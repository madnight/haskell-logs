00:00:23 * Veinor shrugs
00:01:58 <Veinor> time to install hlint and run it on my code
00:02:34 <kmc> ♥ hlint
00:02:56 <Veinor> I dare say I might be approaching a 0.1 release soon :O
00:03:39 <silver> congratz :)
00:06:39 <arcatan> Veinor: what are you going to release?
00:06:48 <kmc> the hounds!
00:07:27 <Veinor> arcatan: twitter bindings that use oauth
00:07:36 <arcatan> 0.1 hounds sounds like a hound puppy
00:07:39 <Veinor> http://github.com/veinor/askitter/blob/master/Web/Twitter.hs anybody mind taking a look real quick and telling me if I'm doing something horrible?
00:07:40 <arcatan> oh, nice
00:08:22 <Veinor> I haven't implemented anything involving, like, following/unfollowing people or doing anything other than getting timelines and posting updates
00:08:36 <Veinor> but I figure that'll be easier
00:08:59 <Eduard_Munteanu> I swear, some day somebody at school will ask me for the source code of my homework, and not only it will be written in that obscure language, but will also be plagued by squares.
00:09:30 <Veinor> squares?
00:09:36 <Veinor> good idea, I should use unicode lambdas
00:10:01 <Eduard_Munteanu> Veinor: yeah, those squares you get when you can't read unicode on your terminal :)
00:10:14 <Veinor> :D
00:10:26 <Veinor> anyway, maybe I should ask for code review when more people are awake
00:11:02 <aruns>  hi whats the haskell way of creating a loop and reading a value from Net () till a specific value is received ?
00:11:17 <Veinor> aruns: what do you mean?
00:11:22 <Veinor> what is Net () in this case?
00:11:29 <Veinor> ... oh, I know what I need now. haddock documentation!
00:11:40 <Eduard_Munteanu> I figure it's some fictional monad for IO on sockets.
00:12:20 <Eduard_Munteanu> I assume same semantics could apply as in the IO case.
00:12:26 <aruns> Veinor: i'm trying to modify the roll your own IRC bot script. Net turns out to be a type ReaderT Bot IO 
00:12:43 <aruns> Bot is a data type with socket handle and starttime
00:12:54 <Veinor> ah
00:12:57 <Eduard_Munteanu> You could opt for lazy IO or safer lazy IO variants.
00:13:36 <Eduard_Munteanu> IIRC Oleg has done something for safer lazy IO (i.e. a la "interact"), I can't remember the name.
00:14:13 <aruns> the server i am connecting to first expects a PONG response to its PING, before doing anything else. the current IRC bot starts responding to pings only after it sets things like nick etc. so i'd like it to first respond with a pong then set nick , join channel etc.
00:14:57 <Veinor> could you link me to the 'roll your own' script?
00:15:18 <aruns> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
00:16:38 <Axman6> that's not a script, it's a program! :O
00:16:46 <Veinor> :P
00:16:55 <Veinor> hm, I dunno; I don't have a lot of practice with IO-y stuff
00:17:28 <aruns> ok
00:17:47 <arcatan> aruns: basically you want something like the listen function, but without the forever and with explicit looping
00:18:27 <arcatan> (explicit looping = explicit recursion)
00:21:46 <arcatan> aruns: something like this: http://hpaste.org/40890/wait_for_ping
00:21:56 <aruns> ok arcatan: having a look
00:21:59 <Veinor> ..bah, I just realized that hs-twitter uses Web.Twitter for its module name as well. but hs-twitter also doesn't work
00:22:08 <Veinor> this could be a problem
00:22:29 <dolio> Oh man, bold!
00:22:36 <dolio> Get the banhammer!
00:22:40 <Veinor> :P
00:22:47 <aruns> ahh right!
00:22:50 <aruns> thanks arcatan
00:23:25 <Veinor> so, I could just upload it and say 'haha sucks to be you'
00:23:28 <merijn> GHC 6.12 garbage collector no longer pauses all threads during garbage collection, right?
00:23:33 <Veinor> or I could rename it Web.OAuthTwitter
00:23:47 <Veinor> ... or Web.Askitter
00:24:26 <dolio> merijn: I think it has concurrent minor collections, but major collections still stop everything.
00:25:12 <Veinor> how badly will I annoy people if I upload it as Web.Twitter vs Web.Askitter?
00:25:25 <Veinor> ... probably a lot, given that the APIs for askitter and hs-twitter aren't compatible
00:25:44 <Veinor> but hs-twitter doesn't work anyway!
00:27:01 <arcatan> you maybe should ask the mailing lists (or Sigbjorn Finne, the author of hs-twitter) for a more well-informed opiniion
00:27:07 <Veinor> true
00:29:09 <kmc> it only really matters if people want to use both modules in the same cabal project
00:29:40 <Veinor> right
00:29:59 <Veinor> I think I'll ask him if he has plans to fix it
00:30:01 <kmc> if you think it's a full replacement, like transformers + monadsfor mtl, it's less bad
00:30:07 <kmc> + monads-fd*
00:47:29 <hvr> if I have a "foo -> Either String Int", what's the easiest way to lift it into a "foo -> ErrorT String IO Int"?
00:50:06 <kmc> :t either throwError return
00:50:07 <lambdabot> forall a (m :: * -> *) a1. (MonadError a m) => Either a a1 -> m a1
00:50:59 <daryoush> how do i define a type in ghci?  for example   xxx :: Int -> Int.  When i do that in ghci, I get xxx not in scope
00:51:21 <kmc> you can't
00:51:22 <hvr> kmc: thx, I was wondering whether there was some builtin lift-operation somewhere
00:51:27 <kmc> you can't define a type in ghci
00:51:30 <kmc> but that's not defining a type
00:51:36 <kmc> you're giving a type signature for a value
00:51:41 <kmc> you can do:  let x :: Int; x = 3
00:51:42 <kmc> in ghci
00:51:48 <kmc> but you might be better off writing and loading a file
00:51:55 <kmc> hvr, not to my knowledge
00:52:39 <hvr> kmc: so that's the way I'm supposed to work with ErrorT if I want to mix it with pure Either computation?
00:53:30 <daryoush> kmc, thks
00:53:38 * hvr is trying to get rid of Either-staircasing within some IO () monad
01:10:05 <merijn> hmm, doesn't STM violate sequential consistency?
01:13:34 <Axman6> merijn: violate what?
01:15:23 <merijn> Axman6: Sequential consistency, its a consistency model for concurrent systems. It states that given a begin state A, an end state A' and a set of steps B, then there is AN ordering of B which transforms A into A'
01:15:42 <merijn> Its the most common/simple consistency model in use
01:16:03 <Axman6> how does STM not provide that?
01:16:40 <maurer_> Wow. I just spent 8 hours hunting down a hardcoding bug.
01:16:48 <maurer_> :/
01:17:43 <merijn> Axman6: Well, if thread A starts a transaction in state 1 and thread B also enters a transaction in state 1, now A finishes and updates the state to 2. Now B finishes and updates to state 3.
01:18:10 <merijn> Axman6: Now there is no guarantee there is an ordering of A B which results in state 3
01:18:25 <merijn> i.e. an action has disappeared
01:18:28 <Saizan> merijn: B will rollback if it has read something that A modified, otherwise it doesn't matter
01:18:47 <Axman6> merijn: not at all
01:18:52 <Saizan> (assuming A committed first)
01:19:00 <merijn> Saizan: So if A finishes before B then B restarts?
01:19:12 <Axman6> both transations will always be run, uless you tell it not to
01:19:21 <Saizan> merijn: yeah
01:19:26 <merijn> Oh well, guess that's what I get for skimming explanations >.>
01:19:31 <Axman6> B restarts if A modified any variables B was using
01:37:08 <merijn> In a non-threaded executable, will doing a blocking socket operation inside forkIO block all threads?
01:39:03 <kmc> meaning you didn't compile with -threaded?
01:39:30 <kmc> the IO manager might handle it anyway
01:39:40 <kmc> in general blocking FFI calls will block all threads if you don't use -threaded
01:40:46 <merijn> kmc: That's what I figured
01:44:21 <maurer_> > catch (return (1 `div` 0)) (\e -> return 0)
01:44:22 <lambdabot>   <IO Integer>
01:44:46 <maurer_> Well, in any case, that computation still seems to generate an exception. What am I doing wrong?
01:44:56 <kmc> nothing to force evaluation within  the scope of "catch"
01:45:17 <kmc> you can use Control.Exception.evaluate :: a -> IO a
01:45:20 <kmc> in place of return
01:45:24 * maurer_ tries this
01:45:33 <kmc> or various tricks with seq, ($!), etc
01:47:50 <maurer_> Hm. "evaluate" fixes my toy example, but my real version still doesn't work.
01:48:28 <maurer_> I'm attempting to simulate 32-bit operations, but not perform them if they would cause an exception.
01:48:47 <chrisdb> presumably evaluate just goes to whnf?
01:48:59 <chrisdb> It might not be enough for complex data structures.
01:49:02 <maurer_> As a result, I have (hackishly) put this inside unsafePerformIO
01:49:22 <maurer_> Maybe if I 
01:50:13 <chrisdb> You could try using deepseq and making your data structure a member of the NFData class. That's just a guess... I'm not an expert on Haskell.
01:50:14 <maurer_> chrisdb: Thanks, that was the problem.
01:50:30 <maurer_> chrisdb: I just applied evaluate to the inner Int32, then built the structure.
01:51:09 <kmc> deepseq is a blunt instrument
01:51:19 <kmc> traversing a whole expression tree is slow
01:51:44 <kmc> you could also use a ! on your datastructure's field
01:52:00 <maurer_> My data structure shouldn't always be strict though
01:52:04 <kmc> ok
01:52:15 <maurer_> In this case, it's just ITerm $ IConst foo, so evaluating foo manually is fine.
01:52:45 <maurer_> (This is just a constant folder for a compiler, so the only fancy thing going on here is that it needs to preserve exception raising behavior)
01:53:15 <chrisdb> kmc: I guess it depends whether you need absolutely everything to be evaluated or not?
01:53:27 <kmc> and you're modeling exception-raising behavior by whether a corresponding Haskell function raises an exception?
01:53:40 <kmc> chrisdb, sure, but even if so, you might know that most of it is already evaluated, and avoid the traversal
01:54:44 <kmc> my point is that it's usually better to have your algorithm introduce whnf strictness when necessary
01:54:59 <kmc> rather than ignoring strictness and then doing a full nf pass
01:55:40 <chrisdb> Yes, you're right if you know in advance what state things should be in. 
01:56:19 <chrisdb> I have used deepseq with parmap recently... but I think it would be too complicated to track what actually needs evaluating, and performance is OK, so I don't think I'll change it.
02:03:09 <Accidus> What's the "complexity monad" M x for a given monoid M?
02:03:53 <kmc> i've never heard that term
02:04:02 <Accidus> Google shows me Plotkin's, Power's and Hyland's paper, but it's unreadable to me
02:04:26 <maurer_> kmc: Yes. "quot" and "rem" raise exceptions precisely when the CPU does for this math.
02:07:18 <kmc> how hard is it to write the condition explicitly?
02:07:28 <kmc> is it just "0 denominator" or is there more to it?
02:07:35 <kmc> > 1 `quot` 0
02:07:36 <lambdabot>   *Exception: divide by zero
02:10:40 <MrAI> How do you run:
02:10:42 <MrAI> fac2 :: Int -> Int
02:10:42 <MrAI> fac2 n = prodList [1 .. n]
02:10:42 <MrAI> prodList lst =
02:10:42 <MrAI>   if (length lst)==1 then head lst
02:10:42 <MrAI>   else head lst*(prodList (tail lst))
02:10:49 <MrAI> From the interpreter command line?
02:10:58 <kmc> put that in a file foo.hs
02:10:59 <kmc> ghci foo.hs
02:11:04 <kmc> fact2 7
02:11:12 <kmc> do you want code suggestions?
02:11:18 <MrAI> I tried fac2 6 but didnt work
02:11:34 <kmc> if you're using length, head, and tail together, that's a sign that you should be pattern-matching instead
02:11:42 <kmc> as a beginner you should probably pretend 'head' and 'tail' don't exist at all
02:11:50 <MrAI> Ah ok
02:11:53 <Zao> MrAI: What does prodList do when you run out of tail?
02:11:56 <kmc> you're not handling []
02:12:05 <kmc> here's how I'd start with prodList:
02:12:07 <kmc> prodList [] = ...
02:12:09 <kmc> prodList (x:xs) = ...
02:12:12 <Zao> The error you get should hint you towards what is happening.
02:12:36 <MrAI> The error I get is not in scope
02:12:50 <Zao> > let f (x:xs) = 9001 in f []
02:12:51 <lambdabot>   *Exception: <interactive>:1:153-167: Non-exhaustive patterns in function f
02:13:15 <MrAI> I see kmc
02:13:23 <Zao> You seem to have your then and else on different indentation levels.
02:13:45 <kmc> so that's the first good way to write it: direct recursion with pattern-matching
02:14:02 <kmc> the second improvement is to notice that foldr generalizes this pattern of recursion
02:14:04 <MrAI> When I run the .hs file from the interpreter it runs fine. But when I try to define fac2 with an input, it doesnt like me
02:14:23 <kmc> can you hpaste the actual interaction?
02:14:26 <maurer_> kmc: The problem is there's also an integer overflow condition with division
02:14:30 <kmc> ah, yes
02:14:45 <MrAI> hpaste?
02:14:48 <maurer_> I could test for that manually, but it seems to make more sense to just use the CPU to test for it.
02:14:54 <kmc> MrAI, hpaste.org
02:14:59 <kmc> don't paste code into the channel if it's more than a few lines
02:15:11 <MrAI> My whole code is:
02:15:12 <MrAI> fac2 :: Int -> Int
02:15:12 <MrAI> fac2 n = prodList [1 .. n]
02:15:12 <MrAI> prodList lst =
02:15:12 <MrAI>   if (length lst)==1 then head lst
02:15:12 <MrAI>   else head lst*(prodList (tail lst))
02:15:15 <Zao> ...
02:15:17 <kmc> there it goes again
02:15:24 <Zao> MrAI: There's a reason why we recommend paste sites, you know.
02:15:31 <Zao> Well, several, actually.
02:15:33 <kmc> don't paste code into the channel if it's more than a few lines
02:15:44 <MrAI> I thought 'few' was a relative term :s
02:15:47 <kmc> it is
02:15:50 <Zao> Highlighting, referencing it while the chat scrolls away, less eyesore, less disturbance.
02:15:50 <kmc> if you want an exact number i've heard 2 to 4
02:15:53 <kmc> but 5 is more than 2 to 4
02:15:55 <kmc> anyway
02:16:01 <kmc> your code is already halfway off my screen
02:16:05 <kmc> which is why you should use the paste site
02:16:16 <Zao> If what you paste has indentation, it's probably not something fit for inline :)
02:16:25 <kmc> i think you should rewrite that code to not use 'head', 'length', or 'tail'
02:16:43 <Zao> genericHead, genericLength, genericTail? :D
02:16:50 <kmc> ;P
02:16:51 <Zao> (first and last don't exist, but meh)
02:17:04 <MrAI> http://hpaste.org/40891/a
02:17:11 <MrAI> haha ok ill give that a go kmc
02:17:21 <damike84> hi
02:17:26 <maurer_> MrAI: Are you aware of foldl?
02:17:28 <kmc> hi damike84
02:17:34 <damike84> how can i acces the 4th element of an array?
02:17:43 <maurer_> damike84: arr ! 4
02:17:45 <damike84> access
02:17:45 <maurer_> err
02:17:46 <Zao> damike84: Depends on what you mean by "array"
02:17:48 <maurer_> arr ! 3
02:17:51 <kmc> damike84, by array do you mean list?
02:17:53 <kmc> or do you mean array?
02:17:54 <damike84> maurer_: hmm
02:18:00 <MrAI> Im new to haskell, I'd like to not use any features beyond what functional programming basics provide
02:18:04 <maurer_> I'm going to assume he means an Array, until he proves to not know what he's talking about
02:18:06 <Zao> If by array you mean Array, ! with the Ix.
02:18:14 <damike84> ugs> [1..3]!2
02:18:14 <damike84> ERROR - Undefined variable "!"
02:18:14 <kmc> technically an array can have any starting index, so the fourth element could have any value
02:18:18 <maurer_> MrAI: foldl is a functional programming basic
02:18:21 <kmc> that's a list, not an array
02:18:24 <kmc> use !!
02:18:26 <kmc> but, better yet, don't
02:18:27 <damike84> ok thx
02:18:30 <kmc> because lists aren't made for random access
02:18:33 <maurer_> > foldl1 (*) [1..5]
02:18:37 <Zao> damike84: What happens if the list is too short?
02:18:40 <kmc> if you need random access, use Data.Map or Data.Sequence
02:18:48 <lambdabot>   120
02:18:52 <Zao> > [] !! 0
02:18:53 <damike84> Zao: good question ;)
02:18:53 <lambdabot>   *Exception: Prelude.(!!): index too large
02:18:56 <kmc> MrAI, if you like, you can define foldr yourself in a few lines
02:18:57 <kmc> @src foldr
02:18:57 <lambdabot> foldr f z []     = z
02:18:57 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:19:04 <kmc> note that this looks a lot like your prodList
02:19:08 <kmc> but generalized to arbitrary f and z
02:19:12 <kmc> rather than (*) and 1
02:19:20 <maurer_> In fact, prodList = foldl1 (*)
02:19:41 <MrAI> Ok, *finds out what fold does*
02:19:50 <Zao> damike84: Note that to get to the fourth element, you have to step over the cold dead bodies of elements 1-3.
02:20:20 <kmc> > foldr (+) 0 [x,y,z]
02:20:21 <lambdabot>   x + (y + (z + 0))
02:20:22 <kmc> MrAI, ^^^^
02:20:33 <kmc> > foldr f z [a,b,c]
02:20:34 <lambdabot>   f a (f b (f c z))
02:20:51 <maurer_> That's a really cool feature--didn't know lambdabot could do that.
02:20:57 <kmc> it's a basic sort of way to reduce a list by applying a binary operator
02:21:03 <kmc> in fact it's called 'reduce' in some other languages
02:21:07 <sipa1024> > a-a
02:21:11 <kmc> maurer_, yep http://hackage.haskell.org/package/simple-reflect
02:21:11 <MrAI> ok
02:21:20 <shachaf> Hmm. Is it possible to make reverse lazier?
02:21:20 <sipa1024> > a - 0
02:21:34 <maurer_> shachaf: If you need that, look at Data.Sequence
02:21:37 <sipa1024> > toInteger (a - 0)
02:21:52 <shachaf> maurer_: I don't need it; I'm just wondering.
02:22:02 <MrAI> I see now
02:22:08 <maurer_> shachaf: If you think about a list as being a cons list, you will quickly realize that accessing the last element requires accessing all elements before
02:22:17 <shachaf> maurer_: Yes, I know that.
02:22:22 <lambdabot>   a - a
02:22:22 <lambdabot>   a - 0
02:22:22 <lambdabot>   *Exception: not a number
02:22:25 <shachaf> maurer_: But you should still be able to look at its *structure*.
02:22:27 <MrAI> But if I need the list result of fib to use later, foldl1(*) doesnt seem the way to go
02:22:33 <maurer_> shachaf: How?
02:22:44 <shachaf> maurer_: A list of N elements still has N elements when reversed.
02:22:44 <kmc> reverse doesn't force the cars of the list, does it?
02:22:54 <maurer_> shachaf: How do you know it has n elements?
02:22:58 <maurer_> kmc: No, it doesn't.
02:23:05 <maurer_> MrAI: Try this
02:23:05 <shachaf> maurer_: You know it has >= 1 once you've looked at the first element.
02:23:29 <kmc> so you'd produce a cons right away, but have its car depend on elements not yet seen
02:23:31 <kmc> clever
02:23:33 <maurer_> > scanl1 (*) [1..5]
02:23:34 <lambdabot>   [1,2,6,24,120]
02:23:55 <shachaf> kmc: Is there a reasonable way of writing that in Haskell?
02:23:59 <maurer_> So you can do
02:24:05 <MrAI> Ah interesting
02:24:11 <kmc> kind of odd though; it means you could match «reverse (0:1:⊥)» against (x:xs) and not fail
02:24:15 <kmc> seems wrong
02:24:15 <maurer_> > let facts = scanl1 (*) [1..] in facts !! 5
02:24:16 <lambdabot>   720
02:24:58 <shachaf> kmc: Hmm... I suppose. Do you think reverse (0:1:⊥) should be guaranteed to be ⊥?
02:25:11 <MrAI> > show 'a'
02:25:11 <lambdabot>   "'a'"
02:25:14 <MrAI> hehe
02:25:35 <kmc> shachaf, i think so
02:25:53 <kmc> it's still a cool idea
02:26:01 <kmc> but i'd hesitate to say it has the right semantics for 'reverse'
02:26:30 <shachaf> kmc: From the Prelude: -- reverse xs returns the elements of xs in reverse order.  xs must be finite.
02:26:34 <kmc> oh, heh
02:26:34 <MrAI> Is there a website that has haskell programming challenges?
02:26:47 <kmc> MrAI, a lot of people solve Project Euler problems
02:26:52 <kmc> however they don't exercise very much of the language
02:27:03 <shachaf> kmc: Anyway, even if it doesn't make sense to do it this way, what would be a reasonable way to write it? :-)
02:27:10 <kmc> there's lots of programming-challenge websites
02:27:13 <MrAI> Yes I solve Euler myself, but they are very problamatic in there own right
02:27:15 <kmc> which either don't care what language you use
02:27:17 <kmc> or support Haskell
02:27:22 <kmc> or you could solve in Haskell even if you can't upload
02:27:39 <MrAI> Im looking for something similar to http://codingbat.com/
02:27:50 <kmc> MrAI, if you're looking for exercises i like http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html particularly Lab 1-3
02:28:01 <mm_freak_> MrAI: PE problems usually are more like "think enough, so the code gets trivial" problems
02:28:12 <kmc> that's good training for Haskell though
02:28:13 <mm_freak_> there is always a brute force solution, but it's not what it's about
02:28:30 <kmc> but yeah, PE is about math as well as programming
02:28:35 <MrAI> Thanks for that link kmc
02:28:51 <MrAI> I have limited (High School Adv. Higher) math background
02:29:11 <MrAI> But I have solved alot of PE problems
02:29:32 <MrAI> I can write programs that work in Java, but I have no idea how they work, lol
02:29:51 <kmc> well, what do you mean by "how they work"?
02:30:02 <kmc> do you mean that Java gives you little confidence that your code is correct?
02:30:15 <maurer_> MrAI: Solve two problems at once. Write a java compiler in Haskell.
02:30:17 <kmc> or do you mean that the Java execution model is very far removed from the real workings of the machine?
02:30:34 <danderson> because if it's the latter, haskell isn't going to be much help :)
02:30:37 <MrAI> I can throw code into Java and it gives me what I am looking for, without an understanding of what my code does. I just know what to write
02:30:37 <mm_freak_> MrAI: http://projecteuler.net/index.php?section=problems&id=15
02:30:41 <mm_freak_> this is a very interesting problem
02:30:55 <MrAI> Ah that one was fun
02:30:58 <kmc> MrAI, so you're programming Java by intuition?
02:31:00 <MrAI> Once you realise something
02:31:01 <MrAI> Yes
02:31:02 <kmc> or by memorization?
02:31:02 <mm_freak_> you can solve it using a lazy Array and sharing in haskell to get a very efficient and very elegant solution
02:31:04 <kmc> heh
02:31:12 <kmc> it's not surprising
02:31:13 <shachaf> mm_freak_: That's a pencil-and-paper problem.
02:31:21 <kmc> i'm surprised you can make large programs work that way, though
02:31:28 <MrAI> I know its weird
02:31:38 <MrAI> I program in Java with feeling, lol
02:31:51 <mm_freak_> shachaf: sure, but that's not the point
02:32:33 <sipa1024> MrAI: it's called experience :)
02:32:56 <kmc> Java gives you a lot of structure
02:33:05 <kmc> in that you have to write pages of boilerplate before anything works
02:33:07 <mm_freak_> MrAI: i find the most interesting problems involve networks and concurrency…  there you'll be exposed to the true power of haskell =)
02:33:13 <MrAI> :) But after finding Haskell/Agda Java feels so wrong
02:33:30 <kmc> in Haskell you have to think a lot and write very little, which is intimidating and makes one feel stupid
02:33:34 <MrAI> Yes
02:33:35 <MrAI> !
02:33:47 <kmc> and you have to think up front, rather than pounding out code and then chasing bugs
02:34:05 <MrAI> I read that the first time and laughed. But it really is the case :s
02:34:07 <kmc> and in some ways, the psychological structure of pounding out code and chasing bugs is a lot more rewarding than getting it right the first time
02:34:20 <MrAI> It feels like your doing something
02:34:27 <mm_freak_> kmc: that's true, if people write type signatures first, but if not, some errors can slip through
02:34:40 <mm_freak_> personally i write a type signature for almost everything, which has a name
02:34:41 <kmc> oh i mean, Haskell programs still have plenty of runtime bugs
02:34:49 <kmc> just an order of magnitude less than other languages
02:34:49 <MrAI> I know what kmc meant
02:34:56 <kmc> mm_freak_, even in let/where?
02:35:00 <kmc> what about do? what about lambda?
02:35:04 * MrAI is in zone kmc just described
02:35:09 <mm_freak_> kmc: yes
02:35:14 <kmc> wow
02:35:16 <mm_freak_> but not lambda or do bindings
02:35:36 <MrAI> brb
02:35:48 <kmc> i write sigs at top level only
02:36:01 <kmc> unless i get confusing errors or have some really maddening situation
02:36:05 <mm_freak_> dunno, i find them very useful, when i read my code weeks later
02:36:08 <kmc> or i'm using extensions that require them, or have ambiguity
02:36:18 <kmc> i wish it were easier to ask for the type of a let/where bound expression
02:36:31 <kmc> i think scion can do it, but ghci has no interface
02:37:03 <mm_freak_> kmc: that's why i always write my type signature before writing the actual definition
02:37:23 <mm_freak_> that way i mostly get compiler errors, where in some places others would get run-time oddities
02:37:49 <kmc> can you give a good example where not writing sigs in let/where is dangerous?
02:38:02 <kmc> i'm sure they exist but i think i'm rarely burned by my policy
02:38:05 <kmc> however perhaps i just don't see it
02:38:16 <Jafet> I write the definition, then try -fglasgow-exts first, then write signatures
02:38:40 <kmc> haha
02:39:08 <mm_freak_> kmc: not really, sorry
02:39:14 <mm_freak_> lol Jafet 
02:39:35 <mm_freak_> Jafet: if an extension solves your problem, then GHC lets you know ;)
02:39:43 <kmc> not always
02:39:51 <mm_freak_> though those suggestions can be weird sometimes
02:40:19 <kmc> ghc gives lots of bad advice
02:40:28 <kmc> "Probable fix: Add an instance for Num (a -> b)"
02:41:22 <Jafet> Meh, lambdabot has an instance for Functor Num, or something
02:41:32 <kmc> yeah well
02:41:38 <kmc> if lambdabot does it, it must be a good idea?
02:41:40 <kmc> @. elite nixon
02:41:40 <lambdabot> the pResIDENcy |-|Az m4NY prO81eM$, bU7 BoRedO/\/\ i$ 7he LeA5t Of T|-|e/\/\.
02:42:07 <mm_freak_> well, the instance is quite useful
02:42:12 <mm_freak_> but it's a hack
02:42:18 <mm_freak_> because:
02:42:23 <sipa1024> > ((+) + (*)) 9 9
02:42:23 <lambdabot>   99
02:42:35 <sipa1024> > (9+9) + (9*9)
02:42:36 <lambdabot>   99
02:42:38 <mm_freak_> > (+1) == (+2)
02:42:39 <lambdabot>   *Exception: (==): No overloading for function
02:42:54 <sipa1024> why does Num require Eq anyway?
02:43:03 <kmc> hysterical raisins
02:43:16 <kmc> i don't know, really
02:43:37 <mm_freak_> yeah, that really sucks
02:43:45 <kmc> Show too
02:43:55 <mm_freak_> yes, both of them suck
02:44:25 <kmc> life is hard
02:44:35 <mm_freak_> writing a Num instance for Num a => a -> a gets just as difficult as writing a Num instance for Integral a => a -> a for modular arithmetic
02:44:54 <mm_freak_> newtype Mod a = Mod (a -> a)
02:45:13 <mm_freak_> instance Eq (Mod a) where _ == _ = undefined
02:45:26 <merijn> How could Eq ever not be defined for Num? That makes no sense
02:45:49 <kmc> well, the case under consideration is functions
02:46:10 <kmc> you can define most of the Num methods for (Num a) => (b -> a)
02:46:17 <kmc> but you can't define show or (==)
02:46:26 <mm_freak_> merijn: i just gave an example
02:46:51 <mm_freak_> you can define all Num methods for (Mod a), but you can't define Eq methods
02:47:11 <sipa1024> why not?
02:47:23 <merijn> mm_freak_: I didn't mean "How could that ever be coded", I meant "How could that ever be semantically valid and not make me want to slap the programmer writing it?"
02:47:24 <mm_freak_> sipa1024: how would you define equality of functions?
02:47:52 <sipa1024> mm_freak_: equality of functions a agree, but you are taking about modulo arithmetic?
02:48:00 <sipa1024> *i
02:48:17 <kmc> type (Mod a) represents modular arithmetic without fixing the modulus, yes?
02:48:28 <sipa1024> ah
02:48:29 <kmc> it wraps (a -> a) in which the arg is a modulus?
02:48:33 <mm_freak_> sipa1024: yes, i think the most straightforward implementation of modular arithmetic is through a function of the modulus
02:48:36 <mm_freak_> kmc: right
02:48:52 <sipa1024> you'd want the modulus in the type :)
02:48:53 <mm_freak_> that way you can make 'fromInteger' work
02:48:57 <mm_freak_> and also 'fromRational'
02:49:29 <mm_freak_> turning the modulus into a variable makes this impossible
02:49:36 <mm_freak_> and it also makes other functions difficult to write
02:49:50 <sipa1024> @src Mod
02:49:51 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:50:13 <mm_freak_> and also less efficient
02:50:56 <mm_freak_> i tried the following two representations of modular arithmetic:
02:51:18 <mm_freak_> newtype Mod a = Mod { modulus :: a, representant :: a }
02:51:31 <mm_freak_> newtype Mod a = Mod { getMod :: a -> a }
02:51:48 <mm_freak_> the latter has serious benefits, but makes it impossible to write Eq
02:52:13 <kmc> instance Eq (a -> b) where f == g = 0 /= I# (reallyUnsafePtrEquality# f g)
02:52:17 <kmc> problem solved
02:52:20 <kmc> yes that's a real function
02:52:28 <mm_freak_> another way to do it is using implicit configurations, but i don't like that approach a lot and it has the same problems as the (a -> a) method
02:52:41 <sipa1024> @hoogle reallyUnsafePtrEquality#
02:52:41 <lambdabot> No results found
02:52:43 <sipa1024> @hoogle reallyUnsafePtrEquality
02:52:44 <lambdabot> No results found
02:52:53 <kmc> GHC.Prim
02:52:57 <kmc> reallyUnsafePtrEquality# :: a -> a -> Int#
02:53:08 <sipa1024> ok
02:53:16 <mm_freak_> kmc: but it's not the kind of equality or equivalence you would expect in modular arithmetic
02:53:19 <kmc> yeah
02:53:22 <kmc> i'm joking ;)
02:53:26 <mm_freak_> i know ;)
02:53:40 <kmc> ptr equality can be legits useful though
02:54:02 <kmc> to be slightly less dubious i should probably throw in some seq or bang patterns
02:54:25 <kmc> god what happens if there's a gc in the middle of that call
02:54:41 <kmc> maybe it's impossible?
02:55:21 <mm_freak_> kmc: nothing probably…  it may just change the result
02:55:35 <Jafet> Then the realtime embedded people will throw bricks at your window
02:55:46 <kmc> i'm wondering if (reallyUnsafePtrEquality# a a) could return 0 due to an intervening gc
02:55:52 <kmc> but it might be that primops like this are atomic wrt gc
02:55:56 <kmc> since they won't allocate
02:56:28 <kmc> i mean i'll wager that just emits "f == g" in Cmm
02:58:58 <companion_cube> @pl (\f -> join . fmap f)
02:58:58 <lambdabot> (=<<)
03:00:08 <mm_freak_> @pl \f c -> c >>= return . f
03:00:08 <lambdabot> fmap
03:00:13 <mm_freak_> wow
03:00:34 <mm_freak_> the transformation rule set of lambdabot must be huge =)
03:00:42 <mm_freak_> @botsnack
03:00:42 <lambdabot> :)
03:01:09 <mm_freak_> btw, does @pl always succeed?  provably?
03:01:15 <sipa1024> @pl i27279d2hi8g62321
03:01:15 <lambdabot> i27279d2hi8g62321
03:01:21 <sipa1024> @pl i27279d2hi8g6<,2(321
03:01:21 <lambdabot> (line 1, column 15):
03:01:21 <lambdabot> unexpected ","
03:01:22 <lambdabot> expecting white space or simple term
03:01:34 <mm_freak_> sipa1024: given a valid expression ;)
03:02:00 <sipa1024> @botsnack
03:02:00 <lambdabot> :)
03:03:59 <MrAI> let pi = 3.14159 in 2*pi*r1 + 2*pi*r2
03:04:03 <MrAI> oops
03:04:44 <sipa1024> > let pi = 3.14159 in 2*pi*r1 + 2*pi*r2
03:04:45 <lambdabot>   Not in scope: `r1'Not in scope: `r2'
03:13:04 <mm_freak_> haskell should support sections like (+x+y)
03:13:27 <mm_freak_> at least for operators with known associativity
03:13:39 <kmc> :t (+2+3)
03:13:40 <lambdabot>     The operator `+' [infixl 6] of a section
03:13:40 <lambdabot>         must have lower precedence than that of the operand,
03:13:40 <lambdabot>           namely `+' [infixl 6]
03:13:42 <kmc> :t (+(2+3))
03:13:43 <lambdabot> forall a. (Num a) => a -> a
03:14:00 <ziman> :t (+2*3)
03:14:00 <lambdabot> forall a. (Num a) => a -> a
03:14:34 <mm_freak_> :t (^2+1)
03:14:35 <lambdabot>     The operator `^' [infixr 8] of a section
03:14:35 <lambdabot>         must have lower precedence than that of the operand,
03:14:35 <lambdabot>           namely `+' [infixl 6]
03:15:38 <mm_freak_> writing (+1) . (^2) is quite ugly
03:15:52 <mm_freak_> i write lambdas in such cases
03:17:29 <kmc> is (^2) >>> (+1) better?
03:17:38 <mm_freak_> not really =)
03:17:56 <mm_freak_> \x -> x^2 + 1
03:18:09 <mm_freak_> i think only (^2 + 1) would beat this
03:18:23 <mm_freak_> or, well, succ . square
03:18:55 <sipa1024> > (+5+) 1 3
03:18:56 <lambdabot>   <no location info>: parse error on input `)'
03:20:57 <Eduard_Munteanu> > (\x -> + x + 5) 1 3
03:20:58 <lambdabot>   <no location info>: parse error on input `+'
03:21:18 <sipa1024> > (\x -> (+(x+5))) 1 3
03:21:19 <lambdabot>   9
03:22:06 <quicksilver> I don't find (+1) . (^2) ugly, actually
03:22:10 <Eduard_Munteanu> > ((+).(+5)) 1 3
03:22:11 <lambdabot>   9
03:22:13 <quicksilver> eye of the beholder.
03:23:52 <mm_freak_> quicksilver: it gets ugly as it gets part of a larger formula
03:24:17 <mm_freak_> "f x = x^2 + 1" is just nicer than "f = (+1) . (^2)"
03:25:23 <quicksilver> as I say, it's in the eye of the behold.
03:25:31 <tsbo> What is the easiest way to track down a "Prelude.read: no parse" (in a library)?
03:25:40 <quicksilver> I have a very slight preference for the first of those, in that case, yes
03:25:51 <quicksilver> but I'd be quite happy with map ((+1) . (^2)) xs
03:26:04 <quicksilver> and I prefer that (slightly) to map (\x -> x^2 + 1) xs
03:26:08 <quicksilver> although the latter is fine too.
03:26:08 <Accidus> Oh, it appears that the complexity monad for a given monoid M is simply X |-> M x X, and the complexity strong-monad transformer maps: T |-> T(Mx-)
03:35:13 <kmc> mm_freak_, what about #(%^2 + 1)
03:35:34 <kmc> or choose different symbols if you like
03:36:02 <mm_freak_> kmc: that would work, too
03:36:12 <mm_freak_> but then you could introduce that as an alternative lambda syntax in general
03:36:14 <damike84> how can i catch "[1,2,3]!!6" error in an if?
03:36:19 <kmc> right that's what i mean
03:36:20 <quicksilver> damike84: don't
03:36:22 <kmc> damike84, you shouldn't
03:36:28 <quicksilver> damike84: don't use !! if there is any chance it won't work.
03:36:30 <kmc> first of all, lists are not a good random-access structure
03:36:33 <kmc> second, you can check with 'length'
03:36:49 <kmc> third, you can do 'drop 6' and see if the remaining list is nonempty
03:36:55 <kmc> by pattern-matching
03:36:57 <quicksilver> kmc: i'm not convinced that #(%^2 + 1) is any improvement on (\x -> x^2 + 1)
03:37:06 <quicksilver> kmc: (whichever pair of symbols you choose
03:37:12 <kmc> don't name things you don't have to?
03:37:24 <quicksilver> yes, I understand the point
03:37:27 <kmc> every irrelevant detail is extra cognitive overhead
03:37:32 <kmc> i agree it's not a big deal though
03:37:32 <damike84> quicksilver: hmm. but thats bad if the caller has to check if its ok to call the function with some params - than i have duplicate of code :S
04:15:37 <opqdonut> is fromIntegral particularly costly?
04:15:49 <opqdonut> I'm doing some bitfiddling and I have to convert between different Word types and Int
04:16:04 <dcoutts_> opqdonut: ghc does the obvious specialisations
04:16:26 <dcoutts_> opqdonut: if you're worried, look at the core
04:16:30 <opqdonut> i'm looking
04:16:38 <opqdonut> i'm not really good at it...
04:17:16 <dcoutts_> it'll be something like a:  case intToWord# i# of w# -> ...
04:18:19 <opqdonut> I have word2Int#
04:19:01 <opqdonut> quite a lot of it actually
04:20:12 <damike84> if i have a list of Bool - whats the fastest way to count the amount of True's?
04:20:52 <opqdonut> with optimizations on, "length . filter id" is probably as fast as anything
04:21:11 <opqdonut> depending on how you produce the list, you might benefit a lot from stream fusion
04:25:32 <damike84> opqdonut: thx - it works in hugs but not in my skript - i hate it :S
04:26:30 <tsbo> W.r.t. useAsCString in ByteString: does "will be freed automatically" mean it'll be GC'd eventually? Or that useAsCString cleans up before returning?
04:34:02 <quicksilver> tsbo: cleans up before returning
04:34:10 <quicksilver> tsbo: that's why it has that form
04:34:22 <tsbo> quicksilver: Ta.
04:34:37 <quicksilver> useAsCString bs act = do { allocate Cstring; run act; free Cstring}
04:35:25 <damike84> i got "countTrues m (row,col) = toInteger(length(filter((\i->i),(buildList(m (row,col)))))" buildList is [[Bool]] -> (Integer,Integer) -> [Bool]. Why does Hugs doesnt like it? :-(
04:35:52 <damike84> *** Type           : [[Bool]]
04:35:52 <damike84> *** Does not match : a -> b
04:36:11 <quicksilver> donri: (buildList m (row,col))
04:36:17 <quicksilver> damike84: (buildList m (row,col))
04:36:23 <quicksilver> (sorry donri)
04:36:25 <donri> Good to know :)
04:36:32 <quicksilver> damike84: is how you pass two parameters to a function.
04:36:45 <quicksilver> also,
04:36:58 <quicksilver> (filter (\i->i) (buildList m (row,col)))
04:36:59 <damike84> now he says
04:37:00 <damike84> *** Term           : (\i -> i,buildNachbarListe m (row,col))
04:37:00 <damike84> *** Type           : (b -> b,[Bool])
04:37:00 <damike84> *** Does not match : a -> Bool
04:37:05 <quicksilver> you had the parameters wrong for filter too
04:37:11 <quicksilver> filter doesn't take a tuple
04:37:14 <quicksilver> it takes two parameters.
04:38:07 <damike84> toInteger(length(filter((\i->i)(buildList m (row,col))))) doesnt work :(
04:38:24 <damike84> *** Type           : [Bool]
04:38:25 <damike84> *** Does not match : a -> Bool
04:39:19 <Axman6> toInteger . length . filter id. buildList m $ (row,col)
04:39:23 <Axman6> to begin with
04:39:25 <quicksilver> that's not helping him.
04:39:28 <Axman6> much clearer and clearer
04:39:33 <quicksilver> it's important to fix the problem you have
04:39:37 <quicksilver> not completely rewrite the code
04:39:44 <quicksilver> otherwise you don't learn what you did wrong.
04:39:49 <damike84> yes ;)
04:39:58 <quicksilver> damike84: you still have an extra () after filter.
04:40:01 <Axman6> and often making the code more readable is a very good way to see where the problem is
04:40:09 <quicksilver> filter((\i->i)(buildList m (row,col))
04:40:22 <quicksilver> Axman6: you didn't make it more readable. You completely changed it to something completely different.
04:40:29 <quicksilver> damike84: that is calling filter with one argument
04:40:32 <damike84> hmm i thought adding ( ) doesnt have a negative effect?
04:40:49 <quicksilver> ...the argument ((\i->i)(buildList m (row,col))
04:40:57 <quicksilver> damike84: on the contrary, it makes a massive difference.
04:41:06 <quicksilver> f b c -- calls f with two arguments, b and c
04:41:20 <quicksilver> f (b c) -- calls f with one argument, which is the result of calling b with one argument, c
04:41:23 <quicksilver> damike84: see?
04:41:34 <damike84> quicksilver: ahh ok - got it. thx a lot :)
04:41:38 <quicksilver> you're welcome.
04:41:43 <quicksilver> Now, do it the way Axman6 wrote.
04:41:45 <quicksilver> it looks much nicer :)
04:42:10 <quicksilver> well, I'd go for : toInteger . length . filter (==True) $ buildList m (row,col)
04:42:12 <Jonny> Hi
04:42:32 <Jonny> Is there a prelude function to find the first/second/third item in a triple?
04:42:35 <quicksilver> Jonny: no.
04:43:09 <tsbo> This is hideous: (>>= (return . decodeUtf8)) . (BS.packCString . castPtr) :: Ptr Word8 -> IO Text
04:43:09 <Jonny> oh ok
04:43:23 <tsbo> How do I make it suck less (but still be pointless)?
04:43:59 <Axman6> striving to make all code pointless is indeed a pointless exercise ;)
04:43:59 <quicksilver> tsbo: ">>=" with "return ." is normally written fmap
04:44:01 <quicksilver> or liftM
04:44:03 <quicksilver> or <$>
04:44:29 <quicksilver> decodeUtf8 <$> BS.packString . castPtr
04:45:49 <tsbo> quicksilver: thanks. That's much better!
04:46:56 <quicksilver> of course Axman6's right, in general, striving to make code pointless is pointless.
04:47:03 <quicksilver> that example comes out OK though
04:50:37 <damike84> last question for today :) if i applay "map" to an list - can i get the current position of the current mapped element in the list?
04:50:41 <tsbo> I can't get it pointless anyway. I've had to use peekText v = decodeUtf8 <$> (BS.packCString . castPtr) v
04:50:43 <knobo> Is  <$> just infix liftM?
04:51:27 <knobo> or is it more to the story?
04:51:52 <magicman> @src (<$>)
04:51:52 <lambdabot> f <$> a = fmap f a
04:52:16 <tomberek> @src liftM
04:52:16 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:52:20 <Twey> knobo: It's infix fmap
04:52:29 <Twey> Which should be the same as liftM for any sane monad
04:52:57 <Twey> But it's restricted to Applicative rather than the Functor of fmap or the Monad of liftM, though any Monad should really be both
04:53:31 <Jafet> damike: use zipWith
04:53:54 <magicman> @type (<$>)
04:53:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:53:56 <knobo> So in theory I could some times be forced to use liftM..?
04:54:18 <magicman> knobo: Yes. When your Monad instance doesn't have a fitting Functor instance.
04:55:11 <damike84> Jafet: thx
04:55:27 <knobo> Does Monads some times not have a fitting Functor, or is that just when the implementor did not do his job?
04:56:00 <Jonny> Can 'lookup' be used even when the second item in the tuple isn't a character but a string instead?
04:56:01 <magicman> The second one. fmap = liftM is (modulo unlawful monads) a valid definition.
04:56:27 <Axman6> Jonny: huh? lookup works on lists
04:56:34 <Axman6> :t lookup
04:56:35 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
04:56:57 <Jonny> How do I return b as a string though,  not as a 'maybe b'
04:57:16 <Jafet> @hoogle Maybe a -> [a]
04:57:17 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
04:57:17 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
04:57:17 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
04:58:38 <qless> would it be possible for someone to run this program? i get inconsistent output here (MinHugs-Sep2006.exe). a report from someone with the same hugs version would be welcome, to verify this is a hardware fuckup
04:58:48 <qless> http://hpaste.org/40896/x
04:59:09 <Axman6> people still use hugs? :\
04:59:33 <Jonny> we use hugs at college
05:00:00 <koala_man> sounds adorable
05:01:35 <Twey> knobo: In theory, yes, if you have a poorly-designed Monad.
05:02:12 <Twey> Most monads are quite good at providing Functor, though; I'd be less surprised if someone forgot to provide Applicative.
05:02:24 <Twey> (for no good reason)
05:02:28 <qless_> sorry i went away. not sure why.
05:02:35 <qless_> was there a reply?
05:03:06 <Axman6> gwern:  my reply was 'people still use hugs?'
05:03:12 <Jafet> Yes, the usual grumpy antisocials stating they are not amenable to hugs
05:03:14 <Axman6> uh, qless_, not gwern 
05:03:34 <Axman6> antisocials?
05:05:14 <qless_> a run with ghc would be fine, while i see whether ghc will install here. i expect the empty list as output
05:05:20 * hackagebot ip6addr 0.3.1 - Command-line tools to deal with IPv6 Addresses text representation  http://hackage.haskell.org/package/ip6addr-0.3.1 (MichelBoucey)
05:06:04 <Jafet> Only antisocials dis hugs.
05:06:32 <Axman6> do antisocials have girlfriends and go out a lot?
05:07:17 <Jafet> > let qs 0 = 0; qs x = let (q,r) = divMod x 10 in r + qs q; iqs x = if x < 10 then x else iqs (qs x); ok x y = iqs (iqs x * iqs y) == iqs (x*y); n = 1000; ls = [(x,y) | x<-[1..n], y<-[x..n], not (ok x y)] in ls 
05:07:17 <companion_cube> the answer is in the question...
05:07:20 <lambdabot>   mueval-core: Time limit exceeded
05:07:43 <Twey> qless_: What appears to be the problem?
05:07:53 <Jafet> Sure, if they're antisocial about it.
05:07:59 <Twey> In GHC I get a fine empty list.
05:08:10 <Axman6> heh
05:08:23 <qless_> Twey: the most immediate problem is that the winhugs here has inconsistent output and i'd like to know whether it's the hardware
05:08:46 <qless_> i get different non-empty lists on different runs
05:08:54 <Axman6> o.O
05:08:57 <Axman6> purity fail!
05:09:03 <qless_> Twey: thanks for reporting the result []
05:10:01 <Jafet> I'm guessing that code computes a digit sum
05:10:31 <qless_> yes, qs should be ds for "digit sum", and iqs is the iterated digit sum
05:10:33 <Jafet> Recursively, or something something
05:10:54 <Jonny> is there a prelude replace function which replaces an item using a lookup table
05:11:04 <qless_> maybe off-topic, i'm supposed to find out why the result is [] (also for bigger n), and i can't
05:12:18 <Axman6> qless_: just curious, what happens when you make Z Int instead of Integer?
05:12:40 <Twey> How peculiar
05:12:48 <Twey> You think it's the hardware?
05:12:52 <Twey> I guess it could be
05:12:55 <magicman> Empty list here as well... mighty odd...
05:13:01 <quicksilver> I can't conceive why any version of hugs would ever give the wrong asnwer for that program
05:13:04 <magicman> </late to the party>
05:13:10 <quicksilver> it's an extremely simple program.
05:13:18 <Twey> Yeah
05:13:30 <Twey> If it's the hardware I'd expect it to segfault at least some of the time
05:13:42 <Twey> And… probably not run an OS, if you've got corruption that severee
05:13:45 <Twey> s/ee/e/
05:14:36 <qless_> yeah, this is a winxp machine (not maintained by me) and it runs firefox, mirc, hugs without crashing. most peculiar
05:14:45 <theom3ga> o hai
05:14:54 <quicksilver> I suppose buggy 'Integer' library is a possibility
05:14:57 <quicksilver> but seems most unlikely.
05:15:03 <Axman6> qless_: have you tried changing Integer to Int?
05:15:04 <theom3ga> is there a way of inserting an element at the end of haskell list?
05:15:08 <Twey> qless_: Try running it on a modern Haskell environment on the same machine?
05:15:14 <Twey> theom3ga: lst ++ [element]
05:15:20 <qless_> (turns out i don't have enough space here to install ghc :(
05:15:22 <Axman6> theom3ga: (++ [x])
05:15:28 <Twey> theom3ga: But it's sloooow (O(length lst))
05:15:31 <theom3ga> thanks, I was missing the brackets
05:16:03 <Twey> If you're doing a lot of that, consider another data-structure (or just reversing the list might be worth-while, depending on your use-case)
05:16:14 <qless_> Axman6: no, i haven't tried that
05:16:21 <Axman6> can you please?
05:17:02 <qless_> it runs now
05:17:46 <Axman6> unless n gets very large, i don't see a need to not use Int, or Int64 if it's available
05:18:09 <qless_> i see now that i don't overflow Int. thanks for the hint
05:18:35 <Axman6> it should be a hell of a lot faster too hopefully
05:18:46 <qless_> meh, i shouldn't be using someone else's computer. this is pointless.
05:19:28 <qless_> (still waiting for result)
05:19:57 <qless_> Axman6: it's []. thanks
05:22:52 <donri> Is "module... where" special in not requiring indentation or does that simply mean "rest of file" and can technically be used for functions etc?
05:23:32 <quicksilver> donri: it's special.
05:23:34 <donri> And can you have multiple modules in a file if you indent after where?
05:23:36 <donri> Ah. :(
05:23:38 <quicksilver> donri: and a bit surpising.
05:23:41 <donri> Yea.
05:23:56 <quicksilver> donri: the haskell standard doesn't discuss files
05:24:08 <quicksilver> GHC doesn't support multiple modules per file
05:24:11 <quicksilver> another compiler might
05:24:14 <quicksilver> (but, none of them do)
05:24:25 <donri> OK
05:26:43 <Twey> I wish it did :<
05:26:52 <Twey> It would make the lack of record namespacing a *lot* less vexing
05:29:59 <mxc> twey: full agree
05:30:02 <mxc> fully
05:30:30 <mxc> i actually think multiple modules per file  could essentially solve a lot of the gripes about records
05:30:37 <mxc> too
05:30:47 <mxc> oops, didnt read your second comment.. sry to repeat
05:44:38 <Jafet> substrings (x:xs) = map (x:) (tails xs) ++ substrings xs -- terrible
05:44:50 <Jafet> substrings xs = filter (not.null) $ tails xs ++ substrings (take (length xs - 1) xs) -- more sharing
05:45:00 <Jafet> Can anyone suggest a more heap-friendly substrings?
05:45:14 <Cale> Using length is admitting defeat.
05:45:51 <Kaidelong> how about
05:45:55 <Kaidelong> heads >=> tails
05:45:56 <Kaidelong> ?
05:46:13 <Cale> That's different from this
05:46:51 <Cale> This is a pretty weird definition of "substrings"
05:47:40 <Jafet> Well, it excludes "".
05:48:53 <Cale> > let substrings [] = [[]]; substrings (x:xs) = map (x:) (tails xs) ++ substrings xs in substrings "abcde"
05:48:54 <lambdabot>   ["abcde","acde","ade","ae","a","bcde","bde","be","b","cde","ce","c","de","d...
05:48:58 <Kaidelong> > (inits >=> tails >=> filter (not . null) >=> nub) "foo"
05:48:58 <lambdabot>   Couldn't match expected type `[a]'
05:48:59 <lambdabot>         against inferred type `GHC.Types...
05:49:28 <Cale> > let substrings [] = [[]]; substrings (x:xs) = map (x:) (tails xs) ++ substrings xs in length (substrings "abcde")
05:49:28 <Kaidelong> more
05:49:29 <lambdabot>   16
05:49:37 <Kaidelong> :more
05:49:39 <Cale> > let substrings [] = [[]]; substrings (x:xs) = map (x:) (tails xs) ++ substrings xs in length (substrings "abcdefg")
05:49:40 <lambdabot>   29
05:49:47 <Cale> ^^ weird
05:50:00 <Cale> > let substrings [] = [[]]; substrings (x:xs) = map (x:) (tails xs) ++ substrings xs in substrings "abcdefg"
05:50:01 <lambdabot>   ["abcdefg","acdefg","adefg","aefg","afg","ag","a","bcdefg","bdefg","befg","...
05:50:22 <Cale> > let substrings [] = [[]]; substrings (x:xs) = map (x:) (tails xs) ++ substrings xs in subsequences "abcdefg" \\ substrings "abcdefg"
05:50:23 <Jonny> if I have a point on an x,y plane and i know its orientation, if i want to move it forward 1 unit, how do I use trig to find out its new coordinates
05:50:23 <lambdabot>   ["ab","ac","bc","abc","ad","bd","abd","cd","acd","bcd","abcd","ae","be","ab...
05:50:49 <Jafet> Oh, sorry
05:51:05 <Jafet> map (x:) (inits xs) ++ substrings xs -- writing this from memory
05:51:25 <Cale> Jonny: The point at the unit circle which makes an angle t (counterclockwise) with the positive x axis has coordinates (cos t, sin t)
05:51:38 * hackagebot practice-room 0.0.2 - Practice Room  http://hackage.haskell.org/package/practice-room-0.0.2 (JinjingWang)
05:51:45 <Kaidelong> @hoogle filter
05:51:46 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
05:51:46 <lambdabot> Data.ByteString filter :: (Word8 -> Bool) -> ByteString -> ByteString
05:51:46 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
05:51:58 <Kaidelong> @hoogle nub
05:51:59 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
05:51:59 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
05:52:06 <Kaidelong> oh I see
05:52:23 <Kaidelong> > (inits >>= tails >=> filter (not . null) >=> nub) "foo"
05:52:23 <lambdabot>   Precedence parsing error
05:52:24 <lambdabot>      cannot mix `GHC.Base.>>=' [infixl 1] and `Con...
05:52:34 <Kaidelong> > (inits >>= (tails >=> filter (not . null) >=> nub)) "foo"
05:52:35 <lambdabot>   Couldn't match expected type `[a] -> b'
05:52:35 <lambdabot>         against inferred type `[[[a...
05:53:07 <Kaidelong> > ((inits >>= tails) >=> filter (not . null) >=> nub) "foo"
05:53:07 <lambdabot>   Couldn't match expected type `[a] -> m b'
05:53:08 <lambdabot>         against inferred type `[[...
05:53:19 <Kaidelong> err right
05:53:40 <Kaidelong> > ((\x-> inits x >>= tails) >=> filter (not . null) >=> nub) "foo"
05:53:41 <lambdabot>   Couldn't match expected type `[a]'
05:53:41 <lambdabot>         against inferred type `GHC.Types...
05:53:47 <Kaidelong> okay someone help me?
05:54:04 <qless_> (iqs x) and (x mod 9) are congruent (mod 9).  cya..
05:54:18 <Jafet> > (inits >=> tails) "123"
05:54:18 <lambdabot>   ["","1","","12","2","","123","23","3",""]
05:54:30 <Jafet> > nub $ (inits >=> tails) "123"
05:54:31 <lambdabot>   ["","1","12","2","123","23","3"]
05:55:05 <Kaidelong> hmm
05:55:09 <Kaidelong> but isn't nub also an arrow between m a and m b?
05:55:22 <Jafet> Let's not go there
05:57:59 <Kaidelong> oh now I see
05:58:04 <Kaidelong> I forgot what exactly >=> does
05:58:49 <zygoloid> (<=<) is a monadic (.); (>=>) is flip (<=<)
05:59:20 <hpc> <3 kleisli arrows
05:59:27 <hpc> i need to get in the habit of using them more
05:59:30 <Kaidelong> I'm trying to remember why the morphisms were a -> m b
05:59:46 <Kaidelong> as opposed to m a -> m b
06:00:06 <mercury^> It's more general.
06:00:08 <Kaidelong> there was an explanation somewhere
06:00:19 <mercury^> You can create the latter by composing with bind.
06:01:10 <hpc> :t (>>=) . (>>=)
06:01:11 <lambdabot> forall b (m :: * -> *) a b1. (Monad m) => m a -> (m b1 -> (a -> m b1) -> b) -> (a -> m b1) -> b
06:01:23 <hpc> hmm
06:01:53 <hpc> (>>=) . (=<<) looks fun
06:03:24 <mercury^> :t bewbs
06:03:25 <lambdabot> Not in scope: `bewbs'
06:03:42 <Kaidelong> > let (¤) = flip ($) in "abc" ¤ (inits >=> tails) ¤ nub ¤ filter (not . null)
06:03:43 <lambdabot>   ["a","ab","b","abc","bc","c"]
06:05:13 <tomberek> @src nub
06:05:13 <lambdabot> nub = nubBy (==)
06:05:19 <Kaidelong> I don't really understand the preference for right-to-left notation
06:05:21 <tomberek> @src nubBy
06:05:22 <lambdabot> nubBy eq []             =  []
06:05:22 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:05:30 <Kaidelong> I find it inefficient to keep hitting the home key when writing something
06:05:52 <zygoloid> Kaidelong: in a lazy language, "right-to-left" notation means writing the thing which happens first, first
06:06:15 <Kaidelong> okay, but I still don't think that way about my algorithm, even if it is evaluated like that
06:06:25 <zygoloid> (at least with respect to function application -- with operators it's not so clear-cut)
06:06:34 <Kaidelong> left to right has an easy imperative interpretation to the human
06:06:41 <Kaidelong> "do this, then do that"
06:07:27 <EvanR-work> Kaidelong: if you usually read left to right maybe
06:07:33 <Kaidelong> true
06:07:35 <EvanR-work> not everyone does
06:07:48 <Kaidelong> but the ones that don't do not generally use the latin alphabet either
06:08:02 <EvanR-work> neither does haskell!
06:08:04 <EvanR-work> necessarily
06:08:16 <zygoloid> tniop doog a s'taht
06:08:34 <quicksilver> Kaidelong: m a -> m b is not an interesting category. It's just normal composition on a subset of the functions.
06:08:34 <EvanR-work> queue the upside down text
06:08:44 <quicksilver> Kaidelong: a -> m b is a quite different kind of composition.
06:08:55 <Kaidelong> I found the article again quicksilver
06:09:32 <Kaidelong> so I should be fine on that for a little while until I lose it again
06:09:38 <EvanR-work> Kaidelong: sometimes id like to do x >>> f >> g >> h or something similar for that reason, left to right
06:09:47 <zygoloid> (=<<) converts a -> m b into m a -> m b; (. return) converts m a -> m b into a -> m b. the monad laws say those are inverses of each other, i think...
06:10:46 <EvanR-work> er, h g f
06:10:59 <EvanR-work> as opposed so (f . g . h) x
06:11:17 <EvanR-work> x $> h $> g $> f
06:11:27 <zygoloid> @type ((. return) .) . ((.) `on` (=<<))
06:11:28 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> (b -> m b) -> b -> m b
06:11:30 <Kaidelong> or
06:11:31 <Kaidelong> x
06:11:34 <quicksilver> zygoloid: there is no useful function of type (m a -> m b) -> (a -> m b)
06:11:36 <Kaidelong> $> h
06:11:40 <Kaidelong> $> g
06:11:41 <Kaidelong> etc
06:11:46 <Kaidelong> F# uses that style
06:11:53 <Kaidelong> it's very nice looking
06:12:03 <zygoloid> @type (. return) :: Monad m => (m a -> m b) -> a -> m b
06:12:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a -> m b) -> a -> m b
06:12:06 <zygoloid> quicksilver: ^^ ??
06:12:12 <Kaidelong> put each step on its own line
06:12:34 <quicksilver> zygoloid: hmm, you're right.
06:12:58 <quicksilver> there is something missing.
06:13:04 <EvanR-work> Kaidelong: foo at dwelling on syntax
06:13:04 <quicksilver> they can't be inverses.
06:13:15 <EvanR-work> screw the ruby code is beautiful thing
06:13:15 <quicksilver> "m a" is too different from a.
06:13:27 <quicksilver> there can't be an isomorphism between (a -> m b) and (m a -> m b)
06:13:57 <zygoloid> quicksilver: isn't the existence of that isomorphism basically what's special about monads?
06:14:30 <Kaidelong> quicksilver: if there isn't one how would binding be possible?
06:15:09 * quicksilver looks doubtful.
06:15:30 <Kaidelong> oh
06:15:44 <zygoloid> (. return) . (=<<) == \f -> (>>= f) . return == \f x -> return x >>= f == \f x -> f x == id
06:15:48 <Kaidelong> I don't remember the term
06:16:14 <Kaidelong> but for every function a -> m b there is some function m a -> m b
06:16:24 <quicksilver> zygoloid is probably right
06:16:30 <quicksilver> but something about it is surprising to me
06:16:31 <Kaidelong> wait and vice versa
06:16:33 <quicksilver> not sure what I've missed
06:16:44 <zygoloid> (=<<) . (. return) == \f -> (=<<) (f . return) == \f x -> x >>= (f . return) == id
06:16:46 <Kaidelong> f :: m a -> m b
06:16:52 <Kaidelong> g :: a -> m b
06:17:03 <zygoloid> hmm, i'm not so sure about that last step!
06:17:09 <Kaidelong> to get f you go (>>= g) or to get g you go (f . return)
06:17:34 <Kaidelong> that's an isomorphism isn't it?
06:17:45 <quicksilver> the thing is, the ".return" construction doesn't produce all values of "m a"
06:17:52 <quicksilver> it just produces the special case which does nothing.
06:18:03 <quicksilver> can that really be surjective?
06:18:25 <Kaidelong> how are objects defined in this context?
06:18:52 <zygoloid> quicksilver: yes, you're right. (=<<) . (. return) is not in general id
06:19:26 <Kaidelong> well it'd be true for the identity monad
06:19:29 <quicksilver> zygoloid: I think the two are probably an adjunction.
06:19:41 <zygoloid> it sequences the argument before the function, which a general function of type (m a -> m b) need not do
06:19:57 <zygoloid> quicksilver: how appropriate ;)
06:20:31 <mercury^> quicksilver: they are functors between which categories?
06:21:31 <zygoloid> mercury^: between the category of morphisms over Hask and the category of morphisms in the Kleisli category for the monad, i think
06:21:44 <dolio> > let f l = [10 * sum l] in (f [1,2,3], [1,2,3] >>= f . return)
06:21:45 <lambdabot>   ([60],[10,20,30])
06:21:52 <zygoloid> but CT makes my mind melt so i'm not sure ;)
06:21:56 <mercury^> What are the arrows between morphisms in hask?
06:22:17 <BrazilianGirl> como faço para coletar o tempo de execução de mapsort = map  sort   content ? Usando criterion.
06:22:35 * sipa1024 doesn't understand portugese
06:22:49 <BrazilianGirl> excuse
06:22:59 <BrazilianGirl> how do I collect the runtime mapsort = map sort of content? Using Criterion
06:23:17 <mercury^> Heh. Why ask in portugese if you can speak english?
06:23:27 <Kaidelong> looks like machine translation
06:23:58 <BrazilianGirl> I am translating with google
06:24:11 <Kaidelong> I am not sure what you want to do, BrazilianGirl
06:24:20 <zygoloid> BrazilianGirl: there are some examples of using criterion here: http://www.serpentine.com/blog/2009/09/29/criterion-a-new-benchmarking-library-for-haskell/
06:25:28 <BrazilianGirl> zygoloid, Thanks, I'll read
06:26:15 <BrazilianGirl> Ha, I've read this site but can not adapt to my situation
06:27:20 <BrazilianGirl> Content is a list of lists of integers, okay, I want to use a map and a sort for sorting lists and calculate the time spent for this.
06:27:57 <earthy> for each sort separately, or for the entire map?
06:28:42 <BrazilianGirl> for the entire map
06:30:28 <Jafet> Ugh, I want a depth argument to -auto-all
06:30:51 <earthy> okay, something like   main = defaultMain [ bench "map sort contents" $ \n -> map sort (generateContents n) ]   should do the trick
06:31:08 <earthy> where generateContents generates a 'contents' list of lists that is scaled by n
06:33:10 <BrazilianGirl> Ok, thanks, I'll test
06:36:21 <earthy> you could also try [ bench "map sort contents" $ nf (map sort) contents ]
06:36:37 <Kaidelong> has anyone here implemented harmony search in haskell or any other language?
06:37:23 <Kaidelong> I'm guessing I'm going to need a vector of melodies as my main data type
06:38:04 <Kaidelong> just wondering how Data.Vector would deal with melodies that are not themselves flat data types, hopefully by keeping pointers to them?
06:38:15 <earthy> kaidelong: yes.
06:38:21 <earthy> every boxed type is a pointer.
06:38:38 <earthy> and every type is boxed by default
06:38:42 <Kaidelong> so if my melodies are flat then I should use a UVector?
06:38:49 <earthy> um.
06:39:03 * earthy doesn't quite understand the question
06:39:08 <Jafet> I hope this is leading up to a first-class pun
06:39:34 <earthy> kaidelong: you have a datatype for melodies, yes?
06:40:11 <tristes_tigres> hi
06:40:17 <Kaidelong> earthy: well one would be supplied, ideally... but I could say something like a melody is a 32 bit integer if I have to...
06:40:37 <earthy> okay, so, you have a datatype for melodies, an abstract one
06:40:56 <earthy> that means that your melodies are represented somewhere on the heap
06:41:13 <EvanR-work> why do you need an array for a melody
06:41:34 <earthy> the exact representation does not really matter much for putting them into a vector, as the pointers to the representations of melodies can be put in the vector
06:41:45 <Kaidelong> EvanR-work: harmony search works by destructively updating a limited harmony memory bank
06:41:53 <Kaidelong> it also needs random access to that memory bank
06:42:19 <EvanR-work> cases like this it would be interesting to see if theres a nicer functional way
06:42:36 <earthy> and will be, unless you explicitly put the unboxed melodies in the vector
06:42:54 <Kaidelong> EvanR-work: it's meant to optimize genetic algorithms which do have a good functional representation
06:43:12 <EvanR-work> would 'good' mean doesnt need optimizing
06:43:15 <EvanR-work> would not*
06:43:31 <Kaidelong> it means that you can think of it naturally in terms of pure things done to list
06:43:32 <Kaidelong> s
06:43:39 <Kaidelong> not that it is faster than harmony search
06:43:48 <Kaidelong> harmony search converges much faster
06:43:55 <Kaidelong> for most problems
06:44:28 <Kaidelong> earthy: how'd I explicitly unbox something in haskell? hopefully I would know it is flat in advance
06:44:49 <Kaidelong> and also fixed in size
06:45:16 <Kaidelong> perhaps I should just make a separate set of overloads for boxed and unboxed melodies?
06:45:33 <Kaidelong> like they do for arrays, for that matter, so I suppose yes, that's the best solution
06:45:37 <EvanR-work> bah @ doing assembly language in haskell
06:45:51 <earthy> evanr-work: sometimes you want to know your memory layout
06:45:58 <earthy> and want to control it
06:46:03 <earthy> see e.g. ByteArray
06:46:05 <earthy> or Data.Vector
06:46:07 <earthy> ;)
06:46:35 <Kaidelong> there is no reason to waste memory in an implementation of harmony search since it was practically designed from the beginning to not have any issues with that
06:46:55 <Kaidelong> same is true of genetic algorithms actually since you have a fixed population
06:47:59 <Jafet> @faq can Haskell be a portable assembler?
06:47:59 <lambdabot> The answer is: Yes! Haskell can do that.
06:50:06 <earthy> kaidelong: I'd say start out with the simplest representation of melody and vector of melodies and then see what the compiler does to it
06:50:42 <Kaidelong> I suppose I should start out not worrying about what to do with boxed vs unboxed types and just assume it is boxed, yes
06:50:55 <earthy> (and the simplest representation of melody is an abstract datatype with 1 dataconstructor without arguments, and a vector is Data.Vector ;))
06:50:56 <Kaidelong> I still need to write a prototype anyway
06:52:33 <bartavelle> hello, I have a really neawbie question : I'm trying to use ByteString and I can't seem to understand how to use read and show
06:52:46 <bartavelle> manual says it is an instance of show
06:53:16 <earthy> yup. it is
06:53:27 <bartavelle> then i'm baffled :)
06:53:42 <earthy> why? :)
06:53:54 <bartavelle> i'll paste code in 2 minutes
06:54:30 <EvanR-work> > show (Data.ByteString.UTF8.fromString "foobarbaz") 
06:54:31 <lambdabot>   Not in scope: `Data.ByteString.UTF8.fromString'
06:54:54 <bd_> > show (Data.ByteString.fromString "foobarbaz")
06:54:55 <lambdabot>   Not in scope: `Data.ByteString.fromString'
06:55:02 <bd_> huh.
06:55:19 <earthy> > show (Data.ByteString.pack "foobarbaz")
06:55:20 <lambdabot>   Not in scope: `Data.ByteString.pack'
06:55:24 <earthy> wtf?
06:56:38 <bd_> not included in the bot's library list I guess...?
06:56:50 <earthy> must be
06:58:02 <dblhelix> heh, it's earthy :)
06:58:14 <EvanR-work> bd_: fromString does what in Data.ByteString
06:58:16 <dblhelix> earthy: how are you doing?
06:58:20 <quicksilver> :t (BS.pack,BSL.pack)
06:58:21 <lambdabot> ([Word8] -> BSC.ByteString, [Word8] -> BSLC.ByteString)
06:58:34 <quicksilver> imported qualified.
06:58:42 <quicksilver> don't think the UTF8 is imported at all, could be wrong.
06:58:52 <earthy> dblhelix: reasonably. funding of our project got pulled, so the current job is in limbo
06:59:39 <earthy> otherwise I'm fine ;) still hacking haskell ;)
06:59:47 <zygoloid> > show (BS.pack "foobarbaz")
06:59:48 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
06:59:48 <lambdabot>         against inferred type...
06:59:49 <earthy> you? :)
06:59:53 <zygoloid> > show (BSC.pack "foobarbaz")
06:59:53 <lambdabot>   "\"foobarbaz\""
07:00:13 <earthy> vector fabrics treating you well?
07:00:55 <bartavelle> http://pastebin.ca/1973673
07:00:59 <bartavelle> this doesn't compile
07:01:05 <bartavelle> how can i tell it i want bytestring show N
07:01:06 <bartavelle> ?
07:01:23 <dblhelix> earthy: oh. that's unfortunate
07:02:00 <dblhelix> earthy: the funding part, obviously. not the haskell part. ;-)
07:02:01 <bartavelle> and read
07:02:29 <Azrael-> Hi guys -- list question here. How would I generate a list as such:
07:03:19 <Azrael-> [("A","B"),("C","D"), ("(A)", "(B)"), ("(C)","(D)"), ("((A))","((B))")..]
07:03:25 <EvanR-work> bartavelle: bytestring show N ?
07:03:32 <Azrael-> starting with the list [("A","B"),("C","D")]
07:03:43 <earthy> bartavelle: there's no show in that code...
07:03:46 <bartavelle> N was '?', but I have it ok with B.unpack
07:04:01 <bartavelle> yeah i had the same problem with read and show, only pasted the read code
07:04:07 <EvanR-work> just show myByteString
07:04:49 <EvanR-work> let b = fromString "foobar"
07:04:53 <EvanR-work> show b
07:04:56 <EvanR-work> "\"foobar\""
07:05:11 <EvanR-work> weird
07:05:45 <EvanR-work> ah right
07:05:56 <EvanR-work> > read "\"foobar\"" :: String
07:05:56 <lambdabot>   "foobar"
07:06:22 <EvanR-work> read "\"foobar\"" :: ByteString
07:06:25 <EvanR-work> "foobar"
07:06:31 <EvanR-work> bartavelle: ^
07:06:36 <earthy> > let x = read "\"foobar\"" :: String in read x :: ByteString
07:06:37 <lambdabot>   Not in scope: type constructor or class `ByteString'
07:06:45 <earthy> > let x = read "\"foobar\"" :: String in read x :: String
07:06:46 <lambdabot>   "*Exception: Prelude.read: no parse
07:06:49 <quicksilver> bartavelle: you can't use read *on* ByteStrings.
07:07:04 <quicksilver> ByteString has a Read instance, sure
07:07:06 <EvanR-work> :t read
07:07:07 <lambdabot> forall a. (Read a) => String -> a
07:07:11 <quicksilver> but that gives you a function String -> ByteString
07:07:15 <quicksilver> there is no Read :: ByteString -> Int
07:07:21 <quicksilver> (or Double, or whatever your posX is)
07:07:32 <EvanR-work> :t parseInt
07:07:33 <lambdabot> Not in scope: `parseInt'
07:07:54 <bartavelle> ok
07:08:15 <earthy> oh, *right*
07:08:19 <earthy> damned quoting
07:08:50 <EvanR-work> you can do ByteString -> String, then String -> Integer...  read . toString :: ByteString -> Integer
07:09:09 <ManateeLazyCat> Hi all. :)
07:09:53 <earthy> there is however readInt and readInteger
07:10:03 <EvanR-work> :: readInteger
07:10:06 <EvanR-work> :t readInteger
07:10:06 <lambdabot> Not in scope: `readInteger'
07:10:13 <earthy> readInt :: Data.ByteString.Char8 -> (Int,ByteString)
07:10:14 <EvanR-work> isnt that just read?
07:10:17 <earthy> @hoogle readInt
07:10:17 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
07:10:17 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
07:10:17 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
07:10:23 <earthy> @hoogle readInteger
07:10:23 <lambdabot> Data.ByteString.Char8 readInteger :: ByteString -> Maybe (Integer, ByteString)
07:10:23 <lambdabot> Data.ByteString.Lazy.Char8 readInteger :: ByteString -> Maybe (Integer, ByteString)
07:10:45 <EvanR-work> ah, nice
07:10:56 <EvanR-work> gives the 'rest' bytestring
07:11:00 <earthy> uhuh
07:11:10 <dankna> argh, Template Haskell!
07:11:27 <EvanR-work> sucks that read itself isnt Maybe a
07:11:34 <earthy> so the read thingy bartavelle wants can easily be written without the regexps 
07:11:43 <EvanR-work> regex >_<
07:11:45 <bartavelle> yeah i figured that out
07:11:47 <dankna> I "like" how you can never splice things where you want to, so you have to fall back to contructing the AST the hard way
07:11:48 <bartavelle> split works alright
07:12:15 <bartavelle> and now for a really noob question
07:12:35 <bartavelle> is there a way to "printf" in my pure functions for debugging ? or is there some debugging facility already for this 
07:12:36 <bartavelle> ?
07:12:44 <earthy> bartavelle: Debug.Trace.trace
07:12:50 <bartavelle> ok will look it up
07:12:51 <bartavelle> thanks
07:12:58 <ManateeLazyCat> bartavelle: trace
07:13:00 <earthy> (use it *all* the time ;))
07:13:05 <quicksilver> even better is to learn to never use it.
07:13:24 <earthy> well... that'd be nice
07:13:38 <quicksilver> structure your programs so that most of them are pure functions, which can be tested from a REPL like ghic
07:13:41 <quicksilver> ghci
07:13:49 <earthy> but I'm not up to that level of quickcheck magic yet
07:14:02 <quicksilver> then your debugging process consists of entering more and more complex expressions in ghci
07:14:02 <EvanR-work> even IO commands can be tested pretty easily in ghci
07:14:09 <quicksilver> true
07:14:10 <EvanR-work> but require you to provide a context
07:14:16 <quicksilver> and once you find the problem/bug
07:14:22 <quicksilver> you're in a perfect place to turn it into a test case
07:14:27 <earthy> quicksilver: the problem is that interactive 'testing' does not find all corner cases
07:14:30 <quicksilver> because you have the 'problem' expression right there in ghci.
07:14:42 <quicksilver> earthy: I'm talking about tracking down bugs, not finding corner cases.
07:14:47 <earthy> ah, yeah
07:14:47 <EvanR-work> earthy: the idea is that there arent any if you write sane functions
07:14:48 <quicksilver> earthy: in that case that you know there is a bug
07:14:54 <quicksilver> you can (1) use debug.trace (2) use ghci
07:15:00 <EvanR-work> some leave any pattern unmatched
07:15:00 <quicksilver> I find (2) much more pleasant.
07:15:06 <EvanR-work> s/some/dont/
07:15:36 <earthy> noted. still, I often run into the problem that I need to debug some complex datastructure that'd be *hell* to build up by hand using ghci
07:15:49 <EvanR-work> use sane types for the job, if you end up with a list 'you are sure' has two things in it, use a pair (,)
07:15:54 <quicksilver> who says you have to build it up by hand, earthy?
07:15:58 <quicksilver> you can build it up using functions
07:16:05 <quicksilver> the same functions that are used in your real code
07:16:07 <quicksilver> when the real bug happens
07:16:08 <earthy> so I Debug.Trace the show of the datastructure at the point I suspect the bug is
07:16:12 <earthy> and I read that in
07:16:13 * hackagebot SoccerFun 0.1.1 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.1.1 (JanRochel)
07:16:24 <bartavelle> ok, trace is awesome 
07:16:25 <EvanR-work> trace should be a last require
07:16:27 <bartavelle> thanks a lot
07:16:31 <EvanR-work> last resort
07:16:39 <EvanR-work> @quote debug.trace
07:16:39 <lambdabot> No quotes match. There are some things that I just don't know.
07:16:44 <EvanR-work> @quote trace
07:16:44 <lambdabot> Babelfish says: And there you travel: a beam tracer! Naturally, there are many things that ought to be amend.
07:16:45 <bartavelle> :)
07:16:48 <roconnor> @quote oasis
07:16:49 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
07:17:05 <dankna> smirk
07:17:06 <ManateeLazyCat> dcoutts_: Are you still have any code use Gtk/TreeList? We want remove all TreeList modules from gtk2hs repository. 
07:17:23 <earthy> quicksilver: ah, yeah, but if you're doing a lot of transformations of your data, and you have input but no intermediate structures, building the right type of intermediate structure can be cumbersome
07:17:37 <dcoutts_> ManateeLazyCat: I do, but don't worry about it, I have to support an old version of the code anyway
07:18:05 <quicksilver> earthy: I'm sure you're right; normally you can grab the code path that generates the intermediate structure and just run it
07:18:14 * earthy nods
07:18:17 <quicksilver> earthy: but I'm sure there are cases where Debug.trace is more convenient
07:18:18 <EvanR-work> earthy: better have sane constructors
07:18:28 <quicksilver> but, in 6 years of haskell hobby programming I've never met one :)
07:18:48 <EvanR-work> great care helps
07:19:06 <earthy> evanr-work: ever tried to string together 4 transformations of your input in ghci, just to get to the correct transform of the bug-triggering input data? :)
07:19:15 <EvanR-work> and the funny thing is, you feel like you have to be even *more* careful when you leave the oasis, and it actually pays off
07:19:18 <ManateeLazyCat> dcoutts_: We have fix many memory-leak/bugs in ModelView modules, i'm afraid TreeList is buggy to you. :)
07:19:31 <EvanR-work> earthy: input, like user input?
07:19:32 <dcoutts_> :-)
07:19:46 <earthy> evanr: yeah. captured network data, e.g.
07:19:52 <ManateeLazyCat> dcoutts_: Since you have particular project use TreeList, i think best don't remove them. :)
07:20:08 <EvanR-work> earthy: so like were debugging a parser?
07:20:18 <earthy> for instance.
07:20:35 <dcoutts_> ManateeLazyCat: no, if you want to remove it from the new versions then do so. My project uses an old gtk2hs release anyway so it is not a problem for me.
07:20:41 <EvanR-work> if the parser is built from well behaved smaller parsers you can be sure it works
07:20:47 <dcoutts_> ManateeLazyCat: don't keep crufty code for no reason
07:20:58 <earthy> evanr: oh, the *parser* may well work, but the output may be surprising
07:20:59 <EvanR-work> there cant be corner cases
07:21:08 <EvanR-work> whos fault is that, you designed it! ;)
07:21:17 <earthy> 'cause the input may not match the specs :)
07:21:39 <EvanR-work> parser is supposed to account for any input not some well behaved subset
07:22:14 <bartavelle> I now have a tricky (for me) question : I'm reading "real world haskell", and exercice 3 is about the convex hull algorithm
07:22:14 <earthy> oh, yea. the 'surprising output' often is 'parse failure' when you want a well constructed datastructure
07:22:27 <bartavelle> I coudln't find any solution on the internet that actually implemented properly the algorithm
07:22:37 <bartavelle> so i wrote mine, but it's not o(n ln n)
07:22:48 <bartavelle> because i have no clue on how to backtrack properly
07:22:54 <bartavelle> in haskell
07:23:03 <EvanR-work> earthy: i guess ideally you make a best effort to correct errors and provide a log of them
07:23:04 <bartavelle> is there a *working* solution somewhere ?
07:23:12 <bartavelle> ie. something that doesn't get away with a filter
07:23:19 <earthy> evanr: ideally, yes. ;)
07:23:21 <ManateeLazyCat> dcoutts_: Ok, just ask to avoid trouble you. I will remove all TreeList modules in new version. :)
07:23:43 <earthy> in practice, you may need to see what breaks. ;)
07:24:05 <dankna> bartavelle: you are looking for an implementation, but I suspect you're going to have to accept an academic paper instead
07:24:06 <dankna> bartavelle: check the index of the book series _Graphics Gems_ to see if it has that, and also search citeseer
07:24:06 <bartavelle> (btw the first hit on google does the wrong thing and looks like i works in o(n), but i found that in practice its performance was exponential or something, i'm really clueless as to why)
07:24:07 <EvanR-work> in practice i dont read corrupted data
07:24:12 <dcoutts_> ManateeLazyCat: ok, thanks
07:24:29 <earthy> hm. :)
07:24:29 <EvanR-work> thats why html is in its sorry shape
07:24:31 <bartavelle> academic paper is alright if i can learn how to do it properly from it
07:24:35 <earthy> would I had that luxury.
07:24:40 <EvanR-work> you can today!
07:24:45 <Jafet> http://codepad.org/1YdXw6tP
07:24:46 <EvanR-work> quit and become an activist
07:24:51 <earthy> (then again, we're parsing natural language texts... :))
07:24:56 <dankna> bartavelle: well, I'm trying the two searches I just suggested to you now and will give you any interesting results in a moment
07:24:57 <EvanR-work> oh
07:25:01 <EvanR-work> nevermind
07:25:05 <dankna> bartavelle: but I suggest you do them yourself as well :)
07:25:05 <bartavelle> thanks a lot
07:25:08 <bartavelle> heh
07:27:34 <dankna> bartavelle: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.117.405
07:28:41 <bartavelle> ah but this is about the algorithm
07:28:49 <dankna> yeah, wasn't that what you wanted?
07:28:52 <bartavelle> I'm going for graham scan, as suggested in the book
07:28:54 <bartavelle> nope
07:28:58 <dankna> oh hmm
07:29:05 <dankna> I will note that I haven't read the book :)
07:29:05 <bartavelle> I can do it properly o(n ln n) in C
07:29:09 <bartavelle> but have no clue in haskell
07:29:17 <BorisL> how can I define a function app2 :: (ArrowApply a) => a b (a (a b c) c) ? I tried app2 = arr $ \b -> arr $ \f -> app (f, b) , but its type is (ArrowApply a) => a b (a (b -> c) c)
07:29:22 <bartavelle> i wrote a working solution
07:29:22 * hackagebot morfette 0.3.2 - A tool for supervised learning of morphology  http://hackage.haskell.org/package/morfette-0.3.2 (GrzegorzChrupala)
07:29:25 <bartavelle> but it is horribly slow
07:29:48 <dankna> well, why don't you nopaste both your C version (so I can understand what you're trying to do) and your Haskell version for me
07:29:53 <dankna> and I'll look for any obvious gotchas
07:30:26 <bartavelle> didn't write a C version, the algorithm is really simple : http://en.wikipedia.org/wiki/Graham_scan
07:30:33 <bartavelle> my version is : http://www.banquise.net/haskell/graham/graham.hs
07:30:41 <dankna> so this is for the 2D case then
07:30:43 <bartavelle> it is full of haskell noobism, but it does seem to work
07:30:45 <bartavelle> yes
07:31:15 <dankna> okay yeah, I get the algorithm
07:31:18 <bartavelle> all haskell "implementations" i found just filter over the list of points without realizing this could never work
07:31:46 <dankna> indeed - it needs to be a fold, I'd think
07:31:59 <bartavelle> i can't see how
07:32:06 <dankna> actually no
07:32:07 <dankna> it needs to backtrack, I skimmed too fast
07:32:15 <bartavelle> invalidating a poitn could invalidate a previously point you thought valid
07:32:18 <bartavelle> exactly
07:32:49 <bartavelle> i don't know how to backtrack efficiently, i start over all the time
07:32:55 <EvanR-work> points need proof!
07:33:15 <Jafet> It would be fun to write that algorithm pointless
07:33:23 <frerich5> bartavelle: I'm not sure you want to hear it, but it's nice to read Haskell code of other beginners (like me) because it's not so dense :-}
07:33:30 <bartavelle> haha
07:33:57 <bartavelle> yeah it's like when i hear a french man speak english, I understand it better than the native english :p
07:34:54 <PhilRod> hey frerich5!
07:34:58 <frerich5> That's a nice metaphor. I have a C++ background as well and that Haskell code is quite easy to read. I believe some science geek who switches between ML and Clojure and Haskell and whatever for fun would write it differently.
07:35:04 <frerich5> hey PhilRod :-)
07:35:05 <dankna> what's this scan (delete (last sr) pts) here?  delete is going to traverse that entire list, isn't it?
07:35:16 <earthy> no
07:35:35 <frerich5> PhilRod: You're writing software in Haskell? I never realized that!
07:35:36 <dankna> okay, wasn't sure
07:35:45 <earthy> it is only generating a thunk that when the list is next traversed will not show the (last sr)
07:35:53 <dankna> hmmm good then
07:35:55 <earthy> laziness is *powerful*
07:36:01 <bartavelle> oh this is tricky
07:36:01 <dankna> yeah, impressive feature
07:36:30 <PhilRod> frerich5: no, just spent some time trying to learn it for fun and then decided to idle in here because it's active :-) are you doing haskell for your day job?
07:36:34 <ManateeLazyCat> I hope GHC 7 will fix memory problem, it's always freeze my box when compile/link big project...
07:36:43 <dankna> bartavelle: you already said this, but please save me scrolling up and answer again - what is the status of this version you're showing?  it produces correct results but too slowly?
07:36:51 <bartavelle> exactly
07:36:57 <Jafet> It's iterated, though, so you will end up with a nested chain of delete thunks.
07:36:58 <dankna> okay
07:36:59 <frerich5> PhilRod: Nono, unfortunately not. It's still all C/C++/Python here. I'm playing around with Haskell in my private time and try to pick up some things here by lurking :-)
07:37:10 <earthy> jafet: true, that turns nasty quick.
07:37:19 <Jafet> Consider using Map or Set to record the deletions (or remaining points).
07:38:27 <bartavelle> stopRights traverses the list until it turns right, and let you know where it went wrong
07:38:34 <bartavelle> then if it went wrong, the offending point is removed
07:38:40 <bartavelle> and the list traversed again and again
07:38:53 <dankna> how about returning an index from stopRights instead of the point in question?
07:39:09 <ski> > concat (iterate ((map . join (***)) (("(" ++) . (++ ")"))) [("A","B"),("C","D")])  -- Azrael-
07:39:10 <lambdabot>   [("A","B"),("C","D"),("(A)","(B)"),("(C)","(D)"),("((A))","((B))"),("((C))"...
07:39:14 <bartavelle> that would help a bit i suppose but i'll call stopRight again from the beginning
07:39:18 <dankna> hmm
07:39:19 <dankna> actually
07:39:22 <dankna> I think I see your issue
07:39:29 <dankna> you're supposed to backtrack only as far as necesssary
07:39:33 <bartavelle> exactly
07:39:35 <dankna> you're backtracking all the way to the beginning
07:39:38 <bartavelle> no clue on how to do that however
07:39:49 <dankna> stopRights needs to take the information it needs to pick up "in the middle"
07:39:59 <dankna> which will be whatever state it has per-iteration
07:40:09 <bartavelle> hum
07:40:15 <dankna> hmm
07:40:27 <dankna> does it work to just discard the early elements of the list, perhaps?
07:40:41 <bartavelle> well you can't be sure
07:40:50 <bartavelle> they might be invalidated eventually
07:40:51 <ski> Azrael- : ^ was that what you had in mind ?
07:41:07 <earthy> well, in any triple p1 p2 p3 you're always either discarding p2 or continuing with p3, right?
07:41:08 <bartavelle> hum
07:41:27 <bartavelle> well i can discard "p1" later, but yes
07:41:41 <earthy> *how*?
07:41:44 <BrazilianGirl> How to tell if it evaluates all elements of content?  let !mapasort =  rnf $ map  sort   content                       content =[[Int]]
07:41:44 <dankna> the "proof" of complexity (which I find insufficiently formal) on the wiki page
07:41:45 <bartavelle> easily
07:41:53 <dankna> claims that each point is considered at most twice
07:42:07 <bartavelle> p1 could be wrong once you have p2 removed
07:42:08 <bartavelle> hum
07:42:22 <bartavelle> actually most "solutions" I found using google just work like that
07:42:29 <bartavelle> they discard p2 and go on
07:42:33 <earthy> no. p1 can never be wrong, because it was either the start point or reached through a left turn
07:42:44 <bartavelle> it can be wrong easily
07:42:47 <bartavelle> jsut look at that
07:42:50 <bartavelle> http://www.banquise.net/haskell/graham/comparison.png
07:42:58 <bartavelle> this is what happens when you don't backtrack
07:43:24 <earthy> noe
07:43:35 <earthy> this is what happens when you don't delete upon right turns
07:43:45 <bartavelle> they did delete upon right turns
07:43:53 <bartavelle> well better proof
07:43:58 <bartavelle> if doing like you say worked
07:43:58 <ski> convex hull ?
07:43:59 <earthy> then why are there right turns in the blue line? :)
07:44:01 <bartavelle> it would be O(n)
07:44:03 <bartavelle> and it's not :)
07:44:04 <dankna> I think
07:44:27 <dankna> that you couldn't necessarily do this efficiently in C as you believe, either :)
07:44:27 <bartavelle> because they kept going through their list without noticing they created a new right turn
07:44:28 <dankna> yet
07:44:39 <dankna> it would be productive to have some working pseudocode
07:44:43 <bartavelle> in C ?
07:44:53 <dankna> yeah
07:45:04 <ricree> Sorry for the newbish question, but when you're defining a custom type, how do you restrict type variables to a certain class.  Like if I have something like "Data Foo a b = ..."  how do I say that a has to be an Ord?
07:45:07 <bartavelle> I'll do that tonight if I have time, but it seems quite easier to me
07:45:10 <earthy> bartavelle: it wouldn't, because the points need to be sorted in order of angle of line through start point and x axis
07:45:24 <earthy> and sorting is O(n log n)
07:45:33 <quicksilver> ricree: idiomatically, the answer is you don't.
07:45:44 <bartavelle> ok
07:45:47 <quicksilver> ricree: you just put that restriction on the functions that use Foo, as necessary.
07:45:48 <Kaidelong> ricree: you can but you should keep that to function types
07:46:03 <bartavelle> earthy, http://www.fatvat.co.uk/2009/09/graham-scan-in-haskell.html   <-   this does what you are saying
07:46:08 <bartavelle> and this is the thing i graphed
07:46:29 <bartavelle> just do his example
07:46:34 <bartavelle> and add a point in the middle of the square
07:46:37 <bartavelle> you'll see it fails
07:46:53 <ricree> quicksilver:  ok, thank you.  Any particular reason for that?
07:47:09 <dankna> hmm
07:47:19 <dankna> I didn't see that there's pseudocode on the wiki page
07:47:22 <quicksilver> ricree: it doesn't work very well; pattern matching doesn't "give you" the constraint so you don't get to use it.
07:47:29 <dankna> what's that step swap points[M] with points[i]
07:47:35 <quicksilver> ricree: this appears to be a bug in haskell98.
07:47:52 <quicksilver> GHC has an extension (GADT syntax) which allows constraints which work as you would hope
07:47:56 <quicksilver> but still, my advice is don't
07:48:12 <earthy> bartavelle: the 'turn' function in that code seems suspect.
07:48:50 <bartavelle> yeah it sucks
07:49:10 <bartavelle> hum
07:49:11 <ricree> ok.  I'll stick to doing it at function level.  thank you
07:49:14 <bartavelle> no it's quite alright
07:49:16 <dankna> it's keeping the entire list as an array
07:49:21 <bartavelle> thought about another thingie
07:49:32 <dankna> and swapping points to the end of it instead of deleting them
07:49:42 <dankna> bizarre way to choose to do it, but I guess it works ><
07:49:49 <bartavelle> working in place, kinda like a sort
07:49:53 <dankna> yeah
07:50:26 * earthy thinks a bit
07:50:36 * hackagebot yesod 0.6.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.6.0 (MichaelSnoyman)
07:50:50 <dankna> well, I apologize, bart, but I should get back to my own code now.  good luck with this, tell me if you solve it.
07:51:04 <bartavelle> thanks anyway !
07:51:08 <dankna> sure ;)
07:51:09 <earthy> bartavelle: no, the grahamScan function does not do it correctly
07:51:11 <bartavelle> i should go back to work too
07:51:36 <earthy> in p1 p2 p3 p4 if it deletes p2 from p1 p2 p3 it does not reconsider p1 p3 p4
07:51:38 * hackagebot yesod-auth 0.2.0 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.2.0 (MichaelSnoyman)
07:51:53 <bartavelle> exactly
07:51:55 <earthy> which you obviously should
07:51:57 <bartavelle> oh
07:52:13 <earthy> the getTurns is applied in one go
07:52:19 <earthy> not at each point
07:52:37 * hackagebot yesod-examples 0.6.0 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.6.0 (MichaelSnoyman)
07:52:50 <bartavelle> i'm not sure i can see that
07:53:00 <earthy>   grahamScan points = map fst (filter (\(x,d) -> d /= RightTurn) (getTurns sortedPoints)) where
07:53:27 <earthy> getTurns is applied to sortedPoints, and then the result of that is filtered
07:53:35 <bartavelle> yes
07:54:26 <earthy> however, in that case  if you have  p1 p2 p3 p4 p5 p6 and p2 and p3 are inside the hull, then p1 p3 p4 will not be considered and p3 will not be correctly filtered out
07:54:49 <bartavelle> yes
07:54:56 <earthy> because the only triples considered are p1 p2 p3  p2 p3 p4  p3 p4 p5  p4 p5 p6
07:55:34 <bartavelle> that's why you have to compute your turns again once you remove a point
07:55:46 <earthy> ah!
07:55:49 <bartavelle> my problem is that i re compute them all from the beginning, which is stupid
07:55:55 <earthy> yes
07:56:22 <bartavelle> except, I'm not feeling confident enough in haskell to only do what is required
07:56:47 <bartavelle> I'm still struggling with the first concepts and the syntax
07:57:04 <Jafet> Well, you can simulate nearly any other language with continuations.
07:57:24 <bartavelle> I have no clue what this means
07:57:49 <frerich5> bartavelle: I'm not sure anybody mentioned it (and I found not such remark in the backlog) but the 'Internet solution' shown on http://www.banquise.net/haskell/graham/comparison.png is actually not correct I believe.
07:58:06 <bartavelle> Internet is totally wrong
07:58:13 <bartavelle> the proper solution is "my solution" :)
07:58:23 <earthy> I just explained why it is wrong actually, frerich5 :)
07:58:34 <frerich5> Oh, sorry. I'll go back into my dark corner. :-)
07:58:46 <earthy> no problem ;)
07:58:53 <ski> (the "internet solution" is <http://www.fatvat.co.uk/2009/09/graham-scan-in-haskell.html> ?)
07:58:57 <bartavelle> yes
07:59:05 <earthy> bartavelle: you're actually on the right track
07:59:23 <earthy> your scan function just isn't ideal
07:59:28 <bartavelle> and i have another question
07:59:37 <bartavelle> the "internet solution" seems to me it should behave in o(n)
07:59:41 <bartavelle> but it doesn't
07:59:42 <bartavelle> at all
07:59:44 <bartavelle> why is that ?
07:59:50 <bartavelle> is there something i didn't get ?
08:00:08 <bartavelle> or is it because of the way haskell interpretes stuff ?
08:00:09 <earthy> bartavelle: yes.
08:00:26 <bartavelle> oh
08:00:29 <bartavelle> besides the sort
08:00:38 <bartavelle> which is obviously not log(n)
08:01:00 <bartavelle> err
08:01:01 <bartavelle> o(n)
08:01:03 <bartavelle> argh
08:01:12 <bartavelle> ok i'll go back to work, i'm not making any sense now
08:01:17 <earthy> bartavelle: think about   scan (p1:p2:p3:pts) | 
08:01:50 <earthy> bartavelle: pattern match so you have the points directly, and then when recursing construct the correct tail
08:01:53 <Jafet> You can also use Data.Array, which lets you use the same algorithm as the one given on the website
08:02:26 <bartavelle> so this part should be O(n) ?
08:02:35 <earthy> bartavelle: yup
08:02:37 <earthy> not O(n^2)
08:02:58 <bartavelle> well it isn't O(n), its performance is horrible as n increases
08:03:08 <bartavelle> way worse than the n log n of the sort
08:03:44 <earthy> but I need to go out to get some bread with my son
08:04:02 <earthy> do think about the pattern matching and then constructing the appropriate tail for the recursion
08:05:10 <bartavelle> thanks
08:30:07 <haskellElephant> @botsnack
08:30:08 <lambdabot> :)
08:30:58 <haskellElephant> You have to remember to feed the bot!
08:31:29 <dankna> this is true!
08:33:14 <benmachine> @hotsnack
08:33:14 <lambdabot> :)
08:33:29 <benmachine> because it's approaching winter nowadays
08:38:36 <FunctorSalad_> :)
09:10:32 <BrazilianGirl> How to tell if it evaluates all elements of content?    let !mapasort = rnf $ map sort content
09:11:02 <haskellElephant> When you use the @pl command for lambdabot is that something coded in lambdabot or is it an independent liberary?
09:11:14 <haskellElephant> *coded into*
09:11:53 <lispy1> haskellElephant: it's a dynamically loaded plugin
09:13:46 <haskellElephant> Does it have a name that plugin? it seems pretty smart, It would be nice to see how it was made.
09:15:51 <zygoloid> haskellElephant: the source code to @pl is part of the lambdabot package on hackage.
09:17:14 <jmcarthur> there's also a package called pointfree
09:17:26 <jmcarthur> an executable
09:17:33 <haskellElephant> nice! I was thinking about adding some of lambdabots functionality into yi! =D.
09:27:44 <turiya> can a Ptr Word8 be converted to a ByteString?
09:28:23 <ClaudiusMaximus> @hoogle Ptr a -> IO ByteString
09:28:23 <lambdabot> Data.ByteString packCString :: CString -> IO ByteString
09:28:23 <lambdabot> Data.ByteString.Char8 packCString :: CString -> IO ByteString
09:28:23 <lambdabot> Data.ByteString.Unsafe unsafePackCString :: CString -> IO ByteString
09:28:39 <ClaudiusMaximus> @src CString
09:28:39 <lambdabot> Source not found. :(
09:28:55 <zygoloid> turiya: Data.ByteString.Internal.create
09:29:59 <turiya> zygoloid: i am not sure about how to write the function Ptr Word8 -> IO () in the create function
09:30:04 <zygoloid> possibly Data.ByteString.Internal.fromForeignPtr would be more direct
09:30:18 <zygoloid> turiya: there's a memcpy exposed in that module
09:31:28 <zygoloid> if you use fromForeignPtr and newForeignPtr, you can probably arrange to not copy the string at all
09:32:04 <turiya> can those two functions be used on a Ptr?
09:32:12 * hackagebot crypto-api 0.1.2.4 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.1.2.4 (ThomasDuBuisson)
09:32:15 <FunctorSalad_> turiya: data ByteString = PS !(GHC.ForeignPtr.ForeignPtr Word8) !Int !Int
09:32:15 <FunctorSalad_>         -- Defined in Data.ByteString.Internal
09:32:41 <FunctorSalad_> (the ints are offset and length)
09:32:51 <FunctorSalad_> but didn't know about the functions zygoloid just mentioned
09:33:23 <turiya> i meant, the Ptr should be converted to a ForeignPtr before one can use those functions.. no?
09:34:58 <zygoloid> turiya: you can make a ForeignPtr from a Ptr with Foreign.ForeignPtr.newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
09:35:16 <zygoloid> use the FinalizerPtr to specify how to deallocate the Ptr Word8
09:36:52 <turiya> zygoloid: i dont understand how to write a Finalizer...
09:40:01 <ClaudiusMaximus> i think packCString is probably better than internal tricks to avoiding copying - because otherwise you have to be careful not to mutate the underlying memory...
09:40:24 <turiya> can someone explain what the following means "The finaliser will be executed after the last reference to the foreign object is dropped"
09:40:54 <zygoloid> turiya: where does your Ptr Word8 come from?
09:41:12 <turiya> zygoloid: from SDL-image
09:41:18 <zygoloid> (who is responsible for deallocating the relevant memory?)
09:41:45 <turiya> the load function
09:42:24 <zygoloid> what is the lifetime of that pointer?
09:42:41 <Nibble> zygoloid: well, depends on exercise and diet.
09:42:58 <Nibble> with proper nutrition, five, six cycles?
09:43:04 <zygoloid> :)
09:43:31 <turiya> zygoloid: not till the end of the program 
09:44:37 <zygoloid> turiya: if you're *entirely certain* that pointer will outlive the ByteString, you could use fromForeignPtr . newForeignPtr'
09:45:06 <zygoloid> but if i were you i'd want to make a copy, to be sure
09:45:22 <turiya> it wont actually.. the BS has more lifetime..
09:46:37 <ClaudiusMaximus> packCStringLen should work then, maybe also needing castPtr and fromIntegral
09:46:51 <turiya> so, if a BS is created from a Ptr or ForeignPtr then the BS becomes obsolete when the Ptr's vanish?
09:48:28 <FunctorSalad_> the BS *is* just a wrapper around ForeignPtr (plus an offset and length)
09:48:32 <ClaudiusMaximus> you'd probably get explosions with Ptr, with ForeignPtr the memory is kept around until the BS is no longer needed, but mutating the underlying memory would cause all kinds of weird issues
09:49:19 <turiya> ClaudiusMaximus: what are explosions (sorry for my limited haskell gyan)..
09:49:23 <sbrg> "Haskell (a pure functional language used in academia) is in the safe-but-not-as-useful category. Because Haskell has no side effects (code blocks are functions and variables never change), and because it forces the programmer to define his types and intentions up front, it is considered a safe language. Unfortunately, Haskell is incredibly hard to get your head around, even for ninja programmers, and it's generally hard to read Haskell 
09:49:33 <Twey> turiya: Bad bad things
09:49:50 <Twey> sbrg: Haha, who wrote that?
09:49:56 <ClaudiusMaximus> turiya: things like Segmentation Fault
09:50:13 <sbrg> Twey: Some total and utter tool, obviously.
09:50:36 * roconnor finds it hard to get his head around pointers with mutable state
09:50:43 <sbrg> Some idiot I was arguing with was arguing that haskell was useless, semi-quoting it from msdn magazine. Then he finally linked the article; it is blatant in it's .NET loving
09:50:44 <turiya> ok..
09:50:56 <sbrg> its*
09:51:52 <FunctorSalad_> " forces the programmer to define his types and intentions up front" okay
09:52:50 <FunctorSalad_> I don't see how haskell does that any more so than .NET languages
09:53:42 <FunctorSalad_> if anything, making your own types is more optional since you can use tuples and eithers...
09:53:42 <sbrg> FunctorSalad_: I personally think that the unfamiliarity of a programming paradigm shouldn't be used to grade the language at all
09:54:15 <aristid> sbrg: wishful thinking :)
09:54:18 <sbrg> Oh, and the "types and intentions" thing is just.. vague crap
09:54:26 <sbrg> aristid: of course
09:54:49 <sbrg> But the article itself is ocmparing a series of languages and it seems that all .NET based languages seem to come out on top
09:55:04 <sbrg> I wonder if the author even took a crack at haskell
09:55:52 <aristid> sbrg: does he use a table with checklists? that would be awesomest
09:56:02 <sbrg> Nope
09:56:03 <sbrg> http://msdn.microsoft.com/en-us/magazine/cc507636.aspx
09:56:08 <sbrg> that would be fun though
09:56:27 <sbrg> "Clearly, the next-generation languages would do well to borrow the best features of all the languages I've discussed. " <- LOL.
09:56:39 <sbrg> Yes, kitchen sink = best
09:57:56 <FunctorSalad_> "In my opinion, F# is more useful than Haskell with [...] , opt-in procedural syntax [...]"
09:58:09 <FunctorSalad_> someone give the man a do block :(
09:58:20 <sbrg> I don't know F#..
09:58:21 <sbrg> OH!
09:58:23 <sbrg> that's what he means?
09:58:25 <sbrg> Hah.
09:58:46 <sbrg> If he did take a crack at haskell, he probably got to monads, where they broke his will and he decided to bash it
09:58:50 <FunctorSalad_> I only know it from reading the docs a bit, but I think he's referring on its variant of do notation, yes
09:59:02 <sbrg> It sounds like it, yes
10:00:24 * hackagebot MissingPy 0.10.4 - Haskell interface to Python  http://hackage.haskell.org/package/MissingPy-0.10.4 (MattBrown)
10:01:15 <FunctorSalad_> http://msdn.microsoft.com/en-us/library/dd233182.aspx
10:01:38 <sbrg> Hah @ "workflows"
10:01:45 <sbrg> What a microsoftian name.
10:02:40 <FunctorSalad_> yeah :) but that aside, I quite like what I read about the language so far
10:03:01 <sbrg> I can see it being alright, yes
10:03:13 <sbrg> I don't mind .NET, F#, C# or any of those
10:03:21 <sbrg> but that article is blatant advertisment for .NET
10:03:40 <FunctorSalad_> at least they do mention monads in the intro paragraph ;)
10:04:11 <roconnor> what's the deal with Ωmega?
10:04:17 <sbrg> Oh, I'm referring to the one I linked
10:05:04 <FunctorSalad_> sbrg: yes, I realized
10:06:40 <Eduard_Munteanu> \o
10:07:48 <aristid> kmc: you should put your toy program on github :>
10:15:12 <turiya> how can i convert from Word8 to CChar?
10:15:31 <Apocalisp> @hoogle (a -> b -> f c) -> f a -> f b -> f c
10:15:31 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
10:15:31 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
10:15:31 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
10:16:04 <Apocalisp> @type ((join .) .) . liftA2 
10:16:05 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m, Applicative m) => (a1 -> b -> m a) -> m a1 -> m b -> m a
10:16:12 <Apocalisp> ah
10:16:27 <Apocalisp> What if I don't have join?
10:16:53 <roconnor> turiya: some combintation of fromEnum and fromIntegral I suppose
10:17:18 <roconnor> Apocalisp: do you have bind?
10:17:24 <turiya> Apocalisp: was that the solution for converting from Word8 to CChar?
10:17:54 <Apocalisp> roconnor: I do in all the cases I can think of, but I was wondering if it could be written for non-monadic applicatives
10:18:05 <Apocalisp> turiya: No, sorry
10:18:49 <turiya> oh.. cool.. i was a bit scared..
10:18:50 <roconnor> Apocalisp: you want  (a -> b -> f c) -> f a -> f b -> f c  for f not a monad?
10:18:55 <FunctorSalad_> Apocalisp: hmm, seems like it'd more or less imply bind
10:19:08 <roconnor> Apocalisp: I mean, this signature is practiaclly the same as bind
10:19:12 <Apocalisp> seems like it
10:19:14 <FunctorSalad_> assuming f () is () or something else trivial
10:19:53 <Apocalisp> yeah, so it definitely is liftA2 then join
10:19:55 <FunctorSalad_> (or a=Void maybe)
10:21:37 * hackagebot MissingPy 0.10.5 - Haskell interface to Python  http://hackage.haskell.org/package/MissingPy-0.10.5 (MattBrown)
10:21:53 <McManiaC> whats the main difference between parsers like happy and parsec?
10:22:04 <jmcarthur> Apocalisp: i call that bind2, btw
10:22:39 <jmcarthur> Apocalisp: i have defined the bind* family a few times now. i really wish they were in base
10:22:54 <roconnor> @type \h f -> h (const f) (return ())
10:22:55 <Apocalisp> I can live with join $ f <$> x <*> y
10:22:55 <lambdabot> forall a b (m :: * -> *) t. (Monad m) => ((b -> a) -> m () -> t) -> a -> t
10:23:23 <Lemmih> McManiaC: Happy is a parser generator, parsec is a combinator library.
10:23:42 <jmcarthur> actually it looks like i've called it extend* before too
10:24:18 <jmcarthur> since it really lines up more with (=<<) i guess
10:24:28 <McManiaC> Lemmih: in what kind of applications would you use which one?
10:24:35 <jmcarthur> http://patch-tag.com/r/jmcarthur/alt-stdlib/snapshot/current/content/pretty/Control/Monad.hs
10:25:19 <FunctorSalad_> $(bind 8) f a b c d e f g h
10:25:21 <FunctorSalad_> :)
10:25:28 <Lemmih> McManiaC: They solve the same problem. Parsec is easier to use. Happy is faster.
10:25:31 <jmcarthur> FunctorSalad_: heh
10:25:41 <jmcarthur> FunctorSalad_: needs an idiom-bracket-like syntax
10:26:16 <McManiaC> Lemmih: so its mostly a matter of taste?
10:26:22 <jmcarthur> happy isn't that hard to use either, IMO
10:26:22 <Lemmih> McManiaC: Yes.
10:26:28 <McManiaC> Lemmih: okay, thanks
10:26:34 <jmcarthur> i prefer parsec just because it's embedded though
10:26:39 <FunctorSalad_> jmcarthur: but to debug :o imho
10:26:47 <jmcarthur> ah, yeah, tougher to debug
10:26:48 <FunctorSalad_> unless it has changed
10:27:01 <jmcarthur> it's been at least a couple years since i've toyed with it
10:29:35 <jmcarthur> in retrospect, it's very interesting (however obvious) to me that (=<<) works for my generalized Monad class and (>>=) does not
10:30:06 <FunctorSalad_> that sounds... impossible if (=<<) = flip (>>=) ;)
10:30:10 <FunctorSalad_> I guess it isn't
10:30:24 <jmcarthur> FunctorSalad_: flip puts it in Hask
10:30:26 <gwern> happy sometimes causes build problems
10:30:31 <gwern> parsec not so much
10:30:35 <FunctorSalad_> jmcarthur: ah
10:31:20 <FunctorSalad_> so you made a monad in some other category I suppose
10:31:38 <FunctorSalad_> (a ~> m b) -> (m a ~> m b)
10:31:46 <jmcarthur> right
10:31:47 <FunctorSalad_> (Category (~>)) :)
10:32:08 <jmcarthur> Category (~>) is of course implied by Applicative (~>) m
10:32:57 <jmcarthur> :D
10:33:58 <FunctorSalad_> .... I see what you did there ;)
10:34:54 <SubjectiveObject> is it possible to implement a binary heap in haskell?
10:35:07 <SubjectiveObject> that still retains O(log n) updates
10:35:12 <FunctorSalad_> I once set out on this quest too, also generalizing 'Category' itself... until copumpkin pointed out that I might as well parameterize the typeclasses with the name of the author
10:35:15 <FunctorSalad_> ;)
10:35:36 <c_wraith> SubjectiveObject, it's possible to implement any data structure you want in haskell.  Be more specific. Perhaps you mean "that doesn't use mutable updates". :)
10:35:56 <SubjectiveObject> c_wraith: Yes that's what I meant =)
10:36:15 <jmcarthur> FunctorSalad_: how did you generalize Category?
10:36:38 <FunctorSalad_> jmcarthur: I think I had had something like 'Compose cat ab bc ac | ab bc -> ac' in mind
10:36:41 <FunctorSalad_> with 'cat' a token
10:36:44 <jmcarthur> omg
10:36:47 <jmcarthur> :)
10:36:48 <c_wraith> SubjectiveObject, yes, it's possible.  Look at Chris Okasaki's work on persistent data structures.  He presents them in a variant of o'caml, but the algorithms work the same way in haskell
10:36:54 <FunctorSalad_> but I don't quite remember
10:37:08 <c_wraith> SubjectiveObject, his thesis is available for free, and contains a LOT of information on the topic.
10:37:20 <SubjectiveObject> c_wraith: I checked out Okasaki's paper. However, I could only see skew heaps and some other structures
10:37:27 <FunctorSalad_> jmcarthur: a lesser generalization would be restricted categories
10:37:34 <FunctorSalad_> (like rmonad)
10:37:36 <gwern> SubjectiveObject: you could look at edison to see whether it has implemenatations
10:38:03 <c_wraith> edison implements pretty directly from his paper.
10:38:16 <c_wraith> I haven't checked his book, I know it has more in it.
10:38:24 <FunctorSalad_> so that you could have 'Set' a functor from OrdHask to Hask etc
10:39:39 <jmcarthur> FunctorSalad_: the best formulations of restricted functors in haskell that i know of are still pretty unweildly. it would be nice if we could get some constraint families in haskell to solve that :)
10:39:47 <FunctorSalad_> *nod*
10:40:05 <c_wraith> SubjectiveObject, more generally, unless the algorithms in binary heaps fundamentally depend on destructive updates, it should be possible to keep the same complexity, though possibly with a greater constant cost.
10:40:46 <c_wraith> SubjectiveObject, the only data structure I can think of offhand that depends on destructive updates is the union-find tree.  Of course, there are probably more.
10:41:06 <Eduard_Munteanu> Mmm, is there any syntactic sugar for concise STRef updates? I can think of making an (<--) so I write x <-- (\c -> c + 2), but it still doesn't look imperative-ish.
10:41:16 <SubjectiveObject> you can't implement a union-find tree in functional languages?
10:41:21 <Eduard_Munteanu> where (<--) = modifyIORef
10:41:52 <Eduard_Munteanu> I can't tell if there's anything that can be done without messing with parsing/lexing.
10:42:25 <c_wraith> SubjectiveObject, the path compression portion of the algorithm relies on mutability fundamentally.  You can just use union-by-rank to get reasonable performance.
10:42:47 <jmcarthur> Eduard_Munteanu: looks fairly imperative to me..
10:43:09 <Eduard_Munteanu> jmcarthur: yeah, it is, but I was hoping to get a syntax along the lines of x = x + 2 :)
10:43:23 <FunctorSalad_> SubjectiveObject: you can have mutation without going all the way down to IO in haskell using the ST monad
10:43:26 <jmcarthur> SubjectiveObject: functional /= pure. you can even get mutation in pure haskell by using the imperative ST monad
10:43:28 <SubjectiveObject> c_wraith: But can you theoretically use the ST monad to do all that
10:43:31 <jmcarthur> ha
10:43:35 <c_wraith> SubjectiveObject, yes.
10:43:45 <FunctorSalad_> :)
10:43:53 <jmcarthur> @quote fugue
10:43:53 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
10:44:02 <c_wraith> SubjectiveObject, like I said, it depends on destructive updates.  I didn't say it can't be done in haskell :)
10:44:20 <jmcarthur> Eduard_Munteanu: quasiquoter?
10:44:33 <FunctorSalad_> Eduard_Munteanu: I think there's a lib providing ":=" :)
10:44:39 <SubjectiveObject> Ah :)
10:44:42 <companion_cube> to which programming language channel should I go to see my questions answered in haikus ?
10:44:42 <FunctorSalad_> for STRef, IORef, TVar maybe
10:44:47 <jmcarthur> Eduard_Munteanu: i think he wants to avoid the lambda abstraction
10:44:51 <jmcarthur> oops
10:44:53 <jmcarthur> FunctorSalad_: ^^
10:45:25 <FunctorSalad_> oh, didn't see you're modifying, not just assigning
10:45:44 <jmcarthur> an ST quasiquoter would be pretty neat, actually
10:45:54 <Eduard_Munteanu> Yeah, for simple assignment I could write an infix equivalent to writeSTRef
10:46:10 <gwern> SubjectiveObject: there are union-finds in haskell, but I can't speak to their performance
10:46:49 <Eduard_Munteanu> jmcarthur: um, by quasiquoter you mean syntax sugar or some preprocessing/TH hack?
10:47:26 <jmcarthur> umm... it's the former implemented with the latter :)
10:47:30 <gwern> SubjectiveObject: the Wikipedia article covers a Coq implementation which apparently has optimal complexity
10:47:34 <FunctorSalad_> @let r += x = modifySTRef r (+x)
10:47:36 <lambdabot>  Defined.
10:47:37 <FunctorSalad_> ;)
10:48:37 <aristid> :t (+)
10:48:38 <lambdabot> forall a. (Num a) => a -> a -> a
10:48:39 <Eduard_Munteanu> jmcarthur: well true, but it's easier not to get into GHC guts.
10:48:39 <aristid> :t (+=)
10:48:40 <lambdabot> forall s a. (Num a) => STRef s a -> a -> ST s ()
10:48:46 <aristid> damn, using the keyboard is hard
10:48:59 <jmcarthur> Eduard_Munteanu: http://www.haskell.org/haskellwiki/Quasiquotation
10:49:04 <jmcarthur> TH isn't really GHC guts
10:49:11 <jmcarthur> it's just a syntax tree
10:49:16 <Eduard_Munteanu> FunctorSalad_: hm, that does it well as long as I don't need to reference x on the RHS.
10:49:18 <aristid> hmm, idea: @let could show the type of the defined expression
10:49:28 <gwern> SubjectiveObject: iirc, the ocaml implementation uses diffarrays to get constant-time access without destructive updates
10:49:58 * gwern tried to write some union-finds in haskell, realized I didn't know how to represent it type-wise, and gave up
10:49:59 <jmcarthur> well, without observable destructive updates anyway
10:50:04 <Eduard_Munteanu> jmcarthur: thanks, that looks interesting.
10:50:05 <aristid> gwern: doesn't haskell have diffarrays, too, with poor performance?
10:50:08 <gwern> jmcarthur: yeah, soemthing like that
10:50:21 <gwern> aristid: complexities, remember; the constants could be terrible
10:50:27 <SubjectiveObject> Heh, I'm gonna start simple. Not going to try union-find yet
10:50:28 <jmcarthur> aristid: yeah, it relies on MVar to be thread safe which kind of slows it down, we think
10:50:39 <FunctorSalad_> Eduard_Munteanu: it was just a special-purpose solution for your \c -> c+2 ;)
10:50:42 <aristid> gwern: right, asymptotical analysis is not everything
10:50:56 <silver> hey guys, can you comment on this (duplication of APIs in Haskell libraries): http://www.mail-archive.com/haskell@haskell.org/msg19992.html
10:51:03 <aristid> jmcarthur: i think MVar being thread safe is kind of a given
10:51:05 <silver> is this a problem for you?
10:51:49 <jmcarthur> i did not realize you could do this: eval' [expr|$x + $y|]  = eval' x + eval' y
10:51:54 <jmcarthur> that's awesome
10:52:13 <jmcarthur> aristid: no, i mean it requires using MVar *in order* to be thread safe
10:52:21 <jmcarthur> which is what slows it down
10:52:28 <zygoloid> yeah, QQ is nice :)
10:52:44 <gwern> silver: yes, it is a problem because libraries each often use a different string-like class, and it makes for constant conversions and interop problems
10:52:57 <gwern> silver: this is not news, though...
10:52:58 <aristid> jmcarthur: uh, ok
10:53:07 <FunctorSalad_> the plan for TH spj posted recently looks nice
10:53:36 <FunctorSalad_> (have two kinds of quotes, one that is renamed but not typechecked, and a typechecked one yielding a typed AST)
10:53:43 <jmcarthur> aristid: DiffArray uses MVar under some unsafePerformIO, so even when you are using it in pure code as intended you are actually reading and writing to MVars all the time. that's what i was getting at
10:53:51 <Eduard_Munteanu> jmcarthur: hm, I would've expected MVar synchronization to be turned into a no-op at compile time unless you really need SMP support.
10:54:03 <aristid> jmcarthur: oh.
10:54:13 <aristid> jmcarthur: the ST arrays don't have that problem?
10:54:25 <jmcarthur> aristid: the ST arrays don't have to be thread safe
10:54:33 <aristid> hooray.
10:54:34 <Eduard_Munteanu> That, if it's such a big problem.
10:54:39 <jmcarthur> until they are frozen, of course
10:54:45 <jmcarthur> at which point they are inherently thread safe
10:55:54 <jmcarthur> Eduard_Munteanu: MVars still have to perform blocking and things like that even for green threads
10:56:10 <jmcarthur> there is going to be some inherent overhead even with a version specialized for a single OS thread
10:57:27 <Eduard_Munteanu> Is DiffArray that slow? I considered using it on a few occassions.
10:58:20 <jmcarthur> it has pretty bad constant penalties, yes
10:58:35 <jmcarthur> sometimes it's okay
10:58:41 <jmcarthur> depends on how you're using it
10:58:55 <Cale> In some cases, it's a decent option. If you have a program which would work with any immutable array, it's worth giving it a shot.
10:59:20 <Cale> I've even had some luck using it in cases with backtracking.
10:59:21 <Eduard_Munteanu> I see. Though I'd expect copying penalties of Data.Array to be worse than acquiring locks and doing atomic operations :/
10:59:30 <jmcarthur> Eduard_Munteanu: not always
10:59:44 <jmcarthur> it just depends
11:01:52 * roconnor prefers to throw exceptions rather than timidly raise exceptions.
11:02:05 <blackdog>  this exception should not be lightly set aside...
11:03:34 <roconnor> @type and
11:03:35 <lambdabot> [Bool] -> Bool
11:04:25 <turiya> can i convert from Double to Int?
11:04:33 * jmcarthur hits client code with exception hammers
11:04:44 <jmcarthur> turiya: you can use floor, round, ceiling, etc.
11:04:55 <jmcarthur> :t round (5.6 :: Double) :: Int
11:04:56 <lambdabot> Int
11:05:01 <jmcarthur> > round (5.6 :: Double) :: Int
11:05:02 <lambdabot>   6
11:06:05 <turiya> len = round(width × height × fromIntegral(bpp) / 8
11:06:18 <turiya> gives an error
11:06:35 <jmcarthur> imbalanced parens?
11:06:55 <turiya> sorry that was a mistake in copying..
11:07:13 <turiya> len = round(width × height × fromIntegral(bpp) / 8) 
11:07:23 <turiya> width, height are ints
11:07:38 <ClaudiusMaximus> you might want `div` instead of / , then you wouldn't need to round
11:07:46 <jmcarthur> :t \w h bpp -> round $ w * h * fromIntegral bpp / 8
11:07:47 <lambdabot> forall b a a1. (RealFrac a, Integral b, Integral a1) => a -> a -> a1 -> b
11:07:49 <aristid> multiplication is * not crazy character
11:07:59 <jmcarthur> :t \w h bpp -> w * h * bpp `div` 8
11:08:00 <lambdabot> forall a. (Integral a) => a -> a -> a -> a
11:09:02 <FunctorSalad_> ∗
11:09:11 <revenantphx> in
11:09:26 <turiya> ClaudiusMaximus: that worked.. thanks
11:09:48 <turiya> i copied the text from Yi, which shows * as x
11:10:19 <Nikla> can we define '<' using foldr ?
11:11:09 <ClaudiusMaximus> :t ((<),foldr)
11:11:10 <lambdabot> forall a a1 b. (Ord a) => (a -> a -> Bool, (a1 -> b -> b) -> b -> [a1] -> b)
11:11:27 <c_wraith> Nikla, that's a bit vague.  Do you mean "can I implement '<' for Ord a => [a] using foldr"?
11:11:29 <jmcarthur> @src (<)
11:11:29 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
11:12:28 <Nikla> @c_wraith ya you are right its about implementation
11:12:28 <lambdabot> Unknown command, try @list
11:12:46 <c_wraith> Nikla, yeah, foldr has the right structure to implement it.
11:13:08 <jmcarthur> :t (fmap.fmap) (all id) zipWith (<)
11:13:09 <lambdabot>     Couldn't match expected type `[Bool]'
11:13:09 <lambdabot>            against inferred type `[b] -> [c]'
11:13:09 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
11:13:13 <benmachine> foldr can implement basically everything.
11:13:24 <jmcarthur> :t (fmap.fmap) (all id) (zipWith (<))
11:13:25 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Bool
11:13:35 <c_wraith> benmachine, not *everything*.  see ackerman's function. :)
11:13:35 <jmcarthur> @src all
11:13:36 <lambdabot> all p =  and . map p
11:13:40 <jmcarthur> @src and
11:13:40 <lambdabot> and   =  foldr (&&) True
11:13:43 <jmcarthur> and there you goe
11:13:45 <jmcarthur> *go
11:13:49 <benmachine> jmcarthur: all id = and . map id = and
11:13:54 <jmcarthur> haha
11:14:05 <Nikla> can we do without use of map
11:14:10 <jmcarthur> i have never used and
11:14:10 <benmachine> jmcarthur: also, you're not getting [1,2,3] < [1,2,3,4]
11:14:18 <jmcarthur> benmachine: indeed
11:14:20 <benmachine> Nikla: map f = foldr ((:) . f)
11:14:33 <jmcarthur> anyway, i think i've at least showed that the structure of foldr works with this problem
11:14:37 <c_wraith> yeah, I was going to point out that zipping-based approaches are going to have issues with lists that aren't the same length.
11:14:40 <benmachine> jmcarthur: I wish there was a zipWith that had some neat way to deal with what was left over
11:15:05 <jmcarthur> benmachine: as long as the element type has a designated element it could work
11:15:07 <benmachine> I'm not sure what that would look like though
11:15:15 <Nikla> ok i think i got some idea, thanx guys
11:15:18 <benmachine> Maybe (Either [a] [b]) -> [c] perhaps
11:15:49 <ClaudiusMaximus> zipAndTheRest :: [a] -> [b] -> ([(a,b)], Either [a] [b]) -- is my guess
11:16:02 <jmcarthur> (Designated a, Designated b) => [a] -> [b] -> [(a,b)]
11:16:13 <jmcarthur> and a zipWith variant using map
11:16:26 <jmcarthur> on the result, that is
11:16:45 <jmcarthur> class Designated a where designated :: a
11:16:56 <c_wraith> I was thinking along the lines of: (a -> c) -> (b -> c) -> (a -> b -> c) -> [a] -> [b] -> [c]
11:17:04 <jmcarthur> that Either version could be simulated using a Maybe element type i think
11:17:35 <jmcarthur> yeah that's a nice algebraic version
11:17:36 <Eduard_Munteanu> You could lift the lists into a Maybe, extend one of them with Nothing, and let the zipping function have Nothing as an identity.
11:17:56 <jmcarthur> Eduard_Munteanu: right, that's a specific instance of my Designated proposal
11:18:08 <ClaudiusMaximus> i like c_wraith's version
11:18:21 <jmcarthur> class Designated (Maybe a) where
11:18:29 <Eduard_Munteanu> Mmm, yes, it makes sense.
11:18:30 <jmcarthur>   designated = Nothing
11:18:31 <benmachine> jmcarthur: or you could inline the dictionaries with a -> b -> (a -> b -> c) -> [a] -> [b] -> [c]
11:18:32 <jmcarthur> *instance
11:18:46 <jmcarthur> benmachine: indeed
11:18:59 <jmcarthur> i like implicit dictionaries though :)
11:19:02 <benmachine> jmcarthur: could you actually recover original zipWith here though? because to be fair that's quite often what you want
11:19:09 <jmcarthur> i also prefer sortOn over sortBy :P
11:19:17 <benmachine> sortOn should be standardised imo
11:19:48 <jmcarthur> benmachine: no, they would represent different ideas of zipping
11:20:00 <benmachine> oh ok
11:20:05 <c_wraith> yeah, I agree that the ability to derive one from the other is not needed
11:20:11 <benmachine> it's not needed
11:20:19 <benmachine> but it's interesting to think about generalisations
11:20:25 <benmachine> as opposed to alternatives
11:20:25 <jmcarthur> benmachine: length (zip xs ys) == length xs `min` length ys ; length (newZip xs ys) == length xs `max` length ys
11:20:45 <jmcarthur> different specifications there
11:20:52 <Eduard_Munteanu> Mmm, I tend to think of zipping as mapping, so perhaps this could be implemented in terms of binary folding.
11:20:52 <benmachine> jmcarthur: mm, but if we're going for a function with that property I prefer c_wraith's version
11:21:15 <Eduard_Munteanu> If so, that could perhaps be used to recover the original zipWith.
11:21:22 <benmachine> jmcarthur: it seems weird to give the function and then give one of its parameters
11:21:27 <ClaudiusMaximus> you could maybe have   c == Maybe c'  and then catMaybes  to define zipWith
11:21:38 <benmachine> mm
11:21:40 <jmcarthur> benmachine: that's not the one i suggested :P
11:21:52 <benmachine> jmcarthur: blink blink
11:21:54 <Eduard_Munteanu> (e.g. map is unary, zipWith is binary, but essentially the same)
11:22:06 <jmcarthur> benmachine: i suggested the Designated type class version
11:22:12 <aristid> Eduard_Munteanu: just like liftA2 is binary fmap?
11:22:17 <jmcarthur> the designated elements are implicit then
11:22:34 <jmcarthur> in fact...
11:22:38 <benmachine> jmcarthur: hmm, are there actually any sensible instances apart from Maybe?
11:22:53 <jmcarthur> this might be a cool specialized version:    Monoid a => [a] -> [a] -> [a]
11:23:12 <jmcarthur> benmachine: any Monoid, basically, which leads to that specialized version
11:23:23 <Eduard_Munteanu> aristid: sort of, yeah.
11:23:23 <benmachine> I guess so
11:23:25 <jmcarthur> benmachine: i'm leaning toward c_wraith's now since it doesn't rely on such properties
11:23:29 <benmachine> yeah
11:23:35 <jmcarthur> but i do think the monoid version seems neat
11:23:47 <benmachine> the monoid version is neat
11:23:50 <benmachine> but it's quite specific
11:24:29 <jmcarthur> if we had restricted monads and a newtype wrapper around list for those semantics we could form a restricted monad from that
11:24:44 <jmcarthur> like ZipList
11:24:59 <jmcarthur> but satisfying that max property on the lengths rather than the min one
11:25:06 <benmachine> right
11:25:37 <jmcarthur> a bit useless though i suspect
11:26:06 <jmcarthur> since all your (a -> m b) functions would have to require that both a and b are monoids
11:26:57 <jmcarthur> well, such a newtype wrapper would at least form a useful monoid instance
11:27:02 <Eduard_Munteanu> Well, half-monoids, you only need a mzero I guess.
11:27:07 <cabalistik> quick question: is there a prelude function that removes extra square  brackets? eg. "[a] -> a" where 'a' is a single element of a list
11:27:18 <jmcarthur> Eduard_Munteanu: ah, Designated then
11:27:19 <Eduard_Munteanu> Because mappend can simply be replaced by fmapping.
11:27:25 <Eduard_Munteanu> Yes.
11:27:43 <jmcarthur> :t head
11:27:44 <lambdabot> forall a. [a] -> a
11:27:53 <jmcarthur> it's partial though
11:27:55 <jmcarthur> > head []
11:27:56 <lambdabot>   *Exception: Prelude.head: empty list
11:27:58 <jmcarthur> > head [1]
11:27:59 <lambdabot>   1
11:28:02 <jmcarthur> > head [1,2]
11:28:03 <lambdabot>   1
11:29:18 <int80_h> I'd like to use a let to bind a ByteString to a variable, let foo = "bar", but foo has to be a bytestring. What is the reight syntax?
11:29:21 <int80_h> right, even
11:29:55 <aristid> :t \x y -> zipWith mappend (x ++ repeat mempty) (x ++ repeat mempty)
11:29:56 <lambdabot> forall t a. (Monoid a) => [a] -> t -> [a]
11:30:02 <aristid> :t \x y -> zipWith mappend (x ++ repeat mempty) (y ++ repeat mempty)
11:30:03 <lambdabot> forall a. (Monoid a) => [a] -> [a] -> [a]
11:30:08 <aristid> @pl \x y -> zipWith mappend (x ++ repeat mempty) (y ++ repeat mempty)
11:30:08 <lambdabot> (. (++ repeat mempty)) . zipWith mappend . (++ repeat mempty)
11:30:11 <cabalistik> ah it's head obviously! how couldn't i have seen that, Thanks jmcarthur!
11:30:34 <Lemmih> int80_h: let foo = pack "bar" ?
11:30:59 <Lemmih> int80_h: Or: -XOverloadedStrings
11:31:01 <int80_h> ah, I was trying to do "let foo :: ByteString = "bar"
11:31:27 <int80_h> if I used OverloadedStrings, what would the syntax be?
11:31:41 <Lemmih> int80_h: let foo = "bar"
11:31:48 <benmachine> int80_h: probably the type of foo would be inferred, so let foo = "bar" would be fine
11:31:51 <aristid> :t \x y -> zipWith mappend <$> (++ repeat mempty) <*> (++ repeat mempty)
11:31:52 <lambdabot> forall t t1 a. (Monoid a) => t -> t1 -> [a] -> [a]
11:31:55 <int80_h> huh, okay
11:31:57 <benmachine> if it's not then let foo :: ByteString; foo = "bar"
11:32:13 <int80_h> ah!
11:32:14 <benmachine> (semicolon would probably be a newline in real code)
11:32:22 <aristid> :t zipWith mappend `on` (++ repeat mempty)
11:32:23 <lambdabot> forall a. (Monoid a) => [a] -> [a] -> [a]
11:32:28 <aristid> yay!
11:32:32 <benmachine> or foo = "bar :: ByteString
11:32:35 <benmachine> er
11:32:39 <benmachine> foo = "bar" :: ByteString
11:33:02 <int80_h> benmachine : yeah I tried that too, but without using the language extention
11:33:28 <benmachine> aristid: yourZipWith [] [] = repeat mempty :o
11:34:56 <aristid> benmachine: anything wrong with that? :D
11:36:41 <benmachine> aristid: not as such. just hard to tell where your original lists ended >_>
11:37:46 <jmcarthur> cabalistik: no problem. easy to overlook such things when in foreign lands :)
11:38:26 <roconnor> I'm surprised that they didn't find any non mtl instances of MonadState.  I thought they would be common
11:38:31 <jmcarthur> cabalistik: a version of head that is not partial: listToMaybe
11:38:35 <jmcarthur> :t listToMaybe
11:38:36 <lambdabot> forall a. [a] -> Maybe a
11:38:40 <jmcarthur> cabalistik: just fyi
11:39:24 <Eduard_Munteanu> aristid: looks like it, but ideally you don't want the result to be infinite.
11:39:38 <jmcarthur> when you know the list cannot be empty anyway then there's no point in listToMaybe (and of course you *still* have to either use the value inside the Maybe or extract it with another partial function like fromJust or, preferably, maybe)
11:39:39 <Eduard_Munteanu> aristid: just have length equal to the max of them
11:39:40 <jmcarthur> :t maybe
11:39:41 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:39:42 <jmcarthur> :t fromJust
11:39:43 <lambdabot> forall a. Maybe a -> a
11:41:13 <jmcarthur> roconnor: i'm not surprised. usually you don't actually intend for the state to be exposed in the API, so MonadState would be a bad instance to implement
11:41:23 <Eduard_Munteanu> @hoogle zipWith
11:41:23 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:41:23 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
11:41:23 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:41:35 <cabalistik> OK got it, thanks again
11:41:41 <jmcarthur> np
11:43:16 * hackagebot SoccerFun 0.1.2 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.1.2 (JanRochel)
11:43:22 <Eduard_Munteanu> Hm... foldl is to map like [...] is to zipWith. What's [...] in Prelude?
11:43:48 <Eduard_Munteanu> @hoogle fold
11:43:48 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
11:43:49 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
11:43:49 <lambdabot> Data.IntSet fold :: (Int -> b -> b) -> b -> IntSet -> b
11:44:00 <pumpkin> map is very clearly related to zipWith
11:44:03 <pumpkin> :t map
11:44:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:44:05 <pumpkin> :t zipWith
11:44:06 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:44:29 <pumpkin> but there isn't a single function I know of in the prelude that folds over two lists at once
11:44:40 <Eduard_Munteanu> Ah, I see.
11:44:50 <pumpkin> :t \f z xs ys -> foldl f z (zip xs ys)
11:44:51 <lambdabot> forall a a1 b. (a -> (a1, b) -> a) -> a -> [a1] -> [b] -> a
11:45:25 <Cale> foldl together with zip?
11:45:27 <Cale> yeah
11:46:09 <benmachine> you can use foldr to build a function [a] -> [b] :P
11:46:25 <benmachine> that's not the most convenient thing in the world though
11:47:58 <silver> where can I read about TH's future?
11:48:45 <benmachine> http://hackage.haskell.org/trac/ghc/blog/
11:48:49 <aristid> :t zip `on` (++ repeat mempty)
11:48:49 <lambdabot> forall a. (Monoid a) => [a] -> [a] -> [(a, a)]
11:48:55 <silver> benmachine, thank you
11:49:16 <benmachine> silver: none of that is concrete I think but there's some nice ideas there
11:49:33 <aristid> :t takeWhile (\x -> case x of (mempty, mempty) -> False; _ -> True) . zip `on` (++ repeat mempty)
11:49:34 <lambdabot>     Conflicting definitions for `mempty'
11:49:34 <lambdabot>     In a case alternative
11:50:04 <Eduard_Munteanu> pumpkin: yeah it makes sense, I don't think there's a natural generalization from folding on a list to folding on two lists :/
11:50:21 * hackagebot ListLike 1.1.0 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-1.1.0 (JohnLato)
11:52:43 <benmachine> :t foldr (\x xs ys -> case ys of [] -> []; z:zs -> (x, z) : xs zs) (const [])
11:52:44 <lambdabot> forall a t. [a] -> [t] -> [(a, t)]
11:53:07 <aristid> @let (.:) = (.).(.)
11:53:08 <lambdabot>  Defined.
11:53:09 <benmachine> hmm xs is a deceptive name there
11:53:17 <aristid> :t (map (uncurry mappend) . takeWhile (\(x, y) -> case x of mempty -> (case y of mempty -> False; _ -> True); _ -> True)) .: zip `on` (++ repeat mempty)
11:53:18 <lambdabot> forall a. (Monoid a) => [a] -> [a] -> [a]
11:53:38 <aristid> anybody know an easier way to check if both are mempty?
11:53:51 <benmachine> aristid: you mean, one that works?
11:54:02 <aristid> ooh, damn
11:54:03 <EvanR-work> if x == y == mempty then
11:54:04 <benmachine> :P
11:54:06 <aristid> i forgot that limitaiton
11:54:16 <benmachine> aristid: you can't check for mempty in general
11:54:22 <benmachine> aristid: for e.g. functions are Monoid
11:54:23 <aristid> benmachine: yeah because it's no constructor
11:54:29 <aristid> but i forgot that :D
11:54:34 <aristid> and it typechecks
11:54:35 <aristid> evil
11:54:36 <benmachine> so EvanR-work's idea doesn't work idea
11:54:37 <benmachine> *either
11:54:55 <benmachine> aristid: at least if you have warnings on it says "unused variable mempty"
11:55:02 <benmachine> *binding
11:55:20 <aristid> benmachine: yeah i don't have that on in gchi
11:55:25 <benmachine> oh
11:55:28 <benmachine> I put :set -W in .ghci
11:55:33 <aristid> heh
11:55:38 <aristid> -Wall would be too annoying
11:55:41 <benmachine> :set -W -XNoMonomorphismRestriction
11:55:43 <benmachine> in fact
11:55:54 <aristid> \o/ monomorphism restriction must die
11:56:04 * benmachine considers adding -XNoIncoherentInstances just to amuse self
11:56:37 <aristid> oO
11:56:48 <aristid> benmachine: add -XTupleSections
11:56:57 <benmachine> hmm
11:56:59 <benmachine> I guess so
11:57:22 <benmachine> actually I dunno
11:57:29 <benmachine> actually
11:57:34 <benmachine> why don't I just enable... most things
11:58:17 <benmachine> --supported-languages doesn't seem to be sorted by any sensible metric
11:58:18 <aristid> benmachine: indeed
11:58:49 <benmachine> I was thinking it wouldn't catch when I forgot a pragma, but that's what cabal is for
11:59:56 <benmachine> MagicHash is a silly extension if you ask me
12:00:01 <benmachine> it's not like there aren't enough names
12:00:15 <benmachine> ...I don't even know what PolymorphicComponents *is*
12:01:55 <EvanR-work> -XMagicBrownies
12:03:29 <arcatan> -XNamedFieldPuns (no pun intended)
12:04:13 <EvanR-work> not to mention the unmentionables
12:05:14 <wlangstroth> I see we're on a roll
12:07:09 <pumpkin> benmachine: it's a simple way to set apart "not haskell, GHC internals" from pure haskell
12:07:22 <pumpkin> although there's nothing stopping you from calling your own regular haskell functions names with hashes in them
12:07:27 <arcatan> http://lolympics.com/files/images/motivational-poster-barrel-roll-02.jpg
12:07:34 <arcatan> ok, i'll get my coat ->
12:11:34 <EvanR-work> exit, stage left
12:12:40 <benmachine> pumpkin: but that could be done using existing names, like jhc does it
12:12:48 <benmachine> and we don't get a nice operator name sometimes eaten
12:14:20 <pumpkin> yeah, I guess
12:17:35 <ClaudiusMaximus> so i have a continuously differentiable complex function f :: C -> C -> C, and a value b :: C , and i need to solve:  f u v - u == 0  , df/du u v - b == 0   -- any particularly nice libraries i should look at?
12:18:42 <dankna> So!  I have a problem.  I have large records and I want to compare them for equality, in the sense of "shares the same memory space"
12:23:08 <mauke> impossible
12:23:08 <ClaudiusMaximus> @hoogle really
12:23:08 <lambdabot> No results found
12:23:08 <Twey> Stablename
12:23:08 <dankna> That's what I feared.  What are some workarounds?  I could put an ID field in each instance, but then I'd have to ...
12:23:08 <dankna> ... construct them in IO.
12:23:08 <dankna> yeah, StablePtr isn't really a solution, there's no guarantee that I'll get the same one twice
12:23:08 <Twey> True
12:23:08 <Twey> IDs it is
12:23:08 <dankna> I guess so :/
12:23:08 <Twey> You don't *have* to construct them in IO
12:23:08 <dankna> well, unsafePerformIO is cheating :)
12:23:08 <Twey> You can safely unsafePerformIO here
12:23:09 <dankna> hm
12:23:09 <Twey> (and indeed Data.Unique does exactly that)
12:23:09 <EvanR-work> use ocaml!
12:23:09 <mauke> just use javascript
12:23:09 <Twey> Haha
12:23:09 <dankna> what package is Data.Unique in?
12:23:09 <dankna> I think I've reimplemented it unknowingly two or three times :)
12:23:09 <dankna> @hoogle Data.Unique
12:23:09 <lambdabot> module Data.Unique
12:23:09 <lambdabot> Data.Unique data Unique
12:23:09 <lambdabot> Data.Unique hashUnique :: Unique -> Int
12:23:09 <Twey> uniqueid
12:23:09 <EvanR-work> you have to cheat since memory space isnt a haskell concept?
12:23:09 <dankna> thanks!
12:23:09 <EvanR-work> and whatever library will use unsafePerformIO or similar?
12:23:09 <dankna> Evan: well, yes, I take that point, heh
12:23:09 <Twey> So long as the IDs are effectively opaque, it's still referentially transparent
12:23:09 <ClaudiusMaximus> arrg, hayoo seems to be down
12:23:09 <dankna> yeah - no problem with that
12:23:09 <Twey> You can't tell that they're not the same object except that they never test equal
12:23:09 <Twey> (which could be achieved with a custom Eq instance)
12:23:09 <dankna> the specific case in which I ran into this was in trying to write a check for recursive data structures, by the way
12:23:09 <roconnor> persumably Data.Unique is some sort of monad?
12:23:09 <roconnor> *is generated by some sort of monad
12:23:09 <Twey> roconnor: IO + unsafePerformIO
12:23:10 <aristid> roconnor: newUnique :: IO Unique
12:23:10 <roconnor> Twey: but I mean the abstact interface
12:23:10 <roconnor> pfft
12:23:10 <roconnor> IO
12:23:10 <aristid> Twey: no unsafePerformIO
12:23:10 <roconnor> lame
12:23:13 <EvanR-work> IO pah!
12:23:14 <aristid> roconnor: yea.
12:23:20 <aristid> not really necessary
12:23:22 <Twey> Oh, is it IO Unique?
12:23:25 <benmachine> dankna: dejavu, I'm sure there's a package somewhere about detecting recursive structures
12:23:27 <EvanR-work> MonadUnique
12:23:27 <Twey> It was unsafePerformIO back when I used it
12:23:47 <aristid> uniqSource = unsafePerformIO (newMVar 0)
12:23:49 <benmachine> one of matt morrow's, if my very vague memory is correct
12:23:53 <aristid> that is unsafePerformIO
12:23:58 <aristid> newUnique itself is in IO
12:23:59 <dankna> benmachine: hmm.... that would be nice, perhaps
12:24:12 <benmachine> pumpkin: do you know what I'm talking about
12:24:45 <pumpkin> vacuum does it
12:24:48 <benmachine> that's the one
12:25:16 <pumpkin> I keep meaning to make a serialization package on top of it, but I also forget to add it to my todo list so keep forgetting to do so
12:25:38 <dankna> you know the solution to that problem? :)
12:25:48 <pumpkin> I don't have my todo list with me!
12:25:53 <pumpkin> I'll email it to myself
12:25:55 <dankna> haha
12:26:19 <EvanR-work> ill have to remember to write down the stuff i keep forgetting
12:26:34 <benmachine> I made a 'tell' bash alias
12:26:42 <benmachine> to write stuff down that I thought of and wanted preserved
12:27:12 <roconnor> I don't know how to write effectient modular code in ocaml.  I can't just write fun _ -> expr and expect the argument not to be evaluated.
12:27:21 <alpounet> that's very handy yeah
12:27:24 <roconnor> How do people live without laziness
12:27:28 <alpounet> i have written smth similar
12:27:38 <Twey> roconnor: With effort and generators
12:27:41 <EvanR-work> roconnor: lambdas right
12:27:51 <benmachine> make everything () -> a
12:27:52 <roconnor> other code that would be constant space in Haskell is O(n) in ocaml
12:27:56 <benmachine> that's not awkward at all
12:27:58 <EvanR-work> wrap lambdas around it for the sake of delaying evaluation
12:28:18 <mauke> there's a Lazy module somewhere
12:28:23 <alpounet> roconnor, use the Lazy module
12:29:03 <pumpkin> ooh, alpounet is back!
12:29:05 * roconnor ponders lazifying his generic traversal in ocaml
12:29:27 <roconnor> hmm
12:29:30 <roconnor> that could work
12:29:46 <roconnor> though if people want to use side effects, then that will reorder everything
12:30:07 <EvanR-work> lazy side effects!
12:30:15 <EvanR-work> the effect happens only when you need it to
12:30:42 <roconnor> ugh
12:30:56 <roconnor> trying to figure out the order of effects in a higher order functions is hard.
12:31:19 <EvanR-work> i have an idea for how to express that better
12:31:36 <alpounet> pumpkin, eh
12:31:46 <pumpkin> alpounet: we missed you!
12:31:47 <EvanR-work> its a new paradigm where you write effects as a sequence of commands, which occur in the order written
12:32:07 <EvanR-work> mutable variables actually fit naturally into this scheme
12:32:11 <EvanR-work> i expect it to take off 
12:32:16 <roconnor> EvanR-work: how does that work with higher order functions?
12:32:35 <roconnor> EvanR-work: you'd effectively be restricted to first order functions
12:33:10 <EvanR-work> higher order functions are not supported, lets add object oriented programming instead
12:33:11 <alpounet> pumpkin, what's up ? what have you been upto recently ?
12:33:41 <roconnor> EvanR-work: oh, like that will make for modular code ...
12:33:56 <pumpkin> alpounet: quit phd, traveling, having fun, starting work not too far in the future :)
12:34:12 <EvanR-work> its uncomfortable how many people would say it does
12:34:47 <alpounet> pumpkin, oh, nice
12:34:52 <alpounet> what are you gonna work on ?
12:35:02 <roconnor> EvanR-work: are those different from the people using Java's generics?
12:35:03 <EvanR-work> roconnor: modular means composable?
12:35:11 <pumpkin> alpounet: http://clarifi.com/
12:35:18 <roconnor> EvanR-work: I think so...
12:36:08 <alpounet> pumpkin, what will you actually do there ?
12:36:21 <EvanR-work> im not familiar with java generics, is that like forall a. A -> a -> B
12:36:36 <Kaidelong> does `par` work in place of (>>) when doing IO operations or do you need to do something more special?
12:36:38 <pumpkin> alpounet: write scala, mostly :) not too sure of the specifics yet
12:36:39 <roconnor> I presume so
12:36:46 <pumpkin> Kaidelong: definitely not
12:36:46 <tarrasch> Hello, I'm learning a bit about arrows. Is there any deeper thought in the choice of operators (***) and (&&&)? I mean, any reason why (***) and not something else? Some mnemoic or something?
12:37:02 <Kaidelong> pumpkin: if I want to run a bunch of IO operations in parallel, what should I do?
12:37:22 <EvanR-work> IO in parallel...
12:37:22 <roconnor> forkIO?
12:37:25 <pumpkin> Kaidelong: something like mapM forkIO
12:37:28 <EvanR-work> without threads?
12:37:31 <pumpkin> or mapM_
12:37:42 <Kaidelong> mapM_ should work
12:38:28 <pumpkin> well, the mapM will let you keep the thread ids
12:38:44 <Kaidelong> I just need to know when they are all done, will I require mapM for that?
12:38:57 <Kaidelong> or will the call to mapM_ automatically block until it is finished?
12:39:11 <tarrasch> they are all done ony by one or 'really all'?
12:39:30 <alpounet> pumpkin, sounds cool! I hope you'll enjoy it
12:39:33 <Kaidelong> this is for a simulation involving many musicians manipulating a shared harmony memory bank for n iterations
12:39:36 <pumpkin> nope, you should probably use a concurrency primitive to keep track of who's done
12:39:56 <EvanR-work> mapM_ takeMVar
12:41:02 <Kaidelong> hmm, I see, you set up each IO action to give you an MVar when it is finished, initiate all the MVars to empty ones, then mapM_ blocks until each thread writes to its MVar?
12:41:05 <Kaidelong> that's clever
12:41:18 <Kaidelong> I think I will do that, let me take notes
12:41:23 <pumpkin> MVar () is common
12:41:39 <pumpkin> so your caller of the various subthreads would prepare a bunch of MVars
12:41:43 <pumpkin> and hand them to the IO actions
12:41:50 <pumpkin> then wait on them
12:42:07 <tarrasch> I guess it would be dangerous for lots of threads to decrease a MVar Int?
12:42:11 <Kaidelong> this is helpful, thanks
12:42:31 <tarrasch> or just 2 doing it, if they try to write at the same time
12:42:33 <Kaidelong> tarrasch: I don't know why it would be, a semaphore should work for me too
12:42:37 <pumpkin> tarrasch: not dangerous, but you don't have an easy way to query whether the MVar Int is 0
12:42:43 <Kaidelong> tarrasch: aren't MVars atomic?
12:43:06 <Kaidelong> the problem would be that you'd have to check the semaphore repeatedly
12:43:21 <Kaidelong> with the MVar () you can just block until there is a () in the MVar
12:43:48 <tarrasch> oh sorry, my mistake. What was the name of the "normal variables" if not MVar?
12:43:51 <shapr> preflex: @seen ProfTeggy
12:43:51 <preflex>  Sorry, I haven't seen ProfTeggy
12:43:55 <Kaidelong> IORef?
12:43:57 <roconnor> @type takeMVar
12:43:57 <lambdabot> Not in scope: `takeMVar'
12:43:58 <tarrasch> oh right
12:45:08 <Kaidelong> so if I have the thing
12:45:14 <Kaidelong> mapM_ takeMVar >> foo
12:45:27 <Kaidelong> everything has to be done before foo gets executed, right?
12:45:53 <Kaidelong> it won't asynchronously execute foo because it isn't doing a >>=?
12:46:15 <Kaidelong> or rather doing one into a wildcard pattern
12:46:33 * Kaidelong is hoping IO won't outsmart him here basically
12:47:11 <pumpkin> nope, that should be fine (assuming you have a list of mvars passed in too)
12:47:18 <pumpkin> mapM_ takeMVar mvars 
12:47:22 <Kaidelong> great
12:47:28 <Kaidelong> I know exactly how to write my simulation now
12:47:58 <pumpkin> replicateM 100 emptyMVar
12:48:06 <pumpkin> newEmptyMVar
12:48:10 <Kaidelong> just hoping that it will converge in a useful way (since I'm taking out one of the original rules from harmony search to improve efficiency, hoping the concurrent musicians will make up for it)
12:48:41 <Kaidelong> (could add the rule back actually, it'll just make more blocking happen on the MVars
12:55:15 <Kaidelong> musician :: Int -> HarmonyMemoryBank -> MVar () -> IO ()
12:55:19 <Kaidelong> this look good?
12:56:00 <roconnor> shouldn't it return IO (MVar ())?
12:56:01 <Kaidelong> the int being a number of iterations, the harmony memory bank being a reference to the vector of MVars storing the harmony memory bank, the MVar () being the callback to say it is done, and the IO () being the result
12:56:01 <EvanR-work> whats Int
12:56:03 * roconnor isn't sure
12:56:09 <pumpkin> roconnor: it's going to be forkIO'd
12:56:23 <pumpkin> Kaidelong: presumably they're going to need to communicate with each other?
12:56:28 <roconnor> @type forkIO
12:56:29 <lambdabot> Not in scope: `forkIO'
12:56:35 <pumpkin> IO () -> IO ThreadID
12:56:41 <roconnor> ah
12:57:01 <EvanR-work> it can make a new empty mvar before the fork
12:57:05 <roconnor> maybe a zipWithM_ would be helpful here :)
12:57:07 <EvanR-work> pass it to the fork
12:57:09 <EvanR-work> and return it
12:57:35 <Kaidelong> wait, maybe I misunderstood something, why would IO (MVar ()) be advantageous in this situation?
12:57:42 * hackagebot iteratee 0.5.0.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.5.0.0 (JohnLato)
12:57:45 <Kaidelong> oh
12:57:49 <Kaidelong> nevermind I just got it
12:58:11 <Kaidelong> you use mapM musician ... >>= mapM_ takeMVar?
12:58:54 <Kaidelong> then >> onto whatever else you need to do
12:59:44 <Eduard_Munteanu> I'd think a fork duplicates all context, so all you need is have an MVar created before the fork.
13:00:21 <roconnor> Kaidelong: I was wrong about IO(MVar())
13:00:22 <Eduard_Munteanu> so, forkIO thread >> takeMVar
13:00:26 <roconnor> Kaidelong: I think
13:00:32 <EvanR-work> Eduard_Munteanu: thats what i meant by 'pass it to'
13:00:36 <EvanR-work> meaning... 'close over'
13:00:56 <EvanR-work> its too simple to explain!
13:00:58 <Eduard_Munteanu> erm, forkIO (thread mvar) >> takeMVar mvar
13:01:00 <Twey> newMVar >>= forkIO . thread
13:01:07 <Twey> Right
13:14:47 * hackagebot mutable-iter 0.2 - iteratees based upon mutable buffers  http://hackage.haskell.org/package/mutable-iter-0.2 (JohnLato)
13:31:01 <dankna> has anyone used the value-supply library?  can you explain how I use it, precisely?  asking for the value twice in a row yields the same value...
13:31:23 <dankna> I cannot read the paper it's based on as I am no longer affiliated with the institutution which used to get me access to such things :(
13:31:38 <joe1> where is ksf?
13:31:50 <joe1> ksf: been searching for him for a few days..
13:31:53 * ksf appears in a puff of magic smoke
13:32:13 <joe1> really?
13:32:25 <EvanR-work> more magic stuff
13:32:35 <nolrai222> @
13:32:36 <EvanR-work> haskell is a very magical system
13:33:12 <ksf> for some value of magic, yes. I'm out of fairy dust, so common secular smoke had to do.
13:33:31 <EvanR-work> no its real!
13:34:02 <nolrai222> > 1+1
13:34:03 <lambdabot>   2
13:34:04 <Lemmih> dankna: Use split.
13:34:11 <joe1> ksf: just wanted to thank you, I do not think you might remember. But, your comments on my program have been very helpful. I built a program using types and I feel as if I have jumped to the next level of programming.
13:34:28 <ksf> used the last of the dust to prepare a hotdog. it tends to dissapear, then, for some inexplicable reason.
13:34:42 <dankna> Lemmih: hmm...
13:34:42 <joe1> my initial program was using a bunch of do functions.
13:34:47 <chrisdb> silly question: if lambda bot evaluates expressions, what happens if you give it something that won't terminate?
13:34:51 <ksf> yeah I remembre
13:34:54 <kmc> it times out
13:34:55 <kmc> > fix id
13:34:55 <mauke> > fix id
13:34:58 <joe1> and I changed it to use types and it looks so much more elegant.
13:34:59 <lambdabot>   mueval-core: Time limit exceeded
13:34:59 <lambdabot>   mueval-core: Time limit exceeded
13:35:21 <dankna> so I have to make my own monad or other means of passing around the supply, then.
13:35:35 <kmc> dankna, did you try Data.Unique instead?
13:35:37 <Lemmih> dankna: Yes.
13:35:38 <Eduard_Munteanu> chrisdb: look on the wiki, it can withstand quite a lot.
13:35:46 <EvanR-work> roll your own monads
13:35:47 <Eduard_Munteanu> It's pretty safe.
13:35:51 <joe1> ksf: Once you have a program with types, what is the next level? how would you refactor it?
13:36:05 <EvanR-work> joe1: kind level programs
13:36:09 <dankna> I looked at it, but there was a note on the hackage page for it that the author considers Data.Unique obsolete in favor of Data.Supply, and Data.Supply is based on a paper so I figure hey, theoretical grounding is always nice...?
13:36:14 <kmc> shrug
13:36:24 <dankna> well, if I get too stuck on this I'll try Data.Unique of course
13:36:25 <ksf> joe1, just paste it and #haskell is going to golf it.
13:36:45 <Lemmih> dankna: Data.Supply is just an IORef + unsafeInterleaveIO.
13:37:02 <dankna> Lemmih: that's a little disappointing.  I'm not sure I understand why it does unsafe IO internally if I have to pass it around myself.  but okay, I can do that...
13:38:19 <Lemmih> dankna: That's so it can be used in pure code.
13:38:20 <joe1> ksf: this is what I ended up with: http://hpaste.org/paste/40777/type#p40835 , please scroll to the bottom.
13:39:03 <Lemmih> dankna: Things that require a supply of new values doesn't generally reside in IO.
13:39:17 <joe1> ksf: i am changing the program radically so I am looking for input on, something similar to "changing it to use types"
13:39:23 <dankna> hmm...  I suppose
13:39:31 <joe1> ksf: or some structural suggestions.
13:40:01 <joe1> ksf: would you think I would still hate the program in 6 months?
13:40:19 <kmc> how can you write a Haskell program that doesn't use types?
13:40:30 <tarrasch> What does "change it to use types" mean??
13:40:37 <tarrasch> oh ok
13:40:42 <kmc> dankna, you have to pass it, but the "get a value out" operation is not in IO
13:40:42 <aristid> kmc: by not writing them down
13:40:47 <kmc> you're still using types
13:40:54 <kmc> writing signatures for top-level bindings is good style
13:40:57 <tarrasch> in your code you use strings all the time. That's weird to my eyes.
13:40:58 <dankna> kmc: hmm - okay, I understand, I believe
13:41:00 <kmc> it's not a fundamental shift in how your program works though
13:41:06 <kmc> it just catches more errors
13:41:09 <kmc> and gives better error messages
13:41:17 <joe1> i was using a bunch of IO functions, nested 2-3 levels without types and ksf came up with the suggestion that I should use ADT.
13:41:18 <EvanR-work> kmc: disable type safety at compile time, and enable sexpressions
13:41:22 <kmc> ah, ok
13:41:35 <EvanR-work> the command is apt-get install clisp
13:41:42 <joe1> ksf: his comment set me off to learn about types and my journey ended with this program.
13:41:48 <dankna> but I actually need to keep the Supply inside an IORef so that I can replace it with its successor, don't I.  so I don't really get that benefit.
13:42:13 <ksf> erm... Functor ((,) a) ?
13:42:15 <tarrasch> joe1, Do you mean type signatures???
13:42:17 <ksf> can't find it.
13:42:41 <ksf> oh, applicative.
13:43:10 <EvanR-work> dankna: getContents plus State doesnt accomplish this Supply thing?
13:43:15 <joe1> tarrasch: this was the first version of my program : http://hpaste.org/40781/usb_messages
13:43:18 <EvanR-work> if its indeed needing interleaveio
13:43:25 <dankna> I mean I can query any one supply without being in IO, but if my use-case is creating serial IDs for data structures...
13:43:43 <EvanR-work> then you dont need IO
13:44:14 <joe1> i ended up with http://hpaste.org/paste/40777/type#p40835 (scroll to the bottom) after embarking on the "type" journey suggested by ksf
13:44:22 <dankna> EvanR: I'm not totally sure what you're asking re getContents.  yes, the library is fairly trivial (one short source file), but it's nice to think that I'm doing things in a way other people might recognize rather than inventing my own.
13:44:44 <EvanR-work> dankna: well Unique....
13:44:55 <EvanR-work> i searched for stable names on google and got stuff about horses
13:45:02 <dankna> haha, well done
13:45:03 <EvanR-work> so much for advanced artificial intelligence
13:45:16 <tarrasch> joe1, I would like to point out that another improvement you did is that you don't have all code in one function. Even though you can work on it a bit more.
13:45:43 <joe1> tarrasch: sure, thanks.
13:45:55 <joe1> ksf: do you have any comments? was that functor comment meant for me?
13:46:28 <ksf> nope.
13:46:35 <ksf> http://hpaste.org/40902/move_by_numbers
13:46:41 <ksf> I was updating an old paste of mine.
13:47:42 <tarrasch> joe1, You seem to be working with something quite complicated, I would suggest you to solve some educational exercises so you see how simple programs are built. Your current code looks somewhat odd with so much Strings.
13:48:09 <ksf> :t inits
13:48:10 <lambdabot> forall a. [a] -> [[a]]
13:48:38 <joe1> tarrasch: it is an IO intensive program. I could have done it with awk /sed. but, wanted to build up on my haskell skills.
13:48:49 <ksf> > ">>>>> 0x2D" `elem` inits ">>>>> 0x2D foobar"
13:48:50 <lambdabot>   True
13:49:16 <ksf> (not that that is efficient, but it doesn't rely on matching exactly 10 chars)
13:49:28 <ksf> > inits ">>>>> 0x2D foobar"
13:49:29 <lambdabot>   ["",">",">>",">>>",">>>>",">>>>>",">>>>> ",">>>>> 0",">>>>> 0x",">>>>> 0x2"...
13:50:19 <ksf> you don't want to use such small definitions as getdatabytes and databyteslen
13:50:19 <EvanR-work> those are the ranks in haskell military
13:50:31 <erisco> can you specify the precedence of your own infix operators?
13:50:32 <roconnor> isPrefixOf?
13:50:39 <roconnor> erisco: yes
13:50:44 <dankna> well, must dash.  thanks for the assistance.
13:50:46 <ksf> length . tail . getbytes is clearer than remembering a name
13:50:50 <ksf> roconnor, yep.
13:50:53 * erisco facepalms
13:51:08 <erisco> better way to ask it: how do you specify the precednce of your own infix operators?
13:51:14 <chrisdb> That must have made the parser for Haskell pretty complicated.
13:51:23 <chrisdb> Since normally precendence gets hard coded into parsers...
13:51:34 <joe1> ksf: ok, thanks.
13:51:44 <ksf> erisco, try infix[l|r] <number>
13:51:48 <erisco> I am not sure how to do it in Haskell and am having a miserable time finding how
13:51:54 <ksf> oh, and put the operators in there, too.
13:52:12 <ksf> infixl 4 + or something.
13:53:15 <tarrasch> I remember I had a hard time googling for that information too
13:53:33 <ksf> joe1, you might want to have a look at a parsing and pretty-printing library.
13:54:01 <ksf> it's not really necessary here, but those beasts are good to know about.
13:54:34 <joe1> ksf: i checked out parsec, but as I can control the input file, I just stuck with something simple.
13:55:04 <EvanR-work> map words . unlines parser for the win
13:55:07 <joe1> ksf: i shoud check out the pretty printing library, I have no idea what it does, other than being impressed by its' output.
13:56:01 <ksf> basically, give you a better syntax for string construction, and also make it more efficient.
13:56:25 <roconnor> joe1: this Message data type isn't working for me... 
13:56:31 <ksf> and libraries like the hugespj pretty printer also line-wrap, if you want to, and properly indent.
13:58:26 <McManiaC> anyone familiar with alex? why won't this work? "\\ ^ $special { \s -> TokenText s }" (in the token :- part)
13:59:05 <erisco> ksf: thanks. I couldn't find any equivalent for the Miranda language
13:59:08 <erisco> bummer
13:59:11 <McManiaC> it should produce something like this `alexScanToken "\\*" `-> TokenText "*"
13:59:16 <erisco> brackets it is then
13:59:19 <roconnor> joe1: Message should have probably have a constructor for each message type.
13:59:49 <ksf> erisco, prepare to be sued.
14:00:15 <erisco> ksf: what did I say? :s
14:00:35 <ksf> you forgot the magic words "Miranda is a trademark of Research Software Ltd"
14:00:55 <erisco> I cannot mention the name?
14:01:00 <ksf> yep.
14:01:16 <erisco> hm
14:01:30 <roconnor> joe1: oh wait,
14:01:45 <ksf> apparently, people got so fed up with the situations that early haskell papers all had that note (when they referenced miranda), and subsequently, mentioning haskell, a footnote "Haskell is a trademark of noone in particular"
14:02:06 <roconnor> joe1: maybe you should simply remove dir, tag and dirflags from the Message structure
14:02:06 * hackagebot sndfile-enumerators 0.4.0 - Audio file reading/writing  http://hackage.haskell.org/package/sndfile-enumerators-0.4.0 (JohnLato)
14:02:25 <roconnor> joe1: since they are all defined by msgtype, they are redundant
14:03:03 <erisco> ksf: thankfully I am anonymous here :D
14:04:11 <joe1> roconnor: ok, thanks. sorry i was away.
14:04:42 <joe1> roconnor: yes, it makes sense.
14:04:52 <roconnor> joe1: you can write function from Message -> Maybe Direction, etc.
14:05:05 <roconnor> joe1: then for msg2actions you can use guards
14:05:31 <roconnor> msg2actions msg | msgType msg == Comment = ...
14:05:36 <ksf> msg2actions is suspiciously non-total.
14:05:53 <ksf> -Wall should warn you about it.
14:06:04 <roconnor>                       | dir msg = Just Host2Device = ...
14:06:49 <joe1> what does "non-total" mean?
14:06:55 <ksf> it can fail.
14:07:13 <joe1> i use ghci. is there an option for ghci to warn about such occurrences?
14:07:22 <joe1> so, I can add it to my init file
14:07:26 <joe1> of ghci, i mean.
14:07:29 <ksf> for example with msgtype = Setup and dir = Nothing
14:07:37 <ksf> -Wall
14:07:58 <roconnor> ksf that case will disappear when he removes dir :)
14:08:35 <roconnor> ksf: but still msgtype = InData1 and InData0
14:09:03 <roconnor> joe1: I also think you want to put your MsgType into a heirarchy.
14:09:19 <joe1> roconnor: that is something I was thinking about. 
14:09:33 <roconnor> data MsgType = Comment | RealStuff Stuff
14:09:36 <joe1> but, my amateurish'ness felt that it would be too complicated.
14:09:49 <joe1> at the end of the day, it actually is a heirarchy.
14:09:54 <roconnor> data Stuff = Host2Device H2D | Device2Host D2H
14:09:56 <ksf> oh, and don't use sequence_ with a static list, use a do block instead.
14:10:05 <joe1> I will look into that more closely now.
14:10:13 <roconnor> data H2D = Setup | Out
14:10:25 <roconnor> data D2H = InData0 | InData1
14:10:30 <ksf> or, in that case, factor out triggerin . datafilename
14:10:33 <ksf> that's a good exercise.
14:10:51 <joe1> ksf: will do so. thanks a lot.
14:11:07 <ksf> oh no wait no don't. just do triggerin.
14:11:09 <roconnor> joe1: the shape of the data reflects the way it is processed and/or produced
14:11:21 <ksf> factoring out datafilename would be obfuscation.
14:11:40 <joe1> roconnor: i will go with the heirarchial data structure. At the very least, I will learn up on it.
14:13:30 <ksf> roconnor, any comments on age-old code of mine? http://hpaste.org/40902/move_by_numbers
14:14:58 <sproingie> very pipeliney
14:17:29 <merijn> Can anyone point me to a good explanation of a zipper? The one on the haskell wiki/wikipedia aren't doing it for me...
14:17:36 <ksf> the paper
14:17:49 <joe1> if I go with a heirarchial data type, to process it i should be using a recursive function, right?
14:17:54 <ksf> or the xmonad docs
14:18:04 <roconnor> merijn: Heut's paper is pretty good.
14:18:07 <ksf> http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
14:18:27 <roconnor> merijn: and then the first 1 or 2 sections of Clowns to the Left / Jokers to the RIght
14:18:53 <roconnor> merijn: the tricky bit is I found that different resources have subtly different definitions of a zipper, which can be confusing.
14:18:56 <merijn> roconnor, ksf: Ok, I'll try the paper first then
14:18:58 <chrisdb> merijn: do you also frequent any language boards? I know another merijn and I was just wondering if the two are one.
14:19:00 <ksf> http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source/StackSet.hs
14:19:05 <chrisdb> Probably not, though.
14:19:11 <wlangstroth> anyone know what the advantages are to continuation passing style?
14:19:15 <ksf> there's also http://en.wikibooks.org/wiki/Haskell/Zippers
14:19:40 <chrisdb> *linguistics
14:19:50 <merijn> ksf: Yeah, but that's got too much fluff, not enough concrete example for me. Or maybe I'm just too tired now to grok it regardless of explanation
14:20:19 * hackagebot hCsound 0.3.0 - interface to CSound API  http://hackage.haskell.org/package/hCsound-0.3.0 (JohnLato)
14:20:20 <ksf> wlangstroth, in my experience it either comes naturally to code or you shouldn't do it.
14:20:23 <merijn> chrisdb: Unlikely, I've only recently started on my road as a pretentious academic :p
14:20:38 <ksf> ...speaking about code structure, though, not cps transformation, that's another topic.
14:20:43 <chrisdb> I guess not then. Oh well....
14:20:45 <roconnor> wlangstroth: it is often faster for some reason.
14:20:49 <chrisdb> Is it a common name in the Netherlands?
14:21:08 <merijn> chrisdb: Not really, only heard it like 2-3 times in my life
14:21:14 <ksf> roconnor, well but then there's codensity.
14:21:21 <ksf> no need to code in cps.
14:21:24 <roconnor> ksf: codensity is like cps
14:21:30 <chrisdb> OK. Thanks anyway.
14:21:46 <roconnor> indeed codensity is what I was thinking of
14:21:58 <roconnor> though cps can even be faster than codensity :O
14:22:45 <ksf> supercompilation hopefully gets rid of that difference.
14:23:28 <ksf> I don't feel particularily comfortable spreading fairy dust over my code. I rather have a sufficiently smart compiler.
14:23:30 <roconnor> ksf: ya I would hope so
14:23:42 <roconnor> ksf: I'm ambivalent
14:24:42 <ksf> as for cps in a compiler, it's a very convinient and homogenous representation.
14:24:52 <merijn> I'm seriously annoyed by the apparent lack of a solid Haskell networking framework...going to have to roll my own or something >.>
14:24:55 <ksf> makes e.g. dead code elimination a no-brainer.
14:25:15 <ksf> happstack?
14:25:32 <roconnor> merijn: yay!
14:25:33 <ksf> hmmm network-bytestring...
14:25:40 <merijn> ksf: Isn't that mostly aimed at being a web framework?
14:25:42 <ksf> have a look at combinatorrent.
14:25:43 <merijn> Is Network & Network.Socket really the only thing?
14:25:53 <chrisdb> Well, I guess library coverage is a function of language use? So hopefully if Haskell stays popular...
14:25:57 <blackh> merijn: network-bytestring
14:25:57 <merijn> ksf: I did, its coded using Network.Socket
14:26:04 <ksf> which manages a gazillion of sockets.
14:26:16 <blackh> merijn: What do you need?
14:26:31 <ksf> also, there's the new IO manager. you shouldn't need much more than that.
14:26:48 * chrisdb loves the IO changes
14:26:58 <chrisdb> Mostly because they finally have decent unicode support in 6.12 though
14:27:00 <aristid> chrisdb: which changes?
14:27:00 <merijn> Which IO changes?
14:27:11 <aristid> oh you mean from 6.10 to 6.12?
14:27:16 <ksf> epoll, for example.
14:27:16 <chrisdb> Yes.
14:27:19 <ksf> nope to 7.0
14:27:20 <chrisdb> Not the epoll ones.
14:27:33 <aristid> chrisdb: basically everybody uses 6.12 already, so it's not a change :P
14:27:40 <merijn> blackh: I'm not sure yet, but I'm sure raw sockets isn't it
14:27:43 <wlangstroth> ksf, roconnor: thanks - I was evaluating it as either worth researching or not, but marginal performance gains can be had elsewhere
14:27:56 <ksf> oh it's not always marginal.
14:28:03 <merijn> epoll support, does that mean kqueue too?
14:28:04 <blackh> merijn: You might have to be a bit more specific. :)
14:28:35 <chrisdb> The main reason I bothered to upgrade was the better unicode handling in the core IO functions.
14:28:41 <ksf> but you can just take the codensity applicative functor/monad and wrap your stuff in it, and if you get a decent speedup, then possibly consider re-writing stuff in cps.
14:28:44 <blackh> merijn: One important thing to remember is that Haskell doesn't need event-based I/O.
14:28:50 <roconnor> wlangstroth: I got a 4x increase in speed by sticking codensity on top of my monad stack.
14:29:07 <roconnor> wlangstroth: though that was several versions of GHC ago
14:29:24 <ksf> merijn, it means whatever the OS supports
14:29:30 <ksf> (except on windoze, right now)
14:29:36 <kmc> epoll, kqueue, select
14:29:39 <kmc> and some lame windoze thing
14:29:40 <merijn> blackh: Not needing event-based IO is not a reason not to have socket multiplexing
14:29:55 <kmc> you multiplex by spawning threads and having them communicate
14:30:14 <merijn> blackh: N blocking socket calls in N threads will still block the entire program, no?
14:30:27 <ksf> if epoll sends an event, your thread is going to wake. lim -> 0 overhead.
14:30:28 <kmc> merijn, one of the calls returns
14:30:34 <kmc> then you can shove an event down a Chan or whatever
14:30:40 <ksf> merijn, haskell threads, not OS threads.
14:30:43 <kmc> i'm not saying there's no room for a library here, but it's a simple library
14:30:43 <joe1> the -Wall is proving to be awesome. I cannot believe that there were so many warnings in my code.
14:30:47 <joe1> Thanks again.
14:30:57 <ksf> joe1, also do cabal install hlint
14:31:00 <kmc> this is a common problem with Haskell.  the rest of the world lacks some feature and invents an insane workaround.  then people show up angrily asking why Haskell doesn't support this insane workaround
14:31:05 <merijn> ksf: Pretty sure haskell threads can't block, so they will have to block the OS thread
14:31:19 <ksf> let the IO manager worry about that.
14:31:21 <joe1> ksf: i used hlint on that code. does not seem to catch that much.
14:31:21 <merijn> Since blocking happens in the OS code
14:31:22 <blackh> merijn: I don't understand - N blocking socket calls in N threads means the program has nothing to do, so of course it should block.
14:31:34 <kmc> merijn, blocking IO operations are handed off to the IO manager, which will use select or (in 7.0) epoll or kqueue
14:31:48 <ksf> you're optimizing prematurely. haskell already does the low-level IO for you, and it's _very_ unlikely you're going to be able to do a better job.
14:32:10 <ksf> you can use the new manager with 6.12, too, it's on github.
14:32:12 <wlangstroth> roconnor: I see - maybe worth checking out, then - thanks
14:32:13 <merijn> kmc: Ah, but that is not actually mentioned anywhere
14:32:35 <ksf> and if you don't use the new one, you're merely stuck with select.
14:32:35 <kmc> merijn, well, it's how threads obviously should work.  just not how they *do* work in other languages
14:32:44 <ksf> which should be enough, at least for development.
14:33:08 <kmc> haha
14:33:31 <merijn> kmc: The only thing mentioned is the apparent complete lack of select & friends, which doesn't encourage one to assume the IO libraries use select internally
14:33:41 <roconnor> wlangstroth: someone else said they did the same thing and got nothing from there code
14:33:59 <roconnor> wlangstroth: for me, a signifigant portion of my profiled time was being spend in >>=
14:34:12 <kmc> merijn, mentioned where?
14:34:18 <roconnor> wlangstroth: I thought there was nothing to be done about that,... until I learned about codensity
14:34:20 <kmc> i assume you did not read all documents about Haskell everywhere
14:34:32 <kmc> so your universal quantifier must have a bound
14:34:42 <merijn> kmc: Well mentioned in the sense that I was looking for select for haskell and its nowhere to be found and people here told me it didn't exist
14:34:44 <blackh> merijn: That's true.  GHC with the new I/O manager is seriously good.
14:35:08 <ksf> http://www.haskell.org/ghc//docs/6.12.1/html/libraries/base/Control-Concurrent.html#v%3AthreadWaitRead
14:35:12 <kmc> merijn, and people here also told you that the IO manager will handle it for you
14:35:14 <kmc> so, what's the problem?
14:35:18 <kmc> your source gave you the correct answer
14:35:23 <aristid> blackh: the 7.0 manager?
14:35:28 <ksf> there, you can even do it manually.
14:35:37 <kmc> anyway i've got to go, ttyl all
14:35:39 <blackh> aristid: Don't quote me, but I think it's been integrated into ghc 7.0.
14:35:39 <ksf> if you use Handles, everything is going to be automatic.
14:35:42 <merijn> kmc: That was today, I was asking about this earlier and at that time no one mentioned IO manager etc
14:35:53 <aristid> blackh: cool.
14:36:25 <blackh> merijn: It's fairly new.
14:37:06 <merijn> blackh: Well, if its using select in GHC6.12 I don't assume it was implemented somewhere between two days ago and now :p
14:37:08 <ksf> "The System.IO  library still does multiplexing, so there can be multiple threads doing I/O, and this is handled internally by the runtime using select. "
14:37:16 <ksf> (that's 6.12.1)
14:37:33 <ksf> ...even without -threaded
14:37:58 <merijn> Anyhoo, then I will happily do it with forkIO instead of finding a more complex solution
14:38:02 <ksf> there's not _that_ many low-level IO coders, here.
14:38:03 <blackh> merijn: The new bit is the new I/O manager which solves the "C10K" problem.  The old I/O manager (as used in ghc-6.12) uses the same basic model, but won't scale as well.
14:38:45 <merijn> blackh: I know about select/kqueue and friends, done quite a bit of socket programming in python and C
14:39:06 <merijn> But select should be more then enough for any reasonable use case I have atm
14:40:17 <merijn> Anyhoo, its bed time now. I'll start a-fresh tomorrow :)
14:40:21 * ksf recommends network-bytestring.
14:40:35 <merijn> ksf: I'll check it out
14:40:36 <ksf> and iteratees, if you have more serious processing going on.
14:40:50 <blackh> merijn: Night night! Even with ghc-6.12, you should be able to do thousands of connections at once.
14:40:54 <ksf> otherwise, hand-rolled code is going to be easier than bending your head around iteratees.
14:41:03 <blackh> ...without blowing your virtual memory
14:41:10 <ksf> 1024 connections.
14:41:15 <wlangstroth> roconnor: codensity in category-extras?
14:41:19 <ksf> active ones, at least.
14:41:32 <blackh> Oh right - because of the limits of select, I remember.
14:41:44 <ksf> oh it's in category-extras.
14:42:41 <roconnor> wlangstroth: ya, but I usually just do the transform by hand
14:43:39 <ksf> wlangstroth, http://www.haskell.org/haskellwiki/Performance/Monads
14:43:48 <wlangstroth> roconnor: oh, I see - I was just wondering if I was ever going to find a package where Edward Kmett wasn't at least a minor contributor.
14:44:07 <ksf> wlangstroth, http://wwwtcs.inf.tu-dresden.de/~voigt/mpc08.pdf
14:44:58 <wlangstroth> oh, excellent - thanks, guys
14:45:09 <ksf> serious brain meltage may lie ahead, though, as is usual when it comes to continuations.
14:45:23 <roconnor> wlangstroth: http://hackage.haskell.org/package/monad-ran  <-- this might even be useable
14:45:26 * roconnor isn't sure
14:45:39 <wlangstroth> pff - whatever; I'm translating Thucydides; this stuff is a cake walk
14:45:55 <roconnor> wlangstroth: monad-ran defines codensity without importing all of category-extras
14:46:24 <wlangstroth> kmett, you magnificent bastard!
14:46:43 <roconnor> wlangstroth: in fact, you can just stick Ran on top of your monad stack and everything will be magically optimized
14:46:51 <roconnor> even more so than sticking codensity on top
14:47:31 <aristid> wlangstroth: your website is weird
14:47:31 <EvanR-work> roconnor: why does what you just said seem impossible or sarcastic
14:47:46 <aristid> wlangstroth: both of them
14:47:49 <roconnor> EvanR-work: because it uses type families
14:48:20 <RickF> I've been having a grand time trying to work through the parsec tutorial.
14:49:01 <aristid> RickF: are you all excited about it?
14:49:01 <wlangstroth> aristid: I'm 'eccentric', which is what you call crazy people when they're not homeless
14:49:01 <RickF> 'Parser' is not in scope.
14:49:05 <ksf> RickF, then you're going to love the uu-parsinglib tutorial.
14:49:13 <aristid> wlangstroth: glad to hear you are not homeless.
14:49:27 <ksf> parser is usually a type synonym.
14:49:47 <ksf> something like type Parser = ParsecT Char Whatever Identity Foobar Quux
14:49:59 <wlangstroth> aristid: :)
14:51:09 <RickF> but shouldn't import Text.Parsec, Text.Parsec.Token, and Text.Parsec.Language create the synonym if that's what the tutorial calls it?
14:51:34 <RickF> or does worksOutOfTheBox not apply?
14:51:46 <RickF> I know the answer to that question
14:51:57 <ksf> I think the tutorial is a bit outdated.
14:51:58 <RickF> I had to change the names of the imports and add paths
14:52:13 <EvanR-work> wlangstroth: so non homeless homeless people
14:52:14 <ksf> ...which means you're using a newer major version of parsec.
14:52:20 <ksf> most stuff should still apply, though.
14:52:49 <RickF> so the PDF is more of a "Lookie what we did" and not a "use this tool as follows"?
14:52:57 <wlangstroth> EvanR-work: your depth of understanding is beacon to all
14:53:07 <ksf> and, tbh, you can just leave out the signatures.
14:53:22 <wlangstroth> EvanR-work: is there a sarcasm operator in Haskell?
14:53:25 <EvanR-work> wlangstroth: i do think i can related to this pigeon holing
14:53:32 <ksf> RickF, well, it was worksOutOfTheBox, at one point.
14:53:33 <EvanR-work> relate*
14:53:49 <Cale> "Use this as follows in 2002"
14:53:52 <ksf> but tracking down the right version would probably be more work than adapting it.
14:54:17 <RickF> you think there may actually be a current manual?
14:54:38 <ksf> dunno, I didn't use parsec for a long time now.
14:55:04 <Cale> The current manual would be the haddock documentation which you can find on Hackage.
14:55:09 <wlangstroth> EvanR-work: well, we're all on the Haskell channel, and madness and creativity have long been tight
14:55:20 <Cale> It's not as much of a tutorial as the old documentation though
14:55:34 <Cale> http://hackage.haskell.org/package/parsec
14:55:38 <EvanR-work> wlangstroth: i mean literally, i seem to have been homeless for half of the last decade
14:55:43 <EvanR-work> yet im on the internet
14:55:44 <Cale> (the module names are links to documentation)
14:56:19 <wlangstroth> EvanR-work: oh, are you freelance, too?
14:56:29 <blackh> EvanR-work: What??? You mean you've actually had NO web server??
14:56:30 <RickF> I installed 3.1; should the matching doc have copied too?
14:56:47 <EvanR-work> blackh: at the moment i dont even have internet
14:57:34 <ksf> RickF, you can just use parsec 2, if you want.
14:59:30 <RickF> I started with that. is cabal happy installing older over newer?
14:59:56 <ksf> you can install all versions there are, if you really want.
15:00:09 <RickF> thanks.
15:03:46 <McManiaC> why is the order of "stmts" and "stmt" reversed in the first line of the last code block on http://www.haskell.org/happy/doc/html/sec-sequences.html ?
15:03:55 <McManiaC> stmts : stmts ';' stmt          { $3 : $1 }
15:04:48 <ksf> .oO( just don't use parser generators )
15:05:06 <ksf> or, at the very least, don't use yacc-likes.
15:06:51 <ClaudiusMaximus> ouch!  got a crash, is this a GHC bug or something wrong in hmatrix?   http://hpaste.org/40908/segmentation_fault_in_hmatrix
15:07:07 <ClaudiusMaximus> (and i think it must be really bad crash because it seems to have crashed hpaste too)
15:08:16 <EvanR-work> is there a guessBrowser :: UserAgentString -> BrowserName  somewhere?
15:09:54 <wlangstroth> EvanR-work: which browser are you trying to guess?
15:10:22 <ClaudiusMaximus> anyone get anything like this before?  http://codepad.org/g57NKgJT  (segmentation fault in hmatrix)
15:10:33 <youngbull> Hi I am having some problems with a function I am trying to make for yi. I am basicly trying to pretty-print what is marked in the buffer. But it says that the arguments to ++ in line 13 should be of type robe, but that doesn't make any sense! http://hpaste.org/40907/pretfy
15:11:00 <youngbull> GHCI compiles it just fine, it is Yi.Eval that is making a fuzz!
15:15:51 <wlangstroth> EvanR-work: I only ask because it's usually separating IE and everything else
15:16:25 <EvanR-work> wlangstroth: IE firefox chrome safari seamonkey etc
15:16:32 <EvanR-work> anything with a name
15:16:42 <EvanR-work> a best effort guess is good enough
15:18:24 <blackh> ClaudiusMaximus: Looks like it's in the garbage collection of weak references.  I don't know exactly how, but it must be possible to do something to upset GHC with regard to weak references.  Maybe hmatrix is doing something funny in a finalizer.
15:18:36 <blackh> I am using weak references in ghc-6.12.3 without problems.
15:18:50 * hackagebot shellish 0.1.3 - shell-/perl- like (systems) programming in Haskell  http://hackage.haskell.org/package/shellish-0.1.3 (PetrRockai)
15:20:23 <wlangstroth> EvanR-work: that can be anything from easy to monstrous, but it's generally frowned upon in favour of testing for capability; unless you're polling to make a graph or something
15:20:24 <ClaudiusMaximus> blackh: yeah - i have no clue about that stuff - would it be worth reporting it on GHC trac? or is it more likely to be hmatrix at fault?
15:20:58 <EvanR-work> wlangstroth: i know its easy to monstrous, and im leaning toward easy with possibility of large error
15:21:04 <wlangstroth> EvanR-work: then you can probably do it by engine, which would be easier than brand name
15:21:09 <EvanR-work> wlangstroth: yes need some heuristics
15:21:25 <EvanR-work> this isnt for capability
15:21:44 <EvanR-work> basically "is anyone with IE6 ever coming within 10 miles of our website"
15:21:45 <blackh> ClaudiusMaximus: Well, ideally it should be investigated, so if at all possible, someone outside GHC should investigate it, because those guys are busying doing good work, and it's possible it's not a GHC bug.
15:22:17 <ClaudiusMaximus> blackh: ok, i'll report it to hmatrix maintainers first
15:22:35 <blackh> ClaudiusMaximus: Actually I think that's the best thing to do.
15:23:31 <wlangstroth> EvanR-work: they will all have the string "MSIE 6" in them
15:24:14 <blackh> ClaudiusMaximus: If it's crashing repeatably, then it could be a very valuable test case.
15:24:22 <EvanR-work> so to generate this 'browser guess' graph, i should learn these factoids and write it myself
15:24:56 <augur> a few days ago someone linked me to a post about filtering infinite lists in finite time. does anyone remember what the link was?
15:25:05 <EvanR-work> i guess heuristics is something that would go into a hackage package ;)
15:25:08 <EvanR-work> is not*
15:26:25 <wlangstroth> EvanR-work: I can tell you what the rest of the factoids are, but it really depends on how you want to categorize them. So yes, you would have to write it yourself.
15:27:01 <ClaudiusMaximus> blackh: well, i tried the tests that come with hmatrix, ghci exited with a Bus Error
15:27:28 <blackh> ClaudiusMaximus: That's not good.  Are you using a Mac?
15:28:00 * hackagebot ansi-terminal 0.5.5 - Simple ANSI terminal support, with Windows compatibility  http://hackage.haskell.org/package/ansi-terminal-0.5.5 (MaxBolingbroke)
15:28:50 <ClaudiusMaximus> blackh: no
15:29:12 <wlangstroth> EvanR-work: there are also probably a ton of browser sniffing pieces of misguided PHP that would have those strings in them
15:29:27 <blackh> ClaudiusMaximus: Help me out a bit here. :) I'll try your test program.
15:30:27 <ClaudiusMaximus> blackh: i'm on 64bit ubuntu lucid - and you could probably just try the instructions here: http://code.haskell.org/hmatrix/install.html
15:30:36 <wlangstroth> EvanR-work: or for apache http://www.zytrax.com/tech/web/browser_sniffing.html
15:30:56 <EvanR-work> wlangstroth: yes the people in charge are sifting through such php
15:31:16 <EvanR-work> i just figured there was a sane, non over engineered guess
15:31:21 <EvanR-work> in haskell of course
15:31:47 <EvanR-work> with stuff of the form 'if it contains MSIE 6, its ie6' else...
15:32:17 <blackh> ClaudiusMaximus: I don't know what this gsl thing is, but it's a foreign library, so that tends to suggest the problem is probably not with GHC itself.
15:33:52 <ClaudiusMaximus> blackh: right.  (GSL = GNU Scientific Library)
15:34:07 <ClaudiusMaximus> blackh: going to see if i can run a C example and see if that crashes too
15:34:33 <wlangstroth> EvanR-work: the problem is that browsers have spoofed each other, and it makes a mess of simply detecting browsers. Usually engine is good enough, or MSIE
15:35:18 <blackh> ClaudiusMaximus: I'm using Ubuntu lucid 64 bit too, so I'm just giving your code a try.
15:35:22 <ddarius> And why do browsers spoof each other?  Because of browser detection.
15:36:07 * hackagebot heist 0.2.4 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.2.4 (DougBeardsley)
15:36:22 <EvanR-work> wlangstroth: yeah ok, so its IE or webkit or gecko
15:36:47 <ksf> whatever happened to cross-browser compability?
15:36:56 <ddarius> ksf: Browsers happened to it.
15:37:01 <EvanR-work> ksf: its a complete joke?
15:37:08 <blackh> Microsoft happened to it?
15:37:19 <EvanR-work> at least, at this company they like to push the envelope
15:37:21 * wlangstroth throws something at ksf
15:37:38 <wlangstroth> hahahahahahahahahaha
15:37:38 <EvanR-work> which means IE increases our operating costs that much
15:37:45 <wlangstroth> ... heh ...
15:37:49 <ksf> which means you should just ignore IE.
15:37:55 <wlangstroth> ... whoo!
15:38:00 <EvanR-work> i would ignore anything that doesnt work in every browser with graphics
15:38:05 <EvanR-work> but im not in charge
15:38:06 <ksf> care that every link is reachable and every text visible, disable the css, and leave it at that.
15:38:17 <ksf> yep.
15:38:17 <EvanR-work> the next best thing is to make a graph of how many SOBs visit with broken browsers
15:38:23 <ksf> and treat IE6 the same as lynx.
15:38:27 <blackh> ClaudiusMaximus: Your test program is executing on my machine and outputting numbers. How long does it take to crash?
15:39:02 <EvanR-work> ksf: we service a lot of companies with embedded, legacy, impossible to upgrade windows systems with ie6
15:39:08 * hackagebot pureMD5 2.1.0.2 - A Haskell-only implementation of the MD5 digest (hash) algorithm.  http://hackage.haskell.org/package/pureMD5-2.1.0.2 (ThomasDuBuisson)
15:39:12 <ClaudiusMaximus> hm, not too long - about 30 seconds maximum (but it has finite runtime)
15:39:23 <EvanR-work> this one survey had stats... 900 IE6, 3 IE7, 1IE8, and 1 blackberry
15:39:26 <wlangstroth> EvanR-work: is that was you're trying to detect? Browsers below a certain version?
15:39:45 <EvanR-work> so looks like ie6 support cant be dropped
15:39:50 <EvanR-work> and pushing the envelope is stupid
15:40:14 <blackh> ClaudiusMaximus: It's still running for me - what's the difference between our environments, then?
15:40:55 <ClaudiusMaximus> hm, maybe it's that i use the nvidia proprietary graphics driver..
15:41:00 <EvanR-work> wlangstroth: definitely need the version of IE, and versions of other stuff might be nice
15:41:08 <ClaudiusMaximus> blackh: i really don't know
15:41:36 <blackh> ClaudiusMaximus: I'm using that too!  I've got Ubuntu 10.04.1 LTS, The Glorious Glasgow Haskell Compilation System, version 6.12.3, and Linux amentet 2.6.31-14-generic (which I patched)
15:41:46 <wlangstroth> EvanR-work: how comfortable are you with regexes?
15:41:53 <jmcarthur> EvanR-work: IE has a (supported!) way to tell the IE version via HTML if that's good enough
15:41:59 <blackh> ClaudiusMaximus: Do you want a login on my machine?
15:42:04 <jmcarthur> but you can't use that server side
15:42:09 <jmcarthur> it's just conditional rendering, basically
15:42:13 <EvanR-work> wlangstroth: in haskell, not very
15:42:39 <EvanR-work> im not discussing changing the behavior of the website with or without detecting the browser
15:42:44 <EvanR-work> just generating visitor stats
15:42:50 <EvanR-work> for off line purposes
15:42:53 <jmcarthur> ah
15:43:09 <blackh> ClaudiusMaximus: I suppose you could try reinstalling all your hackage packages.
15:43:20 <ClaudiusMaximus> blackh: i have Linux zebimus 2.6.32-25-generic #45-Ubuntu SMP Sat Oct 16 19:52:42 UTC 2010 x86_64 GNU/Linux
15:43:31 <EvanR-work> user agent string seemed one way...
15:43:58 <ClaudiusMaximus> blackh: yeah, i've got another user on my system with its own hackage packages, so i can test with that to see if it's a machine or a cabal issue
15:44:07 <ClaudiusMaximus> blackh: thanks for the idea
15:44:43 <wlangstroth> EvanR-work: so you're parsing log files?
15:45:32 <ClaudiusMaximus> blackh: if it's relevant, i have some lines in dmesg with things like "general protection ... error 0"
15:45:42 <mklappstuhl> hey.. does anybody of you use gitit?
15:46:05 <ChudyMichef> hi I have a really, really stupid question and need help...
15:46:14 <mklappstuhl> i wonder wether it can create a wiki based on the structures of my files..
15:46:46 <wlangstroth> ChudyMichef: there are no stupid questions, only stupid people
15:46:47 <jmcarthur> ChudyMichef: just ask
15:46:54 <blackh> ClaudiusMaximus: I'm guessing that's the symptom of the crash, not the cause
15:46:57 <wlangstroth> wait ...
15:47:23 <EvanR-work> wlangstroth: would be nice.... select guessBrowser(uaString), count(*) from events group_by browser;)
15:47:25 <wlangstroth> ... no stupid people? At any rate, what's the question?
15:47:35 <blackh> wlangstroth: guns don't kill people - cops kill people
15:47:44 <jmcarthur> oof
15:47:58 <Pseudonym> Guns don't kill people.  Bullets do.
15:48:13 <EvanR-work> bullets dont kill people bleeding does
15:48:16 <jmcarthur> actually that would be blood loss, infection, decapitation, etc.
15:48:30 <EvanR-work> not being born kills people
15:48:38 <ChudyMichef> wlangstroth & jmcarthur: THanks. Problem is this: I've just installed the haskell platform and downloaded cabal.exe as well (using windows xp). but how do i get cabal.exe to do anything? when I open it, a terminal window appears for about half a second then vanishes
15:48:39 <blackh> ChudyMichef: Quick! Ask your question!!
15:48:41 <ksf> mklappstuhl, find . -name \* -exec mv {} {}.page \;
15:48:45 <jmcarthur> ... perhaps arguably, EvanR-work :)
15:48:46 <ksf> ...or something like that.
15:48:46 <EvanR-work> going home
15:48:49 <EvanR-work> offline!
15:48:56 <ksf> ...provided your files are in a format that gitit understands.
15:48:58 <Pseudonym> I guess brain asphyxia kills people.
15:49:05 <c_wraith> ChudyMichef, run cmd.exe, and run cabal from there.
15:49:09 <jmcarthur> ChudyMichef: you are supposed to use it in your shell and pass arguments to it
15:49:14 <jmcarthur> ChudyMichef: it isn't a gui
15:50:04 <wlangstroth> EvanR-work: I'll see if there isn't a simpler way
15:50:14 <ChudyMichef> use it from the haskell shell?
15:50:25 <jmcarthur> ChudyMichef: no, from cmd.exe
15:50:37 <ksf> open the start menu, find "command prompt"
15:51:38 <ksf> type cd , then drag+drop the directory cabal.exe is in into the window (its path will be inserted), hit enter.
15:51:43 <ChudyMichef> jmcarthur & ksf: thanks, gimme a second I'm just trying that (non-programmer, as you'll have guesed)
15:51:44 <ClaudiusMaximus> blackh: stranger and stranger:  "./MuChild" doesn't crash, but "./MuChild > out.txt" crashes
15:51:55 <ksf> then you should be able to do "cabal update", and then "cabal install <whatever>"
15:52:28 <blackh> ClaudiusMaximus: I am guessing that would be related to the timing of gc's
15:52:41 <ClaudiusMaximus> blackh: could be
15:52:45 <ksf> in the end, I recommend installing cygwin and reading a good shell tutorial. windows isn't particularily famous for it's command-line interface.
15:53:16 <ksf> a decent amount of unix shell knowlege has never hurt anyone.
15:53:42 <ksf> its.
15:53:44 <ksf> not it's.
15:53:55 <ksf> but then, this is irc, not reddit, I'm allowed to make mistakes.
15:54:03 <wlangstroth> I tried to use a windows computer at the library, and there was no ssh.
15:54:10 <roconnor> wlangstroth: putty
15:54:15 <ksf> or cygwin.
15:54:34 <ksf> cygwin+bbwin solves all your windows problems, except fork.
15:54:35 <jmcarthur> whenever i sit down at a windows machine the first thing i do is install putty so i can ssh to my linux box
15:55:01 <ksf> someone should port xmonad to windows.
15:55:19 <wlangstroth> jmcarthur: this must be the missing step to a usable computer
15:56:03 <wlangstroth> roconnor: there's hope after all
15:56:07 <mklappstuhl> ksf: that would create files based on my directorynames? 
15:56:39 <ksf> it would add a ".page" extension to all files in the current directory, recursively.
15:57:16 <ksf> which is, iirc, the extension gitit looks for when deciding whether or not something is a wiki page.
15:57:33 <ksf> if in doubt, just create a gitit and a page and have a look at what it does.
15:57:41 <ksf> if it doesn't do what you want, use the source.
15:58:14 <ddarius> While I haven't used it, though that will probably change, PowerShell sounds pretty interesting.
15:58:28 <ddarius> Though it's probably a too little, too late kind of thing.
15:58:46 <ksf> I seriously doubt it's going to beat zsh
15:58:54 <hpc> powershell is windows?
15:59:08 <wlangstroth> mklappstuhl: in gitit you can set up directories, if I remember right - hold on
15:59:25 <ddarius> ksf: I don't think it's even trying to solve the same problem as zsh.
15:59:25 <mklappstuhl> ksf: i have files with .page suffix in subdirs... these are not accessable through gitits web interface
15:59:36 <mklappstuhl> zsh rules! :D
16:00:13 * hackagebot linux-ptrace 0.1 - Wrapping of Linux' ptrace(2).  http://hackage.haskell.org/package/linux-ptrace-0.1 (RichardSmith)
16:00:15 * hackagebot posix-waitpid 0.1 - Low-level wrapping of POSIX waitpid(2).  http://hackage.haskell.org/package/posix-waitpid-0.1 (RichardSmith)
16:00:25 <Entroacceptor> mklappstuhl: help me writing my cms :)
16:00:28 <mklappstuhl> i discovered 'prompt' today after using oh-my-zsh for a long time
16:00:38 <mklappstuhl> Entroacceptor: ?! :P
16:00:57 <ChudyMichef> hi again. still not working... I'm in the right directory but typing 'cabal.exe' results in 'no command given (try --help)'... what am I doing wrong now??
16:00:59 <Entroacceptor> I'm writing a web cms based on files in directories, and probably in git repos
16:01:08 <ClaudiusMaximus> blackh: ah, seems similar to a known issue in hmatrix
16:01:12 <ksf> ChudyMichef, well, try cabal --help
16:01:35 <ksf> (no need to type ".exe")
16:01:46 <ChudyMichef> ksf: aha! now I get it...
16:01:55 <blackh> ClaudiusMaximus: I ran the one you pasted with > out.txt and it ran to completion without crashing.
16:02:12 <wlangstroth> mklappstuhl: you mean you put files into a directory ... (sorry, describe what you did, etc)
16:02:47 * ksf suddenly realises that he is _old_.
16:02:59 <ksf> there's actually people who didn't grow up with a cli.
16:02:59 <ClaudiusMaximus> blackh: very strange
16:03:16 <ClaudiusMaximus> READY_
16:03:35 <ksf> ...even though it was DOS, my first experiences with a computer involed grey on black text.
16:03:42 <ksf> (or norton commander)
16:03:45 <blackh> ksf: You're such a tough guy
16:03:56 <wlangstroth> ksf: and not green?
16:04:01 <Entroacceptor> ksf: I hear you, brother...
16:04:14 <wlangstroth> ksf: or yellow-on-black?
16:04:15 <ddarius> My first experience would be grey on blue text.
16:04:20 <ksf> nono, it was a 386, and it had vga graphics.
16:04:24 <ddarius> I think that's what our Commodore 64 rendered.
16:04:28 <wlangstroth> ksf: feel young again
16:04:29 <blackh> ksf: Here's something you would like: http://sensi.org/~svo/glasstty/
16:04:35 <ddarius> ksf: 386? Psh, your not old.
16:04:55 <ksf> well, it was our first computer, but yes, I was 8 then or so.
16:05:05 <ksf> I did see slower ones in my youth.
16:05:18 <wlangstroth> ksf: pff - what, when you were 3?
16:06:49 <mklappstuhl> wlangstroth: yes, i have 2 dirs inside wikidata and inside these dirs are files with .page suffix
16:07:06 <mklappstuhl> and i want gitit to represent this structure
16:07:11 <ddarius> Norton Commander was awesome.
16:07:28 <ksf> anyway, my point is that I was socialised before win95 came around.
16:07:36 <Entroacceptor> mklappstuhl: gitit reads the git repository directly
16:07:39 <ksf> I actually witnessed the birth of the internet.
16:07:39 * ddarius remembers Chicago.
16:07:46 <wlangstroth> mklappstuhl: are they in the git repository?
16:07:48 <Entroacceptor> so if you commit them, it should work
16:07:53 * ddarius remembers bulletin boards.
16:07:54 <ksf> ...at least the one that featured animated under-construction gifs.
16:08:13 * ksf remembers playing quake1 via modem.
16:08:18 <wlangstroth> ddarius: the band?
16:08:25 <ksf> ...direct connection, that is, not via internet.
16:08:36 <ksf> and transport tycoon via parallel port.
16:08:43 <ddarius> wlangstroth: Chicago was the code name for the Windows 95 beta.
16:08:47 <wlangstroth> castle wolfenstein
16:09:02 <mklappstuhl> wlangstroth: wait a sec
16:09:09 <ksf> there's still people playing transport tycoon
16:09:23 <ksf> ...openttd, massively epic cooperative games.
16:09:23 <ddarius> ksf: What do you expect, parallel ports are slow.
16:09:27 <ksf> it's astonishing.
16:10:15 <wlangstroth> 5 1/4 floppies
16:10:34 <ksf> http://wiki.openttdcoop.org/images/2/2e/Psg81.png
16:11:15 <ksf> I still have a 5 1/4 drive
16:11:17 <hpc> OMG roller coaster tycoon
16:11:21 <ksf> two, actually.
16:11:36 <ksf> rct is quite young compared to tt
16:11:45 <ksf> about the same time as alpha centauri.
16:11:54 <hpc> rct is wacky fun
16:11:57 <hpc> but too easy to beat
16:12:02 <ChudyMichef> ksf: thanks - I think it worked. Or rather, I think cabal.exe worked. Running it I just got a load of error messages ('The exception was... which failed to instal / Exit failure') but I guess that's a problem with what I was trying to instal not with cabal.
16:12:07 <alex404> So I'm trying to write a relatively effecient function which generates all vectors of a certain length with elements 0 or 1. Can anyone have a look at my code and tell me i) Why it won't compile ii) Whether the idea is efficient anyway? Look at allVectors at the bottom of the file. http://codepad.org/S1YCQsJ0
16:12:13 <ksf> ChudyMichef, yep.
16:12:15 <hpc> i had one park with a fries stand built inside a loop
16:12:54 <wlangstroth> ksf: why would you have a 5 1/4 drive?
16:13:02 <ksf> windows is a bit undersupported as there's just not enough volunteers to care about it.
16:13:11 <ddarius> Why -wouldn't- you have a 5 1/4 drive?
16:13:25 <Twey> Heheh
16:13:40 <wlangstroth> ddarius: for the same reason I have a bicycle instead of a horse
16:13:55 <Twey> ksf: I read that as applying to Windows in general, in the same spirit as ‘Linux is undersupported because nobody is paid to work on it’
16:13:59 <Twey> It made me chuckle
16:14:20 <ksf> because I still have the case of said 386 which now hosts a k5 133 w/ 128 megs of ram and 40m harddisk (don't laugh), and I'm missing a cover.
16:14:34 <Twey> wlangstroth: Horses are way cooler than bicycles.  They keep you warm, they do their own self-maintenance, they keep you company, and you can eat them when they die.
16:14:50 <aristid> wlangstroth: i think you SHOULD have a horse. eccentric people need horses.
16:14:52 <ChudyMichef> ksf: Right, I'll contact the guy that wrote the thing I'm trying to instal. Thanks again.
16:15:00 <ddarius> Twey: And if you get another horse, they'll make more horses.
16:15:09 <Twey> Right!  Free production!
16:15:28 <ChudyMichef> quit
16:15:30 <blackh> alex404: Paste the compiler error on there. We're lazy.
16:15:43 <Entroacceptor> but I can put my bike into the cellar and forget about it for four months
16:15:45 <jmcarthur> horses are a lot more work than bikes
16:15:52 <jmcarthur> a *lot* more work
16:15:52 <ksf> I _do_, however, have a 3.5 drive in my current workstation
16:15:55 * jmcarthur speaks from experience
16:16:09 <ksf> alongside with a cd burner and dvd drive, all three not being connected to anything.
16:16:17 <alex404> blackh: http://codepad.org/eXk4FeoM
16:16:25 <ksf> the internet really changed things.
16:16:40 <alex404> ksf: That's an understatement.
16:16:48 <wlangstroth> jmcarthur: you poor thing - did you escape?
16:16:50 <ddarius> It's just a fad.  It'll pass.
16:16:52 <ksf> well, usb sticks did, too.
16:17:11 <mklappstuhl> wlangstroth: Entroacceptor – maybe that helps you to understand what I'm talking of ... 
16:17:14 <mklappstuhl> http://github.com/jgm/gitit/issues/#issue/15
16:17:16 <ksf> on a more exotic note, I own a 100mb zip drive with plenty of disks.
16:17:29 <hpc> haha, zip drives
16:17:33 <ksf> ...which was my internet connection for quite a long time.
16:17:48 <ksf> hey you can even boot off them.
16:17:48 <hpc> i have seen so many computers broken by someone shoving a floppy in one of those
16:17:53 <hpc> ah, elementary school
16:18:03 <ddarius> ksf: You can boot off of pretty much anything nowadays.
16:18:15 <ksf> well, said k5 133 can do it.
16:18:44 <wlangstroth> mklappstuhl: don't add the .page at the end
16:19:10 <ksf> and then there's bits and pieces... I once planned to build a back-to-basics 486 to play dos games on, but then dosbox came along.
16:19:44 <ksf> 32-bit vlb harddisk controller + video card...
16:19:49 <ksf> oh, and I still got a monster3d.
16:19:51 <mklappstuhl> wlangstroth: no difference unfortunately
16:20:12 <wlangstroth> mklappstuhl: yeah, the "not a repository" error is strange
16:20:21 <ksf> those things are just too precious to throw away.
16:20:32 <wlangstroth> mklappstuhl: wait, did you put them in data/wikidata?
16:20:38 <mklappstuhl> something different... what do you think of OPAL? (if you know ot)
16:20:49 <ddarius> ksf: You should shoot them like skeet.
16:20:58 <wlangstroth> totally forgot about gitit's unfortunate folders
16:21:20 <ksf> @slap ddarius
16:21:20 * lambdabot karate-chops ddarius into two equally sized halves
16:21:43 <ClaudiusMaximus> blackh: i sent a bug report to the hmatrix maintainer; hopefully it will turn out to be something silly at my end rather than anything seriously wrong elsewhere
16:21:57 <mklappstuhl> wlangstroth: I don't have data above wikidata but they are there right
16:22:00 <hpc> lambdabot chops and chops, and somehow ends up with two ddariuses
16:22:02 <mklappstuhl> ah damn
16:22:05 <ddarius> ksf: I remember getting a Matrox Mystique when VLB was the new in-thing.
16:22:07 <mklappstuhl> something pops to my mind... 
16:22:23 <mklappstuhl> all the files are symlinks
16:22:25 <sproingie> matrox mystique had damn nice 2D color quality back then
16:22:30 <mklappstuhl> that could cause the git problem
16:23:06 <blackh> alex404: Umm.. I'm not familiar enough with V.modify, but that code won't work, becaue V.modify isn't returning anything
16:24:42 <blackh> Or rather, line 44 "when x $ ..." can't possibly do anything, because the code is pure.
16:24:59 <wlangstroth> mklappstuhl: it's still weird that you wouldn't get a response to git status
16:25:53 <alex404> blackh: Modify takes an immutable vector, makes it mutable, does something to it, and then turns it back
16:26:19 <blackh> alex404: I get it.  Well, that line isn't returning the modified vector.
16:27:14 <alex404> blackh: But why doesn't the fact that I return 'the original vector', do the trick. I can understand that the code wouldn't work, but not why it would return ()
16:27:28 <alex404> blackh: (i.e. where I have foo vec 0 = vec)
16:27:32 <blackh> alex404: I can't figure that out either
16:27:51 <mklappstuhl> sry got disconnected
16:28:29 <wlangstroth> mklappstuhl: is there no .git folder under wikidata?
16:29:33 <blackh> alex404: line 41 should say "= return vec" (assuming this is a list monad)
16:31:02 <alex404> blackh: Right... I figured that much out. Now the function tries to return a [()]... however, when I comment out the 'when ...' it compiles fine...
16:31:06 <blackh> alex404: I figured out the reason. V.modify is the wrong type.
16:31:47 <blackh> alex404: Add 'return' to it.
16:32:24 <wlangstroth> mklappstuhl: if I remember right (and I could be thinking of another version control system), git doesn't add a directory until you put something in it
16:32:28 <mklappstuhl> wlangstroth: there is a git folder now
16:32:36 <mklappstuhl> there always was one - sry
16:32:36 <blackh> It wants to be something like ... vec' <- if x then return $ V.modify .. else []
16:32:49 <mklappstuhl> wlangstroth: thats correct..
16:32:57 <blackh> vectorLoop vec' (n-1)
16:33:13 <blackh> Still, I have no idea what it's supposed do. :)
16:33:25 <mklappstuhl> wlangstroth: i copied the files to wikidata instead of symlinking now.. that works. however it's not the way i want it
16:33:27 <blackh> Oh, I see... you want
16:33:47 <mklappstuhl> and syncing over a remote repository seems like overhead
16:33:55 <blackh> alex404: let vec' = if x then V.modify .. else vec
16:34:02 <blackh> vectorLoop vec' (n-1)
16:34:39 <wlangstroth> mklappstuhl: oh, I see what you were trying to do - symlinks ... I guess that's not possible
16:34:41 <alex404> blackh: Riiggghttt...
16:34:54 <wlangstroth> mklappstuhl: have you tried rsync?
16:34:57 <alex404> blackh: Wait...
16:35:37 <wlangstroth> mklappstuhl: you mean you're syncing two gitits?
16:36:28 <mklappstuhl> wlangstroth: no, just mirroring my the git repo i have somewhere else on my computer to wikidata/
16:36:44 <mklappstuhl> i dont like to have this 'wrapper'
16:37:24 <wlangstroth> mklappstuhl: and you don't want to edit the files with gitit?
16:37:43 <mklappstuhl> wlangstroth: i dont want - yes
16:38:41 <blackh> alex404: You know, you could do this without explicit recursion (using foldl' with >>=).  Though I don't know how useful this suggestion is. :)
16:38:50 <dobblego> has anyone tried parsing XML with parsec/monadic parser?
16:39:08 <ddarius> I'm sure someone has.
16:39:08 <alex404> blackh: Yah, I'm going to transform it into that form when I figure it out this way (I had an accumulator in a previous form)
16:39:12 <wlangstroth> dobblego: easier with hexpat
16:39:27 <alex404> blackh: Anyway, your suggestion isn't flying either... I'm looking it over...
16:39:55 <wlangstroth> mklappstuhl: not sure what to tell you - a shell script that runs rsync might do it
16:39:58 <dobblego> wlangstroth, easier again with HXT, but I'm wondering specifically about a monadic parser
16:40:17 <ddarius> dobblego: Monadic parsers aren't very well suited to many use-cases people desire when dealing with XML though.
16:40:30 <mklappstuhl> wlangstroth: yes the problem which brought me here is solved – thanks 
16:40:32 <dobblego> ddarius, that's what I was guessing
16:40:42 <ddarius> But for a DOM-like model, Parsec or others would work fine.
16:40:43 <blackh> dobblego: I am attempting to develop an iteratee-based XML parser, in case that is of any help.
16:40:58 <dobblego> blackh, it will be one day, for sure :)
16:41:01 <mklappstuhl> wlangstroth: rsync sounds like a good idea that way i dont need a remote to push/pull from
16:41:30 <mklappstuhl> i'll go to bed now... have to get up at 7 – its 2am here :D
16:41:30 <dobblego> ddarius, yes, I was thinking if memory consumption of the document is not an issue, then parsec may work
16:41:35 <blackh> dobblego: There's a working prototype of it in the hexpat-iteratee package.
16:41:37 <mklappstuhl> thx again to all
16:41:43 <wlangstroth> mklappstuhl: oh good - hope that helped
16:42:07 <alex404> blackdog: Aha! Success. I had a stupid typo. Your suggestion when right. Now the resultant vectors are not what I imagined, but at least it compiles ;) Thanks for the help.
16:42:29 <alex404> blackh: Aha! Success. I had a stupid typo. Your suggestion when right. Now the resultant vectors are not what I imagined, but at least it compiles ;) Thanks for the help.
16:43:02 <blackh> alex404: No worries.  blackdog is my lexical neighbour, so we know each other well. :)
16:43:44 <alex404> blackh: Cheers!
16:45:14 * Philippa would probably avoid using monadic parsers for XML because they minimise what you can twist the parser into doing for you cheaply, FWIW
16:45:32 * hackagebot snap-core 0.2.15 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.15 (GregoryCollins)
16:47:33 * hackagebot snap-server 0.2.15 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.15 (GregoryCollins)
16:52:37 <youngbull> Hey, I'm working on Yi, and I am getting some weird messages, It's caused by Language.Haskell.Interpreter, and it's that when I write a string for it, it comes out as a Rope (and It's somehow different from Data.Rope)
16:53:14 <youngbull> Ie. I want "hello World" to be a string, but the interpreter says it's a Rope
16:55:02 <mm_freak_> "rope" lol
16:55:38 <dankna> so.  I want my records to all have unique IDs, for use in equality tests.  but I want to not need IO when constructing them.  any suggestions? :(
16:55:56 <youngbull> mm_freak_ : Yea, I guess "Rope" would be a Rope ...
16:56:24 <pumpkin> dankna: can you give more details?
16:56:24 <mm_freak_> youngbull: no idea about your problem, sorry…  i just found "rope" vs. "string" funny
16:56:30 <pumpkin> @hackage rope
16:56:31 <lambdabot> http://hackage.haskell.org/package/rope
16:56:41 <pumpkin> ropes are datastructures!
16:56:55 <dankna> pumpkin: sure.  well.  I'm not sure what type of detail to give, but I'll try.
16:57:03 <mm_freak_> dankna: you can create IDs in IO and use them in pure code
16:57:27 <dankna> mm_freak: yeah, but then I still need to thread them in everywhere as parameters, that's barely better than threading IO around
16:57:31 <pumpkin> dankna: why do they need unique IDs? there are pure ways of generating unique IDs if you need to do it in different parts of the code
16:57:40 <pumpkin> if a single places generates them, you can just have an infinite stream of unique ids
16:57:43 <dankna> well, I should mention that I'm already looking at Data.Supply
16:57:53 <dankna> they need unique IDs so that I can, for example, print a recursive data structure
16:57:59 <dankna> and detect the recursion
16:58:26 <mm_freak_> dankna: as kind of a hack you can write an infinite lazy list of IDs using unsafeInterleaveIO
16:58:29 <pumpkin> couldn't you just use vacuum?
16:58:46 <dankna> what I'm doing now is the backend part of the program, which just provides facilities for creating and working with these structures; they will be generated from various client front-end parts
16:58:53 <dankna> possibly; looking into vacuum now
16:59:01 <dankna> mm_freak: hmm...
16:59:04 <mm_freak_> dankna: if your IDs need to be unique per collection only, then you can just use State or something
16:59:11 <mm_freak_> i.e. not Data.Unique at all
16:59:37 <dankna> I'd prefer them globally unique (that is, unique within the Haskell process) because it just feels cleaner
16:59:48 <mm_freak_> Data.Unique is really only for globally unique identifiers
16:59:49 <pumpkin> how is [0..] bad? :P
16:59:56 <dankna> but yeah hmm
17:00:00 <pumpkin> oh you're generating them in different places
17:00:05 <dankna> yeah
17:00:25 <mm_freak_> dankna: i find Data.Unique a dirty solution, which i try to avoid where possible
17:00:34 <mm_freak_> note that you can always interpolate collections
17:00:40 <dankna> mm, I sympathize, but at least it's dirt someone else is maintaining for me :)
17:00:46 <ddarius> pumpkin: Still in Florida?
17:01:05 <dankna> and at least it's not reinventing the wheel.  so if I'm going to use a solution along those lines I'm going to use the existing library for it, obviously.
17:01:13 <pumpkin> ddarius: yeah, will probably not make it to boston in time to give the talk this time around :/ I already emailed ed about it
17:01:18 <dankna> interpolate collections - I don't follow
17:01:18 <youngbull> Damn, why is my Strings getting automatically turned into Ropes???
17:01:27 <adnap> What's the best way to "carry some values" along with you as you run through a list?
17:01:32 <dankna> adnap: fold
17:01:34 <pumpkin> adnap: a fold?
17:01:38 * hackagebot weighted-regexp 0.3.0.1 - Weighted Regular Expression Matcher  http://hackage.haskell.org/package/weighted-regexp-0.3.0.1 (SebastianFischer)
17:01:56 <adnap> Are there extentions of fold that let you carry more values, or do you tyically use a tuple?
17:01:59 <mm_freak_> dankna: if you happen to have to union two collections you can easily write an algorithm, which ensures that IDs remain unique
17:02:06 <dankna> oh, true
17:02:10 <pumpkin> adnap: or a custom type as your state
17:02:45 <adnap> The annoying thing is that fold returns a single value, so if you're still planning on keeping a list, you have to rebuild a new one.
17:03:00 <dankna> you typically use a tuple or a custom type, as pumpkin noted
17:03:15 <adnap> What I really want is "map with a few variables".
17:03:16 <pumpkin> adnap: there are more complex recursion schemes
17:03:32 <pumpkin> but a few variables sounds like a fold
17:03:33 <adnap> Okay, here's a scenario:
17:03:44 <mm_freak_> adnap: that's not annoying, it's the way you encode list-manipulation algorithms
17:03:54 <hpc> adnap: you can still fold into a list
17:04:03 <mm_freak_> adnap: building a new list in source code doesn't mean that a new list is actually built in memory
17:04:04 <adnap> hpc: I know, but you have to build it up.
17:04:06 <dankna> well, I guess I'll do mm_freak's suggestion
17:04:14 <mm_freak_> adnap: garbage collection takes care of that
17:04:17 <hpc> adnap: you have to do that anyway when you map
17:04:20 <adnap> I
17:04:30 <adnap> I'm not concerned about performance.
17:04:36 <adnap> I just think it's...
17:04:54 <alpounet> pumpkin, a talk about what ?
17:04:56 <hpc> there's no variadic analog to map, if that's really what you want
17:05:01 <adnap> yes
17:05:05 <mm_freak_> adnap: btw, often when you need to carry a value through a fold, you can just split your operation into two separate ones
17:05:07 <pumpkin> alpounet: was going to be about agda, and with any luck will still be next time around
17:05:13 <pumpkin> alpounet: unless someone else jumps in and gives the talk for me :)
17:05:21 <mm_freak_> adnap: like:  zip first, then fold
17:05:24 <alpounet> heh
17:05:33 <alpounet> you're probably quite experienced with agda now yeah
17:05:48 <mm_freak_> adnap: and you might also be interested in mapAccumL and mapAccumR
17:05:53 <pumpkin> it was going to be nice, cause ddarius is giving a related talk
17:05:54 <mm_freak_> :t mapAccumL
17:05:55 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
17:06:00 <pumpkin> but I almost definitely can't make it up in time
17:06:11 <adnap> Take the list ["dog", "pig", "cat"] and have two numbers, 34, and 59.  Append these two numbers to the end of each string and then increment the first and decrement the second.
17:06:48 <alpounet> pumpkin, as long as you're having a good time, man, it's okay :]
17:06:54 <adnap> So you want ["dog 34 69", "pig 35 68", "cat 36 67"].
17:07:05 <pumpkin> oh I'm having a great time, but I like going to those things too
17:07:27 <adnap> So, the best way to do this is a fold?
17:07:39 <adnap> Where I have a tuple of the integers, and the partially built list?
17:07:51 <mm_freak_> > zipWith3 (\x y z -> unwords [x,y,z]) ["dog", "pig", "cat"] [34..] [69,69..]
17:07:52 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
17:07:52 <lambdabot>    arising from the literal `...
17:07:52 <adnap> I think that's kind of gross.
17:07:52 <c_wraith> that's the way that seems obvious to me
17:08:07 <mm_freak_> > zipWith3 (\x y z -> unwords [x, show y, show z]) ["dog", "pig", "cat"] [34..] [69,69..]
17:08:07 <lambdabot>   ["dog 34 69","pig 35 69","cat 36 69"]
17:08:24 <pumpkin> adnap: if you give us more details, we might be able to suggest other ways to do it that are more idiomatic
17:08:26 <c_wraith> your typo prevented decrementing :)
17:08:37 <mm_freak_> lol
17:08:39 <mm_freak_> > zipWith3 (\x y z -> unwords [x, show y, show z]) ["dog", "pig", "cat"] [34..] [69,68..]
17:08:40 <lambdabot>   ["dog 34 69","pig 35 68","cat 36 67"]
17:08:49 <mm_freak_> there you go
17:08:54 <mm_freak_> no fold at all =)
17:09:07 <c_wraith> infinite lists to the rescue!
17:09:58 <adnap> Oh, a zipWith is probably what I need in this special case.
17:10:54 <mm_freak_> adnap: that's what i meant…  often when you think you need an accumulation variable in your fold, what you really need is a different operation
17:11:41 <pumpkin> or maybe your foldy thing is an associative operation
17:11:49 <pumpkin> in which case you have a semigroup or even a monoid!
17:11:55 <pumpkin> and can do it in parallel!
17:12:01 <pumpkin> (zomg)
17:12:10 <pumpkin> zomg: do you mind me calling you all the time?
17:12:47 <mm_freak_> what does the 'z' in "zomg" stand for anyway?
17:12:49 <adnap> Actually, I don't know if that will work...
17:12:57 <Rotaerk> mm_freak_, nothing
17:13:02 <Rotaerk> the z is silent
17:13:02 <adnap> 'Cause the numbers in my algorithm are dependent on the contents of the list.
17:13:08 <enthropy> > foldr (\animal (list,(a,b)) -> ((animal ++ show a ++ show b):list,(a+1,b-1))) ([],(34,69)) ["dog", "pig", "cat"]
17:13:09 <lambdabot>   (["dog3667","pig3568","cat3469"],(37,66))
17:13:10 <mm_freak_> omega-omg
17:13:42 <adnap> enthropy: That's what I was afriad of having to do.
17:13:50 <adnap> That is so gross.
17:14:02 <enthropy> put the arguments to foldr on separate lines
17:14:02 <mm_freak_> adnap: in that case it may prove useful not to use fold*, but write a recursive function instead
17:14:32 <adnap> mm_freak_: Yeah, I think you're right.
17:16:17 <mm_freak_> folds with accumulation variables tend to get long and unreadable
17:18:03 <adnap> I just thought there was some kind of more abstract thing that crazy people use.
17:18:16 <adnap> There are a lot of those in Haskell.
17:18:40 <ddarius> Paramorphisms, histomorphisms, zygomorphisms.
17:18:44 <adnap> That's part of why Haskell is so fun to me, because I still haven't run out of things to learn.
17:19:35 <alpounet> @quote lax.functor
17:19:35 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
17:19:40 <mm_freak_> i think that doesn't happen with haskell at all…  even after years of experience i still learn new things all the time
17:20:31 <adnap> lol
17:21:31 <adnap> lax functor from a terminal bicategory?
17:22:29 <mm_freak_> not to be or to be and (not to be or to be and (not to be or to be and (not to be or to be and …))), that's the list monad
17:22:34 <adnap> Do a lot of the concepts in Haskell come from Category Theory?
17:22:38 <ddarius> Yep.  And that suggests that a "parameterized" monad might be able to be viewed as simply a lax functor from a somewhat more interesting bicategory.
17:22:51 <mm_freak_> or: fix (not to be or to be and), that's the list monad
17:23:25 <ddarius> As an exercise, try to show whether the notion of category object in the category of endofunctors is essentially the same (or not) to a lax functor or some subclass of lax functors.
17:23:33 <Veinor> adnap: some of them
17:23:34 <adnap> My school doesn't offer a course in Category Theory.  I asked a professor and he said that Category Theory is sort of something you pick up "along the way" in various other math classes, but it's rarely taught as its own class.
17:23:35 <ddarius> adnap: Not really.
17:23:57 <ddarius> adnap: Not that I have a lot of experience there, but that is my impression as well.
17:24:41 <mm_freak_> luckily you don't /need/ to understand CT to be a good haskell programmer
17:24:43 <pumpkin> adnap: my school only offered it as a week or two of a graduate algebra course (which was admittedly only 10 weeks long)
17:25:01 <hpc> @hoogle splitAt
17:25:01 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
17:25:01 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
17:25:01 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
17:25:13 <ddarius> Category theory does give a very elegant perspective to many abstract algebra concepts.
17:25:53 <Veinor> yeah, I don't know category theory and I use haskell :D
17:26:06 <adnap> Can you give a full function definition with pattern matching inside of another function?
17:26:14 <pumpkin> adnap: example?
17:26:17 <ddarius> adnap: Of course.
17:26:21 <mm_freak_> adnap: 'where', 'let'
17:26:29 <dobblego> adnap, case/of perhaps
17:26:29 <adnap> Okay
17:26:33 <adnap> I've never done that before.
17:26:40 <mm_freak_> > let f True = 2; f False = 3 in f True
17:26:41 <lambdabot>   2
17:26:44 <adnap> I will show my function when I'm done with it.
17:27:03 <mm_freak_> > let 2 + 2 = 5 in 2 + 2
17:27:04 <lambdabot>   5
17:27:11 <adnap> Maybe I can get a critique
17:27:58 <adnap> Wait--another question:
17:28:32 <dobblego> > let f x = case x of True -> 2; False -> 3 in f True
17:28:33 <lambdabot>   2
17:28:42 <adnap> If you have a function with another function defined in like a let or a where along with some other values, are those values in scope within the inner function?
17:28:50 <ddarius> adnap: Of course.
17:28:56 <adnap> Cool
17:29:28 <Axman6> adnap: use where
17:29:29 <mm_freak_> > let f x = let g y = x + y in g 5 in f 4
17:29:30 <lambdabot>   9
17:29:51 <mm_freak_> but i mostly prefer 'where' over 'let'
17:30:01 <dobblego> I'm the opposite
17:30:11 <mm_freak_> > let f x = g 5 where g y = x + y in f 4
17:30:12 <lambdabot>   9
17:30:12 <Axman6> > let f x y = g x + g y where g x = x^45 in f 3 5
17:30:13 <lambdabot>   28421709433358320141395804401768
17:30:40 <Axman6> > let f x y = g x + g y where g x = x^45 *y in f 3 5
17:30:41 <lambdabot>   142108547166791600706979022008840
17:30:42 <mm_freak_> anyway, 'x' is in scope for 'g', which is probably what adnap asked for
17:31:27 <adnap> Why would I always use where?
17:31:34 <adnap> I use both depending on the situation.
17:32:11 <adnap> Sometimes I think it's more clear to introduce values first and vice versa.
17:34:41 <orlandu63> hello, i'm having problems installing template-haskell through cabal: http://parcs.ath.cx:99/~patrick/base.log
17:35:58 <enthropy> orlandu63: it comes with ghc
17:36:30 <orlandu63> enthropy: yes, but a certain package requires a more recent version of it
17:36:57 <adnap> Is it your preference to define helper functions outside of the main function body, or do you sometimes define them inside?  Is it a size thing?
17:37:11 <enthropy> it's integrated with GHCs syntax, so I doubt you can upgrade it without upgrading ghc
17:37:32 <enthropy> adnap: namespace pollution and scope are factors
17:37:51 <adnap> enthropy: But you can always choose what to export
17:38:39 <orlandu63> i see. by the way, what is the status on ghc 6.12? is it considered stable?
17:38:50 <Axman6> sure
17:38:57 <enthropy> adnap: consider    (f x y z = {} where helper = {}), helper gets x y z in scope
17:39:00 <Axman6> it's about to be replaced bt 7.0
17:39:16 <taktoa> hello
17:39:32 <taktoa> let's say I have an array of RGBA tuples
17:39:32 <adnap> enthropy: Yeah, that's the main reason I'm doing what I'm doing right now, but this function is getting long and ugly.
17:39:40 <taktoa> representing a picture
17:39:48 * hackagebot linux-ptrace 0.1.1 - Wrapping of Linux' ptrace(2).  http://hackage.haskell.org/package/linux-ptrace-0.1.1 (RichardSmith)
17:39:49 <taktoa> (one-dimensional)
17:39:56 <taktoa> (with the rows concatenated)
17:40:10 <taktoa> how could I flip it along the x-axis?
17:42:17 <taktoa> anyone got any ideas?
17:42:40 <enthropy> taktoa: split it into rows, then reverse each row
17:43:07 <adnap> Yeah, do takes and reverses.
17:43:16 <enthropy> taktoa: any reason not to use pairs as your array index?
17:43:24 <Axman6> it's an array, not a list
17:43:36 <adnap> Oh
17:43:39 <adnap> I've never used those.
17:43:46 <taktoa> sorry, I meant list
17:43:55 <Axman6> oh, lists are a lot easier
17:44:13 * taktoa comes from an imperative programming background
17:44:29 <enthropy> there are arrays in Haskell
17:44:33 <taktoa> I know
17:44:42 <taktoa> but I've never used them
17:44:55 <taktoa> so when I think list, I think of an array
17:45:06 <Axman6> well, they're very different
17:45:33 <adnap> Something like flip colors = (reverse . take width) colors ++ flip (drop width colors)?
17:45:35 <enthropy> use whichever is most appropriate for your access/update pattern
17:46:15 <adnap> Or, I would probably use a split.
17:46:47 <adnap> flip colors = let (row, rest) = split width colors in reverse row ++ flip rest
17:47:01 <adnap> I don't know if I got all the function names right or whatever.
17:47:08 <adnap> Maybe it's splitAt?
17:47:14 <Axman6> don't call it flip though'
17:47:25 <Axman6> splitAt, yes
17:47:27 <enthropy> adnap: looks good
17:47:29 <adnap> Axman6: Isn't it a flip along x?
17:47:38 <adnap> Er, flip over y.
17:47:45 <Axman6> yes, but flip is a function already defined in the prelude
17:47:48 <adnap> Oh
17:47:51 <adnap> :t flip
17:47:52 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:47:59 <adnap> Oh, that flip!
17:48:05 <taktoa> it's a flip taking something from the bottom and putting it on the top
17:48:06 <enthropy> it doesn't matter though
17:48:08 <Axman6> it's (a -> b -> c) -> b -> a -> c
17:48:09 <adnap> The one that flips the order of vatiables.
17:48:13 <taktoa> so rotating along the x-axis
17:48:24 <adnap> I would call it reflectY
17:48:49 <adnap> Oh
17:49:03 <adnap> Then you need to transpose your image.
17:49:39 <dobblego> lispy, are you there?
17:50:23 <adnap> I think it would be easier to make it of [[a]] type first.
17:50:29 <dobblego> @tell lispy what exactly is the difference between json-b and JSONb?
17:50:30 <lambdabot> Consider it noted.
17:50:58 <taktoa> rotating in 3D along the x axis, that is
17:51:13 <adnap> taktoa: Are you flipping over the x axis?
17:51:17 <taktoa> yes
17:51:19 <adnap> taktoa: Why do you say rotating?
17:51:32 <adnap> taktoa: Yeah, so you need to reverse the columns, right?
17:51:37 <taktoa> if you visualize it as a 2d plane in 3d space, it's rotating
17:51:45 <taktoa> yes
17:51:47 <adnap> taktoa: Oh, I see.
17:52:03 <adnap> taktoa: But you have a 1-D list, so you're columns are like every nth element.
17:52:11 <taktoa> precisely
17:52:47 <adnap> taktoa: Maybe there's a fancier way, but I would first group the image by rows, so you have a list of lists of colors.
17:53:08 <adnap> taktoa: Then, you can transpose the list to swap rows and columns.
17:53:32 <taktoa> :t transpose
17:53:33 <lambdabot> forall a. [[a]] -> [[a]]
17:53:37 <adnap> taktoa: Thenm you can take each column, one at a time, and reverse it, building a new image as you go.
17:53:37 <taktoa> ok
17:53:45 <adnap> taktoa: Then transpose back at the end.
17:54:00 <taktoa> so transpose -> concatmap -> tranpose
17:54:00 <cozachk1> does one have to be voiced to talk in #haskell-in-depth now? 
17:54:29 <adnap> taktoa: Well, you don't want to concat before you transpose.
17:54:34 <taktoa> ok, I have to go watch mythbusters, but I might be back later
17:54:36 <adnap> taktoa: transpose takes [[a]]
17:54:41 <taktoa> I see
17:54:44 <pumpkin> cozachk: it seems not?
17:54:54 <adnap> taktoa: I'll write an example for you.
17:55:10 <taktoa> thanks
17:59:39 <dobblego> hey solidsnack are you there?
18:01:43 <stepkut> Saizan: are you maintaing syb-with-class these days? or is that wishful thinking on my part ?
18:03:47 <Saizan> stepkut: i do, is there something to be done?
18:04:31 <Saizan> stepkut: i'll have to release a new version once template-haskell-2.6 hits hackage
18:05:14 <stepkut> Saizan: ok. 2.5 is in GHC 7.. I guess it won't be long until 2.6 is on hackage ?
18:05:34 <stepkut> Saizan: also the source repo link seems to be out of date? http://hackage.haskell.org/package/syb-with-class-0.6.1
18:06:34 <stepkut> Saizan: i think you just need to drop the 'pullrepo' portion
18:07:22 <Saizan> stepkut: ah, yeah, i meant 2.5
18:07:28 <stepkut> Saizan: oh.. I guess darcs pull from that addr works, but not just clicking on it..
18:07:54 <stepkut> but I think pullrepo i still not required
18:08:20 <stepkut> Saizan: there is a thread on the happs mailing list, if you care to respond :)
18:08:23 <stepkut> or I can
18:08:26 <adnap> taktoa: http://hpaste.org/40913/flip_image
18:08:56 * hackagebot atomo 0.2 - A highly dynamic, extremely simple, very fun programming  language.  http://hackage.haskell.org/package/atomo-0.2 (AlexSuraci)
18:09:02 <Saizan> stepkut: thanks i'll fix the url, and i'll check the email :)
18:09:46 <stepkut> Saizan: thanks!
18:15:25 <retroj> hello.  i am using getCurrentTime from Data.Time.Clock to get the current date as year,month,day.  however, this is UTC time.  How can I get local time?
18:16:15 <ivanm> convert it
18:16:26 <retroj> manually?  can't i get it from the system?
18:16:42 <mikeg> did you try Data.Time.LocalTime?
18:16:54 <retroj> i did not... i'll look that up
18:18:07 <retroj> looks like that does what i want.  thank you
18:18:14 * ddarius needs to make bread...
18:20:37 <adnap> I always say "ddarius" with a stutter in my mind, like "duh-darius".
18:20:44 <ivanm> ddarius: there's these wonderful little establishments called 'bakeries' that typically contain such foodstuffs...
18:21:02 <ivanm> adnap: heh, same, but more like d-darius
18:21:30 * retroj big fan of homemade bread
18:21:36 * pumpkin too
18:22:00 <pumpkin> > ((==) `on` sort) "beard" "bread"
18:22:01 <lambdabot>   True
18:22:06 <ivanm> do you mean with a breadmaker or completely done by hand in an oven, etc.?
18:22:31 <pumpkin> I usually am lazy and do it with my breadmaker (which makes surprisingly good bread) but sometimes I'm feeling more virtuous and do it by hand
18:22:34 <retroj> pumpkin: are you making some kind of esoteric joke referring to James Beard?
18:23:38 <pumpkin> retroj: I don't think so :)
18:23:43 <adnap> pumpkin: Are you the c-something pumpkin person?
18:23:55 <retroj> pumpkin: ok.. well there's a cookbook called "Beard on Bread"
18:24:18 <pumpkin> retroj: ah :)
18:24:31 <pumpkin> adnap: most *pumpkin are me
18:24:41 <adnap> pumpkin: Okay
18:24:53 <dmwit> pumpkin, copumpkin, godofpumpkins?
18:24:59 <pumpkin> contrapumpkin sometimes too
18:25:04 <ivanm> pumpkin: including the ones in the shops? :p
18:25:06 <adnap> I'm going to refrain from saying something groan-worthy about Halloween.
18:25:06 <pumpkin> that's usually my third alternate nick on IRC
18:25:12 <pumpkin> adnap: I'm used to it :P
18:25:29 <deech> Hi all, I was looking at some of the GHC Alioth benchmarks. They suggest that Java 6 is more performant - how indicative are they of real-world performance?
18:25:34 * dmwit has had less nick-based jokes than he expected when he chose his nick
18:25:44 <ivanm> adnap: co-halloween, contra-halloween...
18:25:46 <pumpkin> dmwit: omg ur such a dimwit
18:25:57 * pumpkin wonders about a contravariance matrix
18:26:08 <ivanm> deech: the shootout measures how much someone has bothered to tweak the code to make it more performant
18:26:25 <ivanm> dmwit: I don't think I've had a single one...
18:26:28 <pumpkin> ivanm: there are upper bounds on some implementations
18:26:40 <ivanm> pumpkin: upper bounds of?
18:26:47 <pumpkin> of performance :P
18:26:55 <deech> ivanm: I can't tell -  has someone bothered much with the Haskell entries?
18:27:02 <pumpkin> deech: quite a bit, with some of them
18:27:07 <ivanm> deech: every now and then someone tweaks one of them
18:27:53 <dmwit> Getting good performance with Haskell requires some experience, which you get by getting lots of bad performance.
18:27:53 <deech> So can I conclude that it's reasonably accurate? 
18:28:14 <pumpkin> deech: accurate meaning can you extrapolate from those results?
18:28:15 <dmwit> On the other hand, getting reasonable performance requires almost no experience, which is a huge plus for such a nice language.
18:28:33 <deech> pumpkin: yes
18:28:49 <pumpkin> deech: I'd say don't extrapolate from them, but generally if you're experienced enough I'd say you can reach 3-5x of a hand-optimized c implementation of similar things with nicer code
18:29:05 <pumpkin> and the limit keeps improving
18:29:06 <deech> The benchmarks are interesting, LUa JIT is competes pretty well with GHC.
18:29:14 <pumpkin> often without you having to do much or any work
18:29:43 <dmwit> You can coerce almost any compiler into emitting the assembly you have in mind, in cases where that matters.
18:29:50 <pumpkin> if you basically write C in haskell, you can get within 2-3x of C code (shows how much low-level optimizations help?) but I'd recommend against it
18:30:12 <stepkut> Saizan: thanks!
18:30:15 <deech> So is it accurate to say that with GHC, idiomatic code is generally also the best performing?
18:30:17 <pumpkin> deech: some of those benchmarks are silly designs, in my opinion though
18:30:19 <dmwit> There we go! Now I sound experienced without the pain of actually gaining that experience.
18:30:35 <pumpkin> dmwit: that's always the goal
18:30:52 <pumpkin> deech: no, but it can potentially be almost as performant as the most performant code
18:30:55 <pumpkin> with a lot less code
18:31:07 <pumpkin> :P
18:31:17 <pumpkin> deech: and is more susceptible to improvements in the compiler and libraries
18:31:20 <bos> meep meep
18:31:20 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
18:31:24 <pumpkin> bos bovis!
18:31:48 <bos> ivanm: "yes"
18:31:53 <ivanm> cool
18:31:58 <deech> I see. Thanks for your input, folks!
18:32:04 <ivanm> bos: is there any particular reason that Lazy.length returns an Int64?
18:32:13 <ddarius> I don't own a bread machine, but bread machines do make good bread, they are just limited.
18:32:19 <adnap> Alright, is this shit ugly or no? http://hpaste.org/40914/edge_costs
18:32:19 <ivanm> Also, the sample code in the Lazy module refers to length returning an Int...
18:32:44 <ivanm> adnap: reasonably ugly
18:32:57 <bos> ivanm: so you can handle very large Texts on a 32-bit machine
18:32:59 <pumpkin> ddarius: they can often be used just to make the dough and make sure it rises nicely, and then you can take the dough and put it in the oven yourself
18:33:08 <ivanm> bos: *nod*
18:33:15 <pumpkin> mine can, anyway
18:33:16 <ddarius> pumpkin: Indeed.  That is a good use of them.
18:33:28 <adnap> ivanm: Any ideas on how to make it prettier?
18:33:47 <ivanm> adnap: les let statements
18:33:50 <ivanm> *less
18:34:00 <adnap> ivanm: What, you want "where"'s?
18:34:18 <ivanm> partially, but I meant split the function up
18:34:34 <adnap> ivanm: I think I split it up as much as I could.
18:34:49 <taktoa> adnap: thank
18:34:52 <taktoa> *thanks
18:34:54 <adnap> taktoa: np
18:34:56 <ivanm> adnap: also, if you have to have them in there, I find this cleaner: pBelow edge = (surfaceAreaBelow bounds axis edge) / (surfaceArea bounds)
18:34:59 <ivanm> i.e. don't use lambdas
18:35:24 <adnap> ivanm: I just removed the parens
18:35:32 <pumpkin> dmwit: if your names were francis kevin would you have chosen the same naming scheme?
18:35:35 <adnap> ivanm: hpaste said I didn't need them
18:35:39 <pumpkin> s/were/had  been/
18:35:50 <dmwit> p. not
18:36:06 <ivanm> adnap: whatever; I meant that having a one line non-lambda is nicer IMHO than a 3-line explicit lambda
18:36:57 <ddarius> ivanm: Incidentally, I need to go to the bakery across the street some time as there is a strong Brazilian presence in this area and I bet I can find some awesome Portugese sweet bread.
18:37:08 <pumpkin> mmm
18:37:10 <ivanm> ddarius: hmmm.... nom nom nom
18:37:20 <adnap> ivanm: Oh, I didn't notice that part.
18:37:22 <pumpkin> omnomnomicon 
18:37:29 <ivanm> there aren't any specialist bakeries near me AFAIK :(
18:37:53 <ivanm> though one of the supermarkets has a decent bakery selling international-style breads
18:37:59 <pumpkin> one advantage of being in this part of the world is that there's an amazing steakhouse near me
18:38:09 <pumpkin> unfortunately there's very little else
18:38:24 <pumpkin> in other news, this seems more appropriate for -blah :P
18:38:25 <ivanm> adnap: also, axis0 and axis1 seem to be redundant
18:38:47 <adnap> ivanm: axis1 is defined in terms of axis0
18:38:56 <ivanm> adnap: but neither are used!
18:39:26 <adnap> ivanm: Oh sh-... I thought there was a reason I wanted those...
18:39:55 <ivanm> adnap: I'd also be tempted to do a case statement for (above', below') rather than an if
18:40:27 <adnap> ivanm: Oh, I know why.  I was using them, but then I moved the surface area functions outside, so they do it instead.
18:40:42 <adnap> ivanm: But there are only two cases.
18:41:01 <ivanm> yes, but IMHO pattern matching is nicer than == on a constructor
18:41:16 <ivanm> or use guards
18:41:22 <ivanm> (if you want to use ==)
18:41:26 <adnap> Ohhh
18:41:34 <pumpkin> == will introduce unnecessary constraints
18:41:38 <ivanm> let (above', below') | edgeType == Begin = ... | otherwise = ...
18:41:50 <ivanm> pumpkin: well, if he's already derived Eq for that type it's not too bad
18:42:06 <adnap> It's an enum essentially
18:42:13 <adnap> EdgeType = Begin | End
18:42:14 <ivanm> for a course I was tutoring last semester, a lot of students were bitching that for an assignment one of the data types didn't have an Eq instance
18:42:22 <ivanm> why? so they could do == [] :s
18:42:36 <ivanm> took them a while to grasp that the null function exists for a reason :p
18:42:45 <pumpkin> lol
18:43:25 <ivanm> adnap: you also only use edges' in one spot; I'd be tempted to just do (sort edges) there
18:43:33 <ivanm> same with geometries
18:43:40 <adnap> ivanm: 'Kay
18:43:44 <roconnor> @type (==[])
18:43:45 <lambdabot> forall a. (Eq a) => [a] -> Bool
18:43:53 <roconnor> @type null
18:43:54 <lambdabot> forall a. [a] -> Bool
18:43:57 <adnap> I think I'll keep geometries, because it's less obvious.
18:44:06 <ivanm> yeah, that one is arguable
18:44:35 <adnap> It's kind of dangerous already how I'm inferring the number of geometries.
18:44:44 <adnap> I might change that later.
18:44:55 <adnap> This is a KD-Tree.
18:45:10 <ivanm> adnap: maybe split geometries off into a separate function?
18:45:32 <ivanm> adnap: I think there might be a hackage package that does that already...
18:45:38 <adnap> ivanm: Does what?
18:45:48 <adnap> ivanm: Oh, KD-Tree?
18:45:49 <ivanm> implements KD-trees
18:46:38 <pumpkin> really? I looked a while ago and couldn't find one
18:46:42 <pumpkin> maybe I just suck at looking
18:46:54 <adnap> I'm sure tons of people have them hidden in their ray tracers.
18:47:12 <ivanm> or maybe I'm getting it confused with something else
18:47:59 <adnap> I don't know, but I'm pretty much done with mine, so oh well.  I plan to nab someone's ray-tracer as a base though.  I've seen a lot of those floating around.
18:48:42 <adnap> Also, this is kind of a learning experience for me.  I'm doing this for a class.
18:49:29 <adnap> I'm really surprised there isn't much on Hackage.  Maybe I'll be able to make a contribution with my project.
18:49:51 <adnap> But I'm kind of planning to do the most naive thing I possibly can.
18:49:52 <pumpkin> that'd be nice
18:49:59 <pumpkin> I'd like to see more spatial datastructures
18:50:01 <adnap> I just want to get it done on time.
18:50:05 <pumpkin> purely functional spatial datastructures?
18:50:07 <MiggyX> sweet, RWH should be arriving today :D
18:50:21 <adnap> Well, my project is to implement Photon Mapping.
18:50:32 * ivanm is hoping to get Pearls of Functional Algorithm Design soon
18:50:44 <ivanm> I've only got two copies that should be coming to me from two different sources...
18:51:10 <MiggyX> ivan: I'm willing to settle for Hello World ;)
18:51:21 <blackdog> ivanm: i've got one :) it's good, but hell of dense.
18:51:34 <ivanm> blackdog: where did you get yours from?
18:51:41 <blackdog> bookdepository
18:51:44 <ivanm> huh
18:51:45 <blackdog> or repository
18:51:48 <blackdog> i always forget
18:51:50 <adnap> It will be interesting to see if there will be any speed limitations using Haskell.
18:52:02 <ivanm> I ordered it from Borders Online, and they're still waiting for it to come from overseas
18:52:09 <MiggyX> adnap: what was the original written in?
18:52:14 <ivanm> and Simon Thompson is sending me one to review it for JFP
18:52:16 <adnap> MiggyX: Original what?
18:52:38 <MiggyX> adnap: You mentioned speed limitations using Haskell - I assume you would be comparing the Haskell version to something?
18:53:18 <adnap> MiggyX: Oh, well, other people have written photon mappers in C I'm sure.
18:53:24 <adnap> MiggyX: I've never written one.
18:53:33 <MiggyX> adnap: ah okay
18:54:45 <adnap> MiggyX: I think I'll just look up performance data for other peoples' photon mappers.
18:55:22 <ManateeLazyCat> Have anyone write TH code do "[String] -> [String] -> (TypeA, TypeB, ... TypeN)" ? Example, 'fun ["string", "001", "c"] ["TypeString", "TypeInt", "TypeChar"]' will return ("string", 001, 'c')
18:55:31 <adnap> MiggyX: I'm really planning on implementing the dumbest thing I can though just so I can get it done on time.
18:55:38 <MiggyX> adnap: fair enough - I'm pretty interested in the performance of Haskell, especially with concurrency :)
18:55:47 <MiggyX> adnap: make it work first, then improve it if you have time ;)
18:55:59 <adnap> MiggyX: Yeah, I definitely want to try to parallelize since I've heard it's so easy.
18:56:08 <adnap> MiggyX: It's ideal for a ray tracer.
18:56:42 <enthropy> ManateeLazyCat: better use a typeclass so your Types can be determined by where you use them
18:56:49 <adnap> MiggyX: And you essentially do ray tracing with photon mapping in the rendering step.
18:57:19 * adnap goes to check out alexbobP's 1W laser that he ordered online
18:57:31 <enthropy> ManateeLazyCat: you're asking for your types to depend on runtime values...
18:57:45 <enthropy> and haskell doesn't do that very well
18:57:59 <ManateeLazyCat> enthropy: I think TH can do that.
18:58:37 <enthropy> ManateeLazyCat: if your list of "Types" is available at compile time
18:58:50 <blackdog> they can be in different phases, at least. if you genuinely want functions dependent on runtime values you could be a bit screwed
18:59:16 <ManateeLazyCat> enthropy: Yep, Types can calculate at compile time
19:00:12 <ManateeLazyCat> enthropy: I have [String] and i can calculate [Types] at compile time, i just want use TH with 'read' convert String to special type.
19:01:10 <enthropy> so you have  ''String  instead of  "TypeString" then?
19:02:02 <lispy> dobblego: I'm not sure.  Was there a reason you asked me specifically?
19:02:02 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
19:02:05 <ManateeLazyCat> blackdog: [String] is receive from DBus message for contain many different type, i need parse String on client side. If use DBus return (TypeA, TypeB, TypeC), i need write many different DBus interface function.
19:02:13 <dobblego> lispy, yes I thought were someone else :)
19:02:24 <lispy> dobblego: gotcha.  I'm Jason Dagit
19:02:26 <ManateeLazyCat> blackdog: Use [String], i just need write *one* interface.
19:02:36 <lispy> ?messages
19:02:36 <lambdabot> dobblego said 1h 12m 6s ago: what exactly is the difference between json-b and JSONb?
19:02:57 <dobblego> lispy, not Jason Dusek :)
19:03:51 <ManateeLazyCat> enthropy: New version : fun ["string", "001", "c"] [TypeString, TypeInt, TypeChar] ==> ["string", 001, 'c']
19:04:25 <enthropy> ManateeLazyCat: it's still not obvious what stage you know the TypeString and so on
19:04:44 <enthropy> you can write    $(fun [TypeString, TypeInt, TypeChar]) ["string", "001", "c"] ?
19:05:07 <lispy> dobblego: ah, easy mistake
19:05:30 <enthropy> ManateeLazyCat: also your "string" won't parse with read
19:05:38 <enthropy> > read "foo" :: String
19:05:39 <lambdabot>   "*Exception: Prelude.read: no parse
19:06:23 <ManateeLazyCat> enthropy: I just wonder have exist function do that before i write TH code .
19:08:02 <FeiRuoWa> heading to the library
19:13:26 <ivanm> dobblego: IIRC, the author just re-named the package
19:13:36 <dobblego> ivan, from, to?
19:13:59 <ivanm> see whichever has the newer version/upload date ;)
19:14:25 <dobblego> bleh
19:36:44 <dobblego> @hoogle arc
19:36:45 <lambdabot> System.Info arch :: String
19:36:45 <lambdabot> Text.Html archive :: String -> HtmlAttr
19:36:45 <lambdabot> Text.XHtml.Frameset archive :: String -> HtmlAttr
19:40:56 <dobblego> @type \b a t -> Data.Trie.singleton b a `mappend` t
19:40:57 <lambdabot> Couldn't find qualified module.
19:41:12 <dobblego> I must be doing something wrong -- this function is not available in Data.Trie
19:43:02 <enthropy> dobblego: which package supplies your Data.Trie?
19:44:13 <enthropy> this one has an insert which means you don't have to look up what happens to duplicates with mappend http://hackage.haskell.org/packages/archive/bytestring-trie/0.1.4/doc/html/Data-Trie.html
19:45:42 <ivanm> dobblego: what isn't available?
19:47:45 <enthropy> there are guides to asking good questions...
19:48:02 <Maxdamantus> @pl \a -> 2*a + 2*a
19:48:02 <lambdabot> liftM2 (+) (2 *) (2 *)
19:48:53 <dmwit> join ((+) `on` (2*))
19:49:20 <enthropy> not  (4*) ?
19:49:28 <dmwit> join (+) . (2*) -- even better
19:49:46 <dmwit> enthropy: Presumably (+) and (*) are just stand-ins for some more interesting operation.
19:50:27 <enthropy> @unpul join (+) . (2*)
19:50:27 <lambdabot> (\ d -> ((+) >>= \ e -> e) (2 * d))
19:50:46 <dmwit> I find ?unpl to be quite unhelpful in almost all situations.
19:51:02 <enthropy> it clarifies that (2*d) happens
19:51:02 <dmwit> how about
19:51:13 <dmwit> (\a -> a + a) . (2*)
19:54:26 <dmwit> copumpkin: Oh, lol, I just got your Francis Kevin joke.
19:58:22 <ddarius> Hmm.  I might actually need to buy a new laptop like I've been thinking about recently.  Mine is making weird smells, like way overcooked coffee all of a sudden.
19:58:44 <dmwit> Now, in glorious SMELLOVISION!
20:02:00 <ivanm> dmwit: heh
20:07:01 <mee> ddarius: sounds like dust clogging the fans and smoldering </shot in the dark>
20:07:41 <mee> I've had that make a weird burnt smell a couple times, anyway
20:09:54 <ddarius> Unrelated to the smell, which has passed, I think I have a virus and it's called flash.
20:18:55 <ivanm> ddarius: yeah, a lot of us have that
20:19:04 <ivanm> it's almost impossible to not have that virus nowadays :s
20:23:51 <Jonno_FTW> > sum [0.69,0.1,0.56,0.01,0.04,0.23,0.03,0.1,0.02,0.22]
20:23:52 <lambdabot>   2.0000000000000004
20:24:27 <Jonno_FTW> where did that 4*10^-16
20:24:33 <Jonno_FTW> come from?
20:25:45 <lucca> > sum [0.69,0.1,0.56,0.01,0.04,0.23,0.03,0.1,0.02,0.22] :: CReal
20:25:46 <lambdabot>   2.0
20:26:40 <lucca> or really
20:26:49 <lucca> > sum $ sort [0.69,0.1,0.56,0.01,0.04,0.23,0.03,0.1,0.02,0.22] 
20:26:50 <lambdabot>   2.0
20:29:32 <Jonno_FTW> but where did it come from?
20:29:41 <Jonno_FTW> :t sum [0.69,0.1,0.56,0.01,0.04,0.23,0.03,0.1,0.02,0.22]
20:29:42 <lambdabot> forall t. (Fractional t) => t
20:29:55 <ivanm> Jonno_FTW: computers can't store real numbers precisely, unless you use something like CReal
20:29:58 <ivanm> but CReals are slow
20:30:08 <ivanm> @google what every computer scientist should know about floating point
20:30:09 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
20:30:11 <ivanm> bah
20:30:22 <Jonno_FTW> I did start reaading that article once
20:30:42 <ivanm> well, yeah
20:30:58 <ivanm> you know how floating point numbers are stored in binary?
20:31:16 <ivanm> hint: you can't even store 0.1 accurately using binary
20:32:04 <monochrom> http://floating-point-gui.de/
20:32:33 <ivanm> heh, nice use of the german country code
20:35:11 <monochrom> yeah, took me a year to figure out: (1) why is it hosted in germany? (2) what is the "gui" part doing there?
20:35:54 <monochrom> the characteristic of a scientific theory is that it answers both questions in one go.
20:35:55 <ivanm> lol
20:50:02 * hackagebot web-routes-happstack 0.20 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.20 (JeremyShaw)
20:52:19 <JoeyA> Has anyone investigated automatic memoization in evaluating Haskell or similar?
20:52:32 <ivanm> yes, it's bad
20:53:02 <JoeyA> for instance, if you define drop 0 xs = xs; drop n xs | n > 0 = tail (drop (n-1) xs)
20:53:31 <monochrom> I'm more inclined to a pragma {-# memoize this! #-} than automatic.
20:53:32 <JoeyA> given a list [1..10], it will, conceptually, memoize every function call
20:53:39 <ivanm> monochrom: that _might_ work
20:53:44 <JoeyA> I'm talking about from a theoretical perspective
20:53:51 <ivanm> JoeyA: there are an infinite number of possible lists...
20:54:10 <ivanm> and I doubt you'd be wanting to drop the same list enough times that memoisation would be worthwhile
20:54:18 <monochrom> from a theoretical perspective, we have an unboundedly long tape, yeah...
20:54:29 <JoeyA> well, if you say drop 5 [1..10], it'll become tail (drop 4 [1..10]), and the drop 4 thing can be memoized
20:54:48 <ivanm> @src drop
20:54:48 <lambdabot> drop n xs     | n <= 0 =  xs
20:54:49 <lambdabot> drop _ []              =  []
20:54:49 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
20:54:49 <JoeyA> There are obvious problems with a naive approach, I understand that.
20:55:01 <ivanm> JoeyA: starting with your wrong definition of drop :p
20:55:10 <JoeyA> sure it's wrong?
20:55:20 <JoeyA> I gave it a different implementation.
20:55:26 <ivanm> > let drop 0 xs = xs; drop n xs | n > 0 = tail (drop (n-1) xs) in drop 10 [1..5]
20:55:27 <lambdabot>   *Exception: Prelude.tail: empty list
20:55:35 <ivanm> JoeyA: I'm sure it's wrong :p
20:55:40 <JoeyA> An implementation with head/tail or possibly even pattern matching might fail to memoize (unless the execution engine is really really clever)
20:56:02 <JoeyA> > let drop 0 xs = xs; drop n xs | n > 0 = tail (drop (n-1) xs) in drop 10 [1..20]
20:56:03 <lambdabot>   [11,12,13,14,15,16,17,18,19,20]
20:56:13 <JoeyA> okay, so you throw in a safeguard, big whoop
20:56:23 <ivanm> it's not a safeguard
20:56:23 <JoeyA> (sorry, that's not very polite)
20:56:38 <monochrom> as usual, the devil is in the non-naïve approaches. we can't even get the compiler to detect "is this function strict?" yet. nevermind "is this function memoizable within 10MB memory"
20:56:41 <ivanm> tail is a partial function; let's try to avoid them unless we know it's safe
20:56:50 <ivanm> monochrom: yeah
20:56:56 <monochrom> err, s/to detect/to reliably detect/
20:58:22 <JoeyA> I think that abstractions like lazy evaluation or automatic memoization fail when the programmer has to worry about how the abstraction will affect their performance.
20:58:45 <ivanm> which abstractions don't?
20:58:54 <ivanm> even garbage collection affects performance
20:59:01 <JoeyA> right
20:59:18 <ivanm> but most of us prefer not to program in machine code :p
20:59:50 <JoeyA> let me modify that: if the abstraction's time/space penalty is not limited by some reasonable constant factor, the abstraction "fails" in a sense
21:00:19 <JoeyA> compiled code versus assembly is a constant factor, hence the abstraction doesn't fail there
21:00:39 <JoeyA> When garbage collection doesn't release memory to the OS when you free things, the abstraction fails.
21:00:45 <ivanm> no, I meant machine code in the sense that we have no abstractions
21:00:55 <JoeyA> (Haskell being one perpetrator, but probably not the worst)
21:00:58 <ivanm> and GC affects performance, especially when it uses stop-the-world
21:01:25 <JoeyA> Laziness also fails because you have to worry about space leaks and stack overflows.
21:01:47 <ivanm> very rarely in my experience
21:01:48 <ddarius> Eagerness affects your performance.
21:01:50 <monochrom> all constant-overhead abstractions have alreayd been invented before the 1980s.
21:01:50 <JoeyA> (in cases where running Haskell in the hidden strict mode wouldn't have those problems)
21:02:00 <ivanm> the only time it has affected me is when I had a counter that needed a bang
21:04:19 <JoeyA> I've heard about "speculative evaluation" as an alternative to lazy evaluation.  Perhaps it is possible, with plenty of cleverness, to make every lazy program have time/space performance that's just as good as the equivalent strict program.
21:04:23 <dobblego> enthropy, thanks, I totally overlooked that
21:04:39 <JoeyA> That might come at a cost to the constant factor, though
21:05:00 <ddarius> There are plenty of lazy programs that have much better performance than the eager equivalent.
21:05:01 <JoeyA> (again, to clarify: by "just as good", I'm speaking in terms of big O)
21:05:17 <dobblego> oh I see what happened, I linked to Trie from another module which took me to Data.Trie.Internal, which has no such function
21:05:40 <ivanm> dobblego: lol
21:05:46 <JoeyA> But there exist a whole bunch of cases where laziness ruins performance
21:06:00 <ddarius> There exist a whole bunch of cases where eagerness ruins performance.
21:06:10 <JoeyA> such as having a running tally where the sum turns into a tower of thunks rather than being evaluated.
21:06:41 <ddarius> such as having a guarded recursion where the recursion turns into a tower of stack frames rather than being delayed
21:06:54 * djahandarie is loling
21:07:04 <JoeyA> right
21:08:04 <JoeyA> Anywho, back to my question: is there any research on automatic memoization, even if it's a terrible, horrible, no good, very bad idea?
21:08:37 <ddarius> The main reason you think lazy "ruins performance" is because when laziness causes a problem, people say "that's slow due to laziness", but when eagerness causes a problem people rarely say "that's slow due to eagerness."
21:08:49 <djahandarie> JoeyA, "automatic" as in the compiler doing it for you?
21:09:10 <JoeyA> automatic, as in, conceptually, everything is memoized.
21:09:35 <ivanm> I still say that's a horrible idea
21:09:52 <ivanm> since how often do you keep passing the exact same inputs to a function?
21:10:23 <djahandarie> JoeyA, it's possible for a lot of types of functions (see conal's blog posts)
21:10:31 <JoeyA> Not often, if you structure your code a certain way
21:10:59 <JoeyA> But you can avoid needing infinite lists and laziness if you structure your code a certain way, too.
21:11:04 <conal> memoization can even be done on functions over exact reals.
21:11:27 <conal> which surprised me.
21:11:55 <Saizan> JoeyA: quite related http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.99.8046
21:12:01 <JoeyA> What I'm talking about is the notion of making memoization an abstraction, not just a programming language feature you can salt your code with.
21:12:14 <djahandarie> JoeyA, read conal's blog posts
21:12:24 <djahandarie> http://conal.net/blog/posts/memoizing-higher-order-functions/
21:12:32 <JoeyA> Laziness fails to be an abstraction when you have to use seq (not that it isn't useful).
21:12:39 <MiggyX> yay, RWH just arrived :)
21:12:39 <monochrom> very slow program is due to PEBKAC
21:12:53 <conal> and more here: http://conal.net/blog/tag/memoization/
21:13:19 <ddarius> monochrom: Indeed.
21:13:29 <JoeyA> Likewise, memoization isn't an abstraction, in the fullest sense, if the compiler doesn't do it all for you.
21:13:34 <ddarius> monochrom: That, or mathematics.
21:13:41 <monochrom> err. every slow program is due to PEBKAC
21:14:08 * hackagebot texmath 0.4 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.4 (JohnMacFarlane)
21:14:12 <djahandarie> conal, are you going to write a paper summing up a bunch of these memoization ideas you've come up with?
21:14:28 <JoeyA> Now if automatic, compiler-does-it-for-you memoization is impossible, and if it's impossible to implement a really close approximation, then I rest my case.
21:14:49 <ddarius> Since seq changes the semantics of a program, it doesn't really make sense to say it violates an abstraction.
21:14:54 <conal> djahandarie: yeah i will.  there's so much there.  i'm amazed at what a rich & beautiful topic it's turned out to be.
21:15:15 <monochrom> is memoization an abstraction?
21:15:24 <ivanm> I don't think so
21:15:25 <monochrom> is even GC an abstraction?
21:15:30 <ddarius> I wouldn't say so, nor would I call laziness one.
21:15:36 <ivanm> GC abstracts away memory management...
21:15:43 <conal> probably for icfp 2011. i love writing papers by gathering up material from blog posts. much less painful than other papers i've written.
21:16:02 <monochrom> I feel that this is a strawman thing. First let's pretend it is an abstraction. Now attack it on the ground that it is supposed to be an abstraction but leaks.
21:16:08 <ivanm> monochrom: heh
21:16:15 <JoeyA> What I'm talking about is: can memoization be an abstraction?
21:16:21 <JoeyA> Currently, it isn't.
21:16:41 <djahandarie> I wish I could go to ICFP 2011
21:16:47 <ddarius> djahandarie: You can.
21:16:51 <ddarius> Wish granted.
21:17:03 <ivanm> I might try to be able to go, since it'll be the closest to me it's even been next year
21:17:04 <djahandarie> Are you granting it with all the money you're getting from the government?
21:17:15 <ddarius> djahandarie: I didn't say you will, I said you could.
21:17:30 <ddarius> djahandarie: And the government isn't paying me.
21:17:35 <shachaf> ddarius: "will" == "could"
21:17:44 <djahandarie> (That was the joke ddarius)
21:18:21 <ddarius> djahandarie: The government was paying me until very recently and does, actually, still owe me some money, but it, currently, isn't paying it to me.
21:19:07 <djahandarie> I suppose I could round up some money within a few months and buy a ticket and hotel, since September is pretty far away
21:19:31 <djahandarie> Or maybe I'll work on writing some amazing paper with some stroke of brilliance
21:19:41 <djahandarie> And then get someone to pay for me!
21:19:57 <ivanm> djahandarie: you _might_ be able to get a grant to cover part of the costs
21:19:59 <ivanm> but not all
21:20:15 * ivanm went to PEPM in January with ACM SIGPLAN covering most of his airfares
21:20:33 <djahandarie> Undergraduates get grants these days?
21:20:42 <monochrom> there are even cases of malloc and free hurting speed because of not enough cache locality.
21:21:01 <ivanm> djahandarie: they're aimed at postgrads, but will probably help you out
21:21:26 <ivanm> I wasn't technically a student at that time, as I started my PhD about a fortnight after I got back home
21:21:43 <djahandarie> ...14 days?
21:21:53 <ivanm> about that
21:22:02 <ivanm> possibly 3 weeks
21:22:14 <monochrom> with some stroke of brilliance, you should just make a million dollars.
21:22:15 * ivanm can't quite recall the dates involved
21:22:45 <djahandarie> monochrom, then... with a stroke of brilliance and a stroke of stupidity to use it writing a paper, maybe?
21:22:58 <monochrom> no, a million dollars is ICFP for life.
21:23:49 <JoeyA> Interesting idea (to me, at least): when creating an immutable object, see if another immutable object with the same content has the same data.  If so, just share memory.
21:23:52 <monochrom> also, writing a paper takes only 1000-10000 dollars.
21:24:10 <JoeyA> I wonder if that would be faster, on account of not having to allocate as much.
21:24:12 <djahandarie> Haskeller 4 life.
21:24:18 <JoeyA> (certainly depends on the circumstances)
21:24:38 <ddarius> Yes, let's grep all of memory.
21:24:45 <ivanm> JoeyA: that would require you to go through every memory location and do coercion + equality testing, wouldn't it?
21:24:58 <monochrom> it is very fast initially!
21:24:59 <ivanm> note: things like list concatenation already partially do this...
21:25:26 <JoeyA> Just use a search tree (patricia, AVL, whatever turns out to be fastest) and compare by binary representation
21:25:27 <ivanm> monochrom: heh
21:25:41 <monochrom> we need to compete on coming up with these unbaked ideas so the naysayers are overwhelmed and can't refute them all!
21:26:04 <JoeyA> I've submitted mine!
21:26:16 <ivanm> JoeyA: how do you compare [1..] with [1,2..] ?
21:26:31 <ivanm> can [1..] tell that it should share memory with [3..10] ?
21:26:45 <monochrom> interesting idea: use haskell to solve a millenium problem to win a million dollars and donate it to djahandarie
21:26:54 <djahandarie> Approved.
21:27:12 <JoeyA> ivanm: It would happen in the memory allocation phase.
21:27:31 <ivanm> monochrom: crazy idea: djahandarie solves the millenium problem...
21:27:39 <ivanm> JoeyA: ... right ...
21:27:43 <JoeyA> First of all, require that the heap only hold immutable objects (use a separate construct for mutable objects)
21:28:02 * ddarius goes to sleep.
21:28:06 <JoeyA> Second, when allocating, have the object's data in a temporary buffer first before finding longer-term memory for it.
21:28:07 * djahandarie follows
21:28:12 <djahandarie> (To a different bed)
21:28:22 <ivanm> djahandarie: nice cover story :p
21:28:55 <JoeyA> Third, rather than just allocating and copying the data into it, search for another block with the same data.  Reuse that block if it exists, allocate a new one otherwise.
21:29:33 <monochrom> interesting idea: build biological computer for haskell. hell, I already wrote it in http://thread.gmane.org/gmane.comp.lang.haskell.cafe/22537
21:29:52 <JoeyA> Blocks would be indexed by a search tree (patricia, AVL, B-tree, whatever benchmarks prove to be fastest)
21:30:25 <ivanm> JoeyA: here's an interesting idea: why don't you try implementing some of your interesting ideas? :p
21:30:44 <JoeyA> I tried, but fell behind on my homework.  Now I'm not allowed to program :(
21:31:02 <shachaf> There seem to be different people here, so I might as well ask again: Is there a good way of writing a lazier reverse function in Haskell?
21:31:20 <ivanm> shachaf: I thought the current reverse was as lazy as you could get
21:31:24 <ivanm> @src reverse
21:31:24 <lambdabot> reverse = foldl (flip (:)) []
21:31:31 <shachaf> ivanm: I don't think so.
21:32:08 <ivanm> hmmm, GHC has an optimised version
21:32:08 <JoeyA> meaning I'll probably have to wait till I can manage to get into a masters program before I can devote endless time to something like that.
21:32:10 <shachaf> ivanm: You can start returning the structure of the new list -- the first N conses -- as soon as you've seen N elements, even if you can't return their values until you get to the end of the list.
21:32:16 <ivanm> which appears to be doing the fold manually
21:32:40 <ivanm> shachaf: I have no idea how you would implement that...
21:32:48 <monochrom> I am no longer sure whether I was serious or trolling in my native G-machine article. :)
21:32:49 <JoeyA> well, good night
21:32:58 <JoeyA> thanks for letting me troll
21:33:01 <shachaf> ivanm: Well, I can think of stupid ways of doing it, I suspect. :-)
21:33:52 <ivanm> augur: you're just in time; JoeyA is going to bed and we need someone to replace him as the guy trolling the channel by coming up with crazy ideas!
21:33:55 <shachaf> ivanm: But it should be possible to do it nicely, shouldn't it?
21:34:05 <augur> ivanm: :x
21:34:18 <augur> trolling like with fish, right
21:34:24 <ivanm> it might be _nice_ to do so, but I can't think of a way of saying "I know there will be n values here but I'll provide them later" :s
21:34:44 <ivanm> unless you do some kind of mutable memory reference stuff
21:34:59 <ivanm> shachaf: hmmm, I wonder if you could do something in ST with that...
21:35:12 <shachaf> ivanm: Well, you could return a list of values each of which indexes back into the original list, presumably. Which would be awful, of course.
21:35:33 <ivanm> reverse indexing would be difficult
21:35:49 <michael__> Can I interrupt to asking about building GHC.  I want to do so on Haiku but as far as I can tell, GHC is now distributed with the Platform (an excellent idea, BTW) and there doesn't seem to be any help for installing it on other OSs.
21:35:51 <augur> ivanm: so heres an idea ive been bouncing around in my head for the last few hours
21:36:09 <ivanm> michael__: sure there is, off the GHC page proper
21:36:12 <augur> imagine you have some binary set of propositions, prolog-database-esque
21:36:18 <ivanm> augur: k
21:36:20 <augur> or maybe you can think of it as a labeled directed graph
21:37:26 <augur> what sorts of (symbolic?) learning can we do that lets the system discover things like transitive relations
21:37:29 <ivanm> michael__: http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
21:37:48 <ivanm> augur: hmmm.... I have no idea how to do anything about that, but it definitely sounds cool!
21:38:18 <augur> ivanm: indeed. im trying to figure out just what it would take to get transitive relations
21:38:23 <augur> im not entirely sure how to do it tho
21:38:25 <augur> maybe like
21:38:32 <michael__> ivanm:  Thanks very much;  looking now.
21:38:50 <ivanm> michael__: np
21:39:28 <Saizan> shachaf: go through an array?
21:39:43 <augur> suppose we have   f(a,b) :- g(a,b)   f(c,d) :- g(c,e), g(e,d)   and so forth for a few more examples
21:39:58 <shachaf> Saizan: I'm looking for nice ways to do it.
21:40:10 <shachaf> Saizan: How do you suggest doing it with an array, at any rate?
21:40:16 <augur> maybe we'd be able to abstract out to variables   f(X,Y) :- g(X,Y)   f(X,Y) :- g(X,Z), g(Z,Y)   etc for each
21:40:50 <augur> and then we just say, ahh, but if g(Z,Y), then f(Z,Y), because f(Z,Y) :- g(Z,Y)
21:41:52 <Saizan> shachaf: reverse xs = zipWith (\ _ i -> arr ! i) xs [0..] where arr = listArray{- or whatever it's called -} (0,length xs - 1) xs 
21:41:53 <augur> so f(X,Y) :- g(X,Z), g(Z,Y)   ==   f(X,Y) :- g(X,Z), f(Z,Y)
21:42:17 <Saizan> ?type listArray
21:42:18 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
21:42:19 <shachaf> Saizan: If you have to compute length xs before constructing the array, it defeats the purpose, doesn't it?
21:42:36 <augur> and that should give us an f that's self-recursive
21:42:51 <Saizan> shachaf: why? you'll still be able to return the conses before the array is built
21:42:53 <augur> f(X,Y) :- g(X,Y) ; g(X,Z), f(Z,Y)
21:43:16 <monochrom> haskell arrays are fixed-size. you could implement your own growable array on top of it.
21:43:29 <Mitar> any easy way to add another element to a tuple? so to get from (a,b) -> (a,b,c)
21:43:37 <shachaf> Saizan: Oh, I see. Hmm.
21:44:08 <Rotaerk> if only F# had haskell's where...
21:44:14 <shachaf> Saizan: Your function doesn't actually do the reversing part, though. :-)
21:44:27 <Saizan> shachaf: heh, true
21:44:31 <monochrom> does F# have let?
21:44:35 <Saizan> but that's a detail :P
21:44:36 <Rotaerk> http://codepad.org/V50qmhpM
21:44:44 <Rotaerk> I'm debating between 1 and 3 there...
21:44:58 <Rotaerk> 1 is more concise, but I like to minimize scope, and not have a bunch of up-front declarations before the final result
21:45:11 <ivanm> Rotaerk: and I am once again glad that I never bothered learning ocaml...
21:45:16 <Rotaerk> :P
21:45:37 <Rotaerk> well this is F#, OCaml's just the closest syntax coloring I could find in a pastebin
21:45:57 <ClaudiusMaximus> any thoughts for an optimal GUI for "a finite sequence of rational numbers q_i with each 0<q_i<1" ?
21:46:14 <ivanm> Rotaerk: I'm sorry, is that meant to mean that it could have been _worse_? :o
21:46:15 <monochrom> I learned ocaml. its type system is so cool, all other inconveniences are compensated for.
21:46:29 <ivanm> ClaudiusMaximus: ... why does that need a GUI?
21:46:34 <Mitar> hmm
21:46:44 <ivanm> monochrom: what does its type system have that Haskell doesn't (and should)?
21:46:49 <ClaudiusMaximus> ivanm: because i don't want to have to quit my program and restart it to give new command line arguments
21:46:53 <Rotaerk> ivanm, I like the .NET framework, so I endure F# :P
21:46:55 <Mitar> unzip and zip3? ;-)
21:47:03 <ClaudiusMaximus> ivanm: which is what i'm doing so far!
21:47:07 <monochrom> all sorts of subtyping, such as record subtyping
21:47:08 <ivanm> ClaudiusMaximus: have a prompt then
21:47:09 <Rotaerk> but haskell's certainly more elegant
21:47:39 <ClaudiusMaximus> ivanm: yeah, i think that makes sense, and a big frowny face when it's not valid
21:48:18 <shachaf> Saizan: Is there a way of doing it that's reasonable enough that it could be the default definition of reverse? :-)
21:48:39 <ClaudiusMaximus> ivanm: i might even make it so you can type 1/3 instead of 1%3 
21:49:37 * monochrom imagines the arcade-game style input
21:50:18 <ClaudiusMaximus> monochrom: you mean on screen alphabet style with joystick to navigate?
21:50:21 <monochrom> specifically, the shooting games, in which you use a toy gun, not a stick.
21:50:21 <freedrull> is there a lanugage extension that allows two different record fields in different data types to have the same name?
21:50:47 <ClaudiusMaximus> ok
21:51:15 <Mitar> freedrull: yes
21:51:15 <ivanm> freedrull: no
21:51:19 <Mitar> ye?
21:51:20 <ivanm> Mitar: there is? :o
21:51:20 <Mitar> yes?
21:51:24 <freedrull> will disambiguaterecordfields work?
21:51:26 <ClaudiusMaximus> freedrull: perhaps DisambiguateRecordFields
21:51:27 <monochrom> to enter m/n, first the screen flashes lots of random numbers. when you see the number you want for m, you shoot. do the same for n.
21:51:33 <ivanm> oh, haven't heard of that one...
21:51:35 <ClaudiusMaximus> (i just grepped)
21:51:37 <freedrull> ill try it, maybe im not saying what i mean
21:52:35 <freedrull> nope didnt work
21:52:45 * monochrom offers to describe other crazy methods of input :)
21:52:45 <freedrull> :3
21:54:01 <freedrull> cant haskell infer which record field i want by looking at the type im applying it to
21:54:03 <ivanm> freedrull: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#disambiguate-fields
21:54:11 <monochrom> no, haskell can't
21:54:42 <ivanm> freedrull: as an alternative, define them in separate moduels and import those modules qualified
21:57:31 <freedrull> but they can't be in the same module huh
21:57:57 <monochrom> if they are in the same module, choose distinct names
21:58:39 <ivanm> if you want accessors with the same name, make a new class
21:58:52 <ivanm> it won't help you use the record fields for setting them be the same though
21:58:53 <monochrom> haskell 2036 will fix this IIRC
21:59:10 <freedrull> haha
21:59:55 <ivanm> monochrom: oh? I thought it wasn't planned until 2038
22:00:00 <freedrull> i guess prefixing the fields to make them distinct will do
22:00:15 <ivanm> they were going to fix it whilst dealing with the year 2038 problem
22:00:27 <Saizan> shachaf: another option; "expand xs [] = []; expand xs (_:skel) = head xs : expand (tail xs) skel; yourreverse xs = expand (reverse xs) xs"
22:00:50 <shachaf> > let { rev l = rev' (reverse l) l where { rev' _ [] = []; rev' ~(r:rs) (x:xs) = r : rev' rs xs } } in null (1:2:undefined)
22:00:51 <lambdabot>   False
22:01:00 <shachaf> Saizan: Another way.
22:01:21 <ivanm> shachaf: note: you didn't reverse anything there... ;)
22:01:30 <shachaf> Ahem.
22:01:37 <Saizan> heh expand == rev' :)
22:01:49 <shachaf> Saizan: Oh.
22:01:54 <ivanm> shachaf: you just did "null (1:2:undefined)"
22:02:10 <shachaf> > let { rev l = rev' (reverse l) l where { rev' _ [] = []; rev' ~(r:rs) (x:xs) = r : rev' rs xs } } in (null . rev $ (1:2:undefined), rev [1,2,3]) -- Happy?
22:02:11 <lambdabot>   (False,[3,2,1])
22:02:18 <shachaf> Saizan: Looks like you just beat me. :-(
22:02:31 <ivanm> shachaf: moderately so ;)
22:02:59 <shachaf> s/\(/)/
22:03:10 <Saizan> shachaf: well, if we focus on different aspects of the algorithm we might both get to publish :)
22:03:42 <shachaf> Saizan: IRC logs are all that counts.
22:05:01 <Saizan> i wonder if it's possible to fuse reverse and expand to do the whole thing in a single pass
22:09:04 <shachaf> Saizan: Well, you can do "rev [] = []; rev l = last l : rew (init l)".
22:09:09 <shachaf> Which doesn't really count.
22:13:23 * shachaf notes that (head . reverse) is significantly slower than (last).
22:14:15 <mister_m> can I get learn you a haskell in pdf form ?
22:15:27 <Saizan> shachaf: that definition is O(n^2) to get the whole list though
22:15:34 <shachaf> Saizan: Yep.
22:15:51 <shachaf> Saizan: Although it *does* get the first element more quickly than reverse. :-)
22:16:23 <shachaf> @faq can I get learn you a hasekll in pdf form ?
22:16:23 <lambdabot> The answer is: Yes! Haskell can do that.
22:16:30 <shachaf> @google learn you a haskell in pdf form
22:16:30 <lambdabot> No Result Found.
22:16:47 <shachaf> Bah, broken. Anyway, it's there.
22:17:31 <djahandarie> I'm not sure if that contains the latest chapters or not
22:17:37 <djahandarie> And wow I never went to bed
22:17:39 <djahandarie> Gah
22:18:32 <shachaf> djahandarie: goto bed;
22:18:41 * shachaf suspects this isn't the right channel.
22:18:49 <mister_m> man, it's more fun to read the website version
22:19:27 <monochrom> @quote monochrom record
22:19:27 <lambdabot> monochrom says: Co dawg, we heard you like records so we put record puns so you can omit field names while you name fields.
22:20:21 <djahandarie> It is if goto has a type of (Monad m) => Location -> m Location ;)
22:20:59 * djahandarie is really gone now
22:36:03 <turiya> is there an efficient way to subtract two Bytestrings?
22:39:03 <lispy> turiya: subtract in what sense?  Set difference?
22:39:18 <turiya> no.. arithmetic difference
22:39:45 <turiya> assuming the BS's are of the same length ..
22:40:03 <lispy> turiya: something similar to zipWith subtract bs1 bs2?
22:40:31 <turiya> lispy: i will check if that works
22:45:52 <turiya> lispy: zipWith does not seem to work with ByteStrings
22:46:21 <lispy> ?hoogle ByteString zipWith
22:46:21 <lambdabot> No results found
22:46:50 <lispy> turiya: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/bytestring-0.9.1.6/Data-ByteString.html#20
22:47:40 <turiya> ok.. i think i have the used the wrong zipWith.. thanks
22:56:04 <turiya> is there any advantage of using ByteStrings over Word8 lists?
22:58:14 <Saizan> strict ByteString are more like C arrays, so compact memory representation and fast indexing
22:59:34 <adnap> Why do I get this error: http://pastebin.com/yfwW9zwk when UArray Word8 is clearly an instance of IArray as specified by: http://hackage.haskell.org/packages/archive/array/0.3.0.1/doc/html/Data-Array-IArray.html#t:IArray?
22:59:36 <turiya> oh..i see.. 
23:01:57 <Saizan> adnap: when ghc shows you the package name/version in the name of a type usually it's because it's relevant
23:02:16 <Saizan> adnap: you're probably mixing array-0.3.0.0 and array-0.3.0.1 in your program
23:02:38 <adnap> Saizan: I checked for that.  The documentation for 0.3.0.0 also has an instance for UArray Word8
23:03:12 <Saizan> adnap: yeah, what i mean is that you are using UArray from 0.3.0.0 but the IArray class from 0.3.0.1
23:03:33 <adnap> Saizan: Why would that matter?
23:03:51 <Saizan> adnap: it matters because you can't do that
23:03:55 <adnap> Saizan: lol
23:04:06 <adnap> Saizan: That explains everything. XD
23:04:16 <Saizan> UArray from 0.3.0.0 is not the same type as UArray from 0.3.0.1
23:04:33 <adnap> Saizan: Right, but if the interface to IArray is still the same, why would it matter?
23:04:50 <Saizan> because ghc doesn't bother checking if they are actually defined in the same way, it stays on the safe side and assumes they are unrelated
23:05:00 <adnap> Saizan: Oh
23:05:21 <Saizan> so an instance for one is not valid for the other
23:05:28 <Saizan> same with classes
23:05:28 <adnap> Saizan: One strange thing I noticed is that when I installed array, it installed the newest version, but for some reason, GHC tries to compile with the older version.
23:06:04 <Saizan> adnap: if you don't have a specific reason to use the newer version i'd unregister it
23:06:26 <adnap> Saizan: Wait, IArray and UArray are in the same package.  How could there be conflicting versions?
23:06:46 <Saizan> ghc might be trying to compile with the older one because you're also using some other lib that's compiled against that version
23:06:58 <adnap> Saizan: Oh, I am.
23:07:38 <adnap> But then why would it matter?  I'm either using one array version or the other.  It's not pulling IArray from one package and UArray from the other, right?
23:07:45 <Saizan> so you get the IArray class from array-0.3.0.1 but the other lib you're using exposes an UArray from 0.3.0.0, and kaboom.
23:07:51 <adnap> Saizan: Oh
23:07:57 <adnap> Saizan: It only exposes one type.
23:07:59 <adnap> Saizan: I see.
23:08:08 <adnap> Saizan: That is majorly annoying.
23:08:44 <adnap> Saizan: How do I force ghc to use the older version, or do I just have cabal install the older version?
23:08:59 <Saizan> you can compile a program that uses multiple versions of the array package if you work around the fact that they are considered distinct
23:09:11 <Saizan> adnap: the older version is still installed
23:09:35 <adnap> Saizan: So I just remove the new version?  Can you tell cabal to remove a specific version?
23:09:36 <Saizan> adnap: you can pass "-package array-0.3.0.0" to ghc to force that version
23:10:06 <Saizan> adnap: you can remove the new version with "ghc-pkg unregister array-0.3.0.1"
23:10:38 <adnap> Saizan: And what were you saying about using multiple versions with a work around?
23:10:45 <adnap> Saizan: How does that work?
23:11:21 <Saizan> adnap: usually it's not worth it if you have to convert from one type to the other, it's more useful if they are actually used in separate parts of the code
23:11:59 <Saizan> adnap: in principle you could write a function to convert from an old UArray to a new one
23:12:09 <adnap> Saizan: So, ghc-pkg unregister doesn't uninstall the package?
23:12:25 <adnap> Saizan: What if I forget that I unregistered it and later I need to use the newer version?
23:12:34 <Saizan> adnap: ghc-pkg unregister will uninstall the package, but only that particular version
23:12:46 <adnap> Saizan: Oh, okay.
23:12:51 <Saizan> adnap: that you'll have to reinstall it
23:13:15 <adnap> Saizan: "unregister" just sounds "soft" to me.  I wasn't sure if it actually meant it was uninstalling it.
23:13:26 <Saizan> well, the actual files are not removed
23:13:36 <Saizan> but ghc won't know about the package anymore
23:14:05 <adnap> Saizan: But if you do a --reinstall with cabal, ghc will know about it again?
23:14:43 <Saizan> adnap: you won't need a --reinstall because cabal also won't know about it, and it'll get installed from scratch
23:14:51 <adnap> Saizan: Oh, okay.
23:15:14 <adnap> Saizan: Also, how can I tell from which version a package exposes a type from another package?
23:16:02 <adnap> Saizan: Oh, one thing I noticed: I can use -package to force the newest version too.  That will work for the package that exposes the older version of the type.
23:16:23 <adnap> Saizan: Provided nothing breaks
23:16:47 <Saizan> adnap: if you recompile it, sure, but the newest version is the default anyway
23:17:11 <adnap> Saizan: No, not recompile the package that exposes the older version.
23:17:34 <Saizan> adnap: then you won't be able to make it expose the newer version
23:17:41 <adnap> Saizan: I mean I can just compile MY program forcing the newer package, and the other package which exposes the older package will use the newer version instead.
23:18:02 <Saizan> adnap: no, it doesn't work like that
23:18:11 <adnap> Saizan: Oh, wait...
23:18:17 <adnap> Saizan: It didn't work, nevermind.
23:18:32 <Saizan> once a package is compiled the versions of its dependencies are fixed
23:19:14 <Saizan> and you can use "ghc-pkg field thatpackage depends" to see them
23:21:08 <adnap> depends: array-0.3.0.0-ed0c6ffecd933bdec33f902cfd4153ec base-4.2.0.0-2cc27b7e43511c4ca001642a7f77a8f6
23:21:30 <Zeiris> How... Crazy would it be, to have a Haskell DSL that produces Erlang code?
23:22:29 <adnap> Saizan: Why is it that when I unregister array-0.3.0.1 it still complains when I try to compile without the -package flag?
23:22:42 <adnap> Saizan: Shouldn't it no longer be needed since I've removed the latest version?
23:23:33 <Saizan> adnap: you get the same error?
23:23:49 <kmc> Zeiris, crazy awesome!
23:24:13 <Saizan> adnap: if you have old .hi files around in the source tree remove them
23:25:56 <adnap> Saizan: I don't really know.  Aren't the source trees in my .cabal directory or something?  Shouldn't cabal clean them out?
23:26:17 <earthy> adnap: no
23:26:35 <earthy> (the .hi files I'd expect in the dist/build dir though)
23:26:42 <Saizan> adnap: i mean for the program that you're compiling with ghc directly
23:26:45 <adnap> Oh
23:26:55 <adnap> How can I clean them out automatically?
23:27:30 <Saizan> find . -name "*.hi" | xargs rm
23:27:35 <earthy> find srcdir -name '*.hi' -print0 | xargs -0 rm
23:27:41 <adnap> lol
23:28:00 <Saizan> or maybe passing -fforce-recomp to ghc would also do
23:28:01 <adnap> No one has done this before?
23:28:30 <adnap> It just seems strange since, if this happens to anyone who unregisters a package, they have to follow this process.
23:28:43 <turiya> how do i wait for a thread to complete its operation?
23:29:04 <Saizan> it doesn't happen to anyone that unregisters a package, and what's the problem with using standard unix utilities to deal with files?:)
23:29:39 <adnap> Saizan: Nothing except that I have to remember to do that everytime I have the problem.
23:29:52 <adnap> Saizan: Why did it happen to me if it doesn't happen to everyone?
23:29:59 <Saizan> adnap: did it fix the problem, btw?
23:30:15 <adnap> Saizan: Why would I have old .hi files if I did ghc-pkg unregister
23:30:31 <earthy> unregister does not remove the package
23:30:38 <adnap> earthy: What does?
23:30:40 <earthy> only the reference to it from the packages list
23:30:42 <Saizan> ...
23:30:53 <Saizan> i'm not talking about the .hi files of the package.
23:31:06 <adnap> So "uninstall" and "unregister" are not synonymous?
23:31:21 <earthy> however, if you still have references to the package in other files (e.g. the .hi files of a source tree) then it will still be found
23:31:26 <adnap> Saizan: What are you talking about?
23:31:27 <earthy> adnap: no
23:31:32 <Saizan> also, you still haven't answered me about wheter you still get the same error as before.
23:31:47 <adnap> Saizan: Of course because I haven't removed the .hi files yet.
23:31:48 <Saizan> you could show your current error, if you can't tell
23:32:07 <Saizan> adnap: as before you unregistered array-0.3.0.0
23:32:16 <adnap> Saizan: Right
23:32:26 <Saizan> *0.3.0.1
23:32:36 <adnap> Saizan: So, did that DELETE everything assoicated with that package?
23:32:44 <Saizan> adnap: what does "ghc-pkg list array" shows?
23:32:45 * cozachk1 gives two adnap two blackeyes and covers his face in white powder 
23:32:56 <adnap> ?
23:33:13 <Saizan> adnap: what's the output of "ghc-pkg list array" on your machine?
23:33:21 <cozachk> > reverse "adnap" -- :-D 
23:33:22 <lambdabot>   "panda"
23:33:52 * hackagebot gmndl 0.3 - Mandelbrot Set explorer using GTK  http://hackage.haskell.org/package/gmndl-0.3 (ClaudeHeilandAllen)
23:34:24 <ClaudiusMaximus> screenshot: http://claudiusmaximus.goto10.org/g/mandelbrot/gmndl-0.3.png
23:35:02 <adnap> Saizan: Ah, it's too late.
23:35:58 <Saizan> adnap: ?
23:36:41 <ClaudiusMaximus> turiya: create an empty MVar before starting the thread, when the thread is done make it write to the MVar, meanwhile the parent waits for the MVar to be filled
23:36:55 <adnap> Saizan: Argh, one sec.
23:37:27 <turiya> ClaudiusMaximus: thanks, just referred to that concept in the docs
23:38:27 <adnap> Saizan: I installed a newer version of the package that exposed an old version of the other package, and now everything works and I can't reproduce the error.
23:39:21 <adnap> Saizan: What's weirder is that the new version of the package depends on array-0.3.0.1, but when I unregister that pakcage so that ghc-pkg list array only shows 0.3.0.0, ghc --make still works.
23:39:53 <Saizan> adnap: so you use --force? otherwise it won't get unregistered.
23:40:18 <Saizan> i'm skeptic about the fact that you managed to unregister 0.3.0.1 the first time.
23:40:45 <adnap> Saizan: It says unregistering the new array will break my other package.
23:40:54 <adnap> Saizan: The new version of it, that is.,
23:41:36 <adnap> Saizan: I can't reproduce the old error I had because I don't know what version of the package I used to have.
23:42:04 <adnap> Saizan: Doing ghc-pkg list doesn't give me the old package.
23:56:12 <Saizan> adnap: what it says that unregistering foo will break other packages it's aborting the unregistration of foo
23:56:27 <Saizan> no wonder that everything stays the same :)
23:58:24 <dropdriv1> Is there a recommended way of calling Haskell from Python?
23:59:59 * hackagebot text-icu 0.6.2.1 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.6.2.1 (BryanOSullivan)
