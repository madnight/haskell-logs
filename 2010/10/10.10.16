00:00:24 <dobblego> heh
00:00:34 <SubStack> well it is just the pointfree of \x y z -> x * 2 + z * z + x
00:00:41 <mjrosenb> kwuxalot: i use ghci from within emacs.  i hit ^C ^C.
00:00:46 <shachaf> SubStack: Well, why are you writing it the hard way?
00:00:48 <kwuxalot> mjrosenb: I use vim
00:01:13 <shachaf> @google haskell vim
00:01:14 <lambdabot> http://projects.haskell.org/haskellmode-vim/
00:01:14 <lambdabot> Title: Haskell mode for Vim
00:01:16 <Maxdamantus> > (a, b) = fix id in 42
00:01:17 <lambdabot>   <no location info>: parse error on input `='
00:01:23 <Maxdamantus> > let (a, b) = fix id in 42
00:01:24 <lambdabot>   42
00:01:26 <ski> (mjrosenb : .. i hope you saw the analogy with the `data' declaration)
00:01:32 <shachaf> SubStack: Why are you writing it the point-free way, then?
00:01:47 <mjrosenb> kwuxalot: i'd recommend installing emacs
00:01:51 <mjrosenb> kwuxalot: :-p
00:02:11 <kwuxalot> mjrosenb: I switched to vim from emacs about 8 years ago
00:02:40 <kwuxalot> mjrosenb: have there been any significant improvements since then?
00:03:12 <Maxdamantus> emacs seems rather annoying with its use of key combos for navigating, in a text editor :\
00:03:31 <Maxdamantus> It's like text editing with the commandability of a window manager.
00:03:32 <lispy> Maxdamantus: you can change them
00:03:34 <kwuxalot> Maxdamantus: you do know of course that there's emacs mode for vi, and vi mode for emacs, right?
00:03:52 <mjrosenb> Maxdamantus: i agree.  perhaps you need a better window manager?
00:03:57 <Maxdamantus> kwuxalot: hm. I knew the former, but not the latter. Though that could've been guessed.
00:04:08 <marbles> mjrosenb: people seem to like xmonad.
00:04:16 <Maxdamantus> mjrosenb: eh? WM commands should only be invoked using combo keys imo
00:04:21 <kwuxalot> You can pry sawfish from my cold dead fingers
00:04:35 <Maxdamantus> unless there's some sort of "command mode" like in vim
00:04:35 <kwuxalot> I tried xmonad for a day
00:04:36 * mjrosenb forgot the :-p there.
00:05:50 * Maxdamantus uses xmonad on his netbook, but hasn't bothered switching from awesome on his main computer yet
00:06:51 <marbles> awesome is nice, also.
00:06:59 * shachaf uses xmonad on his other computers, but hasn't bothered switching from... Metacity... On his main computer yet.
00:07:16 <shachaf> (Note that by "other" I mean "dead".)
00:07:16 <arcatan> i used to use xmonad at school
00:07:19 <arcatan> it was fine
00:07:40 <Maxdamantus> Yeah, awesome's not too bad.. just not very nice configuration system
00:08:27 <Maxdamantus> and I'm worried about updating, because my video driver doesn't like Xinerama or anything else that awesome uses, so I added some hacky code to force it to thing I had two monitors.
00:10:27 <shachaf> Maxdamantus: That WM's name leads to confusion all the time.
00:10:31 <shachaf> "becuase my video driver doesn't like Xinerama or anything that awesome"
00:10:49 <Maxdamantus> Heh.
00:10:53 * shachaf wonders where the "else" went.
00:11:26 * shachaf realizes that he accidentally retyped that sentence instead of copying-and-pasting, without noticing.
00:12:26 <kwuxalot> hm, you can't define multiple modules in a file, can you? :-/
00:12:32 <Maxdamantus> > ((a,b) -> 42) $ fix id
00:12:33 <lambdabot>   Pattern syntax in expression context: (a, b) -> 42
00:12:39 <Maxdamantus> > (\(a,b) -> 42) $ fix id
00:12:42 <lambdabot>   mueval-core: Time limit exceeded
00:12:50 <Maxdamantus> Hm. Interesting.
00:13:46 <Jafet> :t fix id
00:13:47 <lambdabot> forall a. a
00:13:50 <kwuxalot> I want the Foo.blah syntax that importing a qualified module gives you, but I want to cram it in to one file for hpaste
00:14:05 <Jafet> > fix id :: (a, b)
00:14:08 <lambdabot>   mueval-core: Time limit exceeded
00:14:10 <Maxdamantus> So using pattern matching in a case/lambda and in a = definition are quite different
00:14:22 <kwuxalot> there's no way to do that, is there?
00:15:56 <identity> Polarina: I knew that programming contest was doomed to fail :P
00:17:22 <arcatan> kwuxalot: nope
00:19:28 <kwuxalot> arcatan: :%s/Foo./foo_/g, and c & p the defs
00:19:47 <kwuxalot> arcatan: (good enough for me)
00:20:08 <Maxdamantus> > \a -> 42 $ fix id
00:20:09 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> b)
00:20:09 <lambdabot>    arising from a use of `...
00:20:16 <Maxdamantus> > (\a -> 42) $ fix id
00:20:17 <lambdabot>   42
00:23:34 <arcatan> interesting thread on having two modules in one file: http://www.haskell.org/pipermail/haskell-cafe/2008-August/046494.html
00:23:58 <Jafet> Maxdamantus: no, they're not?
00:24:11 <Maxdamantus> Jafet: hm?
00:24:12 <Jafet> > let f (a, b) = 42 in f (fix id)
00:24:16 <lambdabot>   mueval-core: Time limit exceeded
00:24:21 <Jafet> > let f ~(a, b) = 42 in f (fix id) -- fix id isn't evaluated
00:24:22 <lambdabot>   42
00:24:31 <Maxdamantus> er, by = definition, I meant not a function
00:25:20 <Maxdamantus> Since other than typing stuff (I think), f (a, b) = 42 is just f = \(a, b) -> 42
00:27:13 <Jafet> It's merely to do with whether you try to evaluate fix id
00:33:21 <Maxdamantus> Hm. So why does it try to evaluate it when used as the applicand of (\(a,b) -> 42)?
00:33:52 <Maxdamantus> > (\~(a,b) -> 42) $ fix id
00:33:53 <lambdabot>   <no location info>: parse error on input `->'
00:34:27 <Cale> > (\ ~(a,b) -> 42) $ fix id
00:34:28 <lambdabot>   42
00:34:41 <Maxdamantus> > (\84 -> 42) 84
00:34:42 <lambdabot>   42
00:37:23 <Maxdamantus> @djinn forall a. a
00:37:24 <lambdabot> -- f cannot be realized.
00:37:44 <Maxdamantus> @djinn forall a. a -> a
00:37:44 <lambdabot> f a = a
00:37:54 <Maxdamantus> @djinn forall a, b. b -> a
00:37:55 <lambdabot> Cannot parse command
00:38:04 <Maxdamantus> @djinn forall a. forall b. b -> a
00:38:04 <lambdabot> -- f cannot be realized.
00:38:22 <Maxdamantus> @djinn forall a. b -> a
00:38:22 <lambdabot> -- f cannot be realized.
00:38:39 <Maxdamantus> :t const $ fix id
00:38:40 <lambdabot> forall b a. b -> a
00:38:50 <Maxdamantus> @djinn forall a b. b -> a
00:38:51 <lambdabot> -- f cannot be realized.
01:00:35 <zenzike1> Hey all. I'd like to benchmark a function of type ([Int], [Int]) -> [Int] -> Maybe ([Int], [Int]). In criterion, I think I need to use whnf to get accurate results, does this mean that I should set up my benchmarks to fill in the first argument of this function? Does partial evaluation make my benchmark meaningless?
01:03:34 <Cale> zenzike1: I'm less familiar with the details of criterion than I should be, but evaluating only into weak head normal form would be meaningful -- it would measure the amount of time it takes the function to decide if it is producing something constructed with Nothing or Just
01:03:53 <Cale> (but not necessarily the time needed to compute the contents of the Just, in those cases)
01:04:38 <zenzike1> How does it work with the presence of implicit shortcutting? for example, if the result might be determined by the first argument alone?
01:04:47 <zenzike1> *i meant short circuiting
01:22:51 * hackagebot DocTest 0.1.0 - Test interactive Haskell examples  http://hackage.haskell.org/package/DocTest-0.1.0 (SimonHengel)
01:27:20 <cch> I am installing cairo package via cabal, which complains setup: gtk2hsC2hs is required but it could not be found. any suggestions ? thanks
01:31:34 <gio1232> hi is anybody familier with automatas
01:31:34 <gio1232> ?
01:31:41 <gio1232> DFA
01:31:43 <gio1232> NFA
01:31:43 <gio1232> ?
01:43:38 <cch> cairo installation problem solved : install gtk2hs-buildtools first. thanks
01:45:11 <mux> if I don't see any signals listed for an object in gtk2hs, does it mean I should use connectGeneric? I tried to do that to attach to the "toggled" signal of CheckMenuItem but get a segfault when it's fired...
01:47:00 * hackagebot data-category 0.3.0 - Restricted categories  http://hackage.haskell.org/package/data-category-0.3.0 (SjoerdVisscher)
02:30:03 * ManateeLazyCat pasted "Get file permission with UNIX style. :)" at http://paste2.org/get/1039831
02:30:04 <ManateeLazyCat> Enjoy! :)
02:31:39 <mux> oh, I actually needed to accept (and ignore) a parameter in my callback with connectGeneric
02:32:09 <ManateeLazyCat> Save http://paste2.org/get/1039831 as File.chs and add 'c2hs' in field "build-tools" of your cabal file, then you can use getFilePermission :) 
02:33:04 <siracusa> Why is cabal trying to reinstall packages, it says `regex-posix-0.72.0.3 (reinstall) changes: regex-base-0.72.0.2 -> 0.93.2'?
02:38:50 <spetrea-home> ManateeLazyCat: :)
02:40:06 <ManateeLazyCat> spetrea-home: Hi . :)
02:40:24 <ManateeLazyCat> spetrea-home: We seen before or just hello ? ;p
02:45:54 <spetrea-home> ManateeLazyCat: yeah, you told me the meaning of your nickname
02:47:37 <ManateeLazyCat> spetrea-home: Sorry, too many nick i can't remember. :)
02:48:28 <therp> so, what's the meaning of your nick then? :) 
02:49:11 <ManateeLazyCat> therp: In real world, everybody call me LazyCat, and call my girl Manatee. (In Chinese). :)
02:50:54 <therp> I wonder how one would end up with the real-life nick "lazy cat" :)
02:59:56 <writer> Too much of haskell, I guess :)
03:01:05 <spetrea-home> too much of one thing good fo nothin
03:01:11 <spetrea-home> -- bob marley
03:36:08 <mreh> is System.Random mentioned in the haskel spec?
03:37:14 <mreh> I ask because I can't remember the semantics of split
03:37:34 <mreh> are the two new gens distinct from the original?
03:39:17 <mreh> found it
03:56:15 <bastl> hello, can someone help with installing ghc into user-space on a remote machine? I installed ghc-6.12.3 from tmp to $HOME. But now I dont have cabal :-/
03:57:09 <megajosh2> You mean cabal-install?
03:57:11 <adimit> bastl: do you mean cabal install? You can download that separately
03:58:14 <bastl> well in fact it is part of the Haskell-platform. but that doesnt want to install because it misses happy ...
03:58:31 <megajosh2> Oh, so you're installing from the Haskell platform
03:58:43 <adimit> don't we all miss happy?
03:58:50 <megajosh2> Haven't done that myself, so I'm not sure what you'd do there
03:59:37 <megajosh2> Hey, what do I do to get Haddock documentation for an already-installed library from Cabal?
03:59:50 <jamy> happy - this is a program, so write "happy"
04:00:03 <megajosh2> Do I have to go untar the package and run `cabal haddock'?
04:00:59 <megajosh2> This was globally installed, if that would change anything
04:30:05 <Sadache> have anyone tried to compile a haskell program for an IPhone?
04:31:00 <Lemmih> http://www.haskell.org/haskellwiki/IPhone
04:44:51 <Sadache> seems no one there to answer
04:46:14 <siracusa> Sadache: You missed that: [13:30:37]  <Lemmih>  http://www.haskell.org/haskellwiki/IPhone
04:47:25 <Sadache> oh yeah i did
04:47:31 <Sadache> thanks siracusa 
04:47:59 <bastl> Why is darcs.haskell.org so slow? http download is only at 500K/s ... Are there mirrors somewhere ?
04:50:54 <adimit> Does anyone know of a good example for Hexpat SAX parsing (I'm looking for an efficient/idiomatic way of building up data structures from a stream of SAX events)
04:54:35 <moosefish> I've hit the following error message changing a type from Data.Word.Word8 to Data.Int.Int8:
04:54:36 <moosefish> ThriftTest_Main.hs: Prelude.chr: bad argument: (-8)
04:54:56 <moosefish> Prelude.chr is nowhere in my code -- is there any way I can figure out who calls it and where?
04:55:10 <moosefish> Looking for imperative languages' 'backtrace' style dumps would be nice.
04:55:16 <moosefish> *looking at
04:55:44 <ezyang> adimit: If Google doesn't find you any, try looking at the hexpat source code for an examples directory of some sort. 
04:56:00 <sipa> moosefish: how do you convert it?
04:56:21 <ezyang> moosefish: Due to laziness, the current execution trace won't even necessarily be correlated with who originally called chr. 
04:56:23 <adimit> ezyang: google'd already, to no avail. But I'll see if there's stuff in the source tree, thanks.
04:56:33 <moosefish> Thrift is a RPC-system/generator -- so I just changed it everywhere in the source, and _thought_ I had caught all the functions that made sense
04:56:46 <moosefish> The fact that it compiles without warnings worries me a fair bit
04:57:17 <ezyang> moosefish: I'd probably try to triangulate the error by forcing strictness and adding debug statements. 
04:57:39 <moosefish> ezyang: Yeah, I know it might not be correlated -- it'd still be nice to be able to find some call graph or w\e else
04:57:43 <zygoloid> moosefish: yeah, chr (and more generally toEnum) is partial ;(
04:58:12 <moosefish> ezyang: Can you describe this a bit more?
04:58:23 <adimit> ezyang: bah, SAX isn't even used in the test suite :-|
04:58:51 <zygoloid> moosefish: i'd guess that some code is assuming that whatever value you changed from Word8 to Int8 can be converted to a Char
04:58:52 <adimit> I'd use the DOM interface, but it has a substantial memory leak.
04:58:54 <ezyang> moosefish: If you have code to post, I can give specific examples. 
04:59:08 <ezyang> adimit: How do you know it even works,then? :-) 
04:59:56 <adimit> ezyang: the SAX interface? I've used it. Awkwardly though. Lots of small functions and case distinctions. I'm used to HaXml :-|
05:00:01 <moosefish> ezyang: http://svn.apache.org/viewvc/incubator/thrift/trunk/test/hs/ThriftTest_Main.hs?revision=1004861&view=markup
05:00:38 <moosefish> line 169 is the outermost call that cause trouble -- somewhere deep inside there's a call to Prelude.chr that blows up
05:01:24 <ezyang> Good, so you've already triangulated it. 
05:01:26 <moosefish> ThriftTest_Main.hs is a unittest -- an RPC test that in a single process calls itself through a TCP socket. Client.testByte is the function that checks that it encodes and decodes a byte as expected
05:01:29 <ezyang> Well, it seems pretty obvious what's going on there... 
05:01:45 <ezyang> -8 is not a valid byte... 
05:01:48 <moosefish> Actually, it is
05:01:57 <moosefish> in thrift terms, a byte is a signed 8 bit qty
05:02:10 <ezyang> Well, it sounds like the cast is not being done. 
05:02:16 <moosefish> I made the same mistake for version 0.5, and converted their use of 'Int' for byte to Data.Word.Word8
05:02:21 <moosefish> And now I'm trying to fix that mistake
05:02:38 <moosefish> ezyang: What cast
05:02:39 <moosefish> ?
05:02:43 <zygoloid> moosefish: where is the code for ThriftTest_Client?
05:02:55 <ezyang> Show me the concrete implementation of testByte 
05:02:58 <harlekin> Is there a nice way to build up a Data.Map like type containing tupes (a, s), (a', s') with s :: Int, s' :: String for example if I know that the type of a implies the type of s?
05:03:06 <ezyang> You've already triangulated the error. Now find the relevant typeclass instance. 
05:03:07 <moosefish> zygoloid: That's where it becomes annoying -- it's autogenerated by the thrift compile
05:03:10 <harlekin> s/tupes/tuples/
05:03:17 <ezyang> You can find generate hs files in dist/build 
05:03:17 <moosefish> takes a .thrift file in, outputs hs boilerplate
05:03:22 <moosefish> (or any of another dozen languages)
05:03:23 <ezyang> (if you're using Cabal) 
05:04:04 <ktosiek> hi! I have infinite list, and I want to get all elements _until_ one that is >4000
05:04:13 <ktosiek> how can I do this?
05:04:15 <ezyang> ktosiek: takeWhile 
05:05:04 <ktosiek> ezyang: Thanks :-)
05:05:05 * ezyang is annoyed that, in the code he just wrote, half of it is devoted to UI and the other half is the actual logic. 
05:05:27 <zygoloid> ezyang: which would you expect more of?
05:05:37 <ezyang> Logic. 
05:05:55 <moosefish> zygoloid: It's not my code (originally) so I'm still trying to grasp it sometimes, and the original author believed in... terseness. Regardless: http://hpaste.org/40620/thrifttest_clienths
05:06:26 <moosefish> (Somehow I conned myself in maintaining the Haskell bindings for Thrift)
05:07:08 <ezyang> moosefish: Go find write_TestByte_args 
05:07:31 <hpc> the huge error list at the bottom is funny
05:07:40 <hpc> warning: use camel case
05:07:41 <ezyang> zygoloid: But I'm a bit of a UI nut and can't stand bad UI. 
05:07:44 <hpc> error: redundant parens
05:07:45 * zygoloid guesses it's in ThriftTest_Types
05:07:59 <moosefish> ThriftTest.hs actually
05:08:14 <ezyang> moosefish: One thing you should get used to in HAskell is debugging by reading source code. 
05:08:20 <moosefish> So, I can do the backtracking by hand -- it's a bit of a pain and my original question was -- is there a better way to do it than manually step through each line?
05:08:37 <ezyang> grep source for chr 
05:08:38 <zygoloid> ezyang: 50% ui doesn't seem so bad, if it's a sophisticated UI
05:08:48 <ezyang> zygoloid: It's just a command line interface... 
05:08:55 <moosefish> ezyang: No joy. It's not in the generated code, the helper libraries or anything else in thrift
05:09:04 <zygoloid> ... oh. sounds like you need a ui library ;)
05:09:08 <moosefish> ezyang: So it's probably in the Prelude or one of my cabal dependencies
05:09:19 <ezyang> But I spent several dozen lines trying to come up with sensible defaults handling 
05:09:30 <ezyang> Parsing is not really even the major complexity :-) 
05:09:30 <adimit> ezyang: are you spending a lot of LOC on cmdline args processing?
05:10:02 <ezyang> Only about a dozen lines. 
05:10:11 <zygoloid> moosefish: you can try to debug it in ghci; you can tell it to run with tracing and give you some sort of backgrace on the failure
05:10:17 <adimit> :-\
05:10:24 <zygoloid> moosefish: however, i've never found that to work very well at all ;(
05:11:08 <zygoloid> moosefish: i'm a bit surprised that this code is using Char at all -- it looks to be byte-orientated and has no business messing with unicode
05:11:32 <moosefish> Yeah. The haskell thrift code has loads of surprises like that.
05:12:03 <moosefish> When I first got my hands dirty, it didn't compile, tried to map all of {byte, i16, i32, i64} to Int and 'binary' to 'String' (guaranteeing corruption)
05:13:00 <moosefish> I've got it to compile and be at least usable for my needs, but I'm trying to do the right thing and fix more bugs upstream since I've probably got most context on it right now.
05:13:56 <moosefish> My understanding of this issue is that for once, the type inference system is getting in my way -- it's doing a conversion from two Integrals somewhere that it shouldn't.
05:14:08 <moosefish> (Or rather, one of the two integrals is not what I'd want it to use)
05:14:24 <ezyang> moosefish: It will never do a conversion unless you explicitly ask it to. 
05:14:29 <ezyang> This is a Good Thing™ 
05:14:37 <moosefish> Sure
05:14:55 <moosefish> fromIntegral $ fromEnum $ from... are about as magical as implicit casts in other languages
05:15:08 <moosefish> A random line from the thrift code:
05:15:09 <moosefish> getBytes i n = (toEnum $ fromIntegral $ getByte i (n-1)) `LBSChar8.cons` (getBytes i (n-1))
05:15:21 <moosefish> There's at least... what, 8 types involved here?
05:15:31 <moosefish> I can figure out maybe 2 without looking at docs
05:15:32 <ezyang> toEnum means fromIntegral must go to Int. 
05:15:33 <moosefish> Magic.
05:16:05 <ezyang> I dunno what type getByte returns but that's lib code. 
05:16:13 <moosefish> yup
05:16:18 <moosefish> getByte :: Bits a => a -> Int -> a
05:17:35 <zygoloid> moosefish: should Thrift.Protocol.writeByte and .readByte be using Int8 not Char8?
05:17:48 <moosefish> Very likely -- where do you see those two?
05:18:06 <zygoloid> lib/hs/src/Thrift/Protocol.hs
05:19:12 <moosefish> Ah, right. So that's what I've fixed in my client right now
05:19:26 <moosefish> What you're looking at is the committed code in SVN. I've got a local client with a few changes
05:19:36 <moosefish> Namely
05:19:37 <moosefish> -    writeByte   :: Transport t => a t -> Word8 -> IO ()
05:19:37 <moosefish> +    writeByte   :: Transport t => a t -> Int8 -> IO ()
05:19:44 <moosefish> and the same thing for readByte
05:19:55 <moosefish> (in Protocol.hs)
05:19:59 * ezyang still thinks using Int8 for bytes is wrong wrong wrong 
05:20:02 <zygoloid> @type BSC.cons
05:20:03 <lambdabot> Char -> BSC.ByteString -> BSC.ByteString
05:20:10 <moosefish> ezyang: It's misnamed, otherwise I agree
05:20:11 <zygoloid> ^^ this is where Char is coming from i think
05:20:18 <zygoloid> that's your LBSChar8.cons
05:20:32 <moosefish> ezyang: The thrift solution is their 'binary' type, which is equivalent to a HAskell bytestring
05:20:33 <zygoloid> (at least i think that's the same ByteString module!)
05:20:34 <McManiaC>   forall a. (Eq a, %x::Int) => a -> Int
05:20:34 <McManiaC> -- how do you read this? whats %x ?
05:21:06 <moosefish> ezyang: (I agree so much I accidentally introduced that bug when I first fixed the bindings)
05:21:17 <ezyang> McManiaC: Huh, I have no idea. 
05:21:18 <zygoloid> McManiaC: that's an old GHC extension, LinearImplicitParams
05:21:30 <zygoloid> McManiaC: modern GHCs don't even support that any more
05:21:36 <McManiaC> ok
05:21:43 <McManiaC> so I dont have to worry about it :)
05:21:51 <ezyang> McManaiC: If you're porting the code, you probably want ? instead 
05:22:13 <McManiaC> "?"
05:22:19 <McManiaC> whats that?
05:22:19 <ezyang> implicit parameters 
05:22:27 <zygoloid> McManiaC: %x is like ?x except it implicitly splits the value if it's used more than once
05:22:35 <McManiaC> I'm reading this atm: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/TypeType
05:22:52 <ezyang> Oh. That should get updated, then :-) 
05:24:07 <zygoloid> moosefish: so the LHS of `LBSChar8.cons` is :: Char, and the toEnum :: Int -> Char, so is chr.
05:24:39 <moosefish> Yeah, I concluded the same a second ago.
05:24:48 <moosefish> Gonna try to just remove Char8 and run my tests, for fun
05:25:00 <zygoloid> @type BS.cons
05:25:01 <lambdabot> Word8 -> BSC.ByteString -> BSC.ByteString
05:25:09 <zygoloid> ^^ that's the one you want, i think
05:25:29 <moosefish> Agreed.
05:26:00 <moosefish> Still kinda sad there's no better way than manually backtrack.
05:26:04 <zygoloid> > toEnum (-8) :: Word8
05:26:05 <lambdabot>   *Exception: Enum.toEnum{Word8}: tag (-8) is outside of bounds (0,255)
05:26:10 <zygoloid> moosefish: Agreed.
05:26:17 <zygoloid> ^^ it won't work, still ;(
05:26:34 <moosefish> I wonder if 'simply' dumping a call graph in graphviz' dot would be that useful
05:27:01 <zygoloid> moosefish: i've been working on a haskell debugger, but i've not got very far
05:27:19 <McManiaC> ezyang: so implicit parameters are some kind of parameters which I dont explicit pass to the function?
05:27:24 <ezyang> Yes. 
05:27:54 <zygoloid> moosefish: though actually very nearly far enough for this
05:27:54 <McManiaC> > let foo :: (?x :: Int) => Int; foo = ?x; ?x = 5 in foo
05:27:55 <lambdabot>   <no location info>: Parse error in pattern
05:28:13 <McManiaC> weird
05:28:14 <McManiaC> :D
05:29:03 <raijin> wow ghc is quite the build
05:29:37 <raijin> does anyone know of a fix for this issue : ghc-stage2: can't find a package database 
05:30:05 <McManiaC> how big is the scope of that implicit parameter? could I write, for example, a network application which always takes some "Connection", do something in main like "do con <- getConnection; let ?connection = con; rest" and then use ?connection in all of my network functions?
05:30:25 <ezyang> McManiaC: Yes. 
05:30:33 <ezyang> But it needs to be in all of their type signatures. 
05:30:45 <McManiaC> hm ok
05:30:53 <McManiaC> and this is "safe"? looks a lot like unsafePerformIO to me
05:31:07 <ddarius> @hoogle showParen
05:31:08 <lambdabot> Prelude showParen :: Bool -> ShowS -> ShowS
05:31:08 <lambdabot> Text.Show showParen :: Bool -> ShowS -> ShowS
05:31:08 <ezyang> Nope, it's all type safe. 
05:31:35 <McManiaC> what if I dont put that "let ?connection = ..." into main?
05:32:35 <ezyang> It doesn't twpecheck. 
05:33:32 <McManiaC> hm ok
05:35:56 <McManiaC> ezyang: ok, cool, I got it :)
05:37:12 <raijin> exit
05:40:06 <McManiaC> :q
05:40:54 <raijin> well my ghc built , with an eroor at the end about some package list 
05:43:05 <ezyang> Is there an easy way to turn "foo" 5 into "foo  "? 
05:43:14 <ezyang> some sort of pad function... 
05:43:40 <McManiaC> printf is your friend
05:43:41 <McManiaC> :)
05:43:58 <ezyang> bawwwl 
05:44:15 <ezyang> At least it's in base... 
05:49:31 <ddarius> > take 5 ("foo" ++ repeat ' ')
05:49:32 <lambdabot>   "foo  "
05:49:59 <ezyang> heh 
05:50:06 <ezyang> "What about right aligned?" :-) 
05:50:38 <aristid> > reverse . take 5 (reverse "foo" ++ repeat ' ')
05:50:39 <lambdabot>   Couldn't match expected type `[a]'
05:50:39 <lambdabot>         against inferred type `GHC.Types...
05:50:49 <aristid> > reverse . take 5 $ reverse "foo" ++ repeat ' '
05:50:50 <lambdabot>   "  foo"
05:51:04 <ezyang> lol. 
05:52:22 <zachk> > reverse.take 5.(++) (reverse "foo").repeat$' ' 
05:52:23 <lambdabot>   "  foo"
05:53:10 <aristid> @pl \n -> reverse.take 5.(++) (reverse "foo").repea
05:53:10 <lambdabot> const (reverse . take 5 . (reverse "foo" ++) . repea)
05:53:16 <aristid> @pl \n -> reverse.take 5.(++) (reverse "foo").repeat
05:53:16 <lambdabot> const (reverse . take 5 . (reverse "foo" ++) . repeat)
05:53:26 <aristid> @pl \n -> reverse.take n.(++) (reverse "foo").repeat
05:53:26 <lambdabot> (reverse .) . (. ((reverse "foo" ++) . repeat)) . take
05:54:45 <zachk> whats repeat repeating? 
05:55:10 <aristid> zachk: the space
05:55:17 <aristid> which is a parameter
05:55:28 <aristid> :t (reverse .) . (. ((reverse "foo" ++) . repeat)) . take
05:55:29 <lambdabot> Int -> Char -> [Char]
05:56:00 <aristid> @pl \foo n -> reverse.take n.(++) (reverse foo).repeat
05:56:01 <lambdabot> ((reverse .) .) . flip ((.) . take) . (. repeat) . (++) . reverse
05:56:49 <aristid> :t ((reverse .) .) . flip ((.) . take) . (. repeat) . (++) . reverse
05:56:50 <lambdabot> forall a. [a] -> Int -> a -> [a]
05:56:53 <ddarius> @pl \foo n -> reverse.take n.(++) (reverse foo)$repeat ' '
05:56:53 <lambdabot> flip flip (repeat ' ') . ((reverse .) .) . flip ((.) . take) . (++) . reverse
05:57:17 <ddarius> @pl \n foo -> reverse.take n.(++) (reverse foo)$repeat ' '
05:57:18 <lambdabot> flip flip (repeat ' ') . ((reverse .) .) . (. ((++) . reverse)) . (.) . take
06:02:24 <alex404> Let's say you have n list, and you want to zip the same indexed elements together via a fold. Is it ineffecient to take your lists together as a list of lists, transpose them to get your index identical lists, and folds those?
06:03:53 <zachk> it will work, if you require really faste execution though you shouldnt be using lists 
06:03:58 <zachk> fast* 
06:06:33 <alex404> zachk: Why not?
06:07:02 <zachk> looking up a list is O(n) 
06:07:17 <zygoloid> alex404: i think it should be pretty efficient
06:07:20 <zachk> arrays/vectors are O(1) for lookup 
06:07:29 <zachk> yea its fine 
06:07:50 <alex404> zygoloid: Cool.
06:08:08 <zygoloid> alex404: there's a risk of a space leak if your fold doesn't look at the entire list, though
06:08:31 <zygoloid> @src transpose
06:08:31 <lambdabot> transpose []             = []
06:08:31 <lambdabot> transpose ([]   : xss)   = transpose xss
06:08:32 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
06:08:46 <alex404> zygoloid: Because of the tranpose?
06:08:59 <zygoloid> ^^ the [t | (h:t) <- xss] will retain the entire matrix if you don't force its spine
06:09:12 <ddarius> Also, zygoloid means it should be pretty efficient for lists (i.e. there isn't a more efficient way using lists.)
06:09:29 <alex404> zygoloid: Interesting.
06:09:47 <alex404> ddarius: But what would be more efficient? This is a pretty listy thing I'm doing... is it not?
06:10:07 <alex404> ddarius: I don't see why constant time lookup would be particularly helpful
06:10:31 <ddarius> Using a two dimensional array, transpose would just be swapping arguments and even that wouldn't be necessary.
06:10:41 <ddarius> alex404: It will be reasonably efficient in absolute terms.
06:11:50 <alex404> ddarius: And I'm assuming that the more complex the fold, the less the transposition is having any effect.
06:12:09 <alex404> ddarius: So if you're doing anything heavy duty, the difference will be relatively negligable?
06:13:16 <zygoloid> the array approach might give a lower constant (though i wouldn't say that's obvious). the list-of-lists approach can in some cases run in space linear in the length of the outer list. profile it if you're concerned about speed.
06:13:38 <zygoloid> in particular, the GC time of the list-of-lists approach might be higher.
06:13:59 <alex404> zygoloid: Indeed. That's roughly what I figured.
06:14:40 <alex404> zygoloid: And if I want to be able to accomodate infinite lists, and/or (iterate tail xs), it's an effective way to go
06:14:49 <ddarius> The only expensive part of the array approach is making the array.  Otherwise, while running there will be no garbage, no or fewer pointer traversals, and, likely, much more cache coherency.
06:15:05 <alex404> ddarius: Cache coherency?
06:15:34 <alex404> ddarius: nm, I can wiki that
06:17:43 <ddarius> alex404: By "cache coherency" there I really mean spatial locality.
06:18:25 <alex404> ddarius: So, in layman's terms, a happier gc?
06:18:55 <ddarius> No.  As I said, there is no garbage.  It means fuller caches and more cache hits.  
06:19:28 <ktosiek> how to get first element of list that satisfies given requirement?
06:19:39 <ddarius> :t find
06:19:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
06:19:52 <ktosiek> and where to look for those functions?
06:20:03 <ddarius> @hoogle find
06:20:03 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
06:20:04 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
06:20:04 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
06:20:13 <ktosiek> ddarius: Not in scope: `find'
06:20:14 <zygoloid> @hoogle (a -> Bool) -> [a] -> Maybe a
06:20:14 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
06:20:15 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
06:20:15 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
06:20:17 <aristid> @index find
06:20:18 <lambdabot> Data.List
06:20:26 <ktosiek> ohh
06:20:29 <aristid> yay for @index
06:20:48 <ktosiek> thanks
06:21:07 <zygoloid> ktosiek: you can use hoogle (in a private chat with lambdabot or online or using the hoogle package on hackage) to find functions if you know what type they should have
06:21:50 <ktosiek> nice, now I'll have to learn to write types myself :-)
06:23:27 <alex404> ddarius: Ah... I think I understand a little. I'll investigate myself. Thansk for all the tips.
06:27:00 <Ergon> haskell
06:31:21 <alex404> @src sequence
06:31:22 <lambdabot> sequence []     = return []
06:31:22 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:31:22 <lambdabot> --OR
06:31:22 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
06:31:28 <Ergon> haskell
06:40:42 <nlogax> on a horse
06:40:51 <Ergon> haskell
06:46:53 <raghs> how do I use isInfixOf on getDirectoryContents to filter?
06:47:07 <Ergon> haskell
06:48:05 <raghs>  length (filterM (return $ isInfixOf ".txt.") getDirectoryContents)
06:48:11 <Ergon> haskell
06:48:34 <raghs> length (filterM (isInfixOf ".txt.") getDirectoryContents)
06:48:38 <Ergon> haskell
06:48:43 --- mode: ChanServ set +o Saizan
06:48:59 --- mode: Saizan set +q Ergon!*@*
06:48:59 <raghs> hello? anybody here??
06:49:04 <Saizan> raghs: hi
06:49:12 --- mode: Saizan set -o Saizan
06:49:37 <raghs> saizan -> any help with length (filterM (isInfixOf ".txt.") getDirectoryContents)
06:49:45 <ddarius> Quick quiz: If you had a language like Haskell but the implementation was required to be call-by-name, what would be the effect of adding mutable state to it?
06:50:08 <Saizan> raghs: liftM length (filterM (return . isInfixOf ".txt.") getDirectoryContents)
06:51:08 <dolio> Confusion.
06:51:29 <ddarius> dolio: Yes and no.
06:51:51 <Saizan> the same as working within ST and taking actions as parameters?
06:51:52 <aristid> if anybody wants a fun problem to solve (the best solution is remarkably short): give the number, as an Integer, in how many bases a given number is a palindrome
06:53:03 <ddarius> Saizan: And if every primitive took an action, in particular, if writeSTRef took two actions, what would happen?
06:58:35 <ddarius> aristid: As well as other solutions, there is an infinity of solutions since for any number n, n is a palindrome in base m > n.
06:59:30 <aristid> ddarius: that is why the solution is remarkably short.
06:59:35 <Saizan> heh, then it'd get a fresh reference to write into, which wouldn't be the same as the one a readSTRef on the same action would see, you'd have no mutability..
07:00:22 <ddarius> Saizan: Correct.
07:01:24 <aristid> ddarius: you do have to test for negative numbers though
07:08:53 <ddarius> > liftM3 (\a b c -> 4*c-2*b+a) [0,1] [0,1] [0,1]
07:08:54 <lambdabot>   [0,4,-2,2,1,5,-1,3]
07:09:09 <ddarius> > liftM3 (\a b c -> 4*a-2*b+c) [0,1] [0,1] [0,1]
07:09:09 <lambdabot>   [0,1,-2,-1,4,5,2,3]
07:09:49 <Jafet> Infinity isn't an Integer
07:10:06 <Jafet> @quote and.beyond
07:10:06 <lambdabot> identity says: "To " ++ (show $ log (2^1024)) ++ " and beyond!"
07:33:02 * hackagebot data-category 0.3.0.1 - Restricted categories  http://hackage.haskell.org/package/data-category-0.3.0.1 (SjoerdVisscher)
07:34:48 <rinzai> hi everyone
07:35:10 <rinzai> is this the best channel for noobs? or is there another one?
07:37:11 <aristid> #haskell-beginners iirc
07:37:24 <nlogax> as a noob myself, i find this channel very helpful
07:37:28 <nlogax> oh. didn't know about that one.
07:38:17 <burp> no, #haskell is fine
07:48:14 <rinzai> cool! thanks
07:55:46 <mengedej> anyone who can explain how to connect a button to a function (gtk) using buttonClicked?
07:59:10 <Lemmih> mengedej: button `onClicked` yourFunction?
08:01:10 <mengedej> Lemmih: tried that, and ghci complains about "Couldn't match expected type `IO () -> IO a'" but I don't undestand how work around that
08:06:15 <Lemmih> mengedej: What did you write, exactly?
08:08:05 <mengedej> Lemmih: buttonClicked somebutton (reDraw localBoard remoteBoard player). reDraw :: drawingArea -> drawingArea -> Player -> IO ()
08:08:48 <mengedej> Lemmih: buttonClicked :: ButtonClass self => self -> IO ()
08:08:49 <Lemmih> mengedej: Write: onClicked somebutton (reDraw ...)
08:09:33 <mengedej> Lemmih: wee!
08:10:41 <mengedej> Lemmih: do you know why buttonClicked doesn't work for me?
08:11:02 <Lemmih> mengedej: That function doesn't do what you think it does.
08:22:16 * hackagebot atomo 0.1.1 - A highly dynamic, extremely simple, very fun programming  language.  http://hackage.haskell.org/package/atomo-0.1.1 (AlexSuraci)
08:27:21 <mreh> :t lift
08:27:22 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:16:55 <monochrom> quiet time. everyone is probably enjoying haskell-cafe instead. :)
09:22:07 <ezyang> Mandlebrot's in heaven. 
09:22:49 <ezyang> (unfortunately the suffix "at least he will be when he's dead" is no longer necessary) 
09:26:21 <identity> ezyang: oh, holy shit, you weren't joking
09:26:33 <ezyang> nope :-( 
09:28:25 <identity> hmm, the lambda-case / lambda-if propsoal on cafe could be cool
09:28:41 <identity> I definitely hate using if-then-else with a passion
09:29:49 <Jafet> Unfortunately, Mandlebrot's death came at a time so as to be grossly overshadowed by that of the great mathematician Mandelbrot.
09:30:05 <ezyang> Jafet: Oops 
09:30:37 <aristid> remembering how to write Mandelbrot is easy: just write Mandel and Brot
09:31:01 <aristid> (almond bread :P)
09:31:55 <mreh> (\~(a,b) -> a) (1,2)
09:32:00 <mreh> > (\~(a,b) -> a) (1,2)
09:32:01 <lambdabot>   <no location info>: parse error on input `->'
09:32:10 <mreh> > (\ ~(a,b) -> a) (1,2)
09:32:11 <lambdabot>   1
09:32:25 <ddarius> Almond bread sounds good.
09:32:31 <aristid> > let (\~) = (+) in 1 \~ 2
09:32:32 <lambdabot>   3
09:32:49 <Jafet> Oh boy
09:33:15 <aristid> Jafet: yes, ALL the opportunities for new operators. it is amazing
09:34:03 <ezyang> oh man, we get to use backslashes. 
09:34:05 <identity> What is the purpose of ~ in the lambdas above?
09:34:35 <aristid> identity: it makes the match infallible
09:34:36 <mreh> identity: irrefutable patterns, if you're looking at what I wrote
09:34:50 <mreh> infallable?!
09:35:04 <aristid> mreh: well, irrefutable infallible, all the same :P
09:35:07 <identity> mreh: I was indeed; what does that mean? o.o
09:35:20 <mreh> identity: if the pattern doesn't match, it explodes
09:35:27 <identity> ah
09:35:45 <mreh> but it allows it to do lazy evaluation of patterns
09:35:51 <identity> > (\ ~(a, b) -> a) 1
09:35:52 <lambdabot>   1
09:35:57 <identity> wait wat
09:35:59 <identity> > (\ ~(a, b) -> a) 2
09:36:00 <lambdabot>   2
09:36:08 <identity> aah
09:36:20 <identity> > (\ ~(a, b) -> b) (undefined, 3)
09:36:21 <lambdabot>   3
09:36:41 <mreh> what the hell is going on
09:36:42 <aristid> > (\(a, b) -> (a, b)) 1
09:36:43 <lambdabot>   (1,1)
09:36:46 <aristid> there
09:36:50 <enthropy> > 1 :: (Int,Int)
09:36:51 <lambdabot>   (1,1)
09:36:52 <aristid> Num instance for (x,x)
09:36:56 <mreh> haha
09:37:00 <enthropy> > 1 :: (Int,Int,Int)
09:37:00 <aristid> Num a => Num (a, a)
09:37:01 <lambdabot>   (1,1,1)
09:37:03 <identity> aah
09:37:13 <aristid> it is slightly evil
09:37:30 <identity> Those irrefutable patterns a new feature?
09:37:44 <mreh> not recently
09:37:57 <mauke> identity: no, they're old
09:38:02 <identity> Oh.
09:41:55 <sipa> 1 :: ((Int),(Int,Int),((Int,Int),Int,Int))
09:41:57 <sipa> > 1 :: ((Int),(Int,Int),((Int,Int),Int,Int))
09:41:58 <lambdabot>   (1,(1,1),((1,1),1,1))
09:43:10 <mauke> > (1,2)*(3,4)
09:43:11 <lambdabot>   (3,8)
09:43:15 <lispy> is that a Caleskell instance?
09:43:27 <ddarius> No.
09:43:36 <mauke> lispy: what does that mean?
09:43:39 <lispy> ddarius: It's not pat of H98 is it?
09:43:58 <ddarius> lispy: No, but neither is the monad instance for (->) r.
09:44:04 <lispy> mauke: I'm just wondering where that instances of Num comes from.  Caleskell implies it's a Cale-ism in lambdabot 
09:44:19 <mreh> I'd notice that, so why do we still use Reader?
09:44:21 <mauke> not every H98 extension comes from Cale
09:44:32 * lispy nods
09:44:33 <mauke> not every module in lambdabot comes from Cale
09:44:39 <lispy> Is it part of some vector space package?
09:44:48 <ddarius> Yes.
09:54:20 <aristid> @oies 1,2,3,4,6,11,19,47,53,79,103,137,139,149,163,167,179,223
09:54:20 <lambdabot>  Strictly non-palindromic numbers: n is not palindromic in any base b with 2 ...
09:54:20 <lambdabot>  [0,1,2,3,4,6,11,19,47,53,79,103,137,139,149,163,167,179,223,263,269,283,293,...
10:03:41 <ezyang> Haskell needs an ASCII type. 
10:03:59 <mauke> is that like Word7?
10:04:29 <ezyang> Something like that. 
10:06:37 <Jafet> > filter (\n -> ap (==) reverse $ (\b -> map ((`mod`b).(div n)) $ takeWhile (<=n) $ iterate (*b) 1) [2..n-1]) [0..]
10:06:38 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
10:12:34 <aristid> Jafet: unfoldr is what i used
10:13:01 <aristid> > let rdigs b = unfoldr (\x -> if x > 0 then Just (snd &&& fst $ x `divMod` b) else Nothing); isP a b = ((==) <*> reverse) (rdigs b a) in filter (\zahl -> null $ filter (isP zahl) [2 .. zahl - 2]) [1..10000]
10:13:05 <lambdabot>   mueval-core: Time limit exceeded
10:13:10 <aristid> ah well :D
10:15:17 <aristid> > let rdigs b = unfoldr (\x -> if x > 0 then Just (snd &&& fst $ x `divMod` b) else Nothing); isP a b = ((==) <*> reverse) (rdigs b a) in filter (\zahl -> null $ filter (isP zahl) [2 .. zahl - 2]) [1..100]
10:15:18 <lambdabot>   [1,2,3,4,6,11,19,47,53,79]
10:19:27 <gareth_0> in haskell, can you make abstract data types from type synonyms, like you can in ML?
10:20:49 <aristid> gareth_0: can you explain what that means?
10:21:13 <gareth_0> like, i want an abstract tyoe that is implemented as a String
10:21:18 <monochrom> no
10:21:25 <rwbarton> with newtype, yes
10:22:09 <gareth_0> aristid, but i dont want to wrap the string in a data constructor
10:22:13 <gareth_0> thanks monochrom 
10:22:25 <gareth_0> newtype requires a data constructor, doesnt it?
10:22:31 <monochrom> yes
10:22:37 <gilaniali> I download the .dmg file for haskell, but it contains two packages, GHC and the haskell platform. which would should I install?
10:22:37 <rwbarton> syntactically yes, at run time no
10:22:46 <gareth_0> thanks
10:22:48 <Jafet> > filter (\n -> not $ any (\b -> ap (==) reverse . map ((`mod`b).(div n)) . takeWhile (<=n) $ iterate (b*) 1) [2..n-2]) [0..]
10:22:52 <lambdabot>   mueval-core: Time limit exceeded
10:23:24 <Jafet> > take 20 $ filter (\n -> not $ any (\b -> ap (==) reverse . map ((`mod`b).(div n)) . takeWhile (<=n) $ iterate (b*) 1) [2..n-2]) [0..]
10:23:25 <lambdabot>   [0,1,2,3,4,6,11,19,47,53,79,103,137,139,149,163,167,179,223,263]
10:30:31 <gilaniali> Is it possible to colorize the ghci prompt or is it just the tutorial i am using that has changed the color? I am using http://learnyouahaskell.com/ to learn haskell 
10:32:01 <Jafet> You could inject ansi terminal codes into the prompt with :set. That also sounds totally insane
10:32:37 <djahandarie> Haha
10:33:23 <gilaniali> Jafet: I cant seem to run ghci --colour, it says unrecognized flags. http://www.haskell.org/haskellwiki/GHCi_in_colour
10:33:41 <Jafet> I never knew such an option existed!
10:34:24 <Jafet> Oh, it's fairy-wish-believe
10:36:48 <thecod> the option -doesn't- exist
10:36:53 <thecod> it's a proposed extension
10:37:04 <identity> I would love ghci in color
10:37:33 <thecod> maybe soon...
10:37:56 <thecod> you can of course try the interactive Emacs mode...
10:38:04 <thecod> though it's not the same of course
10:39:44 <thecod> I have a question...
10:39:50 <megajosh2> What'd really be cool is something like DrScheme for haskell, except in the console
10:40:11 <megajosh2> Buuuuuuuut that'd be a far shot to aim for
10:40:12 <thecod> i'm trying to compile a haskell script; and i get the following error
10:40:37 <thecod> libHSrtsmain.a(Main.o): In function `main':
10:40:37 <thecod> (.text+0x6): undefined reference to `__stginit_ZCMain
10:40:49 <megajosh2> ...woah
10:40:54 <megajosh2> Some error in the linking process?
10:40:59 <thecod> ...
10:41:06 <thecod> i'm a bit of a noob
10:41:13 <megajosh2> Same here
10:41:34 <megajosh2> I got an error like that when I was trying to load code using hs-plugins
10:41:45 <megajosh2> I think you need to link some other objects in or something
10:41:48 <thecod> what are those?
10:41:50 <writer> How're you compiling (command-line) and with which version of GHC ?
10:41:56 <megajosh2> Did you try compiling with `ghc --make'?
10:42:01 <thecod> no
10:42:03 <Jafet> If drscheme met haskell, I'd need another stick of memory to run it
10:42:09 <megajosh2> :D
10:42:10 <thecod> ooh
10:42:10 <writer> :D
10:42:13 <thecod> nice
10:42:17 <thecod> sorry for the bother
10:42:29 <thecod> --make works
10:42:35 <megajosh2> Ah, alright
10:42:35 <writer> cool
10:42:52 <identity> thecod: Don't worry, it's a common error caused by the fact that most other compilers for most other languages that are popular link without some special --make switch
10:42:59 <thecod> oh
10:43:01 <thecod> thanks
10:43:34 <megajosh2> Without make and some explicit instructions to do linking, it just tries to convert to a standalone object?
10:43:41 <megajosh2> Well, convert the source code
10:44:01 <identity> Something like that, yeah, not too familiar with it
10:44:38 <mikeg> If I have two functions of (T -> IO (Maybe T)), how can I combine then with a MaybeT?
10:45:30 <megajosh2> Hmm... that'd be good to know. I haven't done anything with monad transformers yet...
10:45:37 <thecod> while i'm here, any coq fanatics in the group?
10:45:44 <megajosh2> Never heard of it
10:46:24 <thecod> Publicity time: it's a pure functional language with an incredibly rich type structure
10:46:35 <mikeg> RWH has a chapter on monad transformers, I'll look at that: http://book.realworldhaskell.org/read/monad-transformers.html
10:46:49 <thecod> the type system is so rich it allows you to state and prove propositions...
10:47:05 <identity> mikeg: Not quite sure what you mean, but the the type signature would be a -> MaybeT IO a
10:47:14 <identity> Depends on what you mean by "combine"
10:47:24 <identity> If you mean bind, then runMaybeT $ f >>= f'
10:47:45 <mikeg> Yes, that is what I mean. If either of them fail I want a Nothing value
10:48:24 <ezyang> What's the easiest (as in without external libraries) way to get the number of seconds since the Unix epoch? 
10:48:45 <identity> mikeg: Then bind it is
10:49:01 <identity> Nothing >>= f = Nothing
10:49:16 <Lemmih> ezyang: System.Posix.Time.epochTime
10:49:36 <ezyang> oh, is that nonportable? Hm. :-/ 
10:49:51 <Draconx> ezyang, anything to do with time is not portable.
10:49:57 <identity> ezyang: I think System.Time allows you to do that, which is portable afaik
10:49:58 <identity> not sure though
10:50:08 <identity> Anything that relies on the standard C library should be portable
10:50:29 <ezyang> I also don't know what the "new locale" library is; locale and new-locale don't seem to bring up anything 
10:50:38 <Draconx> identity, the C standard does not require the time function to do anything useful.
10:50:46 <identity> Draconx: Really?
10:50:57 <mikeg> I use Data.Time.Clock.POSIX.getPOSIXTime in the new time library
10:51:14 <ezyang> ok 
10:53:31 <mikeg> identity: i get an error Couldn't match expected type (Maybe T) inferred T in the second argument to bind
10:54:07 <rwbarton> You need to turn IO (Maybe T) into MaybeT IO T using the MaybeT constructor
10:54:21 <identity> ^
10:54:28 <mikeg> .. how? :D
10:54:45 <identity> mikeg: basically, change your function's type signature into "f :: a -> MaybeT IO a"
10:54:56 <identity> For all io actions, prefix them with "liftIO $"
10:55:00 <identity> (from Control.Monad.Trans)
10:55:21 <identity> :info MaybeT
10:55:26 <identity> meh
10:55:54 <rwbarton> MaybeT seems not to be in the standard libraries
10:56:07 <identity> It isn't, actually
10:56:11 <mikeg> You mean f and f' in "runMaybeT $ f >>= f'" have to have that type signature?
10:56:21 <identity> mikeg: Precisely
11:01:17 <mansour> hello all, I am trying to install yi editor on gentoo. A lot of packages are masked. Am I doing somehting wrong ? 
11:01:53 <Lemmih> mansour: It's probably easier to install it through cabal-install.
11:02:07 <mansour> ???
11:02:13 <mansour> didn't use that ? 
11:02:32 <Lemmih> mansour: cabal install yi.
11:02:58 <mansour> ok, I am reading about cabal now.
11:03:13 <mansour> it looks like another package management 
11:04:18 <Lemmih> mansour: Right.
11:04:23 <identity> mansour: except it's cooler.
11:06:04 <ostmacka> hello
11:06:15 <Lemmih> Hi.
11:06:21 <mansour> nope it's not cooler.
11:06:24 <cadabra> http://hpaste.org/40623/makerel  <- Why is the Ruby script 4x faster than ghc -02? Is it because of list strings?
11:06:46 <Lemmih> mansour: cabal-install doesn't do a lot. It basically just downloads and installs Haskell packages in the right order.
11:06:56 <Nibble> I am cooler
11:07:02 <mansour> when It's faling to install through "emerge" then it's not any cooler. Plus llearing another package management is become less interesting task 
11:07:07 <Nibble> I am the better at superlatives
11:08:00 <mansour> Lemmih: emerge installs the packages in the right order as well. 
11:08:17 <cadabra> I don't believe makeRelative does anything other than string substitut It's type is String -> String -> String.
11:09:05 <rwbarton> How do these programs take a measurable amount of time to start with?
11:09:06 <Lemmih> mansour: Right, and you should use emerge whenever possible. cabal-install is an option to use when the native package manager doesn't cut it.
11:09:15 <Jafet> And doesn't uninstall packages, or build packages correctly, or manage conflicting versions, or know that there can be more than one Haskell user on a system
11:09:59 <cadabra> rwbarton: lots of input.
11:10:20 <rwbarton> You have a bigger than 32K command line somehow?
11:10:44 <cadabra> Are you saying it's due to startup cost?
11:11:01 <cadabra> Let's try stdin instead of args then.
11:11:07 <rwbarton> No, I'm just curious what kind of times you're talking about
11:11:08 <Lemmih> mansour: cabal-install is very simple, fortunately. It doesn't manage the files once they are installed.
11:11:16 <rwbarton> like ~1 sec or ~0.01 sec?
11:11:23 <cadabra> 2 vs 8.
11:11:30 <cadabra> find . -print0 | time xargs -0 relx
11:11:59 <cadabra> About 40k paths.
11:12:43 <rwbarton> ah, ok
11:12:52 <ostmacka> could someone please help me in resolving a small function that I made? http://pastebin.com/Q3DZZu2T
11:13:08 <ostmacka> or telling me why I got an error message? thank you.
11:13:28 <dschoepe> ostmacka: you need `s instead of ´s
11:13:36 <monochrom> use ` not ´
11:13:50 <ostmacka> aaah. ok. :) Thank you.
11:14:30 <zygoloid> fwiw you don't need the parens around (negate b). function application always binds tightest in haskell.
11:14:50 <ddarius> > ord '´'
11:14:51 <lambdabot>   180
11:15:11 <ostmacka> ok
11:15:12 <mikeg> identity: rwbarton: Here's what I ended up doing (it works :), ty): x' <- runMaybeT $ (MaybeT . f $ x) >>= (MaybeT . f')
11:15:15 <ostmacka> nice to know
11:16:51 <identity> mikeg: ah, yes, that should indeed work
11:16:56 <identity> good observation
11:17:05 <arcatan> cadabra: there's makeRelativeToCurrentDirectory in System.Directory, by the way
11:17:21 <ostmacka> still doesn't work. Possible fix: add an instance declaration for (Num (Int,Int)).
11:17:43 <cadabra> arcatan: thanks!
11:17:45 <ostmacka> some kind of type error?
11:18:50 <monochrom> testFunc (0,b) = (0,0)
11:20:51 <ostmacka> aaah ofcource. :) Thank you. I don't have the eye for programming yet. I hope I will be more vigilant in the future. :P
11:21:02 <cadabra> find . | time relx. Still 4x slower in Haskell, using System.IO isEOF and getLine.
11:21:08 <ostmacka> obvious when I think about it now...
11:21:10 <ostmacka> :)
11:21:30 <mauke> <szbalint> now only Grothendieck needs to die and we'll have no great living mathematicians :(
11:22:04 <arcatan> cadabra: which version of Ruby you're using, by the way?
11:22:20 <cadabra> 1.8.7, ancient.
11:22:55 <ddarius> There are quite a few still living great mathematicians.
11:25:02 <cadabra> The ruby version even fork/execs to get pwd, because I couldn't be bothered with looking up pwd in ruby stdlib.
11:26:17 <cadabra> Although that only happens once, so it doesn't matter.
11:26:20 <raijin> how do you quit the interpreter?
11:26:27 <cadabra> Ctrl-D
11:26:38 <raijin> thanks, where are the man pages?
11:27:42 <identity> In the tubes, man
11:27:57 <raijin> ya, i hoped for a silver bullet
11:29:25 <cadabra> http://hpaste.org/paste/40623/makerel#p40626
11:32:17 <ajnsit> So I created a generic memoisation function for monadic values - http://hpaste.org/40625/generic_memoisation_for_any_mo
11:32:19 * hackagebot http-enumerator 0.2.0.2 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.2.0.2 (MichaelSnoyman)
11:32:29 <jandem> hello, any SmallCheck people here? 
11:32:29 <ajnsit> but it is not generic enough
11:33:10 <ajnsit> can I somehow memoise monadic values without knowing what the arguments are?
11:33:13 <arcatan> @pl \x -> a x >>= b
11:33:13 <lambdabot> (b =<<) . a
11:33:22 <jandem> I've this data type: data Set a = Set [a], and a list2set to turn a list into a set. But i don't know how to create a SmallCheck Serial instance for it
11:39:21 * hackagebot bf-cata 1.1 -   http://hackage.haskell.org/package/bf-cata-1.1 (ArieMiddelkoop)
11:56:00 <dmbarbour> How effective is Haskell's GC at killing threads that are waiting forever on an MVar?
11:56:18 <dons> in what sense are they waiting?
11:56:25 * hackagebot liboleg 2010.1.10.0 - An evolving collection of Oleg Kiselyov's Haskell modules  http://hackage.haskell.org/package/liboleg-2010.1.10.0 (DonaldStewart)
11:56:33 <dons> its very effective at spotting deadlock when e.g. no other thread holds the MVar
11:56:38 <Lemmih> dmbarbour: GHC is very good at killing threads that try to read from a GCed MVar.
11:56:54 <dmbarbour> Thanks.
11:56:55 <dons> well, in fact, it will prevent that statically :)
11:57:15 <dmbarbour> Yeah, they'll often be waiting on an MVar that no other thread is holding.
11:57:31 <dons> once pre major-gc a scan runs to see if a thread in the blocked queue can be made runnable, if some other thread will touch the MVar
11:57:40 <dons> if no other thread will, you'll get a nice MVar deadlock message
11:57:56 <dmbarbour> Can I catch that?
11:58:02 <dons> "they'll often be waiting on an MVar that no other thread is holding" -- that is a design bug
11:58:21 <dons> possibly, but it is a fatal concurrency bug, in my view, in your algorithm
11:58:29 <dons> consider using a Chan or some other structure
11:58:36 <dons> or a sample var?
11:58:37 <dmbarbour> A design bug, eh? I'm developing a new paradigm.
11:59:04 <dons> you can rely on the runtime to kill your program when it finds those deadlocks :)
11:59:43 <dons> however, there are perhaps more appropriate structures, e.g. SampleVars or Ports or Chans, that won't be so persnickity
12:01:19 <dmbarbour> Unfortunately, my paradigm is all about rejecting ports, chans, and shared vars. The only reason I use MVar is to wake a thread up for method calls from other threads (which schedule an event in the receiving thread), and to allow a thread to wait on a clock. 
12:01:33 <gareth_0> hi, is there a bijective map in haskell?
12:02:06 <dmbarbour> So the condition in which a thread waits indefinitely on an MVar is a common one: the other threads have dropped their callback handles.
12:03:08 <dons> dmbarbour: interesting. maybe use the underlying event IO mechanisms?
12:03:32 <dmbarbour> dons: where can I read about that?
12:04:35 <Lemmih> gareth_0: http://hackage.haskell.org/package/bimap
12:04:39 <dmbarbour> dons: I already rejected asynchronous exceptions, because those don't allow me to carefully control where a thread wakes up.
12:05:05 <dmbarbour> or otherwise might receive exception in middle of handling other events.
12:05:51 <c_wraith> you can always use block/unblock
12:06:03 <c_wraith> those exist for a reason
12:06:27 <dmbarbour> hmmm... I'll take a look at those.
12:06:40 <dons> dmbarbour: www.serpentine.com/bos/files/ghc-event-manager.pdf
12:06:51 <dons> ghc's mvars and forkIO are built on top of a epoll-based event layer
12:06:55 <dons> you can program that layer directly
12:07:59 <dmbarbour> I'll definitely look at those, then, dons.
12:10:11 <dmbarbour> Is there a Hackage repo associated with the ghc-event-manager?
12:10:43 <dons> its part of ghc 7
12:10:45 <dons> in the base library
12:12:06 <dmbarbour> Ooh. I don't think I've ever peeked into GHC's base before. I suppose it's time to do so, then.
12:12:41 <danharaj> no, do not peer beyond the veil.
12:12:44 <danharaj> You will be driven mad.
12:13:05 <monochrom> you will go bind
12:16:33 <megajosh2> > Just 5 >>= []
12:16:34 <lambdabot>   Couldn't match expected type `t -> Data.Maybe.Maybe b'
12:16:34 <lambdabot>         against infe...
12:16:43 <megajosh2> > Just 5 >>= ([])
12:16:43 <lambdabot>   Couldn't match expected type `t -> Data.Maybe.Maybe b'
12:16:44 <lambdabot>         against infe...
12:17:15 <megajosh2> > let list x = [x] in Just 5 >>= list
12:17:16 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
12:17:16 <lambdabot>         against inferred ...
12:17:26 <megajosh2> Wait that's obviously not right...
12:17:35 <c_wraith> megajosh2, you're down to only one type error now :)
12:17:40 <megajosh2> > let list x = Just [x] in Just 5 >>= list
12:17:40 <lambdabot>   Just [5]
12:17:43 <megajosh2> :D
12:17:48 <megajosh2> heh
12:17:48 <c_wraith> :t (>>=)
12:17:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:18:11 <c_wraith> Notice that there's only one m in there...  All of them need to be the same.  Maybe and [] are not :)
12:19:12 <megajosh2> > let list x = [x] in Just 5 >>= return . list
12:19:12 <lambdabot>   Just [5]
12:20:15 <megajosh2> :t []
12:20:16 <lambdabot> forall a. [a]
12:20:20 <megajosh2> :t ([])
12:20:21 <lambdabot> forall a. [a]
12:20:47 <zygoloid> :t [()]
12:20:48 <lambdabot> [()]
12:22:10 <taktoa> I'm writing a mandelbrot generating program
12:22:11 <taktoa> http://hpaste.org/40628/mandelbrot2
12:22:39 <taktoa> for some reason, it works fine unless I set the resolution above 3x3
12:22:50 <taktoa> which obviously is pretty problematic
12:23:06 <taktoa> it compiles fine
12:23:17 <taktoa> can anyone help me out here?
12:23:22 <dolio> It uses quicksort?
12:23:31 <taktoa> nah
12:23:35 <taktoa> that was left over
12:23:41 <taktoa> from something else
12:23:42 <dolio> Okay.
12:24:14 <tommd> > "ping"
12:24:15 <lambdabot>   "ping"
12:24:52 <taktoa> it hangs on resolutions above 3x3
12:25:04 <taktoa> I left it for several minutes
12:29:10 <dolio> I don't like the look of 'length . takeWhile id . map ((<2) . magnitude) . iterate (\z -> z^2 + a)'.
12:29:34 <dolio> If the iteration never exceeds 2, it won't terminate.
12:29:39 <kmc> takeWhile id . map p  ≡  takeWhile p  ?
12:29:51 <kmc> well if you don't care about the values, yes
12:30:21 <dolio> You need to insert an arbitrary cutoff somewhere.
12:30:49 <dolio> You must have been getting lucky for 3x3, with all of the points diverging.
12:31:06 <taktoa> hmm... so how would I implement this?
12:31:21 <kmc> you set a maximum number of iterations
12:31:30 <dolio> Using 'take LARGE_VALUE' somewhere.
12:31:49 <kmc> like 50 or 100
12:32:05 <taktoa> but no point will have an infinite number of iterations, correct?
12:32:09 <kmc> nope
12:32:21 <kmc> the mandelbrot set is defined as the set of points with an infinite number of iterations
12:33:00 <taktoa> ahhhh, I see
12:33:04 <dmbarbour> dons: since you're recommending I use features from GHC 7, any ideas on when it'll be released?
12:33:28 <taktoa> thanks, it works
12:37:52 <ClaudiusMaximus> taktoa: hey, i'm working on one too - first version had a thread per pixel, current version (so far unpublished) has as many threads as cores and a job queue per thread
12:38:55 <ClaudiusMaximus> taktoa: current version also uses quad-double arithmetic which is slow, and i tried unboxed tuples of unboxed doubles to speed it up but that seemed to defeat -fno-excess-precision and the output was glitchy
12:40:48 <rwbarton> BTW, magnitude from Data.Complex is quite slow because it properly handles cases where the naive definition `magnitude (a :+ b) = sqrt $ a*a + b*b` would lead to overflow.
12:41:11 <taktoa> ok, I guess I'll implement my own
12:41:59 <taktoa> that improved performance by 33%!
12:42:05 <taktoa> holy bajesus
12:42:42 <dons> dmbarbour: the RC is available, it will be stable by January. I'm not really /recommending/ ghc 7 features. More that if you're designing new concurrency mechanisms, the layer under MVars might be appropriate.
12:43:15 <taktoa> ClaudiusMaximus: I actually just made one that used 4 threads, but it was glitchy, so I'm rewriting it
12:43:50 <dmbarbour> dons: Thanks. I'll stick with MVars for now, but I've written a note that Don Stewart (that's you, right?) suggests using the layer under MVars after GHC7 is widely available.
12:46:40 <tommd> He's actually an entity representing many people named 'Don'.  Don Stewart is just one of those.
12:47:58 <c_wraith> I'm pretty sure dons doesn't know my face.  So I think I should ambush him on the street one day with requests for fixing strangeness in bytestring :)
12:48:48 <tommd> c_wraith: You mean the 'getN' function?  Good luck, I've been talking about that for a month (still need to send in a patch for it)
12:49:06 <dons> dmbarbour: well, i'm not suggesting using it. i'm suggesting being aware of it, so that if it turns out MVars are the wrong thing, you can drop down a level :)
12:49:08 <c_wraith> tommd, no, actually I mean foldr being identical to foldr'.  that is, too strict
12:49:16 <tommd> ah
12:49:18 <dons> by all means use MVars (and definitely consider forkIO/MVars over async exceptions)
12:49:46 <dmbarbour> dons: I'll definitely be aware of it. ;-)
12:50:55 <dmbarbour> I have a lot of respect for your work in the concurrency/parallelism/SIMD things.
12:51:01 <taktoa> sorry, scratch that, it improved performance by 77.64
12:51:05 <taktoa> percent
12:51:12 <megajosh2> ...WOW
12:51:49 <dolio> dons: Oh, by the way, did my message that haskell-src needs some version bumps for 7.0 ever get relayed?
12:51:52 <taktoa> before: 43948.3916 bits/second
12:52:06 <taktoa> after: 78071.5609 bits/second
13:01:37 <Tomh> hey, anyone here knows why its harder to do type inferencing if you allow method overloading?
13:04:39 <dolio> Method overloading?
13:05:15 <sipa> haskell does not have methods, and depending on your definition of overloading; it doesn't have that either
13:06:24 <alpounet> it has somehow, through typeclasses
13:07:29 <mauke> haskell totally has methods
13:08:07 <alpounet> I guess overloading here means ad-hoc polymorphism
13:08:13 <Philippa> Tomh: you mean ala C# et al? Because it makes you carry around the set of potentially-valid overloadings to type things with
13:08:35 <Tomh> I mean scala in particular
13:08:49 <Philippa> scala presumably inherits the same problems?
13:09:06 <megajosh2> @pl \e -> e a s d f
13:09:06 <lambdabot> flip (flip (flip ($ a) s) d) f
13:09:10 <Tomh> yeah it does
13:09:15 <megajosh2> Okay that is really not worth it
13:09:15 <dolio> You need something like type classes to give sensible types to overloaded functions.
13:09:34 <Tomh> dolio, I know in haskell you need to do that
13:09:39 <Philippa> dolio: some way to write a meaningful type subsuming the others, yeah
13:09:43 <dolio> You need it anywhere.
13:09:48 <dolio> Even if only internally to the compiler.
13:09:58 <Tomh> yeah probably
13:10:45 <Philippa> the alternative's the set I mentioned. You get a wonky constraint system operating on it
13:10:46 <dolio> Plus, if you aren't principled about it in the language, anything can be overloaded, so you need a type class for every function, potentially.
13:10:47 <rinzai> hi everyone, complete noob question....
13:10:59 <dolio> Or equivalent.
13:11:09 <rinzai> I'm trying to print a csv file parsed with Text.CSV
13:11:44 <Tomh> mm
13:11:55 <rinzai> parseCSVFromFile returns a IO (Either Text.ParserCombinators.Parsec.Error.ParseError CSV)
13:12:27 <Philippa> right, my set of overloadings is the equivalent - and that's the thing, you want to handle the case where not all the overloadings are valid
13:12:45 <Philippa> and it gets worse: you have one parameter to your 'type class' and one method, whose type is that parameter
13:12:57 <Philippa> there's no actual structure to hang onto, which is why you just get the set of overloadings
13:13:00 <rinzai> how can I just putStrLn this to the screen... sorry mega-basic question :-S
13:13:03 <dolio> Yep.
13:13:22 <Philippa> so suddenly, everything is qualified with all the types all the methods it uses are called at
13:13:32 <dolio> Try writing Haskell programs where every function is 'class Foo a where foo :: a', and see how fun it is.
13:13:41 <rinzai> basically, how can I go from IO ... to String (I know, if I can't grok types, I can't grok haskell :S)
13:13:48 <dolio> How many 'ambiguous overloading' errors you get. :)
13:13:59 <Philippa> rinzai: you don't, you build something :: String -> IO ...
13:14:12 <Philippa> and then you use >>= to "pass" the String from the IO String in
13:14:21 <Philippa> (or do)
13:14:36 <Tomh> so basically the limitation is that you cannot be sure which overload to use?
13:14:47 <Tomh> and that you need extra type signatures to make it work?
13:14:56 <Philippa> more or less, yes
13:15:00 <Tomh> ok cool
13:15:05 <rinzai> Philippa, cool, thanks! I'll try to do it
13:15:18 <int80_h> good day everyone
13:15:24 <mauke> rinzai: do you happen to know javascript?
13:15:45 <rinzai> mauke, yes. better than haskell ... :-)
13:16:01 <mauke> rinzai: familiar with AJAX/XMLHttpRequest?
13:16:05 <Saizan> rinzai: one way would look like "parseCSVFromFile ... >>= print"
13:16:06 <Philippa> rinzai: the easy way is like this: do l <- getLine; putStrLn l
13:16:19 <Philippa> (only you don't need to use ;, layout will do that for you)
13:16:23 <sipa> rinzai: main = do { x <- parseCSVFromFile file; case x of { Right csv -> shoz csv } }
13:16:26 <sipa> show
13:16:33 <mauke> sipa: that doesn't even typecheck
13:16:39 <Saizan> s/show/print/
13:16:51 <sipa> mauke: after Saizan's correction it does ;)
13:17:35 <rinzai> I see ...
13:17:45 <rinzai> many thanks for the useful tips everyone
13:18:05 <rinzai> starting to open the mind's eye to Haskell
13:18:12 <rinzai> ... but very slowly :-P
13:18:16 <rinzai> thanks again
13:18:28 <mauke> rinzai: are you familiar with AJAX/XMLHttpRequest?
13:18:36 <rinzai> mauke, yep
13:18:44 <mauke> this is how IO works in Haskell
13:18:48 <mauke> it's all callback-based
13:19:26 <int80_h> does anyone know of a library more mature than http-enumerator that has https support?
13:19:26 <aristid> mauke: so it's like... node.js!
13:19:47 <aristid> *buzzword*
13:19:51 <rinzai> ehehe
13:20:19 <rinzai> mauke, thanks. that gave me some food for thought
13:21:03 <mauke> rinzai: so you've got an action m and a callback f, and (m >>= f) gives you a new action that's like m but also runs f after it
13:21:33 <mauke> the difference to javascript is that you can't ever execute an action in haskell, you can just attach more callbacks
13:22:02 <rinzai> I see
13:22:19 <rinzai> according to the previous example
13:22:48 <rinzai> print would be the callback for the IO action parseFromCSVFromFile
13:22:54 <rinzai> makes more sense now
13:23:11 <mauke> yes
13:24:06 <rinzai> going to try your suggestions, thanks again everyone!
13:24:46 <mauke> hmm. the type IO Foo doesn't mean "I'm a Foo but with extra IO just to annoy you", it means "if you attach a callback to me and I ever get around to calling it, I'll pass it a Foo"
13:24:59 <mauke> thinking out loud. does that make sense?
13:25:45 <sipa> more or less
13:27:07 <megajosh2> :t forM_
13:27:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
13:27:32 <rinzai> works like a charm
13:27:52 <rinzai> (tried the parseFromCSVFile >>= print)
13:27:58 <sy> Hello, just for fun, does anyone know of a script in Haskell that backups local files?
13:28:09 <mauke> cp file file.bak?
13:28:26 <sy> mauke: In Haskell.
13:28:34 <rinzai> lol
13:28:41 <mauke> main = system "cp file file.bak"
13:28:44 <sy> lol
13:29:59 <sy> mauke: How about pushing that code to Amazon S3!! 
13:30:01 <sy> LOL
13:31:43 <aristid> sy: that would be overkill. just put it on hackage
13:32:41 <int80_h> okay, I'm going to try and use http-enumerator *gulp*
13:33:41 <tommd> int80_h: You must respond here with results.
13:33:41 <aristid> @hackage http-enumerator
13:33:42 <lambdabot> http://hackage.haskell.org/package/http-enumerator
13:33:54 <tommd> @hackage tls
13:33:54 <lambdabot> http://hackage.haskell.org/package/tls
13:34:10 <aristid> int80_h: with iteratee! :D
13:34:11 <int80_h> tommd: oh there will be results. It may result in me tearing out my hair. But there will be results.
13:34:24 <aristid> or wait
13:34:28 <int80_h> aristis: yes, a new concept for me. I hope to get your help
13:34:31 <aristid> it doesn't actually depend on iteratee
13:34:40 <tommd> No, but it does use tls, yay.
13:34:47 <int80_h> what's tls?
13:34:51 <tommd> SSL
13:34:56 <int80_h> ah yes
13:35:00 <int80_h> I need that
13:35:00 <mauke> thread local storage
13:35:08 <aristid> oh, enumerator is an alternative package to iteratee?!
13:35:10 <tommd> no, not that.  Thank god
13:35:11 <int80_h> this is the only package with any support.
13:35:30 <tommd> Because it's the only package that came out after tls
13:35:33 <int80_h> I'm goping to try and introduce haskell to my work, and this is my first chance to do it
13:35:41 <int80_h> *hoping
13:35:48 <tommd> *groping
13:35:53 <aristid> int80_h: use the curl package :P
13:35:53 <int80_h> heh heh
13:36:05 <int80_h> arisitd: that has https support?
13:36:09 <aristid> int80_h: yes.
13:36:24 <int80_h> oh sweet. I don't think anythign fancy needs to be done here
13:36:34 <int80_h> I will look into curl
13:37:16 <aristid> int80_h: download-curl might be easier to use if you don't have any fancy needs
13:37:55 <int80_h> I'm pretty sure I don't. The point of the script is to establish an ssl session, which means some parsing and cookie manipulation
13:38:17 <int80_h> the script sends something, gets something back, parses. repeat until done.
13:39:03 <int80_h> now if someone has some curl examples on a web site somewhere, I'm golden.
13:42:15 <c_wraith> download-curl is trivial.  you pass one of its functions a url, you get something back.  (what exactly you get back depends on which function you called, options include bytestring, tagsoup, etc)
13:42:32 <identity> So I just set up a new linux install; ubuntu 10.10 which is delivering ghc 6.12.1 with the haskell platform. Is there a reason for me to upgrade?
13:43:33 <c_wraith> I really don't like using system haskell on ubuntu.  It doesn't play nicely with using cabal-install.
13:43:38 <int80_h> c_wraith: thanks. trivial is great. Because a year from now when I know much more about haskell, I still may have to pass this off to another newbie for maintainence. If I can write something easy to understand for a newbie, I can get more acceptance.
13:43:39 <sy> You just reminded me that I need to reinstall Arch Linux.
13:43:45 <identity> c_wraith: How so?
13:43:56 <identity> I've used it with ubuntu before; it was leagues more enjoyable than my windows setup
13:44:17 <tommd> identity: If you're asking, then know.  If you are rather deep in the community and like to play with the type checker changes or LLVM backend of 7.0 then that might be a reason.
13:44:43 <tommd> s/know/no/  -- more coffee needed
13:44:47 <identity> Hmm, I can't say that's a major motivation
13:44:55 <tommd> identity: My point exactly.
13:45:05 <c_wraith> identity, it's got to do with the pace packages update.  They tend to be updated *far* faster than debian notices.
13:45:17 <identity> tommd: If you are the same tommd as the one on stackoverflow, I remember you mentioning that ghc 6.12.1 has problems 
13:45:25 <sy> c_wraith: Arch FTW
13:45:45 <c_wraith> If you ever report a bug, maintainers will often fix the package immediately.  And you'll never see that on ubuntu/debian.
13:45:46 <megajosh2> Yeah, high five!
13:45:52 * megajosh2 gets a handprint on the monitor
13:45:55 <tommd> identity: If I said that I mis-spoke.  It is ghc 6.12.2 that has issues.
13:45:57 <sy> lol
13:46:00 <identity> tommd: Oh!
13:46:03 <identity> that may ahve been the one
13:46:11 <tommd> identity: And yes, I am TomMD on stackoverflow.
13:46:17 <identity> What exactly are the issues, out of curiosity?
13:46:22 <identity> og 6.12.2
13:46:26 <identity> s/og/of
13:46:35 <c_wraith> several IO-related bugs
13:46:42 <int80_h> what is the difference between tls and ssl?
13:46:47 <tommd> identity: Something got screwed up in the ForeignPtr finalizing or some such.  It broke GTK2HS.
13:46:52 <identity> Oh
13:46:59 <c_wraith> int80_h, tls is one specific protocol that's part of ssl
13:47:01 <tommd> int80_h: TLS is the new standard.
13:47:10 <int80_h> I notice debian has two difference dev packages for lubcurl. one for tls and one for ssl
13:47:24 <tommd> ssl is an older version of tls.
13:47:34 <c_wraith> int80_h, one probably links to openssl, the other to gnutls
13:47:42 <sy> Wouldn't it just be better to build ghci from source than to depend on their package manager?
13:47:50 <int80_h> oh okay. I heard people throw around tls at work but never asked what they were talking about. Now I know.
13:48:02 <sipa> ssl was only a de-facto standard, tls is an ssl-based more standard protocol
13:48:05 <tommd> TLS is a hugely overused tla.
13:48:13 <c_wraith> sy: I use the linux binary install.  and I do local installs, because that makes several classes of broken package configurations impossible
13:49:07 <int80_h> we use ubuntu at work. What a pia.
13:49:21 <int80_h> I tried installing xmonad. Pow. broken.
13:49:38 <int80_h> I'm sure I can dig into it. It's prolly a path problem.
13:49:38 <sipa> ubuntu 10.04 here; using xmonad
13:49:45 <c_wraith> also, the debian/ubuntu ghc package managed to break haskelline at least once
13:50:02 <megajosh2> I oughtta make the jump to xmonad on my Arch Box
13:50:18 <tommd> That's unfortunate seeing as LambdaCalculator, one of hackages most important packages, uses haskeline
13:50:19 <megajosh2> I've used Fluxbox for over a year, but I often tile terminals with only a border decoration
13:50:55 <int80_h> sipa: did it work "out of the box"?, or did you have to troubleshoot?
13:51:05 <sy> I don't like Debian/Ubuntu anyways because of how much they over hold your hand, even in a minimal install. They tend to have many broken packages also.
13:51:57 <int80_h> I use VMs alot, never figured out how to get arch to work with xen.
13:52:01 <sipa> int80_h: in previous versions of ubuntu it was a mess (they only came with ghc 6.8 i believe)
13:52:04 <int80_h> if I could, I would use it
13:52:05 <sy> Are there any other side projects that I could work on to learn Haskell more quickly, besides trying xmonad and snap?
13:52:15 <sipa> but in 10.04 it worked out of the box
13:52:32 <megajosh2> I'm making myself an IRC bot. I don't know if that's the greatest way, but it's kinda fun
13:52:52 <int80_h> sy: some people like to implement their favorite language in haskell as a project.
13:53:17 <sipa> it's hard to implement haskell in haskell i think
13:53:22 <int80_h> like a subset of lisp, or forth
13:53:25 <sy> megajosh2: I read that Haskell + robotics fits nicely as well, in reference to bots.
13:53:26 <sipa> and it's already been done before ;)
13:53:50 <int80_h> I heard haskell had difficulty with the haskell type system.
13:54:01 <sy> int80_h: I became interested in Haskell when I saw a post on implementing Haskell inside of a Ruby/Rails app. lol
13:54:12 <Philippa> sipa: it's easier than implementing it in Java...
13:55:14 <sipa> Philippa: i'd go even further: i think it's hard to find a language in which writing a haskell implementation is easier than in haskell :)
13:55:27 <identity> Hmm -- maybet-transformers or maybet?
13:55:46 <int80_h> hey I am using base 3.x, how do I update to 4?
13:55:51 <Philippa> eh, I could probably start designing one - haskell's poor at representing relationships between algebraic datatypes still, for example
13:56:07 <Philippa> why do you care? Consider syntactic sugar...
13:56:38 <sipa> relationships between algebraid datatypes
13:56:43 <sipa> can you give an example?
13:57:23 <Philippa> "this type is that one modulo...", "this type is that one with the following extra constructors", "this type is that one with some extra decorations"
13:58:08 <sipa> ah yes; indeed
14:02:40 <sy> I can't wait till I fully "understand" Haskell. My Arch EC2 is screaming at me to login and deploy Snap.
14:09:52 <int80_h> hey he just rickrolled us!
14:12:33 <Adamant> int80_h: well, we are no strangers to love.
14:13:37 <sipa> Adamant: you know the rules
14:14:00 <Adamant> actually, no, I don't
14:18:00 <revenantphx> Er, maybe you guys know.
14:18:18 <revenantphx> What the hell is an ATM socket, and why is Java using AF_ATM instead of AF_INTER
14:18:20 <revenantphx> AF_INET*
14:18:39 <revenantphx> I'm patching code onto the front of connect(), and the sa_family is AF_ATM, and I dunno why
14:18:56 <revenantphx> Let's pretend this has is um... C code which I'm binding to haskell ¬_¬
14:19:01 <revenantphx> (to give it some relevance)
14:19:31 <megajosh2> Hmm... never heard of it myself
14:20:00 <revenantphx> I'm intercepting connect() calls (since the JVM interfaces with C down at that level) so I can proxy a certain connection.
14:20:11 <revenantphx> So ladi da di da I go, expecting a nice old sockaddr_in, but I keep getting nulls!
14:20:24 <revenantphx> So I examine the sa_family only to find... "30"... AF_ATM
14:20:25 <revenantphx> wtf
14:24:45 <sinelaw> howdy
14:38:56 <alex404> As a consequence of laziness, does 'map (foo . bar) xs' actually perform any better than 'map foo . map bar $ xs', or do they end up the same?
14:40:16 <Saizan> without optimizations the latter is going to produce intermediate cons cells that get immediately thrown away
14:40:19 <identity> alex404: I am not an expert whatsoever, but I *think* they get 'merged' into what is effectively 'map (foo.bar)'
14:40:25 <identity> or not
14:40:26 <c_wraith> alex404, laziness has nothing to do with that one.  But there's an optimization that makes them identical
14:40:32 <rwbarton> Due to laziness, they both make one pass over xs
14:40:48 <Saizan> without laziness it'd be even more wasting
14:41:06 <Saizan> since you'd have to produce the full intermediate list before starting with the map foo part
14:41:08 <rwbarton> but yes, "map foo . map bar $ xs" might create some cons cells in "map bar $ xs" which get consumed immediately by "map foo"
14:41:19 <benmachine> they're probably the same to within a constant in the presence of laziness
14:41:53 <sipa> they're the same up to at most a constant, regardless of laziness :)
14:42:15 <rwbarton> In execution time, but not in peak memory usage.
14:42:22 <benmachine> yeah that's what I was thinking
14:42:26 <sipa> ah, yes
14:42:32 <benmachine> map foo . map bar might duplicate the list in a strict language
14:42:38 <benmachine> I mean, once more than is necessary :P
14:42:41 <rwbarton> Er, they are also the same up to a constant if they're both not lazy.
14:42:52 <rwbarton> Hopefully you know what I meant though :)
14:43:19 <Saizan> alex404: anyhow, in GHC, list fusion will convert both to map (foo . bar) xs
14:43:40 <gwern> huh. Mandelbrot is dead
14:43:45 <alex404> Wow, what a chorus of answers...
14:43:53 <Saizan> contrapuntal fugues
14:44:04 <sipa> gwern: yes, he is survived by a number of smaller copies of himself
14:44:22 <gwern> sipa: but they'll never be as good as the original
14:44:29 <revenantphx> @quote fugues
14:44:29 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
14:44:38 <revenantphx> I'm so happy I got to do that <3
14:44:59 <sipa> gwern: of course, mandelbrot never was fully self-similar :)
14:46:21 <alex404> Anyway, it looks like I got my question answered 6 ways. I was just curious whether in some silly world haskell would end up traversing the list twice.
14:47:22 <alex404> What about (++). I have it marked in my head as an operation to avoid, but if you're going to traverse the list anyway, does it actually cost you anything?
14:47:41 <Twey> No
14:47:46 <Cale> alex404: xs ++ ys costs O(length xs) time to fully evaluate
14:48:14 <rwbarton> You basically pay the cost of ++ as you consume the "xs" part of xs ++ ys.
14:48:27 <Cale> As a refinement of that, it costs O(min(length xs, k)) where k is the number of cells of the resulting list that you use.
14:48:39 <Saizan> as a corollary, right nested (++) is what you need to avoid
14:48:51 <Saizan> err, left nested, sorry
14:48:52 <byorgey> alex404: the problem is when you have left-nested calls to ++, like (((xs ++ ys) ++ zs) ++ ws)
14:49:08 <byorgey> alex404: since that will unnecessarily traverse the same part of the list multiple times
14:49:39 <alex404> byorgey: What's the correct way to organize that?
14:49:49 <byorgey> xs ++ (ys ++ (zs ++ ws))
14:49:52 <Twey> But isn't ++ associative anyway?
14:50:06 <Cale> Twey: It's associative, but not when you consider performance
14:50:16 <byorgey> of course, no one would actually write either of those (and writing xs ++ ys ++ zs ++ ws is equivalent to the second)
14:50:31 <alex404> Cale: But the foldl correspons to the first, right?
14:50:33 <byorgey> but it can show up sneakily if you are using certain recursive patterns to build up a list
14:50:45 <alex404> Cale: Which is why it can give you a hit in performance from time to time
14:51:03 <byorgey> and if you care, the solution in that case is to use difference lists (which you should be able to easily google)
14:51:04 <Saizan> in fact you want to use foldr for (++)
14:51:06 <Twey> Cale: Right — I just mean that there's no reason to ever use (xs ++ ys) ++ zs (rather than xs ++ (ys ++ zs) or just xs ++ ys ++ zs)
14:51:12 <Saizan> ?src concat
14:51:12 <lambdabot> concat = foldr (++) []
14:51:25 <alex404> Right
14:51:43 <alex404> So concat on lists that you're traversing anyway doesn't really cost you anything
14:51:53 <Twey> alex404: It sort of does
14:52:06 <Twey> Hm
14:52:10 <alex404> How so?
14:52:28 <Twey> Yes, I think it adds a small constant factor to each lookup when you do eventually get around to traversing the list
14:52:51 <Twey> Since it has to check whether the current list is null yet, and if so return the next list instead
14:52:59 <alex404> Right...
14:53:23 <Twey> I guess it's probably similar to traversing the list twice overall
14:53:31 <Twey> The cost just happens at a different time
14:53:38 <alex404> Really?
14:53:42 <alex404> That seems a bit much
14:53:54 <Twey> Well, in terms of growth
14:54:03 <Twey> I don't know what the constants are like…
14:54:29 <alex404> I just don't want to have to stop using the list monad
14:54:31 <alex404> It's too much fun
14:54:47 <Twey> Just don't optimise prematurely
14:54:54 <Twey> Use your list monad
14:55:13 <Twey> If performance becomes a problem, you know where to look
14:55:16 <alex404> Indeed
14:56:29 <rwbarton> If you're going to traverse the entire list eventually, you can think of ++ as having the same cost as in a strict language (i.e., O(length xs))
14:58:16 <rwbarton> oh yeah, a single call to concat doesn't cost any extra, in that the cost is proportional to the cost of traversing the result anyways.
14:59:11 <Saizan> by that standard traversing a list twice doesn't cost any extra either
14:59:25 <Saizan> which is probably a fine standard :)
14:59:32 <rwbarton> but you still have to watch out if you have a possibly unbounded depth of concats, e.g. generated while traversing some kind of tree structure
14:59:46 <Saizan> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+concat+%3D+foldr+(%2B%2B)+[]+in+concat+[[1,2,3],[4,5,6]] <-
14:59:56 <alex404> rwbarton: Wait, why would (++) be greater than O(length xs)
15:00:18 <alex404> rwbarton: Oh, you mean as opposed to O(length zs), I guess?
15:00:32 <alex404> where zs = xs ++ ys
15:00:34 <rwbarton> It wouldn't, but it sounded like you were thinking of it as costing O(1).
15:00:47 <rwbarton> Maybe I misinterpreted
15:00:53 <alex404> rwbarton: No, I still sort of do
15:01:05 <alex404> rwbarton: I'm imaging java linked lists
15:01:28 * hackagebot xmonad-extras 0.9.1 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.9.1 (DanielSchoepe)
15:01:30 <alex404> rwbarton: And not understanding why the (++) can be O(1) in the best case
15:01:34 <rwbarton> OK, here's an example where that can go wrong
15:01:45 <alex404> err, can't be
15:01:47 <rwbarton> > let reverse [] = []; reverse (x:xs) = concat [reverse xs, [x]] in reverse [1..100]
15:01:47 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
15:01:53 <rwbarton> > let reverse [] = []; reverse (x:xs) = concat [reverse xs, [x]] in reverse [1..10000]
15:01:54 <lambdabot>   [10000,9999,9998,9997,9996,9995,9994,9993,9992,9991,9990,9989,9988,9987,998...
15:02:04 <benmachine> heh
15:02:08 <rwbarton> > let reverse [] = []; reverse (x:xs) = concat [reverse xs, [x]] in sum $ reverse [1..10000]
15:02:12 <lambdabot>   mueval-core: Time limit exceeded
15:02:21 <rwbarton> curse lazy evaluation :)
15:02:25 <benmachine> heh
15:02:37 <benmachine> wait I said that already
15:02:49 <benmachine> > sum $ [1 .. 10000]
15:02:49 <lambdabot>   50005000
15:03:23 <rwbarton> You can't ignore the costs of concat here, because there are n of them and they're each only processing n elements.
15:03:49 <alex404> Interesting...
15:04:10 <Saizan> "only"?
15:05:16 <alex404> So what exactly is causing the huge performance there?
15:05:27 <alex404> performance hit, that is
15:05:41 <osaunders> Is it feasible to have a list with members of more than one type? 
15:05:53 <rwbarton> Well first I can rewrite concat '[reverse xs, [x]]' as 'reverse xs ++ [x]' of course
15:05:59 <sipa> with existential types, i suppose you can do that
15:06:14 <sipa> encapsulated in some adt
15:06:25 <rwbarton> and now my recursion is building an expression that looks like (...(([] ++ [10000]) ++ [9999])...) ++ [1]
15:06:31 <benmachine> osaunders: generally the stuff that can be achieved with members of more than one type can be achieved in a different way with members of one type
15:06:54 <benmachine> osaunders: e.g. a list containing strings and integers could be [Either String Integer]
15:07:00 <osaunders> sipa: Yeah. I know you can use that to declare them but is it feasible? Specially what I'm getting at is: once you have this list of elements with multiple types, can you actually do anything with them?
15:07:06 <osaunders> benmachine: Yeah.
15:07:09 <rwbarton> just extracting the first element of that requires me to process all the ++s so it takes O(n) time (where here n=10000)
15:07:43 <alex404> rwbarton: Crazy. That's really good to know...
15:07:47 <rwbarton> extracting the second element requires me to process all but the first ++ so again it takes O(n-1) time, etc.
15:07:51 <osaunders> benmachine: I want to collect a bunch of functions together in a list. They all output Bool but take different first args.
15:08:09 <benmachine> osaunders: why do you want them in a list?\
15:08:22 <osaunders> benmachine: Run quickcheck against them.
15:08:34 <sipa> osaunders: well, you will need to know what type argument to pass them if you're going to do anything useful with them
15:08:53 <alex404> rwbarton: Why don't you need to evaluate the first (++) if you only want the second element? Don't you always need to begin from the first element with a list?
15:09:35 <benmachine> osaunders: I don't know much about quickcheck but I think an existential would work there
15:09:37 <osaunders> sipa: I know it will be an instance of Testable typeclass.
15:09:37 <rwbarton> @src (++)
15:09:37 <lambdabot> []     ++ ys = ys
15:09:37 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:09:37 <lambdabot> -- OR
15:09:37 <lambdabot> xs ++ ys = foldr (:) ys xs
15:10:03 <rwbarton> (++) checks whether its left operand is the empty list before producing anything
15:10:13 <rwbarton> oh
15:10:33 <alex404> rwbarton: Damn that src thing is handy...
15:10:35 <rwbarton> Sorry, if you write reverse [1..10000] !! 1, that will process all the ++s too.
15:10:46 <benmachine> alex404: it's not terribly reliable
15:10:55 <alex404> rwbarton: Right... still, it's a mess, is the point.
15:11:02 <alex404> benmachine: Thanks, good to know.
15:11:13 <benmachine> alex404: it's not "real" source, just illustrative :)
15:11:38 <sipa> osaunders: i guess it's feasible then
15:12:04 <alex404> rwbarton: So the fundamental point is that if left nested concatenations are supporting your algorithm, you're on very shaky ground.
15:12:18 <osaunders> sipa: benmachine: I don't really know how extistentials work though.
15:12:28 <rwbarton> Right.  Then you should look into difference lists like byorgey mentioned.
15:13:19 <benmachine> osaunders: it looks something like data TestablePredicate = TP (forall a. Testable a => a -> Bool)
15:13:20 <alex404> rwbarton: Indeed... this was all a bit theoretical. I'm just hacking away through the Euler Project.
15:13:26 <alex404> rwbarton: Thanks for your help.
15:13:32 <benmachine> osaunders: then you make a [TestablePredicate]
15:14:22 <benmachine> the idea behind DList is a neat trick, people should learn it for general use
15:14:23 <osaunders> benmachine: Did you mean type instead of data?
15:14:47 <benmachine> osaunders: nope
15:14:56 <osaunders> Hm.
15:14:57 <benmachine> osaunders: note the TP constructor
15:14:58 <alex404> benmachine: What is it exactly, if you don't mind explaining?
15:15:17 <benmachine> alex404: a DList is a function [a] -> [a]
15:15:40 <benmachine> alex404: the idea is you can quickly append to the end of a DList by just composing on the right
15:16:25 <alex404> benmachine: Oh cool. So the cost is only incurred when you need to finally pull the list out of the constructor?
15:16:39 <benmachine> alex404: yeah, then you apply the function to the empty list
15:16:52 <benmachine> of course you can't inspect the list at all before you do this
15:16:58 <alex404> Right.
15:17:06 <benmachine> but often you don't need to
15:17:18 <alex404> If you're just construct your log or whatever...
15:17:22 <benmachine> yeah
15:17:44 <sipa> osaunders: see http://www.haskell.org/haskellwiki/Existential_type#A_short_example
15:17:53 <alex404> Does haskell ever stop seeming like magic? Because sometimes I feel like I'm cheating on Project Euler with how simple some of the solutions are.
15:18:17 <osaunders> sipa: Thanjks
15:18:32 <aristid> alex404: yes, it can sometimes feel quite unelegant :)
15:18:32 <alex404> I imagine people doing it all in C and it would seem so horribly painful...
15:18:32 <Cale> alex404: http://hpaste.org/40629/evaluation
15:18:38 <rwbarton> The other tradeoff is that the difference list version of "let x = {- expensive computation -} in x ++ x" will compute x twice.
15:18:54 <rwbarton> But yeah, that's quite often a non-issue (or even an advantage).
15:19:44 <benmachine> alex404: clarke's third law?
15:20:00 <Cale> alex404: That should help you see why it costs O(n) per element of the resulting list when you have left-associated applications of (++)
15:20:01 <benmachine> (see: http://en.wikipedia.org/wiki/Clarke's_three_laws)
15:20:59 <alex404> Cale: Yah, that's awesome. Thanks.
15:22:30 <alex404> Cale: And sorry if I'm being dense, but just to set it in stone: If you're have a happy right nested series of (++), the cost is minimal (except in some pathalogical cases)?
15:22:41 <Cale> yes
15:22:54 <benmachine> alex404: the pathological cases are only, really really long lists
15:23:05 <Cale> The cost will be linear instead of quadratic for evaluating the whole list, and constant-time per element.
15:26:31 <alex404> So does one only really need to worry about DLists if one is doing lots and lots of relatively small concats?
15:27:01 <Cale> yeah, to the end of a list
15:27:09 <alex404> Right
15:27:14 <Cale> Though, I don't even use the DList library
15:27:24 <alex404> No?
15:27:32 <alex404> What do you use in such a situation?
15:27:37 <Cale> I just use the trick that's behind it. Replace lists [a] with functions [a] -> [a]
15:27:43 <alex404> Heh.
15:27:43 <alex404> Right.
15:27:50 <Cale> that add elements to the beginning of a list
15:28:06 <Cale> So [] becomes id, [x] becomes (x:), and (++) becomes (.)
15:29:04 <alex404> I guess it is that simple...
15:29:16 <alex404> The library is mostly just for people who can't figure that out?
15:29:28 <benmachine> the library is for convenience
15:29:33 <Cale> Mostly :)
15:29:37 <benmachine> and is arguably more explicit
15:29:44 <alex404> Fair enough.
15:29:50 <benmachine> but it's far from necessary
15:29:55 <Cale> Sometimes it's handy to have an explicit name for the type, and a suitable Monoid instance.
15:30:01 <benmachine> and the trick isn't just useful for lists
15:30:05 <benmachine> Cale: Endo :P
15:30:20 <alex404> benmachine: What's another example?
15:30:59 <benmachine> alex404: I used it a couple of times in a project of mine as sort of building an accumulator, but as a function instead of a value
15:30:59 <Cale> benmachine: Indeed
15:31:32 <benmachine> alex404: I think I was building an AST, and deciding what to put in it from the top-down as it were
15:31:40 <benmachine> (AST = abstract syntax tree)
15:31:59 <benmachine> I'd show you the code but it's one of the less legible things I've written
15:32:17 <alex404> I'll take your word for it ;)
15:32:36 <benmachine> yeah I didn't really have any *good* examples to hand >_>
15:32:51 <alex404> It's a really cute idea though. It's worth understanding.
15:33:07 <Cale> Constructing tree traversals is another place where this trick is important
15:33:20 <Cale> Because the trees just might be left-biased
15:34:09 <Cale> (and even if they're balanced it's pretty important)
15:34:21 <alex404> Indeed
15:36:08 <benmachine> (DList is a functor? I suppose it just does fromList . map f . toList)
15:36:23 <benmachine> (unless there's a clever trick I've missed)
15:37:54 <mreh> why does the context lie on the other side of the equals for "type" than newtype?
15:38:33 <alex404> benmachine: Don't ask me, but that would be pretty handy if it was effecient...
16:16:27 <McManiaC> can you do something like
16:16:34 <McManiaC> data A rec = A [rec]
16:16:44 <McManiaC> type Foo = [A A]
16:16:45 <McManiaC> ?
16:17:20 <dmwit> Looks like a kind error to me.
16:17:25 <dmwit> A :: * -> *
16:17:26 <McManiaC> sure it is
16:17:35 <dmwit> so A can't be applied to A
16:17:44 <mauke> did you mean: Fix A
16:17:49 <dmwit> yeah
16:18:01 <McManiaC> my idea is, if I add a "data B = B String" I could add a new "type Bar = [A B]"
16:18:28 <mauke> > undefined :: Mu []
16:18:29 <lambdabot>   In *Exception: Prelude.undefined
16:18:40 <sipa> yes, but in that case B has kind *; not * -> *
16:19:41 <McManiaC> mauke: Fix A?
16:19:44 <sipa> type Foo = [A (A ())] would work
16:20:04 <mauke> McManiaC: as in A (A (A (A (A ...)))))))
16:20:23 <McManiaC> mauke: is there such a "Fix" type?
16:20:25 <sipa> type Fix a = A (Fix a)
16:20:26 <sipa> ?
16:20:29 <mauke> @src Mu
16:20:29 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
16:20:30 <sipa> ow
16:20:33 <mauke> McManiaC: ^
16:20:34 <sipa> type Fix a = a (Fix a)
16:21:07 <McManiaC> sipa:  Cycle in type synonym declarations: ;)
16:21:08 <sipa> where Fix would have kind ((* -> *) -> *)
16:21:32 <sipa> McManiaC: yeah, i've no idea whether it would work in practice
16:21:37 <mauke> @kind Mu
16:21:38 <lambdabot> (* -> *) -> *
16:22:18 <sipa> aha
16:23:51 <mauke> http://blog.plover.com/prog/springschool95-2.html
16:24:22 <McManiaC> mauke: it's impossible without the newtype?
16:24:41 <dmwit> No, you could also use data. =)
16:24:52 <McManiaC> well :P
16:27:45 <Entroacceptor> what can I do about     Ambiguous module name `Control.Monad.Trans': it was found in multiple packages: monads-tf-0.1.0.0 mtl-1.1.0.2
16:28:00 <McManiaC> either hide that package
16:28:02 <Entroacceptor> can I hide that package somehow (without writing a cabal file)
16:28:05 <McManiaC> or use qualified imports
16:28:13 <McManiaC> import "mtl" Control.Monad.Trans
16:28:29 <McManiaC> ghc-pkg hide <package>
16:29:12 <McManiaC> to undo it again use "ghc-pkg expose" :)
16:30:14 <Entroacceptor> I tried that as the user, even with --user
16:30:22 <Entroacceptor> but you can't hide a system package?
16:30:30 <McManiaC> sure, just needs root
16:33:30 <Entroacceptor> mh, ok, it looks like the system one is correct, the one I got by cabal doesn't work
16:35:52 <benmachine> Entroacceptor: you can use -hide-package on the command line
16:37:15 <Entroacceptor> I should do a cabal file soon anyway..
16:37:49 <tommd> Entroacceptor: http://stackoverflow.com/questions/3918774/specifying-package-name-for-module-related-commands-in-ghci
16:38:04 <tommd> For when your in GHCi
16:38:14 <tommd> otherwise yes, cabal or other explicit ghc cli work.
16:38:27 <Entroacceptor> thank you
16:38:38 <Entroacceptor> it's so confusing when stuff suddenly breaks
16:39:01 <Entroacceptor> can't someone do some theoretical work on package management and fix it once and for all?
16:39:24 <tommd> Entroacceptor: The problem is the limitations that are imposed by the obvious fixes.
16:39:39 <tommd> Would you like to be prevented from installing packages with matching module names?
16:39:45 <tommd> That could get annoying.
16:40:55 <Entroacceptor> no, I don't want obvious fixes
16:41:13 <tommd> Non-obvious fixes that fundamentally change and improve the situation?
16:41:21 <Entroacceptor> yes!
16:41:27 <tommd> I'll put it on my list.
16:41:48 <Entroacceptor> good ;)
16:51:16 <identity> If a cabal packge depends on version 2.0 of package X, where does one specify this in the .cabal file? Build-Depends or Other-Modules?
16:53:14 <ManateeLazyCat> identity: build-depends
17:02:52 <identity> ManateeLazyCat: Thanks :P
17:03:00 <adimit> like so: build-depends: X == 2.0; or build-depends X >= 2.0
17:03:15 <identity> yeah, == 2.0 is what I need; thanks
17:03:23 <adimit> I'm too slow; I should go to bed. glad it helped.
17:38:30 <sina> hi
17:39:00 <dmwit> how
17:39:15 <sina> hmm, I'm not alone!
17:39:34 <Axman6> you're never alone!
17:39:50 <sina> where r u guys from?
17:40:20 <Axman6> i'm from Australia
17:40:38 <empt> China :)
17:40:43 <McManiaC> germany :>
17:40:46 <sina> UK here :)
17:40:49 <sipa> belgium
17:40:59 <dmwit> Libya
17:41:10 <fxr> @pl l ++ concat ls
17:41:10 <lambdabot> l ++ join ls
17:41:23 <dmwit> ?pl \l ls -> l ++ concat ls
17:41:23 <McManiaC> pretty international :)
17:41:23 <lambdabot> (. join) . (++)
17:41:31 <sina> yup!
17:41:34 <fxr> oh thanks
17:41:36 <dbelange> (.) (.)
17:41:38 <dmwit> (...okay, I lied)
17:41:59 <fxr> btw, I'm from Turkey
17:42:01 <sina> You guys all do Haskell ? :D (for fun?!!)
17:42:02 <sipa> > (.) (.)
17:42:04 <lambdabot>   Overlapping instances for GHC.Show.Show
17:42:04 <lambdabot>                              (f (a ...
17:42:07 <Axman6> hmm, sina and sipa, this could get confusing
17:42:13 <McManiaC> for fun and for money :)
17:42:24 <McManiaC> Axman6: indeed
17:42:32 <sina> can haskell be compiled to exe?
17:42:39 <McManiaC> sure
17:42:40 <Axman6> yup
17:42:47 <sina> using what compiler?
17:42:47 <sipa> affirmative
17:42:51 <Axman6> ghc
17:42:52 <sipa> ghc
17:42:55 <OscarZ> to experienced haskell programmers.. are there any things that you miss from imperative languages? are there some common tasks that are especially awkward to program functionally? 
17:43:07 <empt> I have just started learning it since I should have learned it 15 years ago :(
17:43:15 <sina> @oscarZ yeah. you don't have variables :D:P
17:43:16 <lambdabot> Unknown command, try @list
17:43:25 <mauke> OscarZ: Haskell is an imperative language
17:43:32 <Axman6> OscarZ: i found writing heapsort very cumbersome...
17:43:41 <Adamant> dmwit: how are the PIRA camps down in ol' Tripoli these days?
17:43:47 <OscarZ> mauke: how come? :)
17:43:49 <empt> I miss IDE since I am Smalltalker
17:43:49 <mauke> OscarZ: I can write C in Haskell
17:43:56 <McManiaC> OscarZ: very imperative, indeed
17:43:58 <mauke> down to pointer arithmetic and everything
17:44:00 <McManiaC> if you want to
17:44:00 <Axman6> empt: cheak out leksah
17:44:13 <sina> how to write C in haskell ? :D
17:44:18 <Axman6> using IO
17:44:20 <Adamant> you can do it
17:44:22 <Adamant> yes
17:44:24 <Axman6> and IORefs
17:44:28 <Axman6> and Ptr's
17:44:29 <ddarius> peek nullPtr
17:44:41 <sipa> > nullPtr
17:44:42 <lambdabot>   Not in scope: `nullPtr'
17:45:23 <sina> I just know as much as writing functions. need to study IO,...
17:45:41 <Axman6> don't
17:45:44 <Axman6> not yet anyway
17:45:57 <sina> why?
17:46:06 <IIcke> I have been learning for a while and it is being a nightmare, although a kinda fun nightmare
17:46:16 <drhodes> brain fog!
17:46:16 <McManiaC> you can even write C-look-alike code without IO
17:46:17 <empt> Axman6: yes I like leksah and wish it a little mature
17:46:21 <Axman6> you should learn haskell by avoiding IO initially, al thew most important concepts in haskell are in the pure code you write
17:46:29 <mauke> meh
17:46:29 <IIcke> sina, what book or tutorial are you following?
17:46:35 <mauke> learning IO is a good functional exercise
17:46:47 <sina> I'm studying haskell at the university...
17:46:50 <IIcke> ah, ok
17:46:59 <McManiaC> first few weeks?
17:47:00 <McManiaC> :D
17:47:00 <sina> I have to learn it, otherwise, its not really fun :D
17:47:17 <Axman6> sina: i'd recomenend you you try learning from a tutorial on your own, like lyah:
17:47:20 <Axman6> @where lyah
17:47:20 <lambdabot> http://www.learnyouahaskell.com/
17:47:21 <sina> I'm mostly a web programmer.
17:47:30 <sina> thanks for the link...
17:47:32 <IIcke> learn you a haskell is great
17:47:33 <Axman6> haskell has some very intere3sting web frameworks
17:47:34 <McManiaC> sina: I use haskell mostly for web programming ;)
17:47:51 <IIcke> sina, I'm a web programmer too, struggling with happstack :)
17:47:51 <Axman6> some extremely fast ones too
17:47:55 <sina> seriously?
17:47:58 <McManiaC> yeah
17:48:01 <dolio> Abandon your web programming and embrace the totally useless mathematical side of computer science.
17:48:20 <alpounet> just embrace mathematics, even better
17:48:21 <sina> how do you use haskell for web?
17:48:29 <empt> I write functional code in Smalltalk but Smalltalk is not optimized for functional programming so I searched and find Haskell
17:48:39 <McManiaC> sina: http://happstack.com http://snapframework.com http://docs.yesodweb.com/
17:49:21 <Axman6> sina: install the haskell platform first:
17:49:24 <Axman6> @where platform
17:49:24 <lambdabot> http://hackage.haskell.org/platform/
17:49:38 <Axman6> then run `cabal install happstack`
17:50:02 <sina> I have my own web server which has apache + php + ...
17:50:09 <IIcke> anyways, I think it is better to finsh learn you a haskell before starting with happstack
17:50:15 <sina> can this run together with apache?
17:50:23 <IIcke> sina, with mod proxy
17:50:29 <McManiaC> sina: haskell web apps usually dont need a webserver :)
17:50:31 <gwern> hakyll makes nice static sites, fwiw
17:50:44 <res> McManiaC: meaning?
17:50:55 <Axman6> res: they have them built in
17:50:57 <empt> McManiaC: wow
17:50:58 <McManiaC> res: at least happstack & snap (can) run their own
17:51:02 <res> ah
17:51:13 <McManiaC> dont know anything about yesod
17:51:16 <rwbarton> yesod too
17:51:26 <sina> McManiaC: they don't need web servers? so how to access the site then?
17:51:36 <McManiaC> sina: see above
17:51:37 <alpounet> they embed one, sina 
17:51:48 <empt> so they do need some :)
17:51:48 <res> I wasn't sure whether you mean those, or cgi programs
17:51:59 <IIcke> sina, happstack has a web server embedded, you can use it with apache if you want using mod_proxy
17:52:05 <alpounet> empt, well, they embed their own
17:52:44 <gwern> not that that is necessarily a great idea
17:52:46 <empt> yes to be sure their servers are self-supply
17:52:52 <sina> thanks guys for the nice info. it seems I can use it with shell_exec as well.
17:53:09 <empt> ye
17:53:56 <sina> why should someone use haskell ? (in the first place) :D is it quicker than C/C++ ?
17:53:59 <McManiaC> sina: join #happs or #snap if you're interested in one of these :)
17:54:03 <empt> I'd like to see leksah more mature and become a showcase of this language
17:54:41 <mauke> sina: doesn't make you want to rip your eyes out when coding
17:54:53 <McManiaC> sina: not quicker than C but easier and more powerfull to use (once, of course, you have managed to understand the syntax etc)
17:55:44 <IIcke> because it is fun and doesn't make you feel like a monkey with a keyboard
17:56:11 <sina> IIcke: do you feel like a monkey with a keyboard when programming in other languages? :D
17:56:19 <McManiaC> yes.
17:56:22 <IIcke> specially when I'm doing php, yes
17:56:25 <res> because you can think more easily
17:56:26 <Axman6> sina: because you can write fast programs in a very nice high level way
17:57:03 <sina> I like some of the stuff in Haskell. but its not really easy getting your head around doing recursion
17:57:47 <mauke> heh
17:57:56 <IIcke> nope, it is very difficult to learn it (at least it is for me), but once you get used to it, you find it easier and eventually fun
17:58:02 <mauke> are you new to this programming stuff? :-)
17:58:15 <empt> recursion is like a dog trying to catch it's own tail
17:58:36 <Axman6> sina: recursion is something all programmers should find easy
17:58:40 <mauke> recursion is like loops, only better
17:58:41 <empt> running cat :)
17:58:43 <McManiaC> recursion is nothing haskell specific btw
17:59:10 <McManiaC> can't you write recursive php functions aswell?
17:59:12 <mauke> haskell programmers don't recurse often
17:59:14 <McManiaC> i know nothing about php lol
17:59:18 <sina> I'm not new to programming. been doing it since I was 8! (Qbasic back then!) then moved to c, cpp, vb.net, php, java, now haskell :D
17:59:29 <res> empt: recursion is like a dog reproducing
17:59:31 <IIcke> I had the same feeling until I did several problems from the project euler page
17:59:41 <sina> you can do recursion in any language I guess. but in haskell there is no for, while, ...
17:59:48 <res> sina: not really
17:59:48 <empt> res: :)
17:59:52 <mauke> sina: but there is map, foldr, sequence, ...
18:00:10 <McManiaC> sina: for = flip map
18:00:10 <McManiaC> :D
18:00:10 <sipa> > forM
18:00:11 <lambdabot>   Overlapping instances for GHC.Show.Show
18:00:11 <lambdabot>                              ([a] -...
18:00:13 <res> sina: map probably does anything you want for for
18:00:16 <sina> yes, there is map and foldr. don't know about sequence
18:00:20 <sipa> :t forM
18:00:20 <Axman6> :t forM
18:00:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
18:00:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
18:00:32 <res> :t map
18:00:33 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:00:51 <IIcke> it is like wearing a corset, at the beginning is annoying, but then your tits look bigger and the world becomes a better place
18:00:57 <res> ...
18:01:00 <McManiaC> lol
18:01:06 <sina> :))
18:01:43 <res> sina: on typing: haskell will stop you from doing stupid things while not preventing you from doing stupid things
18:01:44 <Axman6> IIcke: recursion?
18:01:57 <res> Axman6: probably just haskell
18:02:30 <IIcke> Axman6, haskell, the lack of tools you are used to (loops), the types, I felt and still feel constrained, but kinda enjoying it
18:02:47 <Axman6> @remember IIcke [haskell] is like wearing a corset, at the beginning is annoying, but then your tits look bigger and the world becomes a better place
18:02:47 <lambdabot> I will remember.
18:02:56 <ddarius> "Haskell: It makes your boobs bigger."  With that and another male oriented campaign, Haskell will soon be the most popular programming language ever.
18:03:18 <sina> =)))
18:03:18 <hpc> "Haskell: It makes everyone else's boobs bigger."
18:03:25 <gwern> @flush
18:03:39 <sina> what are the best compilers and interpreters for haskell?
18:03:43 <mauke> IIcke: the trick is to use types as stepping stones platforms, not as obstacles you run into
18:03:43 <empt> The only thing fears me is the unknown time before I can be as productive as in my Smalltalk
18:03:46 <mauke> sina: ghc
18:04:00 <sina> what about winhugs?
18:04:07 <mauke> doesn't run on linux
18:04:35 <sina> what about on windows? (cause I'm on win)
18:04:43 <mauke> dunno
18:04:43 <alpounet> ghc, still
18:04:44 <McManiaC> I'm on win right now aswell
18:04:50 <alpounet> just install the haskell platform sina 
18:05:07 <hpc> GHC is the standard
18:05:08 <alpounet> you have ghc, some useful tools and libraries, without any headache
18:05:10 <sina> wanted to ask about haskell platform. will dl it right now :)
18:05:15 <hpc> there are others that implement experimental features
18:05:23 <hpc> and hugs is basically dead, i think
18:05:26 <mauke> IIcke: the real fun starts when you teleport values through the type checker
18:05:43 <sina> teleport values?
18:05:52 <res> sina: just use ghc until you have a really good reason otherwise
18:06:15 <mauke> sina: advanced magic
18:06:25 <IIcke> mauke, sure, but I just started writing real world code and then I want a string but I have a byte.lazy.string.whatever... :)
18:06:30 <McManiaC> mauke: teleport values? :P
18:06:37 <mauke> McManiaC: implicit configurations
18:06:39 <res> IIcke: unpack
18:06:51 <sina> haskell platform is 74 megs!! wow
18:06:52 <mauke> IIcke: so convert
18:06:59 <ddarius> @hoogle ByteString -> String
18:07:00 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
18:07:00 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
18:07:00 <lambdabot> Prelude show :: Show a => a -> String
18:07:01 <McManiaC> mauke: ah. didn't you explain that just today to me?
18:07:08 <mauke> McManiaC: I don't think I did
18:07:11 <res> sina: dude, that's actually fairly small
18:07:14 <McManiaC> hm then someone else did
18:07:15 <McManiaC> :D
18:07:28 <ddarius> sina: You've never downloaded the JDK?
18:07:34 <hpc> BONUS: ping
18:07:37 <McManiaC> mauke: http://npaste.de/mh/ like this?
18:07:48 <alpounet> BONUS, congrats for the book by the way
18:07:51 <IIcke> thx. I know there are ways to do the things. It is just that I don't know them yet :)
18:07:51 <res> % du --max-depth 0 -h ghc
18:07:51 <res> 1.7G	ghc
18:07:51 <sina> res and ddarius well, I'm saying compared to winhugs :D
18:07:54 <mauke> McManiaC: ew, no
18:08:00 <sina> java is different :))
18:08:03 <mauke> that uses implicit parameters
18:08:06 <res> how is java different?
18:08:27 <ddarius> sina: winhugs is a single interpreter.  The Haskell Platform is a compiler, interpreter, several tools, and many libraries.
18:08:29 <McManiaC> mauke: what is implicit configurations?
18:08:38 <hpc> BONUS: you have a grammatical error in the latest chapter: "If don't get how >>= works at this point, don't worry"
18:08:53 <sina> will be installing it in a moment :)
18:09:02 <mauke> http://okmij.org/ftp/Haskell/types.html#Prepose ... fuck, where's the first link gone?
18:09:46 <IIcke> sina, I found this guide very helpful http://stackoverflow.com/questions/1012573/how-to-learn-haskell/1016986#1016986
18:09:56 <McManiaC> sina: one thing about haskell - there is *so* much stuff to do with just the language that you almost forget to acutally programm in it from time to time :)
18:10:38 <empt> I have difficulty when first install leksah on Linux and windows, that I don't know which dir should I point to when asked for source dir
18:10:51 <sina> McManiaC: I don't understand you
18:11:20 <McManiaC> sina: soon you will if you stick to haskell :)
18:11:25 <McManiaC> :D
18:12:06 <mauke> McManiaC: hope you saw the okmij.org link above; the first link in the references is dead, but it turns out I have copies of the papers at http://mauke.ath.cx/stuff/papers/p1214-kiselyov.pdf http://mauke.ath.cx/stuff/papers/prepose.pdf
18:12:51 <sina> except "not feeling like a monkey with a keyboard", why should someone choose haskell over C# or C++ or Java? (or php for web)
18:13:08 <mauke> C++ is a cruel joke
18:13:36 <empt> do you guys prefer to use Emacs or Vim?
18:13:37 <mauke> Java is extremely annoying to program in; it's very verbose and its type system gets in the way
18:13:40 <IIcke> php... after years I'm still browsing the manual to check the order of the arguments
18:13:51 <mauke> I haven't used C#
18:13:57 <ddarius> C# is nice.
18:14:10 <res> c# is nice in theory but you can do better
18:14:14 <mauke> PHP cannot be taken seriously
18:14:17 <ddarius> res: Certainly.
18:14:25 <IIcke> well, even php creators say that the language is ugly as hell... (but it pays the bills)
18:14:30 <interferon> can i disable the "RecordName {}" syntax? (ie, can i require that record syntax always specifies all fields)
18:14:37 <identity> The author of PHP has been quoted on several occasions saying that he knows PHP is crap and so on
18:14:55 <ddarius> interferon: No.
18:14:57 <identity> IIcke: Not only ugly, but also just junk
18:15:01 <mauke> the nice thing about PHP is that it's crap on all levels
18:15:08 <mauke> design, implementation, and most code written in it
18:15:14 <sina> IIcke: same with me, but php is pretty simple, and does what you want with a simple stupid code
18:15:19 <interferon> ddarius: it's obnoxious
18:15:19 <McManiaC> mauke: hehe
18:15:35 <identity> stuff like admitting the languages had no design specification to follow; they just added the next logical step until it was a clusterf**k of stuff
18:15:40 <interferon> ddarius: The "Foo a b c" syntax doesn't let you leave out parameters, unless you specifically use undefined
18:15:40 <mauke> sina: PHP is not simple by any means
18:15:41 <res> incidentally
18:15:42 <res> http://eevee.livejournal.com/308818.html
18:15:54 <ddarius> interferon: If your fields are strict, GHC will not allow them to be left undeclared.
18:16:03 <ddarius> s/undeclared/undefined/
18:16:05 <mauke> identity: more like "they just added whatever"
18:16:09 <interferon> ddarius: col
18:16:10 <identity> mauke: hehe, yep
18:16:11 <interferon> *cool
18:16:15 <sina> mauke: isn't it?
18:16:20 <mauke> sina: hell no
18:16:38 <mauke> sina: let's try this: explain what PHP's "arrays" are and how they work
18:16:49 <sina> mauke: it is fairly easy
18:16:56 <sina> array(1,2,3)
18:17:04 <mauke> yes?
18:17:08 <sina> returns an array with 3 elements
18:17:08 <res> what does that do?
18:17:11 <gwern> res: I don't get that post. php ignores arguments if the output doesn't use them?
18:17:15 <identity> My first venture into webdev was with ASP.NET which is probably what I would choose if I had to choose a language for web dev(I don't like web dev). I tried PHP afterwards and when the urge to put my head through my monitor started rearing its ugly head I stopped using it
18:17:15 <res> how are arrays implemented
18:17:17 <sipa> but arrays can also be associative maps
18:17:20 <sina> [0] is 1, [1,] is 2 and [2] is 3
18:17:32 <sipa> and they have a notion of order
18:17:34 <sipa> and keys
18:17:35 <res> gwern: it's declared to have no arguments, but it'll silently accept three and ignore thre extra
18:17:36 <sipa> and values
18:17:47 <mauke> sina: wait, that sounds really complicated!
18:17:48 <gwern> res: oh. so it's a typing error
18:18:04 <sina> mauke have you done java or c++ ?
18:18:05 <res> gwern: note that you /can/ declare parameters and name them
18:18:08 <gwern> imo, I like php's various equality operators and their complicated behavior....
18:18:16 <mauke> sina: yes
18:18:18 <IIcke> sina, yes, php has the advantage that there are plenty of frameworks, people working with it, jobs... 
18:18:30 <res> gwern: you can have, say foo($a,$b,$c) and call foo(1,2,3)
18:18:35 <identity> sina: At least there is some consistency in C++'s design; simple concepts like arrays aren't mindbogglingly weird
18:18:43 <res> gwern: the trouble is, you don't have to use exactly three arguments
18:18:44 <IIcke> apart from that, the language makes me cry a bit from time to time, when I'm alone
18:18:49 <mauke> res: meh, javascript works the same way
18:18:56 <sipa> that's the one advantage of PHP: if you have a server that supports PHP, you know your script will probably run on it
18:19:06 <res> mauke: javascript kind of sucks, too
18:19:08 <sina> identity: right. php has no solid design. they just added more and more functions.
18:19:10 <mauke> sina: unless it relies on magic quotes being on (or off)
18:19:20 <sipa> because they combined all the crap they had into one distribution
18:19:46 <mauke> sina: what operations in PHP use an array's order, and how can you change it?
18:19:49 <sina> PHP is getting slower and slower... compared to other web languages. I think php is the slowest :D
18:20:03 <IIcke> is slower than ruby?
18:20:04 <identity> sina: Yep -- I read some post recently to which I can't find the link explaining how details like inconsistency in naming conventions and order of arguments kept polluting the standard library
18:20:09 <identity> which would annoy the hell out of me
18:20:17 <McManiaC> res: I dont understand that eevee link
18:20:17 <McManiaC> :D
18:20:24 <sina> mauke http://www.php.net/manual/en/ref.array.php
18:20:39 <mauke> what, all of those?
18:20:52 <empt> I'm a functional person :)
18:21:02 <sina> php has unlimited number of functions :D
18:21:19 <mauke> sina: that doesn't really answer my question and you forgot to mention that arrays also have a "current" element
18:21:42 <Walt> I'm a dysfunctional perso
18:21:44 <Walt> person*
18:21:59 <sina> dysfunctional person lol :D
18:22:09 <empt> :)
18:22:20 <sina> mauke : what web language you prefer then
18:22:33 <mauke> turns out PHP "arrays" are really hash tables with a doubly-linked list through the values and a pointer to some value
18:22:41 <res> McManiaC: I'll come up with a better example
18:22:45 <mauke> sina: "web language"? fuck that, I want a programming language
18:22:49 <identity> mauke: wat.
18:22:55 <mauke> identity: hmm?
18:23:01 <identity> mauke: @ php's arrays
18:23:03 <empt> can the bot search for a dictionary here? 
18:23:04 <sina> mauke: do you do web programming? cause sooner or later, everything will be web...
18:23:08 <mauke> identity: yes, that's what PHP calls arrays
18:23:16 <identity> so they're not even O(1) for lookup by index?
18:23:17 <res> why do we call them arrays?
18:23:20 <res> they're not arrays
18:23:27 <mauke> identity: hash lookup is O(1)
18:23:31 <identity> ah
18:23:34 <ddarius> res: Why does python call arrays lists?
18:23:50 <res> ddarius: arrays /are/ a sort of list
18:24:06 <mauke> sina: so far I haven't really needed to, but I've written some stuff in Perl
18:24:07 <tommd> Can you cons them without copying?
18:24:08 <identity> @oies 3, 7, 15, 1, 292, 1, 1
18:24:08 <lambdabot>  Continued fraction expansion of Pi.
18:24:08 <lambdabot>  [3,7,15,1,292,1,1,1,2,1,3,1,14,2,1,1,2,2,2,2,1,84,2,1,1,15,3,13,1,4,2,6,6,99...
18:24:12 <identity> Heh.
18:24:13 <sina> and lists are sort of arrays :D
18:24:14 <res> hash tables aren't an array unless you really stretch the idea
18:24:28 <res> sina: what lists?
18:24:34 <ddarius> res: Hash tables are closer to arrays than arrays are to lists.
18:24:49 <res> ddarius: it's not that it's closer
18:24:52 <sina> res: aren't they in general? (not considering what happens in the background!)
18:25:03 <tommd> Give some definitions of each and you might make progress in figuring out where the other person is coming from
18:25:30 <res> ddarius: a granny smith is a fruit, and a fuji is a fruit; granny smith is closer to fuji than fruit, no?
18:25:32 <empt> the names in each language differs. 
18:26:33 <sina> guys, still, why should someone do haskell? isn't Lisp better? or any other functional programming language?
18:26:53 <danharaj> that is not a very good question.
18:27:00 <ddarius> res: If you are willing to look at "list" at a conceptual level, then there is nothing about "array" that makes it not also on the conceptual level and thus you should have no complaint with sina's comment.
18:27:04 <empt> I don't know a Haskell list thing in other language
18:27:09 <tommd> sina: Perhaps you should be exploring what is different about haskell.  That question isn't very constructive.
18:27:28 <danharaj> The constructive version of that question is "what does haskell do better than other functional languages?"
18:27:42 <mauke> round 2: explain how == works in PHP. bonus question: what are the results of "0x1" == "1", "01" == "1", and "123456789012345679" == "123456789012345678"?
18:27:47 <ddarius> empt: Lisp lists are the same thing as Haskell lists, which are just singly linked lists.
18:27:49 <tommd> Or just what are some key differences.  Static types.  Type classes.  Purity...
18:28:00 <mauke> sina: lisp isn't very functional
18:28:17 <empt> ddarius: thx
18:28:18 <IIcke> sina, how long have you been doing php?
18:28:19 <sina> mauke: I dont know lisp. just heard of it
18:28:20 <tommd> empt: Adding to Lisp, Scheme lists aren't really any different than Haskell lists.
18:28:28 <zygoloid> mauke: i could be wrong but i have this vague terrifying memory that "0" == 0, but "0" != 0.0
18:28:30 <sina> IIcke: years... at least 4-5 years
18:28:31 <McManiaC> mauke: False True and error?
18:28:32 <McManiaC> :D
18:28:44 <tommd> sina: Do you know what strong static typing is?
18:28:44 <res> tommd: but you can do more things with cons cells than just make lists!
18:28:52 <empt> isn't Scheme Lisp?
18:28:57 <tommd> no
18:28:59 <McManiaC> yes
18:29:00 <res> empt: scheme is /a/ lisp
18:29:01 <sina> tommd: I guess so
18:29:07 <mauke> zygoloid, McManiaC: I don't actually know the answer and I don't have php on this machine
18:29:07 <McManiaC> there is no "lisp"
18:29:11 <tommd> It isn't traditional lisp.
18:29:18 <IIcke> sina, and you don't feel like you are producing crap most of your time? (I feel that way even trying to do the things right :P)
18:29:19 <empt> OK
18:29:21 <McManiaC> mauke: hehe I remember some of that
18:29:23 <ddarius> No Lisp is "traditional" Lisp.
18:29:25 <res> there is no lisp. there are many lisps.
18:29:37 <ddarius> Current Lisp that is.
18:29:38 <mauke> McManiaC: my guess would be False, True, True
18:29:45 <ddarius> elisp probably comes closest.
18:29:51 <McManiaC> mauke: I think "0x1" gets read as "0" because x is a char not a number, wheras "01" gets cast to 1 and 1 == 1 -> True
18:29:53 <tommd> That's more what I was thinking, yes.
18:29:55 <McManiaC> mauke: or something like that
18:29:58 <sina> IIcke: I mostly use JS, html, css to do the web part. the programming part does not take much time. and it is fairly easy.
18:30:13 <mauke> McManiaC: but why convert it to a number? I'm comparing two strings here
18:30:17 <sina> by web part, I basically meant the client-side part
18:30:19 <ManateeLazyCat> I have convert ezyang's great c2hs blog with c2hs.pdf at : https://docs.google.com/fileview?id=0B8kprmQ446Y9ZWM4ZjllMzAtNmIyYS00ZjVhLWJjOWMtZmZmYmRjMzUwNWM0&hl=zh_CN&authkey=CPe3orIE , Enjoy!
18:30:20 <McManiaC> mauke: ask php :)
18:30:31 <tommd> ManateeLazyCat++
18:30:37 <zygoloid> McManiaC: i think "0x1" == "1" is False because it does a string comparison, because the LHS isn't formatted as a number, and the others are floating-point ;)
18:31:08 <McManiaC> zygoloid: nah, I think it really converts into 0
18:31:19 <McManiaC> let me see if I have a php here...
18:31:19 <McManiaC> :D
18:31:20 <mauke> zygoloid: I'm pretty sure the floatingpointness depends on how your php was compiled (32 vs 64 bit)
18:31:24 <res> try "0x1" == 0
18:31:26 <ManateeLazyCat> tommd: That's the ezyang's "Six part intro c2hs", i just convert very part to pdf and concat them together with single fpdf file. :)
18:31:32 <zygoloid> mauke: wow.
18:31:48 <identity> oh god
18:31:48 <mauke> res: and then "0x1" == "0"
18:32:02 <IIcke> sina, ok, I code with symfony, that it is still a good framework... but, arf, it is hard to explain, but i *hate* the language itself :)
18:32:04 <identity> I now feel pity for everyone I know that does php to pay the bills
18:32:04 <sina> mauke: you are right about 32-64
18:32:20 <mauke> and this is why PHP is so simple~
18:32:26 <ManateeLazyCat> Hope that will hope people understand how to use c2hs binding C library. :)
18:32:29 <sina> IIcke: I dont use a framework. and I dont know why I should :D
18:32:33 <ManateeLazyCat> s/hope/help
18:32:43 <ManateeLazyCat> Damn elisp too slow...
18:32:51 <tommd> ManateeLazyCat: I hope it pulls people away from the evil hsc2hs.
18:33:02 <McManiaC> ` php <<< '<?php if ("0x1" == "1") echo "ok"; ?>'
18:33:03 <McManiaC> ok
18:33:13 <McManiaC> :>
18:33:18 <ManateeLazyCat> tommd: Yes, *.chs file is clearer solution. :)
18:33:21 <IIcke> sina, then you must be doing very simple webs or reinventing the wheel every day
18:33:30 <mauke> McManiaC: what
18:34:01 <res> % php <<< '<?php function foo($a) { print "$a\n"; } foo(1,2,3); ?>'  
18:34:02 <res> 1
18:34:20 <wakeupsticky_> having trouble getting haskell platform running on ubuntu
18:34:24 <identity> res: why the hell does php do that?
18:34:26 <ManateeLazyCat> tommd: BTW, i found awesome site (http://www.htm2pdf.co.uk/Default.aspx) convert web page to pdf and important is "no ad in pdf". :)
18:34:35 <identity> wakeupsticky_: the one from the repo?
18:34:38 <res> identity: stupid design?
18:34:38 <tommd> cool
18:34:52 <aristid> ManateeLazyCat: can't you use the PDF printer integrated in ubuntu?
18:34:55 <identity> res: No doubt, but what is baffling is that it is in no way logical
18:35:05 <identity> "let us allow everyone to pass as many members to functions they want"
18:35:06 <ddarius> identity: You don't want your code to stop working just because it's broken.
18:35:11 <sina> IIcke, Actually yes. both actually. I can pretty much do anything I want without any framework. although it takes time sometimes...
18:35:11 <identity> ddarius: OH!
18:35:15 <identity> I retract my former statement
18:35:22 <ManateeLazyCat> aristid: I have special tool to do that. :)
18:35:24 <wakeupsticky_> i don't even remember
18:35:39 <identity> Haskell is stupid for its type system. I want broken code to work as it's supposed to when it's not broken
18:35:52 <hpc> haha
18:35:52 <identity> wakeupsticky_: What version?
18:35:54 <mauke> identity: I have this theory that they half-copied Perl without enabling their brain first
18:35:54 <IIcke> ManateeLazyCat, I think you can use pandoc too http://johnmacfarlane.net/pandoc/
18:36:02 <identity> mauke: I thought of perl when I saw that stuff
18:36:06 <identity> the whole pop thing
18:36:09 <identity> (I don't do perl)
18:36:21 <sina> I still need an answer to "Why Haskell?" :(
18:36:26 <identity> wakeupsticky_: Of ubuntu, that is. I just set up a new system, 10.10, and everything worked off the bat
18:36:29 <mauke> all Perl functions are vararg, basically
18:36:36 <mauke> sina: it's fun
18:36:36 <identity> sina: Well, the introduction @ haskell.org puts it nicely
18:36:39 <wakeupsticky_> maverick, i think 10.10
18:36:49 <identity> All the buzz words are there; parallelism, concurrency
18:36:50 <identity> etc
18:36:56 <ninly> as another novice here i am curious, what are haskell people's thoughts in general about python (and i hope i am not stepping on a landmine)
18:37:00 <identity> wakeupsticky_: And what is the problem, exactly?
18:37:10 <res> ninly: it works differently?
18:37:13 <ManateeLazyCat> IIcke: Wow. :)
18:37:15 <mauke> ninly: I don't like it, but that's just my opinion
18:37:30 <wakeupsticky_> i believe i was trying to install wxwidgets and i was getting an error.
18:37:32 <mauke> ninly: it's about 200 times better than php, of course
18:37:40 <sina> python ? :D
18:37:50 <identity> wakeupsticky_: You're being very unspecific. Did you use cabal to try to install wxwidgets?
18:37:57 <ninly> res: yes definitely different. but yeah i meant more in the sense of comparing it to other opinions about other languages
18:38:07 <aristid> sina: you are here to ask why to use haskell? if you don't want to use haskell, don't use it
18:38:08 <wakeupsticky_> yeah, sorry. let's assume that i don't have anything done.
18:38:15 <wakeupsticky_> i just installed ubuntu and want to use haskell.
18:38:40 <wakeupsticky_> is there an apt-get package that i can download?
18:38:42 <identity> wakeupsticky_: just a second
18:38:46 <identity> yep
18:38:47 <res> wakeupsticky_: ghcsomething
18:38:55 <identity> sudo apt-get install haskell-platform for the platform
18:38:58 <empt> wakeupsticky_: you can install from app center
18:39:05 <identity> But that comes with ghc 6.12.1, fyi
18:39:06 <sina> I want to know if I should continue doing haskell. I'm just a beginner. and I feel there are many pros here who chose Haskell for a reason
18:39:12 <ManateeLazyCat> wakeupsticky_: I recommend you use cabal install Haskell library, even there have apt-get.
18:39:15 <res> ghc6
18:39:22 <identity> if that's a crime against nature in your eyes, then you want to get ghc and cabal separately
18:39:32 <res> I like to compile my own after I grab the package, but that's just me
18:39:39 <rwbarton> sina: I suggest reading "Why Functional Programming Matters" (PDF, google for it)
18:39:41 <wakeupsticky_> running sudo apt-get install haskell-platform now
18:39:53 <IIcke> sina, it is better if you read some chapters of "learn you a haskell" and try doing a bunch of problems from this page: http://haskell.org/haskellwiki/H-99%3a_Ninety-Nine_Haskell_Problems   you will know more or less what is haskell about
18:40:10 <ManateeLazyCat> Have any library parse man page? I want to build man viewer, but ask to avoid duplicate work.
18:40:12 <res> wakeupsticky_: does that even work?
18:40:19 <wakeupsticky_> it's working
18:40:34 <res> ...how
18:40:40 <identity> wakeupsticky_: for wxhaskell, cabal install wx
18:40:51 <res> I don't think there /is/ a package haskell-platform
18:40:52 <sina> Why h
18:40:58 <sina> sorry
18:41:11 <sina> why choosing haskell between functional programming languages?
18:41:17 <wakeupsticky_> <identity> sudo apt-get install haskell-platform for the platform
18:41:19 <rwbarton> there definitely is on maverick, I just installed it also :)
18:41:25 <empt> speed for me
18:41:26 <res> oh, maverick
18:41:26 <wakeupsticky_> i did and it worked
18:41:39 <identity> wakeupsticky_: and you want the wxwidgets bindings for haskell?
18:41:50 <wakeupsticky_> ok, got to the error now
18:41:53 <res> I'm still using 10.04, okay?
18:41:58 <Cale> sina: purity and laziness
18:42:09 <IIcke> sina, if you don't try it, even if people spend several hours talking to you about the benefits of lazyness, the types, etc. you won't know what it is about
18:42:13 <ninly> wakeupsticky_: sudo apt-get install ghc6 libghc6-mtl-dev
18:42:26 <identity> wakeupsticky_: What was the error?
18:42:32 <ninly> wakeupsticky_: that's what i did, haven't had any trouble on ubuntu
18:42:40 <wakeupsticky_> http://pastebin.com/sPhNJhy0
18:42:45 <rwbarton> 10.04 also has a cabal-install package
18:42:52 <ManateeLazyCat> sina: I can tell you Haskell can do everything you want. :)
18:42:57 <identity> wakeupsticky_: ah.
18:43:09 <McManiaC> @can haskell give me a pony?
18:43:09 <lambdabot> Maybe you meant: faq map run wn
18:43:10 <res> wakeupsticky_: do you have wx libs and stuff?
18:43:12 <identity> That's strange
18:43:15 <FauxFaux> Pony.
18:43:18 <kulin> is there a way to get something like IO but strict?
18:43:18 <ddarius> @hackage pony
18:43:19 <lambdabot> http://hackage.haskell.org/package/pony
18:43:21 <McManiaC> meh
18:43:23 <McManiaC> :D
18:43:24 <sina> IIcke, I tried haskell. not new to it. but I have not tried any other functional programming language. have you guys tried any other language?
18:43:26 <kulin> so the 'do' list is executed in order?
18:43:30 <McManiaC> @faq Can haskell give me a pony?
18:43:30 <lambdabot> The answer is: Yes! Haskell can do that.
18:43:30 <rwbarton> @faq can haskell give me a pony?
18:43:31 <lambdabot> The answer is: Yes! Haskell can do that.
18:43:33 <wakeupsticky_> all i did was apt-get install haskell-platform. Other than that I've installed/downloaded nothing.
18:43:34 <wakeupsticky_> :)
18:43:34 <identity> Huh
18:43:37 <identity> that happens for me as well
18:43:37 <McManiaC> rwbarton: :D
18:43:40 <identity> @ wakeupsticky_ 
18:44:12 <McManiaC> sina: yes, quite a few, and I always came back to haskell ;)
18:44:30 <rwbarton> wakeupsticky_: sudo apt-get install libwx11-dev  and try again
18:44:44 <rwbarton> oops hang on
18:45:01 <IIcke> sina, browse stackoverflow, there are plenty of questions about... haskell vs scheme vs f# vs scala...
18:45:04 <wakeupsticky_> done, now trying again
18:45:33 <sina> thanks IIcke :) will look into it
18:45:37 <ManateeLazyCat> http://learnyouahaskell.com/chapters is great haskell tutorial. ..... :)
18:45:44 <wakeupsticky_> identical error message :(
18:45:44 <ManateeLazyCat> sina: Try read http://learnyouahaskell.com/chapters
18:46:04 <rwbarton> oh, what you need to do is add ~/.cabal/bin to your $PATH
18:46:15 <identity> This is strange; wxdirect is install in .cabal/bin, but bin/sh complains about not finding wxdirect
18:46:21 <rwbarton> because... that
18:46:29 <identity> rwbarton: isn't that done automatically?
18:46:34 <wakeupsticky_> i'm not stupid, but i'm new to linux. how do i add that to my path? >_>
18:46:35 <McManiaC> no
18:46:47 <identity> I figured it would be for the duration of the install, anyway
18:47:12 <ddarius> That would be a really bad idea.
18:47:14 <ManateeLazyCat> wakeupsticky_: Add "PATH=$PATH:~/.cabal/bin" in your .bashrc
18:47:21 <rwbarton> or .profile
18:47:24 <identity> at the bottom works
18:47:39 <wakeupsticky_> my.... .bashrc? 
18:47:45 <sina> already doing ManateeLazyCat . thanks :)
18:47:48 <McManiaC> ~/.bashrc
18:47:54 <wakeupsticky_> i suppose i should have read a book on ubuntu? lol
18:47:55 <ManateeLazyCat> rwbarton: Yep, i was add in .profile, then add "source ~/.profile" in my ~/.bashrc
18:48:15 <IIcke> wakeupsticky_, you should have a .bashrc file in your home. If not, create it
18:48:30 <identity> wxcore still fails to install
18:48:34 <res> just set your path completely in an initfile
18:49:14 <wakeupsticky_> in my home directory i just have the "jesse' folder (i am jesse).
18:49:19 <rwbarton> you'll need to restart your shell
18:49:23 <IIcke> inside jesse
18:49:26 <wakeupsticky_> in there i don't see that file
18:49:48 <IIcke> type ctrl+h, maybe it will appear then
18:49:54 <wakeupsticky_> but after i did view -> show hidden files
18:49:56 <wakeupsticky_> i see it ;)
18:50:00 <wakeupsticky_> see i'm not dumb :(
18:50:02 <wakeupsticky_> :D
18:50:23 <res> type <M-f>xterm<cr>
18:50:48 <wakeupsticky_> i'm editing my .bashrc file now
18:51:01 <res> what are you using for an editor?
18:51:03 <wakeupsticky_> just add "PATH=$PATH:~/.cabal/bin" at the end (without quotes)?
18:51:03 <identity> This doesn't solve the problem entirely, though
18:51:08 <wakeupsticky_> just gedit
18:51:10 <ManateeLazyCat> wakeupsticky_: Yes.
18:51:10 <identity> wakeupsticky_: yep.
18:51:22 <res> hm
18:51:33 <res> does gedit have autoindent?
18:51:33 <wakeupsticky_> k, i added that line at the very end and saved
18:51:40 <wakeupsticky_> but i gather that this is not going to fix the problem?
18:51:40 <sina> ok guys. I g2g. its 3AM here. thanks a lot for your ideas, opinions, and the resources you sent. all were great and helpful. Hope to talk to you all soon. bye for now :)
18:51:59 <ManateeLazyCat> sina: See you. :)
18:53:11 <wakeupsticky_> trying cabal install wx again just for kicks
18:53:18 <rwbarton> also do  sudo apt-get install libwxbase2.8-dev
18:53:21 <RaGiNgDeMoN> hello
18:53:21 <rwbarton> it seems to be working now for me
18:53:39 <RaGiNgDeMoN> my name is mariano
18:53:40 <ManateeLazyCat> wakeupsticky_: Haskell for GUI?
18:53:49 <wakeupsticky_> yep
18:53:59 <identity> rwbarton: You're on to something
18:54:02 <identity> Need a few more though
18:54:10 <rwbarton> ugh
18:54:21 <identity> wx-baseu-2.8-dev, wx-baseu-net-2.8-dev
18:54:23 <identity> I think
18:54:24 <identity> and some more
18:54:25 <RaGiNgDeMoN> hello everybody
18:54:26 <ManateeLazyCat> wakeupsticky_: Do you like GTK+? YOu can install gtk2hs with "cabal install gtk2hs-buildtools && cabal install gtk" 
18:54:28 <wakeupsticky_> identical error message even after apt-getting libwxbase2.8-dev
18:54:35 <identity> At least it gives a meaningful error message this time
18:54:38 <identity> wakeupsticky_: Not identical, no
18:54:40 <ManateeLazyCat> wakeupsticky_: If you more like GTK+ . :)
18:55:01 <identity> RaGiNgDeMoN: Hello.
18:55:02 <RaGiNgDeMoN> i wnat to learn haskell
18:55:03 <wakeupsticky_> identiry, you are correct
18:55:08 <RaGiNgDeMoN> im from argentina
18:55:18 <wakeupsticky_> i was thinking wxwidgets because of fruit
18:55:29 <ManateeLazyCat> RaGiNgDeMoN: http://learnyouahaskell.com/chapters
18:55:40 <identity> lol
18:55:43 <RaGiNgDeMoN> thanks
18:55:48 <identity> Errors again
18:55:54 <RaGiNgDeMoN> i really like lazy programming
18:56:14 <wakeupsticky_> identity, am i supposed to apt-get wx-baseu-2.8-dev and wx-baseu-net-2.8-dev?
18:56:32 <identity> wakeupsticky_: nah, they're not in there
18:56:36 <identity> They're under something else
18:57:01 <identity> wx-0.12.1.6 depends on wxcore-0.12.1.6 which failed to install.
18:57:01 <identity> wxcore-0.12.1.6 failed during the configure step. The exception was:
18:57:01 <identity> ExitFailure 1
18:57:02 <wakeupsticky_> so i guess i could try something other than wxwidgets but gtk2hs seemed very awkward to me.
18:57:07 <identity> Gotta love informative error messages.
18:57:18 <ManateeLazyCat> wakeupsticky_: Why?
18:57:23 <wakeupsticky_> what? you mean ExitFailure1 isn't illuminating to you?
18:57:34 <wakeupsticky_> well, more that fruit looked better
18:57:36 <ManateeLazyCat> wakeupsticky_: gtk2hs easy to use.
18:57:50 <rwbarton> I have to say this error is pretty baffling
18:57:58 <res> why does gtk not depend on -buildtools for installation?
18:58:18 <kulin> is there a way to force some ammount of strictness in a 'do' statement? just for debugging purposes
18:58:28 <ManateeLazyCat> res: Because -buildtools generate Types.chs and Signal.chs file before any cabal step.
18:59:06 <ManateeLazyCat> res: So add gtk2hs-buildtools in build-depends of gtk package can't fix problem, it's a problem of cabal, not gtk2hs
18:59:34 <ManateeLazyCat> @trace
18:59:34 <lambdabot> Unknown command, try @list
18:59:45 <ManateeLazyCat> @hoogle trace
18:59:45 <lambdabot> Debug.Trace trace :: String -> a -> a
18:59:45 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
18:59:45 <lambdabot> module Debug.Trace
18:59:50 <ManateeLazyCat> kulin: ^^^^ ?
19:00:25 <wakeupsticky_> http://en.wikibooks.org/wiki/Haskell/GUI
19:00:27 <ManateeLazyCat> kulin: Debug.Trace.trace use for debug. 
19:00:36 <wakeupsticky_> tried this: sudo cabal install wxcore --global
19:01:23 <wakeupsticky_> http://pastebin.com/BVPpVPa6
19:01:29 <wakeupsticky_> ^^ resulting error message
19:01:58 <kulin> trace forces evaluation? it wont just pass on the thunk?
19:02:01 <wakeupsticky_> missing c libraries.
19:04:03 <ManateeLazyCat> Why just wx demo on http://en.wikibooks.org/wiki/Haskell/GUI ?
19:04:48 <rwbarton> wakeupsticky_: did you install libwxcore-2.8?
19:04:54 <rwbarton> uh, libwxbase-2.8
19:05:04 <rwbarton> er, fail.  libwxbase2.8-dev
19:05:26 <wakeupsticky_> yes
19:05:34 <wakeupsticky_> i did sudo apt-get install libwxbase2.8-dev
19:05:38 <rwbarton> hmm
19:07:14 <identity> wakeupsticky_: sudo apt-get install libwxbase2.8-
19:07:16 <identity> wakeupsticky_: sudo apt-get install libwxbase2.8-*
19:07:31 <identity> that should get you past those C library errors, but it's still broken
19:07:35 <identity> I'm running an identical setup
19:07:39 <taktoa> I'
19:08:00 <wakeupsticky_> done, should i even try cabal install wx again?
19:08:10 <identity> wakeupsticky_: you can try, sure, but it'll break
19:08:19 <identity> With the informative ExitFailure 1
19:08:40 <wakeupsticky_> didn't get me past the missing c libraries
19:08:47 <identity> really?
19:08:48 <identity> did for me
19:08:52 <identity> Pretty sure that's what I did
19:09:02 <wakeupsticky_> i did sudo apt-get install libwxbase2.8-*
19:09:14 <taktoa> I'm writing a mandelbrot-generating program (paste is here: http://hpaste.org/40630/mandelbrot20), but for some reason it outputs in black and white instead of grayscale. Can anyone tell me why?
19:09:52 <rwbarton> I think BMP is a black and white image format?
19:10:21 <taktoa> the Codec.BMP library haddock says it's 24-bit color
19:10:26 <rwbarton> oh ok
19:10:26 <identity> BMP is definitely 24bit
19:10:58 <wakeupsticky_> maybe i should just try gtk2hs
19:11:09 <identity> wakeupsticky_: It would seem so, yes
19:11:20 <identity> I'm rather disappointed myself; I had intentions to check out wxwidgets soon
19:11:40 <identity> Even set up this linux installation partially due to the fact that setting up wxwidgets on windows was supposed to be very, very annoying
19:11:51 <wakeupsticky_> same here!
19:12:05 <wakeupsticky_> i tried to get wxwidgets working on windows!
19:12:06 <wakeupsticky_> lol
19:12:14 <L29Ah> how do i check if C object files are getting stripped before being linked into a haskell library?
19:12:50 <res> why?
19:12:57 <L29Ah> according to my inability to debug with gdb linewise it seems they are, but i doubt where
19:13:34 <res> why in the world are you debugging haskell with gdb?
19:13:50 <rwbarton> taktoa: most points outside the mandelbrot set don't take that long to diverge, so I think "div (mandelnum x y) 10" will give you mostly 0
19:14:22 <taktoa> maybe I should use some sort of weighting function
19:14:34 <rwbarton> I would try something more like multiplying by 10 and see what that looks like
19:14:55 <taktoa> then it would exceed 255!
19:14:59 <L29Ah> res: because i'm getting segfaults inside a C function called from ffi
19:15:06 <res> ah
19:15:09 <rwbarton> mandelnum x y is usually going to be like, 4 or so
19:15:56 <wakeupsticky_> now how do i get gtk2hs?
19:16:06 <res> "    *  * On the Pokemon rules website it states, "Carry your Pokmon with you, and you're ready for anything! You've got the power in your hands, so use it!"
19:16:06 <wakeupsticky_> gtk2hs isn't a package so it must be several packages?
19:17:26 <taktoa> multiplying by 10 works
19:17:28 <taktoa> thanks
19:17:41 <rwbarton> according to the gtk2hs blog it's "cabal install gtk2hs-buildtools" and then "cabal install gtk"
19:19:11 <wakeupsticky_> here i was going cabal install gtk, cabal install glib, cabal...wtf
19:19:13 <wakeupsticky_> >_>
19:20:07 <rwbarton> and you probably need to  apt-get install libgtk2.0-dev  first
19:20:59 <L29Ah> ☹
19:23:24 <wakeupsticky_> http://pastebin.com/qEMyPepp
19:23:50 <wakeupsticky_> this error after successfully running cabal install gtk2hs-buildtools and apt-get install libgtk2.0-dev
19:24:04 <wakeupsticky_> (upon running cabal install gtk)
19:24:28 <rwbarton> gtk2hs-buildtools should have installed gtk2hsC2hs into .cabal/bin
19:24:49 <wakeupsticky_> *kanye shrug*
19:25:04 <rwbarton> you probably need to open a new shell to get the updated PATH
19:25:26 <wakeupsticky_> ok, trying again
19:25:36 <wakeupsticky_> new shell
19:30:01 <cch> any body used haskell bindings for cairo? I have problem with printing chinese text. I select a chinese font family
19:33:53 <wakeupsticky_> i believe that gtk2hs just successfully installed
19:36:36 <gwern> wakeupsticky_: a real accomplishment in these uncertain times
19:36:36 <cch> wakeupsticky_: are you answering my question?
19:37:04 <wakeupsticky_> no, cch, i'm not. sorry :(
19:37:24 <cch> that's fine
19:37:27 <wakeupsticky_> now i need a good haskell editor. tried scite but it doesn't have haskell as a language option.
19:38:20 <gwern> try emacs
19:38:28 <gwern> or yi isn't too bad as a special-purpose haskell editor
19:38:35 <gwern> I hear good things about leksah
19:38:55 <djahandarie> I had really bad problems with yi
19:38:55 <res> yi isn't exactly the greatest of general editors, though
19:39:03 <res> djahandarie: what sort of problems?
19:39:15 <djahandarie> Specifically, if you leave it open long enough, you will eventually get a problem with MVars that totally takes out the whole editor
19:39:39 <djahandarie> I think it also has something to do with resizing the terminal
19:39:43 <res> djahandarie: go fix it and the submit a patch to the maintainer :P
19:40:04 <djahandarie> That'd involve a lot of time which I don't have ;)
19:52:11 <interferon> so somehow my cabal directory has gotten into a corrupt state.  is there anything i can do to force-reinstall all my packages?
19:52:21 <interferon> or to figure out which packages are screwed up?
20:20:28 <megajosh2> interferon: As far as figuring out if packages are corrupted, you could just check ghc-pkg I guess
20:20:41 <interferon> doesn't give me any errors
20:20:43 <megajosh2> hmm
20:20:52 <megajosh2> Never had a problem like that before
20:22:16 <interferon> the error happens when i try "cabal install yesod"   :  http://hpaste.org/40632/error
20:22:24 <interferon> actually http://hpaste.org/40633/error has more details
20:23:30 <interferon> without my current .cabal and .ghc directories, i can "cabal install yesod" without any complaints at all
20:26:36 <interferon> any ideas?
20:26:46 <interferon> short of reinstalling all my packages?
20:27:25 <rwbarton> what happens if you do cabal install zlib-bindings?
20:27:53 <kulin> normally i do not care about evaluation order but I am dealing with ffi code and a lot of pointers and getting random seg faults, has anyone else encountered this and what angle is it best to start debugging from?
20:28:22 <interferon> rwbarton: no errors, but get the same thing when i try to install yesod
20:29:09 <rwbarton> I think the problem is something like cabal has chosen an install plan which involves linking together two different versions of a C library
20:29:49 <rwbarton> I suspect there is a solution which is easier than reinstalling all your packages, but figuring out what it is may not be easier
20:29:50 <wakeupsticky_> sigh, leksah doesn't install
20:30:23 <wakeupsticky_> cabal install leksah gives the error
20:30:44 <interferon> yeah, it looks like zlib and zlib-bindings are conflicting with each other
20:30:56 <rwbarton> can you ghc-pkg hide one of them maybe?
20:31:14 <interferon> trying that now
20:31:20 <interferon> nope :)
20:31:53 <interferon> so, no problem reinstalling all my packages, but when i get the names from "ghc-pkg list" they all have version numbers appended.  "ghc-pkg list --names-only" still leaves them on
20:32:05 <interferon> any way to get just the package names, so i can feed them to cabal install?
20:32:27 <c_wraith> you can feed the names with version to cabal install
20:32:35 <c_wraith> unless you want to change installed versions of something
20:32:45 <interferon> c_wraith: but couldn't there be a version conflict causing this?
20:32:46 <rwbarton> it's not really clear whether that will help
20:32:53 <interferon> c_wraith: or ghc-pkg check would see that?
20:33:28 <rwbarton> I don't see why ghc-pkg check would care if you have two unrelated packages linking against different versions of the same C library
20:33:34 <rwbarton> which seems like it is probably the problem
20:33:40 <wakeupsticky_> this is interesting:
20:33:44 <wakeupsticky_> Configuring gtk-0.11.2... Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure.
20:34:37 <interferon> rwbarton: like i said, if i get rid of my current .ghc and .cabal, i can install yesod without issue
20:34:41 <rwbarton> I have the yesod package installed, and no zlib-bindings at all
20:35:29 <rwbarton> well, not the very latest version
20:35:58 <interferon> eh?
20:37:38 <rwbarton> it looks like yesod gained a zlib-bindings dependency in 0.5.2, and I have 0.5.1
20:39:10 <rwbarton> (I was just confused why cabal was trying to use zlib-bindings at all, since I downloaded 0.5.1 only about a week ago)
20:51:39 <wakeupsticky_> leksah install on ubuntu maverick is broken
20:51:43 <wakeupsticky_> test it if you don't believe me
20:51:46 <wakeupsticky_> i have to go to bed though
20:51:48 <wakeupsticky_> goodnight
20:57:29 <interferon> rwbarton: ah, gotcha
21:36:52 <mtnviewmark> oy - the plugins package is giving me fits
21:37:19 <mtnviewmark> if you load a module and it doesn't have the entry point you are looking for, you can never load it again!
21:43:57 <Itkovian> hi. anybody got a reference to whoever stated "no paper without code" at any recent haskell event?
21:44:15 <Itkovian> I thought dons tweeted about it, but I cannot find it
21:57:35 <kmc> hello everyone
21:59:04 <djahandarie> o/
21:59:06 <kmc> ☭
21:59:36 <mtnviewmark> itssssssssssss Saduhday Nite!
21:59:59 <kmc> Да!
22:00:19 <djahandarie> そうですよね
22:00:49 <kmc> walk without rhythm, and you won't attract the worm
22:00:56 <dolio> Man, Introduction to Higher Order Categorical Logic is crazy.
22:01:37 <dolio> They're giving the type of the S combinator as ((A <= C) <= (B <= C)) <= ((A <= B) <= C).
22:01:46 <kmc> what
22:01:51 <dolio> Who writes their arrows pointing that direction?
22:01:54 <kmc> is it opposite day
22:02:55 <shachaf> dolio: Is there some logic behind it?
22:02:58 <kmc> @djinn-let type a :<= b = b -> a
22:02:58 <lambdabot> Maybe you meant: djinn-del djinn-ver
22:03:25 <dolio> shachaf: I think the idea is to match up with the direction of function application.
22:03:27 <mtnviewmark> > reverse "is it opposite day"
22:03:28 <lambdabot>   "yad etisoppo ti si"
22:03:57 <kmc> > fix ((0:).scanl (+) 1)
22:03:58 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:03:59 <rwbarton> I suppose it does make the (A x -, -^A) adjunction look nicer.
22:04:07 <kmc> > fix error
22:04:08 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
22:04:23 <dolio> So that composition has type ((C <= A) <= (C <= B)) <= (B <= A)
22:04:28 <dolio> For instance.
22:05:02 <kmc> > drop 100 $ fix ((0:).scanl (+) 1)
22:05:03 <lambdabot>   [354224848179261915075,573147844013817084101,927372692193078999176,15005205...
22:05:06 <Cale> dolio: right
22:05:10 <dolio> They only write their typed combinatory logic types that way. not their category theory types.
22:05:24 <dolio> At least, so far.
22:07:17 <rwbarton> It's funny how B^A looks fine but B <= A is baffling.
22:07:56 <dolio> B^A messes my up regularly, too.
22:08:05 <dolio> Messes me up, even.
22:10:29 <rwbarton> p. 44 "From now on in our exposition, the arrow of time will point in its customary direction."
22:10:35 <rwbarton> Hard to resist making a snarky comment at that point.
22:20:58 <kmc> @check \xs -> xs == reverse xs
22:20:59 <lambdabot>   "OK, passed 500 tests."
22:21:22 <dolio> @check \xs -> length xs < 2
22:21:22 <lambdabot>   "Falsifiable, after 1 tests:\n[(),(),()]\n"
22:21:32 <dolio> Ah, of course.
22:21:49 <kmc> @. elite nixon
22:21:49 <lambdabot> Thi$ i$ A gR34t D4y 4 FRANcE!
22:21:52 <kmc> @. elite nixon
22:21:52 <lambdabot> fIni$|-|ING zEc0nd In tH3 0lyMPics 9E7$ yOu siL\/er. FINiSHINg S3(Ond IN P0|I+I(z 93T$ joo obLI\/I0n.
22:22:06 <djahandarie> Whatever happened to QuickSpec?
22:23:27 <djahandarie> I remember reading a paper and thinking "wow this is cool" but I have no idea if it has progressed at all
22:46:41 <Maxdamantus> > let a = [1..] in a == a
22:46:45 <lambdabot>   mueval-core: Time limit exceeded
22:46:54 <Maxdamantus> would it be allowed for an implementation to just return True there?
22:47:17 <kmc> > let a = 0/0 in a == a
22:47:18 <lambdabot>   False
22:53:39 * hackagebot copilot 0.23 - A stream DSL for writing embedded C monitors.  http://hackage.haskell.org/package/copilot-0.23 (LeePike)
22:56:28 <Maxdamantus> > let a = 0/0 : [1..] in a == a
22:56:29 <lambdabot>   False
23:05:48 <Axman6> djahandarie: probably still being written
23:06:03 <djahandarie> :-(
23:08:42 <koninkje> Maxdamantus: allowing it to return True would be unreliable due to the halting problem etc
23:09:34 <koninkje> Also because of the difference between definitional equality and propositional equality (cf theorem provers)
23:10:06 <koninkje> ...that is, the practical difference (whether or not there should be a theoretical difference)
23:16:44 <kulin> doh, so for what its worth, it seems my problem was with the difference between bound and unbound threads
23:19:46 <Maxdamantus> @pl (head .) . filter
23:19:46 <lambdabot> (head .) . filter
