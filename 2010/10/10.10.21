00:00:07 <kmc> headMay = Data.Maybe.listToMaybe
00:00:08 <kmc> btw
00:00:23 <kmc> anyway, so you have an action generating a (Maybe t) value
00:00:29 <kmc> what are you trying to do with 'maybe'?
00:01:26 <tehgeekmeister> either i print what's at the head of the list at the head of the list i'm passing in, or i print that there was an empty list at one of the levels of the call.
00:01:27 <tehgeekmeister> that's it!
00:01:28 <tehgeekmeister> no
00:01:29 <tehgeekmeister> thing more.
00:02:03 <tehgeekmeister> actually i could even get away with just printing the list itself, come to think of it.  i just need to see what the query will return in a few test cases real quick.
00:02:32 <kmc> maybe (putStrLn "it's empty") (print . fromSql)
00:02:46 <tehgeekmeister> right, i should have parens
00:02:50 <tehgeekmeister> and i should use putStrLn
00:02:54 <tehgeekmeister> good points
00:02:55 <kmc> or:
00:03:03 <kmc> putStrLn $ maybe "it's empty" (show . fromSql)
00:03:13 <kmc> print = putStrLn . show
00:04:04 <tehgeekmeister> right, okay
00:04:07 <tehgeekmeister> thanks
00:06:56 <kmc> er that $ should be .
00:07:05 <kmc> if isolated like so
00:08:15 <c_wraith> :t ?x >>= ?x
00:08:21 <lambdabot> Top level:
00:08:27 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
00:08:39 * mjrosenb installs ghc-7
00:08:44 <mjrosenb> this should be interesting
00:08:54 <ivanm> @bot
00:08:59 <lambdabot> :)
00:09:02 <kmc> yay
00:09:03 <ivanm> mjrosenb: it's out already? :o
00:09:04 <kmc> thanks Cale (?)
00:09:05 <ivanm> \o/
00:09:09 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
00:09:11 <ivanm> :o
00:09:12 <mjrosenb> ivanm: it is in the overlay
00:09:17 <mjrosenb> ivanm: or at least a snapshot is
00:09:23 <ivanm> mjrosenb: that's what I figured ;-)
00:09:55 <kmc> there's release candidates yes?
00:10:02 <Saizan> yep
00:10:02 <mjrosenb> ivanm: i've never been a patient one
00:10:27 <ivanm> heh
00:10:52 <mjrosenb> dev-lang/ghc-7.0.0.20100924
00:49:51 <merijn> Is it a safe assumption that show and read are eachother's inverses?
00:49:57 <ivanm> yes
00:50:01 <ivanm> that is precisely the point
00:50:27 <merijn> ivanm: That's sorta what I expected, but you never know when people do crazy stuff...
00:50:30 <ivanm> they should also print/parse actual code representations of the value in question
00:50:37 <ivanm> merijn: people do tend to do crazy stuff
00:50:47 <ivanm> and use Show for pretty printing
00:52:00 <kmc> merijn, it will hold for derived instances
00:53:03 <ivanm> unless the type uses another type that doesn't obey the rules...
00:53:08 <kmc> yeah
00:53:23 <kmc> and personally i stick to simple for Read/Show, and leave parsing / pretty printing to dedicated functions
00:53:26 <kmc> but not everyone does this
00:53:31 <ivanm> if you want printing and parsing classes for your app/library, define your own rather than using Show and Read
00:53:46 <kmc> these days i see Show as mainly for ghci
00:54:37 <ivanm> kmc: when I inherited graphviz I was stuck with it having Show for printing; eventually I got sick of mangling with it and wrote a pretty-printing class
00:54:37 <ivanm> kmc: or debugging in general
00:54:53 <merijn> ivanm: I was more thinking along the lines whether it would be possible to implement serialization for functions in such a way that you could serialize any function "(Show a, Read a) => a -> b"...
00:55:20 <ivanm> well, yes, Show/Read are valid for textual serialisation
00:55:26 <ivanm> I think that's what xmonad uses
00:55:43 <ivanm> but if you're transmitting the data over a network you'd probably want to use binary or something
00:56:00 <ivanm> and do custom serialisation stuff to make it more terse
00:57:57 <merijn> ivanm: Of course, but serializing data isn't so much interesting, there's billions of ways of doing that. Whether you could make functions (or at least a large subset, like "(Show a, Read a) => a ->b") serializable, that was more the point of interest.
00:59:24 <merijn> I have a paper lying around here (admittedly I haven't read it yet) on dynamically loading (and compiling) haskell code, that with serializable arguments should let you serialize closures, I think. Provided some insane mucking about...
00:59:48 <ivanm> merijn: are you talking about dons' plugin paper[s] ?
01:00:18 <merijn> I think that one as well, yeah
01:00:28 <kmc> it's not enough to serialize the arguments and return type
01:00:35 <kmc> you have to serialize the free variables
01:00:53 <ivanm> yeah
01:00:57 <merijn> kmc: Hmm, you're right. Didn't think of that
01:01:03 <kmc> whose types are not part of the function type
01:01:40 <kmc> a closure is a function pointer plus a record of free variables
01:02:01 <kmc> serializing arg/return is useful for RPC, foreign marshalling, etc., but not for serializing the function itself
01:02:17 <kmc> yhc has some ability to serialize haskell functions
01:02:38 <merijn> kmc: Explains why that idea was suspiciously simple
01:03:20 * ski . o O ( `data a -> b = forall env. Clos# $# env $# ((# env , a #) #-> b)' )
01:04:01 * kmc wonders if it's sensible to have a language where a functions' type includes its free variables' types
01:04:14 <kmc> ski, what is $# meant to represent?
01:06:22 <kmc> generally we need to forget what the free vars were
01:06:33 <kmc> for composability, encapsulation, etc.
01:07:12 <ski> kmc : application of an "unboxed function"
01:07:26 <ski>   f : a #-> b , x : a |- f $# x : b
01:07:43 <kmc> why would it appear in a type expression though
01:08:29 <ski> `a #-> b' being the type of "top-level" functions from `a' to `b', the only nonlocal things it can depend on are global constants
01:08:36 <ski> (so, think "C functions")
01:08:40 <kmc> right
01:08:58 <ski> `a #-> b' corresponds more or less to Lewis' "strict implication", i think
01:09:05 <kmc> oh?
01:09:48 * hackagebot amqp 0.2.2 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.2.2 (HolgerReinhardt)
01:09:48 <ski> you can then also think of it as `[] (a -> b)', where `[]' is a necessary-type modality that expresses what is "necessary" (i.e. global, non-cotingent)
01:09:48 <mjrosenb> ski: C functions that aren't from gcc
01:09:55 <ski> yeah
01:09:56 <mjrosenb> ski: gcc is on crack.
01:10:17 <kmc> gcc will lambda-lift to give you downward closure
01:10:27 <kmc> but won't allocate closure data structures and so you can't have upward closure
01:10:36 <kmc> (i might have the directions of the terminology reversed)
01:10:45 <mjrosenb> kmc: alloca is allocation, right?
01:10:53 <kmc> kind of
01:11:06 <kmc> is alloca used in the translation of nested function definitions?
01:11:07 <mjrosenb> kmc: also, it doesn't store the data, *per say*
01:11:43 * mjrosenb does not know.
01:11:52 <kmc> i don't see where it would be needed
01:12:12 * mjrosenb hopes it does not just do the same thing it does for taking the address of nested functions
01:12:27 <kmc> that what does not do what?
01:13:00 <kmc> i think nested functions for C with downward closure only is straightforward syntactic sugar, though the most efficient implementation will be a little trickier
01:14:17 <kmc> hmm
01:15:03 <mjrosenb> it does not store an array of 'here are the values that the free variables have'
01:16:09 <merijn> Anyone aware whether anyone has ever attempted this sorta thing in Haskell (or I guess GHC might be a more appropriate question since I guess this could be rather implementation dependent...)?
01:16:17 <kmc> what kind of thing?
01:16:24 <kmc> serialized functions?
01:16:30 <merijn> Serializing functions/closures
01:16:40 <kmc> as i said, i think it was partially implemented in yhc
01:16:45 <kmc> or maybe nhc98, yhc's predecessor
01:16:59 <merijn> I'll look that up
01:17:00 <mjrosenb> kmc: i heard that it was yhc
01:17:10 <kmc> hmm maybe i was wrong about downward closure being so straightforward
01:17:17 <mjrosenb> kmc: iirc, they had an instance of show for lambda types
01:17:35 <kmc> if g() is defined within f(), and you want to pass &g to an external function which knows nothing about f or g
01:17:44 <mjrosenb> kmc: have you seen what ghc does?
01:17:48 <mjrosenb> err
01:17:49 <mjrosenb> gcc.
01:17:53 <kmc> no
01:18:01 <mjrosenb> it is *hilarious*
01:18:13 <merijn> Oh well, I'll add this and Yhc to my to read list for later
01:18:30 <kmc> oh it actually builds a trampoline
01:18:41 <kmc> ok
01:18:47 <kmc> yeah it's easy to allow f() to define and then call g()
01:19:04 <kmc> harder to allow f to pass &g to functions it calls
01:19:07 <kmc> but gcc allows it
01:19:18 <kmc> still not requiring memory management
01:20:54 <Jafet> You can also make g() use static allocated memory and return &g, thus conferring on yourself eligibility for a Greenspun award
01:21:53 <merijn> I suppose if I really want to do stuff like serialize functions I should start learning Erlang...
01:22:01 <kmc> does erlang let you serialize functions
01:22:22 <kmc> mjrosenb, the Show instance for function types would be hard to write, because you care about the types of free variables, but that's not present within the -> type
01:22:51 * hackagebot amqp 0.2.3 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.2.3 (HolgerReinhardt)
01:23:02 <merijn> kmc: Well, they allow hot-swapping code at runtime, so you could swap a function for a new one (even remotely), seems like that solves the biggest problems already
01:23:14 <mjrosenb> kmc: you can write out a new function that has had all of the values substituted.
01:23:30 <kmc> mjrosenb, how do you show those free variables?
01:24:26 <merijn> I suppose you could do eta conversion to capture the free variables, but then you need to suddenly also check the newly captured variables for serializability
01:25:31 <Jafet> What do you do with a non-hnf closure?
01:25:38 <Jafet> (Evaluate it? Oh my.)
01:26:02 <kmc> serializing thunks seems no harder than serializing closures
01:26:13 <merijn> kmc: Oh, I just realized why Erlang can of course pull it off
01:26:27 <Jafet> Well, if you're satisfied with "<#thunk blah blah blah>"
01:26:52 <merijn> kmc: They don't run machine code, so they can just serialize binary data over the wire and not worry about what machine the other end is running on
01:27:06 <kmc> merijn, true.  but i think serializing the *code* is not the hard part either way
01:27:14 <kmc> you can also just require that both sides are running with the same binary
01:27:28 <sipa> but if you start with the same binary
01:27:28 <kmc> and send just a function pointer relative to the base of .text, or whatever
01:27:33 <sipa> why would you even send the code
01:27:38 <sipa> right, what you say :)
01:27:45 <kmc> serializing the runtime state, e.g. free vars, is the hard part
01:27:56 <Jafet> Not that "the same binary" holds so much meaning in erlang.
01:28:04 <kmc> right, you get other benefits from that
01:28:07 <sipa> make all arguments from encosing closures explicit
01:28:09 <kmc> hot upgrades etc.
01:28:15 <kmc> not serializability per se
01:28:33 <kmc> Jafet, serializing a thunk so that it can later be read and forced seems not much different from serializing a function so that it can later be read and applied
01:28:35 <merijn> Note to self: Figure out how Erlang does it :p
01:28:40 <kmc> either way, the trick is to serialize free variables
01:28:50 <Jafet> kmc: well, they're basically the same problem.
01:29:01 <kmc> merijn, you can require that all types are serializable
01:29:08 <Jafet> What about serializing a combinator calculus? That sounds easy.
01:29:14 <kmc> and that sufficient runtime type information is available
01:29:16 <kmc> then the free var problem goes away
01:29:41 <merijn> Right, we're rapidly moving out of my area of understanding so I'm back to working :p
01:29:49 <mjrosenb> so at some point or other in the compilation process, you need to do closure conversion
01:30:00 <mjrosenb> and when you do that, all of your contexts are explicit
01:30:15 <mjrosenb> so you could pretty easily check for serializability then
01:30:35 <kmc> and make it part of the type of a function whether it's serializable?
01:30:48 <merijn> kmc: That was sorta my original idea, yes
01:31:04 <Jafet> You could make it a magical class.
01:31:21 <kmc> some functions of type A → B are serializable, others aren't
01:31:34 <mjrosenb> what else might there be that aren't serializable?
01:31:34 <Jafet> Oh, true.
01:32:00 <ivanm> mjrosenb: depending on how it's done, PRNG state?
01:32:05 <kmc> the typical example of something non-serializable is system state
01:32:09 <kmc> a file handle or network socket etc.
01:32:18 <Jafet> You can serialize pretty much anything, if you don't care about breaking abstractions (Ptr)
01:32:31 <bd_> Jafet: unless things change under you while you're serialized
01:32:40 <kmc> one cheap answer is that the *representation* is serializable, you serialize a file descriptor as an int, etc.
01:32:45 <kmc> but it's useless on the other end
01:32:46 <Jafet> Of course when you take the resulting string later, its meaning is mostly lost
01:32:53 <kmc> the *meaning* has not been transferred, even if the *representation* has
01:32:56 <bd_> eg, if you're running on a unix-based OS, you'll have a hard time serializing a file descriptor for an unlinked file
01:33:18 <kmc> anyway, Erlang, being dynamically typed, could handle unserializable values by a runtime exception
01:33:22 <kmc> i do not know what it does
01:33:29 <mjrosenb> kmc: clearly you have never run plan9 :-p
01:33:54 * hackagebot splot 0.1.1 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.1 (EugeneKirpichov)
01:34:00 <merijn> mjrosenb: plan9 is hardly unix-based
01:34:12 <Jafet> A Haskell compiler could provide a magical isSeralizableFunction :: (a -> b) -> Bool, which looks up in an internal table
01:34:13 <merijn> Unix inspired, sure. But it does things pretty fundamentally different from unix
01:34:27 <Jafet> Then that shoves the handling of False onto the user
01:34:35 <sipa> Jafet: how do you define serializable?
01:34:57 <mjrosenb> sipa: it is magical, you don't need to define it.
01:35:11 <bd_> mjrosenb: So, an implementation of (const False) would be okay with you? :)
01:35:11 <Jafet> For which magicalUnserialize $ magicalSerialize $ f is always equivalent to f
01:36:01 <sipa> the ability of being serializable only depends on the types a and b right?
01:36:12 <kmc> nope
01:36:13 <bd_> I suppose you could define a function to be serializable if and only if all values in its closure are not unserializable values.
01:36:23 <sipa> ah i see
01:36:27 <kmc> some functions of type A → B have unserializable free vars
01:36:29 <kmc> others don't
01:36:37 <sipa> yes i see
01:36:40 <kmc> solutions include:
01:36:44 <kmc> - deal with it at runtime
01:36:45 <bd_> Note that you can't define it based on 'if all closure values are serializable' as loops may form
01:36:48 <kmc> - force everything to be serializable
01:37:20 <kmc> - invent a "serializable lambda" that checks free var types, and returns a different type
01:37:23 <bd_> I suppose in principle, anything is serializable, if you dump a memory image and don't worry too much about external resources
01:37:37 <Jafet> - be totally point-free
01:37:54 <bd_> however this leads to very interesthing things happening with serialized IOVars and the like :)
01:38:05 <kmc> Jafet, wouldn't you still have free vars?
01:38:09 <kmc> a partially applied S combinator
01:38:51 <Jafet> Well, it'd be directly part of the type, right?
01:38:57 <kmc> ?
01:39:11 <kmc> like if we use σ to mean "serialized λ" then we could say «σ x → x + 2» and its type would be «SFun Int Int».  and we'd have «useS :: SFun a b → (a → b)» but not the other way
01:39:38 <kmc> the extra step in typechecking a σ expression is to check that its free vars are serializable (whatever that means, e.g. type class membership)
01:39:57 <kmc> and probably to save their instance witnesses in some static area, like the info table for that closure
01:40:22 <Jafet> In something like (S f), if f has an unserializable type, then it would show up in the type of (S f) I think
01:40:32 <kmc> once again
01:40:38 <kmc> it's not about the type of f being unserializable
01:40:47 <kmc> it's about f being built with free vars which are unserializable
01:40:52 <kmc> this does not show up in f's type
01:41:08 <kmc> how a function is defined is not part of its type, for good reason
01:41:38 <Jafet> I thought that's excluded by pointfreeism, perhaps I'm mistaken
01:41:44 <kmc> well
01:41:46 <kmc> it might be
01:41:57 <kmc> if you've a proof or an argument for it, i'm interested
01:42:24 <Jafet> Heh, no proof. I'm a type theory poser
01:42:57 <kmc> so actually K is the simpler example of creating a closure
01:43:00 <kmc> because K x y = x
01:43:07 <kmc> so (K x) must remember x
01:43:20 <kmc> however the type of x does appear in the type of (K x)
01:43:27 <kmc> so it doesn't refute your claim
01:43:43 <Jafet> Okay, that's a counterexample
01:43:55 <kmc> it is?
01:44:27 <kmc> @type let s x y z = x z (y z) in s
01:44:28 <Jafet> Since (K x) might be unserializable, but it cannot be deduced from its type
01:44:29 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
01:44:39 <Jafet> Uh sorry, I meant (flip K)
01:44:59 <kmc> flip K :: ∀a b. b → a → b
01:45:04 <Jafet> Which is id, isn't it
01:45:08 <kmc> what?
01:45:38 <Jafet> @pl flip const 42
01:45:39 <lambdabot> id
01:46:00 <kmc> hmm
01:46:06 <Jafet> So 42 might be unserializable but you can't see from the resulting type
01:46:15 <kmc> i see
01:46:18 <kmc> @type flip const 42
01:46:19 <lambdabot> forall b. b -> b
01:46:22 <kmc> right
01:48:37 <mjrosenb> that isn't a good example, since the actual value that you are passing in does not need to be included in the closure.
01:50:04 <Jafet> But it would be impossible to tell, wouldn't it?
01:51:38 <bd_> imagine we have a function f :: UnserializableA -> B -> C. We then do flip (f foo). The type of UnserializableA doesn't appear in the resulting type at all
01:51:49 <bd_> err.
01:51:58 <bd_> f :: UnserializableA -> B -> C -> D even
01:52:19 <bd_> flip (f foo) :: C -> B -> A, where C B and A may all be serializable types
01:52:26 <Jafet> :t (\f g x a -> if a then f x else g x) -- all f, g, x must be in the closure
01:52:27 <lambdabot> forall t t1. (t -> t1) -> (t -> t1) -> t -> Bool -> t1
01:52:53 <Jafet> :t (\f g x a -> if a then f x else g x) ($1) ($2) succ
01:52:54 <mjrosenb> (\f x y -> f y x) (\a x -> a) 42 should step to (\y -> (\a b -> a) y 42) can be reduced to (\y -> y)
01:52:54 <lambdabot> forall a. (Num a, Enum a) => Bool -> a
01:52:57 <bd_> Jafet: well, no, that can pre-evaluate f x and g x and close over the results
01:52:58 <edlinde> when we do something like map (+3) [1,6,3,2]  .... the +3 is supposed to be a partial application function... I don't understand that part
01:53:02 <edlinde> can someone explain?
01:53:21 <mjrosenb> edlinde: what does it look like it does?
01:53:26 <bd_> :t (+3)
01:53:27 <lambdabot> forall a. (Num a) => a -> a
01:53:27 <edlinde> I mean are we saying + is an operator that can work as  (+ 3 4) ?
01:53:32 <merijn> edlinde: (+3) is the same as "\x -> x + 3"
01:53:33 <edlinde> mjrosenb: hi
01:53:40 <merijn> edlinde: No, + is a function
01:53:40 <edlinde> merijn: yep I know
01:53:59 <edlinde> but the tutorial reckons writing it out as \x -> x+3 is plain stupid
01:54:04 <banisterfiend> any hot girls here?
01:54:05 <merijn> edlinde: There is no concept of operators, just functions and more functions
01:54:11 <Jafet> bd: if one of f x or g x is bottom, then you cannot.
01:54:24 <Funktorsalat> *gets the popcorn*
01:54:28 <merijn> edlinde: "(+) 3 4 == 3 + 4"
01:54:28 <Jafet> @vixen are you hot?
01:54:29 <lambdabot> me? hot? naw, it's a nice comfortable 73 degrees in here
01:54:49 <sipa> edlinde: you can write any function as infix by the way too
01:54:53 <merijn> :t elem
01:54:54 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
01:54:54 <edlinde> merijn: so can this be thought of as a short cut?
01:55:14 <sipa> edlinde: it's syntactic sugar, i'd say
01:55:14 <mjrosenb> edlinde: it is syntatic sugar
01:55:17 <merijn> edlinde: Also: "elem a list == a `elem` list"
01:55:18 <edlinde> I mean I understand its adding 3 to every element in the list ... but just trying to get the syntax
01:55:25 <mjrosenb> edlinde: just like if is syntatic sugar
01:55:27 <edlinde> mjrosenb: hmm yeah 
01:55:40 <sipa> (op) is a function that takes 2 arguments
01:55:46 <edlinde> just wonder what else I can do like that then?
01:55:47 <merijn> edlinde: All functions can be used a prefix or infix in haskell (I think postfix too?)
01:55:54 <edlinde> ok
01:55:56 <mjrosenb> sipa: well.....
01:55:58 <Jafet> > (+3) . [1,6,3,2]
01:55:59 <lambdabot>   [4,9,6,5]
01:56:06 <kmc> edlinde, things made of symbols, like + and $ and #$*@&%$, are operators
01:56:10 <Jafet> > (+1) (+2) . [1,6,3,2]
01:56:11 <lambdabot>   [4,9,6,5]
01:56:21 <edlinde> Jafet: whats the "." doing there in your example?
01:56:25 <kmc> @src (.)
01:56:26 <lambdabot> (f . g) x = f (g x)
01:56:26 <lambdabot> NB: In lambdabot,  (.) = fmap
01:56:32 <kmc> it's yet another operator
01:56:34 <kmc> function composition
01:56:38 <mjrosenb> edlinde: it is the same as o in sml.
01:56:39 <kmc> > (succ . succ) 2
01:56:40 <edlinde> a composition
01:56:40 <lambdabot>   4
01:56:41 <edlinde> ok
01:56:47 <edlinde> mjrosenb: yep gotcha :)
01:56:50 <kmc> (f . g) x = f (g x)
01:56:51 <merijn> edlinde: For infix functions like + "(function) a b == a function b" and for prefix functions like elem "elem a b == a `elem` b"
01:56:54 <Jafet> Actually . was <$>
01:58:49 <edlinde> Jafet: win your example (+1) (+2) . [1,6,3,2]
01:58:56 <edlinde> Jafet: *with
01:59:10 <sipa> > (+1) (+2) . [1,6,3,2]
01:59:11 <lambdabot>   [4,9,6,5]
01:59:34 <sipa> > 5 :: (Int->Int)
01:59:35 <lambdabot>   *Exception: show: No overloading for function
01:59:38 <edlinde> I thought the . should be between (+1) and (+2) ?
01:59:41 <mjrosenb> is that some magic brought onto the world by lambdabot?
01:59:55 <merijn> mjrosenb: Lambdabot does weird things, yes
02:00:00 <sipa> :t ((+1) (+2) .)
02:00:01 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
02:00:04 <edlinde> I mean from the (f.g) x
02:00:11 <merijn> > 4 5
02:00:12 <lambdabot>   Ambiguous type variable `t' in the constraint:
02:00:12 <lambdabot>    `GHC.Num.Num t' arising f...
02:00:14 <Jafet> Num instance for functors
02:00:27 <Jafet> What bread will they slice next
02:00:32 <merijn> > (4 5)
02:00:33 <lambdabot>   Ambiguous type variable `t' in the constraint:
02:00:33 <lambdabot>    `GHC.Num.Num t' arising f...
02:00:39 <merijn> hmm, oh well
02:00:42 <sipa> > (5 :: (Int->Int)) 6
02:00:43 <lambdabot>   5
02:00:54 <Botje> @tell Samantha I live in europe, so trying to contact me between 3-5am my time isn't really useful, sorry :)
02:00:54 <lambdabot> Consider it noted.
02:00:57 <merijn> Braindead, but there you go
02:02:08 <edlinde> can I use (+1) (+2) . [1,6,3,2] directly on ghci ?
02:02:18 <edlinde> *Main> (+1) (+2) . [1,6,3,2]
02:02:18 <edlinde> <interactive>:1:12:
02:02:18 <edlinde>     Couldn't match expected type `a -> b' against inferred type `[a1]'
02:02:19 <edlinde>     In the second argument of `(.)', namely `[1, 6, 3, 2]'
02:02:19 <edlinde>     In the expression: (+ 1) (+ 2) . [1, 6, 3, 2]
02:02:19 <edlinde>     In the definition of `it': it = (+ 1) (+ 2) . [1, 6, 3, ....]
02:02:22 <edlinde> I get this error
02:02:59 <merijn> edlinde: Correct, lamdbabot is telling you stupid things are true
02:03:08 <edlinde> hmm
02:03:17 <merijn> edlinde: (i.e. someone defined numbers to be functions...)
02:03:22 <mjrosenb> don't listen to lambdabot.  he is full of lies and blasphemy.
02:03:31 <edlinde> hehe
02:03:43 <merijn> edlinde: Like this above:
02:03:44 <merijn> > (5 :: (Int->Int)) 6
02:03:45 <lambdabot>   5
02:03:53 <merijn> *rage*
02:03:57 <Jafet> > 1.0 2.0
02:03:58 <lambdabot>   Ambiguous type variable `t' in the constraint:
02:03:59 <lambdabot>    `GHC.Real.Fractional t'
02:03:59 <lambdabot>  ...
02:04:02 <Jafet> > 1.0 2.0 :: Double
02:04:03 <lambdabot>   1.0
02:04:05 <edlinde> weird
02:04:29 <merijn> :t (+1) . (+2)
02:04:30 <lambdabot> forall a. (Num a) => a -> a
02:04:32 <kmc> she*
02:04:35 <kmc> @vixen what is your name?
02:04:36 <lambdabot> My name is Emily
02:04:45 <merijn> :t map $ (+1) . (+2)
02:04:46 <lambdabot> forall a. (Num a) => [a] -> [a]
02:04:59 <merijn> map (+1) . (+2) [1..10]
02:05:03 <merijn> > map (+1) . (+2) [1..10]
02:05:04 <lambdabot>   No instances for (GHC.Num.Num [[a]],
02:05:04 <lambdabot>                    GHC.Num.Num [a],
02:05:04 <lambdabot>   ...
02:05:14 <merijn> > map (+1) . (+2) $ [1..10]
02:05:15 <lambdabot>   No instance for (GHC.Num.Num [a])
02:05:15 <lambdabot>    arising from a use of `e_112110' at <i...
02:05:22 <mjrosenb> kmc: oh right.. my bad.
02:05:32 <edlinde> yeah that gives errors on ghci too
02:05:46 <merijn> Oh, duh
02:05:51 <merijn> > map ((+1) . (+2)) [1..10]
02:05:52 <lambdabot>   [4,5,6,7,8,9,10,11,12,13]
02:05:54 <edlinde> why doesn't this work    map (+1) . (+2) [1..10]
02:05:55 <merijn> or
02:05:59 <edlinde> ah
02:06:01 <edlinde> ok
02:06:01 <mjrosenb> > map . (.) (+1) (+2) $ [1..10]
02:06:02 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
02:06:03 <merijn> > map $ (+1) . (+2) $ [1..10]
02:06:03 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[t]'
02:06:31 <merijn> edlinde: Because you're trying to apply (map (+1)) to the rest of the line like I was :p
02:06:31 <edlinde> ok makes sense 
02:06:32 <zomg> heh.. Haskell keeps confusing me
02:06:47 <zomg> I would not have expected the type for (+ 1) . (+ 2) to be that..
02:06:49 <zomg> =)
02:06:50 <merijn> zomg: Sounds normal to me
02:06:50 <edlinde> there is quite a lot of syntax to be aware of with Haskell
02:06:55 <zomg> But I guess it makes sense in the end
02:06:57 <edlinde> can only come with time 
02:07:00 <kmc> yeah
02:07:16 <kmc> (+1) . (+2)  ≡  let f x = x+1; g x = x+2 in f . g
02:07:19 <merijn> zomg: Yeah, haskell's numeric type classes are foncusing
02:07:32 <merijn> See, can't even type properly anymore
02:07:42 <kmc> and yeah, beware of lambdabot's crazy instances and non-standard imports
02:09:14 <edlinde> mjrosenb: so basically with lambda functions in Haskell they use \ which is the same as "fn" in SML yeah?
02:09:53 <quicksilver> yes
02:09:54 <quicksilver> \ is fn
02:10:04 <quicksilver> or 'fun' in ocaml, IIRC
02:10:04 <edlinde> quicksilver: ok cool
02:12:04 <zomg> If you have a Either IOError (Either Failure (Maybe Something)) kind of structure, how you'd go about processing it? I just have a case x of ... case y of... which seems like a very procedural approach to it :)
02:12:24 <quicksilver> using combinators like 'either' and 'fmap'
02:12:30 <quicksilver> and possible custom combinators.
02:12:33 <banisterfiend> is scheme a functional language?
02:12:44 <quicksilver> most people consider it so, yes.
02:12:58 <kmc> zomg, don't use types like that
02:13:02 <kmc> define your own type
02:13:14 <banisterfiend> quicksilver: then you're an 'ignorant buffoon' :P
02:13:26 <zomg> kmc: well this is something that comes out from Database.MongoDB
02:13:29 <kmc> data Result a = Exn IOError | Failed Failure | NoResult | Result a
02:13:30 <quicksilver> I didn't tell what I considered it as.
02:13:30 <kmc> oh :/
02:13:30 <banisterfiend> quicksilver: and you dont know what a 'function' is 
02:13:34 <banisterfiend> quicksilver: hehehehehe
02:13:34 <quicksilver> I just told you most people did.
02:13:48 <zomg> Although it might be because of my use of runNet and runConn
02:13:52 <banisterfiend> quicksilver: sorry :) im just relaying a conversation in #c to here, one person is saying scheme is not functional, and the other is saying it is
02:13:53 <quicksilver> I am, in fact, a fairly knowledgeable buffoon.
02:14:14 <banisterfiend> quicksilver: oh ok, so according to you, is scheme functional?
02:14:16 <merijn> banisterfiend: Scheme is not purely functional, but you can write functional scheme, yes.
02:14:22 <banisterfiend> ok thanks
02:14:26 <zomg> I think the structure would have one less Either if I didn't use runNet =)
02:14:27 <merijn> banisterfiend: Then again, you can also write functional C so...
02:14:48 <Jafet> You can write functional Haskell, too, but it's fairly optional
02:14:50 <zomg> (that catches IOError and wraps it, no idea if it's standard)
02:15:03 <banisterfiend> merijn: well the guy on #c is saying that scheme is not functional as it doesn't have functions
02:15:14 <banisterfiend> merijn: definition of function being a mapping from a domain to a range
02:15:14 <merijn> banisterfiend: The guy in #c is an idiot
02:15:36 <quicksilver> banisterfiend: I would (personally) prefer a defintion of 'functional' which recognised the mathematic meaning of 'function'.
02:15:41 <banisterfiend> merijn: join #c then :)
02:15:44 <quicksilver> banisterfiend: that is, basically, purity.
02:15:45 <banisterfiend> merijn: and set him right :)
02:15:50 <zomg> quicksilver: I'll look at those combinators though, thanks for the pointer
02:15:55 <merijn> banisterfiend: No, they are scary mean grumpy men
02:15:59 <banisterfiend> merijn: the guy is an op on #c though
02:16:00 <quicksilver> banisterfiend: but I acknowledge that this is not really the accepted usage of the phrase.
02:16:04 <banisterfiend> merijn: and an op on #lisp
02:16:08 <kmc> someone on the internet is wrong
02:16:10 <kmc> ?!?!?!?!?!?
02:16:11 <lambdabot> Unknown command, try @list
02:16:15 <quicksilver> and there's not much point railing for ages over accepted usage.
02:16:24 <Maxdamantus> It's more than just functions.
02:16:29 <banisterfiend> quicksilver: yeah i think Zhivago agrees with your definition
02:16:31 <kmc> most languages are functional; most languages support functions
02:16:42 <kmc> C, C++ and Java don't, though there's various ways to hack it
02:16:45 <merijn> banisterfiend: Scheme most definitely functions in the concept of lambda calculus, which is what the entire functional programming thing is based on
02:16:47 <Maxdamantus> I think there needs to be a better word to describe it
02:16:57 <merijn> Anyway, back to boring work
02:16:58 <Jafet> English is surely dysfunctional, if it allows so much confusion over one word
02:17:03 <Maxdamantus> The purely functional aspect
02:17:17 <Maxdamantus> or rather, mathematical
02:17:44 <Maxdamantus> Where in maths you describe facts about some universe
02:20:20 <jnj> Hello. Is this not valid syntax? Data T = T !{x :: Int} How do I make a record strict?
02:20:27 <kmc> x :: !Int
02:20:29 <kmc> maybe?
02:20:55 <kmc> you don't make a whole type or constructor strict; you make individual fields strict
02:21:07 <sipa> or newtype T = T {x :: Int}
02:21:12 <sipa> isn't that identical?
02:21:21 <sipa> semantically
02:21:27 <Jafet> One in which you never hear the phrase "design pattern", perhaps
02:21:29 <kmc> no
02:21:40 <kmc> with the newtype, pattern-matching on T is a no-op
02:21:55 <kmc> with "data", pattern-matching on T forces x to whnf
02:22:10 <sipa> ic
02:22:28 <jnj> Thank you
02:25:51 <Franco_au> hi there
02:26:16 <Franco_au> pretty sure is a dumb question
02:26:49 <Franco_au> i'm trying to load a plugin, that actually imports a plugin
02:27:14 <Franco_au> and I'm getting spit on the face by ghc
02:27:27 <sipa> code? error messages?
02:27:53 <Franco_au> unknown symbol `randomzm1zi0zi0zi2_SystemziRandom_zdfRandomGenStdGen_closure'
02:27:53 <Franco_au> Main: user error (resolvedObjs failed.)
02:28:30 <sipa> how do you compile it?
02:29:07 <Franco_au> with 'make' from System.Plugins
02:29:39 <Franco_au> the problem is that the plugin also imports System.plugins
02:30:19 <Franco_au> didnt pass any arguments to make
02:30:32 <sipa> sorry, no idea in that case
02:31:01 <Franco_au> would you know if is actually possible to load a plugin from a plugin??
02:32:25 <sipa> @hoogle System.plugins
02:32:25 <lambdabot> No results found
02:42:11 <Franco_au> Philippa
02:59:44 <mreh> so I switch on my laptop this morning and find the entire source directory of one of my projects is empty
02:59:59 <mreh> I ask darcs whatsnew and it tells me there is no darcs repository here!
03:01:22 <Entroacceptor> well, it's a good thing you pushed to a remote repository. Right?
03:01:49 <mreh> uhhhhhh
03:01:53 <mreh> yeah....
03:02:08 <mreh> I've got "backups" on the ubuntu cloud
03:02:14 <mreh> but they're useless for version control
03:02:26 <mreh> so I'm back a day or two
03:02:50 <mreh> I want to run darcs on a server ideally, with some kind of redundancy
03:02:58 <mornfall> What filesystem are you using?
03:03:09 <mornfall> Btrfs by any chance? ; - P
03:03:14 <mreh> ext3
03:03:25 <mornfall> That's quite suspicious then.
03:04:02 <mreh> I shuffled a few folders about, it could have been a user error
03:04:18 <mreh> but I can't see how I erased a directory just using mv
03:04:33 <Entroacceptor> maybe you accidently moved it somewhere else?
03:04:46 <mreh> I didn't touch the src directory itself
03:04:47 <Entroacceptor> do a find on $HOME or so?
03:05:08 <Entroacceptor> ext3 is pretty stable...
03:07:20 <Franco_au> :(
03:07:52 <mreh> ubuntuOne only pushes new files, so it's luck that I recovered anything
03:07:56 <mreh> it's a new project
03:08:08 <mreh> I need better measures in place
03:09:10 <mreh> I did do a cabal install of this project last night after it built
03:09:29 <mreh> is there a possibility of recovering from temp build files
03:13:04 <Maxdamantus> > 1 2 3 4 :: Expr
03:13:05 <lambdabot>   1
03:13:36 <Maxdamantus> > f $ 1 2 :: Expr
03:13:37 <lambdabot>   f 1
03:22:02 <ski> kmc : `instance (Finite a,Show a,Show b) => Show (a -> b)'
03:22:37 <ski> btw, O'Caml supports marshalling closures from one process to a process on the same architecture running the same program
03:34:08 <Franco_au> still looking for System.Plugins help!
03:36:34 <Franco_au> :(:(
03:40:49 * Maxdamantus wonders how GHC optimises many (.) applications.
03:41:20 <Maxdamantus> > iterate ((5*) .) id !! 1000000 $ 42
03:41:22 <lambdabot>   *Exception: stack overflow
03:41:29 <Maxdamantus> Oh, meh.
03:41:33 <Maxdamantus> > iterate ((5*) .) id !! 10000 $ 42
03:41:35 <lambdabot>   210519655466670984390497349217205065471505846816213885255700019775728060299...
03:44:09 <Maxdamantus> > iterate (id .) id !! 1000000 $ 42
03:44:11 <lambdabot>   42
03:44:16 <Maxdamantus> > iterate (id .) id !! 10000000 $ 42
03:44:23 <cads> hmm
03:44:24 <lambdabot>   mueval: ExitFailure 1
03:44:41 <cads> can anyone think of how to write a scanl in terms of foldr?
03:45:47 <cads> hehe, I want to write scanl in terms of this crazy mapReduce function, where foldr f z = mapReduce head tail null (const z) f :PPP
03:46:22 <Maxdamantus> Maybe using foldr and iterate?
03:47:16 <Maxdamantus> I'd think foldl would be easier
03:48:34 <cads> I have scanl in terms of foldl, though I haven only the foggiest idea on how to write foldl in terms of mapReduce :P
03:48:46 <cads> have*
03:49:31 <cads> watch, I'll find out that foldl and foldr are dualistic somehow
03:50:26 <Maxdamantus> > iterate ((5*) .) id !! 10000 $ 42 :: Expr
03:50:30 <lambdabot>   mueval-core: Time limit exceeded
03:50:35 <Maxdamantus> > iterate ((5*) .) id !! 100 $ 42 :: Expr
03:50:38 <lambdabot>   5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (...
03:50:57 <xdanek7> hello people, I need to write a lambda expression as a "standard" point free function. And I do not know what should I do with this: \ x y -> 2 * x + y Thanks for your help
03:51:14 <Maxdamantus> @pl \ x y -> 2 * x + y
03:51:14 <lambdabot> (+) . (2 *)
03:51:49 <xdanek7> thanks a lot, Ill do my best to understand it
03:52:32 <Maxdamantus> (2*) takes a number and returns twice it
03:52:42 <xdanek7> I get this part
03:52:50 <Franco_au> when importing System.Plugins from a Plugin ghc crashes!
03:53:17 <cads> xdanek7, that composes a (*2) function onto the first parameter of the (+) function
03:53:20 <Maxdamantus> So (+) "of" it will take a number, and return a function ..
03:54:22 <Maxdamantus> (+) . (2*) = \a -> (+) (2*a)
03:56:35 <Unforgivable> with a datatype like Data vari = I | L [vari]
03:56:42 <Unforgivable> how can I get the length of [vari]
03:56:51 <Unforgivable> length isnt working
03:59:12 <Maxdamantus> What are you trying?
03:59:15 <xdanek7> cads: ok, so (2*) gets applied on the first argument, then (+) is called on the result and the second argument. Is that right?
04:00:03 <Maxdamantus> xdanek7: yes. Do you understand my one-step expansion?
04:00:09 <Maxdamantus> (+) . (2*) = \a -> (+) (2*a)
04:00:32 <xdanek7> no, not really
04:00:42 <Maxdamantus> = \a b -> ((+) (2*a)) b
04:01:03 <xdanek7> ok, i am ok with it
04:01:37 <xdanek7> so (+) . (2*) = \a -> (+) (2*a) is just that written in point free?
04:02:26 <xdanek7> @pl \ x -> 0 < 35 - 3 * 2^x
04:02:27 <Maxdamantus> The = bit isn't actual code, I'm just showing some sort of equivalency
04:02:27 <lambdabot> (0 <) . (-) 35 . (3 *) . (2 ^)
04:02:31 <cads> xdanek7, you may find it easier to see that in general    f . g =  \a -> f (g a). This is a case of that where f is a curried function.
04:11:20 <Franco_au> 2+2
04:11:29 <sipa> > 2+2
04:11:30 <lambdabot>   4
04:11:36 <Franco_au> Plugin HELP!
04:11:56 <Maxdamantus> @help
04:11:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:12:03 <Maxdamantus> @list
04:12:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:19:06 <Franco_au> >2+2
04:19:14 <Franco_au> > 2+2
04:19:15 <lambdabot>   4
04:19:30 <Maxdamantus> >
04:19:33 <ehamberg> if i have a property i want to use for testing with quickcheck, prop_foo :: Double -> Bool, that i only want to test for values ≥ 0, can i tell quickcheck to only generate values ≥ 0?
04:19:49 <Maxdamantus> >  
04:19:50 <lambdabot>   not an expression: `'
04:19:56 <ehamberg> up to this point i have only done “quickCheck my_prop”.
04:20:03 <Franco_au> > putStrLn "Hello"
04:20:04 <lambdabot>   <IO ()>
04:20:14 <Maxdamantus> > str "Hello"
04:20:15 <lambdabot>   Not in scope: `str'
04:20:21 <Maxdamantus> > text "Hello"
04:20:22 <lambdabot>   Hello
04:20:41 <Franco_au> > import System.Plugins
04:20:42 <ski> @src scanl
04:20:43 <lambdabot>   <no location info>: parse error on input `import'
04:20:43 <lambdabot> scanl f q ls = q : case ls of
04:20:43 <lambdabot>     []   -> []
04:20:43 <lambdabot>     x:xs -> scanl f (f q x) xs
04:20:52 <ski> cads : in terms of `foldr', you say ?
04:21:02 <Maxdamantus> :t text
04:21:06 <lambdabot> String -> Doc
04:21:25 <Franco_au> > text ":("
04:21:27 <lambdabot>   :(
04:21:34 <xdanek7> thanks people I finally got it
04:21:50 <Maxdamantus> > map text $ words "foo bar baz"
04:21:51 <lambdabot>   [foo,bar,baz]
04:21:59 <xdanek7> we are taking a test in haskell in two weaks, Youve saved my grade :)
04:22:16 <Franco_au> > text ":("*100
04:22:18 <lambdabot>   No instance for (GHC.Num.Num Text.PrettyPrint.HughesPJ.Doc)
04:22:18 <lambdabot>    arising from...
04:22:34 <Maxdamantus> > read "foo" :: Doc
04:22:35 <lambdabot>   No instance for (GHC.Read.Read Text.PrettyPrint.HughesPJ.Doc)
04:22:36 <lambdabot>    arising fr...
04:23:41 <Franco_au> how can I write in the haskell-in-depth channel?
04:23:46 <ski> > let scanl f q ls = foldr (\x scanl_f_q_xs q -> q : scanl_f_q_xs (f q x)) (\q -> [q]) ls q in scanl (+) 100 [0,1,2,3]
04:23:47 <lambdabot>   [100,100,101,103,106]
04:23:51 <ski> > scanl (+) 100 [0,1,2,3]
04:23:52 <lambdabot>   [100,100,101,103,106]
04:23:58 <ski> cads : does that suffice ?
04:26:00 <Maxdamantus> > let scanl f q ls = foldr (\x scanl_f_q_xs q -> q : scanl_f_q_xs (f q x)) (\q -> [q]) ls q in fix $ (1:) . scanl (+) 1
04:26:02 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
04:30:57 <ski> Maxdamantus,cads : there might be some strictness difference between the two implementations .. but both work on infinite lists, at least
04:41:45 <cads> ski, that's too advanced I think
04:42:13 <Maxdamantus> @pl scanl f q ls = foldr (\x scanl_f_q_xs q -> q : scanl_f_q_xs (f q x)) (\q -> [q]) ls q
04:42:13 <lambdabot> scanl = flip . flip foldr return . (((ap (:) .) . flip (.)) .) . flip
04:43:20 <Maxdamantus> > fix $ (1) . (flip . flip foldr return . (((ap (:) .) . flip (.)) .) . flip) (+) 1
04:43:21 <lambdabot>   No instance for (GHC.Num.Num [a])
04:43:21 <lambdabot>    arising from a use of `e_111' at <inte...
04:43:35 * hackagebot vty 4.4.0.0.1 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.4.0.0.1 (PeterSimons)
04:44:07 <Maxdamantus> :t (flip . flip foldr return . (((ap (:) .) . flip (.)) .) . flip)
04:44:08 <lambdabot> forall a a1. (a -> a1 -> a) -> a -> [a1] -> [a]
04:44:24 <ski> cads : it's basically "leaning so far right it comes back as left"
04:44:27 <Maxdamantus> :t let scanl f q ls = foldr (\x scanl_f_q_xs q -> q : scanl_f_q_xs (f q x)) (\q -> [q]) ls q in scanl
04:44:28 <lambdabot> forall a a1. (a -> a1 -> a) -> a -> [a1] -> [a]
04:44:53 <Maxdamantus> > let scanl = (flip . flip foldr return . (((ap (:) .) . flip (.)) .) . flip) in fix $ (1:) . scanl (+) 1
04:44:55 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
04:45:01 <ski> (btw, you can of course rename `scanl_f_q_xs' to some other name, if you wish)
04:45:28 <Maxdamantus> > fix $ (1:) . (flip . flip foldr return . (((ap (:) .) . flip (.)) .) . flip) (+) 1
04:45:29 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
04:45:33 <Maxdamantus> @pl fix $ (1:) . (flip . flip foldr return . (((ap (:) .) . flip (.)) .) . flip) (+) 1
04:45:34 <lambdabot> fix ((1 :) . flip (foldr ((ap (:) .) . flip (.) . (+)) return) 1)
04:45:51 <Maxdamantus> @unpl fix ((1 :) . flip (foldr ((ap (:) .) . flip (.) . (+)) return) 1)
04:45:52 <lambdabot> fix (\ n -> 1 : (foldr (\ q ac -> (:) >>= \ s -> (\ k -> ac (q + k)) >>= \ r -> return (s r)) return n 1))
04:46:03 <nus> heh
04:46:18 <Maxdamantus> @src foldr
04:46:18 <lambdabot> foldr f z []     = z
04:46:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:47:03 <cads> ski, check it out: http://hpaste.org/40738/assignment?pid=40738&lang_40738=
04:47:12 <cads> the last line is the only one left to do :)
04:47:44 <Maxdamantus> @pl f 0 = 42; f n = 2*n in f 0
04:47:45 <lambdabot> (line 1, column 9):
04:47:45 <lambdabot> unexpected ";"
04:47:45 <lambdabot> expecting digit, variable, "(", operator or end of input
04:48:02 * Maxdamantus wonders if if/else can be modelled for @pl
04:48:59 <cads> I think I'm going to just literally translate  scanr f z =  map (foldl (f) z) $ inits or something
04:49:01 <Maxdamantus> @pl \a -> if (a == 0) then 42 else 2*a
04:49:01 <lambdabot> ap (flip if' 42 . (0 ==)) (2 *)
04:49:06 <Maxdamantus> O_o
04:50:30 <cads> > scanr (+) z [a, b, c, d]
04:50:31 <lambdabot>   [a + (b + (c + (d + z))),b + (c + (d + z)),c + (d + z),d + z,z]
04:51:11 <cads> > map (foldl (+) z) $ inits [a, b, c, d]
04:51:13 <lambdabot>   [z,z + a,z + a + b,z + a + b + c,z + a + b + c + d]
04:51:14 <Maxdamantus> > fix $ (a:) . scanl (+) a
04:51:15 <lambdabot>   [a,a,a + a,a + a + a,a + a + a + (a + a),a + a + a + (a + a) + (a + a + a),...
04:51:30 <cads> > scanl (+) z [a, b, c, d]
04:51:31 <lambdabot>   [z,z + a,z + a + b,z + a + b + c,z + a + b + c + d]
04:51:38 <ski> cads : oh, `scanr' .. i though you wanted to express `scanl'
04:51:59 <cads> actually, it is scanl, I was mistaken
04:52:04 <cads> @type scanl1
04:52:05 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
04:52:13 <cads> @type scanl
04:52:14 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
04:52:19 <cads> ah
04:52:21 <cads> cute
04:52:32 <cads> must implement scanl1, to be specific
04:53:14 <cads> @type mapReduce
04:53:15 <lambdabot> forall a1 a b. (a1 -> a) -> (a1 -> a1) -> (a1 -> Bool) -> (a1 -> b) -> (a -> b -> b) -> a1 -> b
04:53:50 <Axman6> > fix $ (1:) . scanl (+) 1
04:53:51 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
04:54:00 <cads> hah
04:54:42 <Maxdamantus> > let a = 1 in [a,a,a + a,a + a + a,a + a + a + (a + a)]
04:54:43 <lambdabot>   [1,1,2,3,5]
04:56:26 <cads> @src inits
04:56:27 <lambdabot> inits []     =  [[]]
04:56:27 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
04:56:45 <Maxdamantus> > (f .)
04:56:46 <lambdabot>   Overlapping instances for GHC.Show.Show (f a -> f b)
04:56:47 <lambdabot>    arising from a use ...
04:57:01 <XXX> does anobody familier with ordinal powers?
05:00:22 <cads> > let supaflup f z = mapreduce ((mapReduce head tail null (const z) f) . head) tail null (const []) (:) $ inits in supaflup (+) 0 [a,b,c]
05:00:23 <lambdabot>   Not in scope: `mapreduce'
05:00:34 <cads> > let supaflup f z = mapReduce ((mapReduce head tail null (const z) f) . head) tail null (const []) (:) $ inits in supaflup (+) 0 [a,b,c]
05:00:36 <lambdabot>   Couldn't match expected type `[[a]]'
05:00:36 <lambdabot>         against inferred type `[a1] ->...
05:00:41 <cads> damnit :D
05:01:24 <Maxdamantus> > z a b
05:01:25 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
05:01:26 <lambdabot>                           ...
05:01:32 <Maxdamantus> > z a
05:01:33 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
05:01:33 <lambdabot>         against infe...
05:01:53 <Maxdamantus> > g a b
05:01:54 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:01:54 <lambdabot>    `GHC.Show.Show a'
05:01:55 <lambdabot>      a...
05:02:31 <cads> > let supaflup f z xs = mapReduce ((mapReduce head tail null (const z) f) . head) tail null (const []) (:) $ inits xs in supaflup (+) 0 [a,b,c]
05:02:32 <lambdabot>   [0,a + 0,a + (b + 0),a + (b + (c + 0))]
05:03:17 <cads> > scanl1 (+) 0 [a,b,c]
05:03:18 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr] -> t'
05:03:19 <lambdabot>         against in...
05:03:32 <cads> > scanl (+) 0 [a,b,c]
05:03:33 <lambdabot>   [0,0 + a,0 + a + b,0 + a + b + c]
05:04:01 <cads> > scanr (+) 0 [a,b,c]
05:04:02 <lambdabot>   [a + (b + (c + 0)),b + (c + 0),c + 0,0]
05:04:26 <ray> oh my gah
05:04:57 <Maxdamantus> > (a + b) + c
05:04:59 <lambdabot>   a + b + c
05:05:06 <Maxdamantus> > a + (b + c)
05:05:07 <lambdabot>   a + (b + c)
05:05:26 <cads> ray, this is just sickening
05:05:48 <ray> > fix (1:)
05:05:49 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:05:55 <cads> ski, thanks for the input, sorry I couldn't understand it well enough to help my implementation
05:05:59 <ray> needed a left bracket to copy
05:06:11 <ray> phone keypad lacks it
05:06:37 <ray> > take 1 (fix (1:))
05:06:37 <lambdabot>   [1]
05:06:46 <ray> and there is my rbracket
05:07:03 <ray> @faq can #haskell overcome phone deficiencies?
05:07:03 <lambdabot> The answer is: Yes! Haskell can do that.
05:08:58 <Maxdamantus> @faq Can Haskell have a negative effect on world hunger?
05:08:59 <lambdabot> The answer is: Yes! Haskell can do that.
05:10:29 <hpc> @faq Can Haskell divide by zero?
05:10:30 <lambdabot> The answer is: Yes! Haskell can do that.
05:10:34 <hpc> > 1/0.
05:10:35 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:10:43 <hpc> >1.0 / 0
05:10:47 <hpc> > 1.0 / 0
05:10:48 <lambdabot>   Infinity
05:10:49 <hpc> :D
05:10:50 <Kaidelong> > 1/0
05:10:52 <lambdabot>   Infinity
05:10:53 <Kaidelong> should work
05:10:54 <Kaidelong> yep
05:11:02 <hpc> ah right, forgot
05:11:03 <Kaidelong> no need to be all OCaml about it
05:11:04 <nlogax> > 1/0 + 1/0
05:11:05 <Maxdamantus> > 1.0/0-1
05:11:06 <lambdabot>   Infinity
05:11:06 <lambdabot>   Infinity
05:11:14 <nlogax> i expected at least two infinities!
05:11:19 <Maxdamantus> > 1.0/0-1.0/0
05:11:20 <lambdabot>   NaN
05:11:23 <hpc> been dealing with python recently and forgot that Haskell has sensible types
05:11:37 <Maxdamantus> > toInteger $ 1.0/0-1
05:11:38 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:11:38 <lambdabot>    `GHC.Real.Fractional a'
05:11:38 <lambdabot> ...
05:11:44 <hpc> (also been dealing with iRobot Create, but that's a whole other wtf)
05:12:15 <Kaidelong> > let signum x = 1 - (2/(1-(1/0)**x)) in signum 0.45911
05:12:17 <lambdabot>   1.0
05:12:32 <sipa> @vixen do you have any form of intelligence?
05:12:33 <lambdabot> maybe. do you?
05:13:09 <hpc> win
05:13:39 <Kaidelong> I promised to look something up for conal and will probably be headed home next week but now I can't remember what it was
05:14:28 <hpc> this calls for channel logs and some ingenious grep-fu
05:15:59 <cads> @vixen smack me up and call me your own.
05:16:00 <lambdabot> its ringing
05:48:19 <Unforgivable> what is the 'console' thing called in winhugs
05:48:25 <Unforgivable> does that have a specific name or just console :p
05:48:35 <cncl> REPL?
05:49:55 <Unforgivable> REPL?
05:50:19 <fasta> @go repl
05:50:45 <Unforgivable> I see, REPL it is, thanks :)
05:51:01 <Philippa> "Read Eval Print Loop". It's really only that if you're talking about a lisp or close relative, but I guess it'll do
05:54:19 <hpc> it's descriptive enough to apply to any language if you discount the often-specific definition of "eval"
06:12:17 <FunctorSalad_> just curious, is this passage from the STG paper still true? " Secondly, modern RISCs are
06:12:18 <FunctorSalad_> well optimised for taking conditional jumps (employed by the cell model), but not for taking
06:12:18 <FunctorSalad_> indirect jumps (which are needed by the self-updating model)."
06:12:56 * FunctorSalad_ thought OO implementations use indirect jumps too
06:13:14 * FunctorSalad_ thinks that in that case, hardware may well have caught up with it already
06:13:39 <Franco_au> exit
06:14:16 <Jafet> The method dispatch table? That's pretty static.
06:14:40 <Jafet> What's a "modern RISC"?
06:15:19 <sipa> ARM?
06:15:27 <FunctorSalad_> Jafet: 1992 :)
06:15:27 <Axman6> jkoshy: less R
06:15:34 <Axman6> uh, Jafet*
06:15:45 <nus> powerpc
06:15:57 <FunctorSalad_> Jafet: it may be static, but isn't it still indirect?
06:17:16 <FunctorSalad_> since it isn't in general statically known *which* dispatch table you'll use for a given call
06:17:26 <Jafet> Well, I guess that's why no one uses late polymorphism on a cray.
06:18:12 <FunctorSalad_> hmm
06:30:31 <siracusa> Can someone point me to an example how to create callback functions in Haskell, that can be passed as an argument to a foreign C function?
06:31:57 <sipa> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Callbacks_into_Haskell_from_foreign_code
06:33:14 <siracusa> Ah thanks
06:40:28 <EvanR-work> that transformerless 'monad stack' worked out well
06:41:20 <EvanR-work> newtype DbAccess a = DbAccess (Db -> IO (DbResult a, Integer))
06:42:48 <EvanR-work> data DbResult a = DbOk a | DbNotOk Feedback
06:43:22 <EvanR-work> keeps a count of affected rows, exits early when DbNotOk, and operates in the environment containing the lazy db connection
06:47:42 <EvanR-work> and you can exit early manually to create a validating action
06:54:38 <jmcarthur> EvanR-work: i'm glad that it worked out for you. i have a personal interest in improving monad composition. you have already tried to explain your distaste for transformers, but now that you have implemented this without transformers, can you explain in detail exactly what it is about transformers that you do not like?
06:55:14 <jmcarthur> i want to emphasize that i'm hoping for a very specific, explicit answer, so take all the time you need to come up with a good one
06:55:16 <EvanR-work> well to do the above it would have required more code in the implementation
06:55:22 <EvanR-work> oh nevermind then
06:55:56 <EvanR-work> ill need to compile a report
06:56:13 <jmcarthur> heh, i wasn't necessarily wanting to ask you to write up "at least 1000 words" or anything ;)
06:57:10 <EvanR-work> fewer words, more code examples
06:58:12 <EvanR-work> i dont have a distaste, at the moment
06:58:55 <jmcarthur> the way *i* would have prefered to write your monad is like this:  (->) Db . IO . (,) Integer . DBResult  for some definition of type level (.) with instances for monad composition (there are at least four possible ways to compose monads, so it might have to be multiple kinds of .)
06:59:26 <jmcarthur> if that had been available to you you could have written that without using any transformers and still used generalized newtype deriving to get a sensible monad
06:59:54 <jmcarthur> the downside is that you still would have had to go through some sort of equivalent "lift" boilerplate to create your operations on it
07:00:33 <EvanR-work> i noticed i got some things i would not have gotten with ExitT something
07:01:00 <jmcarthur> hmm... although it occurs to me that perhaps there could be a generic inComposition function to apply a function to a decomposed version of the type
07:01:00 <EvanR-work> one was because of ExitTs interface, it can only exit, the 'a' is never returned
07:01:38 <EvanR-work> so i probably wanted a different transformer
07:01:50 <jmcarthur> ah!
07:01:59 <jmcarthur> that may be what your (main) problem was
07:01:59 <int-e> is the Integer a total count?
07:02:07 <EvanR-work> i dont think so
07:02:15 <EvanR-work> int-e: yes
07:02:26 <jmcarthur> oh (,) Integer itself isn't a monad unless it's actually something like (,) (Sum Integer)
07:02:32 <int-e> so you have a writer (over Sum Integer monoid) there.
07:02:38 <EvanR-work> jmcarthur: the other thing is that ReaderT and similar are all instances of MonadIO
07:02:58 <jmcarthur> EvanR-work: do you mean that as a good thing or a bad thing?
07:03:00 <EvanR-work> so to 'unexport' aribtrary i would have needed to newtype and reimplement all the interfaces i did want
07:03:09 <EvanR-work> no i dont want arbitrary IO in DbAccess
07:03:17 <jmcarthur> EvanR-work: GeneralizedNewtypeDeriving
07:03:17 <EvanR-work> only dbQuery, dbModify, and dbExit
07:03:22 <EvanR-work> ah that
07:03:37 <jmcarthur> EvanR-work: all you have to do is say deriving (All, The, Instances, You, Want, To, Export)
07:03:38 <int-e> jmcarthur: but you can decide not to derive MonadIO in the newtype for the monad stack (and you should use a newtype, not a type alias)
07:03:44 <jmcarthur> int-e: right
07:03:56 <jmcarthur> maybe that was directed at the wrong person?
07:03:56 <EvanR-work> piling more and more extensions was one of the reasons i was getting antsy about all the transformers
07:04:04 <int-e> jmcarthur: right.
07:04:11 <jmcarthur> EvanR-work: i don't mind extensions, personally
07:04:16 <benmachine> jmcarthur: there are at least four ways to compose monads? how does that work?
07:04:24 <jmcarthur> EvanR-work: although i avoid fundeps because type families is so much nicer, IMO
07:04:32 <EvanR-work> i was getting overwhelmed by all the meanings
07:04:39 <jmcarthur> benmachine: http://web.cecs.pdx.edu/~mpj/pubs/composing.html
07:04:44 <EvanR-work> i like my simpleton haskell world view
07:04:46 <EvanR-work> at the moment
07:04:47 <jmcarthur> benmachine: not all monads can be composed in all ways
07:05:07 <jmcarthur> EvanR-work: heh
07:05:21 <EvanR-work> newtype deriving does sound nice
07:05:44 <benmachine> jmcarthur: oh, right, that makes sense
07:05:49 <jmcarthur> EvanR-work: newtype deriving is also a fairly conservative extension. all it does it create an instance that wraps and unwraps. it doesn't try to infer any actual functionality
07:06:11 <EvanR-work> that makes sense because thats exactly the case that i think is abhorent
07:06:19 <EvanR-work> it makes me feel like im writing c++
07:06:19 * benmachine saves paper to his 'papers' folder, into which knowledge seems to enter at great rate but never leave
07:06:31 <jmcarthur> EvanR-work: for full disclosure, there have been some reports of GND creating some instances that it shouldn't be able to, but i have never run into that myself
07:06:37 <Twey> benmachine: Haha
07:06:48 <jmcarthur> EvanR-work: by "shouldn't be able to" i mean "using constructors not in scope"
07:07:04 <EvanR-work> that just sounds like a bug not a fundamental flaw in the idea
07:07:10 <jmcarthur> i agree
07:07:18 <benmachine> jmcarthur: GND has actually been unsound sometimes, but I think that requires contrived examples
07:07:38 <EvanR-work> if haskell fails in the face of contived examples, that wouldnt be good
07:07:51 <benmachine> no indeed it wouldn't
07:07:52 <jmcarthur> benmachine: unsound in the sense of using unexported functionality?
07:08:03 <jmcarthur> or in the sense of allowing you to coerce types?
07:08:07 <benmachine> jmcarthur: unsound as in permitting definitions that can't be given without the extension
07:08:13 <benmachine> I don't recall if it allowed arbitrary coercions
07:08:17 <jmcarthur> ah right, i was aware of that one
07:08:20 * benmachine searches for the ticket
07:08:28 <jmcarthur> standalone deriving makes the situation even worse
07:08:32 <benmachine> jmcarthur: not because of scoping but because they're actually impossible though
07:08:36 <benmachine> like
07:08:57 <benmachine> hmm
07:09:30 <jmcarthur> i'd still say this sounds like an implementation bug, not a theoretical bug
07:09:54 <benmachine> yes, certainly
07:09:56 <jmcarthur> if the implementation was syntactic then it wouldn't be a problem
07:10:01 <benmachine> but a potentially significant one!
07:10:06 <benmachine> although
07:10:14 <benmachine> probably not because contrived
07:10:34 <benmachine> and also even less so because at the moment all I have as evidence it ever existed is my vague memory
07:10:42 <EvanR-work> at some point i came to the realization that runExit and runExitT doesnt give the a value of type a
07:10:43 <jmcarthur> i do remember it as well
07:10:47 <jmcarthur> benmachine: you're not crazy
07:10:49 <EvanR-work> and now im confused how its a monad at all
07:11:00 <jmcarthur> EvanR-work: what is the type of its run function?
07:11:48 <benmachine> jmcarthur: well, not on the basis of this issue, anyway :P
07:11:53 <jmcarthur> heh
07:12:09 <EvanR-work> :: Exit e a -> e
07:12:19 * jmcarthur blinks
07:12:26 <int-e> benmachine: well the type family examples aren't that contrived. define a family Foo with Foo () = Int, and Foo (Bar ()) = Bool, where Bar is a newtype. Add a type class with an operation foo :: Foo a -> Int, implemented for (). Then use GND to make an instance for Bar ().
07:12:27 <jmcarthur> newtype Exit e a = Exit e  ?
07:12:50 <jmcarthur> ^^ a "trivial" monad
07:13:10 <jmcarthur> well
07:13:11 <benmachine> http://hackage.haskell.org/trac/ghc/ticket/1496 heeeere we are
07:13:12 <jmcarthur> not quite trivial
07:13:13 <int-e> benmachine: type families break the assumption of GND that if a and b have the same representation then f a and f b also do, for any type constructor f.
07:13:34 <benmachine> int-e: right
07:13:34 <jmcarthur> trivial if you assume some semantics on the e
07:13:44 <jmcarthur> monoid or something
07:14:10 <EvanR-work> e is the argument to the first use of exitWith :: e -> Exit e a
07:14:29 <jmcarthur> EvanR-work: what if exitWith is never used?
07:14:32 <EvanR-work> data Exit e a = Continue a | Exit e
07:14:36 <EvanR-work> jmcarthur: error
07:14:39 <jmcarthur> ah!
07:14:42 <jmcarthur> so it's partial
07:15:18 <EvanR-work> for some reason i thought this monad was so cool
07:15:29 <EvanR-work> but its like what
07:15:30 <jmcarthur> EvanR-work: i'd say it sounds equivalent to Writer (First e) a, except it doesn't give you a real return value
07:16:12 <jmcarthur> of course, Writer (First e) a allows you to continue even after exitWith
07:16:26 <EvanR-work> right thats the point of Exit, to not continue
07:16:54 <jmcarthur> what i mean is that Exit looks like a subset of the functionality of Writer (First e)
07:17:29 <EvanR-work> guess i dont know what First does
07:17:42 <benmachine> First is a monoid on Maybes a bit like mplus
07:17:50 <jmcarthur> > First Nothing `mappend` First (Just 5) `mappend` First (Just 6)
07:17:54 <EvanR-work> so it lets you exit early?
07:18:04 <jmcarthur>  First (Just 5)
07:18:26 <jmcarthur> EvanR-work: it ignores everything after the first Just it gets
07:18:49 <EvanR-work> but doesnt carry any data up to that point
07:18:53 <jmcarthur> right
07:19:10 <EvanR-work> is that what the writer is for
07:19:11 <jmcarthur> if there is an evalWriter function then that would be the runExit
07:19:39 <jmcarthur> writer is for accumulation. it just happens that First's accumulation is to only store the first Just it sees
07:20:00 <jmcarthur> i mean execWriter
07:20:03 <jmcarthur> not evalWriter
07:20:38 <EvanR-work> the first thing i thought of was 'EitherT'
07:20:43 <jmcarthur> execWriter :: Writer w a -> w
07:21:14 <jmcarthur> Either also works, but it would give you a different run function
07:21:19 <EvanR-work> runEitherT :: EitherT e m a -> m (Either e a)
07:21:24 <jmcarthur> that is, it gives you an either :)
07:22:06 <jmcarthur> runExitT = liftM fromLeft . runEitherT
07:22:29 <jmcarthur> that is assuming that EitherT has the sane semantics for an Either monad and not the stupid one
07:22:45 <EvanR-work> but since i just basically made that stuff up, and someone showed me a ExitT which was made up by someone else, i figured it was more valid ;)
07:22:59 <EvanR-work> also 1 days ago i wasnt totally clear about how to even implement monads ;)
07:23:21 <jmcarthur> the key is to simply not think about implementing monads
07:23:46 <jmcarthur> if you notice that you just made a monad, hey it's a monad!
07:23:58 <EvanR-work> yeah but i never would have guessed the Reader pattern
07:24:06 <EvanR-work> but i knew thats what i wanted
07:24:19 <jmcarthur> that's only a partial truth though. i have to admit that i often made a type with the explicit goal of making a monad instance
07:24:26 <jmcarthur> *make
07:24:49 <waterlaz|work> is there a good reason not to support things like 2 `(\a b -> a + b)` 3   ?
07:24:50 <jmcarthur> but when i do that i have a very specific composition of existing types in mind and i just happen to know in advance that it will form a monad
07:25:20 <sipa> waterlaz|work: because you can write it as 2 + 3? ;)
07:25:21 <EvanR-work> reminds me, i need to make sure that DbAccess a is actually a monad
07:25:26 <EvanR-work> DbAccess
07:25:33 <jmcarthur> EvanR-work: what's its run function?
07:25:34 <waterlaz|work> sipa, just an example
07:25:40 <jmcarthur> the type of it, imean
07:25:40 <EvanR-work> theres two
07:25:42 <jmcarthur> *i mean
07:25:50 <EvanR-work> one for read only one for transaction
07:26:00 <jmcarthur> EvanR-work: do either of the run functions serve as a good "model" for the type?
07:26:01 <sipa> waterlaz|work: yeah i know - i guess it would lead to hard to parse code
07:26:22 <waterlaz|work> you mean hard for a human?
07:26:34 <sipa> 2 `(
07:26:38 <jmcarthur> EvanR-work: the type signature for a monad's run function is usually the quickest way to tell what a monad means, IME
07:26:54 <waterlaz|work> I don't see much complication for the machine here
07:27:03 <sipa> 2 `(\a b -> b `(\c d -> c * d)` a)` 3
07:27:21 <sipa> would that be valid as well?
07:27:33 <waterlaz|work> I guess not
07:27:43 <jmcarthur> 2 `foo `wibble` bar` 3
07:28:46 <waterlaz|work> well the solution here would be not to have any nested bnackquotes
07:28:57 <jmcarthur> i should quite calling types monads
07:29:39 <nus> waterlaz|work, let's put it other way around, what would be a *good* reason to support it?
07:30:46 <jmcarthur> EvanR-work: if you can model DBAccess as a composition of existing types which form a valid monad, then you can be certain that at least the idea of DBAccess forms a monad :)
07:30:50 <waterlaz|work> nus I sometimes have to find an urge t owrite some expression as an operator
07:30:52 <waterlaz|work> :)
07:30:59 <waterlaz|work> *have to fight
07:31:12 <jmcarthur> incidentally, this is exactly why i prefer to compose types to create new types. it allows many of your models to be your implementations
07:31:28 <EvanR-work> jmcarthur: runDbQuery :: DbAccess a -> Db -> IO (DbResult a)
07:31:49 <sipa> > let plus = (+) in (5 `plus`) 3
07:32:01 <jmcarthur> EvanR-work: is DBResult a monad?
07:32:13 <EvanR-work> theres no instance
07:32:22 <nus> waterlaz, write as a prefix application?
07:32:26 <EvanR-work> its there to identify results vs errors
07:32:35 <jmcarthur> ah, so it's basically Either?
07:32:44 <EvanR-work> DbOk a | DbNotOk Feedback
07:32:47 <jmcarthur> yup
07:32:51 <jmcarthur> okay, so it forms a monad too
07:32:53 <EvanR-work> i want to parameterize the Feedback
07:33:11 <jmcarthur> looks like a potentially valid monad to me
07:33:18 <jmcarthur> DBQuery that is
07:34:43 <jmcarthur> (->) Db . IO . Either Feedback
07:35:21 <jmcarthur> or in mtl terms i think it would look something like this:    ReaderT DbAccess (EitherT IO Feedback)
07:35:40 <jmcarthur> i never remember some transformer types though. EitherT just seems strange to me
07:35:52 <jmcarthur> i much prefer monad composition
07:36:37 <jmcarthur> ah yes, i was making the right assumptions about EitherT
07:36:54 <jmcarthur> but wrong parameter order
07:37:12 <jmcarthur> ReaderT DbAccess (EitherT Feedback IO)
07:37:19 <EvanR-work> yeah
07:37:29 <EvanR-work> thats the end result
07:37:35 <EvanR-work> but i dont have internet so i cant download EitherT ;)
07:37:39 <jmcarthur> heh
07:37:40 <EvanR-work> unless its in mtl
07:37:45 <jmcarthur> that's not the point
07:38:01 <jmcarthur> the point is that since you can model it this way, all you have to do is make sure that your implementation fits the model
07:38:08 <jmcarthur> and then you can be certain that you have a valid monad
07:38:12 <EvanR-work> that particular model allows MonadIO
07:38:16 <jmcarthur> without even necessarily having to prove the laws yourself
07:38:20 <EvanR-work> right
07:38:34 <jmcarthur> yes, the model does, but that doesn't mean you have to expose it :)
07:38:42 <EvanR-work> newtype deriving!
07:38:50 <EvanR-work> lots of moving parts :(
07:38:58 * jmcarthur facepalms
07:39:07 <EvanR-work> lol
07:39:24 <EvanR-work> also i dont want to ask
07:39:30 <EvanR-work> for the connection
07:39:40 <EvanR-work> 'user code' should have access to it
07:39:43 <EvanR-work> shoudlnt
07:39:59 <EvanR-work> basically its not a instance of any MonadFoo class
07:40:07 <jmcarthur> this is what modules are good for :)
07:40:16 <EvanR-work> ah right
07:40:23 <EvanR-work> dont export MonadIO or MonadReader
07:40:41 <jmcarthur> well, don't implement those for your newtype
07:40:51 <jmcarthur> and don't expose the implementation of your newtype
07:40:57 <jmcarthur> and you're good :)
07:41:22 <dmwit> I don't even have a newtype... DAMN! I'm GOOD!
07:41:45 <dmwit> @yow!
07:41:51 <jmcarthur> no LB right now :(
07:44:44 <BONUS> hey whats that hackage module with the ridiculous type declarations
07:44:53 <quicksilver> session types?
07:44:57 <BONUS> yeah, that's it
07:45:04 <BONUS> thx
07:45:19 <quicksilver> http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
07:45:26 <BONUS> haha i always get a laugh out of those
07:45:41 <BONUS> is that something someone can actually hope to understand or?
07:45:47 <sproingie> there should be a DSL that generates those types
07:46:04 <quicksilver> BONUS: sure, if you read matthew's thesis
07:46:08 <quicksilver> the ideas aren't especially complex
07:46:15 <quicksilver> it's the encoding of them into haskell that's a pain
07:46:23 <sproingie> theoretically they're not hard to understand but as the actual type signature goes they seem to be a write-only language
07:46:28 <BONUS> ah. i'll read the thesis then
07:50:12 * ksf would still like to see a dsl that models everything an (insert architecture) elf binary needs to run.
07:51:21 <ksf> ...and that, of course, would then compile an elf to a native binary that's at least as fast as the original one.
07:59:42 <roconnor> > 2^50
08:00:35 <drhodes> 1125899906842624
08:00:51 <quicksilver> 1125899906842624
08:01:25 <sipa> 1073741824*1048576
08:02:04 <quicksilver> 42
08:03:08 <merijn> Haskell is bad for your social live, the more I hang out here, the more only PhD's and people in here think my jokes are funny...
08:03:20 <sipa> in base (2^45-1/2), that's true, quicksilver
08:03:28 <sipa> eh 2^48-1/2
08:03:43 <quicksilver> sipa: I was working modulo 297467
08:03:51 <quicksilver> that's how my custom ASICs roll.
08:03:52 <sipa> oh, carry on
08:04:02 <sipa> (and yes, i know h2g2)
08:31:41 <dumael> merijn: like http://www.phdcomics.com/comics.php?f=868 ?
08:33:33 <merijn> dumael: Pretty much :p
08:36:02 <ski> Unforgivable : "interactor" ?
08:51:21 <aristid> how well does ghc work on os x right now? *curious*
08:52:30 <quicksilver> fine
08:52:35 <quicksilver> I've only ever really used it on OSX
08:52:38 <quicksilver> and it's always been fine
08:53:11 <ahihi> I think it still doesn't build 64-bit
08:53:21 <ahihi> otherwise no problems here
08:54:42 <wjt> what's standing in the way of a 64-bit build? just fixing up trivia?
08:55:32 <ahihi> http://hackage.haskell.org/trac/ghc/ticket/2965
08:56:52 <merijn> Looks like it'll be fixed in 6.14
08:56:56 <merijn> "I think #4163 is far enough along that we'll be able to use cross-compilation to bootstrap 6.14.1 on OSX 64."
08:57:24 <quicksilver> that'd be nice.
08:57:31 <wjt> ace.
08:58:29 <roconnor> @seen ndm
08:58:30 <preflex>  ndm was last seen on #haskell 1 year, 165 days, 5 hours, 39 minutes and 48 seconds ago, saying: plus with current compiler technology, it would be slower
08:58:37 <roconnor> :(
08:59:53 <quicksilver> roconnor: ndm's been around more recently than that, but with a nick that preflex doesn't remember for unknown reasons.
09:00:04 <quicksilver> roconnor: still, he's not around much now he has a real job.
09:00:25 <roconnor> :(
09:00:35 <roconnor> why did he get a real job?
09:01:06 <quicksilver> history does not relate.
09:01:12 <zygoloid> they offered him a banker's salary
09:01:20 <roconnor> oh
09:01:23 <quicksilver> he's contactable by email. His last email to the -cafe was yesterday.
09:01:38 <roconnor> heh, I'd take a banker's salary too
09:02:29 <quicksilver> the trick is knowing where to hide when the banker asks for it back.
09:02:30 * zygoloid turned down a banker's salary to not have to work in london
09:05:23 * digitteknohippie turned down all salary to not have to work / have a boss.
09:05:40 <zygoloid> roconnor: the hours are long, and the way ndm said that no-one had shouted at him yet worries me
09:05:49 <benmachine> zygoloid: I'd turn down a banker's salary to stay in london >_>
09:06:03 * benmachine resents tiny town
09:06:39 <zygoloid> benmachine: toilet time for tiny town?
09:06:52 <fasta> zygoloid, how much is that exactly?
09:06:53 <benmachine> zygoloid: uhm
09:06:55 <benmachine> sure
09:06:59 <benmachine> (yes I get the reference)
09:07:25 <quicksilver> I like working in london, but I would not like long hours.
09:07:37 <fasta> There are bankers that make 10mil+ and developers for such banks that get 30K pounds.
09:08:09 <fasta> There are other devs that get 300K$ but you have to be fairly special to get that. 
09:09:26 <zygoloid> fasta: six figures including bonus, high five figures without
09:09:52 * shapr hugs quicksilver 
09:10:07 <fasta> zygoloid, that's not even that much considering how much money is at stake.
09:10:39 <fasta> zygoloid, where do you work now?
09:11:35 <zygoloid> fasta: i'm at an EDA company
09:11:48 <fasta> zygoloid, no idea what EDA stands for.
09:11:57 <themonoid> @help
09:12:12 <fasta> zygoloid, and google returns ambiguous results :)
09:12:16 * quicksilver suspects http://en.wikipedia.org/wiki/Electronic_design_automation
09:12:27 <zygoloid> fasta: what quicksilver said. ASIC optimization.
09:12:28 <fasta> quicksilver, me too
09:12:37 <themonoid> @kind fmap
09:12:53 <quicksilver> I had a smart co-PhD who went off to ARM to work in logic/hardware verification
09:12:57 <fasta> zygoloid, do you have any specific electronics knowledge? 
09:12:57 <quicksilver> that sounded interesting. But hard.
09:13:46 <fasta> I would find it a nightmare to find a bug in a real system as opposed to a model of such a system.
09:13:48 <zygoloid> fasta: i had an A-Level in electronics before starting, and i've picked up a lot on the job
09:14:11 <fasta> You cannot say 'the universe is wrong'.
09:14:31 <fasta> Whereas you can say 'the CPU computes the wrong answer'.
09:14:39 <zygoloid> we don't get anywhere near the actual silicon. more like writing backend optimizations for what are essentially verilog to silicon compilers
09:15:34 <fasta> I did a seminar on graph drawing where I read some papers on how to optimize layout, etc. 
09:15:56 <fasta> It seemed fairly non-advanced as things go, but maybe all the interesting stuff is closed/non-published.
09:16:38 <fasta> The whole concept of 'designing a CPU' seems backwards to me. It should be the press of a button. 
09:16:57 <fasta> As your optimizer finds better answers, you ship new CPUs.
09:16:58 <zygoloid> layout optimization is pretty hard when you take into account all the relevant constraints
09:17:33 <fasta> Instead what is being done, AFAIK, is that there are all kinds of humans that interfere with the process.
09:17:50 <zygoloid> each time you tape out a new chip, that costs you somewhere in the ballpark of $1m
09:18:19 <fasta> zygoloid, if you have one of those ASML machines, why is that the case?
09:19:09 <fasta> If it costs 'billions' to build a new factory, something is terribly wrong. 
09:19:28 <sproingie> uh chip fab is sensitive fiddly expensive stuff
09:19:29 <quicksilver> 10 billion, didn't Intel say, for their new fab in oregon?
09:19:33 <zygoloid> fasta: i'm not sure exactly where the money goes but i think a lot of it goes towards the construction of masks
09:19:59 <stepkut> zygoloid: the masks that the workers wear? stupid unions..
09:20:06 <fasta> quicksilver, right, but I think that's a ridiculous number :)
09:20:29 <fasta> I would love to see the cost break down.
09:20:31 <zygoloid> stepkut: you don't want them breathing in the nanotech cyberdroids :)
09:21:05 <Kaidelong> emacs or yi?
09:21:07 <stepkut> zygoloid: speak for yourself!
09:21:18 <arcatan> joe!
09:21:18 <Entroacceptor> Kaidelong: emacs
09:21:24 <Kaidelong> thought as much
09:21:27 <Entroacceptor> leksah
09:21:27 <benmachine> Kaidelong: make yi better, then use that
09:21:30 <Entroacceptor> manatee ;)
09:21:41 <quicksilver> zygoloid: or maybe you do. They might fix the Mesothelioma and save you a fortune in healthcare.
09:21:50 <quicksilver> Kaidelong: emacs.
09:21:50 <stepkut> use emacs to fix yi :)
09:22:08 <quicksilver> I would like yi to be better. It has a long way to go to be emacs, though.
09:22:15 * Kaidelong heads off to his exam
09:22:16 <benmachine> fix yi = yi (fix yi)
09:22:19 <fasta> The defining feature of Yi is dead according to haskell-cafe.
09:22:33 <Kaidelong> I would love to take on projects like that if I had the time
09:22:34 <benmachine> fasta: opinions differ, I'm sure
09:22:36 <Kaidelong> oh before I go
09:22:46 <Kaidelong> conal, I was supposed to look something up for you in a book
09:22:47 <Twey> fasta: What feature is that?
09:22:52 <Kaidelong> but I cannot remember exactly what it was
09:23:09 <fasta> Twey, flipping one bit taking in the order of less than a 20 ms. 
09:23:11 <Kaidelong> I think it was whether or not RWH uses F# events to implement reactive programming?
09:23:15 <Kaidelong> err
09:23:18 <Kaidelong> RWFP
09:23:18 <fasta> Twey, hot code swapping.
09:23:25 <Twey> It's dead?
09:23:36 <benmachine> hs-plugins died but recently got resurrected
09:23:40 <benmachine> but the memory leak's still there
09:23:41 <fasta> Twey, now there is slow code swapping.
09:23:53 <benmachine> fasta: it's still configurable in haskell, just slowly >_>
09:23:57 <Twey> But we have hint and mueval and GHC-as-a-library and… and…
09:23:59 <benmachine> go make a cup of tea
09:24:00 <Twey> … other stuff
09:24:15 <benmachine> Twey: hint is a bit heavyweight though!
09:24:19 <fasta> Twey, I was only making a statement about Yi.
09:24:45 <fasta> Anything can be fixed.
09:24:50 <stepkut> benmachine: plugins is not exactly lightweight -- it adds about 30MB to the size of your executable, and it still forks off an external GHC process to do compilation
09:25:13 <benmachine> stepkut: hmm
09:25:20 * stepkut wishes someone would fix hierachical module support in hs-plugins
09:25:28 <benmachine> I think the world would benefit from a haskell interpreter designed to be embeddable
09:25:47 <stepkut> benmachine: the upside of plugins is that it really compiles the code -- it is not interpreted
09:25:50 <benmachine> like lua only a better language
09:25:53 <Kaidelong> FSI is much nicer than GHCi
09:26:09 <Kaidelong> at least in my experience with both
09:26:14 <Kaidelong> but I like haskell better as a language
09:26:29 <Dawgmatix> what is fsi?
09:26:36 <Kaidelong> F# Interactive
09:26:40 <quicksilver> stepkut: the interpreter can load compiled code though
09:26:46 <quicksilver> stepkut: so it doesn't really matter which you use.
09:26:53 <Dawgmatix> ah
09:26:54 <stepkut> quicksilver: true
09:26:54 <fasta> When is SPJ going to retire?
09:27:07 <stepkut> fasta: :(
09:27:11 <quicksilver> but there are implications of the way plugins loads the library versus the way ghc-api loads the library
09:27:15 <quicksilver> ...implications which I don't understand.
09:27:45 <fasta> For F# to become more popular OCaml and Haskell have to not be popular.
09:27:53 <fasta> One reason for that is to cut all funding.
09:28:01 <fasta> Er one way to do that
09:29:16 <Kaidelong> I don't know, if Haskell and OCaml have wider adoption it'd make more sense to use F# in industry, not less, since more programmers would be able to adapt to it
09:29:32 <sproingie> i dont think it's a zero sum game in FP-land
09:29:52 <Kaidelong> right now the problem seems to be that even if a company does want to do stuff in something like Haskell, there are too few functional programmers to go around
09:30:03 <sproingie> stuff like linq came out of haskell
09:30:04 <fasta> I have never understood this "adapt to a functional language" thing. Programming in an imperative language is more difficult than in a FP language, simply because it has more features.
09:30:09 <Kaidelong> so Microsoft wouldn't gain anything from cutting off funding to open source products
09:30:20 <Kaidelong> fasta: but it is a different mind-set
09:30:28 <fasta> Kaidelong, not for me.
09:30:38 <sproingie> fasta: fact is most people started with imperative.  adapting to something different is difficult.
09:30:48 <fasta> sproingie, I also started with imperative.
09:30:49 <Kaidelong> fasta: most people seem to struggle with it. I blame CS courses to a large degree.
09:30:59 <fasta> Most people do not care.
09:31:05 <fasta> That's why they 'struggle'.
09:31:13 <quicksilver> fasta: most people are not you.
09:31:17 <sproingie> if you can't understand the idea of adapting to something different, then i don't know how to explain it
09:31:23 <merijn> I blame people in general, most people want stupid things. Haskell has started to learn me to stop wanting stupid things :p
09:31:43 <Kaidelong> I heard someone yesterday who told me that Erlang can't possibly be object oriented because it is functional
09:31:55 <sproingie> erlang isn't particularly OO
09:32:06 <fasta> When they then hear completely worthless words like 'monads' and hylomorphisms they think 'why was I learning Haskell again?'.
09:32:09 <merijn> No, but being functional is not the antonym of being OO
09:32:24 <fasta> The parts of Haskell that are useful are then glossed over.
09:32:28 <Kaidelong> well it uses an actor model
09:32:35 <sproingie> no, but pure functional tends to fly in the face of traditional OO
09:32:45 <Kaidelong> which was something that message passing OO was invented to implement wasn't it?
09:32:50 <sproingie> the concept of identity of a stateful object is not something baked in
09:33:26 <fasta> I think STRefs should have a unique identifier in debugging mode. 
09:33:37 <fasta> Now I had to write that myself. 
09:33:45 <Kaidelong> I guess it depends exactly what you call OO
09:33:46 <sproingie> the term OOP itself is late 70's, via smalltalk
09:34:16 <merijn> Smalltalk OOP is almost, but not quite, entirely unlike mainstream OO imo :p
09:34:23 <Kaidelong> what about Simula?
09:34:37 <sproingie> i think smalltalk is older
09:34:39 <Kaidelong> Erlang's OO would be more like Smalltalk's IIRC
09:34:51 <Kaidelong> if you want to call it that
09:34:56 <sproingie> oh how about that it isnt
09:34:58 <merijn> Erlang just says "process" instead object
09:35:11 <sproingie> processes are more like actors
09:35:31 <sproingie> actors can be used as objects, but most wouldnt treat them exactly the same
09:35:43 <merijn> sproingie: Most OO weenies seem to wish objects were actors?
09:35:50 <sproingie> you generally don't go around slinging lists and maps of actors
09:36:03 <Kaidelong> the basic idea of message passing being the only way to manipulate state is intact, though
09:36:07 <EvanR-work> OO weenies
09:36:07 <EvanR-work> nice
09:36:29 <sproingie> let's say it's coarse-grained OO
09:36:42 <Kaidelong> Erlang is next on my list of languages to learn after Mercury, anyway, so I suppose I'll have some first hand experience soon
09:36:52 <Kaidelong> but I need to be going
09:36:54 <sproingie> but even then i still have a bit of a problem with it.  the lifecycle of processes is very different
09:43:28 * hackagebot wumpus-basic 0.12.0 - Common drawing utilities built on wumpus-core.  http://hackage.haskell.org/package/wumpus-basic-0.12.0 (StephenTetley)
09:45:28 * hackagebot wumpus-microprint 0.11.0 - Microprints - "greek-text" pictures.  http://hackage.haskell.org/package/wumpus-microprint-0.11.0 (StephenTetley)
09:45:30 * hackagebot wumpus-tree 0.10.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.10.0 (StephenTetley)
09:48:49 <EvanR-work> mmm lists and maps of actors
09:53:16 <Dawgmatix> is real world haskell a good first book on haskell? 
09:53:45 <jmcarthur> i'd say so
09:54:13 <FauxFaux> Depends if you're prepared to commit 400 pages + activities.  Read learn you a haskell first?
09:54:27 <jmcarthur> as with most things, it depends on how you think
09:54:40 <EvanR-work> a good first book on haskell would depend on how much experience you have in this or that...
09:54:40 <jmcarthur> learn you a haskell is a large commitment too, considering its slower pace
09:54:44 <sproingie> RWH is a really mixed bag
09:54:51 <sproingie> i think on balance it's not a good first book
09:55:03 <manateeUser> Dawgmatix: Learn your haskell is good book also.
09:55:11 <sproingie> LYAH first then maybe RWH
09:55:12 <jmcarthur> i don't there *is* a good first book when you consider balance
09:55:18 <Dawgmatix> i am a competent lisp and python programmer 
09:55:45 <manateeUser> Dawgmatix: Lisp background will help you understand Haskell. :)
09:55:46 <EvanR-work> how much damage control they need to spend time on, fixing your messed up imperative/oop world views ;)
09:55:47 <Dawgmatix> so i dont want something that teaches programming for scratch, but ideally something for a working programmer 
09:55:47 <jmcarthur> Dawgmatix: if you know lisp i'd just go for RWH
09:56:14 <Dawgmatix> thanks jmcarthur 
09:56:16 <manateeUser> Dawgmatix: RWH
09:56:20 <EvanR-work> Dawgmatix: are you going to use haskell at work?
09:56:31 <sproingie> real world lisp bears little resemblance to FP
09:56:36 <Dawgmatix> evanr, not so lucky 
09:57:06 <Dawgmatix> but i have some graph code that i wrote for my own startup in python 
09:57:17 <sproingie> at least the concept of functions as values isn't foreign to people with a lisp or python background
09:57:23 <manateeUser> Dawgmatix: BTW, learnyouahaskell.com is also good Haskell book.
09:57:43 <Dawgmatix> the startup has failed. but i intend to port the code to something other than python (there were some speed issues, particularly around recursive functions)
09:57:57 <EvanR-work> there are lots of graph libraries for haskell
09:58:00 <sproingie> haskell will either run it much faster or much slower :)
09:58:08 <Dawgmatix> :)
09:58:21 <manateeUser> EvanR-work: yes. 
09:58:29 <Dawgmatix> as long as theres no penalty for writing recursive functions, I should be fine sproingie 
09:58:33 <manateeUser> Dawgmatix: Haskell can do everything you want. :)
09:58:49 <sproingie> oh god no, you're not going to blow up the stack with recursion
09:58:56 <burp> @faq can it?
09:59:02 <sproingie> well, maybe the heap if you have space leaks
09:59:17 <joe1> > chunk 2 [1..10]
09:59:26 <sproingie> no lambdabot
09:59:31 <Dawgmatix> thanks all of you for the help :) 
09:59:37 <jmcarthur> Dawgmatix: *explicit* recursion is actually a bit frowned upon in idiomatic haskell, but don't let that scare you :)
10:00:00 <jmcarthur> idiomatic haskell programming is very combinator heavy
10:00:06 <sproingie> rwh does an excellent job at showing how folds can replace recursion
10:00:12 <Dawgmatix> okay 
10:00:29 <Dawgmatix> as long as the principle of problem decomposes to subproblems holds i should be fine 
10:00:39 <manateeUser> Dawgmatix: And don't forgot : #haskell is most friendly channel, you can get answer at here, anytime
10:00:47 <EvanR-work> day or night
10:00:52 <Dawgmatix> thanks :)
10:00:54 <sproingie> for freeeeeee!
10:00:54 <EvanR-work> sun up sun down
10:01:00 <Dawgmatix> i wish my telco provided such support
10:01:10 <jmcarthur> Dawgmatix: decomposition is exactly the reason that we like to put recursion into special folds and stuff
10:01:13 <EvanR-work> 4 corner days supercede 1 day god
10:01:24 <Dawgmatix> oic, let me learn the idioms then 
10:01:31 <sproingie> don't be afraid to write explicit recursion, you can always turn 'em into folds later
10:01:37 <jmcarthur> yeah, that's true
10:02:00 <jmcarthur> especially for newbs
10:02:02 <sproingie> nothing wrong with writing pointy syntax if it makes the intent clear
10:02:14 <jmcarthur> it's not actually *frowned* upon. i worded that in an extreme way
10:02:30 <sproingie> tho "pointy" tends to take on a different meaning when you start using <&&*@#%!*&> operators...
10:02:37 <EvanR-work> i use explicit recursion to do for loops that can exit early
10:02:37 <jmcarthur> o_O
10:02:46 <EvanR-work> by explicit i mean fix (\loop -> ;)
10:03:08 <jmcarthur> meh
10:03:21 <jmcarthur> where the heck is lambdabot?
10:03:36 <sproingie> resting after a prolonged squawk
10:03:40 <manateeUser> Hmm, looks John's patch is good.
10:09:50 <EvanR-work> so what is the state of the art in haskell graphical user interfaces, which i am exclude general real time games from
10:10:13 <EvanR-work> kiosk, desktop app, desktop environment, etc
10:10:49 <EvanR-work> i know theres xmonad, but is it anything special
10:12:00 <tolkad> Why can't I do « data T a where { TI { v :: Int, w :: Int } :: T Int; TB { v :: Int, w :: Bool } :: T Bool }»? v has the type « T a -> Int » and w has the type « T a -> a »
10:12:10 <tolkad> I realize w might be hard to infer
10:12:15 <tolkad> but what about v?
10:12:24 <tolkad> that seems pretty simple
10:12:51 <joe1> i am stuck with trying to figure out how to structure my program and am wondering if anyone has some ideas. i have 2 lists, let a = [(1,2,3),(4,5,6),(8,9,10)]; let b = [aa,b,ac,d,ae], I need f (1,2,3) aa; f (4,5,6) ac; f (8,9,10) ae
10:13:26 <EvanR-work> zipWith ?
10:13:31 <EvanR-work> :t zipWith
10:13:41 <benmachine> joe1: why do you drop b and d?
10:13:41 <tolkad> > 5
10:13:45 <benmachine> joe1: I mean, on what basis
10:13:48 <benmachine> lambdabot's toast
10:13:48 <tolkad> lambdabot is gone : (
10:13:49 <joe1> sorry, should have been  f (1,2,3) aa; f () b, f (4,5,6) ac; f () d, f (8,9,10) ae
10:13:59 <benmachine> joe1: f is not well-typed there
10:14:05 <EvanR-work> (a -> b -> c) -> [a] -> [b] -> [c]
10:14:23 <joe1> sorry, should have been  f (1,2,3) aa; f nothing b, f (4,5,6) ac; f nothing d, f (8,9,10) ae
10:14:51 <EvanR-work> zipWith f a b
10:14:52 <joe1> benmachine, any line with the prefix of a in the second list, I need to do something on it
10:14:53 <benmachine> joe1: you coudl do, f (Just (1,2,3)) aa; f Nothing b; f (Just (4,5,6)) ac
10:14:54 <benmachine> etc.
10:15:03 <benmachine> joe1: prefix of a?
10:15:06 <benmachine> joe1: are they strings?
10:15:16 <joe1> yes,
10:15:51 <joe1> actually, I read 1 2 3 from 3 different files and the list b = contents of readFile
10:16:22 <benmachine> joe1: readFile returns a string, not a list of strings
10:16:58 <joe1> actually, list b = lines . readFile
10:17:05 <benmachine> oh ok, good
10:17:22 <benmachine> right, well,
10:17:35 <benmachine> the first thing I'd do is filter the list so it only had elements beginning with a in it
10:17:39 <joe1> and for each line in the list b, some could just be comments and I do not want to do anything with them other than to just print them out.
10:17:47 <benmachine> oh
10:18:05 <benmachine> what's the significance of the list a?
10:18:07 <joe1> when the line has a certain prefix, I need to compare that line with the 1 2 3 from the 3 different files.
10:18:16 <benmachine> oh ok
10:18:27 <benmachine> then yes, filter the second list by whether it has that prefix or not
10:18:41 <benmachine> filter :: (a -> Bool) -> [a] -> [a]
10:18:48 <joe1> list a = (1st line from file a, 2nd line from file b, 3rd line from file c)
10:19:09 <benmachine> filter even [1,2,7,3,2] = [1,2,2]
10:19:23 <joe1> benmachine: I could do that. but i need to print the lines in order.
10:19:24 <benmachine> that should start you off but I've got to go, sorry
10:19:37 <benmachine> joe1: oh, try a basic recursion I guess
10:19:38 <EvanR-work> joe1: sounds like a job for sort
10:19:54 <EvanR-work> or is sort too strict
10:20:24 <benmachine> f listA (first : rest) = if first is interesting, do something with listA, else print first; either way recurse with rest
10:20:44 <benmachine> something like that
10:20:47 * benmachine goes back to work
10:20:48 <joe1> yes, that will work..
10:21:04 <joe1> yes, recursion is the solution. cannot believe that I could not think of that.
10:21:56 <joe1> benmachine: thanks.
10:22:09 <nooodl> argh, lambdabot is gone and i needed @pf
10:22:10 <benmachine> np :)
10:22:17 <benmachine> nooodl: install pointfree from hackage
10:24:02 <EvanR-work> asTypeOf :: a -> a -> a
10:24:14 <silver> nooodl, gimme expression, I'll give you the result
10:24:18 <silver> :)
10:24:37 <nus> what's the exchange rate?-)
10:24:43 <silver> or you can come to our irc.bynets.org on channel #haskell and use @pl there
10:24:49 <EvanR-work> how does asTypeOf work
10:25:05 <silver> this is belarussian irc network
10:25:09 <benmachine> EvanR-work: it's const, but with a more restrictive type signature
10:25:16 <EvanR-work> :t const
10:25:20 <benmachine> const x y = x
10:25:23 <nooodl> \(x,y) -> x ++ [n] ++ y
10:25:24 <EvanR-work> const :: a -> b -> a
10:25:27 <EvanR-work> ah
10:25:34 <benmachine> it returns the first argument, but in the case of asTypeOf, it also forces the types to be the same
10:26:08 <silver> nooodl, <lambdabot> uncurry ((. (n :)) . (++))
10:26:25 <EvanR-work> is asTypeOf like the only function with type a -> a -> a ?
10:26:29 <nooodl> that's way more obfuscated than i imagined :)
10:26:58 <nooodl> how about \(x,y) -> x ++ n ++ y
10:27:21 <benmachine> or \(x,y) -> concat [x,n,y]
10:27:27 <benmachine> I don't think any of them will do you much good though
10:27:30 <nus> http://www.haskell.org/hoogle/
10:28:09 <EvanR-work> there are no Prelude functions that start with j
10:28:51 * benmachine ponders intercalate n [x,y]
10:28:53 <jmcarthur> EvanR-work: only when case-sensitive ;)
10:29:02 <EvanR-work> oh
10:29:11 <EvanR-work> now i need to go through the whole thing again ;)
10:29:19 <EvanR-work> what does lex do?
10:29:31 <pygatea> any ideas why haskell is choking on this? i think it's a problem with my use of show, but i don't know enough about i/o yet to see what http://hpaste.org/40745/haskell_io_issue
10:29:45 <silver> nooodl, http://hpaste.org/40746/pl
10:30:48 <nooodl> thanks
10:31:29 <opqdonut> pygatea: the return type of show is not Maybe ArithExpr
10:31:40 <opqdonut> even though you claim that that's the return type of simpleParseExpr
10:31:59 <opqdonut> I think you want to do something like "print $ simpleParseExpr s"
10:32:04 <opqdonut> and remove the show from simpleParseExpr
10:32:11 <pygatea> opqdonut: hmm okay i'll take a look thanks
10:32:24 <opqdonut> print is merely putStringLn and show
10:32:26 <opqdonut> @src print
10:32:35 <joe1> EvanR-work: thanks for your suggestion.
10:34:12 <pygatea> opqdonut: to clarify, simpleParseExpr should just start with the "eval" and in my main function I should have print $ simpleParseExpr s instead of putStrLn $ simpleParseExpr
10:34:23 <opqdonut> yes
10:38:14 <joe1> how do I do "type Xxx = String" in ghci?
10:38:31 <joe1> or is it not possible?
10:38:41 <joe1> just creating a type synonym
10:38:46 <Lemmih> joe1: You don't.
10:38:55 <joe1> Lemmih: oh, ok. thanks.
10:42:40 <nooodl> is there some kind of function, f :: Enum a => a -> [a], which returns a sorted list of all a's of the same type?
10:42:51 <nooodl> like f GT === [LT,EQ,GT]
10:43:40 <sipa> [minBound..maxBound]
10:44:08 <sipa> > [..]
10:44:08 <nooodl> ah, that works
10:44:32 <merijn> sipa: lambdabot is MIA
10:44:45 <Jafet> That's a strange function to want
10:45:12 <zygoloid> \v -> reverse (iterate pred v) ++ tail (iterate succ v) ;)
10:46:05 <Jafet> > pred (0::Word64)
10:46:36 <Jafet>  *** Exception: Enum.pred{Word64}: tried to take `pred' of minBound
10:47:10 <aristid> spoon
10:47:18 <zygoloid> :)
10:47:48 <zygoloid> "start by taking the reverse of this infinite list" :)
10:48:22 <Martty> easy if its a circular list
10:48:39 <aristid> No results found for "start by taking the reverse of this infinite list".
10:48:56 <Jafet> minBound is in Bounded by the way, not Enum.
10:48:56 <zygoloid> Martty: sure, but it violates referential transparency
10:49:29 <Jafet> zygoloid: they have to be unique, so run a cycle finder
10:49:45 <ClaudiusMaximus> how would you know where in the cycle to start
10:50:29 <Jafet> nooodl's question seems to imply Ord, so just sort it
10:50:37 <ClaudiusMaximus> hmm,  sum . cycle $ [1, -1]
10:51:08 <aristid> ClaudiusMaximus: that evaluates to _|_ i think
10:51:17 <Jafet> That doesn't quite work
10:52:14 <ClaudiusMaximus> 0.5 if you average the limits
10:56:07 <gigabytes> hello
10:56:36 <gigabytes> I have a quite technical question about the implementation of polymorphism in haskell compilers.
10:56:59 <Lemmih> gigabytes: Ask away.
10:57:04 <gigabytes> thanks
10:57:23 <gigabytes> I should say that I'm coming from C++ and learning haskell 
10:57:34 <gigabytes> I like very much its type system
10:58:07 <gigabytes> I've found some similarities between C++ templates and the type polimorphism of haskell. for example
10:58:33 <manateeUser> gigabytes: Haskell's polymorphism powerful than C++ templates. :)
10:58:54 <gigabytes> manateeUser, I can easily believe this :)
10:59:05 <gigabytes> but the question is deeper, let me do an example
10:59:29 <gigabytes> a piece of code like func x = x:[] is typed a -> [a]
10:59:43 <gigabytes> it's polymorphic.
11:00:15 <gigabytes> a C++ code like template<typename T> list<T> func(T x) { return list<T>(x); } is much the same
11:00:22 <gigabytes> (uglier, but the same)
11:00:32 <gigabytes> the question is about the _implementation_ of this stuff.
11:00:53 <gigabytes> A C++ compiler will parse the definition of the function and create an instance of the function of each type used in its invocations
11:00:58 <gigabytes> what does the haskell compiler do?
11:01:10 <mauke> generate one function and use it for all types
11:01:12 <manateeUser> Type inference
11:01:18 <Lemmih> gigabytes: Haskell compilers doesn't have to do that.
11:01:18 <mauke> that means all types need to have the same representation
11:01:50 <gigabytes> hm
11:01:54 <manateeUser> gigabytes: When Haskell compiler found 'x' in 'x:[]' is type Char, so 'x:[]' is [Char]
11:02:03 <manateeUser> gigabytes: if 'x' is Int, result is [Int]
11:02:08 <gigabytes> manateeUser, ok, that's the semantic
11:02:12 <gigabytes> but
11:02:20 <mauke> gigabytes: everything is boxed, i.e. pointers
11:02:36 <gigabytes> what actually _happens_? is this handled at runtime, or at compile-time like C++ templates?
11:02:55 <sbrg> gigabytes: The important thing is that you don't have to worry about what happens
11:03:02 <mauke> nothing needs to be handled
11:03:04 <sbrg> Like you have to worry about it in C++ at times
11:03:06 <manateeUser> gigabytes: I think it's at static time. 
11:03:27 <Lemmih> gigabytes: As mauke said, there's really nothing to handle.
11:03:55 <gigabytes> hm, ok
11:04:23 <ClaudiusMaximus> gigabytes: dictionary passing usually, but you can also use {-# SPECIALIZE ... #-} pragmas to generate code for specific types if you really want to - at least in GHC.  check your compiler documentation :)
11:04:30 <manateeUser> gigabytes: You just need write your expression and don't worried type problem, like you write 'C':[1,2], compiler will refuse it.
11:04:34 <mauke> ClaudiusMaximus: what dictionary?
11:04:45 <ClaudiusMaximus> mauke: an implicit one
11:04:50 <mauke> ClaudiusMaximus: what
11:05:05 <mauke> there is no dictionary in func x = x : []
11:05:06 <ClaudiusMaximus> i'm probably wrong, i'm just going from #haskell osmosis...
11:05:23 <gigabytes> ClaudiusMaximus, can you please clarify your interesting answer?
11:05:30 <Lemmih> gigabytes: You can see (:) as a structure that takes two pointers. The types of those pointers are irrelevant; they're always just gonna be plain pointers.
11:06:36 <merijn> gigabytes: You could implement all those sorta things with structs of void pointers in C/C++, except now the compiler checks all the void pointers point to the same data type
11:06:49 <gigabytes> ok
11:06:55 <gigabytes> so it's a runtime thing
11:07:05 <mauke> but types aren't checked at runtime
11:07:06 <merijn> gigabytes: No, the type checking is done at compile time
11:07:22 <opqdonut> a bit like java's type erasure with generics
11:07:23 <manateeUser> gigabytes: At compile time.
11:07:29 <gigabytes> hm
11:07:41 <manateeUser> gigabytes: If type mismatch, won't compile pass.
11:07:42 <opqdonut> the compiler checks that your code is correct and then compiles it into bytecode that shuffles Objects around
11:08:00 <opqdonut> if you're not familiar with java, that probably didn't help :)
11:08:03 <mauke> gigabytes: why can't the C++ compiler emit only one machine code version of a function template?
11:08:18 <merijn> gigabytes: Understanding how GHC makes things work is hard. GHC consists of voodoo, elder gods and goat sacrifices...
11:08:34 <nus> gigabytes, consider func x y = x:y:[] :: a -> a -> [a], what would the C++ code look like?
11:08:45 <merijn> That or advanced mathematics combined with low level hacking, which in my opinion is largely the same :p
11:08:52 <manateeUser> nus: A lots of <T> :)
11:08:53 * roconnor reads back
11:09:14 <FauxFaux> nus: std::tr1::bind(x,y,...something ¬_¬)
11:09:25 <merijn> roconnor: The simplified question was "how do haskell compilers actually implement the polymorphic functions"
11:09:30 <ClaudiusMaximus> gigabytes: not sure.  but SPECIALIZE is never necessary, it's a potential (de)optimization depending on the situation
11:09:34 <mauke> nus: template<typename a> list<a> func(a x, a y) { return cons(x, cons(y, nil<a>)); } or something
11:09:55 <gigabytes> nus, yes
11:09:59 <roconnor> merijn: ah
11:10:15 <manateeUser> gigabyte: Maybe you can ask in #ghc
11:10:20 <gigabytes> hm
11:10:21 <roconnor> ClaudiusMaximus: when is it a deoptimization?
11:10:24 <ClaudiusMaximus> i'll bow out - got housework to do and i'm probably misinformationing
11:10:33 <manateeUser> gigabyte: The guy in #ghc know how to implement it. :)
11:10:35 <ClaudiusMaximus> roconnor: when you value code size over speed?
11:10:40 <roconnor> ClaudiusMaximus: ok
11:10:48 <mauke> code size can be speed
11:10:56 <roconnor> fair
11:11:04 <merijn> Code nowadays usually *is* speed
11:11:10 <merijn> s/Code/Code size
11:11:17 <roconnor> I find that surprising
11:11:46 <merijn> roconnor: Really? Why?
11:12:24 <merijn> Complexity analysis of most algorithms is outdated to the point of uselessness
11:12:31 <gigabytes> ClaudiusMaximus, so, using that directive I get the compiler to generate a specialized version of a polymorphic function that avoid runtime polymorphism?
11:12:37 <merijn> (Ok, most might be an exaggeration...)
11:12:43 <roconnor> merijn: I think your answer about void pointers is pretty good
11:13:26 <mauke> gigabytes: what do you mean by "runtime polymorphism"?
11:13:44 <roconnor> since all values are generally boxed by default, the SPECIALIZED function won't really be any better.  Persumably the point of SPECIALIZE is that more optimizations can take place on the specialized code (inlining functions and whatnot)
11:13:49 <merijn> gigabytes: Basically, the compiler type checks all the polymorphic types always match. Since it now knows the types are always correct it can avoid generating boilerplate code to handle type difference and inheritance problems...
11:13:54 <Lemmih> gigabytes: No, it is very unlike that it will unbox the arguments.
11:14:15 <roconnor> if no optimizations run on the SPECIALIZED code, you probably don't gain anything.
11:14:23 <gigabytes> the problem is not about correctness
11:14:32 <gigabytes> for example
11:14:35 <Lemmih> gigabytes: You have to understand that polymorphism in GHC has essentially zero runtime overhead.
11:14:53 <gigabytes> add x y = x+ y
11:14:56 <gigabytes> is polymorphic
11:15:00 <gigabytes> but
11:15:05 <gigabytes> when it executes
11:15:07 <roconnor> Lemmih: more like lazy values already have the overhead of polymorphism :)
11:15:15 <Lemmih> roconnor: Exactly.
11:15:19 <merijn> Can someone resurrect lambdabot? :\
11:15:31 <mauke> gigabytes: that's very different from f x = x : [] in that now we have typeclasses to consider
11:15:37 <gigabytes> it _has_ to find which (+) function to call, right? it depends upon the actual types of the arguments, not about the type-correctness of the function call
11:15:48 <Lemmih> gigabytes: That particular example involves type-classes which are a different thing altogether.
11:16:13 <gigabytes> ok, so sorry If I've given the wrong example. The question was more general than that
11:17:05 <gigabytes> so what happens with that add function? who is deciding which (+) to call? and when?
11:17:08 <roconnor> gigabytes: map is a prototypical example of a polymorphic function
11:17:32 <Lemmih> gigabytes: That does happen at runtime and it will be faster to specialize it.
11:17:36 <EvanR-work> map is parametric, + is ad-hoc
11:17:58 <EvanR-work> Lemmih: i hear that such things are optimized at compile time when possible
11:18:12 <roconnor> gigabytes: ya, in that case specializing will likely allow the compiler to inline the particular dictionary call.
11:18:14 <Lemmih> EvanR-work: Yeah, GHC might very well specialize it for you.
11:18:19 <merijn> gigabytes: The complexity with add is that the type of (+) is not "a -> a -> a", but "(Num a) => a -> a -> a" and Num is can of worms. Maybe equality "==" is a simpler example
11:18:33 <EvanR-work> if it knows the two operands are Ints, then it wont be a method lookup
11:18:35 <mauke> I don't see how Num is more complicated
11:19:10 <EvanR-work> @src Num
11:19:34 <manateeUser> Looks lambdabot is down...
11:19:39 <EvanR-work> still
11:21:44 <dlazar> Hello. Looking for help with Ubuntu Lucid and installing GHC
11:23:14 <dlazar> I need to use GHC 6.10.4, not 6.12... how does one ensure the older GHC gets installed with apt-get?
11:23:26 <sproingie> is there a package for 6.10.4?
11:24:28 <sproingie> you'd probably have to install it from karmic and pin it with preferences or something
11:24:52 <dlazar> I am not sure.. I know apt-get install ghc will do 6.12.. I am not sure how to tell it to use a different version
11:25:07 <maurer_> dlazar: Out of curiosity, what do you need 6.10.4 for?
11:25:14 <sproingie> if it's not in your repo it's kind of painful.  the 6.10.4 package is in karmic
11:25:15 <dlazar> Ok.. I have to learn how to manipulate apt-get that way
11:25:30 <maurer_> dlazar: What you want to do is use getdeb to find the karmic 6.10.4 package, download it, and use dpkg -i on it
11:25:38 <sproingie> you could ask the debian folks how to install from a previous version's repo
11:25:39 <dlazar> right... I am running Karmic on my notebook... ghc worked well.. but on Lucid I am at a loss
11:25:52 <sproingie> the ubuntu guys will probably get all snippy and just tell you to not do it
11:25:55 <maurer_> Adding karmic to your repos will likely cause you to have problems down the road if you don't know what you're doing.
11:26:02 <dlazar> morfette is a Haskell package that ONLY works 6.10
11:26:19 <sproingie> oh definitely don't just blindly add karmic, you have to do weird stuff with preferences and pinning to make it work right
11:26:25 <sproingie> if indeed it'll work at all
11:26:33 <dlazar> So, Maurer has the right approach? 
11:26:51 <sproingie> yeah you can probably just install it manually
11:27:07 <sproingie> otherwise you get to compile it from source, yay
11:27:08 <dlazar> I am not sure I want to install ghc by hand... 
11:27:19 <sproingie> it's not excruciatingly hard nowadays
11:27:22 <dlazar> could be trouble... that is a whole schwack of code
11:27:32 <sproingie> it got easier with 6.10
11:27:54 <dlazar> ya? Like one tar.gz, ./.configure, make && sudo make install kind of thing
11:28:20 <ClaudiusMaximus> yeah.  grab a generic linux ghc binary tarball and install in ~/opt/ or so, then bootstrap cabal-install
11:28:21 <sproingie> tho i think there's a bug in the config scripts for doing shared-lib-everything on 6.10
11:28:26 <sproingie> i remember having to fix it
11:28:34 <sproingie> just a wrong filename or something
11:29:33 <sproingie> if you take all the defaults it builds out of the box without much problem
11:29:40 <maurer_> dlazar: Hold off for 5 minutes.
11:29:51 <maurer_> dlazar: I'm prepping a patched version of morfette that can use 6.12
11:30:10 * roconnor <3's NixOS
11:31:27 <maurer_> http://data.matthewmaurer.org/morfette-0.3.1.1.tar.gz
11:31:34 <maurer_> Now you can just use 6.12 instead.
11:31:47 <maurer_> (6.12 added rec as a reserved word, they used it as a variable, I fixed it)
11:31:59 <EvanR-work> smooth
11:32:16 <roconnor> maurer_: you added -H98 flags, right?
11:32:17 <dlazar> Awesome!! 
11:32:18 <roconnor> :P
11:32:38 <maurer_> roconnor: No, I just patched it by switching the name of the "rec" variable to "f"
11:32:43 <roconnor> ;(
11:32:52 <maurer_> roconnor: That probably would have worked too, but best to migrate the code to not need sillymode :P
11:33:06 <maurer_> Now to contact upstream...
11:34:08 <dlazar> Ok.. so I can now just apt-get install ghc and ultimately cabal install morfette from that tar?
11:34:31 <maurer_> Yep
11:35:32 <Itkovian> FYI, you may find this interesting: Back to the Futures: Incremental Parallelization of Existing Sequential Runtime Systems #splashcon #oopsla
11:36:01 <roconnor> maurer_ may have introduced a security hole as a consequence of variable capture since capture avoiding substitution was *not* performed!
11:36:06 <roconnor> :o
11:36:54 <roconnor> -H98 would have been safer :P
11:37:31 <EvanR-work> we like our software fast and loose
11:37:57 <EvanR-work> insert like we like our women
11:38:52 <roconnor> Itkovian: I like time travel in my code.
11:39:01 <maurer_> roconnor: A security hole in a machine learning system? Even if I fucked it hard, the worst it would do is break.
11:39:46 <roconnor> maurer_: maybe you broke the code that check to make sure it isn't violating Asimov's rules.
11:40:20 <maurer_> roconnor: Ha. Additionally it was a really small change--only 3 uses, all in one function. Switched to use "f" which wasn't in use inside that function.
11:40:23 <roconnor> -H98 would have been safer :P
11:40:32 <roconnor> damn
11:40:33 <roconnor> you wil
11:40:35 <roconnor> win
11:43:51 <dlazar> your guys make me laugh. entertainment... will haskell make me funny too?
11:44:21 <maurer_> Also, it turns out that upstream doesn't need the patch. If you don't want to use my patch, the svn from morfette builds fine against 6.12
11:44:28 <Jafet> @quote kmc fun
11:44:45 <Jafet> I can't be funny without you, lambdabot!
11:44:52 <EvanR-work> dlazar: yes
11:44:57 <EvanR-work> hysterical
11:45:30 <dlazar> I will have to hunt down the SVN for morfette then... 
11:45:39 <edlinde> is there a short cut for writing this lambda function ...    (\acc x -> acc + x) ?
11:45:43 <dlazar> what no git version?
11:45:48 <mauke> preflex: quote kmc fun
11:45:48 <preflex>  no quotes found for kmc
11:45:49 <Botje> edlinde: it's called '(+)'
11:45:51 <mauke> preflex: quote kmc 
11:45:51 <preflex>  <kmc> C++ programmers have this cognitive dissonance where they realize that compile-time metaprogramming is powerful but they don't see that templates are an awful implementation of same.  and so it's all "templates are useful because x,y,z" instead of "templates are useful despite x,y,z"
11:45:51 <EvanR-work> @pl (\acc x -. acc + x)
11:46:03 <EvanR-work> (+)
11:46:10 <edlinde> ah ok 
11:46:11 <edlinde> thanks
11:46:20 <sproingie> still no \bot
11:46:23 <Twey> Invalid syntax
11:46:31 <edlinde> I was just looking at it in regards to the fold example
11:46:55 <burp> Did you mean: @pl (\acc x -> acc + x) *auto correction*
11:47:14 <sproingie> it looks like you're trying to write a function: would you like to ...
11:47:19 <aristid> :t (-.)
11:47:25 <EvanR-work> when we are emulating lambdabot we can add implicit error correction support due to our advanced intelligence
11:47:29 <Twey> \acc x -> acc + x = \acc x -> (+) acc x = (+)
11:47:47 <sproingie> lambdabot is actually oleg typing in the answers
11:47:53 <sproingie> he must be sleeping right now
11:48:04 <aristid> EvanR-work: EvanR-HC is quite advanced, eh?
11:48:15 <EvanR-work> caused by typing errors in our not so advanced motor control system
11:48:47 <FunctorSalad_> visitor = arguments to a fold aka a catamorphism?
11:49:13 <FunctorSalad_> (the visitor pattern :))
11:49:31 <EvanR-work> design patterns!
11:49:38 <EvanR-work> use the 'design' pattern
11:49:43 <Twey> Visitor is Functor, AIUI?
11:49:59 <sproingie> functor is a lot of things
11:49:59 <FunctorSalad_> (I mean the "handler" arguments to the fold, not the foldee)
11:50:21 <sproingie> visitor is an antipattern for languages that lack multple dispatch
11:50:34 <sproingie> er used by languages that lack etc
11:51:05 <FunctorSalad_> Twey: hmm... seems more like a visitor is an algebra for the functor whose fixed point is the datatype
11:51:31 <FunctorSalad_> e.g. for lists with element type A, F X = 1 + A*X
11:52:24 <FunctorSalad_> so an F-algebra in this case is a type X and a function 1+A*X -> X
11:52:59 <FunctorSalad_> which seems to correspond exactly to the implementations of methods "VisitNil" and "VisitCons"
11:53:35 <FunctorSalad_> sproingie: hmm I'm into this more for faking sum types in OO than multiple dispatch
11:53:42 <dlazar> GHC installs kinda ugly... cabal install binary for example... has tons of deprecations? 
11:53:45 <dlazar> You are using the old package `base' version 3.x.
11:53:45 <dlazar>                Future GHC versions will not support base version 3.x. You
11:53:45 <dlazar>                should update your code to use the new base version 4.x.
11:53:47 <roconnor> const 0 ||| uncurry (+)
11:53:57 <sproingie> sounds like more advanced use of visitor than i'm aware of
11:55:09 <sproingie> dlazar: that's probably to be expected when installing ghc itself
11:55:14 <FunctorSalad_> thinking: abstract class EitherVisitor<A,B,R> { R VisitLeft(A a); R VisitRight(B b); }
11:55:32 <EvanR-work> [ ] is not considered 'keywords' ?
11:55:33 <FunctorSalad_> implementations of that class <=> the two arguments to an 'either' in haskell
11:58:17 <dlazar> Seems easy enough to ignore... will just get this working and let the future unfold later
11:58:33 <roconnor> anyone here use uniplate?
12:00:17 <FunctorSalad_> ok, this paper agrees ;) "The simplest example using visitors is that of a sum type of the form A+B.
12:00:18 <FunctorSalad_> Since Java lacks a sum type, the Visitor pattern implements a class doing the
12:00:18 <FunctorSalad_> job of a sum type by a sort of double-negation transform. "
12:00:29 <FunctorSalad_> http://www.cs.bham.ac.uk/~hxt/research/mfps-visitors.pdf
12:01:43 <FunctorSalad_> thinking of making an ADT code generator for C# based on this ;)
12:03:17 <dlazar> runghc Setup configure --prefix=/usr/local    fails... cannot find binary... yet I clearly installed binary using cabal install --prefix /usr/local binary
12:03:40 <dlazar> so... how the heck do I teach ghc to find the libs clearly installed?
12:05:08 <dlazar> /usr/local is in the path... 
12:05:49 <roconnor> installed what binary?
12:06:06 <FunctorSalad_> the package 'binary'
12:06:09 <roconnor> ah
12:06:12 <dlazar> binary is a haskell helper hackage?
12:06:24 <dlazar> morfette needs binary and utf8-string
12:06:40 <FunctorSalad_> dlazar: "ghc-pkg list" should reveal whether it's installed (and where - globally or for your user only)
12:06:41 <dlazar> so I installed those to /usr/local thinking that was better than ~/.cabal
12:06:42 <EvanR-work> cabal install binary
12:06:55 <EvanR-work> ~/.cabal is usually better
12:07:04 <roconnor> dlazar: you installed it as root?
12:07:17 <dlazar> I did a sudo yes... sudo cabal install
12:07:38 <dlazar> I want the ghc and morfette to work for all the dev users on the server
12:07:59 <FunctorSalad_> you can use the --global flag to make sure it's installed globally
12:08:10 <dlazar> without sudo ?
12:08:59 <FunctorSalad_> hmm not sure whether you can omit it even *with* sudo
12:09:28 <Jafet> Think global is default, else you need --user
12:09:30 <FunctorSalad_> (might depend on how sudo is set up and what part of the environment cabal uses to decide where to install by default)
12:09:35 <FunctorSalad_> (don't know)
12:09:44 <Jafet> It's an evil default though, don't use it
12:10:09 <dlazar> ARG... 
12:10:11 <FunctorSalad_> why? he clearly wants a global install
12:10:20 <EvanR-work> --global isnt default
12:10:29 <EvanR-work> since ive never used it, and ive never installed globally
12:10:51 <FunctorSalad_> dlazar: so, I'd use "sudo cabal install --global foo" to make sure
12:10:57 <roconnor> so perhaps dlazar installed it into root's ghc pkgs and not everyones?
12:11:59 <ClaudiusMaximus> http://www.haskell.org/haskellwiki/Cabal-Install#Things_to_put_in_the_config_file
12:12:09 <BrianHV> is there a function Int -> [a] -> [[a]] that splits the [a] argument into a list of (lists having the length of the first argument)?
12:12:20 <BrianHV> hoogle doesn't seem to find such a thing
12:12:33 <EvanR-work> chunk
12:12:51 <FunctorSalad_> BrianHV: 'split' package
12:12:56 <EvanR-work> in Data.List.Split
12:13:11 <BrianHV> thanks!
12:13:50 <siracusa> Is there a way to get the list of currently loaded files/modules in GHCi for using it in a new command? Like `:show modules', but get the result as a [String] or so.
12:14:30 <Jafet> Sometimes I've wanted to get the tab completion as a string, and search through it
12:14:37 <Jafet> Uh, [String]
12:15:49 <joe1> is there a smart way of doing: [1..3] == take 3 [1..5]
12:16:02 <roconnor> joe1: True
12:16:02 <kmc> what do you mean?
12:16:07 <dlazar> GramLab/Data/LCS/SimpleMemo.hs:82:5: parse error on input `rec'
12:16:08 <dlazar> cabal: Error: some packages failed to install:
12:16:08 <dlazar> morfette-0.3.1 failed during the building phase. The exception was:
12:16:08 <dlazar> ExitFailure 1
12:16:12 <joe1> better way of doing it, I mean.
12:16:12 <EvanR-work> True is easier to read
12:16:23 <kmc> joe1, of doing what?
12:16:36 <siracusa> EvanR-work: :-D
12:17:05 <roconnor> wow, a lot of people use the variable rec
12:17:21 <EvanR-work> bad move ghc
12:17:26 <roconnor> dlazar: get maurer_ to repackage that for you
12:17:28 <roconnor> :P
12:17:40 <joe1> i have 2 lists : let a = [1..3] ; let b = [1..5]; f a b = True; let a = [1,2,10] ; let b = [1..5]; f a b = False;
12:17:56 <kmc> joe1, Data.List.isPrefixOf ?
12:17:59 <joe1> i checked isSubsetOf
12:18:09 <joe1> i think isPrefixOf will work.
12:18:11 <joe1> Thanks a lot.
12:18:28 <kmc> there's also isInfixOf, which checks other starting positions
12:18:29 <jmcarthur> joe1: i think hlint might have told you about that one
12:18:35 <jmcarthur> just btw
12:18:50 <EvanR-work> hslint?
12:18:54 <jmcarthur> hlint
12:18:59 <EvanR-work> oh
12:19:04 <joe1> jmcarthur: have not used hlint before? will check it out.
12:19:17 <jmcarthur> joe1: it's nice for pointing out little ways to be more idiomatic
12:19:21 <kmc> but joe1, if you really want subset comparison (unordered), you can use Data.Set
12:19:35 <jmcarthur> i disagree with hlint sometimes, but usually not
12:19:41 <kmc> and it could be more efficient depending on use pattern
12:19:59 <kmc> :t S.isSubsetOf `on` S.fromList
12:20:07 <kmc> gaah where did our bot go
12:20:12 <jmcarthur> :(
12:20:42 <Twey> Ord a => [a] -> [a] -> Bool
12:22:02 <joe1> kmc: thanks.
12:24:08 <edlinde> just read about the function application with $ 
12:24:32 <edlinde> it says that its like the opening parenthesis to group functions right associatively
12:24:34 <edlinde> map ($ 3) [(4+), (10*), (^2), sqrt] 
12:24:37 <edlinde> how does this work?
12:24:47 <edlinde> whats the ($ 3) mean?
12:25:04 <b_jonas> edlinde: ($ 3) means (\x -> x 3)
12:25:04 <EvanR-work> :t ($ 3)
12:25:25 <Jafet> (Num a) => (a -> b) -> b
12:26:14 <roconnor> I don't understand why Biplate a a deines biplate x as ([x],\[x] -> x) instead of definiting biplate as uniplate.
12:26:15 <edlinde> its still a bit confusing as to when I can use this $ operator
12:26:19 <roconnor> *defines
12:26:31 <edlinde> I mean I don't mind having some braces 
12:26:48 <EvanR-work> you $ can $ use $ as $ many $ ($) $ as $ you $ want
12:27:02 <Nopik> hi
12:27:14 <EvanR-work> edlinde: use ( ) unless $ will obviously help
12:27:35 <Nopik> i'm trying to install gtk2hs, though it fails upon cairo install, it says that cairo-pdf is necessary, but it cant find it.. there is no cairo-pdf related package.. any idea?
12:27:55 <edlinde> I mean $ was just supposed to make function applications in right assoc.. I get that
12:27:58 <Nopik> it is actually my frist try to install something via cabal ;) i'm on macos.. i've also did cabal update 
12:28:01 <EvanR-work> liftIO (launchMissles [Russia,China,Europe]) is fine
12:28:21 <edlinde> but then the map ($ 3)... how come it suddenly becomes something where the list elements can be "substituted" instead of it?
12:28:37 <jmcarthur> that's not what it does
12:28:54 <Nopik> i've found some cairo package description, it looks like there is cairo_pdf flag, but i do not know how to pass it to cabal
12:28:56 <edlinde> ok what is each element application looking like?
12:28:58 <byorgey> edlinde: have you seen operator sections before?  like (+3) ?
12:29:00 <EvanR-work> $ is lower precendence application
12:29:16 <b_jonas> edlinde: obviously you can't do that in this case
12:29:16 <Jafet> ($ 3) f = f 3
12:29:17 <jmcarthur> ($ 3) :: Num a => (a -> b) -> b     -- edlinde 
12:29:21 <b_jonas> argh
12:29:27 <b_jonas> EvanR-work: you can't do taht in this case
12:29:35 <EvanR-work> yes i see
12:29:50 <Saizan> Nopik: -fcairo_pdf
12:29:56 <EvanR-work> $ is use to explicitly denote application
12:29:59 <EvanR-work> here
12:30:01 <Nopik> Saizan: thanks
12:30:13 <jmcarthur> edlinde: it's just like how (+ 3) 4 is the same as 4 + 3
12:30:13 <byorgey> Nopik: no, -fcairo_pdf will SET the flag
12:30:23 <byorgey> Nopik: you want  -f "-cairo_pdf"
12:30:42 <edlinde> jmcarthur: is it? 
12:30:43 <byorgey> Nopik: also, the cairo-pdf package it wants is a pkgconfig package, not a Haskell package
12:30:55 <byorgey> Nopik: so it's probably some package provided by your OS's package manager
12:31:01 <Nopik> byorgey: yeah, thanks, indeed
12:31:16 <edlinde> jmcarthur: I thought (+ 3) 4   was being applied as (+,3,4)
12:31:18 <edlinde> or something
12:31:26 <EvanR-work> lisp alert
12:31:29 <ManateeLazyCat> Nopik: Like byorgey said.
12:31:32 <jmcarthur> edlinde: it's applied as (+) 4 3
12:31:45 <jmcarthur> edlinde: and (3 +) 4 would be applied as (+) 3 4
12:31:56 <merijn> edlinde: Infix operators can be partially applied in two ways, (3+) is not the same as (+3)
12:31:58 <EvanR-work> (3 + 4) == (3 +) 4 == (+ 4) 3 == (+) 3 4
12:31:59 <b_jonas> edlinde: no, and you can see the difference with (/ 2) 5
12:32:00 <aristid> (+ 3) 4 is applied as (\x -> ((+) x) 3) 4
12:32:00 <edlinde> jmcarthur: this is what tripped me then in the docs ...    f $ x = f x  
12:32:11 <Nopik> nice, now i have to fight with pkg-config on my machine ;)
12:32:14 <jmcarthur> edlinde: ($) is just a normal operator, like (+)
12:32:16 <edlinde> so I was expecting the $ symbol between a function f and its arg x
12:32:38 <jmcarthur> edlinde: it can be used with section syntax the same way (+) can
12:32:40 <Nopik> after turning off cairo_pdf, it complained about _ps, then _svg. and then it said, that cairo 1.2.0 cant be found at all ;p
12:32:54 <merijn> edlinde: The main usage for $ is that it has the lowest priority of all operators/functions
12:33:01 <Jafet> Haskell, it makes $ disappear
12:33:04 <edlinde> jmcarthur: maybe I should read more about section syntax
12:33:07 <EvanR-work> lol
12:33:13 <Nopik> and since i've just switched from windows to mac, i need to figure out how to install packages in such way that pkg-config will see them
12:33:16 <ManateeLazyCat> Nopik: pkg-config --list-all | grep cairo
12:33:27 <Nopik> probably it is not there, but let me check
12:33:53 <ManateeLazyCat> Nopik: There have three backend for cairo: cairo-pdf cairo-ps cairo-svg.
12:33:59 <Nopik> yeah, nothing.. in general the --list-all is quite short, my linux installations have much much more packages listed there
12:34:01 <edlinde> so would it be safe to say that when I see a $ used in the map function then it will get replaced by the element in the list?
12:34:02 <dlazar_> morfette runs! but I have a terrible encoding issue... the resulting data is munged somehow... 
12:34:05 <edlinde> would that work?
12:34:21 <dlazar_> �missions �missions NPP
12:34:37 <EvanR-work> edlinde: you are missing the point
12:34:38 <ManateeLazyCat> Nopik: You can use "pkg-config --cflags cairo-pdf" to get the library path in your system.
12:34:43 <Jafet> Clearly, $ is of low precedence to Haskellers.
12:34:57 <dlazar_> How can you tell morfette how to deal with encodings?
12:34:59 <merijn> edlinde: "map ($ 3) someList" calls "x $ 3" for all values x in someList
12:35:00 <edlinde> EvanR-work: which is?
12:35:02 <ManateeLazyCat> Nopik: If return Nothing, library cairo-pdf not install correctly
12:35:07 <Nopik> ManateeLazyCat: the thing is i dont have it installed on my system at all ;)
12:35:18 <EvanR-work> edlinde: you can specify functions as 'sections' of infix operators
12:35:21 <edlinde> merijn: ah ok
12:35:26 <ManateeLazyCat> Nopik: You use Mac?
12:35:33 <merijn> edlinde: $ is just another function
12:35:33 <EvanR-work> foldl' (+) [] 0
12:35:38 <Nopik> ManateeLazyCat: yes
12:35:39 <EvanR-work> hrm
12:35:40 <edlinde> EvanR-work: I don't know what you mean by "sections" sorry
12:35:42 <EvanR-work> :t foldl'
12:35:50 <EvanR-work> (3 + 4) == (3 +) 4 == (+ 4) 3 == (+) 3 4
12:35:56 <merijn> EvanR-work: lambdabot is dead :\
12:36:02 <EvanR-work> i know, im using the back system
12:36:04 <EvanR-work> backup
12:36:05 <ManateeLazyCat> Nopik: Sorry, i haven't Mac, but i'm sure gtk2hs can install Windows/Linux/Mac if you have install C library correctly 
12:36:25 <edlinde> EvanR-work: are all those equivalent?
12:36:26 <Nopik> ManateeLazyCat: i'm sure it is possible to install it, just i dont know the way, as i barely know the environment
12:36:30 <merijn> edlinde: Yes
12:36:31 <EvanR-work> edlinde: yes, see ==
12:36:37 <edlinde> wow thats crazy
12:36:41 <edlinde> :)
12:36:42 <merijn> Note that (+3) 4 is not the same
12:36:43 <Nopik> and i think that some stuff was broker after my recent upgrade to snow leopard
12:36:58 <EvanR-work> it is since + is commutative
12:36:58 <merijn> The result is the same for +, but for other functions...
12:37:21 <merijn> EvanR-work: The result is the same, it's not the same
12:37:25 <EvanR-work> (3 / 4) == (3 /) 4 == (/ 4) 3 == (/) 3 4
12:37:42 <ManateeLazyCat> Nopik: Ask in gtk2hs-users@lists.sourceforge.net, i know some people have Mac and have install gtk2hs successful.
12:37:42 <EvanR-work> but /= (/ 3) 4
12:37:44 <edlinde> so can you give me another example where $ is used differently in a map fn?
12:37:51 <merijn> edlinde: As you see () can make any infix operator prefix
12:38:03 <edlinde> ok
12:38:04 <EvanR-work> youre concentrating on $ and map
12:38:07 <merijn> edlinde: `` on the other hand can make any prefix function infix
12:38:20 <ManateeLazyCat> Nopik: If you use Linux, i can tell you how to do step by step, but Mac, i don't know.
12:38:21 <edlinde> EvanR-work: yeah for now
12:38:29 <EvanR-work> you are mapping over a list of functions
12:38:36 <EvanR-work> all you can with functions is apply them to stuff
12:38:38 <Nopik> ManateeLazyCat: nah, i'll figure it out myself.. i think that macports install is broken here, reinstalling it now.. i guess it will allow me to install cairo on my system after that
12:38:41 <EvanR-work> can do
12:38:51 <edlinde> EvanR-work: i mean why did it not go .. ($ 3 x) or something then
12:38:57 <Nopik> ManateeLazyCat: on linux i would not ask at all, as i know it myself ;)
12:38:58 <merijn> edlinde: Like this: elem 1 [1..10] == 1 `elem` [1..10]
12:38:58 <EvanR-work> thats a syntax error
12:39:11 <EvanR-work> er type error
12:39:17 <edlinde> ok
12:39:31 <EvanR-work> you meant (\f -> f 3)
12:39:38 <EvanR-work> that works too
12:39:48 <merijn> edlinde: Open ghci (since lambdabot is dead) and examine ":t ($ 3)"
12:39:53 <Nopik> yeah, reinstalling macports helped, it seems to attempting cairo install now, fingers crossed
12:40:07 <Nopik> pulled out tons of xorg deps so far ;)
12:40:29 <merijn> edlinde: If you look at the types of map, ($ 3) and think really hard the answer should come to you
12:40:44 <merijn> edlinde: Good advice: Grab a piece of paper and work out the type substitution by hand
12:40:52 <edlinde> *Main> :t (3 $)
12:40:52 <edlinde> (3 $) :: (Num (a -> b)) => a -> b
12:40:53 <merijn> Then verify it with :t in ghci
12:40:55 <edlinde> this works out too
12:41:08 <EvanR-work> :t ($ 3)
12:41:14 <EvanR-work> Num a :: (a -> b) -> b
12:41:15 <edlinde> but yeah I get the $ 3 one
12:41:15 <EvanR-work> different
12:41:25 <edlinde> yeah get it
12:41:44 <merijn> edlinde: so (3 $) is a function is a function that expects a function from a number to b and then returns b
12:41:54 <merijn> eh, ($ 3) I mean
12:42:01 <EvanR-work> (3 $) treats 3 as a function
12:42:09 <edlinde> hmm
12:42:34 <merijn> edlinde: Studying the types reported ghci can explain quite a bit about what's going on
12:42:48 <EvanR-work> (3 $) is confusing
12:42:57 <edlinde> it is
12:43:00 <edlinde> :)
12:43:02 <merijn> (3 $) makes no sense
12:43:15 <edlinde> it does to ghci apparently
12:43:16 <opqdonut> :t 3
12:43:21 <EvanR-work> somehow someone made numbers into functions in ghci
12:43:23 <opqdonut> it does for a suitable Num instance :)
12:43:24 <roconnor> Integer
12:43:25 <edlinde> haskell has to much syntax to cover
12:43:34 <merijn> edlinde: "map ($ 3) :: (Num a) => [a -> b] -> [b]" what's this do?
12:43:34 <edlinde> *too
12:43:36 <edlinde> :)
12:43:47 <merijn> (When you look at the type)
12:43:51 <EvanR-work> edlinde: ignore 'numbers are functions' for now ;)
12:44:01 <EvanR-work> or forever
12:44:11 <ManateeLazyCat> All gtk2hs users, today we build *last* patches that fix memory leak on many GObject (non-widget) types, please test gtk2hs darcs with your program, if no bug report, we will release gtk2hs-0.12.0
12:44:16 <opqdonut> the Num b => Num (a -> b) instance is pretty useful sometimes :)
12:44:18 <ManateeLazyCat> Thanks!
12:44:20 <edlinde> takes a list of functions a->b and gives a list of type b
12:44:25 <merijn> Someone tried to implement peano numbers in ghci? :p
12:44:38 <EvanR-work> edlinde: yes
12:44:58 <EvanR-work> it applies them all to 3
12:45:01 <merijn> edlinde: So presumably it's calling each function a -> b (where a is a number, hence the (Num a)) with the 3 as it's argument and returning the result
12:45:02 <Nopik> great, installing cairo pulled out ncurses as depedencies, interesting
12:45:14 <edlinde> I mean I get the type system and all .. its just this $ stuff that is weird to me thats all
12:45:26 <merijn> edlinde: Don't think to much about $
12:45:26 <EvanR-work> use / instead then
12:45:35 <merijn> $ is for removing parenthesis from your code
12:45:36 <edlinde> yeah maybe I should skip it
12:45:36 <EvanR-work> or use $ in a more common context
12:45:45 <edlinde> aha
12:45:48 <EvanR-work> f . g . h $ x
12:46:07 <edlinde> that maybe best.. it can always be replaced with braces for grouping which is also clear enough
12:46:28 <EvanR-work> and ($ 3) in your example can be replaced with (\f -> f 3)
12:46:35 <edlinde> EvanR-work: the . was composition yeah?
12:46:40 <merijn> edlinde: "putStrLn $ func arg1 arg2" is nicer then "putStrLn (func arg1 arg2)"
12:46:42 <EvanR-work> yes
12:46:45 <edlinde> f . g. h $ x
12:46:47 <edlinde> hmm
12:46:51 <ManateeLazyCat> Nopik: Ok now?
12:46:59 <EvanR-work> merijn: no way
12:47:05 <jmcarthur> f . g . h $ x  == (f . g . h) x == f (g (h x))
12:47:09 <edlinde> EvanR-work: what did the $ do there?
12:47:20 <jmcarthur> EvanR-work: yes way
12:47:21 <edlinde> jmcarthur: ok 
12:47:26 <EvanR-work> no wai
12:47:54 <EvanR-work> down with the dollar
12:47:58 <Nopik> ManateeLazyCat: ongoing.. it seems that my system package manager (macports) was broken, after reinstalling, i issued 'install cairo' and it is still running.. downloaded like 20+ depedency packages so far, so with a bit of luck it will end soon and install the cairo
12:48:09 <EvanR-work> edlinde: see what jmcarthur said
12:48:24 <EvanR-work> its a precedence thing
12:48:39 <edlinde> yeah i get it now.. it did exactly what I thought it did :)
12:48:59 <edlinde> I mean if you ommitted the $ what would it do differently?
12:49:00 <merijn> edlinde: $ makes sense if you don't overthink it :p
12:49:10 <EvanR-work> type error probably
12:49:16 <edlinde> f . g . h x
12:49:17 <ManateeLazyCat> Nopik: Ok, if you can't fix it yourself, ask in gtk2hs list will help . :)
12:49:20 <merijn> f . g . (h x) which is probably wrong
12:49:27 <edlinde> f (g (h x))
12:49:33 <EvanR-work> no
12:49:34 <edlinde> should amount to that I would think
12:49:39 <merijn> No
12:49:55 <Nopik> ManateeLazyCat: ok ;)
12:50:01 <edlinde> does . have higher precendence than a space?
12:50:05 <edlinde> *precedence 
12:50:15 <EvanR-work> space has highest (?)
12:50:17 <merijn> Equal
12:50:24 <Nopik> ManateeLazyCat: but installing cairo should help, definitely ;)
12:50:24 <b_jonas> endojelly: f . g . h $ x actually parses as (f . g . h) $ x, so if you omit the $ there then nothing changes
12:50:26 <merijn> Or am I wrong again?
12:50:29 <b_jonas> um, sorry
12:50:31 <b_jonas> I'm tired
12:50:34 <Nopik> great.. now it says that openssl is necessary as well
12:50:51 <Nopik> cairo has very interesting depedency list ;)
12:51:04 <jmcarthur> f . g . h x == \y -> f (g (h x y))
12:51:04 <ManateeLazyCat> Good night all. :)
12:51:07 <EvanR-work> edlinde: if (h x) is not a function, then using it with . will be an error
12:51:11 <Nopik> ManateeLazyCat: good night ;)
12:51:13 <ManateeLazyCat> 03:00 AM in chian.
12:51:17 <ManateeLazyCat> China.
12:51:19 <ManateeLazyCat> Bye
12:51:54 <edlinde> jmcarthur: didn't get how you get the g ( h x y )
12:52:12 <edlinde> is it really h x y in the innermost one?
12:52:36 <EvanR-work> compare with 
12:52:44 <edlinde> ah ok 'y' is just the argument yeah?
12:52:49 <edlinde> ok gotcha
12:52:53 <EvanR-work> map (+3) . filter (/= 2) . even $ [1,2,3,4,5]
12:53:23 <edlinde> gave me an error
12:53:37 <EvanR-work> ah right
12:53:44 <EvanR-work> remove the . even
12:54:06 <edlinde> ok works
12:54:15 <EvanR-work> the arguments to the map and filter have higher precendence than the . and the list
12:54:24 <edlinde> removing the $ now gives me an error
12:54:40 <nooodl> that's because of how $ works
12:54:45 <EvanR-work> right because filter (/= 2) [1,2,3,4,5] is not a function
12:54:51 <edlinde> *Main> (map (+3) . filter (/= 2))  [1,2,3,4,5]
12:54:52 <edlinde> [4,6,7,8]
12:55:09 <edlinde> so I just do the same as $ does yeah?
12:55:12 <EvanR-work> yes
12:55:19 <edlinde> group them together so the composition takes place first
12:55:20 <edlinde> ok
12:55:34 <EvanR-work> first is the filter (/= 2)
12:55:37 <tibbe> quick poll: what do people think about integrating network-bytestring into network?
12:56:07 <EvanR-work> Network by itself has only the most trivial convenience methods
12:58:36 <Nopik> come on, python as cairo depedency?
12:58:57 <tibbe> EvanR-work: I mostly want to integrate them cause network 1) uses the wrong types (i.e. String instead of a byte sequence type like ByteString) and 2) it's slow
12:59:02 <EvanR-work> Nopik: much of haskell is now implemented in python these days
12:59:18 <kmc> haha
12:59:20 <EvanR-work> we will soon be removing all alternative ways to do it
13:00:04 <Nopik> EvanR-work: yeah, i bet it is because python is the only other language which base on whitespace indentation
13:00:14 <EvanR-work> thats part of it yeah
13:00:24 <cads> hey, I have this issue: http://hpaste.org/paste/40747/annotation#p40748
13:00:51 <cads> I have a function of type Ord a => a -> [a] -> [a], and I'm able to implement another function in terms of a fold with this function
13:01:27 <cads> it works if I evaluate the second function in ghci, but if the function is in the file, there is an error, as in the paste
13:01:32 <cads> any ideas
13:01:42 <kmc> write a type signature
13:01:48 <cads> for the second function?
13:01:55 <kmc> for everything at top level, as a matter of style
13:01:58 <kmc> but yes, for the second function
13:02:06 <kmc> like the message says, it's the monomorphism restriction
13:02:18 <EvanR-work> - strikes again
13:02:19 <djahandarie> It strikes again!
13:02:20 <djahandarie> ...
13:02:23 <djahandarie> Wow
13:02:49 <kmc> the best solution here is to get a time machine and go back and convince the Haskell 98 committee to drop the monomorphism restriction
13:02:51 <kmc> bring cookies
13:02:54 <EvanR-work> i have never been struck with it, maybe im not doing stuff particularly generic
13:03:02 <kmc> the second-best solution is to write a type signature
13:03:16 <kmc> you could also disable mmr with that ghc flag it mentions
13:03:18 <merijn> EvanR-work: Once work on Berp is complete the circle is complete and haskell will be completely implemented in python and vice versa :p
13:03:34 <kmc> or eta-expand the definition: foldrsort xs = foldr f [] xs
13:03:41 <kmc> because mmr only applies to things written points-free
13:03:44 <EvanR-work> i want a cyclic implementation
13:03:52 <djahandarie> Which is really the bad part
13:03:56 <edlinde> In learn you a haskell is the chapter on modules important? :)
13:04:01 <merijn> EvanR-work: Of what?
13:04:03 <djahandarie> Though, other things happen when you write stuff point-free too
13:04:05 <edlinde> or can I safely skip it?
13:04:07 <EvanR-work> Pyskell
13:04:10 <edlinde> (for now)
13:04:11 <djahandarie> Like optimization stuff
13:04:11 <merijn> edlinde: Of course it is
13:04:12 <Twey> edlinde: It's important
13:04:17 <EvanR-work> running any code on it causes _|_
13:04:18 <edlinde> hmm ok
13:04:33 <nus> EvanR-work, Hython
13:04:42 <EvanR-work> pyskon
13:04:43 <merijn> edlinde: In the words of the Zen of Python: Namespaces are one honking great idea -- let's do more of those!
13:04:50 <edlinde> So I need to understand how to make modules before knowing how to make typeclasses?
13:05:03 <edlinde> ok
13:05:06 <merijn> edlinde: The modules stuff is pretty easy
13:05:16 <kmc> Haskell's module system is clean and simple
13:05:19 <EvanR-work> they are orthogonal
13:05:19 <edlinde> merijn: thats why I wanted to skip it.... 
13:05:20 <merijn> edlinde: And by pretty easy I mean "almost completely trivial for most use cases"
13:05:26 <kmc> and no, i don't think it's a prerequisite for classes
13:05:29 <kmc> just read the chapter ;P
13:05:43 <edlinde> merijn: I seen modules, signatures etc in ML... and it sounds the same
13:05:46 <merijn> I agree they're not a prerequisite, but I think you shouldn't skip 'em :p
13:05:48 <edlinde> but yeah
13:05:48 <kmc> no, it's much simpler
13:05:50 <edlinde> will read it
13:05:53 <kmc> much simpler than ML's modules
13:05:57 <kmc> less powerful too
13:05:59 <edlinde> ok
13:06:10 <EvanR-work> i like things less powerful ;)
13:06:13 <mauke> edlinde: modules consist of: put "module Foo.Bar where" at the top of your file
13:06:13 <b_jonas> haskell modules are mostly just namespaces
13:06:14 <edlinde> coz in ML we didn't really use modules so much
13:06:20 <b_jonas> they're not like ml modules
13:06:28 <sproingie> it'd be nice if python took its own maxim about namespaces for the modules it shipped with
13:06:32 <edlinde> unless ofcourse you are doing large scale projects etc
13:06:34 <cads> I don't get what the monomorphism restrictoin is
13:06:56 <kmc> cads, read the Report for the full details
13:07:08 <sproingie> http://www.haskell.org/haskellwiki/Monomorphism_restriction
13:07:14 <kmc> essentially certain definitions are not allowed to have polymorphic type
13:07:21 <kmc> as a misguided attempt to avoid confusing beginners
13:07:34 <EvanR-work> and the result is confused beginners
13:07:36 <b_jonas> kmc: I don't think that's the purpose
13:07:39 <sproingie> it only affects functions without a type signature
13:07:43 <sproingie> and you can turn it off regardless
13:07:43 <mauke> kmc: it's an optimization
13:07:51 <b_jonas> yep
13:08:53 <sproingie> personally i think it should be off by default
13:09:01 <sproingie> if it's really an optimization, turn it on
13:09:13 <b_jonas> sproingie: it's not like that
13:09:14 <kmc> if it's really an optimization, just provide a monomorphic signature yourself
13:09:17 <Nopik> yeah... after downloading tons of depedencies, package manager now finally decided to try install cairo ;)
13:09:26 <kmc> i thought the issue was to avoid things looking like they'd be shared when they aren't
13:09:38 <b_jonas> sproingie: it optimizes by making you notice when you do something that is inefficient
13:09:46 <kmc> but an expert would understand that typeclass polymorphism can inhibit sharing
13:09:53 <kmc> so it is for the benefit of beginners
13:10:08 <b_jonas> sproingie: imagine what it would be like if C didn't allow you to copy structs (including passing them as arguments or returning them)
13:10:21 <cads> kmc, I just wonder what it has to do with injective homomorphisms :P
13:10:21 <b_jonas> you could say that's an optimization because most of the time you want to pass references to them anyway
13:10:32 <sproingie> b_jonas: i tend to write C as if that were the case anyway
13:10:33 <kmc> ;P cads not much i think
13:10:42 <sproingie> most code i run into passes structs by pointer
13:10:43 <b_jonas> right, the monomorphism restriction is similar to that, but of course it's important that you have a way to override it
13:10:46 <cads> kmc, I quickly get confused by explanations of pattern matching when I try to read about the monomorphism restriction
13:10:47 <b_jonas> sproingie: exactly
13:11:00 <kmc> cads, how does pattern matching come into it at all?
13:11:01 <b_jonas> and in haskell, a good programmer would write code that obeys the mono restriction anyway
13:11:11 <b_jonas> even if the compiler didn't force them
13:11:13 <sproingie> C doesn't die when you try it tho
13:11:21 <kmc> if you declare a class-polymorphic 'value' and use it monomorphically, a smart compiler like ghc should be able to specialize and recover sharing, without the need to distort the visible type system
13:11:24 <sproingie> well old crappy compilers did
13:11:27 <b_jonas> sproingie: maybe it should be a warning then?
13:11:44 <sproingie> b_jonas: that sounds just about perfect
13:11:59 <EvanR-work> i pass small structures directly to avoid dynamically allocating 
13:12:00 <b_jonas> sproingie: only it doesn't really work, because it changes semantics a bit I think
13:12:12 <b_jonas> sproingie: but maybe I'm wront there
13:12:15 <cads> kmc, I'm sorry, it mentions simple pattern binding
13:12:15 <b_jonas> I dunno
13:12:19 <sproingie> "The monomorphism restriction says that any identifier bound by a pattern binding (which includes bindings to a single identifier), and having no explicit type signature, must be monomorphic. An identifier is monomorphic if is either not overloaded, or is overloaded but is used in at most one specific overloading and is not exported."
13:12:27 <b_jonas> anyway, instead of being a warning, it's an error you can override easily
13:12:27 <sproingie> that's where pattern binding comes in
13:12:35 <kmc> ah
13:12:36 <b_jonas> by providing a type signature for the variable
13:12:41 <kmc> there's pattern bindings and function bindings
13:12:55 <kmc> pattern bindings look like "let p = e" where p is a pattern
13:12:59 <cads> what's their definition of monomorphic here?
13:13:09 <b_jonas> at least I hope taht's what kmc means by "optimization"
13:13:10 <kmc> function bindings look like "let f x y z = e" where x,y,z are patterns
13:13:14 <EvanR-work> one type
13:13:17 <EvanR-work> not polymorphic
13:13:21 <sproingie> ocaml's MR really caused me much pain and suffering
13:13:28 <cads> oooooo
13:13:28 <kmc> monomorphic means its type has no "forall"
13:13:38 <kmc> ocaml has the value restriction, doesn't it?
13:13:46 <sproingie> oh i think it's even more restrictive than forall
13:13:50 <cads> so nothing to do at all with monos from CT :P
13:13:54 <kmc> right cads
13:14:16 <cads> hah, that's a weight that's lifted
13:14:16 <edlinde> when importing what options do you guys recommend?
13:14:22 <edlinde> import qualified?
13:14:34 <kmc> edlinde, i import "standard" stuff like Control.Monad unqualified
13:14:35 <EvanR-work> not unless you want to write java-like code
13:14:40 <sproingie> er nevermind that, i guess it would be a forall, i'm just used to them being implicit
13:14:51 <kmc> for everything else i import qualified with a short name using "as"
13:15:04 <cads> kmc, I kept trying to cram what I was seeing wtr haskell monomorphisms into the naive CT framework :P
13:15:12 <cads> wrt*
13:15:14 <edlinde> EvanR-work: just that the tutorial says you can have name clashes and end up calling the loaded module's implementation
13:15:19 <edlinde> which would suck
13:15:30 <EvanR-work> if there is a clash its an error
13:15:36 <kmc> edlinde, whenever unqualified imports are ambiguous, it's a compile time error
13:15:48 <EvanR-work> if you forgot to import the right module, its probably a type error
13:15:49 <edlinde> ok
13:15:50 <kmc> imports don't shadow other imports, and definitions in your local module don't shadow imports
13:16:03 <edlinde> thats good then
13:16:07 <kmc> (but "let", "where", lambda, etc. do shadow)
13:16:28 <kmc> EvanR-work, just because Java does something doesn't make it a bad idea...
13:16:43 <EvanR-work> it usually does though
13:16:47 <kmc> yeah
13:17:16 <b_jonas> like one class per compilation unit?
13:17:24 <EvanR-work> we should have a php extension so that undefined identifiers dont cause an error, and neither does name clashes or type errors
13:17:28 <sproingie> one public class per compilation unit
13:17:45 <mauke> ghc -fignore-errors
13:18:04 <EvanR-work> ignore errors? and still compile something?
13:18:07 <EvanR-work> nice
13:18:09 <sproingie> and until "compilation unit" stops being synonymous with "file", i'm going to call that one an onerous restriction
13:18:37 <sproingie> one that usually makes things easy to browse but still an annoyance
13:19:06 <EvanR-work> i tend to have 'one main' class or data type in a .hs file
13:19:16 <EvanR-work> or not
13:19:30 <kmc> yeah, i hated OOP until I used Python, where declaring a new class is a breeze
13:19:53 <sproingie> the lovely thing about python is that "class" is a statement executed like any other
13:20:22 <sproingie> as is "def".  makes visibility very simple to understand
13:20:38 <mauke> .oO( you mean like perl? )
13:20:43 <sproingie> nooooo
13:20:50 <sproingie> perl has multiple compilation passes
13:20:55 <mauke> wat
13:22:10 <EvanR-work> isnt perl implemented with haskell now
13:22:11 <kmc> yes, you can even nest "class" within "def", declare a class locally (capturing some variables), and return the class
13:22:13 <sproingie> not so much compilation as execution phases
13:22:24 <edlinde> is it best to use the strict versions of fold like foldl' ?
13:22:32 <kmc> edlinde, depends what you're doing
13:22:39 <edlinde> It seems like the stricter does a much better job on lists
13:22:40 <mauke> edlinde: in general you want either foldr or foldl'
13:22:47 <kmc> if the result of the fold is something monolithic like a number, foldl' is good
13:22:56 <sproingie> EvanR-work: no, rakudo is C
13:23:00 <kmc> if the result can be consumed lazily (e.g. another list), you might want foldr
13:23:05 <sproingie> actually it's mostly perl
13:23:14 <edlinde> hmm
13:23:17 <edlinde> kmc: ok
13:23:18 <b_jonas> kmc: yes, it's like smalltalk or ruby only better
13:23:26 <b_jonas> python dynamic classes that is
13:23:47 <sproingie> kmc: actually 'class' doesn't capture, which is highly annoying
13:23:47 <EvanR-work> why is the benefit of a dynamic oop clas
13:23:54 <edlinde> kmc: are you sadying foldr when you want a list output because mostly its best to start from the back of the list forward?
13:23:57 <kmc> in fact the "class" statement is just sugar for calling type(name, bases, dict) right
13:24:03 <sproingie> yep
13:24:08 <mauke> edlinde: foldr starts at the front
13:24:11 <kmc> edlinde, no
13:24:31 <b_jonas> kmc: only it also creates a new scope for its body
13:24:43 <kmc> edlinde, map f = foldr ((:) . f) []
13:24:45 <kmc> now if you used foldl'
13:24:46 <b_jonas> kmc: and for that you don't really have other sugar in python
13:24:52 <kmc> it wouldn't work the same way
13:25:02 <lewurm> does someone have a cool picture related to haskell? (except http://www9.picfront.org/token/3kLD/2010/10/21/1882310.jpg and http://www9.picfront.org/token/3kLD/2010/10/21/1882307.png)
13:25:03 <kmc> though since foldl' is only head-strict, perhaps the difference is not so big
13:25:20 <b_jonas> lewurm: there used to be the lambdacats site, but it's defunct I think
13:25:26 <kmc> i fucking hate that first thing
13:25:36 <b_jonas> lewurm: hs themed lolcats
13:25:42 <sproingie> lewurm: http://images2.wikia.nocookie.net/__cb20091031085410/uncyclopedia/images/thumb/8/85/NarleyYeeaaahh.jpg/800px-NarleyYeeaaahh.jpg
13:25:50 <merijn> b_jonas: It's still there
13:26:04 <b_jonas> http://www.listware.net/201008/haskell-cafe/18414-haskell-cafe-lambdacats.html
13:26:05 <merijn> Or rather, there's a mirror of lambda cats
13:26:07 <merijn> But lambdabot has the url and lambdabot is dead
13:26:21 <b_jonas> merijn: what's the correct url?
13:26:51 <merijn> b_jonas: I don't know, I figured I could always ask lambdabot :<
13:27:08 <merijn> oh, wait
13:27:15 <merijn> It might be in my e-mail sent items
13:27:24 <merijn> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#960526161_yXhEz
13:27:29 <EvanR-work> kmc: lol its hilarious
13:27:47 <merijn> Lambda cats \o/
13:27:47 <lewurm> greeat, thx! :D
13:29:10 <b_jonas> merijn: thanks
13:29:38 <b_jonas> merijn: ah, in fact that forum thread I linked to tells that url you gave
13:30:49 <b_jonas> strange, it has an image I don't remember seeing in the original site
13:31:05 <b_jonas> delimitd kontinuashun
13:37:32 <danharaj> the haskell subreddit should be named to the dons subreddit.
13:38:17 <monochrom> keep the haskell subreddit. open dons subsubreddit.
13:45:56 <dolio> It isn't as bad as the types reddit.
13:46:44 <dolio> 20 of the first 25 stories there were posted by japple.
13:46:57 <roconnor> This uniplate stuff looks an awful lot like a lens.
13:47:09 <dolio> And 24 of the first 30.
13:48:33 <edlinde> is it possible to split a string based on some pattern like Perl does with regular expressions?
13:48:54 <edlinde> like if I wanted to split a line like "adad;32;43242;" on the character ; ?
13:48:58 <EvanR-work> Data.String.Utils has a split and join on a constant pattern
13:49:00 <Botje> Data.List.Split
13:49:09 <Botje> or you use one of the regex packages
13:49:21 <edlinde> ah ok so there is a regex package
13:49:28 <edlinde> I saw the splitAt
13:49:43 <edlinde> thought it would be cool to split on a certain regexp
13:49:46 <EvanR-work> splitOn is in Data.List.Split, split is in Data.String.Utils
13:49:56 <EvanR-work> regex considered harmful
13:53:01 <edlinde> EvanR-work: why is it harmful?
13:53:22 <EvanR-work> its almost never the best way
13:53:44 <EvanR-work> i think 'it would be cool to' is the best case they can make for it
13:53:46 <edlinde> I mean how else would you read in say a CSV file line by line and store it in some datatype?
13:54:14 <EvanR-work> if you dont have a csv file decoder already made, just split "," . lines
13:55:00 <EvanR-work> map (\row -> build data type with row) .
13:55:18 <EvanR-work> theres also parser frameworks
13:55:53 <edlinde> ok
14:03:03 <merijn> edlinde: Regex's are almost always the wrong solution to any question starting with "How do I parse..."
14:03:53 <EvanR-work> or anything involving 'line by line' or involving 'storing into a datatype'
14:03:57 <merijn> Regexes are for matching tokens, not for parsing data. In fact, the very definition of a regex guarantees they can't parse most data
14:04:34 <EvanR-work> they dont even completely tokenize a character stream very well :(
14:05:03 * hackagebot dstring 0.4 - Difference strings  http://hackage.haskell.org/package/dstring-0.4 (BasVanDijk)
14:05:31 <merijn> Anyhoo, bed time!
14:10:10 * hackagebot string-combinators 0.6 - Polymorphic functions to build and combine stringlike values  http://hackage.haskell.org/package/string-combinators-0.6 (BasVanDijk)
14:12:27 <erisco> has a language processor been written in Haskell? is it practical to do so? I ask because I am interested in trying to write one as a learning process and the ideas that come to my mind are not elegant in a functional language
14:12:50 <Nibble> erisco: well, language processor as in human language?
14:12:54 <EvanR-work> parser?
14:13:00 <Nibble> if it is a parser
14:13:03 <Nibble> look at parsec
14:13:14 <erisco> sorry, I should have specified. I want to parse math statements and eventually sql-like strings
14:13:14 * hackagebot concurrent-extra 0.6 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.6 (BasVanDijk)
14:13:25 <erisco> math expressions I should say
14:13:39 <Nibble> erisco: look at parsec
14:15:04 <sajkr> @pl \a -> f a a
14:16:00 <erisco> hm, thanks
14:17:21 <krey_> hello, I have 3 types which are isomorphic, ie. can be converted into one another, and I've written all 6 conversion functions. I would like to create a type class so that I could convert from one type to another simply by inference. is this possible?
14:17:38 <EvanR-work> krey_: Convertible
14:17:45 <EvanR-work> maybe
14:18:09 <erisco> Nibble: I don't really want to look at how they did the parsing but it is good to know that it has been done
14:18:11 <byorgey> krey_: it's possible if you don't mind adding a call to a function 'convert' or the like
14:18:17 <EvanR-work> but theres no converting invisibly, at some point you have to use toX and fromY wrappers
14:18:18 * hackagebot threads 0.3.1 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.3.1 (BasVanDijk)
14:18:20 <byorgey> class Convertible a b where convert :: a -> b
14:19:16 <byorgey> krey_: also, however, if your types are all "models" of the same "signature" you can make a type class with that signature.
14:19:19 * hackagebot explicit-iomodes 0.6 - File handles with explicit IOModes  http://hackage.haskell.org/package/explicit-iomodes-0.6 (BasVanDijk)
14:19:25 <joe1> any good suggestions for a good parsec tutorial for a newb?
14:19:35 <krey_> byorgey: not sure I follow you
14:19:35 <joe1> real basic, I mean?
14:19:46 <byorgey> krey_: yeah, I'm not sure the best way to explain what I mean.
14:19:49 <krey_> byorgey: would it help you explaining if I went into detail?
14:19:50 <byorgey> krey_: can I ask what the types are?
14:19:53 <byorgey> yes
14:20:12 <krey_> byorgey: DFA st ab, NFA st ab, AFA st ab
14:20:26 <byorgey> what's AFA?
14:20:34 <krey_> byorgey: and they represent deterministic, non-deterministic, and alternating automata
14:20:43 <byorgey> ok
14:21:10 <EvanR-work> you can make a abstract type which holds one of the three
14:21:15 <byorgey> so I think a Convertible type class is probably the way to go
14:21:29 <EvanR-work> and a polymorphic convertFrom which gives you the desired version, possibly converting
14:21:33 <EvanR-work> Convertible
14:21:36 <byorgey> then whenever you want to convert one to the other you can just call 'convert'
14:21:52 <byorgey> and have six instances of Convertible for the six different conversions
14:22:00 <krey_> I see
14:22:13 <krey_> but aren't multi-parameter typeclasses evil or something?
14:22:18 <byorgey> no.
14:22:19 <krey_> I honestly can't remember
14:22:24 <byorgey> they are quite useful.
14:22:35 <krey_> ok, then :)
14:22:39 <byorgey> they can just be tricky to work with sometimes.  but not in this case.
14:23:04 <krey_> I seem to recall that typechecking became undecidable or something
14:23:08 <krey_> but maybe that's something else
14:23:30 <byorgey> must be something else.  typechecking is fine.
14:24:10 <EvanR-work> you wouldnt be messing with the class, youd just be defining an instance
14:24:55 <djahandarie> MPTCs ftw
14:25:09 <krey_> byorgey, EvarR-work: thanks, back to coding :)
14:28:06 <mreh> is there an implementation of push-pull FRP in existance?
14:28:28 * hackagebot explicit-iomodes-bytestring 0.1.0.2 - Extends explicit-iomodes with ByteString operations  http://hackage.haskell.org/package/explicit-iomodes-bytestring-0.1.0.2 (BasVanDijk)
14:29:29 * hackagebot explicit-iomodes-text 0.1.0.3 - Extends explicit-iomodes with Text operations  http://hackage.haskell.org/package/explicit-iomodes-text-0.1.0.3 (BasVanDijk)
14:33:25 <kwos> I'm not sure how to go about it, but I'd like to generate a bunch of types based on some information stored in some persistent form, say a flat file or a database
14:33:33 <kwos> what's the best way to go about it?
14:34:34 * hackagebot repr 0.4 - Render overloaded expressions to their textual representation.  http://hackage.haskell.org/package/repr-0.4 (BasVanDijk)
14:38:18 <dbro> Newbie question: I'm trying to troubleshoot xmobar's swap usage. It always shows zero. So I'm diving into the code (v 11.1), using ghci. I want to import the source code file in /Plugins/Monitors/Swap, and play around with it. So in ghci, I tried the command ":load Plugins.Monitors.Swap" but I get the error "Plugins.hs:25:7:  Could not find module `XUtil'", which suggests that it's trying to load more than just the one file I want. 
14:39:37 * hackagebot usb 0.6.0.3 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.6.0.3 (BasVanDijk)
14:41:43 * hackagebot usb-enumerator 0.1.0.3 - Iteratee enumerators for the usb package  http://hackage.haskell.org/package/usb-enumerator-0.1.0.3 (BasVanDijk)
14:45:17 <EvanR-work> dbro: its going to also load any modules imported by that module
14:45:23 <EvanR-work> they need to be available
14:46:32 <dbro> EvanR-work: thanks. I suppose I need to create a whole new source file for experimenting in this case?
14:47:15 <EvanR-work> ideally you load the module youre trying to debug
14:47:36 <EvanR-work> figure out whats wrong with XUtil
14:47:58 <dbro> yeah, but it's got all these extra dependencies that I'm not working with right now. (shouldn't this be "lazy" ?)
14:48:20 <EvanR-work> i think it is, but it still needs to know that it can be found when needed
14:48:35 <EvanR-work> does the package build and install?
14:49:21 <dbro> I havent tried yet. I think I previously installed it using cabal or something automated?
14:57:13 <Paczesiowa> is it possible to write fix using Mu type (without let rec)? what's the catamorphism of Mu? are those questions related?
14:59:04 <kmc> http://okmij.org/ftp/Haskell/Fix.hs
14:59:57 <ClaudiusMaximus> dbro: you might need to start ghci with   -package nameofpackage   (this is the kind of stuff that ghc --make adds for you)
15:00:36 <Paczesiowa> kmc: I've seen that of course, but Mu isn't there. or is it?
15:00:39 <benmachine> I'd guess the catamorphism for Mu f would be :: (f b -> b) -> b
15:00:45 <benmachine> er
15:00:48 <benmachine> I'd guess the catamorphism for Mu f would be :: (f b -> b) -> Mu f -> b
15:01:02 <dbro> EvanR-work: yes, the code builds without errors. Note that it comes with a file called "XUtil.hsc" - is that something ghci won't work with?
15:01:20 <EvanR-work> it needs to be run through something to produce a .hs
15:01:38 <EvanR-work> which will happen when you do cabal build
15:02:10 <dbro> Claudius: thanks for the suggestion. I got this message when trying that: "<command line>: cannot satisfy -package XUtil"
15:02:20 <benmachine> and then you can use ghci by specifying -idist/build/autogen
15:02:44 <benmachine> dbro: XUtil is not a package it's a module
15:03:24 <dbro> EvanR-work: oh, I didn't use cabal to download this. I just unpacked the tar file. (Sorry, I must sound like quite an idiot. sucks to be new)
15:03:37 <benmachine> dbro: if the code builds without errors, do you get a dist/build/autogen and does it contain XUtil.hs?
15:03:46 <benmachine> (not .hsc)
15:04:26 <joe1> guys, I am thinking of using haskell to generate some vhdl code based on a data file. One option is to just use print statements while reading the data file, which I can do. I am wondering if there are any smarter ways of doing so.
15:05:01 <dbro> benmachine: yes, it built without errors. No, I don't see that file. I only see these two in there: cabal_macros.h  Paths_xmobar.hs
15:05:02 <kmc> joe1, http://hackage.haskell.org/package/vhdl
15:05:13 <joe1> kmc: thanks.
15:05:24 <Paczesiowa> benmachine: how would you implement that?
15:05:38 <benmachine> Paczesiowa: you wouldn't because I'm wrong
15:05:57 <benmachine> dbro: oh, is it in dist/build?
15:06:02 <kmc> typically if you are doing a project which involves 'foobar' (some library / program / system / idea / etc) it is worth going to the hackage package list and Ctrl-F foobar
15:06:32 <dbro> benmachine: yes! it's in dist/build/xmobar/xmobar-tmp/
15:06:49 <benmachine> dbro: not just in dist/build? I'm surprised but I guess that works too
15:07:01 <benmachine> dbro: try running ghci with -idist/build/xmobar/xmobar-tmp
15:07:09 <benmachine> that should tell ghci, look here for files
15:07:46 <dbro> benmachine: thanks! "Ok, modules loaded: Plugins.Monitors.Swap, Plugins.Monitors.Common, Plugins, Commands, XUtil."
15:08:07 <benmachine> :)
15:11:22 <mikeg> Is there any mathematical laziness in Haskell? i.e. 0 * (length (repeat 0)) == 0
15:11:52 <benmachine> mikeg: not with the default numeric types, but (*) can be overloaded with your own type
15:12:49 <benmachine> mikeg: it is possible to define lazy natural numbers for which 0 * x == 0 for all x
15:12:58 <ziman> > 0 * (genericLength (repeat 0)) :: Natural
15:13:04 <benmachine> but they're vastly less efficient for most things
15:13:07 <mikeg> Is it a optimization thing?
15:13:09 <ziman> hm.
15:13:31 <ray> but is it possible to define lazy nats for which 0 * x == 0 and x * 0 == 0
15:13:35 <ray> (the answer is yes)
15:13:51 <benmachine> ray: only using unamb, which is a bit weird
15:13:57 <mikeg> And is that a Haskell thing or a GHC thing? Could a different compiler have Int's with lazy semantics?
15:13:59 <benmachine> or lub, more probably
15:14:07 <ray> unamb is just the most elegant way there are probably others
15:14:41 <rinzai> hi everyone!
15:14:42 <benmachine> ray: I don't think so, without unamb you have to inspect one of the arguments first
15:14:46 <benmachine> if it's _|_ you lose
15:15:02 <benmachine> unless you cheat and define _ * _ = 0
15:15:04 <benmachine> <_<
15:15:10 <benmachine> the trivial ring woo
15:15:26 <ray> well if you want to do your multiplication in the trivial ring
15:15:32 * benmachine isn't actually sure that's the trivial ring
15:15:35 * benmachine hasn't done rings yet
15:15:42 <ray> it's certainly trivial
15:15:54 <benmachine> mikeg: I don't know the answer to that, but http://haskell.org/onlinereport does
15:16:05 <mikeg> Thanks :)
15:16:16 <ray> i only know the algebras i've picked up here and there maybe i should take a course one of these months
15:16:41 <benmachine> ray: it's certainly trivial but I'm not 100% sure it's a ring :P
15:16:46 <benmachine> I think it is
15:16:54 <ray> i am the world's laziest student i will have a BA by 2020 or thereabouts
15:17:07 <rinzai> super noob question... can anyone point me to a really simple example of how to count the number of lines in a file starting with a centain substring? I've gone as far as successfully opening the file and printing its contents...
15:17:12 <benmachine> I just had this idea the additive and multiplicative identities had to be distinct
15:17:15 <ezyang> Is there a way to have "nonblocking update" in a let block? I know, this doesn't make too much sense, and I shouldn't shadow variables anyway, but I was curious if there was of doing this. 
15:17:20 <rinzai> sorry, it's a really basic question ... :-S
15:17:23 <ezyang> Basically, 
15:17:26 <ezyang> > let x=1 in let {x=2;y=x} in y 
15:17:32 <ezyang> 2 
15:17:36 <ezyang> but have it return 1 instead. 
15:17:55 <benmachine> ezyang: a non-recursive let, basically?
15:17:58 <Lemmih> rinzai: See: filter, isInfixOf and length.
15:18:01 <ezyang> benmachine: Yep. 
15:18:18 <Lemmih> rinzai: Oh and 'lines'.
15:18:46 <benmachine> do is non-recursive; maybe you could use the identity monad and something like, (x, y) <- return (2, x)
15:18:57 <ezyang> heh, ok. 
15:19:05 <rinzai> Lemmih, cool. thanks!
15:19:21 <benmachine> ask a silly question get a silly answer :P
15:30:41 <dbro> quick q: How can I declare a float in ghci? I tried "let a = 3.4f" but it didn't like it. Neither "Float 3.4". I don't want a double.
15:30:50 <danr> let a = 3.4 :: Float
15:30:55 <dbro> thanks!
15:33:12 <monochrom> also: let { a :: Float; a = 3.4 }
15:33:50 <monochrom> this form is useful if you want to give a function a type signature
15:39:03 <tarwatirno> brittanyjencks: So I am looking at implementing a Euclidean Distance Transform in Haskell. Anyone have any ideas that might be useful?
15:41:45 <tarwatirno> That last chat was directed at anyone. Chat client had a hicup.
15:46:32 <ymasory> hi everyone. i'm looking to add more rows to this chart comparing some programming languages i know/am learning: http://github.com/ymasory/Lang-Chart/blob/master/langchart.org
15:46:56 <ymasory> (i'm *not* looking to fill in cells). anyone interested in suggesting a few more points of comparison?
15:48:10 <megajosh2> "Abstradct types"?
15:48:13 <megajosh2> *abstract
15:48:23 <Pseudonym> Algebraic types would be useful, I think.
15:48:31 <Pseudonym> Parametric polymorphism.
15:48:40 <ymasory> megajosh2: i'm using scala terminology there. types that are fields that subclasses implement
15:48:48 <megajosh2> Hmmm...
15:48:57 <megajosh2> I oughtta take a look at scala sometime
15:48:59 <ymasory> oh i should add that, abstract fields in general
15:49:17 <Pseudonym> Something about the module system might be worth a mention.
15:49:19 <megajosh2> Would you ever consider a record an object?
15:49:36 <megajosh2> If you simply define one as "unction/data containers that are first-class values" that is
15:49:39 <megajosh2> *function
15:49:45 <ymasory> megajosh2: don't know enough to say. i consider it an object if it can take functions and data and can be passed around as a value
15:50:11 <ymasory> Pseudonym: i don't know enough about module systems to categorize. can you suggest any rows?
15:50:24 <Pseudonym> ymasory: It's an interesting question, because whether or not a language is "object oriented" is usually not a question of capability, but of syntax.
15:50:37 <benmachine> ymasory: you could add "type functions" or something similar
15:50:43 <Pseudonym> Oh, module systems.  Uhm... not offhand, no. :-)
15:50:50 <megajosh2> Type functions... like int()?
15:51:04 <benmachine> megajosh2: no >_> like type families
15:51:06 <benmachine> or fundeps
15:51:09 <ymasory> okay, i'll add type functions, algebraic types, parametric polymorphism. (although i don't know what any of them are yet :))
15:51:43 <megajosh2> Haskell has closures of course with lambda functions
15:51:50 <megajosh2> And let blocks are lexically scoped
15:52:01 <ezyang> megajosh2: Everything is a closure in Haskell :-) 
15:52:02 <benmachine> ymasory: I don't know if type functions is the best term, but general type-level computation
15:52:05 <ymasory> oh i should add structural types
15:52:07 <megajosh2> I guess so...
15:52:14 <benmachine> closures are an implementation mechanism!
15:52:17 <benmachine> apparently.
15:52:20 <ymasory> and existential type
15:52:21 <ymasory> s
15:52:22 <benmachine> not a lanaguage feature
15:52:24 <mauke> ezyang: I disagree
15:52:28 <ray> "closures" is a silly lisper bragging word that means "lambdas work as expected"
15:52:33 <megajosh2> lol
15:52:40 <ezyang> mauke: Ok, sure. 
15:52:41 <benmachine> ray: well, they don't in python :P
15:52:51 <megajosh2> I think OCaml has first-class modules
15:52:53 <ezyang> values of Int# aren't closures :-) 
15:52:54 <ray> see python lacks closures
15:52:55 <mauke> benmachine: how do they not?
15:52:55 <ray> !
15:52:56 <megajosh2> Does F#?
15:53:08 <mauke> ezyang: id is not a closure
15:53:12 <benmachine> python doesn't lack closures, it just has what I consider to be surprising behaviour
15:53:21 <megajosh2> those stinking lambda: blocks
15:53:40 <zygoloid> python has weird scoping rules, but has closures
15:53:41 <ezyang> I've never been clear: if a function doesn't reference its enclosing environment, is it still a closure? 
15:53:46 <ClaudiusMaximus> hm, how do i go about reinstalling everything i ever installed with cabal-install, but this time with new options (like enabling split objects)?
15:53:55 <benmachine> mauke: oh I don't even remember the example I was thinking of, something to do with arguments unexpectedly being passed by reference
15:53:59 <megajosh2> ezyang: Something I wasn't sure of myself
15:53:59 <mauke> ezyang: according to my definition, no
15:54:09 <zygoloid> ezyang: there's nothing for it to close /over/
15:54:15 <megajosh2> Hmm
15:54:15 <benmachine> well
15:54:17 <Draconx|Laptop> megajosh2, SML doesn't have first class modules, I thought OCaml was similar?
15:54:19 <ray> "closures are an implementation mechanism" works
15:54:24 <benmachine> you could say it has access to the environment but doesn't use it
15:54:30 <benmachine> but that's a bit of an irrelevant argument
15:54:50 <megajosh2> Draconx|Laptop: I thought I saw some relatively recent updates to OCaml that gave it first-class modules or something like that
15:54:59 <megajosh2> But I don't know OCaml, so I'm not all that sure
15:54:59 <benmachine> unless it calls other functions which thereby gain access to *its* environment 
15:55:15 <monochrom> OCaml first-class module is recent.
15:55:25 * zygoloid arbitrarily defines closure as "a (function, environment) pair". the answer is then "it's implementation-defined at best"
15:55:55 <ezyang> GHC doesn't really use textbook closures... 
15:56:06 <kwos> is it possible to somehow derive a whole bunch of types from the content of a csv file? suppose I have something like "Foo";Bar;23 and I would somehow like to convert it into bunch of data Foo, instance Enum Foo, instance Show Foo..
15:56:10 <kwos> how to go about it?
15:56:44 <ezyang> kwos: Template Haskell! 
15:56:49 <mauke> search/replace
15:57:05 <mauke> I'd probably use perl
15:57:22 <Cleopatra> hi i have two lists: [2,7,3] and [8,9,1] im looking for way to add them up so that i get the following single list [2+8,7+9,3+1] or simply [10,16,3]  thanks
15:57:33 <kwos> hmm.. I don't like perl idea ;-)
15:57:38 <zygoloid> Cleopatra: zipWith (+)
15:57:40 <megajosh2> > zipWith (+) [2,7,3] [8,9,1]
15:57:45 <megajosh2> Eh?
15:57:47 <Cleopatra> cheers
15:57:51 <kwos> ezyang: I'll have a look, thanks
15:58:02 <zygoloid> preflex: seen lambdabot
15:58:02 <preflex>  lambdabot was last seen on #haskell-blah 10 hours, 32 minutes and 7 seconds ago, saying: i'll hafta plead the fifth on that one.
15:58:05 <megajosh2> > "is anybody out there"?
15:58:15 <monochrom> hahahahaha she really did
15:58:54 <Pseudonym> With preflex around, everyone should think hard about their last words.
15:59:11 <djahandarie> preflex: seen mmorrow
15:59:11 <preflex>  mmorrow was last seen on #ghc 276 days, 20 hours, 1 minute and 25 seconds ago, saying: * mmorrow is rtfm'ing
15:59:17 <monochrom> at least she did what she said :)
15:59:21 <mauke> preflex: seen god
15:59:21 <preflex>  god was last seen on ##c++ 1 year, 17 days, 23 hours, 53 minutes and 55 seconds ago, saying: I don't really know either actually
15:59:55 <ray> proof that c++ is undecidable: god is stumped
16:00:36 <mauke> preflex: quote
16:00:45 <preflex>  <lbr> I'd be in a superposition of not being able to do anything because I wouldn't be able to look up stuff but superproductive because I wouldn't be able to look up stuff
16:01:34 <ymasory> what do first-class modules really get you?
16:02:07 <pumpkin> another way of expressing yourself
16:02:26 <monochrom> oleg shows how to get gadt
16:06:59 <Martty> ok so using named constructors is the norm right?
16:07:07 <hpc> perl has first-class interpreter directives :D
16:07:09 <Martty> because it provides more flexibility
16:07:22 <hpc> sub strict { use strict; }
16:07:27 <Martty> i can see how changing a constructor could break everything
16:07:44 <Martty> but using named constructing seems more flexible in that respect.. even though its kind of a pain to write the field name every time
16:08:46 <mauke> hpc: huh?
16:08:48 <ClaudiusMaximus> Martty: there's an extension to avoid having to type so much each time (record puns?)
16:08:59 <Martty> np i'll manage
16:09:13 <hpc> mauke: "use strict" is similar to -Wall
16:09:24 <mauke> hpc: but it's not "first class"
16:09:32 <mauke> also it's more like gcc
16:09:39 <ClaudiusMaximus> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#record-puns and following
16:09:49 <mauke> in that gcc generally aborts on errors but perl doesn't (by default)
16:09:56 <hpc> mauke: eh? i thought the change happened on the function call
16:10:07 <mauke> hpc: impossible, 'use strict' is lexically scoped
16:10:15 <mauke> also, it's a compiler directive
16:10:20 <mauke> how can it happen at runtime?
16:11:12 <hpc> perl isn't "compiled" so much as it is two scripts
16:11:22 <hpc> one runs at "compilation" and the other is generated and run
16:11:23 <mauke> huh?
16:11:41 <monochrom> perl "compile time" and "run time" are not clear cut.
16:11:42 <mauke> no, perl compiles Perl code to bytecode, then runs that
16:12:01 <monochrom> or rather, "parse time" and "run time"
16:12:07 <mauke> you can make perl run Perl code #1 during the compilation of Perl code #2, but that will still compile #1 first
16:12:22 <mauke> (hi, lisp!)
16:12:47 <monochrom> then again, what does use strict do may be clear cut
16:12:51 <hpc> mauke: http://en.wikipedia.org/wiki/Perl#Implementation
16:12:58 <hpc> start at "most of what"
16:13:28 <mauke> hpc: that's basically what I said
16:13:51 <hpc> except that it can run perl at compile-time
16:13:58 <hpc> so you can have a non-terminating compilation
16:13:58 <mauke> <mauke> you can make perl run Perl code #1 during the compilation of Perl code #2, but that will still compile #1 first
16:14:08 <hpc> ah, you must have ninja'd me
16:14:50 <mauke> (defmacro foo () (loop)) (foo)  ; won't finish compiling
16:15:16 <mauke> I don't remember how to make CL run random code at parse/compile time directly
16:16:16 <hpc> i can't think of any easy-to-produce perl warnings off the top of my head to test this with
16:16:30 <mauke> test what exactly?
16:16:38 <hpc> the scope of 'use'
16:16:42 <mauke> 'use' has no scope
16:16:54 <mauke> it's imperative code that runs, not a declaration
16:17:26 <mauke> hpc: perl -e '{ use strict; } $zomg = 42;'
16:17:48 <mauke> remove the braces and it will yell at you because $zomg is undeclared
16:18:03 <hpc> huh
16:19:14 <Twey> Doesn't that mean it has block scope?  ;)
16:19:26 <mauke> what do you mean by "it"?
16:19:32 <Twey> ‘use’
16:19:36 <mauke> no
16:19:38 <monochrom> "it" = computer
16:19:45 <Twey> It doesn't take effect outside the braces
16:20:08 <mauke> use Some::Module ARGS; is sugar for BEGIN { require "Some/Module.pm"; Some::Module->import(ARGS); }
16:20:33 <mauke> the effects of strict->import have block scope, not 'use' in general
16:21:13 <Twey> 'kay
16:21:23 <mauke> IIRC strict->import flips some bits in $^H, which contains compiler state
16:21:35 <mauke> and is automatically restored at the end of the block
16:21:39 <mauke> or something like that
16:21:57 <hpc> *The more you know!*
16:21:58 <Martty> http://codepad.org/LT6VSIOg when i do something like this then call makeFriends jose pepe, is the stuff kept in the friends array actually pointers? or is it all copied? .. bit efficiency concerned
16:22:22 <Twey> No arrays there
16:23:12 <Twey> You don't need any of those parentheses except the tuples
16:23:32 <mauke> congratulations on using 'rhs' for the left arg and 'lhs' for the right arg
16:23:37 <Twey> Record update syntax would help
16:24:01 <mauke> makeFriends x y = (x{ friends = y : friends x }, y{ friends = x : friends y })
16:24:30 <Martty> sorry, record update syntax?
16:24:36 <mauke> what I just did there
16:24:41 <mauke> Martty: Haskell never copies anything
16:24:42 <dmwit> To answer the original question, it's all pointers.
16:24:47 <Martty> ok thanks
16:24:53 <Martty> its slowly starting to make sense
16:24:56 <dmwit> err, I mean, "go with your heart"
16:24:58 <mauke> if nothing is mutable, everything can be shared
16:25:21 <Martty> bear with me while it does
16:25:29 <roconnor> copy (x,y) = (x,y)
16:26:49 <mauke> roconnor: I wouldn't be surprised if ghc shared that
16:27:20 <roconnor> true
16:27:22 <roconnor> well
16:27:25 <hpc> i would be surprised if it didn't
16:27:27 <roconnor> GHC does almost no CSE
16:27:46 <roconnor> mauke: acutally laziness would prevent that
16:27:48 <Martty> i get a warning about uninitilized fields 
16:27:53 <mauke> copy = \tmp -> case tmp of (x,y) -> (x,y)
16:28:08 <mauke> copy = \tmp -> case tmp of (x,y) -> tmp
16:28:12 <hpc> Martty: when you declare a value of a record type, you need to provide a value for every field
16:28:37 <Martty> when does record update syntax work then?
16:28:45 <hpc> data Foo = Foo {x :: X, y :: Y} must be declared with Foo {x = bar, y = baz}
16:28:49 <hpc> you can't omit x or y
16:29:00 <mauke> Martty: always
16:29:04 <roconnor> @type exit
16:29:06 <Martty> O_o
16:29:16 <mauke> Martty: what line of code triggered the warning?
16:29:47 <Martty> oh i just relized
16:29:56 <zygoloid> hpc: sure you can
16:29:59 <Martty> the thing before the curly brace must be the name of the old record
16:30:03 <Martty> not the type
16:30:05 <Martty> >_<
16:30:13 <hpc> zygoloid: it curries?
16:30:22 <zygoloid> you can even write silly things like "Just {} :: Maybe Int"
16:30:26 <Martty> thanks mauke 
16:30:30 <hpc> zygoloid: lol
16:30:38 <hpc> how does that work?
16:30:43 <mauke> poorly
16:30:44 <zygoloid> hpc: it fills in the holes with _|_
16:30:48 <hpc> ew
16:30:49 <mauke> hpc: Just undefined
16:31:06 <mauke> it's nice for pattern matching, though
16:31:14 <hpc> it would be sort of nifty if monoids initialized as mzero
16:31:19 <mauke> case foo of Con {} -> ...
16:31:22 <hpc> that would be inconsistent with patterns though
16:31:27 <mauke> works no matter how many arguments Con has
16:31:56 <Martty> :r
16:31:58 <Martty> ..
16:31:59 <Martty> lol
16:32:07 <hpc> [sudo password for Martty]:
16:32:58 <zygoloid> hunter2
16:33:06 <sipa1024> ah someone known bash.org
16:33:07 <hpc> nice answer
16:33:11 <sipa1024> *knows
16:33:18 <hpc> sipa1024: who doesn't?
16:33:23 <sipa1024> 01:32:33 < zygoloid> *******
16:33:24 <FauxFaux> sipa1024: It's hunter1, get the reference right http://shoe.goeswhere NOT SAFE FOR WORK .com/hunter1.jpg
16:38:47 <tg_> isn't that special
16:39:27 <tg_> just in case you want to know it is, it's recursive male fellatio.
16:39:48 <tg_> hm.
16:42:11 <revenantphx> tg_: what?
16:42:23 <revenantphx> I join and this is the first thing I see. Out of context?...
17:01:55 <osaunders> What precedence level is ::?
17:02:51 <Pseudonym> osaunders: Lowest.  http://www.haskell.org/onlinereport/syntax-iso.html
17:03:20 <Pseudonym> exp -> exp0 :: [context =>] type | exp0
17:05:22 * fryguybob just got ghcjs to do something, now to make it do more....
17:07:58 * hackagebot gps 0.5.0 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.5.0 (ThomasDuBuisson)
17:09:00 * hackagebot gps 0.5.1 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.5.1 (ThomasDuBuisson)
17:09:13 <hpc> o.O
17:14:17 <pumpkin> anyone know of a way to generically grab all constructors that have a certain set of types for their parameters?
17:14:45 <hpc> pumpkin: TH?
17:14:56 <pumpkin> nah, I mean using either SYB or uniplate or something similar
17:15:07 <pumpkin> TH feels unnecessary here
17:15:29 <pumpkin> like if I had data Moo = A | B Int Bool | C Int Bool | D Float
17:15:49 <pumpkin> and I want all constructors with Int and Bool parameters
17:15:55 <pumpkin> and I want the values of those parameters
17:17:02 <ClaudiusMaximus> yay, with cabal-install using --enable-split-objs and --enable-shared , my executable is 2.9MB instead of 24MB
17:17:38 <hpc> does either of SYB or uniplate let you match types the way you would patterns?
17:18:45 <Martty> how does one solve cyclic importing?
17:18:55 <ezyang> bootstrap files. 
17:18:59 <ezyang> check the GHC manual. 
17:19:13 <ezyang> hs-boot, I think they are called. 
17:20:20 <osaunders> Pseudonym: Not lower than lambdas or brackets though apparently.
17:20:34 <osaunders> *evidently
17:21:26 <hpc> Martty: also refactoring; bootstrap files can be a pain in the ass
17:32:15 * hackagebot gps 0.5.2 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.5.2 (ThomasDuBuisson)
17:44:33 <pumpkin> I want a different kind of generics that use GADTs to represent the type of constructors
17:45:15 <pumpkin> so it'd take an existing type (including a GADT) and parametrize it by an additional parameter, then make each constructor refine that parameter to a nested tuple representing the type of the constructor's parameters
17:46:53 <pumpkin> so data Moo = A Int | B Bool String | C ==> data MooDesc a where A :: Int -> MooDesc (Int, ()); B :: Bool -> String -> MooDesc (Bool, (String, ())); C :: MooDesc ()
17:47:42 <Saizan> but it'd be specific to Moo then
17:47:49 <pumpkin> then remember :: Moo -> (forall a. MooDesc a -> r) -> r, and forget :: MooDesc a -> Moo
17:48:01 <pumpkin> oh, this kind of stuff would be derived magically and automatically
17:48:17 <pumpkin> and finally, an extract :: MooDesc a -> a
17:49:25 <pumpkin> so it would be something like class MagicGenericType a where data Desc a :: * -> * (and that would be a GADT)
17:49:34 <pumpkin> and then deriving (MagicGenericType)
17:49:41 * pumpkin stops blabbering
17:50:29 <Saizan> + some operations to traverse Desc, i'd hope?
17:50:41 <pumpkin> yeah
17:51:17 <pumpkin> I mostly want to get at constructors by type
17:51:47 <pumpkin> not quite sure how I'd do it using the above
17:51:53 <pumpkin> but at least it's keeping that information around
17:52:42 <enthropy> pumpkin: you have a Data instance?
17:52:45 <pumpkin> yeah
17:52:53 <pumpkin> well, I can derive one in most cases
17:52:58 <enthropy> you don't think gmapQ isn't enough?
17:53:08 <Saizan> iirc, reading that uniplate is more efficient because it constructs a table of how the type it is traversing is composed, so it only has to go down some branches and not others
17:53:40 <pumpkin> enthropy: how would I use it to say I want all constructors who have Int and Bool parameters in that order, and I want to extract those values from those constructors only?
17:53:41 <Saizan> so i guess it's doing something like that, even if it still has to go through Data.Typeable.cast
17:54:57 <pumpkin> so I have a type data Moo = A Int | B Bool String | C and want some function (automagically from Data.Data) that is Moo -> (Bool, String)
17:55:05 <pumpkin> or Moo -> Maybe (Bool, String)
17:55:51 <enthropy> I think you'll need TH then
17:56:14 <pumpkin> TH can look at the data definition?
17:56:25 <pumpkin> or I'd have to declare the data inside a TH block too?
17:56:42 <Saizan> yes, no: there's reify
17:56:43 <enthropy> but if you're willing to  gmapQ a function that gets you the Bool and String then check if the list produced has them in the right order
17:57:06 <enthropy> thankfully it can do that, but you may quickly run into TH limitations
17:57:19 <pumpkin> TH just seems like overkill for this
17:58:18 <enthropy> they designed it to handle cases like this
17:59:03 <enthropy> in many ways it's simpler than Data.Generics
17:59:23 <pumpkin> what would it look like in TH then?
18:00:13 <enthropy> you ask for the data type name:
18:00:42 <enthropy> and maybe a list of types in the order you want
18:01:21 <enthropy> so:     $(extract ''Moo [''Bool, ''String]) myMoo  :: Maybe (Bool, String)
18:01:34 <enthropy> pumpkin: or you're wondering about the implementation?
18:01:40 <Runar> what is the target category of an Applicative functor?
18:01:45 <osaunders> I don't understand this. «$ hint .» produces warnings but «$ hint . --hint=hint», where hint is a blank file, doesn't.
18:02:23 <pumpkin> Runar: same one as source, in haskell
18:02:32 <osaunders> And I know it is finding the file because if I rename hint to something else it complains it can't find the file.
18:02:49 <Runar> pumpkin: a monad takes you to a kleisli category. Is there an analogy for Applicative?
18:03:02 <osaunders> Oh, I mean the command to be hlint in those examples, oops.
18:03:43 <pumpkin> Runar: I don't think there's anything analogous, but not sure
18:04:32 <pumpkin> enthropy: hmm
18:05:00 <Runar> pumpkin: It has something to do with monoids, but I wonder what :)
18:05:02 <enthropy> type information can't flow into the TH splice unfortunately
18:05:30 <pumpkin> http://en.wikipedia.org/wiki/Monoidal_functor
18:05:42 <enthropy> it might be nice to ask: what's the expected type of where this is being spliced
18:05:50 * enthropy has no idea how that could be implemented
18:06:08 <pumpkin> hmm, there must be a more elegant solution to this
18:06:59 <republican_devil> dealing with unix files seems ugly in bash, does haskell deal with them well?
18:07:12 <republican_devil> also how easily it is to mirror files from 1 unix box to another over ssh?
18:07:55 <enthropy> pumpkin: it might be worth using a class for the set of tuple sizes you're looking for, operating on a Data.Data.Data a => ... :)
18:10:15 <joe1> how can I write an if statement in ghci? I am trying to do: if (doesFileExist "test.x") then removeFile "test.x" ;
18:11:20 <Saizan> joe1: add an else
18:11:25 <pumpkin> or use when
18:12:42 <pumpkin> Runar: I accepted the offer btw :)
18:12:48 <hpc> republican_devil: you would use sftp
18:13:03 <joe1> Saizan: thanks
18:13:05 <hpc> and everything is ugly in bash
18:13:24 <hpc> haskell files are handled as...Handles
18:13:29 <bremner> republican_devil: see also rsync
18:14:14 <hpc> which makes file operations polymorphic over files, urls, and stdin/out
18:15:32 * hackagebot yaml-light 0.1.1 - A light-weight wrapper with utility functions around HsSyck  http://hackage.haskell.org/package/yaml-light-0.1.1 (MichaelIlseman)
18:17:40 <republican_devil> yeah
18:17:44 <republican_devil> I liek rsync and bash
18:17:53 <republican_devil> I can probably do msot of it with such
18:17:53 <republican_devil> lol
18:18:21 <republican_devil> python has tons of annoying lil quirky things to remember to do anything on filesystem ro with ssh
18:18:24 <republican_devil> bleh
18:21:09 <hpc> python has tons of annoying quirks, period
18:21:20 <hpc> "elif" instead of "else if" or even "elsif"
18:21:30 <dino-> So, tell me, with Text.Regex.Posix, is this supposed to do something?: "aab" =~ "a" :: [String]
18:21:41 <dino-> Which fails.
18:21:57 <republican_devil> I suppose I could NFS mount and copy things
18:22:04 <republican_devil> but not sure how legit it is to to that to prod
18:22:07 <republican_devil> maybe sshfs
18:22:08 <hpc> Text.Regex.Posix.Wrap	(=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
18:22:20 <hpc> that doesn't help...
18:23:02 <dino-> hpc: heh
18:23:47 <dino-> There's the passage here: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
18:24:04 <dino-> That says "If we use [String], we get a list of every string that matches."
18:24:22 <hpc> regexes need a monad, i think
18:24:23 <dino-> And then does it with :: String again like the prior example. But shows a result I can't get at all.
18:24:32 <hpc> so you can deal with $1 - $9
18:24:41 <hpc> and s///
18:24:50 <dmwit> Hahaha, "It works under Linux by accident." http://hackage.haskell.org/trac/ghc/ticket/4251
18:25:50 <dino-> What I usually end up doing is using matchRegex and mkRegex directly.
18:26:02 <dino-> But I haven't been able to find API docs for those for a long time.
18:26:13 <hpc> dmwit: wow
18:27:09 <dino-> Which gives me the distinct feeling of You're Doing It Wrong
18:27:29 <enthropy> http://hpaste.org/40752/dearestpumpkin
18:27:35 <Runar> f (a -> b) -> (f a -> f b)  is naturally isomorphic to (f a, f b) -> f (a, b). I want to say this is connected by an adjunction, but I don't know how.
18:28:02 <enthropy> now all you need is some TH to write the 16 or so instances involved
18:28:21 <joe1> I am doing this and am wondering if there is a better way of doing it: flag <- doesFileExist "test.x"; when flag (removeFile "test.x")
18:28:33 <Runar> pumpkin: I heard!
18:28:41 <joe1> i am using "flag <- doesFi..." to go from IO Bool to Bool
18:28:44 <pumpkin> oh wow, news travels fast :)
18:28:54 <Runar> We are happy to have you on board. When do you start?
18:29:05 <pumpkin> Runar: 15th probably
18:29:10 <Runar> Perfect.
18:29:36 <Runar> Doing some crazy MLPolyR-style stuff with edwardk today
18:29:41 <pumpkin> ooh
18:29:49 <dmwit> joe1: That's a faulty intuition; it'll bite you eventually. You're really using "flag <- ...; foo" to bring foo up to "IO Bool -> IO a" from "Bool -> IO a".
18:30:01 <dmwit> joe1: Anyway, that's a fine way to do it.
18:30:03 <Runar> the unification rules are pretty difficult
18:30:51 <joe1> dmwit: yes, the function when takes a bool and not an IO Bool, hence getting the flag before
18:31:01 <dmwit> joe1: Alternately, you call removeFile and catch the DNE exception.
18:31:15 <joe1> oh, yes. I could do that. Thanks.
18:31:26 <dmwit> But this way is fine, too.
18:31:40 <joe1> benmachine had shown me how to do that yesterday.
18:31:47 <Runar> so how would one describe the relationship between idiomatic function application and multiplication in a strong lax monoidal functor? Rather, where's a good place to find this sort of thing out?
18:34:18 <dino-> Interesting, this fails: "aab" =~ "(a)(a)" :: [String]
18:34:33 <dino-> But this: "aab" =~ "(a)(a)" :: (String, String, String, [String])
18:34:43 <dino-> ("","aa","b",["a","a"])
18:35:17 <Runar> I've a feeling that "ask edwardk on tuesday" is my best bet :)
18:35:31 <dino-> I suppose can just eat the first 3 parts of the tuple with _
18:36:40 <hpc> perhaps munch (_,_,_,x) = x
18:36:52 <hpc> for the entertainment that ensues from trying to actually use it
18:38:34 <republican_devil> is software transactional memory the same as communicating sequential porcesses?
18:38:56 <pumpkin> no
18:39:31 <monochrom> @bots
18:42:07 <joe1> dmwit: what do you think of this "System.IO.Error.try . removeFile $ filename"
18:42:43 <joe1> it seems to work from ghci, but wanted to check if that is ok usage?
18:44:15 <dmwit> joe1: Seems fine to me.
18:50:27 <dino-> Oh cool, you can get to these docs now: http://hackage.haskell.org/packages/archive/regex-compat/0.93.1/doc/html/Text-Regex.html
18:50:43 <dino-> (or build them yourself)
18:51:43 <enthropy> pumpkin: http://hpaste.org/40753/th?pid=40753&lang_40753=Haskell
18:52:11 <enthropy> though I suspect the generated code could be lazier
18:52:30 <enthropy> and/or check some other methods in Data whether the constructor even has the right arity
18:53:02 <pumpkin> enthropy: oh, nice
18:53:38 <pumpkin> I wonder if I can adapt that to use nested pairs for arbitrary exractions
18:54:19 <enthropy> you like to write (a,(b,(c,())))))))?
18:54:26 <pumpkin> yeah
18:54:39 <pumpkin> since my other code can process that a lot more easily than n-tuples
18:54:46 <dmwit> lisp-style: (a,(b,(c,(]
18:54:48 <dolio> Runar: Part of the difficulty is knowing which part of each of those is the real arrow.
18:56:17 <dolio> For (f a, f b) -> f (a, b), that's from a natural transformation from the bifunctor 'f - * f =' to the bifunctor 'f (- * =)'.
18:56:37 <dolio> f (a -> b) -> f a -> f b is less clear.
18:56:53 <dolio> The a -> b has to be an exponential object.
18:57:05 <enthropy> hmm, there's only one call to gmapQ, so I'm not sure how the standard (foldr) recursively calling instances to do the rest of the tuple list will work
18:57:22 <enthropy> I guess that means you need two classes
18:57:43 <pumpkin> I think I have it
18:58:01 <dolio> So it's f (b^a) -> f a -> f b, but now you need to know if that should be f (b^a) * f a -> f b or f (b^a) -> (f b ^ f a).
18:58:14 <enthropy> lemme see
18:58:17 <pumpkin> actually maybe not
18:58:20 <pumpkin> just a sec
18:58:39 <enthropy> heh, if you don't get it, I'll try my plans
18:58:53 <dolio> My guess would be the second, I guess, since then you're comparing two natural transformations between bifunctors.
18:59:34 <dolio> (f - * f =) -> f (- * =)  and f (= ^ -) -> (f =) ^ (f -)
19:05:04 <dolio> However, given f a * f b -> f (a * b), you can go f (b^a) * f a -> f (b^a * a) -> f b, where the second step is the evaluation for the exponential.
19:06:28 <dolio> Which is the obvious thing you'd do in Haskell to get the idiomatic version given the tuple version.
19:06:41 <pumpkin> enthropy: yeah, not working nicely
19:25:38 <FeiRuoWa> time to go home
19:30:46 <pumpkin> I really wish there were a nice way to automatically take apart constructors without resorting to TH
19:32:42 <guest2424> Hello That anyone knows how I can use the function foldr to implement a function bubble that performs one bubble sort pass from rear to front through a list. 
19:34:32 <guest2424> ?
19:34:52 <djahandarie> Haha
19:34:59 <djahandarie> There sure are a lot of people taking that test today
19:36:53 <pumpkin> man, writing a bidirectional serialization library is hard
19:37:09 <enthropy> pumpkin: foiled by the rank2 Data constraint
19:37:14 <pumpkin> :P
19:37:45 <Saizan> maybe you'd do better with syb-with-class ?
19:38:03 <enthropy> otherwise I've translated that TH into two classes
19:38:28 <FunctorSalad_> pumpkin: you mean combinators for generating put/get pairs simultaneously so they're guaranteed to be inverses to each other?
19:38:35 <pumpkin> FunctorSalad_: yeah
19:38:39 <enthropy> Saizan: well you need TH to write those instances...
19:38:43 <FunctorSalad_> pumpkin: funny, just did that in C# :)
19:38:50 <pumpkin> there's a functional pearl for it and newsham has a library for it
19:38:56 <pumpkin> but I'm trying some different stuff
19:39:12 <pumpkin> my main trouble is to make the API as pleasant to use as possible
19:39:39 <FunctorSalad_> pumpkin: I simply use a "product" combinator that takes codecs for A and B, the projection functions T->A and T->B, and the ctor A -> B -> T
19:39:46 <FunctorSalad_> producing a codec for T
19:40:17 <FunctorSalad_> it's a bit boilerplatey, but not that bad
19:40:22 <guest2424> any clue
19:40:28 <pumpkin> yeah, I have something similar right now, but wanted to avoid writing the projections
19:40:49 <FunctorSalad_> (and a transformer for making a collection codec from an element codec... that together with the product one covers most things. also have a 'sum' one)
19:42:10 <pumpkin> yeah, same
19:42:16 <pumpkin> but typesafe + unboilerplatey = hard
19:42:18 <pumpkin> gotta run :)
19:42:35 <ManateeLazyCat> Hi all. :)
19:44:33 <guest2424> its possible to perform bubble sort in Haskell
19:48:39 <IIcke> guest2424, http://codecodex.com/wiki/Bubble_sort#Haskell
19:49:53 <guest2424> thank you can foldr do 
19:50:02 <guest2424> something like that?
19:52:22 <IIcke> guest2424, this looks like http://www.mail-archive.com/haskell@haskell.org/msg01951.html
19:53:56 <guest2424>  IIcke : Thank you
19:54:12 <IIcke> you're welcome
19:56:44 <enthropy> preflex: help
19:56:44 <preflex>  try 'help help' or see 'list' for available commands
19:56:48 <enthropy> preflex: list
19:56:48 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen]; ZCode: [zdec, zenc]
19:57:15 <enthropy> preflex tell pumpkin figured it out http://hpaste.org/paste/40753/projections#p40754
19:57:15 <preflex>  Consider it noted.
19:57:20 <enthropy> preflex tell copumpkin figured it out http://hpaste.org/paste/40753/projections#p40754
19:57:20 <preflex>  Consider it noted.
19:59:58 <Girl-br> could someone help me solve some issues in Haskell?
20:00:35 <PatrickRobotham> Yes.
20:03:01 <guest2424> Can someone traduce me an error message 
20:04:04 <kmc> preflex, botsnack
20:04:04 <preflex>  ☺
20:06:26 <roconnor> Girl-br: Yes.
20:10:03 <dmwit> guest2424: It's certainly impossible to translate the error message if you don't tell us what it is.
20:10:38 <guest2424> oh sorry here go http://pastebin.com/vB9biaQ1
20:12:22 <guest2424> dmwit: Here you go  http://pastebin.com/vB9biaQ1
20:16:16 <guest2424> dmwit : You got it
20:18:48 <Saizan> guest2424: it means that "bubble [3,1,6,4,2]" has type [[t]] -> [[t]], which is the type of functions from "lists of lists of t" to "lists of lists of t", and ghci doesn't know how to display a value of that type
20:19:04 <Saizan> in general ghci won't know how to display functions
20:21:28 <Saizan> guest2424: a reasonable bubble sort function should have type "(Ord a) => [a] -> [a]" but yours takes an additional argument of type 'a', so there's something wrong
20:22:32 <guest2424> oh ok
20:22:35 <guest2424> thank you
20:31:55 <Martty> how does one work around this in hs http://codepad.org/nv75HvCU ? i'm having a hard time shifting 
20:33:26 <kmc> work around what?
20:33:31 <kmc> duplication of names?
20:33:36 <kmc> either put a prefix on each one
20:33:42 <kmc> iName, iInterested, uName, etc.
20:33:49 <kmc> or put each in its own module, and import them qualified
20:34:48 <kmc> if you really really need to use the same names, you can put the accessor in a type class
20:35:04 <kmc> but we prefer to use overloading only for semantically related things
20:35:08 <kmc> and not for merely reusing names
20:35:22 <BrianHV> I was going to guess the problem was data structures that refer to each other...
20:35:32 <Martty> yea that was it
20:35:37 <Martty> but apparently if i put them in the same file
20:35:38 <Martty> it works
20:35:44 <Martty> wth!
20:36:19 <Martty> meh i'll just stick to one file
20:36:23 <Martty> stupid boots
20:38:03 <ymasory> is there any difference between saying a language has "first class functions" and saying it has "functors"?
20:38:59 <kmc> yes
20:39:25 <kmc> the word 'functor' is used in at least three totally different ways in programming
20:39:35 <dolio> In my experience, the word "functor" being used in that sense is what you get in a language that doesn't have real first-class functions, but people use some other facility (objects) to make something that is useful for the same things.
20:39:54 <kmc> one of those is also called "function objects".  it's a standardized boilerplate workaround (aka "design pattern") for the lack of first-class functions in C++ and Java
20:40:11 <Zao> Free functions are quite first-class.
20:40:11 <kmc> there's also ML functors, and Haskell's type class named "Functor", neither of which has anything to do with that
20:40:15 <Zao> Member functions, aren't :D
20:40:40 <kmc> and then there's the meaning from category theory, which has a bit to do with the Haskell type class
20:42:47 <dolio> Quite a bit, provided you overlook the fact that we didn't use the less appealing name HaskEndofunctor.
20:43:58 <ymasory> ah i see. the wikipedia article on functors is kinda unclear on this point, citing first class functions and java-style functors in the same breath
20:44:17 <kmc> yeah
20:44:24 <kmc> well in a decent OOP language, functions are objects
20:44:38 <Gracenotes> what's an object again? :P
20:44:45 <kmc> but that's not to say you have to write out a class and everything
20:44:54 <kmc> it's to say that you write a simple lambda expression, and you get an object which is callable
20:46:24 <dino-> This is how they're doing things in Scala, I believe. It's all objects under the covers to the VM.
20:47:06 <Gracenotes> LambdaVM (JVM backend to GHC) also tried to make everything objects, I believe
20:47:23 <Gracenotes> but due to differences in garbage collection algorithms, it's kind of meh
20:47:51 <dino-> That's too bad. Writing in Scala, while vastly better than Java, leave me kind of meh too.
20:47:57 <dino-> leaves
20:48:00 <Gracenotes> more straight-up java bytecode manipulating primitive types might work better
20:48:16 <Gracenotes> in terms of performance, that is, mostly
20:48:26 <kmc> but java's primitive types aren't first-class
20:48:36 <dolio> The intro to Scala book is pretty good.
20:48:52 <ymasory> dolio: which one
20:48:58 <Gracenotes> well, just use objects whenever you need a struct sort of thing
20:49:02 <dolio> It gives a lot of tips for imperative-type programmers on how to program functionally.
20:49:10 <dolio> The one by Odersky, I think.
20:49:16 <ymasory> i like scala because it captures a large fraction of the functional beauty, while pulling in an extremely practical side (java)
20:49:25 <Gracenotes> and beware of peppering dynamic dispatch all over the place
20:49:36 <ymasory> dolio, yes, the odersky book is *awesome*. single-handedly sparked my interest in PL
20:49:42 <dino-> dolio: I thought that too, that he was presenting that well, to think functionally.
20:50:01 <ymasory> it's aimed at developers, but it has a level of technical precision that makes it feel like a classic textbook at times.
20:50:24 <ymasory> it's the K&R of scala
20:52:37 <Gracenotes> should see if my uni library has it
20:54:23 <ymasory> what i find annoying about scala is the haunting suspicion that it has every feature of every language
20:54:34 <ymasory> i want to get a shirt that says "scala: there's a type for that"
20:54:36 <cch> question about "Yesod in 5 minutes". I just setup a scaffold yesod and find that static files can not be reached
20:55:11 <cch> I didn't make any change to scaffold codes
20:56:00 <Maxdamantus> Should functions in OO languages be bound to the objects they were instantiated from?
20:56:30 <cch> I see static tmp files have been created thought just can not get them from browser
20:56:51 * Maxdamantus is wondering if he should add some OO syntax (like C structs) to his fairly-simple PF language.
20:57:04 <Maxdamantus> What are the reasons against it in Haskell?
20:57:21 <Maxdamantus> simply because what looks like a symbol should be a symbol?
20:59:31 <Gracenotes> er. if you like implicit this then include it.
21:00:36 <Gracenotes> maybe you're seeing a dichotomy I'm not...
21:14:29 <Eduard_Munteanu> \o
21:16:17 <Eduard_Munteanu> How would I do computations in a Gtk2Hs app without freezing the UI? Is there a GTK timer for that?
21:20:57 <Eduard_Munteanu> Hm... System.Glib.MainLoop.addTimeout seems to be what I'm looking for.
21:22:19 <Martty> http://codepad.org/w5JjEQNQ why doesn't undoFriends work? it seems to fail to delete 
21:24:12 <guest2424> Hello
21:25:47 <kmc> hi
21:25:50 <kmc> can haskell do bubble sort
21:26:08 <Martty> yes
21:26:13 <Martty> can kmc answer my question?
21:26:16 <dmwit> lol kmc
21:26:17 <pikhq> @faq
21:26:57 <dmwit> Martty: undoFriends doesn't work because x isn't y's friend, and vice versa.
21:27:14 <dmwit> Martty: You might like to redefine equality for User to ignore the "friends" field. ;-)
21:27:36 <Martty> ah 
21:27:41 <Martty> exactly
21:28:21 <dmwit> or, perhaps, deleteBy uName
21:28:44 <Martty> nah
21:28:50 <Martty> anyways i guess i need to read further
21:28:54 <Martty> on ADTs and stuffso
21:28:57 <Martty> thanks and gn
21:30:17 <guest2424> pumpkin : 
21:34:33 <dmwit> Hm. These install instructions are getting fairly unwieldy!
21:34:41 <dmwit> http://dmwit.com/wyvern/#install_source
21:36:01 <pumpkin> guest2424?
21:36:02 <preflex>  pumpkin: you have 1 new message. '/msg preflex messages' to read it.
21:36:59 <pumpkin> enthropy: thanks!
21:38:04 <Saizan> dmwit: can't 7. and 8. be merged into cabal install wyvern?
21:38:11 <dmwit> No, sadly.
21:38:27 <dmwit> I've got a diamond dependency; I need both parsec-2 and parsec-3 installed for different dependencies.
21:38:34 <dmwit> So cabal refuses to do the whole thing automatically.
21:42:27 <Saizan> ah, ok
21:42:50 <Saizan> but 7 can be just "cabal unpack wyvern"
21:43:10 <dmwit> Oh, cool, didn't know about that one.
21:43:11 <dmwit> Great!
21:47:28 <dmwit> fixed
22:07:12 <periodic> So, there's still not good way to pass in a record-syntax accessor to something to modify it, right?
22:07:21 <kmc> not built in
22:07:27 <kmc> see libraries like fclabels
22:07:38 <periodic> k, I'll take a look.
22:08:10 <periodic> One of my datas has gotten pretty long and it hurts the genericness of the code that I type to write a { foo = bar } every time explicitly.
22:08:34 <periodic> thanks for the tip, kmc
22:21:52 * hackagebot text 0.10.0.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.10.0.0 (BryanOSullivan)
22:34:42 <guest2424> hello everyone any clue on what is wrong with this code http://pastebin.com/imL5rg2d
22:35:39 <sbrg> guest2424: bubble is a function of type [[t]] -> [[t]]
22:35:46 <sbrg> you're tring to 'show it'
22:35:55 <sbrg> you can't 'show' a function
22:36:00 <sbrg> You're missing a parameter, fyi
22:36:04 <sbrg> (which is why it's a function)
22:36:09 <sbrg> unless that's what you intended
22:36:21 <guest2424> I am trying to show it
22:36:29 <guest2424> ?
22:37:33 <sbrg> guest2424: bubble 'returns' a function
22:37:39 <guest2424> ok
22:38:01 <guest2424> oh my bubble is returning a function
22:38:09 <sbrg> Yes.
22:38:29 <guest2424> the [x]
22:38:35 <guest2424> means a function?
22:38:37 <sbrg> bubble :: (Ord a) => a -> [a] -> [a]
22:38:42 <sbrg> That's bubble's type
22:38:54 <guest2424> yeah you are correct
22:38:57 <sbrg> you pass it something, it returns a function ([a] -> [a])
22:39:18 <sbrg> What that basically means is that you need to pass another parameter
22:39:22 <sbrg> Because of currying etc
22:39:48 <guest2424> at the end?
22:40:10 <guest2424> ?
22:40:45 <guest2424> sbrg: at the end
22:40:56 <sbrg> Yes.
22:41:09 <sbrg> bubble something seomething
22:41:29 <guest2424> bubble x
22:41:32 <guest2424> correct
22:41:33 <guest2424> ?
22:41:44 <guest2424> instead of [x]
22:43:29 <bos> new text library doesn't quite go up to 11, but it's close: http://www.reddit.com/r/haskell/comments/durb2/text_01000_faster_than_ever_and_now_with_handy/
22:45:01 * hackagebot gps 0.5.3 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.5.3 (ThomasDuBuisson)
22:57:25 <djahandarie> bos, great, thanks. :) It's nice when core packages like this are solid
22:58:09 <mayahustle> Hi I'm trying to use the Parsec Library with Bytestring... can you do this, and still have combinators like alphaNum return a Bytestring instead of [Char]?
23:01:02 <djahandarie> mayahustle, what version of Parsec?
23:01:43 <mayahustle> umm... I'm not sure how you check that.. But I'm doing an import qualified Text.Parsec.ByteString.Lazy (Parser)
23:01:54 <djahandarie> So you have 3
23:01:59 <mayahustle> yes I believe so
23:02:06 <djahandarie> There aren't many explicit uses of String in there
23:02:32 <djahandarie> And the ByteString that Parsec uses is ByteString.Char8
23:02:47 <djahandarie> (Which allows for Char operations)
23:03:25 <mayahustle> so is there a Parser for ByteString.Lazy.Char8 
23:03:36 <djahandarie> Yes, and you get it by importing what you just imported
23:03:45 <mayahustle> okay let me try that
23:03:47 <Saizan> btw, there are only 2 ByteString types, not 4
23:04:04 <mayahustle> ??
23:04:07 <mayahustle> now I'm confused
23:04:11 <Saizan> .Char8 only adds functions
23:04:16 <mayahustle> oh
23:04:18 <mayahustle> ok
23:04:39 <mayahustle> so how can I parse a file that I'm reading as a bytestring, and still have nice easy to use combinators?
23:05:56 <Saizan> you can use a bytestring as input, but the results of the combinators won't change type
23:06:10 <djahandarie> Right
23:06:24 <djahandarie> Just use the ByteString Parser and it'll handle everything for you
23:06:29 <djahandarie> Your interface shouldn't really change
23:07:06 * djahandarie -> bed
23:07:09 * hackagebot convertible-text 0.3.0.6 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.3.0.6 (MichaelSnoyman)
23:07:11 * hackagebot data-object 0.3.1.5 - Represent hierachichal structures, called objects in JSON.  http://hackage.haskell.org/package/data-object-0.3.1.5 (MichaelSnoyman)
23:07:44 <mayahustle> I keep getting type errors though.. for example: I have a function:
23:07:57 <mayahustle> tester :: Parser B.Bytestring
23:08:08 <mayahustle> tester = x <- many alphaNum; return x
23:08:13 * hackagebot data-object-json 0.3.1.4 - Serialize JSON data to/from Haskell using the data-object library.  http://hackage.haskell.org/package/data-object-json-0.3.1.4 (MichaelSnoyman)
23:08:15 * hackagebot data-object-yaml 0.3.3.1 - Serialize data to and from Yaml files  http://hackage.haskell.org/package/data-object-yaml-0.3.3.1 (MichaelSnoyman)
23:08:17 <mayahustle> and I get an a type error because its inferring [Char[
23:08:17 * hackagebot hamlet 0.5.1.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.5.1.2 (MichaelSnoyman)
23:08:19 * hackagebot mime-mail 0.0.0.1 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.0.0.1 (MichaelSnoyman)
23:08:21 * hackagebot web-encodings 0.3.0.3 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.3.0.3 (MichaelSnoyman)
23:10:19 <zubayr> hello thr haskell guys
23:10:27 <zubayr> hw u doin this mrng
23:10:49 <zubayr> i have the task of making a banking app in haskell
23:11:00 <zubayr> can anyone help??
23:11:41 <Twey> mayahustle: You need to pack it, then
23:12:08 <Twey> tester = fmap B.pack $ many alphaNum
23:14:38 <mayahustle> won't that slow down the parse?
23:14:47 <mayahustle> speed is an imperative here
23:14:55 <mayahustle> the files I'm parsing can be rather large
23:15:04 <bos> mtnviewmark: hey, you're the tops on the haskell reddit!
23:15:13 <mtnviewmark> oh? really?
23:15:26 <bos> yeah dude
23:15:45 <Twey> mayahustle: Well, you need to deal with each character individually here anyway
23:15:58 <Twey> That's basically what you're doing with your ‘many alphaNum’
23:16:48 <mtnviewmark> ooooo and a comment
23:17:15 <mtnviewmark> hmmm... how does one get to the top of reddit? it only had 5 up votes
23:17:23 <Twey> Putting it into a bytestring when you're done ensures that that overhead will only occur once
23:17:48 <mayahustle> ... okay... so for any of the char combinators.. I'm going to have to pack everything
23:17:56 <mayahustle> I was hoping there'd be another way
23:18:09 <mayahustle> but that'll work for now... hopefully it will still run killer fast lol
23:18:18 <mayahustle> I'm dealing with faculty here, that don't take to kindly to Haskell
23:19:44 <Twey> If you're looking for speed, you should probably be using attoparsec or something
23:20:07 <mayahustle> I was under the impression, that attoparsec and parsec with Bytestring were the same thing
23:20:15 <mayahustle> or at least similar enough
23:21:01 <Twey> No, not really
23:21:19 <Twey> attoparsec is optimised for use of bytestrings and for speed in general
23:21:38 <Twey> Parsec with bytestrings is just Parsec with bytestrings: it doesn't perform any additional optimisations
23:21:59 <mayahustle> oh okay
23:22:06 <mayahustle> attoparsec it is..
23:22:21 <mayahustle> Thanks for the information
23:23:03 <Twey> You should also read the ‘Performance Considerations’ section in the Haddock.
23:24:07 <zubayr> anyone thr to advice me please???
23:24:30 <mayahustle> oh I see what you mean
23:24:33 <mayahustle> this is excellent though
23:24:33 <kmc> zubayr, do you have a more specific question?
23:24:40 <mayahustle> as fast as C is exactly what I need
23:24:41 <zubayr> yes kmc
23:25:06 <mayahustle> Twey: if I could send a beer over IRC I would
23:25:08 <mayahustle> Thanks
23:25:09 <zubayr> i hv gt an assignment to develop a banking app using haskell
23:25:13 <zubayr> can u help?
23:25:16 <kmc> zubayr, do you have a more specific question?
23:25:28 <zubayr> yes kmc
23:25:48 <zubayr> i want to develop a banking app using haskell..can you advice?
23:26:04 <PatrickRobotham> What does it do?
23:26:08 <kmc> that's exactly as specific as the last question
23:26:40 <mayahustle> what functionality are you looking for in the app?
23:26:43 <zubayr> i want the functionalities like account deposit, withdrawal, view balance, transfer money
23:26:52 <zubayr> etc etc
23:26:55 <mtnviewmark> wow - like with a network of remote ATMs, quartery audit reports, investment strategies, and all?!?!?
23:27:15 <zubayr> no not so much
23:27:30 <zubayr> just a simple banking app with basic functionalities
23:27:32 <PatrickRobotham> What functions does it have?
23:27:42 <zubayr> lyk account deposit, withdrawal
23:27:53 <zubayr> account transfer etc
23:28:38 <mtnviewmark> zubayr: First step: Define the type for a bank account
23:28:39 <PatrickRobotham> I can't implement "etc."
23:29:04 <mayahustle> Is this a self sufficient test app?... or are you doing real transfers over a network?
23:29:12 * mtnviewmark is sure there is some clever definition of etc. involving fix....
23:29:18 <zubayr> no a self sufficient test app
23:29:45 <mayahustle> Data account = account Integer?
23:29:47 <mtnviewmark> is this homework?
23:29:56 <zubayr> yea kinda
23:30:04 <mayahustle> kinda homework?
23:30:07 <mayahustle> how's that work?
23:30:08 <mtnviewmark> N.P., it is just good for us to know
23:30:26 <zubayr> N.P. here too   ;)
23:30:35 <Eelis> mtnviewmark: i always read the .. in [1,3..] as "etc." :)
23:30:45 <mtnviewmark> so, assume you've defined the type Account
23:31:00 <mtnviewmark> then one might think of the type for the withdraw function....
23:31:18 <zubayr> k
23:31:21 <mtnviewmark> perhaps..... widthdraw :: Currency -> Account -> Account
23:31:34 <zubayr> k
23:31:58 <mtnviewmark> as in: withdrawing some money takes an account state and returns a new account state
23:32:36 <mtnviewmark> now - what do you think the type of a Bank might be?
23:34:38 <kfish> Larceny
23:34:57 <zubayr> where different customers will have their accounts specified by their individual account numbers
23:35:11 <zubayr> n the customer details will be stored in a text file
23:35:42 <zubayr> details like their name, account no, balance
23:36:38 <mtnviewmark> well - I think you should ignore the text file for now - that'll come later
23:36:52 <mtnviewmark> so - look you have two ways to go here:
23:37:16 <zubayr> k
23:37:16 <mtnviewmark> a) either an account data value contains the id numbers, and a bank is just a collection of 'em
23:37:19 <mtnviewmark> or 
23:37:53 <mtnviewmark> b) the account just has a balance and details, and a bank  is a mapping from ids to accounts
23:38:09 <mtnviewmark> You should be able to write the type for a Bank in each case.
23:38:10 <mtnviewmark> can you?
23:38:12 <mtnviewmark> try!
23:38:52 <mtnviewmark> in Haskell - it is all about the types
23:39:08 <mtnviewmark> if you can think about the types of your data, and the types of your functions --- the rest is easy
23:39:42 * mtnviewmark is meanwhile, ironically, battling code in javascript and jQuery....
23:52:45 <Twey> withdraw :: Currency -> Account -> Either ErrorValue (Currency, Account)
23:55:23 <zubayr> is there a drag and drop IDE available for haskell??
23:56:36 <dolio> No, but there's one that plays jazz-techno fusion while you press buttons really fast to assemble 3D cube renderings into patterns.
23:57:04 <companion_cube> in which cabal package is it ?
23:57:15 <dolio> swordfish
23:58:55 <mtnviewmark> zubayr - there is Leksah -- and IDE for Haskell - but if you are looking for some sort of drag-and-drop-build-my-interfaces-and-classes thing.... no
23:59:26 <mjrosenb> drag...... and..... drop?
23:59:35 <zubayr> yes
