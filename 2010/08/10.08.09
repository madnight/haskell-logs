00:00:04 <kmc> reverse-engineering a DOS program that controls some hardware
00:00:13 <endolphin> from assembly??
00:00:17 <kmc> potentially
00:00:24 <endolphin> what processor is this
00:00:29 <kmc> 386
00:00:35 <c_wraith> I know someone who could do it, but she's probably not interested.
00:00:38 <endolphin> ^
00:00:39 <kmc> 386 fo lyfe
00:00:42 <kmc> yeah
00:00:49 <endolphin> reverse engineering asm < death
00:00:52 <kmc> i just have a bunch of DOS trivia questions
00:00:53 <c_wraith> as in, she's done similar stuff before, when she was interested.
00:00:57 <kmc> like "what's the default code segment"
00:01:04 <kmc> and "what's this interrupt / IO port do"
00:01:17 <kmc> http://www.cs.cmu.edu/~ralf/files.html looks useful though
00:02:00 <endolphin> what is the program?
00:02:28 <kmc> it controls a JVF 2010-A LED sign
00:02:49 <endolphin> are you running a vm for it already
00:02:53 <kmc> yeah
00:02:53 <endolphin> like, you know what it does?
00:03:03 <kmc> it works in dosbox and on the real hardware
00:03:09 <kmc> but i want to put custom software on the 386
00:03:17 <kmc> so it can do things other than displaying fixed images
00:03:38 <endolphin> do i dare ask what the end goal is here
00:04:54 <BMeph> World DOMINATION!
00:06:55 <kmc> the end goal is to control a JVF 2010-A LED sign
00:06:58 <kmc> not as yet decided what it should do
00:07:08 <endolphin> oh, yeah, you say that
00:07:14 <endolphin> but you're going to go try to use it to impress girls
00:07:17 <kmc> yeah
00:07:18 <kmc> presumably
00:07:29 <endolphin> then i have a moral dilemma on my hands
00:08:02 <aidalgol> Uh, kmc, the problem seems to be with (length grades), not (sum grades).
00:08:09 <kmc> ok
00:08:16 <kmc> i think i said you'd need to convert both of them
00:08:20 <kmc> or, use genericLength instead of length
00:08:31 <aidalgol> > 7/2
00:08:33 <lambdabot>   3.5
00:08:35 <nettok> kmc: Thanks for all!  What it took 1 minute now it takes 3 seconds :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28749#a28749
00:08:43 <aidalgol> So, why does *that* work?
00:08:45 <kmc> aidalgol, that works because numerical literals are overloaded
00:08:47 <kmc> 7 is already a Double
00:08:50 <kmc> :t 7
00:08:51 <lambdabot> forall t. (Num t) => t
00:08:56 <kmc> note that it does not say "Int"
00:08:56 <djahandarie> Anything that takes over >.01 s is over-rated ;)
00:09:09 <aidalgol> Oh...
00:09:19 <kmc> 7 is already Int, and Double, depending on context
00:09:30 <kmc> but it is harder (and slower) to make your program work only with "polymorphic numbers" like that
00:09:34 <kmc> it makes sense for literals
00:09:41 <aidalgol> So, how can I convert (length x) to a float?
00:09:50 <c_wraith> fromIntegral
00:09:53 <c_wraith> same as always
00:09:56 <c_wraith> :)
00:10:04 <kmc> my advice has not changed in a while ;)
00:10:13 <djahandarie> :t genericLength
00:10:14 <aidalgol> Oh, right, I only did that on *one* side. :P
00:10:15 <lambdabot> forall b i. (Num i) => [b] -> i
00:10:27 <djahandarie> :t fromIntegral . length
00:10:27 <aidalgol> Sorry for being dense.
00:10:28 <lambdabot> forall b a. (Num b) => [a] -> b
00:11:44 * aidalgol jumps for joy!
00:11:51 <aidalgol> It compiles!
00:12:06 <aidalgol> Thanks, guys! \o/
00:12:24 <kmc> :D
00:12:30 <kmc> it compiles, so it must work ;)
00:12:36 <aidalgol> I think I can deal with my own logic bugs, so I'm done spamming the channel.
00:12:41 <aidalgol> kmc: Oh, of course.
00:13:01 <aidalgol> *!*BLAM*!*
00:13:18 <aidalgol> kmc: Your argument is in valid.
00:13:21 <aidalgol> ;)
00:15:40 <aidalgol> Hmm, one function fails completely, and one just doesn't handle the base case.
00:18:09 <aidalgol> And it's not my code, it's some weird character in *their* code: ﬂ
00:19:07 * ezyang is currently annoyed at Haddock's deep integration with GHC 
00:54:25 <steshaw> @pl \a b c -> a + b * c
00:54:25 <lambdabot> (. (*)) . (.) . (+)
00:54:49 <Veinor> that seems like it should be neater
00:55:04 <Veinor> @pl \a b c -> f a (g b c)
00:55:04 <lambdabot> (. g) . (.) . f
00:55:26 <steshaw> Yeah, I first thought it was (+) . (*)
00:55:52 <steshaw> @type (+) . (*)
00:55:53 <lambdabot> forall a. (Num a) => a -> (a -> a) -> a -> a
00:56:41 <steshaw> hmmm, ghci says the type is "(+) . (*) :: (Num (a -> a), Num a) => a -> (a -> a) -> a -> a"
00:57:05 <FunctorSalad> ezyang: hmm? you mean it should have its own parser?
00:58:42 <int-e> @type ((+) .) . (*)
00:58:44 <lambdabot> forall a. (Num a) => a -> a -> a -> a
00:59:30 <int-e> but that's \a b c -> c + a * b
01:01:40 <Veinor> > ((+) .) . (*) 1 2 3
01:01:41 <lambdabot>   No instance for (GHC.Show.Show (f (f1 (a -> a))))
01:01:41 <lambdabot>    arising from a use of ...
01:01:49 <Veinor> > (((+) .) . (*)) 1 2 3
01:01:50 <lambdabot>   5
01:14:02 <jkramer> Ahoy
01:14:08 <jkramer> http://paste.pocoo.org/show/247890/
01:14:26 <jkramer> Which one is the right one and how can I fix it?
01:15:37 <ClaudiusMaximus> jkramer: you get to choose, by hiding the ones you don't want (but i'm not sure how to do that without writing a .cabal file)
01:15:44 <Veinor> I think there's an extension
01:15:46 <nlogax> ghc-pkg hide mtl, iirc
01:15:47 <wto> jkramer: you would probably want mtl, and you can hide the other packages with ghc-pkg
01:16:02 <wto> oh well, you were faster than me nlogax!
01:16:19 <ClaudiusMaximus> jkramer: the 'right' one depends on which other libraries you need, and whether they use mtl or something else
01:17:01 <jkramer> Well, I just wanted to play with the State monad a little :)
01:17:15 <jkramer> So mtl is the one to prefer?
01:18:12 <ClaudiusMaximus> mtl is used more widely as it's older; so is likely to be less painful if you need to interoperate with other libraries - but the newer ones must be better in some way or they wouldn't have been written..
01:18:27 <jkramer> Hehe
01:18:58 <jkramer> Ok, I'll stick with mtl for now, I just want to see how it works anyway
01:19:03 <jkramer> Thanks for your help
01:19:11 <ClaudiusMaximus> @unmtl State s a
01:19:11 <lambdabot> s -> (a, s)
01:20:52 <ClaudiusMaximus> @unmtl ReaderT r (WriterT w (Identity a))
01:20:52 <lambdabot> err: `ReaderT r (WriterT w a)' is not applied to enough arguments, giving `/\A. r -> a (A, w)'
01:21:06 <ClaudiusMaximus> @unmtl ReaderT r (WriterT w (Identity)) a
01:21:07 <lambdabot> r -> (a, w)
01:34:15 <steshaw> @pl \c -> isSeparator c || isPunctuation c
01:34:15 <lambdabot> liftM2 (||) isSeparator isPunctuation
01:35:26 <ClaudiusMaximus> > map (liftA2 (||) isUpper isLower) "Ab!"
01:35:28 <lambdabot>   [True,True,False]
01:36:41 <ClaudiusMaximus> > filter (liftA2 (&&) isUpper isLower) [minBound .. maxBound]
01:36:42 <lambdabot>   ""
01:43:28 <steshaw> ClaudiusMaximus: would you say that liftA2 is more idiomatic for combining functions as above?
01:47:16 <ClaudiusMaximus> steshaw: i would say, that applicative functors are less powerful than monads, and it's better to use the least powerful tool for the job; in this case you don't need the sequencing that liftM2 does, so liftA2 is good enough
01:47:57 <kmc> if it was buried in a bunch of monadic code
01:48:01 <kmc> then there's an argument for not "mixing styles"
01:48:15 <kmc> that said i use (<$>) for fmap frequently even inside "do"
01:48:19 <kmc> maybe less so (<*>)
01:48:33 <ClaudiusMaximus> i tend to use `fmap` because it saves imports
01:48:35 <Veinor> I don't really use fmap at all
01:54:24 <etpace> I tend to use applicative when dealing with things like the maybe monad
01:55:35 <ClaudiusMaximus> @src Monoid a => Monoid (Maybe a)
01:55:35 <lambdabot> Source not found. :(
01:59:02 <ClaudiusMaximus> :t [Data.Monoid.First, Data.Monoid.Last]
01:59:03 <lambdabot>     Couldn't match expected type `First a'
01:59:04 <lambdabot>            against inferred type `Last a'
01:59:04 <lambdabot>     In the expression: Last
01:59:06 <ClaudiusMaximus> oops
02:01:00 <ClaudiusMaximus> anyway, i never knew about those - i should use them! instead of listToMaybe $ [...]  , listToMaybe . reverse $ [...]
02:02:12 <ClaudiusMaximus> not sure whether to use ReaderT and WriterT though, as they use non-portable extensions (and i've already written a specialized version..)
02:02:25 <kmc> which extensions?
02:02:30 <kmc> MPTC
02:02:31 <kmc> fundeps?
02:02:34 <ClaudiusMaximus> both
02:03:04 <steshaw> (sorry for the delay but) Thanks guys. I guess I'll stick with liftM2
02:03:12 <steshaw> oops liftA2
02:03:44 <steshaw> In this case I do kinda like: (||) <$> isSpace <*> isPunctuation  $ 'c'
02:05:04 <ClaudiusMaximus> there's an infix-applicative thing somewhere..
02:05:15 <kmc> when i mix $ with <$> it never looks right
02:05:18 <kmc> i always parenthesize it
02:05:55 <kmc> > liftA2 (||) isSpace isPunctuation 'c'
02:05:56 <lambdabot>   False
02:06:20 <kmc> > let (|$|) = liftA2 (||) in (isSpace |$| isPunctuation) 'c'
02:06:21 <lambdabot>   False
02:07:08 <ClaudiusMaximus> > isSpace <^(||)^> isPunctuation $ 'c' -- is the syntax from... http://hackage.haskell.org/packages/archive/InfixApplicative/1.1/doc/html/Control-Applicative-Infix.html (note: haddocks are messed up...)
02:07:09 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
02:07:56 <kmc> haskell operator or japanese emoticon
02:08:06 <ClaudiusMaximus> bat-pig
02:08:15 <kmc> yes
02:08:21 <kmc> that's what i thought too
02:08:49 <ClaudiusMaximus> i do use ^^*^ for matrix-vector multiplication, though...
02:09:18 <steshaw> a lot to learn. The operators do seems to make for an uphill battle
02:09:40 <kmc> steshaw, do you mean Haskell in general or some specific lib?
02:09:53 <steshaw> dunno really
02:10:03 <steshaw> I guess it's the libs
02:10:10 <kmc> haskell libs do define lots of operators
02:10:13 <steshaw> where does |$| come from?
02:10:20 <kmc> er, i defined one above
02:10:25 <kmc> i don't know if it's in some lib
02:10:28 <steshaw> oh :)
02:10:55 <kmc> i think the operator proliferation is an obstacle, but not a huge one
02:11:03 <kmc> since they're defined in the usual way
02:11:24 <kmc> you can find them in haddock or hoogle, with ghci's :i, get their type, etc.
02:11:41 <kmc> they combine in a simple well-defined way
02:11:53 <kmc> unlike the operator syntax of some other languages
02:11:55 <ClaudiusMaximus> using names infix is nicer sometimes
02:12:23 <steshaw> I kinda wish there were aliases for all the operators at this point
02:12:30 <steshaw> but I'm real green
02:12:36 <ClaudiusMaximus> > let dot u v = sum $ zipWith (*) u v in [1,2,3] `dot` [10,20,30]
02:12:37 <lambdabot>   140
02:13:03 <kmc> yeah
02:13:29 <ClaudiusMaximus> @hoogle <.>
02:13:30 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
02:13:30 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
02:13:32 <kmc> but then you'd have to look up "dot" rather than (^.) or whatever
02:13:37 <kmc> and you have the same tools for looking up either
02:13:51 <kmc> the problem is that experienced coders want their code to be short and readable
02:13:54 <ClaudiusMaximus> @hoogle addExtension
02:13:54 <lambdabot> System.FilePath.Posix addExtension :: FilePath -> String -> FilePath
02:13:54 <lambdabot> System.FilePath.Windows addExtension :: FilePath -> String -> FilePath
02:14:07 <kmc> and once you've memorized five dozen infix operators, the operator soup really is readable
02:14:18 <kmc> whereas names written `like_this` take up lots of space unless they're very short
02:14:38 <steshaw> kmc: I understand. I couldn't expect to see the named aliases in library code etc.
02:14:41 <ClaudiusMaximus> both do the same thing, but   "foo" <.> "txt" is a bit more readable than "foo" `addExtension` "txt"   (especially if you stick to <80char lines)
02:15:01 <kmc> for some reason we find using 3 randomly chosen punctuation characters to be more palatable than 3 randomly chosen letters
02:15:05 <steshaw> I already have my own operators ... so I do like the ones I know :)
02:15:09 <kmc> i mean you could call that function "adx" for "add extension"
02:15:14 <kmc> and write `adx`
02:15:51 <ClaudiusMaximus> :t Data.Complex.i
02:15:52 <lambdabot> Not in scope: `Data.Complex.i'
02:17:02 <ClaudiusMaximus> praise be - that would get tedious with -Wall
02:17:47 <kmc> haha
02:18:18 <kmc> use ı instead
02:18:44 <kmc> @let ı = 0 :+ 1
02:18:45 <lambdabot>  Defined.
02:19:04 <kmc> @let π = pi
02:19:06 <lambdabot>  Defined.
02:19:15 <kmc> > exp (ı*π) + 1
02:19:17 <lambdabot>   0.0 :+ 1.2246467991473532e-16
02:19:30 <ClaudiusMaximus> close enough
02:19:39 <kmc> hmm ι is better
02:19:49 <kmc> > exp (ı*π) + 1 :: CReal
02:19:50 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
02:19:51 <lambdabot>         against infe...
02:20:13 <Ke> 10^-16 is about the machine epsilon for double
02:20:20 <kmc> > let ι = 0:+1; π = pi in exp (ı*π) + 1 :: CReal
02:20:21 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
02:20:21 <lambdabot>         against infe...
02:20:24 <kmc> > let ι = 0:+1; π = pi in exp (ι*π) + 1 :: CReal
02:20:26 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
02:20:26 <lambdabot>         against infe...
02:20:34 <kmc> boo hiss
02:20:40 <ClaudiusMaximus> stick a magnitude in there maybe?
02:21:07 <kmc> whoops
02:21:21 <kmc> > let ι = 0:+1; π = pi in Data.Complex.polar (exp (ι*π) + 1 :: CReal)
02:21:22 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
02:21:22 <lambdabot>         against infe...
02:21:23 <Ke> @type (:+)
02:21:24 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
02:21:31 <kmc> > let ι = 0:+1; π = pi in Data.Complex.polar (exp (ι*π) + 1) :: (CReal, CReal)
02:21:32 <lambdabot>   (0.0,0.0)
02:21:35 <kmc> :D
02:23:55 <kmc> > p == np
02:23:56 <lambdabot>   False
02:24:35 <SubStack> hah!
02:24:39 <Ke> >p
02:24:45 <Ke> > p
02:24:46 <lambdabot>   p
02:24:57 <Ke> @type p
02:24:58 <lambdabot> Expr
02:25:04 <Ke> heh
02:25:14 <byorgey> @type np
02:25:15 <lambdabot> Expr
02:25:26 <byorgey> @type xf
02:25:27 <lambdabot> Not in scope: `xf'
02:25:47 <byorgey> some joker defined np just to be able to do that, eh? =)
02:25:52 <kmc> yes
02:25:54 <kmc> some joker
02:26:01 * kmc whistles innocently
02:26:05 <byorgey> ;)
02:26:43 <kmc> > wisdom
02:26:44 <lambdabot>   Time makes fools of us all.  Also, robots.
02:30:16 <pmurias> any one here has any good/bad experience with HOOPL? how fast is it?
02:40:59 <tallpaul> is there any nice way to represent closures in llvm?
02:42:58 <archguest> i am reading "real world haskell" and just came across the discussion of lists and tuples. then i thought - if one can represent a database record in a table as a tuple, a column could be represented as a list, then a table itself is either a list of tuples (by row), a tuple of lists (by column) or a list of lists (by column). how crazy is that? :)
02:44:18 <fasta> archguest, is there any point you are trying to make?
02:44:26 <Ferdirand> you might like zip and unzip then
02:46:10 <archguest> fasta: not really. it's just when i thought about it i also thought that haskell may be a bit too much for me :)
02:46:15 <Associat0r> Berengal: Heffalump: I see I missed some F#/Scala discussion the other day
02:46:35 <fasta> archguest, Haskell is much easier to program than most programming languages. 
02:47:08 <archguest> fasta: i hope to see it after i finish the book
02:47:14 <fasta> archguest, that you can also make it yourself difficult by using advanced features that don't even work in the compiler yet is also a possibility.
02:47:28 <fasta> archguest, real world haskell only teaches you the basics. 
02:47:33 <archguest> fasta: mathematical examples look particularly clean and i am also using xmonad, which is an inspiration
02:47:41 <fasta> archguest, do not expect to be an "expert" after reading one book.
02:47:48 <archguest> fasta: of course
02:48:56 <archguest> fasta: is there any book i could read which looks at haskell from a CS perspective?
02:49:09 <archguest> fasta: anything you would recommend?
02:49:19 <cncl> archguest: the haskell school of expression
02:49:30 <cncl> though it's a little old now
02:49:34 <cncl> still good, though
02:49:53 <fasta> archguest, I liked the book we had for a course on Grammars and Parsing. 
02:50:28 <fasta> archguest,  http://www.cs.uu.nl/docs/vakken/gont/diktaat.pdf
02:50:40 <archguest> thangs, guys
02:50:43 <archguest> i'll check that out
02:52:50 <fasta> archguest, the Haskell School of Expression is nice too. 
02:53:54 <fasta> archguest, if you read the reviews on amazon and cross-reference the "real names" with people who post on Haskell Cafe you can have more. Make sure that the reviewers do not work at the same department, though. 
02:54:41 <archguest> fasta: cool, thanks!
02:55:15 <fasta> archguest, there isn't really a book on advanced Haskell, though. You would have to read papers for that.
02:55:25 <cncl> the papers are usually pretty good though!
02:55:46 <fasta> Depending on the topic, yes. For example everything about the actual formal semantics of Haskell is crappy imho. 
02:56:14 <fasta> Then again, I haven't read a lot of papers that I studied in detail that didn't have something wrong with them. 
02:58:32 <archguest> well, my main subject is physics/astronomy and there is always something wrong with a paper, i guess it's how it's supposed to be because it's research. often there are no clear answers, only questions.
02:59:02 <archguest> thanks again for your suggestions, i already got a pdf from that link and will get a book as well.
03:03:18 <kmc> archguest, are you familiar with the theory of relational databases as sets of tuples?
03:07:37 <Faye> Okay this is maybe a dumb question but I need some assistance on a website Im in charge of the upkeep and maintence. This is for a MMO type shin-dig; so some familiarity in that field would be sweet.
03:07:57 <Zao> Faye: Is it related to Haskell somehow?
03:08:21 <archguest> kmc: no this is just something i thought about, i have no formal cs education
03:09:34 <Zao> Apparently not :)
03:09:50 * Zao will be re-taking Database Systems this fall.
03:10:00 <Zao> Relation algebras and all the other Fun Stuff.
03:10:38 <kmc> archguest, ok
03:10:39 <kmc> it's a thing :)
03:10:55 <kmc> i was surprised to learn that this nasty world of SQL has a clean, even beautiful mathematical foundation
03:11:22 <fasta> Zao: retaking? What have you done?
03:12:28 <Associat0r> with Null
03:15:17 <archguest> kmc: well, i applied wanted to study cs at some posh university but it turned out i am too mediocre for them. so i am now reading about things on my own. one day i will come to the mathematics of sql.
03:15:33 <archguest> kmc: i quite like sql from the user perspective
03:16:28 * Zao -> blah
03:16:29 <archguest> ^ i meant "i applied to study" in the line above ^
03:28:18 <byorgey> Gracenotes++
03:28:27 <byorgey> ^^ for new Hackage implementation
03:31:22 <kmc> archguest, i think CS is a great field for self-teaching
03:31:26 <kmc> as long as you are motivated
03:31:43 <kmc> the only tool you really need is a computer
03:31:58 <kmc> and you can use that tool to get free tools off the Internet
03:32:00 <kmc> and books and documentation
03:32:04 <kmc> and you can build any other tool you need
03:32:25 <kmc> and if you are really good, you can get a job without formal education
03:32:32 <kmc> it's not easy but it is possible
03:37:13 <h_noob> speaking of self-teaching - is there some function similar to Maybe.fromJust but which do not fail on Nothing e. g. if it's Just - act like Maybe.fromJust, if it's Nothing - return Nothing... of course I can use case.. of.. but it seems like pretty common pattern so I thought some syntactic sugar might exist for that
03:37:51 <Zao> h_noob: Sounds like id.
03:38:19 <Zao> > map id [Just "lol", Nothing]
03:38:19 <lambdabot>   [Just "lol",Nothing]
03:39:01 <Zao> Maybe you want `maybe'?
03:39:06 <Zao> @type maybe
03:39:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:39:25 <Zao> Takes a default value and a function, and applies the function if Just, otherwise returns the default.
03:39:59 <Zao> > map (maybe 9001 (+5)) [Just 3, Nothing, Just 42, Nothing]
03:39:59 <lambdabot>   [8,9001,47,9001]
03:40:03 <h_noob> Zao: thanks, I'll try - sounds like the right thing
03:40:31 <kmc> :t fromMaybe -- h_noob
03:40:32 <lambdabot> forall a. a -> Maybe a -> a
03:41:00 <kmc> h_noob, also (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
03:41:06 <kmc> and the corresponding "do" syntax
03:41:43 <h_noob> kmc: can you point me to some example with >>= ?
03:41:47 <tkahn6> is it just me or is the RWH chapter on writing a JSON library really shitty?
03:42:06 <kmc> > Just 3 >>= succ
03:42:07 <lambdabot>   No instances for (GHC.Num.Num (Data.Maybe.Maybe b),
03:42:07 <lambdabot>                    GHC....
03:42:13 <kmc> dur
03:42:25 <kmc> > fmap succ (Just 3)
03:42:26 <lambdabot>   Just 4
03:42:28 <kmc> > fmap succ Nothing
03:42:29 <lambdabot>   Nothing
03:42:33 <kmc> > succ <$> Just 3
03:42:34 <lambdabot>   Just 4
03:42:39 <kmc> > succ <$> Nothing
03:42:39 <lambdabot>   Nothing
03:42:43 <kmc> ^^^^ this may be more what you want actually
03:43:12 <h_noob> kmc: looks neat, thank you
03:43:26 <Zao> kmc: His question is a bit odd, as he says he wants the behaviour of fromJust, which is to extract a value from a Maybe.
03:43:34 <kmc> > Just [1,2,3] >>= find even
03:43:35 <lambdabot>   Just 2
03:43:39 <kmc> > Just [1,2,3] >>= find (> 5)
03:43:40 <lambdabot>   Nothing
03:43:44 <kmc> > Nothing >>= find (> 5)
03:43:45 <lambdabot>   Nothing
03:43:54 <kmc> h_noob, examples with (>>=) ^^^^
03:43:55 <kmc> find from Data.List
03:45:56 <fxr> is catamorphism and paramorphism are the same thing?
03:46:32 <Cale> fxr: No, but they're related.
03:46:47 <BorisL> I want to remove some previously loaded modules from ghci. So, I type ":m -Module.Name", press tab and it suggests all the modules which start from Module.Name, not only loaded. Do you think it is worth to post a feature request on ghc bugtracker to make ghci suggest only loaded modules?
03:46:55 <fxr> so what are the differences?
03:49:54 <Cale> Let me try to remember which one paramorphism was :)
03:50:16 <fxr> "Paramorphisms supply the gene of a catamorphism with a recursively computed copy of the input."
03:50:57 <fxr> "Catamorphisms model the fundamental pattern of iteration, where constructors for recursive datatypes are repeatedly consumed by arbitrary functions. They are usually called folds."
03:51:11 <fxr> taken from Generics.Pointless.RecursionPatterns
03:51:16 <fasta> BorisL, you can better just send in a patch. 
03:51:29 <fasta> BorisL, they will likely ignore requests like that. 
03:52:36 <Cale> Oh, I see.  para a f [] = a; para a f (x:xs) = f x xs (para xs), so it's similar to foldr over tails of the list.
03:52:48 <Cale> er, oops
03:53:02 <Cale> para a f [] = a; para a f (x:xs) = f x xs (para a f xs)
03:54:26 <fxr> I came to this question after reading sfvisser's papers, he uses paramorphism concept on his thesis, but in a paper, he uses cata for the same concept.
03:54:26 <dobblego> para is like foldr but also takes the tail along with the element
03:55:11 <fasta> Is that module name a pun?
03:56:31 <BorisL> fasta, yes, I thought it is the most likely outcome. If I have free time, I will look at ghci code. Module name is just an example. It might be Data.List or Control.Monad
03:57:04 <fxr> is the annotated fixed points concept new for the haskell community?
03:57:56 <fasta> fxr, AFAIK, it _is_ relatively new. 
03:58:10 <zygoloid> > let f x (xs,v) = (x:xs, g x v xs) in snd $ foldr f ([],a) [b,c,d,e]
03:58:11 <lambdabot>   g b (g c (g d (g e a []) [e]) [d,e]) [c,d,e]
03:58:22 <zygoloid> ^^ building para from cata for []
03:58:36 <fasta> fxr, so the qualification seems a bit redundant. Also, the usefulness of it is completely unproven. 
03:59:48 <fxr> fasta: he wrote a persistence library by using annotated fixedpoints to give every node in a recursive structure a pointer to a disk heap.
04:00:04 <fxr> I think it's very valuable work
04:00:27 <Cale> http://www.cube20.org/
04:00:49 <fasta> fxr, I am not saying you cannot do useful things in a contrived manner. 
04:00:57 <zygoloid> Cale: there's a new P != NP proof out, and you post /that/ link? ;-)
04:00:59 <exDM69> Cale: saw that earlier today on hacker news, very cool
04:01:12 <fasta> zygoloid, it has already been posted ;)
04:01:29 <Cale> zygoloid: P /= NP proofs are boring until they're not just in a preprint archive.
04:02:05 <fasta> Cale, there is a P=NP proof that has been published. 
04:02:28 <exDM69> in fact there are dozens, but they are disputed
04:02:32 <fasta> It doesn't have a stamp of Knuth on it (or anybody else that is not anonymous, though). 
04:02:33 <zygoloid> i suppose both a proof of P/=NP and a proof that god's number is 20 have the property that you go "huh, ok, fair enough. this affects my life in no conceivable way" ;)
04:02:38 <exDM69> http://www.win.tue.nl/~gwoegi/P-versus-NP.htm
04:02:44 <zygoloid> a proof that P=NP on the other hand...
04:02:48 <fasta> exDM69, not a lot of those have been published.
04:03:15 <Cale> zygoloid: I'm waiting for the proof that P = NP where you still go "huh, ok, fair enough. this affects my life in no conceivable way"
04:04:01 <Cale> zygoloid: Because the best possible polynomial time reduction for any NP-hard problem is shown to be O(n^G), where G is Graham's number, or something similar.
04:05:02 <zygoloid> Cale: of course, G would only be an upper bound. and the real exponent would be believed to be 6... ;)
04:05:49 <zygoloid> but yeah. the assumption that polytime == fast is perhaps optimistic
04:05:51 <Cale> That would be more tantalising, but I was thinking it would be funny for the lower bound to be combinatorially large like that.
04:06:16 <Cale> "Oh wait, the space of polynomial time algorithms is larger than we thought"
04:06:23 <zygoloid> :)
04:07:03 <path[l]> yeah this is why I was wondering why cryptography wasnt dead once someone did primefactorization in p time
04:07:28 <path[l]> then I realised p time could mean a large number
04:07:37 <zygoloid> prime factorization is easy. it's composite factorization that's hard ;)
04:09:35 <Cale> Uh, the prime factorisation problem isn't known to be in P, but there are sub-exponential algorithms.
04:09:45 <fxr> is it possible to define javascript syntax using Mu and pattern functors?
04:09:49 <Cale> Primes is in P (deciding if a number is prime or not)
04:11:44 <path[l]> wait what is Primes?
04:11:58 <Cale> path[l]: Deciding whether a number is prime or not.
04:12:08 <path[l]> ah
04:12:19 <path[l]> sorry misread that
04:12:20 <path[l]> lol
04:12:44 <path[l]> I read (deciding if a number is prime or not) as (deciding if a number is prime is not)
04:13:06 <Cale> It's also worth noting that they measure the input size using the number of bits of the number, not the number itself.
04:13:42 <Cale> So trial division is really an exponential time algorithm for factoring.
04:14:34 <drp> I need some help with a monad transformer.  I have a function that returns an ErrorT, which I want to compose with a pure function.  I suspect some type of lift is needed, but damned if I can see it.  I think the type of the function I'd like to write  is :
04:14:43 <drp> (b->b) -> (a -> ErrorT String IO b) -> (a -> ErrorT String IO b)
04:17:55 <luite> sometimes a distinction is made between problems that are still hard when using the numbers themselves as a measure of the input size (unary encoding) and problems that become easy under such an encoding
04:19:54 <h_noob> I have a question on record syntax: I got "data Section = Section {sectionName :: String, sectionContent :: [(String, Pike)]}" and a function which returns Maybe [(String, Pike)] (it uses find). Now I'd like to make a use of "lookup" to get a value of particular key from sectionContent and I got problem: straightforward approach "lookup "cluster" (sectionContent ( (findSection "xxx" val)))" will not work because sectionContent expect "Section" instead of "M
04:20:16 <Cale> drp: That looks like a couple of fmaps
04:20:48 <h_noob> another thing I tried is "lookup "cluster" (fmap (maybe (Nothing) (sectionContent)) (findSection "xxx" val))"
04:21:10 <h_noob> but it also fails :(
04:21:41 <ivanm> h_noob: the brackets around Nothing and sectionContent aren't needed
04:21:49 <ivanm> what are you trying to do though?
04:21:56 <drp> :t (undefined :: (a->ErrorT String IO b))
04:21:57 <lambdabot> forall a b. a -> ErrorT String IO b
04:22:13 <drp> :t :t (liftM (undefined :: b->b)) (undefined :: (a->ErrorT String IO b))
04:22:14 <lambdabot> parse error on input `:'
04:22:21 <Cale> drp: Specifically ((.) . fmap) can have that type
04:22:28 <h_noob> ivanm: I'm trying to get rid of Maybe so I can use selector function from record syntax
04:22:33 <Cale> (or fmap . fmap, using the function instance of Functor)
04:22:38 <ivanm> get rid of maybe? how?
04:22:40 <ivanm> in what?
04:23:03 <luite> h_noob: what is the type of findSection "xxx" val? Maybe Section?
04:23:11 <ivanm> by using lookup you're just getting a Maybe back
04:23:12 <h_noob> ivanm: this could be done like "lookup "cluster" (sectionContent (fromJust (findSection "xxx" val)))" but it's an ugly hack :)
04:23:26 <ivanm> luite: for lookup to work, it'd have to be a list wouldn't it?
04:23:33 <h_noob> ivanm: I'm trying to get rid of Maybe so I can use lookup
04:23:35 <drp> Cale: thx.  fmap is the same as liftM but more general because for any functor?
04:23:36 <Cale> h_noob: you could use  case  to pattern match on the result, or there are lots and lots of library functions for working with Maybe values.
04:23:38 <luite> :t lookup
04:23:39 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
04:23:41 <Cale> drp: yeah
04:23:45 <Cale> drp: You could also use liftM
04:23:53 <ivanm> h_noob: lookup "cluster . maybe [] sectionCOntent $ findSection "xxx" val
04:23:55 <Cale> drp: Since your functors are monads here :)
04:27:04 <h_noob> ivanm: thanks, that's what I missed - using empty list as default value... doh, I need more coffee
04:27:21 <ivanm> heh
04:27:41 <luite> h_noob: you might try  findSection "xxx" val >>= lookup "cluster" . sectionContent
04:29:16 <h_noob> luite: thank you! but I will need something stronger than coffee to understand it :)
04:29:28 <luite> h_noob: it's a monad, they're really scary ;)
04:29:56 <luite> h_noob: (it's really not by the way)
04:29:58 <Cale> Well, Maybe isn't so scary
04:30:17 <Cale> You just have to know that  Nothing >>= f = Nothing, and that (Just x) >>= f = f x
04:30:18 <h_noob> luite: well, if I'll manage to grasp it my math teacher would be so proud :D
04:30:37 <Cale> I think it's prettier if you use =<<  if you're going to also use (.)
04:30:46 <luite> yeah just read what Cale just said
04:30:51 <Cale> lookup "cluster" . sectionContent =<< findSection "xxx"
04:31:08 <h_noob> Cale: that's a great explanation
04:31:12 <Cale> So if findSection "xxx" gives Nothing, then this whole expression evaluates to Nothing
04:31:31 <Cale> and if findSection "xxx" gives Just x, then this evaluates to  lookup "cluster" . sectionContent $ x
04:34:18 <h_noob> Cale: that's interesting - "findSection "xxx" val >>= lookup "cluster" . sectionContent" works just as you've explained but "lookup "cluster" . sectionContent =<< findSection "xxx"" gives error: Couldn't match expected type `Maybe Section' against inferred type `[Section] -> Maybe Section' In the second argument of `(=<<)', namely `findSection "xxx"'
04:34:47 <h_noob> probably there is some difference between >>= and <<= besides application order?
04:35:07 <Cale> oh, I missed 'val'
04:35:18 <quicksilver> >>= and =<< (if that's what you meant) are the same except for argument order
04:35:29 <quicksilver> (=<<) = flip (>>=)
04:35:36 <Cale> lookup "cluster" . sectionContent =<< findSection "xxx" val
04:35:43 <h_noob> doh!
04:35:52 <h_noob> I should have spotted it
04:36:58 * hackagebot blaze-html 0.2 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.2 (JasperVanDerJeugt)
04:37:00 <aristid> :t [(=<<), (.) join . liftM]
04:37:01 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => [(a1 -> m a) -> m a1 -> m a]
04:38:59 * hackagebot blaze-from-html 0.2 - Tool to convert HTML to BlazeHtml code.  http://hackage.haskell.org/package/blaze-from-html-0.2 (JasperVanDerJeugt)
04:42:21 <luite> h_noob: you make it work without val by the way, in this way:
04:42:36 <luite> lookup "cluster" . sectionContent <=< findSection "xxx"
04:43:00 * hackagebot blaze-html 0.2.1 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.2.1 (JasperVanDerJeugt)
04:43:15 <h_noob> luite: holy crap - it looks like a fish.. :)
04:43:37 <h_noob> where can I read more on =<< and <=< ?
04:43:44 <luite> h_noob: it's not really new, since it just uses the >>= for Maybe you already know
04:44:20 <aristid> :t (<=<)
04:44:21 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
04:44:23 <luite> h_noob: =<< is just >>= flipped around, >>= is commonly referred to as the 'bind' operation
04:44:26 <aristid> @src <=<
04:44:26 <lambdabot> Source not found. My mind is going. I can feel it.
04:44:53 <aristid> :t \a b c -> (a c) =<< b
04:44:54 <lambdabot> forall t a (m :: * -> *) b. (Monad m) => (t -> a -> m b) -> m a -> t -> m b
04:46:46 <drp> Cale: thanks for the help - works now.  working with transformers always seems to make my head hurt...
04:47:02 * hackagebot blaze-from-html 0.2.1 - Tool to convert HTML to BlazeHtml code.  http://hackage.haskell.org/package/blaze-from-html-0.2.1 (JasperVanDerJeugt)
04:47:04 <luite> h_noob: you can read about those in any monad tutorial... but for the >=> it's just:    a >=> b = \x -> a x >>= b
04:47:34 <luite> h_noob: and just like =<< is a flipped >>=, <=< is a flipped >=>
04:50:44 <h_noob> luite: which monad tutorial - it seems like there are thousands of them floating around
04:50:46 <h_noob> :)
04:52:01 <Axman6> there are
04:52:04 * hackagebot blaze-html 0.2.2 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.2.2 (JasperVanDerJeugt)
04:52:26 <jaspervdj> Sorry for the package spam, I was having troubles with custom cabal hooks
04:52:43 <aristid> :t \a b c -> a =<< (b c)
04:52:44 <lambdabot> forall t a (m :: * -> *) b. (Monad m) => (a -> m b) -> (t -> m a) -> t -> m b
04:52:47 <luite> h_noob: hmm, don't know, I don't think I ever used a monad tutorial... the problem is that they're not really so magical (or scary). there's nothing really you can do with a monad that you can't do without (ok, there are some special monads like IO and ST, but they're strange)
04:53:00 <kmc> yeah
04:53:12 <kmc> the point of this class we call "Monad" isn't that it gives you some special power
04:53:12 <aristid> @pl \a b c -> a =<< (b c)
04:53:12 <lambdabot> (.) . (=<<)
04:53:19 <kmc> the point is that it unifies the interfaces to a lot of different things
04:53:26 <kmc> so you can use the same syntax and functions for all of them
04:53:27 <aristid> so @pl does not know about <=<
04:54:10 <Eelis> kmc: isn't the Monad type class special in that it is recognized by the compiler for do-notation?
04:54:25 <cncl> Eelis: you can rebind it!
04:54:27 <Eelis> s/recognized by/known to/
04:54:27 <ivanm> any ideas where an error of "commitAndReleaseBuffer" comes from?
04:54:36 <Eelis> cncl: i don't know what that means.
04:54:41 <ivanm> Eelis: there are hacks you can do to let it use any typeclass called Monad
04:54:42 <luite> and I haven't yet written my own monad tutorial, so I guess I can't be considered a real haskell programmer ;)
04:54:49 <Eelis> ivanm: i see..
04:54:51 <cncl> Eelis: you could make a new typeclass that is sort of like monad but not exactly, and have it work with do-notation
04:54:53 <kmc> there are hacks that will let it use whatever (>>=) is in scope
04:54:54 <ivanm> Eelis: e.g. Heffalump's RMonad exports a Prelude replacement that lets you do this
04:54:57 <kmc> even if it belongs to no class at all
04:55:15 <kmc> Eelis, anyway, you're right that it's special in this way, but it's only sugar
04:55:17 <Eelis> the fact that you need "hacks" tells me enough :)
04:55:55 <cncl> is it a hack?
04:55:59 <cncl> i thought it was just normal
04:56:05 * hackagebot blaze-html 0.2.3 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.2.3 (JasperVanDerJeugt)
04:56:05 <chrisdone> #define TODO (error $ "TODO:" ++ __FILE__ ++ ":" ++ show __LINE__)
04:56:05 <chrisdone> is this defined anywhere?
04:56:08 <ivanm> I think it can be classified as a hack
04:56:14 <kmc> you need ghc -XNoImplicitPrelude
04:56:17 <luite> h_noob: the point is that in haskell, Monad is just a type class with the functions (>>=) and return, along with some basic rules they are supposed to obey
04:56:23 <kmc> otherwise it uses (Prelude.>>=) even if you hide it normally
04:56:26 <ivanm> chrisdone: oooohhhh, I like that...
04:56:30 <cncl> i guess that is a hack then? :)
04:56:50 <cncl> usually hack is like, "modify this line in the preprocessor and recompile the compiler" or something, to me :]
04:56:51 <ivanm> chrisdone: btw, have you ever thought about packaging your extensions to haskell-mode rather than telling people to just grab it off github?
04:57:16 <h_noob> luite: so things like >>= and <=< are defined over actions inside some Monad but I can redefine them?
04:57:21 <chrisdone> ivanm: yeah actually! :D I started doing it today, I was gonna package it as haskell-mode-exts or somesuch and put it on github. what do you think?
04:57:33 <cncl> chrisdone: what do your extensions do?
04:58:01 <ivanm> chrisdone: sounds good to me; I'd just like to have a versioned tarball that can be downloaded and turned into a distro package if possible
04:58:03 <luite> h_noob: <=< is just a utility function, you don't need to care about that when making your Monad
04:58:29 <luite> h_noob: when making your own, you must implement >>= and return
04:58:39 <chrisdone> cncl: just some helpers; (1) align up import statements in your file, (2) jump to the import statements and then back again, (3) get a complete list of all installed packages and modules, (4) talk to cabal, and a few others I'm working on atm.
04:58:45 <aristid> h_noob: (a <=< b c) = (b c) >>= a
04:58:45 <chrisdone> ivanm: sure thing
04:58:51 <aristid> argh wrong parens
04:58:55 <cncl> chrisdone: ah that is cool
04:58:59 <h_noob> I see... looks like I should read something on monadic rules to get a clue :)
04:59:03 <aristid> (a <=< b) c = (b c) >>= a
04:59:04 <ivanm> chrisdone: were you thinking of a better cabal-mode whilst you're at it?
04:59:07 <chrisdone> ivanm: I've been emailed svein about haskell-mode but he seems to be MIA atm
04:59:24 <aristid> chrisdone: "MIA"?
04:59:25 <cncl> chrisdone: though i usually just use ctrl-o to jump back from import statements (since i use viper-mode/vimpulse)
04:59:46 <ivanm> preflex: seen Baughn 
04:59:47 <preflex>  Baughn was last seen on #haskell 23 hours, 4 minutes and 40 seconds ago, saying: copumpkin: It's just the 2999'th major version. What?
04:59:52 <ivanm> aristid: Missing In Action
04:59:52 <chrisdone> ivanm: actually I was discussing today about scrapping editing the .cabal file manually and just doing it more like a custommize-group-ish view. not sure. definitely a better way to edit the files is needed
05:00:01 <luite> h_noob: to complete the Maybe Monad instance, you've already seen:  (Just x) >>= f = f x  Nothing >>= f = Nothing,   and the other function: return x = Just x
05:00:06 <aristid> ivanm: that's a stupid abbreviation
05:00:14 <luite> h_noob: that's a complete Monad. 
05:00:14 <ivanm> chrisdone: well, better syntax highlighting for when you need to edit it by hand would be nice
05:00:21 <ivanm> aristid: why? also, I think it's a military term
05:00:28 <chrisdone> sure, that's trivial. I'll add it to my list
05:00:29 <ivanm> you also have KIA, etc.
05:00:33 <ivanm> cool
05:00:45 <aristid> ivanm: because this is not the military here.
05:01:05 <ivanm> .... so?
05:01:14 <ivanm> a lot of acronyms get used out of place
05:01:23 <luite> h_noob: if you look at the types, you can see that there is not really another option for both of those functions, otherwise you'd get a really uninteresting monad (unless you like calculations where you always end up with Nothing)
05:01:25 <aristid> and duh, you can just say "missing" instead
05:01:34 <cncl> oh, here's a question for anyone knowledgeable of haskell-mode and emacs: is there a command to move the cursor forward and backward by expression? (like forward-sexp in a lisp mode)
05:01:35 <chrisdone> aristid: sorry. it's fairly common use, like ymmv "your mileage may vary", etc. basically I haven't seen him for a while and the mailing list is dead
05:01:35 <ivanm> and the military just seems to generate a lot of acronyms
05:01:40 <ivanm> aristid: which one is shorter?
05:01:40 <aristid> if an abbreviation can be replaced by a single word, the abbrevation is pointless
05:01:52 <ivanm> dont' forget, IRC lead to a lot of new acronyms being developed ;-)
05:01:58 <luite> h_noob: if you want to, we could do an example
05:02:10 <aristid> ivanm: i hate unnecessary abbreviations because they create barriers to communication
05:02:17 <ivanm> aristid: *shrug*
05:02:42 * ivanm demands we be allowed to keep at least "AWOL" though
05:02:43 <ivanm> ;-)
05:03:17 <aristid> i know what AWOL means, because that one was explained to me when i asked about that once
05:03:39 <cncl> are they coming to take away my abbreviations? how will i get by without datatypes named NSFBSROMAddr :(
05:03:45 <ivanm> lol
05:03:50 <chrisdone> I like the idea of writing little modules that people can pick and choose
05:03:54 <quicksilver> in a world where abbreviations are one quick google search away, I don't think they're a real impediment.
05:04:14 <cncl> (nintendo sound format bytestring rom address)
05:04:23 <cncl> oops rom is an abbreviation too
05:04:27 <chrisdone> quicksilver: btw tbh idk
05:04:28 <fasta> There is a patent on replacing abbreviations by their full expansion. 
05:04:40 <chrisdone> quicksilver: I think that's a valid sentence :D
05:04:50 <fasta> (Not that I think this patent would hold up in court. )
05:04:50 <ivanm> even better: install wtf and use that!
05:04:52 <chrisdone> !optimisation!
05:04:52 <aristid> quicksilver: my hatred of them has been trained on some big-corp bureaucratic proceedings
05:04:55 <ivanm> no need to even google for most of them
05:04:56 <quicksilver> chrisdone: nope, you missed off the full stop ;)
05:05:01 <chrisdone> quicksilver: drat :P
05:05:23 <fasta> ivanm, wtf? apt-get install wtf does not compute.
05:05:23 <ivanm> ugh, no canonical URL for wtf; seems to be a netbsd app
05:05:36 <ivanm> fasta: well, there's a gentoo package called that...
05:05:42 <ivanm> and an emacs wrapper for said package
05:05:43 <h_noob> luite: I think I'm missing crucial point in here - is it always return x = Just x or I simply have to implement return x = f x where f is so sort of function doing something with x?
05:05:45 <quicksilver> ivanm: google search is actually easier than a commandline tool.
05:05:58 <ivanm> depends if you have a terminal open already
05:06:03 <quicksilver> ivanm: easier to open a new browser tab than a new terminal tab
05:06:11 <fasta> ivanm, how is it better than dict AWOL
05:06:16 <quicksilver> and I hate to re-use an existing terminal, that was alreayd there for a reason
05:06:24 <aristid> fasta: wtf is in packages bsdgames
05:06:35 <ivanm> why would you need to open a new terminal tab?
05:06:54 <ivanm> and you can pipe the result of wtf into IRC using /exec!
05:06:55 * chrisdone just hits Win+Shit+Return for a new terminal >__>
05:07:11 <luite> h_noob: (>>=) and return are part of the Monad typeclass, and they have specific types:  (>>=) :: m a -> (a -> m b) -> m b   and return :: a -> m a
05:07:14 <fasta> In Gnome you can do Alt-t
05:07:15 <theorbtwo> C-a c wtf ymmv C-d vs a-tab c-t a-d google.com ret ymmv ret c-w
05:07:17 <h_noob> chrisdone: let me guess - xmonad? :)
05:07:22 <theorbtwo> Doesn't seem that different to me.
05:07:23 <chrisdone> h_noob: :)))))
05:07:46 <chrisdone> so CPP #define's aren't exportable. tricky
05:07:46 <quicksilver> theorbtwo: A-tab C-t ymmv ret
05:07:51 <cncl> surf is my new favorite browser for use in xmonad
05:07:53 <theorbtwo> Hm.  That a-d is redundant.
05:07:55 <luite> h_noob: in particular, since we work with Maybe, the types are:   (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b  and return :: a -> Maybe a
05:07:58 <cncl> it's just a small thin wrapper around webkit
05:08:02 <Baughn> chrisdone: I'm here. Honest.
05:08:04 <cncl> plays great with a TWM
05:08:15 <Baughn> chrisdone: My email account is MIA, though. :/
05:08:22 <chrisdone> Baughn: hi baughnie :-)
05:08:31 <fasta> wtf AA doesn't even work.
05:08:39 <luite> h_noob: (the first ones are the types for each monad, the second ones are those for maybe)
05:08:42 <luite> Maybe
05:08:44 <fasta> Not that it is a technical term, but still.
05:09:04 * chrisdone puts two and two together
05:09:06 <fasta> Or wtf HM for that matter.
05:09:15 * chrisdone Svein and Baughn are the same person
05:09:19 <chrisdone> O___O
05:09:22 <luite> h_noob: if we look at return, we get a value of type a, and we must return a Maybe a
05:09:37 <Baughn> chrisdone: ...this is surprising?
05:09:45 <luite> h_noob: there are two possibilities, either (Just a), or Nothing
05:09:50 <Baughn> chrisdone: "Baughn [~svein@40.39.202.84.customer.cdi.no]"
05:09:51 <chrisdone> Baughn: lol. I thought svein was a different norwegian guy
05:10:04 <chrisdone> dude you never join or quit
05:10:23 <Baughn> Details. Don't bother me with the details.
05:10:27 <chrisdone> :P
05:10:41 <Baughn> chrisdone: So, anyway. What about haskell-mode?
05:11:00 <h_noob> luite: looks like I got it - both return and (>>=) gives as monad something and in addition to those 2 mandatory function we can define other which could help to get rid of Monad or otherwise - bring some value into monad
05:11:04 <chrisdone> Baughn: are you making any headway converting it to using haskell-src-exts?
05:11:16 <h_noob> s/gives as/give us/
05:11:20 <luite> h_noob: now we need an additional 'law' for what a Monad is supposed to do, every good Monad should obey   a >>= return = a
05:11:45 <Baughn> chrisdone: Sort of. I'm havingto convert haskell-src-exts to handle partial/broken code first, but that's.. not completely progress-free.
05:11:45 <luite> h_noob: this restricts our implementations of return to  return x = Just x
05:13:00 <h_noob> luite: you mean "implementation for Maybe" or more general - restricts implementation of return a for a given >>= ?
05:13:01 <luite> h_noob: yes return brings a value into the monad, (>>=) doesn't really 'get rid of' the monad, but it does let you apply functions to things 'within' the monad
05:13:06 <chrisdone> Baughn: hm, sure
05:13:10 <quicksilver> Baughn: interesting. That sounds hard
05:13:21 <quicksilver> Baughn: I'd have taken the approach of ensuring the code is always valid, I think
05:13:30 <luite> h_noob: well, the general law is that for each Monad,  a >>= return = a
05:13:34 <quicksilver> combination of paredit tricks (inserting closing pairs) and adding secredt 'undefineds'.
05:13:42 <quicksilver> still I'll be interested to see how your way goes.
05:14:06 <chrisdone> quicksilver: Baughn: me too... can't you do code reconstruction surgery if haskell-src-exts doesn't like it?
05:14:19 <luite> h_noob: take for example (Just 1) :: Maybe Integer, and return = Nothing
05:14:26 <Baughn> chrisdone: That's essentially what I'm doing, I'm just doing it inside haskell-src-exts, at the point where it otherwise fails.
05:14:30 <luite> h_noob: then (Just 1) >>= return = Nothing
05:14:57 <quicksilver> well if you can make h-s-e work on invalid data then you've doen a service to all users of it, I guess
05:15:04 <quicksilver> layout helps, funnily enough
05:15:11 <quicksilver> it gives a natural set of 'reset' points
05:15:16 <Baughn> Layout does help. Yes, exactly.
05:15:16 <luite> h_noob: Oh I forgot an x, return x = Nothing
05:15:23 <quicksilver> even if you bail completely until the next implicit }
05:15:24 <chrisdone> indeed
05:16:08 <quicksilver> Baughn: next can I have subtle tones of background colour showing nested layout blocks please?
05:16:15 <chrisdone> (fwiw in my personal use, if the editor is strict and has a cyclic checking interval to wait for me to correct the code I'd be happy with that)
05:16:17 <Baughn> quicksilver: Sure.
05:16:28 <quicksilver> \o/
05:17:44 <luite> h_noob: there are three such laws for monads, but the compiler can't check them for you
05:18:39 <quicksilver> chrisdone: paredit and always-valid code is one of my favourite things about programming lisp.
05:18:53 <quicksilver> of course you can use paredit in haskell too but it doesn't make your code always well-formed.
05:18:54 <chrisdone> quicksilver: true. Lisp programming is my favourite editing experience
05:19:47 <cncl> how does yi handle malformed haskell code?
05:19:51 <h_noob> luite: ok, this one I understood, time for http://www.haskell.org/haskellwiki/Tutorials#Using_monads :)
05:20:01 <Baughn> I think I'd feel.. hobbled, if I had to write Haskell code that was always valid.
05:20:14 <Baughn> quicksilver: I might be mistaken, though. You should try writing a mode for it. ;)
05:20:22 <ivanm> cncl: in what sense?
05:20:53 <cncl> like if you just do like, f x = )))(()D))))(# on a line or something, and then keep going like normal on the next
05:21:05 <luite> h_noob: ok, keep in mind that every specific Monad has its own (>>=) and return. if you look at their types, and the monad laws, you can often make a guess what they should do. In most cases, you'd be right
05:21:14 * ivanm tries
05:21:16 <luite> h_noob: without looking at the source code
05:21:25 <quicksilver> Baughn: depends what "valid" means. Just lacking in syntax errors is probably a high enough goal.
05:21:32 <cncl> i don't have yi installed, otherwise i'd just try it myself
05:21:40 <ivanm> I do
05:21:48 <quicksilver> Baughn: (so it might have undefined identifiers and certainly type errors)
05:22:12 <cncl> ivanm: do you use it frequently? does anyone?
05:22:15 <ivanm> cncl: doens't seem to support any indentation stuff
05:22:18 <ivanm> and no, I don't actually use yi
05:22:28 <Baughn> quicksilver: And after fixing haskell-src-exts, for an encore I'll have the editor point out type errors in realtime.
05:22:29 <ivanm> I just had it installed when testing the new gentoo ebuild for it
05:22:45 <cncl> i like it in principle but emacs just has several nations worth of people behind it
05:22:55 <ivanm> and I'm probably going to keep it installed just because it uses so many deps it means that I'm more likely to update gentoo packages when they become available
05:23:04 <cncl> haha yes
05:23:11 <ivanm> Baughn: is this going to be stuff going to upstream for haskell-src-exts or a fork/wrapper around haskell-src-exts proper?
05:23:19 <Baughn> ivanm: Yes.
05:23:20 <cncl> the last time i tried to build it, it failed :(
05:23:20 <luite> h_noob: learning monads then just becomes learning how the (>>=) and return functions of each individual monad behave
05:23:30 <ivanm> well, according to tibbe's survey vim is still more popular for haskell code than emacs
05:23:39 <quicksilver> Baughn: hurrah! 
05:23:43 <ivanm> even though the impression one gets here is that emacs is slightly more popular
05:24:16 <ivanm> Baughn: excellent, I have occasional problems with haskell-src-exts for SourceGraph where people ask me why it can't parse a file, and my only answer is "because haskell-src-exts doesn't" :s
05:24:17 <chrisdone> Baughn: so I'm making little self contained modules http://gist.github.com/453933, http://gist.github.com/511240, http://gist.github.com/511670, for working with Haskell code and inf-haskell. I have two or three more in the pipeline and more after that. I'm writing them not to be dependent on haskell-mode or eachother. I'm going to package them up as haskell-mode-exts. parts of it could filter into haskell-mode if you feel like it :-)
05:24:23 <quicksilver> ivanm: emacs users make more noise :)
05:24:27 <ivanm> (well, that and if they also use CPP macros; haven't got cpphs support yet)
05:24:30 <ivanm> quicksilver: exactly
05:24:31 <cncl> ivanm: just a guess i have, but it might be because there are actually a decent number of windows users of haskell, but less so in this channel than a random sample of the population. vim is a lot better experience than emacs in windows
05:24:32 <h_noob> luite: so monads are essentially some sort of incapsulation - we know how to apply some functions to things which are inside it and how dump something into it - is it so?
05:24:33 <quicksilver> ivanm: or, perhaps it's just quicksilver that makes more noise.
05:24:39 <ivanm> heh
05:24:42 <Baughn> ivanm: The "yes" was "if the upstream guy will have my patches", by the way.
05:24:45 <luite> h_noob: you already know Maybe, other interesting examples may be State, Writer and [] (the list monad)
05:24:46 <Baughn> Otherwise I'm forking.
05:24:51 <ivanm> Baughn: oh, of course
05:24:54 <ivanm> that was a given
05:24:56 <cncl> ivanm: then again i use viper+vimpulse in emacs :)
05:25:06 <ivanm> cncl: I've never had any problem getting emacs working on windows
05:25:08 <h_noob> luite: []?! list is also a monad?
05:25:11 <ivanm> there's dedicated binaries floating around, etc.
05:25:14 <luite> h_noob: yes that's a good explanation in many cases
05:25:24 <ivanm> h_noob: yes; it is often used to provide pseudo-logic style programming
05:25:27 <luite> h_noob: yes... you may take a guess what return x does
05:25:29 <ivanm> for lists, >== = concatMap
05:25:32 <cncl> ivanm: i see
05:25:42 <Baughn> > do x <- [1..5]; y <- [10,20]; return (x*y)
05:25:43 <luite> h_noob: keep in mind that in this case: return :: a -> [a]
05:25:44 <lambdabot>   [10,20,20,40,30,60,40,80,50,100]
05:25:44 <quicksilver> cncl: I find emacs a very pleasant experience on windows; in fact the only part of using windows that doesn't cause me physical discomfort.
05:26:13 <fasta> quicksilver, why do you even use Windows?
05:26:13 <ivanm> > d x <- [1..5]; y <- [10,20]; guard (even $ x + y); return (x*y)
05:26:14 <lambdabot>   <no location info>: Parse error in pattern
05:26:21 <ivanm> bah
05:26:23 <ivanm> > do x <- [1..5]; y <- [10,20]; guard (even $ x + y); return (x*y)
05:26:24 <lambdabot>   [20,40,40,80]
05:26:26 <quicksilver> fasta: I don't, really.
05:26:28 <cncl> quicksilver: haha, i'll keep that in mind
05:26:37 <quicksilver> fasta: there have been a couple of occasions when my normal computer was broken.
05:26:42 * theorbtwo uses emacs inside a vm via putty, and finds it quite usable.
05:26:44 <quicksilver> fasta: I have a PC on my desk for testing IE6.
05:27:00 <fasta> cncl, you can get the same Emacs Haskell setup working under Linux and Windows. 
05:27:05 <philed> Has anyone used F# in Visual Studio? Having intellisense type-inference while you're typing a function is amazing.
05:27:22 <Baughn> philed: I'll have to take a look
05:27:29 <fasta> philed, how fast is it?
05:27:36 * ivanm has no need for an IDE
05:27:52 <fasta> philed, that is, does it take less than 10ms for the completion to be computed and shown?
05:27:59 <h_noob> ivanm: you mean (>>=) = concatMap ?
05:28:07 <cncl> fasta: probably not mine, i've screwed around with it a lot :)
05:28:14 <ivanm> h_noob: right
05:28:27 <philed> fasta: It doesn't do completions. You hover the mouse over a term and it comes up with a highlight telling you what type it is able to infer. And if it detects a type error as you write it underlines it.
05:28:33 <cncl> my linux setup does not even work on os x, since i replace emacs windows with frames and do window management in xmonad
05:28:33 <luite> h_noob: it is yes, but he shouldn't have told you the solution already ;)
05:28:48 <philed> They've got an even more sophisticated version of this for JEdit and Poly/ML.
05:28:54 <ivanm> luite: sorry, didn't realise you wanted him to derive it
05:28:58 <deteego> what is the operator to get an N'th element out of a list
05:29:05 <chrisdone> :t (!!)
05:29:06 <lambdabot> forall a. [a] -> Int -> a
05:29:32 <luite> ivanm: hehe no prob, I can understand the desire to show off some neat monad examples :p
05:29:38 <philed> The F# one only works on identifiers. The Poly/ML one will work on whatever expression you highlight.
05:29:52 <deteego> thanks
05:30:23 <h_noob> :)
05:31:09 <chrisdone> @let safeN n = take 1 . drop (n-1)
05:31:10 <lambdabot>  Defined.
05:31:11 <chrisdone> :t safeN
05:31:12 <lambdabot> forall a. Int -> [a] -> [a]
05:31:17 <chrisdone> > safeN 3 [1..5]
05:31:18 <lambdabot>   [3]
05:31:21 <ivanm> chrisdone: take 1 == listToMaybe
05:31:53 <ivanm> oh, wait, sorry, you wanted it to return a list
05:31:58 <chrisdone> depends if you want Maybe or []
05:32:01 <ivanm> I think returning a Maybe makes more sense though
05:32:04 <ivanm> > listToMaybe $ drop (3-1) [1..5]
05:32:04 <lambdabot>   Just 3
05:40:00 <roconnor>  
05:40:53 <ivanm> did you mean to say something roconnor?
05:41:06 <chrisdone> roconnor: how can you use a phone if you cannot... speak?
05:41:21 <roconnor> I was catching a falling laptop
05:41:31 <chrisdone> roconnor: free laptops for all!?
05:41:53 <philed> Does anyone have any thoughts on Deolalikar's proof that P != NP?
05:42:02 <philed> http://www.scribd.com/doc/35539144/pnp12pt
05:42:16 <ivanm> philed: they're discussing it in #haskell-blah
05:42:19 <fasta> philed, never ever point to scribd when there is a pdf. 
05:42:20 <philed> Cool.
05:42:36 <philed> fasta: Sorry, first link I pulled from an email :)
05:42:40 <roconnor> too bad it isn't done in Coq
05:43:18 <roconnor> actually, even if the proof were in Coq I'd think it was a bug in Coq
05:43:27 <ivanm> heh
05:44:19 <fasta> roconnor, does your Phd. thesis also descibe the Coq details of your construction, btw? E.g. somewhat like an advanced example? The normal text was more about the high-level decisions you took. 
05:44:40 <fasta> roconnor, Matita is easier to understand.
05:44:47 <roconnor> fasta: I try to describe anything non-obvious
05:44:47 <fasta> roconnor, (and verify)
05:45:00 <roconnor> why is Matita easier to verify?
05:45:12 <fasta> roconnor, there is less code and less code is trusted in the kernel.
05:45:18 <roconnor> ah
05:45:26 <fasta> roconnor, but it is still not completely obvious. 
05:45:31 <roconnor> if the proof were in Coq and Matita then I might be inclined to believe it
05:46:08 <copumpkin> roconnor: TacticalGrace says it's by contradiction!
05:46:19 <fasta> copumpkin, you can also do that in Coq.
05:46:20 <copumpkin> oh, but luqui says it isn't
05:46:33 <roconnor> copumpkin: P != NP is a Pi2 senctence
05:46:41 <copumpkin> fasta: yeah, I guess :) but you need to assume an additional lemma to do so don't you?
05:46:57 <fasta> copumpkin, you can import classical reasoning.
05:47:13 <fasta> copumpkin, every proof is relative to some environment.
05:47:30 <copumpkin> yep
05:47:37 <roconnor> so for any reasonable proof system (say higher order arithmetic) classical proofs are conservative extenstion of constructive proofs.
05:48:58 <copumpkin> nominolo doesn't believe in dependent types?
05:49:27 <roconnor> copumpkin: ... please don't import classical reasoning
05:49:38 <copumpkin> I won't :)
05:50:04 * copumpkin just postulates LEM or DNE in agda, and loses the nice safety afforded by the prop/set distinction compared to coq :D
05:50:17 <roconnor> but you have access to classical reasoning natively in constructive math.
05:50:36 <copumpkin> by double negating your statement?
05:50:43 <roconnor> more or less
05:51:07 <roconnor> it's a bit more complex than that but not a by a lot
05:51:42 <copumpkin> what are the details?
05:52:30 <fasta> Let me guess: stable formulas. 
05:52:32 <roconnor> you need to put a double negation in front of every disjunction and existential
05:54:08 <roconnor> Books will say you need to also put it in front of every atomic formula, but I would simply assume that every atomic formula is decidable.
05:56:46 <zenzike> I'm getting the following warning from ghc:   "Unfolding of Data.Vector.Unboxed.modify: Iface type variable out of scope:  s". I'm wondering if it's due to this bug (http://hackage.haskell.org/trac/ghc/ticket/4120), or if it's something else, can anyone shed some light on what might trigger that warning (obviously it's somehting to do with Vector modify, but I can't think of anything strange that I'm doing!)
06:14:15 <nominolo> copumpkin: I do believe that they can make code much harder to write.
06:14:25 <copumpkin> nominolo: oh, certainly!
06:15:03 <copumpkin> but oh-so-fun :P
06:15:36 <fasta> nominolo, writing a certified program and writing a program are also two completely different things.
06:15:48 <nominolo> I browsed through the "glaring weaknesses" in tibbe's survey and there were a few comments in the spirit "we have problem <foo>, but we probably just need more dependent types to fix it"
06:16:08 <copumpkin> nominolo: just like people claim haskell is too hard to write :) you don't get more certainty for free
06:16:22 <nominolo> fasta: right, but if your api forces you to more or less write a certified program, that doesn't help
06:16:36 <copumpkin> nominolo: oh, I agree with you there
06:16:47 <fasta> nominolo, yes, but... what exactly are you talking about?
06:17:51 <copumpkin> some people who haven't used dependent types do have a skewed idea of what they give you and at what cost
06:18:59 <fasta> copumpkin, have you developed anything big in it?
06:19:34 <copumpkin> fasta: not at all :) but even small things can be quite tedious, especially in agda with no tactics (which is what I've used, mostly)
06:21:58 <copumpkin> but I do think regular programming with dependent types is relatively unexplored and can be improved significantly
06:22:01 <nominolo> for example, using this function http://hackage.haskell.org/packages/archive/hoopl/3.8.6.0/doc/html/Compiler-Hoopl.html#v%3AfoldBlockNodesF you can't write pprintBlock :: Block n e x -> Doc
06:22:17 <nominolo> or at least not straightforwardly
06:22:57 <copumpkin> oh, so you'd like less type safety even in haskell?
06:23:14 <copumpkin> as in, that people not do crazy type-level things in their haskell code?
06:24:03 <deteego> arguing about the Haskell type system again?
06:24:14 <copumpkin> not me
06:24:23 <copumpkin> deteego: would you like to? :)
06:24:48 <Saizan> i hear oleg has proved P=NP in it
06:24:51 <deteego> copumpkin: nah I would rather code in it =D
06:25:00 <copumpkin> code in the type system!
06:25:59 <deteego> nah man Im a rebel
06:26:04 <deteego> I code outside of the type system
06:26:07 <deteego> >.>
06:26:10 <deteego> <.<
06:29:25 <jmcarthur> i think what happens with a lot of dependently typed languages right now is that people get too excited about what they can prove and place unnecessary burdens on themselves by indexing their types too much
06:29:35 <copumpkin> pff
06:30:34 <deteego> I think what makes haskell great is its a language that is strongly typed yet its not very verbose at all
06:30:44 <deteego> gives you the best of both worlds
06:30:55 <copumpkin> ooh look, it's a flying Heffalump
06:30:58 <jmcarthur> i'll be the last to tell you that stuff is pointless, but at this point in the game the costs of super-safe dependently typed programs often outweight the benefits
06:31:00 * copumpkin points up
06:31:06 <jmcarthur> *outweigh
06:31:37 <deteego> wow a winneh the pooh reference
06:31:38 <deteego> thats a first
06:32:01 <copumpkin> considering we actually do have a Heffalump up there :)
06:32:34 <deteego> that movie got a rating of 80%
06:32:37 <deteego> by rotten tomatoes
06:32:38 <deteego> wow
06:33:01 <deteego> someone must have been smoking some bad granola
06:39:32 <yaru1022> Is the only way to interact with DB in Haskell is through SQL? Is there a library/tool that does similar thing as ORM in OOP? It would be great if there's a library which can store/retrieve my algebraic data type in/from a DB. Does anyone know?
06:41:00 <pumpkin> Mac os sucks
06:43:13 <EvanR-work> yaru1022: i used hdbc for raw access to mysql
06:43:40 <EvanR-work> im not sure about object relational mapper
06:43:55 <EvanR-work> http://www.haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces
06:44:09 <EvanR-work> theres also a new channel about takusen (#takusen)
06:44:28 <earthy> pumpkin: all os's suck. that's why we have higher level libraries.
06:44:36 <jmcarthur> pumpkin: then don't use it!
06:45:07 <jmcarthur> (says the guy that was using mac for a couple days in a row because he was too lazy to pull out his linux laptop)
06:45:15 <jmcarthur> until literally five minutes ago
06:46:13 <yaru1022> EvanR-work: do you know if there's a way to extract auto-incremented id value when I run an insert query?
06:46:32 <EvanR-work> is that not in the result set?
06:47:01 <jmcarthur> what database?
06:47:07 <yaru1022> sqlite3
06:47:07 <jmcarthur> *rdbms
06:47:11 <jmcarthur> ah i have no idea
06:48:17 <jmcarthur> yaru1022: if it hadn't fallen to unmaintainance then i would have suggested haskelldb as a candidate for your ORM-like question
06:48:18 <EvanR-work> yaru1022: last_insert_id in the manual
06:48:35 <jmcarthur> although it's not an ORM
06:48:38 <jmcarthur> it's just a DSL
06:48:43 <yaru1022> EvanR-work: thanks, i'll take a look at it.
06:48:54 <copumpkin> jmcarthur: I think I just hate computers
06:49:07 <jmcarthur> me too
06:49:36 <yaru1022> jmcarthur: hm.. okay. I'll take a look at haskellDB as well. I'm just writing an application from scratch, so it would be better to use the right tool to begin with. Thanks for the suggestion.
06:50:18 <jmcarthur> yaru1022: just don't forget that i warned you that it isn't really maintained. you may have to fiddle to bring it up to speed with newer versions of GHC, etc.
06:50:37 <jmcarthur> i also don't know how efficient its query generation is or anything. all i know is that i've seen some neat example code
06:50:40 <EvanR-work> yaru1022: it goes without saying that properly accessing a database is more than being able to easily store and get individual records. but to that end you can define a type class for being able to store and retrieve data from a table
06:51:44 <EvanR-work> i find the attempts at ORM seems to miss some basic points of relational databases
06:52:20 <EvanR-work> jmcarthur: we had good performance with prepared statements in hdbc
06:52:30 <EvanR-work> though some edge cases are annoying
06:52:47 <jmcarthur> EvanR-work: i was talking about haskelldb
06:52:52 <EvanR-work> yeah
06:53:06 <EvanR-work> that deprecated thing ;)
06:53:18 <jmcarthur> oh it's actually deprecated?
06:53:25 <EvanR-work> i dont know
06:53:29 <EvanR-work> probably not
06:53:52 <jmcarthur> i think it might be abandoned
06:54:38 <EvanR-work> takusen, from barely glancing at it, seems to be something
06:55:03 <jmcarthur> i have used takusen. it's my favorite
06:55:16 <jmcarthur> takes some getting used to, but it's nice
06:55:43 <copumpkin> it even has a channel now
06:57:20 <EvanR-work> i havent seen a library yet that provides a meaningful interface to relational except sql itself. but what i do find annoying is the handling of errors, management of connections etc
06:57:34 <EvanR-work> in a low level lib like hdbc
06:58:26 <jmcarthur> those are things that must be accounted for, invariably
06:59:27 <EvanR-work> seems like takusen has something for that
07:03:01 <burp> hdbc is low level? :D 
07:03:17 <burp> might be, but there isn't anything "higher" for haskell :/
07:03:43 * hackagebot blaze-from-html 0.2.2 - Tool to convert HTML to BlazeHtml code.  http://hackage.haskell.org/package/blaze-from-html-0.2.2 (JasperVanDerJeugt)
07:03:44 <EvanR-work> haskelldb ?
07:04:48 <burp> um, that was quite unusable last time I tried it
07:05:06 <burp> in the sense that it didn't allow you many things, it was quite restrictive
07:34:08 <tibbe> nominolo, there were a few language issues mentioned, but not enough to point to any one language weakness
07:56:29 <osaunders> What's the paper with graphical representations of lambda calc?
07:56:43 <osaunders> I can't remember anything more than that.
07:58:27 <Gracenotes> well there is http://worrydream.com/AlligatorEggs/ ...
07:58:31 <jmcarthur> osaunders: http://dkeenan.com/Lambda/ ??
08:01:47 <osaunders> jmcarthur: Yes that's it
08:01:52 <osaunders> But I like Gracenotes too
08:02:09 <copumpkin> the alligator eggs thing was cute
08:02:44 <Gracenotes> mostly when reading it I was trying to come up with better explanations for *why* the alligators eat each other
08:03:00 <Gracenotes> but it's a very creative starting point
08:03:17 <kmc> that's awesome :)
08:03:24 <Gracenotes> reminds me, once I tried to come up with a way to make a game where you take the transitive reduction of a graph
08:03:45 <Gracenotes> s/the/a/
08:04:27 <Gracenotes> the simplest way to put it is: you can remove an edge iff it doesn't cause two previously connected nodes to become unconnected. even so, putting them in familiar terms is difficult..
08:05:11 <Gracenotes> it still is fun, even if you're not a graph theorist. I mean, look how popular the planar graph game became, and that doesn't bother with stories
08:06:18 <Gracenotes> uh yeah tangent
08:11:55 <h_noob> have somebody used validateCmdLine from  System.Console.GetOpt.Utils?
08:13:11 <h_noob> I don't understand why it fails to typecheck after I copied it from arch2darcs.hs
08:31:36 <Maxdamantus> Hmm.. The Haskell language itself doesn't have any number operations does it?
08:31:46 <dmwit> > "\73\32\108\111\118\101\32\72\97\115\107\101\108\108"
08:31:47 <lambdabot>   "I love Haskell"
08:31:56 <dmwit> Maxdamantus: hm?
08:32:21 <dmwit> Maxdamantus: Do you include the Prelude in "the language itself"?
08:32:27 <Maxdamantus> No.
08:32:33 <dmwit> Then no.
08:33:07 <Maxdamantus> But there exists some syntactic rules to create Integrals, .. in the language?
08:33:10 <geheimdienst> isn't the prelude part of the language standard? i mean doesn't haskell 98 / haskell prime specify the prelude?
08:33:14 <Maxdamantus> Hmm.. Same with lists.
08:33:23 <dmwit> geheimdienst: yes
08:33:37 <dmwit> Maxdamantus: yes
08:33:48 <Maxdamantus> Dunno. I think usually standards partially separate the language from the standard library.
08:34:07 <dmwit> Maxdamantus: The Haskell Report includes the Prelude, but not the standard library.
08:34:13 <Maxdamantus> Ah.
08:34:25 <dmwit> That's why I asked. =)
08:34:36 <dmwit> The Prelude is generally considered part of "the language itself".
08:34:48 <Maxdamantus> Mmm.. I see.
08:35:34 <Maxdamantus> I guess Monads and everything are the same.. Can just implement your own separate class that behaves the same way.
08:35:43 <kmc> various bits of special syntax are specified as translation to Prelude functions
08:35:55 <kmc> by default they go to Prelude no matter what
08:36:05 <kmc> but with ghc -XNoImplicitPrelude, they bind to whatever name is in scope
08:36:33 <Maxdamantus> Is that how the operators manage to work in prefix?
08:36:34 <kmc> the Haskell 98 Report includes some modules other than the Prelude
08:36:44 <kmc> Maxdamantus, that seems like an unrelated fact to me
08:37:01 <kmc> H98 includes some non-Prelude module, but does not include most of what is functionally "the standard library" today
08:37:10 <Maxdamantus> Can you define your own subclass (or whatever) of Num that has its own / operation, then apply the (/) function to that?
08:37:26 <kmc> i'm not sure what you mean
08:37:36 <kmc> if you have two functions named (/) in scope
08:37:38 <Maxdamantus> I probably don't know what I mean either.
08:37:41 <kmc> then you will get ambiguity when you use them
08:37:46 <geheimdienst> > let (/) a b = a + b in 5 / 2
08:37:46 <lambdabot>   7
08:37:50 <kmc> it is irrelevant whether one or both is a type-class method
08:39:04 <Maxdamantus> I haven't really looked into classes yes, but when I was reading the Monads "gentle introduction" it showed an example Monadic class that had a >>= function
08:39:39 <Maxdamantus> Could the prefix method (>>=) be used there, and it would figure out to apply the >>= function from that class?
08:40:04 <Maxdamantus> er, on a value of that class' type
08:40:48 <Maxdamantus> (>>=) randomMonadicTypedValue $ \_ -> return ()
08:41:12 <dmwit> Maxdamantus: (>>=) is a function; a >>= b is just special syntax for applying that function.
08:41:19 <dmwit> There is nothing special about the Monad type class here.
08:41:23 <harlekin> Where can I find very simple reactive programs? I can't find something as simple as hello world which isn't using FRP.Reactive.LegacyAdapters.
08:42:01 <dmwit> > let (+!$) = const in (3 +!$ 4, (+!$) 3 4, (3 +!$) 4, (+!$ 4) 3)
08:42:02 <lambdabot>   (3,3,3,3)
08:42:13 <Maxdamantus> Meh, I forgot what I was getting at.. I'll probably just find out later when I look into classes.
08:42:42 <EvanR-work> Maxdamantus: yes youre right. when you use a operator or function like (>>=) it magically uses the right method for that type
08:42:52 <EvanR-work> or types
08:42:55 <dmwit> > let (+!$) = const in (3 +!$ 4, (+!$) 3 4, (3 +!$) 4, (+!$ 4) 3, const 3 4, 3 `const` 4)
08:42:55 <lambdabot>   (3,3,3,3,3,3)
08:43:00 <dmwit> all different syntax for the same thing
08:43:36 <Maxdamantus> Oh, okay.
08:44:06 <EvanR-work> double + double, use double +, int + int, use int +, double + int, error
08:44:12 <EvanR-work> + requires them to be the same type
08:45:32 <Maxdamantus> I see.
08:45:48 <T_S_> @pl \f (x,y) -> (f x, f, y)
08:45:48 <lambdabot> (`ap` snd) . (. fst) . (flip =<< ((,,) .))
08:45:55 <Maxdamantus> The use stuff is implicit when defining a class with those function names?
08:47:03 <EvanR-work> eh?
08:47:38 <Maxdamantus> Hmm.. Does a class that has the + operation need to be a Num subclass or something?
08:47:49 <Maxdamantus> :t (+)
08:47:50 <lambdabot> forall a. (Num a) => a -> a -> a
08:48:02 <quicksilver> Maxdamantus: no.
08:48:10 <quicksilver> Any class can contain an operation called (+).
08:48:14 <mux> @src Num
08:48:14 <lambdabot> class  (Eq a, Show a) => Num a  where
08:48:14 <lambdabot>     (+), (-), (*)           :: a -> a -> a
08:48:14 <lambdabot>     negate, abs, signum     :: a -> a
08:48:14 <lambdabot>     fromInteger             :: Integer -> a
08:48:15 <quicksilver> however since Num already does
08:48:26 <quicksilver> you will have a scoping problem and in some cases an error
08:48:28 <Maxdamantus> So I presume then.. When I say (+) I don't necessarily mean the + operation for working on Numbers
08:48:42 <EvanR-work> if you dont import Prelude yes
08:48:45 <quicksilver> you can't usefully have two identifiers with the same name
08:48:54 <quicksilver> so if you don't want the normal (+) you can hide it
08:48:54 <EvanR-work> and everyone will hate you for redefining +
08:48:58 <quicksilver> so you can write your own.
08:49:03 <Maxdamantus> I could go: let adder = (+) .. then use adder to apply the (+) function to values of whatever class implements it?
08:49:42 <quicksilver> you can do let adder x y = (+) x y ....
08:49:58 <quicksilver> your version falls foul of the monomorphism restriction, which is just a silly language issue.
08:50:12 <Maxdamantus> Mmm.. That does seem odd.
08:50:23 <zygoloid> NoMonomorphismRestriction++
08:50:40 <quicksilver> it is odd, and I'd ignore it for now if you're still trying to grasp the other bits :)
08:53:16 * hackagebot web-encodings 0.2.6.2 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.2.6.2 (MichaelSnoyman)
08:53:20 <djahandarie> Just add an explicit type signature
08:53:22 <djahandarie> Should be done anyways
08:58:01 <NWwiqaXL> Apparently+everyone+is+up+in+arms+about+this+new+racist+Six+Flags+Atlanta+ride,+they+say+it+negatively+portrays+african+americans.+I+guess+the+name+is+a+little+bit+insensitive.+They+call+it+the+'Nigger+Experience'+and+the+ride+is:+when+you+get+in+the+parking+lot+at+the+end+of+the+day,+you+realize+that+niggers+have+broken+into+your+car+and+stolen+your+stereo.+I+don't+know+what+to+think.
08:58:02 <NWwiqaXL> Once,+when+i+was+changing+my+little+brother's+diaper,+i+jacked+him+off.+I+don't+know+what+drove+me+to+do+it,+but+I+did.+now+i+can't+stop+thinking+about+his+little+penis.+I+think+i+want+him+to+grow+up+and+fuck+me.
08:58:04 <NWwiqaXL> I+am+the+world's+foremost+expert+on+sticking+people's+treasured+items+into+my+urethra.+I+have+'gauged'+it+to+the+point+where+I+can+almost+wedge+a+piece+of+celery+in+there,+though+no+one+treasures+celery.+If+anyone+can+beat+this,+I'd+like+to+suck+their+dick!
08:58:23 <geheimdienst> @where ops
08:58:23 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
08:58:32 --- mode: ChanServ set +o copumpkin
08:59:04 --- mode: Igloo set +b *!*@gateway/web/cgi-irc/irc.wikia.com/*
08:59:12 <copumpkin> should we just leave that on from now on?
08:59:17 <hpc> yes
08:59:18 <EvanCarroll> hrm
08:59:25 <EvanCarroll> wikia.com needs to work on that.
08:59:38 <copumpkin> they're just going to use other web IRC clients though... the original attack was from freenode's own I think
08:59:42 <copumpkin> ah well
08:59:46 --- mode: ChanServ set -o copumpkin
09:00:12 <EvanR-work> i dont understand why people spam freenode
09:00:24 <EvanR-work> to remind us how crappy irc is?
09:00:28 <earthy> 'because they can'
09:00:39 <djahandarie> 'for the lulz' may also be an answer
09:00:41 <earthy> nah. that'd assume reflection on their actions
09:00:56 <geheimdienst> what's crappy about irc? i thought it was pretty okay
09:01:09 <earthy> fsvo 'okay'
09:01:27 <dmwit> IRC is popular, anyway.
09:01:31 * fryguybob normally uses freenode's web client.
09:01:34 <EvanR-work> i suppose its unathenticated, and thats a feature not a bug
09:01:50 <Wooga> what is better: overload (+) for own type or write function addOwnType x y ?
09:02:09 <geheimdienst> i don't think authentication would solve anything anyway. twitter gets spammed ...
09:02:10 <EvanR-work> define a Num instance
09:02:16 <Gracenotes> oh by the way you might want to change that to +q
09:02:35 <EvanR-work> Wooga: does your type also support subtraction ?
09:02:37 <Gracenotes> a common practice for proxies and stuff
09:02:45 <EvanR-work> negatives?
09:02:46 <Wooga> EvanR-work: yes
09:02:52 <EvanR-work> then you want a Num instance
09:02:54 <Wooga> no negarives
09:02:57 <Wooga> negatives*
09:02:58 <EvanR-work> uhm
09:02:59 <dmwit> Wooga: Does your type actually represent a number? If so, go for a Num instance.
09:03:10 <EvanR-work> subtraction but no negatives?
09:03:14 <Wooga> natural number
09:03:17 <dmwit> EvanR-work: e.g. naturals
09:03:29 <dmwit> Wooga: Why not use one of the many Naturals available on Hackage?
09:03:30 <EvanR-work> yeah......
09:03:30 <zygoloid> geheimdienst: what's crappy about irc is that there's no standard for codecs.
09:03:44 <Wooga> dmwit: oh, i am not aware of those
09:03:55 <EvanR-work> naturals arent Nums ;)
09:04:35 <EvanR-work> > pred 0
09:04:36 <lambdabot>   -1
09:04:38 <EvanR-work> :\
09:05:00 <dmwit> pred isn't part of Num, anyway
09:05:20 <EvanR-work> @src pred
09:05:20 <lambdabot> Source not found. That's something I cannot allow to happen.
09:05:27 <dmwit> :t pred
09:05:27 <lambdabot> forall a. (Enum a) => a -> a
09:05:29 <dmwit> or
09:05:31 <dmwit> ?src Enum
09:05:31 <lambdabot> class  Enum a   where
09:05:32 <lambdabot>     succ                     :: a -> a
09:05:32 <lambdabot>     pred                     :: a -> a
09:05:32 <lambdabot>     toEnum                   :: Int -> a
09:05:32 <lambdabot>     fromEnum                 :: a -> Int
09:05:33 <EvanR-work> oh
09:05:37 <lambdabot> [3 @more lines]
09:06:19 <hpc> @more
09:06:19 <lambdabot>     enumFrom                 :: a -> [a]
09:06:19 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
09:06:19 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
09:06:53 <EvanR-work> what interfaces can naturals support?
09:06:56 <hpc> what on earth are those last functions?
09:07:10 <EvanR-work> > [1..4]
09:07:11 <lambdabot>   [1,2,3,4]
09:07:19 <EvanR-work> > [1..]
09:07:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:07:33 <djahandarie> > enumFrom 1
09:07:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:07:34 <geheimdienst> > enumFrom 5
09:07:35 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3...
09:07:37 <hpc> oh, i see
09:07:43 <geheimdienst> > enumFromThenTo 5 2 12
09:07:43 <lambdabot>   []
09:07:49 <geheimdienst> > enumFromThenTo 5 1 12
09:07:50 <lambdabot>   []
09:07:52 <djahandarie> > enumFromThen 1 3
09:07:53 <EvanR-work> > [1,2..]
09:07:53 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
09:07:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:08:05 <geheimdienst> > enumFromThenTo 5 7 12
09:08:06 <lambdabot>   [5,7,9,11]
09:08:07 <djahandarie> I never knew those existed
09:08:17 <EvanR-work> > [0,3.14..99.99]
09:08:17 <lambdabot>   [0.0,3.14,6.28,9.42,12.559999999999999,15.699999999999998,18.83999999999999...
09:08:22 <EvanR-work> \o/
09:08:44 <djahandarie> > enumFromThen 0 pi
09:08:45 <dmwit> > [0.5, 1.5 .. 12]
09:08:45 <lambdabot>   [0.0,3.141592653589793,6.283185307179586,9.42477796076938,12.56637061435917...
09:08:46 <lambdabot>   [0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5]
09:08:53 <dmwit> surprise!
09:09:01 <djahandarie> lol
09:09:03 <EvanR-work> i noticed that
09:09:07 <dmwit> > [0.5, 1.5 .. 2] -- similar
09:09:08 <lambdabot>   [0.5,1.5,2.5]
09:09:20 <EvanR-work> thats crap
09:09:21 <djahandarie> Is that due to floats?
09:09:26 <dmwit> > round 12.5 -- yes
09:09:27 <lambdabot>   12
09:09:40 <dmwit> > round 13.5 -- well, sorta
09:09:40 <geheimdienst> > round 12.51
09:09:41 <lambdabot>   14
09:09:42 <lambdabot>   13
09:09:47 <quicksilver> well, floats plus a surprising (?) definition in the report.
09:09:55 <dmwit> > round 13.5 -- you see, there's this thing called Banker's rounding
09:09:56 <lambdabot>   14
09:10:11 <dmwit> > round 14.5 -- that deals with round-off error in human calculations
09:10:12 <lambdabot>   14
09:10:21 <djahandarie> Is it seriously using Banker's rounding?
09:10:24 <Maxdamantus> > 0.4 + 0.2
09:10:25 <lambdabot>   0.6000000000000001
09:10:25 <dmwit> yep!
09:10:36 <EvanR-work> what the hell
09:10:36 * Maxdamantus wonders how wide these floats are O_o
09:10:41 <hpc> > (round 12.5, round 13.5) -- it really is terrible at rounding
09:10:42 <lambdabot>   (12,14)
09:10:46 <dmwit> Maxdamantus: They're Double wide.
09:10:52 <dmwit> Maxdamantus: except the ones that are infinitely wide
09:11:00 <dmwit> > pi :: CReal
09:11:00 <lambdabot>   3.1415926535897932384626433832795028841972
09:11:20 <Maxdamantus> That pi looks all right
09:11:22 <djahandarie> @src pi
09:11:22 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:11:30 <Maxdamantus> Rounded up at the last dp
09:11:44 <Maxdamantus> 41971693993..
09:11:52 <Maxdamantus> Oh, CReal
09:11:54 <EvanR-work> > pi :: Double
09:11:54 <lambdabot>   3.141592653589793
09:12:17 <EvanR-work> > pi :: Float
09:12:18 <lambdabot>   3.1415927
09:12:22 <dmwit> > pi - 3.1415926535897932384626433832795028841972 :: CReal
09:12:23 <EvanR-work> > pi :: Int
09:12:23 <lambdabot>   0.0
09:12:23 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
09:12:24 <lambdabot>    arising from a use of...
09:12:26 <EvanR-work> lol
09:13:16 <Maxdamantus> @src (:)
09:13:16 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:13:23 <EvanR-work> @src []
09:13:24 <lambdabot> data [] a = [] | a : [a]
09:13:47 <Maxdamantus> @src (>>=)
09:13:47 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:14:00 <dmwit> :t showCReal
09:14:01 <EvanR-work> (>>=) depends on the instance
09:14:01 <lambdabot> Int -> CReal -> String
09:14:15 <dmwit> > showCReal 200 (pi - 3.1415926535897932384626433832795028841972)
09:14:16 <lambdabot>   "-0.00000000000000000000000000000000000000003060062489417902505540769218359...
09:14:36 <hpc> would it be a simple thing to index value constructors in @src as well as type constructors?
09:14:39 <dmwit> > showCReal 200 (pi - 3.141592653589793238462643383279502884197)
09:14:40 <lambdabot>   "0.000000000000000000000000000000000000000169399375105820974944592307816406...
09:14:56 <dmwit> hpc: ?src is pretty darn simple.
09:15:00 <dmwit> ?where state
09:15:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/State/
09:15:15 <dmwit> Open up "source" there.
09:15:16 * Maxdamantus can recite further than that
09:15:21 * dmwit too
09:15:31 <EvanR-work> arent you all special
09:15:41 <Maxdamantus> Only just though.. The 8164062816 whatever is too confusing :\
09:15:44 <hpc> i see what looks like a .db file
09:16:07 <dmwit> hpc: zcat it
09:16:17 <quicksilver> I would rather @src was completely removed.
09:16:35 <quicksilver> Perhaps replaced by something intelligent based on haddock's index or hoogle's index which gives weblinks to the online copy of the source.
09:17:28 <hpc> so dons is the developer for lambdabot?
09:18:12 <Samy> no
09:18:21 <hpc> oh i see, it's lots of people
09:18:27 <Samy> yes
09:18:33 <Samy> shapr did the plugin system tho, iirc
09:19:48 <hpc> AUTHORS says that was dons too
09:20:02 <hpc> he seems to have done most of the bot work
09:20:16 <hpc> with maybe 8 other people contributing one or two modules
09:21:10 <fasta> hpc, author files are also not completely accurate all the time.
09:22:38 <fxr> hmm is javascript AST a mutually recursive datatype? expressions uses statements and statements uses expressions...
09:23:59 <roconnor> > showHex 5 ""
09:24:00 <lambdabot>   "5"
09:25:48 <Samy> > showHex 16 ""
09:25:48 <lambdabot>   "10"
09:27:37 <EvanR-work> fxr: tried ##javascript? ;)
09:27:51 <Maxdamantus> The syntax tree for pretty much any high level language that people use is like that O_o
09:28:20 <fxr> EvanR-work: what's that?
09:28:28 <EvanR-work> a channel
09:29:02 <fxr> nope, haven't tried yet :)
09:30:44 <quicksilver> I'm sure the people in ##javascript do not know if the javascript AST is naturally modelled by a recursive datatype.
09:30:57 <quicksilver> In fact, I'm sure they do not know what "AST" or "recursive" or "datatype" mean.
09:31:07 <Phyx-> ^_^
09:31:09 <quicksilver> possibly not "naturally" or "modelled" either :P
09:31:13 <fxr> :(
09:31:21 <djahandarie> Do those words involve jQuery?
09:31:33 <quicksilver> fxr: yes, C-like languages traditionally distinguish statements and expressions but have some recursion between them.
09:31:47 <djahandarie> I hear they were renaming ##javascript to ##jquery
09:32:16 <fxr> I wonder if it is possible to define js syntax using higher order fixed points 
09:32:29 <quicksilver> fxr: I don't think you can put a statement inside an expression except via "function () { ... }"
09:32:46 <quicksilver> ..but that is a way, so that does make them mutually recursive.
09:33:28 <fxr> quicksilver: yeah I got only one case "FuncExpr a (Maybe (Id a)) [(Id a)] (Statement a)" which breaks Expr
09:34:30 <quicksilver> fxr: breaks it?
09:34:47 <c_wraith> What's the termination condition for loeb?  What property do the functions passed in need to satisfy for loeb to terminate?
09:35:33 <fxr> I mean the recursive position refer to Stmt, not Expr...
09:36:13 <quicksilver> fxr: yes but why does that break anything?
09:36:21 <quicksilver> fxr: mutual recursion is not generally a problem
09:36:33 <quicksilver> although it's simplest if you define mutually recursive types in the same module.
09:36:55 <Philippa> most of the time they're conceptually 'one thing' anyway
09:37:15 <fxr> it's a problem because I'm unable to use first order Fix to tie recursive positions
09:38:06 <luite> any happstack devs here? I'm following the crash course, but it describes the current darcs version. is it already advisable to run that version, or should I stick to 0.5.0.2 for now?
09:38:08 <Philippa> you need a 'type-level record' or at least tuple, you take the fixpoint of that and make your recursive references through it
09:38:33 <osaunders> @hoogle fix
09:38:33 <lambdabot> Data.Function fix :: (a -> a) -> a
09:38:33 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
09:38:34 <lambdabot> module Control.Monad.Fix
09:38:49 <quicksilver> fxr: why are you trying to do it with type-level Fix rather than by simplistic recursion?
09:39:11 <djahandarie> Real men use type-level programming
09:39:24 <fxr> quicksilver: because I'll add annotations to the structure generically
09:39:45 <Philippa> I have to admit, I wish the type-level fix approach was easier to use in general for much the same reason
09:39:59 * quicksilver nods
09:40:03 <Philippa> sometimes I'm not just adding annotations but also extensions of the datatype by eg replacing the fixpoint, too
09:40:15 <quicksilver> fxr: fair enough. I was just checking you had a good reason ;) 
09:40:53 <fxr> ok, back to the additional type index...
09:41:45 <fxr> sfvisser explaining higher order fixed points for GADTs
09:42:19 <tolkad> Why is source a broken link? http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html#t%3AIO
09:42:46 <tolkad> nevermind, found the file using google
09:43:24 <tolkad> I'm looking for instance Monad IO, anyone know where the source of that is?
09:44:47 <Philippa> no, but I'm pretty sure it's uninteresting
09:45:03 <Philippa> IIRC it pretty much delegates to compiler internals straight off
09:45:55 <tolkad> Philippa: I'm wondering how it ensures that >>= makes stuff happen in sequence
09:46:11 <tolkad> Philippa: I'm not sure how you would do that in haskell code
09:46:21 <Philippa> magic. Whether the magic's called 'seq' or 'bind#' doesn't really matter
09:46:38 <tolkad> well it has to be written using standard haskell
09:46:42 <Philippa> no, it doesn't
09:46:48 <Maxdamantus> The way I've interpreted it is that the putStrLn function etc doesn't actually print the stirng.
09:47:19 <quicksilver> tolkad: it's written in GHC
09:47:31 <quicksilver> tolkad: which is an impure language vaguely resembling haskell
09:47:39 <quicksilver> the instance is here : http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-ST.html
09:47:44 <quicksilver> but it's pretty meaningless.
09:47:52 <Philippa> and GHC can expose compiler internals including magical functions that just do the right thing
09:47:53 <quicksilver> (in GHC IO is just ST RealWorld#)
09:48:17 <quicksilver> in particular, it relies on evaluation of side-effects in a totally non-haskell-like way
09:48:33 <tolkad> what's RealWorld#?
09:48:38 <quicksilver> (in order to give a perfectly clean monadic interface on the outside)
09:48:43 <quicksilver> tolkad: some meaningless token
09:49:04 <quicksilver> to trick the compiler into generating correct code
09:49:07 <quicksilver> (FSOV 'trick')
09:49:10 <tolkad> that's a terrible way to do it IMO
09:49:16 <quicksilver> OK.
09:49:33 <tolkad> they should write it in standard haskell
09:49:37 <Maxdamantus> Hmm.. So in GHC, the putStrLn function actually does start printing something?
09:49:37 <quicksilver> it's not possible.
09:49:43 <quicksilver> you cannot write IO in standard haskell.
09:49:56 <Philippa> tolkad: how the hell do you cause a real world effect in standard haskell /without/ the primitives in the Prelude?
09:49:56 <quicksilver> you have to have primitives somewhere.
09:50:02 <tolkad> well if you can't write something in standard haskell then don't try
09:50:19 <Philippa> hell, how do you do that in /any/ language?
09:50:32 <Philippa> (hint: even in C, you wouldn't be able to fudge a native call convention)
09:50:34 <roconnor> POKE
09:50:35 <tolkad> Philippa: In C you write to some magic memory address
09:50:41 <tolkad> sometimes
09:50:50 <Philippa> sure, but that doesn't get you the general case
09:51:14 <Maxdamantus> C doesn't even have system calls anywhere.
09:51:31 <Philippa> you might be able to poke, but you can't jump
09:51:51 <Maxdamantus> Is causing undefined behaviour (such as a possible segfault) counted?
09:51:58 <Philippa> it's undefined :p
09:52:11 <Maxdamantus> Wait.. What about just return from main?
09:52:26 <Philippa> you can't implement return in C either :-)
09:52:35 <Maxdamantus> It's part of the language.
09:52:53 <Philippa> well yes. That's kinda the point. Just as the basic IO monad implementation is part of Haskell
09:53:01 <tolkad> and some stuff could by define in standard haskell but they chose not to
09:53:04 <tolkad> defined*
09:53:05 <tolkad> like Int
09:53:14 <Philippa> yes, and with good reason
09:53:20 <Maxdamantus> Hmmm.. I just learned that Haskell binds tighter to its prelude than C does to any libraries.
09:53:29 <tolkad> nah, they should have written Int in standard haskell
09:53:47 <Maxdamantus> The C standard is mostly separated into the language and the standard library, and you can perfectly well use the language without the standard library.
09:54:24 <Philippa> Maxdamantus: well duh. That's what happens when some of your constructs are exposed in a pleasant way rather than as built-in syntax
09:54:44 * Maxdamantus sleeps
09:56:07 <tolkad> Philippa: it would be kind of cool though for a language to only expose magic through syntax, especially if this language had simple syntax
09:56:51 <Philippa> not really, that just forces you to make the effort to lift the syntax up into first class functions
09:57:02 <Philippa> which is called tedious
09:57:38 <roconnor> @wiki IO_Semantics
09:57:38 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
09:57:53 <roconnor> ^ A more natural definition of IO IMHO
09:58:55 <luite> Not in scope: `Blaze.renderHtml' -- When installing happstack 0.5.1 from darcs. is some specific version of blaze-html required?
09:59:12 <Philippa> an implementation using BuiltIn# primitives can be rendered identically by the compiler if it's got no way to optimise it
10:05:58 <Phyx-> so i'm "borrowing" stuff from leksah again. which one of these do you guys think should be on by default? http://phyx.pastebin.com/fAJmupfn
10:07:20 <hpc> that's the unicode translation?
10:07:47 <luite> I want a snowman instead of <$>
10:08:01 <Phyx-> hpc: yup, view only
10:08:09 <hpc> i would say leave the top few as ascii
10:08:20 <hpc> i absolutely hate single-width (->)
10:08:37 <hpc> lambda can be fancied up
10:08:45 <hpc> don't do anything with $
10:08:48 <Phyx-> hpc: what do you mean single-width (->)?
10:08:57 <hpc> i mean the unicode arrow
10:09:07 <hpc> it's one character, so it shows up single-width in monospace
10:09:15 <Phyx-> yes, but i account for that
10:09:25 <hpc> oh, you make the arrow bigger?
10:09:41 <Phyx-> i'll add whitespace, so the layout doesn't get screwed up, and i slightly increase the size too
10:10:20 <hpc> well if it isn't any smaller than the ascii arrow, that's fine
10:10:23 <hpc> same with =>
10:10:35 <hpc> forall and exists can be made unicode
10:10:44 <hpc> as well as the greek characters
10:11:30 <hpc> i would also add "partial" for that freaky partial derivative symbol
10:11:56 <Phyx-> one sec, let me change them
10:12:28 <mreh> hello all
10:12:33 <Phyx-> well, yeah, any replacement will retain the same width. i measure the width of the string that was supposed to be rendered and take it into account
10:12:38 <Phyx-> hi mreh 
10:12:50 <mreh> it's good to be back
10:13:19 <luite> jaspervdj: is there currently a way to install a working happstack + blaze from darcs?
10:13:25 <Phyx-> it's good to have you back :)
10:14:59 <mreh> now I'm faced with a conundrum, decoding recursive haskell syntax
10:15:31 <mreh> this is value recursion
10:15:57 <mreh> and I understand it gets translated into something in terms of fix (or mfix in a do)
10:16:04 <mreh> but I have no idea how
10:16:54 <EvanR-work> :t mfix
10:16:55 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
10:17:00 <byorgey> mreh: decoding in what context?
10:17:14 <EvanR-work> @src MonadFix
10:17:14 <lambdabot> class (Monad m) => MonadFix m where
10:17:14 <lambdabot>     mfix :: (a -> m a) -> m a
10:17:26 <mreh> byorgey: working out the semantics
10:17:35 <byorgey> mreh: and I don't think value recursion actually gets translated into applications of fix.  Although I could probably explain to you how to do so.
10:17:51 <byorgey> oh, ok.
10:18:17 <mreh> "let c = f a c" <- what does that mean in practice?
10:18:34 <mreh> if f is not strict can I get at c?
10:18:51 <jaspervdj> luite: Erm, 2 secs
10:18:58 <c_wraith> if f is strict, that's _|_
10:19:15 <byorgey> mreh: you can translate that to   fix $ \c -> f a c
10:19:17 <luite> byorgey: are you still working on a new version of diagrams? I could use a high level graphics library for my web app, but I can't use any of the cairo output formats
10:19:36 <c_wraith> err, sorry. if f is strict in the second argument.  It could be strict in the first and non-strict in the second, and be fine
10:19:44 <dcoutts_> luite: what output format do you need?
10:20:10 <byorgey> luite: I am still working on it in theory and intention.  In practice I have not had time to work on it in a while.
10:20:13 <McManiaC> are there jQuery bindings for haskell or is there sth similiar?
10:20:35 <luite> byorgey: it's very unfinished, but you can see some samples here if you want: http://80.126.200.96:8081/weblog/tryhaskell.mod/ , it's basically try haskell with some additions (and a major rewrite of most components), try  > plot1   > mandel2  > set11 > set10 
10:20:50 <byorgey> mreh: so you can also think of it as  f a (f a (f a (f a ... )))
10:20:57 <jaspervdj> luite: http://groups.google.com/group/happs/browse_thread/thread/3455d1b00c06f8c/1b4b96c0dcb79174?lnk=gst&q=blazehtml#1b4b96c0dcb79174
10:20:58 <c_wraith> McManiaC, what would "something similar" even mean?  jQuery is very browser-oriented.
10:21:42 <luite> dcoutts_: see the url above. I use Raphael to draw the graphics (and an unsavePerformIO hack to write out the required png files), so I need javascript code
10:21:58 <c_wraith> McManiaC, do you mean something xpath-like?
10:22:00 <byorgey> luite++
10:22:11 <byorgey> luite: that is sweet!
10:22:21 <mornfall> Was there a flip fmap somewhere (in applicative)?
10:22:26 <EvanR-work> haskell can run in the browser??
10:22:35 <c_wraith> :t (<**>)
10:22:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
10:22:39 <luite> byorgey: I want to make it more interactive, so that it should be possible to do basic things similar to the wolfram demonstrations projects
10:23:01 <byorgey> luite: right, wolfram demonstrations was what it immediately reminded me of
10:23:21 <mornfall> c_wraith: Thx.
10:23:52 <c_wraith> mornfall: ?
10:24:00 <byorgey> mornfall: no, there isn't.  there was a thread on libraries@ a bit ago about adding one, IIRC
10:24:13 <byorgey> I think the decision was not to add it.
10:24:40 <luite> EvanR-work: it calls a fastcgi program that evaluates the haskell code
10:24:41 <mornfall> c_wraith: Sorry I discovered my mistake already. :D
10:24:54 <mornfall> c_wraith: Yeah, <$$> was my first try though.
10:25:14 <byorgey> luite: so what would you need from the diagrams library in order to be able to use it?
10:25:26 <c_wraith> Oh, yeah.  <**> wasn't quite what you were looking for.
10:25:53 <luite> EvanR-work: but I'm rewriting the web service to use happstack instead, so that I can store the state for each user (users can add their own definitions in the console)
10:27:02 <byorgey> luite: just a nitpick, the "Show types" button shouldn't show a little check mark when it is not turned on.
10:27:10 <byorgey> in fact I don't know why it needs a check mark at all =)
10:27:14 <McManiaC> c_wraith: hmmm let me take a look
10:27:46 <mornfall> Ended up with >>= return . foo
10:27:49 <luite> byorgey: basically a way to output my own type of graphics (javascript). SVG might work, but it's probably much harder to add interactivity (and IE doesn't support it natively)
10:28:08 <luite> byorgey: I added it because someone else complained that it wasnt clear that that button is a toggle button
10:28:09 <McManiaC> ">>= return . foo" is "foo `fmap`"
10:28:10 <McManiaC> ^
10:28:34 <mornfall> McManiaC: Right, and since flip fmap can't be written nicely and the ordering is much more natural....
10:29:25 <mornfall> (Or maybe it isn't. But it definitely seems it is, to me... :)
10:30:32 <zygoloid> McManiaC: technically it's "foo `liftM`" :p
10:31:00 <aavogt> mornfall: you like reading left to right with right-to-left words stuck in the middle?
10:31:00 <McManiaC> well... :)
10:31:21 <mornfall> aavogt: Actually it doesn't have a . in it.
10:31:45 <imc> hello!
10:31:46 <aavogt>  mornfall | Ended up with >>= return . foo
10:31:50 <aavogt> it's something else then?
10:32:53 <mornfall> Well, >>= \x -> return ...
10:32:55 <luite> byorgey: I already have a simple low level library to generate the javascript, but Raphael is strange when it comes to transformations x.scale(0.5).scale(0.5); is the same as x.scale(0.5);
10:33:09 <imc> i've got another problem :P  (type classes... i will get them one day!) (1) class Term_ t where freeVars :: t -> [Variable] (2) data Variable = Variable Identifier (3) data Function 
10:33:14 <imc> ups
10:33:50 <imc> ... (3) data Function = Function Identifier [Term] (4) instance Term_ Variable where [...] (5) instance Term_ Function where
10:34:06 <imc> in (5) i define freeVars in terms of concatMap freeVars terms
10:34:22 <imc> ghci says i must write an instance of Term_ Term 
10:34:39 <imc> (also i've got data Term = forall t . Term_ t => Term t)
10:34:47 * BMeph weeps for the abandoned hpaste.org -- poor, poor, hpaste.org ...
10:34:48 <luite> jaspervdj: thanks, but the problem is that the current darcs version of happstack doesn't even compile, because of some changes in blaze-html
10:36:19 <EvanR-work> maybe should understand the relatively simple concept of type classes before writing a scheme interpreter? ;)
10:36:19 <imc> code @ http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28757#a28757
10:36:38 <EvanR-work> not that its required
10:37:02 <imc> EvanR-work: yes... but isn't the best way of understand something to actually try it / break his head upon it?
10:37:12 <byorgey> luite: ok, got it.  Yes, diagrams should be nice for that (once it is in a usable state) as it is very easy to add new backends
10:37:28 <byorgey> luite: I hope to work on it more soon.
10:37:44 <luite> byorgey: the new version right? the old one looks tied to cairo
10:37:52 <byorgey> luite: right, the new version
10:38:13 <byorgey> I am only making critical bug fixes to the old version at this point
10:38:24 <imc> what i need is 1. type hierarchy (cannot do with data / union, afaik) and 2. method dispatching (that's what type classes are for if i understood correctly)
10:38:26 <byorgey> and I don't know of any critical bugs =)
10:40:11 <Wooga> hello, can i somehow disable echoing symbols when in NoBuffering [stdin,stdout] mode, like in this program simple: http://codepad.org/uENP7mBq ?
10:40:47 <imc> EvanR-work: so... if I have an instance of X A, can I assume that if somewhere i require an X a I can use an A instead? or i'm completely wrong?
10:42:47 <Wooga> aha, SetEcho stdin False does that
10:42:48 <luite> byorgey: I'd like to add interactivity by adding animations and making shapes clickable (maybe with a mouseover action) or possibly draggable. Interactivity will be limited a little since the haskell runs on the server of course. Do you think it would be possible to do that with a new backend for diagrams 2.0?
10:43:01 <imc> ok now it compiles, i added an instance of Term_ Term where freeVars = freeVars
10:43:38 <lispy1> ski: Do you have a reference with respect to indexed monads and composable continutations?
10:44:57 <Philia> Hi guys, I was wondering if anyone on here would be able to help me. I've got a Maths project on Line Arrangements (http://en.wikipedia.org/wiki/Arrangement_of_lines) and was looking to model them in Haskell. I was thinking of going down a Graph Theory based route. Any ideas?
10:48:24 <tolkad> I'm trying to figure out how to use parsec. Let's say I have a parser, x, which fails on space characters. I want to define a new parser which runs x but stops at the first space character instead of failing, without modifying x. How could I do this?
10:49:02 <Philippa> does x /only/ fail on space?
10:49:27 <tolkad> nah it might fail on other stuff too
10:49:48 <tolkad> in which case it really should fail
10:50:06 <tolkad> if this is impossible that's fine, I'd just like to know if it is
10:50:32 <tolkad> well, impossible without parsing twice
10:51:08 <Philippa> okay, so you want to run, repeatedly: "if lookahead is space, quit and return something. Otherwise, behave as x and then loop"?
10:51:25 <Philippa> one of the funcs'll let you do a lookahead without consuming, I think it's in the Prim module
10:52:04 <tolkad> I don't know what you mean by "and then loop"
10:52:49 <zygoloid> gotSpace <- try (char ' ' >> return True) <|> return False)
10:53:03 <Philippa> pick whatever way you want to indicate to whatever harness you put around it that it should iterate
10:53:11 <Philippa> return an Either, for example
10:53:20 <Philippa> zygoloid: there's a better way to write it
10:53:59 <zygoloid> i don't doubt it :)
10:54:11 <tolkad> zygoloid: but I would have to put that inside x... wouldn't I?
10:54:46 <Philippa> okay, I take that back, can't find the func in the manual. I might've been thinking of notFollowedBy
10:54:58 <Philippa> tolkad: no, you run it before you run x
10:55:07 <Philippa> gotSpace <|> x <|> ...
10:55:15 <tolkad> but x isn't just one character
10:55:20 <Philippa> so?
10:55:32 <Philippa> oh, right, it stops if there's one inside x
10:55:36 <Philippa> but x fails on spaces
10:56:11 <zygoloid> tolkad: what does it mean for a parser to run x but stop at the first character?
10:56:19 <zygoloid> *first space character
10:56:25 <zygoloid> what should the result be in that case?
10:56:36 <Philippa> so you want to consume whatever x would consume, leaving yourself at the space, and then return some default?
10:56:48 <Philippa> x <|> gotSpace >> return ...
10:57:22 <zygoloid> i don't think you can do this without modifying x.
10:57:25 <Philippa> note the lack of try, and I'm assuming x doesn't have an outer try either
10:57:28 <tolkad> let's say x is defined as many1 letter
10:57:36 <Philippa> then x doesn't fail on space
10:57:39 <Philippa> it just stops there
10:57:43 <tolkad> oh, space is a letter?
10:57:45 <zygoloid> no
10:57:54 <Philippa> no, many1 doesn't fail when it reaches a different token
10:57:58 <tolkad> oh
10:58:02 <ksf_> how does ghc decide instance ordering when it comes to incoherent instances?
10:58:08 <ksf_> I'd like to choose the second.
10:58:09 <Philippa> how would it be any use if it did?
10:58:16 <zygoloid> many1 only fails if the first token doesn't match (it needs at least one)
10:58:20 <ksf_> or, at least, try to choose it to see if it works.
10:58:35 <zygoloid> ksf: it chooses the first iirc ;)
10:58:52 <ksf> yes. it does. it in fact even says so.
10:58:58 <ksf> but how does it decide which is the first?
10:59:02 <tolkad> I'm wondering if I can sort of pipe parsers together
10:59:08 <tolkad> without parsing twice
10:59:16 <Philippa> almost certainly
10:59:30 <Philippa> the question is, can you tell us the behaviour of those parsers accurately enough?
10:59:49 <ksf> it should, to be precise, take the least general, that is, the more specific one.
11:00:13 <Philippa> yeah, in the absence of that it'll do whichever it does of fail or pick arbitrarily
11:01:01 <ksf> regular grammars are closed under union, intersection, difference, concatenation and even reversal.
11:01:11 <zygoloid> ksf: that's what overlapping instances does.
11:01:14 <ksf> (it's hard to find a thing they're not closed under)
11:01:36 <ksf> ...it wants to pick the most general one.
11:01:42 <ksf> ...that's the wrong one from my pov.
11:01:54 <zygoloid> no, overlapping instances wants to pick the most specific one.
11:02:12 <ksf> yeah but incoherent doesnt'.
11:02:25 <zygoloid> correct. if you don't want that, why are you turning on incoherent instances?
11:02:40 <tolkad> ok, so what about this: x = do {l <- (letter; x <|> eof); return l}
11:02:41 <ksf> I'm not. but ghc says that it can choose one if I turn it on.
11:02:48 <ksf> problem being, it'd choose the wrong one.
11:02:50 <tolkad> err wait that's invalid
11:02:51 <tolkad> uh
11:03:01 <tolkad> ok, so what about this: x = do {l <- do{letter; x <|> eof}; return l}
11:03:11 <tolkad> no wait that doesn't work either
11:03:30 <int80_h> what does marshalling mean?
11:03:31 <zygoloid> ksf: do you want ghc to delay the decision until it knows the actual types involved?
11:03:44 <zygoloid> (that is, until it can pick the right instance for itself)?
11:03:46 <tolkad> this monad stuff is very confusing
11:03:52 <ksf> but then I guess if oleg could have written a type eq for nonground types then he would have done so.
11:04:45 <ksf> the thing I'd like ghc to do is to specialise the type I'm querying the list with to the concrete type in the list.
11:04:52 <ksf> that is, do proper unification.
11:05:11 <ski> lispy1 : not sure whether i've seen the term "indexed monad" anywhere else than here, but "Monads and Composable Continuations" by Philip Wadler in 1994-01 at <http://homepages.inf.ed.ac.uk/wadler/papers/composable/composable.ps> discussed the composable continuation indexed monad in section 3.6. (Danvy and Filinski Types)
11:05:21 <ksf> typeCast can do that, but I can't use typeCast to generate a bool to distinguish unifiable and non-unifiable cases.
11:05:24 <lispy1> ski: thanks!
11:05:26 <tolkad> oh, I got it
11:05:49 <ClaudiusMaximus> int80_h: here's an example, brief description but marshal seems to mean "put into memory in a defined layout" http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Foreign-Marshal-Utils.html#v%3Anew
11:06:03 <ksf> ...if you try to get a bool out of typeCast, you're bound to reimplement typeEq.
11:06:11 <tolkad> x = do{s <- many1 lettter; eof; return (s)}
11:06:31 <tolkad> now I want x to stop before a space rather than failing
11:06:46 <tolkad> without modifying it, defining a new parser that is
11:06:50 <tolkad> involving x
11:06:58 <ski> (lispy1 : and there's some relevant papers referenced by that too, i believe)
11:07:16 <lispy1> ski: thanks.  This should be enough for now to get me going :)
11:07:51 <Philippa> tolkad: you're screwed
11:08:13 <Philippa> no parser you want to be compositional should talk about eof, you should leave that to a top-level harness
11:08:35 <Philippa> (note re the earlier statement that eof doesn't belong to the class of regular languages)
11:08:41 <tolkad> oh
11:08:57 <Philippa> if you have access to the relevant code, refactor appropriately
11:09:12 <tolkad> I haven't written it yet, I'm trying to understand this better
11:09:13 <Philippa> if you don't, ask for it to be carried out for you - it's the work of all of five minutes
11:09:39 <Philippa> okay, you'll find things work better if you forget about eof until you finally need it. The fact you had to insert it to find an interesting case should tell you something
11:09:44 <Philippa> and I'm heading off, I'm afraid
11:09:55 <ski> (.. imo, it would be better if one couldn't express `eof' as a parser)
11:10:39 <tolkad> oh! I understand how I'm supposed to write this sort of stuff now
11:10:44 <Philippa> ski: yeah, but you'd have to remove negation from Parsec entirely - otherwise it's notFollowedBy anyChar
11:10:55 <zygoloid> isn't that how it's actually defined? :)
11:11:02 <Philippa> zygoloid: exactly
11:11:11 <quicksilver> notFollowedBy is a bit of a nasty one
11:11:14 <tolkad> I define x as x = many1 letter
11:11:15 <ski> Philippa : yeah, negation is the real problem
11:11:17 <quicksilver> it's buggy anyway IIRC.
11:11:28 <Philippa> it gives erroneous error messages, certainly
11:11:33 <Philippa> anyway, *gone*
11:11:56 <tolkad> then I do my other parser as other = do {s <- x; space <|> eof; return (s)}
11:12:09 <BMeph> "x | space", maybe?
11:12:31 <BMeph> "x <|> space", rather?
11:12:51 <tolkad> Philippa: <|> eof is safe, isn't it?
11:13:01 <zygoloid> tolkad: can 'x' ever parse a space?
11:13:12 <ski> tolkad : <Philippa> anyway, *gone*
11:13:14 <tolkad> zygoloid: it shouldn't be able to
11:13:19 <tolkad> oh
11:13:36 <zygoloid> if x fails, you could grab everything up to the next space, and rerun x on just that.
11:13:50 <tias> there are quite a few existing formats that use eof to terminate tokens, and even allow certain short forms in the even of eof (that would not be valid otherwise)
11:14:19 <zygoloid> tias: this is Parsec's eof (meaning end of input) not an EOF character
11:14:50 <tolkad> there is no EOF character
11:14:55 <ski> > '\04'
11:14:56 <lambdabot>   '\EOT'
11:15:05 <zygoloid> tolkad: there is in MS DOS.
11:15:25 <tias> and in ascii IIRC
11:15:42 <int80_h>  ClaudiusMaximus : thanks :)
11:15:47 <tolkad> in languages like C, function slike getchar return something larger than an int
11:15:49 <zygoloid> tias: i guess you could also mean a lisp-like language which implicitly closes all open parens on EOF
11:15:51 <tolkad> err than a byte
11:16:05 <zygoloid> that would be a legitimate use of eof i suppose
11:16:09 <tolkad> and then define EOF as a number outside the range of a byte
11:16:34 <tias> zygoloid: thats what i was refering to; original HTML allows the same
11:17:05 <tolkad> zygoloid: is that what you meant? or does MS DOS actually have a byte value signifying EOF?
11:18:39 <zygoloid> tolkad: no, i meant, for instance, when reading from a terminal in raw mode, that you get an input sequence representing an EOF
11:19:01 <zygoloid> some bytestream encodings have a byte sequence which means 'end of file'
11:19:22 <zygoloid> but that's irrelevant since it's not what tias meant ;)
11:22:12 <mjrosenb> how should i determine if a file exists currently?
11:22:32 <quicksilver> System.Directory.doesFileExist?
11:23:06 <ksf> It's somewhat disenchanting that I'm trading all forms of serious polymorphism when I go for heterogeneously typed TChans.
11:23:29 <mjrosenb> quicksilver: i suppose there is a good reason that is in System.Directory
11:23:51 <ksf> ...as the motivating idea was to ease abstracting by composing handlers into one chan and not have to deal with gazillions of individual ones.
11:24:07 <quicksilver> mjrosenb: whether a file exists is a property of the directory it's in
11:24:19 <quicksilver> mjrosenb: this is not an entirely un-traditional way of segmenting file operations
11:24:24 <quicksilver> although I can see it might be surprising.
11:25:12 <ksf> but as soon as I look up anything by type, the types have to be ground, on both sides or unification hits the fan, somewhere.
11:26:55 <monochrom> what happens when the type hits the fan?
11:27:08 <monochrom> you get type splices.
11:27:18 <ksf> ghc wants me to enable incoherentinstances but even then would choose the wrong instance.
11:27:43 <ksf> it's just not smart enough to unify stuff when doing TypeEq
11:38:09 <ksf> it's not even typeEq per se.
11:39:41 <ksf> as soon as there are overlapping instances like Foo a a' and Foo a a GHC refuses to decide between "yes, they're equal because unifiable" and "no, they're not equal because they're merely unifiable"
11:41:12 <ksf> ...which in the case of hOccursMany even makes some sense, as there could be say Float and Double in the list and both are unifiable to Num a => a, but that won't fit into a vanilla list.
11:45:44 <zygoloid> ksf: what are you actually trying to do?
11:45:58 <ksf> writing a sane object system.
11:46:54 <ksf> to that end, I'm attempting to use HList techniques to statically type TChans that transmit arbitrary messages
11:47:05 <ksf> ...which works fine, as long as the types are ground.
11:48:07 <EvanR-work> sane and object in the same sentence
11:49:16 <ksf> well, sane in the sense of "each object is an acceptor thread, each handle returns its reply in a spark from that thread, and sending an object is optionally async or sync."
11:49:45 <quicksilver> ksf: do you mean ground, or polymorphic?
11:49:56 <quicksilver> *mono
11:50:00 <ksf> I mean non-polymorphic. no variables allowed.
11:50:02 <quicksilver> ksf: [Int] shouldn't be a problem
11:50:04 <quicksilver> [a] will be.
11:50:26 <quicksilver> this is related to the fact you can't store polymorphic types in a Dynamic.
11:50:43 <quicksilver> yes, that's monomorphic, not ground, at least the way I think I use the words.
11:50:53 <quicksilver> "polymorphic types are not first class in haskell"
11:51:07 <ksf> nf, not whnf.
11:51:45 <EvanR-work> first class this first class that... whats an example of 'something' that is second class
11:52:11 <EvanR-work> or third class
11:52:15 <ksf> quicksilver, do you know whether OutsideIn will change that?
11:53:03 * ksf wonders whether he can hack around the overlapping issue by trying each index of the list with brute force.
11:53:25 <ksf> hmmmm
11:54:04 <quicksilver> ksf: in itself, no; it only try to solve an existing problem again. It won't give you anything you can't currently get with some annotations.
11:54:12 <quicksilver> it might mean you need fewer annotations in some cases.
11:54:22 <zygoloid> quicksilver: presumably it'd be possible to make data Dynamic1 where ToDynamic1 :: Typeable1 f => (forall a. f a) -> Dynamic1 ?
11:54:37 <quicksilver> zygoloid: I don't remember the details. There is an oleg on it I believe.
11:55:38 <McManiaC> c_wraith: are you still there?
11:55:39 <ksf> It's not often that I wish for haskell to be dependently typed.
11:55:45 <quicksilver> ksf: but, perhaps(?) it would make it feasible to implement a language extension which does what you want.
11:55:46 <c_wraith> McManiaC, yeah.
11:55:47 <zygoloid> cool :) i'll have a look through
11:55:55 <ksf> ...at least I'd be able to hack around the limitations, then.
11:56:06 <McManiaC> c_wraith: what exactly is xpath? I can only find XPath.Arrows ?
11:56:55 <CalmNelly> @vixen Why do white people like Wayne Brady so much?
11:56:55 <lambdabot> i'm half white and half mexican
11:57:01 <ksf> quicksilver, so you mean I should write that Obituary on polymorphism, and hope for some necrophile to ressurect it?
11:57:11 <c_wraith> McManiaC, I meant the xpath query language in general, not any specific haskell implementation of it.  I still don't know what you want when you say jquery-like library for haskell.
11:57:15 <ksf> mexicans aren't white?
11:57:21 <ksf> thought they were spanish.
11:57:36 <c_wraith> Most have both spanish and native american ancestors.
11:57:36 <ksf> they've good tan, granted, but...
11:57:43 <CalmNelly> mexicans speak spanish
11:57:46 <wli> Mestizo
11:57:52 <McManiaC> c_wraith: well some simple XML navigation like "a>td...."
11:58:11 <CalmNelly> c_wraith: correct
11:58:47 <CalmNelly> and by native american ancestor, you must mean mayan, aztec
11:58:50 <ksf> c_wraith, well, that makes them native people then, unlike whites in the US.
11:59:00 <EvanR-work> 'hispanics'!
11:59:10 <c_wraith> McManiaC, is your goal to succinctly provide a description of subdocuments to extract from an xml document?  If so, an xpath-like library is what you want.  I don't know of any in haskell, though.
11:59:24 <CalmNelly> 'latinos'
11:59:32 <quicksilver> ksf: you could try that ;)
11:59:37 <obfuscated> Hello, how can I access the connection variable returned by Mysql.connect in the function cgiMain in this: http://pastebin.com/u10rGqsz? 
11:59:45 <quicksilver> ksf: you could try a well explained use case on glasgow-haskell-users and see if anyone bites
11:59:50 <McManiaC> c_wraith: ok :(
11:59:57 <ksf> ...but please don't all go where you belong. there's been a reason we kicked you good-for nothing fundamentalist religious idiots out of europe.
12:00:35 <CalmNelly> @vixen Is Jesus your homeboy?
12:00:36 <lambdabot> is that really what you want to know?
12:01:11 <EvanR-work> youre a hispanic latino
12:01:14 <EvanR-work> trust us
12:01:27 <CalmNelly> lol
12:02:03 <c_wraith> McManiaC, it looks like HXT has an XPath library
12:02:17 <c_wraith> http://hackage.haskell.org/package/hxt-xpath
12:02:27 <c_wraith> I haven't used it, so I can't really make a recommendation for or against it
12:02:50 <wli> ksf: I guess I could speak to that issue in -blah
12:06:05 <zygoloid> quicksilver: this works: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28762#a28762
12:06:47 <zygoloid> ksf: ^^ don't know if that's of any relevance to your problem
12:06:57 <mjrosenb> :t mapM resolveName
12:06:57 <mjrosenb> mapM resolveName :: [String] -> (String, [String]) -> [IO String]
12:06:58 <lambdabot> Not in scope: `resolveName'
12:07:07 <mjrosenb> shouldn't the IO be outside of the []?
12:07:21 <tolkad> Does anyone know of an http test client I can use to help test if my server is compliant with the http protocol?
12:07:22 <djahandarie> :t sequence
12:07:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:07:40 <quicksilver> zygoloid: neat.
12:08:01 <quicksilver> zygoloid: but not all polymorphic types are conveniently expressed as (forall a . f a) for a proper type constructor f
12:08:09 <djahandarie> Actually
12:08:13 <quicksilver> zygoloid: (and haskell doesn't do full higher order unification)
12:08:16 <quicksilver> zygoloid: still, that's neat.
12:08:18 <djahandarie> If you're using mapM it should already be outside the list
12:08:32 <ksf> zygoloid, I don't have any problem saving polymorphic values in lists, not even looking them up by index, the problem is looking them up by type.
12:08:36 <djahandarie> A map would leave it inside the list
12:09:21 <mjrosenb> oh, it just picked a random monad and instantiated it with that monad.
12:09:30 <ksf> hmmm I should actually try that "try each index of the list"- approach.
12:09:33 * mjrosenb assumes it picked m = (->)
12:09:39 <maltem> tolkad, not sure about a compliance test, but curl -v is at least useful to be told what's going on
12:09:55 <McManiaC> c_wraith: k thx :)
12:09:58 <ksf> if I don't need any instance for the "type does not match" case, then I don't get overlaps.
12:10:12 <djahandarie> mjrosenb, that's what you get for importing Control.Monad.Instances :)
12:11:39 <zygoloid> quicksilver: i was /very/ confused when i started with haskell about the existence of values of type (forall a. [a])
12:11:50 <sproingie> don't know of any http protocol compliance testers that are free
12:11:54 <zygoloid> i still don't think i fully understand what's going on :(
12:12:15 <ksf> the type as it stands isn't useful, at all.
12:12:28 <zygoloid> (i understand it operationally now, which helps me a lot)
12:12:30 <ksf> you need at least a typeclass constraint there to make the as useable.
12:12:33 <mjrosenb> djahandarie: i didn't?
12:12:49 <zygoloid> ksf: not really. (forall a. [a]) is isomorphic to Nat
12:12:55 <sproingie> i bet a fuzz tester that speaks http/1.1 would be a reasonable compliance tester
12:13:01 <djahandarie> mjrosenb, then it wouldn't pick ((->) r) as your monad
12:13:03 <ksf> well yes but then you could've just used Nat.
12:13:08 <sproingie> it should at least test whether you break gracefully
12:13:16 <ksf> ...or [()]
12:13:23 <mjrosenb> djahandarie: ok, then what *did* it pick?
12:13:27 <zygoloid> ksf: sure, but i can't zipWith const on Nat ;-)
12:13:29 <quicksilver> it's not really the point though ksf
12:13:35 <ksf> it's the as which aren't useable as arguments to anything but id.
12:13:37 <djahandarie> mjrosenb, I don't know, I would need to see more of your code.
12:13:47 <zygoloid> ksf: well, id or seq ;)
12:13:51 <djahandarie> mjrosenb, such as :t resolveName
12:13:53 <quicksilver> there are other such things which are useful
12:14:09 <quicksilver> [(a,a -> IO [a],a -> IO ())]
12:14:23 <ksf> seq == id, unless your cpu has a temperature sensor.
12:14:27 <zygoloid> (forall a. [a]) was just the first such example i saw, shortly before (forall a. Maybe a)
12:14:35 <mjrosenb> > :t resolveName 
12:14:35 <mjrosenb> resolveName :: String -> (String, [String]) -> IO String
12:14:35 <lambdabot>   <no location info>: parse error on input `:'
12:14:55 <mjrosenb> lambdabot: thanks, just what i wanted
12:15:55 <toki78> hi, the pros are here, so can i ask a question about reinforcement learning here ?
12:16:56 <djahandarie> mjrosenb, not entirely sure how mapM resolveName would typecheck unless you had the ((->) r) monad instance loaded somewhere
12:19:32 <mjrosenb> djahandarie: i've imported monad, nothing else should deal with monads at all
12:19:53 <djahandarie> mjrosenb, mapM requires a function with only one parameter though, yours has two
12:20:09 <djahandarie> mjrosenb, and that normally wouldn't type check unless you had instances involving ((->) r)
12:20:13 <tolkad> your mother is a Monad
12:20:23 <EvanR-work> all functions have one parameter
12:20:50 <mjrosenb> djahandarie: which is what my assumption was initially.\
12:20:55 <ski> mjrosenb : and you want to call `resolveName' on a `[String]', on a `[(String, [String])]', or both ?
12:20:57 <EvanR-work> so you can map a list of functions 
12:21:15 <djahandarie> :t mapM
12:21:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:21:39 <ski> (using `mapM' or something similar, i.e.)
12:22:05 <mjrosenb> djahandarie: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28763#a28763
12:22:28 <mjrosenb> ski: i've already figured out what my problem was.  i'm just trying to figure out how my old code typechecked.
12:22:34 <djahandarie> I don't think import Monad would bring in instances like ((->) r)
12:22:39 <monochrom> eh, "import Monad" is rather strange
12:22:54 <djahandarie> It should be Control.Monad though
12:23:22 <tolkad> @hoogle (a -> (b, (c -> d))) -> (a -> c -> (b, d))
12:23:23 <lambdabot> No results found
12:24:16 <maltem> "import Monad" is the vintage version - back when module names had nice, short names
12:24:51 <aristid> maltem: the dark ages.
12:25:46 <maltem> aristid, no really, I'm not a fan of the Control and Data superhierarchies. I can never remember what is in Control, and what is in Data (or System, or Text)
12:26:26 <Samy> heh
12:26:57 <mjrosenb> i can remember Data.List
12:27:00 <mjrosenb> and that is about it
12:27:15 <ski> mjrosenb : `mapM :: (a -> m b) -> ([a] -> m b)' being applied to `resolveName :: String -> (String, [String]) -> IO String' gives `a = String',`m = ((String, [String]) ->)',`b = IO String', so `mapM resolveName :: [a] -> m [b]' is `mapM resolveName :: [String] -> (String, [String]) -> [IO String]' (and `Monad m', i.e. `Monad ((String, [String]) ->)' is satisfied)
12:27:35 <geheimdienst> haskell 2020 will sport Control.Basic.Witchcraft.Monad
12:27:56 <maltem> heh yeah Data.List has a certain ring to it so even I don't forget it
12:28:24 <Samy> maybe all imports should be qualified ;p
12:28:43 <chrisdone> ivan: mmm fresh code http://github.com/chrisdone/haskell-mode-exts
12:28:45 <djahandarie> ski, which only works with the ((->) r) monad instance, which he shouldn't have.
12:28:54 <Samy> Hi ski. 
12:29:01 <Samy> Haven't seen your writing in a while.
12:29:24 <maltem> geheimdienst, or org.haskell.realWorldEnterpriseCode.control.advanced.monad :/
12:30:14 <geheimdienst> ;-)
12:30:26 <zygoloid> import qualified Data.Data; instance Data.Data.Data Data.Data.DataType where ...
12:31:01 <quicksilver> import Catch22.Major; instance Major Major.Major.Major where ...
12:31:25 <chrisdone> I saw a Data.Data.Data type error before. I thought I was going a bit mad before I remembered about it
12:32:24 <geheimdienst> i guess tying the module names to DNS names is pretty clever for avoiding collisions. if you don't have a central place everyone uses (hackage, cpan, ...)
12:33:13 * zygoloid much prefers using packages for uniqueness and giving modules nice names
12:33:58 * ksf wonders how to make elemAtBy :: (ElemAt HZero l e, TypeCast e e') => (Proxy e') -> l -> e   and   elemAtBy' :: (ElemAt (HSucc HZero) l e, TypeCast e e') => (Proxy e') -> l -> e   a proper recursion
12:34:49 <ksf> ...well, not recursion. the induction depth is known beforehand, that's the point of the exercise.
12:34:49 <aristid> ksf: what a wonderful type.
12:35:20 <ski> oh .. this seems strange, `Data.Map' is leaking the `Monad (r ->)', here
12:35:22 <maltem> geheimdienst, I guess it makes sense for code developed by a certain company or such. Maybe not so much for everyday imports
12:35:24 <ski> mjrosenb : ^
12:35:32 <djahandarie> Ouch
12:35:38 <chrisdone> shapr: boing!
12:35:46 <djahandarie> Data.Map is leaking a monad instance? That's nasty
12:35:50 <zygoloid> ski: yeah, it comes in from all over the place ;(
12:35:55 <shapr> chrisdone: bounce!
12:35:55 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
12:35:58 <shapr> whoa
12:36:08 <ski> lo Samy
12:37:36 <chrisdone> shapr: you use emacs right?
12:38:04 <zygoloid> djahandarie: orphan instances are like that: if you use them, that implementation detail leaks out and infects any code which uses yours... ;(
12:38:22 <shapr> chrisdone: very much
12:40:24 <geheimdienst> import Data.OldNonsense.Map
12:43:12 <chrisdone> shapr: how's that for a slice of fried gold? http://github.com/chrisdone/haskell-mode-exts
12:44:08 <shapr> chrisdone: Ooh, gotta try those!
12:44:39 <chrisdone> :D
12:45:16 <mjrosenb> ski: weird.
12:45:58 <mjrosenb> hrmm, is there anything like break, except shifts the first element from snd to the last element of fst?
12:48:04 <ski> not that i can recall
12:49:44 <ski> hm, possibly `Data.List.Split' in package `split'
12:49:48 <ski> @hackage split
12:49:48 <lambdabot> http://hackage.haskell.org/package/split
12:50:41 <quicksilver> chrisdone: nice looking stuff. Now, can you build a database of all importable symbols and suggest which package I need to import if "sort" is undefined (i.e. Data.List in this case)
12:51:19 <tibbe> Can anyone come up with a beautiful way of writing a function that returns all consecutive runs of length [1..k] in a list of length n?
12:51:29 <ski> @wiki Data.List.Split
12:51:29 <lambdabot> http://www.haskell.org/haskellwiki/Data.List.Split
12:51:34 <yescalona> @karma haskell
12:51:34 <lambdabot> haskell has a karma of 61
12:51:54 <tibbe> Example: runsUpTo 2 [1,2,3] ==> [[1], [2], [3], [1,2], [2,3]]
12:51:59 <mreh> @karma C
12:52:00 <lambdabot> C has a karma of 2
12:52:10 <mreh> @karam C++
12:52:10 <lambdabot> Maybe you meant: karma karma+ karma-
12:52:41 <EvanR-work> C karma is stuck at 2
12:52:47 <EvanR-work> @karma+ C
12:52:47 <lambdabot> C's karma raised to 3.
12:52:49 <dpratt71> is there a good resource for figuring out the particulars of the cabal package management system?
12:52:49 <EvanR-work> @karma+ C
12:52:50 <lambdabot> C's karma raised to 4.
12:52:50 <dpratt71> When things go well, it's all good, but when things break in non-obvious ways, I'm usually at a loss
12:52:52 <medfly> C++ C++
12:52:54 <medfly> @karma C
12:52:54 <lambdabot> C has a karma of 4
12:52:57 <EvanR-work> :o
12:52:59 <medfly> :3
12:53:03 <EvanR-work> C++
12:53:06 <medfly> it doesn't like me :(
12:53:06 <EvanR-work> @karma C
12:53:06 <lambdabot> C has a karma of 4
12:53:07 <tibbe> dpratt71: -v for verbose output
12:53:09 <dcoutts_> dpratt71: cabal user guide, cabal FAQ
12:53:11 <tibbe> dpratt71: it's really useful
12:53:15 <medfly> oh, it doesn't like you either.
12:53:23 <dcoutts_> dpratt71: oh and --help of course
12:53:23 <EvanR-work> @karma+ C
12:53:24 <lambdabot> C's karma raised to 5.
12:53:26 <tibbe> ski: Doesn't have what I need :(
12:53:31 <aristid> @karma- C
12:53:31 <lambdabot> C's karma lowered to 4.
12:53:33 <aristid> @karma- C
12:53:34 <lambdabot> C's karma lowered to 3.
12:53:36 <EvanR-work> dammit
12:54:06 <dpratt71> thanks tibbe, dcoutts_; I think I'm looking for something a little deeper
12:54:08 <chrisdone> tibbe: http://github.com/chrisdone/haskell-mode-exts/raw/master/haskell-sort-imports.el
12:54:08 <chrisdone> tibbe :D
12:54:22 <Samy> @karma+ jaspervdj 
12:54:22 <lambdabot> jaspervdj's karma raised to 1.
12:54:24 <tibbe> chrisdone: nice :)
12:54:27 <dcoutts_> dpratt71: if you've got deep questions you can ask me :-)
12:54:55 <dpratt71> dcoutts_: thanks, lemme see if I can formulate...
12:54:55 <tibbe> chrisdone: how's the sort defined and can it be done on a selected region?
12:55:06 <dpratt71> (don't hold your breath or anything)
12:55:15 <dcoutts_> dpratt71: the other resources are the cabal/hackage trac and the source code.
12:55:28 <ski> > [] : filter (not . null) (inits =<< map (take 2) (tails "abcdef"))
12:55:29 <lambdabot>   ["","a","ab","b","bc","c","cd","d","de","e","ef","f"]
12:55:42 <lispy1> Has anyone else ever wanted a variant of Data.Map that lets you specify your own comparison function instead of using the type class instance?
12:55:51 <ski> tibbe : i was responding to mjrosenb
12:55:53 <dpratt71> * Missing header file: include/WideStringSrc.h
12:55:53 <dpratt71> * Missing C libraries: kernel32, user32, ole32, oleaut32, advapi32
12:56:02 <tibbe> ski: oh :)
12:56:03 <aavogt> lispy1: you can use a newtype
12:56:09 <dpratt71> that's the gist of the error, but I suspect something else
12:56:16 <chrisdone> tibbe: it does it on the "group" of imports at the currrent point, where a group is a consequtive list of import lines.  do you need it to work on regions? I can do that
12:56:23 <lispy1> aavogt: So then I can use TH if I want to change the comparison at run-time? :)
12:56:26 <dpratt71> WideStringSrc.h is part of the package, after all
12:56:33 <tibbe> chrisdone: groups is a good start
12:56:35 <quicksilver> > let runsOfLength n = takeWhile ((==n).length) . map (take n) . tails in [1..3] >>= flip runsOfLength [1..4]
12:56:36 <lambdabot>   [[1],[2],[3],[4],[1,2],[2,3],[3,4],[1,2,3],[2,3,4]]
12:56:39 <tibbe> chrisdone: regions might be more predictable
12:56:41 <quicksilver> tibbe: ^^ ?
12:56:47 <aavogt> lispy1: won't the Map be invalid if you arbitrarily change the comparison function?
12:56:50 <tibbe> quicksilver: thanks :)
12:57:11 <lispy1> aavogt: yes.  But what about creating a new map from scratch using a new comparison
12:57:16 <ski> > [] : (tail . inits =<< map (take 2) (tails "abcdef"))  -- simpler
12:57:17 <lambdabot>   ["","a","ab","b","bc","c","cd","d","de","e","ef","f"]
12:57:35 <chrisdone> tibbe: I suppose ideally it will use the current group, or if there is a current region, it uses the region instead
12:57:37 * chrisdone looks up how to check if there is a region or not
12:57:37 <dcoutts_> dpratt71: ok so it means that compiling that header file fails, and it erroneously gets reported as being missing.
12:57:49 <lispy1> aavogt: and let's say you build that comparison at run-time.  (although, this is different than the use I need it for)
12:58:00 <ski> tibbe : how about that ^ ?
12:58:11 <ezyang> Are there any techniques for serializing closures in Haskell? 
12:58:13 <chrisdone> ah, use-region-p :-)
12:58:22 <aavogt> hmm, perhaps it's still possible to reuse Data.Map for that...
12:58:24 <lispy1> aavogt: What about cases where you don't have an Ord instance (and you don't want to write one for some reason) but it still makes sense to compare them and you want to create a map?
12:58:27 <ezyang> So you can do something like Oleg's delimcc implementation for CGI scripts. 
12:58:28 <dcoutts_> dpratt71: so the most likely thing is that some other header that is #included by WideStringSrc.h is missing
12:58:29 <dpratt71> suspected as much...preparing to post the -v dump in case that provides any clues (not directly in the channel, of course)
12:58:34 <quicksilver> ezyang: not in current standard compilers.
12:58:41 <ezyang> quicksilver: Bah humbug. 
12:58:42 <tolkad> > [["4"],[5]]
12:58:43 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
12:58:43 <lambdabot>    arising from the literal ...
12:58:43 <quicksilver> ezyang: the problem has been solved many times though
12:58:50 <quicksilver> ezyang: gdh, yhc, probably more.
12:58:59 <dcoutts_> dpratt71: I think you need -v3 to see the output of that test
12:59:08 <quicksilver> ezyang: I don't know why the solutions keep bitrotting. Presumably no one uses them.
12:59:15 <dcoutts_> dpratt71: in more recent Cabal versions we've improved the error message
12:59:19 <ezyang> I feel like it'd have to be GHC. 
12:59:21 <tibbe> ski: great
12:59:29 <tibbe> I love the auto refactoring abilities of #haskell
12:59:31 <tolkad> :t [3,4.5]
12:59:32 <lambdabot> forall t. (Fractional t) => [t]
12:59:39 <aavogt>  data K a = K (a -> a -> Ordering) a, with appropriate Ord instance
12:59:44 <dpratt71> dcoutts_: ok, -v3 it is
12:59:46 <dpratt71> thanks
13:00:00 <luite> chrisdone: your String.prototype.trim() function in tryhaskell is wrong, it doesn't remove whitespace from the end of the string. Not sure if it's a problem for your site, but I thought I'd mention it anyway :)
13:00:02 <quicksilver> aavogt: let's you change the ordering at every point, though, with strange consequences if you do.
13:00:09 <tolkad> :k forall a. a
13:00:10 <lambdabot> *
13:00:10 <ski> aavogt : what would the instance be .. ?
13:00:17 <ezyang> I wonder what makes this a hard problem for GHC. 
13:00:35 <quicksilver> ezyang: apparently it's not that hard. gdh was based on ghc, and so was mobile haskell I believe.
13:00:35 <tolkad> :k (a -> b) -> a -> b
13:00:36 <lambdabot> Not in scope: type variable `a'
13:00:37 <lambdabot> Not in scope: type variable `b'
13:00:37 <lambdabot> Not in scope: type variable `a'
13:00:39 <ski> aavogt : `compare (K cmp0 a0) (K cmp1 a1) = cmp? a0 a1' ?
13:00:43 <tolkad> :k forall a b. (a -> b) -> a -> b
13:00:44 <lambdabot> *
13:00:46 <aavogt>  instance Ord (K a) where compare (K c a) (K _ b) = c a b
13:00:55 <ezyang> quicksilver: Ah. So I guess we have to convince the Simons to put it in mainline :-) 
13:01:02 <aavogt> ski: or average the results between the two functions?
13:01:12 <aavogt> ... however that's going to happen
13:01:20 <ski> aavogt : what is the average of `LT' and `EQ' ?
13:01:27 <quicksilver> ezyang: or convince the authors of mobile haskell to share the code, perhaps.
13:01:29 <quicksilver> if it ever worked.
13:01:34 <tolkad> :k a->b->c
13:01:35 <lambdabot> Not in scope: type variable `a'
13:01:35 <lambdabot> Not in scope: type variable `b'
13:01:35 <lambdabot> Not in scope: type variable `c'
13:01:47 <aavogt> ski maybe throw an error if they don't give the same result
13:01:48 <tolkad> :k a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a
13:01:49 <lambdabot> Not in scope: type variable `a'
13:01:49 <lambdabot> Not in scope: type variable `a'
13:01:49 <lambdabot> Not in scope: type variable `a'
13:02:01 <medfly> hehe
13:02:05 <ezyang> Oh, Mobile Haskell is not academic research? 
13:02:08 <quicksilver> tolkad: if you just want to play with lambdabot use PM (or just run ghci locally)
13:02:09 <Samy> :k *->*->*
13:02:10 <lambdabot> parse error on input `*->*->*'
13:02:22 <Samy> ;p
13:02:23 <ski> aavogt : doesn't sound like the right thing to do (defining `K', i.e.)
13:02:26 <quicksilver> ezyang: http://www.macs.hw.ac.uk/~dubois/mhaskell/
13:02:36 <chrisdone> luite: hmm thanks. doesn't seem to be an issue but nice to know
13:03:01 <luite> chrisdone: you can just use $.trim() instead
13:03:44 <ezyang> Talk about fail website :-) 
13:04:23 <quicksilver> ezyang: it is a mystery to me why none of these approaches has been taken up. People seem to ask for it here often enough.
13:04:37 <aavogt> ski: I can only think of some unsafePerformIO alternatives
13:05:06 * ski wonders what problem aavogt is trying to solve ..
13:05:35 <aavogt> ski: lispy1's issue for a Map parameterized by the comparison function
13:05:54 <tolkad> unsafePerformIO is great, it's kind of annoying you have to put it in every function definition but at least it makes haskell usable
13:06:10 <dolio> Dependent types.
13:06:21 <roconnor> where are the fancy system.exec* functions located?
13:06:29 <EvanR-work> tolkad: lol?
13:06:32 <dolio> @hoogle exec
13:06:32 <lambdabot> Text.Regex.Posix.ByteString execBlank :: ExecOption
13:06:32 <lambdabot> Text.Regex.Posix.Sequence execBlank :: ExecOption
13:06:32 <lambdabot> Text.Regex.Posix.String execBlank :: ExecOption
13:06:35 <dolio> Bah.
13:06:48 <copumpkin> tolkad: funny
13:06:59 <EvanR-work> i hope youre joking
13:07:04 <copumpkin> tolkad: and haskell + unsafePerformIO is not the same as an imperative language
13:07:08 <ski> aavogt,lispy1 : hm, something ML-functorish might be possible, here
13:07:46 <ksf> fsck.
13:07:47 <lispy1> tolkad: hehe, what are you working on?
13:07:54 <ksf> just give me a bleeding turing-complete type system.
13:08:31 <copumpkin> or give up on turing-completeness in types or values, and come to #agda
13:08:42 <roconnor> @hoogle overflow
13:08:42 <lambdabot> Control.Exception Overflow :: ArithException
13:08:42 <lambdabot> Control.OldException Overflow :: ArithException
13:08:43 <lambdabot> Control.Exception.Base Overflow :: ArithException
13:08:45 <copumpkin> well, you're already there
13:08:48 <copumpkin> but use it, then :)
13:09:29 * EvanR-work throws an OldException
13:09:43 <roconnor> @hoogle processstatus
13:09:43 <lambdabot> No results found
13:09:46 <dpratt71> ideas on the underlying cause of this error?: ./include/WideStringSrc.h:13: error: syntax error before "wchar_t"
13:09:51 <tolkad> lispy1: a simple text-based calculator
13:09:52 <roconnor> @hoogle ProcessStatus
13:09:53 <lambdabot> No results found
13:09:55 <roconnor> pft
13:10:17 <drhodes> is there a Map with parallel insert?  I have a list of guarenteed unique (key, val) I'd like to insert.
13:10:37 <roconnor> drhodes: tricky
13:10:45 <copumpkin> how would a parallel insert work?
13:11:06 <Samy> copumpkin, many ways it could be. :-P
13:11:12 <tolkad> copumpkin: it would insert multiple items into the Map at the same time
13:11:13 <quicksilver> parallel sort is easy enough.
13:11:24 <roconnor> copumpkin: balancing could be done in parallel for things far away. and work magically for things close together.
13:11:41 <copumpkin> roconnor: how would it know what's far away if it doesn't know the input is sorted?
13:11:44 <tolkad> lispy1: I'm kidding about the unsafeperformIO :P
13:12:06 <roconnor> copumpkin: when you go to insert you would soon find out things are far away
13:12:07 <lispy1> tolkad: ooooh
13:12:07 <monochrom> unsafePerformIO is the best thing since whole wheat bread
13:12:09 <ski> hm .. is there a class for the like of `Map k',`IntMap',&c. ?
13:12:12 <quicksilver> so insert into separate sub-maps and merge as a final (serialised) step.
13:12:31 <roconnor> but given that we can't get sequential map correct, I don't know about parallel
13:12:37 <roconnor> granted it is delete that is broken
13:12:38 <quicksilver> but the fact the final merge can't be parallelised usefully probably limits your speed up quite a bit.
13:13:16 <dpratt71> I'm pasting the whole log in case I'm barking up the wrong tree: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28766#a28766
13:13:27 <ski> (like `IArray' and `MArray' for the array types, i mean)
13:13:33 <roconnor> quicksilver: if two far away inserts balance without interference, then the inserts commute
13:13:43 <roconnor> and one can imagine a parallel update
13:14:53 <dolio> @hackage collections
13:14:54 <lambdabot> http://hackage.haskell.org/package/collections
13:15:58 <quicksilver> roconnor: yes, but I think the efficient maps I know about don't have that property in general
13:16:03 <dolio> Just use tries. That should be easy to parallelize.
13:16:10 <quicksilver> roconnor: there is certain inevitable (amortized) globality to balancing
13:17:40 <dpratt71> dcoutts_: you still around? not expecting you to help me, mind you, just hoping :)
13:17:49 <osaunders> Is there anything online that will visualize recursion of Haskell code?
13:17:52 <dcoutts_> @arr!
13:17:52 <lambdabot> Aye Aye Cap'n
13:18:10 <roconnor> drhodes: anyhow, since inserts don't commute wrt their internal represenations (AFAIU), a parallel insert is really difficult
13:18:29 <roconnor> (i.e. how the internal tree is balanced depends on the order of the inserts)
13:18:38 <drhodes> roconnor: I've gather from this discussion, ( which I really appreciate, btw)
13:18:42 <dpratt71> did you see that I posted the -v3 log to the channel?
13:19:07 <mreh> I really don't see how mfix only executes the action once
13:19:15 <mreh> :t mfix
13:19:16 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
13:19:32 <quicksilver> mreh: well mfix is only a specification; it doesn't show that the action is only executed once
13:19:37 <quicksilver> that's down to the actua implementations.
13:19:48 <dpratt71> dcoutts_:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28766#a28766
13:20:21 <quicksilver> drhodes: you can do it if you can avoid the balancing, somehow. like if you can arrange for the stuff to come in sorted order and then "automatically" balance as you go.
13:20:38 <quicksilver> although you still need to understand your tree structure to know how to get it right.
13:20:48 <chrisdone> tibbe: done! http://github.com/chrisdone/haskell-mode-exts/raw/master/haskell-sort-imports.el
13:21:02 <tibbe> chrisdone: you're too fast!
13:21:07 <dcoutts_> dpratt71: so can you figure it out from there? you can see the errors that gcc reports.
13:21:15 <tibbe> chrisdone: I'll bookmark it for tomorrow. Too much going on at the same time!
13:21:33 <chrisdone> tibbe: ;-D
13:21:43 <Ke> is there really some use for fix
13:21:58 <mreh> value recursion
13:22:03 <ski> @src Maybe mfix
13:22:04 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
13:22:11 <dpratt71> dcoutts_: given enough time, perhaps :) do you think this represents a problem with the package or my system's config?
13:22:28 <EvanR-work> Ke: i use it for anonymous looping
13:22:31 <ski> Ke : it's sometimes handy to write a recursive function inline
13:22:42 <EvanR-work> with an end
13:22:46 <copumpkin> > mfix (const Nothing)
13:22:47 <lambdabot>   Nothing
13:23:26 <mreh> that always seems like magic to me
13:23:29 <roconnor> meh, usually it is more clear to use a pointful let statement
13:23:30 <copumpkin> > mfix (\x -> x `seq` Nothing)
13:23:34 <lambdabot>   mueval-core: Time limit exceeded
13:23:38 <dcoutts_> dpratt71: well the com.cabal file specifies incorrect ld flags, and there is an error in the include/WideStringSrc.h file, probably due to some difference in the environment, you'd have to look at the code.
13:23:48 <quicksilver> Ke: there is no technical use for fix, in the sense that haskell has recursion
13:23:53 <aristid> @src [] mfix
13:23:53 <lambdabot> mfix f = case fix (f . head) of
13:23:54 <lambdabot>            []    -> []
13:23:54 <lambdabot>            (x:_) -> x : mfix (tail . f)
13:23:55 <djahandarie> fix is useful for golfing
13:23:56 <EvanR-work> its annoying to have to type (in a do block) let f x = ...  and later f
13:23:59 <quicksilver> Ke: so using 'fix' is a stylistic choice
13:24:30 <roconnor> Ke: I'd only use it in some rare case where you want to be recursive but for some reason, pointfree is more clear (like in an arguement to map).
13:24:34 <djahandarie> > mfix [1]
13:24:35 <lambdabot>   Couldn't match expected type `a -> m a'
13:24:35 <lambdabot>         against inferred type `[a1]'
13:24:39 <dolio> > mfix (const Nothing)
13:24:40 <lambdabot>   Nothing
13:24:43 <djahandarie> > mfix (const [1])
13:24:44 <lambdabot>   [1]
13:24:45 <quicksilver> it is indeed useful for looping as EvanR-work says, although I wouldn't quite call it "anonymous"
13:24:47 <djahandarie> > mfix (const [1..])
13:24:48 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:25:01 <quicksilver> because you do name something: you name the repeat point or whatever you wish to call it.
13:25:04 <ksf> ...if I try backtracking, stuff obviously doesn't work as classes don't backtrack. If I try everything at once, ghc wants my HList to be anything but heterogenous.
13:25:06 <ski> Ke : also, in some cases, it's simpler to just call `fix' on a function, than to make a knot, explicitly .. i did that in "repaste of PoorManDebug" <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10060>
13:25:14 <EvanR-work> yes
13:25:27 <dcoutts_> dpratt71: ah, it's because the com.cabal file specifies the wrong includes, or at least insufficient ones.
13:25:33 <roconnor> > map (take 3) (mfix (\x -> [1:x,2:x]))
13:25:34 <lambdabot>   [[1,1,1],[2,2,2]]
13:26:10 <ski> (EvanR-work : "with an end" means ?)
13:26:13 <aristid> > mfix (\x -> [x,x+1])
13:26:17 <monochrom> if haskell supported de Bruijn numbering, you wouldn't use a name inside fix (\deBruijn -> ...)
13:26:17 <lambdabot>   mueval-core: Time limit exceeded
13:26:18 <dcoutts_> dpratt71: notice that WideStringSrc.h uses wchar_t but does not #include anything that defines wchar_t, it assumes a previous header has included that, but then the .cabal file does not list the header that defines wchar_t, hence the error.
13:26:22 <roconnor> aristid: not lazy enough
13:26:49 <roconnor> aristid: you need to return a list of things lazy in x (AFAIK)
13:26:52 <dcoutts_> dpratt71: the com.cabal file lists the headers assuming there is some existing context that defines wchar_t, but that's not the case.
13:26:58 <ski> > map (take 8) (mfix (\xs -> [0:xs,1:xs]))
13:26:59 <lambdabot>   [[0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1]]
13:27:01 <aristid> > mfix (\x -> [1,x,x+1])
13:27:05 <lambdabot>   mueval-core: Time limit exceeded
13:27:06 <ksf> monochrom, regex syntax uses de bruijn, and it's generally regarded to be a misfeature.
13:27:07 <dpratt71> dcoutts_: ah, makes sense; thanks for the insight
13:27:17 <aristid> roconnor: and lazy not just in the head?
13:27:17 <roconnor> aristid: each element of the list needs to be lazy
13:27:23 <dcoutts_> dpratt71: basically the com package needs fixing to work with more recent versions of the tools (it's surprising that it ever worked)
13:27:44 <dcoutts_> in particular the --enable-stdcall-fixup --disable-stdcall-fixup thing looks like it could never have worked
13:27:46 <dpratt71> dcoutts_: understood
13:27:50 <dolio> It's a misfeature in regexes because it makes them not regexes.
13:32:45 <ksf> dolio, it makes them state transducers.
13:33:04 <ksf> ...that is, it doesn't make them not regular.
13:34:30 <monochrom> regex with \1 etc. can distinguish prime numbers from non-prime numbers (decimal notation). this is non-regular.
13:34:58 <ksf> but only if you apply it more than once.
13:35:19 <dolio> Isn't a^nb^ma^n non-regular?
13:35:25 <dolio> That's (a*)b*\1
13:35:27 <ksf> ...then you have a string rewrite language that's easily turing complete.
13:35:46 <mauke> monochrom: in decimal? seriously?
13:35:49 <ksf> anything with more than one ^n is non-regular.
13:35:51 <monochrom> seriously
13:35:52 <ksf> see pumping lemma.
13:36:00 <mauke> monochrom: I'd like to see that regex
13:36:26 <dolio> http://www.noulakaz.net/weblog/2007/03/18/a-regular-expression-to-check-for-prime-numbers/
13:36:31 <ksf> and I don't mean \1 as dolio is using it.
13:36:40 <monochrom> is there, on the internet, a regex lib that allows \1 etc but "allow only once"? if not, the "more than once" part is moot.
13:36:44 <ksf> my interpretation of it is capture-only. no injection into the runnnig regex.
13:37:20 <dolio> Doesn't look like decimal.
13:37:30 <mauke> that's unary
13:38:03 <monochrom> perhaps I misremembered unary vs decimal
13:38:26 <monochrom> unary is easier to do and still proves non-regular-ness.
13:38:29 <mauke> I have a regex that recognizes fibonacci sequences (in unary)
13:38:39 <monochrom> decimal is then "just engineering" :)
13:38:51 <mauke> http://mauke.ath.cx/stuff/perl/fibcheck.pl
13:39:24 <Ke> so are you people saying that ghc can optimize fix recursion?
13:39:32 <ksf> hmmmmmm.
13:39:36 <ksf> now I know how to do it.
13:39:39 <Cale> I wonder how hard it would be to show that the language of primes in binary is not context-free.
13:39:39 <monochrom> no
13:40:05 <ksf> launch TH, launch hint, try each possible index, and if I don't get a type error then there's a match.
13:40:35 <monochrom> hahahaha
13:41:31 <ksf> that's not even far-fetched, the type system as I'd want it to behave would do the same.
13:41:42 <ksf> .oO( -XBacktrackingInstances )
13:42:06 <mreh> hmm, I suppose I need to understand the laws before I get mfix
13:42:31 <Ke> > fix (\rec n -> if n == 0 then 1 else n * rec (n-1)) 1000000
13:42:35 <monochrom> I have always promoted using runIO in TH but I have only gone to "play a movie", I haven't gone far enough to "run ghc-api again"
13:42:36 <lambdabot>   *Exception: stack overflow
13:42:52 <roconnor> Is Either e x a monadPlus when e is a monoid?
13:42:59 <Ke> > let fact n = if n == 0 then 1 else n * fact (n-1) in fact 1000000
13:43:00 <lambdabot>   *Exception: stack overflow
13:43:15 <dolio> Is it declared as such, you mean? I doubt it.
13:43:26 <roconnor> no I mean in principle.
13:43:38 <Cale> > foldl' (*) 1 [1..1000000]
13:43:42 <lambdabot>   mueval-core: Time limit exceeded
13:43:52 <Cale> (Obviously)
13:44:06 <Cale> > foldl' (+) 0 [1..1000000]
13:44:07 <lambdabot>   500000500000
13:44:14 <dolio> Probably, then.
13:44:14 <medfly> o.O
13:44:30 <roconnor> category-extras probably knows
13:44:46 <aristid> does ghci do some optimizations?
13:44:48 <dolio> mzero `mplus` Left e = Left (mempty `mappend` e) = Left e, etc.
13:45:00 <monochrom> ghci doesn't do optimizations
13:45:01 <quicksilver> doesn't look right to me
13:45:01 <Cale> > sumN n = if n == 0 then 0 else n + sumN (n-1) in sumN 1000000
13:45:02 <lambdabot>   <no location info>: parse error on input `='
13:45:05 <Cale> > let sumN n = if n == 0 then 0 else n + sumN (n-1) in sumN 1000000
13:45:06 <lambdabot>   *Exception: stack overflow
13:45:12 <quicksilver> the mplussiness should be acting only on the non-contained bit
13:45:17 <quicksilver> is what my instinct tells me
13:45:22 <quicksilver> *shouldn't* be
13:45:27 <aavogt> aristid: ghci can load code you've compiled with -O though
13:45:38 <quicksilver> what did you anticipate for Right x `mplus` Right y ?
13:45:45 <Cale> The reason for the stack overflow here is that it builds up a large expression like 1000000 + (999999 + (999998 + ...))
13:45:46 <aristid> and lambdabot?
13:45:49 <aristid> i mean
13:45:49 <dolio> Right x.
13:45:54 <aristid> > foldl' (+) 0 [1..1000000]
13:45:55 <lambdabot>   500000500000
13:45:57 <quicksilver> I think what roconnor wants is the applicative semantics for Either
13:46:01 <quicksilver> but that fails to be a monad.
13:46:06 <aristid> how can this possibly run so fast without optimization?
13:46:36 <quicksilver> aristid: lambdabot runs optimised.
13:46:42 <quicksilver> it compiles the code.
13:46:58 <Cale> and since (+) is strict (it 'pattern matches' on both its parameters), there's no choice but to put the outermost one on the stack and start evaluating the right parameter
13:46:58 <dolio> The only problem I can see might be distributivity.
13:47:05 <monochrom> it's so fast in ghci on my laptop
13:47:21 <monochrom> not to mention that foldl' is compiled, clearly
13:47:23 <quicksilver> dolio: there is also the question of deciding what the laws for monadplus are supposed to be.
13:47:38 <dolio> quicksilver: I don't see how it's very different from Maybe being a MonadPlus.
13:47:46 <dolio> What is Just x `mplus` Just y?
13:47:53 <dolio> Just x.
13:48:04 <roconnor> quicksilver: Right x `mplus` Right y = Right x
13:49:01 <quicksilver> you're right it's not very different
13:49:07 <quicksilver> just adding an extra algebra over the lefts
13:49:22 <quicksilver> perhaps it's fine then, just feels wrong ;)
13:49:29 <ski> roconnor : iirc, Philippa was pondering an applicative functor which collects exceptions if several occur
13:49:31 <roconnor> what are the MonadPlus laws?
13:49:40 <quicksilver> ski: that's the one I was talking about.
13:49:44 <quicksilver> ski: it's in the applicative paper
13:49:49 <roconnor> ski: oh, do I need to restrict myself to applicative?
13:49:50 <quicksilver> and I've used it myself.
13:50:00 <quicksilver> well, it's a different approach.
13:50:10 <quicksilver> that collects failures over applications too
13:50:13 <quicksilver> not over mpluses
13:50:15 <dolio> mzero >>= f = mzero, (m `mplus` n) >>= f = (m >>= f) `mplus` (n >>= f), mzero `mplus` m = m `mplus` mzero = m.
13:50:30 <quicksilver> there are two possible candidate MonadPlus law sets
13:50:31 <roconnor> dolio: those are the laws?
13:50:34 <quicksilver> they're on the wiki somewhere.
13:50:54 <dolio> They're some reasonable expectations.
13:50:54 <ski> roconnor : for `Either e (Either e a)' you can't extract more than one `e', you need `ap' / `liftM2' rather than `(>>=)', i.e. `(<*>)' / `liftA2'
13:51:07 <ski> @haskellwiki Monadplus
13:51:07 <lambdabot> Unknown command, try @list
13:51:10 <ski> @wiki Monadplus
13:51:11 <lambdabot> http://www.haskell.org/haskellwiki/Monadplus
13:51:12 <dolio> The first one and the third one I'd expect to hold in general.
13:51:24 <roconnor> ski: I'd only expect to get the outer one.
13:51:42 <ski> @wiki MonadPlus reform proposal
13:51:42 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
13:51:57 <ski> roconnor : yeah, so what use is the `Monoid' constraint, then ?
13:51:58 <dolio> Distributivity fails for Maybe, I think.
13:52:01 * ksf likes his idea and calls it a day.
13:52:19 <roconnor> ski: collect errors from the use of mplus
13:52:30 <ksf> ...using TH to figure out which type an expression should have so that it typechecks properly, that is.
13:52:31 <ski> oh
13:52:37 <dolio> (Just 5 `mplus` Just 6) >>= \x -> if x == 5 then Nothing else Just x = Nothing
13:52:50 <roconnor> oh
13:52:53 <dolio> (Just 5 >>= \x ...) `mplus` (Just 6 >>= \x ...) = Just 6.
13:52:54 <roconnor> there is a MonadOr
13:52:56 <ksf> the nice thing being that the whole checking stays enabled, it's just inference that's offloaded into TH.
13:53:15 <dolio> Same would probably happen for Either.
13:53:36 * ski prefers `MonadElse' (or `MonadOrElse') to `MonadOr'
13:54:29 <aristid> Alternative is free of these troubles, right?
13:55:11 <dolio> If you don't expect it to interact with Monad stuff in the right way, probably.
13:55:22 <dolio> It doesn't have the higher-orderness.
13:57:14 <roconnor> MonadOr's laws seem very loose.
13:57:38 <dolio> In f <*> (x <|> y) = (f <*> x) <|> (f <*> y), you can decide to fail based on the contents of x or y.
13:57:47 <dolio> Can't even.
13:59:59 <aristid> dolio: for that you would need join?
14:00:21 <dolio> That'd be the idea, yes.
14:00:30 <dolio> Bind makes it obvious, too.
14:00:42 <dolio> With (a -> m b), you get to see the a before you decide whether to fail.
14:00:43 * roconnor is a little lost
14:00:53 <dolio> But not with m (a -> b).
14:01:14 <aristid> dolio: so do you need MonadPlus if you can have Monad+Alternative?
14:01:54 <roconnor> Is that list of laws for MonadOr correct?
14:02:00 <dolio> MonadPlus and Alternative are the same class. It's just that one is expected to interact with Monads in a certain way, and the other is expected to go with Applicative.
14:02:02 <roconnor> it doesn't involve map or join or bind.
14:03:47 <roconnor> dolio: are the laws for Alternative known?
14:04:13 <roconnor> and if so, which set of laws for MonadPlus are they compatible with?
14:04:14 <aristid> i think it's empty <|> x = x and x <|> empty = x
14:04:31 <dolio> Well, being a monoid is obvious.
14:04:36 <aristid> are there other relevant laws?
14:04:55 <roconnor> aristid: how it interacts with <*> (and maybe pure) should be defined
14:05:07 <roconnor> like dolio's distributive law
14:05:09 <dolio> I'd expect (f <|> g) <*> x = (f <*> x) <|> (g <*> x) and f <*> (x <|> y) = (f <*> x) <|> (f <*> y)
14:05:17 <ezyang> I think there are some bottom things? 
14:05:53 <dolio> Those are distributive, though. Not left-catch.
14:05:54 <ezyang> I'd probably expect f <|> _|_ = f, but _|_ <|> g = _|_ 
14:06:13 <roconnor> ack
14:06:14 <dolio> But left-catch might be distributive for applicatives.
14:06:17 <roconnor> forget about bottoms
14:06:26 <aidalgol> I was going to use foldl1 to convert a string of digits to an integer, but I need a counter, which I don't get with a fold.
14:06:34 <aidalgol> What could I use?
14:06:43 <aristid> when you have a type with instances for Monad and Alternative.... is it expected that the Alternative instance behaves like the MonadPlus laws ask?
14:06:44 <geheimdienst> zip?
14:06:47 <roconnor> aidalgol: read
14:06:59 <roconnor> > read "1234"
14:07:00 <lambdabot>   *Exception: Prelude.read: no parse
14:07:03 <geheimdienst> > zip [1..] "abcdef"
14:07:04 <lambdabot>   [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f')]
14:07:06 <roconnor> > read "1234" :: Integer
14:07:07 <lambdabot>   1234
14:07:09 <aidalgol> No, I have to re-implement read, basically.
14:07:12 <aidalgol> :(
14:07:16 <aidalgol> (assignment)
14:07:27 <dolio> > (Just succ <*> (Just 1 <|> Just 2), (Just succ <*> Just 1) <|> (Just succ <*> Just 2))
14:07:28 <lambdabot>   (Just 2,Just 2)
14:07:30 <roconnor> aristid: yes
14:07:33 <EvanR-work> > "140.85" :: Double
14:07:33 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
14:07:34 <lambdabot>         against inferred ty...
14:07:35 <EvanR-work> > read "140.85" :: Double
14:07:36 <lambdabot>   140.85
14:07:44 <aristid> roconnor: that's interesting
14:08:01 <aristid> so strictly speaking the class MonadPlus is not needed if Applicative => Monad would hold?
14:08:12 <EvanR-work> aidalgol: you must use fold?
14:08:29 <dolio> > ([succ, id] <*> ([1,2] <|> [3,4]), ([succ, id] <*> [1,2]) <|> ([succ, id] <*> [3, 4]))
14:08:29 <lambdabot>   ([2,3,4,5,1,2,3,4],[2,3,1,2,4,5,3,4])
14:08:41 <dolio> I guess that's kind of a problem.
14:08:43 <roconnor> aristid: it would seem so.
14:08:48 <EvanR-work> how about reversing, zipping with [0..] and using the place-value formula?
14:08:57 <EvanR-work> for base 10
14:08:58 <aidalgol> EvanR-work: No, I thought I *could* use fold, until I realised that I need to know the place of each digit.
14:09:05 <roconnor> dolio: craptastic
14:09:53 <roconnor> aidalgol: you don't need to know the place of each digit
14:10:00 <EvanR-work> > let x = "1234" in zip (reverse x) [0..length x - 1]
14:10:01 <lambdabot>   [('4',0),('3',1),('2',2),('1',3)]
14:10:08 <EvanR-work> hmm
14:10:15 <EvanR-work> yeah
14:10:32 <EvanR-work> sum map m*2^n
14:10:37 <dolio> > (([1,2] `mplus` [3,4]) >>= \x -> [succ x, x], ([1,2] >>= \x -> [succ x, x]) `mplus` ([1,2] >>= \x -> [succ x, x]))
14:10:38 <lambdabot>   ([2,1,3,2,4,3,5,4],[2,1,3,2,2,1,3,2])
14:10:41 <aidalgol> Looks like a reverse zipWith would do it.
14:10:51 <monochrom> 9413 = ((9*10+4)*10+1)*10+3.
14:10:54 <dolio> > (([1,2] `mplus` [3,4]) >>= \x -> [succ x, x], ([1,2] >>= \x -> [succ x, x]) `mplus` ([3,4] >>= \x -> [succ x, x]))
14:10:55 <lambdabot>   ([2,1,3,2,4,3,5,4],[2,1,3,2,4,3,5,4])
14:11:46 <monochrom> = 9 ⊕ 4 ⊕ 1 ⊕ 3  where x⊕y = x*10+y
14:11:50 <aidalgol> EvanR-work: Is that what I zip with?
14:12:14 <EvanR-work> aidalgol: see above
14:12:51 <monochrom> > let x⊕y = x*10+y in foldl1 (⊕) [9,4,1,3]
14:12:52 <lambdabot>   9413
14:12:57 <EvanR-work> and we just solved your homework
14:13:02 <EvanR-work> lol
14:13:07 <aidalgol> EvanR-work: So I need apply *only* sum map m*2^n to the list?
14:13:20 <aidalgol> Well, only a piece of my homework.
14:13:26 <monochrom> look up Horner's rule
14:13:40 * aidalgol consults Wikipedia.
14:13:42 <copumpkin> mmm horner
14:13:42 <EvanR-work> m*2^n is unnecessary, and the wrong base, see what monochrom's been doing
14:14:17 <monochrom> there are two reasons why "a*x^n + b*x^(n-1) + ..." is stupid
14:15:06 <monochrom> and finding those two reasons is your new homework
14:15:17 <dolio> > (([1,2,3] >>= \x -> [succ x] `mplus` [x]), ([1,2,3] >>= return . succ) `mplus` ([1,2,3] >>= return))
14:15:18 <lambdabot>   ([2,1,3,2,4,3],[2,3,4,1,2,3])
14:15:18 <aidalgol> monochrom: What's that character called (and can I use it in a Haskell program)?
14:15:51 <mauke> (springer-verlag)--
14:15:53 <EvanR-work> aidalgol: plus with a circle around it
14:15:55 <monochrom> I don't know what it's called. I am not a modem. Not interesting in converting programs to voice.
14:15:56 <mauke> U+2295 (e2 8a 95): CIRCLED PLUS [⊕]
14:16:06 <monochrom> s/interesting/interested/
14:16:15 <geheimdienst> aidalgol, just use some normal function name
14:16:20 <dolio> > (([succ] <|> [id]) <*> [1,2,3], ([succ] <*> [1,2,3]) <|> ([id] <*> [1,2,3]))
14:16:20 <lambdabot>   ([2,3,4,1,2,3],[2,3,4,1,2,3])
14:16:24 <aidalgol> I just needed to know what mauke told me.
14:16:46 <EvanR-work> >_> thats not good
14:16:49 <dolio> roconnor: So they're both left-distributive, but not right-distributive.
14:16:49 <monochrom> But you can just copy-paste. You can also find more symbols on http://www.vex.net/~trebla/symbols/select.html
14:16:49 <EvanR-work> weather is pretty bad
14:17:18 <dolio> But left-distributivity for applicative splits up the functions, while left-distributivity for monad plus splits up the values, so to speak.
14:17:18 <monochrom> And I just want to let it be known that I am not a modem.
14:17:23 <mauke> preflex: quote . modem
14:17:25 <preflex>  <monochrom> Do not try to pronounce haskell code. You are not a modem.
14:17:32 <mauke> :-)
14:17:39 <geheimdienst> > let f x y = x*10+y in foldl1 f [9,4,1,3]
14:17:40 <lambdabot>   9413
14:17:46 <roconnor> dolio: that's not so bad
14:18:17 <EvanR-work> "let f x y equal x times ten plus y in foldl one f nine four one three" ;)
14:18:21 <aidalgol> Sooo, why does that work?  (I suppose I should *understand* the solution to my homework.)
14:18:40 <monochrom> <monochrom> 9413 = ((9*10+4)*10+1)*10+3.
14:18:45 <monochrom> <monochrom> = 9 ⊕ 4 ⊕ 1 ⊕ 3  where x⊕y = x*10+y
14:18:51 <EvanR-work> beep boop buzzzz bonk beep
14:19:04 <monochrom> that was 8 minutes ago when you were too busy asking to read answers
14:19:39 <monochrom> and also some time later <monochrom> look up Horner's rule
14:19:39 <aidalgol> No, I see what it does, but I just don't see *how* that works.
14:19:52 <EvanR-work> > fromIntegral '9' :: Int
14:19:53 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
14:19:53 <lambdabot>    arising from a use of...
14:19:56 <aidalgol> And Horner's rule looks like what you said was stupid.
14:20:02 <EvanR-work> > ord '9'
14:20:03 <lambdabot>   57
14:20:09 <aidalgol> <monochrom> there are two reasons why "a*x^n + b*x^(n-1) + ..." is stupid
14:20:54 <EvanR-work> > ord '9' - 48
14:20:54 <lambdabot>   9
14:21:26 <aidalgol> Oh, I get it now.
14:21:39 <aristid> > (-) `on` ord $ '9' '0'
14:21:40 <lambdabot>   Precedence parsing error
14:21:41 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
14:21:45 <aidalgol> Needed to think of it recursively.
14:21:50 <aristid> > ((-) `on` ord) '9' '0'
14:21:51 <lambdabot>   9
14:22:19 <EvanR-work> > ord '9' - ord '0'
14:22:20 <lambdabot>   9
14:22:41 <EvanR-work> > ord 'a' - ord '0'
14:22:42 <lambdabot>   49
14:22:43 <siteswapper> :t on
14:22:43 <jystic> hi all, is it bad style to use a field like 'name' when using record syntax?
14:22:44 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:23:05 <jystic> (if you're going to export the record)
14:23:11 <EvanR-work> jystic: you can do whatever you want, in the end people can import it qualified
14:23:43 <jystic> is it more common to use unique looking names for records?
14:23:53 <EvanR-work> yes
14:24:19 <jystic> so my library would be a bit more friendly if i did the same
14:24:56 <EvanR-work> i like JY.name better than jyGRISTname
14:25:01 <roconnor> BTW, I just want to mention that ocaml is CRAZY!
14:25:24 <jystic> that's true
14:25:52 <EvanR-work> ive been following the rule of thumb, make it easy to use inside the module
14:26:24 <EvanR-work> roconnor: how so
14:27:28 <roconnor> The .mli files are practicaly a copy of the .ml files
14:27:50 <roconnor> and, apparently, I need to get the order of my files on the command line right to get things to compile.
14:28:31 <monochrom> I don't encounter the latter.
14:28:40 <BMeph> roconnor: You mean they aren't?!? (/me goes back to check...)
14:29:07 <roconnor> monochrom: perhaps I have a crap makefile in this project
14:29:19 <QtPlatypus> I read a casual comment on a blob that types form a semiring.  But can't find any one talking about it/explaining about it.
14:29:31 <jystic> EvanR-work: thanks for the tips
14:29:48 <roconnor> QtPlatypus: plus is Either and times is (,)
14:30:02 <roconnor> QtPlatypus: and equality is upto isomorphism
14:30:03 <aidalgol> Isn't there a function that maps numeric characters to integers?
14:30:09 <roconnor> QtPlatypus: and bottoms are ignored
14:30:19 <roconnor> > digit '3'
14:30:19 <copumpkin> QtPlatypus: was that me?
14:30:19 <lambdabot>   Not in scope: `digit'
14:30:24 <copumpkin> I mentioned it recently
14:30:29 <monochrom> > ord '5'
14:30:30 <lambdabot>   53
14:30:39 <QtPlatypus> copumpkin: Could well be
14:30:58 <roconnor> > digitToInt '3'
14:30:59 <lambdabot>   3
14:31:03 <roconnor> aidalgol: ^^
14:31:04 <copumpkin> QtPlatypus: 0 is the empty type and 1 is the unit type
14:31:11 <aidalgol> :t ord
14:31:12 <lambdabot> Char -> Int
14:31:13 <copumpkin> QtPlatypus: noting of course that haskell doesn't have an empty type
14:31:13 <EvanR-work> @src digitToInt
14:31:13 <lambdabot> Source not found.
14:31:19 <aidalgol> @src ord
14:31:19 <lambdabot> Source not found. My pet ferret can type better than you!
14:31:20 <aristid> :t digitToInt
14:31:21 <lambdabot> Char -> Int
14:31:33 <EvanR-work> copumpkin: Void?
14:31:38 <QtPlatypus> Ah ok
14:31:39 <copumpkin> EvanR-work: it's not really empty
14:31:48 <EvanR-work> _|_ ?
14:31:49 <roconnor> copumpkin: shh, ignore bottoms
14:31:49 <copumpkin> all types in haskell have one inhabitant
14:31:51 <copumpkin> lol
14:31:53 <aidalgol> What the heck does ord do, that it maps '5' to 53?
14:31:58 <roconnor> data Empty =  -- not haskell 98
14:32:07 <EvanR-work> aidalgol: unicode codepoint
14:32:07 <copumpkin> or newtype Z = Z Z
14:32:09 <aristid> aidalgol: have you ever heard of unicode?
14:32:14 <azaq23> > 53 `rem` 48
14:32:15 <lambdabot>   5
14:32:19 <roconnor> newType Empty = Empty Empty   -- is Haskell '98
14:32:21 <monochrom> the semiring-ness of types doesn't seem very interesting
14:32:24 <aidalgol> aristid: Of course.
14:32:27 <azaq23> 48 == ascii 0
14:32:31 <copumpkin> monochrom: probably not :P
14:32:37 <aristid> aidalgol: ord returns the unicode code point of a character
14:32:39 <roconnor> monochrom: huh?
14:32:44 <copumpkin> isn't it where the "algebraic" part comes in ADT though?
14:32:48 <napping> lispy1: did you ever sort out that Map thing?
14:32:49 <aidalgol> Oh, OK.  That makes sense.
14:34:07 <Esteth> I don't understand this "Overlapping instances" error I'm getting. Could anybody clue me in? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28771
14:34:50 <napping> lispy1: if not, I have some evil to offer.
14:35:34 <Phyx-> quick offtopic question to you lot, is http://phyx.pastebin.com/yDyCWuaM a valid regexpr?
14:36:04 <monochrom> you need to escape $ too
14:36:15 <Phyx-> aha *does*
14:36:24 <monochrom> and escape .
14:36:25 <Phyx-> it's currently not doing anything :(
14:36:50 <monochrom> escape codes and plain text files must die
14:36:57 <EvanR-work> you must placate the pagan god of regex
14:37:04 <Phyx-> lol
14:37:10 <EvanR-work> before it works black magic on your input stream
14:37:26 <Phyx-> i'm generating those from my candy file
14:37:44 <monochrom> and escape ^
14:37:55 * ezyang sighs, and inserts another level of hierarchical organization. 
14:38:01 * CoolNelly sings *Gotta a black magic input stream, gotta black magic input stream...*
14:38:05 <EvanR-work> where does the name 'ord' come from? it seems to be in every language except C
14:38:11 <monochrom> ordinal
14:38:29 <monochrom> @quote monochrom nth
14:38:29 <lambdabot> No quotes match. Just try something else.
14:38:31 <EvanR-work> but its not the ordinal of any ordinal value, only characters
14:38:38 <monochrom> preflex: quote . nth
14:38:40 <preflex>  <evilgeek> dwarf fortress is awesome. unfortunately, it made me finish my master's four months late.
14:38:47 <monochrom> preflex: quote monochrom nth
14:38:47 <preflex>  <monochrom> n is the nth English letter.
14:38:57 * Phyx- tries again
14:39:25 <monochrom> ord was present in basic, too
14:39:43 <monochrom> C doesn't need it because char and int are unified
14:39:51 <Phyx-> monochrom: do i need to escape : too?
14:40:00 <monochrom> Perl doesn't need it because string and int are unified
14:40:08 <EvanR-work> order has ord anyway
14:40:10 <EvanR-work> err perl
14:40:10 <mauke> monochrom: what
14:40:11 <aristid> @quote ord
14:40:11 <lambdabot> mreh says: right, I understand list monad now, now I need to "takeWhile the sum of the list is less than x", I think like kinky sex games, some zips are in order
14:40:24 <Phyx-> lol, epic fail :(
14:40:27 <monochrom> I don't think : needs escaping
14:41:11 <Phyx-> the final one i have is http://phyx.pastebin.com/qrbyJpCn
14:41:35 <EvanR-work> js decided to go out on a limb and call it charCodeAt
14:41:54 <monochrom> "meaningful" names
14:42:10 <aidalgol> (For those who think they were doing my homework, my assignment is to write a function to convert a string of digits in base 2,8, or 16 to base 10.)
14:42:32 <EvanR-work> a string of digits in base 10 ?
14:43:04 <aidalgol> No, convertToDecimal :: StringOfDigits -> Base -> (Digit -> Int) -> Int
14:43:13 <mauke> that doesn't convert to decimal
14:43:16 <monochrom> Int is not decimal
14:43:17 <mauke> it converts to a number
14:43:21 <aidalgol> I know.
14:43:27 <aidalgol> That's just the type.
14:43:33 <mauke> no, that's what it does
14:43:45 <monochrom> the values of that type are not decimal either
14:43:57 <aidalgol> (Come to think of it, pasting the type was pretty dumb.)
14:44:27 <EvanR-work> convert a string of digits in 2 8 or 16 into a number
14:44:47 <monochrom> if you invoke "but it's decimal when I print", that's just UI illusion
14:45:13 <aidalgol> Uh, good point.
14:45:19 * aidalgol slaps himself.
14:45:22 <EvanR-work> compute a comma separated sequence of numbers enclosed in square brackets
14:45:40 <aidalgol> Duh.  Computers just store numbers.  They don't know about number-base.
14:45:52 <monochrom> it is not like booleans are really stored as 't','r','u','e' anyway. would be stupid to.
14:45:54 <EvanR-work> we like to think of it as abstract numbers
14:46:06 <aidalgol> I really should never have forgotten that.
14:46:07 <EvanR-work> they really have some representation
14:46:49 <aidalgol> I know.
14:47:18 <Phyx-> monochrom: works now :)
14:47:22 <EvanR-work> in smalltalk its lists of numbers between 0 and 255 or something ;)
14:48:04 <aidalgol> I think in Smalltalk the address otherwise used to store the reference to the object is used to store the actual value of the Integer.
14:48:26 <aidalgol> For numbers up to a certain size only.
14:50:00 <EvanR-work> i store all my numbers on a base 10 abacus
14:50:29 <EvanR-work> i can easily multiply and divide by 10 ;)
14:51:22 <aidalgol> I can not believe that I am being told to "google it" in my assignment.
14:51:51 <monochrom> perhaps you should bing it just to be rebellious
14:51:56 <medfly> hehehe
14:52:01 <EvanR-work> >_<
14:52:38 <aidalgol> Or PicSearch or Cuil (OK maybe not Cuil) or just Wikipedia.
14:52:38 <monochrom> or be both rebellious and creative: build your own web page that gives your own definition and examples.
14:52:52 <aidalgol> In Haskell!
14:52:53 <leifw> haha cuil
14:53:42 <fxr> > forever $ forkIO $ fix id
14:53:43 <lambdabot>   Not in scope: `forkIO'
14:53:43 <monochrom> there is a market of writing a web page to say exactly what a customer wants me to say
14:53:56 <fxr> bah
14:54:10 <aidalgol> They want me to convert a string of digits in *any* base, but when do I stop?
14:54:21 <monochrom> when the string stops
14:54:34 <leifw> when you run out of characters to represent values less than your base?
14:54:40 <monochrom> if the string doesn't stop, it is not your fault, don't worry about it.
14:55:02 <aidalgol> leifw: Exactly.
14:55:10 <napping> darn, ghc seems to be handling type classes differencely
14:55:14 <aidalgol> But what do I use after 'Z'?
14:55:15 <aavogt> so any includes irrational, imaginary and so on
14:55:24 <aidalgol> Eek!
14:55:29 <napping> Oh, right, a data type :)
14:55:33 <EvanR-work> aidalgol: see 'base64' ;)
14:55:36 <aidalgol> OK, they could've been less vague.
14:56:00 <monochrom> I see, "base 9384938290000" would be pretty hard
14:56:07 <EvanR-work> aidalgol: literally you could define the 'digits' to be any unicode character
14:56:20 <EvanR-work> but it wont match up with "1234"
14:56:36 <EvanR-work> then you have do base 0x10ffff
14:56:40 <EvanR-work> can do
14:56:44 <aavogt> take a list of digits
14:57:02 <aidalgol> And for some idiotic reason, I have to use a higher-order function to convert the digits to ints, instead of Haskell's type system.
14:57:08 <monochrom> anyway, yes, everyone should learn to be less vague.
14:57:26 <EvanR-work> the type system doesnt convert anything
14:57:36 <aavogt> EvanR-work: it can
14:57:48 <aidalgol> So, uh, they can't have expected us to handle 64 cases.
14:58:00 <aidalgol> Especially as this a programming languages class.
14:58:07 <mauke> write one generic case with a parameter
14:58:24 <EvanR-work> aavogt: like, when you write 5 ?
14:58:27 <EvanR-work> or 3.1
14:58:59 <monochrom> write a new programming language. then just say "you can program the computer to do conversions in this new language"
14:59:23 <aavogt> EvanR-work: you ask ghci for a type which you've specified
15:02:05 <aidalgol> Turns out they only wanted us to write a function that's generic enough that it *could* handle any number system.
15:02:17 * aidalgol shakes his head and goes back to work.
15:02:35 <napping> how are dictionaries represented?
15:02:47 <mauke> in books
15:02:49 <hpc> on a bookshelf :P
15:02:50 <aavogt> napping: codex
15:03:22 <napping> you mean commentary?
15:03:35 <monochrom> OED represents it as an xml file. Or a lot of xml files.
15:05:59 <napping> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28774#a28774
15:06:06 <napping> why does sanityTest segfault?
15:06:11 <aidalgol> Can I use if-then-else or case within a let?
15:06:22 <napping> sure, why not?
15:06:37 <napping> have to respect indentation, I guess
15:06:57 <aidalgol> I wasn't sure if that could work for declarations.
15:07:17 <kyagrd> I remember there was some chagne to if-then-else indentation in Haskell 2010
15:07:28 <monochrom> I know the feeling. Having been burned by stupid previous languages with arbitrary restrictions like that.
15:07:38 <dcoutts_> aidalgol: if-then-else is an expression, not a declaration
15:08:27 <kyagrd> and (let <decl> in <exp>) is also an expression
15:08:34 <aidalgol> Which is why I thought they might not be allowed within a let ... in (between the let and in, to be precise).
15:09:02 <kyagrd> aidalgol: note delclaration can have the form <pat> = <exp>]
15:09:02 <napping> oh, you can't have one of those around a set of bindings, no
15:09:17 <napping> but let <pat> = if .. in ... is fine
15:09:19 <kyagrd> so it can appear in the right hand side
15:09:28 <aidalgol> Of course.
15:09:42 <napping> writing a let at the very top level outside a definition wouldn't parse very well either
15:10:23 <hpc> a top-level "in" is a "where", for certain concepts of top-level
15:10:45 <napping> so, no ideas about the segfault?
15:10:49 <kyagrd> if you want something conditional names of bindings in compile time you should either use Template Haskell or {-# LANGUAGE CPP #-} thing
15:13:37 <dcoutts_> napping: crikey, that is evil
15:14:12 <hpc> what is that case /intended/ to do?
15:14:41 <napping> replace the Eq dictionary with one you provide
15:14:58 <napping> it's slightly more sane in the with form
15:15:10 <dcoutts_> napping: ok, my guess is that it's because you cannot construct a dictionary that way, dictionaries are strict
15:15:12 <napping> that takes a (forall a . (Eq a) -> ...), so at least you don't lose coherence
15:15:49 <napping> they are strict?
15:15:56 <Heffalump> can you use GeneralizedNewtypeDeriving to fake a dictionary somehow?
15:16:14 <napping> well, the the core they are distinctly passed as values
15:16:23 <napping> classes of single methods actually just get newtyped
15:16:38 <napping> the rest seem to be algebraic data, but I wasn't reading the strictness annotations
15:16:48 <BMeph> :t showIntAtBase -- ssh! ;)
15:16:49 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
15:17:06 <dcoutts_> napping: so obviously what you're doing is crazy, the question is what you're really trying to do
15:17:15 <kyagrd> What would be a good way to install Hackage package documentation locally, other than extracting an archive and running 'cabal haddock' for each package?
15:17:47 <mjrosenb_> longshot w.r.t. base libe
15:17:49 <ezyang> kyagrd: Tweak your .cabal settings 
15:18:02 <monochrom> in .cabal, "documentation: True"
15:18:06 <kyagrd> ezyang: http://hackage.haskell.org/trac/hackage/ticket/707 for this reason that is not possible
15:18:14 <mjrosenb_> @hoogle [a->Int] -> [a] ->[[a]]
15:18:14 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
15:18:14 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
15:18:15 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
15:18:15 <monochrom> err, in .cabal/config
15:18:17 <kyagrd> monochrom: there is a bug for that (the liknk abouve)
15:18:30 <ezyang> yeah. I've sort of ignored that... 
15:18:48 --- mode: kornbluth.freenode.net set +oo Igloo Heffalump
15:18:54 <mjrosenb_> looks like no :(
15:19:02 <napping> hmm, are you saying dictionaries are passed strictly?
15:19:19 <monochrom> it doesn't happen to me
15:19:32 <dcoutts_> kyagrd: hmm, that's an interesting bug, never seen that before. Can you post more details in that ticket so we can reproduce it.
15:19:54 <dcoutts_> kyagrd: does it happen in the build step or during the haddock step?
15:20:14 --- mode: Heffalump set -o Heffalump
15:20:37 <monochrom> for example, in my locally built hxt doc via "documentation: True", "IO" links to share/doc/ghc/html/libraries/base-4.2.0.2/System-IO.html#t%3AIO correctly
15:20:59 <napping> ah, it seems to need compiled code
15:21:42 <chrisdone> Twey: ;-) alright?
15:22:01 <kyagrd> monochrom: link error. documentation installs okay but linker doesn't link the right base
15:22:07 <napping> dcoutts_: mostly I'm trying to do evil
15:22:17 <dcoutts_> heh :-)
15:22:40 <napping> though creating skolem types equipped with instances at runtime is sometimes handy
15:22:46 <monochrom> still doesn't happen to me
15:22:57 <napping> but you can usually get by with existing instances, selected by polymorphic recursion
15:23:08 <dcoutts_> kyagrd: post what details you can to the ticket
15:23:17 <monochrom> I have used "documentation: True" for a long time
15:23:20 <kyagrd> monochrom: are you using linux?
15:23:23 <monochrom> yes
15:23:35 <kyagrd> hmm
15:23:46 <Phyx-> netsplit
15:23:47 <Phyx-> wooho
15:24:13 <kyagrd> I'll try to make a minimal example. It didn't happend to me before but recently I had a problem with the RepLib library a generic programming library that uses Template Haskell.
15:28:06 <monochrom> I'm at ghc 6.12.3, Cabal 1.8.0.6, cabal-install 0.8.2 if it hurts. basically haskell-platform current release
15:28:49 <monochrom> but I did use 6.12.1 1.8.0.2 etc (basically last haskell-platform) for a while and still didn't notice it
15:29:47 <chrisdone> nice, just simplified a function that was confusing me. sometimes a bunch of case expressions is better than point free functions
15:30:39 <chrisdone> 500 Internal Server Error
15:30:39 <chrisdone> 58030 5: Unable to close due to unfinalised statements
15:30:43 <chrisdone> go to hell, hpaste!
15:31:14 <hpc> you got a 500 from unreleased server resources? your luck sucks
15:32:09 <chrisdone> I haven't had these database problems. I'm using hdbc with postgresql. no issues
15:32:17 <chrisdone> anyway, mm refactorisation http://paste.lisp.org/display/113350
15:32:45 <chrisdone> funnily it started like the second one, then I thought I'd "refactor" it. a week later I come back to it and I can't understand it
15:32:46 <EvanR-work> i read that as "unable to close due to unfalsified statements"
15:33:42 <dcoutts_> kyagrd: oh, I wonder if you're hitting the mysterious TH package bug
15:34:20 <dcoutts_> kyagrd: which we think is a ghc bug, if you can reproduce that then that'd be jolly useful
15:35:10 <aidalgol> The ⊕ operation is irreversible, correct?
15:35:23 <monochrom> sorry, what is "irreversible"?
15:35:33 <copumpkin> IT'S TOO LATE TO APOLOGIZE
15:35:34 <copumpkin> TOO LATE
15:35:58 <monochrom> doesn't stop me from doing it :)
15:36:14 <copumpkin> :)
15:36:18 <aidalgol> I mean this is not the reverse operation: let x⊝y = (x-y)/base in foldl1 (⊝) (map digitToInt (show from))
15:36:34 <copumpkin> aidalgol: what is ⊕?
15:36:37 <mjrosenb> aidalgol: did that use unicode?
15:36:43 <medfly> chrisdone, you just discovered?
15:36:51 <maximander> I'm just playing with haskell for the first time and wondering how to compare an IO 'x to a 'x… or in general, how to get the raw value from the one wrapped by the monad?
15:36:53 <monochrom> ⊕ is x⊕y = x*10+y
15:37:12 <aidalgol> s/10/base/
15:37:19 <EvanR-work> maximander: you have to execute the IO x to get the x
15:37:20 <chrisdone> dcoutts_: oh hey, can you explain how I can provide -odir to cabal build? with cabal build -v --ghc-option=-odir=foo, I get: /home/chris/Programs/bin/ghc -odir=foo [ .. lots of other args ..] -odir dist/build/confy/confy-tmp. so my -odir argument is kind of useless. how can I override it?
15:37:25 <hpc> are x and y both modulo base?
15:37:29 <monochrom> I don't know what "reversible" or "invertible" means for binary operators.
15:37:35 <hpc> with that assumption, you can reverse the operation
15:38:07 <aidalgol> monochrom: subtraction is the inverse of additon.
15:38:15 <aidalgol> 3+4 = 12
15:38:35 <aidalgol> I mean 3+4 = 7
15:38:40 <hpc> haha
15:38:42 <EvanR-work> (+4) is the inverse of (subtract 4)
15:38:44 <EvanR-work> or something
15:38:45 <maximander> EvanR-work: I'm trying to write a little function to compare a random number to a constant… any guidance would be appreciated 
15:38:46 <aidalgol> 7-4 = 3
15:38:57 <chrisdone> maximander: to get from a value of IO a to a, a function of type IO a -> (a -> IO b) -> IO b will be involved
15:39:02 <monochrom> yes, - is "the inverse of" +, only after we decide that 0 is the identity. / is "the inverse of" *, only after we decide that 1 is the identity. What is the identity now?
15:39:12 <dcoutts_> chrisdone: -odir is for redirecting build output right? you cannot control that individually (cabal controls the layout of the built files) but you can change the location of whole dist/ directory
15:39:16 <EvanR-work> maximander: have you looked through some of the tutorials like learn you a haskell?
15:39:38 <Berengal> Doesn't TH work with ScopedTypeVariables?
15:39:39 <BMeph> x, y, base, mult-sum: pick two. :)
15:39:46 <dcoutts_> chrisdone: if you did manage to sneak -odir to ghc then all you'd do is to break the build because then cabal would not know where to look for things
15:40:19 <chrisdone> dcoutts_: hmm, ok. I wanted to set -odir to be src/, so that ghci would load files faster. but instead I guess I'll have to somehow figure out where the :set -odir should be for ghci to pick up
15:40:27 <chrisdone> dcoutts_: oh, ok
15:40:51 <dcoutts_> chrisdone: ah right, yes, you can call ghci such that it picks up the files built by cabal
15:40:56 <BMeph> E.g., (3,4) -> (5,12) -- (x,y)  (b, ⊕)
15:41:23 <dcoutts_> chrisdone: probably just -hidir, -odir set to dist/build
15:41:42 <chrisdone> dcoutts_: but what if I have several build directories?
15:42:11 <dcoutts_> chrisdone: then select the appropriate one, i.e. for the lib/exe in question
15:42:13 <chrisdone> or can I provide multiple -odir args? that's a point
15:43:15 <chrisdone> dcoutts_: I want to do it automatically, hrm
15:43:22 <ezyang> Hmm... haddock doesn't like c2hs. 
15:44:10 <Berengal> cabal interactive would be nice...
15:44:37 <ezyang> oh, nvm. 
15:44:37 <dcoutts_> chrisdone: unfortunately you really have to pick the right context, since cabal can end up building the same module different ways in different contexts, e.g. if a module is used in a lib and an exe, or two different components that use different flags.
15:44:44 <dcoutts_> Berengal: there's an open ticket on that
15:45:06 <chrisdone> dcoutts_: yeah, i'm aware, that's my problem
15:45:15 <chrisdone> this is difficult to figure out: :set -odir=../dist/build/confy/confy-tmp/
15:45:49 <chrisdone> >_<
15:45:50 <mornfall> Is there an iterate-until-fixpoint somewhere handy? (fix doesn't do what I want, it seems...)
15:46:20 <aavogt> @type until
15:46:21 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
15:46:25 <mornfall> Or maybe I am too stupid to use it. :D
15:46:39 <chrisdone> dcoutts_: hmmm. I suppose what I could do is at least provide an easy ido-mode context choice to switch between
15:46:49 <chrisdone> dcoutts_: I suppose that's not so bad
15:47:10 <dcoutts_> chrisdone: what's the context? is this for an emacs mode or something?
15:47:11 <mornfall> Like until (\a -> a == f a)?
15:47:21 <aavogt> @type \f x -> until (uncurry (==)) (\(a,b) -> (f a,a)) (f x,x)
15:47:21 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> (a, a)
15:47:29 <chrisdone> dcoutts_: yeah, just extending the inferior haskell mode
15:47:50 <dcoutts_> chrisdone: ah ok, well if you're trying to do it reliably then you need to do a bit more
15:48:06 <dcoutts_> chrisdone: you'll need basically all of the flags that cabal passes to ghc --make
15:48:41 <chrisdone> dcoutts_: in order to reliably load the .o files?
15:48:58 <aavogt> mornfall: or that
15:48:58 <dcoutts_> chrisdone: to get the right environment/context
15:49:02 <chrisdone> nightmare
15:49:07 <monochrom> kyagrd: I still cannot reproduce it with RepLib, both installing RepLib and trying to use RepLib.
15:49:08 <chrisdone> then again not
15:49:11 <dcoutts_> chrisdone: in particular all the package flags
15:49:39 <dcoutts_> chrisdone: think about it, you want the same context in ghci as you're using when compiling the thing
15:49:39 <chrisdone> dcoutts_: actually that's probably totally do-able. I can run cabal build -v and inspect what it uses, for each exe/lib. and then set them in ghci
15:49:43 <McManiaC> can someone help me? I got curl installed by cabal can't find the libraries: http://npaste.de/fV/
15:50:23 <mornfall> let fixpoint f = until (\a -> f a == a) f
15:50:26 <mornfall> Hooray. :)
15:50:41 <mornfall> Clear sign that I should have been sleeping.
15:50:51 <ski> monochrom : that `b' is the right inverse of `a' (wrt `*') means that for every `c', `(c * a) * b = c'
15:50:57 <chrisdone> dcoutts_: right?
15:51:07 <dcoutts_> chrisdone: right, that'll show you all the cpp flags etc as well
15:51:30 <chrisdone> nice :-)
15:51:36 <dcoutts_> chrisdone: you might be able to do it slightly more reliably by using --with-ghc=hacky-wrapper
15:51:57 <dcoutts_> chrisdone: or you could just help us implement the thing properly in cabal :-)
15:52:06 <monochrom> ski: well the OP talked of reverse operators rather than reverse elements
15:52:18 <dcoutts_> chrisdone: http://hackage.haskell.org/trac/hackage/ticket/382
15:52:28 <McManiaC> "See `config.log' for more details." <- whats that config.log anyways?
15:52:57 <ski> monochrom : yeah, so `(c * a) / a = a' (resp. `a \ (a * c) = c') ..
15:53:17 <dcoutts_> McManiaC: it needs the curl libraries, not just curl.exe
15:53:28 <ski> <http://en.wikipedia.org/wiki/Quasigroup>
15:53:31 <McManiaC> dcoutts_: they're there... libcurl.dll etc
15:53:42 <dcoutts_> McManiaC: cabal/ghc/gcc need to be able to find them
15:54:16 <McManiaC> http://npaste.de/fW/
15:54:30 <McManiaC> dcoutts_: do you know how this works on windows? ^
15:54:49 <McManiaC> I thought I just add that C:\curl\bin to my PATH
15:54:58 <dcoutts_> McManiaC: and I expect it needs the header files too
15:55:28 <chrisdone> dcoutts_: for my problem, is reading the -v output insufficient?
15:55:49 <McManiaC> dcoutts_: they're in C:\curl\include - but I guess cabal doesnt know about them
15:55:58 <dcoutts_> chrisdone: no, just rather fragile
15:56:19 <mornfall> I just wrote consistent E is True `iff` ...
15:56:35 <dcoutts_> McManiaC: cabal has flags so you can tell it to look in non-standard places, I'm not sure if the curl package's configure script will respect that however.
15:57:57 <McManiaC> dcoutts_: what flags?
15:58:17 <dcoutts_> McManiaC: see --help, it's something like --extra-include-dirs, --extra-lib-dirs
15:59:53 * hackagebot pcre-light 0.4 - A small, efficient and portable regex library for Perl 5 compatible regular expressions  http://hackage.haskell.org/package/pcre-light-0.4 (DonaldStewart)
16:01:16 <McManiaC> dcoutts_: doesnt help :(
16:01:23 <McManiaC> dcoutts_: do you know what that config.log is?
16:01:53 <dcoutts_> McManiaC: it's something written by the ./configure script
16:02:04 <McManiaC> ah
16:02:15 <dcoutts_> McManiaC: you'll need to unpack the curl package and cabal configure
16:03:02 <chrisdone> dcoutts_: trying it, it seems to work okay... right now, I'm happy if it works for most projects. looking at this patch for cabal interactive, it seems to do the same thing?
16:03:11 <dcoutts_> McManiaC: technically it's a bug in the curl package that it does not respect that flag (ie does not pass it on to the ./configure script)
16:04:18 <Phyx-> space is \s in regexpr right?
16:04:24 <McManiaC> http://npaste.de/fX/ well hm... :S
16:04:30 <McManiaC> thats that config.log
16:04:32 <Phyx-> yo lispy1, lispy you around :P
16:05:20 <EvanR> maximander: did you figure it out yet
16:05:40 <dcoutts_> chrisdone: I'm not quite sure what you mean about it doing the same thing, I'm not sure what you're asking.
16:06:07 <chrisdone> I'm probably misreading it, n/m
16:08:20 <maximander> EvanR:  actually got distracted and moved on to next language (trying to write the same little program in many languages)
16:08:34 <EvanR> oh
16:08:47 <tolkad> I'm trying to understand monads.... they basically let you write a series of function applications in backwards order with possible interactions between hidden variables going on?
16:09:18 <EvanR> hidden variables theorem
16:09:31 <tolkad> what?
16:09:39 <EvanR> maximander: which program exactly, you didnt explain that
16:09:52 <tolkad> I mean, I think that's what they are for
16:10:03 <tolkad> but I'm not really sure what else they can be used for besides IO
16:10:14 <amontez> tolkad: did you read Real World Haskell?
16:10:19 <copumpkin> tolkad: I wouldn't think of it that way, or try to learn it that way
16:10:27 <tolkad> amontez: no, I read learn you a haskell for great good
16:10:27 <copumpkin> tolkad: in fact, I wouldn't try to learn them at all this early in the game
16:10:53 <EvanR> function application is the one who is in reverse order ;)
16:11:09 <EvanR> f . g . h . i $ x
16:11:11 <Phyx-> lispy or lispy , when you get back, new addition of the day http://mistuke.wordpress.com/2010/08/10/configurable-candy/
16:11:13 <EvanR> <------
16:11:15 <Phyx-> :)
16:11:25 <copumpkin> Phyx-: lispy or lispy!
16:11:31 <EvanR> monads let you forward!
16:11:35 <EvanR> go
16:11:46 <siracusa> Is there a way to make GHCi load a package from source code in directory A and then load a file with its modules from a directory B?
16:12:01 <aavogt> siracusa: -i  flag?
16:12:02 <writer> is there any equivalent of Lisp's macroexpand for Template Haskell ?
16:12:03 <tolkad> :t ($)
16:12:04 <lambdabot> forall a b. (a -> b) -> a -> b
16:12:05 <maximander> EvenR: find e by summing random floats [0-1]
16:12:08 <tolkad> :t (.)
16:12:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:12:15 <maximander> EvanR: er, (0,1)
16:12:20 <EvanR> maximander: interesting
16:12:25 <siracusa> aavogt: What does -i do?
16:12:41 <EvanR> maximander: so you dont need an IO action for that
16:12:42 <aavogt> siracusa: add a directory to the search path
16:12:57 <copumpkin> Haskell. There's an IO action for that.
16:13:23 <tolkad> > add . add 4
16:13:24 <lambdabot>   Not in scope: `add'Not in scope: `add'
16:13:29 <tolkad> err
16:13:34 <EvanR> > take 10 (randoms (mkStdGen 0)) :: [Double]
16:13:35 <lambdabot>   [0.9872770354820595,9.953806877591176e-4,0.9737700946800807,0.1302804380260...
16:13:38 <Phyx-> copumpkin: nick completion fail
16:13:41 <tolkad> > (+4) . (+4) 5
16:13:42 <lambdabot>   No instance for (GHC.Num.Num (f a))
16:13:42 <lambdabot>    arising from a use of `e_1445' at <i...
16:13:47 <aavogt> siracusa: in case you have say     a/A.hs  b/B.hs main.hs which imports A, B,   you can get them all loaded with     ghci main.hs -ia -ib 
16:13:51 <tolkad> > ((+4) . (+4)) 5
16:13:52 <Phyx-> copumpkin: was supposed to be lispy and lispy1 
16:13:52 <lambdabot>   13
16:13:57 <copumpkin> Phyx- :)
16:14:09 <aavogt> writer: can you describe macroexpand?
16:14:47 <writer> aavogt: it expands the macro.
16:15:10 <tolkad> what's all that Functor stuff about? shouldn't the type signature for (.) look like (a -> b) -> (c -> a) -> (c -> b)?
16:15:13 <aavogt> writer: you know what $v  does?
16:15:21 <aavogt>  where   v :: Q Exp
16:15:49 <writer> aavogt: Sorry, I'm just reading TH paper, and tutorial, and this will be mentioned later.
16:16:04 <writer> s/and /and if /
16:16:29 <siracusa> aavogt: This works great, thanks a lot
16:16:46 <azaq231> tolkad: ((->) t) is an instance of functor
16:17:01 <McManiaC> dcoutts_: Installing library in
16:17:01 <McManiaC> C:\Users\Nils\AppData\Roaming\cabal\curl-1.3.5\ghc-6.12.1
16:17:01 <McManiaC> Registering curl-1.3.5...
16:17:02 <McManiaC> wooohooo
16:17:03 <azaq231> you can see (.) (compose) as the fmap of functors
16:17:03 <McManiaC> :D
16:17:16 <aavogt> writer: well I think those two are the same: get the code that the 'macro' represents
16:17:26 <dcoutts_> McManiaC: so what was the solution?
16:17:33 <tolkad> azaq231: wtf? (->) is a function?
16:17:54 <azaq231> -> can be see as a data constructors
16:17:57 <McManiaC> dcoutts_: I copied C:\curl\include\* to C:\MinGW\include
16:18:04 <tolkad> oh
16:18:08 <dcoutts_> McManiaC: oh, heh
16:18:11 <McManiaC> don't know how to tell that compiler suit how to look in curl\include
16:18:12 <McManiaC> :)
16:18:15 <McManiaC> but it build
16:18:16 <azaq231> a function a -> b -> c is in reality the data type a -> (b -> c)
16:18:16 <McManiaC> :)
16:18:23 <writer> aavogt: okay. thanks for the hint
16:18:25 <azaq231> so its like data Function a b
16:18:34 <azaq231> just with an haskell internal infix syntax
16:18:48 <azaq231> you can define a functor on this type
16:18:55 <tolkad> haskell just keeps getting stranger
16:18:57 <azaq231> -> has kind * -> * -> *
16:19:05 <azaq231> functors have to have kind * -> *
16:19:16 <azaq231> to ((->) t) is correct
16:19:21 <monadic_kid> you mean type constructor, not data constructor
16:19:23 <azaq231> for a functor instance
16:19:24 <aavogt> :k ->
16:19:25 <lambdabot> parse error on input `->'
16:19:28 <aavogt> :k (->)
16:19:29 <lambdabot> ?? -> ? -> *
16:19:44 <azaq231> monadic_kid: yes, thanks
16:19:46 <tolkad> :k (->) . (->)
16:19:47 <lambdabot> parse error on input `.'
16:19:54 <tolkad> :k (->) -> (->)
16:19:55 <lambdabot>     `(->)' is not applied to enough type arguments
16:19:55 <lambdabot>     Expected kind `??', but `(->)' has kind `?? -> ? -> *'
16:20:01 <EvanR> tolkad: if your head doesnt explode once per hour, youre doing it wrong
16:20:04 <tolkad> :k (->) -> (->) (->)
16:20:05 <lambdabot>     `(->)' is not applied to enough type arguments
16:20:05 <lambdabot>     Expected kind `??', but `(->)' has kind `?? -> ? -> *'
16:20:15 <tolkad> wait where is it not applied to enough?
16:20:19 <tolkad> oh I see
16:20:23 <tolkad> uh hmm
16:20:42 <tolkad> :k (->) -> (-> a)
16:20:43 <lambdabot> parse error on input `a'
16:20:58 <azaq231> tolkad: Just like you would apply, say, Int to Maybe to get Maybe Int you can apply Int and Int to -> to get (Int -> Int)
16:21:00 <tolkad> :k forall a. (->) -> ((->) a)
16:21:01 <azaq231> on the type level
16:21:01 <lambdabot>     `(->)' is not applied to enough type arguments
16:21:01 <lambdabot>     Expected kind `??', but `(->)' has kind `?? -> ? -> *'
16:21:01 <lambdabot>     In the type `(->) -> ((->) a)'
16:21:22 <tolkad> :k forall a b c d. (a -> b) -> (c -> d)
16:21:23 <lambdabot> *
16:21:27 <azaq231> type constructors are basically functions on the type level, you can't build normal expressions with them
16:21:48 <azaq231> * is named the a kind, and it's basically the type of types
16:21:59 <dcoutts_> McManiaC: btw, I think it should work if you edit the package to use build-type: Simple
16:22:08 <hpc> what's the term for a type constructor that takes a higher-kinded type as a parameter?
16:22:16 <tolkad> so what do you call types of kinds?
16:22:29 <copumpkin> tolkad: supposedly sorts, but haskell doesn't have those
16:22:35 <copumpkin> other languages have an infinite tower of universes
16:22:53 <tolkad> copumpkin: countably infinite?
16:23:04 <dcoutts_> dons: do you still maintain the curl package? I think you can unbreak it on windows by deleting some old build stuff (the nicest sort of fix :-) )
16:23:06 <McManiaC> dcoutts_: http://npaste.de/fY/
16:23:16 <tolkad> I'd prefer it not to be
16:23:26 <copumpkin> tolkad: yeah
16:23:27 <azaq231> tolkad: there are different perspectives - in more formal discussions there is a type which is seen like a square which is the type of type and then the hierarchy just stops, but you can also define *'s kind to be * itself - python does something like that with it's type object
16:23:46 <azaq231> in haskell, the type of * does not exist if I'm not mistaken
16:23:59 <copumpkin> tolkad: it'd make sense for it to be, since you have Set, whose types is Set1, whose type is Set2, etc.
16:24:13 <copumpkin> plus, everything on a computer is countable
16:24:33 <dcoutts_> McManiaC: does "ghc-pkg field curl extra-libraries" report "curl" ?
16:24:34 <lvh> hi
16:24:49 <lvh> how do I get the index of a character in a string?
16:24:51 <azaq231> tolkad: Now for the functor instance of ((->) t): instance Functor ((->) t) where fmap = (.)
16:24:54 <McManiaC> dcoutts_: yep
16:25:10 <hpc> :t find
16:25:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:25:14 <lvh> Python equivalent: "abcdef".index("b") # == 1
16:25:27 <hpc> @hoogle [a] -> a -> Int
16:25:28 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
16:25:28 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
16:25:28 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
16:25:39 <dcoutts_> McManiaC: then probably it's a mismatch in the curl library version
16:25:46 <monadic_kid> lvh: elemIndex
16:25:53 <azaq231> (a -> b) -> (t -> a) -> (t -> b) = (a -> b) -> f a -> f b
16:25:54 <lvh> hpc: elemIndex looks promising thanks
16:26:01 <azaq231> which is compose's type
16:26:09 <dcoutts_> McManiaC: see if you get a similar error with compiling a standalone program with ghc --make
16:26:20 <azaq231> so compose actually lifts a function into another one
16:26:53 <azaq231> (or better worded, it lifts a function into  the functor - which is a function, so -->)
16:28:35 <osaunders> In types can a represent a -> a?
16:28:45 <aristid> yes
16:28:48 <osaunders> or b -> b, for that matter.
16:28:55 <McManiaC> dcoutts_: http://npaste.de/fZ/
16:29:28 <hpc> or b -> c
16:29:33 <osaunders> :t (\f x -> f f x)
16:29:34 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
16:29:34 <lambdabot>     Probable cause: `f' is applied to too many arguments
16:29:34 <lambdabot>     In the expression: f f x
16:29:43 <osaunders> Why can't you do that?
16:29:52 <dcoutts_> McManiaC: so its missing links to the ssl libs
16:29:56 <hpc> because you are making a = a -> a
16:30:06 <dcoutts_> McManiaC: what did "ghc-pkg field curl extra-libraries" report?
16:30:08 <hpc> which == (a -> a) -> (a -> a)
16:30:12 <McManiaC> osaunders: \f x -> f (f x)
16:30:13 <hpc> which == etc
16:30:27 <osaunders> McManiaC: No, that's not what I want to do.
16:30:39 <osaunders> hpc: Ah, OK.
16:30:39 <McManiaC> dcoutts_: C:\Users\Nils>ghc-pkg field curl extra-libraries
16:30:39 <McManiaC> extra-libraries: curl
16:31:38 <hpc> a similar example would be f = flip f
16:31:41 <dcoutts_> McManiaC: and presumably C:\curl\lib\ also contains some ssl .a library?
16:31:47 <hpc> the recursion has an effect on the type of the function
16:31:54 <hpc> in this case limiting f to a -> a -> b
16:32:04 <McManiaC> dcoutts_: libssl.a
16:32:34 <McManiaC> http://npaste.de/fa/
16:33:17 <dcoutts_> McManiaC: ok, so really this is a problem with the curl binding
16:33:33 <dcoutts_> McManiaC: it only lists the curl lib, when it actually needs to list curl and the ssl lib
16:33:53 <dcoutts_> it probably ought to be using the curl-config program to discover what libs to list
16:34:15 <dcoutts_> McManiaC: you ought to take these issues up with the package maintainer
16:34:40 <McManiaC> dcoutts_: of haskell curl or libcurl itself?
16:34:47 <dcoutts_> McManiaC: the haskell binding
16:34:51 <McManiaC> ok
16:34:56 <dcoutts_> though you may be able to hack it by modifying the package yourself, e.g. to add the ssl lib to the extra libraries
16:36:02 <sexykitn> anyone know why getCPUTime in ghc on a 64-bit Mac (10.6) would return bad values?
16:36:55 <copumpkin> sexykitn: nope, but it's worth reporting a bug for it probably
16:38:30 <Phyx-> does anyone know what might be causing this panic? "Testing for extension flag Opt_Generics before flattening"
16:38:38 <Phyx-> it started after i pulled the latest
16:44:38 <Igloo> Phyx-: You need to flattenExtensionFlags before you do anything that tests extensions
16:52:05 <tolkad> are Chars multibyte characters?
16:52:27 <tolkad> I think they are...
16:52:36 <tolkad> what should I do if I want to parse ASCII with parsec?
16:52:38 <Philippa> they're required to accept any unicode codepoint, IIRC
16:52:46 <Philippa> you should feed an ASCII stream in
16:53:03 <tolkad> what would I use? all the socket things return Strings
16:53:11 <tolkad> HTTP is ASCII
16:53:22 <FunctorSalad> hmm what's the problem?
16:53:38 <FunctorSalad> String is supposed to be abstract characters in no particular encoding
16:53:41 <FunctorSalad> I think...
16:53:43 <Philippa> the problem is tolkad expecting things to be more typeful than they are
16:54:28 <Philippa> check the socket's handling the right encoding, don't sweat the intermediate types unless you have performance issues
16:54:29 <FunctorSalad> you could use some bytestring-based network thing if you specify 'ascii' because you don't want to waste resources for multibyte handling?
16:54:39 <FunctorSalad> (there has to be a bytestring network lib)
16:57:02 <tolkad> so how do I specify the socket encoding?
16:57:22 <tolkad> If I'm using Network
16:57:23 <siracusa> Does GHCi allow you to create a new command from a series of other GHCi commands?
16:58:05 <tolkad> I would normally use accept, then call hGetChar
16:58:14 <tolkad> on the Handle returned
16:58:23 <tolkad> or one of the other hGet... functions
16:58:51 <FunctorSalad> siracusa: :def
16:59:53 <siracusa> FunctorSalad: But :def only accepts Haskell expressions?
17:00:18 <FunctorSalad> siracusa: e.g. :def foo \_ -> ":browse Prelude"
17:00:24 <FunctorSalad> *siracusa: e.g. :def foo \_ -> return ":browse Prelude"
17:00:43 <FunctorSalad> siracusa: yes but it's supposed to output ghci commands
17:01:04 <FunctorSalad> sadly, what you apparently *can't* do is to read from ghci commands in the haskell
17:01:56 <FunctorSalad> (IMHO it might want to be a ghci monad rather than just IO)
17:02:54 <siracusa> FunctorSalad: What is the argument of that function supposed to do?
17:03:11 <FunctorSalad> siracusa: it's the argument of :foo
17:09:38 <FunctorSalad> siracusa: e.g. :def echo liftM2 (>>) putStrLn (fmap return return "")
17:10:07 <FunctorSalad> sorry could not resist inane higherorderism
17:10:41 <Phyx-> Igloo: hm, ok thanks i'll give it a go
17:12:22 <FunctorSalad> (<=> :def liftM2 (\x -> putStrLn x >> return ""))
17:12:30 <FunctorSalad> s/liftM2/echo/
17:14:55 <Phyx-> Igloo: thanks, that worked. Is it new? never needed it before ^_^
17:16:06 <Igloo> Phyx-: Yes
17:17:27 <tolkad> Can you pattern match on incomplete constructors?
17:17:51 <Phyx-> incomplete constructors? you mean partially applied?
17:17:54 <tolkad> yes
17:18:11 <hpc> constructors can be curried
17:18:24 <hpc> types can be curried
17:18:37 <hpc> newtype Foo = Either Int
17:18:43 <hpc> er, s/newtype/type/
17:18:49 <copumpkin> not curry
17:18:52 <copumpkin> partially applied
17:18:55 <FunctorSalad> you can't pattern match on functions generally
17:19:10 <hpc> oh, i see
17:19:12 <FunctorSalad> well, except with simple variables or view patterns
17:19:40 <hpc> like f :: (Bar -> Foo) -> Baz
17:19:42 <McManiaC> :i this
17:19:50 <hpc> f (Foo a) = bleh
17:19:50 <tolkad> like data T = T Int Int; f (T a) = a; f (T 4)
17:19:55 <McManiaC> what is "this" ?
17:20:14 <FunctorSalad> guess: a local variable ;)
17:20:15 <McManiaC> http://www.haskell.org/haskellwiki/HXT <- at the bottom, just before "9 More complex examples"
17:20:16 <tolkad> is there any magic in _? or is it just a convention?
17:20:21 <FunctorSalad> often bound by 'fix'
17:20:29 <FunctorSalad> or an equivalent 'let'
17:20:35 <hpc> _ is a wildcard pattern
17:20:43 <hpc> it matches anything and gives it no name
17:20:57 <FunctorSalad> it's magic in that you can have multiple '_'
17:20:58 <hpc> it is semantically identical to an unused name
17:21:01 <FunctorSalad> yes
17:21:04 <Phyx-> tolkad: I don't think so, but i'm thinking, if you write a instance for Typeable (->a) you can then apply it to undefined and call typeOf again, untill you hit a non function, which should give you the TypeRep of the datatype
17:22:06 <Phyx-> or am i talking non-sense here ^_^
17:22:20 <aavogt> Phyx-: there's a flip in that type?
17:22:26 <hpc> would that give you something to match on?
17:22:41 <Phyx-> aavogt: how so?
17:22:54 <aavogt>  (->a)  isn't valid syntax now
17:22:54 <Phyx-> hpc: well, you recursively call typeOf a = typeOf (a undefined)
17:23:06 <Phyx-> eventually you'll get to a concrete type
17:23:35 <FunctorSalad> (->) a should be Typeable1
17:23:35 <Phyx-> avenge: it's not?
17:23:47 <FunctorSalad> and (->) Typeable2 akshully
17:23:47 <Phyx-> right
17:23:57 <Phyx-> :k Typeable2
17:23:58 <lambdabot> Class `Typeable2' used as a type
17:24:07 * Phyx- tries
17:24:16 <FunctorSalad> (it is, I checked)
17:24:31 <Phyx-> so the idea is flawed?
17:24:47 <FunctorSalad> class Typeable2 t where typeOf2 :: t a b -> TypeRep
17:24:48 <FunctorSalad>   	-- Defined in Data.Typeable
17:24:48 <FunctorSalad> instance [overlap ok] (Typeable3 s, Typeable a) => Typeable2 (s a)
17:24:48 <FunctorSalad>   -- Defined in Data.Typeable
17:24:48 <FunctorSalad> instance [overlap ok] Typeable2 (->) -- Defined in Data.Typeable
17:24:52 <FunctorSalad> instance [overlap ok] Typeable2 (,) -- Defined in Data.Typeable
17:24:54 <FunctorSalad> instance Typeable2 Either -- Defined in Data.Either
17:25:26 <FunctorSalad> I think it's just a 'for all a and b, t a b is Typeable' thing
17:25:33 <tolkad> oh! I have an idea
17:25:54 <tolkad> since -> is a type constructor I should be able to pattern match against it in data declarations
17:26:18 <tolkad> data F a -> b = FA
17:26:25 <tolkad> data F a = FB
17:26:27 <FunctorSalad> you can "type-level pattern match" on (->) indeed (it is injective)
17:26:28 <tolkad> great
17:26:39 <tolkad> will that work?
17:26:51 <FunctorSalad> data family?
17:27:05 <tolkad> I have no idea, I'm just making stuff up
17:28:25 <Phyx-> "Perhaps you intended -XRankNTypes or similar flag"
17:28:29 <Phyx-> i always end up needing that
17:28:30 <Phyx-> lol
17:28:46 <Phyx-> usually rank 2 is enough
17:29:21 <hpc> rank 2 can encode rank N
17:30:50 <tolkad> how can I pipe from input into a parsec Parser rather than having to read input and then parse it seperately?
17:31:26 <hpc> you need a lazy parser, i think
17:31:59 <FunctorSalad> yes, given that, hGetContents should take care of the streaming automatically
17:32:04 <FunctorSalad> (lazy IO)
17:32:37 <FunctorSalad> (or just Prelude.getContents for stdin)
17:33:02 <hpc> ooh, then you can pipe through the terminal
17:33:19 <tolkad> no, I'm writing an HTTP server
17:34:05 <tolkad> hGetContents returns a IO String. I thought that sequential statements within a do block happen sequentially...
17:34:11 <tolkad> an IO String*
17:37:03 <Phyx-> are type families restricted to kind *?
17:37:17 <copumpkin> no
17:37:36 <Phyx-> ok, thanks
17:38:36 <Phyx-> how does the kind hierarchy go again ?? -> ? -> {#, *} ?
17:39:06 <hpc> what's #?
17:40:05 <Phyx-> unboxed types
17:41:42 <hpc> ah
17:42:25 <copumpkin> I think ? is the top
17:42:37 <copumpkin> to figure it out, I just look at :k (->)
17:42:39 <copumpkin> :k (->)
17:42:40 <lambdabot> ?? -> ? -> *
17:42:54 <copumpkin> yeah
17:43:33 <hpc> argh, what are ? and ?? again? i remember asking this about a week ago
17:43:43 <tolkad> hGetContents returns a IO String. I thought that sequential statements within a do block happen sequentially...
17:43:43 <dolio> ?? = # or *, ? = ?? or (#)
17:43:44 <lambdabot> Plugin `compose' failed with: Unknown command: ""
17:44:02 <tolkad> is hGetContents magically not bound by this limitation?
17:44:17 <tolkad> or do statements within a do block not have to happen sequentially?
17:44:38 <c_wraith> welcome to Lazy IO
17:44:58 <c_wraith> It has some uses, but it's also a sure way to introduce bugs.
17:45:05 <c_wraith> look at unsafeInterleaveIO
17:45:06 <hpc> > do {undefined; Just 5}
17:45:07 <lambdabot>   *Exception: Prelude.undefined
17:45:15 <hpc> > do {return undefined; Just 5}
17:45:16 <lambdabot>   Just 5
17:45:21 <mjrosenb> is there any way to get Lazy IO other than to use one of the basis functions that is Lazy IO?
17:45:39 <Saizan> unsafeInterleaveIO
17:45:42 <c_wraith> You can implement unsafeInterleaveIO with unsafePerformIO
17:45:53 <copumpkin> :O
17:45:54 <Philonous> tolkad: There is nothing wrong with the type. Even sequential IO would have it. But you are right about hGetContents being non-strict.
17:47:07 <hpc> dolio: what's the difference between # and (#) in your explanation?
17:47:19 <dolio> # is unboxed types. (#) is unboxed tuples.
17:47:32 <hpc> that's a strange distinction
17:47:34 <Phyx-> didn't unboxed tuples have two #?
17:47:43 <dolio> Int# :: #, (# Int, Char #) :: (#)
17:48:16 <c_wraith> It just means you can use unboxed tuples as return values, but not as arguments.
17:48:38 <c_wraith> So the only thing you can do with them is unpack them.
17:49:04 <dolio> They're used to return multiple results in registers (hopefully).
17:49:09 <c_wraith> Or return them immediately, I guess.
17:49:11 <hpc> if you can't pass them as arguments, unpacking can't be made first-class?
17:49:23 <FunctorSalad> mjrosenb: uh I didn't read the whole backlog, but you can always manually read in lines or chunks one at a time
17:49:29 <copumpkin> hpc: you can't write a fst, etc.
17:49:30 <FunctorSalad> using hGetLine / hGet
17:49:31 <dolio> So they aren't necessary as arguments, and so GHC doesn't support them there.
17:50:20 <FunctorSalad> tolkad: it's borderline purity-breaking, yes ;)
17:50:27 <hpc> is there a tutorial on boxing and unboxing that i could perhaps read to make sense of all this?
17:50:29 <FunctorSalad> (see haskell-cafe for long discussion)
17:50:34 <hpc> @where boxing
17:50:34 <lambdabot> I know nothing about boxing.
17:50:45 <Phyx-> @google boxy types
17:50:45 <copumpkin> @go boxing tutorial
17:50:46 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/boxy/
17:50:46 <lambdabot> Title: Simon Peyton Jones: papers
17:50:46 <lambdabot> Maybe you meant: google googleit do
17:50:51 <copumpkin> @google boxing tutorial
17:50:52 <copumpkin> ;)
17:50:53 <lambdabot> http://www.youtube.com/watch?v=HQ-u_jVgQro
17:50:53 <lambdabot> Title: YouTube - ‪Boxing stance training tutorial‬‎
17:50:56 <FunctorSalad> (real effects happen in the outside world as a consequence of evaluation order)
17:51:03 <Philonous> FunctorSalad: Why only borderline?
17:51:09 <dolio> Boxy types are something else.
17:51:20 <drhodes> @pl \xs -> map (fmap (1+)) xs
17:51:21 <lambdabot> map (fmap (1 +))
17:51:30 <FunctorSalad> Philonous: hmm, they only happen in the outside world, and in the haskell world 'IO' carries no guarantees anyway...
17:51:40 <Phyx-> dolio: to be honest, can't remember what that paper was about again
17:51:47 <Phyx-> dolio: it just popped into my head :)
17:51:55 <FunctorSalad> (and it only affects things that could be oberved through doing IO, I think)
17:51:56 <dolio> Phyx-: Something about higher-rank types.
17:52:02 <Phyx-> unboxed types are so ghc specific, afaik
17:52:06 <Phyx-> dolio: aaaah right
17:52:12 <dolio> But I'm not sure what exactly the paper is about in that regard.
17:52:17 <FunctorSalad> Philonous: but I haven't read the whole debate :)
17:53:45 <mjrosenb> FunctorSalad: but that's boring :-p
17:57:57 <tolkad> what's "unsafe" about unsafeInterleaveIO?
17:58:30 <tolkad> will it delete system files if I don't sing a song before calling it?
17:58:38 <tolkad> will it attack my dog?
17:58:57 <tolkad> can it cause earthquakes?
17:59:03 <Philonous> tolkad: "unsafeInterleaveIO (launcheRockets >> return 5) >>= return . f " -- will rockets be launched?
17:59:13 <aavogt> @docs System.IO.Unsafe
17:59:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html
18:00:00 <dibblego> @type \f -> State (f &&& id) -- is this in the library? am I blind?
18:00:01 <lambdabot> forall s a. (s -> a) -> State s a
18:00:29 <roconnor> tolkad: it can do all those things
18:00:30 <aavogt> @type gets
18:00:31 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
18:00:38 <dibblego> aha, thanks
18:00:57 <smorg> In the type system, dots just delimit quantifiers from the rest of the stuff? It's always in the form of... func :: forall x. blah blah all x always bound to quantifier over here
18:01:59 <monochrom> yes
18:11:36 <dolio> forkIO launchRockets >> return 5 -- will rockets be launched?
18:11:54 <roconnor> @roll 2
18:11:54 <lambdabot> Consider it noted.
18:11:58 <roconnor> :(
18:12:15 <dolio> Is 2 a valid nickname?
18:12:47 <mjrosenb> dolio: 8 is not a valid nick.
18:13:25 <monochrom> yuck, hpaste is still "database locked"
18:13:58 <monochrom> @dice 2
18:13:58 <lambdabot> 2 => 2
18:14:30 <monochrom> and perhaps lambdabot doesn't care what is a valid nickname
18:14:53 <dolio> I'm sure she doesn't. But now she's going to carry around a blank message for 2 forever.
18:15:43 <monochrom> what we need to do now is to crash her before someone instructs her to save to disk
18:16:43 <Esteth> Hey again :) I'm just wondering how I'd convert between different Number types. I have a Word32 that I'd like to treat as a Word64 for a particular calculation, but obviously saying myNum :: Word64 gives a TypeError. Do I have to use fromIntegral then explicitly type the result, or something?
18:17:10 <monochrom> fix ( (forkIO (msg lambdabot "> foldl1 (+) [1..100000]")) >> )
18:17:24 <aavogt> Esteth: yeah, use fromIntegral
18:17:36 <ezyang> Esteth: You probably don't need to explicitly type it though. 
18:17:42 <ezyang> if the function is Word64 
18:18:21 <monochrom> @dice 1000
18:18:22 <lambdabot> 1000 => 1000
18:18:29 <monochrom> @dice 10 4
18:18:30 <lambdabot> 10 4 => 104
18:18:34 <Esteth> My function is Num a => a -> a -> a. This is a complete pain, all this circumventing the type system >_<
18:18:36 <monochrom> @dice 10 4
18:18:37 <lambdabot> 10 4 => 104
18:18:40 <McManiaC> monochrom: use npaste ;D
18:18:40 <Esteth> Thanks though :)
18:19:16 <monochrom> @dice help
18:19:17 <lambdabot> unexpected "h": expecting number
18:19:25 <monochrom> @dice
18:19:30 <lambdabot> unexpected end of input: expecting number
18:19:35 <dolio> Apparently 10 4 is 104.
18:19:36 <dolio> @dice 8d8
18:19:41 <lambdabot> 8d8 => 42
18:19:55 <McManiaC> @dice 1 2 3 4 5
18:19:56 <lambdabot> 1 2 3 4 5 => 12345
18:20:01 <McManiaC> lol
18:20:01 <dolio> @dice 8d8 + 10d6
18:20:02 <lambdabot> 8d8 + 10d6 => 76
18:20:15 <McManiaC> @dice alle meine entchen
18:20:16 <lambdabot> unexpected "a": expecting number
18:20:19 <aavogt> Esteth: well if the result of that function is used somewhere that explicitly needs Word64, you won't have to annotate the fromIntegral
18:24:24 <Phyx-> "Warning! on your computer detected the malicious code. Should immediately make sure that your system is safe! Killing Hazard (R) for Microsoft WIndows Seven immediately started to work" <-- really... how do you fall for that
18:24:52 <monochrom> by being bad in english
18:25:17 <Phyx-> then a page with a windows xp UI opens..
18:25:20 <Phyx-> :|
18:25:30 <tolkad> I
18:25:54 <tolkad> I'd rather not use unsafeInterleaveIO... is there any way to start and stop parsing?
18:26:09 <tolkad> so I could read one character, feed it to the parser, repeat?
18:26:21 <monochrom> by using attoparsec
18:28:29 <tolkad> I want to use parsec
18:30:10 <tolkad> I wish I could just write it inefficiently and GHC would optimize it to be perfect
18:32:16 <EvanR> it does!
18:32:24 <EvanR> its called functional programming ;)
18:34:05 <drhodes> @pl \x -> (x `mod` 2) == 0
18:34:06 <lambdabot> (0 ==) . (`mod` 2)
18:35:28 <tolkad> parsec is slow? I thought it would be fast considering it seems to be such a popular library
18:36:10 <EvanR> PHP is fast, C is slow
18:36:36 <medfly> C is pretty popular too... just not so much recently
18:36:45 <hpc> whoa, bad line to tab into this channel on
18:36:51 <hpc> "PHP is fast"
18:36:55 <EvanR> lol
18:39:54 <Esteth> Is there something like a bx01001 notation in haskell, similar to 0x0F5A? If not, what's the closest thing to creating Num instances from binary?
18:40:33 <mjrosenb> tbf, PHP is going to be faster than a jit unlambda->turing machine written in ruby 
18:41:54 <EvanR> i want sets of pairs of int, regardless of order
18:42:02 <EvanR> a set
18:42:25 <EvanR> (a,b) is in set == (b,a) is in set
18:43:08 <mjrosenb> EvanR: data SetTup = SetTup x y; then give a custom equality operator?
18:44:54 <EvanR> or Set (Set Int), but then i cant restrict it to pairs
18:44:59 <tolkad> How do you ensure something will be evaluated lazily?
18:45:16 <EvanR> lazy is the default
18:45:22 <EvanR> you gotta know when stuff will be strict
18:45:38 <ddarius> This lemonade tastes like electrolytes.
18:45:45 <tolkad> > let f x = (let a = x * 2 in a : f a) in f 1
18:45:46 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
18:46:08 <tolkad> like that, if that isn't evaluated lazily it will run forever. Is it just the compilers choice to evaluate it lazily?
18:46:24 <tolkad> might a standards compliant compiler never halt when evaluating that?
18:46:31 <FunctorSalad> mmm electrolytes nom nom nom
18:46:38 <EvanR> it never halts anyway
18:47:02 <medfly> the real question is: will it explode spectacularly?
18:47:24 <EvanR> depends on if its Int or Integer
18:47:57 <copumpkin> if it's an int, it'll eventually be a string of 0s
18:48:14 <copumpkin> > let f x = (let a = x * 2 in a : f a) in drop 64 (f (1 :: Int))
18:48:15 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
18:48:21 <drhodes> Esteth: there's no 0b... like 0x... but Data.Bits might be worth taking a look at.
18:48:50 <FunctorSalad> > let f x = (let a = x*3in a:f a) in drop 64(f(1::Int))
18:48:51 <lambdabot>   [7752514261426648835,4810798710570394889,-4014347941998366949,6403700247714...
18:50:30 <ezyang> How do I mute "Defined but not used errors?" 
18:50:39 <aavogt> underscores
18:50:46 <ezyang> My preprocessor is generating subpar code, but I don't want to turn off all warnings. 
18:50:51 <hpc> errors or warnings?
18:51:03 <ezyang> warnings. 
18:51:06 <ddarius> ezyang: If you prefix the unused variable with an underscore that warning won't be reported.
18:51:07 <FunctorSalad> -fno-warn-unused or so
18:51:29 <FunctorSalad> -fno-warn-unused-binds?
18:51:41 <ezyang> I tried all of the specific ones and they didn't seem to work :-/ 
18:52:18 <FunctorSalad> do you have an explicit export list and aren't exporting?
18:52:20 <ezyang> oh, but it looks like specifying all of them works. 
18:52:28 <ezyang> FunctorSalad: It's inside a do-block 
18:52:49 <FunctorSalad> ah... the new one?
18:52:52 <FunctorSalad> (warning)
18:53:17 <FunctorSalad> (that one is silences by "_ <- blah")
18:53:21 <FunctorSalad> d
18:53:57 <ezyang> Looks like I need -fno-warn-unused-matches 
18:54:18 <ezyang> oh, lol, I accidentally wrote -fwarn insteaed of -fno-warn, which is why it didn't work the first time I tried it :-) 
18:54:31 <FunctorSalad> a bit here and there
18:56:23 <tolkad> EvanR: well I can take x from it and it will halt
18:57:19 <tolkad> > let f x = (let a = x ^ x in a : f a) in f 1
18:57:20 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:57:22 <tolkad> > let f x = (let a = x ^ x in a : f a) in f 2
18:57:26 <Philippa> tolkad: Parsec is popular more because it's powerful than because it's fast
18:57:28 <lambdabot>   mueval: ExitFailure 1
18:57:37 <tolkad> > let f x = (let a = x ^ x in a : f a) in take 2 (f 2)
18:57:38 <lambdabot>   [4,256]
18:57:41 <tolkad> > let f x = (let a = x ^ x in a : f a) in take 5 (f 2)
18:57:46 <lambdabot>   mueval: ExitFailure 1
18:57:49 <Philippa> and yes, a standards-compliant Haskell compiler must produce code that terminates if the code can be made to terminate
18:57:51 <tolkad> > let f x = (let a = x ^ x in a : f a) in take 3 (f 2)
18:57:52 <lambdabot>   [4,256,32317006071311007300714876688669951960444102669715484032130345427524...
18:59:47 * hackagebot ui-command 0.5.1 - A framework for friendly commandline programs  http://hackage.haskell.org/package/ui-command-0.5.1 (ConradParker)
19:00:06 <tolkad> Philippa: really? that's great! I can check if a computation takes more than a certain amount of time, and if it does then run forever. that will force the compiler to optimize it to run faster than that if such an optimization is possible
19:00:55 <FunctorSalad> hmm?
19:01:11 <tolkad> Philippa: <Philippa> and yes, a standards-compliant Haskell compiler must produce code that terminates if the code can be made to terminate
19:01:43 <FunctorSalad> she means that only evaluation order is variable by the compiler :)
19:01:56 <FunctorSalad> it can't make it terminate by any means whatsoever ;)
19:02:08 <tolkad> FunctorSalad: I can call loopForever x = loopForever x if a computation takes over 5 seconds. that will force the compiler to optimize it to run in under 5 seconds
19:02:27 <tolkad> if such an optimization is possible, that is, a turing machine exists with that behavior
19:02:53 <aavogt> that doesn't happen with existing implementations
19:03:13 <tolkad> aavogt: existing implementations of haskell are not standards compliant?
19:03:30 <aavogt> they aren't... but not for that reason
19:03:42 <FunctorSalad> tolkad: IO has undefined semantics, so the compiler could just make the threadDelay return instantly as far as abstract semantics are concerned...
19:04:22 <FunctorSalad> Philippa was talking about evaluation strategy of pure expressions, I assume
19:04:43 <tolkad> FunctorSalad: is there any sort of currentTime function with standards-defined semantics?
19:05:21 <tolkad> Oh... all IO
19:05:39 <tolkad> that's strange to make all IO undefined behavior, kind of bad
19:05:43 <FunctorSalad> ("it won't go into a loop if there is some evaluation order that won't")
19:05:47 <jmcarthur> no it's good
19:06:04 <jmcarthur> IO is unpredictable for many reasons
19:06:07 <tolkad> no, I'm pretty sure it's bad, that means implementations can do whatever they want when you call IO functions
19:06:23 <jmcarthur> if you want more well-defined side effects you have to make a reasonable abstraction to make those guarantees
19:06:26 <jmcarthur> yes
19:07:19 <jmcarthur> it's kind of a "by definition" sort of thing. IO is, by it's very nature, very hard to reason about
19:07:19 <tolkad> in a standards compliant implenetation, putStr could delete a file with the specified name rather than producing output?
19:07:19 <jmcarthur> yes
19:07:19 <jmcarthur> no sane implementation would do that of course
19:07:37 <FunctorSalad> tolkad: another way to put it is that any implementation must return the same results as a maximally lazy one
19:08:02 <FunctorSalad> (but it may internally be more strict for efficiency reasons if it can guarantee it will give the same result)
19:08:09 <tolkad> jmcarthur: I'm using GHC-Insane, should I be worried?
19:08:24 <Phyx-> what's GHC-Insane?
19:08:25 <jmcarthur> tolkad: i doubt any other language you know defines "IO" functions any more specifically
19:08:37 <jmcarthur> s/specifically/explicitly/
19:09:07 <jmcarthur> aside from "makes X system call" and things like that, which are of course just as well-defined ;)
19:09:35 <hpc> Phyx-: it avoids any sane implementation details :P
19:09:42 <jmcarthur> tolkad: you should only have to worry if you are littering your code with unsafePerformIO
19:09:52 <jmcarthur> or other unsafe functions
19:10:58 <tolkad> what? using one should not be fundamentally different than using many, either they always do what they say they do or they don't
19:11:47 <jmcarthur> i am confused by your confusion :)
19:12:28 <FunctorSalad> tolkad: we meant it has no semantics in the mathematical sense
19:12:34 <FunctorSalad> (perfectly rigorous)
19:12:44 <tolkad> the C standard has very well defined semantics for IO functions
19:12:55 <jmcarthur> tolkad: not in the sense that we are talking about
19:13:00 <FunctorSalad> not "no informal definition" ;)
19:13:03 <monochrom> "that's just semantics"
19:13:43 <tolkad> "The active position is that location on a display device where the next character output by the fputc function would appear. The intent of writing a printing character (as deﬁned by the isprint function) to a display device is to display a graphic representation of that character at the active position"...
19:13:57 <jmcarthur> tolkad: okay great. now define that mathematically
19:14:34 <tolkad> stand back, I'm going to need lots of room for axioms
19:14:41 <jmcarthur> it has to be rigorous to be on par with the kind of definitions we are talking about
19:15:37 <jmcarthur> tolkad: http://www.haskell.org/onlinereport/haskell2010/haskellch7.html#x14-1420007
19:15:48 <jmcarthur> tolkad: those are the informal specs for the standard IO functions
19:15:59 <jmcarthur> tolkad: but they are not what we are talking about when we say "undefined semantics"
19:16:14 <FunctorSalad> -- | This function does some IO
19:16:19 <FunctorSalad> -- | This one too
19:16:20 <FunctorSalad> ;)
19:17:03 <medfly> reading the chat log makes me think of Haskell as that nerdy kid that doesn't like counting on other people.
19:17:08 <monochrom> -- | This function does no IO.
19:18:32 <jmcarthur> tolkad: more IO functions in the spec: http://www.haskell.org/onlinereport/haskell2010/haskellch41.html#x49-32000041
19:18:48 <Phyx-> hpc ah ok
19:18:51 <Phyx-> wait, he left?
19:18:59 <Phyx-> yup
19:21:37 <ddarius> medfly: Who likes counting on other people?
19:22:47 <medfly> it's okay to count on them for some simple tasks!
19:23:10 <Phyx-> if you want something done right, do it yourself is what I always say
19:23:25 <medfly> :-D
19:23:33 <monochrom> if I want something done right, I use a computer.
19:23:56 * hackagebot ui-command 0.5.2 - A framework for friendly commandline programs  http://hackage.haskell.org/package/ui-command-0.5.2 (ConradParker)
19:24:18 <FunctorSalad> I thought it's what you use to make mistake as fast as possible
19:24:22 <FunctorSalad> mistakes
19:24:23 <Phyx-> monochrom: that's the thinking that gives birth to skynet
19:24:27 <ddarius> If you want something done at all, you have to do it yourself.
19:24:39 <monochrom> I'm all for skynet TBH
19:24:40 <ddarius> Phyx-: and a brighter future
19:25:28 <FunctorSalad> ("computers enable you to make mistakes faster than any other human invention, with the possible exception of tequila and a handgun"...)
19:25:38 <Phyx-> ddarius: that... depends on which side you are :P
19:26:00 <Phyx-> but you're right, less people is always a good thing
19:26:05 * ddarius likes Tequila but only has a tactical shotgun.
19:26:12 <ddarius> Phyx-: Yay!
19:27:10 <monochrom> computers also enable near-100%-correct theorem proving
19:27:17 <Phyx-> rm -rf RealWorld#
19:27:58 <monochrom> If I want something done right, I first use a computer to check whether my method is right, then I use a computer to carry out the method.
19:28:19 <monochrom> Computers can speed up mistakes, but only when you use C.
19:28:35 <medfly> Haskell code, on the other hand, is flawless.
19:28:47 <Phyx-> untill it panics
19:29:10 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/81756fe3fe07a61a
19:32:54 <FunctorSalad> 'boundance checking'... I like
19:34:03 <Phyx-> @ping
19:34:03 <lambdabot> pong
19:34:05 <copumpkin> monochrom: they can't perform bound checking
19:34:24 <copumpkin> since you don't get arrays
19:34:28 <copumpkin> (in C)
19:35:29 <Phyx-> loool
19:35:32 <Phyx-> nice reply
19:41:16 <tolkad> does anyone know of a multiparameter imported constructor in lambdabot?
19:41:35 <monochrom> does Either count?
19:41:50 <monochrom> err, that's a type constructor
19:42:04 <tolkad> yeah... I mean normal constructor
19:42:16 <monochrom> @type State
19:42:17 <lambdabot> forall s a. (s -> (a, s)) -> State s a
19:42:18 <tolkad> maybe Ratio?
19:42:23 <tolkad> > Ratio 1 2
19:42:23 <lambdabot>   Not in scope: data constructor `Ratio'
19:42:37 <monochrom> > (:+) 3.0 4.0
19:42:38 <lambdabot>   3.0 :+ 4.0
19:42:42 <monochrom> that's one
19:42:49 * ddarius remembers ALIEN>
19:43:05 <monochrom> @type Reader
19:43:06 <lambdabot> forall r a. (r -> a) -> Reader r a
19:43:10 <tolkad> > (1(:+))
19:43:11 <lambdabot>   Ambiguous type variable `a' in the constraint:
19:43:12 <lambdabot>    `GHC.Float.RealFloat a'
19:43:12 <lambdabot>  ...
19:43:20 <tolkad> > (1(:+)2)
19:43:21 * ddarius is no longer rimed with salt
19:43:21 <lambdabot>   Ambiguous type variable `t' in the constraint:
19:43:22 <lambdabot>    `GHC.Num.Num t' arising f...
19:43:28 <tolkad> > (:+2)
19:43:29 <lambdabot>   Overlapping instances for GHC.Show.Show
19:43:29 <lambdabot>                              (a -> ...
19:43:33 <tolkad> > (1:+2)
19:43:34 <lambdabot>   1.0 :+ 2.0
19:44:22 <tolkad> > let f (a :+ b) = a in f (1 :+ 2)
19:44:23 <lambdabot>   1.0
19:44:30 <tolkad> > let f (a :+ b) = a in f (1 :+)
19:44:31 <lambdabot>   Couldn't match expected type `Data.Complex.Complex t'
19:44:31 <lambdabot>         against infer...
19:44:37 <SubStack> > (exp 1) ** (pi * (0 :+ 1))
19:44:38 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
19:44:39 <tolkad> > let f (a :+) = a in f (1 :+)
19:44:40 <lambdabot>   <no location info>: Parse error in pattern
19:44:47 <tolkad> how do I make this work...
19:45:05 <tolkad> why didn't it work anyway
19:45:12 <tolkad> it looks like it should
19:45:36 <FunctorSalad> pattern match on a section?
19:45:39 <Saizan> you can't pattern match on partially applied constructors.
19:45:59 <FunctorSalad> ah yes, it's not about section syntax specifically ;)
19:46:05 <monochrom> > let f (a :+ _) = a in f (1 +: undefined)
19:46:06 <lambdabot>   Not in scope: `+:'
19:46:11 <monochrom> > let f (a :+ _) = a in f (1 :+ undefined)
19:46:12 <lambdabot>   *Exception: Prelude.undefined
19:46:25 <monochrom> oh, has strictness flag
19:46:29 <monochrom> > let f (a :+ _) = a in f (1 :+ 0)
19:46:30 <lambdabot>   1.0
19:47:16 <wli> > let eps = head . dropWhile (\x -> 1 + x > 1) $ iterate (/2) 1 in eps
19:47:17 <lambdabot>   1.1102230246251565e-16
19:47:30 <SubStack> crazy I have never seen patterns like that
19:47:48 <wli> The imaginary part of exp (0 :+ pi)  is pretty close to eps
19:47:48 <monochrom> isn't haskell exciting?
19:47:54 <ddarius> SubStack: It's a perfectly normal pattern.
19:48:39 <djahandarie> Hm, GHC seems to be complaining that instances don't exist when they do
19:48:47 <FunctorSalad> (but infix ctors are slightly exotic)
19:49:20 <ddarius> FunctorSalad: f (a : _) = ...
19:49:21 <monochrom> haskell feels pretty crazy if you come from an unorthogonal language
19:49:22 <copumpkin> djahandarie: like what?
19:49:44 <monochrom> the first craziness you should feel is "what? you can nest function definitions?"
19:49:56 <copumpkin> you can do that in gcc with an extension
19:49:58 <monochrom> because C has brainwashed you that I can't
19:50:02 <djahandarie> copumpkin, using http://hackage.haskell.org/packages/archive/mstate/0.1.3/doc/html/Control-Concurrent-MState.html
19:50:04 <copumpkin> -fallow-nested-functions or something
19:50:08 <ddarius> monochrom: You can nest classes inside of functions in C++.
19:50:14 <FunctorSalad> ddarius: hmm I guess that is indeed regular
19:50:25 <djahandarie> copumpkin, No instance for (MonadState BotState (MState BotState IO))
19:50:28 <monochrom> the second craziness is "what? you can create your own operators?"
19:50:30 <FunctorSalad> (but the type syntax isn't...)
19:50:30 <Wooga> hello, i wrtied simple programm where user is suggested to guess the random number in range 1..10:  http://codepad.org/UrexIrvC ; can it be improved somehow (like in coding style or logic ways) ?
19:50:40 <FunctorSalad> monochrom: "locally"? ;)
19:50:43 <wli> copumpkin: No upward funargs, so not all that useful.
19:50:48 <djahandarie> copumpkin, even though in the mstate package it is defined: MonadIO m => MonadState t (MState t m)
19:50:53 <copumpkin> wli: yeah
19:51:02 <copumpkin> no closures :)
19:51:05 <FunctorSalad> local operators can actually be benficial to visual parseability...
19:51:16 <djahandarie> copumpkin, unless IO isn't MonadIO for some reason
19:51:17 <FunctorSalad> (they can save quite a few parentheses)
19:51:18 <copumpkin> djahandarie: weird
19:51:27 <monochrom> because C, C++, and most parser courses you take have brainwashed you that I can't
19:51:32 <wli> copumpkin: worse yet there's nothing that really flags errors when you try, it just generates crashing code
19:51:46 <FunctorSalad> 'upwards funargs'?
19:51:47 <copumpkin> wli: oh, nice
19:52:03 <copumpkin> wli: but then again, you're free to return stack-allocated memory, too, which isn't that different
19:52:06 <djahandarie> Even weirder, GHC doesn't complain when it compiles with cabal install, but dyre does
19:52:23 <wli> FunctorSalad: One of numerous alternative names for escaping variables etc.
19:52:57 <monochrom> but I missed the 0th craziness. "what? you can have static typing and still omit types?"
19:53:56 <monochrom> anyway, haskell is crazy or the "real world" is ridiculously retarded. take your pick.
19:54:37 <djahandarie> Grr
19:55:00 <djahandarie> I don't understand why cabal can compile this but dyre can't
19:55:36 <FunctorSalad> wli: hmm so is what you're saying more or less that it doesn't give you closures?
19:56:24 <wli> FunctorSalad: Yes, but more than that. Closure-needing escaping variables basically silently (not sure how silently) compile to crashing code.
19:57:00 * copumpkin wants closure :(
19:59:34 <djahandarie> Ahhh
19:59:34 <djahandarie> It was Dyre being stupid
19:59:34 <djahandarie> lol
19:59:34 <djahandarie> Apparently it was lying about what configuration file it was reading
20:00:18 <wli> copumpkin: Flagging an error would be better than generating code that crashes.
20:00:30 <copumpkin> wli: oh, I agree
20:00:42 <copumpkin> but it can be hard to trace
20:01:24 <wli> copumpkin: Not at all. Escaping variable analysis is reliable.
20:01:56 <dolio> Heh, so someone posted to comp.lang.haskell, "Sometimes I'm not sure when I need parentheses."
20:02:06 <dolio> And someone posted back, "I suggest Liskell."
20:02:12 <copumpkin> lol
20:02:56 <copumpkin> wli: hmm, I feel like it's pretty hard, at least if we're talking about the same thing.
20:03:37 <wli> copumpkin: Escaping variable analysis is not hard.
20:04:40 <FunctorSalad> seems like usual lexical scope analysis
20:05:18 <copumpkin> so if I take the & of an input variable, pass it to a function which multiplies it by two and sticks it into a global structure, then call another function that reads the global variable, shifts it right by 1, and returns that, and then I return that as my result...
20:06:09 <wli> copumpkin: Taking the address and passing it to another function means it escapes from that function.
20:06:28 <copumpkin> oh, okay
20:06:55 <copumpkin> so would it generate false positives if I did some complicated operation on the address of the thing that ended up being a constant?
20:07:17 <wli> copumpkin: In principle, yes.
20:07:21 <copumpkin> I see
20:07:30 <copumpkin> yeah, then it seems easy
20:07:41 <copumpkin> well...
20:07:50 <copumpkin> what if you're sneaky
20:07:51 <djahandarie> Is there some class which I can define an instance of providing fork/forkIO?
20:08:07 <Philippa> you have to assume, for a local analysis, that passing out a reference = escape
20:08:34 <Philippa> djahandarie: not that I know of
20:11:14 <lispy> if I want to create a new monad type class, would it go in Control.Monad.Foo ?
20:11:19 <lispy> Or Data.Monad.Foo?
20:11:21 <FunctorSalad> you mean like 'MonadFork m where fork :: m () -> m ()'?
20:11:29 <djahandarie> Yeah
20:11:37 <djahandarie> Or m () -> m ThreadId
20:11:41 * lispy thinks Control.Foo
20:11:48 <Saizan> there's a package on hackage with that
20:11:58 <lispy> like Control.Alternative, Control.Monad, and Control.Applicatiev
20:11:58 <FunctorSalad> djahandarie: IIRC there's a monad for "(IO a -> IO a) -> (m a -> m a)"
20:12:10 <FunctorSalad> quite clever
20:12:11 <copumpkin> time for sleep
20:12:23 <FunctorSalad> *a monad typeclass
20:12:34 <FunctorSalad> almost all monads based on IO support that somehow
20:12:35 <djahandarie> Was going to say that would be an impressive monad
20:12:44 <avenge> FunctorSalad: Which monad?
20:12:57 <FunctorSalad> don't remember how the class is called
20:13:12 <avenge> I tried implementing something like this in monad-wrap.
20:13:19 <avenge> sort of like this.
20:13:21 <mm_freak> where is the Num instance for numeric functions?
20:14:13 <avenge> mm_freak: I really wish haddock linked instance definitions.  I find myself asking questions like this all the time.
20:14:53 <mm_freak> avenge: it does, usually
20:15:02 <mm_freak> but only if it knows about them at the time it is run
20:15:06 <FunctorSalad> http://hackage.haskell.org/packages/archive/interleavableIO/0.0.1/doc/html/Control-Monad-Trans-InterleavableIO.html
20:15:18 <FunctorSalad> not quite the sig I gave...
20:15:22 <FunctorSalad> but I think it's related ;)
20:16:02 <avenge> mm_freak:  But it doesn't seem to send me to the source.  When I click, it just sends me to the documentation for the thing that is an instance, or to the class.
20:16:12 <avenge> mm_freak:  There's never a source link for the instance source code.
20:16:16 <mm_freak> avenge: true
20:17:30 <mm_freak> as a first intuition i'd say it's in Data.Function, but it isn't
20:17:49 <FunctorSalad> avenge: your wrapIO seems to have exactly the right type, actually
20:18:46 <FunctorSalad> (if the question is where the Monad ((->) env) instance is, the answer is Control.Monad.Reader ;))
20:21:36 <mm_freak> hmm, given the current Prelude, in fact it seems to be impossible to write a Num instance for functions
20:21:50 <mm_freak> > show sin
20:21:51 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
20:21:51 <lambdabot>    arising from a use of `...
20:22:01 <mm_freak> > sin == sin
20:22:02 <lambdabot>   *Exception: (==): No overloading for function
20:22:02 <copumpkin> mm_freak: bogus show and eq instances :)
20:22:32 <mm_freak> i never understood why Num is a subclass of Eq and Show
20:22:52 <wli> mm_freak: Eq/Show requirements?
20:23:24 <Cale> The (shoddy) reasoning for Num being a subclass of Eq is that n-patterns require Eq
20:23:29 <Cale> Like when you write:
20:23:32 <FunctorSalad> hmm Control.Monad.Instances akshully. Never saw that
20:23:32 <Cale> f 0 = 0
20:23:40 <FunctorSalad> (but Control.Monad.Reader reexports)
20:23:41 <Cale> That obviously needs an Eq instance.
20:24:21 <FunctorSalad> http://www.google.com/url?sa=t&source=web&cd=1&ved=0CBUQFjAA&url=http%3A%2F%2Fwww.haskell.org%2Fhaskellwiki%2FNum_instance_for_functions&ei=NcZgTOm3Jo6FOMXpjIkK&usg=AFQjCNEDFelg8vBFmyc1YIzz7JqyWH6b4A&sig2=esy4DhsVy4-G0sIviChsBQ
20:24:22 <Cale> But it would make more sense to me to just demand an instance of Eq at that point, not for all instances of Num.
20:25:03 <joyfulgirl> !give FunctorSalad tinyurl
20:25:17 <joyfulgirl> (Sorry, wrong channel)
20:25:25 <joyfulgirl> (And wrong tab completion)
20:25:39 <FunctorSalad> (or redirect remover)
20:25:59 <mm_freak> Cale: yeah
20:26:15 <FunctorSalad> I can't c&p the url after going to the page because vimperator removes the address bar and I don't know how to copy the current url otherwise
20:26:18 <mm_freak> true, but that doesn't explain its dependence on Show
20:27:33 <FunctorSalad> joyfulgirl: hmm wrong tab completion? coincidence that it was appropriate here too?
20:28:09 <joyfulgirl> FunctorSalad: Strange, ain't it?
20:32:20 <djahandarie> It'd be nice if $ were stronger than :: in terms of precedence
20:32:48 <djahandarie> Constantly need to use parenthesis because of inline type signatures
20:34:10 <FunctorSalad> djahandarie: it isn't? :o (assumign you mean 'stronger' = 'binds tighter')
20:34:43 <mm_freak> > read $ 3 :: String
20:34:44 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
20:34:44 <lambdabot>    arising from the literal `...
20:34:50 <mm_freak> > read $ "3" :: String
20:34:51 <lambdabot>   "*Exception: Prelude.read: no parse
20:35:10 <djahandarie> Hm
20:35:26 <mm_freak> that '::' is not an operator, it's language syntax
20:35:46 <mm_freak> so i think you need to use parens here
20:36:26 <djahandarie> Aren't there other parts of language syntax that have looser bindings than some functions?
20:36:34 <FunctorSalad> uh but this shows that ($) *does* bind tighter than ::
20:36:34 * djahandarie can't remember exactly
20:36:49 <FunctorSalad> (maybe stronger=looser for you as I said)
20:37:02 <djahandarie> I have no idea what I'm saying
20:37:07 <djahandarie> I just don't want those extra ()
20:37:39 <FunctorSalad> I mean tighter in the sense that makes * bind tighter than +
20:37:55 <monochrom> > read $ "3" :: Int
20:37:56 <lambdabot>   3
20:37:59 <monochrom> works
20:38:16 <mm_freak> FunctorSalad: huh?  no
20:38:22 <djahandarie> > read ("3" :: Int)
20:38:23 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:38:23 <lambdabot>         against inferred type ...
20:38:26 <djahandarie> That is the behavior I want from that
20:38:38 <mm_freak> it says no parse, because it tries to parse as a string
20:38:39 <c_wraith> :: binds to the entire previous expression
20:38:45 <mm_freak> instead of using "3" as a string and parsing to a number
20:38:47 <FunctorSalad> mm_freak: yeah, and 3 isn't a string
20:38:47 <djahandarie> Which is annoying
20:38:59 <FunctorSalad> so the :: was looser
20:39:28 <mm_freak> yes, it's looser than every operator, which was djahandarie's complaint
20:39:33 <FunctorSalad> (it isn't the string representation for a string that 'read' expects, which is double quoted)
20:39:34 <mm_freak> because you need extra parentheses
20:39:52 <FunctorSalad> I'd read it the other way
20:40:14 <mm_freak> with "stronger", probably "looser" is meant
20:40:25 <FunctorSalad> then yes
20:40:31 <monochrom> heh, meaningful words
20:40:51 <dolio> @type \x -> x :: Int
20:40:52 <lambdabot> Int -> Int
20:40:55 <FunctorSalad> I find 'tighter' and 'looser' more intuitive ;)
20:41:09 <djahandarie> I understand the terms now
20:41:11 <mm_freak> ditto =)
20:41:14 <FunctorSalad> (and something that's "strong" can hold on more strongly to operands, no?)
20:41:14 <monochrom> just imagine a coding style saying "use meaningful identifiers such as 'stronger' ..."
20:41:33 <FunctorSalad> (or does it have the strength of mind to let go.......)
20:41:39 <mm_freak> dolio: both syntax and both looser than any operator
20:41:48 <dolio> I know.
20:42:14 <djahandarie> I swear there is syntax that is tighter than function application
20:42:54 <monochrom> the next best thing is create an operator equivalent to "asTypeOf" but tighter than "$"
20:43:00 <mm_freak> > let Just !x = Just 3 in x
20:43:01 <lambdabot>   Constructor `Data.Maybe.Just' should have 1 argument, but has been given 0
20:43:10 <mm_freak> > let Just (!x) = Just 3 in x
20:43:11 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
20:44:43 <mm_freak> djahandarie: example?
20:45:11 <monochrom> "asTypeOf" is actually more useful than ::
20:45:15 <FunctorSalad> or just make a narrowed id as a standalone decl if you need the same narrowing many times.....
20:45:20 <c_wraith> djahandarie, record update syntax
20:45:23 <mm_freak> :t asTypeOf
20:45:24 <lambdabot> forall a. a -> a -> a
20:45:32 <dolio> >let f l@(x:_) = x:l in f [1..]
20:45:35 <mm_freak> huh?!
20:45:38 <dolio> > let f l@(x:_) = x:l in f [1..]
20:45:39 <lambdabot>   [1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:45:42 <FunctorSalad> monochrom: hmm it introduces a bit of irrelevant  information
20:45:47 <FunctorSalad> (the value)
20:46:08 <monochrom> not always irrelevant
20:46:20 <mmmulani> > def @
20:46:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:46:25 <mmmulani> > :t (@)
20:46:26 <lambdabot>   <no location info>: parse error on input `:'
20:46:28 <mmmulani> type @
20:46:33 <mm_freak> true, record update is stronger than function application
20:46:36 <mmmulani> :t @
20:46:37 <lambdabot> parse error on input `@'
20:46:39 <mmmulani> :t (@)
20:46:40 <lambdabot> parse error on input `@'
20:46:42 <FunctorSalad> (like ids : String -> String, ids = id)
20:46:47 <mmmulani> oh yeah, as
20:46:49 <mmmulani> that's what it means
20:46:55 <mm_freak> @src asTypeOf
20:46:55 <lambdabot> asTypeOf = const
20:47:21 <mm_freak> i think i prefer ::
20:49:02 <Saizan> "read $ id @String "3"
20:49:04 <Saizan> "
20:49:18 <Saizan> type application ftw
20:55:46 <mm_freak> is there a type level (.)?
20:56:05 <mm_freak> or even type lambdas?
20:56:12 <mm_freak> perhaps using some extension?
20:56:20 <monochrom> no
20:56:21 <FunctorSalad> in ghc's core language ;)
20:56:38 <mm_freak> hmm
20:56:38 <ddarius> FunctorSalad: That's a different lambda.
20:57:57 <FunctorSalad> hmm... specialization lambda
20:58:11 <ddarius> type level lambda /= type lambda
20:58:33 <mm_freak> ddarius: huh?  what's the difference?
20:59:04 <FunctorSalad> one could have a lambda for application and one for specialization...
20:59:10 <Saizan> λ vs. Λ
20:59:30 <mm_freak> i'm asking for Λ
20:59:42 <FunctorSalad> hmm... maybe the one for specialization is called 'forall'? o_O
20:59:46 <dolio> (/\a. \x -> x) :: forall a. a -> a
21:00:20 <dolio> (\a -> a -> a) :: * -> *
21:00:49 <FunctorSalad> ahaaa
21:02:16 <Saizan> to write a type level (.) you need the latter, while Λ is the former
21:02:27 <smorg> not Λ as in \x -> and x
21:02:35 <FunctorSalad>  /\ :: (Type -> Value) -> Value, (\) :: (Type -> Type) -> Type
21:02:36 <FunctorSalad> ?
21:03:20 <FunctorSalad> ;)
21:03:41 <Saizan> yep
21:04:33 <Saizan> they can be generalized to a single thing like in dep. typed languages, of course
21:05:10 <dolio> Yes, it's all pi and lambda in the lambda cube.
21:06:04 <FunctorSalad> (btw I meant that (forall x. p[x]) [x:=Foo] == p[x/Foo]... (/\ x. p[x]) Foo == p[x/Foo]... *blah* ;))
21:06:22 <FunctorSalad> lambdas for different 'application' operators
21:07:28 <tkahn6> .join #haskell-overflow
21:09:50 <FunctorSalad> (what's the right ambient setting for defining 'a lambda/application pair'? I've seen the 'module-over-monad' thing)
21:10:25 <FunctorSalad> doesn't quite seem to fit into a usual algebra setting due to the essential role of names
21:13:40 <Cale> FunctorSalad: Cartesian closed category?
21:13:51 <mm_freak> is there any reason why we don't have certain type functions?
21:14:41 <mm_freak> i've found many cases where i missed something like a type level Const, Flip or even composition
21:14:41 <dolio> Type inference.
21:15:08 <Saizan> instance resolution too.
21:15:35 <Cale> Or even just type checking
21:15:36 <FunctorSalad> Cale: hmm ok, that would make the anwer 'category' :) (I mean like: "a group operation is a binary operation of a set such that... ", "a lambda operator/application operator pair is a ? such that...")
21:16:20 <mm_freak> can't we have an UndecidableTypes extension?
21:16:25 <Saizan> OTOH, in coq they have typeclasses now, which seem to work to some extent
21:16:27 <Cale> FunctorSalad: You can interpret the lambda calculus in an arbitrary CCC.
21:16:36 <ddarius> mm_freak: We -could-
21:16:48 <dolio> It's a big change.
21:16:53 <FunctorSalad> yeah, but I mean the CCC is a particular lambda already
21:17:15 <FunctorSalad> (I was looking for the universe from which possible lambda operators are chosen)
21:17:23 <Cale> er, hmm
21:17:37 <Cale> Different CCCs sort of give you different lambdas?
21:17:45 <mm_freak> dolio: really?  don't we have most of what we need already in GHC?
21:17:52 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.6327&rep=rep1&type=pdf
21:18:08 <Cale> But maybe that's not what you want.
21:18:18 <ddarius> Read Bart Jacob's thesis and/or book.
21:18:25 * hackagebot system-filepath 0.1 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.1 (JohnMillikin)
21:18:38 <FunctorSalad> lambda has "type" Hom(AxB,C) -> Hom(A,C^B) in a CCC, IIRC
21:18:51 <mm_freak> hmm, actually it would make type unification very difficult and undecidable in general
21:18:52 <FunctorSalad> though "C^B" is part of the CCC too :)
21:19:12 <Wooga> what the point of MonadPlus existing ?
21:19:25 * hackagebot directory-tree 0.9.0 - A simple directory-like tree datatype, with useful IO functions  http://hackage.haskell.org/package/directory-tree-0.9.0 (BrandonSimmons)
21:19:30 <ddarius> mm_freak: In general you would require higher order unification which is indeed undecidable.  Isn't this why it would be called "UndecidableTypes" ?
21:20:13 <mm_freak> ddarius: yes, but the question would be related to the equality of functions
21:20:14 <Wooga> existence*
21:20:15 <mm_freak> which is hard
21:20:16 <ddarius> mm_freak: Also, read the paper that I linked.
21:20:36 <mm_freak> Wooga: look at particular instances
21:20:58 <mm_freak> MonadPlus gives you a notion of 'no result' and a notion of 'accumulation of many results'
21:21:34 <mm_freak> and have a look at Alternative from Control.Applicative, too
21:21:43 <mm_freak> which is more general than MonadPlus
21:21:44 <Saizan> if by accumulation you also include "take only one"
21:22:16 <mm_freak> Saizan: what do you mean?  mzero being the identity with respect to mplus?
21:22:43 <Saizan> > Just 1 `mplus` Just 2
21:22:43 <lambdabot>   Just 1
21:22:46 <FunctorSalad_> Cale: (I meant different lambdas in the same way a set can have different group structures.... this is vague but I'm looking for the very frame to make it exact ;))
21:22:53 <mm_freak> Saizan: yes, that's an accumulation
21:23:10 <Wooga> mm_freak: but what instance fo MonadPlus changes? it have no methods, so why do may i want it?
21:23:11 <mm_freak> that's why i said 'accumulation of many results' instead of just 'many results' =)
21:23:19 <ddarius> > [1] `mplus` [2]
21:23:20 <lambdabot>   [1,2]
21:23:23 <Wooga> s/fo/of/
21:23:24 <FunctorSalad_> (and in this frame, one could formulate beta-reduction as a law)
21:23:41 <FunctorSalad_> but it's probably just CCCs, yes
21:23:51 <mm_freak> > mzero :: [a]
21:23:52 <lambdabot>   []
21:24:12 <Saizan> Wooga: mzero and mplus are the methods of MonadPlus
21:24:18 <Wooga> ah, right!
21:24:25 <mm_freak> hmm
21:24:26 <Wooga> thank you!
21:24:37 <FunctorSalad_> MonadPlus exists because we don't have "forall a. Monoid m a" constaints ;)
21:24:38 <mm_freak> "methods" is not a good term, IMO
21:24:49 <FunctorSalad_> why?
21:24:51 <mm_freak> it makes people think that type classes are related to OOP
21:25:04 <mm_freak> or rather:  that type classes are used for OOP
21:25:14 <Saizan> same can be said for "class", i guess
21:25:32 <FunctorSalad_> I thought it's a nicely intuitive name for "things contained in a class definition" :)
21:25:46 <ddarius> "class" in the set-theoretic sense is a reasonable name for what type classes are.
21:25:54 <mm_freak> Saizan: what would you name it?  i mean, "method" is not wrong for some classes, but it's too special
21:26:21 <mm_freak> FunctorSalad_: so 'id' from Category is a "method"?
21:26:27 <ddarius> "properties" would probably be the "appropriate" name, but I'm not sure if that helps...
21:26:27 <mm_freak> it's just a value after all
21:26:58 <FunctorSalad_> mm_freak: I just consider the name appropriate in the weak analogy-sense I mentiond
21:27:05 <mm_freak> or, to stay on topic, mzero =)
21:27:07 <Saizan> i don't feel like a "method" has to be a function
21:27:25 <FunctorSalad_> ("subitems of a class definition")
21:27:39 <mm_freak> Saizan: well, a "method" is a "way to do something"
21:27:46 <Saizan> but i guess not being a native english speaker i don't care much about the natural language meaning of "method"
21:27:48 <mm_freak> so what does mzero "do"?
21:27:53 <dolio> fails
21:28:00 <Saizan> i found that has always helped me with terminology in CS :)
21:28:05 <mm_freak> dolio: it denotes failure
21:28:08 <FunctorSalad_> heh, the relationship between "method"(english) and "method"(oop) has long been lost on me
21:28:12 <mm_freak> in some monads =)
21:28:15 <FunctorSalad_> never made much sense to me
21:28:46 <ddarius> mm_freak: What monad does mzero not denoted failure?
21:29:05 <azaq231> MonadPlus == monad specialized monoid? Also same for Alternative in Control.Applicative?
21:29:08 <mm_freak> ddarius: the list monad
21:29:14 <mm_freak> ddarius: no result is not necessarily failure
21:29:27 <FunctorSalad_> azaq231: and you get that "m a" is a monoid for *all* a
21:29:37 <FunctorSalad_> can't express that with Monoid currently
21:29:46 <mm_freak> empty directory vs. the failure to read the directory contents
21:29:57 <mm_freak> empty file vs. the failure to read the file
21:31:07 <FunctorSalad_> some people suggested a MonadPlus for list-like things and a MonadPlus for (return x) `mplus` _ = return x-like things (failure MonadPluss)
21:31:30 <FunctorSalad_> the distinction wasn't exactly this, don't remember exactly
21:31:30 <Saizan> that's a very vague sense of failure that can be twarted to make mzero denote it or not on any monad depending on context
21:31:40 <ddarius> mm_freak: My opinion is that you are mixing to perspectives.
21:31:44 <Wooga> hm, in http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Control-Monad.html is line "xs      `mplus` _ys = xs" . is it missprint and actualy meant "xs      `mplus` _ = xs" ?
21:31:49 <ddarius> s/to/two
21:31:52 <mm_freak> FunctorSalad_: MonadError?
21:32:08 <ddarius> MonadOrElse
21:32:30 <FunctorSalad_> hmm MonadError is similar but has informative errors
21:32:51 <Saizan> Wooga: "xs      `mplus` _ys = xs" is valid haskell
21:32:51 <mm_freak> anyway, monads are a generic concept, so one can interpret it the way it fits for the current application
21:33:05 <Wooga> Saizan: yes, but what pointo having _ys ?
21:33:09 <Wooga> point*
21:33:44 <Saizan> Wooga: the author felt the need to give a name to the var but also signal that it's unused
21:34:00 <mm_freak> after all "failure" is just an interpretation
21:35:48 <dolio> Yes, it's only failure in list, maybe, either, IO...
21:36:11 <smorg> All conditionals here remind me of python ternary infix a bit... [True if True else False] vs [if True then True else False]
21:36:14 <mm_freak> IO and Either e are MonadPlus instances?
21:36:19 <FunctorSalad_> not necessarily in list, I found the directory example convincing
21:36:25 <Saizan> in general mzero will fail to provide an 'a', at least in the sense >>= wants one
21:36:29 <FunctorSalad_> IO is, yes :)
21:36:30 <dolio> Either e is probably not, but it could be for the right e.
21:36:34 <mm_freak> dolio: it's not failure in the list monad
21:36:36 <Saizan> s/sense/sense that/
21:36:39 <dolio> Yes, it is.
21:36:41 <mm_freak> it's an empty result
21:36:49 <FunctorSalad_> (I think `mplus` is just a catch that ignores the exception)
21:37:13 <dolio> mplus is a choice between successes, mzero is no successes, which is failure.
21:37:38 <FunctorSalad_> (in IO)
21:37:43 <mm_freak> mplus is a choice between results, mzero denotes no result
21:37:47 <mm_freak> is that interpretation invalid?
21:37:57 <dolio> No result is failure.
21:38:09 <FunctorSalad_> mplus is (+), mzero is 0
21:38:18 <ddarius> mplus is a choice between actions, not necessarily successes.
21:38:26 <azaq231> Functor [::] <-- what is this?
21:38:29 <FunctorSalad_> data Inty a = Int
21:38:29 <mm_freak> so reading a directory of configuration files fails, if the directory is empty?
21:38:34 <mm_freak> no matter what the application is?
21:38:38 <ddarius> azaq231: Parallel array.
21:38:44 <FunctorSalad_> *data Inty a = Inty Int
21:38:47 <azaq231> thanks
21:39:27 <dolio> Reading a directory isn't an action in the list monad.
21:39:44 <Saizan> when you present the results of reading a directory you're not using [] as a monad.
21:39:45 <FunctorSalad_> ListT IO?
21:39:54 <mm_freak> it is an action in the ListT transformer
21:39:57 <ddarius> mm_freak: If you are taking a monadic view of the list monad, then "reading a directory of configuration files" is "non-deterministically returning a configuration file" and then no configuration files is indeed failure.
21:40:24 <FunctorSalad_> even in the real lazy ListT if you use these directory streams I found recently
21:41:15 <mm_freak> ok, then consider this:  msqrt :: Floating a => a -> [a]
21:41:29 <mm_freak> results in [] if there are no square roots
21:41:36 <FunctorSalad_> (System.Posix.Directory)
21:41:38 <dolio> Failure to find a square root.
21:41:57 <mm_freak> failure to find a square root can be a different thing
21:41:57 <FunctorSalad_> now you are arguing semantics *hides from monochrom*
21:42:02 <mm_freak> for example if the input is NaN
21:42:22 <ddarius> mm_freak: And how do you intend that function represent this other failure?
21:42:42 <mm_freak> ddarius: EitherT
21:42:51 <mm_freak> or MaybeT
21:42:58 <ddarius> mm_freak: You didn't write a -> MaybeT [a]
21:43:25 <mm_freak> yes, and that means my function cannot express failure
21:43:33 <mm_freak> it can only express no square roots
21:43:38 <dolio> The monadic interpretation of msqrt is again "nondeterministically return a square root of the argument."
21:43:47 <dolio> Which, if there are 0, is failure.
21:44:00 <mm_freak> dolio: that's an interpretation
21:44:01 <ddarius> At any rate, no one is saying that [] represents all forms of "failure", what is being said is that mzero represents the notion of "failure" -for the given monad-.
21:44:15 <FunctorSalad_> (this wouldn't have happened if you used a quality field)
21:44:19 <mm_freak> "failure" is an interpretation, which is my point
21:44:30 <Saizan> (quality?)
21:44:42 <ddarius> mm_freak: Which is why mzero is called mzero and not mfail.
21:45:02 <mm_freak> ddarius: yeah, and which is why 'empty' is called 'empty' and not 'failed'
21:45:09 <FunctorSalad_> Saizan: "algebraically closed" if you insist ;)
21:45:16 <mm_freak> but dolio insists on the failure interpretation
21:45:32 <ddarius> mm_freak: You are misunderstanding what dolio is saying.
21:46:19 <mm_freak> well
21:46:38 <mm_freak> inodes :: Directory -> [Integer]
21:46:43 <Saizan> FunctorSalad_: if i knew how to interpret that i could insist :)
21:47:02 <mm_freak> non-determinism is also just an interpretation
21:47:13 <dolio> What are other interpretations *as a monad*?
21:47:25 <dolio> Would you write "inodes :: Directory ~> Integer"?
21:47:33 <dolio> That seems silly to me.
21:47:42 <mm_freak> arbitrarily many results
21:47:51 <dolio> Do you view it as a function from Directories to Integers with effects?
21:47:51 <FunctorSalad_> Saizan: I just meant that an algebraically closed field has a square root of any number (a zero for every polynomial, actually)
21:47:58 <mm_freak> and with (>>=) you bind "the current result"
21:48:03 <mm_freak> or whatever you would name it
21:48:21 <Saizan> FunctorSalad_: ah, i see :)
21:48:32 <mm_freak> if there is none, then there is none
21:49:23 <dolio> How is that any different from the nondeterminism interpretation, other than your not liking the word "failure"?
21:50:09 <mm_freak> all interpretations are equivalent
21:50:25 <mm_freak> so asking for difference is an invalid argument
21:50:53 <mm_freak> after all, interpretation is the stage where words become meaningful
21:51:01 <dolio> All right. I don't care anymore.
21:53:54 <dibblego> what is the haskell solution to the problem that CORBA attempts to solve?
21:54:13 <Heffalump> there isn't one
21:54:27 <Heffalump> (as haskell solution, that is)
21:54:34 <dibblego> is there a general solution?
21:54:43 <Heffalump> well, there's COM
21:54:45 <ddarius> dibblego: CORBA
21:55:09 <dibblego> have we not improved since CORBA/COM ?
21:55:17 <Heffalump> .NET/JVM?
21:55:42 <dibblego> hmm thanks, that's as far as I got too
21:55:59 <FunctorSalad_> what is the problem it attempts to solve, if you forgive my ignorance?
21:56:15 <Heffalump> binary compatibility between separately released components
21:56:29 <dibblego> serialising data types to/from different languages
21:56:32 <FunctorSalad_> ok
21:56:49 <kmc> there are a few forms of lightweight RPC for haskell
21:56:52 <Heffalump> if you just want the serialisation thing, there's stuff like JSON
21:56:53 <kmc> cross-language too
21:56:58 <FunctorSalad_> sounds like dbus, on linux
21:57:06 <kmc> but nothing solving the whole problem CORBA tries to solve
21:57:17 <kmc> CORBA is widely regarded as an overengineered mess and a general failure, though
21:57:18 <FunctorSalad_> (at least that has some 'general' types)
21:57:31 <dibblego> kmc, what is the lightweight RPC you refer to?
21:58:01 <kmc> thrift, for one
21:58:09 <kmc> there's also a module for speaking Erlang's protocol
21:58:15 <kmc> and probably other stuff
21:58:18 <kmc> google protobuf?
21:58:31 <kmc> json and xml, if you consider those "lightweight"
21:58:52 <kmc> but xml-rpc is conceptually lightweight compared to CORBA, if not in actual network efficiency
21:59:02 <azaq231> @src (<**>)
21:59:02 <lambdabot> (<**>) = liftA2 (flip ($))
21:59:16 <azaq231> that's flip (<*>), that definition is quite silly
21:59:32 <ddarius> azaq231: No it isn't.
21:59:38 <azaq231> no?
22:00:00 <kmc> flip (<*>) will flip the order of effects too
22:00:30 <FunctorSalad_> while we're at it, is there really no flip (<$>)?
22:00:43 <FunctorSalad_> I called it <€> for lack of a free character...
22:01:23 * FunctorSalad_ recently like left-to-right composition :o
22:01:24 <kmc> :D
22:01:24 <dibblego> thanks for the tips
22:01:26 <FunctorSalad_> *likes
22:02:33 <dibblego> FunctorSalad_, you mean >>> ?
22:02:38 <FunctorSalad_> I even made a library systematically naming all the left-to-right compositions, but surely everyone has their own idea ;)
22:02:46 <FunctorSalad_> dibblego: that's flip (.)
22:03:01 <dibblego> FunctorSalad_, then what do you mean by left-to-right composition?
22:03:26 <FunctorSalad_> dibblego: (>>>) is a perfectly fine examle
22:03:29 <mm_freak> FunctorSalad_: i'm usually happy with (<$> something) =)
22:03:30 <FunctorSalad_> also >=>
22:03:37 <dibblego> ah right
22:03:46 <FunctorSalad_> and >>= if you include application
22:05:30 <FunctorSalad_> my humble suggestions ;) http://code.haskell.org/~daniels/composure/dist/doc/html/composure/Control-Composure.html
22:05:43 <FunctorSalad_> for naming the left-to-right applications and compositions
22:07:36 <FunctorSalad_> it even subsumes one existing one of the 15 operators ;) ((>=>))
22:08:25 <mm_freak> is there a type level @?
22:08:59 <mm_freak> class Flip a where type Flipped a; fflip :: a -> Flipped a
22:09:00 <mm_freak> instance Flip (a -> b -> c) where type Flipped (a -> b -> c) = b -> a -> c; fflip = flip
22:09:05 <mm_freak> looks a bit strange =)
22:10:01 <azaq231> liftA2 f a b = f <$> a <*> b. flip ($) <$> Just 10 will yield Just ($ 10), and then <*> (Just f) is Just (f 10). I don't see how that is different from Just 10 <*> (Just f) = Just (f 10)
22:10:24 <azaq231> Maybe obviously just being an example
22:10:42 <FunctorSalad_> (admittedly the operators seem strange even to myself, but it's hard to combine systematic consistency and lack of clashing with very common operators and beauty)
22:10:42 <kmc> > (,) <$> Left 3 <*> Left 4
22:10:43 <lambdabot>   No instance for (Control.Applicative.Applicative
22:10:43 <lambdabot>                     (Data....
22:11:03 <kmc> > (,) <$> "ab" <*> "cd"
22:11:03 <lambdabot>   [('a','c'),('a','d'),('b','c'),('b','d')]
22:11:06 <kmc> > (,) <$$> "ab" <*> "cd"
22:11:06 <lambdabot>   Not in scope: `<$$>'
22:11:12 <kmc> > (,) <$> "ab" <**> "cd"
22:11:13 <lambdabot>   Couldn't match expected type `(b1 -> (GHC.Types.Char, b1)) -> b'
22:11:13 <lambdabot>         ag...
22:11:20 <kmc> :t (<**>)
22:11:21 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
22:11:31 <FunctorSalad_> for example, I wanted two-character operators at first, but all of the repeated two-char ones are already taken
22:11:34 <dolio> mm_freak: Are you trying to write type-level flip? Because that would have type (* -> * -> *) -> * -> * -> *
22:11:41 <FunctorSalad_> >>,++,--,**....
22:11:43 <dolio> Or something with kind polymorphism.
22:11:53 <mm_freak> dolio: no, i'm trying to generalize 'flip'
22:11:56 <FunctorSalad_> %% and @@ not
22:11:58 <kmc> > [succ,pred] <*> [10,20,30]
22:11:58 <dolio> Oh, okay.
22:11:59 <lambdabot>   [11,21,31,9,19,29]
22:11:59 <mm_freak> a value-level flip, that is
22:12:04 <kmc> > [10,20,30] <**> [succ,pred]
22:12:05 <lambdabot>   [11,9,21,19,31,29]
22:12:13 <FunctorSalad_> hmm and //
22:12:14 <kmc> azaq231, note different order ^^^^
22:12:26 <FunctorSalad_> so I might use %, @ and /...
22:12:36 <FunctorSalad_> in some order (for pure, functorial, kleisli)
22:14:08 <mm_freak> not very useful…  i think, generalizing composition makes more sense
22:14:19 <FunctorSalad_> (##) is a valid operator too I just noticed
22:14:28 <FunctorSalad_> hmm? I am generalizing composition
22:14:37 <dolio> f a b c -> f b a c is a possibility.
22:14:51 <dolio> Making that specialize to flip isn't an option, though.
22:14:52 <azaq231> kmc: thanks, see it now >.<
22:15:00 <FunctorSalad_> it's the functions that can be pure, kleisli (as for (>=>)) or functor-wrapped (as for ((<*>)))
22:15:03 <mm_freak> FunctorSalad_: i'm talking to myself
22:15:07 <FunctorSalad_> I see
22:15:17 <dolio> @type flip -- there's also this
22:15:18 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
22:16:10 <mm_freak> :t fmap . flip
22:16:11 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) b. (Functor f, Functor f1) => f1 (a -> b) -> f a -> f (f1 b)
22:16:18 <mm_freak> uhm
22:17:18 <mm_freak> > flip sqrt 4 :: [Double]
22:17:19 <lambdabot>   Couldn't match expected type `[a -> GHC.Types.Double]'
22:17:19 <lambdabot>         against infe...
22:17:37 <mm_freak> > flip [sin, cos] 4
22:17:38 <lambdabot>   [-0.7568024953079282,-0.6536436208636119]
22:18:49 <mm_freak> hmm, i think that's generalized so much that you can't even call it "flip" anymore =)
22:19:03 <FunctorSalad_> haha @that flip
22:19:18 <dolio> I prefer the name 'eta'.
22:19:29 <dolio> But that's me.
22:19:38 <FunctorSalad_> f ((->) a b)               ->                     (->) a (f b)
22:19:50 <FunctorSalad_> you see, it commutes the f with the (->) a
22:19:51 <FunctorSalad_> ;)
22:19:58 <mm_freak> FunctorSalad_: btw, what about (.) from Control.Category?
22:20:32 <FunctorSalad_> that doesn't help much since you need newtypes kleisli, which is a bit of a pita
22:20:37 <FunctorSalad_> *newtyped
22:20:45 <mm_freak> yes, true
22:21:13 <FunctorSalad_> (and I'm naming the various hetero-composition of pure and kleisli or applicative anyway)
22:21:57 <FunctorSalad_> *compositions
22:23:41 * hackagebot directory-tree 0.9.1 - A simple directory-like tree datatype, with useful IO functions  http://hackage.haskell.org/package/directory-tree-0.9.1 (BrandonSimmons)
22:24:48 <FunctorSalad_> now, if utf8 finally became the standard, that'd open up a whole new world of infix cuteness ;)
22:25:16 <siracusa> Is there a way to exit a `forever ioAction' gracefully?
22:25:24 <mm_freak> siracusa: ContT
22:26:00 <FunctorSalad_> fix (\self -> .... when condition self)
22:26:39 <mm_freak> FunctorSalad_: usually 'forever' is more convenient =)
22:26:54 <FunctorSalad_> (the 'when' as the last part of a 'do' construct or after a '>>')
22:28:01 <siracusa> mm_freak: Yeah, I replaced a let loop = .. in loop by forever. ContT looks a bit stange
22:30:44 <FunctorSalad_> functional goto ;)
22:32:35 <mm_freak> hpaste is down
22:34:04 <siracusa> Or is it to use forever in conjunction with the ContT monad?
22:34:36 <mm_freak> siracusa: yes, i'm coding an example
22:34:43 <Saizan> siracusa: you could just throw an exception and catch it just outside the forever
22:35:02 <Saizan> ContT would implement that with CPS instead
22:35:36 <siracusa> Saizan: I thought about that but I was looking for a cleaner solution ;-)
22:35:40 <Saizan> ?type let abort x = ContT $ \_ -> return x in abort
22:35:40 <lambdabot> forall r (m :: * -> *) a. (Monad m) => r -> ContT r m a
22:36:09 <Saizan> you can use that abort then, and wrap the thing in "flip runContT return"
22:36:28 <Saizan> (but then you need to lift the IO parts into ContT)
22:36:57 <mm_freak> siracusa: http://codepad.org/yMx0oPwO
22:37:39 <Saizan> monadlib defines abort?
22:37:55 <mm_freak> Saizan: yes
22:37:59 <Saizan> nice
22:38:19 <mm_freak> monadlib also defines named labels, so you get a real goto =)
22:38:35 <mm_freak> which, of course, you don't want to use =P
22:38:48 <newsham> real goto considered harmful?
22:39:02 <siracusa> mm_freak: Thanks
22:40:39 <Saizan> actually, someone could implement (delimited) continuations for IO
22:41:17 <mm_freak> Saizan: as an effect?
22:41:56 <Saizan> yeah
22:42:42 <mm_freak> that could be useful, even though i'd probably continue using ContT
22:43:06 <mm_freak> (what a pun)
22:43:43 <dolio> CCT IO sort of gets you that.
22:44:10 <dolio> At least, I can't imagine what else putting them directly in IO would get you, other than performance.
22:45:04 <Saizan> not having to stack a transformer over IO, and that
22:45:36 <kmc> you could also exit "forever" with exceptions, yes?
22:45:50 <dolio> Presumably.
22:46:05 <mm_freak> at least in monadLib ContT is a newtype, so i'd question that it can't be as fast as IO continuations
22:46:36 <dolio> It's not the wrapper that's the issue.
22:46:47 <dolio> It's the fooling around with higher order functions and composition.
22:47:15 <dolio> Although, I don't know that sticking it in IO could do better.
22:47:21 <mm_freak> how can you get around that without losing the flexibility of ContT?
22:47:58 <dolio> In theory you can capture up whatever is internally used as a stack, and fool around with that.
22:48:11 <mm_freak> (other than requiring that you don't exit two layers at the same time)
22:48:12 <kmc> @src IO
22:48:12 <lambdabot> Source not found. You untyped fool!
22:48:15 <kmc> aww
22:48:18 <kmc> we used to have it ;P
22:48:33 <mm_freak> ST RealWorld, isn't it?
22:48:41 <mm_freak> at least in GHC
22:48:48 <kmc> more or less
22:48:52 <dolio> But I don't know that having a stack amenable to fooling around like that isn't slower to begin with.
22:49:04 <kmc> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:49:08 <dolio> I guess SML does all right with it, though.
22:49:48 <kmc> so, what primop would you need to add to put continuations into IO?
22:50:02 <mm_freak> i don't think you need any
22:50:12 <kmc> you can just CPS-transform those functions?
22:50:18 <Saizan> SML being call-by-value might have different tradeoffs though
22:50:39 <mm_freak> ioCallCC :: ((a -> IO b) -> IO a) -> IO a
22:51:04 <kmc> now implement it ;)
22:51:32 <mm_freak> kmc: exceptions =)
22:51:41 <kmc> aww
22:51:44 <kmc> that's cheating ;P
22:51:51 <mm_freak> and it's not correct either
22:52:05 <kmc> plus it won't work in the other direction
22:52:16 <dolio> Saizan: Yeah. Haskell's evaluation model doesn't lend itself to the same kind of stack stuff. And I doubt that changes when IO is involved.
22:52:19 <mm_freak> callCC allows taking the continuation outside
22:52:41 <kmc> Haskell's (GHC's?) evaluation model already has the calling structure in the heap
22:53:09 <mm_freak> hmm
22:53:12 <kmc> but i guess a continuation has to save the stack of pattern-matching
22:53:22 <kmc> which frames are already called "continuations" in GHC literature
22:53:32 <Saizan> dolio: seems to work decently for exceptions though, but i don't really know much about this
22:53:56 <mm_freak> abortable :: (forall s. (s -> a -> IO b) -> s -> IO a) -> IO a
22:54:04 <mm_freak> but that's ugly
22:54:44 <mm_freak> abortable :: (forall s. (a -> s a) -> (s a -> IO b) -> IO a) -> IO a
22:56:35 <dolio> Saizan: Yeah, I don't actually know how those work.
23:04:28 <FunctorSalad_> a trivial menu for looking up locally installed haddocks... https://patch-tag.com/r/FunctorSalad/hdoc/snapshot/current/content/pretty/hdoc
23:07:40 <FunctorSalad_> have a similar thing for ghc -e ':bro' :)
23:09:30 <FunctorSalad_> (thought a global haddock index is supposed to do this but it still doesn't exist for me ;))
23:12:01 <Saizan> (checked the mail? i thought i sent it!)
23:14:31 <Saizan> documentation: True
23:14:38 <Saizan> doc-index-file: $datadir/doc/index.html
23:14:56 <FunctorSalad_> I have these :(
23:15:17 <Saizan> and no ~/.cabal/config/share/doc/index.html ?
23:15:37 <FunctorSalad_> (well, doc-index-file: /usr/local/share/doc/index.html )
23:16:05 <FunctorSalad_> not in said location, no
23:16:44 <Saizan> i wonder if it's a problem with write permissions
23:16:47 <aleator> Is there any way to configure haskell-platform without GL? I'd like to have it on a headless server.
23:17:11 <FunctorSalad_> I'm running the cabal as root, otherwise it'd install nothing into /usr/local
23:19:17 <Saizan> it should print something like "Updating documentation index /usr/local/share/doc/index.html"
23:20:39 <Saizan> cabal --version ?
23:20:56 <FunctorSalad_> cabal-install version 0.9.2
23:20:57 <FunctorSalad_> using version 1.9.2 of the Cabal library 
23:22:23 <Saizan> oh, but how are you running it as root? it might be picking up root's config
23:22:34 <dibblego> is there a more appropriate monad than State for this? http://paste.pocoo.org/show/248273/
23:23:06 <FunctorSalad_> Saizan: the line you mention doesn't appear (but it does install the haddock just fine, just not the index)
23:23:58 <FunctorSalad_> Saizan: I have ~/.cabal symlinked to /root/.cabal due to that problem ;)
23:24:11 <FunctorSalad_> (the directory)
23:30:22 <Saizan> you should file a bug report, possibly with instructions to reproduce it
23:31:57 <FunctorSalad_> ok, though maybe it's not a huge priority :) easy enough to predict the urls for a given (package,module)
23:32:11 <FunctorSalad_> (as in that script)
23:32:36 <FunctorSalad_> (but then it might also be a simple problem...)
23:33:02 <Saizan> yeah, asking ghc-pkg is what cabal does anyhow :)
23:35:11 <Zao> dibblego: I can't tell what the heck it's supposed to do.
23:35:58 <dibblego> Zao, I am trying to write g using f
23:44:08 <mm_freak> implementing the Cont monad yourself is very enlightening
23:44:24 <mm_freak> and it's interesting how simple the definition of 'abort' is =)
23:44:32 <mm_freak> abort x = Cont $ const x
23:44:39 <ezyang> Cont is pretty great. 
23:45:08 <ezyang> Actually, as far as I can tell, the 'mother of monads' property ties back to lambda calculus, since everything can be represented as functions. 
23:45:12 <ezyang> *lambdas 
23:45:36 <mm_freak> well, i don't find Cont alone very useful
23:45:40 <mm_freak> i mostly use ContT
23:45:53 <ezyang> Sure :^) 
23:46:02 <ezyang> CPS is also a common implementation method for monads 
23:46:57 <Saizan> Not . Not is actually related to church encoding..
23:47:49 <Saizan> it's funny how the fact that Void is the empty type is often irrelevant when you consider the computational content of these things
23:52:26 <Saizan> that was backwards, but anyhow.
23:59:34 <etpace> :ty let foldlM f z xs = foldl (\acc x -> acc >>= flip f x) (return z) xs in foldlM
23:59:51 <etpace> :t let foldlM f z xs = foldl (\acc x -> acc >>= flip f x)  (return z) xs in foldlM
23:59:52 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
