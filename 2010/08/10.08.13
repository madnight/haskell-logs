00:00:13 <jrockway> yeah
00:00:16 <jrockway> yeah, probably too slow
00:00:23 <etpace> like, HELLA slow
00:00:26 <Heffalump> csv just needs lexing really
00:00:28 <etpace> we used a lexer
00:00:31 <jrockway> yeah
00:00:42 <jrockway> i don't think parsec is the best fit for massive low-latency data transformation
00:00:51 <jrockway> that sort of stuff is easy to do with bytestrings or C though
00:01:01 <jrockway> the hard stuff are things like mini-langauges (or maxi-langauges)
00:01:04 <jrockway> and parsec makes that easy
00:01:12 <Heffalump> you reckon Haskell's performance is predictable enough for low-latency anything?
00:01:26 <etpace> write haskell that generates c :)
00:01:30 <jrockway> low latency, to my project, means "do something simple in less than a second"
00:01:41 <jrockway> we drive "human-based" trading systems
00:01:49 <jrockway> so as long as the computer is relatively quick, we are fine
00:01:57 <jrockway> that is why i have no worries about haskell vs. c++
00:02:07 <jrockway> because the C++ is really, really, really inefficient, and the users are happy
00:03:21 <etpace> worst i've found with haskell so far is the space leaks and debugging them
00:03:28 <etpace> can cause some big headaches
00:03:31 <jrockway> yes
00:03:36 <jrockway> that was one problem i had
00:03:52 <jrockway> i was using writer to collect warning messages, and it made my whole loop-over-the-dataset consume stack
00:04:02 <jrockway> i wrote a very strict version of writer and it still happened
00:04:07 <jrockway> i switched to state instead, no leak
00:04:13 <jrockway> i still don't really understand that
00:04:17 <etpace> I spent three days using profiling tools, it wasnt giving me near the function that was responsible, simply the stuff that was "making" the space
00:04:37 <jrockway> yeah
00:04:42 <jrockway> i have had similar problems
00:04:44 <etpace> turns out a few levels up I bound something to a name isntead of _, and that caused it
00:04:46 <jrockway> not really a deal killer
00:04:53 <etpace> even though that name was never used :)
00:04:53 <jrockway> interesting
00:05:00 <jrockway> did you compile with optimizations?
00:05:03 <etpace> yep
00:05:10 <jrockway> interesting
00:05:12 <jrockway> these issues are annoying
00:05:18 <etpace> it even warned me saying it wasnt used, so it knew it could throw it away
00:05:23 <jrockway> but the otherwise rapid-development makes it a reasonable tradeoff
00:05:29 <jrockway> and i have dealt with C++ memory problems
00:05:43 <jrockway> and those are completely unsolvable most of the time, even with tools like valgrind
00:05:43 <etpace> rapid and fun development
00:06:25 <zenzike> Heya, just a quick question: does ghc produce code that has any form of implicit memoisation? ie if a function is called twice with the same arguments, but from different other functions, will the second call return quickly?
00:09:11 <Heffalump> zenzike: no
00:09:35 <Heffalump> there are fairly straightforward ways to set that up if you want, though, e.g. using lazy data structures
00:10:11 <zenzike> Heffalump: thanks. are there any rules for memoising values within a function though? eg. foo x + foo x, will foo get evaluated twice, or does ghc use a rule to make that once?
00:10:49 <zenzike> (also, is ghc's behaviour for these issues documented anywhere? I've searched, but no potatotes)
00:10:54 <Heffalump> I think GHC does do a bit of CSE, but it has to be quite careful not to introduce a space leak.
00:11:02 <Heffalump> Not very well, which is a shame.
00:11:13 <c_wraith> a named expression is only evaluated once.
00:11:24 <Heffalump> yes, that's a very clear rule
00:11:56 <zenzike> phew, I assumed that at least that would be the case!
00:12:21 <zenzike> Heffalump: CSE?
00:12:23 <jrockway> structures like "fibs = 1 : 1 : (zipWith (+) fibs (tail fibs))" also "memoize"
00:12:35 <Heffalump> zenzike: common subexpression elimination
00:13:03 <Heffalump> zenzike: what's missing is clear documentation or guarantees on when optimisations like foo x + foo x -> let y = foo x in y + y will happen in the compiler
00:13:03 <zenzike> jrockway: yup, I can see that one pretty easily, since fibs is a named expression
00:13:18 <zenzike> Heffalump: shock horror!
00:13:27 <zenzike> Is nobody working on that?
00:13:40 <jrockway> this is the sort of thing that people tend to "memoize" in strict language
00:13:42 <c_wraith> it's easiest to assume it'll never happen.
00:13:52 <jrockway> but in the case of haskell, lazy lists do the same thing
00:13:57 <Heffalump> I think there is a reasonable amount of scattered information around that has appeared in response to mailing list posts etc.
00:14:03 <c_wraith> Because it's nearly impossible to prove that it's actually beneficial to do so
00:14:14 <Heffalump> but I don't think anyone has pulled it together. I could be wrong though.
00:14:40 <Heffalump> c_wraith: not at all. If (+) is strict in the example above then the transformation is safe and beneficial.
00:15:39 <c_wraith> strict isn't enough.
00:15:43 <Cale> The only CSE which is done by GHC is where you have a directly nested pair of case expressions whose scrutinee is the same
00:15:44 <zenzike> If (+) isn't strict, I still can't see why it's bad. 
00:16:01 <c_wraith> You need to prove that the result is actually smaller than the expression.
00:16:09 <Heffalump> zenzike: because (+) might evaluate its left argument and never evaluate its right argument
00:16:32 <Heffalump> but until you discover it's never going to evaluate its right argument, the GC will hold onto 'y'
00:16:37 <Cale> (which is something that is more likely the result of inlining or other transformations on code than something written by a human of course)
00:16:48 <zenzike> Heffalump: sure, but if the left value is memoised, then why would it be bad to use it again in the right expression?
00:17:06 <Heffalump> zenzike: because y might be a very large bit of data
00:17:24 <Heffalump> it's the classic problem of memoisation - it introduces memory leaks
00:17:41 <zenzike> Heffalump: doesn't a pointer get passed around since we're dealing with immutable data?
00:17:53 <zenzike> Heffalump: IE, why would we copy the data?
00:18:09 <c_wraith> You wouldn't copy it.  You just would fail to free it.
00:18:42 <c_wraith> The common example is the expression [1..10000000] ++ [3] ++ [1..10000000]
00:18:42 <zenzike> c_wraith: why doesn't y get freed when the let expression goes out of scope?
00:19:02 <c_wraith> If you do CSE on that, the you'll probably run out of memory
00:19:10 <jrockway> i wonder if this is the sort of thing that where a runtime/VM like LLVM has enough information to do the right thing
00:19:14 <Heffalump> zenzike: because the result of the expression will embed references to y.
00:19:21 <c_wraith> If you don't do CSE on it, you may or may not run out of memory, depending on how you use it.
00:19:28 <Heffalump> You can't free y in that situation in any language that has implicit references (e.g. C# or Java)
00:19:36 <zenzike> ah, thanks guys. that makes sense.
00:20:38 <zenzike> Heffalump: but Haskell doesn't have implicit references unless we're in the right monad right?
00:21:02 <zenzike> ah, you were replying to jrockway weren't you?
00:21:50 <Heffalump> it does have implicit references. let y = [1..5] in x = y -- x is an implicit reference to the [1..5]
00:22:11 <Heffalump> what it doesn't have is implicit *mutable* references
00:23:10 <zenzike> but even in your example, I can't see why the allocated data would need to hang around after the let expression is out of scope
00:23:32 <Heffalump> map (+1) (let y = [1..5] in y)
00:23:32 <c_wraith> in my example?
00:23:36 <c_wraith> It wouldn't.
00:23:39 <Heffalump> sorry, my example was syntactically wrong
00:23:43 <zenzike> (Heffalump's example)
00:24:03 <Heffalump> but ni my fixed version, the [1..5] escapes the scope of the let
00:24:33 <c_wraith> the basic idea is that because of laziness, very large data structures can be used in constant memory, if you are careful.
00:24:53 <kmc> zenzike, if you want to do memoizing yourself, data-memocombinators is a nice lib for it
00:24:58 <BMeph> I believe the "canonical" example is more like "sum [1..1000] + some n + product [1..1000]" -- the [1..1000] is in common, but it uses less memory to re-calculate it without holding the list around.
00:25:28 <kmc> yeah
00:25:29 <zenzike> kmc: thanks :-)
00:25:29 <c_wraith> unfortunately, sum and product both fail at working in constant space.
00:25:35 <kmc> lazy data structures are also control-flow structures
00:25:51 <kmc> and CSE could basically force the control flow to be unrolled into memory at runtime when it wouldn't otherwise be
00:26:33 <zenzike> so the bottom line is that CSE isn't always beneficial, so GHC rarely does it?
00:26:40 <Heffalump> correct
00:26:50 <Heffalump> if you want to be sure, set it up yourself
00:27:00 <zenzike> thanks, that's helpful
00:27:27 <zenzike> I always thought that where expressions were just sugar, but I guess this means that they change the operational semantics of code too
00:28:12 <Heffalump> and as BMeph etc have pointed out, my example of fib x + fib x -> let y = fib x in y + y when (+) is strict is also wrong as an example of where cse is safe
00:34:38 <Heffalump> jrockway: re your LLVM suggestion, I can't think of much dynamic information that could help with optimisation in this case. Perhaps knowing the runtime sizes of things might help.
00:40:49 <jrockway> i'm thinking of some sort of JIT that compiles the memoized path and unmemoized path
00:41:07 <jrockway> if $heuristic then save x for future use, else free it after this computation
00:41:34 <jrockway> sort of how tracing VMs have the "slow path" (arbitrary precision) and "fast path" (machine integers) depending on the values at runtime
00:41:44 <jrockway> disclaimer: i have never written a real compiler :)
00:46:48 <Heffalump> hmm, makes some sense, but wouldn't you get exponential blowup in the number of values in any given bit of code?
00:47:18 <Heffalump> getting compilers to make good decisions consistently is hard :-)
00:48:45 <kulin> i watched a thing on discovery channel, you just need to make compilers with neural networks
00:50:30 <jrockway> no, quantum computers
00:50:40 <jrockway> just run every possible program and only print the answer from the correct one
00:50:49 <jrockway> time travel is another good idea
00:51:07 <jrockway> if your program takes 10 minutes to run, just travel back into the past 10 minutes, start the program, return to the future, and enjoy the results
00:52:42 <Heffalump> kulin: how would neural nets solve the problem? The best known examples of neural net implementations don't consistently make good decisions either.
00:53:04 <kulin> i dont know, that was all discovery channel had to say, that they fix problems
00:53:14 <Heffalump> ("best known examples" = humans)
00:55:08 * tibell_ just remembered why he dislikes using Template Haskell.
00:56:07 <Heffalump> it's pretty much a last resort, IMO
00:56:14 <Heffalump> we definitely need some nicer solution for this whole instances thing
01:02:06 <hgolden> what does the @ do in this phrase: (ptr@(~(Ptr addr)))  ?  where can i learn about @ ?
01:03:15 <ketil> hgolden, it names the expression 'ptr'.   So in addition to a variable 'addr', you get an additional variable 'ptr'.
01:03:28 <kulin> what is the ~ ?
01:03:38 <azaq231> kulin: lazy pattern match
01:03:41 <kulin> ah
01:04:59 <hgolden> it's part of this line of code which ghc-6.12.3 objects to:  (ptr@(~(Ptr addr))) <- withCString symbol c_lookupSymbol
01:06:13 <hgolden> error message:  A lazy (~) pattern cannot contain unlifted types ~(Ptr addr)
01:06:23 <kmc> oh, is addr of type Word# or such?
01:07:07 <adnap> Is this a common function? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28990#a28990
01:07:31 <kmc> what's it do adnap?
01:07:44 <Heffalump> adnap: unfold
01:07:50 <kmc> :t unfold
01:07:52 <lambdabot> Not in scope: `unfold'
01:07:53 <kmc> :t unfoldr
01:07:54 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:08:22 <Heffalump> :t \f -> unfoldr (Just . f)
01:08:23 <lambdabot> forall a b. (b -> (a, b)) -> b -> [a]
01:08:26 <hgolden> kmc: i don't know what the type of addr is
01:08:43 <kmc> oh
01:08:47 <kmc> where did this code come from?
01:09:03 <hgolden> it's in dons's plugin package
01:09:09 <kmc> oh
01:09:16 <kmc> plugins is way deprecated
01:09:21 <hgolden> (which i'm trying to update so it compiles in 6.12)
01:09:35 <kmc> don't think it's built on any GHC since 6.8
01:09:36 <kmc> ah
01:09:41 <kmc> you've seen hint and direct-plugins?
01:09:45 <hgolden> kmc: is there a better alternative?
01:10:18 <hgolden> i'll look at hint. i'm aware of direct-plugins
01:12:53 <adnap> Ah, like this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28990#a28991
01:13:44 <kmc> hgolden, re the specific error
01:13:50 <kmc> in current ghc source i see
01:13:54 <kmc> data Ptr a = Ptr Addr#
01:14:01 <kmc> which means that "addr" there is indeed an unlifted type
01:14:10 <kmc> so it makes sense that a lazy pattern is not allowed
01:14:30 <adnap> @hoogle unfoldForest
01:14:31 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
01:14:31 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
01:14:31 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
01:14:33 <kmc> some sense anyway
01:15:08 <adnap> Can I get a code review?
01:15:45 <hgolden> kmc: is there some way to fix the line above to make it compile?
01:16:18 <Heffalump> adnap: of what?
01:16:55 <Heffalump> adnap: the function you gave is precisely \xs f -> flip unfoldr (Just . f) xs, but with a less general type
01:18:55 <adnap> Heffalump: It's code for a data structure and a means to encode/decode it.  The structure is like this: 5:hello2:3:dog0:3:cat0: or a:bc:d, where a is length of b, b is data, c is number of children, and d is childrens' data.
01:20:43 <Jonno_FTW> > map (\x -> flip . uncurry (^)) [(a,b)|a<-[1..10],b<-[4]]
01:20:43 <lambdabot>   No instance for (GHC.Num.Num (f (a -> b)))
01:20:44 <lambdabot>    arising from a use of `e_1110...
01:20:47 <adnap> Heffalump: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28971#a28993
01:21:04 <Jonno_FTW> > map (\x -> flip $ uncurry (^)) [(a,b)|a<-[1..10],b<-[4]]
01:21:05 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> (a -> b, b1) -> b)
01:21:06 <lambdabot>    arising...
01:21:12 <Jonno_FTW> > map (\x -> flip $ uncurry (x^)) [(a,b)|a<-[1..10],b<-[4]]
01:21:13 <lambdabot>   Couldn't match expected type `b1 -> a -> b'
01:21:13 <lambdabot>         against inferred type `...
01:21:16 <Jonno_FTW> bah
01:21:49 <kmc> hgolden, what if you just remove the ~
01:21:57 <adnap> Heffalump: Winnie the Pooh, Winnie the Pooh, da da da...
01:22:24 <Heffalump> adnap: your code looks reasonable, though it might benefit from using a monad to wrap up the (LBS.ByteString -> (a, LBS.ByteString)) plumbing
01:22:35 <Heffalump> that would help with all the b' b'' b'''' etc
01:22:55 <Heffalump> also, you use length as a variable name which clashes with a library function, though in such a small scope it may not be too confusing
01:23:07 <adnap> Heffalump: Can you explain in more detail?  I'm a beginner at using Monads, and I've never had to define my own.
01:23:09 <hgolden> kmc: i'll try that, but i still don't understand what's going on here. why would dons put the ~ there in the first place?
01:23:43 <Heffalump> adnap: it would be easiest if you read a bit about parsers with monads for yourself. But essentially the type above corresponds to State LBS.ByteString a
01:24:07 <kmc> hgolden, i can't say for sure why, without the context
01:24:13 <Heffalump> and all the manual threading of the bytestrings could be hidden inside the monad operations
01:24:45 <Heffalump> I don't have time right now, but in a bit (30-60 mins) I could try to rewrite decode' in terms of State, if you're interested.
01:25:09 <adnap> Heffalump: Okay, well I've reading "All About Monads" slowly, so maybe I'll have a clue after I'm done with that.
01:25:14 <kmc> «(Foo x) <- e» has the effect that the value resulting from the "e" computation will be forced to weak head-normal form before the do-block continues
01:25:31 <adnap> Heffalump: *I'm reading
01:25:40 <kmc> «~(Foo x) <- e» will defer that, and raise an exception later if it turns out that "e" produced a constructor other than Foo, or produced an exceptional value
01:25:47 <Heffalump> kmc: assuming Foo is not a newtype
01:26:00 <kmc> yeah, that's true
01:26:10 <kmc> in the case of newtype, pattern matching it never forces to whnf
01:26:13 <kmc> and the ~ would be redundant
01:26:23 <kmc> Ptr is not a newtype though
01:26:37 <kmc> it couldn't be, if the field is an unboxed value
01:26:51 <adnap> Heffalump: Yeah, that would be cool if you had the time to refactor my code.  Just modify the hpaste.
01:26:54 <kmc> i wonder, why does GHC disallow this use of ~ patterns
01:27:07 <hgolden> kmc: see trac 2806
01:27:20 <Heffalump> kmc: wouldn't that use imply making a suspended unboxed value?
01:27:21 <Heffalump> which makes no sense
01:27:26 <hgolden> (which i don't understand)
01:27:28 <kmc> yeah, i thought about it a bit more, and it would
01:28:18 <hgolden> kmc: without the ~, the code compiles. i'll have to see if it works properly.
01:29:29 <adnap> Also, is there a function that splits a list at the first occurence of a delimiter, and gives a tuple where neither list contains the delimiter?
01:29:44 <kmc> adnap, check Data.List and also the "split" package
01:29:50 <hgolden> kmc: thanks for your help. (i still have a _lot_ to learn!)
01:30:01 <seric_> hgolden: who doesn't ...
01:30:03 <kmc> no problem hgolden :)
01:30:50 <hgolden> seric: all these "twisty little passages"!
01:37:11 <tallpaul> why is it necessary to calculate the evaluation order before evaluation? I think the order is clear during evaluation.
01:38:05 <JHaskly> Hi, can anyone tell me why this list, f = 0 : map (\x -> x + f !! (x-1)) [1..] is of type [Int], rather than type [Integer]?
01:38:25 <koala_man> tallpaul: how do you mean?
01:38:29 <Zao> JHaskly: Defaulting?
01:38:39 <Zao> JHaskly: Or the context you use it in?
01:38:50 <Zao> JHaskly: Try annotating it with :: [Integer] and see if anything blows up.
01:39:04 <Zao> Oh, !! takes Int, doesn't it?
01:39:05 <JHaskly> I did, and it blew up
01:39:06 <c_wraith> It's because of the !!
01:39:13 <c_wraith> yeah, !! requires its second arg be an int
01:39:18 <Zao> Isn't there a genericIndex?
01:39:23 <Zao> Like there's genericLength and such?
01:39:25 <c_wraith> probably
01:39:38 <Deewiant> ?ty genericIndex
01:39:39 <tallpaul> i want to write a compiler/interpreter and I read that it is necessary to calculate the evaluation order before interpretation.
01:39:42 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
01:40:47 <Cale> tallpaul: That's not necessarily the case -- you can do it implicitly in the way that you interpret the code.
01:41:10 <tallpaul> but what helps to calculate it?
01:41:27 <Cale> Usually, you stick with some simple rule.
01:41:52 <JHaskly> Ok, thanks guys! genericIndex works :D
01:42:07 <Cale> Most languages use strict evaluation, which means that you always evaluate a function and its parameters before evaluating the application of the function to the parameters.
01:42:09 <harlekin> In reactive-glut, does anyone else experience that the framePass event doesn't have any occurences?
01:42:58 <tallpaul> Cale: it's clear, but exactly this is what i'm doing while interpretation.
01:43:50 <Cale> So, to give my standard example, if we have a function  double x = x + x
01:44:08 <Cale> and we evaluate  double (double 5)  under strict evaluation, it goes:
01:44:09 <Deewiant> JHaskly: Using indexing like that is inefficient though; calculating n elements of that list takes O(n^2) work
01:44:13 <Cale> double (double 5)
01:44:18 <Cale> double (5 + 5)
01:44:21 <Cale> double 10
01:44:25 <Cale> 10 + 10
01:44:27 <Cale> 20
01:45:02 <Cale> tallpaul: We could also adopt the convention of evaluating functions before their parameters:
01:45:05 <Cale> double (double 5)
01:45:14 <Cale> -> (double 5) + (double 5)
01:45:20 <Cale> -> (5 + 5) + (double 5)
01:45:29 <Cale> -> 10 + (double 5)
01:45:34 <Cale> -> 10 + (5 + 5)
01:45:36 <Cale> -> 10 + 10
01:45:38 <Cale> -> 20
01:46:04 <tallpaul> Cale: okay, but in a strict-language I always evaluate first the argument.
01:46:11 <Cale> tallpaul: right
01:46:30 <tallpaul> Cale: so calculating evaluation order, seems a task for lazy languages.
01:46:48 <Cale> Note that this second strategy wasted work: double 5 was computed twice because it was duplicated, because the parameter x occurred twice in the body of double's definition
01:46:56 <Cale> So lazy evaluation does one more thing
01:47:30 <Cale> It ensures that whenever a parameter to a function occurs more than once in the body of the function, any evaluation done to one of the copies of that parameter is shared between them.
01:47:55 <Cale> (usually by some scheme which makes them all pointers to the same thing in memory)
01:48:01 <Cale> double (double 5)
01:48:06 <Cale> -> let x = double 5 in x + x
01:48:10 <Cale> -> let x = 5 + 5 in x + x
01:48:13 <Cale> -> let x = 10 in x + x
01:48:17 <Cale> -> 10 + 10
01:48:19 <Cale> -> 20
01:48:46 <tallpaul> Cale: So, calculating evaluation order is for call-by-need, if you only want to calculate shared results once.
01:48:52 <tallpaul> Correct?
01:49:00 <Cale> None of these evaluation orders need to be precomputed.
01:49:16 <Cale> They're just strategies that you apply as you reduce an expression.
01:49:41 <harlekin> conal, ping
01:50:01 <kulin> sometimes its important, once you talk about side effects
01:50:02 <Cale> If you're writing a compiler, you sort of precompute them, insofar as the code you generate probably encodes the strategy for evaluation.
01:50:32 <tallpaul> Cale: thanks, got it now :-)
01:51:11 <Cale> harlekin: I was unaware that anything related to reactive was in working order at all.
01:51:55 <chrisdone> :-)
01:52:25 <harlekin> Cale, so you would advice against using reactive? Is Yampa a better candidate for now or is FRP in Haskell in general only experimental atm?
02:03:38 <Heffalump> adnap: does your decoder actually deal properly with nested children? It seems to ignore the numChildren value it reads.
02:03:56 <Heffalump> Which means it won't know when to stop reading children of the current node and return to reading children of the parent node.
02:17:10 * hackagebot game-probability 1.0 - Simple probability library for dice rolls and similar simple games of chance  http://hackage.haskell.org/package/game-probability-1.0 (NeilBrown)
02:20:11 * hackagebot hswip 0.3 - embedding prolog in haskell  http://hackage.haskell.org/package/hswip-0.3 (EvgenyTarasov)
02:20:58 <Heffalump> adnap: I have to go now, but I've pasted what I did here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28971#a28997
02:21:30 <Heffalump> I'm sure someone else here can help you understand it or improve it further.
02:25:40 <Gracenotes> hm. HTTP sends its digest auth response as bits on the wire, when it should actually display the hex digits themselves
02:25:46 <Gracenotes> the package I mean
02:26:28 <Gracenotes> tis borken :(
02:27:19 <Gracenotes> whichever code goes from Challenge -> Authority, which I don't think is exposed
02:27:46 <chrisdone> nice, I have etags working for all my installed libraries
02:28:06 <Saizan> where are you keeping the source?
02:28:15 <chrisdone> Saizan: ~/.cabal/packages/*
02:28:32 <Gracenotes> chrisdone: nice
02:28:33 <chrisdone> I wrote something to extract all unextracted packages
02:29:10 <chrisdone> (and generate a hoogle database)
02:30:43 <Saizan> makes sense
02:31:51 <chrisdone> e.g. http://i.imgur.com/O7nx9.png
02:32:48 <chrisdone> is there already a hoogle module for emacs? I've seen one that opens a browser but I'd rather just see a listing in a separate buffer
02:33:01 <Gracenotes> I think I'll have to email the HTTP maintainer
02:33:21 <chrisdone> Gracenotes: oh?
02:33:34 <Gracenotes> I found a bug in Google Chrome related to digest authentication, too. it's difficult to do right..
02:34:49 <Gracenotes> chrisdone: in this case, the browser is supposed to send an MD5 hash, but it sends the bytes themselves instead of the hexdigits
02:34:51 <chrisdone> hmm. I think I'll update hasktags though. had to patch it to read UTF8 and it's generally based on a messy manual parser so it could trivially be replaced with haskell-src-exts
02:34:52 * Saizan only needs hoogle --info, actually
02:35:35 <Saizan> chrisdone: there's an "improved hasktags" on hackage iirc
02:35:44 <Gracenotes> which seems to either contain an \r or throw the parser off to not expect one
02:38:19 <chrisdone> Saizan: hothasktags?
02:47:37 <peterNovice> Does anyone know how to get haddock to handle the data-constructors is GADTs? 
02:55:12 <byorgey> peterNovice: what version of haddock?
02:55:47 <peterNovice> byorgey: 2.7.2
02:57:21 <peterNovice> I was trying to find something on hackage that uses it, so I could see how.
02:57:44 <byorgey> peterNovice: what do you mean by "handle"?
02:58:12 <fasta> peterNovice, I am pretty sure there was no support for it, but maybe it has changed.
02:59:53 <peterNovice> byorgey: I get pase errors when I do it as for regular datatypes
03:00:31 <ivanm> I thought Haddock couldn't handle GADTs properly...
03:00:42 <byorgey> peterNovice: hmm, now that you mention it I think I have run into this as well
03:01:34 <peterNovice> fasta & ivanm: ok thanks
03:02:00 <ivanm> oh, whoops, missed fasta saying that
03:03:51 <peterNovice> two persons saying it makes it more plausible ;)
03:07:25 * hackagebot graph-wrapper 0.2 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.2 (MaxBolingbroke)
03:21:23 <ivanm> preflex: seen dons
03:21:23 <preflex>  dons was last seen on #haskell 9 hours, 51 minutes and 55 seconds ago, saying: BrianHV: probably ok. wxHaskell is a good lib.
03:21:52 <ivanm> @ask dons does ghc-core support the new version of pcre-light (since you don't have version bounds for ghc-core's dep on it)?
03:21:53 <lambdabot> Consider it noted.
03:27:48 <fasta> peterNovice, what makes you think we are not the same person? ;)
03:28:12 <ivanm> the fact that you were arguing with me about whether inductive graphs make sense or not?
03:28:25 * ivanm doesn't have multiple personality disorder, last we checked
03:28:26 <ivanm> :p
03:33:07 <fasta> ivanm, he doesn't know that.
03:33:31 <fasta> ivanm, I didn't say they didn't make sense, however. 
03:33:38 <ivanm> heh
03:39:39 <magthe> what's the easiest way to unescape xml string? (ideally something that is String -> String)
03:42:04 <ivanm> what kind of unescapes are you talking about?
03:42:23 <ivanm> you mean XML entities, etc.?
03:42:31 * Jafet plays ivanm the theme to Psycho
03:42:41 <ivanm> O...K...
03:42:46 * ivanm has never watched psycho
03:43:37 <Jafet> Well... I guess the analogy only makes sense if your mother used to abuse you with inductive graphs, or something
03:43:50 <bss03> magthe: I don't know a library function for it, but it should be simple enough to write.
03:43:50 <ivanm> no, not really...
03:43:55 <ivanm> there's a few
03:44:01 <ivanm> in a bunch of different libraries
03:44:05 <ivanm> depends exactly what you want though
03:44:19 * ivanm investigated this when needing HTML escaping/unescaping for graphviz
03:44:27 <ivanm> in the end I just did it myself
03:44:56 <magthe> I have a string, that is XML escaped (with stuff like &#32;) and just want it turned into standard text
03:45:05 <bss03> magthe: Handling &#$dec; and &#x$hex; should be easy.  Special cases for &lt; &gt; and &amp; will be needed.
03:45:06 <magthe> surely there must be something out there already, no?
03:45:28 <bss03> magthe: I'm not sure if XML requires you to handle &quot; or &apos;
03:45:40 <magthe> bss03: I'd rather not write it myself... as writing it would take about as long time as writing the entire script in Python :(
03:46:05 <bss03> @hoogle XML ?
03:46:06 <lambdabot> Parse error:
03:46:06 <lambdabot>   --count=20 "XML ?"
03:46:07 <lambdabot>                   ^
03:46:16 <bss03> @hoogle XML
03:46:18 <lambdabot> No results found
03:46:26 <bss03> @hoogle HTML
03:46:27 <lambdabot> Text.Html class HTML a
03:46:27 <lambdabot> Text.XHtml.Frameset class HTML a
03:46:27 <lambdabot> Text.XHtml.Strict class HTML a
03:46:52 <ivanm> magthe: look in the various XML libraries, maybe even the URI library
03:46:59 <bss03> One of those packages may have a function exported, or source you can cut-and-paste.
03:46:59 <ivanm> I think ndm's tagsoup had it as well
03:47:03 <Jafet> It's quite fun, actually. You'll need to parse DTDs to do it right.
03:47:20 <Jafet> I doubt the python implementors ever care to get such things right.
03:47:47 <ivanm> Jafet: it's just a string, he won't need to
03:47:50 <magthe> Jafet: surely unescaping a string doesn't require the DTD, does it?
03:47:51 <bss03> Technically, yes.  But, I think magthe probably just needs something simple, esp. if the type needs to be String -> String.
03:47:52 <ivanm> if its in tags, then yeah :s
03:48:01 <Jafet> Sure it does.
03:48:12 <Jafet> Then you'd better refine what you mean by "XML".
03:48:13 <bss03> Yeah, the DTD gets to define entities.
03:48:39 <bss03> The HTML4 DTD defines stuff like &alpha; and &Gamma;
03:49:29 <bss03> Even without a DTD, &lt; &gt; and &amp; have to be recognized though.
03:50:27 <Jafet> http://w3.org/TR/REC-xml/#sec-predefined-ent
03:51:32 <ivanm> How I unescaped HTML-like labels in graphviz: http://hackage.haskell.org/packages/archive/graphviz/2999.10.0.1/doc/html/src/Data-GraphViz-Attributes-HTML.html#unescapeHtml
03:51:45 <magthe> since the server only uses numeric character references that's all I need
03:51:48 <ivanm> well, that's doing parsing and unescaping at the same time...
03:52:05 <ivanm> magthe: *shrug* check out URI, tagsoup, the various xml libraries, etc.
03:53:29 <fasta> I wonder how many people use all the bells and whistles of XML, since once you have nested tags you don't really need anything else. 
03:54:57 <bss03> I really haven't used all the bells and whistles, but having to write using just LISP-style S-expressions might be more tiresome than XML. :P
03:55:31 <fasta> bss03, XML has never been designed to be written by humans. 
03:55:42 <fasta> bss03, neither were S-expressions, btw.
03:56:00 <fasta> bss03, it just so happened that S-expressions were more popular than M-expressions.
03:56:19 <bss03> "The design goals for XML are:"
03:56:32 <bss03> "6. XML documents should be human-legible and reasonably clear."
03:56:43 <bss03> "10. XML documents shall be easy to create."
03:56:46 <Zao> bss03: Good jokes.
03:56:49 <opqdonut> (with a tool)
03:56:59 <aristid> fasta: what are M-expressions?
03:56:59 <fasta> bss03, that has nothing to do with what I said. 
03:57:11 <fasta> aristid, a syntax to denote S-expressions.
03:57:21 <aristid> fasta: how does it look like?
03:57:22 <bss03> *shrug* Never had a problem writing it, myself.
03:57:25 <opqdonut> foo[a, b, c] == (foo a b c)
03:57:31 <opqdonut> I prefer sexps to xml
03:57:34 <fasta> aristid, it was years ago that I read it. 
03:57:44 <opqdonut> aristid: about like what I pasted
03:57:48 <aristid> opqdonut: the left side is M-expr, the right side S-expr?
03:57:49 <fasta> bss03, and that is again irrelevant to what you said. 
03:57:52 <opqdonut> aristid: yes
03:58:06 <opqdonut> that's the general idea, can't remember how lists and quoting worked
03:58:25 <fasta> opqdonut, that looks like Mathematica.
03:58:32 <aristid> opqdonut: and that was used as a syntax for lisp?
03:58:43 <opqdonut> well, it was supposed to be used
03:58:52 <bss03> I'm not goign to further argue the point.  But, I feel that those quotes from the XML specification indicate XML should be considered human-writable, without domain-specific tools.
03:58:53 <opqdonut> but since everybody was familiar with writing sexps it never caught on
03:58:59 <bss03> I've always found that to be the case.
03:58:59 <fasta> car[append[(A B C); (D E F)]]    (CAR (APPEND (QUOTE (A B C)) (QUOTE (D E F))))
03:59:07 <opqdonut> IIRC mathematica syntax is indeed inspired by mexps
03:59:31 <aristid> fasta: i suppose the latter looks more consistent
03:59:41 <opqdonut> once you get used to sexps, yes
04:00:07 <aristid> i do think haskell has better syntax than lisp, but haskell is not also a data format
04:00:37 <Botje> grab liskell!
04:01:52 <zygoloid> [$lisp| (...)))))))))))) |]
04:04:05 <fasta> Loq would be interesting to see too. 
04:07:46 <ketil> is there an easy way to implement 'wait' in Haskell?  I'd like to forkIO off some threads, and have the main thread wait for them to finish.  ISTR having to keep track of them all using MVars or something.
04:08:08 <ketil> IOW lots of manual book-keeping.
04:14:01 <Zao> ketil: The typical way tends to be to consume a bunch of mvars.
04:18:11 <fasta> ketil, the documentation contains an idiom (which is a hack imho).
04:20:06 <ketil> fasta, I can just do    ms <- mapM myForkIO -- returns MVars, and 'wait' is simply mapM_ takeMVar ms.  IIUC.
04:20:10 <ketil> Seems to work :-)
04:20:47 <ketil> I accidentally swapped two of my parameters, so instead of launching one thread to work on a 10K data set, I did vice versa.  Damn fast thread creation.
04:22:14 <mreh> I thought we needn't be bothered by race conditions in parallel haskell
04:22:55 <Gracenotes> MVars? for srs
04:23:02 <Gracenotes> tis.
04:23:42 <aristid> ketil: the peril of dimensionless numbers :D
04:24:35 <mornfall> Yeah, Int should have a phantom parameter!
04:26:16 <aristid> mornfall: i guess dimensional Num would look quite a bit different
04:26:50 <mornfall> I guess so. But it'd be likely to suck nevertheless.
04:27:33 <ketil> There are substantial improvements to parallelism in GHC post 6.12, aren't there?
04:27:42 <Zeiris> Why is Data.Vector not a functor?
04:28:06 <ketil> This is looking good so far, but there are some...er, interesting things happening if I spawn too many (OS) threads...
04:28:59 <msieradzki> There was a blog post where someone compared performance of parsers written in attoparsec, parsec 2, parsec 3 and maybe something else. I can't find it. Does anyone remember it?
04:29:50 <mornfall> msieradzki: You mean this? http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/
04:30:00 <msieradzki> yes, thanks
04:30:11 <mornfall> It's the first google hit for attoparsec blog, mind you. :P
04:30:18 <msieradzki> uhm
04:30:27 <msieradzki> I tried like 20 different search keywords :)
04:32:36 <Gracenotes> getting the length of a lazy bytestring is generally an adequate way to evaluate it, right? assuming it's the result of a complicate-ish computation.
04:33:07 <Saizan> Zeiris: does vector impose some constraints on the type of the elements?
04:33:22 <Zeiris> Saizan, don't think so.
04:33:25 <Gracenotes> so there wouldn't be that many cases where the function would know the length, but not the specific characters, even if those characters are just a thunk away from being evaluated
04:34:46 <siteswapper> ?quote
04:34:46 <lambdabot> arw says: ...and a basic law of haskell is, 50% of all documentation has to be monad tutorials :)
04:35:10 <Zeiris> The other 50% must be incomplete, or missing with a link to a paper in its place.
04:45:58 <aRcatan> dissertations are accepted, too
04:46:11 <aRcatan> my favourite kind of documentation!
04:51:30 <aristid> aRcatan: you prefer dissertations as documentation? hmm that's a bit unusual i think
04:51:50 <aRcatan> it was meant to be sarcastic
04:52:00 <aristid> oh
04:52:33 <ivanm> it was? oh...
04:52:44 * ivanm stops writing a thesis specifically for his libraries
04:54:31 * Phyx- writes at most a paper
05:07:51 <siteswapper> ?quote
05:07:51 <lambdabot> fnord123 says: Haskell mainly helps with my C++ template coding when I'm doing money oriented programming
05:08:30 <hpc> haha
05:09:15 <Peaker> Where can I find some references about the theory behind positive/negative type positions? Type products/sums/etc?  I am looking to build an academic Haskell course, and need some references to back me up :)
05:09:34 <Peaker> (Or if anyone has any references to good Haskell course materials..)
05:11:21 <siteswapper> Peaker: I want to learn Haskell.  Where and when is your course?
05:12:02 <Peaker> siteswapper, I am not sure there will be one yet.. If I build something to the college's satisfaction, they might accept it.  In a Tel Aviv college (Israel)
05:12:37 <siteswapper> Peaker: That's too far for me. :(
05:13:05 <Peaker> siteswapper, The Internet materials (LYAH/try-haskell-tutorial) are pretty good as a starter, aren't they?
05:13:26 <Cale> siteswapper: Also, feel free to ask any questions you might have here.
05:13:47 <Cale> @where lyah
05:13:47 <lambdabot> http://www.learnyouahaskell.com/
05:13:48 <ivanm> (whether anyone answers or not is a different story... :p )
05:13:51 <Cale> @where rwh
05:13:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:14:00 <Cale> @where yaht
05:14:00 <ivanm> @where wikibook
05:14:00 <lambdabot> http://en.wikibooks.org/wiki/Haskell
05:14:01 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
05:14:29 <Peaker> Did anyone write up about the relationship between Functor/Applicative/Monad and positive type positions?
05:14:35 <ketil> Any chance of an STM transaction being aborted and *not* automatically retried?  Without me noticing?  I'm not seeing the expected effects here, it seems that some of my transactions just aren't happening.
05:15:05 <ketil> I thought that 'atomically foo' was guaranteed to execute 'foo' at some point - isn't it?
05:15:28 <Cale> ketil: It might just retry over and over, or get stepped on by shorter transactions
05:16:08 <ivanm> Peaker: what do you mean by "type position"?
05:16:10 <Cale> ketil: If you have a very long transaction that reads from lots of stuff, and shorter transactions which write to the locations which that one reads from, then the long transaction might never be able to complete.
05:16:15 <ketil> Cale, yes I realize that - but it should complete eventually, right?  (My program terminates, and it seems all threads exit gracefully)
05:16:36 <Peaker> ivanm, In: (a -> b)   "a" is in a negative position, "b" is in a positive one
05:16:58 <ivanm> as in you're going from a (negative) to b (positive)?
05:16:59 * hackagebot uu-parsinglib 2.5.4.2 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.4.2 (DoaitseSwierstra)
05:17:02 <Peaker> ivanm, So I realized all parameterized types whose type parameter appears only in positive positions -- are Functors
05:17:13 <Cale> ketil: Maybe the main thread is terminating before some transaction in another thread?
05:17:16 <ivanm> what about "a -> b -> c" ?
05:17:24 <ivanm> what is `b'?
05:17:26 <ivanm> neutral? :p
05:17:27 <Peaker> ivanm, negative
05:17:33 <ivanm> *nod*
05:17:36 <Peaker> ivanm, negative*positive = negative
05:17:41 <ivanm> heh
05:17:46 <Cale> If the main thread of the program dies, then the rest of the threads get killed.
05:17:53 <ivanm> what about something like Map, which has two type parameters?
05:18:11 <siteswapper> :type Map
05:18:16 <Peaker> ivanm, They're both in positive positions internally, since Map corresponds to something like [(k, v)]
05:18:18 <siteswapper> ?:type Map
05:18:19 <lambdabot> Not in scope: data constructor `Map'
05:18:29 <Cale> :kind Map
05:18:34 <ivanm> *nod*
05:18:36 <hpc> :k Map
05:18:36 <Cale> :k Map
05:18:38 <lambdabot> Not in scope: type constructor or class `Map'
05:18:38 <lambdabot> Not in scope: type constructor or class `Map'
05:18:38 <ketil> Cale, I think it's unlikely.... I added a second wait without any apparent effect.
05:18:41 <Cale> ah
05:18:43 <hpc> @info Map
05:18:44 <lambdabot> Map
05:18:45 <Cale> :k Data.Map.Map
05:18:46 <ivanm> :k Map.Map
05:18:47 <lambdabot> * -> * -> *
05:18:47 <lambdabot> Couldn't find qualified module.
05:18:51 <Peaker> ivanm, afaik, only left of (->) is negative (and stuff built from that)
05:18:56 <Cale> :t map
05:18:57 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:18:57 <ivanm> *nod*
05:19:06 <Cale> (map and Map are unrelated)
05:19:17 <ketil> (wait as in threadDelay)
05:19:19 <Peaker> ivanm, But it would have helped me, I think, to read that every: Type a = ... is a functor if "a" is exclusively in positive positions
05:19:35 <ivanm> and non-restricted
05:19:59 <ivanm> that reminds me: I need a name to give to a variant of Foldable for types of kind *
05:20:01 <ivanm> any ideas?
05:20:53 <ketil> Aw, crap. I know what the bug is.  Thanks people!  Somehow it always helps to ask :-)
05:22:05 <ivanm> heh
05:30:21 <ketil> One of those bugs that gives you the right answer almost all the time, but some permutations of the input caused wrong answers...sigh.  Fixed now, at any rate.
05:30:51 <hpc> those are so hard to find; that "sometimes" makes it hard to see what is going on
05:31:56 <Heffalump> QuickCheck can (if you're lucky) be great for those
05:33:23 <siteswapper> ?help QuickCheck
05:33:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:33:35 <ketil> Heffalump, QC could definitely helped me catch this earlier, yes.  Lazy evaluation is no substitute for lazy programmers.
05:33:37 <ivanm> @help check
05:33:38 <lambdabot> check <expr>
05:33:38 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
05:33:43 <ivanm> siteswapper: ^^
05:34:00 <ivanm> ketil: I had such a bug that only arose after _hours_ of QC tests :s
05:34:08 <ivanm> (it was rather subtle)
05:34:11 <siteswapper> ivanm: :))
05:34:13 <Gracenotes> that is the most epic lambdabot plugin summary
05:34:18 <ivanm> (and required specific interaction/orderings)
05:34:28 <ivanm> @help run
05:34:28 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
05:34:34 <ivanm> Gracenotes: ^^ much better!
05:34:36 <Gracenotes> not serious enough
05:34:43 <ivanm> bah
05:36:12 <ketil> size on IntSets is cheap?
05:36:17 <Gracenotes> go nuts \o/ vs PROVE SOMETHING （・_>・）
05:36:33 <ivanm> no idea
05:36:36 <ivanm> depends if its cached or not
05:37:43 <ketil> I guess I'll have to read the docs - just wondering if #haskell had cached *that* information :-)
05:38:45 <Cale> ketil: Yes, it is cheap
05:39:04 <Cale> errr
05:39:05 <Gracenotes> every node takes 2 words. every branch takes 5 words.
05:39:05 <Cale> oops, no
05:39:20 <Cale> It's cheap on Set
05:39:29 <Cale> But not IntSet, strangely enough
05:39:45 <Gracenotes> oh you mean the size function, not space storage
05:39:58 <Gracenotes> yeah, each branch *doesn't* store the size, but Set/Map do explicitly
05:39:58 <ketil> Cale, yes - O(n).  But of course, it's easy to cache yourself.
05:40:19 <ketil> Set/Map needs this for balancing in the internal nodes, I guess.
05:40:35 <ketil> IntSet/Map are tries (or trie-like)
06:05:13 <Martty> > undefined
06:05:14 <lambdabot>   *Exception: Prelude.undefined
06:24:42 <geheimdienst> is there a haskell binding for nl_langinfo()? http://www.gnu.org/software/hello/manual/libc/The-Elegant-and-Fast-Way.html#The-Elegant-and-Fast-Way
06:25:02 <geheimdienst> ... or some other way to get locale information?
06:26:00 <danportin> In the function 'string' (from Hutton's book, link), what is the purpose of calling 'return (c:cs).' I've worked some of the function out by hand, but I'm not sure what role 'return' is playing. I know it gets successively bound to each successive output string, but that's about it. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29003
06:26:44 <Jafet> Do you understand the type of return?
06:27:51 <ddarius> Holy non-iterative function Batman
06:28:04 <danportin> In general; I understand how it's used otherwise, I'm just not understanding how the desired effect is being achieved in the function in question.
06:29:01 <Jafet> Hum, that code goes out of its way to avoid (>>). Or do. Pedagogy.
06:29:49 <ivanm> "return" would possibly have been better off called "lift"
06:29:59 <ivanm> as it lifts a non-monadic value into the monad
06:30:01 <ivanm> (if that helps)
06:30:25 <danportin> Well, that suits learning. I've been trying to avoid 'do' in order to make everything explicit.
06:30:34 <ivanm> Jafet: ugh, yeah
06:30:44 <ivanm> danportin: don't ;-)
06:30:49 <ivanm> unless you really, really want to
06:30:50 <Jafet> danportin: notice that `string` returns a parser. What does the parser produce when applied to an input?
06:32:20 <aristid> i'm installing hlint, and it first complained that haskell-src-exts would not build, and looking, i saw it complain about missing happy
06:32:33 <danportin> Well, here, a value of type [(a, String)] (...or  [(Char, String)]).
06:32:34 <aristid> so i installed happy, and voila, now hlint installs fine
06:32:46 <aristid> is that a misisng dependency on haskell-src-exts or so?
06:32:57 <aristid> @hackage haskell-src-exts
06:32:57 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
06:33:30 <Jafet> danportin: so look up the definition of return in Parser
06:33:48 <ClaudiusMaximus> aristid: afaik happy is a build tool and cabal doesn't track build-tool dependencies (because there are only facilities for registering libraries, not executables)
06:33:56 <Saizan> aristid: it's a long-standing bug in cabal-install, which won't install build-tools for you automatically
06:34:05 <aristid> ah.
06:34:30 <aristid> another reason to use parser combinators instead :D
06:36:33 <Jafet> @src Monad
06:36:33 <lambdabot> class  Monad m  where
06:36:33 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
06:36:33 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
06:36:33 <lambdabot>     return      :: a -> m a
06:36:33 <lambdabot>     fail        :: String -> m a
06:37:13 <Jafet> Bah, no default definitions
06:37:30 <EvanR-work> doesnt >> have a default
06:37:35 <Peaker> (>>) has one
06:37:47 <Peaker> @src fail
06:37:49 <lambdabot> fail s      = error s
06:37:50 <Peaker> @src (>>)
06:37:51 <lambdabot> m >> k      = m >>= \_ -> k
06:37:54 <danportin> Okay - so if I evaluate 'string', I will get a function after a few evaluations like : 'case [(v, out)] of {[] -> []; [(v, out)] -> parse ((\_ -> string cs >>= (\() -> return (c:cs)) v) out)} where (c:cs) is the input string. Yes?
06:38:38 <danportin> So (c:cs) in 'return' gets bound to 'out' in each recursive call to string.
06:38:49 <tibbe> does nesting two foldr leads to O(n^2) runtime: foldr (++) [] (replicate 10000 (foldr (++) [] ['a'..'z']))
06:39:39 <Jafet> tibbe: I don't see any n in that expression
06:39:54 <Jafet> Also, what the
06:40:05 <tibbe> JaffaCake, length of e.g. ['a'..'z']
06:40:40 <tibbe> (This is a simplified version of a real problem)
06:40:45 <JaffaCake> wrong Jaf* I guess
06:40:50 <EvanR-work> fold is n, the second fold is m, so doing the second fold for each element is n*m
06:40:56 <tibbe> JaffaCake, doh
06:40:59 <Jafet> That would have a runtime of about O(10000n), by necessity
06:41:20 <EvanR-work> ah yeah the second fold is a constant
06:41:22 <tibbe> Jafet, even if ++ is linear in its first argument?
06:41:22 <Maxdamantus> O(10000n) = O(n)
06:41:44 <EvanR-work> ideally fold (++) [] ['a'..'z'] only happens once?
06:42:10 <Jafet> I believe it would. But even if it didn't, that doesn't change the semantics
06:42:16 <EvanR-work> yes
06:42:31 <EvanR-work> it takes constant time ;)
06:42:34 <zygoloid> in a manner of speaking, the whole expression is constant time
06:42:48 <Cale> Evaluating the result of foldr (++) [] fully takes time which is proportional to the sum of the lengths of the lists being concatenated.
06:43:09 <zygoloid> when combined into a larger program, it has the same asymptotics as replacing the expression with a constant list of the same length would
06:43:10 <EvanR-work> an actual n would be nice
06:43:20 <Cale> (That is, forcing the spine of the entire resulting list, not just the first cons)
06:43:26 <tibbe> Let me paste the real program
06:43:28 <tibbe> @paste
06:43:29 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:43:42 <Jafet> danportin: I'm not sure. Anyway, the interpretation seems to be that return means a successful parse, and (>>=) means to parse further
06:43:55 <aristid> @where hpaste
06:43:55 <lambdabot> http://hpaste.org/
06:44:09 <Cale> I should really fix that at some point.
06:44:10 <aristid> that one is at least not down
06:44:34 <aristid> Cale: i guess you could remove the commands that really should be @where
06:44:34 <tibbe> http://pastebin.com/1Zj9F9xR
06:44:54 <tibbe> mappend should be used in a right associative manner in my code to be efficient
06:45:13 <Cale> tibbe: that's right
06:45:17 <danportin> Jafet: Thanks - I'll just have to stare at the code longer; eventually it will become clear :)
06:45:55 <Cale> tibbe: You're not going to get much more efficient than that.
06:46:01 <aristid> tibbe: foldr mappend mempty is just mconcat, no?
06:46:08 <Cale> yes, it is
06:46:11 <franksh> has anyone successfully set up an environment for qt+qthaskell+hopengl on windows? this seems like it will drain my entire day, as it requires a manual install of a billion mingw packages just to get gcc 4.4+ set up.. (if so, could i just get a .zip and set my PATH?)
06:46:29 <EvanR-work> development for windows is a pain no matter what
06:46:36 <osaunders> How do you write lambda on a mac keyboard?
06:46:45 <EvanR-work> l a m b d a
06:46:54 <osaunders> lol
06:47:02 <osaunders> The unicode character.
06:47:08 <geheimdienst> osaunders, google for it and copy-paste from somewhere, wikipedia or something ...
06:47:18 <Jafet> Select the following text and apple-C: λ
06:47:20 <Saizan> franksh: maybe msys comes with more things from the start?
06:47:38 <Jafet> Indeed, it comes with a working shell and terminal
06:47:45 <EvanR-work> rxvt or some such
06:47:58 <EvanR-work> infinitely surpasses the dos-prompt ;)
06:48:16 <Saizan> i meant more in terms of build tools, but i guess a shell is needed for configure scripts anyway
06:48:34 <Jafet> It comes with a set of coreutils and binutils, yes
06:48:42 <franksh> i have mingw+msys but it's the old one that came in a single .zip/installer.. to get new stuff it seems you have to manually install all the dozens of packages.
06:48:47 <zygoloid> > h e l l o :: Expr
06:48:48 <lambdabot>   h e l l o
06:49:06 <geheimdienst> > l a m b d a
06:49:07 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
06:49:07 <lambdabot>                           ...
06:49:27 <aristid> :t a
06:49:29 <lambdabot> Expr
06:49:32 <aristid> :t m
06:49:33 <lambdabot> Expr
06:49:38 <jkramer> Ahoy
06:49:39 <aristid> > l a m b d a :: Expr
06:49:40 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
06:49:40 <lambdabot>                           ...
06:49:50 <JaffaCake> franksh: you might try takeoffgw
06:49:51 <aristid> ooh
06:49:52 <geheimdienst> > h 4 :: Expr
06:49:53 <jkramer> I'm trying to install/use BlazeHtml
06:49:53 <lambdabot>   h 4
06:49:59 <geheimdienst> > l 4 :: Expr
06:50:00 <lambdabot>   Couldn't match expected type `t -> SimpleReflect.Expr'
06:50:01 <lambdabot>         against infe...
06:50:01 <EvanR-work> take off every zig
06:50:05 <jkramer> However the modules are not found, even though it's installed
06:50:23 <aristid> > a
06:50:23 <lambdabot>   a
06:50:29 <scottmcl66> Completely apart from learning the language, is there a good tutorial on using all the GHC tools, organizing projects on disk, separate compilation and linking, producing docs, installing libraries, etc. etc.
06:50:40 <jkramer> I tried unregistering and reinstalling several times, nothing worked :(
06:51:16 <Saizan> jkramer: so "import Text.Blaze" in ghci doesn't work?
06:51:27 <geheimdienst> jkramer, if you "cabal list" the package, does it show as installed? what does "ghc-pkg check" say?
06:51:40 <jkramer> Saizan: No, it doesn't even show any of them in tab completion
06:52:03 <franksh> JaffaCake, didn't know about that project, i will check it out, thanks.
06:52:28 <jkramer> list shows blaze-builder, balze-html and blaze-from-html
06:52:40 <JaffaCake> franksh: let me know how you get on. it wasn't obvious how to use the installer when I tried.
06:53:02 <Saizan> jkramer: "ghc-pkg field blaze-html id" will give you something like "id: $somestring", what happens when you run "ghci -package-id $somestring" ?
06:53:08 <jkramer> Hmm, ghc-pkg check shows a lot of broken packages, but blaze is not listed
06:53:50 <geheimdienst> jkramer, a reminder: cabal list tells you both the last available version and the last installed. if something shows in the output, that doesn't mean it's installed
06:53:53 <jkramer> Saizan: That seems to load it successfully
06:54:15 <alip> i have this function: http://paste.pocoo.org/raw/249787/ i want to return Just String in case of success but i think return (Just $ peekCString name) isn't true, how should I modify the function so it does what I want?
06:54:22 <Saizan> jkramer: and "import Text.Blaze" works?
06:54:39 <jkramer> Yup
06:55:07 <SonOfLilit> Hello
06:55:13 <SonOfLilit> I'm still writing my Spacewars! clone
06:55:14 <Jafet> alip: CString is presumably not compatible with String
06:55:18 <SonOfLilit> and I'm having a new problem
06:55:19 <Saizan> ok, then i think some of its dependencies are shadowed by other installations of the same version but with different hash
06:55:29 <SonOfLilit> I have a one-player version that is more or less functional
06:55:38 <alip> :t peekCString
06:55:39 <lambdabot> Not in scope: `peekCString'
06:55:41 <Saizan> which means it gets recursively shadowed away.
06:55:47 <jkramer> Saizan: How does that happen?
06:55:48 <Jafet> Well, IO String. Makes sense.
06:55:54 <SonOfLilit> the ship can move around, shoot, get hurt by its own shots, and there's gravity from the sun in the middle
06:56:03 <alip> SonOfLilit: peekCString :: CString  -> IO  String
06:56:06 <Saizan> jkramer: if you run "ghci -v" it should report something like that at the start
06:56:09 <SonOfLilit> now my problem is adding another ship in a non-ugly way
06:56:10 <alip> SonOfLilit: peekCSTring returns IO String
06:56:33 <Jafet> alip: maybe you want liftM
06:56:39 <jkramer> Uh, yeah
06:56:51 <SonOfLilit> I added "controls :: ShipControls" to the Ship constructor of the GameObject data type
06:57:08 <Cale> alip: That foreign import looks dangerous -- it would be better to have it produce an IO action, probably
06:57:23 <SonOfLilit> ShipControls = ShipControls {shootKey, cwKey, ccwKey, thrustKey :: GLUT.Key}
06:57:30 <alip> Cale: but that C function is a pure function
06:57:30 <Saizan> jkramer: well, it can happen that you've two versions of say, foo-0.1 installed, but you can link in only one at a time, so at the start ghci will just pick one and all the packages linked against the other get ignored too
06:57:35 <jkramer> http://pastie.org/1090421
06:57:38 <SonOfLilit> so the "what are the input keys" problem is solved
06:57:39 <Cale> alip: Well, I suppose that's okay in that case.
06:58:03 <Cale> alip: You're looking for  fmap Just (peekCString name)
06:58:07 <Saizan> jkramer: but if you explicitly ask for one or one of the packages built against it, ghc will use that.
06:58:16 <SonOfLilit> but still, all my functions that are GameState -> GameState and act on the single ship and probably other things are hard to port
06:58:17 <jkramer> But isn't "cabal upgrade" meant to remove the old version?
06:58:41 <Saizan> jkramer: mh, no, that shouldn't be it.
06:58:48 <Cale> alip: Or:  do v <- peekCString name; return (Just v)
06:58:51 <SonOfLilit> especially HandleShootKey that cares about the difference between shots by player 1 and shots by player 2
06:59:01 <SonOfLilit> mmm... am I more or less clear?
06:59:03 <alip> Cale: thanks, ta :)
06:59:07 <Saizan> jkramer: i'm not talking about older versions, and no "cabal upgrade" doesn't remove them, also i wouldn't use cabal upgrade.
06:59:33 <jkramer> Hmm
06:59:39 <jkramer> So, how do I fix it? :)
06:59:45 <jkramer> And how do I prevent it in future?
07:00:27 <jkramer> I think I'll just kill my ~/.cabal directory and start over
07:01:10 <danportin> Jafar: A belated thanks: something you said clicked, in a slightly tangential way, and the entire question just dissapated. :)
07:01:28 <EvanR-work> brain unexploded
07:01:29 <SonOfLilit> was my long chain of messages received? seems like I had some network problems...
07:01:54 <Saizan> jkramer: you should rather rm ~/.ghc if you want to star over. but can you paste ghc-pkg list before that?
07:02:28 <Saizan> i'm talking about messages like these, anyhow http://pastie.org/1090432
07:02:41 <fasta> It would be nice if it would by construction be impossible to ever end up in an invalid state. 
07:02:55 <Saizan> this is not an invalid state, actually.
07:02:55 <BrianHV> is there a way to tell cabal to look for C headers in a path before it searches its own headers?
07:03:10 <Saizan> it's just a state that needs more work to deal with :)
07:03:41 <jkramer> Saizan: http://paste.pocoo.org/show/249790/
07:03:45 <Saizan> you've to ask for the library before ghc makes an arbitrary choice for you
07:04:04 <Saizan> it should have a nicer UI though
07:05:34 <aristid> is this an idiom? data X = A TA | B TB | ... and data TA = TA N M and data TB = TB P Q ...
07:05:52 <aristid> as opposed to data X = A N M | B P Q
07:05:59 <SonOfLilit> ping?
07:06:05 <aristid> SonOfLilit: PONG!
07:06:07 <SonOfLilit> I seem to be having network problems...
07:06:08 <fasta> SonOfLilit, ping
07:06:21 <aristid> fasta: wrong answer :P
07:06:27 <fasta> aristid, it was a typo.
07:06:30 <copumpkin> aristid: I'd call it factoring :P
07:06:42 <aristid> copumpkin: factoring? what is that?
07:06:47 <fasta> aristid, I was kind of hoping nobody would complain.
07:07:21 <aristid> fasta: well :)
07:07:24 <copumpkin> aristid: not even factoring, really... just substitution
07:07:27 <Saizan> jkramer: anyhow, if you're not seeing any messages like the ones i pasted the problem should be something else
07:07:31 <copumpkin> aristid: normally you'd do that if you have repeated uses of N M
07:07:54 <jkramer> Saizan: In ghc-pkg list?
07:07:59 <copumpkin> aristid: x = (n * m) + (p * q) ==> x = t + r, t = n *m, r  = p * q
07:08:28 <Saizan> jkramer: no, from ghci -v
07:08:40 <jkramer> Saizan: Renamed .ghc, installed blaze-html once more and now I can load it in ghci
07:08:56 <jkramer> Saizan: There was a lot of things broken, I bet I got some of those messages
07:09:07 <aristid> copumpkin: my actual code is this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29004#a29004
07:09:12 <jkramer> 1sec
07:09:13 <aristid> copumpkin: i'm not sure which is better
07:09:42 <copumpkin> if you use the separated combinations more often, separate them
07:09:46 <copumpkin> otherwise, leave them together :P
07:10:04 <jkramer> Saizan: http://paste.pocoo.org/show/249791/
07:10:09 <Saizan> jkramer: i see now, you've two containers-0.3.0.0, ghc was picking the "wrong" one :)
07:10:35 <jkramer> Oh
07:10:51 <jkramer> Would unregistering one of them fix the problem?
07:11:02 <aristid> copumpkin: hmm maybe i can get greater typesafety from the first
07:11:13 <fasta> aristid, putting more fields in a record makes your programs smaller. 
07:11:26 <copumpkin> aristid: not sure how that would work
07:11:37 <aristid> fasta: i'm not really concerned about speed at this point
07:11:49 <fasta> aristid, this is not about speed. 
07:11:56 <fasta> aristid, in speed it is probably slower.
07:12:05 <EvanR-work> less code means more speed right xD
07:12:15 <fasta> aristid, but it is about making less of a mess of a program.
07:12:37 <aristid> i guess i should look how i actually need the data
07:12:42 <aristid> and then reconsider
07:13:51 <fasta> aristid, that's the spirit
07:13:56 <kmc> flip a coin
07:14:18 <Saizan> jkramer: it's quite probable that you'll end up in a similar state, considering the other things you've installed
07:14:37 <aristid> kmc: that is strictly less efficient than leaving it as is
07:16:30 <jkramer> Saizan: Ok, will stick with my new clean .ghc folder then :)
07:16:34 <jkramer> Thanks for helping
07:17:27 <pmurias> what would be a good way to feed an AST from Perl to Haskell (so that I can optimize it using hoopl)?
07:17:48 <Saizan> jkramer: btw, the latest ghc has nicer defaults for this situation
07:18:03 <EvanR-work> json ? xD
07:18:53 <fasta> pmurias, what is this 'hoopl' you speak of?
07:19:06 <kmc> easily googled
07:19:20 <fasta> kmc, not with my Google with one keyword.
07:19:37 <pmurias> http://lambda-the-ultimate.org/node/3557
07:19:57 <kmc> really? i see top 7 links relevant with just the name
07:20:02 <kmc> damn you google and your user-contextual search
07:20:10 <fasta> kmc, in fact hoopl perl doesn't even work.
07:20:17 <kmc> oh, it's not a perl library
07:20:27 <pmurias> it's a haskell library
07:20:30 <fasta> er hoopl ast
07:20:46 <fasta> hoopl haskell works, though.
07:21:02 * fasta sells Google stocks.
07:21:03 <pmurias> which allows you to easily write composable data flow optimaisations
07:21:29 <kmc> pmurias, does it need to happen quickly?
07:22:02 <kmc> pmurias, if not, you can just derive Read on the Haskell side, and make the Perl code spit out Haskell literal syntax
07:22:16 <fasta> Ah, cool, another undocumented library.
07:22:19 <fasta> Just what we need.
07:22:35 <EvanR-work> documentation is for humans ;)
07:22:37 <kmc> which is not hard, it's close to s-expressions if you ignore things like infix constructors
07:22:39 <kmc> fasta, hoopl is?
07:22:58 <pmurias> fasta: hoopl is documented in the paper
07:23:09 <kmc> there is also haddock
07:23:12 <kmc> not great, but it is there
07:23:26 <kmc> the paper is pretty good
07:23:46 <kmc> one concern is that real codebases tend to diverge from the paper over time
07:24:07 <fasta> pmurias, I think a paper is nice, but you also need real documentation. 
07:24:43 <kmc> in which sense is the paper not "real documentation"?
07:25:00 <fasta> kmc, I mean documentation of every exported function in the API.
07:25:12 <fasta> kmc, that paper is never going to contain all of that.
07:25:45 <kmc> http://hackage.haskell.org/packages/archive/hoopl/3.8.6.0/doc/html/Compiler-Hoopl.html
07:25:56 <kmc> it seems that most of the functions have at least a one-sentence description
07:26:04 <FunctorSalad> what is hoopl? j/k ;)
07:26:33 <EvanR-work> haskell object oriented programming language
07:26:43 <Zao> I would have guessed at something Web2.0
07:27:39 <fasta> kmc, I also don't believe that they need to export so many functions. 
07:27:58 <fasta> kmc, I guess you could call it HXTitis.
07:28:05 <kmc> heh
07:30:23 <geheimdienst> ops: there's a guy "seydar" in -blah who says he can't get into #haskell because of some 5-day old blanket ban. could you look at that? he's clearly not a bot
07:30:28 <geheimdienst> thanks guys
07:30:57 <geheimdienst> @where ops
07:30:58 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
07:31:41 <Igloo> I'm not going to remove the web IRC ban
07:32:41 --- mode: ChanServ set +o roconnor
07:34:51 --- mode: roconnor set -b *!*@gateway/web/freenode/*
07:35:17 <geheimdienst> hm ... doesn't irc have some "voice" facility? it's only about allowing this one guy, you needn't lift the entire ban
07:35:26 <pmurias> kmc: and what would be a quicker way the just using Read?
07:35:39 <kmc> strings are pretty slow
07:35:44 <EvanR-work> geheimdienst: i think there are exceptions
07:35:44 <kmc> some kind of bytestring-based parser
07:35:47 <kmc> or binary serialization
07:35:57 <pmurias> kmc: Read can't handle cyclic data?
07:36:08 <EvanR-work> geheimdienst: i vaguely remember doing that when we had web irc bans in ##physics
07:36:08 <kmc> pmurias, the derived instances won't
07:36:11 --- mode: roconnor set -o roconnor
07:38:03 <seydar> YES
07:38:04 <seydar> thank you
07:38:05 <seydar> http://github.com/bjpop/berp/
07:38:12 <seydar> what are people's thoughts on berp
07:38:18 <seydar> as a haskell system
07:38:19 <kmc> i'm in favor
07:38:31 <seydar> the guy appears to have a shittonne of compiler writing experience
07:38:49 <copumpkin> is that a unit of measurement for compiler writing experience?
07:39:00 <seydar> une shittonne metrique
07:39:09 <Zao> Closely related to the metric fsckton.
07:39:12 <seydar> but how does his code look to an experienced haskell eye?
07:40:33 <kmc> haskell eye for the straight guy
07:40:36 <zygoloid> i'm somewhat disappointed
07:40:45 <copumpkin> son, I am disappoint
07:40:46 <zygoloid> on the basis that i was writing a python compiler in haskell
07:40:48 <p_l> Can anyone suggest to me a statistical package for Haskell (but something closer to SPSS than Excel statistic functions)
07:40:53 <Cale> seydar: For the most part it's okay. There are some nested ($)'s where there could be more uses of (.)
07:40:54 <zygoloid> and it now seems pretty pointless :(
07:41:06 <copumpkin> zygoloid: run it through @unpl
07:41:10 <fasta> seydar, solid, IMHO, without looking whether it does something useful. 
07:41:27 <seydar> zygoloid: write a haskell compiler in python, that produces python code
07:41:44 <seydar> zygoloid: and then you can hook the two compilers up to compile each others' output until you reach an identity
07:41:50 <seydar> oh, and publish your code please
07:42:02 <seydar> (to YOUR python -> haskell compiler)
07:42:09 <carter> seydar: why would there necessarily be a fixed point to such an iteration ?
07:42:17 <fasta> seydar, I highly doubt a Python compiler written in Haskell by one person will compete with one written by a lot of people. 
07:42:41 <seydar> carter: there wouldn't be, but it'd be cool if there were
07:42:57 <zygoloid> seydar: mine was python bytecode -> LLVM
07:42:59 <seydar> fasta: yargh, but it's a good thing to have around. Now the RPython people don't have to cry themselves to sleep nightly
07:43:24 <zygoloid> (using the python RTS rather than the GHC RTS)
07:43:31 <fasta> seydar, R is another language that is a complete mistake. 
07:43:58 <fasta> seydar, yes, it has some libraries, but otherwise you cannot really call it an efficient language. 
07:44:13 <FunctorSalad> what's the first such language?
07:44:27 <fasta> FunctorSalad, you mean one that is efficient?
07:44:38 * hackagebot hstzaar 0.1 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.1 (PedroVasconcelos)
07:44:45 <FunctorSalad> no, one that's a complete mistake =)
07:45:19 <tommd> Any windows users here?  Could someone run "darcs get http://community.haskell.org/~tommd/crypto/ ; cd crypto ; cabal install" ?
07:45:25 <fasta> FunctorSalad, ah, I still don't see the point of Python for example. 
07:45:33 <FunctorSalad> :)
07:45:34 <tommd> It will probably crash and burn
07:45:47 <fasta> FunctorSalad, but I wouldn't say it is a "complete mistake" like e.g. PHP is. 
07:46:49 <kmc> PHP is a massive success *and* a complete mistake
07:47:41 <Maxdamantus> Most languages are.
07:48:18 <FunctorSalad> depends on what exactly 'complete' is
07:48:27 <FunctorSalad> it'd be hard to get every single design decision wrong ;)
07:48:28 <geheimdienst> i guess hindsight is 20/20 ...
07:48:40 * hackagebot language-asn1 0.5 - Parsing of ASN1 definitions  http://hackage.haskell.org/package/language-asn1-0.5 (DmitryAstapov)
07:48:51 <FunctorSalad> I mean, python has lexical scope at least, or not ;)
07:49:06 <fasta> FunctorSalad, not really.
07:49:19 <fasta> FunctorSalad, or rather in a silly keyword manner in Python3.
07:49:45 <zygoloid> nonlocal, wtf
07:49:47 <FunctorSalad> really not? :o (I only know python very cursorly)
07:49:52 <fasta> zygoloid, yep
07:50:10 <FunctorSalad> er is 'nonlocal' to turn lex scope on or off?
07:50:16 <fasta> Really, nothing of interest was created after Scheme w.r.t. dynamic languages.
07:50:24 <zygoloid> FunctorSalad: no. nonlocal means assignment doesn't create a new local variable
07:50:39 <zygoloid> instead it assigns to the lexically-scoped variable with that name
07:50:54 <zygoloid> as opposed to python2's global, which means the name refers to a global
07:51:07 <azaq23> nonlocal declares a variable in a function which is changed in an outer, but not the global, scope
07:51:17 <FunctorSalad> I meant lexical scope as an example of a non-wrong decision just to sillily argue it's not a mistake in every respect
07:51:19 <azaq23> before 2.6 those were not changeable
07:51:25 <zygoloid> i thought nonlocal could refer to the global scope too?
07:51:39 <azaq23> you had to regard to hacks like using a singleton list and changing that
07:52:00 <zygoloid> FunctorSalad: lexical scope plus no variable declarations leads to a poor design though
07:52:03 <kmc> if only someone had already developed a dynamic language with a simple, powerful idea of lexical scope
07:52:04 <azaq23> zygoloid: not sure, I think not - global should be used for that, but I don't know whether python will scream if it's declared nonlocal
07:52:14 <kmc> then the python designer(s) could have looked at that for inspiration
07:53:00 <FunctorSalad> zygoloid: hmm... on haskell the initial and only assignment counts as declaration? ;)
07:53:04 <fasta> Also "Python" in reality is 99% C. 
07:53:04 <seydar> what's something I can write to get practice with monads?
07:53:09 <zygoloid> azaq23: right you are, nonlocal can't refer to a global. that kinda sucks too :(
07:53:20 <FunctorSalad> monad tutorial *ducks*
07:53:20 <kmc> seydar, what do you know already?
07:53:25 <kmc> hahaha FunctorSalad
07:53:38 <kmc> seydar, you can implement Maybe, Either, and [] monads yourself; that's a useful exercise
07:53:48 <seydar> kmc: i'm not really sure what I know. I guess nothing
07:53:48 <seydar> ok
07:53:50 <seydar> that sounds good
07:53:51 <bremner> or a final exam question
07:54:03 * bremner whistles innocently
07:54:13 <seydar> bremner: the final is only the beginning
07:54:26 <FunctorSalad> s/on haskell/in haskell/
07:56:07 <zygoloid> FunctorSalad: hmm, yeah, i guess the third leg of the tripod of fail is mutation being indistinguishable from declataion
07:56:24 <FunctorSalad> haha
07:57:10 <Maxdamantus> O_o
07:57:16 <Maxdamantus> Python's like.. 5% C.
07:58:52 <roconnor> @dict declataion
07:58:53 <lambdabot> Supported dictionary-lookup commands:
07:58:53 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
07:58:53 <lambdabot> Use "dict-help [cmd...]" for more.
07:59:04 <roconnor> @wn declataion
07:59:05 <lambdabot> No match for "declataion".
08:00:47 <Saizan> roconnor: "declaration"
08:01:51 <Phyx-> @wn
08:02:01 <Phyx-> @wn hi
08:02:02 <lambdabot> *** "hi" wn "WordNet (r) 2.0"
08:02:02 <lambdabot> hi
08:02:02 <lambdabot>      n 1: an expression of greeting; "every morning they exchanged
08:02:02 <lambdabot>           polite hellos" [syn: {hello}, {hullo}, {howdy}, {how-do-you-do}]
08:02:02 <lambdabot>      2: a state in the United States in the central Pacific on the
08:02:04 <lambdabot>         Hawaiian Islands [syn: {Hawaii}, {Aloha State}]
08:02:44 <Phyx-> ohh upgrades
08:02:48 <Maxdamantus> @wn awake
08:02:51 <lambdabot> *** "awake" wn "WordNet (r) 2.0"
08:02:55 <lambdabot> awake
08:02:59 <lambdabot>      adj 1: not in a state of sleep; completely conscious; "lay awake
08:03:03 <lambdabot>             thinking about his new job"; "still not fully awake"
08:03:07 <lambdabot> Plugin `dict' failed with: thread killed
08:03:13 <Phyx-> lol
08:03:15 <Maxdamantus> O_o
08:03:21 <Phyx-> @wn senpuku
08:03:25 <lambdabot> No match for "senpuku".
08:03:39 <Maxdamantus> @wn diahorreah
08:03:40 <lambdabot> No match for "diahorreah".
08:05:05 <siteswapper> ?help wn
08:05:05 <lambdabot> I perform dictionary lookups via the following 13 commands:
08:05:05 <lambdabot> all-dicts ... Query all databases on dict.org
08:05:05 <lambdabot> devils ...... The Devil's Dictionary
08:05:05 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
08:05:05 <lambdabot> elements .... Elements database
08:05:07 <lambdabot> [9 @more lines]
08:05:14 <siteswapper> @more
08:05:14 <lambdabot> foldoc ...... The Free On-line Dictionary of Computing
08:05:15 <lambdabot> gazetteer ... U.S. Gazetteer (1990)
08:05:15 <lambdabot> hitchcock ... Hitchcock's Bible Names Dictionary (late 1800's)
08:05:15 <lambdabot> jargon ...... Jargon File
08:05:17 <lambdabot> lojban ...... Search lojban.org
08:05:19 <lambdabot> [4 @more lines]
08:05:22 <siteswapper> @more
08:05:22 <lambdabot> vera ........ V.E.R.A.: Virtual Entity of Relevant Acronyms
08:05:23 <lambdabot> web1913 ..... Webster's Revised Unabridged Dictionary (1913)
08:05:25 <lambdabot> wn .......... WordNet (r) 1.7
08:05:27 <lambdabot> world02 ..... CIA World Factbook 2002
08:06:04 <Zao> Fun fact of the day. Lambdabot listens to private messages.
08:06:17 <sioraiocht> that bitch!
08:06:24 <Zao> Probably -blah too, if you float that way.
08:07:00 <roconnor> @elements argon
08:07:01 <lambdabot> *** "argon" elements "Elements database 20001107"
08:07:01 <lambdabot> argon
08:07:01 <lambdabot> Symbol: Ar
08:07:01 <lambdabot> Atomic number: 18
08:07:01 <lambdabot> Atomic weight: 39.948
08:07:03 <lambdabot> [4 @more lines]
08:09:27 <geheimdienst> so i figure there's no way to have a {- comment -} inside an hsc #{enum ...}, right?
08:09:53 <geheimdienst> (the comment ends up in the c code, which of course gcc then chokes on)
08:10:11 <roconnor> geheimdienst: what about /* */ then?
08:10:25 <geheimdienst> uh ... good point :)
08:10:37 <geheimdienst> will haddock scan those though?
08:10:43 <geheimdienst> ah well i'll just try it
08:10:47 <roconnor> surely not
08:11:18 <geheimdienst> anyway, is haddock what i should use to document my .hsc file?
08:12:00 <roconnor> to be honest, I don't even know what hsc is.
08:12:18 <kmc> hsc files are preprocessed by hsc2hs
08:12:38 <kmc> they contain Haskell code mixed with references to C constants, struct offsets, etc.
08:13:00 <Saizan> what does #{enum ..} do?
08:13:08 <kmc> RWH's FFI chapter covers hsc2hs
08:13:14 <geheimdienst> roconnor, it's a helper tool when you make interfaces to c code
08:13:41 <geheimdienst> saizan, check http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/hsc2hs.html or chapter 17 in RWH ;-)
08:19:24 <Saizan> anyhow, if it's making a declaration you should try with "-- | haddock comment" above it, if it generates an expression i don't see how haddock is involved (all of this on the haskell side)
08:21:13 <SonOfLilit> Would you remind me how to ask lambdabot to turn some code into point-free?
08:21:23 <geheimdienst> @pl
08:21:23 <lambdabot> (line 1, column 1):
08:21:24 <lambdabot> unexpected end of input
08:21:24 <burp> @pl \x -> x
08:21:24 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:21:25 <lambdabot> id
08:21:31 <seydar> should i bite my nail?
08:21:33 <seydar> it's too long
08:21:37 <seydar> and i don't have an emory board
08:21:44 <burp> pl for pointless ;D
08:22:10 <SonOfLilit> @pl \a f g-> (f a) && (g a)
08:22:10 <lambdabot> ap (flip . (((.) . (&&)) .) . flip id) (flip id)
08:22:30 <SonOfLilit> oh my
08:22:32 <geheimdienst> saizan, i've tried various things now, i guess the problem is hsc2hs throws out all the /* ... */ inside an #{enum}
08:23:03 <Saizan> SonOfLilit: liftM2 (&&) is quite near that, using the (r ->) monad
08:23:24 <aristid> i prefer liftA2 (&&)
08:23:37 <aristid> or (&&) <$> f <*> g
08:23:38 <SonOfLilit> @pl \f g a-> (f a) && (g a)
08:23:38 <lambdabot> liftM2 (&&)
08:23:43 <geheimdienst> the comments just don't end up in the .hs file
08:23:52 <aristid> SonOfLilit: woah, you just improved @pl?
08:23:53 <SonOfLilit> ah
08:23:59 <SonOfLilit> much better now
08:24:07 <SonOfLilit> no, I changed the order of a, f, g
08:24:13 <aristid> oO
08:24:21 <Maxdamantus> What do the <>s mean?
08:24:21 <Saizan> geheimdienst: ah, i see, you wanted to give comments for each one
08:24:31 <aristid> Maxdamantus: which <>s?
08:24:37 <Maxdamantus> <$>
08:24:43 <SonOfLilit> Saizan: would you explain why liftM2 does this?
08:24:51 <geheimdienst> yes exactly saizan. i meant to have comments really inside the enum
08:24:52 <roconnor> Maxdamantus: <$> is one token
08:24:56 <aristid> Maxdamantus: (<$>) = fmap = liftM
08:25:05 <Maxdamantus> Oh, so it's not something wrapping around the $ operator?
08:25:11 <aristid> no
08:25:42 <Saizan> though the name itself is meant to refer to $
08:25:55 <Saizan> ?type liftM2
08:25:57 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:25:59 <aristid> :t runIdentity
08:26:00 <lambdabot> forall a. Identity a -> a
08:26:21 <aristid> :t \a b -> runIdentity (a <$> return b)
08:26:22 <Maxdamantus> :t <$>
08:26:22 <lambdabot> forall a a1. (a -> a1) -> a -> a1
08:26:23 <lambdabot> parse error on input `<$>'
08:26:28 <aristid> :t ($)
08:26:29 <lambdabot> forall a b. (a -> b) -> a -> b
08:26:38 <Saizan> bah, ugly type.
08:26:46 <aristid> Maxdamantus: ($) is like (<$>) on Identity.
08:26:59 <aristid> hmm i wonder if that is actually a helpful comment :D
08:27:50 <SonOfLilit> what's Identity?
08:27:52 <Saizan> SonOfLilit: liftM2 :: Monad m => (a -> b -> c) -> m a -> m b -> m c, if you take m = (r ->) then you get "(a -> b -> c) -> (r -> a) -> (r -> b) -> (r -> c)" and there's only one non-bottom definition for that :)
08:27:56 <SonOfLilit> is that like a "default monad"?
08:28:05 <aristid> SonOfLilit: Identity is a monad around pure values
08:28:24 <SonOfLilit> how/where is it defined?
08:28:24 <aristid> newtype Identity a = Identity a, i think
08:28:29 <SonOfLilit> :info Identity
08:28:31 <aristid> in Control.Monad.Identity
08:31:08 <kmc> SonOfLilit, http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Identity.html
08:33:37 <SonOfLilit> I'll ask a more general question
08:34:03 <SonOfLilit> what happens when I use monad functions in what seems at first sight a non-monad context?
08:34:44 <Zao> SonOfLilit: As in juggling around (m a) thingies in a pure function?
08:35:37 <kmc> i think this distinction of "pure" vs "monadic" functions is misleading
08:35:37 <Zao> > let fs = [getLine, return "lol"] in length fs
08:35:38 <lambdabot>   2
08:35:45 <roconnor> SonOfLilit: it is not uncommong to use a monad for only one line
08:35:46 <kmc> there are only functions, some of them return monadic values, which are ordinary algebraic data values
08:36:02 <roconnor> SonOfLilit: runFaviouriteMonad parameters do { .... }
08:36:03 <kmc> (for the most part)
08:36:15 <Zao> ( I expect kmc will say that getLine is not a function, while return is :D )
08:36:22 <kmc> yup
08:36:35 <Zao> ( a function is unary, they say )
08:36:50 <kmc> > show $ sequence [Just 3, Just 5] -- using the Maybe monad in one line only
08:36:51 <lambdabot>   "Just [3,5]"
08:36:59 <roconnor> monadic function are pure function of type a -> m b
08:37:22 <roconnor> But when you put on your Kleisli googles they appear to be an impure function of type a -> b
08:37:28 <Zao> Why is w commonly used for comonads? Is it because it looks like a flipped m?
08:37:32 <kmc> yes
08:37:35 <roconnor> Zao: I believe so
08:37:39 <aristid> :t Kleisli
08:37:39 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
08:37:47 <zygoloid> monadic values remind me of Perfectly Normal Beasts
08:38:49 <SonOfLilit> > f :: Int -> Int; f = return 8
08:38:51 <lambdabot>   <no location info>: parse error on input `;'
08:38:55 <kmc> SonOfLilit, so there's no special rule about how "monadic functions" work
08:39:11 <SonOfLilit> > f = (return 8):: Int -> Int
08:39:12 <lambdabot>   <no location info>: parse error on input `='
08:39:31 <SonOfLilit> > let f = (return 8):: Int -> Int
08:39:32 <lambdabot>   not an expression: `let f = (return 8):: Int -> Int'
08:39:33 <kmc> > let f :: Int -> Int; f = return 8 in f
08:39:34 <lambdabot>   Overlapping instances for GHC.Show.Show
08:39:34 <lambdabot>                              (GHC.T...
08:39:36 <kmc> > let f :: Int -> Int; f = return 8 in f 3
08:39:37 <lambdabot>   8
08:39:44 <zygoloid> Monadic values are Perfectly Normal Values. Don't panic: "The reason for its uncomfortably reassuring name is not so much what it is but where it comes from. And, equally, where it goes to - The creature itself is indeed normal, but it is it's migratory habits that strike people as being odd."
08:40:11 <SonOfLilit> kmc: thank you
08:40:24 <roconnor> > @type let f = Kleisli (return 8) :: Kleisli Maybe Int Int in f
08:40:24 <lambdabot>   <no location info>: parse error on input `@'
08:40:26 <roconnor> @type let f = Kleisli (return 8) :: Kleisli Maybe Int Int in f
08:40:27 <SonOfLilit> so, what monad's was the "return"
08:40:27 <lambdabot>     No instance for (Num (Maybe Int))
08:40:28 <lambdabot>       arising from the literal `8' at <interactive>:1:24
08:40:28 <lambdabot>     Possible fix: add an instance declaration for (Num (Maybe Int))
08:40:41 <kmc> SonOfLilit, the ((->) r) monad
08:40:44 <roconnor> @type let f = Kleisli (\_ -> return 8) :: Kleisli Maybe Int Int in f
08:40:45 <lambdabot> Kleisli Maybe Int Int
08:40:51 <kmc> @src (->) return
08:40:52 <lambdabot> return = const
08:40:52 <SonOfLilit> so that is the "default" monad?
08:40:56 <SonOfLilit> or why is that?
08:41:04 <kmc> SonOfLilit, there is no "default" monad
08:41:13 <kmc> f :: Int -> Int
08:41:20 <SonOfLilit> how does GHC decide to use the (->) monad?
08:41:22 <kmc> return 8 :: (Num a) => m a
08:41:26 <kmc> err
08:41:29 <kmc> return 8 :: (Num a, Monad m) => m a
08:41:34 <kmc> so now it has to unify these two types
08:41:51 <kmc> to unify «Int -> Int» with «m a» we have to set m = «(->) Int»
08:41:59 <kmc> this is easier to see if you write it prefix
08:42:01 <kmc> type Fun a b = a -> b
08:42:15 <kmc> to unify «Fun Int Int» with «m a» we have to set m = «Fun Int»
08:42:30 <SonOfLilit> and a = Int
08:42:31 <SonOfLilit> ok
08:42:33 <kmc> yeah
08:42:47 <SonOfLilit> where is the (->) monad defined? I already know that return = const. what is bind?
08:42:51 <SonOfLilit> and fail?
08:42:53 <kmc> @src (->) (>>=)
08:42:53 <lambdabot> f >>= k = \ r -> k (f r) r
08:43:02 <kmc> it's in Control.Monad.Instances
08:43:10 <SonOfLilit> I'll look there
08:43:22 <kmc> it uses the default "fail"
08:43:25 <ezyang> SonOfLilit: Follow the types! 
08:44:07 <kmc> it is not imported by default, because it can turn some typos into type-checking but incorrect code
08:44:14 <kmc> in particular, (>>) is almost never useful for this monad
08:44:47 <kmc> :t (putStr >> show) 3
08:44:48 <lambdabot>     No instance for (Num String)
08:44:48 <lambdabot>       arising from the literal `3' at <interactive>:1:17
08:44:48 <lambdabot>     Possible fix: add an instance declaration for (Num String)
08:44:53 <kmc> :t (putStr >> show) "foo"
08:44:54 <lambdabot> String
08:44:59 <kmc> :t (liftM2 (>>) putStr show) "foo"
08:45:01 <lambdabot>     Couldn't match expected type `IO b' against inferred type `String'
08:45:01 <lambdabot>     In the third argument of `liftM2', namely `show'
08:45:01 <lambdabot>     In the expression: (liftM2 (>>) putStr show) "foo"
08:45:03 <kmc> grr
08:45:05 <kmc> :t (putStr >> print) "foo"
08:45:06 <lambdabot> IO ()
08:45:11 <kmc> :t (liftM2 (>>) putStr print) "foo"
08:45:12 <lambdabot> IO ()
08:45:20 <kmc> ^^^ the point i was trying to make
08:47:31 <SonOfLilit> kmc: I have no idea what the code you wrote does
08:48:00 <geheimdienst> so, how would i get a look at the .c file that hsc2hs generates? i'm running it through cabal. i tried "cabal build --hsc2hs-opt=--no-compile", but that didn't work
08:48:03 <SonOfLilit> and it seems like the (r ->) monad instance /was/ imported in my code, because the trick you showed with liftM2 worked
08:48:09 <timcowlishaw> hey all - quick question if you don't mind - is it posible to override an instnace defined on a newtype, something like this? http://gist.github.com/523093 - the problem being that there is already a Show instance defined for Show a => [a]
08:48:44 <kmc> timcowlishaw, those aren't newtypes
08:48:50 <kmc> if you use newtype you can define the instance yourself
08:48:50 <zygoloid> timcowlishaw: for a new type, yes. but those aren't newtypes :)
08:49:04 <timcowlishaw> sorry, i mean for type synonyms :-)
08:49:08 <kmc> then no
08:49:10 <roconnor> timcowlishaw: you need to newtype Path, and then write your own show instance that includes a definition for showList
08:49:15 <zygoloid> timcowlishaw: Show is an interesting one. if you want to override Show for [a], you can override showList for a
08:49:19 <kmc> because they are just synonyms, basically macros that expand at the type level
08:49:19 <timcowlishaw> aha
08:49:30 <timcowlishaw> oh that's useful zygoloid
08:49:39 <roconnor> timcowlishaw: I mean you need to newtype PathElement
08:49:41 <roconnor> sorry
08:49:49 <timcowlishaw> aah, got that roconnor
08:49:51 <timcowlishaw> yep
08:49:54 <kmc> seems definitely worthwhile to newtype PathElement anyway
08:50:00 <kmc> because you don't get much safety when your type is just [String]
08:50:06 <kmc> there are lots of things you could accidentally mix that up with
08:50:27 <timcowlishaw> so for the sake of curiosity. how would i go about defining a type that is a list of another sort of types, using newtype or data?
08:50:41 <zygoloid> timcowlishaw: also, you might want to consider not using Show. it's not a general purpose printing mechanism.
08:51:04 <kmc> newtype PathElement = Elem String
08:51:09 <zygoloid> newtype Path = Path [PathComponent]
08:51:09 <kmc> newtype Path = Path [PathElement]
08:51:17 <timcowlishaw> aah really, zygoloid?  that's definitely useful - i was using it as a general purpose cast-to-string method
08:51:17 <danportin> Can't you just flag XTypeSynonymInstances to instance type synonyms?
08:51:34 <copumpkin> danportin: it can't do magic
08:51:36 <timcowlishaw> aha thanks zygoloid / kmc
08:51:37 <zygoloid> danportin: that doesn't do what you think. it just expands the synonyms before parsing the instance
08:51:47 <kmc> danderson, that enables the type synonym expansion, yes, but you still can't write duplicate instances
08:51:53 <zygoloid> danportin: so an instance Show Path is still really an instance Show [[Char]]
08:51:57 <danportin> That's good to know :)
08:52:00 <kmc> synonyms are not new types.  if you want a new type you have to create a new type
08:52:06 <copumpkin> danportin: most of the time, you'll either need overlapping instances too, or it just won't work
08:52:06 <kmc> timcowlishaw, note that "newtype" is mostly just an optimization for "data"
08:52:22 <kmc> you can use "data" instead, with almost the same semantics
08:52:30 <copumpkin> ALMOST!
08:52:35 <kmc> almost
08:52:43 <copumpkin> AAAALMOOOOST!!!
08:53:00 * copumpkin goes back to his bottle
08:53:29 <ezyang> WHoooo! 
08:53:35 <copumpkin> ezyang: sup?
08:53:46 <timcowlishaw> aah, thank you all
08:53:53 <ezyang> copumpkin: Good morning sir. 
08:54:03 <copumpkin> good morning to you!
08:54:10 <timcowlishaw> will have another look - I think i should probably avoid using show for this purpose anyway
08:56:36 <kmc> yeah
08:56:57 <kmc> you may not get much benefit vs. just writing an ordinary function to pretty-print the structure
08:58:57 <timcowlishaw> i think so - in any case the resulting string's getting used as the address for a Network.HTTP request, so show's definitely not the right thing :-)
09:04:02 <SonOfLilit> thank you all
09:04:19 <SonOfLilit> I have a somewhat functioning version of my game ready
09:04:44 <SonOfLilit> the code is horrible in some places, and I would be very glad if some of you would take a look and suggest improvements
09:05:03 <SonOfLilit> as usual, it can be found at http://github.com/SonOfLilit/purewars
09:05:46 <aristid> SonOfLilit: you should make a screenshot
09:06:24 <SonOfLilit> aristid: you should run it :P
09:06:48 <SonOfLilit> aristid: nah, it's just that I can't figure out a simple way to make screenshots with Arch Linux + XMonad
09:07:09 <SonOfLilit> and the game is pretty simple to {run, look at}
09:07:27 <aristid> SonOfLilit: try import from imagemagick
09:07:40 <aristid> import  - saves any visible window on an X server and outputs it as an image file. You can capture a single window, the entire screen, or any rec‐
09:07:40 <aristid>        tangular portion of the screen.
09:08:34 <kmc> gimp can take screenshots too
09:09:14 <jkramer> Is there a dedicated channel for blazehtml?
09:09:40 <aristid> jkramer: i don't know, but #haskell-web might be a good place
09:10:00 <jkramer> Thanks, will try it there
09:11:06 <aristid> SonOfLilit: Main.hs:11:7:     Could not find module `Keyboard':
09:11:24 <SonOfLilit> aristid: you're compiling it wrong, probably
09:11:31 <SonOfLilit> or maybe I didn't add Keyboard.hs to git?
09:11:33 <SonOfLilit> moment
09:11:36 <aristid> SonOfLilit: no, there's no Keyboard file
09:12:12 <SonOfLilit> there you go
09:12:26 <SonOfLilit> it's on git
09:12:55 <jkramer> Ah, maybe my question is not so blaze-specific at all
09:13:31 <aristid> Main.hs:22:53:
09:13:31 <aristid>     No instance for (GLUT.VertexComponent Double)
09:13:31 <aristid>       arising from a use of `GLUT.vertex' at Main.hs:22:53-64
09:13:55 <jkramer> I'm using OverloadedStrings, and things like H.input ! name "foo" work fine, however things like foo x = H.input ! name x \ foo "foo" don't
09:14:18 <jkramer> Is there a workaround for this? I think the problem is that that I'm using a parameter, not a literal
09:14:44 <ezyang> What's the error? 
09:14:51 <osaunders> Why is this a parse error: foo (x % y) = x + y -- I want to pattern match on a Ratio Int.
09:15:23 <ezyang> osaunders: % is not a constructor. 
09:15:44 <jkramer> ezyang:  Couldn't match expected type `AttributeValue' \ against inferred type `[a]'
09:15:49 <ezyang> use numerator/denominator 
09:15:57 <SonOfLilit> aristid: That's strange, it works for me
09:15:58 <osaunders> ezyang: Do you know what is?
09:16:06 <SonOfLilit> what version of GLUT do you have installed?
09:16:09 <ezyang> jkramer: Hmm, not enough context. 
09:16:14 <ezyang> osaunders: It's a function. 
09:16:17 <ezyang> @src (%) 
09:16:17 <lambdabot> Source not found. Are you on drugs?
09:16:28 <ezyang> (%) :: Integral  a => a -> a -> Ratio a 
09:16:41 <jkramer> It means the thing after !, which works when it's a literal "string", but not if it's an argument to the function
09:16:50 <osaunders> OK.
09:16:59 <ezyang> What's the type of the function? 
09:17:40 <jkramer> It should be something like AttributeValue -> AttributeValue -> AttributeValue -> Html, however I think it's String -> String -> String -> Html
09:17:58 <jkramer> I guess the problem is that OverloadedStrings doesn't recognize the intended type
09:18:15 <ezyang> jkramer: You should figure that out for certain. Add undefined until the prog compiles and load it up in ghci? 
09:19:34 <monochrom> constructor of Ratio is not exported. for many good reasons.
09:19:46 <jkramer> Does ghci support OverloadedStrings?
09:19:54 <jkramer> How do I set that option there?
09:20:10 <kmc> ghci -XOverloadedStrings
09:20:15 <kmc> or within ghci: :set -XOverloadedStrings
09:20:17 <jkramer> Ah, right :D
09:21:00 <osaunders> ezyang: Is there any good reason why Ratio doesn't export a data constructor.
09:21:24 <monochrom> internal data invariants need to be enforced. think "smart constructor"
09:21:26 <ezyang> http://hackage.haskell.org/packages/archive/base/3.0.3.1/doc/html/GHC-Real.html 
09:21:36 <ezyang> It's implementation dependent. 
09:21:49 <kmc> if it wants to store in reduced fractions only
09:21:56 <aristid> monochrom: many? isn't it just one? prevention of illegal Ratios...
09:22:08 <kmc> unfortunately you can't export a constructor for matching only
09:22:11 <kmc> i hear you can do this in ocaml
09:22:14 <ezyang> Anyhoo, smart constructor is useful. 
09:22:18 <kmc> a lightweight alternative to views in some situations
09:22:24 <ezyang> And view patterns are a pretty reasonable approximation. 
09:23:30 <SonOfLilit> aristid: try the new version
09:24:25 <aristid> SonOfLilit: how to play?
09:24:35 * ezyang <3 view patterns 
09:24:44 <SonOfLilit> awd, f shoots vs. lrft right up, / shoots
09:24:55 <SonOfLilit> meant for two players
09:25:19 <SonOfLilit> shoot to restart after the game is over
09:25:38 * BMeph <33 view patterns!
09:25:56 <jkramer> I think I found the problem
09:26:06 <monochrom> ♡♥
09:26:28 <jkramer> OverloadedStrings tries to convert my String to an AttributeValue, however in the same function I'm using the string as a string as well
09:27:05 <Heffalump> jkramer: did you try NoMonomorphismRestriction ?
09:27:20 <Martty> fac = 1 : [(x+1)*x | x<-fac] first one to fix this wins 
09:27:26 <SonOfLilit> aristid: how's it going?
09:27:28 <aristid> SonOfLilit: you need to make it more playable :D
09:27:35 <aristid> also i am not two players
09:27:49 <Heffalump> Martty: wins what?
09:27:52 <jkramer> Heffalump: Doesn't help either (tried -XNoMonomorphismRestriction)
09:28:22 <wli> Martty: fac = 1 : scanl1 (*) [1..]
09:28:34 <Martty> it has to use a list comprehension
09:29:20 <aristid> > 1 : scanl1 (*) [1..]
09:29:21 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
09:29:22 <SonOfLilit> aristid: if there were anyone else near you, you would find that it is already much fun to play
09:29:31 <aristid> wli: no, that's not right
09:29:39 <SonOfLilit> there are some constants to tune, and a main menu and score reporting to add, but that's it
09:29:58 <aristid> SonOfLilit: my laptop is not big enough to gather lots of people at it :P
09:30:05 <SonOfLilit> :P
09:30:11 <aristid> SonOfLilit: make an online mode! :D
09:30:33 <BMeph> Looks like (Data.)Ratio should have a Ratio a -> (a,a) function, to conpensate for not having a pattern-matching way to get it. For that matter, a CPS-influenced function would work great for that, too.
09:31:32 <SonOfLilit> since those are boring, and since I have been waiting for weeks to finish this so that I can go on to my next project which will be much fun for me, I don't thing I'll implement them, and maybe one day I'll return to this, port it to FRP and add all the bells and whistles
09:31:56 <SonOfLilit> this was, after all, a 100% learning project
09:32:11 <SonOfLilit> meant to teach me some haskell, and very successful at that
09:34:08 <BMeph> SonOfLilit: Why not put it on Hackage, and let teh intarwebs help make it roXX0rZ...er, get some patches to improve it while you go on to bigger and better projects? ;)
09:34:47 <SonOfLilit> BMeph: because it's too alpha
09:35:00 <SonOfLilit> BMeph: putting it on a blog or something would be ok, though
09:35:06 <BMeph> SonOfLilit: What, you're gonna sell it someday? 
09:35:52 <SonOfLilit> BMeph: no, but I wouldn't put on hackage code that doesn't have much worth by using it as opposed to reading it
09:36:05 <BMeph> Help gwern out - put it on Hackage yourself, don't make him kvetch you into it! :)
09:36:33 <monochrom> there is virtue in not diluting hackage quality
09:36:33 <SonOfLilit> It is open source and can be used by anyone for anything, accessed from my github profile
09:37:04 <SonOfLilit> but I'll only put it on hackage if and when it is of interest without reading the code
09:37:18 <SonOfLilit> anyone have a blog where they want to publish a link? welcome :)
09:37:58 <SonOfLilit> (of course, if anyone strongly disagrees, they are welcome to put it in hackage - the BSD license doesn't forbid that
09:38:41 <SonOfLilit> monochrom: there is. that way I can expect quality from things I get off of hackage
09:44:23 * ezyang doesn't know why he gets so gleeful while doing type programming 
09:46:07 <osaunders> > (3 % 4) * (16 % 12)
09:46:09 <lambdabot>   1 % 1
09:46:26 <osaunders> > (3 % 4) * (10 % 5)
09:46:27 <lambdabot>   3 % 2
09:46:35 <ddarius> ezyang: Your article makes little sense.  1) I doubt most mainstream programmers are familiar with type classes.  2) Your associated types examples don't correspond to your fundep examples and don't illustrate how to cover the latter fundep case, 3) you associated type examples seem "backwards."
09:47:32 <EvanR-work> heh, ghci is pretty awesome
09:48:02 <EvanR-work> i was like 'how the hell am i going to test this IO action, which requires a database connection, which requires a ReaderT Config to aquire......"
09:48:04 <ezyang> ddarius: :-( Ok, lessee. 
09:48:34 <monochrom> perhaps don't target mainstream programmers
09:48:38 <EvanR-work> ... so i read the config file, defined a two statement ReaderT Config IO action, and did runReaderT ;)
09:48:47 <ezyang> Yeah, I think I won't. So I can reword the intro. 
09:49:08 <EvanR-work> functional for the win
09:49:17 <ezyang> re 2 and 3, I don't actually know enough about associated types to really know what you mean. 
09:49:32 <ezyang> What would be the straight translation of the fundeps case? 
09:51:29 <ezyang> Oh, I guess I did get it backwards. 
09:51:33 <ddarius> ezyang: Your associated types example corresponds to having a fundep e -> c, not c -> e.  Writing an associated types example to handle the e -> c, c -> e case would be ugly.
09:51:40 <ezyang> LOL. 
09:52:03 <pumpkin> don't you need superclass equality constraints for bidirectional associated types?
09:52:56 <ddarius> You need something that GHC currently doesn't support to actually witness the theoretical equivalence of multiparameter typeclass+fundeps and associated types.  I think that particular example, though, could be done by simply using multiple classes.
09:53:02 <ddarius> But it gets ugly.
09:53:31 <ezyang> I'm a little confused why I thought the reverse fundep would work... 
09:53:33 <zygoloid> if you're not defining Int or IntMap within the instance, you can't really do the same as | e -> c, c -> e.
09:54:13 <zygoloid> can haz superclass equality constraints
09:54:32 <pumpkin> they were supposedly scheduled for 6.14
09:54:37 <pumpkin> but who knows
09:55:32 <chrisdone> hiya
09:55:35 <zygoloid> type family Container elem :: *; class (Container (Element set) ~ set) => Set set where type Element set :: *; ...
09:57:36 <EvanR-work> i only realized yesterday that copumpkin spells co pumpkin
09:57:52 <EvanR-work> before it was an unpronouncable corruption  of munchkin
09:57:55 <c_wraith> oh, right.  you joined the channel after he changed his name.
09:57:55 <copumpkin> lol
10:00:21 <zygoloid> there was a passing phase of /nick corruptions. some of us got permanent scarring
10:00:47 <zygoloid> > drop 4 $ zipWith ($) (cycle [succ.succ.succ,pred.pred.pred]) "zygoilid`"
10:00:49 <lambdabot>   "lilac"
10:01:07 <copumpkin> :O
10:01:17 * zygoloid pulls off the energy mask
10:01:19 <EvanR-work> the changes i just made to my 'script' seems to have lead to sometimes crashing with 'out of memory' ...
10:01:39 <EvanR-work> but i didnt do anything even remotely bizarr :(
10:01:43 <EvanR-work> how can i debug this
10:01:57 <zygoloid> EvanR-work: use hades :)
10:02:15 <zygoloid> this may require some amount of contributing fixes to hades. this i see as a side benefit :)
10:02:47 <EvanR-work> eehhhyeah
10:02:55 <EvanR-work> another suggestion ;)
10:03:08 <zygoloid> ;(
10:03:39 <EvanR-work> it will show me where memory is going?
10:04:01 <zygoloid> kinda. it'll let you explore your heap.
10:04:25 * zygoloid has not yet implemented an automatic show-me-retainers-for-my-space-leak functionality :)
10:05:00 <EvanR-work> malloc: resource exhausted (out of memory)
10:05:12 <EvanR-work> does this look like a foriegn library?
10:06:28 <EvanR-work> it started happening right after we changed the datatype in the DB from blob (max 16k) to longtext (max 4G)
10:07:26 <lispy1> EvanR-work: which database library?
10:07:29 <EvanR-work> hdbc
10:07:32 <EvanR-work> mysql
10:07:47 <lispy1> EvanR-work: switch to takusen (oh, completely biased plug!)
10:07:58 <EvanR-work> can i get a backtrace?
10:08:19 <lispy1> EvanR-work: Oh wait, 4G?  Are you on a 64bit machine with > 4GB of ram?
10:08:24 <EvanR-work> no
10:08:35 <EvanR-work> but the data is not anywhere near that big
10:08:40 <lispy1> EvanR-work: you might be able to get a backtrace (of limited usefulness) if you run in gdb
10:09:01 <lispy1> Is the exception in unixODBC or in HDBC
10:09:34 <lispy1> it may be happening at a layer you can't control.  Or it could be that some library in the chain is being very conservative about allocating memory and allocating enough for the whole thing.
10:09:52 <EvanR-work> o_O
10:09:54 <EvanR-work> i hope not
10:10:23 <EvanR-work> nothin in gdb
10:10:32 <EvanR-work> -g doesnt seem to add debug info to the binary
10:10:53 <lispy1> EvanR-work: I'd check the unixODBC log.  Maybe _it's_ the one having the malloc fail
10:11:03 <lispy1> I forgot how to get that log...
10:11:05 <EvanR-work> im not using ODBC
10:11:21 <lispy1> doesn't hdbc use odbc for all database types?
10:11:53 <EvanR-work> it seems to have a mysql, oracle, postgres, and odbc driver
10:12:28 <lispy1> Well, you may have to dig into the hdbc source for the mysql backend and do some debugging
10:12:35 <lispy1> find anywhere that it allocates buffers
10:12:51 <EvanR-work> im looking at some basic ways to get debug feedback from the binary
10:12:53 <EvanR-work> first
10:12:58 <lispy1> Figure out how it gets the size of the buffer, try inserting Debug.Trace.trace calls to see how far it makes it before dying
10:13:12 <EvanR-work> i dont even know if its the database yet
10:13:24 <EvanR-work> but ill get a test on that, by setting the field back to medium blob
10:13:33 <EvanR-work> or small or whatever
10:13:46 <lispy1> Compile with -hpc support and then when it crashes check the code coverage
10:14:12 <lispy1> you could run it inside strace
10:14:20 <lispy1> See what system calls it makes before it dies
10:15:32 <sm> zygoloid: is hades your project ?
10:15:35 * edwardk waves hello.
10:15:40 <ezyang> ddarius: I've updated the examples, but I bet there's still a few typos. 
10:15:47 * lispy1 says hi to edwardk
10:17:36 <ezyang> I'm not sure if I've addressed the bidirectional fundep thing adequately though. 
10:18:55 <ezyang> My understanding was a data family forced the function to be injective. 
10:19:03 <ezyang> so it's an adequate (if verbose) substitute. 
10:20:07 <edwardk> ezyang as long as you can "own" one of the two sides of the fundep. data/newtype families are often somewhat verbose
10:20:15 <sproingie> ezyang: your post on fundeps and type families was, uh, awesome.  best intro to the subject i've read yet.
10:21:25 <ezyang> sproingie: You should go reread it: I just edited it to make the examples more parallel :-P 
10:21:41 <ezyang> edwardk: Ah, that makes sense. 
10:22:14 <edwardk> fundeps: for when you want to encode multiple relations, without repeating yourself, type/data families for when you want to get implementation details out of the signature of data types that use them, and not have to mention a bunch of parameters you don't use in the signature of a function. ;)
10:23:01 <edwardk> class Default a where   default :: a runs afoul of the 'default' keyword
10:23:09 <edwardk> this is why data-default uses 'def'
10:23:22 <ezyang> fixored. 
10:23:40 <edwardk> you're fast ;)
10:25:36 <EvanR-work> in the interest of worse is better, we changed it to medium text
10:25:44 <ezyang> I'm going to add a variant of what you just said to the post. 
10:25:45 <edwardk> the other option with IntSet is rather than introduce a fundep between Int and IntSet you can make another class that just provides the non-parameterized behavior. class SetLike c where empty :: c; union :: c -> c -> c; intersection :: c -> c -> c; class SetLike c => Set c e where ... -- of course then type inference is hellish, but it is worth noting
10:25:54 <EvanR-work> so if the bug is still happening some braindamaged C library is allocating 16M for each 10k attachment
10:26:03 <EvanR-work> and since we have more than 16M were 'ok'
10:26:11 <ezyang> edwardk: I think we want to keep inference as much as possible. 
10:26:33 <edwardk> ezyang: i agree. just pointing out the alternate solution available in that space ;)
10:26:46 <edwardk> the fundeps just help type inference flow, they aren't required for the scenario painted.
10:27:10 <ezyang> That's true. 
10:27:17 <edwardk> why data Elem c ?
10:27:35 <edwardk> to be compatible with the IntSet eample with the one way fundep i'd think you'd use type Elem c
10:27:48 <edwardk> oh found it farther down
10:28:10 <kmc> hi edwardk :)
10:28:27 <edwardk> ezyang: why do you presume the existence of a null element?
10:28:28 <copumpkin> hi edwardk :)
10:28:33 <edwardk> heya kmc, copumpkin 
10:29:29 <jadrian> hi
10:29:41 <copumpkin> jadrian: hi!
10:30:03 <jadrian> hi copumpkin 
10:30:08 <EvanR-work> lispy1: off handedly looking at the mysql driver code... i see lots of mallocBytes (fromIntegral size).... could be ripe for bugs...
10:30:24 <jadrian> what do you guys call: return . f
10:30:26 <ezyang> edwardk: It's mostly to demonstrate the injectivity stuff. 
10:30:32 <jadrian> lifting?
10:30:33 <EvanR-work> liftM
10:30:38 <ezyang> jadrian: Yup. 
10:30:44 <lispy1> ?pl \f -> return . f
10:30:44 <lambdabot> (return .)
10:30:50 <jadrian> ok great
10:31:28 <lispy1> EvanR-work: yeah.  That doesn't surprise me.  I'm not sure if you can even get the size of column foo in the current row before copying it out of the database.  Hopefully you can.
10:31:31 <edwardk> it just seems somewhat bolted on to the example you've chosen, with no explanation of why one might want it or that it is just bolted on for that purpose
10:31:37 <ezyang> ok. 
10:32:24 <EvanR-work> :S
10:32:29 <edwardk> personally i'd probably flip it around, and start with a type family example and then work backwards to a data family example from there
10:32:39 <edwardk> since it is closer to the one way fundep you started with
10:32:44 <ezyang> True. 
10:32:50 <EvanR-work> id i had more experience with the mysql C library i might be able to debug this
10:32:51 <edwardk> but what you have has the advantage of already being written
10:32:56 <EvanR-work> if*
10:33:29 <edwardk> you can make an interesting data family version, by changing the convention around too
10:34:00 <ezyang> edwardk: That is, the original way it was structured? 
10:34:02 <edwardk> class Key k where data Set k :: *; empty :: Set k; insert :: k -> Set k -> Set k
10:34:14 <ezyang> yah. 
10:34:47 <jadrian> hmm liftM is a bit different from (return .)
10:34:55 <edwardk> that way the fact that it is is a data family serves a purpose. ;)
10:35:00 <jadrian> the domain of (return .) is not monadic
10:35:11 <jadrian> would it still make sense to call it a lifting
10:35:17 <edwardk> since you are defining the Set in your code and not the element types
10:35:44 <edwardk> you 'own the wrong thing' to use the data family you have
10:36:49 <ezyang> edwardk: Right. 
10:38:56 <edwardk> with the definition you give there, it isn't really possible for the end user to use your data family version at all in any sort of polymorphic way, since they'd have to wrap and unwrap their elements, but would have to use specific constructors for each type that they wouldn't necessarily know
10:48:14 <edwardk> gah i need to work on my abuse-an-external-smt-solver monad
10:48:24 <copumpkin> :O
10:49:02 <edwardk> copumpkin: its based on the SAT solving monad i had, and the template haskell-based external SMT solver code that nirav presented at boston haskell
10:49:18 <edwardk> copumpkin: and the 'vapply' trick from morrisett's nikola.
10:49:31 <edwardk> which is basically the same as the 'vgrad' i use in my 'ad' lib
10:50:08 <copumpkin> hm, don't think I went to that meetup
10:50:18 <edwardk> copumpkin: you missed a good one. =)
10:50:25 <copumpkin> I missed many good ones :(
10:50:29 * copumpkin weeps
10:50:42 <edwardk> copumpkin: clearly you need to get back stateside ;)
10:50:48 <copumpkin> :P
10:50:50 <ezyang> edwardk: Yes, /unless/ your instances define the canonical constructors for the data types :-) 
10:50:57 <ezyang> if I understand correctly 
10:51:00 <copumpkin> edwardk: working on it :)
10:51:25 <edwardk> ezyang: yes but each instance has to define a different constructor =P
10:51:36 <ezyang> Yup. 
10:57:55 <firegolfer> I need little help with Network.CGI
10:58:04 <firegolfer> getParam :: String -> String
10:58:19 <firegolfer> getParam x = (getInput x) >>= fromMaybe "/"
10:58:37 <firegolfer>  No instance for (MonadCGI [])
10:58:41 <firegolfer> Why is that so?
10:59:43 <kmc> probably you need the return value to be a monadic action of some kind?
10:59:52 <kmc> it is, but only by accident, since String = [Char] and [] is a monad
11:00:05 <kmc> but i'm guessing you need something like String -> IO String
11:00:53 <firegolfer> well
11:00:54 <firegolfer> then
11:01:01 <firegolfer> "/" needs to be IO String to
11:01:20 <firegolfer> hm
11:01:23 <firegolfer> return "/"
11:01:49 <firegolfer> hm no.
11:05:06 <firegolfer> http://codepad.org/37BS18BB
11:09:58 <geheimdienst> so, System.Locale is in the old-locale package, but there's no new locale package, right?
11:10:06 <geheimdienst> so i should use old-locale
11:11:49 <chrisdone> firegolfer: it should be
11:12:19 <chrisdone> getParam :: MonadCGI m => String -> m String
11:12:19 <chrisdone> getParam = fmap (fromMaybe "/") . getInput
11:12:59 <chrisdone> or, pointfully:
11:13:00 <chrisdone> getParam name = fmap (fromMaybe "/") $ getInput name
11:14:22 <chrisdone> getParam :: String -> [Char] with getInput x makes Haskell want to reconcile [] with MonadCGI m => m, but [] isn't an instance
11:14:23 <roconnor> getParam name = fromMaybe "/" `fmap` getInput name
11:14:40 <roconnor> I use infix fmap quite a bit in monadic programming
11:14:47 <chrisdone> roconnor: if you're gonna do that you might as well use <$> :-)
11:14:50 <roconnor> Mostly cause I'm too lazy to import applicative
11:14:54 <chrisdone> lol
11:14:58 <chrisdone> roconnor: do you use emacs?
11:15:05 <roconnor> nope
11:15:15 <roconnor> I can't get backspace and help to work at the same time in emacs :P
11:15:17 <chrisdone> tch. importing Applicative is so easy for me
11:15:23 <copumpkin> anyone use haskell+vim here?
11:15:29 <chrisdone> mauke does
11:15:30 <roconnor> I use kate
11:15:33 <firegolfer> Could not deduce (Functor m) from the context (MonadCGI m)
11:15:44 <roconnor> er
11:15:45 <roconnor> `liftM`
11:15:50 <roconnor> instead of fmap
11:15:55 <chrisdone> firegolfer: oop, my bad. should've said liftM, or just add the Functor constraint
11:16:28 <firegolfer> ok
11:16:30 <roconnor> firegolfer: liftM = fmap at least in the cases where they are both defined.
11:16:37 <roconnor> that is why we made the mistake
11:17:13 <firegolfer> so
11:17:22 <firegolfer> No instance for (MonadCGI IO)
11:17:34 <geheimdienst> can i simplify code like this? do x <- getX; y <- getY; return FooRecord { foo_x = x, foo_y = y }
11:17:37 <firegolfer> because main is IO?
11:17:50 <geheimdienst> (suppose i have more than just 2 of those fields)
11:17:52 <chrisdone> firegolfer: are you using runCGI?
11:17:55 <firegolfer> no
11:17:56 <chrisdone> :t runCGI
11:17:57 <lambdabot> Not in scope: `runCGI'
11:18:07 <firegolfer> but
11:18:09 <roconnor> @hoogle runCGI
11:18:10 <lambdabot> Network.CGI runCGI :: MonadIO m => CGIT m CGIResult -> m ()
11:18:10 <lambdabot> Network.CGI.Protocol runCGIEnvFPS :: Monad m => [(String, String)] -> ByteString -> (CGIRequest -> m (Headers, CGIResult)) -> m ByteString
11:18:10 <lambdabot> Network.CGI.Monad runCGIT :: Monad m => CGIT m a -> CGIRequest -> m (Headers, a)
11:18:11 <firegolfer> main = runCGI cgiMain
11:18:17 <firegolfer> and renaming the other main to cgiMain
11:18:23 <firegolfer> leads exactly to the same error
11:18:28 <chrisdone> firegolfer: right, so cgiMain :: MonadCGI m => m CGIResult
11:19:06 * wli would use gets :: MonadState s m => (s -> a) -> m a instead of building up layers of cruft.
11:19:31 <firegolfer> ok
11:19:39 <firegolfer> so I have to return m ()
11:19:41 <firegolfer> ?
11:19:42 <chrisdone> ah, I forgot runCGI adds a MonadIO constraint
11:20:48 <firegolfer> It does not accept the return anymore
11:21:07 <chrisdone> firegolfer: let's start over
11:21:20 <firegolfer> Sorry, but I'm totally a haskell newbie.
11:21:43 <chrisdone> firegolfer: explain the current problem
11:22:03 <firegolfer> cgiMain needs to return "m CGIResult"
11:22:21 <firegolfer> which return () does not.
11:22:28 <chrisdone> indeed
11:22:32 <kmc> geheimdienst, RecordWildCards is useful
11:23:06 <chrisdone> firegolfer: so what do you need to know?
11:23:17 <firegolfer> How can I return m CGIResult?
11:23:36 <chrisdone> firegolfer: do you know have the Network.CGI documentation available?
11:23:40 <geheimdienst> kmc, thank you, looking at it
11:24:09 <firegolfer> chrisdone: I do
11:24:16 <kmc> do foo_x <- getX; foo_y = getY; return FooRecord{..}
11:24:39 <firegolfer> runCGI takes a CGIT m CGIResult
11:24:46 <chrisdone> firegolfer: okay, so you see down the list there are a bunch of actions that return 'MonadCGI m => m CGIResult', such as `output'
11:25:26 <aristid> @hoogle outputNothing
11:25:26 <lambdabot> Network.CGI outputNothing :: MonadCGI m => m CGIResult
11:25:45 <aristid> where CGIT m fulfills MonadCGI, i think
11:27:41 <chrisdone> firegolfer: if you check out the whole definition of runCGI it's a little easier to get
11:27:45 <chrisdone> runCGI :: MonadIO  m => CGIT  m CGIResult  -> m ()
11:27:54 <chrisdone> you're running it from the main :: IO () function, so we can fill that in:
11:28:04 <chrisdone> runCGI :: CGIT IO CGIResult  -> IO ()
11:28:44 <chrisdone> and for any Monad m, CGIT m CGIResult is an instance of MonadCGI
11:28:53 <firegolfer> Couldn't match expected type `IO' against inferred type `m'
11:28:53 <firegolfer>       `m' is a rigid type variable bound by
11:28:53 <firegolfer>           the type signature for `walkDir' at hasfee.hs:16:20
11:29:05 <chrisdone> so you can run any MonadCGI m => m action in ut
11:29:12 <firegolfer> walkDir :: MonadCGI m => FilePath -> m CGIResult
11:29:48 <chrisdone> firegolfer: right, to use IO /inside/ a CGI computation you need to add the MonadIO constraint
11:30:19 <firegolfer> http://codepad.org/CrFMpdBC
11:30:19 <chrisdone> thought in this case it's probably simpler if you just use CGI instead of generalising right now
11:30:23 <firegolfer> thats
11:30:29 <firegolfer> IO [FilePath]?
11:30:38 <firegolfer> @using IO inside CGI
11:30:38 <lambdabot> pong
11:31:26 <chrisdone> firegolfer: okay, I was giving a more general approach for any instance of MonadCGI but we can specialise and make it easy just to get you off the ground
11:31:38 <firegolfer> that'd be nice ;)
11:31:38 <chrisdone> firegolfer: I'll fix it and then explain it
11:33:13 <chrisdone> okay, fixed
11:33:16 <chrisdone> I'll paste on hpaste.org
11:33:49 <chrisdone> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29014#a29014
11:34:19 <chrisdone> I've changed the general MonadCGI m => m, to specialised CGI
11:34:35 <chrisdone> CGI is a specific instance of MonadCGI that allows IO
11:35:39 <chrisdone> firegolfer: see how getParam is defined in terms of getInput, and so it only needs the MonadCGI constraint, we don't have to specialise for a specific type
11:35:49 <chrisdone> getInput :: (MonadCGI m) => String -> m (Maybe String)
11:35:50 <chrisdone> therefore
11:35:50 <chrisdone> getParam :: (MonadCGI m) => String -> m String
11:37:13 <chrisdone> it might be difficult to understand if you're not used to type classes or transformers and things
11:38:53 <geheimdienst> given an (Int, Int), how do i run a function Int -> IO String on each member and collect the results in an IO (String, String) ?
11:39:14 <geheimdienst> (i hope that's clear)
11:39:31 <aristid> getDirs fp = do getDirectoryContents fp >>= mapM (return . (fp ++))
11:39:40 <tafryn> Is there something that similar to " let pad (x:[]) = '0':x:[]; pad s = s; " that already exists?
11:39:53 * hackagebot ListZipper 1.2.0.1 - Simple zipper for lists  http://hackage.haskell.org/package/ListZipper-1.2.0.1 (RyanIngram)
11:39:57 <aristid> at least the do is unneccesary
11:40:46 <chrisdone> tafryn: printf?
11:40:56 <firegolfer> ok
11:40:59 <mauke> let (x, y) = xy in f x >>= \s1 -> f y >>= \s2 -> return (s1, s2)
11:41:04 <firegolfer> except that it does not output anything
11:42:11 <chrisdone> firegolfer: ah, sure. output doesn't actually side-effect. it just returns CGIResult, so you need to return the CGIResult at the end
11:42:41 <firegolfer> :(
11:42:55 <firegolfer> damn pure code
11:42:56 <firegolfer> Ok.
11:43:00 <chrisdone> :p
11:43:06 <firegolfer> So I have to collect everything
11:43:09 <chrisdone> this is your brain on Haskell
11:43:10 <firegolfer> and then output it?
11:43:18 <firegolfer> or can i concat outputs?
11:43:19 <chrisdone> yeah
11:44:21 <firegolfer> ok
11:44:23 <chrisdone> for now I'd generate a string
11:45:06 <chrisdone> there isn't really much you need to do anyhoo
11:45:19 <geheimdienst> mauke, thanks. that's like what i had in mind. i just wanted to see if there's some liftM2 magic or something
11:45:26 <geheimdienst> i'll do it that way then
11:46:03 <mauke> :t (***)
11:46:04 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:46:20 * geheimdienst stares
11:46:43 <mauke> join (***) f gets you (IO String, IO String)
11:47:03 <aristid> \o/ join
11:47:06 * geheimdienst can't believe it
11:47:07 <aristid> :t join (***)
11:47:08 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:47:15 <firegolfer> output $ ".:[Dirs]:.\n" ++ (concat $ map (++"\n") dirs) ++ ".:[Files]:.\n" ++ (concat $ map (++"\n") files)
11:47:24 <firegolfer> awfully long line but works :)
11:47:39 <mauke> geheimdienst: (Arrow (~>)) => (b ~> c) -> (b' ~> c') -> ((b, b') ~> (c, c'))
11:47:42 <aristid> :t join (***) show
11:47:43 <lambdabot> forall b. (Show b) => (b, b) -> (String, String)
11:47:48 <mauke> firegolfer: you want unlines
11:48:04 <aristid> > join (***) show (1, 2)
11:48:05 <lambdabot>   ("1","2")
11:48:20 <geheimdienst> you guys are so awesome
11:49:13 <seydar> this. is. the carter.
11:49:13 <Ivoz_> in http://en.literateprograms.org/Fibonacci_numbers_(Haskell)#Infinite_Lists why does the first list in zipWith seem to move up an element each time?
11:49:17 <firegolfer> thanks for your help
11:49:21 <seydar> a lot more right and a whole lot smarter.
11:49:29 <seydar> s/right/rich
11:49:31 <seydar> sorry lil wayne
11:49:37 <carter> seydar: hrm? 
11:49:40 <aristid> geheimdienst: now instead of simple but tedious code, you can write elegant code that nobody without at least 6 months in #haskell can read :)
11:49:54 <seydar> carter: hahaha sorry, i'm just quoting a lil wayne song
11:50:30 <copumpkin> seydar: SON, I AM DISAPPOINT
11:50:30 <EvanR-work> optimize for math density
11:50:37 <chrisdone> :t uncurry (liftM2 (,))
11:50:39 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
11:50:56 <seydar> copumpkin!
11:51:23 <seydar> copumpkin: what do you think of berp
11:51:29 * copumpkin berps
11:51:46 <copumpkin> seydar: doesn't look bad, haven't played with it much (I only use python for one thing, and berp wouldn't help with it)
11:52:01 <geheimdienst> aristid: and in 2 weeks time, expect me back in here saying "wtf did i write here?" ;)
11:52:19 <carter> seydar: no worries, for a  moment i was like "are people really googling: username haskell"
11:52:48 <carter> or something
11:53:43 <derekwright_> #
11:53:52 <aristid> # derekwright_
11:54:12 <chrisdone> :t uncurry (liftM2 (,)) . join (***) (undefined :: Int -> IO String)
11:54:13 <lambdabot> (Int, Int) -> IO (String, String)
11:54:44 <chrisdone> @pl uncurry (liftM2 (,))
11:54:45 <lambdabot> uncurry (liftM2 (,))
11:54:53 <chrisdone> can't think of a better way to write that
12:03:45 <aristid> :t join (liftM2 (,)) . (undefined :: Int -> IO String)
12:03:46 <lambdabot> Int -> IO (String, String)
12:03:49 <aristid> chrisdone: :P
12:03:57 <aristid> i think i win.
12:04:14 <aristid> oh :(
12:04:16 <aristid> i lose
12:05:01 <chrisdone> lol
12:08:35 <aristid> @unpl liftM2 (,)
12:08:35 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return ((,) b a))
12:08:43 <aristid> @pl . unpl liftM2 (,)
12:08:43 <lambdabot> (line 1, column 1):
12:08:43 <lambdabot> unexpected "."
12:08:43 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:08:57 <aristid> @. pl unpl liftM2 (,)
12:08:57 <lambdabot> liftM2 (,)
12:08:59 <geheimdienst> can i simplify code which has a ton of this? x <- getFoo xconst ; y <- getFoo yconst
12:09:17 <geheimdienst> i.e. the getFoo is unchanged on all lines
12:09:26 <EvanR-work> i emailed chris waterson, maintainer of HDBC-mysql about the problem
12:10:35 <Ferdirand> [x,y,z] <- sequence . map getFoo $ [xconst,yconst,zconst]
12:10:40 <Ferdirand> or something like that
12:11:45 <geheimdienst> i see
12:11:48 <geheimdienst> thanks
12:12:55 <Saizan> sequence . map f = mapM f
12:30:04 <seydar> copumpkin: what do oyu do with your free time now
12:34:13 <copumpkin> seydar: a million different things :P
12:34:24 <copumpkin> I doubt the 600 people in here care though
12:35:36 * EvanR-work suddenly wonders what copumpkin does with his spare time
12:36:00 <geheimdienst> evanr-work, he just told us, it's a million different things
12:36:07 * roconnor . o O ( What does copumpkin do in his spare time )
12:36:32 <EvanR-work> ) O o . <roconnor>
12:36:46 <Heffalump> EvanR-work: your tags are badly nested now
12:37:03 <seydar> what does he do?!?!
12:37:03 <copumpkin> lol
12:37:05 <seydar> we must know
12:37:46 <geheimdienst> and they better not be "dishes", "laundry" and that kinda thing
12:38:01 <copumpkin> nope :)
12:38:56 <dolio> He sits around playing Starcraft in 80-hour stretches.
12:39:23 <geheimdienst> he sits around playing farmville in 80-hour stretches </ftfy>
12:39:35 <copumpkin> return to castle wolfenstein, actually
12:39:45 <geheimdienst> two words: lolcat marathon
12:39:53 <dolio> Wow, haven't played that one in a while.
12:40:19 <copumpkin> I actually played enemy territory every so often up until a few months ago
12:41:15 <EvanR-work> return the castle wolfenstein eliminated my need to play any further FPS
12:41:23 <EvanR-work> same game over and over
12:41:52 <EvanR-work> i do like DOOM though
12:47:46 <EvanR-work> chris waterson, maintainer of HDBC-mysql, has responded already and says hell try to fix it shortlty ;)
12:48:26 <EvanR-work> open source haskell at the speed of business
12:48:49 <sm> go go
12:49:41 <roconnor> EvanR-work: how fast it that?
12:50:07 <EvanR-work> somewhere between speed of sound and speed of light
12:50:16 <roconnor> woah
12:50:21 <roconnor> that is faster than I would have guessed
12:50:56 <EvanR-work> feels that way here, we never can get the software done before management wants something else
12:51:12 <EvanR-work> so we fly through all the projects leaving tangling todo lists
12:51:25 <roconnor> EvanR-work: management is the ones moving at the speed of business?
12:51:29 <EvanR-work> haha
12:51:37 <EvanR-work> personally i move at the speed of haskell programming ;)
12:51:44 <BCoppens> EvanR-work: however fast it is, it will be slower than the speed at which people are leaving Java atm ;-)
12:51:50 <EvanR-work> lol
12:51:53 <roconnor> it's a slower pace than regular programming.
12:52:32 <EvanR-work> people are leaving java for c#, if i sense culture correctly
12:53:02 <EvanR-work> or maybe that migration is done and was done three years ago
12:53:16 <roconnor> http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
12:53:18 <kmc> c# is a much more complete language
12:53:24 <sm> roconnor: I feel like you're right, yet the speed of delivering code that stays working is faster in haskell
12:53:24 <kmc> and still improving
12:53:32 <roconnor> java's delta is -1.53% per month
12:53:42 <kmc> java has stagnated; they're at the stage of "maybe eventually we will add first-class functions"
12:53:47 <EvanR-work> 'better is better' philosophy ;)
12:53:47 <roconnor> sm: yep
12:53:57 * sm hasn't yet been able to "fly" in haskell
12:54:14 <roconnor> what is flying?
12:54:39 <EvanR-work> whats TIOBE programming community index
12:54:43 <sm> meaning, feeling like you're really moving fast, without having to stop and puzzle out now new lib or type manouver
12:54:57 <sm> s/now/some/
12:55:20 <roconnor> sm: the thing about feeling like you are moving very fast in Java ... it is really more like you are typing a lot. :D
12:55:21 <sm> there have been a bunch of flashes of that though. Some of it I just take for granted now
12:55:26 <sm> indeed!
12:55:40 <roconnor> In haskell I fly, but in like 30 seconds I'm done.
12:55:45 <roconnor> then I have to check it over.
12:55:52 <sm> I hope that's not happening to me in haskell too. I do a fair bit of futzing around with emacs
12:56:05 <roconnor> sm: oh, like what?
12:56:20 <roconnor> I use kate so I can't futz
12:56:22 <edwardk> roconnor: to true. java you always feel like there is something you should be typing. in haskell you always feel like there is something you should be thinking about ;)
12:57:09 <EvanR-work> "The index can be used to check whether your programming skills are still up to date or to make a strategic decision about what programming language should be adopted when starting to build a new software system"
12:57:14 <ezyang> My RSI this summer is much better than last year, because I do so much less typing :-) 
12:57:15 <sm> roconnor: I'm not sure what I mean. Lots of editing. I guess exploratory edit-compile-attempts where I don't really grok the types.
12:57:31 <EvanR-work> so it appears i should be learning java, and using C on the next project
12:57:38 <EvanR-work> lol
12:57:43 <sm> and a fair bit of manual code refactoring which you'd expect an ide might handle in other languages
12:57:56 <roconnor> sm: ya I spend a lot of time playing in ghci and reloading
12:58:18 <sm> I do a bit of that, but I rely most on sp doing auto-recompile in a side buffer
12:58:29 <roconnor> sp?
12:58:37 <sm> http://searchpath.org
12:59:00 <sm> I have a patched version and make rule that makes recompile-on-save really easy
12:59:38 <EvanR-work> haskell is the top functional language in this list ;)
12:59:51 <roconnor> sm: that is a frigtening program
13:00:22 <sm> I have no idea what it would do if I let it off it's leash.. I just use it to recompile local files
13:00:37 <roconnor> ah
13:00:46 <sm>  worth its weight in gold !
13:01:17 <roconnor> doesn't reload in ghc reintepret local files?
13:01:21 <roconnor> ghci
13:01:45 <illissius> the really annoying thing for me is when i get a type error in a module, and i'd want to use ghci to check the types of things to puzzle it out, but i can't, because the module can't be loaded, because it has a type error
13:02:07 <roconnor> illissius: true
13:02:08 <illissius> is there any good workaround for that besides 'copy things into ghci' or 'remove stuff from the module until it compiles'?
13:02:21 <sm> illissius: define some things to undefined, sometimes
13:02:25 <roconnor> I just stare at the line number
13:02:29 <ezyang> illisius: udnefined 
13:02:29 <EvanR-work> heh
13:02:34 <Twey> +1
13:02:37 <roconnor> and occasionally add more type annotations when that doesn't work
13:02:40 <EvanR-work> roconnor: i find that often doesnt work because the error is on another line entirely ;)
13:02:41 <ezyang> But for haskell, the stare at it until you find a bug works surprisingly well. 
13:02:45 <sm> yes, always try adding more types
13:02:51 <sm> er annotations, that is
13:02:54 <roconnor> EvanR-work: indeed.  That is the worst
13:03:09 * sm is trying to practice more staring
13:03:11 <ezyang> These days, I mostly only need undefineds if I'm trying to push the type system. 
13:03:16 <illissius> yeah usually i just give up and stare at it until i figure it out without ghci
13:03:36 <roconnor> sm: I'm not really saying staring is a good thing, just simply what I do
13:03:44 <EvanR-work> gotta mentally check the types of all expressions, or add types for each = sign
13:04:03 <sm> it seems like it should be a good thing.. understand rather than hack at it..
13:04:16 <illissius> and undefineds work something, i often use them as "fill in the rest of this later" so I can try to compile what I have
13:04:26 <illissius> *sometimes
13:04:28 <Twey> The aim of debugging is better understanding anyway
13:04:39 <Twey> Debugging methods are just about how you achieve it
13:04:41 <roconnor> I've actually never used the undefined trick myself
13:04:45 <EvanR-work> i get the feeling that undefineds will just lead to code that compiles, obvious fails, and is still wrong on another line
13:04:48 <roconnor> it does seem moderately popular though
13:04:54 <sm> sure, but I know I have sometimes erred on the side of too much debugging and try this!
13:05:15 <ezyang> I mean, really, you should try to understand what the error means. 
13:05:21 <ezyang> Debugging goes much faster when you do. 
13:05:49 <sm> yes. Sometimes that's impractical with new haskell libs, a lot of them are quite frightening to understand in depth
13:05:56 <EvanR-work> errors often read like japanese poems, if you think of it that way, then debugging becomes just a matter of zen ;)
13:06:06 <sm> when you're trying to focus on your own app
13:06:28 <ezyang> sm: Yeah, it's a problem. 
13:06:38 <ezyang> High tech APIs require more understanding of the type system. 
13:06:54 <Twey> EvanR-work: The idea of using undefineds is that they will never fail as a compile error.
13:07:01 <ezyang> But I think it's still worth it >:-) 
13:07:08 <illissius> high tech APIs should come with a "things the compiler says -> what does this mean" translation guide as part of the docs
13:07:16 <sm> that would be nice
13:07:19 <Twey> EvanR-work: So you can replace a complex bit of code with an undefined and add bits in slowly until you find the bit that breaks.
13:07:22 <ezyang> I mean, they should come with more docs in general. 
13:07:27 * sm nods
13:07:27 <ezyang> and more examples. That don't bit rot either. 
13:07:37 <EvanR-work> Twey: yes, but then the type system cant help you if you disconnect the link between the working code and non working code at a place where the type checker gave up
13:07:39 <sm> I think better doc culture will come, with new hackage
13:07:53 * sm chants 100% documentation!!
13:08:01 <ezyang> You're much more optimistic than I am. 
13:08:02 <EvanR-work> but it *is* like deleting and rewriting the code
13:08:08 <EvanR-work> which is also a good way ;)
13:08:19 <sm> I've seen it happen elsewhere, no reason we can't do it
13:08:56 <illissius> according to mr. aaron seigo of kde, writing docs is much more enjoyable if it's on a wiki
13:09:00 <sm> I don't mean 100% docs for 100% of packages on hackage. 
13:09:46 <aristid> illissius: i can't agree with that
13:09:48 <sm> illissius: I think that depends very much on the wiki
13:10:05 <aristid> it's also annoying that wiki docs are not in the source tree
13:10:24 <sm> that's where gitit works well
13:11:13 <sm> I like hakyll a lot too, you could "easily" add a web edit interface for that too
13:12:51 <illissius> fwiw: http://aseigo.blogspot.com/2010/08/making-writing-documentation-enjoyable.html
13:14:31 <sm> reads strangely like something from the last century :)
13:15:24 * sm was a wiki evangelist back in the glorious early days, oh yes
13:16:51 <Axman6> not a wikivangelist?
13:17:07 <dons> mm. seems like haddock could emit documentation coverage information
13:18:14 <ezyang> Haddock is hard to hack on, unfortunately. 
13:18:32 <aristid> and hackage could show that information, so potential users can be warned of libraries that are too much like uu-parsinglib
13:18:38 <sm> maybe it needs a reboot like hackage seems to have got 
13:19:02 <ezyang> I think it's mostly because it expects you to know about GHC internals. 
13:24:34 <chrisdone> hard to hack on? O_o
13:28:31 * ezyang currently annoyed at Haddock 
13:29:08 <chrisdone> ah. what's thee working on on it?
13:29:50 <ezyang> There's no good way to document an API once in a generic module and then refer to that module from specialized versions of that API. 
13:30:28 <chrisdone> for packages like ByteString?
13:30:38 <ezyang> Yeah, that sort of thing. 
13:31:07 <dons>  911m 884m  25m R  100 11.3   2:49.28 haddock
13:31:42 <chrisdone> dons: what's that output from?
13:31:52 <sm> yow
13:31:57 <monochrom> sounds like haddock is annoyed at you too. "why am I given so much work to do?" :)
13:32:21 * sm wonders how many lines of code that is
13:43:24 <firegolfer> Text.XHtml.Strict provides the << operator
13:43:32 <firegolfer> how can I do something like
13:43:47 <firegolfer> (foldl (<<) ulist listentries)
13:44:00 <hpc> :t foldl
13:44:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:44:36 <hpc> @src sequence
13:44:37 <lambdabot> sequence []     = return []
13:44:37 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:44:37 <lambdabot> --OR
13:44:37 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:44:49 <hpc> er
13:45:13 <firegolfer> something has to do ulist << list !! 0 << list !! 1 << ...
13:45:36 <hpc> why doesn't your fold work?
13:45:48 <firegolfer> Occurs check: cannot construct the infinite type: b = Html -> b Probable cause: `<<' is applied to too many arguments
13:46:15 <firegolfer> listentries is [String]
13:46:42 <hpc> :t foldl (<<)
13:46:44 <lambdabot> Not in scope: `<<'
13:46:53 <hpc> @let (<<) = flip (>>)
13:46:54 <lambdabot>  Defined.
13:46:55 <hpc> :t foldl (<<)
13:46:56 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> [m a] -> m b
13:47:00 <mauke> @undefine
13:47:09 <hpc> D:
13:47:10 <firegolfer> its
13:47:19 <firegolfer> (HTML a) => (Html -> b) -> a -> b
13:47:28 <mauke> @let a << b = do x <- a; b; return x
13:47:30 <lambdabot>  Defined.
13:47:51 <Gracenotes> firegolfer: why not use the unordList combinator?
13:47:59 <hpc> mauke: why not the definition i used?
13:48:08 <mauke> because mine is more useful in parsers
13:48:12 <Gracenotes> hm, unless you're intending to chain the unords.. hm
13:48:28 <firegolfer> I have a list, and want to create a ulist ;)
13:48:53 <hpc> oh i see, the order of side effects changes
13:49:08 <Gracenotes> the purpose of the combinators is to make a pretty DSL, not so much to be used in other HOFs
13:49:19 <Gracenotes> but still possible.. somehow..
13:50:47 <firegolfer> ah got it
13:51:00 <dolio> That's going to be weird in, say, 'h =<< n << g =<< f =<< m'.
13:51:07 <firegolfer> ulist << [paragraph << x, x <- listentries]
13:51:15 <mauke> Don't Do That Then™
13:51:59 <dolio> It's also taken the sensible name for that kind of thing.
13:52:16 <Gracenotes> it's also taken !
13:52:17 <dolio> Whereas there's also (<*).
13:52:28 <mauke> << is to >> as <* is to *>
13:52:36 <Gracenotes> firegolfer: ah, you could use map for that as well
13:52:47 <dolio> But not as (=<<) is to (>>=).
13:52:48 <Gracenotes> .. maybe
13:52:52 <osaunders> Is there anything like this already defined?
13:52:53 <osaunders> (&.) :: (a -> Bool) -> (a -> Bool) -> a -> Bool
13:52:53 <osaunders> f &. g = (\x -> f x && g x)
13:52:59 <mauke> that just shows how broken =<< is
13:53:15 <opqdonut> osaunders: (&.) == liftM2 (&&)
13:53:16 <dolio> No it doesn't.
13:54:17 <osaunders> opqdonut: Did I already ask this once?
13:54:31 <opqdonut> not afaik
13:54:57 <opqdonut> of course, if you and predicates a lot, it's useful to give that a name
13:55:31 <Gracenotes> or defined in a where clause, maybe
13:55:43 <opqdonut> > even <^(&&)^> (>9
13:55:44 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:55:45 <opqdonut> gah
13:55:52 <copumpkin> or make a type of predicates
13:56:03 <copumpkin> and then write an instance of something useful for them
13:56:05 <opqdonut> > map (even <^(&&)^> (>0)) [-2..3]
13:56:06 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
13:56:19 <opqdonut> oh, they used to be
13:57:32 <opqdonut> > map ((&&) <$> even <*> (>0)) [-2..3]
13:57:33 <lambdabot>   [False,False,False,False,True,False]
13:57:40 <opqdonut> not quite as compact
13:58:02 <firegolfer> aw crap
14:00:18 <firegolfer> ok
14:00:35 <firegolfer> since now my code now uses also the Html Monad
14:00:38 <firegolfer> everything is broken :(
14:02:57 <firegolfer> how can i go from
14:02:59 <firegolfer> Html
14:03:03 <firegolfer> to CGIT IO Html?
14:03:05 <firegolfer> since
14:03:13 <firegolfer> h1 << "foobar" is now returning html
14:03:14 <opqdonut> return
14:03:39 <firegolfer> does not work
14:03:40 <firegolfer> same error
14:03:58 <opqdonut> which error
14:04:24 <roconnor> Html monad?
14:04:37 <roconnor> firegolfer: what lib are you using?
14:05:56 <Gracenotes> cgi has that monad, right?
14:06:40 <Gracenotes> instance Monad m => Monad (CGIT m)
14:06:43 <firegolfer> Network.CGI and Text.XHtml.Strict
14:06:49 <firegolfer> and it seems $ does not work with two arguments?
14:08:07 <opqdonut> yeah, f $ x $ y is not the same as f x y
14:08:11 <opqdonut> use parentheses
14:08:47 <firegolfer> I have
14:08:54 <firegolfer> walkDir :: FilePath -> CGI Html
14:09:13 <firegolfer> and at the end of walkDir i call createHtml
14:09:24 <firegolfer> which is createHtml :: [FilePath] -> [FilePath] -> Html
14:09:39 <opqdonut> firegolfer: could you please paste the code somewhere
14:09:43 <opqdonut> instead of just describing it
14:09:59 <opqdonut> for example hpaster.org
14:11:12 <firegolfer> http://codepad.org/Rm9oWOOd
14:11:13 <EvanR-work> i like to avoid $ for simple stuff
14:11:24 <firegolfer> anyway...
14:11:30 <firegolfer> without return, with return, without MonadCGI
14:11:32 <firegolfer> nothing works :(
14:11:41 <EvanR-work> its good for things like fooM x y $ \z -> do\n<space><space>
14:13:59 <Gracenotes> because of the precedence of lambdaings
14:14:02 <Gracenotes> or something
14:14:21 <EvanR-work> and do
14:14:41 <ddarius> ezyang: You've the reference to "mainstream languages" but I'd like you to think about what the "Default" type class would look like in say Java or C# or a similar such language.
14:15:12 <EvanR-work> @src Default
14:15:12 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:15:45 <ezyang> ddarius: My feeling would be something like the empty constructor? 
14:16:00 <ezyang> actually, default would be something more like dependency injection 
14:16:22 <BMeph> Object! ;þ
14:16:41 <ezyang> Object = Top :-) 
14:16:44 <EvanR-work> so do i
14:18:17 <Gracenotes> java's primitive types do have different kinds than Object descendants
14:18:24 <ezyang> It's true. 
14:22:13 <firegolfer> can I put something sythetically into IO?
14:22:25 <ezyang> firegolfer: return? 
14:22:48 <c_wraith> maybe liftM, depend on what "something" is.
14:22:56 <firegolfer> Html
14:23:06 <firegolfer> return does not work
14:23:08 <bss03> constAct a b = return a
14:23:16 <firegolfer> Couldn't match expected type `IO Html' against inferred type `Html'
14:23:16 <c_wraith> So what's the type of the function you want?
14:23:16 <firegolfer>     In the expression:
14:23:16 <firegolfer>           return (h1 << ".:[Dirs]:.")
14:23:20 <bss03> :t \a b -> return a
14:23:21 <lambdabot> forall t a (m :: * -> *). (Monad m) => a -> t -> m a
14:23:30 <c_wraith> Sounds like "return" is what you want.
14:23:42 <firegolfer> I want to mix IO, CGI and HTML
14:23:44 <bss03> :t \a -> return a
14:23:45 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:23:51 <firegolfer> well, I don't want to
14:23:53 <firegolfer> but i have to
14:24:02 <Gracenotes> firegolfer: CGIT IO is a monad, so return html has the type CGIT IO Html
14:24:53 <Gracenotes> firegolfer: hm. I think you do need a $
14:25:18 <Gracenotes> remember, function application binds closer than most anything else, including +++
14:25:31 <firegolfer> ups ;)
14:25:39 <Gracenotes> so you'd need return $ a +++ b +++ c, instead of return a +++ b +++ c, which makes the compiler think you're mixing IO Html and HTml
14:25:47 <firegolfer> so
14:25:56 <firegolfer> it returns IO Html now
14:26:07 <firegolfer> but in cgiMain
14:26:12 <firegolfer> it has to be CGIT IO Html
14:26:21 <Gracenotes> well, it returns m Html
14:27:18 <Gracenotes> firegolfer: you know, it would probably be better if createHtml just returned an Html without any modification
14:27:37 <Gracenotes> if the function is pure, don't involve effectful monads unnecessary
14:27:51 <Gracenotes> then on the last line of walkDir, you would have return $ createHtml dirs files
14:27:54 <firegolfer> yes 
14:28:01 <firegolfer> but cgiMain is in the CGI Monad
14:28:02 <firegolfer> and
14:28:04 <firegolfer> walkDir in the IO
14:28:05 <firegolfer> so
14:28:20 <firegolfer> I can't return just Html
14:28:28 <Gracenotes> walkDir looks like it's in CGI to me.
14:29:05 <Gracenotes> return can put something in the CGI monad, or it can put it in the IO monad. it's polymorphic.
14:29:50 <firegolfer> puh.
14:29:53 <firegolfer> so
14:29:57 <firegolfer> walkDir has to be
14:30:02 <firegolfer> FilePath -> CGIT IO Html?
14:30:19 <Gracenotes> it already is
14:30:27 <Gracenotes> the documentation says: type CGI a = CGIT IO a
14:30:47 <Gracenotes> usually there is a transformer monad with T at the end, and the version without T at the end is a specialization of it
14:31:04 <firegolfer> great
14:31:08 <firegolfer> Now it would compile
14:31:14 <firegolfer> if there weren't linker errors
14:32:00 <firegolfer> so
14:32:03 <firegolfer> fixed
14:39:20 <ezyang> Hey guys, I want to be able to write: class forall n. Foo n => Bar a where ... 
14:39:25 <ezyang> Is there a way I can fake this? 
14:40:13 <ezyang> If I put the phantom type in the typeclass, GHC has trouble figuring out that there is an instance of Bar a n for all n. 
14:40:56 <ezyang> Maybe overlapping instances might help... 
14:41:47 <Heffalump> can you make the Foo dictionary a member of the Bar class?
14:41:54 <Heffalump> i.e. wrap it up in a GADT
14:42:16 <ezyang> Hmm, possibly. 
14:42:52 <ezyang> type variables not in scope. 
14:43:03 <Heffalump> what did you try?
14:43:14 <ezyang> data Dup n n2 :: * 
14:44:24 <Heffalump> I don't understand what you were trying to do with that.
14:44:42 <ezyang> Yeah, I don't understand either. 
14:44:47 <ezyang> Let me make a minimal hs file. 
14:45:27 <illissius> ezyang: what's the relationship between n and a? like i assume there is one otherwise there's not much point :)
14:45:43 <ezyang> There is actually none. 
14:45:57 <ezyang> However, I need the variable so that it's in scope. 
14:46:04 <ezyang> I shall demonstrate shortly. 
14:46:33 <illissius> oh, I think I get what you want -- to use n within the class body?
14:46:41 <ezyang> yep 
14:47:04 <Heffalump> I don't get that. If you quantified over it, there's no specific n to use.
14:47:22 <Heffalump> Or are you saying you want to use Foo <something> inside the class body and don't want to expose what something is to the users of the class?
14:50:02 <cydergoth> quick one: putStrLn is only doing an evaluation to whnf. What's the easiest way to fully evaluate the argument to rnf? It looks like there are some functions in Control.Parallel.Strategies to do this?
14:50:18 <illissius> ezyang: it would basically just be a shortcut so you don't have to write 'Foo n =>' before every method def, or is there something else?
14:50:31 <Heffalump> cydergoth: how on earth does it print it without evaluating to RNF?
14:50:42 <opqdonut> well a suitable show instance
14:50:45 <Heffalump> (assuming that everything is printed)
14:51:08 <opqdonut> instance Show Foo where show _ = "Foo"
14:51:09 <opqdonut> :)
14:51:11 <cydergoth> It prints the recursive constructors
14:52:01 <cydergoth> Unless I provide $! in which case it prints the partial result with some constructors 
14:52:02 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29019#a29019 
14:52:22 <ezyang> In practice, branch would use translate and do some non-trivial ops, but that's sufficient to get the error. 
14:52:43 <ezyang> Error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29020#a29020 
14:53:11 <ezyang> Also, in practice there'd be more than one GNT associated type. 
14:53:18 <copumpkin> ezyang: write an instance?
14:53:29 <copumpkin> note that I have no clue what this is :P
14:53:31 <cydergoth> Like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29021#a29021
14:53:34 <copumpkin> but given the error :P
14:53:36 <ezyang> copumpkin: I shouldn't have to, that's the thing! 
14:53:46 <cydergoth> I think that contains un-evaluated functions?
14:54:02 <ezyang> Given that context, I feel like I should be able to get the result GHC says it can't get. 
14:54:24 <copumpkin> how?
14:54:36 <ezyang> Hmmm 
14:54:48 <cydergoth> Ok, looks like I've misread that output, sorry ;-~
14:54:51 <ezyang> I guess, something like, if I have a NetworkMonad m g n, I have a NetworkMonad m g n1 
14:54:58 <illissius> ezyang: when i get errors like that, with n1 and n2 etc., it usually means i need to either add fundeps or use scopedtypevariables
14:54:59 <Heffalump> ezyang: you're not storing the dictionary anywhere.
14:55:15 <illissius> but i haven't expended the brainpower to comprehend your actual problem :)
14:55:43 <Heffalump> you need an existential to do that
14:55:51 <ezyang> Heffalump: Yes! 
14:55:56 <ezyang> But I don't know where to put it. 
14:56:07 <Heffalump> define a GADT outside the class?
14:56:16 <Heffalump> and then have a class member that returns it
14:56:18 <ezyang> Ok, I see. I don't understand what that means :-) 
14:56:29 <ezyang> Hm, that sort of makes sense. 
14:56:34 <Heffalump> ok, I'll try to write it. One sec.
14:57:03 * BMeph thought cydergoth had miswritten that output as well...
14:57:06 <ezyang> So, the GADT acts a sort of function on the type... 
14:57:12 <Heffalump> yes
14:57:27 <ezyang> I'll try too. Let's see who can get it first :-) 
15:00:04 <Poet_> hi all. I am new in haskell. I have a little problem with wx package nad my leksah IDE(IDE said that this package is 'hidden'). Any can help me ? 
15:00:19 <Heffalump> ezyang: where is 'n2' supposed to come from in the definition of test?
15:00:36 <ezyang> Heffalump: It's universally quantified, a phantom type. 
15:00:37 <Heffalump> it seems completely ambiguous
15:00:54 <ezyang> It works ok if you remove the indirection. 
15:00:58 <Heffalump> sure, but it's introduced by return, and eliminated by branch.
15:01:01 <ezyang> It's like s in ST s 
15:01:18 <Heffalump> but there's no operation which takes it as a universal
15:01:23 <ezyang> Hmm. 
15:01:23 <Heffalump> like the Rank 2 in runST does
15:01:44 <Heffalump> so I can't get test to typecheck because I can't specify a type sig for the dictionary you need because I can't pick what n2 should be
15:01:51 <sm> cabal install SDL on mac says "configure: WARNING: unrecognized options: --with-hc", any tips ?
15:01:56 <Heffalump> well, I guess I could actually fix n2 to anything I like.
15:01:58 <ezyang> oh 
15:02:03 <Heffalump> But I don't think that fits with what you actually want.
15:02:11 <ezyang> branch should universally quantify n2 on the first argument 
15:02:30 <sm> oh that's just the warning. What about: General.hsc:60: error: ‘SDL_INIT_CDROM’ undeclared ?
15:02:33 <Heffalump> so the class constraint on Dup n n2 should be inside that quantification too?
15:02:46 <ezyang> Yeah. 
15:03:09 <ezyang> But then it compiles... 
15:03:11 <ezyang> Mysterious! 
15:03:43 <Heffalump> it would, because then the caller has to supply the dictionary
15:03:53 <Heffalump> sorry, not the caller, the implementation of branch
15:04:10 <Heffalump> so now when you try to instantiate Network you'll have the problem
15:04:42 <ezyang> Hmm. 
15:06:12 <ezyang> Yep, looks like it. 
15:06:31 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29022#a29022 
15:06:55 <ezyang> But all I have to do then... is just add a no-op class constraint, and then I think I'm home free. 
15:07:39 <Heffalump> I added some stuff to your paste explaining my general techniauq
15:07:45 <Heffalump> s/techinauq/technique/
15:07:55 <ezyang> Sweet, it worked! 
15:08:35 <Heffalump> I'm not quite sure I understand what you did or why it worked.
15:08:43 <ezyang> Yeah, let me do the updated post. 
15:08:45 <Heffalump> But never mind. If it doesn't actually work out in the end, take a look at what I wrote.
15:08:56 <ezyang> I think the GADT Dict is orthogonal 
15:11:05 <ezyang> Here's an implementation of branch that works: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29024#a29024 
15:11:25 <ezyang> Since I ignore all of the phantom types at this level, I can just add arbitrary constraints 
15:11:50 <Heffalump> hmm
15:11:53 <ezyang> Here's the modified typeclass that checks ok: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29025#a29025 
15:12:06 <ezyang> It sounds like it'll be a pain in the ass to use the generic API manually though. 
15:12:22 <ezyang> But I haven't tried yet. 
15:12:23 <Heffalump> is performNT the same as runNT?
15:13:01 <ezyang> essentially, but without the rank-2 types. 
15:13:10 <ezyang> It's the implementation innards. 
15:13:26 <Heffalump> so what do you think n2 gets instantiated to?
15:13:40 <Heffalump> and where does the dictionary for it appear from?
15:13:40 <ezyang> It stays polymorphic, iuic. 
15:13:49 <ezyang> *iiuc 
15:13:53 <Heffalump> I don't believe that.
15:14:03 <Heffalump> hmm. Maybe I do.
15:14:05 <ezyang> There's a forall in the signature... 
15:14:18 <Heffalump> but I still want to know where the dictionary comes from
15:14:47 <ezyang> I think, since Network is only parametrized on g, the dictionary is obvious from the result type. 
15:15:16 <ezyang> Oh yeah, that's what's happening 
15:15:22 <ezyang> let me paste the instance 
15:15:43 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29026#a29026 
15:15:50 <ezyang> :-) 
15:16:25 <ezyang> So I have a type synonym type NT n a = GNT AIG n a somewhere... 
15:16:40 <ezyang> and AIG gives me the dictionary. 
15:16:52 <Heffalump> that instance is missing branch
15:16:59 <ezyang> yeah, I elided that. 
15:17:06 <Heffalump> that's the important bit..
15:17:09 <ezyang> it's just
15:17:09 <ezyang> branch = B.branch 
15:17:15 <Heffalump> and I don't know what AIG is or why it would give you a dictionary :-)
15:17:20 <ezyang> where B.branch is what I pasted earlier. 
15:17:22 <ezyang> oh, right. 
15:17:29 <ezyang> Well, it's an instance of Network! 
15:17:31 <Heffalump> this is impossible to keep track of because it's all in pieces :-)
15:17:33 <ezyang> so it's 'g' 
15:17:37 <ezyang> Sorry :o) 
15:17:42 <sepp2k1> In parsec what's my neutral element if I want to fold a list of parsers with <|>?
15:17:49 <Heffalump> sepp2k1: mzero
15:18:18 <Heffalump> sepp2k1: at least, that's the canonical netural element of <|> in any MonadPlus/Alternative instance.
15:18:24 <ezyang> Heffalump: I'm looking at your GADT more closly 
15:18:31 <ezyang> So, you're reifying the dictionary? 
15:18:34 <Heffalump> yes
15:18:40 <ezyang> Cool Joe. 
15:18:41 <sepp2k1> Heffalump: Ah, thanks.
15:18:42 <Heffalump> which I think is crucial to expressing the constraint you first asked about.
15:19:29 <ezyang> The feeling I get... 
15:19:49 <ezyang> is that the explicit class constraints in all the functions is acting as a substitute 
15:19:50 <Heffalump> sepp2k1: looking at the Parsec documentation, they're not using the class directly to define <|>
15:19:55 <Heffalump> so you may need to use parserZero
15:20:33 <Heffalump> ezyang: but at some point the dictionary needs to be provided
15:20:46 <Heffalump> anyway. If it's working, all well and good.
15:20:56 <Heffalump> and if you discover it doesn't, you know what to do :-)
15:21:18 <ezyang> I haven't attempted to use the API yet. 
15:21:21 <ezyang> So let's do that! 
15:21:43 <Heffalump> well, I'm going to bed.
15:22:15 <ezyang> g'night! 
15:22:19 <ezyang> Thanks for all the help. 
15:47:53 <ezyang> @msg Heffalump Ooh, I understand what your GADT is doing now! 
15:47:53 <lambdabot> Not enough privileges
15:48:00 <ezyang> wha 
15:48:27 <copumpkin>  you want @tell or @ask
15:48:29 <Gracenotes> that is the sekrit interface used to bring lambdabot to life
15:49:04 <ezyang> @tell Heffalump Ahh, I think I see what your GADT is doing. Now I'm a little skeptical that it works at all :-) 
15:49:05 <lambdabot> Consider it noted.
15:49:06 <Gracenotes> mostly at opportunistic moments, for comedic effect
15:49:13 <lambdabot> Gracenote: your wish is my command
15:49:20 <Gracenotes> o/
15:56:48 <dom96> hello, i am trying to use the OverloadedStrings extension, so that i can use ByteStrings with string literals. I put {-# Language OverloadedStrings #-} at the top of the file and tried :l it with ghci but it doesn't work.
15:56:58 <Heffalump> ezyang: I failed to actually go to bed quite yet :-) What are you skeptical about, your code or mine?
15:56:58 <lambdabot> Heffalump: You have 1 new message. '/msg lambdabot @messages' to read it.
15:57:34 <Veinor> dom96: have you tried LANGUAGE
15:57:36 <Veinor> ?
15:57:45 <dom96> yes
15:57:45 <ddarius> What Heffalump describes will work.
15:57:54 <copumpkin> dom96: "doesn't work" isn't a sufficient description :)
15:58:20 <copumpkin> dom96: have you tried :set -XOverloadedStrings in GHCI?
15:58:27 <copumpkin> (as well as in the file)
15:58:29 <dom96> no
15:58:44 <copumpkin> for some stuff, like NoImplicitPrelude, GHCi doesn't seem to inherit the settings in the loaded file
15:58:48 <dom96> Same thing
15:58:52 <dom96> http://gist.github.com/523680
15:58:54 <ezyang> Well, I'm mostly skeptical in my understanding of what it does. 
15:59:21 <ezyang> Here's a paste of how I've misunderstood: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29027#a29027 
15:59:25 <copumpkin> dom96: what does :t "moo" say?
15:59:37 <copumpkin> I guess it says String
15:59:37 <Veinor> copumpkin: does it work if you compile it?
15:59:51 <dom96> copumpkin: "moo" :: (Data.String.IsString t) => t
15:59:52 <dom96> no
15:59:56 <dom96> well..
16:00:12 <copumpkin> dom96: that's good :P
16:00:27 <dom96> is it?
16:00:30 <copumpkin> dom96: you sure you tried all uppercase LANGUAGE?
16:00:31 <Heffalump> ezyang: your Foo and FooDict are dependent on each other.
16:00:58 <Heffalump> I think you can just resolve the dependency because the instance of Foo is in scope during the definition of the same instance, but it's pointless
16:01:01 <dom96> copumpkin: yes, i have {-# LANGUAGE OverloadedStrings #-} at the top of my files
16:01:15 <ddarius> ezyang: You don't need to change the class that you want to bring in scope, you could use Heffalump's trick for Num, say.
16:01:21 <Heffalump> in fact your default already resolves the dependency
16:02:33 <Heffalump> if you want an example of this in action, in a more complicated setting where the datatype wrapping up the dict is itself an associated datatype, see the rmonad package on hackage.
16:02:36 <ddarius> Eine Woche
16:03:25 <dom96> copumpkin: any other ideas?
16:03:33 <ddarius> The last annotation in this is another example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27220
16:03:33 <ezyang> Heffalump: Is that AsMonad? 
16:04:05 <copumpkin> dom96: nope :/
16:04:08 <ddarius> It is in fact very similar to the scenario you describe, albeit extended to deal with optional support for a class.
16:04:14 <Heffalump> I guess AsMonad does it too, though I was actually thinking of the instances of the Suitable class.
16:04:24 <ddarius> (and not dealing with the universally quantified type parameters)
16:05:11 <dom96> copumpkin: oh well, i'm in the middle of translating everything from String to ByteString, maybe some other errors are interfering or something. I'll just use pack for now. And then i'll try experimenting, thanks for your help.
16:05:16 <ezyang> Hm. 
16:05:37 <ezyang> I think I'm totally misunderstanding what you guys are saying, because I'm thinking about a different problem. 
16:06:02 <Heffalump> I really should go to bed. Hopefully ddarius can explain.
16:06:33 <ezyang> 'gnith! 
16:06:41 <ezyang> *gnight! 
16:06:56 <Peaker> What packages contain a nice Identity type and instances?
16:06:57 * ivanm thinks ezyang might also need to go to bed, if his typos are anything to go by...
16:06:58 <ivanm> ;-)
16:07:05 <ivanm> Peaker: Identity monad do?
16:07:15 <ezyang> It's still 4pm... 
16:07:25 <ezyang> Peaker: I think transformers has one. 
16:07:50 <dom96> copumpkin: yeah, it was my fault. I was using (++) lol.
16:07:58 <Peaker> ivanm, Nah, I want to have a Functor wrapper around something that would sometimes be the Identity functor
16:08:05 <Peaker> ezyang, Ah, thanks
16:08:13 <ezyang> ddarius: Ok, So AFAICT, your paste is just a variation on the (undefined :: SomeType) technique 
16:08:30 <ddarius> ezyang: No
16:08:46 <ezyang> Ok. 
16:08:48 * ezyang rereads 
16:08:55 <ivanm> yeah, mtl has the Identity monad
16:08:59 <ivanm> which sounds like what you want
16:09:08 <ddarius> ezyang: That aspect is actually unnecessary and is just an artifact of my development.
16:09:53 <ezyang> oooh. 
16:10:08 <ddarius> supportsNum could be just Maybe (NumProof a).  At any rate, that aspect isn't very relevant to what you seemed to originally have wanted.
16:10:08 <ezyang> in             Just NumProof -> show (2*a)  you take advantage of the fact that a is Num. 
16:10:14 <ddarius> Yes.
16:10:21 <copumpkin> ezyang: have you checked out rmonad, too?
16:10:39 <ezyang> Not closely, yet. 
16:10:45 <copumpkin> the actual restricted monads aren't what you want, but it does something similar
16:11:43 <ezyang> So, my goal is to understand what Heffalump was getting at with the GADTs 
16:12:01 <copumpkin> I didn't see what he pasted, but given that he's behind rmonad
16:12:13 <ezyang> aha. 
16:12:41 <copumpkin> he was probably exploiting the fact that matching on GADT constructors can actually refine types
16:12:53 <copumpkin> possibly giving you a typeclass dictionary in the process
16:12:53 <ezyang> That makes sense. 
16:12:58 <ddarius> In this particular case, all GADTs are doing is bringing in a local constraint.
16:14:27 <ezyang> So... 
16:14:34 <sepp2k1> @hoogle Monad m => m a -> m b -> m a
16:14:35 <ezyang> I can go from specific -> generic -> specific 
16:14:35 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
16:14:35 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
16:14:36 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
16:14:58 <ezyang> That's handy. 
16:15:12 <ezyang> Now... does that help me out in my original code... 
16:15:20 <copumpkin> sepp2k1: what order do you want the effects?
16:15:58 <copumpkin> (to occur in)
16:16:04 <ezyang> Humm! So instead of tightening the typeclass signature, I use a GADT to get the missing instance. 
16:16:10 <ezyang> I think I understand Huffalumps reasoning now. 
16:16:15 <ezyang> and why he suggested that. 
16:16:15 <sepp2k1> copumpkin: The left operand first than the right.
16:16:26 <copumpkin> :t liftM2 const
16:16:27 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
16:16:31 <ddarius> :t (<*)
16:16:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
16:16:57 <ezyang> But I suspect, given that these are phantom types, that this trick is unnecessary. 
16:17:05 <copumpkin> :t flip (liftM2 (flip const))
16:17:06 <lambdabot> forall a2 a1 (m :: * -> *). (Monad m) => m a2 -> m a1 -> m a2
16:17:11 <ezyang> i.e. all of the types that are giving me problems can eventually be thrown away. 
16:17:20 <copumpkin> :t flip (liftA2 (flip const))
16:17:21 <lambdabot> forall b a (f :: * -> *). (Applicative f) => f b -> f a -> f b
16:17:28 <ezyang> but maybe I'm just babbling to myself at this point :-) 
16:17:35 <copumpkin> (that would be the other order)
16:18:08 <ddarius> :t (<**)
16:18:10 <lambdabot> Not in scope: `<**'
16:18:52 <aristid> :t (*>)
16:18:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
16:19:38 <aristid> :t (<*)
16:19:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
16:19:52 <sepp2k1> copumpkin: ddarius: Thanks.
16:20:48 <ezyang> ddarius: Thanks a bunch for sharing. I bet I'll run into a situation where that will come in handy soon. 
16:23:15 <Gracenotes> > logBase 2 15000
16:23:16 <lambdabot>   13.872674880270607
16:37:01 <ezyang> rmonad does restriction checking at compile time, right? 
16:37:23 <ezyang> If so, I'm a little confused by what I perceive to be partial pattern matches on GADTs 
16:37:59 <copumpkin> ezyang: where?
16:38:10 <ezyang> http://hackage.haskell.org/packages/archive/rmonad/0.5/doc/html/Control-RMonad.html 
16:38:16 <ezyang> case constraints res of                              SetConstraints -> Set.fold (a s' -> Set.union (f a) s') Set.empty s 
16:38:26 <ezyang> couldn't constraints res result in other .... oh no! 
16:38:29 <ezyang> never mind ! :-) 
16:39:11 <ivanm> ezyang: Heffalump has said he has to fix the deps for rmonad
16:39:15 <ivanm> s/deps/docs/
16:39:46 <ezyang> RMonad is very clever. 
16:40:01 <ezyang> I could even see this trick being useful even when you don't need the constraints to need to vary arbitrarily. 
16:42:16 <napping> Is there any way to do nice type-level heterogenous arrays?
16:42:30 <ezyang> napping: What is meant by type level? 
16:42:37 <napping> I guess just a bunch of instances like TCons a (b,c,d) => (a,b,c,d)
16:43:05 <napping> tools for inductively constructing tuples, but not represented as a linked lits
16:43:13 <ezyang> Hmm. 
16:43:16 <ezyang> That would be kind of nice. 
16:43:31 <napping> well, I think it just means making tons of instances of such a TCons
16:43:34 <chrisdone> Baughn: the mailing list seems back up :-)
16:43:37 <ezyang> yes. 
16:43:47 <ezyang> Unless you do something like (a,(b,(c,d)) 
16:43:52 <napping> yeah, but that's linked
16:43:53 <ezyang> which is a linked list anyway. 
16:44:08 <napping> although, not any less efficient at runtime than []
16:44:08 <Baughn> chrisdone: My email is /not/. ;_;
16:44:17 <Baughn> chrisdone: ..say, are you any good at opengl?
16:44:36 <ivanm> Baughn: I notice the haskellmode mailing list seems to be back up...
16:44:38 <napping> Baughn: what are you up to? something else fancy for DF?
16:44:39 <chrisdone> Baughn: no, not used for years
16:44:42 <ivanm> oh, wait, chrisdone just said that :s
16:44:54 <Baughn> napping: Yes. Assuming I can get GL 3.3 to play nice.
16:44:58 <ezyang> Let's say I have a generic function Foo g => g -> g -> Bool. I want to offer a convenience version of this function that makes it easier for users to say "run this function with this particular instance" 
16:45:19 <ezyang> My first thought is to reify instances with a nullary associated data family. 
16:45:22 <ezyang> Does that sound reasonable? 
16:45:47 <napping> why not just fooFun (x :: Ty) y
16:46:04 <ezyang> napping: I never liked that when x == undefined :-) 
16:46:14 <napping> but the signature suggests you have a real g
16:46:28 <ezyang> ah, that's true. 
16:46:28 <napping> so then you might as well just have them quantify it
16:46:37 <ezyang> Ok, so let's say I have a test suite written on the generic version of the coe. 
16:46:49 <ezyang> I can't vary the types without duplicating the code. 
16:46:58 <napping> hmm?
16:47:04 <napping> vary which types?
16:47:21 <ddarius> specializedFoo :: Int -> Int -> Bool; specializedFoo = foo
16:47:26 <ezyang> so maybe I want some list [GImpl g] which specifies the implementations I want to use. 
16:47:31 <ezyang> napping: The types that the function uses. 
16:47:39 <ezyang> ddarius: Fair enough. 
16:47:41 <napping> without duplicating what code, though?
16:48:04 <napping> A generic test should be something like (g -> g -> Bool) -> TestResult, right?
16:48:09 <ezyang> napping: I then have to write (foo :: Int -> Int -> Bool), (foo :: Float -> Float -> Bool) etc. 
16:48:19 <napping> oh, that's a different problem entirely
16:48:24 <ezyang> to pass to that test function :-) 
16:48:38 <ezyang> so I want something a little more compact to write down. 
16:49:44 <ezyang> also, I guess listing those types out means that I need a heterogenous list... 
16:49:48 <napping> nah
16:50:08 <ezyang> hm? 
16:50:30 <napping> hmm, guess you need two levels
16:50:32 <ezyang> I guess I could do [forall g. (g,g,g->g->Bool)] 
16:50:56 <napping> oh, right, you have test values to act as evidence
16:51:02 <ezyang> right. 
16:51:07 <napping> yeah, [forall g . (Foo g) => (g,g,g->g->Bool)] would do
16:51:07 <ezyang> but actually, those are all generic :-) 
16:51:18 <napping> then you want some kind of type tag
16:51:20 <ezyang> ok... 
16:51:25 <ddarius> [Bool] ...
16:51:35 <napping> I'm thinking like data HasFoo = forall a . (Foo a) => HasFoo
16:51:48 <napping> except I'm not sure how to fix the type
16:52:55 <napping> so really more like data HasFoo a where (Foo a) => HasFoo a; data FooInst = forall a . FooInst (HasFoo a)
16:53:38 <napping> then your generic tester gets a type like HasFoo -> (forall t. (Foo t) => ...) -> ...
16:53:50 <napping> and opens like test (FooInst HasFoo) = ...
16:54:05 <napping> the pattern match brining the existential and instance into scope
16:54:09 <alip> what's the most used "ad-hoc solution" (as the guy on cabal ticket puts it) to hook unit tests into cabal? 
16:54:14 <ezyang> Mmm. 
16:54:32 <ezyang> alip: Write a hook that calls your tests. 
16:54:36 <napping> It's probably easier if you have some actual values
16:54:49 <ddarius> napping: You can just write data HasFoo where Foo a => HasFoo a and combine the local constraint and existential.
16:54:54 <Peaker> ezyang, "Foo" lets you make new values of its instance type?
16:55:05 <alip> ezyang: know of any projects that use this method? and where can i learn more about writing cabal hooks?
16:55:29 <Peaker> A type like: forall g. (g, g, ...) is really as impossible (bottom) as (forall g. g)
16:55:30 <napping> if you want to pass actual values, you don't need to invent a phantom type just to have a type parameter that's the instance you want to test at
16:55:33 <ezyang> alip: Cabal hooks are kind of a mess. 
16:56:01 <ezyang> Peaker: Yes. 
16:56:10 <ddarius> He really wanted exists not forall I suspect.
16:56:13 <napping> so more like data TestArgs where (Foo a) => a -> a -> TestArgs
16:56:23 <ddarius> Which is indeed what napping then continued with.
16:56:45 <napping> then you can do [TestArgs (v::Type) v2, TestArgs (v3::Type2) v4, ...]
16:57:13 <napping> although I expect you'd only have to have constraints like that if the arguments are numeric
16:58:14 <ezyang> I'm going to experiment a little. 
16:58:15 <napping> As for my question, I'd like to be able to assemble something equivalent in heap organization to a record value by type level computation
16:58:43 <ezyang> Heap organization? 
16:59:04 <napping> yeah, a header followed by several pointers
16:59:18 <napping> rather than a linked list built from tuples
16:59:41 <napping> I think inductive operations defined over tuples will will work
17:00:15 <ddarius> You can make a strict in snd tuple type and hope unpacking will flatten it suitably.
17:00:17 <napping> many operations will involve ridiculous amounts of repacking the tail into a smaller tuple at -O0, but I hope that would inline away
17:00:34 <napping> I don't think GHC does any data type specialization
17:00:45 <napping> can you unbox single-constructor types?
17:01:16 <Saizan> yes
17:01:47 <dons> Dependencies  base (<1000)
17:01:52 <dons> http://hackage.haskell.org/package/bindings-DSL-1.0.7
17:01:56 <dons> that goes in the hall of shame
17:02:05 <ddarius> dons: Don't you have a package like that?
17:02:12 <dons> then again, "  This package contains no Haskell code, only C header files
17:02:12 <dons>   designed for hsc2hs."
17:02:22 <napping> Saizan: that's nice, the guide promises more than I remember
17:02:38 <napping> pairs and () are single constructor, so it ought to flatten completely
17:03:19 <Saizan> {-# UNPACK #-} works only when the field is a concrete type though
17:03:34 <luite> dons: at least one of your packages doesn't even specify the version of base it depends on
17:03:37 <napping> does (a,b) count?
17:03:51 <dons> luite: i'm sure. i've got about 100 packages, not all of them active.
17:03:58 <dons> patches welcome.
17:04:05 <luite> dons: but this is a real important one, pony
17:04:17 <Cale> haha
17:04:20 <dons> ah!
17:04:32 <medfly> hi
17:04:37 <toki78> hi my freinds
17:04:37 <dons> i've an isabelle proof that shows it is 100% correct.
17:04:45 <toki78> http://tokis-edv-service.de/index.php/beispiele/kuenstliche-intelligenz/pole-balancing-with-a-neural-net
17:04:54 <napping> Baughn: what are you trying to do with OpenGL?
17:04:55 <Saizan> napping: "data Foo a = Foo {-# UNPACK #-} !a" is the same as without the unpack since 'a' is a type variable
17:05:24 <napping> oh, and can that ever specialize?
17:05:30 <ddarius> We need type level inlining hints!
17:05:37 <dons> there  are a lot of binding-* packages now
17:05:42 <luite> dons: does your isabelle proof include induction for abitrary base versions?
17:05:58 <dons> for all possible haskell versions.
17:06:14 <Saizan> no, currently there's no way to make that specialize
17:06:15 <dons> by induction on the structure of the report
17:06:20 * ddarius contemplates a modal logic for Haskell packages.
17:06:28 <dons> mm
17:06:30 * ddarius wonders what the accessibility relation would be.
17:06:39 <dons> hmm. a stability logic
17:07:03 <CakeProphet> a logical logic
17:07:03 <Saizan> hence discussions on ghc-users about doing a weird and boilerplatey dance with associated types to get it :)
17:07:15 <ddarius> Actually, the accessibility relation might be the versioning poset.
17:08:20 <napping> Saizan: how about with associated data?
17:08:31 <napping> ah, I haven't been following ghc-users recently
17:08:37 <Baughn> napping: Sticking most of the tile processing in shaders. Oh, and making those shaders Awesome(tm).
17:08:48 <napping> oh, shaders.
17:09:07 <ddarius> (tm) is a trademark of TM Inc.
17:09:15 <ivanm> dons: do you know if ghc-core works with the new version of pcre-light?
17:09:15 <napping> I'm haven't really used those much (made a perspective-correction thing for a torus with them once)
17:09:17 <ivanm> ddarius: :o
17:09:23 <dons> ivanm: hope so.
17:09:33 <dons> ivanm: can't see why not.
17:09:39 <napping> wait, what kind of tile processing?
17:09:57 <napping> this is just trying to render a tileset if it's DF, right?
17:10:02 <ivanm> dons: well, you haven't specified bounds on the version used, but you've made the new version of pcre-light have a new major version number ;-)
17:10:16 <dons> it probably should have been a minor bump, since it only added 1 function
17:10:27 <dons> however, its feeling 'stable'
17:10:33 <ivanm> *tsk, tsk*
17:10:39 <dons> i need a PVP tool to compute these.
17:10:59 <dons> make version numbers automatic and inferred, not something i have to think of.
17:11:07 * chrisdone nods in agreement
17:11:21 <napping> Saizan: I'm trying something is associated data types, so the strict part will *not* be a type variable in the instances
17:11:21 <ddarius> If such a tool existed, it's outputted proof would be a better version number than the version number.
17:11:43 <ivanm> ddarius: except who wants to specify a large proof file as a constraint in their .cabal file? :p
17:12:31 <dons> we could do with an algorithm for converting sets of module interfaces into the package version #.
17:12:34 <Saizan> dons: you may want to declare "judy" and "stream-fusion" deprecated or similar then :)
17:12:34 <dons> then we'd be able to write a tool
17:13:43 <ezyang> Broke inference in two places. annoying. 
17:13:50 <ezyang> I bet the GADT trick will help. 
17:14:30 <ivanm> dons: what, you want to use some kind of hash-like value (calculated on the API) as a version number?
17:14:31 <chrisdone> dons: it would use these criteria? (1) symbols and their types, (2) typeclasses and instances
17:14:51 <ivanm> chrisdone: instances would be the tricky one...
17:15:08 <ivanm> actually, I've been asked to export the call-graph part of SourceGraph out
17:15:13 <dons> ivanm: no. it isn't a hash. its the PVP. so x.major.minor
17:15:13 <ivanm> I wonder if that would help
17:15:15 <Saizan> napping: http://www.haskell.org/pipermail/glasgow-haskell-users/2010-August/019052.html
17:15:19 <dons> computed properly though via analysis of the package API
17:15:21 <ivanm> wait, I throw away the type sigs... dammit
17:15:30 <ddarius> A content-based address into the world of all possible APIs.
17:15:34 <chrisdone> seems like that *would* at least avoid build failures, even if runtime failures aren't covered 
17:15:46 <ivanm> and you really need to use ghc-api or some such to derive type sigs for code that doesn't specify them
17:15:56 <dons> or .hi files
17:16:00 <ivanm> chrisdone: *nod* most of them, anyway
17:16:02 <dons> you can rip it all from the .hi files
17:16:20 <ivanm> dons: hmmm.... would be nice to have a pure source PVP checker though
17:16:28 <ivanm> rather than having to compile it and _then_ analyse it
17:16:30 <napping> Baughn: a vertex shader?
17:16:57 <Baughn> More of an infrastructure for supplying vertex and fragment shaders with tilesets.
17:17:16 <napping> multiple?
17:17:40 <napping> I'm thinking a vertex shader that reads one byte and sets texture coordinates into the tileset atlas
17:17:57 <Baughn> Dropping the tileset atlas. That's what texture arrays are for. :P
17:18:08 <ivanm> dons: anyway, I did as you suggested and emailed libraries@ regarding having Graph as a new top-level namespace; I got 1 for yes, 1 for no, 1 for package-specific namespacing and 1 for "just update fgl"
17:18:43 <Baughn> napping: http://www.bay12forums.com/smf/index.php?topic=53180.msg1481920#msg1481920 <- It's awfully off-topic in here, but there's a rather long-winded discussion about it on the last dozen or so pages here. Read that if you're curious. ;)
17:19:02 <Saizan> chrisdone: if any package follows the PvP then deps like major.minor.* are safe, and it's quite easy to write a tools that check if a package is following the PvP
17:19:10 <napping> Baughn: well, the OpenGL bindings do seem to cover at least some of shaders
17:19:34 <Saizan> chrisdone: but examples of "base < 10" seems to indicate that people don't want to stick to deps like major.minor.*
17:19:47 <chrisdone> Saizan: true, easy to check if two packages are compatible
17:19:48 <ivanm> Saizan: well, they're safe if you do explicit imports or qualified imports
17:20:00 <chrisdone> ivanm: does that matter?
17:20:05 <ivanm> since in a.b.c.d, if c is bumped then you could have a new function
17:20:12 <ivanm> that clashes with a function you yourself have defined
17:20:27 <chrisdone> ah, true
17:20:32 <ddarius> ivanm: Then you deserve what you get.
17:20:36 <ivanm> ddarius: heh
17:20:38 <napping> Baughn: well, texture arrays prevent you from using the fixed-function fragment stage
17:20:43 <Saizan> yeah, safe with explicit imports.
17:20:53 <Baughn> napping: That's fine with me.
17:21:11 <ivanm> but yes, "base < 10" pisses me off
17:21:35 <ivanm> I've seen packages that had "base < 5" break when using base-4...
17:21:54 <ddarius> ivanm: You don't think base will manage to stay the same enough for, extrapolating, the next 30 or so years?
17:22:04 <chrisdone> I do as cabal check tells me and write base>=4 && < 5
17:22:07 <ivanm> ddarius: base-3 to base-4 broke a lot of packages...
17:22:27 <ivanm> chrisdone: or use extensible-exceptions and have base >= 3 && < 5
17:22:35 * ddarius thinks the silliness of his comment was lost on ivanm.
17:22:39 <Saizan> though there are reasons for wanting ranges that are larger than "major.minor.*" i can only accept those that talk about already released versions as serious :)
17:22:41 <napping> oh, I see talk of fancy 3d stuff
17:22:45 <ivanm> unless you need specific features that were introduced in 6.10 (e.g. type families)
17:22:52 <ivanm> ddarius: obviously not ;-)
17:22:57 <napping> like, perhaps, computing Z in the fragment program. Fancy
17:23:39 <chrisdone> dons: how's the new server/wiki/etc coming along? what's the word?
17:23:47 * ivanm -> breakfast
17:24:08 <msieradzki> Z in PS is not fancy just slow :)
17:26:02 <Baughn> msieradzki: It should be passable for these purposes.
17:26:04 <napping> Saizan: darn, I though John was building up to a solution :(
17:26:06 <adnap> How should I organize my file structure for a Haskell project?  If I have two modules in two different folders in the same directory, how do I import one module from within the other?
17:26:52 <dolio> Foo.Bar.Baz can be in Foo/Bar
17:26:58 <Baughn> adnap: The module Foo.Bar.Baz should always be Foo/Bar/Baz.hs
17:27:06 <dolio> And still import Foo.Quux.Quuux from Foo/Quux
17:27:53 <chrisdone> and remember, Always Import Explicit or Qualified
17:27:57 <adnap> Baughn: I know that part.  But what if I have Foo/Bar/Baz.hs and Goo/Gar/Gaz.hs where Foo and Goo are in the same directory, and I want to import Baz in Gaz?
17:28:07 <adnap> lol
17:28:17 <Baughn> adnap: 'import Foo.Bar.Baz' should work.
17:28:38 <chrisdone> is there a GHC warning that tells me I forgot to import explicit/qualified?
17:28:44 <adnap> Baughn: GHCI doesn't seem to know how to search up directories.
17:28:56 <chrisdone> if not I might add it as an option to hlint, or just as an elisp script
17:28:57 <adnap> Baughn: Or I'm doing something wrong.
17:29:05 <Peaker> chrisdone, closest thing is -ddump-minimal-imports
17:29:07 <Baughn> adnap: Well.. Try 'cabal unpack AES'.
17:29:10 <chrisdone> adnap: how are you running it?
17:29:13 <chrisdone> Peaker: oo, thanks
17:29:24 <Baughn> adnap: Get an example you can look at. ;)
17:29:27 <Saizan> napping: heh, no, and honestly i think associated datatypes are quite the wrong tool, from the haskell side those definitions are actually perfectly parametric, we're are artificially making them ad-hoc just so something we don't have access to can do its job
17:29:50 <adnap> Baughn: Yeah, I guess I need to try again, since everyone agrees that it works.
17:29:56 <Baughn> adnap: Oh, but chrisdone is right. You need to open it by its /complete/ path in ghci, so "ghci Goo/Gar/Gaz.hs", not just ghci Gaz.hs
17:30:02 <Saizan> napping: a {-# SPECIALIZE .. #-} for modules would make more sense to me
17:30:06 <adnap> Baughn: Oooh
17:30:15 <chrisdone> Peaker: oh wow. this is awesome!!!
17:30:16 <adnap> Baughn: That's why it didn't work probably.
17:30:28 <adnap> Baughn: I just did ":l Gaz.hs"
17:30:39 <Peaker> chrisdone, :-)
17:30:52 <Peaker> chrisdone, Simon Marlow said they use unqualified open imports to avoid merge conflicts! :-(
17:30:57 <Peaker> Stupid textual heritage to programming
17:31:26 <ezyang> The monomorphism restriction strikes again! 
17:31:30 <ezyang> dun dun dun 
17:31:37 <Peaker> The MR must die
17:31:58 <Peaker> Non-transparent operational semantics are all over Haskell, yet only this behavior is weird for it
17:32:59 <ezyang> Though, it would be occasionally useful to say "this type is monomorphic" but not say waht it is completely. 
17:33:43 <Peaker> ezyang, I think the relationship between memoization and name binding ought to be disconnected and annotations should be used instead
17:33:56 <Peaker> (This would take away the motivation behind the MR, iiuc)
17:34:00 <ezyang> Peaker: Mmm... I'm not sure I agree. 
17:34:09 <ezyang> You can explicitly write out sharing using monads :-) 
17:34:18 <chrisdone> Peaker: holy crap this is totally awesome. I am going to integrate this into emacs somehow
17:34:35 <Peaker> chrisdone, I would *love* auto-import-updates as I edit my code
17:34:48 <napping> Peaker: it's about dictonary passing, not memoization
17:34:50 <chrisdone> definitely! 
17:34:56 <Peaker> chrisdone, Something like: Ctrl-space, start "hoogling" a name from any module, then emacs putting the import on top automagically
17:35:07 <napping> I guess that's what you'd want to describe with an annotation?
17:35:10 <chrisdone> Peaker: what about etags? I've been fiddling with that recently
17:35:45 <Peaker> napping, I don't agree it's about dict passing.. If no dict is passed, how is that different from a dict being passed? (btw: Who says dict passing is how it is implemented?)
17:35:58 <Peaker> chrisdone, I hate etags (because of it's really crappy way of handling C and C++)
17:36:00 <chrisdone> Peaker: then again hoogle / etags doesn't make a difference as long as it knows what to import
17:36:03 <Peaker> chrisdone, maybe etags is better for emacs
17:36:10 <Peaker> s/it's/its
17:36:18 <Peaker> Oops, better for Haskell :)
17:36:21 <Peaker> I ought to go to sleep soon
17:36:49 <chrisdone> Peaker: I ran hasktags on all my installed packages and it works pretty well. can always work better though ;-)
17:37:17 <Peaker> chrisdone, in C etags uses really ugly regexps (I presume, or some other faulty parser) that catch "90%" of the cases
17:37:19 <Peaker> chrisdone, 
17:37:20 <dom96> is there anyway to get the build time of a program, is there some special variable i could access?
17:37:42 <dom96> build date & build time
17:37:44 <Peaker> chrisdone, if you have a typedef of a function type and have a function prototype like:  some_func_type f;  and the body is elsewhere, etags will jump to the prototype
17:38:21 <chrisdone> Peaker: yeah, hasktags does that. hothasktags uses haskell-src-exts, but that kind of failed parsing a few files this morning, and I don't think it does etags, but that can be added
17:38:34 <dh__> good morning , I have a problem with ghci, X11 on Mac OSX, can't load .so/.dll for: x11
17:38:46 <Saizan> dom96: you could use some TH
17:39:04 <dh__> I've googled , and added DYLD_LIBRARY_PATH, but it has no use. 
17:39:08 <dh__> any help? thanks.
17:39:42 <chrisdone> Peaker: did you see my emacs stuff recently? http://projects.haskell.org/pipermail/haskellmode-emacs/2010-August/000083.html
17:39:46 <dom96> Saizan: oh, thanks.
17:40:43 <Peaker> chrisdone, Seen a presentation that seemed very cool :)
17:40:58 <dom96> Is there no easier way of doing this? Using TH seems a little complicated
17:41:14 <Peaker> night!
17:41:18 <chrisdone> Peaker: ciao!
17:42:52 * chrisdone also beds
17:43:44 <napping> Saizan: it seems splitting instances to Cons a () and Cons a (Cons b rest) just inlines into a Consa() a and ConsaCons a b rest
17:45:09 <aristid> @hoogle merge
17:45:09 <lambdabot> Data.Graph.Inductive.Internal.Heap merge :: Ord a => Heap a b -> Heap a b -> Heap a b
17:45:10 <lambdabot> Data.Graph.Inductive.Internal.Heap mergeAll :: Ord a => [Heap a b] -> Heap a b
17:45:10 <lambdabot> Text.Parsec.Error mergeError :: ParseError -> ParseError -> ParseError
17:49:32 <Saizan> napping: disappointing, but that's the same problem of not being able to handle any abstraction
17:50:12 <napping> yes, I suppose it could be used with the tail known only by a class constraint
17:50:30 <napping> for my needs, type families for inductive operations on tuples should do
17:50:34 <napping> type synonyms, that is
17:56:59 <aristid> is this function readable? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29036#a29036
17:57:10 <bss03> @hoogle bracket
17:57:10 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:57:10 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:57:10 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:01:39 <Saizan> aristid: why not "merge . map (enumFromThen 0) . S.toAscList" ?
18:02:42 <adnap> If my directory looks like Test/Foo.hs Test/Test01/Main.hs, with modules Test.Foo and Test.Test01.Main, why can't I import Test.Foo in Test.Test01.Main?
18:04:55 <aristid> Saizan: yeah, i think that's a good suggestion
18:05:16 <Cale> adnap: Is there an appropriate module declaration in Test.Foo?
18:05:24 <Saizan> anyhow it's quite readable but it'll use a linear amount of stack
18:08:10 <Saizan> adnap: the error message, at least with -v, it'll tell you which files are searched when it tries to find the source for Test.Foo
18:08:25 <aristid> Saizan: linear to the size of the set?
18:08:46 <Saizan> aristid: yes
18:08:59 <aristid> Saizan: is there a way to reduce the complexity / stack consumption?
18:11:20 <Saizan> aristid: i'd think so, but i don't have specific a way in mind, the problem is that you are doing a foldr with a function (merge2) which is strict in its second argument
18:12:10 <Saizan> ("specific a way"? i should really go to bed)
18:12:49 <aristid> would foldl' improve this?
18:14:53 <napping> "cabal: There is no installed version of base
18:15:00 <napping> do I *have* to depend on base?
18:15:12 <aristid> napping: yes.
18:15:26 <napping> but I said NoImplicitPrelude
18:15:29 <aristid> oh
18:15:34 <aristid> don't know then
18:16:04 <luite> does anyone know a javascript or flash application for adding 3d plots (similar to Mathematica's Plot3D) to a page? (such that the user can rotate them in his browser)
18:17:11 <napping> I forgot --user
18:18:57 <dh__> Hello, any body knows how to solve the x11 dll cannot be found with ghci problem?
18:20:21 <hpc> x11 as in the X window system?
18:20:26 <dh__> yes. 
18:20:35 <hpc> becuase that's linux only
18:20:39 <dh__> Loading package X11-1.5.0.0 ... can't load .so/.DLL for: X11 (dlopen(libX11.dylib, 9): image not found)
18:20:42 <hpc> and dlls are windows only
18:20:52 <hpc> ah
18:21:09 <dh__> it's .so, on Mac OS X , 10.5.8
18:23:05 <dons> dh__: dll? your on windows?
18:23:08 <dons> on the mac?
18:23:15 <dh__> I'm on a mac. 
18:23:27 <dons> do you have the C libraries and headers for X11 installed?
18:23:47 <dons> /usr/include/X11/* ?
18:23:54 <dons> or the Mac equivalent
18:24:09 <dh__> dons: I have /usr/include/X11
18:25:26 <aristid> mac os x has X11 support
18:25:33 <dons> you'll need to find libX11.dylib
18:25:42 <dh__> and I have DYLD_LIBRARY_PATH=/usr/X11R6/lib
18:25:59 <aristid> dh__: the compile time linker ignores that env var
18:26:04 <aristid> probably
18:26:44 <dh__> I can compile and run the code with ghc, but not ghci
18:27:32 <dh__> GOA> import Graphics.X11.Xlib.Display 
18:27:32 <dh__> GOA Graphics.X11.Xlib.Display> let d = openDisplay ""
18:27:32 <dh__> Loading package X11-1.5.0.0 ... can't load .so/.DLL for: X11 (dlopen(libX11.dylib, 9): image not found)
18:27:54 <adnap> Saizan: When do I type -v?
18:28:08 <adnap> Saizan: When I lauch GHCI?
18:28:27 <napping> hmm, cabal-install seems to insist on having a version of base
18:29:31 <adnap> Saizan: Ah, yes.
18:30:45 <dh__> I don't like the idea of letting each package evolving independently , 
18:31:20 <dh__> I mean : when package A upgrade to a new version, it's might break other package B . 
18:32:02 <dh__> I prefer python's release  method.  there is only a few release, and everything is tested.
18:32:46 <napping> darn, type synonyms may not be injective
18:33:56 <napping> I made a type function Cons so e.g. Cons (a,b) x ~> (x,a,b)
18:34:16 <napping> but then hd and tl fall down on injectivity
18:48:52 <zuwiki> Really quick question, and I'm sorry if it's offensively simple: can a module contain other modules, and is the syntax equivalent to exporting a function in the module, i.e. putting the name of the included module in the parentheses after 'module'?
18:49:12 <zuwiki> I would try it out, but I'm busy right now and desperately curious.
18:49:32 <hpc> module ExportPrelude (module Prelude) where import Prelude
18:49:32 <roconnor> zuwiki: no
18:49:39 <roconnor> zuwiki: modules can import other modules
18:49:47 <roconnor> and reexport those imported modules
18:50:00 <roconnor> but modules themselves cannot directly contain other modules inline.
18:50:23 <hpc> a common practice is to have a folder and .hs file with the same name
18:50:35 <hpc> with the .hs file exporting convenient modules inside the folder
18:50:54 <zuwiki> Aha! Thanks for the answers. That clears that up nicely. I like it.
18:51:17 <roconnor> hps is shows how to export and imported module.
18:51:22 <roconnor> hps is shows how to export an imported module.
19:13:27 <ddarius> I think I could have given David Spivak's talk a bit better than he did.
19:14:31 <monochrom> @bots
19:14:32 <lambdabot> :)
19:14:47 <monochrom> @vixen give us a talk
19:14:48 <lambdabot> Uh-huh
19:14:55 <monochrom> @vixen give us a spivak talk
19:14:55 <lambdabot> there is nothing going on in your pants that the dictatorship of the proletariat will not solve
19:15:26 <aristid> @vixen monochrom
19:15:26 <lambdabot> eh?
19:20:24 <drhodes> there are a few date time libraries, anyone know if one is preferred over another?
19:20:50 <roconnor> drhodes: just use the standard Data.Time
19:20:52 <Gracenotes> Data.Time is the official-ish one
19:20:59 <drhodes> ok, thanks guys.
19:21:00 <roconnor> drhodes: AFAIK the rest are broken wrappers
19:21:04 <monochrom> I just use time-1.1.4. It's what comes with haskell platform.
19:21:13 <Gracenotes> Data.Time.Clock has getCurrentTime
19:21:35 <aristid> drhodes: Data.Time is not bad
19:21:55 <typemore> how do I get the first N elems of a list?
19:22:07 <monochrom> take n
19:22:35 <typemore> waht's the opposite of take
19:22:39 <typemore> i.e. the last N elems ?
19:22:48 <roconnor> drop
19:22:51 <roconnor> er
19:22:57 <roconnor> there is no such thing
19:22:59 <typemore> drop = all except first N
19:23:10 <monochrom> drop (length it - n) it
19:23:16 <roconnor> don't use lists, use seq
19:23:22 <roconnor> or use snoc lists
19:23:44 <ddarius> snoc lists = cons lists the "difference" is conceptual
19:24:20 <monochrom> I wouldn't call it conceptual difference. I would call it point-of-view difference.
19:24:22 <ddarius> (Of course formalizing the difference with a newtype would be useful for generic functions.)
19:24:39 <roconnor> ddarius: I wrote a Backwards wrapper for traverse
19:24:46 <monochrom> In fact, point of view, view, ...
19:24:46 <ddarius> roconnor: Exactly.
19:25:12 <ddarius> type SnocList a = Backward [a]
19:25:33 <typemore> how do I take a type, keep it the same, except replace one elem?
19:26:10 <monochrom> I don't understand the question.
19:32:07 <typemore> is there a function that takes two lists [a1 a2 a3 ..] and [b1 b2 b3 ...] and returns [f a1 b1, f a2 b2, f a3 b3 ...] ?
19:32:19 <roconnor> typemore: zipWith f
19:32:21 <monochrom> zipWith f
19:32:46 <monochrom> > zipWith f [a,b,c] [x,y,z]
19:32:47 <lambdabot>   Ambiguous type variable `c' in the constraints:
19:32:47 <lambdabot>    `GHC.Show.Show c'
19:32:47 <lambdabot>      a...
19:32:56 <monochrom> nevermind
19:33:14 <aristid> > zipWith f [a,b,c] [x,y,z] :: Expr
19:33:15 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
19:33:15 <lambdabot>         against inferred ...
19:33:25 <aristid> what's wrong with that?
19:33:28 <typemore> > zipWith + [1, 2, 3] [4, 5, 6]
19:33:29 <lambdabot>   Couldn't match expected type `t
19:33:30 <lambdabot>                                -> (a -> b -...
19:33:34 <typemore> err, why doesn't that work?
19:33:41 <roconnor> zipWith (+) [1, 2, 3] [4, 5, 6]
19:33:42 <aristid> typemore: missing parentheses
19:33:46 <roconnor> > zipWith (+) [1, 2, 3] [4, 5, 6]
19:33:46 <lambdabot>   [5,7,9]
19:34:23 <roconnor> > f a x :: Expr
19:34:24 <lambdabot>   f a x
19:34:48 <roconnor> > zipWith f [a,b,c] [x,y,z] :: [Expr]
19:34:49 <lambdabot>   [f a x,f b y,f c z]
19:37:21 <catenate> So Expr just says "don't evaluate this thunk?"
19:37:39 <hpc> Expr says "show what it looks like as function calls"
19:37:47 <hpc> it's part of lambdabot
19:38:19 <catenate> ah.  I was hoping it was like setq and let you play with programs as text
19:39:17 <hpc> there's a lot of non-standard stuff in lambdabot
19:39:18 <typemore> roconnor , aristid : thanks
19:43:10 <Kaidelong> so just to check that I understand:
19:44:04 <roconnor> catenate: Expr is a data type.
19:44:23 <roconnor> Expr is a number type that has formal variables
19:44:38 <Kaidelong> Strict means "for all functions, if the parameter is bottom the value returned is bottom"; Non-strict is "there exists a function which when given bottom returns something other than bottom" and total means "for all arguments, if a function returns bottom that argument is bottom"
19:45:20 <roconnor> > x + t
19:45:21 <lambdabot>   x + t
19:45:29 <roconnor> > x^2
19:45:30 <lambdabot>   x * x
19:45:54 <catenate> @let x = 2
19:45:55 <lambdabot>  Defined.
19:46:04 <catenate> > x ^ x
19:46:05 <lambdabot>   Ambiguous occurrence `x'
19:46:05 <lambdabot>  It could refer to either `L.x', defined at <local...
19:46:09 <roconnor> Kaidelong: a function is strict when it maps bottom to bottom
19:46:23 <roconnor> Kaidelong: a function is not strict when it maps bottom to non-bottom
19:46:35 <catenate> > L.x ^ L.x
19:46:37 <lambdabot>   4
19:47:02 <Kaidelong> ok, then I think I have it down
19:47:23 <catenate> roconnor: so lambdabot kept it symbolic because it didn't have a binding for x?
19:47:40 <Kaidelong> is there any work with using total functional programming in haskell?
19:47:40 <aristid> > x^x
19:47:41 <lambdabot>   Ambiguous occurrence `x'
19:47:41 <lambdabot>  It could refer to either `L.x', defined at <local...
19:47:44 <roconnor> catenate: x is defined to be something like Var "x"
19:47:46 <aristid> > x^x :: Expr
19:47:47 <lambdabot>   Ambiguous occurrence `x'
19:47:47 <lambdabot>  It could refer to either `L.x', defined at <local...
19:47:50 <roconnor> @undef
19:47:57 <roconnor> > x^x :: Expr
19:48:03 <lambdabot>   mueval: ExitFailure 1
19:48:10 <Kaidelong> IE disallowing functions that aren't equivalent to total turing machines
19:48:31 <roconnor> Kaidelong: usually people use Agda or Coq or such
19:49:11 <Kaidelong> hmm, I didn't like Coq, does Agda have haskell like syntax?
19:49:25 * Kaidelong has been looking into ACL2, which is in the same vein
19:49:38 <Kaidelong> well learning at this point
19:50:08 <applicative> Kaidelong, Agda is sort of haskelly as far as can be.  You have to write in emacs to get the effect...
19:51:51 <applicative> who would have thought that totality would require such a thing?...
19:52:15 <dolio> Require what?
19:52:30 <applicative> studying emacs...
19:52:42 <dolio> There are people who write Agda in vim.
19:52:59 <applicative> oh really. 
19:53:32 <dolio> There's certainly nothing stopping you.
19:53:41 <applicative> there's a fair number of bells and whistles in agda mode
19:53:55 <catenate> But emacs has a totality of all possible editing functions, and most things you'd find in an OS, or at least a Lisp Machine. I present, for your consideration, M-x butterfly.
19:54:01 <dolio> Yes, it actually makes writing Agda nicer than writing Haskell.
19:54:24 <dolio> I miss being able to fill in holes with type information.
19:54:39 <applicative> dolio, yes, it's very pleasant. 
19:54:40 <catenate> That said, I prefer Acme
19:55:55 <applicative> M-x butterfly is doing nothing for me.  
19:56:05 <catenate> How do I avoid specifying my type info in every property?  Eg: prop_commutative x y = add x y =? add y x where types = x :: Int
19:56:30 <catenate> http://www.xkcd.com/378/
19:56:35 <typemore> > sort ["", "a", "c", "b"]
19:56:36 <lambdabot>   ["","a","b","c"]
19:56:52 <applicative> hah, i see. I don't have to look.
19:59:42 <BMeph> So, just curious: does anyone still smile a little when hearing an US person call the lasy letter "zee"?
19:59:56 <Kaidelong> applicative: well I was wondering if total functions could by typed in haskell (and if someone had done it)
19:59:57 <BMeph> *last
20:00:12 <Kaidelong> err, typed specifically as total
20:00:18 <Kaidelong> and only when they are
20:00:41 <dolio> It's certainly not a simple addition.
20:00:47 <Kaidelong> not to the language
20:01:08 <dolio> You need different rules for defining datatypes.
20:01:17 <dolio> A termination checker for function definitions.
20:02:11 <BMeph> Don't you need dependent types, just to specify the domains enough for total functions?
20:02:40 <dolio> You don't need dependent types. You could have a total language without them.
20:02:45 <syntaxglitch> just don't include primitive recursion
20:02:47 <syntaxglitch> problem solved
20:02:48 <dolio> Charity is total, for instance, and doesn't have dependent types.
20:04:05 <BMeph> Interesting...so, it has a type just for positives (integers and reals)?
20:04:20 <BMeph> Well, two types, I guess.
20:05:22 <dolio> You mean, for stuff like n / 0?
20:05:30 <syntaxglitch> hm
20:05:35 <dolio> Worst case, you can return a Maybe.
20:05:59 <BMeph> dolio: For integers, "pred" would need it, wouldn't it? ;)
20:06:12 <applicative> @type pred
20:06:15 <lambdabot> forall a. (Enum a) => a -> a
20:06:52 <BMeph> > pred (0::Word)
20:06:53 <lambdabot>   *Exception: Enum.pred{Word}: tried to take `pred' of minBound
20:07:02 <BMeph> E.g.
20:07:21 <applicative> the paper by Turner tries to describe a simple Haskelly language which would deal with things consistently with totality, e.g. 'head'
20:07:22 <ddarius> > 0 - 1 :: Word
20:07:23 <lambdabot>   18446744073709551615
20:07:56 <applicative> I can't remember what he says about 3/0, but he takes a position.  I think it's 0 ?
20:08:12 <ddarius> applicative: Yes, that is what I recall.
20:08:13 <dolio> I think that's what he says. I'm not wild about that definition.
20:08:23 <ddarius> Me neither.
20:08:30 <BMeph> That's kind of demented... :\
20:08:49 <ddarius> Incidentally, you could have a non-zero integer type and a function Integer -> Maybe NonZeroInteger
20:08:50 <dolio> 0 - 1 = 0 is slightly less terrible.
20:08:54 <applicative> it seems strange with real numbers... but then the way they will be handled will no doubt be very different
20:09:14 <aristid> Word is one of the module algebras, i think
20:09:14 <ddarius> Ultimately, though, you are going to want to be propagating failures upward all the type, Maybe monad-like.
20:11:09 * BMeph likes that 'head' and 'tail' are explicitly defined as working on non-empty lists in OBJ...
20:11:44 * applicative wonders, what's the head of [] :: [Int] ?
20:12:05 <dobblego> 7
20:12:17 * ddarius should actually try programming in an OBJ-family language instead of just reading about them some time.
20:12:17 <dolio> At least with all your partial functions returning maybe, no one will write spoon. :)
20:14:18 <pikhq> applicative: _|_
20:14:19 <pikhq> :)
20:14:30 <ddarius> _|_ :: Partial a
20:15:28 <aristid> what's the type of fix id`
20:15:43 <applicative> what's the type of id?
20:16:02 <ddarius> id`
20:16:24 <dolio> What's the type of tail ('x', 7)?
20:16:33 <aristid> ddarius: ` should have been ?
20:16:53 <applicative> tail ('x',7) doesn't exist, otherwise I would answer.
20:19:10 <JoeyA> dolio: tail takes a list.  What you gave is a tuple.
20:19:35 <applicative> dolio knows his tuples
20:19:44 <dolio> If we're still talking about total languages, then fix id has the same problem.
20:19:55 <dolio> Presumably.
20:20:02 <dolio> Or else fix doesn't exist.
20:20:45 <applicative> of course it doesn't exist  .... (a -> a ) -> a ?
20:20:58 <dolio> Not with that type, certainly.
20:21:17 <BMeph> That reminds me of the clever construction in Habit...I like that. :)
20:23:28 <BMeph> Spwcifically, the Pointed class.
20:23:46 <BMeph> Geez...*Specifically
20:24:47 <medfly> :t (fix id)
20:24:50 <lambdabot> forall a. a
20:25:03 <applicative> some type there...
20:28:15 <tolkad> Why is this so poorly documented? it doesn't say what "s" and "a" are: http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector-Unboxed-Mutable.html#t%3AMVector
20:29:31 <applicative> 'mutable vectors ... keyed to the monad they live in....
20:29:59 <tolkad> but... what do the "s" and "a" type parameters represent?
20:30:01 <applicative> http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/src/Data-Vector-Mutable.html#MVector
20:30:46 <applicative> for IOVector, we learn that it's: type MVector RealWorld....
20:31:02 <tolkad> what's RealWorld?
20:31:09 <tolkad> maybe it's in the haskell standard... brb
20:31:27 <applicative> I think RealWorld isn't in the Haskell standard.
20:31:35 <tolkad> huh?
20:31:53 <tolkad> so, it's a type representing the real world?
20:32:11 <tolkad> it contains an entire copy of the universe I assume...
20:32:24 <applicative> Yes, but I don't pretend to understand.  IO is represented by ghc as  State 
20:32:43 <applicative> it doesn't contain a *copy* of the real world....
20:33:21 <tolkad> I wonder... by manipulating RealWorld can I control the universe?
20:33:45 <applicative> You'd have to control RealWorld....
20:34:04 <applicative> but I think "putChar 'x'' makes a bit of a dent
20:34:40 <tolkad> it's the japanese... everyone hide
20:35:02 <pikhq> tolkad: 日本人？何処？
20:35:25 <applicative> or getChar :: RealWorld -> (Char, RealWorld) 
20:35:57 <tolkad> pikhq: ？？処日本 人？日
20:36:38 <pikhq> tolkad: ?
20:36:39 <tolkad> I just want to know what type to use to create a mutable vector of something
20:37:01 <applicative> you need a state monad or else IO, right?
20:37:09 <tolkad> I'm not really sure what these monad things are for
20:38:09 <tolkad> implementing Monad seems to just allow you to write function parameters in a backwards way
20:38:26 <tolkad> and keep hidden state
20:38:40 * shachaf wishes people wouldn't call it "the State Monad".
20:38:40 <applicative> you can write them forward, =<< 
20:39:09 * applicative wonders, why, because there are so many>
20:39:13 <applicative> ?
20:39:38 <tolkad> << means "append" in some contexts
20:39:53 <shachaf> applicative: For the same reason I wish they wouldn't call it "the Maybe Monad". It's just Maybe.
20:39:57 <flippo> 日本人！  太可怕了！
20:40:28 <applicative> I see, I guess I was thinking it's okay as long as they speak of the Maybe Functor too... (?)
20:41:01 <tolkad> 教会の数字は高次の関数は、単一の引数の関数をとりますf、および別の1つの引数の関数を返します。教会数字nは関数をとる関数fの引数とリターンのn番目の組成物としてはf、すなわち関数f自体をn回で構成。これは、f）は（nを示され、実際にはのn乗fは（演算子と考えられる）です。fは（0）恒等関数として定義される。 1つの関数のよ
20:41:01 <tolkad> うな繰り返し組成（f）は指数のなぜこれらの数字は、算術演算に使用されることができる法律を、従いなさい。 （教会の元のラムダ計算では、ラムダ式の仮引数は、0は不可能上記の定義を行う関数の本体、少なくとも1回発生することが必要でした。）
20:41:31 * applicative wonders if any of the ops know japanese, this could be dangerous spam...
20:41:54 <shachaf> applicative: Sure, it's a Functor and a Monad, but those are just type classes that it's in.
20:42:27 <pikhq> applicative: Doesn't seem like dangerous spam to me ATM. Just a lot of Japanese.
20:42:50 <tolkad> applicative: I used google translate on a paragraph about lambda calculus, it's probably incomprehensible talking about "religious institution-numerals" and such nonsense.
20:43:03 <pikhq> ... Though it seems to be a lot of not-entirely-sensible Japanese.
20:43:37 <pikhq> tolkad: Not quite that bad.
20:43:52 <catenate> Found out how to avoid using where types = x::Int in my properties.  Give the property a full type signature: prop_commutative ∷ Int → Int → Bool; prop_commutative x y = add x y =? add y x
20:43:53 <applicative> shachaf, aren't there several monads in the Haskell typesystem -- o r on it or over it or whatever?  
20:43:54 <pikhq> It's still pretty... Weird.
20:44:03 <catenate> unfortunately that's not any shorter
20:44:14 <shachaf> applicative: What do you mean?
20:44:57 <applicative> I was thinking we want to speak of many monads, many interpretations of 'bind' / 'join' / whatever...
20:45:21 <applicative> but how to distinguish them except by the titles :  Maybe , IO, [], etc
20:46:01 <shachaf> applicative: The point is that Maybe stands on its own -- it just happens to belong to the type class Monad as well.
20:46:18 <applicative> So we speak of 'the Maybe monad' 
20:46:25 <shachaf> You don't call it "the Maybe Eq", you just call it "Maybe" or "the Maybe type" or something.
20:46:55 <shachaf> Maybe it's "the monadic Maybe type", but a monad is just one more thing it happens to be.
20:47:44 <tolkad> will "fix forkIO" work?
20:48:30 <applicative> shachaf I understand, I was just thinking that speaking of 'the Maybe monad' wasnt  already the muddle, it's just on
20:49:13 <applicative> shachaf, what really freaks me out is speaking of a value as 'a monad', like [1,2,3] or getChar
20:49:28 * syntaxglitch generally tries to only say "the Maybe monad" when actually talking about using bind/join/etc. on Maybe values
20:49:58 <applicative> shachaf, but LYAH got me used to it, he speaks of [1,2,3] as 'a functor' which freaked me out at first
20:50:15 <shachaf> syntaxglitch: Yep, that's not such a problem. I'm fine with saying "using the list monad" when talking about list comprehensions etc.
20:50:49 <syntaxglitch> I'm pretty sure I've simiarly used the definite article with Functor when talking about fmapping over stuff
20:50:58 <shachaf> syntaxglitch: But similarly State and IO and such exist on their own, and it bugs me that people always say "the IO monad".
20:51:40 <drhodes> is there a function that with do    func? (f, g) x -> (f x, g x)
20:51:40 <syntaxglitch> the difference there is that with Maybe you're often deconstructing a value by pattern matching on it
20:51:42 <applicative> shachaf, but it seems to me you can hear it innocently.  "A functor is something you can map over (fmap over); so a list is a functor" 
20:51:47 <syntaxglitch> you don't usually do that with IO
20:52:27 * applicative is trying to pattern match on RealWorld -> (Char, RealWorld)
20:52:58 <syntaxglitch> but I would try not to talk about "the IO monad" when just, say, passing around IO values without binding them, or when using only Functor/Applicative
20:53:15 <roconnor> syntaxglitch: not that you can do much else with IO since it is abstract
20:53:45 <syntaxglitch> roconnor, hence the joke about "not usually pattern matching on IO" :P
20:54:42 <arrummzen> I installed GHC and HUnit. How do I configure GHC to work with HUnit? More generally, what is the procedure for setting up paths for GHC?
20:55:08 <shachaf> applicative: I think GHC might let you do that if you pattenr-match on the newtype.
20:55:16 * shachaf keeps getting disconnected from IRC.
20:58:20 <tolkad> I just wanted to use arrays. what is all this PrimMonad, PrimState, RealWorld, etc. stuff... I'm so confused
20:58:59 <arrummzen> Like GCC has -I and -L options and Java has the classpath, what is the Haskell equivalent?
20:58:59 <applicative> arrummzen, can you find the executables that come with HUnit?
20:59:29 <tolkad> and then I go to the declaration of these strange classes to figure out what they are
20:59:44 <tolkad> and they use these weird things like State# that don't make any sense
21:00:15 <tolkad> I just want to use arrays.
21:00:21 <applicative> tolkad, we are definitely not supposed to have to know about RealWorld
21:00:52 <roconnor> maybe you should stick to looking at Data.Array
21:00:57 <tolkad> applicative: I'm trying to figure out what types I put in s and a to create a mutable vector: http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector-Unboxed-Mutable.html
21:01:00 <arrummzen> applicative: It doesn't appear to include an executable (according to my package manager). It has a .a, a .o and a bunch of .hi files.
21:01:24 <tolkad> roconnor: someone said vector was better
21:01:47 <tolkad> like... let's say I want a mutable vector of Chars... What do I put in the s?
21:02:02 <applicative> tolkad, the obvious way to start with the vector package is to look at a use of it that attracts you, see these http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/vector-0.6.0.2#direct
21:03:41 <tolkad> huh? I can't create mutable vectors longer than an int?
21:04:02 <tolkad> that's a silly restriction
21:07:56 <catenate> arrummzen: I don't run any separate executable to execute HUnit tests: I just pass control of my program to the runTestTT function in the Test.HUnit library.
21:08:24 <tolkad> hmm, rather than trying to write code with mutable vectors maybe I should just try playing around with them
21:09:35 <arrummzen> catenate: that is what I would like to do. Unfortunately I don't know how to link my program with HUnit and an hour and a half of googling can't find an answer.
21:10:41 <catenate> arrummzen: Just import it, more like Java than C.
21:11:38 <orbitz> In Python I generally only import the module name and then always refer to elements in it as module.element (that way I can easily tell what I'm calling refers to things defiend in teh current module or outside),  is this style frowned upon in Haskell or will it lead to uglier code?  I'm thinking infix operators
21:11:40 <arrummzen> catenate: but GHC gives me an error: "Could not find module `HUnit'" One line file with "import HUnit".
21:12:15 <arrummzen> I think I need to setup the Haskell equivalent of the Java classpath but google has no clue on how to do it.
21:12:20 <arrummzen> Maybe I should try bling.
21:12:23 <catenate> arrummzen: import Test.HUnit
21:12:45 <catenate> Haskell is not Java
21:14:01 <arrummzen> hmm... that worked. It looks like someone needs to update http://hunit.sourceforge.net/HUnit-1.0/Guide.html because it still says "import HUnit" and not "import Test.HUnit".
21:14:05 <applicative> tolkad, I don't know what sort of thing you like.  Here's a use of mutable vectors from the vector package.. http://github.com/elliottt/sprites/blob/master/src/Physics/Shape.hs
21:14:40 <applicative> arrummzen, yes that is Ye Olde Style.  It works for some imports still....
21:15:51 <applicative> arrummzen, there is a hierarchy of modules. if you look on the hackage page, they are listed and linked http://hackage.haskell.org/package/HUnit
21:17:26 <applicative> arrumzen, so if you look toward the top of this module (from HUnit itself) you'll see what an import statement looks like. 
21:17:28 <applicative> http://hackage.haskell.org/packages/archive/HUnit/1.2.2.1/doc/html/src/Test-HUnit-Text.html
21:18:31 <arrummzen> applicative: I see. Thank you for the help.
21:19:06 <catenate> arrummzen: I happen to be playing around with exhaustively testing a trivial add function, so you can see my QuickCheck and HUnit test driver here: http://github.com/catenate/rwhaskell/blob/master/ch2/add_test.hs
21:22:41 <greap_> I'm trying to install hsmagick, and I get the warning that my version of base is out of date, but when I run a cabal update it appears that I already have the latest. 
21:27:09 <orbitz> Golly, Haskell is crazy (reading throuh HappStack crash course)
21:27:26 <greap_> Has anyone come across "Warning: Module `Prelude' is deprecated" before?
21:28:21 <AnAdorableNick> orbitz: Haskell is brilliant!
21:28:50 <Apocalisp> Three cheers for Haskell!
21:29:14 <catenate> hip hip hooray!
21:29:37 <applicative> greap, i dont think you have to worry about the warning.  in any case, you don't install base via cabal install  
21:29:50 <Kaidelong> the GPipe tutorial is probably one of the worst tutorials I've ever come accross
21:30:25 <orbitz> AnAdorableNick: indeed it is.  sometimes i fear too brilliant
21:30:37 * orbitz is going to try to bang out an HappStack app this weekend
21:31:11 <applicative> greap what version of ghc are you using? 
21:31:39 <applicative> greap, yes, the prelude warning is a preliminary warning.
21:32:28 <applicative> greap, almost every module on hackage offends, but it's just a warning so far.  similarly with the 'old exceptions'
21:35:00 <tolkad> So, I figured out how to get these vector things to work
21:35:16 <tolkad> but I'm wondering why anyone would use anything but "IOVector"?
21:35:28 <tolkad> isn't the whole point of mutable vectors to do IO operations on them?
21:35:33 <dons> chrisdon`: why does gd need bytesting ≥0.9.1.6 ?
21:35:37 <dons> depending on a minor rev is odd
21:35:41 <shachaf> tolkad: Why?
21:35:42 <dons> and stops backwards compat.
21:35:56 <dons> tolkad: ST operations, so they're inplace
21:35:58 <dons> not IO ops
21:36:24 <nettok> what's the best webframework for haskell?
21:36:31 <tolkad> what's ST?
21:36:31 <catenate> Figured out how to avoid reproducing my type information in each property test: Call r instead of run, where: r = run :: (Int → Int → Bool) → TestOptions → IO TestResult
21:36:48 <tolkad> shachaf: curiosity
21:37:19 <dons> nettok: happstack or snap or yesod
21:37:25 <dons> http://snapframework.com/
21:37:30 <dons> http://happstack.com/index.html
21:37:38 <dons> http://docs.yesodweb.com/
21:37:44 <shachaf> tolkad: What does a vector have to do with interacting with the outside world?
21:38:09 <dons> tolkad: a monad for memory effects, like mutating a reference
21:38:19 <nettok> dons: if you have to choose one, what would it be?
21:38:40 <dons> nettok: i'd probably look at happstack or snap first. happstack is more mature, snap is sexier.
21:38:43 <tolkad> shachaf: I have no idea, I just know that you can make mutable vectors work by using "IOVector". otherwise they don't work.
21:38:50 <nettok> dons: k, thanks
21:39:00 <tolkad> dons: so ST is better?
21:39:20 <dons> tolkad: well, its less powerful than IO -- you can't do everything, just mutable memory
21:39:43 <tolkad> oh, that's nice
21:39:48 <dons> nettok: both snap and happstack have irc channels here. #happs and #snapframework
21:40:05 <tolkad> but uh... how do you turn it into IO? can you just put it inline in an IO thing or do you need to do something?
21:40:20 <dons> ST monad, http://book.realworldhaskell.org/read/advanced-library-design-building-a-bloom-filter.html#id680273
21:40:32 <dons> tolkad: well, after you've done all the operations, you get back a pure value
21:40:41 <dons> which can be printed or written out
21:40:57 <tolkad> wait is reading mutable memory ST?
21:41:17 <dons> well, yes, if the cell might mutate
21:41:24 <dons> then it might return a different result each time
21:41:42 <dons> so its in some sort of monad, usually ST or its bigger brother, IO.
21:41:48 <tolkad> is that ok with pure stuff?
21:41:53 <dons> if you have a pure, immutable array, reading isn't in a monad.
21:42:08 <tolkad> I thought pure functions had to always return the same thing when given the same arguments
21:42:13 <dons> its just a pure function that always returns the same result
21:42:16 <dons> that's right
21:42:27 <tolkad> it seems like "runST" could allow you to break that rule
21:42:42 <dons> precisely, its impure. but any side effect is trapped inside the runST
21:42:46 <dons> it can't be observed outside
21:42:52 <dons> but within the runST, you can mutate memory
21:43:11 <tolkad> but... you can write a function that looks pure but isn't really pure?
21:43:20 <jmcarthur> no, it's pure
21:43:23 <jmcarthur> it just uses mutation internally
21:43:46 <dons> like local variables 
21:43:57 <jmcarthur> even non-ST functions will use mutation (forcing thunks)
21:44:01 <jmcarthur> but they are still pure
21:44:02 <dons> the type system guarantees you cannot tell from the outside that you did local mutation
21:44:13 <dons> yes, usually the mutation is hidden by the runtime system
21:44:18 <dons> ST exposes a safe form to the user
21:44:54 <dons> its good to know.
21:45:41 <jmcarthur> :t runST
21:45:42 <lambdabot> forall a. (forall s. ST s a) -> a
21:46:17 <dons> awesomo type.
21:46:19 <jmcarthur> tolkad: ^^ it would take some explaining, but that "forall s" actually prevents you from accidentally leaking mutable references from the computation
21:46:35 <jmcarthur> it's a type error if you try to return one with that
21:48:35 <jmcarthur> tolkad: basically though, the "s" type variable is only in scope of the "ST s a". it's not in scope for the result of that function (the "a"). since STRefs and other mutable references meant for the ST monad include that "s" in their types, they can't be leaked
21:48:42 <tolkad> oh, I see. so ST stuff can only use mutable memory internally...
21:48:47 <jmcarthur> right
21:48:55 <tolkad> what's the s supposed to be?
21:48:57 <jmcarthur> and you can't share those references with other ST computations
21:49:10 <jmcarthur> the s is nothing special. it doesn't actually correspond to a value
21:49:16 <jmcarthur> it's just a type tag
21:49:50 <ddarius> At any rate, one does not need to "put something in for s."  Just let the system infer the types.
21:49:58 <tolkad> but... I can't use Data.Vector.Mutable.STVector... it says I'm not applying it to enough type arguments
21:50:16 <tolkad> oh
21:50:22 <jmcarthur> tolkad: you will need to add an s or something in there. you just don't have a concrete type to put there
21:50:50 <tolkad> quantified variable s escapes? what's that mean?
21:51:04 <jmcarthur> that means you tried to return something that uses s :P
21:51:13 <ddarius> It means you were trying to do exactly what runST tries to stop.
21:51:17 <jmcarthur> that's exactly what the type signature is meant to prevent
21:52:05 <Angelion> No Preference
21:52:30 <Angelion> how much time you currently have?
21:52:35 <jmcarthur> ?
21:55:08 <Angelion>  :o 
21:55:13 <sshc> Do I need to enable the TypeOperators extension in my source that uses fclabels to use fclabels?
21:56:03 <Angelion> Why? sshc
21:56:54 <sshc> Angelion: fclabels uses the TypeOperators extension te define :->
21:57:16 <sshc> I'm also trying to look for GHC's documentation for the extension
21:57:50 <Angelion> sshc use google 
21:58:07 <sshc> Angelion: I already did.
21:58:20 <sshc> Also, which extension do I need for data types without constructors?
21:59:00 <Lemmih> sshc: EmptyDataDecls.
21:59:26 <sshc> Lemmih: Thanks.
22:00:07 <Angelion> sshc Haskell is a programming language ?
22:00:35 <Angelion> sshc i used php5 and javascript
22:01:10 <Lemmih> Angelion: Haskell will blow your mind, then.
22:02:54 <medfly> not necessarily.
22:03:51 <Angelion> sshc I am bored
22:04:40 <catenate> Not to be rude, but I think Angelion is a bot.
22:05:10 <sshc> Angelion: Location and gender?
22:05:26 <medfly> maybe just a strange non native English speaker.
22:05:29 <Angelion> catenate you idiot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
22:05:35 <catenate> Yikes
22:05:35 <Rotaerk> ..
22:05:46 <Rotaerk> now that's a lot of bangs
22:05:55 <catenate>  A gang of bangs
22:06:22 <Angelion> medfly I do not speak English
22:06:27 <medfly> you do now!
22:06:52 <Angelion> medfly I do not speak russian
22:06:59 <medfly> yes you do
22:06:59 --- mode: ChanServ set +o Lemmih
22:07:32 <catenate> Angelion: yo quiero humanity?
22:08:28 <Angelion> catenate what is "quiero" ?
22:08:57 <Rotaerk> yo quiero taco bell
22:08:59 <applicative> quiero, "i want" 
22:09:52 <applicative> now i will never learn the solution to the STVector s e mystery....
22:10:13 <catenate> Angelion: what is 2+2?
22:10:45 <Angelion> catenate Why you ask?
22:10:57 <Angelion> 4  :D  :D  :D 
22:11:11 <arrummzen> If I use put my Haskell Hello World program in a module I get the following error : undefined reference to `__stginit_ZCMain'
22:11:19 <arrummzen> How do I tell GHC to find my main in a module?
22:11:22 <catenate> Angelion: Yay!
22:11:26 <Lemmih> arrummzen: Compile with --make.
22:11:49 <Angelion> catenate you like php5 ?
22:12:23 <catenate> Angelion: No occasion to ever use it, thankfully.
22:12:30 <applicative> arrumzen, like so, maybe:   ghc --make -O2 HelloWorld.hs -o helloworld 
22:12:31 <medfly> catenate, better guess: troll
22:13:03 <catenate> medfly: possibly.  I'm still working the bot angle.
22:13:47 <applicative> "catenate Why you ask?" did sound a bit like the emacs therapist...
22:13:49 <Angelion> I'll make it through the rainy days
22:13:50 <Lemmih> applicative: -O2 for printing hello world ultra fast. (:
22:13:56 <catenate> Angelion: What was the last book you read?
22:14:05 <applicative> Lemmih, indeed.  
22:14:08 <Angelion> I'll be the one who stands here 
22:14:08 <Angelion> longer than the rest 
22:14:09 <Angelion> When my landscape changes, rearranges
22:14:11 --- mode: Lemmih set -o Lemmih
22:14:25 <catenate> applicative: sounds like eliza actually, back on my C64
22:14:28 <lpsmith> Angelion, what IRC client do you use?
22:14:40 <medfly> if you're so worried about possibly talking to a bot, then try not to 
22:14:50 <Angelion> catenate i read Ajax
22:15:06 <Angelion> lpsmith opera
22:15:08 <catenate> Oh, no, I think it's cool to talk to a bot.  I just don't want to lose the turing test
22:15:22 <medfly> hehe
22:15:40 <applicative> caenate is practicing to be a judge in the turing test competition
22:15:48 <catenate> exactly
22:15:51 <medfly> heh
22:15:56 <Angelion> I'll be stronger than Ive ever been 
22:15:56 <Angelion> No more stillness, more sunlight, 
22:15:56 <Angelion> Everything's gonna be alright
22:16:05 <arrummzen> Is my main method required to be the main module? 
22:16:16 <Angelion> I know that there's gonna be a change 
22:16:16 <Angelion> Better find your way out of your fear 
22:16:16 <Angelion> If you wanna come with me 
22:16:16 <Angelion> Then that's the way it's gotta be
22:16:27 <catenate> Angelion: I put my hands up, they're playing my song, I know I'm gonna be okay
22:16:30 <applicative>  friend of mine noticed a few months ago that the machines are getting better in the turing test competitions....
22:16:40 <medfly> Angelion, как дела?
22:16:45 <applicative> he said it was because human beings are becoming more mechanical
22:16:58 <Angelion> medfly 
22:17:00 <medfly> maybe because machine are becoming more human
22:17:19 <catenate> The last transcript I read it wasn't even close, but that was a few years ago
22:17:28 <lpsmith> You see,  if I could travel 1000 years into the future,  I think that I'd still be able to accurately judge a turing test.   At least, that's my totally unfalsifiable hypothesis.
22:17:33 <Angelion> I'm all alone and finally 
22:17:33 <Angelion> I'm getting stronger 
22:17:33 <Angelion> You'll come to see 
22:17:33 <Angelion> Just what I can be 
22:17:33 <Angelion> I'm getting stronger
22:18:28 <tolkad> so, in the mutable vector stuff I see "read" and "unsafeRead" unsafeRead says it doesn't do bounds checking but how can read do bounds checking? they return the same thing... how do you know if the bounds check failed?
22:18:33 <medfly> I don't think humans are that special
22:18:37 <catenate> Do you notice how our friend doesn't address topics we discuss amongst ourselves, without saying its name, like its nature?
22:18:42 <lpsmith> I suppose there is one way to falsify my hypothesis,   get a computer that can consistently convince me that it's human before I die
22:19:00 <medfly> just a matter of enough computing power
22:19:13 <tolkad> medfly: and the proper algorithms
22:19:19 <tolkad> medfly: we don't have either at this point
22:19:24 <medfly> right
22:19:32 <medfly> but maybe in a 1000 years we will )
22:20:07 <catenate> Do you notice how our friend doesn't address topics we discuss amongst ourselves, without saying the name Angelion, but does respond when we do?
22:20:10 <tolkad> medfly: we aren't even really sure how powerful a computer the brain is. I think 1000 years is way too long
22:20:18 <tolkad> we'll figure it out before that
22:20:22 <lpsmith> I don't think humans are that special either,   but I think the complexity classes between human and electronic computers are so fundamentally different that we will never develop "strong" AI
22:20:27 <medfly> I think it just works differently
22:20:46 <lpsmith> The real goal,  in my opinion,  is to integrate the two kinds of computers
22:20:49 <medfly> but just like with a lot of work we can do so some number crunching, so can a computer
22:20:59 <Angelion> Lock and Load
22:21:06 <Angelion> Bring the fables from thy tomb
22:21:06 <Angelion> Sporadic doom as knights loom
22:21:06 <Angelion> Does clergy support this passion?
22:21:06 <Angelion> Pure wrath of the winged assassin
22:21:21 <medfly> you know maybe ou are right
22:21:23 <lpsmith> medfly,  perhaps,  but will it be enough to fool a smart human?
22:21:27 <tolkad> lpsmith: It is possible that AI computers will require a computing power of enough density space-wise that we will need to design very specialized hardware for them
22:21:28 <Angelion> A time of fate
22:21:29 <Angelion> Your spite sooths
22:21:29 <medfly> yes
22:21:29 <Angelion> Untold the stories
22:21:29 <Angelion> Of thy muse
22:21:42 <tolkad> anyway
22:21:44 <Angelion> Hour is late as
22:21:44 <Angelion> Kingdoms unfold
22:21:44 <Angelion> Signs in disarray
22:21:44 <Angelion> Your fight in loath
22:21:44 <catenate> Angelion: Quote some code at us, we'll at least be more entertained than by your poetry
22:21:47 <tolkad> so, in the mutable vector stuff I see "read" and "unsafeRead" unsafeRead says it doesn't do bounds checking but how can read do bounds checking? they return the same thing... how do you know if the bounds check failed?
22:21:59 <medfly> now Angelion is just spamming
22:22:08 <tolkad> does it just mean that it will fail with an error rather than access out of bounds memory?
22:22:13 <Angelion> Move, when your
22:22:13 <Angelion> In the groove, in core
22:22:13 <Angelion> With the muse, is your
22:22:13 <Angelion> Light the fuel, with torch
22:22:13 <Angelion> Cues of silence spark the mastery
22:22:13 <Angelion> Knights revolt to demonic treachery
22:22:24 <tolkad> quiet.
22:22:26 <catenate> can someone boot the spammer?
22:22:33 <tolkad> I have an actual haskell question.
22:22:34 <lpsmith> ok,  Angelion is becoming more trouble than it's worth
22:22:44 <lpsmith> tolkad, go! :)
22:23:00 * catenate trembles with antici...pation
22:23:02 <tolkad> so, in the mutable vector stuff I see "read" and "unsafeRead" unsafeRead says it doesn't do bounds checking but how can read do bounds checking? they return the same thing... how do you know if the bounds check failed? does it just mean that it will fail with an error rather than access out of bounds memory?
22:23:10 <Angelion> lpsmith you do not like the song?
22:23:26 <catenate> Angelion: it's off topic and too long
22:23:31 <tolkad> basically, what does read do if the bounds checking fails?
22:23:39 <lpsmith> Not to mention, I'm not hearing any music :)
22:23:45 <tolkad> Data.Vector.Mutable.read that is
22:24:09 <lpsmith> tolkad, I would assume calls "error",  which raises an exception that can only be caught in the IO monad
22:24:37 <tolkad> lpsmith: I see. it seems I will be using unsafeRead
22:24:56 <lpsmith> exceptions can be raised anywhere,  even in pure code.  They can only be caught in the IO monad
22:25:10 <tolkad> are they expensive, as in other languages?
22:25:22 <lpsmith> I don't know,  I don't use them extensively
22:25:42 <lpsmith> unsafeRead will exhibit undefined, unpredictable behavior if you read out of bounds
22:25:56 <Angelion> tolkad i know python php5 JS ajax html 
22:26:29 <tolkad> Angelion: are you a markov chain bot? : /
22:26:49 <lpsmith> tolkad,  The main point of unsafeRead is to go a little bit faster by avoiding the bounds check,  if you are sure the index is never out of bounds
22:27:24 <Angelion> tolkad You made me angry with these words I do not bot
22:27:24 <tolkad> lpsmith: well rather than raising an exception I would like to use Maybe, so I guess I will do the bounds check myself
22:27:46 <tolkad> Angelion: suspiciously human, let's try it again
22:27:49 <tolkad> Angelion: are you a markov chain bot? : /
22:28:00 <applicative> Angelion, but we are discussing our programming language.  At the moment we are learning from tolkad's difficulty.
22:28:54 <lpsmith> sure, that's a perfectly valid design decision,  and if you are checking the bound yourself to return maybe,  then of course,  use unsafeRead :)
22:28:54 <Angelion> tolkad .!..
22:30:24 <Angelion> Welcome the thoughts of a cowards disband
22:30:24 <Angelion> Cuz now youre in the shadow of the angels wingspan
22:30:24 <tolkad> is Angelion a bot or a person trying to be funny?
22:30:41 <Angelion> Cleanse your cradle of filth
22:30:41 <Angelion> Discipline that Ive instilled
22:30:41 <Angelion> Turn and face your sacrifice
22:30:41 <Angelion> As I revolve this lead of might
22:30:46 <medfly> what does it matter?
22:30:48 <medfly> he's a spammer
22:30:52 <medfly> bot or not
22:31:03 <Angelion> In my world only time is feared
22:31:04 <Angelion> Single handedly I draw your first tear
22:31:04 <Angelion> Sway strong to the truthful frequency
22:31:04 <Angelion> Spirits swim in the waves of history
22:31:14 <dolio> Lemmih: You can use that hammer now.
22:31:44 <lpsmith> if it's a person,  then its doing a very good job of not commenting on our discussion of it without using its name
22:31:53 <lpsmith> but yes, it doesn't matter.
22:32:03 <lpsmith> Angelion is a spammer than needs to be booted
22:32:14 <catenate> lpsmith: +1
22:32:28 <syntaxglitch> hm, this is possibly some of the ugliest Haskell code I've ever written :(
22:32:41 <tolkad> are vectors 0-indexed?
22:33:20 * syntaxglitch decides to get some sleep and de-uglify his code tomorrow
22:34:28 <lpsmith> I dunno,  I've mostly used ST Arrays
22:34:38 <lpsmith> Not so much vectors
22:35:19 <tolkad> just tested it, they are. It would be nice if this sort of stuff were documented
22:35:37 <Angelion> tolkad http://code.google.com/intl/ru/ 
22:35:57 <tolkad> the haddock vector stuff is kind of lacking
22:36:19 <tolkad> Angelion: how helpful, the Russian version of google code search. Thank you.
22:37:11 <Angelion> tolkad )
22:37:23 <catenate> tolkad: it responded that way because you asked a question
22:37:32 <tolkad> Angelion: here, you forgot to open it: (
22:38:18 <tolkad> catenate: of course, it's response was entirely contextually sensible
22:38:22 <Angelion>  ;) 
22:38:36 <tolkad> its*
22:38:54 <tolkad> sorry, I put an apostraphe where it shouldn't go
22:40:30 <Angelion> tolkad you like sql injection ?
22:40:43 <Angelion> 1=1'
22:40:56 <catenate> Let's try a pattern that should be easy for a human to read: A n g e l i o n  i s  a  b o t.
22:41:27 <catenate> it's responded pretty strongly to that in the past
22:42:52 <Angelion> &1+and+1'
22:44:56 <Angelion>  :'( 
22:45:16 <Angelion> all silent .......... all silent .......... 
22:45:18 <medfly> now I know how to troll nerds really well
22:46:42 <catenate> well, there's a certain curiosity it preys upon
22:47:22 <sshc> Do I need to enable the TypeOperators extension in my source to use fclabels?
22:47:35 <sshc> Particularily to use the :-> operator?
22:47:41 <dolio> Only if you're going to use type operators yourself.
22:48:25 <sshc> dolio: Do I need the extension to use (:->) in a type signature?
22:48:36 <dolio> I imagine so.
22:49:47 <sshc> I can't find any documnetation on the extension
22:50:00 <sshc> I thought it'd be in the user manual
22:50:15 <dolio> It is.
22:50:37 <Angelion> life is boring but do not worry and I'm sorry
22:50:59 <dolio> Chapter 7.
22:52:16 <dolio> I don't actually see type operators in the section I'd expect, though.
22:52:34 <sshc> dolio: I searched every section, and the only mention of it is in 7.1, which doesn't contain the information I want
22:52:38 <Angelion> http://translate.google.ru/
22:52:41 <sshc> Every section in 7.1
22:52:54 <dolio> Yeah. Probably an oversight.
22:53:17 <sshc> How does the extension work, then?
22:54:03 <Maxdamantus> Hmm.. What's a pretty in Haskell of doing those triangular loops..? for(a = 0; ; a++) for(b = 0; b < a; b++) (a, b)
22:54:07 <dolio> It lets you use infix operators in types. Things that start with colons are available for data/newtype and everything else is a variable, I think.
22:56:08 <Lemmih> Maxdamantus: [ (a,b) | a <- [0 .. ], b <- [0 .. a] ]
22:56:43 <Maxdamantus> Oh, true :\
22:57:38 <Maxdamantus> Ah, didn't think you could use a in the second list expression
22:59:09 <Angelion> http://translate.google.ru/
23:00:03 <sshc> http://example.com/
23:02:08 <sshc> Angelion: Why did you join?
23:02:44 <Angelion> sshc do not understand you
23:02:56 <Angelion> sshc what ?
23:04:41 <sshc> Зачем ты пришел в этот канал?
23:04:49 <sshc> .i mi se na bangu zo'e vau co'odo'u sipna
23:05:12 <Angelion> sshc     ,  !!!!
23:05:37 <Angelion> sshc I train English
23:08:53 <Angelion> all silent .......... all silent ..........
23:09:23 <Angelion> silent .......... ewerywhere ...
23:09:36 <poljp> errm hi
23:09:55 <Angelion> poljp hello my friend
23:10:03 <poljp> :)
23:11:42 <Angelion> poljp my desktop http://s43.radikal.ru/i100/0812/08/00bf706f7b59.jpg
23:11:52 <Angelion>  my desktop http://s43.radikal.ru/i100/0812/08/00bf706f7b59.jpg
23:12:18 <poljp> i see
23:12:31 <poljp> my desktop is covered in haskell stuff :P
23:13:00 <Angelion> poljp my desktop ... good girl ) ?
23:13:58 <kmc> what is going on here
23:14:30 <Angelion> kmc we talk
23:14:44 <Angelion>  8-) 
23:20:06 <Angelion> silent ..........silent ..........
23:20:15 <wioux> :)
23:20:23 <wioux> why does the following fail when the pattern is not lazy:
23:20:26 <Angelion> wioux  ;) 
23:20:58 <wioux> > fst (fix (\(x,y) -> (1:y, 2:x)))
23:21:02 <lambdabot>   mueval-core: Time limit exceeded
23:21:12 <wioux> fst (fix (\ ~(x,y) -> (1:y, 2:x)))
23:21:23 <wioux> > fst (fix (\ ~(x,y) -> (1:y, 2:x)))
23:21:24 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
23:22:00 <Cale_> Well, the abstract reason is the simplest one
23:22:11 <Cale_> fix finds the least-defined fixed point of a function
23:22:15 <dolio> Oh good. Someone with powers.
23:22:44 <Cale_> (\(x,y) -> ...), when applied to undefined, gives an undefined result, because it would have to pattern match against the pattern (x,y)
23:22:53 <Cale_> and so undefined is a fixed point of the function
23:23:16 <dolio> Oh, and it doesn't matter, because the bot quit.
23:23:22 <wioux> ah
23:24:46 <Cale_> On the other hand, if you apply (\ ~(x,y) -> (1:y,2:x)) to undefined, you get something which is effectively (1:undefined, 2:undefined)
23:25:02 <Cale_> and so undefined is not a fixed point of that function
23:25:24 <Cale_> > (\ ~(x,y) -> (1:y,2:x)) undefined
23:25:25 <lambdabot>   ([1*Exception: Prelude.undefined
23:25:44 <wioux> ah i see..
23:25:50 <wioux> so what about something like
23:25:50 <Cale_> > let (u,v) = (\ ~(x,y) -> (1:y,2:x)) undefined in (head u, head v)
23:25:51 <lambdabot>   (1,2)
23:26:33 <Cale_> (The ~ delays pattern matching to when the bound variables are actually needed)
23:27:41 <wioux> alright.. so if ~(x, y) is matched against undefined, and then x and y are used, then x and y are both undefined as well
23:28:41 <kmc> Cale_, that's a nice case where the denotational answer is simple
23:28:42 <wioux> or.. because they're irrefutable as well?
23:28:58 <kmc> and i think the operational answer is a lot more complicated to state
23:29:10 <kmc> wioux, x and y are undefined whether or not they're used
23:29:11 <Cale_> wioux: x and y are both undefined in that case, yes
23:29:29 <shadwick> hi, I'm new to Haskell and I'm wondering how I import 'Infinity' for use in a module that'll be loaded into GHCi ?
23:29:29 <Cale_> wioux: But the pattern match succeeds regardless.
23:29:40 <wioux> right
23:29:43 <kmc> shadwick, Infinity the floating-point number?
23:29:54 <eflister> i can't tell from http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/ffi-ghc.html#id712848 whether i need to hold on to the Ptr a returned from Foreign.malloc if i don't want it garbage collected?  http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Foreign-C-String.html#v%3AnewCString seems to suggest that malloc'd memory is not ever garbage collected.
23:29:57 <shadwick> kmc: whatever it is that a divide-by-zero gives
23:29:58 <Cale_> shadwick: If you want Infinity the floating point number, use 1/0
23:30:11 <kmc> > 1/0
23:30:12 <lambdabot>   Infinity
23:30:17 <kmc> there's not a constructor for it
23:30:19 <kmc> > Infinity
23:30:20 <lambdabot>   Not in scope: data constructor `Infinity'
23:30:22 <Cale_> :t isInfinity
23:30:23 <lambdabot> Not in scope: `isInfinity'
23:30:25 <Cale_> :t isInfinite
23:30:26 <lambdabot> forall a. (RealFloat a) => a -> Bool
23:30:33 <shadwick> kmc: oh, I didn't know that. thanks
23:31:01 <kmc> > let inf = 1/0 in inf == inf
23:31:03 <lambdabot>   True
23:31:05 <kmc> but
23:31:08 <kmc> > let x = 0/0 in x == x
23:31:10 <lambdabot>   False
23:31:12 <kmc> shadwick, beware ^^^^
23:31:41 <arrummzen> I need to write a function which prints a line and returns a number. But I can't figure out how to do it?
23:31:57 <shachaf> arrummzen: That's not a function, that's an action.
23:31:59 <shadwick> kmc: k, thank you
23:32:18 <kmc> arrummzen, you can write a function which returns a "recipe" for doing stuff
23:32:25 <kmc> stuff consisting of printing a line and producing a number
23:32:25 <Cale_> :t putStrLn
23:32:26 <lambdabot> String -> IO ()
23:32:31 <kmc> recipes have type  «IO a» for some a
23:32:43 <wioux> the question arose as 
23:32:45 <Cale_> putStrLn is a function which, given a String, gives the action for printing that String to the terminal.
23:32:50 <eflister> am i right that Foreign.malloc'd memory won't ever be garbage collected even if i drop my reference to it and never free it?  what happens to it, is it freed when the runtime dies?
23:32:56 <kmc> the point is that the function itself has no effect, it just produces a description for doing something
23:33:08 <kmc> eek, is the haskell wiki down?
23:33:11 <Cale_> eflister: That sounds right.
23:33:20 <kmc> :t \x -> print x >> return x
23:33:21 <lambdabot> forall a. (Show a) => a -> IO a
23:33:23 <eflister> cale_: cool thx
23:33:31 <shachaf> eflister: Presumably if you Foreign.malloc something you'll want to Foreign.free it.
23:33:34 <kmc> arrummzen, ^^^ this function turns a value x into a "print and return x" action
23:33:45 <arrummzen> So you are telling me if I have a function which uses putStrLn it is going to return an IO?
23:33:53 <Cale_> arrummzen: Yes.
23:34:00 <kmc> yes
23:34:06 <eflister> shachaf: agreed, but i just wanted to know if it was subject to G 
23:34:10 <eflister> GC
23:34:22 <Cale_> arrummzen: Because putStrLn is an IO action, and unless you just want to discard that IO action, there's not much you can do but to produce another IO action from it.
23:34:39 <Cale_> Rather, the *result* of putStrLn is an IO action, sorry :)
23:34:42 <kmc> arrummzen, yes.  because putStrLn doesn't print a string, it builds a recipe for how to print a string.  that recipe is useless unless you glue it onto other recipes, which eventually make up the "main" value of the program
23:34:48 <kmc> the value named "main" of type "IO ()"
23:34:54 <wioux> Cale: the issue came up as I was reading The Implementation of Functional Programming Languages -- any chance you've read it?
23:35:16 <Cale_> wioux: I haven't read all of it, but I have read parts.
23:35:16 <kmc> arrummzen, it's totally valid code to say «\x -> let y = print x in ()»
23:35:23 <kmc> but it will never print anything
23:35:30 <kmc> because you build the recipe, but then throw it away
23:35:59 <shadwick> kmc: or because you never use the return value, that whole function call could be optimized away to never having to be done in the first place eh? :P
23:36:14 <shadwick> kmc: assuming GHC is an optimizaing compiler...
23:36:18 <arrummzen> sigh, well lets say I have two functions which return IO actions. How do I combine them?
23:36:32 <Cale_> shadwick: Right, the print x there is dead code, so it'll be eliminated.
23:36:52 <kmc> arrummzen, by "combine" you mean "do one, then the other?"
23:36:54 <kmc> :t (>>)
23:36:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
23:36:55 <kmc> :t (>>=)
23:36:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:37:01 <kmc> shadwick, in more concrete types:
23:37:05 <kmc> (>>) :: IO a -> IO b -> IO b
23:37:07 <Cale_> arrummzen: There are a number of ways, but do-notation is the most common.
23:37:15 <kmc> (>>=) :: IO a -> (a -> IO b) -> IO b
23:37:15 <shadwick> Cale_: which is one thing I must say is quite awesome about no side-effects
23:37:38 <kmc> shadwick, that's irrelevant though, even if «print x» were left intact and were evaluated somehow, it wouldn't print
23:37:49 <shadwick> kmc: yes, I understand that
23:38:03 <kmc> arrummzen, check out http://haskell.org/haskellwiki/Introduction_to_IO
23:38:29 <kmc> arrummzen, the basic way to combine IO actions is (>>=).  there's also (>>) which is useful when you're throwing out the result of the first action
23:38:39 <kmc> arrummzen, and, there's the "do" syntax, which is just syntactic sugar for these functions
23:38:57 <kmc> x >> y  =  x >>= \_ -> y
23:39:33 <Cale_> arrummzen: For example...  do putStrLn "hello there"; x <- getLine; putStrLn x; return 5
23:39:55 <Cale_> arrummzen: do-notation lets you glue simpler IO actions together into more complicated ones
23:40:09 <Cale_> (and yes, it's syntax sugar for >> and >>=)
23:40:40 <arrummzen> This all comes up because I'm trying to do an experiment to see how Haskell deals with IO in a parallel program. 
23:41:31 <arrummzen> My goal is to have have one function which prints a and another which prints b and have them called concurrently resulting in a randomish stream of a's and b's.
23:42:02 <kmc> arrummzen, be sure to distinguish parallelism from concurrency
23:42:09 <kmc> concurrency is when you have multiple threads of executing actions
23:42:13 <kmc> we get that with forkIO or similar
23:42:28 <kmc> parallelism is when you do the pure evaluation computation on multiple cores, but it doesn't change the semantics of the program
23:42:42 <kmc> we get that with the stuff in Control.Parallel
23:42:46 <kmc> like "par"
23:42:52 <kmc> and the strategies in Control.Parallel.Strategies
23:43:00 <Cale_> arrummzen: import Control.Monad; import Control.Concurrent; main = do forkIO (forever (putStr "a")); forever (putStr "b")
23:44:25 <arrummzen> ok, that is a lot to think about...
23:44:41 <Cale_> arrummzen: forever x = do x; forever x
23:44:58 <Cale_> arrummzen: (It's just a function defined in Control.Monad)
23:45:02 <wioux> Cale_: i'm not sure how Haskell handles it, but in the book there is the idea of a built-in function SELECT-i which returns the i-th component of structured data. then "f ~p = ...p_i..." would be equivalent to "f v = ...SELECT-i v..."?
23:45:41 <Cale_> and if x is any IO action, then forkIO x is an IO action which just starts a new thread in which x is running (producing the ThreadId of that thread as its result)
23:46:47 <Cale_> wioux: Something like that. For example,  (\ ~(x,y) -> (1:y, 2:x)) is equivalent to (\p -> (1 : snd p, 2 : fst p))
23:48:17 <Cale_> arrummzen: So, forever (putStr "a") is an infinite loop which just prints "a" over and over forever.
23:48:20 <shadwick> what is the difference between Fractional and Floatng? GHCi is griping at me
23:48:34 <wioux> thanks.. and that explains for me why in ~(x,y) matched against undefined results in x and y both undefined - because SELECT-i must be strict
23:48:35 <Cale_> arrummzen: And the first line of our do-block there starts a new thread in which that happens.
23:49:11 <Cale_> shadwick: Fractional defines (/), recip, and maybe a couple other things, Floating defines stuff like sin, cos, (**), log, exp
23:50:02 <Cale_> arrummzen: And then the second line of our do-block just says to go into an infinite loop printing "b" forever (in the main thread)
23:50:14 <kmc> shadwick, they're two different type classes.  Floating requires Fractional
23:50:24 <kmc> shadwick, try ":i Fractional" and ":i Floating" in GHCi
23:50:38 <Cale_> arrummzen: and so you'll get a random interleaving of 'a' and 'b' on your terminal when you run the program, as the threading is pre-emptive in GHC.
23:51:39 <shadwick> kmc: Cale_: thanks, so if I'm writing a function that takes Fractional numbers, but is using / on them... how would I write the type signature?
23:51:44 <kmc> arrummzen, note that you will get different results if you build with "ghc -threaded"
23:51:47 <kmc> :t (/)
23:51:48 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:51:58 <kmc> (/) is in Fractional, you have  no problem
23:52:06 <Cale_> shadwick: Remember that Fractional is just a typeclass to which various types belong
23:52:09 <arrummzen> that clears things up a bit for me. Thank you.
23:52:32 <shadwick> kmc: GHCi says that it can't infer Ord for their type.. I have a >= in my function. shouldn't Floating and Fractional be under Ord ?
23:52:59 <Cale_> shadwick: For example, Float, Double, Rational, and Complex Double, all belong to the Fractional class (and so support / for division)
23:53:10 <kmc> shadwick, no, for example complex numbers are not totally ordered
23:53:25 <DrSyzygy> kmc: Not totally ordered in any sensible way.
23:53:28 <kmc> right
23:53:37 <DrSyzygy> It's easy to put orders on C, it's hard to put one on C that makes any kind of sense.
23:53:40 <Cale_> shadwick: But, for instance, Rational does not belong to Floating, since the cosine of a rational number is often not itself Rational
23:53:41 <kmc> they are orderable but not "ordered conventionally"
23:53:55 <shadwick> ah ok this is quite neat
23:54:51 <shadwick> kmc: so how do I make my function allow Fractional numbers, AND use the >= comparison? something like (Fractional a, Ord a) => a -> ...
23:55:10 <DrSyzygy> Yup.
23:55:16 <kmc> yes
23:55:32 <kmc> says "a must be a fractional type which also supports ordering"
23:55:39 <DrSyzygy> Which allows for people to pick an ordering on C if they need it by implementing, themselves, instance Ord (Complex Double) where ...
23:55:59 <kmc> eww orphan instance :/
23:56:15 <shadwick> ok great, and I'm also using sqrt in my function, so GHCi is saying it can't deduce Floating from the sqrt
23:56:26 <Cale_> Yeah, more likely, you'd make a newtype which selected the ordering you wanted.
23:56:36 <shadwick> so I add one more ", Floating a" to the declaration?
23:56:54 <Cale_> shadwick: You can replace Fractional with Floating
23:57:05 <Cale_> shadwick: Because Floating is a subclass of Fractional
23:57:21 <shadwick> ah, perfect. thanks!
23:59:10 <Veinor> thing I would like: a Set-like data type that can be implemented over types that aren't in Ord
23:59:12 <Cale_> shadwick: Floating and Ord together *basically* imply that the type is either Float or Double. It could also be a user-defined type from some library, but those are the only two instances in the base library.
23:59:24 <Cale_> Veinor: Eq then?
23:59:33 <Veinor> Cale_: yeah, just Eq
23:59:43 <Cale_> Veinor: You'll pay for it with asymptotically slower performance of course.
23:59:58 <Veinor> well... one thing I was thinking is that you pass in a comparator
23:59:59 <Cale_> (Linear in place of logarithmic, for most operations)
