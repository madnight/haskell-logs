00:00:11 <ski> (and, in types, `[t]' is syntactic sugar for `[] t', where `[]' is a type constructor)
00:00:51 <Wolfspaw> I want to use a function,that receives 2 parameters, feeding each parameter with elements from a list (each parameter getting feed with a diferent list). Can i do: (map function list1) $ list2 ?   (with the first map doing a list of functions and then applying to the second list)
00:01:01 <dolio> Lots of unfortunate overloading.
00:01:04 <tolkad> oh, here it is: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Prelude.html
00:01:15 <ski> (poljp : for some reason, your nick makes me think of PolyP <http://www.cse.chalmers.se/~patrikj/poly/polyp/>)
00:01:15 <tolkad> what's this? 0_o []((:), []),
00:01:42 <ski> tolkad : like `List (Cons,Nil)', except the names are different
00:02:04 <ski> tolkad : the type `[]' is exported, together with its constructors `(:)' and `[]'
00:02:30 <poljp> (ski, "oh")
00:03:12 <ClaudiusMaximus> :t zip
00:03:13 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
00:03:26 <tolkad> :t zip . zip
00:03:27 <lambdabot>     Couldn't match expected type `[a]'
00:03:27 <lambdabot>            against inferred type `[b] -> [(a1, b)]'
00:03:27 <lambdabot>     Probable cause: `zip' is applied to too few arguments
00:03:29 <ClaudiusMaximus> :t uncurry
00:03:30 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
00:03:40 <ClaudiusMaximus> @src zipWith
00:03:41 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
00:03:41 <lambdabot> zipWith _ _      _      = []
00:03:42 <tolkad> :t (.) . (.)
00:03:43 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
00:03:46 <ski> @type (zip .) . zip
00:03:47 <lambdabot> forall b a b1. [a] -> [b1] -> [b] -> [((a, b1), b)]
00:04:23 <ski> @hoogle [Either a b] -> ([a],[b])
00:04:23 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
00:04:39 <tolkad> :t (.).(.)
00:04:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
00:04:58 <ski> @type let (.) = (Prelude..) in (.) . (.)
00:04:59 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
00:05:06 <ClaudiusMaximus> > getZipList $ (\x y z -> x + y * z) <$> ZipList [1,2,3] <*> ZipList [10,20,30] <*> ZipList [100,1000,10000]
00:05:07 <lambdabot>   [1001,20002,300003]
00:05:09 <tolkad> :t let x=(.)in x.x
00:05:10 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
00:05:45 <tolkad> :t let x=(.)in x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x
00:05:46 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) (f6 :: * -> *) (f7 :: * -> *) (f8 :: * -> *) (f9 :: * -> *) (f10 :: * -> *) (f11 :: * -> *) (f12 :: * -
00:05:47 <lambdabot> > *) (f13 :: * -> *) (f14 :: * -> *) (f15 :: * -> *) (f16 :: * -> *) (f17 :: * -> *) (f18 :: * -> *) (f19 :: * -> *) (f20 :: * -> *) (f21 :: * -> *) (f22 :: * -> *) (f23 :: * -> *) (f24 :: * -> *) (
00:05:47 <lambdabot> f25 :: * -> *) (f26 :: * -> *) (f27 :: * -> *) (f28 :: * -> *) (f29 :: * -> *) (f30 :: * -> *) (f31 :: * -> *) (f32 :: * -> *) (f33 :: * -> *) (f34 :: * -> *) (f35 :: * -> *) (f36 :: * -> *) (f37 ::
00:05:47 <lambdabot> * -> *) (f38 :: * -> *) (f39 :: * -> *) (f40 :: * -> *) (f41 :: * -> *) (f42 :: * -> *) (f43 :: * -> *) (f44 :: * -> *) (f45 :: * -> *) (f46 :: * -> *) (f47 :: * -> *) (f48 :: * -> *) (f49 :: * -> *)
00:05:47 <lambdabot>  (f50 :: * -> *) (f51 :: * -> *) (f52 :: * -> *) (f53 :: * -> *) (f54 :: * -> *) (f55 :: * -> *) (f56 :: * -> *) (f57 :: * -> *) (f58 :: * -> *) (f59 :: * -> *) (f60 :: * -> *) (f61 :: * -> *) (f62 :
00:05:49 <lambdabot> [38 @more lines]
00:06:07 <ClaudiusMaximus> !
00:06:07 <tolkad> =D
00:06:40 <ski> bad boy/girl !
00:06:49 <kmc> dear lord
00:06:50 <pastorn> :D
00:06:53 <ClaudiusMaximus> @pl \ a b c d e f g -> g a b c d e f
00:06:53 <lambdabot> (((((((flip .) . flip) .) . flip) .) . flip) .) . flip . flip id
00:07:37 <pastorn> ClaudiusMaximus: don't you wish you were using lisp right now?
00:07:53 <ClaudiusMaximus> no
00:08:00 <dolio> Why would anyone wish that?
00:08:07 <tolkad> @more
00:08:07 <kmc> i think lisp is a pretty cool language
00:08:18 <pastorn> ClaudiusMaximus: haha, just quote that and put the last one first etc.
00:08:26 <kmc> tolkad, in GHC you can actually say «data [] a = [] | a : [] a»
00:08:28 <tolkad> it has parentheses and doesn't afraid of anything
00:08:32 <kmc> but only in magical modules
00:08:37 <kmc> (those in the base package, iirc)
00:08:50 <kmc> tolkad, :D
00:09:21 <ski> tolkad : look like how you're making lambdabot feel : <http://users.elis.ugent.be/~kehoste/haskell-blah/lambdabot_dcoutts.png>. now apologize to her (using `@vixen Oh great lambdabot, I know I'm not worthy to address you, but ..') !
00:11:18 <Wolfspaw> How can i do that: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28457#a28457 ?
00:11:34 <kmc> :t zipWith
00:11:35 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
00:11:58 <kmc> is that it?
00:12:00 <Wolfspaw> kmc hm, thanks! that's exactly what i was looking for :-D
00:12:03 <wioux> Data.List.subsequences gives *subsets* ..grr
00:12:43 <Wolfspaw> kmc: sorry for asking too much questions xD, i remember you answering some.
00:12:44 <dolio> > subsequences [2,2,2]
00:12:44 <lambdabot>   [[],[2],[2],[2,2],[2],[2,2],[2,2],[2,2,2]]
00:12:48 <Wolfspaw> kmc: *many
00:13:03 <ski> (looks more like bags than sets ..)
00:13:12 <dolio> > subsequences [2,3,2,3]
00:13:13 <lambdabot>   [[],[2],[3],[2,3],[2],[2,2],[3,2],[2,3,2],[3],[2,3],[3,3],[2,3,3],[2,3],[2,...
00:13:19 <wioux> > subsequences "abc"
00:13:20 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
00:13:37 <kmc> Wolfspaw, i am here to answer questions :)
00:13:39 <kmc> also to ask some
00:13:43 <kmc> and to learn from what others ask/answer
00:13:48 <wioux> just meant "ac" is in there.. not to imply uniqueness of elements
00:13:49 <dolio> I'm not sure why "ac" is in there.
00:14:36 <wioux> > (length $ subsequences [1,2,3,4, 5, 6]) == 2 ^ 6
00:14:37 <lambdabot>   True
00:14:53 <ski> well, it's not giving *contiguous* subsequences, for sure
00:15:04 <kmc> i really appreciate the fact that nearly everyone here has something to learn, and something to teach
00:16:16 <kmc> we don't have an official separation between novices and experts, people just stick around if they like and become more and more useful
00:17:19 <ski> > inits =<< tails "abcd"
00:17:20 <lambdabot>   ["","a","ab","abc","abcd","","b","bc","bcd","","c","cd","","d",""]
00:17:20 <ski> > tail . inits =<< tails "abcd"
00:17:20 <ski> > [] : (tail . inits =<< tails "abcd")
00:17:21 <lambdabot>   ["a","ab","abc","abcd","b","bc","bcd","c","cd","d"]
00:17:21 <lambdabot>   ["","a","ab","abc","abcd","b","bc","bcd","c","cd","d"]
00:17:34 <Wolfspaw> kmc hehe, nice. The community of haskell is really great ^^, maybe the best community in programming languages: its composed of great mathematicians, scientists, programmers. And everyone is nice and polite O_O
00:17:48 <kmc> and i can't speak for everyone, but i've been Haskelling for years and i still learn something here every day
00:18:01 <ClaudiusMaximus> @instances-importing IArray
00:18:01 <lambdabot> Couldn't find class `IArray'. Try @instances-importing
00:18:09 <ski> wioux : something like that ?
00:18:19 <ski> wioux : or you want them ordered first by length ?
00:18:23 <dark> I can't do import Parsec in ghci (but I have it installed, with have programs that use it)
00:18:27 <c_wraith> @instances-importing Data.Array IArray
00:18:28 <lambdabot> Couldn't find class `IArray'. Try @instances-importing
00:18:33 <dobblego> @hoogle f (a -> b) -> f a -> f b
00:18:34 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
00:18:34 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
00:18:34 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
00:18:50 <kmc> dark, the module name is Text.Parsec or (in older versions) Text.ParserCombinators.Parsec
00:19:00 <kmc> dark, some old papers have it as just "Parsec"
00:19:08 <wioux> no order necessary.. i did `subsequences (a:as) = tail (inits (a:as)) ++ subsequences as` -- is yours better?
00:19:11 <kmc> http://hackage.haskell.org/package/parsec -- for doc of latest version
00:19:36 <ski> wioux : it's basically the same
00:19:37 <ClaudiusMaximus> there appears to be no    instance IArray UArray (Complex Float)   which happens to be the one i want :(
00:19:38 <ski> @src inits
00:19:38 <lambdabot> inits []     =  [[]]
00:19:39 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
00:19:42 <ski> @src tails
00:19:42 <lambdabot> tails []         = [[]]
00:19:43 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
00:20:09 <wioux> ski: yours is using the fact that list is a monad, right?
00:20:09 <dark> kmc, hmm, Text.ParserCombinators.Parsec works here, thanks..(so maybe I'm using an outdated version?)
00:20:28 <ski> wioux : yes .. you can replace `(=<<)' with `concatMap', if you prefer
00:20:31 <ski> @type concatMap
00:20:32 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
00:20:34 <ski> @type (=<<)
00:20:34 <kmc> dark, still works in new version too
00:20:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
00:21:01 <dobblego> @hoogle a -> b
00:21:01 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
00:21:02 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
00:21:02 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
00:21:15 <dobblego> @djinn a -> b
00:21:15 <lambdabot> -- f cannot be realized.
00:21:21 <ski> @src [] (>>=)
00:21:22 <lambdabot> xs >>= f     = concatMap f xs
00:21:34 <dark> gentoo has 2.1.0.0 packaged.. and 2.1.0.1
00:21:50 <dark> I could install 3.1.0 with cabal I suppose
00:22:51 <ski> > tails =<< inits "abcd"  -- different ordering
00:22:52 <lambdabot>   ["","a","","ab","b","","abc","bc","c","","abcd","bcd","cd","d",""]
00:22:54 <deteego> man I just went through the biggest dependancy hell in installing a haskell program...
00:23:06 <ski> > init . tails =<< inits "abcd"
00:23:07 <lambdabot>   ["a","ab","b","abc","bc","c","abcd","bcd","cd","d"]
00:23:12 <ski> > [] : (init . tails =<< inits "abcd")
00:23:13 <lambdabot>   ["","a","ab","b","abc","bc","c","abcd","bcd","cd","d"]
00:23:59 <wioux> ski: can they be efficiently ordered by longest length? (i suspect no?)
00:24:24 <ski> wioux : i'm pondering that atm ..
00:24:38 <ski> (hm, you want longest first or shortest first ?)
00:25:25 <kmc> happy august everyone
00:25:29 <wioux> ski: longest first
00:26:16 <wioux> ski: not sure it matters, depending on how `subsequence' matches up against `maximumBy'
00:26:20 <prsteele> kmc: west coast?
00:26:34 <kmc> east coast here, just slow on the uptake
00:26:45 <prsteele> kmc: ah
00:29:55 <wioux> ski: don't think it matters, won't hurt to sort. thanks
00:31:20 <dolio> > let f [] = [] ; f l = [init l, tail l] ; g ([]:_) = [[]] ; g ls = ls ++ g (ls >>= f) ; h l = g [l] in h [1,2,3]
00:31:21 <lambdabot>   [[1,2,3],[1,2],[2,3],[1],[2],[2],[3],[]]
00:31:30 <dolio> Oops.
00:31:32 <dolio> Oh well.
00:31:36 <poljp> q for you. I have data ExprT e = Number Double | Var String | Add e e deriving (...). If I do :t Add 3 4, I get ExprT Integer. Is there anyway i can get it to force it to do ExprT e, and wrap the ints in Number ?
00:32:19 <kmc> you want something of type (Fix ExprT)?
00:32:21 <kmc> @src Fix
00:32:22 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:32:23 <c_wraith> Why do you have a type variable anyway?
00:32:25 <kmc> err sorry
00:32:26 <kmc> @src Mu
00:32:27 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
00:32:30 <kmc> so (Mu ExprT)
00:32:52 <poljp> kmc : yes i have a lot of that.
00:33:01 <kmc> poljp, what you're doing is not the typical way to write a recursive data type in haskell, but can be useful for specialized purposes
00:33:21 <dark> if two instances of a type class (say Show) has different definitions for some function, a different function will be compiled for each matching? (like C++ overloading/templates)
00:34:01 <kmc> it's not really much like C++, but yes, type classes allow the implementation of a function to be chosen based on its type
00:34:02 <poljp> i have later on newtype Fx ExprT = InF {outF :: Expr} deriving (Eq,Show,Ord,Num,Fractional)
00:34:15 <c_wraith> dark, dictionary-passing is used by default
00:34:25 <kmc> err that can't be poljp, ExprT isn't a type variable
00:34:40 <kmc> poljp, why are you doing the recursion the more roundabout way?
00:34:54 <poljp> there's a bit more i did paste using type families.
00:35:00 <dark> dictionary-passing?
00:35:23 <poljp> kmc : its a long story.
00:35:39 <kmc> ok
00:36:01 <kmc> poljp, anyway, if you want to overload numeric literal syntax such that «3 :: Mu ExprT», you'll need an appropriate Num instance
00:36:03 <c_wraith> dark: One implementation of functions that have a a class constraint.  Then, a dictionary of pointers to class methods is passed as an implicit first value to the function
00:36:13 <tolkad> wtf? I thought Read would look like: class Read a where read :: String -> a
00:36:35 <kmc> dark, dictionary passing is an strategy for implementing type classes.  it's not necessarily relevant if you're just trying to define/use type classes
00:36:36 <c_wraith> dark: This results in significantly less duplicated code, but at the cost of an extra level of indireciton.
00:36:39 <kmc> @src Read
00:36:39 <lambdabot> class Read a where
00:36:39 <lambdabot>   readsPrec    :: Int -> ReadS a
00:36:39 <lambdabot>   readList     :: ReadS [a]
00:36:39 <lambdabot>   readPrec     :: ReadPrec a
00:36:39 <lambdabot>   readListPrec :: ReadPrec [a]
00:36:52 <kmc> tolkad, you're wondering what the other functions are for?
00:36:56 <tolkad> yeah
00:37:03 <tolkad> I want to create an implementation
00:37:15 <tolkad> s/implementation/instance/
00:37:18 <kmc> Read is an unhappy class, i rarely implement it unless derived
00:37:32 <kmc> @src ReadS
00:37:32 <lambdabot> Source not found. stty: unknown mode: doofus
00:37:38 <ivanm> @type ReadS
00:37:39 <lambdabot> Not in scope: data constructor `ReadS'
00:37:42 <kmc> type ReadS a = String -> [(a, String)]
00:37:47 <kmc> this is the type of a parser
00:37:51 <ivanm> yeah, there's some way of getting lambdabot to do that
00:37:59 <kmc> takes a string, returns zero or more possible parses, each with a value and a remaining leftover string
00:38:39 <tolkad> actually, I would like it much more if it was class Read a where read :: String -> Maybe a
00:38:46 <kmc> that's not composable though
00:38:47 <poljp> kmc : what i am really trying to do is to be able to take "lift" a value such as "ya2 = Mul (Div (Number 5) (Var "x")) (Add (Number 5) (Number 4.1))" without having to write it as "ya = Mul (mf $ Div (mf $ Number 5) (mf $ Var "x")) (mf $ Add (mf $ Number 5.0) (mf $ Neg (mf $ Number 4.1)))"
00:39:01 <kmc> oh i see poljp
00:39:04 <kmc> that's tricky
00:39:08 <kmc> you can define smart constructors
00:39:16 <tolkad> anyway, I do not like Read
00:39:18 <kmc> div x y = mf $ Div x y
00:39:28 <kmc> tolkad, readsPrec is the most general, it takes a precedence level and returns a parser
00:39:45 <poljp> ah yeah, could do that.
00:39:49 <kmc> readList is for making special syntax for lists... "abcd" is a special syntax for [Char]
00:39:58 <kmc> the other two are not in Prelude, i think they're GHC-specific
00:40:00 <poljp> that works for my situation too, (which is as you'd expect a sort of edsl)
00:40:44 <kmc> tolkad, i too do not like Read
00:41:26 <tolkad> mostly because reading something can result in an error
00:41:28 <ski> > let subSequences = join loop where loop [] as = return as; loop (_:n) ~(a:as) = do f <- [id,(a:)]; f `liftM` loop n as in subSequences "abc"
00:41:29 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
00:41:34 <tolkad> and I have no idea how to deal with errors
00:41:34 <ski> > let subSequences = join loop where loop [] as = return as; loop (_:n) ~(a:as) = do f <- [(a:),id]; f `liftM` loop n as in subSequences "abc"
00:41:35 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
00:41:39 <ski> > let subSequences = join loop where loop [] as = return as; loop (_:n) ~(a:as) = do as <- loop n as; ($ as) `liftM` [id,(a:)] in subSequences "abc"
00:41:40 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
00:41:44 <kmc> tolkad, you can use reads
00:41:45 <kmc> :t reads
00:41:46 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:41:47 <ski> > let subSequences = join loop where loop [] as = return as; loop (_:n) ~(a:as) = do as <- loop n as; ($ as) `liftM` [(a:),id] in subSequences "abc"
00:41:48 <lambdabot>   ["abc","bc","ac","c","ab","b","a",""]
00:41:54 <kmc> :t map fst . reads
00:41:56 <lambdabot> forall a. (Read a) => String -> [a]
00:41:57 <ski> wioux : some variants
00:41:58 <kmc> :t listToMaybe . map fst . reads
00:42:00 <lambdabot> forall a. (Read a) => String -> Maybe a
00:42:01 <kmc> tolkad, ^^^^
00:42:14 <kmc> though this does not check that the whole input string was consumed
00:42:32 <tolkad> kmc: isn't that inefficient? or does it get optimized?
00:42:33 <kmc> :t \x -> case reads x of [(v,"")] -> Just v; _ -> Nothing
00:42:34 <lambdabot> forall a. (Read a) => String -> Maybe a
00:42:37 <kmc> ^^^^ this one does
00:42:39 <kmc> tolkad, inefficient how?
00:43:33 <tolkad> kmc: well, it looks like it puts it in a list and takes it back out
00:43:43 <kmc> probably fine, due to the magic of laziness
00:43:46 <kmc> but also, don't worry about it
00:43:58 <kmc> you're not going to use Read for high-performance parsing
00:44:05 <kmc> you're not going to use String for high-performance parsing
00:44:15 <tolkad> why not?
00:44:21 <kmc> if you profile and it's really a bottleneck then come back to it
00:44:27 <kmc> String is tremendously inefficient
00:44:35 <tolkad> then why is it in haskell?
00:45:01 <kmc> because it's simple and fully lazy
00:45:12 <kmc> it's just [Char], that is, a lazy singly-linked list of boxed lazy characters
00:45:19 <tolkad> GHC should just optimize it then so it isn't inefficient
00:45:27 <tolkad> that would be better
00:45:31 <kmc> it will in some simple cases
00:45:41 <tolkad> and better is better than worse
00:46:14 <kmc> GHC should just optimize my code to the fastest possible code with the same behavior
00:46:31 <kmc> anyway, as lists, strings are subject to fusion of list operations
00:46:38 <kmc> which would help in some cases
00:47:14 <kmc> if you can figure out fancier list optimizations that preserve the original semantics
00:47:16 <tolkad> kmc: that's not computable
00:47:19 <kmc> then i think we'd all like to hear about it
00:47:50 <kmc> it's worth an ICFP paper
00:47:56 <kmc> e.g. http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
00:48:00 <tolkad> kmc: because Kolmogorov complexity isn't. and if that was computable then Kolmogorov complexity would be
00:48:03 <kmc> yes
00:48:05 <wioux> > inits [1..]
00:48:06 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
00:48:44 <kmc> anyway, there are plenty of data types for bytes or text with different semantics and much higher performance than String
00:49:01 <tolkad> ByteString?
00:49:36 <kmc> e.g. bytestring, rope, text, utf8-string
00:49:45 <kmc> and IO and parser libraries which work with them
00:50:29 <kmc> i think String is a sensible default for beginners and for situations where performance doesn't much matter
00:51:44 <kmc> similarly, there is Prelude.lookup for assoc lists, but if you care about performance you'd use Data.Map instead, or something even better
00:53:42 <ivanm> kmc: what is there that's better than Data.Map?
00:54:16 <dolio> Depends on the keys.
00:54:24 <kmc> for Int keys, Data.IntMap is usually better
00:54:59 <kmc> for other things, you can use the "hashmap" library, which is effectively IntMap (Map k v), with a first round of hashing to make the inner maps small
00:55:21 <kmc> for read-only stuff you could use a flat array, for some key types
00:55:38 <kmc> there's also various trie libraries
00:55:41 * hackagebot haskell-updater 1.1.2.0 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.1.2.0 (IvanMiljenovic)
00:55:44 <kmc> for ints, bytestrings, lists
00:55:54 <ivanm> kmc: oh, I meant a general purpose one like Data.Map
00:55:55 <kmc> data-memocombinators builds a lazy infinite trie from a function
00:56:00 <ivanm> I knew about IntMap
00:56:21 <kmc> and then there's plenty of mutating options... MUArray, vector, judy, ...
00:56:44 <kmc> Data.Map requires only Ord, and so i doubt you can do much better while staying as general
00:56:55 <kmc> of course there are plenty of schemes for balancing binary trees
00:57:40 <kmc> e.g. you could implement AVL trees or red-black trees or treaps, and benchmark it against Data.Map's bounded-balance trees
00:57:51 <kmc> i don't expect it to matter that much, but i'm no expert
00:58:20 <ivanm> well, IIRC the reason Data.Map doesn't balance is that in practice apparently it performs better without it due to random insert/deletes vs the cost of continually re-balancing
00:59:28 <kmc> it doesn't balance?
00:59:56 <c_wraith> it does, but only rarely
01:00:17 <c_wraith> it uses a metric that balances only when the longest paths are like 10x shorter than the shortest
01:00:21 <c_wraith> or something like that
01:04:28 <ski> > let foo :: Num a => [a] -> ([a],[a] -> [a]); foo [] = ([],\as -> as); foo (a:as0) = (a:as1,\as2 -> 10 + a : as2)) where (as1,k) = foo as0 in uncurry (flip id) (foo [0,1,2])
01:04:29 <lambdabot>   <no location info>: parse error on input `)'
01:04:49 <ski> > let foo :: Num a => [a] -> ([a],[a] -> [a]); foo [] = ([],\as -> as); foo (a:as0) = (a:as1,\as2 -> k (10 + a : as2)) where (as1,k) = foo as0 in uncurry (flip id) (foo [0,1,2])
01:04:50 <lambdabot>   [12,11,10,0,1,2]
01:05:01 <ski> > let foo :: Num a => [a] -> ([a],[a] -> [a]); foo [] = ([],\as -> as); foo (a:as0) = (a:as1,\as2 -> 10 + a : k as2) where (as1,k) = foo as0 in uncurry (flip id) (foo [0,1,2])
01:05:02 <lambdabot>   [10,11,12,0,1,2]
01:05:07 <ski> > let foo :: Num a => [a] -> ([a] -> [a]) -> [a]; foo [] k = k []; foo (a:as0) k = a : foo as0 (\as1 -> k (10 + a : as1)) in foo [0,1,2] id
01:05:08 <lambdabot>   [0,1,2,10,11,12]
01:05:11 <ski> > let foo :: Num a => [a] -> ([a] -> [a]) -> [a]; foo [] k = k []; foo (a:as0) k = a : foo as0 (\as1 -> 10 + a : k as1) in foo [0,1,2] id
01:05:12 <lambdabot>   [0,1,2,12,11,10]
01:08:10 <ski> @djinn (s,t -> u) -> ((s -> t) -> u)
01:08:10 <lambdabot> f (a, b) c = b (c a)
01:08:21 <ski> @djinn ((s -> t) -> u) -> (s,t -> u)
01:08:21 <lambdabot> -- f cannot be realized.
01:12:56 <tolkad> in this code... what is a? type ReadS a = String -> [(a, String)]
01:12:59 <tolkad> is it a type?
01:13:03 <ivanm> yes
01:13:08 <dobblego> forall a. 
01:13:11 <ivanm> just like you have "Maybe a"
01:13:14 <ivanm> @src Maybe
01:13:15 <lambdabot> data Maybe a = Nothing | Just a
01:13:15 <dobblego> it's a polymorphic type
01:13:18 <tolkad> oh, I see
01:13:25 <ski> dobblego : no. it is a parametric type
01:13:34 <dobblego> yes
01:14:10 <tolkad> and uh what's the String supposed to be?
01:14:24 <dobblego> "rest of input after parsing"
01:14:25 <ski> dobblego : e.g. `forall a. ReadS a', or `forall a. ReadS a -> String -> Maybe a', would be types of polymorphic operations
01:14:37 <tolkad> ok thanks
01:14:38 <dobblego> ski, right
01:15:02 <dobblego> > reads "123 abc" :: [(Int, String)]
01:15:03 <lambdabot>   [(123," abc")]
01:16:27 <ski> dobblego : also, in `newtype Flip f b a = MkFlip {unFlip :: f a b}' (using e.g. <http://monoidal.blogspot.com/2010/07/kind-polymorphism-in-action.html>), `Flip' is a polymorphic type, it has the kind `forall k0 k1. (k0 -> k1 -> *) -> (k1 -> k0 -> *)'
01:18:29 <ski> (it would be even better if it got kind `forall k0 k1 k2. (k0 -> k1 -> k2) -> (k1 -> k0 -> k2)', but i don't think UHC supports that)
01:19:19 <dolio> I don't see how it could.
01:19:42 <ski> well, i have a loose idea of being able to say
01:19:58 <ski>   newtype k (Flip f b a) = MkFlip {unFlip :: k (f a b)}
01:20:19 <dark> how to write the function \x -> "Test" ++ x without the x parameter? (is it even possible?)
01:20:27 <ski> if that works out ok, then `Flip' could get kind `forall k0 k1 k2. (k0 -> k1 -> k2) -> (k1 -> k0 -> k2)'
01:20:28 <dolio> Yes, but there, k must be k2 -> *
01:20:31 <ski> yes
01:20:35 <dark> I think the bot has some command to try this convertion
01:21:05 <ski> dark : `("Test" ++)'
01:21:20 <ski> @pointless \x -> "Test" ++ x
01:21:20 <lambdabot> ("Test" ++)
01:21:35 <dark> õ.o
01:21:36 <ski> dark : also `(++) "Test"'
01:21:55 <ski> (if it was the right argument that was given, one could use `flip')
01:22:09 <dark> (++) "Test" is \x -> x ++ "Test"
01:22:10 <ski> > let f = flip (++) "Test" in f "___"
01:22:11 <lambdabot>   "___Test"
01:22:16 <ski> dark : no
01:22:25 <ski> > (++) "Test" "___"
01:22:26 <lambdabot>   "Test___"
01:22:33 <ski> > (\x -> x ++ "Test") "___"
01:22:33 <lambdabot>   "___Test"
01:23:36 <ski> dark : `(++) "Test"' is `("Test" ++)', which is `\s -> "Test" ++ s'
01:24:02 <ski> `(++)' is a function that first takes the left argument to `++', then the right argument
01:24:32 <dark> hm @.@ I'm following learn you a haskell, main = interact $ unlines . filter ((<10) . length) . lines   is an interesting piece of code..
01:24:56 <dark> main = interact $ unlines . map ((++) "Test") . lines is the modification I was trying to do
01:25:32 <ski> that will prepend the text `Test' in front of each line
01:27:10 <ski> dark : btw, using the utility function at <http://www.haskell.org/haskellwiki/Tangible_Value#IO>, you could write
01:27:33 <ski>   main = interact (onLines (filter ((<10) . length)))
01:27:35 <ski> respectively
01:27:49 <ski>   main = interact (perLine ("Test" ++))
01:28:34 <dark> I'm now looking on how output "> " before reading. I think interact can't do that
01:28:56 <ski> output `> ' in front of each line ?
01:29:31 <dark> no, output before reading the line (not quite the same thing; there is a snippet there that does this with forever $ do ..)
01:30:22 <ski> (a snippet where ?)
01:31:07 <kmc> interact is not good for, err, real interaction
01:31:12 <kmc> it's good for batch input/output filters
01:31:26 <kmc> but working out what will be read and printed when exactly is tricky
01:31:27 <ski> it can be used interactively, too :)
01:31:29 <dark> http://learnyouahaskell.com/input-and-output
01:31:34 <ski> (but it is a bit clunky, yes)
01:31:39 <kmc> as with all lazy IO
01:32:07 <dark> but in order to work I need to put some flush after the prompting
01:32:18 <dark> "hFlush"
01:33:17 <ski> dark : .. or make the argument given to `interact' having the right amount of laziness/strictness
01:35:42 <kmc> if you're a beginner, using lazy IO and going to pains to control laziness/strictness is the wrong way around
01:35:52 <kmc> the point of Haskell IO is that we *don't* use evaluation order to drive execution order
01:36:03 <kmc> lazy IO is a weird exception to this
01:36:17 <dark> but, is there strict io?
01:36:20 <kmc> yes
01:36:27 <dark> but anyway, i found the concept of lazy io interesting
01:36:40 <kmc> getLine, putStrLn, etc.
01:36:41 <stragerLN> @data Maybe
01:36:41 <lambdabot> Unknown command, try @list
01:36:44 <kmc> it is an interesting idea
01:36:47 <ski> (/me wouldn't say it's so much execution order as it is dependency order ..)
01:36:52 <stragerLN> @src Maybe
01:36:52 <lambdabot> data Maybe a = Nothing | Just a
01:37:02 <kmc> but a proper treatment of lazy IO in Haskell is fairly complicated
01:37:03 <dark> I want the reading to be as lazy as it is now, and the output to have a less lazy "> ", and a lazy result, and a less-lazy "> "..
01:37:08 <kmc> not a beginner topic, imo
01:44:38 <dark> main = forever $ do { putStr "> "; hFlush stdout; l <- getLine; putStrLn $ "Test" ++ l } works
01:44:47 <dark> not as elegant as interact, but
01:57:12 <dolio> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28462#a28462
02:02:03 <dark> dolio, interesting o.o'
02:02:14 <dark> but it is outputting > after my first input
02:02:27 <chrisdone> ciao
02:02:29 <dark> also, hello: Prelude.read: no parse
02:02:34 <dark> hi chrisdone
02:02:56 <dolio> What?
02:03:12 <dolio> If typing in "hello" causes that error, then that isn't surprising.
02:03:20 <dolio> But the buffering works fine here.
02:03:33 <chrisdone> > read "\"hello\"" :: String
02:03:34 <lambdabot>   "hello"
02:04:12 <dark> yes, the prompt is actually working fine
02:04:21 <dark> dolio, why have you disabled buffering?
02:04:42 <dolio> Because if you don't, it won't print anything until something else triggers a flush.
02:05:09 <dolio> Like, you pressing enter.
02:05:35 <mauke> disabling buffering is generally a bad idea
02:05:42 <dark> well, I was flushing manually.. but, yes, this is interesting
02:06:17 <dark> ghci disables buffering, it seems
02:08:54 <ski> dark : fwiw, `main = do hSetBuffering stdout NoBuffering; interact . fix $ \loop s0 -> let (l,s1) = span (/= '\n') s0 in "> " ++ reverse l ++ case s1 of "" -> ""; '\n':s2 -> '\n' : loop s2' works fine, here ..
02:09:35 * copumpkin yawns
02:09:40 <copumpkin> ski: did you succeed?
02:10:32 <ski> copumpkin : .. with ?
02:10:37 <copumpkin> oh that complex type
02:10:45 <ski> .. oh, `TraverseType'
02:11:38 <ski> i got `jsr'ed into how to construct the type into multiple stages, and from there to continuation monad and state-in-context comonad
02:11:48 <ski> haven't found the `rts', yet
02:12:01 <copumpkin> :)
02:12:35 <ski> (i think i want to write `TraverseType' in CPS, but i'm not quite sure how, yet)
02:13:08 <copumpkin> I sort of CPSed it 
02:13:18 <copumpkin> I don't think I could avoid it
02:14:29 <copumpkin> writing the function itself is even more challenging though
02:18:27 <dark> ski, I'm trying to figure out how your code works..
02:18:43 <dark> do you know how to make Ctrl+D work with unbuffered i/o?
02:24:49 <ski> dark : my code handles end-of-file correctly .. but if you're running it in GHCi, it will not work, for some reason
02:25:03 <ski> try using `runhaskell', or compile it
02:35:10 <dark> ski, I compiled it.. with ghc --make hello
02:35:47 <dark> and, hmm, yes, ctrl+d is being handled correctly..
02:38:33 <ski> (hm, btw, if i pipe into GHCi, instead of connecting it to a terminal, it appears it handles end-of-file as expected)
02:59:38 <ski> copumpkin : actually, for some reason, i realized it was easier to think about the problem (`TraverseType') in Prolog .. and it appears to work :)
03:00:59 <ski> copumpkin : well, sort of CPS, of course (more specifically nqCPS .. hm, that suggests using delimited/composable continuations to generate the type ..)
03:09:11 <copumpkin> :o
03:11:26 <copumpkin> Adjunction :: (Functor f, Functor g, Category c, Category d, Dom f ~ d, Cod f ~ c, Dom g ~ c, Cod g ~ d) => f -> g -> Nat d d (Id d) (g :.: f) -> Nat c c (f :.: g) (Id c) -> Adjunction c d f g
03:12:56 <copumpkin> pretty hardcore type :)
03:14:12 * ski still ponders how to translate the Prolog relational definition into a functional definition, though ..
03:14:40 <copumpkin> I can show you my monster if you want ideas
03:14:43 <copumpkin> it's not pretty though
03:15:21 <copumpkin> maybe one day I'll make it universe-polymorphic
03:16:12 <copumpkin> writing the definition of this function is such a pain
03:16:16 <copumpkin> the type was hard enough
03:16:31 <ski> bah, this is _fun_ !
03:17:01 <copumpkin> it is fun! it's a challenge unlike other challenges I've had in agda so far :P
03:17:13 <copumpkin> it's a nice break from my massive proof
03:17:42 <copumpkin> omg fake Cale
03:17:50 <copumpkin> omg CAle on an ipod
03:18:01 <Nibble> what is the cabal package for hsdl called?
03:18:25 <copumpkin> http://hackage.haskell.org/package/SDL ?
03:18:36 <Nibble> that's the one
03:18:42 <copumpkin> :)
03:18:56 <Nibble> copumpkin: I tried hsdl, but it couldn't find it
03:20:45 <Nibble> one does not have to import Prelude right?
03:20:50 <Nibble> I see numerous of guides doing it
03:20:59 <copumpkin> only if you want to do non-standard stuff
03:21:08 <copumpkin> like not get the entire prelude
03:21:22 <copumpkin> import Prelude hiding (($)) maybe
03:22:17 <Nibble> oh ok, but I see "import Prelude" on places, without any other stuff
03:22:37 <Nibble> and when installing some packages through cabal I get warnings about programs trying to do import Prelude
03:23:05 <copumpkin> maybe they're just silly :)
03:23:07 <copumpkin> dunno
03:28:33 <Nibble> Even a C library in haskell is awesome.
03:29:53 * copumpkin steals Cale's iPod
03:35:49 <Nibble> copumpkin: when compiling with ghc, I get undefined reference to SDL* things
03:35:54 <Nibble> like flip, blitSurface etc
03:36:00 <Nibble> how do I link a library?
03:36:09 <copumpkin> hmm, didn't think it was necessary
03:36:13 <copumpkin> -lsdl maybe?
03:36:17 <copumpkin> are you using --make?
03:38:37 <Nibble> copumpkin: I just do ghc myfile.hs
03:38:49 <copumpkin> then do ghc --make
03:39:10 <Nibble> oh fuck, I might not have sdl installed. will try it(only hsdl, not sdl) so I might be missing the libs
03:39:30 <copumpkin> ghc with --make should generally take care of any linking needs you have
03:39:49 <Nibble> copumpkin: ok
03:40:12 <Nibble> there it works
03:46:39 <dark> the emacs' haskell major mode does not specify the tab key as being the right amount of ident, right? here, tabs aren't idempotent..
03:47:21 <dark> i was hoping to grasp some of haskell customary style on indentation
03:47:35 <dark> right amount of indentation*
03:48:24 <dark> there is actually 3 indentation modules, and there doesn't seem to have a default, o.o
03:48:47 <Nibble> wow, wtf
03:48:55 <Nibble> hsdl gives error messages! so no error checking
03:48:56 <Nibble> great
03:51:44 <dark> haskell indent modes are just like.. python, o.o
03:52:03 <dark> ahhh.. haskell blocks are whitespace-aware
03:52:25 <dark> that's the trick to eliminate { } at do, right
03:53:14 <Nibble> dark: I think so
03:53:16 <copumpkin> ski: I think your argument order is prettier but it makes it harder to write the function
03:53:22 <copumpkin> (for traverseN)
03:53:30 <Nibble> copumpkin: what argument order?
03:53:50 <copumpkin> for a function we're trying to make variadic
03:54:29 <Nibble> copumpkin: can you do that in haskell?
03:54:42 <copumpkin> yeah, with some difficulty
03:54:47 <copumpkin> but I'm not doing it in haskell
03:54:58 <Nibble> copumpkin: then what language?
03:55:13 <copumpkin> agda, which is somewhat related (and thus I argue is still on-topic :P)
03:55:33 <Nibble> copumpkin: sure, haskell, agda, what's the difference?
03:55:48 <copumpkin> :P
03:55:54 <copumpkin> they look superficially similar
03:56:14 <Nibble> copumpkin: Prolog looks almost like haskell too
03:56:26 <copumpkin> not sure I'd say that :P
03:56:38 <dark> I would think that haskell wouldn't let  you code variadic functions; how would this interact with currying?
03:57:04 <dark> (i mean, in haskell, not agda)
03:57:10 <copumpkin> it takes a lot of type-level magic and is a pain to work with
03:57:17 <copumpkin> here, let me code up a simple example
03:57:18 <Nibble> dark: what ^ wrote
03:57:31 <Nibble> there isn't even an example on WP
03:57:48 <Nibble> copumpkin: care to submit the code to wikipedia?
03:57:59 <copumpkin> it's pretty esoteric
03:58:04 <dark> at haskell article? or variadic function?
03:58:04 <copumpkin> but maybe
03:58:15 <dark> you could submit to "esoteric programming"
03:58:30 <Nibble> dark: variadic function
03:58:32 <dom96> There is a lot of examples if you search 'haskell variadic functions' in google ;)
03:58:42 <Nibble> dom96: sure there is, but copying them would be illegal
03:58:59 <Nibble> if not declared otherwise, the writer has copyright on it
03:59:23 <copumpkin> well, there's printf
03:59:26 <copumpkin> but I'm doing it differently
03:59:44 <copumpkin> > printf "%s omg %s" "wtf" "how does this work??" :: String
03:59:45 <lambdabot>   "wtf omg how does this work??"
04:00:06 <copumpkin> > printf "%s omg %s %s %d" "wtf" "how does this work??" "confused yet?" 5 :: String
04:00:07 <lambdabot>   "wtf omg how does this work?? confused yet? 5"
04:00:12 <dom96> Nibble: i doubt people would copyright examples.
04:00:27 <Nibble> dom96: they are copyrighted
04:00:30 <Nibble> unless specified otherwise
04:01:04 <Nibble> dom96: so if you paste code on some forum, the other guy can't use it legally(not that anyone would care) unless you wrote that he could, or that it was under GPL or some other license
04:02:32 <dark> > :t printf
04:02:33 <lambdabot>   <no location info>: parse error on input `:'
04:02:36 <dark> :t printf
04:02:37 <lambdabot> forall r. (PrintfType r) => String -> r
04:02:41 <dark> :t printf "%s"
04:02:43 <lambdabot> forall r. (PrintfType r) => r
04:02:55 <dark> :t printf "%s %d"
04:02:56 <lambdabot> forall r. (PrintfType r) => r
04:03:09 <dark> :t printf "%s %d" "a"
04:03:10 <dom96> Nibble: oh, i didn't know that. But what are the chances of that person actually suing you for doing that.
04:03:11 <lambdabot> forall t. (PrintfType ([Char] -> t)) => t
04:03:28 <copumpkin> almost done with my example
04:04:24 <ski> (Nibble : hm, doesn't the work have reach to a certain threshold of originality before being elible to copyright, or something like that ?)
04:04:41 <ski> (s/reach to/to reach/)
04:05:15 <ski> > printf "%d" "foo" :: String
04:05:16 <lambdabot>   "*Exception: Printf.printf: bad argument
04:05:38 <dark> at ocaml, (printf "%s") has type string -> unit, (printf "%s %d") has type string -> int -> unit, etc.. so the magic goes away when you specify the format string
04:06:11 <ski> dark : i've never really gotten how O'Caml handles `printf' ..
04:06:12 <Nibble> dom96: as I wrote, not that anyone would care :P So add "all code I write here is licensed under XXX unless other specified or something. Makes for good habit
04:06:27 <Nibble> ski: probably, but that is a floating limit
04:06:44 <dark> ski, it has type ('a, out_channel, unit) format -> 'a, that is, "%s" isn't actually a string in that context
04:06:56 <ski> yes, that last part is what's bugging me
04:07:09 <ski> the  ('a, out_channel, unit) format  thing i'm ok with
04:07:14 <dark> so you can't receive a string from stdin and pass it as the first parameter to printf
04:07:28 <ski> yes .. it seems like a kludge, imo
04:07:44 <dom96> Nibble: oh, ok :P
04:07:55 <dark> well, it prevents a runtime type error, like.. what if there is no %s in the input? @.@
04:08:06 <ski> (basically, whenever `printf' is syntactically applied to a string literal, some macro rewriting happens .. afaui)
04:08:15 <dark> if you generate the string by a computational process, you can't ensure there will ever be any %son it
04:08:31 <dark> hmmm.. macro rewritting? @.@'
04:08:50 <dark> no i don't know how the magic happens, but it seems interesting @.@
04:08:55 <ski> dark : well, you could if you're in a dependently typed programming language, and place constraints on what strings your input can be ;)
04:09:21 <ski> dark : yeah, an ad-hoc case of macro expansion, i assume
04:09:55 <dark> can haskell read a line from stdin,then pass it to printf?
04:10:39 <ski> (as opposed to real macro systems like in the lisps, and to some extent Template Haskell; also Meta(ML|OCaml) are comparable .. i'm not sure whether CamlP4 qualify)
04:11:34 <ski> dark : sure, but as you saw above, you can get run-time errors, if the input format doesn't match the (more or less) statically decided type
04:11:55 <ClaudiusMaximus> hmm, i need   flatten :: UArray (Int, Int, Int) Word8 -> UArray Int Word8   -- ixmap seems overkill
04:11:56 <copumpkin> almost done :P
04:11:59 <ClaudiusMaximus> :t ixmap
04:12:00 <lambdabot> forall i j e. (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
04:12:45 <dark> ski, so actually, sometimes a haskell implementation has to do runtime type verification
04:12:51 <ski> > fix (`printf` "%s")
04:12:55 <lambdabot>   mueval-core: Time limit exceeded
04:13:03 <ski> dark : yes
04:13:06 <ski> also see
04:13:22 <ski> > cast False :: Maybe Bool
04:13:23 <lambdabot>   Just False
04:13:24 <ski> > cast False :: Maybe Int
04:13:25 <lambdabot>   Nothing
04:14:11 <dark> is this coercion well-defined?
04:14:28 <dark> just redefining "cast" in the type-class, right?
04:14:33 <ski> (though, note that what is checked in both the `cast' case and the `printf' case are data values .. no actual types are present at run-time)
04:14:37 <ski> @type cast
04:14:38 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
04:15:07 <copumpkin> dark, Nibble: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28464#a28464
04:15:10 <dark> @type False
04:15:11 <lambdabot> Bool
04:15:39 <dark> so Bool is a Typeable
04:15:44 <copumpkin> you can then write 
04:15:45 <copumpkin> f :: HomoVariadic (S (S (S Z))) Int Bool
04:15:45 <copumpkin> f 0 0 0 = True
04:15:49 <dark> copumpkin, I solved this with emacs -nw :~
04:15:49 <ski> basically, what this does is statically construct values corresponding to the types `a' and `b', then at run-time, those types are compared, and if they're equal, we can return `Just' the input, otherwise `Nothing'
04:16:02 <ClaudiusMaximus> :t Data.Array.array (1,1000) (Data.Array.elems (Data.Array.array ((1,1,1)(10,10,10)) (repeat 0)))
04:16:03 <lambdabot>     Couldn't match expected type `t -> (i, i)'
04:16:03 <lambdabot>            against inferred type `(t1, t2, t3)'
04:16:03 <lambdabot>     In the first argument of `array', namely `((1, 1, 1) (10, 10, 10))'
04:16:18 <ski> s/those types are compared/those values corresponding to types are compared/
04:16:22 <ClaudiusMaximus> :t Data.Array.array (1,1000) (Data.Array.elems (Data.Array.array ((1,1,1),(10,10,10)) (repeat 0)))
04:16:23 <lambdabot> forall t e. (Num t, Num e, Ix t) => Array t e
04:16:24 <dark> ah erm
04:16:44 <dark> (nevermind)
04:16:46 <ski> basically, one could imagine
04:17:01 <ski>   typeOf :: Typable a => a -> TypeRep a
04:17:26 <ski>   compareTypeRep :: TypeRep a -> TypeRep b -> Maybe (Equal a b)
04:17:36 <ski>   subst :: Equal a b -> k a -> k b
04:18:02 <ski> (but, iirc the current implementation of `Typable' and `cast' doesn't work exactly like that)
04:18:03 <copumpkin> that's cute
04:18:12 <dark> ski, but in most cases the compiler should be able to decide if it's Just X or Nothing at compile time
04:18:39 <ski> dark : sure, probably there's unfolding being done by optimizations
04:18:49 <dark> copumpkin, so how one would use a  function like that? o.o
04:19:00 <copumpkin> dark: you can call it normally :)
04:19:07 <copumpkin> f 5 3 2 will give you a bool
04:19:11 <copumpkin> or in that case crash
04:19:49 <copumpkin> dark: however, with that setup, it can't infer how many arguments you passed it
04:19:59 <copumpkin> you have to write the number in yourself, in the type
04:20:08 <dark> ah.. 
04:20:14 <copumpkin> if we could have closed, injective, type families, then it would be nice
04:20:21 <copumpkin> data families wouldn't be very pretty there
04:20:51 <dark> Vec n a.. n is a number encoded with as peano-style natural number?
04:21:16 <dark> s/with//
04:21:53 <dark> I was wondering earlier if haskell had something like C++ numeric template parameters at types
04:22:21 <copumpkin> you can build them
04:22:25 <dark> but regular algebraic types seems to be as powerful as
04:22:31 <copumpkin> Vec n a is a vector
04:22:36 <copumpkin> it's like a list with a fixed length, in the type
04:22:36 <ski> type
04:22:46 <copumpkin> pretty much everything templates can do, you can do in haskell
04:22:52 <copumpkin> especially as of type families
04:22:53 <dark> copumpkin, but, writing an int in the type?.. as a syntax sugar, at least
04:23:02 <copumpkin> yeah, no sugar yet
04:23:07 <dark> ^^
04:23:08 <copumpkin> you have to write it by hand
04:23:36 <ski> (iirc Oleg(?) made base-10 numerals in the type-system, to be able to write larger type-level numbers more compactly)
04:23:57 <copumpkin> yeah
04:24:04 <copumpkin> I've seen that, not sure it's oleg
04:24:11 <Botje> who else but oleg :)
04:24:17 <copumpkin> :P
04:24:33 <Botje> binary would also be nice
04:24:35 <copumpkin> anyway, back to the really difficult variadic function
04:24:35 <ski> well, he *is* the usual suspect, for this kind of thing .. but it *could* be someone else
04:25:03 <ski> @where oleg
04:25:04 <lambdabot> http://okmij.org/ftp/
04:25:44 <dark> would it be too difficult to write arbitrary haskell expressions in types?
04:25:57 <copumpkin> yeah
04:26:05 <copumpkin> but come to #agda and play with the idea :P
04:26:13 <ski> you can have lambdas in types in Haskell, e.g.
04:26:18 <ski> s/can/can't/
04:39:26 <proc> howdy my dear haskell fellows
04:40:40 <ClaudiusMaximus> why/if   do i have to thaw an array to be able to write it to a Handle?
04:41:03 <ClaudiusMaximus> :t Data.Array.IO.hPutArray
04:41:04 <lambdabot> GHC.IOBase.Handle -> Data.Array.IO.Internals.IOUArray Int Word8 -> Int -> IO ()
04:41:55 <ClaudiusMaximus> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28465#a28465 almost every line of this ghci session annoyed me :)
04:42:08 <ClaudiusMaximus> greeting proc 
04:45:22 <yitz> @hoogle withBinaryFile
04:45:22 <lambdabot> System.IO withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
04:45:53 <yitz> @hoogle hPutArray
04:45:53 <lambdabot> Data.Array.IO hPutArray :: Handle -> IOUArray Int Word8 -> Int -> IO ()
04:46:08 <ClaudiusMaximus> it seems to have mostly worked though (converted with GIMP) http://a.imageshack.us/img266/3318/juliat.png
04:46:49 <poljp> ah julia sets
04:46:54 <poljp> always look nice :)
04:47:37 <ClaudiusMaximus> it's currently about 1000 times slower than C, if ghci timing is to be believed
04:47:41 <yitz> ClaudiusMaximus: propose that hPutArray be added to the immutable array interface.
04:47:44 <Cale_> If all you are doing is writing it out, you could use the unsafe thaw
04:48:19 <yitz> ClaudiusMaximus: most of the other IO operations need to be in the IO mutable variety, of course, but that one could be more general
04:49:08 <ClaudiusMaximus> mm, seems so
04:49:34 <yitz> oh oh - preflex just went south
04:51:00 <yitz> ClaudiusMaximus: what else annoyed you, besides the superfluous thaw and the slow timings?
04:51:43 <ClaudiusMaximus> yitz: having to add explicit type signatures to fix the array type constructor
04:52:35 <yitz> @hoogle listArray
04:52:35 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
04:52:35 <lambdabot> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
04:52:42 <yitz> @hoogle thaw
04:52:42 <lambdabot> Data.Array.MArray thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
04:52:42 <lambdabot> Data.Array.MArray unsafeThaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
04:52:42 <lambdabot> Data.Array.IO.Internals unsafeThawIOUArray :: Ix ix => UArray ix e -> IO (IOUArray ix e)
04:53:11 <ClaudiusMaximus> ah, newListArray would have saved a thaw
04:53:46 <yitz> ClaudiusMaximus: those are polymorphic, you *want* to need the type signatures
04:54:48 <ClaudiusMaximus> i suppose
04:54:51 <ClaudiusMaximus> :)
04:54:55 <yitz> preflex, seen preflex
04:54:55 <preflex>  what
04:55:11 <yitz> preflex, seen Cale
04:55:11 <preflex>  Cale was last seen on #haskell 20 hours, 50 minutes and 14 seconds ago, saying: You get a StdGen using newStdGen at the top-level of your program, and pass it down to where it's needed.
04:55:37 <yitz> ok, it remembers its state
04:58:28 <ClaudiusMaximus> yitz: would it make any sense for hPutArray to return count of Word8 successfully written instead of () ?
04:58:56 <ClaudiusMaximus> @hoogle hGetArray
04:58:56 <lambdabot> Data.Array.IO hGetArray :: Handle -> IOUArray Int Word8 -> Int -> IO Int
04:59:27 <ClaudiusMaximus> like hGetArray returning count of Word8 successfully read
04:59:43 <yitz> ClaudiusMaximus: another good point
05:00:24 <yitz> ClaudiusMaximus: http://www.haskell.org/haskellwiki/Library_submissions
05:01:53 <ski> (yitz : possibly it never went down, but just lost connection for a while)
05:01:56 <ClaudiusMaximus> yitz: cool
05:02:47 <yitz> ski: could be. or could be its state has persistency.
05:05:24 <pastorn> @src read
05:05:25 <lambdabot> read s = either error id (readEither s)
05:06:41 <yitz> ClaudiusMaximus: the change to the return type of hPutArray is a bit more problematic, because it could potentially break existing programs that use it. But I doubt that would be a huge problem in practice here.
05:06:59 <pokoko222> how many hours do you spent on programming each day? just curious?
05:07:13 <yitz> ClaudiusMaximus: so I'd say, go for it on both of your proposals.
05:08:13 <yitz> pokoko222: another interesting poll: ratio of programming time / #haskell time
05:08:37 <hpc> yitz: zero, obviously :D
05:08:48 <yitz> hpc: epsilon
05:08:54 <vanadium> zero for me too :V
05:09:36 <pokoko222> ok so how much haskell time per day then
05:09:38 <copumpkin> pokoko222: 24
05:09:38 <pokoko222> :)
05:09:52 <pokoko222> copumpkin you just wanna make me feel bad :D
05:09:58 <hpc> it's only zero for me because every time i find time to boot into linux, i have homework that requires the windows partition :(
05:10:02 <copumpkin> pokoko222: yeah, I love doing that :)
05:10:06 <hpc> i would SSH if i wasn't doing graphics code
05:10:07 <pokoko222> lol
05:10:17 <vanadium> hpc: I hear you~
05:10:31 <vanadium> Fortunately starcraft 2 now works under wine, so even less motivation to boot into windows :D
05:10:35 <yitz> pastorn: that's weird, why is /bot so fixated on Either?
05:11:32 <NaTsu> hello
05:12:02 <hpc> vanadium: haha
05:12:03 <yitz> hpc:  get a windows box (or a vps) that you can vnc into
05:12:17 <yitz> hi NaTsu 
05:12:51 <NaTsu> hello there
05:12:55 <NaTsu> im new here
05:13:11 <hpc> yitz: i can't afford to get a second box; i spent all my computer money on a gaming laptop, so i could be confident in my ability to do anything anywhere
05:13:17 <NaTsu> can you help me sir yitz
05:13:37 <yitz> NaTsu: i don't know. what is your question?
05:13:38 <benmachine> @hoogle readEither
05:13:38 <lambdabot> No results found
05:13:43 <benmachine> >:|
05:13:55 <yitz> benmachine: :)
05:14:10 <yitz> @slap lambdabot
05:14:10 * lambdabot decomposes lambdabot into several parts using the Banach-Tarski theorem and reassembles them to get two copies of lambdabot!
05:14:15 <benmachine> :O
05:14:19 <hpc> XD
05:14:21 <benmachine> that's pretty cool
05:15:01 <hpc> that is one of my all-time favorite theorems, too
05:17:25 <ski> NaTsu : what is your Haskell question/problem ?
05:22:36 <ski>  
05:23:53 <benmachine>  
05:24:46 <olsner> it's so annoying that Monad doesn't imply Applicative...
05:24:51 <olsner> it'd be neat if there was a mechanism for saying "if there is no other applicative instance but there is a monad instance, this is how to instantiate applicative for any monad"
05:24:56 <Nibble> http://github.com/snkkid/LazyFooHaskell
05:25:12 <Nibble> anyone with write access to that repo or that knows the owner?
05:25:35 <Nibble> lesson 2 have a fault in the imagename, and who knows, it might mess up for newcomers
05:25:48 <pokoko222> i am interested in learning strategies for college. i am reading this now http://www.studygs.net/index.htm maybe you guys can share some cool stuff or habits?
05:25:52 <olsner> Nibble: doesn't github provide nice ways to send patches?
05:26:28 <Nibble> olsner: no idea
05:26:34 <Nibble> I have just used it some times
05:30:13 <ClaudiusMaximus> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28465#a28466 very slow   (anyone know which shader phases / techniques i might look at to try to port this to OpenGL/GPU?...)
05:38:39 <yitz> olsner: it's more annoying that Monad doesn't imply Functor.
05:39:02 <Nibble> yitz: it is more annoying that functor means something else than in any other language
05:39:12 <olsner> yitz: yeah, that too
05:39:15 <yitz> I hope they'll fix that in one of the incremental Haskell Prime versions soon.
05:39:19 <benmachine> all other languages are wrong
05:39:26 <benmachine> well, technically haskell is wrong too but ANYWAY.
05:39:36 <yitz> Nibble: what does it mean in other languages?
05:39:49 <copumpkin> Nibble: you mean c++ or ocaml?
05:39:50 <yitz> Nibble: you mean the language of category theory?
05:39:58 <copumpkin> Nibble: our functor is just a functor of category theory, on a specific category
05:40:08 <Nibble> yitz: in C, a functor is a variable pointed to a function
05:40:11 <benmachine> Functors are functors, but not all of them, right?
05:40:39 <copumpkin> yeah, c++ just made it up cause it had a cool name
05:40:41 <copumpkin> no real basis for it
05:40:42 <yitz> Nibble: oh, horrors. Functor has meant what it means in Haskell since long before C existed.
05:41:00 <ivanm> I read a discussion about this recently
05:41:09 <ivanm> comparing C++ functors to Haskell functors to OCaml functors
05:41:12 <copumpkin> omg an ivanm
05:41:20 <ivanm> yes, tis I!
05:41:22 <ski> Nibble : oh, you mean what "functor" means in languages like C++, Prolog, and SML : <http://catonmat.net/blog/on-functors> ?
05:41:24 <benmachine> functor in C is just an abbreviation for function pointer?
05:41:56 <Nibble> ski: I mean exactly what I wrote
05:42:18 <olsner> yitz: but as soon as anyone finds a use for a new abstraction that fits in between some other type-class you'll be in the same situation ... e.g. if anyone adds Pointed functors, every monad and applicative should be pointed but isn't for no particular reason except chronology
05:42:52 <ski> Nibble : ok. then could you please tell me what the similarities are between "functor"s in C++, Prolog and SML ?
05:43:07 <Nibble> ski: I can not, since I do not know prolog or SML
05:43:15 <dark> on ocaml, a functor is a parametrized module
05:43:17 <Nibble> I just said other languages. not all other languages
05:43:40 <Nibble> ski: oh sorry, I did, not exactly but "any other language"
05:43:42 <Nibble> my misstake
05:43:50 <ski> you said "any other language" .. that's a universal quantifier in that context, i believe
05:43:55 <copumpkin> :P
05:44:00 <ski> ok. correction accepted :)
05:44:02 <copumpkin> anyway, different people use the word differently
05:44:16 <yitz> olsner: true, but not all of those will necessarily be in wide usage. those that are - can be added. the general mechanism you speak of would create its own set of serious problems.
05:44:18 <copumpkin> we can point at a branch of math that predates common computers
05:45:15 <ivanm> copumpkin: were you wanting me for something or just generally overjoyed at continual proof of my existence? :p
05:45:24 <copumpkin> ivanm: the latter :)
05:45:29 <ivanm> good-o
05:45:44 <Nibble> ski: but it doesn't mean that every other language is the same as language x where x is not haskell
05:45:49 <ski> Nibble : i apologize if i sound somewhat irritated on this issue. it's just that some people for some reason thinks that the term definitions they are used to / know about must be more correct than other definitions in other communities
05:45:55 <yitz> copumpkin: no proof. ivanm is certainly capable of writing a bot that could give the responses seen so far in this conversation.
05:45:55 <dark> ivanm, this makes up a nice quote
05:46:05 <copumpkin> yitz: damn!
05:46:18 <ivanm> yitz: dammit, how did you uncover my nefarious plot so easily?!?!?!?!
05:46:29 <yitz> bwahaha
05:46:43 <ivanm> dark: well, if you think so, that's what @remember is for!
05:46:55 <ivanm> preflex: seen jfredett
05:46:55 <preflex>  jfredett was last seen on #haskell-blah 145 days, 4 hours, 21 minutes and 43 seconds ago, saying: and with that, I bid Adeiu to you, fair Haskellians, I go now to sleep.
05:46:58 <ivanm> bah
05:47:02 <dark> @remember <ivanm> copumpkin: were you wanting me for something or just generally overjoyed at continual proof of my existence? :p
05:47:02 <lambdabot> Nice!
05:47:06 * ivanm wants a new HWN issue!
05:47:12 <ski> (.. but, when *i*'m claiming that my definition of a word is correct, it is because it *is* the correct one ;)
05:47:17 <Nibble> ski: well. if you read what I wrote originally, I didn't say that haskell was wrong in any way. you shouldn't generalize
05:47:19 <copumpkin> what happened to jfredett anyway?
05:47:24 <copumpkin> preflex: seen jfredett
05:47:24 <preflex>  jfredett was last seen on #haskell-blah 145 days, 4 hours, 22 minutes and 13 seconds ago, saying: and with that, I bid Adeiu to you, fair Haskellians, I go now to sleep.
05:47:26 <ivanm> copumpkin: exams + stuff IIRC
05:47:34 <copumpkin> that's a lot of stuff
05:47:37 <copumpkin> on an mmorrow scale
05:47:46 <ivanm> copumpkin: what, me just doing that wasn't good enough for you? :p
05:47:57 <ivanm> copumpkin: he has been back now and then; not sure why preflex can't remember
05:47:58 <copumpkin> nope
05:48:15 <ski> Nibble : nope. i didn't mean to imply that you said anything of the sort. i just reacted on the use of "any" there
05:48:39 * ivanm -> land of nod
05:48:41 <ivanm> g'night all
05:48:49 <copumpkin> night!
05:51:19 <dark> :t lines
05:51:20 <lambdabot> String -> [String]
05:53:12 <ski> .. can `foo(A,AB)' described by `forall b. (  b ||- foo(A,AB)  <=>  exists a.  a ||- A  /\  (a ++ b) ||- AB  )' be phrased as an adjunction ?
06:12:40 <drhodes> > print "哈哈"
06:12:41 <lambdabot>   <IO ()>
06:14:38 <mpiechotka> @pl \f g -> fmap f . g
06:14:39 <lambdabot> (.) . fmap
06:15:19 <dark> @pl \x -> h $ h $ g $ p x
06:15:20 <lambdabot> h . h . g . p
06:18:20 <Axman6> > join (.) h . g $ p x :: Expr
06:18:20 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> a'
06:18:21 <lambdabot>         against infe...
06:27:54 <hpc> how does one fix a cyclic import when refactoring is impossible?
06:30:34 <ClaudiusMaximus> hpc: GHC can use .hs-boot files, i've heard (never done it myself)
06:30:53 <hpc> ah, thanks
06:30:57 <hpc> just needed something to google
06:31:11 <chrisdone> is refactoring really impossible/
06:31:56 <hpc> i have a type, newtype, and data that all refer to each other, and one of them has to be in a separate module
06:32:13 <Axman6> the advice i've been given is that if you have a cyclic dependancy, than they're probably related enough to be in the same file
06:32:14 <hpc> because i am trying to disconnect game engine code from individual game code
06:32:30 <hpc> in such a way that the engine is generally untouched
06:33:12 <ClaudiusMaximus> reading http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/separate-compilation.html#id2920244 i think i'd rather refactor
06:33:31 <dark> but if the individual game code has something used by the game engine itself, maybe you disconected it wrong?
06:34:37 <moosefish> So, I have some opengl renderer I'd like to use to create movies with -- a stats analysis package that creates graphs of timeseries data, I'd like to output a .mpeg or some such I can put on a webpage. Curious what's a few good approaches; best for me is when non-haskell dependencies are minimized.
06:34:55 <ClaudiusMaximus> moosefish: which OS?
06:35:05 <moosefish> recent debian linux.
06:35:18 <moosefish> But I can use Mac OS X if I must.
06:35:57 <ClaudiusMaximus> moosefish: right.  http://gitorious.org/maximus/mandulia/blobs/master/src/Snapshot.hs#line35 is what i use, dump PPM frames to stdout then encode with standard tools
06:36:57 <moosefish> but from an opengl buffer?
06:37:03 <ski> (Axman6,hpc,dark : .. in OCaml, you can "tie the knot" with module functors like in <http://paste.debian.net/80832/> (maybe SML/NJ also supports this ?))
06:37:15 <ClaudiusMaximus> moosefish: yes, taht's what that code does
06:37:41 <moosefish> ah, yes. Missed the readPixels call. Awesome, thanks!
06:37:58 <ClaudiusMaximus> moosefish: it's not particularly fast because it use synchronous readPixels, would be better to use async PBOs, but it's good enough for me so far
06:38:08 <moosefish> PBO?
06:38:16 <hpc> ski: i don't know OCaml
06:38:18 <ClaudiusMaximus> pixel buffer object
06:38:28 <moosefish> gotcha. Thanks ClaudiusMaximus.
06:39:58 <ski> hpc : `Set.Make' is a module function, that given a module containing a type `t' and a comparision function `compare' for it, constructs a module containing a type `S' representing sets of elements of type `t', together with operations on it
06:39:59 <ClaudiusMaximus> moosefish: encode with ./Main | ppmtoy4m -S444 -F25:1 | ffmpeg2theora -f yuv4mpegpipe -o movie.ogv -   # or similar, i'd have to check the details
06:40:36 <hpc> ski: nifty
06:40:57 <ClaudiusMaximus> (and if ppmtoy4m is still really really slow, i made a faster but less featureful hack...  http://gitorious.org/maximus/mandulia/blobs/master/extra/ppmtoy4m_quickndirty.c )
06:41:00 <dark> ski, I don't understand what you meant by 'tie the knot'.. it looks like you defined recursively a module and a class, inside another module
06:41:00 <ski> hpc : that example build a recursive type (class in this case, but that's not important here) whose values can contain a set with elements being of the same recursive type
06:42:03 <ski> so the recursive type is constructed from the set type, and the set type is constructed from the recursive type, but still the code for constructing sets is general, and decoupled from this particular recursive type
06:42:43 <dark> ski, I think you can define two recursive modules in SML, not sure. (SML has functors, not sure if as powerful as ocaml's)
06:43:25 <ski> dark : yes .. "Tying-the-Knot" is a name for the idiom of instead of defining a function `A -> (B,C -> D)' over some recursive type `A', using a single traversal, and then at top level convert the `B' to a `C', and extract a final `D' result ..
06:44:40 <ski> dark : .. one defines a function `foo :: A -> C -> (B,D)' where we call it like `\a -> let (b,d) = foo a (b_to_c b) in d', so that we feed part of the output back as input to the *same* call
06:44:58 <ski> dark : i just thought the recursive module example was a bit similar to this situation
06:46:06 <ski> (also, that paste isn't mine .. i just happened to have a link to it handy)
06:46:32 * dark is reading multiple times, but is having trouble
06:47:15 <dark> the funny thing is that i was reading a song "hey baby let's combine you hang up the phone if i become too abstract..." (translation from portuguese)
06:47:25 <dark> hearing*
06:47:59 <ski> @type loop
06:48:00 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
06:48:01 <ski> @type \f -> loop . (<<< second f)
06:48:02 <lambdabot> forall c (cat :: * -> * -> *) b c1 d. (ArrowLoop cat) => cat b c1 -> cat (d, c1) (c, b) -> cat d c
06:48:02 <dark> and now i discovered that parsec can't do incremental parsing
06:48:53 <dark> I was kind of hoping to grasp some haskell by writing an interpreter. I think I will just feed isolated lines to parsec..
06:49:41 <dark> and if it founds an eof while parsing, feed the previous lines plus the next line
06:50:19 <ski> @type let swap = arr snd &&& arr fst in \f -> loop . (\g -> swap <<< g <<< second f)
06:50:20 <lambdabot> forall (cat :: * -> * -> *) a b c d. (ArrowLoop cat) => cat a c -> cat (d, c) (a, b) -> cat d b
06:50:33 <dark> @type (<<<)
06:50:34 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
06:50:54 <ski> .. that more like my `A -> C -> (B,D)' example
06:52:16 <ski> dark : btw, one of the simplest examples of Tying-the-Know is "RepMin" : write a *single*-traversal function that replaces each element in a binary tree by the minimum element
06:52:39 <yitz> dark: if expressions do not span line breaks in your input language, it is indeed a good idea to feed parsec individual lines.
06:52:41 <ski> .. if you want, you could subtract the global mean from each element, instead .. it's basically the same
06:53:13 <yitz> dark: why do you say that parsec does not support incremental parsing? what are you having trouble doing?
06:53:31 <dark> yitz, the idea was to leverage the input laziness of haskell
06:54:04 <dark> here http://book.realworldhaskell.org/read/using-parsec.html someone asked 'Maybe running the parser does not run the whole parser immediately; perhaps it's only run incrementally, as needed..'
06:54:35 <dark> and it was said 'Neither Parsec2 or 3 is incremental (though it may be doable in Parsec3) so laziness won't help.'
06:55:02 <yitz> dark: parsec is strict, because of its output type. in order to get any output at all you already need to know if there will be any errors anywhere in the input.
06:55:11 <dark> the idea was that the parser could return a lazy list of individual components
06:55:12 <yitz> dark: attoparsec is a lazy version
06:55:46 <dark> i was thinking about errors, but.. it could be a list of eithers..
06:55:59 <dark> attoparsec, hm
06:56:18 <yitz> dark: yeah, but parsec's output type is Either ParseError a or something like that
06:56:32 <dark> yes, sure
07:02:47 <olsner> dark: if the parser returns a tail of unparsed input, you can wrap that into a lazy list
07:03:27 <dark> olsner, can a parsec parser actually do that?
07:04:52 <dark> Hmm, "Attoparsec is specialised to deal only with strict ByteString input.", "Parsec parsers can produce more helpful error messages than Attoparsec parsers.", plus there is no sense actually into terminating evaluation in any point other than a \n (since input is buffered)
07:05:03 <olsner> dark: iirc there is a function for getting the rest of the input in parsec
07:05:47 <olsner> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Prim.html#v:getInput
07:05:49 <aristid> there's also uu-parsinglib
07:05:59 <yitz> dark: you feed it chunks of strict ByteString, not the whole thing at once.
07:06:02 <aristid> @hackage uu-parsinglib
07:06:03 <lambdabot> http://hackage.haskell.org/package/uu-parsinglib
07:07:07 <yitz> dark: as for the helpfulness of the error messages, well, you have to try it. I think it's usually quite useful. people seem to like attoparsec.
07:07:48 <yitz> there's also polyparse. there are a lot of parsers out there.
07:08:07 <yitz> there's a variant of attoparsec that reads lazily from iteratees, if you like those.
07:08:46 <yitz> attoparsec is popular because it works well, and it's similar to that familiar approach of parsec.
07:11:04 <yitz> dark: if you're going to be pre-chunking your input into lines, parsec itself should be fine though. how much incrementalism do you need?
07:12:35 <nlogax> how do i tell a λbot to listen for commands in a channel? mine only listens to private messages
07:13:54 <dark> yitz, I think I really need only at line-level (since the input is buffered..)
07:14:00 <ski> http://hackage.haskell.org/packages/archive/Encode/1.3.4/doc/html/Parsek.html
07:14:27 <copumpkin> o.O
07:14:29 <copumpkin> Parsek!
07:14:31 <dark> > (\x -> x) "like this nlogax"
07:14:32 <lambdabot>   "like this nlogax"
07:15:15 <ski> (the original link at <http://www.cs.chalmers.se/Cs/Research/Functional/MultiLib/koen/Parsek.hs> appears to be dead)
07:15:44 <yitz> nlogax: does the bot come with an IRC client, or do you need to get one of those separately?
07:16:19 <nlogax> dark: yes, but mine doesn’t listen to that, using the default config/adapted examples
07:16:34 <nlogax> yitz: it comes with an irc plugin
07:17:21 <yitz> dark: well, the issue is whether the language you are parsing has expressions that span line breaks or not. buffering is a side point, it only affects how to feed the parser.
07:18:18 <yitz> nlogax: does the irc plugin just deal with the irc commands, or does it actually make network connections and speak the line protocol?
07:18:50 <nlogax> yitz: it handles the connections and everything, as far as i can tell
07:18:56 <yitz> ok
07:21:34 <Zeiris> Is it practical to build a monad from ExceptionT, that returns a the computation that was meant to happen -after- the exception?
07:23:18 <wli> ContT?
07:23:46 <dark> yitz, yes, it has. so (in my understanding) if the parser fails with 'unexpected end of input' i need to accumulate this line for feeding in the next input
07:24:43 <yitz> dark: no that means the parser has died. for parsec, you won't be able to feed it line by line and get output.
07:25:22 <dark> so i try to parse again with (acc ++ newline) as input
07:25:26 <yitz> dark: for attoparsec, you can feed it each line as a strict ByteString. if it wants more, it won't fail, it will give you a continuation.
07:25:46 <dark> yes, it would be more convenient..
07:26:07 <yitz> dark: can one expression end and a new one begin in the middle of a line?
07:26:27 <dark> yes
07:26:37 <dark> ah.. parsec will fail it entirely
07:27:18 <yitz> dark: right, you'd have to reparse from scratch with all the input plus one more line, until it succeeds. very, very, s-l-o-w.
07:28:08 <yitz> dark: or, read in the entire input strictly and shove the entire thing down parsec's throat.
07:29:05 <yitz> nlogax: so there's an @irc-connect command that you can private message to the bot . you tried that and it's not working for you?
07:29:15 <dark> but I think that in that case I want to parse everything when the end of a line coincides with the end of some expression õ.o to avoid outputting something when the user is in the middle of an expression
07:29:40 <nlogax> yitz: yes, it’s in the channel, just ignoring all commands :)
07:29:50 <yitz> ah
07:31:25 <yitz> nlogax: does it respond to irc PING?
07:32:24 <nlogax> yitz: yes, and also to commands in msg. i just can’t find how to tell it to listen to channels as well
07:32:36 <dark> @pl \x -> case x of 1 -> 1
07:32:37 <lambdabot> (line 1, column 19):
07:32:37 <lambdabot> unexpected ">" or "-"
07:32:37 <lambdabot> expecting variable, "(", operator or end of input
07:33:13 <yitz> nlogax: ah, ok.
07:33:15 <dark> @pl (\x -> case x of 1 -> 1) 1
07:33:15 <lambdabot> (line 1, column 20):
07:33:16 <lambdabot> unexpected ">"
07:33:16 <lambdabot> expecting variable, "(", operator or ")"
07:33:16 <olsner> pl probably doesn't do "case"
07:33:26 <dark> ah
07:33:40 <hpc> @pl \x -> (case x of 1 -> 1)
07:33:40 <lambdabot> (line 1, column 20):
07:33:40 <lambdabot> unexpected ">"
07:33:40 <lambdabot> expecting variable, "(", operator or ")"
07:41:15 <nlogax> heh, i found the issue. 
07:41:34 <nlogax> the channel had the same name as the bot, apparently it didn’t like that
07:43:18 <yitz> nlogax: hah, ok. yeah, channel names and nicks are the same type. No type safety there.
07:43:51 <hpc> i never had that problem with my bot; i detected channels by matching for a '#' at the front
07:44:30 <yitz> hpc: it's a hack to depend on that though.
07:44:49 <hpc> yitz: really? i thought it was in the spec
07:45:17 <hpc> because having it otherwise makes the distinction between channels and users ambiguous
07:45:17 <yitz> oh really? the irc protocol confuses nicks with channel names? yuck!
07:45:48 <yitz> hpc: even then it's a hack. in haskell, the parser should resolve those as different types.
07:45:57 <vanadium> PRIVMSG somedude :text goes here, PRIVMSG #somechannel :text goes here
07:46:22 <Zao> hpc: You can name channels anything really.
07:46:30 <Zao> bitlbee uses &bitlbee 
07:46:41 <hpc> Zao: yuck
07:46:52 <arw> though there are many networks, that assign special meaning to certain characters in front of a channel.
07:47:01 <vanadium> Zao: & is actually a thing in the protocol too
07:47:06 <arw> like + for modeless, ! for server local, etc.
07:47:09 <Zao> Sorry, # and & are the only ones.
07:47:09 <vanadium> It is for server-local channels, as opposed to network-wide
07:47:11 <Zao> http://irchelp.org/irchelp/rfc/chapter1.html#c1_3
07:47:11 <yitz> so i guess a channel is just a kind of person you can exchange messages with, i can hear that
07:47:48 <Zao> & being server-local or something.
07:48:15 <yitz> and if that's the case, then it really wouldn't work for an individual to have the same name as a channel. not the fault of the \bot code then, i apologize
07:49:09 <Zao> Nice, the text distinguishing # and & is broken in the RFC itself :D
07:49:24 <hpc> hmm, Zao and arw are right about networks having extra characters; the network my bot is on uses @, %, and +, at least
07:49:40 <Zao> hpc: For channels?
07:49:45 <hpc> yeah
07:50:06 <vanadium> I did not think irc clients would cope with that
07:50:10 <Zao> You're not conflating them with displays of user modes for users?
07:50:18 <Zao> vanadium: Writing an IRC client is horrible pain.
07:50:26 <hpc> wait crap, i might be
07:50:30 <arw> Zao: the rfc is very old and has certain problems. also, most ircd implementations add certain details.
07:50:47 <Zao> @ being op, % being hop, + being voice
07:50:50 <hpc> yeah, whois adds details
07:50:52 <hpc> nvm
07:51:09 <hpc> and & for owner
07:51:44 <arw> Zao: so while you might write strictly according to the rfc, the only authorative source of specs is the flavour of ircd a certain network uses.
07:52:13 <ski> ("hop" ?)
07:52:20 <arw> Zao: and many networks use their own special ircd, often the only justification for the whole network is their special ircd :>
07:53:03 <vanadium> "hop", half-op is usually pretty much just op, but cannot fuck with other ops
07:53:11 <ski> ok
07:54:19 <yescalona> yi editor is alive?
07:55:04 <djahandarie> sp vanadium 
07:55:11 <djahandarie> sup*
07:55:14 <hpc> yescalona: to my knowledge, only officially; someone else might no better though
07:55:30 <hpc> s/no/know
07:55:59 <vanadium> sup djahandarie 
07:59:27 <drhodes> is Data.Encoding what I should be using to manipulate unicode strings?  in my program I'd like to do; let thing = someConstructor "中"; where someConstructor returns a type satisfying the Show typeclass.
08:00:29 <djahandarie> Check out utf8-string
08:00:38 <drhodes> ok djahandarie, thanks.
08:21:59 <nooodl> i'm trying to write a little "guess the number" game in haskell -- i started learning a few days ago.
08:22:14 <nooodl> what i have so far is this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28471#a28471
08:23:05 <nooodl> ghc complains about the last line being unable to match IO () and String. isn't guess supposed to be a String after using <-? 
08:23:57 <nooodl> wait, nevermind, i think i got it -- i was comparing "print ..." to guess :(
08:24:03 <dolio> Your last line parses as "(print (show x)) == guess".
08:24:24 <roconnor> hey, that is like one of the few chinese characters I can actually read
08:24:27 <roconnor> "middle"
08:24:54 <dolio> @hoogle readLine
08:24:54 <lambdabot> Network.Stream readLine :: Stream x => x -> IO (Result String)
08:24:54 <lambdabot> Network.TCP readLine :: HStream bufType => HandleStream bufType -> IO (Result bufType)
08:24:54 <lambdabot> module System.Console.Editline.Readline
08:24:58 <dolio> @hoogle readLn
08:24:58 <lambdabot> Prelude readLn :: Read a => IO a
08:24:59 <lambdabot> System.IO readLn :: Read a => IO a
08:25:43 <proc> I want to code something
08:25:45 <proc> any ideas?
08:25:58 <nooodl> code world peace
08:26:27 <proc> that'd bring me the nobel peace price and the fields medal
08:26:43 <poljp> seems a good reward ?
08:26:46 <nooodl> neat, right?
08:27:12 <proc> indeed
08:28:02 <EvanR> proc: a game!
08:28:31 <proc> uh no
08:28:40 <proc> reminds me of the pita I had with opensdl ;)
08:28:49 <monadic_kid> does anyone know if jhc defines a macro that says jhc is compiling?
08:29:25 <EvanR> whats opensdl
08:29:26 <Blkt> good day everyone
08:30:27 <proc> oh, it's called just sdl
08:30:38 <proc> EvanCarroll, libsdl.org
08:30:51 <EvanR> yeah i know sdl
08:31:02 <EvanR> so your experience was bad?
08:31:24 <proc> sort of ;)
08:31:37 <nooodl> argh, IO actions are giving me headaches.
08:31:40 <proc> too much low level stuff to do if you ask me
08:31:49 <nooodl> i should try something else.
08:31:51 <EvanR> pretty low level
08:32:21 <EvanR> maybe theres a pygame-like lib for haskell which wraps the low level
08:33:10 <proc> gd writer looks nice
08:34:33 <EvanR> im sort of having a hard time trying to do a certain game
08:34:48 <EvanR> of course i could write as if it were a C program but...
08:35:22 <EvanR> :\
08:35:57 <proc> yeah, that's not why we do haskell
08:36:01 <proc> ... to write imperative style ;)
08:37:10 <proc> oh nice
08:37:28 <proc> someone wrote his master thesis about 3d games in functional programming languages
08:39:47 <hpc> proc: you mean frag?
08:40:11 <proc> exactly
08:40:15 <hpc> it does some cool things, but gets a terrible framerate even on my impossibly fast box
08:41:03 <hpc> im trying to make a more serious game engine, with emphasis on speed
08:41:37 <proc> and how is it going?
08:41:44 <xarch> proc: I also have an (small) article about why functional programming is useful for games (in French though), if you want
08:41:46 <hpc> slowly; i have so little time to work on it
08:41:51 <xarch> s/an/a
08:42:19 <hpc> xarch: ooh, care to give a summary?
08:43:04 <proc> xarch, unfortunately I don't speak french ;)
08:44:04 <xarch> yeah, I just read it again and I can give a summary
08:45:48 <xarch> definitely small actually :-'
08:46:05 <hpc> haha
08:46:50 <monadic_kid> hpc: I had decent framerates with frag, i made a video of it: http://www.youtube.com/watch?v=0jYdu2u8gAU
08:47:13 <hpc> i saw that
08:47:39 <hpc> im on linux with a 3ghz i7 and 5870 gpu, so it could be the OS messing with it
08:47:48 <hpc> or the ATI drivers being generally fail
08:48:03 <monadic_kid> hpc: then something is seriously wrong because I'm using a much older setup
08:48:26 <monadic_kid> hpc: my card is like 4 generations old, x1950 pro and core 2 duo
08:49:17 <hpc> oh no, just my touchpad that sucks, i think
08:49:23 <hpc> lemme try my mouse
08:49:31 <bnonym> no.
08:50:46 <hpc> alright yeah, the framerate hovers between 60 and 100, but the input is hella laggy
08:53:26 <hpc> monadic_kid: your video has the same stuttery input my computer has
08:54:33 <monadic_kid> hpc: if i remember correctly that was just the recording software I was using that sucks
08:58:44 <BrianHV> hm.  frag segs for me very quickly.
09:03:34 <EvanR> i would like to make a game where the 'guts' involve a rectilinear game board where each square can hold zero or more entities, and can move around the board, and i can detect collisions of certain types
09:03:51 <EvanR> graphically they would move gradually from one square to another, and the 'camera' follows the player around
09:04:02 <EvanR> im stumped about a 'functional' way to do this
09:06:12 <monadic_kid> You shouldn't beat yourself up over it and trying to write perfect architecture or the right way
09:07:25 <nooodl> tail recursion?
09:08:36 <adu> EvanR: well, i would just use a list of triples: (x, y, piecetype)
09:08:36 <hpc> yeah, not unless you are setting out to write a (near-)perfect architecture :D
09:09:18 <adu> EvanR: or for collision detection, you might want 2 locations, the real one, and the quantized destination
09:09:31 <hpc> i wouldn't go with a list; you can reduce computation time with spatial partitioning
09:11:01 <hpc> for a grid, i would probably go with a quadtree
09:11:01 <EvanR> trying to grok this...
09:11:22 <jmcarthur> zygohistomorphic prepromorphisms are the obvious way to implement that
09:12:02 <olsner> ah yes, the good old ZP, default solution for anything really
09:12:13 <adu> jmcarthur: did you just makeup a word
09:14:56 <dark> adu, http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
09:15:54 <dark> this must be some kind of joke indeed ._.
09:15:55 <hpc> that page is a frightening taste of haskell buzzwords
09:16:23 <dark> zygo looks like a biology nerd term
09:17:19 <olsner> dark: while it certainly is used as a joke it is also (afaik) a valid definition
09:17:35 <olsner> zygo means "split in two" or something like that iirc
09:18:12 <dark> http://www.b-list.org/weblog/2009/jun/26/fun-little-bug/#c118678
09:18:17 <Phyx-> wow... that page gave me a headache
09:18:21 <Phyx-> too many big words
09:20:22 <EvanR> you people are infuriating
09:20:59 <EvanR> a quadtree for a simple rectangular game board?
09:21:01 <zygoloid> dark: oi!
09:21:15 <EvanR> and histozygo whatsit?
09:21:40 <dark> zygo haha oi =) (speak portuguese?õ.o)
09:21:41 <EvanR> im looking for a nice solution, not a theory of the universe
09:21:54 <zygoloid> EvanR: it sounds like you want to use an array. :)
09:22:42 <EvanR> yeah
09:22:53 <EvanR> what about the graphical part?
09:23:07 <roconnor> data QuadTree = NE QuadTree | SE QuadTree | SW QuadTree | NW QuadTree
09:23:33 <Gracenotes> there's always: Node Quadtree Quadtree Quadtree Quadtree | Leaf, depending on how you unfold it
09:23:44 <EvanR> are the algorithms for this structure nice?
09:23:45 <roconnor> ah crap
09:23:46 <Gracenotes> er Leaf Quadvalue
09:23:55 <roconnor> accidentally did a coQuadTree
09:24:17 <zygoloid> EvanR: i wrote a ST-based quadtree for ICFP a couple of years ago, was pretty nasty tbh
09:24:22 <Gracenotes> and whatever other values you want to store
09:24:22 <zygoloid> but i was quite new to haskell back then
09:24:43 <zygoloid> (these days i would use a pure one rather than an ST one, for a start...)
09:24:58 <Gracenotes> if you're doing it over a euclidean space, you might also want to store bounds
09:25:19 <hpc> ST: for when you don't need IO, but can't for the life of you make some piece of code pure
09:25:22 <Gracenotes> even in imperative programming languages, they're somewhat annoying, but the algorithms aren't terribly unintuitive
09:26:21 <Gracenotes> also tell me when you find a theory of the universe, so I can get a nobel prize in physics
09:26:50 <hpc> Gracenotes: it's not prizeworthy until it's a theorem ;)
09:27:15 <zygoloid> EvanR: my experience of writing games is this: it's much better to go and write some code which does what you want than to spend much time thinking about the 'right' way to do it
09:28:04 <olsner> can't you write quadtrees more nicely as a one-dimensional tree of one-dimensional trees?
09:28:16 <dark> zygoloid, agreed. I always end up trying to do it the 'best' way, and too much earlier I abandon it .-.
09:28:31 <zygoloid> olsner: you need interleaving at each bifurcation point ;-)
09:28:49 <Gracenotes> I used a quadtree for a simple map application once, turned out to be fast enough, except I stored more than one node per tree leaf (I think up to 100)
09:28:54 <dark> ps: found out that it's about fold / unfold (recursion) approaches/orders, http://comonad.com/reader/2009/recursion-schemes/
09:29:08 <zygoloid> dark: i think this holds for any hobby project. you've got to keep making progress otherwise you'll get bored and move on
09:29:18 <dark> not that I understand much, but at least it's reduced to something I heard of
09:29:36 <dark> zygoloid, yeah. but having got the wrong design is so uncool :~
09:29:52 <olsner> zygoloid: right... you'd need something a bit more clever to be able to interleave two tree structures... maybe you could write it as a "tree transformer" or something though
09:30:02 <dark> I try to tell myself that if the project is really nice, I can rewrite any part of it later
09:32:20 <Oejet> EvanR: Which graphical toolkit are you using?
09:32:30 <EvanR> dunno
09:34:49 <hpc> 2D or 3D graphics?
09:36:57 <dark> monadic_kid, amazing video o.o
09:37:49 <poljp> well g'night all.
09:38:11 <ClaudiusMaximus> i think writing C in Haskell is even more painful that writing C in C : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28465#a28474
09:38:16 <dark> good night poljp
09:38:36 * ClaudiusMaximus has to go, for now...
09:39:06 <ski> (hpc : s/pure/not-mutating/)
09:39:54 <hpc> ski: ah, yeah
09:40:10 <ski> ClaudiusMaximus : seen <http://www.haskell.org/pipermail/haskell-cafe/2004-March/005939.html> :) ?
09:40:34 <Phyx-> ClaudiusMaximus: err... that looks narly...
09:41:47 <ski> (hm .. "non-mutating" .. "immutating" ?)
09:43:20 <dark> are lexeme parsec parsers for 3.x only?
09:46:44 * hackagebot parsec2 1.0.0 - Monadic parser combinators  http://hackage.haskell.org/package/parsec2-1.0.0 (AntoineLatter)
09:53:16 <Philippa> dark: Parsec has no real notion of 'lexeme'
09:53:28 <Philippa> or at least, insofar as it does, it's just the smallest unit of a stream
09:53:37 <Philippa> Parsec 2 doesn't care what the token type is either
09:53:59 <Philippa> (but you have to write 'token' parsers in terms of some primitives if you want to use something other than Char)
09:55:01 <dark> no, i mean, http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#lexeme
09:55:16 <dark> (lexeme p) first applies parser p and than the whiteSpace parser, returning the value of p
09:55:27 <dark> just a convenience
09:55:46 * hackagebot aligned-foreignptr 0.1 - An aligned ForeignPtr type  http://hackage.haskell.org/package/aligned-foreignptr-0.1 (BalazsKomuves)
09:57:29 <monadic_kid> since cabal doesn't work with jhc, what would be the best way to automate the process of: h2csc -> jhc -> mv *.hl ~/lib/jhc with support for cross-compiling in jhc to other non-default C compiler (with options). Makefile, shell script, autotools? the last seems over kill
10:00:28 <EvanR> hpc: 2d i guess
10:00:51 <hpc> you might like SDL, then
10:02:33 <EvanR> right, thats all low level backend IO stuff
10:04:54 <EvanR> hpc: an array of list of objects thats simple
10:05:15 <EvanR> but not sure about graphical part... like moving things gradually from one square to another
10:06:08 <hpc> have each object store an origin square and a destination square, and a movement progress
10:06:32 <EvanR> group it with the other data?
10:06:32 <hpc> movement progress changes over time until it reaches 100% or whatever, then the destination becomes the origin and the destination becomes Nothing
10:07:20 <hpc> yeah, so you would have data Object = Object {x, y, destination, origin, progress} with appropriate types
10:07:37 <hpc> and pieceType, forgot about that
10:08:26 <EvanR> and if pieces are deciding how to move with time, keep their thought process in there?
10:08:36 <hpc> yes
10:09:14 <EvanR> seems like itll be tricky to get this 100% thing exactly right if for example a piece is barreling down a row
10:09:17 <EvanR> one square after another
10:09:30 <EvanR> wouldnt want it to glitch each time it passes one
10:09:52 <hpc> is this realtime?
10:10:40 <EvanR> yeah
10:11:03 <hpc> you could have progress "overflow", so if you pass through a square but it isn't your final destination, change origin, change destination to the next square on your path, then put any rollover progress towards the next square
10:11:23 <hpc> so you would have origin, destination, objective, or whatever you choose to call it
10:11:28 <EvanR> the piece for the player doesnt know his final destination ;)
10:11:37 <EvanR> i guess its the next wall
10:11:49 <hpc> hmm
10:11:51 <EvanR> until he releases the movement key
10:11:55 <EvanR> then its the next square
10:12:09 <hpc> yeah
10:12:29 <hpc> if there's a cap on player speed, you don't have to track to the next wall, just to that limit
10:13:01 <hpc> or don't even save a final destination, just a direction
10:13:04 <Nibble> Just one question, about design. Lets say a particle has coordinates x,y in a 2D-plane
10:13:18 <Nibble> And the particle can move and change its location
10:13:23 <Nibble> how would I do that in haskell?
10:13:36 <EvanR> dejavu i just asked that!
10:13:48 <hpc> haha
10:13:59 <dark> for me, "functional" is just giving the state to your "step the world" function, and making it to return the state
10:14:06 <EvanR> direction.. direction... well that makes sense
10:14:07 <hpc> Nibble: if this is for a game, my advice to EvanR still holds
10:14:30 <hpc> if it's for a simulation, you might want something continuous like position :: Time -> (X, Y)
10:14:38 <EvanR> dark: yeah but functional arrays arent the greatest
10:14:39 <dark> so you give a data structure with the point to the function, and it returns a new data structure, with new points..
10:14:53 <Nibble> hpc: ok, what advince, there is a lot of stuff written here
10:15:05 <dark> EvanR, the point is that you can use things like map or fold
10:15:18 <EvanR> yes
10:15:22 <hpc> Nibble: just the last page or so
10:16:08 <EvanR> hpc: so maybe theres no array, just an IntMap of Object
10:16:15 <Nibble> hpc: well, aren't x y immutable?
10:16:28 <Nibble> so they are just what they are, then they can't change
10:16:38 <Nibble> that's the problem I am facing, and I do not know how to deal with it
10:16:49 <hpc> Nibble: you would update by copying, and dropping references to the old data
10:16:51 <EvanR> numbers are immutable in C too
10:17:06 <EvanR> you overwrite registers with new numbers
10:17:14 <EvanR> in haskell you compute new numbers from old
10:17:50 <hpc> movePoint = forever $ do (x,y) <- get; (x',y') <- update (x,y); put (x',y')
10:17:54 <Nibble> hpc: example? references?
10:17:57 <hpc> for example, assuming you are using State
10:18:03 <Nibble> EvanR: yes. but variables are not
10:18:09 <hpc> and have forever, update, etc defined
10:18:19 <Nibble> EvanR: or, perhaps I am missunderstanding you
10:18:19 <EvanR> Nibble: you can use mutable variables in haskell
10:18:32 <Nibble> EvanR: ok?
10:18:42 <EvanR> IORef, State, IOArray
10:18:49 <hpc> ST
10:18:50 <EvanR> ST
10:18:58 <EvanR> MVar
10:19:08 <Nibble> @info ST
10:19:08 <lambdabot> ST
10:19:09 <hpc> continuations, if you are feeling silly
10:19:13 <EvanR> heh
10:19:22 <Nibble> ok.
10:19:31 <vanadium> I would be hard-pressed to say that variables are immutable in haskell
10:19:36 <vanadium> I barely even see any variables in haskell
10:19:36 <Nibble> hpc: but you said references.
10:19:59 <Nibble> vanadium: how do you mean?
10:20:05 <monadic_kid> explicit state passing, that tends to be the most popular in the haskell game code i've seen, but they tend to look a lot like boilerplate code that they could have made more elegant with a state monad
10:20:12 <hpc> Nibble: so in my example above, with movePoint, you let the old x and y drop out of scope
10:20:17 <EvanR> the doc calls IORef a mutable variable, its not like a variable x in f x = g x
10:20:33 <hpc> that would be dropping references; you ignore it and it gets garbage collected
10:21:26 <EvanR> hpc: should the walls be pieces too?
10:21:56 <Nibble> EvanR: Seems like you are trying to do something similar to me
10:21:58 <hpc> EvanR: not sure; you could make them pieces, then give them the ability to move as well, for giggles
10:21:59 <Nibble> what is it?
10:22:03 <dark> monadic_kid, yes, i saw some of this monad thing to avoid passing state explicitly, very nice but i'm not used to it still
10:22:09 <EvanR> hpc: ahhh movable walls! ;)
10:22:23 <hpc> i would probably make them static, to avoid using CPU on those kinds of updates
10:22:25 <EvanR> Nibble: a 2d game on a grid
10:22:46 <monadic_kid> dark: it's not so much avoiding but refactoring out the boiler-plate code of N-number of transformations
10:23:05 <EvanR> hpc: what do you think of the idea of position as a lazy list
10:23:06 <monadic_kid> dark: it's more easier than you think, just use it
10:23:17 <ApeShot> Hi - total haskell newb here.  I am using the latest Haskell Platform on ubuntu and looking at http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays but can't seem to import Data.Array.UDiff into ghci.
10:23:31 <hpc> EvanR: i don't know how to make it work off the top of my head, but it would be cool to try
10:23:35 <ApeShot> I tried to find it in cabal list but it doesn't seem to be there
10:24:21 <EvanR> hpc: ive done it before, coupled with a lazy list for animation ( [Frame] ) but getting any sort of object-object interaction, IO event in-out, and state transitions is  hassle
10:25:07 <hpc> EvanR: i solved the problem with type World = StateT PureWorld IO
10:25:10 <EvanR> if a walls position is repeat (4:+9) then maybe thats not very intensive
10:25:33 <hpc> then updatePureWorld :: PureWorld -> (PureWorld, [World ()])
10:25:42 <monadic_kid> i've used monad transformers and fclabels to reduce boilerplate code
10:25:49 <monadic_kid> for games/demos
10:25:56 <hpc> then you do put . fst and sequence_ . snd
10:26:07 <hpc> :t sequence_
10:26:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:27:09 <monadic_kid> hpc: I what i do is split up my "mutable" global state and readonly, into StateT and ReaderT
10:27:32 <EvanR> hpc: right
10:28:03 <EvanR> hpc: was talking about the pure part...
10:28:16 <EvanR> a seemling simple entity has a lot of different states ...
10:28:40 <hpc> EvanR: oh, yeah that would be a good way to do it
10:29:06 <EvanR> the table of state x event -> state, written as cases seems to take a lot of room...
10:29:09 <hpc> imo, games shouldn't be especially lazy unless you are dealing with infinities; you can control evaluation order better
10:29:15 <hpc> er, not order, time
10:29:32 <hpc> so you don't get a bajillion thunks evaluating over a single frame
10:30:00 <EvanR> i control time in the IO part, it waits for a synchronizing mvar (driven by SDL_GetTicks) and takes the head of the lazy world and uses it
10:30:34 <hpc> ah, cool
10:35:39 <hpc> perhaps we should make #haskell-game?
10:35:56 <digitteknohippie> :)
10:36:40 <EvanR> hpc: i was thinking there needs to be more about haskell game programming
10:36:48 <hpc> yeah, lots more
10:37:22 <hpc> it's astounding the amount of design that goes into a game engine
10:37:38 <EvanR> yeah thats why i avoid engines ;)
10:37:52 <EvanR> overengineering
10:37:58 <hpc> at some point you end up making your own :P
10:38:04 <digitteknohippie> i've seen a few interesting videos about games in haskell.
10:38:18 <EvanR> i would like to think that the pieces parts can be decomposed and used in different combinations
10:38:35 <EvanR> with perhaps the central algorithm (this game board thing) being customized for the current project
10:38:38 <wli> As much work as engines are, isn't the graphic design and other media authoring vastly more work by several orders of magnitude?
10:38:54 <EvanR> ah but were coders we cant draw
10:38:55 <EvanR> ;)
10:39:01 <EvanR> so fuck it
10:39:11 <digitteknohippie> hehe, i'm an artist.  i cant code.  XD   but i still try.
10:39:25 <hpc> real games use hard-coded graphics
10:39:29 <wli> Well, there's other stuff, like mesh editing, texture something or other, and so on.
10:39:39 <hpc> real textures are saved in .hs files as [[Pixel]]
10:39:59 <EvanR> Red Red Red Red Blue Transparent Red Red Red...
10:40:23 <digitteknohippie> yikes, scary.
10:40:23 <EvanR> lazy infinite sprites!
10:40:32 <wli> Sounds unlikely as it's inconvenient for viewing at an angle.
10:40:57 <hpc> real 3D models are saved as IO (), for "abstraction" :P
10:41:39 <EvanR> well now im more determined to make the core of the game functional :(
10:41:59 * EvanR tries again
10:42:05 <digitteknohippie> :)
10:42:26 <EvanR> i almost gave up and installed pygame
10:42:37 <digitteknohippie> hehe, ew.
10:42:45 <EvanR> but then i realized i was in a python interpreter and went back to haskell
10:43:24 <EvanR> though in all seriousness the game would be ton ten years sooner
10:43:28 <EvanR> done*
10:43:59 <hpc> it's more fun this way
10:45:35 <EvanR> before i had a data type for output events which would cause IO actions between updates, but now i like the idea of using values of type IO (), good call
10:45:53 <EvanR> im thinking, sound effect
10:46:07 <monadic_kid> make  #haskell-game exist
10:46:12 <monadic_kid> do it
10:46:21 <digitteknohippie> lol
10:46:37 <digitteknohippie> i been sat in there since it was first suggested.  ^_^
10:46:38 <EvanR> stupid SDL bindings dont support sound >>>___<<<<
10:46:55 <EvanR> going to haskell-game
10:48:17 <digitteknohippie> still seems a little premature, and redundant tho.
10:48:38 <EvanR> great things always begin by being pointless
10:48:45 <digitteknohippie> :)
10:48:48 <hpc> @pl great things
10:48:48 <lambdabot> great things
10:49:07 <monochrom> pointless things always begin by being great things
10:49:28 <digitteknohippie> ah lambdabot, i've missed you.  ^_^ been away too long.  XD
10:49:44 <EvanR> lol
10:50:12 <dark> EvanR, I used to think that too, but after doing some things in python (not much, basically pygtk, cairo and pygame) I'm better using ruby or lua for a little dynamical language
10:50:29 <dark> and there is rubygame, so
10:50:55 <EvanR> i dont need a little or dynamic language
10:51:31 <monochrom> ada is a big static language :)
10:51:45 <EvanR> ada is cool
10:51:49 <dark> I'm better with python than ada
10:57:03 <proc> what's the type constructor for complex?
10:57:32 <dmhouse> :+
10:57:32 <EvanR> :+
10:57:37 <dmhouse> Oh, type constructor
10:57:41 <dmhouse> Just Complex I think
10:58:16 <dmhouse> data RealFloat a => Complex a = !a :+ !a 
11:00:37 <zachk> my first non - rpn parser http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28476#a28476 
11:00:48 <zachk> its ala scheme notation 
11:06:06 <monochrom> "non-rpn ala scheme" is pn
11:08:27 <ZekeDragon> Anyone have any experience in converting a [IO a] to IO [a]?
11:09:01 <kmc> yes
11:09:02 <Zao> mapM
11:09:02 <kmc> :t sequence
11:09:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:09:04 <copumpkin> sequence
11:09:08 <Zao> Erm, sequence :D
11:09:16 <kmc> ZekeDragon, of course there's many functions of type [IO a] -> IO [a]
11:09:20 <Zao> @type mapM id 
11:09:21 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
11:09:31 <Zao> (don't do that)
11:09:40 <kmc> sequence is the one which produces an action that performs the input actions in order
11:09:57 <kmc> but you might want another order, or might do only the first action etc.
11:09:59 <ZekeDragon> The best I got was
11:10:00 <ZekeDragon> liftList :: (Monad m) => (a -> m b) -> [a] -> m [b]
11:10:01 <ZekeDragon> liftList _ []     = return []
11:10:01 <ZekeDragon> liftList f (x:xs) = let attach = liftM2 (:)
11:10:01 <ZekeDragon>                     in f x `attach` liftList f xs
11:10:07 <kmc> in other words, when you have a list of recipes, you have freedom of how to glue them together
11:10:14 <kmc> ZekeDragon, btw if you want to paste code you can put it on hpaste.org
11:10:18 <kmc> nicer than pasting it in the chan
11:10:19 <Zao> @type mapM
11:10:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:10:26 <Zao> ZekeDragon: mapM smells like your function.
11:10:32 <ZekeDragon> Yeah, figured it was small enough, I'll keep it in mind.
11:10:35 <Zao> @src mapM
11:10:35 <lambdabot> mapM f as = sequence (map f as)
11:10:52 <Zao> @src sequence
11:10:52 <lambdabot> sequence []     = return []
11:10:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:10:53 <lambdabot> --OR
11:10:53 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
11:11:11 <ZekeDragon> Yeah, there it is.
11:11:26 <ZekeDragon> I wanted to get it without explicit recursion, and I noticed mine looked a LOT like a foldr already.
11:12:00 <ZekeDragon> Thank you./
11:12:44 <ApeShot> So is anyone out there using Data.Array.Diff with the Haskell Platform?
11:12:56 <kmc> ZekeDragon, 4 lines is probably ok, i'm not annoyed or anything ;)
11:13:16 <kmc> ApeShot, DiffArray is deprecated
11:13:23 <kmc> because it turns out to perform worse than Array usually
11:13:55 <kmc> for pure-functional updatable maps, you really want something tree- or trie-shaped
11:13:58 <ApeShot> kmc: So I am making a prototype array language interpreter which will support matlab style multidimensional arrays.
11:14:09 <kmc> e.g. Data.IntMap, or EnumMap or HashMap
11:14:19 <kmc> ok
11:14:27 <ApeShot> kmc: even though its just a learning project, what would be the best type to use
11:14:48 <ApeShot> kmc: the language itself will be pretty dynamic - do you have any experience with Matlab?
11:14:51 <kmc> if it's a learning project and performance doesn't matter, Data.Map is maybe simplest
11:14:53 <kmc> are the semantics of the language you're implementing those of destructive updates?
11:15:06 <kmc> if so, you could use IOArray or STArray
11:15:52 <ApeShot> kmc: Matlab arrays are mutable, but not copyable.
11:16:02 <ApeShot> Rather, you don't have a reference to arrays at any point
11:16:13 <ApeShot> But you can mutate an array stored in a variable.  Does that make sense?
11:16:16 <kmc> ah, so you can't alias them
11:16:22 <kmc> i think it makes sense
11:16:22 <ApeShot> kmc: exactly.
11:16:31 <ApeShot> x = y copies the array y
11:16:31 <kmc> so maybe IOArray or STArray is a good fit
11:16:37 <ApeShot> but x(10) = 11 mutates x
11:16:39 <kmc> since that will give you "real" in-place updates
11:16:41 <kmc> and good performance
11:16:48 <kmc> though to get better performance, you should unbox
11:16:58 <ApeShot> I guess as a Haskell newb I am a bit worried that I will get tangled up in all the monads
11:17:11 <kmc> check out also the "vector" library on hackage for fast fancy arrays
11:17:17 <kmc> (but geared toward IO/ST)
11:17:19 <kmc> ok
11:17:25 <ApeShot> Already I have state and error to worry about in the interpreter, I think
11:17:29 <kmc> ok
11:17:37 <ApeShot> But you recommend just soldiering on?
11:17:49 <kmc> *shrug*
11:17:54 <ApeShot> I guess its a good way to get used to the semantics of monads in haskell.
11:18:01 <kmc> if you've already got state and error, puting ST at the bottom of the stack seems all right
11:18:46 <Martty> @src product
11:18:47 <lambdabot> product = foldl (*) 1
11:19:04 <ApeShot> kmc: how should i think about the difference between IOArray and STArray?
11:19:07 * hackagebot bird 0.0.12 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.12 (MattParker)
11:19:10 <kmc> the general advice is "don't optimize prematurely", but unfortunately it's a big global change to switch from pure-functional update to mutable arrays
11:19:46 <kmc> maybe it's not *such* a big change, since your interpreter is already monadic... when i build a monad transformer stack i like to define a few domain-specific operations for the monad and hide the underlying state/error/etc. details
11:19:59 <Twey> ApeShot: IOArray requires that you use all of IO, whereas STArray can be used in ST (so you can give it a pure interface).
11:20:33 <ApeShot> Twey: thanks
11:20:59 <kmc> so if you define a read/write array operation, you can implement it with State + Data.Map, and switch later to STUArray or such
11:21:01 <Saizan> i can't stop being amused by matlab not passing arrays by reference after a good part of my numerical analisys course was about silly ways to pack the result in the argument's memory.
11:21:17 <seydar> guys i have really good news
11:21:20 <seydar> IRC works
11:21:23 <Twey> ApeShot: ST is basically a restricted version of IO that uses type-trickery to ensure that you can perform mutable updates within a specific context, but that the operation as a whole remains referentially transparent
11:21:56 <kmc> runST is very much like unsafePerformIO (in GHC's implementation), but uses the type system to prove safety = referential transparency
11:23:10 <kmc> safety (= referential transparency)*
11:24:04 <dons> ?yow
11:24:05 <lambdabot> Couldn't find fortune file
11:24:09 <copumpkin> omg a dons
11:24:20 <dons> back from vacation :-) 
11:24:20 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:24:24 <dons> lets write some code!!!
11:24:33 <copumpkin> me too!
11:24:34 <seydar> omg a pumpkin
11:24:35 <copumpkin> omg
11:24:38 <copumpkin> omg a seydar
11:24:51 <dons> ClaudiusMaximus: did you find forkOnIO ?
11:25:21 <seydar> copumpkin: i got a computer that doesn't suck and isn't 5 years old that my parents kept updating despite my begging
11:25:27 <seydar> and i have ghc
11:25:30 <seydar> and guess what
11:25:37 <seydar> it took under 10 hours to install!
11:26:05 <dons> seydar: you can't use the platform installers?
11:26:11 <BCoppens> dons: I've noticed a lack of new galois tech talks on vimeo, is this abandoned or just 'in the queue'? :)
11:26:19 <dons> BCoppens: oh, definitely not abandoned!
11:26:36 <BCoppens> dons: yay
11:26:36 <dons> BCoppens: i think our video guys might be a bit swamped with other things. will check in tomorrow
11:26:49 <tommd> Tuesday's talk should be good!
11:26:53 <seydar> dons: I'm not sure why, but I'm morally against using large packages like that
11:26:53 <BCoppens> thanks, I was reminded when I saw the announcement of the next talk ;)
11:26:54 <dons> yeah, looking forward to it.
11:27:02 <dons> seydar: ok. you're trading space for your personal time.
11:27:29 <dons> and 100M is small in 2010. we have terabytes to spare these days.
11:27:30 <ClaudiusMaximus> dons: hi, yes - but it didn't seem to do what i wanted (bind the main thread to the same core as Xorg for cache benefits, for example)
11:27:38 <tommd> Anyone going to TechCoffee tomorrow (/end assumption that all of #haskell lives in Portland)
11:27:48 <ClaudiusMaximus> dons: i was probably using it wrong
11:27:48 <dons> ClaudiusMaximus: well, it should pin a haskell thread to an os thread. 
11:27:56 <dons> to pin the os thread, you should use your kernel affinity tools
11:28:01 <dons> tommd: hmm.
11:28:03 <ClaudiusMaximus> right, makes sense
11:28:04 <dons> tommd: interesting.
11:28:15 <seydar> how does cabal alter the load path for libraries?
11:28:27 <tommd> I intend to go and hammer out the next iteration of crypto-api (finally).
11:28:55 <tommd> That means quickcheck properties for algorithms, hmac, and modes.
11:29:16 <dons> that sounds worthy.
11:29:52 <tommd> And I think this will be the first time I send an e-mail indicating (some) modes are implemented in the darcs repo.
11:29:57 <ClaudiusMaximus> dons: fwiw, here's the messy graph of where i tried to use ghc-gc-tune to find optimal settings to reduce jitter (and failed).. http://claudiusmaximus.goto10.org/g/misc/mess.png
11:30:09 <tommd> no GCM or other fancy modes, but basic stuff is there.
11:30:10 * hackagebot bitstring 0.0.0 - Lazy bit strings  http://hackage.haskell.org/package/bitstring-0.0.0 (BalazsKomuves)
11:30:42 <seydar> forgive my nubitude, but is map actually implemented as going parallel when possible?
11:30:48 <Heffalump> seydar: no
11:31:21 <ClaudiusMaximus> dons: turns out that some simple code changes made much more difference (ie, calling swapBuffers at the start of the display callback instead of somewhere in the middle - so +40ms latence but -8ms jitter)
11:31:25 <dons> seydar: no, you'd need to use something like parMap from the parallel package.
11:31:30 <kmc> seydar, for parallel stuff see http://hackage.haskell.org/package/parallel
11:31:36 <dons> ClaudiusMaximus: very interesting
11:31:50 <seydar> cool. thank you
11:32:00 <seydar> and how does cabal alter the load paths for libraries?
11:32:29 <tommd> dons: Did you ever make a hackage/cabal package of that genetic alg library you've been using?
11:32:30 <kmc> dons, i really like your "Multicore Programming in Haskell Now!" talk from DEFUN 2009, but by now it's a bit out of date... is there something similar i should link people to instead?
11:32:41 <tommd> As in, Haskell bindings to the GA library.
11:33:00 <dons> tommd: it needs a huge chunk of fairly uncommon C code.
11:33:05 <tommd> ahh
11:33:16 <dons> kmc: well, i gave a more recent version at DevNation
11:33:38 <dons> tommd: my plan is a tool more like ghc-gc-tune for running a program under the framework, with the ghc flags.
11:33:57 <ClaudiusMaximus> is there a data-parallel library for GPU yet?
11:33:58 <dons> seydar: what are you trying to do? why would you need to alter "load paths" . LDD paths?
11:34:00 <monochrom> is the new title "Multicore Programming in Haskell Yesterday"?
11:34:07 <dons> ClaudiusMaximus: yeah. accelerate has a cuda backend
11:34:15 <seydar> dons: I'm just curious. I want to know how the magician does his tricks
11:34:33 <dons> seydar: dig around inside the Cabal src, its moderately straightforward
11:34:42 <dons> cabal unpack Cabal
11:35:12 <ClaudiusMaximus> dons: cool
11:36:29 <xarch> I have a problem with the container package, all its content can't be loaded (I use Archlinux), do you know how I can fix that ?
11:36:48 <seydar> thanks dons 
11:36:52 <seydar> copumpkin: nnnnnnnnnnnerd
11:37:08 <copumpkin> yes, but why?
11:37:28 <kmc> xarch, can you be more specifc, maybe put an error message on hpaste?
11:38:12 * hackagebot on-a-horse 0.2 - "Haskell on a Horse" - A combinatorial web framework  http://hackage.haskell.org/package/on-a-horse-0.2 (JasonPriestley)
11:38:35 <dons> xarch: hmm.
11:38:36 <monochrom> hpaste tries to syntax-colour error messages as haskell code
11:39:11 <xarch> kmc: « Could not find module `Data.Map': it is not a module in the current program, or in any known package. »
11:39:27 <seydar> copumpkin: you on campus?
11:39:29 <dons> sounds like a broken install. no containers package provided by ghc
11:39:45 <xarch> but I can paste the output of ghci -v
11:39:59 * geheimdienst loves the package name "haskell on a horse"
11:40:17 <monochrom> haskell on a horsy...
11:40:58 <ksf> are there any grapefruit tutorials aroung?
11:41:17 <ksf> and no, I _don't_ mean the haddock or the examples package
11:41:36 <ksf> ...something where you understand the haddock and examples after you've read it would be nice.
11:43:00 <tensorpudding> oh man, they stole my idea
11:43:22 <ksf> what, providing packages without proper documentation?
11:43:27 <tensorpudding> no
11:43:37 <monochrom> yay, haskell on a horsy uses arrowsy
11:43:44 <tensorpudding> i decided that the best name for a haskell web framework would be "Haskell on Horseback"
11:44:06 <copumpkin> tensorpudding: sue them!
11:44:19 <ksf> http://www.haskell.org/haskellwiki/Reactive/Tutorial/A_FPS_display
11:44:25 <ksf> _that_ is a good intro tutorial
11:44:29 <ksf> (no wonder, I wrote it)
11:44:34 <tensorpudding> Yes, I'll sue them for a vague musing I had a year ago
11:44:42 <copumpkin> yep
11:44:44 <tensorpudding> I could show my IM records as proof of concept
11:45:57 <seydar> what's hpc do?
11:46:12 <hpc> he makes jokes and answers questions
11:46:19 <monochrom> "haskell on the tubes"
11:46:20 <hpc> also profiling
11:46:41 <monochrom> haha
11:47:04 <seydar> haha
11:47:29 <kmc> seydar, http://book.realworldhaskell.org/read/testing-and-quality-assurance.html last section
11:47:36 <ApeShot> Is there a haskell-mode for emacs that doesn't just go totally insane with indentation?
11:47:38 <seydar> thanks kmc 
11:47:55 <roconnor> ApeShot: let me know if you find one
11:48:01 <ghc-pkg> haskell-mode for emacs does not go insance at all with indentation. I use it.
11:48:10 <geheimdienst> "im in ur interwebs, framworkin ... framin work ... workin frame ... helpin u wif teh web app"
11:48:11 <roconnor> I don't use haskell-mode because indentation is insane last time I used it
11:48:19 <ApeShot> roconnor
11:48:21 <roconnor> 8 years ago
11:48:39 <ghc-pkg> be sure to select the "advanced" indentation algorithm
11:48:48 <ApeShot> ghc-pkg: When I have a function definition after a new type, and I press tab
11:49:03 <tensorpudding> haskell-mode's indentation is fine to me
11:49:08 <ApeShot> ghc-pkg: everything lines up with the equal sign in the newtype expression
11:49:12 <ksf> \o/ a new reactive version!
11:49:17 <ghc-pkg> does not happen to me
11:49:22 <tensorpudding> sometimes you have to hit it a few times if you're doing a list that takes multiple lines
11:49:29 <tensorpudding> to get the commas to line up
11:51:21 <ApeShot> http://paste.lisp.org/submit
11:51:24 <solrize> does anyone know the url of that FRP article that has the demo with the bouncing balls?
11:51:28 <ghc-pkg> then again I'm still at version 2.7.0
11:51:29 <ApeShot> Sorry
11:52:04 <ApeShot> http://paste.lisp.org/display/113048
11:52:15 <ApeShot> ghc-pkg: that is what happens
11:52:28 <Martty> why is the notation: f [] = []; f (x:xs) = x; and not f [x:xs] = x; ? -_-
11:52:39 <ApeShot> ghc-pkg: in my configure-haskell.el I have turned on turn-on-haskell-indentation
11:52:52 <ApeShot> ghc-pkg: I seem to recall there being a few things to play with with respect to indentation in haskell
11:53:06 <ApeShot> ghc-pkg: Haskell should just use s-expressions 
11:53:14 <ApeShot> ghc-pkg: syntax is bullshit 
11:53:23 <Zao> Martty: Because [x:xs] would match a list with one element, which is a list with at least one element.
11:53:51 <Zao> > let [x:xs] = ["asdf"] in (x, xs)
11:53:52 <lambdabot>   ('a',"sdf")
11:54:05 <Martty> O_o
11:54:10 <Zao> > let [x:xs] = ["asdf", "lol"] in (x, xs)
11:54:11 <lambdabot>   (*Exception: <interactive>:1:137-160: Irrefutable pattern failed for patter...
11:54:14 <ghc-pkg> still does not happen to me
11:54:18 <dolio> s-expressions are still syntax.
11:54:22 <dolio> They're just bad syntax.
11:54:22 <geheimdienst> > let (x:xs) = ["asdf"] in (x, xs)
11:54:22 <lambdabot>   ("asdf",[])
11:54:39 <Martty> Zao i mean why is the pattern (x:xs) when you are matching against a list and not a tuple.. isnt it more natural to use [x:xs] ?
11:54:40 <Zao> [x:xs] is like ((x:xs):[])
11:54:43 <roconnor> > let ((x:xs):xss) = ["asdf","lol"] in (x,xs,xss)
11:54:44 <lambdabot>   ('a',"sdf",["lol"])
11:54:46 <zygoloid> Martty: [x] == x:[], so [x:xs] == (x:xs):[]
11:54:53 <Zao> Martty: The parens are grouping there, not a 1-tuple.
11:54:56 <Zao> (as there's no such thing)
11:55:01 <kmc> "sexps are syntax" is missing the point.  each and every special form is synta
11:55:03 <kmc> x
11:55:11 <Zao> Martty: (a,b) is a tuple. [a,b] is a list of two elements.
11:55:11 * digitteknohippie sees stuff in a search's results that gives him ideas
11:55:12 <ghc-pkg> use (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation). don't use 'turn-on-haskell-indent or 'turn-on-haskell-simple-indent
11:55:13 <digitteknohippie> oh man oh man oh man....  can u use haskell in spreadsheets!?!!?!!!!!  :O    *drools*
11:55:20 <Zao> The latter being sugar for a:b:[]
11:55:31 <Martty> Zao right, got it im just a little surprised
11:55:34 <seydar> please don't get mad, but I don't have cabal installed
11:55:40 <kmc> sexps are the syntax of lisp, only if you think lisp is a language for describing list literals
11:55:40 <ghc-pkg> anyway cannot reproduce problem
11:55:40 <seydar> and I'd like to install it from source
11:55:48 <dolio> kmc: Right. You define the syntax via special trees, instead of special character sequences.
11:55:54 <geheimdienst> > let [(x:xs)] = ["asdf"] in (x, xs)
11:55:55 <lambdabot>   ('a',"sdf")
11:55:57 <kmc> if you care about eval'ing those lists as programs, you have another layer of syntax
11:56:00 <geheimdienst> > let [x:xs] = ["asdf"] in (x, xs)
11:56:02 <lambdabot>   ('a',"sdf")
11:56:02 <seydar> but it seems that cabal-install requires the cabal library which requires cabal
11:56:26 <geheimdienst> ah, so that's the same
11:56:40 <seydar> i'm figuring it out but everyone be aware that i'm crying
11:56:42 <Zao> (:) has no special meaning inside [].
11:56:56 <Zao> Only , and .. and ,..
11:56:59 <geheimdienst> martty, but i agree, the syntax is a little strange
11:57:07 <Zao> (and list comprehension crap, of course)
11:57:19 <Martty> geheimdienst :<
11:57:21 <kmc> Martty, if you ignore the special syntax for lists, you can define them yourself as «data List a = Nil | Cons a (List a)»
11:57:23 <ApeShot> I just like simple things, is all
11:57:37 <somnium> I installed the haskell platform, and am trying to run the GLUT examples, but when I run try `runhaskell Simple.hs' in examples/BOGLGP I get a missing symbol and 'unable to load package GLUT-2.1.2.1' 
11:57:41 <Martty> kmc what do i win with that?
11:57:45 <kmc> and then the pattern (x:xs) is just the infix version of (Cons x xs)
11:57:55 <Zao> Martty: Less overloaded glyphs in your mind.
11:57:58 <Martty> heh
11:58:07 <somnium> am I missing some flags, or is my install screwed up, or ...?
11:58:11 <Zao> Martty: You would of course not use it, just use it to think about things.
11:58:22 <Martty> i think i can get used to (x:xs) 
11:58:27 <Zao> @src []
11:58:27 <lambdabot> data [] a = [] | a : [a]
11:58:34 <monochrom> I keep pressing "tab" with cursor at "in", in fact nothing moves at all after aligning "let" with "in".
11:58:36 <Martty> @src filter
11:58:36 <lambdabot> filter _ []     = []
11:58:36 <lambdabot> filter p (x:xs)
11:58:36 <lambdabot>     | p x       = x : filter p xs
11:58:36 <lambdabot>     | otherwise = filter p xs
11:58:38 <kmc> whereas [x:xs] is like «Cons (Cons x xs) Nil», because «[x]» is sugar for «Cons x Nil»
11:58:53 <kmc> i.e. a one-element list
11:59:17 <kmc> «[p]» is always a pattern for a one-element list, even if p is itself a pattern for a multi-element list.  in that case you have a list of lists
11:59:30 <Martty> heh i had forgotten how nice this channel is
11:59:34 <Martty> thanks everyone
11:59:49 <ksf> yeah, kmc's mother is really nice.
11:59:52 <geheimdienst> > let [x..] = "lolcat" in (x)
11:59:53 <lambdabot>   <no location info>: Parse error in pattern
12:00:04 <geheimdienst> > let [x,y] = "lolcat" in (x)
12:00:04 <lambdabot>   *Exception: <interactive>:1:137-152: Irrefutable pattern failed for pattern...
12:00:13 <kmc> ksf, ?
12:00:17 <geheimdienst> > let [x,y] = "lo" in (x,y)
12:00:18 <lambdabot>   ('l','o')
12:00:33 <ksf> yo ma is _nice_, kmc.
12:00:36 <kmc> heh
12:00:43 <geheimdienst> kmc, it's a "yo mama" insult, #haskell-style
12:01:02 <geheimdienst> yo mama is so nice, she could be on #haskell
12:01:09 <copumpkin> yo mama jokes are unsafe on the internet when you don't know people
12:01:23 <geheimdienst> yo mama is unsafe?
12:01:24 <copumpkin> for all you know, the target's mother could've died a horrible death a few days earlier
12:02:22 <ksf> yo mama is so impure, she does IO all the time?
12:02:23 <dolio> The jerk store called, they're all out of you!
12:02:30 <geheimdienst> yo mama is so unsafe, she's in System.IO.Unsafe
12:03:27 <monochrom> version 2.8.0 still doesn't do it to me
12:04:31 <copumpkin> monochrom: scala?
12:05:14 <monochrom> emacs haskell-mode
12:05:46 <monochrom> someone claims problem http://paste.lisp.org/display/113048 . cannot be reproduced.
12:06:54 <monochrom> why do people run into software problems that I cannot reproduce
12:07:58 <monochrom> "ghc takes 10 hours to install on 2010 hardware" well it takes me 5 minutes on 2009 hardware
12:08:02 <int-e> well, ask about haskell-mode version and indentation mode used.
12:08:13 <int-e> there are several :/
12:08:24 <seydar> uhoh! bug while trying to install Cabal: http://pastie.org/1069887
12:09:27 <monochrom> actually it's more like 2008 hardware on clearance sale in january 2009
12:11:11 <seydar> monochrom: ghc took me 10 hours to build on 2005 hardware
12:11:52 <geheimdienst> maybe the difference is installing from source vs. installing from binary
12:12:08 <monochrom> you know what? I used to build ghc on 2000 hardware. only 5 hours.
12:12:42 <monochrom> and recall that in those days ghc was bigger, not smaller, cf, "extralibs"
12:13:02 <monochrom> I cannot reproduce your problem. PEBKAC
12:14:34 <seydar> monochrom: yeah, my old compy super sucked. I don't know what went wrong with it. and i'm probably exaggerating with the 10 hours claim, but hot damn it was a long time.
12:14:51 <int-e> seydar: odd, but I suspect things were broken already before you started -- a guess: did you remove ~/.cabal/lib but not ~/.ghc/wherever-the-user-package-configuration-is? (ghc-pkg list will tell you which package.conf files it uses)
12:15:02 <geheimdienst> maybe it's strange platform differences ... "when you do X, mac os x creates a temp file" vs. "linux does it in memory" ...
12:15:46 <mietek> I am deeply confused by iteratees.
12:15:58 <mietek> Does anyone wish to chat about them?
12:16:09 <digitteknohippie> i am deeply irritated by confusion
12:16:16 <Zao> They talk one step at a time :D
12:16:23 <seydar> int-e: that is exactly what I did. I installed Cabal on its own, then found out cabal-install ALSO installs Cabal, so I removed ~/.cabal
12:16:24 <ApeShot> I am deeply confused by irritation at confusion 
12:16:35 <c_wraith> circularity achieved!
12:16:41 <geheimdienst> i am deeply iterated by confusion
12:16:43 <digitteknohippie> me to, no er.. wha'?    grrrr.
12:16:47 <seydar> int-e: what is your prescription for fixing this, doc?
12:16:51 <Twey> I am deeply confused by irritation
12:16:53 <roconnor> mietek: sure, but I don't understand them either.
12:17:05 <roconnor> mietek: so I'm a great person to talk to them about :)
12:17:10 <int-e> seydar: remove the user package.conf as well.
12:17:11 <Twey> mietek: What's your confusion?
12:17:26 <mietek> The idea is simple, just process input as it comes along
12:17:39 <int-e> seydar: if you still have broken packages afterwards, reinstall from scratch.
12:18:01 <roconnor> that doesn't sound like the idea to me
12:18:14 <seydar> int-e: which part do I reinstall from scratch?
12:18:22 <int-e> seydar: you'll notice that bootstrap.sh did not, in fact, try to install Cabal again.
12:18:25 <mietek> Perhaps I'm more confused than I though.
12:18:30 <roconnor> I thought it was process chucks of data and pass a continuation to process the rest
12:18:48 <roconnor> but again, I don't know the topic
12:19:41 <int-e> seydar: ghc and libraries.
12:20:31 <kmc> mietek, i have a dim understanding of iteratees, but perhaps i can help
12:20:48 <seydar> int-e: well good news. I removed the ~/.ghc/.../cabal-xxxxx.conf thing
12:21:00 <seydar> and all is well now. thank you so much for know exactly what I did
12:21:04 <kmc> did you read http://cdsmith.wordpress.com/2010/05/23/iteratees-step-by-step-part-1/ mietek
12:21:20 <int-e> seydar: ok, good luck.
12:21:22 <mietek> I'm trying to think of iteratees as state machines, which can either consume input or leave it unconsumed, and can yield output or not, and can transition to a different state.
12:21:49 <Twey> That pretty much works
12:22:10 <Twey> Have you read the TMR article?
12:22:11 <mietek> kmc: thanks, I have that open, along with 5 different pages...
12:22:16 <mietek> Twey: yes. :)
12:22:32 <mietek> Each explanation makes sense to me, up until the details of the Monad instance
12:23:34 <roconnor> Twey: where is TMR article?
12:23:42 <mietek> http://themonadreader.files.wordpress.com/2010/05/issue16.pdf
12:23:52 <Twey> Yeah, that one.
12:24:00 <mietek> There's also http://ianen.org/articles/understanding-iteratees/ and http://therning.org/magnus/archives/735
12:24:02 <Twey> Page 19
12:24:23 <mietek> And Oleg's notes in the source files on http://okmij.org/ftp/Streams.html
12:24:40 <mietek> And finally http://www.haskell.org/haskellwiki/Enumerator_and_iteratee
12:24:43 <mietek> :)
12:25:35 <ksf> \o/ fieldtrip compiles
12:25:55 <ksf> (after a serious amount of instance writing)
12:28:21 <mietek> Twey: The TMR implementation seems to say that an iteratee can only ever return a single output value, once it gets to the final done state.
12:28:57 <mietek> Do I understand it correctly?
12:36:23 <roconnor> @src repeatM
12:36:24 <lambdabot> Source not found.
12:36:26 <roconnor> @src repeatM_
12:36:27 <lambdabot> Source not found. It can only be attributed to human error.
12:36:40 <aristid> :t sequence . repeat
12:36:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
12:36:42 * roconnor remembers the repeatM discussion and signs
12:36:53 <roconnor> *sighs
12:36:55 <kmc> oh, reminds me of a cool trick i saw in the xmonad source
12:37:00 <kmc> fix $ \again -> do ...
12:37:21 <kmc> it's a loop, you execute "again" to do it over again
12:37:28 <Anarch> How can I output a byte with a value in 128..255 using only standard libraries?
12:38:08 <Zao> kmc: Quite cute indeed.
12:38:29 <Zao> kmc: flip fix "asdf" $ \x y -> ...
12:38:38 <Zao> kmc: more fun if you provide parameters.
12:38:46 <kmc> :t flip fix
12:38:47 <lambdabot> forall a b. a -> ((a -> b) -> a -> b) -> b
12:39:36 <Zao> I dread to see a generalization.
12:39:48 <Zao> (a function on the above style can be found in the geordi source)
12:40:36 <kmc> Anarch, is bytestring standard?
12:40:43 <kmc> kinda silly to build a whole bytestring for one byte, though
12:41:52 <kmc> ah hSetBinaryMode :: Handle -> Bool -> IO () "This has the same effect as calling hSetEncoding with latin1, together with hSetNewlineMode with noNewlineTranslation."
12:42:06 <kmc> and there's withBinaryFile and openBinaryFile
12:43:28 <Anarch> kmc: not in hugs
12:43:54 <kmc> Anarch, so if you write a Char to a file in binary mode, you get a single byte, the unicode value of the char mod 256
12:43:57 <kmc> ah, i don't know about hugs
12:44:00 <kmc> btw why are you using hugs?
12:44:05 <nooodl> having winghci errors :/
12:44:18 <nooodl> "CreateGHCiProcess failed with failed with error 18".
12:44:19 <Anarch> kmc: I thought hugs would be easier to start with.
12:44:29 <ZekeDragon> Is there any way I can download the Haskell POSIX docs to my local hard drive (A provided download due to lazy)?
12:44:29 <Twey> No, it's just crippled
12:44:32 <nooodl> "There are no more files".
12:44:39 <kmc> Anarch, i doubt it, hugs is stale (has not been updated in 4 years) and unpopular
12:44:43 <kmc> ghci is what most people learn on
12:45:13 <kmc> ZekeDragon, grab the tarball of the package off hackage and run "cabal haddock"
12:45:15 <Anarch> kmc: OK, thanks, I'm getting that impression.
12:45:57 <kmc> i wish hugs would get more love, though
12:46:02 <kmc> it has some cool extensions not in GHC
12:46:10 <kmc> and a portable interpreter in C is a great thing to have
12:46:12 <ZekeDragon> kmc: Unfortunately cabal wouldn't install properly itself due to a lack of the time library, that was my next question. :P
12:46:16 <kmc> especially if it can run a self-hosted compiler
12:46:28 <kmc> ZekeDragon, time comes with ghc, what did you do to your poor Haskell system ;P
12:46:49 <ZekeDragon> sudo apt-get install ghc? O_o
12:47:28 <ZekeDragon> I'll give it a reinstall.
12:47:33 <kmc> apt-get install haskell-platform
12:47:37 <kmc> on recentish debian
12:47:47 <kmc> you really want the Platform unless you're doing something specialized
12:47:56 <ZekeDragon> Okay.
12:49:09 <kmc> if you have a sane ghc install and working cabal then you can bootstrap up to Platform
12:49:17 <kmc> but it sounds like your install is a bit broken
12:53:43 <ksf> ...and finally, my fps tutorial compiles again.
12:53:49 <ksf> problem being, it doesn't work.
12:53:53 <ksf> and I have no idea why
12:54:12 <ksf> ...just that it burns quite a lot of cpu and exits cleanly.
12:55:26 <hpc> @let s (++:) o = s ++ (show o)
12:55:26 <lambdabot>  <local>:15:12:
12:55:26 <lambdabot>      Ambiguous occurrence `s'
12:55:26 <lambdabot>      It could refer to either `...
12:55:36 <ksf> oh, and it's leaking like a sieve.
12:57:08 <ksf> hmmm it's probably a fieldtrip problem, as reactive-glut works flawlessly.
13:01:10 <ksf> @ask conal are there release notes for the new reactive version anywhere? 
13:01:10 <lambdabot> Consider it noted.
13:02:51 <ksf> *grmbl*
13:03:10 <ksf> I'm still drawn towards elerea because that I am capable of understanding.
13:03:40 <ksf> then, on other days, I just want to implement everything with actors
13:06:01 <ksf> somehow, every single high-level ui project has a very, very low bus factor
13:07:27 <ksf> hopefully stuff changes for the better once we get sane heterogenous extensible records
13:07:54 <ksf> grapefruit is going to lengths to hack them into haskell, and it doesn't add well to the already perlish syntax.
13:07:58 <geheimdienst> a low bus factor? there's tons of people who understand the project perfectly?
13:08:53 <ksf> I've seen tons of single-developer projects each of which sooner or later died or is currently undead.
13:09:17 <ksf> out of all grapefruit seems to be the most active, but it doesn't have any users, either.
13:10:38 * roconnor has only used GuiTV
13:11:16 * ksf puts some coke in his red wine
13:12:08 <geheimdienst> oh i see. low bus factor = 1 ...
13:12:30 <ksf> and then there's one thing I don't like about virtually every project, which is that it isn't sufficiently backend-agnostic.
13:13:23 <ksf> that is, the first thing to do should be to define an interface that specifies the behaviour of a program, and then write guis around that.
13:13:28 <geheimdienst> "bus factor" is a nice notion. but maybe "bus count" would have been clearer. "factor" doesn't suggest what low and high means
13:13:28 <ksf> server/client, if you want.
13:13:58 <ksf> it's a factor because it factors into the survival of floss projects
13:14:09 <ksf> ...not in the mathematical sense.
13:15:49 <ksf> how was that package called that could generate guis and text-mode queries from the same source?
13:16:35 <geheimdienst> hm okay, that's an explanation too. i first thought: bus factor = key developers / people relying on the project
13:17:00 <geheimdienst> that would be a good measure, too
13:18:45 <inimino> project annihilation = bus factor * busses
13:21:24 <wioux> > maximum [1..1000000]
13:21:25 <roconnor> should it depend also on the number of busses :)
13:21:26 <lambdabot>   *Exception: stack overflow
13:21:34 <roconnor> 1000000
13:22:05 <wioux> thats lame..
13:22:43 <roconnor> > foldl1' max [1..1000000]
13:22:44 <lambdabot>   1000000
13:22:51 <Twey> > foldl' max 0 [1 .. 1000000]
13:22:52 <lambdabot>   1000000
13:22:55 <Twey> > maximum []
13:22:56 <lambdabot>   *Exception: Prelude.maximum: empty list
13:22:58 <roconnor> it's a tricky issue
13:22:59 <Twey> Oh, it is
13:23:05 <Twey> Okay
13:23:05 <wioux> ah thanks :)
13:23:19 <nphg|laptop> @src maximum
13:23:19 <lambdabot> maximum [] = undefined
13:23:20 <lambdabot> maximum xs = foldl1 max xs
13:23:20 <Twey> But yeah… maximum won't exhibit that behaviour compiled with -O
13:23:29 <roconnor> if maximum is lazy or strict, there will be compaints either way
13:23:46 <roconnor> wioux: I guess I'd be inclined to define maximum' = foldl1' max
13:24:06 <roconnor> mabye give [] an nicer error message
13:24:35 <Gracenotes> @check \xs ys -> let t = union (nub xs) ys in nub t == t
13:24:36 <lambdabot>   "OK, passed 500 tests."
13:24:52 <Gracenotes> @check \xs ys -> let t = union xs ys in nub t == t
13:24:53 <lambdabot>   "Falsifiable, after 4 tests:\n[(),(),()]\n[(),(),()]\n"
13:26:21 <Phyx-> @hoogle cd e30f6010
13:26:22 <lambdabot> No results found
13:26:25 <Phyx-> @hoogle e30f6010
13:26:26 <lambdabot> No results found
13:26:41 <Phyx-> that can't be using the same google i am
13:27:39 <geheimdienst> > "hoogle" /= "google"
13:27:41 <lambdabot>   True
13:27:45 <Phyx-> oops
13:27:48 <geheimdienst> phyx-, listen to lambdabot
13:27:52 <Phyx-> @google e30f6010
13:27:53 <lambdabot> No Result Found.
13:28:00 <Phyx-> my point still stands :P
13:28:06 <hpc> > "hoogle" > "google"
13:28:06 <lambdabot>   True
13:28:09 <geheimdienst> lol
13:28:44 <copumpkin> > "haskell" > "clojure"
13:28:45 <lambdabot>   True
13:28:46 <Phyx-> it must be failing to parse or something
13:28:57 <Phyx-> > "me" > "you"
13:28:59 <lambdabot>   False
13:29:02 <Phyx-> ouch...
13:29:02 <geheimdienst> > "hayoo" > "hoogle"
13:29:03 <lambdabot>   False
13:29:09 <hpc> > "haskell" > "perl"
13:29:09 <lambdabot>   False
13:29:28 <Liskni_si> > "bull" > "shit"
13:29:29 <lambdabot>   False
13:29:47 <Phyx-> > me == "elite"
13:29:49 <lambdabot>   True
13:30:18 <geheimdienst> i think google these days doesn't show the same results for everyone ... depends on your country of origin, your settings, etc. it's possible that the google api has different results than a google web search from phyx-' computer
13:30:36 <Gracenotes> it's also affected by which links you've clicked in the past
13:30:41 <hpc> google also uses your account if you have one
13:30:53 <Phyx-> i don't search while signed in
13:30:53 <Gracenotes> if you let it record that. :.
13:30:54 <Phyx-> :/
13:31:03 <geheimdienst> it also depends what language your browser is set to
13:31:04 <Phyx-> <-- paranoid
13:31:19 <Phyx-> <- US English
13:31:24 <hpc> Phyx-: i don't search with cookies enabled
13:31:30 <Phyx-> i hate it when sites check my ip and give me dutch :/
13:31:41 <hpc> well, that's not fair
13:31:45 <geheimdienst> i have one browser for valuable stuff (mail + banking) and one browser with everything else
13:31:46 <hpc> i have a whitelist for cookies and javascript
13:32:08 <Phyx-> geheimdienst: i use porn mode when banking etc
13:32:09 <geheimdienst> phyx-, just move to holland. problem solved
13:32:18 <Phyx-> geheimdienst: i do live in holland...
13:32:24 <Phyx-> I just don't like it :/
13:32:31 <Phyx-> give me a list
13:32:34 <Phyx-> let me choose
13:32:54 <Phyx-> don't default to a language and hide the option to change it back in xxx clicks
13:33:02 <geheimdienst> i agree that the browser language settings should take precedence over the ip lookup stunt
13:33:42 <Phyx-> exactly, I hate traveling around and getting different languaged pages
13:33:48 <Phyx-> some of which I can't read
13:35:20 * Phyx- sounds like a cranky geek
13:37:08 <dancor> this internet didn't really pan out the way we hoped
13:38:06 <Phyx-> aint that the truth..
13:38:40 <nooodl> wow, haskell is nice for project euler
13:40:21 * Phyx- used to think ghc's error messages were non-helpful, untill he went back to c#
13:40:39 <Phyx-> "Syntax error in INSERT statement"
13:40:47 <Phyx-> no s**T but where...
13:41:00 <Phyx-> give me a column number you stupid  thing
13:45:40 <NaCl> Hello.
13:45:46 <roconnor> we need iterette error messages
13:46:00 <roconnor> error HERE.  Would you like to know more ...
13:46:17 <tommd> NaCl: Are you using a native client or a foreign one?
13:46:17 <NaCl> Should I install haskell packages using my distribution's package manager or with cabal?
13:46:28 <dons> NaCl: what is your distribution?
13:46:32 <NaCl> dons: slack
13:46:35 <tommd> NaCl: I use cabal to stay up to date.
13:46:42 <tommd> Esp on Slack, I'd think.
13:46:46 <dons> NaCl: they have very few packages, afaik, so probably best to use cabal for most things
13:46:56 <NaCl> yeah.
13:46:57 <dons> debian, fedora, arch, gentoo: best to prefer distro packages, then cabal for extras
13:46:59 <NaCl> It was all fun and games
13:47:09 <NaCl> then I tried to get all the deps for yi
13:47:32 <NaCl> Then I kinda gave up. :P
13:47:39 <dons> right. cabal install yi
13:47:40 <roconnor> for executables I se no reason not to use the distro packages.
13:47:42 <dons> problem solved :-)
13:47:52 <roconnor> oh
13:47:53 <roconnor> ya
13:47:57 <Paczesiowa> is it normal for ghc to use huge amounts of memory when trying to unbox strict fields? I've added one UNPACK pragma and ghc compilation needs more then 1gb memory more then without it
13:48:00 <roconnor> unless your distro has no dependency chaser
13:48:02 <roconnor> god
13:48:12 <dons> Paczesiowa: it might be triggering massive inlining and specialization
13:48:14 <NaCl> roconnor: which is the defining feature of Slack
13:48:17 <ezyang> Paczesiowa: Do you have lots of strict fields? 
13:48:22 <dons> Paczesiowa: i.e. the compiler has found some new optimizations
13:48:49 <roconnor> NaCl: I use nixos.  What's the benifits of Slack?
13:48:52 <dons> Paczesiowa: 1G is pretty high, though not unheard of, if  there is a lot of optimization available
13:49:02 <Paczesiowa> damn, I need more ram:/
13:49:05 <NaCl> roconnor: stable, and users have complete control over thhe system
13:49:17 <Phyx-> hmm, so adding UNPACK can slow things down potentially then? since different optimizations are ran
13:49:37 <dons> Phyx-: can slow down compilation
13:49:46 <Paczesiowa> Phyx-: I don't know if it makes things faster, I can't finish compiling
13:50:04 <dancor> what do ppl know about this hs2js project: http://vir.mskhug.ru/wiki/DevelopmentStatus
13:50:11 <Phyx-> dons: and execution? I could have sworn adding the UNPACKs slowed the code down
13:50:24 <dancor> this ghc2js project even
13:50:31 * NaCl uninstalls stuff from the package manager and makes a package for cabal
13:51:23 <dons> Phyx-: that's not its purpose, usually it improves data density, improving performance and reducing memory consumption
13:51:36 <NaCl> Actually, while I'm thinking about it...
13:51:41 <dons> there's some odd pathological cases where it can add additional reboxing, but that's very rare.
13:52:11 <NaCl> I know I'm likely to get a biased result, but is there any functional language I should try out before any others?
13:52:13 <Phyx-> dons: how about in combinations with alot of strict fields?
13:52:18 <NaCl> I mean, to get an idea of what's going on
13:52:53 <dons> Phyx-: tends to make things better.
13:53:02 <dons> NaCl: opinions vary
13:53:13 <monochrom> pick any: f#, sml, ocaml, haskell
13:53:18 <dons> NaCl: http://stackoverflow.com/questions/102911/whats-a-good-functional-language-to-learn-first
13:53:23 * Phyx- doesn't know why this became slower then
13:53:58 <NaCl> yeah, that's kind of what I thought
13:54:07 <dons> Phyx-: profile and look at the heap graph
13:54:17 * NaCl bravely attempts to install cabal
13:54:37 <Phyx-> dons: can't, not untill Bug 4172 gets fixed ^_^
13:54:51 <Phyx-> Igloo seems to be working on that, last checked
13:55:48 <dancor> what are the current back-ends of GHC?
13:55:59 <NaCl> hmmph... to install locally or not...
13:56:03 <NaCl> eh, can't hurt
13:56:09 <dons> dancor: C, native code, LLVM.
13:56:16 <dons> and bytecode
13:56:26 <roconnor> bytecode?
13:56:35 <NaCl> roconnor: think java
13:56:38 <NaCl> or python
13:56:46 <roconnor> ya, but which bytecode?
13:57:20 <roconnor> ghc bytecode! but no interpreter hasn't been written yet?
13:57:54 <Cale> roconnor: ghci
13:57:58 <roconnor> :O
13:59:33 <Cale> Heh, did you mean that every possible interpreter has been written?
14:01:23 <Phyx-> > length me
14:01:24 <lambdabot>   Not in scope: `me'
14:02:08 <Phyx-> > me
14:02:09 <lambdabot>   Not in scope: `me'
14:02:20 * NaCl thinks cabal needs more progress bars
14:02:24 <Phyx-> lol, someone @undef'd
14:09:59 <Gracenotes> @vixen meow
14:10:00 <lambdabot> *giggles*
14:16:10 <JoeyA> Functional programming question in general, but I wonder if there are any languages that use multiple applicative style like this:
14:16:16 <JoeyA> map (3 + ?) [1,2,3]
14:16:35 <Zao> > map (3+) [1,2,3]
14:16:36 <lambdabot>   [4,5,6]
14:16:46 <JoeyA> Right, that's the same idiom in single-applicative style.
14:16:56 <JoeyA> But consider a function with five arguments
14:17:17 <JoeyA> map (foo (1,2,_,_,5)) [1,2,3]
14:17:19 <Zao> Is that ? supposed to be a ? or is it unicode failure?
14:17:22 <Makoryu> JoeyA: Clojure. (map #(+ 3 %) [1 2 3])
14:17:28 <JoeyA> s/_/?/g
14:17:29 <Zao> JoeyA: Which would do what?
14:17:40 <JoeyA> Yes, a question mark
14:17:44 * NaCl wonders what gtk2hsC2hs is
14:18:03 <JoeyA> map (foo (1,2,_,_,5)) [1,2,3] would be the same as map (\x y -> foo (1,2,x,y,5)) [1,2,3]
14:18:12 <JoeyA> err, not sure that made sense
14:18:24 <NaCl> it seems that haskell-ext-src doesn't depend on happpy
14:18:26 <NaCl> *happy
14:18:36 <JoeyA> zipWith (\x y -> foo (1,2,?,?,5)) [1,2,3] [4,5,6]
14:18:42 <NaCl> bah
14:18:47 <JoeyA> ugh, replace the ?s with x and y
14:18:49 <JoeyA> I mixed styles
14:18:56 <NaCl> it seems that haskell-ext-src doesn't think it depends on happy but does
14:19:47 <JoeyA> Makoryu: so in (map #(+ 3 %) [1 2 3]) (Clojure), is the # operator for binding with %s ?
14:20:00 <Paczesiowa> what does this mean (ghc-core): case something of _ {something else} ? what's the difference between '_' and wild2_X23? 
14:24:11 <NaCl> seems that the gtk2hs people haven't documented how to install gtk2hs all that well...
14:24:13 <kmc> i have a module Foo which defines a type Foo, and another module ManagedFoo which defines a type Foo.  ManagedFoo.Foo contains a Foo.Foo, and also some cached information about it, and ManagedFoo exports a similar api to Foo
14:24:18 <kmc> does this seem like a reasonable design?
14:24:56 <Paczesiowa> NaCl: you need that gtk-buildtools package, or something like that
14:24:57 <Makoryu> JoeyA: #() is a reader macro, I think
14:25:01 <kmc> the intent is to separate the concern of manipulating this underlying structure from the concern of having fast lookups about it
14:25:05 <NaCl> Paczesiowa: yes.
14:25:13 <kmc> but it seems perhaps excessive
14:25:27 <NaCl> Paczesiowa: and that also has a dependency that cabal doesn't auto-get
14:25:28 <Makoryu> JoeyA: It expands to (fn [%] (foo %))
14:25:48 <Paczesiowa> NaCl: probably something native
14:26:10 <NaCl> If I tell cabal to get the program (alex), it does
14:26:12 <Makoryu> JoeyA: I think you can also write %1 %2 etc. for multiple arguments
14:26:50 <JoeyA> Thanks.
14:27:10 <NaCl> And then everything else goes smoothly
14:27:15 <tnks> okay, someone tweeted something that got me digging: *Any* program can be rewritten with a cyclomatic complexity of 1. (trivially proven by Church-Turing equiv)
14:27:42 <tnks> I think he's talking about using Church booleans for encoding.
14:29:36 <kmc> is the "church-turing equivalence" something different from the church-turing thesis?
14:30:06 <ezyang> I've always thought it was. 
14:30:33 <kmc> what is it then?
14:30:47 <ezyang> Church-turing thesis = Lambda calculus, Turing machines and recursion are church-turing equivalent. 
14:31:04 <ezyang> Oh, I missed the negation on your statement :-) 
14:32:04 * hackagebot binary-protocol-zmq 0.1 - Monad to ease implementing a binary network protocol over ZeroMQ  http://hackage.haskell.org/package/binary-protocol-zmq-0.1 (NicolasTrangez)
14:32:40 <kmc> the church-turing thesis is not about the equivalence of the three formal systems you named
14:32:44 <kmc> that's a theorem, you can prove it
14:33:07 <ezyang> oh, that's true. 
14:33:09 <kmc> the church-turing thesis relates all of those models to a vaguer idea of "computations actually possible in our universe"
14:33:25 <ezyang> Right, so it means "any possible method of computation" you could come up with. 
14:33:53 <kmc> it's a philosophical statement, or maybe a physical law
14:33:55 <tnks> yeah, I'm looking this stuff up for the first time now.
14:34:10 <tnks> and I always have to regard Wikipedia entries with a grain of salt.
14:34:32 <kmc> can't be proven, hard to disprove too (how can you convince yourself something is *really* a hypercomputer, especially if you're not?)
14:34:48 <tnks> I hadn't thought about the cyclomatic complexity of a raw lambda calculus, but I guess it is 1.
14:35:05 * hackagebot bird 0.0.13 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.13 (MattParker)
14:35:41 <kmc> a sufficiently fast turing machine could simulate your brain over and over until it knows exactly what to say to convince you it's a hypercomputer
14:35:58 <tnks> but taking all primitives down to functional equivalents is pretty damn extreme.
14:36:01 <kmc> so it would be hard to trust any empirical evidence against C-T
14:36:16 <ezyang> kmc: Hahaha 
14:36:52 <kmc> for a similar reason it's hard to trust empirical evidence for an omnipotent god: it's infinitely more plausible that finitely-powerful aliens are just fucking with you
14:37:39 <EvanR> paranoid!
14:38:36 <ezyang> It depends on your priors, IMO. 
14:38:48 <NaCl> gah yi's default colors in the term suck
14:38:50 <kmc> yeah, it's paranoia in the finite case, but socially accepted, even encouraged in the case of infinite beings
14:39:14 <kmc> anyway perhaps i'm done with OT here
14:45:48 <Wolfspaw> cabal question: If theres more than one lib dir i want to pass, how do i separe them? example: cabal install Yi --extra-lib-dirs=C:/cygwin/lib --extra-lib-dirs=C:/gtk (this does not work, how i pass them both?)
14:50:01 <anair_84> does haskell something like an eval statement
14:50:07 <anair_84> i am new to haskell
14:50:36 <kmc> anair_84, you want to take a String and evaluate it as Haskell code?
14:50:43 <anair_84> yes
14:50:54 <EvanR> you probably dont
14:50:55 <EvanR> ;)
14:50:56 <kmc> you can do that with http://hackage.haskell.org/package/hint
14:51:06 <aristid> anair_84: the short answer is no (you don't want to do it)
14:51:08 <kmc> but it's usually not the right way to do something
14:51:28 <kmc> what are you trying to do?
14:51:31 <anair_84> supposing i want to send code to remote server to execute
14:51:36 <anair_84> like some batch job
14:51:42 <Makoryu> anair_84: Oh boy
14:51:45 <Makoryu> This sounds fun
14:51:48 <kmc> there's also hint-server, which is what it sounds like
14:51:59 <anair_84> ah
14:52:12 <EvanR> then send it to the server, where a shell script runghc's it
14:52:15 <kmc> the yhc compiler has some ability to send function values in running programs over the network
14:52:19 <EvanR> and watch out for security
14:52:21 <EvanR> lol
14:52:34 <anair_84> haha k
14:52:35 <kmc> but yeah, i think there is probably a better way
14:52:43 <kmc> why do you want to send code to a remote server to execute?
14:53:00 <anair_84> just for compute intensive tasks
14:54:06 <anair_84> like finding biggest prime or something being able to easily run it remotely and get back some result
14:54:21 <EvanR> finding the biggest prime will take a while
14:54:26 <kmc> haha
14:54:33 <kmc> anair_84, perhaps this will be useful: http://hackage.haskell.org/package/net-concurrent
14:55:02 <anair_84> net-concurrent wow
14:55:03 <wli> I don't believe the asymptotically fastest primality testing algorithm is actually faster in space-feasible regimes.
14:55:25 <kmc> there's also Thrift, an RPC-binding generator which supports many languages, including Haskell
14:55:39 <kmc> so you can call Haskell functions from code on another machine, in any language
14:55:39 <wli> e.g. Fermat primes get too big too fast to work with and the primality test still isn't fast enough.
14:55:40 <kmc> and vice versa
14:56:03 <EvanR> @hoogle fix
14:56:03 <lambdabot> Data.Function fix :: (a -> a) -> a
14:56:03 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
14:56:03 <lambdabot> module Control.Monad.Fix
14:56:24 <EvanR> why is fix in monad module?
14:56:37 <hpc> @hoogle fixM
14:56:37 <lambdabot> No results found
14:56:41 <anair_84> wli not really prime testing :) was giving and eg what are did ucla use to win the eff prize
14:57:06 <kmc> @hoogle mfix
14:57:07 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
14:57:27 <hpc> > mfix return
14:57:28 <lambdabot>   No instance for (GHC.Show.Show (m a))
14:57:28 <lambdabot>    arising from a use of `M6152586238...
14:57:49 <hpc> > mfix (:[1])
14:57:52 <lambdabot>   mueval-core: Time limit exceeded
14:59:43 <monochrom> http://www.vex.net/~trebla/haskell/learn-sources.xhtml
15:01:13 <ksf> is there a standard stm lifo implementation?
15:01:58 <monochrom> yes and no. TVar [a] is almost there, just missing a few one-liner functions.
15:02:30 <ksf> erm yes.
15:02:38 <ksf> TChans _are_ basically TVar [a]
15:03:13 <monochrom> no, TChan is fifo, and more complex
15:03:15 <wli> I thought Chans were supposed to be more like queues than stacks.
15:03:17 <ksf> otoh, I think a lifo would be an insufficient hack, what I want is a priority queue.
15:03:53 <monochrom> each TChan is a TVar of more TChan
15:03:59 <ksf> ...popMax and each duplicate request increases its priority
15:13:03 <EvanR> how do i catch ioErrors again ?
15:13:14 <kmc> Control.Exception
15:13:51 <EvanR> and these conflict with Prelude right
15:13:55 <kmc> yeah
15:13:59 <EvanR> cool
15:13:59 <kmc> but if you only wanna catch IOError
15:14:02 <kmc> then the prelude stuff works
15:14:09 <kmc> i remember a talk where they benchmarked numerous concurrent stack implementations
15:14:21 <kmc> and the lowly (IORef [a]) with atomicModifyIORef did better than everything else
15:14:35 <ezyang> kmc: Well, it depends on contention. 
15:14:47 <ezyang> IORef will be very fast in low contention cases. 
15:15:10 <EvanR> yes these bindings IO actions might throw using ioError
15:15:29 <EvanR> so ill use Prelude catch
15:18:11 <kmc> ezyang, what happens under contention?
15:18:56 <EvanR> ah. what i was gonna do was print out the internal error message and fail
15:19:09 <EvanR> i suppose thats equivalent to not doing anything
15:19:26 <EvanR> because it will show the exception anyway
15:19:38 <ksf> erm no. a psqueue would be too smart.
15:23:10 <nooodl> wasn't there some function that did "blah 4 [1,2,6] ==> [1,1,1,1,2,2,2,2,6,6,6,6]"
15:23:20 <nooodl> either i can't find it or i'm imagining it and should go write it
15:23:36 <EvanR> @hoogle Int -> [a] -> [a]
15:23:37 <lambdabot> Prelude drop :: Int -> [a] -> [a]
15:23:37 <lambdabot> Prelude take :: Int -> [a] -> [a]
15:23:37 <lambdabot> Data.List drop :: Int -> [a] -> [a]
15:23:45 <copumpkin> > [1,2,3] >>= replicate 4
15:23:45 <Makoryu> :t replicate
15:23:46 <lambdabot>   [1,1,1,1,2,2,2,2,3,3,3,3]
15:23:46 <lambdabot> forall a. Int -> a -> [a]
15:24:25 <nooodl> >>=? hmm
15:24:29 <lispy> :t replicateM
15:24:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:24:34 <nooodl> that looks like an interesting operator
15:24:47 <lispy> > replicateM 4 [1,2,3]
15:24:48 <lambdabot>   [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,1],[1,1,2,2],[1,1,2,3],[1,1,3,1],[1,1...
15:25:50 <nooodl> what's it called?
15:25:55 <copumpkin> bind
15:26:01 <Makoryu> :t (>>=)
15:26:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:26:32 <lucca> well
15:26:47 <lucca> it's maybe clearer to say >>= on list is concatMap
15:26:52 <Makoryu> Yeah
15:26:52 <dibblego> is there an extension that lets me use the same type variable twice in a type declaration?
15:26:59 <Makoryu> :t concatMap -- nooodl
15:27:00 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:27:26 <kmc> dibblego, «type Foo a = (a,a)» works for me, no extension
15:27:45 <nooodl> > concatMap (replicate 4) [1,2,3]
15:27:46 <lambdabot>   [1,1,1,1,2,2,2,2,3,3,3,3]
15:27:57 <nooodl> looks more clear to me, at least :)
15:28:06 <dibblego> kmc, sorry, I mean e.g. instance Foo (T (U e) e)
15:28:13 <kmc> ah
15:28:18 <kmc> try -XFlexibleInstances
15:28:28 <Makoryu> nooodl: Yep
15:28:32 <dibblego> ok cheers
15:28:56 <Wolfspaw> What is the name of the list that take a list, and return the same list without repated elements?
15:28:57 <kmc> nooodl, (>>=) is the most important part of the Monad typeclass.  each monad implements (>>=) differently; for lists, (>>=) = flip concatMap
15:29:01 <Wolfspaw> *Function
15:29:02 <kmc> :t nub
15:29:03 <lambdabot> forall a. (Eq a) => [a] -> [a]
15:29:07 <kmc> nub "abcddeffg"
15:29:09 <kmc> > nub "abcddeffg"
15:29:10 <lambdabot>   "abcdefg"
15:29:11 <kmc> > nub "abcddeffga"
15:29:13 <lambdabot>   "abcdefg"
15:29:15 <Wolfspaw> ok, thanks again kmc xD
15:29:22 <kmc> looks inefficient though, it will traverse the list many times
15:29:22 <dibblego> kmc, I just found an example of that in MonadWriter and the source file has allow-undecidable-instances
15:29:35 <kmc> because it doesn't only remove consecutive repeats
15:29:53 <kmc> :t S.toList. S.fromList -- if you have Ord, this could be faster
15:29:55 <lambdabot> forall a. (Ord a) => [a] -> [a]
15:30:02 <nooodl> all i know about monads is people say they're weird :)
15:30:12 <kmc> or even nub . sort
15:30:16 <nooodl> i should read up on them
15:30:16 <Saizan>  S.toList. S.fromList is stricter though
15:30:38 <kmc> nooodl, monads are kind of over-hyped imo.  they're useful but it's not the central defining concept of Haskell
15:30:56 <kmc> each individual monad is useful on its own, without knowing what the word "monad" means
15:31:04 <kmc> IO is useful, Maybe is useful, lists are useful
15:31:06 <nooodl> what are they used for? all sorts of things?
15:31:10 <kmc> this much is reasonably straightforward and concrete
15:31:15 <Wolfspaw> kmc: hm, a list of list of strings ( [ [String] ] ) is an instance of Ord by default right?
15:31:15 <Saizan> kmc: "map head . group . sort" you mean? "nub . sort" would still be O(n^2) as nub won't exploit the sortedness
15:31:22 <kmc> hmm yeah Saizan 
15:31:30 <kmc> Wolfspaw, yeah
15:32:08 <EvanR> is it typical to use opengl via the sdl bindings?
15:32:09 <kmc> nooodl, so the point of having a thing called "monad" is to recognize that IO, nondeterminism, exceptions, transactional concurrency, parsers, code generators, etc. all have some structure in common
15:32:12 <EvanR> to get input?
15:32:25 <kmc> and then we can write functions which work generically, i.e. the stuff in Control.Monad
15:32:35 <kmc> and invent convenient syntax common to all of them, i.e. "do"
15:32:56 <kmc> but the question of what the abstraction "monad" identifies is perhaps not relevant if you're sticking to a single concrete example
15:33:14 <kmc> EvanR, yes
15:33:27 <kmc> SDL is kind of crap for drawing but it's a reasonable way to get an OpenGL window and some input
15:34:34 <EvanR> ok
15:35:09 <ksf> hmmm it appears I'm still using instance MonadFix STM where mfix = unsafeCoerce fixIO, it's still working, I'm still fundamentally depending on it and I don't have any idea how to do it safely.
15:35:18 <kmc> omg
15:35:28 <kmc> madness
15:36:10 <ksf> well implementing mfix with TVars won't work because of retrying etc.
15:36:16 <ksf> it has to be IOVars.
15:36:22 <kmc> hmm yeah
15:36:33 * kmc looks at how fixIO is implemented
15:37:12 <nooodl> i just solved a difficult project euler problem with an elegant one-liner, i think haskell is now my favourite programming language
15:37:33 <kmc> nooodl, :D
15:37:39 <Makoryu> nooodl: >:)
15:38:06 <ezyang> Anyone know of a small (on the order of one page) program that uses every type extension GHC has to offer in a motivated fashion? 
15:38:16 <ezyang> (if not, I want to write this program :-) 
15:38:34 <Makoryu> ezyang: Why would you go that :\
15:38:36 <Makoryu> *do
15:39:06 <ksf> I think i'd rather go with a page for each extension
15:39:16 <ezyang> Makoryu: I think it would be a kind of cool experiment. 
15:39:19 <danderson> @hoogle a -> [a] -> [[a]]
15:39:20 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:39:20 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
15:39:20 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
15:39:41 <danderson> damnit, not [a], [[a]]!
15:40:39 <danderson> so, what's the opposite of intersperse?
15:41:06 <EvanR> heh
15:41:12 <ezyang> danderson: Check out the split library. 
15:41:16 <Makoryu> danderson: Like a generalization of words and lines?
15:41:33 <danderson> ezyang: thanks.
15:41:44 <EvanR> i just tried to make a record with field foo :: a -> b by saying Rec { field x = a b x c }
15:41:50 <danderson> Makoryu: something like that. But I'm all set now, cheers.
15:42:09 <EvanR> err
15:42:13 <EvanR> foo x = a b x c
15:42:31 <Makoryu> EvanR: That would be a neat extension
15:42:47 <EvanR> ask santa
15:43:07 <EvanR> so i did foo = \x -> a b x c
15:44:02 <magicman> ... *d'oh*
15:44:18 <magicman> I've stumped my head against that way too often, and not thought of that quite simple solution XD
15:44:23 <magicman> Thanks.
15:44:36 <EvanR> lol
15:45:54 <aristid> :t group
15:45:55 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
15:48:40 <kwikshot> hey
15:48:56 <danderson> @hoogle [a] -> (a,a,a,a,a,a)
15:48:57 <lambdabot> No results found
15:49:03 <danderson> worth a try I suppose...
15:50:23 <wioux> don't think that's realizable
15:55:49 <EvanR> this is fairly awesome
15:56:02 <aristid> :t \a -> groupBy ((==) `on` (== a))
15:56:03 <lambdabot> forall a. (Eq a) => a -> [a] -> [[a]]
15:56:38 <aristid> i don't know if there's a better solution for this
15:56:50 <kmc> Haskell is king of refactoring
15:56:54 <aristid> but the type seems to be what danderson wanted
15:57:06 <kmc> i wrote a bigish program, thought parts of it were unnecessarily painful
15:57:12 <kmc> but now i am making big structural changes
15:57:19 <kmc> and the type checker catches my mistakes every time
15:58:43 <aristid> @djinn a -> [a] -> [[a]]
15:58:43 <EvanR> kmc: unless you have two parameters of the same type and you mix them ;)
15:58:43 <lambdabot> Error: Undefined type []
15:58:55 <EvanR> i have avoided that mistake by not having two parameters of the same time
15:59:03 <EvanR> for some reasons its easy
16:00:16 <wioux> kmc: another goodie in Haskell - if your code passes type checks, theres a very good chance its correct
16:00:44 <ezyang> After having worked all summer on Haskell, I would say 
16:00:46 <msieradzki> which doesn't mean that you spend less time correcting errors
16:00:46 <EvanR> unless you are using unsafe functions like head
16:00:54 <ezyang> there is a near 100% chance you didn't do anything stupid 
16:01:07 <ezyang> but you're still probably going to have subtle bugs if you're not thinking carefully. 
16:01:42 <kmc> yes
16:02:17 <kmc> part of the reason Haskell feels hard is that you spend all your debugging time on tricky logic bugs and not dumb typos
16:02:23 <EvanR> it might be that since you *have* to pay attention and think before you code, that makes haskell 'artitifically' easier to write correct programs in
16:02:53 <kmc> yeah
16:03:02 <ezyang> This also makes mindless refactoring easy, except when you're subtly changing the structure of code and manage to not do it correctly. 
16:03:07 <kmc> i think it is hard to write correct programs in any language
16:03:32 <EvanR> except untyped lambda calculus
16:03:39 <kmc> :D
16:03:41 <EvanR> everything right
16:03:42 <roconnor> writing incorrect programs in Haskell is hard
16:03:42 <EvanR> is
16:03:53 <monochrom> just a bit hard
16:03:54 <roconnor> but writing correct programs is hard in every langauge
16:04:03 <kmc> yeah
16:04:06 <roconnor> therefore
16:04:09 <roconnor> writing code in Haskell is hard
16:04:13 <EvanR> everything is hard in haskell ;)
16:04:14 <EvanR> lol
16:04:25 <kmc> that's a pretty good summary
16:04:36 <EvanR> hardCORE, that is
16:05:07 <kmc> a lot of the world is not interested in writing correct programs
16:05:14 <copumpkin> sadly
16:05:28 <msieradzki> correct enough is enough :)
16:05:34 <copumpkin> but types can help with speed too
16:05:48 <monochrom> yes, some languages like haskell force you to design more before coding, so it is the same amount of work just shifted differently
16:06:05 <ezyang> Nah, I'd say langauges like Java force you to design before coding 
16:06:14 <ezyang> just cuz you have to write SO MUCH code. 
16:06:21 <msieradzki> :)
16:07:10 <EvanR> the more you have to type the more work gets done
16:07:32 <monochrom> however, psychologically it is different. people are emotionally attached to code already written. delaying coding implies errors are fixed in cleaner ways.
16:08:15 <EvanR> 'dont write the code' i saw that in art of unix, the code thats not there cant be wrong or slow
16:08:23 <kmc> yeah
16:08:31 <kmc> UNIX is like that :)
16:08:36 <EvanR> lol
16:08:44 <kmc> it is funny that UNIX and X got stuck together, since X is the opposite way
16:09:13 <EvanR> i wish we did things that way at work
16:09:15 <lispy> hmm...I setup a mailman instance on projects.haskell.org, subscribed to it, but when I send messages they don't show up in the archive or the moderation queue.
16:09:19 <ksf> @remember <roconnor> writing incorrect programs in Haskell is hard. but writing correct programs is hard in every langauge. therefore, writing code in Haskell is hard. <EvanR> everything is hard in haskell ;) <kmc> that's a pretty good summary
16:09:20 <lambdabot> Nice!
16:09:32 <EvanR> after enough planning the manager gets ansi (sp?) and wants to start typing random code
16:09:38 <wli> Multics is a very interesting contrast.
16:09:39 <mauke> @quote <roconnor>
16:09:40 <lambdabot> <roconnor> says: I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
16:09:46 <chrisf> kmc: as opposed to all the bits of UNIX that *are* there, which tend to be at least *wrong*, and often *slow* too.
16:09:49 <chrisf> :P
16:09:51 <kmc> haha
16:10:18 <tommd> j/msg lambdabot @quote TomMD
16:10:19 <ksf> @quote EvanR
16:10:20 <lambdabot> <roconnor> says: writing incorrect programs in Haskell is hard. but writing correct programs is hard in every langauge. therefore, writing code in Haskell is hard. <EvanR> everything is hard in
16:10:20 <lambdabot> haskell ;) <kmc> that's a pretty good summary
16:10:25 <ksf> @quote EvanR
16:10:25 <lambdabot> <roconnor> says: writing incorrect programs in Haskell is hard. but writing correct programs is hard in every langauge. therefore, writing code in Haskell is hard. <EvanR> everything is hard in
16:10:25 <lambdabot> haskell ;) <kmc> that's a pretty good summary
16:10:28 <ksf> huh.
16:10:33 <ksf> @quote kmc
16:10:33 <lambdabot> kmc says: Haskell would be much more popular if it were marketed as a pragmatic alternative to Haskell
16:10:43 <tommd> oops, at any rate, it actually remembers a quote.
16:10:45 <lispy> heh
16:10:55 <lispy> ?quote TomMD
16:10:55 <lambdabot> TomMD says: Never trust IO
16:11:02 <lispy> ?quote TomMD
16:11:02 <lambdabot> TomMD says: Never trust IO
16:11:08 <tommd> @quote TomMD
16:11:09 <lambdabot> TomMD says: Never trust IO
16:11:13 <ksf> ...and that from someone who is worried by mfix = unsafeCoerce fixIO
16:11:17 <tommd> @quote ARM
16:11:17 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
16:11:17 <lispy> never say never!
16:11:20 <tommd> @quote ARM
16:11:20 <lambdabot> dons says: so we just win people over with charm and lambdas, given time
16:11:29 <tommd> grrrr, can quote do regex?
16:11:35 <mauke> yes
16:11:43 <tommd> @quote / ARM/
16:11:43 <lambdabot> No quotes for this person. There are some things that I just don't know.
16:11:48 <tommd> @quote " ARM/"
16:11:48 <lambdabot> No quotes for this person. Are you on drugs?
16:11:50 <mauke> you fail
16:11:51 <lispy> Not regex, but simple searches
16:11:53 <tommd> yes
16:12:00 <lispy> ?quote .ARM
16:12:01 <lambdabot> lennart says: I would rather lose my left arm than write it in Java
16:12:10 <tommd> @quote \WARM
16:12:10 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
16:12:11 <lispy> something like that anyway
16:12:16 <tommd> ah
16:13:06 <mauke> preflex: quote
16:13:12 <preflex>  <mrd> deforestation is killing millions of endangered cons cells
16:13:27 <kmc> hahaha
16:14:06 <lispy> anyone know why the mailman instance I setup via community.haskell.org is not accepting mail?
16:14:12 <lispy> Or how we can trouble shoot it?
16:14:15 <redocdam> That's actually not so funny, what's funny is people actually using C++ for serious software.
16:14:25 <redocdam> like the llvm
16:14:54 <lispy> > reverse "redocdam"
16:14:55 <lambdabot>   "madcoder"
16:16:30 <vanadium> I am still amazed that people can wrap their minds around serious software engineered in haskell
16:17:13 <redocdam> stop trolling
16:17:21 <EvanR> lispy: thats like pulling his pants down, geez!
16:17:24 <kmc> er
16:17:40 <redocdam> C++ is the disease and Haskell is the cure
16:17:55 <vanadium> I suspect it might in fact be you who is trolling
16:18:19 <lispy> redocdam: Well, now hang on a second.  The evidence shows that there are quite a few large C++ code bases out there, for large managed projects.  How many similar datapoints do we have for Haskell?
16:19:01 <lispy> redocdam: Based on that evidence, I think it's reasonable to ask "how do you do serious software engineering in haskell?"
16:19:07 <redocdam> There's a lot of crap out there yeah
16:19:20 <lispy> I don't think we have enough data points to say for sure
16:19:23 <redocdam> We can't use crap in comparisons
16:19:24 <kmc> i don't think expressing amazement at stuff that's written in Haskell is trollish
16:19:29 <kmc> it's pretty common here
16:19:30 <msieradzki> how many in erlang, ocaml, common lisp, scheme?
16:19:44 <kmc> lots of big important apps in Erlang
16:19:56 <msieradzki> ok quite a few
16:20:01 <kmc> OCaml might be tied with Haskell by now
16:20:03 <lispy> is there an IRC channel for community.haskell.org?
16:20:07 <msieradzki> I don't remember many more than those in Haskell though
16:20:28 <kmc> anyway i don't see the point of this category
16:20:32 <kmc> which seems to be "functional languages"
16:20:42 <kmc> Scheme and Lisp are closer to Python and Javascript than they are to Haskell or OCaml
16:21:03 <redocdam> There are typed lisps I believe
16:21:18 <msieradzki> Common Lisp has types I read
16:21:20 <EvanR> lazy pure lisp?
16:21:21 <Makoryu> kmc: And these days, lispers will immediately jump up to say, "Scheme and CL are not functional!" if you call them functional languages
16:21:31 <Makoryu> msieradzki: CL has optional typing with no enforcement
16:21:38 <lispy> Igloo: do you know how I can get help with a mailman instance I created on c.h.o using the scripts?  It doesn't appear to be rejecting mail, holding it in the moderation queue, or accepting it.  I'm baffled.
16:21:42 <msieradzki> can have types
16:21:43 <kmc> almost every language has types, does it have *static* typing?
16:21:51 <kmc> it's not the default anyway
16:22:00 <msieradzki> well CL is huge
16:22:05 <aristid> Makoryu: is "functional" something they want to distance themselves from?
16:22:06 <msieradzki> C++ std doc is like 700 pagees
16:22:08 <msieradzki> C# 400
16:22:15 <Makoryu> aristid: Apparently so ¯\O_o/¯
16:22:16 <msieradzki> CL 1000-1500 last time I checked
16:22:26 <aristid> Makoryu: oO what was that smiley?
16:22:30 <aristid> it looks like a vampire
16:22:45 <redocdam> Who cares about lisp anyways; it's dead and has been for ages. It has unfortunately taken C++'s rightful place in history.
16:22:55 <kmc> it's dead like Latin is dea
16:23:10 <kmc> which is to say, not used much for 'real work', but still influential and used in academic discourse
16:23:12 <redocdam> Funny how nothing seems to go right whenever people are in charge
16:23:20 <redocdam> That is other people than me
16:23:59 <vanadium> Man, I am not sure you are doing this right.
16:24:02 <Makoryu> aristid: It's someone shrugging
16:24:13 <Makoryu> redocdam: The original LISP is dead, yes
16:24:19 <aristid> Makoryu: a shrugging vampire :D
16:24:25 <Makoryu> aristid: Sure :p
16:24:38 <redocdam> What lisps are not dead besides clojure?
16:24:54 <redocdam> SBCL has been extremely dead for a long time now
16:24:56 <Makoryu> redocdam: Uh, Common Lisp is pretty healthy, dispite being.
16:24:59 <Makoryu> What?
16:25:03 <Makoryu> How is SBCL dead?
16:25:08 <Makoryu> It's under active development
16:25:12 <msieradzki> lisps aren't much more dead than other functional languages at least from far away
16:25:20 <redocdam> Nobody really uses it
16:25:48 <redocdam> People just want to get good concurrency in it for kicks so that they can bury something they can be proud of
16:25:58 <Makoryu> redocdam: It's not terribly popular, but that's quite different from being dead
16:26:10 <redocdam> Well almost dead then
16:26:14 <kmc> Haskell is not very popular, but trending upwards
16:26:23 <kmc> as are Clojure, Scala, and F#
16:26:27 <kmc> OCaml seems to have stalled out a bit
16:26:31 <Makoryu> SO HASKELL IS DEAD?!?! *GASP*
16:26:43 <redocdam> Haskell is extremely popular dons talks about it all the time
16:26:50 <kmc> BSD is dying, Netcraft confirms it
16:26:56 <Makoryu> redocdam: You're a fascinating troll
16:27:16 <kmc> let's not accuse everyone of being a troll
16:27:24 <ksf> I've got an atomically that sets a tvar to "processing", then a ffi call, then another atomically setting the same tvar to "done, <value>".
16:28:01 <ksf> the strange thing is, if there's only a short ffi call between both atomicallies, the second one might not execute.
16:28:10 <redocdam> I don't see dons talking about SBCL or any lisp 
16:28:12 <ksf> well, at least the result stays at "processing"
16:28:20 <kmc> haha redocdam
16:28:22 <redocdam> ergo they are dead or almost dead
16:28:25 <aristid> kmc: why is it a taboo here to say that people are trolls?
16:28:32 <kmc> he doesn't talk about Java either
16:28:51 <kmc> aristid, because it's one of the ways internet communities go to shit
16:29:06 <kmc> a core of bitter holdouts who accuse everyone with a different view of being a troll
16:29:13 <ksf> the proper way to deal with trolls is to feed them until they explode
16:29:33 <aristid> redocdam: c++ is the coolest language in the world
16:29:39 <kmc> i think there is value to being provocative
16:29:41 <kmc> to a point
16:29:48 <kmc> if it stimulates interesting discussion
16:30:03 <ksf> aristid, please keep the obsceneties down.
16:30:08 <kmc> @karma c
16:30:09 <lambdabot> c has a karma of 2
16:30:36 <aristid> ksf: what, saying that something is cool is an obscenity?
16:30:49 <ksf> in the case of c++, certainly.
16:30:59 <kmc> let's all argue about C++ endlessly again
16:31:13 <kmc> in another channel
16:31:15 <kmc> where i am not
16:31:37 <ksf> I'd rather know how my STM actions are ending up having no effect on TVars.
16:31:47 <kmc> indeed, that's a puzzle
16:31:57 <kmc> ksf, maybe event logging or one of the debug RTS options is helpful?
16:32:10 <aristid> and i'd rather know how to improve the expression \a -> groupBy ((==) `on` (== a))
16:32:18 <kmc> you can also run your code in gdb and set breakpoints inside the RTS
16:32:37 <kmc> @pl  \a -> groupBy ((==) `on` (== a))
16:32:38 <lambdabot> groupBy . ((==) `on`) . (==)
16:32:42 <kmc> there isn't that an improvement ;)
16:33:39 <lispy> totally readable no
16:33:43 <lispy> now*
16:33:45 <aristid> no :(
16:34:16 <ksf> putStr "" isn't enough to make it disappear, putStrLn "" is.
16:34:32 <kmc> is it deterministic?
16:34:56 <ksf> aaaahh.
16:34:59 <ksf> now I'm getting closer.
16:35:24 <ksf> putStr "." doesn't make it dissapear, and, what's even more interesting, the number of dots doesn't coincedence with the number of elements I process.
16:35:41 <ksf> hmmm fixIO?
16:36:10 <aristid> ksf: putStr might buffer
16:36:23 <aristid> ksf: putStrLn always flushes AFAIK
16:36:27 <ksf> yes it does
16:36:40 <ksf> ...but the rts flushes on program end
16:37:08 <aristid> interesting
16:42:06 <ksf> it's _not_ the mfix instance.
16:43:27 <dibblego> what's the typical function to go from (Either a b) to (EitherT a m b) ?
16:44:47 <Heffalump> @type Control.Monad.Either.EitherT . return
16:44:48 <lambdabot> Couldn't find qualified module.
16:45:08 <Saizan> ?type either throwError return
16:45:09 <lambdabot> forall a (m :: * -> *) a1. (MonadError a m) => Either a a1 -> m a1
16:45:27 <aristid> :t EitherT
16:45:28 <lambdabot> Not in scope: data constructor `EitherT'
16:45:34 <Saizan> it's ErrorT btw
16:45:43 <Heffalump> there's an EitherT in category-extras
16:45:56 <dibblego> so Control.Monad.lift doesn't help with that right?
16:45:57 <Saizan> ah, makes sense
16:46:04 <Saizan> no
16:46:14 <Heffalump> dibblego: correct. That's to go from m b -> EitherT a m b
16:46:28 <dibblego> right just checking my brain is in order, thanks
16:46:40 <dibblego> *Control.Monad.Trans.lift
16:46:51 <Heffalump> I don't know how you'd do it without breaking into the EitherT abstraction, if it is hidden.
16:46:54 <lispy> Control.Monad.Trans.Atlantic.lift
16:47:13 <lispy> hey, Heffalump.  How's rebase going?
16:47:23 <aristid> zygohistomorphic prepromorphism
16:47:27 <aristid> just had to say that
16:47:44 <Heffalump> lispy: I got distracted by other things, which was stupid.
16:47:58 <Heffalump> I shall try to become undistracted.
16:48:31 <lispy> heh
16:48:50 <Wolfspaw> lol xD
16:49:33 <redocdam> Heffalump: where are the woozles?
16:49:52 <Heffalump> hiding
16:51:19 <ksf> gnnnnaaaargh
16:51:24 <ksf> of course it's not an rts bug.
16:51:29 <lispy> Heffalump: do you like the idea of switching over our IO primitives to be instances of MonadIO?
16:51:37 <ksf> its gtk's postGUIAsync which fails.
16:54:55 <EvanR> why is it that no matter how clever you are, you always see ways to making it better? does haskell have unlimited potentialy for code goodness?
16:55:26 <EvanR> you can reduce code duplication to ridiculous proportions
16:55:29 <mauke> that sounds more like unlimited badness
16:55:43 <mauke> the same argument might apply to php
16:55:46 <EvanR> my code keeps shrinking
16:55:51 <EvanR> hmm
16:56:09 <ksf> yet another reason not to use gtk
16:56:22 <ksf> whether I'm doing it sync, async or unwrapped, it never works.
16:56:51 <kmc> i often reach a point where i can't reduce duplication without using template haskell or some other absurdly powerful unwieldy mechanism
16:57:10 <kmc> haskell is pretty boilerplatey compared to some very dynamic introspective languages
16:57:19 <kmc> i do think it's a good tradeoff though
16:57:34 <EvanR> i dont like when it lets me used strings to decide what to do
16:57:40 <EvanR> seems like too powerful
16:58:02 <ksf> hmmm I don't think wxhaskell would be more threadsafe, it's gtk backed, after all.
16:58:05 <kmc> also for most metrics of "best", the problem of finding the best program for a given task is undecidable and so there's practically unlimited potential for improvement, in any language
16:58:08 <ksf> fltk might be worth a try
16:58:23 <EvanR> i like fltk (2)
16:58:35 <EvanR> though most people immediately dismiss it for being ugly
16:58:37 <kmc> how is postGUIAsync failing?
16:59:06 <ksf> it's being ignored.
16:59:17 <kmc> but why?
16:59:24 <ksf> ...I update a cell of a treeview in it, and it doesn't display.
16:59:49 <ksf> update the same cell too fast?
16:59:57 <ksf> hrm.
17:00:24 <ksf> stuff might end up being out of order, for some reason or the other.
17:00:40 <ksf> anyway, I was waiting for a proper excuse to get rid of gtk
17:00:45 <dibblego> can I flip type constructors around using type aliases so that I can instance them?
17:00:46 <monochrom> haha
17:00:55 <monochrom> ok, if not gtk, what other choice?
17:01:09 <kmc> dibblego, only if you add a newtype wrapper
17:01:25 <dibblego> ok I will accept that now, cheers
17:01:35 <ksf> something threadsafe. something utterly composable (from within haskell, not extendable via c++)...
17:01:44 <ksf> so I guess there's nothing I could use.
17:01:58 <monochrom> there is a language extension to let you instance type aliases
17:02:17 <dibblego> yeah, I tried that, but I can't seem to get it working TypeSynonymInstances
17:02:24 <dibblego> i.e. the instance declaration
17:02:31 <monochrom> I see
17:02:45 <dibblego> (for both my data types, one being the transformer of the other)
17:03:17 <monochrom> I still think gtk2hs thread problems can be fixed.
17:04:20 <kfish> what are the gtk2hs thread problems? are they gtk-related, or from the haskell bindings?
17:04:34 <ksf> I don't know, and I don't want to know.
17:06:14 <stragerLN> Can you not nest 'where's?  (I'm new to Haskell)  http://paste2.org/p/935832
17:06:25 <monochrom> yes I can nest "where"s
17:06:45 <ksf> ...the second one has to be indented more than "iter"
17:06:59 <stragerLN> alright
17:07:11 <ksf> in the same way that the first one has to be indented more than "madler32"
17:07:32 <stragerLN> ah; I thought the first non-whitespace after the where had to line up with the rest of your stuff
17:07:33 <ksf> and please, please don't mix let and where in the same function
17:07:38 <stragerLN> xD
17:07:42 <stragerLN> okay
17:07:52 <monochrom> mix them at will
17:08:30 <kmc> the first non-whitespace after 'where' sets the indentation column for the 'where' block
17:08:55 <kmc> a subsequent line starting on that column gets an implicit ;
17:09:03 <kmc> a line starting before that column closes the block with }
17:09:35 <stragerLN> okay
17:09:51 <stragerLN> Is there a handy guide to learning Haskell whitespace rules?  Hopefully with different styles as examples
17:10:17 <luite> does hint cache haskell source files? I'm building a web-based haskell evaluator, and it seems to behave strangely when I modify loaded haskell source files
17:10:18 <ksf> looking at the available haskell graphics libraries, I should raytrace my ui.
17:10:28 <kmc> hahaha
17:10:40 <kmc> luite, like ghci, it will load a .o file if it exists
17:10:47 <kmc> but only if it's newer than the source i think
17:11:22 <monochrom> haskell layout short story at http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
17:11:25 <kmc> stragerLN, the Report is pretty readable on this topic: http://www.haskell.org/onlinereport/lexemes.html#layout
17:12:19 <stragerLN> heh, thanks both of you
17:12:30 <luite> kmc: there is no .o file, only source files, in this directory
17:18:47 <monochrom> are you testing in ghci? don't trust ghci on this. test with runghc or compile.
17:31:00 <Wolfspaw> why "foldr1 (==) [2,3,4]" does not work?
17:31:24 <mauke> :t foldr
17:31:25 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:31:31 <mauke> :t (==)
17:31:33 <lambdabot> forall a. (Eq a) => a -> a -> Bool
17:31:44 <mauke> Wolfspaw: because 2 is not a Bool
17:32:20 <dolio> @type foldr1 (==)
17:32:21 <lambdabot> [Bool] -> Bool
17:32:38 <Wolfspaw> hm @_@", ok, thanks mauke dolio 
17:33:21 <mauke> > foldr1 f [x,y,z]
17:33:22 <lambdabot>   f x (f y z)
17:33:35 <mauke> that would expand to 2 == (3 == 4)
17:33:48 <mauke> 3 == 4 is False, and 2 == False is a type error
17:34:19 <Wolfspaw> hm, understood!
17:34:25 <Axman6> :t foldl (==)
17:34:26 <lambdabot> Bool -> [Bool] -> Bool
17:35:40 <Wolfspaw> i was trying to see if all the elements of the list are equal, will try another way @_@
17:36:45 <copumpkin> :t not . null . tail . group
17:36:46 <lambdabot> forall a. (Eq a) => [a] -> Bool
17:37:26 <copumpkin> > map (not . null . tail . group) [[1,2,3], [], [1,1,2], [1,1,1,1], [3,3,3,3]]
17:37:27 <lambdabot>   [True,*Exception: Prelude.tail: empty list
17:37:31 <copumpkin> :P
17:37:38 <copumpkin> > map (not . null . drop 1 . group) [[1,2,3], [], [1,1,2], [1,1,1,1], [3,3,3,3]]
17:37:39 <lambdabot>   [True,False,True,False,False]
17:37:43 <mauke> > let allEq (x : xs) = all (x ==) xs; allEq [] = True in allEq [2,3,4]
17:37:45 <lambdabot>   False
17:37:52 <copumpkin> okay, needs some refinement
17:37:57 <copumpkin> > map (null . drop 1 . group) [[1,2,3], [], [1,1,2], [1,1,1,1], [3,3,3,3]]
17:37:58 <lambdabot>   [False,True,False,True,True]
17:38:21 <copumpkin> I think that's basically correct
17:39:08 <Wolfspaw> hehe, kk . It will work xD
17:43:54 <kmc> :t let f [] = True; f (x:xs) = all (==x) xs in f
17:43:55 <lambdabot> forall a. (Eq a) => [a] -> Bool
17:44:34 <copumpkin> mine is bettar
17:44:56 * copumpkin laughs evilly
17:44:59 <mauke> kmc: stop stealing my code
17:45:20 <dolio> > (null . drop 1 . group) [1..]
17:45:21 <lambdabot>   False
17:48:35 <Axman6> > let f xs = null xs || all (== head xs
17:48:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:48:49 <Axman6> > let f xs = null xs || all (== head xs) xs in f [1,1,1,1,2]
17:48:50 <lambdabot>   False
17:48:54 <Axman6> > let f xs = null xs || all (== head xs) xs in f [1,1,1,1]
17:48:55 <lambdabot>   True
17:49:00 <copumpkin> that's cute
17:49:14 <copumpkin> it avoids the head when it's unsafe
17:49:19 <Axman6> yup
17:49:22 <Axman6> laziness++
17:49:29 <Phyx-> what's the easiest way to read from stdIn untill you get a EOF and get the results as [Int]
17:49:29 <digitteknohippie> :)
17:49:43 <Phyx-> is there a magic one liner for that one?
17:49:50 <ezyang> Phyx-: hGetContents? 
17:50:13 <ezyang> Maybe even interact 
17:50:22 <Phyx-> :t interact
17:50:23 <lambdabot> (String -> String) -> IO ()
17:50:25 <copumpkin> fmap (read . lines) getContents 
17:50:32 <copumpkin> cast to the appropriate type
17:50:34 <Phyx-> ty
17:50:45 <dolio> map read . lines
17:51:03 <copumpkin> oh yeah
17:51:04 <Phyx-> hrm
17:51:10 <Phyx-> yeah, just noticed that
17:51:22 <copumpkin> or
17:51:35 <Phyx-> guess my entire main is just
17:51:36 <Phyx->  = do nm <- fmap (map read . lines) getContents
17:51:37 <Phyx->       mapM_ (print.maxMap) nm
17:52:20 <copumpkin> @type runKleisli (Kleisli (const getContents) >>> arr lines >>> arr (map read))
17:52:21 <lambdabot> forall a a1. (Read a1) => a -> IO [a1]
17:52:23 * copumpkin coughs
17:52:47 <copumpkin> @type runKleisli (Kleisli (const getContents) >>> arr lines >>> arr (map read)) undefined
17:52:48 <lambdabot> forall a. (Read a) => IO [a]
17:52:48 <dolio> That's interact (unlines . map (show . maxMap . read) . lines, I think.
17:52:56 <copumpkin> there we go
17:53:11 <Phyx-> o.. m.. g...
17:53:13 <dolio> Except that that's missing a close paren.
17:53:14 <Phyx-> lol
17:53:40 <Phyx-> :t interact
17:53:41 <lambdabot> (String -> String) -> IO ()
17:53:44 <copumpkin> @type runKleisli (Kleisli (const getContents) >>> arr lines >>> arr (map read)) ("This is just here to confuse you", True, 5, "Because I can")
17:53:45 <lambdabot> forall a. (Read a) => IO [a]
17:54:03 * Phyx- checks
17:54:43 <Phyx-> yeah, that seems to be correct too dolio 
17:55:30 <Wolfspaw> woa, the new ways given confuse me a bit xD. I couldn't make it work yet with the copumpkin way:
17:55:33 <Wolfspaw> :t null.drop 1.group.map length
17:55:33 <Wolfspaw> Why this dont work then: "null.drop 1.group.map length x"
17:55:34 <lambdabot> forall a. [[a]] -> Bool
17:55:35 <Wolfspaw> where x is a [[Int]] ?.
17:55:43 <Phyx-> anyone got any tips on making this http://phyx.pastebin.com/mBEaCizV faster?
17:55:57 <Phyx-> I'm testing in ghci, I figure when compile ghc will unbox those ints
17:56:03 <copumpkin> Wolfspaw: you need a $
17:56:10 <copumpkin> Wolfspaw: give me $
17:56:28 <Wolfspaw> hm, alright. It worked xD
17:56:30 <copumpkin> @type null.drop 1.group.map length
17:56:31 <lambdabot> forall a. [[a]] -> Bool
17:57:43 <Phyx-> anyone? :P
17:59:33 <Phyx-> "GHC_OPTIONS" is the name of the pragma right?
18:02:03 <kmc> OPTIONS_GHC
18:03:18 <Phyx-> kmc: ty
18:03:22 <Phyx-> hmm, this is sloooow
18:07:42 <tensorpudding> so what's the best fastest way to get acquainted with FRP?
18:08:56 <tommd> Phyx-: Look at the assembly.  I'm seeing three sections (one for each `div` 2,3,4) with the asm:
18:10:24 <tommd> http://phyx.pastebin.com/Fyg10qLj
18:13:40 <Phyx-> tommd: yeah, I'm gonna rethink it a bit
18:14:49 <tommd> Phyx-: You could use bitshifts - the assembly looks much better
18:15:11 <tommd> Though the standard way to get `div` 3 will lose 1 bit of your range.
18:15:31 <tommd> Its really annoying the common optimizations aren't done for div.
18:18:08 <Phyx-> tommd: well, the solution is incorrect anyway, I'll first make a correct one :)
18:18:22 <lispy> hey
18:18:28 <lispy> how's code?
18:18:50 <Phyx-> how's code?
18:19:39 <lispy> I'm not writing any at the moment, but someone here must be? :)
18:20:08 <Phyx-> no, my code writing has been interrupted by someone bringing a laptop that needs fixing
18:20:11 <Phyx-> :/
18:20:29 <Phyx-> studying cs and people think I've studies "fixing computers"
18:21:06 <aristid> Phyx-: yeah, which graphics card should i buy?
18:21:18 <c_wraith> the most expensive one.
18:21:24 <Phyx-> ^^ what he said
18:21:40 <tommd> I've been asked several times in the past month about what laptop is good - heck if I know!
18:21:40 <aristid> ok! if it's broken i will just ask you what to do
18:21:48 <tommd> I know how to google and go to anandtech
18:22:23 <aristid> Phyx-: do you ask for something in return for "fixing stuff"? i mean, at the very least that would deter them
18:22:28 * fryguybob thinks hardware is an implementation detail...
18:22:39 * Phyx- wonders why he can remember his 80chars random WPA2 key but not his 7 digit phone number
18:23:14 <Phyx-> aristid: even if i ask, they'd think i'm joking :/
18:23:29 <Phyx-> fryguybob: hahaha, gotta remember that one
18:23:38 <aristid> Phyx-: just refuse to do it if you don't get something adequate in return
18:24:21 <Phyx-> aristid: I've noticed, the way to get them to go away the quickest is to just do it, and get it over with, or they'll keep asking and nagging
18:24:51 <aristid> Phyx-: that doesn't account for the fact that they will come back with similar problems
18:25:10 <aristid> you are successfully optimizing locally, but are stuck away from the global optimum :)
18:25:23 <Phyx-> aristid: i'm here once a year at the most
18:25:55 <Phyx-> it's funny how everyone's pcs suddenly break in this period
18:26:18 <aristid> in the other periods they probably pester somebody else?
18:26:54 <Phyx-> nope, still me, but thanks to caller id.. i just don't pick up ^_^
18:28:20 <EvanR> is there a way to floor both components of a complex number
18:28:30 <Martty> from [1,2,3,3,4] how can make a function that converts it this list to [1,2,3,4] and applied again yields [1,2,4] (obviously 3 is an argument, the element to remove but only once)
18:28:44 <Martty> -it
18:29:07 <Martty> i can't break from the procedural spell damnit
18:29:24 <Martty> all i can think of is a bool flag or a break; 
18:29:31 <EvanR> eh?
18:29:37 <EvanR> > nub [1,2,3,3,4]
18:29:38 <lambdabot>   [1,2,3,4]
18:29:42 <Phyx-> your function would need an extra argument
18:29:45 <EvanR> > delete 2 [1,2,3,4]
18:29:46 <Martty> right
18:29:46 <lambdabot>   [1,3,4]
18:29:55 <Phyx-> EvanR: wrong index :P
18:29:56 <Martty> > delete 2 [1,2,2,3,4]
18:29:57 <lambdabot>   [1,2,3,4]
18:30:00 <EvanR> heh
18:30:11 <Martty> @src delete
18:30:11 <lambdabot> delete = deleteBy (==)
18:30:20 <Martty> @src deleteBy
18:30:20 <lambdabot> deleteBy eq x []        = []
18:30:21 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
18:30:39 <Martty> how come it only removes one of them and not all of them?
18:30:58 <Martty> ah i see it
18:31:07 <Martty> wiowfejwknkcjvnruifh
18:31:07 <Wolfspaw> I have a [["123"],["234"]] and i want to convert to [[1,2,3],[2,3,4]]
18:31:08 <Wolfspaw> The best i could come was:
18:31:08 <Wolfspaw> :t map (map (map (read.pure)))
18:31:08 <lambdabot> forall a. (Read a) => [[[Char]]] -> [[[a]]]
18:31:09 <Wolfspaw> which is horrible, and still needs a concat of the most inner list(which i dont know how to append a concat in the function above...
18:31:28 <Wolfspaw> and i dont know if it even has a chance to work x.x
18:31:30 <EvanR> lol
18:31:35 <EvanR> map . map . map
18:31:40 <aristid> :t \(r:+i) -> ((:+) `on` realToFrac . floor) r i
18:31:42 <lambdabot> forall b a. (RealFloat a, RealFloat b) => Complex a -> Complex b
18:31:55 <EvanR> aristid: ouch
18:32:10 <aristid> EvanR: is that bad?
18:32:23 <EvanR> yeah i thought it was ocaml for a second ;)
18:32:35 <Wolfspaw> xD
18:33:15 <aristid> :t let unComplex (r:+i) = (r,i) in uncurry ((:+) `on` realToFrac . floor) . unComplex
18:33:17 <lambdabot> forall b a. (RealFloat a, RealFloat b) => Complex a -> Complex b
18:33:23 <aristid> EvanR: better? :P
18:33:35 <EvanR> heh
18:33:50 <Martty> @where is delete defined
18:33:50 <lambdabot> I know nothing about is.
18:33:57 <Phyx-> @hoogle delete
18:33:57 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
18:33:58 <lambdabot> Data.IntMap delete :: Key -> IntMap a -> IntMap a
18:33:58 <lambdabot> Data.IntSet delete :: Int -> IntSet -> IntSet
18:34:04 <Phyx-> prelude most likely
18:34:08 <Phyx-> or Data.List
18:34:26 <Martty> bingo
18:34:36 <aristid>  :info delete
18:34:36 <aristid> delete :: (Eq a) => a -> [a] -> [a] 	-- Defined in Data.List
18:34:57 <EvanR> why realToFrac?
18:35:01 <aristid> :t floor
18:35:03 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:35:11 <EvanR> :t (:+)
18:35:12 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
18:35:20 <aristid> EvanR: is there a non-Integral floor?
18:35:37 <EvanR> ah
18:35:49 <EvanR> how annoying
18:36:38 <aristid> EvanR: yeah
18:36:50 <JoeyA> Are there any Haskell -> C compilers?
18:37:00 <ezyang> GHC is one. 
18:37:02 <ezyang> -fvia-C 
18:38:15 <JoeyA> Is there a way to access the .c files created?
18:38:23 <EvanR> aristid: in that case, i will settle for Complex Double -> (Int,Int) ;)
18:39:00 <aristid> :t let unComplex (r:+i) = (r,i) in uncurry ((,) `on` floor) . unComplex
18:39:02 <lambdabot> forall b a. (RealFloat a, Integral b) => Complex a -> (b, b)
18:39:47 <EvanR> \(r:+i) -> (floor r, floor i) ;)
18:40:14 <aristid> EvanR: woah crazy code.
18:41:30 <tommd> JoeyA:Yes.
18:41:51 <EvanR> > (1,1) == (1,2)
18:41:52 <lambdabot>   False
18:41:53 <EvanR> > (1,1) == (1,1)
18:41:54 <lambdabot>   True
18:42:02 <JoeyA> ah, ghc -fvia-C -keep-hc-file
18:42:21 <Axman6> JoeyA: it's not pretty
18:42:48 <Axman6> and i don't believe it compiles properly, and that's the reason for the evil mangler being passed over the produced ASM
18:43:03 <EvanR> haha evil mangler
18:47:17 <EvanR> "what is the smallest number not in an IntMap Int"
18:47:25 <EvanR> non negative
18:57:09 <dancor> EvanR: so you have a map of Ints to Ints.  and you want the smallest Int that doesn't appear in the values?  or the keys?
18:57:17 <EvanR> values
18:58:00 <dancor> :t elems
18:58:01 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
18:58:11 <dancor> :t Data.IntMap.elems
18:58:12 <lambdabot> forall a. IM.IntMap a -> [a]
18:58:56 <dancor> :t notElem
18:58:57 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
18:59:38 <EvanR> min of map all numbers to not elem of elems
18:59:40 <EvanR> ;)
18:59:58 <Phyx-> IntMap == Map specialised to Ints?
19:00:12 <dancor> Phyx-: yes with Int for keys
19:00:17 <EvanR> min of filter of all numbers by notElem ;)
19:00:24 <Phyx-> dancor: aha
19:00:45 <EvanR> but it wont terminate
19:00:56 <EvanR> or will it
19:01:26 <dancor> > take 1 $ filter (`notElem` [9, 2, 5, 1, 7]) [1..]
19:01:27 <lambdabot>   [3]
19:01:39 <EvanR> yeah head
19:01:54 <dancor> ya head will work
19:01:55 <EvanR> thats pretty awesome
19:02:04 <dancor> it will error if your map contained every Int..
19:02:30 <EvanR> ill have to watch out for that
19:02:43 <dancor> i guess it's faster to make a Set of the values instead of a List
19:03:51 <dancor> > take 1 $ filter (`Data.IntSet.notMember` (Data.IntSet.fromList [9, 2, 5, 1, 7, 3, 3])) [1..]
19:03:52 <lambdabot>   Not in scope: `Data.IntSet.notMember'Not in scope: `Data.IntSet.fromList'
19:03:59 <dancor> a wiseguy eh
19:05:00 <EvanR> how about compute a list of pairs of all members that are equal
19:05:19 <EvanR> maybe thats a bad way
19:05:40 <EvanR> pairs of keys
19:07:02 <Twey> > filter (uncurry (==)) [(1, 2), (3, 3), (4, 5), (6, 7), (8, 8)]
19:07:03 <lambdabot>   [(3,3),(8,8)]
19:08:32 <EvanR> its now a map from keys to values, what are the pairs of keys who have equal values
19:08:54 <dancor> EvanR: sounds like you just want to flip the map around?
19:09:15 <EvanR> yeah it seems so
19:09:23 <dancor> from key -> value to value -> [key]
19:09:48 <EvanR> yeah
19:09:54 <dancor> flipMap :: (Ord k, Ord v) => M.Map k v -> M.Map v (S.Set k)
19:09:55 <dancor> flipMap = M.fromListWith S.union . map (second S.singleton . swap) . M.toList
19:10:58 <dancor> swap (x, y) = (y, x)
19:11:58 <EvanR> :t second
19:11:59 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
19:12:08 <EvanR> whats S
19:12:15 <EvanR> set
19:12:30 <EvanR> my brain is going to explode
19:12:47 <dancor> import qualified Data.Map as M
19:12:47 <dancor> import qualified Data.Set as S
19:12:57 <dancor> you can make an IntMap version of that too
19:13:59 <dancor> i heard that IntMap is going to somehow start being used implicitly when Map has Int key
19:14:18 <dancor> which would mean not having to write everything two ways for efficiency
19:14:49 <dancor> but idk the details or timeline
19:15:16 <EvanR> im thinking this operation means i need to keep a saner data structure to do this computation
19:15:57 <EvanR> like a map from keys to values
19:16:07 <EvanR> i mean, from values to keys
19:16:22 <dancor> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bimap
19:16:23 <EvanR> and traverse the finite possible values 
19:17:24 <EvanR> with this wonderful specimen, i cant seem to have two things in the same place
19:17:52 <EvanR> but it may be useful
19:21:24 <dancor> i wonder what's the best way to store "Maybe (Bool, OtherType)" in like JS.  probably abuse null for Nothing and make an object with named two fields for the pair..
19:22:10 <dancor> i want my typesystem back
19:22:33 <uranther> @hoogle second
19:22:34 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
19:22:34 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
19:22:34 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
19:23:11 <dancor> > second (+ 100) ("hi", 4)
19:23:12 <lambdabot>   ("hi",104)
19:23:38 <Martty> holy crap 
19:24:10 <uranther> @hoogle swap
19:24:10 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
19:24:10 <lambdabot> Control.Concurrent.STM.TMVar swapTMVar :: TMVar a -> a -> STM a
19:24:42 <Martty> this has to be the worst implementation of a list sort ever.. it takes like five minutes to sort [1..20]: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28485#a28485
19:24:44 <dancor> swap (a, b) = (b, a) is often used but hasn't been main-librarized
19:25:10 <Martty> at least its cool to see the numbers popping slowly
19:26:04 <c_wraith> martty: your definition of maxl is...  kind of silly.  It traverses the list O(n^2) times.
19:26:14 <dancor> general-purpose-lang : turing-tarpit :: sort-algorithm : ?
19:26:37 <Martty> c_wraith sounds bad.. any pointers on why its stupid?
19:28:00 <c_wraith> Martty: you're not sharing any work.  Haskell doesn't do common subexpression elimination, because it's typically not actually what you want.
19:28:09 <dibblego> what is a reasonable name for a function :: Kleisli m a b -> Kleisli m b c -> Kleisli m a c since (>=>) would be taken 
19:28:31 <dancor> :t (>=>)
19:28:32 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
19:28:43 <dancor> :t (>==>)
19:28:44 <Martty> c_wraith i've no clue what that means sorry
19:28:44 <lambdabot> Not in scope: `>==>'
19:28:52 <dibblego> yeah I guess, cheers
19:28:57 <dancor> >_>
19:29:00 <pastorn> @src sort
19:29:00 <lambdabot> sort = sortBy compare
19:29:03 <pastorn> @src sortBy
19:29:04 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
19:29:09 <pastorn> Martty: ^^^
19:29:14 <Martty> pastorn that's not fun :)
19:29:17 <dibblego> > let (>_>) = 7 in (>_>)
19:29:18 <lambdabot>   <no location info>: parse error on input `)'
19:29:19 <pastorn> Martty: indeed
19:29:22 <c_wraith> @src maximum
19:29:22 <lambdabot> maximum [] = undefined
19:29:23 <lambdabot> maximum xs = foldl1 max xs
19:29:23 <Phyx-> c_wraith: that's not strictly true is it? GHC does *some* CSE but not alot
19:29:24 <Cale> Martty:  maxl (x:xs) = let u = maxl xs in if x > u then x else u
19:29:35 <pastorn> i tried your sorting on [1..200]... my computer froze
19:29:40 <Martty> :d
19:29:50 <Cale> Martty: Actually, it's worse than n^2, it's 2^n
19:29:59 <Martty> looks like i've beaten several records
19:30:06 <Martty> pastorn try on [1..22] its fun 
19:30:12 <Cale> Martty: You're computing the maximum of the tail of the list twice
19:30:16 <c_wraith> I've written O(n!^2) sort before. :)
19:30:25 <Martty> ok let me think about this 
19:30:29 <Cale> Martty: because there are two occurrences of maxl xs there
19:30:29 <c_wraith> You've got nothing on that!
19:30:51 <Martty> for some reason when i code in haskell.. i spend 99% of the time thinking to write 1% of the code which turns out to be 2 lines
19:31:17 <Cale> Someone should come up with a sort whose complexity is naturally O(Ackermann(n,n))
19:31:34 <Martty> btw the line
19:31:37 <Phyx-> Martty: it could be worse... you could always end up not solving it
19:31:39 <Wolfspaw> Im stuck, can someone help me? : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28486#a28486
19:31:42 <Martty> sort x = maxl x : sort (del (maxl x) x)
19:31:50 <Martty> is it bad that there's maxl x twice?
19:31:53 <Cale> Martty: That's also a problem, yes
19:31:58 <Martty> like if i do 
19:32:00 <Martty> sort x = b : sort (del b x) where b = maxl x
19:32:05 <Martty> does that even help..?
19:32:09 <Cale> That'll be faster, yes
19:32:14 <dancor> Martty: if only you could write the other 99% of the code then have the compiler infer the missing part with genetic algorithms and unit tests
19:32:15 <c_wraith> Oh, you're right.  It recurses twice at every level, so yes, O(2^n).  Wow, amazing how simple of a change results in so much more work
19:33:18 <dancor> so simple, just swapping the 2 and the n
19:33:56 <Martty> ugh i can't think of any other intuitive way to get the max out of a list
19:33:58 <c_wraith> Except the other possibility is O(n)
19:34:05 <dancor> :t maximum
19:34:06 <lambdabot> forall a. (Ord a) => [a] -> a
19:34:07 <c_wraith> Cale already provided code.
19:34:14 <dancor> @src maximum
19:34:15 <lambdabot> maximum [] = undefined
19:34:15 <lambdabot> maximum xs = foldl1 max xs
19:34:21 <Martty> yea i saw it
19:34:21 <c_wraith> It's only a *very slight* variant on your code
19:34:29 <Martty> i also know the fold way
19:34:35 <c_wraith> It just makes sure you only recurse for the rest of the list once, instead of twice.
19:35:24 <Martty> well
19:35:27 <Martty> now it works rather fast
19:35:30 <c_wraith> The problem is that recursing twice at every level is *hugely* less efficient than once, because it happens at every level.  Exponential (really, correct use of the word) growth.
19:35:33 <dancor> > let f = f >> f in f
19:35:34 <lambdabot>   No instance for (GHC.Show.Show (m a))
19:35:34 <lambdabot>    arising from a use of `M9199932347...
19:35:52 <Martty> well its not very fast actually.. 
19:36:07 <Martty> i can still see the numbers load up if i do [1..10000].. at first at least
19:36:59 <c_wraith> well, you're still using a really slow implementation of selection sort.  But at least it's polynomial time now :)
19:37:21 <Martty> oh.. its not selection sort's problem?
19:37:44 <c_wraith> well, selection sort isn't going to be fast with lists, anyway.
19:38:01 <Martty> what's the fastest implementation of it? i want to compare
19:38:04 <Martty> hit me with that one liner
19:38:23 <c_wraith> Since removing an item from a list is O(n), where the standard selection sort algorithm (on arrays) assumes it's O(1)
19:39:11 <Martty> > [10..1]
19:39:12 <lambdabot>   []
19:39:20 <c_wraith> > [10,9..1]
19:39:21 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
19:39:45 <c_wraith> Heh.  I think this is a two-liner to do efficiently.
19:41:17 <Cale> Using delete is unnecessary
19:41:54 <Cale> Write selectMin :: (Ord a) => [a] -> (a,[a]), which gives the minimum element along with the remainder of the list.
19:42:07 <Martty> yea i was thinking that
19:42:12 <Martty> selectMax in my case i think
19:42:37 <Cale> I suppose, if you're sorting into reverse order.
19:42:59 <Cale> It's still going to be slow.
19:43:18 <aristid> selectBy :: (a -> a -> a) -> [a] -> (a,[a])
19:45:08 <c_wraith> Martty: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28487#a28487  If you want massive spoilers
19:45:30 <Martty> i'll check in a bit when i give up 
19:45:54 <c_wraith> I used the same approach Cale was advocating, with selectMin
19:46:21 <Wolfspaw> Im stuck, can someone help me? : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28486#a28486
19:46:28 <c_wraith> It's still not *fast*, since selection sort just isn't fast.  But it is at least correct. :)
19:47:35 <Cale> Wolfspaw: I'm not sure I understand what you're trying to do in general.
19:48:03 <Cale> Wolfspaw: What should the function do with [["123","45"],["678"]] ?
19:48:14 <Martty> ugh i need to read some more before i try stuff like this i guess
19:48:30 <Martty> i'm completely clueless on how to do it without deletion
19:48:30 <Cale> Martty: Quicksort is easier :)
19:48:46 <c_wraith> Hmm.  My implementation isn't stable.
19:48:54 <c_wraith> I used < when I should have used <= to make it stable
19:48:54 <Cale> Martty: Well, to avoid deletion you'd use direct recursion.
19:49:15 <Cale> and write the selection function that I mentioned.
19:49:33 <Martty> i was trying to .. then i realized i was calling del
19:49:37 <Martty> for the reminder of the list part lol
19:49:42 <Cale> So, you construct the minimum and remainder for (x:xs) using the minimum and remainder for xs
19:50:57 <Cale> Suppose that (m,rs) = selectMin xs
19:51:08 <Martty> i can see that
19:51:22 <Wolfspaw> Cale:  Well, that value should "never" happen. What i want is to resolve this problem: http://projecteuler.net/index.php?section=problems&id=11
19:51:26 <Cale> Then selectMin (x:xs) depends on the result of compare x m
19:51:45 <Martty> ok
19:51:48 <Wolfspaw> Cale: so i do lines in an input, and i want to transform the [[String]] in a matrix of digits
19:52:03 <Cale> If it's LT, that is, x < m, then x is our new minimum, and the remainder of the list is simply xs
19:52:17 <Martty> THERE
19:52:22 <Martty> "x is our new minimum"
19:52:53 <Cale> Well, rather, x is the minimum for the entire list x:xs, rather than just for xs
19:52:56 <mtnviewmark> Wolfspaw: you seem to have one too many levels of list
19:53:17 <lispy> > fix (:[])
19:53:18 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
19:53:25 <lispy> :)
19:53:36 <mtnviewmark> A matrix would be [String] -> [[Int]]
19:54:05 <Makoryu> > fix (():)
19:54:07 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
19:54:13 <Martty> Cale i'll read some more and get back to this.. looks like implementing sort algorithms was a good idea to learn haskell. thanks and gn
19:54:33 <Cale> Martty: Sure. Feel free to ask any questions you might have. :)
19:54:43 <Wolfspaw> mtnviewmark: but im breaking in lines, to have a "list of lines"
19:55:15 <mtnviewmark> A list of lines *is* [String]
19:55:19 <Martty> im actually surprised i got it to work even though it was O(e^(n!^n!)) 
19:55:42 <lispy> Wow, that's quite the complexity
19:56:00 <lispy> ?remember Martty im actually surprised i got it to work even though it was O(e^(n!^n!))
19:56:01 <lambdabot> It is forever etched in my memory.
19:56:10 <mtnviewmark> @hoogle Char -> Int 
19:56:11 <lambdabot> Data.Char digitToInt :: Char -> Int
19:56:11 <lambdabot> Data.Char ord :: Char -> Int
19:56:11 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
19:56:29 <lispy> > chr (ord 'A' + 1)
19:56:30 <lambdabot>   'B'
19:56:43 <elitexray> Do engineers use haskell?
19:56:59 <mtnviewmark> > digitToInt '5'
19:57:00 <lambdabot>   5
19:57:01 <Cale> elitexray: Some
19:57:05 <Cale> elitexray: I'm sure :)
19:57:25 <elitexray> Cale which distro do are you using?
19:57:50 <Wolfspaw> mtnviewmark: hm, you're right. I have to organize my ideias because its a mess right now... Let me think for a while and i'll come back if it still doesnt work
19:57:55 <Cale> elitexray: Ubuntu, but I'm probably going to switch back to Debian at some point soon.
19:58:02 <mtnviewmark> Okay!
19:58:09 <elitexray> wait, Ubuntu is Debian
19:58:27 <Cale> Ubuntu is a built on top of Debian
19:58:30 <Cale> -a
19:58:49 <elitexray> Is there any reason?
19:59:08 <sshc> What are some examples of Monads in other languages, such as C?
19:59:22 <Tezeract> any reason for what?
19:59:26 <Cale> Well, for one it doesn't seem to want to upgrade me to the latest version. Also, I've been more and more fed up with the broken PulseAudio stuff.
19:59:47 <lispy> sshc: Scala has monads.  I haven't seen them for C
19:59:58 <elitexray> but are you able to upgrade your graphics drivers and such?
20:00:06 <lispy> sshc: But, some of the things in C might follow the same structure.  Hang on, there is a classic blog post about it
20:00:13 <chrisf> sshc: ';' and the environment.
20:00:26 <lispy> sshc: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
20:00:28 <applicative> Wolfspaw, i put a tiny explanation of the trouble, I think http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28486#a28488
20:00:51 <Cale> elitexray: Well, I haven't needed to upgrade my graphics driver. I'm using an appropriate proprietary one.
20:00:51 <fryguybob> I have a string and I want to remove all chars between any repeated chars and the repeat, so "abcdebfg" becomes "abfg".
20:01:00 <Wolfspaw> applicative: thanks! i read it
20:02:30 <mtnviewmark> fryguybob: What do you get with "abcdebfghbk"?
20:02:44 <Makoryu> sshc: Clojure has an actual monad library, implemented with (I think) macros and dynamic binding
20:03:28 <fryguybob> mtnviewmark: "abk"
20:04:51 <mtnviewmark> So longest string between possible pairs?
20:05:44 <fryguybob> mtnviewmark: In the end, there can be no repeats, so taking out the first pair of b's then the remaining pair was that I was thinkking.
20:06:23 <mtnviewmark> So replace the pair with a single copy
20:06:39 <fryguybob> Yeah
20:07:06 <mtnviewmark> Still seems nondeterministic: "aBcdEfghBijkElm"
20:07:31 <mtnviewmark> Reduce the Bs or Es first?!
20:09:45 <Wolfspaw> applicative: okay, its because of a bad habbit that when something isnt working i put random dollar signs to see if it solves (i know they represent a "pair of parenthesis" so the dollar sign for me is like "oh, maybe i forgot a pair of parenthesis") . I'll try to make more sense of them, thanks!
20:11:04 <mtnviewmark> fryguybob: Are you looking for a way to think about how to approach that?
20:11:06 <fryguybob> mtnviewmark: Humm, I think in that case I want the outer most so "abelm".
20:11:09 <Makoryu> Wolfspaw: Hgnrk
20:11:47 <mtnviewmark> There is no outermost they overlap - did you mean left-most?
20:11:56 <Wolfspaw> Makoryu: ? o.o
20:12:11 <applicative> Wolfspaw yes; with a three term expression like " map square [1..10]"  a dollar sign after map will separate it from its arguments, and force the first to apply to the second.
20:12:28 <fryguybob> mtnviewmark: Union of intervals I suppose.
20:13:19 <fryguybob> mtnviewmark: But that's seeming to me to be beyond O(n^2)...back to the drawing board I suppose.
20:13:29 <heatsink> Makoryu: That sounds like a Norse word
20:13:39 <mtnviewmark> Really? That is likely to be much harder - but. Also, does the bigger program this is part of require that?
20:13:51 <Makoryu> heatsink: Maybe you're thinking of "Hngkr"
20:14:03 <applicative> Wolfspaw, but of course, "square [1..10]" won't make sense. And, speaking a bit naively, "map x" won't be something you can evaluate... it should still be a function, -- lifted into the list world, so to say. ;  it is the real function being applied to the list.  
20:14:21 <fryguybob> mtnviewmark: I don't think it is likely that I will come across overlapping pairs.
20:14:45 <heatsink> ah, I always get those two confused
20:14:52 <fryguybob> mtnviewmark: Actually just removing the b pairs is fine there because the end result doesn't have any repeats.
20:15:47 <fryguybob> mtnviewmark: So left most: "aBcdEfghBijkElm" becomes "aBijkElm"
20:15:59 <mtnviewmark> Okay well - then the thing to think of if you are half way through processing a string - what do you have in the "processed" portion?
20:16:12 <Wolfspaw> applicative: hmmm, got it
20:17:57 <mtnviewmark> Like consider "abobc" - after processing two characters what do you have?
20:18:45 <mtnviewmark> How do you combine the 'o' with that intermediate result?
20:18:46 <fryguybob> mtnviewmark: By processed do you mean "know has no repeats"?
20:18:50 <mtnviewmark> Right
20:19:39 <mtnviewmark> Then, after processing that, how do you process the second 'b' into that
20:20:52 <fryguybob> mtnviewmark: Humm, working...
20:25:18 <Wolfspaw> mtnviewmark: i can see clear now that a matrix is a [String], in fact i was even doing it like that in the code, but i was thinking in one more nested list. Im finishing to sketch the problem, but now i can see the problem really more clear!
20:26:09 <Phyx-> > cake
20:26:11 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:26:16 <Phyx-> lol, wtf
20:26:27 <Phyx-> now how do I see the whole thing
20:26:36 <geheimdienst> > tail cake
20:26:37 <lambdabot>   ["One can prepared coconut pecan frosting.","Three slash four cup vegetable...
20:26:48 <Phyx-> > length cake
20:26:49 <lambdabot>   42
20:26:52 <mtnviewmark> Remember that String = [Char] - and sometimes it is useful to think of such values one way, sometimes the other
20:26:53 <Phyx-> damn
20:26:55 <fryguybob> > concat cake
20:26:56 <lambdabot>   "One 18.25 ounce package chocolate cake mix.One can prepared coconut pecan ...
20:27:06 <geheimdienst> > cake !! 3
20:27:06 <c_wraith> you'll do better pming lambabot
20:27:07 <Phyx-> > cake !! 0
20:27:07 <lambdabot>   "Four large eggs."
20:27:08 <lambdabot>   "One 18.25 ounce package chocolate cake mix."
20:27:12 <geheimdienst> > cake !! 2
20:27:14 <lambdabot>   "Three slash four cup vegetable oil."
20:27:17 <Phyx-> > cake !! 1
20:27:19 <lambdabot>   "One can prepared coconut pecan frosting."
20:27:22 <geheimdienst> > cake !! 4
20:27:23 <lambdabot>   "One cup semi-sweet chocolate chips."
20:27:26 <Phyx-> > cake !! 5
20:27:27 <Wolfspaw> lol xD
20:27:28 <lambdabot>   "Three slash four cups butter or margarine."
20:27:30 <geheimdienst> > cake !! 6
20:27:32 <lambdabot>   "One and two third cups granulated sugar."
20:27:37 <geheimdienst> > cake !! 7
20:27:38 <Phyx-> > cake !! 7
20:27:38 <lambdabot>   "Two cups all-purpose flour."
20:27:39 <lambdabot>   "Two cups all-purpose flour."
20:27:45 <Phyx-> > cake !! 8
20:27:47 <lambdabot>   "Don't forget garnishes such as:"
20:27:48 <geheimdienst> it gets pretty funny towards the end
20:27:58 <Phyx-> it's damn long though
20:28:00 <geheimdienst> > cake !! 38
20:28:01 <lambdabot>   "Injector needle gun."
20:28:04 <geheimdienst> > cake !! 39
20:28:04 <Phyx-> o.O
20:28:05 <lambdabot>   "Cranial caps."
20:28:08 <geheimdienst> > cake !! 40
20:28:09 <lambdabot>   "And it contains proven preservatives, deep penetration agents, and gas and...
20:28:14 <Phyx-> I... don't want that cake
20:28:25 <geheimdienst> > drop 50 $ cake !! 40
20:28:26 <lambdabot>   "tion agents, and gas and odor control chemicals."
20:28:35 <geheimdienst> > cake !! 41
20:28:36 <lambdabot>   "That will deodorize and preserve putrid tissue."
20:28:38 <mtnviewmark> > unwords $ map (take 1 . words) cake
20:28:39 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:28:40 <lambdabot>         against inferred type...
20:29:06 <Phyx-> I rather have cake from chrisdone then
20:29:07 <geheimdienst> > length $ concat cake
20:29:08 <lambdabot>   1393
20:29:26 <dark> what if i do unwords $ map \n (newline) and then complete the rest in the other line? it will be a type error, right?
20:29:32 <Phyx-> > group $ sort $ concat cake
20:29:33 <lambdabot>   ["                                                                         ...
20:29:41 <dark> i need to escape the new line, like shell script?
20:29:44 <geheimdienst> what about chrisdone and cake? for the last few days i keep hearing this around here
20:29:57 <Phyx-> lol, he's always eating cake lately
20:30:06 <Phyx-> > group $ sort $ "hello world"
20:30:07 <lambdabot>   [" ","d","e","h","lll","oo","r","w"]
20:30:30 <geheimdienst> > map (head . words) cake
20:30:31 <lambdabot>   ["One","One","Three","Four","One","Three","One","Two","Don't","Fish","Fish"...
20:30:45 <geheimdienst> > unwords $ map (head . words) cake
20:30:46 <lambdabot>   "One One Three Four One Three One Two Don't Fish Fish Fish Fish Fish Pull F...
20:30:48 <mtnviewmark> Fish?!?!?
20:30:50 <dark> > cake
20:30:51 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:30:54 <Phyx-> > map (\x-> (length x, head x))group $ sort $ "hello world"
20:30:56 <lambdabot>   Couldn't match expected type `[[a]]'
20:30:56 <lambdabot>         against inferred type `[a1] ->...
20:31:02 <Phyx-> > map (\x-> (length x, head x)) $ group $ sort $ "hello world"
20:31:03 <lambdabot>   [(1,' '),(1,'d'),(1,'e'),(1,'h'),(3,'l'),(2,'o'),(1,'r'),(1,'w')]
20:31:11 <Phyx-> > map (\x-> (length x, head x)) $ group $ sort $ cake
20:31:13 <lambdabot>   [(1,"Adjustable aluminum head positioner."),(1,"Alpha resins."),(1,"An entr...
20:31:13 <chrisf> Phyx-: win; running that on this spec makes it more readable! [group $ sort ...]
20:31:28 <c_wraith> seriously, if it's a private message, \bot will respond with about 5x as much output at once
20:31:33 <Phyx-> chrisf: hm?
20:31:57 <dark> > tail $ take 5 cake
20:31:58 <lambdabot>   ["One can prepared coconut pecan frosting.","Three slash four cup vegetable...
20:32:07 <dark> > tail $ take 9 cake
20:32:09 <lambdabot>   ["One can prepared coconut pecan frosting.","Three slash four cup vegetable...
20:32:12 <Phyx-> c_wraith: lol, your message got lost in the noise :P
20:32:30 <Phyx-> > map (\x-> (length x, head x)) $ group $ sort $ concat cake
20:32:32 <lambdabot>   [(162,' '),(3,'\''),(4,','),(4,'-'),(43,'.'),(1,'1'),(1,'2'),(1,'5'),(1,'8'...
20:32:49 <dark> > reverse cake
20:32:51 <lambdabot>   ["That will deodorize and preserve putrid tissue.","And it contains proven ...
20:32:53 <heatsink> > map unwords $ transpose $ map words cake
20:32:55 <lambdabot>   ["One One Three Four One Three One Two Don't Fish Fish Fish Fish Fish Pull ...
20:33:06 <Phyx-> > sortBy (\a b-> fst a `compare` fst b) $ map (\x-> (length x, head x)) $ group $ sort $ concat cake
20:33:07 <lambdabot>   [(1,'1'),(1,'2'),(1,'5'),(1,'8'),(1,':'),(1,'D'),(1,'N'),(1,'P'),(1,'U'),(1...
20:33:20 <Phyx-> > reverse $ sortBy (\a b-> fst a `compare` fst b) $ map (\x-> (length x, head x)) $ group $ sort $ concat cake
20:33:22 <lambdabot>   [(162,' '),(156,'e'),(91,'a'),(89,'r'),(85,'s'),(79,'n'),(70,'o'),(62,'t'),...
20:33:25 <Wolfspaw> Ok, my doubt is how to make the (??a) and (??b) part in : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28490#a28490
20:33:38 <Phyx-> ok, i'm done
20:34:01 <Phyx-> @pl reverse $ sortBy (\a b-> fst a `compare` fst b) $ map (\x-> (length x, head x)) $ group $ sort $ concat cake
20:34:01 <lambdabot> reverse (sortBy ((. fst) . compare . fst) (map (liftM2 (,) length head) (group (sort (join cake)))))
20:34:07 <Phyx-> oh wow
20:34:23 <geheimdienst> > words "08 02 22"
20:34:25 <lambdabot>   ["08","02","22"]
20:34:39 <geheimdienst> wolfspaw: ^^
20:34:50 <heatsink> Some of the lines of transposed cake sound like markov chain stuff
20:35:04 <heatsink> "garnishes crackers. candies. solid dirt. ethylbenzene. peel organic peanut lemon resin."
20:35:07 <Wolfspaw> hm , geheimdienst  thanks xD
20:35:30 <fryguybob> How would I write this as a fold http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28486#a28486 ?
20:36:13 <uranther> http://projecteuler.net/index.php?section=problems&id=23 on prob 23, I can make a list of abundant numbers, but I'm not sure how to check if a number is a sum of two abundant numbers. Can someone give me a push in the right direction?
20:36:29 <geheimdienst> you're welcome
20:37:31 <geheimdienst> as for the ??b step, there is nothing to be done. a String in haskell is a list of Char
20:37:58 <geheimdienst> > "lolcat" == ['l', 'o', 'l', 'c', 'a', 't']
20:37:59 <lambdabot>   True
20:39:55 <Makoryu> Would it be fair to characterize ByteStrings as unrolled lists?
20:41:06 <c_wraith> Possibly.
20:42:16 <Wolfspaw> geheimdienst: alright, but in both cases to transform in Ints. In (??a) i though of: map read (words x) . But it gives an error because im operating in the [[Char]] , how can i chain a second map to get the [Char] ?
20:42:56 <geheimdienst> > map (map . read) ["123", "456"]
20:42:58 <lambdabot>   No instance for (GHC.Read.Read (a -> b))
20:42:58 <lambdabot>    arising from a use of `e_112345...
20:43:07 <geheimdienst> > map (map . (read :: Int)) ["123", "456"]
20:43:08 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:43:08 <lambdabot>         against inferred type ...
20:43:20 <geheimdienst> *cough* my haskell-fu is not so strong today *cough*
20:43:25 <Wolfspaw> xD
20:43:55 <Wolfspaw> rofl xD
20:44:41 <springs> I have a ?nub? question: I'm looking through some examples for gloss, there are a few "$" symbols, what do they mean? eg: Pictures [ Color treeColor 	$ rectangleUpperSolid 20 300 , Color treeOutline	$ rectangleUpperWire  20 300  
20:44:58 <c_wraith> springs: it's a function
20:45:00 <c_wraith> :t ($)
20:45:01 <lambdabot> forall a b. (a -> b) -> a -> b
20:45:14 <springs> ooohhh tytyty
20:45:22 <c_wraith> It just takes advantage of haskell's parsing rules to operate at the lowest-possible priority
20:46:19 <Cale> springs: f $ x = f x, but $ has really low precedence
20:46:48 <Cale> springs: It's common to compose a bunch of functions with each other using (.), and then apply the resulting function to an argument with ($)
20:46:54 <Cale> Like:  f . g . h $ x
20:47:07 <Cale> which is equal to f (g (h x)), but with fewer parens
20:47:52 <springs> thanks guys 
20:50:14 <tensorpudding> How can I get parsec 3.x, cabal-installing parsec only gets me 2.1.0.1
20:50:40 <dark> there is a parsec-3.1 package
20:50:44 <dark> or something like that
20:50:52 <Cale> tensorpudding: You can specify a version number with a hyphen in between
20:50:58 <geheimdienst> wolfspaw, i found out that "read" always wants a String, not a Char. maybe try digitToInt from the Data.Char package
20:51:04 <geheimdienst> @hoogle Char -> Int
20:51:04 <lambdabot> Data.Char digitToInt :: Char -> Int
20:51:05 <lambdabot> Data.Char ord :: Char -> Int
20:51:05 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
20:57:08 <tensorpudding> the parsec documentation claims to be incredibly old, and the version in RWH seems to be different too
20:57:31 <tensorpudding> and the parsec page on haskell.org has bitrotted links
20:57:59 <geheimdienst> *bitrotten
20:58:03 <pastorn> tensorpudding: i think there was a major revision last summer
20:58:19 <uranther> how can I take 2 lists [1..10] [1..10] and do 1+1, 1+2, 1+3, ..., 2+2, 2+3, ...
20:58:25 <tensorpudding> is there any documentation for this new revision?
20:58:30 <tensorpudding> is it worth using at all?
20:58:36 <geheimdienst> > forM [1..10] [1..10]
20:58:37 <lambdabot>   Couldn't match expected type `t -> m b' against inferred type `[a]'
20:58:56 <geheimdienst> > forM (+) [[1..10], [1..10]]
20:58:57 <lambdabot>   Couldn't match expected type `[a]'
20:58:58 <lambdabot>         against inferred type `a1 -> a1 ...
20:59:01 <tensorpudding> > [x + y | x <- [1..10], y <- [1..10]]
20:59:03 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
20:59:14 <Axman6> > liftM2 (+) [1..10] [1..10]
20:59:15 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
20:59:37 <Axman6> (+) <$> [1..10] <*> [1..10]
20:59:39 <Saizan> tensorpudding: the API is largely the same, parsec3 has two main innovations, the Stream class and the transformer
20:59:58 <geheimdienst> > (+) <$> [1..10] <*> [1..10]
20:59:59 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
21:00:05 * uranther checks out liftM2
21:00:08 <uranther> thanks guys
21:00:09 <geheimdienst> holy smokes, axman6 :-o
21:00:10 <Saizan> tensorpudding: i.e. even Daan's original documentation is still very relevant
21:00:13 <tensorpudding> if the API has changed, why hasn't the website been made to point to something that has been updated in the last five years
21:00:47 <Saizan> tensorpudding: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html <- this one, if you haven't found it yet
21:01:01 <Saizan> because there's nothing that's been updated in the last five years :)
21:01:10 <tensorpudding> That's the "not updated in five+ years" thing that I was referring to
21:01:18 <Axman6> (\x y z -> x + y + z) <$> [1..10] <*> [1..10] <*> [1..10]
21:01:24 <Axman6> > (\x y z -> x + y + z) <$> [1..10] <*> [1..10] <*> [1..10]
21:01:24 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7,8,9,10,11,12,13,14,6,...
21:01:41 <tensorpudding> I just think that the whole thing is strongly repulsive to newbs
21:01:44 <geheimdienst> > ((+) . (+)) <$> [1..10] <*> [1..10] <*> [1..10]
21:01:45 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
21:01:45 <lambdabot>    arising from a use of `e_111011...
21:01:58 <geheimdienst> > ((+) . (+) ) 3 4 5
21:01:59 <lambdabot>   12
21:02:00 <tensorpudding> considering myself one for intents and purposes
21:02:18 <Saizan> the haddock does have descriptions for the various combinators
21:02:35 <tensorpudding> The haddock is unreadable if you want to know how to use parsec on the whole.
21:03:19 <Saizan> that's what the 5 year old doc explains ;)
21:03:44 <tensorpudding> I've got the 2.x parsec here
21:03:58 <tensorpudding> the types are different from that in the haddock, and different still from what's in RWH
21:04:05 <uranther> Axman6: how does this worK? (+) <$> [1..10] <*> [1..10]
21:04:32 <Saizan> for the first you should just look at the haddock for the version you have
21:04:44 <Saizan> rather than haddock for 3
21:05:09 <Saizan> anyhow, it's true that it could be way more consistently presented
21:05:10 <tensorpudding> why is 3.x not default?
21:07:37 <mm_freak_> uranther: f <$> x <*> y
21:07:47 <Saizan> well, the first release of 3 had some problems, like performance regressions, so it wasn't considered stable, later versions got quite better it seems, but the maintainer still hasn't blessed it as stable/preferred
21:07:51 <mm_freak_> x and y are applicative computations and f is a function, which is applied to their results
21:07:52 <Axman6> uranther: <$> is fmap, and <*> is ap. so in this case, you have <$> :: Num a => (a -> a -> a) -> a -> [(a->a)], <*> :: [(a->a)] -> [a] -> [a]
21:08:14 <mm_freak_> > (+) <$> pure 1 <*> pure 2
21:08:15 <lambdabot>   No instance for (GHC.Show.Show (f a))
21:08:15 <lambdabot>    arising from a use of `M5572026451...
21:08:20 <tensorpudding> when I said five+ years, it's more like 10.
21:08:28 <mm_freak_> > (+) <$> pure 1 <*> pure 2 :: [Integer]
21:08:28 <lambdabot>   [3]
21:08:56 <mm_freak_> > (+) <$> [1,2,3] <*> [4,5,6]
21:08:57 <lambdabot>   [5,6,7,6,7,8,7,8,9]
21:09:06 <tensorpudding> not sure if this will even work on a context-sensitive grammar
21:09:17 <Saizan> it's not like documentation bitrots if the API stays the same :)
21:09:22 <Axman6> > f <$> [x,y] <*> [z,a] :: [Expr]
21:09:23 <lambdabot>   [f x z,f x a,f y z,f y a]
21:10:21 <tensorpudding> it's not really "the documentation is wrong", it's that links are all bitrotted, imports are no longer valid, sample code doesn't compile, and the haskell wiki article is moldy
21:11:16 <Wolfspaw> geheimdienst: thanks! I Read your suggestion now o/
21:12:18 <geheimdienst> tensorpudding, i agree that documentation is often bad, and on parsec it's particularly confusing. it definitely is time to update the wiki with the information that Saizan gave just now
21:13:12 * Saizan spots the "import Parsec" bit he apparently never paid attention to
21:13:34 <tensorpudding> Once I understand how parsec works I'll update the wiki article maybe
21:14:13 <geheimdienst> thanks tensorpudding
21:14:14 <tensorpudding> hmm
21:14:21 <tensorpudding> trying to register an account caused an SQL error
21:15:09 <tensorpudding> oh wait
21:15:19 <tensorpudding> i have to fill the fields for logging in
21:15:42 <scotty> I'm trying to define "put" in my instance declaration for Data.Binary, but I
21:16:14 <scotty> I'm not sure how to "put" an entire list.  I thought I would do mapM put xs, but the type of put has to be PutM ().
21:16:47 <Saizan> mapM_ put xs
21:17:07 <scotty> Saizan: Ah, that one throws away the value, right?
21:17:34 <Saizan> or you could rely on the Binary instance for lists and use "put xs"
21:17:42 <Saizan> scotty: yep
21:17:57 <Axman6> :t mapM_
21:17:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
21:18:06 <Axman6> where m = Put
21:18:16 <Saizan> you could also have used "mapM put xs >> return ()" to make the typechecker happy, but that would have been less performant
21:18:19 <scotty> Saizan: It worked.  I don't thing I can do the second thing you said though.
21:18:33 <mm_freak_> can one write a memoizer without unsafePerformIO?
21:18:35 <mm_freak_> memoize :: Ord a => (a -> b) -> IO (a -> b)
21:18:41 <scotty> Saizan: This list contains elements of the type I'm creating the instance for.
21:18:48 <scotty> Saizan: It's a recursive type.
21:18:59 <Saizan> scotty: that's not a problem per se
21:19:19 <tensorpudding> will the ugly old logo be leaving the frontpage sometime?
21:19:26 <scotty> Saizan: Let me try it.
21:19:41 <scotty> Saizan: Oh, you were right. :)
21:20:08 <scotty> Saizan: I guess I can treat it like it's an instance of Binary in the instance declaration for Binary.
21:20:51 <Saizan> scotty: yeah, anyhow you were doing it already with your "mapM_ put xs"
21:22:47 <Makoryu> tensorpudding: It will probably leave the front page around the same time the whole site switches to HoaH
21:23:11 <fryguybob> mm_freak_: yes!
21:23:23 <tensorpudding> is on-a-horse that big of a deal, that it'll supplant happstack?
21:23:24 <kmc> mm_freak_, did you see data-memocombinators?
21:23:33 <Makoryu> tensorpudding: No :p
21:23:34 <scotty> Also, I have another question: If I have a type that's an instance of some class, and then I have a class which contains methods for converting a type to and from that type, can I then write a catch-all instance declaration for members of that class?  If I worded that poorly, I can provide a code example.
21:23:42 <Makoryu> tensorpudding: Honestly I have no idea
21:23:49 <Makoryu> I didn't even look at the examples
21:24:22 <dark> @src fmao
21:24:23 <lambdabot> Source not found. My pet ferret can type better than you!
21:24:24 <dark> @src fmap
21:24:24 <lambdabot> Source not found. You untyped fool!
21:24:29 <heatsink> scotty: No, that would produce overlapping instances
21:24:33 <dark> :t fmap
21:24:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:24:59 <scotty> heatsink: Overlapping?
21:25:13 <heatsink> scotty: Actually, I think you can, if you turn on some flags
21:25:26 <Saizan> scotty: you could do that by turning on OverlappingInstances, but it's quite discouraged
21:25:28 <fryguybob> mm_freak_: http://hackage.haskell.org/package/MemoTrie
21:25:34 <dark> > fmap (\x -> x + 1) [1, 2]
21:25:35 <lambdabot>   [2,3]
21:25:43 <dark> > map (\x -> x + 1) [1, 2]
21:25:44 <lambdabot>   [2,3]
21:25:44 <heatsink> Oh wait, there's the instance head matching restriction
21:25:45 <scotty> heatsink: I hope I explained it well.  I don't see why it is bad.
21:25:48 <dark> :t map
21:25:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:25:54 <heatsink> Let me check
21:26:05 <kmc> @src Maybe fmap
21:26:05 <lambdabot> fmap _ Nothing       = Nothing
21:26:05 <lambdabot> fmap f (Just a)      = Just (f a)
21:26:08 <kmc> @src [] fmap
21:26:08 <lambdabot> fmap = map
21:26:21 <dark> ah
21:26:28 <dark> @src Maybe map
21:26:28 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:26:29 <kmc> @src Functor
21:26:30 <lambdabot> class  Functor f  where
21:26:30 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
21:26:46 <dark> there is no map for Maybes, but fmap?
21:26:59 <kmc> map is for lists only, fmap works on any functor
21:27:03 <kmc> for lists fmap = map
21:27:04 <mm_freak_> fryguybob, kmc: thanks
21:27:08 <Saizan> scotty: basically, instance resolution doesn't pay attetion to instance contexts, because with separate compilation you can't really tell if a type _is not_ an instance of some class
21:27:13 <dark> fmap is a generalization of map, then?
21:27:17 <Makoryu> dark: Yes
21:27:24 <kmc> yes
21:27:26 <fryguybob> mm_freak_: There is also http://www.haskell.org/haskellwiki/Memoization which has some info.
21:27:45 <mm_freak_> i've implemented a Map-based memoizer using unsafePerformIO
21:27:47 <dark> why wasn't map deleted, and fmap defined as map? performance? historical reasons?
21:27:56 <kmc> historical reasons, better error messages
21:27:57 <mm_freak_> it uses an IORef internally
21:28:05 <geheimdienst> @src map
21:28:05 <lambdabot> map _ []     = []
21:28:06 <lambdabot> map f (x:xs) = f x : map f xs
21:28:21 <kmc> performance should not be an issue, since the compiler could specialize it easily (and GHC can be instructed to do so)
21:28:23 <mm_freak_> is MemoTrie going to be faster?
21:28:29 <dark> ah, hm, if map expects a list, the error message can reflect that
21:28:54 <Saizan> dark: during haskell98 there was a general fear of polymorphism making the language harder to learn
21:29:00 <kmc> there is some idea that beginners will be confused by getting messages about Functor when all they want is to map over a list
21:29:29 <dark> hm o.o
21:29:37 <geheimdienst> ... fortunately, that fear has since been overcome and today haskell is being made as hard to learn as possible</scnr>
21:29:52 <dark> ^^'
21:29:55 <mm_freak_> hehe
21:30:06 <mm_freak_> sometimes i miss monad comprehensions
21:30:07 <heatsink> :t fmap
21:30:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:30:17 <mm_freak_> especially when using a list monad transformer
21:30:19 <Saizan> geheimdienst: scanr?
21:30:27 <scotty> Saizan: So, I have to write an instance declaration for every type which is a member of my class which has functions that convert to and from a type which is already an instance of the class?
21:30:35 <geheimdienst> "sorry could not resist"
21:31:08 <heatsink> scotty: I think you can write a single instance (Convert a b) => Foo a
21:31:14 <mm_freak_> :i Expr
21:31:21 <scotty> Here's what I have: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28496#a28496
21:31:23 <mm_freak_> @src Expr
21:31:24 <lambdabot> Source not found.
21:31:25 <Saizan> scotty: you could use a newtype wrapper
21:31:50 <scotty> I want to write an instance declaration for every type which is a member of "Fooable."
21:32:00 <heatsink> Fooable a => Binary a
21:32:04 <Saizan> i personally would just put toFoo/fromFoo calls where needed.
21:32:07 <kmc> that will overlap with everything else
21:32:10 <scotty> heatsink: Yes
21:32:20 <scotty> heatsink: But I think I tried that and it didn't work.
21:32:24 <kmc> the context is not used when selecting instances, only the head
21:32:28 <kmc> and 'a' unifies with any type
21:32:32 <dark> @pl a (\x -> x . x)
21:32:33 <lambdabot> a (join (.))
21:32:41 <dark> @pl a (\x -> x . x $ x)
21:32:42 <lambdabot> a (join (join (.)))
21:32:50 <dark> :src join
21:32:59 <dark> @src join
21:33:00 <lambdabot> join x =  x >>= id
21:33:01 <johnw> why do people use this channel as if they don't have ghci on their own machine?
21:33:08 <kmc> collaboration
21:33:10 <scotty> Saizan: I'm still kind of a Haskell noob.  I don't know what you have in mind with the newtype wrapper.
21:33:25 <dark> johnw, I find it nice. but yes, I am also with ghci open
21:33:33 <dark> sorry .-.
21:33:44 <mm_freak_> johnw: what's wrong with that?  i've learned a lot from other people using lambdabot
21:33:46 <kmc> scotty, «newtype Bin a = Bin a; instance (Fooable a) => Binary (Bin a)»
21:33:47 <johnw> it just makes #haskell seem like line noise sometimes, and I can't see the relevance to the discussion
21:33:48 <Saizan> "instance Fooable a => Binary a" requires OverlappingInstances, but it's a really bad instance to make, next time you use "get" on a type without a Binary instance you get asked for a Fooable instance instead, and if you later want to do the same with a Barable too, you can't.
21:34:10 <kmc> johnw, i agree it can be abused but i don't see the need to call anyone out on it right now
21:34:13 <dark> johnw, I don't have @pl (or :pl ..) in my ghci
21:34:17 <kmc> it's also worth noting that lambdabot supports private messages
21:34:22 <Saizan> dark: you can privmsg lambdabot btw
21:34:22 <mm_freak_> johnw: also some things aren't available in a typical GHC installation like Expr
21:34:25 <johnw> i'm just asking after several weeks of pent up wondering
21:34:51 <geheimdienst> does anyone understand the source of "join"? i thought join was just another name for >>=
21:34:54 <geheimdienst> @src join
21:34:55 <lambdabot> join x =  x >>= id
21:35:01 <mm_freak_> geheimdienst: look at its type
21:35:04 <mm_freak_> :t join
21:35:05 <dark> johnw, I always learn something new seeing other doing random stuff with the bot. But that's because I'm newbie
21:35:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:35:05 <kmc> join :: (Monad m) => m (m a) => m a
21:35:17 <kmc> dark, i'm not a newbie and i still learn a lot :)
21:35:20 <geheimdienst> :t >>=
21:35:21 <lambdabot> parse error on input `>>='
21:35:25 <mm_freak_> geheimdienst: it removes one layer of, well, 'monadness'
21:35:26 <Makoryu> :t (>>=)
21:35:26 <geheimdienst> :t (>>=)
21:35:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:35:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:35:38 <mm_freak_> > join $ Just (Just 3)
21:35:39 <lambdabot>   Just 3
21:35:41 <kmc> a good exercise is to write (>>=) using join and fmap
21:35:49 <geheimdienst> oh okay. thanks guys
21:35:49 <mm_freak_> > join ["abc", "def"]
21:35:50 <Makoryu> > join [[1]] -- geheimdienst
21:35:50 <lambdabot>   "abcdef"
21:35:51 <lambdabot>   [1]
21:35:58 <kmc> for lists, join = concat
21:36:02 <kmc> as you'd expect from the type
21:36:14 <Makoryu> > join return (putStrLn "foo")
21:36:15 <lambdabot>   <IO ()>
21:36:36 <Saizan> geheimdienst: note that (id :: m a -> m a) in "x >>= id"
21:36:39 <mm_freak_> geheimdienst: in fact, the categorical definition of a monad is a triple of fmap, return and join
21:37:25 <kmc> join is nicer for talking about the algebraic structure, (>>=) is nicer for writing code
21:37:41 <kmc> let it never be said we've never made a compromise for practicality ;P
21:37:44 <drbean> What's the difference between the Fedora ghc-ghc and ghc packages?
21:37:46 <mm_freak_> geheimdienst: there is one transformation (a -> m a) and one transformation (m (m a) -> m a)
21:38:01 <Saizan> "fmap + the type constructor" in the same slot of the triple, actually :)
21:38:10 <mm_freak_> Saizan: true =)
21:38:17 <scotty> Saizan: I'm not sure I fully grasp the overlapping instances thing.  Why would I get asked for a Fooable instance when I call get on something that's not a member of Binary?  Is that because any 'a' can be a Fooable, so now it assumes it will fall in the Fooable class?
21:38:21 <mm_freak_> Saizan: but i think 'fmap' implies that
21:38:34 <mm_freak_> because it belongs to the class Functor
21:38:35 <kmc> scotty, instance selection is based only on the head, the part after =>
21:39:01 <mm_freak_> kmc: actually i found monads to be easier to implement in terms of fmap, return and join
21:39:24 <scotty> kmc: So, it's like I've written an instance declaration of Binary for every type?
21:39:34 <Saizan> scotty: what "instance Fooable a => Binary a" really means is "every type is an instance of Binary. oh then when you need this add a Fooable constraint too."
21:39:42 <Saizan> scotty: right
21:39:53 <scotty> Saizan: Right, but it's ignoring everything after =>
21:40:02 <scotty> Saizan: Well... crap.
21:40:14 <kmc> you can still write more specific instances of Binary, and -XOverlappingInstances will find them
21:40:14 <scotty> Saizan: What should I do instead?
21:40:54 <kmc> newtype Bin a = Bin a; instance Fooable a => Binary (Bin a)
21:40:55 <scotty> My plan was to have this intermediary format for converting things to Binary.
21:41:25 <kmc> now only in cases where it sees the type constructor "Bin" will it attempt to use the Fooableness
21:41:37 <scotty> kmc: I see.
21:41:55 <Saizan> scotty: the options are: 1) used toFoo/fromFoo manually where needed; 2) use kmc's Bin wrapper, but then you'll use Bin/fromBin instead of toFoo/fromFoo 3) write an instance of Binary for each type separately
21:42:40 <kmc> this is a lousy situation, but it's the best we can do with the current typeclass system
21:42:42 <Saizan> fromBin (Bin x) = x, for completeness :)
21:42:46 <heatsink> 4) Use template haskell to generate instances (expect to spend a long time learning template haskell)
21:43:15 <scotty> Saizan: For 2, I don't think I will need to call to/fromBin, since I will put those in the Binary (Bin a) instance declaration, and then I can just call encode.
21:43:20 <Saizan> which is just the slow version of 3) :)
21:43:46 <kmc> scotty, an example from the std lib is that Applicative was invented after Monad; they wanted to retroactively make every Monad an instance of Applicative, but the best they can do is «Monad m => Applicative (WrappedMonad m)» plus individual instances
21:44:20 <Saizan> scotty: you'll have to call encode on a "Bin X" though, and the only way to get a Bin X from an X is to use the Bin constructor, there's no automatic conversion
21:44:26 <kmc> if instances (slash their dictionaries) were first class, you could at least just say «instance Applicative MyMonad = applicativeMonad», where applicativeMonad is some polymorphic dictionary constant
21:44:49 <kmc> as is you've got to write «instance Applicative MyMonad where { pure = return; (<*>) = ap }»
21:44:59 <scotty> Saizan: I see, so it's basically just as bad as writing a bunch of instance declarations or calling to/fromFoo.
21:46:28 <Traveler9> Hello?
21:46:49 <Makoryu> Traveler9: Sup
21:46:54 <scotty> So, why is the context not honored in instance declarations?  It seems like a useful thing.
21:46:54 <kmc> hi Traveler9
21:46:58 <Traveler9> Not much.
21:47:02 <Traveler9> And, hello to you as well.
21:47:15 <scotty> Traveler9: Hey
21:47:21 <kmc> scotty, it'd be more complicated to implement; you'd need a full backtracking logic programming system
21:47:22 <Traveler9> Hello, Scotty.
21:47:35 <kmc> i don't think it's impossible; other languages have supported it
21:47:46 <kmc> scotty, you may enjoy this paper "Type classes: exploring the design space"
21:47:57 <Saizan> the main reason is that it'd be more complicated to understand what instances you're using where
21:48:00 <Traveler9> I stumbled upon Haskell a few minutes ago, and decided it interesting.
21:48:19 <scotty> kmc: Okay, I'll check it out!  I've been reading "Learn you a Haskell", and it's awesome!
21:48:22 <Saizan> unless we just say that separate compilation shouldn't be done :)
21:48:39 <Traveler9> 04Hmm..
21:48:50 <dibblego> Traveler9, feel free to ask questions, how did you stumble on it?
21:48:54 <scotty> Traveler9: Learn you a Haskell for Great Good!
21:49:03 <kmc> i'd like a world where programs are semantically compiled whole-program, and it's the job of the compiler to transparently optimize this to separate compilation behind the scenes
21:49:05 <Saizan> (implementing prolog was 100 lines oh Hugs's Haskell ages ago :)
21:49:08 <Traveler9> 04Via Primesieve
21:49:14 <scotty> Traveler9: http://learnyouahaskell.com/
21:49:15 <kmc> but i realize this is tricky as hell
21:49:17 <Traveler9> 04It added Haskell as a resource.
21:49:23 <ezyang> kmc: Me too! 
21:49:27 <Traveler9> 04I decided to check it out.
21:49:35 <ezyang> We can sort of get this with shared libraries... but not always... 
21:49:56 <scotty> kmc: That sounds cool.
21:50:07 <Traveler9> 04Also: The commands I do know is pretty mush summed up as "Print "Hello World"" 
21:50:09 <Traveler9> 04much*
21:50:38 <kmc> Traveler9, ah.  in Haskell it's best to ignore IO at the start ;)
21:50:51 <kmc> poke around in GHCi, evaluating expressions
21:50:57 <kmc> Traveler9, did you see LYAH and RWH?
21:50:59 <kmc> @where LYAH
21:50:59 <lambdabot> http://www.learnyouahaskell.com/
21:51:00 <kmc> @where RWH
21:51:01 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:51:15 <Traveler9> 04I see that you can make your own executables here? Or, rather, compile for them?
21:51:55 <Saizan> ezyang: i find it unlikely that shared libraries would help much with gathering info for type checking :)
21:52:00 <Makoryu> Traveler9: Yes, Haskell compiles to native executables
21:52:25 <Traveler9> 04It directed me towards GHC, but GHC warned that Haskell already had some sort of implentation for it>
21:52:37 <Makoryu> Eh?
21:52:44 <Traveler9> 04implementation*
21:52:53 <Saizan> you mean the haskell platform?
21:52:57 <ezyang> Saizan: Not dll shared libraries; I mean compile-time libraries :-) 
21:53:04 <Traveler9> 04Sorry for the embarrasing newbie questions..
21:53:42 <wioux> Traveler9: GHC is the most widely used compiler. its the way to go
21:53:51 <geheimdienst> traveler9, don't worry :-) ghc is to haskell as gcc is to C
21:54:04 <kmc> GHC is a Haskell compiler.  Haskell Platform is a bundle of GHC plus standard libraries and tools that are certified to work well together
21:54:10 <kmc> you should probably start with Haskell Platform
21:54:32 <kmc> there are other Haskell compilers, and Haskell interpreters as well, but GHC is the workhorse
21:54:44 <kmc> it comes with an interactive shell (GHCi) that feels like what you may be used to from an interpreter
21:54:50 <kmc> so it's like the best of both worlds
21:55:00 <Traveler9> 04You mean, command-line Haskell?
21:55:14 <kmc> yes, type an expression and see how it evaluates
21:55:24 <kmc> it's the best way to learn, experiment, and debug
21:55:36 <Traveler9> 04Well, it does make a good calculator.
21:55:40 <Traveler9> 04:D
21:55:43 <Traveler9> 04:)*
21:56:12 <kmc> if you're not expecting numeric type conversions, yes
21:56:40 <geheimdienst> > 3 + 4
21:56:41 <lambdabot>   7
21:56:44 <geheimdienst> > 3 + 4.0
21:56:45 <lambdabot>   7.0
21:57:04 <geheimdienst> why does that work?
21:57:11 <geheimdienst> > (3 :: Int) + 4.0
21:57:12 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
21:57:12 <lambdabot>    arising from the lit...
21:57:16 <geheimdienst> ah :-)
21:57:17 <Traveler9> 04Hmm..
21:57:24 <Traveler9> 04I'm used to PARI.
21:57:32 <Traveler9> 04PARI/GP*
21:58:26 <wioux> are you a mathematician?
21:58:58 <Traveler9> 04I'm a maths enthusiast, but am not a mathematician.
21:59:41 <Traveler9> 04Also: I'm going to make a guess as to what commands to use for loops..
22:00:12 <wioux> there are no loops! :)
22:00:34 <Traveler9> 04What.
22:00:39 <wioux> recursion is all-present in Haskell. it takes the place of loops
22:00:49 <Traveler9> 04Oh. 
22:00:59 <Traveler9> 04Does it work similarly to looping?
22:01:09 <kmc> well, you can write functions that act like loops
22:01:19 <kmc> but there's no special built-in looping construct; you define them in terms of recursion
22:01:23 <kmc> an example from the std library is map
22:01:26 <kmc> :t map
22:01:27 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:01:41 <kmc> basically, we focus less on how to get the answer, and more on describing what the answer is
22:01:47 <wioux> any loop can be written recursively, although it sometimes takes a bit of thought
22:02:19 <kmc> @src map
22:02:20 <lambdabot> map _ []     = []
22:02:20 <lambdabot> map f (x:xs) = f x : map f xs
22:02:30 <Traveler9> 04@Wioux: And a whole lot of syntax errors.
22:03:07 <applicative> no, the syntax errors are more likely among loop writers, surely?
22:03:23 <kmc> because loops, being magic built-ins, have more syntax to remember
22:03:31 <kmc> map is an ordinary function and you apply it like any other function
22:03:34 <applicative> we don't do syntax errors, we do type violations!
22:03:45 <Saizan> "loop writer" looks like a nice profession
22:03:46 <wioux> Traveler9: well you're quite new to the language. pretty soon you can grasp the syntax, and then its on to type errors!
22:04:09 <geheimdienst> > map (+2) [1..5]
22:04:10 <lambdabot>   [3,4,5,6,7]
22:04:15 <applicative> Saizan, maybe, I was thinking it's for compiler writers to arrange
22:04:23 <Makoryu> Traveler9: Have you heard the aphorism "Code is data, and data is code"?
22:04:37 <applicative> > foldr (+) 0 [1..10]
22:04:38 <lambdabot>   55
22:04:41 <geheimdienst> that would be something like "for (i = 1; i <= 5; i++) print i + 2" in another langauge
22:04:45 <applicative> > scanr (+) 0 [1..10]
22:04:45 <lambdabot>   [55,54,52,49,45,40,34,27,19,10,0]
22:04:47 <geheimdienst> *language
22:05:05 <etpace> Traveler9: why are you typing in red
22:05:15 <kmc> code is data only rarely in haskell
22:05:18 <kmc> functions are data commonly
22:05:28 * applicative thought it was because he was from outer space.
22:05:40 <Saizan> true, we write too little interpreters lately
22:05:43 <Makoryu> kmc: Well yes
22:05:47 <Saizan> *few
22:06:21 <Traveler9> 04I type in red so I can see my posts easily.
22:06:28 <wioux> Traveler9: on syntax.. you've apparently had some training in mathematics. much of Haskell's syntax is mathematical
22:06:46 <etpace> it's quite distracting
22:06:58 <kmc> perhaps your client could be configured thus
22:07:02 <kmc> without sending it to everyone
22:07:07 <geheimdienst> (not just the syntax is mathematical, also the names for things)
22:07:07 <Traveler9> 04Hmm..
22:07:12 * applicative thinks it wrong that only his thoughts appear in purple, not his statements.
22:07:20 <Traveler9> 03Hmm..
22:07:37 <Traveler9> 03No, this is the same as the entry font..
22:07:38 <applicative> green, nice
22:07:46 * geheimdienst thinks, therefore he is purple
22:07:46 <Traveler9> 12Blue.
22:07:47 <Makoryu> tRAVELER9, i WOULD RECOMMEND, uHHH, tHAT YOU USE, uHH, iNVERSE CAPS,
22:07:49 <heatsink> Traveler9: Try interacting with lambdabot
22:07:57 <Makoryu> oR, uHH, nO I WOULDN'T ACTUALLY,
22:07:57 <heatsink> @quote
22:07:58 <lambdabot> kyevan says: I had a haskell-related dream last night. Sorta. I was beaten up by some kids because I tried to go somewhere my type didn't match, apparently.
22:07:59 <Traveler9> 12Lambdabot?
22:08:04 <applicative> > 1 + 1
22:08:04 <Makoryu> > 2 + 2
22:08:05 <lambdabot>   2
22:08:06 <lambdabot>   4
22:08:23 <geheimdienst> > [1..4]
22:08:25 <lambdabot>   [1,2,3,4]
22:08:28 <Traveler9> 122 + 7
22:08:32 <kmc> > fix ((0:) . scanl (+) 1)
22:08:33 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:08:38 <wioux> > let x = 2; y=3 in x*y
22:08:39 <lambdabot>   6
22:08:56 <geheimdienst> kmc, an excellent example for beginners
22:08:59 <kmc> ;P
22:09:07 <Traveler9> 12The fibonacci sequence?
22:09:18 <wioux> > let n = [1,2..] in [x^2 | x <- n]
22:09:18 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
22:09:21 <dancor> Traveler9: you need a '>' at the beginning
22:09:30 <Makoryu> > "Yes, Traveler9"
22:09:31 <fryguybob> @oeis 0,1,1,2,3,5,8,13
22:09:31 <lambdabot>   "Yes, Traveler9"
22:09:32 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
22:09:33 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:09:39 <Traveler9> 12> 2 + 7
22:09:49 <dancor> > "denied!"
22:09:50 <lambdabot>   "denied!"
22:09:58 <applicative> > scanr (:) [] [1..10]
22:09:59 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
22:10:05 <applicative> > > scanr (+) 0 [1..10]
22:10:06 <lambdabot>   <no location info>: parse error on input `>'
22:10:10 <dancor> does not fempute
22:10:11 <applicative> > scanr (+) 0 [1..10]
22:10:12 <lambdabot>   [55,54,52,49,45,40,34,27,19,10,0]
22:10:25 <Traveler9> 12I get a syntax error. Nice.
22:10:38 <Traveler9> 12> 101 * 709
22:10:43 <geheimdienst> traveler9, i guess you need to turn off the color if you want to talk to lambdabot. the color stuff is confusing her. (and yes, she's a she)
22:10:53 <Traveler9> Okay
22:10:56 <Makoryu> Yep
22:10:59 <applicative> you didn't get a syntax error, did you?  that was me...
22:11:04 <Traveler9> Back to default in that case.
22:11:14 <applicative> i see, she doesn't hear you....
22:11:14 <fryguybob> @vixen Do you like color?
22:11:15 <lambdabot> i'd say i like
22:11:19 <Traveler9> > 101 * 709
22:11:20 <lambdabot>   71609
22:11:25 <Traveler9> Yay~
22:11:29 <Makoryu> geheimdienst: I guess that's a good deterrent for having people use colors in here
22:11:41 <heatsink> Colors are distracting.
22:11:55 <Traveler9> > 709^20 = Amount of cash Traveler9 has
22:11:56 <lambdabot>   <no location info>: parse error on input `='
22:12:03 <wioux> >let x=y^2 where y=2 in sqrt x
22:12:05 <Traveler9> ... :(
22:12:16 <applicative> Traveler9, you can have a private conversation with her, as someone said, I think
22:12:34 <Traveler9> How is it a "she"? It's a bot.
22:12:56 <wioux> > "I live!"
22:12:57 <lambdabot>   "I live!"
22:12:58 <Makoryu> Yeah I almost asked that
22:13:01 <kfish> Traveler9, http://www.haskell.org/haskellwiki/Lambdabot
22:13:36 <Traveler9> Ah, I see.
22:13:38 * geheimdienst pats lambdabot on the head. "don't listen to the mean man. you don't have to cry. we all know you're a she."
22:13:40 <wioux> boats, guitars, theorems.. all beautiful creations are shes
22:13:58 <applicative> > let theAmountOfCash = 709^20 in  theAmountOfCash `div` 2
22:13:59 <lambdabot>   515103745734590492941604944254900450482520675896995637400
22:14:21 <mm_freak_> > 709^20 `div` 2
22:14:22 <lambdabot>   515103745734590492941604944254900450482520675896995637400
22:14:27 <wioux> Traveler9: get GHCi and fool around
22:14:27 <kmc> @vixen what is your name?
22:14:28 <lambdabot> My name is Emily
22:14:36 <geheimdienst> > 709^20
22:14:38 <lambdabot>   1030207491469180985883209888509800900965041351793991274801
22:14:38 <Traveler9> Okay.
22:15:03 <kmc> you can also private-message lambdabot
22:15:05 <applicative> @vixen are you american?
22:15:05 <lambdabot> i truely am
22:15:07 <mm_freak_> bots have feelings, too
22:15:08 <kfish> Traveler9, http://tryhaskell.org/
22:15:13 <mm_freak_> @botsnack
22:15:13 <lambdabot> :)
22:15:15 <applicative> @vixen are you polish?
22:15:15 <lambdabot> yes, i am
22:15:36 <applicative> @vixen are you slovenian and chinese?
22:15:36 <lambdabot> i truely am
22:16:03 <wioux> @vixen are you lonely?
22:16:03 <lambdabot> i truely am
22:16:15 <geheimdienst> @vixen are you a little confused as to your nationality?
22:16:16 <lambdabot> i'm half white, half mexican
22:16:20 <humasect> how may i persist statements across :reload or :load in ghci ?
22:16:28 <kmc> humasect, put them in a file
22:16:34 <kmc> or run them again from your history
22:16:44 <humasect> hmm
22:16:50 <heatsink> @vixen are young birds airworthy?
22:16:51 <lambdabot> nevermind about that
22:17:08 <ezyang> Ooh, new Oleg articles. 
22:17:11 * ezyang goes off to read 
22:17:37 <Traveler9> Hmm.
22:17:39 <humasect> is there a shortcut to reload the .ghci ?
22:18:31 <tensorpudding> my parser seems to need some backtracking
22:18:32 <applicative> ezyang, what are they about?  I think he will be the end of me.  And maybe, that what does not kill me makes me stronger. 
22:18:45 <ezyang> Oh, you're in luck. 
22:18:51 <ezyang> He talks about making you translucent :-) 
22:19:07 <tensorpudding> how can i do backtracking with parsec?
22:19:14 <heatsink> tensorpudding: try
22:19:17 <ezyang> The three new articles are: http://okmij.org/ftp/ML/ML.html#memo http://okmij.org/ftp/Haskell/types.html#fibration and http://okmij.org/ftp/Haskell/types.html#translucent-functor 
22:19:50 <ezyang> (as in the function, not truncated message :-) 
22:19:56 <tensorpudding> I just found try
22:20:00 <tensorpudding> it's giving errors though
22:20:23 <tensorpudding> i've got a rather prodigious array of <|>'s, and the first several need to backtrack
22:20:40 <applicative> oh, i see oleg has an rss.  ...
22:20:45 <heatsink> tensorpudding: Generally, you want to try each LHS of a <|>
22:21:01 <heatsink> try (...) <|> try (...) <|> (...)
22:21:01 <ezyang> Yup! 
22:21:08 <tensorpudding> ah never mind
22:21:13 <tensorpudding> i was omitting parens
22:22:45 <Traveler9> So, in general, functions are defined as: "let x = value in f(x)" or "let f(x) = value in x"?
22:22:54 <ezyang> "syntactically starved" what an image :-) 
22:23:07 <geheimdienst> "Different instantiations of the functor with respect to type-compatible arguments are type-compatible"
22:23:12 <tensorpudding> in real code, you would write f x = something
22:23:15 <geheimdienst> type-compatible cat is type-compatible
22:23:34 <applicative> "Thus we demonstrate that Haskell already has a higher-order module language. No new extensions are required; furthermore, we avoid even undecidable let alone overlapping instances."
22:23:55 <Traveler9> Ex: "Let x = 3 in x^3"?
22:24:11 <Traveler9> And that would give 27?
22:24:12 <applicative> It would be more pleasant to learn the Haskell 98 already had higher order modules... 
22:24:15 <geheimdienst> very mathematical. he's not "inventing" or "programming" solutions, he's just "discovering" them
22:24:23 <kmc> Traveler9, functions can be defined at top level as "f x = ...", or locally with "let f x = ... in ...", or anonymously with lambda
22:24:42 <ezyang> I think this set of articles is several months early for me. 
22:25:07 <applicative> ezyang, unlike the ones from several years ago?
22:25:35 <kmc> Traveler9, the syntax is f x, not f(x)
22:25:46 <kmc> anyway a tutorial should cover this
22:25:52 <Traveler9> "very mathematical. he's not "inventing" or "programming" solutions, he's just "discovering" them " <-- Childishly expecting me to be an expert in under 1 hour = Priceless. 
22:25:56 <ezyang> applicative: There is a nontrivial subset of Oleg articles I understand, but the difficulty is finding them :-) 
22:26:09 <kmc> Traveler9, i think that comment wasn't about you
22:26:20 <Traveler9> It seemed like it. 
22:26:27 <applicative> Was it about Oleg? 
22:26:35 <ezyang> That was how I interpreted it. 
22:26:48 <applicative> I
22:26:54 <geheimdienst> traveler9, no i meant what applicative said about oleg :-)
22:27:24 <mm_freak_> Traveler9: even if it were, haskell is a language, where you often "discover" things =)
22:27:47 <mm_freak_> and then find that you have reinvented the wheel for a long time
22:28:10 <mm_freak_> so i wouldn't even take it as an offense =)
22:28:57 <applicative> It would help with reading him to know a ton of ML  Lisp Scheme  Prolog ... and the other sorts of languages which shall remain nameless.
22:29:35 <mm_freak_> oleg loves to discover practical solutions for the 2020 programmer
22:29:47 <geheimdienst> like "System F-omega" or "Dreyer-Crary-Harper"
22:29:51 <kmc> 10 years seems awfully optimistic
22:30:01 <applicative> I saw an amazing remark about ($) somewhere the other day by him.   Where was it?
22:30:03 <kmc> given that first class functions are just now sort of catching on
22:30:06 <geheimdienst> seriously. what kinda name for a language is Dreyer-Crary-Harper?
22:30:32 <mm_freak_> kmc: the 2020 haskell programmer and the 2050 average programmer =)
22:31:00 <geheimdienst> *if* you can ever convince anyone that this stuff is usefull
22:31:15 <ezyang> kmc: Heh. 
22:31:30 <humasect> @src withSocketsDo
22:31:30 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:31:45 <ezyang> geheimdienst: I think a fascinating exercise would be to catalog all of the Oleg work 
22:31:46 <SevenInchBread> humasect:  most powerful function in Haskell.  IO a -> Io a
22:31:48 <SevenInchBread> *IO
22:31:54 <heatsink> IQs are going up by about 1.5 points per decade, so maybe in two centuries...
22:31:55 <humasect> hehe
22:32:14 <ezyang> Figure out what fundamentals you need, and then do a purpose-directed reference manual for everything else. 
22:33:06 <geheimdienst> "hey, my cool new translucent monoidal allegory allows me to transmogrify hylomorphisms with an ease never before seen!" o rly. that's nice. why don't you put it on the interweb and lemme get back to hacking my xmonad
22:34:47 <ezyang> translucent applicative functors are not Oleg's invention... 
22:34:52 <mm_freak_> humasect: withSocketsDo looks something like this:  if runningWindows then bracket_ initWSA stopWSA f else f
22:35:04 <humasect> ahhh
22:35:09 <humasect> thank you, i see
22:35:10 <kmc> if runningWindows then unnecessaryBoringWindowsBullshit else id
22:35:11 <mm_freak_> humasect: i.e. if running a complicated OS, do the complicated stuff it expects, otherwise just do nothing =)
22:35:16 <humasect> hehe
22:35:24 <heatsink> heh
22:35:25 <ezyang> However, he appears to have popularized it. 
22:35:26 <humasect> so it may not matter how often it appears ?
22:35:35 <mm_freak_> humasect: it probably does
22:35:44 <mm_freak_> humasect: i generally do this:  main = withSocketsDo $ do …
22:35:58 <humasect> hmm. yeah, k - for ghci development i will ignore it=)
22:36:13 <mm_freak_> yes, that's safe =)
22:36:22 <humasect> =)
22:36:28 <mm_freak_> at least if you work on linux
22:36:44 <mm_freak_> and you can have multiple withSocketsDo calls, too
22:36:49 <mm_freak_> but they shouldn't be nested
22:37:13 <wioux> is there any info about on Haskell demographics? .. i'm wondering what proportion have backgrounds in math (proper)?
22:37:19 <humasect> k. i will stuff it in main to be safe
22:37:24 <mm_freak_> > fix withSocketsDo
22:37:25 <lambdabot>   Not in scope: `withSocketsDo'
22:38:00 <mm_freak_> (don't try this in GHCi!)
22:38:14 <dark> should I install ghc 6.10 or 6.12? i'm with 6.8, and trying to follow this, http://www.haskell.org/haskellwiki/Gentoo/HaskellPlatform
22:38:28 <dark> (well #gentoo-haskell is a bit idle)
22:38:53 <mm_freak_> dark: in gentoo, i would just use the haskell overlay
22:39:03 <humasect> :t fix
22:39:04 <lambdabot> forall a. (a -> a) -> a
22:39:23 <dark> mm_freak_, hmm
22:39:46 <dark> mm_freak_, I'm having dependency conflicts as well .-.
22:41:02 <applicative> I found oleg on the difference between f $ x and f x -- vulgarly assimilated by #haskell types.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28501#a28501
22:41:49 <wioux> > fix (^2)
22:41:53 <lambdabot>   mueval-core: Time limit exceeded
22:42:15 <mm_freak_> > fix (1:)
22:42:16 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:46:08 <humasect> hmm, happstack looks nice!
22:46:16 <humasect> @src fix
22:46:17 <lambdabot> fix f = let x = f x in x
22:46:30 <lispy> > foldl (+) 0 [1..5] :: Expr
22:46:31 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5
22:46:45 <lispy> > foldl f z [a,b,c,d] :: Expr
22:46:46 <lambdabot>   f (f (f (f z a) b) c) d
22:47:00 <applicative> > scanl (+) 0 [1,2,3] :: Expr
22:47:01 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
22:47:01 <lambdabot>         against inferred ...
22:47:05 <applicative> ah well
22:47:27 <mm_freak_> @let ($$) = app
22:47:28 <lambdabot>  Defined.
22:47:38 <applicative> @src app
22:47:39 <lambdabot> Source not found. You untyped fool!
22:47:43 <mm_freak_> :t app
22:47:44 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
22:48:00 <Makoryu> :t app
22:48:01 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
22:48:02 <Makoryu> Agh
22:48:03 <humasect> > app :: Expr
22:48:04 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
22:48:04 <lambdabot>         against inferred ...
22:48:13 <Makoryu> :info ArrowApply
22:48:18 <Makoryu> Oh well
22:48:24 <applicative> > ($) :: Expr -- seems no more likely
22:48:26 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
22:48:26 <lambdabot>         against inferred ...
22:48:30 <mm_freak_> hmm
22:48:52 <mm_freak_> there should be a more general 'app'
22:49:18 <mm_freak_> or a less general one
22:49:50 <mm_freak_> but i guess that's not really possible
22:50:23 <mm_freak_> 'curry app' only unifies with the function arrow, so i guess you can't generalize ($) in terms of arrows
22:50:27 <applicative> It would be nice if one could exhibit scanl with this annoying SimpleReflect.Expr, it would be like an image of a foldl and iteratees and so on as a process.
22:51:06 <c_wraith> > scanl f 1 [2, 3, 4, 5, 6]
22:51:07 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:51:07 <lambdabot>    `GHC.Num.Num a'
22:51:07 <lambdabot>      ari...
22:51:13 <c_wraith> > scanl f 1 [2, 3, 4, 5, 6] :: [Expr]
22:51:14 <lambdabot>   [1,f 1 2,f (f 1 2) 3,f (f (f 1 2) 3) 4,f (f (f (f 1 2) 3) 4) 5,f (f (f (f (...
22:52:25 <mm_freak_> but…
22:52:34 <mm_freak_> @let ($$) = id
22:52:35 <lambdabot>  <local>:4:0:
22:52:35 <lambdabot>      Multiple declarations of `L.$$'
22:52:35 <lambdabot>      Declared at: <local>:...
22:52:40 <mm_freak_> @undef
22:52:56 <mm_freak_> > let ($$) = id in (^2) $ 5
22:52:57 <lambdabot>   25
22:53:06 <mm_freak_> i think that's the most general ($) you can get =)
22:53:33 <mm_freak_> uhm
22:53:35 <mm_freak_> > let ($$) = id in (^2) $$ 5
22:53:36 <lambdabot>   25
22:56:43 <applicative> how does that work?  
22:57:19 <mm_freak_> f $$ x = ($$) f x = id f x = (id f) x = f x
22:57:20 <applicative> > scanl (++) "" (map (:[]) "Long document...")
22:57:21 <lambdabot>   ["","L","Lo","Lon","Long","Long ","Long d","Long do","Long doc","Long docu"...
22:58:04 <mm_freak_> > scanr (:) [] "Long document"
22:58:05 <lambdabot>   ["Long document","ong document","ng document","g document"," document","doc...
22:58:14 <applicative> hmm
22:58:26 <geheimdienst> > map (:[]) "Long"
22:58:27 <lambdabot>   ["L","o","n","g"]
22:58:44 <mm_freak_> yeah, now put (++) between those
22:58:50 <mm_freak_> and scan the fold
23:01:08 <applicative> scanr and scanl just seemed like typical utilities til I the curse of iteratees fell upon me. 
23:01:26 <c_wraith> scanr still confuses me
23:01:29 <NemesisD> hi all. i'm currently reading through (and somewhat struggling with) real world haskell. i have read that its often helpful to look at the source of well-designed programs in a language when trying to learn it. anyone know of some source i could look at that isn't likely to blow my mind?
23:01:51 <c_wraith> I know what scanr does.  I don't know when I'd ever use it
23:01:51 <applicative> hm, NemesisD, what are you interested in?
23:02:16 <NemesisD> applicative: by day i design web applications in ruby if that is helpful
23:02:20 <mm_freak_> c_wraith: likely never
23:02:26 <NemesisD> unixy utils are interesting to me too
23:02:39 <mm_freak_> in fact i can't think of any use for scanr besides tails
23:03:09 <applicative> > reverse $ scanr (:) [] "Hello World"
23:03:10 <lambdabot>   ["","d","ld","rld","orld","World"," World","o World","lo World","llo World"...
23:03:32 <applicative> here we see the foldr gnawing at the list from the end.
23:03:55 <mm_freak_> well, honestly i'd implement 'tails' and 'inits' using 'iterate'
23:04:02 <wioux> NemesisD: maybe some of the packages on Hackage
23:04:11 <applicative> I like scanr and scanl for their own sakes. 
23:04:13 <mm_freak_> > takeWhile (not . null) . iterate head $ "Long document"
23:04:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
23:04:26 <mm_freak_> d'oh
23:04:28 <mm_freak_> > takeWhile (not . null) . iterate tail $ "Long document"
23:04:28 <applicative> Like the way jdh30 likes hash tables
23:04:29 <lambdabot>   ["Long document","ong document","ng document","g document"," document","doc...
23:04:54 <mm_freak_> (though that's not exactly the same)
23:05:04 <applicative> hmm, NemesisD, people might come to blows over what is a lovely sensible application.  
23:05:17 <applicative> NemesisD, I like pandoc, since I use it all the time. 
23:05:28 <NemesisD> hmm ok
23:05:52 <mm_freak_> NemesisD: i wouldn't stard reading too much code right away…  haskell is a powerful language and its base libraries provide powerful combinator schemes, which might blow your mind
23:05:57 <NemesisD> ive found haskell to be really hard to pick up by osmosis. you should have seen how much trouble i had just configuring xmonad
23:05:58 <mm_freak_> but you can start with simple applications
23:06:02 <applicative> NemesisD, it has a characteristic use of Parsec parsing, and at the core of it a module Definition where... that defines a "Document"
23:06:20 <mm_freak_> in fact, once you know the syntax and how to read type signatures, you can write applications, because the language itself is very simple
23:06:20 <Saizan> NemesisD: you could try xmonad's source :)
23:06:26 <applicative> so it illustrates a certain kind of straightforward 'real world' employment of the typesystem
23:06:39 <NemesisD> lol something tells me if i don't understand my xmonad.hs i might have trouble with xmonad's source :P
23:06:45 <geheimdienst> nemesisd, the way i got into haskell was exactly that, tinkering with my xmonad.hs in bigger and bigger steps
23:06:53 <applicative> indeed, Xmonad, perhaps with the illustrative remarks of SPJ in the video.  Where is that?
23:06:54 <NemesisD> i guess i should just invent a problem that i can solve with haskell
23:07:10 <mm_freak_> NemesisD: write a 'cat' program
23:07:19 <Saizan> well, the guts my simplify understanding
23:07:20 <mm_freak_> it's simple and has a huge learning factor =)
23:07:31 <geheimdienst> is there any specific syntax from your xmonad.hs you don't understand?
23:07:49 <applicative> echo is good   main = interact id ?
23:08:15 <NemesisD> geheimdienst: one of the things i find challenging is that there are so many operators that ive never seen before and aren't immediately obvious
23:08:17 <mm_freak_> applicative: that's not echo
23:08:33 <mm_freak_> main = unwords <$> getArgs
23:08:41 <NemesisD> seemingly random combinations of <,>,/,=,$,. etc
23:09:03 <mm_freak_> NemesisD: don't worry about them too much…  there are words for most of them, too =)
23:09:16 <mm_freak_> NemesisD: for example "f <$> c" can be written is "fmap f c"
23:09:20 <applicative> mm_freak_, cant I write   $ myecho hahahahah | pandoc -r markdown -w html   
23:09:28 <geheimdienst> nemesisd, that's very true. i think they're often overdoing it, especially in the manageHook department ...
23:09:51 <mm_freak_> applicative: the "hahahahah" is a command line argument, not stdin =)
23:10:00 <mm_freak_> so you need getArgs
23:10:06 <applicative> damn, of course'
23:10:27 <applicative> your right, i can use it as id between pipes,...
23:10:36 <geheimdienst> you can use hayoo to look up any function or operator you're unfamiliar with: http://holumbus.fh-wedel.de/hayoo/hayoo.html
23:10:45 <mm_freak_> applicative: you've written a simplified version of cat, which doesn't support files
23:10:50 <applicative> my kind of function    realecho hahahaha | myecho | pandoc ...
23:11:04 <mm_freak_> sort of a command line 'id' =)
23:11:59 <Saizan> i always find the objection to operators quite weird, maybe i underestimate the extent to which you can guess at what a function should do by its name
23:12:30 <Saizan> in both cases you've the type to help, though
23:12:38 <mm_freak_> Saizan: unfortunately i don't think that 'fmap' is very intelligible
23:12:39 <applicative> NemesisD, keep in mind that all the potentially obnoxious <$> \'s >>='s >=>'s and so forth are just defined terms like "square" or "even"
23:12:42 <mm_freak_> 'map' would be better
23:13:09 <applicative> fmap is the whole justification for haskell
23:13:12 <NemesisD> applicative: yeah im from ruby. i like using words :)
23:13:28 <Saizan> but even map could be quite a few things, until you look it up
23:13:30 <wioux> Saizan: Haskell operators, in particular, were very disruptive to me as a newbie
23:13:37 <mm_freak_> NemesisD: haskell uses combinators a lot…  those are functions manipulating functions
23:13:46 <applicative> you can replace them in every case
23:13:51 <mm_freak_> NemesisD: and often they are much more convenient in infix operator style
23:14:03 <mm_freak_> that's why there are operator names for many combinator functions
23:14:37 <NemesisD> i can see that being convenient
23:14:39 <Saizan> wioux: do you have a clear explanation of why?
23:14:43 <mm_freak_> > sin <$> [0, pi/2, pi]
23:14:44 <lambdabot>   [0.0,1.0,1.2246467991473532e-16]
23:15:15 <mm_freak_> but in this case, fmap is fine as well =)
23:15:20 <mm_freak_> > fmap sin [0, pi/2, pi]
23:15:21 <lambdabot>   [0.0,1.0,1.2246467991473532e-16]
23:15:21 <geheimdienst> "+" and "doSomething" are both functions. the only special thing about + is that when a function name contains no letters and numbers, it's by default treated as infix
23:15:39 <geheimdienst> so you write doSomething 3 4 but not "+ 3 4", rather 3 + 4 
23:15:52 <kmc> but you can write (+) 3 4, or 3 `doSomething` 4
23:15:53 <mm_freak_> and of course, the two styles are interchangable
23:15:58 <applicative> > let op >< y = foldl op y in ((+) >< 0 ) [1..5]
23:15:59 <mm_freak_> > (+) 3 4
23:15:59 <lambdabot>   15
23:15:59 <lambdabot>   7
23:16:01 <geheimdienst> yes, but don't confuse him
23:16:03 <humasect> @src fmap
23:16:03 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:16:04 <humasect> =)
23:16:06 <mm_freak_> > "abc" `concat` "def"
23:16:07 <lambdabot>   Couldn't match expected type `[a]'
23:16:08 <lambdabot>         against inferred type `GHC.Types...
23:16:12 <mm_freak_> uhm
23:16:36 <geheimdienst> mm_freak_, concat doesn't take two lists
23:16:40 <mm_freak_> yes, i know
23:16:46 <geheimdienst> ;-)
23:16:52 <mm_freak_> @let concatTwoLists = (++)
23:16:53 <lambdabot>  Defined.
23:16:57 <mm_freak_> > "abc" `concatTwoLists` "def"
23:16:58 <lambdabot>   "abcdef"
23:17:01 <wioux> Saizan: there are too many operators to possibly keep track of. without knowing the resources, many are hard to lookup (e.g. </> - can't google that), and to someone from a foreign language it wasn't clear for some time just how to recognize something as an operator as opposed to language construct
23:17:02 <mm_freak_> there you go =P
23:17:03 <applicative> > let doSomething = (+) in 1 `doSomething` 2
23:17:04 <lambdabot>   3
23:17:13 <mm_freak_> > let 2 + 2 = 5 in 2 + 2
23:17:13 <lambdabot>   5
23:17:17 <geheimdienst> a quite badass function, mm_freak_
23:17:29 <humasect> > "abc" `concatTwoLists` "def" `concatTwoLists` "ghi"
23:17:30 <lambdabot>   "abcdefghi"
23:17:35 <mm_freak_> geheimdienst: which one?
23:17:46 <geheimdienst> concatTwoLists
23:18:01 <mm_freak_> well, i could have used mappend, too
23:18:30 <Saizan> wioux: ok, but the first point applies equally well to functions from the standard lib, no?
23:18:40 <geheimdienst> wioux, you can use hayoo, it finds operators. it's also handy for answering: are there any functions that fulfill this type signature?
23:18:46 <mm_freak_> wioux: i think, perl is worse, and nobody complains about that one
23:19:14 <kmc> what, nobody complains about perl?
23:19:14 <wioux> mm_freak: many complain about perl :P
23:19:32 <Saizan> @hoogle </>
23:19:32 <lambdabot> Text.Html (</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
23:19:32 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
23:19:32 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
23:19:33 <applicative> wioux, i just hoogle'd (</>) from my editor, 
23:19:35 <applicative> right
23:19:44 <wioux> saizan: true
23:19:47 <applicative> install a local hoogle
23:19:48 <kmc> you can also use ghci's :i
23:19:53 <kmc> or ghc -ddump-minimal-imports
23:19:55 <wioux> as i said, *before knowing about the resources* (like hoogle)
23:19:57 <kmc> to see what module an operator comes from
23:20:10 <humasect> hmm i see inline <div> and suchlike with happstack, how wonderful!
23:20:26 <geheimdienst> mm_freak_, but for perl it's a matter of looking at the "perlop" page to get all the operators. in haskell, you have everyone and their grandma coming up with them. "quick, tell me what --> from XMonad.Hooks.ManageDocks does", etc.
23:20:38 <mm_freak_> wioux: well, there is a certain pattern for the operators used in haskell
23:20:49 <mm_freak_> once you get it, you can even guess what an operator does
23:20:57 <kmc> i would look at the haddock for XMonad.Hooks.ManageDocks
23:20:57 <mm_freak_> particularly if given context, i.e. arguments to apply it to
23:21:44 <mm_freak_> geheimdienst: i'm not having this problem, but i don't read code from others too often either
23:21:48 <wioux> mm_freak_: beginning to pick that up
23:23:00 <mm_freak_> wioux: operators surrounded by angle brackets are usually related to applicative functor stuff
23:23:34 <mm_freak_> knowing that there aren't many ways to interpret:  (+) <$> [1] <*> [2,3]
23:23:41 <applicative> wioux, and there they have a special justification, you want 'punctuation' in order to get the associated point of view
23:25:46 <wioux> one that took a while to figure out, and then turned out not even to be an operator, is @
23:25:48 <applicative> > 1 + 1
23:25:49 <lambdabot>   2
23:26:24 <applicative> wioux, yes @ is gross.  I hate it.  
23:26:31 <humasect> how coem ?
23:26:41 <applicative> i can't believe i got used to $
23:27:13 <mm_freak_> a common pattern for me:  h . g . f $ x
23:27:30 <wioux> i still don't know what ! means in a data declaration.. e.g. data Blah = Bloo !Int !String
23:27:36 <applicative> ....one of the ways you get used to it...
23:27:40 <mm_freak_> wioux: strictness
23:27:52 <humasect> i also say "?" used in types
23:28:01 <kmc> means that if you evaluate a Blah to whnf, you also evaluate its fields to whnf
23:28:11 <mm_freak_> wioux: given your definition of Blah, Bloo undefined undefined = undefined
23:28:39 <mm_freak_> without that ! prefix, Bloo undefined undefined can be distinguished from undefined
23:28:47 <wioux> ah.. whereas Bloo undefined undefined is not an error if its non-strict (until you access those fields)?
23:28:48 <applicative> those things are ugly, but they have their purpose... beautiful whitespace can only take you so far...
23:28:58 <mm_freak_> wioux: neither is an error
23:29:16 <wioux> oh..hm
23:29:29 <mm_freak_> wioux: it's just a semantic difference, and in some cases also a performance difference
23:29:45 <wioux> > Just undefined
23:29:46 <lambdabot>   Just *Exception: Prelude.undefined
23:29:50 <mm_freak_> the following makes sense:  data Point a = Point2D !a !a
23:30:18 <mm_freak_> but the following doesn't make much sense:  data List a = Nil | Cons a !(List a)
23:30:26 <mm_freak_> this effectively prevents lists from being infinite
23:30:40 <wioux> ah
23:30:42 <kmc> why don't spine-strict lists make sense?
23:30:53 <mm_freak_> well, they make sense
23:31:02 <mm_freak_> but they can't be infinite =)
23:33:30 <wioux> how is it not an error if its evaluation crashes the program?
23:33:39 <wioux> undefined that is
23:34:03 <humasect> nonexhaustive pattern? =)
23:34:06 <kmc> it's not an error to name the value, only to evaluate it
23:34:48 <mm_freak_> even that is not an error
23:34:48 <applicative> > fst <$> (  Just (,) <*> Just 1 <*> Just undefined) 
23:34:49 <lambdabot>   Just 1
23:34:54 <mm_freak_> List [Int]
23:35:26 <wioux> > fst (1, undefined) + snd (undefined, -1)
23:35:27 <lambdabot>   0
23:36:04 <humasect> > undefined
23:36:05 <lambdabot>   *Exception: Prelude.undefined
23:36:11 <wioux> so..
23:36:14 <wioux> > Just undefined
23:36:15 <lambdabot>   Just *Exception: Prelude.undefined
23:36:18 <humasect> ahh
23:36:19 <applicative> @type undefined
23:36:20 <lambdabot> forall a. a
23:36:23 <wioux> that's only an exception because its trying to show?
23:36:34 <humasect> > data Maybe2 = Nothing2 | !(Just2 a)
23:36:34 <lambdabot>   <no location info>: parse error on input `data'
23:36:38 <applicative> @type error -- it's so sublime!
23:36:39 <lambdabot> forall a. [Char] -> a
23:36:53 <kmc> > case Just undefined of Just _ -> ()
23:36:54 <lambdabot>   ()
23:37:00 <kmc> > fix error
23:37:01 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
23:37:03 <wioux> k
23:37:10 <humasect> heh
23:37:18 <geheimdienst> @src fix
23:37:18 <applicative> > fix undefined
23:37:19 <lambdabot> fix f = let x = f x in x
23:37:19 <lambdabot>   *Exception: Prelude.undefined
23:37:20 <wioux> aah
23:37:31 <wioux> > case Just undefined of Just a -> ()
23:37:31 <lambdabot>   ()
23:37:46 <wioux> i see..
23:37:52 <geheimdienst> > fix (+) 3 4
23:37:53 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
23:38:00 <kmc> > undefined `seq` ()
23:38:01 <geheimdienst> > fix (+)
23:38:01 <lambdabot>   *Exception: Prelude.undefined
23:38:02 <mm_freak_> wioux: i recommend reading about the denotational semantics in haskell
23:38:02 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
23:38:03 <kmc> > Just undefined `seq` ()
23:38:04 <lambdabot>   ()
23:38:09 <mm_freak_> wioux: it's really useful to know
23:38:30 <mm_freak_> wioux: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
23:38:54 <wioux> gotcha, thanks
23:39:15 <geheimdienst> > fix concat
23:39:17 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
23:39:38 <wioux> yeah because i'm still a little wary of writing something like x = f x on my own..
23:40:02 <geheimdienst> > fix (1+)
23:40:06 <lambdabot>   mueval-core: Time limit exceeded
23:40:14 <mm_freak_> > fix (\r x y -> x : r y (x+y)) 0 1
23:40:15 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:40:20 <humasect> hm i still dont understand fix=)
23:40:22 <humasect> @src fix
23:40:22 <lambdabot> fix f = let x = f x in x
23:40:26 <geheimdienst> i don't get it. what is fix and what is it good for? the haddock has no examples
23:40:33 <kmc> fix is used for anonymous recursion
23:40:38 <kmc> everyone loves factorial, right?
23:40:48 <kmc> > let fact 0 = 1; fact n = n * fact (n-1) in fact 5
23:40:49 <lambdabot>   120
23:40:52 <kmc> that's named recursion, no fix
23:40:58 <geheimdienst> got you
23:41:07 <kmc> > let fact self 0 = 1; fact self n = n * self (n-1) in (fix fact) 5
23:41:08 <lambdabot>   120
23:41:14 <mm_freak_> if fix is given a function of a function, then it passes that function itself as its first parameter
23:41:24 <kmc> that's anon recursion, fact doesn't call itself, only calls this argument it gets, "self"
23:41:25 <mm_freak_> that way you can make implicit (or anonymous) recursion
23:41:32 <kmc> "fix" arranges that self = fact
23:41:48 <Saizan> self = fact self, actually :)
23:41:51 <humasect> > 1 (fix (+)) 5
23:41:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
23:41:53 <kmc> right
23:42:00 <kmc> hence the definition x = f x
23:42:28 <Saizan> ?google you could have invented fix too
23:42:29 <lambdabot> No Result Found.
23:42:42 <kmc> it is slightly confusing that some of the clever uses of fix in Haskell involve recursive things that aren't functions
23:42:46 <kmc> > fix ('x':)
23:42:47 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
23:42:47 <wioux> > (fix (+)) 1
23:42:48 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
23:42:51 <kmc> > fix ((0:) . scanl (+) 1)
23:42:52 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:42:54 <mm_freak_> you can define fix this way, which shows the recursion pattern a bit more clearly:
23:43:02 <mm_freak_> fix f = f (fix f)
23:43:29 <kmc> i think the "let" version is more efficient, though
23:43:30 <NemesisD> did one of you guys write learnyouahaskell?
23:43:35 <kmc> BONUS did
23:43:47 <kmc> btw http://www.willamette.edu/~fruehr/haskell/evolution.html is fun :)
23:44:11 <mm_freak_> kmc: i don't see why…  the pattern should already make it sharing
23:44:27 <mm_freak_> but i guess there is a performance gain for the last invocation, if there is any
23:44:53 <NemesisD> i recently heard of learnyousomeerlang, any relation?
23:46:46 <wioux> :t scanl
23:46:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
23:51:14 <Saizan> "learn you some erlang" is a bit too grammatically correct
23:55:38 <unlink> I prefer fib n = floor $ (phi ** n - (-phi) ** (-n)) / sqrt 5 where phi = (1 + sqrt 5) / 2
23:56:29 <JHaskly> No more correct than "learn you a haskell"
23:57:12 <geheimdienst> is the title at least put on a cat picture?
23:57:54 <mm_freak_> unlink: there are a few problems with that formula
23:58:44 <mm_freak_> firstly it's floating, so it loses precision with larger numbers
23:59:12 <mm_freak_> secondly if you need the whole sequence instead of a certain number the iterative version is faster
