00:57:29 <mreh> blub
01:15:15 <Jonno_FTW> is the comparison of 2 strings as fast as 2 integers?
01:16:02 <c_wraith> Jonno_FTW, that seems exceptionally unlikely, regardless of optimizations
01:18:11 <Jonno_FTW> concat $  zipWith (\(x,y)-> (show x) ++ (show y)) "12345" "67890"
01:18:18 <Jonno_FTW> > concat $  zipWith (\(x,y)-> (show x) ++ (show y)) "12345" "67890"
01:18:19 <lambdabot>   Couldn't match expected type `b -> [a]'
01:18:19 <lambdabot>         against inferred type `GHC....
01:19:03 <Axman6> > concat $  zipWith (\x y -> (show x) ++ (show y)) "12345" "67890"
01:19:04 <lambdabot>   "'1''6''2''7''3''8''4''9''5''0'"
01:19:32 <Jonno_FTW> is there any way to do without the single quote marks?
01:19:41 <Jonno_FTW> without using filter
01:20:39 <Axman6> > digitToInt '1'
01:20:40 <lambdabot>   1
01:20:50 <Axman6> > intToDigit 1
01:20:51 <lambdabot>   '1'
01:21:39 <Axman6> > concat $ zipWith (\x y -> [x,y]) "13579" "24680"
01:21:40 <lambdabot>   "1234567890"
01:22:13 <Axman6> > concat $ zipWith (\x y -> [x,y]) "12345" "67890"
01:22:14 <lambdabot>   "1627384950"
01:25:41 <mreh> I just had a moment of understanding more haskell, mmmmm
01:31:05 <DamienCassou> hi
01:32:07 <Jonno_FTW> > concat $  zipWith (\x y->[x,y]) "12345" "67890"
01:32:08 <lambdabot>   "1627384950"
01:32:11 <DamienCassou> I would like a simple and mature GUI library and I'm an haskell newbie. Do you have something to propose?
01:32:39 <Jonno_FTW> DamienCassou: wXHaskell
01:34:13 <DamienCassou> Jonno_FTW: thank you. I will have a look
01:34:32 <DamienCassou> what about Gtk2Hs?
01:38:11 <tab> DamienCassou: probably a more standard starting point, but it might depends on your platform
01:38:34 <DamienCassou> I'm on Linux
01:38:59 <Jonno_FTW> The real world haskell book uses Gtk
01:39:07 <DamienCassou> which one is the easiest to use?
01:40:01 <Ke> I for one avoid wxwidgets like plague
01:40:20 <Jonno_FTW> how come?
01:40:56 <Ke> I remember it (wxgtk) had some problems with gcc
01:41:13 <Ke> also it is hardly used anywhere
01:49:13 <Jonno_FTW> [uu
02:01:51 <romanandreg> hey guys, is there any way to have a pretty printer without actually having to create a custom method to display it?
02:01:56 <romanandreg> like a pretty printer for lists
02:01:57 <romanandreg> ?
02:02:13 <romanandreg> I'm checking Text.PrettyPrint
02:02:28 <romanandreg> and can't find one simple function that just do something like
02:02:31 <romanandreg> prettyPrint x
02:02:37 <romanandreg> really frustrating
02:02:38 <romanandreg> :-(
02:07:18 <DamienCassou> Jonno_FTW: when installing wx with cabal, I always get a '/bin/sh: wxdirect: not found'. However, wxdirect is in my Path (under ~/.cabal/bin)
02:23:08 <codolio> romanandreg: wl-pprint has a class for pretty printing similar to Show.
02:23:44 <codolio> I think there's a package that has a class for the HughesPJ pretty printers, too.
02:31:06 <aRcatan> what's the problem pretty printing libraries are trying to solve?
02:31:36 <Heffalump> pretty printing :-)
02:33:02 <Heffalump> i.e. laying out things across multiple lines with nice indentation
02:33:29 <Heffalump> and doing so in a compositional way from the point of view of the client
02:33:37 <aRcatan> yeah
02:34:49 <Heffalump> romanandreg: render is the standard method
02:34:55 <Heffalump> @type Text.PrettyPrint.render
02:34:57 <lambdabot> Doc -> String
02:35:10 <romanandreg> yeah the thing is that you want to render custom data objects
02:35:20 <romanandreg> Heffalump
02:35:45 <romanandreg> like, there is not actually a classtype that you can implement that is in the core-library of Text.PrettyPrint
02:37:21 <Heffalump> you want a class like Show, but for making Doc?
02:37:35 <romanandreg> Heffalump: that's correct
02:37:39 <ivanm> Heffalump: any ideas how to get fmap working when I know that the type has only one valid value for the second parameter to Suitable?
02:37:49 <ivanm> romanandreg: there's a few classes for that already
02:37:58 <ivanm> but you're probably better off rolling your own to suit your need
02:38:02 <romanandreg> ivanm: in the Text.PrettyPrint library?
02:38:14 <Heffalump> ivanm: did you try making the constraint be (a ~ Int) ?
02:38:16 <ivanm> that uses that library
02:38:22 <ivanm> Heffalump: hmmm, lemme try that
02:38:26 <Heffalump> that would seem like the obvious equivalent of a typeclass constraint
02:38:39 <ivanm> @hackage prettyclass
02:38:39 <lambdabot> http://hackage.haskell.org/package/prettyclass
02:38:40 <ivanm> romanandreg: ^^
02:39:21 <ivanm> Heffalump: huh, now it seems to want GADT support
02:39:45 <ivanm> but enabling that results in another problem :s
02:39:56 <Heffalump> ivanm: interesting. I'd have expected it to want TypeFamilies, but I guess it comes down to the same thing.
02:40:11 <Heffalump> Actually, yeah. You could also use a GADT with one constructor returning Foo Int, for the datatype instance.
02:40:40 <ivanm> just to repeat: I'm trying it with this: newtype CList a = CL [a]; data instance Constraints CList a = (a ~ Int) => CListConstraints
02:40:47 <Heffalump> I think the two are basically equivalent, and whoever it was who was trying to simulate GADTs with TypeFamilies the other day discovered that
02:41:33 <ivanm> "GADT pattern match with non-rigid result type `k'"
02:41:46 <Heffalump> you need to sprinkle type sigs everywhere to fix that
02:41:55 <Heffalump> hopefully the planned improvements in type checking them will help..
02:41:56 <ivanm> ugh :s
02:42:22 * Heffalump is off for an hour or two
02:42:44 <lpsmith> Does recent versions of GHC-6.13 improve/fix the last core slowdown issue,  or is that still around?
02:43:30 <ivanm> I think that bug was fixed
02:44:33 <lpsmith> totally fixed,  or just improved?
02:46:16 <ivanm> fixed IIRC
02:46:21 <ivanm> ugh, this type sig is fugly and not working :s
02:47:48 <ivanm> dammit, doing :type doesn't work because it wants a type sig :s
03:00:08 <pokoko222> has someone done the GRE test for computer science?
03:41:49 <DamienCassou> hi
03:42:05 * ivanm waves idly in DamienCassou's general direction
03:42:24 <DamienCassou> I'm trying to install gtk with cabal-install, but I always get "The pkg-config package cairo-pdf is required but it could not be found"
03:42:49 <ivanm> probably needs the pdf bindings for cairo or something
03:42:51 <ivanm> i.e. C libs
03:43:28 <DamienCassou> ivanm: how can I install that on Ubuntu?
03:44:11 <ivanm> *shrug*
03:44:23 <ivanm> gtk-dev or something?
03:45:20 <ivanm> or maybe cairo-dev
03:45:31 <ivanm> DamienCassou: is that error actually spat out when trying to build gtk or cairo?
03:45:41 <hamishmack> DamienCassou: This might help... http://rizwanbulbul.blogspot.com/2010/06/installing-leksah-gtk-gtk2hs-and-glade.html
03:45:50 <DamienCassou> ivanm: trying libcairo-dev
03:47:31 <DamienCassou> ivanm: thank you, it works now
03:47:39 <ivanm> np
03:51:17 <DamienCassou> hamishmack: thank you to you also, the web page lists all required packages :-)
03:58:00 <DamienCassou> How can I get around: "cannot find -lHSmtl-1.1.0.2"
03:58:15 <DamienCassou> (output from /usr/bin/ld)
03:58:20 <ivanm> install the mtl library
03:58:27 <DamienCassou> using cabal or apt?
03:58:35 <ivanm> well, preferably apt IMHO
03:58:40 <ivanm> if it's there (and it probably would be)
03:59:00 <ivanm> however, I find the fact that it's a linker script error rather disturbing
03:59:17 <ivanm> might be a ubuntu packaging bug, if whatever gave that error was a ubuntu package
03:59:35 <DamienCassou> this happens during a
03:59:35 <DamienCassou> $ ghc --make test.hs -o hello
03:59:57 <ivanm> ahhh, right
04:00:03 <ivanm> yeah, you need to install the mtl library
04:20:09 <nejucomo> What does the syntax ':=' mean?
04:20:37 <ivanm> in relation to what?
04:20:46 <ivanm> in pascal, etc. it's an assignment statement
04:20:47 <nejucomo> Also '=~='?  On this wiki page: http://www.haskell.org/haskellwiki/Memoization
04:20:51 <ivanm> Hoare Logic uses it for that as well
04:20:59 <ivanm> =~= is probably a regex comparison operator
04:21:33 <ivanm> nejucomo: I think it's just saying that LHS is equivalent to RHS
04:21:48 <ivanm> and for =~= it's something similar
04:22:21 <nejucomo> I don't understand what the underlined + and the x mean in the second set of equations.
04:25:33 <ivanm> nejucomo: just the wiki being too clever for it's own good
04:25:49 <ivanm> it's just meant to be addition and multiplication
04:26:01 <ivanm> (on the type level though I think)
04:26:01 <nejucomo> Hrm.  That seems endemic in documentation about haskell.  :-(
04:26:19 <ivanm> well, that page probably hasn't been updated for a while
04:26:26 <ivanm> why do you want to do memoisation anyway?
04:28:09 <nejucomo> hehe…  who says I want to "do it"?  I just want to learn how it is done in haskell.
04:28:29 <ivanm> there are a few libraries that offer memoisation
04:28:34 <ivanm> but they're all rather fugly IMHO
04:28:37 <ivanm> as is the whole concept
04:28:45 <nejucomo> Hrm…  Does is this syntax an extension: http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries/
04:29:03 <ivanm> no
04:29:11 <nejucomo> Specifically: "class HasTrie a where Data (:->:) a :: * -> *" ?
04:29:50 <ivanm> that says that for every instance of HasTrie, we define a new data-type that is analogous to a look-up function (hence the deliberate similarity to ->)
04:29:57 <nejucomo> What does declaring Data within a class represent?
04:30:20 <nejucomo> Also, does it have a name?  Is the name :->:  ?
04:30:22 <ivanm> a type family declaration
04:30:27 <ivanm> nejucomo: yeah, that's the name
04:30:45 <ivanm> that is an in-fix type constructor
04:32:23 <nejucomo> It looks like it is a ghc extension: http://www.haskell.org/ghc/docs/6.10.2/html/users_guide/type-families.html
04:32:42 <nejucomo> Ok, thanks ivanm.  I'm now parsing it mentally.  ;-)
04:33:49 <ivanm> yes, type families is an extension
04:33:58 <ivanm> the haskell wiki page on them is pretty good, as is the paper
04:37:03 <conal> nejucomo: on that wiki page "=~=" means "is isomorphic to"
04:37:16 <nejucomo> Thanks.
04:39:22 <conal> nejucomo: these three isomorphisms are directly analogous to three familiar laws of exponents.  functional memoization, which is the conversion of functions into data structures by repeated application of those three rules.
04:40:15 <conal> nejucomo: i have a several posts on functional memoization, including a few recent ones.  if you're curious, see http://conal.net/blog/tag/memoization/
04:40:59 <nejucomo> Thanks, I just started this: http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries/ - but now I'm learning about type families.  :-)
04:41:31 <nejucomo> Tonight's one of the depth-first rtfms.
04:41:45 <conal> nejucomo: cool.  :)
04:42:51 <conal> type families gave a wonderful boost to haskell's expressiveness
04:43:10 <ivanm> if only we had superclass constraints already :(
04:43:55 * hackagebot accelerate 0.8.0.0 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.8.0.0 (ManuelChakravarty)
04:44:06 <nejucomo> More syntax confusion: "class HasTrie a where data (:->:) a"   -but later trie's type returns (a :->: b).
04:44:32 <nejucomo> I thought :->: was defined to take only one parameter.
04:45:09 <Axman6> that would make :->: postfix then
04:45:25 <Axman6> though i do agree the syntax is confusing
04:45:27 <nejucomo> Actually I see how the kind is defined as "* -> *", but I don't understand how that is the case, given the left side of "::".
04:45:42 <ivanm> nejucomo: the * -> * bit there means it takes in another arbitrary parameter
04:45:50 <nejucomo> -which is not named?
04:45:54 <ivanm> right
04:45:57 <ivanm> because it's arbitrary
04:46:15 <nejucomo> As in, not within the class definition parameters?
04:46:56 <ivanm> as in it's not a named type in the class, yes
04:46:57 <nejucomo> If the kind annotation were omitted, would the code still be coherent, or would it implicitly become kind * ?
04:47:14 <ivanm> just *
04:47:20 <ivanm> hence why it's there
04:47:54 <nejucomo> I see.
04:49:10 <nejucomo> Ok, yet more questions…  The type annotations for trie/untrie mention b.  Does this imply a "forall b." ?
04:49:58 <ivanm> well, yes
04:50:07 <ivanm> just like "length :: [a] -> Int" implies "forall a."
04:54:35 <nejucomo> :t either
04:54:36 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
05:04:17 <mreh> let x = 1 : x
05:04:24 <mreh> > let x = 1 : x in x
05:04:25 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:04:44 <mreh> > fix (1:)
05:04:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:05:58 <firegolfer> http://codepad.org/nMGZpZJQ
05:06:09 <firegolfer> Why the hell thinks haskell, that ttt is Char?
05:06:49 <mreh> because that's what type it is
05:06:58 <firegolfer> it should be string
05:07:03 <firegolfer> as getInput returns Maybe String
05:07:13 <mreh> your fromMaybe implies otherwise
05:07:20 <firegolfer> Why?
05:07:30 <mreh> :t fromMaybe
05:07:31 <lambdabot> forall a. a -> Maybe a -> a
05:07:35 <firegolfer> I know
05:07:38 <firegolfer> and "" is a String?
05:07:38 <mreh> '"'
05:08:13 <mreh> because '"' is a char
05:08:24 <mreh> the the double quotes char
05:08:24 <ivanm> no, I think you're looking at it wrong mreh 
05:08:34 <ivanm> firegolfer: for the next line to type-check, ttt has to be a Char
05:08:38 <ivanm> since [Char] = String
05:08:39 <mreh> oh, haha
05:08:43 <ivanm> @type readProcess
05:08:43 <firegolfer> ok
05:08:43 <lambdabot> Not in scope: `readProcess'
05:08:51 <ivanm> mreh: yeah, I get confused by that all the time as well :s
05:08:54 <ivanm> @hoogle readProcess
05:08:55 <lambdabot> No results found
05:08:56 <firegolfer> but fromMaybe [] does not work either
05:08:59 <ivanm> bah
05:09:02 <firegolfer> and [] is clearly not a char
05:09:07 <ivanm> firegolfer: readProcess "echo" ttt
05:09:23 <mreh> that's the ticket
05:09:26 <ivanm> IIRC, readProcess takes a String and a String
05:09:45 <mreh> [ttt] == String would imply ttt == Char
05:09:50 <ivanm> no, wait, I'm wrong
05:09:58 <firegolfer> its FilePath -> [String]
05:10:02 <ivanm> readProcess :: FilePath -> [String] -> String -> IO String
05:10:09 <ivanm> firegolfer: no it isn't ;-)
05:10:14 <ivanm> you need another String after that
05:10:14 <firegolfer> + the rest
05:10:28 <ivanm> so your code still won't type-check
05:10:49 <firegolfer> ok
05:10:56 <firegolfer> I can put a "" at the end
05:10:58 <firegolfer> (stdin)
05:11:00 <ivanm> but pasting the actual error message might help as well
05:11:02 <firegolfer> but it's still a char
05:11:13 <firegolfer>     Couldn't match expected type `String' against inferred type `Char'
05:11:13 <firegolfer>     In the expression: ttt
05:11:13 <firegolfer>     In the second argument of `readProcess', namely `[ttt]'
05:11:13 <firegolfer>     In a stmt of a 'do' expression: out <- readProcess "echo" [ttt] ""
05:11:39 <ivanm> by "pasting", I meant on the paste site
05:12:13 <ivanm> *shrug* ttt should be a String AFAICT
05:12:45 <firegolfer> it should, but it ain't
05:14:59 <firegolfer> you can change it to fromMaybe "foo" txt
05:15:02 <firegolfer> it's still Char
05:15:15 <firegolfer> which according to the typsystem cleary just can't be :(
05:16:08 <firegolfer> unless
05:16:55 <firegolfer> hm no
05:17:02 <ivanm> what?
05:17:15 <firegolfer> getInput would be Maybe Char
05:17:30 <firegolfer> (which is getInput not)
05:18:12 <ivanm> well, I find it doesn't like: readProcess "echo" ["hi"] "blah"
05:18:54 <ivanm> oh, wait, I've got it
05:18:59 <ivanm> firegolfer: it's the fromMaybe
05:19:11 <ivanm> let ttt = fromMaybe "" txt
05:19:29 <firegolfer> so
05:19:37 <firegolfer> <- "foo" is Char?
05:20:00 <ivanm> no
05:20:08 <ivanm> well, kinda
05:20:14 <ivanm> it's getting confused which monad it's in IIUC
05:20:25 <ivanm> and thinks it's suddenly switched to the list monad
05:20:36 <ivanm> (adding an explicit type sig to cgiMain helps point that out)
05:23:34 <Heffalump> ivanm: did you manage to sort out that Suitable instance?
05:23:41 <ivanm> nope
05:24:02 <ivanm> it's wanting type sigs for the lambda funcs
05:24:08 <ivanm> and getting them right is a bit of a PITA
05:24:19 <Heffalump> yeah :-(
05:24:38 <Heffalump> actually, a specialised version of withConstraintsOf would make sense here
05:25:00 <ivanm> oh? how?
05:25:27 <ivanm> one that returns an "m a" as well?
05:26:38 <Heffalump> withConstraintsOf just brings the class restricton into scop
05:26:39 <Heffalump> e
05:26:54 <Heffalump> i.e. the body can be of type Foo a => ...
05:27:16 <Heffalump> here, since you just want to know that the type is an Int, you can probably just have a function of type (Int -> something) -> something
05:27:29 <Heffalump> or even just return the thing of type Int
05:35:26 <ivanm> hmmm.... you're saying one specifically for this type?
05:36:32 <ivanm> *groan* now I don't seem to even need withCOnstraintsOf :s
05:36:50 <Heffalump> yes, a specific one
05:36:52 <Heffalump> oh dear :-)
05:37:12 <ivanm> wait, I didn't need it at all
05:37:13 <ivanm> *sigh*
05:37:19 <ivanm> that's not helping me with my more generic case...
05:40:10 <ivanm> Heffalump: can you see any way of getting the Functor instance for KindPromote to work here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29338#a29338
05:42:19 <Heffalump> what information are you expecting to get from Stores c v?
05:43:05 <dom96> Is there a function that takes a Bool, String, String and returns a String. Depending on the bool, if it's true it returns the first string if it's false it returns the second?
05:44:09 <Axman6> that sounds a hell of a lot like an if statement to me
05:44:37 <azaq231> > let f x y z = if x then y else z in f True "a" "b"
05:44:38 <lambdabot>   "a"
05:44:49 <Axman6> > let foo b l r = if b then l else r in [foo True "Hello" "World", "foo False "Hello" "World"]
05:44:50 <lambdabot>   <no location info>:
05:44:50 <lambdabot>      lexical error in string/character literal at end o...
05:44:58 <Axman6> > let foo b l r = if b then l else r in [foo True "Hello" "World", foo False "Hello" "World"]
05:44:59 <lambdabot>   ["Hello","World"]
05:45:15 <dom96> It's simpler to have a function which does that. Then i can concatenate strings easily.
05:45:18 <dom96> with less code
05:45:56 <dom96> But if there isn't, i'll just implement it myself.
05:46:00 <azaq231> afaik there is no such predefined if function, unfortunately
05:47:10 <Heffalump> (?) :: Bool -> (a, a) -> a is quite a common thing for people to define themselves
05:48:11 <aristid> Heffalump: i'd rather define (?) :: Bool -> a -> a -> a
05:48:47 <aristid> :t let if' c a b = if c then a else b in uncurry . if'
05:48:48 <lambdabot> forall c. Bool -> (c, c) -> c
05:49:31 <aristid> :t let c ? (a, b) = if c then a else b in curry . c
05:49:32 <lambdabot>     Couldn't match expected type `f ((a, b) -> c)'
05:49:33 <lambdabot>            against inferred type `Expr'
05:49:33 <lambdabot>     In the second argument of `(.)', namely `c'
05:49:36 <aristid> :t let c ? (a, b) = if c then a else b in curry . (?)
05:49:37 <lambdabot> forall c. Bool -> c -> c -> c
05:49:47 <lispy> ?let (?) b t e = if b then t else e
05:49:49 <Heffalump> aristid: just saying what I've seen before
05:49:49 <lambdabot>  Defined.
05:50:04 <lispy> oh actually, Heffalump's version makes it binary
05:50:07 <dom96> ok, thanks
05:50:09 <lispy> So that's why you'd rather do it
05:50:17 <Heffalump> right
05:50:23 <aristid> lispy: yeah but if i want operatorness, why not use if?
05:50:25 <Heffalump> ternary operators in Haskell are a bit weird
05:50:34 <aristid> .oO(agda)
05:50:34 <lispy> ?undef
05:50:36 <Heffalump> aristid: well, it's more infix this way
05:50:45 <lispy> ?let (?) b (t, e) = if b then t else e
05:50:46 <lambdabot>  Defined.
05:50:56 <lispy> > True ? (1,2)
05:50:57 <lambdabot>   1
05:51:11 <ivanm> Heffalump: given the c, it should tell you the v; in this case it's setting the required types for Constraints
05:52:04 <aristid> Heffalump: i usually want if' in combination with... combinators, not just for infixness
05:52:23 <lispy> ?undef
05:52:29 <lispy> ?let (?) b t e = if b then t else e
05:52:30 <lambdabot>  Defined.
05:52:35 <lispy> > True ? 1 2
05:52:36 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
05:52:36 <lambdabot>    arising from a use of `...
05:52:42 <lispy> > True ? 1 $ 2
05:52:43 <lambdabot>   1
05:53:03 <lispy> That's not actually that bad, with the $ instead of :, it looks a lot like C's ternary operator
05:53:25 <lispy> > let (:) = id in True ? 1 : 2
05:53:26 <lambdabot>   Constructor `:' should have 2 arguments, but has been given 0
05:54:06 <lispy> Now wait a second.  You can use let to change the value of constants, but not (:) ?
05:54:14 <lispy> > let 1 = 2 in show 1
05:54:15 <lambdabot>   "1"
05:54:34 <Heffalump> lispy: try NoImplicitPrelude
05:54:38 <Heffalump> (at a guess)
05:54:52 <Heffalump> > let 1 x = 2 in show (1 2)
05:54:52 <lambdabot>   <no location info>: Parse error in pattern
05:54:55 <lispy> Heffalump: well, let didn't actually work the way I thought in that second example :)
05:55:08 <Heffalump> oh yeah, it's just a lazy match, sorry
05:55:15 <Heffalump> you're not redefining anything. So the types have to match
05:55:34 <Heffalump> and constructors have to be fully saturated at pattern matches
05:55:45 <Igloo> Even if the types did match, you still wouldn't be redefining anything
05:56:57 <Heffalump> ivanm: it works better, but still doesn't typecheck, if you use Mappable instead of Stores in KindConstraints
05:58:37 <ivanm> Heffalump: that won't help me when I want to be able to use KindCOnstraints for Foldable, etc. ;-)
05:58:53 <Heffalump> can't you put it all in the class?
06:00:00 <Heffalump> also, this might work better with type functions than fundeps
06:00:13 <Heffalump> because fundeps don't actually deduce type equality
06:00:18 <Heffalump> even when the fundep implies it
06:00:26 <Heffalump> that may actually be the problem, thinking about it
06:01:07 <ivanm> well, yes, but we don't have superclass constraints yet
06:01:17 <ivanm> actually, I might not need superclass constraints yet...
06:01:26 <Heffalump> you mean equality constraints in superclasses?
06:01:36 <Heffalump> or is it more than that, I forget..
06:02:01 <ivanm> yeah
06:02:27 <ivanm> class (Foo a, Foo b, Bar a ~ Bar b) => Baz a b ...
06:06:05 <lispy> Barbie?
06:06:12 <lispy> Oh, Bar b.
06:06:19 <Martty> cunning
06:07:48 <ivanm> Heffalump: *sigh* "instance (Stores c) => Suitable (KindPromote c) (Value c) where" needs TypeSynonymInstances apparently :s
06:08:46 <ivanm> no, wait, it then says it is an illegal type synonym family application :s
06:08:50 <ivanm> gaaaahhhhhhh!!!!!!!!!!!!!!!!!!!!!
06:11:41 <Heffalump> :-)
06:13:29 <DamienCassou> does haskell-platform include ghc?
06:13:58 <ivanm> yes
06:14:04 <ivanm> but the source tarball doesn't have it
06:14:09 <DamienCassou> it seems that yes, but when I install it, the bin directory does not have any ghc. Only cabal, alex and some others
06:14:10 <ivanm> and neither does the generic unix tarball IIRC
06:14:19 <ivanm> DamienCassou: how are you installing it?
06:15:16 <DamienCassou> I removed all references to ghc, then downloaded the pre-compiled ghc, then compiled and install the platform from haskell-platform-2010.2.0.0.tar.gz
06:15:21 <Baughn> @tell Aww. You /agreed/ with making the indentation broken by default, too..
06:15:21 <lambdabot> Consider it noted.
06:16:15 <Baughn> @tell chrisdone Aww. You /agreed/ with making the indentation broken by default, too..
06:16:16 <lambdabot> Consider it noted.
06:16:43 <ivanm> dammit, I can't change my nick to "Aww." :(
06:16:44 <aristid> Baughn: uh, what?
06:16:45 <Baughn> ..I can only assume that, some time in the 2040s, an AI called "Aww." will get really confused by that tell.
06:16:55 <DamienCassou> ivanm: I removed all references to ghc, then downloaded the pre-compiled ghc, then compiled and install the platform from haskell-platform-2010.2.0.0.tar.gz
06:16:59 <aristid> ivanm: maybe "Aww" works?
06:17:25 <ivanm> DamienCassou: yeah, the source tarball doesn't have ghc
06:18:11 <Baughn> aristid: Because it changed quite a lot, to the point where reconfiguration was a necessity. Trying to make it work would have led to subtle bugs.
06:18:14 <DamienCassou> ivanm: I have to use the precompiled one then?
06:18:22 <ivanm> yes
06:18:28 <ivanm> DamienCassou: especially since you need GHC to compile GHC
06:18:30 <Baughn> aristid: Telling people to "please, please read the readme" /should/ have worked...
06:18:45 <ivanm> Baughn: what did chrisdone do?
06:18:59 <aristid> Baughn: uuh, what?
06:19:18 <Baughn> ivanm: Complained about it. :/
06:20:58 <Baughn> ivanm: (It was a joke, by the way)
06:21:04 <DamienCassou> ivanm: sure, but I thought that ghc was part of the platform as advertised everywhere
06:21:58 <jnj> is there a function available for doing [1,2,3] -> [[1],[2],[3]]? That is, "explode" a list.
06:22:09 <Jaak> map (:[]) ?
06:22:12 <Baughn> map (:[])
06:22:18 <jnj> Thanks
06:22:38 <aristid> DamienCassou: if you download the binaries, it is
06:22:41 <dh__> > (:[]) 1
06:22:42 <lambdabot>   [1]
06:23:02 <aristid> @pl \a b -> [a,b]
06:23:02 <lambdabot> (. return) . (:)
06:23:11 <aristid> :/
06:23:16 <dh__> @pl (:[])
06:23:16 <lambdabot> return
06:23:24 <DamienCassou> aristid: is there any binary for linux and the latest platform?
06:23:27 <dh__> > return 1 ::[Int]
06:23:28 <lambdabot>   [1]
06:23:51 <dh__> > return 1
06:23:52 <lambdabot>   No instance for (GHC.Show.Show (m t))
06:23:52 <lambdabot>    arising from a use of `M6230155894...
06:23:53 <aristid> DamienCassou: dunno, i don't really use haskell-platform, because i use ubuntu which has packages for ghc and cabal (which is all i need)
06:24:10 <Baughn> DamienCassou: Particular linux distributions may or may not have binaries. There is a source code distribution of the platform, which will depend on you installing a binary of ghc first.
06:24:25 <Baughn> I don't know if there is a binary platform release.
06:25:00 <Baughn> DamienCassou: But installing a binary GHC and then compiling the platform is pretty easy. It's just kind of pointless, unless you specifically want to avoid using anything not in the platform.
06:25:09 <Baughn> Generally installing GHC and cabal-install will suffice, see
06:26:16 <Heffalump> hi dcoutts
06:26:46 <DamienCassou> thank you
06:28:07 <ivanm> DamienCassou: as part of the definition of the platform, it is
06:28:40 <ivanm> but in terms of packaging, whilst it's included with the windows and OSX installers, it isn't part of the platform source tarball
06:28:49 <ivanm> since ghc has its own source tarball, and needs itself to compile
06:30:24 <zonkor> How does Haskell automatically derive "Ord", e.g., for Church numerals?
06:30:57 <Zao> zonkor: Ctors are ordered lexically.
06:31:04 <zonkor> I.e., how can it infer what is "bigger" or "smaller"? By the number of nested value constructors?
06:31:16 <zonkor> What's a Ctor?
06:31:17 <Zao> That is, in data Foo = A | B -- A is before B.
06:31:19 <Zao> Constructor.
06:31:41 <zonkor> Oh, that's good to know!
06:31:46 <benmachine> data N = Z | S N results in something like Z < S _ and S n <= S m if n <= m
06:31:47 <Zao> In data Foo = A Int Int -- A 42 3 is before A 9001 1
06:32:21 <zonkor> That's really nice.
06:32:36 <benmachine> that's haskell! :P
06:32:48 <zonkor> Another thing: how would you encode _signed_ Church numerals?
06:33:01 <Heffalump> are Church numerals really the right name for the explicit datatypes?
06:33:09 <Heffalump> Peano numbers or something, isn't it?
06:33:18 <Heffalump> Church numerals use higher-order functions
06:33:24 <zonkor> http://en.wikipedia.org/wiki/Church_encoding
06:33:49 <Heffalump> zonkor: exactly.
06:34:11 <Heffalump> and Haskell certainly won't derive "Ord" if you do use the higher-order function encoding
06:34:51 <zonkor> Heffalump: ok, I get what you mean. Indeed I'm using the type system for encoding, and not higher-order functions.
06:46:31 <ivanm> Heffalump: so, do you see any way out of my dilemma?
06:48:31 <Heffalump> ivanm: errm, dunno. It feels like it should be possible to achieve what you want, but I haven't tried very hard.
06:48:50 <ivanm> heh, fair enough
06:50:25 <duckinator> hi
06:50:36 * ivanm waves idly in duckinator's general direction
06:50:56 * duckinator looks oddly at ivanm, and returns to working on his processor design
06:51:09 <ivanm> well, you said "hi", so I responded
06:51:20 <ivanm> if you don't want me to be polite, just say so!
06:51:24 <duckinator> lol
06:52:54 <Heffalump> does explicitly describing your wave as "idle" count as polite?
06:53:20 <ivanm> at least I responded!
06:53:31 <ivanm> would "urgently" make it sound more polite?
06:53:33 <Axman6> duckinator: what sort of processor?
06:53:50 <ivanm> Axman6: a designed one, duh
06:53:51 <ivanm> ;-)
06:54:03 <Jafet> I wish my processor was designed!
06:54:04 <duckinator> Axman6: a small 4-bit processor :P
06:54:14 <Axman6> heh, nice
06:54:57 <duckinator> it could easily be made to work on larger data and retain the 4-bit opcodes, but i'm trying to keep it so i can actually design it for now
06:55:45 * ivanm -> land of nod
07:36:46 * hackagebot clevercss 0.2.1 - A CSS preprocessor  http://hackage.haskell.org/package/clevercss-0.2.1 (GeorgBrandl)
07:44:49 * hackagebot clevercss 0.2.2 - A CSS preprocessor  http://hackage.haskell.org/package/clevercss-0.2.2 (GeorgBrandl)
07:45:05 <Botje> rapid development in action!
07:45:43 <benmachine> heh
07:46:49 * hackagebot clevercss 0.2.3 - A CSS preprocessor  http://hackage.haskell.org/package/clevercss-0.2.3 (GeorgBrandl)
07:47:21 <Heffalump> :-)
07:47:27 <Jafet> A real committed developer.
08:07:40 * hackagebot enumerator 0.2.1 - Implementation of Oleg Kiselyov's left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.2.1 (JohnMillikin)
08:10:41 * hackagebot JackMiniMix 0.1 - control JackMiniMix  http://hackage.haskell.org/package/JackMiniMix-0.1 (RenickBell)
08:14:46 <Maxdamantus> Monad's aren't "special" as far as the implementation is concerned, are they?
08:15:03 <Maxdamantus> other than the syntactic sugar stuff
08:15:28 <copumpkin> yep
08:15:32 <copumpkin> no magic
08:16:10 <Jafet> Just advanced technology.
08:17:32 <roconnor> Jafet: :D
08:18:26 <spuz> Hello, If I define a function such as:
08:18:31 <greap> Can anyone spot why this goes into an infinite loop? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29350#a29350
08:18:33 <spuz> divisors n = [ x | x <- [1..floor (sqrt n)], n `mod` x == 0]
08:18:54 <spuz> how can I avoid getting the error "Ambiguous type variable `t' in the constraints:" when I call it?
08:19:15 <greap> GHC duly impressed me though by printing "<<loop>>" rather than recursing indefinitely. One step closer to solving the halting problem!
08:19:18 <Maxdamantus> putStr "foo" >> putStr "bar" .. (>>=) (putStr "foo") (\_ -> putStr "bar")
08:19:20 * Maxdamantus sees
08:19:32 <Maxdamantus> so it's all to do with the definition of the >>= operator
08:20:13 <roconnor> greap: you need to define recip or (/)
08:20:27 <roconnor> -- Minimal complete definition:
08:20:27 <greap> roconnor: Oh. Cool.
08:20:29 <roconnor>         --      fromRational and (recip or (/))
08:20:44 <roconnor> greap: right now they are both defined in terms of each other by default
08:20:55 <roconnor> ... admitedly it would be better to get an error.
08:21:05 <greap> Yes. That makes complete sense. I just would have expected a compiler warning.
08:22:07 <Jafet> > throwIO NonTerminationException
08:22:08 <lambdabot>   Not in scope: `throwIO'Not in scope: data constructor `NonTerminationExcept...
08:22:14 <int-e> spuz: you can write floor (sqrt n :: Double) (strictly speaking that will lead to incorrect code because of possible rounding errors. from a practical point of view that likely wont matter)
08:24:13 <spuz> int-e: that doesn't appear to work...
08:24:34 <spuz> No instance for (Integral Double) arising from a use of `floor' at <interactive>:1:32-55
08:24:55 <int-e> spuz: ah, true. floor (sqrt (fromIntegral n) :: Double)
08:25:14 <Zao> @type true. floor
08:25:15 <lambdabot> Not in scope: `true'
08:25:16 <Jafet> Well, the type annotation isn't needed
08:25:31 <Jafet> :t sqrt
08:25:32 <lambdabot> forall a. (Floating a) => a -> a
08:26:30 <int-e> Jafet: Right (thanks to defaulting). I misdiagnosed the problem. But I'd probably add the type annotation anyway.
08:26:58 <int-e> Zao: heh. Not what I meant.
08:28:25 <spuz> int-e: cool, thanks, actually, I didn't need the :: Double type annotation it seems, the fromIntegral did the trick though
08:28:31 <Heffalump> > let x = x in x
08:28:35 <lambdabot>   mueval-core: Time limit exceeded
08:28:37 <Heffalump> hmph
08:28:41 <Heffalump> that ought to black hole
08:28:58 <itsmonktastic> :t x
08:28:59 <lambdabot> Expr
08:29:04 <Jafet> @instances Floating
08:29:04 <lambdabot> Double, Float
08:30:26 <Jafet> > (sqrt 2 :: Double) - realToFrac (sqrt 2 :: Float)
08:30:27 <lambdabot>   2.4203234305630872e-8
08:30:37 <Jafet> Maybe you do need the annotation.
08:31:54 <int-e> Jafet: Double is the default default in that case.
08:31:56 <Jafet> Heffalump: I believe only the compiler is dense enough to make black holes
08:32:14 <itsmonktastic> > let yourmum = x in yourmum
08:32:15 <lambdabot>   x
08:32:34 <itsmonktastic> I don't really see why let x = ... should have behaved any differently there
08:32:50 <int-e> itsmonktastic: because it's recursive
08:33:11 <Jafet> All three xs refer to the same x.
08:33:17 <int-e> > let x = x in x -- defines a fresh value x by itself.
08:33:20 <lambdabot>   mueval-core: Time limit exceeded
08:34:01 <itsmonktastic> > let y = x in let x = y in x
08:34:02 <lambdabot>   x
08:34:04 <int-e> > let x = y; y = z; z = x in x -- same thing, in a more roundabout fashion
08:34:08 <lambdabot>   mueval-core: Time limit exceeded
08:34:49 <int-e> itsmonktastic: in that case, the scope of the second x does not extend outside of its let binding, so let y = x picks up the global x
08:34:53 <int-e> > x
08:34:54 <lambdabot>   x
08:35:26 <int-e> @type x
08:35:27 <lambdabot> Expr
08:37:14 <int-e> > aa
08:37:15 <lambdabot>   Not in scope: `aa'
08:37:22 <itsmonktastic> hmm
08:37:23 <int-e> > [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]
08:37:24 <lambdabot>   [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]
08:37:45 <itsmonktastic> int-e: thanks :) just attempting to grok :p
08:38:07 <Maxdamantus> > [a..z]
08:38:08 <lambdabot>   *Exception: not a number
08:38:12 <Maxdamantus> :(
08:39:04 <Axman6> > succ a
08:39:05 <lambdabot>   succ a
08:39:05 <spuz> int-e: forgive my noobishness but why is it that simply calling sqrt 2 works fine but in my divisors function, I must call fromIntegral?
08:39:24 <Axman6> :t \x -> sqrt x
08:39:25 <lambdabot> forall a. (Floating a) => a -> a
08:39:37 <int-e> spuz: because 2 is polymorphic - it can have any numeric type (instance of Num)
08:39:37 <Axman6> :t sqrt ?2
08:39:38 <lambdabot>     Couldn't match expected type `Bool' against inferred type `a -> a'
08:39:38 <lambdabot>     In the first argument of `(?)', namely `sqrt'
08:39:39 <lambdabot>     In the expression: sqrt ? 2
08:39:43 <int-e> @type 2
08:39:43 <Axman6> urgh
08:39:44 <lambdabot> forall t. (Num t) => t
08:39:46 <Axman6> @unlet
08:39:47 <lambdabot>  Defined.
08:39:50 <Axman6> :t sqrt ?2
08:39:51 <lambdabot>     Couldn't match expected type `Bool' against inferred type `a -> a'
08:39:51 <lambdabot>     In the first argument of `(?)', namely `sqrt'
08:39:51 <lambdabot>     In the expression: sqrt ? 2
08:39:57 <Axman6> rage
08:41:03 <int-e> spuz: so the same expression, 2, can have type Double in one context (as sqrt 2) and Integer in another (11 `div` 2)
08:41:07 <Jafet> Heh, the first dependency for "lambdabot" is "brainfuck"
08:41:18 <Maxdamantus> > 5*x^3*x^4
08:41:19 <lambdabot>   5 * (x * x * x) * (x * x * (x * x))
08:41:24 <Maxdamantus> O_o
08:41:50 <Maxdamantus> > 5*(x^3*x^4)
08:41:51 <lambdabot>   5 * (x * x * x * (x * x * (x * x)))
08:41:54 <spuz> int-e: ah so it's becausing I'm using the same value as a Double and an Integer in the same function?
08:41:55 <Jafet> @src Expr
08:41:55 <lambdabot> Source not found. :(
08:42:03 <int-e> spuz: exactly
08:42:14 <Maxdamantus> > x^x
08:42:15 <dom96> Is there anyway i can decrease hint's memory usage?
08:42:19 <lambdabot>   mueval: ExitFailure 1
08:42:26 <Starfire> :t x
08:42:29 <lambdabot> Expr
08:42:36 <Maxdamantus> > x^(-1)
08:42:37 <lambdabot>   *Exception: Negative exponent
08:42:45 <Cale> > x^^(-1)
08:42:46 <lambdabot>   recip x
08:42:53 <Axman6> > x `mod` 2
08:42:55 <lambdabot>   x `mod` 2
08:42:56 <Maxdamantus> x^^4
08:43:01 <Jafet> > x**x
08:43:02 <lambdabot>   x**x
08:43:02 <Axman6> > x `mod` 2 == 0
08:43:03 <lambdabot>   False
08:43:06 <Maxdamantus> > x^^4
08:43:07 <lambdabot>   x * x * (x * x)
08:43:07 <Axman6> > x `mod` 2 == 1
08:43:08 <lambdabot>   False
08:43:22 <Maxdamantus> > x^^(4.5)
08:43:23 <lambdabot>   Ambiguous type variable `t' in the constraints:
08:43:23 <lambdabot>    `GHC.Real.Integral t'
08:43:23 <lambdabot>   ...
08:43:39 <Maxdamantus> > x^^(999999999999)
08:43:40 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))...
08:43:48 <Maxdamantus> parabola!
08:44:03 <int-e> that Eq instance is dubious (but required for the Num and related instances which are the whole point of the simple-reflect package)
08:44:05 <Maxdamantus> > x^^(9)
08:44:06 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * x
08:44:25 <int-e> > x ** 4.5
08:44:26 <lambdabot>   x**4.5
08:44:32 <Maxdamantus> Where does it get this "Expr" stuff from?
08:44:43 <int-e> http://hackage.haskell.org/package/simple-reflect
08:46:15 <Maxdamantus> > f . g $ x
08:46:16 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:46:16 <lambdabot>    `GHC.Show.Show a'
08:46:16 <lambdabot>      a...
08:47:03 <int-e> nice.
08:47:07 <Maxdamantus> > f x
08:47:08 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:47:08 <lambdabot>    `GHC.Show.Show a'
08:47:09 <lambdabot>      a...
08:47:53 <Maxdamantus> > f . g $ x :: Expr
08:47:54 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:47:54 <lambdabot>    `SimpleReflect.FromExpr ...
08:47:56 <int-e> > (f :: Expr -> Expr) . g $ x
08:47:57 <lambdabot>   f (g x)
08:48:11 <int-e> you need to fix the type of the intermediate result (g x).
08:48:16 <dom96> does anyone have a pre-compiled lambdabot i could download?
08:48:27 <Maxdamantus> I see.
08:48:44 <int-e> not sure 
08:48:50 <int-e> what happened to the f x though
08:48:51 <azaq231> dom96: you can /msg lambdabot
08:48:51 <int-e> > f x
08:48:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:48:52 <lambdabot>    `GHC.Show.Show a'
08:48:52 <lambdabot>      a...
08:48:57 <int-e> > f x :: Expr
08:48:58 <lambdabot>   f x
08:49:04 <int-e> ah. right.
08:49:11 <Deewiant> ?ty f x
08:49:12 <lambdabot> forall t. (SimpleReflect.FromExpr (Expr -> t)) => t
08:49:16 <dom96> azaq231: I just want to see how much memory it uses
08:49:31 <Jafet> @hackage lambdabot
08:49:31 <lambdabot> http://hackage.haskell.org/package/lambdabot
08:49:35 <jnj> A newbie question (in ghci): Why is the expression "id sqrt 2" valid when "sqrt sqrt 2" is not? What is the difference between id and sqrt that causes this?
08:49:54 <dom96> Jafet: i tried 'cabal install lambdabot' that fails
08:49:57 <Jafet> jnj, id sqrt 2 is equivalent to (id sqrt) 2
08:49:58 <Cale> jnj: id sqrt 2 = (id sqrt) 2
08:50:07 <Cale> jnj: = sqrt 2
08:50:09 <azaq231> jnj sqrt sqrt 2 is interpreted as left associative; so as (sqrt sqrt) 2 which is clearly wrong
08:50:11 <azaq231> > sqrt $ sqrt 2
08:50:11 <int-e> > var "cat" + var "dog" == var "mess"
08:50:12 <lambdabot>   1.189207115002721
08:50:13 <lambdabot>   False
08:50:13 <Jafet> dom96: too bad
08:50:16 <azaq231> > sqrt (sqrt 2)
08:50:17 <lambdabot>   1.189207115002721
08:50:27 <dom96> And judging by 'Build failure	ghc-6.12 (log)' on hackage... i guess it's not my fault
08:50:28 <Cale> It's probably okay in lambdabot, because of the extra Num instances :)
08:50:31 <Cale> > sqrt sqrt 2
08:50:32 <jnj> Ah.. I get it
08:50:33 <lambdabot>   1.189207115002721
08:50:34 <jnj> Thanks
08:50:54 <Cale> (That literally takes the square root of the square root function.)
08:50:57 <Jafet> @instances Num
08:50:57 <lambdabot> Double, Float, Int, Integer
08:50:59 <int-e> > sqrt + sin $ 1
08:50:59 <lambdabot>   1.8414709848078965
08:51:25 <int-e> that extra num instance? *wonders*
08:51:27 <Axman6> ...
08:51:30 <Cale> I don't know where the @instances gets its list of instances from.
08:51:46 <Cale> int-e: The one from vector-space
08:52:02 <Cale> int-e: Yeah
08:52:30 <dom96> Does lambdabot load plugins dynamically? i.e at runtime?
08:52:32 <Cale> Well, not just Num, but Floating.
08:52:55 <Cale> dom96: It's supposed to be able to. I'm not sure whether or not that still works.
08:53:28 <Cale> dom96: Support for that was based on the aging hs-plugins library.
08:53:43 <int-e> > sin == sqrt
08:53:43 <dom96> I'm creating an IRC Bot which can, using the hint library. Without any modules loaded my bot uses 1.9mb of ram
08:53:44 <lambdabot>   *Exception: (==): No overloading for function
08:53:53 <dom96> but with 2 modules loaded it uses like 50
08:54:17 <Cale> dom96: hint uses the GHC API, which basically consists of most of GHC.
08:54:38 <Cale> dom96: How's the memory with just one module?
08:55:03 <dom96> Cale: 15.7mb
08:55:22 <Cale> Okay, hmm, what do the modules consist of?
08:55:33 <dom96> The memory usage also increases every time i reload the modules.
08:56:12 <dom96> When i reload the memory usage almost doubles
08:56:22 <int-e> right, because unloading really doesn't work very well - you'd have to keep track of code references and I don't think the RTS can do that.
08:56:26 <dom96> Cale: it's just a couple of functions.
08:56:38 <dom96> It imports quite a lot of module though.
08:56:51 <dom96> ByteStrings, Data.Maybe, Data.Map
08:58:18 <Cale> Right now, lambdabot is using 138 MB of virtual memory, with 37 MB resident.
08:58:48 <Cale> It doesn't use hint though.
08:59:01 <dom96> What does it use then, the GHC API ?
08:59:03 <Jafet> @seen Cale
08:59:03 <preflex>  Cale was last seen on #haskell 15 seconds ago, saying: It doesn't use hint though.
08:59:03 <lambdabot> Unknown command, try @list
08:59:45 <Cale> It used to use hs-plugins to load modules dynamically. I'm not sure whether or not that still is in use.
08:59:52 <Cale> (Or if they're just compiled in)
09:00:13 <dom96> Judging by http://code.haskell.org/lambdabot/Modules.hs
09:00:16 <dom96> I think they are.
09:02:04 <Cale> Anyway, I wouldn't be too afraid of that initial growth in memory usage. I doubt that it will continue indefinitely.
09:02:36 <Cale> It's probably related to loading the dependencies for those packages, similar as you'd have to when loading them in GHCi.
09:03:27 <dom96> It does seem to stop eventually. But the more module i have loaded the more memory it uses.
09:04:20 <Cale> Does precompiling the modules help at all?
09:04:21 <Jafet> Go go lazy dlopen
09:04:21 <dom96> I'm planning to run this bot on a VPS. Which means i have to make it use as little memory as possible.
09:04:38 <dom96> hrm
09:04:58 <Cale> If you have up to date .o and .hi files for the modules, hint will load that code rather than interpreting them.
09:05:28 <dom96> Let me try
09:06:25 <dom96> Dropped to 10mb
09:06:40 <dom96> Reloading doesn't seem to work now
09:06:54 <dom96> It says that the module was not interpreted...
09:08:02 <Cale> Right, well, it's not :)
09:08:15 <Cale> I don't know why reloading wouldn't work.
09:09:18 <dom96> Deleting the .hi and .o files got it working again
09:10:29 <Cale> hmm
09:10:41 <dom96> I think i'm just gonna give up on using hint
09:10:47 <Cale> Did you make some change to the code and the .hi and .o were out of date?
09:10:51 <dom96> The memory usage is just crazy
09:11:01 <dom96> no
09:11:52 <Cale> Can I see the code? Is it easy to get running?
09:12:06 <dom96> http://github.com/dom96/ElysiaBot
09:12:12 <dom96> yeah
09:12:20 <dom96> just edit the .ini file
09:12:24 <dom96> which has all the settings
09:12:30 <dom96> and compile
09:22:51 <greap> Is there a way to avoid the duplicate instance declaration error if one of the declarations is more specific? For example (Num a, Bounded a) and (Num a)?
09:23:31 <Saizan> contexts are not taken in consideration at all
09:23:33 <kmc> nope, in fact instance duplication/overlap is determined entirely by the head and not the context
09:23:49 <kmc> instances look deceptively like a backtracking logic programming system (and this comparison is encouraged in various places)
09:24:02 <kmc> but in fact instances are chosen entirely by their heads
09:24:23 <kmc> then it will attempt to solve the context required by that instance, and fail if it cannot do so
09:24:50 <kmc> greap, consider a newtype wrapper
09:25:08 <kmc> newtype Foo a = Foo a; instance (Num a, Bounded a) => C (Foo a)
09:25:22 <Cale> dom96: errr, which package is Network.SimpleIRC in? I don't see it on Hackage.
09:25:41 <dom96> Cale: oh, i forgot. http://github.com/dom96/SimpleIRC
09:26:04 <greap> kmc: Yeah, I can do that, but I was trying to make a nice numeric class based on Maybe that would prevent division by zero, and thought I might somehow be able to add in overflow protection too.
09:26:48 <kmc> so you wanted an instance for Maybe?
09:27:24 <Cale> Oh, this depends on GHC 6.12. Hmm...
09:27:28 <greap> Yes, I've written the Maybe instance but it is (Num a => instance Num (Maybe a)) and I don't want to lose the genericness.
09:27:43 <kmc> yeah, i think making your own newtype is definitely the right answer
09:27:44 <Cale> Perhaps I should just switch back to 6.12 on this machine, as I don't really build stuff for work here anyway.
09:28:01 <kmc> for a lot of reasons
09:28:11 <kmc> for one you're created orphaned instances for Maybe
09:28:12 <greap> kmc: Yeah. I think I'll take that route. Thanks for the help :)
09:28:21 <Jafet> Just make inductive integers on NonEmptyList!
09:28:40 <Cale> I like how the top result in Google for 6.12 is Haskell-related.
09:28:44 <greap> Jafet: I don't know what that means, but I suspect it is a joke :P
09:29:12 <kmc> :t In . Just . In . Just . In $ Nothing
09:29:13 <lambdabot> Mu Maybe
09:29:19 <kmc> ^^^^ two
09:29:36 <greap> @hoogle In
09:29:37 <lambdabot> Network.Socket iN6ADDR_ANY :: HostAddress6
09:29:37 <lambdabot> Network.Socket iNADDR_ANY :: HostAddress
09:29:37 <lambdabot> Text.Parsec incSourceColumn :: SourcePos -> Column -> SourcePos
09:29:39 <kmc> @src Mu
09:29:40 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
09:29:42 <dom96> Cale: My python IRC Bot uses only 3.4MB of ram. And it has like 7 modules loaded.
09:30:04 <dom96> what a pity.
09:30:06 <Cale> dom96: Well, GHC is big.
09:30:42 <dom96> yeah, i know. But this still doesn't explain the issue of reloading. Why does the memory usage increase?
09:30:46 <Cale> Though, I'm not sure how much of that memory is GHC and how much is dependencies.
09:30:59 <Cale> If you're actually leaking memory, that's another thing.
09:31:42 <dom96> I don't think i am. I already asked about this problem here. People told me to profile my code, i tried that and found a ghc bug while doing it.
09:33:04 <Cale> I can understand it if unloading a module doesn't allow the OS to reclaim memory, but reloading the module after shouldn't take more, I'd think.
09:33:19 <dom96> indeed
09:34:01 <Jafet> If you have enough memory, there's always valgrind
09:34:42 <br1> I have trouble understanding forall.  What's the difference between these two declararions: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29358
09:35:25 <Saizan> dom96: maybe you're still holding to the old ghc state? the one kept via the GhcMonad class? ghci had a bug like that.
09:35:57 <dom96> Saizan: maybe, I don't even know how i would check if i do.
09:36:05 <Cale> br1: In the first, the field f1 can have a value of any type at all (and this type is forgotten)
09:36:25 <Cale> br1: In the second, the field f1 must have a value of polymorphic type
09:36:40 <h0ho> !books
09:36:40 <Cale> (and pretty much must be undefined then)
09:36:50 <Cale> @where lyah
09:36:50 <lambdabot> http://www.learnyouahaskell.com/
09:36:52 <Cale> @where rwh
09:36:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:36:56 <Cale> @where wikibook
09:36:56 <lambdabot> http://en.wikibooks.org/wiki/Haskell
09:37:03 <Cyaxares> !books
09:37:04 <h0ho> ah thanks Cale :D
09:37:07 <Saizan> dom96: can you compile with profiling enabled? otherwise you could run with +RTS -hT to at least get some info about the heap
09:37:29 <dom96> Saizan: I can't. If i compile with profiling enabled i get a PAP Error
09:37:45 <Saizan> try +RTS -hT then
09:37:46 <Cale> h0ho: see also: http://www.haskell.org/haskellwiki/Books_and_tutorials
09:37:57 <dom96> it doesn't matter what i try
09:38:11 <dom96> hint just doesn't like being profiled
09:38:21 <Saizan> "+RTS -hT" works without enabling profiling.
09:38:22 <dom96> I already reported a ghc bug for that
09:38:32 <dom96> hrm
09:38:54 <dom96> Saizan: i see. 
09:40:12 <dom96> Saizan: so what do i do with that .hp file ? convert it to a graph using hp2ps ?
09:40:21 <Saizan> dom96: yes
09:40:29 <Saizan> -c for colors.
09:40:43 <harlekin> Could it be that the reactive mailing list is inactive? I sent a message a few days ago, but neither have got a reply nor is my message in listed in the archives.
09:41:24 <Cale> harlekin: I haven't seen any development on reactive in quite some time now, but Conal hangs around here, and he'd be the one to talk to.
09:41:32 <br1> Cale: Thanks.  D2 fixed my type errors, but you are right in that I can't create D2 instances.  I'll think about this some more.
09:41:35 <Cale> preflex: seen Conal
09:41:35 <preflex>  Conal was last seen on #haskell 4 hours, 58 minutes and 44 seconds ago, saying: type families gave a wonderful boost to haskell's expressiveness
09:41:55 <Cale> br1: Neither of those types is useful.
09:42:07 <Cale> (for anything)
09:42:08 <harlekin> Cale, thanks. I try talking to him.
09:42:12 <dom96> Saizan: so what am i suppose to do with this graph?
09:42:22 <Cale> harlekin: reactive is in a pretty unusable state at present
09:42:43 <Cale> harlekin: Which is sad, because it's a pretty cool library.
09:42:51 <harlekin> Cale, is there any other FRP implementation that's better suited to do actual (fun) projects.
09:43:03 <harlekin> Cale, agree. ):
09:43:28 <Cale> harlekin: Sadly, the only library I know of which has had any success in actual implementation is Yampa, but I don't actually *like* Yampa all that much.
09:43:32 <harlekin> I was just hoping things get fixed soon since I read about a ghc RTS bug which caused many of them.
09:44:05 <harlekin> Cale, is it all that different? I haven't tried Yampa yet, mostly because I haven't learnt how to use the proc notation for arrows.
09:44:19 <Cale> Yampa is extremely different from Reactive.
09:44:34 <br1> Cale: I think I want D1.  In my actual code f1 is Tree a where Tree is a gadt.
09:44:44 <dom96> Saizan: apparently, base:GHC.ForeignPTR.MallocPTR uses the most mem
09:44:59 <Cale> br1: Well, that might be more useful, yeah.
09:45:58 <dom96> Cale: so did you try my bot?
09:46:14 <br1> Cale: yeah, but then ghc won't let me use record accesors
09:46:16 <Cale> dom96: Just changed GHC versions, building deps :)
09:46:33 <dom96> Cale: ok, let me know when you try it :)
09:46:47 <Saizan> dom96: that'd help if we knew what it is :)
09:46:52 <Cale> dom96: I had GHC 6.10 installed, since that's what I'm using for work, but I don't really need to build stuff for work on this machine anyway.
09:47:00 <monadic_kid> what about elerea and peakachu?
09:47:20 <dom96> Cale: ok
09:47:33 <dom96> Saizan: yeah lol
09:47:51 <Cale> br1: Well, record accessors for GADTs/existentials are somewhat impossible without first-class existential types.
09:48:05 <Cale> br1: So give up on that for now, and just use case expressions :)
09:48:11 <Cale> (or otherwise pattern match)
09:48:45 <br1> Cale: OK
09:48:57 <dom96> Saizan: http://imagebin.ca/view/5UqPZb5d.html
09:49:54 <dom96> There is two yellows...
09:50:24 <Cale> The legend is ordered the same way as the graph
09:50:34 <Cale> So most of your heap is list cons cells.
09:51:46 <Cale> (Followed by what looks like finite map nodes, in GHC's internal finite map implementation)
09:52:29 * dom96 has no idea what any of those are
09:52:31 <dom96> lol
09:53:02 <Cale> The stuff that's marked ghc-6.12.3 is the GHC API (which is used via hint)
09:53:20 <Cale> ghc-prim is GHC's implementation of mostly prelude stuff
09:53:20 <dom96> oh
09:53:35 <RayNbow> let module B = Foo.Bar in B.quux  -- is there a Haskell proposal for this kind of syntax?
09:53:47 <Cale> (GHC.Types.:) is just the qualified name of (:)
09:53:56 <Cale> (the list constructor)
09:54:45 <Saizan> so it might indeed be what i suspected
09:54:47 <Cale> I don't know what the difference between THUNK and THUNK_2_0 is, but those are presumably representations of unevaluated expressions.
09:54:54 <monochrom> > let module B = Nothing in module B
09:54:55 <lambdabot>   <no location info>: parse error on input `module'
09:55:13 <Cale> MUT_VAR_CLEAN would be mutable cells (like what's behind IORefs)
09:55:33 <dom96> What's OccName.OccName then?
09:55:33 <Cale> But that's down far enough that you don't even need to care :P
09:55:40 <dom96> it's using the most memory i presume
09:55:44 <Cale> No
09:55:52 <Cale> The thing which is using the most memory is the one at the top
09:55:56 <Cale> (:)
09:56:03 <dom96> the list constructor 0_o
09:56:06 <Cale> Yep
09:56:08 <monochrom> oh, "module" is a reserved word
09:56:10 <dom96> how could that be using the most memory?
09:56:16 <Cale> Which just means that most of the memory is taken by lists.
09:56:26 <Cale> Very easily.
09:56:37 <Cale> Strings are lists too, mind.
09:56:45 <dom96> yeah, i know.
09:56:59 <dom96> I'm using ByteStrings quite a lot though
09:57:07 <Cale> Okay, so not that :)
09:57:46 <Cale> These could also be lists which are built as part of the process of bytecode compiling and interpreting those modules.
09:58:03 <Cale> Or they could be lists created by your program.
09:58:03 <dom96> oh
09:58:33 <dom96> Well this doesn't really tell me how i would fix this memory problem
09:58:39 <monochrom> OccName.OccName stores identifiers in the GHC API
09:59:10 <Cale> It might be more interesting to look at a longer time frame. This looks like an initial startup followed by immediately killing the program?
09:59:42 <Cale> (It ran for a total of one second?)
09:59:52 <dom96> i didn't kill it immediately
09:59:56 <Cale> Okay
10:00:01 <dom96> it ran for at least 3 minutes
10:00:05 <Cale> err...
10:00:07 <dom96> i did some |reload
10:00:15 <Cale> Somehow that's not reflected at all in the profile.
10:00:26 <dom96> maybe the profile doesn't get saved...?
10:00:28 <Cale> (look at the horizontal axis)
10:00:30 <Cale> yeah, hmm
10:00:35 <aristid> hmm -Wall is great, but in ghci it can be slightly annoying when every defaulting gives a warning
10:00:37 <dom96> it says '--cached' at the beginning
10:00:41 <dom96> so...
10:00:43 <aristid> is there a way to deal with this?
10:00:47 <dom96> Any ideas how to make it save?
10:00:49 <monochrom> so don't use -Wall in ghci
10:01:50 <Cale> aristid: I never use -Wall myself.
10:02:09 <Cale> It includes a bunch of types of warnings which are just obnoxious.
10:02:32 <monochrom> but the GHC user guide has the complete list of how to turn off warnings.
10:02:43 <greap> I can't figure out why the newtype wrapper isn't compiling so far http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29361#a29361 When I set return to undefined it type-checks...
10:02:59 <dom96> would calling a quit function instead of killing the program help?
10:03:02 <aristid> Cale: what do you use instead?
10:03:24 <Cale> aristid: Usually nothing. The default warnings are enough for me, whatever they are.
10:03:25 <aristid> Cale: -Wall already helped me find a bug, so i want to keep at least most of it
10:03:54 <Cale> I suppose it might be nice to have pattern completeness checking on, but that seems buggy anyway.
10:04:09 <Saizan> dom96: remove "(Bounded n, Num n) =>" from the definition of Overflowable, otherwise O requires 'n' to be Num and Bounded, and the type of return doesn't let you require those constraints
10:04:30 <dom96> whoa what?
10:04:34 <monochrom> s/dom96/greap/
10:04:44 <dom96> oh
10:04:46 <Saizan> ah, sorry
10:04:55 <Saizan> greap: that was for you ^^^^
10:05:08 <aristid> Cale: actually it found two bugs... one related to non-exhaustive patterns, and the other related to an unused parameter
10:05:47 <Saizan> greap: also, if you want Overflowable to behave as the Maybe monad you can add {-# LANGUAGE GeneralizedNewtypeDeriving #-} (assuming i got the name right) and just add Monad to the deriving clause
10:05:59 <greap> Saizan: Ah great! For some reason I required that restriction before to allow deriving, but it doesn't look like I need it anymore :)
10:06:24 <greap> Saizan: Really? Awesome!
10:06:43 <dom96> Cale: any ideas?
10:06:52 <Cale> dom96: users.ini doesn't exist
10:06:54 <Saizan> greap: yep, it's quite nice :)
10:07:06 <Cale> dom96: Should I put anything in it?
10:07:39 <greap> Saizan: It's like magic. I suppose it only works for newtypes though right?
10:07:56 <dom96> Cale: just put. [test] \n pass = test \n admin = True
10:08:04 <dom96> where \n is a newline ;)
10:09:32 <Saizan> greap: yes, it lifts instances from the newtyped type to the wrapper, unless you are using quite complicated types where it's not clear (to GHC at least) how to do so
10:13:41 <greap> One more question... How would I define minBound? It takes no arguments, so presumably I use it like (minBound :: Int), but the Bounded instance has no type variable.
10:14:14 <RayNbow> :t minBound
10:14:15 <lambdabot> forall a. (Bounded a) => a
10:15:20 <monochrom> define? like instance Bounded MyType where minBound = blah?
10:16:46 <greap> monochrom: Yes.
10:17:27 <nschoe> Hi Haskellers
10:17:40 <Saizan> greap: instance Bounded n => (Overflowable n) where minBound = O minBound; maxBound = O maxBound
10:18:10 <greap> Saizan: Ah, I have to repack it. Of course
10:18:12 <Saizan> ah, you need to add Just
10:18:36 <Saizan> unless Maybe has an instance for Bounded too..
10:19:21 <monochrom> > minBound :: Maybe Int
10:19:22 <lambdabot>   No instance for (GHC.Enum.Bounded (Data.Maybe.Maybe GHC.Types.Int))
10:19:22 <lambdabot>    aris...
10:19:47 <monochrom> > minBound :: ()
10:19:48 <lambdabot>   ()
10:19:53 <monochrom> :)
10:20:07 <greap> Yay. Thanks a bunch guys!
10:20:25 <greap> #haskell really is the best channel I've ever used <3
10:22:12 * Saizan feels used now
10:22:23 <dom96> lol
10:22:48 <aristid> Saizan: not a problem, you can be recycled, and we will even get 25 cents for you
10:23:33 <Saizan> aristid: oh, really? ok then
10:23:58 <aristid> i <3 TimeZoneSeries
10:28:06 <nschoe> Is there anyone who could help me getting gtk2hs on my archlinux please? I've been going through hell for two days, some help would be greatly appreciated^^
10:29:45 <Lemmih> nschoe: Post error messages, receive help.
10:30:07 <kmc> 25¢ deposit on Haskellers?
10:30:08 <kmc> hot damn
10:30:11 * kmc runs to redeem himself
10:30:43 <aristid> kmc: euro cent, actually
10:30:54 <nschoe> Lemmih: I've tried so many things, so many error messages. For now, I've cleaned the whole thing, and currently I have ghc 6.12.3 installed as well as cabal-install. Now I wonder should I do next.
10:31:22 <Lemmih> nschoe: cabal install gtk2hs?
10:31:46 <kmc> is there a symbol for €0.01?
10:32:07 <nschoe> Lemmih: Just before I issue that command, I'd like to know: which one should I install first with my package manager: gtk and/or gtk2? For the moment I have both installed.
10:32:46 <kmc> i guess 'c' is more common
10:33:07 <aristid> kmc: ct is the official abbreviation
10:34:08 <Lemmih> nschoe: is 'gtk' gtk version 1?
10:34:44 <Lemmih> nschoe: Knowing nothing about arch packages, I'd go with gtk2.
10:35:30 <nschoe> Lemmih: Yeah 'gtk' is gtk version 1. I think it's not really used. The packages refer to the 2 mains versions of gtk.
10:49:59 <KitB> Whenever I try to install glade from cabal I get the "gtk2hsc2hs is required but it could not be found" error
10:50:12 <KitB> How on earth can I get around this?
10:50:25 <dcoutts> KitB: cabal install gtk2hs-buildtools
10:50:25 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
10:50:38 <dcoutts> KitB: cabal doesn't track deps on tools yet, only libs
10:51:23 <KitB> dcoutts: I have that installed
10:51:29 <KitB> I think
10:51:34 <dcoutts> KitB: perhaps not on your $PATH
10:51:41 <KitB> I was having issues with it not finding alex
10:52:03 <KitB> It's in /usr/local/bin/
10:52:16 <KitB> I'll check o see if that's in my path :P
10:52:38 <nschoe> KitB: Did you add you .cabal/bin to your PATH? I had this error before I do so.
10:53:39 <KitB> I've been installing things with --global
10:53:48 <KitB> So they're in /usr/local/bin
10:53:53 <KitB> Which might not be in my path
10:54:04 <KitB> This is a fresh arch install, so I don't have any path exports
10:54:25 <nschoe> KitB: echo $PATH and you'll see.
10:58:32 <nschoe> When I 'cabal list | grep -i glade' I have two different things: "glade" and "gtk2hs-cast-glade": Which one should I install, and what's the difference between the two please?
10:59:44 <dcoutts> nschoe: "cabal list glade" should help, and use "cabal info" for more details on each one.
10:59:55 <dcoutts> nschoe: or use the hackage website
11:00:58 <nschoe> dcoutts: Yeah, thanks. Sorry for asking, I did 'cabal info glade' and I saw it provided the packages that I needed. Sorry for asking-then-tried I should have done the converse :/
11:01:10 <dcoutts> np :-)
11:02:10 <nschoe> Lol, thanks, everything is installed now... I dunnow what I did wrong before, but now it seems to be okay :p
11:20:25 <aristid> hmm yitzchak gale's olson parser seems to have a bug :/
11:20:46 <Cale> Anyone here who is familiar with the GHC API and can help tell if there's a memory leak in hint? It looks as if runInterpreter creates a new GHC session and never cleans it up, resulting in an ever expanding amount of memory usage. But I don't know what might be necessary to clean up.
11:21:04 <Cale> (when runInterpreter is used multiple times)
11:21:20 <c_wraith> I should really do research on that, myself.
11:21:41 <c_wraith> I know a bit about the ghc api and hint, though.
11:21:58 <c_wraith> I don't *think* it has an inherent memory leak.
11:22:15 <Baughn> Hang on, I'll check. :)
11:23:50 <nschoe> Bye all, thanks for your help!
11:24:07 <Baughn> Cale: Nope, memory use isn't increasing a bit.
11:24:12 <Cale> Baughn: hmm
11:24:17 <Baughn> forever $ runInterpreter (eval "2" :: InterpreterT IO String)
11:24:28 <Baughn> Wait..
11:24:45 <Baughn> Eep
11:25:28 <Baughn> Cale: It's leaking. I think this falls into "too slow to be noticable" territory", but it's leaking.
11:25:36 <Baughn> Also, ctrl-c isn't working.
11:25:46 <Cale> Baughn: Try loading some modules, like Data.ByteString :)
11:25:58 <dom96> That explains the problems with my IRC Bot
11:26:00 <Baughn> No, I mean ctrl-c isn't working.
11:26:06 <Cale> Yeah, I noticed that too
11:26:08 <c_wraith> ctrl-c doesn't work because the ghc api mangles it
11:26:11 <Cale> Ctrl-Z and kill %1
11:26:18 <Baughn> SIGTERM also isn't working.
11:26:23 <Cale> Er, kill -9 ;)
11:26:25 <Veinor> Ctrl-\ doesn't work either?
11:26:29 <Baughn> SIGKILL did. :)
11:26:30 <Baughn> Veinor: Right
11:26:43 <c_wraith> JaffaCak said he'd fix the ghc api behavior for 6.14
11:26:48 <c_wraith> err, jaffacake
11:27:15 <c_wraith> the ghc api sets signal handlers when its run
11:27:19 <Baughn> dom96: My intuition claims that the leak is so slow that it probably /doesn't/ explain your leak, but that was for 'eval 2'. I could be wrong.
11:27:23 <c_wraith> for TERM, QUIT, INT, and something else
11:27:34 <c_wraith> And if there are threads involved, the handlers it sets are wrong
11:27:38 <c_wraith> and it doesn't clean them up.
11:27:49 <dom96> Baughn: do what Cale said, try importing ByteStrings. That will make the leak bigger.
11:28:35 <Cale> dom96's code loads several packages every time (including containers and bytestring)
11:28:55 <Cale> and the memory corresponding to them never seems to get freed
11:29:06 <Baughn> Yes, why doesn't the GC take care of that?
11:30:30 <Cale> Baughn: I don't know. I assume it has something to do with GHC sessions involving some sort of low-level allocation which requires corresponding manual freeing.
11:31:05 <Cale> But I'm pretty unfamiliar with the GHC API.
11:32:31 <Cale> This behaviour would make sense if each interpreter's heap wasn't being deallocated.
11:51:32 <pnicholson> what is the best way insert the current time in a sql string
11:51:33 <pnicholson> ?
11:52:39 <writer> use SQL's current DATETIME functions
11:53:35 <pnicholson> I don't want the time on the sql server, I want the current time on the box running program
11:54:58 <c_wraith> If those are different, I recommend crying.
11:55:03 <c_wraith> and then using ntp
11:55:15 <pnicholson> they are and the sql server is not mine
11:55:16 <arw_> there could be a time zone difference.
11:55:26 <arw_> even if using ntp
11:55:26 <pnicholson> I can't change the time on it
11:55:33 <c_wraith> You should always be storing the UTC time in the database, anyway
11:55:47 <kmc> most sql libraries allow you to put in placeholders when you compile a query and fill them in when you execute it
11:56:11 <pnicholson> right but how would you get the current time in haskell
11:56:20 <c_wraith> look in the time package
11:56:25 <kmc> oh, so the question actually has nothing to do with SQL?
11:56:33 <c_wraith> @hackage time
11:56:33 <lambdabot> http://hackage.haskell.org/package/time
11:56:55 <c_wraith> :t Data.Time.Clock.getCurrentTime
11:56:56 <lambdabot> IO time-1.1.4:Data.Time.Clock.UTC.UTCTime
11:57:20 <pnicholson> ok so that would give me utc time
11:57:20 <c_wraith> Well, that was the least useful output lambdabot could have provided while remaining correct :)
11:57:29 <pnicholson> perfect
11:57:45 <pnicholson> and toSql will convert that?
11:57:51 <c_wraith> probably
11:57:56 <c_wraith> I tend not to use toSql
11:58:03 <c_wraith> I think Convertible is a horrible interface
12:00:02 <c_wraith> But SqlValue has a constructor that takes UTCTime directly, SqlUTCTime
12:00:18 <pnicholson> ok
12:00:19 <c_wraith> So the odds that it's supported by toSql are very high
12:04:51 * hackagebot ipatch 0.1 - interactive patch editor  http://hackage.haskell.org/package/ipatch-0.1 (JoachimBreitner)
12:11:31 <calsaverini> hi there
12:11:49 <calsaverini> is there any combinator on Parsec that will match anything?
12:11:56 <copumpkin> ddarius: I enjoyed the article, although some parts of it were over my head :) do you plan on finishing and releasing it?
12:12:05 <calsaverini> Or better: anything but a list of combinators?
12:13:38 <ddarius> calsaverini: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html  It a bit out of date, but most of it should apply with the exception of the module names.  Certainly it will explain the ideas and the main combinators.
12:14:07 <ddarius> copumpkin: I want to make it a bit more stand-alone.  Sooner or later I'll finish it.
12:14:29 <b0fh_ua> Hello! I have url-encoded string, with dataenc I can decode it into [Word8] - but how do I create a String from that list?
12:17:01 <kmc> calsaverini, i'd look at http://hackage.haskell.org/package/parsec, in particular the 'Combinator', 'Prim', and 'Char' modules
12:17:28 <kmc> you might be able to do what you want with lookahead
12:20:49 <Raghs> what does "let" do in the do notation?
12:21:20 <aristid> Raghs: just syntactic sugar for let ... in
12:21:48 <aristid> @undo do x <- return 1; let y = x + 1; return y
12:21:48 <lambdabot>  Parse error at end of input
12:22:08 <aristid> *scracth head*
12:22:12 <Botje> put {} around it
12:22:20 <aristid> @undo do { x <- return 1; let y = x + 1; return y }
12:22:20 <lambdabot>  Parse error at "}" (column 45)
12:22:26 <Botje> @undo do { x <- return 1; let y = x + 1; return y; }
12:22:26 <lambdabot>  Parse error at ";" (column 44)
12:22:32 <Botje> buh :p
12:23:32 <aristid> @undo do { x <- return 1; return x }
12:23:33 <lambdabot> return 1 >>= \ x -> return x
12:23:44 <aristid> hmm maybe @undo can't deal with let?
12:24:51 <itsmonktastic> you can't do a do and a let in one line I believe.
12:25:22 <aristid> :t do x <- return 1; let y = x + 1; return y
12:25:23 <lambdabot> parse error (possibly incorrect indentation)
12:25:29 <aristid> :t do { x <- return 1; let y = x + 1; return y }
12:25:30 <lambdabot> parse error on input `}'
12:25:37 <aristid> oO
12:26:40 <ski> @undo do x <- return 1; let {y = x + 1}; return y  -- obviously ;)
12:26:40 <lambdabot> return 1 >>= \ x -> let { y = x + 1} in return y
12:26:55 <itsmonktastic> hahaha
12:27:01 <ski> (`let {y = x + 1; return y}' is a syntax error)
12:27:22 <aristid> ouch :(
12:27:41 <aristid> ski: one advantage of lisp's syntax :D
12:27:44 <itsmonktastic> > do x <- [1]; let {y = x+1}; return y
12:27:45 <lambdabot>   [2]
12:27:55 <itsmonktastic> >.<
12:28:05 <aristid> itsmonktastic: it's monktastic
12:28:12 <ski> aristid : the advantage being more explicit nesting ?
12:28:13 <kmc> preflex, zdec utf8zmstringzm0zi3zi6_DataziByteStringziUTF8_zdwlineszq_entry
12:28:13 <preflex>  utf8-string-0.3.6_Data.ByteString.UTF8_$wlines'_entry
12:28:17 <aristid> ski: yeah
12:28:35 <aristid> kmc: oh, that's a beautifully mangled name :P
12:33:36 <ddarius> aristid: It's pretty common to miss paretheses in the Lisps' let syntax as well.
12:33:53 <aristid> ddarius: hmm.
12:34:09 <ddarius> (let (x 3) x) ; syntax error
12:34:24 <aristid> (let ((x 3)) x) it was, right?
12:34:26 <kmc> but i thought lisp has no syntax
12:34:29 <kmc> how is a syntax error possible?
12:34:32 <kmc> [/reddit troll]
12:34:45 <aristid> kmc: what does it mean?!
12:38:30 <ddarius> edwardk: What have you been up to?
12:40:59 <djahandarie> Okay I'm for sure going to be at Boston Haskell tomorrow
12:41:09 <kmc> yay djahandarie
12:41:11 <kmc> see you there
12:41:21 <kmc> i hope i'll have something good to present
12:41:35 <djahandarie> Haha, should you be hoping one day before? :P
12:42:00 <kmc> i have some bits of code
12:42:08 <kmc> will slap them onto slides
12:42:18 <itsmonktastic> boston? that's totally far away from coventry :(
12:42:31 <kmc> it will be an open-ended "audience participation" sort of talk
12:42:43 <copumpkin> omg so many people at boston haskell now that I've left :(
12:42:57 <djahandarie> itsmonktastic, I'm going up from Storrs
12:43:23 <ddarius> kmc is trying to pull off that lazy lecturer joke.  Lecturer stands up.  "Questions?"
12:43:49 <djahandarie> A lazy lecturer... nothing gets said until a student asks a question
12:44:08 <Martty> that's wrong
12:44:12 <Martty> we live in a monad
12:44:44 <ddarius> I live in an apartment.
12:44:56 <djahandarie> ddarius, there's a monad instance for that!
12:46:17 <aRcatan> we eat monads
12:46:21 <ddarius> I would like to see an Apartment of Apartments of Tigers.
12:50:27 <kmc> monads aren't un-lazy
12:51:21 <copumpkin> indeed! my monads are very hard-working
12:51:54 <ddarius> copumpkin is intuitionistic and doesn't do double negation elimination.
12:52:03 <djahandarie> laff
12:52:25 <copumpkin> ;)
13:12:44 <cncl> is copumpkin the dual to a pumpkin
13:13:50 <copumpkin> cncl: yeah
13:27:14 * hackagebot uu-parsinglib 2.5.5 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.5 (DoaitseSwierstra)
13:27:25 <copumpkin> pretty quiet in here today
13:28:10 * dom96 shouts
13:28:15 <dom96> not quiet anymore
13:33:05 <BCoppens> how do I convert a UTCTime to a CTime?
13:37:43 <aristid> BCoppens: this should help: http://hackage.haskell.org/packages/archive/time/1.2.0.3/doc/html/Data-Time-Clock-POSIX.html
13:39:05 <BCoppens> aristid: yeah I've looked at that, but it only says sth about the conversion *from* CTime :)
13:40:19 <aristid> BCoppens: try round . utcTimeToPOSIXSeconds
13:40:34 <aristid> :t round
13:40:34 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:41:44 <aristid> :t floor
13:41:45 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:42:12 <ski> @type ceiling
13:42:13 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:42:15 <ski> @type truncate
13:42:16 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:43:26 <yitz> @check \x -> floor x == truncate x
13:43:27 <lambdabot>   "Falsifiable, after 3 tests:\n-1.75\n"
13:43:35 <yitz> ah
13:44:03 <yitz> > (floor(-1.2), truncate(-1.2))
13:44:04 <lambdabot>   (-2,-1)
13:44:52 <dolio> @check \x -> (floor x <= truncate x) && (truncate x <= ceiling x)
13:44:53 <lambdabot>   "OK, passed 500 tests."
13:45:53 <ski> > round `map` [1 % 2,3 % 2]
13:45:54 <lambdabot>   [0,2]
13:46:13 <ski> > round `map` [0.5,1.5]
13:46:14 <lambdabot>   [0,2]
13:46:26 <dmwit> > round . [0.5, 1.5]
13:46:26 <lambdabot>   [0,2]
13:46:58 <dmwit> > succ . round . [0.5, 1.5]
13:46:59 <lambdabot>   [1,3]
13:47:02 <yitz> > let cale = (.) in round `cale` [0.5, 1.5]
13:47:03 <lambdabot>   [0,2]
13:47:38 <ski> > [round,floor,ceiling,truncate] `flip` (-1.5)
13:47:39 <lambdabot>   [-2,-2,-1,-1]
13:47:39 <ski> > [round,floor,ceiling,truncate] `flip` (-2.5)
13:47:40 <lambdabot>   [-2,-3,-2,-2]
13:47:50 <aristid> yitz: are you yitzchak gale? :)
13:47:57 <dmwit> :t flip
13:47:58 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:47:59 <yitz> aristid: yes
13:48:09 <yitz> aristid: glad to meet you :)
13:48:39 <dmwit> flip somehow doesn't seem like the right name for that
13:48:49 <ski> > [round,floor,ceiling,truncate] `Data.Traversable.sequenceA` (-2.5)
13:48:50 <lambdabot>   [-2,-3,-2,-2]
13:49:10 <ski> dmwit : well, it's a valid generalization (similar to the `(.)' one)
13:49:11 <aristid> yitz: cool, have you got my mail about the problem with timezone-olson?
13:49:15 <dmwit> :t flip (fmap . ($))
13:49:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
13:49:18 <dmwit> ski: Of coruse.
13:49:35 <yitz> aristid: oh, no. to the list, or to me direct?
13:49:42 * yitz checks
13:49:42 <aristid> yitz: direct
13:49:57 <ski> (i.e, you can as well argue that `(.)' (or the traditional function composition circle) is not the right name for `fmap')
13:49:59 <aristid> should i have sent it to the list?
13:50:45 <dmwit> ski: No, I don't agree. (.) has a good interpretation as functor composition.
13:51:01 <dolio> (.) = fmap isn't functor composition.
13:51:11 <yitz> aristid: found it in the spam. urgh. dusting it off.
13:51:17 <aristid> :(
13:51:23 <yitz> aristid: thanks, looking forward to reading it
13:51:31 <ski> yeah .. but how does that connect with using `f . as' with `f : A >-> B' and `as : F A' ?
13:51:53 <dmwit> I take it back.
13:52:33 <aristid> yitz: the olson format seems to be ... unfriendly
13:53:11 <ski> > let it = 3  in  take it "back"
13:53:12 <lambdabot>   "bac"
13:53:19 <dolio> Perhaps you could build some argument about how in category theory, 'application' is taken to be a special case of composition, so we're inverting the relationship somehow.
13:53:43 <dolio> But, I wouldn't expect that to be very convincing.
13:54:11 <yitz> aristid: oh wow that looks really confused
13:54:49 <yitz> aristid: and for CET, too! thanks much for the report, I'll have a look
13:54:59 <copumpkin> I think Cale's main argument for (.) = fmap is convenience, not mathematically justified notation
13:55:36 <aristid> yitz: ok, cool, if i can help somehow please let me know
13:56:09 <yitz> aristid: thanks!
13:56:54 <yitz> aristid: the olson format is a classic C binary hack. beautiful in its own ugly way.
13:57:37 <BCoppens> aristid: cool, thanks
13:58:56 <aristid> yitz: i suppose it has to be like that because glibc reads it whenever a program needs timezones
14:00:44 <ski> (copumpkin : yeah .. my point was just that you could use that argument for `flip', as well)
14:01:09 <yitz> aristid: not just glibc, the C libs on every Unix-like platform that ever was.
14:01:38 <yitz> aristid: I think if it were designed from scratch today for glibc, it would turn out much differently.
14:02:16 <aristid> yitz: it would be less painful if glibc provided a reasonable API
14:02:52 <yitz> aristid: yeah, that's another problem.
14:03:25 <calsaverini> @src const
14:03:25 <lambdabot> const x _ = x
14:03:38 <yitz> aristid: but again, the idea is that works exactly the same everywhere. and everywhere means really, really everywhere.
14:03:46 <yitz> aristid: so there's no changing it now.
14:03:50 <ski> @type everywhere
14:03:51 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
14:04:55 <yitz> ski: in this case we have *preserve* your boilerplate though
14:04:59 <aristid> yitz: yeah, and the best thing is that it is automatically updated with the operating system, so you don't get outdated definitions... :D
14:06:59 <aristid> ski: what does everywhere do?
14:07:18 <ski> apply the argument function everywhere ?
14:07:35 <lispy> what is a normal pattern match failure converted to?
14:07:40 * ski has no idea of whether it is top-down, bottom-up, or both, though
14:07:44 <lispy> > let foo 1 = 2 in foo 2
14:07:45 <lambdabot>   *Exception: <interactive>:1:149-157: Non-exhaustive patterns in function foo
14:08:00 <lispy> > error "<interactive>:..."
14:08:01 <lambdabot>   *Exception: <interactive>:...
14:08:04 <lispy> cool
14:08:05 <kmc> > fix error
14:08:06 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:08:40 <yitz> > fix (error . show)
14:08:41 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
14:08:47 <dolio> ski: Bottom-up, I think. ndm has a blog post about everywhere' which is top-down and why it's not a great idea.
14:08:52 <ski> aristid : i actually don't recall that much about SYB ..
14:08:54 <yitz> > fix (show . error)
14:08:55 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:09:12 <dolio> At least, I think it's everywhere'.
14:09:22 <dmwit> > let foo x = case () of () | x == 1 -> 2 in [foo 1, foo 2]
14:09:23 <lambdabot>   [2,*Exception: <interactive>:1:161-187: Non-exhaustive patterns in case
14:09:29 <ski> preflex: xseen ndm
14:09:29 <preflex>  Sorry, I haven't seen ndm
14:09:56 <yitz> preflex help xseen
14:09:56 <preflex>  xseen NICK - report when a user has been seen (on any network)
14:10:15 <dolio> @google neil mitchell everywhere uniplate
14:10:15 <lambdabot> http://neilmitchell.blogspot.com/2010/04/dangerous-primes-why-uniplate-doesnt.html
14:10:16 <lambdabot> Title: Neil Mitchell's Haskell Blog: Dangerous Primes - Why Uniplate Doesn't Contain tr ...
14:10:18 <ski> (.. and any channel)
14:10:34 <dolio> Oh, transform'.
14:10:59 <dolio> I guess that's the uniplate name, and everywhere is the SYB name.
14:11:14 <mauke> preflex: seen ndm
14:11:15 <preflex>  ndm was last seen on #haskell 1 year, 105 days, 10 hours, 52 minutes and 34 seconds ago, saying: plus with current compiler technology, it would be slower
14:13:35 <ski> top-down might be useful for `0 * a = 0' kind of things ..
14:14:25 <dolio> I don't doubt it's useful. But it's easy to misuse, too.
14:14:38 <dolio> Easy to write infinite loops, for instance.
14:14:50 <ski> .. yeah
14:18:16 <zonkor> This is weird -- I have a function that imports data from a file into a Map (FilePath -> IO (Map String (Integer, String))). Unless I _print_ the map within the function, it returns an _empty_ map. WTF!?
14:18:44 <mauke> yeah, that makes no sense
14:18:44 <zonkor> Is this related to laziness somehow?
14:18:54 <mauke> are you using hClose?
14:19:05 <zonkor> I'm using withFile in the function.
14:19:21 <mauke> are you using hReadFile?
14:19:25 <mauke> wait
14:19:27 <mauke> hGetContents
14:19:30 <zonkor> No, hGetContents.
14:19:34 <mauke> there's your problem
14:19:42 <mauke> you can't use hGetContents with withFile
14:19:47 <zonkor> No?
14:19:49 <copumpkin> evil lazy IO
14:19:50 <mauke> withFile will hClose the handle for you
14:20:00 <copumpkin> force it, if you really want it
14:20:03 <dolio> Use readFile.
14:20:14 <mauke> readFile is also evil
14:20:20 <zonkor> Is this pitfall documented in System.IO?
14:20:24 * copumpkin is evil
14:20:48 <yitz> is pumpkin coevil?
14:21:08 <FSalad_III> a simple fix would be to use Data.ByteString.hGetContents... 
14:21:21 <FSalad_III> which is teh strict
14:21:31 <FSalad_III> assuming you can easily make use of a bytestring at least
14:21:37 <mauke> zonkor: http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-IO.html#v%3AhGetContents
14:21:53 <zonkor> FSalad_III: Yeah, that would help.
14:22:26 <yitz> zonkor: there are countless pitfalls with lazy IO, it would be impossible to document all of them.
14:22:41 <zonkor> mauke: Thanks. So why is readFine evil too?
14:22:55 <dolio> There's 0 indication that lazy IO is a problem here, except that withFile is closing a handle that shouldn't be closed. So withFile shouldn't be used.
14:22:56 <FSalad_III> it is lazy ;)
14:22:58 <mauke> zonkor: http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-IO.html#v%3AreadFile
14:23:14 <mauke> dolio: it should be closed
14:23:21 <nitnatsnok> hello
14:23:24 <dolio> It will be closed when the map is read.
14:23:36 <nitnatsnok> what char "$" means in Haskell?
14:23:40 <mauke> the file was read (with hGetContents)
14:23:42 <Zao> @src ($)
14:23:42 <lambdabot> f $ x = f x
14:24:06 <Zao> nitnatsnok: a b $ c d e  is like (a b) (c d e)
14:24:07 <chrisf> nitnatsnok: low-precedence function application
14:24:16 <nitnatsnok> Zao: I don't understand because I am not a programmer
14:24:17 <periodic> Anyone have any thoughts on why this code is causing a "stack space overflow"? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29366#a29366
14:24:36 <mauke> nitnatsnok: what kind of answer are you looking for?
14:25:01 <zonkor> What if I want strict IO, but not use a bytestring? How can I force evaluation?
14:25:10 <nitnatsnok> mauke: m.. I just try to configure xmobar in xmonad
14:25:23 <FSalad_III> zonkor: rnf ;)
14:25:35 <mauke> evaluate (length xs)
14:25:36 <copumpkin> nitnatsnok: maybe #xmonad
14:25:44 <FSalad_III> ;) because some people don't like it so much
14:26:03 <Saizan> zonkor: hGetContents h >>= \xs -> length xs `seq` return xs
14:26:03 <nitnatsnok> copumpkin: no
14:26:14 <zonkor> FSalad_III: rnf?
14:26:25 <FSalad_III> zonkor: the method of NFData
14:26:37 <mauke> Saizan: what do you have against evaluate?
14:26:51 <copumpkin> nitnatsnok: $ is explicit function application in haskell. f $ x = f x
14:27:35 <aristid> `id` is explicit function application in haskell. f `id` x = f x
14:27:44 <Saizan> mauke: that i have to import Control.Exception, and that "length xs `seq` return xs" looks nicer than "evaluate (length xs) >> return xs"
14:27:51 <copumpkin> nitnatsnok: so if f x = x + 1, then f $ 1 is 2
14:28:04 <nitnatsnok> copumpkin: and what it for if I can just `f x` ?
14:28:08 <yitz> nitnatsnok: in an xmonad config file, you would usually use # to use less parentheses. Like Zao said above.
14:28:11 <Zao> 22:55 < amphi> put 'avoidStruts $' at the beginning of your layout hook
14:28:17 <Zao> Probably the cause of the question.
14:28:20 <copumpkin> nitnatsnok: it's just a convenience, but you're right, you can just do that in the simple cases
14:28:21 <aristid> :t (`id`)
14:28:22 <lambdabot> parse error on input `)'
14:28:37 <copumpkin> nitnatsnok: it's mostly used as a means to avoid typing lots of parentheses :)
14:28:44 <aristid> :t ?x `id` ?y
14:28:45 <lambdabot> forall t t1. (?y::t, ?x::t -> t1) => t1
14:28:49 <FSalad_III> zonkor: but 'length' is enough here as others said
14:29:22 <FSalad_III> zonkor: 'rnf' is (by convention of how to implement NFData) a deep seq
14:29:41 <zonkor> Great, that worked. I'm using: length p `seq` return p within the IO monad.
14:29:56 <zonkor> p being the lazy data structure.
14:29:56 <copumpkin> zonkor: I wouldn't use length for that
14:30:08 <dmwit> nitnatsnok: If you paste your config and the error to some website, then send a link to #xmonad, I will help you fix your config until it works.
14:30:10 <copumpkin> it will work, but it's kind of a hack :P
14:30:10 <zonkor> copumpkin: Can I use id?
14:30:14 <copumpkin> zonkor: nope
14:30:21 <copumpkin> zonkor: it will only force the spine of the list
14:30:22 <dolio> You don't need to use length. You can just seq the map.
14:30:29 <copumpkin> oh it's a map?
14:30:41 <copumpkin> either way, it'll only force the structure of the map
14:30:42 <mubanga> Hello #Haskell!  I have a question, and the answer to this question is almost certainly "why weren't you paying attention in Math 12" -- Using the functions from Data.List, length $ permutations "ABCD" = 24, length $ subsequences "ABCD" = 16, and length $ subsequences $ permutations "ABCD" = 16,777,216.  Seems to me this should be 384.
14:30:42 <dmwit> Aren't there libraries for explicit deep forcing?
14:30:45 <FSalad_III> forcing the spine is enough to force reading the whole thing though
14:30:52 <zonkor> copumpkin: This is a [(a,b)] from which I'm building a Map.
14:31:10 <FSalad_III> let's "fix" that in the next base ;)
14:31:16 <mauke> > subsequences "AB"
14:31:17 <lambdabot>   ["","A","B","AB"]
14:31:20 <Saizan> length makes most sense only on the input string.
14:31:21 <dmwit> > 2^24
14:31:22 <lambdabot>   16777216
14:31:27 <copumpkin> zonkor: ah :) I just object to length because it isn't forcing the elements, and another function you pass the result to could conceivably not do so either
14:31:27 <dolio> Forcing the structure of the map will almost certainly force the entire string.
14:31:32 <dmwit> mubanga: You should have been paying attention in Math 12.
14:31:41 <copumpkin> dolio: sure, in practice, but it doesn't mean it feels "clean" :P
14:31:41 <dmwit> =)
14:31:47 <zonkor> copumpkin: What would you use in the general case?
14:31:47 <mauke> > subsequences $ permutations "ABCD"
14:31:48 <lambdabot>   [[],["ABCD"],["BACD"],["ABCD","BACD"],["CBAD"],["ABCD","CBAD"],["BACD","CBA...
14:31:59 <nitnatsnok> dmwit: ok, let's try
14:32:01 <copumpkin> zonkor: rnf  or deepseq if you want to force everything
14:32:05 <dmwit> mubanga: There are 24 permutations of ABCD, and so there are 2^24 subsequences of the list of permutations of ABCD.
14:32:06 <FSalad_III> RULES hGetContents h >>= length = fileSize `fmap` hGetFileStatus h
14:32:09 <mauke> > drop 666 $ subsequences $ permutations "ABCD"
14:32:10 <lambdabot>   [["BACD","BCAD","CABD","CDBA","DBCA"],["ABCD","BACD","BCAD","CABD","CDBA","...
14:32:14 <dolio> Yes, well, if you ask me, it'd be clean to just use readFile, and not bother with withFile closing the handle too early.
14:32:22 <FSalad_III> that will "fix" all the programs currently using the length hack to force evaluation, lol
14:32:27 <copumpkin> oh yeah, definitely
14:32:34 <Martty> @hoogle permutations
14:32:34 <lambdabot> Data.List permutations :: [a] -> [[a]]
14:32:49 <zonkor> copumpkin: rnf from Control.Parallel.Strategies? I didn't find deepseq on Hoogle.
14:32:57 <c_wraith> @hoogle deepseq
14:32:57 <lambdabot> No results found
14:33:00 <c_wraith> err
14:33:03 <c_wraith> @hackage deepseq
14:33:04 <lambdabot> http://hackage.haskell.org/package/deepseq
14:33:07 <c_wraith> It's its own package
14:33:16 <dolio> This entire conversation is like, "I'm opening a handle in one thread, and spawning a new thread to work on it, but the original thread closes the handle too early." and everyone telling him, "you should read in the entire string in the original thread before forking."
14:33:21 <yaru1022> has anybody read John Millikin's enumerator package source code? (or http://ianen.org/haskell/enumerator/enumerator.pdf)
14:33:25 <copumpkin> dolio: lol
14:33:35 <ski> > length $ subsequences =<< permutations "ABCD"  -- mubanga ?
14:33:36 <lambdabot>   384
14:33:36 <FSalad_III> (hmm apparently there is no way tog get a file status from a handle, but still ;))
14:33:37 * copumpkin hasn't really been paying that much attention to the overall context so I'm gonna shut up
14:33:45 <mubanga> Well, permutations is returning 24 strings of 4 letters, and subsequence on each 4 letter string returns 16 values... I'm still not...
14:34:17 <ski> mubanga : do you want to apply `subsequences' on each permuation, or on the list of permutations itself ?
14:34:18 <dmwit> mubanga: You're not running "subsequence" on each 4-letter string.
14:34:18 <mauke> mubanga: you're not running subsequence on each 4 letter string
14:34:20 <Saizan> dolio: when you say it like that i'm even more convinced that it's the saner alternative :)
14:34:28 <copumpkin> lol
14:34:41 <mubanga> ... oh, shit
14:34:44 <mubanga> yeah, got it
14:34:47 <mubanga> Thanks guys
14:34:57 <copumpkin> @quote stereo
14:34:57 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
14:34:58 <copumpkin> http://snapplr.com/nxys
14:35:15 <mauke> haskellmind
14:35:25 <Martty> @check fac == c where fac n = product [1..n]; c n = length $ permutations [1..n]
14:35:25 <lambdabot>   Parse error at "where" (column 10)
14:35:40 <c_wraith> @check \x -> x == reverse x
14:35:41 <lambdabot>   "OK, passed 500 tests."
14:35:46 <Martty> ah
14:35:49 <Martty> :(
14:35:58 <mauke> @check \x -> length x < 5
14:35:58 <lambdabot>   "Falsifiable, after 10 tests:\n[(),(),(),(),(),()]\n"
14:36:09 <mauke> @check \x -> length x < 50
14:36:10 <lambdabot>   "Falsifiable, after 133 tests:\n[(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
14:36:14 <copumpkin> we need a polymorphic quickcheck!
14:36:22 <yaru1022> I'm wondering if it's only me who's struggling a lot to understand 'map' function in http://ianen.org/haskell/enumerator/enumerator.pdf. What should I do to understand the implementation? Any tips?
14:36:50 <Martty> @check (\n = product [1..n]) == (\m = length $ permutations [1..m])
14:36:50 <lambdabot>   Parse error at "=" (column 5)
14:37:00 <Martty> @check (\n -> product [1..n]) == (\m -> length $ permutations [1..m])
14:37:01 <lambdabot>   No instance for (GHC.Classes.Eq (GHC.Types.Int -> GHC.Types.Int))
14:37:01 <lambdabot>    arisin...
14:37:02 <dolio> yaru1022: What page is it on?
14:37:09 <mubanga> Ah, I had (map subsequences) in there earlier and it got lost
14:37:10 <Martty> O_O
14:37:11 <copumpkin> Martty: move the \n out
14:37:15 <yaru1022> dolio, pg 13
14:37:19 <copumpkin> Martty: you're asking for equality of functions
14:37:36 <dolio> Wow.
14:37:46 <ski> @check \n -> product [1..n] == length $ permutations [1..n]
14:37:47 <lambdabot>   Couldn't match expected type `a -> b'
14:37:53 <ski> @check \n -> product [1..n] == length (permutations [1..n])
14:37:57 <lambdabot>   mueval-core: Time limit exceeded
14:38:11 <copumpkin> > [1..1]
14:38:12 <lambdabot>   [1]
14:38:35 <ski> @check \n -> n <= 10 ==> product [1..n] == length (permutations [1..n])
14:38:36 <lambdabot>   No instance for (Test.QuickCheck.Testable
14:38:36 <lambdabot>                     (Test.QuickCh...
14:38:40 <ski> bah !
14:38:43 <copumpkin> failcheck
14:39:09 <periodic> When you add a strictness flag to a data constructor, does that make the field fully strict, or just WHNF?
14:39:23 <ski> whnf
14:39:35 <periodic> bah.
14:39:44 <yitz> @check \n -> if n > 20 then True else product [1..n] == length (premutations [1..n])
14:39:45 <lambdabot>   Not in scope: `premutations'
14:39:46 <Martty> > if and [(\n -> product [1..n]) == (\n -> length $ permutations [1..n])|n<-[1..3]] then "good"
14:39:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:39:51 <yitz> @check \n -> if n > 20 then True else product [1..n] == length (permutations [1..n])
14:39:52 <copumpkin> periodic: in general, you don't want things to be fully strict that way
14:39:55 <lambdabot>   mueval-core: Time limit exceeded
14:39:57 <Martty> > if and [(\n -> product [1..n]) == (\n -> length $ permutations [1..n])|n<-[1..3]] then "good" else "bad"
14:39:58 <lambdabot>   "*Exception: (==): No overloading for function
14:40:01 <yitz> @check \n -> if n > 10 then True else product [1..n] == length (permutations [1..n])
14:40:03 <lambdabot>   "OK, passed 500 tests."
14:40:13 <yitz> @check \n -> if n > 15 then True else product [1..n] == length (permutations [1..n])
14:40:17 <lambdabot>   mueval-core: Time limit exceeded
14:40:33 <periodic> copumpkin: I'm trying to do some quick numerical computations.  Verlet integration.  But it seems to be acting lazy and I'm trying to figure out what the best way to deal with it is.
14:40:39 <mubanga> I'm confused, what's all this product stuff I'm guessing was set off by my question?
14:40:44 <yaru1022> dolio, I don't think I could've come up with that complex implementation myself , let alone understanding it... lol how do people do it? I don't know if the way I think is not suitable for understanding functional language? How should I think to understand functional code better?
14:40:51 <Martty> mubanga: it wasn't, dont worry
14:40:59 <mubanga> Sweet
14:41:03 <Martty> apologies
14:41:24 <periodic> copumpkin: in this example the various demensions are independent, so it seems like evaluating the list/vector part doesn't go deep enough.
14:41:24 <dolio> yaru1022: The essence is that when your input Iteratee yields a chunk of aos, you map it into a chunk of ais, and yield that instead.
14:41:46 <copumpkin> periodic: the question is why you want to evaluate it all beforehand, though
14:41:58 <periodic> copumpkin: I want to evaluate it as I go...
14:41:58 <dolio> Because, as I recall, an Enumeratee is a function from Iteratees to Iteratees.
14:42:05 <copumpkin> periodic: but if necessary, just get the deepseq package and use that :)
14:42:20 <periodic> copumpkin: it looks like it's creating a vector with huge thunks for each element.
14:42:22 <dolio> yaru1022: I don't understand all the details of that implementation, though. Do you really need to?
14:43:45 <yaru1022> dolio, not for this exact implementation... but I feel like if I can't understand it, how can I come up with an implementation as sophisticated as this one when I need to later on?
14:45:45 <dolio> Well, I'm not very well-versed in the underlying details of iteratee stuff. If I were, maybe that implementation would seem straight forward.
14:45:51 <dolio> You may be in the same position.
14:46:28 <dolio> Presumably on your own sophisticated project, you'd be better acquainted with all the little details.
14:48:02 <yaru1022> dolio, true... Yeah I guess I shouldn't waste too much time on understanding just one piece of code. 
14:48:41 <dolio> I wouldn't, unless you're planning on getting into implementing iteratee stuff.
14:48:56 <dolio> I'd focus more on understanding things well enough to use it.
15:27:54 <koninkje> Are there any BibTeX gurus in the house?
15:28:30 <Raghs> where is the System.Directory module??
15:28:43 <koninkje> (or citation style-guide gurus may be enough)
15:28:56 <heatsink> If LaTeX were a proper programming language, we wouldn't need BibTeX. </gripe>
15:29:38 <heatsink> Raghs: Are you asking about the package that contains it?
15:30:05 <djahandarie> Raghs, I believe it is in directory
15:30:09 <djahandarie> @hackage directory
15:30:10 <lambdabot> http://hackage.haskell.org/package/directory
15:30:11 <Raghs> yes. I am not able to :m +System.Directory
15:30:17 <koninkje> heatsink: true. However, the problem domain is a peculiar one (e.g., proper handling of implicit styleing for --, ---, etc)
15:30:48 * hackagebot enumerator 0.3 - Implementation of Oleg Kiselyov's left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.3 (JohnMillikin)
15:31:14 <heatsink> koninkje, what did you want to know about?
15:31:44 <koninkje> I'm wondering if there's any good standard for citing software projects and/or websites
15:31:48 * hackagebot attoparsec-enumerator 0.1.0.2 - Convert an Attoparsec parser into an iteratee  http://hackage.haskell.org/package/attoparsec-enumerator-0.1.0.2 (JohnMillikin)
15:31:56 <koninkje> using @Misc is an awful hack
15:32:01 * heatsink tries to understand BibTeX as little as possible, though
15:32:19 <heatsink> I think @misc is the best you can do.  There is a specific field for URLs though.
15:32:27 <heatsink> I think it's called url
15:32:33 <koninkje> yeah, I have urls for all my citations...
15:33:23 <heatsink> If the software project has an official manual, cite that
15:33:54 <heatsink> ... if the manual is published, anyway
15:34:33 <koninkje> I can use @Unpublished for the unpublished manuals :)
15:51:53 <copumpkin> man, I like the view of sudoku as a hypercube
15:53:07 <copumpkin> is that really equivalent to the common sudoku though?
15:53:26 <copumpkin> (I'm talking about Waldmann's solution on the haskell-cafe thread about sudoku, by the way)
16:03:55 <heatsink> How does incomplete and overlapped pattern detection work with pattern guards?
16:04:14 * monochrom imagines trolling haskell-cafe with "sudoku is a timecube"
16:06:55 <heatsink> all rows and columns simultaneously add up to FOUR.   Do not accept the imperative dogma of time-varying puzzles.
16:10:35 <heatsink> Hmm, 4x4 sudoku is kind of easy.
16:11:07 <alise> So is 1x1 Sudoku.
16:11:13 <hpc> and 2x2
16:11:23 <alise> and 1,000 x 1,000.
16:11:24 <alise> Wait, no.
16:11:38 <Gracenotes> it's 3x3, 9x9, 12x12, etc.
16:11:49 <alise> NOT NOW IT ISN'T
16:11:53 <Gracenotes> and 6 for that matter
16:11:58 <aristid> 382x312
16:12:35 <hpc> how would rectangular sudoku work?
16:12:37 <copumpkin> I thought it was 3x3x3x3
16:12:48 <alise> hpc: awesomely
16:12:54 <alise> copumpkin: Four-dimensional Sudoku!
16:12:56 <heatsink> I can generalize to n^2 x n^2.  The row/column constraints generalize to other sizes easily, but I don't know how you would apply the local square uniqueness constraint to other sizes.
16:13:16 <hpc> actually, tetrahedronal sudoku would make my day
16:13:58 <Gracenotes> heatsink: hm, my variants would involve throwing row/column out the window
16:14:02 <heatsink> They don't tile euclidean space though
16:14:13 <Gracenotes> I suppose it does depend on how to transform the rules
16:14:26 <heatsink> yeah
16:49:21 <markmcw> need help with 'instance Pretty'
16:49:37 <markmcw> Just want to derive it from 'Show' but don't see an example
16:49:42 <markmcw> any ideas on this?
16:49:51 <kmc> Pretty from where?
16:50:33 <markmcw> I'm working on this project that encapsulates types giving them different types
16:50:41 <markmcw> in this case UTCTime
16:50:48 <markmcw> it has a Show
16:50:53 <markmcw> that I want to use for starts
16:51:13 <markmcw> sorry 'giving types different NAMES'
16:52:52 <kmc> where is the Pretty class defined?
16:53:20 <ezyang> PrettyPrintHughesPJ or something like that? 
16:53:32 <markmcw> The class is defined in the same module; will do an hpaste and BRB
16:58:18 <markmcw> hpaste.org/fastcgi/hpaste.fcgi/view?id=29368
16:59:45 <markmcw> ezyang: I don't need anything as complete/Complex as PrettyPrintHugesPJ (at least yet)
17:00:12 <markmcw> the rest of the system just expects Pretty and I have to provide it, as minimally working as possible at this point
17:01:04 <markmcw> and since UTCTime comes with a Show instance, it seemed that wiring the Pretty just to do its Show would be the most expedient
17:01:09 <etpace> Heff /window 12
17:01:12 <etpace> whoops
17:01:12 <markmcw> but I don't see syntax to do that
17:03:28 <kmc> markmcw, you still haven't given us the definition of the "Pretty" class, or where to find it
17:04:19 <heatsink> markmcw: You can define a new instance of class Pretty, but first we have to see the class definition.
17:07:07 <markmcw> Sorry, I missed the import:
17:07:09 <markmcw> import Text.PrettyPrint.Mainland as PP
17:07:28 <kmc> markmcw, and what package provides that module?
17:07:31 <markmcw> this is HughesPJ it looks like from the docs I found
17:07:52 <kmc> Text.PrettyPrint.HughesPJ defines no classes
17:08:16 <kmc> Your search - mainland site:hackage.haskell.org/package - did not match any documents
17:08:25 <markmcw> The import is in the current module I'm working to extend
17:09:10 <markmcw> this project requires the HEAD module -- unreleased 6.13 extensions
17:09:17 <markmcw> must be related to that
17:09:28 <kmc> can you find the definition of the class "Pretty" and hpaste it?
17:09:55 <markmcw> kmc: I'll look for that. Thanks
17:12:24 * markmcw quit
17:17:15 <lispy> System.Directory.renameFile should what when the destination FilePath exists and is not writeable?
17:17:52 <mauke> overwrite it
17:18:12 <heatsink> If the directory is not writeable, that's an access error
17:18:53 <lispy> not a direectory
17:19:30 <lispy> touch foo; touch bar; chmod 000 foo; System.Directory.renameFile "bar" "foo" <-- doesn't fail throw an exception and deletes bar
17:19:56 <mauke> touch foo; chmod 0 foo; rm foo
17:20:03 <mauke> same principle
17:20:39 <Jafet> access(2) suggests it should be "atomically replaced"
17:20:46 <Jafet> Whatever that is supposed to mean.
17:21:04 <lispy> It says it will throw isPermissionError when it lacks permission
17:21:37 <heatsink> Removing a file from a directory modifies the directory and requires access permission to the directory.  It doesn't modify the file and doesn't require access permission to the file.
17:22:23 <heatsink> Jafet: It means that another process can't touch the file system between when the old file is removed and the new file is inserted.
17:23:21 <dcoutts_> lispy: on unix, you can rename a file over an existing file entry and that has nothing to do with the permissions of the target file
17:23:39 <dcoutts_> it has everything to do with the permissions of the directory in which you create the new file
17:23:46 <mauke> you can also unlink(2) a file without having write permissions
17:23:47 <lispy> okay.  And I changed the directory permissions and now I get the exception
17:23:48 <Jafet> Only System.Posix.rename would get that semantics. So you could use that.
17:24:47 <dcoutts_> lispy: it's all because conceptually unix separates files and directory entries
17:25:16 <dcoutts_> files can exist without any directory entry, or multiple entries
17:26:02 <lispy> dcoutts_: yeah, I always forget that rm doesn't require a write bit on the file itself
17:26:16 <lispy> Now, I have to dig deeper to find out why the exception is now thrown
17:26:23 <dcoutts_> lispy: it's all different on windows
17:26:55 <lispy> In my test case, the directory is missing the write bit.  The mv is failing but my program is either not getting the exception or somehow ignoring it
17:28:43 <heatsink> dcoutts_: I thought unlinked files were automatically deleted?
17:29:12 <heatsink> Oh, if there are also no open file handles.
17:29:12 <dcoutts_> heatsink: once no process has them open anymore, yes
17:30:21 <dcoutts_> I've heard that on some OS you can construct a new file without adding a name for it anywhere
17:30:39 <dcoutts_> I suppose you have to somehow identify the filesystem, perhaps via a directory
17:31:07 <dcoutts_> perfect for temporary files, none of the nonsense we have with mkstemp
17:31:19 <lispy> dcoutts_: I bet plan9 supports that
17:31:22 <mauke> .oO( O_UNLINK )
17:31:41 <dcoutts_> lispy: sounds like the sort of sensible thing they'd do
17:32:24 <lispy> I removed the exception handling, still not getting an exception hmmm
17:33:24 <ezyang> Try strace'ing the binary. 
17:34:00 <lispy> as, osx.  strace = dtrace?
17:34:39 <ezyang> something like that. 
17:34:52 <ezyang> Just to make sure the mv is actually happening 
17:35:55 <lispy> heh, with dtrace in there it changed the exit code and my test "passed"
17:36:04 <lispy> which means it cleaned up the dtrace log
17:38:26 <cch> @help
17:38:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:38:32 <cch> @list
17:38:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:43:11 <lispy> ah, it's dtruss
17:45:24 <lispy> oh, that won't work because my process is invoking another process and it's the subprocess that should actually get/handle the exception
17:46:10 <lispy> same program, different process
17:46:24 <lispy> So now the question is, does the subprocess get the exception and try to report it?
17:59:34 * hackagebot bird 0.0.19 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.19 (MattParker)
18:03:10 <m3ga> anyone know how much of the System.Posix.* stuff works on windows?
18:07:15 <hpc> likely not much
18:07:25 <lispy> m3ga: I don't think most of it works there, but there is a layer that is platform independent you can use
18:07:25 <hpc> the last windows to have a POSIX dll was 2000 iirc
18:07:32 <lispy> m3ga: and there is a windows specific layer
18:09:48 <pickles> quick request: does anyone have an example of good haskell code (i.e. style / formatting) at hand? no biggie if not.
18:10:11 <lispy> pickles: the haskell wiki has pages dedicated to that topic
18:10:40 <m3ga> lispy: so what hpc says, not much :-)
18:11:11 <pickles> ok, thx lispy!
18:11:31 <kmc> maybe it can be plugged into cygwin?
18:11:51 <lispy> pickles: I haven't had a look, but I've heard xmonad-core is pretty
18:11:56 <kmc> pickles, i think xmonad code style is pretty good
18:11:57 <kmc> hehe
18:12:05 <pickles> lol
18:12:06 <kmc> at least for things like formatting and comments
18:12:15 <pickles> mm, i see this question has been posed on SO as well
18:12:15 <kmc> i have some differences of opinion about how to structure a window manager codebase
18:12:19 <pickles> thx for the tips guys
18:12:21 <kmc> but i should stfu until my wm is working ;)
18:14:11 <lispy> kmc: interesting.  From what I've heard of the design, it works really well.  Small core of functions that have been test/vetted and even some of it formally proven correct, and then the rest is user contrib libraries.  Furthermore, the internals are a nice zipper.
18:14:48 <mee> Is there a tool for formatting Haskell code w/ certain rules? ie. haskelltidy ala perltidy ?
18:15:53 <lispy> mee: I'm not sure what the status is.  I know that "haskell pretty printers" and "haskell reprinters" are things people have proposed
18:16:20 <lispy> mee: haskell-src-exts must have some support for it too
18:16:22 <mee> yeah, I'm sure I'm not the first person to want that tool :)
18:16:32 <mee> cool I'll take a look
18:16:35 <Jafet> mee: scroll down hackage, install whatever looks pretty
18:22:21 <sshc> Where is the source for (->) intance decleration of Monad?
18:22:58 <kmc> Control.Monad.Instances
18:23:01 <kmc> @src (->) return
18:23:02 <lambdabot> return = const
18:23:04 <kmc> @src (->) (>>=)
18:23:04 <lambdabot> f >>= k = \ r -> k (f r) r
18:25:02 <dh__> @src (>>=)
18:25:02 <lambdabot> Source not found. Maybe you made a typo?
18:25:12 <dh__> @src (->) (>>=)
18:25:12 <lambdabot> f >>= k = \ r -> k (f r) r
18:25:23 <dh__> @src ([]) (>>=)
18:25:23 <lambdabot> Source not found. You speak an infinite deal of nothing
18:25:50 <dh__> :i (>>=)
18:26:22 <Axman6> @src [] (>>=)
18:26:22 <lambdabot> xs >>= f     = concatMap f xs
18:26:51 <dh__> thanks.
18:27:05 <Axman6> @src Maybe
18:27:05 <lambdabot> data Maybe a = Nothing | Just a
18:27:10 <Axman6> @src maybe
18:27:10 <lambdabot> maybe n _ Nothing  = n
18:27:11 <lambdabot> maybe _ f (Just x) = f x
18:27:36 <Axman6> :t maybe Nothing (Just . ?f)
18:27:37 <lambdabot> forall a a1. (?f::a1 -> a) => Maybe a1 -> Maybe a
18:27:47 <Axman6> :t maybe Nothing (?f)
18:27:48 <lambdabot> forall a a1. (?f::a1 -> Maybe a) => Maybe a1 -> Maybe a
18:28:44 <derivector> the standard haskell sort implementation is an insert using insertBy?
18:28:47 <derivector> @src sortBy
18:28:47 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
18:28:50 <pickles> nite all
18:28:52 <derivector> @src insertBy
18:28:52 <lambdabot> insertBy _   x [] = [x]
18:28:52 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
18:28:52 <lambdabot>                                  GT -> y : insertBy cmp x ys'
18:28:52 <lambdabot>                                  _  -> x : ys
18:29:41 <Axman6> derivector: in the h98 standard it is i think, but its merge sort in ghc
18:31:39 <Jafet> http://haskell.org/ghc/docs/6.10-latest/html/libraries/base/src/Data-List.html#sortBy
18:32:43 <Axman6> :t maybe Nothing
18:32:44 <lambdabot> forall a a1. (a1 -> Maybe a) -> Maybe a1 -> Maybe a
18:32:51 <derivector> oh, interesting
18:33:58 <ddarius> That's just a specification not a required implementation.
18:34:44 <kmc> don't trust @src to be faithful to the real implementation
18:36:11 <Jafet> @src Int
18:36:12 <lambdabot> data Int = I# Int#
18:36:20 <Axman6> @src IO
18:36:20 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:36:25 <Axman6> >_<
18:38:52 <lispy> Is there a standard name for flip catch?
18:39:06 <Axman6> :t catch
18:39:07 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
18:39:19 <lispy> I suspect it's called handle
18:39:21 <lispy> :t handle
18:39:22 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
18:39:29 <Axman6> :|
18:39:53 <lispy> ?hoogle handle
18:39:53 <lambdabot> Control.Exception handle :: Exception e => (e -> IO a) -> IO a -> IO a
18:39:53 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
18:39:53 <lambdabot> Control.Exception.Base handle :: Exception e => (e -> IO a) -> IO a -> IO a
18:40:58 <sshc> Is it possible to use lambdabot to contrain a type, eg (>>=) for Cont?
18:41:14 <kmc> what do you mean?
18:41:23 <lispy> sshc: yeah, but I always forget the syntax
18:41:24 <copumpkin> oh
18:41:28 <lispy> ?src Cont (>>=)
18:41:28 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
18:41:30 <copumpkin> asTypeIn
18:41:39 <copumpkin> :t asTypeIn
18:41:40 <lambdabot> forall a b. a -> (a -> b) -> a
18:41:43 <lispy> sshc: ^^
18:41:58 <copumpkin> I think he wants a partially instantiated polymorphic type
18:42:11 <sshc> kmc: If (>>=) were written specifically for Conts rather than for all types that are instances of Monad, what would its type be?
18:42:36 <lispy> ?unmtl Cont
18:42:36 <lambdabot> err: `Cont' is not applied to enough arguments, giving `/\A B. (B -> A) -> A'
18:42:53 <sshc> @unmtl Cont r
18:42:53 <lambdabot> err: `Cont r' is not applied to enough arguments, giving `/\A. (A -> r) -> r'
18:42:56 <lispy> >>= :: Cont r a -> (a -> Cont r b) -> Cont r b
18:43:10 <copumpkin> you want a combination of unmtl and asTypeIn, I think
18:43:11 <Axman6> > asTypeIn 1 show
18:43:12 <lambdabot>   1
18:43:12 <sshc> Can lambdabot figure that out?
18:43:19 <Axman6> > asTypeIn 1 undefined
18:43:20 <lambdabot>   1
18:43:27 <Axman6> o.O
18:43:29 <lispy> :t (>>=) (undefined :: Cont r)
18:43:30 <lambdabot>     `Cont r' is not applied to enough type arguments
18:43:31 <lambdabot>     Expected kind `*', but `Cont r' has kind `* -> *'
18:43:31 <lambdabot>     In an expression type signature:
18:43:35 <lispy> :t (>>=) (undefined :: Cont r a)
18:43:36 <lambdabot> forall r a b. (a -> Cont r b) -> Cont r b
18:43:42 <lispy> sshc: partialy
18:43:49 <copumpkin> use asTypeIn
18:43:57 <sshc> I see.  Thanks.
18:44:09 <lispy> :t \(x :: Cont r a) y -> x >>= y
18:44:10 <lambdabot>     A pattern type signature cannot bind scoped type variables `r', `a'
18:44:10 <lambdabot>       unless the pattern has a rigid type context
18:44:10 <lambdabot>     In the pattern: x :: Cont r a
18:44:11 <Axman6> copumpkin: what does it do?
18:44:19 <copumpkin> :t (>>=) `asTypeIn` (\x -> x (undefined :: Cont r a))
18:44:20 <lambdabot> forall a b r. Cont r a -> (a -> Cont r b) -> Cont r b
18:44:22 <copumpkin> :)
18:44:41 <copumpkin> all it can really do, given that signature
18:45:17 <copumpkin> it's const with a tighter type
18:45:29 <lispy> :t asTypeOf
18:45:30 <lambdabot> forall a. a -> a -> a
18:45:32 <lispy> :t asTypeIn
18:45:33 <lambdabot> forall a b. a -> (a -> b) -> a
18:46:10 <copumpkin> :t Cont id
18:46:11 <lambdabot>     Occurs check: cannot construct the infinite type: r = a -> r
18:46:11 <lambdabot>     Probable cause: `id' is applied to too few arguments
18:46:11 <lambdabot>     In the first argument of `Cont', namely `id'
18:57:21 <dropdrive> Hi, I'm trying to write a function in Haskell that is callable from C.  This function should take a pointer to (say) 8000 bytes, to be interpreted as 1000 doubles, and I want to increment all the doubles by 1.  Any tips on how to get started?
18:58:13 <kmc> dropdrive, read the FFI chapter in Real World Haskell
18:58:14 <kmc> @where RWH
18:58:15 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:58:39 <kmc> read the documentation for the modules under Foreign.*
18:59:02 <kmc> CDouble has a Storable instance so you can peek/poke it
18:59:29 <copumpkin> omg adding 1 to a double
18:59:33 <copumpkin> might give the same double!
18:59:43 <kmc> read the GHC manual chapter 8
18:59:49 <dropdrive> kmc: That's very helpful, thanks a lot.
18:59:50 <kmc> it explains how "foreign export" works
19:00:15 <lispy> dropdrive: and ezyang has a series of blog posts about using the ffi
19:00:30 <lispy> ?google ezyang haskell ffi
19:00:38 <lispy> lambdabot: DO IT!
19:00:42 <copumpkin> @check (\x -> x + (1 :: Double) /= x)
19:00:45 <lambdabot> Plugin `search' failed with: thread killed
19:00:45 <lambdabot>   "OK, passed 500 tests."
19:00:46 * lispy weeps
19:00:50 <copumpkin> lol
19:00:53 <copumpkin> @check (\x -> x + (1 :: Double) /= x)
19:00:54 <lambdabot>   "OK, passed 500 tests."
19:00:54 <dropdrive> lispy: It's okay ;) Thanks
19:00:59 <copumpkin> dammit
19:01:00 <copumpkin> fail
19:01:30 <lispy> > 1/0 + 1 == 1/0
19:01:30 <lambdabot>   True
19:01:36 <lispy> copumpkin: ^^
19:01:45 <copumpkin> yep!
19:02:16 <lispy> It's probably a bug in QC, but I seriously doubt it can generate those values
19:02:35 <lispy> There should be a corner case checker, perhaps
19:03:58 <ezyang> Yeah, it seems that QC loaded with corner cases + a random distribution of tests would be a good idea... 
19:04:26 <copumpkin> I wouldn't call it a bug, but yeah, the Arbitrary instance for IEEE types should throw in a few NaNs and stuff
19:12:30 <etpace> :t (.).(.)
19:12:31 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:13:00 <etpace> :t (.).(.) (+)
19:13:01 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Num a1) => (a -> a1) -> f a -> f (a1 -> a1)
19:22:14 <ologNation> Does anyone use haskell with firefox? 
19:22:57 <copumpkin> ologNation: how do you mean?
19:22:58 <lispy> ologNation: What do you mean?
19:23:02 <copumpkin> they seem unrelated :)
19:23:10 <ologNation> It's true.  They're unrelated. 
19:23:11 <copumpkin> ologNation: you mean to write plugins for firefox?
19:23:14 <lispy> ologNation: I most use chrome these days, except when sites check for firefox
19:23:25 <ologNation> copumpkin, Yes.  I think that would be very cool, but maybe not correct in style. 
19:23:30 <lispy> firefox == memory hog
19:23:40 <ologNation> For plugins, I suppose you should use the language built for that. 
19:23:52 <copumpkin> yeah, it's all js and xul
19:24:11 <lispy> ologNation: It would be quite appropriate to make a domain specific language inside haskell for generating firefox plugins
19:24:12 <ologNation> How about this:  Does anyone know how to get, as a text file, some list of tabs open? Say, as (Title, URL) pairs? 
19:24:26 <ologNation> lispy, Well, I'm glad you think so.  
19:24:31 <ologNation> That sounds interesting to me. 
19:24:53 <ologNation> I'm sure that some among us are dreaming of a browser written in haskell, but these ideas must come, each in their time. 
19:25:01 <ologNation> Or maybe someone has one. 
19:25:05 <lispy> I'd rather get ghc and ghc compiled programs running in HTML5 or google's native client
19:25:06 <ologNation> already.
19:26:19 <ologNation> lispy, Well, that's a pretty exciting thought. 
19:30:23 <heis> Does anyone know if there's an established name for the permutation of a powerset? eg - powersetPermutation [1, 2] = [[], [1], [2], [1,2], [2,1]]
19:30:56 <lispy> heis: intractable?
19:31:18 <heis> guh?
19:31:30 <heis> How so?
19:31:53 <Jafet> > permutations . powerset $ [1..3]
19:31:54 <lispy> :)  I'm just being snarky.  Powersets and permutations are both big and expensive, combined would be worse!
19:31:54 <lambdabot>   Not in scope: `powerset'
19:32:08 <Jafet> > permutations . subsequences $ [1..3]
19:32:09 <lambdabot>   [[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]],[[1],[],[2],[1,2],[3],[1,3],[2,...
19:32:15 <luite> Jafet: that would be map permutations
19:32:19 <luite> hmm
19:32:20 <luite> wait
19:32:23 <Jafet> Or even concatmap
19:32:25 <luite> yes
19:32:26 <luite> :)
19:32:43 <heis> And subsequences are already ordered
19:32:56 <Jafet> > filter (not.null) . concatmap permutations . subsequences $ [1..3]
19:32:57 <lambdabot>   Not in scope: `concatmap'
19:33:03 <Jafet> > filter (not.null) . concatMap permutations . subsequences $ [1..3]
19:33:04 <lambdabot>   [[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1],[2...
19:33:22 <luite> but he wanted the []?
19:33:33 <djahandarie> > nub . concatMap permutations . subsequences $ [1..3]
19:33:34 <lambdabot>   [[],[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1]...
19:33:37 <djahandarie> Super expensive!
19:33:41 <djahandarie> haw haw
19:33:48 <lispy> heh
19:33:51 <luite> why nub?
19:34:04 <lispy> luite: because it's unnecassary and O(n^2)
19:34:35 <luite> lispy: i laugh in the face of O(n^2)
19:34:37 <djahandarie> > sort . nub . concatMap permutations . subsequences $ [1..3]
19:34:38 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,3],[1,3,2],[2],[2,1],[2,1,3],[2,3],[2,3,1],[3],[3,...
19:34:53 <djahandarie> Haskell gone wrong
19:35:09 <Jafet> O(n^2) of an exponential, no one will weep.
19:35:09 <djahandarie> > sort . nub . concatMap permutations . subsequences $ [1..100]
19:35:13 <lambdabot>   mueval-core: Time limit exceeded
19:35:19 <djahandarie> loll
19:35:28 <djahandarie> > subsequences [1..100]
19:35:29 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
19:35:31 <djahandarie> Heh
19:35:39 <Jafet> > concatMap permutations . subsequences $ [1..100]
19:35:40 <lambdabot>   [[],[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1]...
19:35:47 <Jafet> Hmm, it does work.
19:37:27 <heis> It is less computationally expensive to compute the powerset and then do the permutation... I think
19:37:43 <ologNation> I can see that you all have some interesting ideas about seeing our web-browsing through haskell-colored lenses. 
19:38:01 <lispy> Jafet: It's only O(n^2), except n is on the powerset, so n is exponential relative to the original input
19:38:02 <kmc> haskell gone wild?
19:38:17 <heis> But I was more looking for some sort of official name for it.  Seems pretty fundamental.
19:38:23 <djahandarie> Haha I was thinking of that when I wrote Haskell gone wrong, yeah :P
19:39:03 <Jafet> It's actually superexponential, I think
19:39:33 <Jafet> (Who's going to derive the size of this set?)
19:39:40 <lispy> Jafet: powerset of a set with N elements has 2^N elements.  You can prove this with the binomial theorem (or induction)
19:40:02 <lispy> The size is the sum of n choose k, for k = 0 .. n
19:40:04 <luite> but the size of the symmetric group S_n is n!
19:40:20 <luite> so that's already superexponential
19:40:31 <lispy> That looks a lot like the binomial theorem when a = b = 1, (a + b)^n = (1 + 1)^n = 2^n
19:41:19 <lispy> Yeah, if you want the permutations of the powerset, I assume that's superexponential (so sorry if I got confused about which set you meant)
19:42:21 <Jafet> > let fac 0 = 1; fac n = n * fac (pred n); comb r n = fac n `div` fac r `div` fac (n-r); in sum [fac k * comb 100 k | k <- [0..100]]
19:42:22 <lambdabot>   *Exception: stack overflow
19:42:37 <shapr> Um, random question... You think a power-saving monad transformer would actually add power-saving features to a Haskell program?
19:42:38 <Jafet> Not you, it seems.
19:43:10 <monochrom> heh, power-saving monad transformer.
19:43:50 <shapr> monochrom: Was just thinking about recent online complaints that firefox is not notebook and phone friendly, it doesn't pay attention to keeping the cpu in low-power mode as much as possible.
19:44:26 <shapr> Made me think that it'd be a huge amount of work to do that to a C program, just wondering if it'd be easier in Haskell.
19:45:21 <djahandarie> What would it even be doing operationally?
19:45:23 <Jafet> > let fac n = product [1..n]; comb r n = product [n-r+1..n] `div` product [1..r]; in sum [fac k * comb 100 k | k <- [0..100]]
19:45:24 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
19:46:09 <shapr> djahandarie: I guess it would really just be changes to the runtime, not the source of the average Haskell program.
19:46:15 <Jafet> shapr: one would, er, tweak the kernel to do that most effectively?
19:46:25 <kmc> see: powertop
19:46:31 <monochrom> I use a related example. Does an IO-killing monad transformer add IO-killing features to a Haskell program?
19:46:31 <kmc> basically, what's important is to minimize interrupts
19:46:39 <shapr> Jafet: Once you've done that, and used powertop, you look to the applications that you are using.
19:46:51 <kmc> it's possible there are ways to tune the RTS (in particular the IO manager) for fewer interrupts, at the expense of latency
19:46:52 <shapr> kmc: Right, exactly. Firefox does not handle that well.
19:46:59 <monochrom> IO-killing means it turns all IO operations to nop.
19:47:00 <orbitz> Anyone familiar with the couchdb module enough for a question?
19:47:01 <kmc> i doubt it'd involve a special monad, just RTS options
19:47:04 <Jafet> Then you killall firefox and start links instead!
19:48:20 <Jafet> (What I used to do was to just pkill -stop firefox when I didn't need it.)
19:48:55 <djahandarie> ETA on haskell web browser
19:49:06 <shapr> yeah, totally!
19:49:13 <monochrom> haskell web browser is being lazily written
19:49:23 <djahandarie> @freename
19:49:24 <lambdabot> Hado
19:49:28 <Jafet> Someone should force it.
19:49:28 <djahandarie> Perfect!
19:49:53 <djahandarie> hSurfin'
19:49:55 <djahandarie> Haha
19:50:02 <djahandarie> Even has the prime in it
19:50:12 <monochrom> because it's strict :)
19:50:29 <monochrom> no one really wants non-strict surfing :)
19:51:51 <luite> > map concat $ mapM tails [[1,2,3],[4,5]]  -- any simpler/shorter way to do this?
19:51:52 <lambdabot>   [[1,2,3,4,5],[1,2,3,5],[1,2,3],[2,3,4,5],[2,3,5],[2,3],[3,4,5],[3,5],[3],[4...
19:52:46 <copumpkin> > sequence [[1,2,3],[4,5]]
19:52:47 <lambdabot>   [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
19:52:51 <copumpkin> whoops :)
19:53:02 <luite> it's not _that_ easy :p
19:53:05 <copumpkin> :P
20:01:09 <jrockway> wow, weird
20:01:18 <jrockway> so i've been working only in haskell for the last two weeks or so
20:01:29 <jrockway> i started doing some perl again today, and noticed, "wow, i can type fast"
20:01:40 <jrockway> then i realized, "wow, i just typed a lot of stuff, and my program doesn't do anything yet"
20:01:54 <djahandarie> Well
20:02:13 <djahandarie> > (concat .) . mapM tails $ [[1,2,3],[4,5]]
20:02:15 <lambdabot>   [[1,2,3,4,5],[1,2,3,5],[1,2,3],[2,3,4,5],[2,3,5],[2,3],[3,4,5],[3,5],[3],[4...
20:02:18 <djahandarie> Only in caleskell though ;)
20:02:25 <kmc> jrockway, heh
20:02:27 <djahandarie> Or Hascale
20:02:30 <kmc> Perl isn't *too* bad for that
20:02:54 <jrockway> with haskell, i spent a lot of time thinking, then i type foo = return . f . g . x =<< 42
20:03:00 <jrockway> and then something does something :)
20:03:07 <luite> the difference is that your perl program won't work the first time you try it
20:03:44 <dolio> You should type in f . g . x <$> 42 instead.
20:03:50 <shapr> jrockway: haha
20:04:15 <jrockway> usually my perl programs work without too much munging :)
20:04:38 <jrockway> i was surprised the first time i wrote a big program in haskell, started it running, waited a half hour for it to finish processing, and seeing the result though
20:04:49 <jrockway> usually my perl programs die somewhere about halfway through
20:04:54 <jrockway> which is why i use haskell for data processing
20:05:32 <jrockway> (it did have a space leak, but hey, it worked)
20:05:42 <luite> I usually run into performance problems when using haskell for data processing
20:06:46 <djahandarie> Most performance problems in Haskell are really easy to fix. Most performance problems in Haskell that are hard to fix are really hard to fix.
20:06:55 <jrockway> for me, it's mixed
20:07:02 <luite> djahandarie: I mean the second type
20:07:21 <jrockway> my app spends about 10% of the time in C, 20% doing IO, 10% formatting the result, and the rest sanity-checking the data
20:07:21 <luite> things that are not fixable by switching to bytestring and having some local ST blocks
20:07:34 <jrockway> before the profiler, it was 99% encodeFloat . decodeFloat to convert CDouble -> Double :)
20:07:43 <jrockway> and then it was 90% formatting dates
20:08:27 <jrockway> (incidentally, i didn't really know how to use the profiler before i converted from String/List to ByteString/Vector.  but the code did get a lot faster even with the silly typecast and date formatting.)
20:09:45 <jrockway> (the key? -auto-all :)
20:35:59 <nejucomo> conal: Are you around?
20:36:32 <conal> nejucomo: yep
20:36:34 <nejucomo> Or, can anyone help me understand this: http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries/
20:37:32 <nejucomo> The HasTrie instances for the common polymorphisms seem to make sense to me, but I don't understand how the instance of HasTrie for Word works...
20:38:07 <nejucomo> Specifically, doesn't there need to be an instance of HasTrie for [Bool] ?
20:38:36 <etpace> isn't there an instance for [a]?
20:39:31 <conal> yes, there is an instance in the library.  maybe i forgot to mention/show that instance in the blog post.  oops.
20:43:28 <nejucomo> Oh, ok.  That makes me feel more sane, I thought I was just missing some haskell magic.
20:43:48 <Cale_> conal: There was someone around today who was interested in the state of Reactive (was that you nejucomo?)
20:44:12 <conal> Cale_: thx.
20:44:20 <Cale_> Has GHC improved the situation at all?
20:44:36 <conal> i think so.
20:44:42 <Cale_> Oh, that's awesome.
20:44:57 <conal> from misc reports i hear, there are still some nasty leaks.  :(
20:45:22 <Cale_> Oh, that's too bad. :/
20:45:44 <conal> i've been focused on functional gpu programming and iOS programming for the last 18 months, so Reactive has been sadly neglected.
20:46:32 <Cale_> I'm even moreso interested in FRP now, since I'm working for iPwn on a Haskell game. We're using a modified Yampa, and I've decided that I don't really care for arrows all that much. ;)
20:46:43 <nejucomo> Cale_: It wasn't me.  I don't know what Reactive is.
20:46:46 <danharaj> Arrows suck :\
20:47:16 <conal> Cale_: glad to know.  what about the arrow approach do you dislike?
20:48:50 <Cale_> conal: It basically forces you to write your program as the geometric dual of the program you want to write. You can't really give names to signals, only to signal transformers. Of course, that's sort of key to how it ensures enough sharing, but it has some brutal effects on style.
20:49:59 <conal> Cale_: ah, thx.
20:50:08 <Cale_> Also, the arrow axioms are "wrong".
20:50:43 <Cale_> Those diagrams everyone draws are slightly BS, because the interchange law doesn't hold, so topological transformations of those wiring diagrams change the meaning.
20:51:11 <conal> i never got comfortable with the sequential look of afrp.
20:51:14 <Cale_> That is to say, (f >>> g) *** (h >>> k) is not the same as (f *** h) >>> (g *** k)
20:52:47 <Cale_> I'm not sure whether or not this law holds for Yampa's SF or not, but there are certainly plenty of Arrow instances floating around which don't satisfy it.
20:53:44 <adelH7> hi
20:53:47 <Cale_> (I actually have a feeling that it may hold for SF, but it certainly does not hold for any Kleisli arrow of a noncommutative monad)
20:53:53 <Cale_> hello
20:54:06 <adelH7> Hi Cale
20:54:34 <conal> Cale_: because the order of g & h gets swapped?
20:54:35 <adelH7> so this is the erudite chat-room yea
20:54:39 <Cale_> conal: right.
20:55:31 <adelH7> Haskell beginner here :)
20:55:34 <djahandarie> adelH7, if you are using erudite as an adjective there... I guess ;)
20:56:15 <adelH7> lol, that's proving my point
20:56:22 <Cale_> adelH7: Feel free to ask any questions you might have. Beginners are always welcome :)
20:56:37 <adelH7> Thanks a lot, much appreciated 
20:57:29 <adelH7> I'm still a Haskell-baby as of now, but it has been intriguing
20:58:04 <adelH7> it's pretty different
20:58:34 <adelH7> recursiveness part mainly
20:58:39 <Cale_> Yeah, it's not just yet another reskinning of choose-your-favourite-imperative-OO-language ;)
20:59:08 <adelH7> Yep, lol , very true
21:00:08 <adelH7> you have to think more up-front
21:00:19 <Cale_> The goal is actually not to write recursive functions, but to write higher order functions (often recursively), and then use those.
21:00:35 <Cale_> Lists, together with higher order functions on them, become your loops.
21:01:27 <adelH7> Aah yes, that's pretty interesting.  I'll need to get used to thinking this way.
21:02:01 <adelH7> So... I'm glad I found this place!
21:02:51 <adelH7> well, tomorrows my first day of class actually
21:03:05 <adelH7> 11pm here in New Orleans, I should head out :)
21:03:10 <djahandarie> Later
21:03:18 <adelH7> a pleasure meeting you guys, thanks a lot!
21:03:30 <adelH7> goodbye
21:03:51 <Cale_> see you
21:05:19 <jrockway> are there any options other than yampa, graprefruit, and reactive for FRP?
21:05:42 <jrockway> (reactive looks nice enough to fix if i need to, as it seems to be a perfect fit for $future_application)
21:08:25 <djahandarie> It also has serious performance issues which are like impossible to fix
21:11:19 <jrockway> hmm, that's too bad
21:11:31 <jrockway> the reactive model seems like a perfect fit for my application
21:11:50 <jrockway> which reads streams of data, and as messages come in, calculates something (with the various messages as args), and then publishes the result
21:12:00 <jrockway> that's like 3 lines of reactive :)
21:19:37 * hackagebot enumerator 0.3.0.1 - Implementation of Oleg Kiselyov's left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.3.0.1 (JohnMillikin)
21:21:38 * hackagebot libxml-enumerator 0.1 - Enumerator-based API for libXML's SAX interface  http://hackage.haskell.org/package/libxml-enumerator-0.1 (JohnMillikin)
21:29:01 <inbuninbu> a question for you good people...
21:29:17 <inbuninbu> i have a list of tuples (int,int), each representing an extent in an address space. i want to keep a list of such extents. so far so good.
21:29:34 <inbuninbu> however, i want a 'reduce' function where if two extents are adjacent, they will be combined into one extent.
21:29:48 <inbuninbu> a function to give me a list of either the single extent if they are adjacent, or a list of the two originals is simple enough
21:30:06 <FSalad_III> hmm is that package an *alternative* to the iteratee package?
21:30:14 <inbuninbu> but i can't use a fold because the original list elements are not lists. any suggestions?
21:30:19 <FSalad_III> seems like it
21:31:09 <FSalad_III> (I was reacting to hackagebot btw, not you inbuninbu :))
21:31:32 <inbuninbu> FSalad_III: i thought so :-)
21:31:41 <Jafet> inbuninbu: interval merging is a standard problem; standard solution is sort and merge
21:32:11 <nejucomo> :t curry
21:32:12 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
21:32:48 <inbuninbu> Jafet: thanks a lot! google should take me from here
21:33:10 <aavogt> > let f ((a,b):(c,d):xs) | c - b == 1 = f ((a,d):xs); f (x:xs) = x : f xs; f [] = [] in f [(1,2),(3,5),(9,10),(11,15)]
21:33:11 <lambdabot>   [(1,5),(9,15)]
21:34:09 <Jafet> ...for one-dimensional intervals, anyway.
21:36:05 <aavogt> inbuninbu: I wouldn't be worried if the function to merge the two (like that f) can't be nicely written using a higher order function
21:39:04 <inbuninbu> thanks aavogt
21:39:23 <Veinor> yeah, I don't think you could do that nicely
21:40:23 <aavogt> Veinor: no, it is impossible!
21:42:45 <Veinor> > let f (a,b) (c,d) = c - b == 1; g [x] = g; g xs = (fst (head xs), snd (last xs)) in map g (groupBy f [(1,2),(3,5),(9,10),(11,15)]) in map
21:42:46 <lambdabot>   <no location info>: parse error on input `in'
21:42:49 <Veinor> > let f (a,b) (c,d) = c - b == 1; g [x] = g; g xs = (fst (head xs), snd (last xs)) in map g (groupBy f [(1,2),(3,5),(9,10),(11,15)])
21:42:49 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t1] -> t
21:42:52 <Veinor> bah
21:43:11 <Veinor> > let f (a,b) (c,d) = c - b == 1; g [x] = x; g xs = (fst (head xs), snd (last xs)) in map g (groupBy f [(1,2),(3,5),(9,10),(11,15)])
21:43:12 <lambdabot>   [(1,5),(9,15)]
21:43:54 <Veinor> @pl \xs -> (fst (head xs), snd (last xs))
21:43:54 <lambdabot> ap ((,) . fst . head) (snd . last)
21:46:58 <ddarius> > fix head
21:46:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
21:52:06 <Cale_> GASP! It is the proof that GHC will never be finished!
21:52:33 <dolio> > fix (head . out)
21:52:34 <lambdabot>   No instance for (GHC.Show.Show (L.Mu []))
21:52:34 <lambdabot>    arising from a use of `M767287...
21:53:07 <djahandarie> :t out
21:53:07 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
21:53:38 <Veinor> Cale_: haha
21:54:35 <djahandarie> Ah, head forces f to a list
21:54:43 <djahandarie> Man I'm really tired to not realize that
21:54:45 * djahandarie leaves
21:55:16 <Veinor> :t fix (head.out)
21:55:17 <lambdabot> Mu []
21:55:27 <Cale_> @undefine
21:55:35 <Cale_> :t fix (head . out)
21:55:36 <lambdabot> Not in scope: `out'
21:55:38 <Cale_> hmm
21:55:50 <Cale_> wat
21:55:54 <dolio> How did that happen?
21:56:19 <dolio> :t In
21:56:20 <lambdabot> Not in scope: data constructor `In'
21:56:22 <Cale_> Weird, all I did was add some derivings
21:56:48 <Cale_> > fix (head . out)
21:56:48 <lambdabot>   L.hs:104:12:
21:56:49 <lambdabot>      No instance for (Eq (f (Mu f)))
21:56:49 <lambdabot>        arising from the '...
21:57:22 <Cale_> @undefine
21:57:23 <Cale_> > fix (head . out)
21:57:24 <lambdabot>   L.hs:104:12:
21:57:24 <lambdabot>      No instance for (Eq (f (Mu f)))
21:57:25 <lambdabot>        arising from the '...
21:57:27 <Cale_> huh
21:57:42 <Cale_> Why would it complain about Eq, I wonder.
21:58:04 <Heffalump> @type out
21:58:09 <lambdabot> Not in scope: `out'
21:59:57 <dolio> Mu not having a Show instance was useful the other day.
22:00:28 <Cale_> I removed the derivings. GHC was unhappy about them.
22:00:58 <dolio> I wouldn't expect it to derive them. It requires undecidable instances.
22:01:37 <Cale_> Yeah, I probably should have thought a little more about exactly what the instance would have to look like ;)
22:04:58 <djahandarie> Tarmo Uustalu sure has a lot of super interesting papers
22:05:05 <djahandarie> Whoops, I mean good night
22:07:19 <juhp> hmm why cabal-install want to build network when I already have it installed
22:07:39 * juhp wonders if it is a faq
22:10:09 <FSalad_III> it is
22:10:11 <juhp> would -v tell me more?
22:10:21 <FSalad_III> but nobody has an *answer*
22:10:28 <FSalad_III> semi-kidding ;)
22:10:32 <juhp> haha
22:10:42 <FSalad_III> one of the cabal devs probably knows
22:10:49 <juhp> or answer is in the next version? :)
22:10:53 <juhp> ok yeah
22:10:56 <FSalad_III> but I think usually the question goes unanswered here ;)
22:11:02 <juhp> hmm
22:11:15 <juhp> FSalad_III: thanks
22:11:18 <dcoutts_> juhp: cabal install --dry-run -v  will often give you a hint
22:11:33 <juhp> dcoutts_: ok
22:11:58 <FSalad_III> dcoutts_: this one doesn't seem to be a traditional version number issue... it's about the ABI (?) hash codes
22:12:03 <dcoutts_> juhp: if you've got the exact same version installed in both user and global package dbs then you're suffering from a cabal bug
22:12:20 <dcoutts_> juhp: which can be avoided by obliterating the one in the user package db
22:12:23 <juhp> dcoutts_: I think so
22:12:36 <FSalad_III> flickering between two different ones, both for network-2.2.1.7
22:12:46 <FSalad_III> (oh and I have no user db)
22:13:04 <juhp> dcoutts_: dunno even after that I see network getting rebuilt
22:13:33 <dcoutts_> juhp: that can still happen for other reasons, see the --dry-run -v output
22:13:42 <juhp> ok sure
22:13:46 <juhp> thanks
22:14:24 <dcoutts_> juhp: basically it's trying to get consistent deps one way or another and sometimes that means rebuilding packages against different versions of their deps
22:14:37 <dcoutts_> you can control it by applying extra --constraint=
22:15:11 <juhp> ok thanks sure
22:15:14 <dcoutts_> FSalad_III: currently you can't have two packages with the same version in the same package db, you can only get that by using multiple dbs, e.g. global+user
22:15:56 <dcoutts_> FSalad_III: and the cabal bug is that when there is the same version, then it's not stable which instance cabal ends up picking, I mean which one masks the other is not stable.
22:16:24 <FSalad_III> dcoutts_: I don't think I have two versions of it, the problem is that package A causes installation of network-2.2.1.7-X, then package B causes [...] network-2.2.1.7-Y, breaking A
22:16:35 <FSalad_III> 'break' as in ghc-pkg complaining about broken packages
22:17:12 <dcoutts_> FSalad_III: oh ok so your problem is you have two different packages that need network to be built against different versions of other dependencies
22:17:24 <FSalad_III> yes, seems like it
22:17:27 <dcoutts_> FSalad_III: you'll be able to see what changes by using --dry-run -v
22:17:34 <FSalad_III> 'random' is another usual suspect :)
22:17:36 <dcoutts_> it reports what deps would change
22:17:49 <dcoutts_> FSalad_III: trick is not to upgrade core packages
22:17:54 <FSalad_III> ok I'll try that next time I notice it :)
22:18:11 <FSalad_III> how would you prevent it?
22:18:23 <dcoutts_> don't use cabal upgrade
22:18:52 <FSalad_III> hmm I don't, apparently some packages insist on building network against different dependencies
22:19:14 <FSalad_III> maybe old packages using base 3 or something...
22:19:19 <dcoutts_> but that's because you've already managed to install later versions of packages that network depends on
22:19:24 <dcoutts_> no, base 3 is not a problem
22:19:26 <FSalad_III> hmm
22:20:00 <FSalad_III> so you are saying that core packages will never be changed by a cabal install if I haven't explicitly 'cabal install'-ed a core package before?
22:20:06 <FSalad_III> which I may well have done....
22:20:25 <dcoutts_> FSalad_III: I think that's correct
22:20:29 <FSalad_III> (as a consequence of trying to install *all* packages to make a hoogle db ;))
22:20:52 <FSalad_III> (for-loop over cabal list...)
22:21:02 <dcoutts_> right, that'd do it :-)
22:21:37 <FSalad_III> (a seperate 'cabal install' for each package, since I'm pretty sure there is no way to solve all dependencies at once ;))
22:22:08 <dcoutts_> actually there is, but it's a longish story (on my blog)
22:22:38 <FSalad_III> I see
22:40:23 <juhp> dcoutts_: I think my problem is mostly because parsec - re-remembered...
22:43:04 <juhp> maybe some way to globally pin down package versions or ignore certain packages on hackage would be nice - though it is really a hackage problem
22:44:01 <juhp> (specially for haskell-platform)
22:59:11 <juhp> hmm I guess cabal patches should be "sent" to trac?
23:11:27 <kulin> are monads nothing more than type classes?
23:12:39 <aavogt> there are some laws that instances should respect
23:12:57 <Cale> kulin: They're instances of a particular typeclass, satisfying some laws.
23:13:26 <Cale> kulin: Well, that's restricting the definition to the category of Haskell types and functions, but that's pretty much all you need for programming.
23:14:15 <kulin> ya, im just trying to get my head around them, ive been using stm and io for months, but i was reading that it is good to use them to create modularity for large projects
23:15:57 <Cale> Some people like monad transformers more than others, and monad transformers quickly get you lots of monads, but regardless of that, sometimes the library you design ends up naturally being a monad in one way or another. If you recognise that fact, you get all the stuff in Control.Monad (and many other libraries) for free.
23:16:26 <kulin> how do you know what is a good fit for monads?
23:16:58 <kulin> like on project im working on is wrapping a c 3d library into ffi, and so it seems a monad might fit there well because it is little different from io
23:18:16 <kulin> but after reading 5 or 6 sites on monads, and a paper, i dont know much more about monads than i get from the type information of the type class
23:19:16 <Cale> kulin: Well, possibly. I think I wouldn't set out saying something like "I'm going to make this a monad" up front. Design the library, perhaps see if there's a natural type constructor there for which you can define return and >>=
23:19:33 <Cale> It's certainly possible to set out to squish things into the Monad interface if you want.
23:19:56 <Cale> But if it's not clear how to do it, then forcing the issue probably isn't helpful.
23:20:25 <kulin> well i want to learn it, the problem im coming up against is, in the c# world, theres a hundred different ways to handle large projects
23:20:45 <kulin> im trying to find anything in haskell so that my code is not just a stream of thought or a list of functions broken up into namespaces
23:21:19 <Cale> Here's the angle I tend to take: What language is it really that I'd like to write my program in? What are the primitive computations and how can they be combined and composed?
23:21:49 <kulin> id like to use haskell thats easy
23:21:59 <Cale> For a 3D library, probably the primitives are shapes of some sort, and there are some obvious geometric combinations and transformations on 3D objects.
23:22:22 <Cale> Nah, it's never just Haskell, it's always some sublanguage built in Haskell :)
23:22:54 <Cale> If you design your libraries right, they will feel like little programming languages.
23:24:08 <Cale> Functional programming is all about finding the language in which your problem is trivial, and then using the features of your language (notably first class functions) to embed that language into the actual language that you're using (Haskell, in this case)
23:24:21 <Cale> Whenever you design a programming language, there are 3 things to consider:
23:24:46 <Cale> 1) The primitive computations. What are the smallest bits of computation that can be performed, and everything else will be built from?
23:25:11 <Cale> 2) The means of composition or combination. What options are there for gluing the primitives together into more complicated things?
23:25:57 <Cale> 3) The means of abstraction. How do you take some composed thing, and give it a name so that it behaves like just another primitive and can be combined into ever larger things?
23:26:27 <Cale> Normally when you're designing a library, 3 is taken care of for you.
23:26:53 <Cale> (You'll use Haskell's means of abstraction)
23:27:01 <Cale> But 1 and 2 are still important things to think about.
23:27:32 <Cale> With a drawing library, often the primitives will be very simple drawings: single lines, simple shapes, and so on.
23:27:43 <Cale> and there are lots of possible ways to combine drawings
23:27:50 <kulin> ya i think the primitives are decided for me already
23:28:30 <Cale> Drawing one on top of another, or adjacent to it (horizontally or vertically), replacing all the lines in one drawing with some other drawing, or even more bizarre things.
23:28:48 <Cale> There are also plenty of transformations: stretching, colouring, and so on.
23:28:48 <kulin> i guess what i am taking from monads is that they are best used when the current calculation depends on some previous one, another form of recursion
23:28:54 <kulin> and so the 3d library is not really taht
23:29:29 <Cale> Well, the important thing about monadic computations is that they all have results. So if you want your library to be monadic, what will the result mean?
23:29:50 <kulin> the scene has changed
23:29:51 <kulin> in some way
23:30:07 <Cale> Well, that's the effect of a drawing
23:30:40 <Cale> Presumably  return v  will be an empty drawing which somehow "always returns v"
23:30:58 <Cale> Maybe the result of a drawing would be the value which is obtained by clicking on part of it.
23:31:23 <Cale> (making drawings somewhat interactive)
23:31:53 <kulin> so the result has to be some value, and the monad would be the act of drawing?
23:32:06 <Cale> The monad itself would be a type constructor
23:32:21 <Cale> Computations in that monad would be drawings, or acts-of-drawing.
23:32:30 <kulin> i see
23:33:55 <aavogt> you can do the drawing as the effects... with all values in the monad being ()
23:34:44 <aavogt> take this module for instance http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Put.html
23:36:04 <Cale> It's a bit suspicious to have a monad whose intended use makes all the actions have result type ()
23:36:15 <kulin> not all would
23:36:17 <Cale> If you bump into that case, you might be better off with Monoid
23:36:19 <kulin> but they might have different times
23:36:22 <c_wraith> that doesn't really sound like a monad. then
23:36:27 <c_wraith> Yeah, it really does sound like a monoid
23:36:29 <kulin> some might return colors, others locations, etc
23:36:33 <aavogt> identity monad
23:36:35 <Cale> kulin: Right :)
23:36:49 <kulin> times = types
23:37:33 <Cale> kulin: It depends on how you choose to interpret actions in the given monad. Certainly, there are very good non-monadic drawing libraries which proceed in a very similar way with primitive drawings and means of combining them, even when none of those combiners looks like >>=
23:38:21 <aavogt> Cale: what do you mean by being better off? Are there practical consequences of using a more complicated (but more familiar) abstraction?
23:39:46 <aavogt> being able to use do notation is quite convenient
23:40:35 <Cale> aavogt: Well... maybe, maybe not. do-notation is convenient, but list notation and mconcat is not much worse :)
23:40:55 <Cale> and the simpler interface might just allow you to do more tricks
23:41:11 <Cale> The thing about monadic computations is that they're never nicely observable
23:41:28 <Cale> Because the right hand side of every >>= is a function, and those are opaque
23:41:44 <Cale> With a monoidal interface, you could have a good chance of writing a decent Show instance.
23:42:26 <aavogt> a simpler interface should make it easier to use the library by looking at the types
23:42:28 <Cale> Or doing other transformations with drawings which you couldn't necessarily do with a monadic one.
23:44:24 <Axman6> when for a function o, (f `o` g) `o` h == f `o` (g `o` h), o is comutative right?
23:44:31 <Cale> associative
23:44:44 <Cale> Commutative means that f `o` g = g `o` f
23:45:06 <Axman6> i've never figured out why i find those two so hard to remember
23:46:32 <etpace> I want to implement a finite queue, which I think is the same as a circular buffer, where cons is O(1), is this possible? or must I accept amortised O(1)?
23:47:01 <Cale> etpace: It is possible, but tends to involve trickery to do in a pure way.
23:47:10 <etpace> ah
23:47:38 <Cale> (Not that much trickery, but it's not just the obvious translation of the way you'd do things with imperative mutation.)
23:47:46 <Cale> However, with the use of something like Data.Sequence, it's easy :)
23:47:56 <etpace> can you give a link?
23:48:11 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/Data-Sequence.html
23:48:35 <etpace> When it says its finite, where do I specify the length?
23:48:57 <Cale> Nowhere in particular.
23:49:03 <Cale> It just can't be infinitely long.
23:49:28 <Cale> (which makes sense for a queue anyway)
23:49:43 <Cale> You can use Data.Sequence directly as a queue
23:49:59 <Cale> The constant factors are not bad, but they're perhaps less than ideal.
23:52:08 <etpace> I'm not sure how Data.Sequence is prefereable to a list implementation, if im just doing cons x xs = take 20 $ x <| xs, and then having to reverse if I want to map from the head to the tail for the first 20 items
23:52:59 <Cale> Data.Sequence is quickly accessible from both ends
23:53:59 <Cale> viewl and viewr are both O(1)
23:54:19 <etpace> but there seems to be no take 20 for whatever for viewr
23:54:32 <Cale> Moreover, splitAt i is O(log(min(i,n-i))), where n is the length
23:54:43 <Cale> (and length is also constant time)
23:56:19 <etpace> thanks
23:56:37 <Cale> Well, hmm, if you want to take 20 from the end in reverse order, I suppose the library doesn't have a built-in for that, but you can write one
23:56:49 <Cale> (which is constant time per element)
