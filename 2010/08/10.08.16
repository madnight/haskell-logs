00:51:30 <franksh> has anyone here used GPipe and compiled this example? http://www.haskell.org/haskellwiki/GPipe/Tutorial - I'm getting loads of type errors when I try to compile it and I can't figure out at all what's going on.. "Couldn't match expected type 'SomeType t' against inferred type 'OtherType' \ NB: 'SomeType' is a type function, and may not be injective" <- no idea what that means.
01:00:38 <cdsmithus> Suppose I have phantom types: data A ; data B ; data C, and then a type data WidgetType x = ... (where x is intended to be one of A, B, or C).  But now I need a function that can take parameters like WidgetType A and WidgetType B, but not WidgetType C.  Can that be expressed easily?
01:01:05 <duckinator> i need to learn more haskell so i can read 3 messages in here without getting confused
01:08:46 <franksh> duckinator, I'm in the same boat.
01:10:03 <quicksilver> @tell cdsmithus IsAOrBButNotC x => WidgetType x; you can probably think of a good name for the class. There must be some *reason* why it can be A or B but not C, and that reason can probably be made into a class.
01:10:03 <lambdabot> Consider it noted.
01:12:10 * duckinator hands franksh some lag
01:18:11 <merijn> duckinator: Learning more haskell won't help. I think I need to win a Turing award first before I start understanding half the conversations here...
01:18:20 <duckinator> lol
01:18:50 <merijn> That or finally get off my ass and make sure I read and understand the entirety of Lamdba the Ultimate
01:18:59 <duckinator> merijn: i've written most of an operating system, all of another, helped with yet another, designed 2 programming languages, and learned >10 programming languages. i still have no clue wtf half this stuff is about :D
01:19:39 <wli> Wow, I've not even gotten that far with hammering out my own kernel.
01:20:02 <duckinator> i wont mention that the one i wrote entirely myself doesn't do anything
01:20:28 <duckinator> the main one i work on, dux, finally hit version 0.0.4 after over 2 years :3
01:20:44 <merijn> Farthest I've gotten with OS coding is my current class project to implement profiling, filesystem defragmentation and threading + mutexes on minix
01:20:45 <duckinator> of course, leaving a year between 0.0.2 and 0.0.3....
01:20:52 <merijn> Which was surprisingly easy so far
01:21:04 <duckinator> i've never taken a single programming class
01:21:09 <merijn> Most of the work is convincing myself that this stuff isn't actually to hard
01:21:12 <duckinator> well, i was in one for a few weeks then got kicked out for "hacking" ^^
01:21:18 <aRcatan> hey, i've been experimenting with Haskell for something like five, six years and I still don't understand all the discussions here
01:21:19 <duckinator> aka i did something the teacher didn't understand
01:21:30 <aRcatan> maybe tells more about me than haskell, though
01:21:38 <duckinator> lol
01:21:46 <merijn> Says more about the people here, then you
01:22:09 <aRcatan> or maybe I just don't understand English very well!
01:22:41 <duckinator> hmmm, this seems like an opportune place to ask for opinions on one of my languages i'm working on a parser (then, eventually, interpreter) for... ;P http://github.com/RockerMONO/pulito/blob/master/design.md <-- it's called pulito in case you couldn't guess
01:22:42 <merijn> There's at least a bunch of people I know are published academics and there's probably a lot more that I just don't know are published.
01:22:48 <medfly> this channel is for breaking your spirit and making you think you're not as good as you thought you were
01:23:20 <duckinator> medfly: nah, that's #java and #c ;) *hides*
01:23:27 <merijn> medfly: It's quite succesful at that
01:23:37 <merijn> Naah #c is just full of grumpy old men that like yelling
01:24:04 <duckinator> haha
01:24:25 <merijn> I swear, every time I go there with a question I regret it within seconds
01:24:32 <duckinator> haha
01:24:49 <duckinator> merijn: i ask someone else to do it for me :>
01:25:13 <duckinator> idk if that falls under "genius" or "lazy"
01:26:49 <cncl> i'm surprised there are so many haskell people using vim
01:27:15 <merijn> Why?
01:27:41 <cncl> i was under the impression emacs was more popular
01:27:45 <cncl> i'm not sure why
01:28:01 <wli> nvi
01:28:06 <duckinator> i use geany myself. except for ooc, which i develop in emacs (because ooc-mode has the best completion/highlighting/formatting/etc out of all the different things i've tried for ooc...)
01:29:08 <duckinator> i'd use emacs, but if i have a gui, i prefer using gui programs :P
01:29:11 <merijn> vim was the first Real Editor(TM) I learned to use dunno why really, but I can't be arsed to invest the time to learn something else. And I've yet to find a machine which didn't have some sort of vi/vim editor available
01:29:26 <merijn> duckinator: xemacs? :p
01:29:29 <quicksilver> duckinator: emacs is a gui program.
01:29:39 <cncl> i actually use viper-mode and vimpulse in emacs, to make the keys work like vim
01:29:41 <duckinator> i mean a gui that doesn't look like a cli program with a border around it :P
01:29:46 <merijn> I use gvim under windows, but under OS X I prefer just using a terminal version of vim
01:29:56 <quicksilver> the reason you get the impression emacs is more popular is that emacs users are noisier.
01:29:59 <merijn> Terminals are our friends :)
01:30:05 <quicksilver> and in particular, I'm extremely noisy.
01:30:09 <cncl> quicksilver: yes :)
01:30:13 * wli used SunOS 4 vi and DYNIX/ptx vi.
01:30:13 <Raynes> I can't bring myself to use Vim, being an Emacs user.
01:30:16 <jnj> Can someone explain the difference between the functions (<2) and (<)2. Checking: (<2) 1 == True and (<)2 1 == False. Aren't both just a curried (<) function? It seems the argument order is switched, or what am I missing?
01:30:20 <Raynes> I like Emacs way of doing things with modes and such.
01:30:35 <duckinator> i like how emacs works, i just dislike how it looks. that's all :P
01:30:37 <cncl> jnj: (<) 3 4 == (3 < 4)
01:30:44 * wli also used ed and ex on z29's.
01:30:55 <Botje> jnj: (<2) = \x -> x < 2
01:30:56 <merijn> jnj: (<2) takes 2 as a right side argument, (<)2 takes 2 as a left side argument
01:30:56 <duckinator> o.O
01:31:11 <jnj> Thank you
01:31:12 <duckinator> wli: what's ex? :P
01:31:12 <Raynes> The GNOME Emacs interface doesn't look that bad.
01:31:33 <merijn> I'm refraining from commenting before another editor holy war :p
01:31:39 <wli> duckinator: Line editor bundled with vi.
01:31:46 <duckinator> Raynes: meh. it's alright
01:31:50 <duckinator> but, i'm just picky is all ;P
01:32:07 <wli> duckinator: The non-editing-mode commands are basically the line editor's commands.
01:32:16 <Raynes> merijn: I'm totally fine with people using Vim. It's their los... choice. :>!
01:32:22 <duckinator> lol
01:32:23 <cncl> frequently i like to change the names of definitions in a project in haskell, like i want to rename a function fromAddr to fromOffset or something
01:32:35 <cncl> is there a better way to do it than string find/replace?
01:32:44 <duckinator> cncl: what editor? :P
01:32:51 <duckinator> if you're using vim, :%s/old name/new name/g
01:32:52 <cncl> emacs or vim :)
01:32:56 <duckinator> :P
01:33:12 <cncl> yeah that's just simple string stuff
01:33:12 <duckinator> it's still find replace, but it's global
01:33:24 <duckinator> mmm....4:30am
01:33:26 <cncl> in emacs i would do it from dired and apply it to the directory
01:33:27 <duckinator> maybe i should go to sleep
01:33:29 <merijn> cncl: What are ways are their to replace two strings other then find/replace?
01:34:00 <merijn> cncl: I'd use sed
01:34:00 <harlekin> Does anyone know why reactive is broken and if it has been fixed, but changes aren't in official releases yet?
01:34:05 <wli> You guys realize that's not special to vim; it's the baseline for vi implementations etc.
01:34:11 <cncl> merijn: editors that are syntax-aware (in other languages) can do it by recognizing actual use of the functions, rather than just manipulating all of the text as strings
01:34:13 <fasta> merijn, he means something that works on the AST, probably.
01:34:18 <cncl> yup
01:34:22 <fasta> So, his question was wrong ;)
01:34:37 <fasta> Or not.
01:34:43 <fasta> I should read more than 10 lines up.
01:34:52 <cncl> since sometimes i will have two functions in different modules that are logically distinct but may be named the same at some point
01:35:02 <cncl> or something like that
01:35:06 <fasta> cncl, HaRe can maybe do it. 
01:35:15 <Saizan> cncl: there was HaRe, but i'm not sure if it's usable now, but you could still do it with haskell-src-exts
01:35:19 <cncl> oh yeah, i remember hearing about that, i forgot about it
01:35:23 <fasta> cncl, I believe someone revived it. 
01:35:32 * duckinator -> zzzz
01:35:33 <duckinator> 'night
01:35:37 <fasta> Still, if it were really alive, Haskell-mode would have it.
01:35:42 <Saizan> the problem is that understanding scoping is a bit harder than just parsing
01:36:22 <Saizan> so maybe it'd be better to use the ghc-api
01:36:55 <aRcatan> hmm, there has been a HaRe release just two months ago
01:38:22 <cncl> i tried yi a few times and thought it was pretty damn cool, but also always had installation flakiness (from both darcs or cabal) and i'm always scared of committing to an editor that isn't widely used
01:38:27 <fasta> Saizan, is there a hard definition for parsing which says that the "semantic analysis" part is completely distinct?
01:39:16 <fasta> Saizan, I had a discussion with this with a professor once and he explained it was just "convention" to separate the two. 
01:39:36 <fasta> about this*
01:40:26 <Saizan> fasta: i'd say that too
01:40:46 <Saizan> but i've never looked for such a definition either
01:41:43 <quicksilver> fasta: one reason to draw the line is to keep the parsing context free
01:41:52 <quicksilver> fasta: and add the context sensitive parts in the 'semantic analysis'
01:42:00 <quicksilver> but, I agree, it's just convention.
01:43:19 <merijn> Well, I believe it's much simpler to do, hence the convention to do it that way
01:43:20 <Saizan> haskell is already blurring that line with operators fixities/precedences, for example
01:43:40 <Saizan> if you count resolving those as parsing :)
01:45:57 <cncl> i really like agda2's mixfix and any-name-for-anything syntax
01:48:07 <fasta> cncl, does agda2 also have something like Coq's Notation?
01:49:34 <Saizan> no
01:50:31 <Saizan> you get really close with the mixfix, but there are some limitations like order of arguments
01:52:10 <fasta> Saizan, is mixfix the same as the GHC extensions, but with more precedence levels?
01:53:38 <Saizan> no
01:54:03 <Saizan> you can, for example, define if_then_else_ as an operator
01:54:51 <ivanm> I must say, Saizan's last comment confused me until I looked up and realised he was talking about agda... ;-)
01:54:52 <Saizan> when you define an operator you use _ as a placeholder for where the arguments should go
01:55:51 <Saizan> whitespace is then required to separate tokens.
01:57:18 <Saizan> which makes you free to use any character in any name :) except for {;} which are stolen as keywords, iirc
01:58:59 <Saizan> "data [_] (a : Set) : Set where [] : [ a ]; _::_ : a -> [ a ] -> [ a ]" <- valid agda to define lists
02:01:12 <cncl> HaRe just complains about missing source files for everything :(
02:01:29 <cncl> since i do not have the sources for all of the libraries i use, i guess, since i installed them from cabal
02:02:22 <ivanm> is this cabalised hare?
02:02:36 <ivanm> if so, maybe it didn't get installed properly...
02:02:52 <ivanm> also, you should remember that HaRe only accepts Haskell98 code (due to its parser being so old)
02:03:22 <cncl> i downloaded the snapshot from the site
02:03:28 <cncl> should i install it again from cabal?
02:03:52 <ivanm> in that case, its installation is tricky
02:03:56 <ivanm> and you probably didn't do it right
02:03:59 <cncl> would hare fail with generalizednewtypederiving
02:04:06 <ivanm> yes
02:04:12 <ivanm> AFAIK it doesn't accept _any_ extensions
02:04:15 <cncl> aw :)
02:04:19 <ivanm> but if you want, try installing the version from hackage
02:04:21 <cncl> ok well, so much for that
02:10:13 <quicksilver> scion is a more modern attempt to do hare-like stuff
02:10:26 <quicksilver> I'm not sure if scion support intelligent renaming or not
02:16:05 <fasta> quicksilver, the last time I tried scion, scion was vaporware.
02:27:12 <quicksilver> fasta: well it does exist, but it doesn't do very much at all. I think the only really useful thing it does so far is "intelligent-jump-to-identifier" and "intelligent-get-type-of-identifier"
02:27:26 <fasta> quicksilver, and even that never worked.
02:27:30 <quicksilver> however, those things appear to show it already has the structures in place for intelligent rename.
02:28:12 <fasta> quicksilver, on two different occasions I was a test user and each time it didn't work for one excuse or another. 
02:28:43 * quicksilver shrugs
02:28:49 <quicksilver> whatever.
02:28:59 <quicksilver> I'm sure it works for nominolo and can be made to work for other people.
02:29:21 <fasta> quicksilver, I can make everything to work. That doesn't mean that it does. 
02:32:42 <franksh> what does "~" mean in type declarations? when i :t an expression in ghci it tells me its type is "(RGBFormat ~ TextureFormat t, LoadableTexture t) => IO t"
02:38:26 <FunctorSalad_> equality
02:38:57 <walter_> ?
02:44:07 <walter_> I am Just learn State monad. Could any one write a "f" for >>=   in Let z = State $ \s -> ( 6, "abcdef" ) ? Many Thanks.
02:44:40 <dobblego> walter_, are you asking how >>= works for the State monad?
02:44:44 <franksh> FunctorSalad_, as in, the type of 't' is equal to 'RGBFormat'? why doesn't it just say RGBFormat then?
02:44:59 <walter_> dobblego, yes!
02:45:37 <dobblego> walter_, consider the signature for (>>=) :: m a -> (a -> m b) -> m b
02:45:52 <FunctorSalad_> franksh: TexureFormat t is equal to RGBFormat; that doesn't let you eliminate t
02:45:54 <dobblego> walter_, now consider m = State s then we have State s a -> (a -> State s b) -> State s b
02:46:27 <dobblego> walter_, which is then (s -> (s, a)) -> (a -> s -> (s, b)) -> s -> (s, b)
02:46:51 <walter_> dobblego, so how to get a 
02:47:06 <dobblego> walter_, the definition of this function plonks that last 's' into the given function to get (s, a) then plonks that into the other given function
02:47:38 <walter_> f :: Int -> State String Int
02:48:29 <dobblego> yes sorry, I have the return type (pair) around the other way
02:49:05 <dobblego> but otherwise, you should try writing that function in its raw form
02:49:41 <walter_> dobblego,  seems    f s = return $ (length s, tail s)  doesn't work
02:49:52 <dobblego> no no, you want to be polymorphic
02:50:33 <dobblego> let f :: (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s); f = error "todo"
02:51:28 <walter_> I was thought f should be a -> ma , so String -> State String Int
02:51:55 <dobblego> well s and a will be specific types in the end, but you don't want to think of the general function in terms of those types
02:52:14 <dobblego> you don't want to be calling length or tail or anything like that
02:53:14 * hackagebot hstzaar 0.2 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.2 (PedroVasconcelos)
02:54:41 <franksh> FunctorSalad_, so... I have this type 't' that's an instance of TextureFormat (or is that TextureFormat t?).. and types like t that are instances of TextureFormat are equal to RGBFormat? probably some major misunderstanding here. like, what does "(String ~ Maybe a) => IO a" tell me about 'a'? or does that not make any sense?
02:54:43 <walter_> dobblego,  so f :: State String Int -> String -> State String Int -> State String Int ?
02:55:01 <walter_> my God
02:55:02 <dobblego> no, it's just "any s" and "any a"
02:55:08 <dobblego> it's a polymorphic function
02:55:12 <FunctorSalad_> franksh: TextureFormat is a type function, not a class
02:55:15 <dobblego> you want to forget about Stringt and Int
02:55:30 <walter_> dobblego,  I see. 
02:56:38 <walter_> but why souldnt think State monad in the General way  like maybe monad or else?
02:56:48 <FunctorSalad_> franksh: String ~ Maybe a is impossible, but for a type synonym family instead of Maybe it's possible
02:56:55 <dobblego> no you should be thinking in the general way
02:57:14 <dobblego> think of State s a as s -> (a, s) 
02:59:35 <franksh> aw man. I have a feeling I'm going to have to spend days trying to understand this and all I wanted was to make some tutorial example compile.
02:59:38 <walter_> dobblego, thanks, but I am still confused on the type of f, could you show me a sample of f ?
03:00:20 <FunctorSalad_> franksh: it's a bit unfortunate that type functions from type synonym families have the same syntax as type constructors... they don't behave like constructors
03:00:34 <walter_> In fact I can not kick off a -> m a on f
03:00:46 <dobblego> let f :: (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s); f p q s = let (a, s') = p s in q a s'
03:00:54 <dobblego> I did that at ghci
03:01:04 <FunctorSalad_> type family Foo a :: *; type instance Foo String = String; type instance Foo Int = String
03:01:10 <walter_> dobblego, many thanks!!!
03:01:13 <FunctorSalad_> @ franksh : that would be legal
03:01:28 <FunctorSalad_> so Foo String would be equal to Foo Int...
03:02:00 <walter_> dobblego, I need time to thinks of it. Thanks again.
03:02:10 <dobblego> walter_, no worries mate, let me know how you get on
03:02:19 <walter_> dobblego, sure!
03:02:20 <franksh> oh.. so "Foo String" is the actual type here? and equal to "Foo Int" and "String"?
03:03:19 <FunctorSalad_> franksh: yes, and type (synonym) families like Foo are different than type constructors like Maybe in that that's possible
03:03:56 <zygoloid> franksh: "(RGBFormat ~ TextureFormat t, LoadableTexture t) => IO t" means: if you give me a type 't' where 't' is an instance of LoadableTexture, and the TextureFormat of t is RGBFormat, then i can give you back a recipe for producing a value of type 't' (an (IO t) action)
03:04:02 <FunctorSalad_> (equality was only introduced together with type families since it's not useful otherwise, as you say)
03:06:28 <franksh> ah, hm, it's starting to become clearer, thank you.
03:17:11 <Zeiris> Is there some simple (and thus trustworthy) way to define Arrow instances for Events?
03:17:40 <dobblego> you could ask djinn (I don't know what an Event is)
03:18:07 <quicksilver> Zeiris: Event in the reactive sense?
03:18:33 <Zeiris> Event in the standard sense. As they're used in GUIs and whatnot.
03:18:57 <cncl> like a mouse click or key press?
03:19:05 <Zeiris> A discrete occurance that gets passed around through a chain of handlers. Like those, yes.
03:19:07 <dobblego> I didn't know there was a standard; do you have a link to the data type?
03:19:07 <quicksilver> well there's no obvious way to make that kind of event be a type constructor with two parameters.
03:19:23 <quicksilver> so there is no obvious way even to make the question of Arrow instance make sense.
03:19:36 <cncl> you would probably not make an Arrow instance for Event
03:19:44 <cncl> you could probably make one for something like EventHandler
03:19:50 <cncl> i.e. some processor that handles events
03:20:14 <Zeiris> Hm, yes. Event stream, even. Lazy lists alone wouldn't work due to blocking, right?
03:20:14 <cncl> and then link them together to handle events in some way
03:20:45 <cncl> you can do it with lazy lists, or monads, too
03:20:56 <cncl> the primary reason to favor arrows over monads is that the compiler can easily eliminate space leaks
03:21:03 <cncl> (as far as i know)
03:21:58 <cncl> (someone please correct me if i'm wrong)
03:23:50 <Saizan> not really
03:23:58 <quicksilver> cncl: you're wrong.
03:24:08 <quicksilver> they're almost entirely incomparable concepts.
03:24:21 <quicksilver> The primary reason to favour horses over oranges is that horses have longer tails.
03:24:47 <Saizan> well, they can be seen as two styles to make edsls
03:24:49 <cncl> haha
03:24:56 <cncl> well i know they are not the same thing
03:25:32 <Saizan> and the arrow interface allows more instrospection, hence the combinator have more ability to "optimize" themselves
03:25:38 <quicksilver> it takes considerable work to set up a circumstance in which they are sensibly comparable though.
03:25:57 <quicksilver> one such comparable setup is convential parser monads vs. S-D style parser arrows
03:26:11 <quicksilver> in that setup, Saizan's advantage is the arrow advantage.
03:26:29 <cncl> Saizan: yes, because the 'input' type can be looked at
03:26:35 <cncl> instead of it just being a thunk
03:26:41 <cncl> er, function
03:26:51 <cncl> i guess i worded it poorly
03:27:04 <fasta> Designing something to be an arrow doesn't really have any point, AFAIK. If something is too slow, you simply figure out why that is the case and you fix that. It is just another data structure. 
03:27:30 <fasta> That something happens to turn out to be an arrow could be an interesting academic fact with even some possible use, but that's about it.
03:28:03 <Saizan> cncl: you still can't look at the input ahead of time, but "arr a b" can carry some useful inspectable information, while (a -> m b) is opaque
03:28:52 <cncl> i didn't mean the input itself, i meant the 'a' part of arr a b
03:29:17 <Saizan> that's what i mean by input
03:29:24 <cncl> oh ok :)
03:29:37 <aleator_> What do people usually do when they want to persist datatypes containing functions?
03:29:50 <Saizan> cry?
03:29:55 <cncl> i was going to say cry, yeah
03:30:25 <aleator_> Saizan: I thought so as well :/
03:30:27 <Saizan> if these functions are statically known you can make a lookup table one way or another
03:31:00 <Saizan> or you can make up a language to interpret at deserialization time :)
03:31:37 <aleator_> I have almost garroted myself with hint trying for a "clean" solution. (Wasn't)
03:31:46 <merijn> Not if you use Lisp, then you just say "Well that's easy, we do it all the time!"
03:31:48 <cncl> there are actually lisp and scheme libraries that do this, for making web sites with continuations, it's pretty nasty though i think
03:32:07 <Saizan> i assumed "in haskell"
03:32:16 <cncl> right :]
03:32:17 <merijn> In haskell you cry, yeah
03:32:24 <merijn> Like most other languages, tbh
03:32:27 <aleator_> All I'd want would be "String -> a" where a is something I've compiled in and given a name.
03:32:29 <Saizan> actually, i've assumed "in GHC"
03:32:38 <fasta> If you control the implementation there is nothing hard about it. In Haskell there is no concept of a "serialized function", since they are opaque. 
03:32:45 <merijn> aleator_: If you find it, let me know
03:33:19 <Saizan> since yhc apparently had function serialization, probably not working so well though :)
03:33:22 <aleator_> I mean, I can do this with foreign exports, so why not without..
03:33:56 <aleator_> Hmm.. Unless I make a encode/decode wrapper and a foreign export / import and TH it into submission..
03:34:27 <Saizan> if you just need to lookup a symbol like that why doesn't hint work?
03:34:43 <fasta> aleator_, what are your real requirements? 
03:35:06 <aleator_> Saizan: Because it loads a another object and gets me into trouble with all kinds of stuff..
03:35:40 <Saizan> you could try direct-plugins
03:36:05 <aleator_> fasta: I have an experimental setup, that I need to be very careful to be able to repeat and would like to be able to log everything/restore when needed
03:36:50 <aleator_> Saizan: Hey, that could work.
03:36:51 <fasta> aleator_, I fail to see how that relates to your question. 
03:37:12 <aleator_> Well, an experiment is a function in the end.
03:37:38 <fasta> aleator_, an experimental setup can also mean that you are next to CERN. 
03:37:45 * hackagebot primes 0.1.1.1 - Efficient, purely functional generation of prime numbers  http://hackage.haskell.org/package/primes-0.1.1.1 (SebastianFischer)
03:37:50 <fasta> aleator_, a computational experiment?
03:37:56 <aleator_> fasta: Ah. I meant a computational experiment
03:38:38 <fasta> aleator_, I did computational experiments and I never needed that, and I am pretty sure I didn't break any scientific rules.
03:38:56 <fasta> aleator_, there are papers about how to do experiments like that.
03:39:34 <aleator_> fasta: I think we are talking about different things.
03:39:35 <fasta> aleator_, all I am saying is  that you probably just want to do a cool Haskell hack, but that there is no reason to do so. 
03:39:55 <fasta> aleator_, that is very possible. 
03:40:46 * hackagebot primes 0.2.0.0 - Efficient, purely functional generation of prime numbers  http://hackage.haskell.org/package/primes-0.2.0.0 (SebastianFischer)
03:40:56 <temoto> how to declare a data type whose parameter must be of some class?
03:40:57 <cncl> speaking of Arrows, i don't really seem to see them in libraries now, but it seems like they got some use (like in yampa) a few years back.
03:41:06 <cncl> what happened?
03:41:28 <temoto> like  data Foo = Bar | (Num n) => Size n Zar
03:41:38 <aleator_> fasta: Well, what I do need to do is save the setup and the arguments of functions that I apply along with their results and currently this is tedious. Just looking for something easier.
03:42:42 <fasta> aleator_, how many different functions do you have then? 
03:43:04 <aleator_> 38 now.
03:43:14 <fasta> aleator_, ok, then I understand the problem.
03:43:25 <fasta> aleator_, I think TH can solve that. 
03:43:33 <Saizan> cncl: given how it's a bit painful to use the Arrow interface compared to Monad you need a good reason for that, and some libraries do.
03:43:37 <aleator_> All with nastily different states and so on.
03:43:42 <fasta> aleator_, but I wouldn't do it until I hit 100. 
03:44:28 <cncl> Saizan: are there any popular examples? (other than yampa)
03:44:58 <Saizan> temoto: why not just "data Foo n = Bar | Size n Zar" ?
03:45:41 <aleator_> fasta: Maybe I'm procrastinating. The actual tests are tedious and boring.
03:46:23 <temoto> Saizan, i don't want to make parametrized type. Just want a constructor that accepts integer or float.
03:47:11 <temoto> Saizan, maybe closer would be   data Foo = Bar | Sizei Integer Zar | Sizef Float Zar
03:47:13 <Saizan> cncl: not sure about popular, recently i've seen this "haskell on horse" webframework and read about iPwn using them
03:47:38 <pokoko222> what is your experience with software process modeling class in college? bad, theoretical bullshit or cool stuff?
03:47:42 <FunctorSalad_> on horse??
03:47:47 <cncl> Saizan: ok :)
03:48:26 <cncl> temoto: GADTs let you have parameterized constructors without having the parameter appear in the type of the data
03:48:48 <Saizan> temoto: you can have "data Foo = Bar | forall n. Num n => Size n Zar" with ExistentialQuantification, but you won't be able to know the exact type of that parameter when you pattern match on Size
03:48:53 <Saizan> temoto: only that it's a Num
03:50:02 <Saizan> which is the same situation you get with GADTs
03:50:33 <temoto> Thanks, i don't need exact type.. i guess
03:52:18 <llaarrll> hello 
03:53:04 <llaarrll> anybody home?
03:53:45 <llaarrll> Im working through RWH at the moment, the section on DB to be specific 
03:53:59 <llaarrll> came to this: stmt <- prepare conn "INSERT INTO test VALUES (?, ?)"
03:54:16 <llaarrll> however, when I run: execute stmt [toSql 1, toSql "one"]
03:54:21 <llaarrll> I get the following error:
03:54:28 <llaarrll>   No instance for (Data.Convertible.Base.Convertible t SqlValue)
03:54:28 <llaarrll>       arising from a use of `toSql' at <interactive>:1:14-20
03:54:28 <llaarrll>     Possible fix:
03:54:28 <llaarrll>       add an instance declaration for
03:54:31 <llaarrll>       (Data.Convertible.Base.Convertible t SqlValue)
03:54:37 <llaarrll>     In the expression: toSql 1
03:54:37 <llaarrll>     In the second argument of `execute', namely
03:54:41 <llaarrll>         `[toSql 1, toSql "one"]'
03:54:44 <llaarrll>     In the expression: execute stmt [toSql 1, toSql "one"]
03:54:49 <Saizan> llaarrll: don't paste so many lines in the channel.
03:54:51 <llaarrll> any ideas?
03:54:59 <llaarrll> sorry about that
03:54:59 <Saizan> use a pastebin next time
03:55:09 <Saizan> anyhow, you need to add a type annotation to 1
03:55:25 <Saizan> e.g. "execute stmt [toSql (1 :: Int), toSql "one"]"
03:55:31 <llaarrll> understood, Im new around here, and thus learning the ropes
03:56:11 <Saizan> no problem :)
03:56:21 <llaarrll> many thanks, Saizan, that worked :-)
03:56:54 <fasta> llaarrll, try to understand the error message now. 
03:57:09 <llaarrll> oh, I see
03:57:16 <llaarrll> its right there in front of me
03:57:25 <Saizan> ?type 1
03:57:27 <lambdabot> forall t. (Num t) => t
03:58:23 <llaarrll> thanks, you guys are awesome -- quite helpful! Well, back to studying!
04:05:54 <sohum> :t groupBy
04:05:56 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
04:06:32 <sohum> > groupBy (>) [1,2,3,4,3,4,2,1,2,3]
04:06:33 <lambdabot>   [[1],[2],[3],[4,3],[4,2,1,2,3]]
04:07:05 <sohum> > groupBy (<) [1,2,3,4,3,4,2,1,2,3]
04:07:06 <lambdabot>   [[1,2,3,4,3,4,2],[1,2,3]]
04:07:16 <sohum> hm. not quite what I was thinking
04:07:56 <zygoloid> sohum: groupBy requires the function to be an equivalence relation
04:08:04 <zygoloid> otherwise the results are not specified
04:08:19 <sohum> zygoloid: ok, fair enough
04:08:34 <zygoloid> as it happens, the implementation in GHC compares each subsequent value to the first element of the group
04:08:38 * sohum nods
04:08:52 <sohum> what's the generalisation of group to more than one direction?
04:09:17 <zygoloid> you mean, group by this, then group by that?
04:09:56 <sohum> no - group by this in multiple different directions. on, say, an Array (Int, Int) _
04:10:01 <sohum> @source group
04:10:02 <lambdabot> group not available
04:10:15 <ivanm> group = groupBy (==)
04:10:18 <ivanm> @src groupBy
04:10:19 <lambdabot> groupBy _  []       =  []
04:10:20 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
04:10:20 <lambdabot>     where (ys,zs) = span (eq x) xs
04:10:51 <sohum> span...
04:10:55 <zygoloid> sohum: what would that mean? would you want to find rectangular regions which are all equivalent values? i don't think that's unique
04:11:16 <sohum> zygoloid: why wouldn't it be unique?
04:12:04 <zygoloid> sohum: group2d [[0,0],[0,1]] could pick a horizontal rectangle and two single-item ones, or a vertical rectangle and two single-item ones
04:12:23 <sohum> zygoloid: oh, right, I'm not thinking generically enough
04:12:26 <ClaudiusMaximus> contiguous regions might be more easily uniquified?  but then you need to decide if diagonals count...
04:12:49 <zygoloid> yeah. then you're looking at some kind of generalized floodfill algorithm
04:13:06 <sohum> ah, of course, /that/s what it would be named
04:14:35 <zygoloid> though at that stage you probably want to abandon the requirement for an equality relation and specify that you're comparing the element to its neighbours
04:15:25 <sohum> aha http://en.wikipedia.org/wiki/Connected_Component_Labeling
04:16:07 <ketil> To get the best concurrency (STM) performance, should I get the latest GHC 6.13, or the GHC 6.12.3 beta? 
04:16:34 <ketil> (Presumably 6.10 which I have installed is too old)
04:18:35 <ivanm> ketil: probably depends if they've done any internal changes
04:18:48 <ivanm> might be better off asking in #ghc or the ghc mailing list about something like that
04:19:47 <sohum> zygoloid, ClaudiusMaximus, ivanm: thanks muchly
04:19:59 <ketil> ivanm - thanks, I'll try #ghc and see what happens. :-)
04:20:00 <ivanm> sohum: I didn't say anything to you!
04:20:10 <ivanm> oh, wait, you wanted source of group...
04:20:12 <sohum> ivanm: you gave me the source to groupBy
04:20:13 <sohum> :D
04:53:12 * hackagebot YampaSynth 0.1.1 - Software synthesizer  http://hackage.haskell.org/package/YampaSynth-0.1.1 (GeorgeGiorgidze)
05:08:59 <Wooga> can i use guards in \lambda->expressions ?
05:09:19 <RayNbow> Wooga: you can use guards in case-of expressions
05:09:29 <Wooga> RayNbow: thanks!
05:11:34 <RayNbow> Wooga, see: http://www.haskell.org/haskellwiki/Blow_your_mind#Other
05:12:30 <RayNbow> > (\x -> case () of () | x == 3 -> 3 | otherwise -> 0) 3
05:12:31 <lambdabot>   3
05:12:36 <Wooga> RayNbow: oh, neat!
05:13:48 * zygoloid has always thought it odd that lambdas don't support guards
05:13:59 <Ferdirand> blow your mind ? oh god I'm afraid to look at that link
05:22:11 <temoto> @djinn Double -> Float  please :)
05:22:11 <lambdabot> Cannot parse command
05:31:22 <Wolfspaw> Is the Yi Editor still an active project? the last news from it i found was from march of 2009 o.o
05:34:42 <nominolo> Wolfspaw: it's a bit quiet, but not dead
05:35:22 <Wolfspaw> nominolo: hm, good. I though it was a very cool project and i was afraid of its quietness ;~~~
05:36:30 <tafryn> Wolfspaw: The last darcs activity was on the 12th, so it looks like it's still going.
05:36:45 <nominolo> Wolfspaw: the main contributers don't have much time to spend on it.  they have a very open commit policy, though, so it's easy to contribute if you wish
05:38:04 <Wolfspaw> nominolo: Im very newbie, but it would be great to contribute. As soon as i grasp more of haskell i'll see if i can help it!
05:40:15 <ClaudiusMaximus> temoto: http://hackage.haskell.org/packages/archive/logfloat/0.12.1/doc/html/Data-Number-RealToFrac.html
05:42:40 <temoto> ClaudiusMaximus, thanks
05:47:05 <Wooga> can't i somehow perform IO actions inside of State monad?
05:47:34 <ivanm> no...
05:47:38 <ivanm> you can _compose_ IO actions
05:47:52 <ivanm> but unless you use a StateT transformer over IO, you ca'nt actually run IO inside State
05:48:52 <Jafet> You can, but it voids your warranty
05:50:40 <winxordie> there was a warranty?
05:51:42 <dino-> Wooga: This really helped me to understand transformers: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.71.596
05:51:50 <Jafet> That's why you should never use pirated Haskell
05:52:14 <zygoloid> @yarr
05:52:15 <lambdabot> Ahoy mateys
05:53:32 <Wooga> thank you!
05:54:31 <kmc> Wooga, the only way you can perform an IO action, ever, is a) name it "main" in module Main, or b) type it at the prompt in GHCi
05:55:13 <kmc> if you can arrange for your State-monad action to produce an IO action and eventually get it to 'main', it will run then
05:56:09 <kmc> the type «State s (IO a)» represents "actions in a state monad, which produce actions in the IO monad"
05:56:25 <zygoloid> or c) compose it into a larger action which is itself run at some point
05:56:30 <kmc> the type «StateT s IO a» represents "actions in a monad which has both state and IO"
05:57:22 <kmc> both types are used, depending on what you want to do
06:00:43 <Wooga> i don't really know. i am re-writing my brainfuck interpreter to use State monad instead of recursive parameters, so i have to run actions "in place", for getting input for example
06:01:00 <kmc> then you probably want «StateT s IO a»
06:01:08 <Wooga> thanks!
06:01:10 <kmc> @unmtl StateT s IO a
06:01:10 <lambdabot> s -> IO (a, s)
06:01:26 <absentia> thank you.  I still think the game's input system is retarded.. but I was able t play through with the hinting./win shrink 3
06:01:47 <absentia> wow, what a missend. sorry.
06:02:33 * ddarius hates marco.
06:09:53 <Saizan> marco?°°
06:11:33 <Philippa> ddarius: what's he done this time round?
06:12:51 <ddarius> Philippa: It's the same thing as always.  He just always thinks he's right, which would be fine if he ever actually was or at least would keep his mouth shut.
06:13:52 <Twey> Who's marco?
06:14:56 <ivanm> some guy that discovered China
06:19:22 <theorbtwo> Funny, sounds like a coworker of my girlfriend's, also named Marco.
06:22:58 <ottoliere> !list
06:25:04 <ddarius> theorbtwo: He discoverd China as well?
06:26:01 <ycm> Anyone here has good resources for someone who touched haskell very slightly about a year ago and wants to start learning it properly?
06:26:17 <kmc> @where LYAH
06:26:17 <kmc> @where RWH
06:26:18 <lambdabot> http://www.learnyouahaskell.com/
06:26:18 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:26:18 <copumpkin> this channel
06:26:27 <ddarius> @where gentle
06:26:27 <lambdabot> http://www.haskell.org/tutorial/
06:26:31 <ddarius> Yay!
06:26:37 <copumpkin> :O
06:27:11 <copumpkin> @where brutal
06:27:11 <lambdabot> http://book.realworldhaskell.org/
06:27:19 <kmc> haha
06:27:23 <ycm> what?
06:27:28 <aRcatan> i thought it'd be the report
06:27:30 <ycm> there is a "brutal" guide to haskell?
06:27:37 <aRcatan> or GHC sources!
06:27:42 <ddarius> aRcatan: The Report isn't brutal.
06:27:50 <kmc> there is a "gentle introduction to haskell"
06:27:55 <kmc> which is a good document, but not a tutorial
06:27:56 <ddarius> GHC's sources probably are.
06:28:23 <aRcatan> ddarius: yeah, i know, but the report still probably isn't the best introduction to Haskell
06:28:25 <fasta> ycm, I am sure there are some people offering brutal guides, if you are looking for one.  
06:29:11 <kmc> i think bits of the report are actually worth reading early on
06:29:14 <kmc> like the description of layout
06:29:26 <ycm> fasta: heh, I never got my head around three things : the Types system, the let keyword, and monads.
06:29:30 <harlekin> Is the local time of a signal somehow accessable in reactive?
06:30:03 <kmc> the "let" keyword is the simplest of those three
06:30:12 <fasta> ycm, all of them are described in the report. About the type system I can tell that the people who implemented it don't even understand it... 
06:30:23 <kmc> i don't think that's true
06:30:30 <kmc> H98's type system isn't that crazy
06:30:32 <ddarius> fasta: The Haskell 98 type system is quite simple.
06:30:33 <ycm> fasta: hahahaha, I don't think that's quite right.
06:30:37 <kmc> it gets more complicated as you add extensions
06:30:39 <fasta> kmc, H98 is easy.
06:30:56 <kmc> ycm, if "e" is an expression and "..." is a sequence of bindings, then "let ... in e" is an expression
06:31:02 <kmc> with the meaning that those bindings scope over e
06:31:12 <kmc> > let x = 3; y = 4; z = x+y in z*4 + x
06:31:13 <lambdabot>   31
06:31:24 <fasta> ddarius, I was talking about the GHC type-system. 
06:31:28 <ycm> kmc: you see, you lost me at "bindings"
06:31:32 <kmc> ok
06:31:36 <ddarius> fasta: GHC's type system isn't Haskell's type system.
06:31:39 <kmc> "x = 4" is a simple binding
06:31:52 <ycm> so "binding" == "assignment?
06:32:05 <kmc> it's not really assignment
06:32:13 <kmc> it's creating a local name for an expression
06:32:15 <fasta> ddarius,  "the Types system" doesn't mean H98 or GHC. 
06:32:22 <fasta> ddarius, we simply do not know. 
06:32:25 <ycm> oh, in the mathematical sense?
06:32:28 <kmc> yes
06:32:33 <ycm> so...
06:32:36 <kmc> "let p be the largest prime number"
06:32:59 <ycm> I'm not sure if that simplifies things, but I think I grasp it somewhat
06:33:13 <ddarius> ycm: Do you understand lambda or where?
06:33:16 <ycm> so basically, that let statement you put up there...
06:33:28 <kmc> it's not a statement
06:33:31 <kmc> it's an expression
06:33:43 <ycm> why the distinction?
06:33:56 <kmc> expressions evaluate to values
06:34:01 <kmc> statements are steps to perform
06:34:02 <ddarius> Expressions have values, statements do not, though there are very few statements in Haskell.
06:34:13 <ddarius> > 3 + (let x = 3 in x+1)
06:34:15 <lambdabot>   7
06:34:55 <ycm> kmc: the way that expression up there works is like it'd work in a C program? You define a new scope?
06:35:01 <kmc> in Haskell statements appear within "do", and are built out of expressions
06:35:19 <kmc> ycm, it's not very helpful to learn Haskell by analogy to C or most other languages
06:35:38 <kmc> ycm, it does define a new scope; the bindings in the "let" part are valid throughout the "in" part
06:35:48 <kmc> (as well as within the "let" part itself; i.e. the bindings can be recursive)
06:35:58 <kmc> > let x=1:y; y=2:x in x
06:35:59 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
06:36:35 <ycm> and in that scope, x == 3, y == 4, z == x+y == 7, and then the end part, z*4+x is 7*4+3 which is 31?
06:36:56 <kmc> yes
06:37:22 <kmc> there's a bit of subtlety to when the computation actually occurs
06:37:24 <ycm> that example broke my mind. What does : stand for? catenation?
06:37:25 <kmc> due to lazy evaluation
06:37:30 <kmc> :t (:)
06:37:30 <lambdabot> forall a. a -> [a] -> [a]
06:37:37 <kmc> it adds an elemnent onto the beginning of a list
06:37:40 <kmc> > 'x' : "yz"
06:37:41 <lambdabot>   "xyz"
06:38:15 <kmc> "x contains 1 followed by the elements of y; y contains 2 followed by the elements of x"
06:38:23 <ycm> so, in that little thing up there, you were defining a list where every... yeah.
06:38:25 <kmc> the result is the least-defined value for which these equations hold
06:38:43 <kmc> which is the infinite list [1,2,1,2,...
06:38:54 <kmc> bbl
06:39:25 <ycm> does lambdabot respond to PMs?
06:39:33 <zygoloid> yes
06:40:08 <ycm> hmm, what happens if I accidentally input a very intensive calculation?
06:40:20 <quicksilver> > sum [1..1000000000000]
06:40:27 <lambdabot>   mueval: ExitFailure 1
06:40:29 <quicksilver> that.
06:40:30 <zygoloid> @bot
06:40:34 <lambdabot> :)
06:40:44 <ycm> quicksilver: okay. Good enough.
06:41:34 <nlogax> where can i increase the time limit for mueval, in lambdabot? was looking at the source before but didn't find it
06:42:30 <zygoloid> nlogax: personally i do it by writing a wrapper script around mueval itself
06:43:30 <zygoloid> nlogax: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29151#a29151
06:44:39 <Saizan> see Plugin.Eval
06:49:58 <nlogax> ahh, args.. didn't see it before
06:58:22 <Raghs> how do i load ord function into ghci
06:58:26 <ycm> :(
06:58:52 <Raghs> i know its part of Prelude, but my ghci can't seem to find it
06:58:57 <tab> Raghs: import Data.Char
06:59:37 <hpc> @src ord
06:59:38 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:00:03 <kmc> ord :: Char -> Int; ord = fromEnum
07:00:14 <kmc> > ord '☭'
07:00:15 <hpc> i suspected as much
07:00:15 <lambdabot>   9773
07:00:31 <harlekin> In reactive I have a system of entities moving to a specific point. How can I create an event that occurs when all entities reached that point?
07:00:42 <ycm> I just can't seem to write a proper reverse function in haskell. =( Gonna try some more.
07:00:43 <Raghs> thanks
07:00:52 <kmc> ycm, would you like some hints?
07:00:53 <medfly> reverse a list?
07:01:03 <ycm> medfly: I know reverse exists. :3
07:01:37 <quicksilver> harlekin: You need a solver for that. It's not a trivial thing.
07:01:43 <ycm> kmc: been trying on lambdabot but I'll get the platform before trying some more. I need to not have to type all that on one line. Messes with my mind. :3
07:01:50 <kmc> ah yes :)
07:01:58 <kmc> there's also http://tryhaskell.org/ which is lambdabot-ish
07:02:04 <ycm> tried.
07:02:09 <quicksilver> harlekin: of course it's simple to have a behaviour which monitors the total square distances between the entities or similar, and does something when that reaches zero.
07:02:16 <ycm> it hates me too, and wants me to type on one line.
07:02:19 <kmc> right
07:02:28 <kmc> if you get the platform you can write some code into a .hs file and then load it into ghci
07:02:32 <ycm> ;)
07:02:33 <kmc> that's probably the way to go
07:02:39 <kmc> since "reverse" will have multiple equations
07:02:46 <kmc> one for [] and one for (x:xs), i'll bet
07:03:49 <ycm> I'm doing it recursively. If the tail of the list is not null, I take the head and catenate it to the start of a list. If it is null, I return the new list.
07:03:53 <harlekin> quicksilver, do you know of any examples I could read?
07:04:03 <kmc> mhm
07:04:18 <harlekin> quicksilver, I just have no idea how I could predict the time the event should occur.
07:04:19 <ycm> oh, that's an interesting installer
07:04:37 <hpc> ycm: that doesn't seem like the right way to reverse a list; it sounds like it just puts the head of the list at the end
07:05:01 <ycm> (head list):newlist
07:05:16 <quicksilver> harlekin: right. I don't know of any examples I'm afraid.
07:05:32 <quicksilver> harlekin: what I mean by "you need a solver" is precisely that it's not trivial to predict the time an event will occur.
07:05:35 <hpc> i would do this:
07:05:37 <ycm> but I'll have to see how that works, gimme a sec, that installer is weird.
07:05:48 <hpc> take the head of the parameter list and put it at the end of the reverse of the tail
07:06:01 <quicksilver> harlekin: this is not a problem that reactive programming solves automatically, I'm afraid - finding the exact time of complex occurrences is, well, complex.
07:06:13 <quicksilver> harlekin: however, a really good reactive library would come with some solvers you could use.
07:06:22 <quicksilver> conal: are you really there or is that an idle IRC client?
07:06:43 <ycm> oh, how nice. The mac .pkg installer says to "click install to perform a standard installation" but the install button is greyed out =/
07:07:30 <int-e> @hoogle Functor2
07:07:31 <lambdabot> No results found
07:08:00 <Saizan> in true haskell form reverse is one line :P
07:08:06 <hpc> heh
07:08:20 <hpc> and recursive :P
07:08:33 <kmc> no
07:08:37 <Saizan> not explicitly
07:08:45 <kmc> it'd use foldl
07:08:51 * hackagebot dyre 0.8.5 - Dynamic reconfiguration in Haskell  http://hackage.haskell.org/package/dyre-0.8.5 (WillDonnelly)
07:08:53 <hpc> ah
07:08:53 <int-e> > foldl (flip (:)) [] [1..3]
07:08:55 <lambdabot>   [3,2,1]
07:08:59 <ycm> goddamnit.
07:09:06 <kmc> spoiler alert?
07:09:35 <int-e> meh. I"m not paying attention, sorry.
07:09:40 <ycm> That package just doesn't want to install. =/
07:09:41 <kmc> eh *shrug*
07:09:57 <kmc> writing it with two equations and explicit recursion is a good beginner exercise
07:10:55 <Saizan> goes ghc still have a mac installer? you might try with that
07:10:58 <Saizan> *does
07:11:11 <ycm> Saizan: yeah, the platform has a mac installer
07:11:55 <Saizan> i meant ghc as opposed to the platform
07:12:13 <ycm> well it's the GHC package that's messing up. XD
07:12:48 <Saizan> http://darcs.haskell.org/download/download_ghc_6_12_3.html#macosxintel
07:12:51 <Saizan> ah well :)
07:13:03 <ycm> oh, darn, it needs the UNIX dev part to be installed. =/
07:13:08 <ycm> okay then, my debian machine it is.
07:13:37 <ycm> (I'm running the Xcode 4 beta, so I didn't install the bundled tools... =/)
07:18:42 <ycm> urgh, the debian ghc says this : ghc-6.8.2: not built for interactive use
07:19:03 <Peasley> I cant believe such a simple code doesnt work.. http://codepad.org/XqOZNsms
07:19:53 <int-e> Peasley: try   print (factorial 10)
07:19:56 <Saizan> ycm: i'd use the generic linux binary tarball
07:20:09 <Saizan> ycm: http://darcs.haskell.org/download/download_ghc_6_12_3.html#binaries
07:20:09 <ycm> Saizan: seems like that's what I'm gonna do.
07:20:15 <int-e> Peasley: or print (factorial(10)), but that placement of parentheses is unusual in Haskell
07:20:28 <Twey> print $ factorial 10
07:20:34 <Peasley> int-e i see, coming from C :P
07:21:13 <Peasley> either way, the print(factorial 10) works, but why wont my code work?
07:21:20 <Peasley> is it because I dont assign the return value to anywhere?
07:21:25 <Saizan> what you'd write as "f(a,b,c)" in C is written as "f a b c" in haskell
07:21:27 <int-e> Peasley: the point is that  factorial 10  is an integer, not an IO action.
07:21:35 <Twey> Peasley: Because a do-block, at least in IO, is a list of things to do
07:21:42 <Peasley> ah fair enough
07:21:50 <Saizan> and if that appears inside another expression you write e.g. "g (f a b c) d"
07:21:51 <Twey> Peasley: ‘factorial 10’ isn't instructing Haskell to do anything — it's just a value
07:22:09 <int-e> Peasley: the confusion probably stems from the fact that ghci's imitation of an IO 'do' block is magical and allows pure values as well.
07:22:12 <ycm> hehe, the wonders of lazy eval
07:22:25 <Phyx-> does anyone know what "CheckHiWay" does?
07:22:54 <ycm> Saizan: I suppose there are no ppc binaries?
07:23:24 <quicksilver> int-e: I prefer to think of ghci as an eval loop with the magical ability to execute IO (rather than an IO do block with the magical ability to print values)
07:23:33 <quicksilver> I guess it's a matter of preference though.
07:24:36 <Phyx-> I prefer quicksilver version too
07:24:38 <EvanR-work> the ghci REPL is best thought of as a gorilla juggling large trouts
07:24:47 <int-e> Phyx-: an educated guess: it allows to detect mismatches between profiled, non-profiled or threaded, non-threaded builds. "Hi" as in "Haskell Iinferface", .hi files.
07:25:40 <int-e> quicksilver: as long as we agree that it's magical, I don't care ;) My primary use of ghci agrees with your view.
07:25:45 <Phyx-> int-e: right, I don't think I need that, I'm just looking to index the contents of all hi files
07:42:48 <Phyx-> int-e: ah, you were right, it is the flag to check for mismatches :)
07:45:01 * hackagebot console-program 0.2.0.0 - Interprets the command line and a config file as commands and options  http://hackage.haskell.org/package/console-program-0.2.0.0 (AriePeterson)
07:45:01 <Saizan> ycm: hah, that might explain why the debian one doesn't work so well :)
07:45:38 <ycm> Saizan: XD
07:49:48 <Phyx-> anyone know what an "ABI" is? mi_mod_hash :: !Fingerprint,    -- ^ Hash of the ABI only
07:50:26 <kmc> application binary interface
07:50:27 <ycm> Application Binary interface.
07:50:33 <EvanR-work> application binary interface
07:50:40 <ycm> It's a part of how your kernel interacts with running applications.
07:50:50 <kmc> > text $ map pred "bqqmjdbujpo!cjobsz!joufsgbdf"
07:50:51 <lambdabot>   application binary interface
07:51:28 <kmc> or how bits of an app interact with each other
07:51:47 <Saizan> Phyx-: that hash is mostly needed because different compilations of the same library can produce binaries with different symbols exported
07:51:52 <Phyx-> ah, ok, cool thanks :)
07:51:52 <ycm> like calling conventions or such
07:51:52 <kmc> for two object files to successfully link into working code, they must use the same ABI
07:52:08 <kmc> conventions about calling, alignment in structures, etc
07:52:11 <Phyx-> ah
07:52:32 <EvanR-work> which c++ doesnt seem to get right, ever
07:52:40 <EvanR-work> so you basically cant run half of c++ binaries
07:52:45 <Jafet> That's because no one's agreed on a standard ABI for C++
07:53:12 <Jafet> Didn't ghc use to produce nondeterministic symbols, or something?
07:53:32 <Saizan> yeah, as i said above :)
07:54:05 <Jafet> Ah, yes, that was the "fix"
07:58:07 <Phyx-> this is a long shot
07:58:17 <Phyx-> but is there such a thing as a ghc-pkg api? :P
07:58:26 <copumpkin> it's called cabal :P
07:58:28 <Phyx-> or am I just to parse  the results?
07:58:44 <copumpkin> but not sure :)
07:58:52 <Phyx-> cabal lists information about already installed packages?
07:59:14 <Saizan> Cabal exports a wrapper around ghc-pkg, in the HcPkg module
07:59:29 <Phyx-> awesome, thanks
07:59:35 <Phyx-> code_reuse++
08:20:20 <ycm> oh
08:20:24 <ycm> now to try writing reverse
08:22:37 <kmc> ycm, you got the platform installed?
08:22:53 <ycm> nope, I just installed ghc6 on a close-by debian x86
08:22:59 <ycm> and I sshed in
08:23:35 <kmc> cool :)
08:23:48 <ycm> does if require alignment?
08:23:48 <kmc> recent debian has a haskell-platform package
08:24:00 <kmc> ycm, you mean by indentation?
08:24:06 <ycm> yeah.
08:24:19 * hackagebot fibonacci 0.1.0.0 - Fast computation of Fibonacci numbers.  http://hackage.haskell.org/package/fibonacci-0.1.0.0 (SebastianFischer)
08:24:22 <kmc> ycm, it doesn't, but it's easy to write an "if" in such a way that it interferes with other constructs' alignment
08:24:33 <kmc> ycm, btw you should not need "if" for writing "reverse"
08:24:44 <Peasley> im already starting to like haskell but im yet only at the 100nd page on my book
08:24:53 <ycm> kmc: I'm trying to understand the syntax a bit.
08:24:56 <kmc> ok
08:25:23 <kmc> ycm, layout is only significant for delimiting blocks after keywords "let", "of", "do", and "where"
08:25:28 <kmc> (and modules, but we'll ignore that)
08:25:46 <kmc> if such a keyword is followed by {, layout is ignored and it is explicitly delimited
08:26:01 <kmc> otherwise, the column of the first non-whitespace token after the keyword sets the indentation
08:26:06 <zygoloid> kmc: modules is covered by 'where' ;)
08:26:09 <kmc> any lines at the same indentation get an implicit ';' prefixed
08:26:19 <kmc> any lines at a lesser indentation get a } prefixed, closing out the block
08:26:21 <kmc> zygoloid, that's true :)
08:26:29 <Ferdirand> top
08:26:37 <Ferdirand> oops
08:26:38 <zygoloid> Ferdirand: bottom
08:27:18 <kmc> ⊤
08:27:34 <kmc> ycm, http://www.haskell.org/onlinereport/lexemes.html#lexemes-layout
08:31:17 <ycm> what the hell
08:33:16 <kmc> hmm ycm?
08:33:38 <ycm> having trouble with that
08:33:54 <quicksilver> I don't think reading the haskell report on lexemes is the fastest way to enlightenment here.
08:34:02 <ycm> not that. XD
08:34:08 <ycm> Writing a small reverse
08:34:12 <ycm> using recursion
08:34:27 <ycm> it doesn't even compile
08:34:42 <kmc> ycm, what error do you get? can you put your code and error on hpaste.org?
08:34:47 <quicksilver> you'll get quicker and more accurate help if you paste the code, ycm ;)
08:35:02 <quicksilver> OTOH if you're just doing therapeutic talking then go ahead. :)
08:35:21 <ycm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29159#a29159
08:35:29 <ycm> That seems to make some bit of sense to me
08:35:31 <ycm> but
08:35:35 <kmc> ycm, don't use "if"
08:35:35 <ycm> seems it doesn't to ghc
08:35:44 <kmc> you should have two pattern matching cases
08:35:46 <kmc> myReverse [] = ...
08:35:49 <kmc> myReverse (x:xs) = ...
08:35:55 <quicksilver> ycm: : doesn't work like that
08:36:09 <kmc> using "if", "null", and "head" together is a sure sign that you should be pattern-matching instead
08:36:13 <quicksilver> ycm: you're trying to use : to append a list - (the recursive call to reverse) to a single elemen t.
08:36:32 <quicksilver> ycm: : works the other way around; single element to list.
08:36:42 <kmc> in fact it might be best to pretend that "head" doesn't exist (because it's a partial function, that can raise an exception) and "if" doesn't exist (because it's usually better to pattern-match)
08:37:05 <quicksilver> kmc is giving you good advice but in my opinion, you will want to understand why your current code doesn't compile
08:37:10 <quicksilver> rather than trying a completely different approach.
08:37:16 <cncl> ycm if you come from a lisp background, ML and Haskell basically replace 'cond' with pattern matching
08:37:25 <kmc> i agree with quicksilver here
08:37:43 <ycm> cncl: I come from a lisp-ish background, but mostly C
08:37:50 <kmc> you can write it both ways (if vs. pattern-matching) and see which you like better
08:38:01 <kmc> but i can already tell you which is generally accepted as better ;)
08:38:16 <ycm> quicksilver: that's fixed fast, I should just pull it the other way
08:38:54 <Saizan> (:) is cons, it's only useful to put an element in front of a list
08:39:21 <Saizan> to put it at the end you need ++
08:39:23 <quicksilver> ycm: perhaps, not sure what you mean by "pull it the other way"
08:39:28 <Saizan> > [1,2] ++ [3]
08:39:30 <lambdabot>   [1,2,3]
08:39:39 <Saizan> > 3 : [1,2]
08:39:40 <lambdabot>   [3,1,2]
08:39:49 <quicksilver> there are ways to write reverse which only use (:) certainly. 
08:39:53 <quicksilver> (not needing ++)
08:40:27 <Saizan> yeah, but i was sticking to "why doesn't this typecheck" question :)
08:41:11 <Saizan> or why "head list : myReverse (tail list)" will make it myReverse similar to the identity function
08:41:26 <quicksilver> yes, I wasn't sure if that's what ycm meant.
08:41:48 <ycm> it doesn't typecheck ô.ô
08:42:42 <Saizan> what doesn't?
08:42:50 <ycm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29159#a29160
08:42:56 <ycm> even this doesn't.
08:43:15 <quicksilver> ycm: as I said, : wants a single element on the left and a list on the right
08:43:23 <quicksilver> "tail list" is not a single element.
08:43:30 <quicksilver> did you perhaps mean "last list"
08:43:34 <quicksilver> > last [1,2,3]
08:43:35 <lambdabot>   3
08:43:47 <ycm> yeah, last. =/
08:44:29 <ycm> what the...
08:44:47 <Saizan> also s/list:[]/list/
08:45:13 <ycm> yeah, I figured that
08:45:35 <ycm> works.
08:45:37 <Saizan> (it's the first time i've seen reverse implemented like that :O)
08:45:58 <ycm> that's how I'd implement it is a lot of other functional languages
08:46:12 <ycm> s/it is a/it in a/
08:46:38 <kmc> hmm i think this is slower
08:46:44 <kmc> because of repeatedly walking to the end to get the last list
08:46:48 <kmc> last element*
08:46:50 <kmc> but i'm not sure
08:47:04 <Saizan> it's O(n^2) instead of O(n)
08:48:04 <Saizan> ycm: last and init have both linear complexity
08:48:07 <ycm> yeah, because usually you'd get the head and prepend the following elements to it, which is pretty much O(n)
08:48:20 <ycm> but here it can't. :3
08:48:28 <ycm> so you get horrendous perf.
08:48:42 <ycm> doesn't matter, I wanted to get acquainted with the list stuff
08:48:50 <ycm> now, to the (x:xs) thing
08:48:53 <Saizan> you can write an O(n) one in haskell too
08:48:56 <ycm> what's that?
08:49:00 <cncl> a pattern match
08:49:09 <cncl> : is the data constructor
08:49:35 <cncl> (which takes two arguments)
08:49:39 <kmc> ycm, (:) is cons, written infix
08:49:41 <kmc> > 2 : 3 : []
08:49:42 <lambdabot>   [2,3]
08:49:57 <kmc> ycm, but since it's a "constructor", rather than an ordinary function, we can also pattern-match against it
08:50:01 <kmc> which is a kind of destructuring bind
08:50:07 <kmc> but also allows for multiple alternatives
08:50:21 <kmc> since a list might be built with (:) or with []
08:50:25 <ycm> ok, so when I pass one list to that, it's gonna take the first element (x) and take all the other x'es (xs) and see that as one head and one tail?
08:50:36 <kmc> (by [] i don't mean "brackets in general" , imean empty list)
08:50:36 <kmc> yeah
08:50:45 <kmc> and you can have another equation «myReverse [] = ...» to handle the empty case
08:51:28 <ycm> [] returns [], in that case.
08:51:40 <ycm> but how should the myReverse (x:xs) case work?
08:52:05 <aristid> @src foldl
08:52:05 <lambdabot> foldl f z []     = z
08:52:05 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:52:16 <ycm> gah?
08:52:31 <kmc> ycm, what's the reverse of (x:xs)
08:53:28 <ycm> given x isn't a list, I can't say xs:x recursively
08:53:47 <copumpkin> it's reverse xs with an x stuck on the end
08:53:59 <ycm> but that's pretty much my vision of a recursive reverse.
08:54:06 <kmc> how about xs ++ [x]
08:54:07 <ycm> hmm
08:54:09 <ycm> yeah
08:54:28 <ycm> but xs has to be passed to myReverse too.
08:54:31 <ycm> so...
08:54:36 <ycm> myReverse [] = []
08:54:54 <ycm> myReverse (x:xs) = myReverse xs ++ x
08:54:59 <copumpkin> almost
08:55:00 <cncl> almost :)
08:55:14 <ycm> myReverse (x:xs) = myReverse xs ++ [x]
08:55:19 <cncl> yay gold star
08:55:29 <Saizan> ?type (++)
08:55:30 <ycm> I have to see what error that mistake would give
08:55:31 <lambdabot> forall m. (Monoid m) => m -> m -> m
08:55:33 <copumpkin> ycm: now that's great and works fine, but is rather inefficient :)
08:55:44 <ycm> copumpkin: wait a sec. :3
08:56:33 <aristid> Saizan: the joy of caleskell :P
08:56:34 <ycm> good, it says a type error, like the one before. :3
08:56:50 <ycm> yay :3
08:56:54 <ycm> copumpkin: what was that?
08:56:55 <cncl> ycm: rule of thumb for ++, if it's left-associate, it'll be slow
08:57:00 <cncl> left-associative
08:57:12 <ycm> okay, so what would you use instead?
08:57:15 <Saizan> *left-associated ?
08:57:25 <copumpkin> omg commie
08:57:28 <cncl> haha
08:57:33 <ycm> hahaha
08:57:35 <aristid> > foldl' (flip (:)) [] [1,2,3,4]
08:57:37 <lambdabot>   [4,3,2,1]
08:58:03 <cncl> ycm: a foldl with (:) so that it builds up a new list
08:58:07 <cncl> like that :)
08:58:08 <ycm> what the hell does that do?
08:58:22 <kmc> :t foldl'
08:58:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:58:24 <Saizan> without using foldl.
08:58:39 <kmc> foldl' walks a list from beginning to end
08:58:44 <kmc> updating an "accumulator" parameter at each step
08:59:01 <kmc> foldl' and foldl are the same except that foldl' is more eager about evaluating the accumulator before it's needed, avoiding some laziness-related space leaks
08:59:07 <kmc> foldr is the more "natural" fold on lists
08:59:15 <kmc> > foldr (+) 0 [a,b,c]
08:59:16 <lambdabot>   a + (b + (c + 0))
08:59:17 <Saizan> reverse xs = go [] where go acc [] = acc; go acc (x:xs) = go (x:acc) xs
08:59:18 <copumpkin> kmc: bigot
08:59:37 <copumpkin> sorry :P
08:59:39 <kmc> ;)
08:59:49 <kmc> «foldr f z» just replaces [] with z and (:) with f
08:59:59 <ycm> so...
09:00:01 <ycm> wait a sec here
09:00:25 <aristid> > let aristidReverse xs = aristidReverseHelper xs []; aristidReverseHelper [] z = z; aristidReverseHelper (x:xs) z = aristidReverseHelper xs (x:z) in aristidReverse [1,2,3,4]
09:00:26 <lambdabot>   [4,3,2,1]
09:00:37 <ycm> foldl kinda makes me think of map
09:00:46 <kmc> you can write map using foldr
09:00:49 <Saizan> more like "reduce"
09:00:49 <kmc> or maybe foldl as well
09:00:53 <cncl> aristid: i think the helper wrapper makes it more complicated in this case :)
09:01:07 <ycm> but instead of applying to a single element, it applies it to pairs?
09:01:09 <copumpkin> saizan also wrote the same thing a minute earlier :P
09:01:19 <copumpkin> (with a small bug)
09:01:29 <aristid> cncl: without it, it would be reverseAppend or so :)
09:01:55 <aristid> > foldl (flip (:)) [1,2,3] [4,5,6]
09:01:57 <lambdabot>   [6,5,4,1,2,3]
09:02:05 <cncl> oh
09:02:07 <Saizan> copumpkin: heh, i often forget that i've needlessly named my arguments
09:02:13 <ycm> o.O
09:02:22 <cncl> i assumed you just wrapped it to eliminate needing to call it with the starting accumulator
09:02:27 <cncl> oops
09:02:51 <ycm> what does fold actually do? I understand it walks a list, but...?
09:03:01 <Saizan> > foldl f z [1,2,3]
09:03:03 <lambdabot>   f (f (f z 1) 2) 3
09:03:04 <kmc> @src foldr
09:03:05 <lambdabot> foldr f z []     = z
09:03:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:03:06 <aristid> http://cale.yi.org/index.php/Fold_Diagrams
09:03:08 <Saizan> does that help?
09:03:16 <kmc> ycm, «foldr f z» just replaces [] with z and (:) with f
09:03:27 <kmc> so e.g. if z = 0 and f = (+)
09:03:29 <kmc> you sum the list
09:03:35 <kmc> > foldr (+) 0 [1,2,3]
09:03:35 <lambdabot>   6
09:03:42 <kmc> > foldr (+) 0 [a,b,c]
09:03:43 <lambdabot>   a + (b + (c + 0))
09:03:53 <duckinator> ooh, so it is sortof like reduce
09:03:59 <duckinator> </lurking>
09:04:08 <kmc> it is what some other languages call reduce
09:04:12 <Saizan> foldl' is probably the most similar to reduce
09:04:42 <ycm> foldr (*) 1 [10,11...20]
09:04:51 <ycm> > foldr (*) 1 [10,11...20]
09:04:52 <lambdabot>   Not in scope: `...'
09:04:57 <ycm> hmm
09:05:06 <aristid> ycm: only two dots
09:05:07 <ycm> oh, ..
09:05:07 <Philonous> > foldr (*) 1 [10,11..20]
09:05:08 <lambdabot>   6704425728000
09:05:13 <ycm> > foldr (*) 1 [10,11..20]
09:05:14 <lambdabot>   6704425728000
09:05:19 <ycm> hmm, nice.
09:07:34 <ycm> > let power x y = foldr (*) 1 (take y (cycle [x])) in power 2 8
09:07:35 <lambdabot>   256
09:07:39 <ycm> YES
09:08:05 <ycm> :3
09:08:12 <zygoloid> foldr (*) 1 == product
09:08:28 <zygoloid> take n (cycle [x]) = replicate n x
09:08:38 <ycm> yeah :3
09:09:01 <ycm> it's just making a list of 8 2's and multiplying in there.
09:09:11 <ycm> > let power x y = foldr (*) 1 (take y (cycle [x])) in power 2 16
09:09:12 <lambdabot>   65536
09:09:16 <Philonous> zygoloid: Will this go away any time soon? 
09:09:20 <ycm> works. :3
09:09:47 <sshc> How do I disable the morphism restriction?
09:09:56 <kmc> ghc -XNoMonomorphismRestriction
09:10:05 <kmc> or {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file
09:10:06 <Philonous> zygoloid: I mean the "lazy" product
09:10:29 <Saizan> Philonous: open a ticket/thread on libraries :)
09:10:30 <sshc> Thanks
09:10:43 <ycm> zygoloid: those two things are alerady defined?
09:10:46 <Saizan> if we can get a fixed Either monad we can get a fixed product, i'd hope :)
09:10:46 <zygoloid> Philonous: not that i'm aware of.
09:10:58 <zygoloid> ycm: yep
09:11:15 <ycm> > let power x y = product replicate y x in power 2 16
09:11:16 <lambdabot>   Couldn't match expected type `[a]'
09:11:16 <lambdabot>         against inferred type `GHC.Types...
09:11:16 <zygoloid> the optimizer already does a good job of strictifying them
09:11:22 <ycm> ...:(
09:11:36 <zygoloid> ycm: you need parens around the replicate y x
09:11:52 <ycm> zygoloid: I figured it had to be something like that
09:12:00 <ycm> > let power x y = product (replicate y x) in power 2 16
09:12:01 <lambdabot>   65536
09:12:12 <ycm> nice
09:12:26 <quicksilver> ycm: (product replicate y x) is passing three parameters to product - replicate, y, and x.
09:12:44 <quicksilver> that's why you needed to add ()
09:12:53 <ycm> quicksilver: I had guessed. :3
09:13:17 <ycm> :t product
09:13:17 <lambdabot> forall a. (Num a) => [a] -> a
09:13:52 <ycm> it makes multiple numbers into an array and then yields a single one?
09:14:07 <kmc> [a] -> a
09:14:10 <ycm> is that even remotely right?
09:14:13 <kmc> takes a list (not array) of 'a'; returns one 'a'
09:14:23 <kmc> «(Num a) => ...» is not an argument
09:14:24 <ycm> it's the (Num a) that I find weird.
09:14:29 <kmc> it's a restriction on which types are allowed for 'a'
09:14:33 <kmc> it says that 'a' must be a numerical type
09:14:37 <kmc> i.e., an instance of the type class named "Num"
09:14:41 <Philonous> ycm: It takes a list of any type that is an instance of the Num class (I.E. can , among other things, be multiplied) and returns a single value of the same type
09:14:44 <roconnor> @instances Num
09:14:46 <lambdabot> Double, Float, Int, Integer
09:14:50 <kmc> :t (*)
09:14:51 <lambdabot> forall a. (Num a) => a -> a -> a
09:14:58 <ycm> basically a type restriction.
09:14:59 <ycm> good. :3
09:15:03 <kmc> yu
09:15:04 <kmc> pp
09:15:38 <kmc> we can do a product of Ints, or of Doubles, but not of functions or lists or bools
09:16:04 <Philonous> That is, until you explain how you would multiply functions or Bools. 
09:16:29 <kmc> and there are some halfway reasonable definitions for such
09:16:32 <duckinator> Philonous: I have a very simple answer to that: magic. ;)
09:16:41 <kmc> but the Haskell standard libraries are fairly conservative with overloading
09:17:02 <kmc> we don't define every possible way that the symbol (*) has even a little meaning
09:17:12 <Philonous> duckinator: unsafeMultiplyBools 
09:17:29 <kmc> we define it for things that act very much like numbers, and leave more esoteric cases (lists = polynomials, functions, etc.) for additional libraries you can import
09:17:39 <kmc> the more overloading you allow, the less type errors you will catch
09:17:57 <Philippa> that, and the more confusing the errors'll be
09:19:43 <hpc> Philonous: you mean (&&)?
09:21:12 <Philonous> hpc: Or (||). But that's not magic
09:21:39 <kmc> multiplication on the finite field of order 2 is (&&)
09:21:46 <hpc> (||) doesn't follow the properties of multiplication; (&&) is roughly the same as (*) `on` fromEnum
09:21:50 <kmc> and addition is xor
09:22:10 <hpc> or what kmc said
09:22:20 * hpc doesn't know all the fancy words :P
09:23:16 <fasta> kmc, don't you mean _a_ finite field, not _the_?
09:23:17 <quicksilver> hpc: (||) is a perfectly good multiplication, you just get a different zero and a different one.
09:23:31 <Philonous> hpc: Which multiplication law does (||) break? It's associative and distributive wrt. (&&)
09:24:00 <quicksilver> fasta: he meant *the* finite field of *size* 2, I imagine
09:24:03 <quicksilver> (not order 2)
09:24:15 <hpc> quicksilver: haha, fair enough
09:24:22 <fasta> quicksilver, order is a different word for size, no?
09:24:25 <quicksilver> no.
09:24:30 <quicksilver> not in this context, at least
09:24:34 <fasta> quicksilver, for groups "order" is defined.
09:24:42 <quicksilver> There is only one (isomorphic) finite field of size 2.
09:24:46 <quicksilver> There are many of order 2.
09:25:25 <Philonous> quicksilver: Order 2 meant 2(i.e. 1+1) =0, didn't it?
09:25:26 <quicksilver> (2^k for all positive k)
09:26:11 * quicksilver is wrong, in fact.
09:26:23 <quicksilver> Order does mean size in this context and I was thinking of somethin else
09:26:25 * quicksilver apologises.
09:29:14 <Wooga> how do i use multiple modules in one file?
09:29:33 <quicksilver> import First.Module
09:29:36 <quicksilver> import Second.Module
09:30:03 <Wooga> i mean, like module Main where <blah blah blah>
09:30:08 <quicksilver> you can't
09:30:13 <quicksilver> in GHC, at least
09:30:22 <Wooga> oh
09:30:22 <quicksilver> you are restricted to one module per file
09:30:26 <quicksilver> I think that's true of all other haskell implementations
09:30:33 <quicksilver> although not required by the standard.
09:30:56 <Wooga> thanks for explanations
09:38:15 <aristid> what happens in a do-block when a pattern match in a let fails? fail?
09:38:31 <zygoloid> Philonous: ||-as-multiplication breaks additive inverses. we need a -False such that False + -False = 0, in other words, x such that False && x = True.
09:38:46 <zygoloid> aristid: bottom, if that value is forced.
09:38:57 <zygoloid> let inside do desugars as a normal let
09:39:27 <zygoloid> if you want 'fail', you can use: pat <- return (exp)
09:39:37 <aristid> k, thanks
09:44:38 <kmc> yeah i probably meant 'size'
09:45:45 <zygoloid> Philonous: no, forget that, that's nonsense. the (+) must be xor, not && :o
09:49:12 <zygoloid> > 1 .|. (0 `xor` 0) == (1 .|. 0) `xor` (1 .|. 0 :: Int)
09:49:14 <lambdabot>   False
09:49:19 <Philonous> zygoloid: Yes, still my fault as I said distributivity wrt. (&&) earlier.
09:49:33 <zygoloid> Philonous: ^^ xor doesn't distribute over ||
09:52:07 <dmwit> ?check \a b c -> a .|. (b `xor` c) == (a `xor` b) .|. (a `xor` c :: Int)
09:52:09 <lambdabot>   "Falsifiable, after 1 tests:\n-2\n1\n-1\n"
09:52:17 <aristid> i wish failing patterns would desugar as mzero instead of fail
09:52:18 <dmwit> ?check \a b c -> a .|. (b `xor` c) == (a `xor` b) .|. (a `xor` c :: Bool)
09:52:18 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
09:52:19 <lambdabot>    arising from a use of `Da...
09:52:24 <zygoloid> @check let (^^) = (/=) in \a b c -> (a && (b ^^ c)) == ((a && b) ^^ (a && c))
09:52:25 <lambdabot>   "OK, passed 500 tests."
09:52:27 <zygoloid> @check let (^^) = (/=) in \a b c -> (a || (b ^^ c)) == ((a || b) ^^ (a || c))
09:52:28 <lambdabot>   "Falsifiable, after 0 tests:\nTrue\nTrue\nTrue\n"
09:52:49 * dmwit nods
09:53:51 <drhodes> @hoogle a -> IO a
09:53:52 <lambdabot> Control.Exception evaluate :: a -> IO a
09:53:52 <lambdabot> Control.OldException evaluate :: a -> IO a
09:53:52 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
09:54:21 <aristid> :t return :: a -> IO a
09:54:22 <lambdabot> forall a. a -> IO a
09:54:39 <drhodes> :t (return 4)
09:54:40 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
09:55:44 <drhodes> :t (return 4)::(IO Double)
09:55:45 <lambdabot> IO Double
10:15:12 <Philonous> @check \ a b c -> (a || (b == c)) == ((a || b) == (a || c))
10:15:14 <lambdabot>   "OK, passed 500 tests."
10:17:00 <Philonous> zygoloid: Of course we have to apply the isomorphism to consistently, so xor becomes (not .: xor)
10:17:22 <Philonous> -to
10:18:48 <kmc> which is (==)
10:18:51 <zygoloid> Philonous: you're using xnor as addition? yeah, that'd work :)
10:19:07 <zygoloid> that's just relabelling True as False and vice versa
10:19:24 <Philonous> zygoloid: That was the idea 
10:19:49 <zygoloid> yeah, that's clearly a field ;)
10:23:41 <kmc> how did Haskell avoid the flaws associated with design-by-committee
10:23:44 <kmc> and which ones did we not avoid?
10:24:11 <dolio> Haskell had a better committee.
10:24:27 <Philonous> kmc: I'd say by disregarding the standard and adding extensions until it became usable 
10:24:56 <kmc> Philonous, was that the tactic taken before H98 as well?
10:25:18 <dolio> Also, 98 arguably has lots of bad compromises.
10:25:27 <wli> Really bad.
10:25:32 <kmc> i can think of a few
10:25:40 * ski . o O ( <http://en.wikipedia.org/wiki/Field_with_one_element> )
10:26:40 <edwardk> kmc: skim the history of haskell paper, they talk a bit about the design by committee process and how they got lucky when wadler put forth type classes and that it was accepted by the entire committee
10:26:58 <kmc> mm
10:27:04 <kmc> the type class design is quite conservative though
10:27:16 <edwardk> kmc: sadly, haskell 98 made a ton of bad committee-like compromises =(
10:27:26 <kmc> monomorphism restriction?
10:27:42 <dankna> I'm not sure conservative design is a bad thing
10:27:56 <dolio> The MR has been around for a while.
10:27:58 <kmc> yeah i don't think it is
10:28:00 <edwardk> MR is acceptable to me. dropping irrefutable patterns was okay, but bundling up fail into monad as a consequence, not letting functor be a superclass of monad, etc.
10:28:20 <kmc> why didn't they make Functor a superclass of Monad?
10:28:38 <edwardk> because that would be an "extra burden on every monad implementor"
10:28:50 <roconnor> an "extra 1 line burden"
10:29:12 <edwardk> roconnor: 2-3 in practice ;)
10:29:20 <roconnor> oh right
10:29:26 <dolio> Not of you have an fmapDefault given Monad.
10:29:26 <roconnor> you have to make a whole new instance
10:29:36 <edwardk> dolio: we do, its called liftM
10:29:52 <roconnor> I thought the one line was just fmap = liftM
10:29:52 <edwardk> dolio: but sadly, you still have to plumb it into place
10:29:55 <dolio> I know. The former might be a more instructive name, though.
10:30:06 <roconnor> but it is really instance Functor Foo where fmap = liftM
10:30:12 <kmc> need first class dictionaries
10:30:26 <kmc> then «instance Functor M = monadIsFunctor»
10:30:34 <wli> The fail/Monad0/etc. stuff was extremely damaging.
10:31:10 <roconnor> kmc: I thought we just needed some fancy defaulting syntax in Class declarations
10:31:28 <roconnor> hmm
10:31:31 <roconnor> still tricky
10:31:56 * BMeph always felt "MonadZero" sounded more like an anime character, or the source of a plague...
10:32:06 <edwardk> roconnor: its not generally possible with the design of haskell as it stands. what happens when i come along and do the same thing with comonad, which gets picked up? now adding instances into scope would change the definition of your program rather than monotonically allowing more things to work
10:32:23 <roconnor> edwardk: ya, I just realized that
10:32:41 <edwardk> roconnor: it is a fairly common issue with most 'class alias' proposal variants
10:33:32 <zygoloid> it's a problem with implicitly generating instances if they don't already exist
10:33:57 <dolio> Stuff being made more monomorphic was a sort of committee compromise, too, I imagine.
10:34:06 <Saizan> "instance Functor m && Monad m where ....; fmap = liftM" ? :)
10:34:26 <Saizan> s/m/your concrete type/g
10:34:32 <zygoloid> instance (Functor m, Monad m, ...) where
10:34:35 <roconnor> Saizan: something like that would work, but it doesn't seem all that much better than what we currently have
10:34:41 <roconnor> and really, what we currently have isn't so bad.
10:34:53 <Saizan> yeah, it's not bad at all
10:34:59 <zygoloid> roconnor: it can get messy if your Monad instance has a lot of context
10:35:09 <roconnor> zygoloid: can it?
10:35:18 <zygoloid> roconnor: well, it's more stuff to type out twice
10:35:28 <roconnor> context as in the list of constraints?
10:35:52 <BMeph> What we need is a way to specify type class isos...
10:36:00 <zygoloid> instance (five lines of constraints) => Monad (FooT ...) where
10:36:11 <zygoloid> and the worst part is, the compiler could deduce the context for you
10:36:20 <roconnor> BMeph: right?  is that any harder than type aliases?
10:36:28 * zygoloid would very much like to be able to add (..) to contexts to mean "and all the other stuff you need to make it compile"
10:36:54 <BMeph> ...as well as injective/surjective relations. Heck, maybe we just need a way to specify type class relations?
10:37:00 <roconnor> it seems like class aliases shoudl be really easy
10:37:17 <roconnor> BMeph: injective/surjective?
10:37:27 * zygoloid would even include type equalities in that, so one could write: "f :: (..) => a -> b; f = id" and the compiler would deduce a context of a ~ b
10:37:52 <Saizan> zygoloid: partial signatures would be very nice in general
10:37:55 <BMeph> roconnor: Oh, and I'm "sure" that it's maybe another order of complexity worse that class aliases, so...yeah. :\
10:38:25 <zygoloid> Saizan: yeah. i quite like this notation for them, is all :)
10:39:08 <zygoloid> the downside is, what does this mean: f :: ((..) => a) -> b ? :)
10:39:25 <edwardk> roconnor: what we have right now isn't so bad as long as you don't build deep inheritance hierarchies. it can be quite hellish when you go to define a real 'rigorous' numerical tower, though. for n levels deep, you need to define all n instances separately.
10:40:05 <BMeph> zygoloid: Is just "a" mentioned in the "..", or what? :)
10:40:07 <ski> (BMeph : `class F a b | a -> b , b -> a' ?)
10:40:09 <edwardk> roconnor: the design of haskell favors a few well chosen powerful abstractions rather than full generality. which is fine, and produces particularly elegant code when those abstractions fit, but there is a real design trade off at work
10:41:20 <zygoloid> BMeph: could be that (..) expands to (a ~ (Int -> Bool)) :)
10:41:24 <edwardk> roconnor: in a more traditional OOP model as you go deeper, you can fill in more of the definitions, so going deeper into the hierarchy can save you work as you get more laws to be able to draw upon. in haskell you just pile on more work for yourself as implementor.
10:43:04 * BMeph dreams of crAzy type-a-rific stuff, like being able to define a rig as a type the "does everything a ring does, but without ("additive") inverses"...
10:43:06 <edwardk> the same trade-off exists in oop, between 'white box' code reuse (isa, more traditional OOP) and 'black box' code reuse (has-a with lots of interfaces), but there they also have mutation muddling Liskov substitution, etc.
10:43:36 <edwardk> BMeph: heh, i tried 'contravariant' type mixins in an early kata draft, but gave up. 
10:43:56 <roconnor> heh, nowadays I find OOP hard to understand
10:44:06 <roconnor> at least typed OOP
10:44:42 <kmc> i like OOP in Haskell
10:45:03 <kmc> it's not perfect
10:45:06 <roconnor> It seems impossible to make deep heirarchies in typed OOP and still meet the co/contra-varient requirements of the subtyping relation
10:45:06 <kmc> record syntax is a bit of a pain
10:45:21 <roconnor> Objects are supposed to encapsulate mutable state
10:45:36 <roconnor> which makes making co/contravarent subclasses next to impossible.
10:45:36 <kmc> in general discourse "typed OOP" might mean C++ and Java, which are quite poor for object-oriented programming
10:45:44 <edwardk> roconnor: sure, but i was just pointing out that the design of haskell is in some ways blinds itself to some of the benefits you get out of a more traditional oop structure. you can only really use black box composition in haskell without silly amounts of oleggery ;)
10:46:05 <roconnor> edwardk: where you talking about OOP a la C++ or Java?
10:46:07 <kmc> hey edwardk, when is the next Boston Haskell?
10:46:14 <roconnor> or as in smalltalk / eiffel?
10:46:24 <edwardk> roconnor: you don't need to encumber objects with mutation, once you split that apart, liskov substitutability becomes easier to maintain =P
10:46:32 <edwardk> kmc: the 23rd
10:46:41 <kmc> ok, one week from today?
10:46:43 <edwardk> kmc: so a week from now
10:46:44 <edwardk> yeah
10:46:45 <kmc> cool :)
10:46:55 <BMeph> I forget where I ran across it, but I emember someone's mad dream of being able to define OO class relationships that way (semi-"superclass", maybe).
10:47:02 <roconnor> edwardk: oh yes, immutable objects are far easier to make into heirarchies.  But I was told that the point of OO was to encapsualte state.
10:47:06 <kmc> i'm giving a talk, apparently.  topic suggestions anyone?
10:47:47 <edwardk> roconnor: nah, that is a common conflation, not necessary to oop. you can use oop purely as a code reuse mechanism for building 'smart dictionaries' for manipulating 'dumb data' if you so choose.
10:47:56 <roconnor> edwardk: if objects don't have mutable state, then they are just values paired up with functions.
10:48:21 <edwardk> roconnor: or you can bundle up in an immutable linked list's head node, the cons, etc. operations that return the new list.
10:48:32 <kmc> roconnor, yeah.  objects are a poor man's closures; closures are a poor man's objects
10:48:34 <edwardk> roconnor: there is still the code reuse benefits of having the class hierarchy
10:48:47 * BMeph prefers closures for encapsulating state... ;)
10:50:17 <roconnor> edwardk: what are the benefits?
10:51:10 <BMeph> What I don't understand about "state-of-the-art" OO programming is how they blather on about encapsulation with objects, and then go hog-wild using reflection to crack open the objects and muck around with the innards. I feel like that's a sign that maybe OO isn't really what they're looking for.
10:51:53 <roconnor> BMeph: I'm pretty sure "state-of-the-art" OO doen't blather about encapsualtion.
10:52:00 <roconnor> e.g. Python has no encapsulation
10:52:12 <roconnor> BMeph: I also think this is a step backwards
10:52:23 <BMeph> I can understand reflection from a practical infrastructure viewpoint, but sometimes I feel as if it's used more because it's possible, than because that's what the problem set needs...
10:52:39 <roconnor> They are going and probaby do end up worse than using gotos
10:52:56 <edwardk> roconnor: as you go deeper into a class hierarchy you can fill in more definitions, that is the 'white box' portion of oop i mentioned above. if given a class Functor<T> and a class Monad<T> : Functor<T> -- you could fill in the definition of map in the Monad, and so code that inherited from it would be able to reuse the definitions. of course then you run into diamond dependencies and virtual inheritance, etc.
10:53:12 <edwardk> roconnor: i hardly consider python state of the art in any way
10:53:30 <edwardk> roconnor: its just the chunk of oop-like glue that is currently in fashion
10:53:30 <roconnor> edwardk: :) I guess I read "State-of-the-art" as modern
10:53:39 <BMeph> roconnor: Hmm, maybe I'm prejudiced; I'm more of a Lua fan than Python, but Lua is explicitly not OO, just "OO-simulatable"...
10:54:03 <roconnor> BMeph: I don't know anything about Lua.  Not that I know much about Python either. :)
10:54:27 <monochrom> mainstream OOP brags about extension: "it's so easy to add this, add that, ..."
10:54:34 <BMeph> roconnor: :)
10:54:41 <edwardk> BMeph: a lot of the time reflection is used in a setting like C# where a language geek would crack out a new language extension. it is sort of their ultimate bodge to work around the limitations of the type system.
10:54:55 <roconnor> edwardk: are you british?
10:55:06 * hackagebot pango 0.11.2 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.11.2 (AndyStewart)
10:55:25 <edwardk> roconnor: nah, that started as 'dodge' and morphed as i wrote it into something that seemed more appropriate ;)
10:55:26 <monochrom> evidence: just observe all newbies to #haskell ask about heterogeneous lists
10:55:58 <roconnor> edwardk: oh ok. :)
10:56:08 <roconnor> @quote O'Connor
10:56:09 <lambdabot> No quotes match.
10:57:15 <Ke> there are no relevant limitations with static strong typing, anything else would be blasphemy!
10:57:19 <aristid> monochrom: in fact i was trying to find out today whether ghc has some extension to support this: [1, "a"] :: [forall a. Show a => a]
10:57:38 <kmc> that's not the right type
10:57:40 <edwardk> roconnor: in any event, most of the OO code i write deals exclusively with immutable objects ;)
10:57:42 <kmc> that would be [exists a. Show a => a]
10:57:52 <kmc> GHC doesn't have that, directly, but you can define a wrapper type
10:58:05 <roconnor> edwardk: in what langauge?
10:58:07 <kmc> data Showable = forall a. (Show a) => Showable a
10:58:16 <kmc> then [Showable 1, Showable "a"] :: [Showable]
10:58:25 <aristid> kmc: ok yeah, but that requires a slightly ugly wrapper for each item
10:58:36 <monochrom> map Showable [1,"a"]  -- tee hee hee!
10:58:42 <roconnor> Ke: there are limitations, but they usually aren't the ones that developers commonly encounter.
10:58:46 <kmc> aristid, right.  first-class existentials are a desired feature, but nobody has them in GHC yet.
10:58:49 <ski> [exists a. Show a *> a]
10:58:50 <kmc> UHC has them, with other restrictions
10:58:54 <kmc> *> ?
10:59:07 <kmc> monochrom, i've often wanted a TH map that works that way
10:59:09 <edwardk> roconnor: i write a lot of C# that way and my toy language kata is built entirely around those precepts ;)
10:59:12 <monochrom> heh
10:59:17 <kmc> aristid, you can also write values of type [forall a. Show a => a] in GHC with -XImpredicativeTypes, but it's not what you said
10:59:20 <Philonous> kmc: Use HList
10:59:23 <ski> kmc : `(*>)' : `(=>)' : `(,)' : `(->)'
10:59:41 <lispy> kmc: that's because it's too hard to have them in the presence for polymorphic let, right?  (too hard in that no one has figure out coherent type checking rules?)
10:59:42 <kmc> ok ski' i see
10:59:49 <kmc> lispy, existentials?
10:59:52 <kmc> i'm not sure
10:59:52 <lispy> kmc: yeah
11:00:15 <lispy> I think it is.  The existential wrapper types mostly work around those issues though.
11:00:24 <Saizan> i think only type inference would be a problem
11:00:37 <lispy> Saizan: ah right, inference not checking
11:00:47 <monochrom> most programmers disbelieve in encapsulation anyway. whenever you tell them (correctly) their doc is incomplete, they go "just see the source code". blatant antithesis to encapsulation.
11:00:48 <ski> kmc : `[exists a. Show a => a]' would be the type of lists of element, which for some hidden/predetermined type `a', if *you* can provide a `Show a' constraint (pretty hard, in this case), they will have type `a'
11:00:50 <edwardk> roconnor: i also put out a lot of purely functional (modulo knot tying) javascript
11:00:51 <kmc> aristid, [forall a. Show a => a] would mean that each individual element has to be capable of acting as any showable type
11:01:15 <zygoloid> ski: [exists a. Show a <= a] ?
11:01:32 <ski> zygoloid : that looks like a converse implication, so i don't like that
11:01:41 <zygoloid> hmm, fair enough.
11:01:56 <zygoloid> would [exists a. (Show a, a)] be so bad?
11:01:57 <mrdk> How can I use data types in a condition like "Foo && Bar"? I want Foo and Bar to be a bool value which I can set somehow.
11:02:13 <lispy> kmc: you can kind of see it when you try to unwrap an existential in a 'where' or 'let' instead of in a place where the type is monomorphic (like a function's pattern matching)
11:02:27 <ski> zygoloid : `(,)' is covariant in both arguments, while `(->)' is contravariant in the first but covariant in the second; similarly i want `(*>)' to be covariant in both parts
11:02:35 <kmc> mrdk, can you be more specific?
11:02:46 <ski> zygoloid : i suppose that would be ok ..
11:02:50 <edwardk> heya ski
11:03:04 <ski> (though it might confuse the parser or something, i don't know)
11:03:05 <zygoloid> it kinda muddles up contexts and types
11:03:09 <ski> hiya edwardk
11:03:32 <mrdk> kmc: basically I want Foo to be True or False. I guess I could also use a normal variable, but I wonder how to do it with data types
11:04:04 <darrint> There are a lot of choices under xml on hackage. What's good choice for generating XML? My target is svg. Alternatively, is there a good library for making 2d graphics that might include blurs?
11:04:04 <ski> mrdk : if `foo' has type `Bool', then the only (real) values it can be are `False' and `True'
11:04:10 <kmc> mrdk, one constructor is never equal to another constructor
11:04:23 <lispy> mrdk: Unfortunately (very unfortunately, IMO), Bool is a type and not a type class in Haskell
11:04:28 <kmc> mrdk, why do you want to do this??
11:04:38 <zygoloid> mrdk: do you want to do this at the type level?
11:04:42 <ski> mrdk : maybe you want to paste the code you have trouble with in particular ?
11:04:51 <Eduard_Munteanu> o/
11:04:55 <aristid> kmc: that would explain the errors i was getting when trying it and enabling every suggested extension :D
11:05:04 <lispy> I think mrdk wants (&&) :: Boolean b => b -> b -> Bool
11:05:10 <kmc> ah
11:05:22 <monochrom> I think no one knows.
11:05:28 <kmc> well, you can hide (Prelude.&&) and define that class
11:05:44 <lispy> kmc:  the real trick is to fix if-then-else statements
11:05:52 <wli> ISTR Mark Jones writing a paper with such.
11:06:09 <monochrom> -XOverloadedBools
11:06:15 <lispy> IMO, all the haskell literals should be type classes
11:06:17 <monochrom> -XOverloadedEverything
11:06:22 <lispy> It works okay for Num
11:06:27 <kmc> but True and False are not "special" literals
11:06:30 <tafryn> How are exceptions handled currently? The example I'm looking at in chapter 24 of RWH causes a 'Ambiguous type variable...' message.
11:06:31 <kmc> they are just constructor names
11:06:38 * zygoloid thinks if should desugar to a call to if', and this should be possible with just -XNoImplicitPrelude ;)
11:06:40 <kmc> should every constructor be subject to overloading?
11:06:43 <ClaudiusMaximus> darrint: is your focus on the XML or on the graphics aspect? personally so far when generating svg i've just used strings (which gets very ugly very quickly), but i've been looking into using wumpus (as that gets me .ps output as well as .svg) or similar (check hackage for more ideas)
11:06:47 <kmc> -XOverloadedMaybes?
11:06:48 <mrdk> I have this type: "data Host = Any | Home | Ultra24 | Laptop". The data types represent different hosts. So what I actually want are conditional expressions like "Laptop || Home". So I guess there must be a way to set boolean values for the data types.
11:07:00 <monochrom> -XOverloadedOverloaded
11:07:10 <kmc> mrdk, (x == Laptop) || (x == Home) ?
11:07:24 <lispy> kmc: Well, for OverloadedBools I think you really jsut need to fix if-then-else, guards, and add a type class Boolean
11:07:36 <kmc> ah, guards.  yes
11:07:44 <mrdk> kmc: that would work, yes. But there's more to type :)
11:07:45 <zygoloid> lispy: i disagree wrt guards. i don't want Boolean to have a toBool :: b -> Bool
11:07:46 <ski> kmc : `otherwise' and `notOtherwise' ? .. ;)
11:07:50 <edwardk> any (x==) [Laptop, Home]
11:08:11 <darrint> ClaudiusMaximus: Focused on the graphics. Ultimately I want a png I can use for sprites in a Cocos2d game. I'll take a look at wumpus. Svg is my fallback though.
11:08:15 <mrdk> edwardk: that looks interessting
11:08:17 * zygoloid wants an instance Monad m => Boolean (m Bool)
11:08:23 <c_wraith> Ugh.  OverloadedBools would be the worst thing ever.
11:08:25 <ski> tafryn : what is the example ?
11:08:33 <ziman> x `elem` [Laptop,Home]
11:08:38 <lispy> c_wraith: it's nice for DSLs
11:08:46 <zygoloid> c_wraith: OverloadedTuples. :)
11:08:48 <tafryn> ski: The one under "Safe resource management..."
11:08:49 <edwardk> @type \x -> any (x ==) [1,4,6]
11:08:50 <lambdabot> forall a. (Num a) => a -> Bool
11:08:58 <c_wraith> lispy, you quickly end up being ruby that way.  don't go that way.
11:09:02 * ski has never read RWH
11:09:11 <ski> @where rwh
11:09:11 <kmc> tafryn, it's probably because 'catch' and friends have types qualified by «(Exception e) => ...» without mentioning 'e' in the return type
11:09:11 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:09:13 <zygoloid> c_wraith: OverloadedLambda?
11:09:18 <tafryn> ski: http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
11:09:25 <mrdk> edwardk: and what if I have expressions like "Home && not Laptop"?
11:09:46 <tafryn> ski: It's about a quarter of the way down.
11:09:48 <kmc> mrdk, why don't you define functions «home = (== Home)» etc
11:09:50 <ClaudiusMaximus> darrint: hm, maybe wumpus doesn't support blurring if it supports .ps output too...
11:09:54 <edwardk> zygoloid: bad idea. recall the way instance head resolution works, then all instances of Boolean would have to have that form.
11:10:12 <kmc> then define «(f &&& g) x = f x && g x»
11:10:24 * ClaudiusMaximus bbiab
11:10:30 <lispy> c_wraith: I don't see why it has to be any different than Num
11:10:31 <mrdk> kmc: right, that would work too. But I would have to create a function for each data type
11:10:31 <tafryn> kmc: That sounds about right. What should I do to fix it?
11:10:33 <kmc> (that's «(&&&) = liftM2 (&&)» if you import Control.Monad.Instances)
11:10:46 <lispy> c_wraith: or does Num make Haskell (unpleasantly) like Ruby?
11:10:46 <kmc> tafryn, add a type annotation within the expression to fix e
11:10:51 <kmc> possibly to the type SomeException
11:11:28 <zygoloid> edwardk: you mean, it'd overlap with all other Boolean (m Bool) instances? yeah, that's true. be nice if i could define it for /my/ monads though :)
11:11:36 <c_wraith> lispy: it's that it encourages people to add truth/falsehood to their data types, in ways that make some code easier, rather than make sense.
11:11:47 <Apocalisp_> Can I get lambdabot to join my channel?
11:11:53 <edwardk> (&&) <$> (== Home) <*> (/= Laptop)
11:11:54 * zygoloid ponders whether you could use proc notation with monads, with -XNoImplicitPrelude
11:11:56 <c_wraith> lispy: that's what ruby does that's painful.
11:12:18 <zygoloid> (==Home) <^(&&)^> (/=Laptop)
11:12:51 <lispy> zygoloid: proc notation?
11:12:57 <c_wraith> lispy: and it's different than Num, because...  How often are you tempted to make your type Num when it doesn't make sense, just to make code easier?  Compare that to how often you'd be tempted to make your type a Boolean
11:13:11 <ski> @type curry ((uncurry (&&) .) . uncurry (&&&))
11:13:12 <lambdabot> forall (a :: * -> * -> *) b. (Functor (a b), Arrow a) => a b Bool -> a b Bool -> a b Bool
11:13:17 <mrdk> hmm this looks all quite good, but I was rather looking for extremely simple expressions
11:13:26 <zygoloid> lispy: the Arrow notation
11:13:59 <lispy> c_wraith: I'm not sure I follow 'makes sense".  I've made Num instances for lists (polynomials) and for Excel formula types and it works great.  How would you classify those?
11:14:26 <lispy> c_wraith: I think, as long as you follow the requirements of the type class (like the functor and monad laws), then it's fine.
11:14:31 <tafryn> kmc: So something like () `catch` \(e::Exception) -> putStrLn "Exception" >> throw e
11:14:38 <kmc> Exception isn't a typ
11:14:43 <kmc> e :: SomeException
11:14:48 <tafryn> Ah
11:15:04 <kmc> needs -XPatternSignatures
11:15:10 <c_wraith> lispy: Have you used ruby?  I mean, enough to really understand where they went wrong?
11:15:18 <kmc> alternately () `catch` \e -> putStrLn "Exception" >> throw (e :: SomeException)
11:15:20 <kmc> no extension needed there
11:16:11 <lispy> c_wraith: I've looked at ruby for a total of about 20 minutes.  I think their community encourages bad behavior (sexism) and I don't want to support them.  So, I don't know much about the language, and I don't want to learn it.
11:16:54 <ski> kmc : rather `ScopedTypeVariables', now, i think
11:17:54 <vanadium> Sexism?
11:17:58 <c_wraith> lispy: Their software design culture is a good lesson in how not to design anything.  It's kind of worth studying as a cautionary tale, especially regarding the dangers of ad-hoc extension of types, by anyone, anywhere.  Abuse of typeclasses in haskell can get close to that sort of danger, so I think people should be cautious with typeclasses.
11:19:01 <wli> Um, Ruby's dynamically typed.
11:19:01 <lispy> vanadium: yes, there was a ruby conference where the couchDB presentation was rather offensive and they community seemed to think that was "cool"
11:19:43 <lispy> vanadium: had the community discouraged such behavior or been apologetic, I might have a different view of them.
11:19:46 <c_wraith> wli: I don't mean dynamic typing is the problem.  I mean the culture of "that type doesn't do what I want, I'll just write some code to change what it does"
11:20:06 <lispy> vanadium: but this is getting really off-topic so I don't want to continue it here.  Maybe in #haskell-blah
11:20:10 <c_wraith> It's open types that are the problem, not dynamic types. :)
11:20:26 <edwardk> lispy: oddly enough most of the ruby devs i know are women ;)
11:20:28 <c_wraith> And I agree with lispy, about relevance to this channel
11:20:45 <edwardk> but yeah offtopic
11:23:14 * hackagebot console-program 0.2.0.1 - Interprets the command line and a config file as commands and options  http://hackage.haskell.org/package/console-program-0.2.0.1 (AriePeterson)
11:27:11 <FunctorSalad> exit ((`mod` 256) -> 0) = exitWith ExitSucess; exit n = exitWith (ExitFailure n)? it seems to be overdoing the types ;)
11:28:12 <lispy> Do you guys know if tolkad is new here or if he/she has used other nicks here?
11:29:45 <dolio> I don't think the join/part messages show a host, so it's hard to say.
11:30:13 <dolio> The nickname has been consistent for a couple weeks now, though.
11:33:00 <wli> Um, Ruby's dynamically typed.
11:33:22 <ski> monochrom : btw, in your continuations page, shouldn't you say that the alternative signature for `callCC' is rank-*3*, rather than rank-2 ?
11:33:38 <dolio> @type callCC
11:33:40 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
11:33:49 <dolio> He should.
11:38:41 <lispy> what is the alternative signature?
11:38:54 <dolio> ((forall b. a -> m b) -> m a) -> m a
11:39:04 <lispy> ah
11:39:21 * lispy would have to check the definition of rank to be sure
11:40:03 <dolio> (forall x. ...) is rank-1
11:40:36 <dolio> rank(m -> n) = max(rank(m) + 1, rank(n))
11:41:02 <dolio> Actually, that's too naive.
11:41:05 <edwardk> an example of the rank-3 version in use: http://www.mail-archive.com/haskell-cafe@haskell.org/msg49975.html
11:41:07 <dolio> But you get the idea.
11:41:48 <dolio> rank(forall x. T) = max(1, rank(T)), probably.
11:42:26 <edwardk> dolio: that looks about right
11:43:54 <ski> (tbc : <http://www.vex.net/~trebla/haskell/cont-monad.xhtml>)
11:51:09 <groberts> Is there any way my ip could be banned from the hackage website?
11:51:25 <dolio> You mean, you can't even contact it?
11:51:51 <groberts> ping fails, and I can't reach the website.
11:52:43 <dolio> Seems unlikely that you'd be personally banned like that.
11:53:37 <lispy> groberts: turning off ping is pretty common these days
11:53:49 <lispy> groberts: the web not responding doesn't sound good though
11:54:00 <groberts> Its definately not down, and my friend who lives close to me on the same isp can connect.
11:54:21 <dons> groberts: hmm. no one is banned
11:54:30 <dolio> Proxy weirdness?
11:54:34 <dons> dns weirdness?
11:55:16 <Saizan> some-router-somewhere-weirdness ?
11:55:38 <danderson> groberts: traceroute it?
11:55:55 <danderson> most likely possibility is something along the way is blackholing the destination network
11:55:58 <dolio> I am also unable to ping hackage, so that's not part of your problem, at least.
11:58:09 <groberts> vlan5.cis197cor04.bea1.easy.easystreet.com is the last place it goes to from traceroute
11:58:27 * hackagebot pathtype 0.5.2 - Type-safe replacement for System.FilePath etc  http://hackage.haskell.org/package/pathtype-0.5.2 (BenMoseley)
11:58:44 <c_wraith> hmm.
11:58:58 <c_wraith> segfault in ghc's garbage collector. >_>
12:01:20 <c_wraith> http://pastebin.com/cKZ8r1b9
12:01:29 <c_wraith> I happened to be running my app from gdb
12:01:48 <c_wraith> Am I doing something wrong, or does that look like something internal to GHC?
12:02:23 <dolio> Wasn't there something on haskell-cafe about a bug in the garbage collector lately?
12:02:47 <c_wraith> well, there was the int overflow issue
12:02:51 <c_wraith> But that's not what this is.
12:02:58 <c_wraith> That required more memory than I've got :)
12:03:06 <ClaudiusMaximus> there was something about finalizers vs threads vs handles
12:03:14 <c_wraith> Oh, the blackhole thing?
12:03:15 <dolio> Ah.
12:03:28 <ClaudiusMaximus> yeah, but i dunno if that's relevant here
12:03:55 <c_wraith> finalizers could theoretically be involved in this, but I don't think this is that problem.
12:04:32 <c_wraith> because this isn't finalizer code that's running
12:04:44 <c_wraith> By the stack trace, it's inside GHC's garbage collector
12:05:06 <c_wraith> I'd hope that finalizers aren't being run during the scavenging phase
12:05:38 <c_wraith> Sadly, I don't have a test case for this.
12:05:39 <ClaudiusMaximus> hm, could be that something else corrupted memory which might make it do something unexpected, like any C code...
12:05:48 <c_wraith> yeah, that's always possible.
12:06:06 <c_wraith> I don't even know *where* I could start to get a test case for this.
12:06:08 <ClaudiusMaximus> if you still have gdb open you could inspect the stack contents perhaps
12:06:13 <c_wraith> I do
12:06:19 <c_wraith> But I don't know much about gdb
12:06:23 <ClaudiusMaximus> :t System.Memory.performGC
12:06:25 <lambdabot> Couldn't find qualified module.
12:06:50 <ClaudiusMaximus> nor do i - i usually try "info locals" first
12:07:18 <ClaudiusMaximus> and then i discover that it's not compiled with enough debugging info, and give up :)
12:07:20 <c_wraith> No symbol table info available
12:07:47 <ClaudiusMaximus> you can print the contents of arbitrary memory addresses i think
12:08:10 <drhodes> is there a shortcut in cabal to enable profiling across all libraries?  from what I've read it's only possible to do this by manually rebuilding each package with  --enable-library-profiling  
12:08:35 <ClaudiusMaximus> but knowing which addresses is the tricky part - maybe there's a way to save the 'core' (as in: core dumped)
12:08:59 <gwern> drhodes: set it in your cabal config?
12:09:13 <ClaudiusMaximus> drhodes: you can enable library profiling in your .cabal/config but you'll need to rebuild each already-installed package
12:09:30 <drhodes> ok ClaudiusMaximus gwern, thanks.
12:10:08 <ClaudiusMaximus> the default makes sense for most users, but the first thing i do after bootstrapping cabal is to set the config to build profiling libs
12:20:19 <monochrom> ski: fixed 2nd-rank to 3rd-rank
12:24:07 * ski still sees "2nd"
12:30:45 <FunctorSalad> are you supposed to #include the .import files?
12:31:02 <FunctorSalad> I know you could just copypaste, but it seems kindof convenient
12:31:33 <FunctorSalad> but I never saw anyone do it :)
12:32:48 <monochrom> ski: oh haha! I fixed it on my laptop copy, haven't uploaded!
12:33:10 <monochrom> now uploaded
12:34:24 <ski> monochrom : ty :)
12:53:29 <kmc> neeeeed ideas for a talk on Haskell
12:53:55 <hpc> where are you giving the talk?
12:54:01 <kmc> boston haskell
12:54:57 <roland`> xk
12:57:13 <cocon> hi
12:58:42 <cocon> given a GADT T : * -> * that is indexed by finitely many types, is there a way to have a Map of type 'forall x. T x -> a' ?
13:00:41 <cocon> hello ?
13:00:49 <Heffalump> cocon: I don't quite follow what the Map would do
13:01:20 <Heffalump> oh, just have T values as keys, but existentially quantified
13:01:28 <cocon> sorry, I actually meant 'forall x. Map (T x) a'
13:01:41 <Heffalump> hmm, now I don't see again.
13:01:47 <Heffalump> what would you store in the map?
13:01:47 <cocon> it would be polymorphic, so for every x a new map is needed
13:02:21 <Heffalump> if T has an Ord instance, then Data.Map.empty would create something of the right type, wouldn't it?
13:02:41 <Heffalump> I suspect you mean something a bit different to what you're saying.
13:02:48 <cocon> yes, but I want to get rid of the "forall x."
13:02:52 <Heffalump> or at least to what I'm (mis)understanding
13:03:12 <cocon> I probably do mean something different :)
13:03:31 <cocon> problems arise when sticking this map into the State monad
13:03:45 <cocon> State (forall x. Map (T x) a) is an impredicative type (deprecated...)
13:03:56 <cocon> and it doesn't work as expected
13:04:12 <cocon> so I was wondering if there's a different trick to achieve this
13:04:45 <Heffalump> I see, so you want a single value.
13:05:08 <Heffalump> and you want the compiler to handle the finitely many types for you, rather than you explicitly building a big tuple/record.
13:05:14 <Heffalump> (which you could do, of course)
13:05:46 <cocon> indeed this could be done by enumerating the x's, but maybe there's a more general solution
13:06:01 <Heffalump> well, how about Map (exists x . T x) a ?
13:06:08 <monochrom> kmc: You could talk about continuations. You could make it a 3-part talk: "continuations", "continuations continued", "continuations delimited".
13:06:10 <Heffalump> (the exists x . T x needs to be wrapped in a fresh datatype)
13:06:31 <cocon> Heffalump: what would the lookup look like then?
13:06:53 <cocon> Heffalump: (don't we lose type information once stuff is wrapped?)
13:07:03 <ski> @type Data.Map.empty  -- no `Ord' ..
13:07:04 <lambdabot> forall k a. M.Map k a
13:07:21 <Heffalump> you can make an Ord instance for the wrapped type, because you can enumerate the constructors of T to get refinement.
13:07:30 <Heffalump> However, this might feel like going back to the manual solution.
13:08:12 <cocon> hmmm, this might be a useful hint...
13:08:33 <cocon> I wonder what happens when x cannot be enumerated
13:09:12 <Heffalump> actually, that assumes that each constructor of T gives a concrete type for x, which you didn't say
13:09:30 <Heffalump> but is sort of implied by the "indexed by finitely many types"
13:10:15 <cocon> Heffalump: what's the difference?
13:10:42 <Heffalump> data T where T1 :: T Int ; T2 :: T Char
13:10:43 <Heffalump> that's fine
13:10:54 <Heffalump> data T x where T1 :: T x -- not fine
13:11:04 <Heffalump> (I meant 'data T x where' in the first case too)
13:11:23 <cocon> I agree for the first case
13:11:33 <ski> cocon : so, you have something like `data T :: * -> * where Ike :: T Bool; Bike :: T a -> T b -> T (a,b); Trike :: String -> Int -> T Int', and you want a single map that can be indexed by keys like `Ike',`Trike "42" 17',`Bike Ike (Trike "42" 17)' ?
13:11:43 <cocon> Heffalump: but is there a solution for the second case? (assuming that x can be ordered somehow?)
13:12:23 <cocon> ski: not necessarily a single map, one Map per index type would be fine as well -- I'm just to lazy to create them all by hand
13:12:28 <ski> cocon : and in each case you want the corresponding values of the keys in the map to have a *single* type ? .. or should the values associated with the key be able to have a type the depends on the `x' in `T x' ?
13:12:35 <Heffalump> being able to order x wouldn't help in the second case
13:12:38 <carter> hey all: is there any known hsCocoa package, and if not, what are the known obstacles to having a nativie gui lib for os x?
13:12:41 <Heffalump> I'm not sure if there's a solution.
13:12:51 <cocon> ski: indeed version 2.0 should have the values indexed as well
13:13:18 <ski> (cocon : well, if you want one map per index type, if there's infinitely many index types, that could be a bit more complicated .. but is probably doable)
13:13:20 <cocon> actually, yes (version 1.0)
13:13:35 <cocon> ski: I'd be very interested to know how
13:14:03 <cocon> the existential type trick seems to work only if the values don't need an index
13:16:51 <ski> the "map with value types related to key types" is an interesting problem .. i think probably `Map' can't do it (barring cheating)
13:17:04 <ski> it seems related to what `ST' gives
13:17:21 * ski vaguely recalls some paper which treated this in ML
13:17:55 <Heffalump> cocon: it also works if you don't mind using a list of pairs for the map (cos then you can quantify over the pair)
13:20:51 <kmc> monochrom, good suggestion.  that'd give me incentive to actually learn delimited continuations :)
13:20:53 <ski> (.. or rather, `STRef', i.e.)
13:21:19 <EvanR-work> ill delimit *your* continuations!
13:21:28 * ski . o O ( <http://community.schemewiki.org/?composable-continuations-tutorial> )
13:22:18 <cocon> ski: it doesn't have to be "map with value types related to key types" -- they could also be indexed by a common type, as in Map (k ix) (v ix) -- not sure if that helps...
13:22:49 <ski> hm .. i suppose that's probably how one would express it with a general `Map'-like library
13:26:32 <chrisdone> > fix ("developers "++)
13:26:33 <lambdabot>   "developers developers developers developers developers developers develope...
13:27:28 <ski>   Map1 k v = [exists x. (k x,v x)]
13:27:45 <ski>   Map1 T v = [exists x. (T x,v x)]
13:27:46 <dolio> Now that Haskell exists, Steve Balmer is obsolete.
13:28:40 <ski>            = [(T Bool,v Bool) + (exists x0 x1. (T (x0,x1),v (x0,x1))) + (T Int,v Int)]
13:29:25 <ski>            = (T Bool,v Bool) + [exists x0 x1. (T (x0,x1),v (x0,x1))] + (T Int,v Int)
13:29:31 <ski> er
13:29:43 <ski>            = (T Bool,v Bool) * [exists x0 x1. (T (x0,x1),v (x0,x1))] * (T Int,v Int)
13:29:55 <ski>            = v Bool * [exists x0 x1. (T (x0,x1),v (x0,x1))] * (String,Int,v Int)
13:30:05 <ski>            = v Bool * [exists x0 x1. (T x0,T x1,v (x0,x1))] * (String,Int,v Int)
13:30:21 <cocon> what are '+' and '*' ?
13:30:22 <EvanR-work> cycle [concat $ replicate 4 "developers "]
13:30:25 <EvanR-work> > cycle [concat $ replicate 4 "developers "]
13:30:26 <lambdabot>   ["developers developers developers developers ","developers developers deve...
13:30:32 <ski>            = v Bool * [exists x0. (T x0,exists x1. (T x1,v (x0,x1)))] * (String,Int,v Int)
13:30:54 <ski> cocon : i'm just thinking aloud (and a bit sketchy), `a + b' is `Either a b' and `a * b' is `(a,b)'
13:31:09 <EvanR-work> > cycle [concat . intercalate " " . replicate 4 $ "developers"]
13:31:10 <lambdabot>   Couldn't match expected type `[a]'
13:31:10 <lambdabot>         against inferred type `GHC.Types...
13:31:18 <EvanR-work> > cycle [concat . intersperse " " . replicate 4 $ "developers"]
13:31:19 <lambdabot>   ["developers developers developers developers","developers developers devel...
13:31:29 <Silvah> > concat $ repeat "developers"
13:31:30 <lambdabot>   "developersdevelopersdevelopersdevelopersdevelopersdevelopersdevelopersdeve...
13:31:45 <EvanR-work> he says it 4 times and catches his breath
13:31:50 <EvanR-work> and repeats
13:32:07 <ski>            = v Bool * Map1 (T,\x0 -> Map1 (T,\x1 -> v (x0,x1))) * (String,Int,v Int)
13:32:28 <ski> something like that, i suppose
13:32:29 <Twey> concat . intersperse = intercalate
13:33:00 <Twey> intercalate " " = unwords
13:33:21 <chrisdone> I like the audiosurf video of (take 4 $ repeat "developers")
13:33:24 * EvanR-work changes his code to compensate
13:33:25 <Twey> > cycle [unwords $ replicate 4 "developers"]
13:33:26 <lambdabot>   ["developers developers developers developers","developers developers devel...
13:33:49 <Twey> cycle [foo] = repeat foo
13:33:49 <Jafet> @pl \developers -> cycle [unwords $ replicate 4 developers]
13:33:50 <lambdabot> cycle . return . unwords . replicate 4
13:34:01 <Twey> > repeat . unwords $ replicate 4 "developers"
13:34:03 <lambdabot>   ["developers developers developers developers","developers developers devel...
13:34:07 <ski>   data Map1T v = MkMap1T {ikeMap :: v Bool , bikeMap :: Map1T (\x0 -> Map1T (\x1 -> v (x0,x1))) , trikeMap :: Map (String,Int) (v Int)}
13:34:14 <Twey> repeat . unwords . replicate 4
13:35:04 <EvanR-work> :t toUpper
13:35:05 <lambdabot> Char -> Char
13:35:07 <EvanR-work> ;)
13:35:08 <ski> cocon : i think for my `data T :: * -> * where Ike :: T Bool; Bike :: T a -> T b -> T (a,b); Trike :: String -> Int -> T Int' example, ^ is how `Map1 T v' could be defined as "one map per index type"
13:35:30 <ski> (assuming we had no `Map1' to use instead, i.e.)
13:35:34 <EvanR-work> repeat . unwords . replicate 4 . map toUpper $ "developers"
13:35:38 <EvanR-work> > repeat . unwords . replicate 4 . map toUpper $ "developers"
13:35:39 <lambdabot>   ["DEVELOPERS DEVELOPERS DEVELOPERS DEVELOPERS","DEVELOPERS DEVELOPERS DEVEL...
13:35:42 <cocon> the above definition of Map1T is recursive ?!
13:35:53 <ski> the `\x0 -> ...' in the types are not actual haskell, but can be encoded pretty easily (though a bit ugly)
13:36:09 <Jafet> EvanR: http://codepad.org/XapQaLzH
13:36:12 <ski> cocon : of course :), the corresponding `T' type was recursive, after all :)
13:36:14 <Silvah> He yells?
13:36:40 <Jafet> He bellows and stamps his feet.
13:37:14 <chrisdone> > concat $ zipWith (++) (repeat $ unwords $ replicate 4 "developers") (repeat ", ")
13:37:15 <lambdabot>   "developers developers developers developers, developers developers develop...
13:37:17 <cocon> ski: what would the complexity of a lookup be?
13:37:54 <cocon> that indeed seems to solve the problem, although I was hoping for a more generic solution
13:37:59 <EvanR-work> Jafet: ._.
13:38:07 <cocon> (one that doesn't require a T-specific Map type)
13:38:23 <Veinor> :t intercalate
13:38:24 <lambdabot> forall a. [a] -> [[a]] -> [a]
13:38:39 <Veinor> > intercalate ", " (repeat . unwords . replicate 4 $ "developers")
13:38:40 <lambdabot>   "developers developers developers developers, developers developers develop...
13:38:40 <FunctorSalad> > throwIO "chair"
13:38:42 <lambdabot>   Not in scope: `throwIO'
13:38:49 <Veinor> FunctorSalad: haha
13:38:50 <FunctorSalad> oldie...
13:39:11 <Twey> > intercalate ", " . repeat . unwords $ replicate 4 "developers"
13:39:13 <lambdabot>   "developers developers developers developers, developers developers develop...
13:39:19 <EvanR-work> it never gets old!
13:39:22 <EvanR-work> never!
13:39:35 <chrisdone> indeed
13:39:47 <chrisdone> unsafeShoutTheFourWords
13:39:59 <harlekin> Regarding reactive, why does whenE (pure False) (atTimes [1..]) consume so much memory?
13:40:02 <chrisdone> unsafeDevelopersDevelopersDevelopersDevelopers
13:40:09 <Twey> > throwTo head chair
13:40:11 <lambdabot>   Not in scope: `throwTo'Not in scope: `chair'
13:40:20 <Silvah> LOL!
13:42:00 <ski> cocon : yes, that's not a generic solution. a generic solution would be implementing a `Map1' thing (maybe there's some other possibility, as well, not sure)
13:45:45 <ski> cocon : `lookupMap1T :: Map1T v -> (T x -> v x); lookupMap1T m Ike = ikeMap m; lookupMap1T m (Bike k0 k1) = lookupMap1T (lookupMap1T (bikeMap m) k1) k0; lookupMap1T m (Trike s i) = lookup (s,i) (trikeMap m)' -- modulo the type-lambdas and `Maybe' in `Data.Map.lookup'
13:46:10 <cocon> nice
13:46:13 <ski> so it traverses the whole key, basically doing a trie-thing
13:46:16 <Raghs> what does $ mean in concat.map f $ xs
13:46:30 <ski> Raghs : application
13:46:46 <ski> `concat.map f $ xs' means `(concat . (map f)) xs'
13:46:51 <Twey> Raghs: (concat . map f) xs
13:46:56 <ski> which is the same as `concat (map f xs)'
13:46:58 <Raghs> k. that helps 
13:47:03 <ski> @src ($)
13:47:04 <Twey> Which is the same as concatMap f xs
13:47:06 <lambdabot> f $ x = f x
13:47:07 <Twey> :þ
13:47:15 <ski> *nod*
13:47:33 <ski> Raghs : .. so, you could also write `f =<< xs' :D
13:47:40 <Twey> Unless ‘concat’ is a module.  Can't tell with that nasty whitespace usage, I guess.
13:47:49 <Twey> Are lower-case modules allowed?
13:47:54 <Raghs> i am still at the >>= stage..
13:48:00 * ski thought modules have to start with upper case
13:48:16 <Twey> Raghs: xs >>= f = f =<< xs
13:48:18 <edwardk> Twey: nope
13:48:24 <Twey> Oh, okay then.
13:48:45 <ski> (maybe it's allowed for the main modulo, as an exception, with some GHC-flag ?)
13:49:04 <kmc> 'main' usually lives in module Main
13:49:14 <kmc> you can set a different module but i think the usual name restrictions still apply
13:49:39 <ski> cocon : anyway, this is an interesting problem, and i'd like to hear more about what you're trying to do .. but i have to leave now
13:51:44 <cocon> ski: same here, good night!
13:51:59 <cocon> (to be continued...)
14:03:02 <roconnor> ... I guess ocaml error messages aren't confusing because they don't say anything.
14:03:18 <dolio> Sounds like a good system.
14:03:51 <aRcatan> sounds like a trivial solution
14:04:24 <aRcatan> like: sync these two directories -> rm -r dir1/* dir2/*
14:04:27 <aRcatan> aaand they're in sync
14:04:38 <dolio> It must be way better than Haskell's fatally flawed type system. :)
14:04:58 <dolio> Which forces its programmers to write top-level type signatures.
14:05:31 <EvanR-work> yeah thats totally bogus
14:05:52 <EvanR-work> either we should know better what types we want, or the compiler, one of the two
14:06:19 <aRcatan> hey, now, hasn't jdh already left OCaml?
14:06:31 <roconnor> aRcatan: that is like university sorting proofs
14:06:43 <roconnor> aRcatan: write a sort function that returns a sorted list
14:06:47 <roconnor> student: const []
14:07:10 <aRcatan> \o/ i love trivial solutions.
14:07:12 <roconnor> actually, student's are not that cleaver
14:07:45 <chrisdone> students
14:07:48 <EvanR-work> neither are students
14:07:55 <roconnor> chrisdone: yes
14:08:15 * chrisdone missed the cleaver
14:08:22 * chrisdone retracts his correction
14:08:23 <roconnor> clever
14:08:57 <lispy> When you play with quips, you get cut by the clever cleaver
14:09:22 <EvanR-work> lispy: its just as you said, the maintainer sees a big problem and theres no trivial solution ;)
14:09:25 <EvanR-work> but hes on it
14:10:31 <endojelly> anyone using Snap?
14:11:03 * chrisdone finds gag reels are funnier than the comedies they are from
14:11:09 <lispy> EvanR-work: ah, interesting.
14:11:47 <lispy> EvanR-work: can I have a copy of your bug report?  It would be nice to try the same example on Takusen and make sure it works around it
14:12:11 <EvanR-work> if you pm me your email i can forward you the convo
14:12:36 <EvanR-work> it has test cases
14:12:48 <aRcatan> endojelly: Snap has its own irc channel #snapframework
14:13:15 <endojelly> aRcatan, thanks
14:16:13 <endojelly> so... what do you currently use for DB access? HSQL or HDBC?
14:16:32 <Heffalump> now that HDBC has grown a native MySQL connector, I don't think there's any reason to use HSQL
14:16:52 <endojelly> HDBC it is, then. thanks.
14:17:16 <EvanR-work> snap uses traditional relational databases?
14:17:41 <jmcarthur> snap uses whatever you use with it
14:18:15 <EvanR-work> i figured it was more frameworky
14:18:23 <jmcarthur> you could use happstack-state with snap if you wanted
14:18:37 <jmcarthur> yeah, snap is more of a library, like all the other "web frameworks"
14:18:46 <jmcarthur> although i think it eventually will be more of a framework
14:20:10 <chrisdone> snap's more like hyena
14:20:42 <chrisdone> bare bones MORE SCPHEED web server with little support for much else
14:21:46 <EvanR-work> i know snap is awesome based only on the website's crisp design
14:23:01 <chrisdone> I believe the end aim is to have support for db and things like that, in a modular library non-frameworky way
14:23:23 <chrisdone> like the html library it has, it's not required and it's independent
14:25:38 <chrisdone> can't remember who recommended google closure to me yesterday but thanks
14:26:17 <aristid> chrisdone: it's helping? (it wasn't me, i'm just curious)
14:26:18 <Heffalump> is that part of an implementation of a distributed functional language?
14:26:39 <Heffalump> (/me reads about what it actually is)
14:30:33 <verma> hmm .. why doesn't this work? http://paste.plurk.com/show/294736 .. couldn't match expected type 'Char' against inferred type '[Char]'
14:30:46 <verma> in the first argument of (==) namely ".c"
14:32:25 <dolio> @type takeExtension
14:32:27 <lambdabot> Not in scope: `takeExtension'
14:33:13 <dolio> @type System.FilePath.takeExtension
14:33:14 <lambdabot> FilePath -> String
14:33:24 <p_l> isCFile = (==) ".c" . takeExtension -- Tried that?
14:33:36 <kmc> why are you using (>>=)? you want to get the list-monad behavior?
14:33:36 <p_l> (unfinished yet)
14:33:45 <chrisdone> aristid: yeah. apart from spotting common javascript mistakes, it's replaced my existing js module system and most importantly provides rudimentary type checking based on type annotations
14:33:52 <kmc> that code is equivalent to:  concatMap ((==) ".c") $ takeExtension f
14:33:58 <verma> kmc: I am trying to understand the >>= operator and trying it on a simple example
14:34:03 <kmc> which doesn't work because takeExtension returns a string, and mapping over a string feeds individual chars
14:34:11 <kmc> verma, why did you choose this example?
14:34:55 <verma> kmc: because I read that >>= feeds output from one statement to the next .. so since takeExtension returns a String .. I was trying to use it on a function which would accept a string...
14:35:15 <aristid> chrisdone: it has an integrated module system?
14:35:22 <kmc> verma, what you read about (>>=) is incomplete
14:35:31 <kmc> it's used for a specific type of sequencing
14:35:37 <kmc> it's not the general "feed this function into that function" operator
14:35:45 <verma> kmc: hmmm
14:35:45 <kmc> that would be (.), or in the left-to-right order (>>>)
14:36:09 <chrisdone> aristid: again, it's very rudimentary, but it does dependency resolving for you and it's just nice to have a standard module system instead of NIH ad-hoc ones
14:36:09 <kmc> in the case of lists, (>>=) implements a form of nondeterminism / all-paths search
14:36:28 <verma> kmc: ok, I think that is too much information :P
14:36:29 <kmc> > [1,2,3] >>= (\x -> [x*10, x*100)
14:36:29 <lambdabot>   <no location info>: parse error on input `)'
14:36:33 <kmc> > [1,2,3] >>= (\x -> [x*10, x*100])
14:36:34 <lambdabot>   [10,100,20,200,30,300]
14:36:48 <verma> kmc .. ok
14:36:58 <kmc> verma, ^^^^ note how the function on the rhs of (>>=) is called three times, once with each left argument, and each time produces a list of two elems, which are subsequently glued together
14:37:03 <kmc> so it's more complicated than function composition
14:37:09 <kmc> (>>=) does different things for different types
14:37:18 <kmc> lists, IO, Maybe, parsers, etc.
14:37:23 <kmc> a type for which (>>=) is defined is called "a monad"
14:37:51 <verma> kmc, oh .. like an IO monad e.g.
14:38:10 <kmc> IO is a monad, yes
14:38:23 <kmc> that's to say, you can use the (>>=) function to glue together IO actions
14:38:57 <verma> kmc ... oh ok ok .. I think I am getting it a little bit
14:40:26 <verma> kmc .. so basically, in my case .. the >>= was applying (==) ".c" to each Char within the [Char] which was returned by takeExtension .. right?
14:40:37 <verma> and that's why it was complaing that Char can't match [Char]
14:40:37 <kmc> yes
14:40:40 <kmc> exactly :)
14:40:44 <verma> nice :)
14:40:51 <kmc> and furthermore, it would want that function to return a list
14:41:00 <kmc> (>>=) :: [a] -> (a -> [b]) -> [b]
14:41:09 <kmc> :t flip concatMap
14:41:10 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
14:41:27 <kmc> concatMap f = concat . map f
14:41:38 <verma> oh ok
14:41:39 <kmc> x >>= f  =  concatMap f x
14:41:51 <kmc> (for the list instance of Monad, that is)
14:41:54 <kmc> @src [] (>>=)
14:41:54 <lambdabot> xs >>= f     = concatMap f xs
14:43:13 <verma> that makes sense .. thanks kmc :(
14:43:16 <verma> :)
14:43:17 <verma> :P
14:43:23 <kmc> :)
14:43:25 <kmc> no problem
14:43:33 <kmc> btw i think the easiest monad to start out with is (>>=)
14:43:39 <kmc> err
14:43:41 <kmc> btw i think the easiest monad to start out with is Maybe
14:43:42 <kmc> sorry
14:43:48 <copumpkin> lol
14:43:53 <kmc> it has a very simple semantics of failure/succes
14:43:54 <copumpkin> now you've ruined it 
14:44:04 <kmc> and you can write the instance yourself with three lines of code
14:44:17 <verma> :)
14:44:49 <dolio> How about Identity?
14:45:53 <verma> I will give it a try and see what I can test it out with .. thanks again
14:46:10 <copumpkin> dolio: not sure people would be blown away in an "oh that's so cool" way
14:46:28 <dolio> I guess Identity doesn't give you a very good feel for why you'd want to use it in the first place.
14:47:28 <dolio> So, CmdArgs still uses unsafePerformIO.
14:47:57 <Veinor> it does? why?
14:48:14 <copumpkin> cause it's awesome
14:49:18 <dolio> Because it has you do things like 'Config { field1 = v &= stuff &= junk ; ... }', and stuff an junk affect what is printed out about the field1 command line option.
14:49:41 <dolio> But (&=) has a type like a -> Something -> a.
14:49:57 <dolio> So obviously magic is happening.
14:51:35 <ezyang> Is there a way to use Data.Dynamic with a polymorphic type? 
14:51:50 <dolio> Not well.
14:52:02 <dolio> Even doing it at all is an Oleg-level hack.
14:52:18 <ezyang> blargh. 
14:52:28 <kmc> you can wrap your polymorphic type in a monomorphic one
14:52:52 <dolio> Yes, I suppose that's an option.
14:53:31 <ezyang> With existential types, hmm. 
14:53:43 <kmc> that's not what i had in mind
14:54:10 <ezyang> Basically, I'm doing explicit dictionary passing that needs to be resolved at runtime. 
14:54:21 <ezyang> (yes, I know, really really bad >.<) 
14:54:58 <kmc> existentials are not what you want for wrapping polymorphic values to be monomorphic
14:58:02 <anair_84> sorry for newbie question , any one know why openFile "quux.txt">>= hIsOpen  fails?
14:58:43 <c_wraith> anair_84, fails how?  That's currently a compile error, because it doesn't have a file mode
15:00:13 <anair_84> yeah compile error
15:00:28 <c_wraith> :t openFile
15:00:29 <lambdabot> Not in scope: `openFile'
15:00:35 <c_wraith> :t System.IO.openFile
15:00:37 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
15:00:42 <anair_84> Couldn't
15:00:43 <anair_84>     match expected type `IO Handle' against inferred type `Handle' 
15:01:03 <c_wraith> oh.  You'd better put your exact code and error message on a pastebin somewhere.
15:01:07 <c_wraith> @where hpaste
15:01:07 <lambdabot> http://hpaste.org/
15:01:22 <c_wraith> hmm.  hpaste is up, but looking recently spammed
15:01:25 <c_wraith> anyway, it will work
15:03:08 <pokoko222> guys you think i should waste time in software engineering literature? it is a looot of reading, some people think it is just dumb shit they make u study in college
15:03:20 <pokoko222> my course is called software processes by the way
15:03:32 <anair_84> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29183#a29183
15:04:14 <c_wraith> pokoko222, It's worth reading some, just to be aware of what common terminology and commonly-encountered problems are.  But don't expect to learn how to be a software engineer from literature, without experience to go with it.
15:04:40 <pokoko222> ok fair advice
15:05:27 <c_wraith> anair_84, I don't know what you're getting that exact error message, but you need to give openFile an IOMode argument
15:06:08 <anair_84> k , let me see
15:06:49 <anair_84> it works if I give it IOMode 
15:07:07 <anair_84> what is the difference between System.IO and GHC.IO
15:07:33 <c_wraith> GHC.IO contains the GHC-specific implementations of the functions in System.IO
15:08:01 <c_wraith> Basically, it's an implementation detail, that sometimes leaks out in type signatures.
15:08:08 <anair_84> c_wraith: so generally we should be using System.IO ?
15:08:14 <c_wraith> anair_84, yes
15:08:17 <anair_84> k thanks
15:11:23 * hackagebot x11-xim 0.0.4 - A binding to the xim of X11 graphics library  http://hackage.haskell.org/package/x11-xim-0.0.4 (YoshikuniJujo)
15:20:56 <minimalis> :q
15:30:01 <Zao> I've got a file with latin-1 text. How do I easiest get that into a Data.Text? Text.pack $ ByteString.Char8.unpack?
15:37:05 <Rotaerk> y halo thar
15:38:52 <luite> Zao: hSetEncoding handle latin1 
15:39:38 <luite> should work with ghc 6.12, and I think recent versions of the text package respect the encoding
15:40:15 <Zao> Ooh, the HP is 6.12.3. I misread the version number in the past.
15:46:43 <djahandarie> Finally back from San Francisco
15:49:32 <sinisa> Hi. I'm new to Haskell and have encountered a problem with function composition. Using the STM module, doing "atomWrite = atomically . writeTChan" seems to cause an error. GHC cannot match expected type "STM a" with inferred type "a1 -> STM ()". What's happening here? ^^ Thanks for any help!
15:50:02 <mauke> :t writeTChan
15:50:04 <lambdabot> Not in scope: `writeTChan'
15:50:20 <djahandarie> For some reason, hackage from my house literally crawls
15:50:22 <aristid> @hoogle writeTChan
15:50:22 <lambdabot> Control.Concurrent.STM.TChan writeTChan :: TChan a -> a -> STM ()
15:50:28 <djahandarie> Impossible to view documentation
15:50:40 <mauke> sinisa: writeTChan returns a function. atomically takes STM a.
15:50:40 <aristid> @hoogle atomically
15:50:41 <lambdabot> Control.Exception data NestedAtomically
15:50:41 <lambdabot> Control.Exception NestedAtomically :: NestedAtomically
15:50:41 <lambdabot> Control.OldException NestedAtomically :: Exception
15:50:45 <mauke> sinisa: those types don't match
15:50:52 <mauke> sinisa: you can't compose them like that
15:51:04 <aristid> and lambdabot finds the wrong stuff
15:51:17 <sinisa> mauke: I can't compose them like that? Is it because writeTChan takes two arguments?
15:51:17 <monochrom> atomWrite x y = atomically (writeTChan x y)
15:51:24 <mauke> :t Control.Concurrent.STM.atomically
15:51:25 <lambdabot> Couldn't find qualified module.
15:51:27 <sinisa> monochrom: Yes, that works.
15:51:36 <mauke> sinisa: all functions take exactly one argument
15:51:43 <monochrom> atomWrite x = atomically . writeTChan x
15:51:57 <sinisa> monochrom: Also, "atomWrite chan = atomically . writeTChan chan" works.
15:52:04 <sinisa> Ah, only one argument...
15:52:05 <aristid> @let (.:) = (.).(.)
15:52:06 <lambdabot>  Defined.
15:52:08 <aristid> :P
15:52:27 <monochrom> atomWrite x = (atomically .) (writeTChan x)
15:52:30 <bss03> :t (.:)
15:52:31 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:52:39 <monochrom> atomWrite = (atomically .) . writeChan
15:52:57 <monochrom> @pl \x y -> atomically (writeTChan x y)
15:52:58 <lambdabot> (atomically .) . writeTChan
15:53:51 <olsner> looks like a case for (.:) = fmap fmap fmap
15:53:52 <sinisa> Crikey, that works. What is this dark magick? :D
15:54:07 <mauke> function composition
15:54:24 <monochrom> You see I just calculated step by step.
15:54:26 <bss03> :t \x -> (x .)
15:54:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:54:41 <monochrom> No magic. No thinking. Just calculate.
15:54:43 <bss03> :t \x -> (x Prelude..)
15:54:44 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:54:48 <mauke> bss03: that's just (.)
15:55:08 <bss03> :t \x y -> (x Prelude..) . y
15:55:09 <lambdabot> forall b c a (f :: * -> *). (Functor f) => (b -> c) -> f (a -> b) -> f (a -> c)
15:55:17 <bss03> :t \x y -> (x Prelude..) Prelude.. y
15:55:18 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
15:55:58 <sinisa> mauke: Ah, I see now. I can repeat the process for as many arguments as I wish, then. Seems like just naming them explicitly is less trouble, however. :D
15:56:05 <sinisa> Thanks for the help!
15:56:20 <kmc> :t (?x Prelude..) Prelude.. ?y
15:56:22 <lambdabot> forall b c a a1. (?y::a1 -> a -> b, ?x::b -> c) => a1 -> a -> c
15:56:30 <monochrom> Yes, I would just stick with atomWrite x y = ... too
15:57:54 <aristid> :t ?x .: ?y
15:57:55 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (?x::a -> b, ?y::f (f1 a), Functor f, Functor f1) => f (f1 b)
16:04:23 <djahandarie> It really bugs me that . = fmap in cases like that
16:04:40 * monochrom debugs djahandarie
16:05:27 <djahandarie> I'm a Haskell program, how do you debug me?
16:05:36 <copumpkin> I take you apart
16:05:41 <kmc> by thinking very hard and then writing a fold function
16:05:42 <copumpkin> and poke the individual parts separately
16:06:00 <monochrom> by static analysis
16:06:13 <tromp> ghc debugs you
16:06:19 <tromp> with type errors
16:06:22 <Veinor> :t fmap fmap fmap
16:06:23 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:06:42 <Veinor> @unpl (.) . (.)
16:06:43 <lambdabot> (\ i b c f -> i (b c f))
16:07:22 <djahandarie> In Glasgow Scotland, GHC debugs YOU
16:07:28 <monochrom> hahahaha
16:07:41 <monochrom> @remember djahandarie In Glasgow Scotland, GHC debugs YOU
16:07:42 <lambdabot> I will never forget.
16:08:32 <djahandarie> Apparently I'm pretty witty when I'm sleep-deprived and starving
16:08:40 <monochrom> me too
16:13:09 <chrisdone> make &> /dev/stdout | ./ignore '^lib/showdown\.js' '^lib/sso-client\.js' '^lib/jquery\.tablednd\.js' '^lib/jquery\.js' '^lib/jquery\.form\.js' '^lib/fileuploader\.js' '^forj/'
16:13:14 <chrisdone> this is how i deal with my problems
16:13:22 <chrisdone> the wonderful ./ignore
16:16:32 <chrisdone> remind me, the static type system is the single greatest human discovery in the field of computer science?
16:16:35 <mauke> is that like grep -v?
16:16:46 <chrisdone> mauke: kinda, but this one deals with multiple lines at a time
16:17:15 <chrisdone> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29184#a29184
16:17:16 <chrisdone> mmm
16:17:20 <mauke> so like multiple grep -v's
16:17:24 <FunctorSalad_> how do I use :ctags to tag a whole tree?
16:17:35 <chrisdone> nah because the lines are dependant
16:17:39 <chrisdone> er, dependent
16:17:59 <FunctorSalad_> for x in **/*.hs; do ghc -e ':ctags' "$x"; done? (give or take a 'cd')
16:18:02 <mauke> how?
16:18:11 <FunctorSalad_> or do I not have to do it for every single file
16:18:26 <ksf> can pandoc-markdown do links to inside the document?
16:18:46 <FunctorSalad_> it does chase some imports, but I don't know which files are minimal in the dependency graph
16:18:49 <chrisdone> mauke: error line and message \n code line \n empty line
16:19:10 <ksf> all I can find is external links and footnotes
16:19:21 <FunctorSalad_> so unless you actually determine the graph, it seems you have to :load and :ctags every single file
16:21:12 <ddarius> GHC does debug you.
16:21:49 <FunctorSalad_> @me?
16:21:50 <lambdabot> Maybe you meant: ? let map msg
16:22:46 <aristid> @vixen me?
16:22:46 <lambdabot> no
16:22:54 <ski> @ghc
16:22:55 <lambdabot> ghc says: Malformed context in instance header
16:23:54 <djahandarie> @ghc
16:23:55 <lambdabot> ghc says: ARGH! Jump uses %esi or %edi with -monly-2-regs
16:24:02 <djahandarie> lol
16:24:19 <djahandarie> I'd be very scared if it told me that
16:24:47 <chrisdone> mauke: possible -B and -A would work the regex were inverted
16:25:14 <chrisdone> grep '^(jquery|etc)' -A 3 or w/e
16:25:57 <chrisdone> but it's not the same
16:27:27 <jozi> Hey, I'm wondering why this is so slow: foldl (++) "" . map doStuff . concat, compared to: concatMap encodeRGB . concat. Does it have to do with the foldl?
16:27:35 <jozi> Also,  I found this by profiling, but are there any tools for performance analysis within expressions?
16:28:18 <jozi> doStuff and encodeRGB being the same function. :)
16:28:25 <kmc> you can profile within an expression by adding your own cost-center annotations
16:28:29 <kmc> it probably has to do with (++)
16:28:39 <kmc> since (++) walks to the end of the first string every time
16:28:49 <ski> don't `foldl' with `(++)'
16:28:55 <ski> use `foldr'
16:29:00 <ski> or, hm
16:29:05 <kmc> @src concat
16:29:06 <lambdabot> concat = foldr (++) []
16:29:22 <ski> well, i suppose it depends on what you actually want to do
16:29:23 <kmc> foldl involves traversing the list in the unnatural direction
16:29:36 <kmc> «foldr f z» is simply replacing each (:) with f and [] with z
16:29:41 <kmc> foldl also effectively reverses the list
16:29:53 <jozi> ski: here I want to join a list of strings.
16:29:57 <kmc> and it's particularly bad with (++)
16:30:01 <kmc> since it walks the first arg each time
16:30:05 <kmc> with foldl that arg grows each time
16:30:09 <ski> > (foldl (++) [] &&& foldr (++) []) ["abcd","efg","hi","j",""]
16:30:10 <kmc> with foldr it is just the new string each time
16:30:10 <lambdabot>   ("abcdefghij","abcdefghij")
16:30:29 <kmc> how about this claim: if you have an associative operator, foldr is always better
16:30:30 <ski> jozi : so `foldr'
16:30:31 <kmc> is that reasonable?
16:30:48 <jozi> Yes it is.
16:30:56 <chrisdone> use a rope!!
16:30:58 <jozi> Thanks.
16:30:59 <aristid> kmc: i think foldl is fine if you need reverse-ness
16:31:10 <aristid> chrisdone: or Data.Sequence.Seq?
16:31:29 <jozi> That shaved off a factor of 1000 performance-wise! Gotta be more careful.
16:31:34 <micahjohnston> > putStrLn "hello"
16:31:36 <lambdabot>   <IO ()>
16:31:37 <ski> > foldr (+) 0 [0 .. 999999999]
16:31:39 <lambdabot>   *Exception: stack overflow
16:31:44 <ski> kmc : ^
16:32:08 <aristid> > foldl' (+) 0 [0 .. 999999999]
16:32:11 <lambdabot>   mueval-core: Time limit exceeded
16:32:37 <micahjohnston> > let {x = y; y = x} in x + y
16:32:42 <lambdabot>   mueval-core: Time limit exceeded
16:32:49 <ski> jozi : btw, `foldr cons nil . map f' can be written as `foldr (cons . f) nil', for any `cons',`nil',`f'
16:33:35 <jozi> ski: how did you find that?
16:33:35 * ski reads the rest of jozi's original message ..
16:33:39 <micahjohnston> > let 5 = 6 in 5 + 1
16:33:41 <lambdabot>   6
16:33:44 <micahjohnston> :/
16:33:48 <ski> jozi : simple rewriting
16:34:03 <micahjohnston> let 3 + 4 = 8 in 3 + 4
16:34:10 <micahjohnston> guh
16:34:16 <micahjohnston> > let 3 + 4 = 8 in 3 + 4
16:34:17 <lambdabot>   8
16:34:29 <jozi> ski: ah, I see it now.
16:34:36 <FunctorSalad_> kmc: (+)?
16:34:52 <FunctorSalad_> maybe you meant foldr is better than foldl but not foldl'
16:35:02 <kmc> oh, right ski
16:35:13 <kmc> foldr is better when you can consume the accumulator lazily
16:35:22 <kmc> the sum version would be great with Peano naturals ;)
16:35:23 <ski> > (foldr f z . map (g :: Expr -> Expr)) [a,b,c,d]
16:35:24 <lambdabot>   f (g a) (f (g b) (f (g c) (f (g d) z)))
16:35:28 <c_wraith> foldr and foldl' are both frequently what you want.  foldl is better...  in very rare cases.
16:35:39 <ski> > (foldr (f . g :: Expr -> Expr) z) [a,b,c,d]
16:35:40 <lambdabot>   Couldn't match expected type `b -> b'
16:35:40 <lambdabot>         against inferred type `Simple...
16:35:58 <ski> > (foldr (f . g :: Expr -> Expr -> Expr) z) [a,b,c,d]  -- doh
16:35:59 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:36:00 <lambdabot>    `SimpleReflect.FromExpr ...
16:36:24 <syntaxglitch> > let 1 + 1 = 2 in 2 + 2
16:36:25 <lambdabot>   *Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
16:36:33 <ski> > (foldr (f . (g :: Expr -> Expr)) z) [a,b,c,d]  -- happy now !?
16:36:34 <lambdabot>   f (g a) (f (g b) (f (g c) (f (g d) z)))
16:44:02 <ddarius> I would go so far to say that foldl is so rarely what you want that it should be removed from the standard libraries altogether.
16:44:17 <etpace> what?
16:44:40 * syntaxglitch has a personal alternate prelude that replaces foldl with foldl'
16:44:40 <etpace> I'm trying to think of a case where foldl is better than foldl'
16:44:55 <copumpkin> etpace: if you have bottoms in your list
16:45:05 <copumpkin> and your folded function isn't necessarily strict
16:45:07 <ddarius> etpace: There are some cases where it is more defined.  There are, conceivably, some cases where it is very slightly more efficient.
16:45:25 <Philippa> is foldl' actually strict there, as opposed to spine-strict?
16:46:06 <c_wraith> foldl' is only ever strict to WHNF in the accumulator.
16:46:22 <c_wraith> Sometimes you need a custom accumulator in order to take advantage of that.
16:46:37 <etpace> "custom accumulator"?
16:46:42 <syntaxglitch> > foldl const () (replicate 11 undefined)
16:46:43 <lambdabot>   ()
16:47:05 <dolio> In my experience, it takes actual work to create a situation where foldl is more defined than foldl'.
16:47:07 <c_wraith> etpace: look at the sample code for averaging a long list of numbers in one pass
16:47:10 <dolio> They don't tend to arise naturally.
16:47:33 <ddarius> dolio: Even when they do arise, you usually don't want it anyway.
16:47:34 <syntaxglitch> > foldl' const () (replicate 11 undefined)
16:47:36 <lambdabot>   ()
16:47:58 <c_wraith> etpace: it uses a custom accumulator that's essentially a strict pair, so that forcing the accumulator to wnf at each step is enough to fully force the calculations.
16:48:33 <syntaxglitch> > foldl' (const $ const ()) undefined (replicate 11 undefined)
16:48:35 <lambdabot>   ()
16:48:53 <ddarius> You don't need a custom type for it (though strict types are certainly helpful), you can just add the extra forcing to the relevant functions.
16:48:58 <c_wraith> err, whnf
16:49:41 <c_wraith> do bang patterns inside of pattern matches work?  let f (!a, !b) = a + b, for instance?  Does that do what I'd expect?
16:49:54 <c_wraith> I seem to remember irrefutable matches inside of patterns not working the way I'd expect
16:50:12 <Veinor> > let f (!a, !b) = a + b in f (2,3)
16:50:13 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
16:50:14 <ddarius> c_wraith: In that particular case, it would be pointless, but yes.
16:50:15 <dolio> > foldl' (\_ e -> e) 0 [undefined, 2, 3, 4]
16:50:17 <lambdabot>   *Exception: Prelude.undefined
16:50:18 <dolio> > foldl (\_ e -> e) 0 [undefined, 2, 3, 4]
16:50:19 <lambdabot>   4
16:50:44 <etpace> > foldl (\acc x -> let len = first (+1); tot = second (+x) in len . tot $! acc) (0,0) [1..5]
16:50:45 <lambdabot>   (5,15)
16:51:33 <ddarius> c_wraith: Irrefutable matches inside of patterns should work the way you expect, or perhaps your expectations are wrong (or maybe mine are.)
16:51:42 <ddarius> c_wraith: What's an example of unexpected behavior?
16:52:39 <c_wraith> ddarius: I don't remember.  I didn't run into it myself.  I just was reading a blog post, and I guessed the meanings wrong.
16:54:09 <aristid> @src ($!)
16:54:09 <lambdabot> f $! x = x `seq` f x
16:55:34 <aristid> > foldr (\x acc -> let len = first (+1); tot = second (+x) in len . tot $! acc) (0,0) [5,4..1]
16:55:35 <lambdabot>   (5,15)
16:56:00 <tolkad> Is it possible to write partical class instances that define default functions?
16:56:34 <aristid> etpace: your expression seems to be symmetric wrt the input
16:56:44 <aristid> etpace: so is foldl better there?
16:57:21 <tkahn6> is there a standard function that converts a ByteString to Integer?
16:57:35 <Veinor> tkahn6: how?
16:57:36 <tolkad> tkahn6: check the binary package
16:57:51 <bss03> read? ;)
16:57:54 <tkahn6> ah as in "1234" -> 1234
16:58:01 <tolkad> check the binary package
16:58:05 <tkahn6> k
16:58:13 <c_wraith> I doubt binary covers that
16:58:28 <tolkad> Oh
16:58:33 <tolkad> whoops, misunderstood
16:58:36 <tolkad> sorry tkahn6 
16:58:39 <c_wraith> Just convert it to a string and use read.
16:58:42 <tkahn6> ok
16:58:47 <c_wraith> That's more efficient than you might think
16:58:58 <monochrom> I use length
16:58:58 <ddarius> There's a readInt somewhere that will convert to Int.
16:59:11 <tkahn6> ddarius: ill check that out
16:59:22 <c_wraith> I mean, attoparsec has primitives for parsing bytestrings to numbers.
16:59:24 <tkahn6> oh nice
16:59:36 <bss03> let { bToC :: Byte -> Char; bToC = fromInteger . toInteger } in read . map bToC bs :: Integer ?
17:00:00 <tkahn6> bss03: i could roll my own but I'd rather use a standard function :)
17:00:13 <tkahn6> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString-Char8.html#v:readInt
17:00:14 <aristid> @hoogle unpack
17:00:14 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
17:00:14 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
17:00:14 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
17:00:19 <bss03> Then, do what c_wraith said.
17:00:29 <tolkad> partial class instances that allow you to define default functions for instances matching the partial instance type would be awesome and harmless
17:00:42 <bss03> :t read . unpack :: Integer
17:00:43 <lambdabot> Not in scope: `unpack'
17:01:04 <bss03> :t read . Data.ByteString.Char8.unpack
17:01:06 <lambdabot> forall a. (Read a) => BSC.ByteString -> a
17:01:11 <kmc> tolkad, can you write up an example of such an instance?
17:01:34 <tolkad> kmc: one moment
17:02:09 <jadrian> I just installed the pointful package but cannot use it
17:02:25 <jadrian> how do you do queries with it
17:05:10 <ClaudiusMaximus> i've found an occasion where a type has an incomplete instance - and i can't import the type and not the instance, so it's worse than useless because i can't implement the missing functions (it's LargeWord from Crypto missing quotRem in Integral)
17:05:36 <tolkad> kmc: ah, here's a good one
17:06:48 <tolkad> instance (Enum t) => Integral t where {succ x = x + 1;pred x = x - 1}
17:07:15 <tolkad> err wait
17:07:18 <tolkad> other way around
17:07:24 <tolkad> instance (Integral t) => Enum t where {succ x = x + 1;pred x = x - 1}
17:07:30 <jadrian> ok apparently all the output of the haskell packages I install goes to some file named 'x'
17:07:31 <ClaudiusMaximus> i guess what i should do is implement it, then file a patch, but i decided to stick to Integer, and then i decided to change the representation to a list, as my usage of divMod was proving slow and dropWhile (== T7) was semantically clearer
17:07:35 <tolkad> kmc: see how that would be useful?
17:07:40 <jadrian> any idea why this might be the case?
17:07:43 <kmc> tolkad, yes, it would
17:10:34 <aristid> > pred 0
17:10:35 <lambdabot>   -1
17:10:43 <aristid> > pred 0 :: Word
17:10:44 <lambdabot>   *Exception: Enum.pred{Word}: tried to take `pred' of minBound
17:10:52 <aristid> > (0 - 1) :: Word
17:10:53 <lambdabot>   18446744073709551615
17:11:22 <hpc> > maxBound :: Word
17:11:23 <lambdabot>   18446744073709551615
17:11:28 <jadrian> @pl \x -> x
17:11:29 <lambdabot> id
17:11:40 <tolkad> aristid: it would just be a default instance, word could still make its own
17:12:06 <aristid> tolkad: that would be an overlapping instance
17:12:34 <kmc> you would need a way to mark it as an overridable default
17:12:35 <tolkad> aristid: classes can make default functions that are overriden rather than overlapped, can't they?
17:12:39 <tolkad> yeah
17:12:45 <kmc> and you would probably want explicit backtracking in class resolution too
17:12:58 <aristid> tolkad: i don't know of such a possibility
17:13:06 <kmc> otherwise you can have only one of «(Foo t) => Bar t», «(Baz t) => Bar t»
17:13:09 <kmc> it would change the language design a lot
17:13:11 <kmc> but it would be useful
17:13:16 <jadrian> @pl  \b -> \a -> \x ->  (b x) (a x)
17:13:16 <lambdabot> ap
17:13:37 <jadrian> huh
17:13:42 <tolkad> are you sure? don't classes already have default implementations of functions?
17:13:45 <jadrian> where is ap defined?
17:13:50 <hpc> @hoogle ap
17:13:51 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
17:13:51 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
17:13:51 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
17:13:57 <bss03> jadrian: Control.Monad
17:14:01 <jadrian> thanks!
17:14:08 <tolkad> :t ap.ap
17:14:09 <lambdabot> forall a b a1. (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
17:14:12 <jadrian> isn't pl cheating :S
17:14:19 <tolkad> :t ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap
17:14:33 <kmc> tolkad, a default implementation of a function, and a default instance of a class, are two totally different things
17:14:33 <djahandarie> You need Control.Monad.Instances for that to work btw
17:14:34 <jadrian> it's supposed to give a point free version of the term
17:14:35 <lambdabot> thread killed
17:14:46 <tolkad> kmc: ah, I see
17:14:47 <djahandarie> lol that's the first I've seen that
17:15:00 <tolkad> :t ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.
17:15:01 <lambdabot> parse error (possibly incorrect indentation)
17:15:04 <tolkad> :t ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap.ap
17:15:05 <lambdabot> forall b a a1. (a -> a1 -> b) -> ((((((((((((((a -> a1) -> a) -> a -> a1) -> (a -> a1) -> a) -> ((a -> a1) -> a) -> a -> a1) -> (((a -> a1) -> a) -> a -> a1) -> (a -> a1) -> a) -> ((((a -> a1) -> a)
17:15:05 <lambdabot> -> a -> a1) -> (a -> a1) -> a) -> ((a -> a1) -> a) -> a -> a1) -> (((((a -> a1) -> a) -> a -> a1) -> (a -> a1) -> a) -> ((a -> a1) -> a) -> a -> a1) -> (((a -> a1) -> a) -> a -> a1) -> (a -> a1) ->
17:15:05 <lambdabot> a) -> ((((((a -> a1) -> a) -> a -> a1) -> (a -> a1) -> a) -> ((a -> a1) -> a) -> a -> a1) -> (((a -> a1) -> a) -> a -> a1) -> (a -> a1) -> a) -> ((((a -> a1) -> a) -> a -> a1) -> (a -> a1) -> a) -> (
17:15:05 <lambdabot> (a -> a1) -> a) -> a -> a1) -> (((((((a -> a1) -> a) -> a -> a1) -> (a -> a1) -> a) -> ((a -> a1) -> a) -> a -> a1) -> (((a -> a1) -> a) -> a -> a1) -> (a -> a1) -> a) -> ((((a -> a1) -> a) -> a ->
17:15:05 <lambdabot> a1) -> (a -> a1) -> a) -> ((a -> a1) -> a) -> a -> a1) -> (((((a -> a1) -> a) -> a -> a1) -> (a -> a1) -> a) -> ((a -> a1) -> a) -> a -> a1) -> (((a -> a1) -> a) -> a -> a1) -> (a -> a1) -> a) -> (((
17:15:07 <lambdabot> [49 @more lines]
17:15:12 <djahandarie> Heh
17:15:16 <jadrian> instead it gives some term which is pre defined  possibly using a non pointfree notation
17:15:17 <kmc> oh god
17:15:37 <djahandarie> At least fmap stops getting more complicated
17:16:14 <jadrian> I know there must be some primitives to pointfree terms...
17:16:18 <jadrian> but ap :S
17:16:22 <hpc> :t ap ap ap
17:16:24 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
17:16:24 <lambdabot>     Probable cause: `ap' is applied to too few arguments
17:16:24 <lambdabot>     In the second argument of `ap', namely `ap'
17:16:32 <tolkad> it would be funny to write useful libraries but hide within them lots of nonsensical instances for builtin haskell types/classes
17:17:23 <tolkad> a Monad instance for Integer
17:17:30 <tolkad> oh wait, that's not possible
17:17:31 <tolkad> uh
17:17:35 <tolkad> you know what I mean
17:17:52 <tolkad> just to cause confusing runtime errors
17:18:19 <shapr> @yow !
17:18:19 <hpc> it would be funnier if you used incoherent instances too
17:18:20 <lambdabot> Couldn't find fortune file
17:18:25 <shapr> Yow!  Legally-imposed CULTURE-reduction is CABBAGE-BRAINED!
17:18:27 <Philonous> tolkad: You mean like mtl/transformers ? 
17:18:44 <Philonous> tolkad: There
17:19:02 <Philonous> tolkad: ... a lot of fun to be had, yes. 
17:20:53 <tolkad> could the kind of evaluation hat lambdabot does be done at compile time?
17:21:13 <c_wraith> well, yes.
17:21:21 <c_wraith> All of lambdabot's functionality is in haskell
17:21:28 <c_wraith> and you can run arbitrary haskell at compile time
17:21:31 <ClaudiusMaximus> @hoogle runIO
17:21:32 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
17:21:32 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
17:21:32 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
17:21:38 <aristid> @yow test6
17:21:39 <lambdabot> Couldn't find fortune file
17:24:10 <ClaudiusMaximus> tolkad: i hacked a template haskell front-end on to djinn recently (need to hack on it some more sometime to enable class support, fix tuple handling properly, etc)
17:25:21 <Wooga> why this code: http://codepad.org/A8htrmdY runs well on hugs (which is codepad using) and fails with ghc?
17:25:48 <copumpkin> fails how in GHC?
17:26:12 <copumpkin> oh
17:26:18 <Wooga> http://codepad.org/CbASFYHS
17:26:21 <ClaudiusMaximus> :t Data.Map.lookup
17:26:21 <copumpkin> cause Map.lookup returns a Maybe now
17:26:23 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
17:26:27 <bss03> :t Data.Map.lookup
17:26:29 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
17:26:37 <copumpkin> I think it used to return a Monad(Plus?) instance
17:26:44 <copumpkin> either using fail or mzero
17:26:46 <bss03> It's possible their Hugs is using the old type signature.
17:27:23 <bss03> forall k a m. (Ork k, Monad m) => k -> Map k a -> m a
17:27:53 <ClaudiusMaximus> http://www.haskell.org/haskellwiki/Upgrading_packages#Return_types_of_Map_and_Set_functions
17:27:56 <bss03> I think it used fail.
17:44:14 <tkahn6> hey btw copumpkin i totally understand the reason for (<*>) now! thanks for your help the other day
17:44:49 <copumpkin> oh, no problem :)
17:44:52 <syntaxglitch> hooray for (<*>)!
17:44:57 <syntaxglitch> my fourth-favorite operator in Haskell
17:45:04 <tkahn6> yeah it's amazing
17:45:05 <tkahn6> lol
17:45:14 <kmc> it's named "splat" right?
17:45:16 <dolio> What's third?
17:45:16 <kmc> splat and money?
17:45:44 <aristid> syntaxglitch: after which?
17:45:51 <syntaxglitch> dolio, (++) after redefining it to be mappend
17:46:00 <syntaxglitch> the first two are ($) and (<$>)
17:46:06 <copumpkin> pff ($)
17:46:10 <copumpkin> I'd put that way down there
17:46:11 <mauke> @let (⧺) x = mappend x
17:46:13 <lambdabot>  Defined.
17:46:17 <kmc> what about (.)
17:46:23 <syntaxglitch> oooh, good point
17:46:26 <syntaxglitch> dunno how I forgot that
17:46:27 <copumpkin> he's got <$> :P
17:46:28 * kmc rimshot
17:46:43 <syntaxglitch> copumpkin, true
17:46:57 <aristid> ($) is the boring-est operator ever
17:47:08 <mauke> ($) is a no-op
17:47:35 <mauke> ($) is a secret identity
17:47:40 <syntaxglitch> kmc, oh and I endorse not calling (<*>) anything at all
17:47:45 <tkahn6> how about
17:47:46 <tkahn6> fmap
17:47:54 <tkahn6> call it sexy fmap
17:47:57 <aristid> tkahn6: that's (<$>)
17:48:03 <tkahn6> oh right
17:48:04 <illissius`> i liek backfish
17:48:06 <tkahn6> :p
17:48:07 <mauke> I'm bringing sexy fmap
17:48:10 <tkahn6> lol
17:48:22 <vanadium> Can we use `id` in place of $
17:48:24 <tensorpudding> (<*>) is goatse fmap
17:48:25 <copumpkin> pff, all I need is <*> and id
17:48:26 <sinisa> Hi! I'm learning Haskell and trying to create a "handleIO" function similar to Control.Exception.handle. Instead of accepting a (\e -> IO a) as a handler, it would just accept an (IO a) to run in case of an IOException. I'm getting type mismatch errors, however. Something about rigid type variables.
17:49:00 <aristid> copumpkin: you don't event need const?
17:49:01 <syntaxglitch> copumpkin, really? how do you write "const" that way
17:49:03 <vanadium> Sounds like you should fix some types then.
17:49:24 <copumpkin> syntaxglitch: I meant const, sorry :P
17:49:28 <syntaxglitch> hahaha
17:50:16 <sinisa> This is what I'm trying to do: "handleIO h act = handle (const h :: IOException -> IO a) act". I'd be grateful for any help. It seems GHC is complaining that the first 'a's are not matched with the one in "const h".
17:50:19 <syntaxglitch> copumpkin, remember, there's no "I" in "haSKell"
17:50:29 <copumpkin> lol
17:51:23 <sinisa> Where the type of handleIO would be "IO a -> IO a -> IO a".
17:51:52 <aristid> @remember syntaxglitch copumpkin, remember, there's no "I" in "haSKell"
17:51:52 <lambdabot> Okay.
17:51:59 <aristid> @quote hasSKell
17:52:00 <lambdabot> No quotes match. I am sorry.
17:52:01 <tkahn6> syntaxglitch: clever
17:52:04 <aristid> oO
17:52:13 <aristid> lambdabot: can't you match properly?
17:52:23 <copumpkin> :)
17:53:52 <kmc> sinisa, can you put your code on hpaste.org?
17:53:58 <kmc> probably you need to match an 'a' in another type signature?
17:54:05 <syntaxglitch> aristid, your spelling is a little excesssssive there
17:54:27 <kmc> the straightforward way is to turn on the extension ScopedTypeVariables
17:54:37 <kmc> then to rewrite that first sig with a "forall a." in front
17:54:48 <kmc> thus bringing it into scope
17:55:56 * syntaxglitch sighs
17:56:23 <syntaxglitch> I spend four hours writing a quick hack to prove a point in an IRC channel, now somehow I'm putting it on github and now I feel obligated to make the code not horrendous :(
17:56:39 <sinisa> kmc: Ahh, I've been missing forall a. It works now. Thank you very much!
17:56:45 <kmc> no problem :)
17:57:06 <aristid> @quote haSKell
17:57:06 <lambdabot> tensorpudding says: so you boil lisp for an hour to sift out the parentheses and impurities, make a whitespace sauce with liberal syntactic sugar, and you have haskell a la mode
17:58:32 <Martty> @quote c++
17:58:34 <lambdabot> gubagem says: If I've made a monad by accident, am I heading in the correct direction?
17:58:51 <djahandarie> ...lol
17:59:04 <djahandarie> @quote c\+\+
17:59:05 <lambdabot> kmc says: I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
17:59:05 <dolio> That's interesting.
17:59:20 <syntaxglitch> heh
17:59:36 <syntaxglitch> C and C++ have a bit more in common than that
17:59:45 <Adamant> eh. for all the differences and technical points, C and C++ are pretty close
17:59:53 <p_l> that's because recrutoids usually don't understand the CVs they read?
18:00:00 <p_l> (assuming the CV is read at all)
18:00:02 <vanadium> @type \h act -> handle (\e -> const h (e :: SomeException)) act
18:00:03 <lambdabot>     Not in scope: type constructor or class `SomeException'
18:00:16 <syntaxglitch> it'd be more like putting "Common Lisp/Scheme" on your resume. Most people don't know the difference, there are superficial similarities, and you'll make fans of each cry into their beer
18:00:20 <tkahn6> is there a better (more idiomatic) way to accomplish what I want here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29191#a29191
18:00:43 <Adamant> syntaxglitch: only some of those fans. most of them have probably done both.
18:01:49 <copumpkin> tkahn6: you're doing join on a return :o
18:02:00 <kmc> C and C++ are pretty close in the same way a lawnmower and a monster truck are pretty close
18:02:02 <djahandarie> tkahn6, that do block can be... fmap (fmap fst) (fmap readinteger s) I think
18:02:06 <copumpkin> :t readInteger
18:02:06 <kmc> both do indeed have an internal combustion engine at the core
18:02:07 <lambdabot> Not in scope: `readInteger'
18:02:17 <djahandarie> All the fmaps confused me so I might be wrong
18:02:26 <tkahn6> readInteger returns (Maybe Integer, ByteString)
18:02:27 <vanadium> kmc: where the monster truck is running on a lawnmower engine with a lot of extra parts tacked on?
18:02:40 <kmc> and modified
18:02:45 <kmc> remember, C++ isn't totally backwards compatible either
18:02:48 <kmc> even less so if you compare to C89
18:03:07 <kmc> the point is, the amount of stuff added to C in C++ is much, much larger than the entire C language
18:03:11 <tkahn6> copumpkin: lol on join on return
18:03:17 <tkahn6> thanks
18:03:21 <copumpkin> :)
18:03:24 <Adamant> kmc: true.
18:03:28 <kmc> so it's not "C with enhancements", it's a wholly different huge sprawling language which uses C as a small core
18:03:29 <copumpkin> :t join . return
18:03:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
18:03:32 <nejucomo> I try cabal install inside a source directory, and it tells me: There is no available version of ghc-prim that satisfies >=0.1 && <=0.2
18:03:33 <tkahn6> hahaha
18:03:35 <kmc> it'd be like saying Haskell and STG are the same language, maybe
18:03:49 <copumpkin> tkahn6: now, your thing simplifies more
18:03:51 <kmc> or Haskell and Scheme
18:03:54 <monochrom> J/Java/Javascript
18:03:56 <djahandarie> tkahn6, also... [operations, number1, number2] <- map getParam ["operation", "number1", "number2"]
18:04:00 <nejucomo> If I do "cabal list ghc-prim" it prints out details about 0.2.0.0.  But if I do "cabal info ghc-prim" it says no package exists.
18:04:12 <nejucomo> Any caballeers here?
18:04:13 <tkahn6> djahandarie: thanks
18:04:36 <tkahn6> it should be mapM or map?
18:05:13 <djahandarie> map I'm pretty sure, but I also haven't slept for over 40 hours
18:05:21 <tkahn6> wow
18:05:24 <tkahn6> why not?
18:05:25 <pickles> go take a nap
18:05:30 <djahandarie> Planes
18:05:32 <pickles> for 12 hrs
18:05:32 <tkahn6> ah
18:05:33 <djahandarie> Been traveling like hell
18:06:27 <nejucomo> No love on cabal issues?
18:06:40 <nejucomo> Is ghc-prim some sort of special case package?
18:07:04 <nejucomo> -or is this a cabal bug?  -or is my cabal state borked?
18:07:05 <monochrom> yes, it comes with ghc and tied in, should not replace
18:07:20 <Martty> what part of the computer is in charge of reading memory?
18:07:30 <nejucomo> Sure, but why does "cabal list ghc-prim" say it is locally installed, but "cabal info ghc-prim" says there is no such package?
18:07:40 <djahandarie> tkahn6, okay, that was actually wrong
18:07:47 <nejucomo> Furthermore "cabal install" inside a different project fails because it says "ghc-prim" is not met…  :-/
18:07:49 <monochrom> what is the semantics of cabal list?
18:08:16 <djahandarie> It was some weird combination of let and <-
18:08:23 <nejucomo> From cabal help:
18:08:24 <nejucomo>   list         List packages matching a search string.
18:08:24 <nejucomo>   info         Display detailed information about a particular package.
18:09:11 <nejucomo> Martty: Your question is pretty vague.  Can you make it more specific?
18:09:24 <tkahn6> ghc using 2.4GB. nice!!
18:09:28 <monochrom> does list mean it must only care about packages on hackage?
18:09:41 <Martty> nejucomo: nvm
18:09:48 <djahandarie> tkahn6, you can do what I said for your let on the next line though
18:09:54 <tkahn6> ah ok
18:09:56 <monochrom> because it clearly says "Latest version available: [ Not available from server ]"
18:09:57 <nejucomo> monochrom: I'm not sure.  list *does* show ghc-prim, but "info" does not...
18:10:12 <monochrom> so it clearly does not restrict itself to hackage packages
18:10:20 <nejucomo> monochrom: Right, but then it also says "Latest version installed: 0.2.0.0".
18:10:23 <sinisa> Is there any way I can make all of my literal Strings be auto-interpreted as Data.Text.Text? Something like auto-packing for Data.ByteString, only this would work with Data.Text.
18:10:33 <monochrom> because it is installed.
18:10:47 <monochrom> try "ghc-pkg list ghc-prim" some day
18:10:51 <nejucomo> monochrom: Then why does "cabal install" tell me the dependency check fails?
18:11:18 <nejucomo> BTW- I'm modifying a .cabal file to port a project to a newer haskell platform version...
18:11:22 <monochrom> cabal install which?
18:11:25 <nejucomo> -so I might have made a mistake.
18:11:40 <djahandarie> Agh, I really need to figure out why hackage doesn't work for me here
18:11:48 <nejucomo> monochrom: With no arguments inside the code checkout.
18:11:49 <monochrom> I see, cabal install in a source directory
18:11:52 <nejucomo> Yeah.
18:12:10 <monochrom> then it is the .cabal file wanting another ghc-prim version
18:12:37 <Wooga> dino-: i must thank you for giving me monad transformers tutorial. it really helps!
18:12:38 <nejucomo> So I altered the build dependency liek this: "ghc-prim == 0.1.*" -> "ghc-prim >= 0.1 && <= 0.2.0.0".
18:12:51 <nejucomo> Is that kosher?
18:13:24 <djahandarie> Weird, hackage only lags when I come from google
18:13:31 <nejucomo> I also changed "base == 4.1.*" to "base >= 4.1 && <= 4.2.0.2" which seems to have passed the dependency checks.
18:13:41 <monochrom> it is not kosher because you haven't personally checked that the way this code uses ghc-prim will work fine with ghc-prim 0.2
18:14:00 <nejucomo> monochrom: Well, my plan was to tell cabal it was okay, then to fix compile errors.
18:14:06 <nejucomo> Is there a better approach?
18:14:55 <monochrom> nothing stops you from testing
18:15:00 <nejucomo> I suppose I can just try ghc —make, then work out the api changes.
18:15:29 <monochrom> I just answered "is it kosher?". It is not kosher.
18:15:40 <monochrom> But even I eat non-kosher meat all the time.
18:15:43 <nejucomo> So, in general, how can I write haskell code that compiles on different versions of dependencies?
18:16:13 <nejucomo> Do I need to use some kind of preprocessor goo?
18:16:19 <tkahn6> djahandarie: thanks for the tip on using map for the lets. I wasn't aware you could bind like that
18:16:39 <djahandarie> Yeah
18:16:48 <tkahn6> :))
18:17:13 <monochrom> If your code really works uniformly over different versions, write .cabal to allow that large range. If you need different code to match different versions, yes a lot of #ifdef
18:17:30 <nejucomo> Hrm.  Ok.  Thanks for the help.
18:18:26 <kmc> you could ifdef some imports
18:18:32 <kmc> and then have whole modules for different versions
18:19:54 <nejucomo> kmc: Yeah, that's the approach I prefer.  I dislike preprocessor directives so I want to minimize their scope.
18:20:10 <sinisa> I have just discovered that OverloadedStrings work with Data.Text as well as Data.ByteString. Good sirs this is nothing short of dark magick.
18:20:32 <tkahn6> djahandarie: the thing with getParams worked. [operation, number1, number2] <- mapM getParam ["operation", "number1", "number2"]
18:20:44 <djahandarie> Oh, it did?
18:20:59 <tkahn6> yeah its working
18:21:10 <tkahn6> unless i'm encountering some weird caching thing
18:21:13 <kmc> sinisa, it kind of shouldn't work with ByteString, since it's a sequence of bytes, not characters
18:21:16 <djahandarie> Oh, yeah, that certainly does make sense now that I think about it
18:21:26 <kmc> but it's useful enough to conflate the two, even though it's also the source of lots of headaches
18:21:27 <tkahn6> thanks again for the help
18:21:37 <sinisa> kmc: Oh, sorry, I believe it's Data.ByteString.Char8 instead.
18:22:24 <tkahn6> why does Data.ByteString.Char8 define a'map' function
18:22:46 <kmc> so you can apply a function to every byte?
18:22:59 <heatsink> delicious functions in every byte!
18:23:07 <heatsink> sorry
18:23:19 <kmc> om nom nom
18:23:20 <tkahn6> haha
18:23:28 <tkahn6> hmmm
18:24:14 <tkahn6> ah ok
18:24:29 * nejucomo wonders why there isn't a Mappable class, rather than separate map functions.  Is this for performance reasons?
18:24:38 <copumpkin> Functor
18:24:42 <kmc> nejucomo, there is a Mappable class.  it's named Functor
18:24:47 <kmc> however, it's for polymorphic containers specifically
18:25:05 <kmc> to extend it to things like ByteString which only contain one type of value would significantly complicate the types
18:25:08 <djahandarie> :t map
18:25:09 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:25:16 <kmc> :t fmap
18:25:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:25:29 <djahandarie> And [] has a Functor instance
18:25:36 <kmc> > fmap succ [2,7]
18:25:37 <lambdabot>   [3,8]
18:25:38 <tkahn6> yeah map = fmap
18:25:41 <kmc> > fmap succ (Just 3)
18:25:42 <lambdabot>   Just 4
18:26:02 <nejucomo> So what are the trade-offs between Data.ByteString.Char8.map and fmap on a bytestring?
18:26:10 <kmc> you can't use fmap on a bytestring
18:26:17 <kmc> because it's not a polymorphic container
18:26:23 <kmc> and thus not an instance of Functor
18:26:38 <kmc> it's not (Bytestring Char) or (Bytestring Bool) or (Bytestring (Int -> Bool))
18:26:48 <kmc> it's just ByteString, and the contents are always Char
18:26:58 <kmc> @src Functor
18:26:59 <lambdabot> class  Functor f  where
18:26:59 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:27:06 <kmc> ^^^ that type doesn't make sense for a non-polymorphic container
18:27:07 <nejucomo> Hm.  I don't quite grok.  Why can't I declare "instance Functor ByteString where fmap f a b = map f a b" ?
18:27:15 <nejucomo> kmc: Ah, thanks.
18:27:21 <nejucomo> I see.
18:27:32 <kmc> the technical term is a "kind error"
18:27:44 <kmc> kinds classify type constructors as to the kinds of types they take
18:27:51 <kmc> just as types classify functions according to their arguments
18:27:53 <kmc> :k Int
18:27:54 <lambdabot> *
18:27:55 <kmc> :k Maybe
18:27:56 <lambdabot> * -> *
18:27:58 <kmc> :k Either
18:27:59 <lambdabot> * -> * -> *
18:28:16 <nejucomo> Hm.  Kinds have so far been mysterious to me.
18:28:18 <kmc> and so instances of Functor must have kind (* -> *).  you can tell by the way 'f' is used in the sig for 'fmap'
18:28:21 <nejucomo> :t Either
18:28:22 <lambdabot> Not in scope: data constructor `Either'
18:28:26 <Wooga> what is runReaderT/runErrorT/runIdentify analog for IO monad ?
18:28:30 <nejucomo> :t Left
18:28:30 <copumpkin> nejucomo: kinds are the types of types!
18:28:31 <lambdabot> forall a b. a -> Either a b
18:28:32 <kmc> Wooga, there is none
18:28:39 <kmc> Wooga, the closest would be unsafePerformIO, but it's... unsafe
18:28:52 <nejucomo> Are kinds always "*" or "* -> *" ?
18:28:54 <copumpkin> and doesn't behave the same as runIO might, if you idealize it :)
18:29:07 <copumpkin> nejucomo: there can be arbitrary functions between *
18:29:13 <kmc> nejucomo, every kind is either * or "k₁ -> k₂" for kinds k₁, k₂
18:29:16 <copumpkin> and there are a few other kinds, but they aren't too useful
18:29:24 <copumpkin> omg subscripts
18:29:28 <kmc> if t has kind *, then t is an actual type, that is, a type which has values
18:29:43 <kmc> sometimes we conflate the terms "type" and "type constructor" but it's most correct to reserve "type" only for things of kind *
18:29:45 <nejucomo> :i Functor
18:29:53 <nejucomo> :t Functor
18:29:54 <lambdabot> Not in scope: data constructor `Functor'
18:29:59 <kmc> @src Functor
18:30:00 <lambdabot> class  Functor f  where
18:30:00 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:30:11 <nejucomo> Thanks.
18:30:15 <kmc> then, -> is used to write the kinds of type constructors
18:30:21 <kmc> so e.g. Maybe has kind * -> *
18:30:26 <nejucomo> How do I ask the bot if a type is an instance of a class?
18:30:27 <kmc> because it takes a type and returns a type
18:30:31 <kmc> @instances Functor
18:30:32 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:30:45 <nejucomo> :k Maybe
18:30:45 <kmc> for a more complicated kind, look at StateT
18:30:46 <lambdabot> * -> *
18:30:47 <kmc> :k StateT
18:30:49 <lambdabot> * -> (* -> *) -> * -> *
18:31:11 <nejucomo> How do I know "f a" is of kind "* -> *" ?  Is this true of all two-term types?
18:31:34 <kmc> nejucomo, it's inferred from the signature on fmap
18:31:35 <kmc> :t fmap
18:31:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:31:42 <kmc> so, first off, look at (a -> b)
18:31:46 <kmc> :k (->)
18:31:47 <lambdabot> ?? -> ? -> *
18:31:59 <kmc> ^^^^ this is best read as «* -> * -> *», ignoring some GHC internals
18:32:05 <kmc> which i can explain later
18:32:16 <kmc> so since (->) :: * -> * -> *, we know immediately that a, b :: *
18:32:18 <kmc> makes sense so far?
18:32:37 <nejucomo> Not yet.
18:33:21 <nejucomo> So, does that imply that the kind of "f a" is "*" ?
18:33:25 <kmc> not yet
18:33:27 <nejucomo> It follows an "->"
18:33:33 <kmc> but yes, that's true
18:33:35 <kmc> i hadn't got there yet
18:33:41 <nejucomo> Oh, okay, continue.
18:33:51 <kmc> from the above reasoning we know that a and b both have kind *
18:33:52 <nejucomo> Thanks for the lesson, btw.  :-)
18:33:58 <kmc> no problem :)
18:34:08 <kmc> and from similar reasoning you just made, we know that «f a» and «f b» also have kind *
18:34:27 <kmc> so if «a :: *» and «f a :: *», what's the kind of f?
18:34:54 <nejucomo> * -> *
18:34:57 <kmc> right
18:35:13 <kmc> and that's all there is to it
18:35:19 <kmc> kind inference is pretty simple, compared to type inference
18:35:25 * nejucomo feels the centers for abstract thought in his brain tingling.
18:35:29 <kmc> because there is no abstraction, application, or polymorphism on kinds
18:35:44 <kmc> i hear rumors that UHC supports kind polymorphism
18:35:49 * nejucomo has an intuitive feel for type inference, but does not yet understand it algorithmically.
18:36:24 <kmc> mm
18:36:32 <dolio> They're not just rumors.
18:36:35 <nejucomo> Right, so I don't quite yet understand why there is no kind polymorphism…  But I'll save that for a later lesson.  Gotta run.  ;-)
18:36:44 <kmc> it's a pretty tricky algorithm, if you want to check Haskell 98 in full
18:36:51 <kmc> the paper "typing haskell in haskell" would be a place to start
18:36:57 <kmc> inference for simply-typed lambda calculus is not so tricky
18:37:14 <copumpkin> inference for dependently typed LC!
18:37:15 <copumpkin> mmm
18:37:18 <nejucomo> Thanks for the reference.
18:37:31 <kmc> you basically write a type checker, but instead of requiring things are equal, you make up new variables for each and then remember an equation that says the variables are equal
18:37:47 <kmc> then, you run all your equations through an algorithm called "unification", which is pretty simple and general (useful outside type inference)
18:37:58 <dolio> Lacking kind polymorphism isn't really that big a deal most of the time.
18:38:12 <nejucomo> :t map
18:38:13 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:38:19 <dolio> Although it's annoying when one of the cases comes up.
18:38:23 <nejucomo> :k []
18:38:24 <lambdabot> * -> *
18:38:34 <nejucomo> :t fmap
18:38:35 <djahandarie> A guy I met at the Bay Area meet up was going to some Haskell course thing at Utrecht
18:38:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:39:28 <nejucomo> So fmap on a list is functionally equivalent to map?  The latter is just a specialized fmap on lists?
18:39:35 <kmc> yes
18:39:42 <nejucomo> And the only reason is for performance?
18:39:48 <kmc> not even
18:39:50 <bss03> fmap (+3) [2,4,6]
18:39:53 <bss03> > fmap (+3) [2,4,6]
18:39:54 <lambdabot>   [5,7,9]
18:39:56 <kmc> in cases where it knows f = [] statically, it should be able to optimize
18:40:00 <nejucomo> (-or perhaps historical legacy?)
18:40:04 <tkahn6> you should read Typeclassopedia
18:40:08 <dolio> The reason is less scary compiler errors for n00bs.
18:40:10 <kmc> and for giving simpler error messages for beginners
18:40:27 <kmc> you can get by pretty well if you hide Prelude.map and then set map = fmap
18:40:39 <nejucomo> Crazy.  Good to know.
18:40:45 <djahandarie> Also replace (++) with mappend
18:40:45 <bss03> > fmap (+3) (Data.Map.fromList [("one", 2), ("three", 4), ("five", 6)])
18:40:45 <Martty> hm.. im gonna do my C assignments in haskell and hand in the C output ghc produces
18:40:46 <lambdabot>   Not in scope: `Data.Map.fromList'
18:40:47 <djahandarie> That makes life so much easier
18:40:48 <wli> Another Haskell 98 "wart"
18:41:11 <nejucomo> So, along with the type system (which I can get by on), I have a generally murky understanding of performance because I don't understand the runtime very well.
18:41:12 <bss03> @hoogle fromList
18:41:13 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
18:41:13 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
18:41:14 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
18:41:37 <djahandarie> Everyone except a couple people have a murky understanding of Haskell performance
18:41:42 <nejucomo> hehe...
18:41:53 <nejucomo> Luckily I work with someone I believe can teach me a fair bit about that.
18:41:58 <djahandarie> dons? :P
18:42:14 <djahandarie> Or do you work at Microsoft research
18:42:14 <kmc> hahaha Martty
18:42:25 <nejucomo> Nope, Linden Lab.
18:42:30 <FunctorSalad_> djahandarie: yeah, and I catch myself speculating instead of running a freaking benchmark not rarely
18:42:40 <kmc> i am sure your instructor will love C code with no indentation where every variable has type "W_" and function calls are made by returning a function pointer
18:42:46 <FunctorSalad_> (hmm that's borderline invalid english isn't it? trailing 'not rarely')
18:42:56 <djahandarie> Oh, Linden Lab, neat
18:42:59 <kmc> FunctorSalad_, i'd say unusual rather than invalid
18:43:15 <djahandarie> I don't know any Haskell performance gurus that work there
18:43:15 <Martty> kmc: he will hate it even more when it compiles and works fine
18:43:20 <nejucomo> Gotta run.  Thanks again.
18:43:24 <FunctorSalad_> I didn't want to mess with the existing sentence, that is very bug-prone
18:43:26 <kmc> hehe
18:43:33 <kmc> you'll include the whole RTS in your .c file as well?
18:43:36 <dolio> Clearly it should be "unrarely".
18:44:14 <Martty> kmc: if i must 
18:45:15 <djahandarie> I really hope I manage to go to the next Boston Haskell meeting
18:45:26 <kmc> i hope so too :)
18:45:27 <FunctorSalad_> . o O ( performance mysticism )
18:45:32 <kmc> i'll be giving a talk on..... ?
18:45:42 <kmc> need suggestions
18:45:52 <dolio> No one suggested anything good earlier?
18:45:59 <djahandarie> Go over some black magic GHC internals
18:46:02 <kmc> did i miss it?
18:46:18 <kmc> djahandarie, i'm still a noob at that, but considering it
18:46:21 <dolio> Well, I just remember you asking earlier. I probably got distracted after that.
18:46:28 <kmc> i don't know GHC API at all, or the compilery bits
18:46:48 <kmc> i know RTS guts somewhat
18:46:49 <djahandarie> Specifically the ones that tend to float up to you when trying to get something done
18:46:53 <kmc> i know how to debug RTS segfaults ;P
18:47:06 <FunctorSalad_> the GHC API is.... gigantic
18:47:07 <lispy_> kmc: gdb?
18:47:22 <djahandarie> I haven't even bothered trying to poke the GHC codebase
18:47:30 <FunctorSalad_> (that's not criticism :))
18:47:31 <djahandarie> Still have stuff left to learn elsewhere :P
18:48:10 <kmc> lispy, yeah, plus various tricks to get breakpoints and other info without slowing it down too much
18:48:22 <kmc> and gdb macros for inspecting the heap/stack which are on the ghc dev wiki somewhere
18:49:26 <Gracenotes> FunctorSalad_: book deal opportunity!
18:50:07 <Gracenotes> GHC Hacking with FunctorSalad
18:50:09 <dolio> Call it, The GHC API for Scientists.
18:50:26 <dolio> Cash in on the naming scheme.
18:50:32 <Gracenotes> (disclaimer: entire sections of this book may be obsoleted by major version changes)
18:50:40 <kmc> Teach Yourself GHC API In 24 Hours
18:50:42 <copumpkin> By sitting duck productions?
18:50:51 <dolio> Minor version changes, you mean?
18:50:51 <kmc> Gracenotes, just like that book i bought on Linux 2.4 :)
18:50:58 <dolio> GHC hasn't changed major versions in a long time.
18:51:01 <kmc> hmm, yeah, when will GHC 7 be released?
18:51:16 <kmc> i like knuth's model of converging version number
18:51:21 <djahandarie> lispy, I'm still having crazy lag on hackage.haskell.org. When I hit abbot.galois.com:80 directly it works fine, but via hackage.haskell.org it lags... which makes me really wonder how it could be a problem on my side
18:51:31 <kmc> it more accurately reflects non-research software, though GHC is definitely still research software
18:51:34 <djahandarie> I suppose I could start monitoring my network traffic
18:51:35 <FunctorSalad_> Gracenotes: I didn't mean to imply I know any of it beyond the surface
18:51:40 <dolio> I'm not even sure what triggered the last major version change.
18:51:47 <lispy> djahandarie: was there a DNS switch over?
18:52:01 <FunctorSalad_> (the very surface, mostly just the GHC module)
18:52:02 <lispy> djahandarie: if so, it could be timing out somehow?
18:52:03 <copumpkin> dolio: I was told it was ghci
18:52:04 <Gracenotes> I've comprehended the types for the various intermediate representations but that's about it
18:52:09 <djahandarie> Recently? It's been like this for months
18:52:12 <kmc> http://www.haskell.org/ghc/docs/6.0/html/users_guide/release-6-0.html
18:52:22 <lispy> djahandarie: ah.  sorry I didn't realize that
18:52:28 <djahandarie> No problem
18:52:28 <FunctorSalad_> teach yourself programming in 10 years...
18:52:40 <Gracenotes> right, though, GHC uses "real"major version conventions, not PVP conventions
18:52:41 <djahandarie> I'm not entirely sure if the same happens from elsewhere in the state
18:52:42 <FunctorSalad_> (not my idea)
18:52:47 <djahandarie> I'll double check when I go to work tomorrow
18:52:50 <dolio> copumpkin: Ah. That'd be notable, I guess.
18:52:57 <FunctorSalad_> player versus player?
18:53:20 <lispy> kmc: how do you efficiently set a breakpoint?
18:53:24 <copumpkin> dolio: maybe not actually, as in that 6.0 release notes they talk about ghci as if people already know about it
18:53:56 <dolio> I don't know. I got in around 6.2 or 6.4, and ghci was quite new at that point, I think.
18:54:24 <dolio> To the point that it was considered significantly inferior to Hugs.
18:54:33 <kmc> lispy, i inserted a counter and a conditional into the code
18:54:34 <copumpkin> ah
18:54:38 <kmc> and then a breakpoint on the conditional
18:54:58 <kmc> and that was much faster to get the nth crossing of that code
18:55:10 <dolio> I may still have code that uses Data.FiniteMap somehwere, too.
18:56:03 <lispy> kmc: ah, instead of creating a conditional breakpoint?
18:57:48 <kmc> yeah
18:58:37 <kmc> ghci was new in 5.00
18:58:56 <dolio> Ah, oh well.
18:59:00 <copumpkin> oh
18:59:13 <copumpkin> maybe the multithreaded stuff was introduced with 6?
18:59:16 <copumpkin> otherwise, no clue :)
18:59:27 <kmc> copumpkin, it says the threaded RTS is more robust but still experimental in 6.00
18:59:28 <copumpkin> no, I guess not that either
18:59:35 <lispy> didn't 6 coincide with a rewrite of the RTS?
18:59:52 <kmc> 5.00 added ghci, --make, ghc-pkg, unicode Char, FFI, hsc2hs, fundeps, etc.
19:00:03 <lispy> I thought that's the way SimonM characterized the version # bumps.  new RTS = new major number
19:00:47 <lispy> at least, I understood it as decoupled from features.  But, certainly a new RTS can mean lots of new features
19:02:21 <etpace> > let q f x = f (f x); r = (q q) (q q) in r (*2) 1
19:02:23 <lambdabot>   115792089237316195423570985008687907853269984665640564039457584007913129639...
19:02:47 <etpace> > let q f x = f (f x); r = (q q) (q q) in length $ (:1) []
19:02:48 <lambdabot>   No instance for (GHC.Num.Num [[a]])
19:02:49 <lambdabot>    arising from the literal `1' at <int...
19:03:08 <etpace> > let q f x = f (f x); r = (q q) (q q) in length $ r (:1) []
19:03:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
19:03:15 <etpace> ;s
19:03:39 <etpace> > let q f x = f (f x); r = (q q) (q q) in length $ r (1:) []
19:03:40 <lambdabot>   256
19:04:30 <lispy> last night I agreed that an infinite type of the form a = (b, a), is just a list of b's.  But, what would a = [a], correspond to?
19:04:46 <monochrom> a list of lists?
19:05:20 <kmc> it's an infinite stream of b
19:05:33 <dolio> a = [a] is like non-well-founded ZF sets.
19:05:48 <copumpkin> lispy: Mu []?
19:05:49 <kmc> «a = Maybe (b,a)» is isomorphic to []
19:05:49 <lispy> hmm
19:06:04 <kmc> «Mu []» is unlabeled trees
19:06:06 <copumpkin> lispy: meaning, trees with no data
19:06:06 <dolio> Only they're ordered bags, of course.
19:06:11 <lispy> kmc: or a = (b, Maybe a)
19:06:26 <lispy> kmc: right?  Because you stop on a Nothing?
19:06:26 <kmc> lispy, that's non-empty lists
19:06:32 <copumpkin> 1 + b * a =/= b * (1 + a)
19:06:33 <kmc> can't represent []
19:06:35 <lispy> ah
19:06:47 <dibblego> there is a NonEmpty list on hackage
19:07:43 <lispy> dolio: What is a non-well-founded set?
19:08:07 <dolio> Normal ZF sets are like trees of finite depth.
19:08:11 <monochrom> example: a={a}
19:08:12 <dolio> That's well-founded.
19:08:14 <lispy> I saw a talk by emertens about well-founded recursion, but I forgot what it means
19:08:38 <bss03> dolio: A non-well-founded set must have non-finite depth.
19:08:43 <bss03> Right?
19:08:45 <copumpkin> it means you have a base case
19:08:51 <dolio> Not necessarily.
19:09:00 <dolio> It just means that it may not have finite depth.
19:09:32 <kmc> i thought the idea of non-well-founded set theory was x ∈ x
19:09:36 <kmc> could be wrong
19:09:42 <bss03> So, there's not Least Upper Bound on the depth of member sets?
19:09:57 <dolio> I suppose if you take all sets in a non-well-founded set theory, and remove the ones that are well-founded, the remainder would have infinite depth.
19:10:27 <dolio> x \in x would be a possibility, certainly.
19:10:40 <FunctorSalad_> (or longer cycles)
19:10:53 <dolio> You could also have infinitely nested chains of non-equal sets.
19:11:16 <lispy> oh I see.
19:11:20 <lispy> No base case again
19:11:38 <lispy> That's interesting
19:12:12 <dolio> If you just take lists as an example, the well-founded (inductive) version would be finite lists.
19:12:26 <dolio> The non-well-founded (coinductive) version would be potentially infinite lists.
19:12:30 <lispy> So, then could we say that some infinite types are well-founded and others are not?  a = Maybe (b, a) vs. a = [a] ?
19:13:32 <FunctorSalad_> hmm in which sense is the maybe better?
19:14:36 <lispy> FunctorSalad_: there is some sense in which a = Maybe (b, a) is equivalent to [b]
19:14:40 <kmc> they both have terms of infinite depth
19:14:54 <dolio> Whether you get non-well-founded trees out of a = [a] depends on whether the fixed point in question is Mu [] or Nu [].
19:15:02 <kmc> but «µa. Maybe (b,a)» is not equivalent to «µb. [b]»
19:15:04 <FunctorSalad_> lispy: mu a, Maybe (b,a)
19:15:06 <kmc> they don't even have the same kind
19:15:13 <FunctorSalad_> (=[b])
19:15:14 <dolio> In Haskell, everything is potentially infinite, though.
19:15:23 <kmc> «µb. µa. Maybe (b,a)» ?
19:15:53 <lispy> I'm sorry but Mu/Nu are not familiar to me.  I know them only as greek letters
19:15:57 <kmc> @src Mu
19:15:58 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
19:16:13 <lispy> so, Mu is the fixed point of f?
19:16:20 <lispy> Well, Mu f, is
19:16:23 <kmc> yes
19:16:34 <copumpkin> Nu is another one, but you can't distinguish them in haskell
19:16:44 <FunctorSalad_> least fixed point yeah, and nu the greatest, and in haskell for some reason I still don't know exactly they're equal
19:16:44 <copumpkin> in fact, it seems like haskell's fix should be called Nu
19:17:47 <lispy> ?src fi
19:17:48 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:17:51 <lispy> ?src fix
19:17:52 <lambdabot> fix f = let x = f x in x
19:17:55 <FunctorSalad_> lispy: there's a more concrete construction... you turn your equation into a function f(a)=Maybe(b,a)
19:18:05 <FunctorSalad_> and iterate it starting from ... Void iirc
19:18:10 <copumpkin> :k Mu Maybe
19:18:11 <lambdabot> *
19:18:12 <lispy> could it be the difference between that definition and the y combinator definition?
19:18:16 <dolio> copumpkin: Well, it has aspects of both. You get fold and unfold.
19:18:19 <Loopies> :t fix
19:18:19 <copumpkin> :t In Nothing
19:18:20 <lambdabot> forall a. (a -> a) -> a
19:18:20 <lambdabot> Mu Maybe
19:18:24 <dolio> If it were just Nu, you'd only get the latter.
19:18:25 <Loopies> :t fix In
19:18:26 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
19:18:26 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `f :: * -> *'
19:18:26 <lambdabot>       Expected type: f (Mu f)
19:18:32 <copumpkin> dolio: fair enough
19:18:43 <syntaxglitch> Mu is the new Nu
19:18:48 <copumpkin> > In (Just (In Nothing)) -- 1!
19:18:49 <lambdabot>   No instance for (GHC.Show.Show (L.Mu Data.Maybe.Maybe))
19:18:49 <Loopies> :t fix (const cake)
19:18:49 <lambdabot>    arising from a u...
19:18:50 <lambdabot> [[Char]]
19:18:55 <FunctorSalad_> (and there's even some way to make sense out of 'taking the limit' of that iteration \o/)
19:19:09 <Loopies> > Out (In (Just 1))
19:19:10 <lambdabot>   Not in scope: data constructor `Out'
19:19:28 <FunctorSalad_> (you somehow get embeddings from X to f(X) and take the colimit for the family of these things, iirc)
19:19:30 <Loopies> :k In
19:19:31 <lambdabot> Not in scope: type constructor or class `In'
19:19:37 <kmc> :k Mu
19:19:38 <lambdabot> (* -> *) -> *
19:19:40 <kmc> :t fix
19:19:41 <lambdabot> forall a. (a -> a) -> a
19:19:56 <Loopies> :t In
19:19:57 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
19:19:58 <lispy> where did you guys learn about coinduction?
19:20:14 <kmc> :t In Maybe
19:20:14 <Loopies> :t UnIn
19:20:15 <lambdabot> Not in scope: data constructor `UnIn'
19:20:15 <lambdabot> Not in scope: data constructor `Maybe'
19:20:22 <kmc> :k In Maybe
19:20:24 <lambdabot> Not in scope: type constructor or class `In'
19:20:27 <FunctorSalad_> lispy: hmm I didn't, but co*limits* are taught in CT ;)
19:20:29 <kmc> :t In Nothing
19:20:30 <Loopies> :t In (\f n-> n+1)
19:20:30 <lambdabot> Mu Maybe
19:20:31 <lambdabot>     The lambda expression `\ f n -> n + 1' has two arguments,
19:20:31 <lispy> coinduction, colimits, codata, etc.  Did I miss the co-bus one day?
19:20:31 <lambdabot>     but its type `t -> Mu ((->) t)' has only one
19:20:31 <lambdabot>     In the first argument of `In', namely `(\ f n -> n + 1)'
19:20:46 <syntaxglitch> lispy, the same place we learned about induction, except backwards
19:20:49 <djahandarie> copumpkins?
19:20:53 * Loopies doesn't get it
19:20:53 <FunctorSalad_> the other coitems I just know from here
19:20:54 <tolkad> all you haskell people just make up these words
19:21:02 <kmc> all words are made up
19:21:15 <Loopies> the words are a lie
19:21:24 <syntaxglitch> on the other hand, cowords are made down
19:21:31 <lispy> tolkad: did you use to use the nick soupdragon?
19:21:35 <FunctorSalad_> (and more broadly the type theory world)
19:21:40 <ddarius> Inductive types are (usually) colimits, coinductive types are limits.
19:21:42 <tolkad> lispy: I'm kidding
19:21:50 <tolkad> lispy: and no
19:21:57 <lispy> tolkad: ah, okay.  Just curious.
19:22:01 <djahandarie> soupdragon is always on the fax account
19:22:06 <djahandarie> Regardless of nick
19:22:12 <ddarius> And soupdragon has significantly different behavior.
19:22:20 <ddarius> djahandarie: You've been around too little.
19:22:25 <kmc> anyway there is a huge and silly argument about whether using names from maths is reasonable or a good idea and whether it prevents Haskell from being popular and whether we should care etc
19:22:29 <djahandarie> That is probably true
19:22:32 <copumpkin> soupdragon still hangs out on other channels :)
19:23:03 <dolio> FunctorSalad_: Taking the omega-colimit of a diagram of increasingly nested fs is a way to construct the relevant fixed points in, say, Set.
19:23:07 <djahandarie> kmc, it's a good idea, some of the time. ;)
19:23:09 <kmc> i don't think the names are a big barrier for anyone who's seriously trying to learn
19:23:22 <kmc> i think they're a barrier for people who look at haskell for three minutes and then look for an excuse to quit
19:23:40 * syntaxglitch sometimes suspects that the mathy names are a good thing because they keep out the people who are afraid of thinking
19:23:44 <dolio> In something like Haskell, or Agda, it's more like the initial algebras exist by fiat.
19:23:48 <ddarius> syntaxglitch: If only.
19:23:49 <FunctorSalad_> dolio: I've seen the construction I mentioned in some domain category, and it's there that you miraculously get the isomorphism to the limit =)
19:23:56 <djahandarie> kmc, that argument could be used for any amount of difficulty in any form...
19:23:59 <copumpkin> omega-coliits!
19:24:01 <copumpkin> limits
19:24:12 <ddarius> dolio: Yes, but you can show that they are equivalent to an omega-colimit.
19:24:13 <copumpkin> man, I thought I'd started to understand all the mathy stuff people throw around here
19:24:17 <kmc> djahandarie, yes, but it would be wrong for some
19:24:30 <kmc> djahandarie, i'm saying it's a small barrier.  it's a quantitative, relative judgement
19:24:39 <FunctorSalad_> (the limit of the projections going downwards)
19:24:41 <ddarius> copumpkin: Omega-colimits are a special case of colimits.
19:24:52 <kmc> if only maths would drop these names, then maths would be more popular
19:25:08 <kmc> and maths journals would outcompete tabloids at the supermarket
19:25:09 <dolio> The omega-colimit stuff is (I assume) useful for denotational semantics, though.
19:25:11 <tolkad> kmc: word selection is based on balancing precision, conciseness, and well-known-ness
19:25:16 <FunctorSalad_> 'omega' just refers to the form of the diagram (infinite chain)
19:25:31 <FunctorSalad_> sounds scary but is actually a much more orderly case than arbitrary diagrams ;)
19:25:39 <tolkad> and it's kind of ironic I couldn't think of a word to use in place of well-known-ness
19:25:44 <djahandarie> I think a major problem is that when I see a word I don't know, I google it. And often googling some of the terms used in Haskell, you get a page describing a concept from category theory
19:25:47 <copumpkin> ddarius: special how?
19:25:54 <ddarius> copumpkin: FunctorSalad_ explained.
19:26:13 <syntaxglitch> tolkad, "ubiquity"?
19:26:14 <kmc> i think Mappable would be a sensible name for Functor.  but i can't think of a similarly good name for Monad; perhaps it's good that "Monad" has no preconceived association for most people
19:26:14 <copumpkin> oh ok
19:26:30 <ddarius> tolkad: FunctorSalad_ is not a native English speaker so...
19:26:42 <djahandarie> Someone needs to translate typeclassopedia into HTML format
19:26:44 <dolio> copumpkin: It's a diagram where the source category is the natural numbers, with the usual ordering as arrows..
19:26:48 <FunctorSalad_> ('infinite' was vague... I mean this one in particular: * -> * -> * -> ....)
19:26:50 * syntaxglitch loathes "*-able" names
19:27:00 <ddarius> kmc: We can go back to the original name: standard construction.
19:27:00 <FunctorSalad_> as opposed to something resembling a different ordinal
19:27:04 <copumpkin> aha
19:27:09 <kmc> how about 'triple'
19:27:23 <tolkad> syntaxglitch: interesting, I know that word but have never used it before
19:27:37 <kmc> djahandarie, aww, i like the pdf
19:27:50 <djahandarie> I like how it looks... that's about it
19:27:56 <FunctorSalad_> I must have missed my english failism
19:27:56 <kmc> i remember someone here or on reddit who had some principled objection to reading pdfs which i think just boiled down to anti-intellectualism
19:28:16 <djahandarie> I've argued about PDFs in here before
19:28:17 <kmc> but i've been accusing lots of people of anti-intellectualism lately ;P
19:28:18 <copumpkin> FunctorSalad_: SO FAIL YOU FAIL AT SEEING YOU FAIL!
19:28:18 <jmcarthur> i like pdfs
19:28:26 <copumpkin> FunctorSalad_: but I missed it too :)
19:28:27 <ddarius> kmc: So by "principled" you mean "unprincipled"
19:28:38 <kmc> ddarius, it's a principle, just a dumb one
19:28:41 <tolkad> kmc: I don't like pdfs because they are take longer to access than HTML pages
19:28:41 <kmc> dumb and socially harmful
19:28:54 <kmc> tolkad's reason is practical, not principled
19:28:58 <kmc> :)
19:29:58 <djahandarie> That's practically peripheral to the principle point of PDFs.
19:30:39 <FunctorSalad_> kmc: the python community? or was that someone else
19:30:50 <FunctorSalad_> I've been citing you on it already j/k
19:30:55 * ddarius thinks djahandarie wanted "principal."
19:30:57 * syntaxglitch has a principled objection to PDFs being used for things where exact printed-page layout isn't needed or relevant
19:31:30 <ddarius> syntaxglitch: When is exact print-page layout ever "needed" for original work?
19:31:45 <FunctorSalad_> heh I just noticed the duplication in 'fist principles'
19:31:48 <FunctorSalad_> *first
19:32:08 <syntaxglitch> ddarius, when formatting matters and there's a reasonable expectation of wanting a printed copy of something
19:32:09 <FunctorSalad_> (the word already derives from the latin word for 'first' iirc)
19:32:37 <FunctorSalad_> ('prince' is related too)
19:32:58 <tolkad> djahandarie: what? I interpreted that as "that is almost related to the main point of PDFs" although it could mean "that is in practice related to the main point of PDFS"
19:33:01 <ddarius> FunctorSalad_: It does, but "principle" doesn't really have that meaning while "principal" does to some extent.
19:33:16 <tolkad> yeah, it's obvious he meant principal
19:33:41 <ddarius> No, the saying is "first principles" not "first principals."
19:34:00 <ddarius> However, one could say a principal principle.
19:34:03 <tolkad> the "almost"/"in practice" ambiguity of "practically" is _really_ annoying
19:34:11 <FunctorSalad_> ddarius: yes, principal ideal is 'hauptideal' in german as an example... with 'haupt'=main which could be considered close enough to 'first' :)
19:34:31 <tolkad> the concepts are almost opposites of eachother
19:34:33 <FunctorSalad_> ddarius: I didn't mean to say that the words are interchangeable
19:34:48 <syntaxglitch> tolkad, I think you mean "they're practically opposites of each other"
19:34:53 <ddarius> I wouldn't consider "main" near "first."  My impression is that the same is true for Haupt in German.
19:35:02 <djahandarie> I was just trying to use words starting with 'p'.
19:35:12 <ddarius> djahandarie: And you almost got it.
19:35:19 <djahandarie> :P
19:35:27 <FunctorSalad_> 'first' as in 'first and foremost' (first rank in importance)
19:35:37 <ddarius> Ichiban
19:35:49 <tolkad> Ich bin
19:35:57 <djahandarie> How many languages do you know ddarius? :P
19:36:21 <ddarius> djahandarie: Less than I should.
19:37:25 <tolkad> yeah, I'm trying to learn more languages too. working on haskell right now
19:37:26 <copumpkin> he's fluent in over six million forms of communication
19:37:32 <copumpkin> or something like that
19:38:01 <FunctorSalad_> (but I agree this is just a specialization of 'first')
19:38:22 <FunctorSalad_> for particular order....
19:38:24 <FunctorSalad_> *a
19:39:57 <CakeProphet> what's the usual style for large import lists?
19:40:12 <CakeProphet> export not import
19:40:34 <CakeProphet> I can't decide if I want to switch to explicit lists or simply use implicit in most cases.
19:41:28 <FunctorSalad_> a workaround is to have a module with an implicit list import and not reexport an 'internals' module
19:42:36 <CakeProphet> FunctorSalad_:  fancy. I don't know enough about how Haskell finds modules to do that though. If you have M and M.Internals, where is that on the filesystem?
19:42:42 <monochrom> when the module grows large, I use an explicit export list because there are more haddock goodies
19:42:54 <FunctorSalad_> CakeProphet: M/Internals.hs
19:43:12 <FunctorSalad_> and M.hs as a sibling of M
19:43:15 <tolkad> can you pattern match for functions?
19:43:27 <monochrom> no, cannot pattern match for functions
19:43:29 <FunctorSalad_> monochrom: oh are there?
19:43:43 <tolkad> monochrom: can you do it anyway using classes?
19:44:42 <tolkad> well, I guess you could pattern match for function types
19:44:46 <tolkad> but not functions themselves
19:44:53 <monochrom> not sure what pattern matching for functions using classes means. but it is safe to just say no.
19:45:39 <tolkad> so I just have to make sure none of the functions in my program have the same type signature, thanks
19:45:41 <syntaxglitch> pattern matching on functions, good idea
19:45:50 <syntaxglitch> can I pattern match on _|_, too?
19:46:00 <CakeProphet> Can someone explain Dual? I just found it in some of my code but I can't remember what it does.
19:46:17 <monochrom> What is Dual?
19:46:24 <CakeProphet> type MudWriter = WriterT (Dual [Log String])
19:46:36 <syntaxglitch> a monoid instance with argument order swapped?
19:46:46 <CakeProphet> ah okay.
19:47:02 <syntaxglitch> assuming it's what I think it is, at any rate
19:47:04 <CakeProphet> oh okay. Now I remember that. :)
19:47:53 * syntaxglitch pushes his terrible little Haskell game up to github
19:49:25 <CakeProphet> how would I download and install fclabels using cabal?
19:50:29 <CakeProphet> cabal install isn't working. perhaps I need to update. I'll try again.
19:50:41 <CakeProphet> ah here we go.
19:51:19 <CakeProphet> transformers-0.2.1.0 failed during the final install step. The exception was:
19:51:20 <CakeProphet> exit: ExitFailure 1
19:52:03 <tkahn6> when cabal fails to install something, you're basically screwed
19:52:29 <CakeProphet> ah, could be a permission problem. I guess I'll try with sudo. I'm pretty pro at this. 
19:53:29 <CakeProphet> ah, but now there are compile errors in fclabels.
19:53:44 <CakeProphet> src/Data/Record/Label/TH.hs:29:29: Not in scope: type constructor or class `TyVarBndr'
19:54:02 <CakeProphet> I assume TH stands for template Haskell.
19:55:46 <tolkad> are the Lazy bytestring, and the normal bytestring the same type?
19:55:57 <copumpkin> nope, but they have all the same functions on them
19:56:11 <tolkad> type compatability is really annoying... it is never documented
19:56:57 <dons> tolkad: ?
19:57:21 <dons> there are functions that convert between the two types, but they're different data structures
19:57:25 <tolkad> dons: whether types within different modules with the same name are the same type
19:57:30 <tolkad> dons: it's never documented
19:57:42 <tolkad> well, almost never
19:57:44 <dons> "with the same name are the same type" -- but they have the same name?
19:57:55 <tolkad> but are in different modules
19:58:02 <dons> oh, you mean, are re-exported?
19:58:10 <tolkad> yeah
19:58:21 <dons> interesting.
19:58:24 <ddarius> @google barry jay pattern calculus
19:58:25 <lambdabot> http://www.amazon.com/Pattern-Calculus-Computing-Functions-Structures/dp/3540891846
19:58:48 <CakeProphet> is there something wrong with fclabels that makes it no compile?
19:58:52 <CakeProphet> *not
19:58:56 <orbitz> is there a nice way to do multiline string literals in Haskell?
19:59:14 <copumpkin> nope
19:59:23 <tolkad> orbitz: prefix every line with ++
19:59:23 <FunctorSalad_> CakeProphet: that error usually means the package needs to be adapted to the TH AST change in 6.12.something
19:59:28 <tolkad> orbitz: : )
19:59:28 <copumpkin> lol
19:59:30 <orbitz> travesty
19:59:39 <copumpkin> orbitz: THIS NEEDS A QUASIQUOTER, NOW
19:59:44 <ddarius> > "a\    \b"
19:59:45 <lambdabot>   "ab"
19:59:49 <ddarius> There are string gaps.
19:59:50 <orbitz> wait. NOW?!
19:59:53 <CakeProphet> FunctorSalad_:  ah, so basically my version of Haskell is too new for this package?
20:00:04 <FunctorSalad_> ('Forall's used to take a list of variables, now they take a list of TyVarBndrs which may or may not be kinded)
20:00:06 <tolkad> > "a\\\\\\\\ \\ \\ \ \\\ \\\\\\ \ \\\ \\ \ \ \ b"
20:00:06 <lambdabot>   <no location info>:
20:00:06 <lambdabot>      lexical error in string/character literal at chara...
20:00:08 <orbitz> ddarius: nasty
20:00:14 <ddarius> orbitz: Yep.
20:00:17 <tolkad> > "a\\\\\\\\ \\ \\ \ \\\ \\\\\\ \ \\\ \\ \ \ \ \b"
20:00:18 <lambdabot>   "a\\\\\\\\ \\ \\ \\ \\\\\\ \\ \\  b"
20:00:28 <copumpkin> > fix show
20:00:29 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
20:00:42 <FunctorSalad_> CakeProphet: yeah... the fix is simple but annoying though
20:00:44 <tolkad> > fix fix
20:00:45 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
20:00:47 <ddarius> copumpkin: A multiline string quasiquoter exists.
20:00:47 <tolkad> :t fix fix
20:00:48 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
20:00:49 <lambdabot>     Probable cause: `fix' is applied to too many arguments
20:00:49 <lambdabot>     In the first argument of `fix', namely `fix'
20:00:53 <orbitz> a """ like Python would be nice (I'm looking at CouchDB and you have to put all this java script code someplace, it's ooogly)
20:00:57 <copumpkin> ddarius: ah, where?
20:00:59 <tkahn6> :t fix
20:01:01 <lambdabot> forall a. (a -> a) -> a
20:01:06 <ddarius> copumpkin: That is the question.
20:01:09 <copumpkin> lol
20:01:13 <FunctorSalad_> copumpkin: uh it's a oneliner isn't it
20:01:17 <FunctorSalad_> let me search
20:01:19 <copumpkin> not a very constructive existential, ddarius 
20:01:21 <tolkad> :t fix.fix
20:01:22 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
20:01:30 <copumpkin> :)
20:01:38 <jmcarthur> dons: if i've been twiddling my thumbs for a week, does that mean galois doesn't like my resume? :)
20:01:45 <copumpkin> maybe a lazy constructive existential?
20:01:50 * djahandarie thinks of uses for fix.fix
20:02:09 <FunctorSalad_> copumpkin: here = QuasiQuoter qe qp where qp :: String -> Q Pat qp = return . LitP . StringL qe :: String -> Q Exp qe = return . LitE . StringL 
20:02:21 <FunctorSalad_> including type sigs and support for patterns even :O
20:02:24 <CakeProphet> FunctorSalad_:  what do you recommend I do? I'd very much like to have the fclabels package. If it's very simple I could fix it, but I don't know if it's worth it.
20:02:29 <copumpkin> orbitz: take FunctorSalad_ 's QQ :)
20:02:39 <tolkad> :t show.show
20:02:40 <lambdabot> forall a. (Show a) => a -> String
20:02:56 <tolkad> :t fix (.)
20:02:57 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
20:02:57 <lambdabot>       Expected type: a
20:02:57 <lambdabot>       Inferred type: f a
20:02:58 <FunctorSalad_> minimal version: QuasiQuoter (return . LitE . StringL) undefined
20:03:03 <orbitz> How does oen use it?
20:03:09 <tolkad> :t (.fix)
20:03:10 <lambdabot> forall a b. (a -> b) -> (a -> a) -> b
20:03:12 <FunctorSalad_> sorry, I was overeager in killing linebreaks there ;)
20:03:25 <FunctorSalad_> [here$| blah |]
20:03:25 <tolkad> :t (.fix) (.)
20:03:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => ((a -> b) -> a -> b) -> f a -> f b
20:03:30 <FunctorSalad_> @orbitz
20:03:31 <lambdabot> Unknown command, try @list
20:03:47 <tolkad> :t ((.).fix).((.).fix)
20:03:48 <lambdabot> forall a (f :: * -> *) b. (Functor f) => ((b -> b) -> b -> b) -> f a -> f b
20:03:52 <orbitz> quasiquote, multiline, line breaks, I don't understand yoru technobabble
20:03:56 <tolkad> :t ((.).fix).((.).fix).((.).fix).((.).fix).((.).fix).((.).fix).((.).fix)
20:03:57 <lambdabot> forall a (f :: * -> *) b. (Functor f) => ((b -> b) -> b -> b) -> f a -> f b
20:04:00 <tolkad> : )
20:04:19 <FunctorSalad_> (the second field of QuasiQuoter is for pattern quasiquotations, I think you can leave it undefined, not sure)
20:04:42 <FunctorSalad_> or just put 'return . LitP . stringL' in ;)
20:05:25 <FunctorSalad_> orbitz: the definition of 'here' needs to be in a seperate module and you need -XQuasiQuotes in the using module
20:05:37 <tolkad> :t (++).show
20:05:38 <lambdabot> forall a. (Show a) => a -> String -> String
20:05:39 <orbitz> ok
20:06:14 <tolkad> :t (++(show)).show
20:06:15 <lambdabot>     Couldn't match expected type `a -> String'
20:06:16 <lambdabot>            against inferred type `[Char]'
20:06:16 <lambdabot>     Probable cause: `show' is applied to too many arguments
20:06:28 <erikc> so what's the deal with Habit, is there a habit compiler available?
20:06:44 <copumpkin> omg it's erikc 
20:06:54 <FunctorSalad_> orbitz: here is one with linebreaks ;) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29194#a29194
20:07:00 <tolkad> :t (\a->a.(++).show)
20:07:01 <lambdabot> forall b a. (Show a) => ((String -> String) -> b) -> a -> b
20:07:12 <syntaxglitch> :t fix . fmap fix . fix
20:07:14 <lambdabot> forall a. ((a -> a -> a) -> a -> a -> a) -> a
20:07:23 <erikc> im back to work on the ghc powerpc port!
20:07:30 <erikc> (i kid)
20:07:48 <tolkad> erikc: what? no powerpc support for ghc?
20:08:03 <tolkad> I want to run it on my 10 year old mac
20:08:37 <erikc> it's bitrotted
20:08:53 * p_l would rather run it on i Series
20:08:55 <CakeProphet> FunctorSalad_:  what would be the easiest way to switch to TH 2.5?
20:09:09 <p_l> (or was it System p? pSeries? I get lost)
20:10:06 <p_l> apparently the current name is System p
20:10:07 <erikc> pSeries is the conventional one (AIX/Linux on PowerPC), iSeries is the kooky one (i/OS on PowerPC), zSeries is the ancient one (z/OS on zArchitecture)
20:10:26 <FunctorSalad_> is there some cli hpaste tool that works?
20:10:32 <FunctorSalad_> (still) works
20:10:34 <p_l> erikc: apparently now it's System i and System p
20:10:38 <erikc> yea
20:10:53 <erikc> and zEnterprise
20:11:16 * p_l found it funny&interesting to connect CPUs with tapes, last time he installed a pSeries server
20:11:56 <CakeProphet>  cabal install template-haskell
20:11:57 <CakeProphet> Resolving dependencies...
20:11:57 <CakeProphet> cabal: cannot configure template-haskell-2.4.0.1. It requires base >=4.2 && <5
20:11:57 <CakeProphet> There is no available version of base that satisfies >=4.2 && <5
20:12:31 <luite> I think template-haskell should be included in your ghc installation
20:12:47 <CakeProphet> that's what I thought, but it seems as though I need a different version.
20:12:48 <FunctorSalad_> now hpaste seems down altogether
20:13:03 <FunctorSalad_> did I kill it by trying to use 'haste' and 'pastepipe' on it? o_o
20:13:20 <luite> if you need a different version, something is probably very broken somewhere :)
20:13:40 <CakeProphet> luite:  yes, the package I'm working with must have old dependencies I guess?
20:13:48 <CakeProphet> base (≥3 & <5), monads-fd (≥0.0 & <0.2), template-haskell (≥2.2 & <2.5)
20:14:11 <CakeProphet> slightly out of date dependencies?
20:14:19 <CakeProphet> I don't know the current versions of these things.
20:15:00 <FunctorSalad_> orbitz: anyway..... example use: http://pastebin.org/567135
20:15:01 <luite> my system has template-haskell-2.4.0.1, with ghc 6.12.2
20:15:09 <FunctorSalad_> where SP.TH is the module you put the definition of 'here in
20:15:14 <djahandarie> Is erikc some oldbie #haskell celebrity?
20:15:28 <CakeProphet> luite:  so maybe this package is just horribly broken.
20:15:30 <erikc> not really
20:16:08 <FunctorSalad_> CakeProphet: it is very simple, yes, you just need to ignore the kind signatures
20:16:10 <luite> CakeProphet: 2.2 <= 2.4.0.1 < 2.5
20:16:21 <FunctorSalad_> TH now supports binding type vars with kind sigs
20:16:32 <FunctorSalad_> so there's a new type for a var that may have a kind sig
20:16:37 <CakeProphet> oh, well... is it simple enough to explain the steps?
20:17:00 <FunctorSalad_> (this type is now where there used to be just Names (of the type vars))
20:17:08 <djahandarie> erikc, and as far as I know, there is no compiler... but I'm not at all involved with HASP so I'm not really an authoritative source
20:19:00 <CakeProphet> FunctorSalad_: I'm knew to both cabal and TH. Will I need to create my own build of this package or is it as simple as compiling with an option?
20:19:02 <Wooga> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.71.596
20:19:16 <Wooga> oh, sorry, wrong terminal to UP+Enter
20:19:36 <FunctorSalad_> CakeProphet: ah it's not *that* simple, I was talking about fixing the code to work with the new AST types
20:19:36 <mjk> i have install gtk2hs, load my code, it's ok. but when run it , it doesn't load cario
20:19:53 <mjk> always waiting
20:19:58 <FunctorSalad_> which might take a bit of understanding TH, yes
20:20:13 <CakeProphet> ah. so then custom build. eh, dunno if I'm interested in that. but I'd be slightly interested in helping the package owner to fix it.
20:20:40 <CakeProphet> ..it's such a handy package to pass up. :( 
20:20:54 <CakeProphet> it FIXES Haskell's records! I mean come on...
20:21:45 <erikc> djahandarie: ah, i read the galois slides, looks good on paper
20:21:59 <FunctorSalad_> @'own build', you'd just send the patch to the maintainer :)
20:22:00 <lambdabot> Maybe you meant: join wn yow
20:22:17 <erikc> ive done similar things in c++
20:22:25 <FunctorSalad_> preferrably against the HEAD or the source repository if you can find it
20:22:59 <CakeProphet> FunctorSalad_:  this is all new stuff for me, but I guess I can learn.
20:23:36 <CakeProphet> is a  patch just a tarball or a diff or...?
20:23:45 <FunctorSalad_> CakeProphet: it would require learning a bit about TH, I just meant it's simple in the sense that the new items in the TH AST are usually stuff you can ignore
20:23:47 <djahandarie> Yeah I happened to stumble on Habit awhile back, it looked neat
20:24:22 <FunctorSalad_> CakeProphet: if the source repo is darcs, you just do 'darcs send -o somefile' and mail the somefile to the maintainer
20:24:33 <FunctorSalad_> after recording your changes with 'darcs record'
20:25:57 <FunctorSalad_> another addition IIRC is that type family stuff in type constraints is now supported in TH 
20:26:52 <CakeProphet> I think this code only uses a few lines of TH so I can't imagine it would be a complicated fix
20:27:56 <FunctorSalad_> btw its git, not darcs
20:28:29 <CakeProphet> ah okay. so what would I do to make a patch with git?
20:28:32 <FunctorSalad_> CakeProphet: in fact, did you try the HEAD from the repo on github? maybe its fixed already
20:28:34 * CakeProphet has never patched anything, obviously.
20:29:02 <CakeProphet> FunctorSalad_:  I have no tried anything other than cabal install fclabels. I'll check it out though.
20:29:09 <FunctorSalad_> repo github.com/sebastiaanvisser/fclabels
20:29:37 <FunctorSalad_> CakeProphet: you'd just fetch the repo as described on github and 'cabal install' while in the directory
20:29:48 <CakeProphet> ah. okay.
20:29:59 <CakeProphet> that's fairly painless to try then. :)
20:30:07 <FunctorSalad_> (no args = use .cabal in current dir)
20:31:07 <CakeProphet> git fetch github.com/sebastiaanvisser/fclabels
20:31:08 <CakeProphet> fatal: Not a git repository (or any of the parent directories): .git
20:31:51 <FunctorSalad_> git://github.com/sebastiaanvisser/fclabels.git ?
20:32:09 <FunctorSalad_> the url I gave was for the www page :)
20:32:12 <CakeProphet> oh... okay. I've never used git either.
20:32:30 <CakeProphet> learning as I go. :)
20:32:38 <FunctorSalad_> I'm the wrong one to ask about git ;)
20:33:29 <tolkad> there's a git channel
20:33:29 <CakeProphet> I don't think there's a fclabels.git
20:33:33 <FunctorSalad_> (but the basic procedure is to get a github account, fork the repository, fetch your copy, do changes, push them to your fork on github, and click 'pull request')
20:33:40 <tolkad> try #git
20:35:07 <FunctorSalad_> CakeProphet: the git:// was copypasted from the webpage of the repo
20:36:57 <CakeProphet> I still get the same error when I try to fetch. 
20:37:40 <FunctorSalad_> it also has a http url, don't know if it makes any difference for 'git fetch' http://github.com/sebastiaanvisser/fclabels.git
20:38:14 <tensorpudding> isn't git fetch only for pulling from a repository when you have a local version?
20:38:39 <FunctorSalad_> oh, right. git clone?
20:38:42 <tensorpudding> git clone is used for initializing a local repository
20:38:58 <CakeProphet> ah. so similar to hg?
20:39:02 <tensorpudding> yes
20:39:12 <FunctorSalad_> sorry but like I said I fail at git too ;)
20:39:16 <tensorpudding> but don't trust hg and git having the same commands
20:39:32 <tensorpudding> git fetch and hg pull are roughly similar, as are hg fetch and git pull
20:39:49 <CakeProphet> awww yeah, making progress on this patching business.
20:41:13 <CakeProphet> cabal: Error: some packages failed to install:
20:41:13 <CakeProphet> fclabels-1.0.0 depends on monads-fd-0.0.0.1 which failed to install.
20:41:20 <CakeProphet> okay... but monads-fd is already installed....
20:43:11 <kmc> tensorpudding, that's hilarious and sad
20:43:35 <CakeProphet> Building monads-fd-0.0.0.1...
20:43:36 <CakeProphet> Control/Monad/Cont.hs:77:7:
20:43:36 <CakeProphet>     Could not find module `Control.Monad.Trans':
20:43:36 <CakeProphet>       it is a member of package monads-fd-0.1.0.1, which is hidden
20:43:47 <kmc> :psyduck:
20:43:50 <CakeProphet> ...ugh. I don't understand...
20:44:26 <kmc> was there a git question a sec ago?
20:44:32 <CakeProphet> sort of.
20:44:43 <tensorpudding> it's kinda funny
20:44:53 <CakeProphet> I'm using git right now, but I'm mostly asking questions about how to patch and how to get cabal to work with this package.
20:47:53 <CakeProphet> can you uninstall with cabal?
20:50:38 <Cale> CakeProphet: Unfortunately not. You can use ghc-pkg unregister to make ghc forget about a package, but it doesn't remove the associated files. You can find those under ~/.cabal though
20:50:50 <Cale> (assuming you installed to your home directory)
20:53:20 <CakeProphet> I don't understand the error I get when I try to install monads-fd
20:53:33 <CakeProphet> but ONLY when I install from this local package.
20:56:37 <CakeProphet> perhaps I'll give up with packages and just copypaste the code into modules. :P
20:56:41 <djahandarie> I want if<- and case<- in Haskell :(
20:57:11 <Axman6> yeah, i liked the look of that
21:00:46 <kmc> how'd they work?
21:01:30 <djahandarie> do d <- blah; if d then e1 else e2    is the same as if<- blah then e1 else e2
21:01:31 <djahandarie> I think
21:01:46 <djahandarie> Been awhile since I saw the thing, was just reminded of it
21:02:19 <squidsoup>  hey there, was hoping someone could lend a hand. I'm getting a dependancy error 
21:02:22 <squidsoup>                    for "time ==1.1.*" after running the bootstrapper for cabal-install-0.8.2. dkpg 
21:02:43 <kmc> djahandarie, oh, they're new do-statements?
21:02:49 <kmc> hmm
21:03:23 <djahandarie> Yeah I suppose. The do's are implicit inside of the if<- since it is monadic
21:05:01 <djahandarie> Also the case<- doesn't require the otherwise branch because it can just do a return ()
21:10:49 <tolkad> how do I do instanceof in haskell?
21:11:06 <guybrush> omg haskell is actually quite nice, how could i miss this like about 10years of coding
21:11:22 <dibblego> tolkad, pattern matching
21:11:30 <djahandarie> By being stuck in a corporate grind
21:11:36 <tolkad> dibblego: across multiple types?
21:11:48 <dibblego> tolkad, no on data constructors
21:12:14 <tolkad> dibblego: ... that's not the question I asked
21:12:15 <lowSodium> yes I was wondering why the sequencing method in the Monad typeclass forces us to provide an action as opposed to something like fmap with will lift a pure function for us
21:12:22 <dibblego> tolkad, it is actually :)
21:12:25 <tolkad> dibblego: I need to pattern match across multiple types
21:12:38 <tolkad> dibblego: all I know is that they are instances of the same class
21:12:43 <tolkad> dibblego: how do I do that?
21:12:52 <dibblego> tolkad, which programming language are you using?
21:13:04 <kmc> tolkad, don't ask questions of the form "how do i <thing from Java> in Haskell?"
21:13:07 <tolkad> dibblego: haskell! what kind of question is that?
21:13:11 <kmc> ask "how do i <problem i actually want to solve> in Haskell"
21:13:14 <tolkad> ok
21:13:21 <tolkad> how do I pattern match across multiple types
21:13:28 <kmc> instanceof does not translate well to Haskell's type system; Haskell has no subtyping at all
21:13:36 <dibblego> tolkad, to solve this problem, you use pattern matching on data constructors
21:13:46 <Esteth> Hey folks, I have a [Instruction], and a function (Instruction -> Mips ()). I'm having trouble wrangling my types so that I can run the list of commands as a sequence of actions in the Mips monad (it's a stateT)
21:13:48 <tolkad> dibblego: that doesn't work if I have multiple types
21:13:57 <kmc> tolkad, how would that work, a function's argument can't have multiple types
21:14:00 <dibblego> tolkad, please believe me, it always works
21:14:04 <kmc> unless it does so in a specific uniform way (polymorphism)
21:14:41 <tolkad> kmc: which is the problem, my function type is «C t => t -> String»
21:14:46 <kmc> right
21:14:51 <kmc> you can't pattern-match on which type t is
21:14:57 <kmc> you can only use the methods of the class C
21:14:57 <tolkad> but I need to know what type it is
21:15:01 <kmc> why do you?
21:15:13 <tolkad> because I want to do different things depending on what type it is
21:15:16 <kmc> why?
21:15:25 <kmc> perhaps those different things should be part of the class C?
21:15:36 <tolkad> 0_0
21:15:46 <tolkad> i'll be back
21:16:17 <dibblego> I apologise for contributing to this dilemma by teaching Java to people
21:16:52 <Esteth> Ah, simplifying my problem. Is there a function that turns a:b:c:d into a >>= b >>= c >>= d with a function to convert from the type in the list to the type in the new monad?
21:17:25 <dibblego> Esteth, foldM perhaps? or possibly (>=>) might be of interest to you
21:17:52 <Esteth> dibblego: Thanks, I'll take a look.
21:18:40 <Esteth> Actually, what's the type signiture for a function that takes two distinct monads?; Monad m, Monad n => ... ?
21:19:02 <Esteth> s/takes/involves/
21:19:03 <dibblego> (Monad m, Monad n) => rest...
21:19:13 <Esteth> Ah, it's the brackets I'm missing, thanks.
21:25:10 <tolkad> kmc: ooh, maybe I can use these existential type things
21:25:33 <Esteth> existential types give you a way to put multiple different types into a function by wrapping those types in a new type
21:25:56 <kmc> tolkad, why don't you describe your problem
21:25:59 <kmc> in problem-domain terms
21:26:27 <kmc> tolkad, existentials can be useful, but there are often simpler solutions
21:26:31 * Esteth agrees with kmc. This sounds like a problem that can be solved in a better way.
21:26:41 <kmc> such as a sum type: «data Foo = FooInt Int | FooBool Bool»
21:27:03 <kmc> there is a common tendency for beginners to attempt to emulate an OO class hierarchy using existentials and type classes and lots of types
21:27:09 <kmc> when a simple sum type would suffice
21:27:19 <dibblego> yes I have seen this too
21:27:45 <FunctorSalad_> hehe I've gone the opposite way (desperately trying to emulate sum types in OO langs)
21:27:46 <tolkad> kmc: a simple sum type would suffice but I would lose a tiny bit of type safety
21:27:51 <kmc> oh?
21:28:05 <CakeProphet> my solution to my issue with fclabeles: copypaste the two files that the package consists of. :)
21:28:09 <tolkad> kmc: maybe that's the way to go, I guess 20 + types in a module is a bad idea
21:28:15 <FunctorSalad_> putting the fold into the common superclass is an ok way to do it I guess
21:28:22 <kmc> FunctorSalad_, just use boost::variant.  several thousands of lines of C++ to get a sum type, with primitive pattern matching
21:28:29 <FunctorSalad_> lol
21:28:36 <FunctorSalad_> it was C# though
21:28:43 <dibblego> I've done that in C# too
21:28:47 <FunctorSalad_> which has closures, making the fold more viable
21:28:58 <tolkad> hmm, actually, I see a complex way to use something like existential types without the extension
21:29:09 <kmc> tolkad, if you would either tell us what you're doing or hpaste some code, we could better advise you
21:29:11 <dibblego> interface Maybe<A> { X Fold<X>(Func<X> nothing, Func<A, X> just); }
21:29:18 <FunctorSalad_> yeah
21:29:39 <kmc> as is, you're just saying "i will use this complicated thing" and we're saying "maybe you don't need the complicated thing"
21:29:41 <kmc> we have no specifics
21:30:27 <kmc> one thing which annoyed me a lot about some other IRC channels was the tendency to assume that the question-asker wants to do the complicated thing only because they're dumb or uninformed
21:30:35 <kmc> so, i'd like to avoid that by actually understanding your problem
21:30:56 <tolkad> thinking about how to describe it
21:32:21 <kmc> <tolkad> kmc: which is the problem, my function type is «C t => t -> String»
21:32:24 <kmc> <tolkad> because I want to do different things depending on what type it is
21:32:29 <kmc> this really makes me think
21:32:34 <kmc> that whatever function you're writing now
21:32:36 <kmc> or some component of it
21:32:41 <kmc> should be a method of the class C
21:33:59 <tolkad> here's a simple explanation, I have types A and B, some functions which take either A or B in other modules, and a socket from which I am parsing As and Bs
21:34:59 <tolkad> I want type safety when using As and Bs I created myself
21:35:15 <tolkad> but I don't want that type safety from As and Bs parsed from the socket
21:35:58 <kmc> so you can invent a new type «data AorB = IsA A | IsB B»
21:36:05 <kmc> and you can continue to use A and B elsewhere, when you know which
21:36:10 <kmc> and use AorB when you don't know
21:37:14 <CakeProphet> FunctorSalad_:  so what do I need to do about these TyVarBndrs?
21:37:46 <FunctorSalad_> I guess I should just grep it too to see how they're used
21:38:28 <tolkad> kmc: huh, that makes sense, thanks
21:38:43 <CakeProphet> hpaste down? what's a pastebin I could use?
21:38:48 <FunctorSalad_> CakeProphet: meh same problem with monads-fd
21:38:58 <FunctorSalad_> upon trying to install the head version
21:38:59 <kmc> no problem tolkad :)
21:39:29 <CakeProphet> FunctorSalad_:  is monads-fd standard?
21:39:34 <Esteth> for those browsing IRC logs: mapM_ is the function I wanted
21:40:08 <FunctorSalad_> CakeProphet: well, it's a rival to mtl
21:40:22 <FunctorSalad_> imho it's quite annoying that it uses the same names :\
21:40:33 <CakeProphet> hmm... so
21:40:49 <FunctorSalad_> causing thousands of compile errors around the world in exchange for some marginal differences
21:40:51 <FunctorSalad_> ;)
21:41:09 <CakeProphet> since what I've basically done is download the source files for fclabels, change the module names, and appended these files to my directory
21:41:26 <CakeProphet> I might have issues with dependencies in monads-fd
21:41:27 <FunctorSalad_> CakeProphet: just delete the '==0.0.*' constraint in fclabels.cabal
21:41:30 <FunctorSalad_> to fix monads-fd
21:41:40 <FunctorSalad_> a case of paranoid upper bounds
21:41:40 <CakeProphet> hmm.. oh
21:42:00 <FunctorSalad_> that procedure works with *lots* of packages *rant*
21:42:26 <FunctorSalad_> I understand the rationale but 99% of the time it yields bogus failures
21:43:54 <CakeProphet> FunctorSalad_:  I have the same issue when trying to install fclabels from local directory.
21:44:01 <CakeProphet> Could not find module `Control.Monad.Reader': it is a member of package monads-fd-0.1.0.1, which is hidden
21:44:07 <CakeProphet> though this time it's a different module.
21:44:17 <FunctorSalad_> CakeProphet: after that change it build without any changes for me
21:44:29 <FunctorSalad_> CakeProphet: apparently you deleted 'monads-fd' too?
21:44:35 <FunctorSalad_> I mean leave it in, but without constraint
21:44:43 <CakeProphet> oh... yes, that's why.
21:44:44 <CakeProphet> haha.
21:45:02 <FunctorSalad_> *it builds
21:45:34 <FunctorSalad_> so apparently the author already did the TyVarBndr stuff
21:46:33 <Gilly> Does anyone know of a example of using HaXml's xtract? I'm having hard time figuring out how to do it properly. Is it really necessary to take the types apart by hand to accomplish any simple task?
21:46:55 <CakeProphet> FunctorSalad_:  still can't find the module, though the error looks a little different now.
21:48:07 <CakeProphet> Could not find module `Control.Monad.Reader':
21:48:28 <CakeProphet> with monads-fd appended to build-deps once more.
21:49:54 <FunctorSalad_> CakeProphet: here's my modified cabal http://community.haskell.org/~daniels/fclabels.cabal
21:50:39 <CakeProphet> FunctorSalad_:  so you're saying the author already fixed what I was about to fix? What's the problem then? The error I'm getting from fclabels is in relation to undeclared type/constructor bindings
21:50:50 <CakeProphet> Not in scope: type constructor or class `TyVarBndr'
21:50:56 <CakeProphet> Not in scope: data constructor `PlainTV'
21:51:15 <FunctorSalad_> lol maybe *I* fixed it and forgot about it
21:51:29 <CakeProphet> in your sleep perhaps? :)
21:52:45 <CakeProphet> and now here's the latest error, using your cabal file.
21:52:47 <CakeProphet> cabal: can't find source for Data.Record.Label in ., dist/build/autogen
21:54:40 <FunctorSalad_> CakeProphet: I'm confused what exactly my currently installed source tree is
21:54:43 <FunctorSalad_> but it compiles, lol
21:55:15 <CakeProphet> hrm..
21:55:40 <FunctorSalad_> ah maybe I should try actually comitting the changes before pushing
21:56:03 <CakeProphet> according to hackage I believe Language.Haskell.TH.Syntax should contain both TyVarBndr and PlainTV
21:56:28 <FunctorSalad_> yes, they are the additions
21:56:41 <FunctorSalad_> are you sure you're compiling against ghc 6.12.3 and its TH?
21:56:43 <lowSodium> How may I use the same field label in two distinct records?
21:56:45 <CakeProphet> so perhaps I don't have the latest template-haskell?
21:56:55 <CakeProphet> I honestly don't know how to check my version of TH
21:57:17 <FunctorSalad_> don't every try to install a TH yourself, it's fixed to ghc
21:57:21 <FunctorSalad_> ;)
21:57:23 <CakeProphet> lowSodium:  I don't think it's possible unfortunately. 
21:57:31 <lowSodium> that's just horrible
21:57:35 <FunctorSalad_> if you have the wrong version you just need to install ghc 6.12.3
21:57:40 <CakeProphet> wired-in package template-haskell mapped to template-haskell-2.3.0.0
21:57:49 <CakeProphet> ah, I'm using 6.10
21:57:51 <FunctorSalad_> yeah that's wrong
21:58:02 <Axman6> lowSodium: it's also not well typed, so it makes sense that you can't
21:58:02 <CakeProphet> so here's the actual problem. :P
21:58:08 <FunctorSalad_> apprently it wasn't me who fixed it after all
21:58:12 <FunctorSalad_> +a
21:58:18 * Axman6 -> lecture
21:58:46 <FunctorSalad_> I just guessed that because it built here and you were saying it doesn't ;)
21:58:59 <CakeProphet> FunctorSalad_:  hmmm, I assume I'm using the most current version of GHC in the ubuntu repos. What's the best way to install the latest version of GHC?
21:59:28 <FunctorSalad_> CakeProphet: download from haskell.org/ghc, unpack, make install
21:59:56 <CakeProphet> ah, yes. of course. :P My lazy self likes packages, but not when they go out of date.
22:00:01 <FunctorSalad_> I don't know ubuntu but 6.10 is really old, surely they have a newer one somewhere?
22:00:22 <CakeProphet> I should be using 6.12 for this correct?
22:01:28 <CakeProphet> FunctorSalad_:  aha. I think I found it
22:01:46 <CakeProphet> ghc -v gives me template-haskell 2.3, but ghc6 -v gives me template-haskell 2.4
22:01:50 <FunctorSalad_> 6.12.3 is the latest stable
22:01:55 <CakeProphet> so perhaps I should mv ghc6 ghc  ?
22:02:27 <FunctorSalad_> isn't ghc a symlink?
22:02:49 <CakeProphet> wouldn't know how to check. 
22:02:56 <FunctorSalad_> you'd need to relink ghc-pkg too
22:03:01 <CakeProphet> I only pretend to be a computer scientist, honestly.
22:03:26 <FunctorSalad_> file `which ghc`
22:03:40 <FunctorSalad_> (file is massive overkill for this, but it works ;))
22:03:50 <CakeProphet> /usr/local/bin/ghc: symbolic link to `ghc-6.10.1'
22:04:06 <CakeProphet> so. yes.
22:04:51 <CakeProphet> now how do I re-link it to 6.12?
22:05:03 <FunctorSalad_> ln -sf /usr/local/bin/ghc-6.12.3 /usr/local/bin/ghc
22:05:09 <FunctorSalad_> same for ghc-pkg and ghci
22:05:16 <FunctorSalad_> and maybe some other tool I forgot...
22:05:41 <FunctorSalad_> assuming .../ghc-6.12.3 is where your other ghc is
22:05:52 <FunctorSalad_> it may be /usr/bin/ghc-6.12.3
22:06:25 <CakeProphet> actually I think I want ghc6
22:07:23 <CakeProphet> ah, but there's also a ghc-6.12.1
22:08:22 <FunctorSalad_> if the ghc6 is 6.12.3 you want that
22:08:36 <CakeProphet> FunctorSalad_:  it is
22:09:00 <CakeProphet> there's also ghci6 and ghc-pkg6
22:10:12 <duckinator> hi
22:10:17 <CakeProphet> cabal install fclabels
22:10:19 <CakeProphet> cabal: failed to parse output of 'ghc-pkg dump'
22:10:38 <FunctorSalad_> hmm cabal is out of date too?
22:10:40 <tolkad> are exceptions expensive in haskell?
22:10:50 <CakeProphet> FunctorSalad_:  ah, lemme check
22:11:02 <FunctorSalad_> (and you did link ghc-pkg to ghc-pkg6?)
22:11:07 <CakeProphet> cabal-install version 0.6
22:11:10 <CakeProphet> FunctorSalad_:  correct
22:11:10 <tolkad> they are in many other languages so I am wondering if the same applies to haskell
22:11:21 <kmc> well that's a question about an implementation, not about Haskell
22:11:31 <tolkad> sorry, I meant GHC
22:11:39 <kmc> best would be to profile, to see the speed in your specific use case
22:11:43 <kmc> sorry i don't have anything less obvious to say
22:11:53 <tolkad> ok
22:12:11 <CakeProphet> FunctorSalad_:  bah, actually my links are all messed up now. :P
22:12:19 <CakeProphet> I think I reversed the arguments of ln
22:12:55 <tolkad> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/bytestring-0.9.1.6/Data-ByteString-Lazy.html#v%3Alength
22:13:00 <tolkad> O(n\c)?
22:13:02 <tolkad> what's that mean?
22:13:07 <tolkad> the \c part
22:13:42 <copumpkin> divided by chunk size
22:13:53 <tolkad> oh, why not /c then?
22:13:55 <CakeProphet> FunctorSalad_:  no. nevermind. I used ln correctly. But for some reason this happens:
22:14:02 <CakeProphet> file `which ghc-pkg`/usr/bin/ghc-pkg: symbolic link to `/etc/alternatives/ghc-pkg'
22:14:09 <copumpkin> tolkad: beats me :)
22:14:35 <tolkad> copumpkin: heh, that's what I thought it was at first but I got confused by the backslash
22:14:48 <copumpkin> I think it's an indication of it being integer division
22:14:51 <copumpkin> but not sure
22:14:53 <FunctorSalad_> CakeProphet: hmm, update-alternatives --config ghc-pkg
22:14:57 <copumpkin> (not haskell, anyway)
22:15:16 <tolkad> O(n`div`c)
22:15:21 <CakeProphet> FunctorSalad_:  no alternatives for ghc-pkg
22:15:27 <FunctorSalad_> 'alternatives' is a system that is supposed to take care of the links for you ;) but didn't know it was used for ghc
22:15:31 <tolkad> now it i
22:15:33 <tolkad> is*
22:16:12 <FunctorSalad_> CakeProphet: hmm but you do have the ghc-6.12.3 installed as a deb package?
22:16:21 <CakeProphet> FunctorSalad_:  correct.
22:16:29 <FunctorSalad_> it should show up as an alternative then
22:17:10 <CakeProphet> FunctorSalad_:  ah, here's a problem. ghc is no longer pointing to anything useful.
22:17:33 <FunctorSalad_> CakeProphet: maybe just aptitude reinstall the ghc? ;)
22:17:58 <CakeProphet> perhaps I shall. :)
22:18:07 <FunctorSalad_> that may reset your package database, not sure how ubuntu handles that
22:18:40 <CakeProphet> maybe PATH is messed up:  bash: /usr/local/bin/ghc: No such file or directory
22:19:39 <FunctorSalad_> hmm but 'which' uses the PATH to look for the name you passed
22:20:09 <FunctorSalad_> so you seemed to have a /usr/local/bin/ghc at the start of this :)
22:20:22 <CakeProphet> okay.. so  ghc goes to /usr/bin/ghc, which goes to /etc/alternatives/ghc 
22:20:38 <CakeProphet> but when I type ghc -V bash complains that /usr/local/bin/ghc isn't there.
22:21:00 <FunctorSalad_> /usr/local/bin/... is usually the one you get from make install-ing the raw ghc yourself
22:21:22 <FunctorSalad_> are you sure it's still there?
22:21:23 <CakeProphet> hmmm
22:21:52 <FunctorSalad_> your file `which ghc` command some screens up said that ghc is in /usr/local/bin
22:22:12 <CakeProphet> now it says it's in /usr/bin/ghc
22:22:15 <CakeProphet> since I reinstalled
22:22:33 <CakeProphet> but there is also a ghc at /usr/local/bin
22:22:43 <FunctorSalad_> ah (but I still don't get why the other disappeared, and on my system /usr/local/bin takes precedence)
22:22:49 <CakeProphet> but it's name appears in ANSI red... I'm not quite sure what that means though.
22:22:50 <FunctorSalad_> don't know about you
22:23:03 <FunctorSalad_> link to nonexistant file, usually
22:23:13 <CakeProphet> ah. so I should clear out these links.
22:23:15 <CakeProphet> :)
22:23:29 <FunctorSalad_> that would unshadow the /usr/bin/ghc yes
22:25:34 <CakeProphet> Functor this is bizzare. which ghc outputs /usr/bin/ghc
22:25:48 <CakeProphet> but typing ghc alone still gives bash: /usr/local/bin/ghc: No such file or directory
22:26:22 <CakeProphet> but /usr/bin/ghc works.
22:26:23 <FunctorSalad_> exec bash? ;)
22:26:39 <CakeProphet> oh, well that fixed it?
22:26:47 <FunctorSalad_> bash probably still had the other one cached
22:26:54 <FunctorSalad_> (its existance I mean)
22:26:56 <CakeProphet> ah. I didn't know it did that. :P
22:28:19 <CakeProphet> FunctorSalad_:  oh, well this might be a problem. cabal-install was not installed.
22:28:40 <CakeProphet> my packages and binaries just aren't playing nicely together, I guess.
22:29:02 <CakeProphet> oh my... perhaps it will actually work now.
22:29:05 <FunctorSalad_> :)
22:30:14 <CakeProphet> haha. yes! it works now. Thanks FunctorSalad. And here I was going to go to patch fclabels. 
22:30:24 <FunctorSalad_> hehe
22:32:31 <CakeProphet> okay... now something is seriously wrong. Here's what happens now when I try to compile MY code:
22:32:37 <CakeProphet> Could not find module `Control.Concurrent.STM':
22:34:01 <CakeProphet> @google Control.Concurrent.STM
22:34:02 <lambdabot> No Result Found.
22:34:07 <CakeProphet> @hoogle Control.Concurrent.STM
22:34:07 <lambdabot> module Control.Concurrent.STM
22:34:07 <lambdabot> package stm
22:34:37 <CakeProphet> ah. I thought stm came with GHC
22:34:48 <Wooga> where i can find System.IO.Utils ? i can't see such module in ghci :m prompt
22:35:01 <CakeProphet> @hoogle System.IO.Utils
22:35:01 <lambdabot> No results found
22:35:12 <Wooga> http://hackage.haskell.org/packages/archive/MissingH/1.1.0.3/doc/html/System-IO-Utils.html#v%3AhInteract
22:35:35 <Wooga> or hInteract in some other place now?
22:36:20 <Heffalump> CakeProphet: even if it comes with GHC, it might not be in package that's available by default
22:36:42 <CakeProphet> I'm just confused because before I reinstalled GHC I don't recall ever having to cabal install stm
22:37:13 <CakeProphet> Ambiguous module name `Control.Monad.Trans': it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.1.0.1
22:37:19 <CakeProphet> how do I fix this? 
22:38:53 <CakeProphet> @hoogle MonadIO
22:38:53 <lambdabot> Control.Monad.Trans class Monad m => MonadIO m
22:39:02 <CakeProphet> @hoogle Control.Monad.Trans
22:39:02 <lambdabot> module Control.Monad.Trans
22:39:02 <lambdabot> Control.Monad.Trans class MonadTrans t
22:42:04 <CakeProphet> do I basically need to have only one of either mtl or monads-fd on my packages at all times?
22:42:31 <ezyang> Ya, essentially. 
22:42:38 <ezyang> Or use Cabal. 
22:42:41 <CakeProphet> hmm
22:43:02 <ezyang> You can ghc-pkg hide one of 'em so that it still builds with CAbal but doesn't interfere with ghc --make/ghci 
22:43:04 <CakeProphet> okay, so fclabels uses monads-fd. Should I remove mtl or could I just have fclabels build with mtl instead of monads-fd?
22:44:14 <CakeProphet> ah, using hide fixed it.
22:46:15 <ezyang> \o/ ghc-pkg hide 
22:46:25 <ezyang> I was always kind of sketched out by that command when I didn't understand the package database. 
22:46:32 <ezyang> now that I understand GHC a little more, it sketches me out less. 
22:46:53 <CakeProphet> I find it kind of sketchy
22:47:05 <CakeProphet> but I suppose as long as I have either mtl or monads-fd visible then it doesn't matter.
22:49:26 <Wooga> can i somehow brake interact interaction by throwing EOF ioError or somehow?
22:49:50 <kmc> from within the function?
22:49:53 <Wooga> yes
22:50:18 <kmc> probably, did you try it?
22:50:37 <Wooga> i tried to find eof error type constructor but failed
22:50:51 <Wooga> maybe i didn't clear enough understand ioErrors
22:51:34 <kmc> why do you want it to be EOF specifically?
22:52:00 <Wooga> i don't. just i don't know anything else determining end of stdin
22:52:01 <CakeProphet> awww yeah. Time to add ugly _'s to the beginning of my vanilla Haskell record accessors, apply a TH hack, and use some first-class record labels. :)
22:52:17 <kmc> the exception you're throwing has nothing to do with stdin ending
22:52:29 <kmc> it's just that, if you throw any exception within the function "interact" is calling, it might break out of interact
22:52:51 <kmc> anyway look at 'eofErrorType' and 'mkIOError' in System.IO.Error
22:52:56 <kmc> but 'userError' is simpler
22:53:06 <Wooga> thanks!
22:53:29 <kmc> to me this mixture of lazy IO and imprecise exceptions smells like disaster
22:54:55 <Wooga> is it worse then completly non-pure function?
22:55:21 <kmc> if you need precise controls on when your IO happens, and when it finishes, you should use strict I/O
22:55:52 <kmc> e.g. hGetLine, not hGetContents
22:55:58 <kmc> worse how?
22:56:06 <kmc> and what do you mean by "non-pure function"?
22:56:44 <Wooga> non-pure: not a completly fp-pure function, without shadow of IO monad
22:57:00 <Wooga> i mean with shadow*
22:57:31 <Wooga> where explicit hGetCOntents, hGetLine and so on used
22:57:32 <BMeph> Is there a TH hack out yet to get fst/snd et al. working? Just curious... :)
22:57:55 <kmc> Wooga, well, Haskell functions returning IO-monad actions are pure fp functions, like any others
22:58:04 <kmc> it's actually the lazy IO that involves some hackery
22:58:12 <Wooga> then why everyone say "don't use IO if you can" ?
22:58:24 <kmc> interact, hGetContents, and other "lazy IO" functions call unsafeInterleaveIO internally
22:59:35 <kmc> Wooga, what they mean is that you shouldn't bring IO into the pure computational part of your program
22:59:48 <kmc> what we're talking about is not the computational part of your program
23:00:04 <kmc> it's how you get lines from stdin, and how you decide when to stop
23:00:13 <kmc> that's an IO task, and it's totally appropriate to describe it with the IO monad
23:00:34 <Wooga> but what if my computations depends on when and how io action happend, like in input of interpreting language?
23:02:10 <kmc> then you read the input, and pass it to your computational function
23:03:01 <kmc> do { x <- getChar; putChar (f x) }
23:03:23 <kmc> calls a function «f :: Char -> Char» as part of an IO action
23:03:39 <Wooga> oh, i apparently find out how to that: firt i should build sequence of inputs, then purely process them into outputs and then sequence them
23:04:07 <Wooga> i didn't thinked in that way before
23:04:19 <Wooga> kmc: thanks for 
23:04:35 <Wooga> patience*
23:05:00 <kmc> no problem :)
23:09:01 <Wooga> oh, i am greatly stupid. this would require user to make all inputs before starting programm. no-IO pure yet wildly inconvenient for user.
23:10:53 <Wooga> so, i am again in front of choice of breaking interact or to using IO-functions explicitly
23:11:07 <Wooga> s/ to//
23:12:15 <sts193> Can anyone point to a good starting point for someone that wants to learn haskell?
23:12:22 <kmc> @where LYAH
23:12:22 <lambdabot> http://www.learnyouahaskell.com/
23:12:24 <kmc> @where RWH
23:12:24 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
23:12:28 <kmc> sts193, ^^^^
23:12:56 <kmc> also tryhaskell.org
23:12:56 <sts193> thanks!
23:13:28 <sts193> so learn you haskell -> real world haskell would be a good progression?
23:17:18 <FunctorSalad_> "<kmc> to me this mixture of lazy IO and imprecise exceptions smells like disaster" <-- I'm sometimes confused what exactly a `catch` is covering...
23:17:55 <kmc> yeah
23:18:06 <kmc> it's covering all the evaluation done during the execution of some IO action
23:18:17 <kmc> but that requires you to reason about evaluation order, which is supposed to be hidden
23:19:24 <FunctorSalad_> yes
23:19:52 <FunctorSalad_> (and as you mentioned the 'evaluation' may include execution with lazy io....)
23:20:00 <kmc> aye
23:20:45 <kmc> so there are some who maintain that imprecise exceptions (those thrown by evaluation) should be used only for killing the program, and shouldn't be caught
23:21:00 <kmc> i wouldn't go that far, but it's a reasonable sentiment
23:21:05 <FunctorSalad_> that'd be really impractical for e.g. xmonad
23:21:16 <kmc> where does xmonad use them?
23:22:18 <FunctorSalad_> I mean it shouldn't crash my whole xmonad if I missed a partiality in something I added ;)
23:22:49 <kmc> well, what actually happens now?
23:23:20 <FunctorSalad_> not sure. I think all the hooks are run inside catch blocks, but I don't know this
23:23:26 <kmc> ah
23:23:38 <FunctorSalad_> well, "block" ;)
23:23:54 <kmc> i think it's reasonable to write software which is designed to fail hard and completely, and then restart itself restoring all important state
23:24:42 <FunctorSalad_> but not if some totally nonessential part fails? the windowmanager can continue perfectly well if the hotkey I added is bogus
23:24:49 <kmc> it's true
23:25:14 <kmc> but maybe your bogus hotkey already did something nasty to the internal state before crashing
23:25:28 <kmc> so it should fail totally and then restart itself from a clean state
23:25:43 <kmc> obviously this is more of an issue in memory-unsafe languages like C and C++
23:25:59 <kmc> the extreme other end being code which catches and ignores SIGSEGV, or maps a readable page of zeros at address 0
23:26:14 <FunctorSalad_> the feature you mention is nice to have in either case :)
23:26:43 <dibblego> @pl \ k -> reverse . k . reverse -- is this around in the libraries?
23:26:44 <lambdabot> (reverse .) . (. reverse)
23:26:47 <dibblego> @type \ k -> reverse . k . reverse -- is this around in the libraries?
23:26:49 <lambdabot> forall a a1. ([a1] -> [a]) -> [a1] -> [a]
23:27:04 <FunctorSalad_> (persisting important state and restarting mostly seamlessly...)
23:27:40 <FunctorSalad_> (*rants against programs whose notion of 'important state' doesn't even include the configuration ;))
23:28:22 <anair_84`> newbie question , what would be the shortest way to foldr over a IO [String]
23:28:28 <anair_84`> foldr (+) 0 (map wordLen lines)
23:28:34 <dibblego> @type foldM
23:28:36 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
23:28:36 <FunctorSalad_> kmc: it really depends whether one would prefer failure or 'try to make sense out of nonsense if at all possible'
23:28:59 <anair_84`> foldM k thanks
23:29:11 <FunctorSalad_> it depends for example on whether you have time to fix things or whether you're *using* the system for something critical at the moment ;)
23:29:43 <FunctorSalad_> (it really depends on the situation I mean)
23:30:50 <FunctorSalad_> say, a moon lander ;)
23:31:34 <FunctorSalad_> should probably rather ignore all errors rather than deliberately crashing
23:31:53 <FunctorSalad_> pun not intended
23:33:01 <FunctorSalad_> (during employment, not testing)
23:41:35 <Peasley> hey. so i made 'find first 1..n numbers squared sum'
23:41:36 <Peasley> sumk :: Int -> Int
23:41:36 <Peasley> sumk x = foldrl (+) [z * z | z <- [1..x + 1]]
23:41:47 <Peasley> Im getting this: back.hs:4:9: Not in scope: `foldrl'
23:41:48 <Peasley> why?
23:42:00 <Peasley> im including prelude
23:42:01 <ezyang> Peasley: foldrl is not a function. 
23:42:05 <ezyang> Did you mean foldr? 
23:42:13 <etpace> import Data.List
23:42:21 <etpace> @hoogle foldr1
23:42:21 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
23:42:21 <lambdabot> Data.ByteString foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
23:42:21 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
23:42:35 <Peasley> ahh
23:42:36 <ezyang> oh, foldr1, not foldrl :o) 
23:42:49 <etpace> or wait, foldr1 is in prelude?
23:42:49 <Peasley> this book..l and 1 so same
23:42:54 <Peasley> but thanks
23:42:58 <etpace> they were the same on my terminal too
23:43:00 <etpace> i need glasses
23:43:57 <CakeProphet> :t gets
23:43:59 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
23:53:58 <Peasley> wipii
23:53:59 <Peasley> quickSort (y:dx) = quickSort [z | z <- dx, z < y] ++ [y] ++ quickSort [z  | z <- dx, z >= y]
23:54:03 <Peasley> so easy :D
23:56:00 <mjrosenb> Peasley: unfortunately, passing over the list twice is likely not going to be 'quick'
23:56:12 <mjrosenb> Peasley: also, mergesort is *totally* the way to go
23:57:15 <Peasley> quicksort > mergesort in practice :o
23:57:38 <Peasley> but yea i agree my 'implementation' is poor
23:58:30 <mjrosenb> Peasley: iirc, the only reason that quicksort reliably beats mergesort is because you can do it in place
23:58:46 <mjrosenb> which you kinda lose when you are doing it on a list
23:59:03 <ajnsit> is there a vector clock implementation in haskell?
23:59:21 <ajnsit> if not I was thinking of quickly implementing one
23:59:31 <mjrosenb> vector clock?
23:59:31 <ajnsit> but I don't want to reinvent the wheel
23:59:50 <ajnsit> http://en.wikipedia.org/wiki/Vector_clock
