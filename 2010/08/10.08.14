00:00:11 <shadwick> Cale_: ok good. Haskell's type system is immense...
00:00:12 <Veinor> and it uses the comparator in place of < or whatever.
00:00:50 <kmc> Veinor, you'd have to enforce always using the same comparator in the same structure, though
00:00:52 <Veinor> so you need to be able to define some ordering, but it doesn't necessarily have to be one that you would feel comfortable using for Ord
00:01:01 <Veinor> yeah. which means you can't union sets at all.
00:01:20 <kmc> you can
00:01:27 <kmc> but you have to re-insert one side
00:01:31 <Veinor> well, yeah
00:01:34 <Cale_> shadwick: The numeric hierarchy is a bit daunting at first, but it's *mostly* pretty sensible. If you get tired of trying to figure it out, you can always just pick a type like Double.
00:02:08 <Veinor> anyway, it strikes me as an interesting project
00:02:46 <Veinor> you could have sets of complex numbers!
00:03:01 <kmc> yeah
00:03:13 <kmc> in practice i'd rather just newtype and define Ord
00:03:18 <Veinor> true
00:03:27 <Veinor> but then you'd have to wrap and unwrap
00:03:30 <kmc> but, maybe not, if you write it and the API is nice :)
00:03:44 <Veinor> well, the API for the most part could mirror Set's
00:04:04 <Veinor> except that the constructor functions would also require an a -> a -> Ordering
00:04:47 <Veinor> ... hm. I think this is going to involve a lot of copy-pasting from Data.Set's source
00:06:35 <Veinor> ooh. I could make CompareT a = CompareT a (a -> a -> Ordering), then just have everything use sets of CompareT a's
00:06:56 <Veinor> the problem is that that would balloon the memory usage since I'd be passing around a copy of the comparator for every element in the set
00:07:05 <kmc> well, just a pointer
00:07:07 <kmc> but yeah
00:08:04 <Veinor> hm, it looks like there aren't that many references to compare in Data.Set
00:08:56 <Veinor> but copy-pasting code is bad
00:09:32 <Veinor> I think CompareT (or Comparable or whatever) is the way to go here.
00:10:07 <Veinor> is there a way to check how much memory a program uses?
00:10:27 <lispy> Veinor: many ways.  +RTS -s -RTS is the most basic
00:10:38 <lispy> Veinor: /usr/bin/time -v foo, works quite well too
00:12:17 <Veinor> @pl \x y -> fst x == fst y
00:12:18 <lambdabot> (. fst) . (==) . fst
00:12:26 <Veinor> @src on
00:12:26 <lambdabot> (*) `on` f = \x y -> f x * f y
00:12:33 <Veinor> >:/
00:14:26 <augur> does anyone know the computational complexity of various forms of type checking?
00:14:46 <ezyang> Interesting question. 
00:14:49 <augur> especially the simpler kinds, not dependent types, etc.
00:15:01 <ezyang> Does typechecking include inference? 
00:15:05 <augur> sure yeah.
00:15:10 <augur> stuff like haskell's type system
00:15:11 <ezyang> not that I know, but I think inference is important. 
00:15:26 <augur> or even something like full explicit type declarations in languages like c
00:15:46 <augur> my intuition is that c-like type checking is mildly context sensitive
00:16:06 <ezyang> I know full F_c is undecidable 
00:16:10 <augur> F_c?
00:16:20 <ezyang> erm, F_<: 
00:16:24 <augur> F_<:?
00:16:52 <kmc> F with subtyping
00:16:57 <kmc> system F that is
00:16:59 <augur> system F?
00:17:01 <kmc> stupid subtyping
00:17:07 <augur> aha
00:17:07 <augur> ok
00:17:10 * ezyang has TAPL in front of him. 
00:17:16 <ezyang> I haven't actually gotten to that chapter yet... 
00:17:17 * kmc ‚ô• TaPL
00:17:31 <augur> really now
00:17:37 <augur> F_<: is undecidable?
00:17:48 <augur> wots TAPL
00:17:49 <kmc> inference is undecidable?
00:17:51 <kmc> @where tapl
00:17:52 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
00:18:05 <augur> ahh ok
00:18:06 <kmc> complexity of checking STLC without inference should be pretty low
00:18:15 <kmc> i think you just traverse the expression tree once
00:18:41 <kmc> inference for STLC would be that plus unification of equations you generate during the traversal
00:18:51 <kmc> one equation per node only?
00:19:51 <augur> hm.
00:19:54 <Veinor> hm, okay
00:20:01 <Saizan> inference for STLC with non-annotated lambdas is undecidable, otherwise it's simple
00:20:16 <Veinor> a Set (Comparable Double) is twice as big as a Set Double
00:20:24 <Veinor> which isn't terribly bad
00:20:34 <augur> im just thinking, what sort of grammar would you need if you were going to compile your type checking into your grammar, right
00:21:10 <augur> and like, a bit of code like say, the c code   int x; ... x += 1; ...
00:21:17 <augur> looks like it displays some amount of cross-serial dependencies
00:21:39 <augur> well, just make it = even
00:23:52 <Veinor> 36 bytes/element for a Set of 1 million Doubles, 77 for a set of 1 million Comparable Doubles
00:31:35 * hackagebot cryptohash 0.5.1 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.5.1 (VincentHanquez)
00:32:33 <Veinor> anybody here know anything about memory usage stuff?
00:32:52 <kmc> what about it
00:35:20 <Veinor> my main is S.fromList [1..1000000] `seq` putStrLn "hello"
00:35:41 <Veinor> compiling with -O3 gives me about... 34 MB of memory usage. is this to be expected or am I doing something wrong?
00:35:59 <augur> well, you
00:36:07 <augur> you've created a 1000000 element list
00:36:12 <Veinor> true
00:36:23 <DrSyzygy> Veinor: 32 or 64 bit platform?
00:36:31 <Veinor> but if I don't construct the set I don't even break a megabyte
00:36:35 <Veinor> DrSyzygy: 64.
00:36:42 <DrSyzygy> So 8 bytes per word.
00:37:17 <DrSyzygy> And 8 bytes per pointer. You've overhead for each : in your list.
00:37:38 <Veinor> ah
00:37:51 <augur> yeah basically thats just a shit way of doing a fixed number of iterations of something
00:38:11 <mauke> there is no -O3
00:38:36 <augur> i dont know if theres a haskell equivalent to ruby's n.times but its trivial enough to write if there isnt
00:39:40 <DrSyzygy> take n . iterate f x
00:39:41 <Veinor> well I just wanted to see what the typical size of a list of 1000000 elements would be
00:39:43 <augur> nTimes 1 f = f; nTimes n f = f `seq` (nTimes (n-1) f)
00:39:55 <DrSyzygy> (also does too much, my suggestion that it)
00:39:56 <augur> or just times, then you can infix it
00:40:49 <shadwick> what exactly is the . operator for?
00:40:56 <augur> 1 `times` f = f; n `times` f = f `seq` ((n-1) `times` f)
00:41:00 <augur> there, thats nicer
00:41:02 <mauke> shadwick: function composition
00:41:09 <shadwick> mauke: ah, ok thanks
00:41:25 <kmc> err that doesn't iterate anything
00:41:26 <augur> 1000000 `times` \_ -> putStrLn "hello"
00:41:37 <kmc> :t replicateM
00:41:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
00:41:42 <augur> or whatever
00:41:42 <kmc> :t replicateM_
00:41:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
00:41:47 <Angelion> The time has come and so have I
00:41:47 <Angelion> Iíll laugh last ëcause you came to die
00:41:48 <Angelion> The damage done the pain subsides
00:41:48 <Angelion> And I can see the fear clear when I look in your eye
00:41:53 <DrSyzygy> augur: I'm kinda hoping that that'd get optimized away.
00:42:01 <kmc> i don't think Veinor's goal in building this list is to iterate some action
00:42:05 <augur> DrSyzygy: that what would get optimized away
00:42:08 <Angelion> Iíll never kneel and Iíll never rest
00:42:09 <Angelion> You can tear the heart from my chest
00:42:09 <Angelion> Iíll make you see what I do best
00:42:09 <Angelion> Iíll succeed as you breathe your very last breath
00:42:18 --- mode: ChanServ set +o Saizan
00:42:23 --- mode: Saizan set +b *!*Angelion@*.broadband.corbina.ru
00:42:23 --- kick: Angelion was kicked by Saizan (Angelion)
00:42:25 <kmc> thanks Saizan
00:42:29 <kmc> thaizan
00:42:29 <augur> kmc: well, perhaps not, but if thats the case then iteration of an action is a poor measure of appropriate memory use for the action :)
00:42:37 <DrSyzygy> augur: Oh wait. I missed that the IO action was inside the function call. 
00:42:37 <kmc> augur, ?
00:42:41 --- mode: Saizan set -o Saizan
00:43:03 <Veinor> but anyway... even if I build up an entire list of a million elements, it takes up a megabyte or so of memory
00:43:13 <Veinor> whereas the set takes 36 or whatever
00:43:19 <augur> kmc: well, if he's looking to actually use a 1000000 element set, then it might be entirely appropriate to be using 34 megs
00:43:47 <augur> whereas the example he gave is one where its not appropriate at all to have this program use that much memory, and thence the problem.
00:43:50 <DrSyzygy> Veinor: And then you copy it into a tree; with space overhead for the entire log 1000000 deep tree keeping the set.
00:43:58 <Veinor> true
00:44:17 <augur> but if he has to compute 1000000 things with the numbers from 1 to 1000000, then its sensible to use 34 megs in the process, its unavoidable
00:44:29 <kmc> Veinor, i highly doubt that.  a million elements fully evaluated should take at least 2 * 1 million machine words = 
00:44:32 <kmc> 15 MB
00:44:32 <augur> i assumed his example was representative of the kind of task he was doing
00:44:39 <augur> namely, iterating some number of times, etc.
00:44:57 <kmc> this example augur: S.fromList [1..1000000] `seq` putStrLn "hello"
00:44:58 <kmc> ?
00:45:03 <kmc> that doesn't iterate anything
00:45:15 <DrSyzygy> kmc: Then add the tree keeping the set and 4 * 1 million machine words isn't all that insane. 
00:45:17 <augur> er.. oh yes, sorry. :D
00:45:22 <kmc> it builds a big list, forces it to whnf, then throws it out
00:45:24 <augur> im misinterpreting things yet again. :D
00:46:39 <shadwick> is there something similar to 'take', but can be given a start index, like:  takeAt n start [list]  ?
00:46:46 <kmc> take n . drop m
00:47:58 <augur> you could ofcourse define your own sublist function like that for convenience. sublist m n = take n . drop m
00:48:20 <Veinor> hm, python uses 105MB for a set of 1 million ints
00:48:48 <augur> or if you're in a sort of OO mode, l `sub` m n = take n (drop m l)
00:49:14 <kmc> :t let l `sub` m n = take n (drop m l) in sub
00:49:14 <augur> >let sub l m n = tak n (drop m l) in [0,1,2,3,4,5] `sub` 2 2
00:49:15 <lambdabot> Parse error in pattern
00:49:19 <kmc> :t let (l `sub` m) n = take n (drop m l) in sub
00:49:20 <lambdabot> forall a. [a] -> Int -> Int -> [a]
00:49:28 <kmc> :t let l `sub` (m,n) = take n (drop m l) in sub
00:49:30 <lambdabot> forall a. [a] -> (Int, Int) -> [a]
00:49:48 <augur> >let sub l m n = take n (drop m l) in [0,1,2,3,4,5] `sub` 2 2
00:49:54 <augur> damn spaces
00:49:56 <augur> > let sub l m n = take n (drop m l) in [0,1,2,3,4,5] `sub` 2 2
00:49:57 <lambdabot>   Overlapping instances for GHC.Show.Show (GHC.Types.Int -> [t])
00:49:58 <lambdabot>    arising f...
00:50:01 <augur> D:
00:50:11 <kmc> x `f` y z  = x `f` (y z)
00:50:23 <shadwick> I got it figured out guys, thanks
00:50:31 <augur> how confusing, kmc
00:50:34 <augur> how confusing indeed
00:50:57 <kmc> function application binds tighter than infix operators
00:51:01 <augur> shadwick: we're no longer trying to help you, we've progressed into the idle navel gazing stage of #haskell talk :)
00:51:11 <kmc> you want that ¬´f x + g y¬ª should work right
00:51:28 <augur> > let sub l m n = take n (drop m l) in [0,1,2,3,4,5] `sub` 2 $ 2
00:51:30 <lambdabot>   [2,3]
00:51:32 <augur> AHA
00:51:53 <augur> > let sub l (m,n) = take n (drop m l) in [0,1,2,3,4,5] `sub` (2,2)
00:51:55 <lambdabot>   [2,3]
00:52:00 <augur> you're right, that was a good idea.
00:53:26 <Veinor> <03:52:21           <@Stephen> also Syk Haskell is such an awesome language
00:53:27 <Veinor> 03:52:39                <Syk> what can it do that VB can't
00:53:31 <kmc> haha
00:54:10 <kmc> that's such a funny question
00:54:12 <augur> well, to be fair, using "awesomeness" as an argument is kind of silly.
00:54:53 <kmc> it should be beat into people's heads that most languages *can* do the same set of things
00:55:11 <Veinor> right
00:55:12 <augur> for some definition of "things", of course
00:55:26 <augur> computationally, all modern programming languages can do the same things
00:55:29 <augur> at least in practice
00:55:37 <kmc> are you calling Agda non-modern? ;P
00:55:41 <augur> (modulo the silly descriptions of C as not turing complete, etc)
00:56:32 <augur> but the computational capacity of the language isn't the measuring stick that people think of when they think of what a language can do
00:56:54 <kmc> right, but what they should be thinking about is what the language can do *easily*
00:56:54 <augur> they think of what the language affords the programmer in terms of problem solving
00:57:15 <augur> sure, expressiveness. among other things
00:57:37 <augur> type checking is another issue. take out haskells types and you dont make the code any less expressive, necessarily (tho you probably do in many cases)
00:57:38 <kmc> otherwise you just say "i can do that in Blub, why learn another language"
00:57:51 <augur> but you certainly make it more difficult to code it due to type errors and such
00:57:57 <kmc> and you don't stop to think that maybe the way Blub does it is not the simplest and clearest
00:58:00 <augur> same with any typed language
00:58:15 <kmc> statically typed?
00:58:16 <Saizan> the problem is you commonly see "but i can do the same thing in $my_favourite_language! <horrible and unusable encoding here>"
00:58:33 <Saizan> so there are often double standards of "can do"
00:58:43 <augur> kmc: sure, or at least a language with a convenient pre-compiler type checker of any sort, required or not
00:58:56 <augur> but that just makes it obvious that languages _always_ do different things
00:59:30 <augur> what can language X do that Y cant? well, it can denote strings with an @ prefix
00:59:31 <shadwick> Ada also has a really nice type system
00:59:32 <augur> lots of crap
00:59:58 <augur> the question is whether or not doing things /that way/ is useful for you or not. its silly that people even ask that question
01:00:53 <augur> i think it comes from a genuine lack of understanding about what programming is and how computers computer, because if you knew this, you would know that for the computational side, theres no difference
01:03:48 <kmc> could be
01:04:19 <kmc> do these people lack formal education in CS, or did they go through bad CS programs, or did they just fail to learn?
01:04:39 <kmc> in the first case i can cut a lot of slack; i think it's a great thing how open the field is to self-directed learning
01:04:46 <augur> i suspect it could be any of them
01:05:04 <augur> bad CS programs that teach programming-is-C/C++/Java
01:05:08 <kmc> yeah
01:05:10 <augur> failure to learn that isnt true
01:05:11 <augur> whatever
01:05:15 <augur> its all the same result, really
01:05:48 <kmc> yeah but the solution is different in each case
01:05:58 <augur> true
01:06:00 <augur> well
01:06:08 <augur> the solution in all cases is an engaging SICP class :3
01:06:12 <kmc> heh
01:06:33 <kmc> does SICP cover theory regarding equivalence of different models of computation?
01:07:21 <augur> not in any real detail, but it does break down the issue of computation into a number of different modes, as well as demonstrate different ways of implementing a Scheme interpreter
01:07:28 <kmc> true
01:07:38 <augur> from a purely functional lazy version, to a register/stack machine version
01:08:09 <augur> obviously you'd do that in conjunction with a more general theory class
01:11:07 <kmc> yeah
01:11:15 <kmc> i'm not sure what a bad CS program looks like
01:11:26 <kmc> can only infer from interviewing clueless people
01:11:52 <kmc> i do know what it looks like to have a good CS program and then let it collapse
01:11:53 <kmc> go caltech
01:13:02 <augur> ive never taken any proper CS classes, so i cant say either
01:13:25 <kmc> but you know what's in SICP :)
01:13:29 <augur> my experience with CS is watching the SICP videos like 3 times (mostly for entertainment lol), reading lots of stuff, etc.
01:13:54 <augur> and also watching a bunch of the berkeley CS classes
01:14:14 <augur> including their intro class, and their machine architecture class
01:14:24 <augur> the latter i rather liked, especially because of the prof
01:15:03 <augur> conal! :D
01:15:14 <kmc> cool
01:15:21 <kmc> is the machine architecture stuff free online?
01:15:24 <kmc> that's something i should study more
01:15:25 <conal> augur: hi :)
01:15:26 <lambdabot> conal: You have 5 new messages. '/msg lambdabot @messages' to read them.
01:15:30 <conal> wow
01:15:42 <augur> kmc: yeah, lemme find you a link to the one i watched
01:15:48 <kmc> thanks augur :D
01:16:03 <augur> http://webcast.berkeley.edu/course_details.php?seriesid=1906978500
01:16:12 <augur> its basically a class about machine architecture via MIPS
01:16:23 <augur> and some minor amounts of c-compiler design for mips
01:16:32 <kmc> cool
01:16:49 <augur> theres also a lovely bit of discussion about pointers in there, as a result
01:17:01 <augur> best damn explanation of pointers ive seen, ill say that
01:17:09 <augur> i actually felt like i understood pointers after that
01:18:02 <mauke> I'm not sure you can understand C pointers by thinking about hardware
01:18:22 <augur> oh you cant, probably
01:18:28 <augur> but the first few lectures of the class are an intro to C
01:18:33 <augur> not about machine architecture
01:18:33 <augur> so
01:18:39 <kmc> heh, real player
01:18:41 <kmc> that takes me back
01:18:43 <kmc> but mplayer does it fine :)
01:19:01 <shadwick> meh, pointers weren't difficult to uinderstand
01:19:07 <shadwick> Monads on the other hand, seem intimidating
01:19:16 <augur> shadwick: when you get pointer pointer pointers they can be
01:19:18 <mauke> here's my explanation: C has two kinds of pointers: function pointers, which are values that refer to functions
01:19:22 <augur> @_@
01:19:27 <mauke> and data pointers, which are proxies for array elements
01:19:31 <shadwick> augur: you just need to keep track of the depth... I mean, it's not that hard
01:19:33 <kmc> i would rather download though
01:19:46 <augur> shadwick: its not hard to keep track of, but its a matter of intuitiveness
01:19:50 <mauke> and that's it, mostly
01:20:05 <kmc> shadwick, do you understand monads?
01:20:06 <augur> i can keep track of almost anything with pen and paper
01:20:14 <augur> but can i /grok/ it subconsciously
01:20:16 <augur> thats the issue
01:20:35 <shadwick> augur: ah, so you mean more of putting pointers into practice?
01:20:40 <shadwick> their concept is simple
01:20:54 <shadwick> well, putting pointers into pratice in a intuitive manner
01:21:01 <kmc> in C the difficult thing is not "pointers themselves" but "how to build high-level data structures in a low-level language"
01:21:12 <shadwick> yeah
01:46:48 <key> Re
01:47:35 <key> Hey guys I'm curious, are numbers objects in Haskell?
01:47:51 <kmc> key, there's nothing in particular called "object" in Haskell
01:47:58 * hackagebot hs2dot 0.1.3 - Generate graphviz-code from Haskell-code.  http://hackage.haskell.org/package/hs2dot-0.1.3 (OscarFinnsson)
01:48:00 <theorbtwo> key: "Objects" as they are generally thought of don't exactly exist in Haskell.
01:48:03 <kmc> what do you mean by that term?
01:48:30 <copumpkin> omg
01:49:08 <key> Oh
01:49:10 <theorbtwo> copumpkin's god: oh.  key: 1
01:49:14 <key> What is a number then?
01:49:25 <copumpkin> key: a value! :)
01:49:34 <kmc> a number is a lot of things
01:49:48 <copumpkin> in haskell's case, often a polymorphic one
01:49:52 <copumpkin> :t 1
01:49:53 <lambdabot> forall t. (Num t) => t
01:49:53 <key> What is + ? I assume there is some arithmetic functionality in Haskell
01:50:01 <Polarina> :t (+)
01:50:03 <lambdabot> forall a. (Num a) => a -> a -> a
01:50:04 <kmc> (+) is a function
01:50:05 <theorbtwo> + is a function.
01:50:11 <somnium> are setters for records built in? I want something like Record -> Field -> (a -> a) -> Record
01:50:13 <copumpkin> (+) is a method!
01:50:21 <kmc> ;P copumpkin you're not helping
01:50:22 <theorbtwo> Well, + is a syntax for calling the function (+).
01:50:31 <kmc> ¬´a + b¬ª is sugar for ¬´(+) a b¬ª
01:50:41 * copumpkin hrmpfs
01:50:48 <kmc> key, are you learning Haskell?
01:50:51 <key> Yes
01:51:01 <copumpkin> stay away from me then :(
01:51:02 <Polarina> key, http://learnyouahaskell.com/
01:51:12 <key> Yea reading it now
01:51:14 <jrockway> > 2 + 2
01:51:15 <lambdabot>   4
01:51:39 <kmc> key, numbers are values.  functions are also values, as are compound data types, IO actions, and lots of other things
01:51:41 <key> How can you pass 2 arguments to a function with the function being infix?
01:51:48 <key> Like, argument function argument
01:51:54 <kmc> argument `function` argument
01:51:59 <kmc> > 7 `mod` 2
01:52:00 <lambdabot>   1
01:52:05 <jrockway> > (+1) `fmap` [1..10]
01:52:07 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
01:52:07 <key> Is everything a value in Haskell?
01:52:14 <kmc> no
01:52:29 <kmc> types, modules, type classes, instances are not
01:52:30 <copumpkin> most things that you'd hope are values are, though
01:52:43 <kmc> goats and pigeons are not values in Haskell either
01:53:16 <kmc> "everything" is underspecified there
01:53:43 <theorbtwo> Functions, notably, *are* values.
01:53:48 <jrockway> is 2 a value?
01:53:54 <kmc> it shouldn't be notable, but it is
01:54:08 <key> Part of me misses the OO nature of Ruby, where the 'Number' type has a + method which takes another argument, and produces the value of the 2
01:54:17 <key> It was cool how Numbers knew how to add
01:54:25 <aRcatan> somnium: I don't think that kind of functionality exists for the standard records
01:54:40 <copumpkin> numbers know how to add in haskell too, but you don't think of it that way
01:54:44 <kmc> somnium, if you use a package like fclabels it can derive those for you automatically
01:55:02 <jrockway> > let f = (2 +) in f 42
01:55:03 <lambdabot>   44
01:55:19 <kmc> this "OO nature" is just ad-hoc overloading, plus weird syntax for the first argument to a function
01:55:38 <jrockway> > let f = (2 +) in (f 1, f 1.2)
01:55:40 <lambdabot>   (3,3.2)
01:55:46 <key> copumpkin: What do you mean? 
01:55:48 <somnium> kmc: cool, thanks
01:55:51 <kmc> that is you can see ¬´a.f(b,c,d)¬ª as sugar for ¬´f(a,b,c,d)¬ª, provided f is allowed to dispatch dynamically by the type of 'a'
01:56:05 <copumpkin> key: we get much more powerful overloading than that
01:56:33 <copumpkin> key: but even just that (+) suggests that "the number knows how to add"
01:56:52 <jrockway> (see above, for example... we made f a function that that takes one arg and adds it to 2.  but it works on both ints and floats)
01:56:52 <theorbtwo> In haskell, though, you can effectively dispatch dynamiclly on the types of any of your arguments.  (Thought it's not actually dynamic.)
01:56:56 <copumpkin> except, haskell's way stops you at compile time from adding a number to silly things
01:57:23 <kmc> you can even overload on the return type of a function
01:57:46 <key> Is Haskell the most powerful language that exists or what?
01:57:56 <kmc> @faq Is Haskell the most powerful language that exists or what?
01:57:57 <lambdabot> The answer is: Yes! Haskell can do that.
01:57:58 <copumpkin> key: it's pretty mind-blowing if you've never tried anything like it :)
01:58:05 <kmc> key, what does power mean to you?
01:58:19 <copumpkin> key: I came to it from ruby about a year and a half ago and have never looked back (although I still use ruby every so often)
01:58:19 <theorbtwo> Remember before we said that the type of 1 is (Num a) => a?  That means that the type of 1 is some type that does Num, but we haven't decided which one yet.
01:58:40 <kmc> key, writing correct programs is hard in any language.  Haskell makes it hard to write incorrect programs, too
01:58:40 <theorbtwo> ("Does" isn't actually the technical term, but it gives the right impression.)
01:58:44 <aRcatan> copumpkin: have you been with us only so short time? o_O
01:58:50 <dobblego> @type mappend
01:58:51 <lambdabot> forall a. (Monoid a) => a -> a -> a
01:59:07 <copumpkin> aRcatan: actually, almost two years now
01:59:11 <key> Very cool
01:59:23 <copumpkin> I started actually coding in it around december 2008
01:59:24 <key> copumpkin, It seems WAY tougher than Ruby however
01:59:33 <somnium> kmc: so, Haskell makes everything hard, but its for the best?
01:59:53 <DrSyzygy> somnium: If you wear a corset, you get such lovely posture.
01:59:55 <copumpkin> somnium: yeah, and those shackles and S&M equipment you're locked in now? it's for your own good
01:59:59 <theorbtwo> key: Part of that is that you are used to Ruby.  Haskell will get easier.
02:00:00 <kmc> somnium, i think so.  because by the time you get your program to compile, it's likely to be correct
02:00:05 <key> somnium: I think what he means is hard to do right, but hard to do wrong too
02:00:08 <kmc> somnium, but it doesn't /really/ make everything harder
02:00:28 <kmc> some things are easier because Haskell is just a coherent well-designed language
02:00:35 * copumpkin coughs
02:00:37 <copumpkin> most of it
02:00:52 <kmc> some things are easier because of the particular approaches taken (functional, lazy, controlled effects)
02:00:54 <theorbtwo> Oh, I'm a strong believer in the waterbed theory.  If you wish to make something easier, something else always gets harder.
02:00:55 * copumpkin has ridiculous hiccups :(
02:00:56 <kmc> some things are harder for the same reason
02:00:56 <dobblego> when standing next to its peers :)
02:01:10 <kmc> yeah it's not perfect copumpkin...
02:01:14 <somnium> yeah, I was just kidding
02:01:25 <kmc> certainly at the beginning it seems like Haskell makes everything hard
02:01:34 <kmc> it takes a long time to get comfortable
02:02:06 <DrSyzygy> theorbtwo: I have all respect for fetishes, but does it really fit in this discussion? ;-)
02:04:09 <jrockway> heh
02:04:10 <jrockway> "hi guys, how can i embed HTML directly into my haskell?"
02:04:32 <Grey_Fox> Use monads.
02:04:33 <catenate> String
02:04:33 <kmc> there's some preprocessor or quasiquoter for XML literals
02:05:22 <shachaf> Grey_Fox: "Hylomorphism-Transformative Monad Language"?
02:05:47 <catenate> @faq Is there a custom data type for XML documents?
02:05:48 <lambdabot> The answer is: Yes! Haskell can do that.
02:07:19 <Grey_Fox> @faq Can Haskell solve the halting problem?
02:07:19 <catenate> shachaf: sad part is that's just as foreign to most code monkeys who sling web pages as what it really stands for
02:07:20 <lambdabot> The answer is: Yes! Haskell can do that.
02:07:53 <kmc> catenate, really?
02:07:55 <catenate> My, that Haskell sure is clever.  For certain values of the halting problem.
02:08:22 <Grey_Fox> @faq can haskell give me everlasting happiness?
02:08:23 <lambdabot> The answer is: Yes! Haskell can do that.
02:08:28 <mauke> preflex: quote . halting
02:08:30 <preflex>  <mauke> I've solved the halting problem WITH A SHOTGUN
02:08:31 <theorbtwo> Sure it can solve the halting problem!  It just can't do it in polynomial time.  (But can you prove it?)
02:08:33 <kmc> it's true, ghc's runtime system can catch some infinite loops
02:08:50 <shachaf> @quote OlegFacts
02:08:51 <lambdabot> OlegFacts says: Oleg's first datatype in haskell started like this: data ChuckNorris ...
02:08:53 <Grey_Fox> That's awesome kmc
02:08:56 <shachaf> @quote OlegFacts
02:08:57 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
02:09:20 <kmc> i wonder how oleg feels about the little cult that's formed around him
02:09:24 <Grey_Fox> @quote OlegFacts
02:09:25 <lambdabot> OlegFacts says: Oleg's first datatype in haskell started like this: data ChuckNorris ...
02:09:34 <Grey_Fox> aww
02:09:38 <theorbtwo> Apparently, it's a very little cult.
02:10:47 <catenate> kmc: I don't know from experience about their HTML acronym-expanding ability, but statistically, half the population has an IQ below 100.
02:10:58 <shachaf> theorbtwo: At one point in the past people filled lambdabot with dozens of OlegFacts. But they most got lost when someone forgot to @flush.
02:11:02 <kmc> *shrug*
02:11:14 <kmc> it seems both easy and insignificant to know what "hypertext" and "markup" mean
02:11:15 <mauke> @quote OlegFacts
02:11:16 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
02:11:31 <Grey_Fox> Who's Oleg?
02:11:36 <shachaf> @where oleg
02:11:37 <lambdabot> http://okmij.org/ftp/
02:11:56 <kmc> but don't let me get in the way of you insulting vast groups of your potential coworkers
02:12:09 <somnium> <?haPHPell do UnsafeSQLOperation getFormData ?> 
02:12:44 <catenate> kmc: Well, I kind of meant it on a deeper level: why hypertext specifically, and what advantage does markup have over, say, wysiwyg web-page coding.
02:13:04 <kmc> ok
02:13:39 <franksh> why would ghc.exe's memory usage just increase and increase when it's compiling separate files? i mean at [450 of 641] (trying to compile qthaskell) it used 600MB, now it's at [581 of 641] and it's using 1.2GB..
02:14:08 <kmc> it keeps the interface files of things it's compiled in memory, for speed
02:14:33 <kmc> don't know if that's the specific issue
02:14:43 <kmc> you could use RTS options to tell it to garbage collect more
02:14:45 <catenate> kmc: Well, who would be here if they weren't a bit of a language snob?
02:14:50 <franksh> ok.. i've gotten an "out of memory" crash several times and had to restart it
02:15:04 <theorbtwo> You could also try seperate compilation.
02:15:07 <kmc> yeah, i am too catenate
02:15:08 <catenate> kmc: You can get a job just fine in Java
02:15:15 <somnium> catenate: language geeks?
02:15:28 <theorbtwo> catenate: But can you get a good job?
02:15:46 <catenate> Statistically I'm sure some Java jobs are good ones
02:15:59 <wli> Lottery odds. 
02:16:08 <catenate> I'm sure
02:16:40 <kmc> you can get a job where you're payed more than enough to cover living expenses, only work about 40 hours a week and get to sit inside in an air-conditioned room
02:16:48 <kmc> that's a good job by many standards
02:16:57 <theorbtwo> catenate: Yes, I'm sure there are some good java jobs, just as there are some good java programmers.  But the primary selling point of Java to componies is that it is easy to find people who have been taught Java.
02:17:10 <kmc> programming isn't an all-consuming intellectual/spiritual pursuit for everyone
02:17:15 <theorbtwo> It's a language for people who like to think of their programmers as replacable cogs.
02:17:36 <somnium> is that really the primary selling point? (Clojure, Scala, JRuby ...)
02:17:57 <theorbtwo> somnium: Those are good examples of languages that are not java, but share a runtime.
02:18:07 <kmc> it is nice that Java interops via JVM with some less archaic languages
02:18:22 <kmc> but the point of Java (the language, not the platform) is to bring everyone to the lowest common denominator
02:18:34 <catenate> There's a library out there, Functional.java I think, that gives you map and fold and stuff, but the contortions it make you go through, in application code to convince Java's type system it's all really okay, makes it too complex to slip in unannounced, or expect others to maintain.
02:18:52 <kmc> yeah
02:19:02 <kmc> that's a feature, not a bug, in the Java language design
02:19:05 <kmc> making it hard to be clever
02:19:21 <dobblego> catenate, the alternatives are even more complex
02:19:21 <kmc> so that you can hire people as replaceable components and get them up to speed quickly
02:19:59 <kmc> of course Java's definition of "clever" includes basic functional programming techniques known for 70+ years
02:20:13 <kmc> but this is probably a reflection of what the schools teach
02:20:49 <Saizan> well, java came before java schools, or not?
02:21:04 <kmc> schools were failing to teach FP before Java
02:21:13 <kmc> if basic FP is considered esoteric, Java needs to avoid it to fulfill its goal
02:22:08 * hackagebot explicit-iomodes 0.4.1 - File handles with explicit IOModes  http://hackage.haskell.org/package/explicit-iomodes-0.4.1 (BasVanDijk)
02:22:10 * hackagebot safer-file-handles 0.6.1 - Type-safe file handling  http://hackage.haskell.org/package/safer-file-handles-0.6.1 (BasVanDijk)
02:22:21 <somnium> http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
02:23:04 <catenate> What's interesting is that from what I hear, I got a better computer science education in 90-94 than kids get in java.edu these days. I learned lisp in an AI course, so got exposed to functional goodness.  I also taught myself Logo in middle school, so that broke the ice early, and I was probably more amenable to a Lisp course.
02:23:13 <Maxdamantus> I'd imagine one of the reasons they teach non-FP first is so people understand that computers ultimately work in sequence.
02:23:32 <kmc> they don't teach non-FP first
02:23:36 <Maxdamantus> Everything in Java is sequential
02:23:43 <kmc> good CS schools start with Scheme
02:23:46 <dobblego> they don't teach
02:23:51 <kmc> and cover both functional and imperative programming in Scheme
02:23:54 <dobblego> that's why I quit
02:23:55 <kmc> and several models for computation
02:24:42 <shachaf> Maxdamantus: Computers don't work in sequence.
02:24:58 <dobblego> neither is everything in Java
02:25:00 <catenate> Well... I'd say schools start teaching functional programming as soon as they teach side-effect free, referentially transparent arithmetic functions in grade school.
02:25:29 <kmc> to be fair the problem with java.edu is not just that they don't teach FP
02:25:29 <Maxdamantus> shachaf: a single-threaded computer program
02:25:34 <kmc> it's equally a problem that they don't teach computer architecture
02:25:52 <Maxdamantus> Ultimately everything works in sequence.
02:25:57 <kmc> having hired candidates for real-time high-performance C++ coding, the fact that they couldn't manage memory explicitly or reason about instructions and caches was a problem
02:26:04 <kmc> not understanding FP wasn't particularly
02:26:33 <shachaf> Maxdamantus: A *true* computer program works in sequence, huh? :-)
02:26:34 <kmc> (well, the people we hired could, but many of the candidates were disappointing)
02:26:47 <kmc> processors definitely don't work in sequence, these days
02:26:55 <shachaf> kmc: I am repeatedly understand that candidates being disappointing is a fact of life no matter what.
02:26:57 <Maxdamantus> shachaf: true?
02:27:09 <kmc> the instruction set abstraction is sequential, but the actual hardware is not even close
02:27:17 <kmc> and that's before you consider threading and multicore
02:27:26 <Maxdamantus> Computation is sequential.
02:27:37 <mornfall> Maxdamantus: Vaguely. :)
02:27:41 <kmc> what does that mean?
02:27:50 <dobblego> it's a projection bias, that's what it means
02:28:14 <Ke> since we are now all using IA64 the instruction set is not even virtually sequential
02:28:20 <Maxdamantus> When computation doesn't appear to be sequential, it's just abstracting the sequentiality away
02:28:23 <Maxdamantus> Like FP does
02:28:25 <Ke> with epic
02:28:30 <kmc> almost nobody uses ia64
02:28:32 <shachaf> Ke: Who's using IA64?
02:28:39 <Ke> !
02:29:06 <kmc> Maxdamantus, so my superscalar pipelined branch-predicting out of order processor isn't *really* parallel?
02:29:19 <kmc> it seems quite the opposite of what you said, the hardware is truly parallel, the sequential nature is the abstraction
02:29:55 <catenate> kmc: If it preserves data dependencies so the program produces the right answer then it's a little sequential
02:30:11 <kmc> yeah, it has sequential semantics with a parallel implementation
02:30:13 <kmc> like "par"
02:30:18 <theorbtwo> I program in much higher level languages then ia64.  Very rarely do I actually care precisely what the compiler that compiled my interpreter actually output.
02:30:18 <shachaf> catenate: You can't really pick and choose your abstractions like that.
02:30:27 <kmc> but i'm trying to get to the core of what Maxdamantus means by "really" sequential
02:30:28 <theorbtwo> Semantics are almost always more important then implementation.
02:31:00 <shachaf> theorbtwo: Ha, another sentence where both "then" and "than" can be valid readings (with appropriate puncutation added).
02:31:02 <kmc> is it "sequential in semantics, if not in implementation" or "sequential in implementation, if not in semantics"
02:31:16 <Maxdamantus> Fine, on single-processor non-pipelined branch-predicting systems
02:31:34 <catenate> shachaf: "When I use an abstraction it means just what I choose it to mean, neither more nor less."
02:31:38 <theorbtwo> Maxdamantus: You can still find those?
02:31:46 <kmc> well Atom is in-order
02:31:50 <kmc> and many embedded chips too
02:32:01 <shachaf> Maxdamantus: So, in other words, at your desired level of abstraction, which is higher than how computers actually work but lower than how anyone actually writes programs.
02:32:10 <kmc> if you want to argue that my ATtiny13A is "really sequential" you will not find disagreement from me
02:32:17 <Maxdamantus> I think they usually begin by studying the simpler processors
02:32:24 <kmc> except... well the counters and timers and the USART and etc. run in parallel ;)
02:32:43 <Maxdamantus> ie, the ones that aren't pipelined branch-predicting.
02:32:44 <shachaf> Maxdamantus: Weren't you just talking about why they teach Java?
02:32:51 <kmc> but your claim was "computation is inherently sequential" which seems quite different from "some simple processors are inherently sequential"
02:35:31 <catenate> At the gate level processors are massively parallel, always doing something with the current input. But in terms of math and matches being done over those gates, a lot of that inherent parallelism and constant activity disappears.
02:35:58 <kmc> yeah
02:36:25 <kmc> if you want to talk about the fundamental nature of computation, you have to consider theoretical models rather than implementation details
02:36:40 <kmc> and it's hard to argue that a denotational semantics for the lambda calculus is sequential
02:36:52 <kmc> especially with the church-rosser theorem
02:37:25 <catenate> The beauty of computer engineering is interpreting the pattern of high and low voltages over p- and n-doped metals as a half-adder.
02:38:15 <catenate> That's where the computer starts.
02:38:45 <Maxdamantus> Metals?
02:38:59 <Maxdamantus> nvm
02:39:15 <kmc> metalloids if you like
02:40:10 <catenate> semiconductors, to change state from conducting to not, in whatever materials they're using this year
02:41:21 <Saizan> i think it's more accurate to say that our brains have some hardware dedicated to the understanding of sequential processes, and that it seems quite easy to make it work.
02:41:52 <kmc> but we also learn early on to reason by equivalence and referential transparency
02:42:26 <shachaf> Saizan: If that's true, it's a bit ironic, given how parallel our brains are in their implementation.
02:42:51 <kmc> planning actions in the world is sequential
02:43:06 <kmc> but manipulating ideas is more denotational
02:44:45 <catenate> People manage complex interrelationships with other people better than they follow instructions.
02:45:49 <copumpkin> omnom
02:45:59 <copumpkin> it may almost be time for another monic sandwich
03:13:30 <somnium> hrm, I've never used Template Haskell before, but I'm trying to use fclabels, so I -XTemplateHaskell and import Data.Record.Label, ghc complains mkLabels is not in scope if I try $(mkLabels [''MyRecord])... any advice?
03:15:18 <kmc> somnium, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29042#a29042 works for me
03:16:07 <fasta> Is it possible to fix the position of a subset of nodes in graphviz and have the rest of the positions computed?
03:19:01 <somnium> kmc: huh, would it not work with ghci for some reason? (working without ghci in emacs seems terribly painful)
03:19:17 <fasta> The FAQ says I can.
03:22:01 <Saizan> copumpkin: monic?
03:22:13 <copumpkin> yeah!
03:22:23 <copumpkin> I got tired of epic ones
03:22:29 <somnium> argh, it does seem to be ghci's fault. cabal build had no complaints
03:22:38 <Saizan> ah :D
03:23:29 * hackagebot bits-extras 0.1.0 - Efficient atomic and non-atomic bit operations not found in Data.Bits  http://hackage.haskell.org/package/bits-extras-0.1.0 (GabrielWicke)
03:27:15 <somnium> aha! ghci only doesn't like it when I load the file with $(...) directly
03:27:20 <somnium> kmc: thanks again
03:30:24 <kmc> somnium, i was testing in ghci
03:30:33 <kmc> loading the file directly
03:30:36 <kmc> i have version 6.12.1
03:39:09 <somnium> kmc: ah, its the pragma. I wasn't using the pragma, I thought -XTemplateHaskell took care of it
03:40:03 <Baughn> Is anyone interested in/trying to make an XCB binding?
03:42:15 <Baughn> ..hm, it occurs to me that I should probably ask haskell-cafe. :P
03:42:54 <lantti> Mmm... cafe...
03:44:35 <ivanm> Baughn: methinks there is a bitrotted one floating around
03:44:42 <ivanm> xhb or some such
03:44:45 <ivanm> @google xhb
03:44:46 <lambdabot> http://finance.yahoo.com/q?s=XHB
03:44:46 <lambdabot> Title: XHB: Summary for SPDR Series Trust SPDR Homebuil- Yahoo! Finance
03:44:48 <ivanm> bah
03:44:50 <ivanm> @google xhb haskell
03:44:50 <lambdabot> No Result Found.
03:44:55 <ivanm> @google xcb haskell
03:44:56 <lambdabot> http://xcb.freedesktop.org/DevelopersGuide/
03:44:56 <lambdabot> Title: DevelopersGuide
03:45:07 <Baughn> ivanm: Ah. It didn't mention XCB, so..
03:45:14 <Baughn> Well, that does give me a place to start.
03:45:33 <Baughn> Are you sure it's bit-rotted?
03:45:43 <ivanm> well, never finished maybe
03:45:52 <ivanm> IIRC, the idea was to port xmoand to it
03:45:55 <ivanm> but it was never finished
03:46:05 <Baughn> The binding looks pretty large as-is.
03:46:25 <Baughn> Might be a good idea to start by the parts xmonad needs?
03:46:54 <ivanm> *shrug*
03:49:55 <juhp_> how do I darcs diff between two tags or patches?
03:50:38 <juhp_> "darcs diff --from-*=blah1 --to-*=blah2" doesn't do what i was hoping
03:50:44 <ivanm> #darcs ? :p
03:52:11 <juhp_> sure - thought it might be faq :)
03:52:24 <juhp_> kind of stunned that it didn't work...
03:52:25 <ivanm> I've never really worked out how to do stuff with tags tbh
03:52:32 <juhp_> ok
04:16:31 <Baughn> <Intel> Quantum tunneling is a problem.
04:16:35 <Baughn> ..modern CPUs really are getting /extreme/. I love it. :D
04:21:48 <Baughn> "Amongst other things, it provides a ‚Äú:vhdl‚Äù extension to the GHCi command line, allowing you to generate hardware designs from the GHCi prompt" <-- Well, this is.. neat.
04:22:03 <Baughn> This'll come in handy once I have a home foundry.
04:22:55 <bremner> fpga
04:23:35 <Baughn> I was actually serious.
04:23:41 <bremner> me too
04:23:52 <Baughn> Yes, but yours is obvious and doable right now. :P
04:24:19 <bremner> this word serious, I do not think it means what you think it means. :)
04:24:35 <Baughn> No, I'm pretty sure it does.
04:30:33 <fasta> Baughn, and when do you expect to have your own home foundry?
04:31:07 <Baughn> fasta: Two to five years after we have working, useful nanofactories.
04:31:26 <Baughn> I'd rather not specify when that might be.
04:31:36 <fasta> Baughn, is that the same as when hell freezes over?
04:31:47 <Baughn> fasta: Might be in four years or so
04:33:28 <Jafet> You can make your own little frozen-over-hell if you have a personal nano foundry
04:49:18 * Saizan points out that in some traditions the bottom of the hell is frozen
04:49:45 <Maxdamantus> Tradition?
04:51:29 <bss03> In "Inferno" is bottom layer of hell was frozen.: Satan is trapped within an icy cage of his own tears.
04:52:24 <bss03> In D&D (first edition), layer 6 (or was it 7) of the nine hells (a plane of existence) was frozen.
04:52:33 <Saizan> in the divine comedy it's frozen too
04:52:53 <bss03> Saizan: "Inferno" was the first part of the Divine Comedy, IIRC.
04:53:10 <Maxdamantus> Isn't "Inferno" just Italian for hell?
04:53:29 <Maxdamantus> So there are 9 (?) infernos in the comedy
04:53:44 <Saizan> bss03: ah, ok, i didn't realize you were referring to that :)
04:54:07 <bss03> "Inferno", .. something I can't remember... and "Paradisio", IIRC.
04:54:16 <copumpkin> Paradiso
04:54:19 <Saizan> inferno, purgatorio and paradiso
04:54:32 <Saizan> each of those is splitted in several zones
04:54:51 <Saizan> paradiso == heaven, purgatorio == ?
04:54:56 <bss03> Purgatory! Right.
04:55:02 * bss03 not very religous.
04:55:27 * Saizan neither
04:55:39 <Maxdamantus> Ah right, the first part is called "Inferno" which is made of 9 circles.
04:56:10 <bss03> IIRC, Purgatory is for Baptized Catholics that have not yet been absolved of all their venial (as opposed to mortal) sins.
04:56:20 <bss03> E.g. those that were not given the last rites.
04:56:41 <copumpkin> what sucked is that if you were born before christ, you went to hell anyway
04:56:55 <copumpkin> for not believing in a religion that hadn't been founded yet
04:57:03 <copumpkin> admittedly, the top of hell
04:58:32 <Saizan> the bright side is that those people didn't believe that :)
04:59:10 <somnium> I bet there are some particularly bitter guys who died around 1 BC
05:00:36 <bss03> I'm not sure all of the Divine Comedy is scriptually supported; I'm sure a lot of it was some creative fiction.
05:03:09 <bremner> unlike the bible
05:03:12 <bremner> (ducks)
05:03:13 <SubStack> fan fic
05:03:56 <Saizan> they revise some of the stuff from time to time anyhow :)
05:05:40 <SubStack> it's like punishing the haskell98 folks for not knowing how much records would blow in the future
05:05:43 <SubStack> actually
05:06:35 <Saizan> i like that records suck, actually, it scared away some rather annoying people :)
05:07:21 <Saizan> while simplifying the MonadZero affair too much is surely a sin! ;)
05:08:13 <SubStack> http://www.youtube.com/watch?v=qtp4xpVjTg4 # haskell powered rov
05:08:30 <SubStack> the video has nothing to do with haskell besides that fact
05:10:24 <SubStack> underwater rov, I should qualify
05:20:15 <siteswapper> @quote
05:20:16 <lambdabot> nomeata says: Haskell is basically Swiss: Small, Efficient, and it's fun to explore the higher parts.
05:49:06 <guybrush> sorry if this is a dumb question, but how can i quit ghci? http://en.wikibooks.org/wiki/Haskell/Variables_and_functions leaves me clueless
05:49:20 <Ke> ctrl+d
05:49:21 <Jafet> By entering your shell's end-of-input command
05:49:33 <guybrush> thank you
05:49:37 <Ke> :quit
05:49:49 <Jafet> Or (bonus points) crashing ghci
05:50:46 <Ke> killall -s 11 ghci
05:50:59 <moonmaster9000> :q
05:51:07 <SubStack> ^D
05:51:16 <ivanm> Ke: "killall ghc" isn't it?
05:51:21 <ivanm> since there's no actual ghci process...
05:51:40 <moonmaster9000> question: is there a GHC language extension that would allow me to break up function definitions like so? http://gist.github.com/524272
05:51:59 <Jafet> echo `where ghci` >> /etc/shells
05:52:04 <ivanm> I don't think so
05:52:17 <ivanm> and that is a PITA for readability purposes anyway
05:52:29 * ivanm hates it when libraries split the type sig from the definition
05:52:46 <Jafet> moonmaster: that would be impossible to implement
05:52:55 <Twey> import Unsafe.Coerce; (unsafeCoerce 3 :: Int -> Int -> String) 4 5
05:52:57 <Jafet> How would ghc know when you've defined a function
05:53:11 <Ke> System.system "killall -s 11 ghc"
05:53:28 <Ke> ghc is apparently the process
05:53:34 <Twey> It would have to do a pass for each function
05:53:44 <Twey> Ke: That won't necessarily just kill GHCi, though
05:53:53 <Ke> ivanm: yes
05:53:56 <Saizan> Jafet: it could scan the whole module :)
05:54:40 <Jafet> Impossible to implement, I say
05:55:11 <Saizan> anyhow, some prologs allow that with a warning (or if you turn on some flag?) so it's possible
05:56:08 <Saizan> moonmaster9000: i think you could do something like that with quasiquoting, but it'd probably be overkill
05:59:52 <moonmaster9000> k thanks. i'm building out a web dev DSL called "bird" where it actually makes more sense to group them together that way.
05:59:59 <guybrush> mh sry, but i have to ask another dumb question.. the example (Varfun.hs) doesnt actually work - isnt it?
06:00:13 <guybrush> http://en.wikibooks.org/wiki/Haskell/Variables_and_functions
06:00:32 <guybrush> i get `Couldn't match expected type `Double' against inferred type `Integer'`
06:01:17 <Botje> on what line?
06:01:32 <guybrush> area / r
06:02:50 <Botje> you're right
06:02:55 <Botje> area should be pi * r ^ 2
06:03:05 <Botje> that way area and r have the same type
06:03:36 <CakeProphet> is there a standard typeclass for types that can convert to Maps?
06:03:39 <guybrush> defining r = 5.0 works also
06:03:41 <tkahn6> can anyone help me understand what `instance Functor (Either e)` means (in terms of why that is valid and `instance Functor Either` is not)?
06:04:16 <sepp2k> Botje: That wouldn't work either, would it? x already has been defaulted to Integer, so you can't multiply x with pi
06:04:27 <sepp2k> Ehrm r, not x
06:04:50 <Botje> guybrush: i fixed the pag
06:04:51 <Botje> e
06:05:12 <guybrush> Botje: nice, ty
06:05:21 <guybrush> was about to register an account :p
06:05:26 <Botje> it's a wiki :p
06:05:29 <Jafet> We hope you enjoyed Act I, Scene i of "How I learned to stop guessing and love type signatures"
06:06:06 <Botje> sepp2k: if the compiler sees both r = ... and area = ... r ... in the same scope, it knows about the link between r and area
06:06:09 <blackdog> so, maybe a dumb question - is it safe to reinstall 'base' ?
06:06:27 <Botje> sepp2k: if you define hem separately (in ghci, for example) then it'll default, yes
06:06:31 <blackdog> for some reason, the ghc package for mac doesn't have dynamic versions of the libraries
06:06:43 <sepp2k> Botje: You do define them seperately
06:06:48 <sepp2k> r = 5 is in a file.
06:06:59 <sepp2k> pi * r^2 is in ghci
06:07:01 <Botje> sepp2k: and area is right below it
06:07:26 <Botje> or did you mean the first example? hmm
06:07:40 <sepp2k> Yes, I did.
06:07:48 <sepp2k> You're right. The second works now.
06:07:51 <Botje> sepp2k: it doesn't matter there
06:07:53 <Botje> :t (^)
06:07:54 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
06:08:31 <Botje> hmm
06:08:32 <Botje> or does it
06:08:34 <Botje> argh :)
06:08:42 <sepp2k> Botje: Why not? r^2 has the same type as r, i.e. Integer. And pi has Floating a => a
06:08:58 <Botje> no, you're right
06:09:00 <Botje> it errors
06:09:01 <Botje> sigh :)
06:09:21 <yokto> I have now read a lot about how you can pass pointers to C-Structs to C-functions - but can you call a C-function that needs not a pointer but the struct itself, if you have a Storable Type corresponding to that struct? or do you have to write a wrapper function for that in c so you can pass it as pointer?
06:09:27 <Botje> but the text below the example says "we now define r to be 5.0 and try it"
06:10:06 <Botje> passing structs on the stack doesn't sound like a good idea
06:10:23 <yokto> why not?
06:10:44 <Botje> some runtimes/compilers don't copy results back if you return them, for example :)
06:11:23 <yokto> copy back ??
06:12:22 <Botje> struct foo bar(struct foo in) { in.baz = 42; return in; }
06:12:48 <Botje> i think not all compilers support ..
06:12:54 <Botje> actually, bleh. they probably do now
06:13:14 <Botje> nevermind :)
06:15:06 <yokto> gcc -std=c99 -W -Wall compiles it without warning
06:15:16 <Botje> yeah, nevermind. i'm confused :(
06:15:40 <yokto> so is it possible to call such a thing in haskell with FFI
06:31:40 <CakeProphet> @pl retrieve k m = lookup k <$> readTVar m 
06:31:41 <lambdabot> retrieve = (. readTVar) . (<$>) . lookup
06:36:17 <guybrush> haha ^^ Approximately how many stones are the famous pyramids at Giza made up of? Use GHCi for your calculations.
06:36:28 <guybrush> http://en.wikibooks.org/wiki/Haskell/Solutions/Variables_and_functions --> TODO 
06:48:37 * hackagebot AC-Vector 2.3.0 - Efficient geometric vectors and transformations.  http://hackage.haskell.org/package/AC-Vector-2.3.0 (AndrewCoppin)
06:50:05 <jkramer> Ahoy
06:50:33 <jkramer> Is there something like heredocs in Haskell, probably with support for embedded code/variable evaluation?
06:52:52 <mrdk> If I do something like "(e, a, _) <- io $ readProcessWithExitCode "dmenu" ..." I get "waitForProcess: does not exist (No child processes)". Why that?
06:54:22 <Heffalump> jkramer: there's quasiquotation
06:57:00 <jkramer> Heffalump: That [foo||] stuff?
06:57:31 <Heffalump> jkramer: yep
06:57:41 * Heffalump hasn't used it so can't comment properly on the limitations
06:57:55 <Heffalump> but I think it's the most promising thing to look at for the requirements you describe
06:58:23 <jkramer> Thanks, will google
06:58:40 * hackagebot hircules 0.4 - IRC client  http://hackage.haskell.org/package/hircules-0.4 (JensPetersen)
07:00:55 <augur> anyone know of a good bottom-up parsing technique for a language with precedence that doesnt use precedence parens or backtracking?
07:06:55 <Baughn> Learn You a Haskell For the Greater Good?
07:07:09 <augur> what?
07:07:27 <digitteknohippie> thnx for the reminder to get back to reading thru it. ^_^
07:18:03 <dom96> hello, i am trying to generate docs with haddock and i get this message. haddock: can't find a package database at /usr/lib/ghc-6.12.1/package.conf.d. Anyone know how i can fix it?
07:25:48 * hackagebot AC-Vector-Fancy 2.3.0 - Fancy type-system stuff for AC-Vector  http://hackage.haskell.org/package/AC-Vector-Fancy-2.3.0 (AndrewCoppin)
07:35:17 <shapr> Good Morning #haskell!
07:35:37 <luite> good afternoon shapr 
07:40:04 <dh__> good evening, how can I implement a condition expression with Control.Arrow ?  cond p f g x = if p x then f x else g x 
07:40:35 <copumpkin> ArrowChoice ?
07:40:39 <dh__> yes. 
07:40:44 <dh__> but how ? 
07:41:58 <jkramer> I've just been wondering, is it possible to have a haskell program run forever (using `forever`)?
07:42:01 <Associat0r> http://www.coyotos.org/pipermail/bitc-dev/2010-August/002518.html
07:42:01 <dh__> copumkin : are you Daniel on twitter?
07:42:06 <copumpkin> dh__: yep
07:42:20 <jkramer> Theoretically, at some time there must be a stack overflow, right?
07:42:34 <copumpkin> dh__: check out http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/arrow-notation.html 7.10.2
07:43:00 <tkahn6> what is the use-case for a Functor being an instance of Applicative when that Functor isn't a collection. I understand why List would be an instance of Applicative but not why Maybe would.
07:43:18 <copumpkin> it's not about being a collection or not
07:43:53 <copumpkin> it's also a superclass of applicative, not an instance
07:43:59 <copumpkin> all applicatives are functors, but not vice versa
07:44:08 <tkahn6> right that's what i meant :)
07:44:23 <tkahn6> so what's the point of Maybe being Applicative?
07:44:30 <copumpkin> because it's very handy
07:44:33 <dh__> thanks copumpkin. I've read a few papers on Arrow, but I don't know how to convert a Bool to Either 
07:44:34 <copumpkin> and because it can be :P
07:44:46 <tkahn6> lol
07:45:03 <copumpkin> dh__: that section covers the translation :) they really just translate from the bool to the either in their if expression
07:45:06 <tkahn6> so you would never actually use Maybe with <*>
07:45:11 <copumpkin> tkahn6: sure you would
07:45:27 <copumpkin> >  (+) <$> Just 5 <*> Just 10
07:45:28 <lambdabot>   Just 15
07:45:29 <dh__> copumpkin: I don't want use the proc notation. 
07:45:30 <tkahn6> when?
07:45:47 <copumpkin> dh__: oh I know, just saying that that's how they translate if expressions in proc notation, and you can use that translation in your code
07:46:01 <copumpkin> tkahn6: say you had a bunch of numbers that might be absent
07:46:01 <dh__> thanks :)
07:46:13 <copumpkin> tkahn6: and you wanted to do arithmetic on them automatically propagating the Nothingness
07:46:18 <copumpkin> dh__: no problem!
07:46:26 <copumpkin> >  (+) <$> Just 5 <*> Nothing
07:46:27 <lambdabot>   Nothing
07:46:30 <copumpkin> magic!
07:46:34 <tkahn6> ah ok
07:46:51 <copumpkin> tkahn6: one way of looking at it is that the [] applicative gives you computations that can return 0 or more results
07:46:59 <copumpkin> and Maybe gives you computations that can return 0 or 1 results
07:47:19 <copumpkin> in fact, Nothing <=> [] and Just x <=> [x]
07:47:28 <copumpkin> :t listToMaybe
07:47:29 <lambdabot> forall a. [a] -> Maybe a
07:47:30 <dh__> copumpkin: what are those <$> and <*>?
07:47:33 <tkahn6> right that makes sense
07:47:35 <dh__> :t <$>
07:47:37 <lambdabot> parse error on input `<$>'
07:47:40 <tkahn6> <$> is fmap
07:47:43 <copumpkin> dh__: <$> is just fmap, but lives in Control.Applicative
07:47:55 <tkahn6> and it's infix :p
07:48:13 <copumpkin> dh__: <*> is slightly more complicated, but can be seen as taking a function living in an applicative functor and applying it to a value in that same functor
07:49:14 <huntse> :t (<$>)
07:49:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:49:23 <huntse> :t (<*>)
07:49:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:54:15 <dh__> which function has type a->[a] , and  return a list contain that element? 
07:54:22 <dh__> I know I can define it , 
07:54:28 <dh__> just wondering if it's already there.
07:54:42 <copumpkin> pure or return
07:54:48 <copumpkin> > return 5 :: [Int]
07:54:49 <lambdabot>   [5]
07:54:57 <Wooga> hello, my ghc suddenly started to produce very strange messages about linking if Data.Sequence is included and no --make flag specified: http://codepad.org/gu1i6yVe
07:54:58 <dh__> thanks
07:54:59 <copumpkin> > pure 5 :: [Int]
07:55:00 <lambdabot>   [5]
07:55:10 <copumpkin> pure is from Control.Applicative
07:55:40 <copumpkin> Wooga: it should always produce those messages if you don't specify --make and include external packages
07:55:50 <copumpkin> why wouldn't you specify --make?
07:56:03 <Wooga> copumpkin: but for i days it worked without --make
07:56:08 <Wooga> s/ i / a /
07:56:16 <copumpkin> Wooga: it really shouldn't...
07:56:34 <copumpkin> --make just tells it to take care of linking in external modules for you
07:56:47 <copumpkin> since Data.Sequence comes from another package, it needs to be linked
08:01:38 <hewei> ?
08:02:00 * hackagebot hircules 0.4.1 - IRC client  http://hackage.haskell.org/package/hircules-0.4.1 (JensPetersen)
08:08:46 <Wooga> copumpkin: thanks for explaining. i just worried if something suddenly broken
08:14:00 <gavilan> > 2 + 2
08:14:01 <lambdabot>   4
08:19:14 <copumpkin> "Also note that the type void should not be confused with the type unit in languages like SML and OCaml; the former is of size 0 while the latter is of size 1 (word)."
08:19:20 <copumpkin> from the front page of ats-lang.org
08:19:32 <copumpkin> where void is the return type of a function...
08:19:46 <copumpkin> seems like a weird thing to write, but he's probably talking about runtime representation?
08:25:09 * hackagebot pathtype 0.0.3 - Type-safe replacement for System.FilePath etc  http://hackage.haskell.org/package/pathtype-0.0.3 (BenMoseley)
08:28:39 <archguest> what editors do you guys find most helpful in editing Haskell code on linux?
08:29:35 <archguest> i'm running emacs with haskell-mode enabled and while i acknowledge being totally inexperienced in both emacs and haskell i can't say i'm very impressed with editing Haskell in emacs
08:29:47 <archguest> i was wondering if it is just me or there are better options
08:30:50 <huntse> 
08:30:52 <Wooga> archguest: i am using vim with haskell syntax highlighting and indentation
08:31:08 <huntse> I use vim
08:31:42 <huntse> ...but then I use vim for everything, so I'm not using it because I particularly find it good for Haskell.
08:32:08 <Wooga> i specially switched from gedit to vim when started coding in haskell
08:32:20 <Wooga> because i want layout indentation
08:32:35 <Wooga> like shifting to place after 'do' or 'if'
08:33:08 <Wooga> here is my indentation config (a bit edited by myself): http://codepad.org/2J2Z4wzK
08:33:15 <archguest> Wooga: thanks
08:33:21 <fasta> Wooga, Emacs also does that. 
08:33:32 <archguest> i find indentation painful in emacs
08:33:36 <Wooga> fasta: i didn't liked emacs when tried it
08:33:55 <fasta> Wooga, I also didn't like Emacs when I tried it the first time.
08:33:55 <copumpkin> I've found that in macvim at least, when I use haskell-mode it adds two big ugly menus at the top
08:33:58 <copumpkin> all uppercase
08:34:03 <copumpkin> anyone know how to turn that off?
08:34:04 <fasta> Wooga, some people don't like sex the first time ;)
08:34:25 <archguest> let's not turn it into emacs/vim argument please :)
08:34:31 <archguest> that was not the point
08:34:34 <fasta> No, I agree. Both work. 
08:34:55 <fasta> (to some degree)
08:35:12 <copumpkin> like, what the hell is this? http://snapplr.com/99f8
08:36:23 <burp> and some work better then the other ;)
08:36:31 <hpc> is that meant to be a horribly broken page?
08:36:48 <hpc> or is there some cross-site script getting blocked there?
08:37:07 <copumpkin> beats me, I just use it for screenshots :)
08:37:10 <hpc> heh
08:37:25 <CakeProphet> :t mapM
08:37:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:38:04 <copumpkin> :t mapM id
08:38:05 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
08:38:10 <copumpkin> omg!
08:38:11 <hpc> :t flip
08:38:12 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:38:35 <copumpkin> > mapM id [cos, sin] 1
08:38:36 <lambdabot>   [0.5403023058681398,0.8414709848078965]
08:38:49 <copumpkin> > flip [cos, sin] 1
08:38:51 <lambdabot>   [0.5403023058681398,0.8414709848078965]
08:39:26 <hpc> @let flipM = mapM id
08:39:27 <lambdabot>  Defined.
08:39:51 <copumpkin> lol
08:39:59 <CakeProphet> @hoogle member
08:40:00 <lambdabot> Data.IntMap member :: Key -> IntMap a -> Bool
08:40:00 <lambdabot> Data.IntSet member :: Int -> IntSet -> Bool
08:40:00 <lambdabot> Data.Map member :: Ord k => k -> Map k a -> Bool
08:40:16 <hpc> the types are not nearly polymorphic enough for my tastes, but meh
08:40:35 <copumpkin> :t Data.Traversable.traverse id
08:40:36 <lambdabot> forall (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => t (f b) -> f (t b)
08:40:47 <copumpkin> aka sequenceA :P
08:40:49 <drhodes> > mapM id (cos, sin) 1
08:40:51 <lambdabot>   Couldn't match expected type `[m b]'
08:40:51 <lambdabot>         against inferred type `(a -> a...
08:41:52 <hpc> . o O (if IO is somehow an instance of Traversable, it could be used as an escape hatch)
08:42:09 <hpc> wait, no it can't <.<
08:42:09 <drhodes> :t fmapM
08:42:11 <lambdabot> Not in scope: `fmapM'
08:44:03 <CakeProphet> :t any
08:44:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:56:19 <Alex4108> ??DCC SEND "ff???f?ùëπùë∞ùë∑ùë≥ùë∂ùë≥ùë∫ùëºùë∑ùëÆùëºùíÄùë∫" 0 0 0
08:57:31 <weihe> > :t (+)
08:57:33 <lambdabot>   <no location info>: parse error on input `:'
08:57:40 <copumpkin> fucker
08:58:12 <copumpkin> perspectival: you should fix that :)
08:58:29 <copumpkin> Gracenotes: same with you :P
08:59:32 <Gracenotes> omg
08:59:54 <copumpkin> Gracenotes: U GOT HAX3D
09:00:15 <Gracenotes> oh right. well tell people to stop DCC SENDing why don't you
09:00:43 <drhodes> is it possible to declare class instances on tuples?
09:00:48 <opqdonut> sure
09:00:56 <opqdonut> you might need FlexibleInstances
09:01:14 <copumpkin> only if you want to put constants in them
09:01:18 <opqdonut> yeah
09:01:21 <copumpkin> or unconventional instancey things
09:01:23 <drhodes> instance Foo (a,a) where, fails on a kind check because (I think) (a,a) is seen a construcor
09:01:26 <jkramer> Is there a list of "official" module namespaces to use for new modules, e.g. "Network." for network related stuff, etc.?
09:01:32 <opqdonut> if you're only instantiating (a,b) you're fine
09:01:41 <copumpkin> drhodes: what's the kind of Foo?
09:01:47 <copumpkin> "kind"
09:01:56 <drhodes> didn't think that mattered copumpkin 
09:02:16 <copumpkin> drhodes: you just said it failed a kind check :P
09:02:23 <drhodes> yeah, I know :)
09:02:43 <copumpkin> if Foo wants things of kind * -> *
09:02:47 <copumpkin> then you'd need ((,) a)
09:02:52 <copumpkin> etc.
09:03:00 <drhodes> but it was Show and Traversable.  So it won't have a problem with that syntax then. ok excellent, thanks!
09:03:17 <copumpkin> so Traversable wants * -> * and Show wants *
09:04:05 <drhodes> which explains the discrepency in jargon emitted.  It's kind of like an impenatrable wall of text.
09:04:26 <drhodes> (Still kind of like!) but getting better :)
09:04:31 <copumpkin> :)
09:21:49 <somnium> is it possible to write a function 'get
09:21:54 <somnium> ack
09:23:14 <somnium> get-in m [k] = m ! k; get-in m (k : ks) = get-in (m ! k) ks
09:24:08 <Lemmih> somnium: Not without some indirections.
09:24:11 <copumpkin> no
09:24:38 <somnium> hrm, and I was starting to think types were ponies
09:25:00 <copumpkin> in some languages you could do something like that :)
09:25:06 <copumpkin> but not for free
09:25:13 <somnium> Lemmih: what kind of indirections?
09:25:35 <somnium> in a dynamic lang its pretty easy 
09:25:49 <ClaudiusMaximus> i've used indirection like:  data Node a = File a | Dir (Map String (Node a))
09:25:59 <Lemmih> data ListOrElt a = Elt a | List [ListOrElt a]
09:26:33 <copumpkin> somnium: it's worth asking why you have arbitrarily nested arrays in the first place
09:26:39 * hackagebot ige-mac-integration 0.0.0.2 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/ige-mac-integration-0.0.0.2 (HamishMackenzie)
09:26:39 <copumpkin> somnium: and if you're just trying to approximate a tree :)
09:26:42 <somnium> ah ok, thats not so bad
09:30:30 <somnium> copumpkin: how is an approximate tree different from a tree?
09:36:23 <weihe> hi there, how can I achieve the sort of polymorphism at runtime, like virual functions (dynamic binding) in C++/Java/etc. please? 
09:36:41 * hackagebot gtk2hs-buildtools 0.11.1 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.11.1 (AxelSimon)
09:37:13 <Zao> weihe: Make types with a bunch of function members?
09:37:42 * hackagebot cairo 0.11.1 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.11.1 (AxelSimon)
09:37:44 * hackagebot glib 0.11.1 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.11.1 (AxelSimon)
09:37:46 * hackagebot gio 0.11.1 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.11.1 (AxelSimon)
09:37:46 <Zao> data Awesome = Awesome (Int -> String) (a -> Maybe b)
09:38:08 <Zao> let a = Awesome (show) (\x -> Nothing)
09:38:22 <weihe> How do I put these polymorphic things together ? Say, if I want to have a set of these things, what would be the type of that set? 
09:38:50 <Zao> Set Awesome
09:38:58 <Zao> Or [Awesome], if you really mean list.
09:39:09 <weihe> Then I need to use pattern matching?
09:39:16 <Zao> Or field accessors.
09:39:42 * hackagebot pango 0.11.1 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.11.1 (AxelSimon)
09:39:44 * hackagebot gtk 0.11.1 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.11.1 (AxelSimon)
09:41:12 <Zao> data Foo = Foo { bar :: T, baz :: T2 } -- let foo = Foo "asdf" "qwer" in (bar foo)  -- retrieves the bar field from foo.
09:41:28 <Zao> Compare to having a function-pointer member in C.
09:41:45 <somnium> copumpkin: in this case I dont really need it, it would just cut a little boiler plate. Then I realized it might not possible. Though I did use something like Tree a = Leaf a | Forest [Tree a] recently, which seems somehow similar
09:43:11 <copumpkin> somnium: it is basically the same :)
09:43:30 <copumpkin> except you were using arrays in the original example
09:43:45 <somnium> I was referring to Data.Map.!
09:44:26 <copumpkin> oh
09:44:42 <weihe> Zao: sorry, I did not make myself clear. In Foo, I want bar to be polymorphic, but do I have to provide the function everytime I create such a Foo?
09:46:09 <weihe> Zao: I think my question is more like: how is OOP's polymorphism handled in haskell's world. 
09:46:10 <somnium> copumpkin: I used it for a scheme pattern matcher (foo (bar ...) ...), weher it needs to follow ellipses to arbitrary depth
09:48:12 <Zao> weihe: I expect that by "polymorphic" you actually mean something like virtual function overriding in OO languages?
09:48:29 <FunctorSalad> weihe: if you'd like the function to be fixed to a type, you could use an existentially-wrapped typeclass
09:48:40 <Zao> weihe: There's a bunch of ways to do things like that, from things like typeclasses to simple things like function members.
09:49:05 <Zao> weihe: Here you'd probably have a makeFoo function that adds your default implementations.
09:49:29 <weihe> FunctorSalad: I think simple typeclasses wouldn't do. But something superior might do. I will take a look at existentially-wrapped typeclasses. 
09:49:50 <dh__> Hi, Zao, which country are you from?
09:49:57 <Zao> "my head just exploded"
09:50:00 <Zao> dh__: Sweden.
09:50:19 <dh__> Zao: you id sounds like a Chinese.
09:50:21 <Zao> And no, I do not speak chinese.
09:50:40 <weihe> dh__: Actually, I am from China. 
09:50:41 <FunctorSalad> class X a where x :: .... method signature ...     ; data AnyX = forall a. X a => AnyX a
09:50:44 <FunctorSalad> (@ weihe )
09:51:22 <dh__> weihe: really ? I 'm wondering how many Chinese like haskell , or knows
09:51:24 <Zao> And add instances for anything you want to be an X.
09:52:10 <ksf> hmmm doing the xmonad and just recompiling+restarting oneself is all nice and shiny, but just won't work out when there's sockets that shouldn't be dropped
09:52:35 <FunctorSalad> heh 'doing the xmonad'
09:52:38 <Zao> ksf: Farm such things off to something that you can reliably recommunicate with?
09:52:43 <gwern> does xmonad actually drop sockets?
09:52:51 <Zao> ksf: Or maybe look at how things like irssi handles reloads.
09:53:47 <alip> is there a way to get process status as an integer, as returned by waitpid(2)? getProcessStatus returns a ProcessStatus type which i don't think can be converted to an integer
09:53:51 <weihe> Zao: if I gave this type (X a) => [a] to my collection, then it can only hold one type inside class X
09:53:59 <ksf> and when I'm the server?
09:54:19 <FunctorSalad> weihe: that's why you'd use an existential
09:54:22 <ksf> imagine hotpatching ircd
09:54:24 <FunctorSalad> [AnyX]
09:54:28 <weihe> FunctorSalad: Thank you
09:54:40 <weihe> FunctorSalad: I am not sure about this. And you just pointed it out
09:54:41 <luite> hmm, leksah still segfaults on windows with the latest gtk2hs updates
09:56:53 <weihe> FunctorSalad: Do you know which library that uses this idea? I want to learn how it is done in pratice. 
09:57:46 <weihe> FunctorSalad: Actually, in xmonad-contrib, I saw some HList construct, which might be the existentially-wrapped ones. 
09:58:40 <ksf> HList is all about not using existentials but definitive types
09:59:31 <ksf> actually, HList is a misnomer 'cos haskell lists are supposed to support infinity.
10:00:58 <fasta> luite, I don't think it is news that leksah doesn't work :)
10:01:18 <FunctorSalad> weihe: hmm, using existential types is fairly common, but I don't know a particular library off-hand ;)
10:01:51 <FunctorSalad> using them together with a typeclass doesn't really add anything special over what Zao suggested (making the functions members)
10:02:19 <FunctorSalad> (except saving you from providing the function if you make an instance, yes)
10:03:07 <luite> fasta: fortunately I don't use it, but I still want to try it some time :)
10:03:28 <fasta> luite, yes, I tried a few previous releases too. 
10:03:38 <fasta> luite, imho, releasing something that doesn't work is a bad idea.
10:03:52 <FunctorSalad> (grep -E 'ExistentialTypes|GADTs|Rank[2N]Types' hackage? ;))
10:03:59 <hamishmack> luite: How did you install GTK?
10:04:12 <fasta> E.g. Yi does work, it just doesn't do everything (and this is clearly communicated). 
10:04:17 <luite> hamishmack: cabal install gtk2hs-buildtools, and then just cabal install leksah
10:04:34 <ulfdoz> Red nicht um den heiﬂen Brei. N‰chstes oder ¸bern‰chstes WE?
10:04:34 <hamishmack> luite: no I mean GTK not gtk2hs
10:04:39 <luite> hamishmack: if you mean the GTK libraries (and not gtk2hs), I just downloaded the complete gtk binary package
10:04:41 <ulfdoz> ewin, sorry
10:04:47 <luite> for windows
10:05:03 <hamishmack> luite: And gtksourceview?
10:05:25 <Zao> FunctorSalad: You do gain the ability to attach some more information to your "subclasses", but nothing you can't do with partial application really.
10:05:34 <luite> hamishmack: not sure about that, probably downloaded the binaries separately if they are not included
10:05:51 <hamishmack> luite: I would recommend trying TakeOffGW instead
10:06:15 <hamishmack> luite: It is working nicely for me.
10:06:50 <luite> ooh that looks interesting
10:07:38 <fasta> hamishmack, that _does_ look interesting, but since it is hosted on sf probably destined to fail. 
10:08:14 <fasta> Or not, they already have 900 packages. 
10:08:15 <luite> at least it has an automated installer
10:08:20 <hamishmack> they use SUSE for building
10:08:25 <luite> so you only need to grab the installer from sourceforge
10:08:36 <fasta> luite, if it does not crash, that's an improvement over everything else.
10:08:43 <hamishmack> luite: Its the cygwin installer
10:08:56 <fasta> I had to run the cygwin installer 3 times to complete my installation. 
10:08:59 <sjoerd_visscher> Hi all. Does anybody know where the gtk2hs cabal installer looks for gtk2hsC2hs?
10:08:59 <luite> hamishmack: yean I noticed
10:09:05 <luite> yeah
10:09:06 <hamishmack> luite: but set up to DL their mingw files
10:09:24 <luite> it wants to install in c:\cygwin :(
10:09:29 <sjoerd_visscher> Cabal put it in /Users/sjoerd/.cabal/bin
10:09:40 <luite> sjoerd_visscher: in your path
10:10:10 <weihe> Zao: Do you know any reading materials (book,link,code) about this approach please? 
10:11:36 <sjoerd_visscher> luite: ~/.cabal/bin is in my path
10:12:44 <Zao> http://www.haskell.org/haskellwiki/OOP_vs_type_classes
10:12:48 <Zao> Might be slightly informative.
10:13:26 <luite> sjoerd_visscher: hmm, strange, does your shell also find the program when you try to run it?
10:13:32 <weihe> Zao: Thanks!
10:13:43 <sjoerd_visscher> luite: yes, but which doesn't find it
10:14:08 <luite> maybe start a new shell?
10:14:12 <Zao> weihe: I've had better links in the past, but I can't recall the right keywords to grep for.
10:14:55 * hackagebot mandulia 0.7 - A zooming visualisation of the Mandelbrot Set as many Julia Sets.  http://hackage.haskell.org/package/mandulia-0.7 (ClaudeHeilandAllen)
10:16:23 <Associat0r> I think this is clearest http://www.scala-lang.org/node/114
10:16:46 <sjoerd_visscher> luite: Nope
10:18:30 <ClaudiusMaximus> sm: hopefully mandulia-0.7 fixes the OS X compilation issue you (and others) were having
10:18:41 <Associat0r> http://lambda-the-ultimate.org/node/4039
10:19:17 <luite> sjoerd_visscher: quite odd that 'which' doesn't find it. did you use export on the PATH variable?
10:20:15 <tkahn6> is this a correct implementation of the ((->) e) monad? if not, can you explain why? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29049#a29049
10:21:26 <copumpkin> tkahn6: yeah
10:21:35 <tkahn6> sweet!!!
10:21:41 <copumpkin> in fact, you can only write one meaningful implementation
10:21:50 <tkahn6> how do you mean?
10:22:06 <copumpkin> @djinn (c -> a) -> (a -> (c -> b)) -> (c -> b)
10:22:07 <lambdabot> f a b c = b (a c) c
10:22:19 <tkahn6> right that's how i derived it
10:22:37 <tkahn6> but doesn't that violate the type signature?
10:22:50 <copumpkin> no
10:22:57 <copumpkin> it was code derived from the type signature
10:23:26 <tkahn6> oh right
10:23:28 <tkahn6> that's what djinn does
10:23:30 <tkahn6> hmm
10:23:47 <Palmik> Hmm... I just stumbled on comparison of Clean and Haskell... are the Clean and Haskell community in similiar relation as C++ and Java community? I hope not :)
10:24:06 * hpc has never heard of Clean
10:24:06 <luite> in what sense similar?
10:24:30 <Veinor> tkahn6: I'd write 'pure = const' instead of 'pure g = \_ -> g'
10:24:40 <hpc> i think in the sense of C++ and Java groups hating each other :P
10:24:45 <tkahn6> @src const
10:24:45 <lambdabot> const x _ = x
10:25:06 <Palmik> luite, they would bash each other for any reason just to prove "their language" is better
10:25:13 <tkahn6> ah ok
10:25:23 <luite> Palmik: Clean programmers think that their language is so much faster since their rts is written in asm, and haskell programmers think their language is so much better and modern?
10:25:54 <chrisdone> I thought clean was pretty cool
10:25:56 <luite> hehe don't know about that, never heard Clean bashing here
10:26:00 <chrisdone> I'd like to understand uniqueness types
10:26:04 <sjoerd_visscher> luite: apparently ~/ doesn't work in PATH, expanding makes is work, thanks!
10:26:33 <Palmik> luite, me neither, but you do not hear java guys bashing on ##c++ either, he would not dare to step there usually... 
10:26:45 <Palmik> *they
10:27:30 <luite> I think that Haskell programmers are relatively open minded when it comes to programming languages, and they restrict bashing to languages that actually deserve it, like Java, C++ or PHP ;)
10:27:47 <Palmik> :D
10:28:13 <Palmik> Ok, that is somewhat reassuring and disturbing and the same time :D
10:28:18 <dankna> I'd certainly like to believe Haskellers are more open-minded.
10:28:36 <dankna> I've certainly never heard hate directed at Lisp, for example
10:28:44 <dankna> (from Haskell users, that is)
10:29:00 <Heffalump> dankna: that's because jdh hates us both (Lisp and Haskell) equally :-)
10:29:00 * hackagebot data-object-json 0.3.1.1 - Serialize JSON data to/from Haskell using the data-object library.  http://hackage.haskell.org/package/data-object-json-0.3.1.1 (MichaelSnoyman)
10:29:03 <dankna> haha
10:29:05 <dankna> I see
10:29:06 <Phyx-> i've directed my fair share of bashing towards Java
10:31:15 <hpc> Java's runtime used to be ahead of its time, to be fair
10:31:51 <EvanR> how >_<
10:32:17 <drhodes> time traveling processes with the delorean flux compiler
10:32:24 <EvanR> lol
10:32:39 <Phyx-> lol, marty
10:32:46 <Martty> what?
10:32:52 <Martty> 1.21 giggawatts?
10:32:57 <Martty> WHAT THE HELL IS A GIGGAWATT
10:32:57 <Phyx-> where's doc?
10:32:58 <Martty> DOC??
10:33:17 <Phyx-> Martty: you got some mad hoverboard skills
10:33:19 <EvanR> 1.21 jiggawatts
10:33:36 <Palmik> :D
10:33:42 <Martty> what
10:33:45 <Martty> isnt it giga.. ?
10:33:48 <Martty> gigabyte
10:33:54 <Martty> gigawatt!
10:33:55 <EvanR> gigawatt is a real word
10:34:01 <Palmik> RttF everywhere :P
10:34:01 <Martty> ahh
10:34:03 <EvanR> which is not used in that movie
10:34:17 <Martty> ahh so say giga but in the movie they say jjigga
10:34:28 <Martty> sorry im korean .. im not very good at pronouncing these things 
10:34:34 <EvanR> heh
10:34:40 <EvanR> yes gigawatt as in gigabyte
10:34:48 <EvanR> 10^9 watts
10:34:59 <winxordie> the term Jiggawatt was seriously used in the '50s, of this I am sure.
10:34:59 <EvanR> er 2^30
10:35:00 <EvanR> something
10:35:09 <dankna> 10^9 is correct
10:35:19 <dankna> 2^30 is "gibi"
10:35:19 <copumpkin> > 2^1251
10:35:20 <lambdabot>   387725688318327035081581783569011298515471154722076088388231111705437602835...
10:35:39 <EvanR> oh right no one does power in base 2
10:36:13 <Martty> is there an updater for the haskell platform?
10:36:37 <Martty> or do i just overwrite it ?
10:37:43 * EvanR checks to see how many jiggabytes are left on his partition
10:38:03 <EvanR> crap, 1.21
10:38:06 <dankna> fairly sure you just overwrite it
10:40:02 <monochrom> Kevin Jardine's "magic should happen" attitude has grown from annoying me to infuriating me. Waving his "this is a high level language" wand abusively.
10:43:50 <Martty> hmm, dankna doesnt seem like it. there will be 2 entries in the add remove programs menu in win32
10:47:56 <kmc> i don't think it's crazy to want a type that switches between internal utf-8 and utf-16 transparently
10:47:58 <gwern> @quote lollipop
10:47:59 <lambdabot> AlanPerlis says: 93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
10:48:17 <lispy> Do we have efficient data structures that do bi-directional maps (data structure for storing bijections) or best to use two Data.Map?
10:48:52 <EvanR> theres a bimap
10:48:52 <kmc> i think (outside specialized cases) such would be equivalent to two Data.Map
10:48:53 <Zao> kmc: It wouldn't be horribly hard to write something like that with a Data.Text interface?
10:49:07 <EvanR> http://hackage.haskell.org/package/bimap-0.2
10:49:07 <monochrom> I have only heard of using two Data.Map. But it's done and posted on hackage.
10:49:09 <kmc> i'm not sure how boost multi-index works
10:49:28 <monochrom> and yeah, it's probably called bimap there
10:49:30 <kmc> Zao, i don't see why
10:49:30 <gwern> I would be surprised if there weren't some sort of clever trick or algorithm to make a bimap better than a pair of maps
10:49:49 <lispy> EvanR: sweet! Thanks.  BTW, what came of your hdbc issue?
10:49:55 <Martty> what the crap
10:49:58 <Martty> the haskell platform is 1 GB?!?!
10:50:18 <gwern> ALL BATTERIES INCLUDED
10:50:31 <jmcarthur> it is?
10:50:34 <Martty> seriously
10:50:35 <Martty> lol
10:50:38 <jmcarthur> i didn't think it was that big
10:50:41 <Martty> me neither
10:50:43 <EvanR> the maintainer responded by email and we started to work it out, but so far he wasnt able to reproduce the bug on his OSX. his test case reproduces it on all my <4G machines, i suspect he has 6G or something
10:50:44 <gwern> jmcarthur: well, that's the slogna which I am ironically mimicking
10:50:46 <Martty> the previous release was half a gig
10:50:58 <gwern> Martty: maybe docs or profiling libs were added
10:51:14 <gwern> profiling is a separate copy, so regular+profile is 2x space
10:52:20 <chrisdone> my sysadmin went mental about installing the haskell platform and its gig size
10:52:36 <chrisdone> WHY ARE YOU INSTALLING OPENGL FOR A WEB SITE?
10:52:50 <EvanR> yeah
10:53:02 <monochrom> It is trivial to "switch between utf-8 and utf-16 internally" by switching to utf-16 always. This is what "other" "high" level languages such as Java do anyway. And Windows does it system-wide too. In Haskell terms, just stick with Data.Text, what's the fuss?
10:53:12 <ezyang> "clearly we should split up the Haskell Platform like the Sun JDK" 
10:53:14 <lispy> chrisdone: HP is for developers.  Why were you installing it on a server? :)
10:53:37 <chrisdone> lispy: it was the dev server :-)
10:53:41 <ezyang> Oh oops, I mean Oracle :-) 
10:53:59 <EvanR> installing haskell on our ubuntu server was a real bitch
10:54:18 <hpc> EvanR: you use ubuntu as a /server/?
10:54:23 <lispy> Am I the only one who preferred using Sun products because Sun was cool and now has started to avoid things that have been rebranded to Oracle just because, well it's Oracle?
10:54:24 <EvanR> i dont
10:54:26 <EvanR> they do
10:54:36 <hpc> yuck
10:54:39 <EvanR> long term support version
10:54:43 <rlnoob> hi how did you make this channel to popular? i mean haskell is not used so much but has the biggest programming channel here!
10:54:44 <winxordie> lispy: you're not alone. I did the same.
10:54:45 <EvanR> we also have SCO unixware
10:55:05 <kmc> rlnoob, Haskell is not used much, but its ideas are influential
10:55:06 <monochrom> rlnoob: by banning hostile people
10:55:11 <lispy> rlnoob: we try to be welcoming :)
10:55:21 <kmc> a lot of people want to learn about haskell to expand their abilities in other languages
10:55:23 <winxordie> "try" being used liberally of course :P
10:55:41 * chrisdone welcomes lispy despite already chatting to him
10:56:27 <copumpkin> rlnoob: in reality, 90% of the people in here idle, hoping to absorb haskell with no effort, and eventually give up and say that haskell is too hard :)
10:56:37 <Martty> oh man im so proud of my fac i can't hide it.. fac = 1 : [ a*b | (a,b) <- zip fac [1..]]
10:56:51 <kmc> Martty, you should run it for us with lambdabot
10:57:24 <chrisdone> :t zipWith
10:57:25 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:57:31 <Martty> knew it
10:57:34 <copumpkin> > let fac = 1 : [ a*b | (a,b) <- zip fac [1..]] in fac
10:57:36 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
10:57:53 <chrisdone> > let fac = 1 : zipWith (*) fac [1..] in fac
10:57:54 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
10:58:06 <Heffalump> rlnoob: I think mainly just by being friendly and helpful. It's very rare that anyone gets banned.
10:58:08 <Martty> ahh zipwith looks neat
10:58:12 <lispy> > try $ welcome "newbie"
10:58:14 <lambdabot>   Not in scope: `try'Not in scope: `welcome'
10:58:15 <hpc> > let fac = 1 : zipWith (+) fac [1..] in fac
10:58:15 <lambdabot>   [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,...
10:58:25 <chrisdone> hpc: :D
10:58:38 <kmc> i think people join to ask one or two questions, then they find it interesting and lurk
10:58:47 <kmc> i don't know what we do to keep more people on as lurkers
10:59:00 * EvanR starts lurking
10:59:09 <hpc> kmc: you talk about monoids over the category of endofunctors
10:59:13 <lispy> or they used to be lispers and when they started to learn haskell they found that the haskell community was way more alive and friendly :)
10:59:13 * EvanR lurk lurk lurk
10:59:16 <chrisdone> kmc: the most common thing said of Haskell is "I've been meaning to learn it for some time"
10:59:17 <hpc> kmc: we are a bottomless pit of compsci jargon
10:59:20 <copumpkin> RayNbow: an algebra in what sense?
10:59:26 <chrisdone> lispy: me too!!
10:59:31 <lispy> I also tried to learn #ocaml, but man....forget that.
10:59:31 <Heffalump> kmc: the channel has a lot of traffic as well as lurkers
10:59:32 <kmc> yeah chrisdone
10:59:33 <copumpkin> RayNbow: there are at least two definitions, and probably more
10:59:38 <lispy> #ocaml is down right hostile.
10:59:49 <hpc> kmc: and they can use it on the job to overwhelm their boss with genius
10:59:50 <Heffalump> I used to watch it continuously in the "good old days". I can't hope to do that now.
10:59:57 <chrisdone> lispy: really? I'd've thought the ocaml guys would be nice
11:00:02 <copumpkin> RayNbow: http://en.wikipedia.org/wiki/F-algebra and http://en.wikipedia.org/wiki/Algebra_over_a_field :)
11:00:15 <monochrom> F algebra
11:00:29 <copumpkin> monochrom: don't be rude
11:00:35 <copumpkin> algebra is nice
11:00:40 <monochrom> heh
11:00:42 <kmc> http://m.assetbar.com/achewood/uuafljZTN
11:00:56 <winxordie> copumpkin: algebra's nice until you try categorizing the finite simple groups :D
11:01:27 <monochrom> ‚ô• algebra
11:01:35 <copumpkin> that's more like it!
11:02:58 <lispy> chrisdone: there was one particular person in their irc channel (someone who is banned here) that makes it hostile.  I didn't realize that at the time.  I thought it was a reflection of the community.
11:03:14 <chrisdone> I suck horrabley at maths but at leest Im doing okey in other feelds
11:03:16 <lispy> Good researcher, bad social networker.
11:03:41 <chrisdone> lispy: not Smerdyakov per chance? he's a legend
11:04:17 <monochrom> yes it's him
11:04:20 <lispy> chrisdone: yeah
11:04:23 * chrisdone laughs
11:04:58 * hpc would like to hear this story
11:05:01 <chrisdone> yeah, he's like that guy who you chuckle at in social events but don't invite to your own get togethers
11:05:05 <monochrom> not the only hostile bannee, but the most famous, prominent, legendary.
11:05:22 <monochrom> (all the other bannees are not famous at all :) )
11:05:31 <kmc> plus he killed fyodor karamazov
11:05:33 <kmc> [spoiler alert]
11:06:08 * hackagebot isevaluated 0.3.0.1 - Check whether a value has been evaluated  http://hackage.haskell.org/package/isevaluated-0.3.0.1 (BertramFelgenhauer)
11:06:20 <lispy> Yeah, keal came out of nowhere with his craziness
11:06:20 <monochrom> well, famous prominent legendary in terms of academic achievement
11:06:22 <chrisdone> hpc: well, just a bit elitist and uncompromisingly frank and/or intolerant of those unwilling to think or figure things out for themselves, among other misgivings
11:07:18 * hpc thinks the last is not entirely unforgivable; take a horse to water, etc
11:07:23 <monochrom> I'm elitist too, but I don't have to respond to or even comment on stupid questions.
11:08:16 <monochrom> nothing wrong with elistist or frank. intolerance is bad. intolerence is intolerable. (paradox!)
11:08:34 <winxordie> kmc: I just started the Brothers Karamazov two days ago :(
11:08:47 <kmc> :( sorry
11:08:57 <winxordie> it's fine
11:09:00 <copumpkin> lol
11:09:07 <chrisdone> he actually criticised me once and it motivated me to try harder and I succeeded. but I'm happy with well meaning critique; some people just want people to be better. it can create a bad atmosphere in the wrong company though
11:09:12 <kmc> i think there's a statute of limitations on spoilers
11:09:14 <copumpkin> the world needs to know that kmc is a story spoiler
11:09:16 <kmc> for books more than 100 years old or so ;)
11:09:20 <winxordie> lol
11:09:32 <copumpkin> chrisdone: he seems comparatively personable in #coq
11:09:37 <monochrom> how a criticism is worded makes a whole world of difference.
11:09:38 <copumpkin> I also read his book
11:10:11 <kmc> http://www.penny-arcade.com/comic/2005/12/5/
11:10:32 <monochrom> plus a whole world of difference in adding spurrious comments like "this is the work of a single-cellular organism"
11:10:33 <chrisdone> copumpkin: yeah. that's not surprising, without sounding obnoxious, considering the high quality of people in #coq
11:10:59 <chrisdone> monochrom: hahaha
11:11:14 <monochrom> "you forgot to define f" is cool. "you forgot to define f. this is the work of a single-cellular organism" is ridiculous.
11:11:41 <copumpkin> monochrom: did he really say that? :O
11:11:49 <copumpkin> I never experienced him in here or ocaml :)
11:11:53 <chrisdone> Zhivago from ##c is notorious, and is on another level than Smerdy, but is equally personable when you're genuinely trying hard
11:12:06 <winxordie> kmc: if it was that popular I wouldn't blame ya :P
11:12:12 <monochrom> No. My imagination. OTOH, I do know people who speak like that. Mostly laypeople.
11:12:25 <copumpkin> laypeople need to get laid
11:12:49 <winxordie> I think most laypeople get laid
11:12:52 <hpc> laypeople do get laid
11:12:55 <winxordie> as opposed to you know, clergy and the like
11:13:03 <monochrom> Somehow, for 99% of the population, it is not enough to say "you forgot to define f", they have to add "you are a moron".
11:13:05 * hpc just noticed the pun
11:13:38 <Martty> C++ on freenode is pretty bad if i may add
11:13:41 <hpc> monochrom: you forgot to add "you are a moron". you are a moron :P
11:13:43 <Martty> i mean the channel
11:13:58 <monochrom> hahahehe
11:14:00 <Martty> PLEASE DONT CORRECT ME I REALLY MEANT THE CHANNEL IM NOT A SINGLE CELULAR BODY
11:14:24 <kmc> my experience in ##c++ was pretty bad but to be fair my questions quickly devolved into "why does your language suck so much and why do you distort reality in order to defend it"
11:14:25 <hpc> haha
11:14:26 <monochrom> ‚ô• Martty
11:14:38 <chrisdone> <Zhivago> You must be suffering from a head injury.
11:14:59 <Martty> well i've had good and bad experiences, i dont really mind the bad ones since its so easy to ignore people on irc
11:15:00 <kmc> i spent several days in ##c and answered a bunch of noob questions
11:15:02 <kmc> thought i was helpful
11:15:20 <kmc> and then one day i got something wrong about C99 VLAs and they flamed me to a crisp and said to gtfo
11:15:28 <chrisdone> ##c is plagued with newbies who haven't done any prior research or thought
11:15:30 <hpc> what's a VLA?
11:15:31 <kmc> who even uses VLAs
11:15:34 <kmc> variable-length array
11:16:11 <chrisdone> kmc: yeah, they're pretty precious about their c89 and c99 differences
11:16:18 <hpc> don't you have to do some ugly realloc shit to make VLAs work?
11:16:24 <Martty> chrisdone haskell has the advantage of not being a common first-language
11:16:29 <kmc> they don't vary over runtime hpc
11:16:32 <Martty> so most people who join here to ask already have a decent amount of prog experience
11:16:33 <copumpkin> hpc: nope, it's just alloca behind the scenes
11:16:38 <hpc> ah
11:16:43 <copumpkin> I use them :P
11:16:47 * copumpkin hides
11:16:55 <kmc> it's just that in C99 you can say ¬´int x[n];¬ª where n is not statically known
11:16:59 <Palmik> Martty, is there a better c++ channel somewhere? :) Not that I dislike ##c++ here that much...
11:17:03 <kmc> but this has various weird implications for sizeof() etc
11:17:05 <chrisdone> hpc: what does 'hpc' stand for. I can't help reading it as Haskell Program Coverage
11:17:13 <copumpkin> high-performance computing!
11:17:14 <Martty> Palmik i've only been on #c++ on quakenet and dalnet
11:17:14 <hpc> chrisdone: headprogrammingczar
11:17:19 <hpc> chrisdone: name i took a long time ago
11:17:22 <hpc> chrisdone: when i was very young
11:17:23 <Martty> Palmik they're both pretty small but good
11:17:41 <chrisdone> hpc: not as bad as my friend's, amod666  -- "arsenic man of doom"
11:17:45 <Palmik> Ok, will look at them, thanks :)
11:17:49 <hpc> heh
11:18:02 <hpc> i think "hpc" has a nice ring to it
11:18:14 <winxordie> HP-C
11:18:18 <Martty> hewlett pack card
11:18:23 <winxordie> HP's variant of C?
11:18:37 <Martty> chrisdone im afraid to ask about your nickname
11:18:38 <hpc> Captain Picard's first name needs to be Hewlett
11:18:43 <hpc> Hewlett Picard
11:18:56 <chrisdone> Martty: it's just my real name juxtaposed
11:19:05 <Martty> chrisdone you're done
11:19:11 * chrisdone facepalms
11:19:12 <chrisdone> don't start
11:19:14 <monochrom> chr is done
11:19:16 <chrisdone> I get enough of this at work
11:19:32 <Martty> ok i won't
11:19:38 <chrisdone> :p
11:19:41 <hpc> chrisdone: could be worse; when i am on steam i go by "Juzz", to mess with people
11:19:45 <int-e> chr is d(the?) one
11:20:36 * jmcarthur joins ##c++ for kicks
11:20:44 <chrisdone> it's like when you meet someone and discover they're called "Adolf", someone makes a joke and they grimace, after hearing it for the thousandth time
11:20:47 <dolio> kmc: I'd probably use that, but only because it's how I'd expect arrays to work from every other language on the planet.
11:20:58 <EvanR> jmcarthur: oh god xD
11:21:00 <EvanR> dont do it
11:21:11 <jmcarthur> should i troll?
11:21:12 <hpc> oh man, my mom used to complain about her boss, who was named "Dick Foote"
11:21:38 <chrisdone> jmcarthur: consider this: right now someone in #c++ is saying, /me joins #haskell for kicks \n should i troll?
11:21:40 <Palmik> jmcarthur, right now the "kicks" consist solely of leave messages :P
11:21:55 <jmcarthur> heh
11:22:01 <hpc> Palmik: or actual kicks :P
11:22:14 <Palmik> :D
11:23:34 * copumpkin lubes up his banhammer
11:23:43 <chrisdone> copumpkin: which end?
11:23:43 <copumpkin> bring it on, evil ##c++er
11:23:48 <copumpkin> chrisdone: the thicker one
11:23:53 <vanadium> What, are we invading ##c++ and upgrading their functors?
11:24:02 <copumpkin> vanadium: redefining them!
11:24:10 <int-e> redefining their concepts
11:24:13 <hpc> oh man, when i learned what C++ functors were i lol'd so hard
11:24:20 <dankna> what ARE C++ functors?
11:24:27 <copumpkin> function objects
11:24:28 <winxordie> there are functors in C++?
11:24:30 <copumpkin> wrappers for function pointers
11:24:31 <dankna> ahh
11:24:31 <jmcarthur> nothing interesting
11:24:35 <winxordie> oh
11:24:38 <dankna> sounds boring indeed :)
11:24:40 <kmc> they're not really wrappers for function pointers
11:24:42 <Martty> C++0x has lambda's
11:24:47 <kmc> they are closures
11:24:48 <Martty> the syntax is pretty ugly though :<
11:24:55 <dankna> ObjC has closures, sort of...
11:25:02 <vanadium> The name is more intuitive to a newbie for quasi-functions than for what you guys call functor, I think, though :V
11:25:02 <jmcarthur> it's understandable that the syntax is ugly though
11:25:03 <hpc> Martty: you say that like the rest of the language is prettier :P
11:25:12 <vanadium> Martty: lambdas are defined on top of their function objects, so it does not really count
11:25:13 <kmc> they are closures, where you're required to list all the free variables and their types three or four times
11:25:14 <Martty> hpc it can be quite elegant
11:25:14 <dankna> oh sure, nobody ever claimed Haskell was /intuitive/
11:25:27 <dankna> kmc: haha, I see
11:25:28 <Martty> vanadium "their" .. !!
11:25:29 <monochrom> only the nipple is intuitive
11:25:30 <jmcarthur> the way lambdas have to work in C++0x to fit the C++ philosophy is that the closures simply have to be explicit
11:25:34 <copumpkin> kmc: close enough :)
11:25:40 <chrisdone> dankna: which languages are intuitive?
11:25:45 <Martty> BASIC
11:25:48 <vanadium> Martty: I just pretend not to have three copies of the c++ standard on my harddrive while in here, okay :V
11:25:50 <hpc> LOL
11:25:50 <Martty> LOLCATs
11:25:56 <copumpkin> english and all the languages I grew up with
11:26:00 <jmcarthur> i think haskell is pretty intuitive
11:26:01 <Martty> vanadium :D
11:26:07 <dankna> I would argue strongly that English is not intuitive either :)
11:26:18 <copumpkin> (I was being silly :P)
11:26:19 <chrisdone> copumpkin: the programming language / natural language cross over jokes are always 100% hilarious and I laugh
11:26:23 <Martty> well at least when programming in BASIC you only need to know basic verbs and nouns
11:26:23 <dankna> I know, haha
11:26:26 <vanadium> I am not saying that C++ as a whole is intuitive, but function<->functor invokes some sort of association
11:26:28 <Martty> PUT 5 IN HERE
11:26:31 <Martty> AND ADD 5. PLEASE
11:26:31 <copumpkin> chrisdone: glad to hear it :)
11:26:40 <jmcarthur> i'm not normally one to troll, but im actually tempted
11:26:46 <vanadium> Too bad that "functino" thing never caught on.
11:26:52 <jmcarthur> actually i don't think i have ever trolled an irc channel before
11:26:53 <Martty> functino haha
11:26:58 <dankna> I like how Intercal requires you to say please, haha
11:27:01 <chrisdone> trolling is worse than sarcasm and practical jokes
11:27:06 <int-e> vanadium: but if you know functors from category theory and aren't so well-versed in overloading, confusion ensues.
11:27:15 <chrisdone> only funny for the person doing it, and generally twatty
11:27:21 <jmcarthur> chrisdone: isn't that what trolling is? ;)
11:27:27 <int-e> dankna: have you found the random compiler error, too?
11:27:31 <monochrom> ctor, dtor, functor
11:27:32 <vanadium> int-e: I suppose that means confusion ensues whether I know category theory or not, eventually
11:27:33 <dankna> no, I have not, do tell
11:27:39 <jmcarthur> copumpkin: :P
11:27:43 <Martty> jmcarthur no, troling is when you act like an idiot and think you are cool but everyone's just sad for you
11:27:53 <jmcarthur> Martty: that's one version of trolling
11:27:59 <Martty> jmcarthur i know no other
11:28:20 <chrisdone> all versions of trolling have the asshole factor in common, regardless of how funny it is
11:28:31 <jmcarthur> trolling is the subtle art of making people react to you in whatever fashion you desire
11:28:36 <int-e> dankna: with a certain probability, the intercal compiler would produce a program that, when run, would print <some number> RANDOM COMPILER ERROR
11:28:37 <copumpkin> trolling is a art
11:28:47 <gwern> Martty: I like the 4chan version - cost you your job and start a bunch of investigations of you
11:28:54 <jmcarthur> funny, they just said C++ doesn't have functors
11:28:55 <dankna> oh neat, haha
11:28:57 <gwern> 'one day, in prison, you'll look back on this and laugh!'
11:29:15 <jmcarthur> maybe they know what they are talking about after all :)
11:29:16 <chrisdone> jmcarthur's face right now: http://i21.photobucket.com/albums/b263/CWheezy/Trollface_HD.jpg
11:29:16 <EvanR> jmcarthur: though youll give haskell a bad name xD
11:29:19 <Martty> gwern im not an an expert in the field 
11:29:20 <vanadium> jmcarthur: I suppose it is somewhat of an inofficial term
11:29:28 <RayNbow> copumpkin: sorry for the late reply, lemme read the messages I've missed in this channel :)
11:29:35 <jmcarthur> chrisdone: that's my buddy icon on aim, actually
11:29:40 <EvanR> haha
11:29:53 <Palmik> It's used quite broadly I would say :)
11:30:22 <Palmik> Either he saw through you and knows ahat you are up to :P
11:30:25 <jmcarthur> chrisdone: i used the icon at my last job on the jabber server because i trolled the mailing list each april fools that came around :)
11:30:28 <Palmik> Or I dunno :)
11:30:36 <jmcarthur> and pidgin stuck it into my aim account too
11:30:58 <chrisdone> it's just one of those things, like sarcasm and practical jokes, where when people do it to you, you resent it. few people appreciate or tolerate it
11:31:11 <chrisdone> it's hypocritical to do it and be flippant about it 
11:31:28 <monochrom> I love sarcasm.
11:31:37 <jmcarthur> the guy in c++ actually identified functors as from category theory. i shall not troll. i would clearly be quickly identified
11:31:39 <somnium> how about adding a @troll plugin to lambdabot to ask random questions from faqs
11:31:44 <RayNbow> copumpkin: but apparently there is no definition that covers all possible definitions of algebras? :p
11:31:58 <int-e> monochrom: said sarcastically, I imagine.
11:32:17 <kmc> @protontorpedo
11:32:18 <lambdabot> its bs dude
11:32:20 <kmc> @protontorpedo
11:32:20 <lambdabot> smalltalk is oo
11:32:22 <kmc> @protontorpedo
11:32:23 <lambdabot> is functional progrmaming the same as object oriented?
11:32:33 <copumpkin> RayNbow: not that I know of :) ring/field/lie sort of fall under the same category of adding a bilinear operator to an algebraic structure, though
11:32:42 <somnium> nice :D
11:32:48 <kmc> @protontorpedo
11:32:49 <lambdabot> Im really only a bash person and even then Im tin
11:32:52 <jmcarthur> somnium: haha. it should store the questions people ask with @faq and recite them when you give the @troll command!
11:33:16 <copumpkin> that'd be neat :P
11:33:28 <monochrom> no, I love sarcasm. I do it often.
11:34:09 <Martty> @faq let usefulLanguages = filter (/=) "Haskell"
11:34:10 <lambdabot> The answer is: Yes! Haskell can do that.
11:34:15 <monochrom> And I like to see other people do it when appropriate.
11:34:45 <copumpkin> Martty: there are a few others :)
11:34:50 <jmcarthur> well, i'm not trolling ##c++ anyway
11:34:56 <copumpkin> I am!
11:35:01 <jmcarthur> i can't bring myself to be an asshole
11:35:02 <copumpkin> not very effectively though
11:35:07 <jmcarthur> copumpkin apparently has no problem with it
11:35:30 <EvanR> does haskell have adjuctions?
11:35:41 <monochrom> no
11:35:55 <jmcarthur> perhaps a very limited class of them?
11:36:08 <copumpkin> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Adjunction.html
11:36:11 <jmcarthur> category-extras has some type classes around adjunctions
11:36:18 <jmcarthur> yeah htat
11:36:20 <jmcarthur> *that
11:36:24 <monochrom> so limited, the pair merges into one, called a monad.
11:36:27 <chrisdone> monochrom: I prefer irony to sarcasm
11:37:11 <jmcarthur> well, i was talking about creating monads from their adjunct functors
11:37:20 <jmcarthur> not all monads in haskell can be created that way
11:45:41 <rlnoob> yeah haskell is very similar to c99 / c++
11:46:52 <dolio> I can barely tell the three apart.
11:47:18 <Zao> dolio: I just compile the same source with whatever compiler strikes my fancy today.
11:47:23 <Zao> They're after all interchangeable.
11:47:57 <reltuk> preferred pastebin?
11:48:18 <dolio> hpaste.ord
11:48:19 <RayNbow> @hpaste
11:48:20 <dolio> org
11:48:20 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:48:29 <RayNbow> hmm, link doesn't work
11:48:35 <Zao> instance Ord HPaste where ...
11:49:30 <reltuk> merci...
11:49:32 <reltuk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29050#a29050
11:49:37 <Phyx-> there's a prefered pastebin?
11:49:53 <reltuk> *shrug*, maybe?
11:50:16 <reltuk> I'm having trouble determining where I'm generating a large stack
11:51:29 <hpc> is there any performance overhead to getting and putting an mvar repeatedly?
11:51:37 <kmc> compared to?
11:51:49 <hpc> compared to not being threadsafe at all
11:51:53 <copumpkin> sure
11:52:01 <copumpkin> nothing is free :P
11:52:17 <hpc> i mean, noticable
11:52:32 <hpc> my irc bot goes from being very fast to doing 5 lines a minute
11:52:55 <copumpkin> why not a Chan?
11:53:17 <hpc> i just picked mvar
11:53:21 <hpc> ill check out chan
11:53:31 <kmc> atomicModifyIORef is faster
11:54:18 <hpc> i can't use that though
11:54:25 <hpc> my problem is primitive operations on Handle
11:54:54 <dolio> reltuk: It isn't really obvious to me, either.
11:54:57 <hpc> i have a thread that sends newlines every so often as a hack to detect a closed connection
11:55:12 <hpc> sometimes it puts the newline in the middle of another line and messes everything up
11:55:21 <hpc> usually during the ident process
11:55:43 <hpc> i have it delay the first fire for a minute, but that's not permanent
11:56:06 <kmc> you could make one thread responsible for writing all lines
11:56:11 <kmc> and send it lines in a Chan
11:56:32 <hpc> ah, cool
11:56:34 <reltuk> dolio: I think it might be IntSet.member...it's the only thing I can think of...but doesn't really make much sense...
11:56:42 <hpc> ill try that out
11:57:22 * hackagebot wai-extra 0.2.2.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.2.2.1 (MichaelSnoyman)
11:57:56 <tolkad> Hey, does haskell have mutable integrally-indexed tries?
11:58:01 <tolkad> unboxed
12:00:02 <kmc> interesting question
12:00:07 <ClaudiusMaximus> reltuk: i think it's here:  Data.List.maximumBy cmp xs        =  foldl1 maxBy xs   -- mightn't foldl1' be better (if such a thing exists)?
12:00:09 <kmc> why do you want a trie, over a flat array?
12:00:39 <dolio> Oh, yes, that's problematic if there isn't a rewrite rule.
12:01:06 <dolio> Are optimizations on?
12:01:42 <tolkad> kmc: only a few entries with wide ranging indicies
12:01:55 <kmc> ok
12:02:40 <tolkad> "few" being a relative term... copy on write would be inefficient
12:02:59 <kmc> well Data.IntMap is not copy-on-write
12:03:06 <reltuk> happens with optimizations as well...I'll try fold1'
12:03:10 <reltuk> foldl1'*
12:03:14 <kmc> there's not a complete copy when you update
12:03:27 <kmc> there's a copy only of the path from the root
12:04:09 <dolio> + balancing.
12:04:21 <kmc> does IntMap also balance?
12:04:21 <dolio> Oh wait, intset is a trie isn't it.
12:04:24 <kmc> right
12:04:49 <kmc> tolkad, i suspect that IntMap is fast enough
12:04:57 <kmc> if you haven't already benchmarked
12:05:23 <reltuk> that got rid of overflow :-)  thanks Claudius
12:05:23 <kmc> tolkad, or perhaps you could use the "judy" package
12:05:49 <dolio> It looks like there are no rules for maximumBy.
12:06:51 <dolio> There are rules for genericLength, though.
12:07:16 <reltuk> I don't really understand why the laziness causes a stack overflow
12:07:40 <dolio> Stack is used in GHC for evaluating nested expressions, not for function calls.
12:08:23 <dolio> So, that foldl builds up '(((x0 `max` x1) `max` x2) `max` ...)'.
12:08:32 <dolio> And then uses stack when trying to evaluate it.
12:08:42 <reltuk> so it just turns into a giant nested thunk...
12:08:46 <dolio> Right.
12:09:00 <dolio> foldl' keeps it evaluated, essentially.
12:10:18 <hpc> can reading and writing from a handle be safely done simultaneously?
12:10:26 <hpc> or should i use another chan?
12:12:03 * hpc uses hGetContents and hopes for the best
12:12:34 <dolio> If you use hGetContents, you probably won't be able to write to the handle.
12:12:42 <hpc> :(
12:12:54 <dolio> And you probably shouldn't anyway.
12:13:27 <dolio> Well, certainly you shouldn't on a handle you've called hGetContents with.
12:18:17 <hpc> so i guess, can you read and write at the same time?
12:18:51 <hpc> oh, what the hell?
12:18:55 <dolio> Probably, but I'm not sure I'd recommend that, either.
12:19:00 <hpc> googling "haskell handle read and write at the same time" yields the wikipedia article for perl
12:20:45 <dolio> Reading and writing to a file with a single handle sounds to me like you'd be doing random access stuff.
12:20:46 <FunctorSalad> hpc: it probably ignored 'haskell'
12:20:48 <FunctorSalad> :|
12:20:57 <hpc> haha
12:21:11 <FunctorSalad> I think it sometimes ignores one of the conjuncts, which sucks if that one's the whole point
12:21:22 <FunctorSalad> use "haskell" or so
12:21:29 <dolio> And I doubt there's a nice 'pure' way to do that right now.
12:21:32 <hpc> i think i just had too many words
12:21:52 <FunctorSalad> btw in my google it gives System.IO
12:22:13 <dolio> Oh, except, I seem to recall some random access stuff in Oleg's iteratee slides.
12:39:20 <spenca> hello all
12:39:45 <spenca> does anyone have an old runescape account they are no longer using?
12:39:53 <rlnoob> lol
12:40:10 <spenca> lol its for my little brother
12:40:17 <spenca> his was keylogged and stolen
12:40:31 <spenca> so does anyone have an account for me?
12:40:46 <dolio> preflex: seen monochrom
12:40:46 <preflex>  monochrom was last seen on #haskell 1 hour, 4 minutes and 22 seconds ago, saying: so limited, the pair merges into one, called a monad.
12:41:22 <spenca> dolio do you?
12:41:35 <spenca> how about you preflex
12:51:45 <Saizan> do any of the haskell webservers have a file upload demo?
12:58:41 * hackagebot cmdargs 0.2 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.2 (NeilMitchell)
12:59:25 <FunctorSalad> ^^^^ *hopes it has become pure*
13:00:02 <FunctorSalad> seemed like a pretty triggerhappy case for unsafePerformIO unless I'm mixing it up with some other package
13:00:23 <dolio> I'm pretty sure that's the one.
13:01:11 <FunctorSalad> (don't get me wrong, otherwise it's a good idea to make option parsing easier than the still somewhat annoying GetOpt)
13:01:30 <dolio> Yes, GetOpt is awkward.
13:02:08 <copumpkin> FunctorSalad: why?
13:02:13 <dolio> Wow, it's very different.
13:02:23 <copumpkin> it seems like a fine case for unsafePerformIO :P
13:02:42 * hackagebot improve 0.0.7 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.0.7 (TomHawkins)
13:03:21 <FunctorSalad> copumpkin: well, I read the types and can't make sense out of what it does by reading the types
13:03:24 <FunctorSalad> (in this case)
13:03:32 <FunctorSalad> because it seems impossible
13:03:46 <FunctorSalad> (because it is)
13:04:04 <orbitz> Is there anything in the std library for randomly sampling a list?
13:04:18 <FunctorSalad> copumpkin: but I'll admit that positional parameters are pretty pure
13:04:43 <copumpkin> his twitter said it was a complete rewrite
13:04:46 <FunctorSalad> (not sure if they can be mutated in general processes or whether 'set -- foo blah' is just a shell feature)
13:06:36 <orbitz> When organizing a library, do I have to do module X.Y.Z where or will the directory structure take care of that?
13:06:54 <FunctorSalad> you have to
13:07:11 <orbitz> is it suggested to mimic that in the idrectory structure?
13:07:19 <FunctorSalad> I just wrote a shell-script that does the opposite ;) (read the module name and go to the top dir)
13:07:33 <FunctorSalad> orbitz: hmm it's mandatory
13:07:44 <orbitz> so I have to do it in the directory structure AND file?
13:07:58 <FunctorSalad> yes
13:08:10 <FunctorSalad> except for executable main files
13:08:21 <FunctorSalad> it must match for everything that's imported
13:09:22 <orbitz> ok
13:12:06 * Phyx- never finds interesting questions he would like to answer on SO
13:12:55 <copumpkin> Phyx-: same here
13:13:09 <bremner> you two should post questions for each other
13:13:36 <Phyx-> lol
13:14:07 <monochrom> what is "SO"?
13:14:09 <Phyx-> after 3 months I only have like 265 points
13:14:15 <mornfall> monochrom: stackoverflow, presumably
13:14:20 <Phyx-> yeah
13:14:33 * syntaxglitch has too many points
13:14:54 <syntaxglitch> I really need to spend less time answering Haskell questions on SO and more time writing Haskell
13:14:56 <Phyx-> no such thing
13:15:18 <Phyx-> well, I usually don't see the point in adding answers to an already answered question
13:15:24 <Phyx-> and they get answered so fast :/
13:15:34 <syntaxglitch> depends on the answers
13:15:47 <syntaxglitch> usually not much point if there's an accepted answer
13:16:25 <syntaxglitch> but for a more open-ended question it never hurts to give an alternate approach
13:16:30 <Phyx-> i've also been the only one to answer on a question, with a correct answer, but the poster never came back i suppose
13:16:39 <syntaxglitch> or a more/less detailed answer than others, or whatever
13:16:49 <syntaxglitch> yeah, that happens
13:16:55 <gwern> Phyx-: 265? that's exactly 1 too many
13:17:21 <Phyx-> heh
13:17:29 * syntaxglitch waits to be able to say that his Haskell score on SO is OVER NINE THOUSAND
13:17:52 <Phyx-> rub it in :P
13:17:56 <Phyx-> e-peen :P
13:18:05 <gwern> winning on stack overflow is like winning the programming olympics; you're a winner, but still a programmer
13:18:34 <syntaxglitch> and noone will ever catch up with dons anyway, so winning isn't really an option
13:18:35 * gwern is all sensitive and avoids insulting the retards
13:18:42 <Phyx-> lol
13:18:50 <Phyx-> how much does dons have?
13:19:11 <syntaxglitch> like 1500 upvotes for Haskell answers or so, I think
13:19:17 <Phyx-> gwern: lol
13:19:39 <jtza8> Hi all.
13:19:49 <syntaxglitch> he doesn't quite have more points than everyone else combined, but probably close
13:19:52 <Phyx-> heh, 16.5k points
13:20:01 <Phyx-> jtza8: hi
13:20:33 <tolkad> why does the Foreign.Marshal.Alloc module use IO instead of ST?
13:20:33 <jtza8> I'm still pretty much a noob when it comes to pure functional programming, I'm wondering, though...
13:20:53 <Phyx-> lol, in 2 months Simon M is already at 1827 points
13:21:04 <syntaxglitch> yeah, big surprise there
13:21:36 <Phyx-> who know, he could give dons a run for his SO points then :P
13:22:11 <copumpkin> norman ramsey is way higher iirc
13:22:12 <syntaxglitch> I hope not, I'd rather Simon spend time working on GHC instead :P
13:22:17 <gwern> what syntaxglitch sez
13:22:31 <syntaxglitch> dons passed norman ramsey's score in the Haskell tag a while back
13:22:44 <Phyx-> hey, he needs to have fun too :)
13:22:55 <tolkad> Is there anyeway to use the Foreign stuff with ST instead of IO?
13:23:08 <copumpkin> tolkad: no, unless you convert it
13:23:16 <copumpkin> but then you get no safety beyond "I said so"
13:23:20 <copumpkin> in which case you might as well use unsafePerformIO
13:23:33 <copumpkin> tolkad: you seem to find the notion of pure programming unacceptable?
13:23:36 <copumpkin> :P
13:23:45 <Phyx-> tolkad: I've never used ST, but if it has a monadIO instance, just use liftIO
13:23:55 <copumpkin> every time you talk about haskell you seem to be mentioning unsafePerformIO :)
13:23:59 <copumpkin> or similar unsafe things
13:24:23 <Phyx-> who me?
13:25:04 <tolkad> copumpkin: the Foreign stuff looks perfectly safe
13:25:22 <tolkad> copumpkin: I'm curious why it doesn't already use ST instead of IO
13:25:43 <copumpkin> tolkad: o.O
13:25:43 <Phyx-> tolkad: because I assume that ST is a state transformer
13:26:01 <tolkad> I thought ST was used for memory and IO was used for input/output
13:26:17 <jtza8> If I were to use Haskel to build a game engine with (as I'm currently doing in Common Lisp), and I have a load of objects in it, i.e. characters, tiles, backdrops and sound, and collision detection with characters and objects... Would "pure functional" imply that I have to re-build the entire world, every frame, 60 times a second?
13:26:19 <copumpkin> it's not that simple, but foreign stuff can do anything
13:26:21 <copumpkin> including launching missiles
13:26:28 <copumpkin> so there's no way it can be stuck in ST
13:26:41 * jtza8 is sorry for spamming like this. :)
13:26:57 <hpc> jtza8: you have to do that anyway :P
13:26:58 <tolkad> so Foreign.Marshal.Alloc.malloc could launch missles? >.>
13:27:07 <syntaxglitch> jtza8, yes, with the caveat that you probably don't have to actually rebuild everything
13:27:08 <hpc> (rebuild the world every frame)
13:27:19 <tolkad> I think the behavior of malloc is specified by the C standard
13:27:29 <syntaxglitch> anything that changes needs to be rebuilt anyway, anything that doesn't change between frames can be reused
13:27:37 <jtza8> hpc: More like re-draw the world, IMHO.
13:27:39 <tolkad> and since GHC uses C as an intermediary when compiling it should follow that behavior
13:27:47 <copumpkin> tolkad: first of all, it doesn't
13:28:23 <hpc> jtza8: well it has to change somehow, and if you aren't duplicating it, you are writing back to it in place; the two are roughly the same, so far as time spent reading and writing RAM is concerned
13:28:33 <Phyx-> jtza8: those are the cases where you'd might want to use a mutable state, so you don't have to keep making copies
13:28:33 <gwern> 'Tupil is a Dutch company that built software for clients, written in Haskell. Tupil used Haskell for the speed in development and resulting software quality. The company is founded by Chris Eidhof and Eelco Lempsink. Currently they build iPhone/iPad applications in Objective-C.'
13:28:41 <copumpkin> tolkad: and what would malloc in ST give you? to make any use of it you'd need unrestricted pointer access, which would then let you do all sorts of evil
13:28:45 <gwern> another haskell success story!
13:28:50 <hpc> you don't have to make deep copies anyway
13:29:01 <hpc> data Foo = Foo {a :: Int, b :: Int}
13:29:02 <copumpkin> gwern: lol
13:29:15 <hpc> doing f {a = 2} keeps b pointing to the same Int
13:29:18 <Phyx-> gwern: the last part is a fail
13:29:23 <gwern> see diffs http://www.haskell.org/haskellwiki/Haskell_in_industry
13:29:29 <tolkad> copumpkin: oh yeah... didn't think of that, that's kind of an unthinkable thing to do
13:29:33 * gwern watches recent changes through rss for spam
13:29:45 <jtza8> Phyx-: I take it monads should suffice?
13:30:10 <copumpkin> tolkad: it's quite fine, if you're extra careful, but then you can unsafePerformIO or unsafeIOtoST. But in the general case, it's unsafe until proven otherwise, so we don't allow ST foreign calls
13:30:12 <Phyx-> jtza8: you could use a State monad yeah
13:30:34 * Phyx- was thinking move about a Ref
13:30:40 <copumpkin> tolkad: but also, GHC haskell doesn't compile through C by default (and will probably stop doing it altogether in a coming release)
13:30:42 <jtza8> Well thanks then, Phyx- hpc and syntaxglitch :)
13:30:44 <Phyx-> but i'm an unsafe person
13:31:04 <Phyx-> wha? no more C--?
13:31:13 <copumpkin> C-- is different
13:31:22 <tolkad> btw, does *alloc return a null pointer if the memory isn't available? as it does in C?
13:31:25 <Phyx-> it's still C flavored
13:31:29 <hpc> IORefs are required at some point, to move the world from the update callback to the render callback (assuming openGL)
13:32:02 * Phyx- stops trolling
13:32:04 <hpc> some sort of state machine monad for World is simplest
13:32:06 <Phyx-> I was bored, sorry
13:32:45 <tolkad> also, are there any thread safety concerns when using foreign pointers?
13:33:08 <hpc> there is always thread safety concerns when using pointers of any kind
13:33:16 <jtza8> I guess this is the perfect time to learn Haskell then :P
13:34:10 <jtza8> Well, thanks again for your time, bye. :)
13:34:43 <tolkad> hpc: what do you mean?
13:35:35 <hpc> i mean pointers break referential transparency
13:36:31 <arrummzen> In cases where speed is more important than efficiency, is there a way to override lazy evaluation and evaluate parameters eagerly on spare CPU cores even if they are unneeded? I have a large Haskell program which has recently been moved from a single core CPU to a machine with dual 4 core CPUs.
13:37:14 <hpc> x `par` y `pseq` f x y
13:37:18 <dons> yes, using `par` and other stratgies in the 'parallel' package.
13:37:30 <dons> values you might need later can be "sparked" to run on spare cores.
13:37:31 <tolkad> hpc: how does that apply to thread safety? does it mean that if I try to access and write to the opinter from multiple threads it could not work as expected?
13:37:45 <tolkad> s/the opinter/a pointer/
13:38:08 <hpc> tolkad: yeah, because the data inside can change when another thread doesn't expect
13:38:37 <dons> arrummzen: programming with speculative sparks is described in "Real World Haskell", btw. http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html#id675076
13:38:39 <tolkad> do how do I ensure thread safety?
13:38:43 <tolkad> so how*
13:38:57 <hpc> Control.Concurrency
13:38:58 <arrummzen> Is there a way to enable this without modifying the code? I've looked at par but it would require me to vastly modify the code to get what I want.
13:39:00 <orbitz> MACID seems...different
13:39:06 <Heffalump> tolkad: use locks or synchronisation of some form
13:39:07 <hpc> has various abscractions
13:39:20 <hpc> *abstractions
13:39:27 <rlnoob> *distractions
13:39:31 <hpc> haha
13:39:45 <dons> arrummzen: it shouldn't require vast modification.
13:39:59 <dons> its probably the cheapest known way to add parallelism without extensive mods, actually. 
13:40:14 <dons> find expressions, add `par` or `using` annotations to key recursion and branching structures
13:40:33 <dons> arrummzen: play with it a bit, and you'll get the sense of how it works. 
13:40:45 <dons> any other technique means rewriting the algorithms
13:41:03 <dons> here's a good tutorial http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/AFP08-notes.pdf
13:41:24 <dons> it should be possible to identify costly computations, add a `par` or two, and gain some speedups
13:41:35 <dons> you can use the ThreadScope tool to identify what each core is doing.
13:42:11 <arrummzen> So is there no tool or option to automatically add par where it might speed things up?
13:42:27 <hpc> that requires strictness analysis
13:42:31 <dons> that's an open research problem.
13:42:41 <dons> because to know where to put the `par` you have to know how expensive the computation is.
13:42:45 <dons> which means running it, in the limit.
13:43:02 <dons> it would be awesome if it was possible in general.
13:43:35 <dons> since it isn't easy in general, the next step is to let the user suggest likely points. which is what `par` is for.
13:44:41 <chrisdone> be nice to use par in a parser if you know certain parts don't overlap
13:45:01 <arrummzen> It would seem trivial to do automatically in a purely functional language like Haskell? Just use random parameters and PGO and take the N slowest functions?
13:45:39 <hpc> it might not terminate
13:45:43 <dons> you can certainly do it via profiling with inputs, yes.
13:46:25 <dons> there's a paper on this. Tim Harris and Satnam Singh, Feedback-directed implicit parallelism, in Proceedings of ICFP 2007 (to appear), January 2007
13:51:39 <napping> I just found you can write do {..;if c then _ else do {...;...}} without increasing the indentation
13:52:14 <napping> like, "if failCond then return () else do", then continue with more statements at the same indentation
13:53:52 <catenate> dons: Thanks for the link to the parallel tutorial. Oh, and thanks for the book.  I'm working through RWH with a study group at the web forum Linux Agora.
13:54:00 <Saizan> that might be the DoIfThenElse ext
13:54:11 <napping> no, that changes the if
13:54:21 <napping> so "then" and "else" may be written even with other do statments
13:55:58 <napping> the first token after do is labeled with {indentation}
13:56:15 <napping> first tokens on lines are not labelled with [n] if they open a new construct
13:56:18 <dons> catenate: nice!
13:56:53 <napping> wait, maybe this is an extension
13:57:40 <napping> oh, or it parses wrong :(
13:59:54 <napping> no, it does parse the way I want it to, which is different from the way the H98 report says it should go
14:00:54 <napping> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29051#a29051
14:00:56 <napping> return True
14:01:22 <napping> report suggests it should end up with an empty do
14:03:00 * Saizan wonders what's the type of an empty do
14:03:03 <Saizan> ?type do {}
14:03:05 <lambdabot> Empty 'do' construct
14:03:21 <copumpkin> ?type \x -> do x
14:03:22 <lambdabot> forall t. t -> t
14:03:58 <Saizan> napping: personally, i'd prefer that code to throw a compile error :)
14:04:27 <napping> I've been trying for ages to figure out how to write early esacpes without increasing the indentation level
14:04:42 <napping> various monads work, but with painful lifting
14:10:49 <Peaker> napping, What about guards? Or splitting to new definitions? Why do you find the lifting painful?
14:11:26 <napping> guards don't work if you need to compute in IO the values the test depends upon
14:12:40 <ddarius> napping: You could throw an IO exception.
14:17:09 <hpc> :t \x y -> do {x;y}
14:17:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:17:27 <hpc> copumpkin: interesting that yours is universal
14:17:52 <Eduard_Munteanu> Hi.
14:18:15 <ddarius> hpc: Why?
14:18:17 <ddarius> @undo do m
14:18:18 <lambdabot> m
14:18:34 <hpc> > do 5
14:18:35 <lambdabot>   5
14:18:37 <hpc> huh
14:18:50 <Phyx-> > mu
14:18:51 <lambdabot>   Not in scope: `mu'
14:18:54 <Phyx-> > mew
14:18:55 <lambdabot>   Not in scope: `mew'
14:19:06 <Phyx-> > squirtle
14:19:07 <lambdabot>   Not in scope: `squirtle'
14:19:36 <Saizan> there was a bug that imposed the type of "do .." to unify with "f a"
14:20:06 <Peaker> Saizan, Sounds like a reasonable specification.. why bug?
14:20:08 <hpc> huh, it works in ghc too
14:21:46 <Saizan> Peaker: well, the report specifies that do {<expr>} desugars to <expr>
14:21:48 <Phyx-> what does undo do again?
14:22:05 <hpc> @undo do {x;y}
14:22:05 <lambdabot> x >> y
14:22:12 <hpc> the do is just do
14:22:14 <Zao> Phyx-: Desugaring, it seems.
14:22:19 <hpc>  @undo is desugar
14:22:29 <Phyx-> aha
14:22:41 <hpc> there's also @do, which can be composed with @undo
14:22:44 <hpc> @. do undo
14:22:44 <lambdabot> ()
14:23:09 * Phyx- goes to buy skype credits
14:23:17 <catenate> One of the things I love about Haskell is that when I finally understand what I'm talking about in my program, the program finally compiles and works. :)
14:23:19 <Peaker> Saizan, I guess, but it still seems to make sense to have "do" mean monadic composition, even if it's just one value
14:24:06 <napping> that bug makes sense, ghc tries to do typechecking on surface syntax
14:27:05 * hackagebot yajl 0.3 - Bindings for YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-0.3 (JohnMillikin)
14:27:30 <gr00vy> hi
14:34:50 * syntaxglitch grumbles
14:34:53 <syntaxglitch> this code is still ugly :(
14:35:04 <ddarius> Stop writing it ugily.
14:35:52 <syntaxglitch> I bet it would be improved with some zygohistomorphic prepromorphisms
14:49:51 <tolkad> If I create a large vector, is the operating system likely to allocate it as I use it like it might with malloc? or will it all be allocated as soon as I create it?
14:50:38 <dons> what kind of vector?
14:50:42 <dons> Data.Vector.Unboxed ?
14:50:58 <dons> unless it is mmap-backed, or lazy, it will be allocated strictly in one go
14:51:51 <tolkad> oh. thanks.
14:52:36 <Heffalump> dons: allocated yes, but committed by the OS?
14:53:13 <Heffalump> unless GHC actively writes to the pages, I don't think it would be.
14:54:55 <tolkad> http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector-Mutable.html#v%3Agrow
14:54:55 <tolkad> what happens if you try to grow it longer than an Int? it specifies no such restriction... I guess it will work. I wonder what length will return then?
14:55:24 <copumpkin> longer than an Int?
14:55:34 <Heffalump> copumpkin: both new and grow take a size, specified as an Int.
14:55:35 <copumpkin> how can you encode "longer than in Int" in an Int?
14:55:52 <Heffalump> grow is the extra size, not the new size. So with multiple calls to grow, you could make the accumulated size overflow an int.
14:55:56 <copumpkin> oh, I see
14:56:20 <copumpkin> given that the length is represented internally by a int
14:56:26 <copumpkin> I imagine you'll get a negative length eventually :)
14:56:37 <copumpkin> of course, you'll probably run out of memory first
14:56:43 <luite> I don't think this will be a problem in practice though, since you're unlikely to be able to allocate such a large amount of memory
14:56:54 <Heffalump> should work on 64 bit platforms
14:56:57 <luite> > maxBound :: Int
14:56:58 <lambdabot>   9223372036854775807
14:57:14 <luite> oh lambdabot is 64 bit :)
14:57:24 <Heffalump> oh, yeah.
14:57:29 <luite> or at least its mueval
14:57:31 <Heffalump> I forgot Int would be larger too.
15:00:35 <Phyx-> > maxBound :: Int
15:00:36 <lambdabot>   9223372036854775807
15:03:34 <copumpkin> anyone use macvim and haskell?
15:04:52 <micahjohnston> are there any resources for learning readp?
15:07:25 <yitz> > length . takeWhile (> 0) . iterate (`div` 2) $ (maxBound :: Int)
15:07:27 <lambdabot>   63
15:07:28 <osaunders> copumpkin: I use TextMate but it's pretty terrible for Haskell.
15:07:38 <copumpkin> I use it too
15:07:47 <copumpkin> but wanted to try something else 
15:08:05 <Peaker> > logBase 2 (maxBound :: Int)
15:08:05 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
15:08:06 <lambdabot>    arising from a use of...
15:08:09 <osaunders> A lot of people use Emacs for Haskell, right?
15:08:19 <Peaker> > logBase 2 (fromIntegral (maxBound :: Int))
15:08:20 <lambdabot>   63.0
15:08:50 <yitz> Peaker: ew, FP
15:08:55 <luite> osaunders: yeah, but quite a few vim users too, according to some recent survey
15:08:57 <tolkad> how do I check if addition will overflow?
15:09:35 <tolkad> besides converting to a large type
15:10:47 <osaunders> tolkad: if a + b < max a b then "overflow" else "fantastic"
15:10:57 * syntaxglitch uses SciTE and a terminal window with GHCi running
15:10:59 <copumpkin> addIntC# :: Int# -> Int# -> (#Int#, Int##)
15:11:00 <copumpkin> :P
15:11:06 <copumpkin> tolkad: how do you do it in other languages?
15:11:14 <copumpkin> besides assembly
15:11:14 <yitz> tolkad: something like x > 0 && y > 0 && x - maxBound + y > 0
15:11:26 <syntaxglitch> or Notepad++ instead of SciTE, if I'm on Windows
15:11:35 <tolkad> copumpkin: never really had to, I mostly write PHP
15:11:50 <tolkad> not much mathematics in web programming
15:11:55 <yitz> tolkad: addition never overflows in PHP?
15:12:13 <syntaxglitch> vi and emacs both confuse me too much :(
15:12:33 <yitz> tolkad: in Haskell probably just as fast to convert to Integer though
15:13:24 <copumpkin> or you can wrap that primitive, if you really care
15:15:40 <ezyang> Does Cabal have a way of saying "Your package dependencies are not for the latest versions of THESE packages?" 
15:16:00 <ezyang> So if you're a good maintainer and are putting upper bounds, you can be continually bumping them as you test. 
15:17:02 <Phyx-> is.. there a way to read the information in a .HI file using the ghc api?
15:19:49 <monochrom> there is but I don't know how
15:20:23 <tolkad> copumpkin: it would be cool if there were a haskell function that checked the overflow bit on systems where that was available and otherwise did it like that
15:20:41 <copumpkin> hm?
15:20:43 <copumpkin> did it like what?
15:20:54 <tolkad> copumpkin: like x > 0 && y > 0 && x - maxBound + y > 
15:20:56 <copumpkin> I think most assembly languages support an add with carry operation
15:21:01 <tolkad> y > 0*
15:22:34 * Phyx- can just use ghc-pkg i think
15:22:40 <Phyx-> no... that no get my functions
15:23:04 <jdavis> Beginner question about typeclasses: How does "Show" know the name of the type it's showing?
15:23:37 <Martty> ok so i installed haskell platform 2010 but i had 2001
15:23:39 <Martty> 2009*
15:23:47 <Martty> so i uninstalled 2009 but now i lost my file associations!
15:24:12 <Martty> does the 2010 have some way to re-associate without re-installing?
15:24:17 <monochrom> Show does not know the name of the type it's showing.
15:25:31 <monochrom> perhaps reinstall 2010 to regain file associations
15:25:37 <Martty> ..!!
15:26:06 <monochrom> the uninstaller of 2009 was perhaps a bit na√Øve
15:26:25 <Martty> nah but there should be some simple way to re-associate
15:26:47 <Martty> or a note in the website "uninstall earlier versions before installing the new one"
15:27:27 * Martty re-installs
15:28:14 <micahjohnston> > (concat . zipWith replicate [1..]) "whoa"
15:28:16 <lambdabot>   "whhoooaaaa"
15:28:25 <opqdonut> dude!
15:28:41 <Raynes> dude!
15:28:43 <micahjohnston> > (concat . zipWith replicate [1..]) "dude!"
15:28:45 <lambdabot>   "duudddeeee!!!!!"
15:28:51 <jdavis> If I have "data Foo = Foo deriving (Show)" then I can instantly do "show Foo" and it will print "Foo". How does that work without explicitly defining the "show" function for type Foo?
15:29:08 <ezyang> jdavis: show is a function in a typeclass. 
15:29:16 <ezyang> deriving Show writes an instance of that function for Foo. 
15:29:49 <monochrom> "deriving" is built-in and has compiler support. Clearly the compiler can see it's called "Foo" and generate code to hardcode that name.
15:30:04 <jdavis> ezyang: ok, how does "deriving" know to define 'show Foo = "Foo"'
15:30:16 <micahjohnston> > (concat . zipWith replicate [1..]) "abcdefg"
15:30:18 <lambdabot>   "abbcccddddeeeeeffffffggggggg"
15:30:19 <monochrom> You may feel better to know that "deriving MyTypeClass" will not work.
15:30:22 <ezyang> jdavis: GHC magic! 
15:30:31 <ezyang> ACtually, it's part of the Haskell98 spec. 
15:30:39 <jdavis> ezyang, monochrom: Can I write other typeclasses that do similar magic?
15:30:44 <ezyang> Nope. 
15:30:48 <monochrom> You may feel better to know that "deriving MyTypeClass" will not work.
15:32:48 <Eduard_Munteanu> Some form of "deriving MyTypeClass" would be nice to do inheritance.
15:33:01 <opqdonut> no it would not
15:33:08 <jedai> jdavis: though you may use template haskell to achieve the same with somewhat less nice syntax
15:33:21 <opqdonut> custom deriving can be nice, but it has nothing to do with inheritance
15:33:21 <jdavis> Ok, thanks everyone. That makes more sense.
15:33:54 <monochrom> there is no inheritance to begin with.
15:33:57 <ezyang> generalized newtype deriving. 
15:34:04 <opqdonut> that's nice, yes
15:34:07 <ezyang> You can derive arbitrary typeclasses on newtypes. 
15:34:22 <Eduard_Munteanu> Ah, interesting, I'll take a look at that.
15:34:28 <jedai> jdavis: you can check out some solutions that attempts to do automatic deriving for some other typeclass and allow the same for your typeclass : Derive and Drift
15:34:50 <ddarius> @wn compossible
15:34:52 <lambdabot> No match for "compossible".
15:34:56 <jedai> ezyang: Well as long as the original type was an instance ;)
15:35:01 <monochrom> haha compossible
15:35:09 <ezyang> jedai: Sure sure. 
15:35:30 <ddarius> Apparently WordNet is not compossible with "compossible."
15:36:02 <dankna> @wn composable
15:36:02 <lambdabot> No match for "composable".
15:36:06 <dankna> @wn composeable
15:36:06 <lambdabot> No match for "composeable".
15:36:08 <dankna> hm
15:36:10 <dankna> owell
15:36:15 <monochrom> orwell
15:36:15 <jdavis> jedai: thanks.
15:38:18 <Martty> is there a function in the prelude for: a -> b -> a:b:[] ?
15:38:42 <copumpkin> no
15:38:56 <Martty> good
15:39:12 <copumpkin> indeed
15:39:29 <Eduard_Munteanu> Well, that doesn't make much sense.
15:39:52 <Eduard_Munteanu> Read "what type is a:b:[]?".
15:40:49 <Eduard_Munteanu> unless it's some a -> a -> [a] and defined by x : y : []
15:40:51 <copumpkin> I think we got what he meant :P
15:41:42 <Eduard_Munteanu> Eh, I thought he was indeed speaking of some sort of heterogenous lists.
15:42:00 <Martty> haha nah it was a definignature
15:42:45 <Eduard_Munteanu> Or a signifition :P
15:42:47 <dom96> how can i force ghci to recompile all modules that a file uses, whenever i try to load it with :l
15:43:17 <Martty> Eduard_Munteanu , thanks. but i prefer it my way
15:43:20 <tolkad> Eduard_Munteanu: a and b must be of the same type t, with the type of the expression being [t]
15:43:33 <Martty> (that was a lord of war quote btw)
15:49:21 <yitz> @djinn a->a->[a]
15:49:22 <lambdabot> Error: Undefined type []
15:49:57 <jedai> dom96: I don't think you can, you'll have to "touch" all those file yourself (or destroy all .o). But normally if a file has been modified in any way, he'll be recompiled which is what you want
15:50:21 <jedai> dom96: If this is not happening it's another problem
15:50:35 <jmcarthur> @pl \a b -> [a,b]
15:50:35 <lambdabot> (. return) . (:)
15:50:48 <EvanR> @pl f g (a,b) (c,d) = let (a',b') = g c d a in (a',b':b)
15:50:49 <lambdabot> (line 1, column 17):
15:50:49 <lambdabot> unexpected "="
15:50:50 <lambdabot> expecting variable, "(", operator or end of input
15:51:07 <EvanR> @pl \f g (a,b) (c,d) -> let (a',b') = g c d a in (a',b':b)
15:51:07 <lambdabot> (line 1, column 25):
15:51:07 <lambdabot> unexpected "("
15:51:08 <lambdabot> expecting "()", natural, identifier or "in"
15:51:18 <jmcarthur> ?
15:51:33 <EvanR> :\
15:51:35 <dom96> jedai: oh, i think i know what the problem is.
15:51:54 <jmcarthur> EvanR: i am confused about what you are going for
15:51:58 <EvanR> heh
15:52:18 <EvanR> a higher order function with no variables?
15:52:33 <jmcarthur> huh?
15:52:36 <EvanR> oops
15:52:38 <chrisdone> EvanR: what's f used for?
15:52:44 <EvanR> f shouldnt be in the lambda
15:53:01 <EvanR> @pl \g (a,b) (c,d) -> let (a',b') = g c d a in (a',b':b)
15:53:02 <lambdabot> (line 1, column 23):
15:53:02 <lambdabot> unexpected "("
15:53:02 <lambdabot> expecting "()", natural, identifier or "in"
15:53:09 <yitz> EvanR: hmm, but that shouldn't bother @pl
15:53:19 <jmcarthur> does @pl understand let?
15:53:29 <tolkad> I just tested it, on MAC OS X at least, it's safe to create huge vectors, they wont be immediately allocated and committed
15:53:30 <chrisdone> seemingly not
15:53:31 <jmcarthur> @pl \a b -> let x = a b in x
15:53:31 <lambdabot> id
15:53:35 <jmcarthur> sure does
15:53:36 <chrisdone> seemingly so
15:53:42 <ddarius> @pl doesn't parse all of Haskell 98.
15:53:43 <lambdabot> (line 1, column 33):
15:53:43 <lambdabot> unexpected end of input
15:53:43 <lambdabot> expecting white space or simple term
15:53:53 <chrisdone> @pl \(pat,pat1) -> pat
15:53:53 <lambdabot> fst
15:54:02 <dom96> Is there anyway i can remove packages that were installed using cabal?
15:54:03 <EvanR> @pl \g (a,b) (c,d) -> let (a',b') = g c d a in (a',cons b' b)
15:54:04 <lambdabot> (line 1, column 23):
15:54:04 <lambdabot> unexpected "("
15:54:04 <lambdabot> expecting "()", natural, identifier or "in"
15:54:12 <chrisdone> @pl \(pat,pat1',pat'') -> pat
15:54:13 <lambdabot> (line 1, column 12):
15:54:13 <lambdabot> unexpected ","
15:54:13 <lambdabot> expecting letter or digit, operator or ")"
15:54:13 <lambdabot> ambiguous use of a non associative operator
15:54:15 <Saizan> dom96: ghc-pkg unregister
15:54:15 <yitz> @pl \g (a,b) (c,d) -> (let (a',b') = g c d a in (a',b':b))
15:54:17 <lambdabot> (line 1, column 24):
15:54:17 <lambdabot> unexpected "("
15:54:17 <chrisdone> aha
15:54:17 <lambdabot> expecting "()", natural, identifier or "in"
15:54:25 <dom96> Saizan: thanks
15:54:41 <chrisdone> @pl \(a,b,c) -> c
15:54:41 <chrisdone> doesn't like this ^
15:54:41 <lambdabot> (line 1, column 6):
15:54:42 <lambdabot> unexpected ","
15:54:42 <lambdabot> expecting letter or digit, operator or ")"
15:54:42 <lambdabot> ambiguous use of a non associative operator
15:54:48 <Saizan> chrisdone: no triples
15:54:57 <chrisdone> weird
15:55:05 <jmcarthur> what's it gonna do with a triple anyway?
15:55:31 <yitz> @pl \g (a,b) (c,d) -> 5
15:55:32 <lambdabot> const (const (const 5))
15:55:36 <carter> copumpkin: you're working on hackage for the summer right?
15:55:42 <chrisdone> :t zipWith3
15:55:43 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
15:55:45 <yitz> @pl \g (a,b) (c,d) -> d
15:55:46 <lambdabot> const (const snd)
15:55:51 <copumpkin> carter: nope
15:55:57 <copumpkin> carter: you're thinking of Gracenotes 
15:56:03 <chrisdone> :t zip3
15:56:04 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
15:56:27 <Martty> > [1..10] == [1..10]
15:56:28 <yitz> @pl \g (a,b) (c,d) -> let (x,y) = g c d a in (x,y:b)
15:56:29 <lambdabot>   True
15:56:29 <lambdabot> (line 1, column 23):
15:56:29 <lambdabot> unexpected "("
15:56:29 <lambdabot> expecting "()", natural, identifier or "in"
15:56:36 <EvanR> @pl \g (a,b) (c,d) -> let x = 5 in x
15:56:36 <lambdabot> const (const (const 5))
15:56:39 <jmcarthur> @pl \g (a, b) (c, d) -> second (`cons` b) $ g c d a
15:56:40 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .) . flip ((.) . (.) . second . flip cons)) .) . flip . (flip .)
15:56:47 <jmcarthur> there you go
15:56:48 <chrisdone> wow
15:57:09 <chrisdone> where was the problem evanr's trying to solve?
15:57:12 <EvanR> still confused
15:57:15 <jmcarthur> that was it
15:57:27 <jmcarthur> :t \g (a, b) (c, d) -> second (`cons` b) $ g c d a
15:57:27 <chrisdone> :t cons
15:57:28 <lambdabot> Not in scope: `cons'
15:57:28 <lambdabot> Not in scope: `cons'
15:57:29 <yitz> @pl \x -> let (a, b) = split 3 x in b
15:57:30 <lambdabot> (line 1, column 11):
15:57:31 <lambdabot> unexpected "("
15:57:31 <lambdabot> expecting "()", natural, identifier or "in"
15:57:31 <jmcarthur> ha
15:57:36 <jmcarthur> :t \g (a, b) (c, d) -> second (:b) $ g c d a
15:57:37 <lambdabot> forall t t1 t2 b d. (t1 -> t2 -> t -> (d, b)) -> (t, [b]) -> (t1, t2) -> (d, [b])
15:57:51 <medfly> :t const
15:57:52 <jmcarthur> @. type pl \g (a, b) (c, d) -> second (:b) $ g c d a
15:57:53 <lambdabot> forall a b. a -> b -> a
15:57:53 <yitz> so it doesn't recognize tuples in let patterns.
15:57:54 <lambdabot> forall a a1 a2 b d. (a2 -> a1 -> a -> (d, b)) -> (a, [b]) -> (a2, a1) -> (d, [b])
15:58:01 <EvanR> ah
15:58:13 <yitz> on the LHS that is
15:58:13 <chrisdone> yitz: or triples in the function pattern
15:58:18 <medfly> ^^
15:58:18 <yitz> or triples at all
15:58:32 <jmcarthur> chrisdone: i wouldn't expect anyone to care if pl supports triples though
15:58:36 <Gracenotes> chrisdone: ah I responded to your comment bytheweh
15:58:42 <jmcarthur> unless you add fst3, snd3, and thd3
15:58:51 <chrisdone> Gracenotes: oh, on your blogmonster?
15:59:06 <Gracenotes> my blog would never hurt anyone :.
15:59:14 <wli> Make fst, snd, thd, etc. methods in typeclasses.
15:59:22 <yitz> jmcarthur: tuples in let pattern, otoh, would be nice to have
15:59:38 <jmcarthur> wli: might as well just use HList
15:59:43 <jmcarthur> yitz: yes it would
16:00:00 <wli> Every tuple has a first component, every tuple with two or more positions has a second, every tuple with three or more positions has thd, etc.
16:00:10 <yitz> oh horrors, HList in @pl, just imagine it...
16:00:10 <Martty> cmp' y x:xs
16:00:17 <Martty> why does this yield 'error in patter' ?
16:00:31 <yitz> Martty: parens around x:xs
16:00:34 <Martty> oh .. dont tell me its the parens..
16:00:38 * Martty facepalms
16:00:53 <chrisdone> Gracenotes: fair comments. I like the candidates idea
16:01:03 <FunctorSalad> wli: template haskle would work too, if the syntax wasn't so clunky
16:01:28 <FunctorSalad> $(nth 3 1)
16:01:29 <FunctorSalad> :)
16:01:32 <carter> copumpkin: oops. btw, you're at dartmouth? i'm starting at dartmouth cs this fall
16:01:42 <copumpkin> carter: hah, I just quit :P
16:01:47 <carter> ahh
16:01:49 <copumpkin> carter: undergrad or grad?
16:01:53 <carter> latter
16:01:59 <copumpkin> ah :)
16:02:08 <copumpkin> cool
16:02:15 <Adamant> copumpkin: what you working on these days?
16:02:23 <Adamant> just hackage?
16:02:27 <copumpkin> lol
16:02:27 <carter> prolly going to work with prof fleisher or winkler
16:02:29 <copumpkin> I'm not the one doing hackage
16:02:36 <Adamant> ah, ok
16:02:41 <EvanR> whats better, foldl or foldr
16:02:46 <copumpkin> Gracenotes: damn you with your cogracenotes :P
16:02:53 <yitz> EvanR: depends for what
16:02:56 <chrisdone> what's better, chocolate or candy?
16:03:01 <EvanR> lets say i dont care about the direction
16:03:03 <FunctorSalad> congraculations
16:03:03 <copumpkin> carter: ah cool, they both seem nice :) I haven't taken any courses with either though
16:03:13 <FunctorSalad> is what I kinda read
16:03:20 <monochrom> if you don't care about direction, foldl'
16:03:27 <EvanR> really? 
16:03:29 <micahjohnston> are there any resources for learning readp?
16:03:46 <EvanR> i guess theres no point in make it lazy
16:03:52 <chrisdone> Gracenotes: glad to have you working on Hackage, it's in good hands :-)
16:03:56 <EvanR> you cant use part of the answer before doing the entire fold
16:04:23 <yitz> EvanR: foldr is good if you need it to work even for infinite lists, or other situations where a lot of laziness is important. otherwise, use foldl'.
16:04:26 <carter> EvanR: the laziness bites in the foldr case, because you get a thunk that kills the stack
16:04:43 <EvanR> doesnt foldl do the same thing?
16:04:52 <tolkad> I don't understand data families. they are very confusing
16:04:52 <carter> EvanR: depends :)
16:05:04 <carter> tolkad: do you need them or are learning them for fun?
16:05:13 <EvanR> yitz: ah
16:05:17 <tolkad> carter: I want to use the vector stuff which uses them
16:05:30 <EvanR> yitz: eh, how would foldr work on an infinite list?
16:05:32 <Martty> i can't believe i just coded this right
16:05:39 <Martty> haskell surprises me with my own code
16:06:13 <EvanR> Martty: get used to it ;)
16:06:19 <monochrom> any more metaphysical questions?
16:06:35 <EvanR> foldr will diverge on an infinite list right
16:06:42 <Martty> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29061#a29061
16:06:55 <Martty> now please give me the obvious 1 liner solution
16:06:57 <monochrom> God, I should be careful what I ask for.
16:07:01 <yitz> EvanR: so for example, in the Prelude, concat = foldr (++) []. So you can concat an infinte list of lists, and start reading from the beginning without hanging.
16:07:15 <tolkad> are data families like paramatic types, except you need to write instances for them for specific types and you can also use them like classes if they aren't fully applied?
16:07:19 <EvanR> oh
16:07:33 <EvanR> duh
16:07:39 <dankna> monochrom: what is the nature of truth?  sorry, that's epistemology and you stipulated metaphysics, but...
16:07:57 <monochrom> perhaps "what is the nature of foldr"
16:08:05 <dankna> heh, indeed
16:08:07 <tolkad> dankna: no such thing, there is only what is percieved
16:08:16 <ezyang> tolkad: That seems... mostly accurate. 
16:08:27 <EvanR> confusion defused
16:08:29 <ezyang> Generalized newtype deriving doesn't seem to work for them, unfortunately. 
16:08:30 <dankna> I disagree profoundly, but I can't say I didn't ask for it, haha
16:08:36 <monochrom> "should I use cabal or gitit"
16:08:49 <Martty> no takers!?
16:08:53 <jmcarthur> monochrom: huh?
16:08:54 <yitz> tolkad: there is no such thing as epistemology because it is not perceived?
16:09:04 <monochrom> "when should I ask about another false dichotomy?"
16:09:21 <jmcarthur> oh
16:09:23 <chrisdone> monochrom: would you save your drowning wife or burning toast?
16:09:34 <tolkad> yitz: perception includes conception (mental conception, not child conception)
16:09:41 <FunctorSalad> should I ask about another false dichotomy or use the internet?
16:09:44 <yitz> tolkad: fair enough
16:09:46 <chrisdone> problem: the toast is gold toast, and its taste is really nice
16:09:52 <monochrom> drowning wife. so she will teach me how not to burn toast next time.
16:10:03 <chrisdone> wise
16:10:46 <Martty> map rescue (shuffle [wife, toast])
16:11:00 <Martty> ok i'll insist: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29061#a29061
16:11:07 <chrisdone> shuffle will always return the same result 
16:11:19 <chrisdone> in shuffle [wife,toast]
16:11:28 <chrisdone> Martty: I'm thinking about it
16:11:33 <Martty> oh ok
16:11:44 <Martty> finally i set to do something useful yet not so obvious!!
16:12:13 <monochrom> I am not sure what your code does. Can you write a specification?
16:12:23 <yitz> Martty: for starters, cmp' == zipWith (==) (except you forgot cmp' _ [])
16:12:33 <Martty> O_o
16:12:41 <Martty> monochrom does that mean my code sucks?
16:12:50 <chrisdone> I think it returns the longest match of two strings
16:12:52 <Martty> ie it should be easy to tell from the definition what it does
16:12:54 <monochrom> It means your code is more than 10 words long.
16:13:04 <Martty> hm ok here's the specification
16:13:08 <chrisdone> subc "beans cooked" "beans fried" = 5
16:13:16 <chrisdone> oh, 6 including the space
16:13:20 <Martty> no way
16:13:24 <chrisdone> oh
16:13:27 <Martty> it's supposed to count x in y
16:13:38 <chrisdone> oh, duh
16:13:41 <Martty> subc "penor" "my penor is a big penor" 
16:13:41 <Martty> 2
16:13:53 <chrisdone> subc "ab" "abceab" = 2
16:13:53 <EvanR> length (filter (==x) y)
16:14:09 <chrisdone> EvanR: no, it's counting sublists
16:14:15 <chrisdone> :t tails
16:14:16 <lambdabot> forall a. [a] -> [[a]]
16:14:17 <Gracenotes> subc "aba" "ababa"?
16:14:23 <monochrom> what about subc "aa" aaabaaaa"?
16:14:24 <Gracenotes> ah 2 then
16:14:31 <chrisdone> > tails "abceab"
16:14:32 <Martty> are you saying
16:14:32 <lambdabot>   ["abceab","bceab","ceab","eab","ab","b",""]
16:14:37 <Martty> oh my lord
16:14:37 <chrisdone> > inits "abceab"
16:14:38 <lambdabot>   ["","a","ab","abc","abce","abcea","abceab"]
16:14:54 <Martty> wait that won't do the trick i think
16:15:00 <ddarius> length . filter (x `isPrefixOf`) . tails
16:15:13 <Martty> that will 
16:15:19 <chrisdone> way to spoil it, ddarius :p
16:15:30 <Martty> in fact, i recall writting something like that myself
16:15:34 <monochrom> so much easier to skip the code and go straight to specification.
16:15:34 <Martty> some year ago.. 
16:15:40 <ddarius> That algorithm can be be made more efficient.
16:15:53 <Martty> every time i set out to practice some haskell i end up writting the same functions over and over again
16:15:58 <Martty> perhaps i should just write real programs
16:16:09 <ddarius> In fact, I highly suspect edwardk's monoidal stuff could be applied to it for that purpose.
16:16:11 <chrisdone> > let subc = length . filter (x `isPrefixOf`) . tails in subc "be" "That algorithm can be be made more efficient."
16:16:12 <lambdabot>   Couldn't match expected type `[a]'
16:16:13 <lambdabot>         against inferred type `SimpleRef...
16:16:17 <EvanR> Martty: how about a game?!?!??
16:16:23 <chrisdone> > let subc x = length . filter (x `isPrefixOf`) . tails in subc "be" "That algorithm can be be made more efficient."
16:16:24 <lambdabot>   2
16:16:58 <chrisdone> Martty: pretty sure subc exists in MissingH, everything does
16:17:17 <Martty> what's MissingG
16:17:18 <Martty> H
16:17:23 <Martty> anyways i just wanted to code it to learn
16:17:30 <chrisdone> if you think of a function, the MissingH author gets a nasty headache and sees visions of code and just starts typing at the nearest keyboard until a new MissingH upload happens
16:17:43 <chrisdone> http://hackage.haskell.org/package/MissingH-1.0.0
16:18:26 <Martty> i wonder which implementation is more efficient now
16:18:57 <ddarius> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/
16:21:31 <chrisdone> In the next post, we will compute the total length of ten9 without trying my patience.
16:21:31 <chrisdone> hehe
16:22:19 <Martty> why does +s give strange results seemingly randomly
16:22:35 <Martty> i get 0 secs 0 bytes 5 times .. the suddenly 0.02 secs 238947293723 bytes
16:22:48 <Martty> when evaluating the same expressing
16:22:53 <Martty> expression*
16:22:58 <Martty> then* ugh..
16:24:21 <chrisdone> garbage collection taking place?
16:24:29 <chrisdone> I don't know about that one
16:26:21 <Martty> it happens after a fixed number of times of running the same expression
16:34:16 <copumpkin> > sum [a,b,c,d] :: Expr
16:34:17 <lambdabot>   0 + a + b + c + d
16:34:21 <copumpkin> carter: ^
16:34:27 <copumpkin> (no simplification though)
16:34:42 <copumpkin> it can also do automatic differentiation but I can't remember the functions for that
16:34:49 <carter> gotcha
16:35:27 * ezyang really wants to see a linear algebra of types. 
16:35:34 <ezyang> It would be so awesome! 
16:35:51 <Kaidelong> how about getting rid of types and instead relying on preconditions and postconditions?
16:36:03 <ezyang> Kaidelong: I.e. assert()? 
16:36:16 <copumpkin> Kaidelong: what would that buy us?
16:36:39 <Martty> actually chrisdone , that version of subc doesn't "work"
16:36:54 <napping> Kaidelong: how is that not a type?
16:36:57 <Kaidelong> copumpkin: so long as the input that will be output by a function can be proven to be useful as an argument all the time it'll work regardless of the type?
16:37:00 <Kaidelong> I guess it is a type
16:37:04 <Martty> if you pass an empty list as the needle it returns the length of the haystack+1
16:37:13 <Kaidelong> but structural as opposed to nominal typing in a sense
16:37:19 <napping> I guess you could do something like falling back to an unpredictable and incomplete decision theory
16:37:30 <napping> er, not theory, a solver
16:38:12 <Kaidelong> I suppose the big argument you can make for nominal types is that they don't surprise the programmer
16:38:16 <Saizan> there's a thesis/system on something like that on top of types
16:38:32 <Saizan> but i don't remember the name..
16:38:44 <napping> data declarations create values in the first place
16:38:52 <Kaidelong> unless the programmer starts casting things
16:39:02 <Kaidelong> in which case I suppose the programmer could be surprised
16:39:06 <napping> it wouldn't be a small change to the language
16:39:11 <Kaidelong> but as far as I know haskell doesn't really allow that
16:39:41 <napping> you'd have to make one special built in type everything had to manipulate
16:39:57 <napping> like the cons | symbol | nil | bool | int | ... that scheme uses
16:40:00 <Saizan> http://www.cl.cam.ac.uk/~nx200/research/escH-hw.ps
16:40:19 <Kaidelong> broken link
16:41:51 <Saizan> http://scholar.google.com/scholar?cluster=2286051296363142827&hl=en&as_sdt=2000 <- one of these hopefully works :)
16:46:12 <Martty> > let d n (x:xs) = if n == 0 then (x:xs) else d (n-1) xs; d n [] = [] in d 4 "test"
16:46:13 <lambdabot>   ""
16:46:16 <iocor> does haskell have a way to get the raw bits of a float as an integer?
16:48:14 <copumpkin> unsafeCoerce ;)
16:48:33 <iocor> well
16:48:35 <iocor> that sounds friendly
16:48:39 <iocor> it even says "don't use me" on the tin
16:48:42 <dons> peek and poke via the FFI
16:49:40 <dolio> You shouldn't really use unsafeCoerce for that.
16:49:44 * hackagebot improve 0.0.8 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.0.8 (TomHawkins)
16:49:55 <dolio> dons' method is the safer (and slower) bet.
16:50:33 <Heffalump> dolio: I'd say unsafeCoerce on the unboxed rep is the right way to do it
16:50:44 <Heffalump> or use decodeFloat/encodeFloat to do it safely but slowly
16:50:49 <tolkad> how do I use mutable vectors thread safely?
16:50:58 <napping> that doesn't get you the exact bits, though
16:51:00 <dolio> Coercing the unboxed thing might be passable.
16:51:07 <dolio> A primop would be best.
16:53:31 <dolio> unsafeCoerce (from Unsafe.Coerce) can do some crazy stuff.
16:53:52 <dolio> Like, get you (I think) the bits of the pointers that GHC uses in boxed representations.
16:53:54 <tolkad> the googles do not favor me: http://www.google.com/search?q=haskell+vector+thread+safety
16:54:00 <tolkad> : (
16:54:24 <aristid> :t elem
16:54:25 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
16:54:38 <tolkad> :t a
16:54:39 <lambdabot> Expr
16:54:42 <aristid> is it just me, or is that parameter order unfortunate?
16:54:50 <tolkad> :k Bool
16:54:51 <lambdabot> *
16:54:55 <Kaidelong> tolkad: I'd say that unless you have to use it inside IO or ST it should be thread safe
16:54:57 <dolio> > 1 `elem` [1,2,3]
16:54:59 <lambdabot>   True
16:55:02 <tolkad> :k a
16:55:03 <lambdabot> Not in scope: type variable `a'
16:55:27 <tolkad> Kaidelong: you have to use mutable vectors inside IO...
16:55:29 <tolkad> or ST
16:55:42 <Kaidelong> I'd say mutable vectors in IO would not be thread safe
16:55:56 <tolkad> in what way? how do I use them safely with multiple threads?
16:56:13 <Heffalump> tolkad: you need to manage your own locking
16:56:26 <Heffalump> inside ST, they will be thread-safe but only because ST isn't multi-threaded
16:56:33 <tolkad> but what operations require locking?
16:56:44 <copumpkin> make a mutable boxed vector of mvars ;)
16:56:53 <Heffalump> anything you don't want to race
16:57:04 <aristid> flip elem [1,2,3] <- using flip makes me unhappy
16:57:19 <copumpkin> aristid: then use `elem` [1,2,3]
16:57:41 <aristid> copumpkin: ooh, will try if the code becomes nicer that way!
16:58:01 <tolkad> Heffalump: I can handle locking to avoid race conditions, I mean will using vectors across multiple threads cause unexpected behavior beyond happening at relatively unpredictable times
16:58:48 <aristid> @ty \s -> filter ((`S.notMember` s) . fst)
16:58:48 <lambdabot> forall a b. (Ord a) => S.Set a -> [(a, b)] -> [(a, b)]
16:58:56 <aristid> that looks good to me.
16:59:06 <tolkad> the word relatively in that sentence applies to "unpredictable times" not "unpredictable"
16:59:22 <Heffalump> tolkad: ah, I see, in terms of corruption to the internal representation
16:59:34 <tolkad> yes
16:59:38 <Heffalump> hmm. Dunno :-(
16:59:56 <copumpkin> the internal representation is just an array and some slice info at the beginning
17:00:01 <copumpkin> so I doubt it
17:00:13 <Heffalump> copumpkin: but the two could get out of sync. And what if you do a grow?
17:00:35 <copumpkin> growing them just gives you a new vector? or can you actually grow a mutable one "in place" ?
17:00:38 <Martty> how can i force evaluation of a function but actually discard its result?
17:00:47 <tolkad> in Java to ensure "thread safety" you just need to use certain wrapper objects
17:00:51 <Heffalump> Martty: a "pure" function?
17:00:56 <Martty> Heffalump yes
17:01:09 <Heffalump> tolkad: well, if you don't mind serialising access completely, you could use an MVar to control access.
17:01:20 <tolkad> Heffalump: I'd rather not
17:01:28 <Heffalump> Martty: seq, or rnf, depending on how much you need to do.
17:01:30 <tolkad> Heffalump: unless absolutely necessary
17:01:48 <Heffalump> tolkad: my uninformed guess would be that any operation that doesn't affect the size, will just be a write or read from the relevant bit of memory.
17:02:12 <Heffalump> So if you're working with single word unboxed data, or any boxed data, there'll be no corruption problems, and even if there are they'll just be mixed up data in that particular element.
17:02:24 <Heffalump> But if you do anything that mucks with the size, then all bets are probably off.
17:05:29 <Martty> Heffalump doesn't seem to work
17:06:43 <Heffalump> Martty: what does your pure function do?
17:06:56 <Martty> sort a list
17:07:33 <Heffalump> so how do you know it's being run/not run?
17:07:45 <Martty> because when i run it it takes like 1 minute
17:07:48 <FunctorSalad> suggestion for shorter name of liftM2: s
17:08:11 <Heffalump> Martty: which did you use, seq or rnf?
17:08:15 <Martty> seq
17:09:02 <Heffalump> ok, that probably won't force it enough
17:09:04 <Heffalump> rnf will
17:09:16 <FunctorSalad> oops, that'd be (<*>) not liftM2 *confuses self*
17:10:12 <aristid> FunctorSalad: the name of ap is too long?
17:10:14 <FunctorSalad> > liftM2 ($) (+) negate 7
17:10:15 <lambdabot>   0
17:10:37 <FunctorSalad> aristid: yeah for 'ap' my case sucks, liftM2 is the one needing abbreviation
17:10:39 <ddarius> rnf is the work of the Devil.
17:10:53 <aristid> FunctorSalad: why?
17:11:00 <FunctorSalad> > ap (+) negate 7
17:11:02 <lambdabot>   0
17:11:06 <FunctorSalad> aristid: because it's too long
17:11:07 <FunctorSalad> ;)
17:11:30 <aristid> FunctorSalad: use liftA2, the A looks less heavy than the M ;)
17:11:38 <FunctorSalad> indeed
17:11:48 <Martty> Heffalump that worked, thanks
17:11:52 <FunctorSalad> it really feels shorter
17:11:59 <dobblego> you can use (<$>) and (<*>) which I think are too long in their name
17:12:49 <FunctorSalad> they're ok except if you need prefixity
17:13:01 <dobblego> f ‚àò a ‚çü b
17:13:27 <FunctorSalad> (oh and \g f x -> g <$> f x needz name too)
17:13:28 <dobblego> [| f a b |] -- would be nice :)
17:13:57 <dobblego> we call that ‚àò‚àò on a Scala project
17:14:04 <FunctorSalad> :)
17:14:10 <aristid> @pl liftX2 f a b = f `xFmap` a `xAp` b
17:14:10 <lambdabot> liftX2 = (xAp .) . xFmap
17:14:16 <FunctorSalad> you actually use \circs?
17:14:21 <dobblego> yes
17:14:40 <aristid> :t fmap (<*>) fmap fmap
17:14:41 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => ((a -> a1 -> b) -> a) -> (a -> a1 -> b) -> f a1 -> f b
17:14:45 <ddarius> Agda: A Read-Only Language
17:14:56 <aristid> :t fmap (fmap (<*>)) fmap
17:14:56 <lambdabot> forall (f :: * -> *) a b a1. (Applicative f) => (a1 -> a -> b) -> f a1 -> f a -> f b
17:18:27 <syntaxglitch> okay, next up: make a game in Haskell that *doesn't* suck
17:18:38 <ClaudiusMaximus> Data.LargeWord.Word256 from Crypto package looks like what i want, except that that implementation doesn't provide quotRem :(
17:18:47 <dobblego> my children think ghci is a game
17:19:06 <Phyx-> dobblego: what do they play in it?
17:19:36 <syntaxglitch> I guess you could pretend that GHCi is some sort of roguelike
17:20:29 <medfly> haha
17:20:32 <etpace> > let makeList x = [x]; h x = makeList (makeList x) in h 5
17:20:33 <lambdabot>   [[5]]
17:20:57 <etpace> > let twice f x = f (f x); makeList x = [x] in twice makeList 5
17:20:58 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
17:21:05 <medfly> dobblego, because you play so much with it?
17:21:09 <etpace> any reason why the latter doesnt work but the former does?
17:21:13 <dobblego> they do things like writing quickcheck tests that "adding two even numbers is always an even number"
17:21:20 <medfly> awww
17:21:22 <medfly> that's so cute
17:21:25 <dobblego> no because they say things to me, so I tell them to prove it
17:21:55 <dons> nice
17:22:13 <dons> syntaxglitch: what about 'nikki and the robots' ?
17:22:14 * syntaxglitch wishes he'd had a parent like dobblego
17:22:25 <dons> syntaxglitch: http://www.indiegames.com/blog/2010/07/trailer_nikki_and_the_robots_j.html <-- preview
17:22:29 <dons> awesome game in haskell that doesn't suck
17:22:32 <syntaxglitch> dons, no I mean making a non-sucky game myself
17:22:36 <syntaxglitch> I know other people can do it
17:22:44 <dons> ah well, that's harder
17:22:46 <copumpkin> dobblego: they should prove it next!
17:23:00 <dobblego> copumpkin, they're oblivious to Agda :)
17:23:09 <syntaxglitch> dons, I hacked together a horrible tetris clone in a few hours to prove that it's not that hard to write games in Haskell
17:23:11 * monochrom refrains from suggesting to dobblego "composing two non-terminating functions is always a non-terminating function"
17:23:12 <copumpkin> dobblego: okay okay, they can stay that way for another year
17:23:37 <etpace> they're exactly the same code after expanding the def of twice f x, so i'm trying to reason why using twice makes a difference
17:23:59 <syntaxglitch> but I still haven't found a way of structuring a game in Haskell that I'm happy with
17:24:16 <monochrom> etpace: not the same type
17:24:28 <medfly> syntaxglitch, some people are working on a proper game in Haskell. maybe check out wha tthey are doing
17:24:32 <dankna> hmm
17:24:34 <etpace> sure, i know that twice :: (a -> a) -> (a -> a)
17:24:35 <dankna> nice trailer, dons
17:24:39 <etpace> but why is it forcing something more strict
17:24:51 <dankna> I look forward to the actual game
17:24:51 <monochrom> @type let twice f x = f (f x) in twice
17:24:52 <lambdabot> forall t. (t -> t) -> t -> t
17:24:54 <dons> hmm. so anyone want to guess how much of hackage builds?
17:24:59 <dons> as a % 
17:25:05 <monochrom> makeList does not have type t->t
17:25:05 <dankna> 87.667%
17:25:18 <dons> any other guesses?
17:25:20 <etpace> yes I know
17:25:23 <dankna> (it's just a guess; why shouldn't it be ridiculously precise?)
17:25:27 <dons> hehe
17:25:27 <etpace> surely (a -> b) -> a -> b is what's needed
17:25:32 <dons> well, 5% increments is ok.
17:25:38 <dankna> hehe
17:25:41 <etpace> because evidently makeList (makeList x) works
17:25:46 <etpace> so why doesnt twice makeList?
17:25:52 * hackagebot yajl 0.3.0.1 - Bindings for YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-0.3.0.1 (JohnMillikin)
17:25:55 <monochrom> would work in scheme
17:26:00 <syntaxglitch> dons, (++ "%") . show <$> [0,0.1..100]
17:26:05 <dons> well, i've got 85% of things building here. it might be higher. 
17:26:13 <dankna> neat
17:26:22 <dons> so that's better than some claims i've seen. :)
17:26:34 <monochrom> if you can force twice to take on the type (a -> b) -> a -> b, do tell me how, because it should be impossible
17:26:47 <monochrom> OTOH perhaps you just need unsafeCoerce
17:26:49 <etpace> if its impossible then why does makeList (makeList x) work
17:26:54 * syntaxglitch probably would have lowballed it at more like 75%...
17:27:03 <bss03> :t makeList . makeList
17:27:03 <ezyang> Something I've never been too clear about is what do you put in the Haddock documentation, and what do you put in the extended Cabal description field. 
17:27:04 <lambdabot> Not in scope: `makeList'
17:27:04 <lambdabot> Not in scope: `makeList'
17:27:13 <ezyang> Any thoughts here? 
17:27:23 <etpace> :t (:[]) . (:[])
17:27:23 <aristid> etpace: what is the type of makeList?
17:27:24 <lambdabot> forall a. a -> [[a]]
17:27:25 <bss03> :t let makeList = (: []) in makeList . makeList
17:27:26 <dankna> Cabal description is for marketing material :)
17:27:26 <lambdabot> forall a. a -> [[a]]
17:27:33 <monochrom> oh haha, I see your problem. (makeList :: [a]->[[a]]) ((makeList :: a->[a]) x)
17:27:35 <dankna> because people read it before they know anything else about the package
17:27:37 <bss03> :t let makeList = (: []) in makeList
17:27:38 <lambdabot> forall a. a -> [a]
17:27:43 <syntaxglitch> BTW, if anyone is interested in some ugly code for a Tetris clone: http://gist.github.com/524789
17:27:47 <ezyang> Do code samples count? :-) 
17:27:48 <aristid> :t twice
17:27:49 <lambdabot> Not in scope: `twice'
17:27:54 <etpace> I see that it doesn't match twices type signature
17:28:01 <dankna> Haddock documentation repeats what's in Cabal just in case the Cabal docs isn't easy to access post-installation, and goes into depth on how to actually use it
17:28:05 <etpace> but when you expand the definitin of twice, it is makeList (makeList x)
17:28:08 <dankna> s/isn't/aren't/
17:28:14 <bss03> :t let { twice f = f . f; makeList = (: []); } in twice
17:28:15 <lambdabot> forall b. (b -> b) -> b -> b
17:28:16 <ezyang> dankna: Yeah, but I hate copypasta. 
17:28:22 <aristid> etpace: makeList has no type conforming to a -> a, therefore it does not work with twice
17:28:22 <etpace> which compiles, so why doesn't twice makeList (more really why deosnt it fit the type signature)
17:28:28 <dankna> and yes, code samples count as marketing if they're sufficiently elegant :)
17:28:35 <monochrom> I've just answered. Please see scrollback.
17:28:42 <dankna> yeah, I understand, but it doesn't have to literally repeat, just cover the same themes
17:28:50 <ClaudiusMaximus> ezyang: i put brief list of changes from previous hackage upload, any custom cabal flags that can be used, and a brief description of why someone might want it
17:29:05 <etpace> whats your answer monochrom?
17:29:09 <monochrom> sigh
17:29:11 <bss03> etspace: IT doesn't work because makeList is polymorphic and in (makeList . makeList) the type variable is different in each invocation.
17:29:17 <monochrom> <monochrom> oh haha, I see your problem. (makeList :: [a]->[[a]]) ((makeList :: a->[a]) x)
17:29:43 <bss03> etspace: When you try and use twice, the type variable has to be the same in both invocations.
17:29:59 <etpace> ok, that makes sense
17:30:14 <etpace> I was just trying to reason why expanding the definition would allow it to compile
17:30:21 <CakeProphet> so what's wrong with
17:30:26 <CakeProphet> instance Named [Char] where ...
17:30:41 <CakeProphet> if I have: class Named n where name :: n -> String
17:30:55 * monochrom hates people who are too busy asking to read answers, and furthermore refuse to read scrollback.
17:31:22 <etpace> No, I read that
17:31:30 <syntaxglitch> monochrom, why, was someone doing that? I'd read the scrollback to find out but I'm too lazy.
17:32:09 <monochrom> "too lazy" is different. "too lazy" would at least imply "too lazy to be too busy asking"
17:32:26 <etpace> I'm asking why expanding a definition allows code to compile, and I was given answers such as "the types dont match" which really isn't what I was asking
17:32:29 <syntaxglitch> ah, good point, I suppose. Joke fail'd. :(
17:32:45 <monochrom> I totally don't mind too lazy.
17:33:14 <monochrom> reddit is an example of problems caused by people not lazy enough
17:33:44 <syntaxglitch> reddit is an example of problems caused by people
17:34:01 <hpc> reddit is an example of problems
17:34:30 <bss03> :t let twice f = f . f in twice :: a -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a
17:34:31 <lambdabot> parse error on input `='
17:34:55 * hackagebot Thrift 0.1.1.1 - Thrift library package  http://hackage.haskell.org/package/Thrift-0.1.1.1 (DonaldStewart)
17:34:59 <etpace> the question still stands I guess is why f (f x) uses makeList :: a -> [a] (makeList :: a -> [a] x) instead of allows f be "repolymorphic@ or something
17:36:14 <Heffalump> etpace: because of technical difficulties with type inference for "impredicative types"
17:36:54 <bss03> It's because "f" has to have a single type since it is a single argument.
17:37:11 <Heffalump> if you enable Rank2Types, and give an explicit signature -  twice :: (forall a . a -> [a]) -> a -> [[a]] - then you can use it with makeList
17:37:15 <FunctorSalad> ghci a game... why not :)
17:37:26 <etpace> right, thanks
17:37:36 <FunctorSalad> coq's interactive proof mode comes even closer...
17:37:43 <bss03> Do you even need rank2 types?
17:38:03 <dons> Gracenotes: see above, example of some kind of 'maintainer' mode for hackage. 
17:38:06 <monochrom> perhaps rank 1.49999 suffices
17:38:08 <lispy> dons: what the hell is thrift? :)
17:38:24 <bss03> :t let { twice :: Monad m => (a -> m a) -> a -> m (m a) } in twice
17:38:25 <lambdabot>     The type signature for `twice' lacks an accompanying binding
17:38:25 <lambdabot> Not in scope: `twice'
17:38:28 <FunctorSalad> dobblego: btw your kids write _quickcheck tests_???
17:38:28 <dons> Gracenotes: user uploads good package with broken Setup.hs -- trusted user fixes and uploads with local rev bump (+ *.*.*.1)
17:38:35 <bss03> :t let { twice :: Monad m => (a -> m a) -> a -> m (m a); twice f = f . f } in twice
17:38:37 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
17:38:37 <lambdabot>     When generalising the type(s) for `twice'
17:38:37 <lambdabot>     In the expression:
17:38:39 <dons> Gracenotes: I think we'd want to support that workflow in hackage 2.
17:38:41 <lispy> dons: n/m, I just googled it
17:38:43 <etpace> :ty mfix
17:38:45 <etpace> :t mfix
17:38:46 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
17:38:54 * dons gardens the package graph
17:38:59 <etpace> > mfix (:[])
17:39:03 <lambdabot>   mueval-core: Time limit exceeded
17:39:12 <FunctorSalad> pretty smart kids if they're as young as I somehow assumed from estimating your age and the age of having kids of a typical haskeller
17:39:57 <FunctorSalad> (a-priori estimate, not based on what you in particular said ;))
17:40:37 <Gracenotes> dons: it is possible to change the .cabal file without changing the package itself
17:41:40 <Gracenotes> even change the package without bumping a version number, theoretically. but that's probably not that stable of a solution
17:42:05 <Heffalump> ugh, please don't do any of that
17:42:13 <Heffalump> at least not once it's on hackage
17:42:17 <Gracenotes> in any case package trustees can upload a new version of any package. new versions are cheap.
17:42:25 <Heffalump> yes.
17:42:36 <Heffalump> don't confuse the world by having two anythings with the same version
17:43:12 <dons> Gracenotes: great. its equivalent to e..g foo-1.0.0-r3 in distro world
17:43:21 <dons> just meta-data editing
17:43:49 <FunctorSalad> hmm... I'm skeptical of changing anything without bumping the least significant version too
17:44:04 <Heffalump> something has to be bumped.
17:44:11 <FunctorSalad> (why? what's the problem with a .0.0.1 trivial fix?)
17:45:01 <FunctorSalad> (or metadata editing even)
17:47:59 <FunctorSalad> . o O ( purity )
17:48:47 <dons> race conditions
17:49:20 <Heffalump> dons: ??
17:49:45 <dobblego> FunctorSalad, sure, they are 7 and 9
17:50:47 <dons> Heffalump: well, a package gets uploaded. someone transfers it to a distro. someone else mutates the .cabal file. now the distro package says "X.Y" but is broken, since "X.Y" no longer exists.
17:50:59 <dons> because a distro packager read the .cabal file between writes.
17:51:14 <Heffalump> right
17:51:36 <Heffalump> I wasn't suggesting you should ever delete the old version when making a new rev.
17:51:45 <Heffalump> You just shouldn't edit an existing version in place.
17:51:53 <dons> right
17:52:17 <syntaxglitch> referential transparency for package versions
17:52:24 <Heffalump> I remember dcoutts has expressed support for the idea of in-place editing, so I'm trying to make plenty of noise against it just in case he still wants to do that :-)
17:52:54 <FunctorSalad> dobblego: :o very bright kids indeed to try to verify statements like the one you said with qc, in this cas
17:52:56 <FunctorSalad> *case
17:53:13 <ezyang> @seen dcoutts_ 
17:53:13 <preflex>  dcoutts_ was last seen on #ghc 2 days, 14 hours, 42 minutes and 21 seconds ago, saying: and applications already have to accept that signals get coalesced
17:53:14 <lambdabot> Unknown command, try @list
17:53:17 <ezyang> @seen dcoutts 
17:53:17 <preflex>  dcoutts was last seen on #ghc 1 day, 12 hours, 45 minutes and 18 seconds ago, saying: tibbe: Kazu Yamamoto tells me he's going to bash your new IO manager a bit and report problems or performance
17:53:18 <lambdabot> Unknown command, try @list
17:53:33 <FunctorSalad> seems to take quite a few prerequisites
17:54:04 <ezyang> @tell dcoutts I spent some time trying to figure out http://hackage.haskell.org/trac/hackage/ticket/438 , but I can't figure out when unknown flags get dropped from ConfigFlags: as early as configureAction they appear to have been elided. 
17:54:05 <lambdabot> Consider it noted.
17:54:07 <Igloo> I think dcoutts wanted to be able to edit the metadata in the hackage index, not the package contents
17:54:33 * syntaxglitch reflects on dobblego's 7-year old apparently being able to understand Haskell, whereas it's apparently too hard for a lot of professional programmers...?
17:54:48 <copumpkin> dobblego: I can give you my proofs about parity and basic arithmetic in agda if you want!
17:54:59 <ddarius> syntaxglitch: That only underscores the typical Haskell education rhetoric.
17:55:56 <FunctorSalad> syntaxglitch: even if they don't really understand *haskell*, understanding even the concept of a REPL and using it to test abstract propositions is quite a feat
17:56:34 <syntaxglitch> yeah, kids are smarter than people tend to think
17:57:12 <medfly> being young doesn't mean your automatically stupid :-D
17:57:15 <Phyx-> syntaxglitch: kids do the darndest things :P
17:57:16 <medfly> you're
17:57:16 <Heffalump> Igloo: isn't that supposed to be a mirror of the .cabal file?
17:57:36 <tolkad> Does the Vector overlaps function check if the vectors share memory addresses?
17:57:55 <Igloo> Heffalump: That's what it currently is, but he wanted to be able to do things like tighten deps
17:58:00 <FunctorSalad> medfly: it doesn't; but understanding *abstraction* tends to come later, or so I thought
17:58:03 <tolkad> it isn't documented what it does
17:58:40 <Heffalump> Igloo: that still sounds pretty dodgy. Users would get pretty confused if cabal install did something inconsistent with what the .cabal file said
17:59:12 <ddarius> Kids are also dumber than people tend to realize.
17:59:14 <Gracenotes> the gentoo system, e.g., separates metadata and source. we happen to bundle them together presently
17:59:20 <medfly> yes
17:59:21 * Igloo isn't a fan of it either, but it's a lot better than editting the packages
17:59:22 <medfly> hahaha
17:59:28 <copumpkin> ddarius: damn kids
17:59:32 <FunctorSalad> (which is why we don't explain numbers in terms of peano axioms to first-graders even if they don't take that much 'smartness' in the sense of cpu power)
17:59:43 <tolkad> also, what happens if you call grow on a vector slice?
18:00:00 <tolkad> vectors seem to be barely documented
18:00:01 <Gracenotes> who needs peano, just start with the ZF encoding
18:00:08 <Heffalump> tolkad: I think someone (e.g. you) is going to need to read the source to understand this, or email the maintainer.
18:00:09 <FunctorSalad> how could I forget
18:00:19 <Heffalump> I'm sure documentation patches would be welcome.
18:01:24 <Gracenotes> yeah, the tarballs contain documentation, metadata, source, and data files all in one go.. can make modifying any of them without touching the source laborious
18:01:35 <monochrom> well it's "concrete before abstract" as Piaget shows. you don't start kindergartens with category theory.
18:02:10 <ddarius> monochrom: And look where that's gotten us.
18:02:11 <dankna> heh, Piaget in this channel.  cool.
18:02:34 <syntaxglitch> monochrom, wasn't that the New Math?
18:02:46 <dolio> New math was set theory.
18:02:50 <monochrom> I don't know enough about New Math.
18:02:54 <napping> monochrom: who gets to abstract?
18:02:55 <FunctorSalad> monochrom: that was my point (except I was just describing my impression of what kids can do, not suggesting a teaching scheme)
18:03:03 <napping> It seems like some people never get to it
18:03:04 <syntaxglitch> monochrom, it's so simple, so very simple, that only a child can do it
18:03:29 <dankna> New Math was set theory, and has nothing to do with Piaget.  Piaget's ideas are closely related to those of Montessori, and are generally pretty good.
18:03:37 <FunctorSalad> dolio: but it will all work out with CT? :D
18:03:57 <dolio> Obviously. Set theory is quite lame by comparison.
18:05:14 <monochrom> napping: perhaps you think of negative numbers as trivial or obvious, but it's already quite more abstract than positive numbers.
18:05:35 <ddarius> Rebecca Saxe's TED talk gives one example of an interesting lack of ability in younger children.  Anyone with children under the age of 10 or so would probably benefit from viewing it.
18:05:36 <yaru1022> does anyone know how to pretty-print HTML using Hamlet?
18:05:44 <monochrom> even the worldly idea of "you owe me money" is pretty abstract
18:06:15 <dankna> even zero as a quantity is fairly abstract, really; it took a very long time for it to be invented
18:06:45 <napping> I'm thinking specifically of considering definitions as just another thing to be manipulated
18:07:34 <napping> rather than just working with concrete instances of a definition
18:10:23 <ddarius> napping: Could you give an example?
18:11:57 <FunctorSalad> haskell makes you miss 'map (f &&& g)' in the shell... first attempt http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29064#a29064
18:12:58 <hpc> :t \f g -> map (f &&& g)
18:12:59 <lambdabot> forall a c c'. (a -> c) -> (a -> c') -> [a] -> [(c, c')]
18:13:26 <FunctorSalad> f is $1, g is $2, [a] is the rest
18:14:17 <FunctorSalad> I turned 'pairing' into just running after each other since that's what you want for zipping outputs of the outputs
18:14:29 <FunctorSalad> outputs of the functions
18:14:53 <FunctorSalad> maybe it should remove any trailing newline from f's output :)
18:15:17 <syntaxglitch> here's a fun example of abstraction: http://www.literature.org/authors/carroll-lewis/through-the-looking-glass/chapter-08.html -- search for the phrase "sing you a song" and read the following dialogue fragment
18:15:33 <dankna> hah yes, I know the bit you refer to
18:15:45 <FunctorSalad> passing functions as fragments to be eval'ed could be done differently, but this way seems most convenient
18:15:47 <dankna> in fact I read it as a kid and it helped guide me on the path towards math-related pursuits :D
18:15:48 <monochrom> ddarius, napping: how about this as an example? http://www.cs.toronto.edu/~trebla/eq-wiltink.pdf
18:16:51 <syntaxglitch> dankna, it always reminds me of using multiple levels of pointer indirection in C
18:16:55 <napping> well, that's already off to a bad start - why believe either inscription?
18:17:07 <dankna> hah, yeah, good call.  it IS like that.
18:17:47 * syntaxglitch notes that Lewis Carroll was a mathematician and logician and sometimes--like in that passage--it really shows
18:17:57 <dankna> yeah.
18:19:06 <dankna> napping: Raymond Smullyan's books of logic puzzles explore that question more deeply, playing with the idea of semi-unreliable information but always assuming you have some known meta-information about the validity of the rest.
18:19:20 <napping> maybe that was where I saw it
18:19:38 <dankna> well, the basic class of problem has been around for ages, but yeah, possibly
18:19:40 <napping> a story of a king whose jester played that sort of puzzle with boxes of angry bees and stuff
18:19:56 <dankna> and then of course there's the xkcd take on it all
18:20:17 <dankna> "This guard always tells the truth, this one always lies, and this one stabs people who ask tricky questions."
18:20:20 <napping> then gave the jester some kind of death or freedom thing with two boxes, and death in the wrong box according to the description
18:20:33 <dankna> "And neither door actually leads out of the labyrinth, the whole setup is just a trap for escaping logicians."
18:20:45 <napping> "how can this be?" "easy, I just put the dagger in there, and then added the inscriptions"
18:20:57 <dankna> hah, nice
18:21:07 * syntaxglitch recommends Smullyan's "To Mock a Mockingbird" for anyone who hasn't already read it
18:21:16 <dankna> noted; I haven't
18:21:19 <syntaxglitch> it deals with topics near and dear to Haskellers :)
18:21:31 <dankna> hehe, I see
18:21:36 <napping> monochrom: I'm not sure how to explain
18:23:03 <syntaxglitch> dankna, namely, it presents combinatory logic in terms of logic puzzles involving a forest of birds with peculiar calls
18:23:18 <dankna> ooh interesting
18:23:27 <monochrom> perhaps you find the puzzle unrealistic. but you're still given a piece of information by definition, and the choice is between manipulating the definition and instantiating "if X is true... if X is false".
18:23:41 <syntaxglitch> the theme chosen as a nod to Haskell Curry, who was apparently an avid birdwatcher
18:23:48 <dankna> I see!
18:24:32 <syntaxglitch> and if you're wondering, yes, someone's "ported" the book to Haskell: http://hackage.haskell.org/package/data-aviary
18:24:35 * FunctorSalad already laughed at 'or else it doesn''t'
18:24:37 <monochrom> and then there comes a game of crocodiles with bizzare egg-laying behaviour
18:24:51 <aristid> syntaxglitch: to mock a mockingbird is not a light read :)
18:25:03 <monochrom> oh haha spoiler on hackage :)
18:25:08 * hackagebot YampaSynth 0.1 - Software synthesizer  http://hackage.haskell.org/package/YampaSynth-0.1 (GeorgeGiorgidze)
18:25:40 <ddarius> aristid: It depends on whether you already know the answers or, alternatively, whether you have access to a compiler to combinators... now where would one find such a thing.
18:26:14 <syntaxglitch> aristid, it's a light read if you already know the gist of the material and don't work through every question
18:26:27 <syntaxglitch> if you don't already know the material and do all the questions I expect it would be insanely challenging
18:26:28 <aristid> syntaxglitch: hmm i don't know the material
18:26:35 <FunctorSalad> syntaxglitch: reminds me a lot of the paragraph with the three or so quotation levels of 'I' in GEB
18:26:54 * FunctorSalad doesn't remember if it was 'I'
18:26:57 <aristid> syntaxglitch: one thing that is odd about the book.. the first and second part seem so completely unconnected
18:26:59 <ddarius> It is also a light read if you skip all of it.
18:27:04 <aristid> first half: standard logic puzzles
18:27:08 <syntaxglitch> FunctorSalad, "yields falsehood when preceded by its quotation" yields falsehood when preceded by its quotation!
18:27:20 <aristid> second half: birds
18:27:36 <dankna> "Yields repetive blather when preceded by its quotation" yields repetitive blather when preceded by its quotation!
18:27:42 <FunctorSalad> (I meant the disucssion of the knight btw, since you seem to be talking about something else already)
18:27:49 <ddarius> third half: non-standard arithmetic
18:27:50 <FunctorSalad> *with the knight
18:27:50 <syntaxglitch> FunctorSalad, yeah, I figured
18:28:06 <copumpkin> http://snapplr.com/qvhg
18:28:10 <aristid> ddarius: haha.
18:29:02 <monochrom> fourth half: profit
18:30:09 <aristid> fifth to infinite half: ...
18:30:24 * syntaxglitch found that GEB loses some of its fascination when you realize the whole thing is basically an ornate monument to the fixed-point combinator
18:30:45 <dankna> yeah, I agree - GEB is amusing writing and presents some important ideas, but it's not world-changing
18:31:04 <syntaxglitch> It's world-changing if most of the content is new to you
18:31:08 <dankna> well, yes
18:31:14 <bss03> I wrote a haskell program to do basically (find -type f), and it runs about 10x slower than GNU find.  Is that normal?
18:31:48 <napping> with find, maybe
18:31:52 <FunctorSalad> syntaxglitch: *nod*, it was, now I take most of it for granted ;)
18:31:58 <napping> do you know all the tricks find uses?
18:32:03 <dankna> bss03: if the question is "is it Haskell's fault" the answer is "probably not", simply because a factor of ten is so big that it's almost certainly a question of what algorithm you're using
18:32:14 <dankna> "normal" is a bit of a loaded word here though
18:32:40 <napping> I wouldn't be too surprised if there are things faster than why System.Directory and friends bind
18:32:50 <bss03> I don't know all the tricks GNU find uses.
18:32:56 <monochrom> people write slow programs all the time. it's normal.
18:32:58 <dankna> yeah; for that purpose I would use the posix interface
18:33:06 <FunctorSalad> "not (((I))) or (I), but ((I))" (to use parentheses instead of quotes)
18:33:08 <dankna> monochrom: haha yeah, that's kind of what I was getting at :)
18:33:21 <syntaxglitch> FunctorSalad, I took it for granted and now I've started coming out the other side and wondering whether general recursion is really all that great an idea
18:33:21 <bss03> I'm using System.POSIX
18:33:49 <bss03> er, System.Posix -- basically just stating files.
18:33:49 <dankna> you should run your code with profiling turned on, to get an idea of your cost-centers
18:33:53 <dankna> I can't really help much with that, but.
18:34:08 <dankna> it's possible that you're generating a lot of garbage (say by using mapM instead of mapM_)
18:34:11 <bss03> I tried with +RTS -s, and it helped a bunch.
18:34:14 <dankna> which is causing memory churn and slowing you down
18:34:17 <dankna> but that's only one possible cause
18:34:24 <FunctorSalad> syntaxglitch: "maybe not a great idea to have in your programming language"? or "not an interesting concept"?
18:34:25 <bss03> My first attempts were Way slower because they spent most of their time in the GC.
18:34:30 * dankna nods
18:34:35 <napping> does type -f check that it's a normal file?
18:34:42 <FunctorSalad> (of course it starts to seem trivial after a while :p)
18:34:48 <bss03> Now, the GC stats are pretty good.
18:34:51 <napping> one trick of find is making assumptions on hardlink counts, to decide when it has found all subdirs
18:35:13 <bss03> Yeah, (find -type -f) just prints in the files, not the directories.
18:35:23 <monochrom> http://hackage.haskell.org/package/directory-tree
18:35:24 <syntaxglitch> FunctorSalad, yeah, a bit of the former plus a bit of the "seems trivial"
18:35:28 <bss03> There's no symlinks or pipes or anything in the directory I'm using to test.
18:36:07 <napping> probably time to profile
18:36:09 <FunctorSalad> syntaxglitch: it isn't very *deep* with the advantage of hindsight... but still very important to have, i think
18:36:11 <napping> there's a lot of things it could be
18:36:20 <napping> you might also strace find
18:36:26 <FunctorSalad> ("deep" as in proofs needing lots of prerequisite development)
18:36:53 <FunctorSalad> it kinda sets out the basic frame
18:38:24 <syntaxglitch> FunctorSalad, yeah. Familiarity breeds contempt and all that, and it's easy to look back today and take a lot of very exciting, important work for granted
18:39:00 <FunctorSalad> (I do still find it somewhat 'deep' in the 'fundamentals of the world' sense)
18:39:31 * syntaxglitch nods
18:41:36 <syntaxglitch> but it does seem kinda funny to realize that it was a big deal when someone published a paper basically showing how to write an infinite loop
18:42:03 <dankna> hm
18:42:05 <dankna> interesting, yes
18:44:06 <FunctorSalad> much of goedel's proof was also about the particular encoding of logic in arithmetic, the possibility of which isn't completely obvious naively :)
18:44:31 <FunctorSalad> another part of the moral of the story is that anything can be encoded in almost anything maybe
18:44:47 <FunctorSalad> (universal turing machine would be of a similar flavour)
18:44:54 <syntaxglitch> <Kleene> hey al check this out <Kleene> > fix not <lambdabot> mueval-core: Time limit exceeded <Church> well crap
18:45:21 <FunctorSalad> :)
18:45:33 <copumpkin> lol
18:45:57 <dolio> n00bs
18:46:08 <FunctorSalad> (and that there's no simple fix like 'disallow quotation' because you can still get it in indirectly)
18:46:23 <FunctorSalad> (or 'disallow direct self-reference')
18:46:33 <bss03> @hoogle par
18:46:33 <lambdabot> Control.Parallel par :: a -> b -> b
18:46:34 <lambdabot> Text.Html paragraph :: Html -> Html
18:46:34 <lambdabot> Text.XHtml.Frameset paragraph :: Html -> Html
18:47:00 <syntaxglitch> yeah, that whole business was Goedel's masterstroke
18:47:08 <dankna> (I always felt that there ought to be some fix along the lines of "embed an AI version of Douglas Hofstadter in the logic system and use it to disallow anything that's problematic)
18:47:17 <dankna> (I understand why there isn't, but I wanted there to be :) )
18:47:33 <syntaxglitch> a whole bunch of other stuff basically reduces to "...and Goedel is laughing at you, QED"
18:47:40 <dankna> quite
18:49:33 <monochrom> I almost thought "(or 'disallow direct self-reference')" was a scheme expression demonstrating indirect self-reference, with ' for scheme quoting and all
18:49:39 * FunctorSalad likes the 'there is no PL that lets you write only terminating programs, and all the terminating programs' reformulation of the halting problems impossiblity :)
18:50:22 <dankna> yeah - that formulation lacks the confusion about infinity
18:50:25 <FunctorSalad> it seems a bit more practically relevant
18:50:29 <napping> Isn't system F like that?
18:50:46 <dolio> No.
18:50:53 <monochrom> @remember syntaxglitch <Kleene> hey al check this out <Kleene> > fix not <lambdabot> mueval-core: Time limit exceeded <Church> well crap
18:50:53 <lambdabot> It is stored.
18:51:03 <syntaxglitch> the particularly obnoxious bit is "and one of the terminating programs you can't write is the interpreter for the language itself"
18:51:13 <dankna> haha
18:51:14 <dankna> yeah
18:51:14 <syntaxglitch> monochrom, :)
18:51:30 <dolio> Intersection types type all and only the strongly normalizing lambda terms.
18:51:32 <napping> in one of those, an untyped lambda term can be elaborated to well-typed term iff the untyped term halts
18:51:58 <monochrom> would be a nice finishing touch with <G√∂del> lol
18:52:16 <FunctorSalad> (assuming 'PL' implies that the set of legal programs is at least recursively enumerable, which is a pretty weak property for a compiler to have ;))
18:52:39 <napping> hey, the set of halting programs is recursively enumerable as well
18:52:51 <syntaxglitch> monochrom, yeah that'd be perfect
18:53:47 <syntaxglitch> napping, wait what, it is?
18:53:58 <napping> yes, just not decidable
18:54:14 <FunctorSalad> hmm yes, now I'm a bit confused too...
18:54:15 <monochrom> recursively enumerable is easy
18:54:19 <napping> interleave execution of all programs in the standard way, output them as they halt
18:54:25 <FunctorSalad> yes
18:55:05 <syntaxglitch> napping, where "all" includes non-halting programs I guess
18:55:15 <FunctorSalad> I think I meant it has to be recursively enumerable which input strings even are programs
18:55:22 <FunctorSalad> (terminating or not)
18:55:40 <napping> sure, an input stream counts as a program if the execution halts
18:55:58 <syntaxglitch> okay, I get it now, nevermind
18:56:04 <napping> perhaps you mean decidable?
18:56:29 <napping> after all, we do generally like compilers to terminate
18:56:36 <syntaxglitch> not me
18:56:43 * syntaxglitch enables UndecidableInstances
18:57:02 <FunctorSalad> hmm, you only need r.e. for the contradiction (assume f1, f2, ... are all the source codes of your language, then g(n) := f_n(n) + 1 is total and is not one of the f_n)
18:57:05 <dolio> Some people do seem to think it's overrated.
18:57:15 <FunctorSalad> (@napping)
18:57:47 <dolio> But I think they usually only want the compiler to not-terminate when they've written a type-system loop or something, which isn't always doable.
18:57:57 <FunctorSalad> this is assuming 'programs' generally express functions from N to N
18:58:08 <napping> there are uncomputable functions from N to N, sure
18:58:40 <ezyang> latest sigfpe looks quality. 
18:58:47 <FunctorSalad> that function is computable, it's just a total function that's not writable in the supposedly 'all total functions, and only those' language
18:59:03 <napping> computable total functions
18:59:09 <FunctorSalad> yes
18:59:53 <syntaxglitch> a new sigfpe post? awesome
19:00:03 <FunctorSalad> I must be missing something obvious now...
19:00:04 * syntaxglitch has been looking forward to that after the previous one
19:00:25 <napping> with type functions?
19:00:37 <napping> I was hoping for lower cunning
19:02:37 <FunctorSalad> I thought the undecidability of the halting problem actually has to be used at some point here ;)
19:03:28 <dolio> For what? The non-Turing-completeness of total languages?
19:03:29 <ezyang> I wonder when I'll be able to understand this recent post series. 
19:03:36 <FunctorSalad> dolio: yes
19:03:39 <napping> FunctorSalad: so total functions is different from terminting programs
19:04:02 <dolio> FunctorSalad: Showing that eval can't be written is easy, and doesn't require talking about the halting problem.
19:04:11 <FunctorSalad> napping: indeed, but I don't see where I confused the two
19:04:14 <napping> in particular, you lose easy composability
19:04:29 <napping> you assume that the language can represent any total function
19:05:05 <FunctorSalad> for deriving a contradiction
19:05:07 <dolio> FunctorSalad: It's similar to your f_n example, too.
19:05:11 <napping> much harder than just allowing closed terms
19:05:32 <dolio> You show that you can write evil such that evil(n) = evil(n) + 1 or something.
19:05:56 <dolio> Or quote(evil(n)) = quote(evil(n)) + 1, maybe.
19:06:08 <napping> In particular, things like intersection types can do that trick, because if you have some untyped f and n, and want to annotation (f n), the annotations can depend on the n
19:06:13 <dolio> Which is a contradiction.
19:07:18 <FunctorSalad> wasn't there some related statement which does imply the halting theorem too?
19:07:24 <napping> so, how's this sound as a strategy to get regexp types with only existential quantification
19:07:31 <FunctorSalad> (about impossibility of certain languages)
19:08:24 * hackagebot libxml-sax 0.6 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.6 (JohnMillikin)
19:08:26 <napping> consider the group of state transitions under composition
19:08:36 <napping> embed it in the group of permutations
19:08:44 <napping> and then give you leafs types like
19:08:54 <napping> A :: Tree (a,b,c,d) (c,a,b,d)
19:12:46 * FunctorSalad is still confused...
19:13:01 <FunctorSalad> (what exactly this was the proof of)
19:13:20 <napping> well, I switched to talking about doing regexps in types as sigfpe does
19:13:22 <catenate> Will I seriously offend anyone in the haskell community if I use under_scores instead of camelCase?  (Bearing in mind that the first letter's capitalization is special.)
19:13:25 * hackagebot dbus-core 0.8.5 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.8.5 (JohnMillikin)
19:13:42 <FunctorSalad> napping: I figured, but I mean about the topic before
19:13:56 <ManateeLazyCat> gtk2hs-0.11.1 is release (a fix bug version), enjoy!
19:13:57 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
19:14:45 <napping> something about what the incompleteness theorem has to do with the halting problem, maybe?
19:14:48 <ManateeLazyCat> @tell BMeph gtk2hs can works with 6.12.3
19:14:48 <lambdabot> Consider it noted.
19:15:23 <FunctorSalad> it shows that any computable-in-the-preformal-sense of natural numbers to total computable functions is incomplete, yes
19:15:34 <FunctorSalad> (doesn't enumerate all total computable functions)
19:15:42 <ManateeLazyCat> @tell BMeph gtk2hs can works with 6.10.x to 6.12.x (except 6.12.2), maybe 6.8.x can work.
19:15:42 <lambdabot> Consider it noted.
19:15:58 <napping> you'd expect that just from a cardinality argument
19:15:59 <FunctorSalad> but it is pre-formal because that computability framework only talks about N->N functions and f has type N->(N->N)
19:16:22 <FunctorSalad> it's not cardinality, since the total computable functions are countable
19:16:59 <FunctorSalad> missing word: "mapping" (of natural numbers to ...)
19:17:24 <monochrom> yes 6.12.2 had a serious thread problem, no hope.
19:18:11 <napping> yes, the set of total computable functions is not r.e.
19:18:23 <napping> the set of terminating programs is, though
19:18:35 <FunctorSalad> that was it, apparently :)
19:19:12 <napping> in particular, one dodge you can take is defining a numbering based on the lambda calculus
19:19:19 <ManateeLazyCat> In gtk2hs main repository, still missing some API in gtk-2.18 and gtk-2.20, if someone have some API want to binding, send mail to me (lazycat.manatee@gmail.com), i can help you binding it in gtk2hs-0.12.0.
19:19:21 <FunctorSalad> (but 'the set of total computable functions is not r.e.' can only be formal statement after you have a g√∂del numbering of some superset of it, no?)
19:19:36 <FunctorSalad> *be a 
19:19:55 <napping> but there's no easy way to find a code for "(f x)"but given a code for "f" and "x"
19:21:13 <napping>  one trick for providing "eval" in a language is just to make it also take an ordinal, and "eval" the given code in a slightly modified version of the language where eval calls are only permitted at smaller ordinals
19:21:53 <copumpkin> napping: only uncountable ones, though
19:22:12 <napping> what's that have to do with it?
19:22:25 <copumpkin> just being stupid :P
19:22:27 <copumpkin> sorry, ignore me
19:25:25 <eflister> hi -- i want to have a class which just requires membership in some other classes, and have instances automatically determined rather than have to list them explicitly.  is this possible?
19:26:31 <ManateeLazyCat> Bye all.
19:28:27 <napping> eflister: like instance (Show a, Storable a) => C a where ...
19:28:43 <kmc> eflister, sounds like you just want a synonym for a class context
19:29:24 <copumpkin> eflister: you can do it with undecidable instances :)
19:29:49 <eflister> napping: right, but i don't need any where.  kmc:  right! how do i do that?  copumpkin: cool, how? :)
19:30:15 <napping> then don't write anything after the where
19:30:23 <FunctorSalad> napping: my problem was that making the set of total computable functions 'tangible' requires already having a language (they live in the uncountable set of N->N functions after all), but I was trying to say something about the impossiblity of a language
19:30:37 <kmc> eflister, it's an oft-desired feature, not currently a great way to do it in GHC but might be added eventually
19:30:41 <FunctorSalad> so you have to be careful that you aren't begging the question ;)
19:30:52 <kmc> the instance copumpkin describes is one workaround
19:31:00 <copumpkin> eflister: class (Alias1 a, Alias2 a) => ShortName a; instance (Alias1 a, Alias2 a => ShortName a
19:31:04 <copumpkin> eflister: it's not pleasant though
19:31:09 <napping> FunctorSalad: for the sort of tricks I'm talking about, you can start with any old language that includes all total and some or all nonterminating functions
19:31:55 <kmc> copumpkin, do you even need the constraint on the class?
19:32:16 <copumpkin> kmc: yeah, otherwise writing functions with it as the constraint won't give oyu the original ones
19:32:27 <copumpkin> I think?
19:32:38 <copumpkin> pretty sure when I played with it it worked more nicely
19:32:40 <kmc> copumpkin, hmm
19:40:26 <tolkad> is it possible to use MVars with ST? it looks like it with this: http://hackage.haskell.org/packages/archive/ghc-prim/0.2.0.0/doc/html/GHC-Prim.html#16
19:40:45 <kmc> tolkad, that's low level GHC guts
19:40:48 <Cale_> tolkad: Maybe with sufficient hackery. You're not meant to.
19:40:59 <kmc> tolkad, it would be equivalent to using unsafeIOtoST
19:41:15 <kmc> tolkad, you can't do concurrency in ST anyway
19:41:21 <Cale_> tolkad: ST computations are meant to be pure anyway, so there's no real reason to use MVars inside them.
19:41:43 <copumpkin> if you can prove your concurrent algorithm is externally pure, you might as well just use unsafePerformIO
19:41:47 <kmc> you can't do concurrent threads inside one ST action.  you can evaluate two separate calls to runST in parallel, but that's simple parallelism (par etc.) not concurrency
19:41:49 <copumpkin> again, the common case isn't
19:42:27 <eflister> copumpkin: thanks, it worked :)  also needed FlexibleInstances.  it did need the constraints on the class.  i have a cabal file with executables listed in it, and no language extensions line.  do i need to add one, or is just the LANUGAGE pragma sufficient?  cabal install seems to work without changing the cabal file...
19:42:58 <copumpkin> eflister: you don't need to, but it's probably a good idea. Also, UndecidableInstances lets you do lots of evil
19:43:07 <copumpkin> and even get non-halting typechecking if you do silly things
19:43:10 <copumpkin> so don't be silly :)
19:43:20 <copumpkin> (I still want a way to turn it on for specific things only)
19:50:57 <ClaudiusMaximus> with ghc -prof -auto-all +RTS -p, what does the 'entries' column in the .prof file mean? the docs say "number of times this point in the call graph was entered", but i'm getting nonsense figures  - 549894 entries with only 846 evaluations (counted using Debug.Trace.trace | wc -l)
19:53:24 <ClaudiusMaximus> > 550000 / 850
19:53:26 <lambdabot>   647.0588235294117
19:53:27 <napping> trace will only record the first time
19:53:53 <napping> entries is something like every time it's forced
19:54:13 <ClaudiusMaximus> ahh, thanks - that is true
19:54:36 <kmc> though, with pointer tagging i'm not sure every pattern-match will result in an entry
19:54:48 <tolkad> it's too bad vectors aren't portable... they mess around with GHC guts
19:55:18 <tolkad> does everyone just write haskell for GHC like nothing else exists?
19:55:30 <kmc> not everyone
19:55:40 <copumpkin> tolkad: JHC is getting pretty serious
19:55:46 <kmc> sometimes the case for using GHC-specific features is compelling
19:55:47 <copumpkin> and UHC has some neat features these days too
19:56:19 <kmc> and when compiler-specific features are needed (e.g. for speed), they can be provided for multiple compilers
19:57:10 <kmc> JHC, UHC, Hugs all have cool extensions not found in GHC
19:57:33 <tolkad> I guess Hugs is much faster than GHC
19:57:58 <copumpkin> you guess wrong :P
19:58:09 <kmc> it's not a compiler
19:58:29 <kmc> so the speed of Hugs itself is not a meaningful concept
19:58:43 <ClaudiusMaximus> hm, i'm still confused - this cost centre has type   baz -> bar -> IO [foo] , but it seems the entries count must include each time an element from the resulting list is used...
20:00:36 <lispy> ClaudiusMaximus: you could try adding more cost centers and see how it changes
20:00:54 <lispy> i've done that before, or turn off auto-all and just add in the ones you want, explicitly
20:03:45 <ClaudiusMaximus> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29066#a29066 the numbers/code
20:07:58 <lispy> ClaudiusMaximus: you can't trust debug.trace
20:08:35 <ClaudiusMaximus> lispy: right, but if it is really being called that many times i have a bad bug - i guess i'll try with putStrLn :)
20:09:41 <lispy> ClaudiusMaximus: debug statements aside, you might convert it to ST [a].  I don't think you need full IO here.
20:10:02 <lispy> ClaudiusMaximus: well, I guess you call c_sort.  So maybe you do actually.
20:15:29 <ClaudiusMaximus> hm, changing trace -> putStrLn gives a much more reasonable result (entries ~= 3x line count, instead of 647x)
20:16:25 <napping> were you confusing the number of timees the IO action was executed, and the number of times it was reevaluated?
20:20:32 <lispy> ClaudiusMaximus: amazing how unsafePerformIO changes the behavior, isn't it?
20:22:28 <ClaudiusMaximus> napping: well, the line counts were both correctish (around what i expected, just the entries count was way more with the 'trace' than with the 'putStrLn')
20:22:32 <ClaudiusMaximus> lispy: hehe
20:23:33 <ClaudiusMaximus> anyway, i think i'll see how much slower a pure haskell sort is under actual program conditions rather than an artificial benchmark...
20:24:00 <tolkad> will atomicModifyIORef block readIORef and writeIORef for its duration?
20:24:23 <napping> what duration? it's atomic
20:24:47 <tolkad> napping: what does that mean exactly?
20:25:28 <bd_> napping: It's probably implemented as a cpu-level atomic swap - instantaneous
20:25:30 <tolkad> that you can think of it as one operation, because it blocks all other operations for its duration?
20:25:47 <napping> no, that no other operation can observe an intermediate state
20:26:15 <bd_> er, that was meant for tolkad, not napping 
20:27:25 <ClaudiusMaximus> :t Data.IORef.atomicModifyIORef
20:27:27 <lambdabot> forall a b. GHC.IOBase.IORef a -> (a -> (a, b)) -> IO b
20:27:31 <lispy> ClaudiusMaximus: you use criterion, right?
20:27:40 <ClaudiusMaximus> lispy: no
20:27:47 <tolkad> oh, wait... you can't pass atmoicModifyIORef something that does IO
20:27:57 <tolkad> guess I'll have to use unsafePerformIO
20:28:04 <lispy> ClaudiusMaximus: criterion is on hackage and it gives you nice statistically robust performance marks.
20:28:16 <ClaudiusMaximus> cool, i'll have a look
20:28:20 <copumpkin> tolkad: ...
20:28:24 <lispy> ClaudiusMaximus: on top of it, someone wrote progression that tracks the performance changes between iterations
20:28:25 <bd_> tolkad: Err, why are you using unsafePerformIO here? Use a MVar
20:28:25 <napping> tolkad: I doubt that will do what you want
20:28:34 <copumpkin> tolkad just likes to troll
20:28:34 <lispy> ClaudiusMaximus: so, progression is nice to see how your improving
20:28:43 <tolkad> but seriously
20:28:44 <copumpkin> maybe we should rename him to trollkad :)
20:29:03 <bd_> tolkad: If you intend to do something like atomicModifyIORef (unsafePerformIO ...), be aware that your IO stuff may be invoked more than once. 
20:29:08 <ClaudiusMaximus> oo, does it log which git commits are related so i know where to go back to when i screw everything up...
20:29:19 <bd_> better to just use MVars
20:29:32 <lispy> ClaudiusMaximus: hehe.  I don't think so, but that would be a cool feature
20:29:42 <lispy> ClaudiusMaximus: I've used criterion but not progression.
20:31:31 <tolkad> let's say I have data T, function f on T, and function g on T. I don't mind multiple f being called on a single T at the same time but I do not want multiple g, or an f and a g, to be called on a single T at the same time. How could I accomplish this?
20:32:31 <tolkad> is there a way to do this with MVars?
20:32:34 <bd_> tolkad: explicit read-write locking using a mvar?
20:32:49 <tolkad> but when do I lock?
20:33:11 <ezyang> tolkad: Yes. 
20:33:15 <tolkad> I want to allow multiple f to be called on T at the same time, but not an f and a g, or two gs
20:33:30 <ezyang> I think you want a semaphore. 
20:33:36 <bd_> basically, have a data MVarLockStruct t = MVL { writerPending :: Bool, readers :: Int, value :: t }
20:34:02 <bd_> and a newtype MVarRWLock t = MVLD (MVar (MVarLockStruct t))
20:34:07 <bd_> and set up a read-write lock protocol using that
20:34:34 <bd_> you might need a bit more to deal with multiple writers, actually - a TVar might even be easier here
20:34:46 <bd_> or a writerToken :: MVar ()
20:38:50 <lispy> ClaudiusMaximus: BTW, you should be able to get your sort to be faster in pure haskell than in haskell calling C and then copying the results bck
20:39:37 <lispy> ClaudiusMaximus: It just depends on how well you tune it.  ghc-core is a tool on hackage to help you see what code is being generated. The haskellwiki has some decent pages about using ghc-core to fine tune your program.
20:45:14 <ClaudiusMaximus> lispy: i did try ghc-core earlier today, coincidentally - i found it mostly incomprehensible but then i didn't read the docs yet; earlier benchmarks did show that the via-C sort was quicker for ~2000 element lists, but maybe i don't need such long lists - more tuning to do...
20:48:51 <tolkad> ClaudiusMaximus: with ST available I don't see why you can't make it fast in haskell
20:51:41 <tolkad> ezyang: I really don't see how a semaphore will help...
20:52:58 <ezyang> tolkad: Assuming that you want writers to block until readers are all finished. 
20:54:36 <tolkad> ezyang: but I also don't want a reader to start in the middle of a writer, or have to writers happen at the same time
20:54:43 <tolkad> two writers*
20:56:33 <lispy> ClaudiusMaximus: We can certainly do better than the standard Haskell sort function
20:59:50 <tolkad> I have an idea....
20:59:57 <tolkad> thanks, I figured out how to do it
21:03:41 <jbapple> How do I remove a package with cabal?
21:04:21 <lispy> jbapple: you can't.  But you can ask ghc to unregister it.  If you really want it to be gone, you can then delete the files for it.
21:04:27 <lispy> jbapple: ghc-pkg unregister Foo
21:05:08 <jbapple> How do I ghc-pkg unregister two packages at one time?
21:05:29 <lispy> Never needed to do that.  Maybe list them at the same time?
21:05:36 <lispy> ghc-pkg unregister foo bar
21:05:42 <jbapple> nope
21:05:52 <jbapple> also, sudo ghc-pkg doesn't work on my machine
21:05:55 <jbapple> ahhhhhhhhhhhhhh!
21:06:44 <tolkad> why would you ever want to REMOVE a package? all packages are perfect and should never be removed
21:07:09 <lispy> perfect?  Nah.  Just no destructive updates :)
21:07:37 <medfly> YOU HERETIC
21:08:08 <jbapple> uhc depends on uulib
21:08:13 <jbapple> but not the latest uulib
21:08:16 <jbapple> why would I think that?
21:08:28 <jbapple> no, it depends on uulib 2 versions ago
21:08:33 <jbapple> but configure doesn't check that
21:09:02 <tolkad> why will calling cabal upgrade on everything available break my set of installed packages?
21:09:15 <lispy> tolkad: yes, that's why cabal doesn't let you do it
21:09:23 <tolkad> why would it do that?
21:09:37 <lispy> I have no idea actually.
21:09:42 <tolkad> I don't know which ones are safe to upgrade...
21:09:52 <tolkad> I guess I can never upgrade anything because it might break
21:10:01 <tolkad> and there is no way to restore it to a previous version if it does
21:10:15 <tolkad> how convenient
21:10:21 <lispy> You don't need the 'cabal upgrade' command to upgrade them
21:10:31 <lispy> you just need the cabal install command
21:10:58 <tolkad> apparently even that could break stuff
21:11:04 <tolkad> since I assume they do the same thing
21:11:11 <lispy> why would assume that?
21:11:22 <lispy> also, you'd be wrong to assume it :)
21:12:19 <tolkad> ultimately they do the same thing... download the package. they might do it under different sets of circumstances (install does it if the package is available, upgrade does it if the package is available and you have an older version installed)
21:13:01 <lispy> tolkad: what did you use as your reference?
21:13:10 <tolkad> lispy: reference for what?
21:13:20 <lispy> tolkad: your information about how upgrade and install work
21:14:09 <tolkad> lispy: nothing really, it's just a guess, but a safe guess to make because I am doing it out of caution
21:14:15 <Phyx-> :t (+1)
21:14:16 <lambdabot> forall a. (Num a) => a -> a
21:14:56 <Phyx-> :t (+1) *** (- 1)
21:14:57 <lambdabot> forall b b' c'. (Num b, Num c') => (b, b') -> (b, c')
21:15:20 <tolkad> lispy: also, people are more likely to correct you if you are wrong than answer you if you ask rather than stating assumptions
21:15:56 <tolkad> lispy: which is also a guess but I believe it to be true
21:16:07 <tolkad> usually
21:16:21 <bos> oh, ze hacking, she is ze painful
21:16:37 <tolkad> :t negate.negate
21:16:38 <lambdabot> forall a. (Num a) => a -> a
21:17:27 <tolkad> @hoogle instance Eq (a -> b)
21:17:28 <lambdabot> Did you mean: :: instance Ordering (a -> b) /count=20
21:17:28 <lambdabot> No results found
21:17:48 <tolkad> @hoogle instance Eq a
21:17:48 <lambdabot> No results found
21:18:18 <tolkad> would hoogling for ¬´instance Eq (a -> b)¬ª find ¬´instance Eq a¬ª?
21:18:25 <tolkad> if it existed
21:21:52 <bos> preflex: seen dons
21:21:52 <preflex>  dons was last seen on #haskell 3 hours, 29 minutes and 58 seconds ago, saying: right
21:22:07 <azaq23> > (- 11) 300 "some" "literals"
21:22:08 <lambdabot>   -11
21:22:12 <azaq23> @type (- 11)
21:22:13 <lambdabot> forall a. (Num a) => a
21:22:19 <azaq23> that shouldn't make sense, should it?
21:22:22 <luite> is there a hackage package for working with multivariate polynomials?
21:24:40 <lispy> :t (- 11) 300 "some" "literals"
21:24:41 <lambdabot> forall t. (Num ([Char] -> t)) => t
21:25:06 <lispy> azaq23: I'm not sure why that work in lambdabot, but i think ti's due to some imported instance.  Perhaps from simple reflect
21:25:08 <medfly> wth?
21:29:40 <Cale_> azaq23: There's an instance of Num for functions from the vector-space package
21:30:06 <Cale_> (In Data.NumInstances)
21:31:16 <Cale_> The relevant definition here is that  fromInteger x = const (fromInteger x)
21:31:35 <Cale_> (where the fromInteger on the right hand side might be for a different instance of Num)
21:32:49 <Cale_> (But it also might be the same instance a few times in order to eat more parameters)
21:33:20 <Cale_> > (1 + cos) (pi/3)
21:33:21 <lambdabot>   1.5
21:34:04 <Cale_> > map (sin^2 + cos^2) [0,0.2..pi]
21:34:05 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0000000000000002,0.9999999999999999,1.0,1.0,...
21:34:18 <Cale_> > map (sin^2 + cos^2) [0,0.2..pi] :: [CReal]
21:34:19 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
21:34:38 <Phyx-> :t sin
21:34:39 <lambdabot> forall a. (Floating a) => a -> a
21:34:43 <Phyx-> :t (^)
21:34:44 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
21:34:49 <Phyx-> :t (sin^2)
21:34:50 <lambdabot> forall a. (Floating a) => a -> a
21:34:57 <Phyx-> that looks very odd
21:34:57 <bss03> :t (^^)
21:34:58 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
21:35:15 <bss03> :t (**)
21:35:17 <lambdabot> forall a. (Floating a) => a -> a -> a
21:35:24 <Phyx-> :t (***)
21:35:25 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
21:35:29 <Cale_> instance (Num a) => Num (e -> a)
21:35:36 <azaq23> Cale_: So the nearest explanation is that there are num instances for [Char] and that a -> b instance, all the literals are const'ed and piped through each other - wow, weird stuff
21:35:46 <azaq23> http://hackage.haskell.org/packages/archive/vector-space/0.1.2/doc/html/src/Data-NumInstances.html
21:35:46 <Cale_> azaq23: Not for [Char]
21:35:59 <Cale_> azaq23: For arbitrary functions whose codomain is an instance of Num
21:35:59 <bss03> :info [Char]
21:36:09 <Cale_> (the domain doesn't matter)
21:36:27 <bss03> codomain?  a.k.a range, right?
21:36:36 <Cale_> yeah, the range is a subset of the codomain
21:37:41 <Cale_> If you have a function f :: A -> B, then A is called the domain, and B is called the codomain. The set of elements b of B for which b = f a for some a in A is called the range.
21:38:21 <FunctorSalad> <jbapple> How do I ghc-pkg unregister two packages at one time? <-- zargs pony kitten -- ghc-pkg unregister
21:38:23 <FunctorSalad> ;)
21:38:37 <bss03> For non-total functions, the corange is a in A s.t. f a /= _|_ ?
21:38:41 <FunctorSalad> zargs -Ix pony kitten -- ghc-pkg unregister x
21:38:41 <Cale_> So, since Integer is an instance of Num, we have an instance of Num for  String -> Integer  as well, such that (f + g) x = (f x) + (g x), and so on.
21:39:02 <FunctorSalad> (first one will just feed both args to one invocation, which I infer from your question doesn't work)
21:39:10 <FunctorSalad> err and this is zsh only
21:39:26 <FunctorSalad> for x in pony kitten; do ghc-pkg unregister $x; done # should work for most shells
21:39:31 <azaq23> Cale_: Yes, I see it now - but that module looks like someone tried to imitate math syntax with the sin^2 stuff - it used fmap = (.) for functions anyway
21:39:36 <Cale_> bss03: I suppose that would be a sensible definition.
21:39:49 <luite> @pl f ((a,b),c) = (a,b,c)
21:39:50 <lambdabot> f = uncurry (uncurry (,,))
21:40:03 <bss03> xargs -l1 -- ghc-pkg unregister <<< "pony kitten"
21:40:04 <bss03> ?
21:40:10 <bss03> For bash, on GNU systems?
21:40:25 <FunctorSalad> or that, but I was golfing the length
21:40:46 <FunctorSalad> for_ pony kitten -- ghc-pkg unregister # for_ a local creation ;)
21:42:17 <bss03> Does it for_ always exit with a return value of 0?  Otherwise, I'm not sure the _ suffix is warranted, since it isn't ignoring all the results of the action. :P
21:42:24 <FunctorSalad> in the zsh case I prefer zargs because it will actually use the partially applied function as a shell command rather than a seperate process
21:42:35 <FunctorSalad> bss03: 'for' is taken ;)
21:43:23 <bss03> Really?  How do you partially apply a command invocation?
21:43:38 <FunctorSalad> uh I just meant the same way xargs works
21:44:23 <bss03> Ah, that's why I used xargs, instead of a for loop, but zargs is awesome is you are using zsh.
21:44:47 <FunctorSalad> f() { echo $(( $1 + $2 )); } ; zargs 1 2 3 -- f 42
21:44:48 <bss03> I do, but I haven't really develed into the z* commands; and I use POSIX sh for most of my shell scripts.
21:45:04 * hackagebot network-protocol-xmpp 0.3.2 - Client <-> Server communication over XMPP  http://hackage.haskell.org/package/network-protocol-xmpp-0.3.2 (JohnMillikin)
21:45:42 <FunctorSalad> err I made the same mistake again (forgot to tell it to invoke f once each time) -- should be zargs -Ix 1 2 3 -- f 42 x
21:46:28 <FunctorSalad> there's presumably something analogous to xargs -l1 too to remain pointless ;)
21:46:35 <bss03> xargs fails badly there, since it doesn't operate inside the current shell -- it can't see shell functions.
21:46:51 <bss03> Big win for zargs; plenty of time I wanted to xargs a shell function.
21:47:45 <FunctorSalad> bss03: yes that's what I was trying to say with 'as a shell command'
21:48:17 <FunctorSalad> (well you can do "xargs sh -c '...' sh" but that's annoying ;))
21:48:41 <FunctorSalad> (the final 'sh' can be anything but is necessary because $0 goes there)
21:48:54 <bss03> Yeah, yeah.  Been there done that.
21:49:08 <bss03> I usually use "ignored" as my $0 in a nested shell like that.
21:49:10 <FunctorSalad> took me some time to notice that last part ;)
21:49:56 <bss03> I spend too much time thinking about how to make my shell scripts impervious to odd filenames.
21:50:17 <bss03> You know, ones that contain newlines, tabs, spaces, colons, dollar-signs, etc.
21:51:07 <FunctorSalad> haha yes :) I found that the trick (other than using -0) is that *arguments* are of list types
21:51:13 <FunctorSalad> so filenames are safe there...
21:51:45 <FunctorSalad> so it seems to be safer to pass a continuation command to a filename-producing command than to have the filename-producing command print to stdout
21:51:51 <FunctorSalad> *of list type
21:52:21 <FunctorSalad> (or use arrays)
21:52:42 <FunctorSalad> (though the syntax for them can be hilarious ;))
21:53:03 <azaq23> @karma++ Cale_
21:53:03 <lambdabot> Cale_'s karma raised to 1.
21:53:10 <bss03> Again, my shell scripts tend to be POSIX, so I don't get the benefit of arrays.
21:53:46 <FunctorSalad> oh, I see (though I didn't know arrays don't exist in posix)
21:56:37 <bss03> Yeah, I'm not sure exactly why they haven't introduced array syntax.
21:56:49 <bss03> Most real shells have some way of handling arrays.
22:16:45 <deteego> has anyone had issues trying to compile cabal2arch?
22:16:51 <deteego> im getting the following error
22:17:00 <deteego> /usr/bin/ld: cannot find -lHScereal-0.2
22:20:17 <azaq23> well, a shared library names libHScereal could not be found
22:20:24 <azaq23> * libHScereal.so
22:20:27 <azaq23> @google libHScereal.so
22:20:27 <lambdabot> No Result Found.
22:20:38 <azaq23> @google libHScereal-0.2.so
22:20:39 <lambdabot> No Result Found.
22:20:41 <deteego> seems to be asking
22:20:47 <deteego> for haskell-cereal 2.0
22:20:53 <deteego> however I have v3 installed
22:21:02 <deteego> hmmmm
22:21:30 <deteego> yeah its working with haskell-cereal 2.0
22:22:55 <deteego> I think that might be an error with the linker
22:24:23 <azaq23> -l<name> just searches for lib<name>.so files in your library path, AFAIK
22:24:31 <azaq23> that library was named with a -0.2 suffix
22:24:46 <azaq23> so v3 will likely have -0.3 -> file not found
22:25:23 <azaq23> very unlikely that something as simple as that doesn't work with a program that was written in the 80s and is used bazillion times each day ;)
22:28:51 <drhodes> @hoogle [IO [a]] -> [[IO a]]
22:28:51 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
22:28:52 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
22:34:13 <bss03> @hoogle insertWith
22:34:14 <lambdabot> Data.IntMap insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
22:34:14 <lambdabot> Data.Map insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
22:34:14 <lambdabot> Data.Map insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
22:36:55 <dbelange> (a -> b) -> (b -> ->( ->
22:40:21 <deteego> azaq23: well that was the problem
22:40:34 <deteego> downgrading haskell-cereal to 2.0 fixed the problem
22:46:15 <carter> is hackage slow right now or is that just me?
22:51:02 <deteego> ffs
22:51:05 <deteego> the gtk upgrade
22:51:10 <deteego> has broken my ghc
22:54:25 * hackagebot wai-handler-snap 0.0.0.1 - Web Application Interface handler using snap-server.  http://hackage.haskell.org/package/wai-handler-snap-0.0.0.1 (MichaelSnoyman)
22:54:59 <carter> i am very confused by this cabal message
22:55:06 <carter>  cabal install --reinstall bytestring criterion parsec-3.1.0 vector-0.6.0.2 
22:55:06 <carter> Resolving dependencies...
22:55:06 <carter> cabal: cannot configure vector-0.6.0.2. It requires ghc >=6.9
22:55:08 <carter> There is no available version of ghc that satisfies >=6.9
22:55:29 <FunctorSalad> ghc-pkg list ghc?
22:55:30 <carter> and considering i'm using haskell platform 2010-2
22:55:48 <carter> /usr/local/Cellar/ghc/6.12.3/lib/ghc/package.conf.d
22:55:48 <carter>    ghc-6.12.3
22:56:00 <carter> sooo....
22:56:03 <FunctorSalad> hmm, then I don't know either
22:56:16 <carter> i get weird stuff like this all the time
22:56:44 <drhodes> carter: I fixed this by changing the requirements in the vector.cabal build file
22:57:08 <drhodes> (I think) it's been awhile.
22:57:12 <FunctorSalad> maybe the 6-12.3 was already excluded by a constraint of one of the other packages you're installing?
22:57:16 <carter> drhodes: so i dl the .tar.gz and fix the issue?
22:57:26 <FunctorSalad> I think running cabal verbosely will show that
22:57:29 <carter> this only came up because i decided to try to install criterion
22:57:53 <drhodes> carter: maybe, but I hope I'm not running you afowl, because I've had to do this for several packages
22:59:46 <carter> snow leopard / os x is funny buildingness somtimes anyways
23:01:33 <carter> what i should be doing right now is converting some code to using attoparsec because the reduced memory churn + improved locality of data should make my "build a Data.Trie from 1.5 mill kv pairs" code run much faster
23:02:13 <carter> drhodes: why did you need to change vector in your case?
23:02:59 <drhodes> I was trying to get the new web framework to build, and I think iteratee needed a newer vector
23:03:09 <drhodes> snap
23:03:35 <carter> ahh
23:04:30 <carter> that was weird.... i changed the version of parsec thats active and it built...
23:05:08 <drhodes> for now!
23:14:11 <carter> drhodes: actually, gonna try the editing the cabal ghc version constraints thing
23:14:39 <bss03> Hrm.  I'm getting an error that I understand, but I'm not sure how to fix.
23:14:58 <bss03> instance (Ord k, MonadPlus mp) => MonadPlus (Map k mp) where
23:14:59 <carter> drhodes: so when i'm build from untared source,  if i want it to act like i did a cabal install,  i do the --user flagged version of the runhaskell stuff
23:14:59 <bss03> 	mzero = empty
23:15:00 <carter> right?
23:15:01 <bss03> 	mplus = unionWith mplus
23:15:15 <bss03> I get a kind error.
23:15:34 <carter> bss03: whats the kind error?
23:15:55 <bss03>     The first argument of `MonadPlus' should have kind `* -> *',
23:15:57 <bss03>     but `Map k mp' has kind `*'
23:16:01 <carter> well
23:16:11 <carter> mp is a monad of kind * -> *
23:16:17 <carter> but you're using it as the key type
23:16:21 <drhodes> carter: not really sure, I just "runhaskell Setup.hs configure" and cross my fingers, I'm really lousy with cabal.
23:16:36 <carter> bss03:  i mean the value type
23:17:01 <bss03> Well, what I mean is forall a. Map k (mp a) or something like that.
23:17:59 <carter> bss03: try that wiht  instance Ord k => MonadPlus (Map k) where
23:18:16 <carter> bss03:  that should be more like what you want
23:18:33 <carter> drhodes: k
23:18:53 <bss03> Hrm, I think I need some way of expressing the MonadPlus restriction on the value type.
23:19:12 <bss03> 'Cause I define mplus on Maps base on the mplus of their values.
23:20:01 <carter> umm
23:20:07 <carter> try it this way first :)
23:20:38 <bss03> Well, I don't get a kind error.
23:20:48 <carter> bss03:  what do you get instead?
23:21:05 <bss03> Instead I get a "could not deduce ... from the context ..." error.
23:21:19 <carter> and the ... are?
23:21:26 <bss03>     Could not deduce (Monad (Map k)) from the context (Ord k)
23:21:28 <bss03>       arising from the superclasses of an instance declaration
23:21:29 <bss03>                    at DupFind.hs:21:9-34
23:21:57 <carter> bss03: then add that instance :)
23:22:43 <bss03> Alright...
23:26:14 <carter> bss03: so what would this do as a monad? 
23:26:19 <carter> would it eg 
23:26:29 <carter> have bind and return both do lookups?
23:27:09 <carter> or what?
23:28:14 <carter> bss03:  rember you need  return : a -> m a , bind: m a -> ( a -> m b ) -> m b to make sense 
23:28:20 <carter> for m = map  thingy
23:28:25 <bss03> Trying to figure that out exactly.
23:28:27 <carter> if you wanna have monad plus too
23:28:32 <bss03> I know what it does as a functor.
23:28:42 <carter> well
23:28:46 <bss03> I'm just trying to figure out how join makes sense.
23:28:47 <carter> here's a better idea :)
23:30:31 <carter> well 
23:30:38 <carter> here's one kinda related idea
23:31:24 <carter> actually
23:31:32 <carter> different question: what is it you want to use this for?
23:31:38 <carter> ignoring the monady bit for now
23:33:07 <bss03> I'm walking a filesystem, and building up a Map Integer (Map (DeviceID, FileID) (EpochTime, EpochTime, [FilePath]))
23:33:38 <bss03> Basically trying to find all the files of the same size, including all the different names for the same hard link.
23:34:24 <bss03> The EpochTimes are bookkeeping; I refuse to list any file that was modified during the walk.
23:36:59 <bss03> I've got existing code that was doing something simpler using (:) and (++) to combine results from walking single directories and recurring.
23:37:29 <bss03> I was hoping to use alter and unionWith in the same manner.
23:39:21 <bss03> By first generalizing to \x y -> mplus (return x) y and mplus.
23:40:28 <carter> well, why do you need the monadic stuff, how about just doing the map union directly?
23:40:35 <carter> rather thanwith lists?
23:41:35 <bss03> Yeah, I can do that.  I was probably trying to generalize too much.
23:42:06 <bss03> MonadPlus was definitely the work typeclass.
23:42:50 <bss03> Map k isn't even Applicative.  There's no sane version of pure.
23:42:59 <bss03> s/work/wrong/
23:43:24 <dolio> Insert at all keys!
23:43:32 <carter> yeah, 'cause at least map datastructures have better unioning performance than list append :p
23:45:01 <bss03> It's not the appending that would kill me; it would be the later groupBy I would need to do.
23:45:04 <carter> in contrast, my algorithm adventure this evening is swaping some parsec code for some attoparsec code to hopefully dramatically lower memory usage
23:45:05 <Heffalump> bss03: what about if k is a Monoid?
23:45:51 <carter> Heffalump: with union being the monoid op?
23:46:21 <carter> bss03: yeah, monoid makes sense
23:46:33 <carter> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-Monoid.html#v:Monoid
23:46:38 <EvanR> its pretty freaky when you refactor a ton of code, fix the compiler errors, and the code still works >_<
23:47:00 <bss03> Ooooh.
23:47:11 <bss03> Monoid might be what I'm looking for.
23:47:30 <Heffalump> carter: return v = Map.singleton mempty v ; join m = Map.fromList [(k1 `mappend` k2, v) | (k1, m2) <- Map.assocs m, (k2, v) <- Map.assocs m2]
23:47:41 <Heffalump> but ideally with a more efficient internal implementation of join
23:48:14 <bss03> mempty = Data.Map.empty; mappend = Data.Map.union; mconcat = Data.Map.unions
23:49:01 <carter> Heffalump: whats that def for?
23:49:02 <Heffalump> bss03: oh, I see. You weren't trying to make a Monad, you were trying to find a nice abstraction for Map. Yeh, Monoid, but you need to decide what to do about key collisions.
23:49:15 <Heffalump> carter: for making Map k a Monad if k is a Monoid
23:49:43 <Heffalump> I was specifically replying to this line, without having read the rest of the conversation: [07:42] <bss03> Map k isn't even Applicative.  There's no sane version of pure.
23:50:06 <carter> Heffalump: i don't quite understand the return v def you proposesd
23:50:16 <bss03> What about (Ord k, Monoid v) => Monoid (Map k v)?
23:50:54 <carter> bss03: nooo, Ord k => Monoid (Map k)
23:50:59 <bss03> with mappend = unionWith mappend
23:51:04 <carter> stop trying too fill in all the paramters )
23:51:06 <carter> :)
23:51:20 <bss03> I need to constrain those parameters. :(
23:51:23 <carter> kind of (Map k v) :: *
23:51:30 <carter> why?
23:51:41 <carter> why do v need to be even mentioned?
23:51:52 <bss03> I was to use the Monoid instance of v to define my Monoid instance of Map k v
23:51:53 <carter> but kind (Map k):: *-> *
23:51:58 <carter> no
23:52:00 <carter> you don't
23:52:06 <bss03> with mappend = unionWith mappend
23:52:27 <carter> am i explaining it wrong?
23:52:33 <bss03> :t mappend
23:52:34 <lambdabot> forall a. (Monoid a) => a -> a -> a
23:52:35 <carter> oh
23:52:37 <carter> oops
23:52:39 <carter> gotcha
23:52:40 <carter> ok
23:52:43 <bss03> :t unionWith mappend
23:52:44 <lambdabot> Not in scope: `unionWith'
23:52:48 <dolio> Heffalump: That might fail associativity.
23:53:08 <bss03> :t Data.Map.unionWith mappend
23:53:09 <lambdabot> forall a k. (Monoid a, Ord k) => M.Map k a -> M.Map k a -> M.Map k a
23:53:17 <carter> bss03: so you'l use the monoid v to decided how to deal with conflict
23:53:18 <carter> k
23:53:32 <bss03> Right.
23:53:39 <dolio> Maybe not.
23:54:27 <bss03> But, I don't know how to make something like (forall a. Monoid (Map k a)) "point-free".
23:54:46 <bss03> @pl \x = f (g h x)
23:54:47 <lambdabot> (line 1, column 4):
23:54:47 <lambdabot> unexpected "="
23:54:47 <lambdabot> expecting operator, pattern or "->"
23:54:48 <carter> umm
23:54:53 <bss03> @pl \x -> f (g h x)
23:54:53 <lambdabot> f . g h
23:55:07 <carter> your instance ... where ... def that i was noo.... ing just now was fine presumably
23:55:09 <bss03> But, I know (.) works on values, not types. :(
23:55:17 <carter> bss03: dont' use point free fro now
23:55:20 <carter> just get it to work :)
23:55:40 <bss03> *shrug*
23:55:47 <carter> syntactic prettiness is less important than design prettines
23:55:53 <carter> to some sane extent
23:56:01 <bss03> 'k, I'm going to go read the typeclassopedia for Monoid and then look at my code again and see how best to use it.
