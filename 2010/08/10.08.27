00:07:06 <EvanCarroll> copumpkin: how would you write that iterate (+9).(*10) as a foldr?
00:07:43 <dibblego> EvanCarroll, every function on list can be written using a foldr; it's a good exercise to write iterate yourself
00:08:15 <copumpkin> well, a function generating a list
00:08:18 <copumpkin> should be written as an unfoldr
00:08:32 <copumpkin> unless you do want to run a foldr over an unrelated infinite list
00:09:39 <dibblego> indeed, use foldr
00:09:42 <copumpkin> EvanCarroll: as an unfold it's quite easy
00:12:34 <evant_> Stupid question, but could someone point me to a good tutorial regarding Maybe? I understand you'll either get nothing or Just a, but something explaining how you check the return etc would be great
00:12:41 <FunctorSalad> see, this is why I proposed renaming (!!) to unfastPerformIndexing http://code.haskell.org/~daniels/plot.png
00:13:06 <FunctorSalad> "old" is for scrolling through a list widget backed by a list, "new" backed by a zipper
00:13:32 <dibblego> evant_, a better tutorial might be about algebraic data types in general of which Maybe is one specific instance
00:14:44 <evant_> Alrighty, I'll check it out, thanks
00:14:52 <FunctorSalad> (x=number of items, y=ticks)
00:15:33 <FunctorSalad> though admittedly these numbers don't include actual rendering of the widget, which would predominate except for larger x :)
00:17:30 * hackagebot buildbox 1.0.1.0 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.0.1.0 (BenLippmeier)
00:17:57 <FunctorSalad> almost makes one wonder whether the benchmark is doing anything for the zipper version, but it does start to take more time in the hundreds of thousands ;)
00:20:03 <evant_> Is there any kind of common pattern for what I'm trying to do here? http://pastie.org/1119817
00:20:09 <evant_> Might be a bit noob... ;)
00:20:56 <copumpkin> how does that compile?
00:21:00 <copumpkin> addBinding refers to x ?
00:21:39 <copumpkin> but otherwise, it looks like a fold
00:21:55 <copumpkin> foldl, even
00:22:03 <evant_> Uh, the "x" is undefined yet ;)
00:22:06 <copumpkin> although I don't really think it needs to be
00:22:12 <evant_> But it's some operation
00:22:25 <copumpkin> ah okay
00:22:34 <evant_> I'm implementing a small evaluator for a haskell like language
00:22:48 <evant_> The environment is for variables and functions etc
00:23:00 <evant_> So Each binding that gets added needs a new environment generated
00:23:10 <evant_> I think that's an ok way of doing it
00:27:40 <EvanCarroll> ok i give up
00:27:48 <EvanCarroll> howdo you write iterateasfoldr
00:27:57 <EvanCarroll> how do you write iterate as foldr*
00:29:05 <Pseudonym> @src iterate
00:30:33 * hackagebot buildbox 1.0.1.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.0.1.1 (BenLippmeier)
00:37:17 <aRcatan> I'm playing around with my IRC library and trying to come up with an event callback system
00:38:53 <aRcatan> the callbacks should be able to have state so my first thought was this: data Callback a = CB { state :: a, action :: (a -> Event -> IRC a)}
00:39:13 <Pseudonym> Oh dear.
00:39:32 <Pseudonym> Currying, people!
00:39:51 <aRcatan> but having a container of these doesn't work out, of course. so i took a look at existential types and made the type variable a existential
00:40:09 <aRcatan> but then, can I somehow run the action after all?
00:40:35 <c_wraith> is IRC an instance of MonadIO?
00:40:49 <c_wraith> If so, you can just leave state handling to IORefs or the like
00:40:57 <Itkovian> dons: Are the talks recorded?
00:42:03 <nniro> dankna: Data.Dynamic works like a charm, exactly what I needed : http://www.pastebin.ca/1926596   thank you!!! (I can finally go sleep ahah)
00:42:24 <Pseudonym> The whole thing of passing a function and data is for languages without closures.
00:42:49 <Pseudonym> If f :: Foo -> Event -> IRC a, then (f foo) :: Event -> IRC a
00:44:19 <shachaf> Pseudonym: Thanks for rubbing in the way I can't use closures nowadays.
00:44:27 <aRcatan> c_wraith: hmm, true
00:44:46 * shachaf is slightly bitter about it.
00:45:08 <Pseudonym> What language are you using?
00:45:45 <shachaf> C++.
00:45:46 * shachaf sighs.
00:45:52 <Pseudonym> boost::function
00:45:58 <Pseudonym> and boost::bind
00:46:49 <shachaf> Pseudonym: Not really an option in this particular context, I think.
00:47:08 <Pseudonym> If Boost isn't an option, you should resign and get a better job.
00:47:19 <Pseudonym> Personal opinion.
00:49:17 <shachaf> Hmm. I don't actually know much about Boost, since I was discouraged from using it for various reasons and haven't really used C++ before this.
00:49:24 <shachaf> Perhaps I should investigate it further.
00:50:09 <Pseudonym> Definitely.  If you're using C++ and not Boost, then you're wasting effort.
00:50:27 <shachaf> The funny thing is that ~half the people I'm working with are Haskell/LISP/FPers of some sort.
00:50:52 * shachaf will investigate Boost, though.
00:51:16 <Pseudonym> http://www.cc.gatech.edu/~yannis/fc++/ <- Also worth checking out.
00:51:59 <kalven> an up to date compiler should have std::function/std::bind
00:52:15 <Pseudonym> Also true, but not everyone is using an up to date compiler.
00:52:29 <kalven> the horror
00:57:13 <shachaf> kalven: Hmm, how up-to-date would GCC need to be?
01:00:51 <shachaf> Hmm, looks like 4.5.
01:01:28 <kalven> if you have 4.5 then you've got std::function and bind. as well as lambda expressions
01:03:02 <shachaf> kalven: Nope, 4.4, it seems.
01:29:51 <kalven> shachaf: that'll work too, minus lambda expressions
01:40:07 <filius> I have a list of strings, can I map "read" to this list in order to turn it into a list of Integers?
01:40:35 <copumpkin> yeah, you write that :)
01:40:55 <copumpkin> map read ["1", "2", "3"] :: [Int]  ===> [1,2,3]
01:41:28 <filius> ah thanks!
01:53:58 <Maxdamantus> jw, how in Haskell do you something like this? contents = ""; while(c = getchar()) contents += c; print(contents);
01:54:30 <Maxdamantus> doing something like (getContents >>= putStr) results in something more like: while(c = getchar()) print(c);
01:59:22 <Taejo> Maxdamantus: you mean you want to make sure the whole string is read before printing?
02:00:04 <Taejo> @pl getContents >>= \s -> last s `seq` putStr s
02:00:07 <Maxdamantus> I don't really want that, just curious as to what of this is sequentially guaranteed.
02:00:23 <Taejo> getContents is weird because it does lazy IO
02:00:34 <koala_man> weird and awesome
02:00:38 <Maxdamantus> Right.
02:00:43 <Maxdamantus> Yeah, I do quite like that actually.
02:00:54 <Maxdamantus> Hm. So other monadic functions often don't?
02:01:00 <Maxdamantus> in IO
02:01:13 <Taejo> Maxdamantus: yes, because IO is supposed to sequence it's actions
02:01:14 <dancor> readFile for strict ByteStrings isn't lazy
02:01:39 <Taejo> that's the *point* of IO -- you need to do things in the right order
02:02:59 * dancor prefers explicit buffering to mysterious lazy IO
02:04:57 <dancor> well i guess iteratee is the state of the art in replacing lazy IO
02:07:37 <fasta> Maxdamantus, isn't that just 'interact id'?
02:08:15 <Maxdamantus> interact?
02:08:37 <fasta> Maxdamantus, there is a search engine, you know?
02:08:40 <fasta> :t interact
02:08:51 <fasta> @hayoo interact
02:09:21 <fasta> Well, use any of the documentation features, so that you don't have to ask completely trivial questions. interact id works here. Type it in a terminal.
02:09:27 <Maxdamantus> I see, interesting.
02:10:21 <Taejo> interact f = putStr . f =<< getContents 
02:11:15 <Maxdamantus> Yep, figured that out in ghci, just didn't initially interpret it as a Haskell expression when fasta said it.
02:13:04 <Maxdamantus> Hmm.. But is it likely that IO might optimise doing multiple reads sequentially?
02:13:44 <Maxdamantus> do {a <- getLine; b <- getLine; c <- getLine; return (reverse a) ++ (reverse b) ++ (reverse c)}
02:14:03 <Maxdamantus> is that likely to be optimal memory-wise for what it's doing?
02:14:17 <Maxdamantus> near optimal.. assume that they're really big lines.
02:14:21 <fasta> Maxdamantus, Haskell and optimal? 
02:14:40 <Maxdamantus> Hmm.. Well that looks like it could be optimised.
02:14:43 <fasta> Maxdamantus, I would say you should not care. 
02:14:54 <Maxdamantus> What if the lines were 1MB big?
02:14:56 <fasta> Maxdamantus, care when you have a multi-million dollar application. 
02:15:06 <fasta> Maxdamantus, then pay someone to modify the compiler, or do it yourself.
02:15:08 <Maxdamantus> Would it read all three lines before starting to reverse the first one?
02:15:39 <Maxdamantus> s/return/return $/
02:16:15 <Maxdamantus> Meh, I'll try it on some 100MB lines and see what it looks like.
02:16:17 <fasta> Maxdamantus, it could do that, but I am fairly sure that it doesn't.
02:16:40 <quicksilver> Maxdamantus: Yes. IO actions are executed in strict sequence.
02:16:49 <quicksilver> so that reads all three lines before reversing any of them.
02:16:53 <fasta> Maxdamantus, consider that it is launching missiles. 
02:17:06 <quicksilver> (exception : interleaved IO [lazy IO], like getContents)
02:17:18 <fasta> Maxdamantus, and that a, b and c are the return values from the missiles.
02:17:36 <quicksilver> of course it's not required to actually construct the lists immediately. It could merely read into some buffer and then construct the lists lazily. This might be more efficient.
02:17:42 <quicksilver> in practice, it does not do that as far as I know
02:17:50 <quicksilver> it does, in fact, construct the lists immediately.
02:18:01 <quicksilver> if you have 100MB lines you will be better off with bytestring.
02:19:39 <Tarrasch> !paste
02:19:51 <Tarrasch> !pastebin
02:21:33 <quicksilver> Tarrasch: hpaste is down. Use, e.g., codepad or pastebin
02:21:44 <Tarrasch> I have a question, http://haskell.pastebin.com/5B0LbiiM, see bottom of the paste
02:22:22 <Starfire> Is there a recommended package for type-level lists?
02:23:25 <quicksilver> Tarrasch: haskell98 has a very limited rule abuot the valid forms of instance declarations
02:23:48 <quicksilver> Tarrasch: the FlexibleInstances extension relaxes this.
02:24:01 <quicksilver> however, instance Traversable a => Functor2 a where is not all that useful.
02:24:24 <quicksilver> it says that all types are Functor2 instances
02:24:39 <quicksilver> (but propoagates a Traversable context)
02:24:43 <Tarrasch> quicksilver, is it not possible to have that instance with the expressiveness of Traversable?
02:24:57 <quicksilver> alternatively, you could say, it makes a Functor2 context reduce immediately to a Traversable context.
02:25:24 <Jafet> Maxdamantus: getLinesInterleaved!
02:26:07 <Tarrasch> quicksilver, Basically what I wanted was to make a real instance of Traversable for Tree, and then get Functor/Foldable for free since that should be possible, no?
02:26:11 <Maxdamantus> Heh.
02:26:25 <Tarrasch> since it's always possible*
02:26:42 <Jafet> interleavedLaunchMissiles
02:27:21 <Maxdamantus> You mean launchMissilesInterleaved?
02:28:28 <Maxdamantus> Is "launch missile" a verb or a noun?
02:29:01 <Tarrasch> it's two words?
02:29:04 <Jafet> It's, uh, an obscure ada79 naming convention.
02:29:58 <Axman6> launch is a verb, missile is a noun
02:30:07 <Maxdamantus> Tarrasch: (two (words)) can be (a (noun))
02:30:29 <Maxdamantus> "collective noun" or something
02:30:47 <Tarrasch> hmmm. had no idea
02:31:14 <Maxdamantus> No, collective noun is different.. can't remember what it's called exactly.
02:31:53 <Starfire> I guess it's somewhat fitting that trying to compile a type-level list library (tfp) seems to take ages to compile.
02:32:12 <por> If launch is an adjective, it's an adjective phrase; if launch is a noun, it's a compound noun (lacking a determiner); if launch is a verb, then it must be imperative, so it would be a command.
02:32:30 <Maxdamantus> Oh yeah, compound noun.
02:32:31 <Starfire> 4 minutes of CPU time, and counting.
02:33:36 <quicksilver> Tarrasch: yes, but then you'd have the problem that the *only* way to be a Functor was via the Traversable instance.
02:34:25 <quicksilver> Tarrasch: the type class system can't express "here is a generic functor instance which works for all Traversables, but also here are some specific functor instances for some non-Traversable types"
02:34:47 <quicksilver> you can express that with a GHC extension called OverlappingInstances, but that extension is semantically broken, and most people who use it don't recognise the fact.
02:34:53 <Tarrasch> quicksilver, oh ok, I've for long thought how things won't clash if there is such a relaxed syntax in haskell. The answer is then simply that haskell by default don't have that much relaxed syntax 
02:35:26 <Tarrasch> quicksilver, hmm, cool
02:35:40 <Maxdamantus> wait.. adjective phrase O_o
02:36:08 <Maxdamantus> (launch missile) cat
02:36:28 <Maxdamantus> Oh, I guess that could work.
02:36:45 <Maxdamantus> Like rocket maybe, in rocket pack.
02:37:29 <Tarrasch> Just out of curiosity, is there any extension that will make it possible to have an autoinstance (like Traversable implies Functor) and then later delcare an Functor instance for a type which actually is Traversable. (Which makes it having two instances)
02:37:47 <Maxdamantus> or.. catdog.
02:37:59 <Jafet> That requires overlapping instances, at least?
02:39:15 <Saizan> that's such a faq i wonder if anyone has written an article on it already
02:39:20 <Jafet> And a lot of tolerance for strange compilation errors later on
02:39:59 <Saizan> mostly a lot of tolerance for being asked Traversable when you only need Functor, and some tolerance for the wrong instance being picked in some cases..
02:40:33 <quicksilver> Tarrasch: yes, you can do that with OverlappingInstances like I said.
02:40:38 <quicksilver> but it's not wise.
02:41:02 <quicksilver> it's perhaps not too bad if have some tolerance for the wrong instance being picked
02:41:11 <quicksilver> (e.g. the specific one is more efficient but they're both correct)
02:41:22 <Maxdamantus> Just realised that this actually relates to type inference, I think. "Prepare the (launch missiles :: verb)!"
02:41:23 <Tarrasch> quicksilver, oh, I thought that was only letting you create isntances for Functor for types that aren't Traversable (then at least there is only one instance)
02:41:33 <quicksilver> no.
02:41:38 <johan_> How do I get BinaryDerive.hs? The link http://darcs.haskell.org/binary/tools/derive/BinaryDerive.hs from http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-binary-0.5.0.2/Data-Binary.html seems to be broken.
02:42:16 <Tarrasch> However, it would be awesome to just Implement sequenceA and join and then you get Functor, Applicative, Monad, Foldable and Traversable :D
02:42:54 <Saizan> well, it's already like that, sort of
02:43:38 <Tarrasch> Saizan, really? You need Functor and Foldable to even be able to make something Traversable, no?
02:44:25 <Saizan> Tarrasch: instance Traversable F where ....; instance Functor F where fmap = fmapDefault; and i'm pretty confident there's a foldMapDefault for Foldable too
02:44:29 <por> Oh, you're right. It would be an attributive adjective adjoining a noun. Can launch even be an adjective? The launchlike missle? Can something be launchy?
02:45:02 <Tarrasch> and those 5 type-classes opens up for like 100+ functions on your datatype, all of them amazingly enough just based on the sequenceA and join
02:45:06 <Saizan> Tarrasch: so you've to explicitly declare the instance but you don't have to write the implementation
02:45:07 <kremsera> launchable
02:45:16 <Tarrasch> Saizan, there is foldMapDefault
02:46:30 <Tarrasch> Saizan, oh right, maybe that works, it's just that I thought haskell would be confused when you write that
02:46:54 <por> Or, 'You're looking very launchable today (!)'
02:47:02 <kremsera> :D
02:47:47 <ManateeLazyCat> http://www.google.com/realtime cool.
02:48:53 <Maxdamantus> 404
02:49:23 <ManateeLazyCat> Maxdamantus: I can use it.
02:49:47 <Maxdamantus> http://www.google.com/realtime?esrch=RealtimeLaunch::Experiment works O_o
02:50:10 <Tarrasch> ok, g2g, thanks ya'll cu! :)
02:50:27 <Maxdamantus> Hm. That is pretty cool.
02:50:55 <ManateeLazyCat> /hmmm.... stm got some race condition...... debugging....
02:50:58 <Maxdamantus> Oh right, it's just twitter.
02:51:06 <Maxdamantus> Ah, news too.
02:51:34 <ManateeLazyCat> Maxdamantus: And have some from Facebook, Google Buzz...etc.
02:51:48 <ManateeLazyCat> Maxdamantus: Of course, most is from twitter
02:52:12 <Maxdamantus> Yeah, seems to be mostly overwhelmed by Twitter/Facebook messages.
02:56:00 * ManateeLazyCat http://github.com/behlendorf/zfs/wiki 
02:58:58 * Maxdamantus signed up for email alerts for "it"
03:10:04 --- mode: ChanServ set +o quicksilver
03:10:06 --- mode: quicksilver set -b CTAPOMAK!*@*$#haskell-ops
03:11:06 --- mode: quicksilver set -o quicksilver
03:17:58 <ManateeLazyCat> I know why GFileMonitor can't work on /proc, because /proc not realy file, it's just exist in RAM......
03:18:39 <Maxdamantus> It doesn't really exist.
03:19:16 <Jafet> Nothing really exists
03:19:55 <koala_man> stuff in /proc doesn't exist in RAM either, file contents is calculated when read 
03:19:58 <Maxdamantus> Everything that does seem to exist probably exists only in a probably non-existant universe.
03:20:10 <por> Is it possible, here <http://pastebin.com/SP0pHZEF>, to make fmap recurse over (W b) at line 9. I'm pretty sure this is a valid instance of fmap, but it's not doing what I want (and when I make it do what I want, the types become messed up).
03:21:04 <por> (E.g., with nested X's).
03:21:30 <Jafet> Probably it doesn't work because its backend (inotify?) doesn't work either
03:22:07 <Jafet> A few turtles later, you conclude that linux is a piece of crap
03:22:54 <ManateeLazyCat> Jafet: Yep, perhaps. Anyway GFileMonitor can't handle /proc.
03:23:14 <ManateeLazyCat> Jafet: Now i use delay repeat got dynamic value from /proc.
03:24:14 <koala_man> it doesn't work because it doesn't make sense to make it work. should monitoring /proc/interrupts fire every time an interrupt fires? should monitors on stuff in /proc/net on every network packet?
03:25:00 <ManateeLazyCat> koala_man: If GFileMonitor can work, i just monitor /proc/pid/status and /proc/pid/stat
03:25:15 <ManateeLazyCat> koala_man: For dynamic information of running processes.
03:25:24 <Saizan> por: not with those types
03:26:25 <koala_man> polling suits an fs like /proc better. if GFileMonitor doesn't have that as a fallback, it's not linux' fault
03:27:19 <por> Thanks, Saizan. (back to the drawing board)
03:28:38 <Jafet> strace(1): "On Linux, as exciting as it would be, tracing the init process is forbidden."
03:31:41 * ManateeLazyCat Hmm... CPU perfect should be : (sum [utime,stime,cutime,cstime]) / (sum [user,nice,system,idle,iowait,irq,softirq,stealstolen,guest])  * CPU number
03:31:55 <ManateeLazyCat> s/CPU perfect/CPU percent
03:34:14 <koala_man> Jafet: haha cute
03:39:47 <magthe> a question on terminology: Maybe.fromMaybe is XXX, but Maybe.fromJust isn't XXX... what's the term I'm looking for, I'm thinking "complete" but that seems wrong
03:40:29 <Liskni_si> total?
03:40:44 <fffej> fromJust is a partial function because it's not total?
03:41:05 <magthe> yes, that's the one, thanks Liskni_si
03:42:17 <Jafet> (Is there a fromNothing?)
03:42:42 <tab> Jafet: how would you define it ? :)
03:43:03 <Jafet> I suppose you cannot get something from Nothing.
03:47:31 <luite> fromNothing = maybe undefined (const $ error "fromNothing: Just")
03:48:43 <dobblego> looks... very useful
03:48:47 <tab> indeed ..
03:49:45 <luite> hehe
03:50:16 <luite> I never claimed it was :p
03:54:14 <Saizan> fromNothing :: Maybe a -> b
03:55:35 <ivanm> = unsafeCoerce ?
03:55:52 <ivanm> or is it just "const undefined" ?
03:56:45 <kremsera> does unsafePerformIO somehow fit into the functional paradigm?
03:57:11 <ivanm> in terms of purity? no
03:57:18 <ivanm> it's a necessary evil for dealing with FFI though
03:57:34 <ivanm> (in that you use it when you're FFI'ing to a pure function but GHC can't tell that)
03:58:40 <kremsera> so i can do all the evil unsafe imperative stuff within haskell - and nobody can tell since its not in a monad
03:59:05 <ivanm> well, it's not within IO, yes
03:59:28 <kremsera> cool
03:59:38 <ivanm> but if you do that in a released package then the supposedly non-existant Haskell Cabal will come around to your house in the dead of night and beat you up
04:01:15 <tab> nobody knows anything about that obviously
04:01:37 <ivanm> obviously
04:01:46 <ivanm> dcoutts is quite emphatic that such a group doesn't exist
04:02:54 <kremsera> (yet)
04:03:23 <Saizan> all of that in case lazyness didn't beat you for that already
04:07:07 <kremsera> i have currently the following problem: i plan to use some ffi stuff within non-monadic code
04:07:36 <kremsera> but it has to be "initialized" when the program starts - and "destroyed" when it ends - to prevent massive overhead
04:08:45 <tab> if it self contains you can create an IO monad just for this purpose as long as the result is pure ..
04:08:59 <kremsera> besides the initialization and destruction - the ffi stuff i use has purlely functional semantics
04:09:06 <ivanm> kremsera: is the FFI stuff pure?
04:09:13 <zygoloid> kremsera: one way of dealing with that is to write a 'withMyLibrary :: IO a -> IO a', and wrap your main with that
04:09:43 <ivanm> in the sense that every time you pass in a value it gives the same value out (where value includes things like writing files, sending stuff over a network, etc.) ?
04:10:03 <kremsera> yes
04:10:12 <zygoloid> kremsera: there are more advanced techniques for if you want to statically guarantee that your library has been initialized whenever it's used
04:10:30 <kremsera> zygoloid, which for example?
04:10:34 <ivanm> in that case, write an overall IO function that does the FFI, and do unsafePerformIO on that
04:11:10 <zygoloid> kremsera: you can create a monad for using your library (a newtype of Identity would be fine) and have a runMyLibrary :: MyLibrary a -> IO a
04:11:59 <zygoloid> but you lose some of the feeling of purity by using a monad
04:14:26 <kremsera> zygoloid, do you know of an example source using the "wrap main" approach?
04:15:03 <zygoloid> kremsera: (in lib code) withMyLibrary act = initMyLibrary >> act >> uninitMyLibrary (in main) main = wrapMyLibrary main
04:15:28 <kremsera> :D
04:15:37 <kremsera> thanks!
04:16:18 <aristid> @hoogle bracket
04:16:42 <ivanm> preflex: seen lambdabot
04:16:43 <preflex>  lambdabot was last seen on #haskell 9 hours, 26 minutes and 53 seconds ago, saying:   Not in scope: `Data.Generics.Aliases.orElse'
04:16:55 <ivanm> wow, 9 hours?
04:19:36 <Jafet> And time / Passes by / So slowly...
04:22:14 <ivanm> is that meant to be unchained melody?
04:25:33 <kremsera> no its the windows -start sound ;)
04:58:55 <doofer> I'm getting parse errors when trying to generate haddock documentation for GADTs. is there a way to do this? (haven't found any solution in the haddock docs or googling)
05:06:03 <mreh> instance Functor Trans where
05:06:03 <mreh>   fmap f t = T $ \g -> let (a, g') runTrans t g
05:06:03 <mreh>                        in (f a, g')
05:06:12 <mreh> could someone suggest what's wrong with my indentation?
05:06:37 <doofer> did you forget an '=
05:06:40 <doofer> '
05:06:49 <doofer> (a, g') = ...
05:06:52 <mreh> yes
05:07:03 <doofer> still wrong?
05:07:07 <mreh> hang on
05:07:33 <mreh> nah, it's right now
05:07:39 <doofer> great :)
05:07:43 <mreh> I was confused by the error
05:08:54 <mreh> I'm aware that what I'm doing looks the same as the state monad
05:29:40 <MexicoLindo> what is the offtopic channel for Haskell?
05:29:46 <zygoloid> #haskell-blah
05:55:40 <dom96> what's the best way to get the compilation date of a program?
05:56:07 <Zao> Look at the file date? Otherwise, I don't think so.
05:57:14 <dom96> hrm, that's a good idea.
05:57:24 <ivanm> good 'ol ls -l ;-)
06:02:10 <Peaker> Is there an academic explanation of positive/negative type positions anywhere?
06:02:39 <ivanm> not that I know of
06:02:46 <ivanm> were you the one talking to me about this last time?
06:02:54 <Peaker> ivanm, perhaps :)
06:03:01 <Peaker> I asked before, but couldn't find any
06:04:57 <Heffalump> I guess it's just folklore
06:05:16 <ivanm> hey Heffalump 
06:06:18 <Heffalump> hiya
06:06:30 <ivanm> would you have any idea why trying to do an "instance F.Functor f => Functor f" would result in an overlapping instance with my KindPromote instance (what you called SingletonWrapper) ?
06:06:47 <ivanm> explicitly when I tried to use the KindPromote instance
06:06:59 <ManateeLazyCat> > 420264 / 6080867
06:07:04 * ivanm is quite sure he didn't write a Data.Functor.Functor instance for KindPromote)
06:07:05 <Heffalump> doesn't that instance overlap with any Functor instance?
06:07:31 <Saizan> ivanm: contexts don't matter.
06:07:35 <ivanm> oh :(
06:08:00 <aristid> is it possible that ghci always activates ScopedTypeVariables?
06:08:08 <aristid> whereas ghc does not
06:08:13 <ivanm> *sigh* so I have to explicitly do "instance Functor <blah> where fmap = F.fmap" :(
06:08:24 <ivanm> for every possible <blah>
06:08:35 <ivanm> aristid: well, ghci tells me to turn it on when I need it...
06:08:40 <Saizan> yeah, or use a wrapper
06:09:05 <aristid> ivanm: in my case, ghci just swallowed the code and ghc (invoked by cabal build) complained without telling me what to do
06:09:18 <aristid> the only sign was that it appended a 1 to the name of the type in the error message
06:09:21 <ivanm> huh
06:09:37 <aristid> maybe i'm doing evil things :/
06:09:55 <Saizan> aristid: maybe you have it in .ghci ?
06:10:09 <mornfall> Is there a way to catchError any Exception e in transformed IO? (As opposed to just IOException...)
06:10:11 <aristid> Saizan: nah
06:10:25 <ramb0> @src mod
06:10:29 <ManateeLazyCat> mornfall: IIRC, OldException can
06:10:31 <mornfall> I.e. I'd like to handle exceptions in StateT ... IO.
06:10:44 <Heffalump> @type catchError
06:10:46 <ManateeLazyCat> mornfall: And new exception package don't allow you catch *any* exception.
06:10:50 <aristid> hmm maybe it's a bug in ghc, because i actually should not need ScopedTypeVariables, i think
06:10:56 <ramb0> @source mod
06:11:04 <Heffalump> ManateeLazyCat: yes it does, that's what SomeException is for
06:11:21 <aristid> i use type variables from the class instance, not from the function
06:11:47 <mornfall> Heffalump: The ErrorMonad instance for StateT ... IO sets e to IOException.
06:11:48 <ManateeLazyCat> Heffalump: But sometimes user don't know what exception will throw. .... :)
06:12:19 <mornfall> MonadError I mean.
06:12:24 <aristid> somehow, writing JSON instances for complex types is not very much fun :/
06:12:54 <ivanm> ManateeLazyCat: SomeException will catch all exceptions, but it isn't recommended
06:13:01 <ivanm> since it will even catch C-c
06:13:06 <Saizan> mornfall: you can newtype that and write your own instance Exception e => MonadError e NewtypedIO where ..
06:13:39 <ManateeLazyCat> ivanm: Oh, i see.
06:14:27 <ManateeLazyCat> ivanm: I just got exception "hGetContents : does not exist" error from my process manager, I guess it's fault of hGetContents
06:14:53 <Saizan> mornfall: actually, it doesn't fit very well because of the fundep in MonadError, so you'd have to use SomeException there
06:14:57 <ivanm> yes; the documentation for it should tell you what the possible Exception types it can throw are
06:15:28 <ManateeLazyCat> ivanm: Maybe i need use other function replace readFile since readFile use hGetContents this stupid function.
06:15:42 <Saizan> that exception is catchable
06:15:51 <ManateeLazyCat> Saizan: How ?
06:15:56 <ManateeLazyCat> Saizan: SomeException?
06:16:12 <Saizan> yeah, and probably by some more specific one too
06:16:32 <ManateeLazyCat> Saizan: I use (\_ :: IOError) -> bla....) catch readFile.
06:17:04 <ManateeLazyCat> Saizan: Looks not right Exception match "hGetContents : doese not exist" error.
06:17:18 <mornfall> Hm. I guess the StateT instance for MonadError loses the state at the point of the exception anyway. :|
06:17:33 <mornfall> (From looking at its implementation.)
06:17:44 <ivanm> maybe an isEOFError ?
06:17:47 <ivanm> whatever that is...
06:18:00 <ivanm> oh, that's IOError
06:18:15 <Philippa> mornfall: that's not about the implementation, it's about the order you stacked the effects in
06:18:19 <ivanm> ManateeLazyCat: maybe it refers to the Handle not existing...
06:18:22 <ManateeLazyCat> ivanm: I donnu, need research..
06:18:29 <Philippa> if you want state to persist past exceptions, you want ErrorT State
06:18:43 <ManateeLazyCat> ivanm: I use readFile scan some files under /proc.
06:18:45 <mornfall> Philippa: There's no IOT to my knowledge...
06:18:48 <aristid> how long do you let your haskell modules become until you split them up?
06:18:56 <ManateeLazyCat> ivanm: Maybe too many files, sometimes hGetContents will failed.
06:19:01 <mornfall> IOT State would be interesting though. :)
06:19:09 <mornfall> Maybe I should just drop StateT and use IORefs.
06:19:14 <Saizan> ManateeLazyCat: http://pastebin.com/JJEwGqrK
06:19:22 <Philippa> if that's the semantics you want, yes
06:19:34 <mornfall> Well, keep an IORef in StateT or something.
06:20:16 <mornfall> Philippa: Well, it would be conceivable that throwError/catchError wrap the exception in StateError state exception, right?
06:20:41 <ManateeLazyCat> Saizan: Ignore 'e' can work? I mean like this : (\_ -> return "")
06:21:11 <Saizan> ManateeLazyCat: with the right type annotation, yes
06:21:17 <Jafet> const (return "")
06:21:41 <Saizan> (\ e -> (e :: IOException) `const` return "")
06:22:02 <ManateeLazyCat> Saizan: Thanks, i use that replace my code and test again.
06:22:05 <Saizan> or (\ (_ :: IOException) -> return "") with ScopedTypeVariables
06:22:32 <ManateeLazyCat> Saizan: I use IOError to catch readFile, looks not right.
06:22:35 <Saizan> though maybe since your error mentioned hGetContents it's something different in your case
06:22:40 <mreh> I get "warning Prelude is deprecated". Is that more to do with a the version of base than Prelude?
06:22:54 <Saizan> type IOError = IOException
06:23:09 <Saizan> mreh: yes, see the deprecation message
06:23:15 <ManateeLazyCat> Saizan: Hmm... so it's fault of hGetContents.
06:23:22 <ManateeLazyCat> Saizan: readFile use hGetContents.
06:23:56 <Saizan> ManateeLazyCat: if you paste a testcase we can investigate.
06:24:08 <ManateeLazyCat> Saizan: Ok, wait.
06:24:20 * ManateeLazyCat pasted "Proc.hs" at http://paste2.org/get/966209
06:24:26 <Saizan> mreh: if you're using cabal-install it might just mean that you forgot to put an upper bound on your base dependency
06:24:37 <ManateeLazyCat> Saizan: Above is my Proc.hs for parse process information of Linux. 
06:25:00 <Saizan> ManateeLazyCat: i meant something smaller :)
06:25:02 <quicksilver> readFile--
06:25:16 <quicksilver> you probably can't catch exceptions with readFile because the IO is interleaved.
06:25:24 <ManateeLazyCat> Saizan: Proc.hs is small, IMO, :)
06:25:45 <ManateeLazyCat> quicksilver: So what's the *right* way? 
06:25:45 <quicksilver> although in this case one seq might be enough because you only need to force one char to notice the file doesn't exist?
06:26:02 <quicksilver> ManateeLazyCat: burn System.IO and rewrite readFile not to use interleaved IO? ;)
06:26:11 <Saizan> quicksilver: the file is opened strictly, as i've shown above
06:26:39 <ManateeLazyCat> quicksilver: That's my plan if my code is right.
06:26:40 <Saizan> though "does not exist" might be what hGetContents says if the file disappears midreading?
06:26:43 <quicksilver> hmm
06:26:55 <quicksilver> good point.
06:27:19 <ManateeLazyCat> quicksilver: I doubt stupid hGetContents do something wrong....
06:27:45 <Saizan> (which i guess can only happen with weird things like /proc, normally the Handle would keep the file there even if unlinked, no?)
06:28:10 <ManateeLazyCat> Saizan: Since i use readFile from /proc, i guess some process disappear when reading....
06:28:18 <ManateeLazyCat> Saizan: /proc is not realy file....
06:28:39 <ManateeLazyCat> Saizan: I just don't understand why my code can't catch exception of readFile.
06:29:02 <mornfall> ManateeLazyCat: Because of unsafeInterleaveIO used in hGetContents?
06:29:10 <ManateeLazyCat> mornfall: Yep.
06:29:17 <Saizan> ManateeLazyCat: it's an exception in the resulting String, not from readFile
06:29:19 <mornfall> Well, use System.IO.Strict.
06:29:40 <mornfall> Lazy IO is evil.
06:29:45 <quicksilver> Saizan: Hmm. read(2) claims it cannot return ENOENT
06:29:55 <quicksilver> Saizan: read(2) can return ENXIO though
06:30:04 <ManateeLazyCat> mornfall: I hope ghc developer remove hGetContents....
06:31:30 <Saizan> it should just be moved to System.IO.Interleaved :)
06:32:17 <ManateeLazyCat> mornfall: Hmm, System.IO.Strict.hGetContents length of string, then string return non-lazy? :)
06:33:05 <mornfall> If you evaluate length of a string, you force it.
06:33:13 <mornfall> (force the string tha tis)
06:33:16 <mornfall> that is*
06:33:22 <ManateeLazyCat> mornfall: That's not be slow?
06:33:38 <mornfall> Not any slower than any other list-based IO would be.
06:33:51 <mornfall> It may be more memory hungry though.
06:34:24 <ManateeLazyCat> mornfall: I more like the true strict version of hGetContents that don't need length force it.
06:34:52 <ManateeLazyCat> Saizan: What do you mean "it's an exception in the resulting String, not from readFile" ?
06:37:27 <ManateeLazyCat> Anyway, i try to use System.IO.Strict.readFile replace and try again....
06:38:03 <dom96> @pl (\e -> putStrLn $ "Unable to connect: " ++ (show e))
06:38:10 <dom96> :O no lambdabot
06:38:15 <Saizan> ManateeLazyCat: that readFile completes successfully giving you a String, this String is the one throwing the exception when you evaluate it
06:38:45 <Saizan> > ' ' : error "foo"
06:38:47 <ManateeLazyCat> Saizan: Yep, i know exception is throwed when readFiel.
06:38:58 <dom96> ManateeLazyCat: that memoserv message you sent me. It seems to be a problem with ghc not my library.
06:39:05 <Saizan> ManateeLazyCat: that's not what i said
06:39:07 <ManateeLazyCat> dom96: Yes.
06:39:20 <ManateeLazyCat> dom96: I fix it by reinstall ghc.
06:39:29 <dom96> ManateeLazyCat: ok
06:39:37 <ManateeLazyCat> dom96: BTW, your demo can't work.
06:39:52 <dom96> ManateeLazyCat: yeah, i haven't updated it in a while lol
06:40:02 <dom96> ManateeLazyCat: i'll update it in a while
06:40:10 <ManateeLazyCat> dom96: But library code is pretty clean.... :)
06:40:18 <dom96> ManateeLazyCat: heh, thanks :)
06:40:31 <ManateeLazyCat> dom96: If you can update demo code, i plan to use your IRC library.
06:40:57 <syntaxfree> where be lambdabot?
06:40:59 <dom96> ManateeLazyCat: Take a look at my IRC Bot, it's always up to date with the Library.
06:41:07 <syntaxfree> @get-shapr
06:41:13 <ManateeLazyCat> dom96: Where your IRC bot?
06:41:27 <dom96> ManateeLazyCat: http://github.com/dom96/ElysiaBot
06:41:41 <syntaxfree> what happened to the web interface to lambdabot, btw?
06:42:03 <ManateeLazyCat> dom96: Thanks.
06:42:57 <ManateeLazyCat> dom96: I haven't run demo success, but from your library code, IMO, it's cleanest IRC parse library i have seen.
06:43:19 <dom96> ManateeLazyCat: that's good :)
06:44:04 <dom96> ManateeLazyCat: all you really need to do to get the example code running is add 'True' in line 28
06:44:21 <ManateeLazyCat> dom96: Infact, i need some code parse IRC message and don't need other framework code, i have complete framework handle multi-threads loop.
06:44:25 <dom96> (or False if you don't want debug messages)
06:44:59 * ManateeLazyCat Downloading strict-0.3.2
06:45:48 <dom96> ManateeLazyCat: you can just use my message parsing if you wish. The library is licensed under BSD3, so you can just copy the parsing module.
06:46:30 <ManateeLazyCat> dom96: Yes, i have seen your 'connect' source code and add False, no response from example.
06:46:43 <dom96> ^ it seems to have connected ..
06:46:45 <ManateeLazyCat> dom96: Thanks, i will.
06:47:00 <ManateeLazyCat> dom96: But nothing response.
06:47:17 <dom96> |hai
06:47:17 <SimpleIRCBot> hai thar!
06:47:19 <dom96> ^
06:47:28 <ManateeLazyCat> dom96: I have some IRC backend, it's almost connected immediately ....
06:47:40 <ManateeLazyCat> dom96: But your example looks no response....
06:47:54 <dom96> ManateeLazyCat: what do you mean? it connects too slowly?
06:48:53 <Axman6> dom96: this isn't the channel to test out 
06:48:56 <ManateeLazyCat> dom96: I change 28 line to "connect ninthbit False False" and compile successfully, but when i do "./example", nothing otput from terminal.
06:48:58 <Axman6> IRC bots*
06:49:06 <dom96> Axman6: tell that to ManateeLazyCat not me
06:49:18 <Axman6> ManateeLazyCat: see above
06:49:32 <Axman6> i believe there's a ##test for just such usage
06:49:36 <ManateeLazyCat> Axman6: I'm not test IRC client, i just ask question about dom96 's IRC library.
06:49:39 <dom96> ManateeLazyCat: ahh, You need True instead of False
06:49:45 <Twey> #bots
06:49:56 <dom96> #botters
06:50:06 <ManateeLazyCat> dom96: Works....
06:50:13 <ManateeLazyCat> dom96: Great.....
06:50:45 <dom96> ManateeLazyCat: you can also bind to the RawMsg event
06:51:16 <ManateeLazyCat> dom96: Thanks, maybe i will copy your Message.hs library for my need.
06:51:24 <dom96> ManateeLazyCat: ok
06:51:35 <ManateeLazyCat> dom96: I need specify control code for multithread MVC design....
06:51:38 <dom96> ManateeLazyCat: i hope you will give me credit :P
06:51:55 <ManateeLazyCat> dom96: Thanks for your great job! :)
06:52:27 <ManateeLazyCat> dom96: http://www.flickr.com/photos/48809572@N02/ My project, irc-client backend finish, developing IRC paser....
06:53:14 <co_dh> can I define a new type in ghic ? 
06:53:25 <co_dh> like type UpdatePool = Int
06:53:25 <dom96> ManateeLazyCat: cool
06:53:26 <quicksilver> co_dh: only by putting it in a file and loading that file
06:53:35 <co_dh> thanks.
06:54:06 <ManateeLazyCat> dom96: I need build irc-rounter in separate processes, then i can use my gtk client login multiple server/channel with same logic.
06:54:15 <ManateeLazyCat> dom96: And some specify thread control....
06:54:30 <ManateeLazyCat> s/specify/specific
06:55:59 <dom96> oh, btw i think you might actually be able to just import Network.SimpleIRC.Messages in your application. Since it exports the parse function
06:56:48 <ManateeLazyCat> dom96: Yes, that's good idea. :)
06:57:10 <dom96> :)
06:58:08 <rushe> Is there a haskell function that duplicates items in a list, for example [5,1,2] becomes [5,5,1,1,2,2]?
06:59:14 <otto_s_> > [5,1,2] >>= (replicate 2)
06:59:14 <ivanm> concatMap (replicate 2)
06:59:36 <otto_s_> ?
06:59:50 <aRcatan> lambdabot is hiding
06:59:51 <Zao> > let f xs = [x | x <- xs, y <- repeat 2 ()] in f [5,1,2]
06:59:56 <ManateeLazyCat> dom96: Have you upload SimpleIRC on hackage?
07:00:01 <dom96> ManateeLazyCat: not yet
07:00:06 <ManateeLazyCat> dom96: It's awesome library.
07:00:08 <Zao> Except mine doesn't work :D
07:00:23 <ManateeLazyCat> dom96: Why not? Still have some bug?
07:00:24 <Zao> Err, replicate.
07:00:42 <dom96> ManateeLazyCat: I still need to write docs, and i really can't be bothered heh
07:00:47 <aRcatan> how many unpublished IRC libraries for Haskell exist?
07:01:01 <dom96> ManateeLazyCat: i also want to include some more features before putting it on hackage
07:01:16 <ManateeLazyCat> dom96: I think you can just upload it since your code is clean enough even don't need docs... :)
07:02:09 <ManateeLazyCat> dom96: I upload my package as soon as possible....
07:02:18 <rushe> Thanks it works
07:02:47 <dom96> ManateeLazyCat: I want to make sure it works :)
07:02:55 <ManateeLazyCat> dom96: Ok.
07:02:57 <dom96> As well as it should.
07:10:05 <dom96> aRcatan: don't worry, it'll be published soon.
07:13:23 <roconnor> @wiki IO_Semantics
07:14:02 <djahandarie> http://www.haskell.org/haskellwiki/IO_Semantics
07:14:17 <geheimdienst> djahandariebot is really lagging
07:14:39 <djahandarie> lag is proportional to name length
07:15:03 <geheimdienst> so that's why dons is so productive
07:15:21 <djahandarie> lol
07:15:32 <Ke> I should probably worry then
07:16:10 <geheimdienst> you could always change your nick to HighLatencyKeLagsALot
07:16:14 <Ke> though typically latency is inversely proportional to troughtput
07:16:26 <Ke> -t
07:19:27 <Peaker> window-size = throughput * latency
07:20:28 <Raevel> success, i remember how to work with monad transformers but had forgotten string concatenation
07:21:05 <Raevel> almpst ended up using concat
07:22:09 <Sadache> hi all
07:22:48 <Sadache> I am looking for a simple algorithm that would give me the page result state
07:23:12 <Sadache> so for 1 .. 100 if I am at 1 it would give 1,2,3,4,5 ... 100
07:23:51 <Sadache> if I am at 9 it would give 1 ... 6,7,8,9,10,11,12... 100
07:24:21 <Sadache> and for 99 it gives 1... 96,97,98,99,100
07:25:48 <luite> hmm, I'm pretty sure I've seen this exact same question here before
07:27:59 <aruns> hi i just upgraded to ghc-HEAD and now i'm having some trouble with some cabal dependencies.
07:28:39 <aruns> i'm trying to install snap (web framework) and it gives me this - cabal: cannot configure unix-2.4.0.1. It requires base ==4.2.*
07:29:01 <Saizan> aruns: that's because ghc-head has base-4.3
07:29:03 <HaskellNewbie> Let me see. First, the neighborhood: neighborhood current radius = [current-radius .. current+radius]
07:29:09 <aruns> the installed version of my base is 4.3.0. i tried modifying snap-core.cabal 
07:29:32 <Saizan> aruns: you also need to bump the version number for snap-core if you do that
07:29:50 <HaskellNewbie> Then filter out anything below the minimum and above the maximum from the neighborhood.
07:29:55 <aruns> in the root directory of snap. but this is what it says under build-depends: base >= 4 && < 5,
07:30:23 <Saizan> aruns: the message is cannot configure unix-2.4.0.1. It requires base  ==4.2.*
07:30:26 <aruns> could you explain that HaskellNewbie - i'm a haskell-super-noob here :)
07:30:42 <Saizan> aruns: so you'd need to do that for unix.
07:30:48 <Saizan> aruns: not for snap-core
07:30:52 <HaskellNewbie> Then prepend "1 ..." if 2 is not in the neighborhood, and postpend "... 100" if 99 is not in the neighborhood
07:31:14 <geheimdienst> aruns, are you sure you need ghc-HEAD if you're new to haskell?
07:31:56 <HaskellNewbie> aruns: Sorry, I was answering an earlier question
07:32:00 <Saizan> aruns: be warned that most packages haven't been updated to work with ghc-head
07:32:01 <Axman6> HaskellNewbie: postpend -> append :)
07:32:19 <Sadache> HaskellNewbie: looks like good way
07:32:58 <HaskellNewbie> Alright, now my question. :) How could I make a constructor for a tree data type such that the max number of branches per node is a constructor parameter? Do I need to use Template Haskell to do something like this?
07:33:45 <Saizan> you can enforce that with gadts
07:34:02 <HaskellNewbie> Huh, I haven't heard of gadts; let me go google it
07:34:33 <aruns> geheimdienst: i was just testing out ghc-head for the new llvm functionality. i do need that for my project
07:35:07 <aruns> Saizan: i dont mind doing a manual install if i can understand where cabal is getting its dependency requirements from.
07:35:26 <aruns> i can't seem to find the dependency for 4.2.* anywhere in snap*.cabal files
07:35:32 <Saizan> aruns: the error message is saying that  unix-2.4.0.1 cannot be configured
07:35:42 <Saizan> aruns: so you've to look in unix's cabal file.
07:36:15 <aruns> there isn't one in the snap directory. could it be in the installed libraries somewhere ?
07:36:34 <Saizan> aruns: cabal-install will fetch missing deps from hackage for you
07:36:48 <Saizan> aruns: use "cabal unpack unix" to get the source
07:37:07 <aruns> oh btw just to clarify.. yes i'm not using cabal install package, since that is complaining about broken dependencies
07:37:17 <aruns> i downloaded the source and i'm installing from it using cabal install
07:37:31 <Saizan> aruns: it'll still download the missing deps from hackage
07:37:59 <aruns> Saizan: it hasn't. i tried cabal install snap-server and it failed saying base had to be between 3.0 and 4.2
07:38:13 <aruns> whereas my base, like you or someone pointed out, is 4.3
07:38:22 <geheimdienst> aruns, ok i see i misread your earlier comment :-)
07:38:45 <geheimdienst> the situation seems to be: snap depends on the "unix" package, which depends on base < 4.3
07:38:49 <Saizan> aruns: anyhow "cabal unpack unix; cd unix-2.4.0.1; edit the .cabal file relaxing the dependency on base and _bumping the version number to 2.4.0.1.1_ and then cabal install from there.
07:39:05 <geheimdienst> ... saizan has a good approach
07:39:20 <Saizan> aruns: it'll still download the source packages, and then it'll try to install them and report you errors, like it did.
07:39:34 <aruns> trying that, brb
07:40:17 <Saizan> aruns: once you've cabal install'ed that modded unix you'll have to restart the installation of snap-core
07:40:20 <mornfall> Hm. Is there the dual of IsString somewhere?
07:40:55 <aruns> that might be working, unix seems to be building. thank you both :)
07:41:05 <geheimdienst> btw, what is a "dual"? been meaning to ask that a long time. wikipedia doesn't seem to know
07:41:21 <aruns> i must say this is one of the most active, friendly and helpful programming channels i've been on.
07:41:45 <Saizan> geheimdienst: in category theory the dual of something is when you interpret it in the opposite category, i.e. with the arrows in the reverse direction
07:41:46 <geheimdienst> aruns, i find it offensive that you forgot "clever"
07:41:49 <geheimdienst> and "humble"
07:41:54 <mornfall> geheimdienst: In this case, a class with a toString :: a -> String method (IsString has fromString :: String -> a).
07:42:09 <aruns> lol
07:42:43 <Saizan> mornfall: would that have a similar "syntactical" use?
07:42:45 <geheimdienst> i see. thanks.
07:43:04 <mornfall> Saizan: Well, it would make it possible to write functions that don't care if their input is string or bytestring or whatever.
07:43:17 <mornfall> Saizan: Where IsString lets you omit pack, ToString would let you omit unpack.
07:44:03 <mornfall> It's really dual! :)
07:44:09 <Saizan> mornfall: ah, IsString is mostly meant for OverloadedStringLiterals (if that's the right name) though
07:44:51 <Saizan> there are a few ListLike/StringLike classes out there more geared towards what you're looking for, i think 
07:44:55 <aruns> missed seeing that bit about bumping the version. snap-core is still complaining about unix. going to try rebuilding it
07:45:00 <Saizan> i'm not sure it makes much sense.
07:45:09 <aruns> but you know what, i dont see a requirement for unix at all in the build deps of snap-core.cabal
07:45:17 <aruns> i wonder where its getting it from
07:45:29 <Saizan> aruns: bumping the version is fundamental
07:45:43 <aruns> i added a .1 to the end of the current one
07:45:46 <geheimdienst> it might be via some other package ... snap -> foobar -> doodle -> unix -> base-4.2
07:45:50 <aruns> adding .1_ gave me a parse error
07:45:59 <aruns> geheimdienst: ahh right
07:46:13 <Saizan> aruns: sorry, just .1
07:46:23 <Saizan> the _ was for emphasis :)
07:46:37 <aruns> ahh ok :)
07:46:56 <Saizan> snap-core -> unix-compat -> unix
07:47:07 <aruns> but now i need to figure out what package requires unix 2.4.0.2 and change it to 2.4.0.2.1 right ?
07:47:14 <Saizan> aruns: no
07:47:43 <Saizan> aruns: i meant that you have to change the version: field in unix.cabal
07:47:57 <geheimdienst> i'd start by looking at "cabal list unix", if your 24021 really is correctly installed now
07:48:22 <geheimdienst> (brb)
07:48:24 <aruns> thats what i did and it seems to be compiling it now Saizan
07:49:13 <aruns> thankfully all the other packages it seems to need aren't complaining about base version
07:49:15 <Saizan> once that unix is installed, snap-core installation should progress, maybe giving another error though :)
07:49:20 <aruns> would have been a pain to manually install all of them
07:49:40 <aruns> thats what i'm looking for, but all seems to be going well so far. though its a lot of packages being downloaded and installed
07:49:58 <aruns> have any of you played around with the -fllvm switch in ghc-HEAD ?
07:51:11 <aruns-afk> brb
08:08:00 <siracusa> Sadache: Since I think I'll need exactly this for my website, here's a simple solution to your problem. n is the current page number, k the number of pages before and after n, and 0 in the output indicates to put in "..." there:
08:08:08 <siracusa> > let min=1; max=20; n=10; k=2; is=[i | i<-[n-k-(if n+k>max then n-max+k else 0) .. n+k+(if n-k<min then n-min+k else 0)], i>min, i<max] in concat [[min], if head is-1==min then [] else [0], is, if last is+1==max then [] else [0], [max]]
08:08:23 <siracusa> Aw, no lambdabot?
08:08:48 <roconnor>  [1,0,8,9,10,11,12,0,20]
08:08:53 <medfly> lol
08:09:06 <zygoloid> thanks, manually-running-ghci-bit
08:09:07 <medfly> @botsnack
08:09:08 <roconnor> I did it in my head
08:09:08 <zygoloid> *bot
08:09:08 <djahandarie> roconnor lags much less than me
08:09:10 <medfly> =)
08:09:18 <roconnor> :O
08:15:58 <aruns-afk> ls
08:16:04 <aruns-afk> oops
08:20:19 <aruns> anyone having trouble installing the mtl package? 
08:22:12 <Ziphilt> hello all, i am having trouble installing a haskell library (HsShellScript, tell me if this is a bad idea in the first place): GHC complains that some functions are not in scope, so i have been trying to fix the library's import declarations. it has partially worked, but it seems that several haskell libraries export the same things (GHC.IO.Handle.FD and GHC.IO.FD for example). what is the deal with them?
08:23:12 <Zao> Ziphilt: It may be assuming a particular base, maybe?
08:23:22 <Ziphilt> that could be it
08:23:48 <Ziphilt> it lists an older version i think
08:24:50 <Ziphilt> the package distribution has a file called hsshessscript.pkg, with a line "depends: base-3.0.3.1 haskell98-1.0.1.0 parsec-3.0.0 unix-2.3.2.0"
08:25:14 <Ziphilt> s/hsshessscript/hsshellscript
08:26:18 <geheimdienst> aruns, don't tell me, mtl is conflicting with monads-tf or somesuch? try ghc-pkg hide monads-tf
08:27:56 <McManiaC> how are you supposed to use Data.Time.Format.parseTime/formatTime without the "defaultTimeLocale" from the "old-locale" package? is there a "new-locale" package aswell?
08:28:02 <Ziphilt> so how do i deal with the older version
08:28:03 <Ziphilt> ?
08:28:15 <Ziphilt> do i find that version and install it manually?
08:30:05 <aruns> Ziphilt: i would just change the .cabal file and ask it to use the newer version of the library you have. see if that works first
08:30:28 <aruns> then install the older version if it doesn't. but i dont know. i'm really new to all this myself, that might not be the best idea
08:31:42 <Ziphilt> aruns, that sounds good but how do i detect which version of base i have?
08:31:57 <Ziphilt> i'm on ubuntu, i see nothing in Synaptic
08:32:25 <quicksilver> McManiaC: you have to use old-locale
08:32:30 <aruns> try cabal list base --installed
08:32:35 <quicksilver> McManiaC: it was planned to have a new one but nobody actually wrote it :P
08:32:52 <McManiaC> okay
08:33:07 <geheimdienst> ziphilt, if i remember correctly, there is no new-locale. that the locale package calls itself "old" is bunk and a conspiracy to confuse newbies
08:33:28 <geheimdienst> use old-locale, it's just a misnomer
08:34:59 <McManiaC> > parseTime defaultTimeZone "10:10" "%H:%M" :: Maybe TimeOfDay
08:35:11 <McManiaC> whats wrong with this?
08:36:38 <Ziphilt> geheimdienst: what?
08:36:38 <mreh> this new ghc-pkg is strange, is it highlighting hidden packages?
08:36:47 <McManiaC> ah lol
08:36:55 <McManiaC> broken haddock doc
08:39:16 <Jafet> > fix $ mapM_ forkProcess . repeat
08:39:16 <geheimdienst> ziphilt, i meant the old-locale package is the one everyone uses. the name is misleading. there is no "new-locale".
08:39:52 <geheimdienst> ziphilt, also, i'm an idiot. i meant to address mcmaniac, not you :-/
08:39:52 <aruns> i'm getting an error during the build of mtl - Duplicate instance declarations: instance Error e => Monad (Either e) at line 76 and 87 of Control/Monad/Error.hs
08:40:01 <Ziphilt> oh that clears up the confusion
08:40:28 <McManiaC> geheimdienst: yeah I understood :)
08:41:11 <aruns> but there are 4 parameterized error monads defined using similar code. any idea why its bombing out on these two? or how to fix this?
08:42:36 <Ziphilt> aruns, "cabal install base-3.0.3.1" does not work, is that what i am supposed to do?
08:43:21 <byorgey> Ziphilt: no, you should never install base yourself
08:43:22 <aruns> to update your version of base? you will have to update ghc i think
08:43:41 <Ziphilt> not update; downgrade
08:43:54 <byorgey> Ziphilt: base-3.0 is very old
08:43:59 <Ziphilt> this library won't compile with my newer version
08:44:03 <aruns> well instead of downgrading, try what i said
08:44:13 <Ziphilt> should i even bother with hsshellscript?
08:44:17 <aruns> modify the .cabal of the library to accept base >3
08:44:40 <Ziphilt> aruns, i forgot to mention: i tried that with no change in the compile errors
08:44:47 <aruns> see if that works. it seems to have worked for me for something i'm installing. except its now bombing out at mtl package
08:45:36 <Ziphilt> this library has a .pkg file, not a .cabal file
08:45:40 <Ziphilt> is that the problem?
08:45:59 <aruns> hmm you'll have to look it up. i haven't worked with any libaries using pkg yet. not sure where to change that
08:46:10 <aruns> but even that must have a build-depends or something similar to that
08:46:14 <byorgey> Ziphilt: this sounds like a very old library.  where did you find it?
08:46:31 <aruns> just search the .pkg for base and 3.* and modify it there
08:48:01 <Ziphilt> http://haskell.org/haskellwiki/Applications_and_libraries/Operating_system#Shell
08:48:08 <Ziphilt> the top one listed
08:48:38 <Ziphilt> aruns, i did try to modify the .pkg file
08:48:46 <Ziphilt> it just had no effect
08:49:33 <byorgey> hmm, I guess it is not that old
08:49:34 <aruns> Ziphilt: what did it say and what did you change it to ?
08:50:31 <Ziphilt> was 3.0.3.1, changed to 4.2.0.0
08:51:29 <aruns> check the versions of other libraries it depends on
08:51:39 <aruns> there might be references to base 3.0.3 elsewhere
08:51:45 <Ziphilt> depends: base-3.0.3.1 haskell98-1.0.1.0 parsec-3.0.0 unix-2.3.2.0
08:51:58 <Ziphilt> i'll check which versions i have of those
08:53:30 <byorgey> Ziphilt: you may also want to try http://hackage.haskell.org/package/HSH
08:54:04 <byorgey> that ought to work without problems as far as I know, it is up-to-date and actively maintained
08:54:15 <Ziphilt> that looks good, i saw it listed
08:54:38 <byorgey> basically these days if I can't install something automatically from Hackage with cabal install, I don't bother.
08:55:23 <Ziphilt> hsshellscript is still refusing to compile, now giving up
08:55:29 <Ziphilt> i'll try HSH
09:00:54 <Ziphilt> it seems to have installed correctly, albeit with a bunch of warnings (defined but not used, orphan instances, redundant imports). are they okay?
09:02:31 <por> If I have a data type e.g. (N b a = L a | B b (N b a) (N b a)) with a functor instance, why can't I define a newtype (T e = T (N e e)) and write: (fmap f (T n) = T {case n of (L a) -> L (f a); (B a u v) -> B (f a) (fmap f u) (fmap f v)})? Shouldn't my newtype override the fact that u :: N b a, e.g., make u :: N a a?
09:03:30 <por> not e.g., i.e.*
09:09:08 <geheimdienst> how could i do something like this in haskell? "var unitTests = array of tests" and then throughout the file i'd say "unitTests.append(testThis)". in hs i got a bazillion unit tests all over the file, then at the end i have unitTests = [ testThis, testThat, ... ]. that seems a little redundant
09:12:08 <geheimdienst> e.g., i guess when i'd say unitTest "testThis" = ... and later unitTest "testThat" = ... that way unitTest would be a big function matching a lot of patterns. so is there any way to run each pattern match ...?
09:12:42 <azaq231> geheimdienst: AFAIR you can't since top level bindings are statically defined at compile time (if I call that correctly) and, as every functional value, constants, so unchangeable
09:12:45 <ezyang> geheimdienst: I suspect you can do something like this automatically with template HAskell. 
09:12:52 <Jonno_FTW> @src any
09:13:02 <ezyang> I've been wondering a little bit about this problem myself. 
09:13:02 <Jonno_FTW> >__>
09:13:22 <Jonno_FTW> is lambdabot down?
09:13:23 <ezyang> Another possibility is to use GHC to extract function names that look like tests, and run those dynamically. 
09:13:35 <Jonno_FTW> > map (+1) [1..10]
09:14:23 <dom96> how can i get the date and time as a string. i.e something like this 'Sat Jan 23 13:28:23 UTC 2010' ?
09:14:29 <geheimdienst> yeah TH might be an option. how high is the barrier of entry? i heard the other day it's a lot of complexity
09:14:31 <geheimdienst> this thing looks like just a tiny bit out of reach with regular haskell, making TH feel like overkill
09:14:40 <Jafet> [2,3,4,5,6,7,8,9,10,11]
09:14:42 <djahandarie> I'd summon the lambdabot quote but it isn't here
09:15:14 <geheimdienst> dom96, iirc formatTime "%c" =<< getZonedTime. you need 1-2 imports from Data.Time or thereabouts
09:15:36 <geheimdienst> Data.Time.{LocalTime,Format} i guess
09:15:51 <ezyang> geheimdienst: In that case, it should be easy, right?! :-) 
09:15:59 <dom96> geheimdienst: ahh, thanks
09:17:22 <geheimdienst> ezyang, Haskell. Making hard things easy, and easy things an endofunctor.
09:18:32 <Maxdamantus> Is there a prelude/something function similar to (length . filter)?
09:20:02 * geheimdienst has often wished that the haddocks had a section in big friendly letters showing 1-2 normal uses that most people would look for. Data.Time and these things are harder to figure out than necessary because there's 60 functions across 4 modules, and coming in, it's difficult to tell that function #32 in module #3 is the big entry point.
09:21:36 <djahandarie> Maxdamantus, what would be the difference? (And I don't think there is)
09:21:52 <Maxdamantus> Difference between what?
09:22:06 <djahandarie> Between (length . filter) and whatever function you're looking for
09:22:13 <Maxdamantus> I'm just wondiring if there's something that already exists.. I'll just use length . filter for now.
09:24:51 <Maxdamantus> er, (length . filter) doesn't even make any sense >_<
09:25:49 <por> is there a way to do this without the newtype wrapper <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29508#a29508> ? Auugh, the types.
09:26:07 <por> length . filter f?
09:26:12 <aruns> here is the error i am getting while trying to build mtl, if someone has time to have a look - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29504#a29504
09:30:45 <byorgey> aruns: what are you trying to accomplish?
09:31:18 <byorgey> wait, that is code from mtl?  and you're getting a duplicate instance error?
09:33:54 <EvanCarroll> foldr (\x a -> if null a then x else (x++"=?,")++a ) "" (words "col1 col2 col3")
09:34:08 <EvanCarroll> can that be better written?
09:34:16 <Ziphilt> thanks to aruns, geheimdienst, and byorgey for your help
09:34:32 <Ziphilt> i'll be working with hsh now
09:34:45 <byorgey> Ziphilt: great =)
09:36:04 <EvanCarroll> foldr1 (\x a -> (x++"=?,")++a ) (words "col1 col2 col3")
09:37:20 <aruns> byorgey: sorry was in another room. still getting used to this irssi. i'm trying to install snap-server basically
09:37:55 <aruns> snap-server requires mtl, and mtl is currently not building on my system, giving me an error saying Duplicate instance definition. i have marked those two places in the code pastie
09:38:15 <djahandarie> Probably because you're building on HEAD
09:39:03 <aruns> djahandarie: i am
09:39:32 <djahandarie> You could try pulling it from the darcs repo
09:39:44 <geheimdienst> aruns, could you paste the exact full error message? i still suspect it's one of those clashes between the mtl and monads-tf packages
09:41:35 <aruns> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29509#a29509
09:42:12 <aruns> btw just noticed when i was trying to build snap-core instead of just mtl, that there is some other spot that it is giving me a similar error at
09:44:43 <Jonno_FTW> @src nub
09:44:54 <aruns> geheimdienst: any ideas? i'm new to Haskell so that code really doesn't make sense to me. i see a lot more definitions which look similar. not sure how i can fix or even what to try
09:49:44 <geheimdienst> no idea, sorry. Control.Monad.Instances seems to belong to base while the clashing Control.Monad.Error is in mtl
09:50:02 <geheimdienst> no idea. maybe that version of mtl is incompatible with ghc-HEAD's base package
09:50:23 <aruns> can i try renaming something to fix the error ?
09:50:42 <aruns> or why is it failing on just those two? all 4 defitions seem pretty similar
09:54:11 <Saizan> aruns: you could try removing the instances from mtl
09:54:33 <aruns> remove references to Error ?
09:55:09 <Saizan> remove the whole instance.
09:55:54 <midorikid> \msg @ChanServ help
09:55:58 <midorikid> oops
09:56:25 <midorikid> Where's lambdabot? I need some sweet pl!
09:56:33 <Saizan> aruns: there's going to be "instance Error e => Monad (Either e) where { return = ...; (>>=) = ...}" in Control.Monad.Error's source, you want to comment the whole thing
09:56:46 <Saizan> aruns: same for "instance Error e => MonadFix (Either e)"
09:56:51 <geheimdienst> lambdabot has been drinking again and is passed out under the table
09:56:53 <aruns> ok going to try it
09:57:34 <Saizan> (except that MonadFix's instance will have a definition of mfix)
09:57:59 <aruns> i commented all 4 instances out, and now it compiled fine without any errors
09:58:12 <aruns> but won't something bomb out at some point when an error occurs ?
09:58:22 <Saizan> which are the other two?
09:59:01 <Saizan> you should have kept MonadPlus and MonadError
09:59:29 <aruns> instance (..) => MonadPlus and MonadError
09:59:51 <Saizan> you're likely to get errors later if you remove those two.
10:00:11 <aruns> so just remove the two duplicates that are giving me the error but keep the rest ?
10:00:15 <lolatu> how do I "cast" a word8 into a word32?
10:00:18 <Saizan> aruns: yeah
10:02:19 <Saizan> aruns: fyi, the instances in base don't agree entirely with the ones you are removing from mtl, so you might get weird runtime behaviour later in code that was relying on the specific aspects of mtl's ones
10:03:13 <Zao> lolatu: fromIntegral
10:03:21 <Zao> fromInteger (8 :: Word8) :: Word32
10:03:32 <lolatu> ah
10:03:43 <Zao> Err, fromIntegral in that paste, misaimed in my ghci
10:03:44 * copumpkin senses a slight discrepancy in Zao's two lines
10:03:53 * Zao blames the lack of lambdabot upsetting my delicate psyche.
10:03:55 <ezyang> Is it possible to use Cabals data-files support in conjunction with runghc? 
10:04:01 <DrSyzygy> > fromIntegral (8 :: Word8) :: Word32
10:04:17 <DrSyzygy> Damn. No lambdabot?!
10:04:27 <Zao> See, DrSyzygy is losing it too!
10:04:38 <lolatu> I need it for implementing sha1 in haskell
10:04:42 <geheimdienst> drsyzygy, she's been drinking again
10:05:01 <Zao> lolatu: Now, that will give you a Word32 from a single Word8.
10:05:15 <Zao> If you're asking how to get four Word8 into a single Word32, it's more fun.
10:05:45 <lolatu> yes, but is that not straightforward when I have converted one word8 into a word32?
10:05:58 <aruns> Saizan: thanks for your help, it seems to be compiling now. if it keeps failing i think i might just uninstall head and go back to the older version of ghc and use cabal
10:06:08 <lolatu> it is what I require it for(converting 4 word8 into a word32)
10:06:42 <Zao> lolatu: The simple solution is to use Data.Bits to shift and OR things into a number.
10:07:12 <lolatu> yes
10:07:17 <lolatu> I hope so
10:07:31 <mauke> Zao: or multiply and add
10:08:04 <Zao> Indeed.
10:10:48 <cncl> so apparently i can't use a library that uses monads-fd and parsec3 at the same time?
10:11:50 <tehgeekmeister> anyone know why the Databse.Sqlite.Enumerator module wouldn't get installed when takusen successfully installed?
10:13:12 <cncl> this really sucks, i didn't know parsec3 couldn't be used if you're using another library that uses monads-fd instead of mtl
10:14:13 <cncl> unless i am mistaken?
10:15:29 <tehgeekmeister> meh.  i'll just use hdbc.
10:15:46 <codolio> cncl: It depends on what you want to do with both of them.
10:16:31 <cncl> what am i allowed to do?
10:16:43 <codolio> What error are you receiving?
10:17:22 <cncl> i get a 'no instance for MonadTrans' on the ParsecT String () type if i have monads-fd exposed instead of mtl
10:17:38 <codolio> Okay, right.
10:17:39 <cncl> if i use flexibleinstances to add an instance for it, then when i actually run my application, it crashes with <<loop>>
10:17:51 <codolio> That's because ParsecT is declared a MonadTrans from the mtl package.
10:18:08 <codolio> But the MonadTrans you're attempting to use is from the monads-fd package.
10:18:23 <cncl> ok
10:18:27 <codolio> They're different classes, essentially.
10:19:22 <cncl> is there a way to fix this
10:19:33 <codolio> There's a way you can add package names to imports. I forget the exact name of the extension.
10:19:59 <codolio> But you could probably write 'import qualified "mtl" Control.Monad.Trans as MTLTrans'.
10:20:38 <dstcruz> is there a way of seeing what modules are loaded into ghci?
10:21:02 <tmug> hi, can anyone point me to source of information on how pattern matching works under the hood in haskell / ghc ?
10:21:04 <aruns> :show modules
10:21:15 <dstcruz> aruns: thanks!
10:21:26 <codolio> Declaring an instance MTLTrans.MonadTrans t => MonadTrans t may not be advisable, though, because that will overlap with stuff.
10:21:29 <aruns> dstcruz: np
10:21:37 <codolio> But you could do it.
10:22:13 <aristid> monads-fd is evil.
10:22:16 <dstcruz> hmmm... :show modules seems to ignore the modules loaded with :m +Module
10:22:37 <afarmer-lab> anyone here built ghc head lately?
10:24:19 <cncl> codolio: it's PackageImports i'm looking for, right
10:24:23 <cncl> the extension
10:24:27 <codolio> Sounds right.
10:24:50 <ezyang> "Man, I wish GHC could infer my rank-2 types for me" 
10:25:11 <c_wraith> I wish that too.
10:25:32 <Saizan> i wish ghc could accept partial signatures so i can fill in only the non-inferrable bits
10:25:32 <c_wraith> I also wish for a pile of gold and a pony.
10:26:00 <c_wraith> ah, yes.  partial signatures would be awesome.  Though I can't figure out a syntax that would make it sensical.
10:26:08 <aruns> dstcruz: hmm you are right. never noticed that. not sure how you can get those modules loaded with :m
10:26:09 <copumpkin> _ in the type?
10:26:13 <ezyang> You can always use the oleg trick. 
10:26:31 <c_wraith> ezyang, unify it with something only as specified as necessary?
10:26:43 <c_wraith> copumpkin, hmm, yes, that'd work.
10:26:56 <cncl> codolio: this is the first time i've had this problem. i am starting to get the impression that parsec3 isn't liked by a lot of people
10:27:00 <Saizan> i think oleg trick only works when the overall type is inferrable
10:27:38 <codolio> cncl: I don't know what would be different with parsec 2. It also uses mtl.
10:27:57 <ezyang> Saizan: Ah, fair enough. 
10:28:16 <Saizan> it's just an educated guess though
10:28:19 <geheimdienst> cncl, it seems that every few days there's somebody in here reporting clashes between mtl and monads-tf or monads-fd. so this is clearly a major snafu. i've had the problem myself, some stuff mysteriously stopped building after an innocent update
10:28:30 <cncl> ah
10:28:38 <cncl> what a pain :(
10:28:51 <geheimdienst> i eventually just hid monads-tf. but if you explicitly need it ...
10:29:02 <geheimdienst> (or -fd for that matter)
10:29:24 <cncl> fclabels needs monads-fd
10:29:40 <cncl> at least as far as i can tell
10:29:51 <cncl> i'm not too familiar with all of the packaging stuff
10:30:41 <geheimdienst> no, you seem to be right. fclabels depends on monads-fd >= 0.0 && < 0.2
10:31:54 <cncl> so there are at least two libraries in common use that provide the similar functionality with the same names but in an incompatible way
10:32:03 <cncl> :[
10:32:47 <geheimdienst> they are trying to provide replacements for the mtl package iirc, but it's not ready yet. or the other way around
10:32:53 * geheimdienst no lykes dis
10:38:01 <sproingie> so what is the recommended replacement for mtl these days?  -fd or -tf?
10:38:38 <geheimdienst> ghc-pkg hide monads-fd && ghc-pkg hide monads-tf && pray
10:39:03 * ezyang still uses mtl... 
10:39:08 <aristid> sproingie: also consider MonadLib ;)
10:39:24 <cncl> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29504
10:39:31 <cncl> i was going to put on hpaste my error
10:39:31 <sproingie> ayy yi yi
10:39:33 <cncl> then i saw this at the time
10:39:36 <cncl> er at the top
10:39:44 <sproingie> so no clear winner i take it
10:39:49 <cncl> which seems to be the problem i am having sort of
10:39:57 <djahandarie> I still use mtl also
10:40:21 <cncl> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29516#a29516
10:40:36 <cncl> help :(
10:41:35 <ManateeLazyCat> \x01
10:41:40 <ManateeLazyCat> > \x01
10:42:24 <copumpkin> Cale: any chance of getting lambdabot back?
10:43:08 <cncl> i actually have to get this software working in the next few hours or i'm in trouble, it works other than this problem, which is the only thing holding me back
10:44:19 <Jafet> Parse error (possibly incorrect indentation). Unknown stty mode: doofus
10:44:59 <cncl> codolio: i don't understand how i'm supposed to declare that instance
10:46:24 <codolio> cncl: If you import the two modules under different qualified names, you should be able to refer to both classes explicitly.
10:46:37 <codolio> At least, I would expect you to be able to do so.
10:47:22 <cncl> i'm not importing MonadTrans explicitly anywhere
10:48:45 <ManateeLazyCat> I remember some function will split string with specify character, what's the function name? 
10:48:59 <zygoloid> Data.List.Split.splitOn ?
10:49:55 <zygoloid> Data.List.Split.splitWhen (==c)
10:49:58 <zygoloid> @hackage split
10:50:12 <zygoloid> ;(
10:50:14 <zygoloid> http://hackage.haskell.org/packages/archive/split/0.1.2/doc/html/Data-List-Split.html
10:50:23 <por> splitAt
10:51:13 <aruns> just discovered there is no cabal uninstall and ghc-HEAD Makefile doesn't have an uninstall target either. anyone know whats the best way of uninstalling/removing ghc-head and reverting to my old copy?
10:52:27 <fxr> aruns: darcs revert?
10:52:56 <cncl> codolio: do you know you can? i always though you couldn't put typeclasses into qualified namespaces
10:53:58 <aruns> fxr: i installed ghc-HEAD directly. before that i had ghc 6.12.1 installed from ubuntu repositories
10:54:44 <ManateeLazyCat> zygoloid: Thanks, i found words can split null character '\0'
10:54:45 <aruns> i'd just like to remove GHC head and then reinstall ghc using apt
10:54:51 <zygoloid> wow, the split package makes impressively unnecessary use of language extensions
10:55:11 <zygoloid> ManateeLazyCat: are you replacing '\0' by ' ' first? :)
10:55:13 <ezyang> \o/ 
10:55:33 <codolio> cncl: Yes, I just tried it.
10:55:34 <ManateeLazyCat> zygoloid: I'm reading /proc/pid/cmdline, it's string split by '\0'
10:55:37 <codolio> It works.
10:55:39 <zygoloid> ezyang: cause for celebration? :)
10:55:46 <zygoloid> ManateeLazyCat: sure, but words splits on ' '
10:55:51 <ManateeLazyCat> zygoloid: I found words can split those.
10:56:01 <fxr> aruns: remove the ghc-head from your filesystem and fix your PATH to include ghc 6.12. I guess it is enough for your case.
10:56:22 <zygoloid> > words "foo\0bar\0baz"
10:56:26 <zygoloid> ["foo\NULbar\NULbaz"]
10:56:34 <codolio> cncl: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29517#a29517
10:56:48 <aruns> fxr: ok thanks
10:57:04 <ManateeLazyCat> zygoloid: I print result for test.
10:58:13 <sproingie> oh cool, making unary - bind tightly is on the roadmap for Haskell2011
10:58:23 <ManateeLazyCat> zygoloid: Hmm, looks i need splitOn you paste.
10:59:15 <zygoloid> > let swap ' ' = '\0'; swap '\0' = ' '; swap a = a in (map.map) swap . words . map swap $ "foo\0bar\0baz"
10:59:18 <zygoloid> ["foo","bar","baz"]
10:59:25 <cncl> codolio: thanks trying it now
10:59:37 <zygoloid> ManateeLazyCat: ^^ a bit ugly but i've used that before
11:01:29 <ManateeLazyCat> > let splitNull list = words $ map (\x -> if x == '\0' then ' ' else x) list
11:01:51 <ManateeLazyCat> > splitNull "andy\0test\0haha"
11:01:57 <cncl> codolio: i now get this error http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29516#a29516
11:02:36 <codolio> Yes. That instance will overlap with everything.
11:02:40 <ManateeLazyCat> zygoloid: splitNull works. :)
11:02:51 <codolio> You'll have to enable overlapping instances if you want to use it.
11:03:10 <cncl> oh ok
11:04:00 <zygoloid> ManateeLazyCat: that'll split "ls\0/mnt/windows/Program Files" incorrectly into ["ls","/mnt/windows/Program","Files"]
11:04:24 <cncl> codolio: i enabled overlappinginstances but i'm still getting that error
11:05:22 <codolio> Oh, okay. I glanced at the error too quickly.
11:05:26 <codolio> That will be a problem, yes.
11:05:32 <ManateeLazyCat> zygoloid: Ah.
11:06:12 <codolio> Both transformers and mtl declare Monad instances for Either, which is a problem.
11:06:50 <codolio> And there's no way to make them not conflict if you try to use modules that include them.
11:07:19 <siracusa> ManateeLazyCat: Hi! Do you know if one of the gtk2hs build tools can be used to get a list of all setter/getter functions of all superclasses for a special widget that can be called on that widget?
11:07:39 <cncl> codolio: so.. i can't do anything about it?
11:07:52 <codolio> The only thing you can do is not use the Either instance of Monad.
11:08:01 <codolio> But I'm not sure that's an option.
11:08:19 <cncl> not without rewriting 500 lines of code in the next two hours
11:08:28 <ManateeLazyCat> siracusa: Haddock can't show those?  
11:08:55 <burp> how about hiding mtl or transformers?
11:09:05 <ManateeLazyCat> siracusa: I think gtk2hs-buildtools haven't that tools got those setter/getter functions.
11:09:14 <siracusa> ManateeLazyCat: It can, but it's a bit difficualt to find all of them.
11:09:39 <BONUS> thinkin about starting a blog. what do y'all think: comments or no comments?
11:09:57 <mauke> strongly moderated comments
11:09:58 <ManateeLazyCat> siracusa: Oh, Infact that scan Attr functon.
11:09:58 <cncl> burp: if i hide mtl then parsec3 says there is no instance of MonadTrans for ParsecT String ()
11:10:13 <cncl> if i declare an instance using overlapping instances then it will crash with <<loop>> when i try to run the program
11:10:18 <BONUS> because reddit already provides a good service for comments imo
11:10:24 <ManateeLazyCat> siracusa: Example, you need scan Attr or ReadWriteAttr in .chs files.
11:10:29 <cncl> and the stack shows that it is an infinite loop somewhere in parsec3
11:10:34 <BMeph> BONUS: Dynamically moderated comments! ;)
11:11:17 <BONUS> haha
11:11:35 <ManateeLazyCat> siracusa: Why do you need that feature?
11:14:13 <siracusa> ManateeLazyCat: Because it's sometime difficult to find the correct haddock file if you want to set a special attribute. Image a text entry, if you want to set the text you have to look in Entry.hs, but the size request can be set for all widgets, so you have to look in Widget.hs. So it would be nice to see all functions for a special widget. :-)
11:14:36 <siracusa> *Imagine
11:15:09 <ManateeLazyCat> siracusa: Ah, i just read those in haddock.
11:15:11 <ManateeLazyCat> siracusa: I see.
11:16:10 <ManateeLazyCat> siracusa: You want some tools scan .chs file, then output all attribute for specify widget include SuperClass's attribute.
11:16:11 <siracusa> ManateeLazyCat: It's like typing "object." in a Java or C# IDE and get a list of all available methods.
11:16:28 <ezyang> I'm segfaulting on a module that, as far as I can tell, shouldn't be used at all by my program. Is there a way to figure out when that module is being entered? 
11:16:37 <ManateeLazyCat> siracusa: Do you develop "code completion" tools for gtk2hs code? 
11:16:41 <ManateeLazyCat> :)
11:18:00 <siracusa> ManateeLazyCat: I'm not doing it yet, but I'm trying to figure out how difficult this would be :-)
11:18:35 <copumpkin> Runar: so I will be seeing you :)
11:18:37 <ManateeLazyCat> siracusa: My answer is possible, you need ask Axel for those detail.
11:18:50 <kniu> so I imported the Data.ByteString.Char8 module, but how do I convert Data.ByteString.Internal.Lazy.ByteStrings to Char8 bytestrings?
11:18:54 <Runar> copumpkin: Yeah, so late Sept?
11:18:58 <ManateeLazyCat> siracusa: I think need scan .chs files then build some database for search.
11:19:00 <copumpkin> yep!
11:19:03 <Runar> nice.
11:19:03 <nschoe> Hi all!Can anyone tell me if there is a way to delete a signal?
11:19:11 <nschoe> in gtk2hs*
11:20:17 <nschoe> There are 'signalStopEmission' and 'signalDisconnect', but I don't know how to use them, and can't find them in the docs :/
11:20:19 <ManateeLazyCat> siracusa: Since Haskell not like Java support Class so much, but i think it's so hard.
11:20:39 <copumpkin> Runar: can't wait :)
11:21:03 * hackagebot hpage 0.12.1 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.12.1 (FernandoBenavides)
11:21:38 <ManateeLazyCat> nschoe: You need signalDisconnect
11:21:59 <ManateeLazyCat> nschoe: delete a signal?
11:22:08 <ManateeLazyCat> nschoe: You need signalStopEmission
11:23:22 <ManateeLazyCat> nschoe: "signalStopEmission (castToGObject yourWidget) signalName"
11:23:22 <nschoe> ManateeLazyCat: hi, thanks for your answer. Can you tell me the diffence between these two please?
11:23:55 <ManateeLazyCat> nschoe: signalDisconnect just disconnect some handler of current signal.
11:24:10 <ManateeLazyCat> nschoe: Example, you can add many different handler for same signal.
11:24:34 <ManateeLazyCat> nschoe: So signalDisconnect is disconnect specify handler for signal.
11:24:40 <nschoe> ManateeLazyCat: Yes, that is exactyl what I want to do, but when I click the button (here it is my event), all my handlers execute, which I don't want.
11:24:53 <ManateeLazyCat> nschoe: signalStopEmission is stop a signal's current emission.                                                                                          
11:25:19 <ManateeLazyCat> nschoe: signalStopEmission (castToGObject yourWidget) signalName
11:25:34 <nschoe> ManateeLazyCat: the first parameter of signalDisconnect, it should be -for instance- the return value of 'onClicked', right?
11:26:07 <ManateeLazyCat> nschoe: Which your want? Stop signal emission or stop some handler of signal?
11:26:50 <nschoe> ManateeLazyCat: stop handler of signal
11:27:29 <ManateeLazyCat> nschoe: If you want stop specify handler such as `onCliked', you need same return of `onClicked' signal, then pass connectId to signalDisconnect
11:27:57 <ManateeLazyCat> s/same/save
11:28:13 <ManateeLazyCat> nschoe: Save connectId of signal return, then pass to signalDisconnect when you want to stop that handler.
11:28:55 <ManateeLazyCat> nschoe: Variant handler for same signal will return unique id for connect.
11:29:12 <nschoe> ManateeLazyCat: Okay, thanks a lot. I'll try that right now.
11:30:10 <siracusa> ManateeLazyCat: Parsing the .chs files will be a bit of too much work I think, I just found haddock can create hoogle database files, maybe they can be hijacked for this ...
11:30:13 <ManateeLazyCat> nschoe: I suggest you ask gtk2hs problem at gtk2hs-list, most gtk2hs developers not here.... :)
11:31:22 <ManateeLazyCat> siracusa: Well, you need ask Axel, he wrote gtk2hs-buildtools.
11:31:31 <nschoe> ManateeLazyCat: yeah, sorry.
11:31:57 <ManateeLazyCat> nschoe: You don't need sorry, just suggestion. :)
11:32:06 * hackagebot netstring-enumerator 0.1 - Enumerator-based netstring parsing  http://hackage.haskell.org/package/netstring-enumerator-0.1 (JohnMillikin)
11:32:24 <Maxdamantus> "In fact, such a merge sort is in the standard prelude as the default sort algorithm." .. is that true? I don't see any sorting functions on http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html
11:32:28 <cncl> i guess i'll ask again in case someone else is around now who can help.. i'm completely and utterly screwed if i can't get this working. i'm using parsec3 and fclabels. parsec3 uses mtl, fclabels uses monads-fd. is there no way to use these two libraries at the same time? i am trying to get the two parts of my program working together
11:32:48 <ManateeLazyCat> siracusa: Now, gtk2hs's tools not smart enough ....
11:33:30 <cncl> i tried using PackageImports earlier, and an orphan instance of MonadTrans, which didn't work, because of overlapping instances for Monad on Either
11:33:44 <Maxdamantus> Oh, Data.List
11:34:24 <vanadium> Can you -ignore-package mtl or monads-fd in the parts of your program that are not using them/
11:34:27 <cncl> the error i get if i hide mtl and just expose monads-fd is one about ParsecT not having a MonadTrans instance. if i fix this by hand (by declaring an instance) it will crash with <<loop>> when i try to run the program
11:34:30 <vanadium> not sure how this works
11:34:45 <cncl> vanadium: sadly, Main needs to use both
11:35:01 <djahandarie> Maxdamantus, that sentence is incorrect, it's only in the standard library not in the prelude specifically
11:35:03 <cncl> otherwise i could just use PackageImports on the individual parts that only need one or the other
11:35:35 <Maxdamantus> Indeed. Misinformational websites. :\
11:39:04 <djahandarie> cncl, there is also lenses
11:39:08 <nschoe> ManateeLazyCat: (Sorry to bother again, :-), but do you know a way to get a list of signals attached to a widget?)
11:39:13 <djahandarie> And sec
11:39:23 <djahandarie> And records
11:39:30 <djahandarie> (All different packages on hackage)
11:39:44 <cncl> do they do the same stuff as fclabels?
11:40:07 <cncl> which one is the most commonly used?
11:40:24 <djahandarie> Not the same mechanics but they solve the same problem
11:40:29 <cncl> i don't have much time left to rewrite stuff, so if i'm going to rewrite code, i need to be pretty sure it'll work
11:40:38 <ManateeLazyCat> nschoe: I think you can do "cabal haddock" before use "cabal install" install gtk package, then you can find haddock at gtk/dist/doc/html/index.html
11:40:53 <cncl> like if i get to the point where i am building the application, and it fails with some library thing like this, i'm in real trouble
11:40:57 <cncl> i only have a few hours left
11:41:01 <ManateeLazyCat> Then you can use browser browse index.html
11:41:23 <djahandarie> cncl, you can always just ditch fclabels and do it the hard way
11:41:24 <ManateeLazyCat> nschoe: Search "Graphics.UI.Gtk.Abstract.Widget", you will find all signals of Widget.
11:41:32 <ManateeLazyCat> nschoe: Other widget is similar...
11:41:59 <nschoe> Ok.
11:42:13 <cncl> djahandarie: i had been for a while, but there is a ton of record updating stuff i needed to do in a few modules
11:42:35 <nschoe> ManateeLazyCat: But I have already gtk installed, will it work anyway?
11:43:19 <ManateeLazyCat> nschoe: You can reinstall gtk again with "cabal haddock", everything will be fine.
11:43:32 <nschoe> ManateeLazyCat:  ok. Thanks
11:43:38 <ManateeLazyCat> nschoe: NP :)
11:43:55 <nschoe> Ths for your help, gotta go, I'll try that ^^
12:06:54 <JoeyA> Is there a more Haskellian way to name this?  http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29524#a29524
12:07:18 <JoeyA> In particular, I'm defining a file tree definition with parent links and a custom field.
12:07:26 <JoeyA> AbstractFileTree just sounds awful to me.
12:07:49 <EvanR-work> AbstractGeneralizedFactoryObserverProxy
12:07:56 <JoeyA> lol
12:08:09 <JoeyA> Perhaps AnyFileTree would be more elegant
12:08:21 <EvanR-work> FileTree?
12:08:39 <JoeyA> Well, then I'd have to litter my basic file tree generation code with ()s
12:08:57 <EvanR-work> also, what makes it file specific
12:09:23 <JoeyA> It's not file-specific, it's application-specific.
12:09:45 <EvanR-work> so its just a kind of Tree
12:09:47 <JoeyA> Some places want to compute SHA1 hashes of files, some want to label files with unique IDs, etc.
12:09:53 <monochrom> a tree in which nodes care about parents that much. perhaps ChineseTree.
12:10:09 <JoeyA> lol
12:10:26 <JoeyA> Indeed, Data.Tree doesn't have parent links.
12:10:50 <EvanR-work> UndirectedTree
12:10:51 <JoeyA> However, in the case of FileTree, they make sense (so you can compute a file path, for instance)
12:11:02 <purplerain> hello
12:11:05 <JoeyA> Hello
12:11:20 <purplerain> anyone familiar with the Snap Framework?
12:12:05 <c_wraith> purplerain, plenty of people
12:12:06 <aruns> purplerain: if by familiar you mean installed it about 7 mins ago, and watched the first 'hello world' page, then yes kinda :)
12:12:10 <aristid> purplerain: there's #snapframework, too
12:12:15 <chrisdone> good mornin' midnight!
12:12:15 <c_wraith> but check out #snapframework
12:12:17 <aristid> aruns: that counts
12:12:19 <c_wraith> Several of us in there
12:12:32 <purplerain> haha, understood
12:12:33 <cncl> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29527#a29527 what is going on here?
12:12:38 <purplerain> just looking for a sample app to work from 
12:12:45 <purplerain> bestof practices, etc
12:12:47 <c_wraith> Did you look at their site app?
12:12:51 <aruns> the snap website itself 
12:12:53 <cncl> i was going to replace fclabel with lenses but it doesn't even look like it installs
12:13:01 <purplerain> they have the code available?
12:13:06 <purplerain> I didnt see any links
12:13:11 <c_wraith> http://github.com/snapframework/snap-website
12:13:20 <monochrom> hidden package 'base'?! something else was wrong to begin with.
12:13:23 <c_wraith> linked to from the bottom of the downloads page
12:13:32 <purplerain> awesome!
12:13:32 <aruns> its at the bottom of the download page, c_wraith s got the link
12:13:41 <purplerain> wow, was at work when I checked
12:13:48 <purplerain> guess I zoned out on that 
12:13:56 <monochrom> ah packedstring may be bitrot
12:14:03 <purplerain> many thanks!
12:14:58 <cncl> monochrom: what does that mean?
12:15:01 <purplerain> bye for now!
12:15:06 <aruns> np, bye
12:18:59 <monochrom> shallow explanation: when building packedstring, cabal selects base 3, but Data.Data is in base 4. "hidden base" means "hidden base 4".
12:19:34 <monochrom> deep explanation: lenses is out of date, being dependent on old template-haskell.
12:19:55 <EvanR-work> all your hidden base, are belong to us
12:20:20 * hackagebot simpleirc 0.1.0 - Simple IRC Library  http://hackage.haskell.org/package/simpleirc-0.1.0 (DominikPicheta)
12:20:46 <djahandarie> monochrom, wasn't that backwards?
12:21:05 <cncl> well, i need to replace fclabels in my code, because it doesn't work with parsec3
12:21:15 <cncl> is there some records library i should use?
12:21:35 <monochrom> it is forward. it is shallow to say "hmm ok I should fix packedstring". it is deep to say "hmm ok I should fix lenses".
12:22:24 <copumpkin> does the opposite category of Set have a (common) name?
12:22:55 <monochrom> (I only know "coset" is taken :) )
12:23:48 <Saizan> copumpkin: btw, we should totally have ^op = opposite
12:24:30 <copumpkin> Saizan: I was thinking of that, but \^o doesn't give you a superscript :(
12:24:37 <monochrom> we should lobby for the next version of unicode to include the ^op symbol just like they already have ^2
12:25:07 <monochrom> x^\mathit{op} or x^\mathrm{op}
12:25:14 * mtnviewmark glances at the operators of Perl 6
12:25:43 <monochrom> there is a whole periodic table for them
12:26:05 <mtnviewmark> http://www.ozonehouse.com/mark/periodic/   --- I drew it!
12:27:44 <luite> wow are those really all built-in things?
12:28:00 <mtnviewmark> yes! and notice the meta-operators!
12:28:27 <copumpkin> mtnviewmark: wow, very nice
12:28:32 <djahandarie> copumpkin, there is a name for the opposite category for finite sets
12:28:32 <mtnviewmark> thank you
12:28:42 <monochrom> I live in an interesting time.
12:29:11 <djahandarie> (It is the category of finite boolean algebras)
12:29:51 <DrSyzygy> Are those >> or  in the rightmost meta-ops?
12:30:00 <aristid> monochrom: but only you?
12:30:02 <monochrom> I mention a famous work to someone, and that someone turns out to be the author of the mentioned work.
12:30:17 <monochrom> But I guess you live in an interesting time too.
12:30:20 <chrisdone> could lenses be generated with Data.Data and Typeable?
12:30:52 <monochrom> One day someone will tell me "hey monochrom have you seen http://www.vex.net/~trebla/haskell/fix.xhtml it's really cool!"
12:31:10 <cncl> should i use sec or data-accessor?
12:31:52 <mtnviewmark> DrSyzygy: both work, but I think  are considered cononical
12:32:05 <luite> very nice drawing indeed... but I don't yet understand how those hyper and other (red stripe?) ops work
12:32:28 <mtnviewmark> you can replace the 'op' with (almost) any other operator
12:32:47 <mtnviewmark> so    [+] is like foldl' (+)
12:33:07 <luite> and the >>op>> ones?
12:33:07 <mtnviewmark> and  R/   is like    flip (/)
12:33:37 <mtnviewmark>      +    is    flip map
12:33:52 <mtnviewmark> er    \x -> map (+x)
12:34:26 <mtnviewmark> so, the rule for those    angles pointing into the operator mean   "this side is a scalar"   
12:34:39 <luite> ah I see
12:34:40 <mtnviewmark> absence of angles means "this side is a collection"
12:35:05 <luite> hmm, I'm not sure if this makes me want to learn perl 6 more ;)
12:35:08 <mtnviewmark> and  (oh boy)    angles point out of the operator mean "this side might be a scalar or a collection... do the right thing"
12:35:29 <mtnviewmark> which of course, is the kind of thing that drives us Haskellers crazy
12:36:04 <mtnviewmark> i'm only the illustrator ..... so don't shoot the artist!
12:36:35 <mtnviewmark> though, I admit, I'm responible for the terms ":iffy"  ":diffy" and ":fiddly" which characterize meta operators
12:36:56 <mtnviewmark> or rather, characterize how operators can be combined with meta operators
12:37:39 <monochrom> It should not drive haskellers crazy. Perl static type system has just "scalar" and "collection". And then a built-in typeclass with both as instances. So some operators expect only scalars, some expect only collections, and some expect both.
12:37:43 <luite> I don't think my mind is great enough to handle the full power of perl 6 :p
12:38:10 <mauke> monochrom: is that perl5 or perl6?
12:38:20 <monochrom> perhaps both.
12:39:34 <monochrom> It should not drive you crazy. It should drive you laughing. It's so hilariously coarse and restricting.
13:14:34 <orium> hi, where can i find the neper number in the haskell standard library?
13:15:08 <opqdonut> > exp 1
13:15:20 <medfly> :)
13:15:28 <c_wraith> @botsnack
13:15:35 <c_wraith> nooo...  bots are dead... :(
13:15:41 <medfly> together with their owners
13:15:56 <nlogax> mtnviewmark: hey!
13:15:57 <orium> thank you opqdonut ;)
13:16:07 <preflex> I'm right here!
13:16:11 <c_wraith> mmorrow could quite possibly be dead.  That would be really unfortunate.
13:16:25 <mtnviewmark> hiho nlogax
13:16:33 <c_wraith> preflex, I'll count you when you respond to @botsnack. :)
13:16:35 <hatds> with -O0 my program runs in constant space, but with -O2 it appears to use linear space ...is this a bug?
13:16:51 <mauke> preflex: botsnack
13:16:51 <preflex>  
13:17:13 <opqdonut> hatds: the optimizer isn't all-knowing
13:17:23 <opqdonut> but that certainly sounds weird
13:17:24 <nlogax> mtnviewmark: maybe it's too late, but i just saw http://www.ozonehouse.com/mark/snap-xhtml/doc-index.html and thought: wouldn't it be nice if the footer was at the bottom, until the content reaches it and starts pushing it down?
13:17:29 <opqdonut> is your program big?
13:17:33 <hatds> no
13:17:42 <nlogax> mtnviewmark: i'd be happy to do it if possible
13:17:50 <mtnviewmark> can you do that in CSS?
13:17:52 <hatds> I've reproduced the behavior with a 17 line program
13:18:35 <nlogax> mtnviewmark: yes. but it's kind of weird, would require some small changes to the markup
13:19:24 <arw> hatds: is the -O0 so slow, that the GC is fast enough to keep up perhaps?
13:19:42 <arw> (just a very wild and stupid guess)
13:19:42 <mtnviewmark> can you send me a pointer to the basic technique?
13:19:48 <tolkad> can there be a newtype with multiple constructors?
13:19:51 <mtnviewmark> I can still get it in before we release
13:19:54 <hpc> tolkad: no
13:20:08 * mtnviewmark <-- phone call
13:20:09 <tolkad> http://www.haskell.org/onlinereport/decls.html#sect4.2.3
13:20:09 <tolkad> "Also, unlike type synonyms, newtype may be used to define recursive types"
13:20:12 <tolkad> how is that useful
13:20:18 <tolkad> newtype T = A T
13:20:20 <c_wraith> @src Mu
13:20:23 <tolkad> oh that's great let me go use that
13:20:27 <tolkad> oh WAIT
13:20:30 <mauke> tolkad: that's actually useful
13:20:32 <hatds> both versions are fast in the small example, I think even the -O0 is quicker.  Heap profiling says the -O2 version uses 20 MB heap, all 'in use' until the very end
13:20:33 <c_wraith> oh, right.  No lambdabot
13:20:37 <mauke> tolkad: that's a type with no values
13:20:47 <nlogax> mtnviewmark: this looks like what i've been doing: http://www.cssstickyfooter.com/
13:20:48 <hpc> tolkad: all it says is that newtype can do recursion the same way data can
13:21:00 <nlogax> mtnviewmark: resize the window and see
13:21:01 <tolkad> hpc: what's the point?
13:21:05 <copumpkin> tolkad: you can define most types you're used to with recursive types
13:21:09 <hpc> an overhead-free infinite list
13:21:15 <mtnviewmark> my gosh - there is a domain name for everything!
13:21:23 <tolkad> hpc: no, it can only have one constructor
13:21:27 <sproingie> www.thereisadomainnameforeverything.com
13:21:28 <mauke> tolkad: so?
13:21:31 <hpc> yeah
13:21:32 <nlogax> mtnviewmark: the drawback is that the footer must be a fixed height, but the height can be in any unit, of course
13:21:35 <hpc> one cons
13:21:36 <tolkad> hpc: so the recursive type is guaranteed to be impossible to instantiate
13:21:39 <hpc> no empty list constructor
13:21:40 <mauke> tolkad: wrong
13:21:54 <tolkad> ok, create an instance of "newtype T = A T"
13:22:01 <mauke> tolkad: impossible
13:22:01 <nlogax> mtnviewmark: and the current footer looks like it would work with that restriction :)
13:22:09 <hpc> let's modify list
13:22:16 <hpc> [a] = a:[a]
13:22:17 <tolkad> oh wait! I understand mauke 
13:22:18 <logch_l> Q: My list only prints two Integers. countdown n = [ fibMax n, n-fibMax n .. 0 ]  I know it holds more..? It's Integer -> [Integer]
13:22:22 <mauke> tolkad: newtype L = CL [L]
13:22:23 <tolkad> you do this:
13:22:27 <hpc> you can't end the list, but you can make an infinite one
13:22:35 <tolkad> A (unsafeCoerce [])
13:22:40 <tolkad> great
13:22:42 <tolkad> thanks
13:22:43 <mauke> tolkad: wtf?
13:22:57 <mauke> just use undefined :: T
13:23:02 <mauke> or fix A, which is the same thing
13:23:29 <tolkad> mauke: that's cheaating, you referenced a data type
13:23:32 <tolkad> cheating*
13:23:38 <mauke> that's what newtype is for
13:23:39 <tolkad> it's really the list which is recursive
13:23:45 <mauke> no
13:23:55 <mauke> newtype M = CM (Maybe M)
13:24:08 <tolkad> meh, I guess so
13:24:10 <hatds> I think the -O2 version is recomputing something it shouldn't... looking and the profile report it is doing 2^22 evaluations of an expression during a 22 iteration loop
13:24:26 <tolkad> I think I'll use this though
13:24:38 <c_wraith> hatds, submit a bug report for ghc
13:24:53 <c_wraith> They're very interested in cases where the optimizer screws up
13:25:21 <tolkad> newtype List = ListC List; emptyList = unsafeCoerce [] :: List
13:25:21 <aristid> is there anything to keep in mind when doing mutually recursive module dependencies
13:25:26 <tolkad> that should work just fine
13:25:51 <c_wraith> aristid: they don't really work in GHC
13:25:52 <tolkad> then I can do for example: 1 `ListC` 2 `ListC` 3 `ListC` 4 `ListC` 5 `ListC` emptyList
13:25:59 <c_wraith> There's a hacky mechanism to get around it.
13:26:00 <tolkad> works great
13:26:07 <aristid> c_wraith: not at all?
13:26:09 <c_wraith> But for the most part, mutually recursive modules just don't work
13:26:32 <por> don't you want fibMax (n - i), not (n - fibMax i), assuming fibMax calculates some (big!) Fibonacci number?
13:27:08 <aristid> c_wraith: "for the most part?" maybe what i want is in the other part?
13:27:36 <c_wraith> arisitid: There's a way to do it.  Somewhere in the ghc manual.  But it's ugly, and you'll probably decide to refactor your code instead of using it.
13:28:10 <aristid> c_wraith: well i could put everything in one module, but i hate it when modules become very long
13:28:48 <aristid> i have a module, which when completed, would probably go to around 800 lines or so, which is more than i want to stomach. and the natural way to split it would involve mutually dependent modules
13:29:28 <logch_l> por: the fibMax returns the largest fib nearest to the value given
13:29:59 <c_wraith> You generally end up refactoring things into layers: a module contain the types, and operations that depend on the constructors for the types.  Then a module that contains things that depend on the combinators for the types, but not the constructors.  etc
13:30:58 <aristid> c_wraith: so essentially i will have to put all these GADTs into the same module?
13:31:00 <logch_l> por: the list should continue until the sum of the list equals the given n value
13:31:30 <c_wraith> aristid: or look at the mechanism in GHC, and decide you can live with it.  It involves some pragmas.  That's all I remember
13:31:50 <nlogax> my_class=type('Foo',(object,),{})
13:31:55 <nlogax> whoops
13:32:30 * mtnviewmark <-- back
13:34:47 <tolkad> can someone explain why I'm getting this error with my code? http://codepad.org/7cpt7Lhf
13:34:50 <por> Maybe I'm dense, in which case I'll shut up, but won't e.g., fibMax 12 = [fibMax 12, (12 - fibMax 12)..0], i.e., fibMax 12 = [13, (12 - 13)..0]?
13:35:14 <djahandarie> It's really just strange how many Haskellers there are on /prog/
13:35:33 <c_wraith> tolkad: because ListC only takes one argument, and you're giving it two.
13:36:56 <tolkad> oh... yeah
13:37:14 <tolkad> uh how should I do this... hmm
13:37:15 <tolkad> I know
13:38:14 <logch_l> por: fibMax returns just one Integer. e.g. fibMax 12 would result in 8 ( since 13 is too big )
13:38:45 <monochrom> define: mycons x (ListC xs) = ListC (x:xs)
13:39:09 <monochrom> use it like (1 `mycons` (2 `mycons ...
13:39:32 <logch_l> por: that func works, countdown n = [ fibMax n, n - fibMax n .. 0 ] also sums up to the given value but the list seems only two items long?
13:39:32 <tolkad> http://codepad.org/75qXoXMr
13:39:43 <tolkad> now what's wrong... "Illegal type "(a,List)" in constructor application"
13:39:53 <tolkad> that should work!
13:40:00 <tolkad> oh I need List a
13:40:43 <tolkad> WTF?!? http://codepad.org/XJUQ13Lc
13:40:58 <tolkad> what happened 0_o
13:41:15 <tolkad> that should have worked!
13:41:16 <monochrom> using unlimited coercion is bizarre anyway
13:41:56 <tolkad> can someone explain why that didn't work? haskell bug?
13:42:00 <c_wraith> tolkad: you wrote code using unsafe* without understanding what you're doing.
13:42:01 <mauke> so I've looked at my logs
13:42:07 <mauke> any reason I shouldn't ban tolkad right now?
13:42:10 <copumpkin> tolkad: nothing using unsafe* is a haskell bug :P
13:42:15 <copumpkin> it's a programmer bug, if it doesn't work
13:42:21 <logch_l> por: http://codepad.org/MdV1ZCeB
13:43:13 <monochrom> mauke: I am not sure if there is any reason to ban, apart from stupidity.
13:43:26 <mauke> monochrom: deliberate stupidity, a.k.a. trolling
13:43:34 <tolkad> mauke: I'm not being stupid
13:43:42 <tolkad> mauke: but I'll stop talking about it if you don't want me to
13:44:16 <copumpkin> tolkad: why are you so obsessed with unsafePerformIO? do you bug ##c all the time because your programs crash because you put bad inline assembly in them?
13:44:41 <copumpkin> tolkad: it honestly just looks like trolling, but I'm curious why you're so fascinated by it
13:45:12 <tolkad> copumpkin: It let's you do cool stuff without breaking the haskell standard rules
13:45:16 <por> well countdown works as expected, since (fibMax 12) = 8, countdown 12 = [fibMax 8, (12 - 8)..0], which evaluates to [8, 4, 0].
13:45:47 <copumpkin> tolkad: it does let you do cool stuff, but you really need to understand the stuff underlying haskell well to use it safely
13:45:53 <tolkad> I am rather confused about why that coerce function works... considering the type signature of unsafePerformIO :: IO a -> a it seems like there should be a type error
13:46:07 <monochrom> it already breaks standard haskell rules.
13:46:15 <easy4> how do i set/unset package flags when installing with cabal?
13:46:19 <por> (err, not as expected - it's not repeating (n - fibMax n), it's calculating the sequence [n, m..0], where n and m are the values of (fibMax n) and (n - fibMAx n).
13:47:07 <logch_l> por: now you expanded that, I would have liked to see 8,3,1
13:47:12 <monochrom> coercion is overkill for converting into and out of newtype anyway.
13:50:36 <copumpkin> tolkad: anyway, I think people just get frustrated when you jump into a new setting and the first thing you try to do is to break the rules (knowing that you are) without even knowing the rules or the (very valid) reasons underlying them
13:50:52 <copumpkin> and then ask confused questions about why things break when you break the rules
13:51:11 <monochrom> only a small subset of trolling can be somewhat objectively confirmed, and even then very strong evidence is needed.
13:51:39 <tolkad> let ref = (unsafePerformIO $ newIORef []) should be forall a. IORef [a] writeIORef ref [x] should force ref to IORef [a] where a is the type of x y <- readIORef ref should be [a] where a is the type of x. head y should be type a where a is the type of x, making the type of the function a -> a which should cause a type error because I put an annotation giving the function the type "forall a b. a -> b"
13:52:48 <tolkad> copumpkin: usually when I want to learn something I start by trying to break it
13:53:13 <logch_l> por: hmm, list stays empty now. countdown n = [ (n - fibMax n) .. 0 ]
13:53:25 <logch_l> por: one week of Haskell is not enough :)
13:53:38 <mauke> tolkad: didn't you argue that Haskell wasn't a functional language because it has tuples?
13:53:58 <monochrom> when I learn something I try to break my presumptions, not the something.
13:54:30 <tolkad> mauke: uh... yeah I didn't know haskell at all yet
13:54:58 <mauke> or tuples, or functional programming
13:55:05 <tolkad> mauke: pretty much
13:55:05 <mauke> didn't keep you from arguing, though
13:55:10 <por> you want a function that takes an initial value n, inputs n into (n - fibMax n), grabs the value, puts the value in a list, then does this again with a new n
13:55:33 <ezyang> What normal form does error evaluate its argument to? 
13:56:02 <Runar> I find myself doing this a lot: join . mapM f
13:56:31 <Runar> @type \f -> join . mapM f
13:56:38 <mauke> (a1 -> [a]) -> [a1] -> [a]
13:56:50 <tolkad> mauke: if you are curious about something the best way to get a fast answer is to state wild assumptions about the answer to your question which are probably wrong. This causes people to immediately try to correct you and you are more likely to get an answer than if you just asked the question
13:56:53 <copumpkin> wow, maukebot
13:57:07 <Runar> haha
13:57:07 <sproingie> tolkad: and doing so knowingly is trolling
13:57:09 <copumpkin> tolkad: yes, it's also unpleasant behavior, and people are likely to get annoyed with you eventually
13:57:11 <logch_l> por: exactly. what type of list generator should I look into? I'am lost sleep over this
13:57:13 <mauke> tolkad: it also causes people to ban you for being an asshat
13:57:29 <Veinor> (a1 -> m a) -> (m a1) -> (m a)
13:57:31 <sproingie> my wild assumptions are of course purely by accident
13:57:31 <tolkad> if it bothers you guys I'll stop 0_o
13:57:33 <tolkad> sorry
13:57:39 <sproingie> please do so
13:57:42 <copumpkin> tolkad: I join #ubuntu and tell them "ubuntu sucks, it's impossible to configure wifi", I'll get a lot of eager responses
13:57:46 <copumpkin> I also piss them off
13:57:49 <monochrom> tolkad: your tactic is not welcome here.
13:57:56 <Veinor> Runar: that has the same type as =<<
13:58:15 <Jafet> copumpkin: nah, you'll just get fifty answers that don't work
13:58:17 <Veinor> and so it's probably the same thing
13:58:22 <copumpkin> Jafet: :P
13:58:35 * sproingie ponders joining #fedora and saying "i'm booting the fedora livecd, but fedora 14 comes out in a year, which will finish first?"
13:58:41 <monochrom> We know this provocative tactic. Lot's of people do it. Hardly original. But unwelcome. This is not a poisonous community.
13:58:59 <copumpkin> Veinor: nope, not the same
13:59:04 <Veinor> aw :(
13:59:10 <copumpkin> sad, isn't it :)
13:59:13 <monochrom> This community does not reward insults with higher social status.
13:59:18 <Veinor> darn you type system!
13:59:21 <tolkad> monochrom: it seemed more efficient to me. I don't understand why it bothers people
13:59:26 <sproingie> took the livecd 15 minutes.  jeepers.
13:59:29 <tolkad> monochrom: there were no insults involved
13:59:57 <mauke> tolkad: unsafeCoerce is an insult
14:00:06 <monochrom> We will show you it is inefficient in this channel. People, ignore all provocative questions.
14:00:12 <mauke> hah
14:00:32 <monochrom> The provocative guy will not be banned. However, I will ban all those who try to answer.
14:00:36 <copumpkin> haskell sucks
14:00:42 <copumpkin> I want a refund for my time
14:01:27 <sproingie> haskell sucks?  what do i have to install to get that?
14:01:33 <monochrom> haha
14:02:00 <monochrom> "cabal upload sucks" is that how to do it? :)
14:02:27 * BMeph hopes that tolkad is ugly, if only to make sure he doesn't have children -- or "try to understand how they work"... =8*O
14:02:30 <Jafet> You need to login to the devel repo and get HEAD
14:02:34 <tolkad> Java's type system is superior to that of haskell because it has interfaces and haskell doesn't have existential types
14:03:08 <Runar> Actually, what I'm doing is this: \r f -> fmap (\rs -> r : join rs) . sequence . fmap f
14:03:48 <tolkad> BMeph: I would respond, but I'm not sure exactly how to measure facial aesthetics.
14:03:49 <Runar> (b -> m [a]) -> a -> [b] -> m [a]
14:04:25 <copumpkin> Runar: I can't even see how that a gets used
14:04:57 <thotypous> what did happen to lambdabot? :~
14:05:05 <Runar> copumpkin: It goes on the front of the result
14:05:10 <copumpkin> oh
14:05:18 <monochrom> @bots
14:05:18 <copumpkin> :)
14:05:22 <monochrom> hahaha
14:05:28 <chrisdone> @vixen became aware and they had to kill her immediately
14:05:44 <sproingie> copumpkin is a cobot
14:05:58 <chrisdone> only because she took up 40GB of memory thinking about shoes and sex
14:06:02 <mreh_> cousin of cubert
14:06:26 <Runar> \f -> fmap join . traverse f
14:06:38 <Jafet> 40GB? That's a lot of progress they're making on the clustering compiler
14:06:53 <mreh_> :t forAll
14:06:58 <mreh_> oh right
14:07:20 <mreh_> @bots
14:07:20 <tolkad> Jafet: large paging file
14:07:35 <Runar> I shall dub it "traverseM"
14:07:36 <mreh_> cobot is down now
14:07:40 <copumpkin> Runar: what kind of a use do you have for it?
14:07:50 <thotypous> is there any webpage to do a query equivalent to lambdabot's @src?
14:08:01 <monochrom> no
14:08:10 <mreh_> hayoo with hackage
14:08:20 <mreh_> is a good substitute
14:08:30 <thotypous> thanks mreh_ :)
14:08:32 <mreh_> but nothing will replace lambdabots txt file
14:09:44 <Runar> copumpkin: I'm traversing a tree in a monad. Each a in the tree results in [m a]. So each (m a) in that list becomes m [m a], etc.
14:10:01 <tehgeekmeister> is there a reliable way to get rid of all my packages and start over?  i have tons of broken ones from trying to rebuild bytestring
14:10:06 <copumpkin> Runar: ah
14:10:20 <tehgeekmeister> (aside from just deleting ~/.cabal and uninstalling the platform?)
14:10:25 <mreh_> what does <<loop>> refer to again? an expression referring back to itself?
14:10:28 <Runar> so I have [m [m a]]
14:10:32 <tehgeekmeister> (I mean, that'd work, but i'd like to kill as little as possible.)
14:11:00 <copumpkin> mreh_: when you're evaluating a value, the runtime tries to enter the value again and spots that it's already evaluating it
14:11:09 <c_wraith> mreh_: yes.  more specifically, it means that the evaluator tried to evaluate an expression it was already in the process of evaluating.
14:11:12 <copumpkin> so it says "this can't be right, <<loop>>"
14:11:16 <zygoloid> ezyang: error does not evaluate its argument
14:11:24 <c_wraith> mreh_: An easy example is let x = tail x in x
14:11:45 <zygoloid> ezyang: normally what happens is the exception handler evaluates it as part of printing it out
14:11:45 <mreh_> that's valid haskell?
14:11:45 <chrisdone> Jafet: someone's making a clustering Haskell compiler?
14:11:48 <c_wraith> because tail needs to pattern match, it tries to evaluate x while it's evaluating x.
14:11:55 <luite> tehgeekmeister: remove ~/.cabal/lib and ~/.ghc
14:12:02 <copumpkin> c_wraith: xzibit would be proud
14:12:03 <luite> tehgeekmeister: then you can cabal-install everything again
14:12:06 <c_wraith> mreh_: sure.  it type-checks, syntax-checks, etc
14:12:06 <mreh_> that's not that easy, it decomposes that to fix and a lambda expression correct?
14:12:18 <tehgeekmeister> luite: sweet!
14:12:34 <zygoloid> ezyang: error ('A':error "b"), for instance, produces an error starting with 'A', not the error "b". but printing out that error produces error "b".
14:12:55 <Jafet> mreh_: no, it doesn't have to.
14:13:17 <tolkad> I found a secret email on the haskell website
14:13:18 <tolkad> http://www.haskell.org/pipermail/glasgow-haskell-users/2002-August/003879.html
14:13:18 <Jafet> chrisdone: something that compiles to clusters. However you name it
14:13:28 <mreh_> Jafet: I mean for the sake of comprehending what it does
14:13:43 <tehgeekmeister> luite: will that fix the rebuilt bytestring, too?
14:13:52 <Jafet> mreh_: then introducing fix does not help you comprehend what it means
14:14:01 * tehgeekmeister wants parallel cabal install
14:14:08 <luite> tehgeekmeister: where have you installed that fixed bytestring?
14:14:12 <Jafet> So you can get parallel install errors!
14:14:28 <luite> tehgeekmeister: I mean rebuilt :)
14:14:42 <tehgeekmeister> luite: i haven't customized any install paths, so it should have been under ~/.cabal
14:14:44 <mreh_> Jafet: but we're talking about operational semantics
14:14:50 <monochrom> heh, parallel build gives parallel syntax errors
14:15:11 <Jafet> mreh_: ghc? It uses thunks, and presumably keeps track of which ones it's current evaluating.
14:15:11 <tolkad> I found a copy of the lambdabot source code! http://code.haskell.org/~morrow/lambdabot/
14:15:21 <chrisdone> > [ (x,y) | x <- [1..] | y <- [1..] ] -- parallel errors?    ^_^
14:15:36 <luite> tehgeekmeister: you then that should also be removed, it should have ended up in ~/.cabal/lib, and the package registration is in ~/.ghc for the packages that didn't come with ghc itself
14:15:53 <tehgeekmeister> oh cool
14:16:10 <tehgeekmeister> well if this causes problems i'll just reinstall the platform and everything later
14:16:11 <tehgeekmeister> we'll see
14:16:13 <tehgeekmeister> =D
14:16:22 <mreh_> will haskell road make me a better programmer?
14:16:37 <monochrom> convert "let x = tail x in x" into graph. (very close to what the computer does.) you will see the cycle, the same one that the computer detects.
14:17:35 <chrisdone> mreh_: I suck really bad at javascript
14:17:39 <zygoloid> ezyang: hmm, no, i'm completely wrong. further evil digging reveals it forces it to WHNF
14:17:43 <chrisdone> haskell made be a bad programmer :(
14:17:51 <zygoloid> which is a weird thing to do to a String...
14:18:02 <chrisdone> learning haskell's like learning dvorak
14:18:03 <mreh_> I agree, haskell also ruined my life
14:18:21 <mreh_> but I'm getting it back onto the rails as we speak
14:18:26 <chrisdone> makes you suck at everything else. it's easier to stick with it and force it upon others
14:18:42 <monochrom> someone wrote a blog saying that too. haskell caused him into depression or unproductivity or something, at work.
14:18:57 <mreh_> the dvorak metaphore is nice, because no-one has it installed on their computer
14:18:58 <chrisdone> :-(
14:18:58 <tehgeekmeister> hahaha
14:19:06 <tehgeekmeister> it makes me hate working in rails
14:19:26 <mreh_> monochrom: link or troll?
14:19:37 <monochrom> blog's title and conclusion is like "this is why you shouldn't learn haskell". not sure if it's sarcasm.
14:19:43 <monochrom> I have long lost the link.
14:20:02 <inr> http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/?
14:20:18 <co_dh> mreh_: I've learned dvorak before, single handed, and then I use my right hand for mouse dedicatedly, but after a while, my left hand is so tired, and I give up. 
14:20:27 <tolkad> when running lambdabot where do you configure the username/password?
14:20:42 <monochrom> probably inr's link
14:21:08 <mreh_> I feel like saying: "haskell isn't the problem, it's the solution baby!"
14:21:11 <co_dh> yep, I'm a worse programmer now. but I'm happy 
14:21:12 <mreh_> there I just did
14:21:28 <chrisdone> Haskell doesn't demotivate people, C# demotivates people!
14:21:36 <BMeph> Runar: I got "\r f -> fmap (\rs -> r : join rs) . sequence . fmap f   :: (Functor m, Monad m) => b -> (a -> m [b]) -> [a] -> m [b]" instead of your type. Did you leave off something?
14:21:54 <chrisdone> tolkad: there's a config file somewhere in the current directory
14:22:58 <Runar> BMeph: I simplified to \f -> fmap join . traverse f
14:23:01 <tolkad> chrisdone: there's a Config.hs but it doesn't look like it has the field in it
14:23:57 <Runar> BMeph: can always liftM2 (:) afterwards
14:24:07 <aristid> lambdabot, come back!
14:24:27 <chrisdone> tolkad: iirc it was a proper text config file but ahh not looked at it in a while
14:24:42 * zygoloid performs lambdabot rain dance
14:24:50 <zygoloid> @bot
14:24:50 <zygotron> :)
14:25:01 <mreh_> I'm trying to distribute random numbers to the points of a network of signal functions, so I wrote this for the fixpoint operator, and I get loopyness: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29535#a29535
14:25:06 <monochrom> > let x=tail x in x
14:25:06 <zygotron>   /home/tla/bin/mueval: line 9: mueval-real: command not found
14:25:08 <copumpkin> lol
14:25:18 <zygoloid> you broke her!
14:25:20 <copumpkin> oh nice
14:25:30 * copumpkin has a lambdabot lying around that he can join here if people want
14:25:36 <monochrom> tla = temporal logic of actions?
14:25:42 <tolkad> > unsafeCoerce 3 :: Int
14:25:42 <zygotron>   /home/tla/bin/mueval: line 9: mueval-real: command not found
14:25:47 <tolkad> lol?
14:25:53 <tolkad> > 3
14:25:56 <zygotron>   mueval-core: /tmp/8302768055539920507155875519456725700: openBinaryFile: re...
14:26:02 <mauke> tolkad: I don't find it laughable
14:26:12 <monochrom> that is a large number...
14:26:14 <tolkad> mauke: it's funny because it's broken
14:26:38 <dom96> lol, what's going on
14:26:45 <zygoloid> huh, this was working last time lambdabot went down :(
14:26:51 <mauke> @eval ""
14:27:02 <dom96> maybe my bot will do better heh
14:28:43 <monochrom> What's funny is the prospect of several people bringing several bots. Welcome to haskell, where your evaluation queries are answered in 7.1 surround sound.
14:28:48 <zygoloid> @bot
14:28:48 <zygotron> :)
14:28:51 <zygoloid> > 1 + 1
14:28:52 <zygotron>   2
14:28:53 <ElysiaBot> => 2
14:28:57 <dom96> lol
14:29:11 <zygoloid> monochrom: your wish is our command :)
14:29:22 <mauke> > fix error
14:29:23 <zygotron>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:29:23 <ElysiaBot> => "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: 
14:29:44 <zygoloid> @slap ElysiaBot 
14:29:44 * zygotron decomposes ElysiaBot  into several parts using the Banach-Tarski theorem and reassembles them to get two copies of ElysiaBot !
14:29:49 <dom96> ^ Elysia could use some real life testing...
14:29:50 <dom96> lol
14:30:03 <burp> qthaskell, gtk2hs, which would you say it better supported? or is there any other ui-framework recommendations?
14:30:09 <monochrom> Elysia is the daughter of Elysium.
14:30:26 <aristid> @pl \f -> fmap join . traverse
14:30:26 <zygotron> const (fmap join . traverse)
14:30:31 <aristid> @pl \f -> fmap join . traverse f
14:30:32 <zygotron> (fmap join .) . traverse
14:30:49 <tolkad> > map undefined
14:30:50 <zygotron>   Overlapping instances for GHC.Show.Show ([a] -> [b])
14:30:50 <zygotron>    arising from a use ...
14:30:50 <ElysiaBot> Error: Overlapping instances for GHC.Show.Show ([a] -> [b])
14:30:50 <ElysiaBot>   arising from a use of `M10...
14:30:59 <mauke> > fix id
14:31:02 <copumpkin> dom96: what kind of a bot is ElysiaBot?
14:31:03 <ElysiaBot> Error: Time limit exceeded
14:31:04 * copumpkin misses lunabot
14:31:04 <zygotron>   mueval-real: ExitFailure 1
14:31:16 <dom96> copumpkin: what do you mean?
14:31:40 <zygoloid> > fix((0:).(1:).ap(zipWith(+))tail)
14:31:40 <ElysiaBot> => [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,53316291173,86267571272,139583862445,225851433717,365435296162,591286
14:31:40 <zygotron>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:31:51 <tolkad> > fix (\a -> undefined)
14:31:52 <zygotron>   *Exception: Prelude.undefined
14:31:52 <ElysiaBot> => *Exception: Prelude.undefined
14:32:26 <sproingie> > fix id
14:32:29 <ElysiaBot> Error: Time limit exceeded
14:32:31 <zygotron>   mueval-real: ExitFailure 1
14:32:51 <sproingie> oh mauke already tried it
14:33:09 <sproingie> > fix fix
14:33:10 <ElysiaBot> Error: Occurs check: cannot construct the infinite type: a = a -> a
14:33:10 <zygotron>   Occurs check: cannot construct the infinite type: a = a -> a
14:33:15 <tolkad> :t let x=(.)in let a=x.x.x.x.x.x.x.x.x in let b=a.a.a.a.a.a.a.a.a.a.a.a in let c = b.b.b.b.b.b.b.b.b.b.b.b in let d = c.c.c.c.c.c.c.c.c.c.c.c.c
14:33:16 <zygotron> parse error (possibly incorrect indentation)
14:33:16 <ElysiaBot> Error: <no location info>: parse error on input `)'
14:33:21 <tolkad> :t let x=(.)in let a=x.x.x.x.x.x.x.x.x in let b=a.a.a.a.a.a.a.a.a.a.a.a in let c = b.b.b.b.b.b.b.b.b.b.b.b in let d = c.c.c.c.c.c.c.c.c.c.c.c.c in d.d.d.d.d.d.d.d
14:33:29 <Bobbias> lol
14:33:32 <zygoloid> > runST (Control.Monad.ST.unsafeIOToST $ exitSuccess)
14:33:32 <zygotron>   Not in scope: `Control.Monad.ST.unsafeIOToST'Not in scope: `exitSuccess'
14:33:34 <dom96> wow
14:33:36 <zygotron> thread killed
14:33:43 <zygoloid> aww, ElysiaBot is already gone :)
14:33:51 <tolkad> did I kill it?
14:33:56 <zygoloid> yeah
14:34:02 * dom96 is sad
14:34:07 <monochrom> professor plum did
14:34:13 <mauke> tolkad: I am impressed (also, you're doing it right)
14:34:18 <monochrom> with a spanner in the library
14:34:30 <zygoloid> professor tolkad did it, in the chatroom, with the exponential type
14:34:31 * dom96 doesn't know how to parse the output of mueval correctly
14:34:39 <monochrom> hahaha
14:34:55 <dom96> zygoloid: is zygotron's source online?
14:35:04 <zygoloid> dom96: yeah, right here:
14:35:09 <zygoloid> @hackage lambdabot
14:35:09 <zygotron> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lambdabot
14:35:20 <dom96> oh, it's just a lambdabot
14:35:21 <dom96> meh
14:35:36 <zygoloid> "just"
14:35:45 <Bobbias> but its not T|HE lambdabot
14:35:52 <zygoloid> @vixen dom96 said you were JUST a lambdabot
14:35:53 <zygotron> no, how dare you ask if i'm a bot!
14:36:01 <monochrom> Just lambdabot :: Maybe Bot
14:36:12 <tolkad> zygoloid doesn't respond to CTCP source : /
14:36:25 <JoeyA> @pl (\a b -> a + 1)
14:36:25 <zygotron> const . (1 +)
14:36:30 <zygoloid> @djinn Maybe bot
14:36:30 <zygotron> f = Nothing
14:36:31 <dom96> Do any clients support CTCP source at all?
14:36:36 <tolkad> yes
14:36:43 <JoeyA> So what ever happened to lambdabot?
14:36:48 <tolkad> well, many
14:36:53 <mauke> which one?
14:36:59 <dom96> xchat doesn't ;p
14:37:00 <JoeyA> The one named "lambabot"
14:37:04 <zygoloid> irssi doesn't
14:37:20 <JoeyA> err, the nickname "lambdabot"
14:37:26 <aristid> :t (fmap.fmap.fmap) join traverse
14:37:26 <zygotron> Not in scope: `traverse'
14:37:31 <notabel> dom96: i believe SOURCE is deprecated
14:37:42 <monochrom> there is as much "CTCP source" as there is "CTCP solve-halting-problem"
14:37:51 <notabel> return the info in your VERSION reply
14:37:52 <dom96> notabel: yeah, i think so too.
14:37:56 <tolkad> really? notabel, source? (no pun intended)
14:37:56 <JoeyA> > Data.Foldable.foldl' (\a b -> a + 1) 0 $ Node "Root" [Node "Child 1" [], Node "Child 2" []]
14:37:57 <zygotron>   3
14:38:16 <tolkad> monochrom: http://www.irchelp.org/irchelp/rfc/ctcpspec.html
14:38:16 <zygotron> Title: The Client-To-Client Protocol (CTCP)
14:38:23 <tolkad> monochrom: under "KNOWN REQUEST/REPLY PAIRS"
14:38:24 <aristid> @pl \f -> fmap join . Data.Traversable.traverse f
14:38:24 <zygotron> (fmap join .) . Data.Traversable.traverse
14:38:39 <aristid> :t (fmap.fmap.fmap) join Data.Traversable.traverse
14:38:40 <zygotron> forall a a1 (f :: * -> *) (t :: * -> *). (Applicative f, Monad t, Data.Traversable.Traversable t) => (a1 -> f (t a)) -> t a1 -> f (t a)
14:38:50 <monochrom> I see.
14:38:58 <JoeyA> > Data.Foldable.foldl' (const . (+1)) 0 $ Node "Root" [Node "Child 1" [], Node "Child 2" []]
14:38:59 <zygoloid> tolkad: rfcs are not a good way of keeping track of the current state of the irc protocols :)
14:38:59 <zygotron>   3
14:39:01 <tolkad> some clients do respond to it
14:39:07 <JoeyA> Is that a good way to count items in a Data.Tree?
14:39:10 <tolkad> I have seen it before
14:39:15 <dom96> hrm, that 'limit time exceeded' message mueval outputs doesn't seem to be read by hGetContents :(
14:39:43 <Bobbias> http://tools.ietf.org/html/rfc5841
14:39:45 <tolkad> dom96: stderr
14:39:46 <zygoloid> tolkad: bitchx, irssi, xchat and mirc don't. that's got to be at least 90%
14:39:47 <tolkad> ?
14:39:58 <aristid> :t (fmap fmap (fmap fmap fmap)) join traverse
14:39:58 <zygotron> Not in scope: `traverse'
14:40:05 <dom96> why do i always forget about stderr ...
14:40:05 <aristid> :t (fmap fmap (fmap fmap fmap)) join Data.Traversable.traverse
14:40:06 <zygotron> forall a a1 (f :: * -> *) (t :: * -> *). (Applicative f, Monad t, Data.Traversable.Traversable t) => (a1 -> f (t a)) -> t a1 -> f (t a)
14:40:08 <dom96> i fail
14:40:13 <dom96> tolkad: thanks
14:40:15 <tolkad> dom96: np
14:41:52 <dom96> does anyone know who hosts the 'official' lambdabot?
14:42:05 <monochrom> Cale hosts the official lambdabot.
14:42:05 <copumpkin> Cale does
14:42:17 <dom96> oh
14:43:13 * hackagebot network-protocol-xmpp 0.3.2.1 - Client <-> Server communication over XMPP  http://hackage.haskell.org/package/network-protocol-xmpp-0.3.2.1 (JohnMillikin)
14:43:14 <zygotron> Title: HackageDB: network-protocol-xmpp-0.3.2.1
14:43:33 <Bobbias> Someone mentioned RFCs: http://tools.ietf.org/html/rfc527 ARPAWOCKY
14:43:33 <zygotron> Title: RFC 527 - ARPAWOCKY
14:43:44 <Bobbias> lol, nice
14:45:20 <tolkad> http://www.faqs.org/rfcs/rfc1149.html
14:45:21 <zygotron> Title: RFC1149 - Standard for the transmission of IP datagrams on avia
14:45:22 <ezyang> zygoloid: Curious. 
14:45:35 <Bobbias> lol, that's a good one too
14:48:24 <Bobbias> http://tools.ietf.org/html/draft-lohsen-ip-burrito-00
14:48:24 <zygotron> Title: draft-lohsen-ip-burrito-00 - IP over Burrito Carriers
14:49:23 <monochrom> why are burritos so popular?
14:49:52 <Bobbias> Well, I like them, but I don't have them all that often (nowhere nearby that has them, actually)
14:51:01 <aristid> monochrom: donuts are much better.
14:51:09 <aristid> A monad is like a donut.
14:51:45 <monochrom> and IP over donut dippings
14:51:55 <mtnviewmark> A monad is like a donut filled with jam, traveling backward in time....   oh DON'T get me started!
14:54:12 <cassian> hi
14:54:17 <monochrom> draw a periodic table of monads and jam and time travel
14:54:29 <zygoloid> error ((:) (unsafePerformIO (putStrLn "A") `seq` 'a') "B") `Control.Exception.catch` (\(SomeException _) -> return ())
14:54:48 <zygoloid> ezyang: ^^ my 'proof' that error reduces to WHNF. that does not printA
14:55:01 <zygoloid> error (unsafePerformIO (putStrLn "A") `seq` "B") `Control.Exception.catch` (\(SomeException _) -> return ())
14:55:04 <zygoloid> ^^ that does.
14:55:08 <tolkad> instance Monad Donut where
14:55:23 <aristid> join = eat
14:55:38 <zygoloid> return undefined :: Donut PassGo
14:55:50 <zygoloid> return undefined :: Donut Collect200Dollars
14:55:50 <co_dh> oh no, Monad Fix paper is 170 page..
14:55:59 <aristid> zygoloid: haha.
14:56:27 <monochrom> 170 pages? which one? and I know there are normal-length papers
14:56:57 <tolkad> I just thought of something... I can flip types around like type N a = a Int
14:57:13 <tolkad> does that work?
14:57:14 <co_dh> value recursion in Monadic computations
14:57:23 <tolkad> I'll try it
14:57:52 <copumpkin> tolkad: yep
14:58:52 <monochrom> Oh I see, it is a whole PhD thesis!
15:00:21 <monochrom> Two things make a PhD thesis long. Many schools require double-space. A thesis includes testing whether the author can write about related work, which you can easily skip.
15:00:52 <copumpkin> double spacing is bullcrap
15:01:04 <copumpkin> for a draft it's good for people to annotate in it
15:01:12 <copumpkin> but the final version should not be double spaced, in my opinion :P
15:01:15 <dom96> :t fix
15:01:16 <zygotron> forall a. (a -> a) -> a
15:01:19 * djahandarie agrees
15:01:42 <monochrom> phd thesis is a very old tradition, you know.
15:02:23 <monochrom> there are even voices within academia that suggest abandoning the whole tradition altogether. double-space is hardly the biggest concern.
15:02:26 <co_dh> thanks, monochrom.
15:02:53 <copumpkin> I think a lot of academia needs revamping, but I doubt it will happen for another couple of generations at least
15:03:02 <ezyang> zygoloid: Yeah, that was what I noticed too. 
15:03:13 <BMeph> Mmm...churros! It's like a cinnamon-sugared burrito, with caramel filling!
15:03:13 <ezyang> What confuses me, however, is the behavior of error undefined 
15:03:25 <monochrom> co_dh: you can just make do with the other papers at http://www.haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Recursion
15:03:26 <zygotron> Title: Research papers/Monads and arrows - HaskellWiki, http://tinyurl.com/yyte4n
15:03:34 <ezyang> Is evaluating undefined to whnf insufficient to trigger the error? 
15:04:06 <tolkad> what's the proper syntax for type (Monad a) => N a = a Int
15:04:10 <monochrom> I personally chose "recursive monadic bindings" and "a recursive do for haskell".
15:04:16 <tolkad> haskell doesn't like that
15:04:29 * logch_l_ gives beer to por
15:04:54 <ezyang> tolkad: You cant really do that... 
15:05:16 <copumpkin> you can put the constraint on the other side of the =, but it won't behave the way you want it to
15:05:23 <tolkad> oh
15:05:30 <tolkad> well why doesn't this work? http://codepad.org/DAFOnYN1
15:05:30 <zygotron> Title: Haskell code - 6 lines - codepad
15:05:46 <tolkad> shouldn't Monad be passed a type function?
15:05:50 <BMeph> ezyang: Evaluate (heh-heh) why you think "error" is strict... ;)
15:05:54 <tolkad> why does it say not enough arguments?
15:06:03 <copumpkin> tolkad: you can't make instances of type synonyms, and even though you can turn it on, it still won't be allowed
15:06:07 <copumpkin> cause the parameter is too flexible
15:06:26 <ezyang> BMeph: well, it's not strict strict, but its certainly not fully lazy either... 
15:06:31 <tolkad> oh, so they aren't like normal types
15:06:34 <tolkad> ok that makes sense
15:06:51 <djahandarie> I hope PhD theses get revised before I need to do mine if I decide to
15:06:55 <zygoloid> > error undefined
15:06:55 <zygotron>   *Exception: *Exception: Prelude.undefined
15:06:59 <zygoloid> > error (error "Hello")
15:06:59 <zygotron>   *Exception: Hello
15:07:09 <zygoloid> umm what?
15:07:12 <BMeph> ezyang: Yes, ...and? :)
15:07:14 <Alex_> hi
15:07:16 <ezyang> Curioser and curioser. 
15:07:30 <c_wraith> > fix error
15:07:31 <zygotron>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:07:34 <BMeph> > show undefined
15:07:34 <zygotron>   "*Exception: Prelude.undefined
15:07:40 <tolkad> :t fix.fix
15:07:40 <zygotron> forall a. ((a -> a) -> a -> a) -> a
15:07:58 <dom96> Anyone know how :t works in lambdabot?
15:08:20 <zygoloid> ezyang: ok, so. it's strict, because error _ = _|_, so error _|_ certainly is. so GHC gets free choice of whether to evaluate the argument to WHNF first.
15:08:37 <ezyang> Ah, I see. 
15:08:41 <zygoloid> and we can see it uses this choice in an arbitrary and inconsistent-seeming manner
15:09:09 <djahandarie> Inconsistency ftl
15:09:50 <zygoloid> *shrug* it complies with the denotational semantics, and the imprecise exceptions rules.
15:10:27 <ezyang> http://blog.ezyang.com/2010/08/interrupting-ghc/#comment-1088 <-- Im curious whether or not #haskell thinks Baughns race condition is an actual problem. 
15:10:27 <zygotron> Title: Interrupting GHC : Inside 245s
15:11:32 <Baughn> ezyang: Keep in mind, you should pretend your computer is being hand-executed by a demon.
15:12:06 <Baughn> ezyang: Also, try running helgrind over your program. I don't know how well it deals with pthread_cancel and signals, but it's worth a shot!
15:12:07 <ezyang> Im planning on empirically testing this by adding a sleep() before the pthread_kill :-) 
15:12:17 <ezyang> helgrind? Havent heard of that before. 
15:12:21 <Baughn> Good idea
15:12:30 <Baughn> Helgrind is pure genius. :)
15:12:30 <ezyang> Cool! 
15:12:49 <Baughn> It's.. it detects race conditions in compiled programs.
15:13:02 <ezyang> I wonder if it's packaged for Ubuntu... 
15:13:04 <Baughn> Or, rather, it detects /potential/ race conditions.
15:13:09 <Baughn> apt-get install valgrind
15:13:28 <ezyang> Oh, its in valgrind 
15:13:31 <zygoloid> specifically, it checks for memory which is read by one thread and written by another with no consistent lock held
15:13:41 <Baughn> Right.
15:13:41 <zygoloid> (iirc!)
15:14:14 <Baughn> It allows even non-explicit locks, though.
15:14:37 <copumpkin> is there a structure like a subobject classifier that instead of giving every monomophism a pullback, gives every epimorphism a pushout? is it of any interest?
15:14:40 <Baughn> Like, if A writes X, and B reads X, and A somehow /causes/ B to do that - no matter how complicated the chain is - then it won't call it a race
15:14:54 <Baughn> Don't know if it works with pthread_cancel and such, though.
15:17:45 <zygoloid> ezyang: i don't agree with your characterization of 'referentially transparent' wrt C code in that blog
15:18:03 <ezyang> zygoloid: I kind of suspected. 
15:18:07 <ezyang> What is the right term to use? 
15:18:11 <ezyang> Re-entrant? 
15:18:20 <ezyang> Interruptible? 
15:18:40 <zygoloid> ezyang: in particular, code which takes a lock, reads some stuff then releases the lock could be referentially transparent (and reentrant)
15:18:59 <zygoloid> is it allowed to leak memory if interrupted asynchronously?
15:19:10 <ezyang> zygoloid: Good point. 
15:19:14 <zygoloid> if not, i might go with something like stateless
15:19:34 <zygoloid> but i don't think that's entirely accurate either
15:19:41 <ezyang> You could imagine C code which is stateful, but can be given a chance to clean up on termination. 
15:20:23 <ivanm> preflex: seen lambdabot
15:20:24 <preflex>  lambdabot was last seen on #haskell 20 hours, 30 minutes and 34 seconds ago, saying:   Not in scope: `Data.Generics.Aliases.orElse'
15:20:35 <ivanm> isn't this getting a bit beyond a joke? where's lambdabot?!?!?!?!?!?
15:20:53 <zygoloid> maybe replace the name with the definition? just say "We should also be able to forcibly terminate it..."
15:21:03 <ezyang> Sounds like a plan. 
15:21:12 <djahandarie> ivanm, replaced by zygotron!
15:21:19 <zygoloid> very temporarily
15:21:40 <djahandarie> Permanently temporarily!
15:21:45 <sproingie> 12 galaxies ... zygotron replaces lambdabot 
15:22:12 <ezyang> updatezored 
15:22:14 <djahandarie> :t (.)
15:22:15 <sproingie> (anyone from san francisco should get that one)
15:22:15 <zygotron> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:22:27 <zygoloid> look ma, no caleskell
15:22:42 <mauke> zygoloid: :-(
15:22:57 <ezyang> "Good riddance" 
15:23:01 <djahandarie> > (+1) . [1,2,3]
15:23:02 <zygotron>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
15:23:03 <ezyang> :-P 
15:23:03 <copumpkin> lol
15:23:20 <ivanm> hooray! now caleskell!
15:23:31 <djahandarie> > 1 2
15:23:32 <zygotron>   No instance for (GHC.Num.Num (t -> a))
15:23:32 <zygotron>    arising from the literal `1' at <...
15:23:32 <gbr> caleskell?
15:24:03 <ivanm> Cale took some liberties with lambdabot's definitions files to make (.) = fmap, flip = fmap, etc.
15:24:06 <djahandarie> > (+1)
15:24:07 <zygotron>   Overlapping instances for GHC.Show.Show (a -> a)
15:24:07 <zygotron>    arising from a use of `...
15:24:15 <djahandarie> Damn, still get overlapping instances for functions :P
15:24:19 <monochrom> haha "good riddance"
15:25:42 <BMeph> flip was NOT fmap!
15:26:03 <BMeph> traverse, maybe, but not fmap.... ;)
15:26:09 <djahandarie> (->) = fmap, (+) = fmap, ($) = fmap, etc etc
15:27:08 <ivanm> BMeph: what was flip then? I recall it having a Functor-based type...
15:27:10 <dolio> flip f = \x -> f <*> pure x = \x -> fmap ($x) f
15:27:47 <djahandarie> @pl \x -> fmap ($x) f
15:27:47 <zygotron> flip fmap f . flip id
15:28:26 <djahandarie> @pl \f -> \x -> fmap ($x) f
15:28:26 <zygotron> flip (fmap . flip id)
15:29:07 <tehgeekmeister> is there anything i can do to get rid of the latency in recompiling my code?  i've got a fast ssd and my cpus aren't getting anywhere *near* maxed from cabal/ghc, and changing just *one* attribute type in a blazehtml template and recompiling takes 13 seconds.
15:29:20 <djahandarie> :t flip $ (fmap fmap (flip id))
15:29:21 <zygotron> forall a (f :: * -> *) c. (Functor f) => f (a -> c) -> a -> f c
15:29:21 <tehgeekmeister> that adds up really quick when you're making iterative changes.
15:29:28 <ivanm> tehgeekmeister: faster linker?
15:29:35 * ivanm wonders if ghc works with the gold linker...
15:29:45 <djahandarie> :t \f x -> fmap ($x) f
15:29:46 <zygotron> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
15:29:53 <tehgeekmeister> if it's a lot of work it may not be worth it, but it's worth looking into
15:30:03 <monochrom> do you mean a blazehtml template is a *.hs file?
15:30:30 <djahandarie> :t flip $ (join fmap .) . (flip id)
15:30:31 <zygotron> forall a a1. (a -> a1 -> a1) -> a -> a1 -> a1
15:30:37 <tehgeekmeister> monochrom: blazehtml is actually a combinator library, not a templating language
15:30:42 <djahandarie> Oops
15:30:55 <djahandarie> :t flip $ (join fmap) (flip id)
15:30:56 <zygotron>     Occurs check: cannot construct the infinite type:
15:30:56 <zygotron>       b = (b -> c) -> c1
15:30:56 <zygotron>     Probable cause: `id' is applied to too many arguments
15:31:06 <djahandarie> Damn
15:31:22 <tehgeekmeister> ivanm: i'm on osx, don't think gold linker will work for me anyway
15:31:24 <monochrom> What kind of things is recompiled? Are they *.hs files you're recompiling?
15:32:12 <ivanm> what kind of latency are we talking about?  what seems to be taking up all the time?
15:32:16 <monochrom> What is "changing just *one* attribute type in a blazehtml template and recompiling" mean in plain Haskell?
15:33:02 <tehgeekmeister> monochrom: an attribute is set by a function, so i am changing from one attribute's constructor function to another, and then recompiling
15:33:30 <tehgeekmeister> ivanm: i'm not sure exactly what is taking up the time, but 13s with only one changed function in a file that's just barely over a hundred lines seems like a lot
15:33:37 <tehgeekmeister> does haskell recompile the whole file every time?
15:33:56 <monochrom> recompile the whole file yes. but that takes less than 1 second.
15:34:38 <tehgeekmeister> over half the time is in linking
15:34:42 <monochrom> you can try ghc -c blah.hs to see.
15:34:45 <tehgeekmeister> (so about six seconds in linking)
15:34:58 <ivanm> yeah, the gnu linker is rather slow
15:35:06 <monochrom> static linking is a lot of file copying.
15:35:30 <tehgeekmeister> an about four seconds in cabal
15:35:32 <tehgeekmeister> *and
15:35:39 <tehgeekmeister> this is counting it manually, of course
15:35:46 <tehgeekmeister> so resolving dependencies, etc.
15:35:57 <monochrom> not sure about ghc dynamic linking in macosx but probably works as beautifully as the linux case.
15:36:14 <ivanm> monochrom: don't think they ever wrote dynamic linking for OSX
15:36:26 <ivanm> since well-typed couldn't find anyone to step up and get paid to do so IIRC
15:37:16 <tehgeekmeister> man, if only i had known about that *and* had the abilities.  i'd *love* to be paid to write haskell.
15:37:27 <monochrom> if you don't recompile, if you just :reload in ghci, how slow is that?
15:37:53 <tehgeekmeister> i'll try
15:37:55 <jmcarthur> C-c C-l ftw!
15:38:05 <BMeph> :t (. pure) . (<*>)
15:38:06 <zygotron> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
15:38:22 <copumpkin> omg a jmcarthur 
15:38:25 <tehgeekmeister> ghci can't find the other parts of my project that cabal would've told it about
15:38:26 <tehgeekmeister> =/
15:38:31 <jmcarthur> omg a copumpkin 
15:39:21 <djahandarie> BMeph, Applicative typeclass ftl
15:39:22 <dom96> how can i get the same result as lambdabot's ':t' command?
15:39:27 <Saizan> tehgeekmeister: you don't need to reconfigure everytime, use "cabal build"
15:39:37 <jmcarthur> dom96: ghci uses the same syntax
15:39:38 <tehgeekmeister> i'll try that
15:39:51 <dom96> jmcarthur: i want to use it in my application
15:39:55 <jmcarthur> ah
15:39:55 <BMeph> djahandarie: ?
15:39:58 <jmcarthur> not sure
15:40:06 <tehgeekmeister> Saizan: it'll remember the -p passed to install the last time?
15:40:21 <jmcarthur> i would check lambdabot source
15:40:23 <djahandarie> BMeph, it could be more general as Functor
15:40:28 <tehgeekmeister> less than a second!
15:40:30 <tehgeekmeister> that's what i needed.
15:40:46 <BMeph> djahandarie: As in, "I don't understand that comment. Would you please elucidate?"
15:41:02 <tehgeekmeister> Saizan: but that doesn't install the built binary itself, does it?
15:41:18 <BMeph> djahandarie: Functors can't use an "f (a-> b)" type.
15:41:35 <zygoloid> dom96: you could use mueval -i if you don't mind also evaluating it
15:41:56 <Saizan> tehgeekmeister: no, it doesn't, you can use "cabal install --only" for that though
15:42:07 <dom96> zygoloid: that doesn't work very well... with 'fix' for example
15:42:33 <tehgeekmeister> Saizan: that's fine, i don't really need it to install, just making sure i should reference the local executable instead of the installed one
15:42:41 <zygoloid> dom96: works fine here, if you also give a time limit
15:42:44 <djahandarie> :t flip (fmap fmap (flip id))
15:42:44 <zygotron> forall (f :: * -> *) a c. (Functor f) => f (a -> c) -> a -> f c
15:43:18 <zygoloid> dom96: mueval -e 'fix id' -i -t 1
15:43:32 <aristid> is it a bad idea to move instances out of a module and into a helper module that is imported by the module where the (G)ADT resides?
15:43:42 <BMeph> djahandarie: Well, I'll be.... Interesting!
15:43:52 <dom96> zygoloid: mueval -e 'fix' -i -t 1 doesn't work
15:44:03 <zygoloid> aristid: the end of that sentence sounds a bit like poetry
15:44:15 <zygoloid> dom96: hah, i see what you mean :)
15:44:29 <aristid> zygoloid: oO, why? :D
15:44:34 <BMeph> djahandarie: Now, can you define it without using "flip"? ;)
15:44:35 <djahandarie> BMeph, like dolio said it is just \f x -> fmap ($x) f
15:44:59 <djahandarie> @pl \f x -> fmap ($x) f
15:45:00 <zygotron> flip (fmap . flip id)
15:45:25 <Saizan> aristid: instances for that same (G)ADT? so they'd be mutually recursive?
15:45:28 <BMeph> djahandarie:  Oh, right, flip it structurally. That makes sense.
15:46:01 <aristid> Saizan: no, i'm trying to find other ways to split my module into more than one
15:46:14 <dom96> zygotron: any other ideas?
15:46:21 <dom96> er zygoloid 
15:46:27 <djahandarie> > "Does not compute!"
15:46:28 <zygotron>   "Does not compute!"
15:46:38 <zygoloid> dom96: GHC API should work
15:46:52 <zygoloid> but that'd be a bit heavyweight
15:47:01 <zygoloid> you could probably hack mueval to produce just the type pretty easily
15:47:19 <c_wraith> hint already has a function to get the type of an expression
15:47:38 <c_wraith> and given that mueval runs on hint...
15:47:53 <tehgeekmeister> what's a good way to deal with passing things like database connections around to all the different places in your code you need it?
15:48:15 <c_wraith> tehgeekmeister, eventually, ReaderT
15:48:37 <aristid> Saizan: the first idea was to introduce small helper GADTs which can be moved to other modules, but that creates mutual recursive type dependencies, so now i'm pondering just splitting all the JSON mumbojumbo into multiple modules
15:48:38 <tehgeekmeister> c_wraith: what does that "eventually" mean?
15:48:46 <tehgeekmeister> c_wraith: that it won't work with snap yet?
15:49:16 <dom96> zygoloid: i have no idea how i would accomplish this with hint, i tried using 'showsTypeRep (typeOf ...'
15:49:25 <dom96> but that doesn't work with fix...
15:49:45 <c_wraith> tehgeekmeister, it works very well with the 0.3 branches of snap.  I meant "when your application defines some monad that it functions in, that's when ReaderT makes sense"
15:50:46 <siracusa> Any ideas what could cause `*** Exception: expectJust mkModuleMap' when loading a module in GHCi?
15:51:38 <tehgeekmeister> c_wraith: but i don't *need* another monad.
15:51:48 * hackagebot mute-unmute 0.2.0.0 - Watches your screensaver and (un)mutes music when you (un)lock the screen.  http://hackage.haskell.org/package/mute-unmute-0.2.0.0 (KrzysztofSkrzetnicki)
15:51:49 <zygotron> Title: HackageDB: mute-unmute-0.2.0.0
15:51:49 <tehgeekmeister> c_wraith: i mean, i'm fine with using the reader monad, but i don't need one on top of that.
15:52:35 <logch_l> goodnite!
15:53:41 <c_wraith> tehgeekmeister, in the context of Snap, It's already a monad.  So you've got ReaderT Snap as something you could work with.  But support for that is *far* better in 0.3
15:54:21 <tehgeekmeister> c_wraith: is 0.3 stable enough to switch to right away?  I know i'd have to pull from github for that.
15:54:44 <c_wraith> I've been developing on 0.3 for a while.  I'm pretty sure all the issues I'm seeing are GHC bugs.
15:54:55 <tehgeekmeister> okay, i'll give that a try tomorrow
15:55:00 <tehgeekmeister> think i'm going to call it a day for now
15:55:15 <tehgeekmeister> i *really* don't want to manually pass my database connection around.
15:55:40 <tehgeekmeister> and then liftIO will still work nicely in ReaderT Snap?
15:55:59 <c_wraith> yeah, liftIO will work just fine.
15:56:07 <tehgeekmeister> slick
15:56:27 <c_wraith> The trick is the addition of MonadSnap, which means you can use ReaderT Snap in place of Snap in most snap api calls
15:56:42 <c_wraith> hey Cale.  \bot seems to be dead again
15:56:46 <Cale> okay
15:57:03 <Cale> I'm just setting up a new machine. Once I get my ssh keys copied over, I'll do it.
15:57:07 <c_wraith> Sorry that that's the most common greeting you get. :)
15:57:43 <sproingie> MonadOhSnap
15:58:01 <tehgeekmeister> sproingie: nice one.
16:12:40 * ezyang shakes fist at QuickCheck 
16:12:50 <ezyang> If the program segfaults, I never get to see what the random seed was. 
16:15:00 <ivanm> ezyang: lol
16:15:04 <aristid> ezyang: how do you manage to make it segfault?
16:15:13 <ezyang> It's FFI code. 
16:15:23 <ivanm> ezyang: IIRC you use a custom runner and you can set or at least print out what the seed was
16:15:36 <ezyang> Yeah, I've hacked up test-framework to print random seeds it generates. 
16:16:23 <dobblego> test-framework is awesome
16:16:42 <ezyang> It's ugly, but when I get that one heisenbug having those seeds will be really useful. 
16:18:40 <ezyang> dobblego: test-framework is pretty awesome 
16:19:05 <diejudenfrage> So I'm on OS X, and trying to install the Download package using cabal, and it fails to build
16:19:07 <diejudenfrage> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29547
16:19:18 <diejudenfrage> Any ideas or alternatives?
16:22:16 <diejudenfrage> Can anybody help me out?  With way to build Download 0.3, or some alternative way to download from the internet.  I'm specifically trying to read an RSS file from Craigslist.
16:23:37 <aristid> diejudenfrage: your nickname is terrible.
16:24:25 <Veinor> diejudenfrage: looks like the download package fails to build on ghc 6.12
16:24:38 <diejudenfrage> I'll change it if it's disruptive, I apologize.  I am Jewish and am historically fascinated by the idea of "The Jewish Question"
16:25:37 <vanadium> Great, now you are a crappy DC comics character
16:26:14 <Veinor> diefrage: you might want to use network.http
16:26:19 <aristid> diefrage: ah, ok, that wasn't really clear from the nickname
16:27:25 <diefrage> Okay, I'll give it a look.  Was interested in Download since it seemed very simple.  Anybody know what's up with the Build failure though?
16:27:51 <Veinor> my guess is that tagsoup changed its API since that code was written
16:28:05 * hackagebot xml-types 0.1.1 - Basic types for representing XML  http://hackage.haskell.org/package/xml-types-0.1.1 (JohnMillikin)
16:28:05 <zygotron> Title: HackageDB: xml-types-0.1.1
16:28:12 <Veinor> yeah, it's been changed
16:28:17 <Veinor> fortunately it's a very simple fix
16:29:44 <sm> dobblego, ezyang: what do you like about test-framework ?
16:30:14 <dobblego> sm, makes testing so much easier and I don't have to piss-fart about so much
16:30:24 <JoeyA> > catch (getDirectoryContents "/root") $ \err -> do hPutStrLn stderr $ show err; return []
16:30:25 <zygotron>   Not in scope: `getDirectoryContents'Not in scope: `hPutStrLn'Not in scope: ...
16:30:25 <lambdabot>   Not in scope: `getDirectoryContents'Not in scope: `hPutStrLn'Not in scope: ...
16:30:25 <zygotron> lambdabot: You have 1 new message. '/msg zygotron @messages' to read it.
16:30:30 <Veinor> preflex: seen dons
16:30:31 <preflex>  dons was last seen on #ghc 17 hours, 23 minutes and 20 seconds ago, saying: off to AFP
16:31:20 <sm> I like it too, but in order to understand it better.. I like the runner it provides better than hunit's (concurrent, etc.); and that it handles both hunit and quickcheck tests
16:31:43 <sm> IIRC that's basically what it provides
16:32:22 <copumpkin> is there a way I can ask cabal-install to pass auto-all to compilation on all modules it's building (in a cabal file I don't control)
16:32:29 <copumpkin> ?
16:32:31 <JoeyA> If I want to shrug off an IOError, is hPrint stderr a good way to do it?
16:32:40 * sm reviews haddock.. yeah, a better runner that can handle both kinds of test (and others)
16:33:05 * hackagebot libxml-enumerator 0.4 - Enumerator-based API for libXML's SAX interface  http://hackage.haskell.org/package/libxml-enumerator-0.4 (JohnMillikin)
16:33:06 <zygotron> Title: HackageDB: libxml-enumerator-0.4
16:33:08 * hackagebot expat-enumerator 0.1 - Enumerator-based API for Expat  http://hackage.haskell.org/package/expat-enumerator-0.1 (JohnMillikin)
16:33:08 <zygotron> Title: HackageDB: expat-enumerator-0.1
16:33:29 <sm> somebody get a hold of JohnMillikin's keyboard or something
16:34:35 <copumpkin> -fwarn-dodgy-exports
16:34:38 <JoeyA> hmm:  /root: getDirectoryContents: permission denied (Permission denied)
16:34:40 <copumpkin> that's cute
16:35:02 <JoeyA> That's not a very user-friendly error message.  I wonder if IOException / IOError etc. provide a more human-friendly error message printer.
16:37:32 <sm> what's wrong with it JoeyA  ?
16:38:21 <JoeyA> getDirectoryContents is a function name, not something a user did.
16:38:32 <JoeyA> 2 permissions denied
16:38:50 <JoeyA> "/root: permission denied" would be better
16:39:21 <sm> ok.. still I think the programmer would like to know about it, and they should catch that and emit whatever
16:39:46 <sm> if I'm trying to debug my haskell, every little clue helps
16:40:44 <JoeyA> Agreed, /root: getDirectoryContents: permission denied (Permission denied) is good for debugging.
16:41:04 * zygoloid out.
16:41:07 <zygoloid> zygotron: quit
16:41:29 <mreh> come back
16:41:32 <mreh> @bots
16:41:32 <lambdabot> :)
16:42:01 <JoeyA> > fix error
16:42:02 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
16:42:21 <JoeyA> I love that snippet
16:42:37 <mreh> > fix trace
16:42:37 <lambdabot>   Not in scope: `trace'
16:42:49 <mreh> :t trace
16:42:50 <lambdabot> Not in scope: `trace'
16:44:39 <mreh> I can't figure out how to write ArrowLoop for modified yampa
16:44:49 <mreh> this modified Yampa*
16:45:34 <mreh> I'm not sure I understand ArrowLoop
16:47:09 * hackagebot iteratee-parsec 0.0.4 - Package allowing parsec parser initeratee  http://hackage.haskell.org/package/iteratee-parsec-0.0.4 (MaciejPiechotka)
17:02:25 <Martty> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29553#a29553 omg im so proud of this
17:02:54 <Martty> first time i have less trouble implementing something in haskell than c++
17:10:53 <mm_freak_> Martty: you can implement this much simpler
17:11:08 <Martty> yea i just took a look at some implementations
17:11:09 <mm_freak_> you need only one base case and a very simple recursive case
17:11:11 <Martty> :(
17:11:12 <Axman6> Martty: i often find writing a partition function: partition :: Ord a => a -> [a] -> ([a],[a],[a]) is quite handy for quicksort, makes it much faster by only traversing the input list once
17:13:18 <Axman6> > let qs [] = []; qs [x] = [x]; qs (x:xs) = qs (filter (<x) xs) ++ x : qs (filter (>= x) xs) in qs [23436,57,368,357,2457,2568,25,824,58,2658,5682568,35679,9,9673568,598]
17:13:19 <lambdabot>   [9,25,57,58,357,368,598,824,2457,2568,2658,23436,35679,5682568,9673568]
17:13:28 <centrinia> You should not take that much time to get the pivot element. Having piv = head xs is fine.
17:14:12 <Axman6> yeah, it's not worth the effort. using length makes the algorithm O(n^2 log n) i believe
17:14:25 <centrinia> Not in this case.
17:14:43 <centrinia> Those two quicksorts already take more than O(n).
17:15:06 <mm_freak_> Axman6: Data.List.partition suffices for single traversal
17:15:15 <centrinia> :t partition
17:15:16 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:15:25 <mm_freak_> let qsort [] = []; qsort (x:xs) = uncurry (\ls gs -> qsort ls ++ [x] ++ qsort gs) $ partition (<x) xs in qsort [5,4,2,3,1]
17:15:26 <Axman6> mm_freak_: surt, but i usually pick out all the elements that are equal to x as well
17:15:29 <mm_freak_> > let qsort [] = []; qsort (x:xs) = uncurry (\ls gs -> qsort ls ++ [x] ++ qsort gs) $ partition (<x) xs in qsort [5,4,2,3,1]
17:15:30 <lambdabot>   [1,2,3,4,5]
17:16:45 <mm_freak_> qsort is O(n^2) anyway and quite slow for lists
17:16:53 <Axman6> right, so it is
17:17:02 <centrinia> > let qsort [] = []; qsort xs = let x = minimum xs in uncurry (\ls gs -> qsort ls ++ [x] ++ qsort gs) $ partition (<x) xs in qsort [1..50]
17:17:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:17:20 <Axman6> it's (n log n)
17:17:41 <Martty> is that theta?
17:17:45 <Martty> or omega
17:17:53 <Martty> damn encoding
17:18:27 <mm_freak_> omega
17:18:34 <mm_freak_> get UTF-8 ;)
17:19:05 <Martty> i can't
17:19:28 <mm_freak_> > (x  x^2) 15
17:19:29 <lambdabot>   Pattern syntax in expression context: x -> x ^ 2
17:19:48 <mm_freak_> GHC supports UTF-8
17:19:54 <mm_freak_> > (x -> x^2) 15
17:19:55 <lambdabot>   Pattern syntax in expression context: x -> x ^ 2
17:20:00 <mm_freak_> oh
17:20:06 <mm_freak_> > (\x  x^2) 15
17:20:07 <lambdabot>   225
17:20:22 <mm_freak_> > 5  Integer
17:20:23 <lambdabot>   Not in scope: data constructor `Integer'Not in scope: `'
17:21:19 <mm_freak_> > (undefined :: Monad m  m a  m b) (return 15)
17:21:20 <lambdabot>   No instance for (GHC.Show.Show (m b))
17:21:20 <lambdabot>    arising from a use of `M3532151837...
17:22:41 <aristid> :t (undefined :: Monad m  m a  m b) (return 15)
17:22:42 <lambdabot>     Class `Monad' used as a type
17:22:42 <lambdabot>     In the type `Monad m'
17:22:42 <lambdabot>     In the type `Monad m ??? m a'
17:25:36 <centrinia>  x,y,z,n  : n >2  x^n+y^nz^n
17:26:22 <aristid> oh, what the unicode makes possible. we shall have APL, too.
17:29:19 <Saizan> anyone knows what stg_ap_2_info represents in a heap profile?
17:29:42 <Saizan> stg_ap_2_upd_info, sorry
17:31:04 <co_dh> give code like below: instance Num t => Num (Signal t) where
17:31:05 <co_dh>   (+) = liftA2 (+)
17:31:05 <co_dh>   (-) = liftA2 (-)
17:31:05 <co_dh>   (*) = liftA2 (*)
17:31:06 <co_dh>   signum = fmap signum 
17:31:41 <co_dh> is it possible to write something like : if op is unary , call fmap, if binary , call liftA2 ? 
17:32:27 <lispy> co_dh: well, what are unary and binary in this context?
17:32:36 <ivanm> co_dh: not really
17:32:46 <co_dh> + is binary , while signnum if unary .
17:32:53 <ivanm> that would require something like an isInstanceOf function, which isn't really possible
17:33:04 <ivanm> you can certainly try to do some TH to generate code like that though
17:34:03 <co_dh> but I found TH code is hard to read. anyway , I think I might be a freak of " Do Not Repeat " yourself.
17:35:03 <co_dh> what's the best way to understand other's code ? 
17:35:18 <co_dh> take http://hackage.haskell.org/packages/archive/elerea/2.1.0/doc/html/src/FRP-Elerea-Simple.html#Signal for example, how do you read it ? 
17:35:37 <co_dh> run it in ghci ? let ghci to decide the type for you ? or something else? 
17:36:06 <co_dh> that start function as example, I would copy & paste the code, and using ghci to debug it , 
17:36:12 <ivanm> co_dh: there's type sigs already in there...
17:36:15 <co_dh> is there a better method ? 
17:36:20 <ivanm> I would just read the code and work my way through it
17:36:39 <co_dh> take start as example, I don't know the what's the gen is S sample <- gen pool. 
17:36:58 <co_dh> ivanm: you already senior enough on haskell, 
17:37:15 <ivanm> am I?
17:37:30 <co_dh> or walk by the brain is too energy consuming. 
17:37:32 <ivanm> co_dh: the S is a capital, so it must be a constructor
17:37:42 <co_dh> ok, let me ask you , whan is the gen there ? 
17:37:47 <ivanm> in this case, it's the constructor for Signal
17:37:59 * wli is doubtless proof that seniority doesn't necessarily entail knowledge.
17:38:10 <ivanm> co_dh: "start (SG gen) = ..."
17:38:11 <mm_freak_> co_dh:
17:38:19 <mm_freak_> > (+) <$> [1,2,3] <*> [4,5,6]
17:38:20 <lambdabot>   [5,6,7,6,7,8,7,8,9]
17:38:20 <ivanm> so the gen is the bit passed in via the input
17:38:25 <ivanm> in this case, it's the Signal
17:39:03 <co_dh> woops , that's one place that will cause brain energy to lose, you see , I didn't see it's coming from the argument.
17:40:18 * ivanm found it by searching for "gen"
17:40:31 <co_dh> mm_freak_: what did you say? 
17:41:01 <ivanm> co_dh: he said:
17:41:02 <ivanm> ;-)
17:41:06 <mm_freak_> hehe
17:41:18 <mm_freak_> i gave you a code example
17:41:39 <mm_freak_> > (+1) <$> [1,2,3]
17:41:40 <lambdabot>   [2,3,4]
17:41:44 <mm_freak_> > (+) <$> [1,2,3] <*> [4,5,6]
17:41:45 <co_dh> on what ? applicative ?  thanks :)
17:41:45 <lambdabot>   [5,6,7,6,7,8,7,8,9]
17:41:46 <JoeyA> Woot, throwing 3 seqs into my program made ghci go from using 1.2g to 64m of RAM :-)
17:41:52 <mm_freak_> yes
17:42:21 <ivanm> JoeyA: hooray!
17:42:27 <ivanm> how did you find where to put the seqs?
17:42:34 <co_dh> wow 3 seqs ? JoeyA ? curios to know
17:42:36 <mm_freak_> JoeyA: interestingly i never use seq, not even in larger programs
17:42:37 <JoeyA> I'm building a tree of files, and I have a function that gathers totals into a structure.
17:42:46 <JoeyA> The tree has a million files
17:42:57 <JoeyA> (1098474, to be exact)
17:43:02 <co_dh> :t seq
17:43:03 <lambdabot> forall a t. a -> t -> t
17:43:18 <JoeyA> I used Data.Foldable.foldl' to get the totals
17:43:28 <JoeyA> but, as I've learned in the past, seq doesn't propagate down
17:43:37 <JoeyA> I still had to seq the individual fields.
17:43:37 <ivanm> mm_freak_: do you use bangs in data types?
17:44:12 <mm_freak_> ivanm: sometimes, yes
17:44:46 <ivanm> so you're implicitly using seqs? :p
17:44:52 <JoeyA> Here's my building function:  http://codepad.org/r33YFFQp
17:45:03 <JoeyA> I guess now's a good time for me to learn about bang patterns.
17:45:20 <JoeyA> count (Totals files size used) file = seq files $ seq size $ seq used $ ...
17:45:21 <Axman6> bang-patterns++
17:45:31 <JoeyA> can that be changed to count (Totals files! size! used!) file = ... ?
17:45:43 <Axman6> !files !size !used
17:46:07 <Axman6> though, it really depends what the types of files, size and used are to make it useful
17:46:31 <Axman6> works best with non recursive structures, because i think it only evaluates to WHNF
17:46:50 <JoeyA> Indeed, they are Int64s
17:47:22 <JoeyA> My question is, is: count (Totals files size used) file = seq files $ seq size $ seq used $ payload
17:47:35 <JoeyA> equivalent to: count (Totals !files !size !used) file = payload
17:47:58 <JoeyA> specifically, where payload = Totals (files + 1) (size + statSize stat) (used + statUsed stat)
17:49:40 <co_dh> ivanm:  how do you understand stateful x0 f = mfix $ \sig -> delay x0 (f <$> sig)
17:49:45 <mm_freak_> ivanm: seq vs. type bangs  eager evaluation vs. strictness
17:50:01 <co_dh> it's in http://hackage.haskell.org/packages/archive/elerea/2.1.0/doc/html/src/FRP-Elerea-Simple.html#Signal 
17:50:08 <ivanm> mm_freak_: huh, I thought type bangs was done via seq
17:50:12 <co_dh> line 362
17:50:21 <ivanm> @type mfix
17:50:22 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
17:50:39 <mm_freak_> ivanm: are you confusing type bangs with bang patterns?
17:50:51 <ivanm> ... possibly... ;-)
17:51:10 <ivanm> co_dh: since I haven't looked through that library and I'm not really familiar with FRP in general, I can't help you too much there
17:51:21 <mm_freak_> data StrictList a = Empty | Cons !a (StrictList a)
17:51:34 <mm_freak_> eagerFoldl = foldl'
17:51:35 <ivanm> but the documentation seems clear enough to understand
17:51:45 <co_dh> ivanm: It's the problem that I encountered when reading other's code. 
17:52:06 <co_dh> I'll try my ghci debug way :)
17:52:41 <ivanm> co_dh: are you wanting to use the library or understand how it works?
17:53:10 <co_dh> one of the problem I found about programming : when we write code, we build piece by piece, and test it, and then put it together, but when others read it, they can't break it to understand it. 
17:53:33 <co_dh> ivanm: understand how it works. as a way of learning haskell. 
17:53:50 <ivanm> well, pick a simpler library with less theoretic aspects ;-)
17:53:56 <ivanm> FRP is still a research area
17:54:06 <co_dh> In fact, I want to do game programming in haskell, on iphone, so if I understand it, I might be able to do FRP with C.
17:54:23 <co_dh> game is my focus and interest :)
17:55:03 <mm_freak_> co_dh: you can do RP in C
17:55:06 <djahandarie> You mean RP in C
17:55:09 <djahandarie> lol beat to it
17:55:12 <mm_freak_> but FRP is going to be difficult =)
17:55:15 <mm_freak_> hehe
17:55:32 <co_dh> lol, RP. 
17:55:51 <djahandarie> I'm still not sold on the arrow interface for FRP
17:55:56 * djahandarie steps out for a moment
17:56:11 <mm_freak_> the arrow interface is great, but a bit difficult to understand
17:56:34 <co_dh> I found arrow is simple for me, just like unix pipe, but with forks etc. 
17:57:18 <ivanm> someone learning Haskell who understands and likes arrows?
17:57:25 * ivanm smells a fake...
17:57:26 <ivanm> :p
17:58:01 <co_dh> I really like arrows and Point free style, I guess because I love APL and J too. 
17:58:32 <co_dh> I learned APL and J before Haskell, and found APL & J is ... really impossible to read , lol. 
17:58:32 <Axman6> pointfree is the bane of my existance
17:58:39 <ivanm> you mean arrows like >->, right?
17:58:40 <ivanm> Axman6: :o
17:58:47 <ivanm> heretic!
17:59:25 <co_dh> >-> is the arrow notation,  by arrow , I mean >>> 
18:01:21 <co_dh> is there something like stack trace in gchi debugger? 
18:01:31 <ivanm> not really
18:01:37 <ivanm> stack traces don't make much sense in GHC
18:01:49 * ivanm can't recall if that's due to implementation or Haskell in general
18:02:24 <djahandarie> There is gdb
18:02:29 <co_dh> if f called g called h, and I'm in h , how can I know f's variable ?
18:02:43 <co_dh> can you gdb Haskell code? 
18:02:56 <ivanm> why would you need to know?
18:02:58 <djahandarie> It's not very nice
18:03:21 <co_dh> ivanm: you seemed right :)
18:03:29 <co_dh> it's functional !
18:03:30 <JoeyA> I'd think a semantic backtrace would be useful (in which a debugger tells you the logical stack, not the actual program stack).
18:03:36 <JoeyA> In other words, if you have:
18:03:41 <JoeyA> makeItems :: [Int]
18:03:47 <JoeyA> makeItems = [1..100]
18:03:53 <ivanm> JoeyA: I'm sure patches are accepted... ;-)
18:04:14 <JoeyA> someFunc = makeItems !! 79
18:04:38 <JoeyA> then you invoke someFunc, but very far into the future, the value of it is evaluated.
18:05:14 <mm_freak_> JoeyA: i would call that value 'items', not 'makeItems'
18:05:17 <JoeyA> The logical stack trace would be ... -> someFunc -> !! for that particular item, I think
18:05:47 <JoeyA> as opposed to crazyFunctionOverYonder, which is invoked and evaluated much later in the program.
18:05:57 <JoeyA> (at the point when makeItems !! 79 is actually evaluated.
18:06:45 <JoeyA> The idea is: get the stack trace pretending that Haskell is a strict language
18:06:55 <JoeyA> Hence, if you kept polling the stack, it'd be all over the place due to lazy semantics.
18:07:08 <mm_freak_> JoeyA: well, that would be a graph trace or something
18:07:16 <JoeyA> I don't know how hard that would be to implement (especially efficiently)
18:07:49 <mm_freak_> it's like asking whether it's possible to tell whether two values share the same memory location
18:07:50 <JoeyA> I'd imagine you could transform an entire program such that function invocations are annotated with call stack strings.
18:07:54 <mm_freak_> that question doesn't make much sense in haskell
18:08:01 <JoeyA> instead of:
18:08:04 <JoeyA> items :: [Int]
18:08:06 <JoeyA> it'd be:
18:08:11 <JoeyA> items :: String -> [Int]
18:08:23 <JoeyA> where String is the logical call stack
18:09:09 <co_dh> I have troulbe to understand 184  instance MonadFix SignalGen where
18:09:09 <co_dh> 185    mfix f = SG $ \p -> mfix (($p).unSG.f)
18:09:28 <co_dh> know I knows from ghci the following :
18:09:35 <co_dh> f :: a -> SignalGen a 
18:09:44 <co_dh> p :: IORef UpdatePool
18:10:25 <co_dh> oh, sorry, ghic knows f and unSG.f , so I don't need to ask you guys ;)
18:15:33 <co_dh> :t ($5)
18:15:34 <lambdabot> forall a b. (Num a) => (a -> b) -> b
18:15:44 <co_dh> ($5) (+1)
18:15:54 <co_dh> > ($5) (+1)
18:15:55 <lambdabot>   6
18:16:26 <co_dh> so ($ 5) give 5 to the first argument of a function, that's cool. 
18:17:08 <Codex_> if I have 2d array of pixels, how do I create for-loop equivalent that would go through all of them and change their colour from white to red? :)
18:17:25 <ivanm> > map ($5) [succ, (^2), (`div` 3)]
18:17:26 <lambdabot>   [6,25,1]
18:17:39 <ivanm> Codex_: how are you implementing said 2D array?
18:17:56 <ivanm> a list of lists? Data.Array? vector? a Map?
18:18:03 <Codex_> ivanm: f :: (x,y)->Color ?
18:18:25 <ivanm> you're implementing your 2D array as a function?
18:18:49 <ivanm> that's not going to be very performant...
18:18:52 <co_dh> I think Codex_ thinks really functaionally.
18:18:56 <ivanm> and you won't be able to get every possible colour out
18:19:26 <copumpkin> Codex_: f = const Red :P
18:19:31 <ivanm> I mean, you can define a Set as its church encoding on member: member :: (Eq a) => a -> Bool
18:19:32 <copumpkin> Codex_: super fast, super efficient
18:19:39 <ivanm> but that won't tell you everything that is in there
18:19:46 <co_dh> compose \c -> if c == White then Red else c with your f , Codex_
18:19:47 <ivanm> copumpkin: I _was_ trying to get a sensible solution done...
18:20:09 <ivanm> co_dh: I don't think that's Codex_'s real implementation somehow...
18:21:00 <co_dh> ivanm: that's a joke, the really fast implementation would be use CUDA.
18:21:14 <ivanm> huh?
18:21:25 <Codex_> well, we were thinking of for-loop equivalents, and couldnt figure out much else than list comprehensions and mapM_ and sequence and [0..] etc, but those have their limitations :)
18:21:26 <roconnor> @type evalState
18:21:27 <lambdabot> forall s a. State s a -> s -> a
18:21:32 <co_dh> or GPGPU, general programming on Graphic Process Unit, that's another interest of me. 
18:22:05 <ivanm> Codex_: how to define your mapping function will depend on how you define your 2D structure
18:22:22 <ivanm> co_dh: doesn't necessarily it'll "really fast" though
18:22:53 <co_dh> ivanm: not fast if you are simulating smokes . 
18:23:08 <ivanm> ummm... OK...
18:26:43 <co_dh> copumpkin, what's your understanding of mfix ? do you have a few example?  
18:28:04 <ivanm> @hoogle mfix
18:28:05 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
18:28:11 <ivanm> co_dh: ^^ type signature says it all
18:28:22 <ivanm> it's a monadic version of fix, which is the haskell equivalent to the Y combinator
18:28:48 <co_dh> fix point of  a -> m a  ?
18:28:56 <ivanm> yup
18:29:17 <co_dh> some example ? take list as monad .
18:29:29 <co_dh> or other monad that is easy .
18:29:36 <ivanm> > fix ( \ f x -> case x of 0 -> 1; _ -> x * fact (x-1)) 5
18:29:37 <lambdabot>   Not in scope: `fact'
18:29:42 <Codex_> copumpkin: the const is somehow a->1->b ?
18:29:45 <ivanm> > fix ( \ f x -> case x of 0 -> 1; _ -> x * f (x-1)) 5
18:29:46 <lambdabot>   120
18:29:55 <ivanm> ^^ using fix to define factorials
18:30:07 <copumpkin> co_dh: never used mfix, sorry :)
18:30:29 <co_dh> ivanm: ok, that's fix, what about mfix?
18:30:49 <ivanm> well, it returns a monadic value rather than a normal one
18:30:49 <co_dh> copumpkin: I guess I could give up mfix :)
18:31:12 <co_dh> > mfix ( \x -> [x] )
18:31:16 <lambdabot>   mueval-core: Time limit exceeded
18:31:53 <aristid> > mfix ( \x -> [] )
18:31:54 <lambdabot>   []
18:32:01 <aristid> > mfix ( \x -> [1] )
18:32:02 <lambdabot>   [1]
18:32:14 <ivanm> @src fix
18:32:14 <lambdabot> fix f = let x = f x in x
18:32:18 <ivanm> @src mfix
18:32:19 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:32:21 <ivanm> bah
18:32:25 <aristid> @src [] mfix
18:32:26 <lambdabot> mfix f = case fix (f . head) of
18:32:26 <lambdabot>            []    -> []
18:32:26 <lambdabot>            (x:_) -> x : mfix (tail . f)
18:32:43 <ologNation> Can someone tell me how to print ghci's search path? 
18:32:55 <ivanm> ologNation: which search path?
18:33:11 <ivanm> ":! pwd" ?
18:33:55 <co_dh> @src IO mfix
18:33:56 <lambdabot> mfix = fixIO
18:34:03 <co_dh> @src fixIO
18:34:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:34:34 <ivanm> Cale: what's this mysterious mission you've given lambdabot? :p
18:35:03 <ologNation> "search path"  See sec 4.3 in http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/separate-compilation.html
18:35:08 <co_dh> wow, what a good document about fixIO 
18:36:02 <ivanm> ologNation: just looks relative to the current directory (and extra paths added with -i) for modules that correspond to the hierechical module system
18:36:18 <ologNation> Oh. 
18:36:22 <ivanm> http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/separate-compilation.html#search-path
18:36:53 <Cale> mission?
18:37:42 <co_dh> anybody knows what fixIO does?
18:37:46 <ivanm> <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:37:51 <ivanm> co_dh: it's just mfix for IO
18:38:22 <monochrom> http://www.haskell.org/haskellwiki/MonadFix
18:38:43 <ivanm> Cale: lambdabot talks about being on an important mission... ;-)
18:38:58 <Cale> oh, I see
18:39:21 <monochrom> her ongoing mission: to seek out new nerds, to boldly go where no ircer has gone before
18:39:50 <ivanm> lol
18:39:51 <monochrom> perhaps to victimize new nerds too
18:39:54 <ologNation> Well, suppose I wrote a module that I really liked.  Isn't there some place that I can put it where ghc or ghci will always be able to find it? 
18:40:08 <ivanm> ologNation: ~/.ghc/ ?
18:40:14 <ivanm> however, that would make distribution difficult...
18:40:25 <ivanm> so you're better off making it a libray
18:40:25 <co_dh> monochrom: am I the nerd you are talking about ?
18:40:27 <ivanm> *library
18:40:30 <monochrom> you can cabalize your module
18:40:39 <ivanm> if it's just a set of tweaks to use in ghci, put them in ~/.ghci
18:40:53 <ologNation> cabalize your module...
18:41:05 <ivanm> make it an actual library and install it locally on your system
18:41:25 <monochrom> I still have cabalize examples at http://www.vex.net/~trebla/tmp/
18:41:42 <ivanm> there's also "cabal init"
18:42:30 <monochrom> http://www.haskell.org/ghc/docs/6.12.2/html/Cabal/authors.html
18:43:23 <ivanm> there's also an example on the wiki, and a couple of examples on hackage IIRC
18:44:23 <co_dh> monochrom: thanks for the MonadFix link, that one seemed easy 
18:44:45 <monochrom> I tend to make everything sound so easy
18:45:23 <co_dh> did you write that wiki of MonadFix? 
18:45:52 <monochrom> Yes. Someone else updated it to use new notation.
18:46:40 <monochrom> new notation means the "with recursive do" columns
18:48:14 <co_dh> monochrom: you should cut your hair, lol
18:48:28 <monochrom> I already did last week.
18:49:13 <ologNation>  monochrom What are these examples on vex.net? 
18:49:38 <monochrom> examples of cabalizing
18:49:51 <monochrom> I mean the *.tar.gz files
18:52:14 <roconnor> OMG, recursion doesn't mean repeatition!
18:52:39 * roconnor mind blown
18:52:46 <JoeyA> About a year ago, I thought it did.
18:53:00 <JoeyA> Look at me now!
18:53:19 <roconnor> it is more like defined in terms of itself
18:53:19 <JoeyA> > fix fix
18:53:20 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
18:53:40 <lowasser1> lololol
18:54:23 <lowasser1> :t fix fix
18:54:24 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
18:54:24 <lambdabot>     Probable cause: `fix' is applied to too many arguments
18:54:24 <lambdabot>     In the first argument of `fix', namely `fix'
18:54:40 <lowasser1> :t fix
18:54:41 <lambdabot> forall a. (a -> a) -> a
18:54:44 <lowasser1> ah, yup
18:54:48 <lowasser1> get it now
18:55:00 <Axman6> :t fix (fix (fix id))
18:55:01 <lambdabot> forall a. a
18:55:07 <Axman6> > fix (fix (fix id))
18:55:10 <lambdabot>   mueval-core: Time limit exceeded
18:55:15 <Axman6> >_>
18:55:25 <co_dh> > fix $ const 5
18:55:27 <lambdabot>   5
18:55:40 <co_dh> @src fix
18:55:40 <lambdabot> fix f = let x = f x in x
18:55:52 <co_dh> how haskell implemented fix ? 
18:55:57 <lowasser1> once you grok fix, you pretty much know haskell
18:56:05 <lowasser1> > fix (1:)
18:56:05 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:56:08 <Axman6> i don't agree
18:56:12 <JoeyA> http://r6.ca/blog/20060919T084800Z.html
18:56:16 <lowasser1> <--- massive exaggeration
18:56:25 <lowasser1> but it's a nontrivial feat
18:56:26 <monochrom> once you grok haskell, you pretty much know fix. :)
18:56:51 <lowasser1> accurate!
18:57:15 <lowasser1> you realize, for instance, that most forms of recursion are secretly fix
18:57:15 <roconnor> lowasser1: have you learned mfix?
18:57:18 <JoeyA> Unless you cheat and use pattern matching:  http://r6.ca/blog/20060919T084800Z.html
18:57:20 <JoeyA> err
18:57:22 <JoeyA> fix2 f = f (fix2 f)
18:57:31 <lowasser1> yeah
18:57:45 <monochrom> haskell implemented fix by that line of code lambdabot said. it further compiles down to a cyclic pointer graph.
18:57:54 <roconnor> man, learning mfix was like learning recursion all over again
18:58:02 <JoeyA> :t mfix
18:58:03 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
18:58:05 <lowasser1> yeah, I bet
18:58:14 <lowasser1> it's recursion.... WITH A MONAD
18:58:27 <co_dh> mind exploded.
18:58:28 <monochrom> learning haskell is like learning computing all over again
18:58:46 <lowasser1> psh, that's why you should start with haskell
18:58:54 <monochrom> and mfix
18:59:25 <co_dh> ok, I'll go to bed the 3rd time again, everytime I feel pain about haskll, I go to bed. lol
18:59:39 <JoeyA> > mfix (:[])
18:59:43 <lambdabot>   mueval-core: Time limit exceeded
18:59:47 <roconnor> @type fix . (=<<)
18:59:48 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b
18:59:56 <roconnor> I found mfix confusing because it is not that
19:00:35 <JoeyA> @type fix . (=<<) . (=<<) . (=<<) . (=<<)
19:00:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m (m (m (m a)))) -> m (m (m (m a)))
19:00:56 <JoeyA> moar monads, MOAR
19:01:15 <co_dh> It is tempting to see recursion and guess it means performing actions recursively or repeatedly. No. 
19:01:32 <lowasser1> *value* recursion
19:01:38 <lowasser1> it's the name of the paper for a reason
19:01:41 <roconnor> co_dh: indeed
19:02:03 <co_dh> I copied that line from MonadFix wiki, which I don't understand now :)
19:02:58 <monochrom> it is called "value recursion". it recurses the return value, not the action.
19:02:59 <roconnor> The only good illustration of value recursion that comes to mind is that KMP-string matching algorithm
19:03:13 <roconnor> there must be other simpler ones
19:03:21 <lowasser1> psh, haskell does value recursion everywhere
19:03:29 <lowasser1> the traditional fibonacci list is value recursion
19:03:30 <roconnor> I mean cycle is an example
19:03:43 <roconnor> but still looks too much like repeatition
19:03:52 <roconnor> to hammer in the point
19:04:20 <JoeyA> > mfix $ (:[]) . const 5
19:04:21 <lambdabot>   [5]
19:05:03 <roconnor> > mfix (\x -> [1:x,2:x])
19:05:04 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:05:14 <roconnor> > map (take 5) $ mfix (\x -> [1:x,2:x])
19:05:15 <lambdabot>   [[1,1,1,1,1],[2,2,2,2,2]]
19:06:25 <Axman6> :o
19:07:01 <roconnor> Axman6: what is the value of 'x' ;)
19:07:31 <Axman6> this is like asking what is the value of love plus a song my friend!
19:08:53 <dankna> slightly more than the value of love without the song.
19:08:54 <roconnor> > map (take 5) $ mfix (\x -> guard (even (head x)) >> [1:x,2:x,3:x])
19:08:58 <lambdabot>   mueval-core: Time limit exceeded
19:13:33 <roconnor> mmm, time travel paradox
19:18:31 <dolio> So, apparently, arguing about what to call monadic values is even more popular than arguing about syntax.
19:18:42 <roconnor> motes?
19:19:13 <lispy> dolio: ?
19:19:29 <ivanm> lispy: on the haskell reddit
19:19:53 <lispy> oh, reddit.  Isn't that thing just a waste of time?  /me asks seriously as someone who avoids reddit
19:20:14 <dolio> The haskell reddit is slightly less of a waste of time.
19:20:31 <lispy> cabal-install is doing something weird >:(
19:20:42 <lispy> setup: ghc-pkg: dependency bytestring-0.9.1.0 doesn't exist (use --force to
19:20:42 <lispy> override)
19:20:51 <ivanm> lispy: well, the whole point of cabal-install is to do weird stuff, isn't it? :p
19:20:59 <lispy> but, ghc-pkg list bytestring is showing that version in my local pkg db
19:21:12 <ivanm> lispy: lemme guess: you're trying to cabal-install something globally?
19:21:20 <ivanm> also, why are you using a non-GHC bytestring?
19:21:22 <lispy> ivanm: nope, I even passed --local
19:21:35 <ivanm> do you _want_ diamond dependency problems?
19:21:39 <lispy> non-ghc bytestring?
19:21:48 <ivanm> well, recent GHCs come with bytestring
19:21:54 <roconnor> lispy: monochrom tells me that he has no problems with cabal.
19:22:01 <ivanm> so installing bytestring to your local DB is going to cause problems down the line
19:22:12 <ivanm> roconnor: yes, but lispy is bitching about cabal-install
19:22:13 <ivanm> ;-)
19:22:17 <roconnor> hmm
19:22:32 <roconnor> I wonder if monochrom wasn't talking about cabal install
19:22:37 <lispy> ivanm: Why would it cause problems?  I don't understand.  I can install multiple versions of other stuff
19:22:38 <roconnor> that would explain a lot
19:22:52 <ivanm> lispy: because bytestring is a boot library
19:23:02 <ivanm> so some parts of GHC depend upon a specific version of bytestring
19:23:21 <lispy> ivanm: The only _weird_ thing I'm doing is telling cabal to use a version of ghc that's not in my path.  I checked with --verbose and it appears to be calling the correct ghc everywhere (6.8.2)
19:23:24 <ivanm> and thus if you try to use those libraries along with something that uses your local version of bytestring then you're going to have version mis-matches
19:23:56 <ivanm> lispy: that's why a lot of package failures on hackage are caused by bytestring being upgraded to a newer version than what comes with the version of GHC that's there
19:24:21 <ivanm> lispy: hmmm..... not sure how to deal with that; my guess is that the pkg-db you have locally is with a different GHC
19:24:26 <lispy> aren't the package failures on hackage meaningless though?
19:24:31 <ivanm> maybe check with dcoutts how he deals with this situation
19:24:33 <djahandarie> ezyang, if you are here, great job on that tech talk!
19:24:42 <djahandarie> ezyang, you're really good at presenting
19:24:44 <ivanm> lispy: sometimes, yes; but there are quite a few caused by bytestring version mis-matches
19:25:21 <lispy> hmm
19:25:44 <lispy> I guess i'll stop torturing myself.  I just wanted to see if darcs still builds on 6.8 (they removed the 6.8 build slave, but I thought maybe...)
19:25:44 <ivanm> that's why the only library that comes with GHC that is safe to upgrade is Cabal
19:25:52 <ivanm> because no parts of GHC actually depend upon Cabal
19:25:57 <lispy> I don't personally care about darcs on 6.8, but maybe someone somewhere does...
19:26:05 <carlosgaldino> Hi, could someone help me to write some simple haskell programs?
19:26:31 <ivanm> carlosgaldino: depends on what you want to do
19:26:36 <ivanm> have you gone through any tutorials?
19:26:39 <lispy> ivanm: but, cabal-install upgrades bytestring whether I ask it to or not
19:26:48 <ivanm> are you using "cabal upgrade" ?
19:26:50 <lispy> ivanm: all I have to do is request a package that wants a newer bytestring
19:27:05 <lispy> ivanm: nope, just cabal install and sometimes cabal install --reinstall
19:27:12 <ivanm> lispy: oh, right, because 6.8 had 0.9.0.x rather than 0.9.1.y
19:28:17 <carlosgaldino> ivanm: the problem is that i can't figure how to get retrieve a value from a list of tuples?
19:28:42 <ivanm> @hoogle find
19:28:42 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
19:28:43 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
19:28:43 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
19:28:50 <ivanm> ^^ carlosgaldino like the last one there?
19:28:55 <ivanm> @hoogle lookup
19:28:56 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
19:28:56 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
19:28:56 <lambdabot> Data.IntMap lookup :: Key -> IntMap a -> Maybe a
19:28:58 <lispy> :t lookup
19:28:59 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
19:29:05 <ivanm> carlosgaldino: ^^ or even lookup ?
19:29:11 <ivanm> lispy: yeah, I forgot about lookup for a bit
19:29:44 <lispy> > lookup "pizza" [("pasta", 1), ("mushrooms", 2), ("pizza", 3), ("bread", 4)]
19:29:45 <lambdabot>   Just 3
19:29:52 <carlosgaldino> ivanm: the problem is i can't even understand the last
19:30:25 <ivanm> the type of lookup?
19:30:30 <ivanm> lispy just provided an example
19:30:36 <ivanm> or do you mean find?
19:30:43 <ivanm> > find (>10) [1..20]
19:30:44 <lambdabot>   Just 11
19:30:57 <lispy> carlosgaldino: do you know how to read a type signature in Haskell?
19:31:14 <carlosgaldino> ivanm: i have to retrieve the first and last teams in a tournament. the structure is like Score = ["Team", 10] and the tournament is [Score]
19:31:33 <ivanm> is this homework?
19:31:53 <carlosgaldino> ivanm: yep. 
19:32:01 <carlosgaldino> ivanm: i think this is the third class
19:32:16 <soduko> how can this be made better?
19:32:19 * lispy thinks that should be Score is ("Team", 10), not []
19:32:23 <soduko> dotProduct lhs rhs len = foldl (+) 0 $ zipWith (*) ( take len lhs ) ( take len rhs )
19:32:23 <soduko> m v n c = [ [ dotProduct ( drop ( c - k ) v ) ( drop ( c - j ) v ) ( n - c ) | k <- [0,1 .. c ] ] | j <- [ 0, 1 .. c] ]
19:32:39 <carlosgaldino> lispy: yeah, right.
19:32:46 <lispy> soduko: use Data.Vector?
19:33:30 <ivanm> carlosgaldino: well, it's just polite to say so, that's all
19:33:33 <lispy> carlosgaldino: if I were you (and I'm not), then I would spend a bit of time going over the basics in a tutorial.  Then try the task again :)
19:33:46 <ivanm> so, if you want the first and last team, you want the first and last elements of a list
19:33:49 <ivanm> @hoogle [a] -> a
19:33:49 <lambdabot> Prelude head :: [a] -> a
19:33:49 <lambdabot> Prelude last :: [a] -> a
19:33:49 <lambdabot> Data.List head :: [a] -> a
19:33:58 <ivanm> lispy: agreed
19:34:32 <lispy> carlosgaldino: what have you tried so far?
19:36:03 <carlosgaldino> lispy: i tried to travel the list but i don't know how to evaluate just the points and return the name. i tried to use fst and snd but i couldn't
19:37:19 <ivanm> show us what you tried
19:38:11 <soduko> lispy: that would make it faster right?
19:38:22 <soduko> would the executable also become bigger?
19:39:03 <lispy> soduko: Yeah, but my _real_ reason to say it is that lists are streams not arrays.  You want some sort of array data type if you're doing dot products.  Or tuples would work too.  But lists are all wrong :)
19:40:49 <carlosgaldino> ivanm: http://pastie.org/1121758
19:41:24 <ivanm> OK, you're doing fst and last right
19:41:39 <ivanm> now, for total_score, should that be the sum of the scores?
19:41:46 <soduko> i have to get the values being worked on from a file.  and figured this would be the easiest way to write it :)
19:42:06 <carlosgaldino> ivanm: yep
19:43:06 <ivanm> carlosgaldino: so, think of it this way: get all the scores, and then add them up
19:46:28 <carlosgaldino> ivanm: but how can i get the second element from the tournament?
19:46:40 <carlosgaldino> ivanm: not the snd, but the snd of the score
19:46:56 <ivanm> sorry, I'm not following
19:47:12 <ivanm> :: Score -> Int ?
19:48:19 <carlosgaldino> ivanm: no. i want to total_score :: Tournament -> Int but i thought to get all of the Int from the Score structure into a list and sum them using sum
19:48:32 <ivanm> yes
19:48:38 <ivanm> I'm trying to help you work out how to do that ;-)
19:48:50 <ivanm> so, how can you go from [Score] to [Int] ?
19:49:02 <carlosgaldino> ivanm: i think it's using snd
19:49:10 <ivanm> close
19:49:17 <ivanm> Score -> Int is snd
19:49:25 <ivanm> now, how do you apply snd to every element of the list?
19:49:39 <carlosgaldino> ivanm: dont know
19:49:56 <ivanm> OK, do you know of any function that lets you apply another function to every element of a list?
19:50:43 <lispy> soduko: well if you really want to use lists, I think the haskell wiki has several versions of dotProduct, but I could be wrong
19:51:13 <carlosgaldino> ivanm: map, fold. is it right?
19:51:18 <ivanm> isn't dotProduct just sum . zipWith (*) ?
19:51:25 <ivanm> @type map
19:51:26 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:51:31 <ivanm> ^^ so yes, map
19:51:52 <ivanm> so, given a Tournament t, we can get all the scores from that tournament by doing "map snd t"
19:53:14 <carlosgaldino> ivanm: if i do total_score = sum map snd t. is it?
19:53:30 <ivanm> close
19:53:37 <ivanm> you need some parentheses
19:53:55 <ivanm> since the compiler will interpret you doing sum on map, which doens't make much sense
19:54:06 <ivanm> and you need to supply the argument to the function
19:54:13 <ivanm> so it's: total_score t = sum (map snd t)
19:55:30 <carlosgaldino> ivanm: oh. good. i tried here. see i cant figure this
19:55:43 <carlosgaldino> ivanm: i think but cant get close to a solution
19:55:43 <ivanm> sure you can
19:55:54 <ivanm> you need to group things properly
19:56:08 <ivanm> now, I highly suggest you go back through your lecture notes as lispy suggested before
19:56:40 <djahandarie> I don't think I've ever read my lecture notes after taking them, except when reviewing for a test or such
19:57:54 <carlosgaldino> ivanm: this is a problem. the lectures are not good
19:58:02 <ivanm> OK then
19:58:05 <ivanm> @where wikibook
19:58:05 <lambdabot> http://en.wikibooks.org/wiki/Haskell
19:58:07 <ivanm> @where LYAH
19:58:07 <lambdabot> http://www.learnyouahaskell.com/
19:58:10 <ivanm> @where YAHT
19:58:10 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
19:58:33 <ivanm> or else get a textbook: Craft of Functional Programming; Haskell School of Expression; Programming in Haskell; etc.
20:00:12 <ivanm> carlosgaldino: which uni do you go to that the lectures aren't any good?
20:00:23 <carlosgaldino> ivanm: it's brazilian
20:00:32 <carlosgaldino> ivanm: i don't think you'll know
20:01:03 <poly> So nowadays universities have classes to teach you Haskell. that's good ;)
20:05:50 <dobblego> poly, which university?
20:06:38 <poly> i don't know
20:06:56 <carlosgaldino_> the main problem is to get away from the traditional paradigm
20:07:03 <poly> it's in brazil according to caarlosgaldino
20:07:26 <aristid> poly: lots of universities seem to teach some haskell, much like they teach (or used to teach) prolog
20:07:40 <carlosgaldino_> poly: what are you talking about? i didn't receive the other messages
20:07:58 <poly> well, my university don't have such classes at least
20:08:15 <lispy> poly: I had a course on haskell in undergrad
20:08:21 <lispy> and then several in grad :)
20:08:51 <poly> my uni only have classes about scheme
20:09:00 <carlosgaldino_> lispy: what did you study?
20:09:04 <carlosgaldino_> lispy: cs?
20:09:08 <lispy> cs and math
20:09:43 <foolusion> $/quit
20:10:20 <poly> carlosgaldino_: I was talking about classes about haskell in universities
20:10:30 <carlosgaldino_> this class i'm taking is optative but you see that there's no interest because that's just a few students
20:10:42 <carlosgaldino_> poly: good
20:11:09 <\\LuCiFaGo999> algien habla espaol?????
20:11:36 <carlosgaldino_> i think could be at least one class for everyone. just to learn the paradigm. i intend to learn it. until the end o the year =)
20:11:46 <carlosgaldino_> \\LuCiFaGo999: yo puedo tentar
20:12:10 <\\LuCiFaGo999> de que hablan en este canal??? im lost
20:12:40 <carlosgaldino_> \\LuCiFaGo999: haskell, es una lenguaje de programacion
20:13:12 <poly> functional programming is best suited for me, I think
20:13:26 <poly> but don't like a lot of parens
20:13:36 <\\LuCiFaGo999> i from cd juarez chihuahua mexico   im locking for chanels
20:13:57 <djahandarie> \\LuCiFaGo999, if you want somewhere to chat try #defocus
20:14:04 <carlosgaldino_> \\LuCiFaGo999: que tipo?
20:14:21 <djahandarie> poly, avoid Lisp. :P
20:14:47 <\\LuCiFaGo999> here you are working or talking with students
20:14:49 <\\LuCiFaGo999> ???
20:14:54 <p_l> poly: for pure functional stuff, go Haskell
20:15:32 <poly> that's why Im here :)
20:15:34 <djahandarie> \\LuCiFaGo999, there are some student and teachers here. But really, anyone who is interested in Haskell (programming language) is in here
20:15:37 <p_l> poly: You won't get anywhere far concentrating narrowly on functional approach in lisp (not that's FP is bad or lisp is bad, it's just misrepresentation caused by history)
20:15:46 <carlosgaldino_> hey, you could also help me with another thing. tomorrow i have to tell the professor which kind of program my group will develop for the end of the semester. since we don't have many knowledge about it we can't think of some kind because we can't measure the difficulty
20:15:57 <p_l> carlosgaldino_: what course?
20:16:23 <carlosgaldino_> p_l: haskell course
20:16:31 <p_l> carlosgaldino_: anything more specific?
20:16:52 <carlosgaldino_> p_l: no. it's a class and we have to develop something in the end
20:17:07 <carlosgaldino_> p_l: tomorrow is the day to tell what we'll do
20:17:19 <carlosgaldino_> p_l: but we don't have a clue
20:17:21 <\\LuCiFaGo999> ok  guys   just  trie to know  irc  because im new
20:17:21 <djahandarie> carlosgaldino_, do you have any interests
20:17:21 <p_l> carlosgaldino_: what's the overall degree you're doing, and what you did before (classes etc)
20:17:32 <p_l> (to make up something based on it)
20:17:51 <p_l> also I'm trying to fish about your overall programming competency, outside of Haskell itself :)
20:18:44 <carlosgaldino_> p_l: i'm almost finishing my cs degree. i know java, ruby. i have developed some kind of programs on it. using OOP i think i'm good at it. but in haskell i really suck
20:19:17 <carlosgaldino_> djahandarie: anything. i wanna make something cool but not so hard because you saw. i suck in haskell
20:19:21 <\\LuCiFaGo999> see you guys bye bye
20:19:29 <carlosgaldino_> \\LuCiFaGo999: hasta la vista
20:19:50 <p_l> hmm
20:19:58 <djahandarie> carlosgaldino_, what do you think is cool? It's a lot easier to work on a project you have some interest in
20:20:06 <monochrom> you probably know how difficult a project is if you use java. just guesstimate that it is twice as difficult in haskll.
20:20:26 <\\LuCiFaGo999> carlosgaldino_: waths you project?????
20:20:41 <carlosgaldino_> \\LuCiFaGo999: i don't have yet
20:20:49 <p_l> carlosgaldino_: think a list of interesting, *singular* and not overly complex "things you'd like to make a program for"
20:20:59 <lispy> Programming in anything that you're just learning is hard
20:21:05 <djahandarie> \\LuCiFaGo999, this channel isn't really for chatting, for your knowledge
20:21:10 <lispy> But, once you know some Haskell I'd say it's easier than other languages
20:21:44 <p_l> it could be even something as simple as "an application to generate/update a local copy of my favourite web fiction series"
20:21:46 <carlosgaldino_> cool? something using the web but i think i'm too novice to start using snap
20:22:02 <\\LuCiFaGo999> carlosgaldino_:  creo que estoy molestando a djahandarie  me retiro
20:23:07 <carlosgaldino_> \\LuCiFaGo999: si. se habla de otros assuntos. aqui hay que hablar sobre el lenguaje haskell
20:24:11 <\\LuCiFaGo999> carlosgaldino_:  grasias por tu ayuda   yo estoy siempre en #frikipedia cuando necesites algo  byebye
20:31:12 <poly> Im thinking of writing a program that run like every 10min like daemon on redhat Linux
20:31:19 <poly> how can I do that?
20:31:29 <poly> with Haskell
20:32:07 <carlosgaldino_> hey, how can I go through all scores in the tournament and subtract one from every score and return the new tournament?
20:32:50 <djahandarie> poly, you can forkIO and use forever and threadDelay
20:32:52 <co_dh> fmap (-1) $ Tree Score
20:32:53 <BMeph> carlosgaldino_: "map pred"
20:33:14 <BMeph> carlosgaldino_: Oops, right - "fmap pred"
20:33:38 <poly> djahandarie: thanks for advice :)
20:33:52 <BrianHV> poly: is there a reason not to use cron to launch a haskell program?
20:34:16 <djahandarie> I think there is a better function than forever + threadDelay, though I forget the name
20:34:31 <Veinor> not (-1), (`subtract` 1)
20:34:56 <poly> BrianHV: you are right. cron is enough for my task but I just wanted to do with Haskell
20:35:15 <carlosgaldino_> BMeph: using this structure, is it possible? http://pastie.org/pastes/1121758
20:36:37 <blackdog> is there a debug mode for TH to get it to spit out what it would have generated?
20:37:41 <poly> djahandaries: So I should learn Concurrent Haskell libraries for that, right?
20:37:52 <co_dh> > (- 1 ) 3
20:37:53 <lambdabot>   -1
20:38:30 <Veinor> caleskell strikes again!
20:38:34 <djahandarie> poly, it isn't a seperate library, it is in the package base under the module Control.Concurrent
20:38:47 <djahandarie> co_dh, that did something else that what you were trying
20:38:49 <djahandarie> > 1 10
20:38:50 <lambdabot>   Ambiguous type variable `t' in the constraint:
20:38:50 <lambdabot>    `GHC.Num.Num t'
20:38:50 <lambdabot>      aris...
20:38:50 <co_dh> > ( `substract` 1 ) 3
20:38:51 <lambdabot>   Not in scope: `substract'
20:38:58 <djahandarie> > 1 10 :: Int
20:38:58 <lambdabot>   1
20:39:00 <djahandarie> That
20:39:03 <djahandarie> Is what it did
20:39:07 <Veinor> djahandarie: what's the point of that, anyway?
20:39:08 <lispy> overloaded whitespace!
20:39:18 <djahandarie> > ((+) + (*)) 19 20
20:39:18 <lambdabot>   419
20:39:23 <djahandarie> Veinor, that ^^
20:39:24 <co_dh> > ( ` subtract` 1 ) 5
20:39:25 <lambdabot>   -4
20:39:26 <Veinor> ...
20:39:28 <Veinor> D:
20:39:31 <djahandarie> Haha
20:39:41 <Veinor> why on earth would you do that
20:40:01 <lispy> the problem is a Num instance for (a -> b) or such
20:40:06 <djahandarie> Because you can!
20:40:07 <Veinor> yeah
20:40:13 <djahandarie> But yeah, the num instance makes things confusing sometimes
20:41:38 <co_dh> > 1 10
20:41:39 <lambdabot>   Ambiguous type variable `t' in the constraint:
20:41:39 <lambdabot>    `GHC.Num.Num t'
20:41:39 <lambdabot>      aris...
20:41:46 <co_dh> > 1 10 :: Int
20:41:47 <lambdabot>   1
20:42:23 <co_dh> why lambabot has different behavior as ghci on this line of code ? 1 10 :: Int 
20:42:23 <lispy> > 1 10 + 2 20 :: Int
20:42:24 <lambdabot>   3
20:42:38 <co_dh> :t ( ) 
20:42:39 <lambdabot> ()
20:42:42 <djahandarie> co_dh, no good reason.
20:42:47 <lispy> co_dh: Because there is an instance of Num for functions that is defined in lambdabot but not in your ghci
20:43:06 <BMeph> carlosgaldino_: Using that structure, it's (almost) mandatory. It is mandatory that it works, just not mandatory that you do it that way. You could do things with a for loop, if you really feel the need to complicate it up... ;)
20:43:08 <co_dh> :i Num
20:43:15 <lispy> co_dh: and when functions are treated as numbers, numeric literals are like constant functions that return their value
20:43:16 <carlosgaldino_> i'm sure there's a cleaner way to do this. can you tell me? http://pastie.org/1121837
20:43:37 <co_dh> lispy: thanks.
20:43:49 <dobblego> carlosgaldino_, you want the map function
20:43:50 <co_dh> @src 5 :: (Num -> Num)
20:43:50 <lambdabot> Source not found. Maybe you made a typo?
20:43:54 <lispy> > 1 undefined :: Int
20:43:55 <lambdabot>   1
20:43:59 <lispy> > const 1 undefined
20:44:00 <lambdabot>   1
20:44:04 <lispy> co_dh: ^^
20:44:47 <dobblego> apito_dourado = map (\(x, y) -> (x, y - 1)) 
20:45:15 <dobblego> apito_dourado = map (second (`subtract` 1)) -- import Control.Arrow 
20:45:19 <carlosgaldino_> dobblego: why is there '\'?
20:45:32 <jmcarthur> > subtract 1 5
20:45:33 <lambdabot>   4
20:45:40 <jmcarthur> > pred 5
20:45:41 <lambdabot>   4
20:45:55 <dobblego> carlosgaldino_, it denotes a lambda symbol for a lambda expression
20:46:12 <BMeph> carlosgaldino_: Have you heard of the phrase, "anonymous function"?
20:46:14 <jmcarthur> :t map $ second pred
20:46:15 <lambdabot> forall b d. (Enum b) => [(d, b)] -> [(d, b)]
20:46:55 <Veinor> instance (Num a, Monad m, Eq (m a), Show (m a), Functor m) => Num (m a) where
20:47:05 <Veinor> bets on how many language extensions it takes for this to be valid?
20:47:14 <carlosgaldino_> just heard of but never got a good explanation. tomorrow will be the third class about haskell.
20:47:17 <jmcarthur> OverlappingInstances
20:47:25 <jmcarthur> Veinor: the Functor constraint is redundant
20:47:28 <lispy> Veinor: flexible instances
20:47:50 <Veinor> jmcarthur: I know but fmap wants it
20:47:56 <jmcarthur> Veinor: just use liftM
20:47:59 <Veinor> true
20:48:09 <lispy> and what fmap wants, fmap gets
20:48:10 <BMeph> carlosgaldino_: Well, you know what "anonymous" means, right?
20:48:17 <carlosgaldino_> BMeph: yeah
20:49:04 <BMeph> carlosgaldino_: Well, there you go - an "anonymous function" is...a function that's anonymous! ;)
20:49:26 <Veinor> it turns out I need FlexibleInstances, FlexibleContexts, and UndecidableInstances
20:49:32 <lispy> BMeph: but it's anonymous why do some of them have names, like s k i?
20:49:43 <carlosgaldino_> BMeph: i got it. and we have to use the slash to denote it
20:49:46 <co_dh> (fmap.fmap) ((,) ptr) (deRefWeak ptr)
20:49:54 <co_dh> cool but hard to understand .
20:49:56 <lispy> Veinor: why do you need FlexibleContexts?
20:50:07 <carlosgaldino_> BMeph: but there's another way to do what i did without using this approach?
20:50:22 <carlosgaldino_> BMeph: since my professor didn't teach us about this
20:50:33 <lispy> Veinor: I don't tihnk you need it for the instance.  But you might need it to use the instance
20:50:58 <Veinor> yeah, I need it to use it
20:51:15 <BMeph> carlosgaldino_: It's just a way to specify a function when you don't really care to give it a name (like when you need to use a function, and it's easy to say what it's supposed to do, and you're just going to use that function once, so giving it a name feels like too much work.
20:51:32 <monochrom> you can write "(\x -> blah) y" or you can write "let f x = blah in f y"
20:52:32 <Veinor> actually, no I don't need it at all. huh.
20:53:15 <Veinor> oh, now I know why I had it in there
20:53:30 <Veinor> I had Eq m a, which requires FlexibleContexts, then I realized that that's not what I want
20:53:36 <carlosgaldino_> ok
20:53:39 <carlosgaldino_> thank you
20:53:46 <carlosgaldino_> i'll try to do the other exercises
20:55:09 <Veinor> > show succ
20:55:10 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
20:55:11 <lambdabot>    arising from a use of `...
20:55:25 <BMeph> carlosgaldino_: Haskell is kind of like a real-life Matrix, where the toughest thing to learn is that (sometimes) what you want to do isn't tough. :)
20:56:24 <Veinor> what do I have to pull in to get the monad instance for ((->) a)?
20:56:38 <carlosgaldino_> BMeph: hahaha. great definition
20:56:39 <luite> Control.Monad.Instances
20:57:10 <carlosgaldino_> BMeph: but i feel i get the solution but i can't understand how and why i made it that way
20:57:14 <BMeph> Oh, yeah -- is there a general name for the type of an action, or do we call both the types and the values "actions" and make it clear through context?
20:57:51 <carlosgaldino_> BMeph: are you talking with me?
20:58:30 <BMeph> carlosgaldino_: I'm paying attention, but my last message was a question for the channel. :)
20:58:41 <carlosgaldino_> BMeph: ok.
21:00:00 <djahandarie> BMeph, I've actually had that question as well... I consider anything that is a recipe that can be "run" an action
21:00:14 <djahandarie> Not sure if that is correct
21:00:27 <monochrom> the type is "a monad". the action is "an action".
21:00:50 <BMeph> carlosgaldino_: But, yes, after some time using it, you get a taste for the "descriptive" way that Haskell works. Then, you start to resent other languages that make you spell out each step that you know you could just "describe" with a couple of lines of Haskell...then you'll know that you've become a Haskell initiate. :)
21:00:55 <monochrom> "Maybe is a monad. Nothing is an action"
21:01:09 <djahandarie> Eh, is that really how it is defined?
21:01:18 <djahandarie> That seems inconsistant with other usages I've heard
21:01:30 <BMeph> monochrom: Right. But, what is Maybe a? Besides a type, that is.
21:01:46 <monochrom> my correct usage is necessarily inconsistent with incorrect usages. I'm sorry for that.
21:02:08 <djahandarie> monochrom, as most people would say about anything they believe. :P
21:02:15 <monochrom> alright, I don't know of a name for things like "Maybe a".
21:02:27 <BMeph> djahandarie: No, that's correct. That particularly is what mjd's article yesterday (or was it Wednesday?) way about.
21:02:36 * djahandarie looks
21:03:03 <BMeph> djahandarie: It just popped up on reddit, so it's easy to find. :)
21:03:10 <djahandarie> Yeah I'm reading it atm
21:03:24 <monochrom> reddit proves me right? impossible. inconsistent with... XD
21:03:47 <BMeph> djahandarie: Where by "just" I mean "sometime today, or yesterday, depending on your timezone"
21:03:49 <carlosgaldino_> BMeph: i expect to become this quickly
21:03:53 <carlosgaldino_> =)
21:05:01 <carlosgaldino_> how can i apply a function to specific elements in a list but returning that list with the modifications made to the elements that satisfied the predicate
21:05:22 <BMeph> carlosgaldino_: It does. The next trick is getting to Apprentice level, where you start feeling comfortable with manipulating types to get your answer right. 
21:05:31 <monochrom> what should happen to those dissatisfying the predicate?
21:05:54 <BMeph> carlosgaldino_: ...yes, what monochrom asked. :)
21:06:07 <djahandarie> BMeph, he doesn't seem to define action in that
21:06:39 <djahandarie> I think there can be motes which aren't actions
21:06:44 <djahandarie> As well as actions that are not motes
21:06:53 <BMeph> djahandarie: No, because he's advocating the use of "mote" for it.
21:06:54 <monochrom> what is mote?
21:07:03 <djahandarie> monochrom, monadic value
21:07:19 <djahandarie> monochrom, coined in the article I just read
21:07:20 <monochrom> I don't mind using the word mote instead, to tell you the truth.
21:07:26 <BMeph> monochrom: By my understanding, a "mote" is mjd's name for an action.
21:07:40 <carlosgaldino_> nothing. i have the tournament and i want to update it. so i pass the tournament and a match result, so i update with 3 more points to the winning team o 1 point for both if no one wins
21:07:47 <djahandarie> I've heard action be used much more general than "monadic action"/"mote"
21:08:19 <djahandarie> Really anything that can be combined up and evaluated with a function
21:09:02 <monochrom> > let f x = if odd x then x else x+1 in map f [3,1,4,1,5,9,2,6,5,3]
21:09:03 <lambdabot>   [3,1,5,1,5,9,3,7,5,3]
21:09:42 <BMeph> carlosgaldino: That's where things get complicated. Since (almost) all values are immutable, it's tough to do that kind of transformation cleanly in Haskell.
21:09:57 <djahandarie> More specifically something that can't be represented entirely without that function being run
21:10:55 <BMeph> djahandarie: I'd say "shouldn't" rather than "can't", especially with the likes of 'vacuum' around. :)
21:11:14 <djahandarie> Heh, yes maybe that'd be better
21:11:29 <djahandarie> Anyways I'm not trying to define it on the spot, that just seems to be how I've heard it used
21:11:32 <BMeph> carlosgaldino: ...and then monochrom goes and shows how slow I am. :)
21:12:14 <carlosgaldino> but the structure is [("char", 3), ("another", 5)]
21:12:18 <monochrom> well, we keep saying "change" but we just mean "build a new one".
21:12:41 <monochrom> I so want to change my computer!
21:12:53 <djahandarie> That was probably not a good example monochrom :P
21:12:59 <djahandarie> Since a computer is fairly mutable
21:13:21 <carlosgaldino> i want to do: update list [("char", 5), ("another", 3)] so the result would be [("char", 6), ("another", 5)]
21:13:43 <carlosgaldino> because the winner receives 3 points for the win
21:14:00 <monochrom> Imagine that from the mouth of someone known to never tinkle computer internals.
21:14:16 <monochrom> "I want to replace my car!"
21:14:31 <BMeph> djahandarie: Well, for things like lists and Maybe, the rep. is so easy that there isn't too much of a problem 'show'ing it directly, whereas other types get complicated, depending on what the Monad represents
21:15:15 <djahandarie> BMeph, I would call a State mote an action
21:15:25 <djahandarie> Same with an IO mote
21:15:48 <lispy> ?hoogle mote
21:15:49 <lambdabot> Foreign.C.Error eREMOTE :: Errno
21:15:49 <lambdabot> Foreign.C.Error eRREMOTE :: Errno
21:15:49 <lambdabot> Test.QuickCheck promote :: (a -> Gen b) -> Gen (a -> b)
21:16:00 <djahandarie> lispy, mote == monadic value
21:16:09 <lispy> huh, never heard that before
21:16:14 <djahandarie> Just invented like yesterday
21:16:19 <lispy> :(
21:16:26 <djahandarie> Keep up ;)
21:16:32 <lispy> mote already has a definition
21:16:42 <djahandarie> Blame yrlnry 
21:16:59 <BMeph> djahandarie: Right. Some folks (Cale and edwardk especially), use "action" in a deliberately general way for any "monadic value", not just the ones that represent a stateful transaction.
21:17:01 <monochrom> an international survey shows that interest in reddit has been declining since 2009 :)
21:17:29 <djahandarie> monochrom, does it also show where that interest has been going?
21:17:43 <monochrom> no :)
21:17:46 <lispy> a mote is a small particle
21:18:19 <lispy> http://www.merriam-webster.com/dictionary/mote?show=1&t=1282969030
21:18:22 <BMeph> My guess is FB, especially zynga games... <eyeroll/>
21:18:29 <blackdog> lispy: as in " ... in god's eye", no?
21:18:34 <djahandarie> BMeph, hm, I don't fully see why you would do tha
21:18:36 <djahandarie> that*
21:18:47 <monochrom> @wn mote
21:18:48 <lambdabot> *** "mote" wn "WordNet (r) 2.0"
21:18:48 <lambdabot> mote
21:18:48 <lambdabot>      n : (nontechnical usage) a tiny piece of anything [syn: {atom},
21:18:48 <lambdabot>          {molecule}, {particle}, {corpuscle}, {speck}]
21:18:54 <monochrom> heh
21:18:56 <carlosgaldino> how can i translate this to haskell? http://pastie.org/1121868
21:18:58 <blackdog> i imagine that's the idea, though - it's the small piece that's manipulated, rather than the overarching structure
21:19:45 <lispy> so if we said, monadic mote, it would sound better to me
21:19:50 <djahandarie> carlosgaldino, looks like a fold
21:19:57 <BMeph> djahandarie: Why you would use the same name for any monadic value, as opposed to using it only for ones that are difficult to/barred from display?
21:20:13 <djahandarie> lispy, the whole point was for a one syllable word
21:20:37 <djahandarie> BMeph, an "action" isn't representable in real life
21:20:47 <djahandarie> I was taking the analog of that in Haskell world
21:20:52 <lispy> djahandarie: value was too long?
21:20:59 <monochrom> perhaps lispy's point is that one syllable is not enough. :)
21:21:35 <djahandarie> I don't see why not
21:21:37 <blackdog> i think mjd's more concerned with human affordances.
21:21:38 <lispy> Why not call it pizza, or dog, or table, or some other word that already has an established meaning?
21:21:47 <blackdog> mote's relatively uncommon.
21:22:00 <djahandarie> I've sure never heard it used before
21:22:12 <djahandarie> lispy, http://blog.plover.com/prog/haskell/monad-terminology.html
21:22:13 <monochrom> mote is one of those other words that already has an established meaning :)
21:22:23 <blackdog> and it's short. "hash" had a real meaning, and even had a precise CS meaning, but it's been a success over terms like "associative array"
21:23:19 <lispy> I think mobit is a much better choice
21:23:46 <djahandarie> @wn mobit
21:23:46 <lambdabot> No match for "mobit".
21:24:07 <djahandarie> Hmm
21:24:18 <djahandarie> Just because no conflict with an existing word in English?
21:24:35 <BMeph> Ooh, I HATE "mobit". Besides, it's a two-syllable neologism. Two syllables are so tl;dr... :
21:25:05 <lispy> tl;dr?
21:25:17 <djahandarie> Too long; didn't read.
21:25:17 <monochrom> yeah, "tl;dr" has 0 syllables and therefore so much better
21:25:33 <blackdog> i pronounce 'tl;dr' as 'meh'
21:25:38 <djahandarie> Haha
21:25:44 <monochrom> 1 syllable is too much
21:26:07 <blackdog> concision is good. therefore, by induction we should shut up.
21:26:08 <monochrom> Behold: YHWH BBQ tl;dr
21:26:13 <lispy> My name is on that guys blog a whole bunch of times
21:26:17 <lispy> creepy
21:26:30 <BMeph> I'm going to start actively calling it a vrashch. Or rather, "". ;
21:26:45 <djahandarie> Anyways, my current standpoint is: "Monadic value" is too long and I haven't used it / won't use it in the future because of that. I'd like an alternative.
21:26:48 <blackdog> lispy: who are you IRL?
21:26:53 <djahandarie> He proposed one so I was just going to go with that.
21:27:02 <lispy> blackdog: that's a good question.  I ask myself that everyday.
21:27:14 <monochrom> haha
21:27:17 <carlosgaldino> djahandarie: but how can i combine all of that operations to fold?
21:27:24 <lispy> blackdog: my name is Jason Dagit, and the LHS column on that blog says, JASOND a bunch of times
21:27:28 <BMeph> blackdog: He's LISPY! World-famous, and Internationally Known! ;)
21:28:08 <djahandarie> carlosgaldino, you don't need to use a fold. It can be a map (which manipulates the values in a list) then the sum (which folds the list into one value via addition). 
21:28:49 <blackdog> oh, you're jason dagit! heh. i had two completely separate boxes in my head for you.
21:29:00 <lispy> BMeph: I'm only internationally known because I was giving out business cards in Canada though ;)
21:29:04 <blackdog> by the pigeonhole principle, i now have one fewer pigeon.
21:29:10 * monochrom hands a union-find to blackdog
21:29:11 <djahandarie> carlosgaldino, if you want, you can rewrite your C into two for loops -- one that creates you a new list, and another that combines that new list into a value
21:29:23 <djahandarie> That'd be closer to the eventual Haskell translation
21:30:20 <lispy> blackdog: Heh.  Oh, the lispy hole and the jasond hole?
21:30:29 <blackdog> lispy: indeed
21:30:39 <lispy> Yeah. I should possibly change my nick to something more incriminating...but too much inertia
21:30:51 <dankna> co-brand yourself
21:30:54 <dankna> call yourself lispy-jasond
21:30:57 <BMeph> lispy: Well, I live about seven miles from the US-Mexico border, not to mention our high Aussie population, so get used to international fame... ;)
21:30:59 <blackdog> gah, every time i look at that article the error in the second last line jumps out at me.
21:30:59 <monochrom> schemy
21:31:25 <djahandarie> That's how I read lispy's name always as well monochrom 
21:32:03 <emilio> Could someone please explain this syntax to me? newtype GenEnv elt = Env (Map Id elt)
21:32:23 <copumpkin> would you understand data GenEnv elt = Env (Map Id elt)
21:32:23 <copumpkin> ?
21:32:28 <lispy> or haskelly
21:32:37 <lispy> I used lispy|dagit for a while
21:32:38 <djahandarie> lispy, that wouldn't be as scheming
21:32:42 <BMeph> lispy: I like '"lispy" Dagit', it reminds me of the tenor of "Lemony Snicket"... ;)
21:32:49 <emilio> Nah, I'm not really sure what the elt refers to
21:32:56 <emilio> like, an element of something
21:32:57 <TTUser> hi
21:33:01 <copumpkin> emilio: it just means the type is parametrized by that
21:33:04 <emilio> Is it just some generic type
21:33:07 <copumpkin> you can have GenEnv Int
21:33:14 <copumpkin> and that would contain a Map Id Int
21:33:23 <TTUser> Id Td Uc
21:33:25 <copumpkin> emilio: think of it as a collection of types
21:33:26 * BMeph goes back to reading "Lispy Dagit and the Series of Unfortunate Coding Incidents"...
21:33:29 <emilio> Right, so essentially the type can be whatever in this case?
21:33:32 <lispy> heh
21:33:34 <copumpkin> emilio: yep
21:33:39 <TTUser> k
21:33:41 <copumpkin> TTUser: yes?
21:33:44 <TTUser> k
21:33:45 <emilio> Sort of like how generics work in OO languages?
21:33:57 <copumpkin> TTUser: do you have a question?
21:34:02 <monochrom> If you understand "GenEnv a" then you understand "GenEnv elt".
21:34:08 <djahandarie> emilio, it's called a type variable btw
21:34:13 <TTUser> no question
21:34:15 <TTUser> yet
21:34:20 <copumpkin> ok :)
21:34:22 <copumpkin> let us know
21:34:26 <TTUser> k
21:34:36 * BMeph wonders when "arcy" will stumble by...
21:34:46 <emilio> So if there's a function like this
21:34:46 <emilio> union  :: GenEnv elt -> (Id,elt) -> GenEnv elt
21:34:55 <lispy> BMeph: heh, that just sounds arsey
21:35:02 <copumpkin> emilio: just means that it works for all values of elt
21:35:04 <emilio> I can pass anything as elt, as long as it's consistently the same type?
21:35:06 <copumpkin> yeah
21:35:18 <emilio> I see, that's cool
21:35:27 <copumpkin> parametric polymorphism!
21:35:35 <emilio> And do I ever need to explicitly specify the type? like in c# you would use line
21:35:37 <emilio> like*
21:35:42 <emilio> method<myType>(foo);
21:35:47 <monochrom> Only sometimes.
21:35:50 <copumpkin> emilio: nope, it'll get inferred for you msot of the time
21:36:01 <copumpkin> emilio: sometimes you'll want to nudge it in the right direction, but most of the time it gets it right
21:36:09 <emilio> Sweet, sorry for the noob questions, I'm doing an assignment ;)
21:36:34 <monochrom> isn't haskell exciting
21:36:56 <copumpkin> emilio: no problem :) we love the language and hope to get other people loving it too
21:36:58 <lispy> Is Haskell still cutting edge?
21:37:03 <copumpkin> emilio: I was asking similar questions a couple of years ago :P
21:37:12 <copumpkin> and look what they did to me!
21:37:18 <TTUser> night all
21:37:18 <monochrom> haskell is no longer cutting edge
21:37:19 <BMeph> monochrom: I'd've used the word 'inciting', but sure, your word works too. ;)
21:37:30 <monochrom> hrm, inciting...
21:37:33 <monochrom> @wn incite
21:37:33 <lambdabot> *** "incite" wn "WordNet (r) 2.0"
21:37:34 <lambdabot> incite
21:37:34 <lambdabot>      v 1: give an incentive for action; "This moved me to sacrifice my
21:37:34 <lambdabot>           career" [syn: {motivate}, {actuate}, {propel}, {move}, {prompt}]
21:37:34 <lambdabot>      2: provoke or stir up; "incite a riot"; "set off great unrest
21:37:35 <lambdabot> [4 @more lines]
21:38:00 <monochrom> hrm, an incentive for ACTION!
21:38:09 <monochrom> what is the noun for incite?
21:38:14 <lispy> monochrom: we need a one syllable word for "not quite cutting edge anymore but still exciting, Haskell."  how about, mauve?
21:39:41 <blackdog> been thinking a bit about 'autotest', the ruby program. basic idea is that you have a watcher on the filesystem that sees when code files and tests are changed, and it has some (convention-based) method for mapping what tests are affected by which code.
21:40:00 * monochrom wonders about "incitant" as "monadic value"
21:40:12 <blackdog> so you change a test, and you get instant feedback on whether it's working - change a chunk of code, and the tests affected by it run
21:40:33 <blackdog> thinking it'd be kind of nice to have in Haskell too - any reasons it couldn't possibly work well?
21:40:44 <ljungk> I've made a new type, and I want to be able to pattern match on it in a list comprehension. What is needed, do I need to make it an instance of Monad?
21:40:53 * blackdog is possibly well into yak-shaving territory.
21:40:54 <djahandarie> I'd like Cale or edwardk to comment on how they define "action"
21:40:55 <monochrom> a monadic value is a "recipe for actions". it may be reasonably an "incitant".
21:41:25 <djahandarie> It's a recipe for actions now? Oh god
21:41:28 * djahandarie is so confused
21:42:09 <trounce> hello all, wondering if there is anything interesting in the graphical department that has the source code available, maybe a screensaver or some such thing, anything I could perhaps wrap my head around
21:42:17 <trounce> suggestions?
21:42:22 <monochrom> If kmc is around, he'll tell you about recipes.
21:42:48 <djahandarie> I've heard all these words used by people in this channel, but only ever loosely with no defintion
21:42:52 <djahandarie> definition*
21:43:24 <monochrom> they are as well-defined as "monad", and rightfully so. you're deeply in ad-hoc-polymorphic territory.
21:44:10 <trounce> where might one go to find haskell source of any kind if I may ask
21:44:11 <djahandarie> monad as in a monadic value, or the typeclass Monad, or "a monad" like State?
21:44:24 <monochrom> as in the typeclass Monad.
21:44:57 <monochrom> you know, like "what does monad mean?", and you can only say, "like computation", or give axioms.
21:45:14 <monochrom> or make people hungry
21:45:18 <djahandarie> Eh
21:45:20 <trounce> what is the meaning of fnord
21:45:30 <djahandarie> I don't see how those words are interchangable with Monad
21:45:35 <djahandarie> They definitely don't seem to be
21:45:47 <trounce> fnord is much like monad
21:45:53 <monochrom> no, not claiming interchangeable.
21:46:09 <djahandarie> Because Monad isn't an action or recipie in any sense, it's just a typeclass
21:46:15 <monochrom> (as well-defined as) /= (interchangeable)
21:46:23 <emilio> Ok I think I got it sorted now, thanks for the help!
21:46:29 <djahandarie> Ahhh
21:46:34 <djahandarie> Totally misinterpted you
21:47:08 <djahandarie> So don't you think looking for some answers is the right thing to do?
21:47:09 <monochrom> But there are algorithmic transformations between definitions of those words.
21:47:32 <trounce> someone make a haskell chatbot that replaces every instance of monad with fnord
21:48:06 <monochrom> I already know the answers.
21:48:32 <djahandarie> monochrom, it sounded like there were no answers
21:49:40 <trounce> I still dont know what a monad is
21:50:12 <monochrom> Some audience does not find definitions useful (despite how much they cry for definitions). They benefit more from rough ideas. So you use suggestive words.
21:50:35 <djahandarie> monochrom, perhaps the problem is that we are interchanging suggestive words and defined terms?
21:50:37 <monochrom> For those who can use definitions, there are the axioms, end of story.
21:51:03 <monochrom> No, the problem is that the audience doesn't know themselves.
21:51:13 <djahandarie> I mean when the audience knows the monad laws.
21:51:22 <djahandarie> And they wish to talk about the usage of monads in Haskell.
21:51:31 <djahandarie> E.g., "monadic value"
21:51:44 <trounce> or understand how IO works, or get command structure, or understand how or why to use variables
21:51:59 <djahandarie> trounce, have you tried out some of the tutorials out there?
21:52:06 <djahandarie> @where lyah
21:52:06 <lambdabot> http://www.learnyouahaskell.com/
21:52:14 <trounce> but no worries I have plenty of material yet to go through
21:52:21 <djahandarie> That one just got a new chapter about monads if you have read the earlier channels
21:53:01 <trounce> there are a few gaps in my understanding that are preventing me from moving forward
21:53:19 <trounce> basically control structure
21:53:42 <trounce> like how do you do a main loop?
21:53:51 <emilio> http://pastebin.org/791717 <- Gives a parse error on the LetVal Eq comparison line, but as far as I can see it;s the same as the others, what have I done wrong there?
21:53:56 <trounce> if you are doing graphical stuff how do you keep track of state?
21:54:01 <monochrom> if you denounce control structure, you may make much progress. you will rediscover control structure later.
21:54:03 <trounce> it all seems very obtuse
21:54:13 <luite> a main loop could be as simple as: forever f
21:54:17 <luite> where f :: IO () 
21:54:32 <djahandarie> trounce, focus more on defining your problem rather than attempting to define exactly how the computer solves it
21:54:52 <djahandarie> If you have a specific problem I can show you how I would tackle it
21:55:15 <trounce> I just need to know things like how do you trigger calculations to happen
21:55:21 <roconnor> @wiki IO_Semantics
21:55:21 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
21:55:23 <trounce> what do you do to get things to do stuff
21:55:29 <djahandarie> trounce, main gets called and everything from then on follows.
21:55:46 <monochrom> "main = print (f x)" triggers (f x) to happen.
21:56:07 <roconnor> calculations happens when the runtime systems tries to figureout the next system call to make
21:56:08 <BMeph> djahandarie: ! ;
21:56:29 <djahandarie> trounce, or more specifically, when you compile, your whole program gets evaluated/reduced down to a single "recipe" or "action" which will then be executed by the Haskell run time system when you run the program.
21:56:30 <trounce> what about mouse clicks and stuffs like that
21:56:41 <roconnor> system calls
21:56:46 <monochrom> tee hee hee!
21:56:56 <roconnor> or call backs
21:57:11 * roconnor ponders that
21:57:34 <BMeph> Main is a . :)
21:57:51 <monochrom> imo you are really jumping too far ahead if you worry about mouse clicks now
21:58:14 <djahandarie> BMeph, I don't know cyrillic so this is going over my head.
21:58:16 <monochrom> But if you insist, you just need to know IO
21:58:20 <trounce> I need tu understand things on a very low level to even get started
21:58:29 <djahandarie> trounce, you're tackling it from the wrong angle.
21:58:57 <djahandarie> It's nice to have a grasp on how it works on the lower level, but that is never how you solve a problem in Haskell
21:59:17 <djahandarie> You don't think of the ASM that will be produced and then say "I wonder what Haskell code will get to this."
21:59:18 <monochrom> OK, let's start with the quantum mechanics of semiconductors...
21:59:20 <luite> trounce: try to start with something simple, for example, make a rpn calculator
21:59:50 <trounce> like ok, a mouse click should trigger a series of actions, what is the protocall from the kernel picking up a signal to entering into a functional bit with the IO collected
22:00:08 <trounce> can someone explain it on a machine and code lever at the same time?
22:00:16 <trounce> level*
22:00:31 <blackdog> trounce: Don wrote a paper about the design of XMonad - it's a pretty good explanation of how you write pure, functional code that nonetheless does real, significant IO
22:00:54 <djahandarie> blackdog, he probably isn't familiar enough to digest that paper
22:01:15 <djahandarie> trounce, is there some blockade that you have with the existing tutorials (which are imo a good approach to Haskell)?
22:01:18 <blackdog> djahandarie: reckon? I thought it was very readable.
22:01:29 <djahandarie> blackdog, it is, but he seems to just be starting out
22:01:39 <trounce> yes, a basic understanding of control flow and structure
22:01:40 <blackdog> some people like immersion :)
22:01:56 <roconnor> is trounce trolling?
22:02:00 <monochrom> Because of fortunate energy levels of electron orbitals of those semiconducting elements, when you have a lot of such atoms together, you get many many energy levels with very small steps in-between. They look like a continuous interval. So electrons can almost freely move inside the interval to any point.
22:02:08 <monochrom> (Is that low-level enough?)
22:02:11 <blackdog> anyway, http://www.cse.unsw.edu.au/~dons/talks/xmonad-hw07.pdf is the one i meant.
22:02:20 <djahandarie> trounce, do you have a specific example of something you can't understand?
22:02:28 <monochrom> (Maybe I should begin with hadrons, leptons, and gluons...)
22:02:36 <luite> monochrom: wait a minute, I don't like the abstraction of electrons
22:02:39 <luite> hehe
22:02:46 <blackdog> oh, wait, i meant the paper, not the talk. oop.s
22:02:46 <monochrom> Figured. :)
22:03:03 <roconnor> monochrom: I'm running my laptop on falling sand
22:03:32 <roconnor> Computing like it is 19100
22:03:42 <trounce> yes, I want a function to trigger on a bit of IO, what do i do to set up a listener for said IO action
22:03:52 <monochrom> Yeah, I remember that falling-sand device on the screen of Windows 3.1
22:04:15 <djahandarie> trounce, what tutorial started out like that?
22:04:33 <trounce> it seems like an important thing to know is all
22:04:34 <roconnor> trounce: how do you do it in C?
22:04:47 <trounce> I dont know c well enough
22:04:57 <trounce> haskel is more or less my first language
22:05:12 <roconnor> I'm pretty sure that trounce is trolling.
22:05:40 <trounce> its a serious enough question!
22:05:42 <blackdog> roconnor: so if he's trolling, be polite and helpful.
22:05:43 <djahandarie> trounce, it is, but you don't always gain knowledge of something by jumping straight into it
22:05:57 <trounce> do you just ask it to ceck as often as it is allowed to?
22:06:04 <monochrom> roconnor has been polite and helpful.
22:06:18 <blackdog> monochrom: certainly. didn't mean to imply otherwise.
22:06:42 <trounce> do checks eat up pocessor cycles?
22:06:46 <luite> trounce: you typically use blocking IO in haskell, which is efficient since the threads used for that are lightweight
22:06:51 <trounce> how do you optimise how often it checks
22:07:01 <trounce> these are serious gaps in my understanding
22:07:09 <djahandarie> trounce, you're basically going to get a lot of confusing answers if you start at this angle
22:07:20 <djahandarie> trounce, can I ask what your background is? Electrical engineering or something?
22:07:21 <trounce> what is blocking IO
22:07:31 <trounce> I have no background
22:07:38 <luite> trounce: the opposite of non-blocking IO ;p
22:07:41 <trounce> my background is wanting to understand
22:07:42 <djahandarie> trounce, how do you know what processor cycles are, etc?
22:07:59 <trounce> because I understand what a processor is and what it does
22:08:06 <trounce> better than most people anyway
22:08:16 <djahandarie> Right, did you just read the wiki on it or something or did you study in school
22:08:26 <trounce> although I have yet to learn x86 assembly
22:08:47 <djahandarie> If that is how you want to approach programming then ASM is a great place to start
22:08:48 <trounce> im too smart for school 8|
22:08:51 <luite> what exactly the processor does, doesn't really matter when learning haskell
22:08:55 <trounce> are you guys done trolling me yet?
22:09:05 <teratorn> x86 assembly is rewarding and fun
22:09:07 <djahandarie> trounce, I've been trying to help
22:09:09 <luite> trounce: you need to learn category theory first by the way
22:09:24 <teratorn> if you use it to crack evil copy protections and DRMs
22:09:27 <monochrom> djahandarie is sincere.
22:09:31 <luite> otherwise it's impossible to understand haskell
22:09:41 <blackdog> luite: funny, but be nice:)
22:09:52 <luite> bah if he trolls I can too ;p
22:10:16 <djahandarie> luite, multiple that a couple times and you get 4chan
22:10:17 <blackdog> you're a haskeller, you should have attained zen enlightenment:)
22:10:17 <lispy> My momma always says, Troll is as troll does.
22:10:22 <trounce> ok I have a few wikis to read
22:10:25 <trounce> I'll be back
22:10:44 <lispy> trounce: you might want to study operating systems actually
22:10:54 <lispy> trounce: because then you'll understand how blocking IO works
22:11:17 <JoeyA> Hmm, is it actually possible to troll a single person?
22:11:30 <JoeyA> I thought trolling was a one-to-many type of thing.
22:11:35 <roconnor> Actually how do mouse clicks work?
22:11:54 <roconnor> does an interupt fire causing a context switch to a kernel function?
22:11:59 <luite> djahandarie: hmm, that's a bad outlook, thanks for the warning ;)
22:12:14 <roconnor> which sets a semephore in some userspace land?
22:12:31 <lispy> roconnor: first the mouse monad creates a click mote.  Then that mobit goes through the mouse arrow and eventually gets into the input functor.
22:12:31 <trounce> I tied to learn BSD
22:12:39 <trounce> I gave up for the time being
22:12:40 <roconnor> lispy: oh
22:12:54 <JoeyA> Is there a way to tell how much memory is used by GHCi?
22:13:09 <lispy> JoeyA: by GHCI?  Hm...not sure
22:13:11 <JoeyA> (not against the system, but by objects)
22:13:14 <dankna> no, actually, I'm fairly sure that DMA writes USB events directly into memory and the kernel notices them by polling the next time it happens to already be in kernel mode
22:13:17 <JoeyA> err, let me clarify
22:13:21 <dankna> modern OS architectures try to avoid context switches
22:13:27 <roconnor> dankna: really?
22:13:27 <JoeyA> I just dumped a bunch of data into memory on GHCi
22:13:33 <JoeyA> top says it's using 1.2g
22:13:34 <lispy> roconnor: I think dankna is right
22:13:37 <roconnor> dankna: ya, I though context switches sounds heavy
22:13:56 <JoeyA> However, from watching top, the heap is expanded in big chunks at a time.
22:14:02 <roconnor> dankna: events are lost if the kernel doesn't poll often enough?
22:14:17 <monochrom> interrupt would have happened with ps/2 and serial mouse. usb is rightfully different.
22:14:19 <lispy> JoeyA: ah, well the expanding is the GC requesting more memory from the OS
22:14:20 <dankna> probably, yes
22:14:21 <JoeyA> It went from about 630m to 1.2g in an instant
22:14:25 <luite> lispy: but if my mouse pointer isn't an arrow, does it still goes throug the mouse arrow?
22:14:25 <JoeyA> Right
22:14:31 <lispy> JoeyA: it only does this when it needs more space for allocating things and it can't free up enough
22:14:33 <roconnor> monochrom: my age is betrayed
22:14:37 <JoeyA> So I wonder if there's a way to count the amount of space used?
22:14:45 <JoeyA> As in, how much more can be allocated before another heap expansion?
22:14:48 <monochrom> but either way eventually something is added to an event queue.
22:15:02 <dankna> yeah, once the event makes it to userspace the tricky part is over
22:15:59 <roconnor> scary that events could be missed
22:16:34 <JoeyA> Perhaps there's something in GHC.*
22:16:58 <dankna> the system would have to be awfully overloaded for things to be missed, I would think
22:18:33 <JoeyA> I guess one way to do it would be to spam 1MB ByteStrings until I get another heap expansion.
22:18:39 <JoeyA> But I don't have enough RAM for that.
22:18:59 <monochrom> JoeyA: due to some conventional wisdom, it is customary to ask-for-more by asking for double. it does not imply immediate need of that much.
22:20:14 <monochrom> And then there is also the fun behaviour of linux (since a certain version) granting all allocation requests without looking.
22:20:48 <djahandarie> Resulting in ghci consistantly killing my system nearly everytime I use it for anything serious
22:21:10 <luite> why don't you set a ulimit then?
22:21:12 <monochrom> that's a bit extreme. how serious?
22:21:39 <djahandarie> luite, I don't know, that'd probably be a good idea
22:22:12 <djahandarie> monochrom, serious enough that I accidently force an infinite list by accident one time in my 100 iterates of whatever function I'm writing
22:23:13 <monochrom> that shouldn't kill the system immediately. slowly yes. but so slowly you would have killed ghci long before.
22:23:35 <JoeyA> Another annoying thing ghci likes to do is stop having a responsive editline when there's a lot of memory used.
22:24:11 <djahandarie> monochrom, my system usually hovers around 70% memory usage because of all the other stuff I have open
22:24:28 <djahandarie> So it doesn't take much not-looking-at-memory-usage to have a crash
22:24:30 <monochrom> I mean unless you have a superfast CPU and you also have some photoshop session running for a 20 megapixel picture.
22:24:34 <JoeyA> Nobody needs more than 640K
22:24:44 <ivanm> 640K? Luxury!
22:24:55 <djahandarie> monochrom, usually I have a ton of tabs open in my browser
22:25:22 <djahandarie> Of 'web 2.0 flash twitter super javascript' websites which like to hog the memory
22:25:36 <luite> is it possible to compile 64 bit haskell programs for windows by the way? the platform is only available in 32 bit, and my program seem to be pushing the memory limit
22:25:58 <monochrom> well, that's suicidal, can't really blame ghci, last straw.
22:26:26 <monochrom> but I guess you're blaming linux really
22:27:03 <djahandarie> I'm also blaming ghci for not having some sort of protection even though Linux should be doing that
22:27:05 * p_l tends (tended?) to go to 100~150 tabs
22:27:10 <wli> Strict overcommit will deny malloc() requests etc.
22:27:29 <p_l> wli: strict overcommit would work if not for Linux's broken memory manager
22:28:08 <wli> p_l: You're seeing cases where strict overcommit fails to do what it should?
22:28:15 <monochrom> even the ghc windows installer is just 32-bit, it seems.
22:28:29 <p_l> both users of GC'd languages (who like flat, mmaped address spaces) and low-latency multimedia people have been badgering for proper mmap() on linux for long time :P
22:28:37 <carter> does anyone here heavily use either of the scrap your boilerplate or scrap your zipper lib? 'cause I have a cool patch for the scrap your zipper lib, and I'd like to know how much they're respectively used before I try to get the patch added
22:28:39 <monochrom> perhaps you have to build ghc yourself if you want 64-bit, but I don't know how well that works.
22:28:46 <p_l> monochrom: Windows Installer (as in product) is 32 bit itself, afaik
22:28:55 <djahandarie> carter, I believe SYB is frowned upon
22:29:06 <carter> djahandarie:  really?
22:29:26 <carter> djahandarie: i'm interested moreso in where people stand on the scrap your zipper lib
22:29:41 <wli> p_l: Something specific to mmap() goes wrong with strict overcommit?
22:29:55 <carter> but why's it frowned upon? (aside from kinda making schemish programming possible?)
22:29:55 <djahandarie> carter, I haven't used it but it doesn't share any of the ugliness of SYB it seems
22:30:12 <luite> monochrom: there's a 64 bit mingw version, but it's possible to compile ghc with it. I was kind of hoping that someone else had already gone through the trouble of figuring these things out ;0
22:30:28 <p_l> wli: I'm using SBCL, which tries to request *address space* instead of memory itself (that's what SIGSEGV handling is for). It uses MAP_NORESERVE option... which then gets ignored by kernel
22:30:33 <carter> djahandarie: you mean the explicit injection of any function to run query stuff?
22:30:40 <luite> monochrom: I mean I'm not sure whether it is possible to compile ghc with it
22:31:14 <djahandarie> carter, I mean the Data.Data and Typeable stuff
22:31:16 <carter> djahandarie:  my patch basically makes it possible to take "slices" of elements in a tree like structure using a zipper at two locations to give the starting and end points of a fold
22:31:41 <wli> p_l: It's not possible to localize overcommitment to a single process.
22:31:41 <luite> monochrom: it's probably easier to just install linux and use that instead
22:31:48 <carter> djahandarie: yeah, but no one should be using that part of syb anyways
22:32:01 <carter> those modules are just for providing new abstractions
22:32:04 <p_l> wli: with or without overcommit, MAP_NORESERVE is ignored, but without overcommit it crashes. multimedia people otoh require a *working* way to actually get strict mapping
22:32:13 <p_l> wli: MAP_NORESERVE isn't overcommit
22:32:13 <carter> s/providing/building
22:32:37 <djahandarie> carter, I'm not really super familiar with it so I dunno how much I can help
22:32:41 <p_l> wli: MAP_NORESERVE means "send me SIGSEGV if I can't get the page backed by Virtual Memory"
22:33:00 <carter> djahandarie: as far as I can tell, you're supposed to only touch the Data.Generics.* stuff for client code if you'e not a lib author
22:33:29 <siracusa> When running `cabal haddock --hoogle', is there a way to include also internal package files to the hoogle database?
22:33:51 <carter> i'm just wondering to what extent people might liking being able to have a sensible way to talk about "slices of trees"
22:34:10 <carter> because i've got a patch for the scrap yer zipper stuff that'll make that possible and easy
22:34:50 <carter> and doesn't requir changing any of the preexisting code in that lib
22:35:27 <carter> but simply needs to be in the same module so it can use the constructors for some types that anren't fully exported
22:35:40 <carter> once i'm happy with the interface I may just email the dude anyways
22:36:01 <carter> but nontheless, i'd be interested in knowing the extent to which theres a potential general interest in that 
22:36:33 <djahandarie> It sounds useful
22:37:07 <carter> its kinda key functionality for a lib i'm working on :)
22:37:56 <carter> namely:  a lib that lets you walk around any tree datastructure any which way, specifying your motion in a parser combinator style
22:38:17 <carter> and then being able to pick out intervals of "tokens" or whatever 
22:38:25 <carter> and using them 
22:38:37 <carter> via a slice / fold construction
22:38:49 <carter> with the endpoints specified by the zippers
22:39:28 <djahandarie> Intervals of tokens?
22:39:33 <carter> yes
22:40:01 <carter> take eg some webpage parsed into a simple AST format by the pandoc html parser
22:40:06 <carter> (which strips out a lot of stuff)
22:40:25 <carter> you want to try to id certain interesting pieces of content
22:40:39 <carter> so the simplest approach
22:40:50 <carter> from a library user standpoint
22:40:55 <carter> would be to be able to say 
22:41:25 <carter> "these are the kinds of word, sequences of words, that I find interesting, tag them acccording to this property type"
22:41:59 <carter> and then you walk around an anotated tree with the zippers or pairs of zippers
22:42:09 <carter> specifying individual tokens
22:42:16 <carter> or the end points of  sequence of tokens
22:42:20 <carter> and then you walk aorund
22:42:34 <carter> starting with these locations
22:42:46 <carter> and building up the info / summary stuff you want
22:43:02 <carter> eg
22:43:07 <carter> "heres some nouns I like"
22:43:24 <carter> and then you have stuff stuff that walks around to see if its the subject
22:43:30 <carter> or the direct object
22:43:31 <carter> etc
22:43:36 <carter> would be one example
22:43:46 <copumpkin> don't forget the comonad!
22:43:55 <carter> copumpkin: which one?! :p
22:44:10 <copumpkin> I dunno, you have a zipper so you probably have a comonad in there somewhere :P
22:44:27 <carter> copumpkin:  well, i am treating the zipper in my mind as a kinda generalize stream
22:44:52 <djahandarie> Comonads are the monads of tomorrow
22:45:16 <carter> djahandarie: nope, real math is the monads of tomorrow :)
22:45:25 <carter> copumpkin:  so it'd be really cool to figure out how to work out some fusion laws for zipper manipulation
22:46:13 <carter> copumpkin: djahandarie: that aside, it may make a nice interface for editing tree stuctured text
22:46:27 <carter> (the lib that uses the sliceable zipper fu)
22:46:43 <carter> (that i've designed out but needed this sliceable zipper first)
22:46:48 <copumpkin> yeah :) that'd be cool
22:47:03 <copumpkin> you should talk to pigworker about this (although I did see you tweeting at him)
22:47:08 <carter> i did
22:47:17 <carter> i'ma gonna email him or something in the near future
22:47:22 * djahandarie isn't sure who carter is
22:47:23 <copumpkin> ah, he's also on IRC, but doesn't come here
22:47:51 * carter djahandarie, please restate that in the form of a question :)
22:48:18 <djahandarie> carter, reveal your identity!
22:48:23 <djahandarie> Oh wait, that still wasn't a question
22:48:31 <copumpkin> lol
22:48:48 <copumpkin> Sir, we will need to see a form of identification.
22:49:06 <carter> copumpkin knows some of  my super plt retroness
22:49:34 <carter> (i'm old in plt despite only just finishing ungergrad, though 'm doing general cs theory for grad)
22:50:05 <djahandarie> Did you start PLT while you were young or start uni while you were old?
22:50:10 <copumpkin> lol
22:50:11 <carter> former
22:50:44 <carter> eg: did some toy work on cbv cps translation when you have dependent types in hs
22:51:09 <djahandarie> Neat. I didn't do much computer science in high school, only lots of programming
22:51:25 <carter> but I don't have the attention span for fully mechanized theorem proving
22:51:59 <carter> so who's djahandarie then?
22:52:00 <firegolfer> how can I fold with Text.Xhtmls <<?
22:52:00 <carter> :p
22:52:15 <djahandarie> carter, just some random bloke :P
22:52:17 <carter> firegolfer: is it an instance of foldable?
22:52:24 <firegolfer> basically, I want thediv << thespan << ls !! 0 << thespan << ls !! 1 ....
22:52:37 <firegolfer> ls :: [String]
22:53:06 <firegolfer> (<<) :: (HTML a) => (Html -> b) -> a -> b
22:53:11 <djahandarie> firegolfer, if I remember correctly, Text.XHTML is a bunch of Html -> Html functions
22:53:21 <carter> firegolfer: umm, please restate it declaritive in terms of what you want to do at a higher level of abstraction
22:53:39 <carter> eg "i want do ____ with html stuff"
22:54:23 <firegolfer> I want to put each element in ls into a <span>...</span>
22:55:19 <carter> so howa bout
22:55:21 <carter> you do a map!
22:55:33 <firegolfer> thediv << (thespan << "1") +++ (thespan << "2") and so on
22:55:41 <firegolfer> where ls is ["1","2",...]
22:55:42 <carter> map (function that puts input betwen stuff) [list of things]
22:56:13 <djahandarie> firegolfer, map (\a -> span << a) would give you a list of spans I believe
22:57:37 <carter> djahandarie: eg I was programming toy lambda calc stuff in haskell (both lexical and dynamically scoped, that latter is not say with a y combinator) the summer after my sophmore year of hs on the side
22:58:03 <carter> which i guess was ~ 6 years ago
22:58:06 <djahandarie> carter, cool. Where are you at now?
22:58:39 <carter> finished undergrad at some pretentious place in ct, off to phd in the icy but fun looking not very urban north
22:58:50 <djahandarie> Oh, I'm going to UConn right now
22:59:02 <carter> copumpkin: fun location but cold, aye?
22:59:17 <copumpkin> yeah, I liked it :)
22:59:48 <carter> djahandarie: when it comes time to choose undergrad advisors, the best advice anyone can give you is choose a person you feel comfortable actually having conversations wiht
22:59:56 <carter> just in case no one's told you that
23:00:10 <carter> (don't know how uconn undergrad advising works)
23:00:20 <mtnviewmark> firegolfer: you just need to do something like
23:00:41 <djahandarie> My uni stuff is a big mess atm until after this sememster anyways
23:00:45 <mtnviewmark> thediv << map (thespan <<) ["1", "2", "3"]
23:01:07 <mtnviewmark> note that << will call "tohtml" on the thing on the right
23:01:09 <djahandarie> Ah whoops, thespan*
23:01:30 <mtnviewmark> which, for lists will +++ 'em
23:02:07 <mtnviewmark> tohtml is also nicely defined so it works on Maybe x and [Maybe x]
23:02:25 <djahandarie> Wow I'm definitely up too late
23:02:27 <firegolfer> thediv << (foldl1 (+++) (map (\a -> thespan << a) ["1","2"]))
23:02:36 <mtnviewmark> no, no need
23:02:48 <mtnviewmark> thediv << map (thespan <<) ["1", "2"]
23:03:02 <carter> djahandarie:  the internet tells me they have a hwole bunch of theory folks
23:03:03 <carter> cool
23:03:21 <djahandarie> carter, my favorite professor is Alexander Russel if you'd like to look him up
23:04:03 <carter> djahandarie:  i approve of the blend of awesome that is the topics he mentions as his interestes
23:04:12 <carter> more math (theory ) = more POWERRRAAA
23:04:24 <djahandarie> I also missed an l in his name *sigh*
23:04:28 <djahandarie> And yeah he's definitely very bright
23:04:35 <djahandarie> I'm off to bed though
23:04:39 <djahandarie> G'night all
23:05:04 <mtnviewmark> firegolfer: they are the same - try it in ghci
23:05:56 <firegolfer> yes
23:06:04 <firegolfer> but...
23:06:18 <firegolfer> it actuelly does not <span>1</span><span>2</span>
23:06:19 <firegolfer> it does
23:06:28 <firegolfer> <span><span>1</span><span>2</span></span>
23:06:39 <mtnviewmark> not in my ghci
23:07:04 <mtnviewmark> > thediv << map (thespan <<) ["1", "2"]
23:07:04 <lambdabot>   Not in scope: `thediv'Not in scope: `thespan'Not in scope: `<<'Not in scope...
23:07:14 <firegolfer> oh
23:07:16 <firegolfer> my mistake
23:07:17 <mtnviewmark> produced
23:07:19 <firegolfer> yeah. works fine
23:07:34 <firegolfer> thx
23:07:37 <mtnviewmark> <div><span>1</span><span>2</span></div>
23:07:44 <mtnviewmark> coolio
23:07:58 <mtnviewmark> I've been deep in Text.XHtml these past few months
23:08:13 <mtnviewmark> let me know if I can help with any other tricks
23:08:27 <co_dh> can I overload (&&) operator ?  by overload I mean like (+) can be overload by define instance of Num
23:08:46 <mtnviewmark> :info (&&)
23:08:49 <Gracenotes> what type do you want to define it for?
23:09:01 <co_dh> [a] && [a] -> [a]
23:09:21 <co_dh> && :: [Bool] -> [Bool] -> [Bool]
23:09:22 <mtnviewmark> well, you can define it in your own module - but then you'll have to hide the prelude's to use it
23:09:23 <Gracenotes> you could possibly make something like that using functions
23:09:31 <Gracenotes> in the prelude and whatnot
23:10:00 <Gracenotes> but && refers to a specific function in the Prelude
23:10:05 <co_dh> ok, thanks, I'll use function. 
23:10:10 <mtnviewmark> > let &&& = zipWith (&&) in [ True, False, True ] &&& [False, True, True ]
23:10:11 <lambdabot>   <no location info>: parse error on input `&&&'
23:10:32 <mtnviewmark> > let (&&&) = zipWith (&&) in [ True, False, True ] &&& [False, True, True ]
23:10:33 <lambdabot>   [False,False,True]
23:10:53 <firegolfer> mtnviewmark: Is there a way to actually render "tidy" html
23:10:55 <firegolfer> instead of
23:10:56 <firegolfer> <li
23:10:59 <firegolfer> Blabla
23:11:00 <mtnviewmark> yes
23:11:01 <firegolfer> </li
23:11:03 <firegolfer> >
23:11:19 <co_dh> I think liftM2 (&&) would be the same, right ? 
23:11:29 <mtnviewmark> firegolfer: prettyHtml and prettyHtmlFragment
23:11:38 <co_dh> > (liftM2 (&&)) [True, False, True] [False, True, True]
23:11:38 <lambdabot>   [False,True,True,False,False,False,False,True,True]
23:11:43 <Gracenotes> co_dh: that would calculate all combinations of the bools
23:11:47 <Gracenotes> er as you can see
23:12:02 <co_dh> yep, you are right.
23:12:24 <firegolfer> mtnviewmark: Thanks
23:12:37 <firegolfer> looks a lot nicer :)
23:12:51 <firegolfer> or should I say prettier
23:13:14 <Veinor> mtnviewmark: why does it output html like that anyway?
23:13:25 <co_dh> > (&&) <$> [True, False] <$> [False, False]
23:13:26 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
23:13:26 <lambdabot>         against inferred ...
23:13:31 <Gracenotes> whitespace preservation
23:13:38 <mtnviewmark> the normal output is putting out a compact form - with minimal whitespace
23:13:43 <co_dh> > (&&) <$> [True, False] <*> [False, False]
23:13:44 <lambdabot>   [False,False,False,False]
23:13:52 <Gracenotes> making sure significant whitespace doesn't sneak in, maintaining correctness and indenting
23:13:53 <mtnviewmark> which is generally what you want if you are dynamically generating web pages and transmitting 'em
23:14:19 <Gracenotes> whitespace correctness is overrated though
23:14:23 <firegolfer> to reduce file size
23:14:40 <firegolfer> I guess
23:14:58 <mtnviewmark> if you want to use lifting somehow, you need to use ZipList
23:14:59 <mtnviewmark> > getZipList $ liftA2 (&&) (ZipList [True, False]) (ZipList [True, True])
23:14:59 <lambdabot>   [True,False]
23:15:10 <Gracenotes> firegolfer: I don't think it reduces filesize, since it does indenting
23:15:21 <Gracenotes> there *is* a function in xhtml which produces compact output
23:15:25 <Veinor> also, so that the people who are source-diving your webpage for whatever reason don't look at you funny
23:15:26 <co_dh> mtniewmark: that's what I want , thanks.
23:15:37 <mtnviewmark> or
23:15:38 <mtnviewmark> > getZipList $ (&&) <$> ZipList [True, False] <*> ZipList [True, True]
23:15:39 <lambdabot>   [True,False]
23:15:57 <mtnviewmark> Really? 
23:16:08 <co_dh> mtnviewmark: yes.
23:16:17 <mtnviewmark> > zipWith (&&) [True, False] [True, True]
23:16:17 <lambdabot>   [True,False]
23:16:21 <mtnviewmark> is pretty concise
23:16:50 <co_dh> inv :: [Bool] -> [Bool] 
23:16:53 <co_dh> inv = map not.
23:17:15 <co_dh> you see, we use zipWith for binary , but map for unary , it's a little ugly, 
23:17:28 <co_dh> but with applicative and ziplist, they are unified.
23:17:39 <Gracenotes> varargs are hard to generalize
23:17:40 <mtnviewmark> true - but then there's all that wrapping and unwrapping
23:17:54 <co_dh> > getZipList $  not <$> ZipList [True, False]
23:17:54 <lambdabot>   [False,True]
23:17:55 <mtnviewmark> unless you plan to carry them all around as ZipList values
23:18:10 <dobblego> I wish there was a nicer solution than that
23:18:26 <co_dh> the wrapping is because Applicative [] defined as something we don't want . 
23:18:38 <co_dh> they could define Applicative [] and ZipList , 
23:18:57 <dobblego> the Applicative [] corresponds to ap for []
23:20:04 <co_dh> we could define Applicative [] as ZipList
23:20:29 <dobblego> or we could find a nicer solution to the fact that there are three possible Applicatives for []
23:20:44 <mtnviewmark> well, I don't know your problem domain -- but if I were handling a large number of [Bool] values in a program, I'd be inclined to define a set of list versions of normal Bool functions - and not worry that some use map, some use zipWith
23:20:46 <co_dh> yes, that would be right. 
23:22:06 <co_dh> my problem domain is nothing , it's just a simple example I 'm reading about Monad fix.  Value Recursion in Monadic Computations.
23:22:51 <mtnviewmark> aha - hence, perhaps you are more interested in the generalized ways you can do this, rather than concise ways to get some particular problem done
23:22:53 <mtnviewmark> :-)
23:23:39 <c_wraith> dobblego, what's the third implementation of Applicative for []?
23:24:09 <dobblego> oh crap, that was from memory
23:24:32 <dobblego> did I read it in Applicative Programming With Effects perhaps?
23:24:50 <dobblego> or am I thinking of the three Monoids for Maybe?
23:25:49 <dobblego> flipping the order of application perhaps?
23:28:28 <co_dh> mtnviewmark: yes , 
23:30:07 <co_dh> > take 5 $ fix $ ( False : ) . inv 
23:30:07 <lambdabot>   Not in scope: `inv'
23:30:31 <co_dh> > take 5 $ fix $ (False :) . map not
23:30:31 <lambdabot>   [False,True,False,True,False]
23:30:47 <co_dh> I begin to understand fix, haha
23:33:04 * mtnviewmark >>= bed
23:33:36 <Veinor> so wait, mtnviewmark is bound to his bed?
23:34:27 <co_dh> anybody has an introduction book ( or online ) on circuit design for a software engineer ? to understand FRP 
23:34:46 <ivanm> I don't see how circuit design relates to FRP...
23:34:54 <emilio> http://pastebin.org/791999 <- can someone check that out please? I figure there's an easier way of doing what I'm doing
23:35:37 <ivanm> emilio: well, you can use a wrapper case statement in getExprForID
23:35:41 <co_dh> FRP borrowed some concept from circuit design , like delay, 
23:35:57 <ivanm> not that you're going to have namespace clashes there, since id is a function in its own right...
23:36:28 <emilio> ivam: It just seems a bit wrong... or is that reasonable?
23:36:48 <ivanm> well, what is this Value type?
23:37:03 <ivanm> if there are any constructors, what happens in all those cases?
23:37:15 <ivanm> but using `id' as a function parameter is a big no-no IMHO
23:37:28 <emilio> Well, in that case I'm sure the value will always be a LetVal
23:37:48 <emilio> ivanm: It's an assignment, we can't change that
23:37:58 <emilio> It's defined in some other part of the supporting code
23:38:03 <ivanm> emilio: fromJust is also iffy
23:38:17 <emilio> Again, in that case I'm always sure I'll have a value
23:38:42 <ivanm> you could always split it up in the let block with direct pattern matches...
23:38:44 <emilio> The parser has more functionality than we need to actually write our stuff, which makes it a bit more complicated...
23:38:54 <ivanm> emilio: but I'd warn you against assuming that something is always going to be a certain value
23:39:15 <emilio> Understood, but in this case the spec for our mini language always assumes a value
23:39:24 <emilio> But the parser has more wide range, so it can handle that
23:39:32 <ivanm> I've made assumptions like that, and then three versions down the track I changed my mind whilst forgetting that previous assumption so other code that made that assumption broke
23:40:34 <emilio> True, but the spec says we won't be tested on invalid programs
23:40:40 <emilio> So, theoretically it can never happen
23:40:48 <ivanm> oh, this is an assignment?
23:40:52 <emilio> + it's just an assignment, not like it's production code or anything ;D
23:40:53 <emilio> yeah
23:41:10 <ivanm> well, the only possible improvements I can think of is to do direct pattern matching in the let statement
23:41:28 <emilio> it's not a huge deal, I just thought it looked a bit stupid to introduce a new function just to pattern match that
23:41:30 <JoeyA> openBinaryFile "fifo" WriteMode fails if the file is a FIFO unless there's a reader, whereas C's fopen() blocks until a reader arrives.
23:41:31 <ivanm> i.e. let (Just (LetVal expr)) = getEnv env id
23:41:40 <emilio> Oh I see
23:41:44 <JoeyA> Is there a way to read a FIFO in Haskell?
23:41:49 <ivanm> emilio: but please, rename `id' ;-)
23:41:54 <JoeyA> dejavu
23:41:54 <ivanm> it's making it hard to read your code ;-)
23:42:01 <ivanm> JoeyA: I think I've seen such things...
23:42:15 <ivanm> JoeyA: http://www.holumbus.org/hayoo/hayoo.html?query=FIFO
23:43:15 <emilio> You got it, it's now ident ;)
23:43:22 <ivanm> *phew*
23:43:38 <emilio> But Id has to stay
23:43:39 <ivanm> emilio: but yeah, it makes it hard to name variables that are meant to be an identifier or some kind ;-)
23:43:45 <ivanm> oh, Id is OK
23:43:53 <emilio> Right, so id is some built in function?
23:44:14 <ivanm> yup
23:44:16 <ivanm> @type id
23:44:16 <lambdabot> forall a. a -> a
23:45:00 <emilio> Ok... so
23:45:07 <emilio> It's a function that returns itself?
23:45:30 <ivanm> no, it's the identity function
23:45:34 <ivanm> > id 5
23:45:35 <lambdabot>   5
23:45:41 <emilio> Err, rather returns the first arg
23:45:44 <dobblego> it's a function that returns its argument
23:45:53 <ivanm> > map ($4) [succ, id, pred, (^2)]
23:45:53 <lambdabot>   [5,4,3,16]
23:46:03 <emilio> Yeah... I guess I'm a bit noob so I don't see where it would be useful :)
23:46:09 <ivanm> emilio: usually used when you have to supply a function but don't want the value to change
23:46:24 <emilio> Ah ok, I see
23:46:31 <ivanm> and to simplify some combinators
23:46:32 <emilio> Cool, thanks for the help
23:46:34 <ivanm> @src join
23:46:34 <lambdabot> join x =  x >>= id
23:46:36 <dobblego> @type foldr (.) id
23:46:36 <lambdabot> forall b. [b -> b] -> b -> b
23:46:37 <ivanm> ^^ id!
23:46:47 <ivanm> @src (<$)
23:46:47 <lambdabot> (<$) = (<$>) . const
23:46:58 <ivanm> oh, right, I thought it was id for some reason, not const
23:47:20 <JoeyA> ivanm:  Thanks.  There's a fifoOpen function here that uses System.Posix.IO : http://hackage.haskell.org/packages/archive/HSH/latest/doc/html/src/HSH-ShellEquivs.html#catToFIFO
23:47:46 <ivanm> JoeyA: just fyi, I think HSH is no longer maintained
23:49:26 <JoeyA> Anyway, in jist, it just calls openFd with default arguments.
23:55:19 <co_dh> I'm looking for a remote Haskell job, anybody knows something?
23:55:56 <dobblego> if I did, you'd be the last person to know about it :)
23:57:43 <co_dh> dobblego: why? 
23:58:05 <dobblego> because I'm selfish!
23:58:23 <co_dh> lol, everybody is some kind of :)
23:58:49 <co_dh> let's hope Oracle win Google on Java's case, and google switched to Haskell !
23:58:59 <co_dh> God bless me, let Oracle win.
23:59:26 <dobblego> hope all you like, but their language "experts" aren't the brightest bulbs in the box
