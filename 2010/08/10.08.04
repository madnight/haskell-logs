00:00:06 <kmc> also, your code is marching off the right hand side of the screen
00:00:07 <bss_> :t Data.Number.CReal.showCReal
00:00:07 <wioux> bss_: for n-decimal precision, multiply by 10^n, read as Integer into x, approxRational x 10^n
00:00:08 <lambdabot> Int -> CReal -> String
00:00:22 <kmc> when you have a guard after a long function arg list, you can put the guard on the next line and indent it a fixed amount
00:00:31 <kmc> in fact indentation doesn't matter at all in that context
00:00:38 <bss_> wioux: 'k, that's basically what I was doing.
00:00:51 <bss_> wioux: let { crealToRational :: Int -> Data.Number.CReal.CReal -> Data.Ratio.Rational; crealToRational n = (Ratio.% factor) . truncate . (* (fromInteger factor)) where factor = 10 ^ n; }
00:01:03 <kmc> it is used only to delimit blocks and entries within "do", "case of ...", "let ...", and "where ..."
00:01:06 <bss_> > let { crealToRational :: Int -> Data.Number.CReal.CReal -> Data.Ratio.Rational; crealToRational n = (Ratio.% factor) . truncate . (* (fromInteger factor)) where factor = 10 ^ n; }
00:01:06 <wioux> bss_: not sure what else you can do, library looks like its still young
00:01:07 <lambdabot>   not an expression: `let { crealToRational :: Int -> Data.Number.CReal.CReal...
00:01:13 <kmc> (and at top level)
00:01:51 <bss_> > let { crealToRational :: Int -> Data.Number.CReal.CReal -> Data.Ratio.Rational; crealToRational n = (Ratio.% factor) . truncate . (* (fromInteger factor)) where factor = 10 ^ n; } in crealToRational 3 $ sqrt 2
00:01:52 <lambdabot>   Not in scope: `Ratio.%'
00:02:03 <bss_> > let { crealToRational :: Int -> Data.Number.CReal.CReal -> Data.Ratio.Rational; crealToRational n = (Data.Ratio.% factor) . truncate . (* (fromInteger factor)) where factor = 10 ^ n; } in crealToRational 3 $ sqrt 2
00:02:03 <blups0r> ok thanks for the hints
00:02:04 <lambdabot>   707 % 500
00:02:16 <blups0r> after correction i get another error
00:02:16 <bss_> 707 / 500
00:02:19 <bss_> > 707 / 500
00:02:20 <lambdabot>   1.414
00:02:29 <blups0r> trie.hs:38:0:
00:02:30 <blups0r>     Warning: Pattern match(es) are overlapped
00:02:30 <blups0r>              In the definition of `insert':
00:02:30 <blups0r>                  insert str v (Start []) = ...
00:02:30 <blups0r>                  insert str value (Start childs) = ...
00:03:05 <bss_> A variable like "childs" can be unified with the value "[]".
00:03:17 <bss_> But, that shouldn't be a problem...
00:04:09 <blups0r> but i have to make differences if the list is empty or not
00:04:12 <wioux> you can match like `insert str value (Stard (child:childs)) =..` and that would go away
00:06:39 <blups0r> ok thanks a lot
00:06:47 <blups0r> it helped
00:12:24 <blups0r> now it crashes while running
00:12:39 <bss_> Error message?
00:12:41 <blups0r> it says non exhaustive patterns
00:12:50 <bss_> In what function?
00:12:53 <blups0r> in insertInTrieLst
00:13:35 <bss_> insertInTrieList _ _ [] doesn't match anything.
00:14:15 <bss_> By that, I mean if the last argument is [] and the first argument is not [], there's no pattern match.
00:14:55 <bss_> @pl \d -> (Ratio.% d) . truncate . (* (fromInteger d))
00:14:55 <lambdabot> liftM2 (.) (Ratio. %) ((truncate .) . (*) . fromInteger)
00:17:16 <JHaskly> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28541#a28541 <- Can anyone help me as to why this function only runs when the type declaration is commented out?
00:18:31 <kmc> because that's not the right type
00:18:39 <kmc> if you remove the signature and load it in ghci
00:18:42 <kmc> you can type ":t reduce"
00:18:48 <kmc> and see the type that was inferred
00:19:12 <bss_> :t elem
00:19:13 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
00:19:44 <c_wraith> JHaskly: also, look at Data.List.nub, if you aren't using your own implementation for a specific reason?
00:19:49 <bss_> JHaskly: ^^ You need a type class restriction; reduce doesn't work on types that aren't instances of Eq.
00:20:00 <bss_> :t Data.List.nub
00:20:01 <lambdabot> forall a. (Eq a) => [a] -> [a]
00:20:05 <bss_> @src Data.List.nub
00:20:06 <lambdabot> Source not found. It can only be attributed to human error.
00:20:10 <bss_> @src nub
00:20:10 <lambdabot> nub = nubBy (==)
00:20:14 <bss_> @src nubBy
00:20:14 <lambdabot> nubBy eq []             =  []
00:20:15 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:20:52 <bss_> It's a little different than yours.
00:21:03 <bss_> > nub [1,2,2,3,2]
00:21:03 <lambdabot>   [1,2,3]
00:21:15 <bss_> Yours would give [1,3,2].
00:21:29 <JHaskly> Ah, ok.  Please excuse the stupidity - I'm new to the Haskell world :P
00:21:38 <c_wraith> yeah.  nub also works for infinite lists, which that implementation wouldn't
00:21:44 <c_wraith> slightly different use cases.
00:22:46 <JHaskly> I guess nub is the way to go then :)
00:23:08 <c_wraith> I just brought it up because it's easy to miss due to the funny name
00:23:44 <JHaskly> Yeh, I looked around a bit and couldn't find anything, but it looks like nub will fit the bill just fine :)
00:24:07 <JoshTriplett> In playing around with "foreign export", I noticed that if I export a function with the type "CInt", that turns into the C type HsInt32, which seems wrong.  Shouldn't "CInt" always become "int"?  The definitions in the Foreign.C.Types module explicitly say that sizeOf (undefined :: CType) == sizeof(type) in C.
00:24:26 <bss_> :t (Ratio. %) ((truncate .) . (*) . fromInteger)
00:24:27 <lambdabot> parse error on input `%'
00:24:39 <bss_> :t (Data.Ratio.%) ((truncate .) . (*) . fromInteger)
00:24:40 <lambdabot> forall a b. (RealFrac a, Integral b, Integral (Integer -> a -> b)) => (Integer -> a -> b) -> Ratio (Integer -> a -> b)
00:25:03 <bss_> :t liftM2
00:25:04 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:25:26 <JoshTriplett> What are you trying to do?
00:26:13 <bss_> JoshTriplett: Sorry, I should be doing that in my labdabot privmsg window.
00:26:30 <JoshTriplett> bss_: I just wondered; it looked like the start of something interesting. :)
00:26:30 <bss_> JoshTriplett: I'm just trying to figure out the output of @pl on a function I wrote.
00:26:35 <JoshTriplett> Ah.
00:26:39 <JoshTriplett> What's the function?
00:26:48 <JoshTriplett> @pl is generally *correct* but hard. :)
00:26:48 <lambdabot> (line 1, column 34):
00:26:48 <lambdabot> unexpected ":"
00:26:48 <lambdabot> expecting space or simple term
00:26:52 <JoshTriplett> heh.
00:26:58 <JoshTriplett> gee, thanks lambdabot.
00:27:09 <kmc> JoshTriplett, did you try on a 64-bit machine? perhaps it becomes HsInt64 there?
00:27:18 <bss_> Converts a Data.Number.CReal.CReal to a Data.Ratio.Rational, sort of like approxRational.
00:27:37 <bss_> (approxRational doesnot work on Data.Number.CReal.CReal values.)
00:27:46 <JoshTriplett> kmc: This is a 64-bit machine.  And no, sizeof(int) == 4 on a 64-bit box, generally. ;)
00:27:59 <Ke> not on haskell
00:28:07 <Ke> in C yes
00:28:10 <bss_> > approxRational (pi :: Data.Number.CReal.CReal)
00:28:11 <lambdabot>   Overlapping instances for GHC.Show.Show
00:28:11 <lambdabot>                              (Data....
00:28:51 <Ke> > 2^40 :: Int
00:28:52 <lambdabot>   1099511627776
00:28:56 <JoshTriplett> > approxRational (pi :: Data.Number.CReal.CReal) :: Data.Ratio.Rational
00:28:57 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
00:28:57 <lambdabot>         against inferred t...
00:29:11 <JoshTriplett> > (approxRational (pi :: Data.Number.CReal.CReal)) :: Data.Ratio.Rational
00:29:12 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
00:29:12 <lambdabot>         against inferred t...
00:29:21 <bss_> > approxRational (recip 7) (pi :: Data.Number.CReal.CReal)
00:29:22 <lambdabot>   0 % 1
00:29:32 <bss_> > approxRational (pi :: Data.Number.CReal.CReal) (recip 7)
00:29:33 <lambdabot>   *Exception: CReal.toRational
00:29:43 <JoshTriplett> :t approxRational
00:29:43 <bss_> :t approxRational
00:29:43 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
00:29:44 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
00:29:52 <JoshTriplett> ...huh.
00:29:58 <bss_> The second number is the uncertainty.
00:30:02 <JoshTriplett> Ah, I see.
00:30:05 <bss_> approxRational pi (recip 7)
00:30:10 <bss_> > approxRational pi (recip 7)
00:30:11 <lambdabot>   3 % 1
00:30:26 <JoshTriplett> > approxRational pi (1 % 2)
00:30:27 <lambdabot>   No instance for (GHC.Float.Floating (GHC.Real.Ratio t))
00:30:27 <lambdabot>    arising from a u...
00:30:34 <bss_> > approxRational pi (recip 14)
00:30:35 <lambdabot>   16 % 5
00:30:40 <JoshTriplett> > approxRational pi (recip 400)
00:30:40 <lambdabot>   22 % 7
00:30:44 <JoshTriplett> heh.
00:31:10 <bss_> Anyway, that does it with Double precision.
00:31:31 <bss_> I was wanting something that would handle 100 digits or so accurately.
00:31:58 <JoshTriplett> I don't think Haskell has arbitrary-precision reals.
00:32:08 <Starfire> CReal?
00:32:23 <c_wraith> CReal is arbitrary-precision
00:32:27 <bss_> let f = \d -> (Ratio.% d) . truncate . (* (fromInteger d)) in f (fromInteger 10^40) (pi :: Data.Number.CReal.CReal)
00:32:29 <c_wraith> it's just slow.  :)
00:32:32 <JoshTriplett> I stand corrected.
00:32:36 <bss_> > let f = \d -> (Ratio.% d) . truncate . (* (fromInteger d)) in f (fromInteger 10^40) (pi :: Data.Number.CReal.CReal)
00:32:36 <lambdabot>   Not in scope: `Ratio.%'
00:32:44 <bss_> > let f = \d -> (Data.Ratio.% d) . truncate . (* (fromInteger d)) in f (fromInteger 10^40) (pi :: Data.Number.CReal.CReal)
00:32:45 <lambdabot>   7853981633974483096156608458198757210493 % 25000000000000000000000000000000...
00:32:50 <JoshTriplett> Oh, I see; not built-in?
00:32:59 <c_wraith> correct
00:33:38 <c_wraith> the name is short for Computable Reals.  Really, that's exactly what they are.  a function from a position to a digit.
00:34:05 <bss_> It's actually fairly fast when dealing with calculations that can be done accuratly in Double precision.  It's based off the ERA implementation, but some of the instance declarations for it are not... great.
00:34:39 <bss_> E.g. toRational = error "CReal.toRational", but that makes sense.
00:35:04 <bss_> approxRational would be nice, but I guess it is derived from toRational ...
00:35:19 <bss_> So, I guess I have to provide my own.
00:35:25 <kmc> Rational is also arbitrary-precision
00:36:12 <MoALTz> inkk is a spambot who PM'ed me with a poker link the moment i joined
00:36:39 <kmc> JoshTriplett, wait, so what's the problem? if sizeof(int) == 4 on your machine and CInt maps to HsInt32, isn't that correct?
00:36:41 <Zao> MoALTz: Poke a staffer?
00:36:47 <Veinor> yeah, I got spam from them too
00:37:37 <bss_> toRational doesn't make sense for CReal, really.  CReal is a wrapper for (Int -> Integer), higher input values give better results.  It's based on series expansions and closures.
00:38:49 <bss_> approxRational does make sense though, which is why I was surprised it didn't work.
00:40:14 <bss_> @src Data.Ratio.approxRational
00:40:14 <lambdabot> Source not found. Wrong!  You cheating scum!
00:40:19 <bss_> @src approxRational
00:40:19 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
00:40:25 <bss_> @hoogle approxRational
00:40:25 <lambdabot> Data.Ratio approxRational :: RealFrac a => a -> a -> Rational
00:40:31 <JoshTriplett> kmc: Not unless HsInt32 *always* correspnds to a typedef of int, as opposed to something else with the same size.
00:40:46 <JoshTriplett> kmc: On some platforms HsInt32 means "signed long".
00:40:59 <JoshTriplett> kmc: Which will make the C type system complain.
00:41:08 <JoshTriplett> kmc: Those are *not* the same type even when they're the same size.
00:41:56 <bss_> > let f = \d -> (Data.Ratio.% d) . truncate . (* (fromInteger d)) in f (fromInteger 10^ 5) (sqrt 5 :: Data.Number.CReal.CReal)
00:41:57 <lambdabot>   223607 % 100000
00:42:06 <bss_> 223607 / 100000
00:42:09 <bss_> > 223607 / 100000
00:42:10 <lambdabot>   2.23607
00:42:58 <JoshTriplett> kmc: Similarly "CLong" became HsInt64, which might mean "long" or "long long" or "__int64", depending on platform.  Again wrong. :)
00:44:28 <bss_> JoshTriplett: I don't see anything in the spec that means CInt maps directly to int.
00:44:29 <JoshTriplett> kmc: Looks like http://hackage.haskell.org/trac/ghc/ticket/2926 .
00:44:56 <bss_> JoshTriplett: It does have to have the same size and alignment, but that seems mostly it.
00:45:07 <kmc> JoshTriplett, i see
00:45:22 <kmc> it's certainly true that ghc-produced C code plays fast and loose with the C type system
00:45:29 <JoshTriplett> bss_: Granted.  But it breaks foreign export to do otherwise. :)
00:45:32 <kmc> i've been debugging -fvia-C output recently and it's no picnic
00:46:01 <JoshTriplett> kmc: Heh.  It makes me very happy that -fvia-C has become deprecated.
00:46:08 <kmc> it does seem like a real bug though
00:46:23 <kmc> yeah
00:46:43 <kmc> i'm working on targeting Android, and i hope we can move it to LLVM eventually
00:46:52 <kmc> for now though, unregisterised via-C is the path of least resistance
00:47:34 <JoshTriplett> kmc: On a related note...
00:47:44 <JoshTriplett> kmc: I take it it's currently impossible to build a real cross-compiler?
00:47:51 <JoshTriplett> kmc: As far as I can tell from the documentation.
00:48:26 <JoshTriplett> kmc: I'd love to have an x86-64-hosted GHC that targets armel.
00:48:37 <kmc> that's what i have, basically
00:48:42 <kmc> but through various hacks
00:48:50 <kmc> it's not supported cleanly within the existing ghc build infrastructure
00:49:08 <JoshTriplett> Right.  As far as I can tell, *ghc* should support it, but ghc's *build process* doesn't.
00:49:15 <kmc> i hope we'll release ghc-android soon
00:49:21 <kmc> and there's also http://projects.haskell.org/ghc-iphone/
00:49:31 <JoshTriplett> Nothing in GHC seems to have the assumption that the compiler's own format matches the binaries it generates, as far as I can tell.
00:49:37 <JoshTriplett> Just that the build system can't cope.
00:49:43 <kmc> but basically, my approach was to configure an unregisterised ghc on armel-linux, then copy over the various generated files 
00:49:57 <kmc> then build ghc-stage1 on the host from those files
00:50:10 <JoshTriplett> Nice.
00:50:18 <kmc> this makes a ghc which produces useless host binaries, but if you turn on -keep-hc-files you get c code you can feed to (say) the Android C compiler
00:50:21 <JoshTriplett> kmc: Why unregisterized?  I thought ghc had a native armel target?
00:50:30 <kmc> no, not in a while
00:50:40 <kmc> for example debian armel has ghc but it's unregisterised via-c only
00:50:57 <JoshTriplett> kmc: Oh.
00:50:59 <JoshTriplett> Sigh.
00:51:01 <kmc> i don't expect to get NCG for ARM working any time soon, but registerised via-C should be a huge win over unreg'd
00:51:03 <kmc> and may not be too hard
00:51:07 <kmc> LLVM would also be a huge win
00:51:15 <kmc> (there is unreg'd and reg'd LLVM, too)
00:51:22 * JoshTriplett will take anything that compiles, really.
00:51:27 <tensorpudding> LLVM works on ARM right?
00:51:38 <bss_> Any place I can file a nit-picky bug against the Haskell 2010 standard?
00:51:40 <JoshTriplett> kmc: As long as I don't have to copy C files around and compile them with a separate compiler. ;)
00:51:54 <JoshTriplett> bss_: Yeah, the haskell-prime mailing list, probably.
00:51:59 <kmc> the LLVM tools can convert LLVM bytecode to ARM assembly, yes
00:52:10 <tensorpudding> Cool.
00:52:14 <bss_> They use "&errno" as an example of a static address.
00:52:15 <tensorpudding> LLVM is so exciting
00:52:21 <kmc> JoshTriplett, it's not *that* bad, really.  but yeah, the build system i'm using now is an awful hack, i do plan to clean it up later but it's a lower priority than things like making the RTS not crash
00:52:24 <bss_> It's not in some modern implementations.
00:52:31 <JoshTriplett> bss_: s/some/most/, even.
00:52:44 <kmc> turns out, Android differs from vanilla Linux in a number of small ways
00:52:53 <JoshTriplett> kmc: Fortunately I want to target Maemo. ;) 
00:53:10 <kmc> that should be easier
00:53:12 <JoshTriplett> kmc: So I don't have insanity like a slightly-different ELF interpreter. ;)
00:53:14 <bss_> The C standards lets it any macro that expands to an l-value, so it can be a dereference of the result of a function call that returns a pointer, e.g.
00:53:16 <tensorpudding> GHC is moving to LLVM, and FreeBSD is moving to clang/LLVM replacing GCC
00:53:19 <bss_> Which is what it is in g++.
00:53:22 <kmc> maybe you can convince iPwn Studios (my employer) that there's a big Maemo games market
00:53:27 <kmc> and they will do the work for you ;)
00:53:34 <JoshTriplett> kmc: I can do that pretty easily, actually. :)
00:53:43 <JoshTriplett> bss_: And in C as well.
00:54:04 <bss_> s/g\+\+/gcc
00:54:06 <bss_> I meant.
00:54:24 <JoshTriplett> kmc: Let me dig up a statistic.
00:57:18 <JoshTriplett> kmc: I'm trying to dig up the numbers (should have saved a bookmark), but several of the top game makers for iPhone actually found that they got higher sales numbers on Maemo.
00:57:28 <kmc> by absolute measure?
00:57:34 <kmc> or by market proportion?
00:57:37 <JoshTriplett> Yes. :)
00:58:02 <kmc> JoshTriplett, well, i'd be very interested to see those numbers if you can find them
00:58:18 <JoshTriplett> kmc: Best hypothesis so far: easier to get noticed, even when comparing against the top of a really huge list.
00:58:24 <kmc> yeah
00:58:26 <JoshTriplett> kmc: Or, in other words, "get in early".
00:58:27 <kmc> makse sense
00:59:02 <kmc> is the N900 the main maemo device?
00:59:05 <kmc> or are there many?
00:59:13 * kmc owned a N800 back in the day but doesn't imagine they're a huge deal now
00:59:23 <JoshTriplett> kmc: Right now it's the only Maemo device running the current version of Maemo.
00:59:32 <JoshTriplett> kmc: Yeah, I have an N800 too; yay for the developer device program. :)
00:59:43 <JoshTriplett> kmc: And it helped them sell me a $600 phone, so it worked pretty well for them. :)
01:00:14 <JoshTriplett> Heh, one fun one I didn't know already.  Angry Birds ended up with a level editor written by the Maemo community. :)
01:00:28 <JoshTriplett> They didn't have one, so the Maemo community reverse-engineered it and wrote one. :)
01:00:45 <Ke> Maemo is dead, get ready for Meego
01:00:50 <JoshTriplett> Good response from the company, too: " As for any possible legal issues no worries, go for it!"
01:01:04 <JoshTriplett> ke: "sort of".
01:01:48 * hackagebot heapsort 0.1.0 - Heapsort of MArrays as a demo of imperative programming  http://hackage.haskell.org/package/heapsort-0.1.0 (BartonMassey)
01:02:00 <JoshTriplett> Ke: By the time Meego gets tailored for the N900's successor, it'll look no more different from Maemo 5 from a programming point of view than Maemo 5 did from Maemo 4.
01:02:30 <Ke> well if you are using just Qt, you should be fine
01:04:39 <JoshTriplett> Ke: Meego will support gtk+ too.
01:05:07 <bss_> Preferred library for talking to Qt4 / KDE4 from Haskell?
01:05:09 <bss_> qtHaskell?
01:07:54 <mun> without defining f and g, is this statement true? \exists x. (\forall y. x != y --> f x > f y) --> g x = 0, i.e. there exists an x which is a zero of g if it is a strict maximum of f.
01:08:58 <JoshTriplett> kmc: Currently failing to find the more detailed statistics I've seen before, but for one example, Rovio, the makers of Angry Birds (#1 iPhone game) said they found their Maemo port even more worth doing than they'd originally thought.
01:09:09 * JoshTriplett keeps digging.
01:09:27 <bss_> mun: I doubt it.
01:09:41 <mun> bss_, why's that?
01:10:06 <bss_> Take, g = asTypeOf 1 for example.
01:10:26 <bss_> g has no zeros.
01:11:25 <c_wraith> any reason you used asTypeOf instead of const? :)
01:11:42 <bss_> :t asTypeOf 1
01:11:43 <lambdabot> forall t. (Num t) => t -> t
01:11:45 <bss_> :t const 1
01:11:47 <lambdabot> forall t b. (Num t) => b -> t
01:12:28 <c_wraith> const is the implementation of asTypeOf.  asTypeOf just has the more restrictive type signature.
01:12:31 <bss_> Wanted g to have type a -> a, not a -> b.
01:12:47 <c_wraith> eh.  unification handles that anyway
01:13:21 <bss_> > asTypeOf 1 (32 :: Data.Word.Word) :: Integer
01:13:22 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
01:13:23 <lambdabot>         agains...
01:13:27 <bss_> > const1 (32 :: Data.Word.Word) :: Integer
01:13:28 <lambdabot>   Not in scope: `const1'
01:13:31 <siteswapper> :t asTypeOf
01:13:32 <bss_> > const 1 (32 :: Data.Word.Word) :: Integer
01:13:32 <lambdabot> forall a. a -> a -> a
01:13:33 <lambdabot>   1
01:13:39 <mun> bss_, but why is g = asTypeOf 1 a counter example when g isn't defined?
01:13:50 <siteswapper> :t const
01:13:50 <lambdabot> forall a b. a -> b -> a
01:14:38 <bss_> mun: Well, since "f" and "g" are not bound in your statement, I assumed they were universally quantified.
01:15:04 <c_wraith> mun, the only way to prove that assertion without defining f and g is to prove it for all f and g.
01:15:13 <bss_> mun: Which means it has to be true for *all* f and g.  So, if I can find one g for which it is false, the entire statement is false.
01:15:44 <bss_> mun: I suppose you might want them to be existentially qualified (a little odd, but possible).
01:16:06 <bss_> mun: In that case, it is trivially true with g = asTypeOf 0, e.g.
01:16:58 <bss_> mun: If it is existentally qualfied, it has to be true for *any specific choice* of f and g.  So, if I can find one g for which it is true, the entire statement is true.
01:17:05 <mun> ah right
01:17:20 <kmc> where does this problem come from?
01:20:41 <_1amzave> Hi, haskell newbie here, working through "Learn You a Haskell", and confused about some differences between its results and my own for the same input
01:20:53 <_1amzave> In ch. 11, LYAH shows:
01:20:53 <_1amzave> ghci> :t fmap (*3) (+100)
01:20:53 <_1amzave> fmap (*3) (+100) :: (Num a) => a -> a
01:21:09 <_1amzave> my ghci (v6.10.1) session, however, shows this:
01:21:10 <_1amzave> Prelude> :t fmap (*3) (+100)
01:21:10 <_1amzave> fmap (*3) (+100) :: (Num a, Functor ((->) a)) => a -> a
01:21:31 <_1amzave> what, if i may ask, gives?  some change between GHC versions or something?
01:21:41 <siteswapper> :t fmap (*3) (+100)
01:21:43 <lambdabot> forall a. (Num a) => a -> a
01:21:50 <kmc> _1amzave, you don't have the module which provides that instance loaded
01:21:55 <bss_> Must be a ghc change.
01:22:08 <bss_> I'm getting the same "Functor" notation in my ghci.
01:22:10 <Ytinasni> kmc: shouldn't that type happen even _with_ the instance loaded?
01:22:26 <JoshTriplett> I get the same thing in ghci, with GHC 6.12.1.
01:22:33 <Starfire> Importing Control.Monad.Instances will give you the shorter type signature.
01:22:34 <quicksilver> it's nothing to do with ghci versions
01:22:35 <kmc> Ytinasni, no, context reduction is performed
01:22:36 <bss_> Ah yeah.
01:22:45 <quicksilver> it just depends whether the instance is in scope or not
01:22:47 <kmc> for example you never see (Ord Int) in a signature
01:22:49 <bss_> You have to load Control.Monad.Instances, right?
01:22:53 <kmc> 'cause that instance is (usually) always visible
01:22:54 <Ytinasni> ah.
01:23:09 <geheimdienst> in this case, you don't need to worry about it. that just indicates that "a" is also an instance of Functor ((->)). the important thing for you is that it's a Num just like in lyah. don't worry about what other things it is :)
01:23:16 <kmc> the stuff in the context is theoretically passed "at runtime", i.e. not visible at compile time
01:23:47 <_1amzave> ah...braindeath on my part, sorry -- missed that part, despite it being right in front of me (didn't have Control.Monad.Instances loaded)
01:23:56 <_1amzave> thanks
01:23:57 <c_wraith> I didn't think LYAH would have that example in it.
01:24:24 <c_wraith> the function instance of Functor is a little more opaque than most
01:25:22 <bss_> I like simple stuff like:
01:25:36 <bss_> >fmap (*3) $ Nothing
01:25:42 <bss_> > fmap (*3) $ []
01:25:44 <lambdabot>   []
01:25:45 <bss_> > fmap (*3) $ [1,2,3]
01:25:47 <lambdabot>   [3,6,9]
01:25:56 <bss_> > fmap (*3) $ Just 4
01:25:57 <lambdabot>   Just 12
01:27:20 <Starfire> > (fmap fmap fmap) (*3) (+) 1 2
01:27:20 <lambdabot>   9
01:28:12 <bss_> :t fmap fmap fmap
01:28:13 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:28:18 <siteswapper> :t fmap
01:28:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:28:58 <bss_> :t (fmap fmap fmap) (*3)
01:28:59 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Functor f, Functor f1, Num a) => f (f1 a) -> f (f1 a)
01:29:09 <bss_> :t (fmap fmap fmap) (*3) (+)
01:29:10 <lambdabot> forall a. (Num a) => a -> a -> a
01:29:17 <Nibble> is advertising against the rules on this network_
01:29:44 <Nibble> I have a user who sent me a link to free poker chip moneyt
01:29:46 <Nibble> money*
01:29:54 <bss_> Nibble: inkk?
01:29:59 <quicksilver> it's certainly against the rules of this channel.
01:30:11 <bss_> Nibble: Please report him, there's been a few complains already.
01:30:15 <Nibble> bss_: yes.
01:30:17 <Zao> I'd bother a staffer but I'm busy "working" :D
01:30:19 <Nibble> bss_: how do I?
01:30:58 <bss_> Um, not sure.  I think the staff members are in some channel... maybe #helpdesk?
01:31:10 <tensorpudding> #freenode, maybe/
01:31:27 <Nibble> bss_: only you in #helpdesk lol?
01:31:52 <Zao> http://freenode.net/policy.shtml#advertising
01:32:57 <bss_> It's 03:30 here guys.
01:33:06 <bss_> I got to try and get some sleep.
01:33:16 <bss_> Have fun.
01:48:34 <osaunders> Are definitions referred to as variables in Haskell? (foo = 1)
01:48:50 <kmc> yes, as in maths
01:49:31 <kmc> but they are more like variables in maths than in most other programming languages
01:49:43 <kmc> they are names for values, not names for locations where values can be stored
01:50:16 <ksf> I'd only call argument bindings variables.
01:50:17 <kmc> they "vary" in that you might call (f 2) and then (f 3) and the x in «f x = ...» is different each time
01:50:28 <ksf> so f is a definition, x is a variable.
01:50:37 <kmc> but they don't vary in the sense of being able to set them directly, as an action
01:50:41 <ksf> ...both are bindings.
01:51:03 <kmc> that's reasonable
01:51:12 <kmc> you might also call x a "formal parameter" of f
01:51:20 <kmc> and when you call (f 2), 2 the "argument"
01:51:53 <kmc> "declaration" is a syntactic concept.  the things inside "let" or at top level are declarations
01:59:36 <wioux> is it normal to get a buttload of warnings whilst building the haskell-platform?
01:59:58 <ksf> yep. most should be harmless.
02:00:15 <ksf> in fact, all should be harmless or the maintainers did something wrong.
02:00:37 <wioux> most are deprecation, i think.. its going pretty fast :)
02:00:40 <ksf> -Wall gets stricter and stricter with each release, and not everybody updates the code in time.
02:00:58 <chrisdone> check this http://gist.github.com/507864
02:01:13 <ksf> at least -Werror isn't socially acceptable, anymore.
02:01:38 <chrisdone> I hit C-c C-c and it runs cabal build, but copies the .o files to src/. so loading a whole project in GHCi will be instant
02:01:53 <chrisdone> haven't figured out how to tell cabal build to use the odir that I want but
02:02:38 <ksf> --builddir=
02:03:05 <chrisdone> that's the builddir
02:03:20 <ksf> that's dist.
02:03:21 <chrisdone> --ghc-options="-odir=src/" doesn't work either
02:03:30 <ksf> and that's where the .os end up
02:03:38 <chrisdone> yeah, and everything else
02:03:57 <kmc> ghc added a warning for ignoring monadic results of type other than ()
02:04:04 <kmc> which causes a boatload of warnings
02:04:14 <chrisdone> most people disable it though
02:04:33 <chrisdone> actually i leave it on unless i'm using parsec
02:04:43 <ksf> it's good practice to -Wall the source and remove all warnings before a release.
02:04:56 <ksf> hell you don't have to _develop_ with -Wall -Werror
02:05:05 <chrisdone> i do
02:05:40 <chrisdone> eventually you even *write code properly the first time!* :o
02:05:44 <ksf> although vim kinda makes me use an implicit -Werror all the time, even without -Wall.
02:06:07 <ksf> ...because I don't want the cursor to jump to random positions when hitting :mak
02:06:22 <etpace> > foldl (\acc x -> acc >> print x) (return ()) [1..10]
02:06:23 <lambdabot>   <IO ()>
02:08:01 <chrisdone> cabal build -v --ghc-options="-odir=src"
02:08:01 <chrisdone> /home/chris/Programs/bin/ghc -odir=src --make -o dist/build/confy/confy -hide-all-packages [...] -odir dist/build/confy/confy-tmp
02:08:12 <chrisdone> what's the point of passing ghc-options if they're going to get overridden?
02:08:27 <chrisdone> i'm passing them because i *know* what i want
02:08:53 <ksf> can't you tell ghci to load the .os from dist?
02:09:21 <chrisdone> possibly
02:09:49 <chrisdone> bit more of a pain in the rear though
02:10:39 <chrisdone> dist/build/[where?]/[where?]-tmp/
02:20:06 <mun> what is a correct logical way to express that there exists a strict minimum of a function 'f'? how about \exists x. \forall y. x ~= y --> f x < f y? I think something is wrong because i recall having an existential variable on both sides of the implication isn't a good thing...
02:21:10 * hackagebot fclabels 0.9.0 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-0.9.0 (SebastiaanVisser)
02:24:57 <kmc> why isn't that a good thing?
02:25:22 <kmc> if you like, you can rewrite the implication
02:26:10 <kmc> ∃x. ∀y. x ≠ y → f x < f y
02:26:22 <kmc> ∃x. ∀y. (x = y) ∨ (f x < f y)
02:28:09 <kmc> classically, at least.  don't think it's constructively valid
02:28:59 <kmc> @djinn ((a -> Void) -> b) -> Either a b
02:28:59 <lambdabot> -- f cannot be realized.
02:29:13 <kmc> @djinn (a -> b) -> Either (a -> Void) b
02:29:13 <lambdabot> -- f cannot be realized.
02:30:46 <mun> kmc, why is it not constructively valid?
02:33:04 <kmc> well i'm not sure that it's not
02:33:44 <kmc> ("it" here is the conversion from (A → B) to (¬A ∨ B))
02:34:02 <kmc> i think if it were valid, djinn would have found a proof
02:34:39 <mun> right
02:34:41 <kmc> the obvious way to write a term of type «(a → b) → Either (a → Void) b» uses first-class continuations
02:35:21 <kmc> and call/cc is equivalent to Peirce's Law
02:35:33 <kmc> constructive logic plus Peirce's Law is classical logic
02:35:57 <kmc> as a side note, do we get anywhere thinking of Cont as a modal operator for "classically provable"?
02:38:27 <quicksilver> it's intuitionistically incorrect, and the kripke counter model looks like this : { (A) ---> (A,B) }
02:40:18 <kmc> this is a Kripke frame?
02:40:23 * copumpkin yawns
02:41:34 <mun> kmc, it just occurs to me that if I had "EX x. ALL y. x != y --> f x < fy" and "ALL x. (ALL y. x != y --> f x < f y) --> g x = 0" then I can't prove "EX x. g x = 0"
02:41:48 <mun> kmc, but I can find a proof I had "EX x. ALL y. f x < fy" and "ALL x. (ALL y. f x < f y) --> g x = 0" instead
02:41:55 <CakeProphet> So.. composable objects?
02:43:11 <kmc> «∃x. ∀y. f x < f y» is not true for any f (for the usual meaning of < wrt a partial order ≤)
02:43:20 <CakeProphet> coordA = getter "x" +& getter "y" 
02:44:01 <blueonyx> what does Occurs check: cannot construct the infinite type: a = [(a, [a])] mean?
02:44:08 <kmc> likewise (dually?) «∀x. (∀y. f x < f y) → g x = 0» is trivial, the antecedent is false
02:44:22 <kmc> blueonyx, it means you tried to use something as if it had type t and simultaneously type [(t, [t])]
02:44:25 <kmc> this is a contradiction
02:44:56 <kmc> it's allowed in some formal systems as an "infinite type", for example the solution to «t = [t]» is [[[[[[[[...]]]]]]]], i.e. list of lists of lists of lists of ...
02:45:05 <blueonyx> ah thanks
02:45:08 <kmc> but Haskell disallows these because they're almost always the result of programmer error
02:45:20 <kmc> and you can build infinite types with wrappers if you really need them
02:46:46 <CakeProphet> GADT could be used to represent object type. 
02:47:45 <blueonyx> i cant spot the programmer error in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28545#a28545 
02:47:51 <CakeProphet> foldr (&+ [getter "x", getter "y"]
02:48:40 <kmc> CakeProphet, have you seen the "records" library?
02:49:06 <CakeProphet> kmc:  no.
02:49:19 <CakeProphet> blueonyx:  the second guard on the function f returns an invalid type
02:49:27 <CakeProphet> should be a tuple.
02:50:11 <CakeProphet> blueonyx:  both guards actually.
02:51:05 <blueonyx> f should return a list, as its the result of the fold o.O
02:51:22 <kmc> well f returns the accumulator type for the fold
02:51:27 <kmc> which is [(a,[a])]
02:51:36 <kmc> which is a list
02:52:03 <kmc> did you mean for f to call itself explicitly?
02:52:08 <kmc> even though it's also being used in a fold?
02:52:31 <blueonyx> yep
02:53:17 <blueonyx> it should mississippi => [(m,[]),(i,[i,i,i]),(s,[s,s,s]),(p,[p])]
02:54:02 <kmc> it's the first guard which makes it unhappy
02:54:08 <kmc> you can replace it with "undefined"
02:54:13 <kmc> and this error goes away
02:57:04 <kmc> hmm shouldn't «f a' bs» be «f bs a'»
02:57:25 <blueonyx> that gives another error
02:57:28 <blueonyx> but yea
02:57:29 <kmc> there is a second problem, which is your sig on f.  there's nothing tying that a to the a in groupBy''s sig
02:57:37 <kmc> so ghc will complain that a and a1 are not the same
02:57:42 <kmc> since it gives them each a fresh name internally
02:57:50 <kmc> iirc you can't write a sig on f in ordinary Haskell 98
02:57:54 <kmc> but you can turn on ScopedTypeVariables
02:58:00 <kmc> and write the sig «groupBy' :: forall a.  ...»
02:58:05 <kmc> and that brings a into scope
02:58:32 <blueonyx> ah
02:58:55 <blueonyx> i dont care for the sig, i just tried to hunt the error with it
02:59:06 <kmc> mm
02:59:41 <blueonyx> thanks again
03:00:36 <kmc> no prob :)
03:00:38 <p> hi all
03:00:41 <kmc> hi p
03:00:52 <p> hi kmc
03:01:20 * hackagebot labeled-tree 1.0.0.0 - Labeled tree structure  http://hackage.haskell.org/package/labeled-tree-1.0.0.0 (JeanPhilippeBernardy)
03:01:35 <Guest74141> any noobs here as well?
03:02:01 <Zao> Guest74141: No, just gurus, everywhere.
03:02:02 <Zao> <_<
03:02:05 <Guest74141> lol
03:02:09 <kmc> usually quite a few :)
03:02:39 <Guest74141> I just did the tutorial. NOt sure if I got everything straight...
03:03:15 <Guest74141> I guess I have to dive in using a book or so
03:03:21 <kmc> which tutorial?
03:03:39 <Guest74141> tryhaskell.org
03:03:42 <kmc> cool :)
03:03:55 <kmc> as for books i recommend LYAH and RWH
03:03:56 <kmc> @where LYAH
03:03:56 <lambdabot> http://www.learnyouahaskell.com/
03:03:57 <kmc> @where RWH
03:03:58 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:05:00 <Guest74141> I'll need haskell for work...How long do you think will it take to use it properly. My experiences are limited to Java and a bit of C. 
03:05:28 <Guest74141> I just hope I'm not too stupid for it...It's kind of a different ;-)
03:05:46 <ivanm> where's preflex? :o
03:05:56 <kmc> you need Haskell for work?
03:06:09 <kmc> there is a steep learning curve
03:06:24 <Guest74141> I can imagine
03:06:29 <byorgey> Guest74141: it will probably take a while to feel comfortable with it.  But I doubt you are too stupid for it.
03:06:37 <kmc> but i think most programmers are smart enough to learn Haskell... you just have to be persistent and willing to think a new way
03:06:46 <byorgey> Guest74141: you might feel stupid occasionally however.  This is normal; it is the feeling if your brain growing
03:06:50 <byorgey> *of
03:07:12 <kmc> it is better to feel stupid and then smart when you crack the puzzle
03:07:16 <kmc> instead of feeling meh about your code all day
03:07:18 <copumpkin> nah, most programmers are too stupid to program in anything
03:07:21 <byorgey> Guest74141: feel free to ask lots of questions here.
03:07:24 <kmc> copumpkin, maybe so
03:07:26 <copumpkin> the other languages just let them do it anyway
03:07:27 <ivanm> Disclaimer: physical brain growth guaranteed, and if it does indeed occur you may wish to consult a qualified physician.
03:07:33 <Guest74141> lol
03:07:47 <ivanm> copumpkin: I'm tutoring someone that goes by the nickname of "pumpkin" apparently :s
03:07:54 <copumpkin> ivanm: omg
03:07:56 <kmc> Guest74141, one way to put it is:  it's hard to write correct programs, no matter what language you use.  Haskell makes it harder to write incorrect programs
03:08:06 <Guest74141> ha good to know!
03:08:19 <copumpkin> we should all use BobX http://thedailywtf.com/Articles/We-Use-BobX.aspx
03:08:30 <kmc> so things get a bit harder overall, but your odds of producing a working program go way up
03:08:32 <ivanm> copumpkin: heh, did you read the comments?
03:09:06 <copumpkin> I read the top-rated one :P
03:09:13 <Guest74141> well thx for your thoughts! I'll come back if I need 'real' help ;-)
03:09:19 <kmc> good luck Guest74141 :)
03:09:22 * hackagebot fclabels 0.9.1 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-0.9.1 (SebastiaanVisser)
03:09:25 <copumpkin> I'm just kidding about most programmers being too stupid btw
03:09:34 <ivanm> copumpkin: a lot of people claimed that they'd used BobX, but it was better known as "ColdFusion"
03:09:42 <copumpkin> lol
03:10:45 <Guest74141> thx again...bye
03:10:53 <copumpkin> buhbye
03:17:08 <kmc> copumpkin, i think most programmers are too stupid to immediately see why FP is useful and worth studying
03:17:55 <kmc> it certainly wasn't obvious to me
03:18:41 <kmc> and so "most people don't learn FP" is an issue of motivation, and to some extent a failure of teaching, but not so much about ability
03:18:48 <copumpkin> yeah
03:19:08 <Zao> My reaction to our first-year FP course was "this language is stupid, where's my variables?"
03:19:11 <kmc> i think you can also argue that most of us are too stupid to really consistently write correct code
03:19:18 <kmc> everyone writes code with bugs
03:19:42 <Zao> Of course, it was in Moscow ML, so there were no lazyness gains either.
03:21:14 <kmc> Zao, it's interesting to teach Scheme first as a pure language, and then introduce mutation
03:22:27 <mjrosenb> kmc: that's how i learned sml
03:23:21 <mjrosenb> then again, sml had a rather different goal from scheme
03:23:33 <kmc> in the first part people struggle with writing code
03:23:33 <CakeProphet> kmc:  structure and interpretation of computer programs. :)
03:23:43 <kmc> in the second part they struggle with understanding what the code they've written does
03:24:18 <kmc> "life was so simple before you introduced these f*cking environment diagrams"
03:24:53 <mjrosenb> kmc: environment diagrams?
03:25:24 <kmc> a graphical representation of the heap, used in SICP
03:25:51 <kmc> in the first (pure) half of the course, evaluation by hand consists of simple substitution, just beta-reduction basically
03:26:07 <kmc> in the second half you have to draw out diagrams, because now you care about identity and state as well as value
03:26:26 <kmc> and the students absolutely hate it, and many drop the course at that point
03:27:19 <kmc> the diagrams are kind of intrinsically a pain in the ass (xfig anyone)
03:27:26 <mjrosenb> yeah... pretty sure we never did anything like that
03:27:44 * mjrosenb remembers aliza complaining about xfig
03:28:12 * mjrosenb diagrammed an r2000 in xfig; everything else seems simple
03:28:17 <kmc> haha
03:28:19 <kmc> indeed
03:28:50 <earthy> ttp://jjc.hydrus.net/cs61a/handouts/envdiag1.pdf eeewwwwww.
03:29:07 <earthy> (add the h, obviously)
03:31:02 <mjrosenb> i suppose writing a program to generate those for you is strongly encouraged, but nobody ever does it
03:32:10 <quicksilver> make them learn TeX and do the diagramming procedurally.
03:33:30 <kmc> many people wrote a program to do the substitution model evaluation
03:33:40 <kmc> don't know anyone who did it in Scheme, though you could just skip to the end of the book ;)
03:33:49 <kmc> mjrosenb, i wish i'd taken CPU architecture
03:33:53 <kmc> how detailed was your R2000 diagram?
03:34:19 <theorbtwo> Since, by the end, you will write a scheme interpreter in scheme, you could pretty easily make the diagrams as a side-effect.
03:34:39 <kmc> eh, i think laying out the diagram in a halfway presentable way is a large unrelated problem
03:34:44 <kmc> graphviz would make a mess of it
03:35:01 <kmc> also intro CS at Caltech didn't get that far, it pretty much ended right before the cool stuff starts in SICP :/
03:35:05 <ivanm> quicksilver: bah, do postscript output directly! ;-)
03:35:29 <kmc> it may be better now, since they've split it into "friendly useful programming in Python" for everyone, plus the SICP course now for CS majors / other interested persons only
03:35:49 <mjrosenb> kmc: we made it more or less directly from the verilog, so pretty detailed
03:35:52 <theorbtwo> I'm not sure that makes much sense unless you skip the first half of SICP.
03:37:29 <kmc> yeah i bet they go pretty fast, can't find the syllabus atm :/
03:39:03 <kmc> ghc uses a lot of memory when you turn on -O2 and feed it all the files in base at once
03:39:08 <blups0r> is there a way to get the last value a funktion returned and use it in that funktion?
03:39:21 <blups0r> something like it in ghci
03:39:31 <kmc> blups0r, sounds like you want to keep some state between function calls?
03:39:44 <tolkad> It seems that Network uses Strings rather than ByteStrings...
03:39:49 <blups0r> something like that
03:39:51 <tolkad> is there any way to use ByteStrings?
03:40:03 <Zao> tolkad: I believe there's packages for that.
03:40:05 <kmc> blups0r, that makes it not a function, in the mathematical sense, and hence in the Haskell sense
03:40:07 <Zao> network-bytestring or somesuch.
03:40:20 <Zao> kmc: function and "function" :D
03:40:39 <Starfire> How often does hackage generate haddocks for uploaded libraries?
03:40:48 <kmc> however you can return an action in some kind of state-manipulating monad (State, IO, ST, ...)
03:41:07 <kmc> and that action could use the state primitives to get at its last result
03:41:14 <kmc> blups0r, what are you trying to do?
03:41:16 <copumpkin> Starfire: once a day or so I thnk
03:41:20 <Starfire> OK.
03:41:42 <tolkad> is there any way to read from a socket with a timeout?
03:41:52 <Starfire> I'm waiting to check out the new version of fclabels, but I don't have a clue how to generate the Haddocks myself.
03:42:21 <kmc> Starfire, "cabal haddock" i think
03:42:27 <kmc> tolkad, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-Timeout.html
03:46:16 <tolkad> kmc: is there any way to do it without creating a new thread??
03:47:01 <Cale> Starfire: If you put the line  documentation: True  into your ~/.cabal/config then cabal will automatically generate docs for you
03:47:37 <Starfire> Cale: I tried that once (on Windows), with poor results. Perhaps it'll work better on this Linux box.
03:47:46 <blups0r> i am trying to build a trie
03:47:50 <Starfire> kmc: 'cabal haddock' worked, thanks!
03:47:52 <Cale> (under ~/.cabal/share/doc/index.html)
03:47:58 <blups0r> but i think i solved it by another way
03:48:26 <Starfire> Cale: Does it also properly link into base etc. ?
03:49:23 <Cale> Starfire: I think it should, if the documentation for base is installed.
03:49:56 <Cale> Mine currently doesn't, but I think it's because I messed with my GHC installation a while back and didn't bother fixing the documentation.
03:50:27 <Starfire> I think when I tried it on Windows, several cabal packages stopped building because haddock would fail.
03:50:52 <Starfire> But I'm not 100% sure. All I remember is that something went wrong and I had to remove 'documentation: True'
03:51:54 <tolkad> kmc: in Java you could interrupt the IO rather than having to kill the thread... is there any way to do that?
03:54:01 <kmc> er, are you referring to an implementation detail of System.Timeout?
03:55:24 <kmc> using System.Timeout does not require you to create a new thread
03:55:24 <tolkad> I'm not sure, I just want to do the equivalent of calling thread.interrupt() and catching an InterruptedIOException in Java
03:55:47 <kmc> timeout does that for you
03:55:56 <kmc> anyway i thought you just said you don't want to make a new thread
03:56:12 <kmc> but your java example involves you doing explicitly what "timeout" does for you
03:56:22 <tolkad> yeah, I want to do it in an existing thread
03:56:27 <tolkad> not run the IO in a new one
03:56:32 <kmc> timeout does it in an existing thread
03:56:38 <kmc> it spawns a new thread to do the killing
03:56:42 <kmc> but also, why do you care which thread?
03:56:58 <kmc> since you don't have to write the threading code
03:57:54 <tolkad> so I can keep a thread pool for efficiency
03:57:56 <blups0r> ive got a compile problem 
03:57:57 <blups0r> http://pastebin.com/TGJ9q7Kn
03:58:08 <kmc> tolkad, GHC already does that for you
03:58:16 <kmc> GHC's threads are lightweight, you can easily spawn 100,000 of them
03:58:26 <blups0r> the error message is 
03:58:27 <blups0r> trie.hs:62:42:
03:58:28 <blups0r>     Couldn't match expected type `a -> Trie a -> [String]'
03:58:28 <blups0r>            against inferred type `[String]'
03:58:28 <blups0r>     In the first argument of `insertStrLst', namely `(xs val gen)'
03:58:28 <blups0r>     In the expression: insertStrLst (xs val gen)
03:58:28 <blups0r>     In the definition of `insertStrLst':
03:58:28 <blups0r>         insertStrLst (x : xs) val tr
03:58:29 <blups0r>                        = insertStrLst (xs val gen)
03:58:29 <blups0r>                        where
03:58:30 <blups0r>                            gen = insert x val tr
03:58:31 <blups0r> Failed, modules loaded: none.
03:58:39 <tolkad> kmc: oh, that's nice... it's different in Java
03:58:39 <ivanm> blups0r: next time, paste the error with your code
03:58:40 <ivanm> not here
03:58:41 <kmc> blups0r, can you hpaste that instead of sending it to the channel?
03:58:49 <kmc> tolkad, yes, many things are different in Java ;P
03:58:55 <Cale> blups0r: It looks like you're applying xs as a function to val and gen
03:59:14 <Cale> blups0r: Are you sure that you didn't mean insertStrList xs val gen?
04:00:47 <blups0r> thanks that was it
04:02:17 <tolkad> Does GHC have thread interrupting though? in Java interrupting a thread stops all IO or sleep operations and throws an interrupted exception within the thread if one of those operations had been occuring
04:02:44 <kmc> you can throw an asynchronous exception to a thread
04:02:56 <kmc> you can read the source for System.Timeout; it's rather short
04:03:09 <kmc> basically i think it already solves the problem you're trying to solve
04:03:16 <kmc> without you needing to muck about with threads explicitly
04:03:26 <aleator> fasta: Ok. I'll try and see if it still happens with newer ghc
04:08:05 <tolkad> but what if I want to wait longer than 10^6 seconds?
04:10:01 <benmachine> wait twice?
04:11:33 <kmc> you can only wait (maxBound :: Int / 10^6) seconds
04:12:20 <Ke> @type maxBound
04:12:21 <lambdabot> forall a. (Bounded a) => a
04:12:32 <kmc> which could be as little as 536 seconds, though in practice it'll be at least 2147 seconds, and 292,277 years on a 64-bit machine
04:12:39 <kmc> it is a flaw in the API though
04:12:56 <kmc> you can rewrite "timeout" yourself and call threadDelay over and over
04:14:01 <benmachine> threadDelay should take an Integer really imo
04:14:09 <kmc> yeah
04:14:44 <benmachine> http://hackage.haskell.org/packages/archive/concurrent-extra/latest/doc/html/Control-Concurrent-Timeout.html oh hello
04:20:53 <benmachine> :t (<=< id)
04:20:55 <lambdabot> forall b (m :: * -> *) c. (Monad m) => (b -> m c) -> m b -> m c
04:21:32 <zygoloid> iirc reactive has a threadDelay wrapper which takes an Integer
04:22:30 * benmachine worked out last night in bed that defining Kleisli composition was sufficient to recover bind
04:23:40 <dancor> ...in bed!
04:24:18 <kmc> @ghc
04:24:18 <lambdabot> ghc says: magic number mismatch: old/corrupt interface file?
04:24:21 <kmc> in bed!
04:24:40 <benmachine> :P
04:25:33 <tolkad> @tolkad
04:25:34 <lambdabot> Unknown command, try @list
04:25:37 <tolkad> @quote tolkad
04:25:38 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
04:25:56 <kmc> hahaha
04:26:03 <kmc> are you sure you want to be known for saying something like that
04:26:46 <zygoloid> PHP: practical haskell pages?
04:27:06 <zygoloid> can't be referring to the /other/ PHP :)
04:27:07 <kmc> polymorphic hylophunctor
04:27:37 <zygoloid> polyhedral hadron pummeler
04:29:29 <tolkad> kmc: but PHP has such beautiful inconsistencies and inconveniences! like the way you cant do new Foo()->func(), or the lack of array dereferencing
04:30:27 <benmachine> array dereferencing?
04:31:08 <tolkad> function func(){return array(5);} echo func()[0]; //doesn't work
04:31:24 <tolkad> you have to assign the result of func() to a variable and then access it as an array
04:33:37 <koala_man> all the features of an embedded system's scripting language from the 80s
04:35:44 <akamaus> and people use it )
04:36:47 <kmc> yup
04:36:58 <kmc> because it's easy to get started and there's good documentation with examples
04:38:04 <koala_man> it's also easy to get started on pot, but that doesn't make it a good career choice
04:38:17 <kmc> depends which career
04:39:09 <quicksilver> koala_man++
04:39:10 <kmc> i think learning PHP is a fine career choice if you want to make some decent money at a decent job where you get to sit down in an air-conditioned room
04:39:31 <kmc> programming doesn't have to be an all-consuming hobby / intellectual/spiritual pursuit
04:40:08 <ivanm> it doesn't?
04:40:13 <ivanm> damn, _now_ you tell me! :s
04:40:26 <zachk1> but math does right kmc? ;) 
04:40:53 <kmc> well plenty of people dabble in math
04:40:56 <kmc> myself included
04:41:03 <kmc> but i don't think you can get paid to do math unless you care a whole lot
04:41:11 <kmc> you can get paid to program even if you don't give a shit at all
04:41:15 <akamaus> kmc, or they use it because _much_ is done in php already
04:41:20 <kmc> yeah
04:41:35 <Gracenotes> oh dear, "strange closure type 5640"
04:42:05 <akamaus> >  you can get paid to program.. 
04:42:05 <lambdabot>   <no location info>: parse error on input `..'
04:42:07 <akamaus> indeed
04:42:11 <Gracenotes> not gonna be able to reproduce that one..
04:42:35 <ToRA> Gracenotes: what are you doing?
04:43:32 <Gracenotes> it's with a happstack server that's intended to run in perpetuity
04:43:36 <zachk1> can i get a job coding haskell? 
04:44:08 <kmc> zachk1, there are a few
04:44:10 <ToRA> Gracenotes: oh. wow.
04:44:12 <kmc> very competitive
04:44:36 <kmc> the best way might be to start your own company
04:44:50 <Gracenotes> I've been recompiling the source rather heavily while it was still running. if GHC tried to peek into an interface file, then that might explain it
04:45:44 <akamaus> kmc, this way you get the job, but not necessary the money
04:49:18 * copumpkin starts his own company for haskell coding
04:49:45 <copumpkin> it's called "fuck around with haksell at your parents' house doing random things nobody but you cares about, inc."
04:50:02 <ivanm> lol
04:50:08 <ivanm> copumpkin: what are you going to be doing
04:50:09 <koala_man> are you hiring?
04:50:10 <ivanm> ?
04:50:10 <luite> sounds fun, have you been able to secure some venture capital? :p
04:50:10 <aleator> I've got a big switchboard in my program that maps strings to IO () functions and it is getting tedious to maintain. Is there any ghc trick other than using th to build the switchboard?  
04:50:18 <ivanm> consultancy or selling actual packages?
04:50:33 <copumpkin> ivanm: in stealth mode for now, can't tell you
04:50:48 <kmc> aleator, other preprocessors
04:50:52 <copumpkin> koala_man: sure, send your resume to me and paypal 500 bucks (application processing fee)
04:51:00 <kmc> CPP or something you write custom
04:51:23 <benmachine> what's wrong with TH :P
04:51:28 <kmc> heh
04:51:31 <kmc> many things are wrong with TH
04:51:49 <benmachine> okay but apart from them :(
04:51:54 <aleator> kmc: I was hoping it wouldn't come to that. Previous version was based on hint (ie. 160 node cluster waiting to interpret anything I throw at it) but it was too slow.
04:51:56 <benmachine> are they just bugs, or conceptual issues?
04:52:19 <kmc> there are useful bits of the TH paper which are not implemented
04:52:28 <kmc> and there are things GHC's TH does that are arguably bugs
04:52:32 <benmachine> ah okay
04:52:48 <benmachine> when are we getting revdeps on officialhackage
04:52:49 <kmc> and it's an inherently cumbersome sort of thing
04:53:15 <aleator> Is there anything in ghc api that could resolve strings to functions in the running executable?
04:53:51 <aleator> I can do that with foreign export and llvm easily, but that is also tedious
04:53:54 <kmc> aleator, well, you can use hint for that.  it will load compiled modules, just like ghci will
04:54:03 <kmc> i'm not sure why that would be slow
04:54:19 <aleator> kmc: Wait. It loads compiled modules also?!
04:54:25 <kmc> just like ghci will
04:54:33 <aleator> ghci does that too?
04:54:36 <kmc> yeah
04:54:56 <kmc> when you do like ":m + Data.List" it loads the compiled Data.List module
04:55:04 <aleator> So I compile with all the fancy options and is as fast as --make?
04:55:09 <kmc> the modules it's interpreting are shown in the prompt with * by default
04:55:23 <kmc> aleator, just make sure that wherever ghci / hint is looking for your .hs file, there is an up to date .o and .hi file
04:55:38 <kmc> if the .hs file is newer, they will fall back to interpreted
04:56:07 <aleator> Well. This solves my problem.
04:56:32 <quicksilver> kmc: *pedantic* - Data.List is already available. All :m + does is change the scope.
04:56:41 <kmc> hmm, true
04:56:43 <aleator> .. beside the fact that I now need to figure out how to send *.o's and *.hi's to all my nodes..
04:56:44 <Gracenotes> hm, I'm getting to an 850-line module. I suspect this is too much.
04:57:12 <aleator> kmc: thanks!
04:57:23 <benmachine> can haddock run TH and therefore arbitrary IO?
04:57:43 <kmc> think so, i think this is regarded as a bit of a hole ;)
04:57:50 <kmc> it must be disabled on hackage tho
04:57:55 <benmachine> it must be!
04:58:03 <benmachine> I hope so, anyway.
04:58:34 <benmachine> well hackage does build stuff, I think that happens in a chroot?
04:58:54 <benmachine> (building stuff *definitely* needs arbitrary IO, cos Build-type: Custom)
05:00:37 <Gracenotes> there is a dedicated buildbot 
05:00:56 <Gracenotes> which will soon be replaced by clients uploading their own stuff. once cabal support for it all is ironed out.
05:01:04 <Gracenotes> cabal-install support I should say
05:04:35 <aleator> kmc: Hmm. I still seem to be getting 30% slower runtime when launching with ghci instead of from compiled executable.
05:04:55 <kmc> hmm, does ghci indicate that it loaded the compiled code?
05:06:31 <aleator> kmc: ah. it seems to always interpreting the file it receives on command line
05:06:35 <aleator> lets try another way
05:07:28 <quicksilver> I think if you chop off the .hs part of the name
05:07:33 <quicksilver> then it will prefer compiled
05:07:49 <quicksilver> ghci Foo.hs -- loads interpreted; ghc Foo -- will load Foo.o if available ?
05:07:52 <quicksilver> I'm not sure.
05:08:08 <aleator> quicksilver: doesn't seem to.
05:09:47 <aleator> quicksilver: No wait.. My bad. I've got a something that always forces recompilation.
05:09:52 <quicksilver> ;)
05:10:27 <aleator> quicksilver: Well, it was fun idea to use TH to pick up git version tags, which needed forcing recompilation..
05:11:46 <aleator> Now it does not interpret but the speed difference is about the same.
05:13:19 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28546#a28546 giggle
05:17:37 <h_noob> hi there
05:17:44 <ivanm> copumpkin: hmmm...
05:17:49 <copumpkin> ?
05:18:05 <h_noob> is it possible to debug parsec parser to see which component consumed what?
05:18:28 <kmc> h_noob, perhaps Debug.Trace would be useful
05:18:41 <kmc> @quote oasis
05:18:41 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
05:19:13 <copumpkin> omg a TacticalGrace 
05:19:41 <ivanm> copumpkin: I just got your last message to me about stealth mode
05:19:46 <copumpkin> oh
05:20:03 <quicksilver> gah, trace--
05:20:15 <quicksilver> h_noob: I would just run sub-parsers against the input in ghci
05:20:25 <quicksilver> then you can easily see what's consuming what
05:20:48 <benmachine> maybe strategic insertions of fail can help you go "definitely not this"
05:21:17 <h_noob> kmc: thanks, I'll take a look
05:21:41 <h_noob> quicksilver: you mean to load module and than manually apply parsers?
05:22:06 <h_noob> quicksilver: the thing is - I'm afraid to pick the wrong order while doing so
05:22:37 <quicksilver> I can't really understand why you'd be afraid of that.
05:22:55 <quicksilver> but then I can't really understand how you can be in doubt about which component consumed what ;)
05:23:45 <zygoloid> benmachine: that's great :)
05:25:08 <h_noob> quicksilver: I use parseCrap on content of file - this top-level parser calls other parsers for heavily nested structures and eventually hit eof saying "unexpected end of input" - I guess it's because some parser somewhere consumed something wrong
05:26:04 * quicksilver nods
05:26:10 <quicksilver> well try Debug.Trace by all means ;)
05:26:49 <ivanm> h_noob: you literally have a function called "parseCrap"? :o
05:26:53 <kmc> with parsec3 you can probably gimmick it to trace itsely
05:26:59 <kmc> with a custom Stream or something
05:27:28 <h_noob> ivanm: for internal use only :)
05:28:26 <h_noob> kmc: I'm using lexical parsing via makeTokenParser - how do I use "custom Stream" and what is it actually?
05:29:01 <kmc> my idea is half-baked enough that i'll let someone who knows parsec3 work out whether it's actually sensible :)
05:32:32 <aleator> Are there any other possible speed 'gotchas' with ghci/hint? I can't make the same function in the same module (compiled) run at even near the same speeds when going through hint
05:33:38 <aleator> than using directly compiled one
05:40:29 <boegel> BONUS: ping
05:40:31 * benmachine belatedly hugs zygoloid 
05:41:45 <zygoloid> \o/
05:43:23 <Cale> aleator: weird
05:43:34 <Cale> aleator: You're using a compiled .o file with hint?
05:44:24 <aleator> Cale: Yes. Though I think I might have figured it out.
05:44:48 <aleator> Cale: The same gc parameters do not work for both direct and non-direct and my program is very picky on those
05:47:15 <h_noob> can somebody take a look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28547#a28547 - this parser fails on such a trivial example that I think I'm missing something very obvious
05:47:42 <h_noob> general comments on code crappiness are also welcomed :)
05:53:18 <benmachine> h_noob: are you expecting the [(key, val)] line to match more than once?
05:55:05 <h_noob> benmachine: it should return list of pairs like [(key1,val1), (key2,val2)...]
05:56:05 <benmachine> but your pattern match in the do is against a list with one element
05:56:06 <quicksilver> h_noob: the pattern [(key,val)] only matches a list containing a single pair
05:56:22 <h_noob> doh!
05:56:25 <quicksilver> and when that pattern match fails that calls failure in the monad, which in parsec's case is a parse failure
05:57:20 <quicksilver> after I replace "[(key,val)]" with 'kvs' in both lines, the parser works for me on
05:57:25 <quicksilver> parse parseCrap "testparser" "[cluster:a2]\ncurrent_links_name=a2\nfoo=bar"
05:57:33 <quicksilver> which is roughly equivalent to your example.
05:58:27 <quicksilver> h_noob: I found that bug by testing various things in ghci
05:58:34 <quicksilver> h_noob: e.g. one of my test lines was:
05:58:43 <quicksilver> parse (many1 parseContent) "testparser" "current_links_name=a2\nfoo=bar"
05:58:55 <quicksilver> h_noob: that works, and that shows me that 'many1 parseContent' is basically OK.
05:59:05 <quicksilver> (although I was a bit surprised at the result)
05:59:25 <h_noob> quicksilver: why?
05:59:38 <quicksilver> didn't expect a2 to parse as 'String "a2"'
05:59:46 <quicksilver> but then it's got to be 15 years since I last looked at pike
05:59:55 <quicksilver> so maybe I didn't know what to expect ;)
06:00:16 <h_noob> quicksilver: it's more likely that I have no idea how to parse it properly :)
06:02:37 <h_noob> quicksilver: is there a better way to do it?
06:07:55 <quicksilver> h_noob: do what?
06:08:48 <ivanm> bens: #haskell.au !
06:09:02 <h_noob> quicksilver: parse things like "this could be string OR some nested piece of... code" without explicitely using "data Val = String String | Pike Pike deriving Show "?
06:09:13 <quicksilver> h_noob: no, that's fine.
06:09:30 <quicksilver> it's purely that unquoted a2 didn't look like a string to me
06:09:34 <quicksilver> but that's just because I don't know pike.
06:09:42 <bens> ivanm: hmm, I expected irssi to join automatically...
06:10:01 <h_noob> quicksilver: man, I'm practically hate it by now :)
06:10:11 <h_noob> I mean pike
06:10:41 <Starfire> If I have a class C, is it impossible to have instances C (m a) and C (a -> m b), where m is a Monad. ?
06:11:23 <quicksilver> well that overlaps if (->) is a monad.
06:11:26 <Starfire> GHC complains about conflicting family instances (I'm using type families), and a quick google suggests there is something fundamentally wrong with my approach.
06:11:34 <quicksilver> (and as it happens, -> is indeed a monad)
06:12:04 <Starfire> Hmmm.
06:12:09 <quicksilver> even if -> wasn't a monad, it would still be an overlap in principle, because type classes are open.
06:12:24 <quicksilver> (so it's always true that -> might be a monad...)
06:13:28 <Starfire> I'll probably have to use a newtype wrapper then.
06:14:32 <benmachine> Kleisli and ReaderT are both newtype wrappers around a -> m b in subtly different ways
06:14:51 <benmachine> and there ='s a WrappedMonad in Control.Applicative
06:15:01 <benmachine> but it may make more sense to us your own
06:15:09 <benmachine> - =
06:15:37 <Starfire> Hmm, apparently, adding a newtype does nothing to resolve the conflict.
06:15:54 <benmachine> might need two newtypes
06:16:04 <benmachine> or at least
06:16:16 <copumpkin> Starfire: overlapping instances help?
06:16:23 <benmachine> just newtyping a -> m b won't be sufficient
06:16:32 <Starfire> I'm trying to consciously avoid OverlappingInstances, if possible.
06:16:40 <benmachine> good man
06:16:40 <copumpkin> ah
06:16:43 <benmachine> (person)
06:16:45 <copumpkin> it's not that bad
06:16:49 <luite> is there an easy way to get the current time with microseconds or picoseconds? (I only need to compare times, so I don't care about time zones)
06:17:08 <quicksilver> getCurrentTime, diffUTCTime
06:17:13 <dolio> 'm a' instances are kind of questionable on their own. If you consider type classes to be definition by recursion on the structure of types, application of two variables is not exactly canonical.
06:17:43 <luite> quicksilver: ah I noticed just too late that the DiffTime data type has a higher internal precision
06:17:55 <Starfire> I guess I can just define two different operators, although it clutters the interface up somewhat.
06:18:04 <Starfire> But then again, the error messages will probably be better.
06:18:21 <quicksilver> dolio: well, for haskell types whether or not you are constructed with a type constructor is a structural property.
06:18:43 <quicksilver> however weird it seems when you think about it carefully.
06:18:55 <quicksilver> but you're still right that an instance for m a is odd.
06:19:13 <benmachine> what about type family application, does that count?
06:19:30 <quicksilver> only for associated data
06:19:31 <quicksilver> I think.
06:19:56 <quicksilver> (associated data is guarantee injective so it behaves like a type constructor? and associated 'type' is not? but I'm not sure).
06:20:30 <byorgey> right.
06:21:13 <quicksilver> associated data is still odd because it behaves like a type constructor but it's not a natural construction.
06:21:23 <quicksilver> that probably breaks stuff quite badly if you (ab)use it.
06:22:22 <byorgey> quicksilver: what do you mean by "it's not a natural construction"?
06:23:03 <ivanm> byorgey: by it being an artificial constructor!
06:23:04 <ivanm> duh
06:23:05 <ivanm> ;-)
06:23:19 <quicksilver> byorgey: we get some laws for free in haskell because universal constructs are automatically natural transformations in the categorical sense.
06:23:30 <HugoDaniel> i want to be a better haskell coder :/
06:23:46 <quicksilver> byorgey: if you write a parametrically polymorphic function over a type constructor like 'Either' or '[]' you cannot help but be natural.
06:23:54 <benmachine> HugoDaniel: this is not an unusual desire.
06:23:54 <quicksilver> that's where "theorems for free" come from.
06:23:54 <byorgey> quicksilver: oh, I see what you mean. yes.
06:24:01 <kmc> HugoDaniel, what do you want to learn?
06:24:22 <quicksilver> byorgey: you lose that with associated data, which 'looks like' a type construction but it's actually adhoc, instance per instance.
06:24:23 <HugoDaniel> stream fusion
06:24:36 <byorgey> quicksilver: right.
06:24:41 <dolio> forall a. D1 a -> D2 a for data families D1 and D2 should also be a natural transformation.
06:24:53 <benmachine> I'm not actually sure how polymorphic functions could be defined on a data family
06:24:59 <dolio> The only value of that type is undefined, I think.
06:25:03 <quicksilver> read one of dons' papers, or perhaps his thesis, HugoDaniel 
06:25:11 <benmachine> but then, there's a lot that I don't know about data families
06:25:17 <dolio> Unless D2 = D1, in which case id is also available.
06:25:22 <kmc> HugoDaniel, did you read http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
06:25:22 <HugoDaniel> quicksilver: thanks :)
06:25:33 <HugoDaniel> i started
06:25:58 <HugoDaniel> ok
06:26:04 <HugoDaniel> dons thesis seems like a good one to go also
06:26:57 <dolio> Was his thesis on stream fusion? I thought it was on plugins for some reason.
06:27:24 <HugoDaniel> i didn't even knew he had a thesis
06:27:38 <byorgey> he just wrote it.
06:27:54 <byorgey> or, just finished it at least.
06:33:16 <Paczesiowa> is drift the only way to derive NFData instances?
06:33:30 <ivanm> Paczesiowa: can derive do it?
06:34:02 <ivanm> @hackage derive
06:34:03 <lambdabot> http://hackage.haskell.org/package/derive
06:34:07 * kmc wonders if you can derive NFData from Data
06:34:18 <benmachine> I bet a syb traversal could... yeah.
06:34:54 <kmc> that'd be pretty godawful slow, i imagine
06:34:56 <hpc> that's a cool package
06:34:57 <Paczesiowa> benmachine: I've googled some email by Cale that said something about order of magnitude slowdown by using generics
06:35:07 <benmachine> the main problem I've found with that sort of thing is you have to use your function for the recursive case
06:35:25 <dreixel> generics don't have to be slow
06:35:32 <kmc> yeah, but SYB usually is
06:35:33 <dreixel> but SYB, in particular, tends to be
06:35:37 <benmachine> which means you have to do all the base cases, too
06:35:38 <kmc> hehe
06:35:40 <kmc> read my mind ;)
06:35:44 <dreixel> :)
06:36:01 <benmachine> what about syb makes it slow?
06:36:23 <dreixel> run-time cast
06:36:42 <kmc> run-time type check on everything
06:36:48 <benmachine> hmm
06:36:51 <dreixel> and probably the use of rank-2 functions
06:36:54 <kmc> accomplished through polymorphism
06:37:05 <kmc> why are rank-2 functions slow?
06:37:08 <Paczesiowa> ivanm: there's a nfdata module in derive, thanks. now to learn TH...
06:37:18 <benmachine> so what generics approach doesn't do that?
06:37:27 <kmc> do you need to know TH to use derive?
06:37:33 <dreixel> all others? :P
06:37:37 <kmc> benmachine, Uniplate looks good.  though i haven't used it, only read the paper
06:38:00 <dreixel> not true, though, with instant-generics you can find yourself needing it, for it
06:38:11 <kmc> also the stuff based on representing types structurally, such as multirec or records
06:38:25 <kmc> and -XGenerics, though i've not seen much code use that
06:38:51 <dreixel> and representing structure as types makes it much easier for GHC to optimize things
06:39:37 <EvanR-work> ghc optimizes better if you code is more beautiful ;)
06:39:49 <dreixel> if you're interested in that, I'd blatantly promote my paper: http://dreixel.net/research/pdf/ogie.pdf
06:40:04 <dreixel> which also has benchmarks of generic libraries
06:40:27 <zygoloid> i would imagine syb + supercompilation would give very good results
06:40:44 * hackagebot hfractal 0.3.3.2 - OpenGL fractal renderer  http://hackage.haskell.org/package/hfractal-0.3.3.2 (ChrisHoldsworth)
06:41:40 <benmachine> < zygoloid> i would imagine [...] supercompilation would give very good results
06:42:46 <benmachine> imagination is a wonderful thing.
06:43:50 <wli> Don't the results depend on a lot more than supercompilation? Like the details of the supercombinator translation process?
06:44:10 <Paczesiowa> it seems, that derive can't derive instances for types from other modules (like standalone deriving):/
06:44:34 <benmachine> Paczesiowa: really? what's the error?
06:44:37 <zygoloid> benmachine: http://community.haskell.org/~ndm/supero/
06:45:00 <benmachine> -O11 :O
06:45:02 <Paczesiowa> $( derive makeNFData ''Text.ParserCombinators.Parsec.ParseError ), error is about that type not being in scope
06:45:53 <hpc> -O9000
06:46:07 <benmachine> hmm
06:46:26 <copumpkin> pejo is working on getting it into GHC
06:46:32 <copumpkin> I'm looking forward to it
06:46:47 <hpc> same
06:46:53 <zygoloid> it has the potential to be amamzingly awesome :)
06:47:17 <boegel> what is supercompilation exactly?
06:47:24 <hpc> does anyone know how drastically it would affect compilation time?
06:47:39 <copumpkin> boegel: symbolic partial evaluation at compile time, I guess
06:47:58 <wli> Translation to supercombinators I thought.
06:48:27 <boegel> copumpkin: basically shift some of the execution time to compile time?
06:48:37 <boegel> copumpkin: by being supersmart?
06:49:16 <HugoDaniel> i can't find dons thesis
06:49:55 <EvanR-work> i thought supercombinators was a given anyway
06:49:56 <chrisdone> nothing gets me in the mood for coding better than Developers Developers Developers Developers (remix)
06:50:05 <EvanR-work> to avoid closures
06:50:31 <chrisdone> I sing along to it even though I'm not good at the lyrics
06:51:24 <EvanR-work> i wonder what happens to people at MS who he finds watching that video
06:52:27 <Paczesiowa> EvanR-work: there was a video of B.Gates presentation including a robot with a recording of "developers"
06:52:29 <hpc> they get eaten by clippy
06:56:06 <EvanR-work> i guess the video isnt that bad. he knows hes a joke
06:56:13 <EvanR-work> someone at MS probably made it
06:56:35 <wli> I guess defining what a supercombinator is comes in at some point.
06:56:54 <EvanR-work> function with no free variables
06:57:22 <Phyx-> clippy came back from the grave?
07:02:47 <luite> chrisdone: I found a problem with caching in msie in tryhaskell
07:02:51 <luite> chrisdone: try for example
07:02:54 <absentia> n/win shrink 3
07:02:55 <absentia> n/win shrink 3
07:03:10 <luite> chrisdone: > i + i
07:03:15 <luite> chrisdone: i = 1
07:03:20 <luite> chrisdone: > i + 1
07:03:22 <aristid> :t uncurry . uncurry
07:03:23 <luite> oops forgot a >
07:03:23 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
07:03:46 <hpc> :t uncurry uncurry
07:03:47 <lambdabot> forall a b c. (a -> b -> c, (a, b)) -> c
07:04:02 <aristid> @hoogle uncurry3
07:04:02 <lambdabot> No results found
07:05:40 <Phyx-> luite: isn't i undefined the first time around?
07:05:56 <Phyx-> in which case, the interpreter will become unresponsive anyway
07:05:58 <Phyx-> ^_^
07:06:13 <luite> Phyx-: yes, that's the problem. it should give an error the first time and the correct result the second time
07:06:16 <luite> which works fine in chrome
07:06:33 <luite> but internet explorer gives the same error the second time
07:06:42 <luite> oops I meant > i + i   in the second expression
07:06:50 <luite> it should be the same as teh first, but with a different response
07:07:04 <Phyx-> i can't get passed the first one to begin with
07:07:14 <Phyx-> it hangs the interpreter
07:07:39 <luite> Phyx-: hmm, it works fine here in Chrome
07:08:45 <wli> I wonder if lambda lifting counts as supercompilation.
07:08:53 <Phyx-> luite: yes, I've speculated before that the fade effect is causing IE to loop internally. so the page hangs in a way.
07:09:14 <dolio> supercompilation doesn't have anything to do with supercombinators, as far as I can tell.
07:09:39 <luite> Phyx-: it does make it quite slow yes, but it still responds :)
07:09:47 <luite> Phyx-: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=28549#a28549
07:10:12 <wli> dolio: Really? Then I may not know what it is at all despite having read various things about it (and apparently not understood them).
07:10:26 <luite> Phyx-: I'm working on a local fork here though, where I disabled the fade effect
07:10:52 <dolio> wli: Supercompilation is like partial evaluation, except you do more fancy stuff to enable more compile-time evaluation.
07:11:37 <dolio> The details of which I'm not totally clear on.
07:11:41 <Phyx-> luite: right
07:11:46 <wli> dolio: What's the distinction between partial evaluation and supercompilation,then?
07:12:48 * Phyx- goes back to watching his scary movie
07:12:49 <dolio> wli: I think partial evaluation can only reduce things that don't inspect runtime-bound values.
07:13:08 <dolio> While supercompilation does some kind of analysis to try and figure out what those runtime values might be, or something of that sort.
07:13:46 <luite> Phyx-: I'm adding extra graphics stuff (just made bitmap graphics work in IE, which was a pain, vector graphis already work somewhat, line/pie/bar charts too). next step is adding support for something like Mathematica's interact
07:14:19 <randomwords> Are there any good resources on how best to deal with run time configuration options for a given haskell program? Hopefully something avoiding global state but also avoiding parameterising every function
07:14:33 <wli> dolio: wikipedia has something near-unintelligible for supercompilation
07:15:25 <roconnor> randomwords: AFAIK your only choices are a reader monand or, with GHC, implicit arguments
07:15:45 <roconnor> well, maybe reader applicative functor
07:15:57 <dolio> wli: http://tunes.org/wiki/supercompilation.html is clearer than wikipedia.
07:16:13 <randomwords> roconnor: That's what I thought. I read the abstract of a paper on "implicit configurations" but I couldn't find it and I imagine it's very similar to implicit arguments
07:16:24 <dolio> Although it's still pretty vague.
07:16:27 <randomwords> I find the whole issue frustrating to say the least
07:17:12 <roconnor> I think a top level args list wouldn't be so terrible.
07:17:26 <randomwords> Agreed
07:17:38 <quicksilver> I don't find parameterising every function so awful, myself
07:17:50 <randomwords> but then is that really so different from just having x global IOrefs?
07:18:00 <quicksilver> in practice, only some of them refer to the configuration, and it's benefit to have that explicit in the type
07:18:07 <roconnor> randomwords: not really
07:18:17 <randomwords> quicksilver: It becomes unweildy quickly though
07:18:19 <quicksilver> (and which parts of the config, if you go that far)
07:18:25 <quicksilver> randomwords: I don't find that to be the case.
07:18:46 <roconnor> actually I take it back, it is terrible
07:18:52 <Phyx-> luite: ah, cool
07:18:55 <randomwords> quicksilver: I'm sure you could imagine a case where you have 40 parameters...
07:19:03 <quicksilver> randomwords: you make it one type, then
07:19:09 <quicksilver> data Config = ...
07:19:18 <roconnor> passing parameters down makes your code modular
07:19:30 <randomwords> quicksilver: Oh sure, and I do, but it's not always so simple
07:19:35 <quicksilver> having a nest of functions which depend in an uncontrolled way on 40 global variables, now *that* is unwieldy.
07:20:45 * ksf just realised he neither understands type fams, fundeps or GADTs
07:20:59 <roconnor> not even GADTs?
07:21:40 <quicksilver> the maintenance headache of not having the passing explicit exceeds the problem of having to add parameters to functions that use them
07:21:40 <ksf> well, I thought this would be an easy hack but I'm stuck.
07:21:46 <quicksilver> in my personal opinion, of course.
07:22:06 <quicksilver> one of my favourite things about haskell code is that the dependencies are explicit.
07:22:12 <randomwords> quicksilver: There's a good chance I'm just being lazy
07:22:30 <copumpkin> ksf: can we help?
07:22:36 <randomwords> quicksilver: Could you think of some good exmple code that deals with configs well?
07:22:53 <kmc> xmonad takes the Reader approach
07:22:59 <kmc> with a single record of the config
07:23:38 <ksf> I want to tuple up stuff like ( (Foo, 1) ,( (Bar, 2) ,( (Baz, 3) ,Nil))) and then have a function that can lookup the int using an Either Foo (Either Bar (Either Baz Nil)))
07:24:03 <chrisdone> man i suck at imperative coding now
07:24:22 <chrisdone> in haskell it's all just maps and pipes, i think about transformations
07:24:23 <ksf> then the next task is constructing a concrete Either value from a given tag and a given list, but that now seems to be the easy part.
07:24:32 <copumpkin> ksf: aha
07:24:33 <roconnor> chrisdone: I suck at classical math now.
07:24:40 <chrisdone> everything else it's push this, add this, mutate that, create a wimblewop
07:24:42 <roconnor> I can't prove things by contradiction anymore
07:24:49 <copumpkin> I posted my first question on mathoverflow!
07:25:10 <yitz> ksf: so you want a tree
07:25:18 <roconnor> proving the infinite pidgeon hole principle was a nightmare
07:25:21 <Gracenotes> I posted my last coquestion on comathoverflow
07:25:26 <ksf> well yes log n lookup is nice but I'd be content with a list right now.
07:25:42 <copumpkin> ksf: so the shape of the index is determined by the shape of the list
07:25:47 <ksf> yes.
07:25:51 <copumpkin> ksf: do you already have code for that? or is that the part you're confused about?
07:25:55 <yitz> Gracenotes: costackoverflow == queueoverflow
07:25:58 <copumpkin> I can throw together something if you want
07:26:16 <ksf> well I have code to check whether my tag is in the list
07:26:39 <ksf> constructing a value along the way would be trivial
07:26:42 <yitz> ksf: not because of log n lookup time. because that is the structure that you are describing
07:26:49 <kmc> chrisdone, do you suck at imperative coding in Haskell?
07:26:53 <copumpkin> ksf: so the "payload" is homogeneous, but tags are different types?
07:26:54 <Gracenotes> yitz: then I suppose the people at costackoverflow can computer more than those at stackoverflow
07:26:56 <Gracenotes> *compute
07:26:57 <copumpkin> where the payload is Int here
07:27:17 <copumpkin> can copumpkin compute more than pumpkin?
07:27:33 <ksf> they're both polymorphic.
07:27:57 <copumpkin> ksf: oh, so what would the return type of the lookup function be?
07:27:57 <ksf> ...but lookup works by their product type.
07:28:05 <poljp> heh, mathoverflow :)
07:28:16 <kmc> sum type?
07:28:18 <copumpkin> it's a really daunting website :P
07:28:40 <hpc> shouldn't it be called something else, like discontinuousdomain?
07:28:44 <copumpkin> ksf: it seems like by using a regular sum for lookup, you're forcing the payload to be a single type
07:28:49 <hpc> math doesn't really overflow...
07:28:49 <ksf> no, you say "give me the handler that takes a Foo and returns an Int"
07:29:16 <kmc> oh
07:29:24 <kmc> you look up by the pair of the types?
07:29:34 <poljp> crikey thats a lot of fun questions on there. i should dust off my stuff!
07:29:35 <ksf> they are, in a sense, in that it's all IO actions.
07:29:36 <copumpkin> your Either only seemed to contain the keys
07:30:01 <copumpkin> so the index is computed by a type function on the input list, right?
07:30:08 <ksf> well, assume that I lookup by typerep
07:30:10 <kmc> ksf, it sounds a bit like the "records" package
07:31:07 <ksf> maybe some context help: I'm trying to do a dispatch scheme where you send something like (Foo, Int -> STM ()) over a TChan.
07:31:34 <ksf> ...the second element being the way to return a result.
07:32:03 <ksf> what I want to do is to take multiple handlers and feed them from a single Chan.
07:32:32 <kmc> the easy way out is existentials / Typeable / Dynamic
07:32:58 <ksf> I've got a Dynamic implementation, but I don't like the lack of polymorphism.
07:33:19 <ksf> ...and that I have to implement type safety separately with a phantom type.
07:33:29 <kmc> you do?
07:33:44 <kmc> by "type safety" do you mean something static?
07:33:48 <ksf> If I want static saftey, yes.
07:34:04 <ksf> I don't want to be able to send messages to actors that can't understand them.
07:35:11 <ksf> I could probably just use HList, but I was hoping for a less heavyweight implementation as the use case is quite restricted.
07:35:26 <kmc> ok, but right off you need some kind of type-level associative container
07:36:40 <ksf> well, a heterogenous tagged list.
07:37:00 <ksf> ...for starters.
07:37:56 <ksf> and all the operations I need are cons, elem (at type level) and lookup (at value level, directed by type)
07:38:36 <Paczesiowa> what's wrong with HList?
07:38:48 <ksf> it's heavyweight
07:39:01 <ksf> and I don't understand its implementation.
07:39:28 <ksf> (well, doing that would probably make me able to implement the list)
07:39:33 <Paczesiowa> 1.read paper 2.read paper 3. ask questions 4. read paper
07:42:38 <aristid> 5. read paper
07:43:11 <Paczesiowa> ksf: if you need elem and want to understand an implementation, you will have to understand HList, there's no other way to implement it
07:43:29 <ksf> I already do have elem, but failed at the rest.
07:43:33 <kmc> you don't need to understand all of HList, though
07:43:46 <Paczesiowa> yes, elem is pretty basic
07:43:50 <ksf> class (x `IsMemberOf` xs) r | x xs -> r where
07:43:51 <ksf> instance IsMemberOf x Nil NoMember
07:43:51 <ksf> instance IsMemberOf x (x,ys) Member
07:43:51 <ksf> instance IsMemberOf x ys t => IsMemberOf x (y,ys) t
07:43:51 <kmc> also fsvo "no other way" -- HList is based on MPTC+fundeps, mightn't it use type families instead?
07:44:20 <Paczesiowa> ksf: that's half of HList:)
07:44:22 <ksf> as far as I heard it does some pretty nasty tricks to get type equality.
07:44:55 <Paczesiowa> ksf: you don't have to understand TypeCasts (and TypeEq), you can use (~)
07:45:28 <Paczesiowa> ksf: besides, you've just used type equality in your instances
07:45:32 <randomwords> quicksilver: I've just done some playing and I think I'm coming round to your way of thinking :)
07:45:35 <nominolo> anyone know the mirror of hackage that supports reverse dependencies?
07:47:00 <ksf> there's one, yes.
07:47:01 <ksf> google it.
07:47:07 <quicksilver> randomwords: :)
07:47:28 <nominolo> gee, so helpful
07:49:05 <nominolo> fwiw, http://bifunctor.homelinux.net/~roel/hackage
07:53:13 <dolio> wli: Thinking about it a little, ordinary partial evaluation may not be able to handle the case-of-case optimization.
07:55:04 <dolio> wli: For 'case (case x of C11 v -> C21 e11 ; C12 v -> C22 e12) of C21 v -> e21 ; C22 v -> e22', if x isn't statically known, then that expression doesn't reduce by any of the normal evaluation rules. It gets stuck on x.
07:55:30 <dolio> But, if you consider scenarios where x takes on different values, it reduces in each scenario, which may be what supercompilation does.
07:56:35 <aristid> i wish uu-parsinglib had meaningful documentation
07:56:43 <nominolo> dolio: have you read neil's and max's paper?
07:56:55 <aristid> it looks like it's very interesting, but there's very little documentation:(
07:56:55 <nominolo> s/paper/papers/
07:57:20 <dolio> I have, but not well enough to fully understand them, I think.
07:59:27 <ksf> there's a wonderful tutorial-like paper that describes the implementation
07:59:38 <ksf> ...the interface is still cryptology, thogh.
08:00:19 <aristid> ksf: yeah, that's totally helpful. describing the implementation, and not the interface... *sigh*
08:04:07 <geheimdienst> how to write unusable code #384215: in the documentation, explain how, not why
08:05:16 <ksf> oh there's enough why in the paper
08:05:42 <ksf> what it lacks is the why of the interface and the how of using it.
08:05:45 <nominolo> dolio: maybe Neil's 2008 paper is easier as an introduction.
08:06:24 <dolio> I'm actually looking at Introduction to Supercompilation at the moment.
08:06:29 <nominolo> dolio: sorry, I meant the IFL 2007 paper
08:06:44 <nominolo> dolio: http://community.haskell.org/~ndm/downloads/paper-a_supercompiler_for_core_haskell-01_may_2008.pdf
08:09:34 <dolio> nominolo: My conjecture that case-of-case could illustrate the difference between supercompilation and ordinary partial evaluation seems on target.
08:09:43 <dolio> If this paper is accurate.
08:09:51 <dolio> Unless I'm underestimating partial evaluation.
08:10:20 <nominolo> dolio: pejo said that case-of-case is one of the most important optimisations, yes.  but i don't know how it relates to partial evaluation
08:10:45 <nominolo> dolio: i suppose it depends on how you define partial evaluation
08:11:05 <dolio> You'd at least need non-standard evaluation rules to eliminate all case-of-cases.
08:11:06 <nominolo> in my mind partial evaluation is a superset of supercompilation
08:11:13 <dolio> In addition to the normal, runtime ones.
08:11:46 <dolio> Heh, stuff I was reading earlier said supercompilation is a superset of partial evaluation. :)
08:12:04 <nominolo> dolio: right, I think in Max's paper, the splitter takes care of that
08:15:04 <wli> I'm thinking there's something special about supercompilation. I mostly think/heard of it in terms of translating from one type of machine to another, which is odd (wrong?) and not meshing well with partial evaluation never mind being a subset or superset of it.
08:16:21 <Botje> wli: isn't translating from one type to another type already a definition of compilation?
08:17:00 <wli> Yeah, it's just weird in some way.
08:18:11 <nominolo> wli: it's basically a huge specialiser
08:18:12 <quicksilver> wli: I also have tried to read overview definitions of what supercompilation is and remain none the wiser.
08:18:24 <quicksilver> wli: I'd love to have a concise + enlightening definition.
08:19:30 <nominolo> and one of the specialisation techniques is partial evaluation
08:19:38 <dolio> The introduction of this paper has an explanation of the original idea, in terms of metasystems and stuff.
08:19:54 <dolio> It's hard to see what that has to do with their subsequent explanation of the process, though.
08:20:01 <ksf> maximum partial evaluation, that is, not merely collapsing leaf constants and operations into new constants, but also non-leaf ones.
08:20:36 <dolio> Which builds trees by specializing variables in a program, and then builds new programs from the trees.
08:20:38 <ksf> which obliberates 99% of the use cases of rules pragmas.
08:20:38 <dolio> ftp://ftp.diku.dk/diku/semantics/papers/D-364.ps.gz
08:21:14 <nominolo> ksf: more like 60%
08:21:17 <ksf> (it won't be able to do stuff like head . sort = maximum
08:21:25 <nominolo> ksf: it can't deal with accumulators (so far)
08:21:53 <dolio> It also won't do 'fromInteger . toInteger = moreEfficientConversionFunction'.
08:22:16 <ksf> but it would do the id case
08:22:43 <ksf> erm. hopefully.
08:22:50 <ksf> actually, possibly not.
08:22:53 <dolio> I wouldn't necessarily count on that.
08:23:00 <dolio> Unless the id in question is Integer -> Integer.
08:23:22 <quicksilver> is this related to what the JS people call "tracing" ?
08:23:40 <quicksilver> that seems to be about inferring / inventing type information on javascript programs and then specializing
08:24:20 <ksf> nope supercompilation is static
08:25:01 <dolio> It seems to be the opposite. You invent values and specialize on them.
08:25:11 <dolio> During the static phase.
08:25:23 <quicksilver> so it only works on types where there are a finite number of possibilities?
08:25:35 <quicksilver> so it's tailor-made, really, for ADTs in the haskell sense
08:25:45 <quicksilver> which often have a small finite number of constructors at each 'level'
08:25:50 <dolio> The stuff described in that paper is, at least.
08:25:58 <thoughtpolice> quicksilver: you mean like tracemonkey? tracing in that case is a jit strategy at runtime
08:26:00 <dolio> But it's describing supercompilation for a functional language.
08:26:30 <thoughtpolice> SPJ has an interesting new paper on supercompilation for GHC too
08:26:47 <thoughtpolice> http://research.microsoft.com/en-us/um/people/simonpj/papers/supercompilation/
08:27:36 <dolio> I doubt the original language that used it was functional, though, since they specifically talk about making the technique work for a functional language.
08:29:15 <dolio> Hey, I can actually contact research.microsoft.com once again.
08:29:23 <thoughtpolice> yeah, i had that problem for a while too
08:29:28 <thoughtpolice> luckily seems to actually work now
08:30:29 <thoughtpolice> according to some bug report I think I saw research.microsoft.com would totally flip out in things like chrome/ff because the HTML was so horrible webkit/gecko just killed themselves or something
08:30:38 <thoughtpolice> i think I tested it and I could always connect with IE8 or whatever
08:31:20 <tolkad> What is kell anyway?
08:38:08 <tolkad> and why does this language have it?
08:38:25 <EvanR-work> :t kell
08:38:26 <lambdabot> Not in scope: `kell'
08:39:11 <Botje> where do you see kell? :)
08:39:41 <tolkad> haskell
08:40:02 <Botje> oh
08:40:03 <Botje> haha :)
08:40:06 <geheimdienst> i can has kell?
08:41:00 <EvanR-work> can haskell has kell
08:41:19 <EvanR-work> :t splitAt
08:41:20 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:41:34 <EvanR-work> > splitAt 3 "haskell"
08:41:34 <lambdabot>   ("has","kell")
08:41:48 <EvanR-work> HAS KELL
08:42:12 <qwebirc16750> @pl \f (a, b) -> (map f a, map f b)
08:42:12 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . map) map
08:42:23 <qwebirc16750> @pl \f (a, b) -> (f a, f b)
08:42:24 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
08:42:53 <qwebirc16750> @pl \f x -> (f $ fst x, f $ snd x)
08:42:53 <lambdabot> ap (ap . ((,) .) . (. fst)) (. snd)
08:43:55 <drhodes> found something slick in emacs ..  Sometype -> AnotherType  , if you select the region containing " -> " and hit M-t, it will flip the types around the arrow.
08:44:18 <EvanR-work> wow thats pretty useful
08:44:26 <EvanR-work> i always change my mind
08:59:49 <arbitrarylogic> @pl \x -> (sort $ map fst x, sort $ map snd x)
08:59:50 <lambdabot> ap ((,) . sort . map fst) (sort . map snd)
09:01:52 <eugenn> @source ap
09:01:52 <lambdabot> ap not available
09:01:54 <Carrabas> hi
09:02:38 <Carrabas> I've just insatlled leksah
09:02:50 <Carrabas> and I am enjoying it pretty much
09:03:37 <Carrabas> is everybody afk?
09:03:43 <Nibble> Carrabas: nope
09:03:52 <Carrabas> thank god xD
09:04:04 <Carrabas> or thank Dijkstra
09:04:06 <Carrabas> xD
09:06:20 <geheimdienst> > fmap (+1) (2,3)
09:06:21 <lambdabot>   (2,4)
09:07:54 <arbitrarylogic> > fmap (+1) [2,3]
09:07:55 <lambdabot>   [3,4]
09:07:57 <copumpkin> onoes, a typo in that SPJ + BSP supercompilation paper
09:09:51 <dayz> does anyone know how to type out logical symbols in xchat?
09:10:12 <EvanR-work> scim
09:11:11 <dayz> EvanR-work, which input method do I use?
09:11:21 <EvanR-work> not sure
09:11:35 <EvanR-work> math or something
09:12:03 <EvanR-work> or copy pasta from gucharmap ;0
09:12:55 <sm> jesus.. json library is hard to figure out
09:13:34 <joeytwiddle> really?  i thought it only had two functions
09:13:48 <sm> http://hackage.haskell.org/packages/archive/json/0.4.3/doc/html/Text-JSON.html ?
09:14:22 <sm> it is a twisty maze of promising-looking types and functions that bite your hand
09:14:37 * geheimdienst pulls out his monocle. "that seems like more than two functions, i say".
09:14:51 <bnonym> at least it's just biting your hand and not shooting your foot
09:15:05 <Carrabas> hi, which IDE do you use for Haskell programming?
09:15:16 <sm> if anyone knows a good doc or example, I'd appreciate it
09:15:25 <EvanR-work> ed
09:15:33 <copumpkin> Carrabas: there's leksah, but most people I know don't use an IDE at al
09:15:40 <copumpkin> emacs, vim, textmate, or *cough* ed
09:15:46 <Carrabas> I am trying Leskah, because I had the old WinHugs, and I want to try something new
09:16:15 <Carrabas> I see
09:16:28 <EvanR-work> really men edit the AST directly
09:16:46 <Carrabas> I tried emacs too, it's nice
09:17:30 <Carrabas> but I was looking for something for a larger project
09:17:51 <EvanR-work> emacs was designed for large projects
09:19:15 <quicksilver> the main reason I don't use an IDE is that IDEs always seem to be bundled with really poor editors.
09:19:26 <quicksilver> and having a good editor is more important to me than the ancillary features the IDE might provide.
09:19:40 <quicksilver> however, leksah looks interesting and may well become promising
09:21:18 <EvanR-work> yeah they usually have something along the lines of notepad with color
09:21:26 <Carrabas> I will give it a try
09:21:45 <zenzike> I'm currently working with OpenGL and having to do lots of shepherding using `fromIntegral`, for example, to change values between GLint and GLsizei, am I missing something, or is it really supposed to be this tedious?
09:23:00 <quicksilver> I suppose the answer is it's really that tedious
09:23:10 <quicksilver> but my experience is there isn't very much of it at all
09:23:35 <quicksilver> how often do you need to convert between GLint and GLsizei? normally they're only used for different things.
09:24:03 <zenzike> quicksilver: yeah, I suppose. It just feels like there should have been some kind of class that overarches those types
09:24:18 <zenzike> more annoying is turning Int to GLInt
09:25:01 <EvanR-work> as long as theres a nice interface between normal code and the graphics backend, you can do all the conversion from Int to GLInt at once
09:25:11 <EvanR-work> and only work with GLInt
09:26:23 <EvanR-work> id like to see a discussion about the rationale for non coercing number types, and for gl bindings being made newtypes or data
09:26:24 <zenzike> Is there any performance hit when working with GLint rather than Int?
09:26:42 <EvanR-work> rather than type synonyms
09:27:07 <quicksilver> zenzike: the problem is that the standard says that GLint might not be the same type as Int
09:27:09 <zenzike> I thought that they weren't synonyms any more
09:27:19 <quicksilver> zenzike: (and indeed I think that's actually the case on x86_64)
09:27:20 <EvanR-work> zenzike: well they arent because you are converting
09:27:24 <quicksilver> so it is a non-trivial conversion.
09:27:35 <sm> bnonym: indeed, but I'd rather have a lib that doesn't hurt me in any way at all
09:28:24 <zenzike> right. so I should make my algorithms play with GLint directly most of the time if I want more performance, and do the conversion from Int just once, when importing data
09:28:39 <EvanR-work> or when you feed data to the renderer
09:29:31 <EvanR-work> like data Sprite = Sprite (Int,Int)
09:29:36 <EvanR-work> ...
09:29:46 <zenzike> EvanR-work: except that if conversion is done when I feed the renderer, it will have to be converted every frame, whereas working with GLInt directly means that the penalty is paid just once
09:30:06 <EvanR-work> the actual conversion may be non existent
09:30:27 <EvanR-work> and i personally would avoid spreading video backend specific types through out the program
09:30:53 <zenzike> the compiler is smart enough to know when not to convert?
09:31:21 <zenzike> (I would also prefer not having GLint sprinkled in places that aren't graphics related!)
09:31:22 <EvanR-work> yes, for example Int16 -> Int32, or even Int -> Word
09:31:38 <dayz> if I want to logically express that there exists an x which is a zero of g if it is a strict maximum of f as ALL x. (ALL y. x != y --> f(x) < f(y)) --> g x = 0 and that there exists a strict minimum of f EX x ALL y. f(x) < f(y), could one conclude that EX x. g(x) = 0?
09:31:42 <zenzike> oh, that's nice
09:32:12 <quicksilver> EvanR-work: on x86_64, though, Int is 64 bit and GLint is 32 bit. I think.
09:32:20 <quicksilver> EvanR-work: so there is real work to do in a (fairly) common case.
09:32:54 <EvanR-work> so its not easy to convert a boxed Int64 to a boxed Int32 ?
09:33:06 <quicksilver> it's easy but it's not non-existent
09:33:51 <EvanR-work> bah im getting sucked into the performance trap
09:34:17 <quicksilver> only matters if it matters.
09:34:22 <quicksilver> that's always the way with performance :)
09:34:27 <zenzike> :-) yeah, I should adopt that philosophy
09:34:30 <EvanR-work> only know if it matters if you do it and measure a problem
09:34:34 <zenzike> I've started worrying before there's even a problem
09:34:35 <jmcarthur> is there a penalty for using C types instead of haskell types? like if you just use the GL types do you suffer any sort of slowdown from the runtime?
09:34:51 <quicksilver> jmcarthur: In principle no.
09:35:02 <EvanR-work> zenzike: by default, write beautiful code, then sort it out later ;)
09:35:04 <EvanR-work> if necessary
09:35:08 <quicksilver> jmcarthur: you suffer annoying interactions with a few library functions that take Int (e.g. "take")
09:35:12 <quicksilver> EvanR-work++
09:35:15 <jmcarthur> well sure
09:35:23 <aristid> :t genericTake
09:35:24 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
09:35:28 <jmcarthur> but i don't see any reason to give take a GL type anyway ;)
09:35:30 <benmachine> jmcarthur: I'd've thought natural haskell types are more likely to have rules and etc.
09:35:43 <quicksilver> jmcarthur: and in a few cases you suffer from a missing RULES which means a static optimisation which fires for Int doesn't fire for MyOtherInt
09:35:48 <quicksilver> benmachine: exactly.
09:35:53 <aristid> @hoogle a -> Int
09:35:53 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
09:35:53 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
09:35:53 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
09:36:02 <aristid> @hoogle toInt
09:36:03 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
09:36:03 <lambdabot> Data.Char digitToInt :: Char -> Int
09:36:03 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
09:36:21 <jmcarthur> quicksilver: badly written rules though, i'd guess?
09:36:32 <EvanR-work> theres gotta be rules for gl types
09:36:43 <zenzike> EvanR-work: sounds like good advice. Sadly, this beholder doesn't see fromIntegral as a particularly beautiful piece of code!
09:37:03 <EvanR-work> zenzike: well its generally necessary, so compartmentalize it
09:37:07 <zenzike> nevertheless, I should probably stop worrying about these conversions until things get aweful
09:38:42 <EvanR-work> zenzike: and youre at the very edge of IO code... dealing with bindings... gotta do the best you can ;)
09:38:50 <jmcarthur> it occurs to me... since UHC has a polymorphic kinds extension, does that naturally lead to some idea of "kind classes"?
09:39:23 <jmcarthur> it might not be very useful...
09:39:45 <EvanR-work> zenzike: perhaps you can make *your* code more beautiful by using a graphics engine. if not youre basically writing your own
09:39:46 <copumpkin> well, it'd be nice to have "universes"
09:39:53 <copumpkin> data Z :: Nat
09:39:55 <jmcarthur> but maybe it could abstract some of the similarities between, say, Monoid and Alternative
09:39:59 <copumpkin> data S (n :: Nat) :: Nat
09:40:24 <jmcarthur> yeah, universes are cool, but that would be much less trivial extension, wouldn't it?
09:40:40 <copumpkin> data Vec (n :: Nat) a :: * where Nil : Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a
09:40:53 <copumpkin> dunno :) conceptually it seems pretty simple
09:41:06 <copumpkin> if necessary, just duplicate some of the type checking code one level up
09:41:26 <jmcarthur> i never read up on the typing rules for universes
09:41:29 <zenzike> EvanR-work: true, though right now I'm playing with triangulation algorithms, so I'm pretty much hitting the metal anyway. I'm happy tinkering with the interface raw.
09:41:31 <jmcarthur> i guess they are simple
09:41:42 <jmcarthur> i just don't know how it would interact with the various haskell extensions and stuff
09:43:30 <Apocalisp> Is there a handy naming convention to keep cognitively separate the types in your host language and the types in the hosted language?
09:43:51 <jmcarthur> i see Ty* a lot
09:45:58 <dolio> System F_2 has polymorphism, but you can't even encode type classes in it.
09:47:56 <dolio> And I suspect UHC's kind-level is like F_2's type level.
09:48:39 <quicksilver> Apocalisp: I like host language types in Consolas bold black and hosted language types in Fraktur sky blue. ;)
09:48:48 <jmcarthur> ha
09:55:08 <dolio> Wow, the Supercompilation by Evaluation paper has a supercompiler that deforests 'let x = 1 : x in map (+1) x' into 'let x = 2 : x in x'.
09:55:35 <jmcarthur> that's really cool
09:55:50 <copumpkin> dolio: yeah, it's pretty awesome
09:55:56 <copumpkin> I keep cringing when they use criteria as a singular though
09:58:43 <EvanR-work> simplify english, makes it better ;)
09:58:50 * hackagebot splines 0.1 - B-Splines, other splines, and NURBS.  http://hackage.haskell.org/package/splines-0.1 (JamesCook)
09:59:11 <EvanR-work> you would like it if some random data type name had to be spelled lower case would you ;)
09:59:15 <EvanR-work> wouldnt
09:59:51 * hackagebot shaker 0.2.1 - simple and interactive command-line build tool  http://hackage.haskell.org/package/shaker-0.2.1 (AnthoninBonnefoy)
10:00:04 <byorgey> oooh, splines
10:00:31 <EvanR-work> reticulating splines
10:01:35 <wli> G^d splines are another matter entirely.
10:01:59 <wli> I don't know if it's Grobner stuff or what that's needed, but anyway.
10:04:02 <Samy> Anyone here involved with CUFP?
10:21:39 <EvanR-work> looking at IntMap operation difference and intersection, im thinking that the union of the two results is the original map. is there a single operation that gets the difference and the intersection ?
10:21:46 <EvanR-work> at once
10:22:01 <pastorn> where's that old blog post that describes how to use first/second?
10:22:08 <pastorn> (functions that are in Control.Arrow)
10:23:11 <copumpkin> > first succ (1, True)
10:23:12 <lambdabot>   (2,True)
10:23:18 <copumpkin> > seoncd not (1, True)
10:23:19 <lambdabot>   Not in scope: `seoncd'
10:23:24 <copumpkin> > second not (1, True)
10:23:24 <lambdabot>   (1,False)
10:24:48 <pastorn> copumpkin: yeah, but there was a blog post ~2 years ago that didn't go into any of the arrow details that was really good
10:25:09 <eugenn> > snd not (1, True)
10:25:10 <lambdabot>   Couldn't match expected type `(a, b)'
10:25:10 <lambdabot>         against inferred type `GHC.Bo...
10:26:02 <aristid> > ((,) <$> fst <*> not . snd) (1, True)
10:26:04 <lambdabot>   (1,False)
10:28:09 <EvanR-work> are arrows ready for public consumption ;)
10:28:53 <jmcarthur> arrows are wasted potential :(
10:30:50 <EvanR-work> is there a zip for Data.Maps ?
10:31:11 * hackagebot indents 0.1.1 - indentation sensitive parser-combinators for parsec  http://hackage.haskell.org/package/indents-0.1.1 (SamAnklesaria)
10:31:43 <zygoloid> EvanR-work: the (->) arrow is in active use. other arrows... not so much.
10:31:56 <zygoloid> there are a few libraries about which use them, possibly to good effect
10:32:04 <EvanR-work> ah libraries
10:32:21 <zygoloid> but i suspect many of those would work just as well as applicatives.
10:32:43 <jmcarthur> the biggest problem with arrow is arr
10:32:56 <jmcarthur> arr makes it much less general than it could be
10:33:08 <zygoloid> yup. but it's hard to remove without crippling the translation from proc notation
10:33:35 <jmcarthur> arrow should just have a superclass for everything but arr
10:33:50 <jmcarthur> that would be the easy fix, anyway
10:34:12 <zygoloid> i thought proc notation relied upon arr for some of its tupling stuff?
10:34:23 <jmcarthur> even if it does, my proposal wouldn't harm that
10:34:37 <jmcarthur> Arrow would still have arr, but we would also have a type class that doesn't have arr
10:34:38 * zygoloid thinks that arrow without proc notation wouldn't be very useful
10:34:58 <jmcarthur> i have used it without proc and didn't have any real problems with it
10:35:21 <jmcarthur> if you generalize arrow even further you get some generalized bifunctor classes, and they are very useful in isolation from proc notation
10:35:31 <zygoloid> hmm, ok. out of interest, what were you using it for?
10:36:32 <jmcarthur> i don't even remember at this point
10:37:01 <jmcarthur> arrow really works well in point free code, though, except for some strange cases (i bet most yampa code wouldn't be as nice without proc, for example)
10:37:28 <jmcarthur> basically just like how the (->) instance is used a lot
10:37:45 <zygoloid> jmcarthur: incidentally i think you can recover proc notation with just two more primitives
10:37:54 <jmcarthur> without arr you mean?
10:37:57 <zygoloid> yeah
10:38:02 <jmcarthur> i'm curious :)
10:38:07 <zygoloid> swap :: a (b,c) (c,b)
10:38:32 <zygoloid> pivot :: a (b,(c,d)) ((b,c),d)
10:38:41 <jmcarthur> oh pivot looks cool
10:38:54 <jmcarthur> i had done swap like that before, but not pivot
10:39:12 <zygoloid> i think those two are enough to do arbitrary reorganisation of the value tree
10:40:15 <jmcarthur> zygoloid: in alt-stdlib i had generalized fst and snd, which can be used to do swap. i didn't think to do pivot though
10:40:47 <zygoloid> actually, one operation is missing. we also need: discard :: a (b,c) b
10:40:48 <edwardk> ah, pivot is in category extras as associate
10:40:50 <jmcarthur> i wasn't paying attention to whether it would be sufficient for proc though
10:41:07 <jmcarthur> in alt-stdlib, arr can be recovered from Functor
10:41:37 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Associative.html
10:42:15 <aristid> edwardk: you should make a typeclassopedia for category-extras :)
10:42:30 <aristid> also, more documentation :P
10:42:33 <zygoloid> but i think it'd make sense to put (&&&) and discard into a separate class. NonlinearArrow maybe?
10:42:33 <jmcarthur> i haven't thought about whether alt-stdlib's arr would be general enough to substitute for Arrow's arr though
10:42:45 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian.html offers fst which gives you your discard
10:42:52 <jmcarthur> zygoloid: here's how i extracted &&& http://patch-tag.com/r/jmcarthur/alt-stdlib/snapshot/current/content/pretty/Control/Arrow.hs
10:44:07 <jmcarthur> and as edwardk says, your discard is my fst
10:44:24 <edwardk> i have swap as braid/swap as well ;)
10:44:32 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Braided.html
10:44:35 <jmcarthur> yeah i don't get braid
10:44:51 <edwardk> braid doesn't have to satisfy swap . swap = id
10:44:57 <edwardk> but swap does
10:45:05 <jmcarthur> aha
10:45:13 <edwardk> consider (a,b,c) = (b,c,a) as a braiding
10:45:22 <edwardk> er braid (a,b,c) = (b,c,a)
10:45:40 <edwardk> (for a suitable data type)
10:45:54 <zygoloid> jmcarthur: interesting. bipoint is a much more natural inverse than (&&&) for discard.
10:46:32 <edwardk> in category-extras terms, bipoint = diag ? http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian.html#v%3Adiag
10:47:21 <zygoloid> edwardk: looks like it.
10:47:36 <ezyang> Hey guys: Data.Foo.Unsafe or Data.Unsafe.Foo? 
10:47:44 <zygoloid> ezyang: Data.Foo.Unsafe.
10:47:47 <edwardk> Data.Foo.Unsafe
10:47:51 <jmcarthur> what they said
10:47:57 <ezyang> zygoloid: Ok 
10:48:09 <ezyang> Lots of directories that means, then. 
10:48:24 <edwardk> ezyang: yeah =/ what are you doing?
10:48:36 * zygoloid forgets where he read that advice. shocking since it was only two days ago that he read it...
10:48:37 <edwardk> heh, there is already a precedent for an Unsafe. hierarchy in Unsafe.Coerce ;)
10:48:45 <jmcarthur> it would be nice if we had a choice between Foo/Bar/Baz.hs and Foo.Bar.Baz.hs
10:48:51 <ezyang> edwardk: Well, I have a bunch of unsafe functions for operating on my data structure: about 10 or so, and I figured this was getting kind of ridiculous and I should put them in another module. 
10:48:52 <edwardk> jmcarthur: use jhc =P
10:49:02 <jmcarthur> oh jhc has that?
10:49:04 <edwardk> jmcarthur: yeah
10:49:06 <jmcarthur> nice
10:49:22 <ezyang> And so there a bunch of DAta.Foo/Data.Bar modules that would probably adopt similar conventions, since I have different versions of this data structure. 
10:49:35 <zygoloid> this is where i read the advice: http://hackage.haskell.org/trac/ghc/ticket/994#comment:4
10:49:38 <edwardk> http://repetae.net/computer/jhc/manual.html#module-search-path
10:49:55 <jmcarthur> awesome!
10:50:18 <zygoloid> in particular: "The hierarchy naming is supposed to primarily reflect functionality, and I argue that the notion of "unsafety" should be secondary to what the function actually does in terms of naming the module."
10:50:45 <ezyang> Ah, what Simon Marlow says must be true. 
10:50:48 <ezyang> Sounds good. 
10:50:49 <zygoloid> :D
10:51:04 <jmcarthur> to take the opposite you would also have to justify why you're not doing Unsafe.Foo.Bar
10:51:35 <ezyang> Hmm... 
10:51:40 <edwardk> zygoloid: yeah, thats why i am stuck making Data.EverthingUnderTheSun.Speculation ;)
10:51:59 <edwardk> ezyang: you back in boston yet>
10:52:03 <jmcarthur> hierarchies suck
10:52:14 <ezyang> edwardk: Not yet; one more month in Portland :^) 
10:52:28 <jmcarthur> ezyang: what you going to boston for?
10:52:39 <jmcarthur> seems like all of #haskell is going to boston
10:52:41 <edwardk> ezyang: shucks. so much for using you to fill the other timeslot i have for boston haskell around the 23rd ;)
10:52:43 <ezyang> jmcarthur: I go to school there :-) 
10:52:46 <jmcarthur> ah
10:52:56 <ezyang> edwardk: Whoops :-) 
10:53:29 <edwardk> sok, i'll try to co-opt you for next time ;)
10:55:03 * ezyang wishes that there was a way to generate two versions of Haddock documentation, one internal and one external. 
10:55:09 <edwardk> jmcarthur: it is all part of my fiendish plot. 1. Get all the #haskellers to boston. 2. ??? 3. Profit!
10:58:07 <Saizan> mh, living in boston this icfp would be easier to go to..
10:58:25 <chrisdone> hi
10:58:31 <copumpkin> Saizan: you should go to boston!
10:58:32 <ezyang> Hmm, I wonder if qualified names can have periods in them. 
10:58:35 <edwardk> Saizan: so much good stuff tied to this year's icfp!
10:58:55 <jmcarthur> ezyang: i think so
10:58:57 <edwardk> ezyang: as in import qualified Foo.Bar as Bar.Baz ? 
10:59:11 <ezyang> as in import qualified Foo.Bar.Unsafe as Bar.Unsafe, yep. 
11:00:37 * BMeph must ... resist... Unsafe.Fthagn
11:02:09 <edwardk> Unsafe.Klaatu.Barada.Nikto
11:02:42 <chrisdone> my haskell.el 'case anyone's interested http://gist.github.com/508523
11:03:35 <msieradzki> damn do I really have to switch to emacs from vim to get decent haskell support
11:03:39 <chrisdone> hmm. i might just fork haskell-mode on github
11:04:02 <ezyang> Hmm, I guess I need an Internal module too now. 
11:04:11 <jmcarthur> msieradzki: that depends on whether you are dedicated to adding good haskell support to vim. a lot of people do use vim for haskell, though
11:04:23 <jmcarthur> i had the fortune of already being an emacs guy
11:04:25 <msieradzki> with tabs and no rel formatting
11:04:29 <msieradzki> real *
11:06:25 <Saizan> edwardk: good stuff like?:)
11:07:36 <jmcarthur> i'm still curious what google is doing with haskell and how i can get in on it
11:07:37 <edwardk> Saizan: msfp, haskell workshop, the main conference, cufp. if i can get away for it, i'm going to be there for a long time. ;)
11:08:14 <edwardk> jmcarthur: they are doing something with Haskell? At last check it wasn't on their 'approved languages list' or whatever nonsense.
11:08:29 <jmcarthur> they at least are giving a talk at cufp
11:08:50 <jmcarthur> http://cufp.org/conference/sessions/2010/high-performance-haskell
11:09:32 <Saizan> well, they produced the new I/O manager, at least :)
11:09:51 <chrisdone> well, did tibbe do it in work time or "personal project" time?
11:10:03 <jmcarthur> wait... google proper funded it?
11:10:05 <chrisdone> that's kinda the difference between "google" and "tibbe"
11:10:35 <Saizan> jmcarthur: i was blurring the difference between google and tibbe, i don't know, really
11:11:02 <jmcarthur> oh, tibbe is not google? disappointing to hear that ;)
11:11:23 <Saizan> google-san
11:11:30 <chrisdone> msieradzki: there's more fun stuff going on in the emacs world of haskell
11:11:41 <msieradzki> like?
11:12:51 <jmcarthur> the benefit of vim is that it's just a text editor. the benefit of emacs is that it's more than a text editor
11:13:08 <edwardk> jmcarthur: i don't know if tibbe is there representing google so much as he is just a guy who likes to hack on haskell.
11:13:19 <edwardk> and who happens to work on haskell
11:13:29 <zygoloid> since we're talking about vim, does anyone know how to search for a non-matching line in vim? like less's /^Nfoo ?
11:14:00 <jmcarthur> i do recall somebody in here that works for google saying that google has used haskell for something internally, but he couldn't say what and already feared that he said too much
11:14:03 <msieradzki> well I guess I'll install it again
11:14:05 <msieradzki> and try it out
11:15:11 <quicksilver> jmcarthur: ...strangely he was never seen again.
11:15:18 <quicksilver> jmcarthur: coincidence, I'm sure ;)
11:15:27 <jmcarthur> heh
11:18:26 * chrisdone imagines the lively Haskeller being dragged into a room, and then being released a few minutes later with a sullen, cold stare and a Java book. resistance is futile
11:18:39 <jmcarthur> chrisdone: D:
11:18:45 <edwardk> zygoloid: .!grep -v ;)
11:19:28 <edwardk> zygoloid: you might be able to get creative with the 'negated lookbehind' as well. which is @<!
11:19:36 <luite> chrisdone: have you already noticed the IE issue in tryhaskell I mentioned earlier?
11:27:44 <zygoloid> edwardk: :) i've gone with /^\(pattern\)\@! which is ugly but effective.
11:30:17 <zygoloid> edwardk: (though it turned out that was too slow and i instead used less to find the line number and just jumped to that line in vim!)
11:30:50 <edwardk> fair nuff
11:31:09 <aristid> zygoloid: how can you show the line number in less?
11:31:16 <zygoloid> =
11:31:37 <edwardk> zygoloid: you could always just replace all lines that _match_ with nothing, and then see the lines that are left and undo ;)
11:31:59 <zygoloid> haha, that could be fun but my file is about 900MB
11:32:15 <edwardk> fair nuff, a rather big undo ;)
11:32:42 <zygoloid> if only vim were lazier ;-)
11:36:02 <mee> zygoloid: ffr, :h grep
11:36:43 * hackagebot wai-extra 0.2.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.2.2 (MichaelSnoyman)
11:40:37 <CalmNelly> help me lambda bot I'm on fire!
11:40:52 <chrisdone> @vixen is CalmNelly on fire?
11:40:53 <lambdabot> why don't you guess?
11:41:25 <CalmNelly> @vixen are you in a bad mood?
11:41:26 <lambdabot> i'm bad in a good way?
11:42:00 <CalmNelly> I need some help
11:42:11 <CalmNelly> I'm trying to use the new Parsec2 module
11:42:42 <CalmNelly> but i don't know how to tell the compiler that I want the new one, not the old
11:42:48 <chrisdone> in the words of Sheri Moon, ``I never try anything, I just do it! ... wanna try me?''
11:43:04 <CalmNelly> ?
11:43:09 <chrisdone> CalmNelly: how are you compiling? with ghc, cabal or ghci?
11:43:15 <CalmNelly> ghci
11:43:44 <chrisdone> hmm. do you get an ambiguous module name message or something similar?
11:43:50 <CalmNelly> yes i get that
11:44:25 <CalmNelly>    Ambiguous module name `Text.ParserCombinators.Parsec':
11:44:25 <CalmNelly>       it was found in multiple packages: parsec2-1.0.0 parsec-3.1.0
11:44:56 <chrisdone> try: ``:set -ignore-package <foo>'' where <foo> is the one you don't want
11:45:01 <EvanR-work> @vixen can haskell put out fires?
11:45:02 <lambdabot> Ooh, functional programmers are so hot!
11:45:02 <CalmNelly> @vixen can you pretend to be a kitten?
11:45:02 <lambdabot> i sure can
11:45:36 <jmcarthur> @faq Can Haskell put out fires?
11:45:37 <lambdabot> The answer is: Yes! Haskell can do that.
11:46:09 <wli> So basically f(x)-p(x) has the same sign as q=\pm\prod(x-x_k) and then you can use p+cq as your updated approximation for some c.
11:46:46 <chrisdone> CalmNelly: e.g. I have parsec 3.0 and 3.1 installed. here I ignore 3.1, so I get 3.0 loaded:
11:46:47 <chrisdone> λ> :set -ignore-package parsec==3.1.0
11:46:47 <chrisdone> package flags have changed, resetting and loading new packages...
11:46:47 <chrisdone> λ> :m + Text.Parsec
11:47:23 <EvanR-work> heh. unifont lambda is so weird
11:48:03 <EvanR-work> horizontally flipped h with a curly head
11:48:19 <chrisdone> in Deja Vu Sans Mono it looks awesome
11:48:20 <zygoloid> mee: cool, thanks, that looks really useful :)
11:48:20 <EvanR-work> it so could look like a normal lambda, but doesnt
11:48:44 * zygoloid was also pleased to learn that grep's name comes from vi's :g/re/p
11:48:50 <CalmNelly> chrisdone: what do i write in my actual file though
11:49:15 <CalmNelly> in my import list
11:50:27 <chrisdone> CalmNelly: I don't think there's a way to specify the version in the file
11:50:54 <CalmNelly> uh-oh
11:51:01 <chrisdone> CalmNelly: in your project.cabal file you can enter it, and you can write a .ghci file and put it in your project directory, so that when you load up ghci in that directory it automatically sets up what you need for that project
11:52:04 <CalmNelly> chrisdone: but what if someone else wants to run it on there comp?
11:52:23 <CalmNelly> and they don't have the new one
11:52:41 <monochrom> you're supposed to cabalize it if you want someone else to use it
11:54:42 <CalmNelly> oh
11:55:06 * CalmNelly starts sobbing uncontrollably
11:55:24 <luite> import "parsec-3.1.0" Text.Parsec
11:55:25 <monochrom> what a low EQ person
11:55:35 <EvanR-work> haskell has that effect sometimes
11:55:40 <EvanR-work> its so awesome it hurts
11:55:46 <monochrom> haha
11:56:15 <chrisdone> (... awesome like werewolf women of the SS. they're horrible people, but awesome)
11:57:21 <luite> CalmNelly: you can import form a specific package with that syntax: import "parsec-3.1.0" Text.Parsec
11:57:41 <luite> CalmNelly: if you enable the PackageImports extension
11:58:30 <CalmNelly> -XPackageImports
11:58:33 <CalmNelly> how do I set that
11:58:40 <verma> hello, everyone, I am new to haskell and learning pattern matching, can this code with condensed further? http://paste.plurk.com/show/288701/
11:58:51 <luite> CalmNelly: you probably shouldn't do that when making a cabal package though, since you use the cabal file to specify the visible packages
11:59:16 <chrisdone> (was hoping no one would mention PackageImports... specifying versions of packages in files seems morally questionable)
11:59:24 <monochrom> I would do that for my own toy programs, i.e., to be thrown away in a day. I wouldn't do that for "what if someone else wants to run it", clearly antithesis.
11:59:31 <shapr> Good Morning #haskell!
11:59:37 <shapr> How's code everybody?
11:59:45 <EvanR-work> shapr: im working on a game ;)
11:59:55 <monochrom> what if someone else wants to run it with 3.0.0 not 3.1.0
12:00:22 <CalmNelly> it probably wouldn't work
12:00:25 <shapr> EvanR-work: Awesome! What kind of game is it?
12:00:40 <EvanR-work> 2d arcade shooter
12:00:43 <chrisdone> shapr: it's goood. I'm continually hacking on emacs to make my Haskell Programming Experience™ more comfortable :-)
12:00:48 <CalmNelly> this is where the cabal file comes in I guess
12:00:50 <shapr> EvanR-work: Spiffy! Got any screenshots?
12:01:05 <mauke>  
12:01:13 <luite> chrisdone: sorry ;) I did warn him though :)
12:01:15 <shapr> chrisdone: Ooh, what improvements are you making? I've been playing with org-mode, but would love to improve my haskell-mode toys!
12:01:33 <EvanR-work> no, dont have graphics resources
12:01:36 <burp> verma: hm, what about something like "take 1 . drop 1 . reverse"?
12:02:02 <zygoloid> shapr: good evening!
12:02:02 <shapr> Anyone else having problems with "cabal install glib" ?  Says it's missing gtk2hsc2hs ?
12:02:10 <shapr> Hiya zygoloid! How's code for you?
12:02:15 <burp> verma: but looks fine to me :>
12:02:25 <verma> burp: oh, I am not familiar with the "." thing yet
12:02:53 <EvanR-work> @source print
12:02:53 <lambdabot> print not available
12:02:57 <burp> verma: oh it's just function composition
12:02:59 <EvanR-work> @src print
12:02:59 <lambdabot> print x = putStrLn (show x)
12:03:03 <zygoloid> shapr: i have too many types and type functions with similar names!
12:03:07 <EvanR-work> print = putStrLn . show
12:03:09 <monochrom> shapr: need gtk2hs-buildtools too
12:03:14 <osaunders> Is that a combinator that copies a parameter (applies it twice)?
12:03:22 <shapr> chrisdone: Is there a way to hook hlint into haskell-mode?
12:03:30 <CalmNelly> @vixen does Haskell code get you off?
12:03:30 <lambdabot> Ooh, functional programmers are so hot!
12:03:36 <Deewiant> ?pl \f x -> f x x
12:03:36 <lambdabot> join
12:03:40 <shapr> zygoloid: Are you going to add some abstractions to fix that?
12:03:48 <EvanR-work> :t join
12:03:48 <osaunders> Deewiant: Thanks
12:03:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:04:03 <burp> verma: hm, though it returns [] or [lastbutoneement] and not Maybe lastbutoneelement
12:04:04 <verma> burp: oh ok, I probably need to do some reading on that ..
12:04:14 <mauke> @hoogle [a] -> Maybe a
12:04:15 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
12:04:15 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
12:04:15 <lambdabot> Prelude head :: [a] -> a
12:04:19 <shapr> monochrom: Are the gtk2hs-buildtools available in cabal or through an ubuntu source?
12:04:20 <burp> > take 1 . drop 1 . reverse [1..10]
12:04:21 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
12:04:21 <lambdabot>    arising from a use...
12:04:22 <burp> > take 1 . drop 1 . reverse $ [1..10]
12:04:23 <lambdabot>   [9]
12:04:35 <burp> > take 1 $ drop 1 $ reverse [1..10]
12:04:36 <lambdabot>   [9]
12:04:37 <mauke> > listToMaybe . drop 1 . reverse $ [1..10]
12:04:38 <lambdabot>   Just 9
12:04:50 <verma> omg
12:04:57 <monochrom> shapr: I know it's on hackage. I don't know about ubuntu.
12:05:14 <burp> oh yes
12:05:15 <mauke> > listToMaybe . drop 1 . reverse $ "omg"
12:05:16 <lambdabot>   Just 'm'
12:05:32 <verma> lol, I think I asked this question too soon
12:05:33 <shapr> monochrom: Aha, bug in glib hackage then, since it doesn't depend on gtk2hs-buildtools
12:05:47 <burp> "The listToMaybe function returns Nothing on an empty list or Just a where a is the first element of the list."
12:05:50 <shapr> @hackage glib
12:05:50 <lambdabot> http://hackage.haskell.org/package/glib
12:05:51 <chrisdone> shapr: dude, easily
12:06:11 <shapr> preflex: seen dcoutts
12:06:11 <preflex>  dcoutts was last seen on #haskell 5 days, 1 hour, 57 minutes and 59 seconds ago, saying: Nibble: but if you did sudo cabal install, then that would install things as root in your home dir, which is a bad thing
12:06:16 <EvanR-work> verma: (f . g) x == f(g(x)) ;)
12:06:19 <monochrom> shapr: exe-only package. not sure it's a good idea to be depended on.
12:06:21 <luite> shapr: it's a known limitation
12:06:25 <luite> of cabal
12:06:27 <chrisdone> shapr: I just sent an email to the haskell-mode maintainer proposing that we smash out the current buglist and then we can work on really being inventive
12:06:34 <luite> cabal-install
12:06:37 <verma> EvanR-work: oh ok, that makes sense
12:06:39 <shapr> chrisdone: Ooh, sounds great, where's the bug list?
12:06:43 <eugenn> preflex: seen eugenn
12:06:43 <preflex>  eugenn was last seen on #haskell 16 hours, 49 minutes and 52 seconds ago, saying: > let number = 4 in 2 + number
12:06:50 <chrisdone> shapr: http://trac.haskell.org/haskellmode-emacs/report/6
12:06:57 <shapr> luite: glib can't depend on gtk2hs-buildtools?
12:07:06 <zygoloid> shapr: i'm randomly picking permutations of possible types until GHC is happy ;-)
12:07:22 <verma> why is it reverse $ "omg", and not reverse "omg"?
12:07:27 <roconnor> Typeable makes Haskell98 unsound!
12:07:37 <mauke> verma: it isn't reverse $ "omg"
12:07:40 <EvanR-work> verma: it can be (reverse "omg")
12:07:44 <shapr> zygoloid: Can you use the 'undefined' trick to find simpler types?
12:07:47 <zygoloid> roconnor: old news ;-)
12:07:52 <EvanR-work> er no it cant, missing context
12:08:06 <EvanR-work> verma: aka f . g $ x ;)
12:08:06 <luite> shapr: it has something to do with it being an executable and not a library package, but I forgot the exact details
12:08:09 <monochrom> FFI makes Haskell2010 unsound!
12:08:10 <zygoloid> shapr: the trouble is GHC is expanding my type synonyms and i'd like to give the nicer names :)
12:08:12 <roconnor> zygoloid: oh wait
12:08:33 <zygoloid> roconnor: we shouldn't be allowed to give non-derived Typeable instances
12:08:36 <roconnor> zygoloid: is this the same as Ix being (was) unsound?
12:08:51 <verma> EvanR-work: oh ok ok, that makes sense :) .. I will go read my book
12:09:09 <zygoloid> roconnor: it's worse than that. an efficient implementation can't really protect against it
12:09:26 <roconnor> true
12:09:37 <roconnor> was there an efficent fix to the Ix problem?
12:09:40 <zygoloid> (for Ix at least the efficiency hit was pretty small)
12:09:45 <roconnor> ok
12:10:39 <zygoloid> there's a pure formulation (no unsafeCoerce) in the paper which introduced Typeable, but it's linear in the size of the object being cast
12:10:48 <zygoloid> (basically it's a serialize + deserialize)
12:11:32 <monochrom> haha great idea for the next "how to convert int to double" question :)
12:12:05 <EvanR-work> > read (show (6::Int)) :: Double
12:12:06 <wli> Multiple precision floating point could help.
12:12:06 <lambdabot>   6.0
12:12:11 <EvanR-work> \o/
12:12:23 <monochrom> "hi, sum xs / length xs fails on me!"  "o hai, sum xs / read (show (length xs))"
12:13:36 <EvanR-work> a guy was in here claiming that sum xs / length xs could be optimized by the compiler (one pass over the list) by somehow making all list heads strict
12:13:53 <monochrom> "I hate having to fromIntegral all the time to work with GLInt!" "You can try read.show if you hate fromIntegral..."
12:14:18 <EvanR-work> monochrom: it takes up less space ;)
12:14:42 <EvanR-work> > let z = fromIntegral in z 5 :: Double
12:14:43 <lambdabot>   5.0
12:14:49 <mauke> > 5 :: Double
12:14:50 <lambdabot>   5.0
12:14:56 <EvanR-work> > let z = fromIntegral in z (5::Int) :: Double
12:14:57 <lambdabot>   5.0
12:14:59 <chrisdone> > ((,) `on` length) "read.show" "fromIntegral"
12:14:59 <lambdabot>   (9,12)
12:15:07 <chrisdone> we have a winner!
12:15:23 <EvanR-work> o_O
12:16:51 <jmcarthur> > join (&&&) (read.show) $ ((,) `on` length) "read.show" "fromIntegral"
12:16:52 <lambdabot>   (*Exception: Prelude.read: no parse
12:17:00 <jmcarthur> > join (&&&) (read.show) $ ((,) `on` length) "read.show" "fromIntegral" :: (Double, Double)\
12:17:01 <lambdabot>   <no location info>: parse error on input `\'
12:17:03 <jmcarthur> > join (&&&) (read.show) $ ((,) `on` length) "read.show" "fromIntegral" :: (Double, Double)
12:17:04 <lambdabot>   (*Exception: Prelude.read: no parse
12:17:39 <jmcarthur> > join (***) (read.show) $ ((,) `on` length) "read.show" "fromIntegral" :: (Double, Double)
12:17:40 <lambdabot>   (9.0,12.0)
12:17:43 <jmcarthur> (doh!)
12:18:26 <jmcarthur> > read.show.fst &&& read.show.snd $ ((,) `on` length) "read.show" "fromIntegral" :: (Double, Double)
12:18:27 <lambdabot>   (9.0,12.0)
12:18:37 * jmcarthur makes it worse and worse
12:19:17 <EvanR-work> @pl read.show.fst &&& read.show.snd $ ((,) `on` length)
12:19:18 <lambdabot> read . show . fst &&& read . show . snd $ (,) `on` length
12:19:19 <jmcarthur> > ((,) `on` read.show.length) "read.show" "fromIntegral" :: (Double, Double)
12:19:20 <monochrom> at least it is not a quine yet
12:19:21 <lambdabot>   (9.0,12.0)
12:19:29 <EvanR-work> @unpl read.show.fst &&& read.show.snd $ ((,) `on` length)
12:19:29 <lambdabot> (read (show ((fst &&& read) (show (snd (on ((,)) length))))))
12:19:50 <blups0r> hi
12:19:54 <Paczesiowa> can anyone tell me how to use progression with more than one recording?
12:20:12 <hithere> hi everyone
12:20:53 <Paczesiowa> hello
12:20:54 <hithere> Anyone can help with a simple php sending question?
12:21:07 <EvanR-work> php?!!?!
12:21:12 <hithere> yeah
12:21:14 <jmcarthur> kind of in the wrong channel for that i think
12:21:20 <blups0r> is there a way to make File io without carrying the IO ... with me
12:21:21 <hithere> oh sorry
12:21:27 <shapr> hithere: Would you like to learn to build websites in Haskell?
12:21:31 <luite> I used php yesterday, it felt bad :(
12:21:41 <jmcarthur> luite: use more lube
12:21:41 <monochrom> file io must carry the IO
12:21:42 * BrianHV would like to learn to build websites in Haskell.
12:21:47 <luite> jmcarthur: oh is that it
12:22:04 <hithere> :) is there another chat room for php?
12:22:09 <EvanR-work> #php
12:22:10 <blups0r> but that IO do i have to carry it to all funktions?
12:22:13 <jmcarthur> hithere: probably either #php or ##php
12:22:37 <hithere> i should have looked better before.. thanks jmc!
12:22:38 <monochrom> don't carry IO to all functions. carry all functions to IO.
12:23:10 <monochrom> i.e., just use your pure functions inside your main or do-block.
12:23:23 <blups0r> for example i have a string funktion that does some things with the string type :: String<-String and another funktion who reads a file and returns it like readDirectoryContents
12:23:55 <EvanR-work> String <- String  
12:24:00 <EvanR-work> my head just exploded
12:24:07 <blups0r> how can i give the Output of readDir.. to the string funktion
12:24:17 <blups0r> sorry type String -> String
12:24:38 <jedai> blups0r: so use "do stuff <- readDir; putStrLn (pureFunction stuff)"
12:24:51 <conal> iirc, "b <- a" is Dutch style.  has some benefits.
12:25:09 <nominolo> conal: aka Bird style
12:25:30 <conal> fits better w/ (.)
12:25:33 <nominolo> conal: "Dutch" because of Dijkstra?
12:25:45 <conal> nominolo: i've forgotten
12:25:55 <chrisdone> shapr: hmm. hlint would make a good post-action after a successful compile with ghci in emacs. I don't want to hear suggestions when I'm seeing compile errors, I'm too outraged. but once it compiles, suggestions would be welcome
12:25:57 <jedai> blups0r: ideally most of your processing and logic should be written with pure functions, IO should only be used to create the skeleton of your application
12:25:59 <conal> or maybe de bruijn?
12:26:04 <conal> anyone know?
12:26:07 <monochrom> Dijkstra didn't write like "codomain <- domain". But probably some other Dutch do.
12:26:21 <aristid> the dutch do seem to be somewhat overrepresented in research :P
12:26:37 <luite> hmm, I don't know any dutchpeople who use Dutch notation
12:26:50 <conal> aristid: they do seem to be brilliance-dense.
12:27:04 <aristid> conal: maybe.
12:27:06 <monochrom> Bird definitely writes like "codomain<-domain". See "The Algebra of Programming".
12:27:31 <aristid> conal: maybe they even understand your papers :)
12:27:31 <conal> monochrom: oh, yeah.
12:27:44 <conal> :)
12:32:27 <dark> haskell 1, me 0
12:32:31 <dark> :(
12:33:04 <dark> in the end i desisted and implemented it (a grammar to parse this: a, a -> b :- b) with ocamllex + ocamlyacc
12:34:12 <EvanR-work> left recursive grammar?
12:34:31 <dark> my problem was: figuring out how to work effectively with parsec api (i.e. how to write from scratch / understand it, instead of getting a snippet and tweaking it)
12:34:32 <dark> hmmm
12:34:47 <dark> to be honest, the problem is that i don't know a thing about grammars
12:34:59 <dark> my ocamlyacc program says "4 shift/reduce conflicts"
12:35:05 <dark> i hope it is saying my program rocks
12:35:09 <dark> :~
12:35:15 <FauxFaux> It means your parser is wrong.
12:35:33 <monochrom> ocamlyacc 1, you 0
12:35:34 <FauxFaux> If it doesn't say more than that, then you need to go learn how to write LR parsers by hand. ¬_¬
12:36:02 <dark> FauxFaux, how come? (ps: i introduced new conflicts by tweaking the operator order. i thought it was super cool, because ^ now binds before ->, etc)
12:36:16 <dark> LR
12:36:28 <nominolo> dark: it means your parser only works by accident (if at all)
12:36:42 <dark> when i searched about shift/reduce, wikipedia told me it has something to do with LR, yeah
12:36:54 <dark> nominolo, but, but.. one day i will learn all of this!!
12:36:58 <dark> :~
12:38:16 <dark> nominolo, the first thing I thought was: "ok, writing the lexer by hand is straightforward. now I just need some folds and a recursion and such to build the tree"
12:38:35 <dark> but I didn't figured out how to do this logic of getting a ( and waiting for a )
12:38:36 <EvanR-work> parsec is pretty nice if your grammar fits
12:38:36 <wli> GLR is really cool IMHO.
12:38:58 <dark> that's why I needed some library to do the code for me.. that's where I met parsec
12:39:15 <EvanR-work> dark: pastebin your grammar in BNF or something? 
12:39:32 <dark> ok just a moment
12:39:51 <wli> I'm not a big fan of parser combinators as they're now constituted.
12:40:09 <wli> Basically because they restrict grammars nastily.
12:40:30 <Paczesiowa> wli: ?
12:41:24 <wli> There's some sort of LL restriction.
12:41:44 <Paczesiowa> what's wrong with LL inf?
12:41:51 <monochrom> yacc-like parsers have restrictions just as badly.
12:42:57 <monochrom> go with earle parsers
12:43:06 <wli> yacc-like I'd not advocate per se. Generating source etc. isn't necessarily a good way to go.
12:43:59 <wli> I'd specify a grammar somehow (e.g. a grammar data structure) and then do GLR or some such (which has better determinism properties than Earley).
12:44:16 <yescalona> why haskell is more faster than python?
12:44:37 <monochrom> no, haskell can be slower than python.
12:44:48 <Paczesiowa> because GvR doesn't know what a tail-call is
12:44:48 <EvanR-work> it has more gremlins inside pushing the buttons
12:45:21 <luite> and we have dons and other fast-making-peoples
12:46:29 <dark> EvanR-work, lexer, http://codepad.org/oq6RNYU2 , parser http://codepad.org/ebasPXeI
12:46:41 <EvanR-work> C is slow, PHP is fast
12:47:52 <EvanR-work> dark: good, now someone might be able to help you ;)
12:48:41 <dark> EvanR-work, in fact, i thought about going here to ask this, #ocaml is sometimes.. low traffic .-. (sadly)
12:49:36 <blups0r> does someone know a good way to get all textfiles rekursive from a given directory
12:49:52 <EvanR-work> you gotta use OS specific api, like posix
12:50:07 <EvanR-work> System.Posix
12:50:21 <dark> why not calling find?
12:50:30 <EvanR-work> du
12:50:38 <EvanR-work> yeah find, all text files
12:50:51 <EvanR-work> but you probably isnt writing a shell script ;)
12:50:55 <EvanR-work> he*
12:50:55 <dark> parsing the string and error codes might be more troublesome than doing it thought this api
12:51:15 <dark> blups0r, what is a text file?
12:51:30 <EvanR-work> .txt 'extension' ;)
12:51:52 <osaunders> When you talk about multiplying things you use the word: multiplication. What's the equivalent for raising things to powers?
12:52:11 <EvanR-work> raising to the power of
12:52:16 <jmcarthur> exponentiation?
12:52:32 <osaunders> jmcarthur: Nice, thanks.
12:52:33 <EvanR-work> exponentiation probably means specifically e^x
12:52:45 <copumpkin> nah
12:52:45 <EvanR-work> rather than x^9
12:52:51 <jmcarthur> it means taking the exponent
12:52:53 <wioux1> polynomication
12:53:05 <monochrom> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/directory-1.0.1.1/System-Directory.html  should give you enough tools to go through directories and under.
12:53:08 <jmcarthur> which has nothing specifically to do with e, i think
12:53:09 <nphg`> potentiation
12:53:28 <EvanR-work> the word exponent traditionally means power of e
12:53:33 <EvanR-work> whereas power is more general
12:53:36 <monochrom> exponentiation refers to a^b generally too.
12:53:47 <jmcarthur> EvanR-work: wikipedia disagrees with you
12:53:49 <Tokki> nphg` that sounds like a bad direct translation 
12:53:52 <aavogt> your traditions are different then
12:53:56 * EvanR-work rewrites wikipedia
12:54:15 <monochrom> it's futile to argue over natural language meaning.
12:54:32 <monochrom> people can't even agree on "is 0 natural" and "0^0=?"
12:54:43 <EvanR-work> 0^0 is obviously 1
12:54:43 <jmcarthur> EvanR-work: exp is the "exponential function"
12:54:56 <copumpkin> > 0 / 0
12:54:57 <lambdabot>   NaN
12:55:04 <wioux1> > 0^0
12:55:05 <lambdabot>   1
12:55:07 <Tokki> EvanR-work if you define it to be so 
12:55:07 <EvanR-work> exponentiation, says to me exp(x)
12:55:12 <wioux1> haskell says so
12:55:18 <monochrom> in any case, observe that people say 2^n "grows exponentially"
12:55:27 <EvanR-work> yeah other bases
12:55:31 <nphg`> Tokki, i know :)
12:55:40 <jmcarthur> EvanR-work: adopting this in black and white can only lead to confusion later
12:55:46 <jmcarthur> this is regardless of whether i agree with you
12:56:06 <EvanR-work> im already confused
12:56:08 <Tokki> monochrom that's because no single solution fits all 
12:56:19 <conal> EvanR-work: some things become less obvious when given more careful thought.
12:56:29 <EvanR-work> im joking about 0^0
12:56:42 <EvanR-work> stupid internet chat
12:56:44 <burp> > take 15 [ x^x | x <- [1..] ]
12:56:44 <lambdabot>   [1,4,27,256,3125,46656,823543,16777216,387420489,10000000000,285311670611,8...
12:56:45 <conal> ah
12:56:49 <conal> yeah
12:57:03 <burp> @oeis 1 4 27 256 3125 46656
12:57:04 <lambdabot>  Number of labeled mappings from n points to themselves (endofunctions): n^n.
12:57:04 <lambdabot>  [1,1,4,27,256,3125,46656,823543,16777216,387420489,10000000000,285311670611,...
12:57:10 <monochrom> this is why "meaningful identifier" is flawed
12:57:59 <jmcarthur> arguments over definitions remind me of bikeshedding in that both kinds of arguments are pointless
12:58:26 <jmcarthur> once a definition is ambiguous enough to be argued over the word has already lost meaning
12:58:56 <aavogt> there's some meaning. It's not as if you go calling   a -> b   exponentiation every day
12:59:06 <copumpkin> you should
12:59:11 <jmcarthur> the most sensible thing to do if one finds himself in the minority of such an argument is to adopt the more common meaning for the word, otherwise we lose vocabulary
12:59:18 <monochrom> that's just because I am not a category theory professor
12:59:29 <wioux1> in cases like this its about what's practical
12:59:38 <Paczesiowa> has anyone used progression?
12:59:49 <monochrom> I don't know what is progression.
13:00:09 <Paczesiowa> criterion wrapper
13:00:10 <wioux1> sometimes its just practical to lump {0} with {1,2,..}.. in this case its practical to fill the gap in addition, multiplication, _, tetration ...
13:00:10 <aavogt> the opposite of regression
13:00:38 * monochrom invents "titration" over numbers...
13:00:53 <aavogt> proof by exhaustion
13:01:12 <dark> blups0r, I know this isn't what you want, but I find this interesting: find directory -type f -exec sh -c 'file --mime-type "$0" | grep -q text' '{}' ';' -and -print
13:01:21 <EvanR-work> the reader gets too tired the read the proof anymore, and assumes its true
13:02:14 <wioux1> heh.. but its also the form wherein one eliminates all but one possibility
13:02:40 <jmcarthur> i like EvanR-work's definition better
13:02:41 <aavogt> so ghci keeps expanding it's memory footprint as you reload the file repeatedly?
13:02:42 <monochrom> and get very tired
13:03:00 <monochrom> yes ghci grows
13:03:30 <Saizan> aavogt: i think they fixed that in the HEAD
13:04:52 <aavogt> I guess one workaround until that patch percolates would be if emacs killed ghci every 5th C-c C-l
13:04:55 <blups0r> is there a concat funktion availiable in haskell
13:05:08 <jmcarthur> :t concat
13:05:09 <lambdabot> forall a. [[a]] -> [a]
13:05:13 <jmcarthur> :t (++)
13:05:14 <lambdabot> forall m. (Monoid m) => m -> m -> m
13:05:16 <osaunders> http://codepad.org/xdS7LZdO
13:05:18 <jmcarthur> depending what you mean
13:05:22 <jmcarthur> dangit caleskell
13:05:22 <EvanR-work> > concat ["a", "b", "c"]
13:05:23 <lambdabot>   "abc"
13:05:32 <jmcarthur> :t (Prelude.++)
13:05:33 <lambdabot> forall a. [a] -> [a] -> [a]
13:05:41 <jmcarthur> > "foo" ++ "bar"
13:05:41 <lambdabot>   "foobar"
13:06:50 <EvanR-work> > concat [[],[],[]]
13:06:51 <lambdabot>   []
13:06:57 <EvanR-work> > concat []
13:06:57 <lambdabot>   []
13:07:24 <EvanR-work> i like it when functions work
13:07:38 <Cydergoth> Hi all. How strong is the recommendation not to use GHC.Prim data types, and what criteria should I apply when choosing [not] to?
13:08:01 <EvanR-work> > concat [[[]]]
13:08:02 <lambdabot>   [[]]
13:08:12 <EvanR-work> > concat [[]]
13:08:13 <lambdabot>   []
13:08:16 <EvanR-work> > concat []
13:08:17 <lambdabot>   []
13:08:22 <EvanR-work> :o
13:08:26 <burp> > [1..10] !! 11
13:08:27 <lambdabot>   *Exception: Prelude.(!!): index too large
13:08:28 <Cydergoth> This is in the context of large arrays of homogeneous (primitive) data types
13:08:34 <burp> throwing exceptions is ugly :|
13:08:54 <jmcarthur> Cydergoth: i think vector uses it
13:08:58 <EvanR-work> its better than making up a value randomly
13:09:04 <EvanR-work> like php
13:09:12 <burp> is php doing that? :O
13:09:16 <EvanR-work> yes
13:09:20 <EvanR-work> try doing that array lookup in php
13:09:27 <jmcarthur> the exception thrown by (!!) is semantically just _|_. you aren't supposed to catch it
13:09:36 <EvanR-work> right
13:09:39 <EvanR-work> it means your code is broken fix it
13:09:40 <jmcarthur> because you aren't supposed to end up throwing it in a correct program
13:09:59 <EvanR-work> but in broken procedures in php is the norm
13:10:01 <jmcarthur> whether you like partial functions is another story though :)
13:10:04 <Cydergoth> There is no such thing as a correct program in the real world
13:10:07 <wioux1> why doesn't it just return `undefined`?
13:10:08 <burp> hm yeah, but I don't like the idea that it can throw an exception :>
13:10:13 <jmcarthur> Cydergoth: what makes you say that?
13:10:18 <Cydergoth> IO ;-)
13:10:23 <Paczesiowa> jmcarthur: so the difference between haskell and php is a nice story with a pretty symbol?
13:10:28 <aavogt> can some newer version of ghc tell you exactly who called the (!!) that failed though? Or is the current workaround for that to use total functions still?
13:10:28 <jmcarthur> IO inherently cannot be correct?
13:10:41 <Cydergoth> Yup. Not in the real world
13:10:44 <jmcarthur> Paczesiowa: i'm not making excuses. i'm prescribing discipline
13:11:06 <jmcarthur> Cydergoth: a strange claim, IMO
13:11:13 <Cydergoth> Especially as most IO is implemented using interrupts (which everyone knows are bad)
13:11:22 <Paczesiowa> compilers shouldn't  provide error/undefined, that would solve many problems
13:11:26 <jmcarthur> "everyone knows"
13:11:26 <dark> a code that has some obvious possibility of failure has no place in.. hmm..
13:11:50 <Cydergoth> jmcarthur: Ok, it is the old story of a fault in async code 
13:12:00 <wioux1> IO is correct if it meets the language spec
13:12:06 <Cydergoth> Which leaves state in other areas undefined
13:12:14 <jmcarthur> Cydergoth: your argument appears to be a sweeping generalization
13:12:18 <dark> i mean, the real reason that returning maybe int is better than returning a int where -1 is the error state, is that what do you do if you get -2?
13:12:26 <Cydergoth> jmcarthur: of course it is
13:12:34 <dark> "impossible" states shouldn't happen by design
13:12:39 <dark> not just by careful coding
13:12:44 <Cydergoth> But a weeping generalisation which applies to most real world CPUs
13:12:47 <jmcarthur> Cydergoth: sweeping generalization is a logical fallacy
13:13:17 <dark> Cydergoth, hardware failure has nothing to do with software correctness
13:13:35 <dark> Cydergoth, in order to get it to work, you have to get *both* hardware and software to work
13:13:37 <Cydergoth> It doesn't have to be hardware failure, there are conditions in software interrupts which cause issues
13:13:51 <aavogt> jmcarthur: your statement applies to itself :)
13:13:56 <jmcarthur> Cydergoth: if those conditions are well-defined then we are not prevented from handling them correctly
13:14:10 <Cydergoth> jmcarthur - they aren't in many (all) real world CPUs
13:14:11 <jmcarthur> aavogt: which statement?
13:14:20 <aavogt> sweeping generalization is a logical fallacy
13:14:22 <Cydergoth> Maybe in a few NASA/aeronautics use
13:14:29 <Paczesiowa> dark: "impossible" states shouldn't happen period. design is just one option
13:14:44 <Cydergoth> Hence the research into formally provable CPUs 
13:14:47 <jmcarthur> Cydergoth: if they are not well defined then we are talking about bad hardware, not bad software
13:15:07 <Cydergoth> jmcarthur: at the level of microcode, hardware is software
13:15:25 <Cydergoth> Physical limits also apply, like latency, limited RAM etc
13:15:35 <Cydergoth> communication failures
13:15:41 <Cydergoth> etc
13:15:50 <jmcarthur> Cydergoth: none of these things have to do with the correctness of software. you are talking about robustness, which in my mind is an entirely different matter
13:16:06 <Cydergoth> If it isn't robust (in the real world) it isn't correct
13:16:17 <jmcarthur> another strange claim, to me
13:16:25 <jmcarthur> what if robustness is not part of the specification?
13:16:45 <jmcarthur> must my pure code be robust to hardware failure in order to be correct?
13:16:48 <Cydergoth> That is rare in industrial programming. 
13:16:50 <wioux1> correctness is meeting the spec
13:16:55 <dark> Cydergoth, the problem of correctness is that programmers *do not understand* their programs. i mean, programs as a mathematical/abstract sense
13:17:06 <dark> they code something thinking it means X, and thus will do what X describe
13:17:13 <interferon> i'm trying to write length in terms of a fold operator and i have "foldr (\_ total -> total + 1) 0"  can i write that without an anonymous function and without losing clarity?
13:17:14 <dark> but they are wrong, because the mess was too much complex to them
13:17:14 <Cydergoth> I've already said that the issue is not hardware failure, but the inherent limitations in the hardware, which is something different i 
13:17:28 <Cydergoth> dark: yes, I agree with that
13:17:31 <jmcarthur> Cydergoth: a program can exist independently of hardware
13:17:42 <jmcarthur> it's merely an idea, like any mathematics
13:17:51 <Cydergoth> jmcarthur: My first constraint on the domain was 'real world'
13:18:01 <jmcarthur> "real world" is a fuzzy term
13:18:10 <jmcarthur> my real world may be different from yours
13:18:29 <wioux1> i> foldr (uncurry ((+1) . snd)) 0 [1,2,3,4,5]
13:18:33 <Cydergoth> Real world means not abstract ideas and maths, but something I can execute on physcial hardware
13:18:35 <dark> Cydergoth, first, you need to get programmers to actually understand the program. this probably has to do with verification and formal definitions, it's not just careful coding..
13:19:03 <monochrom> "real world" is subjective
13:19:12 <dark> Cydergoth, this understanding is purely abstract/mathematical, it's about a description of some abstract process (you see, we still get trouble with *this*)
13:19:12 <Cydergoth> dark: I understand that, and one of my points is that most real CPUs aren't formally verified, and indeed with interrupt based IO, it is very hard to do the verification
13:19:14 * hackagebot uu-parsinglib 2.5.2 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.2 (DoaitseSwierstra)
13:19:20 <jmcarthur> Cydergoth: i'd still say that software cannot be to blame for hardware failure. i don't see what you expect software to be able to do about that
13:19:31 <dark> Cydergoth, in parallel, it is possible to fix hardware too
13:19:54 <Cydergoth> dark: Certainly. But the stuff running in data centers and people's homes *isn't* fixed
13:19:55 <yorirou> hi
13:20:07 <wioux1> > foldr (uncurry ((+1) . snd)) 0 [1,2,3,4,5]
13:20:08 <lambdabot>   2
13:20:22 <Cydergoth> The stuff running in the Shuttle may be, and in some fighter aircraft, but x64 certainly isn't
13:20:31 <wioux1> > foldr (uncurry ((+1) . fst)) 0 [1,2,3,4,5]
13:20:32 <lambdabot>   2
13:20:46 <dark> jmcarthur, i know that linux try to make buggy hardware to behave well
13:20:51 <jmcarthur> Cydergoth: to be more precise, you seem to have won the argument by using definitions which are not only atypical but also change the meaning of your hypothesis from "programs can never be correct" to "hardware can never run a correct program correctly"
13:20:55 <aavogt> Cydergoth: so how does this affect how you write code?
13:21:18 <dark> i.e. if the system know the hardware is broken, it can workaround it
13:21:23 <Cydergoth> jmcarthur: no, I stated real world right from the start
13:21:26 <dark> (sometimes)
13:21:34 <jmcarthur> Cydergoth: again, that's a fuzzy term
13:22:06 <interferon> wioux: i have "const (1+)"
13:22:07 <Cydergoth> Ok, so if I'm working on a network driver for a wifi card, I need to handle a number of exceptional conditions which can be raised at any time asynchronously
13:22:09 <jmcarthur> Cydergoth: i write correct programs in the real world all the time (i hope), but you would be quick to point out that the hardware may still screw it up. that doesn't change the correctness of my *code*
13:22:09 <interferon> but i think that loses clarity
13:22:21 <CalmNelly> @vixen I killed this hooker the other night, what should I do?
13:22:21 <lambdabot> whoa whoa whoa, one question at a time!
13:22:41 <monochrom> jmcarthur: you should also try to win the argument by defining "correct" suitably ;)
13:22:50 <jmcarthur> monochrom: i suppose so ;)
13:22:51 <CalmNelly> @vixen sorry, I'm just freaking out right now
13:22:51 <lambdabot> don't worry about it
13:22:55 <Cydergoth> I can try to force the code to be synchronous using message queues
13:23:13 <Cydergoth> I can try to handle the asynchronous event in hardware
13:23:18 <jmcarthur> Cydergoth: i think monochrom is on to something. what definition are you using for "correct" here?
13:23:19 <wioux1> > foldr (curry ((+1) . snd)) 0 [1,2,3,4,5]
13:23:20 <lambdabot>   5
13:23:40 <monochrom> it's actually fair. define "relative correctness": is the software correct if the hardware and environment are correct? if yes, good enough.
13:23:42 <dark> the other problem is that while it may hard to write code conforming to some specification, it's harder to know what is the "right" spec. the system isn't right if it doesn't do what was intended, because the programmer overlooked some hardware aspect (i.e. because the program specification was wrong). maybe this is what Cydergoth is trying to say..
13:23:47 <Cydergoth> jmcarthur: Correct means the customer isn't screaming at you for a fix ;-)
13:24:13 <jmcarthur> Cydergoth: i have seen many very happy customers not screaming for fixes ;)
13:24:28 <jmcarthur> maybe you should fine tune that definition a little ;)
13:24:50 <monochrom> don't speak of hardware like it's a random number generator. hardware has specs too.
13:24:51 <Cydergoth> jmcarthur: can you _guarantee_ that your program will never cause them to scream for a fix? 
13:24:55 <wioux1> interferon: (curry ((+1) . snd)) -- but why not use a lambda?
13:25:10 <jmcarthur> Cydergoth: i can do that on the condition that they run it on correct hardware
13:25:31 <interferon> wioux1: the lambda is inelegant in that example.  i prefer my (const (1+)) to that
13:25:32 <jmcarthur> Cydergoth: which i think is a reasonable condition in the real world
13:25:35 <monochrom> in fact have you stupid coders ever seen hardware data sheets? they put your docs to shame. hardware data sheets give so much more concrete specs.
13:25:38 <wioux1> don't speak of random number generators like they're ruby. random number generators have specs too
13:25:40 <jmcarthur> even if it's "unrealistic"
13:26:05 <Cydergoth> jmccarthur: but my point is that you can't count on the hardware, as it is just very complex software without a formal proof
13:26:20 <jmcarthur> Cydergoth: i certainly would not do business with somebody who is going to blame my software for problems cause by faulty hardware
13:26:20 <Cydergoth> And there are known areas where current generations of CPUs are non-deterministic
13:26:38 <jmcarthur> or at least not if i can predict it
13:26:47 <Cydergoth> Interrupts being the classic one, but there are also timing issues on cache coherence etc
13:26:59 <Cydergoth> DMA being another
13:27:08 <ezyang> Formally verifying software all the way down to hardware is an active research problem. 
13:27:21 <monochrom> whereas coder docs are too smug to even say "this function takes O(n) space and O(n) time", hardware data sheet says clearly "at 5.0V this chip draws 100-150mA current". look, not even stupid asymptotes. hard numbers.
13:27:41 <Cydergoth> ezyang: Which was basically my point ;-)
13:27:59 <jmcarthur> ezyang: does that mean correct software is impossible?
13:28:11 <monochrom> you coders who pretend to talk about the real world has no idea what the hardware world is like.
13:28:19 <Cydergoth> Anyway, enough playing devil's advocate. Can anyone answer my question on the recommendation to (not) use GHC.Prim?
13:28:25 <ezyang> jmcarthur: I doubt it. However, we haven't figured it out yet. 
13:28:37 <monochrom> this is why you coders can't be called engineers yet.
13:28:41 <jmcarthur> ezyang: i'm with you there
13:29:00 <Cydergoth> monochrom: I've done a lot of embedded programming and I have an FPGA dev kit on my desk ;-) I think I understand real CPUs quite well ;-)
13:29:07 <monadic_kid> has anyone used patch-tag.com?
13:29:15 <Paczesiowa> monadic_kid: yes
13:30:06 <ezyang> API design question for y'all. In order to add a new feature to a monad stack, I've had to make the reader transformer a little more complex.  It's now not clear to me what I should do for the old functions that refer to this API. 
13:30:24 <monadic_kid> i get this error message trying to push: "darcs failed:  Incompatibility with repository snk_kid@patch-tag.com:/r/snk_kid/jhc-sdl:
13:30:24 <monadic_kid> Cannot mix darcs-2 repositories with older formats"
13:30:40 <interferon> ezyang: what do you mean, more complex?
13:30:42 <ezyang> For example, I should probably preserve my MonadReader OriginalType instance. 
13:30:57 * BMeph hasa a theory that Haskell's success is related to the consistent naming...of its adherents! :)
13:31:02 <ezyang> interferon: Basically, ReaderT Foo became ReaderT (Foo, Maybe Foo) 
13:31:07 <Paczesiowa> monadic_kid: what darcs version do you use?
13:31:08 <BMeph> s/sa/s/
13:31:28 <monadic_kid> Paczesiowa: 2.4.4
13:31:38 <ezyang> So I could theoretically support the old interface by defaulting the Maybe Foo to Nothing.  But I'm wondering if this is a good idea. 
13:31:51 <ezyang> Because then I'd need to add all sorts of functions to support the full interface. 
13:32:22 <Paczesiowa> monadic_kid: I would pull a copy of patch-tag repo, delete it, create it again to force usage of new darcs repo format, push the old contents and finally push the new patch
13:33:04 <ezyang> the added type is useful only in very specific cases. 
13:33:29 <monadic_kid> Paczesiowa: I where I did a darcs get origionally wasn't from patch-tag
13:34:16 <BMeph> ezyang: Although this isn't mean as a joke suggestion (it does sound funny), it sounds like you're situation is perfect for...a zygomorphism! =8*O
13:34:31 <BMeph> isn't *meant* as a joke...
13:34:49 <roconnor> it is just me or does the new haddock have *huge* margins?
13:34:50 <ezyang> BMeph: Hmm. 
13:35:23 <ezyang> tears down the structure with a helper function 
13:35:42 <Paczesiowa> monadic_kid: I think that patch-tag has a repo with old format
13:35:47 <ezyang> Not... useful. 
13:35:59 <Paczesiowa> monadic_kid: maybe it was created long time ago?
13:36:34 <monadic_kid> Paczesiowa: quite possible, it's the SDL bindings, i've modified them to work with jhc and jhc wii cross-compile
13:37:10 <roconnor> heh, I didn't even know Hadock produced framed versions
13:37:18 <ezyang> Ok, I'm going to go the route of keeping the old functions 
13:37:34 <jmcarthur> ezyang: if you had a getFoo function then that should be the only thing that changes. really to answer the question most appropriately depends on how many functions you were allowing to access the internals of your transformer stack and in what ways
13:38:18 <ezyang> jmcarthur: The monad stack is not exported, but I have unsafe functions that act as an escape hatch. 
13:38:29 <jmcarthur> ah
13:38:41 <jmcarthur> unsafe functions always complicate abstractions like this
13:38:50 <ezyang> Yeah. It would be a lot simpler w/o them. 
13:39:02 <ezyang> Unfortunately, the primary client for this code needs the unsafe interface :-( 
13:39:23 <jmcarthur> you are sure that you aren't just exposing the wrong interface then? :)
13:39:47 <monadic_kid> Paczesiowa: there is a darcs convert command
13:39:48 <Saizan> roconnor: i find the new style harder to read, but i don't know why
13:39:53 <ezyang> jmcarthur: But the safe interface is sooo much prettier! :-) 
13:40:00 <Cydergoth> Ok, going back to my original question: how strong is the recommendation not to use GHC.Prim?
13:40:02 <ezyang> And the client is doing some pretty horrendous things with unsafePerformIO 
13:40:04 * BMeph glares suspiciously at "unsafeMucksAboutInTheRepresentationalInternalsForValues" function...
13:40:06 <Paczesiowa> monadic_kid: maybe try sshing to patch-tag and running that
13:40:08 <ezyang> Cydergoth: What for? 
13:40:09 <jmcarthur> ezyang: can you say what this interface is for?
13:40:22 <ezyang> jmcarthur: Sure. It's an interface to an FFI library that builds up AIG graphs. 
13:40:25 <Cydergoth> large arrays of graphics data (homogeneous primitive data types)
13:40:31 <jmcarthur> Cydergoth: if it's for arrays i suggest seeing how vector does it (or just using vector)
13:40:39 <ezyang> Cydergoth: See if you can use vector. 
13:40:47 <monadic_kid> Paczesiowa: I've added a public key, which I use for github aswell, can reuse keys?
13:40:53 <Cydergoth> Is vector efficient?
13:41:07 <jmcarthur> Cydergoth: it's stream fused :)
13:41:11 <ezyang> jmcarthur: I don't know how much I can talk about the code that uses it. 
13:41:12 <copumpkin> omg fusion
13:41:17 <copumpkin> it goes so fast it melts your processor
13:41:22 <Paczesiowa> monadic_kid: why not
13:41:24 <Martty> 김수지 ( 8월2일 ) 님의 말 :
13:41:28 <ezyang> but with any luck I can open source the FFI bindings at the end. 
13:41:29 <Martty> sorry about that
13:41:32 <monochrom> and generates more energy than you give it
13:41:35 <jmcarthur> i am not very familiar with AIG graphs
13:41:40 <monadic_kid> Paczesiowa: I'm going to try to convert
13:41:47 <Cydergoth> stream fused?
13:41:52 <BMeph> copumpkin: ...and if you get too close, it'll shave your face! Nice and smooth, but still... ;)
13:41:54 <ezyang> jmcarthur: Probably the best analogy for this design purpose is the ST monad. 
13:42:04 <jmcarthur> ew :)
13:42:10 <ezyang> building up the AIG graph involves doing a bunch of mutation, but when you're done you've got a pure value. 
13:42:31 <ezyang> (mostly. sort of.) 
13:42:34 <ezyang> :-) 
13:42:51 <jmcarthur> i'm assuming this "building up" phase involves a ton of FFI
13:42:55 <ezyang> Yup. 
13:43:36 <ezyang> So I've crafted a nice, functional API for the library, but the system I'm integrating it into actually wants just an imperative interface. 
13:43:51 <ezyang> Instead of making another module, I've decided just to export escape hatch functions. 
13:44:02 <jmcarthur> i guess with my limited knowledge of all this i can't really suggest an alternative, so... good luck :)
13:44:21 <ezyang> Thanks 
13:44:27 <Cydergoth> Ok, thx, vector.Unboxed looks like what I need ;-)
13:44:39 <jmcarthur> where do you work that you get to do haskell? (i'm assuming that's what this is)
13:44:45 <jmcarthur> oh you're in portland...
13:44:46 <ezyang> jmcarthur: Galois! :-) 
13:44:49 <jmcarthur> heh
13:45:05 <c_wraith> I'm in portland, work in haskell, and don't work for Galois. :)
13:45:18 <ezyang> c_wraith: Where do you work? 
13:45:25 <jmcarthur> ezyang: i am finishing up my last week with pikewerks. we were going to collaborate with galois on something eventually, but i guess i won't see that day unless i end up working for galois ;)
13:45:54 <ezyang> jmcarthur: Hee :^) 
13:46:19 <c_wraith> ezyang: Janrain.  Ask Josh Hoyt and Jonathan Daugherty about me. :)
13:46:21 <jmcarthur> ezyang: is it very "defense-contractor-ish" there?
13:46:53 <ezyang> jmcarthur: We field some contracts for defense, but we also have other clients. 
13:47:02 <ezyang> c_wraith: Aha. :-) 
13:47:16 * jmcarthur bookmarks janrain
13:47:18 <ezyang> Having never worked for a devoted defense contractor shop, I couldn't really say :-) 
13:47:52 <c_wraith> I worked on a darpa contract in school.  is that the same thing?
13:48:04 <Saizan>  /win 20
13:48:20 <jmcarthur> both pikewerks and galois have at least looked into darpa stuff
13:48:24 <monochrom> haha you have 20 irc windows?!
13:48:31 <ezyang> Yeah. I don't know enough to say any further though 
13:48:43 <jmcarthur> monochrom: counting privmsg buffers i have had over 50 before...
13:48:59 <ezyang> Re previous conversation: I think I'm going to make my unsafe functions track the internal API as closely as possible. 
13:49:14 <monochrom> it must have felt like "my day job is interactive tech support"
13:49:21 <aavogt> monochrom: the situation is the same how it's most likely that your friends have more friends than you
13:49:34 <monadic_kid> Paczesiowa: convert works, thanks for trying anyway
13:49:49 <aavogt> you're more likely to see people with more irc windows
13:53:23 <Heffalump> byorgey: ping?
13:56:42 <roconnor> wow, the industrial haskell group has an unforutnate logo
13:57:27 <roconnor> thoses three gears just make me think deadlock
13:57:52 <aristid> roconnor: enterprisey logos must be unlogical
13:57:58 <roconnor> oh ok
13:58:57 * BMeph thinks it "needz moar lambdas"
13:59:46 <msieradzki> it wouldn't be called industrial then :)
14:01:24 <roconnor> does anyone read the HCAR?
14:06:59 <ezyang> Hm. I want MonadReader without local. 
14:07:23 <roconnor> ezyang: use MonadLib?
14:07:50 <jmcarthur> monadLib++
14:07:58 <ezyang> Too much effort :-) 
14:08:07 <roconnor> fine, use undefined
14:08:08 <jmcarthur> ezyang: make a wrapper that doesn't expose local
14:08:31 <ezyang> Yeah, that's my plan. 
14:08:35 <jmcarthur> wrappers make the world go 'round
14:08:39 <ezyang> (erm, jmcarthur, not roconnor) 
14:08:46 <roconnor> ezyang: don't come crying ot #haskell when your ContT State monad doesn't work the way you expect.
14:08:48 <ezyang> go go team newtype! 
14:09:02 <ezyang> roconnor: .... 
14:09:06 <roconnor> fair warning
14:09:12 <ezyang> Thanks. I'll keep that in mind :^) 
14:09:16 <aristid> jmcarthur: MonadLib also has the advantage of not interfering with mtl
14:09:28 <roconnor> ezyang: the mtl has a broken instance of ContT State ... or maybe StateT Cont.  I can never remember
14:09:41 <ezyang> Why don't they fix it? 
14:10:16 <roconnor> probably some combination of breaking backwards compatibility and not believing it is an error and not caring
14:10:22 <Heffalump> roconnor: I read it
14:10:36 <roconnor> Heffalump: okay, maybe I should write an entry sometime
14:13:05 <jmcarthur> @unmtl ContT r State s a
14:13:06 <lambdabot> err: `State r' is not applied to enough arguments, giving `/\A. r -> (A, r)'
14:13:13 <ezyang> om nom nom indirection. 
14:13:19 <jmcarthur> @unmtl ContT r (State s) a
14:13:20 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
14:13:40 <jmcarthur> @unmtl StateT s (Cont r) a
14:13:41 <lambdabot> s -> (a -> s -> r) -> r
14:14:19 <roconnor> probably the ContT State instance that is broken.  That type looks complicated enough to get instances of functions wrong.
14:15:07 <ezyang> I'm not really sure if state and cont commute. 
14:15:14 <jmcarthur> i doubt it
14:15:25 <roconnor> ezyang: they don't
14:15:27 <jmcarthur> doesn't mean those are both correct though :)
14:15:34 <ezyang> ok. 
14:15:39 <roconnor> the types are correct
14:15:48 <jmcarthur> yeah that's not what i meant of course
14:15:51 <ezyang> so then, in one version the continuation has state associated with it, but the other version the state is a global thing. 
14:16:02 <roconnor> it's the instances that are wrong.  IIRC it is the MonadState instance that is wrong.
14:16:22 <roconnor> but I'm not sure
14:16:51 <jmcarthur> is it fixed in transformers?
14:16:57 <roconnor> I forget
14:17:34 <monochrom> not MonadState per se. MonadCont. when you use callCC and actually exercise the escape option, should state be reverted or not? that's the question.
14:18:11 <ezyang> well, it would depend on which is outside. 
14:18:16 <ezyang> I haven't figured out which though :-) 
14:18:21 <roconnor> monochrom: with StateT Cont, there is only one choice IIRC.
14:18:37 <jmcarthur> it's pretty clear how ContT IO should work at least
14:20:17 <ezyang> Mm, that's true. 
14:20:31 <roconnor> @unmtl ContT r IO a
14:20:32 <lambdabot> (a -> IO r) -> IO r
14:20:43 <jmcarthur> that doesn't mean we should decide ContT State's behavior based on something as finnicky as IO though ;)
14:20:44 <ezyang> So I guess ContT State should not reset the state. 
14:20:52 <ezyang> oh, is that the point of disagreement? 
14:21:00 <roconnor> ezyang: something like that
14:21:15 <ezyang> I mean, ContT STM would be kind of neat. 
14:21:29 <jmcarthur> mind blown
14:21:34 <ezyang> and in that case, you definitely want the opposite semantics of IO 
14:21:40 <ezyang> since that's what STM is all about, no? 
14:21:40 <jmcarthur> are you sure?
14:21:49 <ezyang> No! 
14:22:10 <jmcarthur> it would at least be neat to look into whether callCC should orElse
14:22:11 <monochrom> you see now it's harder than reciting "it is wrong" :)
14:22:27 <ezyang> Maybe we should have TimeMachineT 
14:22:44 <jmcarthur> i do think that having two ContTs might be a valid solution
14:22:46 <yitz> ezyang: the FRP people are working on that one
14:23:09 <jmcarthur> yitz: :P i don't think that really summarizes what FRP is trying to tackle
14:23:29 <yitz> jmcarthur: it would solve a lot of their problems
14:23:42 <jmcarthur> it certainly would, but i don't think it is a possible solution ;)
14:23:48 <yitz> darn
14:24:12 <jmcarthur> i think part of the main problem is that nobody agrees what the problem is
14:24:39 <devinus> is anybody familiar with erlang pattern matching?
14:24:44 <jmcarthur> it is interesting to note that it's always the *interfaces* that are under dispute, not really the implementations
14:24:48 <devinus> i'd like to know how haskell's pattern matching compares....
14:25:00 <drk-sd> devinus: what do you mean ?
14:25:09 <jmcarthur> devinus: it's untyped
14:25:16 <jmcarthur> erlang's, that is
14:25:23 <devinus> drk-sd: im new to haskell, trying to see how haskell's pattern matching compares to erlang
14:25:28 <devinus> i LOVE erlang's pattern matching
14:25:33 <devinus> it's such an awesome paradigm
14:25:37 <drk-sd> hum devinus, in erlang
14:25:39 <monadic_kid> so i've managed to release my changes for jhc-sdl: https://patch-tag.com/r/snk_kid
14:25:39 <ezyang> I think you'll love Haskell pattern matching too. 
14:25:45 <drk-sd> if you have A = <constant>
14:25:50 <devinus> ezyang: i like to hear that
14:25:54 <drk-sd> and then you do case Foo of A -> ...
14:25:55 <jmcarthur> devinus: erlang allows you to pattern match any type of record in a given function. haskell restricts a function input to a single type
14:25:59 <devinus> like A = 12, ok
14:26:05 <drk-sd> it will try comparing Foo with the value of A
14:26:21 <drk-sd> in languages like haskell (or ocaml) it dœsn't work that way
14:26:30 <blups0r> need some help with this piece of code http://pastebin.com/HEdpMiep
14:26:31 <jmcarthur> devinus: erlang allows you to add patterns in an ad hoc way without penalty. haskell only allows valid patterns based on the ADT
14:26:43 <devinus> ah
14:26:55 <drk-sd> (well jmcarthur explains better than I do, I'll let him continue)
14:26:56 <ezyang> But that's more the type system than pattern matching. 
14:27:04 <jmcarthur> drk-sd: i'm done :)
14:27:25 <blups0r> the error message is http://pastebin.com/zQRr0dFK
14:27:38 <roconnor> blups0r: you need to do foo <- getDirContents pre
14:27:38 <devinus> can you pattern match against function heads ?
14:27:52 <drk-sd> devinus: what do you mean ?
14:27:54 <roconnor> getDirContents doesn't return a list.  It returns an IO list
14:28:19 <jmcarthur> devinus: what is a function head?
14:28:31 <devinus> drk-sd: in erlang I can do, e.g. foo(12) -> hello; foo(_) -> oops.
14:28:38 <drksd> yep
14:28:38 <blups0r> getDirContents is my own funktion
14:28:40 <devinus> then do foo(12) and get hello.
14:28:43 <drksd> you can do that in haskell
14:28:43 <jmcarthur> you can do that
14:28:48 <devinus> SWEET
14:28:49 <drksd> that's called defining clauses
14:28:55 <drksd> (i think, jmcarthur will confirme)
14:29:01 <jmcarthur> > let foo 12 = "hello" ; foo _ = undefined in foo 12
14:29:02 <lambdabot>   "hello"
14:29:04 <jmcarthur> > let foo 12 = "hello" ; foo _ = undefined in foo 13
14:29:05 <lambdabot>   "*Exception: Prelude.undefined
14:29:06 <roconnor> blups0r: your getDirContents function returns an IO list
14:29:09 <devinus> man, i'm lovin the sound of haskell more each day
14:29:10 <roconnor> (and rightly so)
14:29:26 <BMeph> {foo 12 = hello; foo _ = oops}
14:29:41 <aristid> devinus: you're impressed by foo 12 = "hello"; foo _ = undefined?
14:29:59 <jmcarthur> devinus: haskell does not have atoms like erlang does though. that's probably the major distinction between the two forms of pattern matching
14:30:01 <devinus> aristid: i've lived a sheltered development life...
14:30:03 <roconnor> aristid: wait till devinus sees how we produce a list of prime numbers.
14:30:10 <jmcarthur> heh
14:30:14 <blups0r> roconnor: why does it return an io list?
14:31:04 <roconnor> blups0r: an IO list is a data type the contains the effects that need to be prefored to create a list (ie disk operations)
14:31:10 <devinus> i love the use of atoms in erlang, but im sure haskell has an idiom that makes up for it
14:31:16 <yitz> blups0r: i made an amendment to your paste, doing what roconnor said
14:31:28 <BMeph> roconnor: The smooth way, or the sloppy (yet incredibly succinct) way? ;)
14:31:40 <jmcarthur> devinus: haskell's way of doing that sort of thing is much more formalized
14:31:41 <roconnor> blups0r: if it returned just a list, that would imply that the result has nothing to do with disk access
14:31:51 <yitz> blups0r: http://pastebin.com/2yumfxpZ
14:32:02 <jmcarthur> devinus: erlang's way is, IMO, perfect for what erlang is intended, but haskell's way is a lot nicer in general
14:32:03 <roconnor> BMeph: the circular way
14:32:24 <jmcarthur> devinus: wait until you see the things more interesting than pattern matching though :)
14:32:32 <jmcarthur> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
14:32:33 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:32:42 <devinus> jmcarthur: i already get that feeling. im not sure what e.g. Maybe really means yet, but i know that I've probably wanted it for a long time
14:32:51 <BMeph> roconnor: I.e., with mutually recursive functions, or ejecting-multiples-in-twenty-characters?
14:32:59 <ezyang> devinus: It's null put in the type system. 
14:33:07 <roconnor> BMeph: mutually recursive data
14:33:09 <aristid> > fix (([0,1]++) . (zipWith (+) <*> tail))
14:33:10 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:33:15 <jmcarthur> devinus: any time in erlang you have needed either a value or null, you could have used Maybe in haskell with more type safety :)
14:33:58 <aavogt> is there some static analysis to catch those cases though, jmcarthur?
14:34:14 <jmcarthur> aavogt: in erlang or haskell?
14:34:14 <geheimdienst> aristid, is that from the evolution of a programmer? somewhere in the last third, i guess
14:34:32 <aavogt> jmcarthur: either really
14:34:32 <blups0r> now i get a parse error
14:34:49 <aristid> geheimdienst: no, but it could be.
14:34:53 <geheimdienst> ;-)
14:35:00 <aristid> geheimdienst: it's from "aristid loves to play with Applicative"
14:35:00 <jmcarthur> aavogt: ghc at least has a warning you can turn on, and we also have Catch
14:35:22 <yitz> blups0r: oops, right. put a $ after the word return
14:35:25 <jmcarthur> aavogt: i'm sure there is some form of static analysis for erlang somewhere, but i don't know what it's capable of
14:35:37 <jmcarthur> i'm not really much of an erlang guy. i'm just impressed from afar
14:35:57 <yitz> blups0r: which is the same thing as putting everything after the word return in parens, but it looks neater
14:36:12 <aristid> @src (->) pure
14:36:12 <lambdabot> pure = const
14:36:25 <blups0r> yitz: thanks a lot
14:36:32 <blups0r> that was the error
14:36:34 <jmcarthur> devinus: are you learning haskell from a tutorial?
14:36:49 <aristid> there was a way to calculate the list of primes with nubBy or so
14:36:51 <aavogt> jmcarthur: have you use catch? It's sort of impractical to separate out the ghc-extensions in most of my code...
14:36:54 <aristid> but i forgot how to do it :(
14:37:04 <jmcarthur> aavogt: same here. i've experimented with it, is all
14:37:23 <jmcarthur> it would be nice if some of this yhc-dependent stuff would work with ghc as a front end
14:37:32 <BMeph> aavogt: Erlang wouldn't do static analysis. It would have a supervisor process analyze the pieces left over from the child process. ;)
14:37:33 <jmcarthur> supero, for example
14:38:18 <aavogt> BMeph: Dialyzer?
14:38:39 <yitz> jmcarthur: there has been talk for a long time about a ghc core => yhc core translator, but it hasn't happened yet...
14:38:49 <jmcarthur> mmm
14:39:06 <devinus> jmcarthur: im learning it from learn you some haskell and then real world haskell
14:39:07 <jmcarthur> isn't one typed and the other not or something like that?
14:39:12 <BMeph> aavogt: Sounds familiar. I haven't dabbled in Erlang in a while now.
14:39:14 <jmcarthur> devinus: awesome. both are good
14:39:34 <yitz> jmcarthur: there are a lot of really nice things that could be done with ghc core if only there existed some almost current docs for it
14:39:43 <jmcarthur> yeah :(
14:39:59 <BMeph> aristid: "nubBy (((>1).).gcd)", I believe. :)
14:40:14 <jmcarthur> :t nubBy (((>1).).gcd)
14:40:15 <lambdabot> forall a. (Integral a) => [a] -> [a]
14:40:23 <aavogt> you might need a flip
14:40:40 <aavogt> argument order is rather unspecified for nubBy and groupBy
14:40:40 <jmcarthur> > nubBy (((>1).).gcd) [2..]
14:40:41 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
14:40:54 <aristid> > nubBy (\a b -> a `mod` b == 0) [2..]
14:40:55 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
14:41:04 <aristid> i like the solution with mod better
14:41:17 <aristid> my mistake was using [1..], so it didn't work :D
14:41:19 <hpc> > primes
14:41:20 <lambdabot>   Not in scope: `primes'
14:41:25 <jmcarthur> me too, but the gcd version might be slow enough to watch at lower numbers ;)
14:41:37 <hpc> @let primes = nubBy (((>1).).gcd) [2..]
14:41:37 <lambdabot>  Defined.
14:41:39 <aristid> devinus: are you still here? :D
14:41:47 <devinus> aristid: i am indeed
14:42:03 <BMeph> > nubBy (((==0).).mod) [2..]
14:42:04 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
14:42:09 <aristid> devinus: which version of the primes list to you like best? :)
14:42:26 <aristid> BMeph: ugh, dot sections
14:42:31 <devinus> aristid: you want my noob opinion?
14:42:47 <aristid> > let (.:) = (.).(.) in nubBy ((==0) .: mod) [2..]
14:42:48 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
14:42:54 <BMeph> aristid: W00t, dot sections! >;)
14:42:55 <jmcarthur> aristid: :(
14:42:59 <aristid> BMeph: (.:) is the best operator evar
14:43:02 <yitz> @oeis 2,3,5
14:43:02 <lambdabot>  The prime numbers.
14:43:02 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:43:15 <aristid> devinus: yeah
14:43:24 <aristid> jmcarthur: why are you sad?
14:43:30 <jmcarthur> .:
14:43:35 <jmcarthur> that's just wrong
14:43:36 <aristid> huh?
14:43:39 <aristid> no it isn't
14:43:44 <conal> though (.:) only captures the tip a tiny piece of the general pattern.
14:43:52 <conal> so i prefer (result.result) 
14:43:53 <jmcarthur> i knew conal would say something
14:43:54 <devinus> aristid: > nubBy (\a b -> a `mod` b == 0) [2..]
14:43:56 <aristid> conal: yeah but it's more infix than secs
14:44:00 <devinus> aristid: only because i sort of understand it
14:44:12 <aristid> conal: and result.result is important enough to warrant its own name
14:44:19 <conal> jmcarthur: you get the prize!
14:44:41 <aristid> conal: if lambdabot had result, i'd have used that :)
14:44:43 <zachk1> > takeWhile (<20) . nubBy (\a b-> a `mod` b == 0) $ [2..] 
14:44:43 <BMeph> conal: Now you need to think of a nice symbol to represent "result"... :D
14:44:44 <lambdabot>   [2,3,5,7,11,13,17,19]
14:45:12 <aristid> > let result = (.); (.:) = result.result in nubBy ((==0) .: mod) [2..]
14:45:13 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
14:45:15 <jmcarthur> if replicate was generalized to monoids instead of the free monoid then you could say replicate 2 (.) ;)
14:45:25 <Philonous> Can cabal handle multi-licensed projects?
14:45:26 <conal> i like 'result' for how it matches 'first' and 'second'.
14:45:27 <jmcarthur> err
14:45:30 <jmcarthur> i guess that's wrong anyway
14:45:37 <jmcarthur> i was thinking categories
14:45:38 <jmcarthur> which is tougher
14:45:55 <aristid> jmcarthur: with DT, something like replicate 2 result would be possible, i guess
14:46:03 <jmcarthur> eh, maybe
14:46:14 <conal> i'd hate to see a proliferation of ad hoc names for result.result, first.result, result.second, ... not to mention the longer/deeper variants.
14:46:21 <jmcarthur> it would be, but i don't know if it would be practical
14:46:28 <jmcarthur> conal: yeah...
14:46:41 <aristid> conal: well, provide non-ad hoc ones :)
14:46:48 <aristid> you can't stop the infix-lovers
14:47:05 <jmcarthur> infix expressions would solve the problem
14:47:06 <BMeph> That's what SHE said! :)
14:47:15 <jmcarthur> but they would also be ugly
14:47:15 <conal> aristid: i have hope even for the infix-lovers of the world.
14:47:26 <ivanm> preflex: seen edwardk
14:47:26 <preflex>  edwardk was last seen on #haskell 1 day, 49 minutes and 16 seconds ago, saying: gotta run
14:47:44 <jmcarthur> ivanm: edwardk was here more recently than that i'm sure
14:47:48 <conal> i like infix expressions.
14:47:58 <aristid> conal: but seriously, i have used something like result.result quite often. i do think it warrants a shortcut.
14:48:02 <ivanm> well, preflex was away for a bit IIRC...
14:48:10 <ivanm> maybe it didn't come back till after preflex left?
14:48:12 <yitz> > let result = (.) in nubBy (result result result (==0) mod) [2..]
14:48:14 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
14:48:21 <aristid> yitz: haha
14:48:21 <jmcarthur> conal: i guess i like the flexibility they might afford, but i can't think of many cases where i'd use them
14:48:35 <aristid> yitz: i love how you use three result in a row :)
14:48:49 <yitz> :)
14:48:52 <jmcarthur> > nubBy (fmap fmap fmap (==) mod) [2..]
14:48:53 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:48:53 <lambdabot>         against inferred type ...
14:49:00 <jmcarthur> > nubBy (fmap fmap fmap (==0) mod) [2..]
14:49:01 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
14:49:05 <conal> aristid: i can see the appeal.  and i'd still like you & others to get the reminder of the big space of possibilities.
14:49:46 <conal> i'm still surprised in retrospect that it took so long for the SEC pattern to come to light.
14:50:26 <hpc> isn't there a limit at which repeated applications of fmap start to be equal?
14:50:31 <hpc> :t fmap fmap fmap fmap fmap
14:50:32 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
14:50:35 <conal> i've been programming functionally for 25 years and only noticed SECs 5 years or so ago.
14:50:46 <yitz> hpc: yes. fmap^10 == fmap^6
14:50:49 <jmcarthur> i still can't say that i *get* SECs, honestly. i see how they are readable idioms, but i don't see any special *semantic* clarity from them yet.
14:51:00 <aristid> hmm i've been programming functionall for... 3 years or so, if you count c++ metaprogramming
14:51:08 <Cale> I'm astounded that derivatives of datatypes didn't show up a lot sooner. That stuff had been essentially well-known to combinatorialists for quite some time. :)
14:51:35 <conal> jmcarthur: and the name "SEC" doesn't help?  was chosen carefully.
14:51:45 <ezyang> What is SEC? 
14:51:56 <Cale> Semantic Editor Combinators, I presume
14:51:58 <jmcarthur> semantic editor combinator
14:52:01 <aristid> ezyang: o-m-g!
14:52:01 <ezyang> Aha. 
14:52:07 <ezyang> Those are pretty cool. 
14:52:11 <yitz> Cale: they don't seem as surprised as we do. but thinking of it in terms of types is a bit different than what they did, and it's potentially very powerful.
14:52:21 <ezyang> The functions build up a context that the editor places the result in. 
14:52:25 <ezyang> I love it :-) 
14:52:43 <aristid> conal: i forgot... which things other than functions can be used in SECs again?
14:52:45 <Cale> yitz: Well, it's *slightly* different, but it's more or less the same thing as derivatives of species.
14:52:45 <aristid> :t first
14:52:46 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
14:53:03 <conal> yeah.  in other words, SECs promote editors to editors that reach more deeply.
14:53:34 <Cale> yitz: The fact that you can get performance benefits from using zippers is new though.
14:53:40 <aavogt> conal: are they strictly combinators though?
14:53:43 <conal> aristid: there are a few examples in the Eros paper: code, types, GUIs and pairings of same.
14:53:58 <yitz> Cale: yes, and that's an important point
14:54:13 <aristid> conal: hmm. fclabels, maybe?
14:54:29 <aavogt> there's more to them than just applying arguments to eachother: you need to deconstruct one of the arguments
14:54:30 <conal> aavogt: yes i think so, though i mean the term in the recent loose sense of higher order functions.
14:54:31 <Cale> yitz: Combinatorialists don't tend to consider practical aspects like the complexity of computing the operations they perform on combinatorial structures so often.
14:55:23 <yitz> Cale: I have a hunch that it could help towards a functional concept of computational complexity
14:56:24 <yitz> Cale: in the same way that formal derivatives are one way of building up cohomology of topological and geometric structures to measure their complexity.
14:56:54 <Cale> I tend to agree with Jacques Carette that we should be exploring the possibility of adopting more of the theory of combinatorial species into our theory of data types. There are algorithms for automatically computing the asymptotic complexity of many functions on species.
14:57:10 <aristid> haskell seems to have seen a lot of its growth in concepts and implementation in the last few years. as if it had super-exponential growth
14:57:30 <Cale> aristid: Probably just quadratic or so, really. :)
14:57:42 <Cale> Well, *maybe* exponential/logistic :)
14:57:43 <JoeyA> Really?  Super-linear?
14:57:43 <yitz> Cale: yeah, that's also an interesting angle.
14:58:21 * JoeyA isn't used to using things that grow faster than logarithmic at the conceptual level
14:58:21 <aristid> Cale: well, with super-exponential i mean basically, exponential, but with an increased growth rate since ~2006
14:58:25 <Cale> Definitely more than linear growth though.
14:58:58 <CalmNelly> @vixen Will Haskell get me laid?
14:58:58 <lambdabot> Ooh, functional programmers are so hot!
14:59:00 <Cale> If you look at all the graphs of community size, or number of packages, etc. etc., there's a definite curve to them.
14:59:09 <yitz> the problem is that for many of us brain growth is very sub-linear.
14:59:10 <aristid> CalmNelly: rofl
14:59:59 <aristid> yitz: well, if you look at for example the economy, it had super-exponential growth too, and that despite not much growth of the brain. it's more about actually utilizing resources that already exist
15:00:07 <CalmNelly> :_
15:00:08 <CalmNelly> )
15:00:38 <yitz> aristid: you have consoled me
15:01:22 <aristid> yitz: it's actually quite fascinating... it looks like economic growth improved sharply twice: 5000 BC, and 1700 AD
15:02:19 <yitz> aristid: there was a pretty big spike in roman times too
15:02:20 <geheimdienst> what happened in 5000 BC? first iphone came out?
15:02:55 <ivanm> heh
15:02:58 <aristid> geheimdienst: yeah, and also they invented agriculture
15:03:08 <geheimdienst> oh i see :)
15:03:33 <aristid> yitz: dunno, i haven't seen that in the data that i've looked at.
15:03:50 <yitz> aristid: the romans invented global-scale enslavement
15:04:06 <ivanm> yitz: "global"?
15:04:46 <jmcarthur> none of it matters. dec 12, 2012 is coming
15:04:49 <yitz> well, global meant europe, n. africa, and w. asia for them. still pretty massive.
15:04:53 <jmcarthur> or is it dec 21?
15:05:13 <jmcarthur> it's dec 21
15:05:16 <ivanm> jmcarthur: 32 december? :p
15:05:28 <geheimdienst> 12-12-12 has a nice ring to it
15:05:46 <aristid> yitz: my data sources are http://hanson.gmu.edu/IEEESpectrum-6-08.pdf and http://en.wikipedia.org/wiki/File:World_population_growth_%28lin-log_scale%29.png
15:05:47 <jmcarthur> 2012-12-21
15:06:42 <aristid> yitz: but actually looking at it... yeah, there WAS a spike in the last millenium BC
15:06:50 <aristid> at least if that data is accurate
15:06:52 <yitz> yep
15:07:03 <yitz> greco-roman
15:07:15 <aristid> yitz: fascinating, it was pretty short-lived tho
15:07:29 <yitz> actually started with the babylonians
15:08:10 <aristid> yitz: you seem to know a bit more about this time. hobby of yours?
15:08:14 <yitz> the egyptians had much of the same technology and slavery, but they didn't use it for conquest
15:08:50 <yitz> aristid: mmm, not really my hobby, but the hobby of a good friend of mine.
15:09:03 <aristid> i guess egypt is pretty isolated geographically by the desert
15:10:40 <yitz> aristid: they actually try to sweep toward the babylonians a few times, but never really got very far. not sure what stopped them from heading south.
15:11:32 <shapr> Is there a SIP or IAX protocol implementation in Haskell?
15:11:44 <Adamant> that would be nice.
15:12:11 <aristid> so, i think it's fascinating that we had MORE than exponential growth over the last 10,000 years. exponential is a lot, already. and - i haven't yet verified this with data - i have this hypothesis that haskell is actually similar
15:12:12 <yitz> or at least a binding
15:12:53 <aristid> haskell exists since like, the beginning of the 90s. but it looks like its growth accelerated a few years ago
15:15:12 <yitz> aristid: so, your hypothesis is that haskell will fuel continuing human population growth?
15:15:40 <aristid> yitz: uh, no. i actually think population growth has stopped already. economic growth hasn't, though.
15:16:16 <yitz> aristid: it's going to be pretty tough to sustain unless we can get space colonization going.
15:16:52 <aristid> yitz: i'm thinking more about removing current inefficiencies. there's a lot of inefficiency in the economic system. but that's not related to my hypothesis about haskell
15:17:14 <yitz> this is getting to be so #haskell-blah
15:17:16 <aristid> yitz: the "haskell growth" is just about haskell. it's just that i think that the curve looks similar, on a pure numerical level
15:17:52 <aavogt> @faq does haskell taste better than soylent green?
15:17:52 <lambdabot> The answer is: Yes! Haskell can do that.
15:50:30 <devinus> holy cow http://hackage.haskell.org/package/DSTM-0.1.1
15:50:43 <ivanm> what about it?
15:51:02 <ivanm> come on, you restrict which version of base you use but not which version of containers, network, etc.?
15:51:09 <devinus> ivanm: that's awesome
15:51:27 <ezyang> Bah, I keep finding out I made the wrong design decisions. 
15:51:29 <ivanm> yeah
15:51:31 <ezyang> refactor refactor refactor 
15:51:38 <aavogt> @type refactor
15:51:38 <lambdabot> Not in scope: `refactor'
15:52:16 <ezyang> > let refactor = fmap in refactor refactor refactor 
15:52:17 <lambdabot>   Overlapping instances for GHC.Show.Show
15:52:17 <lambdabot>                              ((a ->...
15:52:26 <ivanm> ugh, it would have been better IMHO if they gave their data types new names rather than copying the current STM ones
15:52:42 <ivanm> @type let refactor = fmap in refactor refactor refactor
15:52:43 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
15:52:58 <aavogt> ivanm: what's the problem with qualified names?
15:53:04 <aavogt> (your problem rather)
15:53:24 <ivanm> you mean using qualified imports?
15:54:02 <aavogt> I dunno, the imports don't have to use the word qualified
15:54:10 <aavogt> for you to be able to refer to a module name
15:54:41 <Cale> ivanm: Restricting the version of base does essentially put restrictions on the other packages though...
15:54:53 <ivanm> Cale: right, but you might as well be explicit about it
15:55:05 <Cale> I agree about renaming the datatypes
15:55:30 <aavogt> there's no ambiguity unless you write type signatures
15:55:56 <ivanm> aavogt: if you see a bunch of code using STM, etc., can you tell immediately if it's using stm or dstm?
15:56:06 <Cale> Well, or you want to use local STM and distributed STM in the same program
15:56:11 <aavogt> ivanm: does it matter?
15:56:19 <Cale> Then you'll be forced to qualify stuff.
15:56:27 <aavogt> or use separate modules
15:56:30 <ivanm> using the same name increases the barrier to comprehension
15:56:34 <ivanm> *names
15:57:17 * Cale remembers when Haskell didn't have hierarchical modules and when everyone designed things so that they could be imported unqualified.
15:57:25 <aavogt> ivanm: they don't if you use them in the same way as the original name
15:57:26 <ivanm> heh
15:57:39 <aavogt> Cale: qualified imports existed though?
15:57:42 <Cale> yes
15:57:45 <ivanm> aavogt: but you can't tell if the code is doing distributed stuff or not though
15:58:04 <aavogt> ivanm: do you have a problem when you see monadic code and don't know what effects are going on?
15:58:23 <Cale> In fact, even for some time after hierarchical modules, people still designed things to be imported unqualified.
15:58:28 <Cale> Data.FiniteMap was like that
15:58:44 <aavogt> do you prefer  concatMap, bindIO...?
15:58:44 <ivanm> aavogt: except this isn't a type class
15:58:50 <Cale> The names of the FiniteMap-specific functions all had FM on them.
15:59:04 <Cale> mapFM, etc.
15:59:18 <aavogt> Cale: isn't that the same noise as M.map?
15:59:30 <Cale> aavogt: But less noise when importing the module.
15:59:30 <ivanm> it's the same thing as how bytestring has different modules with the same API, trying to manually provide something akin to an ML functor AFAICT
15:59:36 <EvanR> Cale: like C ;)
15:59:41 <Cale> aavogt: Now I always have to write:
15:59:52 <Cale> import qualified Data.Map as M
15:59:59 <Cale> import Data.Map (Map)
16:00:15 <Cale> (and sometimes I'll stick some other stuff in the import in the second line)
16:00:45 <aavogt> > length "import Data.Map (Map)" `div` 2
16:00:46 <lambdabot>   10
16:00:47 <Cale> I don't know why, but I am strictly opposed to writing qualified names in my types.
16:01:01 <calsaverini> hi, I wrote a small "tutorial" thing on monad transformers and would like to ask for criticism on it: http://randomagent.wordpress.com/2010/08/03/stochastictransformer/
16:01:15 <hpc> ugh, qualifications in type signatures just look ugly
16:01:28 <aavogt> there's less ambiguity in type signatures
16:03:59 <Cale> calsaverini: btw, if x and y are not (essentially) independent in the example you have there, it's not your code's fault, but the PRNG's fault.
16:05:11 <Cale> calsaverini: They're not really using the same seed. The seed for selecting y is the transformed one after selecting x of course.
16:05:28 <Cale> (otherwise they would always be identical)
16:07:25 <zygoloid> is there any way to turn the current thread into a bound thread?
16:07:46 <zygoloid> or indeed any way to ensure that a computation of type (MonadIO m) => m a is run in a bound thread?
16:08:25 <Cale> zygoloid: Are you certain that you need a bound thread? :)
16:08:33 <zygoloid> Cale: yes, quite certain.
16:09:41 <zygoloid> i'm using ptrace, and it says "no" if you try to do stuff on a different thread from the thread where you did the PTRACE_ATTACH
16:10:18 <Cale> okay, so the C library is using thread-local state then
16:10:27 <zygoloid> no. the kernel is using thread-local state :p
16:10:34 <Cale> Well, okay :)
16:11:00 <Cale> So you'll want to use forkOS in place of forkIO, probably.
16:11:27 <Cale> So however you were running the thread before, just replace forkIO with forkOS
16:11:28 <zygoloid> well, i don't have control over that. i'm trying to implement runMyMonadT :: MonadIO m => MyMonadT m a -> m a
16:12:05 <Cale> hmm
16:12:15 <EvanR> i think seeding practices of RNGs are interesting
16:12:27 <EvanR> in cases where people think they are getting actual random numbers
16:12:58 <EvanR> if you seed more than once, you are not guaranteed to have an independent sequence to the first
16:13:31 <EvanR> PHP for instances seeds once for each php process start
16:13:42 <Cale> EvanR: One thing I think it's really shameful that it hasn't been more thorougly studied (or at least, I'm not aware of any research) is pseudorandom number generator splitting.
16:13:42 <EvanR> on your behalf
16:13:44 <zygoloid> ultimately m will be GHC.Ghc (or possibly GhcT InputT)
16:13:54 <kmc> zygoloid, runInBoundThread :: IO a -> IO a
16:13:57 <EvanR> im also interested in the splitting
16:14:02 <luite> is there some package for getting proper seed values by the way?
16:14:12 <zygoloid> kmc: i can't create an IO a, only a MonadIO m => m a
16:14:14 <EvanR> any seed value is proper
16:14:21 <EvanR> just dont reseed if you want random numbers
16:14:25 <Cale> luite: You can use newStdGen in the System.Random library.
16:14:39 <kmc> well that's a problem, you can't in general fork a (MonadIO m => m a)
16:14:45 <Cale> luite: It's not great, but it should be better than it is :)
16:15:06 <zygoloid> kmc: i don't want to fork, i want to bind the current thread ;-)
16:15:28 <luite> Cale: what data does it use to seed the original StdGen?
16:15:32 <zygoloid> i think you're right though -- threads can't change from unbound to bound
16:15:42 * EvanR makes his biannual 'pointing out' that haskells standard generator always starts with True for seeds less than about 50000
16:15:46 <Cale> luite: If you really care about security, then read an Int from /dev/urandom and apply mkStdGen to it.
16:15:54 <zygoloid> which means i need to use a runtime check ;(
16:15:57 <Cale> luite: *Presently* it uses the time, which is pretty bad.
16:16:13 <Cale> luite: But in theory it ought to use the system entropy pool.
16:16:42 <EvanR> luite: what you should do is save the state of your applications RNG to disk and restore it between sessions
16:16:56 <Cale> I'm not sure I'd ever go that far.
16:17:13 <EvanR> well theres not much point in reseeding, regardless of what value you pick
16:17:17 <Cale> Just use /dev/urandom to get a fresh seed :P
16:17:43 <EvanR> it doesnt help
16:17:51 <Cale> hm?
16:18:09 <Cale> It's less trouble than saving and restoring the StdGen
16:18:13 <EvanR> if the goal is to get a sequence statistically independent from the first, then you cant reseed
16:18:26 <Cale> Oh?
16:18:42 <EvanR> because generators are not designed to be random in the seed dimension
16:18:55 <Cale> I'm pretty sure, though I may be wrong about this, that every possible StdGen is accessible as some (mkStdGen n)
16:19:07 <EvanR> yes?
16:19:19 <Cale> (and equally likely to occur)
16:19:46 <sm> alright, I should know this but I don't. How do I go about converting a ByteString to a String ?
16:19:50 <tensorpudding> so if everything is an object in OO languages, is everything a function in FP languages?
16:19:59 <EvanR> the sequences are equally likely to occur, but if you take the sequence of fifth elements of each sequence, in order, they are not necessarily equally distributed, much less random
16:19:59 <Cale> tensorpudding: No, not really.
16:19:59 <hpc> sm: show?
16:20:01 <ezyang> sm: What encoding? 
16:20:12 <ezyang> ByteStrings are bytes; String is Unicode. 
16:20:13 <aristid> data StdGen = System.Random.StdGen GHC.Int.Int32 GHC.Int.Int32
16:20:14 <sm> it had better be utf-8, so utf8-string I guess
16:20:14 <Cale> tensorpudding: Functions are values of type A -> B for various types A and B
16:20:27 <tensorpudding> I know, I was just quipping after reading conal's newest blogpost
16:20:29 <aristid> so if mkStdGen takes one Int, and Int is 32-bit too (on my machine)
16:20:38 <aristid> it looks like it can't generate all values
16:20:52 <Cale> aristid: Interesting.
16:20:55 <sm> but show works quite nicely for the time being - thanks hpc !
16:21:18 <aristid> Cale: maybe it can generate all VALID values, though.
16:21:25 <hpc> definitely look up a better way; show matches in type signature only, from what i know
16:21:33 <Cale> If not, then that seems like a foolish scheme for seeding.
16:21:39 <Cale> (at least to me)
16:22:14 <Cale> It seems to me that a seed should be a representation of a complete PRNG state.
16:23:18 <Cale> and so if you pick a random seed somehow, you get a random PRNG state from all of those which are possible
16:23:22 <Cale> That might not be true though.
16:23:53 <EvanR> picking a random state from all possible is not enough
16:24:33 <EvanR> while a sequence on its own may pass randomness tests, theres no reason why slice[n] of all sequences will pass
16:24:58 <EvanR> > random (mkStdGen 0) :: Bool
16:24:58 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:24:59 <lambdabot>         against inferred type ...
16:25:07 <hpc> :t random
16:25:08 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
16:25:15 <EvanR> > random (mkStdGen 0) :: (Bool, StdGen)
16:25:16 <lambdabot>   (True,40014 40692)
16:25:19 <EvanR> > random (mkStdGen 1) :: (Bool, StdGen)
16:25:20 <lambdabot>   (True,80028 40692)
16:25:22 <EvanR> > random (mkStdGen 2) :: (Bool, StdGen)
16:25:23 <lambdabot>   (True,120042 40692)
16:25:24 <hpc> :t randoms
16:25:25 <Phyx-> is... There a must read paper on Attribute Grammar Systems? or a good one?
16:25:25 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
16:25:34 <EvanR> > random (mkStdGen 100) :: (Bool, StdGen)
16:25:35 <lambdabot>   (True,4041414 40692)
16:25:38 <EvanR> > random (mkStdGen 1000) :: (Bool, StdGen)
16:25:39 <lambdabot>   (True,40054014 40692)
16:25:47 <EvanR> its True up to about 60000
16:25:52 <hpc> > (take 20 $ mkStdGen 0) :: [Bool]
16:25:53 <lambdabot>   Couldn't match expected type `[a]'
16:25:53 <lambdabot>         against inferred type `System.Ra...
16:25:54 <EvanR> an example of a non random slice
16:26:15 <hpc> > (take 20 . randoms $ mkStdGen 0) :: [Bool]
16:26:16 <lambdabot>   [True,True,True,False,False,True,True,True,True,False,True,False,False,Fals...
16:26:28 <EvanR> therefore it requires proof that randomly chosen sequences are statistically independent
16:26:55 <EvanR> with each other
16:28:13 <hpc> > fmap fst . fmap (random . mkStdGen) $ [0..] :: [Bool]
16:28:14 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
16:29:52 <EvanR> hpc: the Random class is a nice way to generate actual values rather than the state
16:30:36 <EvanR> ah thats what weve been using
16:31:26 <EvanR> id like to investate further the correletion between sequences
16:32:38 <Phyx-> > (+1)
16:32:39 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
16:32:39 <lambdabot>    arising from a use of `...
16:34:03 <ezyang> I'd like to write a function that says "Prove to me you have the lock for the data structure you are also passing to me" 
16:34:20 <ezyang> which is checked statically. Do I need rank-2 types or something? 
16:35:35 <c_wraith> I'd think you need a different interface, where the structure contains its own lock?
16:35:47 <ezyang> Oh, the structure does contain its own lock. 
16:36:10 <ezyang> (i.e. it has an MVar that controls access to it) 
16:36:24 <hpc> there's a way to get types that depend on values
16:36:34 <hpc> dependent type
16:36:44 <ezyang> Unfortunately I can't use the standard idiom of put the structure inside the MVar, because there are different locks for the structure. 
16:36:49 <ezyang> hpc: Do I really need dependent types? 
16:37:08 <hpc> no clue, but that's one way to do it
16:37:32 <EvanR> another thing i have a gripe about is the standard generator seed interface, it must be type Int
16:37:38 <ezyang> Not very satisfying... 
16:37:50 <kmc> well, what about «UnlockedFoo a -> (LockedFoo a -> r) -> r»
16:38:00 <EvanR> no matter how many bits of state the generator uses, there can only be Int number of sequences...
16:38:01 <kmc> and you can use the runST trick to prevent them smuggling out the LockedFoo in r
16:38:30 <hpc> what's the runST trick?
16:38:56 <ezyang> kmc: Hm. That works, but it means I can't support a takeLock/releaseLock interface. 
16:39:13 <shapr> Eelis: Aww!
16:39:24 <ezyang> I guess, framed that way, this might be impossible. 
16:39:25 * shapr hugs Eelis
16:39:29 <hpc> if you want static lock checking, i don't think you can provide a first-class interface
16:39:37 * Eelis continues idling
16:41:10 <ezyang> Well, the single lock case would be possible. 
16:41:20 <ezyang> I just create data Token = Token but don't export the data constructor 
16:41:34 <ezyang> and any function that requires you having the lock adds a... OH. 
16:41:39 <ezyang> Yeah, that doesn't work, does it :-) 
16:43:01 <ezyang> Which is unfortunate. I can require a proof that you've done a step, but then there's no way to prove that you've undone the step. That's contradiction! 
16:44:00 <ezyang> I guess the next best thing is to do is runtime lock checking. 
16:47:16 <hpc> you can still have constructs like withLock f = unlock . f . lock
16:48:02 <ezyang> Yeah. Right now I'm trying to decide if I should add runtime checks for whether or not you have the lock or not. 
16:48:12 <ezyang> That's introducing fairly moderate complexity. 
16:48:51 <hpc> what is this for?
16:49:04 <ezyang> Mutable data structure pretending to be immutable. 
16:51:25 <monochrom> if you can't get safety proof, you can still design the api to encourage safe use
16:51:32 <ezyang> Basically, there are some "read" operations that actually use some shared memory, so those have to be synchronized on. 
16:51:41 <monochrom> @type withFile
16:51:42 <lambdabot> Not in scope: `withFile'
16:51:42 <ezyang> monochrom: Yeah... 
16:52:31 <ezyang> "If this were C code, I would sure as hell not be checking if I had the lock or not." 
16:52:45 <hpc> it would be nice to have a strongly typed File, i think
16:53:19 <monochrom> oh well, like withFile. it packages "open", "close", "still close if exception" nicely. who would not want to use it? oh you "could" leak out the handle, but you wouldn't bother to.
16:54:47 <c_wraith> yeah.  withFile ... hGetContents works so well.  :)
16:54:57 <monochrom> haha you evil
16:55:13 <ezyang> lazy IO ruined the party. 
16:55:34 <ezyang> But they definitely had the right idea. 
16:55:36 <hpc> nothing a little seq can't fix
16:55:40 <hpc> :P
16:55:55 <monochrom> nothing a little fix can't seq
16:55:57 <ezyang> nah, you need something like deepseq or seq length 
16:57:27 <monochrom> the next step is add phantom types to forbid leakage, like runST. now, we don't exactly do it to withFile because it would require duplicating all of System.IO (though I heard someone already did and put it on hackage). but if you're developing your lib just now, you can do it now.
16:58:41 <c_wraith> isn't lightweight monadic regions a library that helps to abstract that out?
16:58:41 <ezyang> I'm punting this API feature for now. 
16:58:52 <copumpkin> ezyang: what are you writing?
16:59:01 <ezyang> copumpkin: Bindings for ABC! 
16:59:05 <copumpkin> ABC? :O
16:59:09 <ezyang> (search "berkeley abc") 
16:59:28 <monochrom> withLock :: (forall s. Lock s -> IO a) -> IO a; data Lock s = Lock;
16:59:34 <ezyang> I have a lightweight monadic regions style API already. 
16:59:38 <hpc> you have to misspell it to get the right result on the first page
17:00:33 <ezyang> I think a handle-based API can still be useful in certain cases. 
17:03:39 <monochrom> hrm?! regions help automatic differentiation?!
17:04:34 <Saizan> don't mix the infinitesimals! (or something like that)
17:09:13 <robryk> i've suddenly realized that double negation is a monad. are there any not simple (ie. conjunction) comonads with logical interpretation?
17:10:12 <aristid> robryk: double negation is a monad?!
17:10:36 <robryk> if you can prove x in intuitionistic logic then you can prove double negation of x, isn't it so?
17:11:16 <robryk> and if you can prove quadruple negation... oh, wait
17:11:31 <zygoloid> robryk: keep going... :)
17:12:04 <aristid> robryk: double negation is identity, no?
17:12:08 <robryk> no
17:12:12 <monochrom> double negation is like the Cont monad
17:12:14 <robryk> not in intuitionistic
17:12:15 <aristid> no?
17:12:34 <Saizan> Cont Void a ~ (a -> Void) -> Void
17:12:52 <Saizan> i.e. double negation :)
17:12:59 <robryk> and if you can prove quadruple in int then you can prove double in classical so you can prove x in classical so double in int
17:13:05 <robryk> didn't realize that.
17:13:10 <robryk> thank you :)
17:14:30 <Saizan> np :)
17:14:47 <robryk> are there any comonads with logical interpretation other than conjunction? all the stream- and array-based ones don't have one, right?
17:17:44 <Saizan> i wonder..
17:18:55 <zygoloid> @type \f g -> f (\h -> h g)
17:18:55 <lambdabot> forall t t1 t2. (((t -> t1) -> t1) -> t2) -> t -> t2
17:19:03 <zygoloid> ^^ that looks like it should work as a join
17:19:36 <zygoloid> (t = a -> Void, t1 = Void, t2 = Void)
17:19:51 <zygoloid> Not (Not (Not a)) == Not a
17:19:52 <Saizan> robryk: Cont is strongly related to the call-by-value CPS transformation, so maybe its dual would be a comonad? http://homepages.inf.ed.ac.uk/wadler/topics/dual.html#dual-reloaded
17:20:07 <Saizan> i've never fully understood that paper though.
17:20:32 <robryk> unfortunately i do not know what cps transformation is
17:20:52 <Saizan> continuation passing style
17:21:09 <robryk> doesn't help. have to read something, i guess.
17:21:20 <Saizan> "Not a" is usually interpreted as a continuation accepting an 'a'
17:21:27 <robryk> ok
17:21:32 <jmcarthur> robryk: instead of returning, you pass the result to another function
17:21:36 <jmcarthur> that's continuation passing style
17:21:57 <robryk> result?
17:22:13 <aavogt> or take a function that say what to do next
17:22:36 <robryk> yes
17:22:43 <Saizan> e.g. instead of writing your functions with types like (a -> b) you use (a -> (b -> r) -> r), where (b -> r) is the continuation to which you pass the 'b'
17:23:03 <robryk> or you generate r as usual, yes?
17:23:04 <Saizan> which is "a -> Cont r b"
17:23:11 <aavogt> so not   f $ g x   but    g x f id
17:23:19 <Saizan> yeah, if you want
17:23:31 <robryk> Cont r b? not Cont b r?
17:23:39 <jmcarthur> :t \f g x -> f $ g x
17:23:40 <lambdabot> forall t a b. (a -> b) -> (t -> a) -> t -> b
17:23:41 <Saizan> ?unmtl Cont r b
17:23:42 <lambdabot> (b -> r) -> r
17:23:45 <jmcarthur> :t \f g x -> g x f id
17:23:46 <lambdabot> forall t t1 a t2. t -> (t1 -> t -> (a -> a) -> t2) -> t1 -> t2
17:25:33 <Saizan> anyhow, the call-by-value cps translation, is one that goes from plain lambda terms, to ones that since they use these continuations to guide control flow will correspond to a call-by-value evaluation of the original term, regardless of how they get evaluated
17:26:35 <robryk> so in that translation we never use the possibility of returning a value of type r directly?
17:26:52 <Saizan> i don't think so
17:27:13 <robryk> sorry. was that confirmation or refutation?
17:27:32 <Saizan> i think it never uses that
17:27:35 <robryk> ok
17:28:07 <aavogt> I don't think you'll have a function that returns it's result and can be considered CPS
17:28:44 <Saizan> ?type let abort x = Cont (\ _ -> x) in abort -- is this CPS?
17:28:46 <lambdabot> forall r a. r -> Cont r a
17:29:28 <monochrom> after translation, your function is polymorphic in r, you don't even know what r the user picks, so you can't create your own value for it.
17:29:58 <robryk> ok
17:30:45 <Saizan> and they won't use the same continuation multiple times either, i guess?
17:31:08 <Saizan> while you've to do that to embed some classical logic theorems
17:31:14 <robryk> eh? how could they? they can't do anything with r but return it
17:31:42 <robryk> by the continuation you mean the what-to-do-next function?
17:31:58 <Saizan> yes
17:32:14 <Saizan> ?djinn NotNot (Either a (Not a)) 
17:32:14 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
17:32:32 <robryk> what is the function void?
17:33:01 <Saizan> void :: Void -> a, which holds since djinn assumes totality
17:33:06 <robryk> ah
17:33:17 <monochrom> they can use the same continuation multiple times. but there are very few ways they can do it, again because of polymorphic r
17:33:18 <Saizan> but it'd typecheck even without void
17:33:23 <edwardk> preflex: xseen conal
17:33:23 <preflex>  conal was last seen on freenode/#haskell 2 hours, 38 minutes and 51 seconds ago, saying: aavogt: yes i think so, though i mean the term in the recent loose sense of higher order functions.
17:33:34 <conal> edwardk: hi
17:33:41 <copumpkin> omg conal jailbreak it
17:33:54 <conal> copumpkin: kthx.
17:33:59 <copumpkin> :P
17:34:02 <edwardk> heya conal. loading up tagbits to make the change now.
17:34:13 <conal> edwardk: yay
17:34:48 <Saizan> ?type let lem = Cont $ \a -> (a (Right (\ b -> a (Left b)))) in lem
17:34:49 <lambdabot> forall r a. Cont r (Either a (a -> r))
17:36:19 <Saizan> monochrom: which LC terms once CBV CPS transformed produce ones where some continuation is called more than once?
17:37:17 <robryk> this is excluded middle, right?
17:37:19 <monochrom> I can't write it. I haven't done it in plain LC. But I have done it with the help of Cont and do-sugar.
17:37:59 <monochrom> http://www.vex.net/~trebla/haskell/cont-monad.xhtml  then look for the Setjmp example.
17:38:35 <Saizan> robryk: yep
17:39:09 <robryk> so that isn't a result of CPS of anything?
17:40:14 <Saizan> monochrom: oh, sure, you can do that with Cont in general, but i was talking about the terms in the range of the cps transformation in particular
17:41:01 <monochrom> is callCC in the range?
17:41:30 <Saizan> ?type callCC
17:41:31 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
17:42:19 <Saizan> i'd be tempted to say no, because ((a -> b) -> a) -> a doesn't hold
17:43:08 <monochrom> @djinn ((a -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
17:43:08 <lambdabot> f a b = a (\ c _ -> b c) b
17:44:53 <monochrom> this is too difficult. I don't know.
17:45:35 <robryk> if i understand it correctly, cps lifts intuitionistic proofs into proofs of double negations, right?
17:47:07 <conal> copumpkin: do you have a favorite jailbreaking program?  i've never done it.  i'm running iOS 4.01
17:47:26 <copumpkin> conal: if you're on iOS 4, just visit jailbreakme.com on your device and it'll do it all for you :)
17:47:51 <monochrom> hehe
17:47:53 <conal> wow!
17:49:03 <Saizan> robryk: sort of, e.g. it won't map (a -> b) to Not (Not (a -> b)) but to (a -> Not (Not b))
17:49:34 <aavogt> copumpkin: does it work for real incarcerations?
17:49:37 <copumpkin> conal: then once you've done that, just install ulstrasn0w in cydia to get an unlock (more details on http://blog.iphone-dev.org/)
17:49:43 <copumpkin> aavogt: don't think so :P haven't tried though
17:49:50 <monochrom> conal: http://www.macrumors.com/2010/08/02/ios4-jailbreak-bring-security-concerns/
17:49:55 <robryk> it takes a function and maps its right side?
17:49:57 <copumpkin> monochrom: pff
17:49:57 <conal> copumpkin: thx.
17:50:03 <conal> monochrom: thanks.
17:50:05 <monochrom> pff = ?
17:50:12 <copumpkin> monochrom: security schmecurity ;)
17:50:12 <conal> heh
17:50:22 <aavogt> omnomomatopoea
17:51:04 <HugoDaniel> Not in scope: type constructor or class `NFData'
17:51:05 <HugoDaniel> :(
17:51:07 <HugoDaniel> why is this ?
17:51:12 <robryk> it has moved
17:51:24 <Saizan> robryk: yeah, the double negation is pushed into the result type, which suits quite well the monad way of doing things
17:51:28 <HugoDaniel> where can i find it ?
17:51:36 <aavogt> it might not be a good idea to use it anyways
17:51:48 <Saizan> HugoDaniel: deepseq, iirc
17:51:59 <aavogt> HugoDaniel: it's expensive to traverse structures that are already evaluated
17:52:54 <HugoDaniel> thanks
17:52:56 <HugoDaniel> :D
17:53:07 <Philonous> I have some inline c in a .chs file that c2hs puts into a .h file. How can I tell cabal to compile and link it? 
17:53:48 <monochrom> should just use Haskell Platform
17:57:47 <robryk> well, it's past time i slept. good night. thanks.
17:59:07 <Associat0r> http://lambda-the-ultimate.org/node/4039
17:59:37 <Associat0r> "Type Classes as Objects and Implicits"
18:16:11 <EvanR> where did this 'everything is a function' thing come from
18:16:33 <EvanR> especially in the context of haskell
18:16:44 <EvanR> where CAFs are clearly not functions
18:17:09 <aavogt> in the sense that functions are values whose results become available later
18:17:22 <aavogt> laziness makes a CAF look like a function sort of
18:17:42 <aavogt> EvanR: there are better counterexamples to 'everything is a function'
18:18:03 <EvanR> i want examples of everything is a function
18:19:02 <EvanR> are let blocks functions?
18:19:34 <aavogt> it's hard to prove such sweeping examples with examples
18:20:01 <EvanR> maybe the idea is all values are functions
18:20:09 <EvanR> all expressions evaluate to a function
18:20:13 <aavogt> EvanR: not everything in haskell is a value though
18:20:36 <EvanR> example
18:20:42 <aavogt> class
18:21:09 <EvanR> could you emulate a class with a function
18:21:27 <aavogt> sometimes
18:21:36 <EvanR> how would a class be confused with a function though
18:21:45 * hackagebot tag-bits 0.1.1 - Provides access to the dynamic pointer tagging bits used by GHC.  http://hackage.haskell.org/package/tag-bits-0.1.1 (EdwardKmett)
18:22:01 <EvanR> whats it a function .. of
18:22:20 <EvanR> bah
18:22:29 <aavogt> EvanR: then how can some class be something that's part of everything?
18:22:41 <aavogt> that's sort of a contradiction
18:22:50 <aavogt> unless you like to redefine 'everything'
18:23:20 <EvanR> and i thought OO discussions were bad
18:23:29 <copumpkin> conal: "Would making everything a function really the formal system that is Haskell programming?"
18:23:39 <copumpkin> conal: I think you accidentally the verb :)
18:23:46 <copumpkin> (but nice article)
18:24:01 <conal> copumpkin: thx.  i thought i fixed that sentence.
18:24:04 <edwardk> conal: try that
18:24:08 <aavogt> hehe
18:24:15 <edwardk> conal: it is also much better behaved at ghci now
18:24:18 <copumpkin> conal: oh, maybe. I loaded the page a while ago and only just got to the tab
18:24:28 <edwardk> conal: (because it'll fall back on the info table, which IS supported at ghci)
18:24:55 <conal> copumpkin: please refresh and tell me whether you see the fix.
18:25:15 <copumpkin> yep, fixed :)
18:25:18 <copumpkin> sorry!
18:25:25 <Bill_> Hello everyone~~
18:25:41 <conal> copumpkin: np.  thx.
18:25:59 <conal> edwardk: terrific new.  thanks!!
18:26:32 <EvanR> question how come my compiler time errors are always on line 37
18:27:03 <aavogt> you're always working on the same problem
18:27:27 <edwardk> it now uses the boxed conversion (which happens to be what was used behind the scenes in vacuum it turns out for the same reasons) and I integrated some code from Pepe Iborra to fall back on the info tables when it isn't sure. this should actually mean that it'll be a lot less temperamental and should see evaluatedness once the thunk is evaluated, not once it has been evaluated and a gc has occurred.
18:28:06 <edwardk> if data.lub still gives you grief then we have other problems ;)
18:31:23 <EvanR> just noticed how much of a difference makes between x (y,z) = ... and (y,z) = ... ;)
18:31:58 <edwardk> conal:  undefined `ptimes` 0 :: Integer --> 0 again
18:32:08 <Saizan> EvanR: "everything is a function" is usually just a way to make the word function useless
18:35:04 <sbahra> Hi edwardk
18:35:10 <sbahra> edwardk, are you going to be going to ICFP?
18:35:45 <edwardk> sbahra: not sure yet. i'll know more before the end of the month
18:35:59 <sbahra> edwardk, ok.
18:36:02 <sbahra> I really want to go.
18:36:10 <copumpkin> me too :(
18:36:12 <sbahra> Not so sure whether or not I want to ask my company to cover it.
18:36:59 <sbahra> edwardk, copumpkin: Let me know if any of you decide to go, it'll further motivate me to make it.
18:37:11 <sbahra> I live in Columbia now, so it is very accessible geographically. :-P
18:37:22 <copumpkin> sbahra: it's unlikely for me, as I'm currently in italy
18:37:33 <copumpkin> but I will
18:37:36 <copumpkin> (let you know)
18:37:37 <edwardk> sbahra: i'll probably go
18:38:06 <sbahra> copumpkin, cool.
18:38:21 <sbahra> edwardk, alright, I'll ping you again once the day gets closer to the 30th.
18:39:17 <sbahra> Oh, and if any of you two need a place to crash, you're more than welcome.
18:39:45 <copumpkin> thanks!
18:39:55 <edwardk> sbahra: that may ease the difficulty in convincing my wife to let me go ;)
18:40:25 <EvanR> sbahra: you live where?
18:40:39 <sbahra> edwardk, just shoot me an e-mail with the expected days, I have some spare keys.
18:40:40 <edwardk> i presume columbia, md
18:40:48 <EvanR> col*o*mbia ?
18:40:53 <EvanR> ah 
18:40:57 <sbahra> :-P
18:41:02 <EvanR> not colombia
18:41:33 <sbahra> Alright, food -> programming. Bye.
18:42:10 <aavogt> coulombia is where charges attract
18:44:20 <copumpkin> aavogt: ARGH :P
18:44:46 <etpace> @hoogle Maybe a -> Maybe a -> Maybe [a]
18:44:46 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
18:44:46 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
18:44:46 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
18:44:54 <etpace> bah
18:45:26 <EvanR> > Nothing >>= Nothing
18:45:27 <lambdabot>   Couldn't match expected type `a -> Data.Maybe.Maybe b'
18:45:28 <lambdabot>         against infe...
18:45:32 <EvanR> > Nothing >> Nothing
18:45:32 <lambdabot>   Nothing
18:45:40 <EvanR> > Nothing >> Just
18:45:41 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
18:45:41 <lambdabot>         against inferred ...
18:45:42 <aavogt> @type maybeToList ++ maybeToList
18:45:43 <EvanR> > Nothing >>= Just
18:45:43 <lambdabot> forall a. Maybe a -> [a]
18:45:43 <lambdabot>   Nothing
18:45:59 <aavogt> @type (++) `on` maybeToList
18:46:00 <lambdabot> forall a. Maybe a -> Maybe a -> [a]
18:46:20 <aavogt> @type (++) `on` maybeToList
18:46:21 <lambdabot> forall a. Maybe a -> Maybe a -> [a]
18:46:32 <EvanR> doubletake
18:46:44 <aavogt> @type \x y -> (\z -> guard z >> z) $ ((++) `on` maybeToList) x y
18:46:45 <lambdabot>     Couldn't match expected type `m b' against inferred type `Bool'
18:46:45 <lambdabot>     In the second argument of `(>>)', namely `z'
18:46:45 <lambdabot>     In the expression: guard z >> z
18:46:47 <kmc> tbh i haven't heard much "everything is a function"
18:46:51 <kmc> but i'm glad conal wrote that post
18:47:12 <dolio> I've heard it, but not very often.
18:47:17 <copumpkin> how else do we interpret regular values in hask?
18:47:18 <aavogt> @type \x y -> (\z -> guard (null z) >> Just z) $ ((++) `on` maybeToList) x y
18:47:19 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe [a]
18:47:28 <aavogt> etpace: ^^
18:47:34 <kmc> it's funny because most of the OOP languages don't satisfy "everything is an object"
18:47:38 <kmc> the popular ones i mean
18:47:42 <copumpkin> yeah
18:47:44 <aavogt> EvanR: just gotta be sure :P
18:47:50 <kmc> the funniest misconception i've heard about Haskell is that in the pattern (x:xs), the language cares that the name xs is the plural of x.  like rails.
18:47:59 <jmcarthur> lol
18:48:07 <horms> haha
18:48:08 <EvanR> yes
18:48:10 <aavogt> how does rails care?
18:48:22 <EvanR> :t forever
18:48:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
18:48:27 <EvanR> 'is the m significant'
18:48:40 <aavogt> EvanR: definitely
18:48:45 <copumpkin> aavogt: you can say has_many :moo and it'll give you a method .moos
18:48:48 <aavogt> otherwise it's just undefined
18:48:54 <copumpkin> (this is in activerecord)
18:49:03 <copumpkin> iirc it even pluralizes things correctly
18:49:07 <kmc> and it has a big file of irregular English plurals
18:49:07 <aavogt> copumpkin: what does th : mean there?
18:49:15 <copumpkin> like has_many :child (: is a symbol)
18:49:24 <copumpkin> I think it'll even give you a .children
18:49:27 <copumpkin> can't remember though
18:49:43 <aavogt> what about latin (or is it greek) plurals?
18:49:54 <copumpkin> aavogt: probably in the big file of irregular plurals kmc mentioned :)
18:50:01 <aavogt> haha
18:50:01 <kmc> you can add your own
18:50:09 <dolio> "Everything is a function" might make sense if you're writing Charity.
18:50:11 <copumpkin> has_many :octopus => .octopodes
18:50:38 <dolio> Although, maybe you wouldn't say "function".
18:50:44 <kmc> it boggles the mind that people think DWIM is a good language design principle
18:50:55 <copumpkin> kmc: :P
18:51:02 <copumpkin> have you seen applescript?
18:51:06 <kmc> from that you can draw some unfavorable conclusions about which programmers they appeal to
18:51:12 <kmc> yes copumpkin
18:51:23 <EvanR> haskell drives like lambda calculus sometimes... where 'everything' is a...
18:51:55 <kmc> :t everything
18:51:56 <lambdabot> forall r a. (Data a) => (r -> r -> r) -> GenericQ r -> a -> r
18:51:58 <EvanR> a term ;)
18:52:03 <kmc> see, everything is a function
18:52:05 <copumpkin> in haskell, everything (but types) is an object though
18:52:09 <copumpkin> including functions
18:52:14 <edwardk> copumpkin: i used applescript in my much younger years to torture accounting... by making their computers sing to them.
18:52:27 <copumpkin> edwardk: so cruel :P
18:52:37 <aavogt> @index everything
18:52:37 <lambdabot> Data.Generics.Schemes, Data.Generics
18:52:47 <kmc> yes edwardk!
18:52:48 <EvanR> i heard the mac voice synth in an old sci-fi show recently, completely serious situation
18:52:49 <copumpkin> ugh, it's late, I should go to sleep
18:52:50 <kmc> i did this in middle school
18:52:52 <aavogt> that statesment applies to only that everything though
18:53:02 <kmc> you could invoke applescript remotely
18:53:05 <Cale> @index everywhere
18:53:05 <lambdabot> Data.Generics.Schemes, Data.Generics
18:53:11 <edwardk> kmc: yep
18:53:26 <kmc> if you hate someone you could make their computer load up lots of porn and then shout "PORNOGRAPHY DETECTED"
18:53:33 <aavogt> @hoogle everything
18:53:33 <lambdabot> Data.Generics.Schemes everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
18:53:48 <edwardk> kmc: =)
18:54:37 <dudes> hi
18:55:00 <dudes> can a 3g modem work independently
18:55:32 <kmc> is this a question about Haskell?
18:55:33 <aavogt> no, it depends on another modem
18:56:05 <copumpkin> dudes: I don't think you're in the right place :)
18:56:10 <copumpkin> not that I know where the right place is
18:56:20 <kmc> there's ##electronics
18:56:39 <Cale> What is the sound of one hand clapping?
18:56:56 <wioux1> *clap clap clap*
18:56:57 <aavogt> Cale: you can find videos
18:57:36 * copumpkin keeps an mp3 around of it since a lot of people seem to wonder
18:57:57 * ezyang has finished the massive two-day refactor! 
18:58:09 * ezyang expectantly waits for applause. 
18:58:19 * copumpkin applauds with one hand
18:58:38 <kmc> hooray
18:58:41 <copumpkin> (other is in a sling)
18:58:45 <aavogt> copumpkin: three hands?
18:58:54 <aavogt> n hands even?
18:59:00 <ezyang> copumpkin: Oh no! 
18:59:04 <Saizan> .hands
18:59:12 <copumpkin> aavogt: inductively defined
18:59:43 <aavogt> how disappointing that they might all be the same
18:59:46 <wioux1> ooh
19:00:15 <wioux1> n+1 hands clapping sounds like (n hands clapping) ++ "clap"
19:00:20 <dudes> hey guys
19:00:29 <aavogt> hey dudes
19:00:37 <dudes> can I run a standalone 3G modem
19:00:47 <wioux1> 0 hands clapping sounds like nothing, thus 1 hand clapping must sound like "clap"
19:00:49 <Axman6> dudes: you're in the wrong place
19:00:52 <dudes> with battery and microcontroller
19:01:00 <dudes> i know, but nobody helps me out :(
19:01:11 <wioux1> yahoo answers
19:01:14 <dolio> Someone already answered your question.
19:01:15 <Axman6> people will help you if you ask in the right places ;)
19:01:21 <kmc> well if you want to ask off-topic questions of (a subset of) us, try #haskell-blah
19:01:24 <copumpkin> dudes: it's like saying "the mathematicians in the university wouldn't help me, so I went to the ballet class and asked them instead.."
19:01:33 <kmc> i've found ##electronics to be helpful
19:01:42 <dudes> copumpkin, nice metaphor
19:01:47 <kmc> fun channel, they're always talking about blowing shit up or cutting shit in half
19:01:59 <dudes> kmc, dont stress out my friend
19:02:01 <EvanR> lol
19:02:01 <dudes> calm down
19:02:23 <kmc> i'm perfectly calm dude
19:02:34 <dudes> ok then, peace
19:02:35 <copumpkin> *dudes
19:03:27 <EvanR> gah... whats the cool way to 'make a list of results of an IO action until one of the results satisfied a condition'
19:03:53 <copumpkin> dudes: but we'll be happy to extol the virtues of strong static typing
19:03:54 <copumpkin> oh
19:03:57 <copumpkin> he left :(
19:04:27 <kmc> :t takeWhileM
19:04:28 <lambdabot> Not in scope: `takeWhileM'
19:04:44 <aavogt> Control.Monad tends to be lacking
19:05:16 <EvanR> takeWhileM :: (a -> Bool) -> IO a -> IO [a]
19:05:22 <EvanR> s/IO/m/
19:08:13 <BMeph> "let x = g in f" <==> " (\x.f) g" 
19:08:49 <BMeph> That's the right one, isn't it?
19:09:25 <dolio> The types may not work out, but other than that.
19:09:45 <qwebirc55057> @pl \x -> nub x == "."
19:09:45 <lambdabot> ("." ==) . nub
19:10:19 <dibblego> why not (a -> m Bool) -> m [a] -> m [a] ?
19:11:05 <EvanR> because i have m a, not m [a]
19:11:21 <EvanR> im trying to *get* an [a]
19:11:35 <aavogt> @type fmap join . filterM 
19:11:36 <lambdabot> forall a. (a -> [Bool]) -> [a] -> [a]
19:21:08 <EvanR> :t catMaybes
19:21:08 <lambdabot> forall a. [Maybe a] -> [a]
19:23:05 <cydergoth> Hi all. Is there a way to have a parameterized record type and then have a class which is applied to that type and use one of the type parameters in the class declaration?
19:24:03 <cydergoth> Something like data Foo a b = ( Num a, RealFloat b) => Foo { x::a, y::b } 
19:24:13 <aavogt> cydergoth: and what should instances of that class do with those parameters?
19:24:32 <kmc> cydergoth, if you want contexts on constructors, you should probably write it as a GADT
19:24:34 <cydergoth> Then class (Foo m) => Bar m where ....  and use the types a and b?
19:24:55 <aavogt> no, Foo is a data type, not a class
19:25:14 <cydergoth> Ok, but you see what I'm trying to say?
19:25:53 <cydergoth> kmc: when you say GADT you mean ?Abstract Data Type?
19:26:01 <aavogt> should Foo be it's own class? Otherwise GADTs might be an answer
19:26:32 <cydergoth> There might be types of Foo specialised for Double or Float
19:27:28 <aavogt> cydergoth: are you interested in dealing with specific combinations of Num a and RealFloat b?
19:27:35 <cydergoth> Yes
19:28:23 <cydergoth> a is an index which can be long or short but must be integral, b may be Double or Float, and I need to specialise at least two of the 4 combinations, probably all 4
19:28:43 <aavogt> cydergoth: so a function applied to a (Int,Double) is different than the same name applied to a (Int,Float) pair?
19:28:48 <cydergoth> I also need to return data in the same format, so I don't want to promote Float to Double
19:28:58 <cydergoth> Yes, in some cases
19:29:10 <cydergoth> as it might return a Point(Float) or a Point (Double)
19:29:15 <EvanR> some doubles, and some floats ;)
19:29:22 <cydergoth> We all float down here
19:29:34 <cydergoth> but only the King doubles down
19:29:48 <aavogt> multiparameter typeclasses
19:30:11 <cydergoth> googling
19:30:22 <aavogt> + functional dependencies (if you need it for better type inference / less possible instances) or associated types
19:30:45 <aavogt> the latter serve the same purpose really
19:33:09 <cydergoth> Ouch. Migraine time. Ok, I think I get it. I also need a (relatively) complex ADT against which to apply this type class (a type class is like a protocol right?)
19:33:44 <cydergoth> declares the functions which must be supported but which may be specialised? ) 
19:33:52 <aavogt> I'm not sure you have a correct interpretation by saying a type is applied to a class
19:36:19 <cydergoth> aavogt: So I have a set of methods which I want to apply in a polymorphic way to a (relatively) complex ADT. That ADT is parametrised by at least two type parameters. Polymorphic functions against that ADT should have return types which are defined by the ADT type parameters. Is there a way to do this neatly?
19:37:06 <aavogt> perhaps you don't need a class
19:37:42 <cydergoth> aavogt: So what can I use to define the polymorphic characteristics and allow generalised algorithms to work on them?
19:38:10 <aavogt> @type \x y -> x + 2*y
19:38:10 <lambdabot> forall a. (Num a) => a -> a -> a
19:38:20 <aavogt> cydergoth: polymorphic like that ^^ ?
19:39:11 <cydergoth> Hmmm
19:39:21 <Philonous> Does cabal respect options provided by pkg-config when I set pkgconfig-depends?
19:39:46 <aavogt> but say you want to deal with some set of classes as in the same manner... then you probably need to define a new class
19:40:18 <cydergoth> aavogt you might have something there, if x, y are ADTs and the result is the a different ADT parameterized with a type parameter of x or y
19:40:50 <aavogt> cydergoth: possibly using some classes to connect x or y to some other types x' y' 
19:41:20 <aavogt> (in the case of -XMultiParamTypeClasses)
19:41:32 * BMeph is starting to realize that a huge part of the problems folks have with understanding Haskell, is that they are simply unussed to the idea that Haskell lets you do things easily, that are really difficult in other languages...
19:41:40 <cydergoth> So if x is a Mesh Double Int and the result is a Point (x,y,z) where x,y,z MUST be Double, but if x is a Mesh Float Int then the result must be a Point(x,y,z) where they are Float
19:42:03 <aavogt> BMeph: and the impossible just happened :P
19:42:29 <cydergoth> It looks like aavogt might be correct here in that I don't need a class at all
19:42:40 <aavogt> cydergoth: so the type is like    Mesh a b -> Point a
19:42:54 <cydergoth> Yes
19:43:01 <kmc> BMeph, and makes some things difficult that are easy in other languages
19:43:09 <aavogt> yeah, then no classes are needed there
19:43:13 <BMeph> cydergoth: Welcome to Haskell! :)
19:43:16 <eflister> hi -- has anyone used blackh's iphone thing?  http://hip-to-be-square.com/~blackh/iphone/ghc-iphone-1.3/
19:43:16 <dibblego> I have a pretty solid formula for deciding between a class and a data type -- I should write it down
19:43:24 <kmc> but yeah, people often take the long way around
19:43:32 <kmc> like defining a bunch of type classes and instances and types
19:43:36 <geheimdienst> Haskell™. Making hard things easy, and easy things a hylomorphism.™
19:43:37 <kmc> when they could just pass a function
19:43:39 <cydergoth> If I'm correctly following you, the type system will figure it out automatically. How then would I be able to specialise some of these methods using e.g. an FFI for performance
19:43:46 <aavogt> though they might turn up in the context of that function it you decide to add up some coordinates...
19:44:18 <aavogt> cydergoth: hope the compiler figures it out with SPECIALIZE pragmas?
19:44:23 <cydergoth> Should I do that with pattern selection of the function based on the types of the argument?
19:44:36 <kmc> cydergoth, you need a class if you want to write a function which has *different* code for different types
19:45:14 <aavogt> so write a function using the FFI or whatever, and tell the compiler that when it sees that function applied to specific types, that it can take that shortcut
19:45:16 <cydergoth> kmc: I think I get it
19:45:23 <BMeph> kmc: Oh, well surely! There's no dooubt that Haskell makes otherwise easy stuff difficult. I'm just interested that some people have trouble grasping that there may be a trade-off in Haskell's organization, not just a strictly worse level of descriptive power.
19:45:43 <aavogt> kmc: pragmas though
19:45:59 <mtnviewmark> Why xk
19:46:03 <mtnviewmark> Er
19:46:31 <cydergoth> kmc, aavogt: I think you're correct in that most of the time I want the same operations but on different (but similar) data types
19:46:48 <aavogt> cydergoth: is it strictly an optimization?
19:47:11 <cydergoth> aavogt: Actually I'm trying to port a piece of C++ code, and replace it piecemeal
19:47:14 <mtnviewmark> Why would you need a pragma? If you knew that you needed different code for different types make a class, then implement the instance for some type with a method that calls a FFI function
19:47:30 <Mathnerd314> so how is ghc-llvm going? is it in an official release yet?
19:47:40 <Axman6> no
19:48:05 <cydergoth> mtnviewmark: So the original question was how would I declare a class which applies to a type parametrised ADT 
19:48:25 <aavogt> mtnviewmark: it makes more sense when the implementations for different types do exactly the same thing
19:48:25 <cydergoth> mtnviewmark: in such a way that I can make the function types in the class use the same type parameters as the ADT
19:49:00 <cydergoth> Example: 90% of the code is the same for Float or Double, but the really high precision bit uses different native asm
19:49:02 <BMeph> "class (CyderClass adt) where..." ;)
19:49:03 <aavogt> err, produce the same result, but do it differently
19:50:07 <cydergoth> BMeph: That's syntax I've not seen before
19:50:23 <aavogt> me either
19:50:42 <eflister> i've never used xcode and am trying to get HaskellDraw to compile on the iphone simulator but when i tried to build "error: There is no SDK with specified name or path 'Unknown Path'" and am not sure what to do... 
19:50:42 <mtnviewmark> class HiPrecision a where { ... 
19:50:44 <BMeph> "      ... gimmeAPoint :: adt a b -> Point b "
19:50:47 <eflister> is blackh around?
19:50:52 <eflister> @seen blackh
19:50:52 <preflex>  blackh was last seen on #haskell 14 days, 3 hours, 1 minute and 8 seconds ago, saying: ivanm: I don't mind.
19:50:52 <lambdabot> Unknown command, try @list
19:51:18 <mtnviewmark> noodle :: a -> a -> a ... }
19:51:38 <kmc> eflister, i corresponded with him by email a few days ago
19:52:15 <eflister> kmc: hm, cool, thx. looks like he doesn't hang out on irc much lately? have you or anyone checked out his iphone thing?
19:52:35 <c_wraith> eflister: several people in this channel work at his company, actually
19:52:45 <kmc> i'm working for the same company as him (iPwn Studios)
19:52:52 <kmc> i've looked at the iPhone code (though i haven't built it)
19:52:57 <cydergoth> This is the half-baked code : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28574#a28574
19:53:00 <aavogt> preflex seen ryant5000
19:53:00 <preflex>  ryant5000 was last seen on #haskell 8 days, 16 hours, 43 minutes and 50 seconds ago, saying: is there a way to dynamically add an SCC to the stack?
19:53:11 <kmc> eflister, i'm doing something approximately similar for Android
19:54:00 <cydergoth> So if you look at the ADT MeshData and the method vertex, vertex should return a type Point3 which is parameterized by 'b' in the ADT MeshData
19:54:24 <cydergoth> Instead of being forced to RealFloat as it is
19:54:32 <eflister> kmc: sounds awesome. i think i'm just having an xcode problem -- i've never used it.  the drop down on the upper left says "unknown SDK 'iphoneos2.2.1' | Debug | Has..." -- seems like i haven't gotten it hooked up to ghc properly or something?
19:54:54 <aavogt> cydergoth: constraints on data constructors are rather useless
19:55:00 <cydergoth> Now, I think I can understand that if I don't use a class, the type inference will do the right thing 
19:55:03 <eflister> kmc: i followed the binary install instructions from https://docs.google.com/viewer?url=http://hip-to-be-square.com/~blackh/iphone/ghc-iphone-1.3/GHC-iPhone.pdf
19:55:27 <mtnviewmark> eflister: Do you have the right version of Xcode?
19:55:31 <cydergoth> but in that case I will only be able to specialise methods by using compiler pragmas? Or can I do it using pattern matching against types?
19:56:11 <eflister> mtviewmark: how do i check?  the install instructions don't specify i need anythign in particular.  xcode says it is 3.1.2
19:56:17 <aavogt> cydergoth: if you want to specialize for sure, use a class then
19:56:20 <cydergoth> aavogt: why do you say that? Does my constraint not do the right thing?
19:56:37 <mtnviewmark> You'll need to have downloaded the version from the iPhone developer's site
19:57:04 <aavogt> cydergoth: it doesn't let you assume the values you take out of that constructor match those classes (unless using -XGADTs apparently)
19:57:12 <mtnviewmark> Not the one from the standard OS X developer portal
19:57:19 <eflister> mtnviewmark: hm ok, didn't know that -- the instructions don't say so?  i'll try it... thx!
19:57:25 <aavogt> so you only restrict yourself, without taking any benefits from those restrictions
19:57:27 <cydergoth> aavogt: so is that a limit in the compiler?
19:57:35 <cydergoth> ^limitation
19:58:02 <mtnviewmark> This is because you don't get the iPhone sdk with the normal Xcode release - only after you have agreed to Apples iPhone develop policy
19:58:33 <aavogt> cydergoth: you can't use the regulary   `deriving Foo' with gadt-style data types
19:58:39 <mtnviewmark> You might be bake to din,OAS just the sdk from the iPhone developers site and install it into your Xcode install....
19:58:59 <kmc> apple :(
19:59:00 <kmc> iphone :(
19:59:07 <eflister> "bake to din,OAS" ?  :)
19:59:14 <aavogt> the behavior with respect to    data Foo a = C a => Foo a   is in the specification apparently
19:59:21 <mtnviewmark> A
19:59:36 <mtnviewmark> And yet here I sit with my iPad on IRC...
19:59:41 <ezyang> Ooh, really nice post by conal. 
19:59:52 <mtnviewmark> Hence the typing mistakes!
19:59:54 <kmc> aavogt, cydergoth the GHC manual describes the behavior as strange and useless
19:59:56 <kmc> which i think it is
20:00:05 <kmc> and so they "fixed" it for GADTs
20:00:09 <cydergoth> kmc: is that Haskell you're describing?
20:00:16 <aavogt> the specification being:
20:00:18 <kmc> ;P
20:00:21 <aavogt> @where report
20:00:21 <lambdabot> http://www.haskell.org/onlinereport/
20:01:22 <cydergoth> aavogt: so if we're back to classes, then we've gone full circle and my original question stands: is there a way to declare functions in a class against a parameterized ADT and use the same type parameters in the class function declarations?
20:02:16 <aavogt> like   data T a b = ...  ; class C a b (T a b)
20:03:00 <aavogt> cydergoth: if you add enough extensions, it'll be accepted
20:03:21 <aavogt> just stop around -XUndecidableInstances :)
20:03:34 <cydergoth> aavogt: Yes! I think you've got it
20:03:45 <kmc> really?
20:03:51 <kmc> you can write a class with types in the head like that?
20:04:03 <aavogt> if they are flexible
20:04:14 <aavogt> err, maybe in the instances
20:04:38 <kmc> yeah, in the instances
20:04:41 <aavogt> kmc: there's no -XFlexibleClassses yet
20:05:00 <cydergoth> aavogt: Does that mean ;-(
20:05:02 <dolio> What is "class C a b (T a b)" supposed to mean?
20:05:10 <aavogt> it's a typo
20:05:36 <aavogt> intention:   class C a b c; instance a b (T a b)
20:06:18 <aavogt> dolio: perhaps it could restrict all instances to involve T...
20:06:27 <kmc> but then you could just mention T in the body instead
20:06:30 <kmc> in the sigs
20:06:47 <aavogt> true
20:07:25 <cydergoth> The problem is with methods like this: vertex                 :: RealFloat a => m -> Int -> Point3 a where m is the ADT parameterized by Double, Int and a should match the Double
20:07:42 <cydergoth> But in the class decl, I have no way to say ... and use the type parameter from 'm'
20:08:07 <cydergoth> So I have to make it fixed type
20:08:51 <cydergoth> Correct?
20:09:12 <dolio> Incidentally, I think the behavior of 'data C a => T a' is a relic of when seq was in a type class. It makes some sense there, and it was probably carried forward into Haskell 98 without considering whether it still made sense.
20:09:49 <aavogt> dolio: for C == Seq?
20:10:53 <aavogt> dolio: it isn't clear what it means in that case if Seq is a calss
20:11:08 <aavogt> class*
20:11:24 <dolio> There used to be 'class Eval a where seq :: a -> b -> b'.
20:12:09 <siracusa> How do I pass an extra option to GHC via cabal install?
20:12:28 <dolio> But, if you want to write "data T a = T !a", that declaration is illegal. To make the field strict, you must know that a is in the Eval class.
20:12:43 <dolio> Hence, data Eval a => T a = T !a
20:13:21 <dolio> That is the only situation I can think of where the behavior is useful, though.
20:13:26 <cydergoth> dolio: Or a primitive?
20:15:24 <aavogt> every type is an instance of Eval (in H98)
20:15:28 <Saizan> siracusa: --ghc-option=
20:15:44 <dolio> Every type was an instance of Eval in previous Haskells, too.
20:15:54 <dolio> You just had to mention it explicitly.
20:16:52 <siracusa> Saizan: Ah, that simple. Thanks!
20:17:05 <aavogt> dolio: but if you didn't mention it in the constructor, you could still add that constraint in some function later on (as you can for other classes)?
20:17:33 <dolio> Yes. But the point of T above is that the constructor needs to seq something.
20:17:44 <dolio> So you need the constraint on the constructor.
20:23:25 <Gracenotes> @hoogle fromDistinctAscList
20:23:26 <lambdabot> Data.IntMap fromDistinctAscList :: [(Key, a)] -> IntMap a
20:23:26 <lambdabot> Data.IntSet fromDistinctAscList :: [Int] -> IntSet
20:23:26 <lambdabot> Data.Map fromDistinctAscList :: [(k, a)] -> Map k a
20:31:29 * hackagebot indents 0.2.0 - indentation sensitive parser-combinators for parsec  http://hackage.haskell.org/package/indents-0.2.0 (SamAnklesaria)
20:39:05 <dibblego> @src filterM
20:39:05 <lambdabot> Source not found. My brain just exploded
20:41:11 <EvanR> :t otherwise
20:41:12 <lambdabot> Bool
20:41:58 <ddarius> @src otherwise
20:41:58 <lambdabot> otherwise = True
20:42:10 <ddarius> preflex: xseen xerox
20:42:11 <preflex>  xerox was last seen on efnet/#vim 14 days, 15 hours, 33 minutes and 31 seconds ago, saying: giggles
20:42:11 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
20:43:08 <EvanR> > signum 9
20:43:09 <lambdabot>   1
20:43:12 <EvanR> > signum -3
20:43:13 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
20:43:13 <lambdabot>    arising from a use of `...
20:43:16 <EvanR> > signum (-3)
20:43:17 <lambdabot>   -1
20:43:21 <EvanR> > signum 0
20:43:22 <lambdabot>   0
20:44:25 <aavogt> signum should really have a type like compare
20:45:33 <ddarius> aavogt: Probably not.  It's not that hard to write flip compare 0 if desired.
20:46:20 <ddarius> signum is the derivative of the absolute value function assuming you pop a 0 in at the discontinuity.
20:46:27 <aavogt> yeah, at least it's available without enumerating the cases
20:46:45 <EvanR> aavogt: but wait, if you did that then how would Complex work ;)
20:47:10 <aavogt> EvanR: compare magnitudes?
20:47:16 <cydergoth> aavogt: I think you're correct about the uselessness of type constraints on parameterized ADTs, I've had to decorate all the functions with the same constraints even thought they should be inferable
20:47:36 <EvanR> aavogt: magnitude is never negative
20:48:17 <aavogt> I guess you expect    compare a b == EQ <=> (a == b)
20:48:22 <EvanR> > signum (4:+3)
20:48:23 <lambdabot>   0.8 :+ 0.6
20:49:03 <EvanR> it makes sense that signum is a comparison with num zero
20:49:24 <EvanR> but im saying complex has this funky implemenation, and i dont see a way to compare ;)
20:49:28 <EvanR> to zero
20:50:44 <EvanR> > (4:+3) < (0:+0)
20:50:44 <lambdabot>   No instance for (GHC.Classes.Ord (Data.Complex.Complex t))
20:50:45 <lambdabot>    arising from ...
20:52:00 <blups0r> does someboday know why this doesnt work? http://pastebin.com/7AHmsnd6
20:52:44 <EvanR> @src Num
20:52:44 <lambdabot> class  (Eq a, Show a) => Num a  where
20:52:44 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:52:44 <lambdabot>     negate, abs, signum     :: a -> a
20:52:44 <lambdabot>     fromInteger             :: Integer -> a
20:53:29 <aempirei> man i wanna get my chat on
20:54:57 <Cale> blups0r: Make sure you have a module called Crawler in a file named Crawler.hs in the same directory as that program.
20:55:16 <Cale> blups0r: Otherwise, you'll have to inform GHC explicitly where to look for it.
20:55:50 <Cale> blups0r: Also, instead of using fst and snd, it's better style to pattern match here.
20:56:43 <blups0r> has the file havae to have a capital lette at beginning?
20:56:48 <Cale> yes
20:57:03 <Cale> Unless you're on a filesystem which is case insensitive.
20:58:37 * hackagebot directory-tree 0.2.1 - A simple directory-like tree datatype, with useful IO functions  http://hackage.haskell.org/package/directory-tree-0.2.1 (BrandonSimmons)
20:59:24 <cydergoth> Cale: ...and if you're on a file system which is case insensitive, you're doomed anyway
20:59:58 <aavogt> haskell is supposed to work fine though
21:00:28 <blups0r> now he complain about a parse error
21:00:34 <blups0r> same code as before
21:03:22 <blups0r> somebody got an idea why i get the error?
21:03:41 <monochrom> "insertCrawlerInTrie [Crawler] -> Trie a -> Trie a" ?
21:04:02 <blups0r> oh
21:04:07 <blups0r> i forgot the ::
21:04:19 <monochrom> and later on, "IO Trie a" should be "IO (Trie a)"
21:04:27 <EvanR> > -(1,1)
21:04:28 <lambdabot>   (-1,-1)
21:04:34 <EvanR> *nice* ;)
21:04:47 <monochrom> there is no "Filepath". it's "FilePath"
21:05:00 <monochrom> @type openFile
21:05:01 <lambdabot> Not in scope: `openFile'
21:05:08 <monochrom> @hoogle openFile
21:05:08 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
21:08:33 <cygnus> What's the most appropriate way to modify the "Data-Files" element of my cabal configuration in Setup.hs?
21:12:59 <cydergoth> aavogt: Got it. I decided to go without the class and just rely on the type inference. It gives me what I needed if I forgo the optimisation
21:13:58 <cydergoth> aavogt: but I did have to apply the type constraints on every method, even tho' they are on the ADT data decl
21:16:59 <blups0r> another problem http://pastebin.com/Wtr8Sxvy
21:18:55 <blups0r> anybody?
21:22:01 <siracusa> blups0r: Maybe change the return type of insertCrawlerInTrie to Trie FilePath
21:27:21 <blups0r> ok when i make Trie Filepath it works but why cant i write Trie a
21:30:22 <siracusa> blups0r: I don't know what exactly insertStrLst does, but its return type must be Trie FilePath. So this type is more specialized than Trie a.
21:36:11 <blups0r> but why do i have to specialize the type
21:39:21 <EvanR> something along the lines isnt polymorphic
21:40:38 <siracusa> blups0r: Look at the type signature of insertCrawlerInTrie. It says: Give me a Trie of type a (and a list of crawlers) and I return a Trie of the same type a. But this is not the case here. No matter what exactly your type a is, it will always return a Trie of FilePath.
21:42:00 <siracusa> So if you pass Trie Int the result must be Trie Int, but it won't, it will be Trie FilePath.
21:43:53 <blups0r> ok i undrstand that but then in the other funktions he can replace the a with filepath i think
21:44:57 <blups0r> heres the code of the whole thing http://pastebin.com/VLtc7k1e
21:47:38 <blups0r> i have solved it
21:47:43 <blups0r> thanks for the help
22:22:38 <ezyang> test 
22:29:30 <tensorpudding> ezyang: pong
22:30:00 <ezyang> There was no traffic on Haskell for 40 minutes, so I got a little worried :-) 
22:30:20 <tensorpudding> Heh.
22:30:30 <tensorpudding> It was a perfect storm of disinterest.
22:30:36 <mauke> preflex: quote
22:30:37 <preflex>  <c_okie> Just saying, don't say stupid shit to me
22:30:48 <tensorpudding> @quote
22:30:48 <lambdabot> ChilliX says: You need to seek a balance between category theory and VLSI
22:31:07 <tensorpudding> @quote lambdabot
22:31:08 <lambdabot> lambdabot says: @quote lambdabot
22:31:21 <tensorpudding> oh hmm
22:38:20 <siteswapper> @quote
22:38:20 <lambdabot> AshleyYakeley says: 'What pointers should I give?' Safe ones.
22:38:22 <cncl> is anyone here a frequent user of haskell inferior ghci in emacs' haskell-mode?
22:39:26 <cncl> i noticed that after i have a haskell-inferior buffer open for a long time, ghci will be using a ton of memory (like 4gb+)
22:39:41 <cncl> is there some quick way to kill/reload it
22:55:40 <quicksilver> cncl: I don't *think* that's emacs' fault
22:55:51 <cncl> right, it's ghci
22:55:55 <quicksilver> cncl: I think it's just a limitation of ghci that top-level bindings don't get GCed
22:56:00 <cncl> but i was wondering if there's a quick kill/reload thing
22:56:48 <cncl> since right now i have to switch to the frame/window with it, kill the buffer, then tell haskell-mode to load another inferior haskell buffer, and then it defaults to opening a new split, argh now i have to close the split, switch to my other frame, load the haskell inferior buffer in that frame..
22:56:53 <quicksilver> I kill the ghc(i) process from outside emacs and then when you rerun it in emacs it reuses the same buffer
22:57:02 <quicksilver> which means you save your layout + history
22:57:03 <cncl> perfect
22:57:07 <quicksilver> there might be a cleverer way ;)
22:57:16 <cncl> don't need clever, need works :)
22:57:45 <rat_> is fmap the preferred way to apply functions to a maybe value(propagating Nothings up)
22:57:47 <rat_> ?
22:57:54 <ezyang> rat_: It is one way 
22:58:04 <ezyang> Sometimes it might not be powerful enough 
22:58:19 <tensorpudding> fmap is a way to make a function a -> b work on Maybe a -> Maybe b
22:58:24 <tensorpudding> it's the simplest way
22:59:49 <kmc> rat_, (<$>) is a synonym for fmap defined in Control.Applicative
22:59:52 <kmc> sometimes infix reads nicer
23:00:50 <rat_> which way is usually preferred in nice looking haskell code?
23:01:10 <blups0r> is there a way to debug haskell programms
23:01:17 <kmc> blups0r, various
23:01:27 <kmc> the most straightforward is to load your code in ghci and call individual functions by hand
23:01:40 <blups0r> i mean to go step by step through a function
23:02:01 <kmc> that's both more difficult and less useful in a lazy functional language
23:02:06 <kmc> GHCi has some debugger support though
23:02:10 <kmc> breakpoints and such
23:02:27 <kmc> there's also Debug.Trace for printf-style debugging
23:03:10 <kmc> i have used gdb on ghc-compiled code... but this is mostly useful for debugging ghc and its runtime system, not so much for debugging your code
23:09:36 <cncl> blups0r: i usually just import Debug.Trace and use trace statements
23:31:02 <mmmulani> if my binaries are installed in an unusual directory, how do I tell cabal where to find them when installing a package that requires them?
23:36:29 <Saizan> you can say --with-foo=/path/to/foo, to point cabal to foo
23:40:54 <mmmulani> hmmmmm
23:41:11 <mmmulani> I'm trying to use a compiled version of GraphicsMagick with hsmagick
23:41:18 <mmmulani> just not sure what files cabal is looking for :/
23:46:34 <blups0r> thanks the Debug.Trace helped a lot
23:47:14 <cncl> blups0r: be careful though, oftentimes you will get trace statements printed out not in the order you expect
23:47:18 <kmc> @quote oasis
23:47:19 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
23:47:25 <cncl> due to laziness
23:53:57 <etpace> is there a way to generate ctags/etags via hasktags whenever I do cabal build?
23:54:35 <ezyang> etpace: You could hack your Setup.hs file 
23:55:29 <etpace> m
23:55:33 <etpace> guess so
