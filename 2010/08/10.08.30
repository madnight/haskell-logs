00:19:31 * hackagebot HTF 0.3.4 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.3.4 (StefanWehr)
01:33:53 * hackagebot proc 0.0.6 - Parse process information for Linux  http://hackage.haskell.org/package/proc-0.0.6 (AndyStewart)
01:42:56 <lambdor> do you know of a Monad quiz?
01:43:16 <lambdor> Monds make me crazy
01:43:30 <ivanm> here you are:
01:43:32 <ivanm> What is your name?
01:43:34 <lambdor> Everytime I read something new about them, I have additional interpretations
01:43:36 <ivanm> What is your return definition?
01:43:40 <ivanm> What is your bind/join definition?
01:43:41 <nlogax> What is your quest?
01:43:53 <ivanm> nlogax: what does that have to do with the Monad type class? :p
01:43:59 <lambdor> and want to check what is right
01:44:10 <ivanm> oh, and: Is your fail definition a pile of fail itself?
01:44:13 <luite> everything is probably right, in a way
01:44:40 <luite> ivanm: don't forget the monad laws
01:45:29 <nlogax> ivanm: nothing. "What is your name?" just made me think of that silly bridge keeper :)
01:46:08 <lambdor> a Monad is mathematical concept, but in Haskell implemented as a class
01:47:11 <lambdor> and as a class, the need a "interpretation" of the return and bind function on a CONCRETE type
01:47:14 <lambdor> is this right so far?
01:49:15 <Heffalump> yes
01:51:32 <lambdor> in constrast to a function signature with pure function, where only an input is mapped to an output; a monad type expresses that a computation is being beformed, using an encapsulated value (but it might as well not use it)?
01:53:01 <Heffalump> well, that's just one interpretation of what a monad type means
01:53:21 <luite> lambdor: it's a bit risky to talk about encapsulated value
01:53:22 <Heffalump> if you think of State, then a -> State s b is no different in operation to a -> s -> (b, s)
01:56:25 <malorie> I'm just working through some exercises and wanted to check, whether this looks halfway decent (or whether I've made some obvious mistakes): http://codepad.org/oQ96wzan
01:57:53 <luite> malorie: if you want to check whether a list xs is empty, you usually do null xs
01:59:01 <lambdor> but in the monad I don't get  get access to s?
01:59:17 <luite> malorie: in checkPalindrome :)  you already know the other way to do it, by pattern matching
01:59:35 <lambdor> (except with fetch)
02:00:01 <malorie> luite: ah. I thought guards would fit better, there.
02:00:26 <luite> malorie: then you should just have used | null xs = True
02:00:42 <etpace> True = True?
02:00:43 <luite> malorie: the problem is that length xs has to traverse the whole list to find its length
02:01:03 <malorie> luite: I need to make sure though, that both [] and [_] evaluate to True
02:01:23 <luite> > last [1]
02:01:24 <lambdabot>   1
02:01:28 <luite> > head [1]
02:01:29 <lambdabot>   1
02:01:49 <luite> oops you're right, this will go wrong with the third case
02:01:56 <malorie> :)
02:02:22 <luite> but the code is very inefficient
02:04:07 <malorie> getting the last element of list is very expensive, as I can imagine. I depend badly on it, though.
02:04:34 <luite> yes, and you construct a completely new list each time
02:04:39 <luite> tail xs is quite efficient
02:04:45 <luite> but init xs rebuilds the whole list
02:05:17 <malorie> maybe I should construct a single list with revert when the function is called?
02:05:54 <malorie> s/revert/reverse/
02:05:54 <luite> that would be easier, actually, if you use reverse, you can write it in a single line
02:06:08 <luite> without recursion
02:06:17 <malorie> that'd be awesome!
02:07:01 <fasta> malorie, count how often you need a particular element and choose a data structure based on that. 
02:09:21 <luite> you don't need anything other than lists though, for this problem
02:10:41 <malorie> luite: I think, I did it: checkPalindrome' xs = if xs == reverse xs then True else False
02:10:57 <luite> malorie: even shorter: checkPalindrome' xs = xs == reverse xs
02:12:05 <malorie> luite: ah, I see. because (==) already returns Bool.
02:12:37 <luite> yes, usually, you shouldn't need if/then/else often
02:12:51 <Heffalump> lambdabot: correct
02:13:10 <nlogax> @pl checkPalindrome' xs = xs == reverse xs
02:13:10 <lambdabot> checkPalindrome' = ap (==) reverse
02:14:04 <luite> malorie: you can also improve your makePalindrome function by using revere
02:14:07 <luite> reverse
02:14:08 <fasta> Any reason why  p xs = xs ++ reverse xs doesn't work? 
02:14:20 <luite> it should :)
02:14:24 <fasta> It happens to duplicate singleton lists, but that doesn't make it wrong. 
02:14:52 <luite> I didn't want to spoil the answer though
02:15:06 <fasta> malorie, anyway, in general you should _avoid_ introducing case analysis. 
02:15:29 <fasta> malorie, I can recommend you a book on this topic, if you want.
02:15:44 <luite> I'd guess he's already reading a book, and this is once of the exercises :)
02:16:11 <fasta> luite, yes, but not all books emphasize this. Especially academic books take it as a given. 
02:16:22 <luite> these are exercises in RWH
02:16:37 <malorie> fasta: I'm currently reading realworldhaskell (where this exercise is from, btw)
02:16:49 <fasta> So?
02:17:06 <fasta> Or does it explicitly ask for just one equation?
02:17:23 <malorie> no
02:18:56 <malorie> luite: thanks for tips, so far. I'm wonderning, though, whether it'd be possible to tweak checkPalindrome even more, by not reversing the _whole_ list.
02:19:54 <luite> malorie: of course, but exactly what do you want it to do?
02:22:15 <luite> malorie: you could do something like: palindrome (x:xs) = reverse xs ++ x : xs
02:22:25 <luite> malorie: then it wouldn't duplicate the middle character
02:22:27 <malorie> luite: something like, take and reverse the first half of the list and compare that to the secand half of the initial list
02:24:03 <luite> malorie: oh you mean in checkPalindrome? that wouldn't really be more efficient, since you have to drop a lot of elements to get to the second half of the list
02:24:31 <luite> comparing elements is cheap, so I wouldn't bother trying to reduce the number of comparisons
02:25:59 <fasta> Out of the 37 comments on RWH, only one does the simplest possible solution :(
02:26:40 <fasta> Or two. Anyway, too little. 
02:26:50 <luite> the solution itself doesn't matter, how you get there does :p
02:27:50 <eikke_> is there a more sane way to write this: M.fromListWith (+) $ concat $ map helper $ M.toList myMap (with M being Data.Map)
02:28:22 <Zao> concatMap ?
02:28:23 <luite> eikke_: you can replace concat.map by concatMap
02:29:03 <luite> eikke_: and lots of $ is often a sign that you don't use (.) enough :)
02:29:24 <eikke_> I'm mainly referring to some better-suiting function in Data.Map which I'm overlooking
02:29:33 <ski> luite : rather `(concat .) . map = concatMap'
02:29:57 <eikke_> map to list to list to list to map looks like overkill to me
02:29:57 <luite> ah yes you're right
02:30:11 <etpace> :t fmap.fmap concat map
02:30:12 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
02:30:12 <lambdabot>     In the first argument of `fmap', namely `concat'
02:30:12 <lambdabot>     In the second argument of `(.)', namely `fmap concat map'
02:30:17 <etpace> :t fmap concat map
02:30:17 <lambdabot>     Couldn't match expected type `[[a]]'
02:30:17 <lambdabot>            against inferred type `[a1] -> [b]'
02:30:17 <lambdabot>     Probable cause: `map' is applied to too few arguments
02:30:19 <etpace> mm
02:30:36 <ski> @type fmap (fmap concat) map
02:30:37 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
02:30:54 <ski> (.. if you want to phrase it in those terms)
02:30:57 <luite> eikke_: if you only modify the Map's values, you'd use fmap, but it looks like your helper function also modifies the keys?
02:31:23 <luite> oh sorry
02:31:26 <luite> forgot about the concat
02:31:39 <eikke_> luite: it's new keys being created
02:31:46 <HskNoob> q: How to add modules to ghc on Ubuntu? (Failed to load interface for `Data.Digest.SHA256')
02:32:33 <Zao> HskNoob: If your GHC is from the repositories, see if there's some digest or sha package.
02:33:12 <ivanm> nlogax: that was intentional ;-)
02:33:13 <eikke_> luite: for every given (k, v) in the map, 10 new (k, v) pairs are emitted, and if k is already in the map, it shuold be sum'ed to the existing value
02:33:14 <Zao> HskNoob: Otherwise if you have cabal-install, find out what it's named on Hackage and cabal install it.
02:33:32 <ski> malorie : hm .. could you write a function `leastPalindrome' such that `leastPalindrome as' is the shortest palindrome, which has `as' as suffix (or prefix, if you prefer) ?
02:33:48 <nlogax> ivanm: aww, and then you made me feel guilty
02:34:06 <ivanm> :D
02:34:13 <Zao> As for in what package that is, consult whatever code that that's from :D
02:34:27 <ski> malorie : e.g. `leastPalindrom "aba"' would be `"aba"' not `"abaaba"' or `"ababa"'
02:34:43 <HskNoob> Zao: thanks, going to find out about cabal
02:35:49 <luite> eikke_: you could use a fold on the map, but if your helper function returns a list, what you have may be the easiest solution
02:39:33 <Jafet> @hoogle (a -> a -> a) -> (Map k a) -> (Map k a) -> (Map k a)
02:39:33 <lambdabot> Data.Map unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
02:39:33 <lambdabot> Data.Map intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
02:40:31 <Jafet> @hoogle (a -> a -> a) -> (Map k a) -> (Map k a) -> (Map k a)
02:40:32 <lambdabot> Data.Map unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
02:40:32 <lambdabot> Data.Map intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
02:41:28 <luite> yes the fold would probably use unionWith
02:42:40 <malorie> ski: sounds interesting. will try
02:44:24 <Jafet> Maybe it could fold over insertWith
02:44:41 <Jafet> Whether that looks prettier, or is any more efficient, is debatable
02:50:03 <fizruk> hi all! what do I need to post on haskell-cafe? when I try to send e-mail to haskell-cafe@haskell.org I get message from haskell-cafe-owner@haskell.org that says that my message was automatically rejected =(
02:50:12 <ivanm> you need to register
02:50:16 * hackagebot bits-atomic 0.1.0 - Atomic bit operations on memory locations  for low-level synchronization  http://hackage.haskell.org/package/bits-atomic-0.1.0 (GabrielWicke)
02:50:20 <ivanm> @where mailing_lists
02:50:20 <lambdabot> I know nothing about mailing_lists.
02:50:22 <ivanm> bah
02:50:42 <fizruk> i subscribed, isn't that enough?
02:50:54 <ivanm> http://haskell.org/mailman/listinfo/haskell-cafe
02:51:00 <ivanm> well, that should be it
02:51:10 <ivanm> fizruk: any reason specified for why it was rejected?
02:51:14 <ivanm> was the email too large?
02:51:50 <fizruk> no reason, i tried to send message to haskell-cafe-owner@haskell.org but no reply followed for 2 or 3 days
02:51:57 <ivanm> don't send it there!
02:52:07 <ivanm> that's probably an automated address
02:52:33 <Zao> "To post a message to all the list members, send email to haskell-cafe (frob) haskell.org. "
02:52:33 <fizruk> crazy.fizruk at gmail dot com is too large?)
02:52:45 <ivanm> no, I meant the actual contents of the email
02:52:46 <ManateeLazyCat> fizruk: Have you register haskell-cafe?
02:52:52 <ivanm> ManateeLazyCat: he said he did
02:53:29 <fizruk> maybe i should try to repeat registration?
02:53:32 <ManateeLazyCat> ivanm: Question is where? If he register through other mail-list server, such as gmane.org, can't work.
02:53:46 <ivanm> fizruk: can you log in to http://haskell.org/mailman/listinfo/haskell-cafe ?
02:54:12 <ManateeLazyCat> ivanm: I used to register haskell-cafe through game.org, and haskell-cafe always reject my mail....
02:54:32 <ivanm> heh
02:55:42 <ManateeLazyCat> fizruk: You need make sure you register at http://haskell.org/mailman/listinfo/haskell-cafe, other place can't work....
02:56:01 <ksf> can I hook into ghc's segfault trap?
02:56:27 <ksf> I don't want to do anything fancy, it doesn't even have to be on the haskell level.
02:56:52 <fizruk> "An attempt was made to subscribe your address to the mailing list haskell-cafe@haskell.org.  You are already subscribed to this mailing list."
02:56:57 <ksf> basically, launch a program with whatever info I can scrape together as parameters.
02:57:10 <fizruk> although I failed to log in, where I can get my password? )
02:58:05 <ksf> I think you can tell mailman to send you a new one
02:58:11 <ivanm> fizruk: you can ask it to send you your password
02:58:14 <HskNoob> Zao: I cabal installed Crypto package, but ghc says: undefined reference to `__stginit_Cryptozm4zi2zi1_DataziDigestziSHA2_' only created .o and .hi files
02:58:20 <ksf> if in doubt, search through your inbox
02:58:24 <ivanm> fizruk: however, you should have received an email asking you to confirm your registration; did you?
02:58:34 <Zao> HskNoob: Use -package or --make when building your code.
02:58:59 <ksf> rejoice! --make will be the default in newer ghc versions
02:58:59 <Zao> -package whateverpackagethatisin, that is.
02:59:05 <fizruk> cite I've posted was in e-mail)
02:59:19 <Zao> ksf: How does one negate that? -C or something?
02:59:26 <ivanm> ksf: why?
02:59:28 <Zao> Explicit -o?
02:59:29 <chrisdone> @hoogle Enum e => Integer -> Maybe a
02:59:29 <chrisdone> @hoogle Enum e => Integer -> a
02:59:29 <lambdabot> Did you mean: Integer -> Maybe a /count=20
02:59:29 <lambdabot> Prelude Just :: a -> Maybe a
02:59:29 <lambdabot> Data.Maybe Just :: a -> Maybe a
02:59:29 <lambdabot> Did you mean: Integer -> a /count=20
02:59:29 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
02:59:31 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
02:59:33 <ksf> -o I think.
02:59:37 <ksf> it's somewhere on trac
02:59:41 <Zao> Sounds like it'll break just about EVERYONE that has ever scripted GHC.
02:59:47 <HskNoob> Zao: :] works
02:59:49 <Zao> Oh well, I guess all the arguments have been had.
02:59:49 <ManateeLazyCat> ivanm: I remember some haskell-cafe administer at here, forgot his nick... :-(
02:59:50 <ksf> the rationale is that --make is the stuff that's used from the command line.
02:59:59 <Zao> Not everyone uses Cabal.
03:00:00 <chrisdone> :t toEnum
03:00:01 <lambdabot> forall a. (Enum a) => Int -> a
03:00:13 <chrisdone> weird that that is a partial function
03:00:14 <fasta> Adapting tools to broken users...
03:00:19 * chrisdone checks Safe
03:00:26 <ivanm> Zao: yeah, that's my first worry about that
03:00:38 <ksf> I think the amount of people who write scripts and don't give explicit -o arguments are virtually non-existant.
03:00:49 <ivanm> chrisdone: a lot of unsafe functions are partial ;-)
03:00:56 <ksf> anyway, it's changing a single make rule.
03:01:04 <Zao> ksf: You're assuming make :D
03:01:13 <ksf> compare that to the time spend typeng --make over and over again.
03:01:17 <chrisdone> ivanm: I mean as oposed to Num a => Int -> Maybe a, buttface
03:01:19 <chrisdone> hmm
03:01:30 <chrisdone> nothing in Safe
03:01:36 <malorie> ski: http://codepad.org/6jDkIRDY
03:01:38 <ivanm> chrisdone: what's the Num in there for?
03:01:43 <ivanm> you mean Enum? :p
03:01:43 <chrisdone> er, Enum
03:01:47 <ksf> well, if you're not using something remotely make-like, you should rewrite your scripts, anyway.
03:01:58 <chrisdone> I'll just write a toEnumMaybe and be done with it
03:01:59 <ivanm> and yes, I figured that's what you meant (adding the Maybe)
03:02:10 <Zao> ksf: Meh, I dislike my tools changing under me, and I don't pretend to know what kind of spectacular deployments there's out there.
03:02:14 <ivanm> but compare that to head, etc.
03:02:16 <Zao> ksf: Build bots, custom build systems, etc.
03:02:26 <Zao> ksf: Heck, I had to roll a rather amusing build scripts to build my DLLs.
03:02:30 <ivanm> Zao: well, let's see how well that behaviour is publicised
03:02:53 <chrisdone> ivanm: well, I don't like head either
03:02:54 <fasta> Zao, heh, you are number 4 that did this. 
03:03:01 <ivanm> however, I would hope that any build tool explicitly lists all required parameters used, even ones that you'd assume were defaults...
03:06:19 <chrisdone> ivanm: (it's like having lookup :: Eq a => a -> [(a,b)] -> b -- "I /know/ it's in the list")
03:06:34 <ivanm> yeah
03:06:39 <fasta> The very notion of a "build tool" should ideally not exist as the Smalltalk people figured out 32 years ago. 
03:06:48 <ivanm> chrisdone: however, head as-is can be handly: I often do "map head . groupBy f"
03:06:57 <ivanm> (usually after a sort)
03:07:11 <ivanm> having to deal with a Maybe would just make that more fiddly
03:07:20 <ksf> smalltalk failed for exactly that reason.
03:07:35 <ksf> you end up with an indiscriminate bunch of bits somewhere in some binary blob.
03:08:09 <chrisdone> ivanm: map head = catMaybes . map listToMaybe. now what?
03:08:13 <fasta> ksf, they failed to convince people that they could do proper version control and proper backups in a human readable format. 
03:08:19 <chrisdone> λ> toEnumMay 3 :: Maybe Char
03:08:19 <chrisdone> Just '\ETX'
03:08:19 <chrisdone> λ> toEnumMay 1 :: Maybe State
03:08:19 <chrisdone> Just Submitted
03:08:22 <chrisdone> excellent
03:08:29 <ivanm> chrisdone: still more fiddly!
03:08:35 <fasta> ksf, now, all these things are possible, but not obvious for a new user. 
03:08:36 <ksf> let's see if the gtk people fixed my bugs yet.
03:09:10 <ksf> ...well...
03:09:16 <ksf> at least it's not compiling anymore.
03:09:25 <ksf> someone killed xmlGetWidget.
03:09:55 <ski> malorie : btw, `(reverse (take ((length xs) - (length (biggestSubPalindrome xs))) xs))' can be written as `reverse (take (length xs - length (biggestSubPalindrome xs)) xs)'
03:10:33 <chrisdone> ivanm: I mean that really calls for a function anyway
03:10:47 <ivanm> true
03:10:57 <chrisdone> firsts :: [[a]] -> [a] or somesuch
03:11:03 <chrisdone> @hoogle [[a]] -> [a]
03:11:04 <lambdabot> Prelude concat :: [[a]] -> [a]
03:11:04 <lambdabot> Data.List concat :: [[a]] -> [a]
03:11:04 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
03:11:04 <ivanm> but I tend to use it at most once or twice per project if that inside some other function
03:11:40 <chrisdone> if that's the case then you can just forget about the existance of head
03:11:43 <ski> malorie : that's sortof an interesting solution, because you defined `leastPalindrome' (a construction giving the least palindrome having the given list as prefix) in terms of it's (more or less, at least) *dual* : `biggestSubPalindrome', a construction that gives the *greatest* palindrome *being* a suffix of the given list
03:12:40 <ksf> wth does ghc try to use the old gtk version, which I hid?
03:13:00 <yitz> map head = concatMap (take 1) if all lists are non-null. but if it's that obviously safe i agree it's not worth it.
03:13:25 <ksf> aaah glade.
03:13:30 <chrisdone> there's probably a function in the Safe library to do this
03:14:16 <chrisdone> ivanm: I found a bug in haddock because someone used `head' because they knew at the time it would be a non-null list. then they used the parent function elsewhere and then the list was empty. it's amazing how often head is the cause of runtime errors, and yet it's a function people claim not to use much. I don't see the point in using it at all
03:14:29 <ivanm> oh, true
03:14:54 <ivanm> but in my case I only use a function like head directly after an inbuilt function with defined semantics such as group
03:15:04 <chrisdone> I wonder if I could hack up hlint to warn about partial function use
03:15:05 <ivanm> which will never return a result containing an empty list
03:15:23 <ivanm> chrisdone: *shrug* should be easy enough, just give it a list of known partial functions
03:15:25 <malorie> ski: the solution is sane, though? 'cause it seems like a quite "procedural" one to me ... (esp. leastPalindrome)
03:15:33 <ski> malorie : .. however, i wonder whether one could define `leastPalindrome' more directly recursively ..
03:15:40 <yitz> chrisdone: when it's hard-wired in a pipeline where the "parent function" can't be called separately, it's visually and trivially safe, and where the alternative is less clear and possibly less efficient
03:16:09 <ski> malorie : i think it is *correct* .. then there's always the question of how elegant it is .. as well as of how efficient it is
03:16:19 <ski> (and those are often related)
03:16:24 <malorie> I see.
03:16:27 <yitz> chrisdone: in that case, using something less clear is itself a possible source of bugs and other future maintenance costs.
03:16:44 <chrisdone> yitz: what's less clear?
03:17:04 <yitz> chrisdone: Maybe-stuff (or Safe library stuff) replacing head
03:17:28 <chrisdone> I don't think making a partial function inpartial has ever caused me future maintenance costs, it's *saved* me costs, yes
03:17:29 <ski> (though, it could be that a directly recursive version could be lazier, i.e. give useful results even if you give it partial or infinite lists, while your solution doesn't work there, since you use `length', which only works for finite lists)
03:17:52 <yitz> chrisdone: how many other people have needed to read your code and understand it?
03:18:13 <ivanm> chrisdone: however, it's quite possible to have other types of "this will never happen!" logic functions wrt input assumptions than what is strictly a partial function
03:18:14 <ski> (i.e. your solution is the same as this hypothetical direct recursive solution, for *fully*defined* lists, at least .. not necessarily for partial lists)
03:18:27 <yitz> chrisdone: i'm agreeing with you that head should be used far less than it is. but it certainly shouldn't be banned.
03:18:27 <fizruk> am i missing something? where i should log in here: http://haskell.org/mailman/listinfo/haskell-cafe ? here I can only subscribe ir log in as admin, as I understand) although, I successfully logged in at http://www.haskell.org/mailman/options/haskell-cafe/crazy.fizruk@gmail.com
03:18:53 <malorie> ski: I don't think an infite list can ever be a palindrome. (except [0,0..] and the like)
03:18:57 <ivanm> e.g. I once assumed that a node-grouping function wouldn't permit singleton groupings; I then changed my mind a few versions later and it took me a while to debug :s
03:19:17 <ivanm> fizruk: where it says "Haskell-Cafe subscribers"
03:19:33 <ivanm> specifically where it says "Unsubscribe or edit options" on the button
03:19:56 <yitz> fizruk: it sounds like you're subscribed.
03:20:14 <chrisdone> yitz: I don't think it "certainly shouldn't be banned". it's not neccessary and it causes bugs all over the show
03:20:56 <fizruk> ivanm: where it says "Haskell-Cafe subscribers" it also says "Enter your admin address and password" =)
03:21:04 <ivanm> below that
03:21:04 <ski> malorie : hm .. possibly you are right that indefinite-length lists doesn't make sense, here
03:21:22 <yitz> chrisdone: it causes bugs when misused. there are legitimate uses that do not cause bugs. it is a fundamental accessor to haskell's most fundamental datatype, and therefore one of its most important functions.
03:21:31 <ksf> runhaskell works, -threaded drops my postGUIAsync stuff, unthreaded fails to do anything sensible, at all.
03:22:10 <chrisdone> yitz: honestly I'm surprised I have to argue this to a haskeller seeing as one of Haskell's main initiatives is to stop bugs
03:22:22 <fizruk> oh, I read only "unsubscribe", not "edit options" =) all the same I get th same page with options)
03:22:59 <ivanm> fizruk: yeah, mailman's a little funky like that
03:23:05 <fizruk> so I can enter, I am a subscriber, but my messages to haskell cafe are automatically rejected =(
03:23:20 <ivanm> fizruk: did you get an email from mailman asking you to confirm your subscription?
03:23:41 <yitz> chrisdone: i'm not disagreeing with your main point. perhaps sometimes to get people to change, you have to go to the opposite extreme. but in real life, banning head completely is an extreme.
03:23:53 <chrisdone> yitz: I don't think it's fundamental or import, pattern matching suffices. but anyway, I take bugs seriously enough to care about this, you don't. ok
03:24:02 <fizruk> i think it was long time ago and I confirmed that)
03:24:16 <ManateeLazyCat> ksf: gtk2hs problem?
03:24:31 <yitz> chrisdone: if head is banned, there will be more bugs than if not, assuming that it is used appropriately and correctly.
03:25:09 <fizruk> ivanm: now when I subscribe one more time I get e-mail that says that I'm already a subscriber
03:25:28 <ivanm> fizruk: well, you should have received an email when you first subscribed asking you to confirm your subscription
03:25:43 <ManateeLazyCat> ksf: If you want multi-thread, -threaded flags not enough, you need use unsafeInitGUIForThreadedRTS replace initGUI 
03:25:45 <fasta> chrisdone, how do you get rid of head? 
03:25:53 <ivanm> fizruk: you would have had to either visit a link or reply to that email
03:26:04 <yitz> fizruk: do you receive mail from haskell-cafe
03:26:07 <yitz> ?
03:26:25 <ivanm> yitz: huh, didn't think about that check ;-)
03:27:09 <ksf> ManateeLazyCat, I'm using it.
03:27:33 * hackagebot free-theorems-webui 0.2 - CGI-based web interface for the free-theorems package.  http://hackage.haskell.org/package/free-theorems-webui-0.2 (MatthiasBartsch)
03:27:35 <ManateeLazyCat> ksf: Best paste your code, then i can check it.
03:27:55 <ksf> I'd have to do a more minimal test-case first
03:28:03 <ManateeLazyCat> ksf: Yes.
03:28:34 <ManateeLazyCat> ksf: You need make sure your gtk+ code running in postGUIAsync, otherwise bad thing will happen.
03:28:44 <ksf> ...which I also do.
03:28:48 <fizruk> ivanm: I'll try to unsubscribe and then re-subscribe...
03:28:53 <ksf> it seems to be dropping events.
03:29:05 * ManateeLazyCat pasted "Gtk Concurrent library." at http://paste2.org/get/969339
03:29:30 <ManateeLazyCat> ksf: Above is my gtk concurrent library that split non-gtk code and gtk code in different threads.
03:29:43 <ivanm> ManateeLazyCat: in case you weren't aware, when doing "/me" it's meant to be an action; just stating that you've pasted a link looks a little odd when you use /me ;-)
03:29:47 <chrisdone> fasta: show me some kind that requires head
03:29:59 <ivanm> you'd be better off telling whoever it's aimed at directly
03:30:10 <ivanm> (hackagebot just did that to help stand out is my guess)
03:30:43 <yitz> fizruk: it has happened in the past that someone's email got wrongly flagged and they could not send to the list. i'll ask the haskell.org admins to check.
03:30:43 <ManateeLazyCat> ivanm: Hehe, it's my paste2.el send IRC message automatically... :)
03:30:52 <ivanm> ahhh
03:31:03 <chrisdone> yitz: there will be more bugs? what do you base that on? I can do a google search for "Prelude.head: empty list" and bring up thousands of resutls. what data do you have?
03:31:15 <yitz> chrisdone: those are misuses.
03:31:42 <ManateeLazyCat> ivanm: When i paste some code and press "send" command, it's will paste to paste2.org first, after receive message from paste2.org, it will generate IRC message and send to server.
03:31:46 <fizruk> yitz: i have just re-subscribed, i'll try to send post again
03:31:59 <ManateeLazyCat> ivanm: So it's not me, it's my elisp code..... even i wrote it. :)
03:32:44 <yitz> chrisdone: i base my data on years of experience participating in software teams, both as leader and participant. less clear code, even a little less clear, leads to bugs - often serious ones.
03:32:58 <chrisdone> yitz: show me a way in which not using head makes code less clear
03:33:19 <yitz> chrisdone: again, i am not advocating using head, it is far over-used right now. i'm just saying that banning it totally is an extreme.
03:33:20 <chrisdone> got any hard evidence other than "I'm a big developer with loads of experience"?
03:33:23 * ManateeLazyCat Dinner time, leave message to me....
03:34:09 <chrisdone> anyhoo. I'm not using it, that's fine. you can still use it, I'll just look forward to working with your libraries less
03:34:34 <ivanm> ManateeLazyCat: heh
03:34:45 <yitz> chrisdone: you are claiming that "concatMap (take 1)" is more clear than "map head"?
03:35:31 <yitz> chrisdone: or more efficient?
03:37:55 <ksf> er wait no I'm an idiot.
03:38:07 <ksf> or not?
03:39:14 <chrisdone> yitz: no, I'm claiming that `firsts' is clearer and more efficient
03:39:25 <Twey> It would be nice if concatMap = foldl mappend . fmap
03:39:39 <chrisdone> Twey: indeed
03:39:41 <Twey> concatMap listToMaybe
03:39:53 <chrisdone> maybe Data.Foldable has a concatmap?
03:39:57 <Twey> Er, (foldl mappend .) . fmap, maybe
03:40:17 <Twey> Er
03:40:21 <Twey> I hate mornings
03:40:28 <chrisdone> foldMap :: Monoid m => (a -> m) -> t a -> m
03:40:31 <chrisdone> noice
03:40:51 <Twey> Hmm
03:40:53 <chrisdone> I like everything in Data.Foldable and Data.Traversable
03:41:10 <Twey> Is that (Traversible t)?
03:41:18 <Twey> Traversable?
03:41:39 <chrisdone> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Traversable.html
03:41:45 <Philonous> Twey: Yes, it's a member of the class
03:42:14 <Philonous> Oh, or not
03:42:31 <chrisdone> Twey: (yeah, for some reason it's spelled 'traversable' and not 'traversible', like 'reversible', go English!)
03:43:12 <Twey> Hrmph
03:43:42 <yitz> chrisdone: "firsts" is fine if you assume that everyone reading the code will be familiar with it. right now that is unlikely. i would still use it though, in many or most cases, because it is safer. maybe even 99% of the cases. head is still more basic and shouldn't be banned or removed. (also, i doubt it's "more efficient").
03:43:55 <fizruk> looks strange, but after re-subscribing letter was sent successfully =)
03:44:26 * wli is a fan of either headlessness or nonempty list structures.
03:44:31 <ivanm> fizruk: might have been caught by the spam filter...
03:44:43 <ManateeLazyCat> ksf: I don't understand "dropping events"? Maybe you can detail.
03:44:44 <Twey> :t firsts
03:44:45 <lambdabot> Not in scope: `firsts'
03:44:53 <ivanm> wli: why?
03:44:55 <Twey> Where's that defined?
03:45:06 <ivanm> I've never seen such a definition...
03:45:24 <ManateeLazyCat> ksf: I have develop many gtk2hs multi-threads code, works fine....
03:45:29 <ivanm> hayoo doesn't seem to know it either
03:45:32 <chrisdone> wli: I was thinking you could just have data List a = Single a | Cons a (List a) and then have Maybe (List a).
03:45:32 <fizruk> ivanm: post remained the same, and I haven't posted before that, but maybe... =)
03:46:08 <ksf> yes, and mine works fine, too, now that I realised the reason it wasn't working was because it was so messed up that I couldn't see the bugs for the uglyness.
03:46:22 <wli> ivanm: Expressing invariants with data structures etc.
03:46:26 <ManateeLazyCat> ksf: Fix now?
03:46:40 <ksf> yep
03:46:45 <ManateeLazyCat> ksf: Great. :)
03:49:23 <fasta> chrisdone, any case in which you assume that a list you will get will be non-empty and you want to retrieve the first element. I think head is fine, if you use CPP code to catch it when it doesn't work. 
03:52:53 <yitz> wli: headlessness is just pushing the problem further down the list. you really just need to use safe functions.
03:54:08 * dobblego waggles http://hackage.haskell.org/package/NonEmptyList
03:54:12 <ivanm> gah, I keep thinking I've focused on firefox and try to close a tab there...
03:55:40 <wli> yitz: listToMaybe etc.
03:57:42 <HskNoob> q: In   hashes start end = [sha256Ascii show i | i <- [start..end]]  the show i doesnt convert to String but a -> String . type casting using :: String doesnt work either
03:57:53 * yitz smiles and nods
03:58:19 <Zao> HskNoob: You might have forgotten to provide the last argument.
03:58:21 <ivanm> what is sha256ascii ?
03:58:47 <ivanm> the expression bit in your list comprehension looks wrong
03:58:51 <HskNoob> ivanm: sha256Ascii :: String -> Hash256
03:58:52 <yitz> HskNoob: put show i in parens?
03:58:54 <ivanm> do you want: sha256ascii $ show i ?
03:58:59 <ivanm> yitz: or a $
03:59:05 <HskNoob> let's try that
03:59:06 <yitz> indeed
03:59:14 <Zao> I'm ashamed I didn't catch this.
03:59:21 <Zao> I blame not having glasses on <_
04:00:32 <ivanm> Zao: well, I had to read through HskNoob's message a few times to find the code... ;-)
04:01:01 <HskNoob> ivanm: sry :)
04:03:32 <ski> HskNoob : when you use `foo :: String', in an expression, that isn't known as "type casting", but as "type ascription" -- you're not changing the type of `foo' in any way, you're just claiming what you want it to be (and if it couldn't already have been that, you'll get a type error)
04:04:17 * ski would write `sha256Ascii (show i)' rather than `sha256Ascii $ show i' ..
04:04:36 <Twey> Why?
04:04:45 <ski> it's prettier ?
04:05:01 <Twey> It's longer and requires keeping track of an extra level of brackets…
04:05:14 <Twey> *ponder*
04:05:19 <Twey> Well, not longer, I guess
04:05:20 <luite> why not  sha256ascii . show $ i
04:05:20 <ski> i mostly use `$' when i would otherwise have to have several closing brackets at the end
04:05:24 <Twey> Counting whitespace
04:05:36 <Twey> luite: Because that's just pointless :þ
04:05:41 <ivanm> well, I would write map (sha256ascii . show) [start .. stop] :p
04:05:52 <Twey> Yeah
04:06:01 <ski> (especially when the nested things could be thought of as "commands in a sequence", where i might want to add or remove "commands" later)
04:06:03 <ivanm> and thus, your argument is pointless!
04:06:11 <Twey> I'd probably go with ‘sha256ascii . show `map` [start .. stop]
04:06:12 <Twey> ’
04:06:38 <luite> hmm, that wouldn't work?
04:06:56 <luite> oh wait
04:06:57 <luite> sorry
04:07:01 <Twey> > (: []) . show `map` [1 .. 5]
04:07:02 <lambdabot>   Precedence parsing error
04:07:02 <lambdabot>      cannot mix `L..' [infixr 9] and `GHC.Base.map...
04:07:09 <ski> @type \f start stop -> f . show `map` [start .. stop]
04:07:09 <lambdabot>     Precedence parsing error
04:07:09 <lambdabot>         cannot mix `.' [infixr 9] and `map' [infixl 9] in the same infix expression
04:07:10 <Twey> map has a special precedence?
04:07:17 <ski> no
04:07:23 <Twey> I'm confused
04:07:25 <ivanm> Twey: sha256ascii was String -> blah
04:07:33 <ivanm> Twey: it's the .
04:07:35 <ski> @type \map f start stop -> f . show `map` [start .. stop]
04:07:35 <lambdabot>     Precedence parsing error
04:07:36 <lambdabot>         cannot mix `.' [infixr 9] and `map' [infixl 9] in the same infix expression
04:07:40 <ivanm> > (:[]) $ show `map` [1..5]
04:07:41 <lambdabot>   [["1","2","3","4","5"]]
04:07:50 <Twey> I thought ‘.’ bound more tightly than anything else, except function application
04:07:52 <ski> `infixl 9' is the default fixity
04:08:09 <Twey> Certainly more tightly than unspecified backtick-operators, which have a pretty low precedence
04:08:39 <ski> @type \frob f start stop -> f . show `frob` [start .. stop]
04:08:40 <lambdabot>     Precedence parsing error
04:08:40 <lambdabot>         cannot mix `.' [infixr 9] and `frob' [infixl 9] in the same infix expression
04:08:46 <HskNoob> Hmmz, Couldn't match `String` against inferred type `Hash256'. Now using code "hashes start end = [sha256Ascii(show i) | i <- [start..], i < end]"
04:10:54 <ski> possibly you're calling `hashes' in a context expecting a `[String]' result ?
04:11:46 <HskNoob> ski: The definition is "hashes :: Integer -> Integer -> [String]" in order to get a list of possible hashes between two Integers
04:12:21 <ski> <HskNoob> ivanm: sha256Ascii :: String -> Hash256
04:12:28 <HskNoob> ski: I see my assumption about the returning data is wrongish..
04:12:53 <ski> so, your `hashes' code is returning a list of `Hash256'es, but your type signature claims it should return a list of `String's
04:12:56 <ski> that doesn't match
04:14:18 <HskNoob> ski: I was printing them before using: "print$" so I thought it was String.. so I have to convert the output from Hash256 to String also
04:15:07 <ski> (btw, if you have a `String' that you want to output, you more often wants to use `putStr' (or `putStrLn'), rather than `print')
04:15:30 <ski> why do you need to convert from `Hash256' to `String' ?
04:16:36 <HskNoob> just wanting to print these hashes to see what's going on ( noob here )
04:17:52 <ski> HskNoob : well, as long as `Hash256' is in class `256', you can use `print' of `Hash256'es directly
04:17:55 <ski> @type print
04:17:56 <lambdabot> forall a. (Show a) => a -> IO ()
04:18:11 <ski> `print' can print elements of any type `a', which is in class `Show'
04:18:26 <ski> (er.. is in class `Show', not in class `256' :)
04:18:29 <HskNoob> I'll keep it Hash256 then, it does compile now :]
04:35:31 <Mitar> i want to put different data types into a Chan, should I use http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Dynamic.html#t%3ADynamic? or should I do some custom data class I will make all those data types an instance of? but I am still not sure if I can easily abstract all those data types i would like to put into; but I also do not like the Dynamic idea as I would like to limit somewhat what can be put into the Chan at compile time
04:36:34 <ivanm> if you have a small number of data types, then do a sum type
04:37:31 <ksf> are there any cool gtk2hs wrappers that let me autogenerate guis from datatypes?
04:37:46 <ivanm> not that I know of
04:37:49 <earthy> mitar: if you want an extensible number of data types, but controlled by you, use a custom class.
04:37:50 <ivanm> how would that even work?
04:38:07 <Mitar> i would like that it is extendable
04:38:15 <Mitar> so that other people will be able to add new data types
04:38:17 <ksf> well, if you have a list of Foos where Foo has a String and integer field, make a listview.
04:38:33 <earthy> ivanm: there's the generic gui stuff for clean...
04:38:40 <ksf> working with gtk's treeview is a pita.
04:38:45 <earthy> mitar: well, then a class is the right idea
04:39:14 <chrisdone> Mitar: then you can do that with a type class. class Channelable a where ... and for people to add a data type to the chan they implement the class and robert's their father's brother
04:39:47 <ksf> another thing i'd like to have is an fclabels which can access non-pure data structures
04:39:52 <earthy> ivanm, ksf: look at generic graphical editor components and see if you can translate the ideas into haskell :)
04:40:21 <ksf> well, or I could change my stuff to pure and just put it in a single tvar
04:40:53 <ksf> ...which, otoh, would then clash nicely with gtk because giving incremental updates strictly would be... tricky.
04:41:20 <Mitar> hmm, but then I have to find a way to abstract all possible things people would like to do over different types they would like to push into the chan
04:41:42 <ksf> there's wxgeneric
04:42:16 <earthy> mitar: no. you only need to know how to make it into something that'll go through the chan, and how to turn it back
04:42:26 <chrisdone> indeed
04:42:45 <Mitar> isn't that what Dynamic is for?
04:43:14 <ksf> dynamic is a hack.
04:43:16 <earthy> mitar: you just stated that you'd like to restrict that...
04:43:18 <ksf> real coders use hlist
04:43:35 <chrisdone> Dynamic depends on a Typeable instance
04:43:37 <Mitar> i also do not like that idea and yes, i would like to restrict
04:43:41 <earthy> plus, dynamic does not work over the wire
04:44:04 <Mitar> yes, it does not have Read
04:44:07 <chrisdone> over the wire, what is this, the 70s? :p
04:44:09 <ksf> Mitar, basically, wrap all the different messages you want to be able to send into a huuuuge, nested Either.
04:44:34 <ksf> the rest, then, is syntactic and semantic sugar.
04:44:49 <earthy> chrisdone, hey, don't knock those, I was born then! :P
04:45:23 <earthy> (plus, I'd like to see you do gigabit speeds without wires :))
04:45:34 <Mitar> fiber?
04:45:54 <earthy> mitar: that's glass wires :P
04:46:02 <Mitar> if you say so ;-)
04:46:13 <earthy> (true, that's stretching the word a bit, but still)
04:46:47 <Mitar> in my dictionary it is defined as "metal drawn out into the form of a thin flexible thread or rod."
04:47:03 <Mitar> but why would we believe dictionary ;-)
04:47:17 <earthy> :)
04:47:29 <Mitar> everybody can define a dictionary this days
04:47:39 <Mitar> even python has one ;-)
04:48:06 <Mitar> s/has one/can/
04:48:55 <alpounet> where can i find a logic and operator/function ?
04:49:16 <alpounet> oh, Data.Bits
04:50:54 <Zao> alpounet: Note that it's bitwise, not logical.
04:51:10 <Twey> alpounet: A logical and operator would be (&&), and it's in the Prelude (also Data.Bool).
04:51:16 <earthy> Data.Bool otherwise indeed.
05:07:37 <ksf> I see, wxwidget's list and tree stuff sucks even more than gtk's
05:11:59 <ksf> is there any tk at all than doesn't require the children of a tree node to have the same column layout as the node itself?
05:12:18 <ksf> I'd even be content with a single, expandable field for a simple, flat, list.
05:12:41 <ksf> though what I actually want is the perfect interface for an IxSet.
05:13:37 <ksf> I also don't know why tk's don't come with data type abstractions and methods for users to define their own views.
05:14:21 <ksf> it's the same, old, button radiobutton scrollbar list thing over and over again.
05:15:10 <eevar> i want to profile an stm app, and get the error; could not find module 'Control.Concurrent.STM', perhaps you haven't installed the profiling libraries for 'stm-...'
05:15:33 <eevar> i do have library-profiling set to true, and tried cabal install --reinstall stm, which seems to work
05:15:51 <eevar> any suggestions?
05:16:12 <luite> do you see it actually compiling the library twice?
05:16:27 <fryguybob> ksf: The only one I'm aware of is WPF and I don't know of any haskell bindings to that or what the state of Mono is on that.
05:16:41 <ksf> wpf?
05:16:55 <eevar> luite: nope, only seems to compile once
05:17:04 <fryguybob> ksf: Windows Presentation Foundation, .NET 3.5 and silverlight.
05:17:11 <ksf> *shudder*
05:17:38 <luite> eevar: make sure that library-profiling is set correctly then, I think those lines are commented out in the default configuration file
05:17:43 <luite> -- means comment
05:17:49 <ksf> http://eaglemode.sourceforge.net/   bindings would be cool.
05:18:45 <eevar> luite: that was it. thanks
05:22:49 <co_dh> :t fix
05:22:50 <lambdabot> forall a. (a -> a) -> a
05:25:03 <Nibble> :t fix error
05:25:04 <lambdabot> [Char]
05:25:34 <baaba> > fix error
05:25:35 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:26:01 <Axman6> > length (fix error)
05:26:02 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
05:26:09 <Axman6> > take 10 (fix error)
05:26:10 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:33:17 * hackagebot bits-atomic 0.1.1 - Atomic bit operations on memory locations  for low-level synchronization  http://hackage.haskell.org/package/bits-atomic-0.1.1 (GabrielWicke)
05:40:51 <ksf_> another thing I don't understand is why all those tks are so damn code-driven.
05:41:03 <Nibble> ksf_: tks?
05:41:12 <ksf_> plural of tk
05:41:42 <Nibble> what is tk?
05:41:52 <ksf_> the one species of library which only has members that suck.
05:41:55 <Zao> "toolkit"
05:41:55 <ksf_> widget toolkits
05:42:36 <fryguybob> ksf_: WPF is mostly declarative...
05:43:07 <Entroacceptor> ksf_: how would your favourite toolkit look like?
05:43:27 <ksf_> data-driven, microlithic.
05:44:21 <Zao> XAML is language agnostic, which is nice.
05:44:36 <ksf_> so is xul
05:45:17 <ksf_> there's also a w3c-thing based basically on xul.
05:45:22 <bremner> xul is exactly the evil prehistoric god it sounds like
05:45:47 <ksf_> ...when I read "microsoft" I read "copy, clone, embrace + extinguish"
05:46:11 <ksf_> oracle might have finally shown its evil face, but that doesn't make microsoft any better.
05:47:00 <Jafet> @remember bremner XUL is exactly the evil historic god it sounds like.
05:47:00 <lambdabot> Done.
05:47:07 <Jafet> Argh
05:47:10 <Jafet> @forget bremner XUL is exactly the evil historic god it sounds like.
05:47:11 <lambdabot> Done.
05:47:15 <Jafet> @remember bremner XUL is exactly the evil prehistoric god it sounds like.
05:47:15 <lambdabot> Good to know.
05:50:40 <ksf> haskell tks, otoh, stand and fall with the availability of a sane record system.
05:51:11 <ksf> anything short of hlist just isn't powerful enough, and hlist and polymorphism doesn't blend well.
05:53:51 <ksf> wait I didn't yet try hlist and not support method overloading
05:56:44 <chrisdone> hehe, does ghci segfault regularly for anyone else after a few hours of reloading over and over?
05:57:28 <Nibble> chrisdone: I haven't noticed it
05:57:46 <sioraiocht> chrisdone: Never happened to me, even after a full day of such activity.
06:00:14 <writer> Deesl: nice surprise :)
06:00:24 <Deesl> hmm
06:01:19 <writer> Deesl: so you started Haskell :)
06:01:29 <Deesl> I guess so...
06:01:35 <Deesl> would you like me not to start it?
06:02:05 <Nibble> Deesl: avoid newcommers
06:02:26 <Deesl> Nibble: ?
06:02:29 <writer> Deesl: why would I think so. welcome :)
06:02:37 <Deesl> fair enough writer
06:02:41 <ivanm> writer: Deesl started haskell? I don't recall his name being on the Haskell 98 report...
06:02:42 <ivanm> ;-)
06:02:55 <writer> lol :D
06:03:05 <Deesl> ivanm: hmm. I would say thats a nice welcome :)
06:03:06 <Saizan> you should check earlier reports
06:03:23 <ivanm> Saizan: doh, forgot about them
06:04:24 * hackagebot QuickCheck 2.1.2 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.1.2 (NickSmallbone)
06:10:04 <ManateeLazyCat> Why #test need people register to join?
06:11:07 <ivanm> hmmm?
06:11:43 <Twey> ManateeLazyCat: If you're creating a bot, use ##bots.
06:12:00 <ManateeLazyCat> ivanm: I'm testing my irc client, my irc bot can't join #test.
06:12:28 <ivanm> hey edon 
06:12:53 <edwardk> =)
06:13:41 <ivanm> bah, that should have been edwardk 
06:13:41 <ManateeLazyCat> Twey: Cool, thanks!
06:13:48 <ivanm> stupid tab-completion not being smart enough :@
06:13:53 * ManateeLazyCat Bla bla in ##bots.... :)
06:14:06 <ivanm> edwardk: did you get my message via google chat the other day?
06:14:36 <edwardk> ivanm: i'm going to guess not ;)
06:15:12 <edwardk> I've ben largely incommunicado the last few days
06:15:17 <edwardk> er been even
06:15:24 <ivanm> edwardk: OK, so in container-classes I'm figuring that if I'm going to re-implement all those type classes from base anyway, I might as well get the hierarchy mentioned in typeclassopedia, etc. done officially
06:15:48 <ivanm> now, typeclassopedia talks about pointed, etc. from your category-extras; should I include that as well or just go with Functor -> Applicative -> Monad?
06:16:38 <edwardk> well, i suppose i could finish packaging up 'functors' which is the refactored version of just the functors, functor fixed points, etc. from category extras and would contain Pointed and be fairly small
06:16:48 * ManateeLazyCat I found haskell irc-rounter much faster than erc, almost 10 ~ 20 seconds.
06:17:10 <ivanm> edwardk: I have to reimplement to get Suitable, etc. in as base constraints
06:17:28 <applicative> ivanm, what is this container-classes, sounds good....
06:17:32 <ivanm> one thing though: IIUC, a Set instance for Applicative wont' make sense (since a -> b isn't in Ord) but a Monad instance would...
06:17:33 <edwardk> oh yeah. forgot you were going crazy with the restricted stuff ;)
06:17:52 <ivanm> applicative: I started yet another attempt at having generic classes for different containers; I'm re-writing it now
06:17:54 <edwardk> Set instance for Applicative?
06:17:57 <ivanm> (since my previous attempt failed)
06:18:02 <edwardk> didn't parse that
06:18:18 <ivanm> edwardk: well, if Applicative => Monad, then for Set to be a Monad it needs to be in Applicative
06:18:30 <ivanm> but Applicative has "f (a -> b) -> f a -> f b"
06:18:44 <ivanm> and so a Set instance for Applicative would only make sense if "a -> b" is in Ord
06:18:47 <ivanm> (which it isn't)
06:18:54 <ivanm> however, a Monad instance for Set is possible
06:19:03 <edwardk> yes, this is because Applicative assumes the category over which you are working has exponentials
06:19:06 <ivanm> (I think it behaves like the list monad does)
06:19:19 * ManateeLazyCat When join too many channels, ERC off-line and reconnect, but haskell lightlight thread damn fast.
06:19:23 <edwardk> this holds in Hask, but not all useful categories over which you may want to form a monad.
06:20:13 <ivanm> edwardk: so what are you saying I should do? :p
06:20:15 <edwardk> A less 'needy' version of applicative is to define it as 'Monoidal' instead per the original applicative paper
06:20:37 <edwardk> i'm saying that there is a reason why applicative doesn't er... apply there ;)
06:21:00 <Colours> hi! can someone help me with this compilation error? http://pastebin.com/QrF9NCmT is the code in question and http://pastebin.com/WnfEvppM is the error ~
06:21:17 <applicative> would Set be 'Monoidal'?
06:22:20 <edwardk> applicative: for a 'restricted monoidal' in the sense that it is a 'restricted monad', yes.
06:22:30 <mmmulani> is there a way to list the functions in a C header file that hsc will find?
06:22:43 <mmmulani> I'm having trouble locating the file that is declared in an #include
06:23:22 <chrisdone> sioraiocht: must be todo with the libraries I have loaded
06:23:29 <sioraiocht> which ones?
06:25:53 <ivanm> edwardk: OK, but my goal was to try and copy the base classes as much as possible (in terms of which ones are already there; I might for example force return = pure)
06:26:20 <edwardk> there is no way to enforce return = pure ;)
06:26:36 <edwardk> unless you inherit monad from applicative
06:26:45 <edwardk> and then you toss out compatibility with EVERYTHING
06:27:01 <ivanm> yup
06:27:18 <edwardk> which is a great way to shrink your audience to 1 ;)
06:27:20 <Twey> Compatibility is overrated
06:27:22 <ivanm> edwardk: it's going to be incompatible anyway (since my Functor will technically be different from base's Functor)
06:27:43 <Twey> *Functor* is different?  How?
06:27:59 <ivanm> http://dpaste.com/hold/235183/
06:28:18 <ivanm> (the definition is pretty much copied from Heffalump's RFunctor class)
06:28:32 <edwardk> so why isn't this just built on heffalump's?
06:28:42 <Twey> Hm
06:29:17 <ivanm> edwardk: Suitable is taken from Heffalump's; but I didn't want to put an `R' in front of every class name
06:29:32 <ivanm> (and originally I had an extra constraint in the Functor class which I removed because it didn't work)
06:29:43 <Heffalump> is that the only reason? We could discuss it before rmonad reaches 1.0 :-)
06:30:00 <edwardk> ivanm: what a nice color of bikeshed you have there ;)
06:30:01 <ivanm> Heffalump: tbh, I was kinda hoping to subsume rmonad... ;-)
06:30:15 <ivanm> edwardk: why thank you, for that old-fashioned compliment!
06:30:29 <ksf> has anyone ever tried doing anything with oohaskell, lately?
06:30:31 <ivanm> (originally I wanted to keep the names the same as in base to make it "drop-in")
06:30:46 <ivanm> Heffalump: btw, I just managed to write a Set instance for Applicative (well, a Suitable-version of Applicative)!
06:30:52 <Heffalump> how?
06:30:58 <ivanm> I cheated and used the list instance for the actual RHS
06:31:03 <ksf> I heard that back when it came out is wasn't useable in the real world because it would grind the type system to a halt, but I also think there were some fixes.
06:31:05 <ivanm> but I used your myfoo trick
06:31:11 <edwardk> ksf: oohaskell exists as a sort of pathological exercise in proving what is possible. not of proving what is practical or usable ;)
06:31:13 <ivanm> it typechecks, anyway
06:31:16 <Heffalump> ah, right. What myfoo trick? I forget quickly :-)
06:31:51 <ksf> well, I can certainly make HList useable+practical for certain restricted things.
06:32:02 <ivanm> Heffalump: http://pastebin.com/Lf8XYZZq
06:32:20 <ivanm> it typechecks, but you wouldn't actually be able to use it
06:32:22 <Heffalump> oh, the local mymap definition.
06:32:26 <ksf> and I'm quite happy to do so because it beats the current record system with or without fclabels pants-down.
06:32:28 <Heffalump> yeah, that was kind of annoying to have to use
06:32:30 <ivanm> since there's no Ord instance for a -> b
06:32:43 <ivanm> Heffalump: agreed; maybe the Constraint instances should be shortened? :p
06:32:51 <Heffalump> ivanm: that seems a little...uselesss..
06:32:59 <Heffalump> ivanm: which ones?
06:33:08 <ivanm> SetConstraints, etc.
06:33:22 <ivanm> Heffalump: well, I was thinking that if I managed to do that, then maybe it would make sense to have Applicative => Monad
06:33:23 <Heffalump> to what?
06:33:31 <ivanm> SetConsts ? *shrug*
06:33:40 <Heffalump> ivanm: but you won't be able to share the representation and have an efficient Monad
06:34:05 <edwardk> ivanm: ugh. random abbreviations are an annoyance for every subsequent user of the library, they have to know what particular shortening you chose
06:34:27 <ManateeLazyCat> ksf: HList is recursive tuple essentially.
06:35:07 <ivanm> edwardk: well, since Haddock doens't expose type family instances, the point is kinda moot
06:35:14 <ksf> ...and a lot of type hackery.
06:35:15 <ivanm> besides, if you make it consistent...
06:35:24 <ivanm> Heffalump: what do you mean by share the representation?
06:35:46 <ksf> it all stands and falls with TypeEq/TypeCast, which could definitely use compiler-level implementations.
06:35:47 <Heffalump> ivanm: you won't be able to implement a Set with a decent representation that has a Monad instance
06:36:07 <ivanm> edwardk: so you're saying I _shouldn't_ have even Applicative => Monad? let alone copy Pointed from category-extras and have Functor => Pointed => Applicative => Monad ?
06:36:33 <ivanm> Heffalump: how would having an Applicative instance like that make it any different than the RMonad instance you have for Set?
06:37:06 <Heffalump> oh, I think I misunderstood.
06:37:13 <Heffalump> never mind
06:37:34 <edwardk> well, what i'm saying is that Applicative i not implied by Monad if your category doesn't have exponentials representing all of its arrows. the equivalence between Applicative and Monoidal requires that. If you allow restrictions, Applicative is no longer the right abstraction
06:38:02 <ivanm> oh :(
06:38:04 <ivanm> *sigh*
06:38:28 <ivanm> dammit, the only reason I was even thinking of having Applicative, etc. in there was because I figured I might as well if I was going to re-implement Foldable, etc.
06:38:43 <ivanm> since that's what some comments I had from the first release of container-classes said I should do :s
06:38:55 * ivanm still cna't work out what to call the kind * version of Foldable nor its methods
06:39:02 <edwardk> to get there you could make an RApplicative (sans R if you must) that provides both the monoidal and applicative members, with a Suitable (a -> b) -- constraint in the <*> type signature
06:39:24 <ksf> ivanm, whatever you do, factor out fail into its own class.
06:39:47 * Heffalump deliberately made rmonad mirror the standard classes
06:39:51 <edwardk> ivanm: personally it sounds like you're taking on something huge that won't be able to work with anything else
06:39:55 <ivanm> ksf: I want the functionality of the classes to be the same as currently is, so that for the most part code written as-is would still work
06:40:09 <ivanm> ksf: besides, don't you need fail for do-notation to work?
06:40:14 <edwardk> and each of these individual tweaks is something that will require constant thought on the behalf of the user
06:40:21 <ivanm> *sigh*
06:40:26 <ivanm> you're probably right...
06:40:40 <ksf> ivanm, you need it for patterns that can fail.
06:40:47 <ksf> there's no reason to have it in every monad.
06:41:12 <ivanm> ksf: so, if I was going to do the whole "do-notation uses the >>= currently in scope" trick, doesn't that require fail to be in scope?
06:41:23 <ivanm> edwardk: so what do you recommend? that I give up this foolish endeavour?
06:41:26 <ksf> only if you do pattern matches I think.
06:41:39 <ivanm> but who knows what users would do?
06:41:53 <edwardk> ivanm: if you're passionate about it. go for it, just keep in mind that you have a fairly limited audience
06:41:58 <ksf> "no instance for MonadFail arising from an incomplete pattern match at..."
06:42:03 <Heffalump> ksf: would having fail in a separate class return us to the H1.4 (or whatever it was) behaviour where the type changes if you have an incomplete match?
06:42:07 <ksf> at least that's what I'd like to see.
06:42:11 <ski> ivanm : an alternative `Applicative i' operation would be `forall a b. i a -> i b -> i (a,b)'
06:42:15 <edwardk> Heffalump: yes
06:42:22 <Heffalump> rmonad already has a pretty limited audience, and it's quite minimalist :-)
06:42:34 <ivanm> ksf: how would I implement that though when using the do-notation hack?
06:42:42 <ksf> dunno.
06:42:44 <edwardk> Heffalump: i earlier pointed out his audience size was likely 1 ;)
06:42:54 <ivanm> Heffalump: well, the reverse hackage mirror shows no users ;-)
06:43:00 <edwardk> less if he can't bring himself to use it ;)
06:43:03 <ksf> maybe just try, it might just work.
06:43:04 <Starfire> Is 'do-notation hack' the same as NoImplicitPrelude?
06:43:06 <ivanm> my goal is to use container-classes for the new graph stuff
06:43:09 <Heffalump> Starfire: yes
06:43:12 <edwardk> ivanm: i've used it, just not in anything i've pushed to hackage
06:43:29 <ksf> I'd be surprised if ghc checks that fail and bind are in one class.
06:43:39 <edwardk> ksf: it does not
06:44:03 <ivanm> edwardk: tbh, I really don't care about this; I just figured that since I was going to be re-implementing _some_ classes I might as well go the whole hog, and since everyone keeps whining about the Functor => Applicative => Monad mess, I might as well see if I could fix that as well
06:45:24 <edwardk> ivanm: they complain because it is hard, because all of these issues come up. The difficulties here are intrinsic. It isn't just random whining ;)
06:45:34 <ivanm> edwardk: let's say I was stupid enough to actually go and re-implement these classes; do you think that I should 1) put in the Functor => Applicative => Monad hierarchy, and if so 2) Should I also go and grab Pointed, etc. from category-extras to flesh out the full typeclassopedia graph ;-)
06:45:44 <ivanm> edwardk: oh...
06:46:05 <ivanm> what are the issues exactly?
06:46:32 <ivanm> ski: would that version of Applicative be basically like a zipping class?
06:47:00 <edwardk> here is where we loop back to previous conversations about how type families are not a panacea, given that you now have a more specific dictionary, and can't write certain polymorphically recursive functions, etc.
06:47:10 <Heffalump> FWIW I gave up on RApplicative because of the a->b issue - for more complicated combinators you end up with multiple possible constraints.
06:47:38 <Heffalump> I think the only sane definition would demand Suitable f a, Suitable f b => Suitable f (a -> b) for f to be an RApplicative
06:47:49 <ivanm> Heffalump: well, whilst ugly the myfoo hack seems to work
06:48:06 <ivanm> edwardk: which previous conversation? :p
06:48:15 <Heffalump> how would it help with RApplicative?
06:48:20 * ivanm has had so many theory-full conversations with edwardk it's hard to keep track
06:48:47 <ivanm> Heffalump: in that it lets you define things like Applicative for Set, whether it makes sense or not ;-)
06:49:24 <Saizan> Functor => Applicative => Monad is a mess only for restricted ones :)
06:49:57 <ivanm> heh
06:50:03 <ivanm> yeah, it appears so :s
06:50:44 <Saizan> Heffalump: i guess one could forget about (<*>) and stick to uncurried functions
06:51:36 <ivanm> Saizan: yet isn't <*> the whole point of applicative?
06:51:41 <ivanm> you know, you're _applying_ it?
06:52:34 <edwardk> Heffalump: well, what the technically correct nswer would be is to define something more like class RFunctor i => RMonoidal i where unit :: Suitable a => a -> i a; liftA2 :: (Suitable a, Suitable b, Suitable c) => (a -> b -> c) -> i a -> i b -> i c; (<*>) :: (Suitable (a -> b), Suitable a, Suitable b) => i (a -> b) -> i a -> i b; with a default definition of (<*>) in terms of liftA2
06:52:35 <Saizan> f a -> f b -> f (a,b) (+ Suitable constraints) and fmap would work too
06:52:46 <edwardk> then liftA2 can be used even if (->) isn't suitable
06:52:52 <ivanm> edwardk: unit = pure = return?
06:52:59 <edwardk> ivanm: yes
06:53:24 <ivanm> edwardk: so what are you saying I should do?
06:53:31 <edwardk> ti'm saying i gotta run
06:53:32 <edwardk> ;)
06:53:38 <ivanm> cheat!
06:53:42 <ski> ivanm : if you call that `(<&>)', then `ia <&> ib = fmap (,) ia <*> ib' and `iab <*> ia = fmap (uncurry ($)) (iab <&> ia)'
06:54:07 <ivanm> *nod*
06:54:17 <ski> ivanm : i was thinking maybe `(<&>)' would be better, if you want to have e.g. `Set'
06:54:37 <ivanm> @ask edwardk so, is it possible for me to get a straight answer out of you? :p
06:54:38 <lambdabot> Consider it noted.
06:54:43 <ivanm> ski: hmmm...
06:55:02 * ivanm should probably actually look at Applicative before working out if and how he should re-implement it
06:55:06 <ski> (i haven't thought deeply about this .. just a random idea)
06:55:20 <Saizan> liftA2 is probably a better primitive, to avoid tuple creation
06:55:37 <ski> ivanm : and yes, i suppose you could think of it as a kind of zipping
06:55:43 <ski> Saizan : point
06:56:13 <Saizan> (and more importantly, the whole intermediate f (a,b))
06:56:20 <ski> (i suppose one could have both .. like `Traversable' has both `mapA' and `traverse')
06:56:45 <ivanm> Saizan: yeah, because then something like a bytestring with a phantom type param would still make sense for liftA2 (as long as you stuck for Word8 for a, b and c :p )
06:56:47 <ski> @type Data.Traversable.mapA
06:56:48 <lambdabot> Not in scope: `Data.Traversable.mapA'
06:56:59 <ski> (.. hm, or what was it called ?)
06:57:11 <chrisdone> sioraiocht: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29578#a29578
06:57:18 <Saizan> it's mapM, iirc
06:57:22 <Saizan> traverse is mapA
06:57:28 <ski> @type Data.Traversable.mapM
06:57:28 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
06:58:00 <sioraiocht> chrisdone: oh dear
06:58:08 <chrisdone> sioraiocht: it's not a big deal, I just fit F5 again in emacs and it reloads ghci
06:58:11 <ski> oh, right, i was thinking of `sequenceA' and `traverse'
06:58:15 <ski> @type Data.Traversable.sequenceA
06:58:16 <chrisdone> it's like once every 5 hours tops
06:58:16 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
06:58:19 <ski> @type Data.Traversable.traverse
06:58:19 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
06:58:31 <medfly> hi
06:58:39 * ski always mixes the operations in `Traversable' together
06:58:44 <ski> lo, medfly
06:58:53 <Starfire> How would you write '(f :: a -> b -> c -> d) <$> fa <*> fb <*> fc' using liftA2 ?
06:59:22 <medfly> I want to write a simple game. how do people normally store things like grids?
06:59:52 <Starfire> I mean, without creating intermediate tuples, like Saizan said?
06:59:58 <chrisdone> arrays is a common one
07:00:37 <ManateeLazyCat> chrisdone:  Array is enough.
07:00:38 <ski> Starfire : `liftA2 id (liftA2 f fa fb) fc', e.g.
07:00:41 <medfly> thx
07:00:44 <ivanm> or a Map if it's sparse
07:01:02 <ivanm> if you want to get fancy, there are various tree-like structures as well (quadtrees, etc.)
07:01:03 <ManateeLazyCat> chrisdone: Most map-editor export array.
07:01:07 <ski> @type \f ia ib ic -> liftA2 id (liftA2 f ia ib) ic
07:01:08 <lambdabot> forall b c a b1 (f :: * -> *). (Applicative f) => (a -> b1 -> b -> c) -> f a -> f b1 -> f b -> f c
07:01:12 <medfly> uhhh, I'm gooling Data.Array and there are a bunch of them...
07:01:25 <chrisdone> ManateeLazyCat: why are you telling me, I didn't ask the question :p
07:01:27 <Starfire> ski: Ahh, I see.
07:01:32 <ivanm> medfly: if using unboxed, UArray
07:01:39 <ivanm> however, Vector would probably be better
07:01:43 <ManateeLazyCat> chrisdone: Sorry, is medfly
07:01:46 <ski> Starfire : note that `liftA2 id = (<*>)'
07:01:47 <Saizan> ?type liftA2 id -- this will require Suitable for functions in a restricted setting
07:01:48 <lambdabot> forall b c (f :: * -> *). (Applicative f) => f (b -> c) -> f b -> f c
07:01:52 <chrisdone> I suspect for 'simple' you might as well use a list
07:01:54 <ManateeLazyCat> chrisdone: You guys nick color is too close... sorry.
07:01:56 <medfly> what is ... what?
07:02:08 <medfly> ivanm: what is unboxed? 
07:02:19 <ivanm> medfly: Int#, etc.
07:02:28 <Saizan> we clearly need liftAN as a primitive :)
07:02:33 <ManateeLazyCat> medfly:  2D game right?
07:02:39 <medfly> yep, 2D game
07:02:52 <ivanm> if you're only using basic types, then the unboxed variants are faster (done automatically with -funbox-strict-fields)
07:02:52 <chrisdone> ivanm: bit OTT
07:03:02 <chrisdone> what's the game
07:03:06 <ivanm> chrisdone: which topic? :p
07:03:15 <medfly> I dunno. one of those ones that have a grid, like maybe tetris or something. something simple :p
07:03:18 <chrisdone> ivanm: over the top
07:03:18 <ManateeLazyCat> medfly:  Two-dimensional array is enough.
07:03:22 <chrisdone> if it's tetris a list will do
07:03:26 <ivanm> oh, missed the second T
07:03:36 <ManateeLazyCat> medfly: Most map-editor export two-dimensional array
07:03:40 <chrisdone> don't even bother thinking about lookup speed for tetris
07:04:07 <ManateeLazyCat> medfly: After you design toll-gate in map-editor, you will got two-dimensional array.
07:04:10 <medfly> sure, I just dunno most of the ... store-thingies in Haskell. just lists and tuples 
07:04:18 <medfly> making lists of lists seemed potentially silly.
07:04:26 <medfly> ManateeLazyCat: toll gate?
07:04:54 <ManateeLazyCat> medfly: Well, you used to design game? 
07:04:57 <medfly> no
07:05:06 <medfly> I am making tetris or something
07:05:08 <medfly> should be clear :p
07:06:18 <yrlnry> <lispy> My name is on that guys blog a whole bunch of times
07:06:23 <yrlnry> What's lispy's name?
07:06:30 <ManateeLazyCat> medfly:  Two-dimensional array is enough for 2D game. Generic, we use two or more array.
07:06:34 <chrisdone> > let grid = [((0,0),"hello "),((0,1),"world!")] in do w1 <- lookup (0,0) grid; w2 <- lookup (0,1) grid; return $ w1 ++ w2
07:06:35 <lambdabot>   Just "hello world!"
07:06:44 <yrlnry> Oh, n/m.
07:07:04 <ManateeLazyCat> medfly: One for draw tile, another for Collision Detection.
07:07:51 <ManateeLazyCat> medfly: If your game level more complicated, you perhaps need two or more array for multiple *tile layout*....
07:08:11 <Nibble> what does lookup do?
07:08:23 <Axman6> :t lookup
07:08:24 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
07:08:28 <applicative> @type lookup
07:08:28 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
07:08:36 <applicative> uh oh, fugues
07:08:58 <chrisdone> medfly: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/array-0.3.0.0/Data-Array.html
07:09:13 <chrisdone> lists, or Data.Array should be sufficient
07:09:18 <yrlnry> This is really dumb, but I can't find the function in Data.Map for getting the value associated with a specified key. findWithDefault seems like almost what I want, bit it requires that the key obey (Ord k) for some reason. 
07:09:51 <medfly> thx
07:10:19 <Nibble> yrlnry: I have the same problem, share the solution if you find any
07:10:20 <chrisdone> yrlnry: all functions for maps require the key be an instance of Ord, that's how the map works, by ordering a tree
07:10:20 <yrlnry> and Data.Map.lookup looks like what I want, bu it's not exported for some reason.
07:10:20 <ManateeLazyCat> medfly: Do you know JAVA?
07:10:45 <burp> it is exported
07:10:58 <yrlnry> Chrisdone: Oh, that's disappointing.  Thanks.
07:11:00 <medfly> ManateeLazyCat: no
07:11:40 <monadic_kid> anyone who doesn't know Java should count themselves lucky
07:11:43 <ManateeLazyCat> medfly: I recommend you search j2me game source code.
07:11:56 <ManateeLazyCat> medfly:  90% j2me game is 2D game.
07:12:09 <medfly> ManateeLazyCat: I'm not that hopeless about how to make a game. 
07:12:27 <ManateeLazyCat> medfly: Because j2me game design for mobile phone, it's logic is simple.
07:13:17 <ManateeLazyCat> medfly: What? You didn't told me you want develop a 2D game?
07:13:20 <applicative> Nibble, what was your trouble?
07:13:43 <Nibble> applicative: exactly the same as his
07:13:53 <burp> Nibble: there is no problem at all :O
07:13:58 <medfly> ManateeLazyCat: I do, but a trivial game so I can get coding again
07:14:04 <Nibble> burp: what?
07:14:12 <Nibble> I just said I was looking for the same thing
07:14:22 <ksf> knowing java doesn't mean that you get anything running on j2me phones.
07:14:33 <burp> Nibble: for a map without Ord keys?
07:14:34 <applicative> burp, I was just looking for the source of this mutual incomprehension
07:15:19 <ksf> I think I could point to at least 100 easier and less painful ways to get a game running than under j2me.
07:15:33 <medfly> this is #haskell anyway
07:15:40 <medfly> why are we talking about whether I can write java or not
07:15:46 <ksf> we aren't.
07:15:54 <ksf> we're talking about why _not_ to use java.
07:16:07 <ManateeLazyCat> medfly: I just tell you there have many j2me game's source code you can get to study.
07:16:11 <applicative> medfly, I don't care if you write Java, I respect you anyway.
07:16:19 <ManateeLazyCat> medfly: Not mean you need use java write mobile game.
07:16:20 <Axman6> lol
07:16:34 <ManateeLazyCat> medfly: Other PC game's source code is huge that hard to study.
07:16:50 <ManateeLazyCat> medfly: j2me's source code is much simpler to study.
07:16:52 <applicative> Nibble, were you looking for a lookup function in general, or one associated with the Data.Map implementation
07:16:55 <medfly> I like doing things. that's why I am picking a project I can do
07:16:59 <ksf> one thing's good about j2me games, though, they're easy to reverse-engineer.
07:17:13 <ksf> fire up a decompiler, fire up eclipse and start to rename functions.
07:17:35 <koala_man> have you tried that on an obfuscated jar?
07:17:41 <ksf> yes.
07:17:54 <koala_man> did it compile?
07:17:54 <ManateeLazyCat> koala_man: obfuscated nothing help.
07:17:55 <fasta> ksf, was there anything worth decompiling?
07:17:59 <ksf> ...that's why I was mentioning renaming.
07:18:06 <ManateeLazyCat> koala_man: It's still can reverse-engineer.
07:18:18 <koala_man> ManateeLazyCat: that goes for all languages
07:18:19 <chrisdone> medfly: my first haskell project was connect4. tetris is great, everyone should implement it
07:18:25 <ksf> the hard thing is all those statically computed constants.
07:18:34 <medfly> I haven't written code in forever :(
07:18:40 <ManateeLazyCat> koala_man: Anyway, no secret in j2me source code.
07:18:43 <ksf> but you might be lucky and have the source of an idiot who doesn't know what static final does.
07:18:46 * ski remembers writing a few simple games in assembler on C64
07:19:02 <chrisdone> ski: why didn't you use BASIC? THE MANUAL WAS HUGE
07:19:05 <applicative> medfly, then don't try haskell. It's not code, since each sentence of a module actually says something.
07:19:15 <medfly> eh?
07:19:22 <ManateeLazyCat> koala_man: Only different is large company have many tools can produce game in shorter time than other....
07:19:30 <ksf> back in my days there were ways to crash decompilers with hand-written jvm code (that the jvm still accepted), but I think they have all been fixed.
07:19:42 <koala_man> ksf: the function names shouldn't affect compilability, the bytecode that can't be turned into valid java code is worse
07:20:04 <ksf> ...but the standard javac doesn't generate such stuff.
07:20:14 <ski> chrisdone : i had already tried that. getting "shadows" turned out to be too slow
07:20:24 <ksf> and obfuscators only mangle names, at least back in my days.
07:20:33 <ManateeLazyCat> ksf: Yep.
07:20:42 <ksf> you basically _have_ to obfuscate under j2me or the jar will explode on you.
07:20:45 <ManateeLazyCat> ksf: If you have many time, you can got all logic....
07:20:54 <fryguybob> Colours: I don't think it is completely correct, but this will compile: http://pastebin.com/gXJQfSk3
07:21:11 <ksf> also, use the minimum amount of objects necessary, which is a midlet and a canvas.
07:21:34 <koala_man> ksf: renaming is the most basic thing an obfuscator does. they also further optimize bytecode and shuffle jvm instructions around
07:22:25 <chrisdone> Couldn't match expected type `DL.RecCons DS.Userid (DL.Expr Integer) DL.RecNil'
07:22:25 <chrisdone>            against inferred type `DL.RecNil'
07:22:28 <ski> koala_man : do they typically do any fusion ?
07:22:30 <chrisdone> this is the kind of compile error you get with haskelldb
07:22:48 <applicative> fryguybob, what was the trouble with that module?  I got lost trying to repair it.
07:22:59 <chrisdone> it's actually pretty descriptive. I like it. change the schema of a table, every piece of code that uses it brings up a type error
07:23:05 <ManateeLazyCat> ksf: You just have 800kb memory or less to develop j2me game, i miss those days....
07:23:06 <koala_man> ski: nfi. I haven't even looked them for five years, who knows what kind of crazyness they could be up to now
07:23:43 <ski> (koala_man : "nfi" meaning ?)
07:24:04 <fryguybob> applicative: It needed a type signature and some ()'s around cons and use many instead of recursively parsing.
07:24:21 <koala_man> "no  idea"
07:24:21 <applicative> fryguybob, I think I
07:24:30 <applicative> 'm seeing it.    
07:24:40 <ksf> 740k jarsize, iirc. though that's mostly a carrier limit.
07:25:16 <ManateeLazyCat> ksf: Hehe...
07:25:43 <ksf> forces one do to fun stuff. like re-loading a png with a changed palette to get a second sprite set for the red team.
07:26:09 <ManateeLazyCat> ksf: I remember i use object-pool technology develop my first business game. :)
07:26:11 <ski> (.. and procedural generation ?)
07:26:23 <ManateeLazyCat> ksf: Yes.
07:26:33 <ksf> you can't do such low-pixel graphics procedurally.
07:26:34 <ManateeLazyCat> ksf: Same memory, and change color in runtime.
07:26:45 <Colours> fryguybob thanks it does compile but it does not parse correctly :(
07:26:47 <Colours> thanks though! :3
07:27:01 <ManateeLazyCat> ksf: I write some library cross different mobile device...
07:27:22 <ski> no, i just wondered whether procedural generation of game data would be common, because of such space constraints ?
07:27:24 <ManateeLazyCat> ksf: That's for j2me-1.1
07:27:36 <applicative> Colours, whats it doing wrong?  
07:27:42 <ManateeLazyCat> ksf: After j2me-2.0 release, easier to develop...
07:28:04 <ksf> I'm out of the loop for 5 years or so now, ever since infospace ruined elkware.
07:28:37 <ksf> ski, as in map generation, definitely.
07:29:00 <ksf> but generating 8x8 to 16x16 tiles and sprites procedurally just isn't worth it.
07:29:14 <ski> ok
07:29:34 * ski remembers being introduced to the concept by the (old) game Faery Tale
07:29:36 <ksf> it'd be a true pita to get right, after all, our gfx guys had a specialist who would pixel every pixel individually.
07:30:16 <ski> heh, my brother used to draw pictures pixel by pixel
07:30:22 <ski> (in DPaint)
07:30:32 <ManateeLazyCat> ksf: For map, we use 16x16 tiles, for some property, we perhaps use 8x8 or little...
07:31:02 * ski idly wonders whether this discussion should migrate to #haskell-blah, yet ..
07:31:23 * ManateeLazyCat Just fun... :)
07:31:48 * hackagebot hstzaar 0.3 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.3 (PedroVasconcelos)
07:31:55 <ManateeLazyCat> ski: Just talk Haskell is not boring?
07:32:17 <ski> .. sorry ?
07:32:23 <ksf> only way to get decent graphics performance out of series40 is not to update the whole screen all the time.
07:32:41 <fryguybob> Colours: Can you give an example of something that it fails to parse?
07:34:32 <ManateeLazyCat> ksf: Come on, i hate series40...
07:35:15 <ksf> there are worse things.
07:35:20 <ksf> hopefully, they're all dead.
07:35:47 <ksf> series40 at least has a decently fast cpu and not too tight memory.
07:35:50 <ManateeLazyCat> ksf: Thanks god when my boss tell me don't need develop for S40
07:37:51 * hackagebot QuickCheck 2.2 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.2 (NickSmallbone)
07:38:44 * ManateeLazyCat Got enough IRC message.... parsing........
07:40:37 <dom96> hey ManateeLazyCat 
07:40:51 <ManateeLazyCat> dom96: Hey, i'm use your Messages.hs
07:41:01 <ManateeLazyCat> dom96: And fix some bug.
07:41:07 <dom96> oh?
07:41:39 <ManateeLazyCat> dom96: Your parseFirst should return (nick, user, host, server).
07:41:56 <ManateeLazyCat> dom96: Example ":nick!username@host ...."
07:42:36 <Eelis> i wonder how many irc message parsers there are in hackage already. probably at least 5. hurray for re-use!
07:42:49 <ManateeLazyCat> dom96: Example ":andy!AndyStewart@ChineSomeWhere.net ...." 
07:43:08 <ManateeLazyCat> dom96: nick is andy, user name is AndyStewart, and host is ChinaSomeWhere.net
07:43:29 <ManateeLazyCat> dom96: But your Messages.hs return host is "!AndyStewart@ChinaSomeWhere.net"
07:43:29 <dom96> ManateeLazyCat: it returns the username in with the host
07:43:49 <ManateeLazyCat> dom96: Ah, why you made mHost?
07:43:58 <ManateeLazyCat> dom96: And not mUserHost ?
07:44:50 <dom96> ManateeLazyCat: i don't know, Decided to keep it short.
07:45:42 <ManateeLazyCat> dom96: If you decided make username and host together, you should remove '!'.
07:45:57 <dom96> ManateeLazyCat: your right.
07:47:17 <ManateeLazyCat> dom96: Sorry, i will fork your Messages.hs, i haven't so much time work together, anyway, i will feedback to you if i found some bug.
07:47:42 * ManateeLazyCat pasted "Messages.hs" at http://paste2.org/get/969541
07:48:05 <ManateeLazyCat> dom96: Above is new version, add mUser in IrcMessage and improve code by hlint.
07:49:10 <dom96> ManateeLazyCat: ooh, i never heard of hlint, looks nice.
07:49:23 <ManateeLazyCat> @hackage hlint
07:49:24 <lambdabot> http://hackage.haskell.org/package/hlint
07:49:48 <ManateeLazyCat> dom96: hlint can give suggestion that remove unnecessary code....
07:49:57 <ManateeLazyCat> Or suggest better version....
07:50:56 <lolatyu> how would you go about creating a Data.Vector that has to index itself to create itself. Say you want to create a Data.Vector of length 80 where it is populated with fibonacci numbers
07:51:11 <dom96> ManateeLazyCat: oh
07:51:23 <dom96> ManateeLazyCat: thanks for the bug fix :)
07:52:00 <ManateeLazyCat> dom96: I should thank you, for your great work... :)
07:52:12 <dom96> ManateeLazyCat: :)
07:53:34 * ManateeLazyCat pasted "Irc data fetch from #haskell" at http://paste2.org/get/969545
07:53:41 <ManateeLazyCat> dom96: Above is irc message that fetch from #haskell....
07:54:00 <ManateeLazyCat> dom96: Now it can pick username and host correctly.
07:54:08 <dom96> ManateeLazyCat: nice
07:54:43 <ski> lolatyu : recursively ?
07:55:10 <ManateeLazyCat> dom96: BTW, another tip, you can install package groom, then use 'groom' instead 'show' print IrcMessage, then you got pretty layout like http://paste2.org/get/969545
07:55:18 <ManateeLazyCat> @hackage groom
07:55:18 <lambdabot> http://hackage.haskell.org/package/groom
07:55:49 <ManateeLazyCat> dom96:  Groom is good package to parse complex data structure.
07:56:13 <dom96> cool,  thanks.
07:57:17 <lolatyu> ski: in whatever way is most efficient. You know the Vector size. You have some basis filled in the vector and can inductively populate the rest of the vector
07:58:01 <lolatyu> there is only snoc that I see can be used for it
07:58:11 <ski> lolatyu : i don't know exactly how `Vector's are constructed, but if it's similar to (immutable) arrays, it should be simple
07:59:11 <lolatyu> http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector.html
08:00:05 <ski> lolatyu : ok, `generate' looks like what you want
08:02:40 <lolatyu> ski: yes I could use it if it allowed me to index the array during construction
08:03:23 <ski>   fibUpTo n = v where fib = (v !); v = generate n $ \i -> case i of 0 -> 0; 1 -> 1; i -> fib (i - 1) + fib (i - 2)
08:03:28 <ski> i would assume that to work
08:03:46 <lolatyu> yes it would
08:05:43 <lolatyu> ah, I a suck at asking for help. What I really am wondering about is how you would do it if you were forced to index the vector as you constucted it. My guess is that you would have to use snoc and pass on the vector as you went along. It just seems inefficient when you also know the size you want
08:06:26 <ski> what do you mean by "forced to index the vector as you constucted it"
08:06:57 <leimy> holy beans there's a lot of people in here!
08:07:17 <ski> it happens ..
08:07:21 <luite> leimy: it's because of haskell's failure to avoid success
08:08:37 <leimy> heh
08:08:46 <leimy> I was going to ask when it seems ok to use unsafePerformIO.  
08:08:59 <leimy> There seems to be a trend of people not caring as much as I do about hiding IO 
08:09:48 <luite> it's ok when you know the things you are doing are pure, but the compiler doesn't
08:09:51 <leimy> Was reading this: http://blog.ezyang.com/2010/08/defining-haskelly/  <--- noted that the suggestion was to actually use unsafePerformIO.  I thought perhaps this was a bad suggestion.
08:10:36 <leimy> luite: I've seen suggestions that if only one kind of processing owns a file, that it's ok to do file access via unsafePerformIO
08:10:58 <luite> I would ignore those suggestions :)
08:11:35 <luite> there is lazy IO by the way, which is generally accepted, but should also be used with caution
08:11:54 <leimy> yeah I'm aware of lazy IO
08:11:57 <luite> that uses unsafeInterleaveIO
08:11:58 <leimy> and the pitfalls.
08:12:03 <lolatyu> ski: I am basically translating this "for i from 16 to 79 w[i] = (w[i-3] xor w[i-8] xor w[i-14] xor w[i-16]) leftrotate 1" into Haskell
08:12:45 <ski> lolatyu : ok. any particular reason to prefer `Vector' to `Array' ?
08:12:46 <lolatyu> where w[0]...w[15] are some prefilled values
08:12:57 <lolatyu> not really no
08:13:18 <ski> hm, prefilled how ?
08:13:35 <ski> given as inputs, in e.g. another vector array ?
08:13:51 <ski> s/vector array/vector\/array/
08:13:58 <lolatyu> I guess that would have to be the case
08:16:57 <ski>   foo prefilled = fix $ \w -> generate 80 $ \i -> if i < 16 then prefilled ! i else ((w ! (i - 3)) `xor` (w ! (i - 8)) `xor` (w ! (i - 14)) `xor` (w ! (i - 16))) `leftRotate` 1
08:17:00 <ski> something like that
08:17:21 <ski> you'll have to check how to `leftRotate' things
08:17:24 <ski> @type xor
08:17:24 <lambdabot> forall a. (Bits a) => a -> a -> a
08:17:45 <ski> @hoogle rotate
08:17:45 <lambdabot> Data.Bits rotate :: Bits a => a -> Int -> a
08:17:45 <lambdabot> Data.Bits rotateL :: Bits a => a -> Int -> a
08:17:45 <lambdabot> Data.Bits rotateR :: Bits a => a -> Int -> a
08:17:52 <ski> hm, `rotateL', i suppose
08:18:21 <ski> (possibly some of the brackets above could be elided .. check the precedences
08:18:22 <ski> )
08:18:27 <ski> lolatyu : ^
08:18:32 <lolatyu> yes
08:18:51 <lolatyu> thank you for the help
08:19:45 <ski> (possibly one could avoid the `fix', using view-patterns instead .. might be slightly prettier)
08:20:45 <ski> also, you can do basically the same thing with arrays
08:21:33 <ski> though arrays doesn't need to be indexed starting from zero .. nor do they need to be indexed by `Int's .. one can e.g. have two-dimensional arrays indexed by `(Int,Int)'
08:22:38 * ski isn't that familiar with `Vector' so can't really help on when `Vector' would be preferable to `Array' (or vice versa), given that you already want to start indexing from zero, by `Int's
08:23:10 <dolio> vector does a bunch of fusion.
08:24:24 <ski> lolatyu : btw. maybe a clarification of the other code would be in order. it (is intended to) build the vector lazily, i.e. the vector structure is built, but the elements aren't computed until you look at them, and then only that element, and those elements which it recursively depended on will be computed (and cached in the vector, so that subsequent accesses don't recompute them)
08:24:41 <ski> s/other code/above code/
08:25:27 <ski> .. so, you basically get a cyclic vector, in the same sense that
08:25:44 <ski> > let as = 0 : bs ; bs = 1 : as in as
08:25:45 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
08:25:51 <ski> is a cyclic list
08:26:03 <ski> (only the vector is not infinite)
08:27:15 <ski> > let as = take 10 (0 : 1 : zipWith (+) as (tail as)) in as  -- probably better analogue
08:27:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
08:27:40 <lolatyu> ski: I am implementing sha1. There is a part where 16 words are consumed from the message and extended to 80 words in the given manner
08:28:12 <lolatyu> ski: http://en.wikipedia.org/wiki/SHA-1 (there is pseudocode there, I don't feel like dragging out the sha1 standard)
08:28:31 <lolatyu> only doing it for fun, nothing serious
08:30:34 <ski> ok
08:31:11 <mmmulani> how do I turn an Int into a CInt?
08:31:41 <Jafet> @hoogle Int -> CInt
08:31:41 <lambdabot> Prelude toEnum :: Enum a => Int -> a
08:31:41 <lambdabot> Data.Bits bit :: Bits a => Int -> a
08:31:41 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
08:33:03 <mmmulani> ahh yeah, fromIntegral
08:34:28 <mmmulani> hmm now how to convert Double to CDouble.
08:35:38 <Jafet> realToFrac?
08:36:38 <mmmulani> whoa
08:51:26 <Nibble> @src :
08:51:27 <lambdabot> Source not found. stty: unknown mode: doofus
08:51:30 <Nibble> @src (:)
08:51:30 <lambdabot> Source not found. Are you on drugs?
08:51:40 <Nibble> lambdabot: without the attitude
08:51:59 <Axman6> @src []
08:52:00 <lambdabot> data [] a = [] | a : [a]
08:52:18 <DrSyzygy> Somehow I've ended up giving seminars surprisingly often about ∂ for datatypes and category theory in Haskell...
08:52:19 <Nibble> Axman6: how is : defined then
08:52:27 <Axman6> that's it, right there
08:52:30 <Axman6> a : [a]
08:52:46 <Axman6> lists are special in haskell though
08:53:01 <ski> syntax-wise
08:53:08 <Nibble> Axman6: I would suspe
08:53:23 <Nibble> I would think*
08:53:23 <ski> it's basically
08:53:31 <Nibble> that there should be a definition for : somewhere too?
08:53:32 <ski>   data List a = Nil | Cons a (List a)
08:53:42 <ski> plus a bit of syntactic sugar
08:53:43 <Axman6> Nibble: that is the definition
08:54:00 <Nibble> ski: ah, sugar
08:54:10 <Axman6> it's a constructor which takes an a, and a list of a's, and creates a list of a's
08:54:24 <DrSyzygy> ski: I'm currently writing out a seminar talk (giving it Sep. 1) on how this is really just a matter of working with a Combinatorial Species internal to Hask. :-)
08:54:30 <ski> yeah, sugar being finite-size lists, list enumerations, and list comprehensions
08:54:55 <ski> DrSyzygy : online seminar ?
08:55:03 <DrSyzygy> ski: So writing [a..b] instead of enumFromTo a b, et.c.
08:55:06 <DrSyzygy> ski: No, alas.
08:55:13 <DrSyzygy> ski: But if you're in Stockholm, you could come listen.
08:55:18 * ski would like to learn more about Species ..
08:55:36 <DrSyzygy> It's in the combinatorics seminar though, so it'll be a LOT about what species are, and how that connects to the enumerative combinatorics side of things.
08:55:46 <ski> (i would read Joyal's papers, if i could get hold of them, and they were in english)
08:56:02 <DrSyzygy> But basically, enumerative combinatorics can be captured to a large extent by studying endofunctors of the category of sets with bijections as morphisms.
08:56:08 <ski> DrSyzygy : where is it to be held ?
08:56:16 <DrSyzygy> ski: KTH.
08:56:20 <DrSyzygy> ski: Are you in Stockholm?!
08:56:23 <ski> ok
08:56:28 <ski> no, Gteborg
08:56:30 <Nibble> ski: swe?
08:56:34 <Nibble> DrSyzygy: swe?
08:56:38 <DrSyzygy> Nibble: Yup.
08:56:38 <roconnor> I recently learned that analyisis is actually about generating functions and combinatorics.
08:57:02 <DrSyzygy> ski: Basically, you associate to such an endofunctor the generating series sum_k |F[n]| x^n/n!
08:57:07 <fasta> roconnor, which book told you that?
08:57:10 <ski> DrSyzygy : iirc someone in here (maybe byorgey ?) has some library in Haskell for talking about species
08:57:28 <DrSyzygy> And then coproduct is + on the series, product (in a Haskell sense) is * on the series, composition of endofunctors is composition of gen. series, et.c.
08:57:39 <DrSyzygy> ski: Yah, I aim to sit down and read that paper at some point soon.
08:57:49 <DrSyzygy> Turns out, though, you can talk about species in other categories.
08:57:56 <ski> <http://byorgey.wordpress.com/tag/combinatorial-species/>
08:58:05 <DrSyzygy> And I suspect, very very strongly, that Haskell type theory is to a large extent REALLY about doing species internal to Hask.
08:58:20 <greap> Is there a way to specify importing quickcheck2 rather than 1 in an import statement?
08:58:22 <ski> DrSyzygy : i'd expect to (be able to talk about it in other cats :)
08:58:29 <roconnor> fasta: it is sort of the impression I got from talking to Bruno Salvy.   But I'm probably misrepresenting his views :)
08:58:35 <DrSyzygy> Cool, too, is that »pointing« is a species technique that corresponds EXACTLY to Conor McBride's ∂ for datetypes.
08:59:12 <DrSyzygy> Pointing counts combinatorial structures with a single element distinguished. Which is Huet's Zipper.
08:59:13 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29580#a29580
08:59:18 <int80_h> hi ski
08:59:24 <int80_h> would you take a look there?
08:59:25 * ski str some paper about generalizing datatypes to species .. or something like that anyway, haven't read
08:59:28 <fasta> I don't have the impression that any of these functional programming techniques actually make it _easier_ to understand what algorithms do, though. 
08:59:28 <DrSyzygy> And pointed F-structures are structures for X*F'
08:59:44 <roconnor> fasta: they are computing average case running times for algorithms by putting the times into a taylor series and finding the nereast pole and differentiating there or whatnot.
08:59:55 <ski> `pointing' is derivative ?
09:00:08 <DrSyzygy> No. Pointing is X*d/dx
09:00:12 <ski> ok
09:00:20 <DrSyzygy> Remember that ∂ gets you a hole, and X*∂ gets you Zippers.
09:00:22 <DrSyzygy> Pointing == Zippers.
09:00:53 <roconnor> DrSyzygy: I don't think that is a Zipper
09:00:55 <ski> does elacticity of demand have a (useful) interpration in species ?
09:01:10 <Nibble> dumb question alert, what is species?
09:01:15 <DrSyzygy> roconnor: No? My impression from sigfpe's summaries of McBride's papers is that X*∂ is essentially the same as Zippers.
09:01:32 <roconnor> DrSyzygy: I'm not an expert but that is very much not the impression I got
09:01:50 <ski> well, with zippers, you often want to mark sub-structures of a given structure, as opposed to marking elements
09:02:24 <roconnor> DrSyzygy: X*∂ is a very useful construct, but I don't know the name for it.
09:02:27 <ski> so, that would be related to taking the derivative of (in a presentation) the functor that inductively generates the datatype
09:02:42 <ski> (afaiu)
09:02:53 <roconnor> DrSyzygy: and in general there seems to be confusion over the technical names of things in this area.
09:02:58 <ski> DrSyzygy : what about elactiticy of demand ?
09:02:59 <DrSyzygy> roconnor: Isn't Zipper the construction where you tag a single element inside a (tree-like) datastructure by giving the path to it, hanging alternative subtrees off of the path down, and keeping the actual element at that point separate?
09:03:03 <DrSyzygy> ski: What about it?
09:03:18 <ski> DrSyzygy : i just wondered if it has an interpretation, in species
09:03:24 <ski> (that you know of)
09:03:27 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29580#a29580
09:03:32 <DrSyzygy> roconnor: I'm not talking to CSers now, so I'll stick to sigfpe's narrative for this one. Too late for me to really want to go in and change things...
09:03:36 <roconnor> DrSyzygy: but one important aspect is being able to move the cursor in a zipper to a neighbouring location in constant time.
09:03:38 <DrSyzygy> ski: I don't know what it is.
09:03:38 <int80_h> maybe someone could take a looksee?
09:04:00 <ski> in terms of datatypes, you have `D f a * a  =  f a * E f a', where `D' is derivative and `E' is elacticity of demand
09:04:15 <DrSyzygy> roconnor: Ahhh. I'm pretty convinced you can do that easily for some of the X*∂ I know, but I haven't thought that part through in detail.
09:04:19 <roconnor> DrSyzygy: I'm not sure it is a good idea to purpetuate the confusion over what a Zipper is
09:04:26 <ski> so, there, `E f a' describes paths to elements `a' in `f a'
09:05:13 <ski> DrSyzygy : the term comes from economy, where `E (\x -> x ^ 5)' is `\_ -> 5', e.g.
09:05:19 <DrSyzygy> roconnor: It's not a big part of the talk on Wednesday. And I have 5 other talks in the upcoming week. You'll excuse me if I don't focus on reconstructing that part of my lecture notes. But I'll remember that it isn't as easy as I imagined it, and try to circumnavigate the "is it a zipper or not" issue.
09:05:35 <alise> What's the simplest way to write something returning all N-length permutations of a list?
09:05:53 <roconnor> DrSyzygy: As I undrestand a zipper only applies to recusrive structures of the form (mu X. F X).  and the zipper is something like (this is probably wrong)  (list ∂F)*(mu X. F X). 
09:06:01 <ski> (also, `E' is a bit simpler than `D' for product and division)
09:06:07 <alise> e.g., for 3 and Bool, you'd get [F,F,F], [F,F,T], [F,T,F], [F,T,T], [T,F,F], [T,F,T], [T,T,F], [T,T,T]; i.e. binary counting.
09:06:08 <int80_h> SyntaxNinja: hi there :)
09:06:15 <DrSyzygy> roconnor: (sorry if I sounded belligerent right there; but I'm feeling rather stressed out about the lecture load I accidentially took on for the upcoming week)
09:06:19 <roconnor> DrSyzygy: the important thing is that the list is backwards from the the list you normally get from a derivative
09:06:26 <DrSyzygy> roconnor: Aight.
09:06:46 <roconnor> > permutations "TF"
09:06:47 <lambdabot>   ["TF","FT"]
09:06:51 <roconnor> oh
09:06:53 <ski> roconnor : well, it doesn't *have* to be backward .. but that's how you get efficient local computation, yes
09:06:57 <roconnor> > replicateM 3 "TF"
09:06:58 <lambdabot>   ["TTT","TTF","TFT","TFF","FTT","FTF","FFT","FFF"]
09:07:05 <alise> thanks roconnor
09:07:07 <roconnor> ski: I think it has to be backwards
09:07:12 <alise> list monad, fun fun
09:07:23 * ski wonders how zippers of HOAS as well as indexed types looks like
09:07:29 <DrSyzygy> List monad is awesome.
09:07:43 * DrSyzygy made the list monad do more than he expected in a recent pozorvlak blog post comment thread.
09:07:55 <roconnor> IIRC Clowns/Jokers has a clear definition of a zipper
09:08:20 <DrSyzygy> http://pozorvlak.livejournal.com/150560.html?thread=1489440#t1489440
09:08:24 <ski> e.g., how do you invert `(forall a. P a -> []) -> Q' where `[]' represents the hole ?
09:08:57 <roconnor> well, maybe *had* a clear definition before it was editted for publication
09:09:02 <ski> (.. when using HOAS, i.e.)
09:09:09 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29580#a29580
09:09:37 <eevar> are there any known issues with STM on windows? -- i've been playing around with jeff fosters ant program (http://www.fatvat.co.uk/2010/08/speeding-up-ants-program.html), and it always seems to near-deadlock after 0-10 sec. unless i compile with -threaded
09:10:42 <roconnor> http://www.cs.nott.ac.uk/~ctm/Dissect.pdf -- this was the version with a clear definition of a zipper
09:11:05 <roconnor> ah it is all coming back to me
09:11:33 * ski idly ponders how to compose zippers
09:12:02 <roconnor> There is some debate whether a zipper is just the (List ∂F (mu F))  or if it is the  pair (List ∂F (mu F))*(mu F)
09:13:25 <roconnor> but in either case
09:13:41 <roconnor> it is definitely not X*(∂F X)
09:14:14 <SyntaxNinja> y0
09:14:44 <roconnor> but probably that hole with a context structure should get a name
09:16:07 <int80_h> SyntaxNinja: Do you have a moment to look over my hpaste?
09:19:29 <ski> int80_h : you want the `processFunc' field to contain a function from `String' to `Table soa v', for *which* `soa' and `v' types ?
09:19:49 <ski> any types the *caller* of `processFunc' wants ?
09:20:11 <ski> any types the function in the `processFunc' wants ? (possibly depending on the `String' input or not ?)
09:20:16 <ski> some other variant ?
09:20:54 <ski> possibly you want some specific `soa' and `v' type parameters to be used ? .. (like `Table Int String' or whatever)
09:22:05 * ski taps food patiently
09:22:35 <int80_h> ski: yes I'd like to be able to do this Table Students ID
09:22:49 <int80_h> ski: but the specifics depends on which function is being called.
09:23:05 <int80_h> ski: I'm trying to address a problem I ignored earlier
09:23:07 <ski> i see no `Students' nor `ID' types in there
09:23:37 <int80_h> > data StudentsOrActivites = Students String | Activities String
09:23:38 <lambdabot>   <no location info>: parse error on input `data'
09:23:43 <ski> maybe you meant `Table StudentsOrActivites Value' ?
09:23:49 <int80_h> yes!
09:23:57 <int80_h> thats it
09:23:58 <ski> ok, then just say that in the code
09:24:01 <siracusa> When I have a (library) module A.B.C that also exports a main function, can I make GHC compile it as executable?
09:24:14 <ski>                  , processfunc :: String -> Table StudentsOrActivites Value
09:25:56 * ski -> _|_
09:26:09 <int80_h> thanks, I'm trying to compile now
09:37:02 <roconnor> siracusa: I think so 
09:37:19 <roconnor> siracusa: there is some sort of --main-is or --main-as or something option
09:38:44 <roconnor> ah
09:38:50 <roconnor> siracusa: ghc -no-recomp -O --make Data/Digest/SHA2.hs -main-is Data.Digest.SHA2.moduleTest -o moduleTest && ./moduleTest
09:39:01 <roconnor> is an example I have used in the past
09:39:45 <roconnor> siracusa: in that example I even state which function I want to be main
09:40:04 <roconnor> but if you leave out the function name and just give the module, it should look for main
09:40:34 <greap> I've dug a bit deeper, and I've found this line in ghci -v package QuickCheck-2.1.1.1-c7435cb0d5b5de72fe9540c48335606d is unusable due to missing or recursive dependencies: ghc-6.12.3-66a382195c8a71849653439b67021fd1
09:40:52 <greap> But I'm using ghc 6.12.3
09:40:55 <greap> So I'm confused
09:42:22 <siracusa> roconnor: This works great, thanks!
09:43:36 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29580#a29585
09:44:21 <rpglover64> is there an already defined way to get the 8 indicies adjacent to a given index in a 2d range? (or an nd range)
09:53:22 <Nibble> hello, I am having some problems with the following example code.     loop st    = catch (runReaderT run st) (const $ return ())
09:53:26 <Nibble>     Ambiguous type variable `b' in the constraint:
09:53:26 <Nibble>       `Exception b' arising from a use of `catch' at Main.hs:26:17-61
09:53:46 <Nibble> type of main:  main :: IO ()
09:55:24 <bss03> @type catch
09:55:25 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
09:55:27 <Nibble> I can't possibly see what is wrong, and where the b is
09:55:54 <Nibble> bss03: any suggestions?
09:56:01 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29580#a29585
09:56:24 <bss03> Nibble: I'm new, so I don't see anything immediately wrong.
09:56:31 <Nibble> bss03: ok
09:56:36 <bss03> @type const $ return ()
09:56:36 <lambdabot> forall b (m :: * -> *). (Monad m) => b -> m ()
09:57:10 <Nibble> hmm
09:57:16 <notabel> int80_h: you don't have a type called Students, it's StudentsOrActivities
09:57:24 <McManiaC> hey, can anyone help me with Arrow syntax?
09:57:27 <McManiaC> got the following:
09:57:29 <notabel> Students is a particular data constructor of that type
09:57:34 <McManiaC> html <- (getRawHTML :: Url -> MyArrow HTML) -< url
09:58:12 <McManiaC> but it wont work since it cannot match "MyArrow a" with "Url -> MyArrow a"
09:58:18 <Nibble> byorgey: you have a min?
09:58:27 <byorgey> hi Nibble, sure
09:58:30 <Nibble> in the following code
09:58:32 <Nibble>     loop st    = catch (runReaderT run st) (const $ return ())
09:58:36 <Nibble>     Ambiguous type variable `b' in the constraint:
09:58:36 <Nibble>       `Exception b' arising from a use of `catch' at Main.hs:25:17-61
09:58:47 <Nibble> That is kinda cryptic
09:59:01 <bss03> Nibble: You sure that function is the one giving you a type error?  It looks good to me, assuming your MonadReader is on top of the IO monad.
09:59:21 <bss03> @hoogle catch
09:59:21 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
09:59:21 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
09:59:21 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
09:59:24 <byorgey> that isn't a type error
09:59:31 <byorgey> it's just saying it's ambiguous
09:59:42 <byorgey> so perhaps you need to add a type signature
09:59:50 <Nibble> byorgey: for loop?
09:59:54 <byorgey> yes
09:59:56 <bss03> Nibble:  Are you use Control.Exception.catch?
10:00:04 <byorgey> well, no, a signature for loop wouldn't help
10:00:07 <bss03> Or Prelude.catch?
10:00:19 <Nibble> impl: Control.Exception
10:00:24 <Nibble> bss03: *
10:00:25 <byorgey> Nibble: what is 'run'
10:00:27 <byorgey> ?
10:00:31 <int80_h> notabel: thanks :)
10:00:44 <Nibble> byorgey: it is of type ReaderT Bot IO
10:00:56 <Nibble> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
10:00:57 <bss03> Nibble:  Ah, then you need to have a type annotation for (catch $ return ()).
10:00:59 <Nibble> that is the one
10:01:22 <bss03> @type Prelude.catch $ return ()
10:01:23 <lambdabot> (IOError -> IO ()) -> IO ()
10:01:25 <BMeph> int80_h: Is that link to something someone else tried to do, or are *YOU* the "someone else"? 'Cause I'm wondering if..."whoever did that example"...knew what was going on.
10:01:31 <bss03> @type Control.Exception.catch $ return ()
10:01:32 <lambdabot> forall e. (GHC.Exception.Exception e) => (e -> IO ()) -> IO ()
10:02:11 <Nibble> bss03: what is a type annotation
10:02:31 <bss03> expression :: Type Annotation
10:02:32 <int80_h> BMeph : I did it. With ski's help. 
10:02:35 <bss03> e.g.
10:02:57 <bss03> > [1..4] :: [Double]
10:02:57 <lambdabot>   [1.0,2.0,3.0,4.0]
10:03:01 <Nibble> @type const $ return ()
10:03:02 <lambdabot> forall b (m :: * -> *). (Monad m) => b -> m ()
10:03:09 <bss03> > [1..256] :: [Word8]
10:03:09 <lambdabot>   []
10:03:38 <int80_h> My pattern recognition skills get me far, but then I fall down when I run up against a concept I haven't internalized yet.
10:03:50 <copumpkin> > [1..260] :: [Word8] -- mm
10:03:50 <lambdabot>   [1,2,3,4]
10:04:26 <Nibble> I assume I am doing this wrong
10:04:27 <Nibble> (const $ return () ::  (Monad m) => b -> m ())
10:04:38 <BMeph> int80_h: Well, just noticing...you do know that 'Students' and 'ID' are value constructors of your types, right? Because it doesn't look as if you've doing what you think you want with them, as far as the Table constructor is concerned.
10:05:07 <Nibble> byorgey: Why would I need to do this btw?
10:05:29 <copumpkin> preflex: seen edwardk
10:05:29 <preflex>  edwardk was last seen on #haskell 3 hours, 11 minutes and 57 seconds ago, saying: ;)
10:06:43 <byorgey> Nibble: since the type of loop overall does not mention the type of the exception being caught, the type of the exception could be anything
10:06:45 <BMeph> int80_h: See, you changed 'ID' to 'Value', its (what's the right name, governing?) type. 'Students' isn't a type, though, but a constructor for values of the "SorV" (for short) type.
10:06:52 <int80_h> BMeph : yeah I want to be able to have a "Table Students ID" or a "Table Activities Cost" or any variation
10:06:59 <Nibble> byorgey: ok, so what would the type annotation look like?
10:07:02 <byorgey> Nibble: but since it is type-class constrained, GHC thinks it could make a difference to your program which Exception type is chosen
10:07:23 <byorgey> Nibble: in fact, it doesn't matter in this case since you just ignore the exception!  But GHC is not smart enough in this instance to realize that.
10:07:47 <orbitz> when I do a cabal install package, does it download eh .cabal somewhere?
10:08:24 <byorgey> Nibble: it would look something like   loop st = catch (runReaderT run st) (const $ return () :: FooError -> M ())
10:08:26 <int80_h> BMeph : I mean, I want my functions to be able to return those kinds of Table.
10:08:38 <byorgey> Nibble: replace FooError by the specific type of exception you will be catching
10:08:46 <byorgey> Nibble: and replace M by the specific monad you are using.
10:08:59 <int80_h> BMeph: so if you could help me fix what I am doing wrong, I'd appreciate it.
10:09:01 <byorgey> perhaps IOError -> IO () ?
10:09:11 <byorgey> anyway, I'm off to get some lunch
10:09:22 <Nibble> byorgey: that worked
10:09:24 <BMeph> int80_h: Substitute "Right" for "Cost", and see if that still makes sense to say...
10:09:24 <Nibble> thanks
10:10:14 <McManiaC> anyone familiar with HXT/arrow syntax? what am I doing wrong here? http://npaste.de/hk/
10:10:42 <McManiaC> or how do I use readDocument correctly?
10:10:56 <int80_h> BMeph: it makes no sense whatsoever.
10:11:06 <BMeph> int80_h: The issue, as I see it, is that you're trying to make the value constructor do double duty as a description of the (sub-)type that you want. However, that isn't how value constructors work.
10:11:19 <int80_h> data Value = Right Int | Cost Int? I can't make sense out of that.
10:11:54 <int80_h> oops
10:11:58 <int80_h> I meant
10:12:12 <BMeph> int80_h: I meant, what is a "Table Activities Right" supposed to mean? Or rather, what is it supposed to be?
10:12:20 <int80_h> data Value = Right Int | ID Int. But it still doesn't make sense ;)
10:13:14 <int80_h> "Table Activities Right", doesn't mean anything.
10:13:25 <BMeph> int80_h: Does it sound as if I have a point (that I'm trying but failing) to make yet? :)
10:13:41 <int80_h> so your point is, neither does "Table Activities Cost"?
10:14:04 <notabel> BMeph: your point is clear to those of us who already know it :-)  (but i don't have a better way to try, so keep at it)
10:14:08 <copumpkin> quickspec seems neat
10:14:21 <int80_h> BMeph: Did I get your point?
10:15:29 <BMeph> int80_h: Yes, it is. You're giving your constructor, value constructors of a type as if you can constraint the type to a subtype by mentioning that constructor like a type. (Does that make sense?)
10:15:58 <BMeph> notabel: Thanks for the encouragement. ;)
10:16:09 <int80_h> hmm, yes I think so. That said, if my intent is clear, is it possible to do what I want?
10:16:38 <int80_h> or do I need to change my approach to realize my intent?
10:16:44 <notabel> well, int80_h, what do Students and Activities have in common that made you create the StudentsOrActivities type?
10:17:29 <BMeph> int80_h: It sounds as if what you want, is to make Values a newtype, so that the Cost and ID constructors refer to their own separate types.
10:18:04 <int80_h> notabel: I wish I could think of one word that gives them something in common. I'm implementing a takusen example using a database from this http://www.geekgirls.com/databases_from_scratch_3.htm
10:18:38 <BMeph> int80_h: Or maybe even (make Values) a type class instead. (notabel, if I'm stealing your thunder, I apologize.)
10:18:41 <notabel> okay, but why do you need both of them in one type?
10:18:51 <notabel> won't they be the keys of different tables?
10:18:55 <Ke> int80_h: leet css/html skillz
10:19:19 <notabel> (since they seem to have no semantic relationship, it looks like you are just trying to find a way to put them both into your Table)
10:19:20 <Ke> http://users.tkk.fi/~jkarlson/files/screenshot.png
10:20:09 <int80_h> notabel: well, I was doing that so that later I could make a more generalized function definition
10:20:17 <BMeph> This is one thing (structural equality mappings) that I think Haskell could be better at, but isn't. Not without TH and Data/Typeable_ boilerplate, anyway.
10:21:04 <int80_h> BMeph: I intended to involve typeclasses, but first I wanted to put up with creating this boilerplate so that when I needed help making the typeclasses, it would be clear what I was trying to do.
10:21:46 <BMeph> int80_h: Oh, so this is supposed to be Haskell-like pseudocode? hat works, I guess.
10:21:51 <jonafan> wow, WOW that is ugly
10:22:19 <notabel> int80_h: also, if you really need to hold either a student or an activity, you can use Either Student Activity (assuming you've defined Student and Activity via data or type)
10:23:54 <copumpkin> djahandarie: did you just make up the download numbers in this screen shot? http://althack.org/hackage/hackage.png over 2 million downloads for agda??
10:26:37 <copumpkin> oh
10:26:39 <copumpkin> I just misread :)
10:27:10 <aristid> copumpkin: huh?
10:27:15 <copumpkin> yeah, nothing
10:27:17 <aristid> it does seem to say 20 million downloads
10:27:19 <aristid> -20+2
10:27:51 <copumpkin> yeah, but then on hackage4.png it says something more reasonable, so I dunno :P
10:29:32 <Gracenotes> copumpkin: all of the numbers are made up
10:29:37 <copumpkin> ah ok :)
10:29:52 <Gracenotes> hackage4's values are for cabal-install in the month of May, I think
10:30:07 <int80_h> I disconnected a moment, did I miss anything?
10:38:29 <kniu> Sometimes, I can't decide whether to use a typeclass or a simple data type definition.
10:39:18 <kniu> why make a typeclass when you can just put all the "instances" in the alternates of the sum type and pattern match to dispatch?
10:39:50 * hackagebot shellish 0.1.2 - shell-/perl- like (systems) programming in Haskell  http://hackage.haskell.org/package/shellish-0.1.2 (PetrRockai)
10:40:43 <BMeph> int80_h: Not from us (unless you listen to "the Great Co-Pumpkin"... ;)
10:41:19 <int80_h> BMeph: I'm changing my code to use newtype, I think this expresses what I want. Posting if it blows up.
10:42:06 <BMeph> kniu: int80_h wants to specifically match on subtypes of those sums. (Correct me if I'm misstating, please, int80_h.)
10:42:28 <int80_h> BMeph: no summing going on
10:42:49 <ksf> I can't believe it. I actually understood some grapefruit source.
10:42:55 <int80_h> I took that to mean adding.
10:42:56 <BMeph> int80_h: Maybe not now, but I meant what you wrote earlier.
10:43:10 <int80_h> grapefruit?
10:43:14 <ksf> summing up, the name is very self-descriptive: you need sugar to make grapefruits paletable.
10:43:33 <ksf> http://haskell.org/haskellwiki/Grapefruit
10:43:57 <Botje> disagree, grapefruit is <3
10:44:16 <ksf> ...builds fine with minor changes and only one gripe on 6.12.3 and with the latest gtk2hs, btw.
10:44:20 <BMeph> int80_h: Sum types are what fancy CS folks call what we do when we make types as "This type  -=> | <=-  That one" -- i.e., the bar denotes a sum type.
10:44:58 <kniu> BMeph, I wasn't responding to int80_h's posts, although it's an interesting coincidence that what he was asking is related to what I asked.
10:45:02 <paper_cc> Botje: any way to get over its learning curve?
10:46:04 <ksf> paper_cc, yes, write a tutorial...
10:46:28 <ksf> actually, the main realisation necessary was getting to terms with the record syntax
10:46:41 * paper_cc even read the original paper to get accustomed with Reactive
10:46:47 <notabel> kniu: the reason is openness
10:46:55 * roconnor wonders why GuiTV gets no love on #haskell
10:47:02 <ksf> ...and ignoring wolfgang's ideosyncratic code layout.
10:47:03 <notabel> when you have a sum type, the universe of alternatives is closed
10:47:10 <ksf> roconnor, does it even compile?
10:47:21 <roconnor> ksf: I used it once 2 years ago
10:47:22 <notabel> when you have a type class, new alternatives can be added at any time
10:47:24 <Botje> paper_cc: i was really talking about the fruit. i don't know the software :)
10:47:31 <roconnor> ksf: it was great
10:47:42 <roconnor> ksf: only gui kit I've ever used in Haskell
10:47:43 <paper_cc> ksf: any tutorials finished so far?
10:47:50 <ksf> nope.
10:48:20 <paper_cc> Botje: :)
10:48:32 <roconnor> ksf: I do admit that it is a little bit limited in scope, but seemed broad enough to cover a whole wide range of little applications.
10:48:57 <BMeph> On another not, for the channel: can TH let you do something like dynamic scope? My pre-conceived example: "dynamic-style" print statements.
10:49:04 <ksf> well, I'm not interested in starting out little and then having to rewrite everything as soon as I hit some ceiling.
10:49:20 <Botje> BMeph: you know ghc already supports dynamic scoping natively?
10:51:01 <kniu> So
10:51:18 <ksf> using something hlist-like on the lhs of a <- is a really, really good idea.
10:51:18 <kniu> If I have open datatypes instead, they can do everything typeclasses do?
10:51:24 <BMeph> Botje: No, I didn't. Or were you referring to "ImplicitParams"?
10:51:44 <int80_h> BMeph: okay new problem, I'm posting ...
10:51:45 <ksf> ...iff you can just ignore fields that you don't want to bind, that is.
10:52:10 <enigmus> Why is atomically :: STM a -> IO a ? Wouldn't it be possible to run a transaction without affecting IO? (I suppose one would need another library, with a monad that doesn't allow i/o, a bit like ST, but with transactions)
10:52:29 <Botje> BMeph: yes
10:52:35 <ksf> which is possible, at least in principle. I'd check if grapefruit actually does that if I wasn't compiling guitv
10:52:52 <monochrom> yes, could replace IO by something more like ST
10:52:59 <ksf> ...forkST
10:53:24 <ksf> hmmm wait couln't it even be STM a -> a ?
10:53:43 <BMeph> Botje: Interesting. Do you know of any examples of use, aside from Oleg/CCShan's paper?
10:54:01 <Botje> nope, sorry :)
10:54:09 <enigmus> ksf: I don't think so, as then the transaction run by atomically couldn't share any state with other transactions, making atomically trivial.
10:54:10 <Botje> just found it in the ghc user's guide and was pleasantly surprisede
10:54:12 <monochrom> no, there are TVars to worry about
10:54:38 <BMeph> enigmus: Haskell Warning: "IO" /= "I/O". ;)
10:54:55 <int80_h> BMeph: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29580#a29590
10:55:06 <ksf> you'd of course need a pure newTVar then, too.
10:55:59 <ksf> iirc the docs mention something about atomically being forbidden inside unsafePerformIO
10:56:06 <ksf> ...but in the context of nesting.
10:56:55 * hackagebot llsd 0.2.0.0 - An implementation of the LLSD data system  http://hackage.haskell.org/package/llsd-0.2.0.0 (BryanOSullivan)
10:57:02 <McManiaC> anyone familiar with HXT/arrow syntax? what am I doing wrong here? http://npaste.de/hk/
10:57:12 <enigmus> BMeph: sure, but ST = IO - I/O is kinda true... (insofar as runST is only possible as you don't touch the outside world like memory in arbitrary ways)
10:58:17 <ksf> STM a -> a would introduce limited observability
10:59:03 <ksf> but at least from afar, it looks like a fine and safe way to introduce nondeterminism into pure computations.
10:59:21 * ksf just realised what herecy he just spew out.
11:00:08 <int80_h> anyone care to look at my update?
11:05:27 <BMeph> int80_h: What you wrote should compile without those error messages (no guarantees of having no errors...), but it no longer indicates the particulars of the subtypes you want in the results, right?
11:06:00 <mm_freak> jaspervdj: hello there…  you may want to add another site to the list of sites using hakyll =)
11:08:50 <notabel> int80_h: i changed your code around some, take a look
11:09:50 <enigmus> Is there a well-established JVM backend for Haskell?
11:10:14 <notabel> enigmus: no
11:10:26 <mm_freak> enigmus: no, but if you want a functional language for the JVM, try scala
11:11:20 <c_wraith> isn't Clojure also on the JVM?
11:11:35 <enigmus> mm_freak: I'm aware of it, thanks.
11:12:31 <mm_freak> i haven't looked at clojure yet, but at least scala looks much more promising than java
11:12:37 <mm_freak> (which isn't that difficult anyway)
11:13:01 * hackagebot shaker 0.3.1 - simple and interactive command-line build tool  http://hackage.haskell.org/package/shaker-0.3.1 (AnthoninBonnefoy)
11:13:19 <njbartlett> Clojure is excellent, but it's dynamically typed. For a Haskell user, Scala is likely to be more attractive.
11:15:07 <int80_h> notabel: thanks
11:17:29 <notabel> so, int80_h, do you actually want a single table that has both Student and Activity keys?
11:17:47 <notabel> similarly, will a single table use both Costs and IDs as Values?
11:18:34 <notabel> I'm wondering if you'd be better served by having a table of type Table Student ID and another of type Table Activity Cost
11:19:40 <int80_h> notabel: I'd also need one for ID and Activity.
11:19:58 <int80_h> I was trying to generalize so that I could make any of those three
11:20:22 <notabel> but you're overgeneralizing; the types you've defined let you have entries in the table that don't make sense
11:20:22 <int80_h> that's what the three functions will do, generate the data for each of those three tables
11:20:38 <notabel> your table will gladly associate a student with a cost, for instance
11:20:45 <chrisdone> why hello
11:20:50 <BMeph> notabel: Unless you've already changed ("broken out") those constructors, "Table Student ID" is a nonsensical "type".
11:20:54 <notabel> you probably want each of those three tables to have different types
11:21:01 <notabel> BMeph: i did
11:21:10 <ben_m> To all who know brainfuck: how would you implement the looping recursively?
11:21:27 <int80_h> ahhh1 my virgin eyes!
11:21:35 <notabel> Student and ID are both newtype'd at this point
11:22:19 <notabel> int80_h: i'm going to take a couple minutes to rewrite your code along the lines i'm indicating, rather than try to talk it out
11:22:20 <BMeph> notabel: Oh, sorry, I missed the link to your re-write. Could you remind it to me? :)
11:22:38 <int80_h> notabel: overgeneralizing. ugh. Okay, I conceed that. 
11:23:42 <notabel> int80_h: also, are you explicitly interested in implementing the table lookup, or would using something like Data.Map make sense?
11:24:35 <notabel> actually, i remember now that lookup on association lists is in the Prelude
11:25:15 * chrisdone pokes Baughn
11:25:30 * Baughn pokes back
11:25:49 <Baughn> chrisdone: Nope, I haven't heard back. From anyone.
11:26:16 <int80_h> notabel: table lookup?
11:26:18 <Baughn> It's getting a bit ridiculous.
11:28:43 <Baughn> chrisdone: ...don't poke and run!
11:32:10 <int80_h> w/b
11:35:24 <notabel> int80_h: sketchy coffeeshop wifi.  i updated your hpaste
11:36:26 <chrisdone> Baughn: hehe, that does seem to be our general correspondance. heard back from X about problem Y? no, not yet
11:36:57 <Baughn> Indeed. *Someone* has to be able to do something..
11:37:08 <Baughn> Maybe I should contact the administration of Yale?
11:37:36 <chrisdone> :D
11:38:01 <chrisdone> maybe Bob Geldof will sort it out
11:38:08 * Baughn is going to ask the nice folks at google if they'd like to host it, anyhow
11:38:52 <chrisdone> the Haskell web site?
11:39:00 <monochrom> class Corr x y where heard_from_about x y :: Bool; heard_from_about _ _ = False
11:39:06 <Baughn> Etc., yes. The parts that go down a lot.
11:39:13 <Baughn> Although they haven't done that much lately..
11:39:25 <Baughn> Eh. Let netcraft confirm.
11:39:35 <Martty> sites.google.com ?
11:39:48 <Baughn> Martty: Not quite what I had in mind.
11:39:49 <chrisdone> Baughn: http://www.mail-archive.com/haskell-cafe@haskell.org/msg78215.html
11:39:50 <int80_h> notabel: processfunc :: [String] -> (Students, ActivityCosts, StudentActivities) doesn't match the function definitions
11:40:18 <Baughn> Ah.
11:40:40 <Baughn> chrisdone: Then I should let Don try to fix it first?
11:40:55 <Baughn> Hm. That was july.. any news?
11:40:56 <chrisdone> Baughn: I don't know. it's been a month since that message
11:41:02 <chrisdone> I haven't heard any news regarding it
11:41:04 <int80_h> notabel: does that not say it returns a tuple with (Students, ActivityCosts,  StudentActivities)
11:41:09 <chrisdone> I asked don in here but he didn't reply
11:41:15 <Baughn> @ask dons What's the news on http://www.mail-archive.com/haskell-cafe@haskell.org/msg78233.html ?
11:41:15 <lambdabot> Consider it noted.
11:41:21 <HskNoob> @type Hash256
11:41:22 <lambdabot> Not in scope: data constructor `Hash256'
11:41:47 <Baughn> HskNoob: \bot doesn't search all of hackage. There are other search engines that do, like the one on hackage, so try there.
11:41:58 <HskNoob> Baughn: thanks!
11:42:09 <notabel> int80_h: well, i'm not really sure what you're trying to do,  i assumed each table's data would be loaded individually, so processfunc would be something like `processfunc recs = (popStudents recs, popActivityCosts recs, popStudentActivities recs)`....are all three tables' data really going to be in one list of strings?
11:42:19 <notabel> or are they actually coming from different flatfiles?
11:42:44 <int80_h> notabel: no, only one function will ever be called per use of the utility. 
11:42:56 <int80_h> notabel: yes depending on which flatfile one processes
11:42:58 <Baughn> chrisdone: Netcraft confirms: It's still running the same bloody thing it's been running for years.
11:43:10 <int80_h> notabel: one will call the utility with a name signifying what is being processed.
11:43:16 <Baughn> chrisdone: Also, site rank 40,480. That's higher than I expected..
11:43:19 * chrisdone protracted sigh
11:43:29 <notabel> okay.  what's the use of the ProcessData type?
11:43:30 <Twey> @hayoo Hash256
11:43:31 <lambdabot> Unknown command, try @list
11:43:42 <Twey> I thought there was a @hayoo command in λb
11:44:02 <Baughn> So did I. Maybe there was.
11:44:36 <int80_h> notabel: flatfile holds the file to be processed. processFunc will hold the function doing the processing
11:44:46 <Baughn> chrisdone: Oh, and the DNS entry is a mite broke. RDNS points to bugs.haskell.org.
11:45:25 <notabel> int80_h: what i mean is what are you doing with the datastructure?  whare will be be created, how will it be passed around, etc?  right now i don't really see what it's usefulness is
11:45:30 <chrisdone> Baughn: haha, fitting
11:47:31 <int80_h> notabel: well, I wanted a way to represent a function that could be one of three functions, and I thought it made sense to tie that in with the file the function would be processing
11:47:44 <int80_h> notabel: I just copied what I saw in RAH
11:49:54 <int80_h> notabel: I would be putting the name of the file on the command line in processFunc, that name will be the name of the function being called, I would then pass in flatfile as a paramter to that function.
11:51:00 <int80_h> notabel: I didn't mean "name of the file" I meant "name of the utility". The utility will have three softlinks. Each softlink will be the name of the processing function.
12:06:27 <osaunders> Anyone in Edinburgh? http://www.meetup.com/ed-lambda/
12:07:06 <roconnor> osaunders: is that where Epigram is being developed?
12:07:33 <osaunders> roconnor: I haven't heard of that. First Google hit hints at Bristol though. 
12:07:39 <dom96> Is there a way i could convert escaped characters in strings into the characters? for example if i have a string which is "won\x27t" how can i convert that to "won't" ?
12:08:04 <dolio> > "won\x27t"
12:08:04 <lambdabot>   "won't"
12:08:41 <osaunders> "\x60"
12:08:44 <osaunders> > "\x60"
12:08:45 <lambdabot>   "`"
12:08:51 <osaunders> > "\\x60"
12:08:52 <lambdabot>   "\\x60"
12:08:55 <copumpkin> > read "\"won\\x27\"" :: String
12:08:55 <lambdabot>   "won'"
12:09:32 <dom96> yeah, i can't really use read i don't think.
12:09:54 <dom96> I have JSON data. Which contains \x27 etc.
12:10:33 <dolio> > let s = "won\\x27t" in (s, read $ '"':s++"\"")
12:10:34 <lambdabot>   ("won\\x27t",*Exception: Prelude.read: no parse
12:10:42 <dolio> > let s = "won\\x27t" in (s, read $ '"':s++"\"" :: String)
12:10:42 <lambdabot>   ("won\\x27t","won't")
12:12:20 <dom96> > read "{\"blah\": \"won\\x27tt\")" :: String
12:12:21 <lambdabot>   "*Exception: Prelude.read: no parse
12:12:35 <aristid> dom96: did you mean to read JSON data?
12:12:46 <aristid> :t readJSON
12:12:47 <lambdabot> Not in scope: `readJSON'
12:12:55 <aristid> which lambdabot does not have available
12:13:02 <dom96> If i read that with the json package, it complains about the \x27
12:13:57 <dom96> Left "Unable to parse JSON String: invalid escape char: 'x'"
12:13:57 <dolio> Is that not valid json?
12:15:00 <dom96> i don't know.
12:15:01 <aristid> dom96: Left? which function are you using to parser? decode gives Error, not Left
12:15:25 <dolio> If it isn't, then you should probably complain to whomever's responsible for the invalid generator.
12:15:45 <aristid> dom96: this parses: "{\"blah\": \"won\\u0027tt\"}"
12:15:55 <aristid> and according to http://json.org, \x is not valid
12:15:56 <dolio> If it is, then you can complain at the json parsing library.
12:16:32 <aristid> beautiful syntax diagrams \o/
12:20:07 <lispy> Haskell lists are singly linked.  I was wondering, are there cases where it's worse to reverse the list than to have a doubly linked list?
12:20:45 <Cale> lispy: Doubly linked lists are no better. Adding an element *anywhere* in a doubly linked list would be O(n).
12:21:05 <aristid> Cale: huh?
12:21:19 <aristid> i thought that was O(1) too
12:21:21 <Jafet> That is, if it's anywhere you don't already know.
12:21:36 <Jafet> But a smart bloke like knuth would know, for example.
12:21:45 <Cale> Because every list cell must change to reflect the fact that from it you can get to the new element.
12:21:48 <dom96> aristid: oh
12:22:08 <dom96> In any case. Is there a way i can convert those \x to proper characters?
12:22:20 <aristid> dom96: \xAA becomes \u00AA
12:22:29 <Cale> So you end up "copying" the whole list.
12:22:41 <Cale> (The whole spine of the list is replaced with a new one)
12:22:56 <aristid> Cale: ah, because it's pure and stuff
12:22:56 <Jafet> Cale: would a zipper work?
12:22:59 <dom96> aristid: Are you saying i should replace them all?
12:23:11 <aristid> dom96: if you want to be compliant with JSON, yes
12:23:47 <Cale> Jafet: Well, a zipper is good for supporting O(1) insertion of elements at an arbitrary point in the structure.
12:23:48 <dom96> well it's not my code, i get it from google's API.
12:24:12 <Cale> (But it's O(n) in general to move the insertion point where you want it, with a standard zipper)
12:24:23 <Cale> If you want fast operations, you really need a tree structure.
12:25:06 <Jafet> If using a pure language, that's true
12:25:51 <Cale> This is #haskell of course ;)
12:26:54 <SecondOrderSalad> what was the task? (for the zipper)
12:27:08 <Cale> task?
12:27:16 <SecondOrderSalad> the problem to be solved :)
12:27:24 <copumpkin> SecondOrderSalad: that's first order?
12:27:29 <Cale> We're talking about general data structures. :)
12:27:34 <SecondOrderSalad> ah
12:27:34 <NaturalTransform> dammit
12:27:58 <copumpkin> I like big monads and I cannot lie!
12:28:06 <Cale> lispy asked if sometimes it's better to have a doubly linked list than to reverse a list
12:28:06 <NattransSalad> lol
12:28:08 <ben_m> You other functors can't deny!
12:28:13 <chrisdone> hahaha
12:28:20 <SecondOrderSalad> NattransSalad: I have trouble parsing your query
12:28:27 <NattransSalad> I mean
12:28:31 <NattransSalad> what's first order, sorry
12:28:48 <SecondOrderSalad> FunctorSalad?
12:30:58 <copumpkin> oh okay
12:31:54 <lispy> Cale: I see.  Although, I was thinking the list would already be built and you want to traverse it.  But, let's say you want to traverse it in reverse.  So wit the singlely linked list you have to have enough memory to reverse the list and then follow it in the new order.  With a doubly linked list you traverse to the end and then come back.  But, the memory needed is no better, right?
12:32:46 <fergie> What sort of thing causes an "unknown symbol" error?
12:32:48 <Cale> Basically, yeah.
12:33:35 <copumpkin> fergie: not passing --make to ghc
12:34:02 <fergie> copumpkin: this is in ghci
12:34:35 <copumpkin> give us more information then :P
12:37:32 <SecondOrderSalad> maybe reinstall the package in question
12:38:03 <SecondOrderSalad> sounds like some library it is linked against disappeared in the meantime (I Am Not A Linker Expert)
12:38:22 <copumpkin> we shouldn't have to guess at what the problem is from an unnecessarily vague description, honestly :P
12:38:57 <fergie> copumpkin: There is no problem loading everything. When I call the main function I get an unknown symbol error for one of my own packages
12:39:11 <fergie> What information would you like?
12:39:38 <fergie> SecondOrderSalad: I've reinstalled everything I can think of
12:40:42 <copumpkin> does the package you get a symbol error for do anything linky of its own? is it a binding to an external library or something?
12:41:03 <fergie> no
12:41:49 <fergie> My package uses System.Process to call some external python programs. 
12:44:12 <copumpkin> hmm
12:48:29 <BrianHV> this is probably a trivial question, but I can't figure it out.  if I have a function  a -> State s a, and I have [a], how do I map the function over the list
12:48:58 <mauke> map function list
12:49:30 <Heffalump> what you probably want is mapM
12:49:46 <Heffalump> though mauke's answer is technically correct
12:49:52 <BrianHV> Heffalump: that looks promising
12:50:08 <BrianHV> the technically correct answer hasn't been compiling then. ;)
12:50:22 <Heffalump> well, it would give you a result of type [State s a]
12:50:29 <Heffalump> which is valid, but not necessarily much use
12:50:36 <Heffalump> mapM gives you State s [a]
12:50:42 <ben_m> BrianHV: Your question was technically incorrect then :P
12:51:20 <BrianHV> I'm wrong... the map call alone does compile...
12:51:20 <Saizan> if you don't have variables ranging over functions but you want e.g. to deduce "l = x:_" from "head l = x", is that still higher order unification?
12:52:45 <notabel> BrianHV: you probably want mapM
12:52:55 <aristid> @src mapM
12:52:56 <lambdabot> mapM f as = sequence (map f as)
12:53:13 <Heffalump> you can't dduce that. An alternative would be l = [] and x = error "..."
12:53:19 <aristid> :t ((.).(.)) sequence map
12:53:20 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
12:53:59 <aristid> @let (.:)=(.).(.)
12:54:00 <lambdabot>  Defined.
12:54:01 <ben_m> Is ((.).(.)) a common idiom? I see it all the time in here ... but it's just so damn ugly.
12:54:04 <Jafet> Is that even called unification?
12:54:13 <aristid> ben_m: well, this is better:
12:54:17 <aristid> :t sequence .: map
12:54:18 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
12:54:50 <aristid> ben_m: http://conal.net/blog/posts/semantic-editor-combinators/
12:54:59 <aristid> conal does not like (.:) tho
12:55:03 <Saizan> Heffalump: right, head is not a good example, let's say i have only total functions, and i'm ok with getting partial information if they are not injective
12:55:10 <ben_m> Cool, reading :)
12:55:16 <Cale> BrianHV: To just restate something people have already said, map f xs will give you a list of stateful actions, without running any of those actions. mapM f xs will give you a single action which, when run, will run each of the actions in turn, collecting a list of the results
12:55:37 <Cale> BrianHV: (in the order that they occurred in the list, rather than some other random order, of course :)
12:56:58 <BrianHV> Cale: mapM is indeed what I want... except I now can't figure out how to get my state into it
12:57:10 <aristid> :t mapM
12:57:10 <PowderBot2> Error: /bin/sh: hoogle: command not found
12:57:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:57:31 <copumpkin> whose bot is tat?
12:57:38 <monochrom> hmm, second order burrito wrapper
12:57:39 <geheimdienst> :t map
12:57:39 <PowderBot2> Error: /bin/sh: hoogle: command not found
12:57:40 <Nibble> > map (+) [1,2,3]
12:57:40 <PowderBot2> Error: /bin/sh: mueval: command not found
12:57:41 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:57:41 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
12:57:41 <lambdabot>    arising from a use of `...
12:57:42 <aristid> BrianHV: oh, because you already have a State?
12:57:51 <Cale> BrianHV: Well, you're building up some computation of type State s t, and you'll eventually use runState to supply an initial value of type s
12:57:52 <BrianHV> aristid: yeah
12:58:05 <monochrom> eh? please don't let a bot run if all it does is "error"
12:58:10 <Cale> (and get out a final state of type s, and result of type t
12:58:12 <Cale> )
12:58:28 <aristid> :t foldr (=<<)
12:58:28 <copumpkin> monochrom: was just about to kick it :P
12:58:29 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
12:58:34 <aristid> BrianHV: is this type better?
12:59:27 * BMeph waits for monochrom to 1) Kick it; 2) Chill out... ;)
12:59:47 <aristid> BrianHV: no, reading your question again, mapM is what you want
13:00:15 <BrianHV> mapM (runState state . convertMessage) evs  -- seems to typecheck, at least so far
13:01:19 <BrianHV> so, here's my situation... I'm using PortMidi, which gives me a [PMEvent].  I have a function convertMessage :: PMEvent -> State s PMEvent
13:01:45 * BMeph offers this "nugget" of wisdom: 'undefined' ALWAYS type-checks. Doesn't mean that's what you want, though....
13:01:53 <dom96> what's the best way to regex replace ?
13:01:59 <BrianHV> so every time I get a new list of PMEvents, I need to call convertMessage on all of them, keeping state between calls
13:04:12 <dom96> nvm
13:04:33 <BMeph> dom96: Just curious, but...what do you mean by "regex replace"?
13:05:01 <BMeph> dom96: ...okay, nvm'ing. :)
13:05:03 <dom96> I was looking for Text.Regex.subRegex
13:23:30 <mmmulani> how can I use an IORef in my module as a particular value?
13:23:50 <mmmulani> like, a top level definition as a IORef
13:23:56 <Twey> unsafePerformIO
13:24:01 <Twey> But you're probably Doing It Wrong
13:24:02 <mmmulani> oh god, actually?
13:24:25 <Twey> Well, just for the creation of the IORef
13:24:31 <mmmulani> I'm doing stuff in the IO monad, and I don't want to wrap it one more level
13:24:54 <monochrom> you must choose between unsafePerformIO and wrap more
13:25:01 <mmmulani> gah
13:25:02 <notabel> mmmulani: http://www.haskell.org/haskellwiki/Top_level_mutable_state discusses the tradeoffs in Haskell for this currently
13:25:05 <Twey> I'm not sure I understand what you're getting at, but it sounds like you might want ‘join’
13:25:37 <Twey> The point with having global IORefs is that you don't have to pass them around, not that they're wrapped in an extra layer of something
13:25:43 <monochrom> usually "myfunc :: IORef Bool -> IO stuff" isn't that bad.
13:26:55 <Twey> Prepose is very nice.  Check out http://okmij.org/ftp/Haskell/types.html#Prepose
13:26:58 <monochrom> the best choice is the choice you didn't make
13:27:35 <Cale> mmmulani: Just passing an IORef, or bundle of IORefs is not so hard, usually
13:27:52 <mmmulani> Cale: yeah, I'm not going for any passing
13:28:11 <Cale> mmmulani: If you have more than one, bundle them into a single datastructure to make it easy to pass them around to where you need them.
13:28:17 <mmmulani> bleh
13:28:20 <mmmulani> I don't want to do any passing around
13:28:29 <Cale> Being explicit about it helps to make your program easy to understand, and makes it more modular.
13:28:53 <Cale> (Because you're not stuck with one global resource forever.)
13:29:58 <Cale> and someone reading the code can see which parts of the code depend on that configuration
13:30:39 * hackagebot HTF 0.3.5.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.3.5.0 (StefanWehr)
13:31:05 <dom96> :t matchRegex
13:31:06 <lambdabot> Not in scope: `matchRegex'
13:32:45 <dom96> matchRegex (mkRegex "\\(x([0-9A-Fa-f]{2}))") "blah\x27et" - Why does that return Nothing?
13:32:53 <dom96> shouldn't that match that \x27 ?
13:33:09 <mauke> > length "\x27et"
13:33:10 <lambdabot>   2
13:33:12 <Saizan> Jafet: it should fall under "equational unification" it seems
13:33:42 <Cale> mmmulani: If you want to be principled about it, there's also the possibility of creating a new monad built in terms of IO which carries around the references to your additional state. I wouldn't do it just on a whim though.
13:33:44 <mauke> dom96: I'm surprised that even compiles
13:33:55 <dom96> mauke: matchRegex (mkRegex "\\(x([0-9A-Fa-f]{2}))") "blah\\x27et" doesn't match either
13:34:21 <Cale> mmmulani: It's best to have written some code which does explicit passing of that state and see exactly what operations are needed, and get a feel for what language you're defining.
13:34:26 <mauke> dom96: that looks like you're trying to match a '(' to me
13:34:50 <dom96> mauke: no, ( ) is a group
13:35:05 <mauke> dom96: the first thing in your regex is \(
13:35:09 <geheimdienst> he means that "\\(" will match a (
13:35:29 <dom96> \\ = \ ?
13:35:29 <geheimdienst> 'cause ghc turns \\ into \
13:35:35 <dom96> oh right
13:35:39 <Cale> > length "\\"
13:35:40 <lambdabot>   1
13:35:50 <dom96> ahh yes
13:35:51 <geheimdienst> > "\n"
13:35:52 <lambdabot>   "\n"
13:35:53 <dom96> \\\\ works
13:35:55 <monochrom> > text "\\"
13:35:56 <lambdabot>   \
13:36:04 <geheimdienst> > text "\n"
13:36:05 <lambdabot>  Terminated
13:36:07 <dom96> thanks.
13:36:07 <monochrom> > text "hi\nhello"
13:36:08 <lambdabot>   hi
13:36:08 <lambdabot>  hello
13:36:08 <ben_m> @src text
13:36:08 <lambdabot> Source not found.
13:37:36 <medfly> > text (cycle " \n")
13:37:41 <lambdabot>   mueval: ExitFailure 1
13:37:45 <medfly> aww
13:38:01 <medfly> > text (take 20 (cycle " \n"))
13:38:23 <monochrom> killed
13:38:31 <monochrom> murderer!
13:38:36 <medfly> !!!1
13:40:00 <medfly> @botsnack
13:40:00 <lambdabot> :)
13:40:03 <medfly> > text (take 20 (cycle " \n"))
13:40:08 <medfly> :(
13:40:44 * hackagebot protocol-buffers 1.7.9 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-1.7.9 (ChrisKuklewicz)
13:40:46 * hackagebot protocol-buffers-descriptor 1.7.9 - Text.DescriptorProto.Options and Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-descriptor-1.7.9 (ChrisKuklewicz)
13:41:35 <monochrom> > text "\nhello\nhi\n"
13:41:35 <lambdabot>   hello
13:41:36 <lambdabot>  hi
13:41:49 <monochrom> it erases things
13:41:51 <ben_m> @info text
13:41:51 <lambdabot> text
13:42:03 <monochrom> text is from the pretty-printer lib
13:42:03 <geheimdienst> > text "\n"
13:42:04 <lambdabot>  Terminated
13:42:27 <geheimdienst> > text "\n\n\”"
13:42:28 <lambdabot>   mueval-core: mueval-core: panic! (the 'impossible' happened)
13:42:28 <lambdabot>    (GHC versio...
13:42:31 <geheimdienst> > text "\n\n\n"
13:42:32 <lambdabot>  Terminated
13:42:45 * hackagebot hprotoc 1.7.9 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-1.7.9 (ChrisKuklewicz)
13:43:05 <monochrom> you must give it some non-blanks for meaningful results
13:43:16 <geheimdienst> i noticed :)
13:43:39 <geheimdienst> @src text
13:43:40 <lambdabot> Source not found. Wrong!  You cheating scum!
13:44:00 * monochrom is an expert in robot psychology
13:45:15 * monochrom 's role model is Susan Calvin
13:48:18 <monochrom> Asimov couldn't see US Robotics turning into a modem manufacturer :)
13:52:22 <Colours> does show work on lists
13:52:40 <kaol> > show [1,2,3]
13:52:41 <lambdabot>   "[1,2,3]"
13:52:54 <Colours> like if I have a Show instance for a type and I use show x where x is a list of that type, will it work?
13:53:14 <Colours> x is also an algebraic type if that is relevant
13:54:34 <Cale> Colours: yes
13:54:35 <sepp2k> Colours: There's an instance Show a => Show [a], so yes, it will work.
13:54:38 <roconnor> Colours: yes
13:54:55 <Colours> oh cool thanks (sorry for asking what is probably a silly question 3:)
13:55:03 <Cale> Colours: It's not a problem :)
13:55:14 <roconnor> Colours: if you override showList for x you can even change how lists of x are displayed
13:55:24 <roconnor> this is done with Char for instance
13:55:32 <Cale> > ['a','b','c']
13:55:33 <lambdabot>   "abc"
13:55:51 <Colours> ooh
13:56:41 <roconnor> > let n = 10 in n * n * n * n * n * n * n * n * n * n
13:56:42 <lambdabot>   10000000000
13:56:52 <roconnor> dolio: ^^
13:57:50 <dolio> > let n = 10 in n * n * n * n * n * n * n * n * n * n :: Natural
13:57:50 <lambdabot>   Not in scope: type constructor or class `Natural'
13:57:55 <dolio> > let n = 10 in n * n * n * n * n * n * n * n * n * n :: Nat
13:57:55 <lambdabot>   Not in scope: type constructor or class `Nat'
13:57:57 <roconnor> oooh.
13:58:59 <roconnor> dolio: I think, despite using S and 0 in the theory, in the impelemenation one sould use binary or some such format.
13:59:13 <roconnor> dolio: I know that seems unmotiviated
13:59:40 <dolio> What if we're not working with natural numbers, but lists, or trees, or something.
14:00:11 <roconnor> they all are just abstract versions of binary numbers :D
14:00:21 <roconnor> I guess
14:00:31 <roconnor> again, I'm being fuzzy, and am sorry about that.
14:01:26 <dolio> My point is that you can just as easily build a list with 10 billion elements as the natural number 10 billion.
14:01:37 <dolio> And overflow the stack with that.
14:02:00 <roconnor> dolio: not without something like exp
14:02:05 <HskNoob> q: Call to round returns error: No instance for (RealFrac Integer)   Is there a round function accepting Integer?
14:02:19 <roconnor> dolio: well, that would be the idea at least 
14:02:25 <roconnor> I don't know if it is true
14:02:36 <roconnor> dolio: though the normal encoding of lists that i know of use exp.
14:03:13 <notabel> HskNoob: what would that function do?  do you want a function that rounds an integer to a given number of significant figures?
14:03:49 <dolio> roconnor: Does Nelson's stuff only apply if you encode everything as natural numbers directly?
14:03:55 <HskNoob> notabel: I want to round a div between to Integers
14:04:03 <HskNoob> s/to/two/
14:04:03 <roconnor> dolio: well, he only talks about natural numbers
14:04:10 <roconnor> dolio: so I guess the answer is yes
14:04:15 <dolio> [] and (a:) are not analogous to Z and S?
14:04:26 <roconnor> HskNoob: use div
14:04:33 <roconnor> > 3 `div` 2
14:04:34 <dolio> So I cannot necessarily write functions with them, and (++) and... concatMap?
14:04:34 <lambdabot>   1
14:04:47 <dolio> And be assured that they're "total"?
14:04:49 <roconnor> dolio: ++ is probably okay
14:05:12 <roconnor> and so is concat I think
14:05:20 <HskNoob> roconnor: going to try that, thx - learning everyday :]
14:05:30 <dolio> Well, forget about the map part.
14:05:44 <roconnor> sequence, not so much :D
14:06:09 <dolio> Just 'l * r = r ++ r ++ r ++ ... length l times ... ++ r
14:06:35 <roconnor> dolio: that "length l times" is not an allowed operation I would think.
14:06:38 <roconnor> at least not as such
14:06:51 <dolio> So multiplication is not allowed when it's lists.
14:07:27 <roconnor> not like that I don't think
14:08:29 <roconnor> dolio: again, I don't really understand Nelson
14:10:58 <ologNation> >let d = fromJulianYearAndDay 2010 0
14:11:06 <ologNation> d
14:11:09 <ologNation> > print d
14:11:10 <lambdabot>   <IO ()>
14:11:13 <roconnor> > let d = fromJulianYearAndDay 2010 0
14:11:14 <lambdabot>   not an expression: `let d = fromJulianYearAndDay 2010 0'
14:11:18 <roconnor> > let d = fromJulianYearAndDay 2010 0 in d
14:11:19 <lambdabot>   Not in scope: `fromJulianYearAndDay'
14:11:40 <ologNation> >import Data.Time.Calendar.Julian
14:11:48 <roconnor> > let d = Data.Time.Calendar.Julian.fromJulianYearAndDay 2010 0 in d
14:11:49 <lambdabot>   Not in scope: `Data.Time.Calendar.Julian.fromJulianYearAndDay'
14:11:56 <ologNation> fromJulianYearAndDay 2010 0
14:11:58 <roconnor> no go
14:12:04 <ologNation> ah well.  
14:12:14 <ologNation> My question is: why is this January 14? 
14:12:41 <ologNation> All that I need to do is construct an object of type Day. 
14:12:45 <roconnor> Prelude Data.Time.Calendar> let d = Data.Time.Calendar.Julian.fromJulianYearAndDay 2010 0 in d
14:12:46 <roconnor> 2010-01-14
14:12:47 <geheimdienst> there's some difference between the julian and the normal (gregorian) calendar
14:12:54 <ologNation> There you go. 
14:13:07 <ologNation> oh. 
14:13:15 <geheimdienst> possibly the offset is 13 days or something ... wikipedia can probably help you
14:15:24 <djahandarie> copumpkin, yeah those numbers are fabricated for the moment, just had to put something there :P
14:15:28 <roconnor> Prelude Data.Time.Calendar> let d = Data.Time.Calendar.Julian.fromJulianYearAndDay 2010 1 in d
14:15:29 <roconnor> 2010-01-14
14:15:40 <lispy> cabal init creates a Setup.hs file
14:15:43 <lispy> that seems broken
14:15:56 <roconnor> ologNation: it would seem that Julian calenders have leap years on all centenials
14:16:01 <monochrom> it is very hard to write a broken Setup.hs, you know
14:16:18 <lispy> monochrom: build type simple shouldn't have a Setup.hs
14:16:21 <monochrom> anyway I read the generated Setup.hs myself and it is not broken
14:16:21 <njbartlett> Hmm getting this error while compiling qtHaskell: "ld: scattered reloc r_address too large for inferred architecture i386". How badly am I screwed?
14:16:21 <geheimdienst> lispy, does it write build-type Simple or Custom?
14:16:26 <lispy> geheimdienst: simple
14:16:56 <monochrom> build type simple should have a Setup.hs for those who don't have cabal-install
14:16:58 <geheimdienst> then it's indeed misleading. afaik the Setup.lhs will get ignored with Simple
14:18:18 <ologNation> roconnor, Thanks for the tip. 
14:18:23 <ologNation> Gregorian is working for me now. 
14:18:28 <McManiaC> is "(True && False) || True" or "True && (False || True)" correct?
14:18:42 <monochrom> both are correct
14:18:54 <roconnor> > ((True && False) || True, True && (False || True))
14:18:57 <lambdabot>   (True,True)
14:19:22 <burp> > True && False || True
14:19:24 <lambdabot>   True
14:21:02 <McManiaC> burp: is "Tree && False" or "False || True" evaluated first?
14:21:47 <monochrom> && first
14:22:03 <monochrom> which is a misleading way to put it
14:22:16 <monochrom> > True || (undefined && undefined)
14:22:16 <lambdabot>   True
14:22:24 <McManiaC> ah ok
14:22:26 <monochrom> parsing rather than order
14:22:31 <ologNation> Prelude Data.Time.Calendar> let d = Data.Time.Calendar.Gregorian.fromGregorianYearAndDay 2010 1 in d
14:23:01 <monochrom> kindergarten merges "order" and "parsing" because you were simple-minded kids
14:23:20 <ologNation> Prelude Data.Time.Calendar> let d = Data.Time.Calendar.Gregorian.fromGregorian 2010 1 1 in d
14:23:27 <bos> does stephen blackheath hang out here?
14:23:58 <monochrom> but in all honesty, even in the school setting, 0*(38237493+39483) no one really evaluates 38237493+39483 first
14:24:42 <McManiaC> monochrom: true :)
14:26:53 <ben_m> Is this true, conceptually: "Monads are for composing things inside a context/container"
14:26:58 <bos> Axman6: ^^^
14:27:03 <sproingie> ben_m: that's one thing they're good for
14:27:12 <sproingie> ben_m: it's certainly not true of all monads
14:27:13 <ben_m> What else? :)
14:27:24 <sproingie> monads are good for composing computations full stop
14:27:35 <ben_m> I'm trying to get an understanding when to use Monads, when to use Applicative and when to use Arrows
14:28:39 <sproingie> the monad typeclass expresses composition, the monad laws ensures it makes sense, but that's about it
14:29:11 <monochrom> natural language classes expose grammars (or sub-grammars) to kids just fine. perhaps it is math teachers who are simple-minded in hiding parsing behind evaluation.
14:30:55 <ben_m> sproingie: I see! Can you give me the same kind of summary about Applicative and Arrow? :D
14:31:12 <ben_m> I don't understand when I'd use Applicative instead of Monad, for example.
14:32:19 <BONUS> well monads are for when you want the results of previous actions to influence the next one
14:32:43 <monochrom> use Monad when you use "join". in do-notation, use Monad when you use the like of "x <- m; y <- x"
14:32:44 <ben_m> Right now I use a tiny bit of Applicative for a pointfree-ish replacement of my Monad code
14:32:53 <BONUS> like when you have a chain of Maybe values and each one depends on the result of the previous one to decide if it's gonna be a Just or a Nothing
14:33:08 <BONUS> with Applicatives, the values themselves don't rely on each other that much
14:33:38 <BONUS> applicatives are just about f <$> x <*> y <*> ..., so applying a function to several values with effects
14:33:58 <BONUS> but they're not aware of each other, in a sense
14:34:03 <ben_m> I see :)
14:34:22 <ben_m> I used <$> ... <*> before, but your explanation makes a lot of sense.
14:34:22 <BONUS> > (+) <$> Just 9 <*> Just 10
14:34:23 <lambdabot>   Just 19
14:34:40 <ben_m> That's what I meant with "pointfree-ish" replacement of my Monad code
14:34:45 <BONUS> yeah
14:34:57 <fabjan_> @pl \c -> (c `mod` 10) + (c `div` 10)
14:34:57 <lambdabot> liftM2 (+) (`mod` 10) (`div` 10)
14:34:58 <ben_m> Instead of x <- Just 9; y <- Just 10; return $ x + y
14:35:14 <BONUS> but the point is that these Just values interact more with the function (+) than with each other
14:35:25 <BONUS> but with applicatives you can't do stuff like
14:35:33 <bos> preflex: seen blackh
14:35:33 <preflex>  blackh was last seen on #haskell 3 days, 19 hours, 47 minutes and 20 seconds ago, saying: McManiaC: I like your "wall of code" effect there, too
14:35:48 <BONUS> x <- m; if x > 9 then Just (x+1) else Nothing
14:36:02 <bos> preflex: tell blackh i found a nasty concurrency bug in hexpat
14:36:02 <preflex>  Consider it noted.
14:36:24 <BONUS> here, the next action relies on the result of the previous one
14:37:38 <ologNation> I have an easy question. 
14:37:41 <sproingie> applicatives basically can't rely on the previous computation
14:37:57 <ben_m> Got it :)
14:38:02 <ologNation> When the members of a datatype have names, how can I access the members one at a time by name? 
14:38:08 <ologNation> The idea is to avoid pattern matching. 
14:38:11 <sproingie> the reliance on previous computations is what makes monads suited for sequencing, which is a big reason IO uses it
14:38:11 <mauke> ologNation: I have an equally easy yet wrong answer
14:38:23 <ologNation> mauke, Go ahead. 
14:38:29 <BONUS> ologNation: use record syntax
14:38:34 <mauke> just use perl to preprocess your file
14:38:47 <ologNation> I think it's record syntax that I'm talking about. 
14:39:00 <ologNation> I know how to declare a datatype this way, but I don't know how to *use* it. 
14:39:20 <BONUS> well if you have data Foo = { foo :: Int, bar :: Bool }
14:39:27 <ologNation> BONUS, yeah? 
14:39:38 <BONUS> foo and bar are functions of type Foo -> Int and Foo -> Bool
14:39:39 <ologNation> It's not Foo.bar..
14:39:40 <BONUS> respectively
14:39:57 <ologNation> Oh yeah? 
14:40:04 <ologNation> so foo f 
14:40:06 <ologNation> is an int
14:40:08 <BONUS> yup
14:40:09 <ologNation> where f is a Foo. 
14:40:14 <ologNation> Let's see. 
14:40:15 <BONUS> that's a bingo!
14:40:25 * ologNation is trying out BONUS 's idea. 
14:42:22 <ben_m> BONUS is the _why of Haskell, without all the magic disappearing.
14:42:39 <BONUS> hehe, or maybe he is the me of ruby, who knows!
14:42:42 <ben_m> He might not look like Jack Black.
14:42:50 <ben_m> Who knows!
14:42:56 <BONUS> _who knows
14:43:16 <ben_m> Who knows what _who knows? He's gone!
14:43:32 <noteventime> Is that whole thing still a mystery? 
14:44:16 <monochrom> what mystery?
14:44:21 <BONUS> the dude just gone disappeared, and thats about it i think
14:45:06 <noteventime> BONUS: Didn't the whole tutorial and a number of other websites related to the person also disappear at the time
14:45:15 <Cale> _who knows _why
14:45:29 <BONUS> yes, causing my site to have a broken link for quite some time until someone warned me about it
14:45:50 <ben_m> Wait, is _who another person?
14:45:58 <BONUS> no, that was a joke :)
14:46:01 <ben_m> I thought so.
14:47:29 <noteventime> Hmm, are there any high level interfaces to hscurses or is vty the library to use?
14:48:28 <BONUS> woot, finally finished setting up my blog, now all i have to do is fill it with content
14:48:43 <ben_m> But does it look good in IE?
14:49:00 <copumpkin> BONUS: are there unicorns and rainbows and list monsters?
14:49:01 <monochrom> make sure it looks terrible in IE
14:49:03 <BONUS> i havent tried but from the html/css that i used i figured it would look horrible
14:49:07 <BONUS> in ie
14:49:19 <ben_m> That's a ... BONUS.
14:49:22 * ben_m puts on glasses
14:49:22 <monochrom> in fact, follow my example: http://www.vex.net/~trebla/haskell/index.xhtml
14:49:25 <BONUS> if anyone has IE y'all can try it: learnyouahaskell.com/blog
14:49:41 <monochrom> make sure it looks _nothing_ in IE
14:49:48 <ologNation> Anyone know how to convert from Int to Integer? 
14:49:58 <monochrom> fromIntegral converts
14:49:59 <ologNation> BONUS, Is learnyouhaskell your website?
14:50:07 <BONUS> ologNation: yup
14:50:15 <ologNation> I *LOVE* that website!
14:50:20 <BONUS> thanks! :)
14:50:22 <ologNation> good job on the design.
14:50:33 <djahandarie> BONUS, haha crazy layout for that blog
14:50:40 <BONUS> :)
14:51:33 <monochrom> disturbing
14:52:02 <monochrom> but what do I know, perhaps this is exactly what the current 20-year-old calibre wants.
14:52:03 <ben_m> That ape stares right into your soul.
14:52:08 <djahandarie> I have to say that font is near impossible to read though lol
14:52:09 <BONUS> it reflects my continually deteriorating mental condition
14:52:36 <djahandarie> Don't worry it happens to us all in #haskell
14:53:01 <ologNation> Good use of color. 
14:53:08 <ologNation> And I love the drawings. 
14:53:27 <monochrom> see? can't believe kids today
14:53:43 <BONUS> haha, move aside old folks!!
14:53:48 <dom96> Is there a way i can get the line number at which runtime errors occur? for example 'elysia: Prelude.(!!): index too large'
14:54:43 <monochrom> use Control.Exception.assert
14:55:41 <jaspervdj> mm_freak: I'm so sorry, I was afk
14:55:51 <monochrom> slow but works: assert (n < length xs) (xs !! n)
14:56:10 <jaspervdj> (and I have to go now... if you read this, feel free to ping me about the site at jaspervdj at gmail dot com)
14:56:13 <dom96> is assert really the best way?
14:56:41 <monochrom> yes
14:56:43 <BONUS> preflex: seen mmorrow
14:56:43 <preflex>  mmorrow was last seen on #ghc 224 days, 18 hours, 58 minutes and 58 seconds ago, saying: * mmorrow is rtfm'ing
14:56:52 <dom96> monochrom: ok, thanks.
14:56:58 <notabel> dom96: the Prelude functions aren't annotated, so you either have to use assert yourself or hide the prelude functions and use versions redefined to give locations
14:57:06 <monochrom> no, I spoken too soon. the best way is mechanically prove your program correct.
14:57:14 <noteventime> monochrom: Can't you use ghci with a backtrace or something?
14:57:16 <monochrom> assert is just second best to that.
14:57:37 <monochrom> oh, debugger is the third best way
14:58:02 <dom96> I admit i wrote the module a bit too quickly. Well thanks for the help. assert will come in handy.
14:58:41 <monochrom> even back in imperative land, you wrote a lot of asserts, preconditions, postconditions, invariants anyway
14:59:10 <BONUS> yeah, be very afraid of !! and head
15:00:16 <monochrom> these asserts enjoy a smooth transition from runtime-check to static verification.
15:01:11 <dom96> I got a bit mad at parsing JSON and took the quick way of parsing it, so i didn't check the length of the lists.
15:01:15 <noteventime> Would making "error" report file and line number go against the report (no pun intended)?
15:02:40 <notabel> noteventime: not a bit, but it's not necessarily easy to implement
15:02:59 <noteventime> notabel: Why would it be harder for error than for assert?
15:03:38 <noteventime> Or did I misunderstand assert?
15:03:41 <monochrom> not harder. just not done.
15:04:12 <monochrom> "error" enjoys a much longer history than "assert"
15:04:15 <notabel> the Report actually explicitly encourages compilers to turn error and undefined into more useful things
15:05:38 <noteventime> monochrom: I can't see changing that particular behaviour of error breaking anything though 
15:05:59 <noteventime> (Apart from program flow :p)
15:14:26 <greap> l
15:14:30 <Veinor> m
15:15:00 <greap> I know I'm tired when I try to get a directory listing in irc...
15:15:35 <monochrom> oh, haha
15:15:38 <dolio> lispy: The 1% HTML-like stuff in your statistics are making me seriously doubt your basis for saying that git has 10x more lines-of-code than darcs!
15:16:13 <monochrom> this is for restricting your irc interface to look exactly like any other terminal emulator
15:16:19 <monochrom> @quote 1970s
15:16:19 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
15:16:46 <greap> haha
15:17:01 <lispy> dolio: lol
15:17:39 <ray> i like that quote too monochrom
15:17:51 <lispy> dolio: actually, I probably made the whole thing up.  If only you could repeat the experiment independently of me...
15:19:37 <greap> I'm making a small PNM parser/OpenGL renderer libarary and am getting stuck when dealing with bytestrings. There don't seem to be any of the parsec end level combinators defined for arbitrary tokens, only Chars. Is there somewhere I should be looking for these? http://github.com/sordina/PNM-OpenGL-Haskell/blob/master/src/Graphics/Rendering/OpenGL/PNM/Reader.hs if anyone is interested.
15:20:36 <top_> welcome
15:23:29 <monochrom> the source code of Text.Parsec.Char inspires how to write a token parser, in particular anyChar
15:23:58 <monochrom> or Text.ParserCombinators.Parsec.Char
15:24:50 <greap> monochrom: But there aren't any existing generic token parsers?
15:25:12 <greap> monochrom: Or also applicable, ByteString token parsers?
15:27:24 <monochrom> one could say Text.Parsec.Prim.token is a generic token parser, but it is too general
15:28:09 <monochrom> but there is nothing more specific until you pin down the type t.
15:28:13 <greap> monochrom: That's true.
15:28:48 <greap> I' just had a look at the Char source, and it's extremely terse and readable, so I should be able to port it to another type with no problems*
15:28:56 <greap> *Probably will have many problems
15:29:27 <monochrom> if you get "satisfy" to work, you can do anything.
15:29:55 <monochrom> if you are scared, get "anyChar" to work first as exercise.
15:30:00 <greap> yes, it looks that way. Would this be something worth hosting on hackage if it works nicely?
15:31:04 <monochrom> oh I guess "satisfy" is readily generalizable and no one has packaged it yet.
15:32:44 <ben_m> BONUS: How do Arrows fit into your previous explanation of Mondads? How do they conceptually differ?
15:33:08 <BONUS> ben_m: well i'd say that arrows extend monads so that they take an input and present an output
15:33:20 <BONUS> whereas a value such as Just 9, can be seen as only providing output
15:33:53 <djahandarie> lol trying to explain arrows in like one sentence
15:34:49 <sproingie> ooh monads are in lyah now
15:35:11 <dolio> Monads are monoids in C -> C, but arrows are monoids in C^op x C -> C.
15:35:30 <dolio> One sentence.
15:35:36 <BONUS> haha, nice
15:35:37 <ben_m> ...that I don't understand :D
15:35:38 <djahandarie> >explain
15:36:19 * hackagebot snap-core 0.2.11 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.11 (GregoryCollins)
15:36:38 <djahandarie> I can't fully visualize what C^op x C -> C is
15:36:42 <ben_m> BONUS: not sure what you mean with output and input. The Just 9 confuses me :(
15:37:01 <greap> Monads are arrows through the Kleisli catamorphism.... Or something like that. (Disclaimer: I have no idea what I'm talking about)
15:37:08 <hpc> ben_m: Just 9 is a value, M
15:37:15 <sproingie> it's a mote!
15:37:22 <hpc> ben_m: an arrow is analogous to A -> M
15:37:22 <BONUS> ben_m: well functions are arrows
15:37:27 <BONUS> they have an input and an output
15:37:31 <ben_m> yeah.
15:37:44 <ben_m> Functions are the only instance of Arrow that I used yet
15:37:57 <dolio> djahandarie: One example is the exponential functor.
15:38:04 <BONUS> but monadic values, like Just 9, or [1,2,3,4] or stuff like that, they don't receive any input per se
15:38:16 <dolio> It's a bifunctor from a category into itself, where the first argument is contravariant, and the second is covariant.
15:38:31 * sproingie eeeeeeeeeee
15:39:10 <dolio> Or, hom functors for categories are hom : C^op x C -> Set, usually.
15:39:30 <ben_m> Arrows are magic, got it.
15:40:19 <Entroacceptor> is there a way for cabal-install to get the documentation for a package I have installed?
15:42:39 <monochrom> in ~/.cabal/config, documentation: True
15:42:58 * FunctorSalad is really confused where exactly the prettyprinting of infix tycons or datacons is fixed and where not in the ghc-haddock-complex ;)
15:43:19 <monochrom> or at every command line: --enable-documentation
15:43:45 <monochrom> oh, "have installed", sorry to disappoint you
15:44:12 <FunctorSalad> for example, trying to make a hoogle .txt file for 'Vec', I get an invalid type signature "foo :: blah -> :. a b"
15:44:14 <monochrom> each package already comes with doc, the only trouble is doc is ignored by default, which IMO is a crime.
15:44:34 <FunctorSalad> and haddock seems to defer to ghc for printing types for hoogle...
15:44:41 <FunctorSalad> but in my ghci, it's all well
15:45:12 <FunctorSalad> (the printing that is)
15:46:52 <dolio> FunctorSalad: You have an easy to get package that uses type operators?
15:47:02 <FunctorSalad> dolio: Vec
15:47:25 <Entroacceptor> monochrom: thank you
15:49:23 * hackagebot snap-server 0.2.11 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.11 (GregoryCollins)
15:50:03 <FunctorSalad> dolio: actually I have a pretty comprehensive *list* of failpackages with respect to cabal haddock --hoogle output ;) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29599#a29599
15:50:16 <FunctorSalad> (most of them type operators I think)
15:50:34 <dolio> Hmm...
15:51:36 <FunctorSalad> ghc has multiple styles for printing, maybe some are broken and some aren't
15:52:27 <FunctorSalad> (I can upload these files too if it's useful)
15:52:51 <dolio> I thought I remembered it not printing correctly if -XTypeOperators wasn't set, but I guess that's been fixed.
15:53:15 <dolio> Which would explain haddock if it didn't set the right variable or something.
15:55:01 <FunctorSalad> > :set -XNoTypeOperators 
15:55:02 <FunctorSalad> > :t (:.)
15:55:02 <FunctorSalad> (:.) :: a -> b -> a :. b
15:55:02 <lambdabot>   <no location info>: parse error on input `:'
15:55:03 <lambdabot>   <no location info>: parse error on input `:'
15:55:05 <FunctorSalad> (yes, fixed)
15:56:02 <FunctorSalad> the offending line in Vec.txt, OTOH, is  (:.) :: !a -> !b -> :. a b
15:57:04 <c_wraith> That doesn't appear to be valid.
15:58:49 <FunctorSalad> yes, bug in infix tycon printing
15:59:03 <FunctorSalad> but see above for my confusion (it's fixed in *some* contexts)
16:12:25 <sou45o> @pl(\x -> x/2 - 12)
16:12:26 <lambdabot> Unknown command, try @list
16:12:43 <sou45o> @pl \x -> x/2 - 12
16:12:44 <lambdabot> subtract 12 . (/ 2)
16:21:04 <Aune> Can someone explain the "Drinkers Paradox"
16:22:01 <Martty> its the paradox that explains that one can only quit drinking heavily after suffering from severe health problems
16:22:15 <Aune> Not quite ^^
16:22:18 <Martty> it applies to many things in life too, thats why its important
16:22:32 <Martty> theres the Haskellers Paradox for that matter
16:22:46 <Veinor> Aune: the statement 'if A then B' means that either B is true or A is false
16:23:06 <Aune> Trying to read this paper: http://www.cs.bham.ac.uk/~mhe/papers/msfp2010/Escardo-Oliva-MSFP2010.pdf
16:23:14 <Veinor> so, if everybody is drinking, then for all X, if X is drinking, then everybody is drinking
16:23:31 <Aune> But keep getting stuck at the beginning of section 2.2
16:23:50 <sou45o> @pl \x -> x/2 - 12
16:23:51 <lambdabot> subtract 12 . (/ 2)
16:23:56 <Veinor> hm, I dunno
16:24:10 <hpc> :t (-12)
16:24:14 <lambdabot> forall a. (Num a) => a
16:24:19 <hpc> :t (- 12)
16:24:19 <Aune> So, the drinkers paradox is "if A => B then not B => not A"
16:24:19 <lambdabot> forall a. (Num a) => a
16:24:23 <hpc> D:
16:24:35 <hpc> that's some serious section parsing fail
16:24:57 <elliottt> hpc: subtract :)
16:25:02 <Veinor> Aune: wikipedia has a pretty good article on it, and to be honest that's what I'm reading
16:25:20 <hpc> why not make "-foo" translate to negative foo, and "- foo" translate to a section?
16:25:32 <elliottt> good question.
16:25:50 <hpc> in fact, why not make all function application require an intervening space?
16:25:58 <elliottt> how would you disambiguate (+1)?
16:26:02 <elliottt> and (+ 1)
16:26:11 <elliottt> ah.
16:26:12 <hpc> unary plus in the first case
16:26:26 <elliottt> no one likes extra spaces :)
16:26:39 <hpc> no one likes apl either :P
16:26:45 <elliottt> hehe
16:26:50 <Twey> hpc: Yeah, Haskell negation operators are a bit sucky.
16:27:08 <hpc> requiring a space for function application would remove the whole unary minus inconsistency
16:27:11 <elliottt> there's a lesson here: only use naturals.
16:27:15 <hpc> and enforce what should be standard procedure anyway
16:27:16 <Twey> hpc: They should require spaces IMO (though you still need ‘negate’ to negate variables)
16:27:28 <Twey> Also drastically expand the identifier space
16:27:34 <Twey> For both names and operators
16:27:57 <hpc> yeah
16:28:14 <Veinor> :t \x -> -x
16:28:15 <lambdabot> forall a. (Num a) => a -> a
16:36:07 <dolio> > map length ["(\x-> -x)", "negate"]
16:36:09 <lambdabot>   <no location info>:
16:36:09 <lambdabot>      lexical error in string/character literal at chara...
16:36:16 <dolio> > map length ["(\\x-> -x)", "negate"]
16:36:17 <lambdabot>   [9,6]
16:36:25 <Veinor> bah
16:36:43 <Veinor> this is because mathematicians are silly and use the same symbol for both operations ;)
16:38:49 <djahandarie> There are probably seperate characters in utf-8 for subtract and negate
16:39:45 <FunctorSalad_> what could possibly go wrong
16:39:46 <FunctorSalad_> ;)
16:39:53 <hpc> a person could spend a lifetime authoring a utf-8 font
16:40:36 <copumpkin> > map (-5) [1..4]
16:40:37 <lambdabot>   [-5,-5,-5,-5]
16:40:54 <hpc> > map (- 5) [1..4]
16:40:55 <lambdabot>   [-5,-5,-5,-5]
16:40:57 <aristid> > subtract 1 2
16:40:59 <lambdabot>   1
16:41:12 <copumpkin> :t (–)
16:41:12 <lambdabot> Not in scope: `???'
16:41:23 <hpc> ....
16:42:44 <hpc> does haskell support user-defined unary infix operators
16:42:45 <hpc> ?
16:42:54 <c_wraith> kind of
16:43:10 <hpc> > let ($) x = x in x $
16:43:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:43:17 <dolio> How can it be infix and unary?
16:43:22 <hpc> > let ($) x = x in 5 $
16:43:23 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:43:25 <c_wraith> > let (!) n = product [1..n] in (5!)
16:43:27 <lambdabot>   120
16:43:28 <ezyang> "The sound of one hand clapping" 
16:43:32 <wli> (5 $)
16:43:38 <c_wraith> But only postfix, not prefix
16:43:45 <Twey> hpc: Yes, with an extension
16:43:56 <c_wraith> You don't need an extension for what I did.
16:44:09 <c_wraith> Just a new-enough version of GHC
16:44:20 <hpc> Twey: "Yes, with an extension" should be the new output of @faq
16:44:24 <Twey> Hehe
16:46:34 <FunctorSalad_> > let x --- y = negate y in (--- 3) undefined
16:46:35 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:46:47 <FunctorSalad_> > let x @@ y = negate y in (@@ 3) undefined
16:46:48 <lambdabot>   -3
16:47:31 <FunctorSalad_> a minor inconvenience ;) (the dummy arg)
16:48:53 <wli> The answer is basically no.
16:49:18 <monochrom> I missed the drinker paradox. but anyway, http://www.vex.net/~trebla/weblog/any-all-some.html
16:49:44 <etpace> haskell.org down?
16:50:14 <elliottt> not for me
16:50:53 <etpace> seems to have been a momentary out
16:56:55 <Aune> Thanks monochrome, but I think I have figured it out now
17:02:38 <lispy> http://en.wikipedia.org/wiki/XOR_linked_list  <-- we totally need a library for that in Haskell ;)
17:02:51 <dom96> Why does getAppUserDataDirectory return "" ?
17:03:14 <copumpkin> that's a cute idea :)
17:03:39 <monochrom> not sure how your GC will feel about it
17:03:53 <dom96> ugh, i always miss something lol.
17:04:04 <dom96> nvm :P
17:07:47 <geheimdienst> copumpkin, "cute" in the sense of "the next programmer touching your code will go wtf and yank it out"
17:08:20 <geheimdienst> ;)
17:15:45 <cadabra> Why can't type inference resolve map id [1..2] when both Prelude and Data.Set is imported? It's clear that [1..2] is a list.
17:17:07 <dolio> That isn't type inference's job.
17:17:28 <cadabra> Okay. Why can't GHC?
17:17:34 <FunctorSalad_> you'd need a map typeclass
17:17:42 <FunctorSalad_> err wait
17:17:46 <FunctorSalad_> ;)
17:18:00 <geheimdienst> > map id [1..2]
17:18:01 <lambdabot>   [1,2]
17:18:06 <geheimdienst> what's the problem with that?
17:18:13 * FunctorSalad_ slaps himself around a bit with a large Functor...
17:18:37 <cadabra> I know I'd need a type class, but I want to understand why it doesn't work without type classes.
17:18:48 <hpc> because name conflict
17:18:50 <Veinor> cadabra: because Prelude and Data.Set both have functions called map
17:19:08 <cadabra> I know, I know. But why can't the name conflict be resolved using the type system?
17:19:14 <notabel> cadabra: without typeclasses a single name can only have a single type
17:19:18 <hpc> not generally
17:19:30 <hpc> polymorphic functions can conflict
17:19:36 <cadabra> Prelude.map takes a list, Data.Set.map takes a Set a.
17:19:43 <cadabra> Hmm?
17:19:46 <notabel> the type-directed name resolution proposal, if implemented, would do this in certain cases
17:19:47 <QtPlatypus> cadabra: Because haskell doesn't do Type based dispatch.
17:19:47 <hpc> or an import can make an otherwise list function into a polymorphic one
17:19:55 <elliottt> so really, there is no problem.  just import them both qualified :)
17:20:00 <vanadium> As far as I can tell, the language gives up before that
17:20:15 <vanadium> Yeah, what QtPlatypus says. It just sees a conflict, and nobody told it to resolve it.
17:20:50 <cadabra> What I'm trying to get at it is: is it impossible to resolve in theory? Or does Haskell just choose not to, and if so, why?
17:21:12 <elliottt> sure it's possible.  java does it
17:21:12 <hpc> it is impossible to resolve in every case
17:21:14 <c_wraith> It's not generally resolvable.
17:21:16 <cadabra> hpc, can you give me an example?
17:21:29 <hpc> :t id map
17:21:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:21:45 <hpc> it would be polymorphic in [] and Set
17:22:50 <copumpkin> cadabra: it's a design choice
17:23:06 <copumpkin> the answer is "the designers didn't want it"
17:23:08 <hpc> typeclasses are for that kind of constrained polymorphism
17:23:10 <cadabra> What benefits does this choice give?
17:23:17 <copumpkin> not going crazy like one does in c++
17:23:18 <hpc> in this case, functor defines a generalization of map
17:23:30 <elliottt> makes programs easier to reason about
17:23:34 <copumpkin> there was talk recently of a restricted form of "type-directed name resolution"
17:23:35 <copumpkin> or something
17:23:40 <copumpkin> but I can't remember the details
17:23:41 <Veinor> It does annoy me sometimes when I have to hink about record field names
17:24:01 <copumpkin> yeah, me too
17:24:05 <cadabra> Or how about this: why isn't every function part of an anonymous type class by default?
17:24:09 <elliottt> i've given up on naming records nice things.  they all get horrible names now, so that they stay unique :)
17:24:17 <elliottt> well, record fields.
17:24:17 <copumpkin> cadabra: again, design decision :P nobody
17:24:21 <copumpkin> is saying it's technically impossible
17:24:26 <hpc> cadabra: that's duck typing, which is nice in a more dynamic language
17:24:49 <cadabra> Well, no. I want static typing and generic programming. Like C++.
17:24:53 <elliottt> so, type classes aren't necessarily free
17:25:11 <elliottt> they do incur an overhead, when the dictionary isn't statically known.
17:25:19 <hpc> the main problem is that the type of map changes based on what you import
17:25:22 <copumpkin> generic programming doesn't mean name lookup includes the type
17:25:31 <elliottt> you would probalby end up with code that was unnecessarily polymorphic, just because you didn't specify enough when you were writing your program
17:26:04 <cadabra> elliottt: but the compiler can specialize for types that are known at compile time.
17:26:23 <hpc> he means at the symbol level
17:26:28 <hpc> the compiled code is untyped
17:26:59 <mm_freak> cadabra: every type is an instance of the empty list of type classes ;)
17:27:08 <hpc> consider:
17:27:09 <mm_freak> > 15 :: ( ) => Integer
17:27:09 <hpc> :t map
17:27:10 <lambdabot>   15
17:27:10 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:27:15 <hpc> :t (=~)
17:27:16 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
17:27:24 <hpc> one of these is the right kind of polymorphism
17:27:34 <Veinor> haha
17:28:14 <Veinor> I want to know how someone can look at that and think 'yeah, that's a good idea'
17:28:37 <FunctorSalad_> :)
17:28:48 <hpc> somehow i thought haskell would be immune to this "enterprise" way of coding
17:30:14 <FunctorSalad_> cadabra: we once discussed adding this feature as an addon based on parsing compile errors ;)
17:30:46 <FunctorSalad_> do a search on the tree that consists of a choice for every 'ambiguous blah' error
17:32:51 <hpc> wouldn't ambiguity necessitate user input?
17:33:19 <FunctorSalad_> no, you simply discard the branches that fail with other compile errors ;)
17:33:28 <FunctorSalad_> hopefully there'd be only one success
17:33:29 <cadabra> I think it would be helpful to resolve cases where it isn't ambiguous, and abort compilation when it truly is.
17:35:42 <cadabra> Type inference is supposed to reduce boiler plate keyboarding, right? But it seems that we've just shifted things: instead of declaring my types I now have to write qualified function names.
17:36:51 <cadabra> I should write data Foo = Foo { bar :: Int }, but so much code becomes data Foo = Foo { fooBar :: Int } instead.
17:37:18 <Veinor> hence the reason for import qualified
17:37:18 <cadabra> Seems unfortunate.
17:37:36 <hpc> cadabra: the solution is typeclasses
17:37:49 <Veinor> but I see your point
17:38:37 <FunctorSalad_> I don't like qual names much either
17:38:39 <cadabra> Import qualified seems like a kludge to me. And I avoid it because it's harder to read code if there's random single-letter prefixes all over it, e.g. S.map and M.map.
17:38:57 <FunctorSalad_> cadabra: vim's haskell-mode's _i helps
17:39:03 <Veinor> hpc: this is why I don't like join being what it is
17:39:19 <Veinor> I think intercalate should be named join and join should be... I dunno. fuse.
17:39:30 <hpc> Veinor: indeed; reading the lyah monad chapter, i noticed list is defined in terms of join
17:39:37 <cadabra> I use emacs. FunctorSalad_, what does _i do?
17:39:39 <FunctorSalad_> if you hit _i while the cursor is over 'map', it asks you which package you wants, and adds an 'import Data.Blah(map)' for you
17:39:40 <hpc> :t intercalculate
17:39:41 <lambdabot> Not in scope: `intercalculate'
17:39:53 <Veinor> > intercalate "," ["foo", "bar", "baz"]
17:39:54 <lambdabot>   "foo,bar,baz"
17:40:07 <FunctorSalad_> that way you get less ambiguities
17:40:14 <FunctorSalad_> (compared to importing whole packages)
17:40:16 <hpc> that's not join though
17:40:21 <cadabra> Okay, I see.
17:40:23 <Veinor> it is in other languages :P
17:40:25 <FunctorSalad_> in this case it wouldn't help unless you also import Prelude qualified though
17:40:35 <FunctorSalad_> (since map is in Prelude...)
17:40:41 <hpc> haskell would be departing from a term other languages use too
17:41:04 <Veinor> ?
17:41:26 <hpc> oh wait, nvm
17:41:34 <Veinor> return I'm kind of fine with
17:41:48 <hpc> perl's join is the same as intercalate
17:42:02 <Veinor> yea
17:42:06 <FunctorSalad_> @all-dicts intercalate
17:42:07 <lambdabot> *** "Intercalate" gcide "The Collaborative International Dictionary of English v.0.48"
17:42:08 <lambdabot> Intercalate \In*ter"ca*late\, v. t. [imp. & p. p.
17:42:08 <lambdabot>    {Intercalated}; p. pr. & vb. n. {Intercalating}.] [L.
17:42:08 <lambdabot>    intercalatus, p. p. of intercalare to intercalate to
17:42:08 <lambdabot>    intercalate; inter between + calare to call, proclaim. See
17:42:09 <lambdabot> [18 @more lines]
17:42:19 <Veinor> it's also a really weird name :P
17:42:20 <FunctorSalad_> @moar
17:42:21 <lambdabot> Maybe you meant: map more
17:42:30 <FunctorSalad_> :p
17:42:38 <hpc> but i like join's name
17:43:01 <FunctorSalad_> maybe 'flatten' would be more specific
17:43:25 <hpc> :t intersperse
17:43:26 <lambdabot> forall a. a -> [a] -> [a]
17:43:56 <hpc> hmm, that's annoying
17:44:33 <FunctorSalad_> intersperse?
17:47:44 <cadabra> Apparently, GHC has the extension XDisambiguateRecordFields http://haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html
17:48:30 <FunctorSalad_> it's not for expressions iirc
17:48:32 <FunctorSalad_> :(
17:49:46 <cadabra> I'm also looking at http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution but it's not quite what we're talking about.
17:51:56 <tolkad> > map (flip replicate 1) [10..1]
17:51:57 <lambdabot>   []
17:52:07 <tolkad> > map (flip replicate 1) [10,9,8,7,6,5,4,3,2,1]
17:52:08 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1...
17:52:13 <tolkad> can someone explain this to me?
17:52:22 <tolkad> 0_o
17:52:27 <hpc> :t flip
17:52:28 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:52:28 <dented42> > [10..1]
17:52:29 <lambdabot>   []
17:52:35 <hpc> :t replicate 1
17:52:35 <tolkad> wait what
17:52:36 <Jonno_FTW> it replicates 1 n times
17:52:36 <lambdabot> forall a. a -> [a]
17:52:40 <dented42> > [10 .. 1]
17:52:41 <tolkad> > [10..1]
17:52:41 <lambdabot>   []
17:52:42 <lambdabot>   []
17:52:52 <tolkad> oh
17:52:56 <Jonno_FTW> > [10,9..1]
17:52:57 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
17:52:57 <tolkad> I guess I misunderstood ..
17:53:01 <tolkad> thanks
17:53:07 <Jonno_FTW> flip swaps the argumens around
17:53:22 <Jonno_FTW> it's like doing replicate 10 1
17:53:26 <Jonno_FTW> and so on
17:53:46 <hpc> Jonno_FTW: not in this case; it's doing functor wizardry
17:54:03 <hpc> replicate is a -> [a], so no arguments can be flipped
17:54:10 <dented42> > 1
17:54:11 <lambdabot>   1
17:54:11 <hpc> :t flip replicate
17:54:12 <lambdabot> forall a. a -> Int -> [a]
17:54:19 <hpc> oh, nvm
17:54:22 <hpc> i suck
17:54:39 <FunctorSalad_> :t flip repeat
17:54:40 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
17:54:40 <lambdabot>     Probable cause: `repeat' is applied to too many arguments
17:54:40 <lambdabot>     In the first argument of `flip', namely `repeat'
17:56:22 <Jonno_FTW> > replicate 4 5
17:56:23 <lambdabot>   [5,5,5,5]
17:56:27 <Jonno_FTW> ?
17:56:55 <Jonno_FTW> hpc you mayhave been thinking of repeat
17:57:08 <hpc> Jonno_FTW: probably
18:04:40 <xiackok> hello every one
18:05:28 <xiackok> is there any one knows good university for cs in europe
18:08:07 <xiackok> no?
18:08:46 <c_wraith> I'm sure there are a bunch, but much of europe is asleep right now.
18:09:18 <xiackok> yes i forget it. time is 04:05 in here :D
18:11:21 <ManateeLazyCat> Hi all.
18:12:06 <xiackok> ManateeLazyCat: hi
18:12:18 <ManateeLazyCat> xiackok: Hi :)
18:12:57 <Jonno_FTW> @src gcd
18:12:58 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
18:12:58 <lambdabot> gcd x y = gcd' (abs x) (abs y)
18:12:58 <lambdabot>    where gcd' a 0  =  a
18:12:58 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
18:17:02 * ManateeLazyCat Looks good http://www.flickr.com/photos/48809572@N02/4943815462/lightbox/ , next step, add more features : highlight nick name.....
18:18:07 <xiackok> ManateeLazyCat: gtk?
18:18:19 <ManateeLazyCat> xiackok: Yes.
18:18:29 <ManateeLazyCat> xiackok: http://www.flickr.com/photos/48809572@N02/
18:18:39 <ManateeLazyCat> xiackok: I'm testing my IRC client...
18:19:26 <xiackok> ManateeLazyCat: im looking screenshots
18:19:28 <hpc> > 0 `rem` b
18:19:29 <lambdabot>   0 `rem` b
18:19:39 <hpc> er
18:19:42 <hpc> > 0 `rem` 5
18:19:43 <lambdabot>   0
18:19:51 <ManateeLazyCat> xiackok: Look this : http://www.flickr.com/photos/48809572@N02/show
18:20:52 <aristid> > let gcd' a 0 = [a]; gcd' a b = a : gcd' b (a `rem` b) in gcd' 20 8
18:20:53 <lambdabot>   [20,8,4]
18:21:08 <xiackok> ManateeLazyCat: image viewer is it do you use borderless window at bottom right?
18:21:45 <ManateeLazyCat> xiackok: Image viewer just screenshot for binding GtkImageView, not sub-module of my project.
18:22:02 <ManateeLazyCat> xiackok: It's support by library GtkImageView.
18:22:26 <ManateeLazyCat> xiackok: The real image-viewer sub-module of my project still in developing....
18:22:58 <xiackok> ManateeLazyCat: what is live environment? its so interesting
18:23:11 <ManateeLazyCat> xiackok: I plan to use Gdk-Pixbuf integrate gtkglext (Haskell binding for OpenGL)
18:23:35 <ManateeLazyCat> xiackok: I'm testing my irc client, so i want bla bla bla to you. :)
18:24:02 <ManateeLazyCat> xiackok: It's "Integrated Live Environment" base on Haskell/GTK+ (gtk2hs)
18:24:45 <xiackok> ManateeLazyCat: i cant understand "i want bla bla to you" ?? you want talk with me while testing your irc client??
18:24:45 <ManateeLazyCat> xiackok: With multiple-processes design for variant sub-module for protected core won't crash.
18:24:57 <ManateeLazyCat> xiackok: Yes.
18:25:02 <ManateeLazyCat> :)
18:25:41 <ManateeLazyCat> xiackok: And use DBus as cross-processes IPC for communication between core and sub-modules....
18:26:31 <xiackok> ManateeLazyCat: wow its seems very nice. what is your motivation ? can you detail Integrated Live Environment
18:27:15 <ManateeLazyCat> xiackok: My aim is develop new Haskell Environment that replace Emacs, firefox and *everything* with my style for work efficiently.
18:27:35 <fengshaun> is there any visual debugger for Haskell so I can see how my code gets executed?  (line by line)
18:27:55 <xiackok> fengshaun: leksah ide is good
18:28:16 * ManateeLazyCat Haskell thread is damn fast for IRC transfer.... sweet....
18:28:38 <fengshaun> xiackok: thanks!
18:28:50 <xiackok> fengshaun: your welcome
18:29:21 <ManateeLazyCat> xiackok: I will release first review version after i merge some code to gtk2hs, then you know what exact it is. :)
18:29:23 <xiackok> ManateeLazyCat: it can be scripted like emacs?
18:29:32 <ManateeLazyCat> @hackage pdynload
18:29:32 <lambdabot> http://hackage.haskell.org/package/pdynload
18:29:43 <ManateeLazyCat> xiackok: I have develop pdynload for hot-swapping like Emacs.
18:29:46 <fengshaun> xiackok: wow, this is just what I was (not knowingly) looking for!
18:29:52 <duckinator> hi
18:30:14 <xiackok> ManateeLazyCat: what is mean hot-swapping? sorry about my bad english
18:30:50 <ManateeLazyCat> xiackok: Mean you can change code and update it when software is running.
18:31:06 <ManateeLazyCat> xiackok: Like Emacs, fixed-and-continue don't need restart...
18:31:55 <xiackok> ManateeLazyCat: ok i got it. its saying System.Plugin heh :). if i true Yi editor dont support this
18:32:51 <ManateeLazyCat> xiackok: Yi or XMonad use reboot/reload status technology, pdynload insert code in runtime....
18:33:34 <xiackok> ManateeLazyCat: im just looking methods now
18:33:35 <ManateeLazyCat> xiackok: If you need reboot software for update, you perhaps lost state (such as network link...etc.)
18:34:00 <ManateeLazyCat> xiackok: pdynload is very simple,
18:34:12 <ManateeLazyCat> xiackok: And perfect safe, because it will check type in runtime.
18:34:48 <ManateeLazyCat> xiackok: pdynload can load package and call method in runtime, but now has an issue that can't reload package after user re-install package in cabal database.
18:34:57 <ManateeLazyCat> xiackok: I will find some time fix this problem....
18:36:09 <xiackok> ManateeLazyCat: yes it seems very nice. last night im tought about plugin system and loading modules in runtime. now you are saying "i will do it" :):)
18:37:03 <ManateeLazyCat> xiackok: If you don't re-install package after run pdynload, pdynload can works well.
18:37:12 <xiackok> ManateeLazyCat: module Unsafe.Coerce is different from your project??
18:37:58 <ManateeLazyCat> xiackok: Don't be afraid Unsafe.Coerce, it will run type-checker at runtime, if type mismatch, pdynload will return Nothing that won't crash your program.
18:38:26 <ManateeLazyCat> xiackok: Because i do type-checker before Unsafe.Coerce, so it's perfectly safe.
18:38:53 <xiackok> ManateeLazyCat: i got it
18:39:17 <ManateeLazyCat> xiackok: If you don't re-install package after run pdynload, it's will works well....
18:39:35 <xiackok> ManateeLazyCat: but if you restart program?
18:39:51 <ManateeLazyCat> xiackok: pdynload don't need restart program to update it.
18:39:59 <ManateeLazyCat> xiackok: Insert code in runtime.
18:40:27 <ManateeLazyCat> xiackok: Well, if you restart program, pdynload will load newest version from cabal database.
18:40:56 <ManateeLazyCat> xiackok: Now issue is, once pdynload load some package, it won't load again even have new version in cabal.
18:41:02 <xiackok> ManateeLazyCat: ok now
18:41:24 <ManateeLazyCat> xiackok: Best solution should be: check packge hash value when load, if found new version in cabal database, then reload new version.
18:42:08 <ManateeLazyCat> xiackok: It's need hacking GHC code to reload new version, but i think it's not so hard....
18:43:01 <xiackok> ManateeLazyCat: im not a professional on Haskell. Im newbie for functional programming and haskell (just 2 months). But if you want i can write simple tasks for your project.
18:43:36 <xiackok> ManateeLazyCat: maybe there is a way for unplugging module :)
18:43:58 <xiackok> ManateeLazyCat: and you can reload module with pdynload
18:44:04 <ManateeLazyCat> xiackok: Yes, unplugging perhaps dangerous since Haskell is lazy.
18:44:27 <ManateeLazyCat> xiackok: I will keep old version in memory and change address to new version.
18:44:48 <ManateeLazyCat> xiackok: Welcome to join! Source code at https://patch-tag.com/r/AndyStewart that beginning with manatee-*
18:45:14 <ManateeLazyCat> xiackok: Now it's need darcs version of gtk2hs and gio-branch (https://patch-tag.com/r/AndyStewart/gio-branch/home)
18:45:46 <ManateeLazyCat> xiackok: It will install easier, after i release gio-0.12.0 and gtk-0.12.0
18:47:48 <aristid> ManateeLazyCat: couldn't you change the interface such that the type does not have to be passed as a string?
18:48:53 <ManateeLazyCat> aristid: If pass type, it's need your import something when you use pdynload
18:49:08 <aristid> ManateeLazyCat: sorry i don't understand
18:49:14 <ManateeLazyCat> aristid: And pass string haven't those problem.
18:50:02 <ManateeLazyCat> aristid: If you have type Foo in package Bar.
18:50:36 <ManateeLazyCat> aristid: And pass type Foo to pdynload interface, pdynload don't need what is Foo unless you import Bar.
18:51:01 <ManateeLazyCat> aristid: Once you import Bar, you need add Bar in .cabal file, then you got "static link"
18:51:29 <ManateeLazyCat> aristid: And pass String, pdynload don't need type information, it will build new temporary module in runtime for type check.
18:53:00 <ManateeLazyCat> s/don't need/don
18:53:05 <ManateeLazyCat> 't know
18:53:43 <xiackok> ManateeLazyCat: is there way loading modules in runtime without giving type information?? 
18:53:50 <aristid> ManateeLazyCat: trying to translate... the problem is that the full type might not yet be known to the loader module?
18:54:20 <ManateeLazyCat> xiackok: Yes, but it's not safe! It will crash you program if mismatch type in runtime.
18:54:47 <ManateeLazyCat> aristid: I explain why i use String, 
18:55:00 <xiackok> ManateeLazyCat: i think about a code browsing utility with pdynload
18:55:32 <ManateeLazyCat> aristid: You can find function 'typeCheck' in Plugin.hs.
18:55:45 <aristid> ManateeLazyCat: i really have trouble understanding your english:)
18:56:26 <ManateeLazyCat> aristid: Well, my English couldn't better. :)
18:56:50 <ManateeLazyCat> aristid: Look 'typeCheck' function of Plugin.hs
18:57:02 <aristid> yeah i understand that function now, i think
18:57:33 <joker> myFunction  n = [d | d <- (delete 0 [-n..n]), n `mod` d == 0]   I found this type expressions inline somewhere and wanted to learn how to work with these....what are these forms of expressions called in haskell
18:57:40 <Veinor> list comprehensions?
18:57:49 <joker> list comprehension?
18:58:03 <ManateeLazyCat> aristid: typeCheck create new haskell file in runtime, then insert expression and "type String" and run "ghc -e" for type check. 
18:58:36 <Veinor> joker: you mean stuff like
18:58:46 <Veinor> > [x + 1 | x <- [1..4]]
18:58:47 <lambdabot>   [2,3,4,5]
18:58:51 <joker> yes
18:58:54 <aristid> ManateeLazyCat: yeah i've seen that
18:59:18 <joker> could you be kind of expain that line 
18:59:18 <ManateeL`> aristid: Of course you can pass *type* to pdynload, but it's need import necessary module make pdynload can compile pass.
18:59:31 <ManateeL`> aristid: Then you have to compile module in compile-time, and not runtime. See?
18:59:37 <aristid> ManateeLazyCat: btw i watched a video with peter norvig today and he said that google translate does better translating arabic to english than chinese to english :D
18:59:50 * ManateeL` ERC is really slow that always reconnect IRC server.
19:00:17 <ManateeL`> aristid: Trust me, Google Translate is stupid for Chinese.
19:00:19 <aristid> ManateeL`: can you maybe use Typeable or so to simplify the interface?
19:00:28 <Veinor> joker: think of it as 'assign d in sequence to each variable in the list (delete 0 [-n .. n])
19:00:28 <aristid> oh, google translate is stupid for any language
19:00:39 <Veinor> then only take the ones where n `mod` d == 0
19:00:47 <ManateeL`> aristid: Typeable can't explain any type, and user need write Typeable instance.
19:01:02 <ManateeL`> aristid: My solution can support any type that GHC can support.
19:01:29 <joker> yeah butt why then d|d<-......
19:01:32 <ManateeL`> aristid: 'Typeable' or 'Dynamic' is not perfect way.
19:01:40 <joker> why not just d<-.....
19:01:54 <Veinor> joker: because you have to say 'okay, you have all these d variables, now what do you do with them'
19:02:15 <aristid> ManateeL`: hmm arabic and english are not related at all
19:02:54 <ManateeL`> aristid: If you use Typeable, you need make sure expression's type is instance of Typeable, and not every type can convert to Typeable, and it's a burden for user.
19:03:18 <joker> does every member of list gets assignted to d variable
19:03:20 <ManateeL`> aristid: I think Chinese is harder.....
19:03:20 <xiackok> ManateeL: there is a cabal package for manatee
19:03:42 <ManateeL`> xiackok: No, because manatee use darcs version gtk2hs and gio-branch.
19:03:54 <aristid> ManateeL`: harder? why?
19:03:57 <ManateeL`> xiackok: I will upload manatee package after i merge some code in gtk2hs.
19:04:29 <xiackok> ManateeL`: ok im downloading via darcs now
19:05:26 <xiackok> aristid: i dont know chineese but japaneese seems easy language
19:05:47 <joker> yeah i see that each number in list gets assigned to d.....
19:05:59 <joker> is there rule how to buld this type expressions 
19:06:00 <aristid> xiackok: what's your perspective?
19:06:13 <copumpkin> preflex: seen edwardk
19:06:13 <preflex>  edwardk was last seen on #haskell 12 hours, 12 minutes and 40 seconds ago, saying: ;)
19:06:19 <aristid> i have the theory that related languages are easier to learn
19:06:30 <ManateeL`> aristid: First, Chinese and English are different language family
19:06:32 <aristid> which also applies to programming languages of course
19:06:36 <aristid> ManateeL`: arabic, too.
19:07:09 <ManateeL`> aristid: Second, Chinese character is huge, even same character have different meaning in different environment.
19:07:39 <aristid> ManateeL`: maybe the different writing system also created a different kind of grammar?
19:07:41 <Adamant> queue the shi poem
19:07:52 <ManateeL`> aristid: You can't master Chinese even you're native Chinese speaker...
19:08:16 <Adamant> that's pretty much the same as English, though
19:08:18 <ManateeL`> aristid: Most we say Chinese mean "Han Yu"
19:08:31 <ManateeL`> aristid: And have many many different language in Chinese....
19:08:33 <aristid> ManateeL`: what we call mandarin?
19:08:47 <Martty> theres different dialects of english too
19:08:53 <ManateeL`> aristid: mandarin 普通话
19:08:53 <Martty> what kind of silly discussion is this
19:08:55 <Adamant> there are 1 million English words, of which 500,000 are in current and common use
19:09:00 <aristid> Martty: but they are mutually intelligible
19:09:09 <ManateeL`> Martty: Not just dialects, it's different language.
19:09:19 <Martty> so why group it under chinese?
19:09:28 <Adamant> Martty: Mandarin and Cantonese are not mutually intelligible, for instance
19:09:30 <copumpkin> they're ridiculously different
19:09:35 <co_dh> :t unsafeCoerce
19:09:35 <lambdabot> Not in scope: `unsafeCoerce'
19:09:36 <xiackok> aristid: i compare with turkish. in turkish writing additions endfix. in japaneese seperate. japaneese has regular verbs. turkish has not
19:09:40 <ManateeL`> Martty: Because it's live in China. :)
19:09:42 <Martty> then compare @chinese" with "latin rooted" languages
19:10:06 <ManateeL`> aristid: mandarin aslo mean "Han Yu", just mandarin use accent of BeiJing.
19:10:06 <Martty> id rather compare c++ with haskell, if you dont mind..
19:10:11 <co_dh> ManateeL, r u chinese?
19:10:18 <ManateeL`> co_dh: Yes.
19:11:00 <aristid> xiackok: i think japanese is not an easy language anyways
19:11:25 <xiackok> aristid: i think only kanji alphabet is hard
19:11:30 <Adamant> "easy" is usually based on what other languages you already know
19:11:39 <copumpkin> #haskell-blah ? :)
19:11:50 <Adamant> jawohl, Mein Herr
19:12:01 <ManateeL`> xiackok: You need install "gtk2hs-buildtools glib" in darcs gtk2hs, then install gio-branch (https://patch-tag.com/r/AndyStewart/gio-branch/home), and install "cairo pango gtk" in darcs gtk2hs.
19:12:02 <etpace> j haskell-blah
19:12:05 <etpace> whoops
19:12:29 <ManateeL`> xiackok: Other package you can install from hackage.
19:13:23 <ManateeL`> xiackok: Have repos.sh in package 'manatee'. Pull all manatee package in one place, then switch 'manatee' do "./repos.sh install", this script will install manatee automatically...
19:13:24 <xiackok> ManateeL`: i dont understand. instal bla bla in gtk2hs? i have installed gtk2hs cairo etc. with cabal. 
19:13:42 <ManateeL`> xiackok: Because gtk need depend gio.
19:13:57 <ManateeL`> xiackok: If you install gio-branch, you need re-install gtk again.
19:14:17 <xiackok> ManateeL`: ok i will try install script
19:14:25 <ManateeL`> xiackok: You need gio-branch and darcs gtk
19:14:38 <ManateeL`> xiackok: gtk-0.11.x can't work
19:15:12 <ManateeL`> xiackok: Install script just for build manatee, you need install all dependent before use it.
19:15:23 <xiackok> ManateeL`: hmm ok
19:15:32 <ManateeL`> xiackok: It's not easy to install now.....
19:15:53 <xiackok> ManateeL`: yesss its seems hard :D
19:16:29 <ManateeL`> xiackok: Or you wait me merge gio code to gtk2hs and upload manatee, then you can use "cabal install manatee" instal it.:)
19:16:56 <ManateeL`> xiackok: New version gio has finish, just i need send patches to Axel for review.
19:17:08 <xiackok> ManateeL`: i must remove cabal package on my system gtk2hs??
19:17:17 <ManateeL`> xiackok: No, just re-install.
19:17:22 <xiackok> ok
19:17:41 <ManateeL`> xiackok: But you need install with sequence : glib -> gio-branch -> gtk
19:17:57 <xiackok> ManateeL`: i dont use before darcs. how can i fetch and install this libraries
19:18:47 <ManateeL`> xiackok: darcs get http://code.haskell.org/gtk2hs
19:20:06 <ManateeL`> xiackok: Well i suggest you re-install all package in gtk2hs again, because pango-0.11.0 not compatible with gtk-0.11.2
19:20:41 <xiackok> ManateeL`: aahh you are killing me :D ok
19:20:47 <xiackok> ManateeL`: i will try
19:24:40 <ManateeL`> xiackok: I haven't add customize-system in manatee, so it's need too many package for build manatee now.
19:25:20 <ManateeL`> xiackok: TWo place to find dependent package : cabal (hackage) and my homepage (http://patch-tag.com/r/AndyStewart)
19:27:11 <xiackok> grrr my debian freezing randomly :S
19:27:47 <ManateeL`> xiackok: I need develop irc client now, send mail to me (lazycat.manatee@gmail.com) if you have any problem with manatee.
19:28:25 <xiackok> ManateeL`: ok see you soon
19:31:21 <tolkad> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Control-Monad.html#mapM
19:31:21 <tolkad> What are those "as" for?
19:31:50 <djahandarie> They aren't special, just a regular variable
19:32:01 <djahandarie> It's the syntax highlighter's fault
19:32:07 <tolkad> oh
19:33:36 <tolkad> wait a second... shouldn't mapM require multiple steps of IO? how can it be lazy?
19:34:00 <tolkad> I thought each step in an IO do block has to happen in sequence?
19:35:05 <tolkad> what things are done lazily and what are not?
19:35:09 <tolkad> hod do you know?
19:35:12 <tolkad> how*
19:35:41 <tolkad> or is are all lazy data structures wrapped in IO lazy like that?
19:35:47 <tolkad> s/is //
19:35:52 <tolkad> it's just rather confusing atm
19:36:28 <tolkad> whatever, it works :P
19:37:28 <applicative> what passage is the souce of your trouble tolkad, I was wondering
19:38:15 <applicative> i mean about the laziness of mapM
19:39:17 <Tomsik> :t is
19:39:19 <lambdabot> Not in scope: `is'
19:41:13 <tolkad> applicative: well I thought all IO steps happen in sequence, one after the other
19:41:48 <tolkad> applicative: to convert an infinite list of type forall a. [IO a] would take an infinite number of steps
19:41:59 <tolkad> applicative: my real question I guess is how sequence can work lazily
19:43:10 <tolkad> is it not true that all IO steps must be completed in sequence?
19:43:39 <Tomsik> > let future = Just undefined
19:43:40 <lambdabot>   not an expression: `let future = Just undefined'
19:43:53 <Tomsik> dang
19:44:10 <tolkad> Tomsik: that's different
19:44:35 <geheimdienst> i have a data D = X | Y String. now i want to add a "Z [Num]", so that would be data D a = ... | Z [a]
19:44:54 <geheimdienst> Q1 where do i stick the (Num a): data (Num a) => D = ...?
19:45:12 <geheimdienst> Q2. i got a million functions "Something -> D". do i really have to append a phony "a" in every place? cause that seems like a lot of work
19:45:23 <tolkad> Tomsik: I understand how lazy data structures can be wrapped in IO, I don't understand how an infinite number of IO steps can be completed lazily and the rules for when this will occur
19:46:13 <tolkad> or does sequence never halt...
19:46:18 <tolkad> maybe I misunderstood that
19:46:26 <tolkad> err not sequence
19:46:28 <tolkad> I mean mapM
19:46:36 <Tomsik> well
19:46:38 <Tomsik> if it's IO
19:46:51 <tolkad> if called on an infinite list I guess it doesn't then?
19:46:53 <Tomsik> umm, let's start with, what are you talking about?
19:47:04 <tolkad> ok, let's say I do
19:47:10 <Cale> tolkad: sequence doesn't work lazily in that sense
19:47:42 <Cale> getContents, for example, is magical
19:47:52 <co_dh> is there a way to remove duplication in code like below ? 
19:48:00 <co_dh> instance (REq a, REq b, REq c) => REq (a,b,c) where
19:48:01 <co_dh>     (x1,x2,x3) ~= (y1,y2,y3) = x1 ~= y1 && x2 ~= y2 && x3 ~= y3
19:48:11 <tolkad> Cale: oh. that makes more sense
19:48:11 <co_dh> you know, where have tuple of 2,3,4,5 ... elements. 
19:48:40 <Cale> co_dh: Tuples are all completely separate types. You could write Template Haskell code to generate the code for you
19:48:47 <tolkad> Cale: by magical I'm assuming you mean it could not be defined in haskell without using some similar function
19:49:00 <geheimdienst> co_dh, have you thought about using 2 lists instead of 2 tuples?
19:49:02 <Cale> co_dh: but since people rarely use anything larger than a triple, it's probably not worth the trouble
19:49:05 <co_dh> Cale: can I use Applicative ?
19:49:10 <Cale> tolkad: yeah
19:49:22 <Cale> tolkad: Well, it needs unsafeInterleaveIO
19:49:38 <co_dh> geheimdienst: it's type class, 
19:49:39 <Cale> tolkad: I shouldn't say *needs*, but that's what's used.
19:50:00 <Cale> co_dh: You can't write an instance for more than one sort of tuple at a time
19:50:21 <Cale> (a,b) and (a,b,c) are completely unrelated types
19:50:30 <co_dh> cale: thanks.
19:50:36 <geheimdienst> cause then i think it would boil down to something like "all $ zipWith (=~) xs ys", and that would work for any number of regexes
19:50:58 <Cale> co_dh: However, TH makes it possible of course to generate all the instances.
19:51:54 <co_dh> geheimdienst: REQ is a class, and we need to generate instance for each tuple type. 
19:53:37 <copumpkin> screw each tuple type :P
19:53:46 <copumpkin> anyone who's using more than pairs shouldn't, anyway
19:54:00 <tolkad> unsafeInterleaveIO? or FUNSafeInterleaveIO?
19:54:16 <co_dh> unsafe
19:55:07 <co_dh> :t ($=)
19:55:07 <lambdabot> Not in scope: `$='
19:55:14 <co_dh> :t (=$)
19:55:15 <lambdabot> Not in scope: `=$'
19:55:59 <carter> copumpkin: just fired off that email to haskell-cafe
19:56:24 <copumpkin> cool
19:56:25 <carter> the more I think about it, the more I think i'm going to get back "ya daft man, heres a simpler way to write it"
19:56:34 <carter> but i don't quite think so
19:56:40 <carter> but i do
19:56:45 <carter> hhaha
19:57:48 <carter> either way
19:58:14 <carter> i'm hoping theres an interesting dialogue about generic traveral stuff
19:58:15 <tolkad> if instead of "return [1..]" I had some IO statement, what thread would it be executed in? http://codepad.org/uebaJTWl
19:58:33 <tolkad> or is that not deterministic?
20:00:12 <carter> tolkad: it'd return  IO ()
20:00:17 <copumpkin> tolkad: why do you have unsafeInterleaveIO in there?
20:00:19 <carter> so it'd print () I think
20:00:22 <copumpkin> it's not doing anything?
20:00:49 <tolkad> copumpkin: I know, I can't put an actual IO statement in there on codepad, it's sandboxed
20:01:13 <tolkad> copumpkin: but if I had one, I'm wondering which thread it would execute in. that might be important if it was a bound thread
20:01:27 <co_dh> :t (~=)
20:01:28 <lambdabot> Not in scope: `~='
20:01:50 <tolkad> carter: I know that, that's not what I was asking
20:02:02 <carter> ah
20:02:23 <tolkad> carter: thanks anyway though
20:02:24 <Veinor> :t (=~)
20:02:25 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
20:02:30 <co_dh> I like Data.StateVar
20:03:21 <tolkad> What I'm wondering is, if IO deferred with unsafeInterleaveIO is guaranteed to run in the thread it was originally deferred in
20:03:35 <blackh> tolkad: Definitely not
20:03:35 <preflex>  blackh: you have 1 new message. '/msg preflex messages' to read it.
20:07:59 <tolkad> why does lambdabot have a "nazi-on" command 0_o
20:08:33 <tolkad> @help nazi-on
20:08:33 <lambdabot> spell <word>. Show spelling of word
20:08:43 <geheimdienst> @spell speling
20:08:45 <tolkad> suuuure lambdabot
20:08:55 <geheimdienst> @nazi-on speling
20:08:55 <lambdabot> Not enough privileges
20:09:42 <geheimdienst> @nazi-on Nut enouph privleggez
20:09:42 <lambdabot> Not enough privileges
20:09:48 <geheimdienst> see, it works!
20:18:08 <carter> copumpkin: hrmm, is my cafe email sensical?
20:22:01 <copumpkin> I think so, from the little I know of syb :)
20:23:56 <geheimdienst> > let a = [2] in (a !! 0) / 3
20:23:57 <lambdabot>   0.6666666666666666
20:24:04 <geheimdienst> @let a = [2]
20:24:05 <lambdabot>  Defined.
20:24:12 <geheimdienst> > (a !! 0 ) / 3
20:24:13 <lambdabot>   Ambiguous occurrence `a'
20:24:13 <lambdabot>  It could refer to either `L.a', defined at <local...
20:24:21 <geheimdienst> > (L.a !! 0 ) / 3
20:24:22 <lambdabot>   0.6666666666666666
20:24:54 <geheimdienst> ^^ why does that not work in my ghci? let .. in works fine, but let .. ; a ... does not
20:25:04 <geheimdienst> "No instance for (Fractional Integer)"
20:31:48 <yabberyabber> what is CTCP version?
20:33:07 <sshc> What is the name of the overlapping string extension?
20:35:02 <geheimdienst> sshc, you mean overloaded strings? http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/type-class-extensions.html#overloaded-strings
20:36:22 <Cale> yabberyabber: Ot
20:36:22 <preflex>  Cale: you have 1 new message. '/msg preflex messages' to read it.
20:36:32 <yabberyabber> Ot?
20:36:45 <Cale> yabberyabber: Sorry, it's a request to see which IRC client you're using
20:36:51 <Cale> (accidentally hit enter)
20:37:01 <yabberyabber> ohh, i'm on the tryhaskell.org thing
20:37:04 <Cale> ah
20:37:14 <yabberyabber> i suppose if i don't need to ask any questions, i should log out :/
20:37:33 <Cale> yabberyabber: It'll usually be responded to automatically by the client you're using.
20:38:07 <Cale> yabberyabber: Doesn't matter. :) Feel free to ask any questions you might have about Haskell, of course :)
20:38:25 <yabberyabber> seems a lot like python
20:38:34 <yabberyabber> except with a slightly different function syntax
20:38:57 <yabberyabber> and this whole passing functions is a cool concept (if i can call it that)
20:43:08 <jmcarthur> yabberyabber: you will find that it's very unlike python if you stick around long enough :)
20:43:24 <yabberyabber> (i'm already brainfucked)
20:45:59 <jmcarthur> i'm really appreciating the Monoid instance for functions today
20:48:06 <geheimdienst> perhaps we should name august 31 "Monoid Function Instance Appreciation Day"
20:48:54 <jmcarthur> definitely
20:49:47 <Cale> > sortBy (comparing length `mappend` compare) (words "here are some words to sort by length and then alphabetically")
20:49:48 <lambdabot>   ["by","to","and","are","here","some","sort","then","words","length","alphab...
20:50:13 <yabberyabber> those sound like dead verbs
20:53:02 <mtnviewmark> does that work because a -> Ordering is a Monoid
20:53:48 <Cale> yeah
20:54:06 <Cale> Ordering is a monoid, and so a -> Ordering is, and so a -> a -> Ordering is
20:55:14 <mtnviewmark> > Eq `mappend` Gt
20:55:15 <lambdabot>   Not in scope: data constructor `Eq'Not in scope: data constructor `Gt'
20:55:17 <Cale> The monoid instance for Ordering is: EQ `mappend` y = y; x `mappend` y = x
20:55:34 <mtnviewmark> > EQ `mappend` GT
20:55:34 <lambdabot>   GT
20:55:43 <mtnviewmark> > GT `mappend` EQ
20:55:44 <lambdabot>   GT
20:55:54 <mtnviewmark> > GT `mappend` LT
20:55:55 <lambdabot>   GT
20:55:59 <Cale> and EQ is mempty
20:56:13 <mtnviewmark> got it - that's quite nice to know
20:57:47 <zachk> how do i type convert a double or a regular float to a GLfloat? 
20:57:56 <jmcarthur> my current use case is for a simple templating system
20:58:58 <Cale> zachk: realToFrac
21:00:45 <maurer_> Anyone know how to make a parsec language def have more than one way to write a one line comment?
21:01:04 <maurer_> I'm trying to implement a language definition, and it wants both "//" and "#" as valid.
21:01:05 <jmcarthur> ("My name is " ++ name ++ " and I am " ++ age ++ " years old." `appBuilder` foo), where those are overloaded strings and name and age access foo like you would in a reader monad or something
21:02:07 <jmcarthur> oh and the (++) is caleskell style there
21:02:30 <Cale> maurer_: Yeah, that's strange that they didn't use parsers for the commentStart, etc. fields
21:02:46 <maurer_> Cale: Even just [String] instead of String would work fine
21:07:06 <zachk> thank you Cale ;) 
21:21:39 <kmc> QuickSpec !
21:22:25 <copumpkin> yeah!
21:23:11 <kmc> coming again to save the motherfucking day
21:23:56 <copumpkin> :)
21:36:32 <maurer_> kmc: How's the project coming?
21:37:04 <kmc> it's coming
21:37:15 <kmc> most of the packages we need build, haven't tested them all yet
21:41:59 <co_dh> I found a few times that my emacs capitalized a line which starts from column zero, e.g instance ===> Instance,  does anybody have the same problem? 
21:42:56 <kmc> if you hit the wrong key in emacs, sometimes it will punish you by fucking up your file
21:55:54 <co_dh> @info Control.Category
21:55:54 <lambdabot> Control.Category
21:56:56 <copumpkin> @info sucks
21:56:56 <lambdabot> sucks
21:57:48 <co_dh> lol
22:01:32 <co_dh> @info (>>>)
22:01:32 <lambdabot> (>>>)
22:01:55 <co_dh> :help
22:01:58 <co_dh> @help
22:01:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:02:02 <co_dh> @list
22:02:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:02:35 <co_dh> @dice
22:02:35 <lambdabot> unexpected end of input: expecting number
22:02:40 <co_dh> @dice 5
22:02:41 <lambdabot> 5 => 5
22:02:45 <co_dh> @dice 1000
22:02:45 <lambdabot> 1000 => 1000
22:02:47 <kmc> @dice 5d8
22:02:48 <lambdabot> 5d8 => 24
22:02:50 <kmc> @dice 5d8
22:02:51 <lambdabot> 5d8 => 28
22:02:59 <kmc> @dice 1000000d2
22:02:59 <lambdabot> 1000000d2 => 1499099
22:03:00 <co_dh> :t 5d8
22:03:01 <lambdabot> Not in scope: `d8'
22:03:03 <kmc> @dice 100000000d2
22:03:04 <lambdabot> 100000000d2 => 149993637
22:03:08 <co_dh> what's 5d8 means?
22:03:12 <co_dh> @help dice
22:03:13 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
22:03:13 <kmc> 5 dice of 8 sides each
22:03:14 <kmc> summed
22:03:43 <kmc> http://en.wikipedia.org/wiki/Dice_notation
22:03:55 <co_dh> @help compose
22:03:55 <lambdabot> . <cmd1> <cmd2> [args].
22:03:55 <lambdabot> . [or compose] is the composition of two plugins
22:03:55 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
22:03:55 <kmc> @dice 100000000000d2
22:03:56 <lambdabot> 100000000000d2 => 149999990411
22:04:03 <kmc> man i love the central limit theorem
22:04:17 <co_dh> @help dict
22:04:17 <lambdabot> I perform dictionary lookups via the following 13 commands:
22:04:17 <lambdabot> all-dicts ... Query all databases on dict.org
22:04:17 <lambdabot> devils ...... The Devil's Dictionary
22:04:17 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
22:04:17 <lambdabot> elements .... Elements database
22:04:19 <lambdabot> [9 @more lines]
22:04:42 <co_dh> @all-dicts theorem
22:04:43 <lambdabot> *** "Theorem" gcide "The Collaborative International Dictionary of English v.0.48"
22:04:43 <lambdabot> Theorem \The"o*rem\, n. [L. theorema, Gr. ? a sight,
22:04:43 <lambdabot>    speculation, theory, theorem, fr. ? to look at, ? a
22:04:43 <lambdabot>    spectator: cf. F. th['e]or[`e]me. See {Theory}.]
22:04:43 <lambdabot>    1. That which is considered and established as a principle;
22:04:45 <lambdabot> [66 @more lines]
22:05:03 <co_dh> @help djinn
22:05:04 <lambdabot> djinn <type>.
22:05:04 <lambdabot> Generates Haskell code from a type.
22:05:04 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
22:05:18 <co_dh> @djinn a->a
22:05:18 <lambdabot> f a = a
22:05:29 <co_dh> @djinn (a,b) -> (b,a)
22:05:29 <lambdabot> f (a, b) = (b, a)
22:05:56 <FunctorSalad_> kmc: presumably @bot :) uses a normal approximation for large enough n? ;)
22:06:08 <FunctorSalad_> which would make the experiment not very good evidence
22:06:12 <co_dh> @djinn IO ( Mabye a ) -> a
22:06:12 <lambdabot> Error: Undefined type IO
22:06:46 <co_dh> @help karma
22:06:46 <lambdabot> karma <polynick>. Return a person's karma value
22:06:56 <lispy> polynick?
22:06:57 <co_dh> @karma co_dh
22:06:57 <lambdabot> You have a karma of 0
22:06:58 <FunctorSalad_> @bot
22:06:58 <lambdabot> :)
22:07:09 <co_dh> @karma FunctorSalad_
22:07:09 <lambdabot> FunctorSalad_ has a karma of 0
22:07:38 <co_dh> @google FunctorSalad_
22:07:39 <lambdabot> No Result Found.
22:07:50 <co_dh> @google copumpkin
22:07:51 <lambdabot> http://twitter.com/copumpkin
22:07:51 <lambdabot> Title: Daniel Peebles (copumpkin) on Twitter
22:08:04 <copumpkin> ?
22:08:46 <co_dh> nothing, just try google command :) and I now your name very well 
22:09:42 <FunctorSalad_> 10 billion iterations is still somewhat realistic I guess, but not in < 1 second
22:09:50 <FunctorSalad_> @dice 100000000000d2
22:09:50 <lambdabot> 100000000000d2 => 149999936333
22:10:14 <FunctorSalad_> @dice 900000000000d2
22:10:14 <lambdabot> 900000000000d2 => 1349999299251
22:10:58 <kmc> FunctorSalad_, and not with System.Random ;)
22:11:02 <kmc> if it's using MT maybe
22:12:15 <tonypnz> Hi all. I'm beginning to learn Haskell. I'm going to buy the Real World Haskell book, is it worthwhile getting Programming in Haskell by Hutton as well?
22:12:47 <ksf> how do I manually install haddock docs into ~/.cabal and re-generate the index?
22:13:43 <ManateeLazyCat> tonypnz: Yes.
22:14:38 <Cads> tonypnz: I think the RWH book is a lot more in the modern style of programming where it tackles how to use a language to get stuff done, but the hutton book and some others are more solid at actually talking about haskell
22:15:02 <Cads> that said I like the book's style
22:15:21 * ksf got everything out of sicp, now year-old tutorials and papers
22:15:30 <kmc> tonypnz, btw RWH is available online for free
22:15:37 <Nibble> tonypnz: http://books.google.se/books?id=olp7lAtpRX0C&dq=programming+in+haskell+Hutton&printsec=frontcover&source=bn&hl=en&ei=yI98TLe5MsmZOPqGwIIE&sa=X&oi=book_result&ct=result&resnum=5&ved=0CCkQ6AEwBA#v=onepage&q&f=false
22:15:42 <Nibble> you can always read a bit there
22:15:48 <kmc> tonypnz, plenty of good reasons to buy it though :)
22:15:48 <Cads> a professor I know cries that the index is pretty poor, but you can find the pdf version to search, I suppose
22:16:02 <ManateeLazyCat> Does any encoding auto-detection library or someone developing it? :)
22:16:03 <ksf> tonypnz, you might want to try the "functional pearl" series of papers.
22:16:09 <ksf> a lot of very, very good haskell in there.
22:16:21 <Cads> tonypnz: I ordered mine used from amazon for something like 21 dollars, I believe.. was pretty satisfied
22:16:37 <ksf> ...I'm not aware of a single book which teaches all of haskell.
22:16:46 <Cads> tonypnz: and the Monad.reader
22:16:55 <ksf> and the guide to the xmonad source.
22:16:58 <Cads> but those are pretty technical
22:17:04 <Nibble> I should get a hold of one of those myself.. Reading from the computer screen is nowhere as good as reading from a book
22:17:07 <tonypnz> Great, thanks a lot for your answers all :)
22:17:16 <tonypnz> Yeah I prefer reading a book too
22:17:32 <ksf> playing with xmonad has the additional bonus of yielding you a very, very good window manager.
22:17:54 <Nibble> ksf: managehooks are awesome
22:18:23 <tonypnz> ksf, I installed xmonad on my arch box last night :)
22:18:39 <tonypnz> but my main machine is win7
22:18:46 <co_dh> Does anybody know if Paul Hudak on this irc ? 
22:19:50 <ksf> great! we need more windows developers so that the other windows developer can stop moaning about allegedly lacking community support.
22:20:12 <tonypnz> haha ok
22:21:00 <ksf> (I actually saw a complaint once that said "My OS is called windows, not MinGW"
22:22:40 <lispy> co_dh: fairly sure he is not
22:22:49 <kmc> xmonad is a very, very good window manager, if you like its philosophy
22:22:59 <kmc> if you want to split panes manually, it's not a great fit
22:23:01 <co_dh> lispy: thanks. 
22:23:10 <co_dh> kmc what philosphy?
22:23:14 <Entroacceptor> except that is has some very old bugs not resolved..
22:23:16 <ksf> there's all the bluetile stuff.
22:23:32 <kmc> layout computed dynamically from a set of windows and some parameters
22:23:38 <kmc> rather than explicit splits placed by the user
22:24:16 <ksf> you know that you can change layouts on the fly and rearragnge windows and move splits?
22:24:24 <kmc> yes
22:24:35 <kmc> fsvo "move splits"
22:25:03 <kmc> basically if you've used ion3 or another "static" tiling wm
22:25:09 <kmc> you get used to being able to split any pane anywhere
22:25:14 <kmc> and that's not how xmonad works
22:25:17 * hackagebot persistent 0.2.0.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.2.0.1 (MichaelSnoyman)
22:25:19 * hackagebot yesod 0.5.0.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.5.0.1 (MichaelSnoyman)
22:25:25 <co_dh> I use emacs, is that the same concept of split? 
22:25:27 <tonypnz> is there anything in particular i need to be aware of with regards to haskell on windows?
22:25:31 <ksf> I'd imagine keyboard navigation to be a bugger, then.
22:25:45 <kmc> ksf, i'm working on a little prototype.  might turn into a WM some day
22:26:01 <ksf> tonypnz, some libraries won't install that easily because they depend on unixy stuff.
22:26:17 * hackagebot yesod-examples 0.5.0.1 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.5.0.1 (MichaelSnoyman)
22:26:19 <ksf> I think a cygwin install or similar should alleviate that, though.
22:27:10 <ksf> there's some minor stuff like withSocketsDo, but otherwise haskell is very, very portable.
22:27:12 <maurer_> I've built a program with ghc, and it segfaults. I do not suspect a compiler bug, as my system install got severely fucked with recently. Any ideas on how to track down what's wrong with my system?
22:27:32 <ksf> I've heard more than one report of people compiling stuff under wine and then running it flawlessly on win.
22:28:18 <ksf> maurer_, don't bother, reinstall, for virtually all values of "fucked"
22:28:40 <maurer_> ksf: Damn.
22:29:00 <ksf> tracking such stuff down is usually a very, very long and unyielding task.
22:29:41 <maurer_> Yeah, I probably should, as 'main = print "test"' segfaults.
22:29:42 <c_wraith> I've built a program with GHC and it segfaults.  I suspect it *is* ghc's fault, because it's in the garbage collector. :(
22:29:52 <kmc> maurer_, perhaps: ghc -debug -O0 -fvia-C -optc-g -optc-O0
22:30:05 <ksf> also, get a stacktrace.
22:30:13 <kmc> maurer_, when you build with ghc -debug, you get a bunch of new RTS options like " -DS  DEBUG: sanity"
22:30:18 * hackagebot yesod-examples 0.5.0.2 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.5.0.2 (MichaelSnoyman)
22:30:28 <c_wraith> hmm, that's a short release cycle
22:30:38 <lispy> haha
22:30:45 <lispy> c_wraith: tis indeed
22:30:53 <kmc> maurer_, with those options perhaps gdb will give you something useful
22:31:03 <co_dh> lol, it's short.
22:31:06 <lispy> c_wraith: < 5 minutes, it looks like
22:31:13 <kmc> maurer_, see also http://hackage.haskell.org/trac/ghc/wiki/Debugging/RuntimeSystem and http://hackage.haskell.org/trac/ghc/wiki/Debugging/CompiledCode
22:31:47 <maurer_> kmc: I downgraded my distro (an unsupported operation) recently, so I really suspect that I should follow ksf's advice and just reinstall all things haskell
22:31:55 <kmc> yeah probably ;)
22:32:25 <ManateeLazyCat> lispy: Do you know any encoding auto-detection library?
22:32:35 <ManateeLazyCat> lispy: Like python-chardet
22:32:46 <lispy> ManateeLazyCat: I'm the wrong person to ask :)
22:33:02 <ManateeLazyCat> lispy: Who's right person? ;-)
22:33:20 <lispy> ManateeLazyCat: maybe tux_rocker
22:33:30 <lispy> preflex: seen tux_rocker
22:33:30 <preflex>  tux_rocker was last seen on #darcs 3 days, 8 hours, 23 minutes and 37 seconds ago, saying: kowey: darcs has been needing 6.10 now for some time, right?
22:33:48 <co_dh> at least xmonad's code is worthy reading , 0.7 has only 1200 line of code . 
22:36:37 <ManateeLazyCat> lispy: There have many encoding library, such as encoding, iconv...etc, just haven't auto-detection library for editor or irc client.
22:40:50 <tonypnz> aah my local library has a safari books online subscription with real world haskell.. $ saved :)
22:42:01 <lispy> tonypnz: http://book.realworldhaskell.org/read/
22:42:24 <tonypnz> huh
22:43:19 <tonypnz> time to utilise the office printer
22:43:55 <ksf> ManateeLazyCat, icu?
22:44:11 <ManateeLazyCat> ksf: icu? What's icu?
22:44:16 <ksf> if everything else fails, try different encodings and see whether they suceed
22:44:31 <ksf> http://site.icu-project.org/
22:44:47 <ksf> http://hackage.haskell.org/package/text-icu
22:45:23 <ksf> http://userguide.icu-project.org/conversion/detection
22:46:13 <lispy> ManateeLazyCat: and there is a hackage libary for it: http://hackage.haskell.org/package/text-icu
22:47:50 <ManateeLazyCat> Thanks, i looking...
22:49:12 * ManateeLazyCat Damn gfw, why you filter above links that just for programming...?
22:50:04 <ksf> they have an own country code for taiwan?
22:50:42 <ManateeLazyCat> ksf: Own country code? What do you mean?
22:51:38 <ManateeLazyCat> ksf: TaiWan is not country, it's part of China!
22:51:42 <ksf> well, everybody who aknowledges the existence of an independent country called "taiwan" by not giving it the same country code as china obviously sprouts propaganda.
22:51:48 <ksf> exactly.
22:52:25 <ManateeLazyCat> ksf: Not propaganda, it's truth. 
22:52:33 <luite> does anyone know a packed array implementation for storing integers, that uses exponential-Golomb coding or similar?
22:52:37 <ksf> well, I won't argue about it.
22:52:50 <ManateeLazyCat> ksf: TaiWan always is part of China, i hate GFW, but i agree gov about TaiWan.
22:53:12 <luite> (obviously to allow random access it would have to do a little more than just store a stream of Golomb-coded values)
22:53:32 <Entroacceptor> Taiwan is so not part of China
22:53:48 <ksf> serbia and kosovo, turkey and cyprus, the list goes on and on.
22:54:01 <ksf> germany and all of its member states, for that matter.
22:54:01 <ManateeLazyCat> ksf: You should read some history from 1945 ~ 1949
22:54:16 <ManateeLazyCat> Entroacceptor: Who tell you it's not?
22:54:28 <ksf> for once, the taiwanese.
22:54:42 <maurer_> ManateeLazyCat: The Taiwanese gov't who appears to not be taking orders from the Chinese?
22:55:15 <ksf> oh, marocco and west sahara.
22:55:23 <ksf> the US and canada ;)
22:55:47 <ManateeLazyCat> maurer_: Our bodies with the same blood flow, and we speak the same language.
22:57:22 * ksf thinks germany could annex the netherlands, half of belgium, luxembourg, a third of switzerland, austria, north italia and actually all them scandinavian countries with that line of thought.
22:57:25 * ManateeLazyCat I have some aversion to those who do not understand Chinese history, arbitrary conclusions, in fact, don't know anything of Chinese.
22:57:49 <ksf> in fact, I think some idiot once tried to do so.
22:57:53 <lispy> Politics to #haskell-blah please
22:58:02 <ksf> yep I just went godwin.
22:58:02 <kmc> since when do "blood" and "language" have anything to do with the modern concept of nation-state?
22:58:23 <lispy> kmc, ksf, ManateeLazyCat: please move this to #haskell-blah
22:59:23 <kmc> well ManateeLazyCat isn't there
22:59:26 <kmc> so you've killed the argument
23:00:11 <lispy> The topic just isn't appropriate for #haskell is all
23:00:15 <kmc> agreed
23:00:26 <kmc> ManateeLazyCat, join #haskell-blah?
23:01:03 <ManateeLazyCat> kmc: I just said a fact that the Chinese people should to say...
23:01:16 <kmc> ManateeLazyCat, you're off topic, please join #haskell-blah
23:01:19 <kmc> or stop talking about it
23:04:57 <co_dh> I found the best way to learn Yampa is reading it's unit test. 
23:05:19 <zachk> is yampa up to date?
23:05:32 <co_dh> they have no document , for example iPre ..
23:05:48 <co_dh> I have 0.9.2.3
23:06:10 <co_dh> but in the source package, there is test folder, 
23:10:07 <co_dh> does anybody know what's loop_acc mean in Yampa? 
23:10:58 <co_dh> oh , my fault, it's defined in the test code.
23:11:47 <gloob_> join  #thinkpad-forum
23:19:00 <co_dh> loop $ arr (\ (_,f) -> (f 4,factGen f)
23:19:10 <co_dh> factGen f n = if (n==0) then 1 else n*f(n-1)
23:19:30 <co_dh> the loop $ arr is a weird way of calculating fact 4 , 
23:19:38 <co_dh> anybody understand how it works? 
23:19:45 <ManateeLazyCat> ksf: I have review the code of text-icu, i haven't found any auto-detect features, at least not found in text-icu binding.
23:19:46 <c_wraith> :t loop
23:19:47 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
23:19:50 <ManateeLazyCat> ksf: Any idea?
23:20:58 <co_dh> > fix factGen $ 4
23:20:59 <lambdabot>   Not in scope: `factGen'
23:21:15 <co_dh> > let factGen f n = if (n==0) then 1 else n*f(n-1)
23:21:16 <lambdabot>   not an expression: `let factGen f n = if (n==0) then 1 else n*f(n-1)'
23:21:22 <co_dh> > fix factGen $ 4
23:21:23 <lambdabot>   Not in scope: `factGen'
23:23:01 <chrisdone> http://i.imgur.com/05BWe.png
23:23:03 <chrisdone> NICE!
23:23:24 <co_dh> what nice ? a virus?
23:24:08 <luite> is that for Map or IntMap?
23:24:34 <co_dh> :i fix
23:24:40 <co_dh> @hoggle fix
23:24:40 <lambdabot> Data.Function fix :: (a -> a) -> a
23:24:41 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
23:24:41 <lambdabot> module Control.Monad.Fix
23:24:43 <chrisdone> Data.Map
23:24:56 <co_dh> @src fix
23:24:56 <lambdabot> fix f = let x = f x in x
23:25:42 <luite> chrisdone: ah I've seen the patch then, must say that I was a little disappointed that these changes could make such a difference
23:26:49 <co_dh> what changes?
23:28:15 <ksf> ManateeLazyCat, it's in the C/Java bindings
23:28:25 <ksf> ...csdetect.h
23:29:24 <chrisdone> luite: you mean that they were implemented poorly originally or that the compiler couldn't make the optimisations itself?
23:29:31 <luite> chrisdone: the latter
23:30:05 <luite> chrisdone: most changes are INLINE pragma's and adding extra worker function to avoid passing arguments unchanged
23:30:17 <chrisdone> maybe this provides a good testing ground for work on the compiler to do such optimisations
23:30:54 <ksf> ghc could also give metrics about such stuff.
23:31:12 <ManateeLazyCat> ksf: Have you use csdetect? Accurate?
23:31:23 <ksf> ...that is, ones that are more approachable and comprehensive than the current stuff.
23:31:34 <ksf> ManateeLazyCat, nope, but I've only heard good things about icu
23:32:00 <ksf> it uses a lot of heuristics to detect stuff, according to the docs
23:32:38 <ManateeLazyCat> ksf: I need auto-detect library detect encoding of file or IRC message....
23:33:29 <co_dh> luite: are you talking about Haskell code or c ?
23:33:36 <co_dh> the INLINE pragma
23:33:43 <luite> co_dh: haskell code
23:34:07 <ksf> ManateeLazyCat, that could be not enough data to go by in the case of a single message.
23:34:50 <ksf> but I don't think that'd be a problem if you don't want to distinguish between different iso charsets or such.
23:40:14 <ManateeLazyCat> ksf: I need detect which encoding, then convert to UTF-8 for display.
23:41:01 <ksf> I'd say icu is your best bet
23:41:26 <ksf> if that won't do what you want, chances are slim you can do it better yourself.
23:42:13 <co_dh> does anybody knows what the sscan in Yampa do ? 
23:42:24 <ksf> :t scan
23:42:25 <lambdabot> Not in scope: `scan'
23:42:29 <ksf> :t List.scan
23:42:30 <lambdabot> Not in scope: `List.scan'
23:42:31 <ksf> :t List.scanl
23:42:32 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
23:42:33 <co_dh> :t sscan
23:42:34 <lambdabot> Not in scope: `sscan'
23:42:39 <ksf> something close to that.
23:42:41 <co_dh> it's sscan , not scan
23:42:49 <Twey> ?
23:42:51 <ksf> because it works on signals?
23:42:55 <Twey> Ah
23:43:08 <co_dh> ksf: oh , I think you are right , thanks.
23:43:42 <co_dh> :t (-->)
23:43:43 <lambdabot> parse error (possibly incorrect indentation)
23:48:12 <Twey> Parse error?  o.@
23:48:19 <Twey> :t (--->)
23:48:20 <lambdabot> parse error (possibly incorrect indentation)
23:48:28 <Twey> :t ($$$$$)
23:48:29 <lambdabot> Not in scope: `$$$$$'
23:48:46 <co_dh> Twey: lambda don't know Yampa, and (-->) is defined in Yampa
23:48:55 <Twey> Doesn't matter
23:49:09 <Twey> It should parse as a normal operator and we should get an ‘out of scope’ error like that one
23:49:20 <Twey> Not a parse error
23:49:35 <Twey> > let (--->) = (+) in 3 ---> 5
23:49:36 <luite> > 1 ---> 2
23:49:36 <lambdabot>   8
23:49:37 <lambdabot>   Not in scope: `--->'
23:49:45 <Twey> > let (-->) = (+) in 3 --> 5
23:49:46 <lambdabot>   8
23:49:56 <Twey> I guess :t's parser is a little broken
