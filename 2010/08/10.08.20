00:00:08 <dibblego> request for comment http://paste.pocoo.org/show/252328/
00:09:11 <tolkad> I have a type synonym used across multiple files
00:09:33 <tolkad> and I have to delete all .o directories before compiling or I get a bunch of type errors
00:09:41 <tolkad> .o files*
00:09:48 <tolkad> any idea how to fix this?
00:10:03 <kmc> you're using ghc --make?
00:10:06 <tolkad> yeah
00:10:08 <kmc> and ghc still fails to rebuild files properly?
00:10:12 <tolkad> yeah
00:10:14 <kmc> i guess that's a ghc bug
00:10:21 <kmc> you can use -fforce-recomp instead of deleting
00:10:31 <tolkad> thanks
00:10:44 <kmc> if you can make a minimal test case i can try to figure out what's going on
00:10:56 <tolkad> sure
00:16:11 <tolkad> hmm, hard to reproduce
00:16:18 <tolkad> rather than rebuilding, I'll try reducing
00:19:34 * hackagebot cryptohash 0.5.2 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.5.2 (VincentHanquez)
00:26:06 <tolkad> still reducing code to simplest example
00:27:51 <tolkad> wow... this is hard to reproduce
00:31:41 <tolkad> I can't seem to get it to work, I might work on it later
00:32:06 <Axman6> tolkad: ask in #ghc, they should be able to help you figure out how to reproduce it
00:33:04 <tolkad> Axman6: I'll figure it out later, I'm just taking a break because I have to start over because it started working after moving some files around
00:33:53 <JoeyA> Umm, is cryptohash brand new?
00:34:11 <JoeyA> I actually needed that like right away.  Funny coincidence.
00:34:17 <JoeyA> (well, not that urgently)
00:35:00 <JoeyA> I was just about to look into using FFI for SHA1
00:35:28 <Axman6> well, that seems to be exactly what it does
00:35:38 <JoeyA> indeed :)
00:35:50 <JoeyA> But the timing was phenomenal
00:36:10 <JoeyA> I'm just curious if that's an update or if it's a brand new upload.
00:36:27 <Axman6> it's an update
00:36:52 <hirsch_> What is the <+> operator, can't find any documentation or hint in what module it is defined? (And it is impossible to google for it)
00:37:06 <medfly> @hoogle (<+>)
00:37:06 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
00:37:06 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
00:37:06 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
00:37:18 <Zao> Smells like an Arrow.
00:37:19 <JoeyA> If you can't google, then hoogle :-)
00:37:21 <JoeyA> http://www.haskell.org/hoogle/?hoogle=%3C%2B%3E
00:37:39 <hirsch_> yes, hoogle, thanks!
00:37:51 <JoeyA> Although I would have thought to try googlf, then googlg, etc. first
00:39:02 <JoeyA> (I would have thought <+> was from a parser combinator library like uu-parsinglibe
00:39:07 <JoeyA> uu-parsinglib *
00:39:56 <luite> dons: there are two bindings to judy on hackage, the newest of which is yours. do you remember why you wrote a new one?
00:50:53 <JoeyA> I'm on Ubuntu, and I'm getting linker errors when loading the unix-2.4.0.2 package in GHCi.
00:51:02 <JoeyA> duplicate symbol:  __hscore_getrlimit
00:54:04 <`steven> how do i iterate over every pair of a list quickly? if i use !!, i assume i will get O(n) overhead for every lookup
00:54:15 <Axman6> map?
00:54:27 <Axman6> map, foldl, foldr?
00:54:32 <Axman6> depends what you want to do
00:54:34 <JoeyA> what do you mean pair?  Like this?
00:54:44 <JoeyA> > (zip`ap`tail) [1,2,3,4]
00:54:45 <lambdabot>   [(1,2),(2,3),(3,4)]
00:55:17 <`steven> i mean like [1,2,3,4] -> [(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)]
00:55:41 <JoeyA> @quote zip`ap`tail
00:55:41 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
00:55:48 <Axman6> > zipWith (+) `ap` tail $ [1..4]
00:55:49 <JoeyA> oh
00:55:49 <lambdabot>   [3,5,7]
00:55:56 <koala_man> all unordered pairs
00:56:00 <Axman6> ah
00:57:09 <JoeyA> Here's a snippet I wrote a couple months ago:
00:57:11 <JoeyA> pairs :: [a] -> [(a,a)]
00:57:11 <JoeyA> pairs [] = []
00:57:11 <JoeyA> pairs (x:xs) = map ((,) x) xs ++ pairs xs
00:57:45 <JoeyA> steven: This should be exactly what you need
00:58:11 <`steven> JoeyA: makes sense, thanks
00:58:25 <JoeyA> The idea is, you go through the tail of the list and make a tuple with the head on the left of each
00:58:36 <JoeyA> as in, [(1,2),(1,3),(1,4)]
00:58:52 <JoeyA> Then, repeat with the xs
00:59:04 <JoeyA> Thanks to lazy evaluation, this runs in constant space.
00:59:21 <luite> I used this a few days ago:
00:59:28 <Axman6> well, space proportional to the size of the list i think
00:59:40 <luite> mapPairs f xs = do (y:ys) <- L.tails xs ; map (f y) ys
00:59:50 <Axman6> as with most things, it depends on whether the list if produced lazily or not
00:59:54 <luite> where yours is mapPairs (,)
01:00:18 <JoeyA> oh, right
01:00:28 <luite> oh L.tails is Data.List.tails, I imported it qualified
01:00:54 <JoeyA> so it's most likely O(n)
01:00:57 <JoeyA> space
01:00:58 <Axman6> @. @pl @undo do (y:ys) <- L.tails xs ; map (f y) ys
01:00:58 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
01:01:07 <Axman6> @. pl undo do (y:ys) <- L.tails xs ; map (f y) ys
01:01:07 <lambdabot> (line 1, column 33):
01:01:07 <lambdabot> unexpected "{"
01:01:08 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
01:01:08 <JoeyA> rather than O(stack)
01:01:16 <Axman6> @. undo pl do (y:ys) <- L.tails xs ; map (f y) ys
01:01:16 <lambdabot>  Parse error at "ed" (column 30)
01:01:22 <JoeyA> Or O(crap)
01:01:47 <kmc> > [(x,y) | (x:ys) <- tails "abcde", y <- ys]
01:01:47 <luite> Axman6: it requires the pattern match failure handling of a do block (calling fail if it doesn't match), so it won't get better without do
01:01:48 <lambdabot>   [('a','b'),('a','c'),('a','d'),('a','e'),('b','c'),('b','d'),('b','e'),('c'...
01:02:17 <luite> that's basically the same as mine, also relies on fail
01:02:26 <kmc> yeah
01:03:58 <kmc> > [(x,y) | (x:ys) <- tails ("ab" ++ undefined), y <- ys]
01:03:59 <lambdabot>   [('a','b')*Exception: Prelude.undefined
01:04:06 <kmc> > [(x,y) | (x:ys) <- tails ("ab" ++ [undefined]), y <- ys]
01:04:07 <lambdabot>   [('a','b'),('a',*Exception: Prelude.undefined
01:05:51 <harlekin> How can I run a function using ghci from the command line?
01:06:03 <kmc> ghc -e ?
01:06:19 <kmc> it takes the same commands as ghci (even stuff like :t and :m)
01:06:23 <kmc> ghc -e "print (2+3)"
01:06:46 <harlekin> Can I use ghci for that, too?
01:07:03 <kmc> i'm confused
01:07:08 <c_wraith> what does your question mean?
01:07:11 <harlekin> Yeah, I think my question is stupid. (:
01:07:22 <kmc> ghci is just "ghc --interactive"
01:07:24 <c_wraith> you know that ghci is just a wrapper around ghc, that invokes it with certain arguments, right?
01:07:25 <kmc> -e is another mode for ghc
01:07:35 <harlekin> When I'm having a function of type Event (), I can just call that function in ghci.
01:07:44 <kmc> that's manifestly not a function
01:07:55 <kmc> if it were a function, it would have -> in its type
01:08:00 <kmc> (unless perhaps Event is a type synonym)
01:08:05 <harlekin> However, I cannot call it in ghc, because it's not of type IO. How can I reproduce ghci's behavior for Event () in ghc?
01:08:21 <kmc> by "in ghc" you mean in haskell code compiled with ghc?
01:08:46 <kmc> when ghci evaluates a value not of IO type, it calls "print"
01:09:00 <kmc> when you type «2+3» this desugars to something like «let it = 2+3 in print it»
01:09:01 <harlekin> Thanks! That's what I'm looking for.
01:09:08 <kmc> (you will even see reference to this variable "it" in some error messages)
01:09:35 <kmc> when ghci evaluates a value of IO type, it executes that action, and (if the result has showable type, and not ()) prints the result
01:10:00 <kmc> so «getChar» desugars to «getChar >>= print»
01:29:38 <zachk> > 3+3
01:29:39 <lambdabot>   6
01:30:04 <kmc> glad that's settled
01:35:10 <zachk> > let support = sortBy (\a b->snd b `compare` snd a) . map (\x->(head x,length x)) . group . sort in support . concat . words $ "the quick brown fox jumped over the lazy dog"
01:35:11 <lambdabot>   [('e',4),('o',4),('d',2),('h',2),('r',2),('t',2),('u',2),('a',1),('b',1),('...
01:36:23 <zachk> > let support = sortBy (\a b->snd b `compare` snd a) . map (\x->(head x,length x)) . group . sort in map fst . support . concat . words $ "the quick brown fox jumped over the lazy dog"
01:36:24 <lambdabot>   "eodhrtuabcfgijklmnpqvwxyz"
01:37:37 <chrisdone> should I use the Data-Files field in Cabal to include a configuration file in my distribution?
01:38:50 <FunctorSalad> chrisdone: an example one at least. the file actually used should maybe be read from ~/.blahrc since /usr/local/share/blah will be unwritable to a user
01:39:02 <FunctorSalad> (I mean something like the latter is the datadir with global install)
01:39:53 <chrisdone> then perhaps it should go in Extra-Source-Files
01:40:03 <FunctorSalad> (another option is to give the executable itself the ability to dump an example config)
01:40:20 <FunctorSalad> hmm what does extra-source-files do? :)
01:40:44 <chrisdone> just leaves it in the release tarball
01:41:09 <FunctorSalad> ack
01:41:28 <chrisdone> I don't think using Cabal will be a good idea to manage my whole project
01:43:04 <jystic> > let cs = map toLower (show (0/0)) in "I like " ++ (head cs:head (tail cs):tail cs) ++ " bread"
01:43:05 <lambdabot>   "I like naan bread"
01:44:25 <luite> hmm, dons' judy bindings only do Word -> Word mapping, and HsJudy doesn't appear to be maintained. I need some very fast byte array to int (any type is ok) map, and it can be as impure as it needs to be. any suggestions for alternatives?
01:46:04 <bastl> hey, id like to write an infix function that uses the '@' symbol, But @ seems to be forbidden. Any ways or tricks (like "escaping")?
01:46:34 <zachk> zardoz forbids it
01:47:47 <jystic> bastl: i think HUnit uses @ in an infix function
01:48:52 <bastl> jystic: thanks. I just have to  append a letter to the @
01:49:30 <jystic> here the example: http://hackage.haskell.org/packages/archive/HUnit/1.2.2.1/doc/html/src/Test-HUnit-Base.html#%40%3F
01:49:51 <FunctorSalad> operator character actually
01:50:06 <jystic> i don't think you can mix alphanumerics with symbols when defining a function, i think it's an operator or it's not
01:50:22 <FunctorSalad> (and any string of operator characters other than '@' will work)
01:50:46 <FunctorSalad> *other than "@" :)
01:51:38 <bastl> why is a single @ reserved?
01:52:01 <FunctorSalad> @-patterns
01:52:01 <lambdabot> Unknown command, try @list
01:52:03 <bastl> "@@" works well
01:52:09 <bastl> i see
01:52:27 <etpace> >let f y@(x:xs) = (y,xs) in f [1..5]
01:52:38 <bastl> thanks
01:53:41 <quicksilver> FunctorSalad: '|' is reserved too, no?
01:53:56 <quicksilver> and '='...
01:54:59 <FunctorSalad> quicksilver: I meant to say 'including an @' :)
01:55:41 <FunctorSalad> (the thing it will 'work' for was extending "@")
01:56:04 * quicksilver nods
01:57:24 <FunctorSalad> > let (__)=undefined in (__)
01:57:25 <lambdabot>   *Exception: Prelude.undefined
01:57:50 <FunctorSalad> nobody has grabbed this one? ;)
02:23:34 <jrockway> > let undefined = 42 in undefined
02:23:35 <lambdabot>   42
02:25:36 <Axman6> i like the definition of undefined in earlier versions of the report (i think): undefined | False = undefined
02:26:28 <FunctorSalad> that puts the magic into inexhaustive patterns...
02:27:50 <jrockway> so i just started going through my archive of haskell-cafe
02:28:33 <jrockway> is it fair to say that more than 60% of the posts are in the form of "due to <some minor implementation detail different from my world view>, haskell sucks in general and is too slow to even think about writing my blog in"
02:28:50 <jrockway> i remember a few years ago when everyone was so nice and was actually trying to write code
02:28:55 <jrockway> now it seems to be mostly whining
02:28:58 <jrockway> (hey, like this!)
02:29:33 <n00p> ... and then they go and write their blog in Ruby ;)
02:29:52 <jrockway> exactly!
02:30:07 <jrockway> "haskell is too slow to use because data.text is utf-16"
02:30:26 <jrockway> "ok, use bytestring"
02:30:47 <jrockway> "oh, but i want to use some obscure unicode character in one place, so the whole concept is flawed and fuck you all"
02:30:56 <jrockway> it would be funny if it was the php mailing list or something
02:31:01 <jrockway> but it mostly makes me sad :(
02:32:31 <earthy> bytestring with utf-8 works fine!
02:33:17 <FunctorSalad> yes
02:33:30 <FunctorSalad> Data.ByteString.UTF8.decode/encode
02:34:01 <FunctorSalad> hmm or toString/fromString maybe
02:34:16 <FunctorSalad> confused between the different pkgs
02:34:16 <earthy> yah, that's the utf8-string lib
02:34:24 <earthy> and then there's encoding as well
02:34:32 <earthy> you don't *have* to use data.text
02:34:38 <earthy> it's just more convenient
02:34:43 <earthy> and therefore comes at a price
02:35:03 <earthy> the entire idea that convenience is free is bogus.
02:35:34 <jrockway> i think it can be, but it takes a few users and some hacking first
02:35:38 <jrockway> strings are tricky though, i agree
02:36:14 <chrisdone> @quote chrisdone ruby
02:36:14 <lambdabot> chrisdone says: benchmarks only exist to make fun of ruby
02:38:35 <earthy> jrockway: there's too large a design space around textual strings
02:38:47 <earthy> what will be optimal for one use will not be for another
02:39:27 <earthy> and optimal does start to count when you go into the gigabytes of plain text
02:45:41 <chrisdone> I wonder if I can make a derived JSON instance of a data type for which Read/Show can be derived
02:46:33 <jrockway> doesn't JSON just need Typeable?
02:47:07 <chrisdone> Data.Derive seems to do it
02:47:36 <chrisdone> template haskell ~_~
02:48:52 <chrisdone> seems Typeable will do the trick
02:48:57 <chrisdone> ^_^
02:49:02 <jrockway> here's how i do it in an old-ish app: http://paste.scsys.co.uk/48665
02:49:05 <jrockway> seems clean enough though
02:49:59 <chrisdone> excellent
02:51:52 * Saizan would always prefer template haskell over Typeable when they overlap
02:53:27 <aristid> chrisdone: you could put the Show representation in a string, and call that JSON
02:58:53 <jrockway> but then the structure is opaque to the other side
03:02:28 <aristid> jrockway: yeah i wasn't entirely serious about this
03:03:23 <Baughn> Write it out as XML, then put /that/ in a JSON string
03:04:07 <jrockway> aristid: needs more sarcasm, like baughn
03:04:40 <jrockway> "write a binding to java, then just use java's YAML library and convert the newlines to spaces, and viola -- JSON!"
03:05:21 <aristid> haha "viola" for  dramatic effect (instead of "voila" :P)
03:06:16 <Axman6> http://www.boost.org/doc/libs/1_44_0/libs/preprocessor/doc/examples/delay.c .. ouch
03:08:34 <aristid> Axman6: haha
03:08:35 <jrockway> yeah, i say that in real life now
03:08:39 <jrockway> everyone just looks at me werid
03:08:42 <jrockway> but i think it's funny so it's ok
03:08:57 <Axman6> heh
03:09:00 <Zao> Boost.PP is all sorts of awesome.
03:09:07 <jrockway> they need a macro to generate their macros
03:09:15 <Axman6> aye
03:09:19 <jrockway> ("yo dawg, i put a macro in your macro so you can macro while you macro")
03:09:29 <Zao> I prefer cool stuff like Phoenix3 and Fusion, bringing some Fun into the horrors of C++.
03:09:38 <chrisdone> @hoogle decodeJSON
03:09:38 <lambdabot> No results found
03:09:47 <chrisdone> @slap hoogle
03:09:48 * lambdabot decomposes hoogle into several parts using the Banach-Tarski theorem and reassembles them to get two copies of hoogle!
03:10:13 <chrisdone> guess that's how hayoo was created
03:10:24 <Baughn> But, but.. hoogle's not continuous...
03:10:24 <jrockway> we have an internal C++ library that describes invoking the functions as "applying" them
03:10:27 <jrockway> if only.
03:10:39 <FunctorSalad> chrisdone: my hoogle file has it :P
03:10:42 <chrisdone> for some reason my ghci is unaware of the decodeJSON function despite my importation and use of it in the file
03:10:53 <jrockway> (it also calls the functions functors)
03:11:01 <FunctorSalad> I made a gigantic one from all packages I had installed
03:11:19 <Zao> http://boost-spirit.com/home/2010/07/23/phoenix3-gsoc-project/ <- awesome
03:12:23 <jrockway> what's the point of FP in C++ anyway?
03:12:48 <jrockway> to enjoy manual memory management AND functional programming in the same app?
03:12:52 <dobblego> to admit to oneself we should all be using haskell
03:13:13 <jrockway> something i realized about C++ after using it a bit
03:13:20 <jrockway> is that it suffers from the same problem as every other language
03:13:23 <Zao> jrockway: To lessen the pain of having to use the language due to policy/constraints.
03:13:31 <jrockway> if you write it however you feel like writing it, it's slow
03:13:48 <FunctorSalad> chrisdone: code.haskell.org/~daniels/default.hoo
03:13:52 <jrockway> this is good because my reimplementation-in-haskell is faster than the C++ version
03:14:00 <jrockway> which clearly means that haskell is faster than C++
03:14:06 <jrockway> And It Should Always Be Used
03:14:27 <FunctorSalad> currently trying to get the executable that put that file together portable enough to release o_O
03:14:39 <Zao> jrockway: I wrote a quick tool for Work the other day in Haskell.
03:14:48 <Zao> jrockway: Went all swell until I needed to call a C function.
03:14:56 <Zao> (well, apart from the Data.Text bugs)
03:15:09 <chrisdone> is there a decodeJSON :: Data a => String -> Maybe a?
03:15:49 <chrisdone> guess I'll have to implement in terms of other functions
03:16:04 <jrockway> i like c2hs for dealing with c
03:16:25 <jrockway> (c++ is a pain to call though, due to mangling)
03:16:42 <jrockway> chrisdone: why do you want a maybe return value?
03:16:45 <FunctorSalad> hmm actually my default.hoo is just 2.4M with the stock one being 2.1M, but I assembled quite a few more packages
03:16:48 <jrockway> in case the JSON doesn't parse or something?
03:16:52 <FunctorSalad> they were probablt all small
03:16:52 <chrisdone> jrockway: uh, yeah
03:16:59 <chrisdone> o-o
03:17:10 <jrockway> hmm
03:17:21 <Axman6> jrockway: that's generally why you use Maybe :)
03:17:36 <FunctorSalad> think I'll just fetch ALL of hackage *evil laugh*
03:17:40 <jrockway> Text.JSON.decode returns a Result
03:17:49 <jrockway> where Result = OK | Error
03:17:59 <chrisdone> yeah just found it
03:18:27 <jrockway> if only there was already some type in haskell that could represent success or failure with an error message
03:18:28 <Zao> jrockway: I used bindings-DSL for wrapping the function and the struct it took, but it's pain filling out the 14-odd fields of a struct when several are pointers.
03:18:31 <cncl> is there a specific flag to suppress unused binding warnings at the top level?
03:18:39 <Zao> jrockway: Either?
03:18:44 <Zao> :D
03:19:13 <jrockway> (to be fair, there is a resultToEither function there, but why not just go right to Either)
03:19:21 <jrockway> or is that "go Right to Either"
03:19:27 <Zao> *groan*
03:20:06 <FunctorSalad> :Δ
03:20:40 <jrockway> anyway, c2hs can autogenerate structs
03:22:19 <FunctorSalad> going right to Either would have teh advantage of being able to use `either'
03:22:33 <chrisdone> oh wait
03:22:45 <chrisdone> decode has a JSON constraint
03:22:48 <chrisdone> not a Data constraint
03:23:17 <FunctorSalad> chrisdone: you do want to use the json package, not jsonb?
03:23:23 <chrisdone> I'll just define one in terms of fromJSON
03:23:29 <FunctorSalad> iirc the JSON typeclass is from the json package
03:23:29 <chrisdone> FunctorSalad: dunno?
03:23:42 <FunctorSalad> JSONb is simpler and uses BS
03:23:57 <jrockway> that looks nicer
03:24:00 <chrisdone> bytestrings, for hardcore json decoding!
03:24:02 <FunctorSalad> don't know off-hand if it has a pure-error parsing fun
03:24:16 <jrockway> decode :: ByteString -> Either String JSON
03:24:39 <FunctorSalad> chrisdone: and objects are tries, I feel horrible when using assoc lists
03:24:47 <FunctorSalad> as package:json uses afaik
03:25:47 * FunctorSalad downloads hackage planning to make one MONSTER default.hoo
03:25:58 <rrc7cz> is there any fn that takes [1,2,3,4] and returns a list of pairs like [(1,2),(3,4)]? or do you just have to use fold?
03:26:42 <Baughn> @djinn [a] -> [(a,a)]
03:26:42 <Cale> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1,2,3,4]
03:26:42 <lambdabot> Error: Undefined type []
03:26:43 <lambdabot>   [[1,2],[3,4]]
03:26:52 <Cale> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1,2,3,4,5]
03:26:53 <lambdabot>   [[1,2],[3,4],[5]]
03:26:54 <Axman6> > zip `ap` (tail.tail) $ [1,2,3,4]
03:26:55 <lambdabot>   [(1,3),(2,4)]
03:27:01 <Axman6> wut? lame
03:27:07 <jrockway> haha
03:27:19 <Axman6> > zip `ap` (tail.tail.tail) $ [1,2,3,4,5,6,7,8]
03:27:19 <aristid> Axman6: yeah, use <*> instead of ap, man
03:27:20 <lambdabot>   [(1,4),(2,5),(3,6),(4,7),(5,8)]
03:27:33 <Axman6> how interesting
03:27:45 <aristid> > zip <*> drop 3 $ [1,2,3,4,5,6,7,8]
03:27:46 <lambdabot>   [(1,4),(2,5),(3,6),(4,7),(5,8)]
03:27:47 <Axman6> > zip <*> (tail.tail.tail) $ [1,2,3,4,5,6,7,8]
03:27:48 <lambdabot>   [(1,4),(2,5),(3,6),(4,7),(5,8)]
03:28:03 <Axman6> aristid: duh, right
03:28:06 <Axman6> thanks
03:28:23 <aristid> Axman6: this isn't lisp where you have to do cdddr :D
03:28:55 <FunctorSalad> @type unzip
03:28:56 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
03:28:59 <Axman6> ... that exists?
03:29:04 <Cale> So after my function, all you have to do is decide how to deal with possible lists of length 1
03:29:12 * Axman6 found out where car and cdr came from today
03:29:25 <jrockway> (i think i implemented this once, and zipped with tail and a list of [True,False,True,False...], then filtered out the pairs that were false)
03:29:32 <jrockway> not going to write that on irc though 
03:30:08 <rrc7cz> thanks guys
03:30:15 <aristid> > filter (not . null . tail) . map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1,2,3,4,5]
03:30:16 <lambdabot>   [[1,2],[3,4]]
03:31:29 <aristid> Axman6: yeah, cdddr exists, (cdddr x) is (cdr (cdr (cdr x)))
03:31:45 <FunctorSalad> > unfoldr (\(l:_:ll,r:_:rr) -> Just ((l,r),(ll,rr)))      ([1..],[2..])
03:31:46 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21...
03:31:59 <FunctorSalad> come on, that is clearly prettiest
03:32:05 <Axman6> aristid: that's.... ouch :(
03:32:10 <aristid> :t unfoldr . Just
03:32:11 <lambdabot>     Couldn't match expected type `b -> Maybe (a, b)'
03:32:11 <lambdabot>            against inferred type `Maybe a1'
03:32:12 <lambdabot>     Probable cause: `Just' is applied to too many arguments
03:32:32 <aristid> :t unfoldr
03:32:33 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
03:33:13 <aristid> oO why doesn't unfoldr . Just work?
03:33:22 <aristid> i must be blind or something
03:33:34 <FunctorSalad> because Just doesn't produce a function type
03:33:57 <FunctorSalad> which is the first arg of unfoldr...
03:34:10 <jrockway> > (fst `map`) . filter snd . scanl (\(x,y) z -> (z, not y)) ((1,1), False) $ zip [1..10] [2..20]
03:34:11 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
03:34:28 <jrockway> > (fst `map`) . filter snd . scanl (\(x,y) z -> (z, not y)) (undefined, False) $ zip [1..10] [2..20]
03:34:29 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
03:34:35 <jrockway> there we go :P
03:34:47 <aristid> :t unfoldr . fmap Just
03:34:48 <lambdabot> forall b a. (b -> (a, b)) -> b -> [a]
03:34:52 <aristid> there!
03:35:28 <aristid> > let unfoldrStream = unfoldr . fmap Just in unfoldrStream  (\(l:_:ll,r:_:rr) -> ((l,r),(ll,rr)))      ([1..],[2..])
03:35:29 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21...
03:36:41 <jrockway> > do { x <- [1..10]; y <- [2..10]; guard (y == x + 1); return (x,y) }
03:36:42 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
03:37:00 <jrockway> oops, not quite
03:37:16 <FunctorSalad> > unfoldr (\(a:b:c) -> Just ((a,b),c)) [1..]
03:37:17 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21...
03:37:21 <FunctorSalad> silly me, that's much simpler
03:37:43 <jrockway> > do { x <- [1,3..10]; y <- [2,4..10]; guard (y == x + 1); return (x,y) }
03:37:43 <aristid> FunctorSalad: i was thinking that unfoldr . fmap Just would be a useful function for these cases
03:37:44 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
03:37:46 <FunctorSalad> (finite inputs are a "user error")
03:38:37 <jrockway> just generate every possible piece of data that looks like what you want, and then filter!
03:38:39 <Axman6> @unpl \a b c -> ((a,b),c)
03:38:39 <aristid> FunctorSalad: use a stream type to fix that
03:38:39 <lambdabot> \ a b c -> ((a, b), c)
03:38:41 <jrockway> (still faster than ruby)
03:38:44 <Cale> > concatMap (\xs -> case xs of [x] -> [], [x,y] -> [(x,y)]) . map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1,2,3,4,5]
03:38:45 <Axman6> @pl \a b c -> ((a,b),c)
03:38:45 <lambdabot> ((,) .) . (,)
03:38:45 <lambdabot>   Pattern syntax in expression context: [x, y] -> [(x, y)]
03:38:53 <Cale> > concatMap (\xs -> case xs of [x] -> []; [x,y] -> [(x,y)]) . map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1,2,3,4,5]
03:38:54 <lambdabot>   [(1,2),(3,4)]
03:39:15 <aristid> :t let (.:) = (.).(.) in (,) .: (,)
03:39:16 <lambdabot> forall b a b1. a -> b1 -> b -> ((a, b1), b)
03:39:21 <FunctorSalad> aristid: or actually handle the other cases, but that'd make my neat definition longer
03:40:23 <gokoon> hey guys do you know http://learnyouahaskell.com/ ?
03:40:29 <aristid> @do  concatMap (\xs -> case xs of [x] -> []; [x,y] -> [(x,y)]) . map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1,2,3,4,5]
03:40:30 <lambdabot> concatMap (\ xs -> case xs of { [x] -> []; [x, y] -> [(x, y)]}) . map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1, 2, 3, 4, 5]
03:40:30 <Axman6> yes
03:40:37 <Axman6> BONUS wrote it
03:40:41 <aristid> hmm @do doesn't know concatMap
03:42:03 <aristid> @do (=<<) (\xs -> case xs of [x] -> []; [x,y] -> [(x,y)]) . ((=<<) . (.) return)  (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1,2,3,4,5]
03:42:03 <lambdabot> (=<<) (\ xs -> case xs of { [x] -> []; [x, y] -> [(x, y)]}) . ((=<<) . (.) return) (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1, 2, 3, 4, 5]
03:42:37 <jrockway> fail
03:42:48 <jrockway> > fail "if at first you don't succeed, you fail"
03:42:49 <lambdabot>   No instance for (GHC.Show.Show (m a))
03:42:49 <lambdabot>    arising from a use of `M7238835618...
03:42:55 <aristid> jrockway: :P
03:43:04 <aristid> fail fail
03:43:21 <jrockway> > fail "whale" :: IO ()
03:43:22 <lambdabot>   <IO ()>
03:44:59 <Axman6> > fail (fail "ough")
03:45:00 <lambdabot>   No instance for (GHC.Show.Show (m a))
03:45:01 <lambdabot>    arising from a use of `M7760496812...
03:45:09 <aristid> :t fail . fail
03:45:09 <Axman6> > fail (fail "ough") :: String
03:45:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
03:45:10 <lambdabot>   ""
03:45:15 <jrockway> :t fail =<< fail
03:45:16 <lambdabot> forall b. String -> b
03:45:48 <aristid> @src (->) fail
03:45:49 <lambdabot> Source not found. My mind is going. I can feel it.
03:46:12 <Axman6> :t fail
03:46:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
03:46:48 <aRcatan> :t mfix fail
03:46:49 <lambdabot> forall (m :: * -> *). (MonadFix m) => m String
03:47:12 <aristid> > mfix fail :: [String]
03:47:12 <Axman6> > mfix fail :: String
03:47:13 <lambdabot>   []
03:47:13 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
03:47:14 <lambdabot>         against inferred type...
03:48:14 <gokoon> here is a good channel from frying my brain
03:48:18 <gokoon> for*
03:48:20 <mun_> hi
03:48:31 <Axman6> 'lo mun_ 
03:48:51 <mun_> i recall hearing somewhere that some logic can't make use of the cut-rule, does anyone know what it is?
03:50:42 <aristid> :t fix fail
03:50:43 <lambdabot> String
03:50:47 <aristid> > fix fail
03:50:48 <lambdabot>   ""
03:51:05 <aristid> > fix id
03:51:09 <lambdabot>   mueval-core: Time limit exceeded
03:53:29 <jrockway> > fix error
03:53:30 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
03:53:37 <jrockway> that made it worse
04:35:26 <greap> If you have a function defined in a where clause, are the type variables from the outer function referenced, or new type variables created?
04:38:44 <Boxo> they're referenced if you use {-# LANGUAGE ScopedTypeVariables#-}
04:40:29 <Saizan> and if you use forall to bind them in the outer signature
04:43:26 <neena> BONUS: hello
04:46:09 <aristid> preflex: seen BONUS
04:46:09 <preflex>  BONUS was last seen on #haskell 65 days, 18 hours, 52 minutes and 59 seconds ago, saying: :)
04:47:05 <neena> oh
04:47:45 <neena> well, on his haskell tutorial, it says "The functions min and max take two things that can be put in an order (like numbers!) and return the one that's greater. "
04:50:10 <nlogax> > foldl1 max [1,9,6,4,3]
04:50:11 <lambdabot>   9
04:50:29 <neena> and min?
04:50:41 <neena> doesn't do the same thing does it.
04:50:43 <dobblego> > min 3 4
04:50:44 <lambdabot>   3
04:50:49 <dobblego> > max 3 4
04:50:50 <lambdabot>   4
04:51:12 <neena> yeah, I know. I think that sentence is grammatically incorrect, isn't it?
04:51:31 <dobblego> I don't think so, why do you think so?
04:51:45 <nlogax> oh, i see what you mean
04:52:12 <aristid> > let minAndMax x y | y < x = (y, x); otherwise = (x, y) in minAndMax 3 4
04:52:13 <lambdabot>   *Exception: <interactive>:1:145-174: Non-exhaustive patterns in function mi...
04:52:23 <aristid> > let minAndMax x y | y < x = (y, x) | otherwise = (x, y) in minAndMax 3 4
04:52:24 <lambdabot>   (3,4)
04:52:33 <aristid> > let minAndMax x y | y < x = (y, x) | otherwise = (x, y) in minAndMax 4 3
04:52:34 <lambdabot>   (3,4)
05:10:21 <rrc7cz> if you have a fn returning IO [Foo], how can you life the value out of the IO m so the list can be used by map? I know in a do block, <- lifts the value and binds it to a name, but what about when you don't want to bind it explicitly, just lift the value?
05:10:50 <Twey> You don't ever lift things out of IO
05:10:58 <Twey> You push operations into it, instead
05:12:33 <ziman> > liftM (map (+1)) (Just [1,2,3])
05:12:34 <lambdabot>   Just [2,3,4]
05:12:42 <rrc7cz> Twey: so if I want to map "(+1)" over [Int], but all I have is IO [Int], how might I do that?
05:12:46 <Twey> > map succ <$> Just [1, 2, 3]
05:12:47 <lambdabot>   Just [2,3,4]
05:13:03 <ziman> ^^ (map (+1)) is being pushed into the Maybe monad; you'd do it with IO the same way
05:13:40 <Twey> rrc7cz: You lift the map into it, either using liftM/fmap/<$> (they're all the same), or else by using >>= and wrapping it back up again
05:13:53 <Twey> > Just [1, 2, 3] >>= return . map succ
05:13:54 <lambdabot>   Just [2,3,4]
05:14:18 <Twey> (m >>= return . f = liftM f m = fmap f m = f <$> m)
05:15:05 <Twey> rrc7cz: Do you know how do-notation works?
05:15:39 <rrc7cz> Twey: I understand the concept behind <- and return. The whole box metiphor
05:15:44 <rrc7cz> but certainly not more than that
05:16:03 <Twey> rrc7cz: You can't ‘lift the value’ out of an ‘IO Foo’, because an ‘IO Foo’ does not have a Foo ‘in’ it
05:16:25 <rrc7cz> it's just an action that when executed can return Foo?
05:16:26 <Twey> rrc7cz: An IO Foo is a ‘recipe’ of sorts for a series of impure actions which, if run, will yield a Foo
05:17:23 <Twey> rrc7cz: So instead of ‘taking the value out’ of the recipe, which doesn't make sense, what we do is append a new action to the recipe that says ‘… and then do <something else> with that value’
05:18:18 <Gracenotes> ooh. I like that explanation.
05:18:24 <Twey> The function that lets us do this is called >>=
05:18:58 <Twey> >>= takes two arguments: the original recipe, and a function that takes the value that will eventually be produced by the recipe and uses it to create a new recipe
05:19:29 <Twey> > Just 1 >>= \v -> return (v + 1)
05:19:30 <lambdabot>   Just 2
05:20:06 <CakeProphet> > (+1) <$> Just 1
05:20:07 <lambdabot>   Just 2
05:20:16 <rrc7cz> Twey: that makes sense. One point I'm missing, however, is that it means your "end result" is always a wrapped value, M <something>
05:20:37 <Twey> ‘return’ is the function responsible for converting a value of type Foo into a recipe that will simply return that value, IO Foo (or, in this case, Maybe Foo; the same principle applies, though since a Maybe really does have a value ‘inside’ it, it's a little less abstract)
05:20:42 <Twey> rrc7cz: Yes, it does
05:20:57 <Twey> CakeProphet: Yeah, I did that earlier — I was working back up to it :þ
05:21:26 <CakeProphet> also
05:21:33 <rrc7cz> Twey: so that's how it ties in to the implicit "global" M or sorts? In other words, typing in a "pure" 2+1 at the REPL returns 3, but that's actually wrapped in this implicit M
05:21:34 <Twey> rrc7cz: But that's okay, because your *whole program* is a wrapped value (main :: IO ())
05:21:42 <tolkad> Is there a way of compiling haskell with cross-file optimization?
05:21:47 <Twey> rrc7cz: The GHCi REPL is magic.
05:21:49 <CakeProphet> > (+) <$> Just 1 <*> Just 2
05:21:50 <lambdabot>   Just 3
05:22:02 <rrc7cz> Twey: perfect, thanks
05:22:23 <Cale> rrc7cz: GHCi infers the type of the expression, and unless it has type IO t for some t, it will try applying the print function to it.
05:22:30 <Cale> :t print
05:22:30 <lambdabot> forall a. (Show a) => a -> IO ()
05:22:41 <Cale> (to turn it into an IO action for displaying the value)
05:22:49 <Twey> > Just (+) <*> Just 1 <*> Just 2
05:22:50 <lambdabot>   Just 3
05:22:53 <Cale> It then executes the resulting action, in either case.
05:23:49 <Cale> Recent versions of GHCi will also bind the result of an IO action to print in the case that the result doesn't have type ().
05:24:08 <Cale> (which I find more obnoxious than helpful, but there you go.)
05:24:26 <CakeProphet> it's certain;y useful in debugging.
05:24:27 <Twey> Cale: To print?
05:24:53 <Cale> Twey: Yeah, so for instance...
05:24:56 <Cale> ghci> getLine
05:24:57 <Cale> hello
05:24:57 <Cale> "hello"
05:25:00 <jystic> Hi all, I'm trying to define a data-type which represents a type system similar to C. Lets say for simplicity that a value can be a float, int, struct (which is a heterogeneous list of name/value pairs), or an array (which is a homogeneous list of values). Can anyone help here? I think I need to use a GADT but I'm not sure.
05:25:04 <rrc7cz> so if the entire program is wrapped in main :: IO (), then the idea of the explicit do vs. purity is to create (large as possible) islands of purity with clear boundaries?
05:25:14 <Cale> We have getLine behaving like getLine >>= print
05:25:29 <Twey> Ahh, right.
05:25:50 <Twey> I thought you meant it shadowed the name ‘print’ with a binding to the result of the action.
05:25:54 <aristid> it seems like haskell encourages making complex solutions because it's not that difficult, and i'm not sure how to deal with that
05:25:55 <Twey> Which would be weird.
05:25:59 <CakeProphet> rrc7cz:  you could think of that way.
05:26:18 <rrc7cz> okay
05:26:20 <CakeProphet> *it
05:26:20 <Cale> rrc7cz: Yes, that's a reasonable way to look at it.
05:26:25 <Twey> rrc7cz: do-notation isn't necessarily impure in any way, though.
05:26:28 <tolkad> does haskell automatically optimize cross-module?
05:26:33 <aristid> should i try to avoid creating complex solutions? should i create them and then later try to find a way to make it simpler?
05:26:48 <Twey> rrc7cz: do-notation isn't specific to the IO monad: it can also be used for pure code, like in the Maybe or [] monads.
05:26:58 <dino-> Maybe also worth mentioning here that most monadic things aren't impure, it's just IO
05:27:00 <CakeProphet> aristid:  you should find simple meta-solutions to your complex complexity question.
05:27:03 <CakeProphet> :)
05:27:11 <Cale> rrc7cz: You can use do-notation to describe values in other monads than IO, which don't necessarily have anything to do with side effects or statefulness of any kind.
05:27:11 <rrc7cz> Twey: why might somebody want to do that? to create components?
05:27:30 <aristid> CakeProphet: how meta of you.
05:27:32 <rrc7cz> Twey: nevermind, wasn't thinking
05:27:33 <Twey> rrc7cz: Use pure monads in general, or use do-notation with them?
05:27:35 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (10*x + y)
05:27:36 <lambdabot>   [14,15,24,25,34,35]
05:27:38 <Twey> Okay.  ☺
05:27:43 <Cale> ^^ nothing impure going on there
05:28:23 <tolkad> > do {1; 2; 3; 4}
05:28:24 <lambdabot>   No instances for (GHC.Num.Num (m a),
05:28:24 <lambdabot>                    GHC.Num.Num (m a1),...
05:28:29 <aristid> why do people keep saying that monads are impure?!
05:28:46 <aristid> :t do { 1 ; 2 ; 3 ; 4 }
05:28:47 <lambdabot> forall (m :: * -> *) a b a1 a2. (Num (m a), Monad m, Num (m a1), Num (m a2), Num (m b)) => m b
05:28:54 <tolkad> > do {[1]; [2]; [3]; [4]}
05:28:55 <CakeProphet> aristid:  probably because they're still learning.
05:28:55 <lambdabot>   [4]
05:29:02 <dino-> aristid: I think because they see it first and most prominently through IO when learning Haskell.
05:29:07 <Cale> > let dict = [(1,2),(2,4),(3,5),(4,1),(5,4)] in do x <- lookup 1 dict; y <- lookup x dict; return y
05:29:08 <lambdabot>   Just 4
05:29:10 <rrc7cz> aristid: I think it's because the first exposure in a lot of the text/tutorials/etc is via the IO monad
05:29:11 <tolkad> what does the list monad do?
05:29:21 <tolkad> > do {[1]; [2]; []; [4]}
05:29:22 <lambdabot>   []
05:29:23 <CakeProphet> tolkad:  concatMap
05:29:23 <Cale> > let dict = [(1,2),(2,4),(3,5),(4,1),(5,4)] in do x <- lookup 1 dict; y <- lookup x dict; z <- lookup y dict; return (x,y,z)
05:29:24 <lambdabot>   Just (2,4,1)
05:29:27 <CakeProphet> @src concatMap
05:29:27 <lambdabot> concatMap f = foldr ((++) . f) []
05:29:28 <aristid> dino-, rrc7cz: yeah, sounds plausible
05:29:29 <tolkad> oh, fails on an empty list
05:29:56 <tolkad> does haskell automatically optimize cross-module?
05:30:01 <aristid> tolkad: the list monad is defined by m >>= k = concatMap k m and return x = [x]
05:30:30 <rrc7cz> aristid: the funny thing is I actually implemented the identity, sequence, etc. monads from some tutorials (in Clojure though) but I didn't touch it for a while. Coming back to it now I seem to have forgotten everything
05:31:04 <rrc7cz> aristid: I should know better, but without using it, I drop the concepts rather easily
05:31:26 <aristid> rrc7cz: take ghci and your favorite text editor, and play with it :)
05:31:48 <aristid> when learning haskell, always have ghci running
05:31:52 <dino-> > foldr mplus Nothing [Nothing, Just 1, Just 2]
05:31:53 <lambdabot>   Just 1
05:32:07 <aristid> :t foldr mplus Nothing
05:32:08 <lambdabot> forall a. [Maybe a] -> Maybe a
05:32:15 <aristid> :t foldr mplus mzero
05:32:16 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
05:32:27 <aristid> :t msum
05:32:28 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
05:32:30 <rrc7cz> aristid: Haskell forces me to do that, which is great :-) I don't find monads necessary in my other work though, so if I leave haskell for a while I lose ground
05:32:35 <dino-> I think of it as "keep executing these actions until one doesn't fail"
05:33:01 <aristid> rrc7cz: you don't need monads in haskell either, technically (except for IO, which you obviously have to use for main)
05:33:35 <aristid> dino-: i think of it as "an Applicative Functor with join"
05:33:36 <dino-> ya, msum
05:34:02 <aristid> "Functor with return and join" would do too
05:34:07 <aristid> or "fmap, return and join"
05:34:19 <CakeProphet> The monads I "use" the most of in my Haskell programming are IO, STM, State (and its transformer), Reader, and Writer.
05:34:34 <Twey> I don't use State much these days
05:34:37 <aristid> CakeProphet: Reader? why not use (e ->) instead?
05:34:39 <dino-> CakeProphet: ErrorT too for me
05:34:47 <Twey> More trouble than it's worth
05:35:01 <aristid> Twey: what do you prefer over it?
05:35:06 <CakeProphet> Twey:  I mostly agree, though fclabels fixes a lot of the boilerplate.
05:35:09 <Twey> Manual passing, in most cases
05:35:17 <Twey> Ooh, I hadn't thought of State + fclabels
05:35:25 <Twey> That sounds like it might be worth a try.  Thanks.
05:35:56 <CakeProphet> Twey: it is the reason I use fclabels, actually.
05:36:33 <aristid> > sequence [f, g] :: Expr
05:36:33 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
05:36:33 <lambdabot>         against inferred ...
05:36:41 <aristid> > sequence [f, g] x :: Expr
05:36:42 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
05:36:42 <lambdabot>         against inferred ...
05:36:48 <aristid> :t sequence [f, g]
05:36:49 <lambdabot> forall (m :: * -> *) a. (SimpleReflect.FromExpr (m a), Monad m) => m [a]
05:37:11 <aristid> :t sequence [f :: Expr -> Expr, g]
05:37:12 <lambdabot> Expr -> [Expr]
05:37:17 <aristid> :t sequence [f :: Expr -> Expr, g] x
05:37:18 <lambdabot> [Expr]
05:37:20 <aristid> > sequence [f :: Expr -> Expr, g] x
05:37:21 <lambdabot>   [f x,g x]
05:39:53 <rrc7cz> in which module is <$> in? it isn't in the documentation for the Monad module
05:40:14 <Botje> Control.Applicative?
05:40:17 <Twey> Control.Applicative, yes
05:40:19 <Botje> @hoogle (<$>)
05:40:19 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
05:40:21 <rrc7cz> thank you
05:40:33 <Twey> But it's the same as ‘fmap’, which is in the Prelude, and liftM, which is in Control.Monad
05:40:41 <Twey> (for monads, anyway)
05:40:57 <CakeProphet> @src liftM
05:40:57 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:42:59 <jystic> hi all, can anyone help me to define a data type?
05:43:05 <aristid> @. undo src liftM
05:43:05 <lambdabot> ()
05:43:11 <aristid> uh, what?
05:43:20 <aristid> @undo liftM f m1 = do { x1 <- m1; return (f x1) }
05:43:21 <lambdabot> liftM f m1 = m1 >>= \ x1 -> return (f x1)
05:43:54 <Twey> liftM f m = m >>= return . f
05:43:59 <Twey> liftM = (=<<) . (return .)
05:44:05 <CakeProphet> @pl liftM f m1 = m1 >>= \ x1 -> return (f x1)
05:44:05 <lambdabot> liftM = fmap
05:44:11 * Twey chuckles.
05:44:15 <Twey> It's too smart for us
05:44:23 <CakeProphet> ha
05:45:31 <tafryn> When is it appropriate to use an MVar?
05:45:32 <bobbytek> do haskell programmers really have sex in a monad?
05:45:36 <bobbytek> that just seems odd
05:46:02 <Twey> tafryn: When you're communicating between threads and don't need STM?
05:46:20 <CakeProphet> tafryn:  STM or Chan or any higher-level concurrency abstraction
05:46:35 <aristid> Twey: i think liftM f m = m >>= return . f is the most readable of the bunch
05:47:02 <Twey> I like (=<<) . (return .)
05:47:11 <Cale> jystic: You wanted a datatype to represent C datatypes?
05:47:23 <jystic> Cale: yeah
05:47:24 <CakeProphet> tafryn:  but you should probably use STM, just because it's awesome. ;)  If you really don't want to, then MVar and friends is just fine.
05:47:38 <jystic> Cale: it's a similar idea anyhow
05:48:24 <Cale> jystic: Just the type, or values?
05:48:33 <tafryn> I feel like I'm forcing all my code into an MVar-shaped box when there is probably something else I should be using.
05:48:43 <tafryn> Possibly the state monad?
05:49:02 <Twey> tafryn: Are you communicating between threads?
05:49:16 <Twey> Passing data between them?
05:49:21 <jystic> Cale: the values, so something like the JSValue type (http://hackage.haskell.org/packages/archive/json/0.4.4/doc/html/Text-JSON-Types.html)
05:49:49 <tafryn> I one case, yes, but in another I just need to know the last time a function was called.
05:51:00 <benmachine> MVar has no advantages over IORef when only a single thread has access to it, I think
05:51:01 <Cale> tafryn: There's also IORef.
05:51:11 <benmachine> IORef is probably more efficient in that case
05:51:13 <jystic> Cale: it's just that arrays are homogeneous, so they should one contain values of a single type, the more I think about it the more I think it's not possible though
05:52:03 <mm_freak_> it's wrong to compare IORef to MVar
05:52:09 <Cale> jystic: It's probably possible, but it could be more awkward than just enforcing the constraint in some other way.
05:52:09 <mm_freak_> they are different concepts
05:52:33 <CakeProphet> mm_freak_:  I don' think they're being compared.
05:52:41 <benmachine> mm_freak_: they're similar enough that you could replicate the IORef API with MVars
05:53:16 <benmachine> it'd just be silly, because you wouldn't be using the interesting things about MVars
05:53:28 <mm_freak_> benmachine: you can also replicate TMVar (Chan a) using IORefs
05:53:49 <tafryn> benmachine: What are the interesting things about MVars?
05:53:56 <jystic> Cale: yeah i might just have to be happy with dynamically typed arrays :) i was just trying to see how far i could push the type system
05:54:12 <mm_freak_> anyway
05:54:20 <benmachine> tafryn: they can be empty or full, and when you try to take from an empty var or put in a full var your thread is suspended until you can do that
05:54:29 <mm_freak_> as long as there is no specific need for destructive update, i'd probably use a state monad
05:54:44 <tafryn> benmachine: atomicModifyIORef doesn't do something like that?
05:54:51 <Cale> jystic: You could use a GADT parameter to reflect at least which of the constructors of your type was used to build the values.
05:55:10 <benmachine> tafryn: an IORef always had a value in it, and all actions with IORefs complete immediately
05:55:12 <mm_freak_> tafryn: if an MVar is empty, then reading blocks, not because another thread is using it, but because there is no value to pick
05:55:15 <Cale> (or perhaps more in the case of your heterogeneous structures, if you want)
05:55:31 <tafryn> benmachine: Ah.
05:55:33 <mm_freak_> tafryn: similarly if the MVar already contains a value, then putMVar blocks, until it has been taken by another thread
05:55:47 <Cale> jystic: But then you end up using existentials when you want to treat all the types together.
05:55:52 <benmachine> atomicModifyIORef allows you to write thread-safe code with IORefs, but MVars allow you to do it more easily in most cases
05:55:56 <Cale> (which might be what you want anyway)
05:56:00 <jystic> could you explain that a bit more? my dynamically typed system looks like this:
05:56:33 <jystic> type MValue = MArray [MValue] | MStruct [(String, MValue)] | MFloat32 Float | MInt32 Int32
05:57:20 <Cale> Okay, one sec :)
05:57:28 <temoto> I'm parsing C-syntax config with statements and blocks of statements. data Decl = Decl Ident [Arg] | Block Ident [Arg] [Decl]   i wonder if i could write some instance so  fmap or something like that would traverse all declarations with   Decl -> [Hint]  function.
05:57:30 <Cale> (Of course you mean data)
05:57:43 <jystic> Cale: thanks!
05:57:56 <jystic> Cale: yeah sorry, data :)
05:58:34 <dankna> temoto: read the Scrap Your Boilerplate paper, you may like the approach it suggests
05:59:37 <temoto> dankna, the one with tremendous font, because author closed wrong h2 tag?
05:59:50 <Botje> temoto: check uniplate as well
05:59:55 <Botje> it's simpler, imo
05:59:59 <dankna> temoto: let me find it, haha
06:00:37 <dankna> http://portal.acm.org/citation.cfm?doid=604174.604179
06:01:36 <dankna> (you may be able to find a copy that doesn't require an ACM subscription by googling around, I don't know.  not that I would ever encourage that, haha.)
06:02:03 <temoto> dankna, i found this http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/
06:02:51 <dankna> ah yes, that's the same paper.  I'm surprised simonpj couldn't handle html :) anyway the third one listed there is the one I would start with
06:04:53 * hackagebot gtkimageview 0.11.1 - Binding to the GtkImageView library.  http://hackage.haskell.org/package/gtkimageview-0.11.1 (AndyStewart)
06:07:32 <Cale> jystic: http://codepad.org/cEFCK4JZ
06:07:59 <Cale> ghci> MInt 5
06:07:59 <Cale> MInt 5
06:07:59 <Cale> ghci> MArray [MInt 5, MInt 7]
06:07:59 <Cale> MArray [MInt 5,MInt 7]
06:07:59 <Cale> ghci> MArray [MInt 5, MInt 7, MArray [MInt 8]]
06:08:00 <Cale> <interactive>:1:24:
06:08:02 <Cale>     Couldn't match expected type `Int' against inferred type `ArrayT'
06:08:47 <Cale> This is still kind of weak. We could do even better.
06:09:10 <Cale> But it prevents the very crudest sorts of type errors, where the constructors don't match.
06:09:30 <jystic> cool! thanks for that, this is more or less what i was hoping for
06:09:46 <dankna> jystic: great :)
06:09:49 <dankna> wait
06:09:51 <dankna> you're not temoto
06:09:57 <jystic> haha
06:09:58 <dankna> well, good anyway but I had nothing to do with it, haha
06:10:30 <dankna> always happy to accept praise that isn't directed at me, apparently
06:12:04 <temoto> dankna, Botje  thanks.
06:12:36 <solidsnack> FunctorSalad: Hi.
06:19:05 <danportin> I'm working through Wadler's paper on monads. His version of the Maybe monad is the Exception monad, defined by 'data M a = Raise String | Return a'. The Functor instance for Maybe is clear, but it seems like the Functor instance for 'Exception' is less straightforward. Following the types, wouldn't 'fmap f (Raise s)' require that 'f' be applicable to 's', because of fmap's type signature, in 
06:19:05 <danportin> addition to the definition of fmap for e.g. 'Return a', in which 'a' is applied to 'f'? Or am I overlooking something?
06:19:47 <benmachine> danportin: you're overlooking something :)
06:20:35 <benmachine> danportin: what's the type of Raise "foo"?
06:21:28 <danportin> Raise "foo" would have type M String, since Raise :: String -> M String, I think.
06:21:42 <benmachine> nope
06:21:56 <benmachine> Raise :: String -> M a
06:22:05 <benmachine> consider Nothing :: Maybe a
06:22:12 <benmachine> Raise is the same, only it carries a String with it
06:22:50 <benmachine> in the data declaration, there's no requirement for the 'a' that parametrises 'M' to match the type of the parameter given to Raise
06:25:34 * edwardk_ waves hello.
06:27:24 <danportin> I think I understand, but I'm not sure why, although Raise "string" :: M a (I get that now), 'fmap f (Raise s)' would have type 'M b'.
06:29:22 <danportin> I think I'm not understanding how the return type becomes 'M b.' Since a function like 'f :: a -> b, f x = x' obviously won't type check.
06:29:33 * Cale hangs up http://cale.yi.org/share/Painting.jpeg in his room. :)
06:30:30 <Ferdirand> "f (Raise s) = Raise s" is different from "f x = x"
06:33:21 <benmachine> danportin: you're taking it out of the Raise constructor and putting it back in again, that's important
06:33:31 <Philonous> danportin: Raise <something> has type M a for _any_ a, even b
06:35:48 <danportin> benmachine: Okay, that makes sense. I am /re-applying/ 's' to 'Raise', not just 'copying it over.' That's why the 'Raise' definition type checks, but e.g., 'f :: (a -> b) -> a -> b, f g x = x' wouldn't. 
06:36:26 <benmachine> danportin: yeah
06:38:09 <Philonous> danportin: Yes, that's why "f x@(Raise s) = x" doesn't work
06:38:21 <ivanm> hooray!!!
06:38:42 <ivanm> rather than doing what I was trying to do and try to convert kind * to kind * -> *, I can just do it in reverse! \o/
06:39:27 <danportin> Thanks, benmachine and philonous :)
06:40:00 <benmachine> np :)
06:44:01 <ivanm> preflex: seen Heffalump 
06:44:02 <preflex>  Heffalump was last seen on #haskell 8 hours, 38 minutes and 50 seconds ago, saying: but how is it different from data Quaterion a b c d = Q a b c d ?
06:45:20 <EvanR-wo1k> needs more Fractional a => Quaternion a = Q a a a a
06:45:41 <EvanR-wo1k> but i guess dont normall restrict in the data declaration
06:45:44 <ivanm> @ask Heffalump with Suitable, is there any way of having something like withResCOnstraints, etc. that doesn't require the Constraints types to be exported/visible?
06:45:44 <lambdabot> Consider it noted.
06:46:01 <ivanm> @ask Heffalump (so that different classes can be split up into different modules)
06:46:02 <lambdabot> Consider it noted.
06:50:14 <Martty> jesus.. my left ctrl and windows keys are swapped between my desk and laptop computer
06:50:28 <Martty> DAMN IT ALL TO HELL
06:51:18 <koala_man> so remap them?
06:53:35 <Martty> i wish keyboards just came unlabeled
06:53:39 <lantti> Laptop keyboards are mostly bizarre anyway...
06:53:58 <Martty> well it's a 1700 pressario anyways :D
06:54:46 <Martty> mf gives me static discharges and heats like a fridge
07:07:10 * fryguybob chooses his laptops base on keyboard layout...
07:08:02 * fryguybob which apparently leads to mistyping "based"...
07:08:14 <ivanm> lol
07:25:04 * shapr hugs dcoutts
07:25:12 <shapr> dcoutts++ # for great goodness in many places
07:25:34 <ivanm> what now in particular?
07:25:56 <shapr> Just thinking about ByteString, Gtk2hs, and lots of other goodies I use.
07:26:03 <ivanm> also, methinks you've been coding in bash or a "scripting language" for too long... # isn't a Haskell comment indicator! ;p
07:26:18 <shapr> Ah crap, I was just writing a bash script :-(
07:26:29 * shapr is embarassed and cries
07:26:38 <ivanm> there there
07:26:47 * ivanm awkardly pats shapr on the back
07:26:53 <aRcatan> you can rewrite it in Haskell!
07:27:19 <ivanm> yeah, see dons' talk on how to do it! ;-)
07:27:40 <aRcatan> those dons' slides made me want to rewrite all my shell scripts in Haskell
07:27:48 <aRcatan> then I noticed that I don't use any, anymore
07:27:50 <writer> write in bahs instead of bash :p
07:28:05 <writer> ivanm, aRcatan: link ?
07:28:08 <osfameron> hehe @ "bahs"
07:28:20 <ivanm> I had already done so to an extent... http://projects.haskell.org/graphviz/BuildWebsite.hs
07:28:35 <aRcatan> writer, slides are here, at least : http://donsbot.wordpress.com/2010/08/17/practical-haskell/
07:28:47 <ivanm> dammit, aRcatan beat me to it
07:30:25 <ivanm> I really need to go convert that script into a proper library using pandoc in library mode...
07:30:34 <ivanm> and then integrate darcs into it as well, using filestore if nothing else
07:30:41 <dcoutts> shapr: :-)
07:30:41 <writer> thanks
07:32:33 <romanandreg> what would be the best way to represent a board map game?
07:32:46 <romanandreg> I'm doing it right now with a [[String]] however
07:32:46 <ivanm> depends on the type of board
07:32:50 <ivanm> ugh
07:32:55 <romanandreg> I'm not that sure it is the best way to represent a map
07:33:00 <romanandreg> ivanm: sokoban
07:33:01 <ivanm> better off using an array or a Map with (Int,Int) as the index
07:33:19 <ivanm> huh
07:33:25 <ivanm> probably a Map (Int, Int) or something
07:33:38 <ivanm> since it'd probably be a rather sparse "array"
07:33:54 <romanandreg> uhmm... is there a way to actually not using indexes to access adjacent nodes
07:34:02 <romanandreg> I don't know, like a recursive structure wouldn't be nice?
07:34:15 <ivanm> well, do some wrappers
07:34:24 <ivanm> there are a few other structures that do spatial stuff on Hackage
07:34:25 <roconnor> romanandreg: we really need to know more about what your board is to give it a data type.
07:34:26 <Jafet> How is a sokoban board recursive?
07:34:27 <romanandreg> uhmm yeah I could
07:34:32 <ivanm> but last I tried it was easier to just use indexes
07:34:37 <romanandreg> I don't know
07:34:49 <romanandreg> ivanm: Something like
07:34:53 <quicksilver> well you can use indices behind the scenes
07:35:00 <ivanm> Jafet: I think he just means that you can just go "what is to the left of this spot"
07:35:06 <quicksilver> and still support convenient functions for 'get neighbors of' and 'go left of'
07:35:13 <ivanm> quicksilver: yeah, and then do a map over the indices or something
07:35:28 <ivanm> the beauty of newtypes or wrapper types! \o/
07:35:42 <romanandreg> data CellType = Rock | Wall | Blank; data Board = Cell CellType Board Board Board Board 
07:35:46 <Jafet> That depends on what you want to do with sokoban, too.
07:36:07 <Jafet> I used bitmaps for a small games bruteforcer
07:36:26 <ivanm> romanandreg: of course, a good implementation is one that will hide all details of which actual data structure is being used to store the board information
07:36:37 <romanandreg> ivanm: good point
07:36:40 <ivanm> so you can then go and replace it down the track without touching the rest of your code
07:36:53 <romanandreg> yeah... like probably have that a monad that holds the current position
07:36:55 <romanandreg> and just move around
07:37:06 <ivanm> a zipper would probably be nicer than a monad
07:37:08 <romanandreg> state mondad*
07:37:15 <ivanm> monads are not the be all and end all of Haskell! ;-)
07:37:21 <romanandreg> ivanm: zipper eh?... need to digest that theory
07:37:42 <romanandreg> ivanm: I know, that's why I come here to hear recommendations like that one
07:37:57 <roconnor> You guys know there is a sokoban implementation in Coq.  It's called coqoban.
07:41:24 <romanandreg> roconnor: there is actually a lot of implementations of sokoban
07:41:28 <romanandreg> known and unknown
07:41:33 <romanandreg> it is a common problem for AI
07:42:15 <roconnor> romanandreg: The coq version is a game for humans to play, not for Coq to solve.
07:42:23 <roconnor> at least as it stands.
07:42:52 <roconnor> You play the sokoban level the same way you would prove an mathematical theorem.
07:43:15 <roconnor> It includes new coq tactics for moving west, east, north, or south.
07:43:47 <aristid> is there a recommended hackage package for non-empty lists?
07:43:55 <roconnor> when you reach your goal you write QED. to finish the level.
07:44:42 <roconnor> but if you like, you could write your own tactics in Coq to solve, or help solve the levels.
07:46:48 <copumpkin> RayNbow: wow, you must drive one of these: http://www.quarryed.co.uk/digthisbiggesttruck.html
07:55:50 <FunctorSalad> solidsnack: hi! iirc I had just been trying to ask something about the difference between your json packages, but I think there isn't any (between JSONb and json-b, except the former is newer)
07:57:47 <zygoloid> copumpkin: maybe one of these: http://incontiguousbrick.files.wordpress.com/2007/05/bagger288.jpg
07:59:26 <dom96> hello, i'm trying to profile my app, and the profiling report tells me that it takes 0.0 seconds to execute. Which is false... 
07:59:39 <dom96> why is that?
08:02:04 <lowSodium> Is it possible to get links to the source files in the documentation like on Hoogle locally on a linux system like Ubuntu?
08:02:10 <Cale> dom96: How are you compiling and running it?
08:02:18 <copumpkin> zygoloid: don't be silly, RayNbow's vehicle only consume 5.2 liters / km
08:02:32 <Cale> dom96: Compile with -prof -auto-all and run the program with +RTS -p
08:03:20 <zygoloid> copumpkin: if it's a coal-powered strip miner, its fuel consumption could be negative :)
08:03:36 <copumpkin> zygoloid: :P
08:03:36 <dom96> Cale: that's what i'm doing
08:03:44 <FunctorSalad> lowSodium: cabal haddock --hyperlink-source
08:03:53 <lowSodium> thanks!
08:04:23 <FunctorSalad> you'll have to actually change to the unpacked source dir for that though
08:04:58 <FunctorSalad> cabal unpack cat; cd cat-*; cabal configure; cabal haddock --hyperlink-source
08:04:59 <FunctorSalad> or so
08:06:30 <dom96> This is the profile i get, http://gist.github.com/540508
08:06:38 <lowSodium> this is tough
08:09:07 <FunctorSalad> 'cat' is a metasyntactic cat here :)
08:09:13 <FunctorSalad> not the cat program
08:12:59 <dataangel> Anyone know how to build GHC on Solaris if you don't have a version of GHC to start? The build guide for Solaris assumes you have one. I looked at the porting guide, but it requires you to know what your platform is called (solaris? solaris/x86? i don't know what format it wants) and wants me to run 'perl bootstrap' except there's no bootstrap file in the source distribution :p
08:13:42 <RichardBarrell> dataangel: are there no pre-built executables for Solaris?
08:13:59 <dataangel> RichardBarrell: None are listed on the 6.12.3 download page
08:14:14 <dataangel> RichardBarrel: Only FreeBSD/MacOSX/Windows/Linux
08:14:17 <RichardBarrell> Ah.
08:14:34 <zygoloid> the 'full' bootstrap requires building about 8 versions of GHC :( don't do that, start with a binary distro :)
08:14:35 <RichardBarrell> If you can get an *old* version of GHC running, you can use that to bootstrap newer versions of GHC.
08:14:58 <dataangel> christ, doesn't GHC target C-- as an intermediate language? why can't you bootstrap off of that?
08:15:24 <dataangel> I went through this process about a year ago and don't recall building 8 versions...
08:15:48 <RichardBarrell> Most of those multiple builds are automated.
08:16:05 <RichardBarrell> So it just looks like a very *slow* build.
08:16:22 <dataangel> 6.12.1 seems to have a binary
08:16:29 <dataangel> for opensolaris though, I'm not sure it'll wokr
08:16:44 <RichardBarrell> It's worth a go.
08:17:54 <RichardBarrell> If you can trick that into running then you can use it to build a new GHC for your system.
08:20:58 <dataangel> unfortunately the pkg admin tools aren't on my bod
08:20:59 <dataangel> x
08:21:16 <dataangel> i would rather go the path of the slow build i guess
08:21:38 <dataangel> but what platform do I tell it and how do I get the bootstrap file?
08:51:50 <arbitrarylogic> what's the best way to get the base-256 representation of an Integer?
08:55:40 <Cale> arbitrarylogic: Maybe something like  map (`mod` 256) . takeWhile (/= 0) . iterate (`div` 256)
08:56:56 <Cale> arbitrarylogic: You could also use  unfoldr (\n -> if n == 0 then Nothing else let (u,v) = divMod n 256 in Just (v,u))
08:57:12 <zygoloid> > map fromEnum $ showIntAtBase 256 toEnum 0xff2845012409fe ""
08:57:13 <lambdabot>   [255,40,69,1,36,9,254]
08:57:18 <zygoloid> arbitrarylogic: ^^ that's how i'd do it, probably
08:57:37 <ClaudiusMaximus> perhaps there is an instance Bits Integer that might be more efficient for base-2^n
08:58:56 <azaq23> Am I right that unsafeInterleaveIO = return . unsafePerformIO? Why doesn't main = let foo = unsafeInterleaveIO . putStrLn "test" in putStrLn "normal" >> foo work? Works neither with standard unsafeInterleaveIO nor the self defined one for me (only display "normal")
08:59:27 <arbitrarylogic> Cale: I've been doing something with unfoldr, but it's quadratic in the bit length of the integer
08:59:43 <gwern> man. hard to believe 3.8G of emails can compress down to 678M
08:59:45 <gwern> that's 7zip for you
08:59:48 <zygoloid> arbitrarylogic: Data.Binary.encode :: Integer -> ByteString looks reasonable.
09:00:00 <Cale> azaq23: The definition of unsafeInterleaveIO is that it turns any IO action into one which does nothing, but returns a value which is magical in such a way that if evaluated, causes the original IO action to happen.
09:00:09 <Cale> (and evaluates to the result of that action)
09:00:15 <zygoloid> but it relies on your knowing implementation details of Integer's serialization
09:01:21 <Cale> gwern: It doesn't seem unreasonable given that they'd mostly all be text in one language.
09:01:22 <arbitrarylogic> zygoloid: interesting. I wasn't aware of Data.Binary.encode. let me try it out
09:01:58 <ski> azaq23 : `unsafeInterleaveIO . putStrLn "test"' is a type error .. maybe you meant to do `unsafeInterleaveIO (putStrLn "test")' ?
09:02:09 <zygoloid> arbitrarylogic: what do you want to do with this representation?
09:02:58 <Cale> English text has about 1 to 1.5 bits of information per letter.
09:03:06 <gwern> > 0.678 / 3.8
09:03:07 <lambdabot>   0.17842105263157898
09:03:07 <Cale> > 3.8 * (1.5/8)
09:03:08 <lambdabot>   0.7124999999999999
09:03:25 <gwern> Cale: well, maybe to you that doesn't seem too bad
09:03:27 <Cale> (assuming letters are 8 bit encoded)
09:03:49 <gwern> Cale: fwiw, the best estimations of english entropy I've seen are more like .9 bits
09:03:54 <zygoloid> arbitrarylogic: the showIntAtBase method seems to perform well
09:04:03 <Cale> Yeah, there are lower estimates
09:04:19 <Cale> But we want to overestimate here, I think :)
09:04:20 <azaq23> ski: yes, forgot the $ Cale: Shouldn't the use of >> cause it to be evaluated then?
09:04:31 <Cale> azaq23: Nope.
09:04:49 <ski> that's the point of `unsafeInterleaveIO'
09:05:02 <Cale> azaq23: >> is lazy in both parameters for IO
09:05:16 <arbitrarylogic> zygoloid: hold on, I'm still trying Data.Binary.encode
09:05:21 <Cale> > (undefined >> undefined :: IO ()) `seq` 0
09:05:22 <lambdabot>   0
09:05:43 <Cale> > (undefined :: IO ()) `seq` 0
09:05:44 <lambdabot>   *Exception: Prelude.undefined
09:06:22 <Cale> So the mere evaluation of x >> y doesn't force the evaluation of either parameter, or their results.
09:07:27 <Cale> In this case, you'd have to evaluate the result of the unsafeInterleaveIO before it would cause anything to be printed, and nothing in that code ensures that this will happen.
09:07:51 <Cale> (It's the () that you get back from that action which needs to be pattern matched on)
09:07:57 <ski> azaq23 : but try e.g. `putStrLn "normal" >> foo >>= print'
09:08:24 <ski> or `putStrLn "normal" >> foo >>= \() -> return "foo"' ..
09:10:04 <Cale> gwern: So if the entropy were 0.9 bits per character, then 7zip would have done a fairly poor job:
09:10:10 <Cale> > 3.8 * (0.9/8)
09:10:11 <lambdabot>   0.4275
09:10:26 <Cale> Should have compressed to 427 MB :)
09:11:16 <azaq23> ski, Cale: I see, thanks
09:11:31 <itsmonktastic> @kind ((->) Int)
09:11:32 <lambdabot> ? -> *
09:12:11 <itsmonktastic> What's with that '?' ? Can you really give ((->) Int) something with kind other than * ?
09:12:37 <dolio> ? is the union of ?? and (#)
09:12:40 <zygoloid> itsmonktastic: yep.
09:12:43 <dolio> ?? is the union of * and #.
09:12:43 <lambdabot>  is the union of * and #.
09:12:45 <Cale> Yeah, ? and ?? allow for various sorts of unboxed kinds
09:12:56 <itsmonktastic> mm I'm looking at a page which says that, but I have no idea how to
09:12:59 <zygoloid> @kind (->)
09:13:00 <lambdabot> ?? -> ? -> *
09:13:04 <itsmonktastic> ooh
09:13:18 <Cale> @kind (->) Int#
09:13:19 <lambdabot> Not in scope: type constructor or class `Int#'
09:13:23 <Cale> ah, :P
09:14:07 <ski> @kind GHC.Base.Int# -> (# GHC.Base.Int# , Int , (# Bool #) #)
09:14:08 <lambdabot> *
09:14:20 <ski> @kind (# GHC.Base.Int# , Int , (# Bool #) #) -> GHC.Base.Int#
09:14:21 <lambdabot>     Kind mis-match
09:14:22 <lambdabot>     Expected kind `??',
09:14:22 <lambdabot>     but `(# GHC.Prim.Int#, Int, (# Bool #) #)' has kind `(#)'
09:14:37 <itsmonktastic> Makes sense though now that I think about it, thanks. Just haven't dealt with unboxed types really
09:15:41 <ski> @kind (# #)
09:15:42 <lambdabot> ? -> (#)
09:15:43 <ski> @kind (# , #)
09:15:44 <lambdabot> ? -> ? -> (#)
09:16:10 <EvanR-work> how do you actually use kinds to do anything useful
09:16:46 <ski> @kind StateT
09:16:47 <lambdabot> * -> (* -> *) -> * -> *
09:17:01 <dolio> There's actually an unboxed single?
09:17:16 * ski often uses kind signatures, when doing GADTs
09:17:34 <itsmonktastic> *shrug*, it makes sense to me to be able to have the ability to denote "type" and "type constructor" as different things, for example
09:17:36 <kmc> EvanR-work, that's an odd question
09:17:40 <ski> dolio : but not an unboxed zero tuple, afaict
09:17:43 <zygoloid> itsmonktastic: http://paste2.org/p/957584
09:18:02 <itsmonktastic> zygoloid: Awesome, ty :D
09:18:03 <kmc> what you do with them is know whether your type-level applications are valid
09:18:19 <EvanR-work> ah type level applications
09:18:28 * ski thinks `Either',`Int' are type constructors, and `Maybe Int',`Either Int' are types
09:18:46 <kmc> ski, is Int also a type then? or is this a syntactic category?
09:18:56 <EvanR-work> Int is a type constructor?
09:19:09 <kmc> type ::= tycon | type type
09:19:09 <itsmonktastic> s/Int/Maybe/
09:19:12 <dolio> ski: I'm not sure how different that'd be than () anyway.
09:19:18 <itsmonktastic> at a guess :p
09:19:23 <Cale> EvanR-work: yes
09:19:29 <EvanR-work> ah
09:19:31 <kmc> EvanR-work, you could call it a nullary ty-con
09:19:35 <itsmonktastic> @kind Int
09:19:36 <lambdabot> *
09:19:37 <Cale> EvanR-work: Well, it's a 0-ary type constructor
09:20:10 <EvanR-work> so how do you do actually useful type level applications ;)
09:20:16 <kmc> Maybe Int
09:20:17 <Cale> Maybe Int
09:20:20 <Cale> heh
09:20:20 <kmc> is a type level application
09:20:32 <Cale> :k Maybe
09:20:32 <lambdabot> * -> *
09:20:35 <kmc> of «Maybe :: * -> *» to «Int :: *» yielding «Maybe Int :: *»
09:20:37 <Cale> :k Int
09:20:38 <lambdabot> *
09:20:42 <Cale> :k Maybe Int
09:20:43 <lambdabot> *
09:20:48 <ski> kmc : yeah, sure. i just find it strange to use "type constructor" for things like `Either Int', which we use "data constructor" in a completely different sense of "constructor" (`Node 42' is not normally termed a "data constructor" on its own)
09:20:52 <ski> @type Node
09:20:53 <lambdabot> forall a. a -> Forest a -> Tree a
09:21:17 <kmc> the rules for "kinding" that are the same as the rules for typing the simply-typed lambda calculus with one base type
09:21:23 <ski> dolio : .. possibly .. i'm not sure
09:21:56 <ski> dolio : well, i suppose `()' is lazy, and can be forced, while `(#)' (or however you'd write it) wouldn't be
09:22:07 <kmc> if «τ₁ : κ₁ → κ₂» and «τ₂ : κ₁» then «τ₁ τ₂ : κ₂»
09:22:48 <ski> kmc : .. so i'd agree with that BNF, yes
09:23:02 <cncl> do people like the multi-parameter/functional dependency way of doing type programming over type families?
09:23:09 <cncl> (opinions)
09:23:22 <dolio> ski: Yeah, I'm not sure. I guess it could just be a jump back with no allocation or something.
09:23:26 <kmc> returning (#) should be similar to returning (State# t) right?
09:23:38 <kmc> both will have a "void" representation
09:23:40 <ski> cncl : well, it seems to me it sometimes can be neater to use that, rather than ATs .. i don't have a firm opinion, though
09:23:46 <ezyang> cncl: I like type families, but doing some things in them is still painful. 
09:23:48 <EvanR-work> so type constructors are functions on types
09:23:49 <kmc> the v calling type, as opposed to p or n and such
09:24:10 <dolio> Not that () allocates, because there's only one of them in the entire program.
09:24:13 <EvanR-work> how do you actually use the definitions to do something
09:24:24 <kmc> EvanR-work, yeah, and they're injective by definition.  «C S» is never the same as «C T» if S ≠ T
09:24:27 <cncl> ski/ezyang i see
09:24:30 <kmc> EvanR-work, definitions of what?
09:24:36 <EvanR-work> of the type constructors
09:24:38 <ski> kmc : like `(# Foo , Bar #)' would typicaly occupy two registers, `(#)' would occupy zero registers, yes
09:24:55 <cncl> i have a problem i could probably model with some of that fancy stuff, i was wondering if one was clearly preferred over the other at this point
09:25:00 <kmc> is (#) used in ghc source?
09:25:20 <kmc> cncl, i prefer asstypes over fundeps, but if you run into trouble with them you might want to switch back
09:25:41 <cncl> i haven't really tried either yet
09:25:50 <cncl> the only type-level programming i've done is in agda and c++
09:26:05 <zygoloid> cncl: i much prefer type families over functional dependencies
09:26:21 <zygoloid> i find it a lot easier to express my intent and reason about the compiler's behaviour with TFs
09:26:26 <kmc> EvanR-work, confused what you're asking.  have you written a useful program using a type like «Maybe T» ?
09:26:28 <cncl> do you still use multiparam typeclasses when using type families, typically?
09:26:47 <EvanR-work> kmc: yes, where T is a specific type
09:26:59 <kmc> EvanR-work, so you used the definition of the Maybe tycon there
09:27:15 <kmc> and you "used kinds" in that GHC used kinds to check that you weren't asking for something nonsensical
09:27:33 <EvanR-work> so whenever you write a type level application, there must be a non trivial 'value level' application somewhere ?
09:27:39 <EvanR-work> if not, thats what im asking
09:27:39 <kmc> no
09:27:45 <kmc> Nothing :: Maybe Char
09:27:51 <kmc> no value-level application
09:28:04 <EvanR-work> but what does that do? wheres the evaluation
09:28:07 <kmc> any non-trivial program will have value-level application though
09:28:11 <kmc> EvanR-work, it doesn't do anything
09:28:11 <EvanR-work> whats the input whats the output
09:28:16 <kmc> it's already in normal form
09:28:30 <kmc> if the question is "do non-trivial programs need to use function application" then the answer is yes
09:28:34 <kmc> but tycons are irrelevant to that
09:29:34 <EvanR-work> whats an example of non normal form
09:29:41 <kmc> 2+2
09:29:49 <EvanR-work> at the type level
09:29:53 <kmc> oh
09:30:05 <kmc> you have to get into GHC extensions before those exist
09:30:13 <kmc> type synonym families
09:31:27 <kmc> EvanR-work, in standard Haskell we have type application, but the "functions" we're applying are injective and don't have any computational content.  Maybe applied to Int is just «Maybe Int» by definition; there's nothing else it could be
09:31:50 <kmc> there's nothing like a β-reduction rule
09:31:59 <zygoloid> type synonyms can be not-in-normal form
09:32:42 <EvanR-work> injective *trying to remember algebraic jargon*
09:32:45 <EvanR-work> that means one to one?
09:32:52 <kmc> yeah
09:33:01 <EvanR-work> that means no computational content?
09:33:11 <c_wraith> not necesarily
09:33:12 <kmc> if a≠b then f(a)≠f(b)
09:33:21 <kmc> no, those were two separate properties i attributed to tycons
09:33:27 <c_wraith> But on the type level, with haskell98, there's no computational content
09:33:52 <kmc> injectivity is important because it means «Maybe S» and «Maybe T» are always distinct.  you don't need to do some β-reduction to find that out
09:34:18 <kmc> and by "no computational content" i meant there's nothing else forcing you to do reduction
09:35:03 <kmc> you can consider type synonyms as non-normal forms, or you can consider them as a separate macro pre-processor
09:35:27 <kmc> i prefer the latter view, as GHC defers most validity checking on types until after synonyms are expanded (if you set -XLiberalTypeSynonyms)
09:35:35 <kmc> not kind checking but even that could be deferred
09:35:57 <c_wraith> will haskell ever have kind polymorphism?
09:36:03 <kmc> c_wraith, UHC does
09:36:12 <c_wraith> ah, so there' no semantic issue
09:36:14 <kmc> it'll be a long time making it into the standard if there's no big push
09:36:28 <c_wraith> It's just a matter of getting it implemented in other compilers
09:36:36 <kmc> anyway type synonym *families* are a different matter entirely; they're functions on types in a more interesting way than type synonyms, and can have computational content (basically, pattern-matching on types)
09:36:36 <zygoloid> kmc: the latter view is more consistent with TypeSynonymInstances, i guess
09:36:42 <kmc> yeah
09:37:01 <zygoloid> pattern matching on type /normal forms/
09:37:04 <kmc> yeah
09:37:26 <kmc> just as functions pattern-match on normal forms of algebraic data
09:43:15 <kmc> "GHC currently does kind checking before expanding synonyms (though even that could be changed.)"
09:43:26 <kmc> would there be any interesting new things you could do if that change were made?
09:44:24 <zygoloid> kmc: "type Join f a = f a a" might be interesting if it were kind-polymorphic
09:44:37 <kmc> hmm
09:44:41 <zygoloid> i think it can only save you typing
09:44:49 <copumpkin> *kinding
09:44:54 <kmc> ;P
09:44:55 <zygoloid> since you can always write out a family of synonyms, long-hand
09:45:23 <kmc> so i guess the kind check is what's currently stopping you from writing mutually recursive synonyms which diverge
09:45:45 <kmc> type Fix f = f (Fix f)
09:46:29 <kmc> oh heh there's an explicit check "Cycle in type synonym declarations
09:46:30 <kmc> "
09:46:40 <dolio> Fix there is well-kinded.
09:46:58 <kmc> oh right
09:47:09 <kmc> STLC isn't strongly normalizing when you include explicit recursion
09:48:09 <kmc> type Y f = (G f) (G f); type G f x = f (x x)
09:48:24 <zygoloid> data Foo a b = Foo (b (a a))
09:48:32 <zygoloid> ^^ doesn't give an 'infinite kind' error ;(
09:48:36 <kmc> but G isn't well-kinded
09:48:37 <kmc> heh
09:48:48 <zygoloid>     The first argument of `a' should have kind `k',
09:48:48 <zygoloid>     but `a' has kind `k -> k1'
09:49:36 <copumpkin> zygoloid: wait, that works?
09:50:18 <kmc> hmm:   newtype Rec a = In { out :: Rec a -> a }
09:50:25 <kmc> how does this relate to
09:50:26 <kmc> @src Mu
09:50:26 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
09:50:28 <copumpkin> kmc: mmm
09:50:36 <copumpkin> kmc: roconnor wrote a "real" fix that way
09:51:29 <roconnor> http://r6.ca/blog/20060919T084800Z.html
09:51:37 <copumpkin> was just looking for that :)
09:51:49 <roconnor> FWIW, I copied it from Robert Dockins
09:51:53 <arbitrarylogic> zygoloid: showIntAtBase is too slow (quadratic in bit length) and I can't figure out Data.Binary.encode, but thanks for your help.
09:52:40 <c_wraith> I wish I could see how to make showIntAtBase linear.  It feels like it *should* be linear.
09:52:49 <ski> kmc : that `Rec' is also known as `Santa', it figures in Lb's / Curry's paradox
09:52:53 <kmc> ah
09:53:04 <copumpkin> yeah, languages like agda don't allow it
09:53:14 <EvanR-work> c_wraith: yeah i remember linearly showing int at base in class ;)
09:53:19 <roconnor> c_wraith: I asked around at lunch if anyone knew how long it takes to convert to another base
09:53:21 <EvanR-work> with repeated division
09:53:35 <c_wraith> repeated division is quadratic in bit length
09:53:36 <ski> yeah, the inductive type has to occur positively in the constructor argument types
09:53:50 <roconnor> c_wraith: I got a partial answer, let me find it
09:54:06 <EvanR-work> linear in final answer digit length ;)
09:54:32 <roconnor> EvanR-work: um.. the output is linear in the size of the input :O
09:54:32 <c_wraith> EvanR-work, that doesn't change anything.  repeated division is still quadratic in bit length
09:54:55 <EvanR-work> make division O(1) operation ;)
09:54:58 <copumpkin> lol
09:55:02 <c_wraith> Oh, right.
09:55:02 <copumpkin> make factoring an O(1) operation
09:55:10 <c_wraith> we've broken RSA!!!!
09:55:15 <copumpkin> sweet
09:55:18 <EvanR-work> division isnt factoring
09:55:20 <copumpkin> we should publish
09:55:34 <c_wraith> division isn't O(1)
09:55:42 <c_wraith> can't be.  the output size is O(n)
09:55:55 * EvanR-work divides every Int by every other Int, they seem to all take about the same time
09:56:02 <c_wraith> Int is boring.
09:56:04 <c_wraith> Try Integer
09:56:06 <copumpkin> EvanR-work: yes, but the bit length is constnat there ;)
09:56:07 <EvanR-work> i thuoght that was the goal
09:56:18 <EvanR-work> :t showIntAtBase
09:56:19 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
09:56:28 <EvanR-work> showIntegralAtBase
09:56:32 <EvanR-work> >_<
09:57:30 <EvanR-work> so maybe rendering into a place value system is like factoring, hard
09:57:47 <c_wraith> I mean, showIntAtBase is O(1), for Int.  Integer is the only interesting case
09:58:05 <c_wraith> Nah, because conversion to base 16 or 256 are trivially O(n)
09:58:13 <EvanR-work> but thats a special case
09:58:24 <EvanR-work> like some composite numbers are easy to factor
09:58:29 <roconnor> c_wraith: http://portal.acm.org/citation.cfm?id=1806689.1806771 <-- this 2010 paper seems to at least be kinda relivant.  It seems to show how to create a data structure to store a length n vector from an alphabet of size Sigma in ceil(n*logBase 2 Sigma) bits and have constant time access to each bit.
09:58:56 <copumpkin> we do have constant time access to each bit, if someone merges my patch to Integer in GHC :P
09:58:59 <c_wraith> I would believe that as a lower bound.
09:59:09 <c_wraith> For the arbitrary case
09:59:14 <roconnor> "constant time access to each bit" <-- not entirely sure what that means.
09:59:29 <roconnor> c_wraith: yes, it is also clearly a lower bound
09:59:30 <EvanR-work> bit[1000];
09:59:40 <ski> > unfoldr (cond (== 0) (const Nothing) (Just . (snd &&& fst) . (`divMod` 256))) 0xff2845012409fe
09:59:41 <lambdabot>   [254,9,36,1,69,40,255]
10:00:05 <copumpkin> roconnor: right now the Data.Bits instance for Integer is rather ugly, and shifts the integer to get at a bit, when there's also just a nice GMP function for querying the bit
10:00:26 <c_wraith> I sometimes wish I was an ACM member
10:00:31 <Zao> copumpkin: Assuming you use GMP for Integer...
10:00:37 <roconnor> copumpkin: I just mean that it takes log i time just to decode the index i.
10:00:38 <copumpkin> Zao: as most people do :P
10:00:49 <copumpkin> ah
10:00:50 <Zao> Only people who hates freedom does.
10:00:55 <copumpkin> true that
10:00:59 <roconnor> copumpkin: but I think they are using some sort of instantenous ram model where looking up and address is presumed to take constant time.
10:01:00 <EvanR-work> what?
10:01:07 <copumpkin> Zao: wait, I thought people who didn't use Integer hated freedom
10:01:11 <copumpkin> I guess it depends who you ask
10:01:29 <copumpkin> roconnor: ah yeah, but that's a fairly common assumption, even though it's wrong
10:02:10 <EvanR-work> everything is logarithmic! ram size is a variable!
10:02:20 <roconnor> I haven't read this paper but it sounds like it would imply a linear base conversion algorithm
10:02:33 <EvanR-work> constant time lookup is a shame
10:02:35 <EvanR-work> sham*
10:03:51 <aristid> EvanR-work: why? ram size is limited by the size of the pointers, so everything ist constant time
10:03:56 <aristid> -ist+is
10:05:15 <EvanR-work> so ran size is somewhere between 4G and 2^64-1
10:05:29 <EvanR-work> currently at the low end and increasing
10:05:37 <pnicholson> hello, I would like to interpolate the column name into a sql query using HDBC, how would I do that?
10:05:40 <EvanR-work> seems like a good place to use an unbounded model
10:05:47 <EvanR-work> much like number of particles in the galaxy or something
10:05:50 <roconnor> the paper also describes an online self-delimiting encoder that takes a stream of n bits and returns a n + log_2 n + O(log log n) stream.
10:05:58 <roconnor> which is persumabaly somehow related to all this.
10:06:40 <roconnor> this refutes a conejcture of Maurer and Sjodin on the hardness of online self-delimiting encodings.
10:08:24 <pnicholson> hello, I would like to interpolate the column name into a sql query using HDBC, how would I do that?
10:08:39 <pnicholson> like: run connection "INSERT INTO table (?, column2) VALUES (?, ?)" [toSql column, toSql value1,toSql value2]
10:09:01 <EvanR-work> what if you use a generalized accelerated adder like the lookahead carry adder, but it works in base B
10:09:37 <EvanR-work> and you accumulate 2^n s from the bit stream
10:09:47 <c_wraith> pnicholson, look at quickQuery'
10:09:54 <c_wraith> Oh, nevermind
10:10:02 <c_wraith> You can only use the database driver to interpolate values
10:10:05 <c_wraith> Not column names
10:10:16 <c_wraith> That's a limitation of all sql drivers/interfaces
10:10:24 <EvanR-work> a sensible one
10:10:38 <c_wraith> I often want to interpolate column names, or even table names...
10:10:39 <EvanR-work> column names shouldnt be variables
10:10:46 <EvanR-work> or table names
10:10:52 <c_wraith> that's a *very* limited viewpoint.
10:10:59 <chrisdone> good mornin' mightnight
10:11:09 <JoeyA> This is causing a stack overflow compiled (but not interpreted) with GHC 6.12.1: http://codepad.org/dH0RDFXQ
10:11:12 <EvanR-work> i dont like table1 table2 table3... it suggests a problem with the data model
10:11:16 <c_wraith> It's often correct to build a custom query depending on input.
10:11:27 <EvanR-work> building custom query yes
10:11:28 <JoeyA> Note that I meant to use replicateM instead of replicateM_ because I'm actually interested in the results.
10:11:49 <JoeyA> Why is generating a list with replicateM causing a stack overflow?
10:12:09 <c_wraith> And so, you either use string concatenation, or want to use the same mechanism the interface provides for safely inserting values.
10:12:41 <EvanR-work> you might as well say the driver should arbitrarily construct the string from arbitrary inputs
10:13:12 <c_wraith> I'm just saying, the urge is there, because it's already a string construction system.
10:13:32 <pnicholson> c_wraith, EvanR: don't really see the need to interpolate tables but columns would be usefully depending on input
10:13:34 <EvanR-work> but you are proposing that an identical query is useful in different tables
10:13:37 <EvanR-work> then why are they different tables?
10:14:04 <EvanR-work> pnicholson: replicating columns leads to denormalization
10:14:12 <c_wraith> No, I'm saying "I already have a system to build queries.  Why should it only work for values?"
10:14:42 <c_wraith> what about his question makes you think he's replicating columns?
10:14:51 <EvanR-work> practically speaking yes, to deal with broken databases you want to easily port this query to all the identical tables
10:15:04 <c_wraith> Who says the database is broken?
10:15:22 <EvanR-work> applying a non trivial query to more than one table?
10:15:24 <c_wraith> I want to build *queries* dynamically.  Tables, columns, constraints.  All of them.
10:15:53 <EvanR-work> im not sure what you mean by dynamic
10:15:57 <c_wraith> At the moment, you have to use a split system, of string concatenation for everything but explicit values.
10:16:06 <c_wraith> and then driver interpolation for values
10:16:20 <EvanR-work> you dont have to use the driver interpolation if you dont want to
10:16:22 <c_wraith> dynamic = "depending on user input"
10:16:33 <EvanR-work> ah the user
10:16:37 <c_wraith> eh, not using driver interpolation for values is taking a huge risk.
10:17:00 <EvanR-work> not if your column inserter has the same safeguards
10:17:07 <EvanR-work> just reuse that system
10:17:50 <c_wraith> still, I'm currently writing the insert system.  Yay for creating lists of ? dynamically, too. :)
10:18:21 <EvanR-work> user interfaces are not simple in any case. for getting real work done then i dont think theres an issue here
10:19:14 <c_wraith> It's just annoying that what looks like a useful query builder on first glance is actually far more limited than you'd expect.
10:19:23 <EvanR-work> yes
10:20:04 <EvanR-work> but for everything but 'the user wants to turn an arbitrary language / checkbox list into SQL' i think its appropriate
10:20:29 <EvanR-work> and broken databases
10:23:52 <pnicholson> ok, thanks for your thoughts guys
10:25:32 <dons> ?yow
10:25:32 <lambdabot> Couldn't find fortune file
10:26:23 <chrisdone> My Haskell programs are WELL TYPED!
10:27:20 <dolio> Did YOU find a DIGITAL WATCH in YOUR box of VELVEETA?
10:32:40 <mauke> preflex: be PoppaVic
10:32:41 <preflex>  You likely don't understand "shooting"., "reloading" or "cooking" - let alone C. I don't play executioner
10:33:10 <gwern> mm... cooking
10:40:57 <EvanR-work> where do all these poppavic quotes come from xD
10:41:15 <EvanR-work> besides the obvious source
10:41:25 <JoeyA> Does create :: Int  -> (Ptr  Word8  -> IO  ()) -> IO  ByteString iterate the pointer over the ByteString?
10:41:55 * ski would assume it's just a base pointer
10:42:07 <JoeyA> Or do I have to traverse it manually?
10:42:14 <ski> (.. having a delimited dynamic extent)
10:42:19 <copumpkin> it's the base
10:43:02 <ski> (.. hm, or i suppose rather the pointer to it is supposed to have a delimited dynamic extent)
10:43:42 <kmc> JoeyA, is that an "Internal" function?
10:46:38 <JoeyA> Yes
10:46:48 <JoeyA> I tried it, and yes, I do have to traverse manually
10:48:09 <copumpkin> it makes sense
10:48:49 <copumpkin> otherwise it could just be a generate :: Int -> (Int -> Word8) -> ByteString unless you're doing crazy stuff
10:49:04 <copumpkin> or (n : Nat) -> (Fin n -> Word8) -> ByteString
10:49:09 <copumpkin> :)
10:49:46 <JoeyA> Hmm, come to think of it, I guess ByteString.Internal can be abused to mess around with a block of memory :-)
10:49:55 <dons> important post from JaffaCake  on the new parallel package, check it out. (and upmods!) http://www.reddit.com/r/programming/comments/d3idz/parallel_programming_in_haskell_with_explicit/
10:50:02 <JoeyA> http://codepad.org/ZYh4p1ls -- I don't understand why gen isn't in scope.
10:50:25 <JoeyA> On line 7, gen is not in scope, but it's declared on line 3, is it not?
10:50:52 <copumpkin> not in the where
10:51:03 <copumpkin> you're doing a pretty good job of hiding the where though :P
10:51:15 <kmc> JoeyA, "where" binds to a declaration
10:51:24 <copumpkin> if you want to write it that way, pass the gen into mkChunk
10:51:33 <JoeyA> I think I understand
10:51:47 <copumpkin> typically people put where somewhere visible
10:51:49 <JoeyA> the gen <- newMTGen ... return ... is really an expression
10:51:51 <kmc> so "where" is binding all the way back to line 2
10:51:57 <JoeyA> but where applies to a larger area
10:51:57 <copumpkin> since it always binds to the declaration
10:52:14 <kmc> and so the only stuff carried into the "where" scope from outside are the args to garbage, 'n'
10:52:19 <kmc> JoeyA, use "let" instead
10:52:37 <kmc> get <- newMTGen (Just 0); let mkChunk n = ...; return (...)
10:53:36 <JoeyA> done, and it works
10:53:52 <JoeyA> I just wish System.Random.Mersenne allowed multiple instances.
10:54:20 <JoeyA> (but I don't really need it any time soon)
10:54:23 <dons> use the Pure64 module then
10:55:30 <JoeyA> Thanks, I'll benchmarkify it
10:55:34 <copumpkin> wow, so sad that that thing already has two downvotes
10:55:41 <copumpkin> programmers are so dumb :P
10:56:20 <copumpkin> here, upvote someone's android earning reports, but downvote a blog post about programming in an interesting language
10:56:26 <ski> ("monads are nice and compositional" ?)
10:56:45 <dons> chunks compose easily enough
10:56:51 <dons> values, not types.
10:56:59 <dons> (is how I read that)
10:57:58 <ezyang> copumpkin: Quick, let #haskell know and we'll upvote it from submission! 
10:58:06 <copumpkin> :)
10:58:26 <copumpkin> hey, I actually read it before upvoting it, but that was just cause I saw it on JaffaCake's twitter
10:59:16 <kmc> well nobody actually uses Haskell, so it's just a troll
10:59:28 <BMeph> How'zabout we upvote it into submission? ;)
11:01:23 <aristid> damn, more than half of my firefox tabs are haskell-related (and i have three rows of them)
11:02:35 <ski> "CnC" standing for ?
11:03:23 <gwern> military science's command and control?
11:03:33 <gwern> mechanical engineering's automated lathe-thingies?
11:03:38 <gwern> CnC could be a lot of things
11:03:55 <sproingie> Coffee 'n Cats
11:04:03 <gwern> now you're just being silly
11:04:28 <sproingie> right usually it's spelled C&C
11:04:39 <arjanb> i think it some Intel concurrency library for haskell
11:04:51 <mauke> cheech and chong
11:04:53 <sproingie> concurrent coffee and cats
11:04:58 <ski> "The fork/join API I've described here is comparable in expressivity to Haskell CnC"
11:05:01 <mauke> command and conquer
11:05:27 <gwern> mauke: I just want you to know that whatever anyone else thinks of your humor, I apprecite it
11:05:30 <JoeyA> Is there a way to cast a Word8 to a Word32?
11:05:37 <JoeyA> Or do I just need to use fromIntegral?
11:05:50 <Twey> JaffaCake: Typo ‘discaded’
11:05:57 <JoeyA> (a fast way, I should say)
11:05:58 <Twey> Nice article though
11:06:16 <mauke> JoeyA: use fromIntegral
11:08:43 <arjanb> CnC is http://hackage.haskell.org/package/haskell-cnc
11:09:02 <ski> ty
11:11:50 <noteventime> I'm getting an error about a missing gconf key when trying to run yi with the Pango interface, any suggestions on how to find out what key is missing.
11:13:05 <noteventime> I tried to see it'd be possible to add the information to the gconf bindings, but the call generating the error is a guard thing
11:13:25 <noteventime> It takes a pointer and calls fail (for IO) when the pointer is null
11:19:53 <JoeyA> Is there a way to perform an action in the memory of a ByteString?
11:19:58 <JoeyA> Similar to create, but for an existing one.
11:20:04 <kmc> yeah, you can get a ForeignPtr to it
11:20:46 <JoeyA> Why does create use Ptr instead of ForeignPtr?  Does either have a performance overhead, or do they work the same?
11:20:55 <kmc> http://codepad.org/I03m4tSw
11:21:07 <kmc> Ptr is more directly useful
11:21:21 <kmc> when you have a ForeignPtr you'll use it locally with withForeignPtr
11:21:25 <kmc> :t withForeignPtr
11:21:26 <lambdabot> Not in scope: `withForeignPtr'
11:21:30 <kmc> :t Foreign.withForeignPtr
11:21:31 <lambdabot> forall a b. GHC.ForeignPtr.ForeignPtr a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
11:22:25 <kmc> :t Data.ByteString.toForeignPtr
11:22:26 <lambdabot> Not in scope: `Data.ByteString.toForeignPtr'
11:23:05 <kmc> JoeyA, since ByteString presents a pure immutable interface, you've obviously got to be careful if you're poking around in its memory
11:23:09 <JoeyA> Cool, thanks
11:23:19 <kmc> :t Data.ByteString.Internal.toForeignPtr
11:23:20 <lambdabot> BSC.ByteString -> (GHC.ForeignPtr.ForeignPtr Word8, Int, Int)
11:23:24 <JoeyA> I was just going to peek, sorry!
11:23:31 <JoeyA> Please, can I take just a small peek?
11:23:35 <kmc> hehe
11:23:38 <kmc> if you must ;P
11:23:48 <JoeyA> I promise I won't touch anything but the lamp!
11:23:53 <kmc> haha
11:25:20 <tafryn> Is there a haskell equivalent to select?
11:25:26 <kmc> tafryn, you can call select from Haskell
11:25:39 <kmc> tafryn, but it's far more common to spawn threads for each file descriptor and use blocking IO
11:25:47 <kmc> GHC's IO manager will use select() for you behind the scenes
11:25:59 <copumpkin> http://snapplr.com/hbrx anyone have any ideas?
11:26:04 <kmc> in GHC threads are easy and cheap, one should not bend over backwards to avoid them as in some languages
11:26:38 <tafryn> kmc: Can you point me towards an example that uses threads?
11:26:50 <kmc> RWH has some
11:26:52 <kmc> @where RWH
11:26:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:27:53 <BMeph> After a couple of days, I finally got around to that "Learn a Program in Ten Years" article. Good stuff, very funny... ;)
11:28:29 <mauke> kmc: I don't see how you'd use threads if you want deterministic behavior
11:28:43 <kmc> mauke, does select() give deterministic behavior?
11:28:57 <copumpkin> here are more details: http://pastie.org/1104662 . Anyone ever see anything like that?
11:29:00 <kmc> it's most commonly used with network sockets
11:29:04 <mauke> kmc: i.e. read from multiple file descriptors but be able to stop at any time (because you got a signal), serialize your current state, and restart
11:30:13 <kmc> what does that have to do with being deterministic?
11:30:38 <mauke> because I know my state at any point in time
11:30:55 <mauke> threads could be doing god knows what
11:33:27 <kanak> Hi, can anyone tell me the how to do batch tests with QuickCheck 2.0x? I'm looking for something equivalent to runTests from QuickCheck 1. thanks
11:35:48 <kmc> mauke, good point
11:36:00 <kmc> mauke, can you make each individual thread do its state saving?
11:36:12 <copumpkin> any cabal experts know about my error? :)
11:36:53 <mauke> kmc: what if it's hanging in read()?
11:37:12 <Saizan> copumpkin: see #agda :P
11:37:15 <kmc> then your signal handler can kill it with an async exn
11:37:22 <mauke> ew
11:37:34 <mauke> async exceptions make my head explode
11:37:56 <kmc> yeah
11:38:03 <mauke> it's like writing in C++ with an exponential number of codepaths to think about
11:38:03 <kmc> signals are already like async exns
11:44:06 <chrisdone> mauke: oh god
11:45:18 <mauke> kmc: how do you call select from Haskell?
11:45:32 <p_l> signals suck, especially after seeing CHF or SEH -_-
11:46:04 <mauke> CHF as in swiss franc?
11:47:08 <p_l> mauke: Condition Handling Facility, SEH's (Structured Exception Handling) big brother
11:47:33 <kmc> mauke, well, there's a "unix" library binding most of POSIX, plus you can FFI import directly
11:47:53 <kmc> but i don't know if you have to do something special to keep from interfering with GHC's IO manager
11:48:06 <mauke> I don't think it's in unix, and FFI sucks for this
11:48:19 <mauke> the whole fd_set interface is macros
11:48:25 <mauke> also, interactions with normal IO
11:48:50 <mauke> I might have to upload my pseudo-select (implemented on top of threads) to hackage :-)
11:48:57 <kmc> cool
11:53:10 <Wolfspaw> Does VIM have the pretty-printing of Haskell Symbols? (in a plugin, or something? like the pretty-printing of haskell mode in Emacs?)
11:54:08 <Botje> Wolfspaw: there's a vim plugin for it
11:54:17 <mauke> I don't think so, but you could replace the actual characters on reading/writing
11:56:12 <Wolfspaw> Botje: hm, nice. Ill look for it then
12:05:49 <tafryn> Why would a process that I spawn with createProcess become defunct after a few seconds?
12:06:16 <mauke> because it exited
12:09:44 <tafryn> Is there any reason it would exit when invoked through createProcess, but not when invoked from my shell?
12:10:34 <ClaudiusMaximus> tafryn: are you reading all of its stdout/stderr?
12:10:37 <ski> p_l : "Condition Handling Facility" being ?
12:11:17 <p_l> ski: system-wide condition system in VMS (conditions being used also for exceptions, signaling cpu errors etc.)
12:11:49 <p_l> MSVC implements C++ exceptions on top of Windows' SEH system, which was based on CHF (afaik)
12:11:56 <ski> p_l : hm .. any relation to condition systems in lisps ?
12:12:19 <p_l> ski: no, except maybe for the fact it was more generic
12:12:29 <p_l> VMS is very asynchronous system
12:12:46 <ski> ok
12:12:56 <tafryn> ClaudiusMaximus: Not yet.
12:14:24 <sproingie> NT's I/O was based on VMS
12:14:31 <sproingie> same architect
12:14:42 <ClaudiusMaximus> tafryn: hm, the default seems to be to use the parent's std-handles, but if you override that then you probably need to get the outputs or it'll either block or exit
12:15:21 <tafryn> ClaudiusMaximus: I am overriding them, but shouldn't it just block until I get around to reading them?
12:15:22 <p_l> sproingie: not exactly, though - afaik userspace I/O primitives are more Unix-like (synchronous, the same set of possible operations), the kernel structure is VMS-like - filters, ports, etc.
12:16:17 <p_l> it did fortunately keep SEH, though it seems much less documented
12:17:06 <sproingie> yeah the kernel of course.  win32 was a crock on top of an elegant kernel
12:18:30 <p_l> sproingie: I think the decision of not scrapping win3.x and the mantra of backward compatibility at any price (instead of creating a sensible way to "virtualize" noncompliant apps) is much bigger influence in crocking it up
12:19:03 <sproingie> actually nt does have a decent way of isolating things via subsystems
12:19:15 <sproingie> just that everything uses the same subsystem
12:20:03 <sproingie> business-wise probably the best thing they could have done.  oh well.
12:20:15 <p_l> sproingie: "performance" reasons and "backward compatibility" taken together... and then imagine that backward compatibility meant that they had to *introduce* bugs to keep some crocked-up apps working
12:21:13 <p_l> search on the web for the free chapter of one of their books, the one on bugs in code. I think it had examples of crocked-up stuff found by the Win95 compatibility team (in 3rd party apps)
12:21:31 <p_l> makes you lose hope about programming skills in general
12:21:54 <`Zerax`> There is that classic story about the memory manager having artefacts regarding the treatment of freed memory blocks, because of Sim City.
12:22:51 <sproingie> they've done pretty well these days with making the bug-compatibility stuff confined to compatibility profiles
12:22:53 <p_l> `Zerax`: now imagine that Win95 shipped with database of binary patches
12:23:37 <p_l> and lots of "ifs" to check if the app running was the one that had developers who don't understand "RESERVED FOR FUTURE USE" in bitmasks
12:26:22 <tafryn> ClaudiusMaximus: I was using hGetContents instead of hGetLine, etc. That's how I was closing it.
12:32:00 <jystic> @pl runFieldGet g ds = g ds >>= \(x,_) -> return x
12:32:00 <lambdabot> runFieldGet = flip flip (return . fst) . ((>>=) .)
12:37:08 <Botje> @pl runFieldGet g ds = fst `fmap` g ds
12:37:09 <lambdabot> runFieldGet = ((fst `fmap`) .)
12:37:26 <Botje> that's better :)
12:37:30 <jystic> nice
12:38:57 <jystic> i had settled on: runFieldGet g ds = g ds >>= return . fst
12:39:20 <jystic> @pl runFieldGet g ds = fst <$> g ds
12:39:20 <lambdabot> runFieldGet = ((fst <$>) .)
12:39:31 <mauke> jystic: >>= return . is liftM (a.k.a. fmap)
12:40:10 <jystic> i've been having fun all day with stuff like that :)
12:40:49 <jystic> i've been thinking, dammit i know that this is boilerplate! what am i missing! :D
12:42:05 <jystic> it feels good that i'm starting to recognise the patterns more and more, now i just need to remember the final step and convert some of the boilerplate to library functions
12:42:55 <jystic> fmap still seems mostly like magic to me though, especially in parsers, that's really cool
12:44:32 <c_wraith> jystic: fmap is the opposite of magic.  Every type that implements it needs to do so explicitly.  That's not magic, that's boring! :)
12:45:14 <c_wraith> ...  The fact that there's only a single correct implementation of fmap for every type having the correct kind is a bit magic, but that's another entirely different issue. :)
12:45:30 <jystic> hmm, is it possible to derive it automatically?
12:45:38 <c_wraith> yes.
12:45:45 <c_wraith> GHC 6.12 even has an extension for doing so
12:45:54 <jystic> this is what i find magic, with parsers:  MyType <$> getWord8 <*> getWord8 <*> getWord8
12:46:04 <c_wraith> eh, that's applicative.
12:46:10 <c_wraith> That's a bit more interesting, at least
12:46:16 <jystic> yeah, but it's got an fmap in it
12:46:26 <`Zerax`> Enjoy the feeling, once you figure it out it becomes a bit ordinary.
12:46:30 <JoeyA> How do I interpret ByteString's toForeignPtr offset field?
12:46:44 <JoeyA> is ptr - offset the base of the byte string's containing buffer?
12:46:52 <JoeyA> Or is ptr + offset the base of the string I'm interested in?
12:46:55 <c_wraith> JoeyA: It allows efficient sub-bytestring creation
12:47:03 <c_wraith> Oh, you mean the actualy interpretation?
12:47:07 <JoeyA> right
12:47:17 <JoeyA> when I call toForeignPtr to retrieve the contents of a ByteString
12:47:26 <JoeyA> do I need to add the offset to get to the right position?
12:47:31 <c_wraith> Look at the type.  If it's a pointer, it's absolute.  If it's an int, it's the offset.
12:47:43 <JoeyA> It's an Int
12:47:50 <JoeyA> ytestring/0.9.1.4/doc/html/Data-ByteString-Internal.html#v%3AtoForeignPtr
12:47:54 <JoeyA> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString-Internal.html#v%3AtoForeignPtr
12:48:02 <c_wraith> I mean, this is easy to test.
12:48:07 <c_wraith> But I suspect you want to add the offset
12:48:42 <JoeyA> toForeignPtr actually just unpacks the PS data constructor
12:51:09 <`Zerax`> jystic, a good way to get to grips with these things is to write Functor, Applicative and Monad instances for types in the Prelude. Start with non-recursive types and types with zero arguments, as those get a little more confusing. 
12:51:35 <JoeyA> I got it.  I do need to add the offset.
12:51:52 <mauke> types with zero arguments as in kind *?
12:51:56 <mauke> that won't work
12:52:15 <`Zerax`> I was trying to find a way to avoid saying function types
12:52:20 <`Zerax`> as it would get me into trouble
12:52:26 <JoeyA> In a nutshell, ByteString.head (PS ptr offset length) = withForeignPtr ptr $ \p -> peekByteOff ptr offset
12:52:44 <jystic> `Zerax`: i think i definitely need to write some Applicative types
12:52:46 <JoeyA> (the actual definition checks if length <= 0 and uses inlinePerformIO)
12:52:52 <jystic> that's what i find the most magic
12:53:35 <Heffalump> ivanm: you around?
12:54:45 <jystic> i'm quite comfortable with monads, although i should play a bit more with state/reader and monad transformers
12:55:33 <`Zerax`> @type ap
12:55:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:55:35 <`Zerax`> @type (<*>)
12:55:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:55:45 <ski> jystic : `Applicative' is like `return', `liftM' and `ap' without `join' (or `(>>=)')
12:57:30 <jystic> monads seem to be about sequencing, what is applicative about?
12:57:40 <ski> combining
12:58:07 <jystic> ahh, so just combining in some arbitrary fashion
12:58:41 <ski> e.g. with an applicative parser, you can't have the parser decide *what* to parse later depend on what values it actually parsed earlier
12:59:06 <jystic> right, but with a monadic parser you can?
12:59:10 <ski> e.g. you can't first parse a natural number, and then parse that many characters into a string
12:59:13 <ski> right
12:59:39 <ski> with the applicative interface the "shape" of the parser is predetermined
12:59:52 <ski> with the monad interface, it can depend on run-time datat
12:59:59 <ski> s/datat/data/
13:00:02 <mauke> datata
13:00:10 <jystic> Data.Data.Data? :)
13:00:25 <mauke> Dataism
13:00:33 <nrtelang> hi, if monads define a monoid over endofunctors, does that mean monadpluses define some variety of ring over endofunctors?
13:04:06 <djahandarie> I love how arbitrary math questions get asked in here and usually get answered
13:04:26 <jystic> > 1+1
13:04:27 <lambdabot>   2
13:04:38 <djahandarie> I said arbitrary...
13:04:50 <mauke> and math, not arithmetic
13:04:59 <winxordie> arithmetic's math, right?
13:05:01 <djahandarie> @check \x -> x+x == x*2
13:05:02 <lambdabot>   "OK, passed 500 tests."
13:05:10 <djahandarie> Now THAT's arbitrary
13:05:19 <jystic> haha
13:06:46 <ninechars> i'm probably not the first person to think of this but man, using runIO and 'location' in TH to parse the file you're in with haskell-src-exts or whatever is an evil, evil hack
13:06:50 <ninechars> a deliciously evil hack
13:06:52 <dankna> yes, haha
13:07:45 <aRcatan> what is the order of the smallest field extension of Q that contains 2^(1/4)?
13:09:14 <wli> aRcatan: Galois or normal extension or just any field extension?
13:09:23 * hackagebot strict-io 0.2.0 - A library wrapping standard IO modules to provide strict IO.  http://hackage.haskell.org/package/strict-io-0.2.0 (NicolasPouillard)
13:10:20 <aRcatan> just any field extension
13:10:49 <wli> aRcatan: I'd say [Q(2^(1/4)):Q] = 4.
13:11:30 <wli> aRcatan: For a Galois extension you need Q(2^(1/4),i)
13:12:30 * aRcatan has to think about it
13:14:03 <wli> aRcatan: The tower usually goes F_0 = Q, F_1 = Q(i), F_2 = F_1(2^(1/4)), with F_0\subsetneq F_1\subsetneq F_2.
13:14:59 <wli> aRcatan: You end up needing the roots of unity before the real n-th root.
13:17:46 <sshc> Why is UndecidableInstances unpopular?
13:17:52 <ezyang> Hey guys, say I have a bunch of representations that need to be able to convert to one another. What kind of typeclass should I write? An Integral style one (where I pick one canonical implementation) or something like Convertable a b (these are not my representations, so I indeed do have a function for each pair.) 
13:18:07 <aRcatan> wli: i think i see it now. thanks for the explanation.
13:19:28 <BMeph> That CnC article brings up a good point, that I'll need to keep in mind to use: "Haskell ... function application involves no parentheses or commas, only spaces (like a command shell)."
13:20:00 <EvanR-work> uh oh, i actually do use parentheses sometimes
13:20:04 <EvanR-work> a b (c d)
13:20:27 <EvanR-work> unlike a command shell
13:20:41 <mauke> EvanR-work: those parens are for grouping, not function application
13:21:01 <ezyang> You can make a pretty convincing lisp in Haskell :^) 
13:21:05 <BMeph> EvanR-work: ...what mauke said. :)
13:21:13 <EvanR-work> youre all fired
13:21:41 <BMeph> <EvanR-work> youre all fired .. up! (FTFY) ;þ
13:21:50 <EvanR-work> just replace all $ with parentheses and it suddenly turns intp lisp ;)
13:22:11 <mauke> anyone want an implementation of $ in common lisp?
13:23:26 <BMeph> The conflation of lists as lists and control structure messes up that idea, big-time. :(
13:23:51 <kmc> sshc, i don't know either
13:23:55 <mauke> but people told me that haskell uses lists as loops and other control structures!
13:23:56 <EvanR-work> yeah i dont know what lispers think is so elegant about it
13:24:03 <BMeph> Er, lists as *data ...
13:25:46 <BMeph> Haskell uses lists with control structures, but not _as_ a control structure, except in so far as its use as a data structure.
13:26:12 <kmc> i disagree
13:26:28 <BMeph> Yes!
13:26:35 <EvanR-work> i still get confused about lisp list of data vs function application vs function definition
13:26:59 <BMeph> Someone besides ddarius disagrees, I must be getting better as this stuff! ;þ
13:27:00 <dankna> the elegance is that the Lisp equivalent of Template Haskell doesn't require a huge ontology
13:27:25 <kmc> lazy data structures are control-flow structures
13:27:33 <mauke> warning: lisp abuse: http://mauke.ath.cx/stuff/lisp/add-x.lisp
13:27:37 <kmc> this is totally different from the question of how code syntax is represented
13:28:02 <djahandarie> Man, UHC is really awesome because of its kind polymorphism
13:28:02 <BMeph> kmc: are *interpretable as ... (FTFY) ;)
13:28:06 <dankna> hahahahaa wow, I love that, mauke
13:28:22 <mauke> dankna: the perl version is even better in some ways
13:28:26 <dankna> I bet
13:28:38 <kmc> what does #$ mean in lisp?
13:28:47 <mauke> kmc: nothing, it's defined in implinest.lisp
13:29:04 <djahandarie> Monads and monoids can be written in one typeclass with kind polymorphism!!!
13:29:06 <dankna> it's a reader macro
13:29:08 <djahandarie> So cool
13:29:12 <dankna> that is, a user-defined notation
13:29:14 <kmc> mauke, +5 for the comment at the top of that file
13:30:20 <dankna> hah
13:31:45 <kmc> djahandarie, i'm going to commit the unforgivable sin and ask: is it *useful* to do so?
13:32:09 <dolio> No.
13:32:19 <djahandarie> Well.. you can... uh...
13:32:42 * djahandarie runs
13:33:11 <`Zerax`> You need a distraction
13:33:19 <`Zerax`> Otherwise the mob'll be after you
13:46:28 <JoeyA>  Is there a function in the Haskell libraries to system-independently concatenate paths?
13:46:37 <ddarius> @hackage filepath
13:46:37 <lambdabot> http://hackage.haskell.org/package/filepath
13:46:57 <JoeyA> ah, pathSeparator
13:47:54 <c_wraith> or just </>
13:48:01 <c_wraith> which is an infix name for the same function
13:48:09 <ddarius> UHC has kind polymorphism?!
13:48:28 <mee> you mean you guys don't use the shell like $ echo $(cat <(echo "Hi there"))  ?
13:48:54 <c_wraith> would Typeable be a case where Kind polymorphism would be a win?
13:49:00 <ddarius> Yes.
13:49:19 <lispy1> ddarius: how do they achieve it?
13:49:25 <ddarius> So would Functor and Category.
13:49:43 <ddarius> lispy1: Kind polymorphism?  I just now found out that it allegedly has it.
13:49:55 <lispy1> ddarius: http://monoidal.blogspot.com/2010/07/kind-polymorphism-in-action.html
13:49:57 <dolio> It definitely does have it.
13:50:20 <dolio> Unless they've taken it out since I used it, but that seems unlikely.
13:51:12 <dolio> It has quirks, though.
13:52:02 <dolio> For instance, I don't think 'type Id (f :: k) = f' (or whatever the exact syntax would be) worked right last I checked.
13:52:30 <dolio> In that 'Id Maybe ()' gets a kind error.
13:53:00 <dolio> But that's probably a less interesting use case.
13:53:32 <ddarius> lispy1: I believe for the most part all that would be necessary would be to liberalise the kind inferer/checker to be more like an HM one.  I'm not sure what kind of problems kind polymorphism causes for lower levels.
13:53:57 <ddarius> dolio: Does UHC have a :k like thing?
13:54:29 <dolio> Does it have an interactive environment? I forget.
13:54:48 <dolio> I think I only used the compiler.
13:54:51 <ddarius> Allegedly it doesn't but it could have some less interactive means.
13:54:59 <lispy1> ddarius: I would assume (on intuition only) that it interacts similar to adding rank beyond 1.
13:55:07 <ddarius> I'm curious whether Id gets the kind forall k. k -> k.
13:57:46 * hackagebot binary-generic 0.2 - Generic binary serialisation using binary and syb.  http://hackage.haskell.org/package/binary-generic-0.2 (LarsPetersen)
13:58:13 * ddarius wonders what the simplest lambda calculus that demonstrates kind polymorphism is.
13:59:26 <ddarius> lispy1: I don't think it would be that, particularly with Haskell's limited type level, but there are certainly cases that would require explicit kind annotations to be unambiguous.
14:04:32 <pchiusano> I need a name for a function that groups elements of a set into multiple bins, but not necessarily disjoint bins
14:05:09 <pchiusano> so if the original set were {1,2,3,4}, the output might be {{1,2}, {1,3,4}, {4}}
14:05:43 <copumpkin> groups by what?
14:05:47 <copumpkin> filterM ? :)
14:06:03 <copumpkin> I guess that does more
14:06:26 <pchiusano> copumpkin: some arbitrary function...
14:07:59 <pchiusano> I was thinking "partition", but that implies the bins are disjoint I'd say
14:08:14 <copumpkin> pchiusano: subsetsBy or something?
14:08:28 <copumpkin> not sure
14:08:48 <pchiusano> that is not bad
14:09:33 <`Zerax`> call it fmap
14:09:48 <`Zerax`> Or is that a little too abstract
14:10:31 <copumpkin> not sure that really fits :)
14:12:02 <copumpkin> pchiusano: just out of curiosity, what kind of an interface would you provide to specify the groupings? seems like the easiest would be to be a filter f . subsets but that's necessarily horrendously inefficient
14:13:06 <pchiusano> copumpkin: a set of combinators, I think
14:13:07 <ddarius> copumpkin: You'd never make it as a logic programmer.
14:13:32 <copumpkin> ddarius: :(
14:13:56 <mornfall> Prolog: exponential by default? :)
14:14:57 <pchiusano> like you could specify a disjoint grouping with just an Eq b => a -> b
14:15:15 <pchiusano> b is the bin label
14:15:50 <pchiusano> if you want to allow an item to be put in multiple bins, you could provide an Eq b => a -> [b]
14:15:56 <copumpkin> makes sense
14:17:27 <copumpkin> pchiusano: it almost seems worth calling it groupBy, except the name is already taken :)
14:17:35 <copumpkin> collectBy maybe?
14:18:22 <pchiusano> copumpkin: well, another implementation might be to provide a [a -> Boolean]
14:19:37 <ddarius> pchiusano: Sounds like some topological concept might be relevant.  In fact, it sounds much like a topology.
14:19:37 <pchiusano> I'm thinking of this as a GADT where each of these is a case
14:19:49 <pchiusano> so I need a name for the datatype as a whole
14:20:12 <pchiusano> not just for some specific strategy
14:20:22 <pchiusano> for doing the splitting
14:20:37 <jmcarthur> where each of what is the case?
14:20:43 <copumpkin> maybe just call it classify?
14:20:47 <jmcarthur> each bin?
14:20:48 <copumpkin> or is that too general
14:21:15 <pchiusano> copumpkin: actually, I kind of like classify
14:22:22 <pchiusano> jmcarthur: each of a -> b, a -> [b], [a -> Boolean], ...
14:22:55 <pchiusano> each can be used to provide a [a] -> [[a]]
14:23:27 <jmcarthur> ah i see
14:28:44 <pchiusano> okay, Classify it is!!
14:28:59 <copumpkin> :)
14:29:02 <copumpkin> yay
14:29:48 <jmcarthur> pchiusano: why a GADT? each of those things have something in common, but i bet there could be more "constructors" than just the ones you think of in advance. perhaps it could be more generally a type class with an associated data type?
14:29:57 <copumpkin> another alternative is to call it hypergraph :P
14:30:02 <`Zerax`> @type Test.QuickCheck.classify
14:30:03 <lambdabot> forall prop. (Testable prop) => Bool -> String -> prop -> Property
14:30:16 <copumpkin> not sure hypergraph would be very informative though
14:30:17 <LateNight> Q:(Newbie) I like to convert a file into a large Integer, where to start?
14:30:36 <ezyang> LateNight: What kind of encoding is the file? 
14:30:38 <copumpkin> LateNight: by what encoding?
14:30:40 <Heffalump> a whole file into a single large number?
14:31:04 <LateNight> ezyang: No encoding just playing with Haskell and Perl to convert any file into BigInt's
14:31:07 <copumpkin> There's a function for that, but it's in GMP and is not bound by GHC
14:31:15 <copumpkin> LateNight: it has to have an encoding! :P
14:31:19 <mauke> LateNight: you must have an encoding
14:31:22 <copumpkin> data without interpretation is meaningless
14:31:38 <jmcarthur> LateNight: is it a file containing a big number as text, or are you wanting to interpret the binary data of the file as the number?
14:31:46 <pchiusano> jmcarthur: possibly... I think I need to pattern match on the instances though
14:32:08 <jmcarthur> oh?
14:32:26 <jmcarthur> i guess this has a more specific use than i imagined
14:32:41 <copumpkin> http://en.wikipedia.org/wiki/Hypergraph , just in case
14:32:46 <LateNight> jmcarthur: interpret the bin to large number, in order to regenerate any file as test
14:33:24 <jmcarthur> LateNight: if that's the purpose then why not just store the binary data? why convert to a number?
14:33:31 <LateNight> jmcarthur: compress lateron into series of large Fib's
14:33:37 <pchiusano> jmcarthur: yes...
14:34:39 <copumpkin> LateNight: not sure I'd call that compression :)
14:35:22 <LateNight> copumpkin: http://en.wikipedia.org/wiki/Fibonacci_coding
14:36:17 <copumpkin> I hate it when people write "It can be shown that X" without citations
14:36:43 <Runar> pchiusano: How is your function not traverse?
14:37:01 <copumpkin> LateNight: still don't think I'd call it compression
14:37:25 <Runar> @type Data.Traversable.traverse
14:37:26 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:37:48 <Runar> oh, the a and b don't match
14:38:55 <pchiusano> Runar: yeah, traverse is "right out"
14:39:53 <Runar> Yeah, you want to get back to a
14:40:08 <Phyx-> hi
14:42:00 <dolio> It can be shown that copumpkin is totally lame.
14:42:10 <copumpkin> lol
14:43:28 <danportin> Hmm, Ackermann coding.
14:45:27 <copumpkin> we should invent busy beaver coding!
14:45:30 <copumpkin> nobody can compute it
14:45:33 <copumpkin> but it's super awesome
14:45:49 <dolio> Sounds great.
14:46:14 <danportin> Or teach kids to do arithmetic on Turing machines.
14:46:28 <copumpkin> dolio: fine :(
14:46:40 <dolio> Don't do that. Turing machines are awful.
14:48:19 <danportin> Well, the epistemically advanced ones get typed lambda calculus.
14:49:48 <ddarius> danportin: That's non-sensical logic.
14:50:44 <danportin> Of course.
14:54:45 <ddarius> Planning a cross-country trip is tricky.
14:55:46 <aristid> ddarius: depending on the country.
14:55:53 <ddarius> aristid: Very much so.
14:56:12 <aristid> i think it's relatively doable in, say, Luxembourg
14:56:20 <copumpkin> lol
14:56:36 <ddarius> I would say it's absolutely doable in Luxembourg.
14:57:02 <copumpkin> I walked across luxembourg a couple of months ago
14:57:06 <bos> andorra is a bit more challenging. very steep hillsides.
14:57:52 <copumpkin> monaco or the vatican also seem quite doable
14:58:46 <ddarius> I'm pretty sure I've walked partially across America in a longer line than could be fit into Luxembourg.
15:01:10 <ddarius> bos: I walked through the Appalachians once.
15:01:16 <ddarius> (Well, twice.)
15:01:21 <aRcatan> also depends on which way you want to cross the country
15:01:34 <bos> i gather they're pretty.
15:01:40 <ddarius> bos: They are pretty.
15:02:06 * LateNight needs some sleep, cya!
15:02:16 <ddarius> By "through" though, I meant, I started on one side and ended on the other (and then, later, walked back.)
15:18:22 <ddarius> GHC is the in place for concurrency and parallelism experimentation.
15:19:01 * fryguybob just registered for the Haskell Symposium.
15:19:22 * hackagebot text-json-qq 0.2.0 - Json Quasiquatation for Haskell.  http://hackage.haskell.org/package/text-json-qq-0.2.0 (OscarFinnsson)
15:19:26 <djahandarie> "in place" out of what? All language compilers?
15:19:45 <ddarius> Yep.
15:20:32 <djahandarie> Dunno, there could be some random dude writing a compiler and coming up with some revolutionary idea over a cup of coffee
15:21:36 <ddarius> djahandarie: Some random dude's compiler is not a popular, "cool" compiler.
15:22:03 <djahandarie> Oh, so that's what you mean by "in"... okay :)
15:22:32 <djahandarie> Was thinking of http://xkcd.com/664/ for some reason
15:22:57 <BMeph> When I read this: "Learn at least a half dozen programming languages. Include one language that supports class abstractions (like Java or C++), one that supports functional abstraction (like Lisp or ML), one that supports syntactic abstraction (like Lisp), one that supports declarative specifications (like Prolog or C++ templates), one that supports coroutines (like Icon or Scheme), and one that supports parallelism (like Sisal)."
15:23:39 <aristid> haha c++ templates as a language
15:23:44 <BMeph> ... I thought to myself, "Or, learn Haskell, and learn it all!" 
15:24:04 <djahandarie> But Haskell isn't 6 languages in one ;)
15:24:12 <aristid> BMeph: my first functional language was c++ templates :P
15:24:30 <jozi> Something weird's going on with the State monad for me. Why is the type of "evalState (return initState) $ do { put s0; mapM processCmds cs" not a list (due to the mapM and "cs" being a list), but a single element?
15:24:35 <ddarius> C++ templates don't support "declarative specifications" any more (or less) than Haskell does.
15:24:47 <BMeph> djahandarie: ...or IS it?!? ;)
15:25:00 <ddarius> Haskell's type system is closer to Prolog than C++ templates.
15:25:24 <ddarius> are
15:26:15 <ddarius> Does R6RS explicitly support coroutines?
15:26:39 <jmcarthur> :t evalState
15:26:40 <lambdabot> forall s a. State s a -> s -> a
15:27:01 <aristid> :t runST
15:27:02 <lambdabot> forall a. (forall s. ST s a) -> a
15:27:07 <ddarius> Also, Forth/Factor/Joy and J/APL are missing groups.
15:27:11 <BMeph> :t initState
15:27:12 <lambdabot> Not in scope: `initState'
15:27:19 <ddarius> :t execState
15:27:20 <lambdabot> forall s a. State s a -> s -> s
15:27:21 <jmcarthur> jozi: the first argument of evalState is the state computation, not the second
15:28:23 <jmcarthur> jozi: i suspect that the compiler complained until you threw in that "return" ;)
15:28:39 <jmcarthur> so it rightly pointed out an error, but you fixed it in the wrong way :P
15:28:55 <jozi> jmcarthur: damn, that was not necessary ;-) I was debugging for 30 mins ...
15:29:11 <ddarius> It sounds like you were bugging more than debugging.
15:29:17 <jmcarthur> heh
15:29:42 <jozi> jmcarthus: I relied too much on the belief that if it typecheck's then what could possibly go wrong :P
15:30:05 <jmcarthur> the common saying about haskell is not true, sadly
15:30:26 * jozi also has bugs in speling [sic] tonight
15:36:42 <ddarius> You can make any program type check with liberal applications of unsafeCoerce, and, dammit, if it works for the C programmers it can work for us.
15:37:59 <kmc> hehe
15:38:21 <kmc> the C programmers usually have a bit better idea how their code and data are represented in-memory
15:38:58 <aristid> @let fixIt = (undefined $)
15:38:59 <lambdabot>  Defined.
15:43:27 <bobbytek> Does someone have enough patience to explain the concept of a monad to me? :)
15:43:39 <copumpkin> bobbytek: how much haskell have you had?
15:43:50 <kmc> bobbytek, prerequisites: type classes, first-class functions
15:43:50 <bobbytek> Little to none :)
15:43:53 <Botje> programmable semicolon
15:43:57 <kmc> bobbytek, monads are not a good intro topic
15:44:07 <kmc> you don't need to understand what a monad is to do IO
15:44:09 <copumpkin> bobbytek: don't jump into it :P just play with haskell for a while first :)
15:44:12 <bobbytek> I am familiar with first class functions
15:44:17 <kmc> later you'll see that IO is only a small part of monads, one particular use case
15:44:23 <hiredman> as arrows are more general you should start there!
15:44:28 <kmc> hiredman, ;P
15:44:28 <jystic> @pl f fs = (fName x, MsgStruct fs)
15:44:28 <lambdabot> f = (,) (fName x) . MsgStruct
15:44:50 <JoeyA> Is there a way to force an unsafePerformIO to be re-invoked?
15:44:51 <JoeyA> I have:
15:44:52 <JoeyA> let putter = putWord64be (unsafePerformIO (random gen)) >> putter
15:45:00 <bobbytek> but isn't the concept of a monad more general than haskell?
15:45:12 <bobbytek> I thought it was a general fp concept
15:45:14 <kmc> bobbytek, sure, but that's even harder to describe
15:45:16 <mauke> bobbytek: the concept of a category is even more general
15:45:17 <lispy1> JoeyA: You're doing it wrong :)
15:45:27 <bobbytek> I understand a category... sort of 
15:45:28 <JoeyA> I'm trying various ways to improve performance
15:45:33 <kmc> bobbytek, anyway once you know enough basic Haskell you can read "Typeclassopedia" and perhaps http://haskell.org/haskellwiki/Monads_as_containers and http://haskell.org/haskellwiki/Monads_as_computation
15:45:37 <bobbytek> at least Groovy's implementation of it
15:45:43 <lispy1> JoeyA: Why do you need a random number at that point?
15:45:45 <mauke> @quote endofunctors
15:45:45 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
15:45:52 <JoeyA> (with generating a 200MB random block)
15:46:10 <JoeyA> One option I have would be to throw a dummy variable at it
15:46:11 <kmc> bobbytek, the connection between monads in category theory and in Haskell is pretty indirect
15:46:20 <kmc> the connection is there; it's not necessarily useful for writing actual code
15:46:36 <lispy1> JoeyA: Oh.  One thing you should know is that some of the random libs for Haskell are really, really slow
15:46:42 <bobbytek> is a monad some sort of isomorphic mapping?
15:46:50 <JoeyA> I'm using System.Random.Mersenne
15:46:57 <bobbytek> I vaguely remember this from algebra
15:47:06 <JoeyA> I got it to generate ByteStrings at 250MB/s with some arm twisting
15:47:07 <lispy1> JoeyA: Okay.  I don't know which ones are fast
15:47:19 <JoeyA> now I'm trying to get it to output in big endian
15:47:31 <bobbytek> that's racist
15:47:33 <aristid> JoeyA: 250 MB/s is decent :)
15:47:45 <JoeyA> That's about as fast as an mtwist I tried out in C was.
15:47:47 <kmc> bobbytek, a monad is, first of all, a functor from some category C to itself
15:47:56 <kmc> bobbytek, do you understand what that means?
15:47:56 <JoeyA> (though perhaps I haven't tried it out on my new computer)
15:48:15 <lispy1> JoeyA: Well, isn't your putter inside some other monad that can do IO?
15:48:22 <benmachine> @quote endofunctors.shit
15:48:22 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
15:48:25 <bobbytek> A functor in the C++ sense?
15:48:26 <bobbytek> :)
15:48:29 <kmc> bobbytek, no
15:48:33 <bobbytek> heh
15:48:36 <bobbytek> okay, you're right
15:48:37 <lispy1> JoeyA: it seems odd to me that you even need the unsafePerformIO
15:48:38 <kmc> bobbytek, i suggest you learn either more Haskell or more category theory
15:48:39 <bobbytek> this is pointless
15:48:45 <JoeyA> http://hackage.haskell.org/package/binary-0.5.0.2
15:48:45 <kmc> before you approach this advanced-level topic
15:48:49 <aristid> JoeyA: google found me this: http://hackage.haskell.org/packages/archive/binary/0.5.0.1/doc/html/Data-Binary-Put.html
15:49:01 <JoeyA> Can that cooperate with the IO monad?
15:49:03 <kmc> bobbytek, no, it's points-*free* ;)
15:49:14 <bobbytek> okay, perhaps I don't have to understand what it is, but rather what type of problems it intends to solve
15:49:18 <lispy1> JoeyA: I think cereal has better performance than binary (but I'm not sure)
15:49:32 <copumpkin> bobbytek: I wouldn't even try that yet, since monads don't inherently try to solve problems
15:49:34 <mauke> bobbytek: it's a fairly general interface with lots of different implementations
15:49:45 <copumpkin> haskell uses them to do some things that are similar in a vague manner
15:49:46 <mauke> bobbytek: so you can write some useful generic functions with it
15:49:57 <JoeyA> By the way, let putter = putWord64be (unsafePerformIO (random gen)) >> putter does produce the wrong answer efficiently.
15:50:14 <JoeyA> (about 1 second for 200MB)
15:50:16 <bobbytek> hmm, interesting
15:50:18 <aristid> JoeyA: why do you need unsafePerformIO for this?
15:50:29 <bobbytek> I thought it was the fp answer to managing state
15:50:40 <JoeyA> Well, I don't if the Put and IO monads can cooperate.
15:50:44 <bobbytek> but I'm so imperative it hurts
15:50:55 <mauke> bobbytek: some monads manage state
15:51:03 <ddarius> @quote lax.functor
15:51:03 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
15:51:18 <bobbytek> I guess I always considered it to be an abstraction over deferred computations, where extra information can be threaded through without the computation itself needing to be aware of it
15:51:32 <bobbytek> is that not the gist?
15:51:43 <mauke> that sounds about right
15:51:49 <JoeyA> cereal and binary are the same, apparently.
15:52:01 <bobbytek> I jest
15:52:05 <JoeyA> except for naming it Builder instead of Put
15:52:15 <bobbytek> that was how someone else explained it to me :)
15:52:16 <lispy1> JoeyA: they are similar apis.
15:52:22 <JoeyA> The source code is almost identical in Builder
15:52:32 <JoeyA> http://hackage.haskell.org/packages/archive/cereal/0.3.0.0/doc/html/src/Data-Serialize-Builder.html#putWord64host
15:52:36 <JoeyA> Notice how it's vastly different from:
15:52:59 <JoeyA> http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/src/Data-Binary-Builder.html#putWord64host
15:54:31 <lispy1> JoeyA: my hunch is that you could easily remove the unsafePerformIO if you restructured your code a bit, but I can't really suggest anything from that one liner :)
15:55:15 <JoeyA> Well, to generate with System.Random.Mersenne, I need to use random gen, where gen <- newMTGen (Just 0)
15:55:31 <JoeyA> which is an IO action yielding a thing (in my case, Word64)
15:56:00 <JoeyA> However, Data.Binary operates in a different monad which doesn't seem compatible with IO.
15:56:07 <jystic> @pl wrap c v = (fName x, c v)
15:56:07 <lambdabot> wrap = ((,) (fName x) .)
15:56:12 <aristid> every monad is compatible with IO
15:56:13 <lispy1> JoeyA: Well, randoms is IO [a]
15:56:29 <lispy1> JoeyA: Is that a lazy list?
15:56:42 <lispy1> ah yeah, infinite list
15:56:45 <jadrian> small semantics question, is there a categorical construction for (finite) lists? 
15:56:57 <JoeyA> hmm, I'll try it
15:56:58 <lispy1> JoeyA: so pass that in to your putter and just keep taking the head
15:57:19 <Cale> bobbytek: A functor in the case of Haskell is just a parametrised data type f together with a function fmap :: (a -> b) -> f a -> f b, which acts analogously to the map function on lists.
15:57:22 <JoeyA> But when I generated a list by hand, it was a major performance hit
15:57:25 <kmc> bobbytek, monads are not about state, in particular
15:57:26 <JoeyA> it took about 800% longer
15:57:37 <kmc> bobbytek, some particular monads are
15:57:59 <kmc> bobbytek, "monad" itself describes an interface only.  in Haskell if M is a monad it means you have two functions:
15:58:01 <Cale> bobbytek: That is, there's a way to apply a function to all the "elements" of the datastructure, or "results" of the computation (depending on how you want to look at it)
15:58:02 <kmc> return :: a -> M a
15:58:08 <kmc> (>>=) :: M a -> (a -> M b) -> M b
15:58:09 <lispy1> JoeyA: Interesting.  But, this is a dons library, so I suspect it wil lbe fast
15:58:28 <kmc> this is not inherently about state, or about error handling, or about parsers, or about code generation, or about concurrency, or about SAT solvers
15:58:43 <kmc> it is an interface useful for all of those
15:58:55 <kmc> and the point of giving it a name is that we can define useful, generic functions over it
15:59:00 <kmc> like the stuff in Control.Monad
15:59:00 <JoeyA> Indeed, it's 6.8 seconds
15:59:04 <JoeyA> It should be closer to 1 second
15:59:06 <JoeyA> (using randoms)
15:59:09 <kmc> such as: sequence :: [m a] -> m [a]
15:59:17 <JoeyA> so the list overhead is causing a big hit, it seems.
15:59:50 <lispy1> JoeyA: that's odd.  The implementation is actually very simple
15:59:53 <JoeyA> (I was able to achieve 240 MB/s by using Data.ByteString's unsafeCreate to write Word64 directly to chunks)
16:00:11 <lispy1> JoeyA: unsafeInterleaveIO $ do x <- random g; xs <- randoms g; return (x : xs)
16:00:19 <JoeyA> Exactly
16:00:32 <JoeyA> I wrote exactly that by hand before I noticed the randoms function.
16:00:45 <bobbytek> kmc: thanks for the explanation
16:00:57 <bobbytek> As you may have guessed, it went well over my head :)
16:01:18 <bobbytek> Which is why I appreciate your explanation even more, because you cared enough to try :)
16:01:20 <kmc> bobbytek, analogies aside, a monad is anything which implements the interface named "Monad" (and obeys some simple laws about its implementation)
16:01:48 <bobbytek> Is there a similar concept in the OO world?
16:01:52 <bobbytek> Or an approximation?
16:02:04 <copumpkin> bobbytek: it's to be expected :) way too many people hear that haskell is all about monads and come running to haskell expecting to understand it all immediately. But it's sort of like wanting to try the five point palm exploding heart technique when you first start kung fu
16:02:05 <kmc> bobbytek, i don't think it's so useful to describe "what a monad is" in informal terms.  it's anything implementing this interface; there's a lot of different kinds of monads
16:02:14 <kmc> copumpkin, ♥ your analogy
16:02:15 <copumpkin> bobbytek: there are many forms to learn before you get to that!
16:02:30 <lispy1> JoeyA: in that case, I'm not sure what to tell you.  What if you move the unsafePerformIO up a few levels?
16:02:33 <ivanm> preflex: seen Heffalump 
16:02:33 <preflex>  Heffalump was last seen on #darcs 45 minutes and 3 seconds ago, saying: any other questions? I'm disappearing soon.
16:02:36 <copumpkin> :)
16:02:52 <mauke> bobbytek: do you know what a group is in algebra?
16:02:57 <Cale> bobbytek: It's tricky to use the monad abstraction in most OO languages, because they don't quite have the right sort of polymorphism to make it convenient.
16:03:36 <p_l> or as some people pointed it out, it's more painful than useful.
16:03:38 <nrtelang> bobbytek: here's an explanation of monads that doesn't assume much algebra knowledge http://en.wikibooks.org/wiki/Haskell/Category_theory#Monads
16:03:42 <lispy1> Cale: This came up at lunch today.  Does Java have the right type of polymorphism?
16:03:43 <bobbytek> mauke: isn't it a meta concept of some sort?
16:03:51 <copumpkin> bobbytek: it's a "structure"
16:03:52 <bobbytek> It all gets so meta!
16:03:53 <Cale> bobbytek: In particular, the return function is polymorphic only in its result type, and the bind function (>>=) has two polymorphic arguments whose types have to line up properly.
16:03:55 <mauke> bobbytek: not really
16:03:58 <copumpkin> @quote analogies
16:03:58 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
16:04:06 <copumpkin> @quote analogy
16:04:07 <lambdabot> lilac says: * lilac looks forward to Cale explaining category theory by analogy to Call of Duty
16:04:09 <copumpkin> @quote analogy
16:04:09 <lambdabot> djahandarie says: I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
16:04:17 <copumpkin> @quote mmorrow analogies
16:04:17 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
16:04:20 <Cale> lispy1: Not as far as I know, though it has been a long time since I was programming in Java.
16:04:36 <kmc> bobbytek, here's a meta-question for you: what do *you* hope to get out of this line of questioning, given that you don't have the Haskell or category-theory prerequisites to understand the precise answer?
16:04:52 <Cale> bobbytek: Do you know about typeclasses?
16:04:53 <mauke> lispy1: you really want return-type-based overloading
16:04:53 <bobbytek> I guess a nugget of understanding
16:05:28 <lispy1> Couldn't you use generics to get what you want?
16:05:32 <Heffalump> and Java doesn't have higher-kinded type variables
16:05:39 <Heffalump> though Scala does
16:05:40 <djahandarie> Heh there are some damn funny quotes in lambdabot
16:05:44 <bobbytek> typeclasses: aren't these metaclasses?
16:05:47 <kmc> no
16:05:52 <lispy1> ?quote unsafePerform
16:05:52 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
16:06:00 <bobbytek> traits?
16:06:01 <lispy1> ?quote unsafe
16:06:01 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
16:06:04 * bobbytek shrugs
16:06:08 <mauke> bobbytek: they have nothing to do with OO classes
16:06:25 <kmc> unlike most languages you may know, Haskell is not a rehash of familiar OO concepts with new names
16:06:32 <bobbytek> right
16:06:39 <kmc> type classes are closer to OO interfaces than to OO classes
16:06:45 <copumpkin> bobbytek: they're sets of types that satisfy some properties
16:06:46 <bobbytek> I understand it is more about lamda calculus
16:06:49 <kmc> but i advise just learning them as a new sort of thing
16:07:01 <bobbytek> and category theory
16:07:10 <mauke> pure lambda calculus only has one type, so that's not very interesting
16:07:20 <bobbytek> the function?
16:07:22 <kmc> Haskell is not about category theory, and it's only about lambda calculus in the sense that most languages are, whether or not they admit it
16:07:27 <mauke> I don't think Haskell is about category theory but I don't know category theory
16:07:43 <bobbytek> well, some are about the turing machine
16:07:56 <mauke> I'd write the type as a@(a -> a)
16:07:56 <bobbytek> and some are about lamda calculus
16:08:03 <djahandarie> bobbytek, Haskell has nothing to do with the phrase "lambda calculus" or the phrase "category theory" anyways, it's about the actual topic, so unless you know either already it's probably not worth approaching it from that angle.
16:08:03 <kmc> saying "FooLang is based on the lambda calculus" is about as descriptive as saying "FooLang has functions and function application"
16:08:04 <bobbytek> church-turing thesis
16:08:06 <copumpkin> bobbytek: yeah, mauke makes an important point :P
16:08:14 <copumpkin> bobbytek: you don't need to be a mathematician to understand all this stuff
16:08:17 <kmc> church-turing thesis is a completely different thing
16:08:20 <copumpkin> just don't jump right in
16:08:25 <kmc> really, you're just saying unrelated terms now
16:08:43 <djahandarie> Just like kentucky fried chicken, right?
16:09:04 <Cale> bobbytek: typeclasses are a feature in Haskell and not many other programming languages
16:09:17 <Cale> bobbytek: (Clean has some support, that's about it.)
16:09:52 <Cale> bobbytek: They're somewhat related to Java's interfaces, but generalise them quite a lot
16:10:46 <Cale> bobbytek: Are you familiar with parametric polymorphism at all? (Type variables)
16:10:53 <Cale> length :: [a] -> Int
16:10:56 <bobbytek> yes, kinda
16:11:00 <bobbytek> from c++ templates
16:11:01 <noteventime> Aren't scala traits with implicit defs something like type classes too?
16:11:07 <Cale> Says that length takes a list of values of any type a, and produces an Int
16:11:16 <Cale> and  map :: (a -> b) -> [a] -> [b]
16:11:34 <Cale> says that map takes any function (of type a -> b), and a list of values of type a, and produces a list of values of type b
16:11:43 <mauke> template<typename a> Int length(a);
16:12:10 <Cale> bobbytek: Okay, so now let's consider a function which sorts a list.
16:12:15 <kmc> you're not really helping my argument about "don't learn Haskell as a rehash of existing concepts" by writing Haskell in C++ syntax ;P
16:12:28 <Cale> bobbytek: A first attempt at its type might be something like  sort :: [a] -> [a]
16:12:44 <mauke> template<typename a, typename b> list<b> (map(a (b))(list<a>)); oh god
16:12:46 <noteventime> mauke: I never realised template can be read as forall :)
16:12:49 <Cale> bobbytek: We want it to take a list of values of some type a, and produce a list of values of the same type.
16:13:00 <djahandarie> Hahaha mauke
16:13:11 <Cale> bobbytek: However, there are lots of types for which there's no reasonable way to define (<) and the other comparison operations
16:13:39 <Cale> bobbytek: So what we really want to do is to constrain the type variable a so that it only ranges over types where we have the ordering operations
16:13:50 <bobbytek> that is to say, they do not have a partial ordering?
16:14:00 <mauke> 'a' must implement <
16:14:03 <Cale> Yeah, or total ordering
16:14:17 <Cale> The actual type of sort in Haskell is (Ord a) => [a] -> [a]
16:14:19 <djahandarie> mauke, you're going to get on kmc's nerves here :P
16:14:24 <Cale> The Ord here is a typeclass
16:14:30 <Cale> class Ord a where
16:14:35 <Cale>   (<) :: a -> a -> Bool
16:14:39 <Cale>   ... etc. ...
16:14:56 <Cale> It defines all the comparison operations
16:15:07 <ivanm> @src Ord
16:15:08 <lambdabot> class  (Eq a) => Ord a  where
16:15:08 <lambdabot>     compare      :: a -> a -> Ordering
16:15:08 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
16:15:08 <lambdabot>     max, min         :: a -> a -> a
16:15:17 <Cale> Yeah, there's the actual definition :)
16:15:25 <mauke> djahandarie: for my next trick, I'm going to code lambda calculus with perl syntax
16:15:31 <ivanm> minimum required implementation is compare or (<=) IIRC
16:15:40 <aristid> they wanted to get something similar to type classes into c++0x. was dropped
16:15:41 <ivanm> mauke: ugh
16:15:52 <mauke> aristid: concepts?
16:15:55 <djahandarie> lol mauke, you could probably do it too
16:15:55 <aristid> mauke: yeah
16:16:06 <mauke> I didn't know they were dropped
16:16:12 <aristid> sadly
16:16:14 <djahandarie> 'could' as in 'have the mental stamina to'
16:16:26 <bobbytek> Cale: thanks for the explanation
16:16:27 <mauke> djahandarie: it's a simple mechanical translation
16:16:28 <Cale> You'll also note that it's defined as a subclass of the Eq class, which means that whenever you write an instance of Ord, you must also write an instance of Eq. (and whenever Ord appears in a constraint, it implies Eq as well)
16:16:36 <mauke> djahandarie: fortunately perl can embed LC directly
16:16:40 <bobbytek> I guess I really need to learn me a haskell
16:16:47 <copumpkin> bobbytek: it'll be super fun, I promise
16:16:48 <bobbytek> :)
16:16:50 <copumpkin> assuming you enjoy learning
16:16:51 <kmc> bobbytek, yes :)
16:16:51 <copumpkin> :P
16:16:59 <bobbytek> i do :)
16:17:00 <Cale> bobbytek: No problem... so typeclasses are a good first step to understanding what the functor and monad interfaces are about
16:17:05 <mauke> > 2 + 2
16:17:05 <lambdabot>   4
16:17:13 <kmc> bobbytek, i don't think you can get a quick idea of what Haskell is like without learning a fair bit of it
16:17:25 <Cale> bobbytek: They're just some typeclasses (along with some properties that are supposed to be true of the instances, but which aren't enforced by the compiler)
16:17:36 <bobbytek> kmc: I don't think I can do that unless I really program in it
16:17:37 <`Zerax`> It's best to learn Haskell when you don't work as a programmer, you'll be less inclined to kill yourself afterwards.
16:17:45 <Cale> class Functor f where
16:17:47 <bobbytek> What type of program should I aim to build?
16:17:51 <kmc> bobbytek, there's lots of false analogies to other languages, and a few true ones which cut really deep
16:17:52 <Cale>   fmap :: (a -> b) -> f a -> f b
16:17:54 <kmc> bobbytek, no programs to start
16:17:57 <kmc> bobbytek, just play around in ghci
16:18:12 <kmc> bobbytek, writing a whole program in Haskell is an intermediate-level topic.  it's not a quick language to pick up :)
16:18:22 <ivanm> @tell Heffalump yeah, if possible; whilst they seem to be exported implicitly as instances, it means that if you're trying to extend it with another class in another module you have to know what the actual constructor is
16:18:22 <lambdabot> Consider it noted.
16:18:26 <mauke> sub { my ($x) = @_; $x->($x) }->(sub { my ($x) = @_; $x->($x) })  # infinite loop
16:18:31 <bobbytek> i hear the learning curve is pretty steep
16:18:33 <Cale> Depends on what you consider "a whole program" :)
16:18:37 <mauke> bobbytek: main = putStr "Hello, world!\n"
16:18:49 <bobbytek> something that adds value to the end user
16:18:49 <kmc> bobbytek, there's several good tutorials now.  LYAH and RWH are often recommended
16:19:25 <kmc> learning Haskell is not instant-gratification.  neither is programming in Haskell: the language forces you to think a bit more up front than you may be used to
16:19:48 <copumpkin> bobbytek: I don't think it's painfully steep at all, but you may be used to learning little more than syntactic differences when learning new languages :P
16:19:51 <`Zerax`> In terms of books, Programming in Haskell is also a fairly good place to start.
16:19:53 <Cale> bobbytek: I think for the first while of learning Haskell, it's useful to just use ghci as your user interface, which lets you avoid dealing with IO (which is easy enough, but different from what you'll have been used to)
16:20:31 <Cale> bobbytek: You can define functions which compute things which are perhaps useful, and then try them out at the ghci prompt.
16:20:55 <mauke> Haskell's IO system is easier to understand if you already know the base language, i.e. the basic syntax, type system, data structures, functions
16:21:12 <bobbytek> sure, makes sense
16:22:14 <bobbytek> so, should I learn this before clojure and scala, or before?
16:22:16 <bobbytek> :)
16:22:21 <aristid> bobbytek: haskell first
16:22:39 <aristid> clojure and scala are not as cool. and i'm completely unbiased.
16:22:40 <bobbytek> cool
16:22:45 <bobbytek> hahah
16:22:52 <bobbytek> okay, so what about books?
16:22:58 <aristid> @where lyah
16:22:58 <bobbytek> Any tomes of intereset?
16:22:58 <lambdabot> http://www.learnyouahaskell.com/
16:23:01 <lispy1> If I were learning programming over again, I would definitely have learned Haskell sooner, but I think learning C was extremely valuable too
16:23:03 <aristid> @where rwh
16:23:03 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:23:22 <bobbytek> so I take it books are NOT the way to learn haskell?
16:23:27 <kmc> RWH is a book
16:23:30 <aristid> bobbytek: the latter is a book
16:23:34 <bobbytek> ah, my bad
16:23:37 <Cale> bobbytek: They are, though you ought to ask questions here too :)
16:23:38 <aristid> bobbytek: some books have websites now...
16:23:39 <kmc> but also free online
16:23:43 <kmc> _Programming in Haskell_ is a book
16:23:52 <aristid> @where pih
16:23:52 <lambdabot> I know nothing about pih.
16:23:58 <bobbytek> a good one?
16:24:03 <aristid> @vixen why don't you know about pih?
16:24:03 <lambdabot> because i don't see the need to
16:24:05 <bobbytek> or is RWH better for an intro?
16:24:18 <ivanm> not really
16:24:26 <ivanm> RWH is more an intermediate to advanced book
16:24:31 <Entroacceptor> the "Learn You A Haskell" website is quite nice for a beginner
16:24:36 <ivanm> but if you know how to program already it might serve as an intro
16:25:22 <djahandarie> imo you need to know how to program already to understand LYAH
16:25:38 <kmc> bobbytek, if you have the persistence to learn Haskell now, i suggest it.  if you want quicker results, maybe clojure
16:25:48 <djahandarie> Otherwise you'll be stopped at the first paragraph with a bunch of gobbledygook
16:25:49 <bobbytek> I have programmed in c, c++, perl, python, java, javascript, caml, eiffel, ise, to name a few
16:25:52 <Entroacceptor> but nobody completely new to programming finds Haskell as a first choice
16:26:09 <bobbytek> oh, and groovy :)
16:26:19 <djahandarie> Entroacceptor, which is a shame because it definitely makes a ton more sense than a lot of other languages
16:26:25 <bobbytek> my current fav from an imperative point of view :)
16:26:31 <ivanm> Entroacceptor: unless they're forced to learn in uni...
16:26:43 <mauke> bobbytek: do you know XmlHttpRequest and asynchronous events?
16:26:50 <djahandarie> And yeah, some uni's do Haskell for their intro courses
16:26:57 <bobbytek> mauke: heh, ya
16:26:57 <djahandarie> Although they seem to never get far into it
16:27:00 <Entroacceptor> ivanm: in which case they won't search for a website, would they?
16:27:04 <djahandarie> At least that's what I've heard
16:27:08 <mauke> bobbytek: good, because Haskell's IO is sort of like that
16:27:09 <mee> RWH is very good, IM(newbie)O
16:27:13 <bobbytek> Most js I do is actually in functional style
16:27:26 <bobbytek> asynchronous you mean?
16:27:33 <kmc> bobbytek, if you've used ocaml, some things from haskell will be more familiar
16:27:40 <djahandarie> bobbytek, not too functional hopefully because your stack will explode if it is
16:27:47 <kmc> like basic functional programming, pattern-matching and algebraic data, currying, etc.
16:27:55 <kmc> there's a lot more that is new though
16:27:56 <bobbytek> right
16:28:00 <mauke> bobbytek: you use the >>= operator to attach callbacks to actions
16:28:15 <djahandarie> Callbacks to actions... lol
16:28:16 <mauke> as in getLine >>= (\x -> ...)
16:28:27 <bobbytek> kmc: not ocaml, just basic caml
16:28:28 <djahandarie> I'm not entirely sure that's how I'd describe it
16:28:29 <Cale> bobbytek: Oh, if you've used caml, then a lot of Haskell will be somewhat familiar.
16:28:30 <mauke> or in javascript syntax: getLine >>= function (x) { ... }
16:28:36 <bobbytek> this was for school mind you
16:28:43 <mauke> and the whole program is made from that
16:28:55 <kmc> bobbytek, ok.  well the object system in ocaml is pretty irrelevant to Haskell
16:29:12 <kmc> bobbytek, so "caml" is probably just as good (which implementation did you use? ocaml or caml light?)
16:29:20 <bobbytek> I understand currying, higher order functions, folding, etc.
16:29:22 <bobbytek> basic FP
16:29:27 <aristid> djahandarie: the js people love it so much they have written a webserver where EVERYTHING is done with asynchronous callbacks to actions...
16:29:33 <bobbytek> not monads, as you know :)
16:29:35 <djahandarie> lol
16:29:40 <EvanR> yes all functions are really just callbacks
16:29:56 <EvanR> also values of type IO a are callbacks
16:29:56 <bobbytek> kmc: caml light
16:30:05 <djahandarie> Man it sure bugs me how everyone seems to know the aura surrounding monads when they come into here
16:30:20 <djahandarie> They should be introduced as nothing special and then just be like "oh hey check it out this is how IO works also"
16:30:30 <Entroacceptor> yeah
16:30:46 <djahandarie> Whoops, I just forked this into some meta-haskell teaching argument
16:30:47 <ezyang> Can you imagine a time when we didn't know what monads were? 
16:30:49 * djahandarie hits self
16:30:51 <Entroacceptor> I think they just have the wrong name, like lots of haskell
16:30:56 <EvanR> 'they are just like everything else, ignore the syntactic sugar please, and the logo'
16:31:03 <aristid> djahandarie: when IO works "other than normal", that probably automatically creates an aura of magic for the IO mechanism
16:31:07 <bobbytek> http://projects.tmorris.net/public/what-does-monad-mean/artifacts/1.1/chunk-html/index.html
16:31:13 <bobbytek> going to read this next :)
16:31:15 <bobbytek> bbiab
16:31:27 <mauke> monads don't even matter
16:31:46 * sm thinks monads are a good abstraction
16:31:46 <djahandarie> I also dislike how people often introduce the List monad first or second
16:31:54 <djahandarie> When it is seriously confusing with its recursive definition
16:32:04 <aristid> djahandarie: join = concat <- easy.
16:32:10 <EvanR> List, Maybe, and State
16:32:13 <EvanR> in that order
16:32:17 <EvanR> then everything is made clear!
16:32:20 <djahandarie> lol
16:32:24 <mauke> I'd put Maybe first
16:32:26 <ezyang> I always do Maybe first. 
16:32:36 <EvanR> i put algebraic data first
16:32:52 <ezyang> I kind of wonder if a Strict Id monad would be a good teaching vehicle. 
16:33:00 <ezyang> Kill two birds with one stone. 
16:33:14 <mauke> :t runIdentity
16:33:15 <lambdabot> forall a. Identity a -> a
16:33:15 <djahandarie> Or realize the stone is to small and get mauled to death by two birds
16:33:31 <ezyang> Oh no! 
16:33:35 <ski> ezyang : like <http://ghcmutterings.wordpress.com/2010/08/20/parallel-programming-in-haskell-with-explicit-futures/> ?
16:33:43 <ezyang> Precisely! 
16:34:01 <mauke> @src Monad Identity
16:34:01 <lambdabot> Source not found. Take a stress pill and think things over.
16:34:14 <ski> @src Identity
16:34:15 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
16:34:39 <ski> @src Identity return
16:34:40 <lambdabot> return a = Identity a
16:34:44 <ski> @src Identity (>>=)
16:34:44 <lambdabot> m >>= k  = k (runIdentity m)
16:34:52 <djahandarie> Doing something like that would only work if the person reading is very familiar with the idea of parallel computing
16:35:05 <djahandarie> Otherwise they'll get distracted or frustrated figuring that out first
16:35:58 <ezyang> Yeah, I always thought evaluation order was kind of mysterious. 
16:37:01 <djahandarie> Whoops, got distracted talking in here rather than attempting to help hackage out :P
16:37:04 <djahandarie> Stupid IRC
16:37:11 <ezyang> But it really gets to the heart of /ordering/ computations 
16:37:13 <aristid> @src Identity fmap
16:37:14 <lambdabot> fmap f m = Identity (f (runIdentity m))
16:37:24 <lispy1> ?tell dcoutts I've had my cabal preferences set to prefer base4 since we talked about it the other day; I haven't noticed a single problem yet
16:37:25 <lambdabot> Consider it noted.
16:43:41 <Cale> bobbytek: You might find that while the notation in that might be more familiar (he tries to do things in a fictitious extension of Java or C#), it *might* just be more confusing than learning Haskell's clean notation, and finding out about the monad interface afterward :)
16:46:09 <dobblego> Cale, I have had a higher success rate with the former than the latter
16:46:30 <dobblego> specifically, using the former first, then the latter is most effective
16:46:44 <Cale> Interesting.
16:47:15 <dobblego> first I must achieve the self-admission that "we can stop being baroque now -- I get it"
16:47:24 <dobblego> that's usually what it comes to
16:47:28 <Cale> The Java code looks like it would be tricky to follow because of all the syntactic noise, but maybe some people find that noise comforting.
16:47:54 <dobblego> yes they find it comforting at first, since I am not introducing any new syntax on top, then we can use better syntax
16:48:41 <Cale> Well, you're introducing some :)
16:49:02 <dobblego> well, I try to hide that so no new syntax + new concept
16:49:15 <dobblego> of course the language disallows absolutely no new syntax
16:49:22 <Cale> yeah
16:49:35 <dobblego> if it didn't we wouldn't have the need to explain monads all the time :)
16:49:51 <Cale> Because people would already be using them.
16:49:57 <dobblego> yes I think so too
16:52:04 <Cale> http://projects.tmorris.net/public/what-does-monad-mean/artifacts/1.1/chunk-html/ar01s04s06.html -- the bind here is particularly noisy :)
16:52:24 <dobblego> yeah that slide is a bit of a furfy I think
16:58:03 <T_S_> @ 2^63
16:59:08 <Cale> > 2^63
16:59:09 <lambdabot>   9223372036854775808
17:01:02 <T_S_> thx
17:01:12 <T_S_> > 2^63 ::Int
17:01:12 <lambdabot>   -9223372036854775808
17:01:29 <lispy1> > 2^63 :: Int64
17:01:30 <lambdabot>   -9223372036854775808
17:01:39 <lispy1> > 2^63 :: Word64
17:01:40 <lambdabot>   9223372036854775808
17:02:39 <EvanR> > 2^63 :: Word8
17:02:39 <lambdabot>   0
17:02:51 <EvanR> > 2^63 :: Float
17:02:52 <lambdabot>   9.2233721e18
17:03:08 <EvanR> > 2^63 :: CReal
17:03:09 <lambdabot>   9223372036854775808.0
17:03:17 <T_S_> i see. What about an Integer Overflow or Infinity on the Int Case?
17:03:40 <chrisdon`> beep
17:04:01 <T_S_> What's the biggest Word64? 
17:04:03 <c_wraith> > (maxBound :: Int) + 1
17:04:04 <lambdabot>   -9223372036854775808
17:04:11 <kmc> > maxBound :: Word64
17:04:11 <lambdabot>   18446744073709551615
17:04:16 <c_wraith> ints overflow silently
17:04:35 <c_wraith> > (maxBound :: Word64) + 1
17:04:36 <lambdabot>   0
17:04:51 <ddarius> Cale: Mercury also has type classes.
17:05:03 <lispy1> > 2^80 :: CReal
17:05:04 <lambdabot>   1208925819614629174706176.0
17:06:09 <T_S_> Anybody know a good reason for silent overflow of Ints and company?
17:06:20 <copumpkin> T_S_: how would you deal with it?
17:06:26 <ddarius> T_S_: It's what the hardware does.
17:08:02 <T_S_> I would go for something similar to floating point overflow. Infinity. 
17:08:22 <copumpkin> Ints don't contain Infinity
17:08:26 <kmc> that would slow things down, on standard hardware
17:08:30 <ddarius> This is what the Haskell 98 Report says about this by the way: "The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined; an implementation may choose error (_|_, semantically), a truncated value, or a special value such as infinity, indefinite, etc."
17:08:53 <kmc> if you want the checking, you can implement that type by wrapping Int
17:09:05 <kmc> or just use Integer which never overflows
17:09:16 <burp> and Integer is quite fast too
17:09:31 <kmc> in particular it's nearly as fast as Int within Int's range
17:10:53 <lispy1> huh, leksah has a server component?
17:10:57 <lispy1> That just seems....odd.
17:11:10 <lispy1> Leksah is an editor, right?
17:11:15 <ddarius> All your base are belong to Leksah
17:11:39 <ddarius> lispy: It's an IDE.
17:11:42 <T_S_> Interesting. Does anybody know a nicer way to enter Infinity than 1/0::Double? 
17:11:59 <ezyang> @hoogle infinity 
17:11:59 <lambdabot> No results found
17:12:04 <ezyang> @hoogle infty 
17:12:05 <lambdabot> No results found
17:12:07 <ezyang> @hoogle inf 
17:12:07 <lambdabot> Data.Data Infix :: Fixity
17:12:07 <lambdabot> Text.Parsec.Expr Infix :: ParsecT s u m (a -> a -> a) -> Assoc -> Operator s u m a
17:12:07 <lambdabot> Language.Haskell.TH.Syntax Infix :: NameIs
17:13:06 <ddarius> T_S_: The Report doesn't say that Double is IEEE so there is no necessity that it even have an "infinity" value.  So there is no standard way to say that and you probably aren't going to find anything shorter than 1/0.
17:14:06 <djahandarie> > (-1/0)
17:14:06 <ski> > read "Infinity" :: Double  -- i suppose this would be non-standard
17:14:07 <lambdabot>   -Infinity
17:14:07 <lambdabot>   Infinity
17:14:12 <djahandarie> Haha
17:14:44 <djahandarie> > -0
17:14:45 <lambdabot>   0
17:14:49 <djahandarie> I forget how to get -0
17:14:56 <djahandarie> > read "-0" :: Double
17:14:56 <lambdabot>   -0.0
17:15:01 <djahandarie> Well that works :P
17:15:35 <ddarius> > read "-0" == 0.0
17:15:36 <lambdabot>   True
17:15:46 <djahandarie> > -0 :: Double
17:15:47 <lambdabot>   -0.0
17:15:55 <djahandarie> Ah just needed to tell it to be a double
17:16:15 <aristid> > -0/0
17:16:15 <lambdabot>   NaN
17:16:30 <aristid> > 1/-0
17:16:31 <lambdabot>   Not in scope: `/-'
17:16:31 <djahandarie> I forget where that occurs normally... I think when it rounds to zero from a negative number
17:16:36 <aristid> > 1/(-0)
17:16:37 <lambdabot>   -Infinity
17:16:42 <chrisdon`> here's a speeded up video of me trying to write a program with cairo from scratch, and kinda getting there but mostly failing: http://www.youtube.com/watch?v=zxFPRdbNTHg
17:16:49 <djahandarie> > -0.100000000001 :: Float
17:16:50 <lambdabot>   -0.1
17:16:54 <djahandarie> lol oops
17:17:01 <djahandarie> In fact I'm not sure
17:17:24 <T_S_> I see. Thanks. 1/0 works for me then. 
17:18:58 <aristid> chrisdon`: you don't seem to use ghci very much?
17:19:21 * ddarius almost never uses GHCi.
17:19:53 <ivanm> ddarius: :o
17:20:05 <ivanm> what, you just write your program and hope it works?
17:20:53 <chrisdon`> aristid: I suppose so. I only used it in this video to demonstrate progressively writing a function
17:21:18 <aristid> ddarius: why not? do you have a better method?
17:21:30 <chrisdon`> method of what?
17:21:58 <ivanm> of testing your code
17:22:27 <aristid> chrisdon`: development method
17:22:54 <aristid> i also use it to see whether my new code does what i want
17:23:09 <chrisdon`> sure, I do that
17:23:35 <aristid> and when i'm not sure how to do something, i play in ghci first
17:25:01 <chrisdon`> I do this kind of thing
17:25:05 <chrisdon`> :t insertWith
17:25:06 <lambdabot> Not in scope: `insertWith'
17:25:12 <chrisdon`> :t M.insertWith
17:25:13 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
17:25:19 <chrisdon`> :t M.insertWith (\old new -> old)
17:25:20 <lambdabot> forall a k. (Ord k) => k -> a -> M.Map k a -> M.Map k a
17:25:22 <chrisdon`> :t M.insertWith (\old new -> old) 1
17:25:23 <lambdabot> forall a t. (Num t, Ord t) => a -> M.Map t a -> M.Map t a
17:25:26 <chrisdon`> :t M.insertWith (\old new -> old) 1 'c'
17:25:27 <lambdabot> forall t. (Num t, Ord t) => M.Map t Char -> M.Map t Char
17:25:30 <chrisdon`> :t M.insertWith (\old new -> old) 1 'c' (M.fromList [])
17:25:31 <lambdabot> forall t. (Num t, Ord t) => M.Map t Char
17:25:36 <chrisdon`> > M.insertWith (\old new -> old) 1 'c' (M.fromList [])
17:25:36 <lambdabot>   fromList [(1,'c')]
17:25:40 <aristid> chrisdon`: yeah, it's mostly :t actually
17:27:52 <Daos> ping
17:28:03 <chrisdone> Daos: pong!
17:28:08 <Daos> wow )
17:28:14 <Daos> Hi all! ))
17:30:25 <aristid> > M.insertWith const 1 'c' (M.fromList [])
17:30:26 <lambdabot>   fromList [(1,'c')]
17:36:59 <dom96> Is anyone familiar with mueval? what's the timelimit in ? miliseconds? I tried setting it to 750 and executing "sum [1..]" but that didn't end......
17:37:18 <ivanm> dom96: ummm.... "sum [1..]" will _never_ end
17:37:33 <ivanm> especially since due to defaulting, it will be Integer values...
17:37:50 <dom96> yes, i know. But isn't mueval meant to prevent the never ending cycle from happening?
17:38:00 <ivanm> oh, right
17:38:07 <ivanm> yeah, it's meant to time out...
17:38:09 <ivanm> *shrug*
17:38:21 <dom96> yeah, but it doesn't.
17:38:22 <ivanm> maybe ask chrisdone, since he's using mueval for tryhaskell
17:38:31 <aristid> > sum [1..]
17:38:35 <djahandarie> dom96, it needs to be running as its own process
17:38:37 <lambdabot>  Terminated
17:39:04 <dom96> djahandarie: oh...
17:39:10 <djahandarie> dom96, like "mueval --expression 'sum [1..]'"
17:39:39 <dom96> ugh.. it's telling me i have ambigous modules
17:39:40 <jozi> Is there a shorthand for "f `fmap` mapM g xs"?
17:39:44 <djahandarie> The way lambdabot does it is by forking a process like that
17:40:02 <djahandarie> imo mueval shouldn't even have a library interface because it is never used like that
17:40:57 <dom96> Any ideas how to fix this, http://gist.github.com/541533 ?
17:41:03 <jozi> I'm looking to write it in terms of a foldM.
17:41:59 <jozi> (f has "folding character".)
17:44:22 <dom96> nvm, got it working
17:44:25 <dolio> jozi: I don't think so.
17:44:27 <dom96> thanks
17:44:32 <railk> why the f is cabal so fragile? i dunno what i did but nothing compiles any more and i get fun stuff like:
17:44:32 <railk> $ cabal install --reinstall yi
17:44:32 <railk> Resolving dependencies...
17:44:32 <railk> cabal: dependencies conflict: ghc-6.12.1 requires filepath ==1.1.0.3 however
17:44:32 <railk> filepath-1.1.0.3 was excluded because ghc-6.12.1 requires filepath ==1.1.0.4
17:45:47 <jozi> dolio: hrm, still playing with the types
17:57:10 * hackagebot mwc-random 0.7.0.1 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.7.0.1 (BryanOSullivan)
18:00:03 <jozi> I got it working! "f `fmap` mapM g xs" == "foldM foldFun y0 xs" where "foldFun = \ y x -> liftM (f . (:[y])) $ g x".
18:00:26 * jozi wonders whether there is a formalization for this transformation.
18:00:54 <aristid> jozi: and that's an improvement?
18:00:56 <aristid> :t foldM
18:00:57 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
18:01:02 <aristid> @src foldM
18:01:03 <lambdabot> foldM _ a []     = return a
18:01:03 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
18:01:43 <copumpkin> omg it's fax
18:02:11 <jozi> aristid: no, just playing and trying to understand better. I guess the first version is more readable.
18:03:33 <jozi> aristid: Could be an improvement though. What if the combinator function (f) would not be linear in expense with the size of its input list? Then it will be better to combine two elements during the map already.
18:03:44 <aristid> :t \x y -> (:[y]) x
18:03:45 <lambdabot> forall a. a -> a -> [a]
18:05:11 <jozi> aristid: Also, I'm wondering whether there's an easy transformation pattern that I'm unaware of. It's intuitive that combine . map can be expressed as fold, no?
18:05:46 <aristid> jozi: yeah
18:06:03 <aristid> :t foldr (:) []
18:06:04 <lambdabot> forall a. [a] -> [a]
18:06:23 <aristid> :t \f -> foldr ((:) . f) []
18:06:24 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> [a]
18:06:46 <copumpkin> now you need to fuse your folds!
18:07:02 <aristid> fold your fuses, fuse your folds.
18:07:24 <dolio> Factor Folds for Faster Fusion.
18:07:31 <jozi> copumpkin: folds? Isn't there only fold?
18:07:41 <JoeyA> How do I tell ghc to list all rewrites applied when compiling?
18:07:48 <JoeyA> I remember you can, I just forget how.
18:07:58 <aristid> jozi: foldr and foldl and foldM are three already
18:08:21 <jozi> aristid: Ah, I thought in the example.
18:09:10 <JoeyA> I'm benchmarking my code along with code copy/pasted from Data.Binary, and I'm finding that benchmarks are just as fast with shiftR as they are with a function based on uncheckedShiftRL# (if I staged the test properly)
18:13:59 <ddarius> JoeyA: Why do you find that surprising?
18:14:36 <JoeyA> Well, binary and serial (which have very similar code) both go out of their way to use the more efficient shift.
18:14:42 <JoeyA> Is shiftR rewritten?
18:15:09 <ddarius> It's quite possible that it is an optimization that is no longer necessary.
18:15:16 <ski> @type foldl
18:15:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:15:18 <ski> @type foldr
18:15:18 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:15:21 <ski> @type foldM
18:15:22 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
18:15:23 <ski> @type \f -> foldr ((=<<) . f) . return
18:15:24 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> b -> m b) -> b -> [a] -> m b
18:16:51 <JoeyA> Anyway, is there a switch to ghc that will list rewrites it applies?
18:16:57 <ddarius> JoeyA: Yes.
18:18:36 <ddarius> I think it is -ddump-simpl-stats
18:19:06 <JoeyA> ghc --make -O2 -ddump-simpl-stats foo.hs outputs nothing
18:19:07 <ski> .. maybe that latter one ought to be called `foldrM' ?
18:19:09 <ddarius> Or maybe just -ddump-rules
18:19:30 <jozi> ski: wow! that's what I was looking for.
18:19:30 <dobblego> @type Data.Foldable.foldrM
18:19:31 <lambdabot> forall a b (m :: * -> *) (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
18:19:34 <JoeyA> That doesn't show anything either
18:19:41 <copumpkin> kmc: omg
18:19:49 <kmc> omg copumpkin
18:20:36 <JoeyA> hmm, maybe I just needed to touch the file.
18:20:41 <ski>   foldrM f b0 [    ] = return b0z
18:20:49 <ski>   foldrM f b0 (a:as) = do b <- foldrM f b0 as; f a b
18:20:57 <ski> that's a direct definition
18:20:58 <ski> cf.
18:21:00 <ski> @src foldM
18:21:01 <lambdabot> foldM _ a []     = return a
18:21:01 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
18:21:09 <dobblego> @drc Data.Foldable.foldrM
18:21:09 <lambdabot> Maybe you meant: rc src
18:21:12 <ski> (s/b0z/b0/)
18:21:12 <dobblego> @src Data.Foldable.foldrM
18:21:12 <lambdabot> Source not found. :(
18:21:15 <ddarius> JoeyA: Yeah, I'm pretty sure -ddump-simpl-stats is what you want.
18:21:39 <ddarius> JoeyA: Both print banners so they should have output even if nothing is done.
18:22:22 <ski> (possibly eliding the `return' for a little bit more generality ..)
18:22:22 <JoeyA> Okay, it worked
18:22:29 <ski> jozi : really ?
18:22:38 <JoeyA> but it's saying nothing about shiftR specifically.
18:22:49 <JoeyA> Perhaps bounds checking got beta reduced to smithereens?
18:23:02 <ddarius> JoeyA: You can look at the core.
18:23:06 <jozi> ski: why not? :)
18:23:33 <JoeyA> I don't have a powerful enough drill, and I don't think it's legal or advisable in my locality anyway.
18:23:47 <ski> jozi : i mean, did you have a use in mind for `foldrM' above ? .. or were you just looking for a comparision between the folds ?
18:25:24 <ski> (hm .. or maybe removing the `return' doesn't really buy more power in this case ..)
18:25:50 <jozi> ski: maybe I misunderstood you, but I was wondering whether there's a way to express "f `fmap` mapM g xs" above via a foldM, and I found one (albeit complicated) -- but your foldrM seems to be much simpler.
18:26:11 <ski> @type foldr :: Monad m => (a -> m b -> m b) -> m b -> ([a] -> m b)
18:26:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b -> m b) -> m b -> [a] -> m b
18:26:29 <ski> jozi : also remember that it's fine to use the usual `foldr' monadically ^
18:27:07 <ski> jozi : oh .. i'm not sure whether `foldrM' can express that
18:27:54 <JoeyA> Which option am I interested for a core dump?  cse?
18:27:55 <jozi> Yeah, but the complexity seemed to arise from having to transform the "combine . map" into one folding function for the foldM.
18:27:57 <ski> i mean, the `f' in `liftM f (mapM g xs)' is applied post-`mapM'-stage, so to speak
18:27:59 <JoeyA> prep?
18:28:04 <jozi> ski: then it got ugly :)
18:28:37 <ski> (of course, it might be fusable if you know what `f' is)
18:29:01 <jozi> ski: oh, then I really misunderstood you. I thought you suggested a better solution instead of "foldM foldFun y0 xs where foldFun = \ y x -> liftM (f . (:[y])) $ g x"
18:29:42 <ski> jozi : no, i failed grokking what that was meant to achieve :)
18:29:57 <ski> @type let foldM foldFun y0 xs where foldFun = \ y x -> liftM (f . (:[y])) $ g x in foldM
18:29:58 <lambdabot> parse error on input `where'
18:30:17 <dolio> jozi: I don't really believe that your foldM version does the same thing as the 'f `fmap` mapM ...' version in general.
18:30:37 <jozi> ski: the pasted form was just "informally" formatted. here's the original:
18:30:48 <ski> @type \f -> let foldFun = \ y x -> liftM (f . (:[y])) $ g x in foldM foldFun
18:30:49 <lambdabot> forall r b (m :: * -> *). (Monad m, Show b, SimpleReflect.FromExpr (m r)) => ([r] -> r) -> r -> [b] -> m r
18:30:50 <jozi> processCommandsState cs s0 = let foldFun = \ g c -> liftM (overGraphics . (:[g])) $ processCommandState c
18:30:50 <jozi>                              in evalState (foldM foldFun emptyGraphic cs) initialState
18:30:54 <dolio> It looks like it requires that f (x:xs) = f (x:[f xs])
18:31:48 <ski> (.. hrm, who invited `SimpleReflect' there ?)
18:32:00 <ski> oh, `g'
18:32:07 <ski> @type \f g -> let foldFun = \ y x -> liftM (f . (:[y])) $ g x in foldM foldFun
18:32:08 <lambdabot> forall r (m :: * -> *) b. (Monad m) => ([r] -> r) -> (b -> m r) -> r -> [b] -> m r
18:32:43 <jozi> dolio: actually that's true in my case.
18:33:10 <dolio> Yes, but it's false for some fs.
18:33:14 <ski> jozi : anyway, i was just pondering `foldl' : `foldr' :: `foldM' : ?
18:33:17 <jozi> dolio: I mean, true in the sense that f hold this property.
18:34:31 <ski> jozi : .. so, in that code, `f' is always applied on a list with two elements
18:34:34 <jozi> dolio: ok, then this "transformation" might only be possible if the end result can be produced incrementally, by combining two items at a time. (Note that I wrote this above.)
18:34:56 <jozi> ski: your "pondering" was interesting anyways.
18:35:19 * ski grins
18:35:21 <jozi> ski: f combines a list of elements into one of the same time.
18:35:28 <JoeyA> ddarius: Core with shiftR versus with the specialized compiler-specific stuff look almost exactly the same.
18:35:45 <jozi> same type, sorry
18:35:47 <ski> jozi : yeah, but in that piece of code, it is always applied to lists with exactly two elements
18:36:00 <JoeyA> However, a lot of the label names are different (I guess due to some hash table implementation)
18:36:10 <jozi> Yes, but not in my version using "f `fmap` mapM g xs".
18:36:21 <jozi> There it's applied to "length xs" elements.
18:36:25 <ski> right .. so i doubt it can be equivalent to that
18:36:34 <JoeyA> In conclusion, it looks like I can get rid of some of the ugliness.
18:36:35 <dolio> jozi: It's probably possible in general by building a function that will prepend elements and apply f to a given list. But I doubt that would be much better than using mapM.
18:36:37 <ski> (for all `f', i.e.)
18:37:43 <ski> jozi : possibly if you know `liftM f (mapM g xs)' is really `liftM (foldr h z) (mapM g xs)' you can do something interesting
18:38:09 <ski> (i.e. fuse)
18:38:20 <dolio> Seems likely.
18:38:21 <jozi> ski: I agree, but at least for functions f for which f (x:xs) = f (x:[f xs]) holds.
18:38:47 <ski> jozi : it is not clear to me what functions satisfy that
18:39:58 <dolio> foldr h z `liftM` mapM g xs = foldrM (\e r -> flip h r `liftM` g e) z xs
18:40:01 <dolio> I'd wager.
18:40:05 <jozi> ski: in my application this is a combinator function that overlays a list of images with vector graphics into one compound image of vector graphics.
18:40:54 <jozi> ski: so I guess it doesn't matter whether you build up the image incrementally with the old image and a new vector image, or by overlaying the whole list of vector images at once.
18:41:51 <ski> hm
18:42:10 <ski>   f2 x y = f [x,y]
18:42:15 <ski>   f (x:xs) = f (x:[f xs])
18:42:42 <ski>   f (x:[]) = f [x,f []] = f2 x (f [])
18:43:02 <ski>   f (x:xs) = f2 x (f xs)
18:43:33 <dmwit> :t foldr1
18:43:34 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
18:43:45 <dmwit> for your enjoyment
18:43:56 <ski>   z = f []
18:44:08 <ski>   f (x:xs) = f2 x (foldr f z xs)
18:44:24 <ski> er
18:44:26 <ski>   f (x:xs) = f2 x (foldr f2 z xs)
18:44:36 <ski> so
18:44:43 <ski>   f = foldr f2 z
18:44:50 <ski> if i didn't err somewhere
18:44:58 <aristid> > foldr1 min [1,2,3]
18:45:03 <lambdabot>   mueval-core: Time limit exceeded
18:45:13 <dmwit> ?undefine
18:45:24 <dmwit> > foldr1 min [1,2,3]
18:45:25 <lambdabot>   1
18:45:28 <aristid> wtf
18:45:44 <dmwit> aristid: Somebody had probably defined a diverging foldr1 or min via ?define.
18:46:03 <bremner> jump
18:46:10 <dolio> f `liftM` mapM g xs = ($[]) `liftM` foldM (\k e -> (k .) `liftM` ((:) `liftM` g e)) f xs?
18:46:48 <ski> jozi : so (assuming `f' is defined for all finite, total lists), having `forall x xs. f (x:xs) = f (x:[f xs])' appears to imply `f = foldr f2 z', with `f2' and `z' as above
18:47:28 <lispy> Isn't the Let module imported qualified?
18:47:33 <lispy> It should be if it's not
18:47:44 <ski> dmwit : .. or lambdabot was just a bit busy at the moment
18:48:00 <ski> @let lispy = "lispy"
18:48:01 <ski> > lispy
18:48:02 <lambdabot>  Defined.
18:48:04 <lambdabot>   "lispy"
18:48:14 <lispy> > L.lispy
18:48:15 <ski> > L.lispy
18:48:15 <lambdabot>   "lispy"
18:48:16 <lambdabot>   "lispy"
18:48:45 <dmwit> > dmwit
18:48:46 <lispy> ?let ski = "ski"
18:48:46 <lambdabot>   dmwit
18:48:47 <lambdabot>  Defined.
18:48:51 <dmwit> Mine's better. =)
18:49:01 <aristid> > let master = "aristid"
18:49:02 <lambdabot>   not an expression: `let master = "aristid"'
18:49:06 <lispy> > f
18:49:07 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:49:07 <lambdabot>    `SimpleReflect.FromExpr ...
18:49:08 <aristid> @let master = "aristid"
18:49:09 <lambdabot>  Defined.
18:49:13 <napping> Hey, does anyone know of a functional language with a syntax for tail calls that resembles mutation/loops?
18:49:17 <dmwit> > f dmwit
18:49:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:49:18 <lambdabot>    `GHC.Show.Show a'
18:49:18 <lambdabot>      a...
18:49:34 <dmwit> > f u :: Expr -- oh noes, the channel is turning PG-13!
18:49:34 <lispy> :t L.dmwit
18:49:35 <lambdabot>   f u
18:49:35 <lambdabot> Doc
18:49:56 <jozi> ski: hrm, that's interesting and intuitively makes sense.
18:49:56 <aristid> > f (var dmwit)
18:49:57 <lambdabot>   Couldn't match expected type `GHC.Base.String'
18:49:57 <lambdabot>         against inferred typ...
18:50:03 <lispy> > text "monkies"
18:50:04 <dmwit> > f dmwit :: Expr
18:50:04 <lambdabot>   monkies
18:50:05 <lambdabot>   f dmwit
18:51:09 <dmwit> napping: Some colleagues of mine are building a little language with some loop sugar.
18:51:21 <dmwit> napping: Why do you ask?
18:51:49 <napping> dmwit: tail recursive functions with lots of parameters which mostly don't change have bugged me for a while
18:51:56 <dmwit> I mean, I don't think they're doing anything sophisticated, there's just a very specific pattern that they support and that's it.
18:51:57 <napping> and I had some random ideas for additional sugar today
18:52:26 <napping> I was thinking more like not letting you close over pseudo-mutable variables, and then doing SSA or something
18:55:47 <ddarius> napping: http://lambda-the-ultimate.org/node/4019
18:56:41 <napping> I haven't read that one for a while
18:58:28 <copumpkin> "Actually, I like a research paper to be more like a mystery novel (with a resolution, of course). "
18:58:29 <copumpkin> ugh
18:58:44 <copumpkin> this is one of the many things wrong with authors of technical papers
18:59:46 <cch> hi, i am seeking client lib for get web page, like urllib for python, any suggest?
19:00:01 <ski> napping : well, not exactly that, but you might be interested in "named-`let'" <http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.2.4> and "foof-loop" <http://mumble.net/~campbell/scheme/foof-loop.txt> (search for `(=> <variable> <expression>)') in Scheme, and also the paper "The Anatomy of a Loop" <http://www.ccs.neu.edu/home/shivers/papers/loop.p(s|df)> by Olin Shivers
19:00:31 <pickles> anyone know offhand what i need to import to get foldl' ?
19:00:55 <kmc> @hoogle foldl'
19:00:55 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
19:00:56 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
19:00:56 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
19:01:07 <djahandarie> You probably want Data.List
19:01:10 <ski> napping : also, if most of the parameters doesn't change (and you can group them such that you get a total order relating the groups), then you can define local functions
19:01:12 <napping> ski: Shiver's paper I've seen
19:01:21 <pickles> ah yesh thx!
19:01:22 <aristid> pickles: so you can remember it: foldl' operates on lists, so it's probably in Data.List
19:01:24 <pickles> *yes
19:01:27 <djahandarie> Data.Foldable is slightly more general
19:01:35 <ski>   evalWithEnv env = eval
19:01:35 <pickles> mm
19:01:38 <ski>     where
19:01:45 <aristid> @src foldl'
19:01:46 <lambdabot> foldl' f a []     = a
19:01:46 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:01:46 <pickles> tyvm
19:01:51 <napping> I'm thinking of cases kind of like a list of commands, where you pattern match on successive list items
19:01:54 <ski>     eval (Const c) = Val c
19:02:02 <napping> and perhaps keep a count of nested parentheses and some other stuff
19:02:12 <pickles> yeah, i saw a haskell wiki on hte differences between the folds
19:02:21 <copumpkin> @ask zygoloid did you manage to find anything about mmorrow?
19:02:21 <lambdabot> Consider it noted.
19:02:26 <ski>     eval (Let i e0 e1) = evalWithEnv (extendEnv i (eval e0) env) e1
19:02:26 <pickles> and i remembered their properties, i just forgot what lib that one was in
19:02:29 <ski>     &c.
19:02:35 <napping> I'm not sure how to use nested functions for that
19:02:59 <ski> napping : do you have an example loop ?
19:03:15 <ski> (and btw, tail-recursion is orthogonal to this idea)
19:03:17 <napping> not a recent example, but perhaps an S-expression parser
19:03:31 <ski> maybe "remberUptoLast" ?
19:03:43 * ski seems to recall that could be written in such a style
19:03:46 <napping> say, data S = Atom String | Form [S]
19:04:15 <napping> and a worker like [[S]] -> [S] -> String -> String -> S
19:04:49 <napping> keeping enclosing contexts, predecessors in the current form, letters in the current word, and the tail of the input
19:05:30 * ski doesn't immediately see how that would work
19:05:32 <napping> so, pushing at '(', popping at ')', ending the current atom at those or whitespace, that sort of thing
19:07:22 <napping> parse ctx preds word (c:cs) | isSpace c || c == '(' || c == ')' = parse ctx (Atom (reverse word):preds) "" (dropWhile isSpace c)
19:07:53 <cch> i find Network.Curl, is there alternative?
19:08:18 <napping> parse (level:ctx) preds "" (')':cs) = parse ctx (Form (reverse preds):level) "" cs
19:08:21 <napping> etc
19:08:45 <ski> so, `remberUptoLast a as' gives the shortest prefix of `as' such that the corresponding suffix doesn't contain an occurance of `a'
19:08:57 <copumpkin> napping: it's a monad!
19:09:11 <copumpkin> its name is wily
19:09:13 <copumpkin> willy
19:09:43 <napping> for a more useful exaple, see Olaf Chitil's pretty printers
19:10:13 <copumpkin> after my valuable contribution, I shall return to my cave
19:11:48 <ski> or, hm .. that doesn't seem right
19:12:20 <ski> probably `remberUptoLast a as' was the longest suffix of `as' which doesn't contain an occurance of `a'
19:12:26 <ski> > let remberUptoLast a0 = set where set as0 = loop as0 where loop [] = as0; loop (a:as) | a0 == a = set as | otherwise = loop as in remberUptoLast '*' "abc*de*fgh*ijk"
19:12:27 <lambdabot>   "ijk"
19:13:01 <ski> napping : that's one variant of using nested loops in the way i had in mind ..
19:16:28 <ski> napping : hm, so is there a total ordering on how often the parameters there change ?
19:17:08 <ski> (i.e. such that for each recursive call, if one parameter changes, then all previous ones also change)
19:18:27 <JHaskly> Hi, can anyone tell me why this code: http://pastie.org/1105327 produces this error: http://pastie.org/1105330 ?
19:19:06 <dmwit> yes!
19:19:14 <copumpkin> JHaskly: it doesn't know what can be both sqrt'd and mod'd
19:19:21 <dmwit> It says that because there are many valid types for that list, and it has to pick one to decide how to show the list.
19:19:35 <ski> napping : <http://www.cs.kent.ac.uk/people/staff/oc/Software/FPretty.hs> ?
19:19:46 <napping> does that actually work?
19:19:51 <napping> it was buggy a while ago
19:19:52 <JHaskly> I tried to add a type declaration, but it kept giving me messages
19:20:02 <dmwit> And well it should. =)
19:20:04 <ski> napping : i've never seen it before so .. :)
19:20:07 <dmwit> But it will give you more helpful messages.
19:20:21 <JHaskly> Hmm.. I'll take another look at it
19:20:29 <dmwit> JHaskly: how about
19:20:39 <dmwit> floor . sqrt . fromIntegral $ n, instead? ;-)
19:20:53 <JHaskly> Haha, I just tried that
19:20:56 <JHaskly> And it works :)
19:20:58 <JHaskly> Thanks
19:25:14 <pickles> hm, it's claiming non-exhausive pattern and i'm having trouble seeing why
19:25:15 <pickles> pushConstant v Nothing = Just $ v:[]
19:25:21 <pickles> pushconstant v (Just vs) = Just $ v:vs
19:25:41 <EvanR> no sane reason to use $ there
19:25:50 <pickles> thx
19:26:05 <pickles> sometimes it complains at me so i just put it in by default
19:26:13 <EvanR> well youd need ( )
19:26:26 <ski> pickles : s/pushconstant/pushConstant/
19:26:39 <pickles> ah
19:26:45 <pickles> why lower case ski?
19:27:06 <ski> don't ask me :)
19:27:13 <pickles> lol
19:27:19 <pickles> gah
19:27:21 <pickles> missed that
19:27:22 <pickles> thx
19:27:47 <pickles> i thot u were facetiously telling me to make it lower case
19:27:50 <pickles> awesome, thx!
19:27:58 <ski> (and, imo it's nicer to not use `$', ther)
19:28:35 <aristid> pickles: s/a/b/ replaces a by b, not the other way around, and also either way, what matters is that it's consistent
19:28:35 <pickles> i'll start doing that now on
19:28:52 <pickles> yeah, im not a vim user so i had the order on that screwed up
19:29:09 * ski writes brackets by default, and only writes `$' if it improves readability (which it only does in a few cases)
19:29:10 <pickles> so is $ an operator?
19:29:14 <ski> yes
19:29:16 <kmc> @src ($)
19:29:17 <lambdabot> f $ x = f x
19:29:18 <ski> @src ($)
19:29:18 <lambdabot> f $ x = f x
19:29:19 <aristid> :t ($)
19:29:20 <lambdabot> forall a b. (a -> b) -> a -> b
19:29:29 <ski>   infixr 0 $
19:29:31 <pickles> ah
19:29:35 <kmc> <pickles> sometimes it complains at me so i just put it in by default  <--- :( :( :( :(
19:29:43 <pickles> lol
19:29:49 <pickles> had i only known
19:29:53 * pickles hangs head in shame
19:30:08 <pickles> looks like i have some code to correct then
19:30:13 <pickles> only one file tho i think
19:30:18 <pickles> haven't been doing it for long
19:30:31 * pickles is still a haskell n00b
19:30:45 <aristid> pickles: a b $ c d works like (a b) (c d)
19:32:10 <pickles> hm
19:32:18 <cch> @help
19:32:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:32:33 <cch> list
19:32:50 <cch> @help list
19:32:50 <lambdabot> list [module|command]
19:32:50 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
19:32:50 <ski> @list
19:32:51 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:32:59 <pickles> yeah, i didn't know it was an actual operation, I thought it was a compiler niceity
19:33:07 <cch> @list
19:33:08 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:33:28 <cch> 3x :)
19:33:45 <kmc> yup it's a real operator
19:33:49 <kmc> which means you can use it in a section too
19:33:53 <kmc> > map ($ 3) [succ, pred]
19:33:54 <lambdabot>   [4,2]
19:34:02 <pickles> interesting
19:34:04 <kmc> > zipWith ($) [succ, pred] [3, 9]
19:34:05 <lambdabot>   [4,8]
19:34:06 <cch> @type map
19:34:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:34:47 <pickles> yipe, i was just using it willy-nilly too
19:35:17 <cch> @karma ski
19:35:17 <lambdabot> ski has a karma of 9
19:36:32 <cch> @quote ski
19:36:32 <lambdabot> ski says: death or glory !
19:37:19 <pickles> yipe, bedtime
19:37:28 <pickles> you all win 1 INTERNET for your help
19:37:29 <pickles> thx!
19:38:12 <ski> @quote AlanPerlis
19:38:12 <lambdabot> AlanPerlis says: A LISP programmer knows the value of everything, but the cost of nothing.
19:38:56 <p_l> ... I'd say it applies to Haskellers as well :P
19:39:27 <pickles> tho in haskell it would be the cost of Nothing
19:40:12 * applicative doesn't know the cost of Nothing, he doesn't even care...
19:41:20 <ski> > let complRemberUptoLast a0 = set id where set k0 = loop id where loop _ [] = k0 []; loop k (a:as) | a0 == a = set (k0 . k . (a:)) as | otherwise = loop (k . (a:)) as in complRemberUptoLast '*' "abc*de*fgh*ijk"
19:41:21 <lambdabot>   "abc*de*fgh*"
19:41:34 <aristid> applicative: because it is not a Just cause?
19:41:37 <ski> hm, can that be written more nicely ?
19:41:56 <aristid> :t set
19:41:57 <lambdabot> Not in scope: `set'
19:42:10 <ski> aristid : it's locally defined
19:42:23 <ski> compare that definition with
19:42:37 <ski> > let remberUptoLast a0 = set where set as0 = loop as0 where loop [] = as0; loop (a:as) | a0 == a = set as | otherwise = loop as in remberUptoLast '*' "abc*de*fgh*ijk"
19:42:37 <lambdabot>   "ijk"
19:42:40 * applicative figures the cost of Nothing can't be much, its the Just things that might strain the compiler...
19:42:53 <ski> (which is probably easier to understand)
19:43:33 <aristid> @hoogle find
19:43:34 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
19:43:34 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
19:43:34 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
19:43:55 <aristid> :t \x -> find (== x)
19:43:56 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe a
19:44:09 <pickles> mmk, off to bed
19:44:13 <pickles> thx again for the help guys
19:44:18 <ski> yw
19:45:33 <ski> (aristid : .. any suggestion ?)
19:46:23 <cch> i am seeking lib for get web page, any suggest?
19:46:30 <kmc> cch, did you check Hackage
19:46:37 <kmc> there are a lot of HTTP libraries
19:46:41 <cch> i find network.curl and network.http
19:46:43 <kmc> i believe the one called "HTTP" comes with the Haskell Platform
19:48:02 <cch> thk, curl that i try not that friendly to me
19:48:10 <cch> i will try HTTP
19:49:00 <ddarius> copumpkin: I don't think Steven Obua is representative of technical paper authors.
19:49:47 <aristid> ski: no:/
19:52:37 <darrint> Working with Text.XML.Light, I just defined let atr = flip add_attribute. Is there a more general operator I should be using?
19:54:01 <ski> (i suppose one could factor out the guards into a conditional)
19:56:20 <ski> > let complRemberUptoLast a0 = set id where set k0 = loop id where loop _ [] = k0 []; loop k (a:as) = (if a0 == a then set . (k0 .) else loop) (k . (a:)) as in complRemberUptoLast '*' "abc*de*fgh*ijk"
19:56:21 <lambdabot>   "abc*de*fgh*"
19:58:32 <aristid> :t let complRemberUptoLast a0 = set id where set k0 = loop id where loop _ [] = k0 []; loop k (a:as) = (if a0 == a then set . (k0 .) else loop) (k . (a:)) as in (compleRemberUptoLast, set, loop)
19:58:33 <lambdabot> Not in scope: `compleRemberUptoLast'
19:58:34 <lambdabot> Not in scope: `set'
19:59:04 <aristid> :t let complRemberUptoLast a0 = set id; set k0 = loop id; loop _ [] = k0 []; loop k (a:as) = (if a0 == a then set . (k0 .) else loop) (k . (a:)) as in (complRemberUptoLast, set, loop)
19:59:05 <lambdabot> Not in scope: `k0'
19:59:05 <lambdabot> Not in scope: `a0'
19:59:05 <lambdabot> Not in scope: `k0'
19:59:23 <aristid> oh, right
19:59:56 <ddarius> > ei eI o
19:59:57 <lambdabot>   Not in scope: `ei'Not in scope: `eI'
20:00:09 <ddarius> Foiled.
20:00:22 <ddarius> Ah, :t
20:00:45 <aristid> ddarius: are you mocking me? ;P
20:01:19 <ski> > let complRemberUptoLast :: forall a. Eq a => a -> [a] -> [a]; complRemberUptoLast a0 = set id where set :: forall o. ([a] -> o) -> ([a] -> o); set k0 = loop id where loop :: ([a] -> [a]) -> ([a] -> o); loop _ [] = k0 []; loop k (a:as) = (if a0 == a then set . (k0 .) else loop) (k . (a:)) as in complRemberUptoLast '*' "abc*de*fgh*ijk"
20:01:19 <lambdabot>   "abc*de*fgh*"
20:01:24 <ski> aristid : ^
20:01:46 <ddarius> What's with the type signatures?
20:01:52 <lispy> how's it going?
20:02:07 <ski> ddarius : aristid wanted to know the types of the local functions
20:02:22 <aristid> ya
20:02:34 <ski> > let remberUptoLast :: forall a. Eq a => a -> [a] -> [a]; remberUptoLast a0 = set where set :: [a] -> [a]; set as0 = loop as0 where loop :: [a] -> [a]; loop [] = as0; loop (a:as) | a0 == a = set as | otherwise = loop as in remberUptoLast '*' "abc*de*fgh*ijk"
20:02:35 <lambdabot>   "ijk"
20:03:27 * ddarius considers trying to shove a Chameleon type debugger thing into GHC.
20:03:37 <ddarius> GHCi specifically.
20:04:28 * ddarius wonders when Notes get stripped.
20:04:39 <ski> (the type of `loop' inside `complRemberUptoLast' suggests that it is effectively using composably continuations)
20:05:09 * ddarius considers abusing the heck out of various internal systems of GHC(i) to get a type debugger effect quickly.
20:07:13 <ddarius> ski: Or that it is using a functional representation of lists.
20:07:39 <applicative> darrint, there is often the expedient of using a section instead of flip
20:07:51 <applicative> > ( 1 ^ 6 , 6 ^ 1 , flip (^) 1 6 , (^ 1) 6 )
20:07:51 <lambdabot>   (1,6,6,6)
20:07:54 <ski> well, it's not quite `forall o. (a -> o -> o) -> (o -> o)', now
20:08:22 <ski> (hm .. though possibly you were thinking of diff-lists)
20:09:05 * ski didn't think of it from that pov
20:09:11 <ddarius> ski: I was, but I don't like the name "difference lists" for that pattern.  It is completely unrelated to difference lists from logic languages.
20:09:30 <applicative> darrint, so occasionally you can do things like the last two in this tuple --
20:09:31 <applicative> > let add_attr = (^) in ( 1 `add_attr` 6 , 6 `add_attr` 1 , flip add_attr 1 6 , (`add_attr` 1) 6 , map (`add_attr` 1) [2,3,4])
20:09:32 <lambdabot>   (1,6,6,6,[2,3,4])
20:09:43 <ski> yeah .. i hestitated before calling them that; but couldn't come up with a better name
20:11:14 <ski> (it is similar (sortof) to the construction part of difference lists in logic programming, i'd say)
20:12:15 <ddarius> I wouldn't say so.  One is a function the other is a pair of (logic variables holding) lists.
20:12:30 <ski> that's just a question of representation
20:13:15 <ddarius> ski: xs . xs is not (naturally) representable using Prolog difference lists, while head xs is not easily representable using Haskell "difference" lists.
20:13:16 <ski> both give O(1) appending
20:13:28 <ddarius> ski: One's persistent, one is not.
20:13:35 <ski> (while it is true that difference lists have to be used affinely)
20:13:36 <ski> yes
20:13:45 <ski> (difference lists in LP, i.e.)
20:15:00 <ski> so, i grant that they don't allow the exact same operations .. but i think there's quite a bit of overlap
20:15:30 <ddarius> I don't see any overlap other than they are both solutions to having fast appends.
20:15:48 <ski> (btw, for implementing "head" for LP diff-lists, you really have to keep track of the length separatedly, in case you never "ground" the diff-list)
20:16:37 <napping> doesn't head (xs []) work?
20:17:08 <napping> I guess it could be a bit slow
20:17:11 <ddarius> napping: Yes, but that just converts the "difference" list to a normal list and then uses head and it destroys the point of the difference list.
20:17:15 <ddarius> +"s
20:18:39 <ski> napping : the problem being that given `dl_empty(Xs - Xs). dl_cons(X,Xs - Ys,[X|Xs] - Ys).' then `dl_empty(DL),dl_cons(X,_,DL)' succeeds
20:21:54 * hackagebot enumerator 0.2 - Implementation of Oleg Kiselyov's left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.2 (JohnMillikin)
20:25:57 <JoeyA> It worked!  The de-bigulator worked!
20:26:29 * JoeyA piped 200MB of mersenne twister output through ssh and crc32'd it on another, and the test passed.
20:27:09 <JoeyA> The mersenne-random module doesn't compile on powerpc, so I had to relegate the generation part to another machine.
20:27:47 <ddarius> Now all you have to do is start on the formal proof of correctness.
20:29:12 <luite> is there a computer algebra program that can quickly multiply 20-variable polynomials with a few million terms?
20:30:00 <JoeyA> It says "Prologue junk?: 	.type	s2t1_ret, @function" when I try to build the mersenne-random module on Fedora 12 PowerPC, ghc 6.10.4
20:30:13 <JoeyA> I'm compiling the latest in hopes that the problem magically went away.
20:31:14 <luite> JoeyA: have you tried vector-random by the way? is it too slow? or is the data type wrong?
20:32:08 <JoeyA> Well, it's not ByteString
20:32:19 <ddarius> luite: Are there fourier transform implementations that can perform 20D FFTs of million long vectors quickly?
20:32:46 <luite> ddarius: my next question would be "which one" ;p
20:33:18 <JoeyA> Does GHC have a "make check" ?
20:33:20 <napping> ddarius: yes
20:33:27 <JoeyA> As in, a make rule for running test cases?
20:33:35 <lispy> mauke: does preflex doing public logging?
20:34:12 <napping> ddarius: at least if that's millions of points total, rather than on each axis
20:35:05 <ddarius> Yeah, you should get 20nlog(n) where n is on the order of a million.
20:36:06 <ddarius> Roughly 400 million "steps"
20:38:43 <ddarius> I would say on a gigahertz processor you are looking at a few seconds or a few minutes at the absolute fastest.
20:39:07 <ddarius> (of CPU time, not real time)
20:50:17 <Axman6> @src pow
20:50:17 <lambdabot> Source not found. Just try something else.
20:50:21 <Axman6> @src (^)
20:50:21 <lambdabot> x ^ 0            =  1
20:50:21 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
20:50:21 <lambdabot>   where f _ 0 y = y
20:50:21 <lambdabot>         f x n y = g x n
20:50:21 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
20:50:22 <Axman6> even
20:50:23 <lambdabot>                       | otherwise = f x (n-1) (x*y)
20:50:25 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
20:57:36 * FunctorSalad made a hoogle database from 584 packages+hoogle defaults         code.haskell.org/~daniels/default.hoo.gz
20:58:16 <FunctorSalad> 7.4M gzipped 21M unzipped
20:58:49 <FunctorSalad> I guess this is of general enough interest to post on one of the mailing lists
21:02:34 <mauke> lispy: no
21:05:01 <FunctorSalad> (but now good night :))
21:08:53 <luite> hmm, the sparseness of my data is probably an issue
22:08:29 <ManateeLazyCat> Which random package do you use? Someone compare?
22:09:10 <ManateeLazyCat> I want got a random number from specify range......
22:13:13 * ManateeLazyCat Maybe current time with `mod` is enough
22:14:02 <copumpkin> depends what you're doing with it
22:14:22 <JoeyA> import System.Random
22:14:34 <JoeyA> n <- randomRIO (0,100)
22:14:35 <ManateeLazyCat> copumpkin: I want get a random number of rang that give next song from current play list
22:14:43 <JoeyA> (will return a number from 0 to 100 inclusive)
22:15:10 <ManateeLazyCat> JoeyA: It's random enough?
22:15:33 <JoeyA> It's not super-random, but it should be good enough
22:15:41 <JoeyA> It changes per run of the program
22:17:23 <ManateeLazyCat> JoeyA: Thanks, i think it's enough for my need.
22:18:24 <JoeyA> Here's a script I wrote in Haskell to select a random file in the current directory:  http://codepad.org/nsKt1vXu
22:18:33 <JoeyA> You'll need to cabal install a couple of modules to use it.
22:20:10 <JoeyA> ( cabal install filepath directory should be enough to run it )
22:21:31 <ManateeLazyCat> JoeyA: Thanks, but it's overkill to me, i just need random number from range.
22:21:46 <ManateeLazyCat> JoeyA: BTW, I use gio as my file/directory library
22:22:23 <JoeyA> ah, cool
22:22:53 <ManateeLazyCat> JoeyA: GIO is cross-platform file operation library, base on glib.
22:23:06 <JoeyA> anyway, randomRIO (0,9) is an action randomly selecting 0 thru 9 inclusive
22:23:08 <ManateeLazyCat> JoeyA: You can got same behaviour on UNIX or Windows.
22:23:27 <ManateeLazyCat> JoeyA: Yes, randomRIO is enough for me, thanks!
22:24:03 <JoeyA> Hmm, does GIO Haskell binding implement the GDrive interface?
22:24:12 <ManateeLazyCat> JoeyA: Yes.
22:24:14 <JoeyA> (which lets you find out when drives are mounted)
22:24:17 <JoeyA> Coolness
22:24:49 <ManateeLazyCat> JoeyA: I have finish those at https://patch-tag.com/r/AndyStewart/gio-branch/home
22:25:02 <ManateeLazyCat> JoeyA: Now, i'm working on merge gio-branch code to gtk2hs main repository.
22:25:28 <JoeyA> ah
22:25:53 <JoeyA> I wonder if GIO lets you read/write directly to disk memory (rather than the filesystem)
22:25:55 <ManateeLazyCat> JoeyA: I maybe can finish this job in next week, then i can release gio-0.12.0
22:26:18 <JoeyA> Or do you just have to use /dev/sdb (in Linux) ?
22:26:31 <JoeyA> (that's a GIO in general question, not a question about the Haskell binding)
22:26:41 <JoeyA> Anyway, cool, thanks for releasing that!
22:28:47 <p_l> JoeyA: on systems where raw disk access is possible through normal file API, GIO is probably capable of it
22:29:11 <p_l> which includes both Unix and Windows
22:30:27 <ManateeLazyCat> p_l: Yes, it's cross-platform APIs, Including icon theme, file operation, virtual filesystem, and many others. You just need same APIs can works on UNIX and Windows.
22:31:09 <p_l> ManateeLazyCat: Well, on both Unix and NT disk drives are accessible through normal file I/O :)
22:32:10 <p_l> though you'll probably need to know correct device nodes
22:36:31 <ManateeLazyCat> Bye all, too busy recently. Please report any gtk2hs-0.11.2 bug to gtk2hs list, we will fix it as soon as possible, thanks! 
22:52:51 <smadge> where would I go if I wanted someone to mercilessly critique my haskell programs?
23:05:31 <dmwit> ?tell smedge You're in the right place for Haskell critiques. You just have to hang around a bit longer after you ask your questions, especially late at (USA's) night.
23:05:31 <lambdabot> Consider it noted.
23:06:32 <Lemmih> And early (Europe's) morning.
23:07:28 <Axman6> dmwit: he's still around
23:07:42 <Axman6> smadge: if you paste your code, people will look at it
23:08:37 <dmwit> Oh, huh! I thought he was gone because it wasn't tab-completing, but I was just misspelling it.
23:11:29 <smadge> Axman6 and others, thanks. I'll post sometime in the future, but not tonight.
23:22:41 <Peasley> hey, what does this mean? 'back.hs:9:13: Not in scope: type constructor or class `Mun''
23:23:28 <Peasley> I defined class Est a where lel :: a -> a, and then instance of that type class:    instance Est Mun where lel b = b + 1
23:26:12 <dmwit> It means you haven't defined a type named "Mun", just like it says.
23:26:30 <dmwit> Just so you know, "class" means something very different in Haskell than it does in most OOP languages.
23:26:46 <Peasley> dmwit yeah im noticing it
23:26:47 <dmwit> It's closer to the mathematical idea of a "class" being a bunch of related things.
23:27:12 <dmwit> In Haskell, a class is a set of types that have a common interface.
23:27:42 <dmwit> To begin with, you won't go too far wrong if you think "interface" when you write "class" and think "implements" when you write "instance" (assuming you're coming from Java).
23:29:24 <Peasley> dmwit, so I have to define Mun, can I either use the 'type' trick which basically says that type Mun = Bool, or do I need to use existing types(such as Char, Bool)? also, im sure my book will eventually describe this but you can define your own user types, right?
23:31:11 <dmwit> You can declare an instance for existing types, if you like.
23:31:24 <dmwit> e.g. instance Est Bool where
