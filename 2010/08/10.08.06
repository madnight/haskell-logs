00:14:33 <Wooga> hello, is there any way to make layout indentation in vim like this: http://paste2.org/p/940499 (pipe is a cursor)
00:15:12 <Wooga> ?
00:21:27 <Wooga> maybe that one would be more clear: http://paste2.org/p/940505
00:27:39 <zenzike> Cale: Yup, the Tensor package is from OpenGL, which I'm using, and it seems silly to create another Vector data type when one is already provided. It's just a bit thin on the ground in terms of supporting functions.
00:29:03 <ezyang> @pl flip const 
00:29:04 <lambdabot> const id
00:29:07 <ezyang> bah. 
00:30:21 <Kaidelong> @upl const id
00:30:21 <lambdabot> Maybe you meant: pl unpl url
00:30:23 <wagle> @pl @pl
00:30:23 <lambdabot> (line 1, column 1):
00:30:23 <lambdabot> unexpected "@"
00:30:23 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
00:30:26 <Kaidelong> @unpl const id
00:30:26 <lambdabot> (\ _ b -> b)
00:30:28 <wagle> bah
00:31:00 <Kaidelong> @pl (\ _ b -> b)
00:31:00 <lambdabot> const id
00:31:14 <FunctorSalad> Wooga: I'm a bit of a vim newbie myself, but apparently you can supply a function in the 'indentexpr' setting that maps a line to the level it ought to be indented
00:31:44 <FunctorSalad> though I'm not sure how to do that well without resorting to a serious haskell parser
00:32:07 <Kaidelong> does pl have idempotence with unpl?
00:32:08 <FunctorSalad> (hmm why not, actually?)
00:32:27 <Kaidelong> as in
00:32:37 <Kaidelong> pl . unpl . pl == pl
00:32:47 <Kaidelong> and vice versa
00:33:09 <FunctorSalad> omg triangle equality
00:33:15 <Kaidelong> or are there examples that will diverge or will not immediately converge?
00:33:16 <FunctorSalad> ;)
00:33:56 <Kaidelong> I imagine if there are you could consider it a bug
00:36:04 <FunctorSalad> Kaidelong: hmm I doubt anyone can answer that except *maybe* the author
00:36:15 <FunctorSalad> or someone who studied the code
00:36:26 <Kaidelong> hmm
00:36:49 <FunctorSalad> since you're asking about a particular implementation, unless I'm missing the simple property that defines 'pl'
00:39:32 <FunctorSalad> (there is a rather arbitrary choice of primitives, and are not independent)
00:39:57 <FunctorSalad> (maybe there is some 'simplest' solution in terms of the primitives it uses though)
00:41:03 <FunctorSalad> @pl \x f -> x >>= (return . f)
00:41:04 <lambdabot> (. (return .)) . (>>=)
00:41:34 <FunctorSalad> hmm or maybe they are more independent than I thought... thought it'd return liftM
00:41:57 <FunctorSalad> @pl \f x -> x >>= (return . f)
00:41:57 <lambdabot> fmap
00:42:04 <FunctorSalad> ok ;)
00:42:39 <FunctorSalad> @pl \x -> x >>= id
00:42:39 <lambdabot> join
00:43:28 <FunctorSalad> @pl \f g x y -> f (g x) (g y)
00:43:28 <lambdabot> join . ((flip . ((.) .)) .) . (.)
00:43:38 <FunctorSalad> @unpl on
00:43:39 <lambdabot> on
00:48:28 <FunctorSalad> hmm btw apparently hasktags --append does nothing
00:48:43 <FunctorSalad> (doesn't even try to open any file for writing)
00:52:18 <FunctorSalad> oh well, xargs --show-limits says I have 2mb per command line... should be enough to ctag my cabal source dir ;)
00:52:44 <FunctorSalad> (without --append you have to tag it all in one line)
01:06:12 <handonson> How would I write an attoparsec parser that "fails if endOfInput"?
01:10:34 <kmc> anyone have a hack for syntax highlighting in ghci?
01:11:24 <FunctorSalad> kmc: ghci | HsColour ? :F
01:11:55 <FunctorSalad> you'd probably want to modify it so it works unbufferedly
01:12:26 <kmc> wow, that actually sort of works
01:12:52 <FunctorSalad> ghci |& HsColour # less scrambled
01:14:17 <FunctorSalad> yes, one expects any interactive program to burn/explode when a pipe is involved... but then ghci doesn't do anything special with the terminal afaik
01:15:00 <FunctorSalad> hmm, except the haskeline editing
01:15:03 <c_wraith> ghci uses haskeline, which certainly does
01:15:16 <FunctorSalad> which amazingly still works :o
01:15:23 <c_wraith> yes! :)
01:15:37 <FunctorSalad> HsColour seems to just pass the control sequences through
02:32:23 * hackagebot derivation-trees 0.7.2 - Typeset Derivation Trees via MetaPost  http://hackage.haskell.org/package/derivation-trees-0.7.2 (JeanPhilippeBernardy)
02:34:33 <boegel> is it possible to specify command line argument to main in GHCI?
02:34:46 <boegel> and if so, how? (google isn't helping me much)
02:34:53 <kmc>    :set args <arg> ...         set the arguments returned by System.getArgs
02:35:52 <kmc> or you can write «main' :: [String] -> IO ()» and set «main = getArgs >>= main'»
02:36:20 <FunctorSalad> or withArgs blah main
02:36:23 <ben_m> :main 1 2 3?
02:36:28 <FunctorSalad> (non-ghci-specific)
02:36:37 <boegel> ben_m: no, because main is :: IO()
02:36:41 <tallpaul> hi
02:36:42 <boegel> kmc: yeah, that helps, thx
02:36:59 <FunctorSalad> System.Environment
02:37:03 <FunctorSalad> (.withArgs)
02:37:13 <ben_m> boegel: I thought :main is some special GHCI command
02:37:21 <ben_m> I think I use it like this
02:37:25 <ben_m> But mayben ot.
02:37:27 <ben_m> maybe not*
02:37:42 <boegel> ben_m: Prelude Main> :main "bleh"
02:37:42 <boegel> unknown command ':main'
02:38:06 <ben_m> weird.
02:38:06 <FunctorSalad> weird... my ghci has :main  :)
02:38:12 <ben_m> So does mine.
02:38:27 <tallpaul> if I had some parameterized record type. e.g. something like A = \x. [B = x ; C = \y. y + x]. How can this translated into Continuation-passing style?
02:38:54 <kmc> i don't understand that expression tallpaul
02:39:28 <tallpaul> A is a function that have one argument x. And this function returns a record.
02:39:34 <kmc> is it supposed to be a type or a record value or a function?
02:39:35 <kmc> ok
02:39:47 <kmc> you don't have a constructor on your record
02:39:55 <tallpaul> no constructor
02:40:00 <kmc> then it's not valid Haskell
02:40:37 <tallpaul> yes, of course. But I mean apart from Haskell.
02:40:45 <FunctorSalad> a = \x -> ( x, \y -> y+x) maybe..
02:40:53 <zygoloid> in haskell: a = \x -> Record { b = x; c = \y -> y + x }
02:41:10 <kmc> data Rec t = Rec { recB :: s, recC :: s -> s }
02:41:26 <zygoloid> or church-encoded as: \x -> \f -> f x (\y -> y + x)
02:41:32 <kmc> then your function has type «t -> Rec t»
02:41:50 <kmc> and the direct CPS transform would have type «t -> (Rec t -> r) -> r»
02:42:14 <kmc> i.e. \x k -> k $ Rec { recB = x, recC = \y -> y+x }
02:42:24 <kmc> but maybe you wanted to unfold the continuation too
02:42:29 <kmc> err unfold the record into the continuation
02:42:42 <zygoloid> that'll get you the church encoding of the record
02:42:47 <kmc> i don't know a way to do that while preserving the "recordness" of it
02:42:49 <kmc> i.e. labels
02:42:59 <kmc> i would just write:   \x k -> k x (\y -> y + x)
02:43:06 <kmc> :t \x k -> k x (\y -> y + x)
02:43:07 <lambdabot> forall a t. (Num a) => a -> (a -> (a -> a) -> t) -> t
02:43:13 <gwern> > 18 / 1
02:43:14 <lambdabot>   18.0
02:43:22 <gwern> :t 18 / 1
02:43:22 <lambdabot> forall t. (Fractional t) => t
02:43:32 <gwern> > 1 / 18
02:43:33 <lambdabot>   5.555555555555555e-2
02:44:18 <tallpaul> okay. This means A = \x. \cont. cont [B = x ; C = \y. y + x]
02:44:44 <kmc> yeah
02:44:52 <zygoloid> \x k -> k x (\y -> y + x) == \x k -> ap k (+) x == flip (flip ap (+))
02:44:53 <tallpaul> The conitunation can now only be a selection from the record.
02:44:56 <kmc> it's irrelevant that the value returned is a record
02:45:00 <zygoloid> @pl \x k -> k x (\y -> y + x)
02:45:00 <lambdabot> ap (flip . flip id) (+)
02:45:04 <kmc> the continuation could be lots of things
02:45:09 <kmc> including but not limited to a record selector
02:45:24 <zygoloid> @type [flip (flip ap (+)), ap (flip . flip id) (+)]
02:45:25 <lambdabot> forall b a. (Num a) => [a -> (a -> (a -> a) -> b) -> b]
02:45:33 <tallpaul> Does C not also need to converted to CPS?
02:46:01 <tallpaul> like A = \x. \cont. cont [B = \cont2. cont2 x ; C = \y. \conts2. cont2 (y + x)]
02:46:20 <kmc> i guess?
02:46:49 <tallpaul> okay
02:46:51 <tallpaul> thanks
02:46:53 <kmc> i don't think there's one meaning of CPS transform
02:46:58 <gwern> did you know disk space is down to something like 5 cents per gigabyte? http://forre.st/storage#sata
02:47:02 <kmc> sometimes you only want to transform part of the program
02:47:52 <gwern> I wonder if there's a name for the phenomenon 'network and IO gets ever crappier relative to storage capacity'
02:48:07 <ben_m> Idling in here makes me feel stupid.
02:48:08 <kmc> that's gwern's law
02:48:08 <ben_m> :P
02:48:16 <ben_m> That's Ben's law.
02:48:24 <kmc> ben_m, hopefully stupid punctuated with bits of smart when you understand something?
02:48:36 <ben_m> which doesn't happen that often
02:48:37 <ben_m> :)
02:48:45 <kmc> does it happen more the longer you idle here?
02:48:48 * gwern sees nothing on wikipedia for Ben's law
02:49:23 <kmc> gwern, i'm not convinced of your law.  i think network latency has improved faster than spinning-platter-drive latency
02:49:34 <gwern> capacity, I said
02:49:43 <kmc> to the point where data in RAM on an adjacent node is closer than data on local disk
02:49:44 <kmc> ah
02:49:55 <quicksilver> my first networked machine had 10 meg ethernet, and that was in 93 or so
02:49:55 <kmc> so what are you comparing to?
02:49:58 <kmc> network and IO bandwidth?
02:50:13 <gwern> what's the point of having a 1.5tb drive when my upload is stuck at 1mb?
02:50:15 <quicksilver> at that time, it was faster than any disk.
02:50:22 <ben_m> kmc: Sometimes people explain something
02:50:27 <kmc> to download stuff gwern
02:50:36 <gwern> if you can't move your data around, it's not as useful as it could be
02:50:44 <gwern> kmc: a mere small multiplicative faster
02:51:18 <kmc> you can also get cheap hosting
02:51:21 <kmc> with good upload
02:51:34 <gwern> well, that's fine if I can generate the data on the hosting
02:51:49 <kmc> residential connections have crap upload; i'm not sure that relates to a more general phenomenon
02:52:44 <gwern> have commercial connections improved by 2 or 3 orders of magnitude over the same time that saw sub-100$ drives go from 1gb to 1500gbs?
02:53:09 <quicksilver> my connection has gone from 56K to 8M
02:53:15 <quicksilver> that's quite a big change in that time.
02:53:34 <quicksilver> although not quite the same timescale as 1G to 1.5T
02:53:37 <gwern> actual 8M?
02:53:49 <quicksilver> same order of magnitude, certainly
02:54:05 <quicksilver> about 6.2M of actual TCP data.
02:55:02 <gwern> hm, 56k->500k->5m is 2 arrows; 1gb->10gb->100gb->1000gb~>1500gb is 3 arrows
02:55:44 <quicksilver> yup.
02:56:00 <quicksilver> in paris they have gigabyte internet. Let's all move to paris/
02:56:15 <quicksilver> (erm, gigabit, rather)
02:56:15 <gwern> paris would be great if it weren't for the parisians
02:56:55 <quicksilver> most of the UK has access to 50M, but not the bit I'm in.
02:57:13 <SubStack> 50M!
02:57:49 <SubStack> fastest available here is 3M for $100 / month
02:59:07 <zachk1> @src interact 
02:59:08 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:59:20 <quicksilver> SubStack: :(
03:00:06 <SubStack> quicksilver: don't be sad, I'm moving soon ;)
03:00:35 <Kaidelong> http://msdn.microsoft.com/en-us/library/ee821135.aspx
03:00:38 <Kaidelong> whoops wrong room
03:00:55 <gwern> a microsofot dev!
03:00:58 <gwern> lynch him
03:01:15 <ben_m> attack
03:01:17 <ben_m> !
03:01:19 <ben_m> kekekekeke.
03:01:31 <gwern> let this be Kaidelong's epitaph: 'his first mistake was using Windows; his last was telling us.'
03:01:33 <Kaidelong> relax it's F#
03:01:41 <SubStack> gwern: well, microsoft does pay spj to work on ghc...
03:02:09 <Kaidelong> As far as I can tell GHC is something of microsoft research cambridge's baby
03:02:12 <gwern> Kaidelong: that's like saying sauron isn't such a bad guy because he uses orcs, which are sort of like elves
03:02:12 <Kaidelong> and F# is too
03:02:26 <gwern> (in this analogy, F# is the orcs, and ocaml the elves)
03:02:56 <zachk1> should i not use interact? im trying to catch io errors from in ghci and it just crashes ghci 
03:03:12 <zachk1> from it in * 
03:03:23 <quicksilver> you shouldn't use interact if you expect IO errors, no
03:03:29 <quicksilver> although I'm surprised you're crashing ghci.
03:03:45 <zachk1> well its give prelud htellseek or something or another error 
03:03:50 <zachk1> so its not a total bomb out 
03:04:13 <gwern> how do you use interact in ghci? I thought you could only specify stdargs in ghci, not stdin as well
03:04:22 <zachk1> im just using 
03:04:28 <zachk1> interact id 
03:04:29 <zachk1> atm 
03:04:37 <zachk1> and ctrl-c makes ghci bomb out 
03:04:54 <zachk1> from inside the interact 
03:06:06 <gwern> wonder what c-d does
03:06:09 <gwern> or c-d c-d
03:06:10 <quicksilver> if I ^C interact id, I just get ^CInterrupted
03:06:14 <quicksilver> and back to the ghci prompt
03:06:18 <quicksilver> which seems sensible enough to me.
03:06:22 <zachk1> im on windows vista ;) 
03:06:34 <quicksilver> I have some vague memory of a ^C bug in ghci in windows
03:06:38 <gwern> incidentally, C-c on interact id doesn't crash me
03:06:52 <gwern> (linux 6.12.3)
03:07:04 <cncl> doesn't crash here either
03:08:00 <zachk1> ctl-c works fine on my linux box though the buffering of interact is not as nice as windows 
03:08:27 <Ke> gwern: there is mono http://weblogs.asp.net/esanchez/archive/2008/07/14/f-1-9-4-19-runs-out-of-the-box-with-mono-in-linux.aspx
03:08:55 <Ke> I bet F# is dynamically typed
03:09:56 <Cale> F# is statically typed. In fact, you can see some examples of type inference going on in that screenshot :)
03:10:06 <zachk1> ok now after ctrl-c under linux  ghci 6.12.3 if i try interact again it seems like stdin is closed 
03:11:56 <Cale> zachk1: Yeah, that's how it works for me too.
03:24:13 <mietek> http://okmij.org/ftp/Haskell/Iteratee/IterateeIO-talk-notes.pdf
03:24:18 <mietek> This is excellent
03:24:34 <mietek> I really wish Oleg wrote in this style more often
03:37:38 <zachk1> i saw a bunch of bad rot13 code in here yesterday. here is some that i think is correct http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28625#a28625 
03:39:29 <kmc> cool
03:39:32 <kmc> no type sigs?
03:39:53 <zachk1> im very lazy 
03:40:13 <copumpkin> ADTs without bottom form a semiring (where the equality relation is isomorphism), right?
03:43:26 <quicksilver> copumpkin: well you need EmptyDataDecls to get your additive zero, not sure if that's present in every notion of 'ADT'
03:43:40 <quicksilver> copumpkin: with that proviso it's not just a semiring but a free semiring, I think.
03:44:02 <kmc> zachk1, that'll be slow though
03:44:04 <kmc> (linear search)
03:44:05 <copumpkin> yeah, I'm talking more about "abstract ADTs", with the empty type, unit, sums, and products
03:44:06 <kmc> at least in theory
03:44:13 <quicksilver> /the/ free semiring if you don't have base types.
03:44:30 <copumpkin> ah
03:45:18 <quicksilver> and in fact finite base types don't change it, since they're isomorphic to sums of '1'.
03:45:24 <copumpkin> yeah
03:45:42 <quicksilver> assing your ADTs are non-recursive
03:46:01 <ski> (initial semiring ?)
03:46:01 <quicksilver> if you permit recursion then I'm not sure what that is, algebraically.
03:47:42 <gio123> ski
03:50:23 <quicksilver> some kind of semiring closed under countable unions
03:50:32 <quicksilver> that's beyond my limited algebra.
03:51:10 <ugru> helloo there anyone
03:51:16 <kmc> hi ugru
03:51:39 <ugru> hm are you a person
03:52:02 <kmc> negative, i am a meat popsicle
03:52:16 <osaunders> OK, in flip id I've realized that the "a" in «id :: a -> a», has to be function. But I'm not sure why.
03:52:30 <kmc> :t flip
03:52:31 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
03:52:37 <kmc> damn Caleskell
03:52:39 <kmc> :t Prelude.flip
03:52:40 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
03:52:50 <kmc> so you say «flip id»
03:53:04 <kmc> this means the type of id must unify with the type of the arg to flip, namely «a -> b -> c»
03:53:09 <kmc> with me so far?
03:53:12 <copumpkin> lol
03:53:12 <osaunders> Yes.
03:53:22 <kmc> so you need to unify «a -> b -> c» with «d -> d»
03:53:33 <kmc> «a -> (b -> c)» with «d -> d»
03:53:36 <osaunders> copumpkin is laughing because this has gone on for so long.
03:53:49 <kmc> thus a = d, and (b -> c) = d
03:53:53 <copumpkin> nope, just laughing at kmc's self-identification
03:54:03 <kmc> makes sense?
03:54:46 <kmc> so a = b -> c, and we have flip specialized to ((b -> c) -> (b -> c)) -> b -> (b -> c) -> c
03:54:48 <copumpkin> kmc: yeah, definitely
03:55:02 <kmc> note that the first arg now looks like id
03:55:22 <ski> (quicksilver : <http://math.andrej.com/2005/05/16/how-many-is-two/>,<http://math.andrej.com/2009/09/07/constructive-stone-finite-sets/>,<http://math.andrej.com/2009/09/08/constructive-stone-cardinality-of-sets/>)
03:56:03 <osaunders> kmc: OK
03:56:23 <kmc> :t ($)
03:56:24 <lambdabot> forall a b. (a -> b) -> a -> b
03:56:28 <kmc> :t flip ($)
03:56:29 <lambdabot> forall a b. a -> (a -> b) -> b
03:56:36 <kmc> flip id === flip ($)
03:56:46 <kmc> ($) is just id already specialized to ((b -> c) -> (b -> c))
03:57:03 <kmc> flip forces that type on id anyway, so they're equivalent
03:57:44 <osaunders> Riiight
03:57:53 <osaunders> lolz
03:58:12 <osaunders> Let me get back to ($) later.
03:59:48 <ugru> I´m just starting to learn programming.  What do you people think of ruby compared to python or haskell?
04:00:02 <copumpkin> ugru: I came from ruby and never looked back
04:00:02 <kmc> Haskell is precisely 1.2873 times better
04:00:05 <kmc> ;P
04:00:24 <osaunders> Haskell is very different from ruby and python.
04:00:26 <kmc> ugru, why are you learning programming? what do you want to get out of it? what do you know already?
04:01:19 <kmc> ugru:  writing correct programs is difficult in any language.  Haskell makes it also difficult to write incorrect programs
04:01:20 <ugru> very little. I have made some astrolgy programs, very easy in basic 1.0
04:01:48 <ugru> astrology
04:02:05 <kmc> Haskell will probably stretch your mind more than the others
04:02:09 <kmc> if you have a typical background
04:02:15 <kmc> it will be a lot more frustrating at the beginning
04:02:24 <kmc> it may be less frustrating to learn Haskell now than to learn it once you're used to other languages
04:02:29 <osaunders> When unifying (d -> d) with (a -> b -> c) why is (a -> (b -> c)) the first thing you do?
04:02:43 <kmc> osaunders, because (a -> b -> c) is syntactic sugar for (a -> (b -> c))
04:02:54 <kmc> and i wanted to make that clear, because we're unifying one use of (->) with another use of (->)
04:03:10 <kmc> and you have to know correctly which one is on top
04:04:22 <osaunders> You mean I have to realize that a = (b -> c) and not a = a?
04:04:54 <kmc> a = a would hold anyway...
04:05:11 <kmc> you need to unify the (->) in (d -> d) with the lexically first (->) in the other type
04:05:13 <kmc> not the second
04:05:28 <kmc> (it won't always be the first; it's the "top" / "outermost")
04:05:45 <kmc> if we were unifying (d -> d) with ((a -> b) -> c), then it unifies with the second
04:05:55 <kmc> but we know that (a -> b -> c) means (a -> (b -> c))
04:06:02 <kmc> not ((a -> b) -> c)
04:06:31 <osaunders> Hm.
04:06:46 <augur> anyone know if there are any algebraic techniques for manipulating formal proofs/inference rules in the same way you can manipulate haskell function definitions to produce equivalent functions?
04:07:06 <quicksilver> osaunders: does it help to use normal prefix notation instead?
04:07:13 <copumpkin> ski: interesting articles!
04:07:20 <quicksilver> osaunders: You're trying to unify "Fun d d" with "Fun a (Fun b c)"
04:07:23 <kmc> augur, the Curry-Howard correspondence says that functions are proofs
04:07:24 <kmc> so, yes
04:07:35 <augur> mm
04:07:39 <augur> i suppose
04:07:40 <copumpkin> augur: you really should learn agda or coq :P
04:07:45 <kmc> or both!
04:07:48 <quicksilver> osaunders: so, you deduce that d = a and d = Fun b c
04:07:49 <augur> but its only for a certain kind of proof system
04:07:56 <kmc> coqda
04:08:00 <augur> adoq
04:08:01 <osaunders> quicksilver: Yeah.
04:08:03 <augur> agdoq, even
04:08:04 <kmc> da coq
04:08:08 <copumpkin> coqbloq
04:08:24 <copumpkin> augur: one that's worth knowing, still
04:08:32 <augur> copumpkin, kmc: given an purely syntactic proof system, i mean.
04:08:43 <quicksilver> osaunders: we normally write Fun as (->), and we write it infix, and we don't bother with the () but assume right associativity, which makes all that a bit opaque.
04:08:51 <augur> that is, a proof system built around structural, not denotational, proofs
04:08:55 <quicksilver> augur: yes, that is a very widely studied area. I did a PhD in it.
04:09:02 <quicksilver> it's sometimes called 'Proof Theory'
04:09:05 <quicksilver> or simply Logic.
04:09:15 <kmc> how are coq proofs denotational?
04:09:16 <augur> quicksilver: right, but thats not quite answering the question..
04:09:20 * hackagebot hamlet 0.4.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.4.2 (MichaelSnoyman)
04:09:23 <kmc> they are checked with formal rules like beta reduction
04:09:33 <kmc> not by mapping into some domain of "real" mathematical objects
04:09:37 <quicksilver> your question was "are there any algebraic techniques"?
04:09:39 <kmc> (and how would we represent those in a computer anyway?)
04:09:46 <quicksilver> the answer is Yes! 
04:09:46 <kmc> (by more syntax...)
04:09:56 <quicksilver> I don't have a short list for you of what the techniques are, it's a big area ;)
04:10:03 <augur> kmc: yes, but beta reduction ~ implication
04:10:31 <copumpkin> "Suppose c is a map which assigns to each finite set a natural number, such that c(S)=1 if, and only if, S is a singleton. Then the law of excluded middle holds."
04:10:35 <lantti> coq is evil. it will take our jobs and propably our women too. A bit like an immigrant :)
04:10:44 <copumpkin> onoes
04:10:49 <copumpkin> agda then
04:10:52 <copumpkin> or epigram
04:10:55 <copumpkin> which is pretty cool
04:14:15 <lantti> I should start doing something more difficult so I'd have use for all these proof, mathematics and dependent stuff...
04:15:21 <lantti> The only extension to Haskell98 I have really needed is gadts...
04:15:48 <ski> copumpkin : there's more interesting stuff there, check e.g. <http://math.andrej.com/category/constructive-math/>,<http://math.andrej.com/category/computation/> and <http://math.andrej.com/category/logic/>
04:15:50 <copumpkin> mmmm GADTs
04:16:09 <copumpkin> ski: yeah, I've read a few articles on there before, but never read the whole thing
04:16:40 <copumpkin> omg another slovenian
04:17:02 <copumpkin> I could've met him and bonus while I was in ljubljana, but instead I just ate boiled mush
04:17:26 <copumpkin> :)
04:20:30 <gwern> sensible choice. I wouldn't starve just to eat someone
04:20:42 * gwern wonders if ljubljana is a real name
04:20:52 <gwern> *meet someone. although if you did starve, a meet might become an eat
04:22:26 <osaunders> copumpkin: Are you slovenian?
04:22:30 <copumpkin> osaunders: nope
04:22:34 <copumpkin> was just traveling :)
04:22:56 <osaunders> I travel.
04:23:15 <osaunders> Usually between the kitchen and my bedroom.
04:23:25 <copumpkin> the toilet, too, I hope
04:23:33 <osaunders> Yeah.
04:23:48 <osaunders> No, the toilet is in the kitchen :)
04:24:12 <osaunders> We poo in the sink.
04:25:16 <copumpkin> glad to hear it
04:26:15 <Jonno_FTW> :t getLine
04:26:16 <lambdabot> IO String
04:28:21 <kmc> i've found Rank2Types much more essential than GADTs
04:30:39 <copumpkin> GADTs are awesome
04:30:44 <copumpkin> but so are Rank2Types
04:30:52 <copumpkin> RankN
04:31:20 <kmc> i know better ways to fake GADTs than to fake RankNTypes
04:31:30 <copumpkin> how do you fake GADTs?
04:31:38 <copumpkin> with TypeFamilies?
04:31:49 <kmc> maybe
04:31:54 <kmc> with classes, a la "finally tagless"
04:32:04 <copumpkin> the type equality stuff helps
04:32:35 <kmc> or with phantom types and smart constructors with restricted type
04:33:25 <augur> whats lambdabots points-free-ifier?
04:33:34 <kmc> @pl \x y -> y x
04:33:34 <lambdabot> flip id
04:33:35 <dobblego> augur, @pl
04:33:42 <kmc> data Raw = Lit Int | Add Raw Raw | Eq Raw Raw; newtype Exp a = Exp Raw
04:33:44 <augur> thank you :D
04:33:49 <kmc> add :: Exp Int -> Exp Int -> Exp Int; add = Add
04:33:51 <kmc> etc.
04:34:03 <kmc> course you lose pattern-matching there
04:34:14 <kmc> but it's good enough to force your DSL clients to write well-typed code
04:34:22 <kmc> if not to force the compiler to be type-preserving
04:34:41 <copumpkin> well, with type equality and a suitably constructed class you can get almost exactly the same thing as GADTs
04:34:46 <kmc> yeah
04:34:54 <augur> how in gods name does @pl work
04:35:09 <copumpkin> augur: simple rewriting rules
04:35:20 <kmc> i don't know any way to fake RankNTypes
04:35:31 <kmc> like how could you implement anything like ST in Haskell98?
04:36:02 <kmc> existentials are also pretty handy but you can CPS them away if you have RankN
04:36:09 <quicksilver> for a few specific cases you can do a CPS type transform to turn a rank2 type into rank1
04:36:21 <quicksilver> but you can't in general, and I think ST is an example for which you definitely can't.
04:36:49 <quicksilver> surely if it was possible to right runST h98 compatible they would have done it ;)
04:37:37 <kmc> sorry, but the only person i would trust to make that judgement is oleg
04:37:47 <kmc> he has an incredible ability to squeeze advanced features into H98
04:38:13 <kmc> what's a case where you can turn rank-2 into rank-1
04:38:26 <mietek> I'm still having trouble understanding the Monad instance of Iteratee
04:38:37 <Saizan> oleg has done quite a few things with regions like ST, so the fact that he didn't make them h98..
04:38:40 <kmc> (as an aside, i like that there's a result about rewriting some classical proofs constructively using a CPS transform)
04:38:41 <mietek> Slide 19, http://okmij.org/ftp/Haskell/Iteratee/IterateeIO-talk-notes.pdf
04:38:58 * hackagebot hakyll 2.3 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-2.3 (JasperVanDerJeugt)
04:39:40 <kmc> what about it mietek?
04:39:44 <mietek> Why do we disregard the second leftover stream in the first clause of the case statement?
04:40:03 <Saizan> fsvo constructively, you still don't get much of a witness out of them if you go that route
04:44:48 <kmc> mietek, hmm, i've seen other treatments where they append the two
04:44:52 <kmc> e.g. http://cdsmith.wordpress.com/2010/05/23/iteratees-step-by-step-part-1/
04:44:57 <kmc> so i am confused as well
04:45:27 <mietek> Ah
04:45:40 <mietek> In there, the input is a monoid
04:45:57 <mietek> So there is a meaningful thing to do with the leftovers
04:46:30 <mietek> Of course, list is a monoid as well, but maybe on slide 19 Oleg's trying not to complicate things too much
04:47:10 <mietek> For a change
04:53:02 * hackagebot wumpus-core 0.22.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.22.0 (StephenTetley)
04:54:02 * hackagebot wumpus-basic 0.3.0 - Common drawing utilities built on wumpus-core.  http://hackage.haskell.org/package/wumpus-basic-0.3.0 (StephenTetley)
04:54:49 <augur> is there a lambdabot function that will points-free-ify and then find the differences between functions? :D
04:55:15 <copumpkin> kmc: do you ever sleep?
04:55:22 <copumpkin> augur: nope :P
04:55:27 <augur> copumpkin: aww :(
04:55:29 <augur> why not?
04:55:30 <augur> :|
04:56:03 * hackagebot wumpus-microprint 0.3.0 - Microprints - "greek-text" pictures.  http://hackage.haskell.org/package/wumpus-microprint-0.3.0 (StephenTetley)
04:56:05 * hackagebot wumpus-tree 0.1.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.1.0 (StephenTetley)
04:57:58 <kmc> copumpkin, i sleep a lot
04:58:03 <kmc> must be while you sleep ;P
05:04:56 <pastorn> @src Float pi
05:04:56 <lambdabot> Source not found.
05:04:59 <pastorn> @src pi
05:04:59 <lambdabot> Source not found. You untyped fool!
05:05:33 <quicksilver> join my campaign for @src to be removed. It is mendacious, spammy, and misunderstood.
05:06:05 <mietek> How should it be understood?
05:06:06 <dobblego> would be better if it linked to the GHC sourcve
05:06:32 <hpc> :t pi
05:06:33 <lambdabot> forall a. (Floating a) => a
05:06:45 <hpc> > pi
05:06:46 <lambdabot>   3.141592653589793
05:07:02 <hpc> it's just a literal number
05:07:30 <quicksilver> pastorn: http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-Float.html#line-240
05:07:39 <quicksilver> that's what pastorn really wanted, I guess.
05:08:20 <hpc> o.O pi is a class function?
05:08:40 <pastorn> > pi :: Float
05:08:41 <quicksilver> mietek: it's misunderstood if that people expect it to return the source of all kinds of things, when actually it only has the source of a small number of hand-typed things.
05:08:41 <lambdabot>   3.1415927
05:08:45 <pastorn> > pi :: Double
05:08:46 <lambdabot>   3.141592653589793
05:09:45 <hpc> > pi :: CFloat
05:09:45 <lambdabot>   Not in scope: type constructor or class `CFloat'
05:10:03 <hpc> > pi :: CDouble
05:10:04 <lambdabot>   Not in scope: type constructor or class `CDouble'
05:10:09 <augur> quicksilver: where'd you go to uni?
05:10:30 <kmc> copumpkin, what timezone are you in?
05:11:08 <ClaudiusMaximus> i'm making a preprocessor and i want to get Cabal to use it; but the preprocessor generates more than one output file (assembly with .incbin statements etc, haskell with foreign imports etc) - both outputs need to be compiled and linked, and the .as file needs to find the data to include - what's a sane way to do this?
05:13:03 <quicksilver> augur: cambridge then london
05:13:08 <augur> nice
05:13:17 <augur> focus?
05:13:19 <copumpkin> kmc: central european
05:13:29 <quicksilver> pure maths, then logic/CS
05:13:43 <augur> hmm hmm
05:13:51 <augur> welp, ive emailed girard to see if he can give me some refs x3
05:13:56 <copumpkin> omg girard
05:14:04 <copumpkin> don't tell him you have a type of types
05:14:04 <augur> 0.0
05:14:12 <augur> i dont! :D
05:14:27 <augur> i have a KIND of types
05:14:28 <augur> :D
05:14:37 <augur> and its called SPLAT
05:14:40 <copumpkin> :O
05:14:47 <augur> close that mouth, boy
05:14:52 <augur> you wont like what ends up in it
05:14:56 <copumpkin> :O
05:15:00 <copumpkin> I mean
05:15:05 <copumpkin> :| 
05:15:10 <augur> eh
05:15:11 <augur> more :X
05:15:29 <augur> :| is a stubborn look, only incidentally having a closed mouth
05:15:36 <copumpkin> ah
05:15:42 <augur> :X is surely the look you want, where the intention is entirely to convey the closure of the mouth
05:16:05 <augur> who would've thought that emoticons have denotational and connotational meaning? :o
05:16:07 <Gracenotes> augur, were you let out of your cage again :|
05:16:17 <augur> see? Gracenotes knows how to use it
05:16:21 <Gracenotes> who wants some bacon? who wants some bacon?
05:16:26 <augur> BACONNNNN
05:16:40 <quicksilver> I glance away for 5 minutes and the channel goes mad!
05:16:44 <copumpkin> okay, #haskell-blah :P
05:16:50 <quicksilver> someone ask what monads are and get us back to normal pls
05:16:56 <Gracenotes> (P.S. augur doesn't know it's not bacon)
05:16:58 <augur> whats a noman
05:17:01 <copumpkin> omg monads r hard
05:17:01 <augur> nomad
05:17:04 <copumpkin> lern me them kthx
05:17:06 <augur> gnome ad
05:18:11 * copumpkin gets back to his telescopes
05:18:38 <augur> telescopes :o
05:18:46 <copumpkin> they're super cool
05:18:56 <augur> omg are they
05:19:01 <dobblego> I see Venus, Mars and Saturn each night
05:19:08 <augur> copumpkin: you dont happen to be a professor at UMD do you? :D
05:19:14 <Wooga> yessh, i found ready implementation for layout indentation in vim and also added indent for Data-constructions: http://codepad.org/JyrP5qFU
05:19:21 <copumpkin> augur: nope :P
05:19:26 <mm_freak> what are monads?
05:19:36 <augur> how hilarious would it've been if you were
05:19:39 <augur> and you were my semantics prof
05:19:41 <augur> @.@
05:19:41 <lambdabot> Maybe you meant: . @
05:19:54 <mm_freak> i don't understand monads =|
05:19:55 <augur> hahaha
05:20:00 <quicksilver> anonymity is great. In #haskell, nobody knows you're a professor.
05:20:08 <augur> its so true
05:20:20 <mm_freak> quicksilver: and nobody knows you're not =)
05:20:37 <augur> well you're definitely not
05:20:40 <quicksilver> sure, but I think that's what people normally assume.
05:20:42 <augur> you dont even understand monads
05:20:49 <quicksilver> much like people assume you're not a dog.
05:21:33 <copumpkin> http://snapplr.com/wqgc
05:21:34 <mm_freak> augur: true
05:21:40 <mm_freak> i'm not a professor
05:22:06 <copumpkin> augur: wtf is semantix 
05:22:13 <augur> copumpkin: D: what is that D:
05:22:16 <copumpkin> ;)
05:22:27 <augur> also, semantic is the study of meaning in natural language!
05:22:27 <mm_freak> copumpkin: what language is that?  looks something like agda
05:22:33 <copumpkin> it is!
05:22:35 <kmc> tastes like agda
05:22:44 <augur> dont believe him
05:22:47 <augur> its really coq
05:23:22 <copumpkin> :O
05:23:28 <augur> but its ALSO epigram
05:23:35 <kmc> it's a coq surprise
05:23:51 <deteego> monads are sex
05:23:54 <deteego> thats what they are
05:24:00 <augur> well
05:24:13 <augur> you're only allowed to use haskell on pro-sex OSes
05:24:20 <augur> thats for sure
05:24:25 <deteego> agreed
05:24:31 <augur> what with all the moan ads
05:24:33 <augur> 8D
05:24:40 <kmc> lololololololol
05:24:52 <mm_freak> nightmare = unsafePerformIO (getWrongWife >>= sex)
05:25:15 <augur> 1970s = unsafePerformIO (getWrongWife >>= sex)
05:25:23 <deteego> lulz
05:25:31 <augur> BAZINGA
05:25:49 <copumpkin> I'm playing with data representation
05:25:55 <augur> i bet you are
05:25:56 <copumpkin> it's super fun
05:26:58 <kmc> super fun 100%?
05:27:26 <chrisdone> got a present for the emacs users in the house, couple functions for cycling through import lists: http://gist.github.com/511240
05:27:33 <mm_freak> average1970sman :: Wife -> IO ()
05:27:44 <mm_freak> average1970sman = filterM (const True) >=> sex
05:27:52 <mm_freak> s/Wife/[Wife]/
05:28:04 <augur> O_O
05:28:06 <augur> GASP
05:28:12 <deteego> need moar wives
05:28:13 <augur> THE DREADED FISH FUNCTION
05:28:15 <deteego> imho
05:28:16 <augur> >=> >=> >=>
05:28:26 <augur> *waifu
05:28:53 <quicksilver> chrisdone: you could post that to haskellmode-emacs mailing list?
05:29:02 <quicksilver> chrisdone: (but what's with *starry* variable names?)
05:29:09 <augur> quicksilver: the issue of axiom/rule schema equivalence was important, btw, because in linguistics theres much debate about various syntactic formalisms
05:29:20 <augur> or should i say, theres no qualitative debate just a bunch of BS
05:29:34 <augur> because theres no meta-formalism to phrase them all in
05:29:49 <augur> and as a consequence its hard to actually do things like compare formalisms
05:29:56 <chrisdone> quicksilver: I guess it's a habbit from Common Lisp for globals. what's the proper way?
05:30:06 <augur> so im building this proof system to provide such a common meta-formalism
05:30:26 <quicksilver> chrisdone: some-unique-prefix-name
05:30:32 <luite> chrisdone: want to see what I did to your tryhaskell? it's still very unfinished, but it should give an idea
05:30:39 <copumpkin> luite: I do!
05:30:40 <mm_freak> augur: http://xkcd.com/114/
05:30:41 <luite> chrisdone: http://80.126.200.96:8081/weblog/tryhaskell.mod/
05:30:41 <chrisdone> quicksilver: ah, fair enough. I'll change it
05:30:50 <augur> mm_freak: eh
05:30:55 <augur> this is less CompLing actually
05:30:59 <luite> chrisdone: try the following functions: 'plot1' and 'mandel'
05:31:01 <augur> infact
05:31:05 <augur> its kind of the opposite, right
05:31:10 <mm_freak> yes, but it fits anyway
05:31:14 <augur> because there are plenty of contradictory models
05:31:19 <augur> but few people subscribe to multiple
05:31:29 <augur> because its not about pragmatic use of tools
05:31:29 <luite> chrisdone: sorry for removing your design ;) I wanted to make it skinnable by jquery
05:31:36 <augur> its about epistemology
05:31:40 <copumpkin> luite: it's not loading :(
05:31:47 <copumpkin> (after typing in an expression)
05:31:52 <copumpkin> I have a spinner that just keeps spinning
05:31:55 <augur> engineers can be string theorists and loop quantum gravity theorists all in one because they just use what gets the job done
05:32:03 <augur> comp ling people are engineers of language technology
05:32:07 <luite> copumpkin: oh it sometimes does that, the web service is flaky, sorry for that
05:32:22 <copumpkin> oh nice
05:32:22 <augur> theoretical physicists generally arent both string theorists and LQGers because theyre pursuing Truth
05:32:29 <augur> similarly with syntacticians
05:32:30 <luite> I should also change some things to make it faster
05:32:40 <deteego> augur: tbh they are pursuing insanity
05:32:52 <copumpkin> luite: seems like you'd want the interactive and plot areas to be linked
05:32:55 <augur> deteego: theoretical physicists? or syntacticians? x3
05:33:02 <deteego> both?
05:33:05 <augur> lies!
05:33:10 <luite> copumpkin: you can also plot something directly from the console
05:33:13 <augur> both pursue beautiful understanding of reality!
05:33:14 <augur> :|
05:33:23 <copumpkin> luite: oh
05:33:34 <copumpkin> luite: what are you using for the plotting stuff?
05:33:45 <luite> copumpkin: you can just run the function at the bottom of te interactive area from the console
05:33:53 <copumpkin> I see
05:33:55 <luite> the source for mandelbrot is something like
05:34:08 <deteego> augur: understanding of reality makes people insane >.>
05:34:32 <luite> mandel = interactive "mandelbrot'" [intSlider "zoom" 40 1 100, intSlider "x" 20 1 100, intSlider "y" intSlider 20 1 100]
05:34:45 <luite> where mandelbrot' is the actual implementation
05:35:00 <copumpkin> luite: usual complaint I have about tryhaskell that chrisdone forgets sometimes :P command+w on macs is stolen so I can't close the window
05:35:10 <luite> copumpkin: the gRaphael library
05:35:22 <augur> deteego: lies. :|
05:35:53 <luite> copumpkin: hehe I borrowed his console library so this one should have the same problem indeed :)
05:36:37 <ClaudiusMaximus> where's the best place for me to ask about hooking a moderately complex preprocessor into Cabal?
05:37:07 <zygoloid> luite: i can type 'f x = x + 1' to define a function, but it seems to be forgotten at the next type error
05:37:37 <copumpkin> ClaudiusMaximus: into cabal? how so?
05:38:23 <zygoloid> luite: also 1/0 usually gives 'Time limit exceeded'. head [] gives 'Time limit exceeded' the first time and hangs it the second time.
05:38:34 <ClaudiusMaximus> copumpkin: with a custom Setup.hs
05:38:49 <ClaudiusMaximus> copumpkin: but it seems the mechanisms are limited
05:38:57 <copumpkin> ClaudiusMaximus: the custom preprocessor directive in GHC isn't enough?
05:39:19 <augur> hm
05:39:24 <ClaudiusMaximus> copumpkin: well, i generate 2 output files (.as and .hs) which both need compiling/linking
05:39:31 <augur> i think i have a nice intuitionistic analogy for what science is all about
05:39:35 <copumpkin> ClaudiusMaximus: ah
05:39:38 <augur> but its visual, as things often are with me
05:39:55 * copumpkin 's visual analogies have 5 dimensions
05:40:00 <copumpkin> so I can never show anyone
05:40:09 <luite> zygoloid: time limit exceeded probably means that the interpreter has crashed
05:40:12 <kmc> ClaudiusMaximus, there is #hackage but i think most of the traffic there is confused people asking how to hack computers
05:40:25 <copumpkin> lol
05:40:43 <luite> zygoloid: it should restart after a while, but that is the most important problem of this thing now :)
05:41:14 <ClaudiusMaximus> kmc: i'll go investigate
05:41:20 <zygoloid> luite: it semi-reliably happens the first time i run 1/0
05:41:31 <luite> copumpkin: if you want to plot your own function, try something like: > plots (\x -> x*(x-1) / 2)
05:41:40 <luite> oops
05:41:40 <zygoloid> also the spinning-forever reliably happens when running "head []" a couple of times
05:41:43 <luite> that was incomplete
05:41:58 <luite> copumpkin: try > plot (\x -> x*(x-1)/2) True [1..20]
05:42:10 <luite> and yes I know that you cannot paste into the console :(
05:42:41 <tallpaul> I don't get it: I'm writing a lexer with parsec : languageDef =  LanguageDef { // lexer definition }
05:42:51 <tallpaul> lexer = makeTokenParser languageDef
05:43:07 <tallpaul> ghc say:  No instance for (Text.Parsec.Prim.Stream s m Char)
05:43:19 <tallpaul> arising from a use of `makeTokenParser' at src/Parser.hs:63:8-37
05:43:32 <tallpaul> Line 63 is the above lexer line
05:43:40 <ClaudiusMaximus> you probably need to add more type signature
05:43:43 <Twey> join ((*) . subtract 1) . (/ 2)
05:44:38 <luite> you can use that too :p
05:44:38 <copumpkin> luite: very neat
05:44:53 <hpc> :t (*) . subtract 1
05:44:54 <lambdabot> forall a. (Num a) => a -> a -> a
05:44:55 <ClaudiusMaximus> @instances-importing Text.Parsec Stream
05:44:56 <lambdabot> [tok] m tok
05:45:08 <kmc> tallpaul, can you put your whole code on hpaste?
05:45:30 <copumpkin> "Static type checking helps detect quite a few errors, which is very good. Alas, this may lull you into a false sense of security ("it compiles, so it must work correctly")"
05:45:31 <copumpkin> wtf
05:45:35 <copumpkin> who thinks that?
05:45:50 <hpc> newbies, maybe?
05:45:52 <eikke_> I'm getting a stack space overflow in a little program of mine... any ideas how to debug this?
05:45:56 <kmc> i think it's a valid point
05:46:00 <int-e> copumpkin: heh, it has happened to me :)
05:46:01 <Twey> I often think that
05:46:04 <hpc> compilation is still a pretty damn good indicator of correctness
05:46:08 <Twey> Well… ‘probably works correctly’
05:46:10 <Twey> Aye
05:46:29 <copumpkin> well, if it typechecks in coq or agda and I've written proofs of the behavior I want, then yes, I'll have a true sense of security :P
05:46:31 <luite> copumpkin: I may give the interactive area its own graphics output, or close the interactive pane when some other result is returned from the console
05:46:34 <kmc> it's something important to keep in mind
05:46:39 <kmc> not a reason not to use static types
05:46:41 <luite> don't know yet what works best
05:46:50 <int-e> copumpkin: otoh, the same happens in untyped languages - at some point you'll believe your program to be correct ... until a bug turns up.
05:46:53 <kmc> the false sense of security is dwarfed by the actual security
05:46:58 <Twey> Hehe
05:47:00 <kmc> "untyped languages"?
05:47:11 <int-e> kmc: trivially typed ;)
05:47:12 <Twey> Oh-oh
05:47:14 <Twey> Hehe
05:47:17 <copumpkin> monoidally typed
05:47:43 <kmc> to quote the great Homer, "Seatbelts? Pfft, those kill more people than they save!"
05:47:57 <copumpkin> lots of people thought that when they were first introduced
05:48:01 <copumpkin> lots of opposition to them
05:48:06 <int-e> kmc: let's compromise, and say "weakly typed"
05:48:07 <hpc> lol
05:48:16 <kmc> int-e, which languages do you have in mind?
05:48:25 <kmc> "weakly" to me means something like C, or Haskell + unsafeCoerce
05:48:28 <int-e> kmc: php, python, perl.
05:48:42 <kmc> python and perl are pretty different type-wise
05:48:46 <int-e> the evil languaes with P.
05:48:51 <kmc> perl will usually attempt a wacky improbable coercion
05:48:55 <osaunders> How can a function takes one parameter and a definition takes no parameters if a function can be a definition?
05:49:12 <kmc> python will much more often give a runtime type error
05:49:13 <copumpkin> osaunders: I think you're confused
05:49:20 <kmc> osaunders, you are making category error
05:49:22 <copumpkin> osaunders: but I don't understand your question
05:49:30 <ClaudiusMaximus> why can't i    foreign import ... :: CInt  -- illegal foreign type :(   i have a workaround that imports 2x :: Ptr () and uses `minusPtr` but it's a bit smelly
05:49:38 <kmc> "definition" is a syntactic concept
05:49:45 <kmc> it may or may not define an expression of function type
05:49:50 <Maxdamantus> Eh.. What's the left-assosciative equivalent of $?
05:49:58 <kmc> «f x = e» is sugar for «f = \x -> e», at least in simple cases
05:49:59 <Twey> Maxdamantus: None ☹
05:50:03 <hpc> perl's coersions are at least predictable once you know the rules
05:50:08 <Maxdamantus> Aw.
05:50:09 <ClaudiusMaximus> :info `id`
05:50:09 <kmc> Maxdamantus, i don't think there's a standard one.  it's rare to need it, i think
05:50:15 <hpc> and sometimes they can be taken advantage of
05:50:16 <kmc> though i'd be interested to hear of a case where it is desired
05:50:17 <luite> zygoloid: hmm, I can't reproduce your error forgetting the state. it may be that the fastcgi program crashed, it doesn't yet save your state to disk, so it's lost when it restarts
05:50:24 <Maxdamantus> (foo $ bar) $ baz
05:50:35 <Twey> Maxdamantus: The plan is to eventually make $ itself left-associative, AFAIUI.
05:50:45 <kmc> really?
05:50:46 <kmc> madness
05:50:59 <ClaudiusMaximus> :info `echo what`
05:51:00 <kmc> this is ok because you should write (f . g . h $ x) instead of (f $ g $ h $ x)?
05:51:03 <quicksilver> it is a plan that has been discussed but is unlikely to actually happen
05:51:04 <tallpaul> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28630
05:51:09 <Twey> Maxdamantus: Since its associativity is essentially redundant whilst it's right-associative (you can always use a chain of ‘.’ and finish it off with a ‘$’, instead)
05:51:25 <Twey> quicksilver: Not even in an optional extension?
05:51:25 <luite> zygoloid: i'll look into it though, it really needs to be reliable and fast
05:51:43 <quicksilver> but you need $ for "withFoo $ \foo -> withBar $ \bar -> ..."
05:51:57 <quicksilver> can't do that with a left-associative $ or with .
05:52:05 <Twey> quicksilver: But that works anyway because of the magic of lambdas, no?
05:52:08 * Maxdamantus looks up what . does :\
05:52:16 <quicksilver> Twey: well it's hardly a question for an extension
05:52:19 <hpc> not to mention function application is already left associative
05:52:37 <luite> copumpkin: my idea is by the way to write a lhs blog post, and have such a tryhaskell box on the same page, with the source code for the post loaded
05:52:44 <hpc> (foo $ bar) $ baz == foo bar baz
05:52:57 <kmc> tallpaul, «languageDef :: PT.LanguageDef ()»
05:53:03 <kmc> it's trying and failing to infer a more general type
05:53:09 <quicksilver> Twey: yes but it gets quite ugly if you mix things that have parameters and things that don't.
05:53:26 <kmc> i'm not sure how that's allowed to happen
05:53:33 <kmc> since there's no weird extensions in play
05:53:53 <tallpaul> thanks!
05:53:57 <Twey> hpc: Yeah, but e.g. foo $ bar . baz $ quux = foo (bar (baz quux)), whereas it's fairly common (e.g. map) to want foo (bar . baz) quux, which meaning can currently only be obtained with brackets
05:54:22 <luite> copumpkin: and the interactive plotting / graphics things could be used for mathematical subjects. I want to make it so that this thing can execute an initial command automatically, so that even readers who don't know haskell can just use the sliders and enjoy the pretty pictures :)
05:54:33 <Twey> quicksilver: Hmm
05:54:41 <copumpkin> luite: sounds great! but sounds pretty heavy on the backend
05:54:48 <quicksilver> Twey: there was a discussion, it's archived somewhere
05:54:51 <quicksilver> I wonder where.
05:55:10 <chrisdone> quicksilver: alright, I made it a module and made it smell nicer: http://gist.github.com/511240 
05:55:17 <Twey> quicksilver: An extension just seems the logical choice if it's to be ‘opt-in’.
05:55:37 <Twey> Even though it is indeed a tiny thing.
05:55:53 <Draconx|Laptop> Twey, that seems strange... you've basically just traded parentheses for $, character for character, which doesn't seem like much of an improvement...
05:56:13 * kmc is puzzled
05:56:28 <luite> copumpkin: yeah that might be an issue, I'll see how it goes. I do have an own xen virtual machine for it (but it currently runs on my home server for development), so it should handle quite a few requests. mandel is slow though, calculating (even a small) mandelbrot image in unoptimized interpreted code
05:56:33 <kmc> does anyone know why inference fails to find the constraint (Stream s m Char) on tallpaul's example?
05:57:09 <Twey> Draconx|Laptop: Only because it's a simplistic example… with more complex cases it can aid readability (since you don't have to keep track of the brackets)
05:57:27 <chrisdone> inference always fails on multiple parameter type classes
05:57:40 <chrisdone> quicksilver: I sent an email to haskellmode-emacs@projects.haskell.org. did you receive it? I haven't emailed this list before, but I am registered
05:57:57 <kmc> chrisdone, !
05:58:24 <chrisdone> kmc: well, I'm joking. fails a lot though
05:58:28 <kmc> oh, heh
05:58:33 <luite> the graphics things could probably easily be added to chrisdone's tryhaskell, although it uses a very ugly hack to output the bitmaps
05:58:43 <kmc> i forgot MPTC were involved because the extension wasn't on for this module
05:58:49 <quicksilver> Twey: the discussion starts at http://www.haskell.org/pipermail/haskell-prime/2008-April/002478.html
05:58:52 <kmc> i guess you only need it on when declaring classes / instances?
05:58:55 <quicksilver> (well the interesting part)
05:58:58 <luite> but they're still buggy
05:59:03 <luite> and unfinished
05:59:03 <quicksilver> Twey: it's not an extension because it's not a language change
05:59:09 <quicksilver> alternative preludes are not extensions.
05:59:40 <quicksilver> chrisdone: no, nothing on the list yet
05:59:59 <kmc> oh chrisdone, it's the dreaded monomorphism restriction
06:00:04 <copumpkin> onoes
06:00:18 <chrisdone> kmc: D:
06:00:20 <kmc> it's not a failure of inference, it's a failure to specialize to monomorphic type due to ambiguity
06:00:32 <kmc> with -XNoMonomorphismRestriction it gets the right type
06:00:42 <chrisdone> nice one
06:00:52 <kmc> now i feel bad because i told tallpaul something incorrect and he's gone :/
06:00:58 <chrisdone> quicksilver: oh well
06:01:07 <kmc> come back tallpaul! i was wrong in a way you may or may not care about!
06:01:36 <chrisdone> he will return. someone was wrong on the internet. he'll sense it
06:01:43 <kmc> haha
06:02:33 <h_noob> :)
06:04:16 <chrisdone> @tell Baughn http://gist.github.com/511240 a'ight? ;)
06:04:16 <lambdabot> Consider it noted.
06:04:21 <kmc> copumpkin, was that quote from the guy who wrote a list of small gripes about ocaml and titled it "OCaml sucks" to get attention?
06:04:27 * hackagebot bird 0.0.14 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.14 (MattParker)
06:04:43 <copumpkin> kmc: yeah, he's a *******
06:04:59 <h_noob> back to basics: I have complex junk defined as data Section = Section String [(Crap, Pike)] deriving Show - all the goodness like filter foldl etc work with lists - how do I make them work with my data type - do I convert it list of strings or write my own filter or something else? It is so basic that I do not even know where to look :)
06:05:28 <kmc> start with deciding what the type of your filter would be
06:06:44 <h_noob> kmc: filter [Section], String -> Crap - if I remember type signatures properly
06:06:59 <kmc> that's not a valid type signature
06:07:15 <kmc> first of all it's «e :: t» for e an expression, t a type
06:07:20 <h_noob> kmc: I ean it will receive list of Section and a String and return corresponding Crap for example
06:07:29 <kmc> you'd usually encode multiple arguments as a -> b -> c
06:07:30 <kmc> oh
06:07:33 <kmc> that's not really like filter
06:07:45 <kmc> sounds more like lookup
06:07:48 <kmc> but i'm not clear on what it does really
06:08:03 <kmc> return the first Crap from the first Section which matches that String?
06:08:12 <h_noob> kmc: I don't mind changing type signature if it'll make it easier :)
06:08:24 <h_noob> kmc: for example, yes
06:08:24 <kmc> that doesn't really make sense
06:08:35 <kmc> the type signature is (part of) a specification of what the function should do
06:08:42 <kmc> changing it to make more sense is changing the problem you want to solve
06:08:50 <kmc> so which problem do you want to solve?
06:09:17 <osaunders> Is a function a value?
06:09:22 <kmc> yes
06:09:22 <copumpkin> yeah
06:09:29 <kmc> in any decent general-purpose language
06:09:37 <kmc> that is what is meant by "first-class functions"
06:09:48 <kmc> and it's something most languages have.  it's not a "paradigm"
06:10:09 <h_noob> kmc: filter :: [Section] -> String -> Section - it receive list of Section and String and return Section - this is like filter function I think
06:10:19 <kmc> osaunders, in Haskell, functions are those values whose types are of the form (A -> B) for types A, B
06:10:37 <kmc> osaunders, this is a fairly precise definition, because each expression and each value has a type known at compile time
06:10:55 <kmc> h_noob, but what does it do?
06:11:04 <kmc> which Section does it return?
06:11:20 <osaunders> kmc: Yes.
06:11:36 <osaunders> And a definition is just a mapping from a name to a value.
06:12:29 <kmc> h_noob, the fact that the first arg is [Section] makes me think you're not defining a "filter on Section" at all -- you're just using the plain old list filter on a list of Section
06:12:46 <kmc> perhaps:   filter (\(Section xs _) -> xs == ys)
06:13:19 <h_noob> kmc: the one which String constructor == to supplied string e. g. for (Section Test [(Crap1, Pike1)]), (Section A [(Crap2, Pike3)]) filter Test should return Section Test [(Crap1, Pike1)]
06:13:49 <kmc> ok
06:13:52 <kmc> you can write that function
06:13:55 <kmc> it's not very much like filter
06:13:59 <kmc> it's closer to lookup
06:14:03 <kmc> and what if there is none that matches?
06:14:54 <zachk> Maybe to da rescue ftw 
06:15:00 <kmc> :t find
06:15:01 <h_noob> kmc: probably it should return Either
06:15:01 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
06:15:16 <zachk> @src find
06:15:16 <lambdabot> find p          = listToMaybe . filter p
06:15:38 <kmc> findSection xs = find (\(Section ys _) -> ys == xs)
06:15:43 <h_noob> kmc, zachk thanks, I'll try that
06:15:58 <kmc> this is not a very efficient way to find things, if you care
06:16:01 <kmc> because it's a linear search
06:16:56 <h_noob> kmc: right now I prefer readability over performance - if it's easier to read the code I do not care if it's suboptimal :)
06:17:05 <kmc> that's probably a good attitude
06:17:40 <kmc> Haskell does favor this approach
06:17:51 <kmc> get some solution working very quickly, then optimize the parts which need it
06:17:57 <zachk> the thing im realizing, if i use sensible type signatures i can just do linear search for now and if ever need the performance i can use data.map or something else, at least for pure code, i can easily change where i need the speed if and when i need the speed 
06:18:10 <kmc> you can even use the simple un-optimized solution as a test against the fancy one
06:18:11 * zachk wonders if kmc read his mind...
06:18:14 <kmc> heh
06:19:29 <h_noob> btw, which module find is in? way to common name to make search easy :)
06:19:29 <zachk> :t foldl' 
06:19:31 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:20:47 <zachk> > foldl' (liftM2 (*)) (Just 1).map Just$[1..5] 
06:20:48 <lambdabot>   Just 120
06:20:56 <kmc> h_noob, Data.List
06:21:07 <zachk> > foldl' (liftM2 (*)) (Just 1).Nothing:.map Just$[1..5] 
06:21:07 <lambdabot>   Not in scope: data constructor `:.'
06:21:14 <kmc> h_noob, i thought it was in Prelude but apparently not
06:21:15 <zachk> > foldl' (liftM2 (*)) (Just 1).Nothing: .map Just$[1..5] 
06:21:15 <kmc> @hoogle find
06:21:15 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
06:21:16 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
06:21:16 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
06:21:16 <lambdabot>   <no location info>: parse error on input `.'
06:21:35 <kmc> ooh, Foldable
06:21:38 <h_noob> thanks
06:21:48 <zachk> > foldl' (liftM2 (*)) (Just 1).Nothing: .map Just$[1..5] 
06:21:49 <lambdabot>   <no location info>: parse error on input `.'
06:22:02 <zachk> > foldl' (liftM2 (*)) (Just 1).(Nothing:) .map Just$[1..5] 
06:22:03 <lambdabot>   Nothing
06:22:18 <zachk> and that is how monads are finally starting to make sense to me 
06:22:47 <zachk> they are just functions 
06:23:10 <osaunders> Function application is really like a special language primitive?
06:24:16 <zachk> yea and it binds the tighest compared to other operator precedence
06:24:25 <h_noob> zachk, quick - write monad tutorial! :)
06:24:37 <h_noob> I will definitely write one as soon as I get it :)
06:25:00 <kmc> h_noob, you're kidding i hope ;P
06:25:02 <osaunders> ... and then you'll realize you really don't get it. That's what happens to me. :-(
06:25:05 <kmc> @where burrito
06:25:05 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
06:25:35 <h_noob> kmc: I heard that everybody do so... it's almost like tradition :-)
06:25:50 <kmc> osaunders, yes.  functions are also special, they are almost the only type in GHC Haskell which *really* does not have data constructors
06:26:00 <kmc> (unless there's one buried really deep that i missed)
06:26:27 <kmc> the only type you see regularly, i mean
06:26:40 <kmc> things like IO and Int are abstract Report-wise, but in GHC they have implementations as algebraic data that you can import
06:27:13 <osaunders> Could they be made to have data constructors?
06:27:40 <kmc> fsvo "could"
06:27:47 <quicksilver> Int could be algebraic but clumsy.
06:27:51 <osaunders> Like, could you assemble them as a list of operations, like brainfuck or something?
06:28:05 <quicksilver> Integer could be recursive and very clumsy
06:28:08 <kmc> a function isn't just code; it's also a closure over free variables
06:28:34 <kmc> and the types of the free variables of a function are not part of the function's type
06:28:37 <kmc> unlike the types of the arguments
06:28:43 <alip> is there a project out there that uses autotools to configure & compile a haskell package?
06:28:47 <quicksilver> I'm not sure that argument is relevant, kmc
06:28:55 <quicksilver> non-functions (values) can be closures in haskell too
06:29:02 <quicksilver> but it doesn't matter, it doesn't stop them being algebraic.
06:29:37 <kmc> true, but we're assuming you want the algebraic data of a function to actually represent it
06:29:46 <kmc> you could make them algebraic in a trivial useless way
06:29:54 <kmc> data a -> b = Fun
06:30:03 <kmc> maybe that's not even totally useless
06:30:11 <kmc> it might let you write seq for functions in-language, if you did it right
06:30:29 <osaunders> quicksilver: Functions are values.
06:30:36 <quicksilver> osaunders: I know.
06:30:47 <quicksilver> osaunders: in that sentence I meant ..other values
06:30:49 <osaunders> So you mean to say non-function values not "non-functions (values)"
06:30:53 <kmc> there's no handy word for "value which isn't a function"
06:30:58 <kmc> there's also no word for "value which isn't a Bool"
06:31:08 <quicksilver> I was clarifying.
06:31:25 <quicksilver> I meant non-functions (values) not non-functions (bananas) or non-functions (jellyfish)
06:31:32 <quicksilver> or any of the other many things in the world which are not functions.
06:31:38 <kmc> bananas sure, but what about lenses and barbed wire
06:32:05 <jmcarthur> i thought everything was a function ;)
06:32:09 <kmc> ;P
06:32:11 <ski> kmc : functions are more like coalgebraic datatypes <ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/examples/prelude/exp.ch>
06:32:15 <kmc> we do have "boxed type" and "unboxed type"
06:32:29 <kmc> we = GHC
06:32:33 <kmc> values of unboxed type are not first-class
06:32:41 <ClaudiusMaximus> alip: http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#system-dependent scroll down to example 6
06:32:46 <kmc> what language is that ski?
06:32:55 <jmcarthur> charity
06:33:03 <jmcarthur> it's cool. categorical foundations
06:33:07 <kmc> aha
06:33:17 <kmc> far above my pay grade, i'm afraid
06:33:23 <kmc> anyone feel like explaining the syntax?
06:33:26 <Saizan> a function is just an infinite product, a stream whose indexes are the elements of the argument type, instead of Naturals
06:33:35 <alip> ClaudiusMaximus: thanks!
06:33:51 <kmc> exp(A, B) is Haskell's A -> B right?
06:33:58 <jmcarthur> Saizan is going for the practical definition ;)
06:34:02 <kmc> => is defining a new constructor?
06:34:13 <jmcarthur> i wish i understood it too
06:34:25 <jmcarthur> i had gone through some of the documentation ages ago, but i promptly forgot it all
06:34:33 <ski> (kmc : .. though i guess one could consider `newtype a -> b = forall x. Closure# (# x , (# x , a #) -># b #)' or something ..)
06:34:38 <jmcarthur> i was new to functional programming at the time though. i bet it would stick better now
06:35:09 <ski> kmc : see <ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/examples/prelude/PRELUDE.ch> for more examples
06:35:17 <osaunders> The deeper you go the more confusing it gets.
06:35:32 <kmc> yup osaunders
06:35:36 <osaunders> Is it always this way in Haksell?
06:35:43 <kmc> yes
06:35:43 <ski> kmc : e.g. `data SF A -> C = ss: A -> C | | ff: 1 -> C.' corresponds to `data Maybe a = Just a | Nothing'
06:35:51 <osaunders> Fuck.
06:35:54 <ski> s/| |/|/
06:35:58 <jmcarthur> osaunders: the more you learn, the more you realize you do not know
06:36:03 <kmc> osaunders, just like most other intellectual pursuits
06:36:11 <kmc> it gets harder as you go and there's no real bottom
06:36:13 <osaunders> I must know loads then!
06:36:18 <kmc> but perhaps you mean something different by "confusing"
06:36:29 <kmc> there can be an initial hump of getting the terminology
06:36:41 <kmc> learning how to learn, etc.
06:36:45 <ski> kmc : that definition (in terms of Haskell syntax) says that a `Maybe a -> c' function consists of two parts, one part having type `a -> c', the other having type `() -> c'
06:37:26 <kmc> mm
06:37:30 <ski> `data list A -> C = nil : 1 -> C | cons: A * C -> C.' is similar
06:37:40 <kmc> is 1 supposed to be an initial object or something?
06:37:47 <ski> no, terminal object
06:37:50 <kmc> ok
06:37:56 <kmc> i was close ;)
06:38:25 <ski> both these are examples of "left"- or inductive or algebraic datatypes, because we're explaining the datatype in terms of functions *from* the datatype
06:38:48 <kmc> hmm, sounds like church encoding
06:38:54 <ski> for "right"- or coinductive or coalgebraic datatypes, we're explaining the datatype in terms of functions *to* the datatype
06:39:03 <ski> it's related, yes
06:39:38 <copumpkin> 0 is initial
06:40:14 <ski> (at <ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/examples/misc/triple.ch>) `data T -> triple(A, B, C) = p0_3: T -> A | p1_3: T -> B | p2_3: T -> C.'
06:40:58 <ski> explains basically `(a,b,c)' by explaining that functions of type `t -> (a,b,c)' consists of three functions, of types `t -> a',`t -> b',`t -> c', respectively
06:41:42 <ski> `data I -> inflist(A) = head: I -> A | tail: I -> I.' at <ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/examples/misc/inflist.ch> is probably more interesting
06:42:32 <kmc> is there a coinductive equivalent to church encoding?
06:42:37 <ski> in Haskell, the corresponding would be `data Stream a = Cons {head :: a , tail :: Stream a}'
06:42:50 <kmc> mm
06:42:58 <kmc> so | is conjunction and || disjunction
06:43:03 <copumpkin> kmc: how do you mean? functions are already sort of coinductive
06:43:04 <ski> nono
06:43:58 <kmc> copumpkin, well, we write church encoding for data
06:44:00 <ski> <ski> s/| |/|/
06:44:04 <kmc> we encode data with church encoding
06:44:06 <kmc> oh ok sorry
06:44:13 <kmc> then how do we encode conjunction / disjunction resp.?
06:44:19 <copumpkin> kmc: Stream a === Nat -> a
06:44:20 <kmc> copumpkin, do we have to use something else for codata?
06:44:22 <copumpkin> :P
06:44:24 <kmc> right
06:44:34 <ski> kmc : in both the inductive and the coinductive definitions, we enumerate the components of the function/morphism in question
06:45:22 <ski> kmc : for `data list A -> C = nil : 1 -> C | cons: A * C -> C.' this means (a) that we have functions `nil : 1 -> list A' and `cons : A * list A -> list A', for any `A'
06:45:34 <ski> that's how we construct lists
06:46:24 <kmc> right
06:46:34 <kmc> so C ends up being the recursive part of the type
06:47:18 <mrdk> Could someone explain to me what's wrong with my indentation? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28631
06:47:29 <ski> also, it means (b) that if we can construct a function `foo : 1 -> C' and a function `bar : A * C -> C', then we can "bundle those up" as a function `{| nil : foo | cons : bar |} : list A -> C'
06:47:36 <ski> and that's basically `foldr bar foo'
06:47:48 <ski> kmc : yes
06:47:54 <Philonous> Is it acceptable to point to the C api documentation in a package that contains little more than the raw FFI bindings?
06:48:03 <kmc> mrdk, you're using tab characters?
06:48:09 <mrdk> kmc: yes
06:48:09 <kmc> Philonous, i think so
06:48:14 <kmc> mrdk, don't use tabs ;P
06:48:23 <mrdk> kmc: damn, why not? ;P
06:48:37 <Philonous> kmc: Great, thanks.
06:48:46 <ski> now, *dually*, for coinductive datatypes list `data I -> inflist(A) = head: I -> A | tail: I -> I.', we get (a) functions `head : inflist(A) -> A' and `tail : inflist(A) -> inflist(A)' to *deconstruct* streams
06:48:48 <kmc> Philonous, but, you know, i'm just some guy
06:48:55 <jmcarthur> i agree not to use tabs, but i think the problem here is actually unbalanced parens on the exitSuccess line
06:49:02 <jmcarthur> mrdk: ^^
06:49:03 <EvanR-work> because spaces won the war in haskelland
06:49:04 <ski> and, now the more complicated part is how to *construct* these things
06:49:13 <Philonous> kmc: Well, maye I will copy it at one point, atm I just can't be bothered
06:49:20 <EvanR-work> tabs are hunted down and executed or exported
06:49:32 <kmc> mrdk, because the compiler will use 8-char stops no matter what your editor says
06:49:37 <kmc> which can result in code that looks right but fails
06:49:43 <Philonous> kmc: And I will write into the docs that you said it would be OK ;)
06:49:48 <kmc> gasp
06:49:56 <kmc> you can be careful and avoid problems, or you can not use tabs and avoid problems
06:50:01 <ski> which we do by constructing `foo : I -> A' and `bar : I -> I', and package those up like `(| head : foo | tail : bar |)'
06:50:43 <mrdk> kmc: oh ok. But hmm, I really can't figure out what to change so it'll work
06:51:06 <kmc> what jmcarthur said
06:51:13 <ski> kmc : so, the `I' there is like the seed in
06:51:16 <ski> @type unfoldr
06:51:16 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
06:51:17 <chris_____> tryhaskell is awesome
06:51:27 <ski> except skip the `Maybe' part
06:51:32 <jmcarthur> mrdk: unbalanced parens on the exitSuccess line
06:52:07 <mrdk> jmcarthur: sorry, missed your previous message
06:52:31 <jmcarthur> mrdk: it is unfortunate that GHC doesn't report unbalanced parens explicitly
06:52:51 <ski> kmc : so, in both cases, we talk about how a morphism/function (like `list A -> C' in the inductive case, `I -> inflist A' in the coinductive case) is composed out of a *record* of several morphisms/functions (`1 -> C' and `A * C -> C' in the first case, `I -> A' and `I -> I' in the latter case)
06:52:57 <jmcarthur> and instead suggests that it's indentation (which it *could* be in some contexts, i guess)
06:53:22 <kmc> it does say "possibly" ;P
06:53:40 <ski> kmc : anyway, your question about analogoues for church encoding for codata is good
06:53:51 <jmcarthur> (possibly cosmos noise changing a bit in your RAM)
06:53:56 <jmcarthur> *cosmic
06:54:10 <kmc> it means it hit a } before balancing parens, so it suspects indentation for giving it an erroneous }
06:54:18 <jmcarthur> right
06:54:19 <kmc> anyway, ghc's suggestions are in general pretty dubious
06:54:25 <mrdk> jmcarthur: hmm I'm still stuck .. :/
06:54:29 <ski> kmc : consider `Maybe a -> b', we know this is basically the same as `(() -> b,a -> b)'
06:54:37 <kmc> right
06:54:51 <ski> kmc : so if you have `Maybe Foo' on the left of a function arrow, you can rewrite in this way
06:55:03 <jmcarthur> mrdk: i count four '('s but only three ')'s on that line
06:55:10 <dafis> mrdk: spawnOrRaise $ map (\(_, c, _, _, q, _) -> (c, q)) $ fromApps n
06:55:13 <ski> kmc : now, if you have it on the right of a function arrow, like in `b -> Maybe a', you can't rewrite directly
06:55:38 <ski> kmc : but, using CPS, you can rewrite this into `b -> forall o. (Maybe a -> o) -> o'
06:56:12 <mrdk> jmcarthur: you're good, hehe
06:56:26 <ski> kmc : and that, in turn, can be rewritten into `b -> forall o. (() -> o,a -> o) -> o' .. or `forall o. b -> o -> (a -> o) -> o', if you prefer
06:56:44 <mrdk> I was looking at a totally wrong place in the code
06:58:14 <EvanR-work> ski: Maybe a -> b is the same as (() -> b, a -> b) ?
06:58:33 <jmcarthur> :t maybe -- EvanR-work 
06:58:34 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:58:36 <ski> @djinn (Maybe a -> b) -> (() -> b,a -> b)
06:58:36 <lambdabot> f a = (\ _ -> a Nothing, \ b -> a (Just b))
06:58:47 <ski> @djinn (() -> b,a -> b) -> (Maybe a -> b)
06:58:47 <lambdabot> f (a, b) c =
06:58:48 <lambdabot>     case c of
06:58:48 <lambdabot>     Nothing -> a ()
06:58:48 <lambdabot>     Just d -> b d
06:59:07 <ski> (proof that the compositions are `id' is left as an exercise)
06:59:33 <copumpkin> you know what's cool? (binary) sums are just sigma bool and (binary) products are just pi bool
06:59:46 <copumpkin> (assuming you represent your things as bool -> type
06:59:51 <jmcarthur> copumpkin: i have no idea what you just said, but it does sound cool
06:59:57 <kmc> you know what's cool? Applicative
07:00:04 <kmc> in 20 LoC you can write a minimal parser combinator library
07:00:12 <ski> copumpkin : .. but what is `bool' then ? binary sum of `1' with itself ? ;)
07:00:16 <kmc> which is sufficient to parse s-exprs using 4 small lines of code
07:00:17 <copumpkin> ski: a primitive :P
07:00:33 <jmcarthur> oh i see now
07:00:40 <copumpkin> jmcarthur: either a b = sigma bool (\x -> if x then a else b); (a, b) = pi bool (\x -> if x then a else b)
07:00:45 <jmcarthur> yeah :)
07:00:57 <ski> kmc : .. now, i suspect that an analogoue for this, in the coinductive case, is to instead of using Continuation-Passing-Style, use the State-In-Context comonad
07:01:00 <copumpkin> but you can also represent (a, b) = sigma a (\_ -> b)
07:01:29 <jmcarthur> i need to pull out TAPL again soon
07:01:38 <jmcarthur> getting my interest in PL theory and type theory back again
07:01:45 <copumpkin> it's fascinating
07:01:59 * copumpkin is playing with inductive families now
07:02:02 <kmc> got to go, back later
07:02:10 <kmc> thanks for the explanations so far ski
07:02:11 <ski> kmc : btw, i forgot to point to the interesting `data C -> proc(A, B) = pr: C -> A => B * C.' at <ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/examples/misc/proc.ch>
07:03:31 <jmcarthur> ski: kmc may be gone but i'm still listening :)
07:03:40 <ski> kmc : in Haskell, the corresponding would be `data Proc a b = forall c. MkProc c (c -> a -> (b,c))' .. alternatively `newtype Proc a b = MkProc (a -> (b,Proc a b))'
07:04:19 <copumpkin> moore machine?
07:04:27 <ski> so, this type represents a "process" which is transforming values in `a' to values in `b', but is also keeping track of a *local* state at the same time
07:04:38 <copumpkin> or mealy, sorry
07:04:55 * ski can never remember which is which, of those ..
07:05:29 <SoleSoul> Greetings. I'm a beginner in haskell. In order to learn I try to solve problems from project euler. I was very surprized to see how slow a little piece of code can be. I must be doing something wrong. Can anyone give me a hint? For example, this line of code takes about a minute to run in ghci...  [x | x <- [50000000, 49999999  .. 2], 100000000 `mod` x == 0]
07:05:31 <ski> in the latter definition, the internal state isn't visible in the type .. it gets hidden in a closure :)
07:05:33 <copumpkin> Cofree ((->) r) I think
07:06:02 <jmcarthur> not quite
07:06:04 <copumpkin> oh yeah
07:06:34 <Twey> quicksilver: Got distracted, but just finished reading the discussion: the final decision seems to be ‘worth having, but let's make it a new operator’
07:06:40 <ski> copumpkin : wouldn't `CoFree (a ->) b' be `(b,a -> CoFree (a ->) b)' ?
07:06:43 <Twey> quicksilver: So is *that* going to happen?
07:06:48 <copumpkin> ski: yeah, not that
07:07:09 <copumpkin> that is moore :)
07:07:51 <ski> (exercise, write `currentSum :: Num n => Proc n n' with both versions of `Proc')
07:08:27 <ski> jmcarthur : anyway, .. dual to church encoding .. hm
07:08:45 <copumpkin> it has an Arrow instance, I think
07:08:52 <ski> it does
07:08:55 <jmcarthur> ski: i'm not as interesting in the church encoding stuff as the charity stuff
07:09:00 <ski> oh
07:09:08 <ski> but they're related, i think
07:09:23 <jmcarthur> interesting way to word what enables stream fusion... making the closure explicit so that the same function is used recursively rather than a different one each time
07:09:44 <dafis> SoleSoul: it's interpreted code, it's faster if you compile it
07:10:03 <ski> hm .. maybe i should say that `data C -> proc(A, B) = pr: C -> A => B * C.' "morally" means `data C -> proc(A, B) = pr: A * C => B * C.' .. which might appeal to your sensibilities more
07:10:08 <ski> @type loop
07:10:08 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
07:10:41 <ski> (well, s/A * C =>/A * C ->/ in the latter ..)
07:11:24 <ski> so, to construct a function `c -> Proc a b' you must basically construct a function `(a,c) -> (b,c)'
07:11:30 <SoleSoul> dafis: yeah, but it's still not enough. I made a program in C++ which does something similar and it gave me the result very quickly. I tried this code compiled with larger numbers but it still was slow
07:11:40 <ski> and the `c' input to the function is the "initial seed" of the internal state
07:12:18 <SoleSoul> head [x | x <- [(600851475143 `div` 2), (600851475143 `div` 2 - 1)  .. 2], 600851475143 `mod` x == 0] 
07:12:29 <SoleSoul> this is what I really need. It takes forever
07:12:54 <dafis> SoleSoul: No, that's not what you need :)
07:13:06 <SoleSoul> : ) any hints then?
07:13:35 <copumpkin> SoleSoul: use a real algorithm
07:13:48 <dafis> SoleSoul: You need the largest prime divisor, so write a function to find the prime factorisation of a number
07:14:07 * copumpkin guesses project euler
07:14:21 <SoleSoul> I wanted to find the list of divisors and then find the first prime of them
07:14:27 <SoleSoul> is it so wrong to do?
07:14:46 <copumpkin> SoleSoul: there are way better ways of doing it
07:15:02 <copumpkin> it's not wrong if you don't mind waiting a million years
07:15:06 <dafis> SoleSoul: if you find the divisors from the smallest upward (excepting 1, of course), the first divisor is a prime
07:15:11 <SoleSoul> Well, sure.  but this is simple :)
07:15:22 <copumpkin> :)
07:16:01 <jmcarthur> ski: what is the difference between -> and => in charity?
07:16:09 <dafis> SoleSoul: divide the number by the first prime until that is no longer a divisor
07:16:13 <SoleSoul> Sorry for the question, but would it take million years in C also?
07:16:28 <SoleSoul> Ah thanks dafis
07:16:32 <dafis> SoleSoul: then the next larger divisor is also a prime
07:16:34 <SoleSoul> I got your ide
07:16:35 <SoleSoul> a
07:16:36 <ksf> why oh why don't type equalities not work with overlapping instances.
07:16:45 <sjoerd_visscher> Does anybody know if it is intentional that Hackage is using Haddock 2.6.1 instead of 2.7.2?
07:16:47 <ksf> or, rather, why don't we have type inequality, too?
07:16:48 <ski> jmcarthur : well, charity distinguishes between values and morphisms (/ "functions") .. category theory does this too
07:16:50 <dafis> SoleSoul: repeat until you've found the last prime divisor
07:17:11 <EvanR-work> ski: i tried to work it out in my head, but now... wtf does djinn do? ;)
07:17:13 <dafis> sjoerd_visscher: it's what comes with ghc-6.12
07:17:36 <ski> jmcarthur : `->' is used for the "morphism arrow", like in `list A -> C', but you can't really say `list A -> (list A -> C)', e.g., since that's syntactically illformed
07:17:52 <SoleSoul> dafis: it's very similar to my C++ solution. Thank you. I still wonder why it takes so long to do it in my wrong way :/
07:18:13 <dafis> SoleSoul: paste haskell and C++ somewhere?
07:18:35 <ski> jmcarthur : to be able to reify functions as values, you need something like `list A -> (list A => C)' where the `=>' combines two types/objects into a new type/object .. instead of just forming a morphism class
07:18:50 <sjoerd_visscher> dafis: quite annoying, I like documentation with my class instances
07:19:05 <ski> jmcarthur : however, instead of adding such an `=>' as a primitive to the language, Charity actually *defines* the function type
07:19:39 <dafis> sjoerd_visscher: yeah, build your local docs with 2.7.2
07:19:46 <jmcarthur> so -> denotes a morphism between two objects and => actually denotes an object?
07:19:55 <SoleSoul> dafis: thank you very much for that but the C++ solution is in IBM's labs repairing my other laptop
07:20:49 <ski> jmcarthur : in `data C -> exp(A, B) = fn: C -> A => B.' at <ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/examples/prelude/exp.ch>, the `=>' there is part of the syntax .. it brackets as `fn: C -> (A => B)'
07:21:00 <dafis> SoleSoul: okay, so describe what you did in C++
07:22:17 <ski> jmcarthur : in this case, this (a) gives you a function/morphism/arrow `fg : A * exp(A, B) -> B' (not `fg : exp(A,B) -> (A => B)', since that's not valid syntax), which you can use to apply your function values (which can be inputs and outputs of morphisms)
07:22:52 <dafis> SoleSoul: if you did roughly the same as your Haskell code above, it would take a while in C++ too
07:23:05 <jdizzle> anybody home?
07:23:14 <ski> s/fg/fn/
07:23:20 <dafis> jdizzle: yes
07:23:24 <dpratt71> trying to install the 'com' package via cabal... 
07:23:24 <jdizzle> cool
07:23:31 <dpratt71> getting errors:
07:23:32 <dpratt71> * Missing header file: include/WideStringSrc.h
07:23:32 <dpratt71> * Missing C libraries: kernel32, user32, ole32, oleaut32, advapi32
07:23:53 <dpratt71> first one is odd, since that file is in the package
07:24:02 <ski> jmcarthur : also, it gives you (b) a way to actually construct functions (i.e. elements of the type `exp(A, B)'), namely if you can construct `foo : A * C -> B', then you can package that up as `(fn : foo) : C -> exp(A, B)'
07:24:21 <SoleSoul> dafis: It wouldn't be fair to compare since in C++ I did something similar to what you described. I am going to write a C++ code which does what this Haskell code does and compare.
07:24:48 <ski> (jmcarthur : btw, note that i'm possibly getting some syntactic details wrong here. i'm trying to convey the mechanics. it was some time since i read about and played with Charity)
07:24:57 <dafis> SoleSoul: okay, be patient :)
07:24:58 <jdizzle> dafis: maybe you can help.  Can you explain to me how syntactic sugar effects curried functions when using ++?
07:25:01 <dpratt71> tried to resolve the second error by downloading the WinSDK and setting the --extra-include-dirs and --extra-lib-dirs to the appropriate paths
07:25:02 <jmcarthur> sorry brb
07:25:20 <SoleSoul> dafis: lol. Thanks
07:26:05 <jdizzle> namely, why are both (++ "string") and ("string" ++) functions?
07:26:21 <jdizzle> i can see (++ "string"), but why ("string" ++)?
07:26:22 <ski> jmcarthur : now, compare the definition `data C -> exp(A, B) = fn: C -> A => B.' with `data C -> proc(A, B) = pr: C -> A => B * C.' .. both use the same `=>'-syntax, the first to define a type of function values, the second to define a type of process values
07:26:50 <dafis> jdizzle: ("string" ++) is (++) "string"
07:27:09 <kmc> jdizzle, for any operator ⊕ you have sugar (e ⊕)  ===  \x -> (e ⊕ x),  and   (⊕ e)  ===  \x -> (x ⊕ e)
07:27:11 <ski> jmcarthur : another example is `data Q -> queue(A) = enq: Q -> SF(A) => Q | deq: Q -> Q * SF(A).' at <ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/examples/misc/queue.ch> (remember that `SF' is basically `Maybe')
07:27:14 <dafis> jdizzle: so you've passed one argument to (++)
07:27:26 <ski> jmcarthur : am i overloading you yet ? :)
07:27:30 <dafis> jdizzle: and it expects another one
07:27:51 <kmc> it's nothing to do with (++) in particular, the same works for (+) or even something that takes two different types, like (:)
07:27:58 <jdizzle> dafis: so ("string" ++) is syntactic sugar, right?
07:28:06 <ski> EvanR-work : if you give djinn a type, it writes a program having that type .. with some caveats
07:28:09 <jdizzle> dafis: how does that apply in the (++ "string") case?
07:28:12 <kmc> yes, sugar for \x -> ("string" ++ x)
07:28:13 <dafis> jdizzle: yes, called a section
07:28:22 <kmc> (++ "string") is sugar for \x -> (x ++ "string)
07:28:31 <dafis> jdizzle: kmc explained it above
07:29:00 <kmc> there is an implicit lambda, whose argument goes on whichever side of the operator is missing an arg
07:29:02 <ski> EvanR-work : djinn doesn't handle recursive types, it doesn't handle rank-`n'-polymorphism (for `n >= 2')
07:29:04 <jdizzle> okay.  So the sugar is really what allows the flexibility in the ++ case?
07:29:17 <kmc> yes
07:29:19 <zachk1> > unwords . map ((++) ", thats what she said.") . words $ "I want a real diamond ring for our engagement!" 
07:29:20 <lambdabot>   ", thats what she said.I , thats what she said.want , thats what she said.a...
07:29:50 <zachk1> > unwords . map ((flip (++)) ", thats what she said.") . words $ "I want a real diamond ring for our engagement!" 
07:29:51 <lambdabot>   "I, thats what she said. want, thats what she said. a, thats what she said....
07:29:52 <EvanR-work> ski: ah
07:29:56 <kmc> jdizzle, note that (: "string") and ("string" :) are also valid, but now they have different types
07:30:03 <kmc> :t (: "string")
07:30:04 <lambdabot> Char -> [Char]
07:30:07 <kmc> :t ("string" :)
07:30:08 <lambdabot> [[Char]] -> [[Char]]
07:30:13 <EvanR-work> ski: confused by f a = (\_ -> a Nothing...  whats a?
07:30:16 <kmc> you should be able to work out the types by writing the lambdas
07:30:21 <ski> @djinn (a -> Either (b -> c) (a -> c)) -> (a -> b -> c)
07:30:21 <lambdabot> f a b c =
07:30:21 <lambdabot>     case a b of
07:30:21 <lambdabot>     Left d -> d c
07:30:21 <lambdabot>     Right e -> e b
07:30:32 <jdizzle> are there named functions for : and ++?
07:30:45 <zachk1> no but you could make them 
07:30:54 <kmc> you can use them in prefix syntax
07:30:55 <tibbe> Would it be possible to have default implementations of associated data types? i.e. class C where { data T = ... }
07:30:56 <ski> EvanR-work : the argument of the function `f' .. djinn isn't very imaginative in its identifier naming
07:30:58 <kmc> > (++) "foo" "bar"
07:30:59 <lambdabot>   "foobar"
07:31:08 <quicksilver> tibbe: no, although it's been discussed before.
07:31:17 <tibbe> quicksilver: it's really needed
07:31:26 <ski> oh, the kmc is back !
07:31:27 <kmc> jdizzle, if you have Data.Monoid imported, mappend is a generalization of (++)
07:31:34 <kmc> hi ski
07:31:34 <EvanR-work> ski: is it related to an argument of the original function type?
07:31:36 <kmc> i am indeed back
07:31:36 <quicksilver> last time it was discussed in the context of auto-specialising maps I think
07:31:38 <tibbe> quicksilver: I was hoping that ATs would finally allow us to write really good container libraries, but it doesn't
07:31:44 <jdizzle> kmc: let's not get too complicated just yet :)
07:31:47 <tibbe> quicksilver: with me quite possibly :)
07:31:48 <kmc> though i don't think i can absorb any more category theory at the moment
07:31:55 <quicksilver> tibbe: ah, probably :)
07:31:56 <ski> kmc : see above for some blathering on Charity and inductive vs. coinductive datatypes
07:32:29 <jdizzle> is it possible to create my own syntactic sugar?
07:32:44 <kmc> jdizzle, of what kind?
07:32:47 <zachk1> operators yes, sugar would be very hard 
07:32:50 <kmc> you can define new infix operators
07:32:56 <kmc> and you get the section sugar for free
07:33:00 <ski> kmc : anyway, the main idea i had was that because `Maybe a -> b' is `(() -> b,a -> b)', and using CPS, we can rewrite `b -> Maybe a' into `b -> forall o. (Maybe a -> o) -> o' into `forall o. b -> o -> (a -> o) -> o' ..
07:33:05 <kmc> you can define instances of Enum, then you get to use the [x,y..z] sugar
07:33:06 <zachk1> you can even define their precdence 
07:33:14 <kmc> you can define instances of Monad, then you get to use the "do" sugar
07:33:22 <jdizzle> say I create my own function that takes two params, and I want to do the same thing that ++ does (where a ++ b means (++) a b)
07:33:26 <kmc> so basically there are existing bits of sugar that you can hook new types into
07:33:38 <ski> kmc : i was thinking we could do something similar with `codata NEList a = Head :: a & Tail :: List a'
07:33:47 <ksf> jdizzle, that's the default.
07:33:47 <zachk1> and prolly any grand idea you come up with is a ghc extension that was orginally proposed in a research paper back in the 90's ;9 
07:33:51 <kmc> > let (+*+*+) = (++) in "foo" +*+*+ "bar"
07:33:52 <lambdabot>   "foobar"
07:33:55 <kmc> jdizzle, ^^^^^ defining a new operator
07:34:13 <ksf> you can write all operators prefix with () and all functions infix with ``
07:34:28 <ksf> > 1 `elem` [1..2]
07:34:29 <lambdabot>   True
07:34:38 <zachk1> ksf what if its a unary function , ternary or greater? 
07:34:40 <kmc> jdizzle, whether something is infix or prefix is determined by what characters it's made up of
07:34:55 <kmc> letters, numbers, underscore, and quote  =>  prefix
07:34:58 <ksf> zachk1, there only are unary functions.
07:35:01 <kmc> other symbols  =>  infix
07:35:06 <kmc> (i may have missed some in the first list)
07:35:18 <ksf> a binary function is a unary function that returns a unary function
07:35:21 <ski> kmc : i.e. we can rewrite `a -> NEList b' into `(a -> b,a -> List b)' .. now, using the State-in-Context comonad (instead of CPS), we can rewrite `NEList b -> a' into `(exists s. (s,s -> NEList b)) -> a', which we can now rewrite into `(exists s. (s,s -> b,s -> List b)) -> a' .. or `forall s. s -> (s -> b) -> (s -> List b) -> a'
07:35:26 * zachk1 burns deep in thought 
07:35:56 <ksf> f x y z == ((f x) y) z
07:36:11 <ski> kmc : so .. i was thinking there's a cochurch encoding hiding in here
07:36:21 <ksf> also, a -> b -> c -> d == a -> (b -> (c -> d))
07:36:26 <jdizzle> kmc, dafis: thanks for your help!
07:36:29 <zachk1> is there a comessiah yet? 
07:36:40 * ski is not quite sure how to rationalize the handling of (co)recursive types here, though
07:36:49 <quicksilver> zachk1: he's already here, everyone's waiting for his second leaving?
07:37:00 * zachk1 smirks 
07:37:09 <ksf> I think that'd be jdh
07:37:20 <kmc> oh dear
07:37:27 <kmc> i wonder if he greps these logs
07:37:38 <kmc> to see all the nasty things we say about him
07:37:41 <quicksilver> I spect he vanity searches all the time
07:37:47 <kmc> you know, if reddit isn't enough
07:37:49 <quicksilver> harrop harrop harrop harrop harrop harrop badger!
07:38:22 <copumpkin> list = μ (1# + (vs vz * vz))
07:38:24 <ski> (a certain person involved in the SRFI process grepped #scheme, fwiw ..)
07:38:47 <ski> copumpkin> :k 1#
07:39:01 <copumpkin> ski: ∀ {n} → CFT n
07:39:18 <copumpkin> :P
07:39:29 <ski> copumpkin> :src CFT
07:39:50 <pastorn> @pl (\x -> f x x)
07:39:50 <lambdabot> join f
07:39:56 <copumpkin> ski: http://snapplr.com/vjxt
07:40:37 <zachk1> is that agda? 
07:40:55 <copumpkin> yep
07:40:59 * ski didn't know you could enumerate several constructors under the same signature that way, in Agda2
07:41:09 <copumpkin> yep you can :)
07:41:10 <copumpkin> it's handy
07:41:13 <tibbe> quicksilver: Some type families are usually accompanied by a Map example. However, they're not at all suitable for implementing specialized representations of data types.
07:41:15 <ski> but ugly
07:41:18 <dolio> It's kind of new.
07:41:19 <copumpkin> ski: yeah :P
07:41:34 <copumpkin> should I split them?
07:41:34 <jmcarthur> ski: i'm back. thanks for all the explanation :)
07:41:47 <dolio> You should line up the :s at least.
07:41:54 <ski> they should have used `,' or `&' or `@' or whatever they use for conjunctive patterns (~ `as'-patterns)
07:42:14 <dolio> There are no conjunctive patterns.
07:42:25 <ski> (juxtaposition being reserved to function application)
07:42:32 <copumpkin> dolio: annoyingly, they don't line up perfectly in my emacs (the mu in particular is a little too thin)
07:42:50 <dolio> Ah. I hate when that happens.
07:43:11 <ski> jmcarthur : anything in particular you want elaboration on ?
07:43:33 <copumpkin> I'm trying to figure out how to make haskell-style GADTs now (well, context-free ones)
07:43:48 <copumpkin> since none of these epigrammy papers seem to cover that
07:43:56 <copumpkin> (they only cover fully dependent versions)
07:44:18 <jmcarthur> ski: i think i get the gist. i intend to revisit charity soon (maybe tonight now that it's fresh on my mind) and i might ask you more questions later :)
07:44:24 <ski> by Haskell-style, do you mean indexed by types ?
07:44:31 <copumpkin> yeah, and only types
07:45:05 <ski> (or do you mean, matching recovers the indices, rather than you being required to discover the indices before being allowed to match ?)
07:45:21 <dolio> copumpkin: Look up 'constructing strictly positive families' or something like that.
07:45:26 <dolio> Assuming that thesis doesn't have them.
07:45:31 <copumpkin> dolio: oh, that's what I was talking about
07:45:35 <copumpkin> their strictly positive families are dependent
07:45:41 <ski> jmcarthur : ok (keep in mind that's not really that fresh on my mind, either ;)
07:45:44 <copumpkin> I wanted something in-between
07:45:56 <copumpkin> just as an exercise 
07:46:05 <dolio> What do you mean, then? You want just * indices or something?
07:46:08 <dolio> That's going to be tricky.
07:46:11 <copumpkin> (but yeah, it's in this thesis)
07:46:14 <tibbe> What was the original motivation for type families?
07:46:28 <copumpkin> tibbe: writing functions as relations is a pain, I'd guess
07:46:40 <quicksilver> tibbe: might be worth a post to g-h-u, along the lines of Feature Request : defaulting for associated data, with a motivating example
07:46:55 <jmcarthur> ski: i'm curious though. what are your thoughts on charity regarding expressiveness? does the categorical approach have any distinct benefits that you know of?
07:47:00 <quicksilver> tibbe: that's where it's most likely to be read by people who can explain whether that's implementable or not
07:47:09 <ski> copumpkin : hm, is it supposed to be some kind of encoding of partial recursive functions or something like that ?
07:47:11 <tibbe> quicksilver: I'm going to write one
07:47:25 <tibbe> quicksilver: It has been on my todo list for some time
07:47:25 <copumpkin> ski: is what supposed to be?
07:47:32 <tibbe> quicksilver: there are a number of related issues though
07:47:33 <ski> `CFT'
07:47:40 <copumpkin> ski: context-free types
07:47:56 <dolio> copumpkin: The problem with modeling those is that large indices are kind of ill-founded theoretically, if I understand correctly.
07:47:57 <tibbe> quicksilver: just mentioning e.g. Map Int String needs to generate an instance
07:48:04 <copumpkin> dolio: oh, hmm
07:48:52 <dolio> Having an indexed T : U -> U would sort of require u : U, naively, since indices of the modeled types live in the universe.
07:48:55 <copumpkin> well my goal isn't so much reflective
07:49:03 <quicksilver> tibbe: well, try to separate the related issues
07:49:14 <quicksilver> tibbe: but, yes, I appreciate how they are connected
07:49:18 <copumpkin> I don't necessarily want to use these types in agda, but just figure out how to model them faithfully
07:49:20 <tibbe> quicksilver: we need defaulting, being able to use UNPACK pragmas in the generic (default definition), and having specialized instances generated automatically upon use
07:49:21 <dolio> Maybe you could have a higher-universe with types indexed by the lower universe.
07:49:31 <dolio> But that's not really the same.
07:49:36 <tibbe> quicksilver: feels somewhat insurmountable
07:50:25 <quicksilver> tibbe: right. But more eyes might see paths through it, or solutions to part of it.
07:50:36 <dolio> Agda allows them, of course. But they're on shaky theoretical ground, I think.
07:50:48 <ski> jmcarthur : well, for a terminating/productive language, it appears to be quite expressive .. iirc, you can e.g. write ackermann's function, .. also you can compute binomial coefficients in a non-wasteful way
07:51:00 <dolio> Similar to how inductive-recursive definitions are allowed to have codes for themselves, as long as they don't fail the positivity checker.
07:51:15 <ski> jmcarthur : .. but i haven't tried very much in it, so i might be missing things (either positive or negative)
07:51:21 <tibbe> quicksilver: right, I'll definitely send the email. It feels like some things will require changes to the language
07:51:36 <dolio> That isn't theoretically justified.
07:51:39 <tibbe> quicksilver: oh, defaulting would also mean overlapping instances
07:52:18 <jmcarthur> ski: okay, thanks
07:52:23 <osaunders> OK, another question: what is a value?
07:52:52 <SoleSoul> dafis: Hi. Are you still here?
07:53:33 <dafis> SoleSoul: Aye
07:54:08 <SoleSoul> dafis: I found out that the C++ code is about 4 times faster. Wanna take a look?
07:54:17 <ski> copumpkin_ : so what does `vz' and `vs' signify ?
07:54:20 <dafis> SoleSoul: sure
07:54:38 <quicksilver> tibbe: there has to be a solution which doesn't involve overlapping instances, but I don't know how.
07:54:39 <SoleSoul> dafis: http://pastebin.com/Mvs8Fpza
07:54:40 <dolio> ski: De-Bruijn indices.
07:55:38 <ski> osaunders : a value is something you can operate on, like a number, a pair, a list, a function, an array, a tree, a Sudoku-board-state, a coordinate, a color, &c.
07:55:59 <ski> dolio : ah
07:56:00 <tibbe> quicksilver: C++ templates do use overlapping instances
07:56:27 <dolio> There isn't really one answer to "what is a value". Different people will give you different answers.
07:56:46 <dolio> Some will say only canonical elements are values, some will say bottom is a value, etc.
07:56:54 <quicksilver> tibbe: C++ templates are a vile obscenity with no theoretical foundation and no comprehensible denotational semantics. Please do not compare them to haskell types or classes again.
07:56:55 <ski> .. oh, so `_[_]' is dependent function formation
07:56:57 <dafis> SoleSoul: first, try using quot and rem instead of div and mod, then it might make a difference if you specified the type Int64 for the number
07:57:24 <dolio> ski: I think it's substitution... But I'm not certain.
07:57:27 <tibbe> quicksilver: heh, they do allow for efficient implementation of data types
07:57:45 <pikhq> SoleSoul: Keep in mind that that Haskell code is doing *bignums*, where the C++ is using a 64-bit integer.
07:57:58 <pikhq> As dafis said, Int64 will probably help.
07:58:30 <Twey> @remember quicksilver C++ templates are a vile obscenity with no theoretical foundation and no comprehensible denotational semantics. Please do not compare them to haskell types or classes again.
07:58:30 <lambdabot> It is stored.
07:59:13 <SoleSoul> dafis: I don't know these functions yet. I'll look.
07:59:28 <dafis> pikhq: probably not for numbers < maxBound :: Int
07:59:31 <copumpkin> sorry, was making cajun corn chips
07:59:49 <copumpkin> ski: it's more convenient to just make constructors than to embed Fin in it
07:59:51 <Twey> Isn't there an unboxed int type?
07:59:56 <dafis> SoleSoul: quot and rem are what / and % are in C/C++/Java
07:59:57 <copumpkin> Int#
08:00:00 <Twey> That's the one
08:00:02 <osaunders> ski: OK.
08:00:12 <Twey> Int64# should yield about the same performance as the C++, then?
08:00:12 <ski> osaunders : another way of looking at it is to say that values are the things which variables can stand for (borrowing from Quine)
08:00:20 <pikhq> dafis: It's still bignums, and hence has overhead, even if that is just checking for a lack of overflow in a simple x-bit integer.
08:00:29 <copumpkin> Twey: ideally, but you can't use typeclasses with them
08:00:32 <osaunders> ski: Maybe it was a silly question. It's like asking what is 5?
08:00:36 <Twey> Ah, ick
08:00:38 <dafis> SoleSoul: div and mod do the right thing also for negative numbers, but to do that they need additional checking, hence they're slower
08:00:51 <dolio> Values are the inhabitants of types.
08:00:53 <Twey> So you have to use special-purpose numerical functions?
08:00:58 <copumpkin> addInt# etc.
08:00:59 <dolio> And types are the inhabitants of *.
08:00:59 <copumpkin> yeah
08:01:08 <Twey> Hmph.
08:01:14 <copumpkin> Twey: most type variables can't really be instantiated to # kinds
08:01:16 <quicksilver> tibbe: having said all that, some kind of final pass (like collect2 in gnu c++) may be part of the answer for this. I'm not sure.
08:01:28 <dolio> Oh, and #, I guess. And (#)...
08:01:29 <SoleSoul> dafis: thanks. I'm trying it right now
08:01:30 <msieradzki> is !Int64 + -funbox-strict... enough?
08:01:38 <msieradzki> to get "fast" int64s
08:01:42 <Twey> And ?
08:01:48 <tibbe> quicksilver: I'm not familiar with it
08:01:58 <Twey> (kinds, IOW?)
08:01:59 <SoleSoul> dafis: not a real big difference. a few seconds. : real    0m28.609s
08:02:01 <dafis> pikhq: GHC special cases small Integers, that's almost as fast as Int-arithmetic, while (on a 32.bit system), afaik, Int64-arithmetic goes through the FFI, which tends to be slower
08:02:02 <copumpkin> Twey: but most of the time with Int it'll figure out you need to be nboxed anyway
08:02:08 <copumpkin> Twey: especially if you give it strictness annotations on them
08:02:11 <ski> osaunders : well, if you asked Russel, he'd say that five is the class of all sets which have five elements. (except he's dead now, so he wouldn't answer)
08:02:19 <pikhq> dafis: Most bignum implementations do that. :)
08:02:19 <quicksilver> tibbe: basically, to implement correct implicit template instantiation in C++ required them to add an extra pass at the end of the compile process
08:02:32 <pikhq> I didn't know that Int64 went through the FFI, though.
08:02:33 <SoleSoul> dafis: compared to: real    0m33.470s
08:02:33 <quicksilver> tibbe: early C++ compilers required all instantiations to be explicit.
08:02:50 <tibbe> quicksilver: that's what AT require now
08:02:50 <quicksilver> tibbe: (and any C++ compiler which works by compiling to C cannot do implicit instantiation)
08:02:59 <dafis> pikhq: I don't know whether it still does, but I think I would've heard if it changed
08:03:01 <tibbe> quicksilver: I don't think the Simons will be happy with an extra pass ;)
08:03:19 <quicksilver> it breaks separate compilation.
08:03:29 <quicksilver> unless you embed all the information required for that last pass in the .hi files
08:03:49 <quicksilver> but the design space has to be discussed to be explored
08:03:52 <quicksilver> maybe there is a better way.
08:03:55 <tibbe> quicksilver: yes
08:04:03 <ski> @type error `asTypeIn` \error -> case error "foo" of (# _ , _ #) -> ()
08:04:04 <lambdabot> forall t t1. [Char] -> (# t, t1 #)
08:04:07 <ski> @type error
08:04:07 <lambdabot> forall a. [Char] -> a
08:04:10 <SoleSoul> dafis: If such things in Haskell are 3-4 times slower than C++ I can accept that. I wanted to know.
08:04:10 <dolio> If you ask Zermelo, 5 = {{{{{{}}}}}}.
08:04:10 <dafis> pikhq: So on a 32-bit system, there's a good chance that using Integer is faster than Int64, if most of the numbers are actually < 2^32
08:04:15 <dafis> 2^31
08:04:19 <tibbe> quicksilver: the unfolding of the data type definition will probably have to go in the .hi file
08:04:22 <quicksilver> dolio: he doesn't come into IRC so much any more.
08:04:31 <quicksilver> dolio: I think his { key broke.
08:04:34 <dafis> SoleSoul: yes, no, maybe
08:04:37 <dolio> Heh. Probably.
08:04:43 <tibbe> quicksilver: time to leave work, ttyl
08:04:54 <SoleSoul> Maybe = Yes | Just No
08:05:10 <CalmNelly> @vixen are you female, male, or asexual?
08:05:11 <lambdabot> of course i'm female
08:05:11 <SoleSoul> or something weird like that
08:05:19 <pikhq> dafis: Benchmarks are due.
08:05:48 <CalmNelly> @vixen are you able to reproduce?
08:05:49 <lambdabot> yes, i am
08:05:55 <pikhq> SoleSoul: It's more that *naive* Haskell code is likely to be slower by about that much.
08:06:14 <pikhq> SoleSoul: If you want it optimised, it can be optimised, even without hitting C.
08:06:23 <ski> copumpkin : so `vs t : CFT (suc n)' is just like `t : CFT n', except that it explicitly discards the `suc n'
08:06:28 <ski> th input ?
08:06:28 <dafis> SoleSoul: it's typically some factor slower than C(++), for most stuff the factor is less than 10 if you're not doing something stupid, less than 3 if you know how to Haskell
08:06:49 <CalmNelly> @vixen would you ever do a programmer that only codes in Java?
08:06:50 <lambdabot> i might :)
08:06:50 <SoleSoul> pikhq: you mean by using a better algorithm
08:06:57 <SoleSoul> pikhq: ?
08:06:59 <pikhq> (you can get some *really* nasty and hairy low-level Haskell code in IO if for some reason you want it)
08:07:00 <dolio> ski: vs is context weakening.
08:07:00 <CalmNelly> @vixen you disgust me
08:07:00 <lambdabot> have you ever made it with a man?
08:07:06 <ski> (or maybe it's the `zero'th input ?)
08:07:08 <osaunders> CalmNelly: asexual is not the correct term for gender neutrality. 
08:07:10 <copumpkin> ski: it moves you "one lambda out"
08:07:11 <pikhq> SoleSoul: Or just a more optimised implementation thereof.
08:07:13 <CalmNelly> @vixen how dare you!
08:07:13 <lambdabot> how? it depends...
08:07:19 <ski> dolio : yeah, what i said :D
08:07:34 <pikhq> SoleSoul: The *need* for this is not incredibly likely. :)
08:07:35 <dolio> Then yes. :)
08:08:05 <dafis> pikhq: I very much prefer ST to IO
08:08:16 <pikhq> dafis: Yeah, ST *is* quite cleaner.
08:08:23 <ski> @hoogle unsafeInterleaveST
08:08:23 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
08:08:23 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
08:08:40 <CalmNelly> osaunders: asexual, but it still applies to lambdabot
08:09:17 <SoleSoul> Thank you dafis and pinkhq! Haskell is slower then, but better in writing better algorithms.
08:09:18 <osaunders> asexual is not in the same category as male and female. asexual is in the category of sexuality not gender.
08:09:55 <CalmNelly> osaunders: asexual pertains to her have sexual organs, so it still applies
08:09:58 <pikhq> SoleSoul: Haskell's slower than C in many cases, but this is true of most higher-level languages. You just kinda accept it, and deal with it in the few cases it matters. :)
08:10:14 <SoleSoul> Fine :)
08:10:15 <dafis> SoleSoul: Haskell is not *necessarily* slower, it's just harder to write for the optimum speed
08:10:19 <pikhq> And in the meantime enjoy how much easier it is to program in.
08:10:25 <kmc> yeah, you spend 1/10 the time programming and get something 10 times slower
08:10:36 <kmc> then you can spend the other 9/10 optimizing it, or call it good enough and have a beer
08:10:45 <CalmNelly> beer!!
08:10:50 <kmc> usually most of the code is good enough, a few bits will need optimization
08:10:56 <kmc> better than writing the whole bloody thing in C
08:11:18 <osaunders> The state of asexuality is unrelated to the presence of genitals. Asexual means no sexual attraction to either males or females.
08:11:24 <EvanR-work> languages have speed! ;)
08:11:30 <EvanR-work> in miles per hour
08:11:32 <SoleSoul> kmc: you just killed Hakell there
08:11:45 <kmc> osaunders, it can mean other things in other contexts
08:11:49 <kmc> e.g. "asexual reproduction"
08:12:07 <CalmNelly> osaunders: kmc, said it.  Just check the dictionary man
08:12:19 <kmc> i don't think it commonly means "has no gender" though
08:12:21 <osaunders> kmc: Oh right, OK, sorry I didn't know that. That's stupid.
08:12:23 <SoleSoul> Cya guys
08:12:26 <kmc> anyway #haskell-blah
08:12:32 <osaunders> Yeah.
08:12:46 <CalmNelly> anyways, this is a weird topic
08:13:10 <EvanR-work> Male -> Female -> Either Male Female
08:13:11 <CalmNelly> It's not making me horny either, so it must not be right
08:13:23 * Twey chuckles.
08:13:24 <EvanR-work> data Sex = Male | Female | Other
08:13:42 <CalmNelly> now were talking...
08:14:01 <Gracenotes> you're forgetting data Gender
08:14:10 <CalmNelly> @vixen does defining new data types turn you on?
08:14:10 <lambdabot> nevermind about that
08:14:13 <EvanR-work> whats Gender
08:15:10 <Gracenotes> you'll have to run Society -> IO [Gender] to get the list
08:15:30 <dafis> pikhq: microbenchmark: Integer: 6.97s; Int64: 8.41s for the divisors of 10^8
08:15:31 <EvanR-work> end of
08:15:53 <pikhq> dafis: Guess Int64's hitting the FFI, then.
08:15:55 <pikhq> What about Int?
08:16:30 <EvanR-work> i have been told Int64 is dirt slow on 32bit ghc
08:17:09 <msieradzki> which makes me wonder if GHC works on win64
08:17:13 <dafis> pikhq: 4.08s
08:17:43 <dafis> EvanR-work: dirt slow may be a slight exaggeration
08:18:03 <EvanR-work> slight may be a slight understatement ;) or not
08:18:07 <jmcarthur> half the speed of Int is pretty slow in some contexts
08:18:24 <dafis> EvanR-work: depends on the notion of dirt :)
08:18:25 <quicksilver> I think it's much worse than half the speed of Int
08:18:35 <quicksilver> @quote Int64
08:18:35 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
08:18:45 <EvanR-work> @quote Word64
08:18:46 <lambdabot> quicksilver says: it's said to be faster to write the calculation of paper and take it on a public bus to your local unversity and find a math undergrad to do the multiplication for you, than to use
08:18:46 <lambdabot> Word64 on a 32 bit machine.
08:19:07 <quicksilver> but it should compile fine on an arch where GHC thinks there is an appropriate 64 bit native type.
08:19:56 <dafis> quicksilver: but if you have numbers between 2^31 and 2^63, Int64 is often faster than Integer
08:20:13 <dafis> on a 32-bit system, of course
08:21:32 <EvanR-work> i just freakin want the carry of a 32bit multiplication
08:21:45 <EvanR-work> Integer or Word64 do the job
08:22:12 <EvanR-work> i suppose Word64 is better then
08:33:51 <sshc> Does the (<|>) operator use the second parser if the first one doesn't consume any input, even if the first one doesn't fail?
08:34:40 <dafis> sshc: parsec?
08:34:54 <Lemmih> sshc: no.
08:35:08 <sshc> dafis: Yes.
08:35:22 <dafis> sshc: what Lemmih said
08:35:34 <sshc> That's what I thought, but my hardcopy of RWS seems to suggest otherwise
08:35:48 <benmachine> @unmtl RWS r w s a
08:35:48 <lambdabot> r -> s -> (a, s, w)
08:38:08 <luite> copumpkin: http://80.126.200.96:8081/weblog/tryhaskell.mod/  <- I rewrote the web service, it should be more stable and much faster now
08:38:23 <luite> copumpkin: try 'mandel' or 'plot1' again if you want :)
08:38:26 <sshc> "The choice operator is <|>. This operator behaves like this: it will first try the parser on the left. If it consumed no input[35], it will try the parser on the right."
08:39:17 <copumpkin> luite: nice, much faster
08:39:25 <zygoloid> luite: 1/0 works now, but head [] still kills it ;-)
08:39:33 <luite> really?
08:39:40 <zygoloid> yeah
08:39:43 <luite> ah I see
08:39:45 <luite> thanks
08:39:46 <zygoloid> undefined kills it too
08:39:56 <sshc> Is that description incorrect?
08:40:11 <luite> hmm, I thought that I caught all exceptions... back to the drawing board then ;)
08:40:39 <dafis> sshc: seems the failure condition is missing from the description
08:41:00 <zygoloid> luite: it still has the problem that function definitions sometimes mysteriously disappear
08:41:34 <luite> zygoloid: could be that that's related, I need to redo the session handling and persistence anyway, that's the next step :)
08:42:34 <luite> zygoloid: the requests are handled by an fcgi program. this program spawns an external process that actually runs the interpreter. the interpreter process has all kinds of process limits (and is killed by the fcgi program if it takes too long)
08:42:57 <luite> same architecture as chrisdones version actually
08:43:52 <sshc> parse (do {(return 3) <|> (return 6)}) "" ""
08:43:53 <sshc> Right 3
08:44:18 <sshc> RWS's description is incorrect, since the first parser consumed no input, but the second parser wasn't used.
08:44:24 <kmc> sshc, "if [the first parser failed, and] it consumed no input, it will try the parser on the right"
08:44:27 <kmc> is how i read it
08:44:28 <dafis> sshc: parsec docs: If it succeeds, the value of @p@ is returned. If @p@
08:44:28 <dafis> -- fails /without consuming any input/, parser @q@ is tried.
08:44:35 <kmc> quite misleading though
08:44:52 <sshc> kmc: That has an entirely different, but correct, meaning.
08:45:44 <kmc> "first try ... then try ..." has an implicit meaning of "... if it failed, "
08:45:57 <kmc> i agree it's incorrect
08:46:30 <kmc> but i can see how someone would write that even though they had the correct rule in mind
08:57:38 <karlalfred> hello everyone
08:58:55 <pastorn> karlalfred: glöm inte din spenat
08:59:29 <karlalfred> :) hehe n jag har allid med den.
09:01:07 <Ke> jag skulle ha en kamelåså
09:02:21 <BMeph> Am I just oversensitive, or is it just a little bit disappointing/annoying that there is a specialized Data.IntMap, but not a "Data.WordMap"?
09:02:44 <kmc> there is EnumMap
09:04:29 <BMeph> lål ... þ
09:04:35 <kmc> svenska!
09:05:14 <tias> why is there a Data.IntMap at all? shouldn't the GHC be able to optimise EnumMap to practically identical code?
09:06:13 <kmc> EnumMap is newer probably
09:06:24 <kmc> maybe it will happen eventually
09:06:33 * BMeph has often wanted the specialization of an IntMap, but using an Int64. Now, he can have it - thanks, kmc! :)
09:06:38 <kmc> maybe there is some practical obstacle to the optimization
09:07:26 <copumpkin> how can EnumMap work for Int64 when Enum has a -> Int function ?
09:07:33 <copumpkin> (on 32-bit machines)
09:07:37 * copumpkin hates Enum
09:07:40 <zygoloid> BMeph: i suspect that won't work, since EnumMap is probably just IntMap + fromEnum/toEnum
09:08:11 <kmc> there is also "hashmap"
09:08:14 <kmc> IntMap + Map
09:08:37 <kmc> that at least should work right for Int64 on a 32-bit machine
09:09:15 <zygoloid> for some reason the code is copy/pasted, but it's essentially IntMap
09:10:37 <zygoloid> has anyone made a Seq-based hash table?
09:12:36 <c_wraith> what's the advantage there?  It doesn't give you key/value mapping
09:13:00 <BMeph> The best incentive for using Linux: Having a 64-bit machine running 64-bit Windows... :(
09:17:35 <copumpkin> If you write data ListF a b = Either () (a, b) then type List a = Mu (ListF a). List is the initial algebra of ListF, right?
09:17:40 <Phyx-> @pf \v -> join . liftM (findTyThing v)
09:17:40 <lambdabot> Maybe you meant: bf pl
09:17:46 <copumpkin> well, listF a
09:17:48 <Phyx-> @pl \v -> join . liftM (findTyThing v)
09:17:48 <lambdabot> (=<<) . findTyThing
09:17:53 <Phyx-> heh
09:17:57 <Phyx-> @src join
09:17:58 <lambdabot> join x =  x >>= id
09:18:03 <Phyx-> aha
09:19:14 <aristid> (>>=) = join .: fmap
09:19:30 <aristid> :t \f -> join . fmap f
09:19:31 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
09:19:42 <aristid> ugh, wrong argument order
09:19:45 <copumpkin> If that's the case, what is ListF a with respect to List ?
09:19:50 <aristid> (=<<) = join .: fmap
09:19:54 <zygoloid> c_wraith: ? the problem with implementing hash tables in haskell is implementing a good mutable array. Seq is a reasonable mutable array.
09:20:02 <copumpkin> (I'd typically call it the "underlying functor" but am not sure)
09:20:07 <copumpkin> zygoloid: they fixed mutable arrays, though
09:20:09 <copumpkin> nobody noticed
09:20:31 <c_wraith> Well, Seq is a decent pure mutable array substitute
09:20:35 <zygoloid> persistent, rapidly-mutable array :)
09:20:46 <c_wraith> That's true, I guess.
09:21:02 <copumpkin> I'd say a trie-based "hashtable" would be nicer
09:21:02 <zygoloid> but yeah, not strictly-speaking mutable
09:21:23 <copumpkin> I think ezyang was working on one
09:21:41 <zygoloid> that sounds like an IntMap :)
09:22:00 <copumpkin> well, an IntMap + a hashing function and binning :P
09:22:18 <kmc> that's what "hashmap" on hackage does
09:22:23 <copumpkin> ah
09:22:27 * hackagebot dyre 0.8.4 - Dynamic reconfiguration in Haskell  http://hackage.haskell.org/package/dyre-0.8.4 (WillDonnelly)
09:22:35 <p_l> BMeph: ? I never had issues with 64bit windows...
09:31:17 <Phyx-> terra dum dum
09:33:04 <hewei> Hi there, how can I safely cast a Int to a Word, when I know the Int is non-negative ? 
09:33:16 <mauke> fromIntegral
09:33:40 <zygoloid> > fromIntegral (-1 :: Int) :: Word
09:33:41 <lambdabot>   18446744073709551615
09:33:50 <aavogt> @hoogle Int -> Word
09:33:50 <lambdabot> Prelude toEnum :: Enum a => Int -> a
09:33:50 <lambdabot> Data.Bits bit :: Bits a => Int -> a
09:33:50 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
09:34:00 <kmc> if you need it to be really fast, (\(I# x) -> W# (unsafeCoerce# x))
09:34:06 <zygoloid> > toEnum (-1 :: Int) :: Word
09:34:07 <lambdabot>   *Exception: Enum.toEnum{Word}: tag (-1) is outside of bounds (0,18446744073...
09:34:26 <kmc> i don't know if fromIntegral is much slower, it will depend on how well it specializes the function
09:34:27 <aavogt> kmc: you don't trust the optimizer?
09:34:39 <zygoloid> kmc: wouldn't unsafeCoerce :: Int -> Word be faster? ;)
09:35:00 <kmc> zygoloid, even less safe ;P
09:35:02 <hewei> Actually, Int can be Int16/Int32/Int64, similar for Word
09:35:13 <zygoloid> kmc: meh, only a little :)
09:35:16 <hewei> I have (Num v) => as context 
09:35:17 <dafis> kmc: with -O, fromIntegral compiles to the unboxed stuff
09:35:34 <kmc> cool
09:35:50 <zygoloid> i bet unsafeCoerce :: Int -> Word inhibits that optimization ;-)
09:36:35 <dafis> zygoloid: I'm almost sure unsafeCoerce gives the same code (Int -> Word)
09:37:02 <zygoloid> dafis: i'd be impressed if ghc can unbox the int even if it's passed boxed to unsafecoerce.
09:37:11 * zygoloid tries it
09:39:05 <zygoloid> dafis: with fromIntegral :: Int -> Word, it's completely unboxed and lovely. with unsafeCoerce :: Int -> Word, it's kept boxed and slow :(
09:40:15 <dafis> zygoloid: yes, looks so. I'm not sure how slow unsafeCoerce is, though
09:40:54 <zygoloid> unsafeCoerce should compile down to nothing at the Cmm level.
09:41:04 <zygoloid> but by that time it's too late for unboxing.
09:42:13 <Ke> I must say that optimizing haskell sounds tricky
09:42:35 <zygoloid> Ke: you mean for a compiler or a programmer?
09:42:42 <Ke> programmer
09:42:54 <zygoloid> Ke: ghc-core helps /massively/
09:43:04 <Ke> what's that?
09:43:20 <zygoloid> it's a tool which shows you the optimized core and the assembly
09:43:35 <Ke> hmm might be
09:43:40 <CalmNelly> @vixen Can Haskell prevent nuclear war?
09:43:40 <lambdabot> Ooh, functional programmers are so hot!
09:43:52 <zygoloid> @faq Can Haskell prevent nuclear war?
09:43:53 <lambdabot> The answer is: Yes! Haskell can do that.
09:44:07 <CalmNelly> ahhh
09:44:22 <jmcarthur> optimizing haskell is only as tricky as optimizing any other language
09:44:24 <Ke> but one would eg. expect trivial foldl to be optimized to the extent where foldl' would not be needed
09:44:46 <zygoloid> jmcarthur: i'm not sure that's true. haskell is pretty far from the machine, denotationally.
09:45:11 <jmcarthur> zygoloid: it depends how much you need to optimize, of course
09:45:12 <zygoloid> for algorithmic optimizations i agree, but for operational ones...
09:45:38 <c_wraith> fortunately, algorithmic optimizations are all that matter in most cases.
09:45:40 <jmcarthur> superoptimizing is of course tougher, but once you are manually unboxing it becomes a bit more predictable anyway, no?
09:45:57 <zygoloid> sure. but i'd rather not manually unbox :)
09:46:08 <Ke> doing things manually in a very high level language is not nice
09:46:09 <jmcarthur> it's just a matter of finding that one or two places that you need to superoptimize, if any
09:46:16 <jmcarthur> and we have a lot of tools available for that
09:46:37 <jmcarthur> Ke: no less nice than dropping to C, which i don't see as very unnice anyway
09:48:32 <Ke> though I am still hoping that things will improve while there is still research going on
09:48:45 <jmcarthur> things can always improve
09:49:11 <Ke> well C has almost been optimized to the limit one can optimize
09:49:16 <aavogt> jmcarthur: even if you have a proof that something is optimal?
09:49:39 <Ke> proof is irrelevant, statistical sample suffices
09:49:44 <jmcarthur> aavogt: tricky
09:49:52 <jmcarthur> perhaps the proof needs improvements ;)
09:49:59 <jmcarthur> or rather...
09:50:01 <jmcarthur> the specification
09:50:18 <c_wraith> http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector.html#v%3Amodify  --- "The operation will be performed in place if it is safe to do so and will modify a copy of the vector otherwise."  What?  How is that even possible?
09:50:57 <c_wraith> perhaps a better way to phrase that question is "how does it know if it's safe?"
09:51:00 <jmcarthur> c_wraith: depends on if it's a part of a larger algorithm or not. stream fusion sacrifices sharing in favor of fusion
09:51:35 <c_wraith> Oh.  So if it gets fused, it will optimize to an in-place modification?
09:51:40 <jmcarthur> yeah
09:51:44 <c_wraith> Ok.
09:52:07 <c_wraith> Interesting to combine a clever internal represenation with RULEs to nearly get uniqueness types :)
09:52:11 <jmcarthur> or at least sometimes.... i don't know the details of the underlying ST implementation
09:56:24 <Baughn> Darkovski: Well, you're /in/ #haskell, but I never see you speak. Having fun with the language?
09:56:25 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
09:56:35 <Baughn> @clear
09:56:35 <lambdabot> Messages cleared.
09:58:23 <Baughn> @ask chrisdone So, how do you use that elisp module in practice?
09:58:24 <lambdabot> Consider it noted.
10:03:11 <c_wraith> @quote to.a.seq
10:03:11 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
10:03:11 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
10:03:43 <luite> zygoloid: ok I fixed the problem (had to add some strictness things to detect the error situation), can you still crash it now? :p
10:04:04 <silver> Baughn, hunting down silent bobs? Or is this your friend? Take me as your victim, I speak to much and always not about haskell :)
10:04:42 <Baughn> silver: I tend to point people at haskell. He's one of the victims.
10:07:46 <copumpkin> what is (\x -> x x) called in LC?
10:08:08 <EvanR-work> omega ?
10:08:10 <kmc> θ?
10:08:13 <copumpkin> that's two of them
10:08:19 <copumpkin> theta?
10:08:21 <copumpkin> :O
10:08:45 <kmc> maybe?
10:08:50 <zygoloid> luite: yep. try: let fix f = fix where fix = f fix in fix error
10:10:10 <kmc> maybe it's not θ
10:10:45 <EvanR-work> it has no normal form
10:10:53 <copumpkin> yeah
10:10:55 <luite> zygoloid: yeah length [1..] also hangs
10:10:56 <EvanR-work> or is that (\x -> x x) x
10:11:08 <kmc> «λx. x x» is already in normal form
10:11:10 <luite> zygoloid: that should be handled by the timeout killer, which for some reason doesn't seem to work anymore
10:11:14 <copumpkin> omega reduces to itself
10:11:18 <kmc> it's not simply typed though
10:11:39 <ksf> do we have a package which only contains TypeCast and TypeEq?
10:11:47 <kmc> :t \x -> x x
10:11:48 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
10:11:48 <lambdabot>     Probable cause: `x' is applied to too many arguments
10:11:48 <lambdabot>     In the expression: x x
10:12:13 <EvanR-work> meh "who needs types anyway"
10:12:18 <kmc> yeah
10:12:23 <kmc> types just limit my freedom
10:12:27 <EvanR-work> they just get in the way
10:12:49 <kmc> yup
10:15:24 <dilinger> just like that old saying by ben franklin?   they who can give up essential liberty to obtain a little type safety, deserve neither liberty nor type safety?
10:16:06 <karlalfred> I can't get wxhaskell to work. I downloaded it and installed it with the wxhaskell-register.bat
10:16:24 <EvanR-work> but only haskellers can come up with that evidence against types, so its invalid
10:16:45 <EvanR-work> no one else would think to invoke franklin
10:16:53 <zygoloid> dilinger: those who give up essential type safety to obtain a little performance, deserve neither type safety nor performance?: )
10:17:15 * zygoloid thinks back to how unsafeCoerce was slower than fromIntegral
10:17:21 <ksf> those who give up close scrutiny for the sake of ease deserve neither ease nor working programs.
10:17:35 <kmc> did you check the unboxed coerce btw?
10:17:45 <karlalfred> ghc -package wx -o helloworld
10:17:45 <karlalfred> HelloWorld.hs
10:17:45 <karlalfred> <command line>: cannot satisfy -package wx
10:17:45 <karlalfred>     (use -v for more information)
10:18:13 <kmc> did you try ghc --make?
10:19:33 <karlalfred> no. do you mean ghc --make -package wx -o helloworld? =/
10:19:48 <kmc> ghc --make should find any necessary packages
10:19:49 <EvanR-work> you might not need -package
10:20:05 <karlalfred> I tried to compile a sample file from the wx directory.
10:20:05 <kmc> basically, if you are invoking ghc directly from the command line, you probably want ghc --make
10:20:07 <karlalfred> ok
10:21:26 <karlalfred> like this? ghc --make -o helloworld HelloWorld.hs?
10:21:46 <karlalfred> but then it can't find the Graphics.UI.WX module...
10:22:22 <EvanR-work> is it installed
10:23:43 * copumpkin just wrote an untyped LC interpreter that works first try!
10:24:48 <conal> copumpkin: untyped interpreter or untyped LC?
10:25:00 <copumpkin> well, a typed interpreter for an untyped LC
10:25:10 <karlalfred> it doesn't work. =/
10:25:13 <zygoloid> kmc: the unboxed coerce fully unboxed everything, but left a call to coerce in the core with an int literal, rather than just using a word litera.
10:25:15 <EvanR-work> copumpkin: what happens if you evaluate an expression with no normal form?
10:25:21 <conal> ah.  cool.  i imagine an untyped interpreter for a typed LC would be more challenging.
10:25:40 <conal> dang, i love static typing.
10:25:42 <copumpkin> EvanR-work: it only reduces it one step at a time :P so you need to keep asking it
10:25:47 <EvanR-work> ah
10:26:12 <copumpkin> conal: that's next
10:26:53 <Baughn> @type \x -> x x
10:26:54 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
10:26:55 <lambdabot>     Probable cause: `x' is applied to too many arguments
10:26:55 <lambdabot>     In the expression: x x
10:27:11 <zygoloid> kmc: it generates identical asm code though
10:27:43 <kmc> interesting
10:35:34 <karlalfred> is WxHaskell working with ghc 6.12.3?
10:35:56 <karlalfred> I can't get wx to work. is anyone willing to help me out? :)
10:40:09 <dafis> zygoloid, kmc: just tried a stupid benchmark, fromIntegral was twice as fast as unsafeCoerce, same as i2w (I# i) = W# (unsafeCoerce# i), unsafeCoerce needz moar Rulez
10:40:48 <dafis> karlalfred: what does ghc-pkg list wx say?
10:42:04 <zygoloid> dafis: that sounds about right from the ghc-core results
10:42:08 <karlalfred> first of all. I need help with the installation. :) It can't install for some reason. What do you want me to do?
10:42:37 <dafis> karlalfred: what's the error cabal-install gives?
10:43:39 <karlalfred> I will post it on pastebin or something. one moment...
10:44:33 <karlalfred> http://pastebin.com/9mKDkeUF
10:44:55 <karlalfred> seems to be incompatible with my version of ghc?
10:45:17 <karlalfred> wxhaskell-bin-msw2.6.4-ghc6.8.3-0.10.3-0.zip (Windows, ghc 6.8.3, updated)
10:45:27 <karlalfred> from http://wxhaskell.sourceforge.net/download.html
10:46:14 <karlalfred> it sais 6.8.3 but I have ghc 6.12.3
10:46:30 <dafis> karlalfred: wx is at 0.12.* now, that should work with ghc-6.12
10:46:40 <chrisdone> beep
10:46:40 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
10:46:49 <chrisdone> @messages
10:46:50 <lambdabot> Baughn asked 48m 26s ago: So, how do you use that elisp module in practice?
10:47:00 <chrisdone> Baughn: are you there?
10:47:18 <dafis> karlalfred: cabal update, then cabal install --dry-run wx
10:47:59 <dafis> karlalfred: you should use the hackage package, I think
10:48:12 <Baughn> chrisdone: Yep
10:48:30 <chrisdone> Baughn: did you see the example usage line?
10:48:31 <chrisdone> Baughn: (require 'haskell-navigate-modules)
10:48:31 <chrisdone> Baughn: (define-key haskell-mode-map [f8] 'haskell-navigate-modules)
10:48:45 <karlalfred> ok
10:48:55 <chrisdone> Baughn: it's for jumping to the import list (hit f8), doing some import stuff, and then jumping back to where you were (C-u f8)
10:49:10 <Baughn> chrisdone: Ah.
10:49:13 <karlalfred> but I use windows 7 on this computer. not linux. my gaming rig. :)
10:49:23 <chrisdone> Baughn: I just realised I should've called it haskell-navigate-imports
10:49:41 <karlalfred> so how do you do it in windows? cabal...
10:49:50 <chrisdone> Baughn: alright, how's this for a slice of fried gold? http://gist.github.com/511670
10:49:52 <Baughn> chrisdone: I prefer to use recursive-edit for that
10:49:57 <dafis> karlalfred: have you the wxwidgets library and the windows port of wx-config installed?
10:50:11 <Baughn> chrisdone: exit-recursive-edit makes a reasonable catch-all return key
10:51:03 <karlalfred> Dafis: I have only downloaded wxhaskell-bin-msw2.6.4-ghc6.8.3-0.10.3-0.zip (Windows, ghc 6.8.3, updated)
10:51:15 <karlalfred> from wxhaskell.sourceforge.net/download.html
10:51:32 <dafis> karlalfred: if it's for ghc-6.8.3, it won't work with 6.12
10:51:48 <chrisdone> Baughn: mmk
10:51:49 <karlalfred> yes probably an old link.
10:52:07 <Baughn> chrisdone: So anyway, I think you should invoke recursive-edit. ^_^
10:52:35 <fryguybob> karlalfred: cabal works fine on windows
10:52:48 <karlalfred> so what is cabal?
10:53:02 <aleth> n00b question: does 'cabal update' etc have to be run with root priviledges?
10:53:09 <dafis> karlalfred: wxwidgets is a C (or C++) library you need for wxHaskell, and you need to install it with MinGW or something, have a look at the wiki-page
10:53:19 <Phyx-> @pl \fs lc -> msum . map (\env -> findName env fs lc)
10:53:19 <lambdabot> (((msum .) . map) .) . flip . flip findName
10:53:27 <Phyx-> hrm.. fugly
10:53:28 <c_wraith> aleth: no
10:53:42 <karlalfred> allright. thank you for your help!
10:53:43 <chrisdone> Baughn: patch it :p
10:53:48 <aleth> c_wraith: thx - just checking
10:53:49 <c_wraith> aleth: cabal is perfectly happy to keep user-specific state.
10:54:05 <dafis> karlalfred: http://www.haskell.org/haskellwiki/WxHaskell/Building
10:54:21 <c_wraith> and running cabal as root is a good way to mess up your haskell install, actually
10:55:14 <Phyx-> @pl \nm -> msum . map (\env -> findTyThing env nm)
10:55:14 <lambdabot> (msum .) . map . flip findTyThing
10:55:15 <zygoloid> have they not fixed that yet? ;)
10:55:42 <dafis> zygoloid: who hasn't fixed what yet?
10:55:44 <chrisdone> Baughn: next; what these two modules are leading up to. an ido/iscicles/anything completed import command ~o__ </
10:56:15 <chrisdone> Baughn: (/me sick of navigating to import list, typing out full module names. nevar again!)
10:57:06 <chrisdone> Baughn: i tried posting to the haskell-emacs mailing list but it doesn't appear to have sent. did you get any emails from me on it?
10:57:23 <zygoloid> dafis: the Cabal haven't fixed the 'running cabal install --user as root breaks the world' issue yet :)
10:57:34 <chrisdone> Baughn: the archive also hasn't been updated since july. I don't know if that's an intentional part of the process (but it's kind of annoying anyway)
10:57:50 <aristid> :t let findTyThing = undefined; (.:) = (.).(.) in msum .: (map . flip findTyThing)
10:57:51 <lambdabot> forall (m :: * -> *) a a1 a2. (MonadPlus m) => a2 -> [a1] -> m a
10:58:03 <aristid> :t let findTyThing = undefined; (.:) = (.).(.) in msum .: map . flip findTyThing
10:58:04 <lambdabot>     Precedence parsing error
10:58:04 <lambdabot>         cannot mix `.:' [infixl 9] and `.' [infixr 9] in the same infix expression
10:58:04 <zygoloid> i imagine it'd be pretty easy to add a check that .cabal is owned by the current user. might put a patch together...
10:58:27 <dafis> zygoloid: ah, that, but running as root with --user is strange anyway
10:58:32 <aristid> how can i set precedence levels in a let, again?
10:58:40 <zygoloid> dafis: the default is --user whether you're root or not iiuc
10:59:44 <dafis> zygoloid: yes, but running as root, you'd get root's user-db, wouldn't you?
10:59:48 <Baughn> chrisdone: I haven't seen any emails to the haskell-mode list since july, too..
11:00:01 <zygoloid> dafis: not if you use sudo. that doesn't change $HOME
11:00:01 <chrisdone> Baughn: oh dear D:
11:00:06 <Baughn> chrisdone: I thought it was just the "being a low-volume list" thing. :/
11:00:54 <zygoloid> dafis: upshot: "sudo cabal install foo" leads to horrific screaming bloodshed
11:00:58 <Baughn> chrisdone: ..guess I'll have a look. And while I'm doing that, I can ping the haskell.org admin again.
11:01:18 <dafis> zygoloid: oh, sudo, yeah
11:01:34 <chrisdone> Baughn: sure
11:01:34 <Phyx-> @src MonadPlus
11:01:35 <lambdabot> Source not found. Where did you learn to type?
11:01:36 <Baughn> dafis: cabal-install has its own root-cmd line in ~/.cabal/config, where you can put sudo
11:01:45 <Baughn> dafis: That will make global installs work fine, without messing anything up.
11:01:48 <Phyx-> does MonadPlus imply Monad? :P
11:01:58 <Baughn> Well, for "If you mess this up, you have to reinstall GHC" values of "fine", anyhow. >_>
11:02:10 <zygoloid> @type return () `mplus` return ()
11:02:11 <benmachine> Phyx-: Monad is a superclass of MonadPlus
11:02:11 <lambdabot> forall (m :: * -> *). (MonadPlus m) => m ()
11:02:14 <zygoloid> Phyx-: ^^ yes.
11:02:19 <dafis> Baughn: I have my GHC in $HOME so I don't mess up anything irreparably
11:02:34 <benmachine> @type undefined :: (Monad m, MonadPlus m) => m ()
11:02:35 <lambdabot> forall (m :: * -> *). (MonadPlus m) => m ()
11:02:50 <Phyx-> ok, cool thanks, I can remove that constraint then
11:03:07 <Baughn> dafis: I find that /usr/local works fine
11:03:40 <dafis> Baughn: would, probably, but I'd need to sudo to install there
11:04:00 <dafis> so I play it safe
11:04:09 <Baughn> dafis: Right. I've got sudo setup to work without a password.
11:04:24 <Baughn> Because, let's be honest about this, all my *valuable* files are in $HOME.
11:05:17 * Baughn wouldn't particularly mind running his system as root, if programs could shut up about how insecure it surely is
11:05:30 <FunctorSalad> surely there's some cat-free way to achieve '{ echo let oh=\"hi\" ; cat } | ghci'
11:06:33 <Phyx-> hmm. if I want a general instance F a => F (Located a) where and a specific instance F (Located Name) where, so, only way to use this is overlapping instances right?
11:06:42 <FunctorSalad> (maybe sed -u -e '' is less buffered than a cat o_o)
11:06:46 * hackagebot hierarchical-clustering 0.3 - Algorithms for single, average/UPGMA and complete linkage clustering.  http://hackage.haskell.org/package/hierarchical-clustering-0.3 (FelipeLessa)
11:07:12 <dolio> Phyx-: Yes.
11:07:17 <Phyx-> aww too bad
11:07:31 <dolio> I mean, you can do the same trick as Show, if you want.
11:07:31 <Phyx-> atleast it's better than Undecideable instances
11:07:40 <FunctorSalad> is it?
11:07:54 <dafis> FunctorSalad: echo let oh=\"hi\" >> ~/.ghci; ghci ?
11:08:21 <FunctorSalad> dafis: yes that'd be a way
11:08:42 <FunctorSalad> (maybe backup the .ghci first if it's a one-shot)
11:10:28 <dafis> FunctorSalad: or echo it into the .ghci in the same directory to not mess with your global .ghci
11:10:47 * hackagebot hierarchical-clustering 0.3.0.1 - Algorithms for single, average/UPGMA and complete linkage clustering.  http://hackage.haskell.org/package/hierarchical-clustering-0.3.0.1 (FelipeLessa)
11:10:50 <FunctorSalad> it looks for a .ghci in the pwd?
11:11:10 <dafis> FunctorSalad: yes, before ~, iirc
11:11:48 <luite> zygoloid: hmm, this is interesting. in my implementation "fix error" never produces output, and I think the process ignores signals because I'm in an exception handler, handling another exception
11:12:07 <luite> so the timeout killer doesn't work, since it sends a SIGKILL instead of a SIGABRT
11:12:18 <FunctorSalad> "/tmp is owned by someone else, IGNORING ;)" but thanks, obviously I can just make a subdir
11:12:28 <c_wraith> > error $ error "error is strange"
11:12:29 <lambdabot>   *Exception: *Exception: error is strange
11:12:34 <seydar> how are the ruby bindings via hubris coming along?
11:13:12 <copumpkin> omg a seydar
11:13:16 <copumpkin> abandon ruby
11:13:19 <copumpkin> that way lies madness
11:13:57 <seydar> copumpkin: fo rizzle?
11:14:03 <seydar> expliquer
11:14:14 <copumpkin> trust me, once I used to be a rabid rubyist
11:14:28 <copumpkin> then I saw the light
11:14:30 <seydar> yes, and now thou art ein haskelhead
11:14:37 <copumpkin> yep
11:14:40 <seydar> i, too, have seen this light
11:14:47 <seydar> but i wish to combine the light and the dark
11:14:53 <seydar> to create a subtle, romantic setting
11:14:55 <copumpkin> that way lies madness, though
11:15:01 <copumpkin> it's like matter and antimatter
11:15:06 <copumpkin> in your head
11:15:07 <seydar> yeah, orgasmic madness
11:15:30 <copumpkin> preflex: seen mwotton
11:15:30 <preflex>  mwotton was last seen on #haskell 15 days, 13 hours, 8 minutes and 37 seconds ago, saying: feels a bit "but i'm not dead!" "you will be soon, get on the cart"
11:15:40 <copumpkin> preflex: seen blackdog
11:15:41 <preflex>  blackdog was last seen on #haskell 10 days, 8 hours, 47 minutes and 26 seconds ago, saying: ksf: stop trying to turn perfectly useful programmers into academics
11:15:51 <FunctorSalad> hauptsache es knallt...
11:15:54 <Phyx-> preflex: longest unseen
11:15:55 <copumpkin> seydar: he's the guy, but I guess he isn't around much these days
11:16:05 <copumpkin> preflex: seen TheHunter
11:16:06 <preflex>  TheHunter was last seen on #haskell 73 days, 12 hours, 5 minutes and 16 seconds ago, saying: @join #functionaljava
11:16:11 * copumpkin coughs
11:16:19 * jmcarthur coughs
11:16:25 <Phyx-> preflex: seen mmorrow
11:16:25 <preflex>  mmorrow was last seen on #ghc 200 days, 15 hours, 18 minutes and 40 seconds ago, saying: * mmorrow is rtfm'ing
11:16:38 * Phyx- wonders what manual he was reading
11:16:39 <jmcarthur> that's a long fm
11:16:45 <seydar> preflex: seen seydar
11:16:45 <preflex>  seydar was last seen on #haskell 1 minute and 38 seconds ago, saying: yeah, orgasmic madness
11:16:49 <dafis> preflex: seen oleg
11:16:49 <preflex>  oleg was last seen on #perl 1 year, 195 days, 23 hours, 14 minutes and 33 seconds ago, saying: oh hey... perlre... I wish I knew about that before I tried to make a project work
11:16:49 <seydar> preflex: seen seydar
11:16:50 <preflex>  seydar was last seen on #haskell 4 seconds ago, saying: preflex: seen seydar
11:16:57 <mauke> preflex: seen ndm
11:16:57 <preflex>  ndm was last seen on #haskell 1 year, 89 days, 7 hours, 58 minutes and 16 seconds ago, saying: plus with current compiler technology, it would be slower
11:17:01 <jmcarthur> preflex: seen preflex
11:17:01 <preflex>  what
11:17:04 <jmcarthur> haha
11:17:05 <seydar> hahahaha
11:17:06 <Phyx-> hahaha
11:17:10 <seydar> anyways
11:17:13 <seydar> i fucking love haskell
11:17:21 <dafis> preflex: seen lambdabot
11:17:21 <preflex>  lambdabot was last seen on #haskell 4 minutes and 52 seconds ago, saying:   *Exception: *Exception: error is strange
11:17:29 <copumpkin> preflex: seen preflex
11:17:29 <preflex>  what
11:17:44 <seydar> and am searching for time to work with it
11:17:49 <Phyx-> preflex: seen *
11:17:49 <preflex>  Sorry, I haven't seen *
11:17:54 <Phyx-> preflex: seen %
11:17:55 <preflex>  what
11:18:00 <seydar> preflex: seen my dog
11:18:01 <preflex>  Sorry, I haven't seen my
11:18:03 <Phyx-> preflex: seen %a%
11:18:04 <preflex>  Sorry, I haven't seen a%
11:18:07 <seydar> preflex: seen 'my dog'
11:18:07 <preflex>  Sorry, I haven't seen 'my
11:18:09 <Phyx-> preflex: seen %a
11:18:09 <preflex>  a was last seen on #perl 149 days, 15 hours, 40 minutes and 31 seconds ago, saying: thanks for all your help, everyone. also thanks for all the resources. maybe next time i come in here you wont be offended by my stanky perl
11:18:20 <Phyx-> preflex: seen %b
11:18:21 <preflex>  b was last seen on ##javascript 296 days, 17 hours, 20 minutes and 54 seconds ago, saying: `
11:18:33 <Phyx-> there are people with single letter nicks?
11:18:36 <jix_> is there a way to "sample" a TVar without putting it into the transaction log?
11:18:50 <Phyx-> preflex: seen %z
11:18:51 <preflex>  z was last seen on ##php 2 years, 103 days, 20 hours, 7 minutes and 52 seconds ago, saying: heh
11:18:55 <copumpkin> okay okay, quit it
11:18:59 <seydar> copumpkin: you've got to let go of your fear
11:19:01 <Phyx-> sorry :/
11:19:08 <copumpkin> :)
11:19:11 * Phyx- crawls into his corner
11:19:15 <seydar> you have to accept that there are many languages out there
11:19:19 <copumpkin> seydar: it's not fear, it's basic safety
11:19:20 <Phyx-> *puts on his dunce hat*
11:19:21 <seydar> and there are two which are the best
11:19:23 <seydar> ruby and haskell
11:19:31 <seydar> and d kicks ass as well
11:19:33 <seydar> but anyways
11:19:44 <mauke> Phyx-: #haskell-blah?
11:19:49 <seydar> ruby and haskell can be combined to create the ultimate thingydo
11:20:14 <Phyx-> mauke: nah, i'll do back to doing something productive
11:20:25 <jmcarthur> seydar: *why*?
11:20:31 <seydar> fuck it man, if there were some serious haskell-ruby bindings, i'd rewrite half my shit in haskell
11:20:47 <seydar> jmcarthur: because i really like the glue that ruby provides
11:20:52 <seydar> but sometimes, I need something else
11:20:58 <seydar> or
11:21:01 <seydar> let me start over
11:21:06 <seydar> i really like blue cheese dressing
11:21:26 <jmcarthur> oh i see
11:21:32 <seydar> but sometimes, blue cheese doesn't complement the salad as well as a vinegar based dressing does
11:21:49 <jmcarthur> would have been better to just leave it at blue cheese dressing
11:21:51 <chrisdone> o_o
11:22:02 <seydar> i mean sure
11:22:03 <seydar> i could
11:22:05 <jmcarthur> i understood then
11:22:20 <jmcarthur> you are one of "those" people
11:22:24 <shapr> seydar: I'm actually enjoying C++ so far.
11:22:31 <seydar> but you know some salads just BEG for something else
11:22:42 <seydar> like a white chocolate and orange dressing
11:22:42 <jmcarthur> shapr: okay, now you've gone off the deep end
11:22:43 <seydar> yummmm
11:22:47 <luite> > error (show $ length [1..])
11:22:51 <lambdabot>   mueval-core: Time limit exceeded
11:23:10 <dafis> > fix error
11:23:11 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:23:28 <kyagrd> Is there a good way to derive template haskell Lift class?
11:23:38 <c_wraith> > iterate error "foo" !! 13
11:23:39 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:23:40 <jmcarthur> huh, error is strict?
11:23:53 <c_wraith> error can't be strict, if fix error works
11:23:59 <jmcarthur> > error (let x = x in x)
11:24:03 <lambdabot>   mueval-core: Time limit exceeded
11:24:10 <kyagrd> In fact I only need to derive it for variables 
11:24:15 <chrisdone> > fix ("developers "++)
11:24:16 <lambdabot>   "developers developers developers developers developers developers develope...
11:24:22 <kyagrd> don't even have to bother for constructors
11:24:32 <seydar> jmcarthur: but do you see what i'm saying? I want to use BOTH languages, because ruby is better suited for somethings than haskell is
11:24:39 <jmcarthur> seydar: like what?
11:25:01 <luite> hmm, mueval has some interesting code to work around this issue
11:25:05 <chrisdone> Ruby's like violence
11:25:07 <seydar> personally, i find it better suited for web development and constructing UIs
11:25:19 <chrisdone> solves a lot of problems
11:25:22 <jmcarthur> nobodys perfect
11:25:52 <seydar> i actually view haskell as a badass fucking sword
11:26:06 <luite> chrisdone: did you see my tryhaskell mod?
11:26:09 <jmcarthur> chrisdone: referring to "XML is like violence. If it doesn't solve your problem, you're not using enough of it."
11:26:12 <seydar> that when i face a problem that's like "well well well i'm so big and complicated and i require a lot of cpu time"
11:26:12 <jmcarthur> ?
11:26:13 <chrisdone> luite: nope
11:26:20 <luite> chrisdone: http://80.126.200.96:8081/weblog/tryhaskell.mod/
11:26:28 <seydar> haskell comes along and makes mincemeat out of the fucker and then skullfucks him
11:26:34 <luite> chrisdone: try the functions 'plot1', 'mandel'
11:26:39 * jmcarthur debates whether to quote that or not
11:26:45 <seydar> whereas ruby is just like a little dagger. good for negotiations
11:27:58 <chrisdone> luite: cool. what are the types of plot1 and mandel?
11:28:06 <luite> chrisdone: Interactive
11:28:18 <jmcarthur> @quote fuck
11:28:18 <lambdabot> Spark says: i think the rule of thumb is that sets that fuck up the entirety of mathematics are not considered to be valid sets
11:28:28 <luite> chrisdone: which contains a json object with the requested gui elements
11:28:37 <luite> chrisdone: similar to Raphael
11:28:47 <jmcarthur> precedent has been set i guess
11:28:49 <chrisdone> ah, ok
11:28:58 <luite> chrisdone: I have some tests with raphael objects directly
11:29:05 <luite> chrisdone: 'set11', 'set10' etc
11:29:08 <mauke> preflex: quote * fuck
11:29:10 <preflex>  <jawnsy> fuck you Debian :(
11:30:02 <luite> chrisdone: but I probably need to rework the Raphael vector library, raphael is strange with repeated transformations
11:30:04 <osaunders> preflex: seen mauke 
11:30:04 <preflex>  mauke was last seen on #haskell 54 seconds ago, saying: preflex: quote * fuck
11:30:38 <chrisdone> luite: where's your blog?
11:30:50 <luite> chrisdone: so I think I'm going to do all the transformation in haskell, and just send the result (instead of complete javascript code of things like paper.circle(...).translate(...).scale(...).rotate(...)
11:30:54 <luite> chrisdone: nowhere yet :)
11:31:37 <ag> can somebody, please, explain and/or give an example that I can run in ghci:
11:31:38 <ag>  
11:31:39 <ag> -- p.273 | Strict left fold, similar to foldl' on lists.
11:31:39 <ag> foldA :: Ix k => (a -> b -> a) -> a -> Array k b -> a
11:31:41 <ag> foldA f s a = go s (indices a) --indices function returns a list of every index
11:31:44 <ag>     where go s (j:js) = let s' = f s (a ! j)
11:31:47 <ag>                         in s' `seq` go s' js
11:31:50 <ag>           go s _ = s
11:31:52 <luite> chrisdone: I removed your design because I wanted it to be skinnable with the jquery-ui wizard, not because I don't like yours ;)
11:31:53 <ag>  
11:33:03 <chrisdone> luite: I'm just waiting for you to rewrite the console library and then you'll have re-done everything ;-)
11:33:06 <seydar> hey question
11:33:16 <seydar> if i implement a stateful VM in haskell
11:33:24 <seydar> it will, in the end, be stateless, right?
11:33:26 <dafis> ag: foldA f z ar == foldl' f z (elems ar)
11:33:38 <luite> chrisdone: actually I still use a lot of your javascript code :)
11:33:38 <chrisdone> seydar: why?
11:33:45 <seydar> chrisdone: i'm just thinking
11:33:54 <chrisdone> don't fink, feeeel
11:34:00 <luite> chrisdone: although I have to admit that I keep replacing things :p
11:34:02 <seydar> in short: i can do stateless on top of stateful. can i do stateless on stateful?
11:34:14 <seydar> chrisdone: hahaha. i feel like the answer is no
11:34:14 <chrisdone> luite: as long as you're having fun that's all that counts ;D
11:34:52 <luite> chrisdone: but I'm not sure what to do with the console, is it really possible that works much better than yours? The most important thing i'd like to have is copy/paste support
11:35:15 <luite> but I'm afraid that would have other disadvantages
11:35:44 <seydar> chrisdone: so what do you FEEEL? is it possible to do stateful on top of stateless? you can fake it, obviously, but can it be REAL?
11:36:08 <seydar> what is real?
11:36:11 <seydar> how do you define "real"?
11:36:24 <chrisdone> luite: paste is actually trivial to do, there's a hidden input box that picks up key presses. if you paste into this it could detect the change. copy is already done...
11:36:45 <jmcarthur> seydar: what is the difference between stateful and stateless, really? does it matter?
11:36:48 <luite> chrisdone: would it also accept paste from the context menu?
11:36:51 <osaunders> mauke: I think I did it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28640#a28640
11:37:01 <chrisdone> luite: I'm afraid not
11:37:25 <seydar> jmcarthur: the difference, to me, is how they are represented in memory
11:37:42 <jmcarthur> seydar: "statefulness" is an abstract concept. you can write stateful code in a pure language just like you can do the opposite
11:37:49 <seydar> aha. that would be why haskell is said to be "stateless **by default**"
11:38:00 <chrisdone> luite: but yeah, there are already console libs that have a real text box for the input. I made mine like that to encourage people to type stuff out themselve
11:38:02 <seydar> jmcarthur: you mean with monads?
11:38:16 <luite> chrisdone: I'll look around a bit, thanks :)
11:38:18 <jmcarthur> well, pure haskell is stateless, but you can build a stateful abstraction, monadic or not
11:38:24 <ag> dafis: thanks, I'll work on this
11:38:29 <FunctorSalad> stateful processes are routinely encoded in (static) mathematics
11:38:33 <chrisdone> seydar: no.
11:38:44 <FunctorSalad> similar thing...
11:39:01 <seydar> EXPLAINE YOUR BLACKE MAGICK
11:39:08 <osaunders> @quote refreshing desert
11:39:09 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
11:39:09 <jmcarthur> seydar: consider a finite state diagram, for example. that is a stateless representation of a stateful idea
11:39:20 <chrisdone> FunctorSalad: I wrote a little bash script that changes my wallpaper and the brightness at 5 minute intervals today. my emacs is in a semi transparent terminal. ^__ ^
11:39:24 <luite> chrisdone: I'll github the code for Graphics.Raphael and Interactive later, when it works better. they don't depend on the json webservice, so they should probably work with your programs
11:39:46 <luite> chrisdone: but Graphics.Raphael uses unsafePerformIO to write bitmaps
11:39:56 <luite> since IE doesn't support bitmaps in the json response
11:40:08 <luite> it's hidden from the user, but still ugly
11:40:21 <FunctorSalad> actually both even use the concept of a time-evolution function, sort of (State s () = s -> ((), s) *nudge*))
11:40:35 <jmcarthur> seydar: you can even look at source code written in an imperative language for an example of statelessness. the code itself, that is.
11:40:42 <osaunders> kmc: Is this right? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28640#a28640
11:40:50 <seydar> jmcarthur: ok. I understand now that you can build a stateful *abstraction* in a pure language
11:40:54 <FunctorSalad> that it may be continuous or noncomputable in physics aside :p
11:41:02 <seydar> jmcarthur: but what about having mutable and stateful memory?
11:41:16 <chrisdone> luite: cool cool. I probably won't be updating tryhaskell for a long time. got other fish to fry! namely, the state of Haskell in Emacs
11:41:18 <jmcarthur> seydar: and in fact, the IO monad kind of works that way. you construct "programs" by evaluating pure expressions, then the runtime executes them
11:41:54 <jmcarthur> seydar: and the programs you construct are stateless representations of stateful ideas
11:42:08 <FunctorSalad> chrisdone: boring! 5 deciseconds
11:42:48 <dafis> osaunders: that's correct
11:43:04 <jmcarthur> seydar: anyway, my point in all this is that there is not a big difference. more important than stateful vs. stateless is purity vs. impurity, IMO
11:43:07 <luite> chrisdone: oh I'll just keep hacking on this then. graphics, sliders etc may not be very important for tryhaskell, but I want to use it for things similar to the mathematica demonstratiosn projects
11:43:19 <EvanR-work> seydar: IO ST State StateT, all stateful abstractions
11:43:26 <osaunders> dafis: Can the wording be improved?
11:43:46 <jmcarthur> EvanR-work: it's important to point out that you don't need a monad to consider something as a state abstraction
11:43:58 <dafis> osaunders: Sure, but I'm not a brilliant wordsmith
11:44:01 <EvanR-work> C code runs on a virtual machine which is a big stateful abstraction
11:44:02 <chrisdone> luite: yup
11:44:04 <FunctorSalad> chrisdone: but that aside, what's the connection...? that your bash script is itself static?
11:44:25 <jmcarthur> those are all monads, but even a simple function can represent a "state transition" when you squint your eyes at it
11:44:52 <jmcarthur> where using its result later is using the new state, and using its original input is like "undo"
11:45:04 <seydar> jmcarthur: your point was well made. I see what you are saying now, and i see what I was trying to say
11:45:18 <luite> chrisdone: by the way, where do you publish that emacs code?
11:45:23 <FunctorSalad> hmm not really more squinting than with the pure State monad imho
11:45:23 <seydar> jmcarthur: because mutable, stateful memory is the definition of pure, isn't it?
11:45:38 <jmcarthur> FunctorSalad: indeed not
11:45:51 <EvanR-work> if everything can be stateful or not, then it loses meaning
11:46:04 <EvanR-work> the idea is to think about it in a way that makes the most sense and call it that
11:46:27 <jmcarthur> seydar: pure basically means referentially transparent. it's kind of a separate meaning from statefulness, although contextual statefulness can have an effect on whether an expression is considered pure or not
11:47:09 <seydar> jmcarthur: once more, in english?
11:47:35 <jmcarthur> seydar: referentially transparent = you can replace an expression with its result without changing semantics
11:47:56 <dpratt71> how to log what 'cabal configure' is doing?
11:48:06 <Berengal> ST is stateless outside of runST, but stateful inside
11:48:08 <seydar> jmcarthur: what's an example of impure then?
11:48:08 <jmcarthur> seydar: and when i say "contextual statefulness" i mean "where (stateful) context influences the result of an expression"
11:48:13 <FunctorSalad> hmm statefulness seems to prevent purity in practice since you can't really control the huge implicit state in practice
11:48:15 <FunctorSalad> *blah*
11:48:23 <EvanR-work> seydar: rand()
11:48:41 <FunctorSalad> (even though you can model the state of a stateful language statelessly in principle)
11:48:51 <chrisdone> if a function f is referentially transparent, then f x = f y where x = y
11:48:52 <chrisdone> a function g, if not referentially transparent, the above law isn't true
11:49:13 <EvanR-work> i.e. its not a function!
11:49:38 <roconnor> Informatica gaat net zomin over computers als astronomie over telescopen.
11:49:46 <EvanR-work> a contextually dependent expression
11:49:49 <roconnor> -- Dijkstra
11:51:00 <Berengal> Dijkstra was an angry old man.
11:51:10 * hackagebot th-lift 0.3.1 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.3.1 (KiYungAhn)
11:51:12 <seydar> so mutability is not the same as purity?
11:51:21 <seydar> even just a little bit?
11:51:23 <dolio> I think a better explanation of referential transparency would be (let x = e in e') = e'[x := e].
11:51:23 <kyagrd> Hackage is so cool
11:51:24 <jmcarthur> it depends on how you define mutability
11:51:32 <roconnor> seydar: Basic is (almost) a pure langauge
11:51:32 <chrisdone> Berengal: that quote didn't have much to do with his anger or age, though :P
11:51:38 <kyagrd> I just made a backport to lower version of th-lift
11:51:39 <jmcarthur> it is?
11:51:45 <roconnor> I think so
11:51:49 <Berengal> chrisdone: It does a little with his anger.
11:51:53 <jmcarthur> brb
11:52:00 <chrisdone> well, SICP make the same claim
11:52:09 <chrisdone> is SICP an angry book?
11:52:12 <dolio> f x = f y when x = y is a statement that function application respects whatever equality is being referred to.
11:52:22 <Berengal> Only a little
11:52:23 <kyagrd> th-lift 0.4 dosn't compile on ghc-6.12 so copied the change I needed in 0.3 and made 0.3.1 :)
11:52:26 <ski> EvanR-work : aka a non-extensional operation
11:52:39 <dafis> osaunders: my take at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28640#a28641
11:52:57 <EvanR-work> ski: non extensional?
11:52:59 <roconnor> wait, does pure mean side-effect free (like I think) or referentially transparent?
11:53:00 <chrisdone> dolio: thought someone would say that. blah
11:53:18 <Berengal> Dijkstra's other writings lead me to voice him saying it in an angry tone, whereas I voice SICP in a friendly tutor tone.
11:53:34 <dolio> That is, referential transparency says that you can inline or abstract arbitrary sub-expressions without changing the meaning of programs.
11:54:39 <Berengal> dolio: In computer programs, that means replacing a variable with it's definition and vice versa, no?
11:54:50 <osaunders> dafis: I prefer yours.
11:54:57 <dafis> :D
11:55:01 <dolio> Yes. That probably covers it.
11:56:13 <ski> EvanR-work : yeah, if `f' is an operation that computes representants for values of `B' from representants for values of `A', then that `f' is extensional means that for two representants `x0' and `x1' for values in `A', if those two representants `x0' and `x1' are equivalent relative to the equivalence relation for `A', then `y0' and `y1' (any two representants computed by `f' from `x0' and `x1') must be equivalent relative t
11:56:25 <travisbrady> Does anyone know where the code implementing priority search queues Johan Tibell mentions here http://blog.johantibell.com/2010/04/generational-garbage-collection-and.html is?
11:56:48 <EvanR-work> pure and referentially transparent are two different buzzwords, so lets use two defs. has or suffers side effects is sufficiently wordy to replace with something, call it pure. referentially transparent has already been explained ;)
11:56:57 <ski> @where purelyfunctional
11:56:58 <lambdabot> "What is a Purely Functional Language?" at <http://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps> by Amr Sabry, 1998
11:56:59 <ski> roconnor : ^
11:57:19 <roconnor> ski: but I want to know what Purely is independent of functional
11:57:41 <BMeph> p_l: Oops, had to do some work -- still on? :)
11:57:49 <ski> roconnor : iirc, Sabry propose definitions for both `pure' and `referentially transparent'
11:58:26 <dolio> He proposes that 'pure' is independence of evaluation strategy, up to bottoms.
11:58:41 <EvanR-work> ski: you were cut off
11:58:47 <ski> EvanR-work : at ?
11:58:49 <EvanR-work> must be equivalent relative t
11:59:02 <p_l> BMeph: still on
11:59:02 <ski> ".. must be equivalent relative to the equivalence relation for `B'"
11:59:07 <EvanR-work> ah
11:59:08 <roconnor> ski: I just see a definition of "purely functional"
11:59:13 <roconnor> Definition 4.7
11:59:22 <EvanR-work> interesting
11:59:47 <EvanR-work> why represetant and not representative ;)
11:59:58 <BMeph> EvanR-work: As an Arizonan, I'd like to re-specify "pure" as "having no undocumented system effects"... ;)
12:00:03 <dolio> I don't know if the definition of 'pure' makes sense independent of the language being functional.
12:00:12 * devinus is intimidated by all the computer sciency stuff in haskell
12:00:16 <roconnor> dolio: Basic is (almost) a side-effect free langauge
12:00:33 <copumpkin> devinus: it's the point!
12:00:35 <roconnor> BASIC I should say :)
12:00:37 <pikhq> dolio: Reasonable, really. Evaluation strategy only has anything to do with "purity" in that it's pretty insane to do anything but with certain evaluation strategies...
12:00:38 <copumpkin> we're here to scare you away
12:00:42 <devinus> :P
12:00:47 <EvanR-work> BASIC has 'print' ;)
12:00:56 <roconnor> EvanR-work: Haskell also has pring
12:00:57 <roconnor> print
12:01:28 <EvanR-work> if i remember basic, commands were executed sequentially
12:01:30 <roconnor> neither BASIC nor Haskell's print are side-effect.  They are upfront-effects.
12:01:31 <BMeph> p_l: Ah. You were saying that you had no problems using 64-bit Windows. I'm curious; what do you use for compiling wrappers of C libraries?
12:01:38 <EvanR-work> ah
12:01:40 <EvanR-work> tricky!
12:01:49 <roconnor> ML has side-effect, lots of them
12:01:50 <EvanR-work> front effects
12:02:26 <roconnor> You can almost see that BASIC is a "pure" language in that the BASIC monad is so easy to implement in Haskell.
12:02:44 <BMeph> EvanR-work "Front, back, and side-to-side"? ;)
12:02:57 <EvanR-work> side-by-side effects
12:03:00 <EvanR-work> new in windows vista
12:03:03 <Berengal> Programming Haskell is not side-effect free
12:03:49 <EvanR-work> roconnor: well seems this weakens the notion of side effect, necessarily i guess if we have input/output
12:04:13 <roconnor> side-effects are effect that occur on the side of evaluation.
12:04:34 <thoughtpolice> side effects to programming in haskell include: undescribable hatred for non statically typed languages like python, undying need for constant compiler approval
12:04:37 <roconnor> but in Haskell IO and in BASIC, effect occur on the front of execution.
12:04:44 <EvanR-work> lol
12:04:49 <thoughtpolice> it makes you a very dependent person, really
12:05:06 <EvanR-work> roconnor: what about read?
12:05:18 <roconnor> EvanR-work: read in Haskell?
12:05:27 <BMeph> p_l: For example, I have few problems compiling library wrappers with 32-bit libraries. I can even get source code to re-compile with a 64-bit toolchain. As for that toolchain, however... :(
12:05:44 <EvanR-work> roconnor: no, some way of getting user input in basic
12:05:49 <EvanR-work> or haskell
12:06:25 <EvanR-work> getC, when executed has the effect of dequeuing some queue
12:06:35 <EvanR-work> and begin evaluating a whole new expression with the result as input
12:06:53 <EvanR-work> is the dequeue not a side effect?
12:07:08 <roconnor> Well everything in Haskell is side-effect free
12:07:24 <roconnor> all IO in Haskell is a front-effect
12:07:35 <EvanR-work> how so
12:07:45 <EvanR-work> the dequeuing does not appear in the result of executing getC
12:07:56 <BMeph> EvanR-work: No "undocumented" effect workers! ;)
12:07:59 <ski> roconnor : hm, it appears the several definitions istr was probably the one Sabry references in the first section (and discusses later)
12:08:00 <roconnor> EvanR-work: sure it does
12:08:10 <roconnor> EvanR-work: it is right there in the output of getC
12:08:17 <roconnor> IO Char
12:08:20 <EvanR-work> so this is about documented behavior
12:08:29 <roconnor> I disagree with ski
12:08:34 <EvanR-work> IO Char could also have done any number of other things to compute that char
12:08:38 <roconnor> er
12:08:42 <roconnor> I disagree with BMeph
12:08:43 <roconnor> sorry ski
12:08:53 <ski> (?)
12:09:20 <roconnor> EvanR-work: Sorry, I mean it is right there in the value of the output of getC
12:09:24 <FunctorSalad> sorry for accidentally disagreeing with you, not to you for disagreeing with BMeph
12:09:30 <FunctorSalad> I think
12:09:39 <ski> dolio : btw, imo, any reasonable definition of "pure" which trancends "functional" should have Mercury falling under it
12:09:41 <roconnor> which is of type IO Char (and in particular isn't Char)
12:10:05 <roconnor> EvanR-work: a value of IO Char is a tree of system calls that produces a Char
12:10:10 <dolio> ski: I don't doubt that.
12:10:16 <EvanR-work> IO Char says nothing about dequeuing a specific queue somewhere
12:10:20 <roconnor> EvanR-work: The dequing operation is there in the tree of system calls.
12:10:23 <dolio> I'm not sure how well it extends to something like basic, though.
12:10:26 <jmcarthur> EvanR-work: State Char wouldn't either
12:10:39 <roconnor> EvanR-work: Sorry I should have said the value of the result of getC
12:10:50 <EvanR-work> value of the result of?
12:10:51 <tkahn6_> hmmm
12:10:59 <dolio> How many ways are there to evaluate basic? roconnor's argument is basically that there's one, because there is no evaluation in basic.
12:11:03 <tkahn6_> why is my output of: 
12:11:04 <tkahn6_> break odd [1..10]
12:11:04 <roconnor> EvanR-work: I only mentioned the type to clairify that the type isn't Char, so the value can contain more information than a char.
12:11:15 <tkahn6_> ([], [1,2,3,4,5,6,7,8,9,10])
12:11:23 <mauke> tkahn6_: because 1 is odd
12:11:26 <dafis> tkahn6_: because 1 is odd
12:11:29 <EvanR-work> ah right
12:11:30 <dolio> So purity would be trivial.
12:11:35 <mauke> oddmind
12:11:35 <tkahn6_> oh
12:11:45 <roconnor> dolio: Just like in Haskell, BASIC starts executing statement (and as a side-effect of execution, some functions might get evaluated)
12:11:51 <EvanR-work> IO Char could be (get from queue 77) or (choose randomly) or (just 'c')
12:11:57 <tkahn6_> i thought break did something else
12:11:58 <roconnor> Arguably it is evaluation that is the side-effect in Haskell.
12:11:59 <tkahn6_> :)
12:12:09 <dafis> tkahn6_: span?
12:12:23 <roconnor> EvanR-work: yes, but the value of getC includes syscalls to dequeue the character
12:12:24 <dafis> > span odd [1 .. 10]
12:12:25 <lambdabot>   ([1],[2,3,4,5,6,7,8,9,10])
12:12:44 <EvanR-work> getC's definition
12:12:51 <roconnor> EvanR-work: if IO wasn't abstract you would even be able to print the tree and see the syscalls reified.
12:13:03 <zygoloid> FunctorSalad: i read it as "sorry, not BMeph, i mean it's ski i disagree with after all" at first ;)
12:13:09 <ski> > partition odd [0 .. 9]
12:13:10 <lambdabot>   ([1,3,5,7,9],[0,2,4,6,8])
12:13:12 <tkahn6_> oh
12:13:16 <tkahn6_> thats what i wanted!
12:13:19 <tkahn6_> thanks
12:13:19 <mauke> > filter odd [0 .. 9]
12:13:20 <lambdabot>   [1,3,5,7,9]
12:13:21 <EvanR-work> roconnor: so how does that apply to the equivalent in basic
12:13:50 * ski thought it was dafis who maybe wanted that .. :)
12:14:00 * shapr hugs Haskell
12:14:18 <roconnor> EvanR-work: BASIC are basically programs are essentially equivalent to programming only in the main do block in Haskell
12:14:19 * ski ghcs shapr
12:14:23 <tkahn6_> lol
12:14:39 <EvanR-work> roconnor: except 'getchar' or something says nothing about the side effects
12:14:51 * dafis yhcs ski
12:14:56 <EvanR-work> X = readchar
12:15:07 <EvanR-work> READCHAR ;)
12:15:27 * ski decompiles ski to lambda calculus, only to recompile into super-combinators
12:15:31 * EvanR-work turns on capslock in order to discuss basic
12:15:56 * ski waves hands in the general direction of augustss
12:16:05 <mauke> preflex: quote * SELECT
12:16:07 <preflex>  <jcreigh> SELECT * FROM FooBar WITHOUT IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
12:16:22 <EvanR-work> ski: you just decompiled yourself
12:16:47 <ski> EvanR-work : but i recompiled to more efficient combinators, then !
12:16:54 <roconnor> EvanR-work: in an idealized basic only statements would have effects
12:16:59 <mauke> :t ap const it
12:17:00 <lambdabot> Not in scope: `it'
12:17:03 <mauke> :t ap const id
12:17:03 <lambdabot> forall b. b -> b
12:17:09 <kyagrd> some obvious TH Lift instances for Haskell standard library types are missing ... Ratio, Array, Double
12:17:13 <roconnor> And so the effects wouldn't be on the side of evaluation of functions
12:17:50 <kyagrd> Has anyone wrote th-missing-instnaces package yet?
12:18:02 <EvanR-work> how do you separate the notion of evaluating a pure function from getting a char if both are both 'front effects'
12:18:20 * ski remembers `DEF FNRECIPROCAL(X) = 1/X' in (C64) BASIC
12:18:33 <EvanR-work> haha
12:18:35 <roconnor> EvanR-work: it's easiest to see this constrasted to ML
12:18:43 <roconnor> EvanR-work: print in ML is a side effect
12:18:53 <roconnor> it happens whenever evaluation gets around to the print statement
12:19:01 <EvanR-work> print... statement?
12:19:06 <ski> (.. or elaboration, for that matter)
12:19:07 <roconnor> print funciton I mean
12:19:08 <roconnor> :)
12:19:11 <EvanR-work> ah
12:19:14 <FunctorSalad> {-# LANGUAGE CPP #-} ; #define FNRECIPROCAL(X) (1 / fromIntegral (X))
12:19:21 <roconnor> ML's print funciton evaluates to ()
12:19:25 <kyagrd> ML doesn't have statement it's just evil side effect of an expression :)
12:19:26 <EvanR-work> print can be in any nesteed expression and something is printed when it evaluates to () or something
12:19:29 <roconnor> on and by the way, it prints something to the screen
12:19:43 <roconnor> But in Haskell the effects are part of the value of the output of print
12:19:49 <EvanR-work> so in basic, you cant have PRINT in a function definition?
12:20:09 <kyagrd> EvanR-work: you can
12:20:10 <roconnor> EvanR-work: not only that but there are no function defintions in BASIC at all
12:20:21 <mauke> FOR FNRECIPROCAL KTHX 1/\@
12:20:30 <EvanR-work> it has rewrite rules?
12:21:29 <roconnor> EvanR-work: I'd say BASIC has no rewrite rules.  Technically everything has rewrite rules though
12:21:32 <kyagrd> basic has sub (for subroutine) I believe?
12:21:41 <ski>   fun square_and_print x = let val y = x*x in y before print (Int.toString y) end
12:21:50 <kyagrd> Well old basic didn't even have SUB only GOTO and statement numbers
12:21:57 <EvanR-work> sub must be in newer iterations
12:22:01 <EvanR-work> and gosub
12:22:36 <roconnor> EvanR-work: INPUT$ is a basic funciton with a side-effect
12:22:45 <ski> kyagrd : `GOSUB <numeral>', `ON <expression> GOSUB <numeral>{,<numeral>}'
12:22:45 <roconnor> You'd have to remove that in idealized BASIC
12:22:55 <EvanR-work> why is it a side effect
12:23:28 <ski> roconnor : in the BASIC i know, `INPUT' is a command, not a function
12:23:35 <roconnor> INPUT is fine
12:23:43 <roconnor> INPUT$ is problematic
12:23:44 <EvanR-work> what does it do
12:23:47 <EvanR-work> they 
12:24:00 <EvanR-work> maybe we should go to #basic ;)
12:24:31 <roconnor> INPUT$(n) reads n characters (as a side-effect) and returns a (string?) value
12:24:46 <roconnor> If I understand this GW-BASIC manual correctly
12:24:54 <ski> (hm .. `RND' (and `FREE') would be problematic functions in C64 BASIC, i suppose)
12:25:02 <roconnor> but the point is that INPUT$ occurs as a function in the grammer of the language
12:25:05 <p_l> BMeph: ah, regarding compiling, I usually do windows stuff in .NET or use 64bit libs
12:25:14 <roconnor> while INPUT occurs ass a statement in the grammer of the language
12:25:18 <roconnor> as
12:25:18 <EvanR-work> roconnor: ah documented behavior ;)
12:25:21 <mauke> grammar
12:25:31 <p_l> (cause one of my tools works *only* in 64bit mode on win64, 32bit crashing immediately)
12:25:31 <roconnor> It's not about documentation
12:25:40 <CalmNelly> it's about ass
12:25:46 <roconnor> It's about the way you put programs together
12:25:59 <EvanR-work> whats the difference between a built in statement or built in function
12:26:11 <EvanR-work> besides the docs
12:26:23 <ski> that one is a function, the other a command ?
12:26:25 <CalmNelly> @vixen Do a lot of guys hit on you?
12:26:25 <lambdabot> me?
12:26:34 <roconnor> EvanR-work: statement and functions have deferent types of denotations
12:27:03 <CalmNelly> @vixen yes, you.
12:27:04 <lambdabot> you agree?
12:27:22 <kyagrd> FunctorSalad: since you are here, let me confirm.  Are you okay with using patch-tag for shared repositofy for development?
12:27:25 <EvanR-work> suddenly i want to write a basic
12:27:35 <kyagrd> FunctorSalad: for logic-TPTP
12:28:18 <FunctorSalad> kyagrd: yes, I saw it (but apparently you've done everything already?)
12:28:29 <FunctorSalad> except the not-whole-line comments
12:28:39 <roconnor> statements denote system calls and mutation of global state and are sequenced by line numbers (or ; in other langauges)
12:28:59 <Phyx-> boy this is getting me no where fast
12:29:26 <kyagrd> FunctorSalad: it needed a really simple change (renaming one variable) so I did that one. Planning for more major change about dealing with comments though
12:29:55 <roconnor> functions map primitive values to primitive values (in functional langauges functions are also primitive values) and are combined by composition with other functions and finally composed into parameters for statements. 
12:30:28 <jonafan> how do threads work in haskell? for example, if you have one thread listening to a user interface and one thread listening to a bunch of sockets?
12:30:38 <EvanR-work> so you can compute a value by putting INPUT$ deep in an expression
12:30:48 <EvanR-work> and print it
12:30:57 <roconnor> Yes, you can put INPUT$ deep into an expression
12:31:05 <EvanR-work> but not INPUT
12:31:10 <roconnor> but INPUT can only occur at the beginning of a line
12:31:15 <EvanR-work> ah
12:31:24 <EvanR-work> so whats the point of INPUT$ ;)
12:31:28 <EvanR-work> 'convenience' ?
12:31:29 <roconnor> This is enforced by the grammer.
12:31:33 <roconnor> which is nice
12:31:52 <copumpkin> omg grammar
12:31:54 <roconnor> EvanR-work: INPUT$ is used to write confusing programs :P
12:31:59 <roconnor> grammar
12:32:05 <copumpkin> sorry :P
12:32:08 <roconnor> np
12:32:13 <kyagrd> FunctorSalad: but before that I wil make some routine changes about cabal file and LANGUAGE pragmas ... (especially eliminating fglasgow-exts)
12:32:30 <roconnor> EvanR-work: I think there is a (usually) a clear distiction between evaluation and execution.
12:32:31 <FunctorSalad> kyagrd: alright
12:32:40 <roconnor> execution asks, what system call to preform next
12:32:57 <roconnor> evaluation asks, what is the normalized form of this value?
12:33:02 <ski> EvanR-work : apparently instead of typing `INPUT A$ : LET B$ = A$ + "!"' you can type `LET B$ = INPUT$ + "!"' .. or something like that, anyway
12:33:29 <roconnor> ski: something like that
12:33:34 <EvanR-work> roconnor: this model seems to be nice. have two halves of the language, the command language and the calculator language. the command language lets you do what i thought were side effects (now called front effects :), calculator would be a function language
12:33:38 <ski> (i.e. modulo the reading a specified number of input characters)
12:34:04 <EvanR-work> the command language is at the top level and uses the calculator language
12:34:06 <roconnor> EvanR-work: the effects are just called effects (IMHO)
12:34:28 <roconnor> EvanR-work: the question of whether they are front-effect or side-effect depends on how execution and evaluation are tied together
12:34:28 <EvanR-work> like haskell IO
12:35:11 <EvanR-work> haskell is cool because you can compute commands themselves using the functional language ;)
12:35:30 <roconnor> in haskell and in idealized BASIC evaluation is driven by execution; in ML execution is driven by evaluation.
12:35:52 <EvanR-work> yes ive seen that too
12:35:56 <ski> (roconnor : .. and elaboration)
12:36:00 <EvanR-work> that could get messy
12:36:13 <roconnor> ski: what is elaboration?
12:36:32 <EvanR-work> and in C execution and evaluation are all mixed together in a blender
12:36:35 <fryguybob> jonafan: Can you make your question more specific?
12:36:44 <roconnor> EvanR-work: still BASIC is a crummy language.  Not being able to define your own functions is quite annoying.
12:36:57 <ski> roconnor : elaboration declarations, so as to bring identifiers into scope (doing this can also have side-effects)
12:37:01 <jmcarthur> EvanR-work: actually i'd say it's still execution driven by evaluation
12:37:13 <ski> s/elaboration declarations/elaborating declarations/
12:37:27 <roconnor> ski: I don't quite follow.  Can you give a simple example?
12:38:40 <ski> roconnor : e.g. to evaluate `let <decl> in <expr> end' you first elaborate `<decl>' producing bindings (and possibly having side-effects), augmenting the environment with those bindings, and finally evaluate `<expr>' in that augmented environment
12:38:47 <EvanR-work> so called 'expression languages' must use the evaluation -> execution model, i guess? maybe not since haskell program is an expression
12:39:03 <EvanR-work> or maybe thats how to think of haskell execution
12:39:15 <roconnor> ski: interesting. Does that happen in BASIC or C?
12:39:18 <EvanR-work> evaluation -> execution -> repeat
12:39:35 <ski> roconnor : another example is `structure IntSet = MakeSet IntComparision' which creates a module `IntSet' by applying the module function `MakeSet' to the module `IntComparision'
12:39:41 <zygoloid> @hoogle (m a -> m a) -> t m a -> t m a
12:39:41 <lambdabot> Data.Map alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
12:40:31 <roconnor> EvanR-work: haskell is an expression language, but I think your ituition is mostly correct.  It is quite surprising that Haskell manages to both be an expression language and be side-effect free
12:41:10 <ski> roconnor : in some extensions to SML (also in OCaml, iirc), such module function (aka "functor") application can happen at run-time, depending on function arguments : `fun foo x = let structure M = MakeFoo (struct fun g y = ..x..y.. end) in .. M.h .. end'
12:41:25 <roconnor> isn't that a side-effect of MakeFoo?
12:41:33 <ski> which ?
12:41:43 <osaunders> Anyone heard of this http://www.amazon.co.uk/Pattern-Calculus-Computing-Functions-Structures/dp/3540891846/ref=sr_1_1?ie=UTF8&s=books&qid=1281123572&sr=8-1 ?
12:42:32 <roconnor> MakeFoo is on the RHS so it seems like any effect would be side-effect of evaluation rather than of declariation elaboration.
12:42:34 <EvanR-work> roconnor: back to the distinction between 'effects'... you call the result of a pure function an effect?
12:42:58 <roconnor> EvanR-work: We have only been talking about one class of effects
12:43:10 <ski> `MakeFoo' constructs a new module (anonymous, byt locally named `M', here), from the (anonymous) module `struct ... end', possibly creating new types as well as values in the process .. then they can be accessed in the local scope
12:43:10 <EvanR-work> which are
12:43:15 <roconnor> EvanR-work: the question is about when they occur
12:43:50 <EvanR-work> which class of effects
12:43:51 <ski> roconnor : but, yes, part of the point was that this new module construction business can have side-effects : initializing some local mutable state internal to the module, say
12:43:55 <roconnor> EvanR-work: I'd say effects as we have been talking  about them are system calls (but I reserve the right to ammend my definition when confronted with inconsistencies)
12:44:06 <EvanR-work> heh
12:44:10 <EvanR-work> permission denied!
12:44:15 <roconnor> doh
12:44:26 <Phyx-> use sudo!
12:44:32 <roconnor> ski: is module construction not part of the evaluation model?
12:44:40 <roconnor> sudo reserve rights
12:44:51 <zygoloid> is there a name for a monad transformer t equipped with fmapT :: Monad m => (m a -> m b) -> t m a -> t m b ?
12:44:53 <ski> roconnor : note that `MakeFoo (...)' is not an expression .. or rather, not a value expression. it is a module expression (which is a completely different syntactic category)
12:44:54 <roconnor> Password: hunter1
12:44:55 <Heffalump> osaunders: yes, I've heard of it. I'd like to buy it but not at that price.
12:44:55 <EvanR-work> roconnor: but also the effect of assigning a value to a variable
12:44:59 <zygoloid> if not, what do people think of MonadTransFunctor ? :)
12:45:22 <ski> roconnor : evaluation of expressions and elaboration of declarations are intertwined
12:45:24 <Phyx-> roconnor: did you know that passwords show up on irc as *********?
12:45:26 <roconnor> ski: I see your point.  For this argument I might simply call a module a different type of expression if I can be so bold.
12:45:33 <roconnor> Phyx-: I do
12:45:39 <zygoloid> roconnor: when you typed hunter1 there we all saw *******
12:45:45 <roconnor> zygoloid: good
12:45:47 <roconnor> ;)
12:46:09 <osaunders> Heffalump: You can read about 20 pages on here: http://books.google.ca/books?id=Q_J4Lnmfjx4C&printsec=frontcover#v=onepage&q&f=false
12:46:10 <Heffalump> though I see it's available for £45, which looks a bit more attractive
12:46:14 <ski> roconnor : it's just that you used "evaluation" for expressions and "execution" for commands; it only seemed fair to mention "elaboration" for declarations, then
12:46:25 <roconnor> ski: is that how they call it in ML?
12:46:30 <EvanR-work> roconnor: so does evaluating (pure) functions count as an effect, or is it effect free
12:46:43 <roconnor> EvanR-work: I'd call it effect free.
12:46:51 <jmcarthur> it would suck you set your password to a common word. every time you type *** password in everybody would see *** stars and guess what *** the word is from *** context
12:46:59 <jmcarthur> oops
12:47:02 <jmcarthur> i messed that up :P
12:47:07 <jmcarthur> it would suck you set your password to a common word. every time you type *** password in everybody would see *** stars and guess what *** word is from *** context
12:47:12 <roconnor> :D
12:47:16 <Phyx-> :D
12:47:22 <jmcarthur> :D
12:47:31 <Twey> Haha
12:47:33 <EvanR-work> ive either missed or misunderstoof the above, what is elaboration?
12:47:46 <zygoloid> *********: that's right. fortunately i just set my password to something easy to remember
12:47:54 <ski> roconnor : well, the evaluation of `MakeFoo (struct ... end)' itself is a kind of evaluation of a module/structure expression (not the normal kind of expression) .. otoh, the declaration `structure M = MakeFoo (struct ... end)' there is *elaborated* .. it's just a matter of different terminology for different syntactic classes
12:47:55 <zygoloid> *********: like my secret internet lover's /nick.
12:47:56 <roconnor> EvanR-work: apparently elaboration is like evaluation but producing modules instead of normal values
12:48:02 <roconnor> modules in ML
12:48:02 <Twey> xD
12:48:06 <jmcarthur> heh
12:48:17 <zygoloid> jmcarthur: oops, sorry, that was for you
12:48:30 <Phyx-> missing the ******* there :P
12:48:34 <ski> roconnor : commands are executed for effects only, expressions are evaluated to yield a value, declarations are elaborated to yield a binding environment
12:48:38 <zygoloid> Phyx-: where?
12:48:39 <jmcarthur> i think that was the point, Phyx- 
12:48:50 <Phyx-> i know
12:48:51 <EvanR-work> at what point would this elaboration operation take place
12:48:54 * copumpkin just encoded GADTs with type families and existential types
12:49:01 <roconnor> ski: binding environment to look up say function calls?
12:49:03 <jmcarthur> copumpkin: ?
12:49:05 * Phyx- is just 10 instances away from being done
12:49:06 <jmcarthur> i wanna see it
12:49:17 <copumpkin> jmcarthur: just let me clean it up a sec
12:49:20 <Heffalump> copumpkin: how do you get Eq?
12:49:21 <jmcarthur> Phyx-: you are never "done" writing instances
12:49:25 <roconnor> ski: does this give you lisp style dynamic binding?
12:49:39 * zygoloid just encoded incoherent instances with GHC-as-a-library and MonadPlus
12:49:41 <copumpkin> Heffalump: just a sec, I'll try
12:49:42 <Phyx-> jmcarthur: I'll be done with these :P
12:49:49 <zygoloid> (not even joking about that...)
12:49:50 <ski> roconnor : in Haskell, `let x = 0; f y = x + y in ..x..y..', the `x = 0; f y = x + y' part could be said to be elaborated to yield bindings for `x' and `y', to reuse the ML terminology
12:49:57 <Phyx-> jmcarthur: atleast untill the GHC internals change again
12:49:57 <jmcarthur> actually i guess you could be if you just do instance Foo a
12:50:23 <roconnor> bindings for `x' and `f'
12:50:32 <ski> s/`x' and `y'/`x' and `f'/ (i thought i fixed that, grmbl)
12:50:38 <EvanR-work> the above elaboration could result in a graph to be reduced?
12:50:43 <EvanR-work> since its letrec
12:51:24 <ski> roconnor : i'm not sure what you mean by "lisp style dynamic binding" .. there's no "dynamic scope (actually extent)" here
12:51:26 <EvanR-work> rather than a binding environment
12:51:37 <jmcarthur> i actually can make a guess at what copumpkin is doing
12:51:39 <jmcarthur> neat idea
12:51:49 <ski> roconnor : the same terminology could be used in Haskell as well, except that elaborating declarations in Haskell can't have side-effects
12:51:49 <copumpkin> it's a real pain to work with though
12:51:53 <copumpkin> I wish I had agda holes 
12:52:10 <copumpkin> oh, implicit parameters can sort of work as those
12:52:11 <roconnor> ski: wait, when are Haskell binding elaborated?
12:52:38 <EvanR-work> i figured let x = ... in ... was an expression to be evaluated
12:53:02 <ski> roconnor : in `let x = 0; f y = x + y in ..x..y..' the `x = 0; f y = x + y' declarations are elaborated to produce bindings for `x' and `f', when the whole `let'-expression is evaluated
12:53:30 <roconnor> ski:  but isn't that elaboration step a no-op?
12:53:41 <ski> roconnor : of course, since that's lazy bindings, the values for `x' and `f' won't be computed yet, but you can still pass `x' and `f' to functions in the body, e.g.
12:53:41 <lispy> EvanR-work: if x is a pattern, I'm not sure how the evaluation happens.
12:53:51 <lispy> > let () = undefined in 1
12:53:52 <lambdabot>   1
12:54:08 <roconnor> ski: okay. I think I understand, barely
12:54:09 <lispy> > let (Just x) = undefined in x
12:54:10 <ski> roconnor : in implementation terms, you'd need to create thunks (or whatever you use)
12:54:10 <lambdabot>   *Exception: Prelude.undefined
12:54:14 <EvanR-work> lispy: thats how
12:54:34 <ski> roconnor : also, you need to augment the static environment
12:54:34 <roconnor> lispy: that is a bit more interesting
12:54:52 <EvanR-work> > let (x,y) = 6 `divMod` 5 in y
12:54:53 <lambdabot>   1
12:55:22 <roconnor> ski:  so evaluating going under let expressions can have side-effect in ML?  Are you saying opening a module is like a let statement?
12:55:26 <lispy> IIRC, using let like this you can get he same semantics as irrefutable patterns
12:55:56 <copumpkin> Heffalump, jmcarthur: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28642#a28642
12:56:07 <copumpkin> no eq yet, or pattern matching, so not sure if it's actually equivalent in haskell
12:56:08 <lispy> foo x = let Just y = x in e == foo ~(Just y) = e
12:56:12 <roconnor> > let (a,(b,c)) = (1,(1,undefined)) in b
12:56:13 <lambdabot>   1
12:56:16 <lispy> Or something close to that?
12:56:25 <EvanR-work> lispy: youre saying its not an expression?
12:56:52 <ski> roconnor : sure, evaluating an expression can have a side-effect. elaborating a declaration can cause an expression to be evaluated, and thus can have a side-effect. (also evaluating an expression can cause a declaration to be elaborated, as i exemplified above)
12:57:07 <roconnor> ski: oh right
12:57:11 <lispy> EvanR-work: let ... in ..., is a expression.  But it's an expression that might do some pattern matching
12:57:20 <copumpkin> Heffalump, jmcarthur: the issue is not bringing the context of equality into scope with normal datatypes :/
12:57:23 <EvanR-work> yes, like case
12:57:28 <Heffalump> I see no type families
12:57:34 <copumpkin> Heffalump: just for ~
12:57:41 <Heffalump> I see
12:57:47 <ski> roconnor : a module groups a couple of declarations together into a module expression (usually, but not always bound to a name, in a module declaration)
12:59:09 <ski> roconnor : a module is a bit like a record, except it can contain not only value declarations, but also type declarations, (exception declarations,) and other module declarations .. and a module expression is not an expression, it's a different syntactic category
13:00:44 <Heffalump> copumpkin: I don't really follow what's going on there. SPf handles type-level decrement?
13:01:39 <copumpkin> SPf f n is a proof that n is the successor of some value b, and also carries f applied to that value
13:01:52 <ski> roconnor : .. hopefully i managed to clear you up more than confuse you ..
13:02:18 <eugenn> what was ML?
13:02:19 <roconnor> ski: I'm neither more clear nor confused
13:02:33 <copumpkin> Heffalump: so for example, you couldn't make a value of SPf f Z
13:02:39 <copumpkin> Heffalump: well, without using bottom, anyway
13:02:59 <roconnor> ski: I'm mostly aware of ML modules, I know opening modules can have side effects ahh
13:03:04 <copumpkin> (this means that Fin Z is basically uninhabited, minus bottom)
13:03:12 <fryguybob> @where ML
13:03:13 <lambdabot> I know nothing about ml.
13:03:21 <roconnor> opening modules has side-effect because the let bindings are evaluated!
13:03:21 <fryguybob> :D
13:03:28 <roconnor> which can cause executions
13:03:31 <jonafan> sorry fryguybob, i went afk because it didn't look like anyone was paying attention to me
13:03:35 <roconnor> now I see how let fits into the picture
13:03:47 <jonafan> i had the question about threads in haskell
13:04:00 <roconnor> ski: but ML's top-level let bindings feel quite different than Haskell let expressions.
13:04:06 <jonafan> basically, i am wondering how the overall structure of something like an IRC client would look
13:04:18 <roconnor> ML's top level let bindings are more like let statements in do notation
13:04:21 <roconnor> right?
13:04:32 <napping> hmm?
13:04:32 <ski> (roconnor : in SML, module declarations can be elaborated fully at link-time (because you can't say `let structure M = MakeFoo (struct ... end) in ..M.. end', i.e. modules can't depend on run-time values) .. but in extensions in SML/NJ e.g., or in OCaml (iirc), they generalize to allow precisely this kind of run-time dependency, so elaboration of modules can't always be done before run-time)
13:04:36 <eugenn> ML = Monad Loader? xD
13:04:37 <Heffalump> roconnor: sort of, but they can have side-effects
13:04:45 <roconnor> (of course Haskell's let statement in do are lazy (and side-effect free))
13:04:48 <EvanR-work> eugenn: magical language ;)
13:04:48 <napping> roconnor: let's in do notation are just sugar for normal lets, that doesn't add indentation
13:04:49 <Heffalump> eugenn: Meta Language. The first statically type functional programming language.
13:04:51 <jonafan> typically i'd have a thread with a socket listening to an IRC server
13:04:58 <eugenn> oh thanks
13:04:59 <jonafan> and a thread listening to the user interface
13:05:12 <napping> roconnor: maybe you mean <-? ML let is reasonably similar to a bind, I think
13:05:18 <roconnor> napping: true but I'm looking through my Kleisli goggles.
13:05:21 <napping> shadowing, evaluation, etc.
13:05:26 <c_wraith> jonafan: you'd do the same in haskell.
13:05:31 <Heffalump> copumpkin: I see. But can you ever get type refinement from a value?
13:05:50 <jonafan> how do you get the two threads to coordinate in a referentially transparent way
13:06:03 <EvanR-work> jonafan: not a listening socket in bsd sockets jargon
13:06:04 <napping> Heffalump: by pattern matching, sure. data Eq a b where Refl :: Eq a a
13:06:12 <copumpkin> Heffalump: I think the existential will give you that, but I'm trying to figure out
13:06:16 <EvanR-work> but a connected socket
13:06:18 <copumpkin> napping: that's what I'm trying to avoid :P
13:06:20 <c_wraith> Jonafan, you don't, really.  You use MVar, or Chan, etc.  They are explicit communication mechanisms
13:06:23 <jonafan> sorry, yeah
13:06:28 <roconnor> napping: okay, I'll go back to saying that ML's top level let *statements* are quite different from Haskell's let *expressions*
13:06:32 <EvanR-work> jonafan: MVar is awesome
13:06:50 <jonafan> do both threads have their own thing to unroll their IO monads?
13:07:03 <EvanR-work> yes
13:07:08 <c_wraith> jonafan: start with forkIO and MVar
13:07:10 <Heffalump> napping: copumpkin is claiming to have simulated GADTs with type families and existentials.
13:07:11 <ski> roconnor : yes, a sequence of declarations in SML is elaborated one at a time, using the augmented environment from the previous declaration to elaborate the next, and then augmenting that .. there are other forms to be used for (e.g. mutually) recursive and collateral declarations
13:07:19 <Heffalump> so I was asking about his simulation
13:07:21 <c_wraith> jonafan: those two are easy to use and understand
13:07:25 <jonafan> okay thanks
13:07:32 <copumpkin> Heffalump: well, it works in agda, and I'm trying to translate the basic concepts :)
13:07:41 <napping> jonafan: details on the runtime are here: http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/multicore-ghc.pdf
13:08:05 <napping> jonafan: in short, threads are very cheap, fully preemptive, runtime multiplexes them across all real cores
13:08:06 <copumpkin> Heffalump: lol, okay, no
13:08:24 <copumpkin> Heffalump: it's treating my existential with type equality as a GADT behind the scenes, it seems
13:08:30 <Apocalisp> What is State# ?
13:08:31 <jonafan> i'm an ocaml guy so i don't know how haskell works but i still work hard for referential transparency whenever possible
13:08:32 <copumpkin> if I try to pattern match on it, it tells me to turn on -XGADTs
13:08:43 <ezyang> jonafan: An admirable goal. 
13:08:52 <Heffalump> does it still tell you that if you don't have the type equality?
13:09:07 <napping> jonafan: well, anything in IO is referentially transparent
13:09:10 <copumpkin> Heffalump: nope
13:09:16 <Heffalump> interesting
13:09:17 <copumpkin> Heffalump: I've never seen an "implicit GADT" like that before
13:09:22 <copumpkin> yeah, it's weird
13:09:25 <jonafan> i should just switch over to haskell where i don't have to fight for it as much
13:09:26 <Heffalump> it doesn't feel like refinement, given that b is existential
13:09:39 <napping> jonafan: because the >>= keep you from substituting x by m in do x <- m; ...
13:09:55 <copumpkin> Heffalump: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28642#a28643
13:10:00 <EvanR-work> jonafan: in soviet haskell, referential transparency fights for you
13:10:03 <Phyx-> @type listify (const True :: Name -> Bool)
13:10:03 <lambdabot> Not in scope: type constructor or class `Name'
13:10:04 <napping> jonafan: but threads can talk by Chan or STM or MVar
13:10:08 <ski> roconnor : s/ML's top level let *statements*/ML's top level *declarations*/ :)
13:10:12 <Phyx-> @type listify (const True :: Int -> Bool)
13:10:13 <lambdabot> forall a. (Data a) => a -> [Int]
13:10:22 <Phyx-> @type listify (const True :: Int -> Bool) [1..10]
13:10:23 <lambdabot> [Int]
13:10:26 <Phyx-> listify (const True :: Int -> Bool) [1..10]
13:10:27 <napping> ski: does ML allow mutually recursive modules?
13:10:30 <Phyx-> > listify (const True :: Int -> Bool) [1..10]
13:10:30 <ski> roconnor : there are no `let'-commands in SML (but maybe you're thinking about OCaml ?)
13:10:31 <lambdabot>   []
13:10:33 <jonafan> i basically write my own IO monads
13:10:43 <ski> napping : in extensions, yes ..
13:10:44 <robryk> napping: yes
13:10:50 <Phyx-> hrm, why did that return empty
13:10:55 <robryk> you can do let ones = 1:ones ;;
13:10:57 <jonafan> it's a neat system but it ends up looking a little noisy in ocaml
13:11:07 <napping> ski: so, how does that get along with side effects?
13:11:07 <ski> napping : btw, you should really say whether you mean SML or OCaml (or Alice ML or F#)
13:11:21 <napping> mostly SML I guess
13:11:29 <SonOfLilit> Hello
13:11:36 <c_wraith> jonafan: in that case, I think you'll have no trouble.  Just look at Control.Concurrent.  You should understand how it all works pretty easily.
13:11:36 <SonOfLilit> I have a packages problem
13:11:51 <copumpkin> Heffalump: I guess that means I do get refinement though :) but I need to turn on GADTs, and then not use any
13:11:52 <SonOfLilit> State monad appears in both mtl and monads-fd that I have installed
13:11:52 <Phyx-> > listify (const True :: Int -> Bool) [1..10]
13:11:53 <lambdabot>   []
13:11:55 <Phyx-> odd
13:12:11 <Phyx-> @type listify (const True :: Int -> Bool)
13:12:12 <lambdabot> forall a. (Data a) => a -> [Int]
13:12:21 <SonOfLilit> I can compile by hiding mtl, but I cannot seem to get my emacs ghc-mode to flymake
13:12:27 <Phyx-> > listify (const True :: Int -> Bool) 1
13:12:28 <lambdabot>   []
13:12:37 <SonOfLilit> that is, when it flymakes, it cries about the said package conflict
13:12:39 <Phyx-> >  (const True :: Int -> Bool) 1
13:12:39 <lambdabot>   True
13:12:48 <Phyx-> *scratches head*
13:12:53 <Phyx-> >  (const True :: Int -> Bool) 'p'
13:12:54 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:12:54 <lambdabot>         against inferred type ...
13:13:09 <napping> jonafan: STM is probably the most straightforward way to coordinate threads, though I haven't used it for servers with heavy load
13:13:09 <benmachine> SonOfLilit: hiding mtl as in -hide-package? you could hide it permanently with ghc-pkg hide
13:13:12 <Phyx-> shouldn't that be working?
13:13:21 <benmachine> not permanently but... defaultly
13:13:29 <roconnor> ski: I am thinking of Ocaml
13:13:38 <SonOfLilit> benmachine: and wouldn't it hurt my trying to cabal install all sorts of things?
13:13:43 <bss03> Phyx: I don't think so.
13:13:49 <copumpkin> Heffalump: yeah, I get refinement, and can write something like inject :: Fin n -> Fin (S n)
13:13:49 <SonOfLilit> wouldn't cabal, say, try to download it again?
13:13:54 <benmachine> SonOfLilit: no cabal is sensible
13:13:58 <napping> SonOfLilit: actually, cabal completely ignores that visibility stuff
13:13:58 <SonOfLilit> thanks
13:14:01 <SonOfLilit> I'll try
13:14:02 <Phyx-> bss03: care to elaborate? :)
13:14:06 <c_wraith> STM is beautiful, in terms of semantics, but its implementation makes its use rather narrow.
13:14:09 <napping> SonOfLilit: it hides everything, and exposees just what the cabal asked to depend on
13:14:11 <jonafan> i think the sanest way to tackle my particular issue is to just poll the sockets on a timer
13:14:25 <jonafan> all on one thread
13:14:27 <bss03> Phyx: Your types don't match.  You are forcing (const True) to be a specific type, and then using it as a different type, I think.
13:14:35 <EvanR-work> jonafan: no, no, no
13:14:41 <bss03> :t const True
13:14:42 <lambdabot> forall b. b -> Bool
13:14:44 <c_wraith> jonafan, before you make that decision, learn how IO works under the hood in haskell.  (hint, it does that for you already)
13:14:52 <SonOfLilit> yay, thanks :)
13:15:03 <bss03> > const True $ 'p'
13:15:03 <lambdabot>   True
13:15:10 <Phyx-> bss03: yes, that's right, I want it only to match on Integers
13:15:17 <bss03> > (const True :: Int -> Bool) $ 'p'
13:15:18 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:15:18 <lambdabot>         against inferred type ...
13:15:25 <napping> Phyx-: they why are you confused that it refused to apply to a char?
13:15:25 <Phyx-> > listify (const True :: Int -> Bool) 1
13:15:26 <lambdabot>   []
13:15:40 <Phyx-> napping: i'm confused that ^^ that syb call returns []
13:15:41 <jonafan> well i'm in ocaml land, and i'm thinking of a GTK interface where user interface updates would have to happen on the GTK thread
13:15:59 <dolio> Heffalump: Existential quantification and the equality GADT (along with ordinary algebraic types) are sufficient to write all GADTs. Hence, TypeFamilies turning on type equality constraints enables you to write all GADTs.
13:16:00 <dafis> :t listify
13:16:01 <lambdabot> forall r a. (Data a, Typeable r) => (r -> Bool) -> a -> [r]
13:16:05 <bss03> @src listify
13:16:05 <lambdabot> Source not found. I feel much better now.
13:16:27 <copumpkin> dolio: except that you can't pattern match on them unless you turn on GADTs too, strangely enough
13:16:35 <dafis> > listify (const True :: Int -> Bool) 0
13:16:36 <lambdabot>   []
13:16:36 <dolio> Yeah, I don't know why it'd do that.
13:16:55 <Phyx-> ooohh
13:16:55 <dafis> > listify (const False :: Int -> Bool) 0
13:16:56 <lambdabot>   []
13:17:00 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28642#a28646
13:17:03 <Phyx-> > listify (const True :: Int -> Bool) (1 :: Int)
13:17:04 <lambdabot>   [1]
13:17:09 <Phyx-> stupid defaulting
13:17:11 <ski> napping : O'Caml Language extensions 7.8Recursive modules <http://caml.inria.fr/pub/docs/manual-ocaml/manual021.html#toc75>  .. afaicd, SML/NJ doesn't support recursive modules (though it supports higher-order modules)
13:17:21 <dafis> > listify (const True :: Char -> Bool) 'a'
13:17:22 <lambdabot>   "a"
13:17:25 <copumpkin> I have to say, it's pretty fugly
13:17:37 <Phyx-> > listify (const True :: Int -> Bool) ([1..10] :: [Int])
13:17:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:17:41 <Phyx-> that works
13:18:05 <napping> jonafan: GTK makes it a bit of a mess
13:18:20 <jonafan> yes it certainly does
13:18:48 <Heffalump> and pretty pointless if you need -XGADTs, since you are probably turning on GHC's refinement checker. I guess it's interesting that GADTs become syntactic sugar in that regard, but given that equality refinment is the core of GADTs (over and above existentials) as dolio says, it's not that exciting.
13:19:14 <copumpkin> Heffalump: I never said it was :P
13:19:32 <Heffalump> sorry, wasn't trying to be rude :-)
13:19:36 <SonOfLilit> here's a silly question: if I want to run an action on a state monad and get both its state and its return value, what should I de?
13:19:39 <SonOfLilit> do*
13:19:51 <Heffalump> @type runState
13:19:51 <lambdabot> forall s a. State s a -> s -> (a, s)
13:19:55 <Heffalump> SonOfLilit: that.
13:20:36 <SonOfLilit> specifically, I'm in an IO action and I want to "step" a State MyState (IO ()) and then run the returned IO
13:20:48 <SonOfLilit> thanks
13:21:28 <aristid> SonOfLilit: maybe you want StateT MyState IO?
13:21:31 <c_wraith> I really can't figure out what you want
13:21:38 <copumpkin> Heffalump: nah, didn't take it that way :) I've just been playing with inductive families (the dependent version of GADTs) and wanted to see if I could "backport" an encoding of them to haskell
13:21:49 <ezyang> those are isomorphic. 
13:22:04 <ezyang> State doesn't give you a way to "step" the computation. 
13:22:16 <napping> jonafan: there are the Graphics.UI.Gtk.General.General.postGUI functions
13:22:16 <ezyang> Think about it: what constitutes a step? A put? A get? 
13:22:34 <Heffalump> ezyang: are you saying State MyState (IO ()) is isomorphic to StateT MyState IO () ?
13:22:37 <ezyang> You might want iteratees, but if you're a beginner that might be pushing you off the deep end. 
13:22:46 <Heffalump> @unmtl StateT MyState IO ()
13:22:47 <lambdabot> MyState -> IO ((), MyState)
13:22:47 <c_wraith> @unmtl StateT MyState IO ()
13:22:47 <lambdabot> MyState -> IO ((), MyState)
13:22:51 <benmachine> @unmtl State MyState (IO ())
13:22:52 <lambdabot> MyState -> (IO (), MyState)
13:22:57 <c_wraith> hahha
13:22:57 <ezyang> Heffalump: Ah, no, I've got it backwards. 
13:23:12 <napping> jonafan: you can pass IO blocks for the GUI thread to run
13:23:13 <ezyang> mea culpa :-) 
13:23:24 <SonOfLilit> ezyang: you took me to mean more than I did
13:23:26 <jonafan> yeah it looks somewhat similar to how it works in ocaml
13:23:38 <SonOfLilit> "step" means "run that action"
13:23:49 <napping> oh, there's a thing that takes a () -> () and calls it in the main thread?
13:23:50 <jonafan> you can provide a function to run on the gtk thread either synchronously or asynchronously
13:23:57 <ezyang> Ah. Then runState(T) is what you want. 
13:24:05 <napping> yeah, that sounds pretty close
13:24:08 <ezyang> (add the T if you do StateT) 
13:24:33 <ski> @type (flip uncurry .) . runState
13:24:34 <lambdabot> forall a b b1. State b a -> b -> (a -> b -> b1) -> b1
13:24:42 <jonafan> i could add in my own IO system which seems somewhat similar so the haskell one and be pretty satisfied
13:26:09 <napping> jonafan: oh, another option I guess is to just use the single-threaded runtime
13:26:34 * hackagebot uu-parsinglib 2.5.4 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.4 (DoaitseSwierstra)
13:26:40 <napping> as described here: http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html#PodMainGUI.hs:main
13:27:34 <jonafan> do you still have a one way ticket to race condition land if you have a bunch of mvars?
13:28:01 <ezyang> jonafan: Depends on what you do. 
13:28:13 <napping> maybe - mvars don't have actual data races
13:28:18 <ezyang> Some of the built-in MVar functions are racy. 
13:28:42 <napping> but you can certainly build logic that depends which thread grabs an MVar first, and maybe deadlocks and stuff
13:29:01 <jonafan> yeah...
13:29:04 <napping> you don't have the sort of compositional progress guarantees you get with 
13:29:06 <napping> STM
13:29:33 <jonafan> threads are the pits
13:29:38 <SonOfLilit> when programming with OpenGL and no FRP, is there any way to avoid a global for program state?
13:30:22 <Zao> SonOfLilit: Depends on what silly toolkit you use, but you can always have a StateT (IORef World) IO ()  :D
13:30:31 <lispy> SonOfLilit: You can avoid global program state.  but, opengl will still require some
13:30:37 <Zao> Or I guess, ReaderT, but that's just marginally non-global.
13:31:09 <napping> jonafan: that atomic get-and-emtpy / put-and-fill are noticeably easier to work with than a lock guarding a variable, but it's not foolproof
13:31:15 <lispy> SonOfLilit: OpenGL just has this very stateful model.  You can of course, hide that in a monad
13:31:25 <napping> Chan, on the other hand, is pretty simple to work with
13:31:50 <SonOfLilit> my problem is that opengl wants to call me back for display
13:32:03 <SonOfLilit> so should I change the callback on every step?
13:32:15 <SonOfLilit> or how?
13:32:39 <napping> SonOfLilit: generally, I make IORefs shared between the callbacks and the rendering procedure
13:33:16 <napping> you can make it in main and share it rather than making it really global, but it is hard to use GL without state
13:33:16 <SonOfLilit> oh, so my display callback has an IORef parameter?
13:33:25 <SonOfLilit> ok
13:33:32 <SonOfLilit> thanks
13:33:33 * ski wonders how `.. [ f, A, B, ...]' could be construed to mean a "function call" in Prolog ..
13:33:37 <SonOfLilit> I'll learn how to use those
13:34:12 <napping> jonafan: STM is worth a look anyway
13:34:16 <jmcarthur> SonOfLilit: alternatively, you can store state in closures
13:34:44 <jmcarthur> SonOfLilit: so when you set the callback you include your state as a parameter to the callback, and then when things change you can change the callbacks to match
13:34:58 <jmcarthur> it's probably not as fast, and it's technically almost the same thing
13:35:03 <EvanR-work> hehe dumping friggin everything ghc can do on jonafan at once
13:35:29 <EvanR-work> and letting him sort it out ;)
13:35:34 <napping> EvanR-work: coming from O'Caml, that's not so bad
13:35:38 <EvanR-work> heh
13:35:44 <EvanR-work> O'Caml haha
13:35:47 <napping> it's not like we're mentioning type system stuff
13:36:02 <napping> but that reminds me
13:36:02 <jonafan> i know some of the type system stuff
13:36:07 <jonafan> i wish ocaml had type classes
13:36:11 <napping> do you use extensible variants much?
13:36:34 <jonafan> i'm like 95% there on haskell, but the last 5% is the hardest
13:36:35 <Phyx-> uh... you gotta be kidding me
13:37:08 <EvanR-work> the first 5% of haskell is the easiest, the rest is hard, and ignorable ;)
13:37:50 <napping> that's the thing from O'Caml I'd really like to have in Haskell, that and a decent module system
13:38:02 <Heffalump> yeah
13:38:18 <Heffalump> the Haskell module system and namespacing problems are really starting to annoy me
13:38:20 <jonafan> i do enjoy the module system
13:38:36 <napping> Well, I never did get into camlp4, but Coq notations can be pretty impressive
13:38:52 * EvanR-work scibes down more critisms of haskell ;)
13:38:57 <EvanR-work> scribbles
13:39:12 <g_cross> Quick question:  Is there a tutorial somewhere for parsec 3?
13:39:28 <Heffalump> EvanR-work: what for? :-)
13:39:44 <EvanR-work> posterity
13:39:59 <Phyx-> If i see another GHC panic I'll...
13:40:00 <Heffalump> I think the other big problem with Haskell is that the type-level syntax is a mess now we have all this type-level programming.
13:40:03 <Berengal> What happened to foldl.com and foldr.com?
13:40:09 <EvanR-work> im looking for ill founded, valid, and highly theoretical problems
13:40:09 <benmachine> this file has the nerve to write "Portability :  portable (template-haskell)" -- not only does that make very little sense itself, it's not ten lines below an OPTIONS_GHC pragma
13:40:12 * benmachine sigh
13:40:16 <napping> Phyx-: whoa, how are you getting those?
13:40:42 <Phyx-> napping: quite easy... poking around in it's internal
13:40:52 <CalmNelly> g_cross: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
13:41:00 <Heffalump> CalmNelly: that's not parsec 3
13:41:07 <napping> oh, that will do it
13:41:12 <Phyx-> the latest version "Evaluated the place holder for a PostTcType"
13:41:23 <CalmNelly> Heffalump: oh :(
13:41:29 <Phyx-> even though I'm using a Data instance defined in the compiler itself
13:41:31 <Phyx-> *sigh*
13:41:39 <dafis> benmachine: OPTIONS_GHC pragmata can appear in portable code
13:41:48 <Phyx-> @hoogle listify
13:41:49 <lambdabot> Data.Generics.Schemes listify :: Typeable r => (r -> Bool) -> GenericQ [r]
13:41:50 <benmachine> dafis: -fglasgow-exts, though?
13:41:55 <Phyx-> @src listify
13:41:56 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:42:00 <dafis> benmachine: THAT not
13:42:04 <g_cross> CalmNelly:  I was hoping for a Parsec 2 tutorial, but thanks, anyway.  :-)
13:42:06 <Phyx-> is there a listifyBut
13:42:07 <benmachine> dafis: so I thought :)
13:42:10 <g_cross> I mean Parsec 2
13:42:12 <g_cross> GAH
13:42:13 <g_cross> Parsec 3
13:42:17 <EvanR-work> Heffalump: anything specific about the type system?
13:42:22 <EvanR-work> that you have a problem with
13:42:38 <Heffalump> not the type system itself, the syntax
13:42:50 <dafis> benmachine: OPTIONS_GHC -O2, -funbox-strict-fields, such stuff
13:42:55 <CalmNelly> g_cross: I was also looking for Parsec 2 tutorial, but I'm sure there is none out since Parsec 2 is pretty fresh
13:42:59 <EvanR-work> Heffalump: what about it
13:43:07 <Berengal> EvanR-work: Type synonyms are often forgotten by the compiler
13:43:08 <copumpkin> the worst part about haskell types is 1
13:43:10 <copumpkin> :P
13:43:15 <copumpkin> :k 1
13:43:15 <g_cross> CalmNelly:  Hmm, is there a document describing the differences?
13:43:16 <lambdabot> *
13:43:24 <benmachine> copumpkin: what is it?
13:43:30 <copumpkin> a synonym for Unit
13:43:34 <copumpkin> > Unit :: 1
13:43:34 <benmachine> oh
13:43:35 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
13:43:35 <lambdabot>    arising from a use of ...
13:43:37 <copumpkin> > Unit :: Unit
13:43:37 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
13:43:38 <lambdabot>    arising from a use of ...
13:43:41 <benmachine> why :/
13:43:50 <Berengal> > show (undefined :: 1)
13:43:51 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
13:43:51 <lambdabot>    arising from a use of ...
13:43:53 <CalmNelly> g_cross: I haven't seen one, you'd have to email the guy who did the parsec2 fork
13:44:02 <Heffalump> hmm, I'd have to write stuff down as I encountered it really, but one problem is to do with the circumstances under which you are allowed to use the same identifier in different contexts.
13:44:02 <Phyx-> is there a way to prevent listify from entering certain types/
13:44:04 <copumpkin> :k (1 :+: 1) :*: (1 :+: 1 :+: 1)
13:44:05 <lambdabot> *
13:44:23 <EvanR-work> Heffalump: within the same type declaration?
13:44:24 <copumpkin> :j Mu
13:44:27 <copumpkin> :k Mu
13:44:28 <lambdabot> (* -> *) -> *
13:44:49 <CalmNelly> g_cross: It's just supposed to be simpler. I followed the link i just gave you, but then I checked the documentation when I was about to implement something
13:44:52 <copumpkin> :k Mu ((:+:) 1)
13:44:53 <lambdabot> *
13:44:59 <copumpkin> there, it's the naturals! :P
13:45:02 <Phyx-> hello?
13:45:55 <Veinor> > 1 :+: 1
13:45:55 <lambdabot>   Not in scope: data constructor `:+:'
13:45:56 <dolio> :k MuF
13:45:57 <lambdabot> Not in scope: type constructor or class `MuF'
13:46:07 <ezyang> Bah, I wish c2hs supported anonymous unions. 
13:46:11 <dafis> Phyx-: define a restricted alias?
13:46:14 <copumpkin> dolio: http://en.wikipedia.org/wiki/Dogcow
13:46:35 <Phyx-> dafis: huh?
13:46:48 <dafis> :t listify
13:46:49 <lambdabot> forall r a. (Data a, Typeable r) => (r -> Bool) -> a -> [r]
13:47:27 <dafis> class (Data a, Typeable r) => Allowed a r where myListify :: (r -> Bool) -> a -> [r]
13:47:36 <dolio> copumpkin: You had that on the tip of your tongue, eh?
13:47:56 <benmachine> Phyx-: define your own with recursive gmapQ?
13:47:56 <copumpkin> dolio: I guess so :)
13:48:10 <Phyx-> dafis: I would have to define an instance for every type then, and there are alot
13:48:34 <SonOfLilit> how do I convert a Time.Clock.NominalDiffTime to Double?
13:49:50 <Philonous> Is there a package with a program that reads haskell code from the arguments and applies it to stdin? 
13:50:34 <copumpkin> runhaskell ?
13:51:20 <Philonous> can it read code from the command line?
13:51:21 <Phyx-> benmachine: bleh, this suddenly made SYB useless in this case
13:52:02 <SonOfLilit> I'm having real trouble with this simple conversion
13:52:10 <Phyx-> if i have to define something for everytype, I might aswell just write out the traversal
13:52:18 <Philonous> copumpkin: I'm looking for something like ``dmesg | runhaskell -c "interact . reverse" ``
13:52:25 <SonOfLilit> I need to get a Double from Time.Clock.NominalDiffTime
13:52:53 <SonOfLilit> or in general, a double from a real
13:52:56 <napping> Phyx-: you need Data for a lot of GHC types?
13:53:12 <ezyang> SonOfLilit: NominalDiffTime has Fractional/Real/RealFrac instances 
13:53:18 <dafis> SonOfLilit: realToFrac, perhaps
13:53:49 <SonOfLilit> but frac is still not double
13:53:51 <Heffalump> EvanR-work: no, same scope
13:53:58 <SonOfLilit> how do I get then to a double?
13:54:05 <Phyx-> napping: GHC 6.13/6.14 already defines them. my problem is, it tries to enter something that's undefined at a certain point. so it panics
13:54:20 <Heffalump> oh yes, and the fact that you can't open GADTs or existentials in a let sucks.
13:54:21 <SonOfLilit> ah
13:54:25 <SonOfLilit> think I got it
13:54:29 <Heffalump> (I know the reasons behind it, but it's still really annoying)
13:54:30 <Veinor> what'd you do?
13:54:46 <SonOfLilit> realToFrac
13:54:47 <Veinor> (for future reference)
13:55:12 <bss03> :t realToFrac
13:55:13 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
13:55:13 <SonOfLilit> seems like Frac /is/ Double, in the sense that Num is Integer
13:55:22 <SonOfLilit> exactly
13:55:25 <Veinor> ah, yeah
13:55:32 <Veinor> Doubles are Fractional types
13:55:38 <SonOfLilit> it converts to the fract type of my choice, e.g. double
13:56:18 <bss03> > realToFrac (pi :: Data.Number.CReal.CReal) :: Rational
13:56:19 <lambdabot>   *Exception: CReal.toRational
13:56:49 <dafis> > realToFrac (pi :: Float) :: Rational
13:56:50 <lambdabot>   13176795 % 4194304
13:57:00 <dafis> > realToFrac (pi :: Double) :: Rational
13:57:01 <lambdabot>   884279719003555 % 281474976710656
13:57:50 <kyagrd> @qc (\x -> fromRational (toRational x) == (x :: Double))
13:57:51 <lambdabot> Not enough privileges
13:58:03 <kyagrd> @check (\x -> fromRational (toRational x) == (x :: Double))
13:58:04 <lambdabot>   "OK, passed 500 tests."
13:58:54 <benmachine> @check (\x -> (0/x) == (0/x :: Double))
13:58:56 <lambdabot>   "Falsifiable, after 0 tests:\n0.0\n"
13:58:59 <EvanR-work> Heffalump: scope?
13:59:33 <EvanR-work> different type declarations have different sets of identifiers, they cant be shared (i think)
13:59:45 <dafis> > realToFrac (0/0 :: Double) :: Rational
13:59:46 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
14:00:05 <EvanR-work> i knew thats what 0/0 was
14:00:15 <EvanR-work> teachers told me it was an indeterminant form
14:00:26 <mercury^> It's nullity.
14:00:46 <opqdonut> haha nullity
14:01:05 <arw> what a nice name for undefined :)
14:01:28 <c_wraith> > length $ show (realToFrac (0/0 :: Double) :: Rational)
14:01:44 <CalmNelly> I hope someone can help me and explain why this doesn't work
14:01:48 <CalmNelly> evalprop              :: String -> Either ParseError Prop
14:01:48 <CalmNelly> evalprop xs            =  case (parse mainParser "" xs) of
14:01:48 <CalmNelly>                              Left err -> err
14:01:48 <CalmNelly>                              Right  p -> p    
14:01:55 <c_wraith> Huh.  I wasn't expecting that to explode
14:02:10 <dafis> > length $ show (realToFrac (0/0 :: Double) :: Rational)
14:02:10 <lambdabot>   316
14:02:17 <opqdonut> CalmNelly: you're not returning an either, I think
14:02:28 <opqdonut> even though your type claims so
14:02:29 <CalmNelly> It says it's expecting an Either, your correct
14:02:30 <Paczesiowa> bos: back in march you were benchmarking attoparsec (and parsec) with some header parsing code, parsers are available at your repo, but I don't see any input data (only med.txt for Tiny). Do you still have that data lying around?
14:02:44 <Veinor> arw: I think you mean NaN
14:02:50 <bos> Paczesiowa: probably somewhere
14:02:53 <opqdonut> CalmNelly: parse returns an Either but you are destructuring it with the case
14:03:02 <bos> Paczesiowa: i just grabbed it via tcpdump
14:03:08 <CalmNelly> yes, that's what I want
14:03:18 <CalmNelly> I want to pull the p out of it
14:03:23 <CalmNelly> Prop p
14:03:39 <arw> Veinor: yes, but that doesn't sound as nice as "nullity"
14:03:57 <arw> Veinor: notice how it gently rolls off the tongue...
14:04:04 <EvanR-work> it hurts to say
14:04:16 <CalmNelly> opqdonut: I thought that was the purpose of Either to get 'a' or 'b'
14:04:17 <Paczesiowa> CalmNelly: don't inspect it, parse mainParser "" xs is already of Either ParseError Prop type
14:04:18 <dafis> nullity shnullity
14:04:45 <EvanR-work> Either a b = Left a | Right b
14:05:14 <CalmNelly> Paczesiowa: okay, i suspected this, but wasn't sure
14:05:18 <arw> Veinor: but there is also the evil cousin "naughty", for (0/0)^0 :>
14:05:30 <EvanR-work> fromLeft (Right _) = undefined 
14:05:53 <Veinor> haha, I didn't know chu-carrol wrote an article about nullity
14:08:28 <CalmNelly> Paczesiowa: okay, now I don't inspect it, but if it's of type Either ParseError Prop type now, how to I get the Prop out of it when it works correctly
14:09:26 <Paczesiowa> case parse mainParser ""xs of Left e -> print e; Right p -> doSomethingWith p
14:09:35 <EvanR-work> :t either
14:09:35 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
14:09:49 <Paczesiowa> doSomethingWith :: Prop -> IO ()
14:10:04 <luite> does anyone know why this program cannot be killed anymore by SIGKILL when itis presented with the input ([], "fix error")?     http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=28648
14:10:48 <luite> it tries to evaluate "fix error" using hint, and deepseqs the result
14:10:57 <luite> and catches the exception when there was a problem
14:11:08 <luite> but something goes wrong
14:11:47 <luite> I can only kill the program with kill -9 afterwards (SIGABRT)
14:11:52 <c_wraith> uh.  if SIGKILL doesn't kill something, your OS is broken
14:11:56 <c_wraith> you mean SIGTERM?
14:11:58 <c_wraith> or SIGINT?
14:12:05 <EvanR-work> CalmNelly: gotta figure out what you want to do in the case that its an error, just crash?
14:12:22 <robryk> signal 9 is usually SIGKILL and not SIGABRT
14:12:38 <luite> oh sorry, I got some signals mixed
14:12:42 <c_wraith> As a matter of fact, I know precisely why programs that use hint stop responding to SIGTERM, SIGQUIT, SIGINT, and one other...
14:12:42 <Paczesiowa> bos: using tcpdump requires www server, right?
14:12:53 <bos> Paczesiowa: yp
14:13:05 <Paczesiowa> bos: damn:/
14:13:15 <c_wraith> luite: the ghc api installs a broken signal handler
14:13:16 <luite> I meant the default kill doesn't work anymore, which is SIGTERM
14:13:27 <sproingie> possible for some stuff to not even respond to SIGKILL
14:13:34 <sproingie> if it's wedged in a kernel thread
14:13:57 <Paczesiowa> we all love nfs!
14:14:04 <arw> c_wraith: programs that are unkillable by SIGKILL usually hang in a syscall. the program is not running but waiting for the scheduler to schedule it in, which depends on some hanging read() or some other IO.
14:14:12 <EvanR-work> we all live in a yellow submarine
14:14:14 <luite> c_wraith: is it's possible to work around that?
14:14:34 <sproingie> and yeah it's usually nfs
14:15:05 <arw> c_wraith: as soon as the program is scheduled in again it will be killed, and after a KILL you can be sure that it will never get another cycle of cpu. but the process structure will hang around until the syscall times out or fails.
14:15:08 <c_wraith> luite: that signal handler causes four signals to be dropped on the floor if the ghc api was started in a thread that's finished when the signal is caught.
14:15:08 <c_wraith> daniel gorin was going to release a new version of hint with a workaround sometime.  I should ask how that's coming along.
14:15:28 <jonafan> how do TVars work? i understand that you build up an STM and run it with 'atomically', but if there is a problem during writeTVar, does it roll back to the last readTVar?
14:15:36 <sproingie> ahhh signals and threads, such happy fun insanity
14:16:34 <c_wraith> But you can work around it by saving the signal handlers before calling hint, and restoring them after
14:18:06 <luite> c_wraith: hmm, this is strange, and I now know why I got the signals mixed up. I try System.Process.terminateProcess on the hint process when it takes too long. it usually works, but if it is in the "fix error" exception loop, it doesn't
14:18:22 <CalmNelly> got disconnected
14:18:28 <luite> the documentation claims that it sends a SIGKILL
14:18:30 <CalmNelly> someone picked up the phone
14:18:37 <CalmNelly> j/k
14:18:40 <EvanR-work> haha
14:18:49 <CalmNelly> lol
14:18:54 <EvanR-work> i was just explaining to someone 2 player DOOM over the modem
14:19:19 <CalmNelly> that was the greatest thing in the world at the time
14:19:27 <EvanR-work> was wondering wtf api original dos doom used to do that... doubt it was bsd sockets ;)
14:19:53 <EvanR-work> wrote their own modem drivers?
14:20:17 * CalmNelly shrugs
14:20:26 <c_wraith> jonafan: it actually uses optimistic locking.  At the end of a transaction, it checks to see if any other thread updated a value it read while it was in progress.  If no other thread did, it commits.  Otherwise, it retries
14:21:20 <jonafan> oh, so it doesn't actually update until the very end?
14:21:29 <volvic> can someone see wehat the deal is with the type declaration of quicksort in this program? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28650#a28650
14:22:03 <luite> c_wraith: ok, process is wrong
14:22:39 <Paczesiowa> volvic: what's the error?
14:23:21 <luite> c_wraith: ok, process is wrong, it claims that terminateProcess sends SIGKILL, this is the function: int terminateProcess (ProcHandle handle) { return (kill(handle, SIGTERM) == 0); }
14:24:25 <c_wraith> luite: anyway, you can save the signal handlers before calling hint, and restore them afterwards.
14:24:28 <c_wraith> It's a bit annoying to do it cross-platform, but it can be done
14:24:40 <volvic> Paczesiowa: i updated the hpaste
14:25:33 <c_wraith> luite: *also* hint isn't thread-safe.
14:25:33 <c_wraith> luite: I didn't check to see if you're guarding against that or not
14:25:42 <luite> c_wraith: I don't think that really helps in this case, since the program is basically a loop that processes hint requests. it only exits the Interpreter monad to handle exceptions and then quickly starts the interpreter
14:25:52 <benmachine> volvic: the trouble is that there are lots of types that could be in the input list, and haskell is unable to work out which to use
14:26:08 <luite> c_wraith: it's single threaded, so that's no problem :)
14:26:08 <benmachine> volvic: give an explicit type to input, and you should be fine
14:26:28 <volvic> oh, let me try that. thanks!
14:26:31 <napping> jonafan: yes, the current implementation checks at the end
14:26:50 <Paczesiowa> volvic: all those values are polymorphic, haskell doesn't know which instances to choose. it usually works by defaulting to Integers, but defaulting doesn't allow constraints Random a, only unresolved numeric constraints are defaulted
14:27:04 <dafis> benmachine: It should default to Integer, I think; Random *is* in a standard library, isn't it?
14:27:26 <benmachine> dafis: it's not a prelude class though
14:27:29 <Paczesiowa> Random isn't a numeric class
14:28:23 <jonafan> if it fails, does it go back to the beginning of the operation, or can it figure out that some of the operations were successful and not redo them
14:28:28 <dafis> Paczesiowa: defaulting takes place when all constraints have the form C a, at least one is numeric and all appear in the satndard libraries
14:28:33 <EvanR-work> > random (mkStdGen 0) :: (Bool, StdGen)
14:28:34 <lambdabot>   (True,40014 40692)
14:29:02 <EvanR-work> > random (mkStdGen 0) :: (Char, StdGen)
14:29:03 * hackagebot gsc-weighting 0.1.1 - Generic implementation of Gerstein/Sonnhammer/Chothia weighting.  http://hackage.haskell.org/package/gsc-weighting-0.1.1 (FelipeLessa)
14:29:03 <lambdabot>   ('\64685',40014 40692)
14:29:07 <jonafan> it seems to me that if writeTVar x val fails, it only needs to go back to the last time readTVar x was invoked
14:29:43 <Paczesiowa> dafis: my bad
14:29:46 <benmachine> jonafan: sounds like an implementation detail, is there actually any visible difference?
14:30:03 <EvanR-work> :t take 10 (randoms (mkStdGen 0)) :: [Char]
14:30:04 <lambdabot> [Char]
14:30:07 <EvanR-work> > take 10 (randoms (mkStdGen 0)) :: [Char]
14:30:08 <lambdabot>   "\64685\1052295\639025\625672\825586\260381\726547\823083\9171\20448"
14:30:32 <Paczesiowa> I hate these kind of exceptions, I'd have a few ideas on abusing if we could use default rules without any problems
14:30:33 <benmachine> jonafan: hmm, wait a sec, what if you had a transaction which dealt with one variable and then another?
14:30:36 <jonafan> i don't htink it would matter
14:30:40 <jonafan> other than the wasted work
14:30:54 <napping> That's not how it works
14:30:57 <benmachine> jonafan: failing the latter transaction, you'd have to do the former part again to make sure what you did was still valid
14:31:06 <benmachine> *the latter half
14:31:15 <volvic> hmm, i can't seem to find a type to declare "input" as that ghc will accept
14:31:17 <jonafan> perhaps you're right
14:31:21 <benmachine> otherwise, someone might have changed the first variable while you were mucking about with the second
14:31:25 <napping> if only some variables were modified by a concurrent transaction, you might imagine going to the earliest read
14:31:32 <benmachine> I don't know I'm not an expert but it seems to me that it's a messy issue
14:31:40 <napping> but that would require saving all intermediate states
14:32:08 <jonafan> so this must be implemented right into the GHC runtime?
14:32:10 <Paczesiowa> volvic: where\ninput :: [Integer]\ninput = ...
14:32:32 <Paczesiowa> volvic: or input = (...) :: [Integer]
14:32:36 <napping> as it is now, it just needs primitives to read and write TVars that check the local log and maybe do something with the versions
14:32:45 <napping> and then one to check the log and actually apply the changes at the end
14:33:05 <Paczesiowa> volvic: or input :: [Integer] = ... (this one needs scoped type variables)
14:33:10 <volvic> d'oh! of course, it has to be a list. that's what i get for trying this out on a friday night
14:33:10 <napping> the one clever thing it does, is if you fail by an explicit "retry", then it blocks until one of the variables that you read has been changed
14:33:47 <napping> I guess there is some kind of partial rollback if you use `orElse`
14:34:07 <napping> that's one of the two things that's better about STM in Haskell than any other implementation I've seen
14:34:21 <dafis> Ah, System.Random has been removed from the H2010 report, seems it's no longer a standard library
14:34:33 <jonafan> i'm wondering if i could do an ocaml version of this
14:34:47 <napping> using "retry" and "orElse" you can convert between blocking and testing versions of things
14:35:00 <napping> (blocking >> return True) `orElse` (return False)
14:35:01 <volvic> whoa, now i got an even stranger error... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28650#a28652
14:35:18 <napping> and (do worked <- polling; if worked then return () else retry)
14:35:38 <napping> that, you could do
14:35:48 <benmachine> volvic: ghc --make
14:36:18 <luite> hmm, they changed the signal from SIGKILL to SIGTERM in process-1.0.1.2 :(
14:36:34 <napping> having a pure language to enforce that STM actions don't mutate unchecked variables wouldn't work in O'Caml
14:36:41 <napping> (I think clojure has a runtime check for that)
14:37:12 <volvic> beanmachine: excellent, thank you. is there a way for me to know up front that i need to add the --make flag?
14:37:33 <Paczesiowa> volvic: yes. you do.
14:37:42 <benmachine> volvic: pretty much every time you use ghc
14:38:19 <jonafan> it wouldn't work in ocaml why?
14:38:30 <ezyang> I have a list that I'm going to need O(1) random access to, but not much more. Is Data.Array tolerable for this? 
14:38:34 <volvic> ok thanks guys, i guess i need to go back to RWH and RTM :)
14:38:48 <monadic_kid> what does ~ do?
14:38:48 <c_wraith> ezyang, it's great for that.  not just tolerable
14:38:58 <Paczesiowa> monadic_kid: which one?
14:39:03 <napping> just because you can always ! or := a mutable value
14:39:08 <Paczesiowa> monadic_kid: type level or value level?
14:39:37 <monadic_kid> Paczesiowa: value, i'm guessing it's strictness annotation
14:39:48 <jonafan> i think i can use the type system to prevent that
14:39:51 <dafis> monadic_kid: laziness, actually
14:40:01 <ezyang> c_wraith: Sounds good. 
14:40:01 <Berengal> foldr.com is gone, so I made this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28653
14:40:11 <Paczesiowa> monadic_kid: foo ~(x:xs) = ... == foo arg = let x:xs = arg in ...
14:40:19 <dafis> monadic_kid: ~ makes a pattern irrefutable, it is assumed that it matches
14:41:07 <napping> jonafan: only if you have a foundation of pure types
14:41:13 <jonafan> i've made an array monad in ocaml that prevents writing to the array outside the monad, then running the monad gives you an immutable array
14:41:15 <monadic_kid> Paczesiowa, dafis: i was just testing if I could get transformers buildilng in jhc
14:41:28 * ski hands Paczesiowa a fine `<=>' symbol
14:41:50 <napping> jonafan: sure, that's not the problem. You can easily make new effects that have to be reflected in types, by tying them the a monad or something
14:41:54 <jonafan> i think this would be a little like that, but a step further
14:42:12 <napping> but to do trasnactions and rollbacks you have to make sure there are not *any* effects, not that your new effects are encapsulated
14:44:40 <napping> well, that or you can say "don't use normal mutables in transactions kthxbye", and end up with yet another concurrency system that explodes if you the human are even a tiny bit careless
14:44:48 <jonafan> if the read functions also built up a function that verified that the variables haven't been modified, and the write functions built up a function that committed the changes, you just have to lock and unlock before executing them
14:45:06 <jonafan> before and after
14:45:30 <napping> the problem is not verifying access to the new special transactional variables
14:45:48 <napping> but making sure nobody sneaks in side effects that shouldn't be retried with the transactions
14:46:13 <napping> or especially mutation that itself ought to be controlled w.r.t. other threads
14:46:47 <jonafan> ohhhh i see
14:46:54 <hpc> :t (<=>)
14:46:54 <lambdabot> Not in scope: `<=>'
14:47:01 <Berengal> There's some STM extentions in ghc which does this, I think
14:47:09 <napping> I'd be a bit surprised if there isn't already some kind of transactional library for O'Caml
14:47:15 <Berengal> Or perhaps that just defered things to the end
14:47:21 <napping> but you'd better be careful not to e.g. insert into a hash table inside a transaction
14:47:33 <copumpkin> @djinn Not (a, Not a)
14:47:34 <lambdabot> f (a, b) = b a
14:47:35 <jonafan> yes i see what you're saying now
14:49:16 <Axman6> @djinn Not (a -> b) -> (a -> Not b)
14:49:16 <lambdabot> f a _ b = a (\ _ -> b)
14:49:19 <napping> So, I'd like to make an extensible interpreter for first order logic
14:49:40 <luite> is it possible to get a System.Posix.Types.ProcessID (unix) from a process started with System.Process.createProcess (process)?
14:49:41 <applicative> @djinn (a, a -> b) -> b
14:49:41 <lambdabot> f (a, b) = b a
14:49:47 <ezyang> Annoyance of the day: modules intended to be imported qualified which have infix operators. 
14:49:59 <ezyang> there's some mumble language extension I need, right? 
14:50:01 <applicative> ezyang, yes, pretty gross
14:50:25 <napping> ezyang: how is that worse than any other case where you want some things unprefixed?
14:51:19 <napping> import qualified Module as M; import Module(stuff)
14:51:20 <ezyang> QualName.(!) doesn't work by default. 
14:51:22 <karlalfred> Sorry if I have asked this before but how do you install wx-haskell on a windows 7 64-bit mashine? Where do I get a wx-haskell that is compatible with the latest GHC?
14:51:36 <napping> oh, you want to use the operator prefixed
14:51:53 <ezyang> yeah... 
14:53:08 <napping> isn't it (QualName.!)?
14:54:42 <ski> napping : a logic programming implementation ?
14:55:06 <ski> @type (Data.Map.!)
14:55:07 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
14:56:18 <applicative> karlalfred, I'm probably no use, but you have the wxWidgets libs installed, and still `cabal install` fails? I remember it giving a pile of errors, but building (one or two ghc's ago)
14:57:31 <napping> ski: not for logic programming, but to parse and interpert
14:57:41 <napping> for side conditions on a rewrite system
14:58:01 <napping> I want to be able to add extra modules that introduce new sorts and functions involving them
14:58:29 <napping> but then also be able to evaluate them
14:58:35 <karlalfred> I didn't have wxwidgets. but I am installing it now.
14:59:44 <ski> napping : what do you mean by "interpreter for first order logic" ? to compute truth values for propositions, given values for the free variables ?
15:00:10 <karlalfred> applicative: I have installed wxwidgets now. what should be done now to get it to work?
15:00:30 <monadic_kid> Yeah I can build almost all of transformers on jhc except for the Lazy variants that uses irrefutable patterns.
15:00:47 <monadic_kid> So I'll just build it without those modules for now
15:01:08 <ski> (jhc doesn't support irrefutable patterns ?)
15:01:13 <napping> ski: well, I have a context where variables are all bound to bits of syntax
15:01:17 <dafis> karlalfred: have you wx-config?
15:01:24 <napping> and I've got various semantic analyses over them
15:01:41 <napping> but then to compute the truth value of various assertions about the dataflow facts, yes
15:01:55 <karlalfred> wx-config? sorry, I don't know but I will check dafis. :/
15:01:56 <napping> and to be able to extend the system easily when a new analysis comes in
15:01:57 <dafis> karlalfred: http://sites.google.com/site/wxconfig/
15:02:14 <monadic_kid> ski: doesn't look like it
15:02:17 <dafis> karlalfred: you need that to build wxHaskell
15:02:27 <ski> napping : hm .. just wondering, is this related in any way to attribute grammars ?
15:02:28 <karlalfred> ok I am getting it too then.
15:02:36 <napping> not particularly
15:03:18 <ski> monadic_kid : strange
15:03:33 <karlalfred> I klicked on the exe but nothing happened. In what path should I put it?
15:03:48 <ski> napping : ok. but you have some kind of system for manipulating object syntices ?
15:04:26 <napping> I suppose, but I don't think that will show up in the logic
15:04:36 * ski nods
15:04:48 <napping> as far as it's concerned there are just some sorts like Stmt and Expr that classify variables in the environment
15:05:27 <napping> I'm thinking of GADT tags for the sorts
15:05:37 <karlalfred> dafis where do I get the lastest wxHaskell? sorry for my noob questions. 
15:05:38 <ski> just slightly curious what you're trying to do ..
15:05:52 <dafis> karlalfred: does http://www.haskell.org/haskellwiki/WxHaskell/Building give enough instructions?
15:05:58 <napping> make an extensible language of predicates
15:06:03 <napping> for putting side conditions on rules
15:06:18 <dafis> karlalfred: you get the latest wx packages from Hackage
15:06:20 <ski> that's pretty vague and general :)
15:06:33 <dafis> karlalfred: have you a working cabal-install?
15:06:49 <ski> (also, i still think it sounds like logic programming ;)
15:07:00 <napping> well, not with any search
15:07:12 <copumpkin> lol,
15:07:13 <copumpkin> The algorithm Tarski proposed for http://en.wikipedia.org/wiki/Quantifier_elimination has http://en.wikipedia.org/wiki/NONELEMENTARY complexity, meaning that no tower  can bound the execution time of the algorithm if n is the size of the problem.
15:07:26 <karlalfred> dafis: nope I don't have cabal.
15:07:37 <applicative> karlalfred, in principle, given a working `cabal install` and the C++ libs etc. cabal update/ cabal install wx  should work.
15:07:38 <ski> copumpkin : "tower" ?
15:07:53 <applicative> karlalfred, but you installed the haskell platform for windows?
15:07:58 <copumpkin> ski: I lost image from wikipedia in pasting, but 2^(2^(2...
15:07:58 <karlalfred> yes
15:08:00 <copumpkin> n
15:08:03 <karlalfred> for windows
15:08:10 <copumpkin> ski: http://upload.wikimedia.org/math/7/3/9/739894704971d0e3bd88d48c87f344d0.png
15:08:15 <dafis> karlalfred: http://www.haskell.org/cabal/download.html
15:08:18 <applicative> hmmm, i wonder where cabal install could be hidden
15:08:24 <karlalfred> I installed ghc
15:08:29 <karlalfred> ghci
15:08:39 <applicative> so they are responding.
15:08:43 <alip> i have a library and i want to write haskell bindings for it. the library uses autotools and i want to keep the haskell bindings in the source tree of the library under a directory haskell/. anyone knows of a similar project that does this? what's the best way to proceed? i think i somehow need to hook cabal into autotools etc. but not sure how
15:09:10 <dafis> karlalfred: you want cabal.exe
15:09:50 <karlalfred> I klicked on it. should I open it in the terminal?
15:09:53 <applicative> dafis, doesn't it come with the platform installer?  
15:10:06 <dafis> karlalfred: if you've installed the platform, you ought to have cabal.exe
15:10:33 <karlalfred> I will show you what I installed. one sec...
15:10:34 <dafis> applicative: hadn't thought of platform
15:10:51 <karlalfred> http://www.haskell.org/ghc/download_ghc_6_12_3.html
15:10:56 <karlalfred> that is what I got
15:10:59 <applicative> it occurs to me, are there two actions needed to install the platform -- one for ghc, the other for libs (+cabal.exe , i'd guess)
15:11:33 <karlalfred> hmm ok
15:11:57 <karlalfred> so how do I know if I have cabal?
15:12:01 <dafis> karlalfred: that's just GHC, not the platform, http://hackage.haskell.org/platform/
15:12:11 <applicative> karlalfred, the page says use the platform installer.  But now I'm worried, if you've built ghc without the platform what can happen.
15:12:31 <karlalfred> ok stupid me.
15:12:38 <karlalfred> it works to compile
15:12:50 <karlalfred> but I will uninstall it 
15:12:55 <karlalfred> and install the platform
15:13:00 <applicative> yeah, you have the ghc sounds like.   no small task!
15:14:06 <applicative> karlalfred, I think that's the best plan, I never would have made bold to put this stuff on Windows without the platform.  Of course stuff can still go wrong.  
15:14:25 * dafis wonders, why is it always so complicated to get stuff working on windows?
15:14:51 <Twey> Lack of POSIX compliance
15:15:05 <karlalfred> ok I will remove everything related to haskell first. then install the platform and see what happens...
15:15:14 * applicative thinks its worse on a mac.  actually its a nightmare on anything.  if a compiler doesn't come with your OS, you need experience of each single one.
15:16:22 <applicative> POSIX compliance is not morally required. 
15:17:17 <Axman6> i've not had much problem with ghc on OS X
15:17:30 <Axman6> recent years have made it improve a lot
15:17:38 <applicative> Hm, even with C libs you've added yourself?
15:18:52 <interferon> anyone succesfully installed Haskell on a Horse on os x?
15:19:56 <karlalfred> ok applicative and dafis. now I am installing the platform. :)
15:20:08 <thoughtpolice> my macbook is slightly on the frits otherwise I'd be able to try it
15:20:16 <thoughtpolice> (i think my fan is broke)
15:20:18 <applicative> (I noticed a bug report the other day where someone had replaced his macports perl with a symlink to the mac perl, thinking that was his problem....I'm not complaining of course.  GHC is a miracle, something divine; really it's too easy to install. )
15:20:23 <alip> how do I bind constants defined in a C header file using #define using c2hs?
15:21:11 <Polarina> What is an array fusion?
15:21:13 <thoughtpolice> also the windows dilemma is well known - there seem to be tons of people who download the HP for windows, and yet the actual amount of windows hackers is incredibly small
15:22:03 * applicative seems to remember some wrong-minded people here dissing these benefactors of humanity
15:22:16 <thoughtpolice> like, the HP for windows is downloaded by orders of magnitude more people than OS X or linux. i don't think don takes into account how many linux distros provide HP packages - you'd need popcon for that on debian at least I guess
15:22:54 <applicative> there are zillions of times more humans in possession of windows machines...
15:22:56 <thoughtpolice> i've actually also never tried building GHC from source on windows - I know it at least requires mingw/msys, but beyond that I'm not sure
15:23:41 <thoughtpolice> applicative: yes, and yet the amount of people who hack GHC on windows can be counted with half of one hand as far as I know
15:23:47 <napping> hmm, well I've got the platform on windows to mess around with ghci
15:24:06 <napping> and usually get ghc on linux by itself and add stuff as needed with cabal
15:24:07 <karlalfred> if I was on a linux box I would compile it from source. but can you do it on windows?
15:24:10 <dafis> thoughtpolice: also, why bother with the platform if you don't need it on linux?
15:24:12 <applicative> thoughtpolice, it's because it's so hard.  they just install linux, its the easy way
15:24:36 <thoughtpolice> those people are, as far as I know: simon marlow, and ian lynagh
15:24:43 <thoughtpolice> aka JaffaCake and Igloo
15:24:45 <monadic_kid> alip: enum hooks: http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/implementing.html
15:25:32 <applicative> karlalfred, it should be possible to install even the devel versions of GHC once you have a GHC.  Getting the first one can be rough. 
15:25:55 <applicative> karlalfred, on the other hand, you haven't lived until you've watched the ghc self-compile....
15:25:56 <karlalfred> ok I have the HP
15:26:03 <thoughtpolice> karlalfred: you can, it's just not clear (at least to me) how much more of a process it is than linux
15:26:07 <EvanR-work> i have 9999 HP
15:26:14 <karlalfred> ok
15:26:20 <thoughtpolice> also installing GHC from source is like stupidly simple really once you have the darcs repos
15:26:26 <applicative> can you find cabal.exe?
15:26:33 <thoughtpolice> something like 'perl ./boot; ./configure; make; make install'
15:26:37 <thoughtpolice> i think that's it
15:26:42 <karlalfred> I have the cabal.exe yes
15:27:30 <dafis_> karlalfred: then try cabal update, after that, cabal install wx
15:27:30 <karlalfred> I can find it in C:\Program Files (x86)\Haskell Platform\2010.2.0.0\lib\extralibs\bin
15:27:42 <thoughtpolice> dafis: i think people on linux probably definitely need the platform less than OS X/windows, but at the very least no matter what it's a baseline set of libraries/versions that can be respected easily among multiple OSs, by, uh, just installing it
15:27:44 <applicative> can you ask it --help  ?  try `cabal install pony` first
15:27:50 <applicative> after update
15:27:53 <dafis_> karlalfred: after you've put that dir in the path
15:28:17 <karlalfred> can you run cabal from anywhere in the terminal in windows?
15:28:29 <karlalfred> I will open the terminal to see...
15:28:43 <karlalfred> ok it works
15:28:51 <applicative> AWESOME
15:28:57 <karlalfred> :)
15:29:35 <applicative> so i guess in principle cabal install wx should work.
15:29:48 <karlalfred> great
15:29:55 <karlalfred> so it is like some kind of package manager?
15:29:59 <karlalfred> for haskell
15:30:01 <applicative> pretty much
15:30:02 <thoughtpolice> kalven: yes, that's exactly what cabal is
15:30:07 <karlalfred> great! =D
15:30:21 <EvanR-work> ruby gems
15:30:21 <applicative> check out hackage.haskell.org
15:30:28 <karlalfred> cabal in now updated and I will try to install ws
15:30:35 <karlalfred> wx
15:30:38 <thoughtpolice> i will say this, however: in my experience, it's a crapshoot as to whether 'cabal install foo' will Just Work on windows like it tends to on linux
15:30:39 <EvanR-work> haskell cabbages
15:30:57 <applicative> karlalfred, wx may cause further trouble, since it's so complicated.  don't be dispirited.
15:31:24 <karlalfred> :) ok but I am curious to find out.
15:31:26 <thoughtpolice> that's to say, there are seemingly no windows haskell hackers, and because of it very few of the packages on hackage have ever even been built or attempted to have been built on windows
15:31:35 <thoughtpolice> of course, I'm sure those people would gladly accept patches :)
15:31:35 <monadic_kid> thoughtpolice: it's more of a problemw when it comes down to binding libraries
15:31:40 <thoughtpolice> monadic_kid: yeah, seriously
15:32:01 <nooodl> hmm, i've got this big number
15:32:09 <napping> and a lot of that at least beings with the problem of installing the things being bound in the first place
15:32:11 <nooodl> whenever i divide it by 2, i get scientific notation
15:32:15 <dafis> nooodl: how big?
15:32:18 <applicative> its all about the C libs, same on a mac.   You need a C-cabal-install, also known as apt get or pacman...
15:32:19 <thoughtpolice> monadic_kid: things that typically just depend on the base set of libraries are normally OK, but anything foreign binded is a much bigger question
15:32:24 <napping> you can't just ap-get stuff
15:32:30 <nooodl> dafis: factorial 40
15:32:40 <napping> nooodl: If you use / you end up with imprecise floating point numers
15:32:42 <karlalfred> pacman on arch linux is nice...
15:32:51 <napping> nooodl: if it's just digits you probably get an Integer
15:32:53 <applicative> pacman is a miracle too...
15:32:54 <EvanR-work> > fact 40
15:32:55 <lambdabot>   Not in scope: `fact'
15:32:56 <dafis> nooodl: use Integer and quot
15:33:00 <EvanR-work> > factorial 40
15:33:00 <lambdabot>   Not in scope: `factorial'
15:33:06 <napping> or (%) from Rational
15:33:10 <dafis> > product [1 .. 40] `quot` 2
15:33:11 <lambdabot>   407957641623948867172805634798057947136000000000
15:33:15 <nooodl> > product [1..40] `div` 2
15:33:17 <lambdabot>   407957641623948867172805634798057947136000000000
15:33:37 <nooodl> hey, "div" works too, it seems.
15:33:52 <monadic_kid> I use linux (fedora) on a VM do my haskell coding on that.
15:34:04 <nooodl> > toInteger $ product [1..40] / 2
15:34:05 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:34:05 <lambdabot>    `GHC.Real.Fractional a'
15:34:06 <lambdabot> ...
15:34:07 <dafis> nooodl: yes, and it works even better with negative numbers, but quot is faster
15:34:13 <opqdonut> @scheck \x -> (div x, mod x) == (quot x, rem x)
15:34:14 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
15:34:14 <lambdabot>    arising from a use of `GHC.Cla...
15:34:31 <opqdonut> gah :D
15:34:31 <karlalfred> I like linux better then windows. I use windows for games. I hope they will make more good platform indipendent games that work with linux also so that I can continue only using only linux in the future.
15:34:33 <applicative> karlalfred, i have to go. I hope the rest goes well.  There is usually someone here who knows something about Windows, it tends to be the masters like duncan coutts though. 
15:34:42 <opqdonut> @scheck \x y -> (div x y, mod x y) == (quot x y, rem x y)
15:34:42 <lambdabot>   "Falsifiable, after 4 tests:\n1\n-2\n"
15:34:55 <karlalfred> thank you very much for your help guys!
15:35:01 <opqdonut> divMod and quotRem differ in how they handle negative numbers
15:35:11 <karlalfred> applicative and dafis thnx
15:35:48 <dafis> karlalfred: did cabal install work?
15:35:54 <monadic_kid> karlalfred: linux on virtualbox, problem solved for me. Even supports hardware accelerated GL (version 2.1)
15:36:58 <karlalfred> ok I have never used virtualbox. I have only used VM-ware.
15:37:04 <karlalfred> what is the difference?
15:38:18 <mszep> Hello room I have a question: I'm trying to get a git-like behavior in that my program starts vim, lets the user edit and save a file, and then reassumes control. It's not working because the rawSystem call to vim locks the file long enough for the next statement in the "do" list to raise an error (I'll try to paste my code next). My question is what is the easiest way to stall execution until the user has saved the file from vim?
15:38:29 <mszep> getDescription :: Filename -> IO Description
15:38:29 <mszep> getDescription filename = do
15:38:29 <mszep>   writeFile "tmp_description.txt" $ "Replace this text with your annotations \
15:38:29 <mszep>                                      \for file " ++ filename ++ "\n"
15:38:29 <mszep>   rawSystem "vim" ["tmp_description.txt"]
15:38:30 <mszep>   readFile "tmp_description.txt"
15:39:21 <dafis> mszep: get an exit-code?
15:39:39 <mszep> dont know :-)
15:39:53 <ezyang> Idea: Get rid of the PVP for version numbers, and introduce an automatically generated API version number that is used for API matching. 
15:39:55 <mszep> everything seems to work ok until the invocatin of vim
15:40:30 <Zeiris> Monads describe side effects, right? So, a really common and really useful pattern would be to create a new monad, like NetIO. Then have runNetIO be an IO action, possibly with restrictions on which sockets the monad can operate. And then NetIO functions would be pure, -except- with respect to whatever networking primitives I exposed from IO...
15:40:49 <ezyang> Zeiris: Yes. You can do this with the Prompt monad. 
15:41:09 <ezyang> But if you're just interacting with sockets, the Iteratee monad might be a closer fit. 
15:41:38 <mszep> dafis: were you asking or suggesting? cause how would I solve it using the exit code of rawSystem?
15:42:45 <dafis> mszep: suggesting; if you demand the exit code of rawSystem, that should have completed before the next action in main runs
15:43:28 <dafis> mszep: ec <- rawSystem ...; ec `seq` readFile ...
15:43:53 <dafis> mszep: don't know if that works, but worth a try
15:44:09 <mszep> so just demanding it should be enough? in other words, if you don't demand it, the runtime is clever enough to skip right away to the next statement instead of wating for an exit code?
15:44:59 <karlalfred> dafis: I got an error message when I tried to install wx with "cabal install wx"
15:45:14 <dafis> karlalfred: which error?
15:45:38 <karlalfred> I will post it on pastebin
15:46:12 <dafis> mszep: I don't know, depends on when rawSystem returns, after vim is invoked (then it won't work) or after vim has finished
15:46:48 <karlalfred> dafis: http://pastebin.com/3uWkQPcs
15:46:59 <Veinor> mszep, dafis: it works for me
15:47:19 <Veinor> but it also works without the seq
15:48:11 <mszep> for me it doesnt work without the seq...
15:48:43 <karlalfred> something wrong with wx-config?
15:48:54 <mszep> oh no, wait I'm doing it wrong..
15:48:55 <dafis> karlalfred: you need wx-config, have you installed that and put it in the path?
15:49:18 <karlalfred> before I get wx?
15:49:31 <dafis> karlalfred: the windows wxWidgets doesn't include wx-config
15:49:36 <Zeiris> @hoogle fix
15:49:36 <lambdabot> Data.Function fix :: (a -> a) -> a
15:49:36 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
15:49:36 <lambdabot> module Control.Monad.Fix
15:49:53 <mszep> Veinor, dafis: nor does it work with `seq`
15:50:00 <dafis> karlalfred: yes, you need to install that before wxHaskell
15:50:04 <karlalfred> no I have not.
15:50:31 <eugenn> > sort "Squeak"
15:50:32 <lambdabot>   "Saekqu"
15:50:34 <Veinor> interesting
15:50:42 <Veinor> mszep: could you pastebin your entire code?
15:51:15 <mszep> *new to this* pastebin.com or something?
15:51:17 <eugenn> > sort maltso
15:51:17 <lambdabot>   Not in scope: `maltso'
15:51:26 <eugenn> > sort "maltso"
15:51:27 <lambdabot>   "almost"
15:51:35 <dafis> mszep: hpaste.org, pastebin.com, whatever
15:53:18 <eugenn> :t randomize
15:53:19 <lambdabot> Not in scope: `randomize'
15:53:20 <mszep> http://pastebin.com/fhbYjzDN
15:53:36 <eugenn> :t fuse
15:53:37 <karlalfred> dafis I have wxWidgets now. what should I do with the wx-config? Put it in the wxWidgets folder?
15:53:37 <lambdabot> Not in scope: `fuse'
15:55:16 <eugenn> > (+1) . (*4) . (-2) 40
15:55:17 <lambdabot>   No instance for (GHC.Num.Num (f a))
15:55:17 <lambdabot>    arising from a use of `e_114240' at ...
15:55:17 <ezyang> Whoo, segfault and no useful backtrace. 
15:55:31 <eugenn> > (+1) . (*4) . (-2) $ 40
15:55:32 <lambdabot>   -7
15:56:01 <dafis> karlalfred: I don't really know, maybe http://wewantarock.wordpress.com/2010/05/05/haskell-platform-2010-1-0-0-and-wxhaskell-on-windows/ explains it
15:56:14 <ezyang> What could s9TS_info me? 
15:57:44 <ski> > foldr ($) 40 [(+1),(*4),(-2)]
15:57:45 <lambdabot>   -7
15:58:10 <karlalfred> hmm it says that I should use an older haskell platform installer... :/
15:58:11 <ski> > foldr (.) id [(+1),(*4),(-2)] 40
15:58:12 <lambdabot>   -7
15:58:13 <lispy> ezyang: IIRC that's a closure in C
15:58:30 <ezyang> ok... 
15:58:32 <lispy> ezyang: not that C has closures, but I mean a GHC created struct for managing them in the RTS
15:58:46 <mszep> dafis, Veinor: pasted my entire code now.. http://pastebin.com/nUuH4u8E
15:58:50 <Berengal> I thought info was the actual code
15:59:04 * ski thought lispy might be talking about GCC:s "downward FUNARGS"
15:59:12 <lispy> ezyang: you could run your program in gdb and when you get the crash, do a backtrace
15:59:26 <ezyang> That's all the backtrace I get. 
15:59:35 <ezyang> (gdb) bt #0  0x08067f1f in s9TS_info () #1  0x00000000 in ?? () 
15:59:43 <lispy> hmm
15:59:54 <lispy> ezyang: is this a stripped binary with no debuggin symbols?
16:00:25 <ezyang> No. 
16:00:30 <ezyang> Well, I don't think it is. 
16:00:40 <ezyang> I've gotten perfectly useful traces when I've crashed in the FFI 
16:00:52 <ezyang> the trace goes to mush when I hit GHC, but that's normal, iirc 
16:01:19 <ezyang> Maybe I'll try the "stare at my code until I find the bug" strategy. 
16:01:26 <lispy> ezyang: have you tried, say running in valgrind?
16:01:38 <ezyang> ooh, good idea. 
16:01:53 <syntaxglitch> valgrind is the only thing that makes writing C tolerable for me
16:02:27 <ezyang> Conditional jump or move depends on uninitialised value(s) 
16:02:29 <c_wraith> wait, ezyang, what's the error?
16:02:37 <ezyang> Address 0x27 is not stack'd, malloc'd or (recently) free'd 
16:02:41 <ezyang> c_wraith: segfault 
16:02:47 <c_wraith> what ghc version?
16:02:59 <ezyang> 6.12.1 
16:03:09 <ezyang> But I'm mucking around with the FFI so it's my fault, not GHC's 
16:03:14 <c_wraith> Does your code depend on IO exceptions?
16:04:24 <c_wraith> or rather, new-style extensible exceptions?
16:04:24 <ezyang> It will throw IO exceptions in error conditions, yes. 
16:04:24 <ezyang> I don't do any catching. 
16:04:25 <c_wraith> Because that error looks *just* like the ones I ran into, that turned out to be a ghc bug
16:04:29 <c_wraith> seems to be a known problem with all of ghc 6.12
16:04:29 <ezyang> No, I just use error "asdf" 
16:04:30 <c_wraith> here's an easy way to check:  compile with -O0
16:04:36 <c_wraith> If it works properly then, it's not the same bug
16:04:36 <ezyang> Oh, will do. 
16:04:41 <ezyang> Do I have to recompile my library? 
16:04:53 <c_wraith> I would guess yes.
16:05:07 <dafis> mszep: I'm not sure whether it works, it gave "QThreadStorage: Thread 0x804b500 exited after QThreadStorage 2147483645 destroyed", but it created labentry.tex alright
16:05:11 <ezyang> ooh, actually, --track-origins=yes is giving plausible information. 
16:05:25 <c_wraith> is that a valgrind flag?
16:05:38 <ezyang> yeah. 
16:06:13 <mszepien> dafis: sorry, having network problems; what was your suggestion that kind of works?
16:07:36 <dafis> the code you pasted kind of works (replaced gvim with kwrite since I don't have any vi-derivates installed)
16:08:28 <mszepien> dafis: ok thats interesting.. for me the lock error shows up in the terminal as soon as the gvim window appears...
16:09:28 <dafis> mszepien: it works the same without the seq here, actually, and nothing appears in the terminal before I close the editor
16:10:52 <mszepien> dafis: odd.. maybe we're on different platforms or something, with rawSystem chosing different moments to transmit its exitcode? I'm on linux, ghc 6.8.2
16:11:54 <EvanR> why do i feel uneasy using floating enum instance
16:12:08 <EvanR> > [0,pi/10..pi-pi/10]
16:12:09 <lambdabot>   [0.0,0.3141592653589793,0.6283185307179586,0.9424777960769379,1.25663706143...
16:12:10 <c_wraith> EvanR: because it's very confusing
16:12:14 <EvanR> > length [0,pi/10..pi-pi/10]
16:12:15 <lambdabot>   10
16:12:21 <dafis> mszepien: I removed the binding of the exitcode and it worked the same, linux, 6.12.3, I'll try 6.8.3 in a moment, hang on
16:12:24 <EvanR> its 10, am i just lucky?
16:12:34 <danharaj> float shouldn't have an enum instance :\
16:12:54 <mszepien> dafis: hm, I'll try to install a more recent ghc then as well...
16:13:19 <dafis> mszepien: 6.8.3 works the same
16:14:01 <karlalfred> Copy cc1plus.exe from a MinGW 3.4.5. I can't seem to find that file. =/
16:14:08 <dafis> mszepien: a newer GHC is a good thing anyway, but it doesn't seem to be the problem here
16:14:39 <mszepien> for the record, I tried compiling instead of using runhaskell, but same result
16:14:44 <dafis> karlalfred: Oooh, methinks you need a windows expert now
16:14:56 <karlalfred> getting wx for windows was harder then I was expecting. =/
16:15:04 <karlalfred> ok
16:15:12 <ezyang> wagh, off by one error 
16:15:17 <ezyang> > [0..6] 
16:15:18 <lambdabot>   [0,1,2,3,4,5,6]
16:15:27 <ezyang> I always forget this is inclusive >:-( 
16:15:49 <EvanR> ezyang: you know whats funny, i was about to test that ;)
16:16:05 <danharaj> karlalfred: if you are using haskell platform, it still comes with a version of ghc that accidentally omits the C++ compiler part of mingw.
16:16:05 <EvanR> after writing [0..steps-1]
16:16:37 <danharaj> karlalfred: which means you can't build wx. There is a fix here: http://wewantarock.wordpress.com./
16:16:59 <ezyang> heh, it still segfaults, but at least it segfaults somewhere else. 
16:17:25 <karlalfred> yes but that method don't seem to work for me. :/
16:17:30 <EvanR> ezyang: what are you coding in... C?? ;)
16:18:45 <mszepien> dafis: the only other thing I can think of is that I'm running an old version of ubuntu.. but I don't see how that could have any influence on this..
16:18:47 <karlalfred> oh I installed a newer minGW. that is probably the reason
16:19:22 <danharaj> karlalfred: is the problem that you can't find cc1plus?
16:19:36 <karlalfred> it talks about MinGW 3.4.5 but I have MinGW 5.1.6
16:19:49 <karlalfred> yes correct!
16:20:35 <danharaj> karlalfred: it's in libexec/gcc/mingw32/3.4.5
16:20:43 <karlalfred> I also have the newest platform. should I uninstall it and use 2010.1.0.0 instead?
16:20:49 <danharaj> 5.1.6 is the mingw version, but 3.4.5 is the gcc version
16:20:52 <karlalfred> as the guy in the article
16:21:05 <dafis> mszepien: I don't see how either, but I seem to remember some funny behaviour on ubuntu
16:21:11 <danharaj> karlalfred: let me check to see what is different
16:21:35 <karlalfred> ok thank you
16:22:18 <danharaj> karlalfred: that is strange, the mingw that comes with 6.12.3, which comes with your version of haskell platform, should not have this problem.
16:22:33 <danharaj> Are you sure you are using 2010.2.0.0?
16:23:45 <karlalfred> danharaj: yes indeed. I am sure.
16:23:50 <danharaj> If so, I would not know what is wrong because I stopped using platform a month ago because of this problem.
16:23:52 <karlalfred> I have 2010.2.0.0
16:24:17 <danharaj> You should send a message on the wx mailing list, or contact Jeremy (the maintainer of wx) somehow.
16:24:31 <danharaj> Windows users get the short end of the stick, unfortunately
16:24:58 <Phyx-> danharaj: we're used to it :)
16:25:02 <danharaj> however, if you want, the fix should work
16:25:17 <danharaj> just be careful so you can revert after you try it.
16:25:20 <karlalfred> yes. I have done all this on linux without asking. it is a much better platform for programming for sure. :)
16:25:34 <karlalfred> it seems so complicated right now.
16:25:37 <karlalfred> :S
16:25:38 <danharaj> only because that's where all the unwashed library maintainers focus their efforts.
16:25:40 <karlalfred> I am confused
16:25:48 <karlalfred> yes indeed
16:25:58 <EvanR> the enum instance for floating feels like something the php inventors would have come up with
16:26:01 <EvanR> 'wouldnt this be cool if'
16:26:07 <Phyx-> "much better platform for programming"
16:26:08 <Phyx-> meh
16:26:08 <dafis> danharaj: you get the short end because so few of you take part in development
16:26:24 <syntaxglitch> windows is a fine platform for programming as long as you're willing to pay money for tools and don't mind being at the mercy of someone else to fix bugs in closed-source libraries
16:26:27 <karlalfred> Can you still compile windows programs if you use linux? I will use virtualbox then...
16:26:34 <danharaj> you just have to move a few files into ghc's copy of mingw so that it has access to the c++ compiler
16:26:48 <karlalfred> I want to do an application for my friend that uses windows also...
16:26:58 <EvanR> virtual box linux
16:27:05 <EvanR> 'best' of both world
16:27:12 <karlalfred> ok
16:27:13 <danharaj> dafis: I wouldn't mind if libraries didn't claim to work on windows but obviously don't.
16:27:27 <syntaxglitch> EvanR: Forget Enum, I'm not convinced that a Num instance makes sense for floating point values
16:27:31 <danharaj> dafis: Hackage should mark packages that aren't tested on some major platform.
16:27:36 <EvanR> Num ?
16:27:38 <dafis> danharaj: that's a valid objection
16:27:38 <Phyx-> syntaxglitch: oh please. you're currently still at the mercy of opensource developers to fix bugs
16:27:41 <Phyx-> when they want to and feel like it
16:27:56 <Phyx-> the notion that because something is open source it gets fixed faster is bull
16:27:58 <EvanR> @src Num
16:27:58 <lambdabot> class  (Eq a, Show a) => Num a  where
16:27:58 <lambdabot>     (+), (-), (*)           :: a -> a -> a
16:27:58 <lambdabot>     negate, abs, signum     :: a -> a
16:27:58 <lambdabot>     fromInteger             :: Integer -> a
16:28:12 <Phyx-> take a look at GHC itself, only a handfull of people actually know, want or care to fix it
16:28:21 <EvanR> Num seems sane enough
16:28:31 <syntaxglitch> Phyx-, if it's a big enough problem I can fix stupid open-source code myself, it's rarely a GOOD option but it's better than nothing
16:28:45 <danharaj> Phyx-: my experience with open source has been that people like to use it as an excuse to put my criticisms back on me and tell me to fix it myself.
16:29:05 <c_wraith> phyx-: I've dug through GHC code to find the source of a bug before.  I didn't fix it, but I was at least able to pinpoint the exact interaction that was causing the bug, due to having the source.
16:29:16 <dafis> danharaj: have you tried offering money ;)
16:29:42 <danharaj> dafis: If I'm going to offer money, I'll pay for a toolset like visual studio :p
16:29:44 <Phyx-> c_wraith: i'm not faulting the GHC devs for anything, they've been generally responsive. And I get they have other things to do
16:29:54 <Phyx-> but the general observation is the same as what danharaj said
16:29:58 <Phyx-> you either a) get ignored
16:29:59 <syntaxglitch> Not to mention that if it came down to it, I suspect it would be cheaper to bribe most open-source developers into fixing their stupid code than it would be to convince some software company to fix a bug they don't care about
16:30:02 <Phyx-> b) get told to fix it youself
16:30:11 <Phyx-> or c) get straight out told, that they don't care
16:30:17 <karlalfred> so the only solution I have is to get Haskell Platform\2010.1.0.0?
16:30:22 <c_wraith> Phyx-, I'm just saying it's valuable to have the GHC source, even if I'm not fixing and recompiling myself.
16:30:49 <syntaxglitch> Phyx-, how is that not better than closed source libraries, where you generally either a) get ignored b) get ignored c) get ignored unless you have huge piles of cash
16:30:54 <Phyx-> c_wraith: it's certainly valuable. I've benefitted from it. I just don't have the time to fix bugs, but atleast I report them.
16:30:55 <danharaj> syntaxglitch: I think most companies that make developer tools have a high response rate to fixing bugs. Certainly microsoft has a long history of bending over backwards to fix bugs and 'mis-features' in their tools for clients.
16:31:30 <Phyx-> syntaxglitch: every company i've ever contacted with bug reports have always responded and always told me when the bug will be fixed if any. Including microsoft
16:31:33 <Phyx-> you know why?
16:31:40 <Phyx-> because their income is dependent on it
16:32:24 <BrianHV> Phyx-: may I ask your approach to reporting bugs?  your experience does not match mine.
16:32:35 <danharaj> syntaxglitch: which companies have ignored you? so I can avoid them in the future :p
16:32:42 <syntaxglitch> maybe for outright bugs, but not so much for misfeatures or poor design decisions, or things that don't impact significant numbers of people
16:33:03 <EvanR> let n = map (\x -> length [0..100/(100/x)]) [1..] in take 10 n
16:33:04 <Phyx-> BrianHV: I usually just report on connect, the forums or sometimes mail the developer if I know their emails
16:33:07 <EvanR> > let n = map (\x -> length [0..100/(100/x)]) [1..] in take 10 n
16:33:08 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
16:33:22 <EvanR> > let n = map (\x -> length [0..100/(100/x)]) [1..] in take 10 (drop 100 n)
16:33:23 <lambdabot>   [102,103,104,105,106,107,108,109,110,111]
16:33:32 <syntaxglitch> there are more kinds of broken code than just obvious bugs
16:33:41 <danharaj> syntaxglitch: They have economic reasons for doing that. But it is more often than not that if you try to correct such things in open source, you will be ousted by politics and ideology in any reasonably large project (so that it is comparable to a closed source product in scale).
16:33:42 <Phyx-> syntaxglitch: if it doesn't impact a significant number of people, you'll get told to "gtfo" by open source people aswell
16:34:11 <danharaj> hell, there are open source projects that tell you to gtfo even if it means shooting themselves in the foot, all for the sake of misplaced passions.
16:34:12 <syntaxglitch> yes, but at least with open source I have the option to tell everyone else to take a hike and fork the code
16:34:16 <EvanR> Phyx-: hmm... democracy ;)
16:34:38 <danharaj> syntaxglitch: lovely, now you're spending your valuable time fixing someone elses shit.
16:34:42 <syntaxglitch> I don't dispute that open source developers are, if anything, worse about fixing problems that other people complain about
16:34:54 <mszepien> dafis: I got it to print the exit code of rawSystem, and it does so even before raising the lock error, and before the gvim window appears. So the exit code definitely gets produced before the vim session is terminated.
16:35:04 <Phyx-> EvanR: democracy doesn't really play a big role. No matter if you have the source. You can fork it, but only a few can commit to the main, so even if you fix it. No one will generally know about it
16:35:07 <syntaxglitch> danharaj, if fixing their shit is faster than reimplementing it and I need the functionality it offers, that's still a net win
16:35:25 <mszepien> dafis: but since you can't reproduce, I guess the sensible thing to do is just update my system and hope it goes away :-)
16:35:26 <dafis> mszepien: aha, here the exit code is only produced after the editor is closed
16:35:34 <EvanR> Phyx-: thats what i was saying... if not enough people care about the code, it wont matter ;)
16:35:36 <danharaj> syntaxglitch: That to me is like gargling battery acid. I hate working on code that I don't want to work on.
16:36:15 <syntaxglitch> danharaj, well, it's better than nothing at all
16:36:19 <danharaj> syntaxglitch: If your net win is economic, then yes, that is probably an advantage, but you would also have more clout when dealing with closed source developers too.
16:36:22 <EvanR> > eval "i dont want to work on code i dont want to work on"
16:36:23 <lambdabot>   Not in scope: `eval'
16:36:24 <tkahn6_> recommendations for good haskell books?
16:36:24 <EvanR> True
16:36:36 <danharaj> syntaxglitch: if it is purely personal enjoyment, then it is a complete net loss for me, because I hate doing that.
16:36:46 * ezyang is starting to suspect that it's better to write C-like code in C, if only for the backtraces... 
16:36:50 <mszepien> dafis: that gives me food for thought... thanks for your help anyway :-)
16:36:53 <Phyx-> I have nothing against Open source software at all. I just have something against people blantantly claiming that open source is better because it's open
16:37:09 <syntaxglitch> I'm talking about paying the dues, not personal enjoyment
16:37:09 <EvanR> no its better cause its source
16:37:18 <msieradzki> isn't it like more open
16:37:21 <msieradzki> by definition? :)
16:37:31 <danharaj> anywho
16:37:34 <dafis> tkahn6_: Simon Thompson's Craft of Functional Programming, Graham Hutton's Programming in Haskell, Real World Haskell
16:37:36 <EvanR> the opposite of source is no source, which is bad ;)
16:37:38 <danharaj> it turns out that the wx problem was just a mistake
16:37:45 <msieradzki> though that's potential start of huge flamewar so let's not drain that topic
16:37:48 <danharaj> and it was fixed almost right away in a minor release of ghc
16:37:49 <EvanR> it should be called to no no source movement ;)
16:37:59 <danharaj> but haskell platform took a few extra months moving up
16:38:00 <syntaxglitch> I prefer linux for reasons unrelated to open/closed source, so for hobby stuff non-open source is rarely an option
16:38:13 <tkahn6_> dafis: thanks
16:38:24 <EvanR> syntaxglitch: youd rather use closed source code? o_O
16:38:31 <EvanR> programs
16:38:40 <Phyx-> and when you ask the mahority of people they say "It's open, you can change it if you want it", the fact is, a very small percentage of people actually using a software have the ability to understand and change it usually. So by large I don't see that is a selling point
16:38:59 <Phyx-> non-open source with a good api is alot better than open source and no api
16:39:02 <syntaxglitch> Phyx-, yes, that's a terrible reason to claim open-source is superior in general
16:39:17 <danharaj> Phyx-: The problem is that open source culture does not have a very strong user serving culture.
16:39:25 <syntaxglitch> but in specifics, I'm a programmer, I do have the ability to fix stuff if I have to, so it's a benefit to me
16:39:36 <EvanR> while it *should* sell to people who can change the code, stallmans rebuttal to that is people in general should be able to debug their own programs. like knowing how to fix your car saves you the hassle of being screwed over at the shop
16:39:43 <danharaj> Open source is all about developers, not users.
16:39:44 <Phyx-> danharaj: that I agree with
16:39:51 <mathijsje> Can somebody explain me how to force evaluation on a list in the IO monad?
16:39:52 <danharaj> If you're a user, you will often get sidelined.
16:39:52 <lambdabot> mathijsje: You have 1 new message. '/msg lambdabot @messages' to read it.
16:40:03 <syntaxglitch> most end users aren't programmers and having source code available does them no good at all
16:40:12 <mathijsje> I've got the following bit of code, http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=28657#a28657, but for some reason my list of pixels doesnt seem to get evaluated untill its written to file
16:40:16 <danharaj> Unless it is a small project. People tend to be nicer when the politics of the mob aren't in the way.
16:40:32 <EvanR> danharaj: Phyx-: just today the developer of my paint program came into the channel and i asked him to add a few trivial but useful features, he agreed ;)
16:40:53 <mathijsje> i'm trying to measure the time taken to evaluate the list, without the time spending writing the list to file included.
16:40:56 <danharaj> Open source is good for one reason: The culture helps smaller developers get out their ideas, people who really want to help others with their talents.
16:41:09 <dafis> mathijsje: seq x x is the same as x
16:41:21 <Phyx-> danharaj: but even then, I'm not faulting them, it takes time, there's little to no incentive, and the community is generally unsupportive and only critize
16:41:44 <Phyx-> EvanR: sure, but that could have happened with a closed sourced program aswell. If you happen to see the dev
16:41:56 <noteventime> mathijsje: You know about things like Criterion?
16:42:12 <dafis> mathijsje: perhaps timeEnd <- length lazyPixels `seq` getCurrentTime forces enough
16:42:20 <EvanR> those guys are typically going to ask you for money or a shareware license
16:42:45 <noteventime> Otherwise you may want deepseq
16:42:48 <danharaj> EvanR: and for that they will be more willing to meet your needs.
16:42:51 <mathijsje> noteventimeL: No, what is it?
16:43:01 <Phyx-> EvanR: I tend to stay away from writers of shareware stuff. but For instance, the daemon-tools dev listen to user requests. yet afaik it's not open source
16:43:03 <EvanR> i could make the trivial changes for him for all i care ;)
16:43:19 <danharaj> anyway
16:43:23 <danharaj> Haskell doesn't have too many problems
16:43:32 <Phyx-> i dissagree
16:43:34 <danharaj> just sometimes people get careless about windows support and it's a bit annoying
16:43:45 <danharaj> Compared to say, *shudder* "pythonic" culture.
16:43:52 <Phyx-> Haskell is suffering more and more lately that people use unix only dependencies in their libraries
16:43:56 <Phyx-> or tools
16:44:04 <Phyx-> which force windows user to run in something like cygwin or mingw
16:44:09 <danharaj> They are just fulfilling the prime directive.
16:44:17 <danharaj> Avoid success at all costs.
16:44:18 <dafis> danharaj: how should people support windows if they don't have a windows machine?
16:44:19 <Phyx-> rather annoying, sometimes unneeded, but I can live with it i suppose
16:44:24 <syntaxglitch> People use Windows without cygwin installed? Crazy :D
16:44:28 <mathijsje> dafis: That doesnt seem to force it.
16:44:33 <danharaj> dafis: They should then clearly mark their packages as not tested on windows.
16:44:41 <danharaj> at least in the haddocks
16:44:44 <noteventime> mathijsje: http://hackage.haskell.org/package/criterion
16:45:01 <Phyx-> dafis: but why is the reverse unaccepted? If someone releases a package that works only on windows, they'll be alot more fuss than the reverse
16:45:03 <dafis> mathijsje: then you probably need deepseq
16:45:18 <Phyx-> last checked for instance, cabal init doesn't work on windows
16:45:22 <Phyx-> if i remember correctly
16:45:23 <EvanR> i think the answer is obvious
16:45:24 <danharaj> A few weeks ago I wrangled with building the SDL binding libraries. The installation instructions on windows were just *wrong* and I'm not even sure one of them (mixer) can even be built on windows.
16:45:34 <EvanR> who cares about the windows platform
16:45:38 <dafis> Phyx-: has that ever happened? I don't remember any such fuss
16:45:40 <msieradzki> I
16:45:43 <EvanR> or why should i care
16:46:08 <msieradzki> depends if you make libraries or just write your own code :)
16:46:49 <Phyx-> dafis: I can't name one from the top of my head, but I can grep Haskell-cafe someday
16:46:58 <EvanR> a lot of my tools are already incompatible with windows, why should my haskell code be anydifferent
16:46:59 <Phyx-> EvanR: that's exactly the mindset I hate
16:47:03 <ozamosi> Yeah. The world would be a better place if the people who wrote generic components would just stop releasing them, unless they first went out and bought windows. ;)
16:47:29 <EvanR> valgrind, XFCE, real text editors...
16:47:40 <EvanR> mencoder
16:47:47 <EvanR> (actually that probably works...)
16:48:01 <msieradzki> EvanR for instance I usually work on linux machine but  want to demo app on windows or on windows notebook, not entirely impossible use case
16:48:19 <EvanR> demo for what purpose
16:48:32 <EvanR> gui app?
16:48:39 * fryguybob cares mostly about things written in haskell (not bindings to libs) and doesn't have to worry about the fact that he is on windows.
16:49:03 <danharaj_> gui app?
16:49:06 <EvanR> if the gui app doesnt work on windows, well you probably dont care about demoing it on windows
16:49:54 <msieradzki> no, not gui
16:49:57 <Zeiris> Is there some simple representation of the instances I'm using here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28658#a28658
16:50:01 <EvanR> terminal app?
16:50:34 <EvanR> ssh client
16:50:38 <msieradzki> slow
16:50:44 <kmc> mathijsje, seq on a list only evaluates the first cons cell
16:50:59 <EvanR> over the internet maybe
16:51:03 <kmc> if you want to force the whole thing, you need to walk the whole list
16:51:04 <Zeiris> The sheer repetition of a<-dec;b<-dec;c<-dec;... suggests there's some way to represent it with >>=, and have type inference figure out what the type of dec is. Since the type constructor at the end determines both type and signature.
16:51:24 <kmc> using for example the deepseq package
16:51:47 <kmc> Zeiris, well, there's *always* a translation from "do" to >>=
16:52:10 <kmc> liftM3 Mod dec dec (liftM2 (,) dec dec))
16:52:12 <kmc> should do it
16:52:24 <syntaxglitch> Zeiris, wouldn't something like e.g. Mod <$> dec <*> dec ((,) <$> dec <*> dec) do the trick?
16:52:26 <kmc> s/liftM/liftA/g if you're in an applicative mood
16:52:42 <dafis> Zeiris: liftM Constructor `ap` dec `ap` dec ...
16:52:46 <mathijsje> kmc, dafis: I'll look at deepseq.
16:52:51 <Zeiris> Hm, I haven't groked applicative functors yet. Guess it's time.
16:53:07 <dafis> Zeiris: or the Applicative style, which is prettier
16:53:14 <kmc> mathijsje, you can use "evaluate" from Control.Exception to force something to whnf as an IO action
16:53:25 <kmc> so e.g. «evaluate (mylist `deepseq` ())»
16:53:33 <syntaxglitch> Zeiris, code like what you've got is exactly where Applicative works so much better
16:55:47 <syntaxglitch> Zeiris, Applicative is basically just a way to chain a multi-argument function through a Functor, e.g. if you want to add two Maybe numbers you could do (+) <$> x <*> y
16:55:47 <_unK> > catch (putStr . show $ (read " "::Int)) (\_ -> putStr "wtf")
16:55:48 <lambdabot>   <IO ()>
16:56:19 * syntaxglitch probably spends too much time evangelizing Applicative
16:56:21 <Zeiris> syntaxglitch, awesome, that's exactly what I've been looking to do for a while now.
16:56:44 <kmc> Applicative is so great
16:56:54 <syntaxglitch> Zeiris, I might as well plug this since people seem to like it: http://stackoverflow.com/questions/3242361/haskell-how-is-pronounced/3242853#3242853
16:57:22 <_unK> could anyone tell me, why expression `catch (putStr . show $ (read " "::Int)) (\_ -> putStr "wtf")` doesn't catch the exception?
16:58:17 <syntaxglitch> Zeiris, on a conceptually more abstract level, the key difference between Applicative and Monad is that Monad lets you embed control flow in the lifted functions
16:58:56 <syntaxglitch> If you're not making any control flow choices based on the variables bound in a monadic expression, you probably only need Applicative
16:59:03 <dafis> _unK: because the read isn't performed before the time to catch has passed
16:59:11 <kmc> _unK, maybe you want readIO
16:59:42 <dafis> _unK: try (putStr . show $! read " ")
16:59:46 <kmc> catch (readIO " " :: IO Int >>= print) (\_ -> putStr "wtf")
17:00:05 <kmc> but, to catch "read" failure it's better to use reads and just pattern-match
17:00:11 <kmc> :t reads
17:00:12 <lambdabot> forall a. (Read a) => String -> [(a, String)]
17:00:18 <danharaj_> if the most general monad is the continuation monad, what is the most general applicative functor?
17:00:26 <kmc> :t \x -> case reads x of [(v,"")] -> Just v; _ -> Nothing
17:00:27 <lambdabot> forall a. (Read a) => String -> Maybe a
17:00:36 <_unK> hmm
17:00:47 <_unK> thx for answers, I'll look into it
17:00:55 <syntaxglitch> danharaj_, I don't know if there really is such a thing
17:01:01 <kmc> bbl
17:01:26 <danharaj_> syntaxglitch: there should be an applicative functor
17:01:28 <danharaj_> that is free
17:01:31 <danharaj_> maybe?
17:01:43 <syntaxglitch> The reason why the continuation monad is so powerful is exactly what I said: Monads can embed control flow, and continuations are the One Control Flow Operator To Rule Them All
17:03:48 <dafis> _unK: and you want Control.Exception.catch, not Prelude.catch, btw.
17:05:07 * syntaxglitch heads out for dinner
17:07:40 <EvanR> is Monoid mconcat defaulted?
17:07:54 <Phyx-> ?type first
17:07:56 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
17:08:03 <Phyx-> ?type first (1,0)
17:08:04 <lambdabot>     No instance for (Arrow (,))
17:08:04 <lambdabot>       arising from a use of `first' at <interactive>:1:0-10
17:08:04 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
17:08:09 <Phyx-> ?type first 4
17:08:11 <lambdabot> forall (a :: * -> * -> *) b c d. (Num (a b c), Arrow a) => a (b, d) (c, d)
17:08:17 <Phyx-> ?type first 4 (0,1)
17:08:18 <lambdabot> forall c t. (Num c, Num t) => (c, t)
17:08:23 <Phyx-> > first 4 (0,1)
17:08:24 <lambdabot>   (4,1)
17:09:19 <EvanR> is foldl' always better than foldl
17:09:46 <Phyx-> only when the operator isn't strict
17:10:20 <syntaxglitch> GHC is often smart enough to figure out that a left fold should be strict anyway
17:10:28 <EvanR> mconcat xs = foldl' mappend mempty xs ?
17:10:36 <syntaxglitch> so in many cases foldl is better if only due to being one fewer character
17:10:40 <msieradzki> where often doesn't include ghci?
17:11:15 <syntaxglitch> where "often" doesn't include unoptimized code, so yes, not in GHCi
17:11:21 <karlalfred> where should I put wx-config.exe to install it?
17:11:54 <karlalfred> I got this http://wewantarock.wordpress.com to work now. but I need to install wx-config.exe also
17:14:59 <kcalbgod> i'm trying to put a command in my simple haskel irc bot, which would cause the bot to go silent and stop returning results from the usual commands, for a duration...  wondering how to go about that... and i know u guys always come up with a million great ideas.  here's my neat lil page for it: http://wastedartist.com/scripts/daskeb/daskeb.html
17:18:13 <kcalbgod> i'm still such a haskell noob, still not even got very far through learn you a haskell for great good.  ^_^   but it's great that i've already got more than a xmonad configuration on the go.    +1 for haskell.  ^_^
17:20:00 <Twey> kcalbgod: The small-scale way is to split your ‘listen’ into ‘listenSilent’ and ‘listenNormal’ and have listenNormal switch to listenSilent instead of returning
17:24:36 <EvanR> should i use the Num constraint on the newtype declaration, the Monoid instance, or in the types of the operations
17:25:22 <roconnor> EvanR: very rarely do you put constraints on data type declarations
17:25:35 <EvanR> thats what i heard
17:25:37 <roconnor> mostly because it doesn't do what you might think it does
17:25:46 <roconnor> and what it does do isn't very useful
17:25:53 <EvanR> what does it do?
17:26:03 <c_wraith> amusingly, if you use a GADT, you can add constraints, and those do what you think. :)
17:26:13 <roconnor> IIRC it adds the constraints to the constructors
17:26:15 <roconnor> not sure
17:26:42 <copumpkin> yeah
17:26:49 <EvanR> the monoid instance uses +, so should it be on the instance declaration
17:26:52 * syntaxglitch seems to recall that the net result is you have to put the constraints on every function using the type, even where it wouldn't be otherwise necessary
17:28:30 <kcalbgod> woops!   forgot i still have this temp name on...
17:32:57 <EvanR> hrm some of my operations only make sense for a subset of Num types... like Fractional and Complex a
17:33:37 <EvanR> getting lost in numeric polymorphism
17:34:26 <roconnor> EvanR: you can put individual constraints on each function
17:34:48 <osaunders> @let recursive = recursive
17:34:49 <lambdabot>  Defined.
17:34:57 <osaunders> :t recursive
17:34:58 <lambdabot> forall t. t
17:35:02 <EvanR> oh no he didnt
17:35:20 <osaunders> > t 1
17:35:21 <lambdabot>   Couldn't match expected type `t1 -> t'
17:35:22 <lambdabot>         against inferred type `Simpl...
17:35:38 <osaunders> > t 1 2 3 4 5 6
17:35:39 <lambdabot>   Couldn't match expected type `t1
17:35:39 <lambdabot>                                -> t2
17:35:40 <lambdabot>      ...
17:35:42 <EvanR> @more
17:36:12 <osaunders> Oh whoops
17:36:16 <osaunders> > recursive 1
17:36:20 <lambdabot>   mueval-core: Time limit exceeded
17:36:25 <osaunders> Ah, OK.
17:37:09 <syntaxglitch> > fix error
17:37:10 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
17:37:34 <syntaxglitch> that has to be the most misleadingly-named expression possible
17:37:41 <syntaxglitch> "oh, I have an error, I'll fix it"
17:37:42 <EvanR> *suddenly a laugh track plays in response to fix error*
17:38:39 <syntaxglitch> > fmap fix return "Ok"
17:38:40 <lambdabot>   "Ok"
17:39:57 <Veinor> > fix show
17:39:57 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:40:12 <EvanR> > break show
17:40:13 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
17:40:13 <lambdabot>         against inferred type ...
17:40:27 <Veinor> :t fmap fix
17:40:27 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
17:40:29 <EvanR> > fix break
17:40:30 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
17:40:39 <Veinor> :t fmap fix return
17:40:39 <lambdabot> forall a. a -> a
17:40:44 <EvanR> > break fix
17:40:45 <lambdabot>   Overlapping instances for GHC.Show.Show
17:40:45 <lambdabot>                              ([GHC....
17:41:13 <syntaxglitch> Veinor, it's magic
17:41:50 <Veinor> I wanna understand it :P
17:42:29 <syntaxglitch> Veinor, think about how you could unify the types for (fmap fix) and return
17:42:50 <Kaidelong> :t return
17:42:51 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:42:57 <Kaidelong> :t fmap fix return
17:42:58 <lambdabot> forall a. a -> a
17:43:52 <Veinor> hm
17:44:18 <Veinor> :t (fmap fix :: (a -> a -> a) -> (a -> a)) return
17:44:19 <lambdabot> forall a. a -> a
17:44:31 <Veinor> :t (fmap fix :: (a -> a -> a) -> (a -> a)) (return :: a -> a -> a)
17:44:32 <lambdabot> forall a. a -> a
17:44:40 <robryk> @src fix
17:44:41 <lambdabot> fix f = let x = f x in x
17:45:24 <Veinor> why the let-binding?
17:45:34 <Saizan> moar sharing
17:45:45 <robryk> and what would you expect?
17:45:53 <copumpkin> fix f = f (fix f)
17:45:54 <syntaxglitch> Veinor, what monad and functor are return and fmap being specialized to?
17:45:56 <robryk> ah
17:46:15 <Kaidelong> (a -> b) -> f a -> f b   and   (a -> a) -> a    would become ((a -> a) -> a) -> f (a -> a) -> f a, fix is of type ((a -> a) -> a) 
17:46:16 <Veinor> syntaxglitch: I think I get why it typechecks
17:46:50 <Kaidelong> oh oops
17:47:12 <syntaxglitch> Veinor, yeah, but if you're still trying to figure out why it works, it's a good first step
17:47:23 <syntaxglitch> it's actually pretty stupid, in the end :P
17:48:07 <Veinor> well, return in the ((->) a) monad is just const, isn't it?
17:48:11 <syntaxglitch> yep
17:48:18 <syntaxglitch> can't really be anything else
17:48:23 <Veinor> right.
17:48:32 <Veinor> and fmap in that monad is just (.)
17:48:36 <syntaxglitch> yep
17:48:47 <Veinor> so it becomes (fix . const) x
17:48:48 <syntaxglitch> so it's fix . const
17:48:55 <Veinor> and fix (const x) is just x
17:49:01 <syntaxglitch> yep
17:49:03 <Veinor> clever.
17:49:07 <syntaxglitch> it's a cheap trick
17:49:21 <syntaxglitch> but totally baffling at first glance :D
17:49:25 <robryk> how is lambdabot different from ghci?
17:49:34 <syntaxglitch> lambdabot has extra magic
17:49:36 <EvanR> caleskell
17:49:51 <Kaidelong> lambdabot also can't do some kinds of IO, right?
17:49:57 <robryk> because error (error "x") behaves differently, I think
17:50:12 <robryk> caleskell?
17:50:23 <EvanR> it cant do any IO whatsoever
17:50:29 <robryk> > error (error "x")
17:50:30 <lambdabot>   *Exception: x
17:50:37 <syntaxglitch> caleskell is a dialect of Haskell with some, uh, stylistic improvements
17:50:41 <syntaxglitch> or so I gather
17:50:49 <robryk> oh, sorry; though i've seen some other answer somewhere up
17:50:50 <EvanR> > 1 1
17:50:50 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:50:51 <lambdabot>    `GHC.Num.Num t' arising f...
17:51:12 <Veinor> > :t 1 1
17:51:13 <lambdabot>   <no location info>: parse error on input `:'
17:51:14 <Veinor> er
17:51:16 <Veinor> :t 1 1
17:51:16 <lambdabot>     Ambiguous type variable `t' in the constraint:
17:51:17 <lambdabot>       `Num t' arising from the literal `1' at <interactive>:1:2
17:51:17 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
17:51:20 <Phyx-> let 1 = (+2) in (1 1) 0
17:51:23 * syntaxglitch writes a replacement prelude that defines id as (fmap fix return)
17:51:25 <Phyx-> > let 1 = (+2) in (1 1) 0
17:51:26 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:51:26 <lambdabot>    `GHC.Num.Num t' arising f...
17:51:45 <EvanR> i thought caleskell had applicative numbers
17:51:55 <EvanR> or something
17:52:09 <Phyx-> > let 1 = (+2) in 1 0
17:52:10 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:52:10 <lambdabot>    `GHC.Num.Num t' arising f...
17:52:38 * syntaxglitch actually wonders what all "caleskell" entails
17:52:42 <Phyx-> compile... compile....
17:53:25 <robryk> hm. why does error $ error "x" behave differently from error (error "x") ;  i assume it has something to do with laziness of $, but it's somewhat unclear to me
17:54:09 <Kaidelong> @src ($)
17:54:09 <lambdabot> f $ x = f x
17:54:36 <Kaidelong> well that didn't help, hmm
17:54:46 <Phyx-> @infix ($)
17:54:47 <lambdabot> Prelude
17:54:51 <Phyx-> lol?
17:55:11 <robryk> the exception value gets evaluated when it is about to be displayed, right?
17:55:20 <robryk> what was that supposed to return?
17:55:27 <robryk> (that == @infix)
17:55:33 <Kaidelong> > error (error "x")
17:55:35 <lambdabot>   *Exception: x
17:55:43 <Kaidelong> > error $ error "x"
17:55:44 <lambdabot>   *Exception: *Exception: x
17:55:56 <robryk> oh. maybe error is strict?
17:55:58 <robryk> :t error
17:55:59 <lambdabot> forall a. [Char] -> a
17:56:04 <robryk> doesn't seem so...
17:56:52 <robryk> sorry if that will cause a message storm, but i think lambdabot isn't likely to do that
17:56:54 <robryk> @src error
17:56:54 <lambdabot> error s = throw (ErrorCall s)
17:57:11 <Kaidelong> :t throw
17:57:12 <lambdabot> Not in scope: `throw'
17:57:15 <robryk> > throw $ error "x"
17:57:15 <lambdabot>   Not in scope: `throw'
17:57:22 <Kaidelong> that's helpful
17:57:44 <Kaidelong> @hoogle throw
17:57:44 <lambdabot> Control.Exception throw :: Exception e => e -> a
17:57:45 <lambdabot> Control.OldException throw :: Exception e => e -> a
17:57:45 <lambdabot> Control.Exception.Base throw :: Exception e => e -> a
17:58:00 <Heffalump> I really don't get it. $ should be the head redex, so get reduced straight away.
17:58:09 <syntaxglitch> :t \w x y z f g = f (g w) (g x) (g y) (g z)
17:58:10 <lambdabot> parse error on input `='
17:58:15 <syntaxglitch> :t \w x y z f g -> f (g w) (g x) (g y) (g z)
17:58:16 <lambdabot> forall t t1 t2. t -> t -> t -> t -> (t1 -> t1 -> t1 -> t1 -> t2) -> (t -> t1) -> t2
17:58:19 <robryk> but during that reduce you might get the exception
17:58:36 <syntaxglitch> :t let ha w x y z f g = f (g w) (g x) (g y) (g z) in ha.ha
17:58:36 <lambdabot> forall t t1 t2 t3 t4. t2 -> (t2 -> t2 -> t2 -> (t3 -> t3 -> t3 -> t3 -> t4) -> (t2 -> t3) -> t4) -> (t2 -> t2 -> t2 -> (t3 -> t3 -> t3 -> t3 -> t4) -> (t2 -> t3) -> t4) -> (t2 -> t2 -> t2 -> (t3 ->
17:58:37 <lambdabot> t3 -> t3 -> t3 -> t4) -> (t2 -> t3) -> t4) -> (t -> t -> t -> t -> t1) -> ((t2 -> t2 -> t2 -> (t3 -> t3 -> t3 -> t3 -> t4) -> (t2 -> t3) -> t4) -> t) -> t1
17:58:42 <syntaxglitch> :t let ha w x y z f g = f (g w) (g x) (g y) (g z) in ha.ha.ha.ha.ha.ha
17:58:45 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12. t10 -> (((((t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) -> t12) -> (t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12)
17:58:45 <lambdabot> -> (t10 -> t11) -> t12) -> (t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) -> t12) -> (t8 -> t8 -> t8 -> t8 -> t9) -> ((t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12)
17:58:45 <lambdabot> -> (t10 -> t11) -> t12) -> t8) -> t9) -> ((t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) -> t12) -> (t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) ->
17:58:45 <lambdabot>  t12) -> (t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) -> t12) -> (t8 -> t8 -> t8 -> t8 -> t9) -> ((t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) ->
17:58:45 <lambdabot>  t12) -> t8) -> t9) -> ((t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) -> t12) -> (t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) -> t12) -> (t10 ->
17:58:47 <lambdabot> [508 @more lines]
17:58:50 <EvanR> @more
17:58:51 <lambdabot> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) -> t12) -> (t8 -> t8 -> t8 -> t8 -> t9) -> ((t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) -> t12) -> t8) ->
17:58:51 <lambdabot> t9) -> (t6 -> t6 -> t6 -> t6 -> t7) -> (((t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) -> t12) -> (t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) ->
17:58:53 <lambdabot> t12) -> (t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) -> t12) -> (t8 -> t8 -> t8 -> t8 -> t9) -> ((t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) ->
17:58:55 <lambdabot> t12) -> t8) -> t9) -> t6) -> t7) -> (((t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) -> t12) -> (t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) ->
17:58:57 <lambdabot> t12) -> (t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) -> t12) -> (t8 -> t8 -> t8 -> t8 -> t9) -> ((t10 -> t10 -> t10 -> (t11 -> t11 -> t11 -> t11 -> t12) -> (t10 -> t11) ->
17:58:57 <EvanR> oops
17:58:59 <lambdabot> [503 @more lines]
17:59:10 <Heffalump> robryk: why? $ doesn't throw anything.
17:59:20 <syntaxglitch> there's plenty more, but you'll have to try it in your own GHCi :P
17:59:40 <robryk> i don't know when the exception happens exactly
17:59:44 <robryk> when you reduce error?
17:59:56 <robryk> or after you've reduced error?
17:59:57 <EvanR> when error is evaluated it causes a runtime error
18:00:03 <robryk> ok
18:00:05 <EvanR> like undefined but with a message
18:00:15 <robryk> so error (error "x") should give you Exc: Exc: a
18:00:17 <Heffalump> I guess it's all ok due to the semantics of imprecise exceptions.
18:00:32 <Heffalump> but I still don't understand why it happens operationally.
18:00:55 <EvanR> @src head
18:00:55 <lambdabot> head (x:_) = x
18:00:56 <lambdabot> head []    = undefined
18:00:56 <Heffalump> > error $! error "x"
18:00:58 <lambdabot>   *Exception: x
18:01:09 <Heffalump> so it seems like error is behaving as if it was strict. But it's not.
18:01:13 <Philonous> Someone should write that down. It's a great story to scare kids away from unsafePerformIO
18:01:21 <robryk> what is?
18:01:21 <karlalfred> is there any method to get wx-haskell to work on windows or is it not supported?
18:01:52 <ezyang> > error (error "x") 
18:01:53 <lambdabot>   *Exception: x
18:03:02 <EvanR> :t error "x"
18:03:03 <lambdabot> forall a. a
18:03:23 <EvanR> and in this case a is String ;)
18:03:57 <EvanR> Heffalump: error is not strict?
18:04:08 <robryk> @src error
18:04:09 <lambdabot> error s = throw (ErrorCall s)
18:04:17 <Igloo> Heffalump: error is strict: error x is _|_ if x is _|_
18:04:31 <EvanR> robryk: src isnt exactly whats being run...
18:04:38 <robryk> why?
18:04:45 <EvanR> @src undefined
18:04:45 <lambdabot> undefined =  error "Prelude.undefined"
18:04:54 <EvanR> robryk: its a possible implementation
18:05:07 <robryk> it's special cased somewhere?
18:05:19 <robryk> or does lambdabot run something a lil' bit different?
18:05:20 <EvanR> each @src command result is a line in some giant text file ;)
18:05:27 <robryk> yes
18:05:28 <EvanR> not in ghc
18:05:48 <robryk> isn't it the text file which got compiled into Prelude, in this case?
18:05:53 <EvanR> no
18:06:16 <robryk> why? readability?
18:06:24 <robryk> or bot's quirkyness?
18:06:37 <EvanR> too much work to replace all the normal code in the haskell implementation with worse versions?
18:07:08 <sm> hey all
18:07:14 <robryk> i mean, why these versions are displayed
18:07:21 <EvanR> robryk: the above would make sense, just consider throw to be an error-like 'function'
18:07:27 <EvanR> for readability
18:07:29 <sm> is it possible to evaluate quasi-quoter expressions in ghci ?
18:07:29 <fryguybob> Heffalump: Is this related: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28500 ?
18:07:34 <robryk> oh, ok
18:10:17 <sm> yes! http://www.haskell.org/haskellwiki/Quasiquotation shows how
18:10:56 <sm> that'll be handy for understanding hamlet
18:11:17 <EvanR> shakespear use quasiquotation?
18:14:03 <mjrosenb> is replaceFileName supposed to be able to replace a file name with a relative path>
18:14:06 <mjrosenb> ?
18:16:17 * syntaxglitch tinkers with some simple game programming in Haskell
18:16:59 * EvanR mentions #haskell-game to syntaxglitch 
18:17:23 <EvanR> @hoogle foldl'
18:17:25 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
18:17:25 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
18:17:25 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
18:17:36 <fryguybob> mjrosenb: It does for me.
18:19:55 <mjrosenb> fryguybob: i tested it and saw that it worked in one case; is it supposed to work in general?
18:23:21 <fryguybob> mjrosenb: Looking at the source I would say yes.
18:23:39 <mjrosenb> fryguybob: awesome!
18:24:02 <mjrosenb> grrr
18:24:19 <mjrosenb> the System.* naming conventions could be better
18:24:28 <mjrosenb> :t normalise
18:24:29 <lambdabot> Not in scope: `normalise'
18:24:39 <mjrosenb> :t System.FilePath.normalise
18:24:41 <lambdabot> FilePath -> FilePath
18:25:03 <mjrosenb> :t System.Directory.canonicalizePath
18:25:04 <lambdabot> FilePath -> IO FilePath
18:25:58 <mjrosenb> we should choose one language and stick to it :-p
18:31:38 <jrockway> haha
18:31:47 <jrockway> i remember the 200+ message flamewar about the same issue on emacs-devel
18:31:56 <jrockway> the decision was made to ... well, there was no decision
18:32:03 <jrockway> but at least there were 200 emails
18:40:39 <Phyx-> @karma nominolo++
18:40:40 <lambdabot> nominolo++ has a karma of 0
18:40:47 <Phyx-> @karma +  nominolo
18:40:47 <lambdabot> + has a karma of 172
18:40:51 <Phyx-> lol
18:40:55 <Phyx-> @karma+  nominolo
18:40:55 <lambdabot> nominolo's karma raised to 0.
18:41:02 <Phyx-> he had negative?
18:42:43 <aristid> @karma+ +
18:42:43 <lambdabot> +'s karma raised to 173.
18:47:57 <c_wraith> aristid, are you the commenter of the same name on language log?
18:48:05 <aristid> c_wraith: no
18:48:23 <EvanR> @karma php
18:48:23 <lambdabot> php has a karma of 0
18:48:26 <EvanR> @karma- php
18:48:26 <lambdabot> php's karma lowered to -1.
18:48:36 <Martty> @karma haskell
18:48:36 <lambdabot> haskell has a karma of 60
18:48:41 <EvanR> @karma+ haskell
18:48:41 <Martty> @karma c++
18:48:41 <lambdabot> haskell's karma raised to 61.
18:48:41 <lambdabot> c++ has a karma of 0
18:48:42 <aristid> c_wraith: at least i don't remember commenting on language log
18:49:36 <EvanR> @karma ocaml
18:49:36 <lambdabot> ocaml has a karma of 0
18:49:49 <jrockway> @karma c
18:49:49 <lambdabot> c has a karma of 2
18:50:02 <EvanR> @karma+ c
18:50:02 <lambdabot> c's karma raised to 3.
18:54:19 <yescalona> karma???
18:55:03 <yescalona> whats mean that of karma???
18:55:08 <yescalona> @karma python
18:55:08 <lambdabot> python has a karma of 0
18:55:17 <yescalona> @karma lisp
18:55:17 <lambdabot> lisp has a karma of -1
18:55:27 <yescalona> @karma c
18:55:27 <lambdabot> c has a karma of 2
18:55:31 <yescalona> @karma gtk
18:55:32 <lambdabot> gtk has a karma of -2
18:55:35 <yescalona> @karma qt
18:55:35 <lambdabot> qt has a karma of 0
18:55:46 <EvanR> where did c's karma go
18:56:04 <yescalona> @karma
18:56:04 <lambdabot> You have a karma of 0
18:56:07 <yescalona> !karma
18:56:10 <keseldude> lambdabot, I have a feeling we're not in #haskell anymore
18:58:52 <jrockway> so, am i missing something?
18:59:15 <theorbtwo> Wow, only 2 for C?  It's normally much higher then that, since there's a language called c++ (of course, there's also a language called c--, IIRC, but it's not nearly as popular.)
18:59:21 <jrockway> why is data.bytestring.lazy's concat O(n) over the strings to concat, but data.bytestring.lazy's append is O(n) over the characters?
18:59:25 <jrockway> theorbtwo: karma works differently here
18:59:37 <dolio> C is special cased.
18:59:51 <dolio> Typing C++ and C-- does not affect C's karma.
18:59:52 <danharaj_> It seems like every couple of days the karma thing comes up
18:59:53 <jrockway> over on #perl, its karma is OVER NINE THOUSAND
19:00:05 <jrockway> mostly from people saying, "man, C++ sucks"
19:00:08 <Zeiris> Are there any "specialized" wrappers of IO, for database access or network communication or whatever? I seem to remember them always using straight IO.
19:00:14 <ezyang> I'm using a full module name in quotes in Haddock, but it doesn't seem to be generating the hyperlink. Anyone know why? 
19:00:38 <jrockway> Zeiris: it's been done
19:00:40 <EvanR> @karma
19:00:40 <lambdabot> You have a karma of 0
19:00:57 <Zeiris> Is it on haddock/standard libs?
19:01:10 <jrockway> depends
19:01:13 <ezyang> No; it's inside my package. 
19:01:29 <jrockway> oh, different question now :)
19:06:31 <kyagrd> Today I've leanred a lesson that LANGUAGE CPP is jolly useful when using Template Haskell.
19:08:19 <Zeiris> I've had the revelation that "NetIO" (sockets) and "StdIO" (stdout/in/err) would be trivial to write, but provide massive longterm benefits in code readability/safety. Am I getting overexcited about this?
19:09:10 <Zeiris> Is there a reason why people mostly use IO directly, rather than specializing it?
19:09:13 <EvanR> networked IO is usually done with many concurrent sockets
19:09:23 <EvanR> socket threads
19:09:26 <tkahn6_> oh hey jrockway
19:09:55 <Saizan> Zeiris: one reason might be that one might fear it'd get clumsy to combine those
19:09:55 <Zeiris> EvanR, which packages ought I look at?
19:10:02 <EvanR> Control.Concurrent
19:10:12 <EvanR> Control.Concurrent.MVar
19:10:18 <Saizan> that's still in plain IO
19:10:50 <Saizan> Zeiris: but, e.g. ST would be MutVarIO
19:11:06 <EvanR> seems like something that does *actual IO* like stdio and sockets should... be IO
19:11:24 <Saizan> except that you get to project it out into pure code
19:11:25 <syntaxglitch> I suspect that "special-purposes subsets of IO" is one of those things that everyone figures would be a good idea, but would be a lot of boring work to do properly
19:11:35 <EvanR> and we would separate non IO stuff like ST and things to other packages, which they did
19:11:43 <Zeiris> Combining two or three such effects at the same time could be weird, yeah. Is there a way to scale MonadLib's (StateM Int m, ReaderM Int m) => m a thing to an arbitrary number of monads?
19:11:55 <Saizan> EvanR: the idea here is to have finer grained subsets of IO
19:12:09 <Saizan> EvanR: even if in the end you'd need to map them back to IO
19:12:27 <EvanR> bondage and discipline eh
19:12:32 <BMeph> EvanR: Rule 15 of Haskell: "IO /= I/O" ;)
19:12:37 <Zeiris> Yeah. It'd be nice knowing whether some code only interacts with sockets, or only with stdout, and never anything else.
19:12:47 <syntaxglitch> the tricky part is defining a sub-IO that's broad enough to be useful, but specialized enough that there's no way to fire the missiles
19:13:16 <syntaxglitch> if you just want to take like three IO functions and wrap those and only those in a special-purpose monad that's simple, but not extensible
19:13:23 <EvanR> this seems useful when dealing with other peoples IO code
19:13:25 <BMeph> EvanR: Although, I/O in done in IO... it's "tricksy" like that. :)
19:13:28 <Zeiris> Firing missiles is fine, as long as you know they're being fired through sockets rather than your file system. That's still an improvement :)
19:14:01 <EvanR> but when writing my own code if i dont plan on firing missiles, then... i dont fire missiles and i dont spend time stopping myself from doing it. much like the pointlessness of c++ private
19:14:13 <Saizan> in "Data Types a la Carte" they use this idea as one of the examples
19:14:44 <EvanR> Zeiris: you know, socket file handles are supposed to be similar in interface to file handles, or to zip file handles, or whatever else, why do we want to break this apart?
19:15:14 <BMeph> Saizan: The "Teletype" type, right?
19:15:15 <Zeiris> Can you use 'em interchangeably?
19:15:38 <EvanR> given the right interface, which is open close read write
19:15:45 <EvanR> all of which can fail in various ways
19:15:48 <BMeph> Can you Catch 'em All? ;)
19:15:54 <Saizan> BMeph: i don't remeber the details :)
19:15:57 <EvanR> ._.'
19:16:11 <EvanR> Pokemon!
19:16:13 <ddarius> BMeph: No.
19:16:32 <Saizan> Zeiris: darcs has a RIO for dealing with repositories i hear
19:16:50 <Saizan> Zeiris: but it's a MonadIO so it's pretty weak..
19:16:58 * syntaxglitch can also see value in a sub-IO for, say, working with processes and threads
19:17:13 <Zeiris> EvanrR, Handle seems to be a separate type, so having sub-IOs shouldn't affect it.
19:17:21 * Phyx- has to figure out a way to code and exercise at the same time
19:17:41 <Saizan> it seems like it'd be more insteresting to deny access to particular resources, rather than restricting whole classes of interactions
19:17:43 <EvanR> Zeiris: k but you are going to stop people from writing to file handles but not to socket handles?
19:17:48 <Zeiris> Phyx-, 5 pushups per syntax error, 5 pushups 10 situps per error, run around the block for runtime bug.
19:17:51 <Zeiris> Adjust as needed.
19:17:54 <syntaxglitch> Phyx-, get an exercise bicycle, replace wheel with a generator, plug computer into generator
19:17:59 <syntaxglitch> Then pedal quickly
19:18:11 * ddarius recommends a laptop in that case.
19:18:24 <tkahn6_> Phyx: http://www.wired.com/images_blogs/geekdad/images/2008/06/23/connectadesk.jpg
19:18:28 <Phyx-> Zeiris: lol, i'll be running around the blocks for weeks
19:18:31 <Zeiris> EvanR, good point. How often do you get into situations where you want to write to file/socket handles interchangeably though?
19:18:36 <EvanR> i wonder how different coding zen is from coding torture
19:18:39 <Phyx-> syntaxglitch: i'm on one of those bikes now actually
19:18:41 <Phyx-> but typing is hard
19:18:48 <mjrosenb> <3 polymorphis
19:19:00 <mjrosenb> i just replaced 3 instances of find with filter
19:19:01 <Phyx-> tkahn6_: lol!
19:19:09 <mjrosenb> and my whole program continued to typecheck
19:19:19 <EvanR> Zeiris: write commands to read data certain way regardless of source
19:19:25 <tkahn6_> Phyx-: you'll look awesome running around the track with that
19:19:34 <EvanR> a good example is ... hGetLine
19:19:42 <Phyx-> mjrosenb: I replaced 300 lines today with "    findName grp a b = findName (listifyBut (isName a b) grp) a b"
19:19:52 <Zeiris> I'm not convinced of the usefulness of hGetLine in actual code.
19:19:58 <EvanR> ?
19:20:02 <Phyx-> tkahn6_: aslong as I have Inet i don't mind :)
19:20:09 <tkahn6_> hahaha
19:20:46 <Zeiris> The only thing similar I've seen is the ANSI stuff, which allows you to send codes over sockets... I guess. But that's a bit of a mess due to windows incompatibility.
19:20:53 <EvanR> so you dont like my example doesnt invalidate the entire point of polymorphic code
19:20:54 <aavogt> Phyx-: no base case?
19:20:58 <Phyx-> then I could write a little app, everytime you guys see me slow down, you can press a button and it shocks me
19:21:07 <tkahn6_> lol
19:21:08 <Zeiris> I mean, you're on windows and have a handle. Do you handle it as an stdout, a file, or a socket?
19:21:11 <Phyx-> well.. maybe that's not a good idea.. you guys will shock me just for fun....
19:21:24 <EvanR> Zeiris: on unix its called a file descriptor
19:21:33 <Phyx-> aavogt: how so?
19:21:37 <Zeiris> Yeah, there it's clean and beautiful.
19:21:41 <EvanR> why?
19:22:16 <EvanR> its an integer which might be linked to a fs file, a socket...
19:22:32 <EvanR> stdio 
19:22:35 <yescalona> @karma perl
19:22:35 <lambdabot> perl has a karma of 2
19:22:41 <Saizan> EvanR: having subsets of IO wouldn't necessarily prevent you to also have polymorphic code, which could specialize to a different monad type depending on the type of "Handle" you apply it to
19:22:43 <aavogt> @type listifyBut
19:22:43 <lambdabot> Not in scope: `listifyBut'
19:22:47 <aavogt> @type listify
19:22:48 <lambdabot> forall r a. (Data a, Typeable r) => (r -> Bool) -> a -> [r]
19:22:56 <Phyx-> aavogt: oh you meant that
19:23:01 <Phyx-> no it doesn't need any
19:23:08 <EvanR> Saizan: handles have types?
19:23:26 <Phyx-> aavogt: listifyBut is my own little contraption, so I can specify where it should not traverse
19:23:26 <Saizan> EvanR: you could have Handle parameterized by Remote or Local and have hGetLine :: Handle t -> SubIO t String
19:23:29 <aavogt> I didn't think that listify was polymorphic like that
19:23:35 <Zeiris> I haven't written much code that would work interchangeably with files, sockets, and stdfoo. It's always been focused on one of them, so I'm wondering whether the Unix fds are merely beautiful from an OS point of view, but not useful here.
19:23:47 <Phyx-> aavogt: it's SYB, so fully generic
19:24:02 <tkahn6_> Has anyone read _The Haskell Road_?
19:24:11 <p_l> Zeiris: file descriptors would be more beautiful except for the aberration known as BSD sockets
19:24:13 <EvanR> Zeiris: a read/write stream is a good interface
19:24:28 <aavogt> tkahn6_: what about that book?
19:24:28 <Saizan> EvanR: there's usually quite a bit of room to make types more precise, once one starts to care
19:24:31 <Phyx-> aavogt: same principle I use in "isPost a = isJust (cast a :: Maybe PostTcType)"
19:24:41 <tkahn6_> aavogt: Is it good?
19:24:41 <Zeiris> Personally, given the chance to know whether some code merely reads/writes to the window, at the price of having to modify that code if I also wanted it dumped to disk... I'd pay that price happily.
19:25:10 <EvanR> :\
19:25:12 <aavogt> tkahn6_: if that's what you want to learn
19:25:29 <tkahn6_> k
19:25:31 <p_l> Zeiris: in Plan9, you could say that a fd is a reference to an object of type "IO Stream".
19:27:02 <Zeiris> Perhaps stdout/files/sockets are a poor example for sub-IO :) How about database-access IO, threading-IO, and socket-IO.
19:27:12 <Zeiris> Three totally separate interfaces.
19:27:32 <EvanR> if all you can do is forkIO, threadDelay, and killThread, its pretty boring
19:28:41 <EvanR> and like forkIO, socketIO is basically limitted to reading and writing a handle
19:28:52 <EvanR> once the server and connections are established
19:28:56 <Saizan> it'd be nice to be able to write code that's guaranteed to only deal with threading and communication between threads, but can also embed other IO-actions given from the outside
19:28:59 <Zeiris> Well, that and channels/mvars/other stuff. 
19:29:13 <Saizan> i.e. like a thread pool implementation would do
19:29:48 <Zeiris> Knowing some code doesn't write to stdout could be nice for determining where to write logs.
19:29:54 <EvanR> can you only communicate with threads in a similarly restricted environment
19:29:56 <Saizan> though that's far from a strong motivating example
19:30:10 <EvanR> or not in
19:30:49 <ezyang> Can I turn off the synopsis on a per-module basis in Haddock? 
19:30:53 <Zeiris> Why restrict IO in the first place? I always have an easier time in C, where I can printf anytime :)
19:31:02 <EvanR> logging is sort of boring task
19:31:08 <micahjohnston> there's Debug.Trace
19:31:09 <EvanR> if most of your code is pure theres no much to log
19:31:16 <micahjohnston> and ghci
19:31:18 <Zeiris> It just seems like there's a gap between most monads (which are extremely specific) and IO (which is extremely general).
19:31:28 <EvanR> theres that
19:31:38 <Zeiris> So while I can accurately control side effects like Writer/State, accurately controlling IO doesn't happen.
19:31:49 <EvanR> i accurately control IO
19:32:14 <EvanR> as little as i can, so i can get into pure code ;)
19:32:27 <Saizan> this is not about self-discipline, it's about what the compiler can prove about your code.
19:32:27 <Zeiris> You can't tell which of a billion things it might be doing though. Your program might only access a database and some sockets - but you can't tell that from the types, even though you totally could :)
19:32:55 <EvanR> yes this would be good for libraries
19:32:55 <micahjohnston> the idea is that you can accurately control the rest of your code though
19:33:15 <EvanR> but its kind of hard to use a database when you didnt mean to
19:33:17 <micahjohnston> and since directly interfacing with other code, the OS, etc. can't be reasoned about in the same way, you confine it
19:33:36 <EvanR> or use opengl when you didnt want to
19:33:37 <Saizan> Zeiris: you should probably start with this style in some program you care about and report your experience :)
19:33:38 <BMeph> How come the ACIO thing didn't take off more?
19:33:51 <Zeiris> Libraries and complex code in general. Once you have enough code, type signatures provide amazing guarantees.
19:34:04 <aavogt> Phyx-: actually it still doesn't make sense to me why you can get output from "findName" with that being the only equation
19:34:09 <EvanR> learn to fear IO ;)
19:34:38 <Zeiris> Saizan, that's exactly what I'm thinking. However, my current Haskell project is mostly closed source :( I'd totally love to try this on something visible and that would benefit, though.
19:35:31 <Saizan> (so much commercial haskell :O)
19:35:57 <EvanR> giant code bases are a hallmark of commercial software, i would bet a lot of it is more complex than it needs to be, just like in java or c++
19:36:05 <EvanR> even though its haskell
19:36:06 <napping> conal: I just realized you are missing the most basic (and actually sensible) explanation for referring to arbitrary non-function values as "nullary functions"
19:36:07 <kyagrd> Zeiris: trying to find missing instances and defining them could be a good contribution with minimal effort.
19:36:10 <Zeiris> Choice between writing commercial Haskell, looking for a 9-5 fast food job, or writing commercial C :p
19:36:30 <Zeiris> kyagrd, missing instances of what?
19:36:43 <aristid> so, reykjavik is in the region of Höfuðborgarsvæðið
19:36:44 <kyagrd> Any useful class
19:36:46 <napping> Zeiris: I fear the type signatures would be too complicated
19:37:19 <kyagrd> Zeiris: for example, template-haskell Lift class is not defined for Double, Array, and Rational
19:37:45 <Saizan> kyagrd: i think you miss the context of the above discussion :)
19:37:57 <Zeiris> napping, if stuff that's currently IO was instead wrapped in a SubIO, the only change that'd be needed is occasionally runSubIO-ing when you enter full on IO.
19:37:58 <aristid> oh, wrong channel
19:37:58 <kyagrd> Saizan: yeah I just jumped in
19:38:04 <Phyx-> has anyone ever done a benchmark of FFI in ghc?
19:38:27 <Zeiris> Naturally, this would quickly result in IO-transformers. I'm still not 100% certain how some of that stuff works, however :p
19:38:33 <napping> kyagrd: use th-lift
19:38:53 <napping> Zeiris: what if you need to use console output and sockets?
19:39:06 <Zeiris> For instance, I love monadLib's lift-less ReadM WriteM StateM etc instances, but I suspect the amount of code for them is O(n^2) for the number of monads supported.
19:39:06 <napping> if it's done at a fine grain you'll end up with huge sets of effects
19:39:16 <Phyx-> @google FFI benchmarks GHC
19:39:19 <lambdabot> http://donsbot.wordpress.com/2010/02/21/smoking-fast-haskell-code-using-ghcs-new-llvm-codegen/
19:39:19 <lambdabot> Title: Smoking fast Haskell code using GHC’s new LLVM codegen « Control.Monad.Writer
19:39:27 <Phyx-> nope
19:39:27 <Zeiris> Well, you'd do the same thing as if you needa Reader and State.
19:39:31 <Phyx-> next one please lambdabot 
19:40:08 <kyagrd> Oh, you guys were talking about IO and concurruncy :)
19:40:11 <Phyx-> I guess no one ever has... odd
19:40:29 <jrockway> where do you think the overhead would be?
19:40:30 <EvanR> rather than moving real IO into its own place, move non IO stuff into *its* own place
19:40:31 <Zeiris> I guess the question is whether monad transformers are usable enough to be used regularly in actual code.
19:40:44 <Zeiris> Or if they're something scary to be used to define a monad once, and then forget you had to do it.
19:40:45 <napping> Zeiris: some sort of IDE support might help here
19:40:47 <kyagrd> napping: yes I am and because th-lift had a bug I uploaded a backport few hours ago
19:41:03 <EvanR> transformers increase the complexity of the type signatures
19:41:21 <EvanR> and of code that needs to lift into other transformers
19:41:31 <napping> if you could mostly just see "IO", but request an expansion if you care about the details
19:41:38 <jrockway> mtl's solution is not too bad
19:42:05 <jrockway> newtype Foo = FooT BarT BazT IO a deriving (Monad, MonadIO, ...
19:42:28 <Zeiris> I haven't used transformers enough to be entirely comfortable, but (SqlIO m, StdIO m, SocketIO m) => m Int looks very manageable signature-wise.
19:42:30 <EvanR> Zeiris: defining ones own monad for ones own application is sometimes suggested... not sure how often that actually happens
19:43:00 <jrockway> i have done that without being told to
19:43:01 <Zeiris> EvanR, how often are applications written that are complex enough to need them?
19:43:20 <EvanR> i dont know, i rather design simple programs
19:43:26 <jrockway> generally, you are going to have a bunch of app-specific "things" to do, and making your own monad stack can facilitate that
19:43:40 <aavogt> you don't need -XGeneralizedNewtypeDeriving with mtl (or any other monad library)
19:43:46 <Zeiris> Bah, simple programs can't do anything awesome.
19:43:56 <EvanR> that is a very business attitude
19:44:33 <EvanR> the more complex the more it looks like the programmers are being paid for something
19:44:35 <Zeiris> Well, I should elaborate. You can write a fun simple program, but you can't proceed to use it for months afterwards. You'll want more functionality, extra features, etcetera.
19:44:40 <micahjohnston> I think the awesomest programs are the simplest
19:44:48 <jrockway> i kind of disagree with zeiris
19:44:56 <jrockway> if your program is complicated, you haven't found the right abstraction yet
19:44:57 <micahjohnston> ones that have a very simple base and can be extended while still being simple
19:45:18 <EvanR> our haskell program was too complex to use for months afterward, to add features, so we simplified it. then it was good
19:45:46 <EvanR> deleting code is nice ;)
19:45:54 <Zeiris> Not complicated in the sense of code, but in the sense of features. This includes free, unpaid code: I wrote a Haskell shortest-route finder for an online game, but for it to be useful to my friends it needs additional heuristics, more options, etc...
19:45:57 <roconnor> EvanR: who is our?
19:46:09 <EvanR> i work at a market research place
19:46:19 <roconnor> cool
19:46:30 <roconnor> how did you land a Haskell job?
19:46:36 <jrockway> my $work haskell application is also too complicated
19:46:40 <Zeiris> I think the distinction isn't between "business" and "not", but between "stuff that gets used by people" and "doesn't".
19:46:44 <jrockway> it's all because i picked the wrong abstraction
19:46:54 <jrockway> "oh, i'll have 99 mini-programs that all do something slightly different"
19:47:23 <EvanR> roconnor: its a php job, and for certain mission critical components i basically said that it cant be done in php
19:47:29 <jrockway> after fixing it to share some higher-level abstraction, all 99 programs look the same
19:47:52 <EvanR> roconnor: needless to say, those components took about 1% of the work time of the total system... 
19:47:56 <Saizan> Zeiris: the problem domain also matters a lot
19:48:10 <roconnor> interesting
19:49:06 <EvanR> hopefully when i leave, and if that haskell code needs work, they wont freak out and try to find a replacement
19:49:29 <Zeiris> Yeah, motivation in general tends to decide features. Most of my low-feature, simple programs tended to be simple because I got bored and moved on before I got around to implementing [x,y,...]
19:49:55 <Zeiris> EvanR, a replacement to port it to <insert language>, I bet :\
19:50:05 <EvanR> the unix philosophy is to make simple special purpose pieces that link together however you want
19:50:18 <EvanR> not giant feature packed monoliths
19:50:29 <Zeiris> Yeah, but what if you want a giant pile of features? :)
19:50:42 <napping> then make somehing parameterized
19:50:47 <Zeiris> Lemme see if I can find my specs on the route planner...
19:50:56 <Phyx-> you pack togther alll those little pieces into something highly inefficient ^_^
19:51:03 * Saizan wonders how many lines of code grep is
19:51:36 <aristid> EvanR: now you need to make this into rhetoric why FRP is the modern equivalent of unix pipes
19:51:55 <aristid> Saizan: 23121 *wild guess*
19:52:12 <EvanR> ftp://mirrors.kernel.org/gnu/grep/
19:53:03 <Saizan> if i wanted to fetch the sources i could've found them, but thanks anyway :)
19:53:13 <EvanR> .c files total 7858 
19:53:29 <micahjohnston> .
19:53:31 <micahjohnston> ._.
19:53:33 * jrockway wonders how many lines of those lines it takes for the grep binary to decide whether it's egrep, fgrep, or regular grep
19:53:39 <jrockway> s/lines//
19:53:48 <EvanR> yeah
19:53:52 <aristid> jrockway: 47 *wild guess*
19:53:55 <napping> I'd hope not too many
19:53:55 <EvanR> modern stuff tends to have more features
19:53:58 <EvanR> so its bigger
19:54:02 <napping> switch (argv[0][0])?
19:54:23 <EvanR> heh... egrep.c, fgrep.c ...
19:54:25 <aristid> napping: well in C you can find a way to do everything with lots of lines
19:54:38 <Zeiris> Ehh, the specs are a bit obscure to people who haven't played the game. But my goal is a command-line utility which, through some smart heuristics and option choices, provides the same quality answer as a human with 10 minutes with a map would. So the problem definition requires complexity: parsing commands that are as intuitive as possible, optimizing for many different options, etc. Writing the core of that was when I ran into my first 
19:54:38 <Zeiris> "I need a monad or a gun" scenario.
19:54:59 <aristid> they even have a trick to make string concatenation need multiple lines of code
19:55:03 <Zeiris> So complexity is definitely not a function of business...
19:55:11 <jrockway> well, it is C
19:55:15 <jrockway> and C doesn't even have a string type
19:55:33 <micahjohnston> char* is a string type ;)
19:55:34 <EvanR> Zeiris: clearly the front end is complex, great place to start hacking away at the complexity
19:55:44 <napping> but that sort of complexity isn't at odds with the sort of simplicity we are talking about
19:55:45 <EvanR> decide what is optional complexity and what is accidental
19:55:59 <Phyx-> > let f = id :: forall a. a -> a in (f 1, f '4')
19:56:00 <lambdabot>   (1,'4')
19:56:15 <napping> sounds like parsing can be decoupled almost completely from the rest, even if you are going for some fancy natural language thing
19:56:22 <aristid> :t ($) :: forall a. a -> a
19:56:23 <lambdabot>     Couldn't match expected type `a1' against inferred type `a -> b'
19:56:23 <lambdabot>       `a1' is a rigid type variable bound by
19:56:23 <lambdabot>            an expression type signature at <interactive>:1:14
19:56:30 <aristid> :t id :: forall a. a -> a
19:56:31 <lambdabot> forall a. a -> a
19:56:31 <Zeiris> Yeah, the problem is in the goals of the user interface. The core shortest-path solver is, of course, simple and beautiful :)
19:56:34 <Saizan> i still don't see why you need an huge bloated program to start worrying about what IO code is actually doing
19:56:44 <Saizan> especially when you're using libraries.
19:56:49 <Zeiris> Well, as simple as something working with other people's real-world data is, heh.
19:57:04 <Phyx-> :t ($) :: forall a b. a -> b
19:57:06 <lambdabot>     Couldn't match expected type `a1' against inferred type `a -> b'
19:57:06 <lambdabot>       `a1' is a rigid type variable bound by
19:57:06 <lambdabot>            an expression type signature at <interactive>:1:14
19:57:20 <napping> Saizan: you don't, but you probably need a big program before defining a bunch of teeny monads yourself and moving operations into them starts to seem worthwhile
19:57:26 <Zeiris> Saizan, are you asking why the world needs large prorgams?
19:57:26 <Saizan> though, sometimes "not knowing" helps with abstraction, assuming what you don't know is not actually observable
19:57:36 <napping> especially if you need to manually define stacks or sets or whatever
19:57:37 <Zeiris> You don't need bloat for the question "what does this function do, exactly" to be a problem!
19:57:45 <Saizan> Zeiris: i'm asking what large programs have to do with the SubIO idea
19:58:02 <Phyx-> > let f = id :: forall a. a -> a in (fix f 5, fix f 'a')
19:58:06 <lambdabot>   mueval-core: Time limit exceeded
19:58:19 <Phyx-> > let f = id :: forall a. a -> a in (fix (const f) 5, fix (const f) 'a')
19:58:21 <lambdabot>   (5,'a')
19:58:21 <Zeiris> Well, small programs can get away with one IO function and the rest is all pure.
19:58:30 <Saizan> napping: i agree about "yourself", but we can make libs and share the effort
19:58:53 <Zeiris> Large programs are the ones mixing up sockets/databases/stdout/files, with multiple layers of IO, before it gets to purity.
19:58:57 <Saizan> Zeiris: depens, what if i'm writing a small webserver?:)
19:59:00 <Phyx-> @quote Winzows
19:59:01 <lambdabot> No quotes match. Where did you learn to type?
19:59:12 <EvanR> Zeiris: as long as the interface is well defined, no reason large programs cant avoid increasing their IO footprint
19:59:14 <Phyx-> @google winzows
19:59:15 <lambdabot> No Result Found.
19:59:16 <Saizan> it's still a very small program, it just deals with IO all the time.
19:59:16 <napping> Saizan: well, there's still some friction in the lifting and stuff, unless you go Oleg and make something like effect sets
20:00:07 <Zeiris> Even a web server would mostly be pure though. Hm. I guess the question is, how much IO do programs need?
20:00:23 <EvanR> web server doesnt do much at all besides IO
20:00:36 <Saizan> well, parsing would be pure
20:00:36 <napping> and of course higher order functions get tricky, you'll need subset constraints or something
20:00:55 <Zeiris> Yeah, but everything between receive request, open file, and send file would be pure.
20:01:05 <Saizan> napping: true, the type system doesn't seem to collaborate much here
20:01:40 <Saizan> Zeiris: there'd be concurrency to manage
20:01:42 <EvanR> parsing yes
20:02:11 <Zeiris> If anything, I'd say that the existance of IO hinders understanding of the language. It's so general, that the idea of monads as signature-based trackers of side effects takes a while to come around to.
20:02:34 <EvanR> im tempted to bring up the issue of side effects vs front effects again ;)
20:02:41 <Zeiris> If someone showed me five types of subIO on the first day I looked at monads... Well, it'd still take me ages to figure out what was up. But I'd be a HELL of a lot more motivated :)
20:03:03 <napping> Zeiris: I think an effect system is more suitable than some ugly transformer stack thing
20:03:09 <Cale> Also, if you're using the word "side effects" or "effects" in that way, I think you end up meaning something more than most people usually think of.
20:03:24 <Cale> For example, you'll have to include nondeterminism as an "effect".
20:03:30 <Zeiris> It's quite likely that I'm misusing terms. What's an effects system, napping?
20:03:37 <napping> monad transformers are a little funny, and I think the classes that do compose nicely are probably instances of something simples
20:03:55 <napping> Zeiris: A type system which records what effects applying a function can have
20:04:13 <Cale> The effect system used in Disciple doesn't really capture everything that various monads do.
20:04:15 <napping> you might see something like f :: Int --{reads x, writes y}--> Char
20:04:34 <Zeiris> napping, is that doable with Haskell?
20:04:38 <napping> um
20:04:39 <Cale> Basically just state effects, which, while it might be helpful, is a bit boring.
20:04:52 <napping> um
20:05:04 <Saizan> you can't define your own?
20:05:07 <EvanR> thats why RealWorld data doesnt make much sense as a model for IO
20:05:23 <napping> well, how many Olegs of type class hackery do you have to burn?
20:05:35 <Cale> Saizan: I'm pretty sure you can't do anything like the list monad, anyway.
20:05:51 <Zeiris> "f :: Int -> ReaderT X (Writer Y Char)" seems like a pretty decent way to describe effects.
20:06:06 <Saizan> Cale: i'd expect them to have something for continuations at least..
20:06:23 <Zeiris> You could do smoething like f :: Int -> SocketIO Char instead, of course.
20:06:31 <EvanR> the only effect there is the result, just like any function
20:06:33 <Zeiris> And then runSocketIO handle
20:06:53 <Cale> I'm pretty sure the effect system is essentially just "state monads anywhere"
20:07:16 <napping> doesn't it track various IO things also?
20:07:41 <napping> I don't know about Disciple in particular
20:07:46 <EvanR> Zeiris: there shouldnt be much to socket io, a bytestring decoder thread or something that writes values to an mvar, the other side of the mvar wont know where or what the data comes from
20:08:07 <napping> but in just about any effect system it's trivial to invent a new token like "network", and label some primitives with that effect
20:08:12 <EvanR> i would avoid using socketIO commands anywhere
20:09:13 <EvanR> Zeiris: you can use type synonyms to say that the command to fork that thread is SocketIO = IO (MVar Char)
20:09:29 <EvanR> adding documentation
20:09:48 <Zeiris> EvanR, so it's common that instead of code working directly with sockets it does so through an MVar layer?
20:10:08 <Cale> Yeah, it also tracks some various IO effects, and you can define new classes of effects.
20:10:09 <Zeiris> That... Is an interesting idea, that hasn't occured to me before :p
20:10:55 <Saizan> i hope noone works with MVar Char for such things :)
20:11:04 <Cale> But as far as I can tell, the newly defined effects are just tags.
20:11:24 <napping> well, isn't that what you ultimately end up with anyway?
20:11:29 <napping> how else to classify an ffi import?
20:12:07 * hackagebot improve 0.0.1 - A simple imperative programming language for embedded applications.  http://hackage.haskell.org/package/improve-0.0.1 (TomHawkins)
20:12:22 <EvanR> Zeiris: yes things are a lot simplier if you do networking with forkIO 
20:12:22 * Zeiris just wants something to hide the ugly feeling he gets, moving from pure code to "IO YouDontKnowWhatIDid".
20:12:41 <kyagrd> src repository of improve is atom :)
20:13:47 <jrockway> clearly the solution is unsafePerformIO
20:13:52 <jrockway> then all your functions can just return ()
20:13:58 <kyagrd> EvanR: if only GHC backend supported more advanced event pollong something other than select
20:14:06 <EvanR> it doesnt?
20:14:22 <kyagrd> EvanR: that's why happstack is as slow as apache
20:14:40 <kyagrd> there is a framework that does use ev
20:14:41 <Zeiris> jrockway, every time I've felt the need to unsafePerformIO so far, I found an alternative soon afterwards. I'm quite happy about that :)
20:14:43 <Saizan> kyagrd: it will in the next release, afaiu
20:15:22 <jrockway> yeah, there is work to use libevent (or libev?)
20:15:27 <jrockway> and you can use one of those manually
20:15:38 <kyagrd> snap
20:15:46 <jrockway> and select isn't *that* bad
20:16:06 <EvanR> unsafePerformIO is there so when people complain about things being too restricted you can say dont worry anything is possible if you really want it ;)
20:16:08 <jrockway> (typically, you don't have 100,000 sockets directly connected to your web server)
20:16:39 <jrockway> unsafePerformIO is just an annotation to tell the compiler that a function it thinks is impure is actually pure
20:16:39 <kyagrd> jrockway: not ideal for services targeded for massive peers
20:16:52 <jrockway> sure, there is long-poll stuff that needs to keep connections open like that
20:17:17 <kyagrd> When I had a real world day job changing select to kqueue in BSD just made the server boost
20:17:21 <luite> http://80.126.200.96:8081/weblog/tryhaskell.mod/  -- I think I have fixed the timeout bugs, can anyone still think of expressions that give strange results or that kill the interpreter? (use the built-in functions 'plot1', 'mandel', 'mandel2' to get a gui and generate more requestst)
20:17:22 <jrockway> (note that i'm not advocating the webserver <-fastcgi-> app process model either, that is VERY inefficient)
20:18:06 <EvanR> that depends on the workload
20:18:19 <EvanR> and how well they are using fastcgi multiplexed connections
20:19:03 <EvanR> and how well the fcgi client is caching stuff...
20:19:10 <jrockway> fastcgi is not the bottleneck, but app servers that only expect to serve one request at a time are
20:19:17 <EvanR> yeah
20:19:23 <jrockway> while you're waiting for results from the database, you can serve the "hello, world" template just fine
20:19:25 <EvanR> thats absurd
20:19:40 <jrockway> yeah, but still how 99% of people do it :(
20:19:53 <EvanR> i have been looking for ways to do just that, but it seems you need a OS thread to multiplex database accesses
20:20:08 <EvanR> libmysql for example has no asychronous methods that i can see
20:20:23 <EvanR> dunno
20:20:38 <jrockway> yeah, that's because mysql sucks
20:20:50 <jrockway> in theory, you can do this though :)
20:21:02 <jrockway> i have not written a database-driven application for a long time (!)
20:21:19 <jrockway> i recently wrote an http proxy that uses libev to nicely handle slow-responding requests
20:21:33 <jrockway> if you get http://slow.com/, that's fine, it doesn't affect other requests
20:21:43 <jrockway> you can even access the proxy via the proxy, and it all works
20:21:46 <jrockway> (one OS thread)
20:22:59 <EvanR> things on the web are so dumb, and they wonder why its so slow
20:23:43 <luite> jrockway: do you have a better suggestion than fastcgi? what would cause it to be inefficient?
20:24:09 <EvanR> the client serves one request at a time
20:24:20 <jrockway> yeah
20:24:21 <EvanR> which it could do many, and do many on one connection
20:24:23 <luite> the website I just mentioned uses fastcgi to call the haskell interpreter, and it seems ok, but I don't know how well it handels many simultaneous users
20:24:35 <jrockway> typically, you can pretend it's not a problem by having a ton of fastcgi servers ready to handle a request
20:24:45 <jrockway> but this is a waste of resources (like RAM)
20:24:48 <EvanR> throw hardware and duplicate computers at the problem
20:24:49 <luite> the apache fcgid docs said that it could spawn more than one server
20:24:57 <jrockway> i personally use HTTP -> HTTP and that works well for me
20:25:02 <jrockway> yes, the HTTP request is parsed twice
20:25:03 <jrockway> oh well
20:26:11 <luite> the amount of ram could be an issue, I need to keep a lot of haskell interpreter processes around
20:26:16 <luite> since starting them is quite slow
20:26:55 <jrockway> ram is typically the issue
20:27:19 <jrockway> when you use events / lightweight threads, one process (and its associated memory use) can handle many simultaneous clients
20:27:41 <luite> since it's a try-haskell clone, but with graphics, sliders / buttons, it could generate more requests, and I want to be able to use multiple "try haskell boxes" on different pages or blog posts, each with different modules loaded
20:29:02 <ashley_s> Hey guys, is there a channel to talk about NP problems?
20:32:29 <jrockway> "don't ask to ask, ask"
20:33:23 <ashley_s> OK, Is algorithm to verify the correctness of a solution to the Traveling Saleman problem P or NP?
20:33:33 <ashley_s> I suspect NP, but I don't want to assume.
20:38:12 <luite> ashley_s: P is a subset of NP :) but since the unrestricted travelling salesman problem is in NP, you can verify a certificate in polynomial time.
20:39:05 <Saizan> yeah, reread the definition of NP :)
20:39:28 <dolio> Solvable in polynomial time on a nondeterministic Turing machine?
20:42:48 <aavogt> > words ("abc "++undefined) `seq` ()
20:42:49 <lambdabot>   ()
20:44:31 <tkahn6_> :type seq
20:44:37 <tkahn6_> > :type seq
20:44:38 <lambdabot>   <no location info>: parse error on input `:'
20:44:45 <aristid> :t seq
20:44:46 <lambdabot> forall a t. a -> t -> t
20:44:49 <tkahn6_> :)
20:45:25 <tkahn6_> @src seq
20:45:25 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:45:33 <tkahn6_> lol
20:46:19 <aavogt> @src const
20:46:19 <lambdabot> const x _ = x
20:46:56 <ashley_s> luite: I'm not familiar with the unrestricted TSP? What does unrestricted imply?
20:47:00 <aavogt> seq is the same (arguments flipped), but the result is undefined if the 'unused' argument is undefined
20:47:39 <luite> ashley_s: nothing really, I just meant that you don't need to restrict the problem in any way, to be able to verify a solution in polynomial time
20:47:55 <Saizan> seq _|_ b = _|_; seq _ b = b :)
20:48:57 <luite> ashley_s: keep in mind that being able to verify a solution in polynomial time on a DTM and being able to say whether there is a solution on a NDTM are equivalent
20:49:44 <ashley_s> luite: That last statement confused me.
20:50:03 <aavogt> is there any harm in using   (evaluate $!) instead of (return $!) ?
20:50:23 <luite> ashley_s: these complexity classes are about decision problems, where you answer a YES/NO question. a typical question for the TSP is, "is there a tour of length at most n"
20:51:22 <ashley_s> luite: so your saying that the TSP that aims to find the shortest path ever, is not apart of NP?
20:52:39 <luite> ashley_s: if you can decide the problem with a NDTM (non-deterministic turing machine) (so you answer the question with yes or no), then you can also take a solution (that should prove 'yes') and verify it in polynomial time on a deterministic turing machine
20:52:46 <luite> and the other way around
20:53:23 <aavogt> as I understand it, using evaluate does an extra seq
20:53:49 <luite> ashley_s: P and NP are for decision problems, finding the best solution is another kind of problem, but the distinction is generally not very important
20:55:15 <Cale> (You just make a record of which branches the NTM took to arrive at the answer it did, and build a similar deterministic turing machine to your nondeterministic one which follows the recorded branches instead of splitting the computation.)
20:56:42 <luite> ashley_s: note that for this problem, you have an easy way to verify a yes-instance (just verify a solution that is shorter than n), but no way to verify if you have a no-instance
21:01:32 <Saizan> (so the "solution certificate" needs basically to be a trace of the machine to allow this?)
21:04:30 <luite> it doesn't need to be anything, but that form makes it easier to see that both definitions are equivalent
21:09:06 <Saizan> i guess it's not a problem if the procedure from which you make the DT out of the NTM needs to run the NTM again and so not be in P :)
21:09:24 <ashley_s> luite: thanks for you answers, It sort of makes sense, I am going to study NDSM until it sinks in
21:10:40 <napping> ashley_s: decision and minimization problems are different here. I don't think there's any quit way to verify a claimed minimal tour
21:11:27 <napping> that is, unless NP = co-NP
21:11:57 <luite> napping: the difference is not that big if you have a NTM at hand :p
21:12:32 <napping> but not if you don't
21:13:52 <Phyx-> @ping
21:13:53 <lambdabot> pong
21:13:58 <Phyx-> @time
21:14:01 <lambdabot> Local time for Phyx- is Sat Aug  7 06:13:23 2010
21:14:31 <luite> that looks like the time here :)
21:15:04 <BMeph> ...but not the time "here"... ;)
21:15:35 <luite> I should probably get some sleep :)
21:18:09 <Phyx-> luite: so should I
21:18:12 <Phyx-> but I'm not sleepy
21:18:42 <Phyx-> so instead, I code
21:21:53 <luite> I was working on my tryhaskell thingy till very late yesterday, I'm adding more gui elements now. I want to duplicate the functionality of some wolfram demonstrations projects, but with haskell of course :)
21:22:32 <BMeph> Mmm...GUI! :)
21:22:53 <luite> I already have sliders and buttons, the most important bits :)
21:25:46 * BMeph is strangely reminded of a variation on an Adam Sandler song: "Buttons and sliders, buttons and sliders, canvas screens, canvas screens, canvas screens, bitmapped browsers -- AJAX flow, A-AJAX flow...
21:29:00 <wioux> sloppy styles, slop-sloppy styles..
21:29:07 <luite> I can't figure out some problem with drawing some vector things though :(  I have a somewhat nice library which looks something like: raphael 500 300 $ rotate 30 $ translate 10 30 $ set [ circle x y 10 | x <- [10,20], y <- [10,20,30]]  on the haskell side, and generates the required javascript code
21:29:25 <luite> but something goes wrong with elements that are both rotated and scaled
21:30:01 <wioux> what seems to go wrong?
21:31:04 <luite> wioux: it scales around the wrong point or something like that
21:32:30 <luite> the javascript side is not really meant for this kind of things, I have things like paper.circle(10,10,10).translate(30,20).scale(0.5).rotate(-20,100,150).scale(0.5);
21:33:13 <luite> it might not be the most efficient way to send this kind of things to the browser
21:33:43 <wioux> you probably want to scale/rotate etc. before translating?
21:35:07 <luite> wioux: I want to do nice functional graphics in haskell, for example if you generate a fractal like the koch snowflake, you can draw the next iteration by copying the result of the previous one a few times, scaling, translating and rotating it
21:35:38 <Phyx-> luite: ah, i'm working on visual haskell, finally figured how to query for information. so i'm implementing QuickInfo now
21:36:54 <luite> is there actually anthing "visual" in visual haskell? :)
21:37:22 <Phyx-> luite: not yet atleast, when I get the basics done I intend to make a GUI editor etc
21:38:09 <wioux> luite: the order in which you perform those transformations matters - if you translate *before* you rotate, it will likely come out wrong
21:38:18 <Phyx-> luite: maybe some method of drawing diagrams based on your haskell programs
21:38:29 <Phyx-> i'm ambitious, but this is alot of work
21:38:54 <luite> wioux: yes I know of course. but I want to be able to do that multiple times, group elements, transform them together etc
21:39:28 <luite> Phyx-: is there some nice functional gui library for which you'd generate code?
21:40:38 <luite> wioux: for example, this is the code that I have for generating one third of the snowflake:
21:40:46 <luite> snowFlake 0 = line 0 0 300 0
21:40:47 <luite> snowFlake n = set [s , translate 200 0 s,
21:40:47 <luite>                    translate 100 0 $ rotate'  60     0 0 s,
21:40:47 <luite>                    translate 100 0 $ rotate' (-60) 100 0 s]
21:40:47 <luite>     where s = scale' 0.3333 0.3333 0 0 $ snowFlake (n-1)                   
21:41:01 <Phyx-> luite: I haven't thought that far yet, but I was thinking gtk2hs. I could use glade.
21:41:24 <Phyx-> and also some native bindings to windows, with support for Aero and Glass etc
21:42:33 <luite> wioux: the idea that each iteration returns a group of graphics items, the group can be translated as a whole
21:43:43 <luite> but that does mean that individual items will get some sequence of transformations, with multiple rotates, scales, translates
21:44:02 <fryguybob> luite: I'm planning on using Diagrams to do something similar to what you have going on.
21:44:30 <fryguybob> http://unpretentiousness.blogspot.com/2010/02/latex-grapher.html
21:44:57 <fryguybob> Diagrams is here: http://code.haskell.org/diagrams/
21:45:08 <luite> yes I've seen it
21:46:23 <luite> the things I have now are low level, basically directly translate to javascript code
21:46:42 <luite> I plan to add some higher level front end, maybe diagrams
21:47:15 <luite> I want to support animations and interactivity, but having to work through the browser makes it difficult
21:47:56 <fryguybob> I made a simple HTML5 canvas backend for the new diagrams code.
21:48:12 <luite> it currently works like this: the user enters some haskell expression in the browser. the webservice evaluates the expression and sends back the result. if the result has some specific type, it is caught by the browser
21:49:12 <wioux> luite: are you using a library for set, line, etc. or have you written your own?
21:49:14 <luite> it currently has special handling for two types: graphics using raphael (bitmap and vector), javascript. and interactive user interfaces (places some sliders, buttons)
21:49:22 <luite> wioux: my own, but it's very simple
21:49:51 <luite> it's a very thin layer that just builds javascript expressions for the raphael library
21:49:57 <wioux> ah
21:50:41 <wioux> whats the constructor for whatever `line` results in?
21:51:31 <luite> wioux: raphael.line(...)
21:51:40 <luite> or paper.line(...) actually
21:51:47 <wioux> i mean in haskell
21:51:52 <luite> oh sorry
21:51:59 <luite> Shape
21:52:13 <luite> line :: Double -> Double -> Double -> Double -> Shape
21:52:27 <luite> attr :: Attribute -> Shape -> Shape
21:52:42 <luite> translate :: Double -> Double -> Shape -> Shape
21:52:46 <luite> very simple
21:53:47 <luite> wioux: you can try it here: http://80.126.200.96:8081/weblog/tryhaskell.mod/
21:54:10 <luite> wioux: I made some test drawings, set10, set11, set12, set9 etc
21:54:17 <luite> but you can make your own
21:54:34 <luite> just enter them in the console
21:54:47 <luite> interactive things are 'mandel', 'mandel2', 'plot1'
21:55:29 <luite> I can paste the code for Graphics.Raphael if you want (which is imported in this box)
21:55:32 <wioux> nice
21:56:21 <wioux> well.. im just trying to work out - is the problem with `snowFlake` in particular, or the general behavior of transformations acting on sets of shapes?
21:57:06 <luite> general problem, but it only happens when scaling, rotating and translating elements multiple times
21:57:25 <luite> 1 moment, I'll add some snowflake to the code
21:58:41 <luite> you saw the snowFlake function from earlier?
21:58:45 <wioux> yeah
21:58:46 <luite> try > snowTest 0
21:58:51 <luite> and > snowTest 1
21:58:52 <luite> etc :)
21:59:16 <wioux> ah i see
21:59:21 <luite> snowTest n = raphael 500 300 $ toDrawing $ translate 30 90 $ snowFlake n
21:59:54 <luite> toDrawing :: Shape -> Drawing   (a shape is something that can be transformed, a drawing is fixed, can only be composed)
22:00:02 <luite> for example if you run > plot1
22:00:12 <luite> then you get a gui for something that generates a Drawing directly
22:06:16 <wioux> are you actually calculating a shape's center in order to scale? (can you link to Graphics.Raphael?)
22:07:10 <luite> wioux: no such calculations are done in haskell (not yet anyway)
22:07:34 <luite> wioux: for the snowflake, I ahve specified each scale and rotation origin manually
22:07:45 <wioux> ah
22:08:29 <wioux> that's the 3rd and 4th argument to scale'?
22:08:45 <luite> raphael scales/rotates around the center of an object if you don't specify the coordinates explicitly, but it doesn't properly calculate bounding boxes for scaled or rotated elements (or for groups of elements)
22:08:49 <luite> the origin
22:09:15 <fryguybob> luite: this doesn't give what I would expect: set [line 0 0 100 0, rotate 90 $ line 0 0 100 0]
22:10:22 <luite> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=28665#a28665
22:11:44 <luite> fryguybob: it rotates around the midpoint of the line, you have to translate the whole set to make the top of the second line visible
22:12:45 <fryguybob> luite: So it is composing based on the center of the bounding box?
22:13:01 <luite> raphael 500 300 $ toDrawing $ translate 0 100 $ set [line 0 0 100 0, rotate 90 $ line 0 0 100 0]  should work
22:13:32 <luite> fryguybob: yes, unless you specify your own coordinates using the rotate' function
22:13:49 <luite> see the source I just hpasted :)
22:14:03 <luite> it's very unfinished
22:14:55 <fryguybob> luite: After something is rotated does that bounding box gets reset?
22:15:37 <luite> fryguybob: it's the raphael javascript library that does those calculations, but unfortunately it does them completly wrong
22:15:53 <fryguybob> luite: Ah, ok
22:16:18 <luite> but in the snowflake example, I don't use them, since all coordinates are specified
22:19:13 <fryguybob> luite: I don't see how they are all specified?  In the function above you have nested sets right?
22:21:26 <wioux> fryguybob: only 5 points need be accounted for. the rest (hopefully) stay consistent while scaling
22:23:52 <luite> fryguybob: scale sx sy cx cy (set xs) = set $ map (scale sx sy cx cy) xs
22:26:13 <wioux> luite: how can i see what this looks like?
22:26:19 <fryguybob> luite: Look at: rotate 0 $ snowF lake 1
22:26:20 <wioux> snowFlake 0 = line 0 0 300 0
22:26:21 <wioux> snowFlake n = set [s , translate 200 0 s,
22:26:21 <wioux>                    translate 100 0 $ rotate'  60     0 0 s,
22:26:21 <wioux>                    translate 150 86.6 $ rotate' (-60) 0 0 s]
22:26:21 <wioux>                where s = scale' 0.3333 0.3333 0 0 $ snowFlake (n-1)
22:26:29 <luite> wioux: run > snowTest n
22:26:58 <wioux> i changed it :P.. have to put the whole thing in a let/in expression?
22:27:07 <luite> oh sorry
22:27:27 <luite> you can just do something like
22:27:31 <luite> mySnowFlake n = .....
22:27:34 <luite> and it will remember
22:27:40 <wioux> ah.. k
22:27:50 <luite> and sometimes it will forget ;)
22:28:11 <luite> if the fastcgi program crashes or you run into some bug
22:28:35 <luite> it builds a let ... in expression for all things that you entered this way
22:28:40 <fryguybob> luite: rotate 0  should do nothing, but it seems to re-center things.
22:30:23 <luite> fryguybob: yes the items that are already rotated go wrong :(
22:30:55 <Phyx-> oooooohhhh
22:30:56 <fryguybob> Just snowFlake 1 looks right.
22:30:58 <Phyx-> no wonder this is crashing
22:31:16 <Phyx-> project rename fail
22:39:25 <luite> anyway, I'm going to sleep now. I'll turn off the server for a while
22:39:35 <fryguybob> luite: It appears that if you have "rotate 0 $ set [a, rotate t $ translate 100 $ b]" it applies the "t" rotation about the set's center, but if you don't have the rotate 0 it applies it about the center of the translated b.
22:40:01 <fryguybob> Hopefully the bug will make more sense tomorrow :D.
22:40:06 <luite> yeah probably
22:40:49 <luite> thanks for looking though :)
22:40:49 <Phyx-> and we have a crash
22:40:52 <Phyx-> *golfclap*
22:41:30 <luite> I hope you like the idea of the in-browser gfx and haskell
22:42:14 <wioux> yeah it's gonna be awesome once its all worked out
22:42:32 <wioux> i hate all the canvas apis
22:42:42 <Phyx-> luite: is it gonna break IE too? :P
22:42:45 * Phyx- runs
22:42:46 <fryguybob> We will wrap them in better apis.
22:42:53 <luite> it's very slow in IE Phyx- 
22:42:55 <luite> but it does work
22:44:08 <luite> probably due to the amount of javascript code, 340k at the moment
22:44:23 * Phyx- curses at his internet
22:44:30 <luite> oh wait, one file is not used anymore, 260k
22:45:07 <Phyx-> gawd my internet sucks... can't browse
22:45:27 <luite> I hope you don't use my server to test, because I just turned it off :p
22:45:50 <Phyx-> luite: http://ie.microsoft.com/testdrive/benchmarks/SunSpider/SunSpiderResultsPPB4.png that'll be fixed soon :P
22:47:19 <path[l]> haha
22:47:45 <luite> it will take another 12 years before a sizable portion of the ie users uses that version...
22:48:15 <Phyx-> the majority of users will get it via windows update
22:48:20 <Phyx-> it's businesses that are the problem
22:48:25 <luite> home users yes
22:49:01 <luite> I do test it in IE8, but I use chrome for development, it's so much faster
22:49:23 <fryguybob> By they time their update is finished they could have been using chrome for an hour...
22:49:56 <Phyx-> fryguybob: your troll doesn't make sense
22:50:21 <luite> Phyx-: microsoft probably rigged the javascript compiler so that it only generates fast code for the sunspider test ;)
22:50:58 <Phyx-> hmm, that's odd "Exception: compiler\basicTypes\SrcLoc.lhs:(307,9)-(328,62): Non-exhaustive patterns in case"
22:51:23 <Phyx-> luite: you just can't admit that they might actually have a fast js engine huh :P
22:52:11 <fryguybob> Phyx-: they are getting speed by heating up the GPU.  That's not progress, it's brute force.
22:53:06 <p_l> fryguybob: like Chrome doesn't?
22:53:40 <fryguybob> To be fair it is javascript that is the real problem.
22:54:04 <p_l> also, the IE team is actually quite good, but constrained by stupid problems caused by people who wrote applications that work *only* with IE6
22:54:14 <Phyx-> "In computer science, brute-force search or exhaustive search, also known as generate and test, is a trivial but very general problem-solving technique that consists of systematically enumerating all possible candidates for the solution and checking whether each candidate satisfies the problem's "
22:54:25 <Phyx-> for the life of me, I can't figure out how brute force speeds things up
22:54:28 <Phyx-> must be me.
22:54:31 <fryguybob> :D
22:55:31 <Phyx-> dmanit, I screwed up, my CodeGen is wrong arrggg
22:56:35 <fryguybob> I'm just saying it isn't a direct comparison to benchmark one thing running just on the CPU vs something running on CPU and GPU.
22:57:15 <Phyx-> chrome 6.0 does the same hardware accelerations stuff build in
22:57:25 <Phyx-> infact all browsers are starting to use the GPU
22:57:26 <fryguybob> Right, but that's not in the benchmark.
22:57:41 * Phyx- points out the Chrome 6.0 nightly in the benchmark
22:57:55 <fryguybob> Ah missed it :D
22:58:16 <Phyx-> and the Firefox 4.0 pre-release
22:58:41 <p_l> Phyx-: actually it does, when the n is small 
22:58:59 <p_l> and you get to use a simpler algorithm that fits better in cache :D
22:59:49 <p_l> fryguybob: Chrome definitely shows GPU usage in benchmarks, since it speeds up raw rendering which will still show in JS benchmarks
23:03:50 * Phyx- bangs head on table
23:06:24 <mauke> Phyx-: done
23:06:29 <mauke> preflex: longest-unseen
23:06:38 <Phyx-> lol
23:06:50 <Phyx-> not working
23:06:54 <Phyx-> eh...
23:06:58 <mauke> heh
23:07:01 <mauke> freenode is big
23:07:08 <Phyx-> hehehe
23:07:21 <Phyx-> is it not backed by some kinda database?
23:07:30 <mauke> it is
23:07:43 <Phyx-> sql?
23:07:50 <mauke> not directly
23:08:19 <Phyx-> better disable that, seems like a kill switch
23:08:20 <Phyx-> lol
23:09:05 <mauke> @hoogle maximumM
23:09:05 <lambdabot> No results found
23:16:55 * Phyx- crashed ghc
23:17:00 <Phyx-> no error
23:17:03 <Phyx-> nothing PP
23:17:04 <Phyx-> :P
23:18:46 <Phyx-> fixed
23:18:54 <Phyx-> time to modify the codegen
23:18:57 <Phyx-> stupid mistake
23:18:58 <Phyx-> :/
23:22:04 <Kaidelong> anyone used gloss?
23:22:08 <Kaidelong> any recommendations?
23:25:36 <mauke> preflex: longest-unseen
23:26:59 <preflex>  fghy was last seen on #perl 2 years, 113 days, 18 hours, 41 minutes and 23 seconds ago, saying: SINCE?
23:27:13 <mauke> freenode has entirely too many nicks
23:27:52 <Phyx-> hehehe
23:28:00 <Phyx-> or rather preflex has seen too many :P
23:28:17 <mauke> yay for linear scans over huge tables
23:28:23 <Phyx-> lol
23:28:31 <mauke> probably worse than linear
23:29:28 <Phyx-> atleast it didn't crash again
23:29:48 <mauke> it ran out of memory before
23:30:18 <Phyx-> lol
23:30:39 <Phyx-> i'm guessing the table is indexed over nicknames
23:30:47 <mauke> hah, no
23:31:21 <Phyx-> well, why not :P
23:31:45 <mauke> because there's only a single table and I need to store other things
23:31:59 <wioux> preflex: list
23:32:00 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen]; ZCode: [zdec, zenc]
23:32:21 <Phyx-> damnit, no haddock for 6.13 yet
23:32:27 <mauke> the actual keys look something like "!Seen:" ++ show (network, nick)
23:32:43 <Phyx-> ah, ok
23:33:31 <Phyx-> is there a way to override the dependency in a .cabal file when installing using cabal-install?
23:43:51 <Saizan> you can only make it stricter
23:44:32 <Wooga> how do i use hIsEOF's IO Bool in regular if-then-else construction ?
23:45:21 <mauke> Wooga: sounds like you need to understand IO first
23:45:31 <mauke> also, why are you using hIsEOF?
23:45:54 <Wooga> i am trying to write simple program reading text from file char by char untill it reach EOF
23:46:15 <Wooga> i want to solve this problem in this way
23:46:41 <Wooga> i understand that IO should go seperatly from pure functions
23:46:48 <mauke> no
23:46:53 <Wooga> but how do i use IO Bool then?
23:47:00 <mauke> Wooga: do you know javascript?
23:47:12 <Wooga> mauke: no, only php, posix sh and C
23:47:27 <mauke> hmm
23:47:42 <Wooga> ah, wait
23:47:45 <Wooga> not java, but javascript
23:47:52 <Wooga> yes, i writed some of those
23:48:15 <mauke> do you know XMLHttpRequest?
23:48:25 <Wooga> yes, it used for implementing AJAX
23:48:57 <Wooga> but i dont rememver clearly some details
23:49:02 <Wooga> remember*
23:49:06 <Saizan> "do b <- hIsEOF h; if b then .. else .."
23:49:16 <Saizan> b is of type Bool there
23:49:16 <Wooga> Saizan: oh, thank you!
23:49:42 <Veinor> clearly we need an ifM
23:50:09 <mauke> Wooga: basically, you attach a function to XMLHttpRequest and it gets called when the response arrives
23:50:10 <Saizan> an IO Bool is not a boolean, it's a recipe to get one by potentially executing some side-effects
23:50:25 <mauke> Wooga: IO works the same way
23:50:30 <mauke> it's all callback based
23:52:16 <Wooga> i just forgot that i am dealing with actions, which should be dereferenced (is it a right word?) with monadic <-/>>= thing
23:52:46 <mauke> >>= doesn't actually dereference, it just adds a callback to an "action"
23:53:23 <mauke> given an action m and a function f, (m >>= f) is a new action that (when run) first runs m, then calls f with the result (and then runs the result of f again)
