00:02:23 <humasect> what is fib useful for? =)
00:02:52 <mm_freak_> humasect: fibonacci numbers
00:03:14 <mm_freak_> > let fib n = floor $ (phi ** n - (-phi) ** (-n)) / sqrt 5 where phi = (1 + sqrt 5) / 2 in map fib [0..9]
00:03:15 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
00:03:39 <humasect> =) i should have said "what are fibonacci numbers userful for? =)"
00:03:53 <kmc> a few things, i don't think anyone here is claiming this is useful code though
00:04:06 <JHaskly> humasect: Project Euler?
00:04:06 <kmc> humasect, http://en.wikipedia.org/wiki/Fibonacci_number#Applications
00:04:08 <JHaskly> :P
00:04:45 <humasect> ah, interesting, thank you=)
00:04:54 <mm_freak_> wow, i didn't know there are any applications of them
00:05:08 <kmc> "The Fibonacci numbers and principle is also used in the financial markets. It is used in trading algorithms, applications and strategies. Some typical forms include: the Fibonacci fan, the Fibonacci arc, Fibonacci retracement and the Fibonacci time extension."
00:05:14 <kmc> ah, i do love cargo cult technical analysis
00:05:56 <geheimdienst> lol
00:06:08 <geheimdienst> "cargo cult" -- right on
00:06:25 <unlink> mm_freak_: yes, I was being tongue in cheek. But, this is #haskell
00:06:28 <humasect> =) another way to say RNG ?
00:06:57 <unlink> kmc: Fibonacci technical analysis is Serious Business(TM).
00:07:10 <kmc> haha
00:07:21 <kmc> ™
00:07:31 <mm_freak_> humasect: random number generator?
00:08:04 <humasect> yeah.. financial "stuff", prediction and strategies and etc.
00:08:11 <unlink> I love fibonacci retracements. "The four basic Fibonacci retracement levels are calculated as 23.8%, 38.2% 50.0% and 61.8% of the impulse."
00:08:12 <humasect> (like the weather)
00:08:14 <mm_freak_> ah lol
00:08:20 <mm_freak_> now i got it =)
00:08:24 <unlink> ... 50.0% ...?
00:08:42 <Zeiris> Why does this idea not work? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28504#a28504
00:09:25 <Zeiris> (I'm trying to make a typeclass that auto-fills type constructors like A and B in "data Foo = A Int | B Int Int" with default values.)
00:09:28 <kmc> none of the people i know who run actual successful quantitative finance strategies give three shits about this technical analysis chart squinting tea leaf reading nonsense
00:09:34 <kmc> in fact we'd mock it regularly
00:10:08 <Saizan> Zeiris: because the 'b' in Fillable class declaration doesn't match the 'b' in your instances, they merely share the same name as variables but are distinct
00:10:32 <kmc> Zeiris, if my type T is an instance of Fillable, then you promise a function of type «forall b. T -> b», i.e. you can make any type whatsoever from T
00:10:39 <kmc> such a function is a bit suspicious
00:10:48 <mm_freak_> > drop 100 . map (.&. 1) . iterate (\x -> mod (x^2) 4851085112721855747656629897) $ 2
00:10:49 <lambdabot>   [0,1,1,1,1,0,0,1,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,0,0,0,0,1,1,1,1,0,0,0,1,0,1,...
00:10:57 <kmc> maybe you want a multi-param type class
00:11:20 <kmc> class Fillable a b where fill :: a -> b; instance Default a => Fillable (a -> a -> b) b where ...
00:11:44 <kmc> then you might want a fundep too, class Fillable a b | a -> b where ...
00:11:48 <Zeiris> That... Makes sense. Sort of.
00:11:49 <kmc> or use an associated type synonym
00:11:58 <humasect> kmc: yep, @ tea leaf voodoo=)
00:12:38 <unlink> kmc: Again, tongue firmly in cheek, but due to the behavioral nature of markets, it can be useful to be aware of such cargo cult phenomena.
00:12:49 <kmc> yeah
00:13:18 <kmc> real quantitative finance looks like science, lots of matlab ;)
00:13:37 <unlink> looks can be deceiving :-)
00:13:58 <kmc> how do you mean?
00:15:19 <geheimdienst> it's not like anything has to be true to be useful, or to be worth money. if you can convince just a few people to give you $$ for your tea-leaf cargo-cult bullshit, then good for you ... i think the economy would shrink a lot if you killed everything untrue
00:15:48 <geheimdienst> (i'm not defending the crackpots, by the way. _i_ wouldn't give them money)
00:16:04 <kmc> yes but people won't give you money to invest unless you can deliver on returns
00:16:13 <unlink> What superficially appears to be reasoned, hard science is typically plagued by swaths of unaccounted-for uncertainty
00:16:21 <unlink> (in quant finance)
00:16:27 <kmc> true enough
00:16:34 <kmc> i meant in terms of methods, not rigor
00:16:44 <unlink> oh, definitely.
00:16:46 <kmc> i.e. that it involves serious data crunching, statistics, machine learning etc
00:16:59 <unlink> But then, so is detecting a head and shoulders pattern in a chart O:-)
00:17:16 <Saizan> "real science -> lots of matlab" makes me sad
00:17:41 <geheimdienst> saizan: garbage in, garbage out, matlab or no
00:17:50 <kmc> geheimdienst, you can lie about returns of course.  that's easy, it's a popular way to make money, it's called "fraud"
00:18:06 <unlink> geheimdienst: I was about to say the exact same thing.
00:18:32 <Saizan> i don't care about the results, matlab is the sad part.
00:20:35 <unlink> Laugh at technical analysis all you want, but as soon as your model mentions, "now assume stocks follow exponential Brownian motion", you might as well dip into your laundry quarters to predict your price movements.
00:22:07 <geheimdienst> kmc, i think you're right about investment (what little i know of it). what i had in mind with my snarkiness was more the stereotypical consultant wrapping bullshit into long words
00:22:15 <kmc> well i think that "assume a spherical market of uniform density" does work pretty well for everyday trading
00:22:23 <kmc> it fails spectacularly on weird long-tail events
00:23:05 <kmc> i think real quant strategies are all overfit to some degree, and this somewhat makes up for unrealistic assumptions at the expense of constant re-tuning
00:23:27 <unlink> Too bad that weird long tail events drive all significant price movements in the market.
00:24:57 <unlink> I love it when Bloomberg punts even on it usual narrative fallacy and publishes headlines of "Market swings X% on no news".
00:25:29 <kmc> hehe yes
00:26:35 <kmc> anyway there's a whole class of strategies that make money during periods of no significant price movements, and perhaps even shut down then
00:27:26 <unlink> That's the usual type. One needs to look no further than August '07 (or this past May I suppose) for corroboration.
00:30:26 <unlink> http://en.wikipedia.org/wiki/Nassim_Taleb#Ludic_fallacy
00:40:38 <dancor> http://en.wikipedia.org/wiki/Ludic_fallacy has its own, better, article
00:47:25 <unlink> dancor: Thanks, I just incidentally had that one open already.
00:49:30 <dancor> URL futures
00:50:13 <dancor> futurls
00:51:37 <dark> I'm getting the gentoo haskell overlay through darcs and literally 1h ago it downloaded 3.8mb but is intensely doing some processing
00:51:59 <dark> is darcs get meant to be cpu-bound? it seems like a bug (version 2.0.2 here)
00:52:21 <c_wraith> that's pretty old
00:52:31 <c_wraith> But yes, it sometimes goes exponential
00:53:34 <Cale> dark: Do a darcs show repo on it. Is the repo a darcs-2 repository?
00:54:38 <dark> that's the output so far: http://paste.pocoo.org/show/244534/ , someone suggested 2.4.4-r1 darcs at #gentoo-haskell, I'm trying to install
00:57:33 <Cale> dark: Well, I'm already past that point, and I just started.
00:57:57 <Cale> I'm using 2.0.2
00:58:42 <Cale> Finished just now
00:58:47 <dark> Cale, what's your ghc?
00:59:03 <dark> Cale, 6.8.2 here
00:59:05 <Cale> 6.10.4 on this machine
00:59:14 <Cale> 6.8.2 is really old
00:59:21 <Cale> 6.10.4 is also really old
00:59:48 <dark> it's the latest stable version at gentoo
00:59:55 <Cale> (but I need it for our project which uses GHC iPhone currently, so it's stuck on 6.10.4)
01:00:10 <dark> someone suggested me to install from the overlay, but for that i need the repo :P
01:00:18 <Cale> dark: You could do what I do and just get the generic linux binary of GHC.
01:00:39 <Cale> I never bother with my distribution's packages for Haskell stuff.
01:01:21 <dark> I will do just.. wget -R -np http://code.haskell.org/gentoo/gentoo-haskell/
01:01:27 <dark> ._.
01:02:22 <Cale> dark: Yeah, that ought to work too
01:03:35 <Cale> dark: btw, compiling your own GHC is always a temendous waste of time unless you're hacking on it. I suppose you're a gentoo user though.
01:04:08 <Cale> There ought to be a binary ghc package in the overlay anyway
01:07:59 <Wolfspaw> Ok, one last doubt before sleep: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28506#a28506 what can i do?
01:09:55 <wioux> [f x y | x <- list1, y <- list2]
01:10:24 <Wolfspaw> wioux: hm, nice one thanks!
01:10:32 <wioux> np :)
01:10:56 <kmc> alternatively:  liftA2 f list1 list2
01:10:56 <wioux> you get every pair in the cartesian product like that
01:11:03 <kmc> or:   f <$> list1 <*> list2
01:11:08 <kmc> using Control.Applicative stuff
01:11:17 <wioux> > [(x, y) | x <- [1,2,3], y <- [-1,-2,-3]]
01:11:18 <lambdabot>   [(1,-1),(1,-2),(1,-3),(2,-1),(2,-2),(2,-3),(3,-1),(3,-2),(3,-3)]
01:12:05 <dark> Cale, I will maybe give up eventually, but I switched to gentoo exactly to be in charge of that. (But I already gave up compiling chromium, so this is not without precedence:)
01:12:29 <kmc> the comprehension wioux suggested is probably the easiest to write/understand if you're just starting out
01:13:15 <kmc> it is equivalent to the (structurally similar) "do"-block:   do { x <- list1; y <- list2; return (f x y) }
01:13:26 <kmc> and from there you can see the connection to Monad / Applicative, if you are so inclined
01:14:42 <wioux> > do {x <- [0,1,2]; y <- ['a','b','c']; return (x,y)}
01:14:42 <lambdabot>   [(0,'a'),(0,'b'),(0,'c'),(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c')]
01:15:05 <wioux> hm
01:15:20 <Wolfspaw> kmc:  i read a bit about applicative and monads, but i cant think in solutions using it yet. If i focus my concentration in a code with a good explanation on it i can "temporaly" understand the code. xD
01:15:34 <kmc> ok :)
01:15:53 <kmc> if you squint just right the magic eye picture becomes a sailboat ;)
01:17:11 <wioux> yeah i understand it in comprehension form but not viscerally as a monad...
01:17:40 <wioux> > do {x <- [1,2,3]; y <- "abc"; z <- [(), ()]; return (x,y)}
01:17:40 <lambdabot>   [(1,'a'),(1,'a'),(1,'b'),(1,'b'),(1,'c'),(1,'c'),(2,'a'),(2,'a'),(2,'b'),(2...
01:18:15 <kmc> the translation between list-comprehension and list-"do" is simple and mechanical
01:18:27 <kmc> the trick to it is seeing why (>>=) = flip concatMap does what you want
01:19:04 <wioux> @src flip
01:19:04 <lambdabot> flip f x y = f y x
01:20:48 <kmc> or alternately, join = concat
01:22:40 <wioux> > (flip concatMap) [1,2,3] ((flip concatMap) "abc" (\x -> (\y -> (x, y)))
01:22:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:23:12 <wioux> > (flip concatMap) [1,2,3] ((flip concatMap) "abc" (\x -> (\y -> (x, y))))
01:23:12 <lambdabot>   Couldn't match expected type `a -> [b]'
01:23:12 <lambdabot>         against inferred type `[b1]'
01:23:24 <wioux> gah, its too late
01:23:31 <humasect> we are doomed!
01:23:59 <humasect> @src forM
01:24:00 <lambdabot> forM = flip mapM
01:37:50 <wioux> aha
01:38:26 <wioux> > (flip concatMap) [1..3] (\x -> (flip concatMap) "abc" (\y -> [(x,y)]))
01:38:27 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
01:41:50 <wioux> and it gets applied to all ordered pairs because of nesting..
01:42:37 <kmc> > concatMap (\x -> concatMap (\y -> [(x,y)]) "abc") [1..3]
01:42:38 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
01:43:11 <wioux> i see now
01:43:29 <kmc> > (\x -> (\y -> [(x,y)]) =<< "abc") =<< [1..3]
01:43:30 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
01:47:15 <wioux> (\x -> (\y -> Just (x,y)) =<< Just 1) =<< Just 'a'
01:47:24 <wioux> > (\x -> (\y -> Just (x,y)) =<< Just 1) =<< Just 'a'
01:47:25 <lambdabot>   Just ('a',1)
01:47:48 <eikke_> if forkOS or runInBoundThread run the action passed in in one single OS thread, does this also apply when using forkIO in this action?
01:48:15 <kmc> i'm not sure; i suspect not
01:48:39 <kmc> and that's not what bound threads mean
01:49:29 <kmc> you have no guarantee about where Haskell computation takes place
01:49:38 <kmc> only that successive FFI calls will come from the same OS thread
01:50:24 <eikke_> thats good enough :)
01:50:51 <RayNbow> @check \xs ys -> let {s = nub xs; t = nub ys} in length (union s t) == length s + length t - length (intersect s t)
01:50:52 <lambdabot>   "OK, passed 500 tests."
01:52:19 <kmc> nice :)
01:53:10 <kmc> @check \xs ys -> let {s = S.fromList xs; t = S.fromList ys} in S.size (S.union s t) == S.size s + S.size t - S.size (S.intersect s t)
01:53:11 <lambdabot>   Not in scope: `S.intersect'
01:53:17 <kmc> @check \xs ys -> let {s = S.fromList xs; t = S.fromList ys} in S.size (S.union s t) == S.size s + S.size t - S.size (S.intersection s t)
01:53:18 <lambdabot>   "OK, passed 500 tests."
01:53:55 <kmc> @check \s t -> S.size (S.union s t) == S.size s + S.size t - S.size (S.intersection s t)
01:53:56 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary (Data.Set.Set a))
01:53:56 <lambdabot>    arising fro...
01:54:03 <kmc> @check \xs -> xs == reverse xs
01:54:04 <lambdabot>   "OK, passed 500 tests."
01:54:40 <eikke_> hmh, that puzzles me?!?
01:55:31 <kmc> stupid trick
01:55:36 <kmc> the type of xs is defaulted to [()]
01:55:45 <kmc> @check \xs -> xs == reverse (xs :: [Bool])
01:55:46 <lambdabot>   "Falsifiable, after 0 tests:\n[True,False]\n"
01:56:05 <quicksilver> I really don't like extended-defaulting to ()
01:56:14 <kmc> i really don't like defaulting
01:56:14 <quicksilver> () is a most atypical type and defaulting to it seems unhelpful.
01:56:22 <uranther> @hoogle !
01:56:22 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
01:56:22 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
01:56:22 <lambdabot> Text.Html (!) :: ADDATTRS a => a -> [HtmlAttr] -> a
02:02:53 <Gracenotes> what's the status of deriving, say, NFData? I get the feeling someone must have written a TH masterpiece somewhere..
02:03:18 <copumpkin> deriva can do it
02:04:08 <quicksilver> Gracenotes: there are two packages you should look to for such questons : Data.Derive and DrIFT
02:04:15 <quicksilver> they can both derive NFData as it happens
02:04:39 <quicksilver> of course, using NFData means your program is broken ;)
02:05:01 <Gracenotes> quicksilver: D: is it
02:05:07 <copumpkin> yeah
02:05:22 <Gracenotes> I didn't know of this. explain before I bring on the apocalypse
02:05:27 <quicksilver> no, of course not, but it's bad code smell.
02:05:59 <copumpkin> it's a sledgehammer for "onoes laziness is making my code slow, let's kill it all"
02:06:55 <Gracenotes> ah I see. in this case it's a web server and I want to make sure complicated data structures are fully evaluated before they're served.
02:07:22 <Gracenotes> so it's not laziness that's the problem here, but, literally, not-being-evaluated
02:07:43 <Gracenotes> I think dons is trying to push the use of deepseq in this area
02:08:20 <quicksilver> Gracenotes: why do you want to make sure it's fully evaluated before being served?
02:08:27 <quicksilver> why not permit the serving to force htem in the usual way?
02:08:41 <quicksilver> I'm not really intending to challenge you but more context needed to understand this requirement
02:10:21 <Gracenotes> in a sense, there will be less overhead from doing a one-time evaluation, holding onto the old data before replacing it, as opposed to having the data structure be unfolded by several threads at the same time
02:12:55 <Gracenotes> this kind of system could easily be replaced by one that simply doesn't force evaluation. I think, personally, there's no harm, in this case, of returning the old value while the new one is still being worked on, which can take in some cases up to half a minute
02:12:57 <Saizan> ah, so you evaluate before broadcasting/putting it in a shared mvar ?
02:13:07 <Gracenotes> yeah
02:16:30 <Gracenotes> the main downside in my mind is all of the orphaned instances :/
02:16:40 <quicksilver> it's very unlikely to be unfolded by several threads at the same time
02:16:45 <quicksilver> are you sure that's actualy happening?
02:16:59 <quicksilver> in practice generally the first thread hits it and by the time the second is traversing it's all done
02:17:43 <Gracenotes> yes, that would involve a lot of weird interleaving. the main motivation for it is the responsiveness really.
02:18:31 <quicksilver> so it's more a case of you want to be in control of when it gets evaluated?
02:18:46 <quicksilver> rather than deferring evaluation until the first client request and then that client gets a slow response?
02:19:42 <Gracenotes> more or less
02:20:00 <Gracenotes> I can't be exactly sure, since I didn't write the module that does it. it's largely an enhanced MVar for me
02:20:15 <Gracenotes> but why else
02:21:30 <Saizan> unless it's an elaborate joke.
02:21:53 <quicksilver> Gracenotes: OK well if you're trying to use a module which requires NFData then you are off the hook, it's not your fault ;)
02:22:21 <quicksilver> I think it might be a bit more composable to require a (Strategy a) instead ("How much evaluation should be done upfront")
02:22:39 <quicksilver> but it is perfectly sensible ot want to do computation up front to keep responses responsive.
02:22:54 <HugoDaniel> i want to be a better haskell coder
02:24:02 <Gracenotes> quicksilver: possible. at present, the most general function of the function is (a -> ()), for which rnf is really a more specific (but more composable) version
02:24:08 <Gracenotes> *general version
02:24:45 <Gracenotes> it's tempting, all of those data structures you get from all of those recursive instances
02:33:36 <wioux> what's the point of irrefutable pattern matches?
02:33:47 <kmc> with ~ ?
02:33:53 <wioux> yeah
02:33:57 <dolio> > case undefined of ~(x, y) -> length [x, y]
02:33:58 <lambdabot>   2
02:34:31 <Gracenotes> > let (x, y) = undefined in length [x, y] -- test
02:34:32 <lambdabot>   2
02:34:34 <kmc> the point is to take apart a value without introducing extra strictness
02:34:50 <kmc> > let swap (x,y) = (y,x) in swap undefined `seq` ()
02:34:51 <lambdabot>   *Exception: Prelude.undefined
02:34:55 <kmc> > let swap ~(x,y) = (y,x) in swap undefined `seq` ()
02:34:56 <lambdabot>   ()
02:34:56 <wioux> ah
02:35:36 <wioux> weird
02:35:40 <dolio> > foldr (\x (xs, _) -> (x:xs, xs)) ([], error "tail of empty list") [1..]
02:35:41 <lambdabot>   *Exception: stack overflow
02:35:45 <kmc> > let swap p = (let (x,y) = p in (y,x)) in swap undefined `seq` ()
02:35:46 <lambdabot>   ()
02:35:48 <dolio> > foldr (\x ~(xs, _) -> (x:xs, xs)) ([], error "tail of empty list") [1..]
02:35:49 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
02:36:03 <dolio> > snd $ foldr (\x ~(xs, _) -> (x:xs, xs)) ([], error "tail of empty list") [1..]
02:36:04 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
02:36:10 <dolio> > snd $ foldr (\x (xs, _) -> (x:xs, xs)) ([], error "tail of empty list") [1..]
02:36:11 <lambdabot>   *Exception: stack overflow
02:36:43 <Gracenotes> also useful for lazily unfolding partition-type functions
02:36:44 <dolio> In the report, the operational semantics of let is defined via case and ~.
02:37:02 <dolio> And fix.
02:37:49 <quicksilver> dolio: operational?
02:37:58 * quicksilver thought the report was mainly about nailing down the denotational.
02:38:12 <dolio> "Dynamic semantics" they call it.
02:38:27 <dolio> The translation is wrong if you take types into account.
02:38:58 <dolio> But operationally, you can take case as primitive, and define let in terms of it, for pattern matching.
02:39:39 <dolio> I suppose it could work denotationally, too.
02:39:41 <wioux> which is how e.g. let (x,y) = (1,2) works?
02:39:46 <Gracenotes> I like thinking that ~ makes case behave like let. shows my bias.
02:40:17 <wioux> case (1,2) of (x,y) -> ...in..
02:40:55 <dolio> let p1 = e1 ; p2 = e2 ; ... in e ==> let (~p1, ~p2, ...) = (e1, e2, ...) in e, I believe.
02:41:39 <dolio> let p = e in e' ==> let p = fix (\~p -> e) in e'  if the let is recursive.
02:41:58 <dolio> let p = e in e' ==> case e of ~p -> e'  if the let is non-recursive.
02:42:12 <dolio> I think that's it.
02:44:19 <quicksilver> Gracenotes: I think that a reasonable way to think.
02:45:09 <Gracenotes> the STG machine lends equal focus to both case and let though
02:45:25 <dolio> You could have a similar translation of ~ in patterns back to let, but I think you'd have to worry about variable capture.
02:46:22 <dolio> case x of ~x -> x ==> let x = x in x is wrong, for instance.
02:47:11 <dolio> ~ can be useful in avoiding multiple lets, too.
02:47:51 <Gracenotes> recursive tuple lets are crazy
02:48:31 <dolio> For instance 'let (~(w,x),~(y,z)) = t in ...' is the same as 'let (p1, p2) = t ; (w, x) = p1 ; (y, z) = p2 in ...'.
02:49:12 * hackagebot binary-protocol-zmq 0.2 - Monad to ease implementing a binary network protocol over ZeroMQ  http://hackage.haskell.org/package/binary-protocol-zmq-0.2 (NicolasTrangez)
02:50:13 <dolio> And those two are not the same as 'let ((w, x), (y, z)) = t in ...'
02:51:07 <dolio> > let ((w, x), (y, z)) = (undefined, (1, 2)) in y
02:51:08 <lambdabot>   *Exception: Prelude.undefined
02:51:10 <dolio> > let (~(w, x), ~(y, z)) = (undefined, (1, 2)) in y
02:51:10 <lambdabot>   1
02:51:29 <Gracenotes> that would be a fun Haskell final exam
02:51:32 <Gracenotes> :|
02:52:30 <dolio> Maybe I should post that on that blog article asking for Haskell quizzes.
02:52:44 <copumpkin> ooh yes
02:53:35 <wli> dolio: You've got a quiz?
02:55:43 <Gracenotes> Greetings, your job interview question is: *a let statement of tuple with 12 total nodes, scattered irrefutable matches, 2 infinite lists, 1 tree, and several bottoms, tying the knot a total of 3 times*. You have 15 minutes.
02:56:10 <copumpkin> :P
02:57:57 <etpace> i thought let was lazy? hence using case to force evaluation to hnf or something
02:58:38 <copumpkin> sort of
02:58:41 <Gracenotes> pattern-matching functions, definable in let, use case implicitly
02:59:25 <dolio> in 'let ((w, x), (y, z)) = (undefined, (3, 4)) in y', when you use y, you must match the outer tuple.
02:59:38 <dolio> Once you match the outer tuple, you're committed to matching both sides of the inner tuple, as well.
03:00:38 <dolio> So the failure of the (w, x) pattern results in failure of the match, and y is set to undefined.
03:01:18 <dolio> With 'let (~(w, x), ...', the pattern succeeds trivially, and y is set to 3, instead.
03:02:14 <wli> I don't get why the irrefutability matters there since the only pairing is the other half.
03:03:00 <wli> heh I had that typed and wanted to erase not send
03:04:00 <copumpkin> it doesn't care that you don't use w or x, it still needs to bind them to something, and to do that it needs to pattern match undefined with the (,) constructor
03:04:54 <wli> It seems like a weird technicality that it'd throw an exception to evaluate y.
03:06:38 <ivanm> omg, it's a co-squash!
03:06:48 <copumpkin> :)
03:07:31 <quicksilver> I don't think it's really a technicality, wli
03:07:40 <quicksilver> pattern matching is deep and 'instant', not lazy.
03:07:48 <quicksilver> f (x:y:xs) = ....
03:07:59 <quicksilver> forces the first to elements whether or not you examing x and y
03:08:19 <wli> I guess I expected lazy pattern matching.
03:09:27 <dolio> The unexpected behavior results from nested matching.
03:09:48 <dolio> People generally expect ~ to make all the matching irrefutable, but it only makes the outer-most match irrefutable.
03:10:29 <copumpkin> quicksilver: but that's a case match there
03:11:11 <copumpkin> it should also only force the first two cons cells
03:11:21 <dolio> I can't really find anything in the report about desugaring nested matching into a non-nested variety, though.
03:11:24 <ivanm> looks like the old RWH google group has been forgotten: http://www.haskell.org/pipermail/beginners/2010-July/004850.html
03:11:36 <dolio> Maybe nested is primitive.
03:11:37 <copumpkin> but apart from nitpicking :P
03:11:37 <copumpkin> onoes
03:11:48 <dolio> That makes it a little harder to explain,t hough.
03:12:02 <wli> I would expect let ~((w, x), (y, z)) = (undefined, (1, 2)) to do the right thing
03:13:45 <dolio> Anyhow 'let ((w, x), (y, z)) = (undefined, (1, 2)) in y' is like: case (undefined, (1, 2)) of ~(p1, p2) -> case p1 of (w, x) -> case p2 of (y, z) -> y
03:14:38 <dolio> And 'let (~(w, x), (y, z)) = (undefined, (1, 2)) in y' is like: case (undefined, (1, 2)) of ~(p1, p2) -> case p1 of ~(w, x) -> case p2 of (y, z) -> y
03:15:13 <wli> Does left-to-right order matter?
03:15:28 <dolio> Not really.
03:15:37 <dolio> You have to do them all, though.
03:16:05 <dolio> If you match (y, z) first, you still have to match (w, x), even though you're not looking at it.
03:17:05 <wli> Ah, let (_, (y, _)) = (undefined, (1, 2)) does what I expect.
03:17:37 <copumpkin> let (x, (y, q)) should too
03:17:49 <dolio> Yes. Variables are irrefutable.
03:18:56 <wli> Not sure why just binding a variable does any forcing. I'd expect forcing only for eval (which I guess is wrong about my intuition or something).
03:19:42 <dolio> Binding a variable doesn't do any forcing.
03:19:49 <dolio> (w, x) is not a variable.
03:20:20 <wli> Okay, then maybe it's something else.
03:21:10 <wli> let ((_, _), (y, _)) = (undefined, (1, 2)) catches an exception.
03:21:38 <lucca> for the same reason that x:xs doesn't match with []
03:21:51 <Gracenotes> methought _ does not have any effect on the semantics
03:21:52 <copumpkin> it's sort of odd though, because you'd expect let (x, y) = undefined in 5 to fail too
03:22:24 <Gracenotes> at some IR dummy vars are used
03:22:25 <lucca> (,) is a constructor
03:22:28 <copumpkin> (i.e., splitting the two sides of the pair into separate let bindings)
03:22:29 <copumpkin> yeah, it doesn't
03:22:44 <quicksilver> wli: no it doesn't.
03:22:49 <quicksilver> > let ((_, _), (y, _)) = (undefined, (1, 2)) in 5
03:22:50 <lambdabot>   5
03:23:06 <quicksilver> or maybe I misunderstood what you meant by 'catches an exception'
03:23:17 <copumpkin> oh, interesting
03:23:25 <Gracenotes> quicksilver: do you mean y?
03:23:26 <copumpkin> > let ((x, _), (y, _)) = (undefined, (1, 2)) in 5
03:23:27 <lambdabot>   5
03:23:32 <wli> > let ((_, _), (y, _)) = (undefined, (1, 2)) in y
03:23:32 <quicksilver> no, I meant what I wrote
03:23:33 <lambdabot>   *Exception: Prelude.undefined
03:23:36 <quicksilver> but I'm not sure what wli meant ;)
03:23:39 <dolio> > let (_, _) = undefined in 5
03:23:40 <lambdabot>   5
03:23:49 <dolio> That is not surprising.
03:24:10 <quicksilver> so what's surprising is that by accessing y you force the whole shape, not just the path that leads to y
03:24:11 <copumpkin> dolio: I'd just assume you can split up a nested let like that
03:24:18 <copumpkin> quicksilver: exactly
03:24:18 <quicksilver> I think that is surprising, yes.
03:24:28 <wli> It seems like it shouldn't bother trying to pattern match on the half of the outer pair that's not used.
03:24:30 <Gracenotes> if nothing in a let clause is used, why should be compiler both with it
03:24:35 <Gracenotes> *bother
03:24:43 <copumpkin> Gracenotes: it is though
03:24:56 <quicksilver> I'd expect let ((_,_),(y,_)) = e to be the same as let y = fst . snd $ e
03:25:03 <quicksilver> but wli's example shows it isn't.
03:25:05 <quicksilver> I do think that's odd.
03:25:13 <Gracenotes> I would rightly expect 'let <anything> in 5' to evaluate to 5. I wonder if we're on the same page
03:25:23 <quicksilver> Gracenotes: yes, we all agree with that.
03:25:31 <quicksilver> Gracenotes: that's not what we're being surprised by.
03:25:43 <copumpkin> > let ((_, _), (y, _)) = (undefined, (1, 2)) in y -- I'd expect it to be safe to split this into let (_, _) = undefined; (y, _) = (1, 2) in y
03:25:44 <lambdabot>   *Exception: Prelude.undefined
03:25:50 <quicksilver> we're surprised that when you *do* use the 'y' it forces an undefined in different part of the pair
03:25:51 <copumpkin> so first case split the outer pair, then let bind the two inner ones
03:25:54 <quicksilver> copumpkin: yeah, me too.
03:26:06 <Gracenotes> with the dummy vars, yeah
03:28:01 <copumpkin> it seems like the desugaring into cases would have effects for polymorphism too
03:28:32 <dolio> Yes, the translation is only valid for "dynamic semantics".
03:28:33 <copumpkin> instead of desugaring into case + let
03:28:51 <dolio> Not static semantics.
03:29:36 <dolio> To make it work for types, you'd need rank-2 types, at least. And I'm not sure it would even work then.
03:30:09 <dolio> Probably impredicative types, too.
03:30:38 <copumpkin> oh, so that isn't actually how it gets translated? it's just how it behaves for that case?
03:31:16 <dolio> It's the report's definition of the behavior of let. The report takes case as the only pattern matching primitive.
03:31:38 <dolio> I don't think GHC actually uses that translation.
03:32:19 <dolio> It probably translates some cases into lets, even.
03:32:26 <wli> How "far" can one make this happen?
03:32:38 <dolio> Because case always evaluates, even for variables in core.
03:32:54 <dolio> There, case is for evaluation, and let is for heap allocation.
03:33:03 <dolio> Or something like that.
03:34:11 <quicksilver> dolio: case always evaluates .... but only for variables in core
03:34:17 <Gracenotes> explicit cases are fun
03:34:23 <quicksilver> dolio: haskell case does not always evaluate but core-case does.
03:34:29 <dolio> Isn't that what I said?
03:34:41 <quicksilver> it doesn't contradict what you said
03:34:57 <quicksilver> but your intensifier "even" seemed to imply you thought case always evaluated in haskell
03:35:01 <Gracenotes> doesn't this depend on what you mean by 'evaluate' as well
03:35:02 <quicksilver> (and even in core)
03:35:11 <quicksilver> Gracenotes: WHNF, is what I mean here.
03:35:13 <Gracenotes> WHNF vs NF?
03:35:14 <dolio> I missed a comma.
03:35:15 <quicksilver> (and dolio too I think)
03:35:23 <dolio> '... evaluates, even for variables, in core.'
03:35:25 <quicksilver> dolio: ah. "even-for-variables"
03:35:28 * quicksilver understand now.
03:35:32 <quicksilver> damn ambiguous language.
03:36:12 <Gracenotes> oh, core, as in the IR. I was thinking of the RTS casing on primitives. .. please ignore
03:38:37 <copumpkin> Gracenotes: NF is pretty uncommon, unless you use NFData, which means you suck
03:38:37 <copumpkin> ;)
03:39:07 <Gracenotes> NF for primitives, the only way to be, wat up.
03:49:25 <wli> It doesn't look like you can bury undefined deep enough in a pattern not to catch an exception.
03:54:46 <dolio> I'm not sure why putting it deeper would make a difference.
03:55:19 <wli> In one way of thinking you'd never get to breaking apart the structures enough to hit the undefined.
03:58:04 <dolio> Should 'case ((((undefined,1),2),3),4) of (((((u,v),w),x),y)z) -> z' work?
04:09:10 <Kaidelong> wouldn't you preferentially try to avoid returning undefined as much as possible and rely on Maybe or Either monads if it is likely you'll do so often?
04:09:38 <Kaidelong> as far as I remember undefined is considered equivalent to a computation that doesn't terminate
04:10:06 <Ke> I would consider undefined as a failed assert
04:15:21 <uranther> is there a free ebook of Real World Haskell?
04:15:53 <MasseR> Yes
04:16:08 <MasseR> http://book.realworldhaskell.org/read/
04:16:20 <uranther> err, in PDF format?
04:16:25 <MasseR> Oh
04:18:03 <uranther> I figured since it's CC, that someone generated a PDF with a script
04:20:04 <silver_> try to google that
04:21:12 <yitz> > let ((_, _), (y, _)) = (undefined, (1, 2)) in y -- why is this surprising?
04:21:13 <lambdabot>   *Exception: Prelude.undefined
04:21:40 <yitz> for pattern matching, it needs to see that the undefined is a tuple.
04:22:24 <yitz> first it checks that the entire pattern matches, and only then binds
04:25:40 <copumpkin> yitz: I would expect that to behave as case (undefined, (1, 2)) of (p ,q) -> let (_, _) = p; (y, _) = q in y
04:26:05 <yitz> i wouldn't expect that at all. why do you?
04:26:06 <copumpkin> i.e, the outer pattern gets split to reveal the inner ones
04:26:27 <copumpkin> which get treated separately as let bindings
04:26:28 <copumpkin> > case (undefined, (1, 2)) of (p, q) -> let (_, _) = p; (y, _) = q in y
04:26:29 <lambdabot>   1
04:26:47 <yitz> interesting i would have never thought of that.
04:26:48 <copumpkin> because the evaluation to whnf of the fst of the outer tuple is completely unnecessary
04:27:33 <yitz> but it is necessary - the semantics of patterns is that they get matched, and you need to evaluate enough to check them.
04:27:43 <dolio> yitz: I think people expect nested patterns in a let to expand to multiple let-matches. But that's wrong.
04:27:44 <copumpkin> I mean, I can sort of see why this happens this way too
04:27:56 <yitz> i never expected that
04:28:07 <copumpkin> but I think the other one would be a more "haskelly" way of doing it
04:28:43 <dolio> yitz: It's not very surprising once you know how it does work, though.
04:28:49 <int-e> copumpkin: imagine the case where you have more than one constructor, say ... (True, _) vs. (False, _)
04:28:50 <copumpkin> I mean, when you let (x, y) = undefined in Q, where Q does not contain x or y, you don't get _|_
04:28:50 <copumpkin> so you'd expect it to "compose"
04:29:24 <int-e> copumpkin: not matching the inner constructors of a pattern would be fatal then
04:29:26 <yitz> pattern matches are strict. i think that even follows from the report, but i'd have to look at it again
04:30:25 <int-e> > let f (~False) = "no"; f True = "yes" in f True
04:30:26 <lambdabot>   "no"
04:30:27 <copumpkin> int-e: yeah, I can see why it happens this way, but I'm not sure I like it
04:30:43 <yitz> copumpkin: that's because let patt = val is explicitly made equivalent to let ~patt = val. That I know is in the report.
04:30:44 <copumpkin> yitz: case and let pattern matches behave differently though
04:30:55 <yitz> indeed, intentionally.
04:30:58 <copumpkin> like case undefined of (x, y) -> 5 vs let (x, y) = undefined in 5
04:30:59 <copumpkin> if you add a ~ to the first one or a ! to the second
04:30:59 <copumpkin> then you make them behave the same way again
04:31:00 <copumpkin> yeah
04:31:15 <copumpkin> just saying you'd expect it to work recursively for nested patterns
04:31:36 <dolio> Why would you expect that?
04:31:36 <copumpkin> or at least, I would
04:31:40 <zygoloid> copumpkin: i think it depends how you're taught let works
04:31:41 <copumpkin> I can see why not though
04:31:45 <dolio> ! doesn't deepseq.
04:32:05 <zygoloid> copumpkin: both interpretations are "natural" in some sense i think
04:32:27 <dolio> I suppose that's an improper analogy.
04:32:28 <zygoloid> operationally i think the interpretation which haskell uses is better
04:32:31 <copumpkin> dolio: I'd just expect nested let patterns to behave as "let" patterns as much as they can. Case where it's needed, and let everywhere else
04:33:26 <zygoloid> copumpkin: suppose it worked that way. how would you write a let binding which you wanted to be that little bit stricter?
04:33:28 <copumpkin> it just seems like let (p, q) = (P, Q) should behave in a sense like let p = P; q = Q
04:34:05 <zygoloid> would "let (!p, q) = (undefined, 0) in q" result in _|_? if so, composability still doesn't hold. if not, ! is 'broken'.
04:34:23 <dolio> > let (!p, q) = (undefined, 0) in q
04:34:24 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
04:34:46 <copumpkin> zygoloid: yeah, it obviously isn't as simple as what I said
04:35:01 <dolio> That expression is _|_.
04:35:02 <copumpkin> just saying what one (I) would expect to happen
04:35:43 <zygoloid> dolio: of course it is :) but if complex lets desugared to nested lets, it presumably wouldn't be...
04:35:58 <copumpkin> > let !p = undefined in 5
04:35:59 <lambdabot>   *Exception: Prelude.undefined
04:36:19 <dolio> Wait, it allows that but complains about the bang inside a tuple?
04:36:35 <zygoloid> dolio: that's not a pattern binding ;-)
04:36:36 <copumpkin> maybe it just likes me more
04:36:38 <int-e> let !(p, q) = (P, Q) will behave like let p = P; q = Q, I think
04:37:02 <zygoloid> int-e: are p and q patterns or variables there?
04:37:10 <dolio> zygoloid: Why would it allow bang patterns at all if -XBangPatterns isn't enabled?
04:37:10 <int-e> patterns
04:37:11 <copumpkin> > let !((_, _), (y, _)) = (undefined, (1, 2)) in y
04:37:12 <lambdabot>   *Exception: Prelude.undefined
04:37:19 <zygoloid> int-e: not so.
04:37:22 <dolio> Whether they're inside other patterns or not.
04:37:25 <int-e> ah. thanks.
04:39:00 <int-e> so we need !(~(p), ~(q)) then, but that's silly.
04:39:18 <dolio> Did they just enable !var in general, for the required 'let var :: Int# ; !var = 5#' stuff?
04:41:19 <zygoloid> dolio: as far as i can see, it's just because ! is unambiguous at the start of a pattern (it can't be confused with an infix operator (!))
04:41:46 <zygoloid> certainly doesn't look like the haskell'10 report allows it
04:42:30 <dolio> Yeah, I think they're still working out how exactly to tweak the syntax to make ! less of an aberration.
04:44:41 <dolio> Losing ! as an operator might not be so bad, but I don't use Data.Array much.
04:46:07 * hackagebot interpolatedstring-perl6 0.5 - QuasiQuoter for Perl6-style multi-line interpolated strings  http://hackage.haskell.org/package/interpolatedstring-perl6-0.5 (AudreyTang)
04:46:08 <copumpkin> indexing is the devil anyway
04:46:38 <dolio> Yeah, you could get rid of !! for lists and use it for arrays instead.
04:46:47 <dolio> Although the current (!!) has rare uses.
04:49:07 <copumpkin> it's a crutch for newbies who pretend lists are arrays
04:49:16 <mjrosenb> with -XFlexibleInstances, instance (Foo a, Foo b) => Foo (a,b) should be fine, right?
04:49:17 <copumpkin> definitely worth keeping around ;)
04:49:40 <ivanm> copumpkin: yeah, I've always found that weird where languages with some lambda calc basis use lists as the fundamental data type, and OO/imperative langs use arrays
04:50:24 <dolio> mjrosenb: That should be fine with Haskell 98.
04:51:07 <mjrosenb> oh, it is complaining on the definition of the function, not the instance per se.
04:57:48 <Cale> ivanm: I think the reason mostly has to do with sharing.
04:58:27 <Cale> (At least in the strict FP languages, lazy ones have even more reasons to go with lists :)
05:04:17 <ivanm> Cale: "sharing"?  as in mutability?
05:04:26 <ivanm> (i.e. being able to use it with in-place updates)
05:04:52 <ivanm> I would think it's more because lists are so easy to define in FP langs/lambda calc (including lisps) but harder in OO/imperative langs
05:05:52 <dolio> Well, lists are algebraic, and arrays aren't, exactly. So that explains some of it.
05:07:46 <Cale> ivanm: I mean the ability of lists to share tails with one another without making additional copies.
05:07:54 <mjrosenb> ivanm: i would expect that sharing means sharing computation where you can have one list l, then say x = 1:l; y = 2:l;  now you have "two" lists, but it only needs to be evaluated once
05:07:58 <mjrosenb> efb
05:09:51 <dolio> And arrays arise pretty simply from the 'manipulating chunks of memory' model that lots of imperative programming goes with.
05:09:59 <RayNbow> jelly12gen: I search for "Haskell "in1605"" and I find a file you wrote :p
05:14:03 <eikke_> if I use GeneralizedNewtypeDeriving and derive (e.g.) Monad and MonadIO, is there any way to know which 'code' GHC generated for these instances? (out of interest)
05:14:50 <Nibble> xor in haskell? is there any built in function for it?
05:15:12 <FauxFaux> > (15^15)
05:15:13 <lambdabot>   437893890380859375
05:15:59 <Ke> @type (.^.)
05:16:00 <lambdabot> Not in scope: `.^.'
05:16:03 <dolio> What xor?
05:16:04 <Ke> @type (.|.)
05:16:05 <lambdabot> forall a. (Bits a) => a -> a -> a
05:16:37 <Nibble> dolio: xor, exclusive or
05:16:39 <dolio> > [ x /= y | x <- [False, True] , y <- [False, True] ]
05:16:40 <lambdabot>   [False,True,True,False]
05:16:50 <uranther> is there any more information about the Haskell AI Strike Force (besides haskellwiki/AI)?
05:17:07 <dolio> > 5 `xor` 5
05:17:07 <uranther> the mailing list archive has 1 thread 
05:17:08 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:17:08 <lambdabot>    `Data.Bits.Bits a'
05:17:08 <lambdabot>      a...
05:17:11 <dolio> > 5 `xor` 5 :: Int
05:17:12 <lambdabot>   0
05:17:20 <Nibble> dolio: that didn't work. it din't find xor.
05:17:22 <Nibble> and besides
05:17:29 <Nibble> xor should return a Bool
05:17:30 <dolio> xor is in Data.Bits.
05:17:31 <Traveler9> Hello, all. 
05:17:34 <Nibble> dolio: ok
05:17:49 <dolio> Well, then, I'm not sure what you're talking about. You want to xor two booleans?
05:18:06 <dolio> (/=) on booleans works for that.
05:18:20 <Nibble> ok
05:18:23 <Nibble> that's what I wanted
05:18:57 <Nibble> doesn't /= mean not equal to in haskell?
05:19:06 <dolio> Yes.
05:19:07 <Nibble> I guess it has the same functionality.
05:19:08 <Nibble> :P
05:19:21 <Traveler9> > let x = 7 in map (*7) [1..15]
05:19:21 <lambdabot>   [7,14,21,28,35,42,49,56,63,70,77,84,91,98,105]
05:19:49 <dolio> And a `xor` b is only true when one is True and the other is False, meaning they are unequal.
05:20:00 <Nibble> dolio: I know how xor works
05:21:20 * hackagebot DSTM 0.1.1 - A framework for using STM within distributed systems  http://hackage.haskell.org/package/DSTM-0.1.1 (FrankKupke)
05:22:31 <chrisdone> how do I make an alias for this beast? (Functor m,MonadCatchIO m,MonadCGI m,MonadIO m,MonadDriver driver)
05:23:46 <zygoloid> chrisdone: is that last 'driver' supposed to also be an 'm'?
05:24:07 <chrisdone> zygoloid: no, it's separate. we can ignore that one if it makes it easier
05:24:08 <Gracenotes> you can get rid of Functor by using liftM instead of fmap. *duck*
05:24:16 <chrisdone> Gracenotes: I'm using <$>
05:24:21 <zygoloid> chrisdone: in any case: class (Functor m, MonadCatchIO m, MonadCGI m, MonadIO m, MonadDriver driver) => MyConstraints m driver
05:24:23 <Gracenotes> yeah
05:24:26 <zygoloid> instance (Functor m, MonadCatchIO m, MonadCGI m, MonadIO m, MonadDriver driver) => MyConstraints m driver
05:24:35 <zygoloid> ^^ that's how do to a constraint synonym
05:24:35 <chrisdone> zygoloid: I tried that but I must've done it wrong
05:24:40 <chrisdone> hmm
05:25:03 <Kaidelong> do you have multi-parameter type classes enabled?
05:25:14 <Gracenotes> cue feature request for typeclass aliases
05:25:23 <Kaidelong> (it's not standard)
05:25:33 <zygoloid> chrisdone: what happened when you tried that?
05:25:34 <chrisdone> hmm
05:25:51 <chrisdone> I must've literally written something wrongly because this is exactly what I tried. /me checks the compile errors
05:26:06 <Gracenotes> zygoloid: would that require overlapping instances?
05:26:08 <zygoloid> (you can avoid MPTCs by splitting off the (MonadDriver driver) constraint)
05:26:39 <zygoloid> Gracenotes: no. there's only one instance, so there can be no overlap :)
05:27:05 <zygoloid> if you got rid of the 'driver' i think it'd require UndecidableInstances
05:27:12 <Gracenotes> I forget whether or not GHC is "optimistic" in this respect
05:27:14 <chrisdone> heh, wtf. /me goes through his "undo" history
05:27:34 <Traveler9> How do you make any indentations in GHCi? 
05:27:45 <zygoloid> Traveler9: you use braces instead of indentation.
05:27:54 <Gracenotes> http://repetae.net/recent/out/classalias.html anyhow
05:28:24 <Kaidelong> I'm not terribly sure about type syntax in haskell, but would the m in the constraints be the same m, and "forall m"?
05:28:45 <Kaidelong> so that it enforces that the type must be the same
05:28:48 <Traveler9> Oh. So the command has to be in one line?
05:28:54 <chrisdone> wahhh
05:28:55 <zygoloid> Traveler9: that is correct, sadly.
05:29:26 <Gracenotes> often you can define temp functions in the module, and then delete them when you're done ghci-ing
05:29:28 <Kaidelong> traveler9: GHCi is a little disappointing, but you can always use a text editor and :l(oad) them
05:29:33 <zygoloid> Kaidelong: yes, it's the same m. you get implicit quantification of all type variables mentioned in the class/instance head.
05:29:46 <Kaidelong> okay
05:29:57 <Kaidelong> so in terms of predicate logic you get something like
05:30:37 <Gracenotes> I have a command to make a temp file, actually: name='/tmp/'$(tr -dc "[:lower:]" < /dev/urandom | head -c 2)'.hs', then fork with your editor of choice and ghci there
05:31:06 <chrisdone> zygoloid: ehhh, I have no idea. in my history I tried this and got Could not deduce (Functor m) from the context (Component m driver). now with seemingly the same code (undo'd), it works as I originally expected. haha, I can't figure out what I typed wrongly
05:31:07 <Gracenotes> <works well enough..>
05:31:34 <Kaidelong> ((Am)(Adriver)(Ax))(meFunctor n meMonadCatchIO etc
05:31:37 <zygoloid> chrisdone: time to blame cosmic rays
05:31:50 <Kaidelong> and then end up with
05:31:51 <chrisdone> zygoloid: I'm with you on that. I never make mistakes
05:32:14 <Kaidelong> hmm guess not
05:32:15 <zygoloid> Gracenotes: name=$(mktemp) ?
05:32:53 <Kaidelong> oh hmm, does someone know a good resource on formal definitions of haskell type signatures?
05:32:58 <Gracenotes> uh. that might work as well. less pretty of a name for loading though.
05:33:00 <Kaidelong> I should probably take a look at that
05:33:10 <zygoloid> Gracenotes: seems like a neat trick in any case
05:34:19 <zygoloid> Kaidelong: where does the \forall x. come from?
05:34:48 <Kaidelong> zygoloid: I was thinking the instance itself would be an x, but it would be existential, not universal...
05:34:53 <Kaidelong> so that was wrong
05:35:05 <Kaidelong> I am clearly not quite understanding type signatures yet
05:35:54 <Kaidelong> hmm, also, the existential instantiation would be in the consequent
05:36:09 <Kaidelong> "if these conditions are met, there exists an instance..."
05:37:07 <ivanm> Cale: oh, right
05:37:48 <zygoloid> in system fc, it's something like "/\m driver -> \dict1 dict2 dict3 dict4 dict5 -> MyConstraintsDict @m @driver dict1 dict2 dict3 dict4 dict5"
05:37:49 <Cale> Heh, did anyone else see jailbreakme.com? :)
05:38:11 * Kaidelong doesn't know System FC, perhaps should learn it?
05:38:30 <Cale> (totally off-topic :)
05:38:46 <ivanm> Cale: *tsk, tsk*
05:38:51 <tibbe> Could someone please give me an opinion on the State of Haskell survey I've created (please don't fill it out yet!): https://spreadsheets.google.com/viewform?formkey=dGVsZkY1S0R3WUt6aTRaTGJQUVp0MUE6MQ
05:39:11 <Cale> Now, I just need to go visit the Apple store...
05:39:12 <zygoloid> Kaidelong: it can be useful for understanding some of GHC's type extensions
05:39:30 <ivanm> tibbe: I'd appreciate it a multi-option for Q2
05:39:47 <Cale> (and jailbreak everything there :)
05:39:51 <ivanm> I mean, I use it for stuff I want atm, but will be using it for uni when I actually start writing code except just reading papers :s
05:39:53 <zygoloid> Kaidelong: also if you want to read core (which is basically system fc)
05:39:56 <ivanm> Cale: lol
05:40:01 <chrisdone> newtype CGIIO a = CGIIO { unCGIIO :: ST.StateT CGIIOState IO a }
05:40:01 <chrisdone>   deriving (Monad,MonadIO,ST.MonadState CGIIOState,Functor,MonadCatchIO)
05:40:01 <chrisdone> god damnit I love -XGeneralizedNewtypeDeriving
05:40:25 * hackagebot th-lift 0.4 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.4 (MathieuBoespflug)
05:40:35 <ivanm> tibbe: also, the "workplace" question is a bit hard to quantify if you're not working (either a student or unemployed)
05:40:36 <Kaidelong> zygoloid: I take it it is an extension of System F?
05:40:50 <Kaidelong> I did take a bit of a look at that
05:40:54 * chrisdone mauls mauke
05:40:54 <ivanm> even then, if you're a researcher (and not doing research into FP itself), none of those answers really suit
05:41:11 <Kaidelong> In which case System FC shouldn't be terribly hard to get a grasp on
05:41:18 <Kaidelong> from what I remember of System F
05:41:36 <ivanm> tibbe: the domains could do with some clarification and maybe even some expansion (math/data analysis is a rather big field...)
05:41:38 <zygoloid> Kaidelong: yes, it's System F + type equality constraints iirc
05:42:08 <tibbe> ivanm, ok
05:42:17 <zygoloid> tibbe: in the list of domains, there should be something for compilers and other programmer tools
05:42:17 <ivanm> tibbe: you may wish to have the "other" option for environments have an edit box or something as well so you can see what other people are using
05:42:33 <tibbe> zygoloid, ok
05:42:36 <ivanm> tibbe: and for some reason, F# seems to be pre-selected as the previous primary language :s
05:42:49 <ivanm> wait, now it's Erlang :s
05:42:58 <zygoloid> tibbe: f# appears to be preselected for two of the questions! :)
05:43:06 <dolio> F_omega, probably.
05:43:06 <ivanm> maybe have an "I didn't do any programming" option
05:43:13 <ivanm> or "I can't remember which language I used"
05:43:26 <tibbe> ivanm, zygoloid, hmm :)
05:43:29 <ivanm> (I for one didn't really do much non-uni programming before learning and starting to use Haskell)
05:43:30 <zygoloid> tibbe: also, if haskell disappeared tomorrow, i actually wouldn't look for a replacement :)
05:43:33 <tibbe> ivanm, I made #3 optional
05:43:40 <tibbe> zygoloid, give up programming?
05:43:47 <Cale> Heh, this apparently exploits a bug in the PDF renderer in Mobile Safari.
05:43:53 <ivanm> tibbe: "what language(s)": sounds like that should be a checkbox question, not a radio button one
05:44:06 <zygoloid> tibbe: nope. i'd continue to use c++ for the projects where i currently use c++
05:44:15 <ivanm> tibbe: that reminds me: how did you get radio buttons? when I tried doing that with google spreadsheets, I couldn't work out how to do it :s
05:44:18 <zygoloid> tibbe: my current haskell project would not make any sense if haskell didn't exist ;-)
05:44:25 <tibbe> ivanm, fixed
05:44:42 <ivanm> tibbe: are multiple weaknesses allowed? how about a strengths option?
05:44:53 <tibbe> ivanm, there's a multichoise option
05:45:07 <ivanm> oh? I thought that was for checkboxes...
05:45:12 <tibbe> I'm modeling this on: http://muckandbrass.com/web/display/~cemerick/2010/06/07/Results+from+the+State+of+Clojure%2C+Summer+2010+Survey
05:45:17 <tibbe> survey for Clojure
05:45:24 <tibbe> Please take another look, I've fixed some things
05:45:27 * ivanm has several areas he'd like fixed, but can never remember what they are
05:45:32 <ivanm> until I run into them again :s
05:45:50 <chrisdone> oh, someone's doing a haskell survey?
05:45:59 <ivanm> tibbe: I would still appreciate being able to do hobby projects + studies for the second question ;-)
05:46:22 <ivanm> tibbe: maybe split that up into two: do you use it for hobby projects, etc. and do you use it for work/studies
05:46:37 <tibbe> ivanm, ok
05:46:39 <tibbe> chrisdone, me
05:46:40 <zygoloid> tibbe: for the 'if haskell disappeared tomorrow' question i guess i should tick no boxes now?
05:46:51 <tibbe> zygoloid, yes
05:46:56 <chrisdone> tibbe: is there a link yet?
05:47:00 <ivanm> zygoloid: but you would never start any new projects?
05:47:05 <zygoloid> f# still seems pre-selected for the previous question :)
05:47:08 <ivanm> chrisdone: he's asking for comments only atm: https://spreadsheets.google.com/viewform?formkey=dGVsZkY1S0R3WUt6aTRaTGJQUVp0MUE6MQ
05:47:24 <ivanm> zygoloid: hmmm, I now have Erlang pre-selected
05:47:25 <zygoloid> ivanm: honestly, the projects i use haskell for now, i couldn't really imagine using another language for ;-)
05:47:26 <chrisdone> ah, sorry, I searched the backscroll
05:47:53 <zygoloid> ivanm: the upshot would probably be that i'd spend more time on the projects for which i don't currently use haskell
05:47:57 <ivanm> tibbe: Maybe default to (and actually have) a "none" option for the previous language question
05:47:59 <chrisdone> wow, google documents supports polls. that's nifty. pity it shows me it in italian *mini-rage*
05:48:21 <ivanm> chrisdone: it's a form put on top of a spreadsheet
05:48:32 <ivanm> how do you categorise an italian "mini-rage"? :p
05:48:32 <chrisdone> that's neat
05:48:49 <zygoloid> tibbe: on the domains list i'd still like something for compilers + programmer tools :)
05:48:49 <ivanm> OK, I have erlang pre-selected for one and F# selected for the other
05:49:04 <ivanm> no, wait, back to F# for both
05:49:10 <tibbe> zygoloid, will add
05:49:21 <tibbe> ivanm, trying to fix the preselect thing
05:49:27 <ivanm> good-o
05:49:52 <ivanm> why are math and data analysis together?
05:50:07 <ivanm> admittedly, data analysis uses maths; but so does a lot of other stuff...
05:50:51 <chrisdone> What language did you use just prior to adopting Haskell – or, if Haskell is not your primary language now, what is that primary language?
05:50:51 <chrisdone> I used Scheme for hobby projects and wasn't employed. ._. so do I answer Scheme?
05:51:20 <ivanm> chrisdone: yeah, the only languages I used before Haskell were those that I needed for uni
05:51:35 <ivanm> I can think of precisely two non-uni projects I worked on briefly before I learnt Haskell
05:51:58 <copumpkin> chrisdone: omg
05:52:09 <Kaidelong> ivanm: you could cheat and list curry
05:52:17 <chrisdone> copumpkin: >_>
05:52:18 <Kaidelong> although perhaps that's not an option
05:52:46 <ivanm> one was a sudoku solver in Java I got to a proof-of-concept stage (after entering data in using "x y v" notation, it could solve it), the other was a simulator for the monty hall problem to prove to students that the math was right
05:52:49 <ivanm> (again in Java)
05:52:51 <danderson> man, what language did I use before haskell
05:52:56 <danderson> it feels so far away
05:53:00 <chrisdone> danderson: Python?
05:53:06 <ivanm> Kaidelong: except I've never learnt curry, let alone used it....
05:53:07 <danderson> oh, yeah, that's probably it
05:53:08 * chrisdone recalls your talk at Zurihac
05:53:27 <danderson> it feels as far away as the step up to C from Visual Basic
05:53:27 <Kaidelong> ivanm: but it's a descendant of haskell I think, so it'd sort of be cheating
05:53:36 <tibbe> danderson, any suggestions on the survey design: https://spreadsheets.google.com/viewform?formkey=dGVsZkY1S0R3WUt6aTRaTGJQUVp0MUE6MQ
05:53:44 <ivanm> I mean, I _could_ list Java as my last previous "primary programming language" since my uni was a Java-shop (at least in IT; in maths and phys it was a matlab-shop)
05:53:47 <Kaidelong> danderson: that's a step up? most of the verbosity of VB is generated for you by the IDE
05:54:03 <ivanm> anyway, I should hit the sack
05:54:03 <Kaidelong> and VB is at a much nicer level of abstraction
05:54:05 <ivanm> g'night all
05:54:07 <danderson> Kaidelong: at the time, it was VB4
05:54:11 <Kaidelong> oh ok
05:54:17 <Kaidelong> VB.NET is very different
05:54:19 <danderson> which wasn't bad per se
05:54:23 <chrisdone> tibbe: possibly a distinction between hobby/professional prior languages?
05:54:24 <danderson> just... basic.
05:54:43 <danderson> I switched to C because I wanted to understand a MUD server that Alan Cox wrote (AberMUD 5)
05:54:52 <tibbe> chrisdone, I'm trying to keep it simple to encourage people to fill it out
05:54:57 <chrisdone> ah, ok
05:55:06 <danderson> once I managed to get the server to boot on linux, going back to windows felt a little silly
05:55:08 <tibbe> chrisdone, want the broad strokes of people's background
05:55:11 <ivanm> tibbe: you going to have an "enter your name" question?
05:55:20 <Kaidelong> tibbe: I'd be willing to take the survey
05:55:24 <tibbe> ivanm, no, anonymous
05:55:28 <ivanm> *nod*
05:55:37 <tibbe> Kaidelong, I'll post it to haskell-cafe, reddit, etc when it's ready
05:55:44 <yitz> tibbe: s/Object C/Objective C/
05:55:50 <tibbe> Are there any major options missing?
05:55:52 <chrisdone> is there a way to verify the data?
05:55:58 <tibbe> yitz, but what if you object to C ;)
05:56:07 <ivanm> I just found it interesting that only about 35% of respondees to my FGL naming survey put a name/email address down for the optional question
05:56:16 <ivanm> tibbe: haskell@
05:56:19 <zygoloid> tibbe: Objective C++ ? ;-)
05:56:23 <danderson> tibbe: I'd split question 2 up
05:56:27 <ivanm> tibbe: and write a blog post to go on planet.haskell
05:56:27 <tibbe> ivanm, sure
05:56:30 <yitz> tibbe: Perhaps add Finance and Embedded to domains
05:56:34 <tibbe> danderson, how?
05:56:38 <ivanm> danderson: I've already suggested that
05:56:40 <tibbe> yitz, good idea
05:56:42 <yitz> tibbe: Objection, your honor
05:56:42 <danderson> it conflates "how comfortable are you with haskell" and "do you use it at home or at work?"
05:56:45 <danderson> imho at least
05:56:50 <ivanm> tibbe: some people may use haskell for hobby stuff _and_ work/study
05:56:52 <Gracenotes> chrisdone: even more fun when there are typeclass parameters involved
05:56:59 <danderson> yeah, what ivanm said
05:57:14 <Gracenotes> on that note, I should scroll down more often. *blame to my irc client*
05:57:23 * Kaidelong wonders if someone could really be comfortable with haskell since it seems to me that there are lots of different ways to do it and lots of interesting libraries for it!
05:57:25 <chrisdone> Gracenotes: haha. that was so 5 minutes ago!
05:57:32 <Gracenotes> the chagrin
05:57:32 * ivanm instead blames Gracenotes for using such a bad IRC client
05:57:33 <ivanm> :p
05:57:37 <yitz> tibbe: oh, also Natural Language Processing
05:57:38 <danderson> and perhaps add a question that probes how expert you believe you are at haskell
05:57:46 <Kaidelong> although that said I haven't found a library that allows logic programming for haskell
05:57:56 <ivanm> danderson: what, scale of 1 to 10 where 10 is oleg/SPJ/etc.? :p
05:58:03 <zygoloid> tibbe: i'd change the second question to checkboxes and remove the last three options (they're logically part of the third question)
05:58:15 <Zao> ivanm: Enter your aptitude in milliOlegs.
05:58:20 <yitz> danderson: years of using Haskell is an approximate measure of that
05:58:30 <ivanm> Zao: heh
05:58:41 <ivanm> Zao: except that only measures type-system hackery, does it not?
05:58:44 <yitz> danderson: I guess it could be made more accurate by adding a "thickness of skull" question
05:58:51 <ivanm> yitz: lol
05:58:56 <danderson> yitz: very approximate though. 2 years of using it at the weekend doesn't match up to 2 years of working at Galois
05:59:05 <yitz> true
05:59:27 <danderson> so, yeah, something like "on a scale of 1 to oleg, rate yourself"
05:59:30 <tibbe> danderson, true
05:59:34 <ivanm> it's also subjective; when I look and compare myself to dons, etc. I feel stupid; however, other people might feel the same way about me (and extra stupid compared to dons :p )
05:59:48 <chrisdone> tibbe: I'd like to know how many people actually start using Haskell after tryinghaskell.org, but :p my google analytics stats says there have been 530 conversions where a conversion is >1 minute on the site, but I'd bet only 1% of those actually go on to use it. anyhoo 
05:59:53 <zygoloid> tibbe: you could change the first question to 8 haskell expressions, and ask "which is the last of these expressions you can easily understand?"
06:00:02 <ivanm> tibbe: if you do, I suggest having a couple of sample "skill levels" indicating what each number represents
06:00:15 <ivanm> that way you're not taking people's subjectivity into account as much
06:00:23 <danderson> right
06:00:24 <ivanm> zygoloid: heh
06:00:25 <tibbe> ivanm, I'm trying to make the results somewhat comparable to the Clojure survey
06:00:30 <zygoloid> chrisdone: i'm afraid two of those were me ;-)
06:00:48 <danderson> one of the early levels should be "I wrote a monad tutorial"
06:00:49 <chrisdone> zygoloid: i bet you were the one that started the infinite loop that crashed it
06:00:52 <ivanm> chrisdone: you bought the tryinghaskell.org domain as well?
06:00:52 <danderson> the "folly of youth" level.
06:01:02 <ivanm> danderson: I never bothered to write a monad tutorial...
06:01:14 <chrisdone> ivanm: nah just the way i phrased it
06:01:15 <Kaidelong> ivanm: better to measure "how many"
06:01:21 <tibbe> Changed question #2 to: tinkering, hobby, studies, work
06:01:35 <Kaidelong> also easily is subjective
06:01:37 <danderson> tibbe: make it multiple choice?
06:01:41 <ivanm> tibbe: maybe a question (multichoice?) indicating how much you're involved with the community: IRC, -cafe, reddit, distro maintainer, packages on hackage, etc.
06:01:55 <chrisdone> oh! that's a good one
06:02:01 <chrisdone> "I've published a package to Hackage"
06:02:04 <ivanm> tibbe: does that cover doing hobby + work?
06:02:13 <ivanm> chrisdone: but do you _maintain_ said package?
06:02:19 <chrisdone> <____<
06:02:19 <Traveler9> .
06:02:34 <Traveler9> How does one peform (x mod n) in GHCi?
06:02:40 <tibbe> ivanm, should be checkboxes
06:02:41 <Traveler9> perform*
06:02:58 <ivanm> e.g. I now maintain 6 packages on hackage (of which I wrote 5); I only consider 3 of them (including FGL) really worth using atm
06:03:07 <ivanm> Traveler9: x `mod` n
06:03:10 <ivanm> or "mod x n"
06:03:14 <ivanm> > 5 `mod` 2
06:03:15 <lambdabot>   1
06:03:19 <ivanm> > mod 5 2
06:03:20 <lambdabot>   1
06:03:29 <ivanm> tibbe: good-o
06:03:54 * ivanm really heads off this time
06:03:58 <ivanm> g'night all (again)
06:04:10 <tibbe> ivanm, gnight, thanks for the input
06:04:19 <ivanm> np
06:04:21 <chrisdone> I learned Haskell [x] through academic education [ ] self-motivated learning
06:04:59 <zygoloid> [ ] osmosis [ ] at work [ ] at gunpoint
06:05:00 <chrisdone> hmm. compared to the clojure survey it looks about right now
06:05:13 <danderson> at work sounds like a big one
06:05:21 <ivanm> chrisdone: "academic education" should probably have "formal" there
06:05:35 <ivanm> I mean, I self-taught myself Haskell in part by using it to work on uni projects...
06:05:50 <ivanm> and maybe "for work" rather than "at work"
06:05:59 <zygoloid> I learned Haskell [ ] as a joke
06:06:10 * ivanm shuts up and quits IRC to stop himself from responding and thus not going to sleep
06:06:32 <danderson> tibbe: so how about that question on the level of involvement?
06:06:37 <h_noob> Question about parsec: how to combine <|> with do-notation? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28507#a28507 - this example will fail to compile because sepEndBy1 is expecting 2 arguments and I don't know how to put it in do and <|>
06:06:38 <ksf_> wtf is up with opengl
06:06:44 <lysgaard> Hi, I have some questions about concurrency in haskell
06:06:47 <Kaidelong> development environment:
06:06:47 <ksf_> not even _that_ seems to get threads right.
06:06:50 <zygoloid> [ ] for a bet [ ] because someone left RWH in the toilet [ ] in order to learn category theory
06:06:58 <Kaidelong> I use Scite/Notepad++
06:07:12 <danderson> [ ] to be able to look down on lesser, impure programmers
06:07:44 <chrisdone> h_noob: (do x; y) <|> (do z; α)
06:07:45 <Traveler9> > 5 'mod' 6
06:07:46 <lambdabot>   <no location info>:
06:07:46 <lambdabot>      lexical error in string/character literal at chara...
06:08:06 <danderson> > 5 `mod` 6
06:08:06 <lambdabot>   5
06:08:07 <copumpkin> [ ] cause it's fucking awesome and I couldn't stop once I got a glimpse of it
06:08:09 <zygoloid> h_noob: which bit of that is problematic?
06:08:25 <danderson> Traveler9: infixing functions needs backquotes, not simple quotes
06:08:26 <chrisdone> h_noob: alternatively do { x; y } <|> do { z; α } might also be possible
06:08:27 <copumpkin> (which is different from self-motivated)
06:08:37 <lysgaard> I've written this DHT algorithms. I's kinda like a p2p program. And like every it needs to do parralell requests etc. The problem is that it needs a shared state. What are the solutions for that in Haskell?
06:08:52 <h_noob> chrisdone: what about vise-versa e. g. do {x <|> y}?
06:08:54 <quicksilver> lysgaard: MVar
06:09:09 <danderson> lysgaard: you could carry an MVar around in a reader monad
06:09:16 <chrisdone> h_noob: that particular expression is fine too
06:09:20 <danderson> that way all threads have access to the shared state when they need it
06:09:24 <zygoloid> h_noob: if you indent the <|> less than the body of the 'do', you should get the (do x) <|> (do y) result
06:09:38 <danderson> (well, all threads operating within that monad)
06:10:13 <lysgaard> Hm. ok, so MVar is the thing. There is no libraries to simplyfy the design?
06:10:21 <chrisdone> MVar is pretty simple
06:10:22 <h_noob> zygoloid: I'm not sure if I got it right but it sounds like it will harm readability
06:10:24 <chrisdone> how simple do you need?
06:10:28 <tibbe> danderson, involvement?
06:10:35 <tibbe> (grabbed a sandwich)
06:11:22 <chrisdone> tibbe: I want your google mug
06:11:22 <chrisdone> tibbe: I think he means whether you contribute packages, use the haskell mailing list, etc
06:11:29 <lysgaard> Not supersimple, I've never done concurrent before with a state you see, so i'm a bit baffeled
06:11:34 <danderson> tibbe: 15:01:17 < ivanm> tibbe: maybe a question (multichoice?) indicating how much you're involved with the  community: IRC, -cafe, reddit, distro maintainer, packages on hackage, etc.
06:11:50 <lysgaard> Would i just forkIO a lot of threads then and they all would read the MVar?
06:12:13 <tibbe> danderson, I see, you think it would be interesting to know?
06:12:15 <lysgaard> Oh, I also need to change the state from all the threads :S
06:12:16 <chrisdone> lysgaard: yeah
06:12:24 <tibbe> danderson, we could probably mine that
06:12:24 <danderson> lysgaard: in the simplest version, the functions you run on the thread all take the "MVar MyState" as an argument
06:12:59 <danderson> when they need to consult it or make changes, they can use helpers like modifyMVar to temporarily gain exclusive access to the shared state
06:13:03 <chrisdone> lysgaard: the MVar is like a reference. it's a pure value you can carry in any thread. if you use putMVar to write to it, then all the other threads, when they use readMVar, will get a different value
06:13:09 <danderson> (see the documentation of Control.Concurrent.MVar for the various functions)
06:13:50 <Kaidelong> lysgaard: obviously you'd only have to use the MVar if the threads have to share information while they are running.
06:14:14 <tibbe> danderson, I'm inclined to run the survey as is
06:14:26 <tibbe> danderson, if no one has a great idea how to restructure it
06:14:26 <chrisdone> if you need to send messages between threads then Channels are pretty nice too
06:14:33 <danderson> tibbe: fair enough, sounds good.
06:15:13 <lysgaard> chrisdone: But what if i do readMVar in thread a to se if a value i need is there. It turns out it issn't so it waits. Later, thread b reads the MVar, does something and writes it. It now contains the value thead a needs. Will thead a automatically see that?
06:15:50 <danderson> lysgaard: yes. readMVar blocks the thread until there is something to extract from the MVar.
06:16:06 * Kaidelong thinks that this sort of "data flow" is what the Reader and Writer monads are for?
06:16:13 <chrisdone> if you need it, you can also use a non-blocking reader
06:16:22 <danderson> in your case, if you want to share mutable state, usually the MVar would be full, with the current copy of the state
06:16:41 <chrisdone> Kaidelong: you only get the writer result at the end of the computation
06:16:52 <danderson> when a thread wants to read, it uses readMVar to get a snapshot copy of the state
06:17:06 <danderson> when it wants to modify it, it uses modifyMVar to atomically change the shared copy
06:17:09 <danderson> does this make sense?
06:17:10 <lysgaard> danderson: well what if thread a can read the MVar, it's just not the right value, how do i then know when another thread changes it so it has the right value?
06:17:24 <Kaidelong> chrisdone: but can't it side effect during the computation?
06:17:28 <chrisdone> you have to keep checking
06:17:29 <danderson> lysgaard: what do you mean by "right value" ?
06:18:00 <danderson> I thought you were trying to share state between threads, but it sounds like you actually want to transmit events between threads
06:18:22 <Kaidelong> well then it'd be IO I suppose
06:18:30 <chrisdone> Kaidelong: you can inspect the current written state but again, at some point you have to communicate between threads. the Writer/T monad is pure
06:19:33 <chrisdone> if you want to communicate between threads, checkout channels in Control.Concurrent.Chan (?)
06:19:37 <chrisdone> @hoogle Chan
06:19:37 <quicksilver> lysgaard: if you have a notion of 'a value that thread A needs' then mayb you want some Chans
06:19:37 <lambdabot> module Control.Concurrent.Chan
06:19:37 <lambdabot> Control.Concurrent.Chan data Chan a
06:19:37 <lambdabot> Control.Concurrent.Chan dupChan :: Chan a -> IO (Chan a)
06:19:39 <lysgaard> Hmm.. Well, all the threads need one shared mutable state, in addition some threads needs to do some sort of event transmitting or alike to eachother
06:19:48 <quicksilver> lysgaard: send the stuff that A needs to it.
06:20:05 <Kaidelong> lysgaard: sounds like MVars to me
06:21:20 <Kaidelong> chrisdone: is MVar nondeterministic?
06:21:34 <lysgaard> Maybe i should write it on paper and draw something to make my problem clear
06:21:50 <Kaidelong> I imagine it must be, but perhaps haskell does something different
06:22:13 <quicksilver> Kaidelong: yes.
06:22:39 * hackagebot AC-Vector 2.1.1 - Efficient geometric vectors and transformations.  http://hackage.haskell.org/package/AC-Vector-2.1.1 (AndrewCoppin)
06:22:45 <quicksilver> Kaidelong: all the thread communication stuff is non-deterministic in a pretty fundamental way.
06:23:00 <quicksilver> of course the challenge is to build deterministic result out of non-deterministic primtiives
06:23:07 <quicksilver> but that's always the challenge with concurrency.
06:25:24 <h_noob> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28507#a28511 - I tried to put <|> inside do-statement but failed type check
06:25:45 <h_noob> any ideas how to do that properly?
06:26:23 <Kaidelong> quicksilver: does this mean you can break referential transparency using MVar? hence why using an MVar puts you in the IO monad?
06:27:03 <Kaidelong> since the time something takes to complete signals something about the implementation
06:29:12 <chrisdone> MVars are definitely not referentially transparent
06:29:45 <chrisdone> two invocations of readMVar is not guaranteed to result in the same value, or behaviour
06:30:25 <Kaidelong> oh right of course
06:31:03 <chrisdone> Kaidelong: but the ST monad is a nice way to do mutability in an enclosed referentially transparent bubble
06:31:17 <chrisdone> :t runST
06:31:18 <lambdabot> forall a. (forall s. ST s a) -> a
06:34:35 <lysgaard> Hi, I've written a better problem discription in this hpaste: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28512#a28512
06:35:30 <ernst> !pastebin
06:36:42 * hackagebot AC-Vector-Fancy 2.1.2 - Fancy type system stuff for AC-Vector  http://hackage.haskell.org/package/AC-Vector-Fancy-2.1.2 (AndrewCoppin)
06:38:42 <CalmNelly> anybody know where i can find a parsec2 tutorial?
06:38:48 <Kaidelong> lysgaard: looks to me like each listRemoteContext would needs its own MVar to swap from and exchange information with the "R" thread?
06:39:20 <Kaidelong> Someone else may know better
06:39:35 <Kaidelong> but that's my first reaction looking at your problem description
06:39:45 <lysgaard> Kaidelong: But how would i get the "R" thread to know of the MVar that the listRemoteContent then makes?
06:40:06 <h_noob> CalmNelly: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html - how about this one?
06:40:21 <Kaidelong> lysgaard: I imagine you'd have to instantiate the other stuff from your "R" thread
06:40:35 <Kaidelong> so that the "R" thread knows about them
06:40:46 <CalmNelly> h_noob: I'll check it out
06:40:53 <lysgaard> Kaidelong: instantiate, what does that mean?
06:41:08 <Kaidelong> errm, bad terminology, I don't know the correct term. Create, run?
06:41:49 <Kaidelong> you could also pass the MVars to your "R" thread using an MVar that stores MVars?
06:41:59 <lysgaard> Kaidelong: Ah, yeah
06:42:01 <lysgaard> Kaidelong: Haha
06:42:38 <lysgaard> Kaidelong: I find it a hard problem to solve
06:43:00 <Traveler9> Okay: Making a square number generator is as simple as "let x = 2 in map (^2) [1..<desired integer>]" ?
06:43:24 <Kaidelong> concurrency supposedly is a hard problem to solve. I remember huge portion of one of the sigplan notices devoted to about 9 different approaches to concurrency in Haskell
06:43:26 <lysgaard> Does there exist any similar concurrent things in haskell, bittorrent?
06:44:17 <lysgaard> Kaidelong: Wow, and I'm only a self thaught high scool student :S
06:44:56 <tibbe> Please take the State of Haskell, 2010 survey: http://blog.johantibell.com/2010/08/state-of-haskell-2010-survey.html
06:46:38 * chrisdone takes the State of Haskell, 2010 survey like never before!
06:47:43 <sfvisser> hello guys, anyone knows how to perform proper regex substitutions in Haskell?
06:47:58 <EvanR-work> regex considered harmful
06:48:15 <sfvisser> Text.Regex.Compat has a subRegex function that seems to skip some unicode chars like the euro sign
06:48:27 <sfvisser> EvanR-work: harmful but useful
06:48:50 <EvanR-work> heh
06:49:29 <plediii> Can someone help me with this novice syntax problem?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28517#a28517
06:49:59 <Valodim> plediii: you got :: there instead of =
06:50:20 <plediii> Valodim: thank you :)
06:55:09 <Traveler9> Wait.. why does every tutorial write in indentations, when there are no indentations? O_O
06:55:54 <chrisdone> it's just a convention to distinguish between code and pros
06:57:18 <Traveler9> I don't see how one isn't going to become confused.
06:57:45 <Traveler9> Writing in indentations where none exist = Misleading. 
06:58:12 <chrisdone> it's usually four spaces
06:58:28 <lysgaard> What would be the best way to learn STM?
06:58:35 <Ke> use it
06:58:43 <Ke> not much to learn there anyways
06:59:04 <ksf> THIS IS INSANITY
06:59:11 <Silvah> anyway*
06:59:13 <mjrosenb> @unpl (\x -> x)
06:59:13 <lambdabot> (\ x -> x)
06:59:29 <mjrosenb> @pl (\x -> x)
06:59:29 <lambdabot> id
06:59:30 <ksf> I obviously can't rely on my perspective transformation being carried out before I draw my models.
06:59:50 <mjrosenb> right, got that backwards
07:00:04 * chrisdone injects ksf with sedatives and pushes him back into his cell
07:00:18 <clive> hello
07:00:34 <mjrosenb> @pl (\x -> liftM (flip(,)x) (runState (foo bar) x))
07:00:34 <lambdabot> ap (fmap . flip (,)) (runState (foo bar))
07:00:35 * EvanR-work knocks out chrisdone from behind and rescues ksf 
07:00:48 * EvanR-work returns to his cell
07:01:00 <mjrosenb> clive: morning
07:01:19 <chrisdone> EvanR-work: chief?
07:01:19 <Silvah> Hehe, "morning".
07:02:35 <ksf> I don't even understand how that's possible in the first place.
07:02:51 <ksf> unless...
07:03:00 <ksf> something messed up my X state
07:03:32 <Traveler9> > 207^40
07:03:33 <lambdabot>   435325210081455054579329070111691676372738961348785547377423970258372212188...
07:03:39 <ksf> X is sometimes a bit dodgy around the corners when you do non-standard stuff
07:03:53 <Traveler9> > 19^19
07:03:54 <lambdabot>   1978419655660313589123979
07:04:14 <Kaidelong> libbe: my contribution is done
07:04:16 <ksf> aren't usually all gears in glxgears completely visible?
07:04:27 <Traveler9> How is it that one defines x as all integers?
07:04:37 <Traveler9> Ex: factorial x?
07:04:44 <Traveler9> Or: square x
07:04:45 <Traveler9> ?
07:06:15 <Kaidelong> Traveler9: what're you asking? What the type would be for a function that works on any integer data type?
07:06:25 <Kaidelong> that'd be (Integral a) => a -> b
07:06:44 <EvanR-work> Traveler9: let x = [0..] in
07:07:29 <copumpkin> EvanR-work: that's just all the naturals :P
07:07:34 <yitz> > let factorial x = product [2..x] in factorial 70
07:07:35 <lambdabot>   119785716699698917960727837216890987364589381425464258575553628646280095827...
07:07:47 <copumpkin> yitz: that's quite an optimization you did there, starting from 2 :P
07:08:11 <EvanR-work> copumpkin: hmm. 0 0 1 -1 2 -2 3 -3... ?
07:08:16 * yitz shines the medals on his lapel
07:08:17 <EvanR-work> tail of
07:08:32 <copumpkin> EvanR-work: yep, just pull in enumerable if you want to enumerate the integers :P
07:09:00 <EvanR-work> is Double enumerable? :)
07:09:06 <copumpkin> yep
07:09:10 <EvanR-work> bah
07:09:16 <copumpkin> hey, it is!
07:09:17 <Kaidelong> > [1..10] :: [Double] 
07:09:18 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
07:09:21 <yitz> EvanR-work: unfortunately. it's a weird instance.
07:09:22 <EvanR-work> is rational?
07:09:26 <copumpkin> EvanR-work: sure
07:09:34 <copumpkin> EvanR-work: it covers ALL values of double :P
07:09:45 * EvanR-work wonders how it does rational
07:09:47 <copumpkin> except for bottom, cause I never got around to doing the bottom stuff
07:09:53 <yitz> > [1%2..10]
07:09:54 <copumpkin> EvanR-work: the correct way :P
07:09:54 <lambdabot>   [1 % 2,3 % 2,5 % 2,7 % 2,9 % 2,11 % 2,13 % 2,15 % 2,17 % 2,19 % 2,21 % 2]
07:10:01 <copumpkin> @hackage enumerable
07:10:02 <lambdabot> http://hackage.haskell.org/package/enumerable
07:10:03 <EvanR-work> CReal? :)
07:10:07 <copumpkin> nope :P
07:10:11 <EvanR-work> shucks
07:10:21 <EvanR-work> are computable reals enumerable
07:10:38 <EvanR-work> in principle
07:11:39 <zygoloid> EvanR-work: if you mean recursively enumerable, then yes, by definition, i think
07:11:52 <EvanR-work> i mean, 1 to 1 with integers
07:12:14 <EvanR-work> ah right, computable function
07:12:20 <EvanR-work> its all based on integers
07:12:48 <EvanR-work> so i expect to see a enumerable instance for creal
07:12:56 <copumpkin> write one :P
07:13:00 * edwardk waves hello.
07:13:00 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
07:13:04 <copumpkin> omg it's edwardk
07:13:13 <yitz> hi edwardk 
07:13:14 <zygoloid> EvanR-work: if a set is RE, you can write a program which generates the first N then stops, so there's a computable, surjective function from naturals to the set.
07:13:26 <edwardk> copumpkin: re hmpfr, its just flat busted these days
07:13:50 <copumpkin> edwardk: oh yeah, I just was wondering about your gmp comment in the repo description
07:14:14 <copumpkin> it doesn't mean integer-gmp (the ghc package) has subtle bugs does it?
07:14:17 <edwardk> copumpkin: well it is broken because mpfr relies on being able to use gmp's internal allocator occasionally
07:14:23 <copumpkin> I see
07:14:26 <edwardk> copumpkin: nah, gmp itself is safe
07:14:33 <edwardk> its stuff like hmpfr that get hosed
07:14:37 <edwardk> er mpfr
07:14:52 <edwardk> sadly i can see no workaround
07:14:52 <copumpkin> doesn't mpfr have its own custom allocation function setters?
07:15:06 <chrisdone> I like that this survey is written in English, my browser only Accepts English, my Google settings, are English, but because I request the page in Italy, you're going to get an Italian interface, and like it!
07:15:14 <dpratt71> I'm interested in trying to create a data-driven web app in Haskell; any advice on what package(s) I should consider?
07:15:20 <edwardk> it does, but it only uses those for the stuff you allocate. when it goes to round or work internally it occasionally needs to allocate new buffers, those use the internal allocators
07:15:30 <edwardk> and ghc then shuffles them around breaking everything
07:15:45 <copumpkin> edwardk: that seems like a bug in mpfr though, if it doesn't respect the custom gmp allocators you set?
07:15:55 <copumpkin> oh
07:16:27 <h_noob> dpratt71: http://jekor.com/article/is-haskell-a-good-choice-for-web-applications - definitely take a look here
07:16:43 <edwardk> copumpkin: nah, its explicitly stated in the docs. the custom allocator api isn't sufficient. it just specifies that for _this_ object here is the memory. behind the scenes it uses the internal custom allocator, which breaks badly because ghc moves the memory
07:16:52 <yitz> dpratt71: there are quite a few options these days. can you tell a little more about what kinds of stuff you'll need?
07:16:58 <edwardk> er two custom allocators
07:17:05 <copumpkin> edwardk: lame :/
07:17:09 <dpratt71> h_noob: checking that out, thanks
07:17:18 <edwardk> there is the 'manual allocation' component which is what is used by hmpfr, and the 'custom allocator' which manages gmp's internal memory set by ghc
07:17:39 <EvanR-work> :t fix
07:17:39 <lambdabot> forall a. (a -> a) -> a
07:17:56 <EvanR-work> is fix wildly unpopular?
07:18:00 <edwardk> you can't make mpfr work with just using their manual allocation api, because it occasionally needs to allocate larger buffers than you gave it for temporaries.
07:18:03 <copumpkin> EvanR-work: nope, I love it
07:18:05 <dpratt71> yitz: I'm pretty flexible; I need data storage and a web application API
07:18:08 <EvanR-work> i know, its awesome
07:18:26 <edwardk> e.g. due to maintaining the correct rounding behavior that gives the API its name
07:18:33 <copumpkin> yeah
07:18:41 <dpratt71> yitz: I'm mostly just looking for the best experience for doing this sort of development using Haskell
07:18:47 <EvanR-work> i have no idea what the type means of course
07:19:03 <edwardk> they apparently fixed a bug a year or two back, w.r.t. rounding, that caused it to have to do more internal memory allocation
07:19:12 <edwardk> that is about when hmpfr went to hell
07:19:15 <copumpkin> EvanR-work: (if you can provide a proof that X implies X, then I can give you a proof of X)
07:19:19 <edwardk> as near as i can tell
07:19:39 <copumpkin> edwardk: so mpfr itself is just making bad assumptions?
07:20:07 <EvanR-work> copumpkin: by encoding a loop with fix, do we reach a stack overflow at some point?
07:20:10 <yitz> dpratt71: here is a list of a bunch of them: http://www.haskell.org/haskellwiki/Applications_and_libraries/Web_programming
07:20:14 <edwardk> mpfr makes sound assumptions w.r.t. a stock gmp. ghc makes kind of bad assumptions that it can safely swap out the allocator for gmp. gmp provides a crappy api for that
07:20:17 <copumpkin> EvanR-work: sure, if it's too strict
07:20:38 <EvanR-work> example?
07:20:46 <copumpkin> > fix id :P
07:20:47 <lambdabot>   Not in scope: data constructor `P'
07:20:48 <edwardk> in the end anything that uses gmp can't be ffi'd from haskell =(
07:20:57 <yitz> dpratt71: do you want a high-level serialization abstraction, or just SQL or JSON or something? Is a static site generator good for you?
07:21:01 <copumpkin> edwardk: that's annoying :/
07:21:14 <EvanR-work> non trivial example?
07:21:35 <copumpkin> EvanR-work: you know how to transform any recursive definition into a fix definition?
07:21:43 <EvanR-work> i suppose
07:21:46 <yitz> @google mpfr
07:21:48 <lambdabot> http://www.mpfr.org/
07:21:48 <lambdabot> Title: The GNU MPFR Library
07:21:59 <copumpkin> well then, pick any recursive function that overflows and encode it in fix :P
07:22:11 <EvanR-work> ok thats basically my question
07:22:50 <copumpkin> > let broken_factorial n = n * broken_factorial (n - 1) in broken_factorial 4
07:22:51 <lambdabot>   *Exception: stack overflow
07:23:13 <copumpkin> > fix (\broken_factorial n -> n * broken_factorial (n - 1)) 4
07:23:14 <lambdabot>   *Exception: stack overflow
07:23:25 <EvanR-work> im using it to generate a semi infinite IO action: http://codepad.org/2QITzuGK
07:23:59 <edwardk> copumpkin: i don't think that is the right way to 'fix' a broken factorial ;)
07:24:02 <edwardk> > fix error
07:24:04 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
07:24:05 <copumpkin> :P
07:24:12 <copumpkin> > fix fail
07:24:14 <lambdabot>   ""
07:24:14 <copumpkin> :)
07:24:23 <EvanR-work> something tells me that 'IO is strict' so im superficially worried ;)
07:24:40 <yitz> > let really_broken_factorial n = length $ permutations [1..n] in really_broken_factorial 10
07:24:40 <zygoloid> EvanR-work: it's the evaluation versus execution thing again
07:24:41 <lambdabot>   3628800
07:24:43 <dpratt71> yitz: thanks for the link; I'm not sure I'm parsing your question correctly, but I like the experience of using ORMs in OO languages; an experience close to that would be ideal; I'm open to 'NoSQL'-style document databases, but that's not my comfort zone
07:24:53 <copumpkin> yitz: at least it returns :P
07:25:20 <yitz> copumpkin: bad name - it's actually less broken that yours :0
07:25:24 <EvanR-work> so the collector will collect old iterations of the loop?
07:25:38 <EvanR-work> as they are executed
07:25:50 <zygoloid> > (getLine >> when True undefined :: IO ()) `seq` ()
07:25:51 <lambdabot>   ()
07:25:59 <copumpkin> EvanR-work: why would you use fix in the first place though? an explicit name there would probably help it
07:26:07 <zygoloid> ^^ EvanR-work: the >> makes it lazy.
07:26:10 <EvanR-work> you mean, would take up space and be ugly ;)
07:26:22 <EvanR-work> 'loop' is the explicit name
07:26:24 <copumpkin> lol ok
07:26:35 <copumpkin> let loop = 
07:26:41 <copumpkin> is shorter than fix (\loop
07:26:45 <EvanR-work> then what
07:26:52 <EvanR-work> in loop
07:26:57 <zygoloid> EvanR-work: there's actually nothing to collect. you're not creating a new IO action each time.
07:26:59 <copumpkin> same thing
07:26:59 <EvanR-work> at the very end
07:27:15 <EvanR-work> you need to start the loop at some point
07:27:17 <dpratt71> the article that h_noob linked states "Unfortunately, Haskell does not yet have a mature way of interfacing with a relational database in a type-safe way" Is this still true?
07:27:21 <zygoloid> EvanR-work: it's like walking "fix (1:)" won't result in a bunch of (:)s and 1s being collected.
07:27:33 <EvanR-work> ah
07:27:53 <EvanR-work> its a cyclic expression with constant values for IORef
07:27:54 <copumpkin> edwardk: working on any awesome projects these days?
07:28:08 <edwardk> copumpkin: did you see the speculation library?
07:28:14 <copumpkin> yeah, that's pretty awesome :)
07:28:16 <EvanR-work> amazing
07:28:31 <edwardk> copumpkin: i worked with conal to update unamb to use the tag-bits stuff
07:28:43 <copumpkin> very neat :)
07:28:47 <zygoloid> EvanR-work: if you ran newIORef inside the action given to fix, those IORefs would be collected each time round
07:28:47 <yitz> dpratt71: ok, well right now the closest to that is still happstack. it's a whole framework with a lot of stuff. it takes a little learning though, and your site is then pretty much locked in to it.
07:28:55 <Kaidelong> :t fix error
07:28:56 <lambdabot> [Char]
07:28:56 <edwardk> copumpkin: my current project is 'finding ddarius an apartment, so he can move here' ;)
07:29:11 <copumpkin> edwardk: oh, he's gonna work with you? or just work in boston?
07:29:11 <Kaidelong> > head . fix $ error
07:29:12 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
07:29:13 <EvanR-work> zygoloid: pretty cool
07:29:18 <edwardk> copumpkin: it is slightly more foundational than my previous work
07:29:19 <yitz> dpratt71:  there is a lot of new good stuff that is ready for use, faster, but not nearly as complete as happstack. such as snap and yesod/wai.
07:29:24 <Kaidelong> > tail . fix $ error
07:29:25 <edwardk> copumpkin: that looks to be the case
07:29:25 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
07:29:32 <EvanR-work> zygoloid: somehow it doesnt seem very lazy or functional
07:29:34 <copumpkin> edwardk: which of the two? :P
07:29:42 <Kaidelong> > head . tail . fix $ error
07:29:43 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
07:29:46 <zygoloid> EvanR-work: ironically it's the laziness which makes this all work :)
07:29:46 <edwardk> copumpkin: coming to work with me
07:29:47 <dpratt71> yitz: I see; thanks for the advices
07:29:48 <yitz> dpratt71: then again, there's always good old cgi and fastcgi :)
07:29:51 <copumpkin> edwardk: that's awesome!
07:30:12 <copumpkin> with any luck I'll be back in boston one of these days so I can meet him and start going to haskell meetups again
07:30:14 <Kaidelong> :t error "foo"
07:30:15 <lambdabot> forall a. a
07:30:21 <aristid> > head . fix $ error
07:30:22 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
07:30:26 <edwardk> now i just need to talk cale into working over at capitaliq ;)
07:30:30 <yitz> dpratt71: join the haskell web devel mailing list. (one second...)
07:30:36 * yitz looks for the link
07:30:40 <copumpkin> edwardk: boston will be the land of haskell!
07:30:42 <zygoloid> EvanR-work: if you grab the latest WIP copy of Hades you can get a textual representation of it </self-pimp>
07:30:49 <EvanR-work> haha
07:30:52 <mije> hi
07:30:57 <Kaidelong> :t error
07:30:58 <lambdabot> forall a. [Char] -> a
07:31:11 <EvanR-work> zygoloid: textual representation of the cycle?
07:31:14 <aristid> :t fix error
07:31:15 <lambdabot> [Char]
07:31:17 <Kaidelong> interesting how fix infers [Char] since a is a free variable
07:31:19 <yitz> dpratt71: http://www.haskell.org/mailman/listinfo/web-devel
07:31:25 <zygoloid> EvanR-work: yeah, of the heap representation of it
07:31:28 <dpratt71> yitz: will do, thanks
07:31:29 <EvanR-work> ah
07:31:33 <aristid> Kaidelong: error is unified with a -> a
07:31:48 <Kaidelong> aristid: how does that work?
07:31:50 * dpratt71 steps away for a few minutes...
07:31:51 <aristid> :t fix
07:31:52 <lambdabot> forall a. (a -> a) -> a
07:31:57 <Kaidelong> oh ok
07:32:10 <copumpkin> edwardk: then we just need to set the private investigators on the mmorrow case and bring him to boston too
07:32:11 <Kaidelong> wait
07:32:13 <EvanR-work> that type is infuriating
07:32:19 <zygoloid> EvanR-work: http://control.monad.st/download-hades if you're interested ;-)
07:32:19 <EvanR-work> because im trying to come up with the actual type of a
07:32:21 <Twey> And if a = [b] then head typechecks
07:32:27 <copumpkin> EvanR-work: it's disallowed in some languages :P
07:32:38 <h_noob> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28507#a28511 - can somebody help me with parsec and <|> inside do? It's seems like I'm missing something pretty obvious in here...
07:32:38 <Kaidelong> @src fix
07:32:39 <lambdabot> fix f = let x = f x in x
07:32:44 <EvanR-work> so what is a in my case?
07:32:56 <aristid> :t let fix f = let x = f x in x in fix
07:32:57 <edwardk> copumpkin: well given the particular selection of Haskellers involved, we wind up more like the terminal object in the category of haskell user groups.
07:32:58 <lambdabot> forall t. (t -> t) -> t
07:33:05 <EvanR-work> IO () ?
07:33:15 <zygoloid> @type when
07:33:16 <copumpkin> :)
07:33:16 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:33:20 <lysgaard> What would the difference between the State Monad and a MVar in the reader Monad be?
07:33:21 <zygoloid> EvanR-work: right. :)
07:33:24 <EvanR-work> insane
07:33:30 <EvanR-work> insane!!!
07:33:32 <EvanR-work> brain explode
07:33:59 <aristid> EvanR-work: damn now we have to clean up your exploded brain :(
07:34:03 <yitz> h_noob: looks cool. where's the problem?
07:34:15 <EvanR-work> yall do that on a daily basis in here anyway
07:34:30 <copumpkin> edwardk: meanwhile I'm making myself useful by proving stuff about a repa-alike in agda :P and permutations, for fun
07:34:41 <h_noob> yitz: in a <- pikeJunk <|> (sepEndBy1 words (char ','))  -- this will not compile
07:34:52 <h_noob> just like previous variant as well
07:35:05 <yitz> edwardk: the problem is that that category has no direct limits
07:35:42 <zygoloid> actually... does anyone have any comments on the formatting / style / content of my new haskell blog: http://control.monad.st/ ?
07:35:55 <Kaidelong> so what's the rule that allows you to turn Foo -> a into Foo -> Foo?
07:35:55 <copumpkin> zygoloid: capitalize it right :P
07:36:01 <EvanR-work> zygoloid: ill have to look at hades when im not at work ;)
07:36:01 <Kaidelong> universal instantiation?
07:36:09 <copumpkin> zygoloid: but that's a great domain name :P
07:36:10 <edwardk> yitz: well, i figure it becomes the terminal object if we kill all the people that try to leave.. a hitman will catch up with copumpkin eventually and restore us to our terminal state.
07:36:12 <yitz> @hoogle sepEndBy1
07:36:12 <lambdabot> Text.Parsec.Combinator sepEndBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
07:36:12 <lambdabot> Text.ParserCombinators.Parsec.Combinator sepEndBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
07:36:18 <alexsuraci> h_noob: adding type signatures would probably make it easier to debug
07:36:26 <Kaidelong> > fix id $ 5
07:36:30 <lambdabot>   mueval-core: Time limit exceeded
07:36:32 <zygoloid> copumpkin: ok. http://Control.Monad.ST
07:36:37 <copumpkin> edwardk: lol :P can't you just wait until I move back there? I really don't intend to stay in italy that long :P
07:36:45 <zygoloid> copumpkin: ok, that looks weird ;-)
07:36:58 <copumpkin> edwardk: also, not sure I'd put myself in the same category as cale, you, and ddarius :P
07:37:06 <Kaidelong> > fix (const 5) $ 5
07:37:07 <edwardk> copumpkin: but then we'd have to deal with being isomorphic to rome.
07:37:07 <lambdabot>   5
07:37:20 <jmcarthur> boston seems to be the place to be
07:37:29 <h_noob> alexsuraci: the problem is that I do not understand which signature I should put actually :)
07:37:34 <copumpkin> oh and jmcarthur and maybe even kmc
07:37:44 <copumpkin> boston would be by far the coolest place on earth then
07:38:03 <yitz> edwardk: the nice thing is that you don't need a whiteboard on location, because the diagrams all commute.
07:38:04 <jmcarthur> :D
07:38:11 <copumpkin> maybe I'll get a job as a janitor in MGH
07:38:12 * hackagebot haskell-src-exts-qq 0.3.0 - A quasiquoter for haskell-src-exts.  http://hackage.haskell.org/package/haskell-src-exts-qq-0.3.0 (MathieuBoespflug)
07:38:12 <alexsuraci> h_noob: all of them :P but it looks like pikeJunk returns one value, but sepEndBy returns a list of them, so the types wouldn't check there
07:38:15 * Kaidelong wonders why fix id doesn't terminate
07:38:23 <Kaidelong> seeing as fix id == id
07:38:29 <copumpkin> Kaidelong: no it isn't
07:38:35 <copumpkin> @src fix
07:38:35 <zygoloid> Kaidelong: fix id /= id. fix id :: a, id :: a -> a
07:38:36 <lambdabot> fix f = let x = f x in x
07:38:36 <Kaidelong> it isn't?
07:38:37 <EvanR-work> fix id! why are you doing that!
07:38:46 <jmcarthur> copumpkin: you can be in the same category as me
07:38:47 <zygoloid> EvanR-work: maybe id is broken?
07:38:48 <copumpkin> fix id = let x = id x in x
07:38:53 <copumpkin> jmcarthur: yay thank you
07:39:01 <jmcarthur> not sure what directions our arrows should point though
07:39:06 <Kaidelong> EvanR-work: I was wondering if it would terminate
07:39:06 <alexsuraci> h_noob: it's generally good form to always have type signatures accompanying toplevel definitions, it's a bit of a sanity check
07:39:07 <copumpkin> lol
07:39:17 <copumpkin> we can be adjoint to theirs
07:39:23 <EvanR-work> Kaidelong: i know, its just blowing my brain ;)
07:39:33 <copumpkin> well, our functors
07:39:34 <yitz> h_noob: words is not a Parsec parser
07:39:43 * copumpkin doesn't want to take the analogy very far :P
07:39:47 <edwardk> yitz: currently all of the diagrams have a 30 minute commute or so upstate ;)
07:39:54 <jmcarthur> heh
07:40:02 <Kaidelong> still, x = id x means x = x
07:40:07 <EvanR-work> Kaidelong: you can manually evaluate the expression...
07:40:15 <copumpkin> Kaidelong: yeah, and let x = x in x is nontermination
07:40:16 <EvanR-work> @src id
07:40:16 <lambdabot> id x = x
07:40:22 <copumpkin> Kaidelong: it's an infinitely recursing definition
07:40:31 <copumpkin> > let x = x in x
07:40:35 <lambdabot>   mueval-core: Time limit exceeded
07:40:39 <EvanR-work> @src fix
07:40:39 <lambdabot> fix f = let x = f x in x
07:40:47 <copumpkin> in fact, in some versions of ghc, you can't even ctrl+c out of that
07:41:13 <EvanR-work> fix id => let x = id x in x => id (id (id (
07:41:13 <Kaidelong> oh so it's a bit like doing x :- x in prolog
07:41:36 <copumpkin> Kaidelong: yeah, or just write f = f at the top level in haskell and try calling it :P
07:41:39 <copumpkin> or even look at its type
07:41:42 <h_noob> yitz: oops... but how so - should I use it as (many1 letters) or something else?
07:41:45 <copumpkin> a type like that should set off some warning bells
07:41:49 <Kaidelong> :t a = a
07:41:50 <lambdabot> parse error on input `='
07:41:56 <copumpkin> :t let a = a in a
07:41:57 <Kaidelong> :t let a = a in a
07:41:58 <lambdabot> forall t. t
07:41:58 <lambdabot> forall t. t
07:42:01 <alexsuraci> h_noob: try "identifier"
07:42:08 <Kaidelong> > let a = a in a
07:42:11 <lambdabot>   mueval-core: Time limit exceeded
07:42:18 <EvanR-work> let x = x in x is one thing, but isnt id (id (id (id structurally different
07:42:18 <copumpkin> Kaidelong: only one value of that type, and it's not one you want :P
07:42:30 <yitz> h_noob: yeah something like that
07:42:44 <copumpkin> brb
07:42:57 <dolio> id x = x, so 'let x = id x ...' is the same as 'let x = x ...'
07:43:11 <EvanR-work> ah
07:43:18 <yitz> h_noob: another problem - in "pikeArrEntry = pikeJunk <|> pikeArrContent", pikeArrContent is a function that needs an argument to return a parser.
07:43:30 <h_noob> alexsuraci: "not in scope" error - probably not part of parsec either
07:43:47 <edwardk> copumpkin: Wed Dec 16 21:27:12 UTC 2009  	MattMorrow	  dom-lt-0.1.0 -- he lives!!
07:43:52 <Kaidelong> EvanR-work: well, with a cleverer fixed point implementation on a pure function, you'd stop when you hit a fixed point
07:44:00 <edwardk> oh wait
07:44:04 <edwardk> hah, last year
07:44:05 <Kaidelong> which in the case of id would be immediately
07:44:08 <edwardk> was looking on sparky ;)
07:44:25 <alexsuraci> h_noob: ah, yeah, sorry, that assumes you're using TokenParser, etc. probably overkill. ignore me. :P
07:44:32 <EvanR-work> Kaidelong: that actually happens
07:44:35 <h_noob> yitz: that's why I tried to use pikeJunk <|> (sepEndBy1 words (char ','))  in later revision
07:44:43 <EvanR-work> Kaidelong: if you compile with ghc
07:44:43 <yitz> ah, right
07:44:57 <EvanR-work> you get the <loop> exception
07:46:18 <Kaidelong> if f(x) = x then f . f = f = id, basically
07:46:36 <EvanR-work> > id . id == id
07:46:37 <lambdabot>   *Exception: (==): No overloading for function
07:46:49 <copumpkin> edwardk: aww :(
07:46:52 <Kaidelong> You can't compare or show functions
07:47:02 <EvanR-work> i know that!
07:47:27 <EvanR-work> i was just kidding
07:47:33 <Kaidelong> ok =p
07:47:43 <copumpkin> edwardk: it's a pity cause all his repos are offline too now
07:47:54 <copumpkin> so all the code that he hadn't gotten around to releasing on hackage is gone
07:47:55 <dolio> That's a weird error...
07:47:59 <edwardk> copumpkin: =(
07:48:16 <dolio> Is that from some bogus Eq instance in something lambdabot imports?
07:48:20 <peterNovice> Is there any way to have type constructors that act like value constructors? e.g. "Mat (Int,Int) t" where "::Mat (1,1) Double" typechecks differently from "Mat (1,2) Double". Where the types can include values.
07:48:39 <Kaidelong> > fix (^2) 1
07:48:40 <lambdabot>   *Exception: stack overflow
07:48:42 <copumpkin> peterNovice: #agda
07:48:48 <Kaidelong> ...
07:48:50 <dolio> > snd (id == id, 5)
07:48:51 <copumpkin> peterNovice: or clunky type-level naturals
07:48:51 <lambdabot>   5
07:49:46 <Kaidelong> well ok
07:49:57 <copumpkin> peterNovice: here's something I started writing yesterday that illustrates the clunky type-level naturals, if you want: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28464
07:49:59 <Kaidelong> fix works on stuff that doesn't work with comparables
07:51:37 <EvanR-work> yeah it takes a function
07:52:22 <peterNovice> copumpkin: ok I will look and see if it is what I had in mind. Thanks
07:53:01 <Kaidelong> EvanR-work: I suppose, at least in a pure language, it might be worthwhile to make everything comparable in some way. OCaml might actually have done something like that, and it's not pure? I forgot
07:53:30 <Kaidelong> Java and CLR stuff can compare references, but that's not really the same as comparing structures or values
07:53:58 <EvanR-work> ocaml has an operation for comparing pointers
07:54:03 <Paczesiowa> @seen bos
07:54:03 <preflex>  bos was last seen on #haskell 9 days, 15 hours, 30 minutes and 9 seconds ago, saying: @src showString
07:54:04 <lambdabot> Unknown command, try @list
07:54:20 <copumpkin> peterNovice: I'm actually working on something like that in agda right now :P not sure if you've come across repa
07:54:55 <Kaidelong> EvanR-work: didn't it also have some kind of recursive structural comparison where it works down toward elements of a data structure and checks that everything is the same?
07:55:07 <Kaidelong> so a bit like Haskell's "deriving Eq"
07:55:32 <Kaidelong> but implicit for all types, or something
07:56:33 <Kaidelong> comparing references would make sense for mutable values anyway since you only know that two things will always be the same if they are literally the same thing in the same place
07:56:37 <ksf> and haskell has StableName
07:56:51 <peterNovice> copumpkin: is your way  Z , S (Z) , S ( S Z) etc ? Not explicit integers? 
07:56:52 <EvanR-work> it doesnt compare functions by value
07:56:58 <EvanR-work> thats like... the halting problem or something
07:57:12 <Kaidelong> EvanR-work: it wouldn't have to to implement fix
07:57:14 <EvanR-work> actually ocaml errors if you try to compare functions, i think
07:57:21 <Kaidelong> because everything would be equatable
07:57:24 <copumpkin> peterNovice: yeah, integer literals would be nice but we don't have support for them in haskell yet. This gives the same end result, but is more cumbersome to write. 
07:57:30 <Kaidelong> so it is simple to check if a function has reached a fixed point
07:57:32 <EvanR-work> why are we talking about comparisons if were interested in fix
07:57:36 <copumpkin> peterNovice: especially when there's an ugly special case for the type-level integer literal 1
07:57:42 <EvanR-work> Kaidelong: ah, no thats a ghc trick
07:57:54 <EvanR-work> you cant programmatically tell if a program will loop forever
07:58:01 <Kaidelong> > fix (^2) 1
07:58:02 <lambdabot>   *Exception: stack overflow
07:58:16 <ksf> but you can error out while running it and you see that it isn't productive, at all.
07:58:17 <copumpkin> EvanR-work: unless you artificially disallow some constructs in the language :)
07:58:32 <copumpkin> EvanR-work: which would stop it from being turing-complete, but who cares :P
07:58:39 <EvanR-work> its not TC anyway!
07:58:41 <Kaidelong> > let smartfix f x = let y = f x in if y == x then x else smartfix f y in smartfix (^2) 1
07:58:42 <lambdabot>   1
07:58:44 <EvanR-work> i only have 4G of ram
07:58:49 <ksf> that's always plain thunk -> thunk dependencies. throwing arithmetic or something into the mix breaks the whole thing.
07:59:11 <Kaidelong> EvanR-work: if everything is comparable, then the above would work
07:59:22 <Kaidelong> as your general implementation of fix
07:59:44 <EvanR-work> you cant compare functions by value
07:59:56 <ksf> you can compare them by AST
08:00:09 <EvanR-work> but thats not equality
08:00:14 <ksf> ...well, or by graph, rather.
08:00:16 <Kaidelong> you could also take the approach of something like ACL2 and prove that they are the same
08:00:21 <ksf> it's _one_ equality.
08:00:31 <EvanR-work> Kaidelong: its undecidable ;)
08:00:31 <ksf> one that happens to be sensible, because it's actually decidable.
08:00:47 <Kaidelong> EvanR-work: it's undecidable in general
08:00:58 <Kaidelong> which is a bit different in implication from undecidable
08:01:03 <EvanR-work> i thought we were talking about general
08:01:03 <alios> how can I make cabal-install to use a different directory then /tmp during building packags (quota problems on remote server)
08:01:18 <Kaidelong> ACL2 will try to stop you from writing a program that doesn't terminate
08:01:24 <EvanR-work> otherwise ghc already detects some loops
08:01:27 <Kaidelong> that means either you can't write any program you like in it
08:01:38 <Kaidelong> or that you have to disable it to make it turing complete
08:01:41 <ksf> or you have a proof obligation
08:01:58 <EvanR-work> Kaidelong: right
08:02:08 <EvanR-work> but i like infinite loops
08:02:09 <ksf> ...I don't think haskell will ever be total by default. possibly as a switch.
08:02:21 <Kaidelong> but turing-completeness is a dumb thing to really go for anyway
08:02:28 <Kaidelong> as an objective in and of itself
08:02:35 <ksf> otoh, it all depends on how much depentently typed languages can infer automatically.
08:02:37 <EvanR-work> you cant really prove the user will eventually press 'quit game'
08:03:00 <EvanR-work> and ideally they play forever ;)
08:03:08 <ksf> that's still total.
08:03:11 <Kaidelong> EvanR-work: you could prove that the game will always terminate when they do press it, hopefully
08:03:12 <ksf> as in productive.
08:03:40 <ksf> ...bounded amount of work for bounded amount input. if the input doesn't stop it's not the programs fault that it doesn't terminate.
08:04:02 <alios> ok .. solved it .. TMPDIR env variable
08:04:15 <benc___> ksf: isn't that codata?
08:04:30 <ksf> yep
08:06:05 <applicative> alios, theres "cabal install pony --builddir=~/wherever "
08:06:12 <Kaidelong> EvanR-work: anyway, in the case of fix, the inability to perfectly compare stuff like functions or mutable reference cells would just translate into fix not terminating
08:06:29 <EvanR-work> is it really that bad?
08:06:31 <Kaidelong> which is the behavior it would show anyway if you gave it a function without a fixed point
08:06:36 <ksf> applicative, he's gone.
08:07:00 <Kaidelong> EvanR-work: it's just a bit surprising since it seems like such a simple improvement. But it seems to be deeply tied to Eq not being implicit in haskell
08:07:19 <EvanR-work> pointer comparisons arent that useful generally
08:07:27 <EvanR-work> haskell is supposed to be higher level
08:07:29 <Kaidelong> EvanR-work: but they're more useful than nothing
08:07:44 <EvanR-work> maybe if you want to write a c program!
08:07:47 <ksf> reify-graph makes good use of them.
08:07:48 <EvanR-work> (or ocaml)
08:07:51 <Kaidelong> and unlike structural comparison it'll never say two things are the same when they aren't
08:08:11 <Kaidelong> but you could recursively introduce pointer comparison into structural comparison
08:08:14 <Kaidelong> to eliminate that problem
08:08:18 <Kaidelong> which is what OCaml does IIRC
08:08:29 <EvanR-work> ocaml cant compare functions
08:08:34 <h_noob> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28507#a28518 - I cleaned my example but I still don't understand why I get "No instance for" error and why I get type mismatch for many1 in one place and not in another... can you take a glance?
08:09:02 <Kaidelong> I suppose that's true, so you still end up with something like umm
08:09:12 <ksf> h_noob, paste the errors too, please.
08:09:17 <Kaidelong> fix fix fix
08:09:20 <Kaidelong> not terminating
08:09:28 <Kaidelong> but what where you expecting?
08:10:19 <EvanR-work> eh? you were the one expecting stuff
08:10:28 <Paczesiowa> how can I tell cabal to build a package against specific library (e.g. parsec-2.1.1.0) ?
08:11:03 <ksf> great. hpaste is down.
08:11:16 <Kaidelong> EvanR-work: basically what you would do would be unless you find a match with pointer comparision, f == g is false, even if the two functions do the same thing?
08:11:25 <Kaidelong> not very elegant
08:11:50 <Kaidelong> but unless you have some full on proof system built into the language and you enforce its use, then you're not going to do better
08:12:00 <EvanR-work> what do you want to do throw an exception if fix sees two of the same function?
08:12:06 <ksf> Paczesiowa, --constraint="parsec == 2.1.1.0"
08:12:08 <h_noob> ksf: http://pastebin.org/441479 - here it is
08:12:15 <EvanR-work> i dont understand your gripe
08:12:19 <Kaidelong> no, fix should terminate on a fixed point and not terminate otherwise
08:12:25 <Paczesiowa> ksf: thx
08:12:39 <Kaidelong> in a language where everything is comparable, at least in some way, it'll catch some fixed points
08:12:39 <EvanR-work> but i dont want to terminate on a fixed point
08:13:02 <Kaidelong> err, so long as it is also pure
08:13:11 <EvanR-work> but my loop is pure
08:13:29 <EvanR-work> http://codepad.org/2QITzuGK
08:13:40 <ksf> h_noob, can you paste the source, again, too? 
08:13:47 <EvanR-work> gotta work now
08:14:36 <Kaidelong> EvanR-work: if you have a fixed point then making another iteration would be pointless. And that loop has IO in it.
08:15:12 <Kaidelong> it reads from the outside world
08:16:27 <Kaidelong> oh wait no I get it now. Pointer comparison would make things look like things are fixed
08:16:30 <h_noob> ksf: http://pastebin.org/441487 - here they are
08:16:45 <EvanR-work> Kaidelong: its not fix that does that though
08:16:54 <EvanR-work> fix just generates an infinite string of IO actions
08:17:19 <adregorochapimen> hey
08:17:20 <mije> my life expectancy is dropping since i try to wrap my head around haskell type system
08:17:25 <EvanR-work> lol
08:17:42 <sanders> just curious is anyone working on updating the design of haskell.org?
08:17:51 <adregorochapimen> i have a question, why is usefull learn Haskell? what is the principle use of Haskell?
08:18:03 <mije> adregorochapimen: hmm write applications ?
08:18:03 <EvanR-work> to become awesome
08:18:09 <Zao> adregorochapimen: Getting stuff done.
08:18:19 <Zao> adregorochapimen: Or looking busy while not getting stuff done.
08:18:20 <adregorochapimen> what kind of stuff?
08:18:30 <mije> or to make his life expectancy drop.
08:18:41 <sanders> adregorochapimen: it will change your point of view on programming
08:18:48 <ksf> h_noob, what type do you expect pikeJunk to have?
08:19:04 <adregorochapimen> what are the principle advantage of using Haskell instead of Python in a High Level Application?
08:19:13 <ksf> according to the way you use it with many1, it has to be Parser String
08:19:22 <mije> adregorochapimen: you can learn haskell in order to make learning scala less difficult :)
08:19:48 <sanders> adregorochapimen: type safety is one key advantage
08:19:49 <ksf> ...but sepWordsBy is Parser [String]
08:19:55 <Zao> mije: That sounds like a step backwards :D
08:19:55 <ksf> ...which doesn't unify.
08:20:03 <adregorochapimen> i just want to learn new stuff, but usefull stuff
08:20:09 <Kaidelong> adregorochapimen: I primarily use Haskell to prototype stuff I later write in Java
08:20:18 <dv_> quite a gap.
08:20:19 <h_noob> ksf: it should be Parser [String] I think
08:20:23 <mije> Zao: sometime you have to learn the right thing in order to make it bad
08:20:32 <Zao> adregorochapimen: Learning a decent language gives perspective to things.
08:20:38 <Kaidelong> it is useful because it is much faster to write the code in Haskell, and the Haskell lets you sort out conceptual trouble before you commit to coding stuff in Java
08:20:42 <ksf> more specifically, you can't have recursive data types like that (calling pikeJunk recursively again and again would result in [String], [[String]], etc)
08:20:42 <dv_> Kaidelong: talk about contrasts :)
08:21:00 <h_noob> ksf: how should I use many1 to get Parser [String] instead of Parser String?
08:21:03 <ksf> h_noob, you should define a recursive data type for your stuff
08:21:04 <EvanR-work> adregorochapimen: youre gonna learn such useful stuff that youll hate your life when you go back to normal languages ;)
08:21:19 <mije> EvanR-work: i agree with that.
08:21:26 <adregorochapimen> lool
08:21:28 <ksf> fmap (:[]) (many1 (noneOf "\n"))
08:21:30 <sanders> adregorochapimen: with the right mind set and a willingness to learn Haskell can be an extremely useful language, one can develop very rapidly in Haskell and in the end you'll probably have a better (easier to maintain) application then you might with python or other languages
08:21:40 <EvanR-work> and if you try to do things right (tm) in those languages your coworkers will hate you
08:21:45 <EvanR-work> or ridicule you
08:21:53 <mije> i'm a lousy haskell programmer but now i can say to a java programmer "Ha ! your code is sooooo dirty"
08:21:57 <h_noob> ksf: how is recursive data type will help in this case?
08:22:19 <Kaidelong> adregorochapimen: I also use enjoy Haskell's data structures when writing programs that translate from one format of data representation to another
08:22:31 <ksf> it doesnt' only help, it's the only way to do what you want.
08:22:37 <mije> adregorochapimen: haskell is fun
08:22:39 <Kaidelong> F# is perfectly good at that, but I find haskell to be better at the specification part
08:22:47 <Zao> I ended up implementing my CDT in C++ instead of Haskell.
08:23:03 <ksf> data Junk = Arr Just | Map Junk
08:23:04 <Kaidelong> also lazy evaluation can very nice
08:23:07 <Zao> Couldn't conjure up a nice mutable data structure for my mesh.
08:23:11 <ksf> s/Just/Junk
08:23:20 <EvanR-work> lazy is awesome!
08:23:50 <ksf> ...you can't nest lists like you're trying right now. Haskell doesn't do infinite types (for good reason)
08:23:58 <applicative> adregorochapimen, what sort of thing to you think of as 
08:24:04 <applicative> useful at the moment
08:24:29 <h_noob> ksf: can you post a bit lengthier example somewhere? I don't really get the idea oh how to make Parser with that :(
08:24:51 <adregorochapimen> applicative, usefull like app, or like concepts?
08:24:56 <Kaidelong> adregorochapimen: for personal projects, I recommend you use Haskell. It has its flaws, for example...
08:25:04 <Kaidelong> > sum [1..100000]
08:25:05 <lambdabot>   5000050000
08:25:08 <Kaidelong> > sum [1..100000000]
08:25:18 <lambdabot>   mueval: ExitFailure 1
08:25:20 <ksf> h_noob, forget about parsing for a second and write the data in haskell syntax.
08:25:32 <adregorochapimen> Kaidelong, but for sys scripts sucks
08:25:41 <EvanR-work> > foldl' (+) [1..1000000000]
08:25:45 <lambdabot>   mueval-core: Time limit exceeded
08:25:49 <Kaidelong> adregorochapimen: I'll disagree on that one.
08:25:56 <EvanR-work> > foldl' (+) [1..100000000]
08:25:57 <ksf> you can write things like ["a","b","c"], but you can't write [["a"],"b","c"]
08:25:57 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
08:25:58 <lambdabot>    arising from a us...
08:26:01 <applicative> adregorochapimen, yeah, like useful apps, what sort of app would count as useful for you at the moment.  Just trying to figure out where you're coming from.
08:26:09 <EvanR-work> crashed lambdabot
08:26:17 <Kaidelong> > foldl1' [1..10000000000]
08:26:18 <lambdabot>   Couldn't match expected type `a -> a -> a'
08:26:18 <lambdabot>         against inferred type `[...
08:26:22 <Kaidelong> > foldl1' (+) [1..10000000000]
08:26:24 <Paczesiowa> how should I go about benchmarking different versions of parsec for pandoc? using that "--contraint parsec == 2.1.0.1" cabal complains that pandoc depends indirectly on different versions of parsec
08:26:26 <lambdabot>   mueval-core: Time limit exceeded
08:26:30 <Kaidelong> > foldl1' (+) [1..100000000]
08:26:34 <lambdabot>   mueval-core: Time limit exceeded
08:26:41 <Kaidelong> ah well
08:27:04 <Kaidelong> hope that it is as least lg(n) in memory as opposed to n + lg(n)
08:27:05 <EvanR-work> > let l = [1..10000000] :: [Int] in foldl' (+) l
08:27:06 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
08:27:06 <lambdabot>    arising from a use of `GHC...
08:27:17 <applicative> Paczesiowa, shouldn't you hack the cabal file?  It supposed to build with both but default to parsec-3
08:27:20 <h_noob> ksf: the thing is - I'm working with kinda .ini file so it's context-sensitive e. g. many1 section each might contain key=value pairs and nested arrays and maps... how to express this as a data type?
08:27:27 <adregorochapimen> applicative, my future(like some years) i want to develop systems apps, and help on OS development,and right now i just want to learn as much as i can, mu background is only in C, i am a newbie yet
08:27:29 <applicative> or rather default to parsec-2
08:27:35 <EvanR-work> Kaidelong: anyway, it would be faster compiled, and 1000000000 is bigger than most machine-based ints can handle
08:27:37 <ksf> h_noob, http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
08:27:46 <Kaidelong> EvanR-work: you keep trying to use foldl' without enough arguments
08:27:55 <ksf> have a look at the LispVal type.
08:28:09 <Kaidelong> > foldl' (+) 0 [1..10]
08:28:10 <lambdabot>   55
08:28:20 <Kaidelong> > foldl1' (+) [1..10]
08:28:21 <lambdabot>   55
08:28:22 <Paczesiowa> applicative: but cabal complains that other libraries (HTTP, network) depend on parsec 3 (they are system-wide ), and it could result in errors
08:28:54 <Paczesiowa> applicative: should I prune all parsecs from my system, then use one version for everything?
08:29:06 <h_noob> ksf: thanks I'll take a look
08:29:37 <applicative> Paczesiowa, hmm, studying.  
08:30:00 <mije> by the way, does anybody use haskell for real world stuff ?
08:30:20 <unlink> yes
08:30:22 <applicative> Paczesiowa, I take it you saw the back and forth with ivanm the other day on the list.
08:30:57 <siracusa> mije: See http://www.haskell.org/haskellwiki/Haskell_in_industry
08:31:46 <mije> thanks
08:32:04 <yitz> Paczesiowa: for profiling, build pandoc by hand, on the ghc command line you can expose whatever version you want
08:32:10 <EvanR-work> mije: well i wrote part of your email subsystem in haskell
08:32:17 <EvanR-work> not your
08:32:18 <EvanR-work> our
08:32:41 <applicative> I see, he does suggest --constrain=... should work, hmm.  http://groups.google.com/group/pandoc-discuss/browse_thread/thread/55c3b3a3b6191dc4
08:33:44 <mije> i'm working in the it industry, i wish there were examples of web applications or stuff interfaced with flex and databases that are done in haskell
08:34:08 <ksf> h_noob, btw: http://hackage.haskell.org/package/ConfigFile
08:35:00 <jmcarthur> mije: like http://snapframework.com ?
08:35:31 <jmcarthur> oh you mean things using libraries like that, not just the libraries themselves
08:35:42 <jmcarthur> i think patch-tag is running on happstack
08:35:53 <EvanR-work> mije: i would show you our db stuff but id have to kill you ;)
08:35:55 <jmcarthur> i don't know many examples off the top of my head though
08:36:07 <mije> jmcarthur: yep but with references for big projects
08:36:29 <EvanR-work> snap looks pretty bad-ass
08:36:40 <EvanR-work> if i thought webframeworks were cool
08:36:46 <h_noob> ksf: it looks like file format is way simpler than what I need but source code might be good example to study, thanks
08:37:13 <mije> i have to make a poc of a basic web application in haskell in order to show where the Truth lies to my managers
08:37:30 <mije> i'll give snap a try
08:38:38 <EvanR-work> someone should make a haskell propaganda pamphlet so people like mije can convince managers
08:39:04 <EvanR-work> on the other hand maybe people should get more experienced with the tools first or else it might turn into php
08:39:54 <Phyx->  hm, that's odd.... in ghci i get a type Integral a => a... but with the api i get Integral a => [a]...
08:40:18 <mije> EvanR-work: yep, that would help
08:40:54 <EvanR-work> mije: something similar but not in pamphlet form can be found on the haskell main page
08:41:35 <mije> http://haskell.org/haskellwiki/Introduction ?
08:42:24 <Paczesiowa> applicative: no, I haven't seen anything with ivanm
08:42:28 <EvanR-work> i was thinking of something else but thats good
08:42:35 <EvanR-work> wtf is with the logo on haskell.org >_<
08:43:00 <mije> EvanR-work: yeah for me it's ok, but managers want to know if they'll make money with it
08:43:34 <EvanR-work> id say not if youre experienced with functional programming
08:43:37 <EvanR-work> not if youre not
08:43:42 <mije> i agree
08:44:40 <Phyx-> that page needs an update though
08:44:43 <mije> but for example programming with referential transparency, i.e. where everything is testable is a good argument
08:44:56 <Phyx-> Is HaskellDirect even still maintained? not to mention Green Card
08:45:03 <mije> the performances of haskell vs java as well
08:45:35 <mije> if there is a mature web or SQL mapping framework would kick ass
08:45:40 <mije> +it
08:46:28 <jmcarthur> well there's always the usual database adapters, my current favorite of which is takusen
08:47:20 <EvanR-work> bah@ sql mapping
08:47:33 <EvanR-work> sane queries is a lost art
08:48:01 <EvanR-work> make abstractions that you deep to be useful
08:48:07 <EvanR-work> deem
08:48:46 * Kaidelong baffled at this, apparently some python guy told adregorochapimen that perl doesn't have "full OO"
08:49:08 <EvanR-work> even more baffling what does that have to do with haskell
08:49:22 <Kaidelong> he was wanting to choose between Python and Haskell
08:49:36 <EvanR-work> you said perl
08:49:51 <monochrom> haskell has full no-OO. perl doesn't have full no-OO :)
08:50:21 <Kaidelong> I told him Haskell and tha tI like Perl better than Python anyway and that Haskell is a better choice if he wants to write operating systems but the people he wants to be hanging out with all use C so he should stick to that
08:50:26 <nominolo> monochrom: haskell has interfaces, which many consider better than inheritance-based OO
08:50:31 <jmcarthur> 1) OO is an ambiguous term as it is. 2) All the OO definitions I'm aware of do not really require language support.
08:50:39 <monochrom> yes, that is full no-OO
08:51:28 <Kaidelong> I also told him that Perl is not obsolete and I did use it in two internships, since people also told him that perl is "old"
08:51:52 * quicksilver knows plenty of people who use Perl to run their businesses.
08:52:01 <applicative> Paczesiowa,  http://groups.google.com/group/pandoc-discuss/browse_thread/thread/55c3b3a3b6191dc4
08:52:05 <EvanR-work> i know plenty of people who used to use perl ;)
08:52:09 <EvanR-work> and now use c#
08:52:26 <Kaidelong> apparently some python guy said that perl is old, that people hate it, and that it "doesn't have full OO"
08:52:52 <Kaidelong> I suppose the hate it part is true enough but a lot of people hate python too
08:53:00 <applicative> Paczesiowa, I'm having trouble trying both ways, like you said, but in any case don't have a proper profiling infrastructure.
08:53:02 <Zao> Kaidelong: Someone should bless him with a clue-by-four.
08:53:03 <Kaidelong> and <language> for that matter
08:53:19 <Kaidelong> Zao: I can't blame him for what some pythonista told him
08:53:35 <Paczesiowa> applicative: oh, there's nothing about errors that Parser a doesn't match parsec-2.1.0.1-.....Parser a
08:53:37 <Zao> Kaidelong: There's Only One Way To Be Wrong
08:53:44 <Paczesiowa> applicative: what infrastructure?
08:53:49 <Kaidelong> that made me laugh =3
08:54:07 <Kaidelong> EvanR-work: C# is getting COME FROM
08:54:17 <EvanR-work> youre joking 
08:54:23 <hpc> that's excellent
08:54:26 <Kaidelong> "await"
08:54:31 <Kaidelong> it's cool how it is implemented
08:54:33 <hpc> finally the syntax reflects the madness within
08:54:34 <EvanR-work> ._.
08:54:50 <EvanR-work> and i thought php's new goto feature was ***
08:54:53 <applicative> Paczesiowa, I don't have experience with profiling these things, that's all.  
08:55:04 <Kaidelong> await signals the compiler to pass everything below it as a closure to the asynchronous call that will end up in it
08:55:06 <Paczesiowa> applicative: I use +RTS -sstderr
08:55:18 <Kaidelong> EvanR-work; it's not literally implemented as COME FROM
08:55:31 <Kaidelong> and for the asynchronous stuff it was meant for, it makes sense
08:55:50 <Kaidelong> "wait for this to finish, then finish the rest of the method" is what it looks like to the programmer
08:55:57 <Kaidelong> I just liketo think of it as COME FROM
08:57:10 <Kaidelong> EvanR-work: the fact that F# has the async monad and haskell has sparks and C# has "await" signals how much OS designers screwed up threads and processes, too
08:58:17 <Paczesiowa> applicative: I did this: cabal install all_pandoc_deps --constraint="parsec == 2.1.0.1" --reinstall and it helped a bit
08:58:26 <Kaidelong> well I suppose all those languages have runtimes
08:58:32 <Kaidelong> of some kind
08:58:46 <Paczesiowa> I love that cabal works per user and I can wipe it all at will
08:58:48 <Kaidelong> the haskell runtime getting compiled in as native code
08:59:01 <quicksilver> Kaidelong: C has a runtime too...
08:59:06 <Kaidelong> that's true
08:59:18 <Paczesiowa> in kernel?
08:59:24 <Kaidelong> although in C you do generally still call the OS and make OS threads/processes right?
08:59:28 <quicksilver> (as commonly used on common PC/server operating systems)
08:59:32 <Kaidelong> or did practices change?
08:59:35 <quicksilver> Paczesiowa: libcrt.a - C RunTime
08:59:59 <Paczesiowa> quicksilver: isn't that just things like collecting args ?
09:00:11 <quicksilver> Kaidelong: C threads are generally kernel backed in some sense yes
09:00:18 <quicksilver> Paczesiowa: memory management too, I believe
09:00:32 <EvanR-work> c doesnt have threads
09:00:32 <Kaidelong> anyway
09:00:51 <Kaidelong> EvanR-work: on Win32 at least you can explicitly make the OS start them
09:00:52 <quicksilver> EvanR-work: it does just as much as haskell does...
09:01:03 <quicksilver> in neither case are they part of the language definition
09:01:09 <quicksilver> in both cases, real code uses them.
09:01:19 <EvanR-work> real code uses a thread library
09:01:23 <Kaidelong> Haskell however implements its own abstraction over OS threads
09:01:45 <Kaidelong> as in, the platform and the libraries
09:02:08 <Kaidelong> as far as I know C programmers will still call their platform to make threads or fork
09:02:24 <quicksilver> Kaidelong: technically haskell doesn't (if we're going to be pedantic about C not doing it); there are libraries for threads in haskell, which require compiler support.
09:04:51 <quicksilver> Kaidelong: meanwhile, libpthreads is an abstraction over kernel thread facilities
09:05:01 <quicksilver> I don't htink the situations are particularly different, qualitatively.
09:05:17 <EvanR-work> libpthreads or win32threads
09:05:25 <EvanR-work> not really standard
09:05:40 <quicksilver> yes, really standard.
09:05:46 <quicksilver> POSIX.1c, Threads extensions (IEEE Std 1003.1c-1995)
09:06:09 <Kaidelong> 1995, so Windows NT probably implemented them
09:06:17 <EvanR-work> would be nice if you could just discuss posix c
09:06:34 <Kaidelong> whether or not the implementation is exposed by default... different story
09:07:01 <Kaidelong> but I suppose in theory POSIX threads should work on Windows NT?
09:07:14 <EvanR-work> pthreads works on windows
09:07:39 <Kaidelong> out of curiousity, does anyone know the specifics of the court order that said that Windows NT had to comply with the POSIX standard?
09:09:13 <hpc> Kaidelong: no idea, but XP and later don't have POSIX compatibility
09:09:35 <Kaidelong> hpc: XP had it but it was "locked"
09:09:48 <hpc> that seems pointless
09:09:57 <Kaidelong> hpc: it was a way to justify the editions
09:10:07 <Kaidelong> professional and up you could get stuff to unlock the POSIX API
09:10:17 <Kaidelong> up being umm
09:10:20 <hpc> :/
09:10:25 <Kaidelong> server 2003 I guess, which is different, and enterprise
09:10:41 <EvanR-work> Kaidelong: #windows
09:10:45 <Kaidelong> sorry
09:11:03 <EvanR-work> do you have anything about haskell to say? :)
09:11:10 <Kaidelong> Yes
09:11:25 <Kaidelong> Lists should default to being head strict
09:11:46 <zygoloid> but spine-lazy?
09:12:15 <Kaidelong> they have no spine until you look at it
09:12:27 <zygoloid> they have no head until you look at it either :)
09:12:34 <Kaidelong> that's true
09:12:53 <Kaidelong> but you can't look at the spine without looking at the head
09:12:59 <Kaidelong> that's the important part, I suppose
09:13:20 <hpc> > let xs = [undefined, 5] in tail xs
09:13:22 <lambdabot>   [5]
09:13:38 <Kaidelong> hpc: yes, that's the problem
09:13:54 <zygoloid> Kaidelong: what's the problem? that looks reasonable to me
09:14:19 <hpc> if you need strictness, use a bang pattern
09:14:38 <hpc> strictness is easier to derive from laziness than the other way around
09:15:10 <hpc> > let (!x:xs) = [undefined, 5] in xs
09:15:11 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
09:15:14 <EvanR-work> im confused
09:15:23 <Kaidelong> hpc: I'd rather that sum/product/iterate etc be written in general for "Foldables" anyway
09:15:29 <EvanR-work> > ah, it doesnt look at the head
09:15:31 <BMeph> hpc: Rather, strictness is easier to compensate for in a lazy-by-default system, than the other way around. 
09:15:32 <lambdabot>   <no location info>: parse error on input `,'
09:15:33 <Kaidelong> right fro the start
09:15:49 <EvanR-work> @src sum
09:15:49 <lambdabot> sum = foldl (+) 0
09:15:55 <zygoloid> > let xs = words "foo (1,1) bar baz (2,1) quux (3,3)"; ys = [1,4,6] in map (map read xs!!) ys :: [(Int,Int)]
09:15:55 <lambdabot>   [(1,1),(2,1),(3,3)]
09:15:56 <EvanR-work> @src sum'
09:15:56 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:15:58 <Kaidelong> ad then make people use head strict lists as much as possible
09:16:01 <ksf> ...after a complete reboot the correct behaviour is now way more frequent than the wrong one.
09:16:03 <zygoloid> Kaidelong: ^^ how would i do that if lists were head-strict?
09:16:18 <zygoloid> Kaidelong: (yes, this is a something i've done when parsing a real file format)
09:16:43 <Kaidelong> zygoloid: if sum was of type (Foldable a, Num b) => a b -> b
09:16:48 <zygoloid> ok i suppose i could do the read second ;-)
09:16:50 <Kaidelong> you could give it a lazy list if you wanted
09:16:57 <Kaidelong> and live with the consequences
09:17:12 <Kaidelong> :t sum
09:17:13 <BMeph> Kaidelong: How would 'iterate' work on a tree? Just curious...
09:17:14 <lambdabot> forall a. (Num a) => [a] -> a
09:17:15 <zygoloid> Kaidelong: what's the advantage of head-strictness in lists?
09:17:34 <Kaidelong> BMeph: depends on how the tree is implemented
09:17:43 <Kaidelong> zygoloid: not building up huge thunks
09:17:54 <Kaidelong> since if you reference the head recursively in the tail
09:18:06 <Kaidelong> the head is reduced to normal form before evaluating the tail
09:18:09 <EvanR-work> > foldl' (+) [1..100000]
09:18:10 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
09:18:10 <lambdabot>    arising from a us...
09:18:25 <hpc> :t foldl'
09:18:27 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:18:31 <EvanR-work> > foldl' (+) 0 [1..100000]
09:18:31 <lambdabot>   5000050000
09:18:33 <zygoloid> premature strictness seems like an analogue of premature optimization to me: use it only if you need it.
09:18:34 <EvanR-work> > foldl' (+) 0 [1..1000000]
09:18:35 <lambdabot>   500000500000
09:18:37 <EvanR-work> > foldl' (+) 0 [1..10000000]
09:18:38 <lambdabot>   50000005000000
09:18:39 <EvanR-work> > foldl' (+) 0 [1..1000000000]
09:18:43 <lambdabot>   mueval-core: Time limit exceeded
09:19:13 <EvanR-work> profile to determine whats slow, then fix that part if necessary
09:19:20 <zygoloid> Kaidelong: if you were to say that a strict-by-default, explicitly lazy haskell might be more pragmatic, i might be inclined to agree.
09:19:24 <mije> is there a noticeable documentation on the type classes except yaht and haskell wiki ? (say yes because it not i'll have to do with the reference)
09:19:31 <EvanR-work> until then live in euphoric lazy function world
09:19:42 <zygoloid> Kaidelong: there's always Disciple if you want to go that way.
09:19:48 <Kaidelong> well it's frustrating when it turns out "obvious " solutions are bad
09:20:01 <EvanR-work> not necessarily bad
09:20:09 <Kaidelong> zygoloid: I'd rather the prelude not be there anre you add Data.Foldable to get folds
09:20:18 <Kaidelong> or drastically reduced, anyway
09:20:32 <EvanR-work> you can ignore the prelude entirely
09:20:39 <hpc> mije: typeclassopedia explains some, but the only real documentation is the real documentation, haddock
09:21:00 <Kaidelong> EvanR-work: you can do all this, it's just a matter of what is the easiest and laziest thing to do
09:21:06 <Kaidelong> there is special syntax for lists
09:21:08 <mije> hpc: ok thanks
09:21:13 <Kaidelong> lazy lists
09:21:15 <Kaidelong> in particular
09:21:20 <Kaidelong> that makes them easy to use
09:21:26 <EvanR-work> Kaidelong: the easiest and laziest to do is not do anything
09:21:36 <Kaidelong> so you will end up using lazy lists even where you shouldn't
09:21:42 <EvanR-work> where shouldnt you?
09:22:38 <zygoloid> scanl (+) 0 [1..] <-- there
09:22:46 <Kaidelong> > let fibs = 1 : scanl (+) 1 fibs in fibs !! 100000
09:22:49 <lambdabot>   420269270299515438631900510129391513177391570263223450330471608719833573145...
09:22:54 <Kaidelong> > let fibs = 1 : scanl (+) 1 fibs in fibs !! 1000000
09:22:55 <lambdabot>   *Exception: stack overflow
09:23:11 <hpc> > let fibs = 1 : scanl (+) 1 fibs in fibs
09:23:12 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
09:23:30 <zygoloid> Kaidelong: but the lazy list isn't actually the problem there at all
09:23:37 <zygoloid> Kaidelong: you're blaming the wrong guy
09:23:44 <Kaidelong> yeah
09:23:45 <EvanR-work> maybe we are discussing changing global properties of the language to improve a single artificial example
09:24:05 <EvanR-work> who uses !!
09:24:10 <zygoloid> the problem is that you 'want' scanl'. the same problem happens with foldl, where no lazy list is built
09:24:19 <Kaidelong> EvanR-work: referring to the head in the tail is a common pattern and it's what causes the huge stack growth
09:24:27 <Kaidelong> zygoloid: is there a scanl'?
09:24:34 <Kaidelong> > let fibs = 1 : scanl' (+) 1 fibs in fibs !! 1000000
09:24:34 <lambdabot>   Not in scope: `scanl''
09:24:36 <zygoloid> Kaidelong: i don't think there is.
09:24:36 <EvanR-work> @src scanl'
09:24:36 <lambdabot> Source not found. Just try something else.
09:24:39 <ksf> how come currentRasterPosition $~ \(Vertex4 x y z w) -> Vertex4 x y z w   isn't a noop?
09:24:42 <Kaidelong> it wouldn't make sense
09:24:48 <hpc> scanl' would == undefined, by definition
09:24:55 <Kaidelong> exactly
09:25:08 <quicksilver> ksf: that allocates a fresh cell
09:25:22 <quicksilver> ksf: no particular reason, but (AFAIK) that's not an optimisation that GHC does
09:25:26 <zygoloid> @let scanl' f q ls = q `seq` (q : case ls of [] -> []; x:xs -> scanl' f (f q x) xs)
09:25:28 <lambdabot>  Defined.
09:25:45 <quicksilver> ksf: (also currentRasterPosition was broken for $~ but Sven knows and maybe he fixed it)
09:25:46 <ksf> I don't mean operationally, I mean semantically wrt. hopengl
09:25:49 <Kaidelong> > let fibs = 1 : scanl ((\x y -> x `seq` x+y) 1 fibs in fibs !! 1000000
09:25:50 <lambdabot>   <no location info>: parse error on input `in'
09:25:52 <zygoloid> > let fibs = 1 : scanl' (+) 1 fibs in fibs !! 1000000
09:25:52 * hackagebot HaTeX 2.0.0 - Library for write LaTeX code.  http://hackage.haskell.org/package/HaTeX-2.0.0 (DanielDiaz)
09:25:56 <lambdabot>   mueval-core: Time limit exceeded
09:25:56 <quicksilver> ksf: Ah, OK, known bug
09:25:56 <Kaidelong> > let fibs = 1 : scanl (\x y -> x `seq` x+y) 1 fibs in fibs !! 1000000
09:25:57 <lambdabot>   *Exception: stack overflow
09:26:04 <quicksilver> ksf: it reads in one coordinate system but writes in another
09:26:09 <zygoloid> hpc: why would scanl' == undefined?
09:26:11 <Kaidelong> yeah
09:26:12 <EvanR-work> Kaidelong: in a real program you would read from such a scanl little by little, forgetting the head
09:26:17 <Kaidelong> won't help here because of the definition
09:26:21 <EvanR-work> as long as you dont use the head in the definition
09:26:30 <hpc> > scanl 1
09:26:33 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [b] -> [a])
09:26:33 <lambdabot>    arising from a...
09:26:45 <Kaidelong> EvanR-work: isn't using the head in the definition a common pattern?
09:26:49 <hpc> @src scanl
09:26:50 <lambdabot> scanl f q ls = q : case ls of
09:26:51 <lambdabot>     []   -> []
09:26:51 <lambdabot>     x:xs -> scanl f (f q x) xs
09:26:53 <EvanR-work> only for cyclic
09:27:10 <EvanR-work> otherwise store the head somewhere else not connected to the list
09:27:39 <EvanR-work> otherwise you need the entire list anyway
09:27:40 <Kaidelong> anyway it's not so much that I think the lists should be strict so much that I find it weird that lazy lists get special treatment by the syntax
09:27:51 <Kaidelong> and by the prelude definitions
09:28:07 <zygoloid> Kaidelong: haskell is a lazy-by-default language. why does it surprise you that an element-lazy list is the normal list?
09:28:34 <EvanR-work> since lists are usually read sequentially, not as arrays, it makes sense to spread out the work
09:28:37 <quicksilver> ksf: I have email from Sven from 2007 discussing it ;)
09:28:42 <EvanR-work> or make them infinite
09:28:50 <Kaidelong> zygoloid: because it seems to better to use a typeclass to talk about all kinds of different lists
09:28:51 <ksf> hmmm I wouldn't mind so much if it wouldn't mess with the _colour_ settings.
09:29:13 <EvanR-work> Kaidelong: if you can avoid writing instances, do it. they get in the way
09:29:14 <Kaidelong> rather than using : and [] and , to hardcode in one particular type of list
09:29:30 <EvanR-work> and i like the list sugar
09:29:52 <Kaidelong> sure, but the list sugar inadvertantly makes you use lazy lists where they may be a bad idea
09:30:07 <Kaidelong> there must be a better solution
09:30:23 <Kaidelong> perhaps better strictness analysis
09:30:35 <Kaidelong> but wasn't that what they had been betting on in the first place?
09:30:39 <EvanR-work> so far ive seen the lazy case more useful more often
09:30:57 <zygoloid> Kaidelong: i thought we'd agreed that lazy lists aren't actually the problem?
09:31:19 <Kaidelong> not for that example, but someone came the other day with an example of iterate overflowing the stack
09:31:39 <EvanR-work> and strict would have helped?
09:31:44 <Kaidelong> not strict
09:31:48 <Kaidelong> strict would make it halt
09:31:59 <Kaidelong> head-strict would stop the stack overflow
09:32:03 <Kaidelong> but would not halt
09:32:11 <zygoloid> Kaidelong: we're talking about element-strict, not spine-strict
09:32:36 <Kaidelong> basically it would stop iterate from building up f ( f ( f ( f...
09:32:39 <EvanR-work> > [undefined, undefined, 5, undefined, undefined] !! 2
09:32:40 <lambdabot>   5
09:32:42 <Kaidelong> if you never evaluate the head
09:33:06 <zygoloid> Kaidelong: what if reducing f a to WHNF still builds up a large thunk?
09:33:21 <Kaidelong> zygoloid: then you're screwed
09:33:32 <zygoloid> Kaidelong: no, you just need a better combinator for your forcing
09:33:52 <zygoloid> what-you-need-to-force and is-my-list-strict-enough are completely separate concerns imo
09:34:11 <Kaidelong> anyway, it's somewhat orthogonal to what was really bothering
09:34:21 <zygoloid> you can take iterate and layer in something which forces the previous elements before forcing each element if you want
09:34:37 <Kaidelong> which is that the prelude folds work on [a] and not on Foldable a or some other notion like that
09:34:45 <EvanR-work> if you always evaluate the head, doesnt that mean a head that is infinite will cause a problem?
09:34:47 <zygoloid> that's nice and composable in a way which changing the data structure would not be
09:34:48 <zachk1> anyone know if this book is any good ? http://www.amazon.com/exec/obidos/ASIN/013507245X/acmorg-20 
09:35:33 <monochrom> this book is very good. prepare to read at the speed of one chapter a month. :)
09:35:45 <quicksilver> Foldable is a false abstraction, IMO.
09:35:52 <Kaidelong> zygoloid: you could do these things, but "sum xs / length xs" would be nice if it worked and was efficient
09:36:06 <jmcarthur> it's supposedly a good book but i can never find a copy for less than $140
09:36:11 <quicksilver> the most interesting thing is viewing it as a stepping stone to traversable which is a true abstraction.
09:36:13 <monochrom> on the bright side, you get to crack even greedy algorithms
09:36:17 <jmcarthur> because it's out of print and all that
09:36:23 <Kaidelong> however the easy way to write it turns out not to work since you can't / with an int and even if you could it'd be inefficient
09:37:00 <zygoloid> Kaidelong: sum xs / length xs will never be efficient, unless the compiler is amazingly heroic
09:37:04 <zygoloid> strictness does not fix that case.
09:37:24 <Kaidelong> well you'll always have the problem with traversing it twice
09:37:39 <EvanR-work> you can write a more efficient algorithm
09:37:39 <zygoloid> right. and the stack overflow in sum is already fixed, today, by strictness analysis
09:37:47 <Kaidelong> oh
09:37:48 <EvanR-work> for that special case
09:37:55 <Kaidelong> I did not know that they fixed it for sum
09:37:55 <zygoloid> > let forceList f [] = []; forceList f (x:xs) = x `f` (x:forceList f xs) in forceList seq [1,2,undefined,3] !! 3
09:37:56 <lambdabot>   *Exception: Prelude.undefined
09:38:07 * ksf falls back to OpenGLRaw
09:38:11 <zygoloid> Kaidelong: ^^ that's a composable make-my-list-stricter combinator
09:38:16 <Kaidelong> did they fix it in general for all f such that f needs both its arguments to return something?
09:38:25 <zygoloid> Kaidelong: you can use something other than seq there if you want to force the elements more
09:38:38 <zygoloid> Kaidelong: yes. you should read about strictness analysis
09:39:21 <ksf> can anyone tell me any advantages of having the origin in the lower left corner?
09:39:35 <ksf> in other words, is there any reason I should get used to that punk?
09:39:41 <hpc> > let forceList f [] = []; forceList f (x:xs) = x `f` (x:forceList f xs) in forceList seq [1..] !! 3
09:39:42 <lambdabot>   4
09:39:45 <Kaidelong> zygoloid: I wonder if you can turn the two traversals into one too
09:40:00 <Kaidelong> since you can see that you have two catamorphisms over the same data structure
09:40:01 <EvanR-work> ksf: you can make whatever you want the origin, i use upper left
09:40:30 <EvanR-work> because it corresponds with the usual window coordinates
09:40:49 <Kaidelong> would there be anything stopping the compiler from turning it into a single one?
09:41:53 <Kaidelong> I think you may even be able to use a rewrite rule, that'd probably be how to do it really
09:41:53 <copumpkin> @djinn Not (Not (Not (Not a) -> a))
09:41:54 <lambdabot> f a = void (a (\ b -> void (b (\ c -> a (\ _ -> c)))))
09:42:01 <ksf> the only thing I know of that comes with a natural left bottom origin is fonts. and even there, it's left middle.
09:42:18 <EvanR-work> ksf: and opengl
09:43:03 <ksf> not anymore, it doesn't, I just changed to ortho2d 0 w h 0
09:43:15 <zygoloid> Kaidelong: doing it in general is pretty tricky. for the specific case of sum xs / length xs you could use a rewrite rule
09:43:41 <EvanR-work> or a normal function
09:43:43 <ksf> ...which doesn't fix the raster coordinates.
09:44:03 <luite> is there a pure PNG encoder library?
09:44:03 <EvanR-work> ksf: thats because you didnt flip the world upside down
09:44:12 <zygoloid> Kaidelong: i don't think GHC's RULES stuff is powerful enough that you can say 'for any operation which takes two strict arguments, and those arguments are both calls to fold called on the same list, fuse them into a zip'
09:44:17 <quicksilver> zygoloid: well you can imagine analysis which says "if you have a function which has multiple strict parameters all being folds over the same structure..."
09:44:27 <ksf> er wut?
09:44:27 <quicksilver> zygoloid: but it sounds like a slightly obscure optimisation...
09:44:43 <quicksilver> ksf: you are right, of course.
09:44:50 <quicksilver> ksf: the solution is never to use raster coordinates
09:45:01 <ksf> but all other ftgl fonts suck.
09:45:07 <quicksilver> the raster path is slow, obsolete, poorly supported, and deprecated.
09:45:08 <EvanR-work> ksf: glOrtho(0, 320, 240, 0, -1, 0)
09:45:26 <EvanR-work> er nevermind
09:45:48 <EvanR-work> i thought i had a negative y in there
09:45:59 <quicksilver> ksf: render a decent font to a texture and map that onto quads
09:46:01 <Kaidelong> h (foldr f (x1) xs) (foldr g (x2) xs)   turns into   (uncurry h) (foldr (\x (a,b) -> (f a x, g b x)) (x1,x2) xs
09:46:05 <Kaidelong> was what I had in mind
09:46:10 <zygoloid> quicksilver: it's a bit too ad-hoc for GHC's RULES, and a bit too specific for a built-in compiler optimization :)
09:46:27 <EvanR-work> the raster api is deprecated, much like everything else in opengl
09:46:32 <zygoloid> Kaidelong: that only holds if h is strict in both arguments.
09:46:45 <Kaidelong> zygoloid: true
09:46:55 <ksf> oh. I didn't try textureFont because I thought that's what bitmapFont is.
09:47:03 <zygoloid> Kaidelong: (and even then it's not equivalent if building either argument is lazy)
09:47:38 <Kaidelong> zygoloid: so it'd be a bit beyond what you can easily do with haskell right now
09:47:40 <zygoloid> Kaidelong: you can fix that by changing the resulting foldr to foldr (\x ~(a,b) -> ..., but then you lose the advantage of a single traversal with no thunk buildup
09:48:31 <quicksilver> ksf: I was not familiar with ftgl, but having just googled it, yes I woudl recommend using textureFont
09:49:57 <Kaidelong> zygoloid: you could have a notion of parallel execution of folds on a single list where folds are only evaluated for as long as they need to be evaluated, but before one fold can grab the tail the rest have to catch up
09:49:59 <quicksilver> ksf: seems a bit daft to use one texture per glyph instead of building up an atlas but I doubt that matters much.
09:50:12 <Kaidelong> You could write that in haskell I guess, but then you go back to the "obvious vs efficient" issue
09:50:21 <ksf> oh no that's perfect
09:50:43 <ksf> ...well, one could stack multiple glyphs into one texture and then index them.
09:50:45 <zygoloid> Kaidelong: you have the trouble that the 'catch up' is a change in semantics.
09:51:03 <quicksilver> ksf: that's what I meant by atlas. That's what I'd do if I was doing it by hand.
09:51:07 <zygoloid> Kaidelong: if the 'catch up' bottoms out for a value which you were never actually going to look at, then you've broken the program.
09:51:16 <ksf> otoh, such a unicode font contains gazillions of glyphs, and that's not even counting different sizes.
09:51:33 <Kaidelong> oh right
09:51:33 <quicksilver> ksf: but it only generates the glyphs you actually use so it's probably fine.
09:51:41 <Kaidelong> because the function inside the fold can return bottom
09:51:56 <ksf> garbage collection becomes a bit tricky if you generate an atlas.
09:52:23 <ksf> ...you don't want to run out of memory when somebody decides to display the whole unicode range, in succession.
09:52:25 <Kaidelong> well that goes away if you know h is strict in both arguments
09:52:29 <Kaidelong> ah well
09:52:43 <Kaidelong> at least now I can see why it is a hard problem
09:52:53 <zygoloid> Kaidelong: not so. suppose one of the folds is 'foldr const ...'
09:52:57 <ksf> I think ftgl renders whole strings to textures, though.
09:54:00 <zygoloid> or suppose that the result is :: Maybe a, then h being strict might not be enough (it'd need to be hyperstrict)
09:54:35 <Kaidelong> > const 5 undefined
09:54:36 <lambdabot>   5
09:54:55 <zygoloid> > map (foldr const 0) [[], [1,2,3]]
09:54:56 <lambdabot>   [0,1]
09:55:36 <zygoloid> @let headOr = foldr const
09:55:37 <lambdabot>  Defined.
09:56:44 <EvanR-work> whats hyperstrict
09:56:52 <zygoloid> EvanR-work: rnf-strict.
09:56:56 <hpc> it's one level below megastrict
09:56:59 <siteswapper> 11
09:57:16 <siteswapper> > 11
09:57:17 <lambdabot>   11
09:57:25 <EvanR-work> whats rnf-strict ;)
09:57:34 <hpc> rnf = reduced normal form
09:57:39 <hpc> ie no thunks
09:58:01 <EvanR-work> still dont get it
09:58:14 <zygoloid> EvanR-work: f is hyperstrict if f x = _|_ whenever x contains a _|_ (at any level of nesting)
09:58:27 <EvanR-work> so it means evaluate friggin everything
09:58:52 <EvanR-work> are other languages normally hyperstrict :)
09:58:55 <EvanR-work> i mean ?
09:59:09 <hpc> yes
09:59:27 <hpc> hyperstrict is a stupid term, in any event
09:59:37 <hpc> it's just strict, and anything else is lazy or partially strict
09:59:38 <jmcarthur> why?
10:00:17 <zygoloid> EvanR-work: yeah. functions in strict languages are usually hyperstrict, in that all domains are flat.
10:00:25 <zygoloid> (so strict == hyperstrict)
10:00:27 <Paczesiowa> @seen aslatten
10:00:28 <preflex>  Sorry, I haven't seen aslatten
10:00:28 <lambdabot> Unknown command, try @list
10:00:44 <jmcarthur> i think a term like "head strict" could make some sense, perhaps
10:00:59 <zygoloid> hpc: arguing over established terminology is fruitless, imo
10:01:01 <hpc> head-strict would be whrnf
10:01:06 <Silvah> @slap lambdabot
10:01:06 * lambdabot clobbers lambdabot with an untyped language
10:01:08 <jmcarthur> yeah
10:01:54 <zygoloid> jmcarthur: as opposed to "weak head strict", or its confusing synonym "strict"? ;-)
10:01:55 <Kaidelong> zygoloid: thanks for the help
10:01:58 <Paczesiowa> @src ap
10:01:58 <lambdabot> ap = liftM2 id
10:02:13 <zygoloid> Kaidelong: no problem. laziness is a pain :)
10:02:30 <EvanR-work> laziness is awesome!
10:03:12 <jmcarthur> zygoloid: weak head strict makes sense too. i just mean as opposed to the ambiguous "strict"
10:03:13 <Kaidelong> strictness analysis is not easy and laziness can make life hard on people who write compilers, it seems
10:03:19 <zygoloid> Newton's first law of Haskell motion: consider an expression at rest. if no force is applied, no work is done.
10:05:09 <Botje> zygoloid: haha :)
10:07:40 <Phyx-> hm.. this is like black magic...
10:08:32 <Phyx-> or GHC has decided to have some fun with me again
10:11:05 <drhodes> has anyone rigged emacs haskell-mode to show the type of anything the cursor is on?
10:11:10 <zygoloid> jmcarthur: "strict" is only ambiguous if there's any doubt as to what it means. the other way out is to be clear that strict means f _|_ = _|_.
10:11:30 <jmcarthur> zygoloid: yeah
10:12:02 <EvanR-work> zygoloid: meaning 'not necessarily at any level of nesting'
10:14:07 <zygoloid> EvanR-work: meaning "you need to understand what _|_ means first" i guess
10:14:08 <EvanR-work> > f x = x !! 2 in f [undefined, 9, undefined]
10:14:08 <lambdabot>   <no location info>: parse error on input `='
10:15:29 <zygoloid> i think maybe that's unfortunate; it'd be nice to be able to teach haskell to the point of explaining how to fix space leaks, without explaining the denotational semantics
10:22:09 <tibbe> dons: I could possibly fly to Amsterdam/Utrecht on the evening of the 26/27 and back to Zurich on Sunday
10:24:34 <redocdam> what really are dons? What's a don?
10:25:06 <Phyx-> What's in Amsterdam/Utrecht?
10:25:06 <tibbe> redocdam: Don Stewart ;)
10:25:08 <copumpkin> redocdam: it's someone's nickname :)
10:25:16 <copumpkin> Phyx-: lots of weed
10:25:18 <tibbe> Phyx-: Don
10:25:22 <Phyx-> @pl (\base filename-> foldr id filename $ replicate (foldl (\n a->n + if a=='.' then 1 else 0) 0 base) takeDirectory)
10:25:22 <lambdabot> flip (foldr id) . flip replicate takeDirectory . foldl ((. flip (flip if' 1 . ('.' ==)) 0) . (+)) 0
10:25:29 <Phyx-> copumpkin: meh, it's overrated :/
10:25:52 <redocdam> Oh dons, is he that guy who attacks cardboard in his backyard?
10:26:04 <copumpkin> redocdam: do you have a haskell question?'
10:26:27 <Phyx-> no, but seriously, what's in Utrecht :P
10:26:37 * Phyx- checks his mailing list
10:26:41 <tibbe> Phyx-: Don will be there
10:26:43 <copumpkin> Phyx-: probably don
10:26:53 <Phyx-> oh, lol
10:27:03 <Phyx-> I thought some kinda haskell thing
10:27:10 <copumpkin> where don is, so is haskell
10:27:16 <Phyx-> lol
10:27:21 <Phyx-> I never go to those things :/
10:29:10 <copumpkin> redocdam: welcome to #haskell, what can we do for you today!?
10:29:31 <redocdam> Oh I just thought you were talking about multiple dons
10:29:50 <mauke> no, you didn't
10:30:42 <Paczesiowa> speaking of trolls, is jdh30 banned from /r/haskell?
10:30:50 <copumpkin> Paczesiowa: I think so
10:30:58 <Paczesiowa> why?
10:31:18 <dolio> Because no one wants to read his crap, presumably.
10:31:20 <tibbe> What conference does AFP stand for? (It's in the Utrecht area)
10:31:43 <dolio> Or if they do, they can read it elsewhere.
10:33:37 <Paczesiowa> he posts a lot of haskell things on his blog lately and they don't make it to /r/haskell. if he's able to have a nice, polite discussion on /r/coding with Simon Marlow, he should be allowed on /r/haskell. you can always downvote him if you "don't want to read his crap" that's no reason for a ban.
10:33:40 <dolio> If there were stuff about hash tables dumped in half the articles on the Haskell reddit, I'd probably just stop reading it the same way I stopped reading the programming one.
10:34:18 <copumpkin> omg haskell hashtables suck ballz
10:34:34 <copumpkin> haskle sux lulz
10:34:42 <zygoloid> lulz wtf haskul < f#
10:34:43 <Silvah> Hashtables suck in general.
10:34:55 <copumpkin> Silvah: omg lern 2 prgrm
10:35:13 <Paczesiowa> copumpkin: that's still not a reason for a ban.
10:35:16 <redocdam> I may disapprove of what you say, but I will defend with my life your RIGHT to say it. - voltaire. I don't see a problem with jdh30, he keeps people entertained. Well imho it is even hypocritical for a Haskell programmer to ban a troll anywhere(wrt. haskell programming).
10:36:08 <copumpkin> redocdam: oh, so you were just pretending to be clueless earlier :)
10:36:16 <zygoloid> i think sufficiently many people just don't give a flying frog what jdh30 has to say that it wastes a lot of everyone's time and emotions to read his tripe
10:36:31 <copumpkin> Paczesiowa: I agree, but whatever
10:36:36 <zygoloid> @protontorpedo
10:36:36 <lambdabot> what echniques can be used to scael application in haskell?
10:37:52 <redocdam> zygoloid: every community needs a scandalous rebel. It creates diversity, which is unarguably a good thing.
10:38:28 <nus> hire Paris Hilton
10:38:47 <redocdam> She is not entertaining
10:39:08 <redocdam> or functional in any way
10:39:44 <zygoloid> redocdam: if the scandalous rebel tries to be part of the community, that's one thing. if they're throwing rocks from across the street that's another...
10:39:45 <copumpkin> she's like IO (), all side effects and no results
10:40:03 <redocdam> The fact that she's more popular than Haskell just goes to show that you can't use popularity as a measure of anything good
10:40:19 <redocdam> same goes for C++'s popularity
10:40:28 <zygoloid> or that she's trying to succeed and haskell is trying to avoid success?
10:43:36 <redocdam> zygoloid: well obviously that just goes to show that success is not intrinsically a good thing
10:43:52 <redocdam> maybe the strive for success is actually bad
10:44:21 <jmcarthur> i'm for banning trolls in topic-specific communities. ruthless haskell bashing is neither helpful nor informative for the haskell enthusiasts the community is meant for
10:44:26 <redocdam> Because I've heard people say thing like C++ being a successful language
10:44:45 <jmcarthur> jdh claims that dons has deleted some of his posts in /r/programming, and i would say that would be across the line
10:44:48 <redocdam> Which actually has made me question the merits of success itself
10:45:14 <copumpkin> it's possible to delete posts as a moderator of a subreddit?
10:45:19 <redocdam> yes
10:45:47 <copumpkin> I can't
10:45:52 <redocdam> what's worse is that admins have a nasty tendancy to shadowban devil's advocates
10:45:53 <copumpkin> in a subreddit I moderate
10:46:47 <jmcarthur> copumpkin: were you given the moderating power by somebody else? maybe they can withhold things from you
10:47:26 <Paczesiowa> Mr. Fantastic had Dr. Doom, Spider-Man had Dr.Octopus and Captain Marvel Dr. Sivana, and now dons has his arch enemy - Dr. Harrop
10:48:08 <redocdam> What can Dr. Harrop do he's not in plural form
10:48:13 <redocdam> like don
10:48:29 <copumpkin> jmcarthur: don't think so
10:48:42 <copumpkin> I can delete top-level postings
10:48:44 <copumpkin> but not comments
10:49:16 <redocdam> You should be able to hide or delete comments
10:49:20 <jmcarthur> copumpkin: i suppose it's also possible that jdh's claims were false, but i think i can give him more credit than *that*. i believe that he believes they were deleted
10:50:04 <copumpkin> http://snapplr.com/e3t2
10:51:30 <Apocalisp> @pl State (\s -> (s, runState (s x) s))
10:51:30 <lambdabot> State (ap (,) (runState =<< ($ x)))
10:51:36 <Apocalisp> What's a better way of saying that?
10:51:57 <redocdam> speaking of which was there an improvement on the stuff jdh30 complained about?
10:52:16 <Apocalisp> @pl State (\s -> (runState (s x) s, s))
10:52:16 <lambdabot> State ((,) =<< runState =<< ($ x))
10:52:26 <copumpkin> redocdam: the hashtable issue is basically resolved, but nobody uses them anyway
10:52:41 <jmcarthur> redocdam: hash tables are fixed. jdh makes claims about sorting algorithms now
10:52:55 <redocdam> tries are faster, but only if they fit memory
10:53:18 <jmcarthur> they are not faster in most real-world scenarios, although they are more elegant IMO
10:53:19 <redocdam> in practise
10:53:28 <jmcarthur> they are not cache friendly
10:53:48 <jmcarthur> there are trie-based structures that are designed to be more cache friendly, but they are not pure
10:54:11 <redocdam> they can be I believe if you make a flat tree
10:54:37 <copumpkin> a stump
10:55:22 <jmcarthur> the cache thing is really a shame. i love tries in theory
10:55:56 <copumpkin> looks like redocdam was banned at some point
10:56:04 <jmcarthur> it is especially nice how lazy tries play so nicely for memoization
10:56:11 <copumpkin> redocdam: you seem pretty harmless though :)
10:56:24 <redocdam> I hit a sweetspot
10:56:28 <redocdam> for some people here
10:56:47 <jmcarthur> copumpkin: how can you tell?
10:56:48 <redocdam> I think it's best to not bring up
10:57:16 <copumpkin> jmcarthur: found him on the banlist looking to see if madcoder was on it and redocdam was an evasion :P
10:57:21 <copumpkin> ah well
10:57:24 <jmcarthur> ah
10:57:35 <redocdam> madcoder is backwards
10:57:48 <redocdam> redocdam is right
10:57:50 <mauke> looks like it is an evasion, then
10:57:50 <copumpkin> :)
10:57:59 <redocdam> what?
10:58:07 <mauke> redocdam: you're technically still banned
10:58:21 <jmcarthur> seems pretty harmless to me though
10:58:31 <redocdam> I've never been here as any other name than this
10:58:45 <mauke> redocdam: yes, but you've been here with a real irc client
10:59:00 <mauke> the webchat overrides your cloak
10:59:03 <copumpkin> yeah, I originally thought you'd reversed your nick to evade a ban, but it turned out you were banned under this nick already :)
11:00:15 <redocdam> Well shucks folks, I guess shows over then
11:00:25 <copumpkin> lol
11:00:29 <kdvh> How often does LYAH get updated? I like the style and ive finished all the chapters...
11:00:35 <jmcarthur> he was playing nice
11:00:44 <copumpkin> yeah, I would've left him alone
11:01:06 <sproingie> i've not seen LYAH get updated in a long time.  i think BONUS has some other stuff on his plate lately
11:01:25 <mauke> preflex: seen BONUS 
11:01:26 <preflex>  BONUS was last seen on #haskell 48 days, 1 hour, 8 minutes and 15 seconds ago, saying: :)
11:01:37 <kdvh> ahh, ok, guess ill use RWH to learn about monads and so on
11:01:58 <sproingie> once you've got applicative under your belt, monads will be a snap
11:02:07 <copumpkin> I'd say play with the language for a while then try monads
11:02:09 <copumpkin> play with specific instances of them
11:02:38 <kdvh> alright :)
11:02:59 <copumpkin> but different stuff works better for different people, so who knows
11:03:47 <Martty> database is locked
11:04:11 <Martty> @src foldl
11:04:12 <lambdabot> foldl f z []     = z
11:04:12 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:04:26 <copumpkin> Martty: yeah, it happens every day I think
11:04:48 <Martty> i dont get this URGH
11:04:51 <Martty> maxl [x] = x
11:04:52 <Martty> maxl (x:xs) = max x (maxl xs)
11:04:59 <Martty> this seems slower than using foldl max 0
11:05:16 <Martty> even though its more appropiate since it doesn't have the 0 base case limitation
11:05:31 <mauke> did you mean: foldl1 max
11:05:44 <Martty> nope
11:06:02 <mauke> well, you should have
11:06:15 <Martty> yea i think i can safely guess what foldl1 does now 
11:06:24 <Martty> @src foldl1
11:06:24 <lambdabot> foldl1 f (x:xs) = foldl f x xs
11:06:24 <lambdabot> foldl1 _ []     = undefined
11:09:39 <jmcarthur> cool http://ego.fm/
11:12:31 <rgrinberg> @src foldr
11:12:31 <lambdabot> foldr f z []     = z
11:12:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:22:30 <ezyang> I wonder if ekmett's made a bytestring finger tree yet 
11:24:10 <lispy> ezyang: ekmett or edwardk?
11:24:11 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
11:24:32 <ezyang> edwardk :-) 
11:24:48 <edwardk> ezyang: yes
11:24:53 <jmcarthur> ezyang: rope?
11:25:13 <Silvah> Hi all!
11:25:17 <edwardk> ezyang: rope on hackage offers Data.Rope. it could stand to have the api polished though
11:25:54 <ezyang> Ah, ok. 
11:26:49 <djahandarie> There should be a standardized way to say "api change" when you upload a new verison of a package
11:27:08 <ezyang> djahandarie: It's called bump the major/minor number 
11:27:25 <ezyang> minor for added features, major for changes. 
11:27:27 <lispy> djahandarie: yeah, you want to learn about the Package Version Policy (PVP)
11:27:32 <djahandarie> I thought that wasn't very standardized
11:27:44 <ezyang> We're rallying toolchain support around it 
11:27:50 <edwardk> djahandarie: http://www.haskell.org/haskellwiki/Package_versioning_policy
11:28:20 <lispy> I'm not sure if base is following the PVP yet
11:28:27 <lispy> Which is sort of annoying from my perspective
11:31:18 <lispy> Annoying in that I want to assume it is and treat it like it is, but it seems that the second version number gets bumped in every release of GHC
11:31:31 <lispy> I'm just not sure if base is really changing that quickly
11:32:31 <djahandarie> I feel like there should be some checking in hackage to detect those sorts of changes
11:32:33 <Veinor> whoops
11:32:44 <Berengal> Better to bump too much than too little
11:32:52 <Veinor> I tried to calculate the 200,000th fibonacci number in GHC and it caused everything to swap out
11:32:56 <lispy> djahandarie: yeah, and we're getting there little by little.  See ezyang's comment.
11:33:12 <djahandarie> Ah, that's what he meant.
11:33:36 <djahandarie> It'd be nice to have the guarantee that someone else's changes don't break my stuff.
11:33:44 <djahandarie> (More of a guarentee, I mean)
11:33:48 <Veinor> like type safety for the packaging system?
11:34:11 <Silvah> O.o
11:34:26 <Silvah> Type-safe packaging system?
11:34:34 <Silvah> O.o
11:34:38 <djahandarie> Not sure how that'd work, but if it has the same sort of guarantee that normal type-safety brings... yes!
11:35:07 <edwardk> djahandarie: sure, just apply an SHA-1 hash of every piece of source and object code on the system. something like NixOS might serve as a start ;)
11:35:22 <copumpkin> more sophisticated module systems seem like a decent starting point
11:36:23 <edwardk> copumpkin: strikes me as a boondoggle full of other problems
11:36:36 <copumpkin> probably :)
11:44:11 <Phyx-> 19:39:18 < copumpkin> she's like IO (), all side effects and no results
11:44:14 <Phyx-> loool
11:45:13 <BMeph> Phyx-: @remember it, or it doesn't count... ;)
11:47:25 <monochrom> hahaha
11:48:22 <Phyx-> @help remember
11:48:22 <lambdabot> quote <nick>
11:48:23 <lambdabot> remember <nick> <quote>
11:48:23 <lambdabot> Quote somebody, a random person, or save a memorable quote
11:48:40 <Phyx-> @remember copumpkin she's like IO (), all side effects and no results
11:48:40 <lambdabot> It is stored.
11:49:14 <monochrom> nice
11:49:30 <BMeph> I will never forget.
11:51:14 <monochrom> It is etched on my body.
11:51:54 <Phyx-> you guys are weird...
11:54:17 <EvanR-work> what are some common times of activity in here, like what time UTC are most #haskellers not at work
11:54:35 <EvanR-work> i.e. are people mostly american, european, or asian
11:55:41 <Berengal> Ask now and you'll get "european" for an answer
12:00:56 <Phyx-> Euromerican
12:01:36 <EvanR-work> Amerasian
12:02:04 <Phyx-> Euromerasian
12:02:19 <EvanR-work> if anyone is interested in haskell game programming #haskell-game may want you to valid its existence, btw
12:02:20 <aristid> what about africa?
12:02:26 <aristid> oh, and australia
12:03:43 <yitz> @vixen you're like IO (), all side effects and no results
12:03:45 <lambdabot> yeah, i like
12:06:37 <EvanR-work> just wondering when the most economical time to make that kind of an announcement is ;) i guess when someone serious about game programming shows up with a question
12:10:57 <Phyx-> EvanR-work: i've been on here from different timezones, and it's always the same people
12:11:00 <Phyx-> who are talking
12:11:15 <EvanR-work> heh
12:11:15 <Phyx-> So I'd say. everyone here is an insomniac
12:11:32 <monochrom> everyone here is a bot
12:11:57 <aristid> :t monochrom
12:11:58 <lambdabot> Not in scope: `monochrom'
12:12:24 <monochrom> I am a phantom type.
12:12:30 <nus> @instances-importing monochrom
12:12:31 <lambdabot> Couldn't find class `monochrom'. Try @instances-importing
12:12:36 <nus> :-P (-:
12:12:53 <monochrom> "the phatom of the type system is there, inside your mind"
12:13:02 <Phyx-> @src monochrom 
12:13:03 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:13:13 <Berengal> @pl monochrom
12:13:13 <lambdabot> monochrom
12:13:14 <nus> monochrom :: PolyChrome
12:21:10 <djahandarie> > fix monochrom
12:21:11 <lambdabot>   Not in scope: `monochrom'
12:21:19 <djahandarie> Even Haskell can't fix monochrom!
12:29:02 <siteswapper> > :t fix
12:29:03 <lambdabot>   <no location info>: parse error on input `:'
12:29:40 <Phyx-> @type fix
12:29:41 <lambdabot> forall a. (a -> a) -> a
12:30:12 <c_wraith> > fix error
12:30:13 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
12:31:04 <monochrom> > fix ("fixed " ++)
12:31:05 <lambdabot>   "fixed fixed fixed fixed fixed fixed fixed fixed fixed fixed fixed fixed fi...
12:31:49 <jmcarthur> > fix error
12:31:50 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
12:32:01 <jmcarthur> oh somebody did it already
12:32:17 <aristid> > let monochrom = undefined in fix ("fixed " ++) ++ monochrom
12:32:18 <lambdabot>   "fixed fixed fixed fixed fixed fixed fixed fixed fixed fixed fixed fixed fi...
12:37:08 <temoto> .w test
12:37:35 <temoto> I believe there was a word definition bot...
12:38:02 <monochrom> @help webster
12:38:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:38:11 <monochrom> @wn test
12:38:12 <lambdabot> *** "test" wn "WordNet (r) 2.0"
12:38:12 <lambdabot> test
12:38:12 <lambdabot>      n 1: any standardized procedure for measuring sensitivity or
12:38:12 <lambdabot>           memory or intelligence or aptitude or personality etc;
12:38:12 <lambdabot>           "the test was standardized on a large sample of
12:38:15 <lambdabot> [31 @more lines]
12:38:18 <monochrom> that's the one
12:59:42 <Martty> why is this such a slow implementation
12:59:43 <Martty> sort [x] = [x]
12:59:44 <Martty> sort (x:xs) = if x >= foldl1 max xs then x : (sort xs) else sort (xs ++ [x])
13:00:18 <sshc> Why is unsafeInterleaveIO unsafe??
13:00:20 <c_wraith> well, xs ++ [x] is going to be O(n)
13:00:34 <c_wraith> So you're adding in an extra O(n) factor
13:00:41 <Martty> dang it
13:01:00 <c_wraith> sshc: because it can result in IO exceptions or other non-deterministic behavior from pure code.
13:01:02 <sshc> Is it because of the "hackiness" of GHC's IO implementation?
13:01:32 <c_wraith> No
13:01:37 <c_wraith> It's a necessary result.
13:01:41 <EvanR-work> hah
13:01:47 <copumpkin> sshc: do you know what it does?
13:01:50 <burp> and x:xs is O(?)?
13:01:56 <c_wraith> burp: O(1)
13:02:17 <aristid> > tan (pi / 2)
13:02:18 <lambdabot>   1.633123935319537e16
13:02:28 <sshc> copumpkin: "unsafeInterleaveIO allows IO computation to be deferred lazily. When passed a value of type IO a, the IO will only be performed when the value of the a is demanded. This is used to implement lazy file reading, see System.IO.hGetContents."
13:02:44 <sshc> I don't understand why it is unsafe
13:02:46 <c_wraith> unsafeInterleaveIO's entire *purpose* is to run IO magically inside of pure computations.  When the IO blows up, that results in pure code doing things it shouldn't be able to do.
13:02:49 <EvanR-work> > (tan 1) * 4
13:02:49 <sshc> c_wraith: What can result in IO exceptions?
13:02:50 <lambdabot>   6.229630898619609
13:02:53 <EvanR-work> hmm
13:03:01 <EvanR-work> > (atan 1) * 4
13:03:02 <lambdabot>   3.141592653589793
13:03:12 <c_wraith> sshc: reading from a closed file.  reading a file that doesn't exist.  hardware errors.  etc, etc
13:03:19 <EvanR-work> > (tan 1) * 2
13:03:20 <lambdabot>   3.1148154493098046
13:03:25 <EvanR-work> ._.
13:03:44 <EvanR-work> > 22 / 7
13:03:45 <lambdabot>   3.142857142857143
13:03:47 <sshc> c_wraith: How does that make lazy IO unsafe?
13:04:17 <roconnor> AFAIK it doesn't
13:04:26 <c_wraith> sshc: It just means it can have very unexpected side effects.  The common case of withFile ... hGetContents is one example.
13:04:40 <c_wraith> withFile will close the handle.
13:04:44 <roconnor> @src readFile
13:04:44 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
13:04:51 <c_wraith> Before hGetContents reads anything from it.
13:04:58 <sshc> c_wraith: unsafeInterleaveIO :: IO a -> IO a — how can that be executed in pure code?
13:05:19 <sshc> (< c_wraith> unsafeInterleaveIO's entire *purpose* is to run IO magically inside of pure computations.  When the IO blows up, that results in pure code doing things it shouldn't be able to do.)
13:05:20 <copumpkin> sshc: main is IO a :P
13:05:23 <c_wraith> sshc: It means that the IO will actually be deferred until necessary.
13:05:38 <EvanR-work> i think we get used to code not having the ability to screw up, and when it can, we label it 'unsafe' because its an exception
13:05:46 <c_wraith> sshc: that generally means "until some pure computation forces the return value"
13:05:52 <EvanR-work> whereas almost everything is unsafe in other languages
13:05:58 <EvanR-work> and safe is an exception
13:06:00 <jmcarthur> it's unsafe because it allows you to thwart the type system, isn't it?
13:06:07 <copumpkin> nope
13:06:10 <roconnor> jmcarthur: AFAIK it doesn't
13:06:12 <c_wraith> unsafeInterleaveIO doesn't allow those kind of tricks
13:06:17 <roconnor> and hence doesn't deserve the name unsafe
13:06:17 <EvanR-work> unsafePerformIO does though
13:06:19 <copumpkin> unsafePerformIO lets you break it
13:06:21 <Martty> c_wraith well i can't think of any other way to implement this kinda sort .. any hints!?
13:06:22 <c_wraith> It just allows you to create undefined semantics
13:06:32 <eikke> is there any 'unsigned' identifier in haskell?
13:06:33 <c_wraith> Martty: did you look at my example?
13:06:38 <Martty> c_wraith yes but i didnt quite get it 
13:06:41 <EvanR-work> eikke: Word
13:06:50 <copumpkin> roconnor: it's still pretty unsafe, I'd say. We generally assume something like String doesn't have side effects
13:06:51 <roconnor> I don't undestand what is wrong with the withFile hGetContents
13:07:13 <30BAAVBOK> wow, what? http://news.ycombinator.com/item?id=1567414
13:07:15 <copumpkin> roconnor: read head of resulting string, write to that file, read some more
13:07:18 <c_wraith> roconner: it will crash on a read from a closed file handle when you try to use the results
13:07:20 <roconnor> copumpkin: I still haven't seen how these side effect are observable.
13:07:30 <Martty> oh and hpaste aint working right now sadly
13:07:37 <jrockway> (wow, and what did freenode do to my nick!)
13:07:41 <EvanR-work> well theyd be observable by another unsafeIntereaving IO
13:07:44 <roconnor> unsafeInterleaveIO is just a type of forkIO
13:07:56 <Nibble> guys, if I make a function take a list and return an element of it
13:07:56 <sshc> c_wraith: How is running an IO action before any pure code is evaluated any more unsafe than running that IO action (only once) after pure code starts to be evaluated?
13:08:00 <roconnor> in fact, I consider them practially the same.
13:08:06 <codolio> All the problems people have with unsafeInterleaveIO are problems with doing IO concurrently.
13:08:10 <sshc> c_wraith: You could cause those same issues without unsafeINterleaveIO
13:08:14 <c_wraith> sshc: it results in non-deterministic IO
13:08:15 <Nibble> how should the defition be? someFunc x or someFunc [x]
13:08:16 <roconnor> where unsafeInterlaveIO is a hinted version of forkIO
13:08:23 <sshc> c_wraith: What are you referring to by "it"?
13:08:28 <EvanR-work> sshc: are you trying to use unsafePerformIO ?
13:08:31 <c_wraith> sshc: unsafeInterleaveIO.
13:08:42 <aristid> does GHC have a type for 96-bit floating point?
13:08:46 <roconnor> now if you want to say forkIO is unsafe, well maybe I could buy that
13:08:48 <codolio> At least, all the ones off the top of my head.
13:08:55 <aristid> or 128-bit, or anything more than 64
13:08:56 <c_wraith> sshc: it means that the code that calls the IO functions doesn't actually control when the IO happens.
13:09:01 <sshc> EvanR-work: I'm not trying to use anything; I'm trying to unedrstand why unsafeInterleaveIO, which enables lazy IO, is unsafe.
13:09:18 <sshc> It seems as unsafe as normal IO.
13:09:19 <roconnor> sshc: I've never heard a convincing argument
13:09:19 <c_wraith> sshc: that means you can have concurrency errors in code that's been unsafeInterleaveIO'd, even if it would be perfectly safe without it.
13:09:38 <Nibble> anyone? how should the defition be? someFunc x or someFunc [x] if someFunc is of type [a] -> a
13:10:02 <sshc> c_wraith: All IO is non-deterministic.
13:10:14 <EvanR-work> sshc: can you catch IO exceptions from unsafeInterleavedIO?
13:10:18 <roconnor> sshc: I don't think so
13:10:35 <c_wraith> sshc: not at all.  I can easily say "read this file" and get the contents of the file before moving on to the next step in the program.
13:10:48 <sshc> IO *can* be non-determistic, rather
13:10:56 <roconnor> better
13:11:15 <EvanR-work> Nibble: somefunc :: [a] -> a
13:11:27 <copumpkin> executing IO is nondeterministic, but evaluating the results of executing IO shouldn't be
13:11:32 <c_wraith> Martty, I re-pasted the code here:  http://pastebin.com/zx7XPFYc
13:11:35 <Nibble> EvanR-work: yes. that is the type of the function yes
13:11:37 <EvanR-work> somefunc mylist = ...
13:11:39 <EvanR-work> or 
13:11:43 <EvanR-work> somefunc (x:xs) = ...
13:11:44 <copumpkin> sshc: that's the problem with it
13:11:47 <EvanR-work> somefunc [] = ...
13:11:51 <sshc> unsafeInterleaveIO only changes when that action is executed.
13:12:09 <Nibble> EvanR-work: but should it be someFunc x or someFunc [x]
13:12:09 <c_wraith> yes, but when becomes "who knows?  maybe never!"
13:12:11 <copumpkin> sshc: or whether it's executed at ll
13:12:13 <sshc> How is executing it later any more unsfe?
13:12:16 <Martty> c_wraith thanks
13:12:17 <EvanR-work> Nibble: to use it?
13:12:23 <Nibble> EvanR-work: yes.
13:12:25 <copumpkin> sshc: if I don't bother evaluating the result, the missiles might not get launched
13:12:34 <EvanR-work> somefunc (any expression that has type [a])
13:12:39 <copumpkin> sshc: evaluating a pure value should not change things like that
13:12:41 <EvanR-work> somefunc [1]
13:12:50 <EvanR-work> somefunc "abc"
13:13:13 <EvanR-work> somefunc (filter even [0..])
13:13:28 <copumpkin> say you have two unsafeInterleaveIO'd lists, one which when evaluated writes to a file, and the other which reads from that file
13:13:40 <copumpkin> now, depending on how much you force of one list, the contents of the other one might change
13:13:43 <Nibble> EvanR-work: you are not understanding. if someFunc :: [a] -> a. Should I, when writing how the function works(definition of it.) write someFunc x or someFunc [x]
13:13:53 <copumpkin> not change, but you know what I mean
13:13:53 <dolio> copumpkin: The problem with that is that it's bad design.
13:13:55 <EvanR-work> Nibble: i just described that
13:14:00 <copumpkin> dolio: sure :P
13:14:04 <roconnor> copumpkin: it is all still just a type of scheduling of forkIO
13:14:11 <dolio> It's the same as having two concurrent threads, one which reads and one which writes to the given file.
13:14:11 <EvanR-work> Nibble: around 15:11
13:14:13 <Nibble> EvanR-work: that is when you call the function?
13:14:21 <sshc> copumpkin: If it's important that you *do* execute an action and at a certain time, then you shouldn't use lazy IO.  You can improperly use strict IO as you can improperly use lazy IO.
13:14:21 <EvanR-work>  = means definition
13:14:28 <Nibble> EvanR-work: yes.
13:14:31 <EvanR-work> somefunc mylist = ...
13:14:39 <roconnor> sshc: I fully agree
13:14:39 <EvanR-work> or
13:14:41 <Nibble> EvanR-work: yes. so no [] around mylist
13:14:44 <EvanR-work> somefunc [] = ...
13:14:49 <EvanR-work> somefunc (x:xs) = ...
13:14:53 <copumpkin> sshc: yeah, sure, and that's why it has the unsafe prefix. unsafePerformIO works fine if you follow "the rules", just like rules like the ones you're talking about :P
13:15:04 <copumpkin> sshc: all it's saying is that you're on your own
13:15:09 <dolio> The fact that "it's happening due to pure evaluation!" is a red herring.
13:15:27 <Nibble> EvanR-work: yes. but that is not the question. the question is if I should have [] around my variable or not when defining a function that takes a list.
13:15:40 <roconnor> people shouldn't rely on the forcing of pure values to determine when IO actions are executed IMHO.
13:15:50 <Nibble> because I am getting this silly error
13:15:51 <roconnor> that would be crazy programming
13:15:51 <copumpkin> roconnor: yeah, definitely! :P
13:15:55 <sshc> copumpkin: It can be as "unsafe" as regular IO
13:16:18 <roconnor> but it works great an a very lightweight concurency with very little control.
13:16:58 <copumpkin> sshc: the point is that you can observe pure evaluation with it. You're not supposed to be able to do that, and that's it :P
13:17:18 <Saizan> we should find a way to lose control over the scheduling
13:17:22 <copumpkin> sshc: sure, the worst you can do as side effects is do what you'd do in regular IO
13:17:26 <EvanR-work> Nibble: somefunc [x]  = ... means you accept a list of one thing
13:17:30 <copumpkin> but all your program runs in IO a in the first place
13:17:34 <roconnor> copumpkin: I can do that without unsafeInterleave IO can't I
13:17:38 <Nibble> EvanR-work: that's what I wanted, thanks
13:17:39 <roconnor> copumpkin: I can catch exeptions.
13:17:42 <EvanR-work> Nibble: somefunc (x:xs) = ... means its at least one
13:17:46 <EvanR-work> [] means zero
13:17:47 <roconnor> copumpkin: do we call in unsafeCatchException?
13:17:56 <Nibble> I know what it means, just my bad memory
13:17:59 <Nibble> ^^
13:18:00 <Saizan> but then "do the side-effects as late as possible" is often what you want when you do unsafeInterleaveIO
13:18:12 <sshc> roconnor: Pure code can see the text of a file that was read strictly or lazily.
13:18:15 <copumpkin> roconnor: weren't our positions on this reversed a while ago when I introduced spoon? :P
13:18:18 <sshc> copumpkin, rather
13:18:30 <roconnor> copumpkin: possibly :)
13:18:44 <copumpkin> I don't like that we can catch exceptions either
13:18:49 <dolio> Doesn't spoon use unsafePerformIO to catch exceptions into pure values?
13:18:52 <copumpkin> it's ugly, but practical
13:18:58 <copumpkin> yep :P
13:19:16 <dolio> Well how is that not a significant difference?
13:19:59 <copumpkin> I don't think anybody likes spoon :P
13:20:10 <copumpkin> or thinks it should exist, in a perfect world
13:21:45 <dolio> interact, say, allows you to interleave reading input with processing and outputting it, essentially.
13:21:51 <roconnor> I still maintain that unsafePerformIO is perfectly safe so long as you consider it a form of concurency
13:22:07 <dolio> Which is nothing you couldn't do with other concurrency primitives.
13:22:17 <EvanR-work> dolio: wrong ;)
13:22:26 <EvanR-work> top level defines as results of IO
13:22:31 <dolio> It'd just force you to use a lamer interface than String -> String.
13:22:34 <EvanR-work> cant do that with forkIO
13:22:38 <dolio> For the string pricessing, that is.
13:22:57 <monochrom> unsafePerformIO combined with IORef let you unsafeCoerce.
13:23:02 <dolio> EvanR-work: How do I make a top-level define using interact?
13:23:05 <roconnor> oh
13:23:07 <EvanR-work> global = unsafePerformIO (newIORef 0)
13:23:07 <roconnor> ah
13:23:11 <roconnor> I mean unsafeInterleaveIO
13:23:13 <roconnor> my bad
13:23:15 <Nibble> http://beta.yapaste.com/fZ
13:23:16 <roconnor> very very bad
13:23:19 <EvanR-work> heh
13:23:24 <roconnor> I still maintain that unsafeInterleaveIO is perfectly safe so long as you consider it a form of concurency
13:23:27 <monochrom> oh ha, <3 unsafeInterleaveIO
13:23:34 <Nibble> EvanR-work: any ideas?
13:23:43 <Nibble> EvanR-work: I know the last one is wrong
13:23:47 <Nibble> but how should I do it?
13:23:52 <EvanR-work> Nibble: cant pay much attention at this point, at work
13:24:02 <EvanR-work> in principle
13:24:10 <Nibble> EvanR-work: ok
13:24:19 <Nibble> EvanR-work: how could anyone guess you are at work ;)
13:24:50 <Nibble> EvanR-work: nvm, I think i have a solution
13:25:19 <dolio> Now unsafeInterleaveST is unsafe.
13:25:29 <monochrom> "interact" requires its user to be very careful about forcing order. it is as much care as unsafeInterleaveIO.
13:25:52 <jrockway> i wrote a database interface with unsafeInterleaveIO once
13:26:14 <jrockway> it was excellent, especially when you wrote "do { openDatabase; results <- getResults; closeDatabase; pritn results }" ;)
13:26:20 <monochrom> perhaps it's unsafe in the sense of "different order from default"
13:26:21 <roconnor> I would avoid using interact for interactive programs
13:26:54 <sshc> jrockway: And you wrote getResults lazily?
13:27:04 <dolio> interact isn't bad as long as you don't care about printing prompts and stuff.
13:27:15 <dolio> For interactivity.
13:27:23 <dolio> If you just expect people to type into a blank screen, it's all right.
13:27:42 <monochrom> it's probably better off called "pipe"
13:27:44 <roconnor> oh
13:27:47 <dolio> Otherwise it's kind of a pain.
13:28:11 <sshc> jrockway: That's a lot worse than using strict IO and {openDatabase; closeDatabase; results <- getResults, print results}, right? ;)
13:28:43 <jrockway> yeah
13:28:57 <jrockway> turns out that closing the database makes the program segfault regardless, so...
13:29:30 <jrockway> the point is that unsafe* is actually unsafe when you don't use it safely
13:29:35 <monochrom> openSesame; replicateM 40 ...
13:29:43 <jrockway> and expecting users of your library to realize that it's unsafe is expecting too much :)
13:30:39 <wioux> dolio: what's a good way to do REPL-like interaction, if not interact?
13:30:44 * hackagebot uu-parsinglib 2.5.1 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.1 (DoaitseSwierstra)
13:31:11 <roconnor> @type forever
13:31:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:31:14 <dolio> wioux: I've been using haskeline, but that gets pretty imperative.
13:31:28 <dolio> That gets you line editing and stuff, too.
13:31:34 <Nibble> oh shit. I got it working
13:31:35 <dolio> Which interact won't.
13:32:12 <sshc> jrockway: There are a lot of IO actions, such as reading from a file, that can be unsafe, such as when that file doesn't exist.
13:32:26 <sshc> jrockway: How is interleaveIO more unsafe?
13:36:43 <orlandu63> why doesn't lambdabot have the sources to some functions?
13:36:44 <Saizan> irrelevance of the evaluation order on the effects executed is the main part of the only formalization of "purity", though that formalization would need some work to handle concurrency sensibly
13:37:02 <Saizan> orlandu63: the @src database is manually populated
13:37:35 <Saizan> orlandu63: it doesn't even reflect the source of actual GHC libs, it's mostly taken from the simpler definitions in the haskell report
13:38:11 <Saizan> you can use hoogle/hayoo to find sources in generaò
13:38:14 <Saizan> *general
13:38:15 <jrockway> sshc: because you get the error at a point where you aren't expecting it
13:38:29 <ezyang> Given a filename, what's an easy way to print it to stdout? 
13:38:33 <jrockway> remember, people don't expect their programs to crash in the middle of code that looks pure
13:38:39 <ezyang> s/it/the file's contents/ 
13:38:39 <jrockway> that's where the unsafe-ness comes in
13:38:57 <Saizan> ezyang: putStrLn . readFile ?
13:39:05 <Saizan> s/./<=</
13:39:14 <ezyang> Saizan: Will that bite me in strange ways? 
13:39:22 <jrockway> inside of IO, it's expected that the outside world is going to let us down, and we have mechanisms for anticipating those letdowns and correcting them :)
13:40:09 <Saizan> ezyang: on 6.12 it'll decode/encode the stream according to your locale
13:40:39 <ben_m> Greetings :) Is there a special reason why I can't use -> as an operator?
13:40:45 <ezyang> Hm I think that's ok, but ideally no transformations would be good. 
13:40:48 <aristid> > (1 / cos) pi
13:40:49 <lambdabot>   -1.0
13:40:56 <kmc> ben_m, it's reserved syntax
13:40:57 <ezyang> I guess that means... bytestring? 
13:41:02 <mauke> ben_m: yes, it's used by the language itself
13:41:06 <obfuscated> hello, is there some way I can make this code http://pastebin.com/KsRYmNj8 work?
13:41:09 <sshc> jrockway: I don't expect errors from lazy IO to happen when they would happen if it were strict
13:41:13 <kmc> same reason you can't use "let" as a variable ben_m
13:41:14 <Saizan> ezyang: even there you might need to open the file in binary mode
13:41:28 <dolio> Errors from lazy IO are just ignored.
13:41:31 <jrockway> whatever, don't really care to argue about it
13:41:41 <jrockway> i avoid unsafeInterleaveIO in my code, and my code works nicely
13:41:47 <jrockway> that is really all i wanted to add to this discussion
13:41:54 <jrockway> i am here to whine about HN, but nobody wanted to join me :)
13:42:14 <aristid> i wish there was an infix-syntax for Applicative
13:42:27 <kmc> obfuscated, there is no point to two "return"s in the same do block
13:42:31 <mauke> obfuscated: remove line 11, remove return from line 12, change line 13 to "pure" -> return (pureFunc "called")
13:42:44 <jrockway> aristid: foo <$> bar <*> baz ?
13:42:44 <Saizan> dolio: i think that's just what the old hGetContents did to be haskell98 compatible
13:42:47 <kmc> do { return x; return y }  === do { return y }
13:42:58 <dolio> Saizan: Does it do something different now?
13:43:26 <ben_m> kmc & mauke: Thanks :)
13:43:30 <aristid> jrockway: no, that's prefix
13:43:35 <obfuscated> kmc, mauke: line should have been commented out :(
13:43:38 <aristid> jrockway: i want the foo in the middle
13:44:05 <jrockway> fmap foo bar <*> baz? :)
13:44:16 <dolio> @hackage InfixApplicative
13:44:16 <lambdabot> http://hackage.haskell.org/package/InfixApplicative
13:44:39 <Saizan> dolio: yeah, you get a pure exception
13:44:49 <dolio> Oh. That'll make roconnor happy.
13:44:59 <aristid> jrockway: the foo is stil not between bar and baz
13:45:16 <aristid> bar ``foo`` baz
13:46:31 <obfuscated> mauke: thanks, it works and I even got it :) 
13:48:02 <dolio> > let (<^) = flip fmap in (succ <^ (+) <*> pred) 2
13:48:03 <lambdabot>   Ambiguous occurrence `+'
13:48:03 <lambdabot>  It could refer to either `L.+', defined at <local...
13:48:14 <dolio> > let (<^) = flip fmap in (succ <^ (*) <*> pred) 2
13:48:15 <lambdabot>   3
13:48:21 <dolio> > let (<^) = flip fmap in (succ <^ (*) <*> succ) 2
13:48:22 <lambdabot>   9
13:50:57 * hackagebot uu-parsinglib 2.5.1.1 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.1.1 (DoaitseSwierstra)
13:56:51 <aristid> dolio: thanks, that's pretty cool
13:57:29 <dolio> aristid: If you look at the SHE preprocessor, they have support for idiom brackets, and I think it's supposed to do some amount of infix stuff, too.
13:57:33 <dolio> But I don't know how good its.
13:57:37 <dolio> It is, even.
13:58:15 <dolio> I think they're trying to get by doing as little parsing as possible.
14:01:28 <copumpkin> good enough for pigs!
14:02:29 <dolio> But, I was doing something one day, and Conor suggested I do something infix with idiom brackets.
14:02:37 <dolio> So I guess it works at least partially.
14:02:54 <dolio> I think I was suggesting a 'let ... in' syntax for applicatives.
14:03:00 <aristid> is the guy behind http://ego.fm/ here?
14:03:03 * hackagebot lattices 1.0 - Fine-grained library for constructing and manipulating lattices  http://hackage.haskell.org/package/lattices-1.0 (MaxBolingbroke)
14:03:33 <aristid> dolio: let ... in for applicative?
14:04:29 <dolio> Because I had been using several things of the form 'do x1 <- m1 ; x2 <- m2 ; x3 <- m3 ... ; return (f x1 x2 x3 ...)' which should be valid for applicatives, too.
14:04:50 <dolio> Where none of the xs are visible until the final return.
14:05:50 <aristid> dolio: let x1 = a1 ; x2 = a2 ; x3 = a3 in f <$> x1 <*> x2 <*> x3 ?
14:06:39 <dolio> let x1 = a1 ; x2 = a2 ; x3 = a3 in f x1 x2 x3 ==> pure f <*> a1 <*> a2 <*> a3
14:08:18 <dolio> I believe the constraints on it are the same as 'let' in scheme.
14:08:34 <dolio> Whereas do-notation is like let*.
14:08:55 <dolio> And mdo or Haskell's let is like letrec.
14:08:56 <sshc> jrockway: forkIO also can cause the program to crash or perform IO while pure values are being evaluated.
14:09:14 <c_wraith> sshc: not from the same thread of control
14:10:49 <sshc> Yes.  But how does that make it more unsafe than something that can cause the program to crash when pure val[Cues are not being evaluated?
14:12:10 <sshc> "unsafe" seems to suggest that the function should only be used for low level, debugging, or "hacky" purposes
14:12:17 <sshc> That it should generally be avoided otherwise
14:12:25 <c_wraith> sshc: I'm not saying that unsafeInterleaveIO is broken, by the way.  Or even nearly as unsafe as unsafePerformIO or unsafeCoerce.  It just has the effect of causing IO to happen at an unpredictable time, meaning that it introduces additional ways things can go wrong, possibly in quite unexpected ways for the callers of functions that use unsafePerformIO
14:14:21 <dolio> You could conceptualize unsafeInterleaveIO as creating a new thread of control, really.
14:14:42 <c_wraith> without unsafeInterleaveIO, evaluating a list in a pure function will only result in CPU use.  if that list is the result of a computation that used unsafeInterleaveIO, evaluating it could result in arbitrary control flow taking place.
14:14:54 <c_wraith> err, arbitrary IO.
14:15:05 <dolio> One works on evaluating things, and the other does the IO actions, and they coroutine between each other at opportune points.
14:15:13 <c_wraith> sometimes, the results of that are very unexpected.
14:15:27 <c_wraith> And that's why the function is marked "unsafe".
14:15:36 <c_wraith> It means you really should think about if there's a better solution.
14:16:24 <kmc> we don't have a single clear definition of "unsafe"
14:16:43 <copumpkin> unsafe = eeevil
14:16:51 <monochrom> the unsafe mangler
14:17:00 <unsafePumpkin> make of this what you want
14:17:03 <c_wraith> copumkin: does that have a full-on cackle, or just a hint of it?
14:17:12 <unsafePumpkin> muahahahahahhahaha
14:17:16 * kmc wishes on a shooting star for JHC's top-level IO bindings to make it into GHC
14:17:17 <c_wraith> just checking
14:17:25 * unsafePumpkin engages in much unsafety with unsafeChrom 
14:17:26 <unsafeChrom> hawhawhawhawhawhaw
14:18:00 <c_wraith> kmc: I'd like to see that, as they provide valuable functionality...  But they also will tempt a new generation into doing things the easy way, rather than the right way.
14:18:23 <unsafePumpkin> I want haskell holes
14:18:53 <roconnor> This solution to HoH's performance problems doesn't feel right to me:  http://blog.on-a-horse.org/posts/2010-08-01-released-crashed-optimized.html
14:18:58 <unsafeChrom> I want self-modifying haskell
14:19:03 <dolio> I like Philippa's first-class modules solution more, but that's a lot more demanding.
14:19:16 <roconnor> not that I have an alternative
14:24:36 <unsafePumpkin> that'll teach me to try to do dependent stuff in haskell
14:27:07 <unsafePumpkin> roconnor: make Automaton a "transformer" parametrized by the functor applied to the recursive automaton? :P
14:27:14 <unsafePumpkin> Automaton Maybe, Automaton Identity
14:27:22 <unsafePumpkin> who knows what the other ones would do :P
14:27:24 <Saizan> wow, i found a place where Either is used for error reporting but where Left is the succesful case.
14:27:36 <c_wraith> that's...  intriguing.
14:27:38 <unsafePumpkin> Saizan: oh, I found one of those a while back
14:28:11 <unsafePumpkin> Saizan: where's yours?
14:28:12 <Saizan> i was quite puzzled for a while, especially since it was Either String String
14:28:19 <roconnor> unsafePumpkin: this Maybe thing feel hacky to me
14:28:29 <Saizan> Distribuntion.Simple.PreProcess.Unlit
14:28:44 <roconnor> there should be some sort of knot tying that you can use to prevent yourself from rebuilding the automoton
14:28:49 <dolio> That's not surprising if the algorithm a search where you want to exit immediately if you find something, and error out if you exhaust every possibility.
14:29:09 <roconnor> like the difference between fix f = let f x = x in x   vs fix f = f (fix f)
14:29:16 <unsafePumpkin> roconnor: I agree
14:29:26 <unsafePumpkin> it has a fairly cofree feel to it, too
14:29:42 <c_wraith> uh, that's a bit backwards in your definition of fix :)
14:30:40 <roconnor> ya
14:30:50 <eikke> `arbitrary' is not a (visible) method of class `Arbitrary'
14:30:52 <roconnor> equality is symetric, right ;)
14:30:54 <eikke> whats that about?
14:31:09 <unsafePumpkin> eikke: there are two quickcheck versions out there
14:31:15 <unsafePumpkin> one of them might have different method names 
14:31:18 <unsafePumpkin> can't remember :P
14:31:38 <sshc> @src fix
14:31:38 <lambdabot> fix f = let x = f x in x
14:31:39 <dolio> arbitrary should be in Aribtrary in both.
14:31:48 <Saizan> eikke: maybe you imported the class but not the methods?
14:32:05 <eikke> when I import Test.QuickCheck in GHCi and :info Arbitrary, I see arbitrary and shrink as methods, as expected
14:32:05 <c_wraith> eikke: did you import Arbitrary, instead of Arbitrary(..)?
14:32:13 <eikke> aaah right, sorry :$
14:32:50 <c_wraith> I've done that more than once :)
14:33:07 <copumpkin> oh Haskell, how I wish you were agda sometimes
14:33:14 <copumpkin> oh Agda, how I wish you were haskell sometimes
14:33:36 <c_wraith> clearly, you need to create your own language with exactly the right features, and use it.
14:33:43 <copumpkin> c_wraith: it's what I'm planning :P
14:33:48 <fryguybob> oh c++ how I wish you wern't.
14:34:05 <copumpkin> in fact, the file that makes me wish I had my own language is a beginning of its implementation
14:36:15 <copumpkin> of course, pretending haskell had dependent types isn't the best idea either
14:36:25 <copumpkin> which is what's making me curse so much right now
15:08:54 <Martty> i can't think of a way to split a list at the n'th element, any hints?
15:09:04 <dolio> @type splitAt
15:09:05 <lambdabot> forall a. Int -> [a] -> ([a], [a])
15:09:16 <Martty> i got that much
15:09:38 <dolio> So... You can think of a way. :)
15:09:48 <Martty> no i can only think of the type sig
15:09:55 <Martty> :<
15:09:58 <yescalona> haskell is only for mathematics??
15:10:04 <dolio> splitAt is it.
15:10:08 <Phyx-> > splitAt 5 [1..10]
15:10:09 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
15:10:14 <dolio> Or you want to write it yourself for some reason?
15:10:21 <Martty> i want to write it myself to learn
15:10:25 <dolio> Ah.
15:10:35 <copumpkin> yescalona: nope!
15:10:40 <copumpkin> yescalona: haskell is general purpose
15:10:52 <Axman6> yescalona: only if you count compilers, webservers, and anything else you can think of as mathematical applications
15:11:01 <monochrom> haskell is only for exploding your head
15:11:07 <Martty> monochrom +1
15:11:22 <dolio> Well, if you don't mind inefficiency, you can write take :: Int -> [a] -> [a] and drop :: Int -> [a] -> [a].
15:11:34 <Martty> @src take
15:11:34 <lambdabot> take n _      | n <= 0 =  []
15:11:34 <lambdabot> take _ []              =  []
15:11:34 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
15:11:36 <dolio> Then splitAt n l = (take n l, drop n l)
15:12:00 <kmc> yescalona, programming is inherently mathematical.  furthermore, the connection between haskell and maths is overblown by people who don't understand the language
15:12:08 <copumpkin> or you can build a simple zipper and move it along
15:12:15 <Martty> dolio thanks
15:12:26 <dolio> copumpkin: Yeah, clearly that's the simplest way. :)
15:12:27 <dibblego> @remember kmc programming is inherently mathematical.  furthermore, the connection between haskell and maths is overblown by people who don't understand the language
15:12:28 <lambdabot> It is forever etched in my memory.
15:12:33 <kmc> heh
15:12:44 <monochrom> there is also...
15:12:49 <monochrom> @quote hard
15:12:49 <lambdabot> <mapreduce> says: Some people just find programming with types hard, because they're still learning to program.
15:12:51 <copumpkin> dolio: hey, it isn't much more complicated than writing take :P
15:12:56 <monochrom> and also...
15:12:58 <dolio> I suppose not.
15:12:58 <monochrom> @quote hard
15:12:58 <lambdabot> pikhq says: <kmc> you use simonSaysPerformIO to make it so <pikhq> Yes, but you should think long and hard before using it if you're not named Simon.
15:13:05 <pikhq> \o/
15:13:09 <monochrom> hrm getting close!
15:13:11 <monochrom> @quote hard
15:13:11 <lambdabot> lament says: haskell and asm are not equivalent, can you blank all your RAM and then physically damage some hardware in Haskell?
15:13:16 <monochrom> ok I give up
15:13:33 <Phyx-> @quote kick
15:13:33 <Martty> is there a webpage with all the quotes?
15:13:33 <lambdabot> leimy says: I'd rather have my ass kicked at compile time than at a customer site :-)
15:13:48 <Martty> @quotes
15:13:48 <lambdabot> DrMoreau says: I like big bots and I can not lie
15:13:57 <Martty> .. :D
15:13:58 <Phyx-> lol
15:14:12 <Phyx-> @quote unsafe
15:14:12 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
15:14:43 <Phyx-> isn't that recursive?
15:14:44 <kmc> haha
15:15:00 <monochrom> this is the one:
15:15:02 <monochrom> @quote correct.*hard
15:15:02 <lambdabot> <roconnor> says: writing incorrect programs in Haskell is hard. but writing correct programs is hard in every langauge. therefore, writing code in Haskell is hard. <EvanR> everything is hard in
15:15:02 <lambdabot> haskell ;) <kmc> that's a pretty good summary
15:15:53 <mauke> preflex: quote
15:15:53 <Phyx-> @quote pizza
15:15:54 <lambdabot> integerToBreakfast says: = (["Cornflakes", "Strawberry jam toast", "Grapefruit", "Cup of tea and a biscuit, gotta dash", "Bacon, eggs, toast, tomato and mushroom. You deserve it", "Waffles", "
15:15:54 <lambdabot> Porridge of some description", "Orange juice and muffins", "Apples, pears, mango and kiwi", "A selection of cold meats with crisp bread", "Headache pills and water", "Leftover pizza", "Leftover
15:15:54 <lambdabot> vindaloo curry"] !!)
15:16:23 <Phyx-> @quote windows
15:16:24 <lambdabot> sebazzz says: la vez que salimos, que vino erg0t de bsas, nos metimos en un ciber para contactarnos con tizoc, y erg0t no sabia manejar windows xp ...
15:16:33 <Phyx-> ok....
15:17:23 <kmc> @quote freebsd
15:17:24 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
15:17:24 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
15:17:59 <kmc> @quote ubuntu.freebsd
15:18:00 <lambdabot> NIXDAEMON-COOL says: how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
15:18:08 <jrockway> is there any accepted practice for testing internal functions in a module?
15:18:18 <EvanR-work> ghci
15:18:20 <jrockway> i am thinking about having the tests inline with the code, and then exporting a function that returns the test cases
15:18:31 <jrockway> but then i will have to "import Everything hiding tests"
15:18:43 <jrockway> OTOH, if I write the tests in another file/module, i won't be able to test the non-public parts
15:18:46 <baguasquirrel> I have that problem too, fwiw
15:18:53 <EvanR-work> did you look into quickcheck
15:19:04 <jrockway> i use quickcheck with testframework
15:19:32 <jrockway> normally, when i am only testing "external" stuff, i just write a module called Test.Whatever.My.Module.Is, which exports tests (generated with some TH magic, see test-framework-th, very nice)
15:19:47 <Phyx-_> I really should stop pressing that button
15:19:53 <jrockway> then my main test program looks like main = defaultMain [Foo.tests, Bar.test, ...] where Foo and Bar are the test modules imported qualified
15:20:03 <jrockway> i am fine with this setup, but it doesn't let me touch the internals
15:20:07 <preflex>  <patterner> this channel is an oasis of intelligence in a sea of dumbness
15:20:19 <baguasquirrel> I think jrockway is referring to the problem where it's hard to deal with more than one module at a time in ghci? am I correct?
15:20:32 <EvanR-work> dont think so
15:20:33 <jrockway> this has nothing to do with ghci
15:20:39 <baguasquirrel> ok, nvm then
15:20:42 <jrockway> if i want to *try* code, i can do that in ghci
15:20:50 <jrockway> if i want to *test* code, that's something different :)
15:20:56 <baguasquirrel> ic
15:21:02 <jrockway> specifically, i am referring to automated tests
15:21:03 <EvanR-work> testing is pretty easy in ghci
15:21:17 <EvanR-work> for example you can test a few values and eyeball the result, or use quickcheck
15:21:42 <jrockway> yeah, but this is a multi-thousand-line-program, and i don't want to manually test it everytime i refactor something
15:21:54 <jrockway> trust me, i use ghci extensively while programming
15:22:00 <jrockway> but at some point, i want the program to test itself
15:22:19 <jrockway> (so i can focus on the parts that are changing, not on the parts that already work)
15:22:37 <EvanR-work> you are already focusing on parts that already work because you just said you refactored them ;)
15:24:09 <jrockway> anyway, just curious what other people are doing here
15:24:22 <jrockway> some of the hackage packages i've looked at take the approach of just making everything public
15:24:28 <jrockway> which is not really what i want to do either
15:25:08 <EvanR-work> i have heard groans that everything should be public and the client should decide what to import
15:25:30 <jrockway> yeah
15:25:35 <EvanR-work> but by making stuff private you definitely cant have tests in another module
15:25:36 <c_wraith> jrockway: I tend to create an .Internal version of the module which exports everything, and can be tested.
15:25:53 <c_wraith> And then have a non- .Internal version that exports what I consider to be the public interface
15:26:00 <kmc> i wish we could just import overriding export lists
15:26:20 <baguasquirrel> I personally dislike nonpublic modules. it can make instancing something after-the-fact a real pain
15:26:25 <afarmer> jrockway: I also do what c_wraith said
15:26:37 <c_wraith> I make both public modules, also.
15:26:38 <baguasquirrel> and that can be a big deal for testing sometimes
15:27:06 <jrockway> ah, i like the .internal idea
15:27:30 <jrockway> i also see the "private things suck" angle
15:27:39 <afarmer> jrockway: also, recognize you from HN (I'm Xichekolas)... so hi!
15:27:40 <jrockway> as this has burned me many, many times in the few, few java programs i have tried to write :)
15:27:48 <jrockway> hi!
15:27:51 <zygoloid> jrockway: i've heard people talk about exporting the normal stuff plus one 'allTests' function from a module
15:28:14 <jrockway> i like the elegance of the allTests idea
15:28:35 <jrockway> i am not sure if i like "import Foo hiding allTests" though
15:28:46 <EvanR-work> private should be different from 'not in the public interface' its two different freakin things. basically, enforced private is not useful, not even in stopping newbs from using the wrong functions
15:29:11 <EvanR-work> (in java, c#, php)
15:30:14 <jrockway> i agree
15:30:20 <zygoloid> jrockway: i have an evil idea. define a class Tests in some internal module, and define an instance in each public module
15:30:25 <baguasquirrel> yea, that's a pretty funny point
15:31:09 <zygoloid> jrockway: so your module could define an instance Tests ModuleFooBar where allTests = ...
15:31:43 <zygoloid> and the internal module would define the class Tests and ModuleFooBar, while another module would import yours and the internal module and run the tests
15:32:05 <jrockway> hmm
15:32:34 * hackagebot HaTeX 2.0.1 - Library for write LaTeX code.  http://hackage.haskell.org/package/HaTeX-2.0.1 (DanielDiaz)
15:33:29 <jrockway> so let me ask you this
15:33:36 <jrockway> say you started working on a job with a haskell codebase
15:33:44 <ClaudiusMaximus> @hoogle (b -> f b) -> g b -> f (g b)
15:33:44 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:33:45 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:33:45 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
15:33:57 <jrockway> and each module exported a function called "fooTests", where foo was some abbreviated version of the module name
15:34:07 <jrockway> would you stab the author immediately?
15:34:24 <jrockway> (that is the solution i am leaning towards right now, but then again, i am the only person that has to maintain this code :)
15:34:48 <hpc> i would agree with the idea
15:34:52 <baguasquirrel> am I just a bad programmer or something? I don't see what's so evil about that?
15:34:54 <zygoloid> no. in fact that sounds handy for testing the module during interactive development in ghci
15:35:11 <hpc> for implementation, i would probably give them all the same names, so i only have to change a qualified import in another file to change tests
15:35:25 <hpc> rather than hunt down the precise name
15:35:44 <Eduard_Munteanu> Hi.
15:38:02 <hi> hi
15:38:37 <baguasquirrel> hello
15:38:38 <Guest29699> hi everyone
15:38:44 <Guest29699> how are you?
15:38:45 <jrockway> i like the class idea too
15:38:51 <ClaudiusMaximus> @instances-importing Traversable
15:38:51 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
15:38:52 <jrockway> i am going to try that out and see if it works for me
15:38:59 <jrockway> for $next_project, i think i will follow the .Internal convention
15:39:18 <jrockway> i like advisory privacy, and that gives it to me
15:39:33 <jrockway> use Foo.Bar if you want to follow the author's rules, use Foo.Bar.Internal if you know better than he does :)
15:40:44 <benmachine> @instances-importing Data.Traversable Traversable
15:40:45 <lambdabot> Maybe, []
15:40:49 <monochrom> if you use ghci to load and enforce bytecode, unexported things become visible. if you want more automation than ghci, there is ghc-api.
15:41:32 <jrockway> that is what i really want, but it might be too evil
15:42:06 <unsafeChrom> enough said :)
15:42:54 <jrockway> then i could write a program that finds each module, looks for an unexported tests function, and then runs the tests
15:43:01 <jrockway> that would actually save me a bit of boilerplate
15:43:06 <jrockway> at the cost of being Very Evil
15:46:34 <jrockway> (i seem to remember some perl script that visited files, regexed out ^prop_ functions, and then ran them in ghci... but i prefer something more structured than that :)
15:47:30 <Martty> omg mergesort rocks
15:47:40 <wli> How so?
15:47:54 <dolio> That was an order.
15:48:04 <mauke> eh sorts data and doesnt afraid of anything
15:48:22 <Martty> well it took less time to figure out than selection sort
15:48:28 <Martty> and it sorts waaaaaaaay faster
15:49:00 <jrockway> heh
15:49:01 * Martty is happy over coding sorting algorithms in hs < wtf
15:49:05 <dolio> Isn't selection sort "look for the lowest value, and stick it at the beginning. Repeat."?
15:49:22 <jrockway> i remember learning about sorts in high school CS, and being confused about how to implement bubble sort and insertion sort
15:49:25 <jrockway> they were so complicated
15:49:34 <jrockway> then i learned about merge sort and quicksort, and they were so simple
15:49:42 <jmcarthur> yeah i don't even know why anybody bothers with bubble sort
15:49:50 <jrockway> it's weird
15:49:58 <Martty> its very simple in imperative programming languages
15:50:00 <Martty> simple to implement i mean
15:50:02 <jmcarthur> insertion sort is useful for finishing up some divide-and-conquor sorts
15:50:08 <wli> Things are somewhat different in Haskell. Selection sort is probably more awkward than it is elsewhere.
15:50:11 <jrockway> "today we are going to spend an hour learning about the worst possible way to solve a problem -- one that is so convoluted that you would never come up with it yourself"
15:50:13 <jmcarthur> in imperative languages, at least
15:50:35 <jrockway> "tomorrow, we will gloss over the correct ways to solve the problem, that are not obvious but are very simple"
15:50:44 <mauke> selectionSort xs = let (y, ys) = extractMin xs in y : selectionSort ys
15:50:48 <jmcarthur> my favorite is bogosort
15:50:53 <Martty> http://pastebin.com/UPmmKfTa
15:50:58 <jmcarthur> that's what they *should* be teaching first
15:51:01 <wli> extractMin is where the pain is.
15:51:11 <jmcarthur> it's simple and slow, perfect for explaining why you need good algorithms :P
15:51:22 <kmc> extractMin = foldr1 min?
15:51:26 <jmcarthur> actually i guess shuffles aren't so simple
15:51:31 <kmc> oh it has to extract too
15:51:31 <jrockway> i like bogosort
15:51:53 <jrockway> sometimes i secretly hope that the entropy of my milk and coffee will result in a state where the milk and coffee combine to form a picture of something
15:52:02 <jrockway> it is very statically unlikely, but would be very amusing
15:52:04 <jmcarthur> haha
15:52:08 <Martty> jmcarthur i think the plus of selection sort is you can run it on a big list and watch the numbers come up one by one slowly even on the best computers.. it makes the demo look more hackish thus automatically pro
15:52:11 <jmcarthur> i have thought about things like that too
15:52:25 <Martty> motivates the students
15:52:29 <unsafeChrom> bubble sort is convoluted and touted as "for beginners". insertion sort at least has an obvious plot.
15:52:50 <jrockway> clearly a job for merge sort, unsafeInterleaveIO (!), and calls to "sleep"
15:53:25 <jmcarthur> hmm, a Debug.Trace style sleep would be cool
15:53:52 <jmcarthur> it's even pure
15:54:42 <wli> Selection sort is very clear in imperative languages.
15:54:48 <sproingie> bubble sort isn't convoluted.  "if they're not in order, swap them"
15:55:06 <Martty> they look very good in the language i learned them.. PASCAL
15:55:39 <sproingie> bubble sort is ridiculously inefficient but that's beside the point
15:56:13 <Saizan> it's not so clear why it'd terminate though
15:56:21 <unsafeChrom> bubble sort is convoluted because it is not obvious to see why it doesn't miss out a pair.
15:56:39 <sproingie> expressing bubble sort functionally doesn't strike me as very pleasant either
15:56:42 <unsafeChrom> a case of "some complicated it has no obvious omission"
15:56:50 <unsafeChrom> s/some/so/
15:57:14 <Martty> @src Sort
15:57:15 <lambdabot> Source not found. There are some things that I just don't know.
15:57:18 <Martty> @src List.Sort
15:57:18 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:57:34 <Martty> @src List.sort
15:57:34 <lambdabot> Source not found. It can only be attributed to human error.
15:57:36 <jrockway> @src Data.List.sort
15:57:37 <lambdabot> Source not found. Maybe you made a typo?
15:57:43 <Martty> @src sort
15:57:43 <lambdabot> sort = sortBy compare
15:57:47 <unsafeChrom> you can't see why it doesn't omit. you can put your finger at a specific omission. proof by intimidation.
15:58:02 <Martty> @src sortBy
15:58:02 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
15:58:30 <c_wraith> Is Data.List.sort really an insertion sort?
15:58:33 <Martty> i have this strange feeling our existance is ruled by foldr and its evil brother
15:58:40 <jrockway> #ifdef USE_REPORT_PRELUDE
15:58:41 <Saizan> no, it's a mergesort
15:58:43 <jrockway> otherwise, it uses mergesort
15:58:44 <unsafeChrom> an algorithm is not simple until its proof of correctness is trivial.
15:58:48 <jrockway> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Data-List.html#sort
16:01:44 <jrockway> wow, did ghc-6.12 add support for trailing commas for module export lists, or did i just now notice that?
16:02:04 <jrockway> module Foo (foo,bar,baz,) where ...
16:02:19 <benmachine> I think that's been around a while
16:02:58 <jrockway> after i finally got used to putting the commas in front...
16:03:08 <c_wraith> ah, it does a bottom-up merge.  That's how it manages splitting the list.  makes sense.
16:04:25 <robryk> a probably simple question: data.control.monad.trans.region.internal tries to import functor from data.functor and neither me, nor hayoo, nor ghc can find it. what am i missing?
16:05:11 <unsafeChrom> you're missing a recent version of ghc
16:05:29 <robryk> is that supposed to be in base?
16:05:47 <unsafeChrom> base 4.2
16:06:07 <robryk> thanks
16:06:21 <robryk> strange that it doesn't depend on it (any particular reason?)
16:06:25 <jrockway> incidentally, a google search for base 4.2 returns this as one of the results
16:06:26 <jrockway> http://www-cache.daz3d.com/store/item_file/4783/image_large.jpg
16:06:32 <jrockway> (slightly nsfw, perhaps)
16:06:38 <Martty> daz boot
16:06:54 <unsafeChrom> ghc 6.10 base 4.1 did not have Data.Functor
16:07:08 <dolio> > let yes = Any True ; bubble (x:y:zs) | x <= y = (x:) <$> bubble (y:zs) | otherwise = tell yes >> (y:) <$> bubble (x:zs) ; bubble l = return l ; srt l = case runWriter $ bubble l of (l, Any b) | b -> srt l | otherwise -> l in srt [1,18,2,7,36,-1]
16:07:09 <lambdabot>   [-1,1,2,7,18,36]
16:07:19 <robryk> i mean, any particular reason why regions don't depend on base>=4.2?
16:07:30 <unsafeChrom> human fallibility
16:07:34 <robryk> ah, ok
16:07:45 <unsafeChrom> trust only libs from bots.
16:08:01 <unsafeChrom> exterminate all humans
16:08:04 <Martty> rl = x : rl where x <- randomIO
16:08:16 <digitteknohippie> never trust a bot u cant throw out the window
16:08:18 <Martty> can you see what im trying to do there?
16:08:39 <unsafeChrom> you want a random list?
16:08:48 <Martty> yea
16:08:58 <Martty> haskell is bugged, my intentions are clear.. perhaps i need --plase
16:09:00 <Martty> please
16:09:16 <benmachine> you can't have an infinite list of IO stuff without cheating in sneaky ways
16:09:25 <benmachine> use the pure RNG interface
16:09:28 <unsafeChrom> look for "randoms" and "randomRs". it is ok to first get a generator from IO
16:09:30 <benmachine> StdGen and all then
16:09:32 <benmachine> them
16:09:42 <benmachine> ok unsafeChrom said it better and faster than me
16:09:50 <benmachine> listen to him
16:09:52 <unsafeChrom> "randomRs" is not an attempt at mimicking "toys r us"
16:09:58 <benmachine> or her, whichever
16:10:11 <Martty> 'it'
16:10:22 <Martty> unsafeChrom > define randomRs
16:10:31 <Martty> @src randomRs
16:10:31 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:10:38 <Martty> @src Random.randomRs
16:10:38 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:10:54 <unsafeChrom> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/random-1.0.0.2/System-Random.html#v%3Arandoms
16:11:24 <Martty> ty
16:11:26 <tensorpudding> Seeding the RNG requires an I/O action and therefore needs to be wrapped in the IO monad
16:11:28 <unsafeChrom> first use "newStdGen" in IO, then you're home free and pure
16:12:30 <tensorpudding> after the initial seed the PRNG is a pure function, using some type of deterministic algorithm like Mersenne twister
16:13:39 <tensorpudding> What algorithm does Data.Random use, anyway?
16:13:43 <kmc> bad
16:13:46 <tensorpudding> err, System.Random
16:14:15 <Martty> ah yes, now i remember why i quit haskell the last time
16:14:24 <kmc> why's that?
16:14:59 <Martty> im not exactly sure but it had something to do with randomizing or IO
16:15:17 <unsafeChrom> you will eventually not quit
16:15:22 <tensorpudding> Purity is hard.
16:15:26 <Martty> i think this is the 3rd attempt
16:15:36 <Martty> i'll make it this time
16:15:40 <kmc> the easy way to generate random numbers is randomRIO
16:15:42 <Martty> just need a 6 month break again
16:15:51 <kmc> you treat randomness as an IO action, like reading a file
16:15:57 <unsafeChrom> 3rd attempt to escape? bwhahahahaha we will get you again
16:16:04 <tensorpudding> Having to know when your code is pure is one of the bits of "activation energy" to liking Haskell
16:16:27 <unsafeChrom> Haskell Correctional Service
16:16:31 <tensorpudding> We hope the benefits outweight the initial cost.
16:16:32 <Martty> *whip*
16:16:45 <kmc> this means you have to understand how to use IO, but you probably need that for a real program anyway
16:17:01 <Martty> i've already coded 2 real programs in hs
16:17:06 <tensorpudding> kmc: Also what do you mean by "bad"
16:17:13 <kmc> tensorpudding, slow
16:17:14 <unsafeChrom> "how to come out of the monad jail"
16:17:15 <Martty> im not sure how i managed to forget everything
16:17:16 <tensorpudding> is it some ad-hoc crap?
16:17:24 <kmc> probably not crypto-strength either
16:18:09 <ezyang> This code makes me very unhappy: openFile f ReadMode >>= hClose 
16:18:15 <tensorpudding> Hackage seems to have drop-in replacements
16:18:17 <kmc> haha
16:18:52 <c_wraith> ezyang, what is that?  a bad hack to check to see if you have permission to read a file?
16:18:54 <Martty> too bad i need to focus on linked lists and all that craptota in c++ for my next semester which starts in 2 weeks
16:19:03 <ezyang> c_wraith: Yep. 
16:19:11 <pikhq> Martty: Should not be hard, just tedious.
16:19:12 <ezyang> Because the FFI code that actually reads the file does the fopen outside of Haskell. 
16:19:14 <tensorpudding> Traditional data structures are surely worth learning.
16:19:42 <tensorpudding> C++ is a decent language for learning them too, since it's low enough level for you to get a proper experience
16:19:51 <Martty> tensorpudding not worth re-learning
16:20:00 <pikhq> tensorpudding: s/C++/C/.
16:20:39 <tensorpudding> C++ is just C with bomb that goes off if you drive faster than 50 mph
16:21:11 <Martty> lambdabot terminate tensorpudding 
16:21:12 <dibblego> is there a problem with using a list for the w value in the Writer monad, since it appears to append as it goes through the computation?
16:21:25 <Martty> mm dinner bbl
16:22:25 <kmc> you mean the problem that appending lists is slow?
16:22:47 <dibblego> yes, it seems that if w is ever evaluated, it may run over the list appending
16:22:52 <tensorpudding> lists are slow for a lot of things
16:23:17 <c_wraith> I feel like the writer monad just isn't that interesting.
16:23:38 <dibblego> sorry, having the same discussion in #haskell-in-depth
16:23:48 <kmc> dibblego, yeah, it can be faster to use Data.DList from dlist, «Endo [a]» (essentially equivalent), or something like Data.Sequence
16:24:00 <Eduard_Munteanu> BTW, how would you keep pointers to various parts of a list in Haskell? Or is this unnecessary?
16:24:03 <dibblego> kmc, got it, thanks
16:24:09 <Eduard_Munteanu> i.e. vs reverse xs
16:24:21 <kmc> Eduard_Munteanu, to keep a position in a list you could use a zipper
16:24:27 <kmc> i'm not sure how it generalizes to keeping multiple positions
16:24:43 <Eduard_Munteanu> kmc: I see.
16:24:49 <kmc> that's if you want to update it later
16:24:53 <copumpkin> omg activity in haskell-in-depth
16:25:18 <kmc> if you don't need to build new lists, something like «case xs of (y:ys) -> ...» suffices.  ys is a pointer into the list xs
16:25:37 * Phyx- does a /list haskell*
16:25:54 <Phyx-> well, that failed
16:25:54 <kmc> it looks like you've made a copy of the list with one fewer element, but due to referential transparency, the memory can be invisibly shared
16:26:31 <Eduard_Munteanu> kmc: can I presume doing something like 'reverse xs' would go over the list and then be just as fast as keeping a pointer to its end?
16:26:53 <kmc> a pointer to the end of a singly-linked list is not very useful
16:26:59 <kmc> if you can't append in place
16:27:13 <kmc> if you want something like a list but with efficient access at both ends, you want something other than a list
16:27:16 <kmc> i.e. Data.Sequence
16:27:17 <Eduard_Munteanu> kmc: ah, that makes sense, we'd need doubly-linked lists.
16:27:26 <Eduard_Munteanu> I'll look that up.
16:27:35 <ClaudiusMaximus> @djinn (b -> Either b c) -> (a, b) -> (a, Maybe c)
16:27:35 <lambdabot> f a (b, c) =
16:27:35 <lambdabot>     case a c of
16:27:35 <lambdabot>     Left _ -> (b, Nothing)
16:27:35 <lambdabot>     Right d -> (b, Just d)
16:27:37 <kmc> and doubly-linked lists are a disaster for persistent structures
16:27:42 <kmc> because every node can reach every other
16:27:48 <kmc> so you have to copy the whole thing in an update
16:29:03 <ezyang> When it is impossible to make read . show == id, is it better to make a fake Show instances or make a custom show function? 
16:29:04 <kmc> good persistent structures have this nice sharing property
16:29:06 <Eduard_Munteanu> kmc: though a singly-linked list would be nice if you want to append at the end and read from its start.
16:29:11 <ClaudiusMaximus> is there a template-haskell implementation of @djinn so i don't have to write boilerplate? :)
16:29:23 <ezyang> Edward_Munteanu: you want a queue 
16:29:33 <Eduard_Munteanu> Mmm, yeah.
16:29:50 <kmc> for example if you write a tree in the naive way in Haskell, you get something where updates copy only the path from the root, and share everything else
16:30:35 <kmc> which is definitely not the case for a copying update of a mutable tree
16:31:09 <kmc> mutable singly-linked lists make a good queue
16:31:21 <kmc> for example the message queue of a Chan is basically a singly-linked list of MVars
16:31:24 <ezyang> ([a], [a]) is a pretty decent queue. 
16:31:29 <ezyang> if you need persistence. 
16:31:52 <Eduard_Munteanu> Well you don't really need it mutable to make a queue.
16:32:26 <Eduard_Munteanu> I suppose one can produce it as it goes, though then I don't need a pointer to the end.
16:33:36 <ezyang> Hmm, if no one has any answers to my previous question, here's another one: if I discover I have a data type whose actual constructors only three (out of several dozen) functions use, should I factor that data type into another module? 
16:37:38 <baguasquirrel> there's also Data.Sequence, which is pretty good as a queue
16:38:43 <baguasquirrel> oh wait, kmc already mentioned that...  sorries
16:47:40 <ezyang> > guard True >> "foobar" 
16:47:41 <lambdabot>   "foobar"
16:47:44 <ezyang> > guard False >> "foobar" 
16:47:45 <lambdabot>   ""
16:47:49 <ezyang> Eehee :-) 
16:49:17 <tensorpudding> hmm, how does that work?
16:49:34 <tensorpudding> isn't the input ignored?
16:49:37 <copumpkin> monadplus on lists
16:49:47 <copumpkin> > mzero :: String
16:49:47 <lambdabot>   ""
16:50:31 <aristid> > guard True :: [()]
16:50:32 <lambdabot>   [()]
16:50:38 <aristid> > guard False :: [()]
16:50:39 <lambdabot>   []
16:50:55 <tensorpudding> but (>>) should ignore the guard False and return "foobar" right?
16:51:09 <mauke> no
16:51:11 <aristid> tensorpudding: no, it becomes [] >> "foobar"
16:51:12 <Saizan> [] >>= f = []
16:51:34 <Eduard_Munteanu> >> ignores the input
16:51:42 <Eduard_Munteanu> :t (>>)
16:51:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
16:51:45 <ezyang> (for the record: I decided to go with if b then "" else "asdf") 
16:51:47 <Saizan> there's no result to ignore :)
16:52:02 <ezyang> (but I thought I would share :-) 
16:52:06 <Philonous> a >> b  === a >>= \_ -> b
16:53:12 <tensorpudding> yeah, a >> b should return b
16:53:12 <aristid> > return () >> "asdf"
16:53:13 <lambdabot>   "asdf"
16:53:19 <aristid> > [] >> "asdf"
16:53:20 <lambdabot>   ""
16:53:35 <aristid> tensorpudding: no
16:54:12 <unsafeChrom> > [undefined,undefined] >> ['x']
16:54:13 <lambdabot>   "xx"
16:54:25 <Philonous> tensorpudding: If a >> b ignores the _value_ of a but keeps the effects
16:54:31 <Philonous> -if
16:54:42 <Eduard_Munteanu> Ah, keeps the monoid structure.
16:54:43 <tensorpudding> No, I think i got it now.
16:54:57 <tensorpudding> I forgot what (>>=) was doing for lists
16:55:11 <jrockway> indeed
16:55:25 <jrockway> it's fmap <next thing> [], which results in <next thing> not being evaluated
16:55:41 <ezyang> tensorpudding: bingo! 
16:56:34 <Eduard_Munteanu> Hm, the general definition is a >>= f   =   fmap f mzero?
16:56:38 <benmachine> > "bananas" <$ guard False
16:56:38 <lambdabot>   No instance for (GHC.Show.Show (f [GHC.Types.Char]))
16:56:39 <lambdabot>    arising from a use ...
16:56:47 <benmachine> oh I silly
16:57:02 <tensorpudding> and I'm supposing guard False = mzero, guard True = return ()? or something
16:57:13 <unsafeChrom> yeah
16:57:34 <unsafeChrom> > guard False :: [Char]
16:57:35 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:57:35 <lambdabot>         against inferred type...
16:57:52 <unsafeChrom> > guard False :: [()]
16:57:53 <lambdabot>   []
16:57:59 <unsafeChrom> > guard True :: [()]
16:58:00 <lambdabot>   [()]
16:58:26 <Eridius> > guard True :: [[Int]]
16:58:27 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
16:58:28 <lambdabot>         against inferred typ...
16:58:30 <Eduard_Munteanu> @djinn (>>)
16:58:30 <lambdabot> Cannot parse command
16:58:31 <tensorpudding> oh wait, unsafeChrom is monochrom?
16:58:48 <unsafeChrom> evil and unsafe
16:59:18 <tensorpudding> unsafeChatIRCWithNewNick
16:59:45 * copumpkin eats tensorpudding 
16:59:54 <tensorpudding> :O
17:00:35 <unsafeChrom> > [3,2,1] >> guard False
17:00:36 <lambdabot>   []
17:00:40 <unsafeChrom> > [3,2,1] >> guard True
17:00:40 <lambdabot>   [(),(),()]
17:01:35 * Eduard_Munteanu wonders if UTF8 Haskell extensions cover '»'
17:02:03 <Eduard_Munteanu> :t (»)
17:02:04 <lambdabot> Not in scope: `??'
17:02:30 <unsafeChrom> > let () » () = () in () » ()
17:02:31 <lambdabot>   <no location info>: lexical error at character '\187'
17:02:34 * jrockway wonders if there is a utf-8 character for <<< or =<<
17:02:44 <unsafeChrom> no go
17:03:21 <unsafeChrom> > let () ⊕ () = () in () ⊕ ()
17:03:22 <lambdabot>   ()
17:03:29 <jrockway> Eduard_Munteanu: you can configure emacs to display >> as »
17:03:30 <Eduard_Munteanu> Doubtful, though forall and exists are there in Unicode, and IIRC ghci takes those.
17:03:34 <jrockway> so although ghc does not see the », you do
17:03:51 <Eduard_Munteanu> jrockway: hm I could do that
17:03:56 <Eduard_Munteanu> (well, in Vim)
17:04:19 <Eduard_Munteanu> But the neat thing would be using such stuff for Literate Haskell.
17:04:30 <Eduard_Munteanu> So when you write a paper, it looks cool without changes.
17:04:45 <Eduard_Munteanu> And you can execute it.
17:05:36 <Eduard_Munteanu> s/and exists// <- no exists in Haskell, forgot.
17:05:49 <jrockway> that is what emacs does; it works in lhs mode also
17:06:15 <jrockway> not sure i have any software installed that can take a screenshot, otherwise i would show you ;)
17:06:17 <dibblego> how do you adjust the ghci history length from 100?
17:06:47 <jrockway> i know the answer to this too!
17:06:49 <jrockway> use ghci from emacs!
17:07:03 <ezyang> Hey guys, need a name help. I need something like show but a -> IO String (because it handles some IORefs and I want to show their internal state). What should I name this function? 
17:07:27 <jrockway> "display"?
17:07:30 <dibblego> ShowT ?
17:07:51 <ezyang> dibblego: ShowT? 
17:08:04 <jrockway> "Missouri"?  (because it's the "show me state")
17:08:09 <ezyang> jrockway: That seems... sufficiently ambiguous. Maybe it could work. 
17:08:12 <dibblego> Kleisli IO a String
17:08:13 <Eduard_Munteanu> Data definition with a Show instance I suppose.
17:08:16 <ezyang> s/sufficiently// 
17:10:02 <ezyang> dibblego: I think creating a typeclass for this is overkill. 
17:10:19 <dibblego> oh I thought that's what you mean
17:10:25 <kau> what are the environments where haskell is used...i mean its application??
17:10:29 <ezyang> dibblego: Oh, no. This is one off. :^) 
17:10:30 <Eduard_Munteanu> ezyang: you'd need an instance of Show only.
17:10:47 <Eduard_Munteanu> not define a typeclass
17:10:51 <kau> what are the environments where haskell is used...i mean its application??
17:10:53 <aristid> kau: mostly for twitter apps http://ego.fm/
17:11:07 <ezyang> Edward_Munteanu: Show is a -> String 
17:11:27 <kau> ezyang: Thanks
17:12:08 <kmc> ego.fm is in haskell?
17:12:22 <aristid> kmc: yes, it says "snap framework" below
17:12:44 <kmc> kau, i've found it's particularly good for implementing tools for other languages: compilers, interpreters, debuggers, embedded domain-specific languages, etc.
17:12:57 <kmc> but Haskell is a general-purpose language and can be used for most things
17:13:32 <kmc> _Real World Haskell_ has some good varied examples
17:13:40 <kmc> see also http://haskell.org/haskellwiki/Haskell_in_industry
17:14:40 <Eduard_Munteanu> ezyang: ah, IORef stuff makes it impossible
17:15:00 <kau> thanks kmc , reading it through now...
17:15:42 <Eduard_Munteanu> I was reading the seL4 paper a few days ago, that was some effort, wow.
17:15:58 <Eduard_Munteanu> I mean 200kloc proof for a 5k-ish program is a lot.
17:16:09 <kmc> that is
17:16:13 <Eduard_Munteanu> (they wrote the prototype in Haskell)
17:16:22 <kmc> but most formally verified code is like that
17:18:37 <Eduard_Munteanu> I'm not sure I understand if it's possible to obtain the program itself from the proof.
17:19:04 <shivam3013> Hello.
17:19:15 <Eduard_Munteanu> That would be neat, since they modeled the underlying C model and whatnot.
17:19:29 <shivam3013> Can anyone here code?
17:20:20 <unsafeChrom> No, we have lost that skill.
17:20:42 <shivam3013> ...
17:20:57 <unsafeChrom> We can get computers to extract code from our proofs. We can't "just" code.
17:21:07 <jrockway> who has time to code when you are writing monad tutorials for people on social news sites that claim you need to have a PhD to understand function composition?
17:21:08 <shivam3013> I expected a more simple answer to that simple question instead of sarchasm.
17:21:11 <unsafeChrom> Kind of like we can't add, but we can get the computer to add.
17:21:35 <unsafeChrom> We are the computer generation.
17:21:38 <shivam3013> jrockway, I completely agree with to.
17:22:00 <Eduard_Munteanu> jrockway: I remember older people claiming "I can't use a computer, I don't know math." :)
17:22:12 <shivam3013> Even the smartest programmer requires a degree such as PhD to prove themselves.
17:22:18 <unsafeChrom> I can't use a VCR. I don't know physics.
17:22:26 <Eduard_Munteanu> Yeah, exactly.
17:22:37 <etpace> has anyone here used dyre? I'm getting "Configuration .. changed. Recompiling. Program reconfiguration successful" but it doesnt actually reconfigure, although it does work fine with persistant state
17:22:40 <unsafeChrom> I can't use a toaster. I don't know OOP. :)
17:22:44 <shivam3013> etpace, me.
17:23:03 <etpace> mind having a quick look at a small mockup I made to test it?
17:23:12 <shivam3013> Sure,
17:23:30 <jrockway> the word "object" is too hard to understand
17:23:41 <jrockway> why should i have to use specialized vocabulary to understand a specialized field?
17:23:43 <shivam3013> Is it debugged?
17:23:44 <jrockway> i call everything things
17:23:51 <jrockway> thing-oriented programming 
17:23:53 <Eduard_Munteanu> Stuff :P
17:24:02 <unsafeChrom> thing-driven thinging
17:24:02 <jrockway> yes, that too
17:24:09 <nus> stuff-oriented stuffing
17:24:12 <shivam3013> for me, its: programming-oriented thing
17:24:14 <unsafeChrom> recall that "oriented" is a specialized word too
17:24:14 <etpace> I'm not sure how shivam3013, like I said, it detects a change and says it a success
17:24:18 <etpace> but it doesn't actually do it
17:24:21 <Eduard_Munteanu> "So what do you do?", "Well, stuff."
17:24:36 <shivam3013> try QBasic
17:24:43 <shivam3013> Or JustBasic.
17:24:47 <shivam3013> Very simple.
17:24:59 <shivam3013> Helps the greatest create the simplest.
17:25:05 <jrockway> basic is too hard
17:25:06 <shivam3013> Such as Knock Knock games.
17:25:07 <jrockway> what is "if"
17:25:12 <jrockway> i don't have a PhD in flow control
17:25:15 <shivam3013> Basic is easy.
17:25:21 <jrockway> if/then is too hard to understand for a non-basic-programmer
17:25:33 <unsafeChrom> what is "flow control"??!!
17:25:37 <shivam3013> I am not a basic-programmer.
17:25:46 <shivam3013> You could say i am a all-rounder programmer.
17:25:56 <etpace> http://paste.lisp.org/display/113094 shivam3013 
17:26:11 <shivam3013> Speciallizing in all or most languages.
17:26:14 <unsafeChrom> I'm an intermediate programmer. I use gwintermediate.
17:26:19 <shivam3013> ...
17:26:22 <shivam3013> Dude.
17:26:26 <Eduard_Munteanu> I hear even advanced programmers have troubles understanding GOTO syntax. On the other hand, call/cc is much simpler.
17:26:30 <shivam3013> That's like third class.
17:26:41 <shivam3013> GOTO syntax for me is quite simple.
17:26:59 <tensorpudding> I haven't written a goto in my life
17:27:03 <tensorpudding> Maybe I ought to
17:27:34 <shivam3013> etpace, Good but you should improve the syntax as I observed a couple of preventable errors.
17:27:39 <unsafeChrom> just write some arbitrary recursion
17:27:50 <shivam3013> Maybe you ought to, Maybe you got to
17:27:51 <etpace> what?
17:28:03 <shivam3013> etpace, what?
17:28:04 <jrockway> goto is too hard to understand
17:28:08 <jrockway> your editor has cut-n-paste, use it!
17:28:12 <shivam3013> Goto is quite simple.
17:28:17 <Eduard_Munteanu> What's recursion?
17:28:22 <EvanR> yeah replicate the code manually
17:28:31 <jrockway> yeah, good idea
17:28:31 <EvanR> thats the ticket
17:28:36 <jrockway> cut-n-paste is too hard to understand
17:28:48 <robryk> some realy old languages had goto with mutable destination
17:28:49 <jrockway> i don't have a PhD in cutting and pasting, all i want to do is WRITE A COMPUTER PROGRAM
17:28:56 <shivam3013> Recursion, in mathematics and computer science, is a method of defining functions in which the function being defined is applied within its own definition; 
17:29:19 <shivam3013> Quite simple to understand.
17:29:22 <jrockway> (wow, now i know how fun it is to be on the opposite side of those "haskell is too hard" discussions!  it's fun!)
17:29:34 <shivam3013> Quite difficult to conprehend and implement.
17:29:40 <Eduard_Munteanu> Oh... a fancy term for zygohistomorphic prepromorphisms. Why didn't they just use that instead?
17:29:47 <EvanR> robryk: which supports my hypothesis that basically you can do anything with a computer. and as time passes we refine our tools to do *less*, thereby making saner programs
17:29:55 <shivam3013> Haskell, for me is one of the easiest languages created.
17:30:03 <EvanR> haskell, state of the art, lets you do almost nothing! ;)
17:30:15 <shivam3013> Correct!
17:30:26 <dons> http://news.ycombinator.com/item?id=1569605 <-- help get this up to the front page, we need more survey responses.
17:30:31 <shivam3013> Although, I am not so immpressed with Haskell.
17:30:36 <shivam3013> Even perl is better.
17:30:53 <shivam3013> As they say, With Perl you can do a million things in one single line.
17:30:57 <jrockway> dons: upmodded
17:31:04 <jrockway> i sense that HN hates Haskell though
17:31:05 <shivam3013> Crossed.
17:31:09 <shivam3013> HN?
17:31:15 <dons> jrockway: hmm. most stuff does well
17:31:17 <shivam3013> Who might that be?
17:31:20 <jrockway> if you can't use it to make twitter aggregators in one line of code, it sucks
17:31:24 <dons> shivam3013: have you written much haskell?
17:31:31 <shivam3013> Quite a bit.
17:31:59 <shivam3013> Why.
17:32:09 <shivam3013> No, I will not code Haskell for you.
17:32:20 <shivam3013> Nor will I teach you.
17:32:20 <kmc> HN = Hacker News?
17:32:27 <shivam3013> If that's your reason.
17:32:32 <shivam3013> Oh.
17:32:34 <shivam3013> That Hn
17:32:35 <ezyang> lol. 
17:32:44 <jrockway> (apparently 14 people think that function composition is "incredibly obscure double-talk": http://news.ycombinator.com/item?id=1567414)
17:33:04 <Eduard_Munteanu> :)
17:33:20 <jrockway> clearly we should rename Kleisli arrows into "Thingamajigs"
17:33:21 <shivam3013> You should be more specific as it is a multi-purpose abbreeviation as it can also mean HeadLine News and much more.
17:33:24 <jrockway> working on a patch right now
17:33:30 <EvanR> jrockway: lol
17:33:34 <tensorpudding> The order of function composition might be confusing to people not used to it
17:33:48 <shivam3013> Anyways, has anyone here even coded a website?
17:33:52 <shivam3013> Except me?
17:33:53 <danderson> functions might also be confusing to people who only code in assembler
17:33:55 <ezyang> shivam3013: I have. 
17:33:58 <unsafeChrom> everything is confusing to people not used to it. only the nipple is intuitive.
17:33:58 <jrockway> yeah, but didn't everyone take a math class where the phrase "f of g of x" was used?
17:33:59 <EvanR> ... f . g <=> f(g( )) ?
17:34:01 <Eduard_Munteanu> I still think function composition ordering is confusing for chasing diagrams.
17:34:02 <jrockway> like, in elementary school?
17:34:04 <danderson> not sure how that's a decent excuse :)
17:34:14 <tensorpudding> Coding a website means writing HTML and CSS and JavaScript, or something else?
17:34:40 <unsafeChrom> "f of g of x" is covered in most school systems
17:34:42 <EvanR> SQL
17:34:45 <EvanR> PHP
17:34:49 <EvanR> XYZ
17:34:54 <jrockway> so why is it suddenly doubletalk when it's applied to programming?
17:35:01 <jrockway> who hasn't written f(g(x)) even in C or PHP?
17:35:02 <unsafeChrom> but people take pride in forgetting school math
17:35:18 <tensorpudding> It's the notation
17:35:19 <danderson> jrockway: because it's not a Well Known Design Pattern
17:35:24 <EvanR> jrockway: because functions in programming arent math functions duh. they are subroutines for doing arbitrary anything
17:35:24 * digitteknohippie hasnt
17:35:34 <danderson> how can it make any sense if it's not an abstract facade factory implementation?
17:35:36 <Eduard_Munteanu> Well, rather point-free is not really used in C or such.
17:35:37 <EvanR> jrockway: actually that form is almost impossible to pull off in PHP
17:35:58 <shivam3013> Jrockway, all of us have written the programming languages you have listed, atleast i predict
17:35:58 <tensorpudding> PHP can't do function composition?
17:36:09 <ezyang> tensorpudding: It's really difficult. 
17:36:11 <EvanR> it cant. and it can most of the time not do f(g(x))
17:36:15 <EvanR> either
17:36:19 <jrockway> why not?
17:36:23 <tensorpudding> That's hilarious.
17:36:26 <EvanR> because often g is not an actual function
17:36:36 <jrockway> oh, like print vs. echo or something?
17:37:10 <EvanR> $x = g($foo); $x = f($x)
17:37:21 <EvanR> no, not print or echo
17:37:37 <EvanR> they dont even look like functions
17:38:24 <unsafeChrom> don't try to reason with programmers
17:38:26 <EvanR> i seem to have lost my examples
17:38:33 <unsafeChrom> @quote 1970s.terminals
17:38:33 <jrockway> unsafeChrom: you mean real programmers
17:38:33 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
17:38:39 <unsafeChrom> yeah
17:38:41 <jrockway> not pseudo-programmer academics, like anyone who uses haskell
17:38:45 <shivam3013> I am a real programmer.
17:38:58 <jrockway> if you use a word longer than three letters to describe control flow, you can't possibly be able to write real programs
17:39:09 <jrockway> i know because i don't know what anything is, and one time i wrote a web app for my mom
17:39:18 <jrockway> and called it a startup
17:39:37 <shivam3013> What did you write for your dad?
17:39:39 <shivam3013> Nothing?
17:39:42 <shivam3013> So mean?
17:39:43 <EvanR> is this a anyone who doesnt know haskell is a troglodyte party
17:39:46 * ezyang feels dirty for adding runtime assertions to his code. 
17:39:58 <tensorpudding> trilobytes are fun for parties
17:40:04 <EvanR> ezyang: it compiles is the only assertion you need!
17:40:17 <ezyang> EvanR: Not if you also export unsafe functions :-) 
17:40:30 <unsafeChrom> you don't have to think of assertions as runtime-only
17:40:37 <EvanR> *thats* why you feel dirty ;)
17:40:42 <kmc> nom nom trilobyte
17:41:16 <unsafeChrom> first of all it's also writetime and readtime. someone else maintaining your code will appreciate it.
17:41:27 <EvanR> > cycle "OM N"
17:41:28 <lambdabot>   "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM...
17:41:41 <unsafeChrom> secondly nothing says next year it will be checked compile-time
17:41:46 <unsafeChrom> err
17:41:50 <unsafeChrom> secondly nothing says next year it will not be checked compile-time
17:42:48 <CalmNelly> lol, lambdabot is eating?
17:43:01 <unsafeChrom> non-constructive double negation is hard :)
17:43:08 <Eduard_Munteanu> @vixen Are you eating?
17:43:09 <lambdabot> whoa whoa whoa, one question at a time!
17:43:11 <etpace> groann why isn't dyre working
17:43:26 <Philonous> jrockway: I think they understand function composition just fine (after all, programming is essentially composition, whether imperative, functional or objectionable...). What they don't understand is the concept of abstracting pattern and reifying them into language features
17:43:35 <CalmNelly> @vixen have you seen Inception?
17:43:36 <lambdabot> who's to say?
17:44:00 <CalmNelly> @vixen Christopher Nolan, that's who.
17:44:00 <lambdabot> sorry, i'll stop
17:44:07 <kmc> yeah, better to write the patterns down in books and sell a million copies
17:44:20 <EvanR> better for business
17:44:24 <dolio> That does sound better.
17:44:28 <EvanR> (but not for the economy in general)
17:44:42 <unsafeChrom> it is better for the economy
17:45:03 <Eduard_Munteanu> Yeah, if they're buying it, what the heck...
17:45:26 <EvanR> more wealth is generated if more working software was created and less existing software stopped working and needed maintenance
17:45:27 <unsafeChrom> the economy hinges on giving everyone something more to do and something more to consume
17:45:47 <EvanR> so programmers can do something else
17:46:13 <jrockway> yeah
17:46:13 <unsafeChrom> no, your scheme makes programmers unemployed, nothing to do, and no income
17:46:24 <EvanR> invalid
17:46:25 <jrockway> it wouldn't be so hard to find programmers to write new applications if the old applications actually worked
17:46:49 <EvanR> "throw bricks through the window because then a glass maker will have more work to do"
17:46:59 <Eduard_Munteanu> OTOH, giving jobs to monkeys isn't good either :P
17:47:04 <unsafeChrom> and the brick maker, too
17:47:07 <jrockway> incidentally, i have been learning about this internal application we have at work
17:47:11 <jrockway> it is 100,000+ lines of code
17:47:23 <Eduard_Munteanu> EvanR: ah, broken window fallacy?
17:47:27 <jrockway> but 99.9% of the code is just things like wrappers around linked lists, for absolutely no reason
17:47:35 <jrockway> the actual app is mostly rewritten in 100 lines of haskell
17:47:43 <danderson> turtles all the way down?
17:47:47 <EvanR> lol
17:47:48 <CalmNelly> sweet! go Haskell
17:47:52 <Philonous> EvanR: I daresay our problem now is not so much the production of wealth but the distribution thereof, and pointless work might help do that if it generates employment opportunites
17:47:53 <digitteknohippie> yeps, sounds a familiar tale of woe n bloat
17:47:59 <danderson> and when you get to the bottom, you come to realize the truth, that there is no list
17:48:16 <digitteknohippie> nice one danderson
17:48:16 <danderson> just endless facades, adapters and factories
17:48:23 <jrockway> this isn't really a haskell success story, just a C++-fail story :)
17:48:39 <CalmNelly> :s...:(
17:48:41 <EvanR> Philonous: comes down to motivation and self allocation, if i werent writing this stupid crap at work, maybe id be designing the next generation social network or something
17:48:47 <digitteknohippie> and you realise all your coding life, had just been lolling around in syntactical candyland
17:48:47 <jrockway> if i had to write it in C++, it would not be 100,000 lines of code
17:48:54 <jrockway> i think people think their app has to be complex, so they make it complex
17:49:21 <EvanR> 'facade' is a hilarious c++ pattern
17:49:22 <Philonous> EvenR: Good thing you are kept busy writing stupid crap :D
17:49:24 <teratorn> probably they just aren't good enough to make it more simply
17:49:26 <digitteknohippie> yeah, clever > complex.
17:49:34 <CalmNelly> even designing the next generation social network isn't exactly a pressing issue
17:49:57 <EvanR> well social networks a hugely valuable, for advertising
17:50:05 <EvanR> advertising is hugely valuable for distribution of information
17:50:14 <EvanR> which reduces costs and lets us make smarter decisions
17:50:15 <pikhq> digitteknohippie: And simple > clever in many cases.
17:50:27 <digitteknohippie> the world could do with an open source ( freedomware ) and secure "social networking" service though. 
17:50:46 <Eduard_Munteanu> Open source != free hosting
17:50:46 <Philonous> EvanR: The advertising industry makes me believe there is such a thing as a negative information value
17:50:47 <teratorn> who pays for 10,000 servers though?
17:50:50 <digitteknohippie> ah, yes, very true pikhq... like when : genius = simple.
17:50:51 <CalmNelly> you mean like buying the next best diet pill?
17:50:52 <EvanR> Philonous: lol
17:50:59 <jrockway> yeah, simplicity is the key
17:51:10 <unsafeChrom> heh, it's now secure source and open social networking :)
17:51:18 <jrockway> the C++ version of the app has CORBA and RPC and process manager managers
17:51:20 <Eduard_Munteanu> Though a distributed OSS social network sounds intriguing.
17:51:28 <jrockway> my thing just reads a message from the network, performs the computation, and returns the result
17:51:34 <EvanR> the "manager manager" pattern for the win
17:51:52 <jrockway> it won't automatically shut itself down if it is using too much memory or if it doesn't get a response from the server soon enough or ...
17:52:08 <Eduard_Munteanu> There is (was?) the Diaspora project.
17:52:22 <Philonous> EvanR: So burning a advertising billboard would actually reduce entropy.
17:52:50 <unsafeChrom> burning reddit would reduce entropy
17:53:08 <Eduard_Munteanu> unsafePerformIO reduces entropy
17:53:41 <EvanR> unsafeReverseTime
17:53:42 <ezyang> Oh man, I just had an epiphany 
17:53:45 <digitteknohippie> embracing life reduces entropy.  ... if u follow the prigogine thing
17:53:46 <jrockway> unsafeStartFire
17:53:55 <ezyang> Because I have a type system, I only need to add runtime checks to the unsafe functions! 
17:53:57 <ezyang> :^) 
17:54:08 <unsafeChrom> yes
17:54:28 <Eduard_Munteanu> Well, in some cases they should really call it unsafeThing, anyway you don't know what the result is gonna be...
17:54:35 * hackagebot hierarchical-clustering 0.1 - Algorithms for single, average/UPGMA and complete linkage clustering.  http://hackage.haskell.org/package/hierarchical-clustering-0.1 (FelipeLessa)
17:54:39 <EvanR> nice isnt it. sometimes i want to 'type checks' to my php code, then i realize how futile it is in the scheme of things
17:54:44 <jrockway> well, pure functions can cause problems at runtime
17:55:05 <jrockway> consider "data Foo = Foo | Bar; f Foo = 42; main = print $ f Bar"
17:55:13 <Eduard_Munteanu> :t (!!)
17:55:14 <lambdabot> forall a. [a] -> Int -> a
17:55:21 <jrockway> yeah, that too
17:55:25 <EvanR> how about this one
17:55:29 <EvanR> @src head
17:55:29 <lambdabot> head (x:_) = x
17:55:29 <lambdabot> head []    = undefined
17:55:58 <Eduard_Munteanu> They should really live in a monad.
17:56:10 <unsafeChrom> can you come out of the monad?
17:56:11 <kau> logout
17:56:38 <Philonous> log out of the monad. Good idea.
17:56:40 <Eduard_Munteanu> Well, that's the point, no.
17:56:46 <unsafeChrom> heh
17:56:54 <jrockway> "join"
17:57:05 <Eduard_Munteanu> coreturn FTW
17:57:14 <izz> hi
17:57:15 <unsafeChrom> we're silly, aren't we :)
17:57:16 <Eduard_Munteanu> Or 'extract' as they call it.
17:57:19 <EvanR> head works if you always use infinite lists, too bad thats not checked by the compiler ;)
17:57:35 <dolio> It can be.
17:57:57 <EvanR> oh?
17:58:11 <dolio> data Stream a = Cons a (Stream a)
17:58:36 <Philonous> dolio: Oh, I thought you suggested we could solve the halting problem ;)
17:58:41 <EvanR> lol
17:58:52 <jrockway> interestingly, i have runtime checks for things like "is this number positive"
17:59:00 <unsafeChrom> don't worry about the halting problem
17:59:02 <jrockway> is there some library that has a type with only non-negative integers?
17:59:05 <EvanR> shead (Cons x xs) = x
17:59:06 <BMeph> "head" works on any non-empty list... ;)
17:59:23 <unsafeChrom> Data.Word has only-non-negative integers
17:59:30 <BMeph> ...even an infinite one! =8*O
17:59:35 <EvanR> iterate head may eventually hit the end of the road
17:59:37 <dolio> Or just use catch on your code.
18:00:04 <unsafeChrom> you never escape the halting problem
18:00:08 <jrockway> nice, need to convert some Int stuff to Word
18:00:42 <EvanR> Word is not unbounded though right
18:00:47 * BMeph thinks we needed to "convert some Int stuff to Word" about twelve years ago... :(
18:00:54 <unsafeChrom> Word is bounded.
18:01:14 <EvanR> :t maxBound
18:01:15 <lambdabot> forall a. (Bounded a) => a
18:01:24 <EvanR> > maxBound :: Word
18:01:24 <lambdabot>   18446744073709551615
18:01:59 <unsafeChrom> >  2^64
18:01:59 <lambdabot>   18446744073709551616
18:02:18 <jrockway> > (1 :: Word) - 2
18:02:19 <lambdabot>   18446744073709551615
18:02:50 <jrockway> relevant picture: http://picasaweb.google.com/lh/photo/DF6rwQWQ9Z_tr4TYFyDrlb9d6UQD5zMkQiVhCTBk04U
18:03:09 <unsafeChrom> heh
18:03:38 <EvanR> crap
18:03:38 <benmachine> converting Int to Word doesn't sound helpful
18:03:51 <benmachine> you just convert runtime sign checks to runtime subtraction screwups
18:03:52 <EvanR> broken machines are revealing our secret numbers to the world!
18:03:57 <jrockway> yeah, it doesn't add any safety
18:04:03 <jrockway> it just makes the math work differently
18:04:18 <jrockway> when someone comes along with their negative-one-cent coin, your program breaks
18:04:18 <unsafeChrom> this is why you never escape the halting problem
18:04:19 <benmachine> you can encode your natural numbers as [()] :P
18:04:42 <Eduard_Munteanu> Might work if you want modular arithmetic and you happen to do it (mod 2^n - 1)
18:04:52 <benmachine> jrockway: I think the problem is really just that in haskell you can't define + without defining - as well
18:04:57 <benmachine> (and fromInteger, indeed)
18:05:10 <jrockway> yeah true
18:05:30 <jrockway> x `jrockwaySubtract` y = if x - y < 0 then x - y else undefined
18:05:33 <EvanR> just need another type class
18:05:34 <jrockway> but that is a runtime error too
18:05:39 <EvanR> called monoid
18:05:44 <EvanR> @src Monoid
18:05:45 <lambdabot> class Monoid a where
18:05:45 <lambdabot>     mempty  :: a
18:05:45 <lambdabot>     mappend :: a -> a -> a
18:05:45 <lambdabot>     mconcat :: [a] -> a
18:05:55 <unsafeChrom> some people, when confronted with program verification, say "oh, that's the halting problem, we won't try". Now they have two problems.
18:05:55 <EvanR> 4 `mappend` 5
18:05:59 <EvanR> > 4 `mappend` 5
18:06:00 <benmachine> EvanR: ugly name though.
18:06:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:06:00 <lambdabot>    `Data.Monoid.Monoid a'
18:06:00 <lambdabot>  ...
18:06:11 <benmachine> > getSum $ Sum 4 ++ Sum 5
18:06:12 <lambdabot>   Ambiguous occurrence `getSum'
18:06:12 <lambdabot>  It could refer to either `Data.Monoid.getSum...
18:06:17 <benmachine> wat
18:06:20 <benmachine> siiigh
18:06:38 <benmachine> @more
18:06:42 <benmachine> aw
18:06:45 <EvanR> haha
18:07:16 <EvanR> @instances Monoid
18:07:17 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:07:36 <benmachine> there are (at least) two monoids on numeric types
18:07:42 <EvanR> :t getSum
18:07:43 <lambdabot>     Ambiguous occurrence `getSum'
18:07:44 <lambdabot>     It could refer to either `Control.Monad.RWS.getSum', imported from Control.Monad.RWS
18:07:44 <lambdabot>                           or `Data.VectorSpace.getSum', imported from Data.VectorSpace
18:07:47 <EvanR> >__<
18:07:59 <Eduard_Munteanu> @src (++)
18:07:59 <lambdabot> []     ++ ys = ys
18:08:00 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
18:08:00 <lambdabot> -- OR
18:08:00 <lambdabot> xs ++ ys = foldr (:) ys xs
18:08:00 <benmachine> :t Data.VectorSpace.getSum
18:08:01 <lambdabot> forall a. Data.VectorSpace.Sum a -> a
18:08:02 <EvanR> :t comeGetSum
18:08:03 <lambdabot> Not in scope: `comeGetSum'
18:08:07 <benmachine> Eduard_Munteanu: lambdabot cheats
18:08:18 <benmachine> @slap EvanR 
18:08:18 * lambdabot clobbers EvanR  with an untyped language
18:08:33 <EvanR> rofl
18:08:46 <Eduard_Munteanu> @vixen Behave!
18:08:47 <lambdabot> what's the last book you read?
18:08:48 <jrockway> unsafeChrom++
18:08:50 <jrockway> so true
18:09:08 <jrockway> this has been the bane of the perl community's existence
18:09:20 <jrockway> there is one corner case in the grammar that makes it impossible to parse without evaluating
18:09:31 <EvanR> just one??
18:09:38 <jrockway> people have wasted many hours whining about how it's impossible to write any static analysis utility, because of this one corner case
18:09:42 <chrisf> "perl is a corner case" :P
18:09:50 <jrockway> someone wrote a parser anyway, that works perfectly 99.99% of the time
18:10:01 <jrockway> and yet people refuse to use it, because IT WOULD VIOLATE THE HALTING PROBLEM
18:10:11 <Eduard_Munteanu> :))
18:10:19 <jrockway> no, it just means it picks the most logical interpretation of the syntax, instead of the one that perl would necessarily pick
18:10:24 <jrockway> it's called guessing
18:10:34 <chrisf> jrockway: the cases where it's nasty/wrong are not particularly interesting?
18:10:41 <EvanR> a language that guesses for you. sounds like intercal or something
18:10:48 <Eduard_Munteanu> ... which is the entire point of a static analysis tool, _guess_ if there are errors
18:10:50 <jrockway> the case has to do with parsing functions invoked without parens
18:11:33 <jrockway> if you write "foo 1, 2 / 3", that could be "foo(1)" or "foo(1,2/3)" depending on how foo is declared
18:11:45 <jrockway> since you can declare functions at runtime, you can make the declaration depend on rand
18:11:50 <jrockway> and thus, it's impossible to parse perl code
18:11:55 <jrockway> but the reality is, it doesn't matter
18:12:04 <BMeph> I prefer: "So people, when confronted with a complicated computation, say, 'Oh, that's okay, I'll just use state.' Now they have two problems." :)
18:12:18 <BMeph> Dang it - *Some people
18:12:23 <danderson> in that if you come up with that horrible edge case, you just declare the program broken and require the programmer to fix it? :)
18:12:40 <shivam3013> Hello.
18:12:45 <digitteknohippie> 'alo
18:12:51 <Eduard_Munteanu> Reflection is tough.
18:13:02 <jrockway> "some people, when confronted with the opportunity to write a correct computer program, decide to whine on hacker news about how writing a correct program means they might have to learn something new and how horrible that would be.  now they are the problem."
18:13:11 <jrockway> (sorry, do i sound bitter about this? i am.  very, very bitter.)
18:13:22 <danderson> heh
18:13:31 <aristid> jrockway: don't be bitter. be happy :)
18:13:39 <danderson> what saddens me right now is that most of the stuff I want to do with haskell is very IOy
18:13:43 * digitteknohippie feels the same as jrockway, and hugs jrockway
18:13:51 <danderson> VPN daemons, file servers...
18:14:08 <EvanR> jrockway: so basically, your coworkers think youre insane / psychotic / a fanboy because you use haskell
18:14:15 <jrockway> nope
18:14:19 <shivam3013> Can anyone here code? Please jrockway don't answer to this question.
18:14:22 <danderson> it feels like I'm cheating on haskell when most of my program runs in IO
18:14:24 <Saizan> funny that the person posting the proof perl is not parseable did it to realize where to focus with its static analysis :)
18:14:29 <jrockway> my coworkers are not morons, they will happily use haskell when required
18:14:32 <EvanR> danderson: you are
18:14:49 <Eduard_Munteanu> shivam3013: I personally found coding very difficult.
18:14:50 <danderson> EvanR: please clarify how one writes to the network or talks to a kernel over netlink without IO :)
18:15:03 <EvanR> well you said 'most of the code ';)
18:15:17 <danderson> well, it feels that way.
18:15:20 <aristid> if the program is very simple, then maybe most of what is needed, is just IO
18:15:33 <danderson> The routing algorithm is all nice and pure
18:15:40 <ezyang> Is there a way to close a file handle before all of its contents have been read? 
18:15:47 <Eduard_Munteanu> OSPF?
18:15:50 <EvanR> hClose
18:15:50 <danderson> but distributing it to the threads routing packets requires IO because of the MVars
18:16:03 <ezyang> EvanR: It doesn't seem to actually be closing the file 
18:16:04 <Eduard_Munteanu> That stuff should be reasonably pure.
18:16:15 <EvanR> er
18:16:16 <danderson> the threads themselves require IO because of the MVars and the network
18:16:25 <danderson> and the supervisor code requires IO because of the concurrency stuff
18:16:37 <EvanR> danderson: you are excused if you use several / many simple worker threads
18:16:39 <ezyang> Maybe I'm misdiagnosing this bug 
18:16:53 <danderson> EvanR: I do, and channels/mvars between them.
18:16:58 <EvanR> thats not really i/o anyway ;)
18:17:12 <shivam3013> Hi, I am hiring programmer for my most recent project, pm me if you are interested.
18:17:13 <danderson> Eduard_Munteanu: BGP actually (just the core protocol, no extensions)
18:17:50 <jrockway> shivam3013: see, that still sounds like spam
18:18:00 <jrockway> why are you asking on #haskell?
18:18:01 <danderson> which I then replaced by a much simpler custom EGP that does just what I need
18:18:15 <danderson> without all the awesome extensibility and internet-proofness of BGP4
18:18:15 <jrockway> is there a specific need for haskell programmers?  are you wondering what channels would be the best place to post job ads?
18:18:18 <shivam3013> Well, this is a programming channel, so...
18:18:33 <danderson> I bet you want to build a social website
18:18:43 <danderson> the next facebook, only better and with farmville, maybe?
18:18:49 <shivam3013> No.
18:18:54 <jrockway> ooh, farmvillebook
18:18:56 <jrockway> sounds like a hit!
18:19:01 <shivam3013> I have been addressed to code a role playing game.
18:19:02 <danderson> we'll make millions!
18:19:09 <danderson> oh, yeah, that's the other one, a video game.
18:19:12 <EvanR> shivam3013: massively multiplayer?
18:19:24 <shivam3013> Yes.
18:19:27 <EvanR> i knew it
18:19:31 <Eduard_Munteanu> Writing games is fun!
18:19:32 <EvanR> well, you can count me in
18:19:32 <danderson> like starcraft 2 meets world of warcraft and half life 2, only better
18:19:35 <Saizan> shivam3013: this is not a general programming channel though, it's specifically about Haskell
18:19:41 <shivam3013> Basically, a web browser based mmorpg.
18:19:56 <EvanR> are you coming up with the worst sounding projects on purpose?
18:20:07 <shivam3013> Yes, although if you guys knew such a complicated language such as haskell, undoubtfully you would be able to help me.
18:20:11 * BMeph runs off to copyright "World of FarmVille"...
18:20:26 <Saizan> :O
18:20:31 <aristid> you can't copyright a sequence of three words
18:20:34 * jrockway creates "World of FarmVille 2"!
18:20:43 <danderson> the Ogre user forums have a running gag that at least one impossible game project recruiting thread will turn up per week
18:20:45 <proq> I think he meant trademark
18:20:45 <Eduard_Munteanu> WOF then? :)
18:20:46 * digitteknohippie wonders if he aught to point out the copyright rightfully defaults to the original artist
18:20:52 <ezyang> My openFile f ReadMode >>= hClose trick doesn't seem to be working 
18:20:58 <Eduard_Munteanu> Ah.
18:21:10 <aristid> also, you automatically get copyright for whatever you do (unless you seize it to somebody else, by way of some contract)
18:21:12 <tensorpudding> Farmcraft: Wrath of the Potato Beetle.
18:21:25 <proq> you don't copyright a name, you trademark it
18:21:28 <shivam3013> Anyone interested>
18:21:39 <Eduard_Munteanu> aristid: I'd be careful with that outside US.
18:21:55 <aristid> Eduard_Munteanu: well, maybe not in nicaragua
18:21:55 <Eduard_Munteanu> I hear some countries are a bit stupid on that.
18:21:59 <Philippa> shivam3013: I think you'll find people are mostly interested in pointing and laughing at you
18:22:08 <Eduard_Munteanu> As in copyright is much harder to prove de facto.
18:22:10 <ezyang> Hello all, please take this to #haskell-blah 
18:22:12 <aristid> Eduard_Munteanu: actually it was the US which long insisted on registering copyrighted works
18:22:21 <proq> Philippa: ssshhh, don't ruin the fun
18:22:41 <danderson> "It'll be an open-ended MMORPG where users can create content without programming and be completely cheat-proof. We anticipate 2 million users within three months of launch, and a million dollars of net revenue within a year. I'm currently the only person on the project, and I can't program, draw, design, market, sell or manage. I'll be the ideas guy!"
18:22:45 <aristid> i forgot the name of the treaty which harmonised basic aspects of international copyright
18:23:02 * BMeph is interested in Net Neutrality, and points and laughs at shivam3013 disinterestedly...
18:23:09 <Eduard_Munteanu> I'll be testing!
18:23:34 <Philippa> aristid: Berne Convention
18:23:42 <etpace> @src last
18:23:42 <lambdabot> last [x]    = x
18:23:42 <lambdabot> last (_:xs) = last xs
18:23:42 <lambdabot> last []     = undefined
18:23:44 <aristid> Philippa: ah, yeah, that was the name :)
18:23:47 <EvanR> ill be the [inserst name of position here], a new position like the producer, only in reverse. i get all the revenue
18:23:59 <Eduard_Munteanu> aristid: yeah, though copyright registration is generally, as you say, just additional proof.
18:24:03 <EvanR> call it the recudorp
18:24:14 <danderson> "I don't know what it'll be about yet, but there'll probably be aliens, spaceships and time travel as a gameplay element. Your role will be to implement my vision, and also run the website on the side. Please send resumes for consideration."
18:24:35 <Philippa> Eduard_Munteanu: it's not even a relevant concept in many jurisdictions
18:24:40 * BMeph exercises some copyrights, to feel the Berne...
18:24:43 <jrockway> he offered me 65% of the profits in query, but he already has "a few coders"
18:24:48 <jrockway> i guess everyone gets 65%
18:24:54 <jrockway> because there is so much money, there is more than 100%!
18:24:55 <proq> haha
18:25:13 <jrockway> i hate disclosing privmsgs to channels, but in this case i think it's necessary
18:25:14 <Eduard_Munteanu> Philippa: I see, that's interesting.
18:25:16 <jrockway> because it's so amusing
18:25:18 <danderson> jrockway: everyone can get 65% of the profits if there are never any profits.
18:25:24 <jrockway> that is what i said
18:25:51 <danderson> it's actually the only solution, assuming everyone gets 65%
18:25:52 <EvanR> i got 65% of the profits 99% of the mmo startups
18:25:59 <danderson> which is not encouraging for the company as a whole
18:26:01 <Eduard_Munteanu> Also don't forget the case concerning losses!
18:26:15 <jrockway> realistically, 65% of maybe a million dollars doesn't excite me that much
18:26:24 <danderson> Eduard_Munteanu: no need to handle that, it'll make millions! Losses are unimaginable!
18:26:28 <shivam3013> ...
18:26:30 <jrockway> i enjoy going to "a job" on a regular basis, and getting the same amount of money every month no matter what
18:26:34 <proq> people looking to hire programmers with absolutely no clue apropos the software world but some "amazing" idea seem to be a dime a dozen nowadays
18:26:37 <shivam3013> 65% of your group profit
18:26:46 <shivam3013> there are approximately 23 groups
18:26:48 <danderson> proq: they always have been
18:26:54 <danderson> ideas are cheap
18:26:55 <Philippa> shivam3013: I /will/ kickban you from here if you mention this once more
18:27:00 <Eduard_Munteanu> danderson: I'd love to work for free on a project where every other member has a gain of 65% of "losses".
18:27:02 <shivam3013> Each with special coders, graphic artists, designers and sound derectors
18:27:05 <Philippa> this is not a recruitment chan for general programming projects
18:27:18 <shivam3013> Philipa, why aren't you operator here too>
18:27:24 <jrockway> that way i can focus on software instead of how to best obtain food for the next few days
18:27:25 <danderson> the drive to turn an idea in a viable product is very, very rare
18:27:42 <danderson> s/ in / into /
18:27:52 <Philippa> shivam3013: I'm sure you can figure out how to ask chanserv if I'm an op here if you really need to
18:28:01 <EvanR> the sad thing is, shivam3013 probably got a few baiters from this channel. a lot more from other channels
18:28:19 <EvanR> like #python or something
18:28:31 <etpace> i doubt it
18:28:34 <etpace> nobody is that dumb
18:28:37 <EvanR> lol.
18:28:38 <jrockway> i've trolled #haskell with actual jobs before, didn't get anything :)
18:28:40 <danderson> hah
18:28:40 <Philippa> you'd be surprised, unfortunately
18:28:43 <danderson> such naiveté :)
18:28:48 * Eduard_Munteanu thinks about doing something really bad...
18:28:59 * Eduard_Munteanu checks if #cobol exists
18:29:08 <danderson> the existence of schmucks (that's a technical term) is the reason "idea people" can still exist
18:29:39 <Philippa> danderson: not always, but they have to be something slightly more than the stereotypical "idea person"
18:29:53 <Philippa> like, they have to have enough clue to understand the other jobs, for one
18:29:58 <proq> danderson: yes, but they seem to be popping up everywhere lately
18:30:00 <EvanR> #tto was a channel on this network about one of these 'idea' mmos. it was populated by at least 3 teenager wannabe coders each month, new ones to replace the ones who got a clue
18:30:05 <danderson> "idea people who can talk good" then
18:30:36 <EvanR> promised profits 'after release'
18:30:43 <danderson> of course
18:30:43 <jrockway> yeah
18:30:55 <danderson> then, one by one, they come across numbers from Blizzard and others
18:30:57 <jrockway> why work for someone else and make no money, when you can work for yourself and make no money instead?
18:31:04 <EvanR> lol
18:31:07 <danderson> and learn how much work it really takes to build a successful MMO
18:31:20 <proq> seriously
18:31:29 <jrockway> but he already "has a couple coders"
18:31:36 <EvanR> oh of course
18:31:36 <jrockway> clearly he is positioned for success
18:31:42 <Eduard_Munteanu> And how "fun" it is.
18:31:43 <jrockway> i mean, have you ever seen a programming project fail?
18:31:44 <proq> or better yet, work for someone else and make gobs of money
18:31:52 <EvanR> of course when i met this guy his 'other coders' left
18:31:57 <proq> and then you can work for yourself and not starve
18:32:04 <Eduard_Munteanu> Now really, some people think that just because the end result is fun, the "doing it" is fun too.
18:32:07 <inimino> "Since you are doing the work I will share 50% of the profits with you even though it is my idea."
18:32:17 <jrockway> haha
18:32:25 <BMeph> danderson: Where, when you say "Blizzard", you mean "Activision", amirite? ;
18:32:32 <jrockway> i was offered 65% because i told him i work at a bank
18:32:32 <danderson> jrockway: programming projects never fail once you have a couple of coders
18:32:36 <jrockway> oh yeah
18:32:39 <danderson> that's the big stumbling block.
18:32:40 <Philippa> *nod*. Real, as in hard, development isn't something you should do for future profit alone
18:32:45 <jrockway> i am such a moron for turning down this job offer!
18:32:47 <danderson> but once you have a couple of coders, well.
18:33:29 <danderson> BMeph: I'm actually not a gamer at all (emacs and a compiler are my favorite toys, I can use them to make other toys!), so, um, yeah, maybe :-)
18:33:34 <Eduard_Munteanu> Or that they're even compatible with the sort of fun doing the thing implies.
18:33:50 <conal> almost done with this blog post...
18:34:05 * EvanR eagerly awaits conal's twitter ;)
18:34:13 <conal> :)
18:34:15 <BMeph> Another conal blog post - w00t! You're on fire, man! :)
18:34:20 <Philippa> once you have a couple of coders you're only down any means of creating the actual content in a game :-)
18:34:23 <danderson> jrockway: so, you work at a bank, therefore you clearly are the expert he's been searching for to implement his MMO?
18:34:31 <danderson> that's some logic there
18:34:42 <jrockway> yeah
18:34:46 <BMeph> conal: ...uh, you're not "really" on fire, though, that's just a saying, right? ;D
18:34:47 <danderson> his brain probably hit some undefined behavior on the way to that conclusion
18:34:52 <EvanR> lol
18:34:52 <Eduard_Munteanu> danderson: absolutely. If he works in a bank, that means he can bring in money!
18:34:59 <Phyx-> danderson: aren't banks MMO? where the objective is to get money? :P
18:35:09 <conal> BMeph: thx :)  a backlog of pent-up writing.  needed a break from obj-c iOS hacking.
18:35:42 <danderson> Phyx-: yeah, but the GUI sucks and you can't buy epic mounts
18:35:46 <proq> Phyx-: something like that, but without the "game" and "fun" part
18:35:58 <danderson> unless there's an awesome part of trading systems I've been missing out on
18:36:10 <Phyx-> proq: sure it's fun... just not for the player :)
18:36:40 <Phyx-> danderson: and the GUI changes ofthen
18:36:45 <BMeph> conal: Whew! I have only snatched glimpses of obj-c from afar, but I can see that it'd be..."work". :\
18:36:50 <jrockway> there is more to finance software than trading systems
18:37:13 <danderson> jrockway: you mean there *are* epic mounts?
18:37:16 <conal> BMeph: yeah.  luckily there are some fun novel aspects.
18:37:31 <conal> i tend to write lisp-ish obj-c.
18:37:41 <danderson> and a PvP arena to resolve differences?
18:37:49 <EvanR> and your cooworkers dont hate you for it? ;)
18:38:03 <Eduard_Munteanu> +10 barter rings :P
18:38:07 <Makoryu> BMeph: You know, Objective-C might be the most widely used dynamically typed compiled language.
18:38:34 <Makoryu> I mean, compiled to native binaries.
18:39:04 <aristid> Eduard_Munteanu: lol
18:39:09 <Philippa> these days, yeah. Once upon a time it would've been one or another basic variant
18:39:25 <Eduard_Munteanu> Anything beyond Cocoa/Mac stuff that still uses obj-c?
18:39:32 <aristid> iPhone
18:39:34 <Makoryu> Nope, just iPhone
18:39:41 <Eduard_Munteanu> Ah.
18:39:42 <aristid> and iPad
18:39:44 <Makoryu> Of course... There are quite a lot of iPhones.
18:39:45 <aristid> and iPod tocuh
18:39:51 <Eduard_Munteanu> Yeah, yeah, all the overpriced crap :P
18:40:06 <aristid> it's overpriced, but no crap:)
18:40:15 <Eduard_Munteanu> Um, I agree.
18:40:27 <EvanR> no its crap
18:40:43 <Makoryu> aristid: There was a memo about all Apple products being crap
18:40:52 <Eduard_Munteanu> It has "interesting" features, but overpriced.
18:41:01 <Makoryu> It was the same memo where Common Lisp and Scheme were declared to no longer be functional languages
18:41:18 <dudes> Hi
18:41:19 <aristid> Makoryu: i guess i must have missed the memo. was it written in Comic Sans MS?
18:41:19 <Saizan> quite a wise memo
18:41:20 <kmc> i think ObjC is a decent language
18:41:23 <kmc> from like three minutes of using it
18:41:35 <dudes> WHAT LANGUAGE DO I NEED TO KNOW TO CODE HARDWARE?
18:41:42 <kmc> don't yell dudes
18:41:46 <dudes> sorry
18:41:46 <EvanR> the caps lock language
18:41:49 <aristid> dudes: VERILOG OR VHDL MIGHT WORK
18:41:52 <kmc> dudes, probably C, and maybe assembly for whatever processor
18:42:06 <kmc> btw dudes this is not a general programming channel, it's about the language Haskell
18:42:07 <dudes> i know some C++
18:42:14 <aristid> kmc: i think he must mean FPGAs
18:42:15 <kmc> what kind of hardware did you want to program?
18:42:15 <Eduard_Munteanu> aristid: :))
18:42:19 <dudes> my bad
18:42:20 <Makoryu> dudes: YOU SHOULD START WITH C, I SUPPOSE. BUT IT REALLY DEPENDS WHAT YOU MEAN BY "CODE HARDWARE." DO YOU INTEND TO MAKE HARDWARE? OR JUST WRITE PROGRAMS FOR MICROCONTROLLERS?
18:42:26 <dudes> i need to program a rfid reader
18:42:34 <dudes> i want to add a 3g connection chip
18:42:35 <Makoryu> dudes: Go to ##C
18:42:45 <dudes> and try to play around
18:42:48 <kmc> dudes, get an Arduino, program it in their language, or in straight up C
18:42:52 <EvanR> nice. sending him into meat grinder
18:42:52 <Eduard_Munteanu> Now that's evil :)
18:42:59 <dudes> what is arduino?
18:43:00 <jrockway> i programmed an AVR in C
18:43:01 <kmc> Arduino is nice and easy
18:43:03 <jrockway> it was painful
18:43:17 <kmc> dudes, a very simple microcontroller development board, plus a language and IDE for it
18:43:20 <kmc> http://arduino.cc/
18:43:28 <dudes> thanks kmc
18:43:33 <kmc> you can probably find all the hardware you need at sparkfun.com
18:43:38 <kmc> or cheaper elsewhere if you look around
18:43:39 <unsafeChrom> price is defined by supply-demand. if sells well, not overpriced.
18:43:40 <jrockway> not as painful as trying to get various common lisp and scheme implementations to compile to code that would fit in its memory, though :)
18:43:42 <dudes> do you think i need an electronic engineer for building the device
18:43:45 <Eduard_Munteanu> BTW, if you want a cheap uC devel board, go for the STM8S. But don't expect widespread usage yet.
18:43:51 <jrockway> dudes: no
18:43:52 <Eduard_Munteanu> just 5$,
18:43:53 <Makoryu> jrockway: Geesh
18:43:54 <dudes> (ie. connecting 3g chip to the rfid reader)
18:43:59 <jrockway> arduino is very newbie friendly
18:44:01 <kmc> dudes, no, that's a very feasible hobbyist project
18:44:11 <dudes> ok kmc
18:44:11 <kmc> Eduard_Munteanu, wow
18:44:18 <dudes> so the input would be the rfid tag
18:44:26 <dudes> and then there is communication going on
18:44:30 <dudes> thru 3g
18:44:36 <dudes> that sounds logic to you?
18:44:36 <kmc> dudes, there are tons and tons of similar projects online, i would just start reading about Arduino projects to see how it works
18:44:37 <Eduard_Munteanu> kmc: yeah, got a few from Farnell a few months back
18:44:40 <aristid> Eduard_Munteanu: the TI launchpad is a few cents cheaper
18:44:54 <Eduard_Munteanu> aristid: didn't know about that, thanks.
18:44:55 <dudes> ok man
18:44:55 <dudes> you saved my life
18:44:55 <dudes> btw
18:44:59 <dudes> where can i check these ongoing project?
18:45:00 <aristid> but i'm still waiting for mine
18:45:04 <kmc> dudes, google
18:45:07 <kmc> imo the hardest part of starting embedded electronics is learning how to read datasheets
18:45:17 <kmc> just like the hardest part of learning to use UNIX is learning how to read manpages
18:45:25 <dudes> yeah, but what should I look for, people name stuff differently
18:45:29 <aristid> Eduard_Munteanu: http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_%28MSP-EXP430G2%29
18:45:40 <unsafeChrom> too bad the hardest part of learning to use an API is not learning how to read API docs
18:45:41 <kmc> dudes, google arduino projects
18:45:46 <kmc> or arduino rfid 3g
18:45:48 <kmc> etc.
18:45:51 <dudes> kmc, ok 
18:46:02 <dudes> kmc, i see what you mean. thanks a bunch
18:46:03 <EvanR> unsafeChrom: it might be... if there are no docs ;)
18:46:04 <jrockway> wow, $4.30
18:46:10 <jrockway> i paid $20 for my teensy :(
18:46:20 <kmc> dudes, btw there is ##electronics on Freenode
18:46:24 <kmc> they are helpful people
18:46:25 <unsafeChrom> if there are no docs, it comes down to reading implementation or cookbook
18:46:51 <kmc> one nice thing about Arduino is that the processor is only $4, and is socketed
18:46:54 <Eduard_Munteanu> Looks nice, here's the STM8S (found it on hackaday too) ... http://hackaday.com/2009/11/23/stm8s-discovery-microcontrollers-reach-a-new-low/
18:46:56 <jrockway> btw, gsm modem: http://www.sparkfun.com/commerce/product_info.php?products_id=8700
18:47:20 <dudes> kmc, i know nothing about electronic
18:47:23 <jrockway> rfid reader: http://www.sparkfun.com/commerce/product_info.php?products_id=8419
18:47:32 <dudes> but god knows i will get onto that as a crazy workaholic
18:47:39 <kmc> sparkfun's tutorial series is good
18:47:42 <danderson> yay, another haskell library successfully open sourced thanks to my awesome employer
18:47:46 <dudes> thanks jrockway
18:47:46 <kmc> "beginning embedded electronics"
18:47:47 <danderson> now, to write documentation for it...
18:47:50 <dudes> God bless you guys
18:47:50 <kmc> cool danderson, which?
18:48:01 <danderson> http://secure-hs.googlecode.com/
18:48:13 <EvanR> danderson: you wrote it at work?
18:48:26 <aristid> Eduard_Munteanu: are there third-party linux tools for these things?
18:48:27 <Eduard_Munteanu> Still, a working Linux compiler would be nice for it.
18:48:37 <jrockway> do you work for google?
18:48:47 <Eduard_Munteanu> aristid: when I last look, there weren't.
18:48:52 <Eduard_Munteanu> *looked
18:48:56 <danderson> very basically, TCP sockets that understand the concept of peer identity, and create strongly authenticated/encrypted connections with no configuration required.
18:49:07 <danderson> a very simple, secure by default wrapper around HsOpenSSL.
18:49:39 <danderson> (actually, right now it's slightly imperfect, the ciphersuite it uses doesn't provide perfect forward secrecy, because HsOpenSSL doesn't have the binding to set DH parameters)
18:49:55 <aristid> Eduard_Munteanu: k without linux support it's a total no-go IMO
18:49:57 <danderson> EvanR: yes, a brick of my 20% project
18:50:03 <danderson> jrockway: yes
18:50:04 <aristid> Eduard_Munteanu: because linux is my ONLY os
18:50:20 <EvanR> danderson: does your employer have to also authorize givaway of stuff you write at home?
18:50:27 * BMeph thought the hardest part of using Unix was telling your mother you're gay...
18:50:41 <dudes> lol
18:50:45 <Eduard_Munteanu> aristid: should be possibly to install the tools under Wine. IIRC I went through the install, but didn't actually find time to play with it.
18:51:18 <aristid> Eduard_Munteanu: i'd rather get one of these arduino thingies then
18:51:21 <Eduard_Munteanu> However, since Linux is my only OS too, I'd rather have native tools.
18:51:33 <aristid> Eduard_Munteanu: but the TI (i haven't received it yet) seems to have linux tools
18:51:43 <danderson> EvanR: depends who you ask. I bypass the issue because I write only open source code at home, and it's exceedingly easy for me to open source it via my employer
18:52:02 <Eduard_Munteanu> aristid: "There is currently no official support for the Linux operating system. IAR Embedded Workbench does work under WINE in Ubuntu 10.04 but the LaunchPad itself doesn't map to a /dev/ttyUSB* port but rather to /dev/ACM0. Linking com1 under WINE to ACM0 doesn't allow for a debug connection through the IDE. "
18:52:04 <EvanR> :\
18:52:10 <jrockway> i think it's generally accepted in the US that your employer can't prevent you from doing stuff at home
18:52:19 <EvanR> is that true?
18:52:22 <Eduard_Munteanu> aristid: but there are a few links to something called mspgcc on the page you gave me.
18:52:29 <jrockway> if you are a house painter, you are allowed to paint your friend's house for free on your own time, if you want to
18:52:34 <jrockway> why would programming be any different?
18:52:35 <Eduard_Munteanu> (I'm referring to TI)
18:52:36 <danderson> jrockway: in California specifically, "we own all ur ideas" clauses in contracts are unenforceable
18:52:50 <aristid> Eduard_Munteanu: yeah i know, mspgcc is what i mean
18:52:51 <danderson> anything you develop on your own time not using company resources is yours.
18:52:55 <aristid> Eduard_Munteanu: i don't care about the IDE
18:52:58 <jrockway> yeah, and employers seem to have stopped putting them in
18:52:59 <EvanR> jrockway: because you signed a contract that said so
18:53:03 <proq> you could always talk to your employer about it beforehand
18:53:07 <jrockway> i worked at small companies that hard contracts like that
18:53:12 <aristid> Eduard_Munteanu: heck, i might even generate bytecode from haskell if i can pull that off :)
18:53:14 <Eduard_Munteanu> Yeah, just being able to write a Makefile would be nice.
18:53:18 <Eduard_Munteanu> Heh.
18:53:22 <jrockway> but i work at a huge megacorp with a billion lawyers, and it wasn't in there
18:54:03 <Eduard_Munteanu> danderson: I thought I've seen you on the ML or IRC channel. I'm a GSoC student there.
18:54:05 <aristid> jrockway: a huge megabank?
18:54:10 <jrockway> the hugest!
18:54:14 <jrockway> (actually, probably not)
18:54:22 <BMeph> jrockway: Odd; it was in mine, and I'm not even in the SW section.... :\
18:54:29 <danderson> but as I said, in my case, I don't care. I write open source code and work for an open source friendly company, so I just put everything through the open sourcing process.
18:54:41 <proq> I told one company I was working on some projects at home and they offered me a raise
18:54:54 <EvanR> why?
18:54:55 <jrockway> nice, that's the way to do it
18:55:04 <EvanR> oh, work projects
18:55:06 <dons> proq: huh
18:55:11 <proq> EvanR: they were afraid I was going to leave and start on my own company
18:55:29 <jrockway> i like it when employers are afraid of employees
18:55:33 <jrockway> that's the way it should be :)
18:55:48 <EvanR> unless youre the employer :(
18:56:35 <jrockway> the market has decided
18:56:39 <danderson> so, anyway, as I was saying, yay, my code can now be used to shame me in public!
18:56:40 <jrockway> there are a lot of places that need software
18:56:50 <jrockway> but there aren't very many people that will do a good job making that software
18:56:52 <jrockway> hence, fear
18:57:01 <EvanR> do people care?
18:57:16 <danderson> (particularly the awful bit that shells out to `openssl` to generate certificates, because openssl makes it so horribly difficult to programmatically generate and sign a cert correctly)
18:57:17 <jrockway> does anyone care about anything? is there any meaning in life?
18:57:40 <jrockway> danderson: heh, i think i had the same problem and came up with the same solution once :)
18:57:56 <danderson> jmcarthur: I did try for about two days to generate it programmatically.
18:58:00 * unsafeChrom is tempted to @remember jrockway does anyone care about anything? is there any meaning in life?
18:58:04 <danderson> the cert looked valid, and `openssl` could print the details
18:58:26 <danderson> but any attempt to build a secure connection using it ended in "certificate verification failed"
18:58:39 <Eduard_Munteanu> Didn't Oleg write some OpenSSL replacement?
18:58:53 <jrockway> gTLS?
18:59:08 <danderson> so I decided it wasn't worth the time to figure out and HSH'd to the binary that has the embedded knowledge of the Great Old Ones
18:59:17 <Eduard_Munteanu> There was something he was using as an example in his paper on configurations.
18:59:59 <danderson> the annoying thing about SSL is that, looking at the spec, every piece of it makes sense in terms of being extensible, secure, and so forth
19:00:13 <danderson> and yet implementations are always awful to use, somehow
19:00:27 <conal> New blog post: "Topless data".  http://conal.net/blog/posts/topless-data/
19:00:58 <Eridius> damnit conal, you've been posting far too much lately :p
19:01:05 <c_wraith> Conal, somewhat less nudity than I was hoping for. About as much as I was expecting, though. :)
19:01:19 <conal> :) !  taking a break from iOS programming helps.
19:01:28 <conal> c_wraith: yeah, sorry about that!
19:02:20 <proq> c_wraith: nah.  topless data is very sexy
19:02:46 <c_wraith> ah, now that I've read the intro, this is on a topic I've thought about idly before.  I'm interested to see what you've found :)
19:03:25 <conal> cool.
19:03:44 * EvanR presses play on tape "porno music"
19:09:16 * BMeph starts up: "Bow Chicka Bow Wow"... ;)
19:09:29 <EvanR> i couldnt figure out how to spell that ;)
19:11:43 * BMeph watches a lot of "Red vs. Blue".
19:11:53 <EvanR> lol
19:18:31 <dancor> conal: is there a brief way to sum up what is "wrong" with yampa
19:20:20 <conal> dancor: is there something wrong with yampa?
19:24:05 <Philippa> well, it uses all those icky arrows and that reactimate function's a PITA and...
19:24:07 <Philippa> (HHOS, there)
19:25:34 <dancor> "nothing" is pretty brief i guess :)
19:26:23 <Philippa> I think I'd rephrase as "what trade-offs did it make that one should be aware of when choosing an FRP lib?"?
19:31:32 <dancor> i wonder if other FRP libs have low enough overhead to do software audio synth
19:32:43 <kmc> for most audio stuff, latency will be more of an issue than computational throughput
19:32:50 <kmc> and you might could solve that with big buffers
19:33:01 <Philippa> not if the computational throughput's done in a really fuckwitted-for-the-purpose manner
19:33:19 <kmc> true enough
19:33:20 <EvanR> bigger buffers means more latency
19:33:30 <kmc> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.4489
19:33:42 <Philippa> for synthesis you also want room to write explicit discrete generators, too
19:34:01 <EvanR> i have asked about real time audio stuff in haskell before...
19:34:05 <Philippa> modelling everything as continuous is all well and good, but you care about the implementation details the moment you start turning that into samples
19:34:06 <EvanR> does it exist
19:34:21 <kmc> i meant latency getting audio to the hardware, resulting in choppy output
19:34:23 <Philippa> EvanR: I'm pretty sure it's been done for at least something
19:34:49 <conal> if i wanted a lot of speed, i'd go for a deep embedding rather than a shallow one, so i could generate optimized code.  as in Pan & Vertigo & related systems.
19:35:02 <kmc> if you're doing something interactive, big buffers are infeasible due to a different sort of latency
19:35:08 <EvanR> "haskell" has i think never been uttered in #lad before ;)
19:35:09 <Philippa> eh, these days your initial embedding should be through a type class
19:35:26 <conal> dinner time for me.  later, folks.
19:35:46 <kmc> iirc, there are people doing "high-frequency" stock trading in Haskell, who said they were sensitive to latency on the 1 ms scale
19:36:02 * hackagebot appar 0.1.2 - A simple applicative parser  http://hackage.haskell.org/package/appar-0.1.2 (KazuYamamoto)
19:36:14 <kmc> which... plenty of stock trading is sensitive to latency on the 1 µs scale, but a std dev of a few ms should be fine for audio
19:36:17 <Philippa> and yeah, you'll want something you can analyse the structure of, but that's not where I'd be seeing big issues to start with, at least not if you care about quality
19:37:33 <dancor> aha conal wrote vertigo
19:38:07 <EvanR> kmc: unless were talking about an interactive system, theres no real room for error in digital audio. your sample buffer is going to be filled whether youre ready or not. if it is, everything is perfect, if it isnt you get dropouts
19:39:10 <kmc> true
19:39:12 <dancor> i'm interested in interactivity
19:39:14 <kmc> it's more hard-rt than stock trading
19:39:24 <kmc> even though the event rate is lower
19:41:03 <EvanR> on the other hand, the cell phones get around this, if it cant be filled they do some crazy prediction or something that makes you sound like a robot ;)
19:41:17 <EvanR> disclaimer i have no idea how cellphones work :(
19:41:23 <kmc> haha
19:43:02 <kmc> voice communication by phone is awful
19:43:16 <kmc> it is pretty much the worst mode of communication in common use
19:43:32 <Philippa> dancor: I guess start out by writing a simple oscillator+amp+envelope monosynth, toy around with a few libraries to see how it goes?
19:44:42 <Philippa> dancor: you'd have to make a decision about modulation signals and how often they get read and fed into your other blocks, I guess
19:46:27 <sshc> Can a random value be generated for *any* type, or only within a typeclass?
19:47:08 <sshc> My copy of RWS seems to suggest the former in chapter 15, in which Supply and MonadSupply is defined.
19:47:16 <ClaudiusMaximus> how do you go about debugging -XTemplateHaskell when you can't 'reify' in IO (for example, in GHCI)?
19:47:48 <Philippa> ClaudiusMaximus: printf the ASTs you splice?
19:48:02 <kmc> you can make a "tracing splice"
19:48:08 <Philippa> yeah, exactly
19:50:23 <aristid> sshc: i can prove that it is not possible if you don't want bottom to be generated :)
19:50:27 <Gracenotes> the argument order for folds doesn't make much sense for composing multiple folds
19:50:43 <Gracenotes> but that's not what it's used for. usually.
19:50:59 <aristid> :t foldr
19:51:01 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:51:01 <Saizan> ClaudiusMaximus: $(stringL . show =<< reify 'Foo) also works
19:51:07 <Saizan> ClaudiusMaximus: in ghci i mean
19:51:28 <Saizan> -ddump-splices is also useful, though it doesn't produce valid haskell code..
19:52:59 <ClaudiusMaximus> i figured out one way:  > let tr a = traceShow a undefined
19:53:16 <ClaudiusMaximus> then: > $(tr =<< environment =<< [t| forall a . Maybe a |] )
19:53:16 <ClaudiusMaximus> [(Data.Maybe.Maybe,([a_1627398555],HTUnion [(Data.Maybe.Nothing,[]),(Data.Maybe.Just,[HTVar a_1627398555])]))]
19:53:46 <ClaudiusMaximus> Saizan: thanks, looks cleaner than my attempt
19:56:49 <ClaudiusMaximus> Saizan: almost perfect - just needed stringE instead of stringL for my testing
19:57:39 <Saizan> ah, true, stringL needs an additional litE
19:58:13 <Saizan> s/stringE . show/lift/ also works, given a Lift instance
20:03:09 * hackagebot rpf 0.2.2 - Receiver Policy Framework  http://hackage.haskell.org/package/rpf-0.2.2 (KazuYamamoto)
20:11:29 <interferon> Is it fair to say that map is just a special case of fold (i.e. map f = foldr (\x xs -> f x : xs) [ ] 
20:11:40 <askhader> interferon: Sure.
20:11:48 <danderson> not only fair, it's correct
20:11:53 <interferon> Nice
20:12:14 <interferon> Was looking at iterates and starting to realize how general the fold operator is
20:12:20 <kmc> yeah, that's a nice one
20:12:33 <kmc> fold is so general that you don't even need lists ;)
20:12:59 <kmc> you can represent a list xs as (\f z -> foldr f z xs)
20:13:06 <kmc> which is the church encoding i believe
20:13:53 <interferon> Huh.
20:14:12 * hackagebot gsc-weighting 0.1 - Generic implementation of Gerstein/Sonnhammer/Chothia weighting.  http://hackage.haskell.org/package/gsc-weighting-0.1 (FelipeLessa)
20:14:16 <Saizan> "recursive types for free"
20:14:40 <kmc> a way to implement lists in languages with only functions, i.e. the lambda calculus
20:15:03 <interferon> Can anyone recommend a good FRP tutorial?  I want to write a simulation and I don't want to give in to mutable state :)
20:16:03 <interferon> kmc: so fold was known when Church was working?
20:16:12 <kmc> nil = λf z → z; cons = λx xs f z → f x (xs f z)
20:16:18 <kmc> yeah i think so
20:16:22 <kmc> don't know when the name came around
20:17:53 <Saizan> this encoding is quite inefficient for things like tail though
20:31:53 <Gracenotes> hm. what's a good data structure storing partition information for a ByteString? i.e. the string is divided up into sections [    ][ ][    ][  ] each with a known starting index. from a given index, then, how to get the starting and ending indices of the range it's in? I suppose a Set has splitMember.. that might be enough...
20:35:39 <danderson> would it be an acceptable use of -cafe to ask for a library documentation review, prior to uploading that library to hackage?
20:35:59 <danderson> to save on version bumps to fix docs.
20:37:22 <Saizan> assuming you put it somewhere else equally accessible.. though version bumps are free!
20:38:19 <Saizan> (it might also happen that your package won't build on hackage for some reason, so you're forced to put the docs somewhere else anyway :)
20:38:28 <danderson> yeah, I'd just like at least one other pair of eyes on it before the initial version is frozen into immortality :)
20:47:12 <ezyang> Mister Eric Mertens, I don't understand your API. 
20:48:56 <ezyang> Oh, it looks like Iavor is a co-conspirator. 
20:49:08 <ezyang> I guess I'll shake 'em down tomorrow. 
20:50:10 <kmc> "Haskell, as you may or may not know, is a wildly popular functional language which, though rarely used in business, has attracted a fanatic following of hipsters. #Haskell on Freenode is that IRC network's second most-populated language-specific channel, with over 600 users on average. The channel is second only in size to #Java."
20:50:53 <mtnviewmark> Woo-hoo! I'm a hipster!
20:51:22 * hackagebot gsc-weighting 0.1.0.1 - Generic implementation of Gerstein/Sonnhammer/Chothia weighting.  http://hackage.haskell.org/package/gsc-weighting-0.1.0.1 (FelipeLessa)
20:57:33 <orclev> quick question, and it kills me that I used to know the answer to this one... how do a get an instance of Data for UTCTime? trying to derive Data on a type that has an instance of UTCTime and it's pitching a fit
20:59:24 <kmc> {-# LANGUAGE StandaloneDeriving, DeriveDataTypeable #-} deriving instance Data UTCTime
20:59:31 <kmc> usual caveats about orphan instances apply
21:00:08 <orclev> hmm... I think I tried that and ran into some sort of issue if I remember, but I'll give it a shot... brb 
21:01:01 <conal> sometimes when people compare their language to haskell, i replace "haskell" with "math" or "precision of meaning", and it reads about the same.
21:01:40 <kmc> you can also write a Data instance yourself
21:01:48 <kmc> i don't think it's dangerous like writing your own Typeable instance is
21:02:53 <kmc> conal, are you working on functional graphics for iPad?
21:03:08 <orclev> hmm, is there no standard instance of Data DiffTime or Data Day either?
21:03:12 <dibblego> the haskell channel has about 1.5-2 times more users than the java channel
21:03:42 <orclev> as someone that gets paid to write Java I can say with authority that's because Haskell is cooler
21:04:05 <conal> kmc: i've been working on two things: functional gpu programming as a deep haskell dsel, and supporting code on the iPhone/iPad side.
21:04:13 <dibblego> I get paid to write Haskell, in a company of people who get paid to write Java
21:04:18 <ezyang> orclev: It might not be a bad idea to ask the appropriate library maintainers to add those instances. 
21:04:19 <kmc> cool
21:04:29 <kmc> does that mean your DSEL will output ObjC or such, that runs on iPad?
21:04:45 <conal> kmc: better yet: glsl.
21:04:59 <kmc> ah, right
21:05:00 <conal> which is much faster
21:05:16 <conal> and gets by apple's restriction of no code downloading.
21:05:23 <conal> and no code-gen.
21:05:43 <conal> because *all* opengl programming on iOS is dynamic code-gen.
21:06:05 <kmc> but apple's policy is really "we will reject your app if we feel like it"
21:06:17 <kmc> any do's or don't's are just guidelines they may or may not follow
21:06:19 <conal> kmc: yeah. :p
21:06:38 <conal> i want to start learning android soon.
21:06:42 <kmc> anyway it sounds like a cool project, i hope someday i will be able to use it on a less hostile platform
21:06:43 <conal> for that reason.
21:07:23 <orclev> I've been trying to figure out how to ditch my iPhone GS for a Droid X2
21:07:24 <conal> i keep wondering when to bail on iOS altogether.
21:07:45 <orclev> but I can't bring myself to sign up with Verizon
21:08:13 <conal> i'd love to collaborate on functional android programming.
21:08:31 <dibblego> conal, how could you use Haskell for android?
21:08:35 <kmc> if you are interested in user base, for money or exposure or whatever else, you can't ditch iOS
21:08:47 <orclev> hmm... does android expose anything but JVM APIs?
21:08:57 <kmc> orclev, only for a few things, like OpenGL
21:09:06 <dibblego> some people are using Scala on android
21:09:33 <conal> dibblego: one way: generate java code, as i did for htttp://conal.net/Pajama .  another: generate glsl shaders.
21:09:34 <orclev> kmc: I don't know, there's a lot of rumbling that iOS is starting to lose major share to android
21:09:41 <kmc> conal, sounds great, i hope to have ghc cross-compiling to android soon
21:09:46 <kmc> it already works for simple stuff
21:09:52 <kmc> working now on getting the threaded RTS to run
21:09:55 <conal> kmc: squee!!
21:09:59 <kmc> :)
21:10:14 <kmc> orclev, cool, is it backed by numbers?
21:10:31 <kmc> it makes sense they'd lose share -- iPhone had no credible competitors, now it does
21:10:45 <kmc> it is really amusing to look back at how bad smartphones were before iPhone
21:11:18 <kmc> even though i've no love for iPhone, it got the ball rolling
21:11:31 <conal> i switched from linux to mac last year in order to program iOS.  now with the apple restrictiveness and the brokenness of haskell graphics & guis on mac os x, i'm afraid i have the worst of both worlds.
21:11:32 <orclev> kmc: I'd have to go find the article but it did show that pretty much everyone but iOS was gaining share
21:11:40 <conal> well, windows would be worse still.
21:12:12 <Eridius> orclev: all such comparisons were omitting iPod touches and, more notably, iPads
21:12:18 * orclev sighs.
21:12:23 <kmc> conal, fortunately mac hardware can run linux and windows easily these days
21:12:30 <orclev> can't derive Data for UTCTime
21:12:50 <kmc> Eridius, fair enough, if it's for phone share.  though, what is a 'phone' is becoming increasingly blurred
21:12:53 <orclev> or more accurately, can't derive Data for DiffTime as it's not exposed
21:12:57 <kmc> aww
21:13:07 <kmc> then you can write your own instance, and make DiffTime abstract
21:13:12 <dancor> orclev: does http://hackage.haskell.org/package/time-extras help
21:13:13 <kmc> (or make UTCTime itself abstract if you like)
21:13:21 <conal> i've quit working on haskell graphics & guis while waiting for the cross-platform situation to improve.
21:13:32 <conal> which is a shame.
21:13:47 <kmc> orclev, see for example the instance for Data in http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/src/Data-Map.html
21:13:49 <Eridius> conal: you could try improving the situation... ;)
21:14:07 <orclev> dancor: installing time-extras now... I really hope that solves this problem
21:14:10 <kmc> conal, what about the Web as a platform
21:14:16 <conal> Eridius: i could, but it'd spread me too thin.  not playing to my strengths.
21:14:21 <dancor> time will tell
21:14:23 <kmc> EDSLs generating JavaScript, <canvas>, WebGL
21:14:26 <kmc> could go somewhere
21:14:33 <kmc> tryhaskell.org has some graphics capability
21:14:54 <conal> kmc: i'd love to if i knew a way to get generated gpu code to run on the web client.
21:15:00 <ezyang> I'll once again repeat: everyone wants instant gratification, but the long-term sustainable solution is to fix upstream :-) 
21:15:24 <dancor> WebCL in our future?
21:15:29 * hackagebot approximate-equality 1.0 - Newtype wrappers for approximate equality  http://hackage.haskell.org/package/approximate-equality-1.0 (GregoryCrosswhite)
21:15:53 <kmc> conal, ah, good point
21:16:03 <orclev> dancor: thanks, that was exactly what I needed
21:16:30 <dancor> nice
21:16:39 <conal> someone said (sigfpe?): if you're crunching numbers on a cpu, you're doing it wrong.
21:17:08 <Eridius> conal: I assume when you said "no code-gen" earlier, you meant at runtime, right?
21:17:35 <conal> Eridius: i did, yes.  the offline code-gen story is fuzzier, iiuc.
21:17:39 <Eridius> I'm really hoping Apple will come up with a solution to that. The main problem right now is malloc'd pages are not allowed to be marked executable, which is a fairly important security restriction
21:18:02 <Eridius> however, Android's JavaScript interpreter has already eclipsed Safari, and I'm not sure Apple can catch up until they figure out some way to let Safari run a JIT on the JS
21:18:20 <Eridius> so that gives me at least some hope that they're working on a solution to allow code-gen at runtime without breaking the security model
21:18:54 <kmc> won't the solution likely involve letting only Safari set that bit?
21:19:19 <Eridius> kmc: any app is allowed to embed a UIWebView. It would look very strange if Safari could run JS faster than other apps.
21:19:26 <conal> i do also want some cpu-side code-gen, for set-up to the cpu code.  for instance, computations of values that are constant across a gpu program execution.
21:20:10 <conal> if those computations have to go into gpu code, they get redundantly executed.  i don't have a solution to that problem now.
21:20:43 <Eridius> conal: btw, have you filed a radar asking for code-gen? Every voice counts
21:20:48 <Eridius> (radar being Apple's bug reporteR)
21:21:14 <conal> Eridius: no.  i assumed it was a lost cause.
21:21:28 <Eridius> it may be, but every bug report does count.
21:21:37 <Eridius> the more people who request it, the more effort they'll spend trying to find a solution
21:21:38 <conal> ah
21:22:13 <orclev> near as I can tell Apple doesn't actually care... his Stevey-ness just adjusts his reality distortion field accordingly
21:22:22 <dancor> the problem is that on iOS you can't execute runtime-generated code?
21:22:27 <Eridius> bug reports from third-party devs get weighted far higher than from Apple people, and duplicates are counted sort of like votes. The more dupes a radar has, the higher priority it becomes
21:22:47 <Eridius> dancor: yep. You can't set the execute bit on writable memory
21:25:13 <dancor> does that protect the phone owner or apple's control
21:25:23 <Eridius> the phone owner. It's part of the security model
21:25:33 <Eridius> it basically prevents the entire class of overrun/underrun bugs
21:25:45 <dancor> ok
21:25:48 <kmc> eh
21:25:51 <kmc> it protects both
21:26:18 <Eridius> kmc: it really has nothing to do with Apple's control
21:26:55 <dancor> well it might be somewhat easier to audit things that can't have that level of dynamism
21:27:33 <Eridius> dancor: true, it does make the static analysis a bit easier, but it's still possible to hide things from the static analyzer
21:27:34 <kmc> i guess it doesn't matter since they also ban "interpreters"
21:27:43 <kmc> (what kind of program isn't an interpreter, anyway?)
21:27:57 <kmc> does apple actually run static analysis tools on submitted apps?
21:27:59 <Eridius> kmc: they've loosened that restriction a bit
21:28:01 <Eridius> yep
21:28:06 <kmc> ha
21:28:16 <kmc> well... if they add a check for it, it will be trivial for them to detect ghc-compiled apps
21:28:23 <Eridius> they catch all sorts of things that way, most notably usable of private APIs
21:29:34 <ClaudiusMaximus> hmm, suppose i have a monad for "state with multiple results" -} newtype P a = P { unP :: PS -> [(PS, a)] }  {- and i now need to turn it into a monad transformer so i can lift things into a Q monad, how do i do that?
21:30:10 <dancor> the monadic child of List and State?
21:30:27 <ClaudiusMaximus> dunno, i didn't write it!
21:30:41 <etpace> Has anyone here been able to get dyre to load a new config after recompilation?
21:30:52 <etpace> It claims a success message, but doesn't actually do it
21:30:55 <ClaudiusMaximus> i'm trying to hack djinn to work with template haskell so i don't have to write so much boilerplate
21:32:25 <ClaudiusMaximus> and the problem is i need    newSym :: String -> P Symbol  to use    newName :: String -> Q Name
21:32:48 <ClaudiusMaximus> s/the problem/the current immediate problem/
21:33:55 <kmc> @unmtl ListT (State s) a
21:33:55 <lambdabot> s -> ([a], s)
21:34:04 <kmc> @unmtl StateT s [] a
21:34:04 <lambdabot> s -> [(a, s)]
21:34:46 <kmc> ClaudiusMaximus, probably «newtype PT m a = PT { unPT :: PS -> m [(PS, a)] }»
21:34:54 <kmc> then you need to write an instance of MonadTrans
21:34:55 <kmc> :t lift
21:34:57 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
21:35:29 <ClaudiusMaximus> kmc: cool, i'll have a go at that :)
21:35:39 <kmc> but as i hinted above, you could scrap the custom monad and write it as «StateT PS (ListT m) a»
21:37:02 <ClaudiusMaximus> mm, i think i'd be scared that it might behave differently - but if it's one line then it's worth a shot
21:37:56 <kmc> *shrug*
21:37:59 <ClaudiusMaximus> the monad implementation is about 1/3 of the way down this: http://www.augustsson.net/Darcs/Djinn/Djinn/LJT.hs
21:38:05 <kmc> btw i like this idea ;)
21:38:11 <ClaudiusMaximus> kmc: :)
21:38:16 <kmc> do you plan to scan the file for definitions to make djinn aware of them?
21:38:45 <ClaudiusMaximus> no, just the types so far..
21:38:57 <ClaudiusMaximus> ..maybe add more once i get it to compile/work
21:42:04 <ClaudiusMaximus> which is the correct ListT ? i've heard there's a few different ones
21:42:42 <Cale> LogicT works properly
21:43:25 <ClaudiusMaximus> is the explanation simple?  if so i'd like to know, otherwise i'll just use it in bliss
21:44:31 <Cale> Well, I think there's a paper about how it works.
21:44:55 <Cale> http://okmij.org/ftp/papers/LogicT.pdf
21:45:11 <ezyang> What is the Church encoding of a list? 
21:45:24 <Cale> The ListT in mtl is not really a monad transformer, since much of the time, it doesn't really give you something which satisfies the monad laws.
21:45:34 <ezyang> oh, look, Wikipedia says... 
21:45:47 <Cale> ezyang: things like  (\nil cons -> cons 1 (cons 2 (cons 3 nil)))
21:46:16 <ezyang> That's very clear, thanks :-) 
21:54:10 <kmc> it's a function which calls foldr on that list
21:55:59 <Saizan> said function is how to go from [] to the church encoding, to be pedant :)
21:56:46 <Saizan> "\list -> list [] (:)" is the other side of the isomorphism
22:10:10 <ezyang> I wonder... if I create 2^32 distinct data types, does GHC run out of labels? 
22:10:17 <kmc> one way to find out
22:10:40 <copumpkin> ghc becomes unusable way before that
22:10:43 <kmc> each type will get its own info table, which will be at least a few words of memory
22:11:07 <kmc> so i think on a 32-bit machine you'd run out of vm at like 2^29 or fewer types
22:12:39 <wioux> thats what, a ~55-60k GB source file?
22:13:14 <wioux> more..
22:13:40 <geheimdienst> -55 kilo gigabytes? sounds scary
22:14:15 <BMeph> Wow...you really *could* get yourself molested by a peta(byte) file... <insert rimshot here> ;
22:14:19 <wioux> rough (under) approx. with ASCII
22:14:21 <kmc> jiggabytes
22:15:03 <EvanR> 1. 21 jiggawatts
22:17:31 <wioux> BMeph: 55k GB isn't even close to 1 petabyte :P.. but.. ::rimshot::
22:22:29 <dancor> compile takes 90sec here with 100k data An = An
22:22:44 <BMeph> wioux: Eh, off by what, 17, 18. So it'd have to be "several" instead of "few".
22:23:59 <dancor> i guess the worst part is that the ghc run is single-threaded
22:25:49 <EvanR> :t su
22:25:49 <lambdabot> Not in scope: `su'
22:25:51 <EvanR> :t subtract
22:25:51 <dancor> if 1M is 10min and 1G is 10k min that's a week
22:25:52 <lambdabot> forall a. (Num a) => a -> a -> a
22:25:56 <dancor> so that's pretty unusable
22:26:05 <EvanR> > (+1) 8
22:26:06 <lambdabot>   Ambiguous occurrence `+'
22:26:06 <lambdabot>  It could refer to either `L.+', defined at <local...
22:26:16 <EvanR> >_>
22:26:23 <EvanR> > (1+) 8
22:26:24 <lambdabot>   Ambiguous occurrence `+'
22:26:24 <lambdabot>  It could refer to either `L.+', defined at <local...
22:26:28 <dancor> @undef (+)
22:26:32 <EvanR> > (+1) 8
22:26:33 <lambdabot>   9
22:26:39 <EvanR> whose the wise guy
22:26:44 <EvanR> > (- 1) 8
22:26:45 <lambdabot>   -1
22:26:50 <EvanR> > (1 -) 8
22:26:51 <lambdabot>   -7
22:27:01 <EvanR> eh?
22:27:02 <dancor> @vixen Which one of you did it?
22:27:03 <lambdabot> first you tell me.
22:27:14 <geheimdienst> > (-1) 2 3 4
22:27:15 <lambdabot>   -1
22:27:16 <dancor> > (\ x -> 1 - x) 8
22:27:17 <lambdabot>   -7
22:27:28 <geheimdienst> > ord 'X' 2 3 4
22:27:29 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t3 -> t'
22:27:29 <lambdabot>         against inferred...
22:27:39 <EvanR> > dec 8
22:27:40 <lambdabot>   Not in scope: `dec'
22:27:50 <EvanR> > succ 8
22:27:51 <lambdabot>   9
22:27:52 <geheimdienst> why does the unary minus eat all the arguments?
22:27:57 <EvanR> > pred 8
22:27:58 <lambdabot>   7
22:27:59 <geheimdienst> > (-1) 2 3 4
22:28:00 <lambdabot>   -1
22:28:00 <EvanR> > pred 0
22:28:01 <lambdabot>   -1
22:28:33 <c_wraith> geheimdienst, that's because of some lambdabot craziness
22:28:43 <c_wraith> lambdabot has a Num instance for functions
22:28:46 <c_wraith> So..
22:28:50 <c_wraith> > 5 2
22:28:51 <lambdabot>   Ambiguous type variable `t' in the constraint:
22:28:51 <lambdabot>    `GHC.Num.Num t' arising f...
22:29:05 <c_wraith> > 5 2 + 3 4
22:29:06 <lambdabot>   8
22:29:39 <EvanR> i will now learn arrays
22:30:24 <c_wraith> That's an odd statement.  It's kind of like "I will now learn to type a new word"
22:30:38 <EvanR> yep
22:30:43 * geheimdienst will now learn
22:30:53 <c_wraith> Arrays are just an API, with a few tradeoffs between some different ones.
22:31:03 <EvanR> crap its not in hackage
22:31:22 <EvanR> http://hackage.haskell.org/package/array-0.3.0.1
22:31:23 <EvanR> nevermind
22:31:59 <EvanR> do i want Array or IArray
22:32:10 <c_wraith> you want either IArray or MArray
22:32:21 <c_wraith> depending on whether you want truely mutable arrays or not
22:32:55 <EvanR> i dont understand MArray
22:33:08 <c_wraith> MArray is the interface for mutable arrays
22:33:10 <EvanR> i doesnt require IO ?
22:33:23 <c_wraith> It requires any monad that can implement the interface.
22:33:42 <c_wraith> IO and ST are the obvious ones
22:33:43 <EvanR> but it only makes sense for ones that can implement it efficiently
22:33:58 <c_wraith> But any monad that wraps IO or ST will also work
22:34:09 <EvanR> anyway, i want immutable arrays
22:34:25 <EvanR> im cool like that
22:34:37 <kmc> immutable arrays are great as long as you don't want to update them
22:35:04 <c_wraith> They're even great if you update them very rarely, in comparison to the number of lookups.
22:35:26 <EvanR> its going to be a 2d grid of bools, to represent the walls of the level
22:35:30 <EvanR> which are static
22:35:53 <EvanR> so you need a new array on level change
22:36:01 <kmc> seems reasonable
22:36:32 <EvanR> crap... what if i want moveable walls...
22:36:35 <kmc> crap
22:36:36 <EvanR> or destructable
22:36:40 <EvanR> lol
22:36:56 <kmc> btw (UArray Bool) will be a lot more space-efficient
22:36:58 <EvanR> ill represent them separately
22:37:16 <wioux> what kind of game are you making?
22:37:29 <aavogt> Position -> Bool  or  Map Position Bool can work too
22:37:30 <EvanR> i bet it wont be a big hassle to switch to UArray if its too slow
22:37:42 <kmc> yeah
22:38:05 <c_wraith> All you have to do is change type signatures, assuming you used a smart constructor that's part of the interface, like...  whatever the fromList equivalent is
22:38:09 <EvanR> i expect to do this operation, starting from (x,y) go (0,+1) for instance until you hit a wall
22:38:21 <EvanR> i had this amazing flash of insight that an array would be the most efficient way
22:39:07 <EvanR> wioux: arcade run and shoot
22:40:12 <EvanR> does strict / non strict matter?
22:40:23 <kmc> unboxed strict arrays can take a lot less space
22:43:30 <scotty> Can lazy ByteStrings be just as efficient as strict ones?  I don't understand why when I do Data.Binary.encode on something like a String, there's a bunch of extra space.
22:43:43 <EvanR> > array ((0,1),(0,1)) [((0,0),True), ((0,1),False), ((1,0),True), ((1,1),False)]
22:43:44 <lambdabot>   array *Exception: Error in array index
22:44:18 <ezyang> scotty: If you can the entire string in memory, no. 
22:44:31 <scotty> ezyang: Huh?
22:44:33 <EvanR> > array ((0,1),(0,1)) [((0,0),True), ((0,1),False), ((1,0),True), ((1,1),False)] :: Array (Int,Int) Bool
22:44:33 <ezyang> lazy bytestring is just [ByteString] (with some unpacking) 
22:44:33 <lambdabot>   array *Exception: Error in array index
22:45:01 <EvanR> > array ((0,0),(1,1)) [((0,0),True), ((0,1),False), ((1,0),True), ((1,1),False)] :: Array (Int,Int) Bool
22:45:02 <lambdabot>   array ((0,0),(1,1)) [((0,0),True),((0,1),False),((1,0),True),((1,1),False)]
22:45:16 <EvanR> :t array ((0,0),(1,1)) [((0,0),True), ((0,1),False), ((1,0),True), ((1,1),False)]
22:45:17 <lambdabot> forall t t1. (Num t, Num t1, Ix t, Ix t1) => Array (t, t1) Bool
22:45:30 <scotty> ezyang: I'm just trying to figure out why my ByteString after calling Data.Binary.encode is so space-inefficient.
22:45:38 <EvanR> [(0,0)..(1,1)]
22:45:42 <EvanR> > [(0,0)..(1,1)]
22:45:43 <lambdabot>   No instance for (GHC.Enum.Enum (t, t1))
22:45:43 <lambdabot>    arising from a use of `e_10011' ...
22:46:59 <scotty> 00000000  00 00 00 00 00 00 00 05  68 65 6c 6c 6f           |........hello|
22:47:06 <scotty> That's the hexdump.
22:47:28 <ezyang> scotty: Can you restate your question? 
22:47:56 <scotty> ezyang: Why is Data.Binary.encode padding out my Strings and such?  Is there a certain block size it's enforcing?
22:48:18 <ezyang> Ah, I see. 
22:48:51 <ezyang> so, your string is 5 characters, but it's padding it out to... 
22:48:57 <scotty> 00000000  00 00 00 00 00 00 00 05  68 65 6c 6c 6f           |........hello|
22:48:59 <scotty> Oops
22:49:02 <scotty> ezyang: Yes
22:50:16 <scotty> ezyang: Is that something like 52 bits?
22:51:10 <ezyang> Hmm. 
22:51:11 <scotty> ezyang: Er, 104 bits?
22:51:19 <ezyang> Are you actually passing binary a String? 
22:51:32 <ezyang> or are you giving it a bytestring? 
22:51:37 <scotty> ezyang: A string
22:52:14 <ezyang> ok, so you're using the Binary instance for [Char] 
22:52:24 <scotty> ezyang: Yep
22:52:48 <EvanR> so the type of an array does not tell what the dimensions are. i have to keep those as separate data
22:53:05 <scotty> ezyang: So, does that instance declaration pad out strings or something?
22:53:58 <kmc> it does EvanR
22:54:00 <kmc> :t bounds
22:54:01 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
22:54:16 <ezyang> ah 
22:54:34 <ezyang> It looks like toByteString creates a buffer of defaultSize to stick data into 
22:54:37 <EvanR> i can compute the dimensions from the array, so i dont have to store it
22:54:59 <ezyang> defaultSize = 32 * 1024 - 2 * sizeof(Int) 
22:55:30 <scotty> ezyang: I've never heard of toByteString and I don't see it on Hoogle.  Are you referring to encode?
22:55:39 <ezyang> I'm source-diving binary. 
22:55:43 <scotty> ezyang: Ah
22:55:54 <scotty> ezyang: So, why would they so that?
22:57:11 <ezyang> That seems too large, compared to what you're seeing. 
22:58:01 * ezyang keeps looking 
22:58:11 <scotty> ezyang: Wait, I'm looking at the Data.Binary doc and I don't even see String among the instances.
22:58:17 <ezyang> oh! 
22:58:22 <ezyang> this makes sense 
22:58:30 <ezyang> you've got 4 + 4 + 5 
22:58:34 <ezyang> erm 
22:58:37 <ezyang> yes 
22:58:43 <scotty> ezyang: Can you link me?
22:58:54 <ezyang> cabal unpack binary 
22:59:01 <scotty> ezyang: Oh
22:59:02 <ezyang> vim src/Data/Binary.hs 
22:59:03 <ezyang> :-) 
22:59:13 <scotty> ezyang: So, there is an instance declaration for String?
22:59:21 <ezyang> No, but there is one for [] and for Char 
22:59:23 <ezyang> So 
22:59:29 <scotty> ezyang: Ah
22:59:30 <ezyang> your string is 5 long, so that's 5 bytes 
22:59:39 <ezyang> we need to store the length, which requires an int 
23:00:07 <aavogt> > log (fromIntegral $ ord maxBound) / log 2
23:00:08 <lambdabot>   20.087461546321563
23:00:15 <ezyang> the int is small 
23:00:17 <scotty> ezyang: Why do we need to store the length?
23:00:27 <ezyang> scotty: Why, how would we know when the string ended, then ? :-) 
23:00:48 <ezyang> Since the int is small, we tag it as such with four null bytes, and then write out a 32-bit int with the length. 
23:00:50 <scotty> ezyang: Well, decode takes a ByteString, so it would just assume the String is the entire ByteString.
23:00:58 <ezyang> Nope. 
23:01:33 <scotty> ezyang: Why wouldn't that work?
23:01:41 <ezyang> Consider, for example, you have a network socket open and you've got a lazy bytestring reading data from that. 
23:01:46 <ezyang> then you don't know how long the bytestring is. 
23:02:03 <ezyang> or, consider I'm sending binary data that contains binary data inside it 
23:02:14 <scotty> ezyang: Bah
23:02:30 <ezyang> anyway, so its 4-bytes small int tag, 4-bytes the length (small int), 5-bytes actual payload. 
23:04:00 <scotty> ezyang: I see.
23:04:32 <ezyang> You might have had an original question, but I can't remember what it was :-) 
23:04:36 <scotty> ezyang: So, is there no way to strictly output the characters without the length?
23:04:45 <ezyang> There is! 
23:04:50 <scotty> Help!
23:05:20 <scotty> ezyang: You see, I'm putting the numbers out myself.
23:05:27 <ezyang> mapM_ put theString 
23:05:31 <scotty> ezyang: I don't want Binary to do it for me.
23:05:43 <scotty> ezyang: Ah, so you're using Char now.
23:05:50 <scotty> ezyang: And calling put put put ...
23:05:57 <ezyang> yep 
23:06:00 <aavogt> @hackage text
23:06:00 <lambdabot> http://hackage.haskell.org/package/text
23:06:21 <scotty> ezyang: So, that was in [] that it was enforcing that block size?
23:06:30 <ezyang> yes. 
23:06:40 <scotty> ezyang: Okay, thanks for looking at that for me.
23:06:52 <ezyang> IMO they should document their format 
23:06:59 <ezyang> well, it is pretty documented, just not in Haddoc >:-) 
23:07:50 <EvanR> is there already a data type Up | Down | Left | Right
23:07:55 <ezyang> I do way more source diving in Haskell these days than I really should be. 
23:08:00 <ezyang> EvanR: Zipper! 
23:08:04 <EvanR> lol
23:08:16 <aavogt> (Bool,Bool)  ignore bottoms
23:08:33 <EvanR> unreadable
23:08:59 <aavogt> @hoogle Direction
23:09:00 <lambdabot> Language.Haskell.TH data FixityDirection
23:09:00 <lambdabot> Language.Haskell.TH.Syntax data FixityDirection
23:10:56 <EvanR> is there an array slice...
23:11:36 <Kaidelong> well there is a toList
23:11:44 <Kaidelong> you could compose that with something else
23:12:02 <EvanR> maybe ixmap ?
23:12:59 <EvanR> no
23:13:02 <EvanR> gah
23:13:05 <BMeph> EvanR: Vectors have slices.
23:13:23 <EvanR> seems like arrays should
23:14:00 <BMeph> EvanR: Seems like Vector should have a splitAt, to me, but it doesn't.
23:14:32 <ezyang> This is such great reading: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects 
23:15:13 <EvanR> :t toList
23:15:14 <lambdabot> Not in scope: `toList'
23:15:21 <EvanR> BMeph: wheres this toList
23:16:16 <BMeph> EvanR: Where's which "toList"?
23:16:21 <EvanR> nevermind
23:16:33 <EvanR> that would be elems i guess
23:16:41 <EvanR> i believe ixmap will do it
23:17:32 <EvanR> ixmap ((3,4),(3,9)) (\(x,y) -> (x-3,y-4)) arr
23:17:35 <EvanR> or something
23:20:07 <EvanR> >_> thats not good
23:26:46 <Ivo_> would anyone know why 5 'div' 2 is not working for me? (lexical error @ 'i')
23:26:59 <EvanR> > 5 `div` 2
23:27:00 <lambdabot>   2
23:27:01 <tensorpudding> it should be backticks `
23:27:05 <tensorpudding> not quotes
23:27:10 <EvanR> :t or
23:27:11 <lambdabot> [Bool] -> Bool
23:27:15 <EvanR> :t ||
23:27:15 <lambdabot> parse error on input `||'
23:27:19 <EvanR> :t (||)
23:27:20 <lambdabot> Bool -> Bool -> Bool
23:27:20 <muhtimin> tensorpudding: why is that, by the way?
23:27:20 <tensorpudding> single quotes are used for constructing character literals
23:27:21 <Ivo_> ahhhh
23:27:37 <muhtimin> but of all possible characters, why backticks :D
23:27:51 <Ivo_> can any function be made infix this way?
23:27:53 <tensorpudding> muhtimin: I have no idea, probably everything else was taken
23:27:59 <Ivo_> (with two arguments)
23:28:01 <muhtimin> okay
23:28:01 <QtPlatypus> Ivo_: Yes
23:28:02 <EvanR> is there a function see if an index is in bounds?
23:28:10 <tensorpudding> any function with two arguments can be made infix using the backtick wrapping
23:29:16 <Ivo_> Are all functions really just 1 argument functions with currying going on [under the surface]?
23:29:26 <wioux> inRange
23:29:38 <EvanR> :t inRange
23:29:38 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
23:30:28 <EvanR> barely mentioned in hackage
23:30:40 <wioux> Ivo_: no.. there are things you can do with unary functions but not others
23:30:49 <wioux> http://www.haskell.org/tutorial/arrays.html is fairly to the point
23:31:40 <Ivo_> unary = actual 1 arguement? so are all >1 argument functions composed of curried 1 argument ones?
23:31:59 <QtPlatypus> Ivo_: Yes
23:32:36 <QtPlatypus> A function a -> b -> c is just a -> (b->c)
23:32:39 <wioux> Ivo_: "arity" is a term for the number of arguments, suffixed as: unary, binary, ... n-ary
23:32:51 <Ivo_> cool, thanks QtPlatypus wioux tensorpudding 
23:32:59 <EvanR> currying is cool!
23:34:20 <wioux> > let {f x = x+1; g x y = x*y} in (f . g) 1 2
23:34:21 <lambdabot>   3
23:34:47 <wioux> whoa
23:35:24 <wioux> why doesn't that work in ghci / actual code?
23:37:41 <Cale> wioux: Because it uses the instance of Num for functions
23:38:14 <Cale> (f . g) 1 2  ->  f (g 1) 2  ->  (g 1 + 1) 2
23:38:23 <Cale> g 1 is a function, and you're adding 1 to it there.
23:40:12 <Cale> You could also just go with ((f .) . g) 1 2
23:40:39 <Cale> Which doesn't require 1 to be treated as a function, or functions to be added
23:41:07 <wioux> ah
23:41:41 <Cale> (Though a lambda also works well here)
23:42:08 <Cale> (\x y -> f (g x y)) is probably easiest to understand in most settings.
23:42:11 <wioux> would you happen to be "Caleskell"'s namesake?
23:42:58 <Cale> Yeah, some people call the extra definitions that I put in lambdabot "Caleskell", but that makes it sound like it's a different language. :P
23:43:16 <ClaudiusMaximus> holy £$^! i got it to work  http://codepad.org/IXc2Pwkb
23:43:41 <wioux> :) nice to meet you. i understand the composition mathematically, just was confused as i didn't think the right operand could be anything but unary
23:44:26 <Cale> Well, all functions in Haskell are really functions of a single parameter
23:44:47 <Cale> Even the ones which appear to take more than one parameter are just producing other functions as their results.
23:44:52 <ezyang> Hmm, this is annoying. The code is literate... but in French. :-/ 
23:45:15 <Zao> Sounds like you're not :D
23:45:31 <wioux> :t (.)
23:45:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:45:49 <Cale> Lambdabot's definition for (.) is generalised :)
23:45:52 * ezyang dusts off four years of High School French. 
23:45:54 <wioux> i see
23:46:12 <Cale> If f = (e ->), you recover the ordinary (.)
23:46:21 <wioux> standard is something like (b -> c) -> (a -> b) -> (a -> c)
23:46:24 <Cale> yeah
23:46:49 <EvanR> is it typical to have array bounds like (1,10) rather than (0,9) ?
23:46:56 <Cale> Or (a -> b) -> (e -> a) -> (e -> b), to make the variables line up more with the ones in the generalised signature
23:47:00 <EvanR> to get the width i seem to be adding 1
23:47:24 <wioux> but despite what you say about all functions being unary (a la currying?), i've always gotten errors when composing anything but an every-day-sense unary function on the right
23:47:26 <EvanR> my poor C brain cant handle it
23:47:27 <Cale> EvanR: You can use whatever array bounds are most convenient
23:47:46 <ClaudiusMaximus> @instances Ix
23:47:47 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
23:48:00 <c_wraith> @instances-importing Data.Array Ix
23:48:01 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
23:48:11 <c_wraith> Ordering?  that's an odd one.
23:48:54 <EvanR> not (a,b,c,d,e) ?
23:49:15 <EvanR> lol @ ()
23:49:37 <c_wraith> For all your single-element array needs
23:50:41 <Cale> > let foo f = f 0 + f 1 in (foo . (*)) 6
23:50:42 <lambdabot>   6
23:50:57 <Cale> wioux: ^^
23:51:54 <c_wraith> :t let f ... g = \x y -> f (g x y) in (...)
23:51:55 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t2 -> t3 -> t) -> t2 -> t3 -> t1
23:52:26 <c_wraith> That's the kind of type signature you'd need to compose two-argument functions.
23:52:49 <c_wraith> actually, that's composing a single-arg function with a two-arg function
23:55:30 <robryk> what does `ambigous type variable in constraint' mean?
23:58:11 <wioux> Cale: don't understand the semantics of `f = f 0 + f 1' enough to make sense of that. what I'm getting at is (*) :: Int -> Int -> Int is the unary function Int -> (Int -> Int), according to what you've said, and since (+1) :: Int -> Int, if what you say holds then ((+1) . (*)) should work - and yet it doesn't (without something extra)
23:58:19 <robryk> expression runRegionT $ return () typechecks, but let f = <that expression> gives the error
23:59:24 <robryk> wioux: other way round
23:59:42 <robryk> your expression first applies * and then tries to do +1 to Int->Int
