00:21:22 <orbital_fox> hello
00:22:05 * ivanm waves idly in orbital_fox's general direction
00:22:46 <huntse> orbital_fox: hi there
00:28:07 <orbital_fox> is ivanm a bot? or is that a script to greet that way? :P
00:28:14 <orbital_fox> hi huntse 
00:28:29 <orbital_fox> luite are you here? i got a suggestion..
00:28:46 <ivanm> orbital_fox: nah, I just do that whenever someone who isn't here regularly says "hello", "hi" or something similar to the channel
00:29:08 <orbital_fox> right
00:29:39 <ivanm> so, you know you're a regular when you greet the channel, I'm around (as in actually on IRC rather than idling) and I don't wave at you :p
00:30:27 <c_wraith> hi ivanm! :)
00:30:34 <ivanm> hey c_wraith 
00:30:55 <orbital_fox> hehe, do you actually keep statistics? :P
00:31:15 <c_wraith> nah.  There are only maybe 30-40 people who are regularly active in this channel.
00:31:21 <c_wraith> It's not that hard to keep them all in memory
00:32:09 <ivanm> for example, Peaker has joined, and if memory serves Peaker is in Israel
00:32:31 <ivanm> and is wondering about his own personal type theory about adding/removing types or something
00:33:16 <orbital_fox> :P
00:33:32 <Peaker> ivanm, what? :)
00:33:44 <Peaker> I was wondering about academic sources for some common Haskell "folklore"
00:34:38 <robertmassaioli> awkward...
00:34:42 <robertmassaioli> lol
00:34:54 <lispy> If ivanm were a bot he would be more like mailman :)
00:35:00 <ivanm> Peaker: oh, I had never heard of those terms before and thought you had made that up... ;-)
00:35:08 <ivanm> lispy: in what sense?
00:35:54 <Peaker> ivanm, negative/positive type positions?
00:36:04 <ivanm> yeah
00:36:11 <ivanm> I thought that was something you had come up with
00:39:47 <ski> the terms "positive contexts" and "negative contexts" are used in logic ..
00:40:07 <Peaker> ski, any academic references?
00:42:37 <ivanm> so I'm writing restricted versions of all (well, not all; Monoid for example is fine as-is) the type classes in base; as such I was thinking of "fixing" that whole Functor/Applicative/Monad/etc. hierarchy whilst I was at it
00:43:03 <ivanm> should I do so sticking to only the classes in base, or also get Pointed, etc. from category-extras to fully implement all classes in typeclassopedia?
00:43:05 <ski> Peaker : i'm not sure of any original reference, but e.g. "Constructivism in Mathematics - An Introduction - Volume I" by Anne Sjerp Troelstra and Dirk van Dalen mentions "positive contexts", "negative contexts", "strictly positive contexts"
00:43:28 <Peaker> ski, isn't it weird that nobody seems to cite/explain what that is?
00:43:40 <ski> Peaker : oh, it's not hard to explain :)
00:44:42 <lispy> ivanm: you're quick to respond on haskell-cafe :)
00:45:12 <ivanm> lispy: procrastination is an art ;-)
00:45:41 <Peaker> ski, Well, I've only reverse engineered the meaning to "negative is left of (->)" (well, and getting a product which is positive again when in even amount of (->))
00:45:52 <Peaker> ski, Not sure about the strict definition..
00:46:24 <ski> Peaker : consider `F ::= A  |  True  |  False  |  F /\ F  |  F \/ F  |  F -> F  |  forall x. F  |  exists x. F'
00:46:38 <ski> where `A' stands for "atomic" formulae
00:47:16 <ski> (i.e. predicate symbols applied to the correct number of terms)
00:47:55 <ski> Peaker : now, we want to be able to speak about about a *position* within such a formulae
00:48:19 <Peaker> ski, Well, if we took out "F -> F", they'd all be positive, right?
00:48:41 <ski> we've not reached anything that can be positive or negative, yet
00:49:26 <ski> Peaker : we define `C[] := []  |  C[] /\ F  |  F /\ C[]  |  C[] \/ F  |  F \/ C[]  |  C[] -> F  |  F -> C[]  |  forall x. C[]  |  exists x. C[]'
00:49:57 <ski> this is the type of formula contexts, i.e. formulae with exactly one sub-formula missing
00:50:16 <ski> the `[]' alternative is the case where the whole formula is missing
00:51:03 <Peaker> how would you define []?  Wouldn't it be equal to F?
00:51:39 <ski> `[]' is just another constructor of this new datatype
00:51:51 <ski> we can define a substitution operation, so that we can say that if `C0[] = (forall x. P x -> []) -> Q' and `C1[] = (forall x. P x -> Q) -> []'
00:51:52 <Peaker> oh, I missed that, oops
00:52:32 <ski> then both `C0[Q]' and `C1[Q]' (i.e. `Q' substituted in the "obvious" way, into the hole in both cases) are equal to `(forall x. P x -> Q) -> Q'
00:53:03 <Peaker> Is this Agda notation? I'm not sure what C0[Q] means after those definitions
00:53:18 <ski> so, by using `C0[]' and `C1[]' we are able to speak about the two different occurances of `Q' in `(forall x. P x -> Q) -> Q'
00:53:23 <ski> no, not agda notation
00:53:27 <opqdonut> Peaker: just think of it in a mathy way
00:53:36 <ski> i'm just mimicking the notation in the book (mostly)
00:53:42 <Peaker> Is C0[Q]  C0[] applied to Q?
00:53:45 <opqdonut> yes
00:53:48 <ski> yes, more or less
00:54:03 <opqdonut> except C0[] is not a construct in the language
00:54:08 <opqdonut> only in the meta-language
00:54:32 <ski> think of `C0[]' as a meta-level function, which given a formula, builds a larger formula with the formula plugged in
00:55:17 <ski> but it's supposed to be parametric, i.e. *which* larger formula it builds can't depend on the given formula, except that the place where the formula is plugged in will of course depend on the input :)
00:55:54 <ski> anyway
00:56:19 <ski> as you noted, `C[]' can't distinguish between positive and negative contexts or occurances
00:56:22 <ski> so, we need
00:57:23 <ski>   P[] := []  |  P[] /\ F  |  F /\ P[]  |  P[] \/ F  |  F \/ P[]  |  N[] -> F  |  F -> P[]  |  forall x. P[]  |  exists x. P[]
00:57:24 <Peaker> a type for a hole in a negative position, and one for a hole in positive positions?
00:57:27 <ski>   N[] :=        N[] /\ F  |  F /\ N[]  |  N[] \/ F  |  F \/ N[]  |  P[] -> F  |  F -> N[]  |  forall x. N[]  |  exists x. N[]
00:57:39 <ski> (these two are mutually recursive)
00:57:42 <ski> yes
00:57:46 * hackagebot bits-extras 0.1.1 - Efficient atomic and non-atomic bit operations not found in Data.Bits  http://hackage.haskell.org/package/bits-extras-0.1.1 (GabrielWicke)
00:57:51 <Peaker> ski, ah, cool
00:58:05 <ski> also, there's
00:58:27 <ski>   SP[] := []  |  SP[] /\ F  |  F /\ SP[]  |  SP[] \/ F  |  F \/ SP[]  |  F -> SP[]  |  forall x. SP[]  |  exists x. SP[]
00:58:35 <ski> these are the "strictly positive contexts"
00:59:12 <ski> (btw, note that `P[]' and `N[]' are mutually exclusive, and exhaust all off `C[]')
00:59:39 <Peaker> strictly positive means it's not a "double negative"?
00:59:53 <dolio> Right.
01:00:10 <Peaker> Great, thanks. Now I might have a book source for this. Need to check if it is in a library
01:00:32 <ski> Peaker : oh, right. if you search for "Felleisen contexts", you'll find info on Felleisen's idea on using contexts like this (but for expressions, not for formulae), for expressing operational semantics, where some reduction rules can depend on the context
01:01:13 <ski> (such as semantics for control operators, shared mutable state, laziness, &c.)
01:01:16 <Peaker> thanks! Gotta go or I'll miss my train
01:02:40 <ski> (Peaker : btw, the book i mentioned doesn't use use or study these contexts that much .. it just mentions them because it needs the concept to express some theorems)
01:03:44 <ski> (.. and i don't see any specific reference re contexts in the notes at the end of the chapter)
01:04:50 <orbital_fox> how is tail recursion optimisation coming along in haskell?
01:05:37 <ivanm> it isn't
01:05:45 <ivanm> laziness kinda precludes TCO
01:06:31 <orbital_fox> i see
01:06:40 * ivanm tries to find a good source for that
01:07:25 <dolio> Stacks aren't typically used for function calls when implementing Haskell, so there's nothing to optimize.
01:07:33 <ivanm> http://book.realworldhaskell.org/read/functional-programming.html
01:07:45 <ivanm> ^^ see the bit "What's the big deal about tail recursion?"
01:09:09 <orbital_fox> brb
01:09:23 <ski> ivanm : i'm not sure i would say it precludes TCO ..
01:09:38 <ivanm> well, true
01:09:44 <ivanm> but they're kinda orthogonal
01:09:54 <ski> .. only that tail calls aren't always what you want, when you have lazy constructors
01:23:53 * hackagebot hamlet 0.5.0 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.5.0 (MichaelSnoyman)
01:23:55 * hackagebot web-routes-quasi 0.6.0 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.6.0 (MichaelSnoyman)
01:23:57 * hackagebot persistent 0.2.0 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.2.0 (MichaelSnoyman)
01:23:59 * hackagebot persistent-postgresql 0.2.0 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.2.0 (MichaelSnoyman)
01:25:53 * hackagebot yesod 0.5.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.5.0 (MichaelSnoyman)
01:25:55 * hackagebot persistent-sqlite 0.2.0 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.2.0 (MichaelSnoyman)
01:45:52 <dobblego> you are setting an exercise to implement a library of monadic combinators, which functions do you choose? [mapM, sequence, join, liftM, filterM] ++ ?
01:46:21 <ivanm> well, with sequence and map you can get mapM
01:46:29 <dobblego> [ap, replicateM]
01:46:33 <ivanm> wait, are you wanting a minimal list?
01:46:34 <dobblego> yes and vice versa
01:46:37 <dobblego> no
01:46:42 <ivanm> ahhh, then I misunderstood
01:51:23 <Saizan> takeWhileM and show how it's the only one (+ join) that requires Monad instead of Applicative?:)
01:51:42 <dobblego> the only one of what?
01:52:17 <Saizan> of that list
01:52:20 <Axman6> dobblego: sequence for sure
01:52:32 <dobblego> ah yeah good point
01:54:47 <ivanm> Saizan: why does it need Monad rather than applicative?
01:58:08 <c_wraith> Saizan, filterM needs Monad
02:00:22 <ivanm> @src filterM
02:00:22 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:00:34 <c_wraith> :t filterM
02:00:35 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
02:00:55 <c_wraith> it needs to inspect the result of applying the filter function, so it needs Monad
02:01:04 <ivanm> that sounds right to me
02:01:18 <ivanm> which would be the same argument for takeWhileM IIUC
02:01:21 <c_wraith> yes
02:01:50 <c_wraith> the two functions are structurally very similar.  they just do different things with the function passed in
02:01:58 <ivanm> *nod*
02:10:25 <Saizan> ?type let filterA f [] = pure []; filterA f (x:xs) = (\b xs -> if b then x:xs else xs) <$> f x <*> filterA f xs in filterA
02:10:26 <lambdabot> forall a (f :: * -> *). (Applicative f) => (a -> f Bool) -> [a] -> f [a]
02:10:40 <Saizan> c_wraith: ^^^
02:11:09 <c_wraith> Oh, I suppose so.
02:12:01 <Saizan> the difference is that it does the recursive call unconditionally
02:12:11 <c_wraith> yeah
02:13:06 * hackagebot yesod-examples 0.5.0 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.5.0 (MichaelSnoyman)
02:13:27 <aRcatan> what's the difference between Applicative and Monad?
02:14:37 <ski> aRcatan : `join', basically
02:15:46 <om-foxy> what sort of errors cause "Process haskell bus error"?
02:16:31 <om-foxy> I'm using "sequence" on a list of monadic functions, and using the resulting list.
02:16:36 <om-foxy> @type sequence
02:16:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:16:49 <om-foxy> > putStr "1"
02:16:50 <lambdabot>   <IO ()>
02:17:26 <om-foxy> > sequence [putStr "H" >> return 1,putStr "e" >> return 2]
02:17:28 <lambdabot>   <IO [Integer]>
02:17:48 <om-foxy> but the monad I'm using isn't strict?
02:18:06 <co_dh> > sequence [ Just 1 , Just 2 , Nothing]
02:18:07 <lambdabot>   Nothing
02:19:03 <om-foxy> > sequence [Just 1,Just 2,Just 3]
02:19:04 <lambdabot>   Just [1,2,3]
02:19:17 <deteego> is it just me
02:19:21 <deteego> or is haskell wiki failing
02:20:05 <deteego> as in the page isn't loading
02:32:57 <por> Can you express an exclusive disjunction of data types in a data type, like F a = a :-> (U a | W a) ?
02:33:03 <angstrom> deteego: http://downforeveryoneorjustme.com/www.haskell.org
02:35:35 <Saizan> por: use Either
02:35:39 <Saizan> @src Either
02:35:39 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:35:44 <rajeshsr> @src sequence
02:35:44 <lambdabot> sequence []     = return []
02:35:45 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:35:45 <lambdabot> --OR
02:35:45 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
02:35:49 <Saizan> data Either a b = Left a | Right b
02:36:35 <Nibble> @let data Either a b = Left a | Right b
02:36:35 <lambdabot>  Invalid declaration
02:36:37 <Nibble> :(
02:36:53 <Saizan>  @let doesn't talk to @src anyhow.
02:37:08 <por> Yeah, but I need a larger range than Either provides, e.g., A = B (C | D | E | F). I guess a custom Either is the only solution?
02:37:31 <opqdonut> or, Either (Either C D) (Either E F)
02:37:38 <opqdonut> but yeah, just code your own
02:38:12 <opqdonut> you can give the cases more semantic names, too
02:43:35 <por> Oh, well 'F a = A | B a | C a a ...' with 'E e - F a | G a', and so forth, works, since then you can build nested F values. Not elegant, but whatever.
02:53:44 <chrisdone> hai
02:54:02 <deteego> hmm
02:54:06 <deteego> my dns must be screwed
02:55:55 <co_dh> :t dist
02:55:56 <lambdabot> Not in scope: `dist'
03:05:30 <dobblego> The head function is on a type-class: Copointed. The tail function... ?
03:05:46 <dobblego> @seen edwardk
03:05:46 <lambdabot> Unknown command, try @list
03:05:46 <preflex>  edwardk was last seen on #haskell 2 days, 13 hours, 58 minutes and 55 seconds ago, saying: preflex: xseen copumpkin
03:06:11 * Saizan thinks [] doesn't make a legitimate Copointed functor.
03:06:40 <co_dh> @src Applicative []
03:06:40 <lambdabot> Source not found. Wrong!  You cheating scum!
03:06:47 <co_dh> @src pure
03:06:47 <lambdabot> Source not found. I feel much better now.
03:06:53 <co_dh> @src [] pure
03:06:53 <lambdabot> pure = return
03:07:17 <co_dh> @src [] (<*>)
03:07:17 <lambdabot> (<*>) = ap
03:07:26 <dobblego> no [] doesn't, but NonEmpty does
03:07:27 <co_dh> :t zapp
03:07:27 <lambdabot> Not in scope: `zapp'
03:07:34 <Axman6> :t pew pew
03:07:35 <lambdabot> Not in scope: `pew'
03:07:36 <lambdabot> Not in scope: `pew'
03:13:12 <co_dh> @see co_dh
03:13:12 <lambdabot> Maybe you meant: free let src
03:13:21 <co_dh> @seen co_dh
03:13:22 <lambdabot> Unknown command, try @list
03:13:22 <preflex>  co_dh was last seen on #haskell 10 seconds ago, saying: @see co_dh
03:13:30 <co_dh> @seen copumpkin
03:13:30 <lambdabot> Unknown command, try @list
03:13:30 <preflex>  copumpkin was last seen on #haskell 1 day, 4 hours, 14 minutes and 12 seconds ago, saying: yeah, I liked it :)
03:17:13 * RayNbow wonders when QuickSpec will make its way to hackage
03:19:51 <Jonno_FTW> hello
03:20:31 <Jonno_FTW> I have the latest version of cabal, but when I run: cabal install split
03:20:48 <Jonno_FTW> I get an error about cabal install being too old
03:21:04 <Saizan> Jonno_FTW: cabal --version; which cabal
03:21:54 <Jonno_FTW> cabal-install version 0.6.4
03:21:54 <Jonno_FTW> using version 1.6.0.3 of the Cabal library 
03:22:08 <co_dh> @src Maybe pure
03:22:09 <lambdabot> pure = return
03:22:17 <co_dh> @src Maybe (<*>)
03:22:17 <lambdabot> (<*>) = ap
03:22:22 <co_dh> @src ap
03:22:22 <lambdabot> ap = liftM2 id
03:22:32 <Jonno_FTW> /home/jonno/.cabal/bin/cabal
03:22:39 <Saizan> Jonno_FTW: that's not the latest version, by far
03:22:50 <Jonno_FTW> but
03:22:56 <Jonno_FTW> synaptic says I have the latest
03:23:00 <CakeProphet> can you make existential newtypes?
03:23:15 <co_dh> @src liftM2
03:23:15 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
03:23:24 <Saizan> Jonno_FTW: ubuntu can be way behind the released versions
03:23:33 <Jonno_FTW> I use debian, but ok
03:23:37 <Jonno_FTW> how do I fix it?
03:23:48 <Saizan> you can "cabal install cabal-install"
03:23:52 <Jonno_FTW> nope
03:23:57 <Jonno_FTW> I get the old version error
03:24:30 <Saizan> are you sure it's an error, and not just a warning?
03:24:41 <Saizan> though i guess that version might not work with a recent ghc..
03:24:52 <Jonno_FTW>  cabal install cabal-install
03:24:52 <Jonno_FTW> cabal: This version of the cabal program is too old to work with ghc-6.12+.
03:24:53 <Jonno_FTW> You will need to install the 'cabal-install'
03:24:58 <co_dh> > liftM2 id f a
03:24:58 <lambdabot>   Couldn't match expected type `m a2'
03:24:59 <lambdabot>         against inferred type `SimpleRe...
03:25:12 <co_dh> :t liftM2 id  f
03:25:13 <lambdabot> forall a2 r (m :: * -> *). (SimpleReflect.FromExpr (m (a2 -> r)), Monad m) => m a2 -> m r
03:25:13 <Saizan> Jonno_FTW: ok, you need to download the tarball from hackage and run the bootstrap.sh script
03:25:20 <Jonno_FTW> hmk
03:25:25 <CakeProphet> ?
03:25:35 <CakeProphet> existential newtypes? yes or no?
03:25:41 <Saizan> CakeProphet: no
03:26:33 <Saizan> which is a shame
03:26:51 <CakeProphet> I could see it being difficult to optimize.
03:27:33 <orbital_fox> why was cabal named cabal?
03:27:47 <CakeProphet> because there is no cabal
03:27:54 <CakeProphet> -ahem- not one you need to know about.
03:29:11 <Axman6> what is a cabal anyway?
03:29:28 <Jonno_FTW> a group of people
03:29:32 <CakeProphet> an exclusive, secretive group.
03:29:33 <c_wraith> a secret organization with shadowy goals
03:29:33 <Jonno_FTW> like a guild I think
03:29:45 <Axman6> hmm
03:29:49 <CakeProphet> the sinisterness is only a connotation to the actual meaning.
03:30:10 <Jonno_FTW> what does a cabal have to do with haskell package management then?
03:30:46 <CakeProphet> Jonno_FTW:  everyone here knows why. Perhaps you should join our club.
03:31:08 <Jonno_FTW> i assume there is some kind of cruel and degrading initiation
03:31:28 <CakeProphet> yes.
03:31:32 <c_wraith> CakeProphet, connotations of a word are just as important as the denotation
03:31:48 <orbital_fox> ok
03:31:52 <orbital_fox> i want in then :P
03:32:09 <orbital_fox> orbital_fox : cabal
03:32:24 <CakeProphet> c_wraith: indeed. It is also important to know when something is a connotation and not the true meaning.
03:33:01 <c_wraith> this concept of "true meaning" is not an accurate description of how language works
03:33:17 <CakeProphet> I suppose.
03:33:42 <por> But 'deviousness' is part of the denotation of 'cabal'. Try using it as a verb.
03:34:03 <c_wraith> still.  I do want to join a sunshine and kittens and rainbows cabal :)
03:34:07 <CakeProphet> How do you use cabal as a verb? Surely you must cabal first.
03:36:01 <por> It's an intransitive verb, so 'he/she/it cabal, caballed, are caballing,' etc.
03:36:45 <n00p> You're an intransitive verb.
03:37:00 <por> No, I'm a gerund.
03:37:27 <n00p> Well, you're not far from it
03:37:35 <n00p> What's a gerund?
03:37:47 <CakeProphet> to gerund is to cabal
03:38:13 <CakeProphet> well, not equivalent. But necessary. You must cabal to gerund.
03:38:52 <por> a gerund is a type of verbal noun
03:38:57 <por> haha, CakeProphet
03:39:18 <CakeProphet> on-topic question: how do I get an ordered map?
03:39:21 <co_dh> :i Monoid
03:39:24 <co_dh> :t Monoid
03:39:25 <lambdabot> Not in scope: data constructor `Monoid'
03:39:27 <n00p> Your mother's a verbal noun.
03:40:49 <HskllNoob> CakeProphet: toAscList :: Map k a -> [(k, a)]
03:42:20 <sioraiocht> hello ther
03:42:20 <CakeProphet> HskllNoob:  not quite. I want the ordering to occur during insert.
03:42:20 <sioraiocht> e
03:42:32 <sioraiocht> oops, wrong window, sorry guys
03:42:43 <CakeProphet> I don't want to take an unordered map and make it ordered. I guess [(k,a)] is an ordered map?
03:43:02 <CakeProphet> not very efficient at lookup though.
03:43:13 <CakeProphet> but my application doesn't require efficiency.
03:44:03 <CakeProphet> score       :: [(String, ([(String, MudData)])] 
03:44:07 <CakeProphet> that's quite a type there.
03:44:14 <CakeProphet> to my human mind.
03:44:25 <olsner> what do you mean by "ordered"? Map uses the Ord instance and can easily get the ordered=sorted list out of it
03:44:46 <CakeProphet> hmm...
03:45:07 <CakeProphet> well, I have a collection of keys to values, but they need to maintain a constant ordering. I suppose ordered by insert.
03:46:03 <CakeProphet> perhaps: data OrdMap k a = OrdMap (Map k a) [k]
03:46:44 <CakeProphet> so I could utilize the lookup efficiency of Map with the controllable ordering of a list.
03:48:58 <c_wraith> CakeProphet, are you looking for an LRU type structure?
03:49:20 <CakeProphet> I don't know what that is. So maybe.
03:49:37 <c_wraith> typically used for caches.
03:50:03 <c_wraith> They implement a policy that if they get too full, the least recently used (inserted or accessed) element is removed
03:50:11 <CakeProphet> hmmm, no.
03:51:05 <CakeProphet> I have a collection of names to values, but they also are ordered. They're ordered because they're displayed to the user in a regular form, as a table.
03:51:26 <CakeProphet> so I think I want [(k,a)] it works for my purposes, though doesn't have the efficiency of Map.
03:51:43 <c_wraith> If it's intended for display, that should be just fine
03:52:18 <c_wraith> you could also thread a linked list through a Map k a
03:52:33 <c_wraith> But that's error-prone.
03:53:01 <CakeProphet> oooh. no, that's too complicated.
03:53:04 <CakeProphet> but interesting.
03:53:52 <boegel> BONUS: just learned you're going to attend BelHac in Nov., so cool!
03:53:59 <CakeProphet> type LinkedMap k a = Map k (a,a)  ?
03:54:24 <CakeProphet> no
03:54:25 <CakeProphet> either
03:54:32 <CakeProphet> type LinkedMap k a = Map k (a,k) 
03:54:40 <CakeProphet> or: type LinkedMap k a = Map k [a] 
03:54:55 <c_wraith> I was thinking of the former
03:56:01 <c_wraith> that has the downside that an ordered traversal is O(n log n) instead of O(n)
03:56:46 <c_wraith> But that's generally worth it, when it lowers the cost of lookup and replace as much as it does
03:57:15 <CakeProphet> hmmm, I think [(k,a)] will do just fine. lookup and traversal are equall important.
03:57:18 <CakeProphet> *equally
03:59:36 <CakeProphet> :t lookup
03:59:37 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
03:59:43 <CakeProphet> :t Data.Map.lookup
03:59:44 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
04:00:30 <CakeProphet> @pl getChar p k = lookup k (characters p)
04:00:31 <lambdabot> getChar = flip lookup . characters
04:02:17 <CakeProphet> @hoogle say
04:02:18 <lambdabot> No results found
04:03:47 <chrisdone> No instance for (Applicative Identity)
04:03:48 <chrisdone> ~_~
04:07:05 <chrisdone> newtype RunForm a = RF { runForm :: Identity a } deriving (Monad,Functor)
04:07:05 <chrisdone> instance Applicative RunForm where (<*>) = ap; pure = return
04:07:07 <chrisdone> yaaaay
04:07:12 * hackagebot proc 0.0.5 - Parse process information for Linux  http://hackage.haskell.org/package/proc-0.0.5 (AndyStewart)
04:07:19 * chrisdone kicks orphan instances in the groin
04:08:55 <CakeProphet> I have a challenge for everyone
04:09:02 <CakeProphet> guess what the function with this type does:
04:09:04 <CakeProphet> TVar a -> (a :-> r) -> (r -> r) -> STM ()
04:09:40 <pshc> Man I wish certain stdlib functions that wrap (IO a) actions were (MonadIO m => m a) instead :(
04:09:52 <c_wraith> I'd hope it updates the TVar's contents via the fclabel and modification function
04:10:41 <CakeProphet> ...yes.
04:10:55 <luite> pshc: write your own generic ones with liftIO ?
04:11:25 <c_wraith> why ask the question, CakeProphet?
04:11:35 <pshc> luite: yeahhh.. I feel really stupid digging around libraries' source and duplicating their code, though
04:12:26 <luite> do you actually need their code then?
04:13:13 <pshc> er... unless there's a way to turn say (IO a -> IO a) magically into (MonadIO m => m a -> m a)
04:13:43 <pshc> unless you're putting them down, two meanings there hehe
04:14:20 <c_wraith> There's no magical way to perform that transformation
04:14:23 <CakeProphet> c_wraith:  I was simply curious how obvious the semantics were from the type.
04:14:25 <pshc> yeah.
04:14:32 <CakeProphet> @pl modS tvar field f = modTV tvar (modL field f)
04:14:33 <lambdabot> modS = (. modL) . (.) . modTV
04:14:45 <c_wraith> CakeProphet, they're not too bad, if you know that :-> means fclabel
04:17:09 <orbital_fox> hello luite 
04:17:48 <CakeProphet> @pl modS field f tvar = modTV tvar (modL field f)
04:17:49 <lambdabot> modS = (flip modTV .) . modL
04:34:07 <greap> Is there a more idiomatic way to do this in parsec? http://codepad.org/EKz6FMFv
04:34:36 <greap> (I'd like the parser to fail on Nothing)
04:35:35 <Tim__> Never used IRC before- do I just go ahead and ask my Haskell question or is there some sort of etiquette?
04:35:53 <ivanm> Tim__: the etiquette is "don't ask to ask" :p
04:36:14 <Tim__> first message and I've already broken the unspoken rules :-(
04:36:24 <ivanm> greap: ummm, dunno, sorry
04:36:35 <greap> Tim__: In pennance you must ask a question!
04:36:45 <ivanm> I've never really used parsec, and I don't know what you're trying to do
04:37:03 <ivanm> however, you might be able to use a try, or whatever parsec calls it
04:37:09 <ivanm> @hoogle option
04:37:09 <lambdabot> Text.Html option :: Html -> Html
04:37:09 <lambdabot> Text.Parsec.Combinator option :: Stream s m t => a -> ParsecT s u m a -> ParsecT s u m a
04:37:09 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
04:37:19 <ivanm> greap: ^^ the option combinator
04:37:42 <greap> ivanm: Mmm, I think this might be on the right track.
04:38:10 <aristid> hmm it would be very convenient if lookup functions returned any MonadPlus
04:38:13 <aristid> or Alternative
04:38:15 <Tim__> OK, complete Haskell beginner here. The tutorials all list the syntax for function definition as "square x = x * x" for example, but the latest GHCi won't accept that syntax: "Parse error found on input '='".
04:38:37 <Tim__> I find if I use "set square x = x*x" it's happy
04:38:40 <aristid> Tim__: in ghci you cannot write top-level declarations like in a file.
04:38:53 <aristid> this is valid in ghci: let square x = x * x
04:39:05 <ivanm> Tim__: write your code in a file, then load that in ghci
04:39:06 <Tim__> sorry, yes I meant 'let'
04:39:14 <Tim__> righto
04:39:17 <ivanm> ghci isn't a true REPL in the lisp/python sense
04:39:41 <aristid> ivanm: it would be very cool if it were
04:39:42 <Tim__> it would be helpful if the tutorials actually mentioned that, I thought they were out of date and 'let' was the new way to define funcs
04:39:54 <ivanm> aristid: HBC apparently let you define new data types, etc. ...
04:39:58 <Tim__> thanks for the help guys
04:40:09 <ivanm> Tim__: they generally do at some point; which tutorial are you using?
04:40:12 <greap> Tim__: Which tutorial?
04:41:26 <wli> hbi -like functionality would be nice to have
04:42:36 <Tim__> upon closer inspection it does say to save the code to file, how embarassing ;-)
04:42:59 <Tim__> I'm using Yet Another Haskell Tutorial (http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf)
04:43:09 <mauke> oh, oldschool
04:43:32 <Tim__> I must have skipped over the section on loading files because I assumed it was like Python, code in a file is the same as code in the repl
04:43:34 <ivanm> yeah, that hasn't been updated for a while
04:43:36 <ivanm> @where LYAH
04:43:36 <lambdabot> http://www.learnyouahaskell.com/
04:43:38 <ivanm> @where wikibook
04:43:38 <lambdabot> http://en.wikibooks.org/wiki/Haskell
04:43:40 <ivanm> @where RWH
04:43:41 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:43:47 <ivanm> Tim__: ^^ these tutorials are more up-to-date
04:44:01 <ivanm> (RWH is also a book; LYAH is being turned into one; wikibook claims to be a book :p)
04:44:07 <mauke> LYAH has the best illustrations ever
04:44:45 * ivanm personally dislikes "silly" tutorials like LYAH
04:44:54 <Tim__> ok these are now in my bookmarks
04:45:14 <Tim__> yeah I'm not a big fan of the children's book style
04:45:36 <orbital_fox> who has done any webdevelopment with haskell here?
04:45:36 <aristid> ivanm: then you probably also dislike this: http://cheezburger.com/View/3749502464
04:45:57 <mauke> LYAH isn't silly
04:46:14 <mauke> apart from the title
04:46:25 <Tim__> pretty sure in a week I'm going to actually need burrito kitty to explain monads to me
04:46:27 <ivanm> aristid: as a joke, it's almost mildly amusing; however I prefer a mathematical approach on tutorials
04:46:32 <ivanm> or a CS approach
04:46:32 <aristid> Tim__: if you can't get over that and don't let yourself see the content, then i must feel sorry for you :)
04:46:44 <klugez> Title and some of the illustrations, but otherwise it's not silly at all.
04:46:50 <ivanm> aristid: was that aimed at me? :p
04:46:56 <aristid> ivanm: no, at Tim__
04:47:02 <Tim__> oh I'll definitely read it- it's always held up as a good tutorial
04:47:05 <ivanm> klugez: aren't the examples, etc. rather whimsical and silly?
04:47:11 <aristid> ivanm: i think you know haskell well enough not to need lyah :D
04:47:31 <ivanm> right, but I can't see what Tim__ said to make you feel sorry for him
04:47:44 <Tim__> I was judging a book by it's cover
04:47:52 <Tim__> or in this case, it's illustrations
04:47:55 * ivanm does that all the time
04:48:00 <ivanm> usually serves me well though
04:48:02 <aristid> ivanm: nothing directly, but if "<Tim__> yeah I'm not a big fan of the children's book style" makes him not read it..
04:48:21 <ivanm> oh, missed that bit
04:48:31 <ivanm> can't be any worse than that Fortran colouring-in book though :p
04:48:36 <ivanm> (or whichever language it was)
04:49:07 <Tim__> what's the best IRC client? I'm currently connecting through http://webchat.freenode.net/ and the layout leaves much to be desired
04:50:10 <klugez> ivanm: Some of the toy things use something silly instead of foo, bar, baz and stuff. But I don't hold it against them. Although I haven't (yet) read it all the way through.
04:50:13 <aristid> Tim__: xchat, quassel and irssi (that one is command-line) are some clients.
04:50:25 <ivanm> konversation
04:50:29 <ivanm> eirc
04:50:32 <ivanm> reirc
04:50:39 <ivanm> etc.
04:50:43 <mauke> erc, weechat, mirc, colloquy
04:50:55 <Tim__> wonderful, spoilt for choice ;-)
04:51:00 <mauke> circle
04:51:06 <mauke> well, I use irssi
04:51:19 <Tim__> is there a most popular one or something? I don't want to have to try out fifteen different clients
04:51:26 <aristid> i use quassel because it has an integrated bouncer, which is easy to configure
04:51:43 <aristid> Tim__: i think xchat is decent and quite popular
04:51:49 <bremner> Tim__: under X, I can recommend xchat.
04:51:49 <ivanm> I like xchat because of the line between the nicks and what people say
04:51:57 <ivanm> haven't found any other GUI IRC client that has that :s
04:52:02 <Tim__> I'm on windows [ducks]
04:52:08 <aristid> xchat does work on windows
04:52:20 <bremner> xchat is available on windows, but is shareware or something weird
04:52:30 <ivanm> (but I wish it had better netsplit support, and I want to disable C-l to stop clearing the message display :s)
04:52:32 <lantti> A list of ducks works on windows too.
04:52:37 <aristid> bremner: there is a free version for windows, just not on xchat.org
04:52:38 <ivanm> bremner: the official one is, but there are individual ports
04:52:43 <greap> ivanm: For reference it was the choice combinator I wanted. Much cleaner. http://codepad.org/KI1picDZ
04:52:51 <ivanm> aha
04:52:54 <aristid> free xchat for windows: http://www.silverex.org/news/
04:52:56 <bremner> aristid, ivanm: "or something weird"
04:52:56 <mauke> Tim__: are you a well-known Tim?
04:53:18 <aristid> it's not weird. the official maintainers feel they need to be paid for having to build on windows
04:53:51 <ivanm> bremner: when did I say that?
04:54:00 <ivanm> oh, wait, you said that
04:54:04 <ivanm> how are individual ports weird?
04:54:43 <greap> aristid: I vaguely recall that it was because they wanted to promote free operating systems.
04:55:00 <bremner> ivanm: my point was just that the xchat folks have a non-standard distribution model on windows, where standard is defined as what I am used to on Debian
04:55:10 <aristid> hmm looks like xchat isn't developed very actively
04:55:14 <ivanm> bremner: right
04:55:17 <philed> I'm using xchat.
04:55:29 <ivanm> bremner: then again, the entirety of windows is non-standard when compared to debian, etc. :p
04:55:31 <philed> (on windows)
04:55:33 <ivanm> stability for starters... :p
04:55:37 <philed> I also recommend erc for emacs.
04:55:43 <ivanm> aristid: yeah, there's a couple of forks though IIRC
04:55:45 <Tim__> mauke: FYI I'm not a well known Tim
04:55:58 <ivanm> conspire, etc.
04:56:01 <aristid> just your average Tim :D
04:56:13 <Tim__> above average like everyone else
04:56:18 <ivanm> Are you the sorceror they call Tim? :p
04:56:52 <Tim__> what, an african or a europea- aaaaarrrrrghhh
04:57:34 <ivanm> wrong guy
04:57:53 <Tim___> ahoy from XChat
04:58:10 <Tim___> oh yes, wrong Holy Grail guy
04:58:24 <Tim___> Tim's the gratuitous explosions guy
04:58:41 <Tim___> John Cleese
05:00:08 <Tim___> I have to shoot, it's 10PM here
05:00:08 <ivanm> was it? don't think it was John Cleese
05:00:14 <ivanm> admittedly, I haven't watched it for a while
05:00:19 <ivanm> Tim___: same here, what's your point? :p
05:00:45 <Tim___> are the red messages personal messages? what's the syntax for that?
05:00:49 <aristid> 10PM? that's 22:00?
05:01:04 <Tim___> yeah, 22:00 Sunday night
05:01:25 <aristid> where "sunday night" means night _to_ sunday?
05:01:46 <Tim___> It is Sunday here, it is also night time
05:01:54 <Tim___> I thought Sunday night pretty accurately summed it up ;-)
05:02:31 <aristid> > 22-12
05:02:32 <lambdabot>   10
05:02:36 <aristid> UTC+10?
05:02:51 <Tim___> Gold Coast, Queensland, Australia, UTC+10
05:03:12 <aristid> ah, that explains the crazy timezone :D
05:04:21 <Tim___> explains why I'm talking to you from.... THE FUTURE!
05:05:42 <Tim___> anyway thanks for the help, I'm sure I'll be back on with further facepalm-worthy noob Haskell questions very soon ;-)
05:05:44 <Tim___> take care
05:06:32 <ivanm> aristid: what, how is this a crazy timezone?
05:06:40 <ivanm> now, _daylight saving_ is crazy
05:06:44 <ivanm> but that's another story ;-)
05:07:51 <aristid> aussies don't have DST?
05:08:05 <aristid> ivanm: the funny thing about DST rules is that they constantly change
05:08:26 <aristid> which makes writing libraries for it very much fun
05:09:08 <ivanm> yeah
05:09:21 <ivanm> did you see the recent proposal for removing leap seconds from the UTC standard?
05:09:48 <ivanm> aristid: Australiains do indeed have DST; thus in Summer we go from 3 time zones on the mainland to 4 (since Queensland thankfully still doesn't have DST)
05:21:29 <sohum> > length [1,2,3]
05:21:30 <lambdabot>   3
05:21:34 <sohum> > length [1..]
05:21:38 <lambdabot>   mueval-core: Time limit exceeded
05:22:09 <sohum> would it be at /all/ possible to have that return Omega? and what would that imply for how infinite lists (and recursion, in general) are handled?
05:32:15 <greap> Any idea why quickcheck runs 100 tests when there is no argument to a function? shouldn't it just be 1 test?
05:35:47 <ivanm> greap: because it always runs 100 tests by default
05:36:05 <ivanm> it can't tell that there's only x possible inputs
05:36:08 <ivanm> e.g.:
05:36:18 <ivanm> @echeck \ b -> not (not b) == b
05:36:18 <lambdabot>   "OK, passed 500 tests."
05:36:21 <benmachine> can't have functions with no arguments
05:36:30 <benmachine> the very idea is absurd
05:36:48 <mauke> @check True
05:36:48 <lambdabot>   "OK, passed 500 tests."
05:37:17 <benmachine> @check False
05:37:18 <lambdabot>   "Falsifiable, after 0 tests:\n"
05:37:34 <benmachine> @check (== 7)
05:37:34 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
05:37:39 <ivanm> @hoogle quickCheck
05:37:39 <lambdabot> Test.QuickCheck quickCheck :: Testable a => a -> IO ()
05:37:39 <lambdabot> package QuickCheck
05:37:39 <lambdabot> module Debug.QuickCheck
05:37:48 <ivanm> @instances Testable
05:37:48 <lambdabot> Couldn't find class `Testable'. Try @instances-importing
05:37:56 <ivanm> @instances-importing Test.QuickCheck Testable
05:37:57 <lambdabot> (), Bool, Gen prop, Prop
05:38:05 <mauke> @check ()
05:38:05 <lambdabot>   "Arguments exhausted after 0 tests."
05:38:16 <ivanm> mauke: :o
05:38:25 <ivanm> what's the point of the () instance for Testable?
05:38:36 <benmachine> check for termination maybe? >_>
05:38:51 <benmachine> @check fix (mappend ())
05:38:51 <lambdabot>   "Arguments exhausted after 0 tests."
05:39:50 <greap> benmachine:  mmm
05:40:24 <greap> benmachine: For some reason I figured it would do some analysis of the function.
05:40:31 <benmachine> @check fix (mappend () $!)
05:40:32 <lambdabot>   "Arguments exhausted after 0 tests."
05:40:37 * hackagebot shellish 0.1 - shell-/perl- like (systems) programming in Haskell  http://hackage.haskell.org/package/shellish-0.1 (PetrRockai)
05:40:37 <benmachine> @check fix (mappend $! () $!)
05:40:38 <lambdabot>   The operator `Prelude.$!' [infixr 0] of a section
05:40:38 <lambdabot>      must have lower prec...
05:40:41 <benmachine> :(
05:41:16 * benmachine isn't sure how fix (mappend () $!) terminates
05:41:52 <benmachine> > fix (mappend () $!)
05:41:54 <benmachine> oh
05:41:55 <lambdabot>   mueval-core: Time limit exceeded
05:42:08 <benmachine> so it doesn't even test termination actually
05:42:12 <benmachine> @check (undefined :: ())
05:42:12 <lambdabot>   "Arguments exhausted after 0 tests."
05:42:18 * benmachine blinks
05:43:00 <Axman6> @check (\x -> undefined == ())
05:43:01 <lambdabot>   Undefined
06:00:09 * benmachine wonders what typeclasses Void belongs to
06:00:17 <benmachine> instance Eq Void where {}
06:00:32 <benmachine> is an equivalence relation, I guess
06:01:01 <ivanm> yeah, we need an inverse to @instances
06:01:22 <aristid> @info?
06:01:23 <lambdabot> Unknown command, try @list
06:01:23 <benmachine> well Void isn't really anywhere
06:01:31 <greap> Is there a standard way to parse numbers in parsec?
06:01:34 <aristid> @hoogle Void
06:01:34 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
06:01:36 <benmachine> I'm just curious what typeclasses it *could* be in
06:01:44 <benmachine> in a law-abiding fashion
06:01:56 <aristid> benmachine: typeable? :D
06:02:00 <benmachine> heh
06:02:20 <aristid> Void has one value: bottom, so it's possible to use that value
06:02:30 <benmachine> does, for example, mempty = undefined; mappend = undefined, follow the laws
06:02:34 <benmachine> I suppose it does
06:02:41 <benmachine> assuming all bottoms are equal
06:02:59 <aristid> wouldn't it have to be mappend _ _ = undefined?
06:03:07 <benmachine> hmm
06:03:12 <benmachine> only seq can tell the difference
06:03:16 <benmachine> and who cares about seq anyways >_>
06:03:25 <benmachine> I'm not sure even seq could tell the difference here
06:03:33 <aristid> hmm
06:03:35 <benmachine> oh it could yes but it doesn't matter
06:04:09 <aristid> and Functor of course: fmap = undefined
06:04:18 <aristid> and Monad: return = undefined; (>>=) = undefined
06:04:31 <aristid> the type instance just WRITE THEMSELVES
06:05:02 <benmachine> kind mismatch for Functor and Monad unfortunately :)
06:05:10 <benmachine> you'd need Void1 a
06:05:11 <benmachine> or something
06:07:29 <aristid> benmachine: we need polymorphic kinds.
06:07:55 <benmachine> intriguing o_Ã´
06:08:52 <aristid> i think UHC has them
06:09:05 <benmachine> haskell-src-exts has support for parsing kind variables
06:09:16 <aristid> not sure if it's possible to write an any-kinded Void type
06:10:50 <benmachine> how do you write a polymorphic-kinded type of any variety?
06:11:20 <monadic_kid> sorts?
06:11:43 <benmachine> would they actually help
06:15:26 <chrisdone> mmorrow played with sorts
06:15:29 <chrisdone> look what happened to him
06:15:31 <chrisdone> don't go there
06:18:34 <aristid> chrisdone: what are sorts?
06:22:38 <ivanm> aristid: we obviously don't want to know if we want to keep using Haskell
06:23:29 <aristid> ivanm: is it that bad?
06:23:50 <ivanm> well, if it caused mmorrow to disappear...
06:24:06 <ivanm> either it makes you realise that Haskell is the wrong thing, or the sorts mafia gets you
06:24:29 <aristid> maybe he defected to agda
06:25:59 <monadic_kid> aristid: sorts are types of kinds
06:26:08 <aristid> the kinds of kinds?
06:26:09 <monadic_kid> aristid: value, type, kind, sorts
06:26:15 <abcd-> hi, how do i convert between String and ByteString?
06:26:23 <aristid> @hoogle pack
06:26:24 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
06:26:24 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
06:26:24 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
06:27:35 <monadic_kid> there some madness going about trying to make a typekind for type computations but I'm not sure that is a great idea
06:27:40 <abcd-> thanks!
06:27:45 <monadic_kid> type and kinds on the same level
06:28:05 <dons> enjoy http://hackage.haskell.org/trac/ghc/ticket/4277 
06:29:22 <mietek> Is the forall in "forall a b. m a -> m b -> m b" usually omitted?
06:30:40 <dobblego> mietek, yes
06:30:41 <ivanm> yes
06:30:44 <ivanm> it's implicit
06:30:51 <mietek> Right, thanks.
06:31:02 * lispy is happy to finally have syntax highlighting on his blog
06:31:06 * lispy >>= nap
06:31:14 <ivanm> lispy: using what?
06:31:23 <lispy> ivanm: ready mah blog!
06:31:31 <lispy> ivanm: :)
06:31:33 <ivanm> codersbase.com?
06:31:38 <lispy> blog.codersbase.com
06:31:42 <ivanm> and why should I get your blog ready for you? :p
06:31:59 <lispy> oh, heh
06:32:04 <lispy> Tired typist is tired.
06:32:19 <monadic_kid> speaking of higher-rank polymorphism i think C++0x missed the boat on there lambdas
06:36:27 <Feuerbach> dons: great work, thanks!
06:36:36 <dons> :)
06:39:53 <greap> How odd Parsec's choice consumes further on every attempt, you have to explicitly use try.
06:42:02 <ivanm> greap: compare that to polyparse which optimised more at choice-like operations
06:48:56 * hackagebot shellish 0.1.1 - shell-/perl- like (systems) programming in Haskell  http://hackage.haskell.org/package/shellish-0.1.1 (PetrRockai)
06:51:23 <aristid> @hoogle (a,b) -> (b,a)
06:51:24 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
06:51:24 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
06:51:24 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
06:51:37 <ivanm> aristid: uncurry (flip (,))
06:51:43 <ivanm> or just do it manually
06:51:45 <aristid> :t snd&&&fst
06:51:46 <lambdabot> forall a c. (a, c) -> (c, a)
06:51:53 <ivanm> wow, no b?
06:52:19 <benmachine> :t (&&&)
06:52:20 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:53:44 <aristid> @hoogle swap
06:53:44 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
06:53:44 <lambdabot> Control.Concurrent.STM.TMVar swapTMVar :: TMVar a -> a -> STM a
06:54:02 <aristid> was thinking maybe there is an arrow operation swap or swapA
06:56:39 <ivanm> there was talk of defining a swap function
06:56:58 <ivanm> but it bogged down because people figured it was too simple and then they couldn't agree on how lazy to make it IIRC
06:57:08 <benmachine> :t arr snd &&& arr fst
06:57:09 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1) => a1 (a, b) (b, a)
06:57:34 <benmachine> I was thinking about unlifted tuples the other day
06:57:39 <benmachine> what would the drawbacks be?
06:57:55 <ivanm> what do you mean by unlifted?
06:58:05 <ivanm> do you mean unboxed?
06:58:05 <benmachine> well I'm not entirely sure!
06:58:21 <benmachine> no because unboxed tuples can only contain unboxed values, right?
06:58:27 <ivanm> bit hard to tell what the drawbacks would be if even you don't know what you're talking about! ;-)
06:58:31 <ivanm> benmachine: probably, yes
06:58:35 <benmachine> I think "unlifted" of a type basically means it doesn't contain _|_
06:58:41 <benmachine> e.g. newtypes are unlifted
06:58:45 <ivanm> not possible
06:59:00 <sioraiocht> ooh, I wondered that
06:59:05 <ivanm> the only types that can't have _|_ are unboxed and newtype due to the way newtype is implemented
06:59:08 <ivanm> (IIUC)
06:59:18 <sioraiocht> because with a lifted type T you could have T _|_ != _|_?
06:59:25 <benmachine> I think the idea is that unlifted tuples have that (_|_, _|_) = _|_
06:59:42 <benmachine> kind of like, all pattern matches are lazy
07:00:08 <benmachine> or something
07:00:13 * benmachine vague on the details
07:00:25 <benmachine> I remember reading in the history of haskell paper that there was a debate about it
07:04:01 <benmachine> hmm, unlifted tuples are incompatible with seq
07:04:47 <benmachine> because you can't make seq (_|_, _|_) x = _|_ but both seq (a, _|_) x = x and seq (_|_, b) x = x
07:05:02 <benmachine> without unamb or lub or whatever
07:14:47 <randomwords> luite: Thanks for all the work you did, if you could let me know the full list of modifications neccessary sometime, that would be great.
07:15:17 <aristid> to use bimap or not to use bimap. tough decisions :D
07:17:36 <benmachine> > foldr (\x zip lst -> case lst of [] -> []; (y:ys) -> (x,y) : zip ys) (const []) [1,2,3] [4,5]
07:17:36 <lambdabot>   [(1,4),(2,5)]
07:18:56 <Nibble> how would I accomplish infinite precision floating point numbers
07:19:28 <benmachine> Nibble: you can't
07:19:45 <benmachine> you can accomplish arbitrary-precision though, which is probably all you need
07:20:08 <benmachine> or you can have infinite-precision rational numbers, which is good for some other things
07:20:38 <Nibble> benmachine: Data.Ratio? From only looking at an example briefly, sounds like something for the job
07:20:48 <benmachine> Data.Ratio is pretty good yes
07:20:55 <Nibble> but that would require me to express them as a ratio
07:20:55 <benmachine> drawbacks being you can't square root or sin or anything
07:21:02 <benmachine> sure
07:21:08 <Nibble> benmachine: any other alternatives
07:21:21 <benmachine> well, it would help to know what you wanted to do with them
07:21:31 <benmachine> but you could try CReal from the numbers package
07:21:34 <benmachine> @hackage numbers
07:21:34 <lambdabot> http://hackage.haskell.org/package/numbers
07:22:11 <benmachine> the API is a bit
07:22:13 <benmachine> sparse
07:22:15 <benmachine> but there you go.
07:22:23 <Nibble> ah, arbitary was the right word.
07:24:08 <benmachine> hmm
07:24:23 <benmachine> the Eq and Ord instances for CReal look a bit suspect, actually
07:24:38 <benmachine> oh well
07:26:37 <Nibble> benmachine: what about BigFloat
07:26:52 <Nibble> nevermind
07:27:38 <luite> randomwords: I'm a bit busy at the moment, but I hope I can find some time tonight to see if I can solve the freetype issues
07:28:15 <luite> randomwords: the main thing I did to get it to work was to #undef WIN32 in gd.h, since it seems to assume that WIN32 => MSVC
07:28:32 <randomwords> luite: That makes sense
07:30:43 <Nibble> benmachine: am I right if CReal should be really slow?
07:31:45 <firegolfer> I need little help
07:31:53 <Nibble> firegolfer: shoot
07:32:01 <firegolfer> I currently have: 
07:32:04 <firegolfer> return $ prettyHtml $ ulist << table << (map (\a -> tr << ((td << a !! 0) +++ (td << a !! 1))) fields)
07:32:34 <firegolfer> and at the end it should be +++ (td << a !! 2) +++ (td << a !! 3) +++ (td << !! n)
07:32:52 <firegolfer> but... I actually don't want to write such a long line :(
07:33:03 <benmachine> Nibble: it is slow, yes
07:33:10 <firegolfer> I guess: I can map that too?
07:33:24 <firegolfer> *try*
07:33:39 <benmachine> firegolfer: I think you can do it with a foldr
07:33:45 <benmachine> but then, you can do most things with a foldr, so
07:34:42 <firegolfer> return $ prettyHtml $ ulist << table << (map (\a -> tr << (map (\a -> td << a))) fields)
07:34:45 <firegolfer> seems not to work
07:34:55 <benmachine> well no, you need to combine the list with +++
07:35:14 <benmachine> which library is this?
07:35:25 <firegolfer> Text.XHtml
07:35:32 <firegolfer> oh
07:35:35 <firegolfer> yeah @+++
07:35:41 <benmachine> http://hackage.haskell.org/package/xhtml this one
07:36:05 <firegolfer> Text.XHtml.Strict actually
07:36:07 <firegolfer> but
07:36:15 <firegolfer> tr << [td << "a",td << "b"] is totally valid
07:36:18 <benmachine> oh not that one then
07:36:26 <firegolfer> so
07:36:28 <benmachine> oh ok
07:36:33 <benmachine> ah
07:36:43 <benmachine> your problem is you're reusing the name a, and it's confusing
07:36:51 <benmachine> the second map isn't given a list
07:37:08 <firegolfer> oh
07:37:09 <firegolfer> right
07:37:42 <firegolfer> *shame on me*
07:37:50 <firegolfer>  table << (map (\a -> tr << (map (\n -> td << n) a)) fields) works fine
07:38:03 <por> Is there an easy way to restrict access to data types? For instance, suppose I have a data such as (F a Int), but 'Int' has n values. If I write a function (f :: Int -> ...) over just those n values, how do I avoid writing a partial function?
07:38:23 <por> (Without using Maybe or a dummy return value in e.g. a case expression).
07:38:43 <benmachine> firegolfer: technically you can re-use a there, it's just more likely to confuse you
07:38:52 <co_dh> por: can you use Enum? if n is not too big ? 
07:38:54 <Nibble> benmachine: can't one divide CReal?
07:39:00 <benmachine> Nibble: should be able to
07:39:35 <Nibble> hmm
07:39:41 <aristid> hmm, total maps would be cool.
07:39:46 <Nibble>     Couldn't match expected type `String' against inferred type `CReal'
07:39:47 <Nibble>     In the second argument of `(/)', namely `x'
07:40:01 <por> Sure, I can use enum
07:41:44 <firegolfer> ok
07:41:46 <firegolfer> but
07:42:05 <firegolfer> ((tr << td << "field1") ++ (map (\a -> tr << (map (\n -> td << n) a)) fields))
07:42:10 <firegolfer> since map returns [Html]
07:42:18 <firegolfer> and tr << td << "field" does too
07:42:33 <Nibble> benmachine: http://pastebin.com/tMNeFF2W
07:42:45 <firegolfer> oh
07:42:50 <firegolfer> must be encapsulated
07:45:03 <benmachine> Nibble: for some reason it thinks the function returns CReal but it doesn't
07:45:11 <co_dh> :t tr
07:45:12 <lambdabot> Not in scope: `tr'
07:45:52 <benmachine> Nibble: also, you're inviting a stack overflow in the first parameter, but that's another issue
07:46:09 <benmachine> Nibble: did you give the function a type signature, and if not how is it used?
07:46:19 <Nibble> benmachine: golden'''' :: CReal -> Int -> Int -> CReal
07:46:47 <benmachine> Nibble: showCReal wants to return String but that signature says it returns CReal
07:46:50 <benmachine> hence the error
07:47:00 <benmachine> why are you showing it?
07:48:03 <Nibble> benmachine: benmachine no idea
07:48:11 <Nibble> benmachine: or wait
07:48:13 <Nibble> there is one
07:48:15 <firegolfer> ok
07:48:23 <firegolfer> header << body << thespan << "body"
07:48:26 <Nibble> I want to be able to specify how many decimals it should print
07:48:27 <firegolfer> generates wrong html
07:49:09 <benmachine> Nibble: it doesn't print anything
07:49:21 <benmachine> how can it print anything if it returns a CReal?
07:49:36 <firegolfer> hm
07:49:44 <firegolfer> +++ vor header and body. and header must not be empty
07:50:00 <Nibble> benmachine: I fixed that.
07:50:06 <Nibble> now it is workingh
07:50:16 <benmachine> oh good
07:56:05 <chrisdone> needs more Text.Blaze
07:59:08 <mreh> have we got a function that will tally elements in a list
07:59:23 <Botje> define tally
07:59:31 <Botje> count the number of times each element appears?
07:59:37 <mreh> yah
07:59:49 <Botje> map (head &&& length)  . group . sort
07:59:51 <mreh> @hoogle [a] -> [(a,Int)]
07:59:51 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
07:59:51 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
07:59:51 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
08:00:39 <benmachine> group . sort turns up a lot
08:00:43 <benmachine> maybe it should have a name
08:00:49 <mreh> :t group
08:00:50 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
08:00:52 <yitz> histogram
08:01:00 <mreh> bleh
08:01:10 <aristid> :t \a -> a >>= \x -> a >>= \y -> return (x,y)
08:01:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m (a, a)
08:01:19 <Nibble> :t fix error
08:01:20 <lambdabot> [Char]
08:01:29 <Nibble> > fix 5
08:01:30 <lambdabot>   5
08:01:32 <Nibble> > fix -5
08:01:34 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a)
08:01:34 <lambdabot>    arising from a u...
08:01:36 <chrisdone> :t foldr (flip (M.insertWith (const (+1))) 1) (M.fromList [])
08:01:37 <lambdabot> forall a a1. (Num a, Ord a1) => [a1] -> M.Map a1 a
08:01:48 <mreh> what's the run time of group, O(n!) i suppose
08:02:14 <mreh> i don't know where I plucked that from
08:02:32 <yitz> sometimes it's faster to do foldl' (insertWith' (+ 1) 1) empty (into a Data.Map), depending on what you need to do with it
08:02:34 <chrisdone> > foldr (flip (M.insertWith (const (+1))) 1) (M.fromList []) [1,2,4,4,2,3]
08:02:35 <lambdabot>   fromList [(1,1),(2,2),(3,1),(4,2)]
08:02:54 <yitz> ^ a paraphrase, check argument order
08:03:03 <aristid> :t M.empty
08:03:04 <lambdabot> forall k a. M.Map k a
08:03:19 <benmachine> mreh: group is O(n) because it only groups consecutive element
08:03:19 <benmachine> s
08:03:25 <yitz> chrisdone: foldl' better than foldr here, often
08:03:53 <Saizan> i'd say always
08:04:09 <Saizan> since Data.Map is spine-strict
08:04:18 <mreh> I'm so hung over, my mind can't remember what foldl' does
08:04:33 <Saizan> > foldl' f z [1..3]
08:04:34 <lambdabot>   f (f (f z 1) 2) 3
08:04:35 <yitz> mreh: same as foldl. but applies the function strictly to each element
08:04:58 <yitz> > foldl (+) 0 [1..1000000]
08:04:59 <lambdabot>   *Exception: stack overflow
08:05:06 <yitz> > foldl' (+) 0 [1..1000000]
08:05:07 <mreh> oh yah
08:05:07 <lambdabot>   500000500000
08:05:54 <firegolfer> :t &&&
08:05:55 <lambdabot> parse error on input `&&&'
08:05:57 <yitz> mreh: foldl and foldl' are often the same for programs compiled with -O2. not in ghci though.
08:06:01 <firegolfer> :t (&&&)
08:06:02 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:06:14 <firegolfer> In which module is &&&?
08:06:19 <mreh> Arrow
08:06:22 <yitz> Control.Arrow
08:06:23 <mreh> Control.Arrow
08:06:29 <yitz> @hoogle &&&
08:06:30 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
08:06:34 * mreh wins
08:07:06 <yitz> hoogle always wins :)
08:07:15 <mreh> :(
08:07:46 <firegolfer> Awesome @ map (head &&& length) . group . sort
08:07:46 <mreh> :t M.insertWith
08:07:47 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
08:07:55 <yitz> @vixen does hoogle always win?
08:07:56 <lambdabot> how frequent is always?
08:08:32 <mreh> I often get the feeling she understands profound mysteries
08:09:10 <yitz> firegolfer: yeah, that's a useful variant
08:09:37 <mreh> :t M.insertWith'
08:09:37 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
08:09:42 <firegolfer> and totally makes sense
08:11:56 <aristid> :t M.fromList . map (snd&&&fst)
08:11:57 <lambdabot> forall a b. (Ord b) => [(a, b)] -> M.Map b a
08:17:27 <sshc> How do I write a Cont that doesn't call the future contiunation it is passed and instead always returns the same value and ignores the continuation it is passed?
08:17:40 <sshc> (I'm asking this since I'm trying to understand callCC)
08:19:14 <sshc> > let a = callCC $ \_ -> Cont $ \k -> 3 in      runCont a succ
08:19:15 <lambdabot>   3
08:19:31 <sshc> a is a contiunation, but succ was ignored
08:20:35 <sshc> > let b = callCC $ \k -> return 3 in runCont b succ
08:20:35 <lambdabot>   4
08:20:53 <deteego>  /quit
08:24:41 <Nibble> this awesome guy triclops have found out he could use python to program web applications.
08:27:33 <mietek> :r
08:39:23 <hpc> @hoogle [(a,b)] -> Map a b
08:39:23 <lambdabot> Data.Map fromDistinctAscList :: [(k, a)] -> Map k a
08:39:24 <lambdabot> Data.Map fromList :: Ord k => [(k, a)] -> Map k a
08:39:24 <lambdabot> Data.Map fromAscList :: Eq k => [(k, a)] -> Map k a
08:40:18 <BrianHV> is there a built-in function of type IO () that does nothing?
08:40:29 <hpc> :t DONE
08:40:30 <lambdabot> Not in scope: data constructor `DONE'
08:40:30 <hpc> er
08:40:32 <hpc> :t done
08:40:33 <lambdabot> String -> Int -> [[String]] -> IO String
08:40:44 <hpc> o.O
08:42:17 <sshc> BrianHV: return ()
08:42:34 <krey_> hi, how does one know when to use Maybe/[] for parsing?
08:43:02 <hpc> if something comes in quantities 0 or 1, use Maybe
08:43:08 <BrianHV> sshc: right.  I should have figured that out.  thanks.
08:43:13 <hpc> if it comes in quantities 0 to N, use []
08:48:05 <BrianHV> I've found myself writing one of those ugly nested case blocks that all the monad tutorials say to turn into a do block.  the problem is, some of the calls return Maybe and some return Either.  is there a way to clean that up?
08:48:34 <roconnor> I find it kinda upsetting that worker/wrapper transforms to lift out constants have to be done by hand.
08:50:24 <hpc> @hoogle Either a b -> Maybe b -> Either a b
08:50:25 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
08:50:25 <lambdabot> Data.Graph.Inductive.Monad delNodeM :: GraphM m gr => Node -> m (gr a b) -> m (gr a b)
08:50:25 <lambdabot> Data.Graph.Inductive.NodeMap delMapNode :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
08:51:08 <hpc> i would write a function toEither :: a -> Maybe b -> Either a b
08:51:12 <hpc> and use that to change Maybe to Either
08:51:37 <hpc> then continue using do
08:51:39 <BrianHV> good idea
08:53:16 <Codex_> I wrote some very awful looking code, http://codepad.org/nHRZq2pd Any ideas how to make it cleaner? :)
08:54:27 <hpc> Codex_: first off, use Bool instead of Maybe ()
08:54:45 <chrisdone> @google tibbe's style guide
08:54:46 <lambdabot> http://github.com/tibbe/haskell-style-guide
08:54:46 <lambdabot> Title: tibbe's haskell-style-guide at master - GitHub
08:55:46 <yitz> Codex_: (\p->ff p) == ff
08:56:03 <chrisdone> 80 columns, dude
08:57:36 <Botje> hide Bitmap from wherever you import it
08:57:41 <Codex_> hpc: I can't use Bool because I sometimes have something else than ().
08:57:44 <Botje> then you don't have to say Main.Bitmap everywhere
08:58:01 <chrisdone> Codex_: http://i.imgur.com/4WydL.jpg
08:59:19 <Codex_> botje: what was the syntax for hiding? :)
09:00:09 <hpc> import Foo hiding (bar, baz, Quux(..))
09:01:26 <yitz> Codex_: in charifyimage, ch == uncurry (maybe c2 (const c1) . f)
09:01:41 <chrisdone> /never/ use `hiding` for anything other than Prelude
09:01:52 <chrisdone> always import explicitly or qualified or both
09:02:15 <chrisdone> unless you want people to hate reading your code
09:02:34 <yitz> Codex_: but yeah, all those fromJusts & stuff indicate overuse of Maybe.
09:04:28 <Codex_> also I noticed that I need to pattern match the Bmp away so many times in it... that could be somehow better.
09:07:20 <yitz> so you could just make it type Bitmap a b = (a, a) -> Maybe b
09:08:25 <greap> Does anyone have any good examples of using parsec with bytestrings?
09:10:01 <luite> > let andnot a b = a >>= maybe return (\_ _ -> Nothing) b in andnot (Just 1) Nothing
09:10:02 <lambdabot>   Just 1
09:10:36 * hackagebot HaTeX 2.1.2 - Monadic tool for write LaTeX files.  http://hackage.haskell.org/package/HaTeX-2.1.2 (DanielDiaz)
09:14:47 <sbahra> What was that lint-like tool for cabal packages called again?
09:15:10 <Saizan> "cabal check"?
09:15:17 <Saizan> or was there another?
09:15:43 <sbahra> That was it. :-)
09:15:50 <sbahra> Thanks Saizan.
09:16:55 <yitz> greap: perhaps you are looking for attoparsec?
09:17:41 <yitz> @hackage attoparsec
09:17:41 <lambdabot> http://hackage.haskell.org/package/attoparsec
09:18:45 <BrianHV> if I have a series of functions I need to call of type IO (Either a b), is that where a monad transformer would come in handy?
09:18:59 <greap> yitz: Maybe...
09:19:42 <Saizan> BrianHV: possibly, since that's equivalent to ErrorT e IO a
09:20:07 <yitz> Saizan: provided that a is an instance of Error :(
09:21:02 <Saizan> ExceptionT e IO a, using monadLib, then :)
09:21:14 <BrianHV> guess I have some more reading to do. :)
09:21:46 * BrianHV can't wait until he's out of cargo-cult mode
09:24:35 <Nibble> btw
09:24:45 <Nibble> Is there any price for writing shitty code?
09:24:49 <Nibble> I might have a winner
09:25:01 <Nibble> length' xs = sum ([ 1 | x <- xs, (tail xs) /= []])
09:25:42 * hackagebot porte 0.0.4 - FreeBSD ports index search and analysis tool  http://hackage.haskell.org/package/porte-0.0.4 (SamyAlBahra)
09:25:55 <benmachine> ...what's with the tail xs thing
09:26:19 <ben_m> Probably a C coder's work
09:26:29 <Nibble> ben_m: nah, I wrote that when I was elarning haskell
09:26:32 <Nibble> learning*
09:26:43 <Nibble> ben_m: check if the next element is []
09:26:43 <ben_m> oh :)
09:26:49 <Nibble> but really
09:26:58 <benmachine> > let xs=[1,2,3]in sum [1|x<-xs]
09:26:58 <aristid> > let length' xs = sum ([ 1 | x <- xs, (tail xs) /= []]) in length' [1,2,3,4]
09:26:58 <lambdabot>   3
09:26:59 <lambdabot>   4
09:27:07 <aristid> > let length' xs = sum ([ 1 | x <- xs]) in length' [1,2,3,4]
09:27:08 <lambdabot>   4
09:27:18 <Nibble> aristid: see? it works
09:27:25 <benmachine> try length' [1]
09:27:25 <ben_m> Of course it works
09:27:26 <aristid> > let length' xs = sum ([ 1 | x <- xs, (tail xs) /= []]) in length' [1]
09:27:26 <lambdabot>   0
09:27:29 <benmachine> or length' []
09:27:31 <aristid> Nibble: nope.
09:27:31 <Nibble> indeed
09:27:36 <Nibble> aristid: it works for most cases
09:27:36 <ben_m> :D
09:27:47 <Nibble> but that only makes it more shitty
09:28:11 <Nibble> but really, can it be more shitty?
09:28:17 <aristid> no.
09:28:26 <Nibble> aristid: goal achieved
09:28:58 <aristid> it might be made more complex, but the shittiness is at MAX already
09:29:26 <Nibble> complexity O(100n^n) or something like that
09:29:34 <firegolfer> how can i filter each n-th element?
09:29:52 <Nibble> firegolfer: do a recursive call and increment a counter?
09:30:45 <firegolfer> hm
09:30:47 <hpc> or write [a] -> [(Int, a)]
09:30:53 <hpc> filter by what the Int is
09:30:56 <hpc> and change back
09:31:05 <Twey> > let length' = const succ `foldr` 0 in length' [1 .. 5]
09:31:06 <lambdabot>   5
09:31:23 <Nibble> Twey: I am not sure that is more shitty.
09:31:24 <Twey> Increased succ'iness!
09:31:32 <Nibble> Twey: but lol
09:31:34 <monochrom> > let length xs = maximum [sum [ 1 | x <- ys ] | ys <- tails xs] in (length [], length [3,1,4,1,5])
09:31:34 <lambdabot>   (0,5)
09:31:43 <chrisdone> Twey: that succs!
09:31:55 <Twey> chrisdone: Increasingly!
09:31:55 <monochrom> now the shittiness is really at "maximum" :)
09:32:00 <Twey> Heheh.
09:32:30 <ben_m> > map fst $ filter (\(_, n) -> n `mod` 5 == 0) (zip "foobarbazmoofoo" [1..])
09:32:31 <lambdabot>   "amo"
09:32:42 <aristid> > map snd . filter ((==0) . (`mod` 5) . fst) . zip [0..] $ ['A'..'Z']
09:32:43 <lambdabot>   "AFKPUZ"
09:32:53 <ben_m> >_>
09:33:03 <aristid> ben_m: you lose because your code is not point-free
09:33:41 <Nibble> that is enough to scare away anyone from haskell
09:33:53 <aristid> huh? that's a pretty simple expression
09:34:05 <monochrom> yeah, our new motto: scare newbies at all costs
09:34:08 <ben_m> I used point-free code all the time before
09:34:19 <aristid> monochrom: does it replace the "avoid success" motto?
09:34:24 <monochrom> yeah
09:34:25 <ben_m> Then I realized that I can read my code much better if I don't 
09:34:35 <monochrom> it also replaces: eat newbies at all costs
09:34:47 <aristid> damn, they taste so well
09:35:45 <monochrom> do-notation is point-free for the State monad
09:35:46 <chrisdone>  so I've written a hpast replacement. and I did all the development in Emacs. I only did the CGI part and tested it in the browser just now. works flawlessly, of course. the best part is, it's 366 lines of Haskell and I recorded every keystroke of it (including the '*haskell*', '*psql*' and '*shell*', buffers) each as a commit in a git repo. so I'll make a web page that shows it in realtime x 100 like an etherpad screencast
09:36:08 <hpc> ooh, fun
09:36:31 <hpc> alternatively, have it run at a constant keystroke rate
09:36:41 <monochrom> haskell is point-free for the heap and the environment etc.
09:36:59 <monochrom> every programming language is point-free for something.
09:37:20 <aristid> chrisdone: do that
09:37:26 <Nibble> @hoogle RealFloat
09:37:27 <lambdabot> Prelude class (RealFrac a, Floating a) => RealFloat a
09:37:32 <Nibble> @hoogle Float
09:37:32 <lambdabot> Text.Parsec.Token float :: GenTokenParser s u m -> ParsecT s u m Double
09:37:32 <lambdabot> Text.PrettyPrint.HughesPJ float :: Float -> Doc
09:37:32 <lambdabot> Language.Haskell.TH.PprLib float :: Float -> Doc
09:37:36 <ben_m> chrisdone: That sounds awesome
09:37:45 <chrisdone> \o/
09:38:55 <firegolfer> ok
09:38:59 <firegolfer> that makes it
09:39:03 <firegolfer> maximum $ map fst $ filter (\(_, n) -> n `mod` 2 == 0) (zip ((concat $ map (\n -> [fst n, snd n]) $ map (head &&& length)  . group . sort $ [99,8,7,7,7,6,6,6,7,7])) [1..])
09:39:07 <firegolfer> which is pretty ugly
09:39:09 <firegolfer> but works
09:39:13 <chrisdone> http://paste.lisp.org/display/114024
09:39:19 <chrisdone> quite a lot of language pragmas, hehe
09:39:26 <Twey> @let (y ?? n) p = if p then y else n
09:39:27 <lambdabot>  Defined.
09:39:50 <Twey> > catMaybes $ zipWith ((Just ?? const Nothing) . (== 0) . (`mod` 5)) ['A' .. 'Z'] [1 ..]
09:39:51 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
09:39:52 <lambdabot>    arising from a use of...
09:39:55 <ben_m> I should read up on all those pragmas...
09:40:01 <Twey> Oops, backwards
09:40:10 <Twey> > catMaybes $ zipWith ((Just ?? const Nothing) . (== 0) . (`mod` 5)) [1 ..] ['A' .. 'Z']
09:40:11 <lambdabot>   "EJOTY"
09:40:21 <Nibble> what does ?? do?
09:40:26 <monochrom> TypeDirectedTypeInference
09:40:27 <Twey> 17:39:02 < Twey> @let (y ?? n) p = if p then y else n
09:40:52 <Jafet> Nibble: as defined above.
09:41:02 * chrisdone go for pizza
09:41:09 <Nibble> oh uh
09:41:10 <Jafet> @let if' p t f = if p then t else f
09:41:11 <lambdabot>  Defined.
09:41:23 <Twey> Like that, but with a more useful argument order.
09:42:05 <BrianHV> is there a syntax/function that will copy an existing record with one field altered?
09:42:18 <Twey> BrianHV: oldRecord { fieldName = newFieldValue }
09:42:28 <BrianHV> nice.  thanks.
09:42:31 <Jafet> @cheatsheet
09:42:31 <lambdabot> Unknown command, try @list
09:42:38 <Jafet> @where cheatsheet
09:42:38 <lambdabot> I know nothing about cheatsheet.
09:42:39 <hpc> @where cheatsheet
09:42:39 <lambdabot> I know nothing about cheatsheet.
09:42:49 <Jafet> @vixen what do you know?
09:42:50 <lambdabot> yeah, i know
09:42:57 <monochrom> heh
09:43:50 <mreh> and the best joke told by a machine goes to...
09:44:15 <Jafet> @hackage CheatSheet
09:44:15 <lambdabot> http://hackage.haskell.org/package/CheatSheet
09:44:22 <Twey> @where+ cheatsheet http://blog.codeslower.com/static/CheatSheet.pdf
09:44:22 <lambdabot> I will never forget.
09:44:33 <Twey> @where cheatsheet
09:44:33 <lambdabot> http://blog.codeslower.com/static/CheatSheet.pdf
09:45:37 <blah> That's more like a cheat book ;)
09:46:18 <Phyx-> Is there a easy one liner to do, given a [a -> Maybe a] and a keep applying everything in the list till one fails or you're done?
09:46:25 <mreh> anyone know the semantics of the a -> a -> a in insert with?
09:46:32 <Phyx-> i tried foldl (>>=) but that's of the wrong type
09:46:38 <Phyx-> the argument becomes m a
09:47:02 <Twey> mreh: If the key already exists in the map, this function is applied to the old and new values to determine what the new value will be
09:47:17 <Twey> So you can e.g. sum maps
09:47:19 <mreh> Twey: I just want to add 1 to the old value
09:47:29 <Twey> :t const succ
09:47:30 <lambdabot> forall a b. (Enum a) => b -> a -> a
09:47:37 <hpc> :t foldl (>>=)
09:47:38 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
09:47:50 <krey_> Phyx-: foldr1 (>=>) ?
09:48:13 <hpc> :t foldr1 (>=>)
09:48:14 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> b -> m b
09:48:38 <hpc> does it fold in the right direction?
09:48:40 <Phyx-> krey_: that'll work, thanks
09:49:00 <Phyx-> hpc: no I need it as a left fold, so i'm gonna use foldl1
09:49:31 <yitz> > let length' = untriangle . sum . concatMap (map $ const 1) . tails; untriangle = (`div` 2) . isqrt . (+1) . (*8); isqrt n = stable (\x -> (n + x*x) `div` (2 * x)) n; stable f x = fst $ until (uncurry (==)) (\(a, b) -> (b, f b)) (x, f x) in length' [1..5]
09:49:32 <lambdabot>   5
09:50:10 <yitz> Nibble: ^
09:50:35 <krey_> hpc: (>=>) is associative
09:51:32 <aristid> yitz: that is crazy, but not really shitty
09:51:40 <hpc> just wondering because for m = [], you could use one of the folds to stream
09:51:51 <hpc> i think
09:51:59 <yitz> darn
09:52:07 <Phyx-> krey_: yeah, but the fold direction matters in my case
09:52:10 <Phyx-> left vs right
09:52:14 <yitz> @pl let length' = untriangle . sum . concatMap (map $ const 1) . tails; untriangle = (`div` 2) . isqrt . (+1) . (*8); isqrt n = stable (\x -> (n + x*x) `div` (2 * x)) n; stable f x = fst $ until (uncurry (==)) (\(a, b) -> (b, f b)) (x, f x) in length'
09:52:16 <lambdabot> (`div` 2) . ((fst .) =<< ap ((.) . until (uncurry (==)) . (. snd) . ap (,)) (ap (,)) . (`ap` (2 *)) . (div .) . (. join (*)) . (+)) . (1 +) . (8 *) . sum . (map (const 1) =<<) . tails
09:52:24 <yitz> aristid: better?
09:52:39 <krey_> Phyx-: why? care to explain?
09:52:44 <hpc> yitz: perfect!
09:52:50 <aristid> yitz: yeah.
09:52:56 <yitz> tnx :)
09:53:04 <Jafet> pl is usually suboptimal
09:53:40 <Jafet> Well, I guess it doesn't matter in this case
09:53:48 <Phyx-> krey_: because it's folding to apply type substitutions, the list is build and maintained in that applying left to right terminates earlier than right to left. both will eventually reach the same answer though
09:54:22 <krey_> krey_: fair enough :)
09:54:25 <krey_> argh
09:54:33 <krey_> Phyx-: fair enough :)
09:54:36 <krey_> i's an idiot
09:56:04 <Nibble> mine was shitty
09:56:06 <Nibble> idiotic
10:01:25 <aristid> :t until
10:01:26 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
10:01:40 <aristid> @src until
10:01:40 <lambdabot> until p f x | p x       = x
10:01:41 <lambdabot>             | otherwise = until p f (f x)
10:04:17 <aristid> @unpl (`div` 2) . ((fst .) =<< ap ((.) . until (uncurry (==)) . (. snd) . ap (,)) (ap (,)) . (`ap` (2 *)) . (div .) . (. join (*)) . (+)) . (1 +) . (8 *) . sum . (map (const 1) =<<) . tails
10:04:18 <lambdabot> (\ q -> div ((((\ af d e -> until (uncurry (==)) (\ ce -> ((,) >>= \ an -> af >>= \ am -> return (an am)) (snd ce)) (d e)) >>= \ y -> (\ ax -> (,) >>= \ au -> ax >>= \ at -> return (au at)) >>= \ x -
10:04:18 <lambdabot> > return (y x)) >>= \ b cb -> fst (b cb)) ((\ ch -> div ((1 + (8 * (sum ((tails q) >>= (map (\ _ -> 1)))))) + (((*) >>= \ bi -> bi) ch))) >>= \ cm -> (\ g -> 2 * g) >>= \ cl -> return (cm cl))) 2)
10:04:29 <aristid> now THAT is shitty.
10:04:51 <hpc> needs more parenthesis
10:05:29 <hpc> also, i like how it expands (*) >>= id
10:11:57 <Jafet> > let length [] = 0; length xs = succ . length' . (inits xs !!) . length' . head . drop 1 $ tails xs in length [1..30]
10:11:58 <lambdabot>   Not in scope: `length''Not in scope: `length''
10:12:06 <Jafet> > let length [] = 0; length xs = succ . length . (inits xs !!) . length . head . drop 1 $ tails xs in length [1..30]
10:12:10 <lambdabot>   mueval-core: Time limit exceeded
10:13:16 <chrisdone> good lord
10:15:51 <MangledBody> Hi everybody!
10:16:32 <MangledBody> Can anyone explain me Curry function? I'm new to Haskell...
10:16:41 <Jafet> @src curry
10:16:42 <lambdabot> curry f x y = f (x, y)
10:17:14 <Botje> uncurry is rather more popular
10:18:07 <MangledBody> Botje: uhuh...
10:18:12 <MangledBody> lambdabot: Thanks
10:18:20 <Twey> @bot
10:18:21 <lambdabot> :)
10:19:02 <MangledBody> Jafet: Thanks to you too :D
10:19:09 <ionfish> speaking more generally, currying converts a function which accepts n arguments into a nest of n lambdas which each accept one argument
10:19:23 <Twey> Hmmm
10:19:28 <Twey> Not really
10:19:30 <Jafet> (Therefore, there is no currying in haskell!)
10:19:34 <Twey> Hehe
10:19:38 <ionfish> e.g. the operation f = ?xyz.M -> f* = ?x.(?y.(?z.M))
10:20:25 <Twey> ionfish: In Haskell and Î»-calc, all functions that âaccept n argumentsâ are in fact a series of n functions.
10:20:48 <MangledBody> ionfish: thanks
10:20:58 <Twey> Î»xy. M is merely shorthand for Î»x. Î»y. M
10:21:18 <ionfish> I realise that; currying is a notational trick to simplify the lambda calculus so it doesn't need functions with multiple arguments
10:21:20 <MangledBody> Twey: Is it true that Gimp is written in Haskell??
10:21:50 <MangledBody> ionfish: Yes, I heard that in school, but I completely forgot it... 
10:22:03 <MangledBody> ionfish:  Mathematics in Haskell is horrible :D
10:22:09 <Codex_> mangledbody: doesn't sound right
10:22:19 <Twey> MangledBody: More specifically, the function âcurryâ in Haskell takes a function that accepts one argument that is a pair of two values and converts it into a function that accepts two values in the style ionfish described (as a function that accepts one argument and returns a function that accepts the other argument), with the latter being the usual argument-passing mechanism in Haskell
10:22:58 <MangledBody> Twey: *THUMBS UP*
10:23:13 <MangledBody> Twey: Does Haskell have any IDE??
10:23:15 <Twey> With the function âuncurryâ doing the opposite transformation (converting from a âcurriedâ two-argument function into a function that accepts a single pair of arguments)
10:23:27 <benmachine> Twey: Î»x. Î»y. M is a function that accepts two arguments :P
10:23:29 <MangledBody> Twey: I'm little bit nervous about Hugs
10:23:35 <Twey> MangledBody: I don't believe it is, and there are several IDEs capable of working with Haskell.
10:23:48 <Twey> MangledBody: Hugs is not much used these days.  Try GHC instead.
10:24:25 <Twey> We have our own Leksah, though how complete or functional it is I don't know; there's also KDevelop, the KDE IDE, which has had Haskell support for a long time, and, I believe, a plugin for Eclipse
10:24:57 <Twey> However, most of us just use a generic editor (vim, emacs, or sometimes Yi, which is kind of like an emacs built using Haskell instead of a Lisp)
10:25:23 <benmachine> yi can pretend to be vim
10:25:28 <benmachine> but it's not very good at it in my experience
10:25:29 <Twey> So can emacs ;)
10:25:33 <MangledBody> Twey: ok
10:25:46 <MangledBody> Thanks guys! Bye!
10:25:51 <Twey> 'bye!
10:33:32 * chrisdone squints at the mangled body
10:39:45 <orbital_fox> anyone here into webdevelopment with haskel?\
10:47:15 <tehgeekmeister> is my intuition that applicative functors are monads without join and >>= correct?
10:49:36 <BrianHV> if I have an Int and need a CLong, how do I convert?
10:49:45 <luite> fromIntegral
10:49:57 * BrianHV tries that again.
10:50:34 <Twey> @quote fromIntegral
10:50:35 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
10:50:42 <Twey> Oh gods
10:50:48 <Twey> @quote fromIntegral
10:50:48 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
10:50:54 <Twey> That's the one
10:51:07 <BrianHV> huh.  that worked.  dunno what I was doing before.
10:51:55 <aRcatan> if applicative functor had join, >>= could be written in terms of it (and vice versa)
10:52:04 <Twey> \b @quote is getting to be a bit like /b/: it's Russian roulette.  You never know whether you're going to get something amusing or a snapshot of an illegal operation that's going to make you want to tear out your eyes.
10:52:09 <Twey> tehgeekmeister: Yes
10:52:21 <jmcarthur> aRcatan: yes
10:52:23 <Twey> tehgeekmeister: A monad is, by definition, an applicative functor with join
10:52:38 <jmcarthur> aRcatan: in fact, just adding join to Functor is enough to make Monad
10:52:40 <tehgeekmeister> Twey: oh, right, and >>= depends on join, this makes sense
10:52:48 <jmcarthur> oh, well
10:52:51 <jmcarthur> except for return
10:52:56 <Twey> tehgeekmeister: You can write join in terms of >>= or >>= in terms of join: it doesn't matter which way around you go
10:52:58 <jmcarthur> but you can write (>>=) with join and fmap
10:53:06 <benmachine> functors are monads without >>= and join
10:53:09 <Twey> jmcarthur: Applicative functors have returnâ¦
10:53:10 <benmachine> and return.
10:53:11 <Twey> :t pure
10:53:11 <benmachine> whoops
10:53:12 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
10:53:18 <jmcarthur> Twey: i corrected myself already ;)
10:53:19 <tehgeekmeister> what instances of applicative can't have an analog to join?
10:53:25 <tehgeekmeister> I can't think of any off the top of my head
10:53:26 <Twey> Oh, right
10:53:29 <jmcarthur> tehgeekmeister: ZipList, for example
10:53:31 <Twey> You meant on top of Functor.  Okay.
10:53:38 <aristid> :t ((.).(.)) join fmap
10:53:39 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
10:54:16 <tehgeekmeister> jmcarthur: huh; why can't ziplist, but list can (and obviously does)
10:54:23 <jmcarthur> tehgeekmeister: try it and see
10:54:48 <jmcarthur> tehgeekmeister: just make sure you check the laws relating Applicative and Monad
10:55:50 <jmcarthur> tehgeekmeister: hint: you can do it if you don't allow empty ZipLists
10:56:05 <aRcatan> but yes, i think you're right
10:56:11 <jmcarthur> that would be the semantics of data Stream a = Cons a (Stream a)
10:56:58 <tehgeekmeister> wait, i was confusing ziplists and zippers, and remembering wrong what a zipper is
10:57:01 <tehgeekmeister> what *is* a ziplist
10:57:55 <tehgeekmeister> ah, okay, found it
10:58:05 <jmcarthur> it's a list where the semantics are more like zipWith than concatMap
10:58:42 <jmcarthur> liftA2 = zipWith rather than (=<<) = concatMap, that is
10:59:06 <jmcarthur> but critically you can't define a Monad instance such that liftM = zipWith unless you don't allow empty lists
10:59:31 <jmcarthur> *liftM2
11:00:20 <tehgeekmeister> yeah, i see
11:00:24 <benmachine> jmcarthur: I thought you generally had to not allow lists of different length
11:00:28 <benmachine> hence, infinite lists working well
11:01:49 <jmcarthur> benmachine: that might be true
11:02:05 <jmcarthur> but that's yet harder to enforce
11:02:36 <jmcarthur> hmm.... so there would be a monad for data Pair a = Pair a a ?
11:03:10 <tehgeekmeister> what would join be?
11:03:20 <jmcarthur> join (Pair (Pair a b) (Pair c d)) = Pair a d ?
11:03:26 <Saizan> yep
11:03:31 <tehgeekmeister> weird
11:03:40 <aristid> :t liftA2 (,)
11:03:41 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
11:04:12 <tehgeekmeister> i can't see why ziplists are useful, yet.  seems like in any case one wants a ziplist, there are better ways to do it
11:04:39 <ahihi> tehgeekmeister: if you're looking for an intuitive explanation of the difference in power between Monad and Applicative, I think the original paper by McBride and Paterson has a pretty nice one
11:04:41 <jmcarthur> they are useful because you can use any function that works on applicative on a ziplist ;)
11:04:57 <jmcarthur> tehgeekmeister: http://just-bottom.blogspot.com/2010/04/programming-with-effects-story-so-far.html
11:05:00 <ahihi> "Intuitively, the (>>=) :: m a â (a â m b) â m b of some Monad m allows the value returned by one computation to influence the choice of another, whereas â keeps the structure of a computation fixed, just sequencing the effects."
11:05:16 <mtnviewmark> but yes, the zipXxx functions are generally easier to use and all you need
11:05:36 <ahihi> (where â = <*>)
11:06:43 <tehgeekmeister> hmm.  are there other examples of applicatives that are not monads?
11:07:04 <tehgeekmeister> i do not grok this example, though i get what ziplists do.
11:07:57 <jmcarthur> i do occasionally run across things that are applicatives but not monads, but i never retain the information to give as an example
11:09:19 <tehgeekmeister> okay.
11:09:44 <tehgeekmeister> i'm just trying to get what makes applicative (or <*>) useful when we have monads
11:09:53 <mtnviewmark> off-topic funny: recursive bumper sticker: http://www.contextfreeart.org/gallery/view.php?id=2400
11:10:45 <jmcarthur> tehgeekmeister: the useful thing is that if you can write a function in terms of just applicative and not in terms of monad then it will apply to more data types
11:11:32 <mtnviewmark> > fix (\x -> "I â¥ [ " ++ x ++ " ]")
11:11:33 <lambdabot>   "I \9829 [ I \9829 [ I \9829 [ I \9829 [ I \9829 [ I \9829 [ I \9829 [ I \9...
11:12:03 <tehgeekmeister> jmcarthur: that's sensible.  but i've not gotten to the point of writing general code in terms of either, so this doesn't really click for me.  i've used specific monads, but i've never wrote code for monads in general.
11:12:16 <mtnviewmark> > putStrLn $  fix (\x -> "I â¥ [ " ++ x ++ " ]")
11:12:17 <lambdabot>   <IO ()>
11:12:26 <shortcircuit> It only took catching a Haskell programmer for about 30-45 minutes at BarcampGR for me to finally understand monads. Or, at least, understand monads as well as one who's never written a line of Haskell can.
11:12:38 <mtnviewmark> oy - why won't LambdaBot put out UTF8?
11:12:42 <shortcircuit> Also, I got my pronounciation correct. :)
11:13:42 <ahihi> Applicatives are more composable than Monads too
11:14:22 <ahihi> specifically, the composition of two Applicatives is always another Applicative
11:14:32 <Saizan> > text $  fix (\x -> "I â¥ [ " ++ x ++ " ]")
11:14:38 <lambdabot>  Terminated
11:14:44 <Saizan> heh
11:15:00 <Saizan> > text $ "I â¥ [ "
11:15:01 <aristid> > text . take 100 $ fix (\x -> "I â¥ [ " ++ x ++ " ]")
11:15:02 <lambdabot>   I â¥ [
11:15:03 <lambdabot>   I â¥ [ I â¥ [ I â¥ [ I â¥ [ I â¥ [ I â¥ [ I â¥ [ I â¥ [ I â¥ [ I â...
11:15:17 <aristid> wtf
11:15:29 <jmcarthur> tehgeekmeister: it's also helpful to be able to isolate the properties of your data types and helps you understand your code
11:16:00 <jmcarthur> tehgeekmeister: if i see (a `foo` b) then i don't know what to read out of it, but if i see (a <*> b) then i can learn a lot more about it
11:16:03 <tehgeekmeister> shortcircuit: i get monads (i have practical difficulties with transformers sometimes, though), i just haven't needed to write any code for monads in general yet.
11:16:04 <Twey> shortcircuit: Unlike in âpronunciationâ?  ;)
11:16:44 <tehgeekmeister> jmcarthur: right, of course if you can make your types an instance of something sanely, you should
11:17:13 * tehgeekmeister should stop reading up on functors, applicative functors and whatnot, and start working on his real projects for the day.
11:20:07 <jmcarthur> man, i really like the idea of distributed bug tracking, but none of the existing ones seems to be any state of usefulness
11:20:20 <jmcarthur> *be in any
11:25:54 <Mitar> this is probably in FAQ, but how can I match on multiple patterns in case ... of at the same time?
11:26:17 <Jafet> What do you mean?
11:26:27 <chrisdone> simultaneously!?
11:26:39 <Jafet> > case 1 of 0 -> "zero"; 1 -> "one"; 2 -> "two"; _ -> "woah"
11:26:40 <lambdabot>   "one"
11:26:52 <Twey> Uhh, what would that even mean?
11:27:01 <Mitar> like
11:27:06 <Zao> If you want to match on multiple values, you can tuple them.
11:27:22 <Zao> case (a,b) of (Foo,Bar) -> ...; (Foo,Baz) -> ...; 
11:27:24 <Mitar> case bla of Bla _ | Blu _ -> do something ; _ -> do other
11:27:45 <Zao> Some kind of fallthrough then?
11:27:57 <Mitar> ehm, yes, could be also fallthrough
11:28:02 <Twey> Hm
11:28:06 <Zao> Maybe you can let (do something) and use some friendly name for it?
11:28:16 <Zao> View patterns, maybe?
11:28:24 <mrd> case x of 0 -> foo; 1 -> foo where foo = ...
11:28:35 <chrisdone> probably only worth if if you have to match >5
11:28:52 <Mitar> ok, i was just checking if there is something in syntax i am missing
11:28:57 <Mitar> so i have to make a function ...
11:30:14 <Zao> I can't say I've ever understood view patterns though.
11:30:40 <Twey> Or case bla of x | isBla x || isBlu x = do something where isBla (Bla _) = True; isBla _ = False; isBlu (Blu _) = True; isBlu _ = False
11:30:47 <aristid> is there any problem with scoped type variables? why weren't they included in haskell 98, or even -fglasgow-exts?
11:31:01 <Twey> Zao: What's not to understand?  It just involves applying a function before you match.
11:31:11 <Twey> aristid: They weren't invented then
11:31:20 <Twey> aristid: I'm pretty sure they're in 2010
11:31:26 <Zao> Twey: I made a mistake and tried to read http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
11:31:31 <Twey> Zao: Oh :
11:31:32 <Twey> :Ã¾
11:32:01 <Twey> Zao: A pattern (foo -> bar) simply applies the function âfooâ to the argument at that position and then matches the result against the pattern âblaâ normally.
11:32:11 <aristid> Twey: invented as in, the way to implement them? or even just the idea? being able to use type variables in the function body doesn't sound like a radical idea
11:32:15 <Twey> Nothing scary about it.
11:32:33 <Twey> aristid: Pass
11:33:18 <aristid> hmm
11:36:51 <mietek> Is there a way to go from a Bits instance to a Num instance, without requiring the value to be also an Integral instance?
11:37:29 <HskNoob> Q: Profiling searching nearest fib value is really slow. fibBelow i = takeWhile (<= i) fibs  and  fibMax i = maximum (fibBelow i) consume 98% of walltime, tips?
11:37:30 <mietek> Since  Num a => Bits a  it seems to me this should be possible
11:37:39 <Nibble> A quick question, the <-, what does it mean?
11:37:49 <Twey> Nibble: That's not a quick question ;)
11:37:53 <Jafet> @undo do { a <- b; c }
11:37:54 <lambdabot> b >>= \ a -> c
11:37:59 <Jafet> That's all it means, kids.
11:38:04 <Nibble> I see
11:38:25 <Twey> It doesn't have any meaning on its ownâ¦ it's part of the whole magic do-notation malarkey.
11:38:35 <Nibble> Twey: I know some about monads and do notation
11:38:42 <mietek> Nibble: http://book.realworldhaskell.org/read/monads.html#monads.do
11:38:44 <Twey> Oh, then you're fine.
11:38:53 <Phyx-> haskell has too much magic :)
11:39:24 <Phyx-> I half expect david coperfield to pop up when using unsafePerformIO
11:39:43 <bremner> what is magical about unsafePerformIO ?
11:39:52 <Nibble> bremner: it is not pure
11:39:57 <bremner> neither is C
11:40:04 <burp> escaping IO jail
11:40:06 <Nibble> according to someone that wrote it in a comment
11:40:12 <Nibble> to realworldhaskell
11:40:27 <Jafet> The whole point of unsafePerformIO is that it is pure
11:40:37 <Jafet> (But obviously unsafe)
11:41:05 <Phyx-> (and can break referntial transparency)
11:41:32 * bremner is confused. pure referential transparency breakage?
11:43:34 <mauke> unsafePerformIO can break everything
11:43:51 <Nibble> unsafePerformIO can divide by zero
11:44:23 <mietek> @let bits2num = fromIntegral :: (Bits a, Integral a, Num b) => a -> b
11:44:24 <lambdabot>  Defined.
11:44:34 <Phyx-> mauke: it can't break my pride!! (i hope)
11:44:35 <byorgey> unsafePerformIO can beat up Chuck Norris
11:44:42 <mietek> Is there another way of doing this, without having to depend on Integral?
11:44:47 <byorgey> but not Oleg
11:45:42 <lispy> Oleg is the only know I know who can unsafePerformIO in the type system
11:46:19 <rickster> http://hackage.haskell.org/platform/     <-- this the correct site to download from ?
11:46:30 <Phyx-> bremner: for instance, if you have (unsafePerformIO ..); (unsafePeformIO ..); so the same statement, if CSE is done you'd end up with p; p; for instance. where p is only executed once. which is wrong
11:47:27 <lispy> Phyx-: in general, ghc doesn't do cse though
11:47:34 <bremner> CSE?
11:47:40 <lispy> bremner: common subexpression elimination
11:47:49 <Phyx-> lispy: I thought it didn't do much but it does do some?
11:48:11 <lispy> bremner: like implicitly adding a let and reusing an expression.  It's something compilers can do automatically in many cases.  The questions is: when is it a _good_ optimization
11:48:26 <lispy> Phyx-: I'm really not sure how much it does.  It's a tricky optimization to apply generally
11:48:38 <Phyx-> true
11:49:01 <lispy> It is a good technique to do as a programmer though :)
11:49:13 <Phyx-> heeheh
11:49:17 <lispy> Usually it makes the code easier to read, but sometimes it increases space
11:49:33 <lispy> laziness really messes with the traditional optimizations
11:49:52 <lispy> like doing the transformation from non-tail recursive to tail recursive isn't an obvious win in Haskell
11:50:00 <Phyx-> when does it increase space? unless you don't mean source code lines
11:50:12 <Jafet> But traditional optimizations rarely mess with laziness
11:50:22 <lispy> It can be faster, but not always.  And you usually need to be strict in the accumulator if you use tail recursion
11:50:31 <lispy> Phyx-: I mean run-time space usage
11:50:34 <Phyx-> ah ok
11:50:59 <lispy> Phyx-: it makes sense because you're asking the RTS to hold on to things until both points have used it (or all N places)
11:51:01 <byorgey> rickster: yes
11:51:19 <chrisdone> hehe, my "emacscast" repo has 37652 commits
11:51:23 <Phyx-> lispy: yeah, I was confused since we were talking about source lines :)
11:51:25 <lispy> Phyx-: if you were, say, using weak pointers maybe it wouldn't matter
11:51:25 <Jafet> Maybe the runtime should have optimistic gc triggers, to remove parts of shared objects
11:51:36 <chrisdone> git and gitg handles it well
11:51:37 <Jafet> I leave the implementation as an exercise.
11:51:41 <byorgey> chrisdone: ?
11:52:00 <lispy> Jafet: haha.  Yeah, isn't the GC looking at the halting problem everywhere it looks?
11:52:06 <byorgey> chrisdone: what is emacscast?
11:52:07 <chrisdone> byorgey: I'm recording all changes to specific emacs buffers (.hs, *haskell*, *shell*) etc as a kind of emacs-cast, to a git repo
11:52:18 <Jafet> lispy: not necessarily; it could be compiled in when the sharing is added
11:52:20 <chrisdone> (while working on a project)
11:52:23 <Phyx-> lispy: lol, how far along is it to solving it? :P
11:52:26 <byorgey> chrisdone: oh, I see. neat.
11:52:30 <Phyx-> GC.statusHaltingproblem
11:52:39 <Jafet> lispy: and if all else fails, it throws a NonTerminationException
11:52:49 <Jafet> (Yeah, that exists...)
11:52:55 <Phyx-> it does?
11:53:07 <lispy> Phyx-: well, it some cases the GHC rts does correctly solve the halting problem ( see <<loop>> exception)
11:53:15 <Phyx-> lol
11:53:18 <Phyx-> Blackholing
11:53:26 <Jafet> Exception.NonTermination, it seems
11:54:00 <Jafet> That's what the rts uses to print <<loop>>
11:54:23 <Jafet> Now the better part is yet to come. I think you can spoon it
11:54:32 <Phyx-> eh?
11:54:44 * Phyx- hopes it's not the "spooning" he has in mind
11:55:29 <Jafet> http://hackage.haskell.org/packages/archive/spoon/0.3/doc/html/Control-Spoon.html
11:55:31 <chrisdone> byorgey: http://paste.lisp.org/display/114026
11:55:56 <Phyx-> Jafet: that's much better :
11:56:05 * Phyx- can almost test his typesystem
11:56:14 <ski> Jafet : something similar to <http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#Selectorthunks> ?
11:57:08 <Jafet> Uncannily so
11:58:46 <jmcarthur> "Patterns not matched: #x with #x `notElem` ["firstname"#, "lastname"#]"  <-- that is a pretty cool error message
11:59:30 <Jafet> chrisdone: cd / && git init
12:00:03 <sshc> Yes!  I finally understand callCC :D
12:00:22 <aristid> sshc: will you still understand it in 5 minutes? :)
12:00:45 <ski> sshc : now implement nondeterminism with it (plus state)
12:02:40 * Phyx- just realised he hasn't eaten today
12:03:00 * Phyx- waddles off to the kitchen
12:04:47 <Nibble> where is Database.HDBC.ODBC? I have installed HDBC
12:05:53 <randomwords> I wish there was an easy way to automattically SCC everything, it can be tedious
12:06:54 <Heffalump> Nibble: there's a separate package for it
12:06:56 <Phyx-> @hoogle Maybe a -> [a]
12:06:57 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
12:06:57 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
12:06:57 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
12:07:11 <Heffalump> randomwords: including sub-declarations?
12:07:12 <Nibble> Heffalump: where?
12:07:16 <burp> randomwords: you mean the whole os?
12:07:23 <Nibble> nvm
12:07:23 * hackagebot ls-usb 0.1.0.6 - List USB devices  http://hackage.haskell.org/package/ls-usb-0.1.0.6 (RoelVanDijk)
12:07:26 <randomwords> Heffalump: Yeah
12:07:47 <randomwords> burp: No, just all the expressions within a given piece of code
12:08:46 <Nibble> db.hs:10:2: Not in scope: `catchDyn'
12:08:47 <Phyx-> :t foldr M.insert
12:08:47 <lambdabot>     Occurs check: cannot construct the infinite type:
12:08:48 <lambdabot>       b = M.Map a b -> M.Map a b
12:08:48 <lambdabot>     Probable cause: `M.insert' is applied to too few arguments
12:09:04 <Phyx-> :t foldr (\a->M.insert undefined x)
12:09:05 <lambdabot> forall a a1. (Ord a1) => M.Map a1 Expr -> [a] -> M.Map a1 Expr
12:09:07 <sshc> aristid: What helped me understand is the realization that continuations could ignore future continuations
12:09:25 <sshc> Cont $ const 3 for example
12:09:43 <lispy> sshc: CPS lets you change your destiny
12:09:44 <Nibble> @hoogle catchDyn
12:09:45 <lambdabot> Control.OldException catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
12:09:45 <sshc> I somehow thought that the function would always be called with a result
12:09:47 <Nibble> oh.
12:09:52 <Nibble> what is the new version of that?
12:10:06 <lispy> ?hoogle catch
12:10:06 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
12:10:06 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
12:10:06 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
12:10:28 <lispy> Nibble: in some sense, I think it's just Control.Exception.
12:10:31 <Heffalump> Nibble: HDBC-odbc
12:10:37 <ski> sshc : the fun starts to happen when the continuation is called more than once :)
12:11:32 <Nibble> lispy: I have that included
12:12:20 <lispy> Nibble: I don't mean that the name and type are the same
12:12:46 <lispy> Nibble: But, the newer catch takes an instance of Exception now
12:12:58 <lispy> Nibble: so that's kind of like the Typeable constraint, I think
12:13:14 * sshc am very happy to finally understand continuations
12:14:03 * Phyx- cries that with the complexity of the problems the type errors just get horrible
12:14:47 <Jafet> sshc: now understand delimited continuations
12:15:40 <carter> hey folks: am I correct in thinking that foldM is strict?
12:15:47 <sshc> Can template haskell always be used instead of hsc2hs?
12:16:02 <lispy> carter: I don't know the answer for sure, but it seems that way yes
12:16:05 <lispy> ?src foldM
12:16:06 <lambdabot> foldM _ a []     = return a
12:16:06 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
12:16:15 <carter> lispy: thats what I was thinkin
12:16:17 <carter> but
12:16:18 <Phyx-> lispy: for all problems?
12:16:19 <Jafet> sshc, no, they do entirely different things
12:16:20 <lispy> carter: it should really depend on if (>>=) is strict
12:16:30 <carter> hrmmm
12:16:33 <Phyx-> oh sorry
12:16:40 <Phyx-> i confused carter and sshc 
12:16:41 <lispy> carter: I haven't played with it in a lazy monad to check
12:16:57 <carter> well
12:17:00 <carter> for Cont r
12:17:17 <carter> bind m k is Cont $ \c -> runCont m $ \a -> runCont (k a) c
12:17:33 <Nibble> what about hdbc-mysql?
12:17:43 <carter> so i'm not sure if thats strict
12:17:59 <lispy> carter: doesn't look strict to me
12:18:01 <carter>  / i dont' think it is
12:18:03 <carter> yeah
12:18:06 <carter> oh well,
12:18:10 <ski> carter : it's strict in `m'
12:18:15 <carter> well
12:18:16 <Nibble> Heffalump: hdbc-mysql vs hdbc-obdc?
12:18:20 <carter> ski: it is?
12:18:21 <carter> huzzah
12:18:25 <lispy> oh, because of runCont
12:18:28 <lispy> ski: thanks
12:18:32 <carter> ski: explain
12:18:35 <carter> please?
12:19:04 <ski> carter : i.e. .. if you plan to call the action somewhere
12:19:14 <carter> hem
12:19:15 <carter> ok
12:19:21 <carter> been on a long coding spree
12:19:38 <ski> (otherwise you could claim `(+)' applied to an integer is not strict, since you don't have to give a second argument)
12:19:39 <carter> but sounds sensible / will once i've rested
12:20:01 <ski> .. so it depends wrt which result you're talking about strictness
12:20:03 <carter> well, as long as i'm getting whnf back, its strict enough for me
12:20:28 <aristid> hmm i wonder.... http://mozakai.blogspot.com/2010/08/emscripten-llvm-to-javascript-compiler.html
12:20:36 <carter> i'm adding some traversal code to the scrap yer zipper lib
12:20:47 <carter> and the only sane way to get the sort of depth first left right traversal
12:21:02 <carter> needs foldlM  using M= continations
12:21:23 <carter> the reason being you want to thread around your accumulation paramter
12:22:55 <carter> though i'll admit i'm kinda embarassed at how long it took for me to work that out
12:23:30 <carter> thanks!
12:23:38 <ski> (zipper things sounds like it could in some cases possibly need continuations, yes)
12:23:45 <carter> yeah
12:23:47 <carter> basically
12:24:30 <carter> i'm doing a mod of the syz package so i can say "gimme the fold over this interval of the zipper" where you specify the end points of a dfs traversal via two zippers into the datastructure
12:25:11 <ski> .. and i presume you can then prune away whole subtrees ?
12:25:22 <carter> you mean pick em out?
12:25:31 <carter> well
12:25:33 <carter> you could do that too
12:25:34 <ski> i mean so you don't have to traverse into them ?
12:25:38 <carter> yeah
12:26:01 <carter> ie: you have a foldl like interface over intervals of a tree
12:26:13 <carter> via zipper pairs acting like the hi and lo in an array
12:26:17 <carter> but with some extra stuff 
12:26:40 <carter> so that you can eg: not duplicate stuff when you ahve a term and subterm both be "valid datums"
12:27:13 <carter> because recursively nested stuff tends to contain itself
12:27:23 <carter> and sometimes you only want nodes of a tree
12:27:29 <carter> i  mean leaves
12:27:47 <carter> and not to be folding over both the tree and itss leaves
12:28:06 <carter> and the basic syb combinators dont quite give you that 
12:28:15 <carter> or at least I don't think they do
12:28:24 <carter> at least not as a foldl
12:28:24 <ski> .. and sometimes you want top-down, and sometimes you want bottom-up
12:28:49 <carter> you mean picking out the value in a node before you pick out its leaf values
12:28:50 <carter> yeah
12:28:59 <ski> aye
12:29:07 <carter> i'm for now just working out the the implementation for the top down left right
12:29:09 <carter> "reading order"
12:29:12 <carter> traversal
12:29:21 <carter> but it should be easy to then get the others
12:29:54 <carter> its just a question of which way you choose to merge the parent  result with the children result
12:32:50 <megajosh2> @src (->)
12:32:50 <lambdabot> Source not found. You type like i drive.
12:33:02 <megajosh2> @src ((->) r)
12:33:02 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:33:05 <hpc> (->) has no native definition
12:33:15 <megajosh2> Lernyouahaskell fooled me :C
12:33:26 <Nibble> @type forM_
12:33:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
12:33:32 <Nibble> kduh
12:33:36 <c_wraith> @src ((->) a) (>>=)
12:33:37 <lambdabot> Source not found.
12:33:38 <Nibble> makes sence
12:33:43 <c_wraith> @src (>>=) ((->) a) 
12:33:44 <lambdabot> Source not found. Sorry.
12:33:47 <hpc> it has instances, but not a definition
12:35:19 <aristid> @src (->) (>>=)
12:35:19 <lambdabot> f >>= k = \ r -> k (f r) r
12:35:41 <aristid> c_wraith: :P
12:36:05 <c_wraith> Hmm.  That's not even right.  (->) doesn't have the right kind.  I protest!!!
12:36:16 <aristid> this is @src
12:36:19 <c_wraith> I know :)
12:36:23 <c_wraith> I still protest!
12:42:00 <yitz> @src insults us when we get it wrong. c_wraith has a right to insult @src when it is wrong.
12:42:00 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:44:29 <hpc> haha
12:45:29 <aristid> @src -> (>>=)
12:45:29 <lambdabot> Source not found. Just try something else.
12:57:34 <megajosh2> Are you able to use @src to see how an instance of a class is declared?
12:57:48 <Nibble> @src windows
12:57:48 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:57:50 <c_wraith> if it's in the database, yes
12:57:59 <c_wraith> @src Maybe (>>=)
12:57:59 <lambdabot> (Just x) >>= k      = k x
12:58:00 <lambdabot> Nothing  >>= _      = Nothing
12:58:21 <c_wraith> @src Maybe return
12:58:21 <lambdabot> return              = Just
12:58:31 <megajosh2> Ah, okay
12:58:32 <megajosh2> Thanks
12:58:38 <c_wraith> But @src just uses a fixed database.  It's very incomplete
13:01:32 <FSalad_III> why won't anyone fix it
13:01:40 <FSalad_III> somebody do something! :D
13:02:10 <FSalad_III> my ctags file of my cabal package cache is probably better
13:02:14 <FSalad_III> ;)
13:08:56 <chrisdone> feel free to patch lambdabot
13:18:08 <Saizan> it doesn't make much sense for @src to work for arbitrary code, it has to be a decently short and illustrative version
13:22:47 <int80_h> hpaste is up for now
13:26:37 <HskNoob> Q: Is it possible to define a function which has an optional argument (to initialize the list once and hopefully use a cached list when used without arguments) ?
13:27:36 <Zao> HskNoob: A "function" always has a particular number of arguments.
13:27:50 <HskNoob> (need to have a list with limited amount of fibonacci numbers - avoiding recalcuation is the goal)
13:28:01 <Zao> (unless you go into deep magic like Text.Printf that cheats)
13:28:16 <Zao> HskNoob: Maybe you want to pass in a context or use a Reader?
13:28:20 <chrisdone> is tehre a consequtive element remover defined in a standard/hackage lib anywhere?
13:28:23 <Zao> Err, State.
13:28:35 <chrisdone> replace :: Char -> (Char -> Bool) -> String -> String
13:28:35 <chrisdone> replace with p = map (\a -> if p a then with else a)
13:28:37 <chrisdone> and one of these?
13:28:49 <chrisdone> (replace Char with a where necessary)
13:29:02 <lispy> chrisdone: map head . group ?
13:29:16 <chrisdone> lol
13:29:22 <chrisdone> #haskell-syndrome never fails
13:29:24 <HskNoob> Zao: any pointers on a list with state ( i'am just learning .. noob here )
13:29:52 <chrisdone> 'is there *already* an implementation in a library somewhere'
13:30:01 <Zao> chrisdone: Probably.
13:30:01 <chrisdone> not 'how do I implement this simple function'
13:30:07 <chrisdone> lol
13:30:09 * chrisdone gives up
13:30:13 <Zao> Data.Text tends to have a reasonably rich set of functions.
13:30:18 <Gracenotes> functional programming is all about avoiding implementing functions
13:30:21 <Zao> But that's not String particularly.
13:30:30 <Gracenotes> and taking other peoples'
13:30:51 <HskNoob> Zao: thanks
13:31:02 <Zao> HskNoob: That was aimed at chrisdone 
13:31:07 <HskNoob> woops :)
13:31:11 <Zao> chrisdone: What would an "consecutive element remover" do?
13:31:20 <lispy> ?let removeAdjacent = map head . group -- there now it's defined in lambdabot
13:31:21 <lambdabot>  Defined.
13:31:32 <Gracenotes> @undefine  -- :(
13:36:03 <Twey> What's with the ?let syntax?  Why doesn't it just have @let like everything else?  (okay, :t and > are exceptions, but easily explicable ones)
13:36:36 <nlogax> doesn't it recognize both ! and @ ?
13:36:45 <nlogax> er, ?, i mean
13:37:22 <Twey> Not in general, I thinkâ¦
13:37:28 <Twey> ?pl \x -> x + 1
13:37:29 <lambdabot> (1 +)
13:37:30 <Twey> Oh
13:37:33 <Twey> Maybe she does
13:38:41 <nlogax> i was poking around the source before, there's a list of command prefixes iirc
13:39:14 <nlogax> trying to write my own bot now. got mueval working within it, and was pwned by lazy evaluation
13:39:16 <lispy> Twey: for me it's easier to hit ? than @ so I tend to use ? for commands.  most people use @
13:39:29 <Nibble> If I recall, there are mutable data types in haskell
13:39:32 <Twey> They're both about the same for me
13:39:40 <lispy> Nibble: yes
13:39:46 <Nibble> states? What are the full names
13:39:46 <Twey> Nibble: No
13:39:52 <Twey> Nibble: Yes and no.  âº
13:39:53 <lispy> Nibble: STRef being a good example
13:40:29 <Nibble> @type StRef
13:40:30 <Twey> Oh, I forgot about ST.  Hm, does that count?
13:40:31 <lambdabot> Not in scope: data constructor `StRef'
13:40:37 <Nibble> @type STRef
13:40:39 <lambdabot> Not in scope: data constructor `STRef'
13:40:48 <Twey> Nibble: It's a type constructor
13:40:49 <lispy> IOUArrays are mutable
13:40:53 <Twey> STRef s a
13:41:12 <Twey> lispy: But mutable *in Haskell*?  The mutation occurs when doing the execution, surely.
13:41:29 <lispy> Twey: I don't understand the distinction
13:41:56 <Twey> lispy: Well, Haskell is a âpure languageâ because mutation and suchlike doesn't occur during execution, right?
13:42:26 <Nibble> @info STRef
13:42:26 <mauke> *evaluation
13:42:27 <lambdabot> STRef
13:43:36 <lispy> Twey: How would you talk about putStrLn ?
13:43:51 <lispy> Twey: when does it display its parameter?
13:45:01 <mauke> putStrLn doesn't display its parameter :-)
13:45:39 <Twey> Indeed
13:45:48 <Twey> It constructs an IO action that represents displaying its parameter
13:46:07 <Twey> Er, s/during execution/during evaluation/
13:51:17 <int80_h> say I had a set called "students", and another set called "activities". If these two sets were part of another set, what would the name of that set be?
13:51:42 <lispy> int80_h: a superset :)
13:51:56 <int80_h> yeah but I'm trying to name that set
13:52:10 <c_wraith> plans?
13:52:14 <int80_h> this is for the tutorial, the name should be descriptive.
13:52:34 <int80_h> student isn't a plan
13:52:34 <Twey> students_âª_activities
13:52:51 <int80_h> I'm going with what Twey said. 
13:53:55 <int80_h> if it turns out to be clunky I can always change it
13:54:39 <jmcarthur> Twey: well, *visible* mutation doesn't occur during *evaluation*
13:54:39 <Tomsik> http://blog.plover.com/prog/haskell/monad-terminology.html
13:55:08 <Twey> jmcarthur: Right
13:55:11 <jmcarthur> s/visible/observable/
13:55:31 <Tomsik> Probably everyone's seen it, what do you guys think?
13:57:46 <Twey> Motes, heh.  Cute.
13:57:49 <Twey> I like it.
13:58:34 <Tomsik> I never really thought of it as a problem, but now... ignorance is a bliss I guess.
14:05:09 <kevinburke> I had this idea I wanted to try - to delay all my RSS feeds until 5 pm every day
14:05:36 <kevinburke> but I wasn't sure how to implement it. how would you 'store' the rss feeds until the correct time?
14:06:45 <Jafet> Uh, cron?
14:07:33 <vanadium> The rss feed already stores the rss feed, surely
14:08:44 <kevinburke> im new to cron, servers etc
14:08:59 <kevinburke> so you'd run a cron every minute or 10 minutes and just query the feed each time
14:09:46 <vanadium> The feed is not going anywhere, just wait until 5
14:11:34 <ben_m> I bet everytime I use the term "mote" I'd get yelled at for using new terminology.
14:15:39 <Philonous> Why do we need a word for monadic values but not for functors, arrows, <type class X>? Isn't the real problem the undue attention to monads?
14:16:18 <Jafet> Say the word / You're thinking of
14:19:46 <megajosh2> Mote... hmmm
14:20:10 <megajosh2> I need to frobnicate the mote so it can doodad my kitchen appliance
14:21:06 <lispy> megajosh2: I recommend using the Strategy pattern where you get the strategy from a Factory (which you register to your singleton factory registry)
14:21:57 <mauke> preflex: be PoppaVic
14:22:18 <preflex>  I hear you can BUY a doc that makes you a "minister" and perform weddings.. Is that the same as programming?
14:24:59 * lispy thought preflex was a troll for a second :)
14:25:16 <Veinor> Is that a quote, or an amalgamation of two?
14:25:20 <Twey> Success
14:25:28 <mauke> straight quote
14:25:31 <Twey> preflex has passed the Turing test
14:25:35 <mauke> and PoppaVic is not a markov bot
14:25:39 <Twey> We have AI
14:25:40 <lispy> Veinor: I think PoppaVic was a troll who got banned at some point
14:25:46 <Veinor> ah
14:25:50 <mauke> no, he's a regular in ##C
14:26:04 <lispy> ah
14:27:01 <mauke> preflex: be PoppaVic
14:27:02 <preflex>  C is one of those things that expects "miles", rather than "hours".
14:28:37 <Veinor> ... what?
14:28:43 <Veinor> preflex: be PoppaVic
14:28:43 <preflex>  You cannot walk into ##C and speak "C" as a moron. Really-really. This shit is the underlayer to scripting and an uber-layer to the machine.
14:28:59 <Veinor> C: an uber-layer to the machine
14:30:53 <Jafet> preflex: be mauke
14:30:54 <preflex>  I've solved the halting problem WITH A SHOTGUN
14:31:46 <Martty> preflex: be tomalak
14:31:46 <preflex>  no quotes found for tomalak
14:33:29 <Tomsik> HALT! Ein Problem! 
14:33:52 <Tomsik> That's what Germans said to Turing a day before.
14:39:49 <Adamant> preflex: be Adamant
14:39:49 <preflex>  no quotes found for Adamant
14:39:52 <Adamant> :(
14:42:46 <BONUS> im setting up a blog! how do y'all like the design: http://learnyouahaskell.com/blog/this-is-an-example-post
14:43:18 <megajosh2> Oh, I was reading over your site just now!
14:43:29 <BONUS> haha
14:43:35 <megajosh2> That logo is kind of scary
14:43:47 <BONUS> i hope so!
14:43:59 <mauke> logo gets cut off if window is too narrow
14:44:04 <mauke> and no scroll bars
14:44:33 <BONUS> yeah im aware of that, i was like ok i want a big logo but i dont want scrollbars
14:46:42 <Veinor> BONUS I like the pig in the monad tutorial
14:46:55 <BONUS> haha thanks! its blocky
14:47:08 <Veinor> I am unable to deal with it
14:47:16 <Veinor> also I like the logo not forcing scroll bars on narrow windows
14:47:23 <BONUS> haha
14:47:43 <Veinor> it annoys me when I visit a site that has decoration that forces me to scroll
14:48:00 <BONUS> yeah, i figured why should i force scrollbars just so people can see a stupid logo
14:48:54 * BMeph always thinks of Rage Against the Machine when he sees that mauke quote about problem-solving...
14:49:07 <Twey> It's veryâ¦ loud
14:49:17 <Twey> Hold on a minute, my eyes need to adjust before I can read my terminal again
14:49:34 <Jafet> Rise against the imperative pigs! Burn the boolean flags
14:49:39 <BONUS> bam! eyefull of space ape
14:50:07 <Jafet> BONUS: I assume the banner (which you call logo) has some sort of strange meaning that I'm not aware of
14:50:07 <Veinor> I also really like the logo design
14:50:40 <BONUS> Jafet: it probably has a meaning if you're crazy. actually i just put together a collage from various images i had lying around
14:57:27 <illissius`> hmm
14:57:37 <illissius`>     Cycle in class declarations (via superclasses):
14:57:38 <illissius`>       TypedList.hs:(7,1)-(11,25): class TypedList (TailOf l) => TypedList l where {
14:57:39 <illissius`>                                       type family HeadOf l :: *; type family TailOf l :: *; }
14:57:51 <illissius`> am i trying to do something silly, or is ghc being overly restrictive?
14:58:02 <lowasser1> you are definitely trying to do something silly
14:58:55 <lowasser1> and, more to the point, I'm just about positive that sort of scheme isn't possible
14:59:21 <lowasser1> first, you're saying that every TypedList has a tail, it is definitely an "infinite list"
14:59:27 <Cale> illissius`, What are you trying to do?
14:59:27 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:59:38 <illissius`> lowasser1: tail [] = []
14:59:50 <illissius`> saying every list has a head is more problematic in that sense
14:59:58 <lowasser1> mmmm
15:00:00 <jre2> I haven't tried any of the database packages on hackage yet- any recommendation for which sqlite lib to use (or tips on when one is more suitable than another)?
15:00:22 <illissius`> but i can't very well say "maybe it has an associated type"
15:00:25 <lowasser1> well, you're constraining TailOf^n l for *all* n
15:00:42 <lowasser1> >= 0
15:00:50 <alise_> how do you convert an integer to a String in a certain base?
15:00:51 <alise_> or an Int
15:01:00 <lowasser1> and infinite dependencies aren't something the type system can deal with ;)
15:01:28 <illissius`> hmm
15:01:33 * illissius` ponders
15:01:56 <lowasser1> I'm trying to figure out how to explain how you can finitely bootstrap to get arbitrarily long, albeit always finite, inference change
15:02:23 <notabel> alise_: showIntAtBase
15:02:27 <alise_> notabel: thanks
15:02:36 <alise_> notabel: what module?
15:03:49 <notabel> Numeric
15:03:54 <lowasser1> okay, so here is a sense in which infinite types are fine:
15:03:57 <notabel> it's part of the H98 report library
15:04:13 <lowasser1> you have data Foo a = ..., and a typeclass Bar
15:04:17 <alise_> notabel: what about modern haskell?
15:04:32 <lowasser1> you show that Bar a => Bar (Foo a)
15:04:37 <lowasser1> and induct, essentially
15:04:40 <notabel> modern haskell is a superset of H98 :-0
15:04:42 <notabel> :-)
15:04:44 <alise_> notabel: yes, but...
15:04:46 <alise_> :)
15:04:57 <notabel> just `import Numeric`
15:05:02 <alise_> yes, but still
15:05:08 <alise_> hierarchical modules are nicer.
15:05:15 <illissius`> lowasser1: yeah, that's basically what I do -- I'm not sure if that constraint is even necessary
15:05:39 <illissius`> I just added it on a "can't hurt" basis and then I was curious whether GHC was right to complain about it
15:05:52 <notabel> anyway, the odd thing about showIntAtBase is that it takes a function to map integer digits to chars
15:06:05 <notabel> it makes sense (because it generalizes to arbitrary bases) but may be unexpected
15:06:52 <lowasser1> it may be more effective
15:06:59 <lowasser1> to add it as a type constraint on the *methods*
15:07:04 <lowasser1> rather than a superclass constraint
15:07:14 <Cale> alise_, Numeric strangely is the only module, apart from the Prelude, which hasn't moved.
15:10:49 <alise_> Cale: Huh, it's still Numeric?
15:11:03 <Cale> yes
15:11:04 <alise_> notabel: easy enough -- ("0123456789abcdef"!!)
15:11:10 <alise_> it should be generalised to non-Chars though
15:15:22 <EvanR> interesting, i got my object to bounce off slopes and things. i applied gravity and didnt attempt any friction. its path is crazy. but its interesting that at some point it will enter a repeating sequence ;)
15:15:52 <EvanR> its all integer math
15:16:04 <EvanR> int
15:18:47 <Tomsik> if it's bounded then it should enter a repeating sequence :p
15:19:33 <Jafet> When you implement friction, you will curse the gods for making double only 64 bits
15:19:40 <EvanR> its bouncing around a bounded room using bounded precision position, velocity, and trigonometry
15:20:12 <lispy> Jafet: why is that?
15:20:28 <Jafet> Touching surfaces.
15:20:50 <Jafet> If havok cannot get that kind of thing right, you know it's hard.
15:21:06 <EvanR> lol it entered a short loop
15:21:13 <EvanR> bouncing off two things
15:21:45 <lispy> Cale: what's in Numeric, I don't think I've ever looked at it
15:21:47 <EvanR> i didnt even have to wait combinatorial explosion number of years
15:22:36 <lispy> Cale: oh, I just looked.  It doesn't have anything I ever care about :)
15:23:30 <Cale> brb
15:23:30 <megajosh2> @src Rational
15:23:31 <lambdabot> type Rational = Ratio Integer
15:26:47 <shapr> It's way cool that Haskell is a commonly reference language now.
15:27:08 <Mitar> where?
15:27:08 <shapr> Maybe there aren't lots of folk that use it regularly, but everybody knows something basic about Haskell.
15:27:19 <shapr> I was looking at the comments for http://lwn.net/Articles/402540/
15:27:42 <Jafet> Success at last
15:27:48 <shapr> Someone asked for a better statically typed language than Java, and Haskell gets mentioned twice so far.
15:27:51 <Mitar> everybody knows something? (me tourns around) ... nah, no
15:28:05 <shapr> Mitar: I mean that everyone has heard of Haskell, they know it exists.
15:28:11 <shapr> They may not have used it ...
15:28:14 <Mitar> ok, that's true
15:28:30 <Mitar> but this is not the same as reference language?
15:28:38 <Mitar> or you meant referenced language?
15:28:44 <shapr> When I started advocating Haskell just over nine years ago, most people thought I was saying Pascal.
15:28:53 <Mitar> lol
15:29:02 <EvanR> haskalle
15:29:08 <Mitar> it has the same ring to the ear ;-)
15:29:25 <shapr> Nowadays they say, "Oh yeah, Haskell shows up lots on reddit, etc"
15:29:36 <Jafet> Nine years later, Pascal is still a better statically typed language than Java...
15:30:38 <shapr> In any case, it means I can likely get a Haskell job when I finish my degree two years from now.
15:30:48 <EvanR> yeah righ
15:30:57 <shapr> Not that I'm planning to stop advocating Haskell or anything.
15:31:12 <dons> i sat next to a comp sci major from CMU and one from UPenn who thought I said "Pascal" this week.
15:31:12 <shapr> EvanR: I've had a Haskell job before, I should be able to get another.
15:31:20 <Veinor> shapr: some people that I know think I said 'pascal', but they're people that are like 40 and non-programmers
15:31:40 <shapr> dons: Maybe not total market penetration then...
15:31:46 <EvanR> is that the actual pronunciation of pascal, ryhmes with haskell?
15:31:55 <dons> not really
15:32:21 <shapr> EvanR: Nah, I've got a sound file on scannedinavian where SPJ says "Haskell"
15:32:24 * shapr looks...
15:32:50 <shapr> Or, I had it...
15:32:53 <Mitar> it is interesting
15:32:57 <Igloo> Many people, myself included, would naturally pronounce Pascal incorrrectly, to rhymewith Haskell
15:33:01 <Mitar> when you search anything in haskell
15:33:06 <Mitar> on google
15:33:11 <EvanR> for that matter, whats the right way to haskell?
15:33:21 <shapr> EvanR: The way Simon Peyton-Jones says it :-)
15:33:21 <Mitar> the only google add you get on the right is "we are hiring" - from google
15:33:41 <tehgeekmeister> applicative instance for list is concatmap, no?
15:33:52 <tehgeekmeister> well, for <*>
15:33:54 <shapr> Maybe Haskell will be the next COBOL a decade from now, but golly, I sure won't mind.
15:34:18 <Jafet> Mitar: it's a trap, they will suck you into python
15:34:30 <Jafet> shapr: that would guarantee you a job.
15:34:56 <EvanR> COBOL must be an interesting language for so many other totally different languages to be 'the next cobol' 'cobol of the 90s' and 'finally replacing cobol'
15:34:59 <luite> hmm, when I search for haskell, there's only a "haskell programmers welcome" ad, but it's for an ocaml job
15:35:01 <shapr> Java did great things for programming solely by removing malloc and pointers from the use of the average programmer.
15:35:06 <Saizan> tehgeekmeister: (<*>) /= concatMap, but it's implemented with it, or more directly by taking the cartesian product of the lists and mapping uncurry ($) over it
15:35:30 <Saizan> tehgeekmeister: the cartesian product is easy to implement with two nested concatMap's
15:35:44 <Jafet> EvanR: it can be PICTUREsque
15:35:47 <shapr> I'd be happy if Haskell removed the use of mutable variables from use by the average programmer.
15:36:02 <EvanR> lol
15:36:07 <illissius-> I'm scared to death of pronouncing some really obvious word in public the way I've always been pronouncing it my head, and discovering that I've always been pronouncing it wrong
15:36:23 <shapr> illissius-: I do it all the time, get corrected, and say 'thanks!'.
15:36:24 <illissius-> for example, does algorithm rhyme with rhythm or rhyme?
15:36:38 <shapr> rhythm
15:36:45 <sepp2k> shapr: Though to be fair that wouldn't have been necessary if the average programmers had been using decent languages to begin with.
15:36:48 <illissius-> yay!
15:36:48 <EvanR> its not algorithime?
15:36:53 <EvanR> shucks
15:37:06 <illissius-> EvanR: i was afraid the th might be silent
15:37:15 <EvanR> hahahaha
15:37:18 <shapr> Now that I'm approach asterisk guru-ness, we gotta have #haskell group voice chats ;-)
15:37:22 <mauke> are there silent ths?
15:37:39 <mauke> I know "psych" is pronounced "sike" for some reason
15:37:40 <EvanR> shapr: ah asterisk
15:37:41 <illissius-> I'm sure there's some good reason for me suspecting that, but I can't dig it out of my subconcious
15:37:54 <shapr> mauke: Thibodeaux? lathe?
15:38:23 <mauke> how is that silent?
15:38:35 <shapr> It's a different th sound than bath, imo
15:49:48 <tehgeekmeister> Saizan: thanks!
16:00:27 <dancor> it seems like cabal-install should: error on unrecognized command-line options (like --flag instead of --flags), and error on unrecognized flags themselves.  should i file a bug report?
16:00:52 <dancor> forget the first one
16:00:52 <monochrom> what does it do now?
16:01:16 <dancor> monochrom: for unrecognized flags, it just installs with no flags
16:07:41 <benmachine> I thought the whole point of having an executable depend on a library in the same cabal file was to avoid recompiling everything
16:08:05 <benmachine> it seems not only do I have to do that but also I have to list the build-depends of the entire library in the executable section as well
16:08:11 <benmachine> what's up with that :(
16:09:08 <monochrom> a new enough cabal-install does what you want.
16:09:35 <ivanm> not quite
16:09:39 <benmachine> I'm on 0.8.2
16:09:42 <ivanm> you can't build haddock docs if you use that feature
16:09:52 <monochrom> oh, right.
16:09:53 <benmachine> oh well I don't have any
16:10:08 <ivanm> benmachine: the reason being you have to copy all the build-depends is that in essence the executable section is completely separate from the library section
16:10:37 <benmachine> ivanm: so what's the point of the executable depending on the library at all?
16:10:39 <ivanm> so you have to mention the libraries that the executable depends upon; this might only be base and the library in the package
16:10:49 <ivanm> benmachine: to avoid recompilation
16:10:56 <benmachine> but it's not avoiding recompilation
16:10:57 <Colours> hi! can someone help me with this bit of code: (I am using Text.ParserCombinators.Parsec)
16:10:59 <benmachine> hmm
16:11:00 <Colours> http://pastebin.com/yhdpzReG
16:11:10 <benmachine> do I need separate hs-source-dirs I wonder
16:11:18 <ivanm> benmachine: if you did it right and said that it needs cabal >= 1.8 then it will ;-)
16:11:23 <ivanm> benmachine: oh, right, yes, you do
16:11:26 <ivanm> I forgot about that
16:11:36 <ivanm> otherwise ghc --make is stupid and picks up all the library files
16:11:53 <ivanm> Colours: what's your problem?
16:12:09 <ivanm> @hoogle count
16:12:09 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
16:12:09 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
16:12:09 <lambdabot> Data.ByteString.Lazy count :: Word8 -> ByteString -> Int64
16:12:28 <ivanm> is count actually a parsec combinator?
16:12:58 <Veinor> hayoo says it is
16:13:01 <ivanm> ahhh, yes it is
16:13:13 <ivanm> count :: Stream s m t => Int -> ParsecT s u m a -> ParsecT s u m [a]
16:13:25 <monochrom> count :: Int -> GenParser tok st a -> GenParser tok st [a]
16:13:38 <Colours> yeah I get a type
16:13:44 <Colours> error
16:13:45 <ivanm> so what's your problem?
16:14:03 <ivanm> assuming letter is indeed a combinator, that appears to be valid?
16:14:06 <monochrom> oh I see, len is not a number.
16:14:07 <ivanm> Colours: _what_ error?
16:14:13 <ivanm> oh...
16:14:18 <Colours>     Couldn't match expected type `Int' against inferred type `[Char]'
16:14:18 <Colours>     In the first argument of `count', namely `len'
16:14:19 <ivanm> count (read len) letter
16:14:22 <monochrom> count (read len) letter
16:14:29 <Colours> oh lovely~
16:14:53 <Colours> woo thanks a bunch :3
16:14:55 <monochrom> And screw those who advocate "safeRead :: (Read a) => String -> Maybe a"
16:15:01 <ivanm> but if you want to be thorough there's probably a better way of doing that; convert each digit to a number and then use the digits library to join them all together
16:15:13 <ivanm> monochrom: well, in this case you shouldn't need it, unless there's overflow
16:15:26 <Veinor> ivanm: or a parse failure?
16:15:38 <ivanm> Veinor: well, it'll be a string of digits
16:15:45 <Veinor> oh, true
16:15:46 <ivanm> readDec might be worth considering
16:15:46 <Veinor> derp
16:15:49 <ivanm> @hoogle readDec
16:15:49 <lambdabot> Numeric readDec :: Num a => ReadS a
16:15:49 <lambdabot> Text.Read.Lex readDecP :: Num a => ReadP a
16:16:38 <ivanm> but that gets you the [(Int, String)] situation
16:17:02 <ivanm> Colours: but next time, include the error with the code to make it easier on us ;-)
16:17:24 <monochrom> let [(answer,"")] = readDec len ""
16:17:46 <monochrom> this is not an example of inexhaustive pattern
16:18:22 <monochrom> The above is my sentiment about safeHead, safeTail, safeThis, safeThat.
16:18:39 <Jafet> @hoogle safeHead
16:18:39 <lambdabot> Data.ByteString.Unsafe unsafeHead :: ByteString -> Word8
16:18:47 <Twey> Jafet: âsafeâ package
16:18:57 <Jafet> safeHead = spoon . head?
16:19:01 <ivanm> safeHead = listToMaybe
16:19:10 <dibblego> safeHead = copoint
16:19:38 <Jafet> All this abstraction
16:20:36 <hpc> :t spoon
16:20:37 <lambdabot> Not in scope: `spoon'
16:21:08 <Veinor> it calls it headSafe, apparently
16:21:09 <ivanm> spoon was by copumpkin, wans't it?
16:21:31 <Veinor> er, headMay
16:21:51 <BMeph> hpc: Five drops from an eyedropper.... ;)
16:21:58 <aristid> dibblego: copoint? as in, extract?
16:22:03 <dibblego> yeah that
16:22:12 <dibblego> it was renamed somewhere along the way
16:22:32 <aristid> i thought lists are not copointed because f a -> a is not safe
16:22:40 <dibblego> prexactly my copoint!
16:23:07 <aristid> *scratch head*
16:23:09 <dibblego> data NotEmpty a = N a [a] -- this is though
16:23:16 <Anarch> I want to display Complex(Double)s whose imaginary parts are 0 as if they were reals.  Is there a datatype or show function already supplied for that?
16:24:06 <aristid> dibblego: is it also a comonad?
16:24:47 <dibblego> aristid, indeed it is http://hackage.haskell.org/packages/archive/NonEmptyList/0.0.9/doc/html/src/Data-List-NonEmpty.html
16:26:04 <hpc> does a copointed instance exclude a monoid instance?
16:26:15 <hpc> because f a -> a would break for mzero
16:26:28 <dibblego> Copointed requires fmap and copoint
16:28:09 <lispy> I don't get your copoint.
16:32:52 <Veinor> Anarch: no, I think you have to post-process the output of show
16:33:13 <Anarch> Veinor: k thanks
16:36:38 <tehgeekmeister> how can i find out type signatures for functions I don't have them for (yes i was lazy, no I'm not sure what they are off the top of my head.)
16:36:54 <hpc> tehgeekmeister: open in ghci and :t functionName
16:37:02 <tehgeekmeister> hpc: thanks
16:38:29 <aristid> dibblego: duplicate = tails?
16:44:21 <benmachine> Anarch: you could newtype the Complex and then make a Show instance for the newtype
16:44:29 <benmachine> or a showComplex function
16:45:03 <dibblego> aristid, yes
16:45:23 <Anarch> benmachine: That's what I'll probably end up doing, a MaybeComplex type
16:47:51 <lispy> tehgeekmeister: compile with -Wall and watch the output, Ghc will print the full sigs
16:48:03 <tehgeekmeister> lispy: thank youuuu
16:48:12 <lispy> tehgeekmeister: nppppp
16:48:53 <lispy> I tend to write my type sigs first, but in general it would still be nice to have editor support for this
16:49:00 <lispy> Same with managing import lists
16:49:30 <monochrom> haskell-mode for emacs asks ghci for type for toplevel things
16:49:35 <lispy> If you start using a type that is in a library already on your machine, it would be nice if your editor could add the import to your module and update your cabal file (both with permission of course)
16:50:02 <lispy> oh, and write my QC properties for me
16:50:08 <lispy> and maybe take out the trash too, it's kind of full
16:50:28 <monochrom> I need my laptop wiped clean every two weeks.
16:50:56 <tehgeekmeister> lispy: i would like to write my top level sigs first, but i often don't know what they'll end up being.  still not entirely comfortable with monads.
16:51:05 <tehgeekmeister> well, transformers.  monads themselves are simple.
16:51:09 <tehgeekmeister> mixing them is crazy.
16:52:48 <kevinburke> what's the best code editor for mac? 
16:53:09 <kevinburke> i'm using komodo edit, but it doesn't auto-indent new lines
16:53:25 <tehgeekmeister> lispy: how do i get cabal to pass that to ghc?
16:54:37 <monochrom> of course, what I said about haskell-mode for emacs needs your file to be correct enough first (ghci loads it without complaint). so for example doesn't work for "still under construction"
16:54:42 <tehgeekmeister> kevinburke: textmate is pretty nice, don't know how it handles haskell.  i use vim for haskell automatically, for some reason.
16:54:53 <kevinburke> okay
16:54:58 <kevinburke> i need to learn im
16:54:59 <kevinburke> vim
16:55:49 <monochrom> supposedly the eclipse plugin for haskell will eventually do everything, write code for you, and upgrade your linux automatically
16:56:05 <lispy> tehgeekmeister: um. I always have to look at an exampel
16:56:21 <tehgeekmeister> lispy: i'm looking it up anyway, just wondered if you knew
16:56:55 <lispy> GHC-Options: -Wall
16:57:08 <lispy> http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html Example 4
16:57:13 <tehgeekmeister> kevinburke: beware, though: http://www.terminally-incoherent.com/blog/wp-content/uploads/2006/08/curves.jpg
16:57:39 <lispy> tehgeekmeister: Nice
16:57:47 <monochrom> everyone should bookmark http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html
16:58:29 <lispy> The only time I bookmark something is if I can't google for it
16:58:33 <tehgeekmeister> oh, i have to edit the cabal file?  okay, that works, i guess.  wish i could set that as a config options for cabal itself.
16:59:39 <monochrom> cabal configure --ghc-option=-Wall
16:59:44 <kevinburke> tehgeekmeister: yeah, that happened with emacs. the preference file is nuts
16:59:56 <tehgeekmeister> ohohoh
17:00:09 <tehgeekmeister> monochrom: okay, i thought that had to be in the cabal file
17:00:37 <monochrom> I would give preference to the *.cabal file
17:00:42 <lispy> tehgeekmeister: with out often cabal forces me to clean/configure I put everything in the .cabal file
17:02:49 <monochrom> actually almost everyone with ghc installed has the cabal manual installed too
17:03:12 <monochrom> that pretty much covers 99% of this channel
17:03:35 <lispy> monochrom: where you going with that?  /me is lost
17:04:37 <monochrom> everyone should rtfm
17:07:01 <masak> trying to compile Example 1 from http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Reader.html -- almost succeeding, but not quite: http://gist.github.com/556837
17:07:11 <masak> I'm guessing I need to write my imports differently. but how?
17:07:51 <notabel> masak: `import qualified Data.Map as Map`
17:07:59 <masak> tried that.
17:08:11 <masak> it helps a bit, but still gives errors about missing things.
17:08:41 <masak> one thing, to be exact:
17:08:42 <masak> sample.hs:5:16: Not in scope: type constructor or class `Map'
17:08:53 <notabel> the problem is that most of the code uses qualified names, and that one line doesn't
17:09:02 <notabel> if you import qualified, change that line to say Map.Map
17:09:09 <masak> ah. ok.
17:09:19 <masak> could it be argued that Example 1 is wrong as it stands?
17:09:52 <notabel> probably, i didn't look at anything but your gist
17:10:38 <masak> hm, now I got a linker error: http://gist.github.com/556839
17:10:44 <masak> is that something to worry about?
17:15:02 <masak> because I see nothing wrong with the program itself now. a bit surprised about the undefined symbols.
17:18:55 <JoeyA> Is it "considered harmful" to make <*> have different strictness characteristics than its monadic equivalent? (namely, f <*> a = do {f' <- f; a' <- a; return (f' a')} )
17:21:00 <jmcarthur> i would say so
17:21:19 <ezyang> In the quickspec paper, the authors say "these laws completely characterize the reverse operator". What do they mean by "complete"? 
17:22:40 <Twey> That it has no behaviour not described by the laws?
17:22:48 <jmcarthur> i don't have the paper in front of me, but maybe they mean that all implementations obeying those laws are observationally equivalent?
17:23:55 <jmcarthur> i actually doubt that what i suggested is true though, if i'm remembering the laws in the paper
17:24:04 <ezyang> jmcarthur: Hmm. I'm not convinced, but let's see... 
17:26:15 <jmcarthur> i see it for the (++) operation, but i'm also unconvinced about reverse
17:26:39 <jmcarthur> reverse = id would also satisfy that spec, i think
17:26:48 <jmcarthur> oh wait
17:26:53 <jmcarthur> no, not that one
17:27:10 <jmcarthur> the third one i think might actually do it
17:27:13 <JoeyA> In particular, I'm writing a lazy IO monad that ensures a given set of (wrapped) IO operations is performed in sequence, but values output by the monad can be retrieved lazily.
17:27:19 <JoeyA> let readLines = (\a b c -> [a,b,c]) <$> defer getLine <*> defer getLine <*> defer getLine
17:27:24 <jmcarthur> make it such that reverse is fully characterized, i mean
17:27:44 <ezyang> oh, true 
17:27:48 <JoeyA> Note that the above example doesn't actually use my monad's main feature.
17:28:00 <ezyang> I guess I'm really used to operational semantics as characterizing functions 
17:28:33 <JoeyA> In monad-land, runLazy readLines >>= mapM_ putStrLn . snd would have to be evaluated strictly because of the promiscuous nature of monads.
17:28:57 <JoeyA> (namely, we have no way of knowing what the outer function is without performing all the actions)
17:29:31 <JoeyA> With Applicative, the top-level function (namely (:)) is directly available.
17:29:41 <JoeyA> It should be lazyable if I can just get it to work.
17:30:09 <jmcarthur> i'm not sure i understand
17:30:40 <jmcarthur> can you describe your functor's semantics in terms of _|_?
17:30:47 <JoeyA> What's that?
17:31:00 <jmcarthur> bottom, as in undefined
17:31:31 <jmcarthur> if a function f is strict in its argument then it has the property f _|_ = _|_
17:31:38 <jmcarthur> or, f undefined = undefined
17:32:09 <jmcarthur> if it doesn't have that property, it's non-strict
17:35:23 <jmcarthur> JoeyA: does your defer function behave any differently from unsafeInterleaveIO?
17:36:24 <jmcarthur> oh, is the difference that if you evaluate the second element of the list that it first forces the first element?
17:37:46 <JoeyA> It uses unsafeInterleaveIO
17:38:19 <JoeyA> But it takes care of chaining actions such that a tower of unsafeInterleaveIOs is constructed, ensuring the stream of actions is done sequentially.
17:38:26 <jmcarthur> i see
17:38:29 <JoeyA> (with a put method for yielding output)
17:39:31 <jmcarthur> JoeyA: what did you mean by "would have to be evaluated strictly because of the promiscuous nature of monads"?
17:39:42 <JoeyA> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29576#a29576
17:41:06 <jmcarthur> JoeyA: "Can't do tuple matching here because it causes immediate evaluation"  <-- you could use a lazy pattern
17:41:06 <JoeyA> jmcarthur: when you say f <*> a, the f is the top-level function.  If it has something to output right away (as in the case of ("string or list" ++) ), it can.
17:41:44 <JoeyA> Whereas with a Monad, the toplevel that ends up being used depends on what actions were thrown at it.
17:41:51 <megajosh2> :t ([]) (>>=)
17:41:52 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `[a]'
17:41:52 <lambdabot>     In the expression: ([]) (>>=)
17:41:53 <JoeyA> Honestly, I'm not sure I know what I'm talking about that well.
17:42:01 <megajosh2> :t (>>=) :: []
17:42:02 <lambdabot>     `[]' is not applied to enough type arguments
17:42:03 <lambdabot>     Expected kind `?', but `[]' has kind `* -> *'
17:42:03 <lambdabot>     In an expression type signature:
17:42:04 <megajosh2> :t (>>=) :: [a]
17:42:05 <lambdabot>     Couldn't match expected type `[a]'
17:42:05 <lambdabot>            against inferred type `m a1 -> (a1 -> m b) -> m b'
17:42:05 <lambdabot>     In the expression: (>>=) :: [a]
17:42:11 <jmcarthur> JoeyA: what is "the toplevel" in a monad?
17:42:24 <JoeyA> I'm just referring to the toplevel function that is evaluated.
17:42:51 <jmcarthur> i don't understand your terminology though
17:42:51 <megajosh2> :t (>>=) []
17:42:52 <lambdabot> forall a b. (a -> [b]) -> [b]
17:42:55 <sshc> "GHC since version 6.12 emits a warning when you silently ignore a return value"
17:43:05 <sshc> How do I enable that warning?
17:43:08 <jmcarthur> the first function that's evaluated in that expression is (<*>)
17:43:20 <jmcarthur> sshc: i just use -Wall
17:43:23 <JoeyA> If you can get inside of the applicative composed with f <*> a , the toplevel function is f, right?
17:43:40 <JoeyA> Because the expression within is really f, with heaven knows what arguments.
17:43:41 <jmcarthur> JoeyA: i still don't understand your use of "toplevel"
17:43:56 <jmcarthur> JoeyA: also, you can't simply "get inside" some applicatives
17:44:35 <jmcarthur> i understand that you are using handwavy terms here, but i honestly just am not following
17:46:06 <megajosh2> :t concatMap
17:46:07 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
17:47:57 <aristid> :t (=<<)
17:47:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
17:49:07 <JoeyA> In some cases, applicative methods can have more favorable strictness semantics than their monad equivalents.  For instance, a lazy IO technique may not be possible in Monad but possible in Applicative.
17:49:36 <JoeyA> I guess making Applicative and Monad have different I/O semantics would be weird.
17:49:44 <co_dh> is it possible to give a Show instance for function  ? (->) 
17:49:45 <JoeyA> But lazy IO is weird anyway.
17:50:03 <ezyang> Lazy ST is really cute though. 
17:50:27 <JoeyA> By the way, in the code I posted:  http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29576#a29576
17:50:43 <JoeyA> Is that honest-to-goodness rank 2 polymorphism I just used?
17:50:49 <JoeyA> And is it needed?
17:52:14 <JoeyA> (I'm chaining IO actions in continuation-passing style so that the unsafeInterleaveIOs are stacked)
17:52:38 <JoeyA> Also, what wheel am I reinventing?
17:52:43 <jmcarthur> JoeyA: why (\p -> return (fst p, snd p))?
17:52:58 <jmcarthur> oh, you're probably reinventing all possible wheels ;)
17:53:02 <awarring> I'm looking at some of the Snap code to expand my haskell knowledge...this piece of code doesn't quite make sense to me: liftIO m = Snap $ liftM (Just . Right) $ liftIO m
17:53:10 <JoeyA> jmcarthur: see the comment
17:53:14 <awarring> i don't understand the liftIO m at the end...
17:53:37 <awarring> m is some IO action as far as I understand it
17:53:46 <JoeyA> without it, (xs, _) <- runLazy $ defer getLine -- will get a line right away
17:54:09 <JoeyA> but only one of the IO actions is done rather than all.  I'd rather it be none.
17:54:15 <jmcarthur> ah
17:54:19 <jmcarthur> i see now
17:54:24 <JoeyA> (a lazy tuple match on the part of the user would fix it, but who has time for that?)
17:54:41 <jmcarthur> yeah i was thinking of that case, but i see that you would rather that hassle not be there
17:54:45 <awarring> I'm confused as to what implementation of liftIO is actually being called
17:54:58 <benmachine> awarring: this is for a monad transformer?
17:55:06 <awarring> benmachine: yes
17:55:08 <benmachine> well of course it is
17:55:20 <benmachine> so it's using the "next monad down"'s liftIO
17:55:23 <ski> co_dh : not in general
17:55:29 <awarring> argh, duh
17:55:32 <awarring> thanks benmachine 
17:56:00 <awarring> i get confused, sometimes the haskell type system seems so magical in how it infers types
17:56:01 <JoeyA> Haskell:  it's monads all the way down.
17:56:03 <awarring> lol
17:56:17 <benmachine> awarring: it's not obvious :)
17:56:29 <co_dh> ski: I don't need a show for function in general , just something like the type of the function, or something I can identify that function.
17:56:30 <JoeyA> What's fun is using Data.Binary
17:56:35 <JoeyA> and just saying "get"
17:56:38 <benmachine> awarring: but that's kind of natural in what liftIO does, each monad knows how to pass the action to the next transformer
17:56:46 <ski> > not
17:56:47 <lambdabot>   Overlapping instances for GHC.Show.Show
17:56:47 <lambdabot>                              (GHC.B...
17:56:52 <JoeyA> when the type is inferred by the type signature of the caller to refer to the right value.
17:56:52 <benmachine> which it has to do because it doesn't actually know what the next transformer *is*
17:59:04 <ski> co_dh : yeah, you could do something like `instance (Typable a,Typable b) => Show (a -> b) where showsPrec p f = showParen (p > 0) $ showString "_ :: " . shows (typeOf f)', i think
17:59:34 <jmcarthur> :t typeOf
17:59:36 <lambdabot> forall a. (Typeable a) => a -> TypeRep
17:59:40 <awarring> JoeyA: yea, I've had to scratch my head at times with Data.Binary because of that as well
17:59:45 <jmcarthur> > typeOf (undefined :: Int -> Double)
17:59:46 <lambdabot>   Int -> Double
17:59:50 <awarring> thanks benmachine
17:59:52 <jmcarthur> co_dh: ^^
18:00:03 <mietek> What's the best way to read a file into a list of Word32s?
18:00:06 <ski> co_dh : though, if you're manually writing a `Show' instance for another type, you don't even need to add an instance on function types
18:00:39 <co_dh> ski: thanks, I'll try
18:00:54 <jmcarthur> mietek: i don't know about best, but the binary or cereal packages should make it pretty easy
18:01:51 <co_dh> :info Typeable
18:02:02 <co_dh> @hoogle Typeable
18:02:02 <lambdabot> module Data.Typeable
18:02:02 <lambdabot> Data.Typeable class Typeable a
18:02:02 <lambdabot> Data.Typeable class Typeable1 t
18:03:20 <co_dh> ski: it works, thanks!!
18:03:25 <mietek> jmcarthur: I don't know; these both seem to define their own serialization schemes
18:03:31 <ski> co_dh : yw :)
18:03:55 <ski> co_dh : just note that you shouldn't place that instance in any library
18:04:10 <co_dh> what ? 
18:04:17 <co_dh> why ? 
18:04:21 <ski> i mean if you're making a library
18:04:23 <co_dh> only in my main code ? 
18:04:36 <ski> and if other people then use that
18:04:49 <ski> they might have their own such instances, which would clash
18:04:52 <jmcarthur> ezyang: "As mentioned earlier, our testing method guarantees that this set of
18:04:54 <jmcarthur> laws is complete, in the sense that any valid equation over our signature, which
18:04:56 <jmcarthur> is not excluded by the depth limit, follows from these laws."
18:05:15 <ski> (iirc, some libraries/packages already have `Show' instances for function types)
18:05:27 <co_dh> ski: thanks. can I get the function name displayed in Show ? 
18:05:41 <jmcarthur> mietek: you can use the Get monad to read in Word32s, i'm sure
18:05:49 <ski> co_dh : what is the name of `[2,5,7,9]' ?
18:05:57 <jmcarthur> i think that's the name of the monad, anyway
18:06:00 <JoeyA> mietek: Data.Binary and Data.Serialize both encode Word32s the same way: big endian.
18:06:04 <ski> co_dh : what is the name of `\x -> x*x - log x' ?
18:06:23 <co_dh> ski: you are right, what if that function have a name?
18:06:26 <JoeyA> but they have methods for writing them manually.
18:06:36 <ezyang> jmcarthur: Where "Depth limit" is kind of key :-) 
18:06:38 <JoeyA> getWord32be and putWord32be or something.
18:06:43 <jmcarthur> ezyang: so the "completeness" they are talking about is only up to the depth of their expression generator
18:06:45 <jmcarthur> yeah :)
18:06:54 <ski> co_dh : functions (like other values) don't inherently have names. names are used to (sometimes) refer to them, and one could have many names which reference a value
18:07:12 <jmcarthur> ezyang: it's still pretty cool though, IMO :)
18:07:13 <JoeyA> e.g.:
18:07:21 <JoeyA> contents <- readFile "foo.binary"
18:07:21 <co_dh> ski: ok, thanks.
18:07:23 <ezyang> Yeah. 
18:07:28 <ski> co_dh : also, generally, after compilation, any names would have been removed from the executable code, so at run-time there's no names to print left
18:07:59 <ezyang> Unfortunately, purely functional code isnât as prone to sprouting the sort of complexity that this tools would be really killer for as imperative code is. 
18:08:11 <JoeyA> decode contents :: [Word32]
18:08:14 <ezyang> ^ really really bad sentence :o) 
18:08:26 <jmcarthur> heheh
18:09:04 <jmcarthur> ezyang: but a lot of really complex imperative code won't have very meaningful properties like this anyway
18:09:08 <ski> (ezyang : i didn't notice any bad part ..)
18:09:12 <mietek> HM
18:09:20 <mietek> WHy would my ghc-binary package be hidden?
18:09:28 <ezyang> jmcarthur: Yeah, itâs true. 
18:09:46 <ski> ezyang,jmcarthur : what'cha talking about ?
18:09:57 <jmcarthur> ski: https://docs.google.com/viewer?url=http://www.cse.chalmers.se/~nicsma/quickspec.pdf&pli=1
18:10:12 <jmcarthur> gah, sorry for the google viewer link
18:10:18 <jmcarthur> well, sorry unless you like it :)
18:11:01 <mietek> Could not find module `Data.Binary': It is a member of the hidden package `ghc-binary-0.5.0.2'.
18:11:16 <jmcarthur> i have my browser automatically turn pdf links into google viewer links so i don't have to use a pdf reader plugin or external program
18:12:08 <mietek> I've now exposed the package; I don't understand why was it hidden, though.  Is it hidden by default after a Platform installation?
18:12:40 <ski> jmcarthur : i don't :)
18:13:16 <jmcarthur> mietek: i don't even know what ghc-binary is. it sounds dangerous to me :)
18:13:24 <ezyang> Has anyone tried to treat Hask as a graph and run visualizations on it? 
18:13:37 <jmcarthur> mietek: you might want to try the binary package instead of ghc-binary
18:13:47 <ski> "run visualizations" ?
18:14:09 <jmcarthur> ski: yeah, as opposed to walking them
18:14:26 <ezyang> ski: Like, maybe thereâs some sort of interesting structure to the type system that you could see if you graphed out all of the functinos. 
18:14:30 <ezyang> *functions 
18:14:41 <mietek> jmcarthur: it came with the Platform...
18:15:00 <ski> ezyang : like CT diagrams ?
18:15:04 <ezyang> ski: Yeah. 
18:15:10 <mietek> I think.
18:15:28 <jmcarthur> mietek: and was hidden by default
18:15:33 <ezyang> It might be the case that high arity means there will be a lot of partially curried function types floating around 
18:15:35 <ski> or like visual programming (like those diagrams of computing fibonacci numbers using a fix-point with `zipWith') ?
18:15:37 <ezyang> so it might not actually be useful. 
18:15:43 <ezyang> Not visual programming. 
18:15:49 <ezyang> (though that is interesting in its own right :-) 
18:19:38 <mietek> ghc-binary has the same version number as binary
18:19:51 <mietek> Anyhow, both seem to work
18:20:34 <rabidsnail> Are there any libraries in haskell for working with on-disk trees?
18:22:52 <Axman6> rabidsnail: i know there's at least one file system written in haskell, is that the sort of thing you mean?
18:23:13 <Cale> Is the filesystem open-source though?
18:23:34 <rabidsnail> Axman6: Yeah. I'm thinking more along the lines of space partitioning, but similar stuff under the covers.
18:23:47 <Martty> what do you write when you write a filesystem ?
18:23:52 <Martty> isnt it a spec 
18:24:02 <Martty> what exactly do you need to implement?
18:24:35 <ezyang> Martty: Thereâs several layers. 
18:24:39 <rabidsnail> Martty: A quadtree that gets updated frequently and won't go away when the power goes out.
18:25:03 <Martty> sounds like haskell is a good choice
18:25:03 <Cale> rabidsnail: Interesting, what is it for?
18:25:12 <rabidsnail> Nearest-neighbor
18:25:23 <rabidsnail> collaborative filtering
18:25:52 <Cale> Ah, so a data-mining sort of project
18:25:53 <ezyang> http://pdos.csail.mit.edu/6.828/2009/lec/l-fs.html 
18:26:04 <rabidsnail> Cale: yes
18:33:17 <Cale> http://www.reddit.com/r/haskell/comments/d6ve6/quickspec_guessing_formal_specifications_using/ -- this is really cool
18:49:17 <Adamant> QuickSpec looks nice
18:51:30 <jmcarthur> indeed it does
18:51:35 <jmcarthur> i can't wait to see it on hackage
18:51:44 <jmcarthur> it's a good day's worth of fun, at least
18:54:06 <benmachine> sort (xs ++ ys) == sort (ys ++ xs) -- the paper says this strongly implies sort doesn't depend on the order of the input
18:54:14 <benmachine> I think that together with the associativity of ++ it requires it
18:54:22 <benmachine> eeer
18:54:28 <benmachine> *strongly suggests, but does not imply
18:55:27 <Veinor> yeah, if f (x ++ y) = f ( y ++ x) then f cannot depend on the order of its input
18:55:59 <benmachine> sort (xs ++ ys ++ zs) == sort (xs ++ (ys ++ zs)) == sort ((ys ++ zs) ++ xs) == sort (ys ++ (zs ++ xs)) == sort ((zs ++ xs) ++ ys) == ...
18:56:28 <benmachine> hmm
18:56:32 <Jafet> Well, you cannot prove anything out of a black box
18:56:47 <QtPlatypus> benmachine: You can prove that via induction
18:56:47 <benmachine> f could depend on the order of its input up to a point
18:57:12 <benmachine> in particular, f could depend on the order of its input modulo cyclic shifts
18:57:40 <benmachine> now, if you proved that sort (xs ++ ys ++ zs) == sort (xs ++ zs ++ ys), then...
18:57:48 <Jafet> I wonder if you could make an inverse to this quickspec
18:57:50 <QtPlatypus> benmachine: Ah yes
18:58:00 <jmcarthur> an inverse?
18:58:08 <Veinor> benmachine: oh... yeah
18:58:15 <benmachine> Jafet: well, two of the specs it comes up with for ++ are just the definitions of that function :P
18:58:28 <benmachine> the inverse might be called GHC?
18:58:45 <Jafet> Not always, though
18:58:52 <Jafet> Maybe with view patterns
18:59:00 <Tomsik> Prolog is inverse to all
18:59:15 <Tomsik> It will backtrace your pants off
18:59:32 <Jafet> And backtrack them, too
19:02:57 <Tomsik> Three Languages for the FP during their gradwork
19:03:30 <Tomsik> Seven for the Imperative programmers in their viewpoint of stone?
19:04:22 <Jafet> Nine for Sysadmins doomed to die
19:04:53 <Tomsik> now, what is the worst language ever?
19:04:56 <Veinor> One for alan turing on his pink throne?
19:05:42 <Tomsik> I think it should be an epic tale of epic fight of Church against Turing or something
19:05:51 <kmc> tolkien is overrated
19:06:06 <Tomsik> What isn't?
19:06:10 <diPython> lol
19:06:23 <kmc> functional programming
19:06:31 <Tomsik> nah, it's overrated too
19:06:42 <Veinor> haskell!
19:06:50 <kmc> Haskell is overrated by people who have just started learning
19:06:54 <Pseudonym> Dismissing stuff out of hand is completely overrated.
19:07:01 <Veinor> overrating things is overrated.
19:07:02 <kmc> but underrated by programmers in general
19:07:05 <Tomsik> You know what's not overrated? Feces. Nobody thinks feces are great and if they do, there's something... smelly going on anyway,
19:07:05 <Pseudonym> Retro is the new passe/
19:07:22 <diPython> i'm not overrated, nobody knows me
19:07:29 <Tomsik> Passe is passe.
19:09:28 <Pseudonym> Oh, this reminds me of a joke.  How many hipsters does it take to change a lightbulb?
19:10:00 <Tomsik> lightbulbs are passe?
19:10:14 <Tomsik> or not "ironic" enough?
19:10:52 * notabel suspects the punchline has to do with one changing it and the rest complaining that they were into changing lightbulbs before it was cool
19:11:33 * Pseudonym notes that this joke would work better spoken than on IRC
19:11:46 <Pseudonym> Because the first response of most people is to say "I don't know".
19:11:54 <Pseudonym> The punchline is then: You don't KNOW?!
19:12:08 <Veinor> "Yeah, it's a pretty indie joke, most people haven't heard it before."
19:12:17 <jmcarthur> lol
19:12:25 <Tomsik> haha
19:12:45 <notabel> aha!  metahumor
19:13:10 <Veinor> I like how haskell-blah is talking about haskell-y stuff and we're telling hipster jokes in here.
19:13:11 <Tomsik> I was into metahumor and irony before it was cool
19:13:25 <Tomsik> and now I'm not, because it's cool which is uncool which is cool
19:13:41 <Tomsik> I don't see how COBOL is haskelly :p
19:13:58 <aristid> COBOL is the new haskell
19:14:13 <Veinor> COBOL on cogs!
19:14:54 <Pseudonym> http://littlehipsters.tumblr.com/
19:15:28 <Pseudonym> In particular: http://littlehipsters.tumblr.com/photo/1280/837234275/1/tumblr_l5vc2olHgI1qcjsau
19:15:57 <sajkr> hello.
19:16:15 <Tomsik> hello, you hipster
19:16:19 <sajkr> :)
19:18:29 <mtnviewmark> APPLY CONS TO 'H' AND "ELLO".
19:19:01 <mtnviewmark> F*COBOL = Functional Cobol?
19:19:04 <Tomsik> thank goodness that there's almost no subcultural people on CS in my institute
19:21:31 <tonypnz> Hi all, I'm thinking about writing a trend forcasting and what-if business intelligence program.. would Haskell be a suitable language for that?
19:22:03 <Tomsik> Umm... what would that software do?
19:23:41 <Jafet> Sexpert fistem
19:25:52 <tonypnz> Basically look at trends for the same week over the past x years and forecast what would most likely happen this week
19:26:08 <sajkr> let's say that i'm writing a daemon which provides a HTTP/JSON interface to MPD. so i'm looking for a "http server library", ie. all i need is something to abstract over the protocol details, perhaps also providing a nice way to handle request urls.
19:26:18 <tonypnz> also provide a way for the business to propose changes and see what might happen
19:26:25 <sajkr> i'm looking at snap-core atm. any advice?
19:27:42 <Tomsik> tonypnz: haskell will let you develop rapidly, letting you implement better algorithms
19:28:02 <Tomsik> but if it's very number-crunchy and does heavy computations that take over a second
19:28:05 <Tomsik> I'm not sure
19:29:01 <diPython> how are you representing trends?
19:30:47 <kmc> tonypnz, it's probably suitable, but Haskell takes a long time to learn properly
19:30:57 <kmc> if you want to get this up and running quickly, and you don't know any Haskell already, it might not be a good choice
19:31:33 <tonypnz> Thanks for the answers, it doesn't need to be too quick, I was going to use it as a way to learn Haskell
19:31:44 <kmc> ok, sounds good then :)
19:31:48 <kmc> just be prepared to start small
19:31:53 <tonypnz> yeah sure :)
20:07:20 <ezyang> In what since of the word âaffineâ is âaffine typesâ using it? 
20:08:56 <diPython> can someone help me with an agda question?
20:09:02 <diPython> very basic question
20:11:19 <diPython> i have data Vec (A : Set) : Nat -> Set with [] : Vec A zero and _::_ : {n : Nat} -> A -> Vec A n -> Vec A (succ n)
20:12:15 <diPython> and data Fin : Nat -> Set with fzero : {n : Nat} -> Fin (succ n) and fsucc : {n : Nat} -> Fin n -> Fin (succ n)
20:12:44 <diPython> data Nat : Set where zero : Nat and succ : Nat -> Nat
20:13:02 <diPython> now I want to define the following function
20:13:35 <diPython> _!!_ : {A : Set}{n : Nat} -> Vec A (succ n) -> Fin (succ n) -> A
20:14:09 <diPython> this type is to remove having to do [] !! () 
20:14:30 <diPython> but i run into problems with the recursive call 
20:15:13 <diPython> i need a way of specifying that (x :: []) !! fsucc n fails
20:15:34 <diPython> any thoughts?
20:18:29 <Cale> Hmm, I'm not an Agda user, but isn't it really something like...
20:19:09 <cadabra> Is there any way to catch the error from (fromJust Nothing)?
20:19:09 <Cale> _!!_ : {A : Set}{n : Nat}{m : Nat} -> {n <= m} -> Vec A m -> Fin n -> A
20:19:21 <Cale> (I'm not sure of the actual Agda syntax for what I mean)
20:19:44 <diPython> Cale I cannot change that type
20:19:45 <Cale> cadabra: Technically there is, but you should never really do it
20:20:08 <cadabra> Cale: why not?
20:20:49 <Cale> cadabra: fromJust should only be used when you're already absolutely certain that the value is Just x. It should indicate a flaw in your program for that exception to occur.
20:20:58 <jmcarthur> i'm playing with QuickSpec. it's really fun
20:21:42 <cadabra> In my case I do: let getFoo = bunch of operations that may fail. catch getFoo \e -> do { print "Could not get foo"; return ...; }
20:22:04 <cadabra> I don't want to write error handling code for everything in getFoo, I don't need that sort of detail in this case.
20:22:29 <Cale> It sounds a bit like you want to use the fact that Maybe is a monad.
20:23:45 <diPython> jmcarthur: why is it fun?
20:24:26 <cadabra> Well, there's more than Maybe involved, but perhaps I could look into that. Do you know a good resource?
20:25:08 <Cale> ezyang: Linear type systems ensure that every variable is used exactly once
20:25:38 <ezyang> Does linear = affine? 
20:25:42 <Cale> No.
20:25:57 <Cale> Affine type systems by contrast ensure that each type variable is used *at most* once
20:26:06 <ezyang> ...hmmmm. 
20:26:37 <Cale> This is sort of by a weak analogy to the way that the expressions for linear and affine functions look.
20:26:57 <ezyang> Yeah, I can sort of see that. 
20:27:01 <Cale> (At least, as far as I understand it)
20:27:16 <diPython> hmm, why is that useful?
20:28:08 <ezyang> No. Actually, I feel like it should be the other way around. 
20:28:39 * ezyang is puzzled 
20:28:49 <Cale> cadabra: hmm... well, most tutorials about monads talk about Maybe at some point, but the basic idea is that "running" a Maybe value will result in x in the case that it's Just x, and will cause the whole computation to fail and produce Nothing otherwise
20:29:06 <ezyang> diPython: Linear/affine types? 
20:29:10 <diPython> yes
20:29:18 <diPython> affine types
20:29:21 <ezyang> One thing they let you do is say "this value should only be used once" 
20:29:34 <Cale> > let dict = zip [0..] (words "hello there world") in do x <- lookup 0 dict; y <- lookup 2 dict; return (x,y)
20:29:34 <ezyang> for example, if that value represents some IO action that you shouldn't reuse. 
20:29:35 <lambdabot>   Just ("hello","world")
20:29:41 <Cale> > let dict = zip [0..] (words "hello there world") in do x <- lookup 0 dict; y <- lookup 5 dict; return (x,y)
20:29:42 <lambdabot>   Nothing
20:29:45 <dolio> Linear types are useful for resource management.
20:29:48 <Cale> cadabra: ^^
20:30:07 <diPython> i can see why linear types are useful, but what about affine types?
20:30:22 <Cale> cadabra: Note that in a do-block if you have v <- x and x :: Maybe a, then v :: a
20:30:38 <kmc> cadabra, rather than catching Â«fromJust NothingÂ» you would pattern-match on the Maybe value, or use a function like 'maybe' or 'fromMaybe'
20:30:38 <kmc> :t maybe
20:30:38 <kmc> :t fromMaybe
20:30:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:30:39 <lambdabot> forall a. a -> Maybe a -> a
20:30:45 <ezyang> diPython: Theyâve found some applications in session typing 
20:30:52 <ezyang> Where you use types to encode protocols 
20:31:07 <diPython> is there any paper about it?
20:31:13 <Cale> kmc: His issue is that there are a lot of possible points of failure and he just wants to collect them all.
20:31:24 <kmc> ok
20:31:29 <diPython> any good paper :)
20:31:31 <dolio> Affine types, off the top of my head, let you do the same mutability optimizations as linear types would.
20:31:48 <dolio> But you'd still need garbage collection.
20:31:49 <Cale> diPython: ATTaPL's first chapter? :)
20:32:19 <kmc> cadabra, then maybe you want this function:  (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
20:32:23 <kmc> @src Maybe (>>=)
20:32:23 <lambdabot> (Just x) >>= k      = k x
20:32:23 <lambdabot> Nothing  >>= _      = Nothing
20:32:45 <kmc> (as suggested above, but in different words)
20:33:25 <diPython> Cale: thanks 
20:33:46 <kmc> @undo do x <- lookup 0 dict; y <- lookup 2 dict; return (x,y)
20:33:46 <lambdabot> lookup 0 dict >>= \ x -> lookup 2 dict >>= \ y -> return (x, y)
20:33:55 <dolio> Also, _!!_ : {A : Set} {n : Nat} -> Vec A n -> Fin n -> A, presumably.
20:34:37 <dolio> You don't need the succs, because when n = 0, you have an empty vector, but also an empty set Fin 0.
20:38:10 <diPython> did anyone tried the caldims library about units of measurement ?
20:38:17 <applicative> I see, the values in the Fin n types represent the numbers less than n?
20:39:10 <dolio> Well, at least, Fin n has n elements.
20:39:32 <dolio> But typically you construct it as fzero and fsucc, which would make them the natural numbers less than n, yes.
20:40:07 <co_dh> @src Either fmap
20:40:07 <lambdabot> fmap _ (Left x) = Left x
20:40:07 <lambdabot> fmap f (Right y) = Right (f y)
20:40:10 <applicative> diPython wants them to be ordered, plainly.
20:41:00 <diPython> yes
20:41:02 <dolio> (exists m. m < n) is another representation strategy that's explicit about that.
20:41:36 <dolio> Or Sigma, really.
20:42:02 <diPython> applicative: the problem is the recursive call
20:42:36 <diPython> (not sure if i sure say recursive or just talk about induction)
20:42:43 <diPython> *just say
20:42:54 <diPython> *should day lol
20:42:56 <diPython> omg
20:43:04 <diPython> ***should say
20:44:40 <diPython> (x :: t) !! fsucc n = t !! n
20:45:11 <diPython> i think its because t can be [], so it doesnt type checks
20:45:38 * applicative ... uh ...is beaming over his shiny new just-compiled The Glorious Glasgow Haskell Compilation System, version 6.13.20100826
20:46:00 <kmc> compile GHC every day
20:46:08 <dolio> diPython: In the (x :: []) !! (fsucc fn) case, fn :: Fin 0, I believe.
20:46:17 <dolio> So you should be able to match on it with the absurd pattern.
20:46:26 <applicative> kmc, you're another subject...!   
20:47:24 <kmc> ?
20:47:52 <applicative> kmc, i meant, it doesn't surprise my you compile 6 versions of the ghc each morning before breakfast.
20:48:02 <diPython> roflol
20:48:06 <kmc> 6 broken versions maybe
20:48:14 <applicative> i have to trash the darcs repository a few times first....
20:48:35 <kmc> darcs :(
20:48:43 <diPython> dolio: how do i do that ? 
20:48:48 <kmc> 'darcs annotate' on GHC's tree is unusable
20:48:56 <dolio> (x :: []) !! (fsucc ())
20:49:20 <diPython> ok let me try smth
20:49:55 <applicative> kmc, is that right, it seems not to return for me, I figured it was all my fault
20:50:13 <kmc> for me it spins for a few minutes then dies with a 'stack overflow' error
20:50:24 <kmc> i confirmed on IRC and on the GHC wiki that this is the expected behavior
20:50:29 <applicative> is it just the immensity of the repository?
20:50:33 <co_dh> @pl \g x -> pure g <*> x
20:50:33 <lambdabot> (<*>) . pure
20:50:41 <kmc> if you're feeling charitable to darcs, yes
20:51:00 <kmc> but git can handle similarly sized repositories without breaking a sweat
20:51:06 <kmc> i mean it was designed for the Linux repo
20:51:14 <diPython> dolio: i still have the problem of the recursive call, how do you do (x :: t) !! (fsucc n) ?
20:51:27 <applicative> well, i meant, it's disproportionate to darcs.  I never have any trouble with darcs but I don't have to do with any giant projects
20:51:30 <kmc> so perhaps blame the algorithm used by darcs, or its data model, or the implementation of these
20:51:32 <dolio> You have to match on t and n.
20:51:40 <dolio> Your scheme isn't saving you any work.
20:51:57 <kmc> darcs is fast enough for a tiny project, but too slow for many significant projects
20:52:05 <kmc> i'm told they've improved that a lot in recent years
20:52:11 <Axman6> that's changing though right?
20:52:22 <Axman6> speed is one of their top priorities at the moment
20:52:23 <diPython> dolio: i know, this is just an exercise. it gives me a type check error on t
20:52:25 <kmc> so perhaps GHC is hurt by being an old repo and can't take advantage of the latest features
20:52:32 <Makoryu> Axman6: It's still changing slowly
20:52:36 <applicative> i've never had trouble except with the ghc.  i assume because it's old and a monster
20:52:50 <diPython> in (x :: t) !! fsucc n = t !! n
20:52:56 <Makoryu> Axman6: Maybe the problem is that they're using the current version of darcs, rather than a future version, to develop darcs
20:53:12 <Axman6> Makoryu: lol
20:53:15 <kmc> if only we could borrow a new version of darcs from the future and use it to develop that same version
20:53:26 <Veinor> clearly we need continuations
20:53:31 <Makoryu> ï¼ãÂ°â¿â¿Â°ï¼
20:53:32 <dolio> (x :: (y :: t)) !! (fsucc fzero) = y ; (x :: (y :: t)) !! (fsucc (fsucc n)) = (y :: t) !! fsucc n
20:53:51 <Veinor> I agree with Makoryu. ï¼ãÂ°â¿â¿Â°)
20:53:55 <dolio> Or something like that.
20:54:09 <applicative> i love darcs, except when it comes to the ghc, but i don't have experience of the problems of the past
20:54:21 <dolio> Actually, matching that far on the finite set probably isn't necessary.
20:54:26 <kmc> applicative, do you know git too? how do you think the two compare?
20:54:51 <dolio> (x :: (y :: t)) !! fzero = x ; (x :: (y :: t)) !! fsucc n = (y :: t) !! n
20:55:03 <diPython> yep
20:55:14 <diPython> :D
20:55:21 <applicative> i'm much feeble with git. It's obviously way faster with things, but that doesn't seem worth the complete madness of the system of commands
20:55:41 <diPython> dolio: thanks
20:55:42 <applicative> but maybe that will change with more experience
20:56:01 <kmc> git has a really simple clean data model
20:56:31 <kmc> and some complex commands for manipulating it
20:56:38 <applicative> if that were really true, it woud be much easier to master
20:56:51 <Tomsik> same about haskell?
20:57:04 <applicative> nobody who really thinks out a 'really clean data model' goes on to invent retarded commands.  ....
20:57:10 <kmc> applicative, what part do you think is untrue?
20:57:21 <kmc> and what's wrong with the commands?
20:57:26 <applicative> but i'm not making a serious knowlegable objection.  
20:57:43 <applicative> the commands are unlearnable, you have to study Pro Git ...
20:57:52 <applicative> and refer to it constantly.
20:58:02 <kmc> i learned git, i am a counterexample
20:58:05 <applicative> darcs you learn in a half an hour.  but of course its clunky
20:58:11 <applicative> i'm learning git too...
20:58:20 <Tomsik> svn is easy to learn or something
20:58:23 <applicative> it's taking alot longer
20:58:30 <applicative> svn is pretty easy too.
20:58:33 <applicative> ha
20:58:38 <kmc> i like git's approach (simple data model + complicated commands) as opposed to the opposite.  because even if you don't understand a particular command, you can understand what's there before and after
20:58:56 <kmc> svn is easy, it works great about 90% of the time and will ruin your life the other 10%
20:59:05 <Tomsik> kind of
20:59:18 <applicative> kmc, i dont mean to oppose you.  I think it might seem that way when you have more mastery of it than i do.
20:59:21 <Tomsik> it's annoying when whining about conflicts
20:59:58 <kmc> applicative, so if git is "unlearnable" then how did i learn it?
21:00:02 <applicative> it's strange you think darcs' data model isn't as simple as its commands. I'd think they go together
21:00:04 <kmc> (i'm certainly not a master by any means, but i get by)
21:00:07 * ezyang likes git too. 
21:00:13 <kmc> i made no claim about darcs's data model
21:00:15 <applicative> kmc, anyone can learn it, i'm learning it.
21:00:20 <kmc> when i said "the opposite" i didn't mean "darcs"
21:00:29 <applicative> i use it a fair bit, but with periodic crises :)
21:01:08 <applicative> but what amazes about git is the speed of everything, it stuns the mind.
21:01:54 <kmc> yeah
21:02:04 <applicative> its funny how people mind slowness in some things but not in others. for example, the mind numbing slowness of latex
21:02:10 <kmc> git is a hash-addressable copy-on-write filesystem, and a VCS implemented on top of that
21:02:26 <kmc> the former is something you'd expect to be fast
21:02:55 <kmc> some VCS operations will be slow with that model, but the common ones turn out to be pretty fast
21:04:01 <Tomsik> VCS?
21:04:28 <ezyang> version control system 
21:05:08 <co_dh> :i Identity
21:05:13 <co_dh> :t Identity
21:05:14 <lambdabot> forall a. a -> Identity a
21:05:29 <co_dh> @hoogle Identity
21:05:30 <lambdabot> module Control.Monad.Identity
21:05:30 <lambdabot> Control.Monad.Identity newtype Identity a
21:05:30 <lambdabot> Control.Monad.Identity Identity :: a -> Identity a
21:05:32 <applicative> Tomsik, there's a heated darcs vs git agreement underway.
21:05:46 <Tomsik> yeah, just didn't know that acronym
21:06:39 <kmc> i'm not agreeing
21:06:46 <kmc> ;)
21:06:54 <applicative> what aren't you agreeing with?
21:07:07 <applicative> ...just to keep the heated agreement going ...
21:07:15 <Tomsik> he doesn't agree with anything
21:07:18 <kmc> that git is "unlearnable" and that its commands are "retarded"
21:07:24 <kmc> your words
21:07:34 <applicative> oh, i grant those were over the top.  
21:07:58 <applicative> still, there is a great disproportion in learnability, ease of understanding, etc.
21:08:08 <kmc> i mean, you're entitled to hyperbole, but i don't see what's so wrong with git's command-set at all
21:08:21 <kmc> yeah, git is not a system optimized for learnability
21:08:23 <kmc> neither is Haskell
21:08:24 <kmc> ;)
21:08:40 <applicative> "yeah, git is not a system optimized for learnability" -- right, thats my point
21:08:57 <etpace> well is that a problem
21:08:59 <applicative> we will disagree about Haskell, it is, of all languages, most optimized for learning
21:09:00 <Tomsik> kmc: I think this is inappropriate to say that something is "unlearnable" here, yaeh
21:09:28 <etpace> @src guard
21:09:28 <lambdabot> guard True  =  return ()
21:09:28 <lambdabot> guard False =  mzero
21:09:39 <applicative> the main body of git enthusiasts seem to use fancy gui's i gather. 
21:09:54 <Tomsik> something can be nonmemorizable, but not unlearnable
21:10:53 <_nickel> applicative: I've not found that to be the case at all
21:11:10 <_nickel> applicative: the cli can be tough to learn but I've never used anything else
21:11:12 <applicative> _nickel, which of my over the top exagerrations
21:11:26 <_nickel> applicative: :D git and fancy gui's
21:11:32 <kmc> applicative, i worked on a team of ~30 software devs using git as our primary vcs, and we didn't have anything too fancy
21:11:47 <kmc> i used gitk and tig
21:11:55 <kmc> tig is basically curses gitk
21:12:01 <_nickel> kmc: tig is about the only thing outside of the cli that I use
21:12:12 <applicative> _nickel, try darcs, for the heck of it, then.  It takes about an hour to master
21:12:28 <_nickel> applicative: I was going to say I haven't tried darcs
21:12:29 <applicative> you can teach it to small children
21:12:49 <_nickel> kmc: though I should point out I am generally on teams of 2 to 3 consultants at the largest
21:12:55 <applicative> but, for professionals, git is the answer, i suppose
21:13:09 <_nickel> applicative: its officially on my todo list :D
21:14:16 <applicative> all of my lecture notes from the last couple years are in little micro darcs - repositories
21:14:43 <diPython> i like darcs
21:14:49 <diPython> never tried git? is any good?
21:15:17 <Veinor> git's pretty nice
21:15:37 <etpace> is there really any big advantage of using one over the other
21:15:40 <etpace> or is it just nitpicking
21:15:44 <applicative> diPython, yes, it's good, it's a monster that eats and merges and gets the right answer.
21:15:49 <_nickel> diPython: I think its a great tool
21:16:10 <applicative> kind of a black box if you ask me, but i bow to superior wisdoms
21:16:22 <kmc> etpace, i like git for its speed and simple data model
21:16:24 <diPython> applicative: haha
21:16:29 <_nickel> diPython: take some learning, but once your comfortable with it you'll wonder how you lived without it
21:16:42 <kmc> etpace, i have not used darcs much, but have been disappointed with its inability to handle basic tasks without choking and dying
21:16:50 <_nickel> diPython: and github is very nice ;)
21:16:53 <applicative> what's simpler than the so-called patch algebra
21:17:01 <atude> addition
21:17:17 <diPython> monster that eats and mergers and gets the right answer! i'm curious
21:17:27 <_nickel> applicative: I would love to see a cabal-install addition to pull tagged tarballs from github and build them, I even looked at doing it myself but haven't had the time
21:17:35 <applicative> _nickel, but did you learn one of the other fancy systems like darcs or mercurial or whatever, before learning git?
21:17:45 <_nickel> applicative: nope, big caveat :D
21:18:09 <_nickel> applicative: s/caveat/disclaimer/
21:18:47 <applicative> part of the git hype -- which i don't mean to attack -- is from people who used svn or nothing.  they say 'git rules', not realizing there were more sophisticated systems.  ...
21:19:00 <applicative> of course git does clean their clocks on any number of points...
21:19:08 <kmc> yeah
21:19:12 <Axman6> but linus wrote it, it must be perfect!
21:19:17 <kmc> just like how a lot of very basic features of Haskell get hyped by people who've only used Java
21:19:19 <_nickel> Axman6: who says that?
21:19:21 <kmc> "wow, first-class functions, the future is here"
21:19:38 <applicative> i thinks thats the secret reason for my refusal to go full tilt git-lover, i hate linus
21:19:48 <applicative> but this is distinctly -blah
21:20:24 <_nickel> honestly one of gits killer features is github
21:20:45 <diPython> applicative: why do you hate him?
21:20:49 <kmc> a little ironic given that it's marketed as an uber-decentralized vcs
21:20:59 <kmc> git is flexible though, it supports lots of hybrid workflows
21:21:11 <applicative> there's no reason why github shouldn't admit darcs or mercurial repositories. it's all marketing nonsense
21:21:37 <jmcarthur> kmc: the only scenario that i've seen modern versions of darcs choke on is when you are messing with large binaries
21:21:50 <applicative> excellent point about github, kmc
21:22:40 <applicative> diPython, i'm exagerrating as usual.  I just feel like he aids and abets the C -and - unix forever world.
21:22:52 <applicative> my utopia is very different
21:23:55 <kmc> jmcarthur, so is the failure of "darcs annotate" on a GHC tree due to GHC being an old repo or due to my version of darcs (2.4)?
21:24:04 <diPython> applicative: share your utopia with us :)
21:24:07 <Tomsik> why there's no electronics native to lambda calculus instead of register machines? :<
21:24:09 <applicative> meet the new OS, same as the old OS
21:24:26 <Axman6> applicative: linus is the mian reason for me avoiding learning git as well
21:24:36 <kmc> Tomsik, http://www.cs.york.ac.uk/fp/reduceron/
21:24:44 <Makoryu> applicative: YEEEAAAAAAHHHHH
21:24:45 <applicative> and its programming language, a madhouse from 40 years ago. 
21:25:10 <FSalad_III> curious... .hsc files are HAMSTER files according to vim :-)
21:25:11 <Tomsik> come on, lisp is older
21:25:22 <applicative> wow, what's hamster
21:25:31 <applicative> but lisp isn't a madhouse, it's a wonder
21:25:42 <kmc> ehhhh
21:25:50 <kmc> Common Lisp is a huge language with lots of hairy corners
21:25:55 <kmc> ye olde lisp is even worse in some ways
21:26:02 <kmc> you guys are fans of lexical scoping right? ;P
21:26:03 <applicative> On my naive vision of progress, people are supposed to chuck things like C on further reflection.
21:26:36 <kmc> C is a fine language for low level systems work, and there's significant parts of an OS which will inevitably need something like C
21:26:48 <applicative> the idea of lisp, a simple lisp.  face it, its an amazing idea compared to most of what one sees.
21:26:49 <Makoryu> applicative: There are a few crucial niches where C is still absolutely necessary
21:27:00 <kmc> by "something like C" i would like to mean a language with a fancy type system which proves pointer safety at compile time, etc.
21:27:03 <applicative> well, linus is making sure of that Makoryu
21:27:04 <kmc> but that's still an active research topic
21:27:06 <Makoryu> applicative: But nobody can agree on how to improve on C while still serving those niches
21:27:25 <Tomsik> kmc: java!
21:27:26 <Tomsik> :p
21:27:32 * Makoryu slaps Tomsik
21:27:35 <kmc> i mean like ATS or Habit ;P
21:27:36 <diPython> lol
21:27:39 <applicative> away with all of them!
21:27:43 <kmc> (Habit's not dependently typed though)
21:27:53 <kmc> if you want to Get Shit Done, you've got to write the core of your OS in C or C++ and maybe higher-level parts in ML or Haskell
21:27:58 <kmc> and Linus hates C++, for good reasons
21:28:08 <diPython> who doesnt hate c++?
21:28:16 <applicative> ecrasez l'infame!
21:28:19 <kmc> i support research into new fancy systems languages, but it *is* research and linus isn't an OS researcher
21:28:21 <Tomsik> C++ is better than C
21:28:34 <Makoryu> kmc: Hmm. Maybe there's room for a strict ML dialect that panders to low-level OS development.
21:28:44 <applicative> away with them all and the so-called professional programmer who demands them!
21:29:00 <kmc> yes, a friend of mine worked with Tannenbaum for a while rewriting bits of Minix in OCaml
21:29:04 <etpace> 'professional programmer'?
21:29:19 <applicative> etpace, yeah, bracket lovers.
21:29:29 <etpace> why are they the same thing
21:29:36 <diPython> kmc: how was it? I thought on going to his classes when i was studying in a'dam
21:29:59 * applicative is out of control.  he should get back to seeing if he can get f-via-llvm working or whatever its called
21:30:12 <kmc> diPython, on't know
21:30:13 <Makoryu> kmc: OCaml displeases me greatly and I would almost rather see C++ get that job.
21:30:17 <etpace> im not sure why professional programmer ==> bracket lovers
21:30:18 <kmc> heh
21:30:27 <kmc> OCaml isn't perfect but it does have things like a real type system
21:30:37 <Tomsik> it's half-real
21:30:38 <applicative> etpace, i was meaning the great mass of them, as a blob, not e.g. you
21:30:39 <applicative> ha
21:30:44 <kmc> C++'s type system is a trainwreck.  huge effort, no payoff
21:30:49 <Tomsik> I mean, weak type variables
21:31:05 <applicative> millions of man hours on those compilers ... for what
21:31:13 <diPython> there will be lambdas in c++ in a near future
21:31:15 <applicative> so darkness can continue to be compiled
21:31:25 <kmc> yeah in Java too
21:31:27 <kmc> welcome to 1936
21:31:32 <diPython> lol
21:31:33 <Axman6> ha
21:31:41 <kmc> anyway FP in C++ will still be a pain because you've got to manage the memory for your closures explicitly
21:31:54 <Tomsik> and you WON'T have type system anyway
21:31:56 <applicative> hail The Calculi of Lambda Conversion. The pope of my church is....
21:32:02 <kmc> this is perfectly reasonable, you probably chose C++ because you want to do crazy things like that for a problem-domain reason
21:32:22 <diPython> applicative: i'm on those who works on those compilers 
21:32:28 <diPython> but not for long
21:32:43 <Makoryu> There is no reason to write compilers in C++. That way lies madness.
21:32:47 <Makoryu> I speak from experience.
21:32:48 <applicative> well, i suppose it advances *your* comprehension
21:33:00 <diPython> Makoryu: i agree
21:33:07 <diPython> applicative: i feel like a vegetable
21:33:15 <kmc> yeah.  i don't understand the appeal of the self-hosting compiler;  C++ is a bad language for writing compilers, and that's true regardless of whether the language you're compiling happens to be C++
21:33:28 <applicative> diPython, haha
21:34:01 <Tomsik> C++ is a bad language for being complied
21:34:06 <kmc> that too
21:34:09 <applicative> i suppose the ghc is self-hosting, because spj and others would find it too boring to work on otherwise.  bless them.
21:34:15 <diPython> kmc: are u talking of industrial or open source compilers? there are many reasons for c++ be the chosen one
21:35:00 <Makoryu> diPython: For C++ to be the language that you're compiling, you mean?
21:35:09 <Axman6> Makoryu: the clang guys seem to be doing alright. but i think they require a fairly high quality of code
21:35:21 <diPython> Makoryu: yes
21:35:25 <Axman6> and probably don't use a hell of a lot of what C++ has to offer
21:35:37 <Makoryu> Axman6: Man, they got Steve Jobs breathing down their necks, and god knows what else
21:35:42 <Makoryu> They can live with C++
21:35:45 <Axman6> yup
21:36:07 <Tomsik> C++ is like the rednecks, everyone hates them, but you know you need them to drive your trucks
21:36:19 <diPython> whats the alternative to c++ anyways? 
21:36:28 <applicative> in utopia, the trucks will drive themselves
21:36:50 <QtPlatypus> Tomsik: The redneck attitude isn't manditory for truck driving.
21:36:51 <Makoryu> diPython: For what, exactly?
21:37:07 <diPython> Makoryu: writing a compiler for C++
21:37:16 <dolio> Haskell.
21:37:19 <diPython> lol
21:37:22 <applicative> haskell or something like it would make an excellent alternative, with say 1% of the human brain that has been expended on c/c++ land
21:37:34 <Makoryu> diPython: In all seriousness, Haskell or OCaml.
21:37:40 <Makoryu> Anything in the ML family, really.
21:37:46 <Tomsik> QtPlatypus: you gonna drive a truck? :p
21:37:56 <kmc> C++ is used in a lot of places it shouldn't be, but also in some niches where Haskell would really not work
21:37:57 <diPython> applicative: in utopia there will be no trucks! :D
21:38:09 <Makoryu> kmc: Yeah. Ditto C.
21:38:24 <kmc> try writing a microsecond-sensitive high frequency stock trading system in Haskell
21:38:28 <applicative> there's nothing wrong with haskelly MLy languages that a few hundred thousand programmers couldn't overcome in a week or two
21:38:44 <dolio> C++ doesn't have any special features that make implementing C++ compilers easier, that I'm aware of.
21:38:49 <kmc> "a few hundred thousand programmers"
21:39:01 <diPython> Makoryu: is there enough people that know haskell to the point of writing a compiler? don't get me wrong, i would love to use haskell to develop, but i dont see it happen.
21:39:17 <Makoryu> diPython: I don't understand what you're asking.
21:39:25 <kmc> whether you could write a C++ compiler in Haskell, i think
21:39:32 <applicative> if the brain power devoted each day to the gcc & co were given over to improving haskell, there
21:39:42 <kmc> and have it be a successful maintainable project, given the difficulty of finding Haskell programmers
21:39:50 <diPython> Makoryu: is Haskell a viable commercial choice?
21:39:50 <applicative> would be no problem writing a microsecond-sensitive high frequency stock trading system in Haskell
21:40:12 <applicative> if the answer is no, the solution is clear. 
21:40:18 <Makoryu> diPython: I believe Haskell is a great choice for writing a compiler, whether that's a C++ compiler or something else.
21:40:41 <kmc> applicative, you are making huge claims with no basis
21:40:52 <kmc> you think that the GCC team could implement basically flawless realtime garbage collection for Haskell?
21:41:24 <applicative> how many people work on gcc, report bugs suggest patches....
21:41:26 <diPython> Makoryu: I believe so too, but i dont see anyone knowing haskell in the entire compiler area where i work
21:41:47 <Makoryu> kmc: Maybe if they'd been brought up on FP rather than battles over assignment expressions and other C trivia.
21:41:54 <diPython> applicative: did you know that gcc only has 5 000 test cases ? thats amazing!
21:42:17 <luite> how many does ghc have?
21:42:26 <diPython> 95% of testing is done by users, no company can beat that 
21:42:30 <Makoryu> diPython: Well we all know Haskell doesn't get quite the attention it ought to :p
21:42:43 * applicative is studying the demographics behind the gcc.  his main point is about c-world in general though. things like haskell or minute by comparison.
21:42:50 <kmc> applicative, yeah and they're all experts in garbage collection research yes
21:42:59 <diPython> Makoryu: after all Haskell is not overrated ! :D
21:43:03 <kmc> or maybe 99% of them would actually be useless on a really difficult project like that
21:43:13 <kmc> anyway this is crazy
21:43:14 <kmc> bbl
21:46:09 <applicative> kmc, my 'baseless claims' were only the claim that we don't know anything, since so little else has been tried, and thus that claims for the necessary eternity of c-world are the 'baseless claims'; they are merely bowing before the 'facts'.
21:46:24 <Makoryu> diPython: Well, just taking compilers into account, most people think that lexx/yacc and company are the end-all and be-all of compiler tools, and that's not true.
21:46:53 <Tomsik> Truth is
21:47:00 <applicative> indeed it is, Tomsik
21:47:12 <Tomsik> That probably the world will keep being more and more dominated by java
21:47:26 <Tomsik> And our tears will flow in a great pain of our asses.
21:47:30 <Makoryu> diPython: I'm dwelling on compilers because I have a feeling that a high-profile compiler project might be just the thing to increase Haskell's visibility
21:47:50 <applicative> hey how 'bout the python compiler....
21:47:58 <Makoryu> And if everyone started writing their compilers in Haskell instead of C++... I'd be fine with that
21:48:12 <applicative> of course there was the perl6 debacle
21:48:13 <Makoryu> applicative: Possibly >:]
21:48:17 <Makoryu> Yes
21:48:24 <Makoryu> That was an interpreter, though, wasn't it?
21:48:27 <diPython> Makoryu: i think everyone still wonder about perfomance
21:48:39 <diPython> and in fact thats the main reason why people use c++
21:48:51 <Makoryu> diPython: Yeah, people have a lot of plainly wrong ideas about Haskell and lots of other languages
21:48:56 <diPython> yep
21:48:57 <applicative> Markoryu, i'm not knowledgable, it predates me;  i think it had higher pretentions.
21:49:42 <diPython> Makoryu: once you take performance out of the way, and show how amazing haskell is, people will start using it more
21:49:57 <Tomsik> yeah, people use python and php
21:49:59 <applicative> "Pugs is a compiler and interpreter for the Perl 6 programming language, started on February 1, 2005 by Audrey Tang."
21:50:04 <Tomsik> and java
21:50:10 <Tomsik> these surely don't wonder about performance
21:50:11 <diPython> but it's also an academic problem, i'm not sure how many univ. use haskell in their compiler construction courses
21:50:54 <diPython> Tomsik: definitely not, but php has a different purpose than c++ 
21:51:06 <diPython> php is horrible in my opinion
21:51:07 <Tomsik> but not necessarily than haskell
21:51:23 <notabel> applicative: was Markoryu asking about pugs?
21:51:42 <Makoryu> Who's Markoryu?
21:51:53 <applicative> notabel, i wasn't sure.  the new python would-be compiler is certainly a would-be compiler
21:51:58 <notabel> someone i met one time I didn't use tab completion
21:52:16 <Markoryu> How's that ï¼ãâ¢Ìwâ¢Ìï¼
21:52:31 * notabel is an empire now, he creates his own reality
21:52:44 <diPython> Tomsik: correct, but people dont like math in general, and haskell is almost math :D its easier to do something (even wrong) in php than in haskell  
21:52:56 <Tomsik> what, people don't like math!?
21:53:02 <FSalad_III> "Displays the set's internal structure in an undefined way." :D
21:53:13 <diPython> Tomsik: do they? oO
21:53:17 <notabel> anyway, working on Pugs was the first thing I did in Haskell, so if you were asking about Pugs, i'd be glad to answer (but didn't see the question)
21:53:23 <FSalad_III> (showTrie)
21:53:23 <Tomsik> It might be sad, but I have to remind myself often that they don't
21:53:31 <applicative> map square [1,2,3]  -- that's some rough math there
21:53:37 <Tomsik> Most people I know do like math >_>
21:53:44 <Makoryu> notabel: The question was: Was Pugs supposed to be a compiler, or merely an interpreter?
21:53:59 <applicative> foldr (+) 0 [1,2,3]  -- this math stuff is way over my head
21:54:09 <applicative> pugs was a compiler
21:54:11 <applicative> for perl
21:54:18 <diPython> applicative: what is a map? lol
21:54:37 <applicative> diPython, I have explained it to a 7th grader
21:54:47 <applicative> it's very much child's play
21:54:59 <diPython> applicative: yes i think it's quite simple
21:55:01 <applicative> when i get fmap into his head, i will declare total victory
21:55:11 <notabel> Makoryu: both.  it was a mostly-unified architecture, could interpret or compile to Haskell, Perl 5, Parrot VM code, and kind-of javascript
21:55:21 <diPython> even for a 7th grader
21:55:21 <Makoryu> notabel: Wacky
21:55:25 <notabel> there was never any attempt to give it a native-code compiler
21:55:37 <notabel> well, Parrot is the official Perl6 vm
21:55:40 <Makoryu> notabel: I can't blame them for not wanting to write a register allocator
21:55:52 <notabel> Haskell and Perl5 were pretty obvious translation targets
21:55:54 <diPython> applicative: i think there is still a lot of obfuscation in the terminology 
21:56:00 <notabel> and js, well, people seem to have a fetish
21:56:19 <diPython> specially when we move to category theory
21:56:46 <Makoryu> LLVM IR is a much nicer target than machine code, so maybe if people still want to work on the project they can give that a shot
21:56:48 <Makoryu> @notabel 
21:56:49 <lambdabot> Unknown command, try @list
21:56:49 <applicative> diPython, haskellers don't stand by haskell, but by a possible future language.  Haskell has St John the Baptist written all over it.
21:57:33 <notabel> i have occasionally had wild thoughts to that effect, but I'm just insufficiently interested in perl6 to pick up pugs without audrey
21:57:34 <applicative> diPython, if I can get fmap into the 7th graders head, I will declare the category theory nonsense a non-issue
21:57:45 <diPython> hahaha
21:58:41 <diPython> why does *everyone* says that category theory is a waste of time?
21:58:56 <Tomsik> honestly
21:59:03 <diPython> i like the diagrams, it's like puzzles
21:59:07 <applicative> diPython, it's a miracle, of course
21:59:22 <Makoryu> Fuckin' category theories. How do they work?
21:59:25 <Tomsik> I checked arrows and it turned out to be not really interesting
21:59:33 <Tomsik> kinda demotivated me
21:59:55 <diPython> Tomsik: i never looked into arrows but i heard there are powerful 
21:59:58 <applicative> Tomsik, but whats wrong with class Functor, or class Monad?
22:00:20 <Tomsik> yeah, but that's not much of CT, is it
22:00:35 <diPython> i dont think so, concerning Functor at least
22:01:49 <applicative> My own experience is that Haskell is a much greater help learning category theory than the other way round/
22:02:21 <applicative> I took a course on it last fall, and clearly, that I could execute all sorts of ideas, that they were given to my senses, in a way, was a great advantage
22:02:43 <diPython> i dont think ct is helpful to learn haskell per se
22:03:30 <diPython> as far as i could understand the real juice in ct are cartesian closed categories
22:05:57 * applicative apologizes if his excesses have offended. ... a certain wildness overtakes his brain from time to time.....
22:20:10 <elliottcable> Iâm new to Haskell. Why is the cons operator instaneous, whereas concantenation is not?
22:20:13 <Cale> I wouldn't say that CT is a waste of time by any stretch, but if your goal is just to learn how to program in Haskell, it would be probably be a waste in that context (moreso early on than later)
22:20:54 <elliottcable> (Reading LYAH)
22:20:57 <Tomsik> elliottcable: it's because of the immutability
22:21:00 <Cale> elliottcable: In memory, a list which is not empty consists of a cons cell, which consists of an integer tag and a couple pointers
22:21:01 <mtnviewmark> elliottcable: the issue isn't specific to Haskell - in almost all languages that is true
22:21:03 <Tomsik> and memory-sharing
22:21:22 <elliottcable> ah, lists in Haskell are lls?
22:21:24 <Cale> elliottcable: The pointers pointing to the first element of the list, and the rest of the list
22:21:28 <elliottcable> I assumed arrays for some reason, and I was all confused
22:21:28 <Cale> yeah
22:21:39 <elliottcable> âk, thatâs obvious then. Itâs late o_o
22:21:41 <elliottcable> lol thanks
22:21:50 <Cale> There are arrays too
22:21:56 <Cale> But they're a separate type of course
22:22:24 <elliottcable> strings are actually linked lists of characters?
22:22:31 <elliottcable> how can that *popssibly* be feasibly âfast?â
22:22:32 <Nibble> elliottcable: indeed
22:23:00 <mtnviewmark> the type String is --- though there are other types that one can use for text processing that aren't linked lists
22:23:03 <elliottcable> is there some sort of insane optimization wherein theyâre *actually* arrays of `char`s, or are they always stored as lls of Haskellâs character-type?
22:23:23 <Nibble> elliottcable: lists vs arrays, depends on what you want to accomplish
22:23:25 <mtnviewmark> String is ALWAYS a linked list of Char
22:23:27 <Cale> elliottcable: It's not fast.
22:23:50 <Cale> elliottcable: But for simple things, it's often fast enough. When it's not fast enough, use Data.Text or Data.ByteString
22:23:51 <mtnviewmark> Data.Text and Data.ByteString are two other types that are based on arrays and so faster 
22:23:53 <Nibble> elliottcable: since haskell is practically based on lists, making strings lists makes for easy manipulation
22:23:57 <Tomsik> elliottcable: how much of processor time operations on strings can take?
22:24:12 <elliottcable> hm ok
22:24:15 <elliottcable> thanks all :3
22:24:18 * elliottcable goes back to learning
22:25:42 <Cale> The reason we like lists so much is pretty much the same reason that imperative programmers like loops
22:26:03 <Cale> Lists, along with higher order functions on them are our loops
22:26:09 <shachaf> Cale: Imperative programmers like loops?
22:26:30 <Tomsik> shachaf: what else could they possibly like?
22:26:42 <Cale> shachaf: Well, they put primitives in their languages for them!
22:27:32 <shachaf> I think it's more "view them as a necessary evil".
22:30:15 <Axman6> but, they're not a necessary evil, because we don't have them
22:31:50 <elliottcable> dude, itâs Axman6 
22:34:01 <shachaf> Axman6: They're a necessary evil in imperative languages.
22:34:17 <elliottcable> not quite
22:34:26 <elliottcable> you can do the same sort of âuse lists instead of loopsâ in an imperative language
22:34:30 <elliottcable> itâs just not usually so pretty
22:35:00 <shachaf> elliottcable: Well, you need lazy lists.
22:35:08 <Cale> It would work best if you have infinite lists, yeah :)
22:36:00 <elliottcable> well, for infinite loops, yeah, but eh
22:39:19 <Axman6> wtf is an elliottcable doing in here? :O
22:42:38 <elliottcable> Axman6 3â¼ fuckinâ with haskell. Howâs life?
22:42:54 <elliottcable> Axman6 3â¼ where do you live, again? SOmewhere in the US? Iâm in Seattle, leaving tomorrow or the next day, so if youâre on my path
22:53:25 <elliottcable> Does Haskell have a limit on numberâs sizes? Just out of curiosity, I typed `length [1..]` into `GHCi`; Iâm wondering if itâll shit brix eventually or not
22:54:07 <c_wraith> eventually your computer will run out of memory to hold the current Integer
22:54:08 <Axman6> the return type is an Int, which is a machine int... though since it's an infinite list, that won't terminate
22:54:10 <Nibble> indeed
22:54:21 <c_wraith> Axman, numeric literals default to Integer in ghci
22:54:26 <Axman6> c_wraith: it's an Int, not an Integer
22:54:26 <Nibble> yep
22:54:31 <Axman6> ah, good point
22:54:39 <Axman6> i only thought about the accumulator
22:54:55 <notabel> c_wraith: that's not relevant, the value length is computing is always an Int
22:55:01 <Axman6> elliottcable: canberra, australia ;)
22:55:04 <notabel> regardless of the element type of the list
22:55:20 <c_wraith> notable: calculating the next element of the list will take ever-growing size
22:55:28 <c_wraith> very, very slowly growing
22:55:42 <Axman6> notabel: [a..] will eventually produce very large integers
22:55:48 <Axman6> and, time to go
22:55:50 <Axman6> o/
22:56:23 <elliottcable> lol âta
22:56:53 <notabel> Axman6: anyway, it will loop forever, because signed overflow is unsignalling in Haskell
22:56:57 <c_wraith> like, in some thousands of years, the size of the list elements might exceed your memory.
22:57:09 <c_wraith> Maybe millions of years.
22:57:18 <c_wraith> But for all practical purposes, it'll just sit there forever
22:57:28 <notabel> so the limited size of the Int type won't keep it from going past 2^32 or 2^64 element
22:57:33 <c_wraith> no
22:57:48 <c_wraith> > (maxBound :: Int) + 1
22:57:49 <lambdabot>   -9223372036854775808
22:57:59 <notabel> if haskell had signalling overflow, then length would choke on lists with more than maxBound elements
22:58:06 <c_wraith> It just silently wraps to negative
22:58:21 <notabel> exactly.  signed overflow is unsignalling in Haskell, just like i said
22:59:17 <c_wraith> notabel, my point was that it will theoretically die, because each element in the list gets bigger and bigger.  But that's so slow it's not really a practical concern
23:04:13 <lucca> :t genericLength
23:04:13 <lambdabot> forall b i. (Num i) => [b] -> i
23:07:47 <ologNation> What's the best way to get a list of words from comma-separated values
23:07:48 <ologNation>  ?
23:08:21 <Veinor> do you have to deal with words that might have commas in them?
23:08:55 <Veinor> and therefore have to escape commas?
23:15:26 <ologNation> Veinor, No.  I don't think I'll worry about escape commas just now. 
23:15:34 <ologNation> That's a good question though. 
23:15:48 <ologNation> I'm looking for a simple function , maybe called split
23:15:51 <Veinor> then Data.List.Split.splitOn ","
23:15:54 <ologNation> split :: String ...
23:15:57 <Veinor> in the package split
23:15:57 <ologNation> Oh, you got it. 
23:16:02 <ologNation> cool. 
23:16:06 * ologNation is googling for docs
23:16:26 <Veinor> http://hackage.haskell.org/packages/archive/split/0.1.2/doc/html/Data-List-Split.html#v%3AsplitOn
23:29:33 <ski> > (maxBound :: Word) + 1  -- unsigned overflow is also unchecked
23:29:34 <lambdabot>   0
23:46:13 <etpace> @hoogle on
23:46:13 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
23:46:13 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
23:46:13 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
