00:05:52 <Zeiris> Suppose you were writing a MUD in Haskell. String, ByteString, or DList?
00:06:19 <Zeiris> And are there libraries/methods for nicely handling large amounts of template-like text? (Filling in fields based on identifiers, or some other template system.)
00:10:20 <blackdog> Zeiris: hamlet is pretty nice for templating
00:10:31 <blackdog> specialised for html, though
00:11:11 <blackdog> and string/bytestring/dlist is not really a well-defined question :) it's usually bad to use strings for anything that could be remotely performance sensitive
00:14:52 <Zeiris> Well, something like a MUD is a fairly well-defined problem where you spend a lot of time generating text. So String's probably out.
00:16:07 <blackdog> is it web-based?
00:18:23 <Zeiris> blackdog, in a sense, since it's generally accessed via telnet, but plain text rather than HTML. Possibly with minor colour markup.
00:19:05 <blackdog> well, that's more the net than the web:)
00:19:20 <Ferdirand> but it's text that is destined to be processed by a human
00:19:26 <Ferdirand> is String really that slow ?
00:20:05 <blackdog> it's a lot slower than bytestring, but people write big systems in ruby :)
00:20:36 <robertmassaioli> Are there any string/bytestring benchmarks somewhere?
00:21:22 <blackdog> but really, i think you're focusing on the wrong problem
00:21:51 <blackdog> you can always optimise later - just write it as clearly and simply as you can
00:22:47 <robertmassaioli> Agreed 'just do it' and if there's a problem rethink it. You'll probably find it works out just fine. :)
00:23:16 <blackdog> http://www.serpentine.com/blog/2009/12/10/the-performance-of-data-text/
00:32:10 <Zeiris> Ruby strings are linked lists??
00:33:24 <blackdog> Zeiris: no
00:33:32 <blackdog> but the interpreter itself is shockingly slow.
00:33:44 <blackdog> it just doesn't matter, most of the tiem.
00:56:44 <Zeiris> How would a common OOP design be translated to Haskell? Like a naval combat simulator, where there are different weapons. Some of those are torpedoes, which have additional behaviours. There's various clear subclasses of torpedoes, airdropped/surface/underwater, with individual behaviours. There's further subclasses within those subclasses... And similar class trees for all other, non-torpedo weapons etcetera.
00:57:19 <Zeiris> The obvious and fairly elegant OOP representation is a class hierarchy. Typeclasses seem like the thing in Haskell, but I remember reading that modeling OOP type hierarchies with typeclasses led to pain...
00:58:34 <Associat0r> http://www.haskell.org/haskellwiki/Existential_type#Dynamic_dispatch_mechanism_of_OOP
01:03:50 <Zeiris> ...That's what I get for asking questions, everybody quits!
01:04:11 <Raynes> NETSPLEEEEEET
01:20:15 <hape_> >76
01:22:58 <Phyx->  hello
01:40:20 <sykora> Hello, I'm just starting to use quickcheck to test my code, and I've got a pretty fundamental question: Which version of quickcheck should I use?
01:43:01 <medfly> what's the most straightforward way to save data for later use by Haskell?
02:12:53 --- mode: kornbluth.freenode.net set +o ChanServ
02:16:49 <aRcatan> how to read all the stdin before using it? that is, i need strict getContents
02:17:53 --- mode: kornbluth.freenode.net set +o ChanServ
02:18:31 <Botje> (\x -> length x `seq` x) `fmap` getContents
02:21:58 <aRcatan> Botje, thanks!
02:35:42 --- mode: kornbluth.freenode.net set +o ChanServ
02:36:52 <jozi> I found this function useful for curried functions: dot' f g x = f . g x . Does it have a specific name?
02:37:19 <medfly> ?
02:37:34 <medfly> @src (.)
02:37:34 <lambdabot> (f . g) x = f (g x)
02:37:34 <lambdabot> NB: In lambdabot,  (.) = fmap
02:38:42 <medfly> > ((.) (+2) (+3)) 3
02:38:43 <lambdabot>   8
02:38:47 <jozi> black :: Solution -> Guess -> Int
02:38:48 <jozi> black = countTrue `dot` isWhite
02:38:48 <jozi>         where dot f g x = f . g x
02:38:48 <jozi>  
02:40:04 <jozi> You can't just say: "black = countTrue . isWhite", since isWhite :: [Int] -> [Int] -> [Bool].
02:41:44 <ziman> @pl dot' f g x = f . g x
02:41:45 <lambdabot> dot' = (.) . (.)
02:41:53 <ziman> oh
02:42:17 <ziman> i've seen it usually called (.:) and it's not in the standard libs :)
02:42:58 <medfly> guess I misunderstood it :/
02:43:00 <ziman> there's even a blogpost somewhere, discussing this "lifting" of (.)
02:43:31 <ziman> (for more general cases of more-ary functions)
02:44:18 <Baughn> @pl f g x y = f (g x y)
02:44:18 <lambdabot> f = fix ((.) . (.))
02:44:37 * Baughn *stares*
02:44:56 <Saizan> @pl h f g x y = f (g x y)
02:44:56 <lambdabot> h = (.) . (.)
02:46:52 <Baughn> @type ((.) . (.))
02:46:53 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:46:58 <Baughn> ..oh you
02:47:09 <Baughn> @type fix ((.) . (.))
02:47:09 <lambdabot>     Occurs check: cannot construct the infinite type: a = f1 (f a)
02:47:10 <lambdabot>       Expected type: a
02:47:10 <lambdabot>       Inferred type: f1 (f a)
02:47:34 <Baughn> @pl dot f g x y = f (g x y)
02:47:35 <lambdabot> dot = (.) . (.)
02:47:50 <yitz> ziman: usually? I've *never* seen the "owl eyes" function called (.:)
02:47:50 * Baughn facepalms
02:48:26 <Saizan> "owl eyes", nice euphemism
02:48:41 <Zao> Check out the owl eyes on that bird!
02:48:41 <yitz> ziman: in fact, I use (.:) all the time to construct time values, hr .: min
02:48:59 <medfly> @type (.:)
02:49:00 <lambdabot> Not in scope: `.:'
02:49:00 <yitz> Saizan: yeah, there's another common name that' more rude
02:49:02 <medfly> ?
02:49:08 <ziman> yitz, well it obviously depends on what you've been exposed to and maybe also some positive bias :)
02:49:39 <Saizan> yitz: (.:) got proposed as a name a while back, but since no one actually went and defined ((.) . (.)) as a single combinator anywhere popular..
02:50:35 <yitz> I would oppose that name since it is a natural name for other things
02:51:04 <medfly> what's so natural about it?
02:51:31 <Saizan> don't you have to use (:.) for constructors?
02:51:42 <yitz> medfly: it's the visually shortest legal operator name that looks like (:)
02:52:51 <yitz> medfly: so it's the first thing you would choose for any natural use of (:) other than list constructor. e.g., constructing times.
02:53:38 <yitz> Saizan: well yeah, if I want it to be a direct constructor I use :., if I want it to be a function I use .:
02:53:54 * yitz refrains from putting a period at the end of that sentence ^^
03:39:46 <Jonno_FTW> @src permutations
03:39:46 <lambdabot> Source not found. stty: unknown mode: doofus
03:57:30 <danportin> I am writing a function <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29277#a29277>, and realized I will run into an error situation: I might end up taking 'tail []
03:57:34 <danportin> ', 'head []
03:58:21 <danportin> , etc.. I can work around this, but is there a more elegant way to perform the operations in 'transition' than cluttering up the code with exceptional cases?
04:00:37 <SubStack> writing elegant code is hard
04:00:55 <SubStack> and reality is messy
04:01:50 <Jafet> If your code was a lot messier than that, it might justify using a non-throwing head, or something
04:01:56 <danportin> It shouldn't be :)
04:02:23 <Jafet> Then you wouldn't be able to distinguish the ambiguous input case. Moral: suck it up
04:02:38 <danportin> Good moral.
04:07:30 <Jafet> You can also use Either, but with the same caveat
04:08:10 <zygoloid> danportin: i'd use pattern guards, like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29277#a29279
04:09:40 <Jafet> Best error message ever.
04:13:55 <danportin> Cool, zygoloid - I didn't realize guards were allowed in case expressions. Something like this <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29277#a29280> is legal, then?
04:14:13 <jrockway> i love bash: http://paste.scsys.co.uk/48578
04:14:41 <temoto> may i somehow mix case and guards?
04:14:50 <danportin> This is a terrible way to represent an infinite tape, too. I feel like I just angered the 'epistemological gods'.
04:15:01 <zygoloid> danportin: sure, except that 'h' is not defined in the second clause there
04:15:10 <zygoloid> also, why not just use an infinite list?
04:15:51 <zygoloid> danportin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29277#a29282
04:16:48 <temoto> I have this     case parse plain_string "" arg of { Left _ -> Nothing; Right s -> if s == arg then ... else ... }   and i wonder if i could replace 'if' with guards near Right s
04:19:42 <danportin> In the last one (while it is certainly cleaner), I'd still have to deal with empty list cases. But it is certainly cleaner, and I could check for [] outside the main body of the function. 
04:19:59 <danportin> I'd have to read more on working with infinite lists, so perhaps I should do that.
04:21:46 <tolkad> In GHC, is there a pragma to just include all the extensions?
04:22:18 <danportin> But I suppose I could generate lists for an initial state, e.g., [blank, blank..], then cut them off with a pretty printing function.
04:24:11 <tolkad> uh btw, are there any extensions I should avoid?
04:27:35 <jrockway> there are extensions that can affect the compilation of your program
04:27:45 <jrockway> rank-n types, undecidable instances
04:27:58 <jrockway> these, in the general case, remove the ability to prove that type checking halts
04:28:10 <jrockway> in specific cases, though, they are quite useful
04:28:14 <jrockway> so turn them on when you need them
04:28:24 <tolkad> is it bad to just turn on everything?
04:28:46 <jrockway> i would say so
04:28:56 <jrockway> if you are using a strange feature, you should scope it only to the file that needs it
04:29:14 <jrockway> so you can open the file and see what strange things the file is doing
04:29:23 <jrockway> some things might be good to universally enable though
04:29:28 <tolkad> why does {-# OPTIONS -fglasgow-exts -#} exist?
04:29:32 <jrockway> NoMonomorphismRestriction, OverloadedStrings
04:29:36 <jrockway> legacy
04:30:08 <tolkad> I wonder what would happen if you put something like --make in there
04:30:26 <jrockway> let's see :)
04:30:53 <jrockway> unknown flag in  {-# OPTIONS #-}"
04:31:00 <tolkad> heh, indeed
04:31:23 <jrockway> ghc is clearly Smarter Than You
04:31:47 <jrockway> what if i *want* my file to print out ghc's --help message when compiled? ;)
04:33:28 <tolkad> what if I *want* to use -o to overwrite system files
04:34:17 <tolkad> interesting, it doesn't complain
04:34:21 <jrockway> haha
04:34:33 <jrockway> theoretically you don't have permission to overwrite files
04:35:14 <medfly> what's a simple way to store data for later use by Haskell?
04:35:15 <tolkad> it doesn't actually use it, just ignores it
04:35:23 <tolkad> what? you don't run GHC as root?
04:35:58 <tolkad> haha {-# OPTIONS -v #-} works
04:40:31 <tolkad> interesting, {-# OPTIONS -cpp #-} works, that's good to know
04:41:08 <Saizan> {-# LANGUAGE CPP #-}
04:42:55 <tolkad> oh, I guess that would be preferable. When it says it runs the CPP preprocessor it really means it, it does not like it when I do #include <stdlib.h>
04:44:09 <jrockway> lol
04:45:11 <quicksilver> medfly: A simple way is Show/Read instances.
04:45:17 <quicksilver> medfly: a faster way is binary or cereal.
04:46:01 <PeakerWork> > iterate (*2) 1
04:46:02 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
04:46:56 <medfly> ?
04:47:07 <medfly> Show/Read instances?
04:58:13 <ivanm> @. elite protontorpedo
04:58:13 <lambdabot> 5o iz |-|4SkEL1 9oiNG t0 R3D0 x wInDoW$ and m4ke it BeTTER?
04:59:47 <quicksilver> medfly: yes. Show the data to a file, Read it from a file.
05:03:25 <Sadache> what is the best type of set for intersection in terms of performance?
05:03:33 <medfly> ok. thx
05:04:14 <copumpkin> Sadache: a bitfield :)
05:05:28 <Sadache> I am talking about sets of Strings
05:05:55 <ivanm> Sadache: what else are you wanting to do with it?
05:06:01 <ivanm> and what are you going to be using it for?
05:06:39 <Sadache> ivanm: I load elements into it only once, so no add or delete after that
05:07:01 <Sadache> keeping order is a plus
05:07:03 <ivanm> but you want to be able to find the intersection of two sets?
05:07:11 <ivanm> OK, a bloom filter might be out...
05:07:14 <Sadache> ivanm:  yes
05:07:25 <ivanm> you do realise that intersection is going to be expensive?
05:07:54 <Sadache> ivanm: I am going to do it a lot of times
05:08:16 <copumpkin> if you're going to be doing a lot of intersection and not much querying, I stand by my original suggestion :P
05:08:26 <ivanm> copumpkin: on Strings?
05:08:42 <ivanm> comparing Strings is going to be expensive
05:08:55 <Sadache> ivanm: I have a list of lists, and I need to sort it. For sorting it i need to intersect the sub lists
05:08:57 <ivanm> using Text or even ByteString might be cheaper, but probably not by much
05:08:58 <copumpkin> why would that make a difference? you need a mapping from strings to indices, and then you store your sets as integers
05:09:09 <ivanm> Sadache: why do you need to do that to sort it?
05:09:16 <ivanm> copumpkin: oh, a Map-backed Set?
05:09:36 <copumpkin> yeah, the map lets you query membership, and then you just & the underlying Integer for intersection
05:09:37 <ivanm> Sadache: why not just use the sort function? :p
05:09:50 <ivanm> copumpkin: that of course requires you're using a canonical mapping...
05:09:53 <ivanm> like say a hash
05:10:06 <ivanm> dammit, don't tell me I'm advocating a hash-table...
05:10:07 <ivanm> ;-)
05:10:08 <copumpkin> not necessarily, but you need to be consistent
05:10:12 <Sadache> yes, but I need to tell sort how to sort my elements, right?
05:10:22 <zygoloid> if all you want is intersection, data FastIntersectionSet = FIS; intersect FIS FIS = FIS ;-)
05:10:33 <baaba_> @pl f g x = g x x
05:10:34 <lambdabot> f = join
05:10:45 <ivanm> zygoloid: heh, I was thinking of just cheating and making intersection an && on member ;-)
05:11:01 <ivanm> Sadache: if you're just using String, then there's already a sort function for that...
05:11:10 <ivanm> or else if you want a specific comparison use sortBy
05:11:22 <ivanm> are you trying to do a really weird merge sort or something?
05:11:32 <Sadache> ivanm: no I have a list of lists of strings
05:12:06 <jrockway> and you want to fold that down to all the common members?
05:12:29 <ivanm> oh, basically foldr1 intersect ?
05:12:42 <Sadache> and to compare two lists of strings, I need to intersect each with a third predifined list of strings, and take the one that shares more with it
05:13:04 <ivanm> huh
05:13:26 <jrockway> for efficiency, i like the map -> ints idea
05:13:27 <Sadache> and get a sorted list of lists of strings
05:13:29 <ivanm> Sadache: well, your best bet is to probably either use plain ol' Set
05:13:33 <jrockway> for ease of implementation, just data.set first and profile later
05:13:48 <ivanm> or else to do some kind of canonical String -> Int or something (e.g. a hash) and then do intersections using that
05:13:53 <ivanm> jrockway: agreed
05:14:00 <benmachine> ok, so sort each list internally, and then you can calculate the amount of intersection with the main list in a single traversal
05:14:25 <benmachine> wait no
05:14:34 <benmachine> just... do it the obvious way
05:14:44 <benmachine> you don't need to do lots of intersections
05:14:52 <benmachine> just one for each element of the list?
05:15:17 <ivanm> benmachine: he wants to sort by the number of common elements
05:15:20 <ivanm> hmmm....
05:15:22 <Sadache> this means I need to do a map first right?
05:15:31 <benmachine> ivanm: yes but common *with a third constant list*
05:15:33 <ivanm> sortBy (compare `on` (length . intersect foo)) ?
05:15:50 <benmachine> ivanm: schwarzian transform is better
05:15:50 <ivanm> use a schwarzian transform for efficiency
05:15:53 <benmachine> or however you spell it
05:15:55 <Sadache> ivanm: yes
05:15:59 <ivanm> benmachine: yes, I was making it more explicit first ;-)
05:16:07 <jrockway> seems more like a fold than a sort if you only need the best
05:16:19 <jrockway> accumulate (score, list-of-strings)
05:17:01 <Sadache> jrockway: no i need the 10 best actually
05:17:16 <jrockway> ok
05:17:26 <jrockway> just do what ivanm said :)
05:17:32 <jrockway> worry about making it faster after your program actually works
05:18:06 <Sadache> jrockway: the problem is the intersection is done each time you compare two elements right?
05:18:16 <jrockway> yes
05:18:19 <jrockway> it is not the ideal algorithm
05:18:25 <ivanm> you'd probably want to use Set.intersect rather than the list one, but anyway
05:18:28 <jrockway> presumably there is more to your program than just this
05:18:33 <jrockway> get something working, then make it fast
05:18:38 <ivanm> Sadache: hence the schwarzian transform
05:19:05 <jrockway> (fun profiling story: i rewrote my string- and list- heavy app to use bytestrings and vectors, and it did speed things up a little, but the real slowness was (encodeFloat . decodeFloat :: CDouble -> Double))
05:19:18 <Sadache> ok i ll look at that, but no idea whether hashset is better than treeset in this case?
05:19:32 <jrockway> (that conversion took about 66% of the program's time)
05:19:42 <Twey> Yow
05:19:43 <eikke> any gtk2hs dev in here?
05:19:57 <Sadache> jrockway: wow, really unpredictable!
05:20:43 <jrockway> makes sense if you think about it, Double -> Integer and Integer -> Double is not going to be as fast as a nop
05:20:53 <jrockway> but you don't think about that while you are writing the program, which is why you write it and then profile it :)
05:21:09 <ivanm> jrockway: why were you using encodeFloat and decodeFloat?
05:21:23 <ivanm> @hoogle CDouble -> Double
05:21:24 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
05:21:24 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:21:24 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
05:21:36 <jrockway> that's why
05:22:01 <jrockway> i eventually use the doubles as realfrac (because the library giving me the data is stupid and represents integers as doubles)
05:22:12 <jrockway> so i just kept it as cdouble until the conversion to rational
05:22:28 <quicksilver> jrockway: realToFrac :: CDouble -> Double should be a NOP.
05:22:42 <quicksilver> and in many cases compiled away entirely.
05:22:42 <ivanm> jrockway: what's why?
05:23:11 <Sadache> anyway, thank you for the help
05:23:34 <jrockway> realToFrac didn't sound like what i wanted, is why
05:23:40 <jrockway> it's realToReal
05:24:00 <jrockway> similar to the reason why people say "there's no way to join a string with strings in haskell"
05:24:07 <jrockway> because they search for "join", not "intercalate" :)
05:24:12 <quicksilver> you should have asked hoogle :)
05:24:25 <quicksilver> @quote realToFrac
05:24:25 <lambdabot> No quotes match. Just what do you think you're doing Dave?
05:24:30 <ivanm> as in the _real_ hoogle, not lambdabot's cut-down version!
05:24:34 <zygoloid> @hoogle String -> [String] -> String
05:24:34 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
05:24:35 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
05:24:35 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
05:24:40 <ivanm> and how does realToReal differ from realToFrac?
05:24:45 <zygoloid> hoogle finds intercalate easily enough :)
05:24:46 <quicksilver> it doesn't exist.
05:24:56 <quicksilver> jrockway is just pointing out the name 'realToFrac' is surprising.
05:25:08 <quicksilver> the reason, of course, is that realToFrac isn't restricted to reals, in fact.
05:25:21 <quicksilver> > (realToFrac (2.0 :: Double)) :: Complex Double
05:25:22 <lambdabot>   2.0 :+ 0.0
05:25:32 <jrockway> yeah
05:25:38 <jrockway> that is neither real, nor a fraction
05:25:53 <quicksilver> complex double is 'Fractional' in the haskell sense
05:25:57 <benmachine> it's *kind* of fractional
05:26:00 <zygoloid> jrockway: Fractional just means 'has division'
05:26:05 <quicksilver> although the type classes are strangely named
05:26:09 <quicksilver> (hard to name, though)
05:26:14 <benmachine> depending on what you think of as a fraction
05:26:30 <jrockway> you guys are missing the point of my story though
05:26:39 <jrockway> you are not going to write perfect code the first time through
05:26:41 <Jafet> @hoogle Rational
05:26:41 <lambdabot> Prelude type Rational = Ratio Integer
05:26:41 <lambdabot> Data.Ratio type Rational = Ratio Integer
05:26:42 <lambdabot> Text.PrettyPrint.HughesPJ rational :: Rational -> Doc
05:26:48 <benmachine> and the profiler knows better than you
05:26:56 <jrockway> yeah
05:27:09 <jrockway> a "slow" function is not slow if you only call it once a day
05:27:13 <quicksilver> right.
05:27:58 <Philonous> jrockway: Unless it takes more than 24h to complete. 
05:28:27 <benmachine> ...yes
05:28:38 <benmachine> pedant :P
05:28:42 <zygoloid> if it takes an hour to do something which could be done in a second, it could still be far too slow
05:29:17 <benmachine> look it's just a nice expression ok you don't have to take it literally :(
05:30:12 <zygoloid> in our product there are functions which we only call once per run. sometimes they have perf bugs which means they run for hours. that's a big deal.
05:30:26 <jrockway> you need smaller functions
05:30:42 <zygoloid> jrockway: and then what? never call them?
05:31:01 <jrockway> anyway, while we are on the subject
05:31:15 <jrockway> what's the best way to zip an unboxed (or storable) vector with a boxed one?
05:31:29 <jrockway> obviously it becomes boxed after the zip, but there seems to be a manual conversion step required to make the types work
05:38:05 <itayd> > 1+1
05:38:06 <lambdabot>   2
05:38:10 <itayd> nice! :)
05:38:26 <medfly> heh
05:38:41 <Jafet> > let 2 + 2 = 5 in 2 + 2
05:38:42 <lambdabot>   5
05:38:55 <Starfire> What is the best way to convert from CReal to Double?
05:39:06 <Starfire> realToFrac throws an exception.
05:39:18 <jrockway> haha
05:41:23 <itayd> q
05:43:09 <itayd> @djinn a -> a
05:43:09 <lambdabot> f a = a
05:44:30 <rossputin> Hi guys, newb here looking for a little help with typeclasses
05:46:17 <Lemmih> rossputin: Yes?
05:47:25 <rossputin> can I somehow define more than one instance of a typeclass working with the same Type, to be able to get new behaviour in a function implementation for that type...
05:47:44 <rossputin> for example:
05:47:44 <copumpkin> use newtype
05:48:11 <copumpkin> > Sum 5 ++ Sum 7
05:48:12 <lambdabot>   Ambiguous occurrence `Sum'
05:48:12 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
05:48:13 <rossputin> ok thanks, I will go look that up :-)
05:48:16 <copumpkin> ugh
05:48:23 <copumpkin> > Data.MonoidSum 5 ++ Data.Monoid.Sum 7
05:48:24 <lambdabot>   Not in scope: data constructor `Data.MonoidSum'
05:48:26 <copumpkin> > Data.Monoid.Sum 5 ++ Data.Monoid.Sum 7
05:48:27 <lambdabot>   Sum {getSum = 12}
05:48:35 <copumpkin> > Data.Monoid.Product 5 ++ Data.Monoid.Product 7
05:48:36 <lambdabot>   Product {getProduct = 35}
05:49:48 <Lemmih> rossputin: You have to define a new type which the 'newtype' keyword can help with.
05:49:59 <Starfire> :t (++)
05:50:00 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:50:14 <ski> @type (Prelude.++)
05:50:15 <lambdabot> forall a. [a] -> [a] -> [a]
05:50:21 <Starfire> Where does that (++) come from?
05:50:22 <ski> @type mappend
05:50:23 <lambdabot> forall a. (Monoid a) => a -> a -> a
05:50:28 <ski> Starfire : ^
05:50:33 <ski> @index mappend
05:50:34 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
05:50:42 <medfly> Caleskell
05:51:02 <baaba_> > 1 ++ 1
05:51:03 <ski> (also Haskell 1.4, iirc)
05:51:03 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:51:03 <lambdabot>    `Data.Monoid.Monoid a'
05:51:04 <lambdabot>  ...
05:51:18 <ski> > 1 ++ 1 :: Int  -- error
05:51:19 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
05:51:19 <lambdabot>    arising from a use of...
05:51:37 <Starfire> Is there some package that defines (++) = mappend ?
05:51:54 <baaba_> i guess there's no way to make it disambiguate in some scope
05:52:02 <ski> Starfire : not that i know. you can do it yourself, if you want
05:52:05 <ivanm> Starfire: yes
05:52:09 <ivanm> but it isn't ready yet
05:52:15 * ivanm is currently re-writing container-classes
05:52:54 <ski> ivanm : so `(++)' for monoids there ? or for containers ?
05:53:14 <ivanm> ski: containers, but containers have to be monoids
05:53:27 <ski> yeah, i just wondered about the generality
05:53:30 * ivanm isn't sure whether he's going to keep that Monoid c => Container c requirement in this new version
05:53:50 <ivanm> since people bitched about the all-in-one typeclass aspect of it
05:54:02 <ivanm> ski: well, I'm currently doing it by duplicating Functor, Foldable, etc.
05:54:08 <ski> (sometimes, it could be useful to allow containers which can't be empty .. i'm not sure how much worth it would be, though)
05:54:12 <ivanm> so I might do that for all Monoids then
05:54:25 <ivanm> ski: yeah, that's the big thing; someone wanted to be able to do a non-empty list with it
05:54:40 <ivanm> this splitting up of typeclasses means that a lot of default definitions are being lost though
05:54:50 <ski> *nod* :/
05:54:58 <ivanm> e.g. I had a default definition for map/fmap; with the type-classes being split I don't have that any more :s
05:56:22 <benmachine> are there monoids which aren't containers which you might like to use ++ on?
05:56:45 <eikke> benmachine: Product? :P
05:57:06 <ivanm> benmachine: well, the point of my original version was to duplicate and generalise all list functions (except string-only ones) in the Prelude + some from Data.List
05:57:23 <ivanm> but in general, I don't think it makes sense to use ++ for Sum, Product, etc.
05:57:58 <benmachine> why not
05:58:13 <ivanm> because to me ++ is too tied in with appending
05:58:25 <ivanm> even the name "mappend" doesn't make much sense IMHO
05:58:29 <ivanm> > (Sum 4) `mappend` (Sum 5)
05:58:30 <lambdabot>   Ambiguous occurrence `Sum'
05:58:30 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
05:58:34 <ivanm> bah
05:58:40 <benmachine> ++ is two plus symbols :P
05:58:40 <ivanm> > (Product 4) `mappend` (Product 5)
05:58:41 <lambdabot>   Product {getProduct = 20}
05:58:42 <ski> yeah, the name `(++)' is better than `mappend'
05:58:55 <benmachine> it makes even more sense for Sum than it does lists, arguably :)
05:59:04 <earthy> ;)
05:59:04 <eikke> > (Product 4) ++ (Product 10)
05:59:04 <ivanm> benmachine: possibly
05:59:05 <lambdabot>   Product {getProduct = 40}
05:59:09 <ivanm> but for product?
05:59:15 <ivanm> @hoogle Sum
05:59:15 <lambdabot> Data.Monoid newtype Sum a
05:59:15 <lambdabot> Data.Monoid Sum :: a -> Sum a
05:59:16 <lambdabot> Prelude sum :: Num a => [a] -> a
05:59:18 <eikke> got to love that one
05:59:21 <benmachine> ivanm: sure, why not
05:59:28 * geheimdienst when he first read "mappend" thought it was some kind of map append thing, similar to mapconcat
05:59:29 <ivanm> OK, so which other Sum was lambdabot confused with?
05:59:37 <ivanm> geheimdienst: heh
05:59:45 <ski> well .. i suppose one might argue that `(++)' should be reserved for *commutative* monoids ..
06:00:05 <geheimdienst> > (Sum 1) `mappend` (Sum 2)
06:00:07 <lambdabot>   Ambiguous occurrence `Sum'
06:00:09 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
06:00:10 <geheimdienst> @more
06:00:17 <jrockway> @fail
06:00:18 <lambdabot> Maybe you meant: fact faq
06:00:20 <ski> (not that product over integers aren't commutative .. but that's common math convention)
06:00:37 <geheimdienst> what's the command for reading the rest of the error?
06:00:38 <int-e> lambdabot knows Data.AdditiveGroup.Sum and Data.Monoid.Sum
06:00:54 <ivanm> geheimdienst: should be @more
06:01:00 <ivanm> int-e: what's Data.AdditiveGroup?
06:01:02 <geheimdienst> more no worky
06:01:22 <jrockway> > (First $ Just 42) ++ (First $ Just 1)
06:01:23 <lambdabot>   First {getFirst = Just 42}
06:01:29 <jrockway> > (First $ Just 1) ++ (First $ Just 42)
06:01:30 <lambdabot>   First {getFirst = Just 1}
06:01:34 <ivanm> :o
06:01:41 <int-e> http://hackage.haskell.org/package/vector-space/
06:01:46 <ivanm> I'm guessing that's the whole point of First?
06:02:32 <int-e> > mempty ++ First $ Just 1
06:02:33 <lambdabot>   First {getFirst = Just 1}
06:02:47 <jrockway> Nothing `mplus` (Just 42)
06:02:49 <jrockway> > Nothing `mplus` (Just 42)
06:02:50 <lambdabot>   Just 42
06:02:53 <int-e> > mempty `astypeof` First 1
06:02:53 <lambdabot>   Not in scope: `astypeof'
06:03:11 <int-e> > mempty `asTypeOf` First 1
06:03:12 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
06:03:12 <lambdabot>    arising from a use of...
06:03:28 <jrockway> > mempty `asTypeOf` (First $ Just 1)
06:03:29 <lambdabot>   First {getFirst = Nothing}
06:03:40 <ski> > (mempty ++ First) (Just 1)
06:03:41 <lambdabot>   First {getFirst = Just 1}
06:03:45 <jrockway> Last seems more interesting
06:03:57 <int-e> ah.
06:04:18 <jrockway> > mconcat $ (Last <$> repeat Nothing)
06:04:19 <lambdabot>   Last {getLast = *Exception: stack overflow
06:05:34 <ivanm> hmmm, does it make sense to ask if a bloom filter is empty?
06:08:58 <ski> hm, you can ask whether an item is in a bloom filter set, and get either "possibly" or "no" as an answer, is that right ?
06:09:22 <zygoloid> ski: yeah.
06:09:25 <zygoloid> it's more "probably" though
06:10:04 <zygoloid> ivanm: yes, that makes sense.
06:10:14 <ski> so, it would seem to me that asking whether a bloom filter is empty would answer either "definitely", or "maybe" as an answer
06:11:05 <ski> (in case of "definitely" that would then imply that every item is not in the bloom filter)
06:11:19 <ivanm> OK, why does ghci bitch about this? class (Mappable (c v) v, Suitable c v) => Functor c where
06:11:19 <zygoloid> well, with a normal bloom filter, there's no way to remove elements, and all of the bitmaps will be all-zeroes iff no element has ever been added
06:11:23 <EvanR> > (3 :: CReal) == (4 :: CReal)
06:11:24 <zygoloid> so it's a yes/no thing
06:11:24 <lambdabot>   False
06:11:27 <ivanm> it says: Data/Restricted/Functor.hs:18:19: Not in scope: type variable `v'
06:11:27 <EvanR> > (3 :: CReal) == (3 :: CReal)
06:11:28 <lambdabot>   True
06:11:36 <EvanR> > (pi :: CReal) == (pi :: CReal)
06:11:37 <lambdabot>   True
06:11:39 <ivanm> zygoloid: right
06:11:40 <EvanR> ._.
06:11:41 <ski> zygoloid : yeah, i was just about to ask about removal :)
06:11:51 <ivanm> EvanR: it cheats by only going to 20 decimal places or something
06:11:59 <EvanR> ah
06:12:06 <zygoloid> even with a counting filter, it's still a yes/no thing, unless one of the buckets has gone overfull
06:12:14 <ivanm> > (3 :: CReal) == (3 + 10^(-10000000000000000))
06:12:15 <lambdabot>   *Exception: Negative exponent
06:12:23 <ivanm> > (3 :: CReal) == (3 + 10**(-10000000000000000))
06:12:29 <lambdabot>  Terminated
06:12:31 <ivanm> bah
06:12:40 <EvanR> "I'll be back"
06:12:58 <EvanR> arnold got yer evaluation
06:13:28 <zygoloid> is there a conventional name for a monad transformer equipped with fmapT :: (m a -> m b) -> t m a -> t m b ?
06:13:38 <EvanR> > (3 :: CReal) == (3 + 10**(-1000))
06:13:39 <lambdabot>   True
06:13:41 * zygoloid is calling it MonadTransFunctor but that seems awkward
06:13:52 <ski> ivanm : ambiguity ? which `v' should it choose ?
06:14:08 <ski> .. er, you had `class', not `instance'
06:14:34 <rossputin> hi... still a little stuck with this typeclass thing...
06:14:36 <zygoloid> (more generally: fmapT :: (m a -> n b) -> t m a -> t n b ... but i suspect this is equivalent for an appropriately-chosen m)
06:14:37 <rossputin> if I have:
06:14:40 <ivanm> ski: right, but I have a fundep in Stores
06:14:42 <rossputin> class CalculationEngine a where
06:14:43 <rossputin>     calculate :: a -> Int
06:14:46 <ivanm> even adding a fundep to Mappable doesn't fix it
06:14:47 <rossputin> and
06:14:53 <rossputin> instance CalculationEngine CalculableEntity where
06:14:53 <rossputin>     calculate (CalculableEntity  a b) = a + b
06:15:07 <geheimdienst> MonadTransFunctor -> Motrafu
06:15:12 <rossputin> but I also want a new instance.. working on the same type, something like :
06:15:13 <zygoloid> haha nice
06:15:16 <geheimdienst> ... nice ring to it
06:15:19 <ivanm> hang on, are language extensions meant to be transitive?
06:15:19 <rossputin> instance CalculationEngine CalculableEntity where
06:15:19 <rossputin>     calculate (CalculableEntity a b) = (2 * a) + (2 * b)
06:15:24 <rossputin> how do I do that ?
06:15:26 <ski> zygoloid : well, there's also `tmap :: (forall a. m a -> n a) -> (t m a -> t n a)'
06:15:39 <ivanm> rossputin: you can't have one type, two instances
06:15:53 <ivanm> you have to use a newtype wrapper around the type to get that
06:16:05 <rossputin> sorry, yes, thats the bit I can not figure out
06:16:12 <rossputin> I am reading the docs now
06:16:34 <zygoloid> ski: is that a standard thing?
06:16:52 <ivanm> ski: I have "class (Stores (c v) v) => Suitable c v where" which works
06:17:03 <ski> rossputin : probably you'll want two different `newtype's, since one of them doesn't seem to be more "canonical" than the other
06:17:14 <ivanm> dammit, it wants the v as a class parameter
06:17:15 <ski> zygoloid : i don't think so .. but i think it's useful
06:17:33 <ivanm> when all I wanted it for was to maintain the congruence between kind * and kind * -> *
06:17:36 <ivanm> *sigh*
06:17:51 <int-e> @type foldr (\a b -> (:) <$> a <*> b) (pure [])
06:17:51 <lambdabot> forall (f :: * -> *) a. (Applicative f) => [f a] -> f [a]
06:17:54 * ivanm bangs his head against a convenient solid surface
06:17:59 <int-e> @hoogle sequenceA
06:18:00 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
06:18:00 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
06:18:08 <ski> zygoloid : e.g. say you want to go from `StateT s m a' to `StateT s (ParserT m) a' .. or something like that
06:19:26 <ivanm> if there's "class Foo c v | c -> v", why wouldn't "class (Foo (c v) v) => Bar c" work?
06:19:28 <zygoloid> my specific case is lifting an f :: IO a -> IO a into t IO a -> t IO a.
06:19:41 <ski> zygoloid : when you `tmap' over `StateT s' the `a' in `(forall a. m a -> n a)' will not be the `a' in `t m a -> t n a', but rather `(a,s)', in this case
06:19:42 <ivanm> (when "class (Foo (c v) v) => Bar c v" does)
06:19:46 <ski> @type mapStateT
06:19:47 <lambdabot> forall (m :: * -> *) a s (n :: * -> *) b. (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
06:20:01 <ski> that leaks implementation details of `StateT', so can't be made generic
06:20:06 <ski> @type mapWriterT
06:20:07 <lambdabot> forall (m :: * -> *) a w (n :: * -> *) b w'. (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
06:20:15 <ski> @type mapReaderT
06:20:16 <lambdabot> forall (m :: * -> *) a (n :: * -> *) b w. (m a -> n b) -> ReaderT w m a -> ReaderT w n b
06:21:29 <zygoloid> ski: the two are separate though. you can't implement tmap in terms of fmapT nor vice versa
06:22:03 <ski> zygoloid : ok, i think `(m a -> n b) -> (t m a -> t n b)' (or even `(m a -> m a) -> (t m a -> t m a)') is harder than the `tmap'
06:22:21 <ski> zygoloid : yeah, sure. just mentioning something a bit similar
06:22:55 <zygoloid> yeah. there's clearly a lot of options in this space, and choosing something too general rules out a lot of instances
06:23:19 <ski> *nod*
06:23:42 <ski> one'll just have to try different options and see what can be implemented and what is most useful
06:23:45 <zygoloid> interesting that fmapT and tmap can both be implemented in terms of mapStateT, mapWriterT and mapReaderT.
06:24:59 <zygoloid> i wonder if the 'right' abstraction is something like: class Thingy t where type Encapsulated t a :: *; mapT :: (m (Encapsulated t a) -> n (Encapsulated t b)) -> (t m a -> t n b)
06:25:15 <ski> (also, your `fmapT' seems related to the "monad tunneling problem" .. but i assume you know that)
06:25:24 <zygoloid> (so that the transformer can specify the type of the extra stuff it wants carried through the other monad)
06:25:50 <zygoloid> ski: yeah, very much so. istr quicksilver had a great post on -cafe about that stuff
06:26:00 <ski> well, in that case you'd at least want `instance Functor (Encapsulated t)', i think
06:26:27 <zygoloid> yeah :) hmm, maybe even Monad (Encapsulated t) ? :o
06:26:40 <ski> (can one write that inside a type class, when doing associated types ?)
06:26:55 <zygoloid> you can put a requirement for an instance of the associated type in the class's context
06:27:03 <ski> oh, right
06:28:24 <zygoloid> this now seems like a delimited form of: run :: (MonadTrans t, Monad m) => t m a -> m (t Identity a); coRun :: m (t Identity a) -> t m a
06:30:36 <ski> .. there should also be a `class MonadTransBase m t where toTrans :: Monad n => m a -> t n a; fromTrans :: t Identity a -> m a'
06:37:39 <shapr> Good Morning #haskell !
06:40:27 <aRcatan> @time shapr
06:40:28 <lambdabot> Local time for shapr is Thu Aug 19 08:40:04 2010
06:40:36 <shapr> Good morning aRcatan!
06:40:43 <aRcatan> good afternoon, shapr!
06:42:20 <klbz> sik
06:50:22 <kamatsu> hi all
06:50:43 <kamatsu> i have an alex generated lexer that appears to make ghc stall
06:50:57 <kamatsu> i.e it infinite loops and doesn't seem to compile beyond that point
07:01:13 <copumpkin> kamatsu: maybe send it to the ghc list or ask in #ghc ?
07:03:09 <mb1> test
07:03:24 <wakeupsticky> hey all
07:03:40 <bla123> would someone please persuade me that laziness is a good default for a programming language?
07:03:46 <wakeupsticky> i finally got gtk installed on windows, but it looks like i'll want to use something on top of it.
07:04:08 <bla123> i know you can write neat one-liners with it, but you can also run in laziness-related bugs easily
07:04:11 <Zao> bla123: <insert joke about being too lazy to>
07:04:14 <wakeupsticky> any recommendations? looking at grapefruit-gi right now. should i go with gtk2h instead?
07:04:28 <wakeupsticky> [1..]
07:04:29 <medfly> laziness related bugs?
07:04:29 <Zao> bla123: If by bugs you mean space leaks, sure.
07:04:37 <medfly> I just thought that you might do things less efficiently..
07:04:40 <Zao> Or traversing infinite lists strictly.
07:04:46 <wakeupsticky> (false or [infinite-loop])
07:04:47 <bla123> performance-bugs
07:04:56 <Zao> Those are features.
07:04:57 <wakeupsticky> (true or infinite-loop) i mean
07:05:28 <wakeupsticky> gtk2h = gtk2hs
07:06:02 <bla123> i'd say that in time-critical applications, performance-bugs are real bugs
07:06:22 <wakeupsticky> doesn't laziness generally improve performance though?
07:06:29 <Zao> If you're hard or soft RT, you have some rather specific requirements not suitable to use as generic downsides.
07:06:45 <copumpkin> bla123: we don't have time-critical applications cause we have a non-RT GC anyway
07:07:11 <bla123> Zao: would GUIs qualify as soft RT?
07:07:23 <Zao> Not horribly.
07:07:28 <roconnor> bla123: have you read "why functional programming matters?"
07:08:04 <bla123> roconnor: a long time ago, i barely remember it
07:08:22 <bla123> but laziness /= fp
07:09:54 <copumpkin> bla123: here's one opinion on it: http://pchiusano.blogspot.com/2009/05/optional-laziness-doesnt-quite-cut-it.html
07:10:34 <bla123> copumkin: thanks (ah, fresh meat!)
07:11:20 <greap> Is there a way to have a value computed at compile time? For example, I have a lookup table definition...
07:12:46 <wakeupsticky> ok, i have gtk installed on windows but i'm a bit confused as to exactly which packages constitute gtk2hs.
07:13:02 <wakeupsticky> one is supposedly called "tools" but there is no package called "tools" or "gtk2hs-tools"...?
07:13:18 <itsmonktastic> greap: Have a look at tepmlate haskell perhaps http://www.haskell.org/haskellwiki/Template_Haskell
07:13:58 <hpc> usually, constant values will already be optimized by precomputation by GHC
07:14:17 <hpc> dunno if a lookup table would fall into that category
07:14:18 <doofer> greap: you can use template haskell to convert a Map to a function with a case expression for example
07:14:42 <bla123> wakeupsticky: you only need tools to compile the rest
07:14:58 <doofer> greap: have you profiled your program?
07:15:19 <wakeupsticky> ok...what is the name of the package i need? it's not "tools" or "gtk2hs-tools" if i'm supposed to get it with cabal.
07:15:32 <wakeupsticky> am i supposed to download/unzip/add directories to path instead of use cabal?
07:16:04 <greap> doofer: Nope. I'm not going to do it yet, but was just wondering :)
07:16:18 <greap> I'll check out some more template haskell
07:16:21 <hamishmack> wakeupsticky: cabal install gtk2hs-buildtools
07:16:30 <wakeupsticky> ah
07:16:53 <wakeupsticky> is that all i need to do or is that step one of (i presume) two?
07:16:56 <Saizan> wakeupsticky: if you've already installed gtk you already have gtk2hs-buildtools, and you don't need it anymore
07:16:59 <doofer> greap: profiling often proves your assumptions about bottlenecks wrong :) but go ahead, TH is quite fun to play with anyway :D
07:17:14 <wakeupsticky> ok, i just need to get something to run on top of gtk
07:17:26 <bla123> copumpkin: i read the article
07:17:27 <wakeupsticky> that's all i'm confused about
07:17:52 <bla123> copumpkin: i see that there are problems if we freely mix lazy and non-lazy
07:18:03 <Saizan> wakeupsticky: try the helloworld here? http://www.haskell.org/gtk2hs/documentation/#examples
07:18:04 <bla123> copumpkin: but why have lazy at all?
07:18:15 <Saizan> wakeupsticky: i don't know if it works with the current api though
07:18:22 <bla123> copumpkin: i could pass a closure as an argument and call it when needed
07:18:51 <copumpkin> bla123: it solves a lot of the issues with dependent types, probably
07:18:57 <copumpkin> although I don't think any languages use that
07:19:05 <copumpkin> maybe, dunno
07:19:18 <copumpkin> (with compiling dependently typed programs, that is)
07:19:33 <wakeupsticky> ok, what i'm wondering is what packages i need to install to have gtk2hs available
07:19:51 <roconnor> bla123: the paper "why functiona programming matters?" is really IMHO a paper about laziness.
07:20:11 <roconnor> or at least half of it is about laziness.  I don't remember so well
07:20:16 <roconnor> you should reread it now.
07:20:18 <siracusa> wakeupsticky: You only need the gtk package
07:20:29 <bla123> copumpkin: but haskell does not have dependent types, right? should it have them to put laziness to full effect?
07:20:40 <copumpkin> bla123: also, if you don't want to reread it, read http://weblog.raganwald.com/2007/03/why-why-functional-programming-matters.html
07:20:43 <wakeupsticky> ok, i already have that. so i can go through a gtk2hs tutorial and the includes and etc. will all work out?
07:20:47 <wakeupsticky> gtk-demo works for me.
07:20:52 <copumpkin> bla123: yeah, it doesn't, and no it shouldn't have them :P
07:21:01 <bla123> roconnor: ok, at least someone convinced me to re-read that paper ;)
07:21:17 <ski> bla123 : it can help with modularity, as, iirc, the paper gives an example of
07:21:22 <bla123> copumpkin: why not? (i'm not into dependent types)
07:21:36 <copumpkin> bla123: they're neat, but you lose a lot of nice stuff when you add them
07:21:41 <roconnor> bla123: usually people get totaly different messages from that paper when it is reread.
07:21:42 <wakeupsticky> ok, i will just try following along in a gtk2hs tutorial and see if it all works
07:21:53 <roconnor> bla123: it's like a whole new paper! :O
07:22:31 <bla123> roconnor: ok, i didn't have much exposition to fp when i read it the last time
07:22:46 <copumpkin> bla123: the game tree example is a nice one
07:23:01 <copumpkin> of something where laziness fits nicely
07:28:31 <mb1> Hey. I would like somebody to check a part of a source code for a Haskell project. The particular part is about 20 lines. I am a Haskell rookie so the problem could be almost anything. Is there a user forum I can sign up for to post my question and the part of the code?
07:28:40 <roconnor> @paste
07:28:41 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:28:48 <roconnor> paste the 20 lines there
07:30:21 <mb1> I might need to get into the problem.
07:30:41 <greap> I tried to use the template haskell idea like so: frequencies = $( [|M.fromList . map toRatio $ letter_occurances |] ). I have a debug.trace statement in letter_occurances, and this is still printed at runtime, is there something I'm doing wrong?
07:30:47 <Botje> put whatever contxt you think will help in a comment? :)
07:32:45 <Saizan> greap: that's exactly the same as without the TH
07:33:29 <doofer1> greap: [| ... |] means "the representation of ...", $(...) means "the haskell code from ... (an Exp representation)"
07:33:55 <doofer1> so [|$(...)|] is the id function
07:34:12 <Saizan> i don't think there's a way to include an already evaluated Map, since the constructors are not exposed.
07:34:15 <mm_freak_> there is this iteratee package, which i don't really understand yet, but i always asked myself:  couldn't a parser monad do just the same?
07:35:02 <Botje> mm_freak_: an iteratee inverts the flow of control
07:35:26 <copumpkin> a continuationish parser like attoparsec looks quite a bit like an iteratee
07:35:31 <Saizan> mm_freak_: one that accepts input incrementally can, like attoparsec
07:35:47 <mm_freak_> copumpkin: yes, there is even a package to convert an attoparsec parser to an iteratee
07:36:11 <Saizan> what attoparsec lacks is an interface for vertical composition
07:36:44 <greap> doofer1:  So how would I get it to evaluate at compile time?
07:36:49 <mm_freak_> well, most of the time, when i read a file, i apply a parser right away
07:37:26 <doofer1> greap: I think you would have to make a new function with a representation of the evaluated data
07:37:51 <greap> I tried runQ but that doesn't seem to help. Sorry if I seem to be bumbling through this rather than sitting down and going through tutorials or something. I really only want to learn this one thing for now :)
07:37:52 <Saizan> yeah, but supposed you have both a tokenizer and a parser
07:38:08 <doofer1> greap: th-lift could help here
07:38:14 <mm_freak_> Saizan: the parser does the tokenization
07:39:02 <Botje> greap: how big is the map?
07:39:17 <greap> Botje: Quite small.
07:39:45 <Botje> greap: then maybe you could live with constructing the map at runtime but the elements at compile time?
07:39:55 <Botje> or isn't that the problem :/
07:40:03 <ski> @where paste
07:40:03 <lambdabot> http://hpaste.org/new
07:40:15 <ski> mb1 : try that ^ instead
07:40:16 <greap> Botje: That would be fine.
07:40:22 <Saizan> mm_freak_: sure, but i can see the appeal of defining separate layers separately and just compose them later, since it seems the runtime overhead is minimal with iteratees
07:40:49 <Saizan> mm_freak_: though i've never done anything large with them, and i'm not a great fan of the api
07:40:50 <ski> roconnor : i suspect `moonpatio.com' is down until the second coming of mmorrow
07:40:56 <roconnor> sorry
07:41:03 <roconnor> I'm so used to typing @paste
07:41:15 <Saizan> oleg's slides feel clearer than the haddocks on hackage though, surprisingly
07:41:23 <mm_freak_> Saizan: yes, i don't like it that much either
07:41:31 <mm_freak_> i really prefer the way parser monads do it
07:41:45 <temoto> map (\f -> f arg) funs   what does this look like?
07:41:56 <doofer1> greap: if you have the map bound to a name, its elements will only be evaluated once anyway, so TH may be a bit overkill
07:41:57 <vanadium> map ($ arg)?
07:42:00 <copumpkin> temoto: looks like that to me
07:42:13 * zygoloid gets an idea
07:42:25 * zygoloid discovers mmorrow's phone number
07:42:26 <copumpkin> damn, we can't have any ideas in here
07:42:32 <copumpkin> zygoloid: I've found it before
07:42:37 <Saizan> mm_freak_: well, with the right combinators the interface won't be very different, actually
07:42:41 <copumpkin> Saizan thinks I'm a stalker :(
07:42:57 <aristid> copumpkin: why do you stalk him?
07:43:12 <copumpkin> aristid: I was considering calling him to see if he's okay
07:43:13 <drksd> copumpkin: is he right?
07:43:18 <copumpkin> he kind of disappeared very suddenly
07:43:27 <copumpkin> and all his web presence died off
07:43:34 <copumpkin> except for hpaste, strangely enough
07:43:38 <greap> doofer1: Yes. I'm definitely breaking the premature optimisation rule here, but now that the idea is in my head I have to see if I can make it work :)
07:43:42 <aristid> hmm
07:44:52 <zygoloid> copumpkin: did you manage to make contact?
07:45:09 <copumpkin> zygoloid: I was too chicken to try calling him, but I can show you where I found the ino
07:45:11 <copumpkin> info
07:45:28 <mb1> I published the code and a short description at hpaste. (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29295#a29295)
07:45:40 <doofer1> greap: okay :) well th-lift will allow you to derive a Lift instance for your data so you can go from YourData -> ExpQ, which will let you construct a list of the evaluated data using TH's listE function
07:46:02 <doofer1> (or if you're using some in-built datatype, it will probably already have a Lift instance)
07:46:45 <temoto> vanadium, thanks
07:47:04 <temoto> i'll keep it as (\f -> f arg) :)
07:47:44 <greap> doofer1: Ok.
07:48:39 <jaspervd1> preflex: seen moonmaster9000
07:48:40 <preflex>  moonmaster9000 was last seen on #haskell 5 days, 1 hour, 48 minutes and 48 seconds ago, saying: k thanks. i'm building out a web dev DSL called "bird" where it actually makes more sense to group them together that way.
07:50:38 <quicksilver> mb1: looks like pixbufSave changed.
07:50:55 <quicksilver> mb1: it used to return (I guess) Nothing for success and Just in the case of error
07:51:04 <quicksilver> now according the to docs at http://www.haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-Gdk-Pixbuf.html#v%3ApixbufSave
07:51:12 <quicksilver> it simply returns () and signals error with exception.
07:52:03 <Blkt> good evening
07:53:07 <byorgey> hi Blkt 
07:53:38 <Blkt> hi byorgey
07:53:46 <mb1> Can I use the old function? I already use import Control.OldException instead of Control.Exception. I first just want to get it running.
08:01:41 <quicksilver> mb1: well the simplest thing to do is not worry about the possibility of exceptions
08:01:48 <quicksilver> mb1: and just remove the error haandle code
08:10:24 <ski> hm, who is a lambdabot master ? JordiGH in #math is wondering what it is doing in there
08:10:39 <medfly> cale
08:10:46 <geheimdienst> "it" is a she
08:11:07 * medfly points fingers
08:11:13 <ski> (yeah, but iirc also some other people can command her to join and part)
08:11:25 <ski> geheimdienst : slip of tongue :)
08:11:41 <medfly> pretty sure it's all Cale's fault
08:11:45 <medfly> it always is.
08:11:51 <copumpkin> it can be made to part easily
08:12:02 <geheimdienst> lambdabot? slip? tongue? what exactly are you guys in #math doing with her?
08:12:02 <copumpkin> *she
08:13:26 <aristid> geheimdienst: why is lambdabot a she?
08:13:37 <c_wraith> @vixen are you a woman?
08:13:38 <lambdabot> yup, i'm all woman
08:13:44 <aristid> @vixen are you a man?
08:13:44 <c_wraith> @vixen are you a man?
08:13:45 <lambdabot> no, i'm a woman
08:13:45 <lambdabot> no, i'm a woman
08:13:48 <aristid> oh.
08:13:49 <geheimdienst> aristid, what kinda question is that? "why is aristid a he?"
08:13:51 <RichardB_> @vixen are you a robot?
08:13:51 <lambdabot> no, how dare you ask if i'm a bot!
08:14:18 <aristid> geheimdienst: because i have a Y chromosome and the usual phenotypes associated with males.
08:14:36 <vanadium> @vixen is aristid a man?
08:14:36 <lambdabot> yes
08:14:42 <aristid> see.
08:14:43 <medfly> :D
08:14:50 <roconnor> aristid: are you sure you have a Y chromosome?
08:14:54 <aristid> @vixen is vanadium a man?
08:14:54 <lambdabot> no
08:14:58 <medfly> hehe
08:14:59 <vanadium> Hey :<
08:15:06 <aristid> roconnor: no, but i think it's likely due to the phenotypes
08:15:08 <geheimdienst> so obviously, since lambdabot does not have a y chromosome and the usual phenotypes associated with males, she must be a she. case closed.
08:15:26 <vanadium> I would say lambdabot is a she because she self-identifies as such
08:15:27 <medfly> is not male = female? what happened to it?
08:15:31 <aristid> geheimdienst: i did not know that lambdabot has no Y chromosome
08:15:34 <geheimdienst> why do some people have so many problems with logic?
08:15:52 <roconnor> geheimdienst: http://shemesh.larc.nasa.gov/fm/fm-humor-penguins.html
08:16:01 <vanadium> Apply logic to a set of faulty assumptions about gender can easily lead to drama :<
08:17:28 <fryguybob> Zao: Any word back on that Data.Text.IO bug?
08:17:38 <aristid> vanadium: and this in a channel where normally the height of drama is excitement about a new paper about zygohistomorphic prepromorphisms.
08:18:00 <roconnor> there's a new paper?
08:18:33 <bss03> :P
08:18:34 <aristid> roconnor: not yet! you have to write it
08:18:36 <vanadium> :D
08:18:53 <geheimdienst> you forget the excitement when they put the lambdacats back on the web
08:19:02 <zygoloid> aristid: new paper? ooh ooh. oh.
08:19:07 <vanadium> Who is running that, anyway?
08:19:08 <zygoloid> aristid: i am disappoint
08:19:11 <int80_h> good morning everyone
08:19:12 <vanadium> I still need to submit liftMeow.png
08:19:23 <aristid> vanadium: the name is promising.
08:19:29 <vanadium> http://ilfirin.org/liftMeow.png
08:19:39 <geheimdienst> omg! cats! capshuns! haskell! the universe's three most awesomest things all together
08:20:01 <burp> lol
08:20:13 <geheimdienst> vanadium, a very nice lambdacat. submit it!
08:21:09 <vanadium> sproingie actually came up with the name, I just found the image ._.
08:21:36 <geheimdienst> i remember that, it was one of the first times i was on #haskell
08:21:52 <gio123> ski
08:21:58 <geheimdienst> (not the names, just that somebody asked and somebody answered)
08:26:57 <kmc> lambdacats?
08:27:21 <benmachine> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#960526161_yXhEz
08:27:29 <kmc> yay it's back
08:28:08 <Twey> Oh no!  The lambdacats archive died ☹
08:28:21 <Botje> NOT LAMBDACATS?!
08:28:55 <benmachine> the above is a mirror
08:29:16 <bla123> roconnor, copumpkin: i just finished re-reading "why fp matters" - it was really worth the read
08:29:20 <aristid> what happened to the old lambdacats?
08:29:26 <vanadium> The domain expired.
08:29:26 <roconnor> bla123: \o/
08:29:35 <vanadium> Apparently the operator dropped off the face of the internet.
08:29:43 <aristid> vanadium: who hosted it?
08:29:50 <bla123> although i wonder whether we still have great composability in io heavy code
08:29:55 <vanadium> Some guy at arcanux.org
08:30:02 <roconnor> bla123: indeed.
08:30:08 <aristid> vanadium: too bad
08:30:14 <nlogax> where can i find cabal's exitfailure codes?
08:30:30 <bla123> roconnor: err ... that means "no, we don't"?
08:31:08 <kmc> @vixen do you have a Y chromosome?
08:31:08 <lambdabot> maybe. do you?
08:31:14 <roconnor> bla123: The point is debatable.
08:31:16 <ski> good answer
08:31:24 <kmc> we don't even know what kind of sex selection bots use
08:31:25 <geheimdienst> @vixen do you have a Y combinator?
08:31:25 <lambdabot> i do occassionally, i guess
08:31:39 <kmc> they might be like those reptiles which come out male only if the egg is incubated in some narrow temperature range
08:31:43 <kmc> if and only if, actually
08:32:34 <kmc> or they might have haploid males and diploid females
08:32:46 <ski> .. or like those fishes who can change sex when they get older (or if the oldest dies)
08:33:03 <bla123> roconnor: do you think that we just need to find concepts for nicely composable io or is io inherently less composable that pure code?
08:33:37 <roconnor> bla123: I think IO is full of things that shouldn't be in IO.
08:33:46 <geheimdienst> is composability the issue? i thought it's more about pureness
08:33:47 <aristid> :t foldr (++) []
08:33:48 <lambdabot> forall a. [[a]] -> [a]
08:34:12 <ski> @type concat
08:34:13 <lambdabot> forall a. [[a]] -> [a]
08:34:14 <aristid> oh, so fillBelly = concat fridgeContents
08:34:30 <geheimdienst> aristid, i see you're checking that fridge cat doesn't have a type error or something. good thinking.
08:34:39 <aristid> looks more impressive with the foldr
08:34:53 <benmachine> geheimdienst: pure stuff is more composable
08:34:56 <kmc> i think IO in general is probably not very composable
08:34:59 <bla123> roconnor: couldn't we split IO? things in IO have a varying degree of badness ... some could easily be simulated in a testing environment
08:35:05 <bla123> for example file IO
08:35:08 <kmc> but that there are composable denotational models for lots of particular things people do in IO
08:35:25 <kmc> interactive graphics, concurrency, file servers
08:35:44 <geheimdienst> #haskell. Our lolcats have cleverer code than your lolcats.™
08:35:46 <roconnor> bla123: I suspect we can
08:36:08 <bla123> maybe we should then ;)
08:36:36 <bla123> we already have ST which is a kind of pointer simulator if you just need pointers, and so on
08:36:47 <copumpkin> bla123: there's a section in data types à la carte tht talks about that
08:36:57 <kmc> yeah, ST gives you the mutation part of IO without the rest
08:37:05 <kmc> and is implemented just as efficiently (in GHC)
08:37:06 <copumpkin> bla123: I wouldn't say pointers as much as mutability
08:37:06 <geheimdienst> what do you guys mean by "composable", anyway?
08:37:17 <copumpkin> you still can't do pointer arithmetic
08:37:48 <kmc> geheimdienst, that you can tractably build big systems by gluing together small ones
08:38:06 <copumpkin> bla123: http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
08:38:23 <kmc> IO has a bunch of implicit state, so all IO actions can potentially interact, so it's not tractable to reason about big IO actions, without a lot of discipline on the part of the programmer
08:38:38 <bla123> copumpkin: thanks, i didn't know that one
08:38:43 <kmc> (this is a criticism of most programming languages, as well as of Haskell's IO system)
08:39:33 <geheimdienst> i see. yes i've noticed that, as the program grows, the IO monad tends to include everything and the dog
08:39:39 <roconnor> copumpkin: you can still have aliasing in ST right?
08:39:48 <kmc> geheimdienst, that's not true of the programs i write
08:39:53 <kmc> and it's not what i was saying
08:39:59 <roconnor> alaising is a bigger problem than pointer arithmetic.
08:40:09 <kmc> or did you mean "more operations are added to IO" rather than "more code uses IO"?
08:41:08 <geheimdienst> i meant that there seems to be so much stuff in IO: from printing to the screen to file operations, getting the time, mostly any foreign function ...
08:41:15 <orbitz> anyone had any issues isntalling happstack on 6.12.1?
08:41:16 <geheimdienst> seems like a lot of diverse stuff
08:41:27 <geheimdienst> don't know if my point makes much sense
08:41:42 <bla123> it does, IO looks like the rubbish dump for everything impure
08:41:50 <kmc> ah yes geheimdienst
08:41:55 <geheimdienst> bla123, that's what i meant exactly
08:41:58 <kmc> that *is* what i meant
08:44:02 <geheimdienst> and even doing getArgs or reading environment variables requires your function to drop into IO. i'm sure the command line arguments can't change during the program's lifetime, and i'm pretty sure there's no way for env variables either
08:44:30 <vanadium> Sure there is. setenv.
08:44:39 <Zao> fryguybob: It's being looked into.
08:44:45 <ski> also, consider mobile code
08:44:55 <kmc> geheimdienst, there is some very strict interpretation of "purity" where even things which change *between* runs should be considered impure
08:45:04 <kmc> or between compiles
08:45:12 <ski> or between platforms
08:45:19 <kmc> there are bits of the standard library which are in IO but implemented with "return" for this reason
08:45:26 <Zao> geheimdienst: Well, canonically an application is allowed to modify argc and the contents of argv.
08:45:26 <bla123> the world is impure
08:45:35 <ski> let's make it more pure !
08:45:41 <ezyang> Oh man, Oleg replied to my haskell-cafe mail! 
08:45:47 <bla123> yeah, let's factor a peace out of it!
08:45:50 <geheimdienst> vanadium, but isn't that practically only for when you execve a child process? "fork this guy and give him the following environment"
08:46:01 <geheimdienst> kmc, i see. that's interesting
08:46:39 <geheimdienst> zao, but surely in haskell there's no way of changing argc, right?
08:46:45 <vanadium> geheimdienst: But you can still change your own environment, so making that pure seems wrong
08:46:49 <bla123> i somehow feel that purity constraints can make my code less maintainable
08:47:28 <copumpkin> all the typical examples I hear of that involve not separating concerns
08:47:30 <bla123> i can't just decide that a function deeply buried somewhere needs to read an environment variable
08:47:42 <copumpkin> "I have this pure function and I wanted to make it read from external state"
08:47:42 <copumpkin> lol
08:47:45 <copumpkin> exactly :P
08:48:05 <bla123> but what's the solution? pass everything in that is needed?
08:48:10 <kmc> yes
08:48:13 <ezyang> It does seem a lot easier to apply hacks to impure code. 
08:48:16 <geheimdienst> i just checked, /proc/*/environ is read-only
08:48:19 <copumpkin> yeah, and if you have a lot of stuff
08:48:20 <bss03> Being explicit about state is a good thing.
08:48:23 <copumpkin> then bundle it up in a type
08:48:24 <bla123> won't you necessarily end up passing more and more stuff?
08:48:27 <geheimdienst> (cause sometimes i wished you could change variables of a running process)
08:48:38 <copumpkin> bla123: typically you design your functions to have nice simple behaviors
08:48:45 <copumpkin> I try to avoid making very large functions
08:48:47 <burp> bla123: monads are the solution (State and Reader monads)
08:48:53 <copumpkin> if they have lots of nested indentation, something's probably wrong
08:49:04 <bla123> yeah, burp, that's exactly where i wanted to go ;)
08:49:23 <bla123> you figure that you pass so much stuff that you want an "environment"
08:49:25 <bss03> Instead of function growing extra arguments, types grow extra accessors.  But, more data does imply more "stuff" being passed around.
08:49:30 <bla123> then you wrap it up in a monad
08:49:38 <kmc> bla123, Haskell makes it harder to modify your code willy-nilly.  in return, you get more assurance that your modifications are actually correct
08:49:46 <burp> bla123: monads don't make it impure
08:49:59 <bla123> but monads don't "feel" pure to me either
08:50:16 <bla123> purely functional code looks much more beatiful to me
08:50:25 <ski> well, often it's not (necesarily) that you're passing so much stuff .. rather that you want to be able to change the details of the stuff you're passing without having to modify most code
08:50:28 <kmc> monadic code is purely functional
08:50:31 <bss03> The only impure Monad is IO.  [], Maybe, State, etc. are pur as the driven snow.
08:50:36 <bla123> with monads, there it is again: stuff working behind the scenes
08:50:39 <kmc> and you can always ignore the monadic syntax and operators
08:50:39 <ski> `IO' is pure, as well
08:50:44 <aristid> bla123: no, only with IO.
08:50:51 <kmc> bla123, it's no more behind the scenes than the fact that "map" iterates its list argument behind the scenes
08:51:06 <geheimdienst> kmc, not that i have much experience yet, but i've sometimes felt haskell makes willy-nillytude easy. you just go ahead and change something. the compiler will tell you all the places that broke. in a dynamic language you'd have to hunt that all down yourself with no help from the language
08:51:07 <bla123> kmc: that's a point
08:51:13 <kmc> geheimdienst, right
08:51:21 <aristid> there's nothing purer than the Monad instance of []
08:51:25 <bss03> (>>=) and return are simply haskell functions, no magic.
08:51:43 <aristid> bss03: (>>=) is slightly magic because it combines join and fmap :)
08:51:50 <kmc> bla123, abstraction will always involve some degree of "behind the scenes", and is widely acknowledged as an essential part of software design
08:51:51 <bla123> i know that it is pure, what i meant is that it does not "feel" pure to me
08:51:55 <drksd> aristid: how is that magic ?
08:52:10 <kmc> bla123, but "behind the scenes" does not imply magic; you can drill down into the implementation easily
08:52:12 <aristid> drksd: *shrug*
08:52:12 <burp> does it have to feel pure? :D
08:52:17 * ski . o O ( "(a) Magic | (b) More Magic" )
08:52:22 <kmc> hahaha ski
08:52:23 <drksd> and aristid, it doesn't combine join and fmap, it can be expressed as a composition of the two, but the inverse holds
08:52:32 <drksd> (iirc)
08:52:39 <ezyang> Refactoring in Haskell is fun! 
08:52:41 <bla123> "pure" in the sense of: i can exactly see, what is passed in and out
08:52:51 <aristid> drksd: join and fmap are the more natural transformations :P
08:53:01 <drksd> nee
08:53:04 <bss03> aristid: True, (>>=) is more there for the "do-notation" then as a model of mathematical Moands, but I wouldn't condier it "Magic".
08:53:14 <drksd> maybe it is because well, you've been programming for a while
08:53:18 <ski> bla123 : yeah, what doesn't "feel pure" to you is probably that you have to reason about execution order
08:53:19 <aristid> bla123: are you aware that IO is not the only monad?
08:53:45 <bla123> ski: yes
08:53:53 <geheimdienst> bla123, i agree. when hacking xmonad you get the feeling that when a function is in the X monad, it has a big bunch of global variables to mess with
08:53:53 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29297#a29297
08:53:53 <bla123> aristid: yes
08:54:06 <drksd> but aristid, >>= is simply a composition law
08:54:11 <int80_h> I just pasted some questions for discussion if you'd like.
08:54:17 <ski> aristid : well, `join' and `return' are natural transformations. `fmap' is not (normally) phrased as one :P
08:54:25 <drksd> seems quite natural to me
08:54:31 <kmc> bla123, you can't see, when you use "foldr", that it folds right-to-left.  you have to know this from the contract
08:54:45 <kmc> similarly you have to know what the contract for (>>=) says, for your particular monad
08:54:49 <aristid> ski: it was supposed to be a small joke :D
08:55:01 <drksd> oh
08:55:03 <drksd> i missed it
08:55:04 <drksd> :°
08:55:06 <aristid> ski: i wanted to write "more natural functions" first
08:55:23 <ski> aristid : yeah, i just joked upon it :)
08:55:24 <bla123> kmc, i like your former argument best: it's what abstraction is all about
08:55:41 <kmc> fmap is a natural transformation from the identity functor to this functor?
08:55:56 <kmc> focusing on (>>=) instead of 'join' also makes sense if you want to see the difference in power between Applicative and Monad
08:56:00 <bss03> int80_h.  createHull is buildilng a list.
08:56:27 <aristid> kmc: why? i think join expresses that difference more succinctly
08:56:47 <int80_h> bss03 : thanks :)
08:56:52 <bss03> int80_h: The first element has no transofrmation applied to it, the tail has a recursive call and "fiilterPoint" applied to it.
08:57:35 <bss03> So, you get something like [a, filterPoint b, filterPoint $ filterPoint c, filterPoint . filterPoint $ filterPoint d, ...]
08:57:42 <int80_h> so createHull builds the list, then filterPoint uses that list?
08:58:03 <int80_h> I want to make sure I totally understand what is going on here. I'll have to talk about it.
08:58:04 * ski often wishes for an SML-like `local' construct in Haskell ..
08:58:27 <bss03> 'cept that each nesting of "filterPoint" is a slightly different function.  (notice that it uses a bound variable)
08:59:53 <kmc> aristid, hmm
08:59:58 <kmc> aristid, i guess it works either way
09:00:02 <megajosh2> I'm having a bit of a problem getting the State monad... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29298#a29298
09:00:07 <int80_h> bss03: thanks :)
09:00:17 <kmc> megajosh2, that's a partially applied type constructor
09:00:30 <kmc> megajosh2, note that other instances of Monad are also partially-applied type constructor
09:00:31 <dankna> So...  Today's problem on which i need help:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29299#a29299
09:00:35 <kmc> Maybe, (Either s), IO
09:00:42 <kmc> none of those are types; they're all waiting for one more type argument
09:00:49 <roconnor> anyone recall the method of representing variable binding with HOAS but using some fancy polymorpism to disallow exotic terms?
09:00:51 <megajosh2> Oh, okay
09:00:54 <megajosh2> Thanks
09:01:04 <dankna> it seems like it's saying that it can't match two type variables against each other because they're both rigid... which.... okay, as far as that goes
09:01:08 <kmc> no problem :)
09:01:47 <ski> megajosh2 : in the `data Maybe a = Nothing | Just a' case, there is `instance Monad Maybe where ...'
09:02:10 <ski> megajosh2 : we say that `Maybe' is a type function that takes types like `Int' and wraps them into `Maybe Int'
09:02:16 <dankna> I guess the root cause is probably that the typechecker doesn't fully know that the list of lists has every element the same type, even though /I/ know that
09:02:28 <dankna> but it should; the GADT should be forcing it to
09:02:47 <ski> megajosh2 : so, to say that `Int' is a normal type, we write `Int :: *', and they we say `Maybe :: * -> *' meaning `Maybe' takes a type and gives a type
09:02:52 <kmc> dankna, can you make a shorter example?
09:03:00 <dankna> yes, one sec
09:03:18 <roconnor> Ah, I think it might be in "Engineering Formal Metatheory"
09:03:33 <ski> megajosh2 : in your `newtype State s a = ...' case, `State' takes two parameters, which both are normal types, so we get `State :: * -> * -> *', which means `State :: * -> (* -> *)'
09:03:56 <ski> megajosh2 : now, in `instance Monad Blah', `Monad' wants `Blah' to have "kind" `* -> *'
09:04:25 <ski> megajosh2 : so `State :: * -> * -> *' does not fit in there, but `State s :: * -> *' does, for any type `s'
09:04:54 <megajosh2> ski: Okay, that explains a lot
09:05:08 <megajosh2> I was confused about a couple of other things I saw
09:05:52 <bss03> dankna: For some reason, I think "value@...:rest" is being treated as a pattern, but that's just a guess.
09:07:13 <dankna> bss: hmm good thought
09:07:27 <bss03> re-writing as "(value@(CustardList _)):rest", maybe?
09:07:36 <dankna> yeah, trying that
09:07:58 <int80_h> ski: could we go over a function you wrote for me yesterday. It uses where and read in a way I am not familiar with, and I didn't have time yesterday to talk to you about it.
09:07:59 <ski> dankna : the type signature for `processFromHere' is problematic, i think
09:08:01 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29300#a29300
09:08:03 <int80_h> ^^^^
09:08:09 <dankna> no dice, but I'm almost ready with the shorter example
09:08:20 <dankna> ski: hmm, perhaps, but it needs to have a type signature because the compiler complains if it doesn't :)
09:08:42 <Botje> int80_h: yes, a tuple accepts any expression
09:09:02 <int80_h>  Botje: now what about that where clause?
09:09:03 <ski> int80_h : yes, you can have a tuple expression `(blah,bleh)' for any expressions `blah',`bleh'
09:09:12 <Botje> int80_h: and yes, the tuple binds two variables, which are indeed used in the line above
09:09:22 <bss03> int80_h: That's a pattern binding.
09:09:24 <dankna> there we go, shorter example at the bottom in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29299#a29301
09:09:30 <Botje> splitCSV line = (coa, ...) where (coa,...) = span ...
09:09:33 <int80_h> oh hey I see it!
09:09:35 <ski> int80_h : the binding in the `where'-clause `(poa,':':coi) = span (/= ':') line' matches the result pair from the `span' call
09:10:09 <bss03> int80_h: It defines poa and coi throughout the function body.
09:10:30 <ski> int80_h : it names the first part of the pair `poa', and then it matches the second part of the pair with  ':':coi  i.e. it makes sure the first character is a colon, then it names the rest of that string `coi'
09:11:06 <ski> > span (/= ':') "ab:cd"  -- note that the second part of the pair includes the colon, which you wanted to discard
09:11:06 <lambdabot>   ("ab",":cd")
09:11:56 <zygoloid> dankna: what is SomeCustardValue? i'm guessing data AnyCustardValue = SomeCustardValue (CustardValue t) ?
09:12:07 <ski> > let (poa,coi) = span (/= ':') "ab:cd" in concat ["poa = ",show poa,"; coi = ",show coi]  -- this is basically the same, but we're matching the result on a pair
09:12:08 <lambdabot>   "poa = \"ab\"; coi = \":cd\""
09:12:30 <dankna> zygoloid: data AnyCustardValue = forall a . SomeCustardValue (CustardValue a), which I think is equivalent to what you just said
09:12:33 <ski> > let (poa,':':coi) = span (/= ':') "ab:cd" in concat ["poa = ",show poa,"; coi = ",show coi]  -- now, i match away the colon
09:12:34 <lambdabot>   "poa = \"ab\"; coi = \"cd\""
09:12:50 <dankna> zygoloid: reload the page, I made it self-contained and shorter down below
09:12:50 <ski> > let (poa,':':coi) = span (/= ':') "ab" in concat ["poa = ",show poa,"; coi = ",show coi]  -- watch what happens if there is no colon
09:12:51 <lambdabot>   "poa = \"*Exception: <interactive>:1:137-170: Irrefutable pattern failed fo...
09:13:01 <ski> > let (poa,':':coi) = "abcd" in concat ["poa = ",show poa,"; coi = ",show coi]  -- watch what happens if there is no colon
09:13:02 <lambdabot>   Couldn't match expected type `(t, [GHC.Types.Char])'
09:13:02 <lambdabot>         against inferr...
09:13:21 <int80_h> bio break
09:13:23 <ski> > let (poa,':':coi) = ("ab","cd") in concat ["poa = ",show poa,"; coi = ",show coi]  -- er, i meant this
09:13:23 <lambdabot>   "poa = \"*Exception: <interactive>:1:137-163: Irrefutable pattern failed fo...
09:13:39 <zygoloid> dankna: well, processFromHere has the wrong type
09:13:53 <ski> zygoloid : yeah, with a `forall t. ' before `SomeCustardValue'
09:13:55 <dankna> hmmmm, does it?
09:14:28 <zygoloid> dankna: [AnyCustardValue] -> [CustardValue [a]] means, the caller can pick an 'a' and get back a list of that type of CustardValue
09:14:30 <bss03> dankna: I agree with zygoloid, I think you mean [CustardValue a]. Maybe?
09:14:47 <int80_h> ski: back
09:14:51 <int80_h> and reading
09:14:53 <zygoloid> dankna: i think you want the processFromHere function to be choosing the type 'a'
09:14:56 <dankna> bss: well, I actuall tried [CustardValue a] when I was flailing around helplessly, and it gave the same error :)
09:15:04 <dankna> zygoloid: I agree.  I wasn't aware I could express that in the type system.  How? :)
09:15:25 <zygoloid> dankna: one way to do that is with a rank-2 type.
09:15:31 <dankna> hm!  okay...
09:15:48 <zygoloid> dankna: processFromHere :: [AnyCustardValue] -> (forall a. [CustardValue [a]] -> b) -> b
09:15:51 <bss03> zygoloid: Oh yeah, good point.  Any type variables that only occur in the last argument are basically bound by the call location.
09:15:56 <bss03> :t fromInteger
09:15:57 <lambdabot> forall a. (Num a) => Integer -> a
09:15:59 <ski> dankna : oh, so you're trying to convert from `[exists a. CustardValue a]' to `exists a. [CustardValue a]' ?
09:16:13 <dankna> ski: that sounds right to me
09:16:15 <int80_h> ski: thanks for the explaination. I will let that sink in a bit...
09:16:26 <dankna> ski: although Haskell doesn't actually have the exists qualifier, right?
09:16:31 <zygoloid> dankna: this means, processFromHere gets given a function which has to work for all types 'a', so processFromHere gets to choose the type 'a' it calls that function with
09:16:33 <ski> dankna : i.e., check whether the list is actually heterogenous, and then manifest that in the types
09:16:44 <zygoloid> dankna: that's correct. Rank-2 types can be used to simulate it though
09:16:44 <dankna> yes, exactly
09:16:51 <ski> dankna : no, but it is easier to express what you want that way, imo
09:16:54 <zygoloid> as can GADTs and existentially-qualified data types
09:16:58 <dankna> gotcha
09:17:01 <zygoloid> *quantified
09:17:20 <kmc> dankna, standard Haskell has neither "forall" nor "exists".  GHC adds the former as an extension and uses it for both universal and existential types (confusingly).  UHC adds both quantifiers and thus has "first-class existentials", which GHC does not
09:17:30 <kmc> but UHC's are limited in other ways (can't capture a class context)
09:17:32 <dankna> still thinking through the snippet zygoloid just gave me
09:17:35 <dankna> gotcha, I see
09:17:44 <dankna> yeah, I knew forall was an extension
09:18:09 <ski> dankna : so, you see that your original `processFromHere :: forall a. [AnyCustardValue] -> [CustardValue [a]]' .. that `forall' should have been an `exists' (and it shouldn't scope over the whole type, either)
09:18:18 <quicksilver> GHC using forall for existentials is not as stupid as it sounds at first glance.
09:18:23 <ski> s/../is wrong ../
09:18:27 <quicksilver> the forall is really on the 'constructor'
09:18:38 <ski>   data AnyCustardValue = forall a . SomeCustardValue (CustardValue a)
09:18:41 <quicksilver> it's just the syntax (for data) that is odd; in GADT syntax it's exactly right.
09:18:45 <dankna> ski: yes, I see indeed
09:18:46 <kmc> yeah
09:18:51 <kmc> it's not stupid, just confusing
09:19:04 <ski>   forall a . (x :: CustardValue a) => (SomeCustardValue x :: AnyCustardValue)
09:19:19 <ski>   forall a . SomeCustardValue :: CustardValue a -> AnyCustardValue
09:19:27 <ski>   SomeCustardValue :: forall a. CustardValue a -> AnyCustardValue
09:19:35 <ski>   SomeCustardValue :: (exists a. CustardValue a) -> AnyCustardValue
09:20:42 <dankna> you're saying "these are some equivalent ways to express existential quantification, although ghc only supports some of them"?
09:20:52 <ski> dankna : anyway, what you (appear) to want requires the ability to compare the various `a' types hidden inside each `AnyCustardValue' list element
09:21:15 <dankna> well, yes
09:21:38 <ski> dankna : i'm saying the above is a way to understand why `forall' is used for "existentially quantified data types", and why that ends up describing an existential
09:21:40 <dankna> since they could be arbitrarily deep lists of lists, I can't just case on them
09:22:04 <dankna> ski: oh - okay.  I've heard the whole forall/exists debate before :)  I think I more or less get it, at least as much as I care to at this time :)
09:22:47 <ski> dankna : so, if you really want to do this kind of type comparision (i'm not convinced you want to do it, yet), then you do need a `Typable a' constraint on the `a' in `AnyCustardValue'
09:22:52 <ski> @type cast
09:22:53 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
09:23:11 <ski> > cast False :: Maybe Bool
09:23:12 <lambdabot>   Just False
09:23:13 <ski> > cast False :: Maybe Int
09:23:13 <lambdabot>   Nothing
09:24:08 <dankna> okay.  and then once I added the Typeable constraint I would basically use cast and check for Nothing.  I still am not sure I see how I would do that, but let's first talk about whether this is what I want.
09:24:17 <dankna> why would I not want to do this type comparison?
09:24:38 <dankna> the overall goal is to enforce list homogeneity in my embedded language
09:24:54 <dankna> to implement functions such as "concat" in it, I need to check that all the subject lists are the same type
09:24:56 <ski> well, if you can design your program to not need dynamic type checks, that is usually better
09:25:28 <ski> (this is sortof like `eval' in Lisps .. you should only use it if you know why you shouldn't use it)
09:25:38 <dankna> heh, that's definitely true
09:26:07 <dankna> well, at the moment the way I have the language set up is that I typecheck things at the point they're used, rather than statically in advance
09:26:17 <dankna> it's an interpreted language, in other words
09:26:45 <dankna> I would have to write a static typechecker, which I could probably manage but it's something I've never done before and in this particular case I'm not sure the performance gain would justify the effort
09:27:07 <ezyang> dankna: Is this a personal project or work code? 
09:27:12 <ezyang> Writing a typechecker sounds like it would be fun. 
09:27:15 <dankna> personal, but fairly large
09:27:27 <dankna> oh it would be fun, but you know what else is fun?  finishing :D
09:27:35 <ski> hm
09:27:38 <ski>     CustardList :: [CustardValue a] -> CustardValue [a]
09:27:47 <ski> would support `concat' just fine, i think
09:28:00 <dankna> well.
09:28:02 <ski> doing it on `[AnyCustardValue]' is what is problematic
09:28:05 <dankna> yeah.
09:28:07 <ezyang> dankna: Enlightenment lies in the journey, not the destination :-P 
09:28:15 <ski> so, why do you want the latter ?
09:28:19 <dankna> ezyang: yes, but I want to actually use this for stuff.
09:28:42 <ezyang> Ah, I see. 
09:29:22 <dankna> ski: well...  because all the functions I have that implement builtins have to be stored in the symbol table, so they have to have the same type signature, so I need the existentially-quantified type to hide the fact that what theye actually deal with is different
09:30:08 <dankna> ezyang: if you're curious, it's a web-templating kinda thing.  I have a content management system that I wrote in Haskell and I'm tearing it to pieces and rebuilding it differently to be more elegant.
09:30:41 <ski> dankna : why can't you have a symbol table like `[exists a. (Symbol a,CustardValue a)]' ?
09:31:18 <ski> (possibly using phantom-types for `Symbol a' .. hm)
09:31:41 <dankna> well, it would be Map Symbol, CustardValue a -- symbols don't have type parameters in my thing, they're just strings -- unless your point was that they should or something, but, hmm
09:32:32 <ski> yeah .. the other say cocon had a problem which seemed to want a `Map1 k v' which morally is `[exists i. (k i,v i)]'
09:32:40 <dankna> I could try that.  How would I express it in a dialect that ghc understands?
09:33:14 <dankna> right I see
09:33:26 <ski> well, you presumably want to be able to construct new `Symbol a's at run-tim
09:33:28 <ski> e
09:33:31 <dankna> indeed
09:33:38 <ski> if that wasn't the case, you could just make a GADT
09:33:39 <zygoloid> dankna: what should typecheckAndHomogenizeList [SomeCustardValue (CustardList []), SomeCustardValue (CustardList [])] do? there's 'best' type for it to internally pick for type 'a'.
09:33:44 <zygoloid> *no 'best' type
09:33:48 <ski> so, i would try a phantom-type
09:33:57 <ski>   newtype Symbol a = Sym String
09:34:15 <dankna> zygoloid: ouch!
09:34:18 <ski> and manually give the correct indices for your symbols
09:34:26 <dankna> zygoloid: that seems to torpedo the whole concept that I can do this dynamically even in principle
09:34:42 <ski> this possibly will then need `unsafeCoerce#' somewhere
09:35:32 <dankna> hmm
09:35:35 <c_wraith> what's the difference between unsafeCoerce and unsafeCoerce# ?
09:35:48 <c_wraith> needing the MagicHash extension?
09:35:49 <ski> i suppose one'd want a monad encapsulating the idea of generating new typed identifiers
09:36:08 <ski> c_wraith : i didn't realize there was two of them ?
09:36:22 <kmc> c_wraith, i think unsafeCoerce# can coerce unboxed values
09:36:30 <ski>   newSym :: forall a. GenSym (Symbol a)
09:36:33 <kmc> unsafeCoerce is an ordinary polymorphic function and thus requires a boxed argument
09:36:36 <ski>   instance Eq (Symbol a)
09:36:44 <c_wraith> kmc: ah, that would make sense
09:36:49 <jystic> hi all, does anyone know how i would go about getting C (IEEE?) floats/doubles out of a ByteString? i'm using Data.Binary.Get for everything else
09:37:20 <yitz> jystic: Haskell Doubles are usually IEEE
09:37:46 <yitz> jystic: you can use Get for that also
09:37:48 <dankna> ski: hmm... this requires me to do a lot of rewriting, but I think it's probably worth the effort to bring stronger typechecking to the Custard language
09:37:49 <jystic> so just using the Binary Double instance? hmm
09:37:54 <Zao> jystic: Grab a Ptr CFloat, grab N bytes, peek and poke until happy?
09:37:56 <ski> @type GHC.Base.unsafeCoerce# (# () , () #) :: (# () , () #)
09:37:57 <lambdabot> (# (), () #)
09:38:05 <kmc> jystic, http://hackage.haskell.org/package/data-binary-ieee754
09:38:06 <dankna> ski: thanks for the input, I'll report back if I get stuck, haha
09:38:31 <c_wraith> jystic: at least test the Binary Double instance.  If it works right, perfect.
09:38:39 <kmc> ski, wow, it can take an unboxed tuple as an arg?
09:38:47 <kmc> that's even more magical than i thought
09:38:53 <jystic> c_wraith: i did but it didn't work for me, just wanted to check i was on the right track
09:39:00 <ski> dankna : just trying to give some ideas. if you go with the "check actually homogenous", you'll have to add `Typable' constraints, though
09:39:14 <jystic> kmc: that looks like what i'm after
09:39:16 <ski> @type GHC.Base.unsafeCoerce#
09:39:17 <lambdabot> forall t b. t -> b
09:39:29 <dankna> ski: yeah, I see that now.
09:39:50 <ski> it probably ought to say `forall (t :: ?) (b :: ?). t -> b'
09:40:48 <ski> @type error "foo" :: (# () , () #)
09:40:49 <lambdabot> (# (), () #)
09:40:59 <yitz> jystic: ah, i see, the Data.Binary.Get only comes with getters for various sized integers, not floats. got it. yeah, use what kmc says.
09:41:01 <kmc> which violates the stated kind of (->) but anyway, that whole system is a bit dubious
09:41:45 <ski> oh .. so it does
09:41:50 <jystic> hmm, kind of sucks that the license is GPL :(
09:42:09 * ski never really understood why arguments couldn't be unboxed tuples
09:43:01 <kmc> you could flatten them to multi args automatically
09:43:31 <greap> Are there any stats libraries for haskell? Std-deviation, variance, so forth?
09:43:39 <kmc> greap, yes, see Hackage
09:43:51 <kmc> but they can't really persist anywhere
09:44:49 <kmc> (the unboxed tuples)
09:46:29 <kmc> i think the components just get loaded into STG registers
09:48:20 * kmc doesn't really know either
09:55:33 <pps> Hello guys.. what is the best way to start off Haskell? Which book/tutorial shd I use?
09:56:16 <kmc> @where RWH
09:56:16 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:56:17 <kmc> @where LYAH
09:56:18 <lambdabot> http://www.learnyouahaskell.com/
09:56:25 <kmc> tryhaskell.org
09:56:31 <kmc> pps, all of the above, see what you like
09:56:38 <kmc> and ask plenty of questions here :)
09:57:43 <pps> Looks descriptive and interesting.. I guess I need to read and try out a few programs before I post questions...
09:57:58 <pps> thanks a lot <kmc>
09:58:02 <kmc> pps, at the beginning you won't be writing whole programs
09:58:05 <pps> and <lambdabot>
09:58:05 <kmc> just expressions you type into ghci
10:03:03 <bla123> maybe those beginner books should be collected somewhere, so that people can be directed to a single page?
10:03:06 <c_wraith> pps: let me repeat one of kmc's suggestions - ask here with any questions you've got.  Most of the time, there are plenty of people glad to help around.
10:03:26 <bla123> the "learning haskell" section on haskell.org does not seem to be up to date
10:03:37 <bla123> e.g., it doesn't have RWH
10:08:29 <dom96> hey, what do you guys think of my haskell irc library. http://github.com/dom96/SimpleIRC ?
10:11:47 <BMeph> Y'know, pointer arithmetic would be fine in Haskell...if it were modeled on arithmetic using Naturals. >;)
10:12:58 <Maxdaman1us> Pointers in FP \o/
10:13:21 <BMeph> bla123: One thing to mention about RWH: it's geared for beginners to Haskell, but not beginners to programming in general. Most other beginner texts/tutorials aren't.
10:13:58 <bla123> BMeph: right, i didn't think about that
10:14:21 <sm> dom96: is there a haddock online ?
10:14:54 <bla123> maybe seasoned programmers don't like to write tutorials for programming beginners
10:14:55 <dom96> sm: no, i will probably add it to hackage soon though.
10:15:30 <danportin> I started programming approximately 1.5 months ago, and found Hutton's text (not free, unfortunately) and 'LYAH' incredibly helpful.
10:15:42 <sm> dom96: it looks useful. Could you maybe add it to http://hackage.haskell.org/package/irc ? less proliferation = more win
10:15:53 <sm> I'd use it
10:15:57 <danportin> (As introductions to programming and Haskell).
10:16:18 <sm> or get him to merge with you
10:16:23 <dom96> sm: i can do that? i didn't know i could add new packages to existings packages.
10:16:32 <smoofra> what does a ~ in a constraint mean?
10:16:33 <sm> but he's got the nice "irc" package name...
10:16:47 <sm> dom96: you'd have to collaborate with Trevor Elliot
10:16:49 <dom96> what's wrong with having simpleirc as the name?
10:16:57 <bla123> danportin: thanks for pointing that out
10:17:11 <smoofra> as in: '(Monad m, m ~ n) =>'
10:17:14 <sm> nothing. I'm just a demanding user wanting one awesome irc package so I don't have to think
10:18:01 <dom96> sm: heh, i see. Well irc is a parser for irc messages. And i already have a nice parser in simpleirc. So i don't know.
10:18:12 <ski> smoofra : equality .. imo, it should have been written as `='
10:21:05 <sm> dom96: can't hurt to ping him anyway.. I'll do it. I'll cc you if you give me your addrss
10:22:12 <dom96> sm: can i /msg it to you?
10:23:18 <sm> sure
10:23:53 <monochrom> you can always use an even nicer package name such as "better-irc"
10:24:47 <dom96> i prefer simpleirc :P
10:25:55 <smoofra> ski: thanks
10:26:13 <Raynes> Having "simple" always makes me think it isn't simple at all.
10:27:26 <monochrom> "simple group"
10:27:28 <sm> heh
10:27:42 <monochrom> "I have a simple question"
10:28:08 <monochrom> I'm sure the question is simple to state, unsolvable to solve.
10:28:14 <dom96> lol
10:28:36 <dom96> Raynes: good, because it's not really that simple :P
10:28:50 <monochrom> "I have a simple question. How do you write a program to determine whether programs halt. It's just a simple question!"
10:29:02 <sm> dom96: so is yours a superset of the irc package ? Did you look at it and decide not to use it ?
10:29:56 <dom96> sm: Yes, i did look at it. The irc package is just a parsing library. My library can connect to an IRC Server call events when certain things happen etc.
10:30:36 <sm> how come you rewrote the parsing stuff ? I'm just curious about reuse dynamics
10:30:46 <sm> I mean, rather than depending on irc
10:31:07 <Raynes> Your IRC library is a traditional library for working with IRC connections all the way down, from parsing commands to eating babies.
10:31:28 <Raynes> Put that in your README.
10:31:39 <monochrom> but I don't want to eat babies. I want to eat newbies.
10:31:51 <dom96> sm: the irc package didn't seem to work when i tried it.
10:32:00 <dom96> i.e couldn't parse anything :P
10:32:06 <sm> strange.. hackagebot uses it
10:32:16 <dom96> maybe i was just using it wrong
10:32:41 <dom96> Raynes: haha
10:33:15 <dom96> Raynes: You sure know how to make readme files funny.
10:33:39 <Raynes> dom96: If only I could make my own READMEs funny. :(
10:33:56 <dom96> Raynes: add that to your IRC libs README then.
10:34:09 <jystic> unsafeParseAndEatBabies
10:34:29 <Raynes> But mine isn't funny at all! In fact, mine is so serious, it makes Ben Stein sound exciting.
10:46:37 <aristid> haddock says "We do not support associated types in instances yet." :(
10:46:50 <aristid> <- considering switching back to fundeps
10:47:28 <ezyang> Yeah, it's kind of annoying. 
10:47:58 <duckinator> hi
10:48:41 <sm> dom96: your bot looks nice
10:49:20 <sm> is the functionality similar to lambdabot ?
10:50:25 <dom96> sm: all it can do currently is eval code, so yeah. But i'm not really aiming at the same functionality as lambdabot. Although it's gonna be very easily extensible, thanks to modules.
10:50:52 <dom96> So you could create modules which resemble lambdabots functionality
10:51:06 <sm> lambdabot has modules too I guess
10:51:29 <sm> looks like you reload yours at runtime, which is nice
10:51:46 <dom96> yeah, it seems to take a lot of memory though.
10:52:07 <kmc> i really liked lunabot, which only did eval, but had loaded into the namespace some lambdabot-like plugins as ordinary Haskell functions, e.g.
10:52:17 <kmc> , type [| Just 3 |]
10:52:52 <sm> your lib seems to be an ircbot lib as well as basic irc utilities
10:52:57 <kmc> and some sugar so you could say «#type Just 3» instead
10:53:20 <dom96> sm: yeah
10:54:04 <dom96> kmc: supporting lambdabots plugins would be nice. I think i might try implementing that.
10:57:08 <harlekin> Concerning reactive, why is whenE (pure False) (atTimes [1..]) consuming so much memory?
10:58:02 <aristid> hahaha unsafeDoggeh#
10:58:55 <aristid> does haddock support fundeps fully?
10:59:10 <aristid> if so, that would be a good reason to move back to fundeps from type families :P
11:00:24 <zygoloid> iirc fundeps are more powerful too (until we get superclass equalities)
11:00:27 <roconnor> newtype Rec a = Roll (a (Rec a)) -- I think I've just been Rec Roll'd.
11:01:05 <ezyang> roconnor: Waggggh 
11:01:55 <aristid> zygoloid: i somehow also like the syntax better
11:02:00 <c_wraith> Is that fundamentally different than Mu?
11:02:15 <kmc> @src Mu
11:02:15 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
11:02:22 <c_wraith> So, no
11:02:25 <zygoloid> aristid: weird. that's the one big thing i think type families have over fundeps
11:02:40 <aristid> zygoloid: well, it's so repetitive
11:02:52 <harlekin> conal, ping
11:03:33 <zygoloid> but it's so much clearer ;)
11:04:36 <roconnor> data Rec a b = Roll (a (Rec a b)) | Place b
11:04:40 <ski> well, fundeps are more symmetric
11:05:22 <aristid> when you have a "data" with many type parameters, do you have a method for sorting them?
11:05:37 <ski> cf. `class C a b c | a b -> c , a c -> b , c -> a' with the corresponding AT version
11:05:55 <benc___> any clues why +RTS -N2 gives me the runtime help message but +RTS -N1 runs? I'm building with -threaded...
11:06:08 <ski> aristid : same as with function, arguments which "change more often" go later
11:06:27 <aristid> ski: ok, that requires thinking
11:06:57 <ski> aristid : also, consider that for e.g. `StateT' to be a monad transformer, the `s' has to be before the `m' and `a' (in that order) in `StateT s m a = ...'
11:07:33 <aristid> ski: yeah i have the situation where i have a couple of datas with many type parameters to make them generic
11:07:38 <ski> (for `RWS' the `r',`w',`s' parameters similarly go before `m' and `a')
11:07:57 <aristid> and they aren't in a standard typeclass
11:07:59 <c_wraith> ski, if there's an m, it was RWST
11:08:10 <ski> er, that's right
11:08:20 <ezyang> hpaste needs spam filtering 
11:08:20 <ski> aristid : so, no `Functor' even ?
11:08:24 <aristid> or is having many type parameters in a data a sign of some mistake? something that can be avoided?
11:08:46 <c_wraith> aristid, that depends entirely on what you're doing.
11:08:54 <aristid> ski: no, the type parameter for which that would make sense has constraints
11:08:58 <ski> aristid : not a mistake, imo .. though in some cases type records (or even type tuples) would be really handy
11:09:04 <aristid> well, no constraints
11:09:13 <aristid> but all functions using it have them
11:09:21 <Saizan> or you could parametrize over an higher-kinded one
11:09:27 <aristid> ski: type tuples exist :)
11:09:35 <ski> aristid : where ?
11:09:36 <Saizan> inversion of control at the type level.
11:09:45 <aristid> ski: (A, B, C)
11:10:00 <ski> aristid : note that type tuples is distinct from product types (i.e. types of tuple values)
11:10:14 <aristid> ski: what is a type tuple, then?
11:10:25 <ski> aristid : a type tuple would be something with kind like `(*,*,* -> *)', e.g.
11:10:37 <int80_h> entryFileNames <- processPaths <$> getDirectoryContents d
11:10:49 <aristid> @where lyah
11:10:50 <lambdabot> http://www.learnyouahaskell.com/
11:10:53 <aristid> int80_h: read that.
11:10:54 <ski> so, instead of saying `(* -> *) -> (* -> *)', that could be uncurried into `(* -> *,*) -> *'
11:11:03 <int80_h> I keep forgetting what people tell me about <$>, can we go through what this means again?
11:11:13 <ski> int80_h : `fmap'
11:11:16 <int80_h> I'm reading it right now
11:11:24 <int80_h> functors, right.
11:11:34 <ski> aka `liftM', in the monad case
11:11:39 <ski> @src liftM
11:11:39 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:12:24 <aristid> ski: another style question... i can avoid UndecidableInstances by adding one or two type parameters to my datas. should i do that?
11:12:55 <int80_h> so <$> is lifting the results of getDirectory d into a monad processPaths can use, which then takes that and binds it's output to entryFileNames?
11:13:33 <ski> aristid : the point being that instead of having `data Foo o p q r s t a = ...' you could say `data Foo <o,p,q,r,s,t> a = ...' (or whatever syntax should be used for the type tuples (damn you Haskell for stealing the nice tuple syntax on the type level for product types ;))
11:13:43 <ski> aristid : depends
11:14:06 <ski> @type System.Directory.getDirectoryContents
11:14:07 <lambdabot> FilePath -> IO [FilePath]
11:14:42 <int80_h> > let processPaths = map (d </>) . filter (`notElem` [".",".."])
11:14:43 <lambdabot>   not an expression: `let processPaths = map (d </>) . filter (`notElem` ["."...
11:14:52 <int80_h> hmmm
11:15:05 <ski> int80_h : `getDirectoryContents d' has type `IO [FilePath]' .. `(<$>)' (or `fmap' or `liftM') allows you to run a function of type `[FilePath] -> Blah' on that, getting `IO Blah' as a result
11:15:14 <ski> int80_h : so
11:15:18 <ski>   entryFileNames <- processPaths <$> getDirectoryContents d
11:15:21 <ski> is the same as
11:15:40 <ski>   files <- getDirectoryContents d
11:15:46 <aristid> ski: it's like this: data Foo a b c where c is always fully determined by a fundep of a relevant type class. when doing data A a b instead, ghc complains that it needs UndecidableInstances. right now, i have added UndecidableInstances, but somehow i'm a bit scared by that
11:15:49 <ski>   let entryFileNames = processPaths files
11:15:54 <ski> int80_h : ^
11:15:54 <Zao> (except for not introducing the `files' name)
11:16:00 <ski> right
11:16:00 <aristid> (right now it's also no fundep but an AT)
11:17:12 <ski> aristid : well, i don't really see why it wants `UndecidableInstances', so i can't comment
11:17:29 <int80_h> :t </>
11:17:30 <lambdabot> parse error on input `</>'
11:17:38 <ski> @type (</>)
11:17:39 <lambdabot> Not in scope: `</>'
11:17:44 <ski> @type (System.Directory.</>)
11:17:45 <lambdabot> Not in scope: `System.Directory.</>'
11:17:50 <Zao> ski: FilePath?
11:17:51 <int80_h> huh
11:17:52 <ski> @index (</>)
11:17:52 <lambdabot> Text.Html
11:18:03 <int80_h> let processPaths = map (d </>) . filter (`notElem` [".",".."])
11:18:04 <c_wraith> aristid, UndecidableInstances isn't that bad.  It just means that the type checker can't guarantee type-checking will terminate.
11:18:15 <int80_h> this is the line that uses it, I'm trying to figure out what it does.
11:18:19 <c_wraith> aristid: IncoherentInstances is the one to be afraid of.
11:18:21 <int80_h> starting with getting it's type.
11:18:22 <ski> Zao : ?
11:18:42 <aristid> c_wraith: so if it buys me some simplicity, i should go for it?
11:18:59 <Zao> http://hackage.haskell.org/packages/archive/filepath/1.1.0.2/doc/html/System-FilePath-Posix.html#v%3A<%2F>
11:19:05 <Zao> (same function for .Windows)
11:19:09 <ski> int80_h :  filter (`notElem` [".",".."])  removes the non-proper file names `"."',`".."' from the list of files in the directory
11:19:09 <c_wraith> aristid: yeah, it's pretty safe.
11:19:26 <ski> @index (System.FilePath.Posix.</>)
11:19:26 <lambdabot> bzzt
11:19:51 <ski> int80_h : also, s/it's/its/ :)
11:19:54 <int80_h>  ski: yeah I got that, but don't know what the </> in map (d </>) is doing.
11:20:04 <c_wraith> ski: it's an operator section.
11:20:12 <c_wraith> err, sorry, that was meant for int80_h 
11:20:16 <Zao> int80_h: </> for FilePaths appends a component in the path.
11:20:20 <c_wraith> int80_h, that operator is path concatenation
11:20:35 <Zao> "C:\\awesome" </> "stuff" produces "C:\\awesome\\stuff"
11:20:54 <int80_h> got it
11:21:01 <ski> int80_h : well, if `d' is a directory path and `f' a (relative) file path, then `d </> f' is a file path that first searches according to `d', then according to `f'
11:21:10 <Zao> Beats the crap out of ++"/"++ for portability.
11:21:22 <c_wraith> Also, easier to read :)
11:21:43 <int80_h> I'm trying to get away from book haskell and into idiomatic haskell.
11:22:01 <int80_h> so learning things like this helps.
11:22:08 <ski> @type let foo = "foo" in (++ "/" ++ foo)
11:22:09 <ski> @type let foo = "foo" in (foo ++ "/" ++)
11:22:09 <lambdabot> [Char] -> [Char]
11:22:10 <lambdabot>     The operator `++' [infixr 5] of a section
11:22:10 <lambdabot>         must have lower precedence than that of the operand,
11:22:10 <lambdabot>           namely `++' [infixr 5]
11:22:15 <c_wraith> There isn't a single idiomatic haskell, either. :)
11:24:54 <sm> how can I write a function that can be used like putStr, but takes arguments like printf ?
11:25:00 <sproingie> looking at the source of stuff on hackage, it runs the range from nicely factored "book haskell" to obfuscated one-liners
11:25:18 <sm> I have putDebugStr :: (PrintfType r) => String -> IO r, but it needs to be IO ()
11:25:23 <sm> apparently
11:26:45 <Saizan> isn't printf already that function?
11:27:27 <Saizan> if you use it in an IO context it'll print to stdout
11:27:29 <tafryn> What's the best way to get at the n-th item in an infinite list?
11:27:45 <osfameron> tafryn:    list !! n    ?
11:28:16 <sm> Saizan: yes, that's true, and I do. But I'd like to define variants of this that do different things depending on --verbose, --debug etc.
11:28:17 <tafryn> osfameron: Thanks.
11:28:29 <sm> one might print to stderr, eg
11:29:09 <sm> putDebugStr   = putStr . printf  is not right
11:29:16 <Saizan> look at Text.Printf source then
11:30:09 <Saizan> you could write a generic curry/uncurry which would let you to do that kind of composition quite easily
11:30:27 <Saizan> but i'm not sure how many olegs of type hackery you're willing to allow :)
11:30:49 <monochrom> pointfree does not mix well with the var-arg technique used by printf. try not to be pointfree.
11:31:30 <sm> Saizan: exactly.. I can't/don't want to spend too many olegs
11:31:31 <monochrom> this is because this var-arg technique relies exactly on seeing explicit arguments
11:32:11 <monochrom> it is also the same story with ocaml's printf. slightly different technique but equally relies on seeing explicit arguments.
11:32:29 <ski> tafryn : or `genericIndex', if you want to, say, index with `Integer's
11:33:09 <ski> (yeah, O'Camls `printf' is strange)
11:34:01 <monochrom> oCamlCase :)
11:34:25 * monochrom now wonders why it is not called javaCase
11:34:57 <Saizan> sm: bos was having roughly the same problem here, see the comments for solutions http://www.serpentine.com/blog/2009/09/25/riddle-me-this/
11:35:52 <luite> monochrom: sun (or now oracle) would sue you for using their trademarks
11:37:19 <sm> ah, that looks quite helpful thanks
11:42:36 <luite> wow that package almost has more language extensions than lines of code :)
11:42:56 <Saizan> which?
11:43:11 <luite> generalized Uncurry
11:43:59 <Saizan> heh, yeah, that scares off some people, i still don't know why ;)
11:47:29 <siracusa> luite: What's the package name for this?
11:48:10 <luite> siracusa: don't know, it's on hpaste: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9857
11:49:31 <luite> siracusa: it was linked to in a reply by Saizan to a the blog post he mentioned earlier
11:50:25 <siracusa> Ah okay
12:01:15 <benmachine> Saizan: what's the difference between instance (b ~ HTrue) => IsFunction (a -> c) b and instance IsFunction (a -> c) HTrue
12:04:47 <dolio> The former may not be correctly implemented yet?
12:05:46 <benmachine> the former is what's in the hpaste :P
12:06:07 <dolio> They probably work on instances, actually. I think it's classes they don't work on.
12:06:11 <copumpkin> it's only superclasses, yeah
12:06:36 <copumpkin> eww, HTrue :P
12:06:43 <dolio> The former has somewhat different character, too.
12:06:51 <danewbie> hey guys
12:07:13 <danewbie> do you know whether mutable boxed arrays still have problems with the GC?
12:07:24 <dolio> It declares an instance of IsFunction for all b, with the caveat that there must be an equality (b ~ HTrue).
12:07:32 <Lambdanaut> If my main function in haskell is just a recursive loop that calls itself infinitely, will it overflow the stack or anything similar? 
12:07:34 <c_wraith> No, that was fixed somewhere in GHC 6.8.x, I think
12:07:39 <dolio> danewbie: It's supposed to have gotten better.
12:07:40 <danewbie> uhm
12:07:50 <Lambdanaut> would it be good coding practice is what I mean
12:07:51 <dolio> They added card marking recently.
12:07:54 <danewbie> yes, i found that that bug was closed
12:07:59 <danewbie> http://hackage.haskell.org/trac/ghc/ticket/650
12:08:01 <danewbie> this one
12:08:03 <danewbie> but...
12:08:06 <c_wraith> Oh, was it more recent?
12:08:15 <dolio> I think it's in 6.12, but I'm not certain.
12:08:19 <danewbie> i'm having troubles with what seems to be related to this
12:08:28 <c_wraith> Yeah, the ticket says it was in 6.12
12:08:33 <danewbie> i have tried also with 6.13.20100525
12:08:45 <danewbie> and same behavior
12:09:00 <danewbie> if you care to take a look
12:09:05 <danewbie> http://pastebin.com/BH3c3qrG
12:09:21 <danewbie> i've put the same function
12:09:31 <danewbie> using immutable arrays
12:09:34 <danewbie> immutable arrays
12:09:41 <danewbie> and mutable vectors
12:10:15 <danewbie> and for mutable and immutable arrays, the unboxed versions use linear/constant memory
12:10:20 <danewbie> but with the boxed ones...
12:10:42 <benmachine> Lambdanaut: it won't stack overflow
12:10:50 <danewbie> no
12:10:55 <Lambdanaut> thankya
12:10:58 <danewbie> but uses quite a lot of memory
12:11:06 <danewbie> (with the boxed arrays)
12:11:19 <danewbie> and most of the time is spent by the GC
12:11:43 <dolio> danewbie: Given the stuff in your comment, I don't see how the problem you're encountering could be the bug you think it is.
12:11:56 <danewbie> it's just a recursion tree over all the subsets of a list
12:12:02 <danewbie> dolio: why?
12:12:22 <danewbie> i mean, when i use unboxed arrays, the program is fine
12:12:25 <dolio> Immutable boxed arrays had no problems with GC.
12:12:32 <danewbie> aha
12:12:56 <danewbie> thought maybe ghc translated internally to mutable arrays
12:13:02 <dolio> And mutable vectors use the same underlying implementation as the arrays.
12:13:05 <danewbie> because its kind of an acumulator
12:13:25 <danewbie> don't know if ghc is able to do this kind of optimization...
12:13:33 <dolio> No, it doesn't do that.
12:13:41 <danewbie> then i'm lost...
12:14:46 <danewbie> it seemed to me that it could be that bug because the unboxed version behaved nice
12:17:02 <dolio> Modification of immutable arrays copies the whole array, but that's true for unboxed arrays, too.
12:17:30 <danewbie> but the unboxed immutable arrays behave "correctly"
12:18:54 <Saizan> benmachine: that the latter makes the typechecker cry :)
12:20:39 <dolio> danewbie: I suspect the problem with the immutable boxed arrays are that you're creating copies of the array that differ by only one element, and reference the old array in that element.
12:21:03 <danewbie> ok, that could be true
12:21:18 <dolio> And since they're lazy, they store a thunk. that references the old array, rather than storing a thunk pointing to whatever the old array referenced.
12:21:20 <danewbie> actually, i only tried that version to compare with the mutable array version
12:21:51 <danewbie> what bothers me most is the problem with the mutable boxed arrays
12:21:59 <Saizan> benmachine: but, more generally, equality constraints like that help because they are imposed only after the instance is chosen, so they add more information about the type rather than requiring it for the instance to match
12:22:14 <dolio> So, you're building a huge chain of arrays that can't be collected until you start actually evaluating the final results.
12:22:22 <danewbie> aha
12:22:33 <danewbie> is there a way to force the evaluation?
12:22:35 <dolio> Which explains the exponential behavior if this has something to do with powersets.
12:22:51 <danewbie> yes, it's a version of powersets
12:23:15 <dolio> danewbie: Unboxed arrays keep their elements fully evaluated, which is why they work well for this problem.
12:23:22 <danewbie> i see
12:23:52 <danewbie> uhm
12:24:09 <danewbie> so, checking each element of the new array
12:24:18 <danewbie> should force its evaluation, right?
12:24:54 <danewbie> uhm
12:25:16 <danewbie> no, what you say is that i should force the only element that i updated
12:25:19 <danewbie> i'll try
12:26:13 <dolio> Try 'let v = arr2 IA.! newUsed + newAccum in v `seq` arr2 IA.// [(newUsed, v)]' in the relevant spot.
12:27:14 <danewbie> let's see...
12:30:03 <danewbie> nice!
12:30:08 <danewbie> it was that!
12:30:13 <danewbie> thanks!
12:31:06 <dolio> I'm not really sure what the deal with the other two is, then.
12:31:36 <dijxtra> Howdy everybody, I want to write a highly concurrent application, so I learned Erlang to do it. But then it turned out Erlang doesn't have vector/matrix library (and many more libraries Haskell has). Today I tried Haskell (at tryhaskell :-D) and fell in love.
12:31:42 <danewbie> i'm trying the same solution, but i don't think it should work...
12:31:45 <dijxtra> So, how stable is Haskell as a concurrent language? Is it ready for production environment? If you had a multi-million project that has to have few thousand concurrent processes and be rock solid, would do it in Haskell?
12:31:45 <dolio> Vector stuff should behave about the same as Array stuff, so if the unboxed arrays are slow there, I don't know why.
12:33:00 <dolio> danewbie: It may be, I suppose, that card marking doesn't solve performance problem well enough for the boxed mutable arrays for your program.
12:33:38 <danewbie> uhm
12:33:40 <tafryn> Is there anything in Data.Time apart from Clock.POSIX that provides millisecond time resolution?
12:33:48 <danewbie> it's a bit stressing, indeed
12:34:05 <dolio> It divides the arrays into chunks of size K, and if you dirty any chunk, it has to do the same thing as it used to do.
12:34:32 <dolio> That is, it has to do it for just that chunk.
12:34:41 <danewbie> well, but in fact
12:34:48 <danewbie> my arrays are quite small
12:35:02 <danewbie> so i don't think that strategy will make any difference, here
12:35:27 <danewbie> i tried the same change with the mutable boxed arrays, but didn't work
12:35:44 <dolio> It's not surprising that it wouldn't.
12:35:54 <danewbie> yep, but i had to try :-)
12:36:15 <dolio> There's no array copying going on, so you don't have to worry about hanging on to references to old arrays.
12:37:05 <dom96> Is there any way i can lower the memory usage of a haskell application, i.e determine why it's using so much memory?
12:37:42 <danewbie> dom96: welcome to the club :-P
12:37:59 <Raynes> Wah wah wah. People are so afraid to use their precious and abundant RAM these days.
12:38:01 <dom96> lol, are you trying to do the same thing?
12:38:16 <danewbie> yes, hehe
12:38:42 <dom96> I know my problem has something to do with me loading modules using the 'hint' package
12:38:50 <danewbie> have you identified what part of your program is using most of it?
12:38:56 <dom96> every time i reload the modules it starts using more and more memory
12:39:00 <dom96> ^^
12:39:11 <dolio> danewbie: How much memory (not GC time) do the mutable boxed versions use?
12:39:34 <dolio> Is that exponential?
12:39:56 <danewbie> for the [1..18] list, 21MiBs
12:40:01 <danewbie> and it seems so
12:40:14 <dom96> I'm using an MVar.
12:40:20 <danewbie> yes, 19 -> 41
12:40:22 <danewbie> etc
12:40:24 <dom96> To store the loaded modules as a list
12:40:40 <dolio> Well then, I still don't think bad array gc behavior is the culprit.
12:41:02 <danewbie> something related to laziness, then?
12:41:04 <dolio> We're probably building too many thunks.
12:41:20 <dom96> can someone help me ? :(
12:41:58 <danewbie> dom96: can you be more specific?
12:43:16 <dolio> danewbie: What did you change when you tried making the mutable algorithms more strict?
12:43:33 <danewbie> aha
12:43:39 <danewbie> i've found part of the culprit
12:44:04 <danewbie> the newAcum parameter used on the second call to subsets'
12:44:12 <danewbie> was not evaluated, it seems
12:44:23 <danewbie> forcing it reduced the amount of memory used
12:44:27 <dolio> Yeah. Keeping the accumulators strict is a good idea.
12:44:53 <dom96> danewbie: http://github.com/dom96/ElysiaBot/blob/master/elysia.hs#L28
12:45:34 <dolio> Maybe GHC is smart enough to do that automatically for unboxed arrays.
12:45:35 <danewbie> dom96: let me try to fix this first, please
12:45:47 <dolio> And not for unboxed vectors for some reason.
12:45:53 <dom96> ok
12:45:57 <danewbie> but it was a parameter of the function call
12:46:00 <danewbie> weird
12:49:34 <danewbie> done!
12:50:22 <danewbie> i needed to force both the MyInt acumulator in the function call, and the elements in the array
12:50:32 <danewbie> thank you very much :-)
12:50:46 <dom96> now can someone help me :P ?
12:50:53 <danewbie> let's see
12:51:03 <dom96> wait, i'll push my changes...
12:51:05 <danewbie> not that i know that much haskell, but let's try it
12:51:07 <danewbie> ok
12:51:57 <benmachine> dom96: peekMVar = readMVar?
12:52:18 <dom96> benmachine: takeMVar
12:52:20 <dom96> i just pushed
12:52:39 <dom96> i tried using newMVar there
12:53:27 <benmachine> dom96: sorry I was talking about something irrelevant
12:53:36 <benmachine> your peekMVar function
12:53:43 <dom96> ok...
12:53:44 <benmachine> is the same as readMVar so far as I can see
12:54:00 <dom96> hrm
12:54:25 <dom96> yeah, it is. I must have missed it. Thanks
12:57:54 <dom96> Anyway, any ideas why the memory usage goes up to about 87mb whenever i execute |reload a couple of times?
12:59:20 <danewbie> is the "Modules" a module made by you?
12:59:23 <danewbie> or...?
13:00:50 <roconnor> @hoogle Control.Monad.void
13:00:50 <lambdabot> No results found
13:00:57 <roconnor> @type Control.Monad.void
13:00:58 <lambdabot> Not in scope: `Control.Monad.void'
13:01:09 <roconnor> what is Control.Monad.void ?
13:01:32 <dolio> m a -> m (), I think.
13:01:32 <dom96> danewbie: yes
13:01:50 <dom96> danewbie: two modules to be exact, they're in the modules directory
13:01:55 <roconnor> hmm
13:02:30 <dolio> roconnor: Useful for the people who want (>>) to have type like m () -> m b -> m b.
13:02:30 <roconnor> dolio: what is the use case for void?
13:02:42 <roconnor> ... but >> doesn't have that type
13:02:56 <dolio> @type forkIO
13:02:57 <lambdabot> Not in scope: `forkIO'
13:03:03 <dolio> @hoogle forkIO
13:03:03 <djahandarie> void would be nice
13:03:03 <edwardk> roconnor: it saves you the typing of () <$ ;)
13:03:03 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
13:03:16 <dolio> roconnor: That's one.
13:03:19 <roconnor> ok
13:03:20 <dolio> forkIO (void m)
13:03:38 <roconnor> you know.  we worked very hard to make forever not have that type.
13:03:51 <djahandarie> @hoogle forever
13:03:52 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
13:03:55 <dolio> Did we?
13:04:14 <dolio> It's the principal type of the usual implementation.
13:04:14 <roconnor> dolio: ya we had to remove the extra type constraint that was there for no good reason.
13:04:33 <roconnor> isn't the right solution to fix forkIO?
13:04:46 <dom96> Anybody? any ideas?
13:04:52 <dolio> roconnor: I think some people want to go in the opposite direction as you.
13:04:53 <djahandarie> A better forkIO would be nice
13:04:58 <roconnor> not that we can't having both void and fix forkIO
13:05:07 <djahandarie> > fix forkIO
13:05:08 <lambdabot>   Not in scope: `forkIO'
13:05:12 <djahandarie> damn!
13:05:17 <danewbie> uhm
13:05:26 <dolio> roconnor: And write 'do ... ; void m ; ...' and such.
13:05:28 <dom96> :\
13:05:30 <danewbie> dom96: have you tried to unload all the modules before reloading them
13:05:32 <danewbie> with reset?
13:05:33 <c_wraith> :t forkIO
13:05:34 <lambdabot> Not in scope: `forkIO'
13:05:41 <c_wraith> :t Control.Concurrent.forkIO
13:05:43 <lambdabot> IO () -> IO GHC.Conc.ThreadId
13:05:44 <roconnor> dom96: have you run a heap profile?
13:05:48 <dom96> danewbie: no, i'll try it now
13:05:53 <c_wraith> You can't fix that anyway. :)
13:05:56 <dom96> roconnor: no?
13:06:11 <dom96> roconnor: never even heard of that
13:06:16 <dolio> GHC already warns when you have 'do ... ; e :: m a ; ...' instead of 'do ... ; _ <- e ; ...' with -Wall.
13:06:20 <djahandarie> > fix (Control.Concurrent.forkIO >> return ())
13:06:21 <lambdabot>   Not in scope: `Control.Concurrent.forkIO'
13:06:31 <roconnor> c_wraith: I can't fix what?
13:06:43 <c_wraith> oh, "forkIO"
13:06:48 <c_wraith> It doesn't have the right type signature.
13:07:34 <c_wraith> :t (() <$) . Control.Concurrent.forkIO
13:07:35 <lambdabot> IO () -> IO ()
13:07:39 <aristid> changing from type families to fundeps saves 12% of my code (counting LOC)
13:07:45 <c_wraith> Now, that...
13:07:56 <aristid> 533 lines with tf -> 468 lines with fundeps
13:07:58 <djahandarie> Would running a type level fix on that screw lambdabot up?
13:08:14 <aristid> :t (<$)
13:08:14 <djahandarie> Nevermind that makes no sense
13:08:15 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
13:08:18 <c_wraith> :t fix $ (() <$) . Control.Concurrent.forkIO
13:08:19 <lambdabot> IO ()
13:08:29 <c_wraith> Of course, running that won't result in a fork bomb.
13:08:38 <c_wraith> It'll never actually execute the forkIO
13:08:41 <c_wraith> because it will never terminate.
13:09:06 <dom96> danewbie: that doesn't help :\
13:09:14 <danewbie> oh...
13:10:06 <dom96> it jumps from 27mb to 40mb with just one |reload
13:10:43 <danewbie> and with another one?
13:10:58 <dom96> 61mb
13:11:05 <danewbie> ok...
13:11:15 <dom96> with another one 71..
13:11:34 <dom96> 82.
13:11:34 <sm> ack! just bit by the need for LANG with ghc 6.12 binaries, again
13:11:55 <dom96> and it stops there
13:12:17 <danewbie> even although you reload them once again?
13:12:25 <dom96> yes
13:12:56 <dom96> well, it goes up by .1 mb
13:13:00 <dom96> i think
13:13:46 <dom96> i think now it's completely halted at 88.6
13:14:46 <danewbie> and what do you do with the plsMVar that you create every time you reload?
13:15:16 <dom96> It just gets read
13:15:26 <danewbie> and discarded?
13:15:38 <danewbie> or do you store them somewhere?
13:16:12 <dom96> they are discarded
13:17:07 <danewbie> then i have no idea
13:24:10 <dom96> Anybody else any ideas?
13:24:32 <copumpkin> I have lots of ideas
13:25:57 <dom96> Do any of them fix my memory usage problem ?
13:26:37 <copumpkin> doubt it
13:26:50 <dom96> aww
13:28:52 <sm> dom96: run with the ghc RTS option that logs memory usage on stdout, sprinkle print statements through your code, and you might get some clues about when it happens
13:29:08 <dom96> sm: I know when it happens
13:29:20 <c_wraith> dom96, the only thing I can think of is that maybe you're not fully evaluating something
13:29:33 <c_wraith> But you're holding on to a reference to it somewhere.
13:29:38 <c_wraith> Usually, that's a small space leak
13:29:53 <c_wraith> but when it's the only thing holding on to interpreted code, it could add up fast
13:30:17 <davidL> how is this explained? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29302#a29302
13:30:25 <c_wraith> have you tried throwing a deepseq at the results of your interpreted computation?
13:30:39 <dom96> a deepseq?
13:30:52 <danewbie> to force its full evaluation
13:31:08 <dom96> no...
13:31:33 <danewbie> though you'll need that your result is an instance of NFData
13:31:58 <c_wraith> it's usually not too bad to write NFData instances
13:32:24 <copumpkin> in general you shouldn't need deepseq
13:32:28 <copumpkin> except for parallel code maybe
13:32:48 <c_wraith> deepseq is often a useful hammer to smack at places to see which is responsible for a space leak
13:33:02 <c_wraith> Then you go back with less clumsy tools to fix it appropriately
13:33:30 <dom96> i'm just getting a value of two variables
13:33:30 <FunctorSalad_> btw what is controversial about NFData? ddarius said that `rnf' is evil iirc
13:33:42 <FunctorSalad_> but I had missed the context...
13:33:43 <dom96> And their types are. M.Map B.ByteString CmdFunc
13:33:51 <dom96> where CmdFunc = (IrcMessage -> IO B.ByteString)
13:33:58 <c_wraith> Ah.
13:34:01 <FunctorSalad_> so maybe it was kidding :)
13:34:08 <danewbie> the map
13:34:21 <danewbie> is not strict on its values
13:34:31 <c_wraith> Those values can't be strictified anyway
13:34:41 <dom96> So what do i do?
13:34:45 <c_wraith> Holding on to them *is* going to hold on to your interpreted code, no matter what.
13:35:05 <dom96> How do i release them then?
13:35:07 <copumpkin> FunctorSalad_: I don't think anything is evil about it. Just that you shouldn't use it in regular code beyond diagnostics, or parallel stuff
13:35:12 <copumpkin> FunctorSalad_: but I didn't see what he said
13:35:17 <c_wraith> dom96: let them get garbage collected.
13:35:31 <dom96> And how do i do that?
13:35:40 <FunctorSalad_> copumpkin: it doesn't do anything outlawed that goes beyond seq, does it?
13:35:46 <copumpkin> not at all
13:35:50 <FunctorSalad_> iirc it's just a convenience for lots of seqs
13:35:53 <FunctorSalad_> o_o
13:35:55 <c_wraith> make sure that the map is not in scope at some point in your program's execution.
13:36:13 <c_wraith> FunctorSalad: it's just that it's usually overkill, and rather clumsy overkill at that.
13:36:20 <FunctorSalad_> ic
13:36:46 <CakeProphet> I'm truly amazed that most languages don't support custom operators.
13:37:02 <FunctorSalad_> after haskell?
13:37:03 <dom96> c_wraith: i'm pretty sure it's not
13:37:19 <nlogax> anyone know what's up with lambdabots Seen plugin if it says "Plugin `seen' failed with: too few bytes. Failed reading at byte position 8" ?
13:37:23 <CakeProphet> FunctorSalad_:  yes, after Haskell.
13:37:48 <Saizan> nlogax: the state got corrupted
13:37:55 <nlogax> Saizan: ohh
13:38:14 <davidL> preflex: seen ddarius
13:38:14 <preflex>  ddarius was last seen on #haskell 16 hours, 3 minutes and 52 seconds ago, saying: Necessary versus contingent.
13:38:21 <dom96> c_wraith: the only place i use it is in my callCmd function. It's not like i'm returning it...
13:39:01 <c_wraith> dom96: well, is it possible you're not forcing the result of your callCmd function promptly?
13:39:27 <dom96> c_wraith: 'ret <- callCmds (Just prefix) m mods' I think that's forcing the result promptly
13:39:30 <c_wraith> oh, right, this is your irc lib.  I should just look at the source :)
13:39:38 <dom96> it's in my bot
13:39:47 <dom96> not in the irc library
13:39:48 <c_wraith> oh, your bot, not the lib?
13:39:54 <dom96> but the source of the bot is on github too
13:40:09 <dom96> http://github.com/dom96/ElysiaBot
13:40:15 <c_wraith> that line doesn't guarantee that it forces any part of ret, which is the value I'm wondering about.
13:40:28 <Philonous> FunctorSalad_: I think it uses pseq rather than seq (though it is up to the instance implementor)
13:40:32 <`Zerax`> Quickcheck question: Is there anyway to define a property such that I could change how arbitraries are generated? Essentially I've defined a synonym for a numeric type, the range of possible values is much smaller than the underlying type so I want to restrict the values that are generated while testing the property so that I get better coverage of valid input values.
13:40:56 <FunctorSalad_> Philonous: I'm afraid I haven't heard of pseq
13:40:56 <dom96> callCmd filters through the commands, and then calls the functions that are appropriate
13:41:19 <dom96> callCmd returns the return values of those functions
13:41:20 <danewbie> Zerax: is sized useful to you?
13:41:55 <c_wraith> dom96, what file/line were you referring to above?
13:42:09 <dom96> http://github.com/dom96/ElysiaBot/blob/master/elysia.hs#L41
13:42:24 <danewbie> (and resize)
13:42:26 <`Zerax`> Possibly
13:42:40 <`Zerax`> I'm not sure my brain is large enough to understand how though. 
13:42:49 <`Zerax`> quickcheck documentation seems a bit .. thin on the ground
13:42:53 <danewbie> if you only want to reduce the size of the input
13:44:22 <`Zerax`> Thanks for the advice, I'll see what I can do with it.
13:44:44 <c_wraith> dom96, not that this is related, but you know that lines 66 and 67 could be collapsed to one line, right? :)
13:45:11 <danewbie> for instance
13:45:27 <Philonous> FunctorSalad_: I believe the difference between pseq and seq is that pseq a b guarantees that a will be evaluated before b.
13:45:29 <dom96> c_wraith: yes
13:45:30 <danewbie> sized $ \n -> resize (n `div` 2) arbitrary
13:45:48 <c_wraith> Philonous, yes, that's correct.
13:45:54 <danewbie> will return the original generator, but with the size parameter halved
13:46:01 <danewbie> you can put a max there, if you want
13:46:07 <danewbie> or something like that
13:46:10 <ezyang> I wonder if it would be possible to make GHC maintain extra data on the "stack" so that GDB would be able to get some information. 
13:46:19 <Philonous> FunctorSalad_: wheres seq only guarantees that a will be evaluated, but not necessarily before b
13:46:23 <`Zerax`> I guess my question is, I don't know how to supply the generator to quickCheck or whatnot.
13:46:29 <danewbie> ah
13:46:39 <danewbie> i use to make newtypes
13:46:53 <danewbie> and declare them instances of Arbitrary
13:47:10 <danewbie> then in the arbitrary function do what i want
13:47:27 <`Zerax`> Ah, I see. I was sort of hoping there was a shorter way to do it. 
13:47:29 <c_wraith> dom96: also, peekMVar is the same as readMVar
13:47:35 <`Zerax`> Ok, cool.
13:47:41 <dom96> c_wraith: yeah, someone already told me.
13:47:45 <c_wraith> oh, ok.
13:47:48 <dom96> still haven't pushed...
13:47:50 <c_wraith> anyway.
13:47:56 <dom96> those little fixes
13:47:57 <c_wraith> I'm not fully clear on something.
13:48:06 <dom96> what do you not get?
13:48:09 <c_wraith> let me straighten out the question in my head, first :)
13:48:19 <dom96> heh, ok
13:50:00 <dh__> Does anybody knows where I can find some tutorial on ArrowLoop? Especially it's use with Yampa?
13:52:23 <c_wraith> dom96: This doesn't explain your problem, but line 31 makes me *really* suspicious
13:52:48 <dom96> i changed that to swapMVar btw
13:52:58 <c_wraith> ah.  that's not cosmetic
13:53:10 <dom96> wait i'll push all my changes so far...
13:53:10 <c_wraith> that's a significant semantic change :)
13:53:35 <c_wraith> you were shadowing.  swapMVar is actually updating the contents, which is far more correct :)
13:54:10 <dom96> yeah, i actually had swapMVar at the beginning. But then i changed it to newMVar because i thought it would help with the memory usage
13:54:16 <dom96> but it just caused more problems
13:54:37 <dom96> ok, i pushed
13:54:43 <c_wraith> well, among other things, it would break reloading. :)
13:55:00 <dom96> indeed :)
13:56:23 <c_wraith> well, line 31 is clean then...
13:56:38 <dh__> for example, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29304#a29304,  when I run it , it seemed enter a dead loop.
13:56:56 <dom96> ok.
13:57:27 <c_wraith> Where is IrcModule defined?
13:57:32 <c_wraith> in Modules.hs?
13:57:36 <dom96> Modules.hs
13:59:21 <c_wraith> I'm assuming sendMsg is strict in its 3rd argument?
14:00:44 <dom96> http://github.com/dom96/SimpleIRC/blob/master/Network/SimpleIRC/Core.hs#L264
14:00:48 <dom96> I think it is
14:00:55 <c_wraith> Looks like it
14:04:42 <c_wraith> dom96: ok, I give up.  I don't see anything obvious that should be holding on to the old values.
14:04:51 <c_wraith> dom96: try retainder profiling, though
14:05:20 <dom96> i bet that's complicated ...
14:05:31 <greap> Is there a way to have ghci still include the loaded modules even when the main script fails to load?
14:05:32 * dom96 googles
14:06:36 <c_wraith> dom96: doing the profiling isn't that hard.  making sense of the results, on the other hand... :)
14:07:05 <dom96> oh heh
14:08:29 <dom96> Perhaps you haven't installed the profiling libraries for package `hint-0.3.2.3'?
14:08:33 <dom96> How do i install them?
14:08:54 <c_wraith> this is the part where you curse at cabal.
14:09:06 <kmc> there's a flag to cabal
14:09:43 <c_wraith> cabal install --reinstall -p hint-0.3.2.3
14:09:58 <c_wraith> The problem is you'll need to give a command like that for every one of your dependencies
14:10:04 <FunctorSalad_> Philonous: why'd you want to do this? :)
14:10:09 <c_wraith> And *really* hope that they don't decide to relink the wrong way
14:10:16 <luite> that's why I now install profiling things by default
14:10:23 <dom96> oh, ... ugh
14:10:47 <c_wraith> You can list multiple packages at once
14:10:49 <luite> it might be easier to delete your whole cabal directory, configure it to always install profiling things and just start again :)
14:11:01 <dom96> oh god..
14:11:12 <c_wraith> that will at least make it link those packages against each other properly
14:11:34 <c_wraith> But yeah, a cabal command for "install profiling libs without changing any linking decisions" would be pretty awesome.
14:12:11 <dom96> yeah, i think emptying my cabal directory would be better....
14:12:24 <c_wraith> don't forget to take out ~/.ghc too
14:12:57 <FunctorSalad_> Philonous: (as I understand it, they have the same semantics (seq is only allowed to return b after it has made sure that a ≠ ⊥, right?))
14:13:12 <dom96> so which directories do i delete? ~/.ghc and ~/.cabal ?
14:13:16 <FunctorSalad_> even if it evaluates b first
14:13:33 <dom96> Can i just delete ~/.caba/lib?
14:13:34 <kmc> FunctorSalad_, Philonous : http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg10973.html
14:13:40 <kmc> that whole thread
14:13:44 <kmc> goes into some detail on seq vs. pseq
14:13:53 <dom96> I'm scared i will mess something up
14:13:57 <Philonous> FunctorSalad_: True, but it might evaluate b, evaluate a, return b
14:14:23 <FunctorSalad_> hmm ok, I can see why you wouldn't want that if there's unsafe* involved
14:14:26 <kmc> i think the conclusion is as you said; they have the same denotational semantics but pseq makes an additional operational guarantee
14:14:31 <FunctorSalad_> lazyIO in particular
14:14:36 <kmc> FunctorSalad_, it also matters with par
14:14:37 <kmc> consider:
14:14:39 <luite> dom96: you need .ghc since it contains the ghc-pkg configuration for the installed packages
14:14:49 <kmc> a `par` b `seq` a+b
14:14:52 <kmc> ierr
14:14:54 <kmc> a `par` b `seq` (a+b)
14:14:58 <dom96> luite: so what do i delete ?
14:15:01 <FunctorSalad_> how does that associate? ;)
14:15:11 <kmc> doesn't matter in this case
14:15:17 <pumpkin> kmc: pseq?
14:15:25 <FunctorSalad_> > let f=(+) in let g=(*) in 1 `f` 2 `g` 3
14:15:26 <lambdabot>   9
14:15:28 <kmc> if the `seq` evaluates its right arg first, then forcing (a+b) will quickly force a, possibly before 'par' gets to it
14:15:35 <kmc> that will make the 'a' spark fizzle and you get no parallelism
14:15:38 <FunctorSalad_> left apparently
14:15:46 <luite> dom96: I think ~/.cabal/lib and ~/.ghc  should be enough
14:15:51 <dom96> luite: ok
14:15:58 <kmc> you want to force the seq to chew on b for a while, so that evaluation of a can proceed at the same time
14:16:03 <luite> rename them if you want to be able to go back :)
14:16:08 <kmc> hence pseq
14:16:31 <FunctorSalad_> kmc: hmm ok
14:16:56 <Tarlok> Is there a better way of writing maybe_read than: 'maybe_read str = unsafePerformIO $ catch (fmap Just $ readIO str) (const $ return Nothing))' ?
14:16:56 <Tarlok>  
14:17:10 <kmc> Tarlok, use reads
14:17:11 <kmc> :t reads
14:17:12 <lambdabot> forall a. (Read a) => String -> [(a, String)]
14:17:23 <kmc> :t \x -> case reads x of [(v,"")] -> Just v; _ -> Nothing
14:17:24 <lambdabot> forall a. (Read a) => String -> Maybe a
14:17:33 <Tarlok> ok thanks
14:17:37 <dom96> luite: ok :)
14:21:16 <dom96> wow this was faster than i thought it would be
14:22:03 <FunctorSalad_> what's the simplest of the webservers in haskell? I mean for trivialest stuff like serving stuff for yourself or to a few people from your desktop
14:22:12 <dom96> wow
14:22:25 <Botje> FunctorSalad_: i wrote one in 200 lines
14:22:26 <FunctorSalad_> it=?
14:22:30 <dom96> http://gist.github.com/538958
14:22:35 <FunctorSalad_> err, 'this', not 'it' :)
14:22:37 <dom96> An internal ghc bug that's nice
14:22:52 <Botje> it doesn't use bytestrings, unfortunately :)
14:23:03 <FunctorSalad_> is it on häckage?
14:23:10 <Botje> no
14:23:29 <FunctorSalad_> I guess using one should still be easier than writing it ;)
14:23:35 <FunctorSalad_> maybe I'm overestimating how complex iti s
14:23:36 <FunctorSalad_> *is
14:23:38 <pumpkin> FunctorSalad_: häckage? :P
14:23:46 <FunctorSalad_> pumpkin: forced meme
14:23:47 <kmc> FunctorSalad_, i used httpd-shed
14:23:48 <FunctorSalad_> ;)
14:24:00 <kmc> for something really trivial
14:24:04 <olsner> FunctorSalad_: häck == ass in swedish, btw
14:24:06 <Botje> FunctorSalad_: http://wilma.vub.ac.be/~dharnie/Shttpd.hs
14:24:10 <Botje> there it is, warts and all :)
14:24:28 <Botje> oh, hey, it /does/ use bytestrings
14:24:30 <FunctorSalad_> olsner: hmm 'hack' pronounced in english and 'häck' in german are almost identical
14:24:32 <pumpkin> dom96: not sure that's actually a GHC bug
14:24:42 <pumpkin> dom96: what are you using?
14:24:50 <dom96> what do you mean?
14:24:56 <FunctorSalad_> "häckage" just adds a funny accent
14:25:01 <dom96> what packages i'm using?
14:25:14 <pumpkin> dom96: any unsafe modules? 
14:25:28 <dankna> so when I realized just how much work it would be to add a static typechecker to my mini-language, I decided to spend a few more hours trying to live without one
14:25:29 <dom96> i dunno, maybe the hint package is unsafe ?
14:25:29 <FunctorSalad_> kmc: *looks*
14:25:30 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29305#a29305
14:25:38 <dankna> but I'm not much further than I was this morning
14:26:07 <kmc> dankna, you can write a type-checker without using a GADT representation
14:26:20 <kmc> you lose then the property that well-typed Haskell code preserves Custard typing
14:26:27 <dankna> kmc: I suppose that's true, hmm
14:26:44 <dankna> kmc: but since I'm not letting the user write Haskell code, only Custard code, that might be acceptable
14:26:59 <kmc> yeah
14:27:02 <dom96> i knew profiling would be complicated, i can sense these things lol
14:27:12 <kmc> e.g. GHC typechecks all of Haskell, without using GADTs
14:27:22 <kmc> (maybe it does use them now)
14:27:25 <dankna> well, I knew that must be the case, haha
14:27:28 <kmc> :)
14:28:28 <luite> dom96: do other programs that use similar packages still work fine after recompiling?
14:28:48 <dom96> luite: i don't think i have any....
14:28:54 <FunctorSalad_> dom96: I used to get 'PAP' errors too... fixed it by rebuilding/installing ghc and all my packages
14:29:00 <FunctorSalad_> ;)
14:29:04 <olsner> FunctorSalad_: dunno about german, but to me that looks like something pronounced 'heckage'
14:29:05 <FunctorSalad_> not saying that's necessary
14:29:18 <luite> FunctorSalad_: he just deleted all installed packages :)
14:29:39 <luite> I'm wondering if there's something else that should've been removed
14:29:47 <FunctorSalad_> olsner: hmm is it much different in english? hackage, heckage... the 'a' is more "open" in the former
14:29:54 <FunctorSalad_> but so is 'ä' compared to 'e'
14:29:57 <dom96> i hope this didn't break my ghc forever :(
14:30:39 <luite> dom96: it probably did, and you won't be able to use haskell ever again, because it tells the other compilers
14:30:54 <dom96> oh noes!
14:31:00 * dom96 cries
14:31:03 <FunctorSalad_> dom96: 'forever' being bounded by 'until I reinstall', surely
14:31:15 <FunctorSalad_> not saying it *is* broken, just that I found it easier to do that ;)
14:31:20 <luite> dom96: what does ghc-pkg list say?
14:31:35 <dankna> kmc: this was probably obvious to you, but I just realized that what you just said applies even to the dynamic type checker that I currently am using.  so I'm taking the GADT out and seeing where that gets me.
14:31:58 <dom96> luite: http://gist.github.com/538976
14:32:26 <ivant> does anyone know where *exactly* ICFP 2010 is going to be located? I can't find any information, where in Baltimore it's going to be
14:32:29 <dankna> kmc: in retrospect I'm not sure why I considered the extra layer of safety important
14:33:18 <luite> dom96: hm that looks ok
14:33:51 <dom96> it works if i compile it without the -prof arg
14:34:15 <luite> dom96: those in ~/.ghc are all newly installed, right?
14:34:43 <dom96> luite: yes
14:35:56 <luite> dom96: hm, strange. you could try and add a temporary new user to your system, and check whether you can cabal-install those packages with profiling there
14:35:57 <kmc> ghc doesn't have absurd patterns does it?
14:36:10 <kmc> how do i suppress a non-exhaustive pattern warning when the rest of the patterns are prohibited by the GADT types?
14:36:13 <dom96> luite: *sigh* :(
14:36:25 <luite> dom96: sorry, I can't think of anything better :p
14:37:05 <luite> dom96: if it works there, it should also work on your regular account after completely removing .cabal and .ghc
14:37:12 <kmc> dankna, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29306#a29306
14:37:23 <dom96> i doubt i would make sense of the profiling anyway.
14:37:44 <kmc> dankna, note that I don't use typeable
14:38:02 <luite> dom96: it's not that difficult to interpret
14:38:03 <dankna> hmm, yes, I see
14:38:23 <kmc> dankna, it'd be cleaner if you had CustardNil and CustardCons rather than CustardList
14:38:34 <luite> and heap profiling gives you nice graphs
14:38:38 <dom96> luite: i'll try removing .cabal aswell
14:38:45 <dankna> you may be right, it would make the empty-list case clearer
14:39:14 <luite> dom96: don't forget to copy back the configuration file
14:39:47 <dom96> actually i'll keep the bin folder lol...
14:40:03 <kmc> dankna, like so http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29307#a29307
14:40:12 <dankna> yes, I see
14:40:17 <kmc> err sorry
14:40:21 <kmc> there it goes
14:40:24 <kmc> (hpaste hiccup)
14:44:15 <FunctorSalad_> dom96: I *think* I started getting PAP errors after I had compiled ghc with an ancient flag in the build.mk turned on
14:44:20 <FunctorSalad_> gut I assume you didn't do that
14:44:24 <FunctorSalad_> *but
14:44:40 <FunctorSalad_> I didn't know what it's for but I said 'what the hell'...
14:44:51 <dom96> meh, it's still the same after i renamed all dirs except bin in .cabal
14:45:16 <dom96> this sucks
14:45:50 <pumpkin> ask in #ghc maybe?
14:46:44 <luite> hmm, I have no idea what it can be then... and I'm sorry for helping you destroy your ghc installation :)
14:47:15 <dom96> 'Note also that if you compile gitit for executable profiling, attempts to load plugins will result in "internal error: PAP object entered!"'
14:47:21 <dom96> from http://github.com/jgm/gitit
14:47:44 <luite> oh so it migh be a ghc bug after all?
14:47:45 <dom96> i think hint doesn't support profiling
14:48:02 <dom96> yeah
14:48:15 <luite> ah interesting, I surely would've run into that later
14:48:36 <luite> since I'm working with hint for my tryhaskell clone
14:48:41 <luite> or fork
14:48:43 <luite> :)
14:50:08 <dom96> I don't think i'm ever gonna find this space leak
14:50:19 <dom96> and 86mb usage is just unacceptable
14:51:31 * dom96 hopes someone answers in #ghc
14:53:15 <luite> dom96: is that package available somewhere? I can try to reproduce the error
14:53:31 <dom96> you mean my irc bot?
14:53:34 <luite> yes
14:53:43 <dom96> yeah, on github. Both my irc library and bot
14:53:50 <luite> can I just git clone both library and bot?
14:53:56 <dom96> http://github.com/dom96/ElysiaBot
14:54:00 <dom96> http://github.com/dom96/SimpleIRC
14:54:01 <dom96> yeah
14:54:11 <dom96> ElysiaBot doesn't have a cabal file yet though
14:54:20 <luite> oh that's no problem
14:54:26 <dom96> but you shouldn't need one anyway :)
14:55:00 <monochrom> ElysiaBot sounds heavenly
14:55:53 <dom96> heh, that's good :)
14:55:59 <luite> dom96: yes same error here, ghc 6.12.3 linux
14:56:30 <dom96> So it must be a ghc bug then.
14:56:39 <dom96> let's see if i can reproduce it
14:57:05 <monochrom> Freude, schönen Gotterfunken, Tochter aus Elysium
14:59:52 <geheimdienst> wir betreten feuertrunken, himmlische, dein heiligtum ...
15:00:20 <dom96> There we go
15:00:31 <dom96> Easier than i thought
15:06:30 <dfkjjkfd>   BwBkk
15:06:44 <BrianHV> is there some way to create (e.g.) a list whose members may not be the same type, but all derive some type (e.g., Show)?
15:07:10 <ddarius> BrianHV: Use an existential.
15:07:24 <kmc> hmm
15:07:31 <kmc> it's worth considering simpler solutions first
15:07:35 <kmc> data Value = VInt Int | VChar Char
15:07:36 <kmc> [Value]
15:07:40 <kmc> BrianHV, ^^^^
15:08:02 <kmc> existentials are useful for *open* sum types, i.e. if you want to allow users of your library to invent new types which can go in the list
15:08:16 <BrianHV> I think that'd be neat, yes. ;)
15:08:22 <kmc> btw if all you have on these values is Show, you might as well use [String]
15:09:06 <BrianHV> this is more a mental exercise than a practical matter at the moment.  but I will indeed consider the simpler solutions if it becomes a practical matter.
15:09:15 <Ke> I thought existentials were blasphemy and your soul would burn in FORTRAN66 land
15:09:47 <typemore> my ghc does not have Data.Char
15:09:48 <zygoloid> existentials are great :)
15:09:50 <typemore> how do I purchase Data.Char ?
15:10:02 <typemore> (I'm on ubuntun latest)
15:10:18 <zygoloid> typemore: is there a libghc6-base-dev package you can install?
15:10:58 <typemore> libghc6-regex-base-dev
15:11:05 <typemore> and a bunch of hdbc / hsql crap
15:11:40 <Cale> BrianHV: You can often avoid using existentials (though often existentials are still convenient), through good old functional programming: just make a record of what all the functions in your common interface do to the given pieces of data. Lazy evaluation means that even if some of those are expensive, you don't have to worry.
15:11:48 <zygoloid> typemore: do you have: /usr/lib/ghc-6.12.1/base-4.2.0.0/Data/Char.hi
15:12:05 <typemore> ls -l /usr/lib/ghc-6.12.1/base-
15:12:05 <typemore> base-3.0.3.2/  base-4.2.0.0/
15:12:25 <typemore> find /usr/lib/ghc-6.12.1/base-4.2.0.0 | grep Data | grep Char
15:12:25 <typemore> /usr/lib/ghc-6.12.1/base-4.2.0.0/Data/Char.p_hi
15:12:25 <typemore> /usr/lib/ghc-6.12.1/base-4.2.0.0/Data/Char.hi
15:12:25 <typemore> /usr/lib/ghc-6.12.1/base-4.2.0.0/Data/Char.dyn_hi
15:12:31 <BrianHV> Cale: also a good idea.  I'll keep it in mind.
15:12:33 <dolio> Existentials are codata, codata is existential.
15:12:43 <typemore> I have a typo
15:12:45 <typemore> i am impoting
15:12:47 <typemore> Ddata.Char
15:12:57 <dom96> luite: http://hackage.haskell.org/trac/ghc/ticket/4263 If you'd like to take a look.
15:13:19 <zygoloid> typemore: haha :)
15:13:23 <luite> dom96: I already saw it in #ghc, thanks :)
15:13:32 <dom96> luite: heh, ok :)
15:13:34 <typemore> zygoloid: yeah, thakns for help :-)
15:14:31 <zygoloid> no problem. :)
15:14:49 <luite> dom96: I joined because I wanted to see how your problem would get resolved... though now that it looks like it's an actual ghc bug, that might take a little longer
15:15:16 <typemore> test.hs:9:0: The type signature for `sendCommand' lacks an accompanying binding
15:15:19 <typemore> what does that mean?
15:15:27 <typemore> when I have:
15:15:28 <typemore> sendCommand :: String -> IO ()
15:15:29 <typemore> sendCommadn s = do
15:15:35 <luite> lol
15:15:37 <Cale> typemore: It means you have a typo
15:15:39 <dom96> spelling mistake...
15:15:54 <typemore> i'm 2 for 2 today
15:16:25 <dom96> luite: yeah, unfortunately i will have to wait...
15:16:28 <zygoloid> typemore: more generally it means it saw a type annotation, but didn't find any definition of the value whose type was specified. almost always a typo though :)
15:23:07 <pumpkin> ezyang: omg you're giving a talk? :O
15:23:14 <pumpkin> ezyang: awesome!
15:26:00 <ezyang> pumpkin: Yah, my "what I did for my internship" tlak 
15:26:11 <pumpkin> looks fun :)
15:26:17 <pumpkin> have you told edwardk about it?
15:26:25 <pumpkin> cause he was just talking about writing a binding to a SAT solver
15:26:38 <pumpkin> albeit a different one
15:26:55 <ezyang> now that you mention it, I don't think I've explicitly mentioned it. 
15:27:04 <ezyang> edwardk has been working very exotic SAT solvers 
15:27:32 <pumpkin> :)
15:27:50 <pumpkin> well, having two solvers around for haskell won't hurt
15:28:11 <ezyang> Yep! 
15:28:31 <ezyang> There are already a bunch of pure Haskell SAT solvers, but no binding ones, afaict. 
15:29:25 <ddarius> @tell edwardk You might find this interesting http://arxiv.org/pdf/0804.3241
15:29:25 <lambdabot> Consider it noted.
15:29:47 <kmc> binding?
15:30:06 <kmc> doesn't satchmo bind to various external solvers
15:31:06 <ezyang> yeah, but I think he does that by shelling out to the executable 
15:46:01 <endpoint_david> so I want to define a datatype that essentially wraps a values between 0 and 1 inclusive; is there a way to define this in the type system so I can assume that if a value was successfully constructed (say as Unit Double) that it passes that constraint, despite the underlying storage type supporting a greater range?
15:46:58 <vanadium> Just use the full range and divide by max :: Double before interacting with other types? <:)
15:51:17 <kmc> endpoint_david, put the type in a module and don't export the constructor, only a "smart constructor" function
15:51:59 <kmc> vanadium has a good point though, that you're losing precision
15:52:15 <vanadium> Mostly I wanted to get around smart constructors I guess
15:52:29 <kmc> if you actually clamp to [0,1] rather than mapping the full range
15:52:37 <koninkje> vanadium: smart constructors or an isomorphism (like (/max)) are the only way
15:52:39 <kmc> either way, you can newtype Double and define Num, Fractional, etc.
15:53:37 <vanadium> Either way you probably want to hide the constructor and disable patternmatching on it, I guess
15:53:52 <vanadium> err, patternmatching on doubles is probably not a great loss
15:54:14 <pumpkin> endpoint_david: why not just treat an Int as a step between 0 and 1?
15:54:21 <pumpkin> or a Double if you like uneven precision
15:54:30 <koninkje> endpoint_david: oops, see my previous @vanadium
15:59:45 <`Zerax`> Is there any way in the defintion of a property to make quickCheck aware that a particular test case should be skipped?
16:00:51 <pumpkin> you can put a prerequisite in with ==>
16:01:00 <pumpkin> but if you do a lot of them, you'll want to make a custom generator
16:01:34 <`Zerax`> hmm
16:01:51 <ivanm> wow, copumpkin was un-co'd for a bit? :o
16:01:59 * ivanm thought something felt wrong in the universe...
16:01:59 <ivanm> ;-)
16:02:01 <copumpkin> shh, don't tell anyone
16:02:09 <copumpkin> :)
16:08:08 <Phyx-> copumpkin: a bit to late for that
16:08:16 <Phyx-> it's now a matter of public record
16:08:17 <copumpkin> :(
16:09:59 <benmachine> I've seen a contrapumplin before
16:10:02 <benmachine> k
16:10:16 <copumpkin> indeed :)
16:11:39 <Phyx-> benmachine: pumpkin was the result of the co and contra meeting
16:14:36 <`Zerax`> Undoubtedly a reaction that would put nuclear fusion to shame
16:15:16 <Phyx-> `Zerax`: yes, haskell compilers all over the world trembled
16:22:25 <roconnor> how do you write (==) using foldr?
16:22:41 <koninkje> you mean list's (==)?
16:22:53 <roconnor> ya
16:23:00 <roconnor> though I'm hoping to generalize it
16:23:01 <napping> you mean as (==) = foldr .. ..
16:23:16 <koninkje> that'll be ugly since it's using dual recursion (two lists)
16:23:23 <roconnor> napping: not necessarily, just using foldr some how.
16:23:30 <roconnor> probably will require 2 foldrs
16:23:39 <lispy> Or use a zipWith/and
16:23:41 <koninkje> yes, but one of those is trivial
16:23:50 <lispy> > and $ zipWith (==) ...
16:23:51 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:23:56 <koninkje> zipWith doesn't work because it discards the end of uneven lists
16:24:08 <koninkje> cf Data.List.Extras.Pair.pairWith
16:24:11 <lispy> koninkje: are lists of different length equal?
16:24:22 <lispy> Oh you mean, if they are equal to a common prefix
16:24:30 <roconnor> > and $ zipWith (==) [] [1]
16:24:31 <koninkje> lispy: no, but you can't tell when they're different lengths
16:24:31 <lambdabot>   True
16:24:32 <kmc> :t map (==)
16:24:33 <lambdabot> forall a. (Eq a) => [a] -> [a -> Bool]
16:24:52 <kmc> :t map ($) . map (==) 
16:24:53 <lambdabot> forall a. (Eq a) => [a] -> [a -> Bool]
16:24:58 <kmc> durr ($) = id
16:24:58 <dankna> > (\a b -> (length a == length b) && (and $ zipWith (==) a b)) [1..2] [1..5]
16:24:59 <lambdabot>   False
16:25:02 <dankna> > (\a b -> (length a == length b) && (and $ zipWith (==) a b)) [1..2] [1..2]
16:25:03 <lambdabot>   True
16:25:28 <benmachine> can zip be defined in terms of a fold?
16:25:40 <dankna> this lacks the elegance of only traversing once, but it works...
16:25:41 <koninkje> benmachine: yes, of course
16:25:53 <benmachine> koninkje: well okay sure, can it be done easily/efficiently
16:25:54 <koninkje> benmachine: though again, it's dual induction, so it won't be pretty
16:25:57 <kmc> benmachine, yeah, by folding a list into a zip-me-with-other-list function
16:26:12 <benmachine> kmc: ah, I see
16:26:21 <kmc> :t foldr (\x f (y:ys) -> (x,y) : f ys)
16:26:22 <lambdabot> forall a t. ([t] -> [(a, t)]) -> [a] -> [t] -> [(a, t)]
16:26:22 <koninkje> What you want is a dual induction method to base zip, pair, (==), etc off of
16:26:43 <kmc> :t foldr (\x f (y:ys) -> (x,y) : f ys) (const [])
16:26:44 <lambdabot> forall a t. [a] -> [t] -> [(a, t)]
16:27:03 <kmc> > foldr (\x f (y:ys) -> (x,y) : f ys) (const []) "abcd" "xyz!"
16:27:04 <lambdabot>   [('a','x'),('b','y'),('c','z'),('d','!')]
16:27:17 <kmc> i think it'll have some issues on length mismatch
16:27:43 <kmc> @pl (\x f (y:ys) -> (x,y) : f ys)
16:27:43 <lambdabot> flip flip tail . (ap .) . flip flip head . ((.) .) . flip . (((.) . (:)) .) . (,)
16:27:48 <koninkje> (==) = case pairWith (\x y -> x == y) of { Just True -> True ; _ -> False }
16:27:49 <kmc> jesus haploid christ
16:27:54 <roconnor> :t foldr (\x f (y:ys) -> x == y && f ys) null
16:27:55 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:28:18 <koninkje> er, that's not quite...
16:28:20 <napping> kmc: I suppose that makes sense
16:28:27 <roconnor> :t foldr (\x f (y:ys) -> x == y && f ys) (foldr (\_ _ -> False) True)
16:28:28 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:28:31 <dankna> > (\f -> f f) (\recurse a b -> case (a, b) of ([], []) -> True ; ((firstA:restA), (firstB:restB)) -> (firstA == firstB) && recurse recurse restA restB ; _ -> False) [1..2] [1..5]
16:28:32 <lambdabot>   Occurs check: cannot construct the infinite type:
16:28:32 <lambdabot>    t = t -> t1 -> t2 -> t3
16:28:35 <dankna> oops
16:28:45 <koninkje> (==) - case pairWithBy (==) (&&) True of { Just True -> True ; _ -> False }
16:29:04 <dankna> well, you see what I'm doing - just building it as a recursive function instead of using an existing primitive.  I think that's what I would do.  granted using an existing primitive may be more interesting...
16:29:34 <koninkje> list-extras:Data.List.Extras.Pair.pairWithBy
16:29:34 <benmachine> dankna: use fix
16:29:44 <benmachine> rather than \f -> f f
16:29:46 <dankna> :t fix
16:29:47 <lambdabot> forall a. (a -> a) -> a
16:29:54 <dankna> > fix (\recurse a b -> case (a, b) of ([], []) -> True ; ((firstA:restA), (firstB:restB)) -> (firstA == firstB) && recurse recurse restA restB ; _ -> False) [1..2] [1..5]
16:29:54 <lambdabot>   Couldn't match expected type `[t]'
16:29:55 <lambdabot>         against inferred type `[t] -> [t...
16:30:12 <dankna> so fix is the y-combinator?  I don't think I realized that.
16:30:19 <benmachine> @src fix
16:30:19 <lambdabot> fix f = let x = f x in x
16:30:39 <kmc> fix isn't the y combinator
16:30:39 <dankna> head hurty
16:30:42 <kmc> they are both fixed-point combinators
16:30:48 <kmc> i.e. same effect
16:30:51 <dankna> I see
16:30:54 <benmachine> dankna: the easier to understand but less efficient version is
16:30:56 <kmc> but they are written different ways, and Y can't be typed in Haskell
16:30:59 <benmachine> fix f = f (fix f)
16:31:01 <dankna> makes sense
16:31:12 <dankna> okay, that's clearer, haha
16:31:18 <kmc> it's less efficient because it reconstructs the expression «fix f»?
16:31:19 <roconnor> I don't know how to write (\(y:ys) -> x == y && f ys)  with foldr
16:31:23 <roconnor> I suspect it isn't nice
16:31:40 <roconnor> and really I need to also return False in the case the input is []
16:31:55 <benmachine> kmc: I think it's something to do with let x = f x in x making a cyclic data structure
16:32:04 <roconnor> I think it would be easier with primitive recursion
16:32:14 <roconnor> catamorphisms suck
16:32:38 <koninkje> roconnor: foldr2 f g h z = go where go [] [] = z ; go (x:xs) [] = f x (go xs []) ; go [] (y:ys) = g y (go [] ys) ; go (x:xs) (y:ys) = h x y (go xs ys)
16:32:48 <koninkje> catamorphisms rock!
16:32:59 <roconnor> koninkje: is that a catamorphism?
16:33:19 <koninkje> kinda...
16:33:26 <roconnor> :^)
16:33:28 <koninkje> it's not a catamorphism on [] though
16:33:42 <kmc> hmm benmachine i guess with the "let" version of fix, «sum . take n $ fix (1:)» will always take constant space (ignoring int size)
16:33:50 <kmc> and with the other it might build a n-element list in memory first?
16:33:57 <koninkje> it's a ctamorphism on [Or a b] where data Or a b = Fst a | Both a b | Snd b
16:34:00 <megajosh2> @src Control.Monad.State.execState
16:34:00 <lambdabot> Source not found. stty: unknown mode: doofus
16:34:09 <kmc> "always" modulo some assumptions about a proper lazy graph-reduction implementation, but no particular optimization
16:34:22 <benmachine> kmc: I think the list would be GC'd in either case, but I think if you held on to the head of the list
16:34:25 <koninkje> roconnor: ^
16:34:27 <kmc> right
16:34:35 <benmachine> then the latter version would make a big list whereas the former would make a list that referred to itself
16:35:01 <kmc> «let x = 1:x in x» takes constant space
16:35:10 <benmachine> http://haskell.org/haskellwiki/Tying_the_Knot this is the sort of stuff I have in mind?
16:35:12 <kmc> even if you consume up to the 10,000,000th element
16:35:26 <kmc> and hold onto "all" of them
16:35:29 <roconnor> koninkje: that seems hard to gerneralise to arbitrary nice recursive types
16:35:31 <copumpkin> kmc: that's over 90000!!!
16:36:06 <koninkje> roconnor: why's that?
16:36:22 <roconnor> becuase most data types are not containers
16:36:47 <koninkje> every recursive type is the fixed point of a "container"
16:36:52 <roconnor> yes
16:37:21 <Rotaerk> "container" doesn't make sense in the context of immutables imo
16:37:29 <FSalad_III> Prelude.sort order == versioning order for hackages?
16:37:30 <QtPlatypus> koninkje: Could you explain that?
16:37:33 <Rotaerk> collection, perhaps
16:37:38 <olsner> kmc: I don't think you can actually know that the "1:" cons is actually being reused (at least one previous time I tried to claim it was so, there were objections)
16:37:43 <roconnor> Rotaerk: container is a techincal term
16:37:43 <koninkje> So, just take the derivative of your nice recursive type and stick (Or a b) in the hole, where a and b are the parts removed from the context
16:37:54 <kmc> olsner, from the Report only, you certainly can't.  it's pretty silent on operational issues
16:37:56 <koninkje> QtPlatypus: explain which?
16:38:03 <Rotaerk> roconnor, oh, in what field?
16:38:06 <kmc> olsner, are there objects considering an actual implementation like GHC?
16:38:11 <QtPlatypus> every recursive type is the fixed point of a "container"
16:38:34 <Rotaerk> category theory?
16:38:37 <napping> koninkje: are you sure the containers work for nested types
16:38:41 <napping> or GADTs?
16:38:51 <copumpkin> olsner: you can't
16:38:53 <kmc> yeah we have a class named "Functor" and everyone complains that we're elitist math nerds.  if we call it "Container" instead, they'll complain that it's not really a container because foo and bar and baz
16:39:00 <koninkje> napping: I haven't thought about nested types
16:39:01 <benmachine> FSalad_III: 6.10 as a version is after 6.8
16:39:02 <kmc> you can't win :)
16:39:13 <benmachine> "six point ten"
16:39:30 <copumpkin> Containers are the devil
16:39:40 <koninkje> napping: for GADTs it only works to the extent that the recursion site is polymorphic in its index; otherwise you'll have to deal with the different types in the family
16:39:43 <copumpkin> assuming it's those things that keep showing up in the epigram papers on universes etc. :P
16:39:44 <FSalad_III> benmachine: oh right :(
16:39:51 <benmachine> FSalad_III: :(?
16:39:59 <FSalad_III> currently I'm invoking sort -V as an external process
16:40:05 <FSalad_III> which isn't exactly portable
16:40:37 <benmachine> oh
16:40:39 <roconnor> Rotaerk: http://en.wikipedia.org/wiki/Container_%28type_theory%29
16:40:46 <Rotaerk> ah thanks
16:40:53 <QtPlatypus> I think I understand what a recursive type, I think I understand what a fixed point is and even what a container is.  I just don't understand the relationship between the three concepts.
16:40:57 <benmachine> split on the dots, read the parts as integers, and sort as a list of integers
16:41:23 <napping> QtPlatypus: fixpoint and recursive type are easiest to explain
16:41:25 <FSalad_III> benmachine: ok :) I didn't even consider implementing the comparison myself ;)
16:41:36 <FSalad_III> but sounds easy enough
16:41:38 <ddarius> Containers have a wikipedia page?
16:41:48 <etpace> @hoogle (a -> b) -> [a] -> [(a,b)]
16:41:48 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
16:41:48 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
16:41:48 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith :: Monad m => (a -> b) -> GT m g a -> m g -> m (b, g)
16:41:55 <napping> QtPlatypus: consider a type like data L x = N | C Int x
16:42:07 <kmc> :t \f -> map (id &&& f)
16:42:08 <lambdabot> forall a c'. (a -> c') -> [a] -> [(a, c')]
16:42:09 <koninkje> roconnor: I'm not sure Id call that a technical term really...
16:42:12 <kmc> etpace, ^^^^
16:42:15 <etpace> cheers
16:42:18 <FSalad_III> benmachine: and split on the final dash I guess
16:42:19 <kmc> :t map . (id &&&)
16:42:20 <napping> so L () has values like C 1 () and N 
16:42:20 <lambdabot> forall a c'. (a -> c') -> [a] -> [(a, c')]
16:42:23 <FSalad_III> (as a first step)
16:42:30 <napping> L (L ()) has also things like C 1 (C 2 ()), etc.
16:42:32 <benmachine> yeah
16:42:35 <QtPlatypus> napping: A fixed point of a function f is x such that x = f x (IIRC)  How does that generalize to Types?
16:42:35 <benmachine> something like that
16:42:43 <kmc> FSalad_III, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Version.html ?
16:42:45 <napping> QtPlatypus: and L (L (L ...  )) looks like lists
16:42:51 <endpoint_david> thanks for the ideas guys; I think storing as the full range of an unsigned int and then converting to a double on demand will work great for my applications
16:42:56 <FSalad_III> I hope dashes are illegal in versions...
16:43:00 <napping> we can take the fixpoint with a type data Fix f = I (f (Fix f))
16:43:01 <kmc> standard library!
16:43:11 <QtPlatypus> napping: Ah I get it.
16:43:13 <roconnor> koninkje: I thought a container was a type that has a logarithm.
16:43:20 <napping> then Fix L has values like I(N), I(C 1 (I(N))), etc.
16:43:22 <ivanm> FSalad_III: in Cabalised packages, yes
16:43:24 <FSalad_III> kmc: \o/
16:43:36 <ivanm> dcoutts doesn't let you use tags in version numbers
16:43:50 <zygoloid> \o/ http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29310#a29310 \o/
16:44:27 <ivanm> wow, what's the error in there for?
16:44:32 <ivanm> zygoloid: what's that meant to be?
16:44:45 <copumpkin> zygoloid: neat!
16:44:48 <zygoloid> ivanm: it's my haskell debugger, attached to fibonacci-printer
16:45:04 <ivanm> you mean you decided to write a haskell debugger?
16:45:11 <zygoloid> you can see the 'fibs' CAF being built up as it progresses
16:45:15 <zygoloid> ivanm: yup :)
16:45:23 <ivanm> dammit, this means when people ask for one we can't just go "you don't need one" !!!
16:45:27 <ivanm> see what you did? :@
16:45:28 <ivanm> ;-)
16:45:31 <zygoloid> SORRY!
16:45:55 <napping> hmm, universes are kind of hard to build in Haskell
16:45:56 <ddarius> ivanm: Don't worry, there are other debuggers that aren't being used.
16:46:08 <`Zerax`> It's not a massive issue, just make the debugger more complicated to use than solving their problems without it
16:46:08 <dankna> !
16:46:10 <dankna> good job zygoloid
16:46:12 <ivanm> ddarius: *phew*
16:46:22 <napping> I don't see how I can enforce well-kindedness
16:46:31 <ivanm> napping: data Universe = Universe -- done!
16:46:33 <copumpkin> napping: need moar universez
16:46:44 <copumpkin> an infinite tower of them!
16:46:54 <napping> that would do it
16:46:56 <ivanm> type Multiverse = Set Universe
16:47:05 <ddarius> copumpkin: Why so linear?
16:47:14 <roconnor> newtype Universe = Universe Universe
16:47:15 <copumpkin> ddarius: I'm boring that way :(
16:47:22 <koninkje> roconnor: I'm pretty sure the dual induction case can always be defined by, cata2 :: (Der X (Or a b) -> c) -> X a -> X b -> c
16:47:25 <`Zerax`> Surely it should be a rose tree
16:47:26 <ivanm> roconnor: heh
16:47:41 <ivanm> `Zerax`: why rose tree rather than any other kind of tree?
16:47:41 <napping> I was trying to see how far I could get defining codes of data types, and then a gadt that would just have values from that type
16:47:45 <copumpkin> ivanm: his has got fewer universes than yours :(
16:48:07 <copumpkin> napping: like the generic stuff?
16:48:11 <roconnor> koninkje: say I define Nat.  How do I define cata2 for Nat?
16:48:13 <copumpkin> 1 :+: 1?
16:48:15 <ivanm> copumpkin: it's easier to define an infinite multiverse with his though
16:48:23 <ivanm> fix Universe :p
16:48:28 <ivanm> hey edwardk 
16:48:30 <napping> copumpkin: yes, something like that, but trying to capture H98 definitions
16:48:32 <edwardk> heya ivan
16:48:32 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
16:48:35 <copumpkin> ivanm: yours doesn't take a parameter
16:48:35 <napping> well, minus class constraints
16:48:43 <copumpkin> ivanm: so boring :(
16:48:56 <copumpkin> edwardk: did you see ezyang's SAT solver binding!?
16:49:18 <ddarius> break universe
16:49:18 <edwardk> copumpkin: which one?
16:49:21 <ezyang> copumpkin: That would be kind of difficult, seeing that it's not published yet... 
16:49:27 <copumpkin> ezyang: hrrmpf fine
16:49:29 <ivanm> copumpkin: I was looking for the simplest possible (no-extensions-required) definition to prove to napping how easy it was to define a universe
16:49:30 <edwardk> copumpkin: we talked about it a while back, i don't know that i've actually seen it
16:49:34 <copumpkin> ezyang: I meant the talk about it :P
16:49:38 <ivanm> ezyang: lol
16:49:40 <ezyang> ;-) 
16:49:49 <edwardk> copumpkin: ah no, was it posted online somewhere?
16:49:57 * ivanm heads off to uni
16:50:00 <copumpkin> edwardk: yeah, it's a galois talk
16:50:05 * edwardk turns to ezyang, figuring he should probably ask the source. ;)
16:50:41 <ezyang> http://www.galois.com/blog/2010/08/19/tech-talk-abcbridge-functional-interfaces-for-aigs-and-sat-solving/ 
16:50:41 <ddarius> darcs get ezyang
16:50:43 <napping> copumpkin: guess it's time for Agda, and then I think McBride has pretty much covered it
16:50:59 <edwardk> ezyang: oh, neat, you went down the AIG route. =)
16:51:02 <ezyang> yep. 
16:51:06 <koninkje> roconnor: data Nat = Z | S Nat  ===> Der Nat r = IsZ | IsS r ==> cata2Nat f = go where go Z Z = f IsZ IsZ ; go Z (S n) = f IsZ (IsS (go n)) ; go (S m) Z = f (IsS (go m)) IsZ ; go (S m) (S n) = f (IsS (go m)) (IsS (go n))
16:51:16 <copumpkin> napping: yep, or morris
16:51:23 <ezyang> I would have loved to have the library published yesterday, but there are legal issues etc etc 
16:52:12 <edwardk> ezyang: i've been working on a set of smt bindings with nirav dave to talk to stp or yices
16:52:20 <edwardk> ezyang: picked it back up recently
16:52:27 <koninkje> roconnor: make sense?
16:52:42 <ezyang> Oh, nice! 
16:52:54 <edwardk> ezyang: hah, the talk hasn't yet been given, so no slides/presentation yet i presume ;)
16:53:05 <ezyang> I now know enough about SAT solving to definitively say that SMT solvers are really cool :-) 
16:53:12 <ezyang> edwardk: Well, /unpublished/ slides :^) 
16:54:04 <edwardk> ezyang: i think before you went over to galois we talked, because i was hacking on my little ersatz sat monad at the time and playing with aig and nnf reps for internal use, because i wasn't happy with compiling down to a prenex cnf
16:54:45 <ezyang> edwardk: Yep. 
16:54:50 <napping> copumpkin: has morris done anything recently?
16:55:09 <ezyang> Galois ended up picking the representation for me, because they have existing code that needs AIGs. 
16:55:28 <ezyang> But I suspect SMT solvers are what general practitioners want. 
16:57:14 <copumpkin> napping: not sure how recently, but the stuff I've seen by him has been about making universes of "kinds" of types. Mostly strictly positive families
16:57:37 <copumpkin> and he talks about the dreaded containers, of course
16:58:54 <napping> oh, those were strictly positive
16:58:55 <FSalad_III> how about (>-) = flip id, (>>-) = flip fmap?
16:59:01 <koninkje> roconnor: actuall, that definition doesn't work out. I'll have to think about it later
16:59:03 <FSalad_III> leftttoright applicators
16:59:26 <FSalad_III> >>- is like >>= except less monadic ;) and >- even less
16:59:56 <zygoloid> i've seen (.) used as flip id, with horrific consequences
17:00:10 <FSalad_III> :O
17:00:17 <ddarius> @where pleac
17:00:17 <lambdabot> I know nothing about pleac.
17:00:24 <ddarius> @google pleac haskell
17:00:25 <lambdabot> http://pleac.sourceforge.net/pleac_haskell/index.html
17:00:25 <lambdabot> Title: PLEAC-Haskell
17:00:26 <copumpkin> napping: of course in haskell you wouldn't need them to be strictly positive
17:00:46 <copumpkin> napping: but once you don't keep them strictly positive, WHO KNOWS WHAT COULD HAPPEN
17:00:49 * copumpkin makes ghost noises etc.
17:01:02 <napping> copumpkin: not even to implement them in Agda? I guess not, if I don't mind just getting finite values
17:01:15 <ddarius> http://pleac.sourceforge.net/pleac_haskell-on-steroids/index.html
17:01:24 <zygoloid> > let (.) = flip ($) in [(1,'a'),(2,'b'),(3,'c')].lookup(2)
17:01:25 <lambdabot>   Just 'b'
17:02:11 <FSalad_III> g >-> f would consequently be (return . g) >=> f
17:02:33 <FSalad_III> (except it doesn't need a monad instance)
17:02:41 <dolio> koninkje: Is cata2 just simultaneous induction over two values?
17:02:46 <FSalad_III> and I mean g >=> (return . f)
17:03:38 <etpace> :ty foldl1 (>>=)
17:03:50 <etpace> :t foldl1 (>>=)
17:03:51 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
17:03:52 <lambdabot>     Probable cause: `>>=' is applied to too few arguments
17:03:52 <lambdabot>     In the first argument of `foldl1', namely `(>>=)'
17:03:55 <FSalad_III> (= \x -> g x >>- f)
17:03:57 <FSalad_III> :)
17:04:11 <etpace> @hoogle (a -> m b) -> m [a] -> m [b]
17:04:12 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:04:12 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:04:12 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
17:04:55 <etpace> :t return undefined >>= flip mapM undefined
17:04:56 <lambdabot> forall (m :: * -> *) b. (Monad m) => m [b]
17:05:51 <koninkje> dolio: yeah
17:06:26 <koninkje> dolio: But trying to make it general for any recursive type, rather than just for one speciic type
17:06:32 <koninkje> specific types are easy
17:06:45 <dolio> Heh.
17:07:08 <koninkje> My first hunch is close, but it doesn't quite work out
17:07:19 <koninkje> ...and I have a paper to finish just now, so...
17:07:27 <aristid> random blabber: An elegant solution has the modesty not to draw attention to the difficulties it has surmounted.
17:07:50 <ezyang> wow. 
17:08:02 <ezyang> Oleg just sent me this jewel: "monadicValue'' x | False = monadicValue''_sig; monadicValue'' () = genericMonadicValue" 
17:08:22 <zygoloid> ezyang: that's the partial type signatures trick
17:08:37 <ezyang> Yeah. That's so... wow. 
17:08:44 <etpace> partial type signatures?
17:08:53 <geheimdienst> what's the deal with the " marks in there
17:09:02 <geheimdienst> > "monadicValue'' x | False = monadicValue''_sig; monadicValue'' () = genericMonadicValue"
17:09:03 <lambdabot>   "monadicValue'' x | False = monadicValue''_sig; monadicValue'' () = generic...
17:09:05 <zygoloid> doesn't really work though. you'd want ghc to cut the type checking at the signature, and it doesn't
17:09:12 * hackagebot bindings-gts 0.0.1 - Low level bindings supporting GTS, the GNU Triangulated Surface Library  http://hackage.haskell.org/package/bindings-gts-0.0.1 (JoelCrisp)
17:09:14 <roconnor> koninkje: :)
17:09:22 <FSalad_III> zygoloid: hmm maybe .> or >. wouldn't be bad for flip id, building on the OO familiarity ;)
17:09:37 <bobbytek> I'm a newbie!
17:09:39 <bobbytek> Be nice!
17:09:44 <bobbytek> :)
17:09:45 <FSalad_III> >- is more symmetric otoh
17:09:50 <ezyang> zygoloid: Hm? 
17:10:13 <megajosh2> bobbytek: Boo you stink!
17:10:22 <bobbytek> Are there 2 styles of FP: haskell like languages and lisp like languages?
17:10:32 <bobbytek> ie, static vs. dynamic?
17:11:01 <ezyang> zygoloid: I'm not sure what you mean by "cut the type checking" 
17:11:08 <ddarius> bobbytek: No.
17:11:25 <bobbytek> ddarius: sadness
17:11:30 <bobbytek> I missed the boat AGAIN!
17:11:39 <megajosh2> bobbytek: That's nothing restricted to functional languages
17:11:49 <napping> Lisp is often fairly imperative
17:11:57 <megajosh2> I guess some languages emphasize being more imperative or less imperative
17:12:18 <FSalad_III> discussion protipp: agree what 'FP' means first
17:12:22 <FSalad_III> ;)
17:12:38 <QtPlatypus> bobbytek: THre are two styles of typing, static vs. dynamic.
17:12:51 <bobbytek> churches lamda calculus in a programming language
17:13:00 <FSalad_III> there surely is static and dynamic though
17:13:08 <bobbytek> dynamic, strictly speaking, isn't a type system
17:13:21 <napping> I don't think it usually changes how you write functional code that much
17:13:28 <FSalad_III> (dynamic language cynics here would point out that dynamic is the trivial special case of static....)
17:13:48 <napping> once you get to tricky higher order stuff, people seem to mostly write things in a typeable way so they don't get very confused
17:14:16 <bobbytek> So haskell is uses typing more than lisp right?
17:14:26 <roconnor> yes
17:14:29 <megajosh2> Haskell is always static
17:14:37 <bobbytek> Sorta like scala?
17:14:38 <megajosh2> As far as lisp goes, you can use methods
17:14:41 <djahandarie> Except with Data.Dynamic.
17:14:44 <zygoloid> ezyang: i mean, normally, if you write foo :: Int -> Char; foo = some nonsense, you don't get type errors in the /callers/ of foo to do with that nonsense
17:14:55 <megajosh2> Like defgeneric and defmethod macros
17:14:58 <zygoloid> (you only get type errors in the callers of foo if Int -> Char doesn't work as foo's type)
17:14:59 <napping> Scala is kind of different
17:15:10 <zygoloid> with Oleg's trick, you don't get that error message pruning
17:15:12 <megajosh2> So it's sort of optional
17:15:17 <ezyang> Oh, I see. 
17:15:21 <bobbytek> napping: In what way?
17:15:29 <bobbytek> It's type system is more full featured?
17:15:36 <napping> well, it needs a lot more annotations
17:15:48 <napping> but it has also more subtyping to interoperate more with OO things
17:15:51 <bobbytek> I thought it uses type inference as much as possible
17:15:55 <bobbytek> right
17:15:59 <napping> and then some random stuff like implicits
17:16:01 <FSalad_III> napping: hmm you're saying that even dynamic langs have a type system similar to haskell's kind system?
17:16:14 <napping> FSalad_III: I don't think I said anything like that
17:16:17 <bobbytek> heh
17:16:34 <FSalad_III> it's how I parsed "<napping> once you get to tricky higher order stuff, people seem to mostly write things in a typeable way so they don't get very confused"
17:17:09 <napping> nothing to do with the kind system. Just that most higher order functions like 'map' or whatever are written in a way that e.g. Haskell would probably accept
17:17:24 <FSalad_III> (but then I think most static languages don't even statically check arity with constructs like funcall or apply)
17:17:39 <ddarius> Technically, many list functions in Scheme/Lisp are broken...
17:17:42 <FSalad_III> *most dynamic
17:17:53 <megajosh2> Broken?
17:18:14 <napping> FSalad_III: sure, but you'll get very confused if you try to write a fifth-order function where various arguments can have different arities in different applications
17:18:16 <FSalad_III> napping: I just took the kind system as an example of a type system that has only * and (->)
17:18:24 <megajosh2> A language made out of lists has poor list support? lol
17:18:28 <bobbytek> so, what is a good FP language to learn FP from scratch?
17:18:36 <bobbytek> I know about some FP constructs
17:18:44 <ddarius> megajosh2: Lisp isn't made out of lists, it's made out of pairs.  Pairs are not lists.
17:18:46 <etpace> the little schemer is nice
17:18:46 <bobbytek> and a little about lambda calculus
17:18:47 <kmc> bobbytek, Scheme maybe
17:18:54 <kmc> bobbytek, SICP is a classic text
17:19:04 <bobbytek> I have used caml as well
17:19:05 <napping> bobbytek: Stuff like implicits certainly seems to lead to some smooth code, but I'm not familiar enough to tell if there is a grand design, or if it's just a pile of various convenient hacks
17:19:18 <bobbytek> heh
17:19:19 <FSalad_III> napping: yes :) which is a good argument for having a static system I guess
17:19:19 <kmc> Scheme is "just FP", while Haskell is FP + static types + laziness + more types + other stuff
17:19:25 <napping> anyway, subtyping especially makes type inference much harder, so Scala needs more annotations
17:19:34 <kmc> Haskell is pretty unusual and idiosyncratic, among functional languages
17:19:44 <bobbytek> sorta like the c++ of FP?
17:19:48 <kmc> hehehe
17:19:51 <kmc> them's fightin' words
17:20:03 <napping> It's not so unusual compared even to the ML/O'Caml typed languages
17:20:07 <napping> thought more pure an lazy
17:20:14 <napping> fits right in with 
17:20:16 <kmc> bobbytek, in all seriousness, I think Haskell's design is a lot cleaner and more sane than C++, but there is something to that comparison, yes
17:20:19 <napping> Miranda(TM), Clean, etc
17:20:27 <kmc> Haskell has many features but they tend to be pretty orthogonal
17:20:49 <kmc> C++ it seems once you use one feature it draws you into its web
17:20:57 <ddarius> Just cuz you can compile Haskell into C++'s "type" system is no reason to say they are similar.
17:20:58 <lispy> I would say that OCaml is the C++ of FP langs
17:21:06 <kmc> (using constructors? need exceptions for failure.  using references? need constructors for init)
17:21:25 <lispy> Which would make ML/SML the C of FP lang, I suppose
17:21:26 <megajosh2> It does have the O
17:21:29 <kmc> Haskell's type system is a good deal fancier than SML and OCaml's
17:21:36 <kmc> though OCaml has some stuff Haskell lacks
17:21:43 <napping> but that's mostly just adding qualified types
17:22:03 <napping> and SML/OCaml already have the old eqtype vs general type thing
17:22:11 <FSalad_III> ddarius: the point is that most list functions don't handle improper lists? (if I remember correctly that that's the term for lists that aren't nil-terminated)
17:22:24 <megajosh2> OH
17:22:36 <FSalad_III> (actually I don't know whether they do)
17:22:42 <megajosh2> ...oh!
17:22:47 <kmc> napping, do the two MLs have rank-N types? what about existentials?
17:22:49 <lispy> FSalad_III: you mean dotted pairs?
17:22:58 <kmc> pretty sure they don't have polymorphism over type constructors (sez recent jane st. post)
17:23:03 <lispy> dotted pairs are evil in CL
17:23:08 <kmc> tbf we're now out of "Haskell" into GHC-land
17:23:27 <lispy> GHC FTW, though
17:23:37 <napping> bobbytek: anyway, Haskell is the most popular of things that really follow the whole denotational semantics / domain theory approach
17:23:39 <FSalad_III> lispy: or longer (1 . (2 . 3))
17:23:50 <napping> kmc: rank N types is more along the lines of removing restrictions
17:24:13 <kmc> (my "do they" questions were not rhetorical; i don't know, and would welcome an answer)
17:24:25 <napping> bobbytek: like algebraic data, and equational reasoning
17:24:49 <napping> Scheme is pretty good for the basic computing with functions thing, and there are some really good books
17:24:58 <dolio> kmc: No first-class type constructors at all, if edwardk was correct in confirming my statement.
17:25:05 <kmc> Scheme is also good for homoiconicity / metaprogramming / metacircularity
17:25:17 <dolio> kmc: Modules do existential quantification, sort of, but not exactly the same.
17:25:20 <napping> dolio: isn't it just that you can't write an unapplied constructor to get a function?
17:25:27 <kmc> which is to say, for generating / transforming Scheme code, or building little Scheme implementations in Scheme
17:25:46 <kmc> the source-metaprogramming features in GHC Haskell are unwieldy and generally used only as a last resort
17:26:05 <dolio> napping: Right. T list is a type, but list on its own is not a well-formed type expression.
17:26:19 <napping> dolio: like that, but at the value level
17:26:28 <napping> you have to write (fun x => Some x) instead of just Some
17:26:32 <kmc> yeah, you do have to eta-expand unapplied constructors
17:26:38 <napping> doesn't really seem to be that big a deal, honestly
17:26:49 <kmc> yeah, but the lack of first-class tycons is a bigger deal
17:26:54 <dolio> napping: Yes, but there's no type-level lambda either, I think.
17:26:59 <dolio> So you can't work around it.
17:27:03 <napping> hmm?
17:27:09 <napping> we don't have a generic type-level lambda either
17:27:18 <dolio> Not in ML, as far as I know.
17:27:27 <FSalad_III> hey I use TH! $( do { operators <- liftIO (system "grep -e '^(.*::' This.hs"); mapM_ operators ... } )
17:27:28 <lispy> FSalad_III: well, to be fair to lisp, if a function takes a list it shouldn't accept (1 . (2 . 3)), that's like feeding (a,(b,c)) to a function that takes [a] in Haskell
17:27:31 <FSalad_III> (j/k)
17:27:34 <napping> you mean you can't parameterize over type constructors?
17:27:39 <kmc> oh god FSalad_III
17:27:42 <FSalad_III> :D
17:27:47 <copumpkin> lol
17:27:59 <kmc> hmm what's the most frivolous use of TH i've seen
17:28:03 <dolio> napping: I mean you can't write anything like "fun t => t list".
17:28:08 <kmc> sometimes i write some very complicated TH and then realize it's a trivial CPP macro
17:28:11 <dolio> That's not a type expression.
17:28:12 <blackdog_> kmc: string interpolation? :)
17:28:24 <kmc> HsHere you mean?
17:28:26 <dolio> At least, I've never heard of the MLs having that.
17:28:54 <napping> dolio: you can't write something like data T f = Con of (f Int * f Char)?
17:29:07 <napping> or however the type definitions go?
17:29:08 <FSalad_III> lispy: I was just asking whether that's what ddarius means by 'broken'
17:29:15 <blackdog_> kmc: something like that.
17:29:23 <blackdog_> i think there's about six different packages to do it
17:29:38 <lispy> FSalad_III: it's broken at the type level, IMO :)  But, there are reasons why people use the dotted pairs.
17:29:48 <kmc> i was very pleased to see that haskell-src-meta has a new, active maintainer
17:29:51 <lispy> FSalad_III: It's certainly frustrating for production stuff
17:29:53 <kmc> and now builds on current GHC
17:29:53 <dolio> napping: What would be a valid f, considering that 'list' isn't on its own, and we don't appear to have lambda expressions.
17:30:09 <dankna> oh - I'm pleased by that too.  haskell-src-meta is an important package.
17:30:09 <lispy> kmc: yeah
17:30:17 <napping> kmc: anyway, all the rankN and GADTs and stuff are pretty much just a subset of things dependently typed languages do, so it doesn't seem that funny even if we do chop it up into lots of extensions
17:30:17 <kmc> also wouldn't it be (Int f * Char f) ? ;)
17:31:01 <kmc> (int f * char f)
17:31:15 <kmc> bizarro world
17:31:41 <blackdog_> kmc: yeah, that was good.
17:33:45 <dolio> napping: Also, if you want to parameterize by multiple types, you write "('a, 'b) foo" instead of "'a 'b foo". The latter isn't allowed.
17:34:07 <FSalad_III> lispy: efficiency = reasons I suppose
17:34:30 <FSalad_III> (and yes, I was going to point out that the nice thing is that you can't actually do that in .hs ;))
17:34:58 <kmc> OCaml is less sugary in general.  things like eta-expanding unsaturated constructors are usually done in a frontend pass of a Haskell compiler
17:35:22 <dankna> huzzah!  my program compiles again.  still needs work before it's in testable state, but this is progress.
17:35:35 <dankna> I had torn the whole thing to pieces a couple days ago to make major reorganizations.
17:38:47 <kmc> yay dankna :)
17:39:34 <dankna> thanks :)
17:39:56 <FSalad_III> meh... hint for people supplying their own makeprg in haskell vim mode: compiler/ghc.vim sets shellipe to 2>
17:40:06 <FSalad_III> so only the stderr of your makeprg will be used...
17:40:14 * geheimdienst thinks of the terminator in the 2nd movie ... he could become liquid and reassemble in a different form. an interesting kind of refactoring.
17:40:29 <FSalad_III> *shellpipe
17:41:39 <FSalad_III> I guess you can just :set makeprg=myprg\ >&2   as the simplest solution
17:42:05 <bobbytek> is referential transparency the same notion as idempotence?
17:42:07 <FSalad_III> (I'm using a makeprg that automatically cd ..s once for each dot in the modulename if any)
17:42:14 <dolio> No.
17:42:32 <bobbytek> are they related?
17:42:33 <FSalad_III> idempotence is more general if nothing else :)
17:42:53 <FSalad_III> x is idempotent for operation * if x * x = x
17:43:06 <FSalad_III> * is idempotent if this holds for all x
17:43:23 <FSalad_III> function idempotence is the special case where * = composition
17:43:30 <bobbytek> ah
17:43:32 <bobbytek> touche
17:45:37 <FSalad_III> (ignore me, obviously I'm missing the point ;))
17:45:56 <FSalad_III> I guess referential transparency is idempotence for some evaluation operator?
17:46:40 <bobbytek> I'm learning me a haskell atm
17:46:48 * bobbytek learns himself a haskell
17:47:22 <zygoloid> for great good!
17:48:05 <bobbytek> :)
17:48:32 <dolio> Referential transparency means inlining and CSE preserve meaning, essentially.
17:50:06 <bobbytek> CSE?
17:50:13 <bobbytek> sorry, I dumb
17:50:15 <dolio> Common subexpression elimination.
17:50:22 <bobbytek> ah
17:50:41 <dolio> Turning '... e ... e ...' into 'let x = e in ... x ... x ...'
17:51:03 <dolio> e being an arbitrary expression.
17:51:31 <bobbytek> a form of factoring?
17:52:00 <blackdog_> yeah, but compiler driven, usually
17:52:17 <dolio> GHC doesn't do much CSE, because it can cause performance problems.
17:52:43 <bobbytek> compile time performance?
17:52:46 <bobbytek> or runtime?
17:52:48 <dolio> Runtime.
17:52:59 <bobbytek> I would have thought otherwise
17:53:00 <blackdog_> so, if you have two lazy, large lists
17:53:06 <dolio> Sometime holding on to big values in memory is worse than recomputing them.
17:53:15 <blackdog_> and you use the first one completely, and then the second
17:53:21 <blackdog_> (where they're actually the same thing)
17:53:46 <blackdog_> then you might be able to complete in a small amount of memory, because you're using them in a streamed way
17:53:52 <robertmassaioli> Those of us in Computer Science and Engineering departments (CSE) are probably reading this funnily too. 
17:53:54 <blackdog_> CSE would break that
17:54:07 <blackdog_> and tracing space leaks is tricky enough:)
17:54:37 <bobbytek> doesn't haskell have a gc?
17:54:55 <blackdog_> of course
17:54:59 <blackdog_> but that doesn't help
17:55:10 <bobbytek> to references that are maintained?
17:55:16 <dolio> You can't gc, because you're going to use it all eventually.
17:55:17 <blackdog_> after you've been through the first list, you still have a handle on the head
17:58:08 <bobbytek> what sort of problems is haskell better suited at than say a lisp?
17:58:19 <kmc> bobbytek, writing a compiler or an interpreter
17:58:27 <kmc> pattern-matching makes transformation of syntax trees easier
17:58:39 <dolio> Problems where you want to write programs with nice syntax. :)
17:58:40 <zachk> or writing something with syntax other then polish notation 
17:58:44 <kmc> static typing ensures that your compiler's passes don't introduce malformed terms
17:58:57 <kmc> fancy static typing like GADTs ensures that your compiler's passes don't introduce ill-typed terms
17:59:15 <zachk> or a program where you want the compiled version to approach optimized C compiler speeds 
17:59:41 <kmc> hmm there are some pretty good Lisp compilers i thought
17:59:58 <zachk> $$$$$$$$ id imagine 
18:00:07 <dolio> Like Stalin, with its totally uncontroversial name.
18:00:23 <kmc> :t ($) ($) ($) ($) ($) ($) ($) ($) id --- zachk this is how i parsed your statement
18:00:24 <lambdabot> forall b. b -> b
18:00:42 <kmc> bobbytek, also, concurrency
18:00:44 <bobbytek> Stalin sounds cool!
18:00:50 <kmc> though i don't know anything about concurrency in Lisp
18:00:53 <kmc> so maybe i should shut up
18:00:57 <kmc> and concurrency in Clojure is pretty good
18:01:14 <bobbytek> I'm learning about Clojure and Scala atm :)
18:01:14 <kmc> but Haskell has great concurrency support, plus pure parallelism (think: use multi cores without futzing around with threads)
18:01:20 <bobbytek> Mostly Clojure though
18:01:34 <bobbytek> Scala dudes pointed me here for FP :)
18:01:48 <bobbytek> Told me to learn Haskell before Clojure :)
18:02:00 <bobbytek> To REALLY understand FP
18:02:43 <blackdog_> be careful, it'll probably make you vaguely dissatisfied with most other tools you have to use :)
18:03:22 <bobbytek> well, I mostly use java... so that's not hard ;)
18:03:37 <bobbytek> Although groovy helps a lot :)
18:06:51 <zachk> haskell is like nasa space age materials compared to other people learning how to make iron axes 
18:06:59 <zachk> we are talking real lazerssss!
18:07:28 * BMeph is reminded of friggin' sharks...
18:07:29 <blackdog_> i think it's the logical culmination of a few different trends
18:07:46 <aristid> zachk: i think... haskell is like iron tools compared to stone tools, and we haven't remotely reached the space age of programming languages yet :)
18:08:15 <blackdog_> a lot of people I know left java for python/ruby/perl, but that's more a revolt against bad type systems than the idea of types in general
18:08:23 <aristid> BMeph: you are supposed to be reminded of tigers: http://ilfirin.org/liftMeow.png
18:08:33 <zachk> well there is something things more advanced then haskell, though they dont seem to optimized that well, have libraries , and some cant even run their programs just compile 
18:08:53 <Rotaerk> zachk, theorem provers?
18:08:53 <blackdog_> i was at a javascript meetup a couple of days ago, and both of the talks were about ways to minimise mutable state
18:08:55 <zachk> you can just leave out type signatures in haskell 99% of the time 
18:09:00 <zachk> Rotaerk: yea 
18:09:34 <aristid> zachk: in the iron age, they didn't have space age tools because those weren't ready yet. so we don't have space age programming languages because it's not done yet
18:09:48 <aristid> really all i'm trying to say is there's still a long way to go
18:10:27 <bobbytek> aristid: what are we missing?
18:10:33 <blackdog_> aristid: yeah, we shouldn't break our arms patting ourselves on the back quite yet
18:10:34 <bobbytek> we have the turing machine
18:11:31 <aristid> bobbytek: well i know that haskell has some deficiencies (like lack of DT :D) but i don't really know what we are really missing, what will be important in the future
18:11:59 <copumpkin> aristid: I wouldn't say lack of DT is a deficiency :P
18:12:09 <bobbytek> duck typing?
18:12:13 <bobbytek> dynamic typing?
18:12:16 <zachk> dependent types?
18:12:16 <dh__> I think one of the problem of haskell is the learning curve, it's extremely high.
18:12:20 <copumpkin> bobbytek: you can simulate both
18:12:26 <aristid> copumpkin: why?
18:12:28 <bobbytek> no, is that what DT is?
18:12:34 <dh__> I believe that I can't find a haskell job in 10 years. 
18:12:35 <duckinator> hi
18:12:37 <zachk> you can make haskell look like gwbasic or python if you want 
18:12:43 <copumpkin> aristid: massive trade-offs involved :)
18:12:55 <aristid> copumpkin: un-overcomable trade-offs?
18:13:00 <copumpkin> yeah, fundamentally
18:13:21 <bobbytek> What is DT?!?
18:13:23 <copumpkin> but there are plenty of interesting experiments to make DTs more palatable
18:13:25 <copumpkin> dependent types
18:13:43 <aristid> copumpkin: these experiments will hopefully yield something
18:14:01 <copumpkin> I'm certainly hoping :)
18:14:07 <copumpkin> there's already lots of exciting stuff going on
18:14:13 <BMeph> aristid: I prefer: http://mp.blogs.com/.a/6a00d83451d22169e2011168f7c48e970c-250wi
18:14:30 <aristid> BMeph: lol
18:14:56 <blackdog_> dh__: the job market will be a bit tricky for a while, i think
18:15:27 <dh__> Am I the only one care about the learning curve ? 
18:15:32 <BMeph> aristid: That's all I'm asking for... ;)
18:15:33 <blackdog_> the whole point of using an advanced, slightly esoteric language is that it's meant to make programming easier and quicker
18:15:38 <aristid> rofl oleg cat: http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#960831913_rhDdG-A-LB
18:15:40 <blackdog_> so you don't need as many programmers
18:15:55 <bobbytek> DT: discuss
18:15:55 <BMeph> dh__: Some people Like a "learning curve... ;)
18:16:20 <copumpkin> bobbytek: loads of fun
18:16:23 <blackdog_> dh__: the curve isn't _that_ steep, i think, except for unlearning existing habits
18:16:27 <copumpkin> I like my learning super curvy
18:16:31 <blackdog_> it's more that it doesn't stop
18:16:38 <bobbytek> but what does DT stand for?
18:16:42 <bobbytek> I am at a loss
18:16:49 <zachk> a Type variable with a regular variable 
18:16:52 <bobbytek> google says downtown
18:16:54 <zachk> Vector n 
18:16:57 <zachk> like that 
18:16:59 <geheimdienst> Dependent Types™. So weird that even in Haskell there's no place for them.™
18:16:59 <copumpkin> bobbytek: dependent types :)
18:17:08 <bobbytek> ah, thanks :)
18:17:09 <copumpkin> where n is a _value_ of a type
18:17:10 <dh__> In fact, I'm still trying to figure out how arrow loop or rec works. 
18:17:12 <zachk> well Vector n a 
18:17:21 <dh__> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29304#a29304 anybody can help me understand rec ? 
18:17:23 <aristid> Vector 5 Integer
18:17:28 <zachk> yes like that 
18:17:33 <copumpkin> you can still write that in haskell
18:17:47 <aristid> copumpkin: i'd at least want nicer syntax:)
18:17:48 <zachk> or Vector 3 float 
18:17:50 <copumpkin> just not with the nice number literal
18:17:57 <copumpkin> but dependent types are so much more than that
18:18:01 <BMeph> dh__: "UR DOIN IT RONG"? ;)
18:18:03 <bobbytek> does haskell support continuations?
18:18:09 <zachk> yes 
18:18:17 <bobbytek> what are they called?
18:18:17 <zachk> there is a monad for that
18:18:20 <copumpkin> bobbytek: sure, but it depends how you mean
18:18:26 <dh__> BMeph: I don't know why I'm doing it wrong.
18:18:27 <zachk> or you can do cps style 
18:18:42 <bobbytek> essentially a saved stack
18:18:56 <zachk> anything normal ends up being a monad, which are just "special" function "worlds" 
18:19:05 <BMeph> dh__: ...and ->That's<- why you're doing it wrong! ;)
18:19:06 <copumpkin> bobbytek: well, considering immutable values, it's trivial to do in haskell
18:19:13 <bobbytek> ah, true
18:19:24 <copumpkin> bobbytek: in the presence of side-effectful stuff, no
18:19:28 <copumpkin> well, not easily, anyway
18:19:31 <zachk> for starters id say learn the prelude, pattern matching, recursion, and lists 
18:19:46 <bobbytek> what about AOP? is that even logical?
18:19:47 <BMeph> zachk: Have you ever programmed an ATM machine to read MC cards in CPS style? ;þ
18:19:51 <zachk> or just get "Programming in Haskell" by graham hutton 
18:19:51 <aristid> @where lyah
18:19:51 <lambdabot> http://www.learnyouahaskell.com/
18:19:53 <zachk> no
18:19:57 <dh__> BMeph: any good learning stuff on how to understand rec ? 
18:20:04 <zachk> recursion? 
18:20:19 * zachk learned recursion in scheme then moved on 
18:20:25 <copumpkin> dh__: your paste doesn't work cause hpaste is down
18:20:41 <bobbytek> can you do aspect oriented stuff with haskell?
18:20:58 <dh__> mover4 = proc _ -> do
18:20:58 <dh__>            rec
18:20:59 <dh__>                    y <- (+1)  -< x
18:20:59 <dh__>                    x <- (*2)  -< y
18:20:59 <dh__>            returnA -< (x,y)
18:21:11 <bobbytek> or does that not make sense at all?
18:21:39 <dh__> I'm learning rec, so I let y depends on x , and x on y , and when I run mover4, it's seemed enter an endless loop. 
18:21:39 <geheimdienst> i find that an interesting question actually
18:21:57 <zachk> whats rec? 
18:22:04 <zachk> and whats -< 
18:22:04 <geheimdienst> what do you do in haskell if you want, let's say, to log all the calls to some function
18:22:26 <geheimdienst> without major ugliness like putting the function and all its callers in some monad
18:22:29 <copumpkin> oh, arrow notation
18:23:07 <dh__> rec from the Arrow Notation.  http://www.haskell.org/arrows/syntax.html
18:23:17 <copumpkin> dh__: it would make sense for that to enter an infinite loop
18:23:35 <copumpkin> unless you had some form of lazy naturals that support multiplication by 2 cheaply
18:23:48 <dh__> copumpkin: why it will enter a loop?
18:24:39 <copumpkin> dh__: have you ever tried fix (*2) ?
18:24:45 <copumpkin> do you understand fix, first of all
18:24:48 <dh__> or how can I write a simple rec example that will not enter an infinite loop?
18:25:02 <copumpkin> y <- (1:) -< x
18:25:06 <blackdog_> bobbytek: it doesn't make a lot of sense. AOP is about changing the behaviour of code, Haskell is about being explicit about possible effects
18:25:10 <copumpkin> x <- (2:) <- y
18:25:13 <blackdog_> there's a tension there
18:25:13 <Kaidelong> geheimdient: type classes provide some notion of aspect oriented programming don't they? As you can give instance declarations
18:25:22 <dh__> I understand fix a little bit. fix f  = ( x , while f x = x)
18:25:34 <copumpkin> dh__: try what I wrote
18:25:36 <aristid> :t mfix
18:25:37 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
18:26:38 <dh__> copumpkin: I tried, it return an infinite list of 1,2,1,2 , ...
18:26:58 <Kaidelong> You could have one instance declaration of the same type in one module and swap it out with one in another
18:27:00 <geheimdienst> kaidelong, you mean some code expects typeclass X, and i give it for logging purposes my own instance implementing X, which logs and then does the usual thing. right?
18:27:10 <geheimdienst> ah okay :-)
18:28:03 <Kaidelong> geheimdienst: that'd be a specific example
18:28:37 <dh__> mover4 = proc _ -> do
18:28:38 <dh__>            rec
18:28:38 <dh__>                    y <- (1:)  -< x
18:28:38 <dh__>                    x <- (2:)  -< y
18:28:39 <dh__>            returnA -< x
18:28:44 <geheimdienst> i think your point is valid, but it's not AOP very much ... i guess if i had to say that in java terms, that'd be having code that expects an object implementing interface X, which you can swap out
18:28:49 <dh__> head $ mover4 0
18:28:49 <dh__>  return 2.
18:29:00 <copumpkin> dh__: please don't paste in here
18:29:04 <dh__> how comes the system knows the first x ? 
18:29:05 <copumpkin> just use something like pastie if hpaste is down :)
18:29:11 <copumpkin> dh__: laziness
18:29:13 <dh__> sorry , does hpaste works?
18:29:18 <copumpkin> and yeah, it should return a pair of infinite lists
18:29:24 <geheimdienst> so i think typeclasses are more akin to java interfaces
18:29:55 <bobbytek> http://en.wikipedia.org/wiki/INTERCAL : rad
18:30:04 <copumpkin> dh__: no, but pastie.org or any number of other sites do :)
18:30:15 <copumpkin> dh__: anyway, if you understand fix, that example is very similar
18:30:16 <dh__> copumpkin: thanks.
18:30:36 <copumpkin> it's giving you mutual recursion, in that case
18:30:43 <aristid> i don't know if some of you can do it, but desugaring proc notation mentally is not trivial, and i think it's a disadvantage of using it
18:30:51 <copumpkin> it's like, at the top level, writing x = 1:y; y = 1:x
18:31:03 <aristid> > fix (1:)
18:31:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:31:13 <aristid> > fix (1:2:)
18:31:14 <lambdabot>   The operator `:' [infixr 5] of a section
18:31:14 <lambdabot>      must have lower precedence th...
18:31:17 <copumpkin> aristid: yeah, it's way more complex, but if you reason about what it's doing it's not too hard to see how you'd translate it using the arrow combinators
18:31:37 <megajosh2> @hoogle fix
18:31:38 <lambdabot> Data.Function fix :: (a -> a) -> a
18:31:38 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
18:31:38 <lambdabot> module Control.Monad.Fix
18:32:26 <BMeph> > fix ((1:).(2:))
18:32:27 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
18:32:54 <dh__> does pastie.org exists ? or because I'm inside the Great FireWall? 
18:33:17 <copumpkin> http://www.haskell.org/arrows/sugar.html
18:33:24 <geheimdienst> try pastebin.com
18:33:30 <copumpkin> dh__: try pastebin.com or gist.github.com
18:33:58 <dh__> copumpkin: thanks
18:35:26 <dh__> is there a visual programming tool that support point-free style? 
18:35:51 <copumpkin> dh__: anyway, the basic answer is that it gives you a form of recursion inside your arrow, similar to fix
18:35:58 <FSalad_III> how do I get ghc-6.12.3/ghc/ghc.cabal to work?
18:36:21 <FSalad_III> cabal haddock --hoogle says that STAGE is not in scope
18:38:50 <dh__> copumpkin: thanks. that lazy stuff helps me a lot.
18:39:13 <FSalad_III> maybe #ghc
18:44:42 <BMeph> I get arrow notation, but "Arrow Calculus" still gives me the willies...
18:48:17 <copumpkin> does anyone have an iteratee that allows you to seek and requests certain amounts of data?
18:48:23 <copumpkin> :P
18:49:33 <dolio> Oleg's slides have random-access iteratees.
18:49:41 <copumpkin> ah
18:51:02 <ddarius> My hamburger melted...
18:51:37 <copumpkin> ddarius: put it in the freezer
19:11:40 <dh__> where I can find API document for Yampa ? for example, there is not docuemnt on accumHold in Yampa?
19:15:47 <yaru1022> Hi, I'm reading the enumerator package source code (http://hackage.haskell.org/packages/archive/enumerator/0.1/doc/html/src/Data-Enumerator.html), but I have a question.
19:16:31 <BMeph> yaru1022: Well, ask! ;)
19:16:36 <yaru1022> in "instance Monad m => Monad (Iteratee e a m) where" part
19:16:39 <Arnar> hi all
19:17:13 <Arnar> does anyone remember seeing (or writing) operational semantics for haskell exceptions?
19:17:15 <yaru1022> when you say m >>= f, wouldn't the type of f be (Step e a m b -> Iteratee e a m b) ?
19:17:20 <BMeph> dh__: Have you exhausted http://haskell.org/yampa for hints? ;)
19:17:32 <dh__> BMeph: yes. 
19:18:53 <yaru1022> BMeph, oh wait... I think I got it lol
19:18:58 <yaru1022> nvm =)
19:19:41 <dh__> finally I got a Yampa example works : a ball that bounce between (-100, 100) 
19:19:49 <Arnar> nm, found it
19:21:49 <dh__> if you are interested , it's in http://pastebin.com/XHZVgfTH
19:23:16 <dh__> and I'm wondering that how long it will take me to write a collision module for a pool game in Yampa , :(
19:37:42 <leimy> I'm still finding iteratee difficult to understand, even with iteratee and enumerator packages :-)
19:39:20 <etpace> iteratee is fine, its enumeratees that are brainfrazzling
19:42:44 <leimy> Well I have a program I'd like to write a certain way.  Right now I'm consuming characters 1 at a time from a serial line, and combining them looking for patterns
19:42:57 <leimy> kind of in a TCL Expect sort of way.
19:43:07 <leimy> I'd rather get chunks of data, something like "take"
19:43:23 <leimy> > take 5 [1..4]
19:43:24 <lambdabot>   [1,2,3,4]
19:43:37 <leimy> yeah, basically that behavior :-)
19:44:03 <dh__> leimy: then why do you need iteratee?
19:44:12 <leimy> I don't know that I do :-)
19:44:28 <leimy> in fact the code I have now works pretty well, though I do worry about all the hGetChar
19:45:17 <dh__> leimy: then what is your question?
19:46:39 <leimy> dh__: I'm wondering if it's worth going to iteratee or just trying something else from System.IO
19:48:09 <leimy> My current feeling is that hGetBuf and ByteStrings would be all the optimization I need at this point.
19:49:25 <ezyang> leimy: If you don't have memory requirements, reading the string strictly into memory is a good way of doing things. 
19:54:34 <sbidin> Is it possible to "reverse" (>>)? For instance, make x >> y == x, and not y?
19:54:50 <sbidin> I know it might not make sense, but could one accomplish this somehow?
19:54:53 <copumpkin> sure
19:54:55 <copumpkin> :t (>>)
19:54:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:55:04 <copumpkin> :t liftM2 const
19:55:05 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
19:55:28 <copumpkin> sbidin: you also want to decide what order you want the effects to happen in though
19:55:31 <copumpkin> the type doesn't convey that
19:55:58 <copumpkin> :t flip (liftM2 (flip const))
19:55:59 <lambdabot> forall a2 a1 (m :: * -> *). (Monad m) => m a2 -> m a1 -> m a2
19:56:01 <copumpkin> that's the other way around
19:56:37 <sbidin> Fantastic! Thanks for the help and speedy reply.
19:59:05 <copumpkin> no problem
19:59:13 <copumpkin> there are also various similar things in Control.Applicative
19:59:15 <copumpkin> :t (<*)
19:59:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
20:06:50 <jaredj> Made my own tree type instead of using Data.Tree. Is that really stupid or merely silly?
20:07:25 <jaredj> data TextTree = Branch String [TextTree] | Leaf String String
20:07:26 <kmc> it's a good exercise
20:07:37 <kmc> jaredj, i have the impression Data.Tree is not so popular
20:07:40 <kmc> i have no real basis for that
20:07:50 <kmc> the module doesn't provide so much stuff
20:08:00 <jaredj> hmm, i guess i couldn't use pattern matching if i used Data.Tree
20:08:17 <kmc> jaredj, you could, it's not an abstract type
20:08:17 <jaredj> er, constructor guards
20:08:29 <kmc> :t \(Node x _) -> x
20:08:30 <lambdabot> forall t. Tree t -> t
20:08:45 <copumpkin> jaredj: why not parametrize the type to make your operations on it more general?
20:10:01 <jaredj> because i'm from python and c ;P
20:10:29 <copumpkin> lol
20:14:00 <jaredj> data Tree k v = Branch k [Tree k v] | Leaf k v
20:14:22 <kmc> Haskell has the temptation to premature generalization :)
20:14:29 <kmc> however in some cases the general version is actually easier to write
20:14:47 <jaredj> type TextTree = Tree String String
20:14:50 <kmc> parametricity is on your side: when you know nothing about the type contained in the tree, there's fewer mistakes you can make because you tree operations all have to be purely structural
20:15:04 <jaredj> sure
20:16:46 <jaredj> lessee, how do you haddock a module :d
20:18:00 <jaredj> right
20:35:45 <calsaverini> hi
20:35:56 <jaredj> ho
20:36:38 <calsaverini> I was reading some text on categories and haskell (don't know much about this) and the guy said the following about Functors
20:37:23 <calsaverini> that from the type of fmap, the second "functor law" fmap (f.g) = (fmap f).(fmap g) follows as a free theorem
20:37:38 <calsaverini> what does this means exactly?
20:37:45 <dolio> @free fmap
20:37:45 <kmc> it means you can prove it just from the types
20:37:46 <copumpkin> do you know what free theorems are?
20:37:46 <lambdabot> Expected variable or '.'
20:37:51 <kmc> there are papers about this, e.g. "Theorems for free"
20:37:59 <dolio> @free map :: (a -> b) -> F a -> F b
20:37:59 <lambdabot> g . h = k . f => $map_F g . map h = map k . $map_F f
20:38:02 <calsaverini> I have a slight idea
20:38:03 <copumpkin> free theorems are just properties of natural transformations
20:38:32 <calsaverini> this really means ANY function with type (a -> b) -> f a -> f b will have this property?
20:38:42 <dolio> Yes.
20:38:54 <kmc> any function with type «forall a b. (a -> b) -> F a -> F b»
20:38:56 <kmc> for your particular F
20:39:06 <kmc> since a and b are totally unknown, there's not much you can do
20:39:12 <calsaverini> I've heard about the free theorems thing, but I wasn't sure this would hold for any function...
20:39:26 <calsaverini> hummm... there's this forall thing
20:39:39 <calsaverini> right
20:39:40 <kmc> "forall" is a way of writing explicitly what's implicit in Haskell 98
20:39:47 <dolio> I believe you need the identity law to prove the composition law.
20:40:02 <kmc> which is that a type variable gets filled in by the caller, thus the function must allow any type there
20:40:07 <calsaverini> <dolio> you meand fmap id = id?
20:40:43 <calsaverini> well, I should read more about this
20:40:55 <dolio> Yeah. Off the top of my head. I may be remembering incorrectly, though.
20:41:05 <calsaverini> what is the necessary background to understand the this kind of thing?
20:41:18 <calsaverini> I mean... I'm not a mathematician nor a computer scientist :P
20:41:40 <calsaverini> (I'm just a poor physicist...)
20:41:45 <dolio> I'm not sure what the background for the Theorems for Free paper would be.
20:43:30 <calsaverini> BTW, do you have any suggestion of a simple text about type theory?
20:43:41 <calsaverini> I don't even know if this is really the name of the field.
20:44:29 <calsaverini> all the mathematics about types and recursive functors (is that it?) 
20:44:57 <calsaverini> I was trying to read some articles but I get stuck trying to understand this things
20:45:34 <dolio> http://intuitionistic.wordpress.com/works-on-martin-lofs-type-theory/
20:45:39 <dolio> Some of the stuff there is pretty good.
20:46:00 <dolio> The Intuitionistic Type Theory from 1984 is surprisingly readable.
20:46:18 <jaredj> oh noes! hpaste down: 58030 14: unable to open database file
20:46:28 <kmc> calsaverini, TaPL?
20:46:29 <kmc> @where tapl
20:46:29 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
20:46:38 <kmc> calsaverini, this is a great intro book to type theory
20:46:52 <calsaverini> hummmm
20:46:55 <kmc> it gets a bit into recursive types as fixed points of functors etc
20:46:56 <calsaverini> nice
20:47:03 <kmc> it's definitely good background for that stuff
20:47:08 <calsaverini> I guess this is the king of thing I need
20:47:14 <calsaverini> thanks
20:47:24 <dolio> Functor stuff you can eventually get by learning category theory.
20:47:46 <dolio> Although, after learning some basics, you'll probably have to look for papers with a more computer science bent.
20:48:06 <jaredj> http://haskell.pastebin.com/a8arXCpR
20:48:33 <dolio> Since mathematicians tend to be less interested in the comp sci applications, as far as text books go.
20:49:12 <sbidin> If (>>) by definition doesn't pass the the contents of the monad to the second-argument function, how am I able to use it with the State monad to advance the state?
20:49:36 <kmc> it doesn't pass the result of the first action
20:49:49 <kmc> «a >> b» is just  «a >>= (\_ -> b)»
20:49:59 <kmc> depending on how (>>=) is defined, this could easily pass some "hidden" state
20:50:14 <sbidin> Aaah, I see... thanks.
20:50:40 <kmc> jaredj, fwiw i like codepad.org as an alternative to hpaste
20:50:46 <kmc> pastebin is kinda ugly and cluttered
20:50:56 <jaredj> i'm trying to make it a parse error to, say, have a <compound2> tag at the toplevel, but presently it isn't. why not?
20:51:00 <kmc> right now it's trying to sell me hotel deals in las vegas
20:51:01 <jaredj> ah, yes, codepad looks much simpler
20:52:06 <QtPlatypus> Oddly enought some of my key releizations about cat theory was made while reading mathmatics mayed difficult.
20:52:26 <QtPlatypus> made
20:56:07 <calsaverini> wow, codepad looks awesome for colaboration...
21:08:13 <lispy> When was the seen command removed from lambdabot?
21:08:17 <lispy> ?seen lispy
21:08:17 <lambdabot> Unknown command, try @list
21:09:00 <copumpkin> ages ago
21:09:03 <copumpkin> cause it was unreliable
21:09:14 <copumpkin> maybe a year or so?
21:09:57 <lispy> heh, oh
21:10:06 <lispy> <-- is clearly a little slow
21:10:44 <lispy> QtPlatypus: that sounds interesting.  Is it a book or a website or ?
21:10:57 <jaredj> ?seen ?seen
21:10:57 <lambdabot> Unknown command, try @list
21:12:48 <dmwit> lispy: preflex has an analogue
21:12:52 <dmwit> preflex: seen lispy
21:12:52 <preflex>  lispy was last seen on #haskell 2 minutes and 8 seconds ago, saying: QtPlatypus: that sounds interesting.  Is it a book or a website or ?
21:13:02 <dmwit> preflex: seen dmwit
21:13:03 <preflex>  dmwit was last seen on #haskell 11 seconds ago, saying: preflex: seen lispy
21:13:07 <lispy> dmwit: yeah, but I wanted it in #darcs which has lambdabot but not preflex 
21:13:20 * dmwit nods sympathetically
21:14:04 <QtPlatypus> lispy: Its a book but its been scanned and put online.
21:14:10 <lispy> It's funny how terrible lambdabot is at being a bot, but good at being a calculator
21:14:45 * djahandarie will finish making his bot one day
21:15:03 <lispy> djahandarie: are you starting from dons's tutorial?
21:15:22 <djahandarie> I did, but it looks absolutely nothing like it
21:15:28 <djahandarie> Looks more like xmonad
21:15:52 <lispy> djahandarie: is it a tiling channel bot?
21:15:58 <djahandarie> Haha not quite
21:16:03 <djahandarie> A ReaderT StateT IO monad drives it
21:16:24 <dmwit> RWST, the king of monads
21:16:26 <djahandarie> And it uses attoparsec for the parsing
21:16:44 <lispy> dmwit: then Cont is still the mother/Queen
21:16:53 <dmwit> Cont is like the progenitor or something
21:17:23 <djahandarie> Oh neat, I never knew there was a single monad transformer for that
21:17:40 <djahandarie> I don't actually use StateT though, I use some concurrent-friendly variant... I forget its name
21:17:57 <lispy> djahandarie: STM?
21:18:05 <djahandarie> Nah
21:18:10 <dmwit> STM isn't (can't be) a transformer.
21:18:17 <dmwit> err... I think
21:18:30 <c_wraith> It would be like having IOT
21:18:30 <djahandarie> It's called MState
21:18:51 <lispy> What is RWST equal to?  ReaderT + WriterT + StateT?
21:18:58 <dmwit> yes
21:19:03 <dmwit> But more efficient.
21:19:12 <lispy> If you have a ReaderT and WriterT why also have StateT?
21:19:22 <djahandarie> Why not!
21:19:23 <dmwit> For bits that can be both read and written.
21:19:49 <c_wraith> Because it's easier to think in terms of "immutable environment," "mutable state," and "output"
21:19:57 <djahandarie> Instead have a ReaderT + WriterT + ReaderT + WriterT
21:20:01 <lispy> ReaderT for your environment, WriterT for your logging/auditing, and StateT for your application state?
21:20:15 <djahandarie> RWRWRWRWRWRWRWRWRW monad
21:20:33 <copumpkin> RWST!
21:20:35 <copumpkin> mmm
21:20:50 <kmc> WURST
21:21:07 * djahandarie had to look that up to make sure it wasn't real
21:21:08 <kmc> ROWST
21:21:10 <lispy> We write RWST-full programs
21:21:25 <Axman6> ROWSIT
21:21:31 <lispy> ?unmtl RWST
21:21:31 <lambdabot> err: `RWST' is not applied to enough arguments, giving `/\A B C D E. A -> C -> D (E, C, B)'
21:21:45 <lispy> ?unmtl RWST a b c d e
21:21:45 <lambdabot> a -> c -> d (e, c, b)
21:22:11 <dmwit> ?unmtl RWST r w s m a
21:22:12 <lambdabot> r -> s -> m (a, s, w)
21:22:21 <djahandarie> So, is there still a battle between MTL and whatever else?
21:22:36 <dmwit> There's a migration path away from mtl, I believe.
21:22:37 <lispy> djahandarie: yeah
21:22:50 <lispy> monadLib and something else are winning then?
21:22:56 <Kaidelong> Monad does not appear in this pocket dictionary of mathematical terms
21:23:03 <Kaidelong> nor Monoid, although it does have Group
21:23:18 <lispy> Kaidelong: does it have module?
21:23:48 <Kaidelong> nope
21:24:22 <lispy> So they left out all the uncommon parts of algebra?
21:24:38 <Kaidelong> doesn't have ring either
21:24:45 <lispy> hmm
21:24:48 <dmwit> Maybe it's for small pockets.
21:24:58 <lispy> Does it focus on some particular area, like real analysis?
21:25:05 <lispy> Kaidelong: fields are surely in it though?
21:25:27 <Kaidelong> lispy: "For teachers, engineers, scientists, computer scientists, high school and college students."
21:25:43 <kmc> is that a dictionary of mathematics in your pocket
21:25:49 <Kaidelong> it has field yes
21:26:11 <Kaidelong> I find it funny that you don't learn about monoids before learning about groups, though
21:26:23 <Kaidelong> since a monoid is almost a group
21:26:36 <Veinor> what do monoids lack, inverses?
21:26:40 <kmc> yes
21:26:41 <Kaidelong> yep, IIRC
21:26:54 <Veinor> that's what makes sense thinking about Monoid
21:26:54 <kmc> there isn't necessarily an inverse for each element
21:26:58 <djahandarie> I wonder if someone has made a pocket dictionary of category theory
21:27:04 <kmc> (there may or may not be depending on the element)
21:27:15 <lispy> Veinor: heh, I misread that with s/what/why, and thought you were setting up a joke
21:27:16 <Veinor> when I want to remember monoids I think of ++
21:27:18 <Kaidelong> groups are a subset of the monoids
21:28:23 <lispy> "Why do monoids lack inverses?"  "I don't know."   "so they can cross the road!"
21:29:17 <Veinor> haha
21:29:29 <kmc> what's yellow and relates functors to Set with natural transformations from a hom-functor?
21:29:42 <Veinor> I don't know, what?
21:29:48 <kmc> yoneda's lemon
21:30:01 <Veinor> :D
21:30:06 <lispy> What's purple and commutes?
21:30:08 <sbidin> Is it possible to pattern-match functions?
21:30:19 <dmwit> An abelian grape!
21:30:20 <lispy> sbidin: there is no pattern for functions
21:30:22 <kmc> sbidin, no (if you mean what i think)
21:30:38 <lispy> sbidin: The problem is, we don't have a data constructor for them
21:30:41 <dmwit> What's the integral of d(cabin)/cabin?
21:30:49 <copumpkin> sbidin: what would it mean, anyway?
21:30:59 <kmc> houseboat
21:31:18 <jaredj> ._.
21:31:26 <dmwit> natural log cabin
21:31:35 <dmwit> It's only a houseboat if you remember to add C. =)
21:31:36 <sbidin> Well, lets say the function f is receiving (\_ -> Int) and wishes to just return that Int. How could I do this?
21:31:48 <jaredj> dmwit ARGH
21:32:03 <calsaverini> @free (>>=)
21:32:03 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
21:32:14 <calsaverini> ¬¬
21:32:14 <dmwit> @. free type (>>=)
21:32:15 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
21:32:23 <dmwit> :t (>>=)
21:32:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:32:29 <kmc> sbidin, by calling the function you're given with any argument of the appropriate type
21:32:32 <dmwit> ?free Monad m => m a -> (a -> m b) -> m b
21:32:32 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
21:32:33 <lispy> > let f g = g 1 in f (\_ -> 4)
21:32:34 <lambdabot>   4
21:32:49 <dmwit> free probably doesn't do typeclasses
21:32:56 <sbidin> kmc, but I do not know the type in advance. Could I somehow make it work generally?
21:32:57 <calsaverini> @free id
21:32:58 <lambdabot> f . id = id . f
21:33:13 <calsaverini> hummm... it makes sense :)
21:33:14 <kmc> sbidin, how can you not know the type in advance? Haskell is a statically typed language
21:33:25 <kmc> sbidin, you're trying to write a function of type «(a -> Int) -> Int»?
21:33:34 <sbidin> Correct.
21:33:40 <Veinor> @free const
21:33:40 <kmc> you could always use «undefined» or «error "don't evaluate me bro"»
21:33:41 <lambdabot> f . const x = const (f x) . g
21:33:44 <dmwit> :t ($ undefined)
21:33:44 <lambdabot> forall a b. (a -> b) -> b
21:33:46 <kmc> it will work if the function really doesn't evaluate its arg
21:33:53 <kmc> sbidin, this is a strange thing to want to do
21:33:58 <kmc> what problem are you trying to solve?
21:33:58 <calsaverini> I like this free theorem stuff! Really interesting...
21:34:09 <lispy> kmc: it's not that strange when you're playing with CPS
21:34:22 <kmc> Haskell: where "A implies B" implies B
21:34:36 <dmwit> Oh, go on, sound logics are no fun to program in.
21:34:41 <dmwit> You can't even write loops. =)
21:34:46 <calsaverini> (why, oh why, I learned about functional programming so late... If someone told me about it while I was still an undergrad...
21:34:48 <kmc> dmwit, i've had a lot of fun with coq
21:35:06 <dmwit> Yes, okay, Coq and Agda do reasonably well for themselves.
21:35:08 <kmc> calsaverini, yeah, it's a big gap in most CS programs
21:35:12 <calsaverini> It would really change the course of my academic carreer.
21:35:35 <calsaverini> <kmc> my case is worst, I'm not even a computer scientist... hahaha
21:35:42 <JoeyA> > [1..5] >> "%02x" -- this is a cool trick, but am I missing out on an obvious function?
21:35:43 <lambdabot>   "%02x%02x%02x%02x%02x"
21:35:43 <sbidin> kmc, I'm trying to implement the (>>=) function, but I don't want it to care about the argument given to its second argument. (In other words, say, x >>= (\_ -> y) == y.)
21:35:51 <kmc> calsaverini, you confused me a sec, i didn't remember saying that ;)
21:36:03 <JoeyA> > concat $ replicate 5 "%02x" -- longer, but (arguably) clearer alternative
21:36:03 <lambdabot>   "%02x%02x%02x%02x%02x"
21:36:04 <kmc> JoeyA, what are you trying to do?
21:36:15 <JoeyA> > take 5 $ cycle "%02x" -- another alternative
21:36:15 <calsaverini> <kmc> but I WOULD become a CS if I've learned about Haskell some 8 years ago...
21:36:15 <lambdabot>   "%02x%"
21:36:21 <JoeyA> (err, make it 5*4)
21:36:29 <calsaverini> seriouslly... 
21:36:47 <kmc> sbidin, why?  what sort of monad has that as its (>>=)?
21:37:04 <JoeyA> I'm writing this function:  hash2hex (Word160 a b c d e) = printf ([1..5] >> "%02x") a b c d e
21:37:22 <sbidin> kmc, a custom one! :D I'm doing it just to see if I can, really.
21:37:28 <kmc> concatMap (printf "%02x") [a,b,c,d,e]
21:37:33 <kmc> sbidin, strange
21:37:40 <kmc> but sounds like a fun exercise :)
21:37:41 <dmwit> sbidin: But not all functions behave that way.
21:37:44 <kmc> what are the semantics of this custom monad?
21:37:47 <copumpkin> kmc: mapM_ ?
21:37:48 <dmwit> sbidin: You are trying to define a partial (>>=) ?
21:37:57 <copumpkin> kmc: oh, the string output :)
21:38:03 <kmc> copumpkin, depends, printf can produce either String or IO ().  you could use "sequence" in the latter case
21:38:09 <copumpkin> yeah
21:38:14 <kmc> well, not with concatMap ;P
21:38:16 <sbidin> What I'm really trying to do is pass state with (>>).
21:38:24 <sbidin> But I don't want to use the State monad.
21:38:28 <kmc> sbidin, did you look at how the actual State monad is implemented?
21:38:31 <kmc> it's only a few lines
21:38:36 <dmwit> sbidin: (I mean to say, your equation (x >>= (\_ -> y) = y) is not a good definition, because the "pattern" (\_ -> y) doesn't capture all functions.)
21:39:07 <kmc> dmwit, one can imagine having other pattern-matching cases.  though it's not clear what they'd be
21:39:11 <sbidin> kmc, No, I don't think I've seen the actual definition as of yet. Where could I find one?
21:39:32 <dmwit> ?src State (>>=)
21:39:32 <lambdabot> Source not found. I feel much better now.
21:39:38 <dmwit> ?src (>>=) State
21:39:38 <lambdabot> Source not found. :(
21:39:45 <dmwit> ?source Control.Monad.State
21:39:45 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
21:39:49 <kmc> sbidin, my sources for docs are http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ and http://hackage.haskell.org/packages/archive/pkg-list.html
21:39:58 <dmwit> ?source Control.Monad.State.Lazy
21:39:58 <lambdabot> Control.Monad.State.Lazy not available
21:39:58 <kmc> sbidin, State is in the "mtl" package so i'd go to the latter and choose "mtl"
21:40:03 <kmc> those haddock pages have source links
21:40:09 <sbidin> Great, thanks! I'll give it a go.
21:41:01 <kmc> what's yellow and useful for pricing options
21:41:13 <JoeyA> kmc: monad syntax is more fun here
21:41:17 <JoeyA> > printf "%02x" =<< [10,20,30,40,50] :: String -- "plug" the array into printf ;-)
21:41:18 <lambdabot>   "0a141e2832"
21:41:23 <JoeyA> err, list, list!
21:41:26 <kmc> nice JoeyA :)
21:41:35 <kmc> list?
21:41:41 <Veinor> eww, printf
21:42:00 <dmwit> > flip showHex "" =<< [10, 20 .. 50]
21:42:01 <lambdabot>   "a141e2832"
21:42:06 <dmwit> ah
21:42:09 <dmwit> sneaky =)
21:42:09 <kmc> (Itō's lemon)
21:42:25 <calsaverini> :O
21:42:38 <calsaverini> <kmc> hahahahahahaha...
21:42:43 <dh__> > printf "%02x" =<< [10,20,30]
21:42:44 <lambdabot>   Ambiguous type variable `b' in the constraints:
21:42:44 <lambdabot>    `Text.Printf.IsChar b'
21:42:44 <lambdabot>  ...
21:43:03 <dh__> > printf "%02x" =<< [10,20,30]::String
21:43:04 <lambdabot>   "0a141e"
21:43:05 <calsaverini> hey guys, thank you very much for the help
21:43:12 <calsaverini> you are all very kind as usual
21:43:17 <Veinor> :D
21:43:25 <EvanR> :t fix
21:43:26 <lambdabot> forall a. (a -> a) -> a
21:43:29 <calsaverini> see ya
21:43:53 <dh__> :t printf
21:43:54 <lambdabot> forall r. (PrintfType r) => String -> r
21:44:04 <copumpkin> > printf "%02x" =<< [10,20,30]
21:44:05 <lambdabot>   Ambiguous type variable `b' in the constraints:
21:44:05 <lambdabot>    `Text.Printf.IsChar b'
21:44:05 <lambdabot>  ...
21:44:08 <copumpkin> boo
21:44:19 <dh__> @where printf
21:44:19 <lambdabot> I know nothing about printf.
21:44:29 <dh__> :i printf
21:44:42 <kmc> what's yellow and describes the limits of finite state machines
21:44:51 <dh__> :i printf
21:44:54 <mauke> pumping lemon
21:44:56 <dh__> @src printf
21:44:57 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:45:09 <kmc> what's yellow and like the pumping lemon but more confusing
21:45:13 <dh__> where is this printf defined?
21:45:19 <Veinor> copumpkin: yeah you have to explicitly cast it to String because it does the horrible IO () thing
21:45:20 <dmwit> Text.Printf
21:45:21 <mauke> @index printf
21:45:21 <lambdabot> Text.Printf
21:45:24 <copumpkin> yeah
21:45:31 <dh__> @index printf
21:45:31 <lambdabot> Text.Printf
21:45:32 <Veinor> it's like printf and sprintf combined!
21:45:32 <kmc> ogden's lemon
21:45:34 <dh__> thanks!
21:45:40 <kmc> this concludes my weekly joke series, "into the ground"
21:45:47 <dmwit> What's yellow and equivalent to the axiom of choice?
21:45:55 <dmwit> Zorn's Lemon!
21:45:57 <Veinor> nothing, because theorem's don't have colors!
21:46:02 <Veinor> *theorems
21:46:07 <blackdog_> dmwit: i thought that was a free jazz ensemble
21:46:34 * blackdog_ hums "squeeze my lemma baby"
21:46:43 <JoeyA> ogden's lemon: almost reminds me of that Simpsons episode
21:46:45 <EvanR> Veinor: put its cool, like small bit of php's power available in haskell ;)
21:46:53 <Veinor> :P
21:47:01 <EvanR> function that does everything!
21:47:32 <JoeyA> (Ogdenville is a nearby town to Springfield in the Simpsons.  However, the episode I'm referring to had to do with Shelbyville and lemons, not Ogdenville.)
21:47:50 <Veinor> I've always wondered, if they decide to split it: should printf print and sprintf string format, or printf just do string formatting?
21:48:12 <JoeyA> I've always wondered: how the heck did they manage to implement printf anyway?
21:48:23 <Veinor> evil magic!
21:48:42 <EvanR> it secretly uses variadic C procedures! ;)
21:48:57 <lispy> Nah, just clever (but simple) type classes
21:49:00 <kmc> the "standard" one uses type classes
21:49:03 <kmc> there's also a template haskell version
21:49:09 <dh__> @index bind
21:49:09 <lambdabot> bzzt
21:49:14 <EvanR> i.e. abuse of type classes ;)
21:49:17 <kmc> but the best way to do formatted IO in a language like Haskell is to use some format combinators with nice types, rather than a string
21:49:20 <kmc> @quote stark
21:49:20 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
21:49:20 <lispy> The standard one is even valid in Haskell98 IIRC
21:49:39 <kmc> the only reason the string is the format specifier type in C is that the choice of types in C is so limited
21:49:41 <mauke> kmc: I disagree
21:50:01 <lispy> printf in C is a DSL for output
21:50:25 <lispy> not the best, but the terseness is actually nice for some uses
21:50:56 <sbidin> Would it be possible to simplify the State monad even further if we limit ourselves to carry and return a value of the same type?
21:51:17 <EvanR> would that be a monoid
21:51:19 <lispy> sbidin: what do you mean carry and return?
21:51:25 <mauke> I don't think that's a monad
21:51:44 <mauke> :t (>>=)
21:51:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:51:53 <Deewiant> lispy: runState :: State a -> a -> (a,a)
21:52:04 <blackdog_> kmc: it'd be nice to use the string as a specifier, but statically check that it makes sense. has that been done?
21:52:06 <EvanR> m a -> (a -> m a) -> m a
21:52:13 <kmc> blackdog_, with template haskell
21:52:19 <lispy> It seems like it would be hard to make the state monad simpler
21:52:25 <kmc> i still don't see why a string is a good way to implement this DSL, rather than an embedded DSL?
21:52:26 <lispy> It's already pretty simple
21:52:27 <kmc> is it just terseness?
21:52:36 <blackdog_> terseness is important
21:52:48 <kmc> sure, but is there something more to it
21:53:04 <lispy> blackdog_: gcc statically checks statically known printfs.
21:53:09 <kmc> as does ocaml
21:53:13 <kmc> both by special cases in the compiler, iirc
21:53:19 <mauke> ocaml doesn't have "real" printf
21:53:47 <Axman6> Clang does some very nice checking of printf formats. it's a really nice feature to have
21:53:54 <sbidin> lispy, by carry and return I mean the values which the State monad holds within itself. State { runstate :: oldstate -> (retval, newstate) }
21:54:01 <Axman6> seems to go a lot further than GCC ever did for me
21:54:05 <blackdog_> yeah. much nicer to have it as a library feature
21:54:29 <lispy> sbidin: okay. Then I see why people were saying you'd get a monoid.
21:54:47 <blackdog_> Axman6: it's a bad design to have to recover intent at the code generation level, i think
21:55:01 <Heffalump> that would still be a monad
21:55:05 <Heffalump> not sure I see the point though
21:56:03 <sbidin> Heffalump, I consider it an exercise. :) I'm relatively new to the language.
21:56:13 <BMeph> So, when are we going to have a TH version of fst/snd/thd et al.?
22:00:58 <sbidin> BMeph: do people actually use tuples to hold more than three elements? Seems unwieldy.
22:01:15 <EvanR> quaternions!
22:01:25 <kmc> define a new type instead
22:01:48 <EvanR> well people return 4tuples all the time
22:01:50 <EvanR> in php
22:01:50 <lispy> newtype Quaterion a b c d = Q (a, b, c, d)
22:02:04 <kmc> yeah if it's common practice in php it's definitely good design
22:02:30 <lispy> I knew it!  /me goes off to code up a 34 rule table for equality
22:02:34 <sbidin> I say we need one of those mysql_real_escape_string functions.
22:02:40 <kmc> lispy, any advantage to the newtype+tuple versus "data"?
22:02:51 <mauke> sbidin: it could be integrated into printf
22:02:58 <mauke> a format modifier
22:02:59 <EvanR> by 4tuples i mean Either Bool (Int, Maybe String, Maybe (Either Bool String), (String,String))
22:03:06 <kmc> :(
22:03:13 <Veinor> EvanR: what the hell?
22:03:14 <kmc> EvanR says that just to make me sad
22:03:18 <EvanR> lol
22:03:20 <EvanR> im not joking
22:03:29 <Heffalump> One of the core functions in some code I maintain at work has grown over time to use a 13-tuple.
22:03:31 <EvanR> people implicitly define types like this in php
22:04:09 <EvanR> Heffalump: lucky
22:04:11 <kmc> Heffalump, we had a C++ class with a constructor of type Foo(bar*, const baz*, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool)
22:04:17 <Axman6> @remember kmc yeah if it's common practice in php it's definitely good design
22:04:17 <Heffalump> Also, some of the users of the same codebase use big enough tuples we starting pushing the GHC limit, because we use tuples to mirror data structures that can get quite wide.
22:04:17 <lambdabot> Good to know.
22:04:20 <kmc> all of those bools have default values, some true, some false
22:04:38 <kmc> (this was the place i *used* to work, thankfully)
22:04:47 <lispy> kmc: well, newtype won't add any 'additional' overhead compared to the tuple
22:04:57 <kmc> sure
22:05:03 <EvanR> kmc: good thing it wasnt trooleans
22:05:11 <Heffalump> but how is it different from data Quaterion a b c d = Q a b c d ?
22:05:16 <kmc> the newtype is good if you want to go between Quaternion and the tuple
22:05:19 <kmc> which could be useful for a view
22:05:32 <kmc> if you wanted Quaternion itself to be abstract, for whatever reason
22:05:48 <EvanR> im wondering why Quaternion is parameterized on all four elements
22:06:08 <Veinor> a quaternion of floats, sets, trees, and functions obviously
22:06:14 <EvanR> lol
22:06:36 <BMeph> @remember kmc we had a C++ class with a constructor of type Foo(bar*, const baz*, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool)
22:06:36 <lambdabot> It is forever etched in my memory.
22:06:38 <EvanR> Floating a => Q a = Q a a a a
22:06:40 <lispy> Heffalump: well, in yours if you add bangs you can get GHC to unpack it when it has registers available, so that could be a huge win
22:07:21 <kmc> BMeph, and people would add more bools to it (still with defaults), and not always at the end
22:07:29 <mauke> what is lavender and commutes?
22:07:33 <kmc> or two people would each add one at the end and then fuck up the merge
22:07:49 <EvanR> ._.
22:08:31 <Veinor> that's horrible
22:08:59 <lispy> That is terrible, but it's not really uncommon
22:09:01 <BMeph> kmc: That reminds me of an MS spot...
22:09:13 <kmc> in the case of all bools there is a simple and ancient solution: the bitfield
22:09:41 <EvanR> "its too simple" ive heard as serious arguments against things like that
22:10:01 <ddarius> kmc: in the case of a large tuple there is a simple and ancient solution: the record 
22:10:11 <mauke> O_WRONLY | O_CREAT | O_EXCL
22:10:23 <kmc> ddarius, but those are a pain in C++
22:10:25 <Veinor> O_RLY
22:10:37 <mauke> open("/dev/owl", O_RLY)
22:11:27 <dh__> what's the meaning of the ~ in  \ ~(Num u ) -> means?  
22:11:38 <dmwit> It's a lazy pattern match.
22:11:46 <dolio> It means that you're certain the pattern will match.
22:11:53 <dmwit> It means, don't bother checking that the damn thing is actually a Num constructor until you actually have to use u.
22:12:07 <dh__> thanks.
22:12:10 <kmc> (and then throw an exception if it's not)
22:12:17 <dh__> lol
22:13:42 * hackagebot enumerator 0.1.1 - Implementation of Oleg Kiselyov's left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.1.1 (JohnMillikin)
22:13:46 <Axman6> > (\~Just 3 -> "hello") undefined
22:13:46 <lambdabot>   <no location info>: parse error on input `->'
22:13:53 <Axman6> > (\~(Just 3) -> "hello") undefined
22:13:54 <lambdabot>   <no location info>: parse error on input `->'
22:14:03 <lucca> > let foo ~(x:xs) = x in foo []
22:14:03 <lambdabot>   *Exception: <interactive>:1:137-151: Irrefutable pattern failed for pattern...
22:14:40 <lucca> though an example with undef would be more useful
22:14:45 <lispy> You can do something similar with let. foo x = let Just y = x in y
22:14:48 <dh__> thanks, those examples make me understand better.
22:15:12 <lispy> Then the pattern match failure happens where you use y instead of where you accept x
22:15:22 <ddarius> The Report explicitly states that a let binding is irrefutable.
22:15:49 <lucca> let doesn't evaluate anything
22:16:19 <dolio> > (\~(u, Just _) -> u) (5, Nothing)
22:16:20 <lambdabot>   <no location info>: parse error on input `->'
22:16:28 <dolio> > (\ ~(u, Just _) -> u) (5, Nothing)
22:16:29 <lambdabot>   *Exception: <interactive>:1:138-156: Irrefutable pattern failed for pattern...
22:17:05 <ddarius> > (\(u, ~(Just _)) -> u) (5, Nothing)
22:17:06 <lambdabot>   5
22:18:18 <dh__> > (\ (u, ~(Just v)) -> v) ( 5, Nothing)
22:18:19 <lambdabot>   *Exception: <interactive>:1:138-158: Irrefutable pattern failed for pattern...
22:18:33 <dmwit> ?src fromJust
22:18:33 <lambdabot> fromJust Nothing  = undefined
22:18:33 <lambdabot> fromJust (Just x) = x
22:18:41 <dh__>  (\ (u, (Just v)) -> v) ( 5, Nothing)
22:19:10 <dh__> >  (\ (u, ~(Just v)) -> v) ( 5, Nothing)
22:19:11 <lambdabot>   *Exception: <interactive>:1:138-158: Irrefutable pattern failed for pattern...
22:19:26 <dh__> >  (\ (u, (Just v)) -> v) ( 5, Nothing)
22:19:27 <lambdabot>   *Exception: <interactive>:1:138-157: Non-exhaustive patterns in lambda
22:20:06 <ddarius> > fromLeft (do Nothing <- Just (); return ())
22:20:07 <lambdabot>   Not in scope: `fromLeft'
22:20:16 <ddarius> > either id undefined (do Nothing <- Just (); return ())
22:20:17 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe ()'
22:20:17 <lambdabot>         against inferred...
22:20:25 <ddarius> > either id undefined (do Nothing <- return $ Just (); return ())
22:20:26 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:20:26 <lambdabot>    `Control.Monad.Error.Cla...
22:22:32 <mauke> Q: What's an anagram of "Banach-Tarski"?
22:22:37 <mauke> A: Banach-Tarski Banach-Tarski.
22:22:47 <kmc> haha
22:23:13 <kmc> mauke, what is lavender and commutes?
22:23:20 <mauke> an abelian semi-grape
22:23:46 <kmc> hehehe
22:23:54 <dmwit> What is lavender, commutes, and has a few worshippers?
22:24:03 <dmwit> A finitely-venerated abelian semigrape.
22:24:46 <dmwit> O_o
22:24:52 <dmwit> mathworld has a citation for its jokes
22:25:45 <Pseudonym> I had a wonderful mathematical meta-joke, but unfortunately the margin is too small to contain it.
22:33:49 <Pseudonym> Q: What's the difference between sysadmin and a category theorist?
22:34:02 <Pseudonym> A: A category theorist only believes they are God up to isomorphism.
22:34:21 <jystic> :)
23:00:27 <Axman6> @src (^)
23:00:28 <lambdabot> x ^ 0            =  1
23:00:28 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
23:00:28 <lambdabot>   where f _ 0 y = y
23:00:28 <lambdabot>         f x n y = g x n
23:00:28 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
23:00:30 <lambdabot>                       | otherwise = f x (n-1) (x*y)
23:00:32 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
23:01:09 <Pseudonym> I wonder what kind of code that compiles into.
23:01:20 <Axman6> machine
23:01:22 <Axman6> >_>
23:01:22 <Pseudonym> I have to wonder if the double recursion unnecessarily complicates things.
23:01:24 <kmc> sad code
23:01:39 <Pseudonym> _ ^ _ <- Lesser-known Japanese emoticon.
23:02:01 <Axman6> ^_^'s cousin
23:02:26 <kmc> :t \w v -> w<*($)*>v
23:02:27 <lambdabot> forall a a1 b b1. ((a1 -> b) -> a) -> ((a1 -> b) -> b1) -> (a1 -> b) -> b1
23:04:58 <kmc> @djinn ((a1 -> b) -> a) -> ((a1 -> b) -> b1) -> (a1 -> b) -> b1
23:04:58 <lambdabot> f _ a b = a b
23:05:59 <Pseudonym> @free f :: ((a1 -> b) -> a) -> ((a1 -> b) -> b1) -> (a1 -> b) -> b1
23:05:59 <lambdabot> (forall f2 f3. h . f2 = f3 . g               =>                k (q f2) = f1 f3) => (forall f6 f7. h . f6 = f7 . g               =>                p (f4 f6) = f5 f7) => h . f8 = f9 . g => p (f q f4
23:05:59 <lambdabot> f8) = f f1 f5 f9
23:06:15 <Polarina> Isn't (^) implemented in gmp for Integer?
23:06:34 <Pseudonym> Not that I know of.
23:06:42 <Polarina> That's sad. :(
23:06:54 <Pseudonym> Well, a more common case is Integer ^ Int.
23:07:04 <Pseudonym> It's rare that you have to raise to the power of an insanely large Integer.
23:07:27 <Pseudonym> And no, powmod doesn't count.
23:07:42 <Polarina> Hehe. :P
23:11:25 <Pseudonym> But seriously, I can't imagine that most cases of Integer ^ Integer would result in a number that fits in memory.
23:13:41 <Polarina> > (2 :: Integer) ^ (64 :: Integer)
23:13:41 <lambdabot>   18446744073709551616
23:14:02 <Pseudonym> But 2 and 64 both fit in Int.
23:14:11 <Polarina> But not the result.
23:14:15 <Pseudonym> True, I wasn't very clear.
23:22:00 * hackagebot proc 0.0.4 - Parse process information for Linux  http://hackage.haskell.org/package/proc-0.0.4 (AndyStewart)
23:25:29 <dolio> > 2 ^ (2 ^ 64)
23:25:34 <lambdabot>   mueval: ExitFailure 1
23:27:18 <jystic> @pl getFloat32le >>= \v -> return (MsgFloat32 v, ds)
23:27:18 <lambdabot> (flip (,) ds . MsgFloat32) `fmap` getFloat32le
23:27:51 <jystic> @pl getFloat32le >>= \v -> return (ds, MsgFloat32 v)
23:27:51 <lambdabot> ((,) ds . MsgFloat32) `fmap` getFloat32le
23:48:12 <kmc> http://cufp.org/jobs/programmer
