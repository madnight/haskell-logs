00:02:40 <augur> guys
00:02:46 <augur> what should i do with my NeXT computer
00:03:22 <Zao> Paint spots on the sides and use as a d6.
00:03:35 <augur> no >o
00:03:57 <c_wraith> sounds pretty awesome to me
00:04:24 <augur> its also not a cube
00:04:43 <augur> NeXTstation
00:41:38 <Gracenotes> hm, is intersectionWith so efficient that it's worth doing Map.intersectionWith const mainMap (Map.fromDistinctAscList . map (flip (,) ()) $ Set.toList smallerSet)?
00:42:23 <Gracenotes> now if there were only an intersectionWithDistinctAscList.. /s
00:44:11 <Gracenotes> essentially a nice way to do mass lookups with a subset of the map's keys
00:51:26 <handonson> hi. I didn't import Data.ByteString.Char8 but ghci tells me that I have instance Data.String.IsString ByteString defined in Data.ByteString.Char8 in the scope. Is there an easy way I can figure what module is importing (and exporting) this instance among the ones I imported?
00:52:08 <Cale_> handonson: How many imports do you have? You could load them in ghci and see if the instance is there using :info IsString
00:52:32 <handonson> Five. Okay, let me try that.
00:58:28 <handonson> Weird. I don't have any module that answers positively when I ask for :info IsString, and I have defined an instance of IsString only in Types.hs, but ghci complains about duplicate instance declarations
00:59:37 <handonson> Data.ByteString.Char8 shouldn't be in my scope at all
01:01:02 <handonson> grr
01:04:46 <handonson> Data.Attoparsec was the problem
01:05:31 <handonson> although you can't see anything in ghci with Prelude Data.Attoparsec> :info IsString
01:08:20 <handonson> Can I make "import Data.Attoparsec" not to import the instance Data.String.IsString ByteString defined in Data.ByteString.Char8?
01:17:23 <handonson> Or is this a ghc/ghci bug? Data.Attoparsec doesn't even export anything about instance Data.String.IsString ByteString. It only imports it and uses it internally. But ghci still complains about the overlapping
01:18:35 <Zao> Instances are universably visible once defined.
01:18:44 <Zao> And you can't restrict them in any way.
01:19:05 <Zao> Which is quite annoying if some random library decides to add a "helpful" instance.
01:20:10 <handonson> No workaround?
01:21:46 <dark> handonson, can't you use hiding?
01:21:55 <dark> import X hiding (y, ..)
01:22:06 <kmc> you can't specify an instance that way, iirc
01:22:20 <Zao> Write to your senator about the dangers of instance pollution.
01:22:25 <kmc> instances are weird and second-class
01:22:36 <handonson> dark: Wouldn't I try that before asking
01:22:58 <kmc> i'd like to see them scrapped in favor of something like Scala's implicit parameters
01:23:36 <handonson> So... No workaround?
01:24:04 <Zao> handonson: Except applying a hacksaw to the module that defines it?
01:24:14 <handonson> Except that.
01:24:22 <handonson> Because it seems impossible.
01:24:41 <Zao> I'd say that that instance is warranted, as it's in the package that defines the type, really.
01:25:04 <kamil_> first time trying haskell, cool beans
01:25:06 <Zao> Maybe you could nag to the maintainer to move it to another module as an orphan?
01:25:48 <dark> beans?
01:27:02 <handonson> Zao: Well, it's Data.Attoparsec and Data.Attoparsec imports Data.Attoparsec.Char8 in a qualified way, which again imports Data.ByteString.Char8
01:27:27 <handonson> And the Data.Attoparsec functionalities are quite dependent on Data.Attoparsec.Char8 and ...
01:28:06 <Zao> handonson: Oh right, attoparsec. I thought this was all about BS.Char8.
01:28:49 <dark> handonson, does parsec has this design issue too?
01:29:27 <handonson> dark: parsec doesn't handle ByteString by default.
01:29:54 <handonson> well, that's not accurate.
01:30:21 <handonson> i mean, parsec wouldn't need to import Data.ByteString.Char8 at all. i think.
01:30:29 <dark> unless you define your own parsers, i imagine
01:30:56 <dark> (i think you can define parsers for arbitrary data structures, althrough this is too much work)
01:31:36 <handonson> my problem is:
01:32:02 <handonson> Data.ByteString.Char8 has an instance of IsString which I just want to smash to the death
01:32:35 <handonson> because it simply DESTROYS non-ASCII strings during the conversion to ByteString
01:32:53 <handonson> my idea was to implement my own IsString ByteString instance with Data.ByteString.UTF8.fromString
01:33:11 <handonson> and use the {-# LANGUAGE OverloadedStrings #-}
01:33:42 <handonson> so I can safely put UTF-8 ByteStrings anywhere in my code by simply using the string literal, "like this."
01:33:59 <quicksilver> I would use a newtype for that, handonson 
01:34:27 <quicksilver> newtype UTF8ByteString = MkUTF8ByteString ByteString
01:34:58 <handonson> well..
01:35:01 <handonson> would you elaborate?
01:35:24 <quicksilver> UTF8-encoded isn't a "natural" IsString instance for bytestring
01:35:27 <quicksilver> it's just one possible encoding
01:35:37 <quicksilver> so it doesn't deserve to be the IsString instance for bytestring.
01:35:49 <quicksilver> so make a newtype to tag - in the type system - the encoding you are using.
01:35:54 <handonson> where Char8 packing is a far more unnatural IsString instance
01:36:04 <quicksilver> unnatural but historical.
01:36:24 <quicksilver> you might consider Data.Text, which is designed for this.
01:36:58 <handonson> what I meant by elaborate was
01:37:13 <handonson> say there's a function f :: ByteString -> IO ()
01:37:26 <handonson> what I want to do is { f "blah blah" }
01:37:54 <handonson> which should feed some UTF-8-encoded ByteString to f.
01:37:54 <quicksilver> you're outta luck I'm afraid.
01:38:52 <dark> no, this makes no sense. bytestring is just a bunch of bytes, right? one ought to be able to put anything there
01:39:10 <handonson> i can already put anything there
01:39:14 <quicksilver> he's outta luck because of the conflicting instance in D.BS.Char8
01:39:17 <quicksilver> that's the only reason.
01:39:25 <handonson> it's just that i can't { f "blah" }
01:39:38 <dark> but one can do a function transform_string_literal_to_utf8_encoded_byte_string
01:39:39 <handonson> i'm doing { f $ fromString "blah" } now
01:39:47 <dark> ahm
01:39:53 <handonson> and what I want is to get rid of that fromString.
01:39:55 <Zao> dark: Like say, the encoding ones in Data.Text.
01:40:22 <quicksilver> handonson: what is "f" ? arguably it's not a very good function if it takes ByteString but expects UTF8 encoding?
01:40:29 <quicksilver> the best solution seems to be to wrap f.
01:40:36 <dark> handonson, can't you do f x = f $ fromString x?
01:40:42 <quicksilver> hide it and replace it with a better f.
01:40:44 <dark> @pl \x . f $ fromString x
01:40:44 <lambdabot> (line 1, column 4):
01:40:45 <lambdabot> unexpected "."
01:40:45 <lambdabot> expecting operator, pattern or "->"
01:40:55 <dark> @pl \x -> f $ fromString x
01:40:56 <lambdabot> f . fromString
01:41:00 <dark> erm
01:41:24 <dark> yes, f = f . fromString
01:41:30 <handonson> quicksilver: Data.ByteString.hPutStrLn, Data.ByteString.hGetLine, ...
01:41:42 <handonson> many.
01:42:08 <quicksilver> handonson: wrap them, or use Data.Text, which is better designed for this.
01:42:29 * boegel yanks BONUS' chain again
01:42:52 <handonson> I use Network.Socket.ByteString
01:43:25 <handonson> that's why i'm dealing with BS
01:43:56 <handonson> Network.Socket seemed to have the 8-bit truncation problem (although I didn't test it thoroughly, since I found Network.Socket.ByteString, i just switched)
01:45:38 <quicksilver> the old style IO libraries truncated.
01:45:52 <quicksilver> in 6.12, System.IO was changed to encode strings instead of truncating them
01:46:17 <handonson> which is a big headache for people like me who live in CJK countries...
01:46:34 <handonson> not that I prefer CJK over English
01:46:40 <quicksilver> why are you using Network.Socket? UDP?
01:46:44 <handonson> i just have to use them everyday, you know
01:47:20 <handonson> ...because other higher-level libraries built on Network.Socket shares the 8-bit truncation problem?
01:47:33 <quicksilver> nope
01:47:39 <quicksilver> the Handle-based API in Network is fine
01:47:50 <quicksilver> if you write to a handle using System.IO you get your Strings encoded.
01:48:07 <handonson> Ah, sorry. that one was what I was talking about
01:48:10 <quicksilver> (this is a property of Handles rather than sockets)
01:48:21 <handonson> the handle-based API had the truncation problem
01:48:25 <quicksilver> if you're using GHC 6.12, Handles do not truncate.
01:48:58 <handonson> err, they did. the handle returned by socketToHandle had the truncation problem.
01:49:32 <quicksilver> did you try hSetEncoding?
01:49:35 <handonson> maybe just because I didn't hSetEncoding, i don't know. it truncated, and I just switched before looking into it deeply.
01:49:37 <quicksilver> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-IO.html#23
01:51:21 <quicksilver> handonson: even then, why were you using socketToHandle?
01:51:27 <handonson> i didn't.
01:51:42 <quicksilver> so why did you speak of "the handle returned by socketToHandle" ?
01:51:44 <handonson> i was just specifying what handle i was talking about
01:53:00 <quicksilver> the socket returned by connectTo or accept, then ;)
01:53:12 <handonson> right
01:53:24 <handonson> should've been clearer
01:53:35 <quicksilver> hSetEncoding to what you want and you should be fine.
01:53:57 <quicksilver> I don't know what encoding it's firing up in by default (although you can try to find out with hGetEncoding)
01:54:12 <handonson> the problem is, all the code I wrote that deals with BS should be rewritten if I take that approach
01:54:38 <handonson> like the attoparsec parsers
01:54:46 <quicksilver> well, bytestrings are a poor choice of data type if it annoys you to have to specify encoding, since bytestrings dont' have an implicit encoding
01:54:53 <quicksilver> so you have to mention it specifically
01:55:04 <quicksilver> but it would be fairly simple to wrap hPutStrLn and friends if that's what you want.
01:55:06 <handonson> i don't get annoyed
01:55:29 <handonson> i just wanted a...
01:56:01 <handonson> f "asdf", which isn't that big deal
01:57:50 <handonson> now i come to think the IsString ByteString instance in BS.Char8 (which defines fromString to be BS.Char8.pack) should be taken away, leaving the choice to the coders
01:58:29 <handonson> or, if "taking away" is to radical, replace with UTF8.fromString, which is fully backward-compatible
01:58:34 <handonson> too radical*
01:59:56 <handonson> well, not fully backward-compatible, if there were some sick coders using the 8-bit truncation as a feature, using "안녕" to say "HU"
02:07:56 <Zao> handonson: Char8 is all about "treat a bytestring as a sequence of truncated Char"
02:08:03 <Zao> If you want that behaviour, you import it. If you don't, don't.
02:08:28 <Zao> Complain at the attoparsec author if he imports things unnecessarily?
02:09:01 <handonson> Zao: yeah! treat a BS as a sequence of truncated Char, and don't do anything to Strings! so i can use OverloadedStrings on my choice.
02:09:47 <quicksilver> an overloadedstrings instance which encoded bytestrings as UTF8 would be morally wrong.
02:09:56 <quicksilver> instances should exist when they are natural.
02:10:01 <quicksilver> UTF8 is not natural for bytestring.
02:10:12 <quicksilver> (and there are other well-behaved types like Text, designed to solve this properly)
02:10:27 <handonson> your idea is not to have instance IsString ByteString at all?
02:10:59 <handonson> since you agreed that 8-bit truncation is not natural for BS either
02:11:09 * hackagebot uu-parsinglib 2.5.3 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.3 (DoaitseSwierstra)
02:12:13 <quicksilver> handonson: yup.
02:13:24 <handonson> well i'm cool with that, but that's hardly possible, especially if you think about the packages dependent on that instance
02:13:57 <handonson> on the other hand, replacing minimizes that impact...
02:14:52 <quicksilver> I doubt there are any packages dependent on that instance.
02:15:10 <handonson> Snap, for example.
02:15:15 <quicksilver> really?
02:15:17 <quicksilver> that's awful
02:15:18 <quicksilver> snap--
02:15:33 <quicksilver> what a terrible decision to depend on such a useless instance :P
02:15:49 <aleator> \me gets frustrated with ghc performance tuning
02:18:16 <aleator> I can either pass a function as a parameter or copypaste 20 lines over and over again. Guess which solution I can't get to execute fast.. :/
02:19:12 * hackagebot blaze-builder 0.1 - Builder to efficiently append text.  http://hackage.haskell.org/package/blaze-builder-0.1 (JasperVanDerJeugt)
02:19:54 <tkahn6_> ghc doesn't support inline functions?
02:20:15 <Cale> tkahn6_: What do you mean by inline?
02:20:30 <mietek> On a scale of 1 to 10, how serious do you suppose Haskell on a Horse is?
02:20:45 <Cale> tkahn6_: There are a couple of meanings I can think of, but the answer is that GHC supports them in each case.
02:21:17 <tkahn6_> ah well aleator is saying that copy+pasting a function 20 times is giving him better performance than passing a function in as an argument
02:21:46 <Cale> oh, I see
02:22:31 <tkahn6_> out of curiosity, how would one inline a function in Haskell (with ghc)?
02:22:50 <aleator> tkahn6_: {-#INLINE f#-}
02:23:03 <tkahn6_> thanks
02:23:25 <tkahn6_> wouldn't that solve your problem with optimization?
02:23:34 <Cale> Well, ghc automatically inlines a lot of stuff anyway. You can use the INLINE pragma to declare the inlining cost to be very low.
02:23:46 <aleator> I'd like to inline lambda, which doesn't really work
02:23:57 <tkahn6_> oh i c
02:24:26 <tkahn6_> is there a reason you can't name it?
02:24:27 <quicksilver> could be specialization you're suffering from aleator 
02:24:33 <quicksilver> but without more info I can't tell.
02:24:35 <aleator> It really can't inline anything since it is not know at compile time what it actually will receive
02:25:20 <tkahn6_> you cant do something like `f = (\x -> x)`?
02:25:33 <Cale> aleator: hmm, that sounds suspicious, given that you're able to replace it with fixed variants of the function you're supplying a function to
02:26:35 <quicksilver> mietek: it looks experimental and in early stages but quite serious, to me.
02:27:03 <aleator> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28581#a28581
02:27:23 <aleator> I can't really paste this all, since it is mess, but there goes.
02:28:04 <aleator> tkahn6_: See paste.
02:28:17 <tkahn6_> thanks
02:28:48 <tkahn6_> haha i just started learning haskell a few weeks ago so I don't really understand most of that
02:29:40 <aleator> Well, I can't yet read core enough to see whats wrong either..
02:29:48 <McManiaC> (f = \x -> x) == (f x = x)
02:29:49 <McManiaC> :P
02:30:40 <tkahn6_> i kno :)
02:32:28 <kmc> aleator, CPP to the rescue?
02:32:31 <quicksilver> aleator: is there type class there? does "strat" have a type-class polymorphic type?
02:34:51 <aleator> quicksilver: Shouldn't have.. What kind of effect that could have?
02:34:57 <aleator> kmc: aiee! :)
02:37:25 <quicksilver> it can make slower code by doing a dictionary pass
02:37:40 <quicksilver> whereas when you inline by hand GHC is better at seeing the dictionary statically and eliminating the pass.
02:37:58 <quicksilver> it's a common case in which copy-paste code is faster. But apparently not the reason this time.
02:38:05 <aleator> quicksilver: That bit me once already, but everything here is just basic types.
02:38:08 <kmc> aleator, is that a squeal of approval or disgust? ;P
02:38:18 <aleator> kmc: I think despair :)
02:38:22 <quicksilver> aleator: are you compiling with -O2?
02:38:27 <aleator> quicksilver: yes.
02:38:59 <quicksilver> how much slower is it?
02:39:28 <aleator> quicksilver: around 10%
02:39:41 <quicksilver> hmm. That's not that big. That could just be the case analysis.
02:39:52 <aleator> (before saying hmph, this thing is supposed to run for a week or two)
02:40:31 <aleator> quicksilver: Shouldn't the case analysis happen just once here?
02:46:23 <mietek> quicksilver: the operator overloading overload and the project name have led me to the idea that perhaps it's a parody
02:46:58 <quicksilver> well the name is a parody certainly
02:47:06 <Peaker> should I be bothering with this guy? http://www.reddit.com/r/programming/comments/cw6ct/why_haskell_isnt_popular_in_the_industry_9_reasons/c0w0qcl
02:47:11 <quicksilver> what do you mean by operator overloading overload?
02:47:18 <quicksilver> Peaker: it's a reddit comment. The answer is no.
02:48:26 <aleator> Is there, btw, way to change rts parameters at runtime? Different phases of my program seem to require different ones..
02:48:40 <quicksilver> aleator: I fear not :-(
02:48:47 <kmc> aleator, doubtful -- there's certainly some which can't be changed
02:48:51 <quicksilver> a better RTS API would be nice.
02:48:55 <kmc> which do you want to tweak?
02:48:58 <quicksilver> (well, *any* RTS API)
02:49:33 <aleator> kmc: I'd like different gc parameters
02:49:55 <aleator> For some reason my program is very very picky on those.
02:50:06 <kmc> you can perform a major GC as an IO action
02:50:42 <tkahn6_> Peaker: good response. the guy is clearly either trolling or trying to rationalize not being able to grok haskell
02:50:56 <Peaker> tkahn6_, thanks
02:51:07 <aleator> Well.. Perhaps I can drink coffee for few days and just leave it as is :/
02:51:39 <EpicUser> is there any way to pretty print haskell data structures?
02:51:42 <ivanm> Peaker: wtf? how is Haskell apparently a massive troll?
02:52:00 <kmc> aleator, if you're feeling adventurous, the RtsFlags structure is just a global variable, you can write some C code to frob it at runtime
02:52:03 <tkahn6_> i think you should just drop it though since hes not going to be able to reciprocate the same level of intelligence in his response
02:52:45 <quicksilver> kmc: does that work?
02:52:48 <kmc> i have no idea
02:52:53 <quicksilver> they're not cached by various bits of code at startup?
02:52:57 <tkahn6_> ivanm: he's quoting the parent
02:53:03 <kmc> i expect it to work for some flags, do nothing for others, and cause horrible bugs for others
02:53:09 <Peaker> ivanm, read the history above
02:53:10 <quicksilver> sounds fair :)
02:53:18 <kmc> but if you grep the RTS source you see that the RtsFlags variable is read in various files
02:53:35 <kmc> debugging crashes in the RTS is great fun
02:53:46 <ivanm> tkahn6_, Peaker: yes, I'm reading graeunwolf's message
02:54:04 <ivanm> Peaker: if you are of a mind to continue, you might wish to point out that 1) hoogle is an abstraction away from a specific IDE and lets you find functions that are not specific to a particular object (e.g. static methods); and top-level type sigs add documentation for free without having to explicitly write what values are required and in what order, etc.
02:54:29 <osaunders> Question: Some people scoff at Haskell. What are there reasons?
02:54:37 <osaunders> *their
02:54:44 <kmc> osaunders, you're asking us?
02:54:55 <osaunders> Yeah.
02:55:05 <kmc> well, people who scoff at Haskell usually don't know much about it
02:55:24 <osaunders> I want to send an email to a mailing list to get some study-buddies for learning Haskell.
02:55:30 <quicksilver> yeah, the scoffers are ignorant. It's the polite condescenders you have to worry about :)
02:55:32 <Nibble> hello, how do I switch the place of 1 and 2 in a tuple? (1,2)
02:55:45 <quicksilver> > \(x,y) -> (y,x) $ (1,2)
02:55:46 <lambdabot>   Couldn't match expected type `a -> b'
02:55:46 <lambdabot>         against inferred type `(t1, t)'
02:55:48 <dobblego> osaunders, usually it's because they have a very poor understanding
02:55:50 <kmc> not everyone who learns Haskell likes it, but most everyone who learns Haskell will at least admit that it's a serious language with some interesting ideas
02:55:51 <Nibble> osaunders: you are elarning haskell?
02:55:53 <tkahn6_> switch (x, y) = (y, x)
02:56:01 <Peaker> ivanm, why don't you reply to him too?
02:56:02 <kmc> or:  switch ~(x,y) = (y,x)
02:56:03 <Nibble> thetallguy: thank
02:56:05 <quicksilver> > (\(x,y) -> (y,x)) $ (1,2)
02:56:05 <lambdabot>   (2,1)
02:56:08 <kmc> though the difference usually won't matter
02:56:11 <quicksilver> > swap (1,2)
02:56:12 <lambdabot>   Not in scope: `swap'
02:56:18 <osaunders> Nibble: Yes, I have been for quite a while.
02:56:22 <tkahn6_> oh that's cool
02:56:28 <Nibble> osaunders: you said you are looking for study buddies?
02:56:33 <osaunders> Yes.
02:56:39 <tkahn6_> \x -> x + 2
02:56:42 <ivanm> Peaker: no reddit account ;-)
02:56:44 <Nibble> osaunders: pm
02:56:45 <kmc> osaunders, i think one problem is the learning curve.  people are used to jumping into a new language and learning it as just alternative syntax for something they already know
02:56:51 <Peaker> ivanm, it takes 5 seconds to create one :)
02:57:03 <kmc> it'd be as if you learned French and Spanish and Italian and Portuguese easily, and then one day tried to learn Chinese
02:57:11 <Nibble> ugh, chinese
02:57:13 <kmc> and so this is understandably frustrating
02:57:17 <ivanm> I procrastinate enough by _reading_ reddit, let alone responding and getting into arguments myself!
02:57:24 <Peaker> ivanm, heh
02:57:43 <kmc> and some people react to the frustration of not being a Haskell master in one week by lashing out
02:57:46 <Peaker> tkahn6_: Feel free to respond too if you want, I gotta go.  Thanks!
02:58:06 <kmc> you'll find a lot of blogs out there with a post "yay, i'm going to learn Haskell, yippee!" and another post one week later "haskell sucks, here is an exhaustive list of why"
02:58:06 <osaunders> kmc: OK.
02:58:20 <tkahn6_> coming from imperative programming and then reading SICP it really changed the way I thought about programming. i think coming from imperative programming directly to haskell would be frustrating
02:58:32 <kmc> frequently that list will make a lot of fundamental errors, e.g. advocates of dynamic typing failing to understand what static types are for, or that it takes time to make use of them
02:58:35 <osaunders> But there are some more legimate criticisms. Like lack of libraries.
02:58:44 <kmc> yes, there are lots of legit criticisms of Haskell
02:58:50 <kmc> frankly every day I use Haskell, something about it pisses me off
02:58:55 <kmc> this is true of every language I've ever used
02:58:56 <Nibble> osaunders: no, there are a lot of libraries for everything.
02:59:03 <dobblego> same, but "not enough libraries" is rarely that reason
02:59:04 <Nibble> not as much as for C, for obvious reasons
02:59:06 <kmc> but you asked why people scoff, not why they gripe
02:59:21 <kmc> and to me "scoff" means dismissing the entire idea as worthless
02:59:31 <quicksilver> or eat enthusiastically and fast
02:59:37 <osaunders> Why do you think Haskellers choose Haskell. I know why I did but what about everyone else? It's not to make money is it?
02:59:38 * quicksilver scoffs a pile of sugarcoated lambdas.
02:59:53 <dobblego> "not enough libraries" is something that pisses me off when using Scala, Java or C#
03:00:03 * quicksilver was lured here by the fast cars and hollywood lifestyle.
03:00:09 <osaunders> kmc: Yeah, OK, I want to move on to why they gripe now, please.
03:00:15 <kmc> osaunders, it's fun, interesting, intellectually challenging (yes, this sometimes means "pointlesly hard")
03:00:18 <Nibble> osaunders: it helps you progrtam better
03:00:19 <tkahn6_> it's intellectually challenging and fun to use. going back to java makes me feel handicapped
03:00:20 <Nibble> program*
03:00:21 <kmc> (but also "hard because it makes you write correct code")
03:00:33 <osaunders> kmc: Hehe
03:00:34 <Nibble> short and concise code
03:00:38 <zachk2> i got lured in cause i wanted a real syntax, libraries, and a decent compiler, and I hate the bugginess of C 
03:00:41 <Nibble> something to show your friends
03:00:48 <osaunders> Nibble: A lot of the ibraries are experimental.
03:00:54 <Nibble> osaunders: sure they are
03:01:01 <Nibble> but that doesn't mean you can't use them
03:01:09 <kmc> osaunders, to me Haskell is a very well-balanced design with a lot of clever tradeoffs and compromises
03:01:38 <osaunders> OK.
03:01:50 <osaunders> Do you think Haskell will ever break out into maintream?
03:01:50 <kmc> expressiveness vs. readability, static typing vs. polymorphism, pure computation vs. actions and state
03:02:07 <dobblego> Haskell already is in the mainstream; just look at C#
03:02:16 <kmc> i know Haskell is usually seen as some kind of extremist no-compromise position
03:02:19 <h_noob> hmm... soeaking of frustration and haskell... how do I combine parsers for different types in one action: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28582 ?
03:02:45 <kmc> h_noob, where is your question in that code?
03:03:10 <h_noob> I got error when "x <- parseA <|> parseB" when parseA and parseB works on different types
03:03:23 <kmc> h_noob, yes, what would the type of x be?
03:03:28 <h_noob> in the link above it's parseMap function
03:03:32 <kmc> you have to put it into some type which holds both
03:03:33 <kmc> e.g.
03:03:45 <kmc> x <- (Left <$> parseA) <|> (Right <$> parseB)
03:03:55 <kmc> though instead of Either, you may want to define your own type
03:03:57 <h_noob> x is Val, data Val = A A | B B
03:04:05 <kmc> err that's one type then
03:04:07 <kmc> Val is the type
03:04:23 <h_noob> kmc yes
03:04:39 <kmc> v <- (Pike <$> parsePike) <|> (String <$> pStringLiteral)
03:04:46 <kmc> you have to wrap it into the Val type
03:04:58 <kmc> using Val's constructors
03:05:48 <kmc> osaunders, if "mainstream" means replacing Java as the language of choice for making armies of replaceable parts code boring business software, then no
03:06:06 <h_noob> kmc:  what is <$> ?
03:06:12 <kmc> (<$>) = fmap
03:06:18 <h_noob> Not in scope: `<$>'
03:06:26 <kmc> (Functor f) => (a -> b) -> (f a -> f b)
03:06:37 <kmc> for monads:
03:06:42 <h_noob> kmc: which module is it?
03:06:43 <kmc> f <$> x = do { y <- x; return (f y) }
03:06:49 <kmc> @hoogle (<$>)
03:06:49 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
03:07:03 <h_noob> wow, thanks a lot
03:07:06 <kmc> :) no prob
03:08:14 <kmc> osaunders, if mainstream means that lots of people have heard of it, then it's already mainstream
03:08:22 <osaunders> Are you sure about that?
03:08:27 <osaunders> A lot of people haven't heard of it.
03:08:31 <kmc> yes, because the word "lots" is vague
03:08:54 <kmc> and there are people using Haskell professionally, not a huge number, but enough to e.g. go to conferences and talk about it, and advertise for jobs on haskell-cafe@
03:08:54 <dobblego> most programmers in my city have heard of it
03:09:03 <kmc> (i can recall four job postings in the past few months)
03:09:27 <kmc> also worth noting that this is one of the biggest channels on freenode
03:09:32 <osaunders> Yeah.
03:09:56 <kmc> anyway i don't see the point of a popularity contest
03:10:16 <h_noob> erm... import Control.Applicative (<$>) do not work - how do I get only this functor (is it functor btw)?
03:10:22 <kmc> it's a function
03:10:24 <osaunders> You wouldn't like Haskell to be more popular?
03:10:27 <zachk2> an active and friendly community is always a nice addition to a language 
03:10:29 <kmc> import Control.Applicative ((<$>))
03:10:44 <kmc> h_noob, the name of an operator is written with parens when not used infix
03:10:55 <kmc> e.g. import Control.Applicative ((<$>), pure, empty)
03:11:03 <h_noob> kmc, thanks - I forgot about it
03:11:08 <kmc> osaunders, i care much more that Haskell be good than that it be popular
03:11:21 <kmc> and being popular can get in the way of being good
03:11:22 <osaunders> kmc: Do you work using Haskell?
03:11:29 <kmc> osaunders, yes
03:11:33 <osaunders> Paid?
03:11:48 <kmc> i am porting GHC to target Android
03:11:51 <osaunders> I mean yes/no. Not how much. :-)
03:12:05 <kmc> though most of the coding so far is not Haskell, but C / bash / make ;)
03:12:10 <kmc> paid, yes
03:12:22 <osaunders> Is that with a university?
03:12:24 <kmc> no
03:12:32 <kmc> i'm working for http://ipwnstudios.com
03:12:49 <ivanm> you too? :o
03:13:04 <ivanm> geez, just about every second person in here seems to be working for them...
03:13:05 <kmc> as are Cale, pastorn, blackh, and probably others here
03:13:15 <tkahn6_> woah that's cool kmc
03:13:18 <kmc> RyanT5000 is a co-founder
03:13:22 <tkahn6_> haskell on android would be awesome
03:13:36 <kmc> yes :)
03:13:39 <osaunders> Basically all the best programming in the world are working for this company.
03:13:42 <osaunders> *programmers
03:13:59 <uranther> games in haskell?
03:14:02 <kmc> yes
03:14:06 <kmc> an iPhone game in Haskell
03:14:08 <kmc> crazy, yes
03:14:10 <pastorn> uranther: yampa
03:14:13 <kmc> crazy awesome :)
03:14:15 <kmc> hi pastorn
03:14:23 <pastorn> kmc: you highlulzed me
03:14:28 <kmc> hehe
03:14:32 <kmc> ipwn represent
03:14:50 <tkahn6_> haha
03:15:01 <pastorn> kmc: we should change our nicks to [iPwn]$NICK
03:15:09 <kmc> haha
03:15:24 <MigoMipo> @src cycle
03:15:24 <lambdabot> cycle [] = undefined
03:15:24 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
03:15:51 * kmc thinks «cycle []» should be an unproductive ⊥ rather than an erroring ⊥
03:15:55 <tkahn6_> what's the biggest challenge in getting haskell to play with android?
03:16:14 <kmc> tkahn6_, depends what you consider challenging
03:16:26 <kmc> binding Haskell to the Java APIs may be a big pain
03:16:30 <handonson> isn't there a simple ghc option that shows the list of packages a haskell code depends on?
03:16:31 <kmc> i expect it to be pretty straightforward though
03:16:33 <quicksilver> kmc: unproductive = _|_ = undefined
03:16:49 <tkahn6_> oh wow
03:16:49 <kmc> quicksilver, denotationally, yes.  my nitpick is an operational one
03:16:52 <quicksilver> kmc: semantically those aren't supposed to be different.
03:16:54 <tkahn6_> that's pretty cool
03:16:58 <kmc> the game doesn't need much in that area
03:17:10 <quicksilver> I think the actual definitoin is error "cycle: empty list"
03:17:13 <tkahn6_> can haskell already compile to dalvik?
03:17:19 <kmc> no, we are compiling to native code
03:17:28 <tkahn6_> oh right
03:17:31 <kmc> ghc outputs c for gcc
03:17:31 <tkahn6_> that would be easier
03:17:37 <kmc> and faster
03:18:04 <uranther> kmc: how does programming games in haskell differ from game programming in general? you know, where the developers work 80hr weeks to meet deadlines made by the marketing team
03:18:33 <kmc> uranther, what makes you think the choice of programming language has much to do with that?
03:19:03 <uranther> kmc: I thought programming in haskell is less error-prone, faster, et
03:19:03 <uranther> c
03:19:05 <kmc> i expect some correlations between "willingness to use Haskell" and other aspects of corporate culture
03:19:19 <kmc> but there's so little data
03:19:24 <kmc> uranther, well, it can be
03:19:35 <dobblego> Being a good programmer is less error-prone, etc.  Haskell is accommodating to good programmers.
03:19:36 <kmc> but i don't think there are any success stories from gaming yet
03:19:37 <ivanm> kmc: is your expected correleation that we're more or less rebellious corporate-wise?
03:19:49 <ivanm> @remember dobblego Being a good programmer is less error-prone, etc.  Haskell is accommodating to good programmers.
03:19:50 <lambdabot> I will remember.
03:20:06 <kmc> Haskell certainly doesn't try to handicap good programmers
03:20:13 <kmc> which is more or less an explicit design goal of Java
03:20:18 <kmc> and i can understand why; it's not unreasonable
03:20:23 <kmc> just not what i want to do
03:20:44 <kmc> i'm still sticking to "writing correct programs is hard; Haskell makes writing incorrect programs hard too"
03:21:26 <tkahn6_> i'm still amazed that java doesn't have closures yet
03:22:20 <kmc> i think the innovation for that sort of language moved to C# a while ago
03:22:25 <dobblego> it makes perfect sense as the world's least productive programming language
03:22:33 <kmc> and to JVM-implemented languages other than Java
03:22:49 <kmc> it makes perfect sense if you think the lowest common denominator programmer can't understand first-class functions
03:22:51 <tkahn6_> do you guys play with clojure at all?
03:23:17 <tkahn6_> kmc: true. they do have anonymous classes though.
03:23:23 <kmc> right
03:23:38 <osaunders> I think Java is hard.
03:23:46 <osaunders> I some ways harder than Haskell.
03:23:48 <kmc> every language has a way to fake basic FP features, often a cumbersome "design pattern" you have to memorize and type out over and over
03:23:54 <tkahn6_> Java is hard because of all the design patterns
03:23:58 <mun> does anyone know how to type out logical symbols as unicode characters in xchat?
03:24:18 <kmc> mun, copy-paste?
03:24:25 <mun> kmc, from what?
03:24:29 <kmc> from a website
03:24:36 <kmc> e.g. http://en.wikipedia.org/wiki/Table_of_mathematical_symbols
03:25:07 <mun> kmc, right. is that how you got the bottom symbol?
03:25:19 <kmc> or you can use X's compose key feature
03:25:26 <kmc> i have a custom ~/.XCompose: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28583#a28583
03:25:41 <tkahn6_> oh nice
03:25:41 <dobblego> mun, CTRL-SHIFT-uUNICODEVALUE then enter
03:25:58 <kmc> there's also some gnome bullshit you need to do to make it respect that
03:26:09 <tkahn6_> how. that would be useful
03:26:11 <mun> kmc, right. do you use XCompose?
03:26:26 * geheimdienst is a big fan of the compose key. one of the few things in linux that are really easier than on the mac or in windows
03:26:30 <kmc> export GTK_IM_MODULE=xim
03:26:32 <kmc> in your x session
03:27:06 <tkahn6_> cool. will check this out
03:27:13 <mun> cool
03:29:01 <mun> kmc, so what is this <Multi_key> that triggers it?
03:30:04 <letsel> My two cents on differentiating between Haskell and other languages: It hurts more to learn Haskell, but it hurts less to think in it.
03:31:34 <geheimdienst> mun, i'm pretty sure it's another name for the compose key. i've got it mapped the context menu key (which is damn useless otherwise)
03:31:41 <dobblego> osaunders, Java is extremely hard; I've met few people who have even a reasonable understanding of it
03:31:42 <cizra> mun: xcompose?
03:31:49 <cizra> mun: oh, oops
03:32:07 <osaunders> letsel: I like that.
03:32:56 <cizra> kmc: How do I use this .XCompose? Restart X and hope it'll get loaded?
03:33:03 <osaunders> dobblego: There are good Java programmer.
03:33:05 <osaunders> *programmers
03:33:21 <ivanm> osaunders: yes, but they don't use Java :p
03:33:31 <geheimdienst> cizra, try this: setxkbmap -option compose:menu
03:33:36 <osaunders> They're better when the don't use Java.
03:33:39 <geheimdienst> then hit the menu key and o and /
03:33:47 <geheimdienst> you should get an ø
03:33:51 <cizra> geheimdienst: I have working compose. I use caps lock for that
03:33:59 <cizra> geheimdienst: The question is about .XCompose file.
03:34:14 <cizra> ☺
03:35:46 <tkahn6_> wooh got it
03:35:50 <tkahn6_> ø
03:35:52 <tkahn6_> :)
03:35:56 <dobblego> osaunders, good Java programmers don't use Java
03:35:58 <kmc> dobblego, what particularly makes Java difficult?
03:36:00 <mun> tkahn6_, did you need to restart to map the compose key?
03:36:05 <tkahn6_> nope
03:36:29 <geheimdienst> cizra, i googled a little and i guess it's a matter of creating the file and restarting x
03:36:29 <kmc> you don't need to restart to map Multi_key (just run xmodmap) but i think you need to restart to reload ~/.XCompose
03:36:37 <tkahn6_> saved http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28583#a28583 into ~/.XCompose
03:36:38 <kmc> if anyone finds a way to not restart i'd like to know :)
03:36:39 <cizra> okay
03:36:54 <tkahn6_> and then did  export GTK_IM_MODULE=xim
03:36:55 <dobblego> kmc, its restrictions, particularly imposed by the type system -- the amount of effort required to solve a problem is significantly disproportionate tothe size of the problem, such that eventually, you're only faffing about the language
03:37:10 <tkahn6_> and in ubuntu, I followed this guide:
03:37:18 <tkahn6_> https://help.ubuntu.com/community/ComposeKey
03:37:40 <tkahn6_> you need to set a Compose key (i set mine as 'menu')
03:37:52 <tkahn6_> and a Third level key (i set mine as Right Alt)
03:37:54 <kmc> also if anyone wants to beef up my file with better/more bindings i'd like to see it
03:38:01 <tkahn6_> k
03:38:19 <dobblego> kmc, Java has an enormous number of corner cases; the highest score I've ever seen by a Java programmer on a bunch of Java trivia questions, which I derived from years working on the implementation, is 4/10
03:38:25 <tkahn6_> i think those are all of the math symbols i've seen
03:38:28 <tkahn6_> lol
03:38:31 <kmc> heh dobblego
03:38:49 <mun> tkahn6_, are you on kde?
03:38:50 <tkahn6_> omg
03:38:54 <kmc> would you say it has more corner cases than C++?
03:38:54 <tkahn6_> nah Gnome
03:39:16 <dobblego> kmc, I've never really thought about it, but it's certainly a possibility
03:39:24 <tkahn6_> the AP Computer Science test is 70% "Do you know Java idiosyncrasies"
03:39:28 <kmc> :(
03:39:31 <tkahn6_> so frustrating
03:39:48 <kmc> yeah well AP is supposed to be equivalent to a typical college course
03:39:52 <kmc> so i guess they're doing their job
03:39:54 <kmc> ;P
03:39:56 <tkahn6_> haha
03:39:58 <dobblego> kmc, most Java programmers are using a subset of the language, making them even more unproductive (it is often as if this is actually the goal)
03:40:32 <kmc> dobblego, what are some common subsets?
03:40:37 <tkahn6_> You should check out google tech talks about java. the have this series where some guys come in and show a bunch of weird things about java
03:40:47 <tkahn6_> people vote on what they think the outcome is
03:40:50 <tkahn6_> and usually its insane
03:41:14 <dobblego> kmc, the most obvious is the introduction of "generics" in version 1.5 -- occasionally I meet someone who uses the language subset without this feature (because it's so hard! and it is)
03:41:30 <kmc> wow
03:41:44 <kmc> people actively avoid generics?
03:41:49 <dobblego> kmc, I was on the advisory for JSR-14 (the spec for generics) and I protested as loudly as I could because it was both complicated and useless 
03:41:58 <kmc> it doesn't seem useless to me
03:42:04 <kmc> though it's fairly complicated
03:42:05 <dobblego> yes, even people at my place of employment (where I am currently running a haskell course)
03:42:14 <dobblego> some of the complications render it useless
03:42:21 <dobblego> not in all cases
03:42:22 <kmc> ok
03:42:42 <kmc> i'm familiar at the basic level of List<Foo>
03:42:48 <kmc> and it seems clearly superior to runtime type casts
03:42:52 <dobblego> it gets quite complicated from there :)
03:42:54 <kmc> but i realize you can do a lot more with it
03:43:04 <dobblego> by complicated I mean unnecessarily complicated
03:43:41 <dolle> dobblego: Do you have a good example?
03:43:57 <kmc> is the basic problem here that subtyping and polymorphism fit poorly together?
03:44:08 <dobblego> dolle, I could whip one up using arrays, varargs and forall T. T
03:44:30 <kmc> i have a Haskell-centric worldview, in which subtyping is always trouble ;)
03:44:33 <dobblego> kmc, one big problem is the implications of type erasure on the JVM
03:45:03 <kmc> ah
03:45:12 * kmc knows little about operational details of JVM
03:45:19 <kmc> other than not supporting tail calls, grr
03:45:28 <dobblego> IBM JVM supports direct TCO :)
03:45:37 <dobblego> (I used to work on Java for IBM)
03:46:01 <kmc> cool
03:46:35 <dobblego> generics also implement a completely borked co/contra/variance
03:47:05 <kmc> do you know if Scala does it better?
03:47:08 <dobblego> to the extent of "not worth using"
03:47:11 <kmc> i know it has explicit co/contravariance annotations
03:47:14 <dobblego> yes it does it better; using variance annotations
03:47:32 <dobblego> though we (Scalaz project) have determined that to be "not worth using" as well
03:47:32 <kmc> how does Java do (or fail to do) it?
03:47:57 <Wooga> hello, i am trying to install hlint with cabal, but i am getting problems with haskell-src-exts: it requires happy >=1.17 and thinks that i don't have one, while actualy i have 1.18. here is log: http://paste2.org/p/939581 . what could i do ?
03:48:10 <quicksilver> kmc: I think it's only subtyping, polymorphism and mutation that conflict.
03:48:12 <dobblego> using the extends/super keywords e.g. interface Function<T, R> { <U super T, S extends R> S apply(U u); }
03:48:24 <quicksilver> kmc: without mutation you should be OK?
03:48:25 <tkahn6_> ahhh
03:48:36 <dobblego> Java also has an "existential quantifier" <?> which borks it
03:49:36 <cizra> kmc: I didn't get your .XCompose to work right. It just ignored it and loaded the defaults instead. There's nothing interesting in the log.
03:49:45 <kmc> cizra, you need a recentish X
03:50:01 <cizra> X.Org X Server 1.7.6
03:50:05 <kmc> "But I have a Ph.D. in Mathematics, and I'm sure a Circle is a kind of an Ellipse! Does this mean Marshall Cline is stupid? Or that C++ is stupid? Or that OO is stupid?"
03:51:43 <nooodl> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28586#a28586 i don't really get why this doesn't work
03:52:02 <kmc> nooodl, you didn't tell us why it doesn't work
03:52:05 <dobblego> nooodl, what do you mean by "doesn't work"?
03:52:17 <kmc> nooodl, you can't bind 'x' twice in the same pattern
03:52:23 <kmc> compress (x:y:xs) | (x == y) = ...
03:52:45 <kmc> patterns are structural only, whereas (==) is a computational idea implemented by an actual function
03:53:33 <kmc> (except for all the patterns that call functions behind the scenes... numeric patterns and n+k and view patterns, but hey, that would contradict my nice simple rule ;)
03:54:04 <nooodl> oh, (x:y:xs) | (x == y) looks just as nice
03:54:06 <nooodl> thanks :)
03:54:07 <Wooga> anyone?
03:54:11 <tolkad> Is it possible to specify package dependencies in a hasekll program?
03:54:16 <tolkad> haskell*
03:54:21 <kmc> tolkad, using cabal
03:55:14 <kmc> quicksilver, the issue with mutation is that (S <: T) implies neither (ref S <: ref T) nor (ref T <: ref S), right?  is that correct?
03:56:54 <osaunders> Wooga: It should be possible to use cabal install the specific version of happy you need.
03:57:12 <osaunders> Oh wait, it wants >=.
03:57:15 <tkahn6_> mun: working?
03:57:15 <osaunders> Hm.
03:57:24 <mun> tkahn6_, nope
03:57:30 <osaunders> Wooga: What's the error exactly?
03:57:33 <tkahn6_> rats
03:57:49 <Wooga> osaunders: i pasted it here: http://paste2.org/p/939581
03:57:50 <mun> tkahn6_, let me change the permissions
03:57:53 <quicksilver> kmc: yeah, you want it one way for reading and one way for writing, in a sense
03:58:12 <ivanm> anyone here using debian?
03:58:35 <kmc> yeah
03:59:04 <kmc> (ref S <: readref S), (ref S <: writeref S) with readref covariant and writeref contravariant but ref neither
03:59:07 <kmc> i guess something like that works
03:59:17 <osaunders> Wooga: ghc-pkg list | grep happy?
03:59:33 <kmc> ivanm, me
03:59:35 <Wooga> osaunders: none
03:59:53 <osaunders> So you don't have happy.
04:00:16 <ivanm> kmc: can you check for me what the leksah package on debian uses: wget or curl ?
04:00:39 <kmc> i have leksah installed from cabal i think
04:00:43 <kmc> yeah
04:00:59 <ivanm> well, doesn't apt tell you metadata or some such like that?
04:01:20 * ivanm is trying to write the ebuild for gentoo and isn't sure which option to use
04:01:25 <Wooga> osaunders: but i ran '$ cabal install happy' multiple times
04:01:49 <osaunders> Is it completing successfully. echo $? afterwards, it should be 0.
04:02:07 <osaunders> Also maybe try uninstall, clean, reinstall.
04:02:18 <kmc> ivanm, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28587#a28587
04:02:20 <osaunders> You might need to sudo as well.
04:02:47 <ivanm> kmc: ta
04:02:50 <ivanm> dammit, it doesn't say :s
04:03:59 <Wooga> osaunders: $? is zero; how do i uninstall with cabal?
04:04:16 <robryk> ivanm: portage uses wget by default
04:04:35 <ivanm> yeah, I know
04:04:35 <robryk> so if you don't want to try to be able to use both, it is more likely to be installed
04:04:35 <Wooga> osaunders: i can;t see anything like 'uninstall' or 'remove' in cabal --help
04:04:49 <ivanm> robryk: but I'm wondering if we should make it use libcurl instead
04:04:59 <robryk> ah, i see
04:07:05 <osaunders> Yes, you're right.
04:09:19 <osaunders> I don't know any more.
04:14:55 <osaunders> @src ($)
04:14:55 <lambdabot> f $ x = f x
04:15:22 <osaunders> @src id
04:15:22 <lambdabot> id x = x
04:17:16 <osaunders> Wooga: Try cabal update and then cabal install hlint
04:17:46 <Wooga> osaunders: i tried, it even suggests to update cabal-install, but even after such update nothing changes
04:18:02 <Wooga> including message suggesting to update cabal-install
04:18:03 <osaunders> What do you get for: ghc-pkg list | grep haskell-src-exts ?
04:18:18 <Wooga> nothing
04:18:27 <osaunders> Try cabal install haskell-src-exts
04:18:52 <Wooga> osaunders: http://paste2.org/p/939601
04:19:01 <ivanm> Wooga: is happy in your path?
04:19:31 <Wooga> ivanm: how do i check/set path to it?
04:19:39 <ivanm> which OS?
04:19:46 <Wooga> linux, gentoo
04:19:55 <ivanm> why not use the hlint ebuild then?
04:20:09 <Wooga> there is no such ebuild in portage tree
04:20:13 <osaunders> Yeah, try: which happy
04:20:16 <ivanm> there is in the overlay
04:20:26 <Wooga> ivanm: which one?
04:20:30 <ivanm> the haskell one
04:20:33 <Wooga> thanks
04:20:35 <ivanm> it's in layman
04:20:58 <ivanm> anyway, happy is in the tree
04:23:19 <ivanm> preflex: seen edwardk
04:24:08 <osaunders> Why is flip flip :: (a -> b -> c) -> b -> a -> c and not flip :: (a -> b -> c) -> (b -> a -> c)
04:24:20 <copumpkin> osaunders: those two are equivalent
04:24:33 <osaunders> Why?
04:24:45 <copumpkin> a -> b -> c === a -> (b -> c)
04:24:53 <copumpkin> -> is right-associative
04:25:09 <copumpkin> (that's how partial application works)
04:25:21 <osaunders> OK.
04:25:28 <pastorn> osaunders: the only difference is if you have something like map :: (a -> b) -> [a] -> [b], which is different from map :: a -> b -> [a] -> [b]
04:26:01 <pastorn> but if it's at "the end" of the type signature, you can just put () around it
04:27:00 <ivanm> though hlint doesn't like it when you do something like: (a -> b) -> (a -> b)
04:27:14 <ivanm> even though I want to emphasise that it just transforms the provided function
04:27:14 <kmc> (->) is right-associative
04:27:18 <ivanm> silly hlint!
04:27:26 <kmc> hlint complains about that? lame
04:27:42 <pastorn> ivanm: maybe it ignores it if you rename it to _f
04:27:44 <ivanm> it also complains about doing: func f = \ a -> ...
04:28:19 * ivanm guesses haddock also mangles the order
04:28:20 <kmc> osaunders, do you understand why Haskell defines «a -> b -> c» to be «a -> (b -> c)» and not «(a -> b) -> c» ?
04:28:29 <ivanm> I'd check, but I can't remember where I've done that...
04:28:37 <kmc> you could make either choice in the language design, but this is the more convenient one
04:28:41 <pastorn> kmc: stop it with the weird c:s
04:28:46 <ivanm> hooray for currying!
04:28:53 <ivanm> pastorn: what werid c ?
04:28:56 <kmc> pastorn, ?
04:29:05 <ivanm> you mean the << ... >> ?
04:29:28 <dark> kmc, hmm, why?
04:29:32 <osaunders> kmc: Not really.
04:29:39 <ivanm> more formally known as guillemets
04:29:51 <pastorn> http://mkeyd.net/~alexander/kmcs_cs.png
04:29:56 <kmc> because we want to think of «a -> b -> c» informally as a two-argument function
04:30:00 <kmc> takes a and b, return c
04:30:00 <Zao> »quoting like this is awesome«
04:30:01 <dark> i understand that a -> b -> c must be a function that receives a and returns b -> c
04:30:02 <pastorn> and i'm runnig UTF and everything
04:30:18 <kmc> but we only have one-argument functions, so we encode them like dark said
04:30:25 <kmc> take one arg, return a function which takes the remaining args
04:30:27 <ivanm> pastorn: it's meant to be these: http://en.wikipedia.org/wiki/Guillemets
04:30:35 <kmc> therefore, it is convenient if «a -> b -> c» means «a -> (b -> c)»
04:30:47 <ivanm> I'm guessing your IRC client doesn't do UTF-8 prperly
04:30:49 <ivanm> *properly
04:30:52 <Zao> pastorn: What about mine?
04:31:13 <osaunders> OK, I'm going to have a shower now.
04:31:13 <Zao> (also, what font is that)
04:31:13 <dark> pastorn, freenode is an utf-8 irc network
04:31:18 <Zao> dark: Says?
04:31:22 <pastorn> » == >>, « == ,+C
04:31:24 <kmc> you can encode multi-arg functions this way in any reasonable language, but Haskell's syntax and libs are set up to encourage it
04:31:44 <pastorn> maybe it's my font...
04:31:57 <ivanm> could be
04:32:12 <Zao> dark: I find no such policy document on freenode.net
04:32:17 <kmc> do these look the same pastorn? Ç«
04:32:46 <dark> Zao, hmm, i know of no channel with another encoding
04:32:46 <pastorn> kmc: yes, and it was my font
04:32:50 <pastorn> (monofur)
04:32:50 <kmc> oh
04:33:00 <kmc> weird that it would do one of the two correctly
04:33:10 <Zao> dark: Still, that's mutual luser agreement or ignorance, not network policy.
04:33:41 <kmc> Γ ⊢ (σ₁ → τ₁) ≤ (σ₂ → τ₂)
04:33:50 <dark> Zao, one could say that sentence actually means the current best practice
04:35:18 <dark> or hmm
04:35:18 <dark> what most clients are configured to
04:37:05 <copumpkin> http://snapplr.com/fpbv
04:38:18 <kmc> supercompiler?
04:38:22 <kmc> i hardly know her!
04:38:26 <copumpkin> :P
04:38:29 * kmc hangs head in shame
04:39:01 <Ke> so will this supercompiler thing be ever available to us
04:39:29 <copumpkin> yeah, but it isn';t magic
04:39:50 <copumpkin> takes forever on some programs appartently and makes others way slower
04:41:11 <kmc> copumpkin, i was promised a free lunch
04:41:31 <copumpkin> I'll get you one
04:41:32 <Ke> yes, we want our money back now
04:44:31 <mun> kmc, Hi again. In your .XCompose, is your first line cinlude "%L"?
04:44:37 <mun> kmc, sorry, include "%L"
04:44:48 <kmc> yes
04:44:53 <kmc> that's supposed to include the system file
04:45:10 <mun> kmc, what permissions did you give?
04:45:35 <mun> strangely, mine doesn't import the .XCompose in my home dir.
04:45:50 <kmc> nothing special, 644
04:46:16 <mun> I see.
04:46:48 <steshaw> curious why the following works:
04:46:58 <steshaw> > return 1 ++ [2..4]
04:46:59 <lambdabot>   [1,2,3,4]
04:47:11 <kmc> return :: a -> [a]; return x = [x]
04:47:22 <steshaw> @type return 1
04:47:22 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
04:47:28 <kmc> in the particular instance (Monad [a])
04:47:31 <steshaw> @type (++)
04:47:32 <lambdabot> forall m. (Monoid m) => m -> m -> m
04:47:36 <steshaw> oh
04:47:56 <kmc> @src [] return
04:47:56 <lambdabot> return x    = [x]
04:47:59 <steshaw> I thought ++ was just for lists
04:48:00 <kmc> @src [] (>>=)
04:48:00 <lambdabot> xs >>= f     = concatMap f xs
04:48:12 <kmc> steshaw, it is in standard Haskell.  lambdabot has other definitions loaded
04:48:20 <kmc> but «return 1 ++ [2..4]» will work in standard haskell too
04:48:25 <kmc> because they are lists
04:48:29 <steshaw> it works in ghci
04:49:33 <steshaw> the type of (++) is "(++) :: [a] -> [a] -> [a]" in ghci
04:50:58 <steshaw> is "return 1" a list?
04:51:01 <steshaw> @type return 1
04:51:02 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
04:51:08 <copumpkin> steshaw: it can be
04:51:21 <tkahn6_> list is a monad
04:51:29 <tkahn6_> return lifts its argument into the monad
04:51:33 <tkahn6_> (right?)
04:51:39 <steshaw> but is a monad a list?
04:51:43 <kmc> no
04:51:46 <tkahn6_> no list is a monad
04:51:46 <kmc> that is a category error
04:51:50 <tkahn6_> lol
04:51:52 <kmc> monads are types
04:51:54 <kmc> lists are values
04:51:59 <kmc> [] is the name of a particular type
04:52:00 <kmc> it is a monad
04:52:04 <kmc> "the type of lists"
04:52:10 <pkrumins> type of lists!
04:52:14 <kmc> (type constructor, if you want to be specific)
04:52:33 <kmc> «return 1» can specialize to many types, including [Double], IO Int, Maybe Integer
04:52:40 <kmc> > return 1:: Maybe Integer
04:52:41 <lambdabot>   Just 1
04:52:46 <kmc> > return 1 :: [Double]
04:52:47 <lambdabot>   [1.0]
04:52:56 <kmc> in this case it knows from your use of (++) that you want a list
04:53:12 <tkahn6_> how does haskell know what you intend to do with return?
04:53:19 <tkahn6_> what does the statment
04:53:22 <tkahn6_> return 1
04:53:34 <tkahn6_> mean in free context? (does it mean anything at all?)
04:53:37 <pkrumins> i haven't yet understood the type ((->) e)
04:53:51 <kmc> tkahn6_, return is not a statement
04:53:54 <kmc> it's an ordinary function
04:53:56 <pkrumins> since it's also a monad
04:53:58 <tkahn6_> right
04:53:58 <steshaw> seems the same way that "1" can be an Int, Integer or Double
04:54:07 <kmc> «return 1» is an expression
04:54:08 <quicksilver> tkahn6_: it's a polymorphic value.
04:54:14 <kmc> its type is «(Monad m, Num a) => (m a)»
04:54:22 <kmc> any numeric type, wrapped into any monad
04:54:25 <tkahn6_> right, how does it know m?
04:54:25 <quicksilver> tkahn6_: return 1, alone, is polymorphic and can take on various concrete values.
04:54:31 <quicksilver> it doesn't. It's polymorphic.
04:54:44 <kmc> but if you use it in a more specific way, it will unify that type with however you use it
04:54:47 <kmc> like when you pass it to (++)
04:54:58 <kmc> it unifies (m a) with [a], and concludes m = []
04:54:59 <tkahn6_> ok
04:55:02 <steshaw> That's great thanks
04:55:06 <kmc> ([] a) being another way to write [a]
04:55:07 <tkahn6_> gotcha that's what i was wondering
04:55:25 <quicksilver> > let x = return 1 in (x,x) :: (Maybe Int, [Double])
04:55:26 <lambdabot>   (Just 1,[1.0])
04:55:29 <kmc> and ((->) a b) is another way to write (a -> b)
04:55:41 <quicksilver> tkahn6_: ^^ here I use the polymorphic value twice in two contexts and get two quite different values out.
04:55:41 <hpc> @src ((->) e) return
04:55:42 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
04:55:46 <kmc> which means ((->) a) is the type constructor of "functions from a"
04:55:47 <tkahn6_> arrow is a monad?
04:55:52 <kmc> arrow?
04:55:56 <tkahn6_> oh type constructor
04:56:00 <tkahn6_> nvm
04:56:00 <hpc> monads are arrows
04:56:09 <kmc> ((->) a) is a type constructor and a monad
04:56:18 <kmc> every monad is a type constructor of exactly one argument, itself a type
04:56:42 <kmc> for example Maybe
04:56:54 <pkrumins> oh i see!
04:58:00 <hpc> does lambdabot have the monad instance for functions in @src?
04:58:24 <dolio> @src (->) return
04:58:24 <lambdabot> return = const
04:58:30 <hpc> ah
04:58:37 <hpc> @src (->) (>>=)
04:58:37 <lambdabot> f >>= k = \ r -> k (f r) r
04:58:44 <kmc> it's really ((->) a), but @src is not terribly consistent with real source
04:58:47 <kmc> it's just a plain text file
04:59:07 <hpc> ah, i see
04:59:41 <dolio> If you made it match, I imagine you'd have to type some specific letter, like ((->) r).
05:00:20 <kmc> yeah
05:00:27 <dolio> Unless I'm underestimating the level of effort put into it.
05:02:53 <Hunsville> i've question, not specific to haskell but related. If I want to translate a function like f = \x. IF x = 0 THEN \y. y + x ELSE \y. y - x to machine-code. How do I represent the result? Reserving memory and wirting the function into it and then returning the pointer on that piece of memory?
05:03:46 <hpc> i would do it with a function pointer
05:03:49 <Botje> you'd lift the functions to top level and return function pointers
05:04:06 <Botje> possibly closures (function pointers with associated free variables)
05:04:26 <hpc> how would you do a closure in machine language?
05:04:48 <dolio> With a lot of effort.
05:04:51 <exDM69> function pointer + captured variables + garbage collection
05:04:53 <tkahn6_> lol
05:05:24 <hape01> are generators more tight to machine-language?
05:05:51 <kmc> ?
05:05:58 <Hunsville> okay, so i have to do lambda-lifting first?
05:06:18 <Hunsville> g = \x. \y. y + x 
05:06:26 <Hunsville> h = \x. \y. y - x
05:06:31 <Hunsville> and rewrite f to
05:06:46 <Hunsville> f = \x. IF x = 0 THEN g x ELSE h x
05:06:52 * h_noob found Text.Show.Pretty - exactly is the thing I was asking for in here a while ago
05:07:04 <kmc> Hunsville, yes
05:07:18 <kmc> where the code "g x" means "build a closure which points to g and stores the free variable x"
05:07:25 <kmc> said free variable is now an arg to the lambda-lifted function
05:07:54 <kmc> but you do need to build closures in memory, at least some times, because you have to be able to store functions as values
05:08:27 <hape01> are generators more tight to machine-language? ( i read, e.g. python does closure-like as python - generators )
05:08:27 <Hunsville> kmc: how is this represented in machine language? Allocate new memory and write function to memory?
05:09:01 <kmc> well, you've already compiled the code into the static code segment of your program
05:09:49 <kmc> you allocate memory for the closure
05:10:03 <kmc> with a pointer to the code you already generated at compile time
05:10:07 <kmc> and store the free variables too
05:10:31 <kmc> hape01, generators and closures are not very comparable as features
05:10:41 <kmc> python has closures
05:10:55 <kmc> and really "closure" refers to an implementation technique, and we should just say "python has first-class functions"
05:11:05 <exDM69> Hunsville: you should have your runtime system + garbage collector first. creating the closures is just a matter of bundling the captured free variables with the function pointer in an object
05:11:09 <kmc> or even "python has functions" as opposed to Java which has only crippled functions
05:12:05 <hape01> kmc: I try to understand ;-)
05:12:30 <theorbtwo> Closure refers to how lexical variables interact with functions.  First-class functions means that the syntax for calling a reference to a function is the same as calling a function.  What you really mean is that it has function-valued variables.
05:12:50 <theorbtwo> (Like C, and unlike Java.)
05:13:37 <kmc> i thought first-class was not about syntax but about functions being values
05:13:57 <dolio> Yes.
05:13:58 <kmc> i think most agree that LISP has first-class functions even though the syntax for calling a function-value is awkward
05:14:01 <Hunsville> okay, so i have a bundle like : (5, pointer to g) for f 5?
05:14:06 <Hunsville> sorry mean g 5
05:14:30 <kmc> C's function valued variables don't count imo, because there's no way to construct new functions on the fly
05:14:38 <kmc> i.e. no closure
05:14:49 <kmc> all you can do is select from a predefined small set of functions
05:15:03 <hpc> Hunsville: i would probably also index the arguments in some way, to account for sections
05:15:22 <Hunsville> okay, and this bundle lays on for example the stack?
05:15:30 <Botje> no, on the heap
05:15:36 <Botje> because you're not sure when/if it might be used
05:16:08 <Botje> Hunsville: the book "compiling with continuations " by andrew appel has a very good section on closures
05:16:24 <osaunders> Is there a word for where an operator take different types of parameters?
05:16:32 <quicksilver> overloaded?
05:16:33 <kmc> if you knew it could live on the stack (i.e, you know you pass it down to a function and that function won't squirrel it away somewhere) then you could avoid building a closure entirely
05:17:07 <osaunders> quicksilver: Really?
05:17:20 <osaunders> Is (:) overloaded?
05:17:22 <quicksilver> maybe. you didn't give enough context.
05:17:29 <quicksilver> no, it's polymorphic.
05:17:33 <quicksilver> (which is a more general term)
05:17:34 <Hunsville> okay, thanks to all this help!!! :-)
05:17:37 <Hunsville> bye
05:17:54 <quicksilver> overloading = adhoc polymorphism; (:) is parametric polymorphism.
05:18:01 <quicksilver> they're both polymorphism.
05:18:03 <osaunders> Isn't it polymorphic because it's a -> [a] -> [a] rather than Int -> [Int] -> [Int]?
05:18:08 <hpc> osaunders: polymorphic means it can take arguments of different types; overloaded means it does different things to things of different types
05:18:09 <kmc> osaunders, typically "overloading" refers to an ad-hoc scheme where you define a function a few different times for different types
05:18:19 <kmc> parametric polymorphism means you define it *once* in a uniform way that works on many types
05:18:29 <quicksilver> osaunders: oh, you simply meant the left argument is a different type from the right?
05:18:34 <osaunders> quicksilver: Yes.
05:18:37 <copumpkin> omnom
05:18:38 <quicksilver> there's no word for that as far as I know
05:18:42 <kmc> that's nothing special
05:19:16 <osaunders> So there's no word for it.
05:19:19 <osaunders> :(
05:19:25 <hpc> transformation, maybe, unless i am being horribly wrong
05:19:41 <hpc> wait, no, nvm
05:19:41 * hackagebot HaTeX 2.1.0 - Library for write LaTeX code.  http://hackage.haskell.org/package/HaTeX-2.1.0 (DanielDiaz)
05:19:49 <osaunders> Asymetrically-typed?
05:19:55 <ivanm> hmmm, HaTeX sounds interesting...
05:20:01 <copumpkin> so much hate
05:20:10 <osaunders> lol
05:22:57 <ivanm> hey copumpkin 
05:23:00 <copumpkin> hey hey
05:23:07 <ivanm> I heard you were offering free lunches...
05:23:08 <ivanm> ;-)
05:23:20 <copumpkin> yep
05:23:22 <copumpkin> want one?
05:23:33 <ivanm> sure
05:23:43 <copumpkin> okay, will get you one later
05:23:50 <ivanm> ta
05:28:02 <burp> hm, is there anything like System.IO for bytestrings?
05:28:59 <copumpkin> in the bytestring package
05:29:49 <burp> oh yes :>
05:29:50 <ivanm> wow, what a strange location to have it in...
05:29:51 <ivanm> ;-)
05:30:28 <burp> who can know that it's all put into one clump :p
05:34:19 <Kaidelong> do I go for HOpenGL or OGL?
05:35:22 * Kaidelong wants to try writing stuff for data visualization in many dimensions, wondering where to start
05:35:53 <hpc> hopengl
05:36:00 <kmc> it's just called "OpenGL" now
05:36:13 <hpc> or for your purposes, probably gpipe
05:36:31 <hpc> which is a more functional interface
05:37:13 <Kaidelong> hmm honestly, I probably should be working with a library for images or SVG, rather than doing stuff with openGL
05:37:36 <byorgey> Heffalump: pong?
05:45:02 <osaunders> Properties of binary functions: associativity, commutativity, ... any more?
05:45:36 <Kaidelong> transitivity
05:45:44 <quicksilver> that's relations only
05:45:52 <quicksilver> (functions -> Bool, if you like to see it that way)
05:46:23 <Kaidelong> are all functions closed on a group also relations?
05:46:39 <quicksilver> no, you have a type error ;)
05:46:45 <quicksilver> associative implies you are A -> A -> A
05:46:50 <osaunders> Whats transitivity?
05:46:54 <quicksilver> transitive implies you are A -> A -> Bool
05:47:02 <quicksilver> you can't be both of those unless A = Bool ;)
05:47:03 <osaunders> Oh, a predicate.
05:47:13 <fasta> osaunders, aRb, bRc => aRc
05:47:18 <Kaidelong> quicksilver: but if you are closed on a set of values for which equality is defined
05:47:44 <osaunders> fasta: I don't understand that notation.
05:47:46 <Kaidelong> oh wait
05:47:54 <Kaidelong> sorry, it's morning
05:47:58 <fasta> osaunders, read the , as "and"
05:48:14 <Kaidelong> yes, transitivity doesn't make sense for functions, excuse me
05:48:16 <fasta> osaunders, aRb = R(a,b)
05:48:26 <fasta> osaunders, that is fairly standard notation. 
05:48:29 <osaunders> What should I read the Rb as?
05:48:42 <Kaidelong> a `relation` b
05:48:45 <fasta> osaunders, the relation under consideration. 
05:49:07 <osaunders> What area of mathematics is this?
05:49:10 <fasta> osaunders, for example (==) is transitive. 
05:49:52 <fasta> osaunders, I think set theory has these concepts also.
05:50:00 <Kaidelong> (a == b), (b == c) :- (a == c)
05:50:08 <Kaidelong> something like that
05:50:14 <quicksilver> in fact, in set theory, relations precede functions.
05:50:16 <osaunders> Oh.
05:50:31 <fasta> osaunders, I have an introduction to set-theory which contains it. 
05:50:37 <nominolo> @check a < b && b < c ==> a < c
05:50:38 <lambdabot>   No instance for (Test.QuickCheck.Testable
05:50:38 <quicksilver> an (n-ary) function is an (n+1-ary) relation satisfying some well-definedness conditions.
05:50:38 <lambdabot>                     Test.QuickChe...
05:50:49 <nominolo> @check a < b && b < c ==> a < (c :: Int)
05:50:49 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:51:06 <quicksilver> nominolo: \a b c -> 
05:51:22 <nominolo> @check \a b c -> a <= b && b <= c ==> a <= (c :: Int)
05:51:23 <lambdabot>   No instance for (Test.QuickCheck.Testable
05:51:23 <lambdabot>                     (Test.QuickCh...
05:51:30 <nominolo> :t (==>)
05:51:31 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
05:51:48 <nominolo> whatever
05:51:52 <dolio> I don't think (==>) works right in lambdabot for some reason.
05:52:12 <nominolo> @check \a b c -> if a <= b && b <= c then a <= (c :: Int) else True
05:52:12 <lambdabot>   "OK, passed 500 tests."
05:53:21 <nominolo> @check \a b c -> if a <= b && b <= c then a <= (c :: Double) else True
05:53:22 <lambdabot>   "OK, passed 500 tests."
05:53:57 <nominolo> actually, it's not true for Int
05:54:05 <osaunders> Properties of binary functions: associativity, commutativity, transitivity, ... any more?
05:54:21 <nominolo> ah, no it is
05:54:40 <quicksilver> osaunders: not transitivity, really
05:54:51 <quicksilver> as I was saying that only applies to relations which are (in this sense) a special case.
05:55:01 <osaunders> Yeah.
05:55:18 <quicksilver> existence of left and right inverses?
05:55:30 <quicksilver> existence of left + right identity
05:55:37 <osaunders> What are they?
05:55:55 <quicksilver> an identity is "e" such that f(a,e) = a for all a
05:56:16 <quicksilver> or, a ~ e = a if you prefer an operator style notation
05:56:33 <quicksilver> if you have an identity then you can talk about inverses
05:56:42 <quicksilver> b is an inverse of a if f(a,b) = e
05:57:24 <osaunders> OK, I think I'm going to stop there for a while. :-)
06:01:59 <copumpkin> anyone know what silkapp.com is?
06:02:05 <copumpkin> it's in haskell supposedly
06:03:10 <nlogax> probably a lot of javascript too (i've been following their blog)
06:03:25 <copumpkin> yeah, I mean the server side
06:03:43 <bobzhangatthu> has anyone met such error "Error: BadGC (invalid GC parameter)
06:03:44 <bobzhangatthu> Error: BadDrawable (invalid Pixmap or Window parameter)"? thanks
06:03:54 <copumpkin> preflex: seen sfvisser
06:03:55 <preflex>  sfvisser was last seen on #haskell 2 days, 23 hours, 15 minutes and 28 seconds ago, saying: EvanR-work: harmful but useful
06:04:04 <copumpkin> oh he's here
06:06:04 <quicksilver> bobzhangatthu: I think you probably want #xmonad
06:08:35 <bobzhangatthu> quicksilver: Ye, I see, I met such error when I was playing frp
06:11:32 <bobzhangatthu> quicksilver: It works in ghc , but not in ghci when I create a large amount of graphics. Did anyone know why?
06:12:48 <quicksilver> bobzhangatthu: such things are common because of the way ghci handles threads
06:12:53 <Zao> bobzhangatthu: ghc probably optimizes sufficiently and doesn't keep top-level bindings around longer than needed.
06:53:43 <Jonno_FTW> @src div
06:53:43 <lambdabot> Source not found. Maybe you made a typo?
06:53:45 <mrdk> Is there a vim plugin which replaces haskell characters like \ with λ, or <- with ←?
06:53:47 <mooglenorph> Hi. I'm just starting to learn haskell. I'm on chapter 7 of real world haskell, and I'd like to try some kind of small project soon.
06:53:51 <Jonno_FTW> @src quot
06:53:51 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
06:54:04 <BrianHV> mrdk: you can use abbr for that
06:54:56 <BrianHV> mrdk: I assumed you meant when you're typing.  otherwise, it's a :%s//g to replace everything
06:55:20 <mooglenorph> I think I want to write a metadata client for oai-pmh repositories. Can someone recommend an easy-to-use xml parser library, and HTTP request library?
06:55:20 <mrdk> BrianHV: exactly, only when I'm typing, don't want to actually replace it of course
06:55:28 <Kaidelong> mooglenorph: You have a spreadsheet full of data with some empty cells. You can only remove rows or columns. ...
06:55:30 <Kaidelong> ok
06:55:38 <Jonno_FTW> what's the difference between `div` and `quot`?
06:55:38 <Kaidelong> well if you have already figured out something, nm
06:55:40 <BrianHV> does the lambda character actually work?  I tried it and I got an error, even with the unicode operators flag on...
06:56:43 <zygoloid> > (λx -> x + 1) 41
06:56:44 <lambdabot>   Pattern syntax in expression context: λx -> x + 1
06:56:48 <byorgey> I don't think the unicode operator extension includes lambda.
06:57:04 <byorgey> BrianHV: unfortunately lambda is a letter, so it is an identifier
06:57:24 <mrdk> BrianHV: I stumbled upon http://wordaligned.org/articles/from-hash-key-to-haskell, bottom of the page. Would be nice if we had something similar for vim
06:57:26 <Silvah> @src Int div
06:57:27 <lambdabot> Source not found. That's something I cannot allow to happen.
06:57:33 <BrianHV> byorgey: that's what I thought... mrdk made me think I was missing something for a sec :)
06:58:37 <BrianHV> mrdk: oh, I think I see what you're getting at
06:59:23 <BrianHV> mrdk: and I don't have an answer for you
06:59:34 <mrdk> BrianHV: too bad :/ 
06:59:41 <byorgey> I think the point is that the editor just displays it like that, but it's still \ or -> or whatever in the actual file, right?
06:59:57 <BrianHV> that's what it looks like to me
07:00:12 <byorgey> Jonno_FTW: the difference has to do with negative numbers, I forget the exact details
07:00:22 <byorgey> try some examples and you'll probably figure it out
07:00:31 <byorgey> but I'm pretty sure for all positive arguments they are identical
07:00:57 <mrdk> BrianHV: http://www.vim.org/scripts/script.php?script_id=2603
07:02:09 <Jonno_FTW> they both seem the same no matter where negative numbers are
07:02:28 <BrianHV> mrdk: interesting.  looks like it converts the digraphs on load and save, and also adds the abbreviations
07:02:31 <Jonno_FTW> which one should I use?
07:03:22 <Silvah> > 3 `div` (-2)
07:03:23 <lambdabot>   -2
07:03:27 <Silvah> > 3 `quot` (-2)
07:03:28 <lambdabot>   -1
07:03:32 <BrianHV> mrdk: and if I'm not mistaken, it does that without regards to whether the character is quoted.  that means it'll do the wrong thing if you have a string with a fancy char in it.
07:04:15 <Jonno_FTW> According to the docs: quot: integer division truncated toward zero -- div: integer division truncated toward negative infinity 
07:04:46 <Jonno_FTW> I will only be using positive numbers. Which one should I use?
07:04:55 <mrdk> BrianHV: true on that, that ain't that nice
07:05:04 <mrdk> BrianHV: but first I will have to try it ;)
07:06:20 <EvanR-work> "for some integer a and b > 0, there exists q and r such that a = bq + r where 0 <= r < b
07:06:23 <EvanR-work> "
07:06:38 <quicksilver> Jonno_FTW: quotRem is faster on x86 at least, because it maps directly to an assembly language instruction.
07:06:52 <quicksilver> Jonno_FTW: however, most people seem to use divMod because they're more familiar sounding ;)
07:06:53 <EvanR-work> "exercise to the reader: extend this so that b can be negative" :)
07:08:37 <Kaidelong> how does disjunction work with middles?
07:09:08 <Kaidelong> IE for p v q
07:09:15 <Kaidelong> you don't know q
07:09:22 <Kaidelong> but you know that p is neither true nor false
07:09:39 <Kaidelong> how does the answer relate to q?
07:09:51 <Kaidelong> or can you not talk about disjunction without excluding the middle?
07:10:56 <Jonno_FTW> thanks quicksilver 
07:11:02 <fasta> Kaidelong, wrong channel. 
07:11:55 <Kaidelong> fasta: I figured it out anyway, nm
07:11:55 <copumpkin> it's definitely not historically off-topic
07:12:08 <Kaidelong> copumpkin: it was haskell that bought this on, yes
07:12:12 <fasta> Kaidelong, excluded middle is simply stating that a \/ -a is provable. 
07:12:26 <Kaidelong> fasta: yep
07:12:33 <copumpkin> @djinn Not (Not (Either a (Not a)))
07:12:34 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
07:12:40 <copumpkin> omg :P
07:13:42 <Kaidelong> so there is a type in haskell that is not not both a type a and a type a at the same time
07:13:45 <Kaidelong> ?
07:13:57 <Kaidelong> and djinn found something that would yield it
07:14:03 <copumpkin> @djinn Either a (Not a) -> Not (Not a) -> a
07:14:04 <lambdabot> f a b =
07:14:04 <lambdabot>     case a of
07:14:04 <lambdabot>     Left c -> c
07:14:04 <lambdabot>     Right d -> void (b d)
07:14:20 <copumpkin> @djinn (Not (Not a) -> a) -> Either a (Not a)
07:14:20 <lambdabot> -- f cannot be realized.
07:14:41 <copumpkin> @djinn (Not (Not b) -> b) -> Either a (Not a)
07:14:41 <lambdabot> -- f cannot be realized.
07:14:57 <copumpkin> @djinn (forall a. Not (Not a) -> a) -> Either a (Not a)
07:14:58 <lambdabot> -- f cannot be realized.
07:15:01 <copumpkin> boo
07:15:13 <copumpkin> Kaidelong: how do you mean?
07:15:38 <Kaidelong> copumpkin: I don't know, I haven't learned much at the type level yet, still working mostly on a function level
07:15:49 <copumpkin> Kaidelong: you mean something like Either a (Not a) ?
07:15:59 <Kaidelong> that's what you wrote right?
07:16:00 <copumpkin> it's definitely a type (a logical statement)
07:16:08 <copumpkin> we just can't write a value of that type
07:16:12 <Kaidelong> Not Not (Either a or Not a)
07:16:18 <copumpkin> meaning it can't be proved in our logic
07:16:21 <copumpkin> well, in haskell you can
07:16:24 <copumpkin> but we pretend you can't
07:16:40 <copumpkin> Kaidelong: oh, double negating a classical statement is provable in constructive logic
07:17:02 <dolio> Propositional.
07:17:54 <Kaidelong> anyway the idea I came up with is that a distinction between two middles is another middle, between a middle and a false is a middle, and between a middle and a true is a true?
07:18:26 <dolio> What is a middle?
07:18:36 <Kaidelong> something that'd neither true nor false
07:18:40 <Kaidelong> that's*
07:19:07 <quicksilver> intuitionistic logic is not three-valued.
07:19:18 <quicksilver> the "excluded middle" isn't a real thing called a middle.
07:19:25 <Kaidelong> well
07:19:30 <Kaidelong> it says you can't prove it, right?
07:19:33 <dolio> "Excluded middle" is saying there are no middles.
07:19:40 <Kaidelong> which is different from having proven it true or false
07:19:45 <Kaidelong> so it's a different outcome
07:19:54 <dolio> Intuitionistic logic still doesn't have middles, though.
07:20:30 <Kaidelong> "can't be proven" then
07:20:38 <Kaidelong> or
07:20:41 <Kaidelong> "indeterminate"
07:20:43 <Kaidelong> or something
07:21:19 <quicksilver> provability is proof-theoretic concept; truth and falsity are semantic (model-theoretic) notions.
07:21:29 <quicksilver> I think you might be mixing the levels somewhat.
07:22:34 <copumpkin> Kaidelong: programs definitely halt or don't halt, but we can't determine which in a general manner
07:23:20 <Kaidelong> so if you had a statement "either a program halts or it doesn't" what is the truth value of that?
07:23:43 <mceier> \msg lambdabot @djinn Either a (Not a)
07:24:13 <zygoloid> Kaidelong: i think that's true but not provable in intuitionistic logic
07:24:35 <Kaidelong> that makes sense
07:24:49 <robryk1> is there a simple argument why?
07:24:58 <robryk1> that is, why somethign intrinsic doesn't help
07:25:34 <zygoloid> if there were a counterexample, you could derive a contradiction, so there can be no counterexample in a consistent model
07:25:48 <robryk1> i mean, why isn't it provable in int
07:26:19 <Kaidelong> robryk1: the only general solution to checking if a turing machine terminates is running it
07:26:25 <dolio> It would certainly be a non-trivial theorem.
07:26:32 <dolio> In classical logic you get it for free.
07:26:39 <dolio> Because A \/ Not a.
07:26:44 <zygoloid> well, looking backwards through the lens of curry-howard, a proof would be a general program which determines whether a type is inhabited
07:27:00 <robryk1> eh?
07:27:07 <robryk1> how would it get the type to check?
07:27:26 <mm_freak> how do i hide a package using the GHC command line?
07:27:28 <dolio> A constructive proof would be a decision procedure for the halting problem.
07:27:35 <robryk1> oh
07:27:36 <robryk1> right
07:27:38 <dolio> More or less.
07:28:30 <wioux1> :module -Package
07:28:49 <quicksilver> mm_freak: -hide-package?
07:28:58 <wioux1> er nvm
07:36:44 <mm_freak> quicksilver: thank you
07:37:24 <copumpkin> preflex: seen sjanssen
07:37:25 <preflex>  sjanssen was last seen on #haskell 64 days, 10 hours, 42 minutes and 27 seconds ago, saying: jbapple: I'm not familiar with any of those packages, so I really don't know
07:39:46 <jmcarthur> 64 days? :(
07:42:10 <copumpkin> I guess :/
07:42:14 <copumpkin> all these people disappearing
07:51:55 <fasta> preflex, seen shapr
07:51:55 <preflex>  shapr was last seen on #haskell-blah 13 hours, 45 minutes and 37 seconds ago, saying: and a variety of other strange bits of software.
07:56:20 <Esteth> I'm trying to write my own EitherT monad transformer for an exercise in "Real World Haskell", but I'm running into trouble with the type of my fail function. Logically, it should return a Left value wrapped in my EitherT transformer, but I can't use, say, Left "error" because then the whole monad transformer will need to use String on the Left. Should I use ()?
07:56:57 <copumpkin> use the wrapped monad's one
07:57:12 <Jonno_FTW> Is there an easier algorithm than long division to divide two numbers and return a floating point result to n decimal places?
07:57:45 <copumpkin> Jonno_FTW: if you don't mind slowness and lack of floating point, 
07:57:56 <Jonno_FTW> I need the floating points
07:57:59 <copumpkin> > showCReal 50 (7 / 17)
07:58:00 <copumpkin> oh
07:58:00 <lambdabot>   "0.41176470588235294117647058823529411764705882352941"
07:58:19 <Jonno_FTW> I need n significant figures
07:58:23 <Esteth> copumpkin: How do I construct a value for the wrapped monad when all I know is that it is an instance of Monad?
07:58:46 <quicksilver> Esteth: this is a famous problem with EitherT :-(
07:58:46 <copumpkin> Esteth: by using its fail method!
07:58:51 <copumpkin> :P
07:59:14 <quicksilver> Esteth: the instance in the library solves it by requiring a 'fromString' method to convert from the string passed to fail into the right type for the Left.
07:59:24 <quicksilver> this is not very nice either.
07:59:44 <Esteth> yeah. Remind me why fail is in Monad again? >_<
07:59:51 <copumpkin> evil
07:59:56 <Esteth> That was rhetorical by the way.
07:59:59 <copumpkin> :P
08:02:35 <jmcarthur> Jonno_FTW: it sounds more like fixed point to me. floating point doesn't guarantee how many figures you get
08:03:11 <jmcarthur> Jonno_FTW: like this http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Fixed.html
08:03:15 <jmcarthur> does that look like what you want?
08:06:14 <Jonno_FTW> jmcarthur: not really
08:09:37 <quicksilver> sounds like you want abitrary precision floating point
08:09:43 <quicksilver> I'm not aware of a library for exactly that
08:09:58 <quicksilver> although you can built it out of CReal plus a manually managed exponent, I think.
08:10:17 <quicksilver> or just use CReal and skip leading zeros, I guess :)
08:11:18 <randomwords> We could do with a reasonably efficient abitrary precision floating point library
08:11:44 <randomwords> I think most of the current libs focus on mathematical correctness rather than speed
08:11:45 <copumpkin> mpfr :P
08:11:49 <copumpkin> but we can't use it
08:12:12 <exDM69> randomwords: really? I thaught that GNU GMP is smoking fast
08:12:18 <fasta> Aren't all of them reasonably efficient? 
08:12:28 <Jafet> CReal isn't!
08:12:38 <quicksilver> copumpkin: http://hackage.haskell.org/package/hmpfr
08:12:39 <randomwords> I meant native sorry
08:12:42 <copumpkin> quicksilver: yeah, it doesn't work
08:12:43 <fasta> I think it is just that people expect hardware performance on fixed sized structures. 
08:12:47 <quicksilver> copumpkin: ?
08:13:01 <copumpkin> quicksilver: and can't work :P 
08:13:09 <copumpkin> edwardk was trying to find a way to fix it
08:13:10 <fasta> I know it is "slow", but the people who write these things are not known to write crappy stuff.
08:13:28 <quicksilver> copumpkin: well it works well enough for the author to have released 6 versions, it must have worked for someone at some time...
08:13:35 <randomwords> fasta: So you're saying we need better hardware eh ;)
08:14:03 <fasta> randomwords, more that I haven't seen proof that it can be done much faster.
08:14:15 <copumpkin> quicksilver: edwardk was just saying that it'll compile, but mpfr doesn't expect GHC's allocator to be doing the stuff it does, and so it breaks at runtime
08:14:22 <fasta> randomwords, or someone saying "the representation is really bad". 
08:14:44 <jmcarthur> Jonno_FTW: what is it that you need that our proposed solutions don't offer, exactly?
08:14:47 <copumpkin> quicksilver: I haven't tried it, but he said he couldn't find a way to fix it
08:14:56 <copumpkin> quicksilver: and any C library that relies on GMP, for that matter
08:15:43 <fasta> randomwords, regarding hardware: I bought a laptop nearly 1.5 years ago and I can still buy worse laptops in the shops. Progress has basically stopped.
08:16:10 <quicksilver> copumpkin: can't you use the private linking functions of (at least some OSes) and link a private copy of GMP into the package?
08:16:10 <fasta> randomwords, in fact, for the same amount of money you get less I think. 
08:16:16 <EvanR-work> my laptop from 2003 is about as good as new ones
08:16:23 <randomwords> fasta: I was really making the joke that instead of fp librarys we just invent larger word sizes in CPUs. 
08:16:27 <randomwords> 512bit floats
08:16:27 <EvanR-work> except for a different video card
08:16:44 <fasta> EvanR-work, pentium4, I suppose?
08:17:04 <copumpkin> quicksilver: it might work, beats me :) Not even sure how GMP stores its global allocator information
08:17:09 <fasta> EvanR-work, anyway, I think that's really bad. :)
08:17:13 <randomwords> I'm sure custom fp pipelines exist, but I'm pretty ignorant of cpu tech
08:17:17 <fasta> (the lack of progress)
08:17:36 <EvanR-work> fasta: yes something like that, 4-M
08:17:59 <EvanR-work> moores law is collapsing!
08:18:02 <Esteth> Is a kind error normally the result of something stupid I've done, or is it likely to be an error I need to understand to solve?
08:18:03 <EvanR-work> :o
08:18:26 <fasta> EvanR-work, a new interview with Mr. Kurzweil would be nice now.
08:18:30 <jmcarthur> > 40/7 :: Pico  -- Jonno_FTW: division to 12 points
08:18:31 <lambdabot>   5.714285714285
08:18:34 <EvanR-work> fasta: lol
08:18:47 <quicksilver> fasta: well I think the i5/i7 are some kind of progress; but the rate has definitely slowed quite remarkably.
08:19:26 <EvanR-work> they hit rock bottom with implementations, resorting to duplicating the computer (hexacore) and hoping that applications can be multiplexed efficiently
08:19:29 <fasta> quicksilver, yes, but the double exponential growth which Kurzweil talks about is far from that ;)
08:19:46 <EvanR-work> e^e^x
08:19:57 <randomwords> Isn't there a fundamental limit on how small you can make the process size before it all goes horribly wrong?
08:20:11 <randomwords> quantum effects etc.
08:20:26 <EvanR-work> stray capacitance, electron tunneling...
08:20:38 <fasta> I do think that having more cores and more bandwidth would provide new applications, but they would have to have millions of cores at the very least, not a few hundred. 
08:20:42 <quicksilver> fasta: Yes. It seems sublinear now.
08:21:15 <notabel> fasta: sounds like you want to program a Connection Machine
08:21:21 <fasta> quicksilver, of course Kurzweil would say that a new breakthrough will make all of this redundant "in just a few years". 
08:21:33 <fasta> notabel, something like that, but much bigger. 
08:21:37 <EvanR-work> carbon nano tube 3d computer
08:21:43 <EvanR-work> waiting
08:21:45 <fasta> That's more like it.
08:21:59 <fasta> Preferably self-replicating.
08:22:03 <EvanR-work> hahaha
08:22:09 <liyang> Don't forget quantum.
08:22:11 <fasta> With chrome. 
08:22:12 <fasta> ;)
08:22:43 <aavogt> fasta: bling?
08:22:44 <liyang> Throw in spintronic too.
08:22:51 <fasta> aavogt, yes. 
08:23:08 <fasta> aavogt, computing needs to be done in style, no?
08:23:37 <h_noob> does somebody using ubuntu/debian? Is there .deb I should install to get Data.Either.Unwrap?
08:23:58 <EvanR-work> ive been out of the loop for a while but it seems like nanotubes took a backseat like AI and Virtual Reality
08:24:13 <aavogt> perhaps you're describing gangstas... but they don't exactly run programs as electronic computers
08:24:52 <fasta> EvanR-work, I think there has been progress and most likely construction will be the first application. 
08:24:58 <notabel> EvanR-work: not really, but they've taken a support role.  ie less talk about nanotubes, more talk about X+nanotubes = superX
08:25:13 <notabel> for instance, X = photovoltaic cells\
08:25:32 <EvanR-work> did lasers go through this phase?
08:25:40 <EvanR-work> LASERS! i mean... laser powered X
08:26:06 <fasta> EvanR-work, don't they go through only one phase? 
08:26:22 <aavogt> refraction fasta
08:26:23 <EvanR-work> rofl
08:26:38 <fasta> :)
08:26:41 <notabel> well played fasta, well played
08:28:26 <fasta> They should find a good application to kill people with nano-tubes. Then development would go much faster. 
08:28:33 <azaq23> I don't quite get why the following would be true (seen yesterday here in #haskell):
08:28:37 <azaq23> @type mapM (>>=)
08:28:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => [m a] -> (a -> m b) -> [m b]
08:28:43 <EvanR-work> nanotube poisoning
08:28:56 <EvanR-work> less realistically, mind control
08:29:07 <fasta> EvanR-work, yes, but you typically want to kill only a few. Not all of them. 
08:29:08 <EvanR-work> artificial viruses!
08:29:54 <EvanR-work> id like to do weapons research, so i can be ultimately ironic when i explain my work
08:31:42 <fasta> EvanR-work, ironic, how?
08:31:45 <quicksilver> @type mapM
08:31:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:31:52 <Twey> I'm confused as to why you think it would be otherwise.
08:31:59 <Twey> (azaq23, that is)
08:31:59 <fasta> EvanR-work, unless you are going to reinvent an axe ;)
08:32:05 <quicksilver> azaq23: see the type of the first parameter to mapM? "a -> m b" ?
08:32:11 <aavogt> because the monad instance isn't one you're familiar with
08:32:53 <aavogt> > mapM id [succ,pred] 2
08:32:53 <lambdabot>   [3,1]
08:33:16 <azaq23> yes, but then -> would have to be a monad, not? ghci says -> Could not deduce (Monad ((->) (a -> m b)))
08:33:18 <aavogt> @type \f x -> mapM f [succ,pred] x
08:33:19 <lambdabot> forall t b a. (Enum a, Monad ((->) t)) => ((a -> a) -> t -> b) -> t -> [b]
08:33:31 <quicksilver> azaq23: right.
08:33:38 <aavogt> azaq23: you have to add an import
08:33:39 <quicksilver> azaq23: and (->) *is* a monad, but it's not in scope in your ghci
08:33:50 <Twey> azaq23: Ah!  It is a monad in lambdabot (instance defined in Control.Monad.Instances)
08:33:55 <quicksilver> azaq23: if you +m Control.Monad.Instances
08:34:06 <quicksilver> then you'll get lambdabot's answer
08:34:44 <azaq23> k, thanks, works - wasn't aware of that instance
08:36:43 <Esteth> Could anyone tell me why I get kind errors for my EitherT implementation? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28594
08:37:19 <quicksilver> your type for runEitherT is wrong
08:37:40 <quicksilver> Either has two parameters
08:37:43 <quicksilver> and you're only giving it one
08:38:28 <Esteth> aha, thank you. I should have something like: EitherT m a b = EitherT {runEitherT :: m (Either a b)}?
08:38:36 <Twey> Yeah
08:38:42 <Twey> Likewise for bindET &c.
08:39:09 <aavogt> pointfree data declarations?
08:39:40 <Philonous> Having a handle-like resource of which, for all practical purposes, there will always only one be active at any time, is it a good idea to hide the handle in a ReaderT and lift all functions that take it as an argument? 
08:40:30 <fasta> aavogt, yes, that is questionable.
08:41:36 <aavogt> fasta: how would that be much worse than pointfree expressions?
08:41:58 <EvanR-work> i would rather a kind error than a nasty one
08:42:31 <Esteth> I'm just going by Real World Haskell's example for MaybeT, which used the same style of declarations
08:44:22 <fasta> aavogt, I don't think I ever had the idea to use that feature. 
08:45:05 <fasta> aavogt, since it is impossible to create such values in the first place other that by using undefined. 
08:46:47 <fasta> aavogt, for type-synonyms there are applications, but in this case, I don't see any use case for this and it seems that the compiler should forbid it.
08:46:50 <aavogt> hmm? I mean if the data constructor contains values that are * -> *, it adds a parameter to the type and puts it in there
08:47:47 <fasta> aavogt, since when can you pass type-constructors in functions in Haskell?
08:48:04 <Esteth> how would one rewrite the data constructer for it not to be point-free? It's confusing me with these kind errors now, and I'd rather I get nasty type errors that I can fix than strange errors about kinds that I don't understand
08:48:30 <aavogt> fasta: you can't
08:48:44 <aavogt> this feature is hypothetical
08:49:10 <fasta> aavogt, but the module gets loaded in ghci.
08:49:32 <fasta> aavogt, so, it accepts something which is nonsense right now.
08:49:51 <fasta> aavogt, I know that you can do similar stuff in Coq, which makes sense. 
08:51:57 <quicksilver> fasta: it's not valid in ghci because GHC supports pointsfree types
08:52:07 <quicksilver> fasta: it's valid in ghci by inferring a different kind for 'm'
08:52:18 <quicksilver> ((* -> *) -> *)
08:52:23 <quicksilver> instead of the expected (* -> *).
08:53:36 <fasta> quicksilver, but can you make a concrete value of type EitherT?
08:53:47 <quicksilver> yes
08:54:04 <quicksilver> you have to provide it an "m" of kind ((* -> *) -> *) though
08:54:31 <fasta> quicksilver, ah, I think I see.
08:54:38 <quicksilver> (so, not a Monad)
08:54:49 <fasta> quicksilver, but the data in Either a b would be inaccessible.
08:55:56 <fasta> quicksilver, that's probably false, never mind.
08:57:25 <quicksilver> fasta: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28595#a28595
08:57:32 <Esteth> GHC doesn't seem to like the line: "instance (Monad m) => Monad (EitherT m) where" because it wants my instance to be *->* and my EitherT is now *->*->*. Do I have to specify concrete types in my instance declaration for it to accept it?
08:57:55 <fasta> quicksilver, I had a data Bar x b= Bar (x b)
08:58:02 <fasta> quicksilver, you were just a bit faster :)
08:58:04 <quicksilver> ;)
08:58:17 <quicksilver> Esteth: you have to supply all but one parameter to be a monad
08:58:30 <quicksilver> Esteth: your "left part" (the error type) needs to be there
08:58:59 <Esteth> Hm. That seems rather restrictive. so EitherT cannot exist in a generic form?
08:59:20 <fasta> Esteth, the kinds are just the types of types. If you need * -> *, you cannot provide e.g. Int, which is *.
08:59:56 <fasta> Esteth, you can specify a type-variable. 
09:00:33 <Optimo> 3G-Unrestrictor now supports facetime over 3G
09:00:39 <Optimo> whoops wrong windo sry guys
09:00:44 <copumpkin> lol
09:00:50 <EvanR-work> facetime (tm)
09:00:53 <Esteth> Right. I don't quite understand why I need to leave one of my type variables out of the isntance declaration
09:00:56 <EvanR-work> wtf
09:01:22 <robryk> because EitherT m a is a monad for every monad m and a
09:01:27 <quicksilver> Esteth: because that's what a monad is.
09:01:33 <robryk> and it isn't true that EitherT m is a monad
09:01:49 <quicksilver> Esteth: a monad is a constructor class - a class on types with exactly one variable missing.
09:01:50 <EvanR-work> copumpkin: i started typing haskell code into #cakephp a few days ago ;)
09:01:51 <Optimo> copumpkin, hi =)
09:01:58 <copumpkin> ohai Optimo 
09:02:03 <copumpkin> EvanR-work: were they terrified?
09:02:07 <quicksilver> Esteth: Maybe is a monad, [] is a monad, IO is a monad, Either x is a monad.
09:02:11 <Optimo> what's new in monad-land?
09:02:11 <EvanR-work> bewildered maybe
09:02:17 <quicksilver> Esteth: exactly one variable missing in each case.
09:03:25 <EvanR-work> copumpkin: if you restrict to only simple type signatures, things dont superficially look that hairy ;)
09:03:31 <fasta> Esteth, the required kind is something like *->*. If you put in a complete type (that is a *), it is not going to work. 
09:03:38 <copumpkin> EvanR-work: yeah
09:03:45 <copumpkin> Optimo: everything!
09:03:48 <Esteth> So is there anything special about the type that I miss out?
09:04:01 <Esteth> it seems like it's just as undefined as the type variables
09:04:12 <fasta> Esteth, the Monad type class is defined on m a stuff,  the m <which has to be a type constructor> thus takes one argument type (an a).
09:04:17 <Optimo> copumpkin, I like that pespective
09:04:59 <Esteth> So the one that I leave out is the one which is "wrapped" so to speak?
09:05:01 <fasta> Esteth, that is why the kind is *->* and thus also why you have to supply a type-constructor with that kind. 
09:05:06 * hackagebot HsSVN 0.4.3.1 - Partial Subversion (SVN) binding for Haskell  http://hackage.haskell.org/package/HsSVN-0.4.3.1 (MasatakeDaimon)
09:05:09 <fasta> Esteth, yes
09:05:54 <Esteth> righto, sorted :) I have another question, but my oven is beeping. Thanks for all the help. This stuff is mind-bending for me :(
09:06:26 <jmcarthur> mind-bending should have a smile next to it, not a frown ;)
09:06:30 <fasta> Esteth, remember that just because something bends the mind, it doesn't mean that that is a good thing.
09:07:29 <EvanR-work> blasphemy
09:07:36 <EvanR-work> why else do we use haskell ;)
09:08:08 <jmcarthur> because it doesn't suck?
09:08:51 <EvanR-work> bondage and discipline, forces us to think before we code
09:08:58 <EvanR-work> sometimes to think a lot ;)
09:09:31 <aavogt> sometimes less since you can often just ask what the types are
09:09:34 <jmcarthur> i know a lot of people call haskell a bondage and discipline language, but i really don't see it that way
09:09:46 <p_l> ... I think it's the first time I've seen someone equal haskell and kink xD
09:11:24 <jmcarthur> the way i see it, all the little functions i write are potentially evil demons in my programs, and haskell just keeps them under control with the sword of purity so i can get on with my work without fear of total destruction
09:11:25 <quicksilver> not really, this is quite common.
09:12:32 <EvanR-work> i suppose the B&D is supposed to be pejorative, used by people who think they know better and can do better without any restrictions
09:13:25 <EvanR-work> whereas after thinking enough in haskell, you go to free-play land and wisely apply the restrictions yourself
09:13:26 <p_l> EvanR-work: it kinda fails on people who don't consider it like that, I guess :D
09:14:09 <jmcarthur> i don't feel that the B&D restricts *me*. it's more like it restricts the little demons waiting in my code, which actually gives me more perceived freedom.
09:14:10 <EvanR-work> write code to do one thing and dont extend it to do something unrelated, or even related
09:14:10 * hackagebot cgen 0.0.1 - generates Haskell bindings and C wrappers for C++ libraries  http://hackage.haskell.org/package/cgen-0.0.1 (AnttiSalonen)
09:14:36 <EvanR-work> instead write another function and perhaps compose them
09:14:39 <fasta> Not having automatic infinite types is quite annoying sometimes, though. 
09:15:01 <p_l> EvanR-work: some people also take pride in *bad* cowboy programming
09:15:04 <jmcarthur> fasta: i would introduce so many errors if infinite types were allowed though
09:15:11 <p_l> or simply don't know better.
09:15:25 <EvanR-work> the latter im sure ;)
09:15:31 <EvanR-work> but ihave met a few bad cowboys
09:15:33 <p_l> funny thing, I'm maniacal lisper, and here I'm defending haskell's strictness :D
09:15:44 <jmcarthur> haskell isn't strict :P
09:15:58 <EvanR-work> good retort 'haskell is too restrictive'
09:16:02 <EvanR-work> 'no, its non strict'
09:16:11 * hackagebot hogre 0.1.0 - Haskell binding to a subset of OGRE  http://hackage.haskell.org/package/hogre-0.1.0 (AnttiSalonen)
09:16:13 * hackagebot hogre-examples 0.1.0 - Examples for using Hogre.  http://hackage.haskell.org/package/hogre-examples-0.1.0 (AnttiSalonen)
09:16:20 <p_l> jmcarthur: haha
09:16:30 <BMeph> From what I've seen, the people who use it (B&D) pejoratively, almost invariably imagine it in terms of something else restricting the programmer.
09:17:28 <BMeph> Those who do not use it that way, have a variety of usages, from those who imagine the restrictions keeping the programmer safe, to the programmer applying the restrictions to the data.
09:17:41 <jmcarthur> BMeph: i'm sure they think the same of the little rubber flaps on the backs of push lawn mowers
09:17:49 <jmcarthur> so restrictive
09:17:51 <jmcarthur> better without them
09:17:57 <jmcarthur> ;)
09:18:11 <aavogt> seatbelts are restrictive
09:18:29 <EvanR-work> most people would rather not have the flaps, so they can do 'advanced' lawn mowing. they know what their doing ;)
09:18:29 * BMeph thinks jmcarthur personally knows people who use lawn mowers while wearing shorts and flip-flops...
09:18:42 <jmcarthur> BMeph: actually i do
09:18:44 <BMeph> jmcarthur: amirite? ;)
09:18:58 <EvanR-work> aavogt: watch out because that analogy might lead to equating haskell's safety with training wheels on a bike ;)
09:19:55 <jmcarthur> EvanR-work: so true. i mean, all you have to do is avoid all human error (don't run over rocks and sticks and stuff)
09:20:11 <aavogt> EvanR-work: what's wrong with that analogy (other than the connotation being negative)
09:20:18 <EvanR-work> "error? what error?" *crash*
09:20:21 <RaptorJesus> haskell=kink
09:20:35 <EvanR-work> aavogt: the connotation is negati i mean nothing
09:20:40 <BMeph> EvanR-work: I prefer to think of them as rudder fins on a rocket. :)
09:21:11 <EvanR-work> its a nanotechnology repair skin on a relativistic ramjet ;)
09:22:02 <EvanR-work> analogies are useless
09:23:06 <RaptorJesus> using analogies on logic is like using a wrench on rivets
09:24:42 <EvanR-work> ive heard some criticism ofhaskell (not much though)
09:24:49 <BMeph> @remember RaptorJesus using analogies on logic is like using a wrench on rivets
09:24:49 <lambdabot> Okay.
09:24:50 <EvanR-work> mostly unfounded
09:25:03 <EvanR-work> but id like to collect everything i can and put it into an faq or something
09:25:08 <EvanR-work> propaganda page ;)
09:25:18 <jmcarthur> i've heard a *ton* of criticism of haskell
09:25:29 <EvanR-work> id be interested in recording whatever you know
09:25:40 <BMeph> I've seen poor jrockway flailing around trying to explain the use of monads on HN.
09:25:49 <jmcarthur> i think most of it is just because outsiders think haskellers see haskell as a silver bullet
09:25:56 <EvanR-work> i also want valid criticism, and criticism based on advance math and techniques and theory that no one understands ;)
09:26:51 <EvanR-work> tricky to separate criticism of haskell98 and ghc
09:27:00 <jmcarthur> i think a valid criticism of haskell in many practical applications is loose resource management, especially memory
09:27:06 <p_l> jmcarthur: I suspect the unfounded criticism is quite similar to how Lisp is criticised, except with comparisons to Java (due to supposed similarity due to types)
09:27:57 <james_britt> EvanR-work: Complaint I heard (and have had myself): basic things that are easy in many languages (e.g. Ruby, Perl) such as File IO and string interpolation are hard.
09:28:01 <jmcarthur> while it may appear that loose resource management is solely an implementation issue, haskell's laziness makes it really hard to get away from problematic garbage collectors
09:28:27 <jmcarthur> james_britt: really? that's not one i've experienced any difficulties with
09:29:52 <Philonous> EvanR-work: The record system, the monormorphism restriction, the module system (especially the scope of class instances), the Prelude (Show and Eq required for Num, Num being too coarse)
09:29:55 <EvanR-work> james_britt: well Text.Printf, but yeah this is the sort of stuff im looking for ;)
09:29:57 <jmcarthur> EvanR-work: i think it would also be fair to criticize haskell for its standard library, although this is more of a "haskell vs. potential" issue than it is a "haskell vs. mainstream languages)
09:30:01 <james_britt> I've found it les than obvious how to print, for example, integers mixed with strings
09:30:31 <jmcarthur> > printf "Foo %d bar %d baz %d" 5 6 7 :: String
09:30:32 <lambdabot>   "Foo 5 bar 6 baz 7"
09:31:03 <tommd> cale: Ping
09:31:06 <james_britt> jmcarthur: OK, but fugly
09:31:14 <jmcarthur> james_britt: compared to what?
09:31:15 <EvanR-work> the :: String isnt required
09:31:29 <robryk> :t printf
09:31:29 <Esteth> The biggest complaint I've seen is that there's no obvious way to design a program. OOP solves that nicely, but in haskell, people are greeted with mountains and mountains of functions, with no simple "verbs are methods, adjectives properties, and nouns objects" metaphor
09:31:30 <lambdabot> forall r. (PrintfType r) => String -> r
09:31:30 <jmcarthur> EvanR-work: yes it is, unless context contrains it
09:31:36 <EvanR-work> yes context is typical
09:31:45 <james_britt> jmcarthur: puts "I have #{@some_int_var} books on Haskell"
09:32:16 <jmcarthur> james_britt: i think it is questionable which is less fugly ;)
09:32:18 <tommd> @tell Cale Is the ImLib binding to "saveImage" incomplete??  Its type is awfully odd (saveImage :: String -> IO ()) - what image is being saved?
09:32:18 <lambdabot> Consider it noted.
09:32:22 * EvanR-work writes down perl style string substitution ;)
09:32:29 <james_britt> jmcarthur: Granted
09:33:32 <james_britt> Much of this is a result of expectations and experience, but for an outsider they are real barrrierss
09:34:10 <quicksilver> tommd: I've not used imlib, but it looks stateful
09:34:17 <quicksilver> tommd: I think there is an implicit 'current image'
09:34:25 <jmcarthur> james_britt: probably a quasiquoter could give you something like what you want
09:34:41 <jmcarthur> just for the record
09:34:57 <EvanR-work> maybe i should make it a wiki/blog or something so people can just post a massive review of haskell
09:35:14 <jmcarthur> a wiki page with criticisms of haskell would be nice
09:35:15 <tommd> quicksilver: ahh, thanks.
09:35:19 <jmcarthur> humbling, perhaps :)
09:35:24 <quicksilver> tommd: contextSetImage :: ImlibImage -> IO ()
09:35:24 <james_britt> jmcarthur: No doubt, but I think when many people jump into Haskell, they have a hard time finding resources that explain how to do things they're used to in "scripting" or OO languages
09:35:35 <james_britt> And then they dump on Haskell :)
09:35:36 <zygoloid> EvanR-work: how do you ensure it doesn't get full of misinformation and FUD?
09:35:37 <jmcarthur> as long as wel restrict it to either valid criticisms or invalid ones with counter-arguments
09:35:45 <quicksilver> tommd: lots of the calls appear to use that implicit image, like getWidth, getHeight, etc.
09:35:45 <jmcarthur> s/wel/we/
09:36:27 <EvanR-work> zygoloid: i would be incharge ;)
09:36:38 <Zeiris> Figuring out how to design large things is a problem... Part of it is finding good examples is tricky.
09:36:51 <Zeiris> They're either too large and undocumented and scary, or too small and toy-like.
09:37:03 <EvanR-work> Esteth: yours is interesting
09:37:04 <jmcarthur> EvanR-work: if we do a wiki page for it we will need to be careful not to turn into a big c2.com-alike
09:37:17 <EvanR-work> jmcarthur: yes i would avoid that manually ;)
09:37:39 <tommd> @tell Cale Nevermind - createRotatedImage confused me - now I see contextSetImage and all is well
09:37:39 <lambdabot> Consider it noted.
09:37:40 <Zeiris> And despite searching a bit, I think I've only ever found one book that talked about design effectively, in a "this is how you think about it, this is what you do" way.
09:38:19 <EvanR-work> Zeiris: are you talking about haskell or general
09:38:24 <EvanR-work> designing
09:38:55 <jmcarthur> the question of "how to design programs" seem more foundational than something haskell can be at fault for, to me
09:39:07 <jmcarthur> certainly it could be addressed on the page
09:39:19 <jmcarthur> *seems
09:39:31 <Esteth> jmcarthur: It's not really haskell's fault that program design is difficult, but the OOP community has come up with a simple way to make it easy from the get-go. FP doesn't have that yet.
09:39:42 <jmcarthur> Esteth: what way is that?
09:39:44 <Zeiris> In general, but the Haskell problem is more serious due to 1. being a new paradigm to people already familiar with OOP/procedural 2. Haskell's tendency to experiment or get all mathy 3. lack of examples.
09:39:47 * EvanR-work scribbles
09:40:05 <Zeiris> 3 can only be solved with time, and 2 isn't really a downside if you're into that sort of stuff, of course ;)
09:40:19 <jmcarthur> Esteth: my obervations of "the OOP camp" are largely made up of fundamental design questions
09:40:27 <Esteth> jmcarthur: Ye Olde "Nouns are objects, Verbs are methods, Adjectives are properties" Paragraph in the opening chapter of every "introduction to java/C#/OOP" book ever.
09:40:58 * kuribas doesn't find that OOP fits all problems nicely.
09:41:11 <quicksilver> Esteth: that doesn't actually make program design easy. But it does suggest one approach you can start with.
09:41:17 <jmcarthur> "nouns are nouns, adjectives are nouns, verbs are nouns"  :)
09:41:30 <jmcarthur> that would be haskell
09:41:46 <dkr> "Verbing weirds language." -- Calvin
09:41:46 <Esteth> Maybe the people I talk with normally all work the same way, but from a day or two into our first year class in java, it was easy to see how to start a program. When people tried picking up haskell, it's never been obvious how to solve a problem
09:41:48 <quicksilver> Esteth: (btw : nouns are data types, verbs are functions, adjectives are functions on data types)
09:42:00 <Zeiris> Haskell seems like it could be taught easier to people who took a math course or two in college. Purity seems easier to grasp if you think in terms of math formulas.
09:42:03 <jmcarthur> it doesn't really help, i know, but i don't think the noun, verb, adjective metaphor helps in OO either
09:42:06 <quicksilver> Esteth: yes, your second formulation seems more accurate
09:42:16 <quicksilver> Esteth: not actually "Easy to design programs" but "easy to see how to start".
09:42:18 <applicative> monads are tenses
09:42:30 <kuribas> Esteth: But those people already had exposure to programming languages?
09:42:32 <Esteth> quicksilver: That's more what I mean, thinking about it, yes.
09:42:34 <randomwords> Zeiris: Possibly, but only due to familiarity. I think if you had never seem imperative code before FP would be just as easy
09:42:43 <osaunders> Do you think it's feasible to test people by asking them to write graph reductions of Haskell expressions? I'm aware that expressions can be evaluated in multiple different ways. Maybe I can qualify it by saying "assuming everything is strict" or something.
09:42:53 <jmcarthur> i think this issue can be rolled up into "Haskell in unfamiliar"
09:43:01 <Zeiris> Seeing imperative code for many years probably is a stumbling block, yes. Math is more familiar.
09:43:22 <jmcarthur> *is
09:43:28 <Esteth> kuribas: Around half of our class hadn't done programming before, but still picked up Java reasonably quickly. I can't compare those people with a haskell class myself, but my friends who's first classes were in Haskell seemed less able to solve real problems
09:43:48 <kuribas> Esteth: I see.
09:43:53 <applicative> what is a real problem?
09:43:54 <randomwords> define "real problems"?
09:44:10 <jmcarthur> EvanR-work: there may be some good criticisms for you here: http://gamedev.stackexchange.com/questions/374/what-are-the-challenges-and-benefits-of-writing-games-with-a-functional-language
09:44:16 <Esteth> Something like "write a instant messenger program to talk with other people in the lab"
09:44:18 <applicative> this will mean:  what they teach in the first 10 pages of  a python manual...
09:44:20 * hackagebot CheatSheet 2.5 - A Haskell cheat sheet in PDF and literate formats.  http://hackage.haskell.org/package/CheatSheet-2.5 (JustinBailey)
09:45:06 <EvanR-work> jmcarthur: ah game related stuff
09:45:13 <EvanR-work> good stuff for #haskell-game ;)
09:45:22 <jmcarthur> EvanR-work: that channel exists?
09:45:28 <EvanR-work> barely
09:45:48 <jmcarthur> i definitely need to be in there then
09:46:03 <EvanR-work> great
09:46:06 <kuribas> Esteth: Haskell requires you to think clearly about things like passing state and side effects, I can imagine that it may be hard to grasp in the beginning.  But IMHO that's a good thing.
09:47:00 <Zeiris> kuribas, for practical applications you end up spending time figuring out how to get around that, though. Which should pay off in the long run, but man is it a pain in the short run. Sometimes all you want is a Python dictionary :)
09:47:21 * hackagebot DSTM 0.1.2 - A framework for using STM within distributed systems  http://hackage.haskell.org/package/DSTM-0.1.2 (FrankKupke)
09:47:33 <minoru-kun> hello everybody, here i have a big problem
09:47:37 <jmcarthur> kuribas: another possibly valid criticism based on that: Haskell makes exploratory coding difficult for people with certain mindsets.
09:47:46 <EvanR-work> Zeiris: you know ive experienced that in OOP design
09:47:53 <EvanR-work> i want to 'just do something' but i cant figure out how to make it OOP
09:48:01 <EvanR-work> i spend a lot of time on it
09:48:09 <jmcarthur> i find exploratory coding in haskell *easier* than in many other languages, but that's only because i have learned a "type-driven" approach
09:48:16 <jmcarthur> EvanR-work: me too!
09:48:34 <kuribas> Zeiris: True.  I have found that my stumbling blocks when coding in haskell usually made me rethink things I know.
09:50:18 <minoru-kun> for example, we have
09:50:18 <minoru-kun> f1: (Data d => d -> f) -> a -> a1
09:50:18 <minoru-kun> class DoSomething where
09:50:18 <minoru-kun>    doSomething :: a -> b
09:50:18 <minoru-kun> how can we define f2 :: Data d => d -> f , that uses doSomething inside if d is also instance of DoSomething, or displays error otherwise?
09:50:48 <Zeiris> kuribas, the type system definitely develops your understanding of problems. Sometimes, though, it's just a pain in the ass. (I spent at least 6 hours writing + wrapping my head around a library last night, to load critical program data from CSV files, yet keep some of the type benefits I'm using Haskell for. It is -not- rocket science, but it took me a while and still isn't ideal)
09:51:28 <Zeiris> If I used a Python dictionary, it woulda been written in about 30 seconds... But then I would start annotating Python code with Haskell type signatures in the comments, and it would come full circle again.
09:51:29 <kuribas> Zeiris: Can you show your solution?
09:51:29 <applicative> minoru-kun maybe if you posted a bit of code on hpaste.org ?  It's a little hard to follow
09:52:12 <jmcarthur> Zeiris: but the unique thing there is that you were seeking type safety. had you not been doing that, i imagine it would have been much easier, and the option to have that kind of type safety is one you don't even have available in many other languages
09:52:47 <jmcarthur> Zeiris: my point is that if you write python in haskell it's probably easier than intentionally seeking type safe abstractions
09:52:57 <applicative> minoru-kun  Is this a question about Data.Data or something more elementary?
09:53:11 <jmcarthur> but it's also going to build up into the big mess that many python programs turn into
09:53:18 <Zeiris> kuribas, warning, code in progress. Lib: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28597  Usage: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28598#a28598
09:53:29 <jmcarthur> what i mean is... they aren't so different in this respect :)
09:53:45 <EvanR-work> a csv reader is pretty easy to specify the interface of ;)
09:54:01 <EvanR-work> and should be easy to convert to a Data.Map of the desired kind
09:54:12 <EvanR-work> as a second stage
09:54:23 <Zeiris> jmcarthur, true, there's no way that I'd get the same kind of compile-time safety in Python. Well, I might, but it'd be "unpythonic" and take about as much effort as this has.
09:54:42 <EvanR-work> should be as safe as database access
09:54:52 <Zeiris> Hopefully that safety will pay off in the long run... However, I've programmed long enough now to know that I can't see how long that long run will be :[
09:55:10 <minoru-kun> applicative, about something more elementary. I think that there are some language extensions to do it. Please wait a bit, I'll post a code snippet on dumpz.org
09:58:21 <Zeiris> EvanR-work, seems so, and I've got the Map k (Vector a) implementation with a function that generates a data definition for k, based on the header of a CSV file. The thing I'm wrapping my head around is 1. strictness (moving type checks from compile time to startup time, which is still better than arbitrary run time, and some of the checks even remain at compile time!) 2. using this data in pure code, such as type instances (since it's as
09:58:22 <Zeiris>  integral a part of the program as the executable file... but just so happens to be in another file)
09:59:49 <kuribas> Zeiris: You wouldn't have typechecks in python either, would you?
10:00:16 <Zeiris> I would eventually. In the form of type mismatch exceptions when the code gets executed.
10:01:54 <EvanR-work> Zeiris: thats the thing
10:02:06 <EvanR-work> i would have made the raw interface an Array (Int,Int) String ;)
10:02:37 <EvanR-work> then you made your own decoder rather than attempting to write your own data language into the csv file
10:02:53 <EvanR-work> csv are so dynamic i wouldnt try to embed actual type safety into them directly
10:03:10 <Zeiris> Oh the csv files starts with a row of names for the columns.
10:03:21 <Zeiris> And individual columns are all the same type.
10:03:29 <EvanR-work> names == types?
10:04:13 <Zeiris> Individual columns = types, names = way to automatically generate type declarations, loading the CSV file on program startup = opportunity to type-check the file.
10:04:45 <EvanR-work> it should be checked on decode
10:05:29 <EvanR-work> something that doesnt parse is a Nothing or a default value
10:05:49 <EvanR-work> or the whole process fails, but i think most of it is better than none
10:06:32 <Zeiris> It is checked on decode. Decode happens on program startup, if something's malformed and the [[ByteString]] -> Map MyKeyType (Vector ByteString) decoding fails the entire process fails.
10:06:35 <EvanR-work> the process of generating useful data from a csv file i dont think can be solved generally with embedded tags
10:07:11 <Zeiris> The embedded tags are already in place (for human readability, mostly) I'm just making use of them to make generating appropriate Haskell data structures easier.
10:07:18 <EvanR-work> thats dangerous! ;)
10:07:21 <osaunders> When defining your own operators how do you know what precedence level to give them?
10:07:24 <Zeiris> If you check http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28598#a28598 - that's a lot of different key values. And that's just two files.
10:07:38 <minoru-kun> applicative, http://dumpz.org/21471/
10:07:45 <EvanR-work> human readable stuff mixed with programatic interpretation is the hallmark of php brittle apps
10:08:11 <Zeiris> It is dangerous - but that's the tradeoff you gotta make when dealing with large data files. There is literally no other choice I see, short of hardcoding magic integers into my code.
10:08:19 <EvanR-work> if either end decides to spell something different yer in trouble
10:08:27 <minoru-kun> applicative, also, note the type of fromConstrM
10:08:38 <EvanR-work> Zeiris: well you can make specialized decoders, that is easier if the decoding is composable
10:09:30 <minoru-kun> i think that some ghc extensions may do the work
10:10:04 <Zeiris> Yep, if the CSV file doesn't match code it crashes at start-time. But I've got a choice between "lup statTable SCAdd 324" and "lup statTable 0 324"... Using a custom data type instead of an int for even -one- of the indexes takes away a huge risk.
10:10:23 <EvanR-work> Zeiris: nah
10:10:29 <Zeiris> I can't use the wrong index from a different table. I can't use the wrong index from the same table. The code is readable...
10:10:31 <EvanR-work> thats where Maybe and default values come in
10:10:48 <EvanR-work> index?
10:11:25 <Zeiris> Well, yeah. My whole goal is to use "data IndexKey = IA | IB | IC ..." instead of 0,1,2 :)
10:12:45 <EvanR-work> hmm.
10:13:11 <osaunders> Ooh, what's non-associtativity?
10:13:16 <EvanR-work> on a related note, something that might be interesting... (i avoid classes unless i see a real use)...  is a CSV class
10:13:26 <zygoloid> osfameron: check out this handy chart: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27894
10:13:44 <EvanR-work> the CSV class has methods to encode and decode data values (like record types) from a row in a CSV
10:13:57 <osaunders> zygoloid: That is handy.
10:14:04 <Zeiris> The problem I'm trying to solve, is I've got ~400kb of data, spread across ~10 separate tables, with up to 200 columns and hundreds of rows each. I've hardcoded that kind of thing in the past (C include files are a wonderful thing) but it wasn't pretty.
10:14:35 <Zeiris> So it comes down to loading it from disk, with minimal wrapper code, and maximum type safety.
10:14:47 <EvanR-work> so to write a list of datas to the csv you forM list (putStrLn . encode)
10:15:16 <EvanR-work> safeDecode could be specially suited to returning default data or Nothings
10:15:54 * EvanR-work wonders
10:16:20 <EvanR-work> or error messages
10:16:28 <EvanR-work> what exactly was wrong with the record
10:16:58 <EvanR-work> its like the Binary or Storable or some other such class
10:17:02 <EvanR-work> but suited for csv ;)
10:17:22 <Zeiris> EvanR-work, I think we're thinking about two different problems here. Returning Nothing when out of range is straightforward - but how do you get a better interface than (Int,Int) to a CSV file?
10:17:30 <EvanR-work> out of range?
10:18:20 <osaunders> zygoloid: It's changed since 98 http://www.haskell.org/onlinereport/decls.html#fixity
10:18:26 <Zeiris> Ah. So safeDecode :: [[ByteString]] -> Maybe (Map ColumnKey (Vector ByteString)) ?
10:18:36 <EvanR-work> Zeiris: well with a csv instance on your data records, the interface would be (CSV v) => filename -> IO [v]
10:20:00 <Zeiris> Ahh. So a data record would be "data Row = {rA :: Int, rB :: ByteString, rC :: Char ...}", and have an "instance CSV Row"?
10:21:00 * Zeiris has trouble imagining that for 200+ columns in Row.
10:21:20 <EvanR-work> Zeiris: Row could be like... Student or something
10:21:27 <Zeiris> Yeah.
10:21:43 <EvanR-work> or RawStudent if you want to convert students to another form
10:21:52 <EvanR-work> after reading
10:22:08 <EvanR-work> basically instances would just list the fields they wanted in the way they wanted
10:22:16 <EvanR-work> and on decode, parse the string to a useful value
10:22:24 <EvanR-work> thats where safeDecode comes in
10:22:30 <EvanR-work> for failed parses
10:22:39 <Zeiris> How would you do that for 200+ columns, though?
10:22:42 <EvanR-work> i bet theres a hackage package for this already ;)
10:22:49 <nolrai_psu> Yo, the example code in the Cairo bindings is wrong, who should I let know?
10:22:53 <Zeiris> I have the feeling it's template-haskell :D
10:22:55 <EvanR-work> Zeiris: well are some columns supposed to be converted a list ?
10:22:56 <applicative> minoru-kun why are you using readLn?  I'm not following...
10:23:09 <EvanR-work> or are there really 200 columns?
10:23:15 <Zeiris> There are really 200 columns.
10:23:16 <EvanR-work> different data fields
10:23:19 <EvanR-work> ._.
10:23:22 <Zeiris> Yep. All different data types.
10:23:28 <jmcarthur> woah
10:23:29 <EvanR-work> something is denormal about this data
10:23:35 <jmcarthur> ha
10:23:48 <Zeiris> It's about 50% sparse, but this is about as "real world" as it gets.
10:23:53 <EvanR-work> ._.
10:23:56 <EvanR-work> NULLs ?
10:24:00 <jmcarthur> nice
10:24:38 <Zeiris> Three similar tables merged together, not all columns are intersecting. This leads to 50% sparsity.
10:24:48 <EvanR-work> who designed this system ;)
10:24:56 <Zeiris> Also, some values are undefined (due to not being used) so I suspect overall sparsity is ~60 to 75%.
10:24:58 <Zeiris> Blizzard.
10:25:00 <EvanR-work> lol
10:25:04 <jmcarthur> haha
10:25:11 <jmcarthur> is this a starcraft thing? ;)
10:25:37 <Zeiris> No, a decade older. Still, if I'm gonna learn, I figure I should learn from the masters :)
10:25:46 <EvanR-work> 'masters' my ass
10:25:57 * jmcarthur masters my ass
10:25:57 <minoru-kun> applicative, because in the main problem i'll have to deal with Convertable class.
10:26:12 <EvanR-work> anyway yeah were talking about different things, i assumed a save csv schema
10:26:13 <Zeiris> There's a -lot- of data in this game. You can't hide from it - gotta handle it somehow.
10:26:22 <Zeiris> And you sure as heck can't hardcode all this :p
10:26:28 <EvanR-work> no you cant
10:26:34 <jmcarthur> you could at least normalize it though :P
10:26:50 <EvanR-work> its just your trying represent an entire database with a single table
10:26:54 <EvanR-work> with NULLs
10:27:12 <jmcarthur> it was probably made in an excel spreadsheet
10:27:24 <jmcarthur> i'm not joking
10:27:43 <EvanR-work> i figured it was from a long time ago
10:28:01 <EvanR-work> dont fix it if its not broken
10:28:03 <Zeiris> jmcarthur, yep, most likely! Someone remind me, normalization is simplifying the data to use as few tables as possible?
10:28:19 <jmcarthur> Zeiris: it's simplifying the tables to reduce redundancy
10:28:30 <jmcarthur> Zeiris: probably introduces many *more* tables
10:28:38 <jmcarthur> a lot nicer to work with though
10:29:08 <Zeiris> Makes sense... However, doing so increases code complexity for handling all those extra tables.
10:29:14 <jmcarthur> Zeiris: for example, everywhere you see NULL, that is a sign of denormalization
10:29:19 <EvanR-work> depends on what you want to do with it
10:29:28 <jmcarthur> it increases code complexity, but increases code comprehension, too
10:29:42 <EvanR-work> databases have already been designed for this purpose
10:30:00 <jmcarthur> denormalization is usually either a result of laziness of optimization
10:30:13 <jmcarthur> normalization is safer and cleaner, generally
10:30:16 <EvanR-work> heh @ optimization
10:30:24 <jmcarthur> *laziness or optimization
10:30:31 <Zeiris> Well, extremely efficient serialization/deserialization was a design goal here. This data describes objects in a computer game, which must be saved to disk and sent over the net as efficiently as possible. Since it's denormalized, -all- items can be handled the same way by compression.
10:30:52 <EvanR-work> you would take up less space wasting commas on empty fields
10:31:07 <jmcarthur> Zeiris: normalized data is usually more space efficient
10:31:07 <EvanR-work> and then you json encode and deflate it
10:31:10 <Zeiris> Hm. Wait, yeah.
10:31:26 <jmcarthur> not always though
10:32:26 <Zeiris> I'm pretty sure I can trivially factor out stuff like the serialization/deserialization code. And anything else shared by all three tables. Then possibly move down further - into data I care about, and everything else.
10:32:43 <jmcarthur> having two separate tables that each contain only a key on each row and then creating a join table for them would be be less space efficient than a denormalized version
10:33:01 <jmcarthur> for an example of normalization being bad for space
10:33:21 <Zeiris> This makes the row-centric record-syntax data storage viable, and superior to my current column-syntax, key-type method.
10:33:35 * hackagebot strict-concurrency 0.2.4 - Strict concurrency abstractions  http://hackage.haskell.org/package/strict-concurrency-0.2.4 (DonaldStewart)
10:34:06 <Zeiris> As far as acid tests of programming language capability go, though, I think this is a pretty darn good one.
10:34:36 <applicative> minoru-kun, I'm at a loss, class Convertible is the one from the new records package?  
10:37:34 <minoru-kun> applicative, no, class Convertible is the one from HDBC package
10:38:52 * wli isn't entirely clear on what the test of the programming language is.
10:38:56 <mrdk> How can I define a global constant during compile time? (I want to use $HOME globally in my code).
10:39:21 <mauke> $HOME at compile time? how is that useful?
10:39:54 <minoru-kun> The main problem is to deal with HDBC and MySQL. But first, I need to understand how can I cast Data (or arbitary type) to arbitary type. So, I asked here.
10:40:38 <minoru-kun> logically, there is no problem. the problem is to write an actually working haskell code.
10:40:52 <mrdk> mauke: I need the content of $HOME in my code. I could use getEnv "HOME", but I don't know a way to define a variable globally using getEnv
10:41:14 <mauke> mrdk: that doesn't really answer my question
10:41:15 <zygoloid> mrdk: the $HOME /at build time/ ?
10:41:26 <mauke> also, why does it have to be a global constant?
10:42:02 <osaunders> Can somebody ask me questions to test my knowledge?
10:42:16 <zygoloid> osaunders: who won the world cup in 1962?
10:42:27 <jmcarthur> osaunders: explain what a zygohistomorphic prepromorphism is
10:42:32 <mauke> osaunders: what's the air speed of an unladen swallow?
10:42:41 <osaunders> OMG!
10:42:52 <mrdk> sorry, I guess I'm bad at explaining. What I want is a variable named f.e. home in my code, which I can globally access in my code. That's why I thought maybe there's a way to hardcode it in the binary
10:43:04 <zygoloid> um guys, i think that's asking questions to test /patience/, not /knowledge/ ;-)
10:43:08 <tromp> osaunders, what is number of 19x19 go positions?
10:43:19 <osaunders> Can you ask me questions about function application and currying please.
10:43:31 <mauke> osaunders: what does 'flip id' do and why?
10:43:38 <osaunders> OK, OK.
10:43:42 <zygoloid> mrdk: is this for a quick hack? otherwise, hardcoding it sounds like it'd lead to brokennness
10:43:48 * osaunders thinks
10:44:01 <Zeiris> jmcarthur, EvanR-work : my bad, looking a little closer there's only 117 columns in the main thing. 96 can be normalized out, into 4 or so separate tables.
10:44:08 <zygoloid> mrdk: if you're prepared to assume it's constant you'd probably be fine with an unsafePerformIO
10:44:18 <osaunders> id 4 is 4
10:44:41 <osaunders> I guess flip id would require another parameter to be complete.
10:45:02 <zygoloid> flip id is indeed a function
10:45:16 <mrdk> zygoloid: it /could/ change, but then I'd just recompile it
10:45:18 <nolrai_psu> > flip id (+2) 3
10:45:19 <lambdabot>   3
10:45:22 <osaunders> But wait flip needs (a -> b -> c) for first parameter.
10:45:29 <nolrai_psu> bwa?
10:45:43 <zygoloid> mrdk: unsafePerformIO would be a fair bit simpler than TH, and it'd not require a recompile (only a rerun) if it changes
10:45:43 <mauke> nolrai_psu: stop confusing yourself and the newbies
10:46:02 <zygoloid> haha caleskel kills another newbie :)
10:46:04 <nolrai_psu> What did I do wrong?
10:46:09 <azaq23> osaunders: a -> b -> c == a -> (b -> c) == a -> d where d = b -> c
10:46:24 <Zeiris> Which brings me to the key question concerning records: is there some nice way to do "[ByteString] -> recordConstructorFunc -> Record"? With Record having many values, of a couple of different types?
10:46:29 <tromp> > 3 (+2)
10:46:30 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:46:31 <lambdabot>    `GHC.Num.Num a' arising f...
10:46:47 <tromp> ghci
10:47:09 <nolrai_psu> > (:"string") x
10:47:10 <mrdk> zygoloid: sounds good about unsafePerformIO.
10:47:10 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:47:10 <lambdabot>         against inferred type...
10:47:16 <osaunders> mauke: I don't know what flip id does. :-(
10:47:16 <nolrai_psu> > (:"string") 'x'
10:47:17 <lambdabot>   "xstring"
10:47:24 <mauke> osaunders: what is its type?
10:47:30 <yitz> @type flip id
10:47:31 <lambdabot> forall a b. a -> (a -> b) -> b
10:47:35 <osaunders> mauke: And I'm ignoring other people because they are only making things more complicated for me.
10:47:38 <mauke> yitz: don't make me kick you
10:47:41 <yitz> oops
10:47:46 <osaunders> It's ok I haven't read it.
10:47:47 <yitz> @slap yitz
10:47:47 * lambdabot will count to five...
10:48:00 <mauke> and by kick I mean look at you
10:48:01 <mauke> furiously
10:48:16 <osaunders> id :: a -> a; flip :: (a -> b -> c) -> b -> a -> c
10:48:18 <osaunders> so...
10:48:19 <nolrai_psu> > [1..5] :: [int]
10:48:19 <lambdabot>   Could not deduce (GHC.Num.Num int) from the context ()
10:48:20 <lambdabot>    arising from the ...
10:48:26 <nolrai_psu> > [1..5] :: [Int]
10:48:27 <lambdabot>   [1,2,3,4,5]
10:48:46 <osaunders> I've no idea. To me flip id should be type error.
10:48:53 <zygoloid> osaunders: i suggest you rename your type variables, so you don't reuse 'a' in both types
10:49:12 <aavogt> osaunders: flip ($)
10:49:18 <aavogt> @src ($)
10:49:18 <lambdabot> f $ x = f x
10:49:20 <mauke> zygoloid: but the 'a's are actually equal :-)
10:49:24 <aavogt> == id
10:49:29 <zygoloid> mauke: :)
10:49:41 <mauke> seriously, why do people do this?
10:49:46 <zygoloid> i think it's good general advice though
10:50:03 <osaunders> OK, tell me why flip id isn't a type error.
10:50:06 <mauke> osaunders: do you understand how a -> b -> c actually means a -> (b -> c)?
10:50:18 <osaunders> Because flip first parameter should be a -> b -> c and id is only a -> a
10:50:24 <jmcarthur> osaunders: think about how flip *constrains* the type of id
10:50:25 <zygoloid> osaunders: flip requires that id :: a -> b -> c. what does that tell you about a, b and c?
10:50:51 <jmcarthur> id is polymorphic, so you can unify its parameter and result so any type, even another polymorphic type
10:51:03 <jmcarthur> *to any type
10:51:17 <zygoloid> osaunders: you know that you need (a -> a) == (b -> c -> d). how can that happen?
10:51:34 <osaunders> mauke: Reminding me is useful
10:52:08 <nolrai_psu> bizarr, my unthought out intuitive awnser was right, and my thought out one was wrong.
10:52:55 <osaunders> @src flip
10:52:55 <lambdabot> flip f x y = f y x
10:53:43 <osaunders> Can I have an easier one. :'-(
10:54:28 <mauke> no, flip id is the essence of currying
10:54:35 <somnium> I'm curious, say I have some data Quux_0 ... Frotz_n, then later I decide I want to add some meta-data, maybe a Map of some sort   
10:54:39 <aristid> :t flip id
10:54:39 <lambdabot> forall a b. a -> (a -> b) -> b
10:54:53 <aristid> mauke: uh, what?
10:55:11 <somnium> is it better to rewrite the base type with Maybe Map, or make a wrapper type, or is there an elegant way?
10:55:35 <osaunders> mauke: Can we try to walk through it?
10:56:00 <zygoloid> osaunders: remember (a -> a) == (->) a a, and (b -> c -> d) == (->) b (c -> d)
10:56:42 <zygoloid> also, t a b == u c d => t=u, a=c, b=d.
10:56:53 <mauke> osaunders: you're trying to match (a -> a) with (a -> b -> c)
10:57:06 <mauke> (a -> b -> c) is (a -> (b -> c))
10:57:07 <osaunders> Yes.
10:57:17 <mauke> hence a = a and a = (b -> c)
10:57:19 <aavogt> @type (\id -> (id, flip id)) id
10:57:19 <lambdabot> forall a b. ((a -> b) -> a -> b, a -> (a -> b) -> b)
10:57:40 <nolrai_psu> well now I see what I did wrong.
10:57:55 <mauke> osaunders: id :: (b -> c) -> (b -> c) is a valid specialization of id
10:58:23 <osaunders> Wait.
10:58:34 <nolrai_psu> > 2 1
10:58:35 <lambdabot>   Ambiguous type variable `t' in the constraint:
10:58:35 <lambdabot>    `GHC.Num.Num t' arising f...
10:58:40 <osaunders> It's like your putting id into flip not flip into id.
10:59:05 <mauke> type inference works in all directions
10:59:34 <aavogt> there was some app for showing some reductions of haskell expressions somewhere?
10:59:47 <aavogt> step by step
11:00:18 <nolrai_psu> Gah (Num a => a -> a) is an instance of Num? 
11:00:24 <edwardk> aavogt: mcmasters has something that cale likes to use
11:00:36 <mauke> nolrai_psu: did you mean: (Num a) => b -> a
11:00:47 <edwardk> nolrai_psu: needing one is usually a sign that you omitted a parameter
11:01:20 <nolrai_psu> mauke: posibly, its what ever makes "> 1 $ 2" eval to 1.
11:01:30 <nooodl> hey, i'm new to haskell, i'm going to try finding out the answer "what does flip id do" as well :)
11:01:39 <nolrai_psu> mauke: just seems counter intuitive.
11:01:50 <osaunders> nooodl: Welcome, I hope you're not as confused as me.
11:02:01 <aristid> > 1 2 :: Expr
11:02:01 <lambdabot>   1
11:02:04 <edwardk> mauke: ah, to make that Num instance  you need to lie a bit. unfortunately Eq and Show are a superclasses of Num,. neither can be properly implemented for Num b => a -> b
11:02:17 <mauke> edwardk: that's a bug in Num
11:02:19 <edwardk> er nolrai_psu 
11:02:23 <edwardk> mauke: i agree
11:02:34 <nolrai_psu> Its an Expr hmm that makes more sense.
11:02:51 <mauke> > 1 2 :: Int
11:02:52 <lambdabot>   1
11:03:08 <aristid> mauke: now you're being mean :D
11:03:09 <edwardk> nolrai_psu: that is a combination of Expr and a "caleskel" instance Num b => Num (a -> b)
11:03:26 <Zeiris> Why does this code type mismatch? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28599#a28599
11:03:29 <nooodl> got it :O
11:03:51 <nolrai_psu> well I like some caleskel, but.. 1 == const 1 seems a little strange.
11:04:02 <aavogt> Zeiris: use parentheses
11:04:09 <Zeiris> :(
11:04:18 <aristid> nolrai_psu: why? think about it this way:
11:04:22 <aristid> 1 = pure 1
11:04:22 <nooodl> well, i figured out what it does, at least, but why it does so is puzzling me a little
11:04:32 <mauke> Zeiris: because $ is right associative
11:04:46 <aristid> sin = fmap sin
11:04:52 <aristid> (+) = liftA2 (+)
11:05:02 <nolrai_psu> aristid: hmm okay.
11:05:02 <mauke> s/fmap/liftA/
11:05:15 <aristid> mauke: huh? fmap is the same as liftA
11:05:18 <copumpkin> it is
11:05:19 <edwardk> fmap = liftA
11:05:23 <mauke> http://mauke.ath.cx/stuff/haskell/fun.hs
11:05:32 <mauke> the whole thing is really rather regular
11:05:41 <conal> mauke: have you seen applicative-numbers?
11:05:48 <mauke> conal: no
11:05:56 <nooodl> nevermind, if you find out what it does and look at @src flip you pretty much know why it does so
11:06:05 <conal> mauke: it packages up that Applicative pattern
11:06:18 <mauke> nooodl: but how does it typecheck?
11:06:56 <aavogt> Zeiris: if you apply   map dec   to the argument of decode, before pattern matching, you don't need () or $
11:07:07 <osaunders> flip f x y = f y x
11:07:09 <osaunders> flip id x y = id x y
11:07:09 <osaunders> flip x = x y
11:07:28 <aristid> conal: infix syntax for applicative is what really is needed, i think
11:07:36 <copumpkin> @hackage infix-applicative
11:07:37 <lambdabot> http://hackage.haskell.org/package/infix-applicative
11:07:42 <aristid> i know i know
11:07:45 <copumpkin> I failed anyway
11:07:46 <aristid> :)
11:07:49 <nooodl> if osaunders is right i'm very confused right now
11:07:51 <mauke> osaunders: your third line doesn't make sense to me
11:07:58 <aristid> copumpkin: i know which package you mean tho :)
11:08:00 <nooodl> yeah
11:08:09 <copumpkin> :D
11:08:09 <nolrai_psu> osaunders: flip id x y = id y x
11:08:11 <mauke> also, flip id x y = id y x
11:08:12 <nooodl> i don't want to spoil anything yet
11:08:12 <jmcarthur> osaunders: you switched something around in the second line
11:08:19 <nooodl> oh there you go
11:08:20 <nolrai_psu> doesn't it?
11:08:42 <sproingie> > (* 2) `liftA` [1..10]
11:08:43 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
11:08:51 <osaunders> jmcarthur: OK, thanks
11:08:56 <nooodl> mauke: hmm, typechecking is the thing with the arrows right :)
11:09:23 <sproingie> @src liftA
11:09:23 <lambdabot> liftA f a = pure f <*> a
11:10:35 <nooodl> "flipId :: a -> (a -> b) -> b", or something?
11:11:16 <osaunders> OK there's obviously something basic I've completely misunderstood.
11:11:43 <jmcarthur> osaunders: okay, let's walk through exactly what you did a second ago, but without the errors ;)
11:11:46 <Zeiris> aavogt, aww, you got me all excited but no :( Rec takes varied types, map produces a single type.
11:11:50 <jmcarthur> flip f x y = f y x
11:11:55 <Zeiris> I'm really sad too, 'cuz that seemed like one step away from a silver bullet.
11:12:02 <jmcarthur> flip id x y = id y x
11:12:09 <jmcarthur> osaunders: following that so far?
11:12:26 <osaunders> Yes.
11:12:31 <osaunders> Thank you for asking.
11:12:45 <jmcarthur> osaunders: can you do the next step yourself? it's something you do *only* on the right hand side
11:13:00 <osaunders> Ah, OK.
11:13:03 <nolrai_psu> nooodle: that is a type. Type checking is makeing sure that the pieses of an expression have types that allow the expression to have a type. er..some one else should put that better.
11:13:07 <osaunders> flip id x y = y x
11:13:11 <jmcarthur> right!
11:13:33 <osaunders> Why was I changing the left side?!
11:13:50 <jmcarthur> i think you were trying to do some sort of cancellation or something
11:13:59 <nooodl> nolrai_psu: huh, i'll have to look that up
11:14:05 <aavogt> Zeiris: something like   foldl (\c x -> c (dec x)) Rec (a:b:c:d:e:[])   if it could be typechecked
11:14:14 <aavogt> it can work using template haskell
11:14:26 <jmcarthur> osaunders: if you treat "flip id" as the function name then you can assign it some sort of type now
11:14:34 <jmcarthur> of the form:   flip id :: <???>
11:14:37 <Zeiris> Anything can work using Template Haskell. It always seems to come up, and I don't know whether that's the fault of my mindset or of the language itself.
11:14:38 <nooodl> whoops, he quit. :S
11:16:38 <aavogt> Zeiris: maybe -XRank2Types could get it working
11:16:59 <nooodl> can somebody give an example of typechecking? googling only confuses me more
11:17:08 <nooodl> perhaps i'm not looking where i should be... hmm
11:17:50 <aavogt> > 'a' :: Int
11:17:51 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:17:51 <lambdabot>         against inferred type ...
11:17:56 <aavogt> nooodl: ^^
11:18:26 <zygoloid> nooodl: try googling for type inference, maybe
11:19:25 <zygoloid> nooodl: you start with a bunch of expressions and some type annotations, and you're trying to work out what types all your expressions have, by propagating information about
11:19:58 <nooodl> flip id can take arguments of a lot of types, though
11:20:18 <zygoloid> nooodl: you do this by applying some rules. for instance, if you see "(expr1) (expr2)", then you know that (expr1 :: a -> b) and (expr2 :: a) and the result is of type b.
11:20:34 <nooodl> right
11:20:36 <osaunders> Perhaps I need to be put out of my miser.
11:20:39 <osaunders> *misery
11:21:20 <nooodl> why's "flipId :: a -> (a -> b) -> b" an incorrect answer?
11:21:24 <zygoloid> nooodl: well, we work with type variables; each time we see 'id', we know its type is "a -> a" (but this is a /fresh/ 'a', not the same as used by other users of id)
11:21:54 <zygoloid> nooodl: apart from the flipId / flip id, that looks correct to me.
11:22:29 <nooodl> well, i just quickly assigned it a name
11:22:50 <nooodl> flipId = flip id. should've said that :)
11:23:45 <Zeiris> Is there any hope in this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28599#a28601
11:23:58 <zygoloid> nooodl: so, given 'flip id', we start with 'flip :: (a -> b -> c) -> b -> a -> c' and 'id :: d -> d'
11:24:25 <zygoloid> nooodl: the function application rule tells us that (a -> b -> c) ~ (d -> d)  (where ~ means 'is the same type as')
11:24:52 <zygoloid> nooodl: therefore a ~ d, and (b -> c) ~ d   (because (->) is right-associative)
11:25:51 <zygoloid> the type of (flip id) is then  b -> a -> c, which we can simplify to  b -> (b -> c) -> c, because a ~ d ~ (b -> c).
11:26:14 <zygoloid> nooodl: ^^ and that's type inference.
11:27:22 <nooodl> whee :)
11:28:58 <roconnor> what is the selection monad transformer?
11:29:15 <roconnor> ( a -> m r) -> m a  ?
11:31:35 <osaunders> OK I have to go. Thank you muake, xygoloid, and jmcarthur. I'll try and think about this some more.
11:35:23 <jmcarthur> selection transformer? i don't know this one
11:35:40 <roconnor> hence my question :)
11:35:56 <roconnor> The selection monad is J r a := (a -> r) -> a
11:36:10 <jmcarthur> i didn't even know that one
11:36:21 <roconnor> It is sad that it is left out of the mtl
11:36:29 <roconnor> and monadlib
11:36:33 <jmcarthur> what is it useful for?
11:36:38 <roconnor> donno
11:36:49 <roconnor> usually used to find things
11:37:08 <roconnor> if r is ordered
11:37:10 <ezyang> Optimal game play, iirc? 
11:37:27 <jmcarthur> @djinn a -> (a -> r) -> a
11:37:27 <lambdabot> f a _ = a
11:37:44 <roconnor> yes, optimal game play is one thing
11:38:01 <roconnor> in this case it is finding the well optimal play
11:38:12 <roconnor> mabye I should say it is useful for optimising things
11:38:18 <jmcarthur> @djinn (a -> r) -> a -> (a -> (b -> (b -> r) -> b)) -> b -> (b -> r) -> b
11:38:18 <lambdabot> f _ a b c d = b a c d
11:38:34 <roconnor> when r is ordered, find an x that maximizes f x
11:38:47 <ezyang> I'm currently putting in runtime checks for developer error, and one of the things I want to do is mention the name of the function that is emitting the error to help people figure out what their naughty call is. 
11:38:58 <roconnor> jmcarthur: that typesig isn't right
11:39:03 <jmcarthur> i thought so
11:39:10 <roconnor> @djinn (a -> r) -> a -> (a -> (b -> r) -> b) -> b -> (b -> r) -> b
11:39:10 <lambdabot> f _ a b c d = b a (\ _ -> d c)
11:39:17 <ezyang> However, the check I'm implementing is buried in some deep helper function that the user is not likely to use. What should I do? 
11:39:20 <jmcarthur> there we go
11:39:22 <roconnor> @djinn ((a -> r) -> a) -> (a -> (b -> r) -> b) -> b -> (b -> r) -> b
11:39:22 <lambdabot> f a b _ c = b (a (\ d -> c (b d c))) c
11:39:29 <roconnor> @djinn ((a -> r) -> a) -> (a -> (b -> r) -> b) -> (b -> r) -> b
11:39:29 <lambdabot> f a b c = b (a (\ d -> c (b d c))) c
11:39:32 <jmcarthur> err
11:39:32 <roconnor> that one
11:39:35 <jmcarthur> okay
11:39:51 <jmcarthur> ah yeah
11:39:59 <jmcarthur> @. pl djinn ((a -> r) -> a) -> (a -> (b -> r) -> b) -> (b -> r) -> b
11:39:59 <lambdabot> f = flip flip id . (ap .) . ap (.) . (. (ap (.) . flip)) . (.)
11:40:46 <roconnor> ezyang: all I know of is there might be some cpp line pragma stuff available maybe
11:40:58 <ezyang> roconnor: Huh. 
11:41:07 <fryguybob> byorgey: I wanted to learn a little about html5 canvas so I wrote a diagrams backend for canvas.
11:41:30 <roconnor> ezyang: macros that will give you the line number and source file name as a string
11:41:52 <ezyang> roconnor: Hmm. 
11:42:19 <aavogt> TH splices can tell  you where they were expanded IIRC
12:03:19 <roconnor> Perhaps an esitmator is J [0,1] a 
12:03:25 <roconnor> estimator
12:12:39 <timcowlishaw> Hey all - I'm having some slightly weird problems trying to install Criterion via cabal - I keep getting the error "cabal: dependencies conflict: ghc-6.12.1 requires filepath ==1.1.0.3 however
12:12:41 <timcowlishaw> filepath-1.1.0.3 was excluded because ghc-6.12.1 requires filepath ==1.1.0.4", but this doens't make a lot of sense to me - how can it depend on two versions of the same package simultaneously?
12:13:07 <mauke> see cabal faq
12:13:28 <timcowlishaw> aah sorry
12:13:31 <timcowlishaw> thank you :-)
12:14:08 <timcowlishaw> googling for the specific error  / package combination obviously yielded nothing - should have known it was something more general
12:17:06 <Gilly> BONUS: In your nice book you have the example let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ], I only wanted to say that these triangles don't necessarily satisfy the triangle inequality.
12:22:40 <djahandarie> Congrats BONUS on the book btw :)
12:37:27 <nlogax> there's a book now? 
12:37:42 <djahandarie> Soon
12:38:03 <djahandarie> I think Gilly was just refering to the online version
12:38:49 <roconnor> nice, hsequence : Monad m => [[x] -> m x] -> m [x]
12:39:44 <Zeiris> jmcarthur, EvanR-work thanks for pointing me in the direction of composable thingamabombs and normalization: the code I have contains lots of boilerplate, but should be able to factor the CSV files into amazingly fine-grained structures. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28599#a28603
12:40:25 <Zeiris> I've hit a speed bump, where the CSV parser I use treats ,,,,,, as a single cell boundary. (It also doesn't work with tab separated files!) However, once that's passed, I expect to see some mad progress.
12:40:36 <roconnor> > sequence (repeat [0,1])
12:40:38 <lambdabot>   *Exception: stack overflow
12:40:41 <jmcarthur> Zeiris: awesome :)
12:40:46 <roconnor> > map head $ sequence (repeat [0,1])
12:40:47 <lambdabot>   *Exception: stack overflow
12:41:00 <roconnor> > head $ map head $ sequence (repeat [0,1])
12:41:01 <lambdabot>   *Exception: stack overflow
12:41:17 <Zeiris> Needless to say, when looking closely at the data, there's a lot of "min value, max value", "name, id", "repeat1 repeat2 repeat3" and etc patterns. With 'em, it should be possible to build something interesting up.
12:42:24 <jkramer> Ahoy
12:42:26 <Gilly> yes, the online version is what I was talking about
12:42:57 <jkramer> I'd like to import the type IOError, but GHC.IOBase says it's deprecated and I should use GHC.IO
12:43:05 <jkramer> However, GHC.IO doesn't export IOError
12:43:50 <roconnor> > sequence (repeat id) 5
12:43:51 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
12:44:10 <Saizan> jkramer: System.IO.Error
12:44:13 <roconnor> > runReader sequence (repeat ask) 5
12:44:13 <lambdabot>   Couldn't match expected type `Control.Monad.Reader.Reader r a'
12:44:14 <lambdabot>         agai...
12:44:16 <roconnor> @type ask
12:44:17 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
12:44:32 <roconnor> > runReader (sequence (repeat ask)) 5
12:44:33 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
12:45:11 <roconnor> > (sequence (repeat (tell 7)))
12:45:12 <lambdabot>   No instance for (GHC.Show.Show (m [()]))
12:45:12 <lambdabot>    arising from a use of `M2940974...
12:45:15 <jkramer> Saizan: That doesn't seem to export IOError neither :(
12:45:18 <roconnor> > runWriter (sequence (repeat (tell 7)))
12:45:19 <lambdabot>   Ambiguous type variable `w' in the constraints:
12:45:19 <lambdabot>    `GHC.Num.Num w'
12:45:19 <lambdabot>      ari...
12:45:36 <jkramer> :i IOError
12:45:41 <roconnor> > runWriter (sequence (repeat (tell [7])))
12:45:42 <lambdabot>   ([(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(...
12:45:51 <roconnor> > execWriter (sequence (repeat (tell [7])))
12:45:52 <lambdabot>   [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,...
12:46:02 <jkramer> Ah, GHC.IO.Exception
12:47:01 <Saizan> jkramer: but it does!
12:47:31 <Saizan> module System.IO.Error (
12:47:33 <Saizan> -- * I\/O errors IOError,   
12:47:48 <Saizan> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/System-IO-Error.html
12:48:19 <interferon> fair description of arrows: they are a generalization of monads that let you perform static analysis on the chain of arrows without running the entire chain?
12:48:34 <jkramer> Saizan: Here it doesn't for some reason.
12:49:05 <jkramer> I'm probably doing something wrong
12:49:43 <Saizan> interferon: if by generalization you mean that every Monad can be used as an Arrow, then yes :)
12:49:56 <interferon> Saizan: that's what i mean :)  basically, a superset of arrows
12:50:43 <interferon> er, superset of monads
12:51:09 <Philonous> interferon: Not all arrows allow static analysis, though. 
12:51:13 <interferon> trying to install HoH and getting errors about not finding the "event" library - is that the same as the "libevent" library?
12:52:37 <Saizan> is it referring to a C lib?
12:53:55 <interferon> Saizan: yep
12:54:00 <interferon> cabal: Missing dependency on a foreign library:
12:54:01 <interferon> * Missing C library: event
12:54:09 <roconnor> > runCont (sequence (repeat (return 6))) id
12:54:13 <lambdabot>   mueval-core: Time limit exceeded
12:54:53 <Saizan> then libevent is probably the right one
12:54:53 <roconnor> > execWriter (sequence (repeat (return ())))
12:54:54 <lambdabot>   ()
12:55:01 <roconnor> > execWriter (sequence (repeat (return 6)))
12:55:02 <lambdabot>   ()
12:55:09 <roconnor> > runWriter (sequence (repeat (return 6)))
12:55:10 <lambdabot>   ([6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6...
12:55:10 <djahandarie> What in the world are you doing roconnor
12:55:23 <roconnor> seeing where sequence works
12:55:41 <Saizan> > runWriter (flip runContT return $ sequence (repeat (return 6)))
12:55:47 <lambdabot>   mueval: ExitFailure 1
12:56:25 <Saizan> > execriter (flip runContT return $ sequence (repeat (return 6)))
12:56:29 <Saizan> > execWriter (flip runContT return $ sequence (repeat (return 6)))
12:56:29 <lambdabot>   Not in scope: `execriter'
12:56:40 <lambdabot>   mueval: ExitFailure 1
13:05:04 <jkramer> I think something is wrong with my ghc installation. I've installed blaze-html and blaze-builder and I could watch cabal install the modules, but when I try to import Blaze.Html.*, the modules can't be found
13:06:36 <Mathnerd314> here's a puzzle: define fst in pointfree style, without using functions that use fst
13:07:12 <copumpkin> Mathnerd314: what can I use?
13:07:26 <copumpkin> :t uncurry const
13:07:30 <lambdabot> forall a b. (a, b) -> a
13:07:36 <Mathnerd314> @src uncurry
13:07:36 <lambdabot> uncurry f p = f (fst p) (snd p)
13:07:45 <Mathnerd314> fst - you can't use it
13:07:52 <copumpkin> pff, it could be defined with a lazy pattern
13:08:23 <blups0r> hi there
13:08:41 <blups0r> is there a way to extract text from a pdf file in haskell
13:09:33 <Mathnerd314> > let fst = let uncurry f p = f (fst p) (snd p) in uncurry const in fst (1,2) -- compumpkin, is this what you mean?
13:09:34 <edwardk> blups0r: i don't off the top of my head know of a haskell specific library for manipulating pdf internals, but you should be able to talk to mupdf or something to get at the text.
13:09:36 <lambdabot>   mueval-core: Time limit exceeded
13:09:37 <mee> blups0r: checkout pandoc
13:09:46 <mee> http://johnmacfarlane.net/pandoc/
13:09:46 <edwardk> mee: oh good call
13:10:03 <copumpkin> I thought there was hpdf or something
13:10:08 <copumpkin> but I've never looked to see what it does
13:10:12 <copumpkin> maybe only writes them?
13:10:31 <copumpkin> Mathnerd314: I meant uncurry f ~(x, y) = f x y
13:10:44 <edwardk> mee: won't work. pandoc doesn't include pdf in its 'read' list
13:10:52 <edwardk> Yes, that too. Pandoc can read markdown and (subsets of) reStructuredText, HTML, and LaTeX, and can write ...
13:10:54 <zygoloid> Mathnerd314: which functions are we allowed? everything in the Prelude?
13:11:13 <mee> edwardk: ah, my mistake.
13:12:37 <Mathnerd314> copumpkin, zygoloid: I think I'll just ban every function not defined in pointfree style or that uses a pointful function
13:12:42 <edwardk> snd . swap -- now you just need swap ;)
13:12:50 <copumpkin> Mathnerd314: lol
13:13:02 <Mathnerd314> pointfree or die :p
13:13:04 <edwardk> Mathnerd314: then you're done. ultimately something has to do the pattern match
13:13:22 <zygoloid> @let fst' :: (a, b) -> a; fst' = head . listify (const True)
13:13:23 <lambdabot>  <local>:3:35:
13:13:23 <lambdabot>      Could not deduce (Data a, Data b) from the context ()
13:13:23 <lambdabot>    ...
13:13:31 <zygoloid> @let fst' :: (Data a, Data b) => (a, b) -> a; fst' = head . listify (const True)
13:13:32 <lambdabot>  Defined.
13:13:39 <zygoloid> > fst' ("Hello", 42)
13:13:40 <lambdabot>   "Hello"
13:13:44 <blups0r> how can i use pandoc in haskell
13:13:46 <edwardk> data isn't pointfree ;)
13:13:54 <edwardk> blups0r: pandoc doesn't read pdfs, it can only write them
13:13:57 <benmachine> > fst' ()
13:13:58 <lambdabot>   Couldn't match expected type `(a, b)' against inferred type `()'
13:14:07 <zygoloid> edwardk: well, i assume compiler-generated code is ok :)
13:14:14 <edwardk> zygoloid: hahaha
13:14:29 <blups0r> but i search for a way to read them
13:14:40 <Mathnerd314> edwardk: what if I'm kind and let you use one, and only one, pointful function (that's not fst)
13:15:02 <edwardk> swap (a,b) = (b,a) -- fst = snd . swap ;)
13:15:05 <copumpkin> lol
13:15:23 <Mathnerd314> @src snd
13:15:23 <lambdabot> snd (_,y) =  y
13:15:33 <Mathnerd314> sorry, edwardk... :p
13:15:38 <edwardk> Mathnerd314: but, let me guess, you won't tell me which function that is
13:15:42 <edwardk> ;)
13:16:00 <copumpkin> we need some sort of thing eventually that will pattern match on the tuple
13:16:09 <copumpkin> at some level
13:16:11 <Mathnerd314> edwardk: you are free to write whatever function you want, so long as it isn't equivalent to fst
13:16:19 * Mathnerd314 thinks
13:16:23 <Mathnerd314> @src (.)
13:16:24 <lambdabot> (f . g) x = f (g x)
13:16:24 <lambdabot> NB: In lambdabot,  (.) = fmap
13:16:31 <copumpkin> Mathnerd314: how about unsafeCoerce?
13:16:43 <Mathnerd314> @src unsafeCoerce
13:16:43 <lambdabot> Source not found. Just try something else.
13:16:48 <benmachine> Mathnerd314: pretty much every pointfree function is defined in terms of pointful ones
13:16:52 <copumpkin> it's pointfree, in terms of a primitive
13:16:54 <copumpkin> unsafeCoerce#
13:17:01 <edwardk> unsafeCoerce calls out to a primop 'pointfree'
13:17:13 <Mathnerd314> hmm, ok...
13:17:32 <copumpkin> I get the impression that isn't what you wanted
13:17:49 <benmachine> why are we doing this again :P
13:17:52 <edwardk> too bad unpackClosure# needs pattern matching to parse the pointers ;)
13:18:03 <copumpkin> but as I said, it needs to pattern match on the tuple eventually
13:18:05 <edwardk> er to parse the unboxed tuple
13:19:19 <dino-> Not sure if this showed up here earlier. Check out new Haddock redesign and take survey: http://www.haskell.org/pipermail/haskell-cafe/2010-August/081394.html
13:21:00 <edwardk> foo :: (a, b) -> a; foo x = x `seq` case unpackClosure# x of (# _, a, _ #) -> unsafeCoerce (indexArray# a 0#) -- then shuffle it around to use a helper and be pointfree in x ;)
13:22:07 <roconnor> edwardk: do you use rankN or rank2 polymorphsism in category-extras?
13:22:23 <edwardk> roconnor: good question.
13:22:27 * copumpkin used rank 3 the other day!
13:22:31 <edwardk> roconnor: rank2 everywhere i can think of
13:22:46 <edwardk> roconnor: but i may accidentally use a rank2 type here or there
13:22:49 <edwardk> er rankn
13:23:02 <roconnor> where do you use rank2?
13:23:04 <roconnor> for example
13:23:11 <roconnor> codensity / density?
13:23:17 <edwardk> yeah that would be a rank 2 type
13:23:32 <roconnor> but isn't (one of them) just an existential?
13:23:37 <edwardk> i also use it for my definition of natural transformations: :~> 
13:23:42 <roconnor> ah
13:23:45 <roconnor> that is a good use
13:23:53 <roconnor> really good illustration of rank2
13:24:01 <edwardk> there are a bunch in the dist laws that make up most of Control.Morphism
13:24:23 <edwardk> type Dist f g = forall a. f (g a) -> g (f a)
13:24:52 <edwardk> the hfunctor machinery may also have some quantification floating around
13:24:54 <copumpkin> Mathnerd314: soooo :P
13:25:06 <edwardk> the shift/reset implementation in the indexed monads
13:26:13 <edwardk> if i put in any of the recursion schemes a la mendler i may dip into rank-n territory
13:27:02 <edwardk> of course limit/colimit are universal/existential
13:27:42 <Saizan> edwardk: btw, the forall is in the wrong place in the type of shift
13:27:52 <edwardk> Saizan: yep =)
13:28:13 <edwardk> Saizan: there was a minor technical issue with placing it in the right place, but for the life of me i can't remember what it was
13:29:24 <Saizan> that you get RankN?:) or that you need to eta expand to make it typecheck, maybe
13:29:46 <edwardk> Saizan: i don't recall what it was honestly
13:30:09 <edwardk> i remember beating my head on it for a few hours, finding some apologia from oleg and moving on
13:30:38 <ezyang> That sounds... familiar. :-) 
13:30:50 <Saizan> in the place it is now it makes the thing less usable than no forall at all, i think
13:30:52 <edwardk> (apologium?)
13:31:02 <edwardk> yeah oleg had none iirc
13:31:09 <copumpkin> edwardk: it's greek
13:31:21 <edwardk> copumpkin: its all greek to me ;)
13:31:24 <copumpkin> :P
13:31:37 <edwardk> etymology: late latin ;)
13:31:50 <edwardk> http://www.merriam-webster.com/dictionary/apologia
13:31:51 <edwardk> =)
13:32:08 <copumpkin> latin, from greek
13:32:48 <copumpkin> pff
13:33:02 <yitz> @wn apologium
13:33:04 <copumpkin> ORIGIN mid 16th cent. (denoting a formal defense against an accusation): from French apologie, or via late Latin from Greek apologia ‘a speech in one's own defense,’ from apo ‘away’ + -logia (see -logy ).
13:33:04 * copumpkin sticks out his tongue
13:33:04 <lambdabot> No match for "apologium".
13:33:23 <killown> ['A'..'F']  give me ABCDEF i think its useless or so? in which case do i will need generate a sequencial string range?
13:33:36 * copumpkin gets back to stuff he should be doing
13:34:17 <edwardk> singular apologia. its one of those cases like virus/viruses which trips people up =)
13:34:34 * Saizan moved the forall and it all compiled fine
13:34:35 <copumpkin> killown: it's a consequence of things not being special syntax
13:34:35 <copumpkin> edwardk: or octopus!
13:34:35 <nooodl> killown checking if a word is lowercase/uppercase
13:34:40 <yitz> or alumni
13:35:00 <roconnor> > ["A".."F"]
13:35:02 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
13:35:02 <lambdabot>    arising from the arithm...
13:35:04 <copumpkin> (plural of octopus, apart from octopuses, is octopodes!)
13:35:17 <roconnor> lame
13:35:19 <nooodl> implementing rot13, too
13:35:47 <copumpkin> roconnor: you could enumerate strings using my enumerable package, and pick out the ones you want :P
13:36:01 <edwardk> > map return ['A'..'F'] :: [String]
13:36:02 <lambdabot>   ["A","B","C","D","E","F"]
13:36:55 <killown> useless, i think
13:37:18 <yitz> > map (:[]) ['A'..'F'] -- the ever popular monkey grin operator
13:37:19 <lambdabot>   ["A","B","C","D","E","F"]
13:37:34 <edwardk> killown: [foo...bar] works for all enumerables, Char is Enumerable, because that way you can use toEnum/fromEnum as 'chr/ord' and use succ/pred to get the next/preceding char
13:37:39 <roconnor> killown: do you think chr and ord are useless?
13:37:44 <copumpkin> killown: as I said, it's a consequence of Char being Enum, which doesn't hurt
13:37:45 <applicative> yitz, damn you, i was about to
13:37:47 <applicative> > (:[]) <$> ['a'..'z']
13:37:48 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
13:37:58 <killown> roconnor no 
13:38:06 <Saizan> copumpkin: cosequence?
13:38:15 <copumpkin> :O
13:38:16 <roconnor> killown: well .. is effectively implemented using chr and ord
13:38:24 <edwardk> killown: you can also define your string using the usual list sugar
13:38:24 <roconnor> generically
13:38:28 <edwardk> > 'a':'b':'c':'d':'e':'f':[]
13:38:29 <lambdabot>   "abcdef"
13:38:55 <edwardk> that strings are lists of chars lets you use all of the list machinery on any string. it is far from useless.
13:38:56 <yitz> > enumFromTo 'A' 'F'
13:38:57 <lambdabot>   "ABCDEF"
13:39:18 <edwardk> > enumFromByTo 'a' 'c' 'z'
13:39:19 <lambdabot>   Not in scope: `enumFromByTo'
13:39:30 <yitz> enumFromThenTo
13:39:35 <edwardk> thanks
13:39:56 <Saizan> cosequence :: w (f a) -> f (w a) ?
13:40:09 <copumpkin> Saizan: zomg
13:41:11 <killown> can anyone give me a example of useful usage?
13:41:27 <copumpkin> > [1..5]
13:41:29 <lambdabot>   [1,2,3,4,5]
13:41:40 <copumpkin> there
13:41:43 <wioux1> isUpper = `elem` ['A'..'Z']
13:41:51 <mauke> killown: generating identifiers
13:41:56 <zygoloid> Mathnerd314: oh, we're allowed unsafeCoerce? well then. data Pair a b = Pair { fst' :: a, snd' :: b }; fst = fst' . unsafeCoerce
13:41:57 <mauke> wioux1: fail
13:42:00 <copumpkin> lol
13:42:23 <copumpkin> zygoloid: pff
13:42:37 <edwardk> heck, if you can unsafeCoerce, why bother with the second arg to Pair ;)
13:42:53 <nooodl> killown: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28604#a28604
13:42:58 <applicative> killown , what are you thinking is useless, exactly?
13:43:07 <wioux1> mauke: why? (assuming roman alphabet)
13:43:10 <sbahra> edwardk, ever look at R?
13:43:12 <nooodl> (add import Data.Char to that, it uses ord and chr
13:43:39 <mauke> wioux1: because 1) that's a syntax error and 2) that's not how isUpper works
13:43:40 <copumpkin> nooodl: granted, using elem on lists is probably a bdad sign
13:44:01 <Mathnerd314> zygoloid: that type definition isn't pointfree :p
13:44:03 <killown> applicative i don't know when i will need use ['foo'..'bar'] for any code. i can't find a useful usage for this thing
13:44:13 <edwardk> killown: i use this one a fair bit actually to generate a supply of variable names
13:44:15 <copumpkin> Mathnerd314: lol
13:44:15 <mauke> killown: 'foo' is a syntax error
13:44:15 <Eduard_Munteanu> Hi.
13:44:33 <edwardk> >  [ [i] | i <- ['a'..'z']] ++ [i : show j | j <- [1..], i <- ['a'..'z'] ]
13:44:34 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
13:44:40 <zygoloid> Mathnerd314: yeah, you have a point. it's hard to extract the element from the object without a pattern match, no matter how you cast it
13:44:55 <sbahra> I guess I'll just see how it performs.
13:45:11 <zygoloid> Mathnerd314: when you said this was a puzzle, did you have a solution in mind? ;)
13:45:14 <edwardk> > drop 20 $ [ [i] | i <- ['a'..'z']] ++ [i : show j | j <- [1..], i <- ['a'..'z'] ]
13:45:15 <lambdabot>   ["u","v","w","x","y","z","a1","b1","c1","d1","e1","f1","g1","h1","i1","j1",...
13:45:26 <wioux1> mauke: forgot parentheses
13:45:31 <nooodl> ooh
13:45:31 <wioux1> @src isUpper
13:45:31 <lambdabot> Source not found. My mind is going. I can feel it.
13:45:43 <mauke> > filter isUpper ['\0' ..]
13:45:43 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ\192\193\194\195\196\197\198\199\200\201\202\203...
13:45:44 <Philonous> > isUpper 'Λ' -- wioux1
13:45:45 <lambdabot>   True
13:45:46 <copumpkin> wioux: it knows about unicode
13:45:57 <mauke> > text $ filter isUpper ['Z' ..]
13:45:58 <lambdabot>   ZÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞĀĂĄĆĈĊČ...
13:46:09 <edwardk> killown: while you may not find it useful, it has found its way into every hoas pretty printer i've ever used =P
13:46:18 <applicative> killown, I don't use it much, it's just pleasing sugar.    I thought there was something it was making hard to do.
13:46:36 <Mathnerd314> zygoloid: I wanted to see if there was anything you could use instead of pattern matching
13:46:36 <killown> hmmm
13:46:39 <zygoloid> Mathnerd314: how about this then: unsafeCoerce . ((+8) :: Addr# -> Addr#) . unsafeCoerce :: (a,b) -> a
13:46:54 * zygoloid suspects that doesn't work, but isn't sure
13:47:03 <nooodl> is there any way to implement rot13 without ord and chr? it feels messy and requires Data.Char
13:47:27 <roconnor> nooodl: you can use fromEnum and toEnum
13:47:30 <edwardk> nooodl: ord/chr are just fromEnum/toEnum
13:47:40 <nooodl> oh hah.
13:47:45 <applicative> succ ?
13:47:53 <applicative> map succ "abc"
13:48:19 <applicative> > map succ "abc"
13:48:20 <edwardk> nooodl: you could build a map ;)
13:48:22 <lambdabot>   "bcd"
13:48:24 <Eduard_Munteanu> You can simply zip the alphabet in any way you want to remap.
13:48:34 <zygoloid> iterate 13 succ :)
13:48:42 <Mathnerd314> zygoloid: I think it's pretty well determined now that nothing except escaping the language and manually addressing the members works
13:48:51 <zygoloid> (if, you know, you don't care about correctness)
13:49:01 <nooodl> iterate 13 doesn't work :(
13:49:12 <zygoloid> iterate succ x !! 13 :)
13:49:17 <nooodl> > iterate succ 'a' !! 13
13:49:18 <lambdabot>   'n'
13:49:19 <nooodl> yeah
13:49:22 <edwardk> you can work with lut = zip letters ((drop 13 letters) ++ (take 13 letters)) where letters = ['a'..'z']
13:49:23 <zygoloid> however
13:49:27 <zygoloid> > iterate succ 'n' !! 13
13:49:28 <lambdabot>   '{'
13:49:38 <nooodl> > iterate pred 'n' !! 13
13:49:39 <lambdabot>   'a'
13:49:43 <burp> no periodic boundary conditions :>
13:49:59 <edwardk> > let letters = ['a'..'z'] in zip letters (drop 13 letters ++ take 13 letters)
13:50:00 <lambdabot>   [('a','n'),('b','o'),('c','p'),('d','q'),('e','r'),('f','s'),('g','t'),('h'...
13:50:20 <nooodl> then what do you do to get items from that list?
13:50:34 <burp> > rot26 "hello world"
13:50:35 <lambdabot>   "hello world"
13:50:37 <b_jonas> > map (\c -> maybe c (\i -> "nopqrstuvwxyzabcdefghijklm" !! i) (elemIndex c "abcdefghijklmnopqrstuvwxyz")) "haskell" -- -> noodl
13:50:38 <edwardk> @type lookup
13:50:38 <lambdabot>   "unfxryy"
13:50:39 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:51:22 <edwardk> > map (\c -> maybe c (\i -> "nopqrstuvwxyzabcdefghijklm" !! i) (elemIndex c "abcdefghijklmnopqrstuvwxyz")) "unfxryy"
13:51:22 <lambdabot>   "haskell"
13:51:31 <nooodl> monads D: let's see if i can make sense of this
13:51:32 <copumpkin> omg crypto
13:51:41 <copumpkin> nooodl: don't approach it like that!
13:51:44 <b_jonas> obviously you'd also need to add uppercase letters
13:51:51 <b_jonas> but yeah, jsut use fromEnum and toEnum
13:52:24 <Saizan> monads? where?
13:52:27 <nooodl> copumpkin: i'd probably use fromEnum and toEnum if i was asked to do this, but the elemIndex solution seems interesting.
13:52:48 <copumpkin> nooodl: oh, I meant monads
13:52:58 <b_jonas> you can use the elemIndex if you want to be APLish, but at least generate the arrays with toEnum instead of typing by hand
13:53:22 <nooodl> > ['A'..'Z']++['a'..'z']
13:53:23 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
13:53:25 <Eduard_Munteanu> Are there actually any APL programmers? :)
13:53:31 <b_jonas> Eduard_Munteanu: yes
13:53:35 <zygoloid> > zipWith fromMaybe <*> map (flip lookup (zip ['a'..'z'] (['n'..'z']++['a'..'m']))) $ "rot13"
13:53:36 <lambdabot>   "ebg13"
13:53:38 <applicative> APL rocks.
13:53:39 <Eduard_Munteanu> Ah, I thought it was a myth :P
13:53:53 <burp> > map isUpper "Hello World" -- save this as height profile, then lower the string, make rot13 and then restore it it :>
13:53:54 <lambdabot>   [True,False,False,False,False,False,True,False,False,False,False]
13:54:03 <b_jonas> Eduard_Munteanu: there are some myths about APL for sure
13:54:09 <zygoloid> @type zipWith fromMaybe <*> map ?f
13:54:10 <lambdabot> forall a. (?f::a -> Maybe a) => [a] -> [a]
13:54:13 <nooodl> apl looks fun to program in
13:54:25 <Eduard_Munteanu> Yeah, using symbols is useful at times.
13:54:32 <b_jonas> nooodl: welcome to the club
13:54:33 <nooodl> i've tried J which is basically ascii apl with funny looking boxes
13:54:35 <edwardk> nooodl: the problem with programming in apl is your programs are always second class citizens
13:54:47 <edwardk> something you write is never as nice as a symbol added by the compiler author
13:54:55 <hpc> > map (toEnum . (+13) . fromEnum) "rot13 of the whole character set"
13:54:56 <lambdabot>   [*Exception: Prelude.Enum.().toEnum: bad argument
13:54:56 <Eduard_Munteanu> Like, using Literate Haskell to write your paper AND have symbols embedded nicely.
13:55:06 <hpc> er
13:55:17 <zygoloid> hpc: need moar type annotashunz
13:55:28 <hpc> > (map (toEnum . (+13) . fromEnum) "rot13 of the whole character set") :: String
13:55:29 <lambdabot>   "\DEL|\129>@-|s-\129ur-\132u|yr-pun\DELnp\129r\DEL-\128r\129"
13:55:30 <b_jonas> Eduard_Munteanu: J does help some of that. you don't get to name stuff as symbols, but at least you can apply most higher-order operations (like map) to them
13:55:34 <edwardk> zygoloid: for a moment i thought i was running the kata compiler ;)
13:55:35 <b_jonas> um
13:55:41 <b_jonas> Eduard_Munteanu: that was for you
13:55:44 <b_jonas> argh
13:55:46 <b_jonas> doesn't work
13:55:48 <zygoloid> edwardk: lolcat errors? awesome
13:55:50 <b_jonas> edwardk: that was for you
13:55:54 <b_jonas> damn you, tab
13:56:05 <Eduard_Munteanu> Heh.
13:56:14 <zygoloid> b_jonas: gets you once, more fool it. gets you twice...
13:56:18 <edwardk> zygoloid: you can set your locale to en@lolcat and it'll localize to them
13:56:25 <zygoloid> hahaha
13:56:28 <edwardk> gotta run
13:57:10 <BMeph> > []++map (toEnum . (+13) . fromEnum) "rot13 of the whole character set"
13:57:12 <lambdabot>   [*Exception: Prelude.Enum.().toEnum: bad argument
13:57:35 <b_jonas> BMeph: you don't except that to work, do you?
13:57:45 <BMeph> Oops, not specific enough...
13:57:50 <b_jonas> that's not real rot13 I mean
13:57:50 <BMeph> > ""++map (toEnum . (+13) . fromEnum) "rot13 of the whole character set"
13:57:51 <lambdabot>   "\DEL|\129>@-|s-\129ur-\132u|yr-pun\DELnp\129r\DEL-\128r\129"
13:58:05 <BMeph> Yeeeeeeesssssssssssssss...... >;)
13:58:39 <Eduard_Munteanu> :t unzip
13:58:40 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
13:58:52 <nooodl> > map (\x -> toEnum $ (fromEnum x - 52) `mod` 26 + 65 :: Char) "ABCXYZ"
13:58:53 <lambdabot>   "NOPKLM"
13:59:13 <ppavelV6> hi everybody
13:59:20 <nooodl> hi there
13:59:38 <BMeph> "Fool me once, shame on you. Fool me twice,...watch it! I'm Huge!" -- Minsc
14:00:12 <ppavelV6> I'm reading Colin Taylor's thesis about fudges. Does anyone aware about development in this area? anything on hackage maybe?
14:00:26 <ppavelV6> s/fudges/fudgets
14:00:37 <killown> thanks for prove my point, ['use'..'less']
14:00:48 <copumpkin> o.O
14:00:51 * copumpkin gives up
14:01:07 <ezyang> ppavelV6: fudges sounds tasty :-) 
14:01:08 <Eduard_Munteanu> I thought Tom Cruise was packing fudge :P
14:01:18 * ezyang hasn't read the thesis. 
14:01:42 <ppavelV6> ezyang:  an approach to functional gui components
14:01:50 <BMeph> killown: ['0'..'9']++['A'..'F']
14:02:07 <copumpkin> Eduard_Munteanu: that sounds like a fun job
14:02:19 <BMeph> killown: But seriously, if it's so useless to you,...don't use it! :)
14:02:20 <yitz> > let rot32SortOf = map (chr . xor 31 . ord) in rot32SortOf "Hello there."
14:02:22 <lambdabot>   "Wzssp?kwzmz1"
14:02:23 <copumpkin> I wonder what it must be like to work at a fudge factory i
14:02:46 <Eduard_Munteanu> Must be yummy :)
14:02:52 <yitz> copumpkin: oh i've worked at software companies like that before
14:02:55 <nooodl> killown: you can use them for checking character cases, rot13ing, pretty printing, and everything, but still they're useless? huh
14:03:57 <killown> hmm
14:04:12 * BMeph uses someone else's nooodl... ;)
14:04:38 <yitz> copumpkin: they asked us fudge the results all the time
14:04:43 <copumpkin> :O
14:04:48 <applicative> > map (\x -> [1..x]) [1..5]
14:04:49 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
14:04:58 <copumpkin> yitz: were you in the packaging department?
14:05:11 <applicative> hmm, can we prove to killown that [n..m] is turing complete...?
14:05:42 <nooodl> > tail $ inits [1..5]
14:05:43 <yitz> copumpkin: no, i had to clean up the floor afterwards. didn't last too long.
14:05:43 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
14:05:49 <copumpkin> ah :P
14:06:21 <nooodl> applicative: hmm :) what's the simplest way of doing that?
14:06:46 <yitz> nooodl: step 1 - goedel number it.
14:07:05 <copumpkin> > filter (not . null) . (tails <=< inits) $ "supercalifragilisticexpialidocious"
14:07:06 <lambdabot>   ["s","su","u","sup","up","p","supe","upe","pe","e","super","uper","per","er...
14:07:13 <nooodl> i've read something about NAND gate --> OR/AND gate using NAND logic --> Conway's Game of Life --> turing completeness
14:07:17 <b_jonas> applicative: easy, just define a special instance
14:07:41 <Eduard_Munteanu> What's that, a reversed Kleisli arrow?
14:07:46 * applicative grants that this would be a pretty weak argument for the utility of "[ .. ]"
14:07:49 <Eduard_Munteanu> @src <=<
14:07:49 <lambdabot> Source not found. Are you on drugs?
14:07:56 <Eduard_Munteanu> :t <=<
14:07:57 <lambdabot> parse error on input `<=<'
14:07:59 <Eduard_Munteanu> :t (<=<)
14:08:00 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:08:00 <yitz> nooodl: winning ways for your mathematical plays. conway's book. (2 co-authors)
14:08:13 <copumpkin> Eduard_Munteanu: kleisli composition!
14:08:20 <applicative> Eduard_Munteanu, what part of "reversed" and "Kleisli" and "arrow" don't you understand?
14:08:24 * BMeph wonders what "NAND to Tetris" would be like using Implication gates instead... :)
14:09:09 <Eduard_Munteanu> Ah, right composition it is.
14:09:29 <Eduard_Munteanu> :t (>=>)
14:09:29 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
14:10:05 <yitz> nooodl: here it is. berlekamp, conway, and guy. http://en.wikipedia.org/wiki/Winning_Ways_for_your_Mathematical_Plays
14:10:45 <EvanR-work> was this just answered or... what use is >=>
14:10:55 <nooodl> that looks interesting
14:11:19 <killown> do you guys still trying get the usefulness of  ['a'..'c']?
14:11:45 <b_jonas> killown: what, instead of "abc"?
14:12:17 <killown>  "abc" for what?
14:12:50 <b_jonas> > ['a'..'c']
14:12:50 <lambdabot>   "abc"
14:13:26 <applicative> killown, I think we've just gone slightly mad thinking how wonderful it is...
14:13:45 <killown> b_jonas, -.-
14:13:58 <applicative> > map (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) "hahah"
14:13:59 <lambdabot>   Couldn't match expected type `[a] -> [c]'
14:13:59 <lambdabot>         against inferred type `[a...
14:14:04 <applicative> rrrrr
14:14:53 <b_jonas> night
14:14:56 <zygoloid> > map ((:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[])) "hahah"
14:14:57 <lambdabot>   ["h","a","h","a","h"]
14:15:15 <Deewiant> > map (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) $ "hahah"
14:15:16 <lambdabot>   ["h","a","h","a","h"]
14:15:44 <zygoloid> > (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) $ "hahah"
14:15:45 <lambdabot>   ["hahah"]
14:16:37 <EvanR-work> oh my god haskell demons!
14:16:42 <applicative> > concatMap (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) $ "haha"
14:16:42 <lambdabot>   "haha"
14:16:47 <EvanR-work> its like a scnee from ghost busters
14:17:03 * hackagebot elerea 2.1.0 - A minimalistic FRP library  http://hackage.haskell.org/package/elerea-2.1.0 (GergelyPatai)
14:17:28 <killown> applicative, you should agree to me about the ['use'..'less']
14:17:50 <applicative> killown, I grant that the (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) >=> (:[]) operator is useless.  
14:18:23 <zygoloid> i disagree with that
14:18:28 <applicative> killown, but I intend to write a {-# RULE  to keep the compiler from taking it seriously....
14:18:33 <zygoloid> that's return in the [] monad :)
14:19:07 <applicative> zygloid I wouldn't diss (:[])
14:19:17 <nooodl> it'll eat you if you diss it
14:19:37 <copumpkin> lol, http://snapplr.com/jhm1
14:20:08 <killown> thanks guys for prove my points, really thanks
14:20:14 <killown> point*
14:20:23 <copumpkin> lol
14:20:32 <copumpkin> killown: you're starting to feel a little ***llish
14:20:33 <nooodl> so, thinking something is useless and asking what it's used for, that i can understand
14:20:51 <nooodl> but then going all "just agree with me, you proved my point" afterwards?
14:20:53 <nooodl> you're a troll
14:21:10 <killown> noj, i am not
14:21:19 <zygoloid> > reverse . sort . drop 11 $ "reverse . sort"
14:21:20 <lambdabot>   "tro"
14:21:22 <mauke> killown: what is your quest?
14:21:40 <copumpkin> killown: you completely ignored everything we told you and keep repeating your own, fairly controversial, conclusion
14:21:41 <zygoloid> @faq can haskell work out what copumpkin means by *** ?
14:21:41 <lambdabot> The answer is: Yes! Haskell can do that.
14:21:59 <copumpkin> killown: either way, it doesn't contribute anything
14:22:19 <killown> i just think ['a'..'c'] thats no make sense 
14:22:35 <zygoloid> killown: why not?
14:22:40 <copumpkin> we've been over this a thousand times
14:22:43 <copumpkin> it's a waste of time
14:22:46 <copumpkin> let's just drop it
14:23:00 <zygoloid> > let letters = filter (`elem` ['a'..'z']) in letters "h149tvj019"
14:23:01 <lambdabot>   "htvj"
14:23:02 <applicative> killown, but "the letters from 'a' to 'c'" does make sense?
14:23:57 <Eduard_Munteanu> ['ø'..'»']
14:24:01 <Eduard_Munteanu> > ['ø'..'»']
14:24:02 <applicative> copumpkin, do both operators get rendered >=> and <=< ?  --Much deeper question
14:24:02 <lambdabot>   ""
14:24:05 <zygoloid> > [(a,b,c) | a <- [1..10], b <- [1..10], c <- [1..100], a^2 + b^2 == c^2]
14:24:06 <lambdabot>   [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
14:24:14 <Eduard_Munteanu> > ['»'..'ø']
14:24:14 <lambdabot>   "\187\188\189\190\191\192\193\194\195\196\197\198\199\200\201\202\203\204\2...
14:24:41 <mauke> > text ['»'..'ø']
14:24:42 <lambdabot>   »¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞß...
14:24:52 <Eduard_Munteanu> Ah.
14:25:27 <mauke> @hoogle [Set] -> Set
14:25:27 <lambdabot> Did you mean: [Set a] -> Set a /count=20
14:25:27 <lambdabot> Prelude head :: [a] -> a
14:25:27 <lambdabot> Prelude last :: [a] -> a
14:25:36 <mauke> @hoogle [Set a] -> Set a
14:25:36 <lambdabot> Data.Set unions :: Ord a => [Set a] -> Set a
14:25:36 <lambdabot> Data.Set deleteMax :: Set a -> Set a
14:25:36 <lambdabot> Data.Set deleteMin :: Set a -> Set a
14:28:08 <kyagrd> @t text
14:28:08 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:28:13 <kyagrd> @type text
14:28:14 <lambdabot> String -> Doc
14:29:52 <kyagrd> We would need WString -> WDoc or something?
14:30:19 <applicative> > text "haha" <> text "hoho"
14:30:20 <lambdabot>   hahahoho
14:30:36 <kyagrd> something should be done for libraries for unicode and other charsets
14:31:39 <c_wraith> to the funny farm?
14:34:39 <applicative> > vcat [(text "haha") , (text "hoho")] -- didn't know she could pretty print.
14:34:40 <lambdabot>   haha
14:34:40 <lambdabot>  hoho
14:37:05 <yitz> > (text.ap(++)show)"(text.ap(++)show)"
14:37:07 <lambdabot>   (text.ap(++)show)"(text.ap(++)show)"
14:37:56 <mauke> > ""
14:37:57 <lambdabot>   ""
14:38:09 <yitz> > ()
14:38:11 <lambdabot>   ()
14:38:28 <yitz> but those aren't quines, so they're less fun
14:38:31 <mauke> > 0
14:38:32 <lambdabot>   0
14:38:41 <mauke> how are they not quines?
14:39:29 <yitz> well not the classical kind - a function applies to a picture of itself
14:40:56 <yitz> mauke: define a language in which the empty program is valid and prints nothing.
14:41:04 <yitz> >
14:41:14 <mauke> perl
14:41:29 <yitz> m4
14:41:37 <mauke> python, ruby, javascript, sh, ploki, H9Q+
14:41:56 <yitz> but again, those aren't interesting quines
14:42:17 <dancor> (touch a.pl; perl a.pl) works but (touch a; perl a) is made about ;
14:42:23 <dancor> s/made/mad
14:42:33 <mauke> huh?
14:42:44 <dancor> oh, i messed up.
14:42:48 <mauke> perl /dev/null
14:42:53 <dancor> it was state.. a already existed
14:43:06 <yitz> haha
14:44:16 <applicative> > vcat $ text . (:[]) <$> ['a'..'z']
14:44:17 <lambdabot>   a
14:44:17 <lambdabot>  b
14:44:17 <lambdabot>  c
14:44:17 <lambdabot>  d
14:44:17 <lambdabot>  e
14:44:18 <lambdabot> [21 @more lines]
14:44:46 <yitz> @more
14:44:46 <lambdabot>  f
14:44:46 <lambdabot>  g
14:44:47 <lambdabot>  h
14:44:47 <lambdabot>  i
14:44:47 <lambdabot>  j
14:44:48 <lambdabot> [16 @more lines]
14:44:59 <dancor> @src vcat
14:44:59 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:45:43 <applicative> @hoogle vcat
14:45:43 <lambdabot> Text.PrettyPrint.HughesPJ vcat :: [Doc] -> Doc
14:45:43 <lambdabot> Language.Haskell.TH.PprLib vcat :: [Doc] -> Doc
14:48:06 <applicative> I didn't realize, Text.PrettyPrint.HughesPJ has special implementation in GHCi (and thus lambdabot)
14:50:08 <Philonous> How do I use monadic in marshallers in c2hs? "myMarshaller* `myType'" produces "myMarshaller x $ \x' -> ..." instead of "myMarshaller x >>= \x' -> ... " ($ instead of >>= ) Is that a bug or am I doing something wrong?
14:50:10 <applicative> > render $ vcat $ text . (:[]) <$> ['a'..'z']
14:50:11 <lambdabot>   "a\nb\nc\nd\ne\nf\ng\nh\ni\nj\nk\nl\nm\nn\no\np\nq\nr\ns\nt\nu\nv\nw\nx\ny\...
14:53:19 <hpc> :t vcat
14:53:20 <lambdabot> [Doc] -> Doc
14:53:46 <hpc> @hoogle Doc
14:53:46 <lambdabot> Text.PrettyPrint.HughesPJ data Doc
14:53:46 <lambdabot> Language.Haskell.TH.PprLib type Doc = PprM Doc
14:53:46 <lambdabot> System.Directory getUserDocumentsDirectory :: IO FilePath
14:55:33 <Philonous> @seen dcoutts
14:55:34 <lambdabot> Unknown command, try @list
14:55:34 <preflex>  dcoutts was last seen on #haskell 6 days, 4 hours, 47 minutes and 22 seconds ago, saying: Nibble: but if you did sudo cabal install, then that would install things as root in your home dir, which is a bad thing
15:02:57 <EvanR-work> is there some already written way to prepend a finite list to a stream and get a stream?
15:03:27 <EvanR-work> ? :: [a] -> Stream a -> Stream a
15:03:43 <EvanR-work> :t (++)
15:03:44 <lambdabot> forall m. (Monoid m) => m -> m -> m
15:03:57 <EvanR-work> :t Prelude.(++)
15:03:58 <lambdabot> Not in scope: data constructor `Prelude'
15:04:43 <mauke> what's a stream?
15:04:53 <EvanR-work> Cons a (Stream a)
15:05:05 <mauke> how is that different from a list?
15:05:11 <EvanR-work> theres no empty Stream
15:05:43 <applicative> why not fold the cons for Streams over the list
15:05:54 <mauke> :t foldr Cons
15:05:55 <lambdabot>     Couldn't match expected type `a -> b -> b'
15:05:55 <lambdabot>            against inferred type `Keyword'
15:05:55 <lambdabot>     In the first argument of `foldr', namely `Cons'
15:05:59 <EvanR-work> http://hackage.haskell.org/package/Stream-0.4.1
15:06:18 <EvanR-work> applicative: wouldnt that reverse the list?
15:07:47 <mauke> *> :t flip $ foldr Cons
15:07:48 <mauke> flip $ foldr Cons :: [a] -> Stream a -> Stream a
15:08:18 <EvanR-work> is that going to build a big thunk
15:09:26 <EvanR-work> maybe Stream isnt worth it
15:09:43 <byorgey> fryguybob: awesome!
15:10:04 <fryguybob> byorgey: I'm working on putting it on patch-tag now, just got an account.
15:10:17 <mtnviewmark> Now I have an image of "The Thunk" as a giant green mutant...
15:10:18 <byorgey> cool
15:10:35 <EvanR-work> THUNK SMASH
15:10:57 <EvanR-work> YOUR STACK
15:11:12 <mtnviewmark> THUNK HUNGRY - THUNK EAT MEMORY
15:12:10 <EvanR-work> anyway i can write a function for it...
15:13:04 <EvanR-work> f [] s = s, f (x:xs) s = Cons x (f xs s)
15:14:07 <mauke> @src foldr
15:14:08 <lambdabot> foldr f z []     = z
15:14:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:14:14 <bos> who's going to ICFP?
15:14:20 <mauke> surprise, that's foldr Cons
15:14:24 <EvanR-work> :o
15:14:42 <EvanR-work> maybe i was mixing it up with foldl
15:15:10 <azaq23> :t Cons
15:15:11 <lambdabot> Keyword
15:15:20 <EvanR-work> lol
15:15:31 <EvanR-work> @hoogle Cons
15:15:31 <lambdabot> Data.ByteString cons :: Word8 -> ByteString -> ByteString
15:15:31 <lambdabot> Data.ByteString.Char8 cons :: Char -> ByteString -> ByteString
15:15:31 <lambdabot> Data.ByteString.Lazy cons :: Word8 -> ByteString -> ByteString
15:15:45 <azaq23> @type (:)
15:15:47 <lambdabot> forall a. a -> [a] -> [a]
15:16:56 <azaq23> > foldl (flip (:)) [] [1 .. 10]
15:16:57 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
15:17:22 <EvanR-work> @src reverse
15:17:22 <lambdabot> reverse = foldl (flip (:)) []
15:19:54 <greap> I'm trying to use 'system' with snap, but I'm getting the error "Could not find module `System.Cmd'" I thought this was a standard library. Any Idea why this could be happening?
15:21:04 <tkahn6_> mun i got it working
15:21:17 <tkahn6_> ⊅
15:21:18 <c_wraith> greap: does it say it's a member of a hidden package?
15:21:43 <c_wraith> greap: If so, you need to list it in your project's .cabal file as a build dependency
15:24:15 <mun> tkahn6_, oh?
15:24:24 <mun> tkahn6_, how did you get it to work?
15:30:05 <tkahn6_> i added that file to .XCompose
15:30:08 <tkahn6_> i removed the first line
15:30:37 <tkahn6_> in my .gnomerc file
15:30:47 <tkahn6_> i have export GTK_IM_MODULE="xim"
15:30:53 <tkahn6_> and then i restarted X
15:31:03 <tkahn6_> ⊅
15:31:05 <tkahn6_> ⊃
15:32:07 <mun> tkahn6_, you removed the include line?
15:32:19 <mun> tkahn6_, so far I've been setting that env variable in .bashrc. i'll give it a try.
15:32:53 <tkahn6_> k
15:33:01 <tkahn6_> yeah i removed the include line
15:39:16 <lodi> Hello all.  I'm trying to write a MonadCont instance for a transformer, and I'm not sure why this is failing to typecheck: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28607#a28609
15:39:47 <lodi> any help would be appreciated; this is getting a bit abstract for me...
15:41:02 <mun> tkahn6_, did you add export GTK_IM_MODULE=xim or export GTK_IM_MODULE=xim& ?
15:41:13 <mun> what value do you get if you echo $GTK_IM_MODULE?
15:42:50 <greap> c_wraith: That was it :)
15:55:21 <syntaxglitch> I really wish I knew why I got a pile of upvotes on StackOverflow today for an answer from two and a half weeks ago
15:56:27 <bnonym> syntaxglitch: reddit ofc
15:58:30 <syntaxglitch> bnonym, I figured a link from somewhere but I couldn't figure out where from :( I don't spend a lot of time on reddit so that wouldn't surprise me
16:00:48 <robryk> lodi: the function has wrong type
16:00:56 <robryk> i don't quite understand how is it supposed to work
16:01:04 <robryk> but if i just define such a function
16:01:47 <robryk> then the most-deeply-nested argument (one whose type is called a in definition of callCC) is that strange Either
16:03:00 <robryk> i would guess that the problem isn't trivial
16:03:18 <robryk> or not.. 
16:03:22 <lodi> robryk: which function do you mean?
16:03:50 <robryk> are you sure it should be (\a -> Coroutine $ c a) ?
16:04:18 <robryk> this requires c to take the inside of coroutine as argument
16:04:28 <robryk> where it should be taking the value returned
16:05:51 <robryk> you never use any propierties of s in your function
16:06:20 <Gracenotes> wooo... got a 967-line module, 967 and counting
16:06:41 <Gracenotes> (counting /down/, eventually)
16:06:49 <ezyang> Gettin close to refactortime! 
16:07:14 <Gracenotes> there's no time like refactortime
16:07:35 <lodi> well I'm not sure... but I think it should work: c :: a -> m b, so I give it the 'a', wrap it into a Coroutine so it becomes 't m b', and then pass that to f, which is expecting a -> t m b
16:08:12 <robryk> you don't give it an a
16:08:26 <robryk> you give it an Either ( s ..., a)
16:08:30 <lodi> giving me back a 't m a', from which resume will extract an 'm a', which completes the signature of the callCC lambda: (a -> m b) -> m a
16:09:23 <copumpkin> preflex: seen augustss
16:09:24 <preflex>  augustss was last seen on #haskell 19 days, 2 hours, 51 minutes and 27 seconds ago, saying: I've not been on in a while
16:09:38 <copumpkin> anyone know where I can find cayenne? his site seems to be offline fairly permanently
16:10:30 <lodi> what do you mean I don't give it an 'a'?
16:11:38 <robryk> the type of variable a is that Either from the error
16:11:42 <robryk> it is not the monad parameter
16:14:15 <Saizan> lodi: have you looked at the MonadCont instance for ErrorT ? it should help getting something that typechecks at least, not sure if the runtime behaviour would make sense tough
16:16:53 <lodi> Saizan: doh... I should have tried that first... I was going off the code for List/State/etc... I just have to replace the inner 'a' with 'Right a'
16:16:56 <lodi> makes sense...
16:17:03 <lodi> that extracts the monad parameter
16:17:22 <dibblego> is there any way to not have to write (Monad m, Functor m) => ?
16:17:43 <copumpkin> use liftM instead of fmap
16:17:46 <lodi> well it compiles anyway... now to understand it...
16:17:48 <Heffalump> class (Monad m, Functor m) => FMonad m
16:17:58 <dibblego> ok, let me rephrase that
16:18:04 <dibblego> is there any way to not have to write (Monad m, Pointed m) => ?
16:18:17 <copumpkin> use return instead of point :P
16:18:22 <dibblego> I knew you'd say that
16:18:25 <copumpkin> sorry
16:18:34 <copumpkin> no class synonyms though
16:18:41 <dibblego> that's ok, I wasn't expecting a better answer
16:18:46 <dibblego> ok cheers
16:19:07 <Saizan> class synonyms can be done with Overlapping + Undecidable instances
16:19:21 <copumpkin> yeah, but that's fugly :P
16:19:34 <aavogt> lots of other things can be done with those extensions though
16:19:35 <dibblego> sounds pretty nasty
16:19:48 <copumpkin> I wish we could turn on stuff like that for restricted parts of the program
16:20:07 <BMeph> Is there a proposal for type unions in the works?
16:20:10 <dibblego> like a source file pragma?
16:20:13 * BMeph looks...
16:20:52 <Saizan> it's quite clean actually, "class (Monad m, Pointed m) => PMonad m; instance (Monad m, Pointed m) => PMonad m;"
16:20:56 <copumpkin> BMeph: type unions? like the polymorphic variants?
16:21:09 <Saizan> maybe Overlapping is not even needed.
16:21:51 <Saizan> the only drawback is that PMonad won't be ever inferred, but the problem was to make explicit signature shorter, no?
16:21:59 <Saizan> *ever be
16:22:50 <BMeph> copumpkin: ... <nods> yes.
16:23:01 <copumpkin> BMeph: don't think anyone's proposed it, nope
16:23:14 <JoshTriplett> I need to send emails from Haskell.  I found a pile of SMTP libraries on Hackage, but I wondered what I ought to use.  Any recommendations, or experience?
16:24:16 <dibblego> no instances of Pointed for IO, WTF1?
16:24:58 * hackagebot indents 0.3.0 - indentation sensitive parser-combinators for parsec  http://hackage.haskell.org/package/indents-0.3.0 (SamAnklesaria)
16:25:16 * dibblego prays to the orphaned instances fairies that he doesn't have to write it
16:27:45 <ddarius> dibblego: Pointed in category-extras or what?
16:27:53 <dibblego> yes Control.Functor.Pointed
16:34:22 <dancor> what are some uses of Pointed
16:37:15 <dolio> Any applicative or monad.
16:37:20 <dibblego> when you just need a -> f a but not anything more
16:37:42 <copumpkin> what are some exampels of pointed functors that are not applicative?
16:37:54 <dolio> I don't have any.
16:38:07 <copumpkin> I imagine the pointed law says that point (f a) == fmap f (point a) ?
16:38:26 <dolio> That'd be reasonable.
16:38:44 <ddarius> Well, that's a free theorem so...
16:38:47 <dolio> There might be pointed categories in category theory that don't really show up in Haskell.
16:38:49 <Saizan> ((,) a) when a is not a Monoid?
16:38:51 <ddarius> Nevermind, I'm wrong.
16:39:33 <dolio> @free point :: a -> F a
16:39:33 <Gracenotes> Saizan: that doesn't look pointy to me
16:39:33 <lambdabot> $map_F f . point = point . f
16:39:41 <ddarius> I imagine there are a variety of pointed comonads that aren't monads/applicatives.
16:39:56 <Saizan> Gracenotes: oh, right.
16:40:00 <dolio> Apparently that is a free theorem.
16:40:15 <c_wraith> Gracenotes, it can be pointy for any a that has a distinguished value.  Even if it's not a monoid.
16:41:41 <Gracenotes> just assumed an unqualified a (qualification by monoid isn't uncommon here..)
16:44:04 <ddarius> dolio: Well, it's a free theorem, what I was more worried about is whether point is appropriately parametric, but I guess it is in the necessary way, so I'm wrong about being wrong.
16:44:29 <dolio> But are you wrong about being wrong about being wrong?
16:44:32 <dolio> No, I guess not.
16:45:03 <ddarius> Well we've established my unreliability in my determinations of my own inaccuracy.
16:46:45 <steshaw>  /quit
16:46:49 <steshaw> \quit
16:46:56 <ddarius> No quit for you.
16:47:47 <zygoloid> careless
17:01:10 <syntaxglitch> Anyone know of a pure library for working with 2D geometry, e.g., set operations on arbitrary polygons, computing areas, centroids, etc.? Maybe my Hackage-fu is weak but I can't find anything
17:01:36 <osaunders> OK, I know (++) :: [a] -> [a] -> [a] and flip (++) :: [a] -> [a] -> [a] but flip started out as (a -> b -> c) -> b -> a -> c. What were the intermediary steps?
17:01:45 <copumpkin> syntaxglitch: I'd like one, but I don't know of one, nope :(
17:01:58 <syntaxglitch> copumpkin, so it's not just me? :(
17:02:15 <copumpkin> syntaxglitch: I'd say write a binding for CGAL but it's all C++ templates
17:02:23 <copumpkin> which we can't really bind to nicely
17:02:38 <syntaxglitch> there's packages to do simple stuff, and some FFI bindings that are impure functions everywhere
17:02:57 <copumpkin> osaunders: so you want to unify [a] -> [a] -> [a] with a -> b -> c
17:03:00 <copumpkin> osaunders: see that?
17:03:13 <osaunders> copumpkin: Yeah.
17:03:26 <copumpkin> or let's say with x -> y -> z
17:03:32 <copumpkin> it means x = y = z = [a]
17:03:57 <syntaxglitch> What I really want is something with a lovely API like graphics-drawingcombinators, for a 2D equivalent of constructive solid geometry (is there a term for that?)
17:04:10 <copumpkin> syntaxglitch: constructive area geometry, I've heard
17:04:17 <osaunders> Why does it mean x = y = z = [a]?
17:04:19 <copumpkin> but not sure it's very common
17:04:25 <etpace> mmm seems running my haskell program gives me a segfault
17:04:29 <etpace> this will be fun
17:04:30 <copumpkin> osaunders: x, y, and z are all equal to [a]
17:04:45 <osaunders> Oh, yes, OK.
17:05:12 <osaunders> a = 1st param of (++), b = 2nd param of (++), c = return type of (++)
17:05:15 <copumpkin> which forces the y -> x -> z remaining part of the flip type signature to be [a] -> [a] -> [a]
17:05:20 <syntaxglitch> copumpkin, it clearly isn't, and I've also seen "planar" but I guess area makes more sense
17:05:20 <copumpkin> yeah
17:05:46 <copumpkin> syntaxglitch: I wish there were more out there on it :) 
17:05:59 * copumpkin elects syntaxglitch to write a beautiful pure haskell geometry library
17:06:20 <syntaxglitch> I'm honestly actually really, really surprised that the library I was hoping for doesn't exist, it seems like the sort of thing that would fit perfectly in Haskell
17:06:40 <syntaxglitch> copumpkin, I might just do that :P
17:06:49 <copumpkin> syntaxglitch: I'd love that
17:07:01 <copumpkin> syntaxglitch: lots of type-level stuff kthx :P
17:07:09 <syntaxglitch> I'm toying with graphics stuff so right now I'm faking some stuff and/or bolting ugly hacks onto drawingcombinators
17:07:16 * ddarius should consider how such a library using the conformal geometric algebra would turn out.
17:07:39 <syntaxglitch> copumpkin, okay how about analog literals to construct primitive shapes :P
17:08:10 <osaunders> copumpkin: OK, thanks I understand that now :-) I think I can do flip id now. :-)
17:08:29 <copumpkin> osaunders: once you get the hang of unification and types it all makes loads of sense
17:08:32 <copumpkin> and becomes second nature
17:11:04 <syntaxglitch> copumpkin, have you used graphics-drawingcombinators at all? I'm thinking a constructive area geometry library that had a similar concept to Image's type parameter would be useful
17:11:15 <copumpkin> I haven't :/
17:11:40 * copumpkin has done very little graphics work at all in ages :(
17:12:54 <osaunders> copumpkin: I made the mistake of thinking this could be done with type signatures only. No, you need to see the src as well.
17:13:09 <copumpkin> osaunders: no, it can be done with type signatures only
17:13:26 <copumpkin> ignoring silly definitions
17:13:31 * hackagebot Semigroup 0.0.5 - A semigroup  http://hackage.haskell.org/package/Semigroup-0.0.5 (TonyMorris)
17:13:44 <osaunders> copumpkin: Not for me, not yet.
17:14:06 <syntaxglitch> copumpkin, basically the Image type it uses is an Applicative instance with semantics associating the type variable to points in the image
17:14:35 <zygoloid> suppose i have a "t1 m a" and i want a "t1 (t2 m) a" where MonadTrans t1, MonadTrans t2, Monad m. how can i get that?
17:15:02 <aavogt> @type lift
17:15:03 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
17:15:30 <aavogt> @type lift . lift
17:15:30 <lambdabot> forall a (t :: (* -> *) -> * -> *) (m :: * -> *) (t1 :: (* -> *) -> * -> *). (MonadTrans t, Monad (t1 m), MonadTrans t1, Monad m) => m a -> t (t1 m) a
17:16:08 <aavogt> zygoloid: lift into t2 first
17:16:31 <zygoloid> aavogt: that'd give me a t2 (t1 m) a
17:18:00 <zygoloid> i vaguely recall commuting monad transformers isn't possible in general :(
17:18:17 <aavogt> zygoloid: I don't think there's a class for functions like  mapBlahT
17:18:31 <syntaxglitch> copumpkin, and composing images combines the associated data as well, making a very tidy way of relating the final image to something meaningful to the program
17:18:39 <aavogt> if you want to turn   m into   t2 m
17:18:47 <copumpkin> syntaxglitch: neat
17:18:52 <copumpkin> looking at it now
17:20:07 <syntaxglitch> it's definitely oriented around images though, but I love the conceptual structure and want to do the same thing with geometry
17:20:38 <zygoloid> aavogt: ok, i've used a rank-2 type to ensure that the underlying code can't know what the 'm' is in the t1 m a. then i set m = t1 m'. :)
17:22:26 <krey> hello, I'm trying to parse strings with parentheses into tip labeled (string) trees, how would you do it?
17:22:27 * syntaxglitch would also like a way to define continuous functions over the area and compute things like integrals but that gets into really hairy math pretty fast
17:22:28 <aavogt> much like this paper http://www.cs.kuleuven.be/~toms/Research/papers/aosd2010.pdf
17:22:40 <osaunders> @pl \x y z -> x + y + z
17:22:40 <lambdabot> ((+) .) . (+)
17:22:45 <aavogt> zygoloid: ^^
17:22:59 <Pseudonym> @pl \x y z -> x + (y + z)
17:22:59 <lambdabot> (. (+)) . (.) . (+)
17:23:09 <Pseudonym> @pl \x y z -> sum [x,y,z]
17:23:10 <lambdabot> ((sum .) .) . (. ((. return) . (:))) . (.) . (:)
17:24:25 <Pseudonym> @pl \x y z -> sum [z,y,x]
17:24:26 <lambdabot> (((sum .) . flip (:)) .) . flip (:) . return
17:24:29 <Pseudonym> Oh!
17:24:31 <Pseudonym> I like that one.
17:24:41 <Pseudonym> That's subtle.
17:26:38 <syntaxglitch> copumpkin, anyway, thanks for letting me know that I'm not crazy for not being able to find something along those lines on hackage
17:26:49 <syntaxglitch> guess I'll put it on my TODO list for when I have more free time :\
17:27:09 <copumpkin> hah np :P let me know if you come up with anything
17:27:20 <copumpkin> or if you want to talk about it some more... it's deep down on my todo list too
17:28:56 <syntaxglitch> copumpkin, unfortunately I'll have to brush up on some relevant maths before I could do anything useful
17:31:21 <copumpkin> just steal cgal code :P
17:31:30 <copumpkin> j/k :P
17:32:48 <syntaxglitch> copumpkin, it still helps to at least sort of understand the code one is stealing :P
17:35:27 * napping 's computer is pretty Frankenstein now
18:08:33 <benmachine> woo, hackage account
18:09:16 <dibblego> start hackaging!
18:09:33 <benmachine> :)
18:10:42 <kmc> krey, any luck with your parsing problem?
18:10:53 <kmc> krey, it sounds like you're parsing s-expressions
18:16:23 <syntaxglitch> awesome, I currently have 666 upvotes in the Haskell tag on Stack Overflow
18:17:00 <danharaj> The devil could have chose any number to be his own and he chose 666. Lame.
18:17:07 <Eduard_Munteanu> Now that's why Haskell is evil and beginners should stay away :P
18:17:16 <syntaxglitch> now I just need approximately OVER NINE THOUSAND more upvotes to catch up with dons
18:17:39 <benmachine> insert token comment about how it's actually 616
18:17:59 <kmc> benmachine beat me to it ;P
18:19:55 <hiptobecubic> 616?
18:21:08 <benmachine> hiptobecubic: apparently.
18:21:37 * syntaxglitch has heard that but can't recall the details
18:22:53 <eugenn> @quote details
18:22:53 <lambdabot> xerox says: you reminded me of a thing but I can't remember the exact details
18:23:59 <eugenn> @pl f x y z = x + y - z + 4
18:23:59 <lambdabot> f = flip flip 4 . ((flip . ((+) .) . (-)) .) . (+)
18:24:41 <eugenn> @pl f x = x f
18:24:41 <lambdabot> f = fix (flip id)
18:24:44 <Pseudonym> And the _really_ interesting bit is that there is only one known name which, when it gets translated through gematria, has 616 and 666 as possible numerological solutions.
18:24:57 <kmc> which name is?
18:25:00 <Pseudonym> Nero
18:25:06 <Pseudonym> Which should be no surprise.
18:25:13 <lispy> is parsec shaped like String -> (Maybe a, String) or String -> Maybe (a, String) internally?
18:25:17 <syntaxglitch> my memory is in pointfree style, it keeps the shape of things but not the particulars :P
18:25:23 <kmc> Pseudonym, heh
18:25:30 <lispy> I think it must be the former, or else no failing parser could consume input
18:25:31 <ddarius> Closer to the latter than the former.
18:25:33 <eugenn> @pl f x y z = z y x f
18:25:34 <lambdabot> f = fix (flip (flip . (flip .) . flip (flip . flip id)))
18:25:58 <Pseudonym> Wow, you mean the Book of Revelation is actually about stuff that concerned the people of the time, not people of today?
18:26:12 <ddarius> It's kind of a combination.  The original Parsec returned one of four possibilities.
18:26:18 <Pseudonym> Anyway, enough about that.
18:26:24 * Pseudonym goes back to paper-writing
18:26:36 <lispy> Pseudonym: oh, cool, what is your target conference?
18:26:36 <ddarius> Pseudonym: What's the paper about?
18:26:43 <eugenn> @pl f x = 3^x + 5
18:26:43 <lambdabot> f = (5 +) . (3 ^)
18:26:46 <Pseudonym> Journal, actually.
18:26:51 <Pseudonym> Oxford Bioinformatics
18:27:22 <lispy> ddarius: Hmm...I have a parser that is String -> Maybe (a, String) internally and I noticed that try and mplus are the same for my parser because of it.  mzero = Nothing.
18:27:23 <Pseudonym> Further questions will be taken on -blah, since it's not submitted yet and this channel is logged.
18:27:33 <eugenn> @pl f x = x^x^x^x
18:27:34 <lambdabot> f = ap (^) (ap (^) (join (^)))
18:27:59 <benmachine> Pseudonym: everywhere is logged by someone :)
18:28:13 <kmc> krey, you could parse sexprs with a "real" parsing lib, but they're simple enough that a quick hack suffices
18:28:17 * lispy logs YOUR mom
18:28:19 <Pseudonym> Yeah, but this channel goes straight up on a couple of web sites.
18:28:28 <benmachine> mm, fair enough
18:28:32 <Pseudonym> It's being submitted on Monday anyway.
18:28:51 <krey> kmc: I would like to parse them myself
18:29:06 <lispy> ddarius: So in my parser, I can't think of any time when try is actually needed
18:29:26 <ddarius> lispy: Your parser is deterministic so try isn't needed/possible.
18:29:28 <kmc> krey, well a typical parser for type A has type «String → [(A, String)]»
18:29:39 <kmc> take an input, return a list of possible (result, remaining input) pairs
18:29:43 <eugenn> @pl f s = "cereal" ++ "want" ++ s f
18:29:43 <lambdabot> f = fix ((("cerealwant" ++) .) . flip id)
18:29:45 <kmc> but parsing sexprs is nice and deterministic
18:30:01 <syntaxglitch> as opposed to parsing perl, which is uncomputable
18:30:13 <kmc> so you don't need the list, you can get by with «Maybe (A, String)» or even just «(A, String)» if you handle errors by some crappy mechanism like "error"
18:30:29 <krey> kmc: well, it might fail, so something like StateT String (Either String) a
18:30:33 <lispy> ddarius: Hmm...
18:30:39 <kmc> why state?
18:30:46 <kmc> oh, to represent the input?
18:30:52 <kmc> @unmtl StateT String (Either String) a
18:30:52 <lambdabot> String -> Either String (a, String)
18:31:05 <eugenn> > sort "once upon a time"
18:31:06 <lambdabot>   "   aceeimnnooptu"
18:31:06 <Phyx-> does anyone here know how to construct a value for the GHC Type Name? I keep getting a panic
18:31:22 <krey> but how do I turn this into trees?
18:31:27 <eugenn> > sort "enthropy"
18:31:28 <lambdabot>   "ehnoprty"
18:31:37 <kmc> krey, 'a' will be your tree type
18:31:40 <napping> Phyx-: I generally use mkName
18:32:00 <ClaudiusMaximus> :t newName
18:32:00 <lambdabot> Not in scope: `newName'
18:32:04 <kmc> krey, here's my simple sexpr parser: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28617#a28617
18:32:15 <Phyx-> napping: oh, there's a mkName? I was trying to use mkInternalName 
18:32:15 <syntaxglitch> > sort "almost"
18:32:15 <kmc> i'd be interested to golf this and see what clever tricks others can come up with
18:32:16 <lambdabot>   "almost"
18:32:35 <napping> Phyx-: that sounds like the most dangerous of the bunch
18:32:36 <Phyx-> napping: where is it? it's not in GHC nor Name
18:32:47 <napping> Language.Haskell.TH.Syntax
18:32:49 <ClaudiusMaximus> Phyx-: hm, there's the TemplateHaskell Name...
18:32:52 <kmc> krey, it's essentially using parsers of type «a -> (a, String)» except that i CPS-transform the tuple into a 2-ary continuation
18:32:56 <eugenn> > (take 1) . reverse . sort $ "ax"
18:32:57 <lambdabot>   "x"
18:33:10 <kmc> you can do it either way, i was golfing and this came out shorter than returning and unpacking tuples
18:33:11 <lispy> syntaxglitch: now that's an interesting puzzle.  Words in english which have all their letters in lexographical order
18:33:12 <kmc> (but maybe less clear)
18:33:17 <Phyx-> napping: are those the same Name?
18:33:22 <Phyx-> ClaudiusMaximus: same Name as GHC uses?
18:33:30 <ClaudiusMaximus> Phyx-: no idea..
18:33:50 <krey> kmc: thanks, trying to understand it, this be too short to be true
18:33:53 <syntaxglitch> lispy: There aren't many, and most are very obscure
18:34:26 <c_wraith> lispy, that's a really easy puzzle with a programming language and a dictionary file :)
18:34:46 <syntaxglitch> To the best of my knowledge, "almost" is the longest common word meeting that criteria, but feel free to crunch some dictionary files to look for others!
18:35:44 <Phyx-> napping: nope, that's not the same Name
18:36:17 <benmachine> c_wraith: doesn't make it uninteresting though :P
18:37:21 <lispy> ?pl \x -> x == sort x
18:37:22 <lambdabot> ap (==) sort
18:37:30 <eugenn> filter f [listOfWords] where f w = w == sort w
18:37:39 <eugenn> right?
18:38:04 <Phyx-> bleh, I give up
18:38:04 <kmc> eugenn, i don't follow
18:38:23 <kmc> if you pass f to filter, f :: a -> Bool
18:38:26 <lispy> :t filter f [listOfWords] where f w = w == sort w
18:38:27 <lambdabot> parse error on input `where'
18:38:34 <lispy> :t let filter f [listOfWords] where f w = w == sort w
18:38:35 <lambdabot> parse error on input `where'
18:38:40 <lispy> :t let filter f [listOfWords] where f w = w == sort w in 1
18:38:42 <lambdabot> parse error on input `where'
18:38:47 <kmc> which since f = id, implies that [listOfWords] :: [Bool]
18:39:01 <kmc> filter does not do any sorting
18:39:35 <lispy> yeah, that was the point I wanted to make but I couldn't get the type
18:39:47 <krey> kmc: would it take you long to get rid of the continuations? cos I kind of fail at those... :(
18:40:07 <eugenn> :t let f w = w == sort w in filter f ["almost", "there"]
18:40:08 <lambdabot> [[Char]]
18:40:18 <kmc> krey, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28618#a28618
18:40:21 <benmachine> kmc: f w = (w == sort w)
18:40:22 <kmc> krey, comparing the two may be instructive
18:40:28 <napping> "billowy"
18:40:31 <kmc> ah benmachine
18:40:52 <krey> kmc: thanks!
18:40:56 <kmc> i thought eugenn meant (==) as "these functions are equivalent"
18:40:59 <benmachine> heh
18:41:00 <kmc> 'cause otherwise i don't see how it's a question
18:41:01 <syntaxglitch> napping, nice
18:41:28 <lispy> almost billowy
18:41:30 <eugenn> I meant (==) as the function as it is :P
18:41:33 <benmachine> it's a suggestion to the exercise about finding words whose letters are in alphabetical order
18:41:36 <eugenn> > 3 == 3
18:41:36 <lambdabot>   True
18:41:52 <lispy> > () == ()
18:41:53 <lambdabot>   True
18:42:18 <kmc> ah ok
18:42:34 <kmc> @check \xs -> xs == reverse xs
18:42:34 <copumpkin> > () == undefined
18:42:35 <lambdabot>   "OK, passed 500 tests."
18:42:35 <lambdabot>   *Exception: Prelude.undefined
18:42:42 <eugenn> and by "right?" I meant "this would work, right?" 
18:42:48 <benmachine> there's probably a faster way of ensuring a list is ascending than w == sort w
18:42:48 <copumpkin> > undefined == ()
18:42:49 <lambdabot>   *Exception: Prelude.undefined
18:43:02 <copumpkin> benmachine: yes :P
18:43:06 <benmachine> :t \w -> and $ zipWith (>) w (tail w)
18:43:07 <lambdabot> forall a. (Ord a) => [a] -> Bool
18:43:12 <benmachine> erm
18:43:17 <benmachine> :t \w -> and $ zipWith (<=) w (tail w)
18:43:19 <lambdabot> forall a. (Ord a) => [a] -> Bool
18:43:22 <benmachine> possible
18:43:26 <benmachine> *possibly
18:43:36 <eugenn> w == sort w is the most expressive one though
18:43:42 <benmachine> :t \w -> and $ zipWith (<=) w (tail w)
18:43:43 <lambdabot> forall a. (Ord a) => [a] -> Bool
18:43:50 <benmachine> eugenn: I guess so
18:43:56 <benmachine> wait I just asked the same thing twice
18:44:09 * lispy waits for benmachine 
18:44:12 <benmachine> eugenn: wait no, isSorted w is the most expressive :P
18:44:15 <tolkad> I think I remember something about most OSes only able to have a certain number of sockets open at a time, is there any way in haskell to tell how many are available?
18:44:29 <eugenn> right
18:44:30 <lispy> tolkad: ulimit?
18:44:34 <benmachine> :t and . zipWith (<=) <*> tail -- lispy, you can stop waiting now
18:44:36 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Bool'
18:44:36 <lambdabot>     In the first argument of `(.)', namely `and'
18:44:36 <lambdabot>     In the first argument of `(<*>)', namely `and . zipWith (<=)'
18:44:41 <lispy> tolkad: if not ulimit, then proc
18:44:46 <benmachine> screwed it up anyways.
18:44:48 * lispy resumes
18:44:54 <benmachine> :t and . (zipWith (<=) <*> tail)
18:44:55 <lambdabot> forall a. (Ord a) => [a] -> Bool
18:45:09 <benmachine> > and . (zipWith (<=) <*> tail) $ [0,0,1,2,78003]
18:45:10 <lambdabot>   True
18:45:13 <benmachine> \o/
18:45:16 <tolkad> lispy: what package is it in?
18:45:20 <benmachine> no other testcases are necessary.
18:45:34 <eugenn> :t and
18:45:35 <lambdabot> [Bool] -> Bool
18:45:38 <lispy> tolkad: oh, ulimit is a command line thing
18:45:46 <tolkad> lispy: that wouldn't be portable
18:45:53 <tolkad> lispy: I want to do it within haskell
18:46:05 <benmachine> tolkad: try to open more and see if it breaks?
18:46:07 <benmachine> >_>
18:46:09 <krey> kmc: thank you a lot for this, I will spend some time studying it
18:46:10 <drhodes> :t (。)
18:46:11 <lambdabot> Not in scope: `???'
18:46:15 <lispy> tolkad: oh, for some reason I thought you asked for a linux solution
18:46:16 <tolkad> benmachine: : /
18:46:17 <krey> kmc: it is incredible short
18:46:24 <benmachine> I think you can't necessarily assume the number of openable sockets is fixed
18:46:33 <benmachine> why would you want to know anyway?
18:46:43 <tolkad> it's necessary for a server to dynamically alter timeouts based on socket availability
18:46:44 <krey> kmc: my solution doesn't use such parsers, but zippers...
18:46:59 <eugenn> :t enumFromTo
18:47:00 <lambdabot> forall a. (Enum a) => a -> a -> [a]
18:47:16 <copumpkin> that function is useless
18:47:16 <tolkad> this prevents certain kinds of DoS
18:47:56 <kmc> krey, oh, interesting
18:48:05 <kmc> can i take a look?
18:48:10 <eugenn> > filter even (enumFromTo 1 15)
18:48:11 <lambdabot>   [2,4,6,8,10,12,14]
18:48:32 <EvanR> i have a question.... heres code for an operator (dunno if its in common use or not)... what im wonder is if recursive use of this to create an infinite list will take more and more time to evaluate? http://codepad.org/QDNPYoF1
18:48:46 <tolkad> they should have called it enumRange imo
18:48:56 <EvanR> will the (+x) keep building up and being recomputed, or well they be computed once
18:49:14 <eugenn> @pl f x = take x (repeat x))
18:49:14 <lambdabot> (line 1, column 24):
18:49:14 <lambdabot> unexpected ")"
18:49:14 <lambdabot> expecting variable, "(", operator or end of input
18:49:23 <krey> kmc: sure, but the code is fairly horrible to be honest
18:49:25 <benmachine> EvanR: I imagine recomputed
18:49:25 <eugenn> @pl f x = take x (repeat x)
18:49:25 <lambdabot> f = ap take repeat
18:49:33 <krey> kmc: but I'd be interested in your opinion
18:49:39 <eugenn> @source ap
18:49:39 <lambdabot> ap not available
18:49:47 <krey> kmc: http://pastebin.com/kSDdZ9ZN
18:49:58 <eugenn> > (ap take repeat) 2
18:49:59 <lambdabot>   [2,2]
18:50:00 * hackagebot FTPLine 1.0.0 - A command-line FTP client.  http://hackage.haskell.org/package/FTPLine-1.0.0 (DanielDiaz)
18:50:00 <EvanR> benmachine: gah
18:50:22 <benmachine> EvanR: easiest way to find out is to try though :P
18:50:25 <kmc> krey, why does your tree have both Top and Branch? what's the diff?
18:50:33 <EvanR> benmachine: but will it grow and grow ?
18:50:45 <EvanR> yeah i guess
18:50:57 <krey> kmc: I needed it for the zipper to someone identify the top node
18:51:03 <tolkad> so... anyone know how to get any information on socket availability within haskell?
18:51:07 <krey> kmc: ^somehow
18:51:18 <eugenn> @pl f x = x + 3 - 3
18:51:18 <lambdabot> f = subtract 3 . (3 +)
18:51:23 <tolkad> this is necessary for implementing a server
18:51:23 <benmachine> EvanR: I don't really see how it could fail to grow without GHC doing something incredibly specific and clever with the thunks
18:51:59 <benmachine> @check \x -> x + 3 - 3 == x
18:52:00 <lambdabot>   "OK, passed 500 tests."
18:52:05 <krey> kmc: I'm not even sure it's a zipper, I 'invented' the thing, and it turns out to be similar to zippers
18:52:07 <eugenn> @check (-) == flip subtract
18:52:08 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a -> a))
18:52:08 <lambdabot>    arising from a use of `GH...
18:52:42 <EvanR> benmachine: well, the map eventually computes the entire map list... maybe that result itself is what is eventually fed back to the map rather than the original map expression
18:53:16 <krey> kmc: also, usage is (createTree . stringToPath)
18:53:16 <eugenn> @pl \x y -> x y
18:53:16 <lambdabot> id
18:54:33 <eugenn> :t <*>
18:54:34 <lambdabot> parse error on input `<*>'
18:55:26 <eugenn> > this.getLocalTime = new Date().getTime();
18:55:27 <lambdabot>   <no location info>: parse error on input `='
18:56:01 <kmc> :t (<*>)
18:56:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:56:35 <EvanR> benmachine: im running let loop xs = xs &> (loop xs) in loop [1,2,3] ;)
18:56:43 <EvanR> lets see if ghci flies out of control
18:56:58 <drhodes> > let (方) = \x -> x * x
18:56:59 <eugenn> :t (&>)
18:56:59 <lambdabot>   not an expression: `let (方) = \x -> x * x'
18:57:00 <lambdabot> Not in scope: `&>'
18:57:03 <krey> kmc: any thoughts? make any sense?
18:57:03 <tolkad> what is Network.Socket.maxListenQueue?
18:57:30 <kmc> krey, it makes some sense
18:57:53 <kmc> seems like you're supporting more operations than just parsing
18:58:01 <kmc> the zipper is useful for navigating a tree if you want to make modifications
18:58:12 <copumpkin> > let (方) = \x -> x * x in 方 5
18:58:13 <lambdabot>   25
18:58:20 <copumpkin> drhodes: ^
18:58:24 <eugenn> > zipWith (+) [1..5]
18:58:25 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
18:58:25 <lambdabot>    arising from a use ...
18:58:55 <drhodes> copumpkin: ok thanks
18:59:00 <eugenn> :t zipWith
18:59:01 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
18:59:07 <krey> kmc: It was the only way I could think of implementing it, until now :)
18:59:23 <krey> kmc: thanks for your help, good night
18:59:25 <EvanR> benmachine: memory is increasing monotonically, though very slowly, but its slowing down a lot to compute the next number ;)
18:59:28 <eugenn> > foldl (+) [2..7]
18:59:29 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
18:59:29 <lambdabot>    arising from a us...
18:59:33 <benmachine> EvanR: keep in mind that compiling with optimisations can change space usage
18:59:39 <EvanR> alright ill try that
19:00:00 <eugenn> :t foldl
19:00:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:00:21 <SubStack> gah whoever wrote Text.Regex.Posix cares way too much about performance and not at all about usability
19:00:31 <eugenn> > foldl1 (+) [2..7]
19:00:32 <lambdabot>   27
19:00:32 <SubStack> where is the =~ for lists >_<
19:00:43 <benmachine> lists?
19:00:49 <SubStack> some kind of matchAll that just operates on strings
19:00:53 <SubStack> would be great
19:01:01 <eugenn> :t matchAll
19:01:02 <lambdabot> forall regex source. (RegexLike regex source) => regex -> source -> [MatchArray]
19:01:20 <benmachine> > matchAll "bloop bleep" "bl.*p"
19:01:22 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexLike
19:01:22 <lambdabot>                     [G...
19:01:30 <SubStack> that
19:01:42 <benmachine> ah, Regex and stuff
19:01:49 <EvanR> benmachine: same story ;)
19:01:58 <EvanR> gah
19:01:59 <benmachine> EvanR: I'm not hugely surprised, oh well
19:02:12 <eugenn> @source foldl1
19:02:12 <lambdabot> foldl1 not available
19:02:18 <benmachine> @src foldl1
19:02:18 <lambdabot> foldl1 f (x:xs) = foldl f x xs
19:02:18 <lambdabot> foldl1 _ []     = undefined
19:02:34 <benmachine> SubStack: what did you mean by =~ for lists
19:02:56 <SubStack> I mean like //g that doesn't suck at instances like matchAll
19:03:13 <benmachine> > "bloop bleep" =~ "bl.*p" :: [[String]]
19:03:14 <lambdabot>   [["bloop bleep"]]
19:03:15 <SubStack> a nice way to just pull out a list of matches
19:03:27 <benmachine> > "bloop bleep" =~ "bl\w+p" :: [[String]]
19:03:28 <lambdabot>   <no location info>:
19:03:28 <lambdabot>      lexical error in string/character literal at chara...
19:03:34 <benmachine> > "bloop bleep" =~ "bl\\w+p" :: [[String]] -- sigh
19:03:36 <lambdabot>   [["bloop"],["bleep"]]
19:03:51 <benmachine> isn't that more or less what you want?
19:04:00 <benmachine> > "bloop bleep" =~ "bl(\\w+)p" :: [[String]] -- sigh
19:04:01 <lambdabot>   [["bloop","oo"],["bleep","ee"]]
19:04:28 <SubStack> seems to be!
19:04:36 <benmachine> heh
19:04:39 <SubStack> although why the [[]]?
19:04:44 <SubStack> seems like one level should suffice
19:04:52 <benmachine> see the second example
19:05:05 <SubStack> yes, returning the entire match seems to be a bug
19:05:06 <eugenn> :t flat
19:05:07 <lambdabot> Not in scope: `flat'
19:05:08 <benmachine> it's a list of possible matches, where each match yields a list of subgroups matched
19:05:14 <eugenn> :t plane
19:05:15 <lambdabot> Not in scope: `plane'
19:05:17 <SubStack> if you want to capture text, it should go into a capture group
19:05:20 <SubStack> otherwise forget it
19:05:37 <benmachine> SubStack: that's not a bug as such, it's what you asked for :P
19:05:46 <benmachine> or, it's a weird API design choice I guess
19:06:13 <eugenn> > let f [[x]] = x in f [[3]]
19:06:14 <lambdabot>   3
19:06:15 <benmachine> > "bloop bleep" =~ "bl(\\w+)p" :: () -- wat
19:06:16 <lambdabot>   ()
19:06:25 <SubStack> also the docs could use some actual examples
19:06:40 <SubStack> I can read the type signatures myself, those don't need anything
19:06:56 <benmachine> lots of people dislike the regex-posix API, I think
19:07:03 <tolkad> :t fix
19:07:04 <lambdabot> forall a. (a -> a) -> a
19:07:10 <benmachine> I find ghci comes in handy, especially :info RegexContext
19:07:15 <benmachine> (:i Regex<tab>)
19:07:25 <benmachine> er, RegexC<tab>
19:07:35 <eugenn> > let f (n+1) = n in f 33
19:07:36 <lambdabot>   32
19:07:53 <SubStack> benmachine++ anyways
19:07:57 <eugenn> > let f (n+2) = n in f 33
19:07:58 <benmachine> :)
19:07:58 <lambdabot>   31
19:08:11 <benmachine> > let f (n+34) = n in f 33
19:08:12 <lambdabot>   *Exception: <interactive>:1:153-164: Non-exhaustive patterns in function f
19:08:50 <eugenn> > sqrt 2
19:08:51 <lambdabot>   1.4142135623730951
19:09:13 <eugenn> > pi
19:09:14 <lambdabot>   3.141592653589793
19:09:28 <eugenn> > cos pi
19:09:29 <lambdabot>   -1.0
19:09:41 <EvanR> benmachine: any idea how to get a similar effect but not broken?
19:09:46 <eugenn> > cos (pi/2)
19:09:47 <lambdabot>   6.123233995736766e-17
19:09:50 <cjf> > acos -1.0
19:09:51 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:09:51 <lambdabot>    arising from a use of `...
19:10:08 <eugenn> > cos 45
19:10:09 <lambdabot>   0.5253219888177297
19:10:44 <benmachine> EvanR: nope. any method that only involves generating the tail of the list once, rather than calling a function on it O(place in list) times, I guess
19:11:44 <eugenn> > ((^2) . sin 4) + ((^2) . cos 4)
19:11:45 <lambdabot>   No instance for (GHC.Float.Floating (f a))
19:11:45 <lambdabot>    arising from a use of `e_1242...
19:12:11 <EvanR> benmachine: guess i need another structure
19:12:13 <eugenn> > (((^2) . sin) 4) + (((^2) . cos) 4)
19:12:14 <lambdabot>   1.0
19:13:24 <eugenn> @slap _unK
19:13:24 * lambdabot smacks _unK about with a large trout
19:14:01 <_unK> ?
19:16:30 <jmcarthur> EvanR: if you want to accumulate the sums then you need an explicit accumulator
19:16:40 <jmcarthur> if i'm understanding correctly that's the issue, right?
19:16:47 <SubStack> > "=one= =two= =three=" =~ "=(.+?)=" :: [[String]]
19:16:48 <lambdabot>   [["=one= =two= =three=","one= =two= =three"]]
19:16:57 <SubStack> posix doesn't seem to have non-greedy support :(
19:17:28 * SubStack gives pcre a go
19:18:16 <SubStack> ah much better
19:19:08 <EvanR> jmcarthur: well id like to append the list of nums such that the second list uses the last element of the first as the origin
19:19:20 <jmcarthur> ah, this is your paths thing :)
19:19:26 <tolkad> is there lazy evaluation between multiple lines in a do block?
19:20:00 <tolkad> for example «do {s <- recv socket 100; print s}»
19:20:07 <jmcarthur> EvanR: and what's the problem with your version?
19:20:15 <EvanR> you saw what i pasted/
19:20:41 <jmcarthur> oh, you want to apply it recursively
19:20:50 <jmcarthur> so you're creating an infinite list
19:20:54 <EvanR> yeah, go left, then go right, then repeat
19:20:59 <tolkad> Will that read and collate data from the socket before printing it? or pipe read output from the socket to standard output?
19:21:17 <jmcarthur> EvanR: it depends how you do the recursion i think
19:21:32 <EvanR> tolkad: IO actions must totally complete before moving on in the >>= sequence
19:21:43 <jmcarthur> it seems properly lazy, so i think if you do it with right associativity then it should be good
19:22:13 <EvanR> jmcarthur: hmm. yeah let me try to just repeat (go left &> go right) ;)
19:22:29 <jmcarthur> :t repeat
19:22:29 <lambdabot> forall a. a -> [a]
19:22:30 <tolkad> EvanR: is there any way I could make it pipe the data?
19:22:34 <EvanR> cycle
19:22:38 <jmcarthur> ah
19:22:42 <EvanR> tolkad: with lazy IO, beware though
19:22:47 <jmcarthur> i don't think that's what you want though
19:22:54 <tolkad> EvanR: how do I use lazy IO?
19:23:02 <EvanR> jmcarthur: youre right, only if i end up at the original origin
19:23:10 <jmcarthur> well, for left and right only i guess it's fine
19:23:12 <jmcarthur> yeah
19:23:40 <tolkad> are you talking about that function that unsafely pulls stuff out of the IO monad?
19:24:02 <tolkad> I can't remember it's name at the moment
19:24:03 <EvanR> what i originally tried was (fix (\f xs -> xs &> f xs))
19:24:13 <EvanR> [1,2,3]
19:24:15 <kmc> tolkad, you can't say much about "do" in general.  "do" for IO monad in particular will be strict by default
19:24:15 <EvanR> (i think)
19:24:21 <kmc> in the sense you are asking about
19:24:34 <siracusa> tolkad: Have a look at unsaveInterleaveIO
19:24:42 <kmc> tolkad, you're not really asking about lazy evaluation; you're asking about lazy execution
19:25:00 <kmc> which is ordinarily forbidden
19:25:06 <kmc> because we never let evaluation drive execution
19:25:07 <tolkad> kmc: well, really I'm just asking haskell to do something I can easily do myself
19:25:22 <kmc> but this thing called "lazy IO" is a hack implemented with unsaveInterleaveIO
19:25:28 <kmc> which allows you to make evaluation drive execution
19:25:29 <EvanR> unsave eh
19:25:32 <kmc> and has numerous pitfalls and traps
19:25:33 <EvanR> dinner
19:25:33 <kmc> heh
19:25:40 <kmc> unsafeInterleaveIO*
19:26:29 <jmcarthur> EvanR: foldr (&>) [] . cycle $ [go left, go right]
19:26:33 <tolkad> does GHC make a significant effort to precompute all statements not involving IO?
19:26:53 <etpace> when would you want to not use INLINE?
19:27:48 <kmc> tolkad, what would that mean?
19:28:01 <jmcarthur> i think tolkad means partial evaluation
19:28:20 <tolkad> > ['a'..'z']
19:28:20 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
19:28:31 <kmc> etpace, inlining a non-function (an unevaluated application, say) could result in duplicated work
19:28:36 <kmc> but i think ghc will refuse to do that anyway
19:28:51 <tolkad> for example if I «main = print $ reverse ['a'..'z']»
19:29:02 <tolkad> will GHC precompute the reverse?
19:29:17 <kmc> etpace, http://www.parashift.com/c++-faq-lite/inline-functions.html#faq-9.3
19:29:31 <kmc> not Haskell-related but good general advice
19:29:39 <tolkad> > reverse ['a'..'z']
19:29:40 <lambdabot>   "zyxwvutsrqponmlkjihgfedcba"
19:30:01 <kmc> etpace, note in particular that specializing and duplicating your code can produce worse i-cache behavior than having one bit of more general code
19:30:06 <tolkad> and end up compiling to roughly the same as «main = print "zyxwvutsrqponmlkjihgfedcba"»
19:30:07 <jmcarthur> tolkad: even if it doesn't, it shouldn't have to compute it more than once at runtime
19:30:42 <etpace> aha~
19:30:54 <kmc> tolkad, it will sometimes
19:30:55 <tolkad> jmcarthur: well, obviously it would be impossible to precompute everything with the halting problem, but I'm wondering if it makes an effort to precompute as much as possible
19:31:00 <tolkad> kmc: ah, thank you
19:31:07 <kmc> tolkad, i think there are no guarantees
19:31:21 <p_l> kmc: regarding inlining etc, is there some good writeup on subroutine call cost compared to simple jump for major modern architectures?
19:31:22 <kmc> tolkad, a useful tool: http://hackage.haskell.org/package/ghc-core
19:31:27 <kmc> p_l, none that i know of
19:31:33 <kmc> if you find it, i'd love to read it
19:31:37 <benmachine> tolkad: if it really upsets you, use TH :P
19:31:39 <kmc> but the point of inlining is not just to avoid call cost
19:31:53 <kmc> the main point (esp. in Haskell) is that it exposes additional optimizations at the call site
19:32:13 * p_l had a crazy idea involving some low level ARM coding (for 3D graphics)
19:32:36 <kmc> like if we inline a bunch of Int operations, we can often get rid of the boxing entirely
19:33:09 <p_l> I wanted to generate some very tight code from a DSL written in either Haskell or CL, trying to shave as many cycles off as possible
19:33:09 <kmc> because then you have the optimization «case (I# x) of I# y -> e»   ===   e[x/y]
19:33:11 <kmc> or whatnot
19:33:16 <p_l> kmc: yeah, I know
19:33:46 <p_l> though an interesting way would be to have two entry points for a function, one with boxing another without
19:34:07 * p_l had actually seen that. Confuses the hell out of decompilers
19:34:16 <tolkad> it would be cool if I could promise GHC that a certain line will halt, and then it will precompute it
19:34:36 <c_wraith> use template haskell?
19:34:43 <kmc> tolkad, you'll find that most of your program depends on things not known at compile time
19:35:05 <kmc> but yeah, you can use TH to do precomputation
19:35:11 <aavogt> multi-stage programming
19:35:15 <kmc> and also to precompute unrolled optimized code for something
19:35:32 <kmc> e.g. given an FFT window size, compute an FFT function optimized to that size
19:35:53 <p_l> kmc: or tightly rolled up into a nice loop that fits into L1? :D
19:35:54 <c_wraith> I'm still waiting for magical supercompilation to come along and reduce entire programs to compile-time computation
19:36:15 <tolkad> but what if I want meta-meta-programming?
19:36:18 <p_l> c_wraith: doesn't work except for simple stuff
19:36:52 <c_wraith> p_l: *magical* supercompilation.  As distinct from implementable 
19:36:55 * p_l had seen (very simple) C programs reducted to I/O operations by Sun's CC
19:37:23 <p_l> I don't necessarily count "magical" as "impossible/unimplementable" XD
19:37:30 <kmc> tolkad, TH supports arbitrarily many stages
19:37:35 <kmc> see fig. 1 in the original TH paper
19:37:39 <kmc> http://research.microsoft.com/en-us/um/people/simonpj/papers/meta-haskell/
19:38:03 <wli> MIPSpro CC is/was rather good at that, too.
19:38:24 <kmc> however some stuff from the TH paper is not implemented in GHC
19:39:04 <p_l> LLVM I think also handles it quite well...
19:39:08 <tolkad> c_wraith: have you ever tried using tarot cards as a halting oracle?
19:39:24 <p_l> that reminds me, I've got GCC for ARM built, now I should take care of getting a LLVM-based stack
19:39:34 <c_wraith> tolkad: I had not considered it.
19:39:45 <kmc> tolkad, sounds like you're dangerously close to discovering the Turing-Lovecraft Theorem
19:39:56 <kmc> watch out for secret agents and shoggoths
20:04:14 <ezyang> If I wanted to find out whether or not GHC was sharing two expressions, what would I look at? 
20:04:25 <ezyang> Stable names, maybe? 
20:06:50 <kmc> GHC.Prim.reallyUnsafePtrEquality# :: a -> a -> Int#
20:07:16 <ezyang> ...Hah. 
20:07:19 <kmc> no joke
20:07:33 <ezyang> That's great. 
20:07:54 <kmc> stable names are a saner way perhaps
20:08:00 <jmcarthur> isn't that basically what you would get from stable names anyway, except breaking the type system?
20:08:02 <kmc> but the official guarantees on stable names are too weak
20:08:14 <jmcarthur> seems like both would be weak
20:08:15 <kmc> i don't see how it breaks the type system
20:08:25 <jmcarthur> it's not RT
20:08:43 <kmc> yeah, but what does that have to do with the type system?
20:08:52 <jmcarthur> not really a type system thing i guess, but it breaks the guarantees about IO and RT
20:09:01 <kmc> non-referentially-transparent values are not specially marked in the type system
20:09:28 <jmcarthur> it was a miswording
20:10:10 <kmc> what i mean by "too weak" is that «_ == _ = False» satisfies the contract for StableName
20:10:15 <ezyang> A little more context: I'm attempting to transform a pure program that uses a lot of sharing to prevent exponential blow-up into a monadic version. 
20:10:38 <ezyang> (specifically, into the reader monad) 
20:10:45 <ezyang> But this transformation appears to be breaking sharing. 
20:10:52 <jmcarthur> kmc: is the situation any different for GHC.Prim.reallyUnsafePtrEquality# ?
20:10:56 <ezyang> which means my program doesn't terminate in reasonable time. 
20:11:34 <kmc> jmcarthur, it makes it explicit that you're depending on implementation-specific behavior
20:11:55 <jmcarthur> sure, at least in name
20:13:04 <jmcarthur> interesting, i expected stable name to use reallyUnsafePtrEquality#, but it has its own eqStableName# primitive
20:13:24 <kmc> yeah
20:13:35 <kmc> a StableName is an actual thing, allocated and freed with gc
20:13:47 <kmc> this means it's probably more stable than reallyUnsafePtrEquality#
20:14:05 <jmcarthur> i see, you're right
20:14:17 <kmc> which could even be non-reflexive if the GC runs at a particularly unlucky time
20:14:23 <ezyang> Mm. That makes sense. 
20:15:10 <tolkad> just how unsafe is reallyUnsafePtrEquality#?
20:15:27 <kmc> really unsafe
20:15:52 <ezyang> As a library author, I demand to know when I can call my functions reallyUnsafe 
20:16:56 <tolkad> when your mother writes functions, she has to label them all "reallyUnsafe" because she is a terrible programmer.
20:17:00 <tolkad> so there.
20:17:24 <kmc> heh, a 'your mom' joke
20:17:33 <kmc> tolkad, you should write for xkcd
20:30:48 <ezyang> I wonder what the relationship between the prompt monad and iteratees is. 
20:33:28 <kmc> hmm
20:33:56 <kmc> Iteratee is a monad, right?
20:34:01 <ezyang> Yup. 
20:34:01 <kmc> did you try implementing it with Prompt?
20:34:10 <ezyang> That's what I'm doing right now :-) 
20:35:08 <alex_kidd> is there any obvious performance problem with the following? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28619#a28619
20:36:32 <ezyang> alex_kidd: Have you run it yet? 
20:36:36 <alex_kidd> yep
20:36:41 <kmc> there is nothing obvious at all about that code
20:36:49 <alex_kidd> its not too bad.
20:36:51 <kmc> however the use of (!!) is a bit suspicious
20:36:56 <alex_kidd> ah.
20:37:03 <kmc> alex_kidd, i'm not saying it's bad, just complicated enough that i can't see what it does at a glance
20:37:43 <kmc> why are you !!ing so much, and have you convinced yourself that the linear-time lookup is ok?
20:38:16 <alex_kidd> sort of, i may have to rethink it
20:38:56 <kmc> what are you trying to do?
20:38:59 <dons> alex_kidd: well, you're traversing lists
20:39:10 <dons> oh, and using list  indexing
20:39:24 <dons> boxed vectors with random access might be more efficient
20:39:40 <alex_kidd> i was trying to naively memoize a function with three Int params, wasn't sure if I got it right
20:39:42 <kmc> or Data.IntMap
20:40:03 <kmc> or one of the trie-based memo libraries
20:40:06 <kmc> like data-memocombinators
20:40:07 <dons> alex_kidd: looks ok.
20:40:17 <dons> http://hackage.haskell.org/package/data-memocombinators
20:40:44 <alex_kidd> thanks
20:44:32 <kmc> so... who wants to play s-expression parser golf?
20:46:30 <wagle> how do you make a string with multiple lines in it (ie, with real eoln's not \n)
20:47:04 <ezyang> ooh ooh, pick me! 
20:47:11 <ezyang> wagle: \n is a real end of line. 
20:47:16 <m3ga> wagle: on unix \n is real eolns
20:47:41 <wagle> i mean "this is line 1
20:47:44 <fryguybob> http://book.realworldhaskell.org/read/characters-strings-and-escaping-rules.html#id689881
20:47:47 <Gracenotes> if you mean like C's \\n, then you'll need multiple strings with ++
20:47:49 <wagle> this is line 2"
20:48:20 <wagle> ok..  hoping for prettier way
20:48:22 <Gracenotes> however, it might be less ugly to have a list of strings concatenated together, one on each line
20:48:41 <m3ga> maybe     unlines [ "line 1", "line 2" ]
20:48:45 <Gracenotes> concat $ [ "this is line 1"
20:48:57 <Gracenotes>          , "this is line 2"
20:49:00 <Gracenotes>          ]
20:49:28 <Gracenotes> giving you this is line1this is line 2. or yeah, for actual EOLs, what m3ga said
20:50:13 <kmc> wagle, so you're talking about string literals in code?
20:50:53 <m3ga> cats skinned many ways
20:52:24 <wagle> makebody x = ""
20:52:24 <wagle>              ++ "\documentclass{article}\n"
20:52:24 <wagle>              ++ "\xymatrix{\n"
20:52:24 <wagle>              ++ xx ++ "\n"
20:52:24 <wagle>              ++ "}\n"
20:52:25 <wagle>              ++ "\end{document}\n"
20:52:33 <kmc> wagle, don't paste code into the channel, use hpaste.org
20:52:41 <wagle> that was shortened
20:52:48 <kmc> wagle, did you see the suggestions above about "concat" and "unlines"?
20:53:20 <wagle> did now..  thanks
20:53:45 <kmc> this is probably overkill, but you can implement here-docs with Template Haskell quasi-quoting
20:54:05 <wagle> hahaha..  an excuse to learn template haskell!  wooo!
20:54:14 <Gracenotes> I haven't found one of those yet
20:54:26 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28620#a28620 wagle
20:54:39 <kmc> this is lifted from haskell-src-meta
20:54:42 <kmc> which i think does not build anymore :/
20:54:46 <kmc> but this code works
20:54:59 <Gracenotes> yeah absent maintainer, whatnot
20:57:40 <ClaudiusMaximus> > "white\                     \space munching can include \n for newlines (for string literals that span more than one line)" -- if this is at all relevant
20:57:41 <lambdabot>   "whitespace munching can include \n for newlines (for string literals that ...
20:57:54 <kmc> hmm.... instance (IsString a) => IsString (a -> String)
20:58:30 <kmc> ClaudiusMaximus, cool, did not know that
20:59:28 <ClaudiusMaximus> but it's still 4 chars of boilerplate per line if you want output lines to match input lines...   \text here\n\
20:59:33 <Gracenotes> ClaudiusMaximus: so it can in fact do the C?
21:00:10 <Gracenotes> well, nearly. hm.
21:02:24 <wagle> kmc thanks
21:02:41 <wagle> btw, I'm setting up a xypic plugin for gitit
21:05:57 <dibblego> anyone know if there is a lambdacats mirror? the domain has died
21:06:08 <luite> anyone want to try a little experiment I'm building?
21:06:10 <luite> http://80.126.200.96:8081/weblog/tryhaskell.mod/
21:06:19 <luite> it's based on tryhaskell, but with some extra's
21:06:27 <luite> try the following commands in the console:
21:06:30 <luite>  > mandelbrot
21:06:34 <luite>  > plot1
21:07:26 <luite> both are just haskell functions in some file I preloaded
21:08:02 <davekong> If I want to put a multi-line string into my code is there some way to conveniently escape newlines and avoid indentation errors?
21:08:13 <luite> the first one outputs a Graphics.Raphael.Raphael value, which is used by the server to display a bitmap
21:08:58 <luite> the second one outputs a Graphics.Interactive.Interactive value, which sets up an interactive user interface for some function, in this case you get a plot which you can influence using buttons and a slider
21:09:09 <luite> does it work for you guys?
21:10:09 <luite> the plot is drawn with vector graphics, you can also draw other things, although it's still a bit buggy
21:10:23 <luite> some examples:
21:10:25 <luite>  > set10
21:10:27 <luite>  > set11
21:10:43 <luite> (nothing interesting, just some things I used to debug the vector graphics library)
21:10:47 <fryguybob> luite: plot1 worked for me, but mandelbrot doesn't.
21:10:56 <luite> fryguybob: timeout?
21:11:07 <luite> oh sorry I know why mandelbrot doesn't work
21:12:06 <fryguybob> ok
21:12:40 <kmc> davekong, that's uncanny, wagle was just asking about that
21:12:51 <kmc> you might want to read the last bit of today's logs
21:13:20 <davekong> kmc: OK, thanks
21:13:20 <wagle> davekong: i opted for using unlines
21:13:22 <luite> fryguybob: mandelbrot should work now
21:13:41 <fryguybob> luite: Yup!
21:14:33 <luite> the source code for plot1 is by the way:
21:14:36 <luite> plot1 = interactive "plotSinCos" [select    "Shade"     True [False, True], intSlider "Range 0.." 10 1 50]
21:15:03 <luite> plotSinCos sh n = plots [sin,cos] sh $ map (*n) [0,0.01..1]
21:15:34 <luite> plot f sh range = raphael 540 200 $ lineChart 15 0 540 140 [[(x, f x) | x <- range]] [axesBottomLeft, shade sh]
21:15:37 <tolkad> :t (++)
21:15:38 <lambdabot> forall m. (Monoid m) => m -> m -> m
21:16:16 <luite> so, any suggestions? :)
21:16:25 <davekong> wagle: I saw this which looks like it may be nice http://groups.google.com/group/fa.haskell/msg/6a63dc4540f0486d
21:16:41 <luite> it's still in an early stage, especially the itneractive things, I should add a "loading" indicator among other things
21:17:35 <davekong> unlines looks nice too though
21:17:36 <luite> the idea is to write a weblog post with inline haskell and add this evaluation box to the end of the post, which the functions from the post available
21:17:49 <luite> so that the reader can experiment with the code immediately
21:18:40 <luite> with bitmap or vector graphics and other user interface elements :)
21:19:01 <davekong> wagle: http://www.haskell.org/pipermail/haskell-cafe/2006-January/013911.html this looks helpful as well
21:20:10 <wagle> davekong: thanks
21:20:29 <ezyang> Ok. 
21:21:05 <fryguybob> luite: It looks nice, but the interactive parts were slow for me.  Are they all server side?
21:21:47 <ezyang> It seems to me the difference between prompt and iteratees is that prompt abstracts away the monad (the interface you use feels like the original, but you can only do what the prompt handler is permitting you to do), whereas for iteratees, the entire flow control of handling incoming input is abstracted away. 
21:21:53 <luite> fryguybob: yes, it should be faster one I compile the graphics library
21:22:02 <ezyang> So iteratees are more restrictive and safer. 
21:22:10 <fryguybob> luite: yeah.
21:22:13 <ezyang> Does this seem reasonable? 
21:22:30 <luite> fryguybob: and this is on my home server, I'll move it to a proper server later :)
21:22:46 <luite> fryguybob: by the way, how slow where they, more than a second?
21:23:08 <fryguybob> luite: Yeah, a couple seconds.
21:23:10 <dolio> Aren't iteratees a specific monad?
21:23:26 <dolio> Prompt is for creating something like a free monad for a given signature.
21:23:33 <ezyang> dolio: Iteratees are a monad, yup. 
21:23:50 <dolio> Only more efficient than the naive free monad definition.
21:24:00 <luite> fryguybob: ah that's too slow
21:24:02 <ezyang> What's the naive free monad definition? 
21:24:18 <dolio> data Free f a = Return a | Roll (f (Free f a))
21:24:35 <luite> fryguybob: it should respond within 100ms for those plots, they're pretty simple. mandelbrot is slow though, it's interpreted code
21:24:43 <ezyang> Ah. 
21:25:08 * ezyang goes and ponders that. 
21:25:33 <dolio> I'm no prompt expert, but it's something like that.
21:26:31 <ezyang> f is supposed to be a Functor? 
21:26:38 <dolio> Yes.
21:27:04 <ezyang> Ah, so it gets more complex because we have to increase the number of fmaps continuously. 
21:27:08 <kmc> davekong, yeah, i lifted that code out of haskell-src-meta and hpasted it a few min ago
21:27:23 <kmc> unfortunately h-s-m doesn't build anymore, mmorrow has vanished
21:36:23 <wagle> where do i look to find out the fastest way to write a string to a file?
21:36:33 <wagle> easiest..  etc
21:36:43 <c_wraith> System.IO, probably
21:36:52 <Cale> Well, there's writeFile in the Prelude
21:36:53 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:36:53 <dolio> Looking at Prompt, it looks a lot like that definition of Free in CPS.
21:36:54 <c_wraith> @hoogle writeFile
21:36:54 <lambdabot> Prelude writeFile :: FilePath -> String -> IO ()
21:36:54 <lambdabot> Data.ByteString writeFile :: FilePath -> ByteString -> IO ()
21:36:54 <lambdabot> System.IO writeFile :: FilePath -> String -> IO ()
21:39:26 <ezyang> dolio: Looked up the paper, you're right. 
21:40:11 <dolio> It doesn't look like an exact match, so maybe there's additional fanciness.
21:40:14 <ezyang> In fact, they describe their result in the setting of Swiestra and Altenkirch, who write something very similar to Prompt (but specialized for two functions) 
21:40:14 <dolio> But it's close.
21:40:25 <wagle> yeah..  thought i'd ask for a fishing pole instead of a fish
21:40:57 <wagle> i googled for system.io and haskell..  8)
21:41:39 <c_wraith> wagle, in general, hayoo and hoogle are good tools.  It's worth using both, as they each have their good and bad points
21:41:45 <ezyang> Continuations are pretty awesome. 
21:41:52 * ezyang nods vigorously. 
21:44:52 * hackagebot improve 0.0.0 - A simple imperative, provable programming language for embedded applications.  http://hackage.haskell.org/package/improve-0.0.0 (TomHawkins)
21:49:54 <mmmulani> anyone have the hsmagick package working?
21:49:58 <ezyang> Hm, I bet the mismatch is because prompt ~ >>=, while Roll ~ join 
21:50:01 <mmmulani> I can't get it to recognize GraphicsMagick
21:52:46 <luite> http://80.126.200.96:8081/weblog/tryhaskell.mod/   -- I recompiled a few things, is it faster for you now? ( try > plot1,  then adjust the slider or click the button )
21:53:04 <luite> it sometimes stops responding, sorry for that, that's a known bug :(
21:53:26 <luite> I don't use mueval (like the original tryhaskell), but my own haskell interpreter webservice based on hint
21:53:39 <luite> and it's unfortunately a little buggy, so it crashes often
21:55:11 <fryguybob> luite: Its about half a second delay now after moving the slider.
21:55:49 <kmc> wagle, fastest is tricky.  Strings are pretty slow in the first place
21:56:04 <luite> fryguybob: may be partially due to javascript redrawing the plot, but I'll look into it. the haskell webservice does seem to respond pretty quickly to those requests, at least on my local network
21:56:13 <wagle> kmc writefile is fine for now
21:56:21 <kmc> yeah
21:57:11 <wagle> fastest as in O(n) where n = number of keystrokes
21:57:12 <luite> fryguybob: I changed it so that it doesn't restart the interpreter each request, but unfortunately that does make it more unstable
21:57:25 <fryguybob> luite: Ah
22:00:11 <luite> does anyone know, if I use hint, load some source file for which I control the import statements (so I don't import System.IO.Unsafe), and evaluate a user-specified expression
22:00:14 <luite> is that safe?
22:00:45 <luite> I memory, cpu time and disk space limits in place, like with mueval
22:00:50 <c_wraith> You should look into just using mueval
22:00:52 <wagle> @hoogle </>
22:00:53 <lambdabot> Text.Html (</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
22:00:53 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
22:00:53 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
22:01:06 <wagle> @hoogle <.>
22:01:07 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
22:01:07 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
22:01:07 <ezyang> luite: Run it in a vm to be safe. 
22:01:21 <wagle> i guessed right!
22:01:29 <luite> ezyang: it would still be bad to mess up the vm
22:02:02 <ezyang> Wipe every week. 
22:02:07 <ezyang> Heavily firewall. 
22:02:32 <luite> c_wraith: there is one problem, I want to be able to load arbitrary modules
22:02:48 <luite> and don't want to restart the interpreter for each request
22:03:09 <c_wraith> hmm
22:03:22 <luite> the original tryhaskell used a modified mueval for that, but that still restricts the modules that can be loaded
22:03:33 <luite> I mean uses :)
22:03:42 <luite> it's still run by chrisdone
22:03:48 <ezyang> luite: What does arbitrary mean? 
22:04:00 <ezyang> Anything thing from HP? Anything from a vetted list of your choosing? 
22:04:02 <luite> ezyang: anythign that I cabal install, or upload as source to my server
22:04:09 * kmc doesn't think "run it in a VM" is foolproof
22:04:15 <ezyang> Seems poor. 
22:04:29 <luite> the idea is that I write a weblog post, generate a lhs file from that post
22:04:41 <luite> and have a tryhaskell box specific to that post to play with
22:05:04 <fryguybob> luite: I like the idea!
22:05:15 <luite> if it's about haskell or programming, it should just be like tryhaskell with some preloaded functions
22:05:35 <luite> if it's about math, the graphing (and maybe vector / bitmap graphics) features should come in handy
22:05:46 <kmc> that's so cool luite
22:06:14 <luite> oh by the way, I haven't tested it in internet explorer, it's probably buggy
22:06:26 <kmc> good
22:06:46 <luite> kmc: have you tried it? suggestions?
22:06:52 <kmc> recent IE is compatible-ish
22:06:58 <kmc> IE6 can rot in hell
22:07:21 <luite> I'll add more widgets for the interactive feature later
22:07:31 <kmc> cool, it's a mandelbrot set
22:07:37 <luite> text boxes and other input fields
22:07:41 <kmc> evaluated in parallel? ;)
22:07:55 <fryguybob> luite: Seems to work on in IE8.
22:08:04 <luite> yeah the mandelbrot set is not interactive,  I could maybe add some parameters to zoom it
22:08:05 * fryguybob closes IE8 with a shiver...
22:08:10 <luite> or even add sliders to do so
22:08:18 <ddarius> Wonderful, an entire thread of dmbarbour, Z-Bo, and Marc Hamann
22:08:43 <dolio> Heh.
22:09:21 <kmc> i don't know who these people are
22:09:35 <dolio> Lambda the Ultimate posters.
22:10:33 <kmc> λ the ⊤
22:21:26 <luite> http://80.126.200.96:8081/weblog/tryhaskell.mod/  -- type > mandel, and get an interactive (with sliders!) mandelbrot
22:21:43 <luite> reload if you have seen it before, I had to fix some javascript bugs
22:23:55 <luite> sorry for the strange ranges on the sliders, floating point support for the slider is not done yet
22:27:30 <ezyang> how long does it usually take to render? 
22:27:40 <luite> around 200ms
22:28:01 <luite> oh the webservice crashed
22:28:07 <ezyang> ah. 
22:28:14 <luite> try again
22:28:26 <luite> the next step is to make a proper multithreaded and stable webservice :)
22:29:36 <ezyang> "I hear there is a veritable cottage industry of Haskell web frameworks." 
22:30:04 <ezyang> no dice. Maybe I'm cursed. 
22:30:16 <kmc> web frameworks are like burritos
22:30:17 <luite> I don't use any web framework by the way, the html page is just static
22:30:33 <luite> the only thing dynamic is the json webservice, which is just a fastcgi script
22:30:51 <luite> the page does load around 400kB javascript code
22:31:13 <luite> so it may run slowly on browsers that don't have a proper javascript compiler
22:33:56 * dancor just learned what "cottage industry" means; why are CS ppl so well-versed in arcana?
22:34:18 <mlh> that's arcana? :-)
22:34:27 <dancor> idk..
22:34:47 <dancor> can we use google to define the arcaneness of phrases
22:36:46 <kmc> but i thought javascript was an interpreted language luite
22:36:48 <kmc> [/flamebait]
22:36:50 <luite> :)
22:37:38 <SubStack> I use wordnet more than google
22:37:39 <luite> I think IE9 generates native code, so not even microsoft should tell you that :)
22:37:47 <dancor> ah yes
22:38:10 <SubStack> I can look up synonyms, antonyms, and definitions all on the command line
22:38:15 <kmc> OED is the shit
22:38:17 <augur> guys, question about operator associativity
22:38:19 <kmc> but, it's restricted
22:38:27 <augur> if two operators are the same precedence, but different associativities
22:38:32 <dancor> SubStack: how about pronunciations..
22:38:32 <kmc> answer about operator associativity / irrelevant witty remark
22:38:37 <dancor> can you rap
22:38:39 <augur> lets say * is infixr 0 and + is infixl 0
22:38:49 <augur> what is the parse for a*b+c
22:39:03 <SubStack> dancor: I don't think wordnet can do those but some dictionaries in apt can
22:39:08 <kmc> did you try it augur?
22:39:13 <dancor> SubStack: ok
22:39:15 <augur> kmc, i have not :D
22:39:18 <augur> i dont know how i would
22:39:19 <kmc> try it
22:39:30 <kmc> "        cannot mix `***' [infixl 0] and `+++' [infixr 0] in the same infix expression"
22:39:30 <augur> well, i suppose i could try define some functions
22:39:43 <augur> huh wha
22:39:55 <augur> so it just errors huh
22:40:19 <luite> ok, I'm going to sleep now, and I'll turn off the server. I'll be back later when I have more things to show, hopefully a few snazzy graphics that can compete with some mathematica demonstrations projects :p (and a stable site)
22:40:42 <kmc> yeah augur
22:41:09 <luite> a 100x100 pixels grayscale mandelbrot doesn't really cut it in the web 2.0 world :)
22:41:21 <kmc> yeah, it needs a drop shadow
22:41:24 <luite> even if it has a jquery user interface
22:42:05 <ezyang> What is an automata that generates a stream of outputs given a stream of inputs called? 
22:42:48 <ezyang> For example, something that calculates convolutional codes. 
22:43:35 <ezyang> Oh, I guess it's just a state machine. :-/ 
22:43:44 <luite> oh speaking about javascript, which of course is entirely off-topic here, is there a shorter/better way to do something like:  function(j) { return function() { x.something(j); } }(i);
22:44:20 <kmc> it doesn't work when you capture i directly?
22:44:24 <kmc> because of mutation?
22:44:32 <luite> kmc: not when i changes in a loop
22:44:36 <kmc> right
22:44:37 <luite> yes mutation is bad...
22:45:00 <kmc> solution: rewrite the loop using map instead ;)
22:45:05 <kmc> i've had this problem in Python, i don't know of a better solution there or in JS
22:45:31 <kmc> (or in Scheme or Haskell, but people don't write mutating loops as often in those languages)
22:45:38 <luite> oh you may be right, there are few cases where I can circumvent this using .each()
22:46:34 <wagle> yeeha!  i have commutative diagrams working in gitit
22:47:10 <Phyx-> Panic,  the 'impossible' has happened
22:47:17 <kmc> yay!
22:47:31 <mauke> kmc: scheme and haskell have 'let'
22:47:42 <mauke> i.e. explicit scoping
22:47:49 <Saizan> kmc: readIORef ?
22:48:04 <kmc> readIORef still involves introducing another lambda probably
22:48:08 <kmc> (the RHS to (>>=))
22:48:15 <kmc> it's just so syntactically lightweight as to be invisible
22:48:46 <Saizan> and a little more explicit about what is going on
22:49:11 <kmc> yeah
22:49:51 <luite> kmc: I had this problem one in perl, but there I solved it using a local scope within the for loop
22:49:55 <luite> once
22:50:05 <mauke> luite: other solutions: use perl instead, require javascript 1.7 ("let"), use .forEach
22:50:09 <luite> and an extra variable
22:50:15 <mauke> luite: why do you need an extra variable in perl?
22:50:38 <kmc> one thing i really like about Scheme is that it does scoping right
22:50:43 <kmc> unlike a lot of similar languages
22:50:55 <kmc> i had the scheme scoping rules beat into me while TAing intro CS
22:51:09 <mauke> my @fs; for my $i (0 .. 9) { push @fs, sub { $i }; }  print join(" ", map { $_->() } @fs);
22:51:14 <luite> mauke: I remember that I needed it, but it may not be loop variable itself that I needed
22:51:19 <mauke> ah, ok
22:51:37 <luite> I haven't been programming perl for quite some time though :)
22:51:44 <luite> fortunately?
22:52:24 <luite> it has been said that perl is almost as hard to read as haskell
22:52:25 <Phyx-> does anyone know why http://phyx.pastebin.com/9zY3Mb3n panics?
22:53:57 <m3ga> luite: perl is potential harder because things like ACME:Whitespace actually work. I don't think it would be possible to do something simialar in haskell
22:55:50 <BMeph> Phyx-: My best guess? "UR DOIN IT RONG!!!11!1!11!!1ichi1!" ;)
22:56:01 <Phyx-> ...
22:56:26 <kmc> helpful
22:57:38 <kmc> m3ga, ghc -F -pgmF
22:57:50 <kmc> and/or TH QQ
22:58:04 <BMeph> Phyx: A more helpful answer: "thing" is one space to the left of "name". Fixing that may be a Good Thing... :)
22:58:21 <ezyang> This is so beautiful. http://blog.sigfpe.com/2009/01/fast-incremental-regular-expression.html 
22:58:23 <drbean> What is the equivalent of mauke's perl script in Haskell?
22:59:34 <m3ga> kmc: stop that. i ended up regretting i learned perl. i don't want to say the same about haskell.
22:59:57 <kmc> haha
23:00:24 <drbean> Specifically how do you do an anonymous subroutine reference?
23:00:43 <kmc> you may end up regretting the fact that source code is plain text that can be processed by files
23:00:49 <kmc> by programs i mean
23:01:10 <kmc> but this is true for any language
23:01:27 <kmc> i think it's convenient to have hooks for preprocessors, obviously the sort of power that can be abused
23:01:32 <m3ga> i've seem suggestions on replacing plain text, but none of them were compelling.
23:01:35 <kmc> Acme:: is supposed to be for jokes / weird experiments anyway
23:02:13 <m3ga> kmc: i know, i am the inspiration behind ACME::butfirst
23:02:34 <kmc> drbean, trying to find an equivalent to some Perl or Java or FooLang program in Haskell is usually a fool's errand
23:02:59 <kmc> does lambda do what you'd want from an anonymous subroutine?
23:03:21 <kmc> the "reference" part is usually invisible in Haskell; i can take it literally and suggest you put the lambda expression in an IORef
23:03:29 <m3ga> kmc: http://lists.slug.org.au/archives/slug/2005/09/msg00346.html
23:03:46 <kmc> haha
23:03:48 <kmc> nice m3ga
23:03:55 <kmc> i searched for "acme buttfirst" by accident and could not find it
23:04:52 <m3ga> my most memorable and successful troll ever
23:05:36 <kmc> well done sir
23:16:16 <augur> kmc
23:16:20 <augur> howd you get that fixity error?
23:17:19 <augur> you know what, nevermind, it doesnt matter, im just going to enforce that things in this language have left-to-right fixity
23:17:20 <augur> :P
23:18:38 <kmc> augur, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28622#a28622
23:18:51 <augur> weird
23:19:02 <augur> i did that in GHCi and it just gave me in-order evaluations
23:22:46 <augur> kmc, i do think i came up with an interesting kind of parser tho x3
23:23:11 <augur> a perverse mixture of categorial grammars, chart parsing, and precedence parsing
23:24:38 <kmc> cool
23:25:39 <kmc> can i see?
23:25:50 <augur> i dont have a demo of it, but i can give you a brief intro
23:29:56 <kmc> demo in #haskell-in-depth :)
23:49:07 <zenzike> hey all, is there any way of knowing which packages are dependants of another?
23:49:39 <zenzike> I'm looking at the Tensor package, and surprised that it doesn't implement any numeric instances, and wondering if someone has already done that
23:54:51 <kmc> someone has added reverse dependency listing to Hackage
23:54:54 <kmc> but it's not on the main site yet
23:55:02 <kmc> i don't remember if there's an active mirror, i think it's Coming Soon though
23:55:06 <Cale> zenzike: That's a pretty minimalist package.
23:55:09 <FunctorSalad> http://bifunctor.homelinux.net/~roel/hackage/packages/archive/pkg-list.html
23:55:26 <FunctorSalad> (rdepends)
23:57:45 <Cale> Oh, I see, it's used by OpenGL
23:58:20 <Cale> Those types were probably originally defined in OpenGL, and split off into their own package.
