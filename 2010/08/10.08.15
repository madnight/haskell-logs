00:01:42 <Heffalump> dolio: how? mappend has to be associative, surely?
00:01:55 <Heffalump> I guess I'm assuming no key clashes, though.
00:02:14 <dolio> Heffalump: I was thinking if there were keys that combined to produce the same key, they could cause issues.
00:02:39 <dolio> I'm not sure, though.
00:02:45 <Heffalump> I think you're right.
00:07:42 <bss03> Grr.  Where can I get Issue 13 of Monad.Reader?
00:07:51 <bss03> The new site doesn't seem to link to issues that far back.
00:08:07 <bss03> Found it, sorry.
00:13:22 <Heffalump> hi conal
00:13:39 <conal> Heffalump: hi
00:22:17 <jrockway> hey, so why doesn't data.vector have a Functor instance?
00:22:24 <jrockway> (fmap = V.map)
00:25:40 <ljungk> why is my ghci not accepting the arrow keys? They just insert A,B,C and D.
00:26:11 <bss03> Looks like your terminal settings are wrong.
00:27:52 <Saizan> jrockway: what's the type of V.map ?
00:29:36 <Saizan> jrockway: it fits, someone forgot to make the instance i guess :)
00:29:48 <dons> jrockway: hmm. i think the lazy,  boxed ones do have Functor
00:30:00 <dons> though the unboxed and storable ones won't
00:30:15 <dons> oh odd. no instance
00:30:39 <dons> instance Monad m => Functor (Stream m) where
00:34:41 <ljungk> bss03: okay, I'm using urxvt and there is no problem anywhere else
00:35:15 <ljungk> i.e. in all shells, irssi, emacs etc
00:37:22 <ljungk> oh, it must be urxvt since it's okay in xterm
01:00:37 <bss03> So, lists are great for stacks, but is there a good data type for Queues or Deques?
01:02:01 <bss03> I guess the order I process things doesn't really matter, but it seems like using a queue stay smaller, normally.
01:02:03 <ezyang> bss03: Yes! 
01:02:19 <ezyang> There are bunch of ways to implement them. 
01:02:54 <bss03> Well, I was hoping there might be a good library already written, ala Data.Map / Data.Set
01:03:04 <ezyang> My personal favorite is ([a],[a]), which is amortized O(1) 
01:03:12 <ezyang> Ah, well, there are plenty on Hackage. 
01:03:16 <ezyang> I'm not sure which ones are good. 
01:03:45 <bss03> 'k I thought ([a],[a]) would perform fine...
01:03:49 <bss03> @hoogle Queue
01:03:49 <lambdabot> module Data.Graph.Inductive.Internal.Queue
01:03:49 <lambdabot> Data.Graph.Inductive.Internal.Queue data Queue a
01:03:50 <lambdabot> Data.Graph.Inductive.Internal.Queue queueEmpty :: Queue a -> Bool
01:07:11 <lucca> bss03: try Data.Sequence?
01:10:04 <bss03> Yeah, I was looking at that.
01:10:37 <bss03> It appears to have good performance, I think.  I can't really understand the implementation.
01:10:47 <bss03> I've never dealt with FingerTrees before, I guess.
01:11:40 <jedai> bss03: They're a very cool idea and the paper on them is pretty nice and clear :)
01:12:11 <jedai> Though I'm not sure they're the best choice if your queue only needs to be a queue
01:15:56 <deteego> kamatsu: hello!
01:16:02 <kamatsu> deteego: yo
01:16:16 <deteego> how are you
01:16:20 <kamatsu> okay
01:16:25 <kamatsu> wondering what i'm teaching in the tute tomorrow
01:18:10 <deteego> kamatsu: I just looked at the sample exam for Tuesday
01:18:25 <deteego> kamatsu: is exam basically on "everything we learn until last week"
01:24:04 <kamatsu> yeah
01:24:58 <deteego> ok cool
01:25:48 * hackagebot bindings-directfb 0.1 - Low level bindings to DirectFB  http://hackage.haskell.org/package/bindings-directfb-0.1 (MauricioAntunes)
01:27:52 <deteego> kamatsu: I found another nice mpd ncurses client, but whoever coded it was naive and thus its quite slow
01:28:02 <deteego> kamatsu: its called pms (aur package is called pmus)
01:38:29 <kamatsu> i use pms
01:41:30 <deteego> I still use ncmpc =D
02:04:32 <danportin> Is there a control character (or other command) to clear the terminal in GHCi? I can't seem to find one. E.g., so you can run a function which prints, waits for input, clears the screen, then prints something else (in a loop). Supposedly \ESC[2J should do this, but doesn't.
02:23:04 * hackagebot hs2dot 0.1.4 - Generate graphviz-code from Haskell-code.  http://hackage.haskell.org/package/hs2dot-0.1.4 (OscarFinnsson)
02:23:53 <om-foxy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29074#a29074:  What is wrong here?
02:27:59 <monadic_kid> om-foxy: what is C.Render, is it a monad?
02:28:16 <om-foxy> yes, C.Render is the Cairo monad
02:29:43 <monadic_kid> om-foxy: you want "MonadTrans StateT" i believe
02:30:06 * hackagebot elerea-examples 2.0.1 - Example applications for Elerea  http://hackage.haskell.org/package/elerea-examples-2.0.1 (GergelyPatai)
02:30:59 <monadic_kid> om-foxy: in the deriving clause
02:34:01 <monadic_kid> om-foxy: MonadTrans expects a type with the kind (* -> *)  -> * -> *, but you're giving it a type with a kind of *  -> *  -> *
02:34:01 <lucca> danportin: control-l
02:34:50 <om-foxy> monadic_kid: yeah, I tried that and got: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29074#a29076
02:35:35 <lucca> danportin: otherwise, varies by your terminal.  putStr "\ESC[0;0H\ESC[2J" works nicely for me
02:42:19 <RayNbow> lucca: that requires an ANSI terminal
02:42:42 <RayNbow> (which isn't a problem as long as you don't have to deal with Windows)
02:42:56 <bss03> What the heck has kind (* -> *) -> * -> *?
02:43:24 <bss03> I thought windows could do ANSI.
02:43:32 <bss03> You just have to load ansi.sys, right?
02:43:48 <RayNbow> bss03: that won't work in XP, Vista and 7
02:44:18 <monadic_kid> bss03: monad transformers
02:44:34 <RayNbow> http://hackage.haskell.org/package/ansi-terminal  <--  someone made a portable ANSI-like package though
02:46:19 <monadic_kid> om-foxy: actually you was right, trying taking out the brackets, MonadTrans (StateT BoundingBox) to MonadTrans StateT BoundingBox
02:46:33 <om-foxy> okay, thanks
02:47:08 <danportin> thanks - ansi terminal looks promising; or i could just use xterm (i think)
02:49:03 <monadic_kid> om-foxy: yeah when I put brackets around the partial application of a type constructor i get the same error message, without the brackets it works
02:50:31 <monadic_kid> om-foxy: you probably want to derive MonadIO as well, to lift plain IO actions
02:50:43 <om-foxy> okay, thanks
02:51:47 <iocor> if I have a float, how can I get it's bit representation as an Int32?
02:52:09 <opqdonut> probably by using Data.Binary
02:53:21 <iocor> "could not find module Data.Binary it is a member of the hidden package ghc-binary-0.5.0.2"
02:53:53 <opqdonut> you need to expose the package in your cabal file or something
02:55:48 <lucca> RayNbow: heh.  System.Win32.Console doesn't offer much.
02:57:49 <ljungk> is there a built-in function which takes a pair and reverses the order of the elements?
02:58:15 <opqdonut> :t swap
02:58:16 <lambdabot> Not in scope: `swap'
02:58:19 <om-foxy> iocor: cabal install binary, keep ghc-binary hidden
02:58:40 <opqdonut> ljungk: it seems it's not defined by default, but the function is usually called swap
02:58:48 <opqdonut> easy to define of course, swap (x,y) = (y,x)
02:58:49 <iocor> om-foxy, ok
02:58:56 <lucca> @pl \(x, y) -> (y, x)
02:58:56 <lambdabot> uncurry (flip (,))
02:59:06 <opqdonut> that too
03:00:57 <kmc> or:  swap ~(x,y) = (y,x)
03:01:22 <ljungk> okay, thanks
03:01:23 <aRcatan> kmc: what's that?
03:01:47 <kmc> lazy irrefutable pattern
03:02:02 <kmc> > let swap (x,y) = (y,x) in case swap undefined of (a,b) -> ()
03:02:04 <lambdabot>   *Exception: Prelude.undefined
03:02:07 <kmc> > let swap ~(x,y) = (y,x) in case swap undefined of (a,b) -> ()
03:02:09 <lambdabot>   ()
03:02:38 <aRcatan> interesting
03:11:24 <bss03> > let swap ~(x,y) = (y,x) in case swap undefined of (a,b) -> a
03:11:25 <lambdabot>   *Exception: Prelude.undefined
03:39:34 <ivanm> @. elite protontorpedo
03:39:34 <lambdabot> p13Az3 3xPaliN PUrE 4nd LAzy 4 Lit+Le (i/\/\ igoNOr4n7 I knoW)?
03:45:25 <b0fh_ua> Hello! Are there any libraries like JavaMail exist for parsing e-mail messages with attachments etc in Haskell?
03:45:43 <ivanm> not sure
03:45:55 <b0fh_ua> I found mime library, but not sure how to use it with e-mails
03:46:20 <bss03> _ua? = University of A???
03:46:20 <ivanm> there's an mbox library, if that helps...
03:46:23 <ivanm> and HackMail...
03:46:30 <ivanm> bss03: Ukraine I believe
03:46:39 <ivanm> b0fh_ua: hsemail?
03:46:57 <ivanm> bss03: http://en.wikipedia.org/wiki/.ua
03:47:27 <b0fh_ua> ivanm: hm, nice. Will take a look at it :) Thanks
03:47:33 <b0fh_ua> bss03: Ukraine
03:47:43 <ivanm> np
03:47:51 * ivanm just searched for "mail" on hackage
03:48:18 <b0fh_ua> I looked at mime
03:49:41 <b0fh_ua> http://hackage.haskell.org/packages/archive/hsemail/1.2/doc/html/Text-ParserCombinators-Parsec-Rfc2822.html
03:49:55 <b0fh_ua> so this is only a set of combinators?
03:50:48 <ivanm> looks like it
03:51:08 <b0fh_ua> hm, interesting
03:51:23 <illissius_> anyone know if/how you can manually invoke a major garbage collection in ghc? google isn't helping
03:51:30 <ivanm> not sure if you can
03:51:54 <illissius_> I seem to remember reading somewhere that you can -_- oh well.
03:52:08 <Saizan> ?hoogle performGC
03:52:09 <lambdabot> System.Mem performGC :: IO ()
03:52:15 <Saizan> that's it ^^^
03:52:19 <ivanm> aha
03:53:54 <illissius_> Saizan: thanks :)
03:54:49 <chrisdone> IIRC, performGC isn't guaranteed to actually do anything though
03:54:51 * chrisdone checks
03:58:34 <chrisdone> check inconclusive
03:59:46 <bss03> What does the C function "performMajorGC" in GHC do?
03:59:50 <illissius_> chrisdone: did what i wanted, in any case
04:00:57 <illissius_> (which was to check whether you can do FFI calls and callbacks into haskell in Foreign.Conc finalizers -- because you can't in Foreign.ForeignPtr ones. the result is that you can.)
04:08:23 <robertmassaioli> I am just playing around with implementing the ICalendar rfc spec and it has given me the entire grammar to parse. Should I be using Parsec to get me the whole way to the final container that will hold it? Because currently I am just using it to separate the data on each line into name;params:value triples.
04:09:23 <Twey> Within Parsec you can perform a transformation on the triple before returning it (to get it into the desired structure)
04:15:03 <robertmassaioli> Twey: okay I'll read through Parsec more. (Still new to parsec)
04:35:35 <rizwanhudda> hi haskellers
04:36:58 * hackagebot binary-generic 0.1 - Generic binary serialisation using binary and syb.  http://hackage.haskell.org/package/binary-generic-0.1 (LarsPetersen)
04:38:58 * hackagebot SybWidget 0.5.4 - Library which aids constructing generic (SYB3-based) widgets  http://hackage.haskell.org/package/SybWidget-0.5.4 (MadsLindstroem)
04:39:31 <Wooga> hello, i am trying to write brainfuck parser in Parsec, but i am stuck here: http://codepad.org/P3t43dVO . is there any way to trashout non-brainfuck characters without creating special value 'Skip' like in this example ?
04:41:11 <Saizan> yep
04:41:17 <jkramer> Ahoy
04:41:34 <jkramer> I think since the last update, hlint suggests weird/wrong things
04:41:51 <Wooga> Saizan: can you show me please how exactly?
04:42:43 <lispy> someone should make a really nerdy zombie movie where the only way to kill the unix sysadmin zombie is to kill his/her parents.
04:43:08 <Saizan> Wooga: i was writing it up :) http://codepad.org/qWFYNYc0
04:43:10 <Cale> Wooga: One option: make bfChar and bfBraces produce a list of tokens, so that trash can give an empty list. Concatenate the results.
04:43:47 <Wooga> Saizan: thanks!
04:43:52 <Wooga> Cale: thank you too
04:44:25 <lispy> jkramer: like, "Instead of eta reduction, try a Factory pattern." ?
04:47:07 <Axman6> could you not also just run filter on the String?
04:47:20 <ivanm> lispy: heh
04:47:40 <ivanm> @remember lispy jkramer> I think since the last update, hlint suggests weird/wrong things <lispy> jkramer: like, "Instead of eta reduction, try a Factory pattern." ?
04:47:41 <lambdabot> Good to know.
04:48:11 <jkramer> Sorry, I was looking for the hlint bug tracker instead of explaining further :)
04:48:17 <medfly> I think you're supposed to @tell
04:48:33 <ivanm> medfly: no, that was a quote
04:48:35 <bss03> @pl \x y = y >>= modify $ (x :)
04:48:35 <lambdabot> (line 1, column 6):
04:48:36 <lambdabot> unexpected "="
04:48:36 <lambdabot> expecting pattern or "->"
04:48:36 <medfly> oh. maybe it's a joke :-/
04:48:41 <bss03> @pl \x y -> y >>= modify $ (x :)
04:48:42 <lambdabot> flip (modify =<<) . (:)
04:48:46 <jkramer> hlint suggests code that just doesn't make sense and won't compile: http://pastie.org/1093583
04:48:52 <bss03> @pl \x y -> y >>= (modify $ (x :))
04:48:53 <lambdabot> (=<<) . modify . (:)
04:49:20 <jkramer> Also, it does so twice :)
04:49:21 <bss03> :t modify . (:)
04:49:22 <lambdabot> forall (m :: * -> *) a. (MonadState [a] m) => a -> m ()
04:49:43 <lispy> jkramer: does it not understand shadowing or something?
04:50:12 <bss03> :t (=<<) . modify . (:)
04:50:13 <lambdabot>     Couldn't match expected type `m b' against inferred type `()'
04:50:13 <lambdabot>     In the first argument of `(.)', namely `modify'
04:50:14 <lambdabot>     In the second argument of `(.)', namely `modify . (:)'
04:50:29 <Saizan> i guess it just doesn't care about qualifications
04:50:54 <jkramer> lispy: Not sure, A.id should be pretty clear I guess
04:51:18 <jkramer> A is Text.Blaze.Html5.Attributes
04:51:39 <lispy> jkramer: it thinks A.id = Prelude.id
04:51:45 <bss03> :t let push = modify . (:) in [] >>= push 1
04:51:46 <lambdabot>     Couldn't match expected type `[b]' against inferred type `()'
04:51:47 <lambdabot>     In the second argument of `(>>=)', namely `push 1'
04:51:47 <lambdabot>     In the expression: [] >>= push 1
04:51:57 <lispy> Which I guess is what Saizan meant by quantification
04:52:21 <bss03> :t let push = modify . (:) in execState (push 1) []
04:52:23 <lambdabot> forall a. (Num a) => [a]
04:52:23 <Gracenotes> import Prelude as A
04:52:32 <bss03> let push = modify . (:) in execState (push 1) []
04:52:38 <bss03> > let push = modify . (:) in execState (push 1) []
04:52:40 <lambdabot>   [1]
04:53:01 <lispy> import qualified Prelude as Epilog
04:54:11 <bss03> > let pop s = (head s, tail s) in runState pop [1]
04:54:12 <lambdabot>   Couldn't match expected type `Control.Monad.State.Lazy.State s a'
04:54:12 <lambdabot>         a...
04:54:14 <Saizan> *qualification, but yes :)
04:54:20 <Wooga> Cale: thank you too
04:54:22 <Wooga> oh
04:54:26 <Wooga> sorry, wrong terminal
04:54:30 <bss03> > let pop s = (head s, tail s) in evalState pop [1]
04:54:31 <lambdabot>   Couldn't match expected type `Control.Monad.State.Lazy.State s a'
04:54:32 <lambdabot>         a...
04:54:41 <lispy> Saizan: ah, sorry.  Very tired :)
04:55:00 <Saizan> > let pop s = (head s, tail s) in evalState (State pop) [1]
04:55:02 <lambdabot>   1
04:55:32 <lispy> > let { uncons [] = Nothing; uncons (x:xs) = Just (x,xs) } in uncons [1..3]
04:55:34 <lambdabot>   Just (1,[2,3])
04:56:09 <medfly> > let { uncons [] = Nothing; uncons (x:xs) = Just (x,uncons xs) } in uncons [1..3]
04:56:10 <lambdabot>   Occurs check: cannot construct the infinite type:
04:56:10 <lambdabot>    a = (t, Data.Maybe.May...
04:56:14 <medfly> :|
04:56:45 <lispy> That's actually a case where the infinite type makes some sense
04:56:59 <lispy> It would just be an infinite interleaving of just and (,)
04:57:18 <kmc> which is isomorphic to [] anyway
04:57:56 <kmc> List X = µF. 1 + X*F
04:58:02 <lispy> Hmm...wouldn't it be weird if the type checker saw that and replace d it with []?
04:58:38 <kmc> yes
04:59:19 <lispy> I've heard of people allowing infinite types in their type checkers, but I haven't heard of people having the infinite types be replaced by some standard recursive type
04:59:33 <Saizan> "this fixpoint is the same as a declared one" might make some sense as an heursitic to let only "good" infinite types pass
04:59:47 <lispy> yeah
05:00:12 <lispy> I might replace "good" with "ones we already understand"
05:00:34 <Saizan> by good i mean ones that are not likely to be a sign of a bug
05:01:26 <lispy> I wonder if hlint can or does tell you when the type you've used is isomorphic to some simpler or more conventional type
05:11:41 <Saizan> yay, i can make GHC loop while building typeclass dictionaries.
05:13:52 <bss03> :t modify
05:13:53 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
05:13:54 <bss03> :t .
05:13:55 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29078#a29078 <- except that i haven't commented it, but you get the point :P
05:13:55 <lambdabot> parse error on input `.'
05:13:58 <bss03> :t (:)
05:13:59 <lambdabot> forall a. a -> [a] -> [a]
05:14:00 <Saizan> :t (.)
05:14:00 <bss03> :t (.)
05:14:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:14:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:14:12 <Saizan> :t Prelude..
05:14:13 <lambdabot> parse error on input `Prelude..'
05:14:19 <Saizan> :t (Prelude..)
05:14:21 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:16:21 <Maxdamantus> How is . meant to be defined? a . b = \c -> (a b) c ?
05:16:37 <medfly> @src (.)
05:16:38 <lambdabot> (f . g) x = f (g x)
05:16:38 <lambdabot> NB: In lambdabot,  (.) = fmap
05:17:06 <Maxdamantus> Oh yeah.
05:17:28 <kmc> a (b c)  not (a b) c
05:17:29 <Maxdamantus> Ah, didn't think of pattern matching like that.
05:17:44 <Maxdamantus> Yeah
05:18:36 <Maxdamantus> So it's different to the "of" operator in mathematics?
05:19:21 <Maxdamantus> Hm. It's called "function composition" and Wikiing that shows that operator.. seems more like $ now
05:20:32 * Maxdamantus looks for a name for ($)
05:20:40 <Twey> Function application
05:20:46 <burp> dollar operator
05:20:50 <Maxdamantus> Ah right.
05:21:09 <Twey> Mathematical f(x) is f x; f(x)(y) is f x y; f(x(y)) is f (x y) or f $ x y
05:21:11 <Maxdamantus> So why is (.) called function composition and ($) not?
05:21:17 <kmc> because they're two different things
05:21:17 <Twey> Because ($) doesn't compose functions
05:21:23 <kmc> and (.) is the one called "function composition" in maths
05:21:37 <kmc> the word "of" could mean either in maths
05:21:43 <kmc> that's why symbolic notation is preferred ;)
05:22:39 <Maxdamantus> Maybe the way we've used it in my maths course is just a special case
05:22:48 <Maxdamantus> a \of b(c) -> a(b(c))
05:23:34 <kmc> (f ∘ g)(x) would mean f(g(x))
05:23:35 <azaq23> a . b is an entity which can be applied (a new function); a(b(c)) is an expression involving two functions and a variable
05:23:37 <Maxdamantus> Wait yeah, that's how it's described on Wiki too.. isn't that just identical to the $ operator?
05:23:41 <kmc> no
05:23:42 <kmc> @src (.)
05:23:43 <lambdabot> (f . g) x = f (g x)
05:23:43 <lambdabot> NB: In lambdabot,  (.) = fmap
05:23:44 <kmc> @src ($)
05:23:45 <lambdabot> f $ x = f x
05:24:52 <Maxdamantus> Ohhh.. I see.
05:25:28 <kmc> «(f . g) x» is «f (g x)» as above
05:25:33 <kmc> «(f $ g) x» is just «f g x» which is «(f g) x» which is not «f (g x)»
05:26:13 <Maxdamantus> Mmm.. The brackets might make a difference - they weren't there in the lecture.
05:26:43 <hpc> f $ g x == f (g x)
05:26:57 <hpc> the parens undo the low precedence of ($)
05:26:57 <Maxdamantus> f∘g(x) -> f(g(x)) .. f $ g x -> f (g x)
05:27:15 <Maxdamantus> dw
05:28:38 <Maxdamantus> I don't think we did functions constructed from other functions yet.
05:37:27 <danportin> Hmm, is there a better way to track the context for a rose tree ('data Tableau a = Node a [Tree a]') zipper than, e.g., 'data Context a = Branch Int', where the v :: Int = index in list of subtrees? 
05:39:53 <Botje> you could have a zipper over the [Tree a]?
05:42:51 <dobblego> danportin, http://hackage.haskell.org/packages/archive/rosezipper/0.2/doc/html/Data-Tree-Zipper.html ?
05:43:56 <danportin> Wierd, I just searched Hackage and didn't find that - I'll have a look :) Thanks
05:45:58 <drp> Can anyone tell me if it is safe to nest MVars?  I have a modifyMVar inside a different withMVar.  My innermost computation is throwing an exception, and an then later, I am getting an error "thread blocked indefinitely in an MVar operation"
05:57:42 <smorg> Interesting though how haskell treats \x \y and \x y as curried.
05:58:04 <copumpkin> it's not currying
06:03:22 * hackagebot improve 0.0.9 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.0.9 (TomHawkins)
06:03:23 <Cale> Well...
06:05:17 <Cale> They are curried, in the sense that they'll each be functions of one parameter which produce other functions.
06:07:38 <copumpkin> I guess writing it as \x y suggests an implicit tuple, supposedly?
06:15:24 <Cale> copumpkin: Well, it's not so much that any process of currying is being carried out, just that the function is already in curried form.
06:16:04 <Wooga> hello, i have written brainfuck interpreter; can it's code be somehow improved: http://codepad.org/PuGVXkmN ?
06:16:16 <copumpkin> so any function of one argument that returns another function is curried?
06:17:55 <Cale> copumpkin: Yeah, I suppose so :)
06:18:06 <copumpkin> fair enough :)
06:20:25 <Cale> Wooga: Something you might consider would be instead of taking Boolean parameters for isRawInput and isRawOutput, instead take the appropriate IO actions or functions to do input and output.
06:20:58 <RayNbow> not a Haskell question, but does anyone know the English word for this? http://img153.imageshack.us/img153/28/imag0043hh.jpg
06:21:16 <Martty> door handle?
06:21:17 <Cale> A doorknob?
06:21:18 <Heffalump> that's a doorhandle
06:21:25 <Wooga> Cale: thanks!
06:21:29 <Martty> Cale doornoob
06:21:45 <RayNbow> erm, it's not the thing to open the door :p
06:22:02 <RayNbow> it's kinda like a door hook
06:22:11 <Twey> A latch?
06:22:27 <copumpkin> latch?
06:23:03 <RayNbow> hmm, I'll settle for latch... thanks :)
06:23:08 <Cale> Do you know a word for what you're referring to in any language? :)
06:23:12 <Igloo> What does it do?
06:23:26 <RayNbow> Cale: I'm not even sure what it's officially called in Dutch :p
06:23:31 <Igloo> This is a door knob, incidentally: http://t2.gstatic.com/images?q=tbn:ANd9GcTnxMSskcw6NtvOCBwfa5r5j31pyMY4ccy7QCp1tt4A5jhFCBg&t=1&usg=__xZ2CNTguT2HH3XFmVu8WZHZyEm0=
06:23:39 * copumpkin can't even load the picture on this shitty connection :(
06:24:24 <sohum> is there a decent image library? One I can point to an IO File and get, I dunno, a Map (Int, Int) Colour?
06:24:30 <RayNbow> Igloo: you can use that thing to lock the door from the inside
06:24:56 <sohum> *bitmap library, I suppose
06:26:57 <Cale> sohum: There's a binding to (part of) the gd library, and a bunch of other things on Hackage.
06:27:57 <Cale> There's also the Imlib package, which is a binding to Imlib 2
06:28:42 <ManateeLazyCat> I'm working on merge gio-branch to gtk2hs-0.12.0, gio is cross-platform APIs for file operation, can use it develop file manager or similar application. If anyone want to use those APIs, help me test functions at https://patch-tag.com/r/AndyStewart/gio-branch/home, then we can release gio-0.12.0 quicker. Thanks!
06:29:39 <sohum> Cale: the gd library.. hah, it has setPixel, but not getPixel
06:30:12 * huntse cannot construct the infinite type apparently.
06:30:17 <copumpkin> setPixel and getPixel functions are terrible, in general
06:31:24 <sohum> copumpkin: well, in this particular case, I'm having trouble imagining abstractions above getPixel that would help me
06:32:41 <Twey> Map (Int, Int) sounds more like an Array to me.
06:32:53 <tibbe> What does a strict left fold over a binary tree look like?
06:33:39 <Cale> tibbe: A composite of foldl' with some traversal?
06:34:03 <Cale> tibbe: "left" is weird here, usually that term is used with lists.
06:34:48 <tibbe> Cale: I guess pre-order would be more appropriate
06:35:01 <tibbe> Cale: I was thinking about the order of things should get forced
06:36:17 <sohum> imlib... looks like it'd work, but /damn/ that is not a nice looking api
06:36:21 <tibbe> How about this:
06:36:36 <tibbe> foldlWithKey' :: (b -> k -> a -> b) -> b -> Map k a -> b
06:36:36 <tibbe> foldlWithKey' f z0 m0 = go z0 m0
06:36:36 <tibbe>   where
06:36:36 <tibbe>     go z Tip              = z
06:36:36 <tibbe>     go z (Bin _ kx x l r) = let x' f = (go z l) kx x in x' `seq` (go x' r)
06:36:52 <tibbe> module 'f' on the right side of the =
06:37:25 <sohum> Cale: thanks
06:44:39 * hackagebot base-unicode-symbols 0.2.1 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.2.1 (RoelVanDijk)
06:56:45 <FunctorSalad> hmm I don't remember `cabal update' eating so much CPU... it has accumulated 20 minutes of cpu time already
06:56:55 <FunctorSalad> did I missetup it?
06:58:25 <FunctorSalad> (I recently rebuilt ghc, maybe some wrong flag there regarding IO?)
07:00:27 <Saizan> weird, update just downloads a tarball and ungzips it
07:02:21 <yescalona> @karma java
07:02:22 <lambdabot> java has a karma of -10
07:03:47 <RayNbow> @karma C++
07:03:48 <lambdabot> C++ has a karma of 0
07:03:56 <iocor> java++
07:04:24 <RayNbow> preflex: karma C++
07:04:25 <preflex>  C++: -44
07:04:42 <iocor> that sonuds about right
07:04:54 <aristid> preflex: karma java
07:04:54 <preflex>  java: -30
07:05:01 <aristid> preflex: karma haskell
07:05:01 <preflex>  haskell: 54
07:05:02 <iocor> :O
07:05:06 <iocor> but java's beautiful
07:05:09 <aristid> iocor: no.
07:05:21 <RayNbow> some parts of Java (the island) are beautiful, yes
07:05:28 <iocor> hahaha
07:05:29 <iocor> you guys
07:07:12 <illissius_> c++ > java
07:07:18 <illissius_> (#haskell trolling of the highest caliber.)
07:07:25 <FunctorSalad> Saizan: yes, that's why I think I must have done something wrong ;)
07:09:25 <aristid> illissius_: yeah, true.
07:11:38 <jkramer> How do I efficiently convert a lazy bytestring to a strict one? I guess "BS.pack (LBS.unpack s)" is rather inefficient?
07:12:17 <ivanm> IIRC there is a specific function that will do that
07:12:25 <Saizan> concat . toChunks
07:12:54 <ivanm> using strict concat, of course
07:12:59 <Saizan> still O(n) but not as bad
07:14:20 <jkramer> Thanks, seems to work
07:15:19 <FunctorSalad> here's the strace -f output of running it for a few seconds(!) http://79.216.135.82/gal/cabaltrace.html
07:15:42 <FunctorSalad> in colour :D
07:16:21 <FunctorSalad> I have no idea what rt_sigprocmask does but it sure is doing a lot of it ;)
07:16:24 <eikke> FunctorSalad: what do you use to colorize strace output?
07:16:41 <FunctorSalad> eikke: source-higlight -s c
07:16:46 <FunctorSalad> ;)
07:19:15 <SingAlong> hi all :)
07:19:32 <FunctorSalad> hmm hope that 3.8M file isn't too slow to serve with my adsl ;)
07:20:21 <Jafet> FunctorSalad: I tried checking my webbrowser's page info tab for a gzip header, but it crashed it
07:20:54 <FunctorSalad> I'll just gzip it explicitly ;)
07:21:31 <FunctorSalad> http://79.216.135.82/gal/cabaltrace.html.gz
07:22:15 <FunctorSalad> sorry that killed the original .html ...
07:22:38 <FunctorSalad> (but it's pretty effective, down to 83k ;))
07:23:39 <FunctorSalad> ok, both should be back now ;)
07:24:45 <Jafet> It looks like some part of cabal is throwing lots of signals around and some other part is responding spuriously to it
07:25:20 <FunctorSalad> (btw what crashed what? the page info the browser? no idea)
07:25:39 <Jafet> The browser -- but firefox is temperamental like that
07:25:51 <FunctorSalad> it's a cherokee without much changed
07:26:06 <Jafet> Or another guess is that strace is trying to capture signals and cabal is trying to prevent that from happening
07:27:05 <FunctorSalad> I did get the >20min cputime without strace too though
07:29:56 <Saizan> which version of ghc?
07:30:31 <jkramer> Does anyone know a function like this: (a, b) -> (a -> b -> (c, d)) -> (c, d) (hoogle doesn't find anything)
07:30:52 * hackagebot hashable 1.0.0 - Class Hashable providing a hash method.  http://hackage.haskell.org/package/hashable-1.0.0 (MilanStraka)
07:30:59 <jkramer> I'd also be happy with (a, b) -> (a -> c) -> (b -> d) -> (c, d)
07:31:10 <Saizan> ?type flip uncurry :: (a, b) -> (a -> b -> (c, d)) -> (c, d)
07:31:12 <lambdabot> forall a b c d. (a, b) -> (a -> b -> (c, d)) -> (c, d)
07:31:48 <Saizan> the other is \p f g -> (f *** g) p
07:32:06 <jkramer> Ah, that's better
07:32:07 <jkramer> Thanks
07:33:53 * hackagebot hashmap 1.1.0 - Persistent containers HashMap and HashSet.  http://hackage.haskell.org/package/hashmap-1.1.0 (MilanStraka)
07:33:55 <jkramer> Sweet
07:34:14 <jkramer> I have no idea what arrows are and how they work, but the operators are just sweet .)
07:35:03 <syntaxglitch> jkramer, Arrow is a type class of things that are sort of like functions... give or take
07:35:40 <Botje> arrows are parametrized over both the input and output type
07:35:41 <syntaxglitch> As it turns out, functions are indeed like functions, so they're arrows as well, and a lot of Arrow combinators are very useful for plain old functions
07:36:30 <Saizan> just pretend Control.Arrow = Data.Tuple
07:37:36 <jkramer> Saizan: Ok :)
07:37:43 <jkramer> That's something I understand :)
07:46:18 <FunctorSalad> Saizan: 6.12.3, recently custom-built..
07:47:42 <FunctorSalad> hmm I made GhcLibWays+=dyn unconditional in build.mk
07:48:03 <FunctorSalad> and uncommented GhcRtsWithFrontPanel = YES
07:48:15 <FunctorSalad> (whatever that does, I wanted to find out ;))
07:49:40 <Jafet> FrontPanel? Now I have an image of you programming ghc with punch cards.
07:50:19 <FunctorSalad> hmm I don't get the connection :)
07:50:35 <FunctorSalad> maybe I should rtfm what that option actually does
07:52:19 <FunctorSalad> The front panel is currently defunct. It offers a graphical view of the running Haskell program in real time, and was pretty cool when it worked. 
07:52:30 <FunctorSalad> </quote>
07:52:43 <FunctorSalad> sounds like it shouldn't hurt though ;)
07:54:03 <Saizan> running code that probably no one has tested in ages in your RTS doesn't sound wise :)
07:54:13 <FunctorSalad> hehe
07:54:21 <augur> anyone interested in grammar induction?
07:54:30 <dankna> me
07:56:16 <FunctorSalad> LOL the page I quoted is itself 4 years old
07:56:34 <FunctorSalad> I hope rebuilding without 'make clean' will be enough...
08:14:03 * hackagebot AC-Vector 2.3.1 - Efficient geometric vectors and transformations.  http://hackage.haskell.org/package/AC-Vector-2.3.1 (AndrewCoppin)
08:36:10 * hackagebot AC-Vector-Fancy 2.4.0 - Fancy type-system stuff for AC-Vector  http://hackage.haskell.org/package/AC-Vector-Fancy-2.4.0 (AndrewCoppin)
08:45:12 <Zao> I need a string interpolation library. Any suggestions?
08:46:28 <danlei> Text.Printf?
08:49:32 <Zao> danlei: With placeholders.
08:49:39 <Zao> (named ones, that is)
08:52:25 <danlei> Zao: ah, have no idea, but there are some links for interpolation on haskelwiki
08:52:37 <danlei> +l
08:53:14 <Zao> I'd use Perl for this, but unfortunately I don't have the ability to deploy a runtime :(
08:55:13 <Palmik> Hi guys, I might have a question to which the answer might be quite obvious (but it's not for me). The question is: Why, when foldr from Prelude can work on infinite lists and foldl can not, why is not foldl defined using foldr?
08:57:04 <Twey> Because if it were it still couldn't work on infinite lists
08:57:22 <Jafet> foldl cannot work on infinite lists because it is foldl
08:57:30 <Zao> The l and r have significance.
08:57:31 <Twey> How lazy your foldr is depends on the combination function
08:57:58 <Twey> The combining function that would turn a foldr into a foldl would make your foldr exactly as lazy as a foldl
08:58:13 <Palmik> I see
08:58:59 <Palmik> Thank you :)
08:59:08 <FunctorSalad> Saizan: Jafet : hmm rebuilding ghc seems to have fixed it ;)
08:59:56 <Jafet> You must've have spread the bones correctly this time
09:00:15 <Jafet> What's the "front panel" like?
09:00:18 <FunctorSalad> (lesson: don't enable random flags)
09:00:37 <FunctorSalad> well, I redisabled it ;)
09:01:19 <FunctorSalad> cabal is blazing fast now ;)
09:19:22 <luite> is there some standard function that does something like: mapCombinations (,) [1,2,3,4] = [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
09:20:35 <FunctorSalad> > map (\i -> [i+1..4]) [1,2,3,4]
09:20:37 <lambdabot>   [[2,3,4],[3,4],[4],[]]
09:20:47 <FunctorSalad> nvm me
09:20:51 <Twey> > heads [1 .. 4]
09:20:52 <lambdabot>   Not in scope: `heads'
09:20:56 <Twey> Er
09:20:58 <Twey> > inits [1 .. 4]
09:20:59 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4]]
09:21:05 <luite> FunctorSalad: I mean in general by the way, type:  (a -> a -> b) -> [a] -> [b]
09:21:08 <Twey> Hmm, not quite right, huh
09:21:17 <wli> use tails
09:21:21 <luite> I was thinking about using tails
09:21:23 <Twey> > tails [1 .. 4]
09:21:24 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
09:22:25 <aristid> > let mapCombinations f xs = [f x y | x <- xs, y <- filter (> x) xs] in mapCombinations (,) [1,2,3,4]
09:22:26 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
09:22:33 <Twey> > let f = uncurry (map . (,)) splitAt 1 in map f $ tails [1 .. 4]
09:22:34 <lambdabot>   Couldn't match expected type `(a1, [a])'
09:22:34 <lambdabot>         against inferred type `GHC...
09:22:41 <yitz> > let subsetsOf 0 _ = [[]]; subsetsOf n (x:xs) = map (x:) subsetsOf (n-1) xs ++ subsetsOf n xs; subsetsOf n _ = 0 in subsets of 2 [1,2,3,4]
09:22:42 <lambdabot>   <no location info>: parse error on input `of'
09:22:52 <yitz> > let subsetsOf 0 _ = [[]]; subsetsOf n (x:xs) = map (x:) subsetsOf (n-1) xs ++ subsetsOf n xs; subsetsOf n _ = 0 in subsetsOf 2 [1,2,3,4]
09:22:52 <wli> > let xs = [1 .. 4] in [(x, y) | x : _ <- inits xs, y <- ys, ys <- tails xs]
09:22:53 <lambdabot>   Couldn't match expected type `[[t]]'
09:22:53 <lambdabot>         against inferred type `t1 -> [...
09:22:53 <lambdabot>   Not in scope: `ys'
09:23:23 <yitz> > let subsetsOf 0 _ = [[]]; subsetsOf n (x:xs) = map (x:) (subsetsOf (n-1) xs) ++ subsetsOf n xs; subsetsOf n _ = 0 in subsetsOf 2 [1,2,3,4]
09:23:24 <lambdabot>   No instance for (GHC.Num.Num [[t]])
09:23:24 <lambdabot>    arising from a use of `e_101021234' ...
09:23:46 <yitz> > let subsetsOf 0 _ = [[]]; subsetsOf n (x:xs) = map (x:) (subsetsOf (n-1) xs) ++ subsetsOf n xs; subsetsOf n _ = [] in subsetsOf 2 [1,2,3,4]
09:23:47 <lambdabot>   [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
09:24:40 <eevar> > map (\x -> take 2 x) $ permutations [1..4]
09:24:41 <lambdabot>   [[1,2],[2,1],[3,2],[2,3],[3,1],[1,3],[4,3],[3,4],[3,2],[4,2],[2,4],[2,3],[4...
09:24:57 <yitz> eevar: nub
09:24:59 <carter> question: would it not be a good thing for the attoparsec docs to be slightly more clear that on a successful computation of the form "parse parser string"
09:25:15 <carter> the result type case will be a continuation for more input
09:25:23 <carter> and you need to feed that an empty string 
09:25:27 <eevar> yitz: indeed :)
09:25:30 <carter> and Then you get your result :)
09:25:32 <carter> !?
09:26:00 <carter> its a simple change, but it'd probably make getting the feet wet a lot easier for people
09:26:12 <wli> > let xs = [1..4] in [(last xs, y) | (xs@(_:_), ys) <- zip (inits xs) (tails xs), y <- ys]
09:26:13 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
09:27:19 <luite> > let mapComb f xs = concat [map (f y) ys | (y:ys) <- tails xs] in mapComb (,) [1,2,3,4]
09:27:20 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
09:27:27 <luite> I think I'll settle for this one
09:28:44 <aristid> > let mapComb f xs = do (y:ys) <- tails xs; map (f y) ys in mapComb (,) [1,2,3,4]
09:28:45 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
09:29:15 <luite> mine is basically the same, both do and list comprehensions use fail on pattern match failure
09:29:15 <aristid> @undo mapComb f xs = do (y:ys) <- tails xs; map (f y) ys
09:29:16 <lambdabot> mapComb f xs = tails xs >>= \ a -> case a of { (y : ys) -> map (f y) ys; _ -> fail ""}
09:30:36 <wli> > let mkPairs (x:xs@(_:_)) = map ((,) x) xs ++ mkPairs xs ; mkPairs _ = [] in mkPairs [1..4]
09:30:37 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
09:31:59 <Trollinator> What was the command for the bot to rewrite something in point-free style?
09:32:07 <luite> @pl
09:32:07 <lambdabot> (line 1, column 1):
09:32:07 <lambdabot> unexpected end of input
09:32:08 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:32:11 <luite> oops :)
09:34:08 <yitz> @pl let subsetsOf 0 _ = [[]]; subsetsOf n (x:xs) = map (x:) (subsetsOf (n-1) xs) ++ subsetsOf n xs; subsetsOf n _ = []
09:34:08 <lambdabot> (line 1, column 115):
09:34:09 <lambdabot> unexpected end of input
09:34:09 <lambdabot> expecting ";" or "in"
09:34:24 <yitz> @pl subsetsOf 0 _ = [[]]; subsetsOf n (x:xs) = map (x:) (subsetsOf (n-1) xs) ++ subsetsOf n xs; subsetsOf n _ = []
09:34:24 <lambdabot> (line 1, column 21):
09:34:25 <lambdabot> unexpected ";"
09:34:25 <lambdabot> expecting variable, "(", operator or end of input
09:34:26 * hackagebot pathtype 0.5 - Type-safe replacement for System.FilePath etc  http://hackage.haskell.org/package/pathtype-0.5 (BenMoseley)
09:34:28 <Trollinator> thanks. 
09:36:09 <yitz> @pl subsetsOf n xs = if n == 0 then [[]] else if null xs then [] else map (head xs:) (subsetsOf (n-1) (tail xs)) ++ subsetsOf n (tail xs)
09:36:11 <lambdabot> subsetsOf = fix (ap ((.) . flip if' [[]] . (0 ==)) . (ap (flip if' [] . null) .) . ap (ap . ((ap . ((++) .) . ap (map . (:) . head)) .) . flip flip tail . ((.) .) . (. subtract 1)) (flip flip tail .
09:36:11 <lambdabot> ((.) .)))
09:39:34 <yitz> @pl if' p th el = fromMaybe el $ guard p >> return th
09:39:34 <lambdabot> if' = (flip fromMaybe .) . (. return) . (>>) . guard
09:41:40 <luite> :t gcd
09:41:40 <lambdabot> forall a. (Integral a) => a -> a -> a
09:49:14 <RayNbow> > do re mi
09:49:16 <lambdabot>   do re mi
09:49:32 * hackagebot gtk 0.11.2 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.11.2 (AxelSimon)
10:03:07 <dankna> > do re mi fa so la ti do
10:03:08 <lambdabot>   <no location info>: parse error on input `do'
10:03:10 <dankna> aw
10:13:56 <ziman> :t re
10:13:57 <kmc> :t ?do ?re ?mi ?fa ?so ?la ?ti ?do
10:13:57 <lambdabot> String -> Doc
10:13:58 <lambdabot> Top level:
10:13:58 <lambdabot>     Occurs check: cannot construct the infinite type:
10:13:59 <lambdabot>       t = t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t -> t7
10:14:02 <kmc> :t ?do ?re ?mi ?fa ?so ?la ?ti ?do'
10:14:03 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7. (?do'::t6, ?ti::t5, ?la::t4, ?so::t3, ?fa::t2, ?mi::t1, ?re::t, ?do::t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7) => t7
10:14:27 <ziman> :t mi
10:14:29 <lambdabot> [Char]
10:14:37 <ziman> > mi
10:14:38 <lambdabot>   "do re mi"
10:14:49 <ziman> nice :)
10:16:08 <RayNbow> :t text
10:16:09 <lambdabot> String -> Doc
10:17:25 <ziman> > fix (show . mi)
10:17:26 <lambdabot>   Couldn't match expected type `GHC.Base.String -> a'
10:17:27 <lambdabot>         against inferre...
10:17:37 <ziman> > fix (show . re)
10:17:41 <lambdabot>   mueval-core: Time limit exceeded
10:20:24 <tromp> anyone else having trouble with the new version of cabal-install?
10:22:02 <Saizan> what kind of trouble?
10:24:51 <tromp> anyone else having trouble with the newNote: there is a new version of cabal-install available.     version of cabal-install?
10:25:16 <tromp> rotten paste:(
10:25:29 <tromp> i ran cabal install cabal-install
10:25:34 <Saizan> ok
10:25:48 <Saizan> you probably have two "cabal" executables installed at this point
10:25:50 <tromp> i ran cabal install cabaInstalling executable(s) in /home/tromp/.cabal/bin                              l-install
10:26:08 <Saizan> and the older is masking the newer
10:26:13 <tromp> weird, all my pastes gets messed up
10:26:30 <Saizan> compare "cabal --version" and "/home/tromp/.cabal/bin/cabal --version"
10:26:45 <tromp> anyway, after installing the new, calbal update still tells me there's a new version
10:27:20 <tromp> you're right
10:27:28 <tromp> one is 1.6.0.2
10:27:33 <tromp> other is 1.8.0.4
10:27:47 <Saizan> get rid of "which cabal" :)
10:28:59 <tromp> what's the recommended way to find ~/.cabal/bin/cabal ?
10:29:06 <tromp> put it in my PATH?
10:29:21 <Twey> Yes
10:29:25 <tromp> or can i link from the old place to there?
10:29:31 <Twey> ~/.cabal/bin should be in your PATH
10:29:49 <Twey> Preferably before anything else
10:31:08 <tromp> ok, thanks for all the help
10:50:48 * hackagebot pathtype 0.5.1 - Type-safe replacement for System.FilePath etc  http://hackage.haskell.org/package/pathtype-0.5.1 (BenMoseley)
10:54:26 <ziman> hm, that looks cool ^^
10:58:51 * hackagebot snap-core 0.2.9 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.9 (GregoryCollins)
11:03:52 * hackagebot snap-server 0.2.9 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.9 (GregoryCollins)
11:06:32 <carlosgaldino> Hi, I'm starting to learn Haskell and I'd want to know which is the best library to do TDD in Haskell. I've seen that there's QuickCheck and HUnit but I can't figure which one is recommended for beginners
11:08:27 <Lemmih> carlosgaldino: QuickCheck verifies properties. HUnit is for unit testing. So, go with QuickCheck.
11:11:27 <dons> carlosgaldino: quickcheck is best for beginners
11:11:27 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:12:59 <Mekanik> .йгше
11:17:04 <carlosgaldino> dons: Lemmih so how can I install it?
11:17:17 <Lemmih> carlosgaldino: cabal install QuickCheck.
11:19:43 <carlosgaldino> Lemmih: ok and do you know a good introduction to it?
11:20:17 <Lemmih> carlosgaldino: This is pretty decent: http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
11:22:39 <carlosgaldino> Lemmih: ok. thanks for the help
11:48:10 * ddarius hates the very existence of the world passing view of IO.
11:50:35 <Twey> Why's that?
11:51:08 <ddarius> It's a crappy model but worse, it's just a massive time-sink.
11:51:25 <vanadium> Is there a more light-weight model?
11:51:49 * Zao wants to stab haddock a bit.
11:52:20 <Zao> http://hackage.haskell.org/packages/archive/template/0.2/doc/html/Data-Text-Template.html#v%3Asubstitute
11:52:26 <RayNbow> ddarius: I can see why the world passing view is not a good model, but what do you mean with it being a time-sink?
11:52:31 <Zao> Text and Text are not the same type \o/
11:52:37 <Zao> (one is strict and the other is lazy)
11:53:27 <dolio> RayNbow: People are constantly having to explain to other people why it's a bad model.
11:54:22 <ddarius> Not only that, but defending it quickly becomes meta-physical and ill-defined.
11:55:05 <Veinor> what's the world-passing view?
11:55:12 <mauke> haha
11:55:24 <RayNbow> time for a hawiki page for "Why the world passing view is not a good model"? :)
11:55:36 <ddarius> vanadium: You can view IO as a data type that is interpreted by the run-time system or there is a continuation passing view which is sort of like a fused version of the first view.
11:55:59 <ddarius> These have the benefit of being clearly implementable and actually conceptually similar to what is actually happening.
11:56:09 <syntaxglitch> Here's my favorite mathematical formalism for IO: http://www.sciencecartoonsplus.com/gallery/math/math07.gif
11:56:16 <syntaxglitch> I think it's the best model available
11:56:17 <ddarius> Veinor: IO a = World -> (a, World)
11:56:24 <Veinor> syntaxglitch: haha
11:56:31 <Veinor> 'how does the IO monad work? nobody knows!'
11:57:06 <vanadium> ddarius: Yeah, okay
11:57:07 <Veinor> ddarius: yeah, that just seems... off
11:57:51 <merijn> syntaxglitch: I love that image :)
11:58:47 <merijn> syntaxglitch: I think you'll appreciate the "Ways to go wrong"-tally sheet: http://www.ma.utexas.edu/users/henrys/waystogowrong.html
11:59:04 <aRcatan> hmm. i going to start telling all the haskell beginners that nobody actually knows how the IO monad works
11:59:26 <Veinor> not even the ghc developers!
11:59:57 <noob-leech> merijn:  So finally, N != NP?
12:00:17 <syntaxglitch> the IO monad is the blissful ignorance that shields your beautiful programs from the true horror of the stateful world
12:00:18 <aRcatan> that's after all the impression you used to get from Haskell tutorials
12:00:31 <syntaxglitch> calling unsafePerformIO is basically like reading the necronomicon
12:00:51 <merijn> I already tell people my imperative programs operate via magic
12:01:13 <noob-leech> Mathemagicians...
12:01:14 <mauke> it's pretty simple. IO generates perl code and runs it.
12:01:34 <syntaxglitch> mauke, the evil mangler?
12:01:39 * RayNbow hasn't touched Perl in years
12:01:49 <merijn> mauke: That reminds me of the argument that C is a purely functional language :p
12:01:51 <mauke> syntaxglitch: no, that code is evil
12:02:01 <ddarius> syntaxglitch: The Evil Mangler is a static Perl program that is used when compiling (in some cases.)
12:02:14 <syntaxglitch> yes, I know
12:02:22 <syntaxglitch> the whole concept is frightening
12:02:38 <syntaxglitch> using a perl script to optimize assembly or whatever, I try not to think about it too much
12:03:13 <Twey> Hurk.
12:03:21 <mauke> s/perl/terrible perl/
12:03:26 <syntaxglitch> heh
12:03:48 <mauke> IT IS POSSIBLE TO WRITE STRUCTURED CODE IN NON-HASKELL LANGUAGES
12:03:59 <mauke> too bad the ghc developers don't believe in it
12:04:01 <ddarius> It isn't in Haskell.
12:04:35 <RayNbow> <mauke> IT IS POSSIBLE TO WRITE STRUCTURED CODE IN NON-HASKELL LANGUAGES  <--  but no one knows how? :p
12:05:42 <ddarius> mauke: The Evil Mangler grew by accretion and everyone is too scared to refactor it.
12:05:45 <Veinor> that's... atrocious
12:05:55 <Veinor> I think I just lost faith in something
12:06:06 <dolio> It's being thrown away, so why bother?
12:06:13 <pettter> xactly
12:06:30 <Twey> ‘Non-Haskell languages’, maybe, but this is *Perl* we're talking about *hides*
12:06:31 <kmc> the IO monad came to Simon Peyton-Jones in a dream
12:06:35 <ddarius> dolio: -Now- it is, but it is many, many years old.
12:06:36 <kmc> in the form of a snake eating its own tail
12:06:39 <kmc> that's why nobody knows how it works
12:06:43 <dolio> Yeah, yeah.
12:06:54 <kmc> the EM could be rewritten in Haskell
12:06:54 <mauke> Twey: perl makes it easier because it even has *subroutines*!
12:06:56 <kmc> but it would be pointless
12:06:58 <kmc> via-C is deprecated
12:07:03 <Twey> mauke: Heheh
12:07:08 <mauke> Twey: i.e. you could totally modularize your code
12:07:13 <kmc> iirc LLVM has its own mangler, but it's tiny and i don't know what language they used
12:07:18 <kmc> it might become unnecessary with newer versions of LLVM too
12:07:23 <ddarius> kmc: It -could- be rewritten in Haskell -if- people knew what the Evil Mangler does.  They do not.
12:07:28 <Twey> kmc: Deprecated, but it's probably going to continue to be used until GHC supports all the targets gcc does?
12:07:47 <Twey> Who actually wrote the Evil Mangler?
12:07:54 <Veinor> haha, there's a variable called T_STABBY
12:07:57 <Twey> Surely, at some point, someone must have known enough about what it does to append to it.
12:08:04 <mauke> Twey: no
12:08:11 <syntaxglitch> It probably wrote itself, in the dark of night
12:08:26 <mauke> they just copy/paste code that seems like it almost works, then tweak the regexes
12:08:27 <kmc> ddarius, eh, i have a *vague* idea what it does
12:08:36 <ddarius> kmc: A vague idea doesn't let you rewrite it.
12:08:45 <kmc> true, but i mean i think it could be investigated further
12:08:51 <ddarius> kmc: Have fun.
12:08:53 <kmc> i don't think it's totally impenetrable
12:08:53 <Twey> mauke: The PHP approach?
12:08:56 <kmc> i'm not volunteering though ;P
12:10:37 <RayNbow> <kmc> in the form of a snake eating its own tail  <--  are you talking about a version of Python with TCO that will never see the daylight?
12:10:38 <djahandarie> lol
12:10:45 <ddarius> kmc: The problem is it is intricately related to over a decades worth of GCC internal details, much of the code is probably no longer necessary but it is hard to be sure, and there are no doubt non-local interactions that make the code more complicated then it at first seems.
12:11:42 <bos> preflex: seen dons
12:11:42 <preflex>  dons was last seen on #haskell 1 hour and 15 seconds ago, saying: carlosgaldino: quickcheck is best for beginners
12:13:35 <telephone> I shall use OpenAL. I need to bound a buffer to a 'Source' object. How do I create a new 'Source' object?
12:13:39 <kmc> RayNbow, haha
12:14:14 * bos shakes a fist at type families
12:14:43 <kmc> RayNbow, someone on reddit said that Stackless Python has call/cc
12:14:49 <kmc> and maybe TCO as well
12:15:02 <dolio> Twey: I don't know how many platforms GHC's optimizing gcc-backend supports, but that's the only one that uses the evil mangler.
12:15:18 <djahandarie> I remember seeing that as well kmc
12:15:36 <dolio> The gcc backend for porting/bootstrapping isn't deprecated.
12:15:40 <RayNbow> kmc: hmm, I'm not familiar with the features of Stackless
12:15:49 <kmc> neither am i ;P
12:16:05 <syntaxglitch> doesn't berp support TCO and call/cc? :P There you go
12:16:14 <syntaxglitch> sure, it's missing a few other python features
12:16:34 <syntaxglitch> but call/cc, that's what really matters
12:17:23 <ddarius> syntaxglitch: Once you have call/cc and state, all other features are left as an exercise to the user.  Alternatively, you could just have delimited continuations.
12:17:42 <syntaxglitch> indeed
12:17:45 <syntaxglitch> everything else is just cruft
12:18:29 <syntaxglitch> yep, TCO and callCC: http://wiki.github.com/bjpop/berp/novelties
12:19:27 <dolio> Oh no! TCO in python? That will make it so hard to use!
12:20:26 <syntaxglitch> dolio, yes, TCO is far more confusing than call/cc
12:20:55 <vanadium> How does avoiding stack frames interfere with debugging?
12:21:02 <syntaxglitch> but python is already too confusing to be worthwhile, how can you tell where blocks end without curly brackets? ridiculous
12:21:25 <dolio> vanadium: Some people like to see stack traces when their program blows up.
12:21:25 <vanadium> Is it just that stack traces do not show all the repeated entries anymore?
12:21:30 <syntaxglitch> vanadium, because if something crashes in a tail-recursive function there's no stack trace for the previous iterations
12:21:33 <RayNbow> syntaxglitch: Python actually has curly braces ;)
12:21:46 <kmc> not in the same way Haskell does, unfortunately
12:21:50 <vanadium> Surely you can add a field that counts how often the current frame has been repeated :3
12:22:12 <mauke> while loops interfere with debugging :-(
12:22:12 <aRcatan> vanadium: but you still don't see the last arguments, nor the development of them
12:22:15 <syntaxglitch> this makes it harder to debug than, say, writing a standard "while" loop where your stack trace includes all previous loop iterations
12:22:16 <dolio> vanadium: With tail calls, there may be no record of frame at all.
12:22:16 <syntaxglitch> er, wait
12:22:18 <vanadium> point
12:22:46 <dolio> 'f x = g y ; g y = h z ; h z = <explosion>' may just show h.
12:23:04 <RayNbow> syntaxglitch, http://dpaste.com/229352/ curly braces :p
12:23:10 <dolio> Even if it was called through f.
12:23:22 <syntaxglitch> RayNbow, yes, I've seen that joke :D
12:23:44 <syntaxglitch> Python is very advanced, it supports user-defined block delimiters, so long as they start with #
12:24:20 <mauke> if you can't write code in it on IRC, it's not a real language
12:24:35 <RayNbow> recently I saw Python 2.7 now uses {} for set comprehensions
12:24:41 <dolio> There are languages with proper tail calls that do keep track of a call stack in debugging modes, though.
12:24:53 <dolio> SML-NJ, perhaps? I forget.
12:24:54 <RayNbow> and for set literals
12:25:03 <vanadium> Someone confirm my suspicion that #python will never be as great as #haskell for their lack of eval bots
12:25:36 <syntaxglitch> I dunno, at least the Python REPL lets you use whitespace syntax, unlike GHCi :(
12:26:32 <dolio> Yeah, that's a bummer.
12:26:54 * syntaxglitch grumbles about GHCi and considers writing his own Haskell REPL... would mean figuring out the GHC API though
12:27:11 <vanadium> syntaxglitch: Or just rewriting things and piping it into a hidden instance of ghci
12:27:17 <syntaxglitch> true
12:27:20 <Gracenotes> python's is pretty unambiguous. as are most lisp's.
12:27:41 <Gracenotes> lisps'?
12:28:17 <Gracenotes> you'd have the manage line breaks explicitly for the most part...
12:29:39 <Gracenotes> [more obvious things here]
12:30:30 * syntaxglitch decides to just get back to writing some Haskell
12:31:36 <merijn> vanadium: I kinda like #python because they have a lot of people willing to tell me I'm an idiot :p
12:32:14 * hackagebot pb 0.1.0 - pastebin command line application  http://hackage.haskell.org/package/pb-0.1.0 (DominikPicheta)
12:32:36 <FunctorSalad> . o O ( haste, pasty )
12:32:58 <ddarius> syntaxglitch: :{
12:33:45 <syntaxglitch> ddarius, it's just not quite the same
12:34:01 <syntaxglitch> also, isn't that pretty new anyway? Like in the last couple versions of GHCi
12:34:11 <FunctorSalad> syntaxglitch: why write your own instead of editing ghci? curious
12:34:51 <FunctorSalad> (hmm and doesn't ghci have some multiline mode now?)
12:34:59 <syntaxglitch> FunctorSalad, well, I'd probably try the latter first, yes
12:35:06 <syntaxglitch> but it's not really high on my list of things to do either way
12:35:15 <merijn> FunctorSalad: Because of NIH syndrome :p
12:35:55 <syntaxglitch> hm, this is a good time to make coffee, I think
12:36:01 <FunctorSalad> well, sometimes I'ing it here makes sense ;) (if it's easier to write than to read what exists)
12:36:13 <FunctorSalad> @quote cofree
12:36:14 <lambdabot> No quotes match. Just try something else.
12:36:39 <merijn> FunctorSalad: It's almost always easier to write than to read what exists, because reading code is fundamentally harder then writing it :p
12:37:40 <FunctorSalad> *nod*, though you usually don't have to read through *everything* ;)
12:37:51 <syntaxglitch> FunctorSalad, yes, a comathematician is a device for converting cotheorems into ffee.
12:37:57 <FunctorSalad> :)
12:38:15 <FunctorSalad> and 'tify' is not a valid option in zsh
12:38:23 <FunctorSalad> (nonotify is though)
12:38:28 <FunctorSalad> the manual points this out
12:39:00 <syntaxglitch> heh
12:39:12 <Veinor> no, not ify!
12:39:18 <Veinor> anything but ify!
12:40:03 <FunctorSalad> :D
12:40:11 <syntaxglitch> anyway, BRB, coffee time
12:41:45 <FunctorSalad> 'ify'... is that an ununsed three letter word? :O
12:42:52 <micro> win l
12:42:53 <Veinor> I believe it is!
12:49:03 <jbapple> syntaxglitch: for co-converting? nverting?
12:49:49 <Veinor> I'm going to go covote for my cosenator in ngress
12:50:26 <mauke> my cosenator covotes for me
12:50:35 <Veinor> oh yeah
12:52:13 <Veinor> in soviet corussia, tv is watched by you!
12:55:01 <syntaxglitch> very funny, mrade Veinor.
12:55:52 <Veinor> :D
12:57:42 <FunctorSalad> 'corunhaskell' is a good name for a compile-and-run-haskell program, isn't it? just to add to the nfusion
12:58:07 <Veinor> no, corunhaskell takes an interaction with a haskell program and produces source
12:58:33 <syntaxglitch> as opposed to a Haskell mpiler, which takes an executable and produces source
12:59:42 <dom96> What would be the best to create a modular IRC Bot ? i.e how could i load modules at runtime and reload them at runtime aswell?
13:00:18 <ddarius> lambdabot already does that
13:00:47 <dom96> how does it do it?
13:01:24 <JoshTriplett> :t fromMaybe (return ())
13:01:25 <lambdabot> forall (m :: * -> *). (Monad m) => Maybe (m ()) -> m ()
13:01:40 <ddarius> It uses one of the various plugins libraries (or maybe its own hacked version as lambdabot was where most of them first got tried out.)
13:01:48 <JoshTriplett> :t maybe (return ())
13:01:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
13:02:14 <dom96> oh, perhaps i can use one of the plugin libraries, thanks.
13:06:25 <lysgaard> I need some help making an instance decleration for the msgPack-rpc package. Anyone up for some tutoring?
13:18:26 * hackagebot darcs-beta 2.4.98.3 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-beta-2.4.98.3 (ReinierLamers)
13:21:57 <dom96> http://hackage.haskell.org/package/plugins-1.4.1 fails to install...
13:30:26 <Raghs> Hi - I keep getting File mode specification error: (wrong-number-of-arguments require 3) when I use Xemacs to open a hs file
13:31:40 <Raghs> anybody know how to fix the xemacs error??
13:32:30 <jedai> Raghs: pure curiosity but why do you use xemacs rather than emacs ?
13:32:56 <JuanDaugherty> same reason anybody does
13:32:58 <Raghs> i am windows 7
13:33:16 <jedai> JuanDaugherty: And that is ?
13:33:40 <JuanDaugherty> more stuff
13:33:57 <JuanDaugherty> the appearance of being better supported
13:34:37 <ulfdoz> sounds strange, emacs is supported, xemacs sometimes happens to be compatible.
13:35:03 <JuanDaugherty> and otherwise still being emacs. Additionally recently saw that initially anyway it was blessed and or initiated by R. Stallman.
13:35:22 <ddarius> Use vim, lose the drama
13:36:04 <JuanDaugherty> i use xmacs or emacs, don't pay that much attention to the diff
13:36:15 <Twey> 21:35:21 *** #emacs 381
13:36:17 <Twey> 21:35:22 *** #xemacs 3
13:36:21 <Twey> Better-supported?  :þ
13:36:21 <dom96> Does anyone know of a way i could implement plugins in my app ? or why the plugins package fails to compile?
13:36:23 <ulfdoz> hrhr
13:36:56 <Twey> dom96: hs-plugins is deprecated for GHC-as-a-library, I think
13:37:06 <Twey> http://www.haskell.org/haskellwiki/GHC/As_a_library
13:37:20 <ddarius> Twey: There are a variety of plugin packages.
13:37:39 <dom96> I could only find that one.
13:37:40 <Twey> Are there new ones?
13:37:51 <JuanDaugherty> besides general hs pkg malaise?
13:39:46 <dom96> ddarius: could you link me to other ones ?
13:40:31 <ddarius> @hackage direct-plugins
13:40:31 <lambdabot> http://hackage.haskell.org/package/direct-plugins
13:40:33 <ddarius> @hackage plugins
13:40:34 <lambdabot> http://hackage.haskell.org/package/plugins
13:40:35 <ddarius> @hackage hint
13:40:36 <lambdabot> http://hackage.haskell.org/package/hint
13:40:39 <ddarius> @hackage mueval
13:40:39 <lambdabot> http://hackage.haskell.org/package/mueval
13:41:00 <ddarius> You can also talk to the GHC API directly.
13:41:12 <ddarius> I think there is one or two others as well.
13:41:18 <dom96> nice, thanks.
13:41:48 <jedai> It was my feeling that xemacs was more innovative in past years but that gnu emacs was now mostly caught up if not in advance and that the community was bigger for gnu emacs with many packages dropping compatibilities with xemacs
13:42:10 <Twey> That's about right
13:42:20 <jedai> But I may be completely wrong (I do not follow the community closely enough to give an exact account)
13:44:12 <jedai> Raghs: Gnu emacs is available on Windows, maybe using it instead of emacs would help with your issue (if you don't have other reason to prefer xemacs)
13:44:51 <Raghs> okay. I am setting emacs now.
13:45:29 <ulfdoz> btw. I have emacs on WinXP. Works great including emacs-client.
13:45:53 <ulfdoz> Notepad++++ with proper line-end detection.
13:46:04 <Twey> Yeah, I did my computing exam on Ergoemacs on WinXP.
13:47:29 <ulfdoz> And notepad++ still fails at simple things like M-x make-directory
13:47:35 * hackagebot haskeline 0.6.2.3 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.6.2.3 (JudahJacobson)
13:48:30 <mauke> preflex: karma notepad
13:48:30 <preflex>  notepad: 2323
13:48:32 <mauke> preflex: karma notepad++
13:48:32 <preflex>  notepad++: 3
13:50:03 <ulfdoz> some ambiguity in that parser?
13:50:16 <mauke> no, why?
13:50:29 <ulfdoz> how to increase karma for "notepad"?
13:50:55 <mauke> by saying "notepad++"
13:51:41 <ulfdoz> and why does it say 2323 vor karma notepad but 3 for karma notepad++?
13:52:04 <mauke> because people said "notepad++" 2323 times
13:52:12 <mauke> but only 3 occurrences of "notepad++++"
13:52:53 <ulfdoz> ah, behaviour has changed. I thought it would be still old-style with explicit karma inrement.
13:53:41 <mauke> huh?
13:54:14 <ulfdoz> Wasn't it before, that you need to explicitly say, that you want to change the karma?
13:54:55 <mauke> no
14:13:43 * hackagebot archlinux 0.3.2 - Support for working with Arch Linux packages  http://hackage.haskell.org/package/archlinux-0.3.2 (DonaldStewart)
14:30:00 <FunctorSalad> any HSH experts? isn't there some way for a command to not consume its whole stdin?
14:30:29 <FunctorSalad> apparently this would be needed to replicate the shells's '&&' command on the haskell side
14:31:01 <FunctorSalad> ('&&' passes the leftover rest of the stdin after the first command is run to the second command)
14:31:19 <benmachine> does it?
14:31:36 <FunctorSalad> I had to test it too ;)
14:31:53 <FunctorSalad> c() { read; echo "$1: $REPLY"; }
14:31:54 <benmachine> :O
14:32:09 <FunctorSalad> foo | { c 1 && c 2 }
14:32:23 <FunctorSalad> (use your favourite foo)
14:32:39 <mauke> cat /dev/urandom
14:33:54 <FunctorSalad> I prefer 'ps' for an example multiline producer ;)
14:34:48 <FunctorSalad> anyway, I think there's no way to do this with HSH commands, since a Channel may be a String or ByteString (or a Handle, that case would be ok)
14:35:20 <FunctorSalad> but for the former two, I don't think I can determine how much was actually used without deep ghc unsafeness
14:37:26 <benmachine> you could do it with just an unsafeInterleaveIO, but it'd be pretty evil
14:37:40 <FunctorSalad> how?
14:38:01 <FunctorSalad> ah... make a pseudohandle from the string?
14:38:45 <FunctorSalad> if it's possible to make virtual handles...
15:17:06 <benmachine> FunctorSalad_: on the understanding that you never use this ever, this is what I meant: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29100#a29101 :P
15:18:20 * FunctorSalad_ copypastes and darcs send-s
15:18:31 <FunctorSalad_> ;)
15:18:34 <FunctorSalad_> but nice
15:18:47 <FunctorSalad_> that it's possible at all
15:24:00 <benmachine> FunctorSalad_: fsvo nice, sure :)
15:25:12 <aristid> hmm, hlint never has suggestions
15:25:21 <aristid> is it always like this?
15:25:49 <syntaxglitch> benmachine, I like how for writing four lines of evil you still import (<$>)
15:26:31 <benmachine> syntaxglitch: antch
15:26:33 <benmachine> *natch
15:27:09 <ddarius> Crazy kids these days
15:28:52 <FunctorSalad_> I didn't evey notice the <$>, just thought 'ok, he's pointlessly incrementing the ref and returning the element somehow' ;)
15:29:18 <FunctorSalad_> hmm or not pointless actually
15:29:24 <Veinor> ... what the heck?
15:29:48 <aristid> the IORef contains the number of forced conses, i think
15:30:09 <FunctorSalad_> benmachine: funny style, I never saw the pure transformation *outside* a (>>)
15:30:14 <aristid> no idea what to use this for
15:30:18 <syntaxglitch> aristid, hlint mostly makes trivial suggestions
15:30:44 <FunctorSalad_> aristid: to know how much of the stdin (which may be a string) a command consumed
15:30:49 <FunctorSalad_> for HSH
15:30:58 <benmachine> FunctorSalad_: oh, that would work too I guess
15:31:05 <FunctorSalad_> (to pass the remaining stdin to the next command in a &&)
15:31:09 <benmachine> how it is there is not how I wrote it originally sooo
15:31:18 <aristid> FunctorSalad_: ugh, that is terrible
15:31:28 <FunctorSalad_> better idea? :p
15:31:29 <benmachine> aristid: ref. module name
15:31:45 <FunctorSalad_> given HSH's ShellCommand class
15:31:55 <aristid> no idea what "HSH" is
15:32:35 <syntaxglitch> a library for doing shell scripting stuff in Haskell, I assume
15:32:41 <FunctorSalad_> * HSH
15:32:41 <FunctorSalad_>     Synopsis: Library to mix shell scripting with Haskell programs
15:33:13 <FunctorSalad_> "echo meow" -|- reverse
15:33:42 <aristid> that sounds evil
15:33:50 * syntaxglitch recalls being disappointed that it wasn't an interactive Haskell-flavored shell
15:33:53 <hpc> it actually sounds kinda cool
15:33:56 <syntaxglitch> though I think there might be one of those somewhere, too
15:33:57 <Silvah> Impure evil, I'd say.
15:34:09 <aristid> @hackage HSH
15:34:09 <lambdabot> http://hackage.haskell.org/package/HSH
15:34:10 <ddarius> @google hash haskell shell
15:34:12 <lambdabot> http://nellardo.com/lang/haskell/hash/
15:34:12 <lambdabot> Title: HaSh - The Haskell Shell (Home Page)
15:34:25 <FunctorSalad_> "echo meow" -|- (reverse :: String -> String) actually
15:34:40 <FunctorSalad_> instance error otherwise
15:35:28 <FunctorSalad_> Silvah: HSH itself isn't impure
15:35:41 <FunctorSalad_> you still have to run the resulting command in IO...
15:37:22 <Silvah> Does it work under Windows?
15:43:25 <FunctorSalad_> no idea
15:45:10 <FunctorSalad_> btw 6.12.3 is missing here http://www.haskell.org/ghc/docs/
15:48:45 <drhodes> print (return 4)
15:48:48 <drhodes> > print (return 4)
15:48:49 <lambdabot>   No instance for (GHC.Show.Show (m t))
15:48:49 <lambdabot>    arising from a use of `System.IO.p...
15:49:25 <benmachine> anyone know what happened to that alleged proof of P = NP?
15:49:31 <benmachine> I remember reading about it in here about a week ago
15:49:34 <benmachine> then I forgot about it
15:49:55 <aristid> :t print (return 4)
15:49:56 <lambdabot>     No instance for (Show (m t))
15:49:56 <lambdabot>       arising from a use of `print' at <interactive>:1:0-15
15:49:57 <lambdabot>     Possible fix: add an instance declaration for (Show (m t))
15:50:26 <benmachine> :t print (return 4 :: [Integer])
15:50:27 <lambdabot> IO ()
15:50:45 <kmc> benmachine, it was P ≠ NP
15:50:53 <kmc> and i think it's regarded as flawed
15:51:08 <benmachine> kmc: yeah, ≠, okay
15:51:13 <syntaxglitch> it was P != NP, and I think what happened is that most people in the field decided it was probably sufficiently flawed as to not be immediately interesting
15:51:27 <kmc> i think they agree it's interesting
15:51:31 <kmc> new approaches etc
15:51:39 <drhodes> http://rjlipton.wordpress.com/2010/08/10/update-on-deolalikars-proof-that-p%E2%89%A0np/#comment-4885
15:51:47 <drhodes> terrence tao's take on it
15:52:31 <syntaxglitch> interesting in the techniques, probably not interesting in the sense of "going to prove N != NP any time soon"
15:52:39 <syntaxglitch> from what I heard, at least
15:54:40 <medfly> man, terrence tao is like a mathematics superstar, huh
15:55:49 <drhodes> oops I linked to the wrong blog >.<
15:55:55 <drhodes> same layout ..
16:18:20 * hackagebot x11-xim 0.0.2 - A binding to the xim of X11 graphics library  http://hackage.haskell.org/package/x11-xim-0.0.2 (YoshikuniJujo)
16:23:38 <chrisdon`> man, javascript is hard
16:23:45 <chrisdon`> I need types somehow
16:24:08 <chrisdon`> I'm trying to refactor a codebase and it's a nightmare without types
16:25:12 <chrisdon`> me: "I'm pretty sure this is correct" javascript: "yeah, sure, whatever"
16:25:26 <Veinor> haha
16:26:00 <shachaf> chrisdon`: Are you using ===, at least?
16:26:03 <chrisdon`> I wonder if there's a type annotation based on comments out there
16:26:11 <drhodes> google has one
16:26:24 <drhodes> closure 
16:27:19 <drhodes> http://code.google.com/closure/compiler/docs/js-for-compiler.html
16:27:59 <chrisdon`> oh nice one
16:28:37 <drhodes> I jvaem
16:28:59 <drhodes> haven't used it much, only just to see how it worked.
16:30:34 <chrisdon`> oh, the @this tag is good
16:35:18 <chrisdon`> this is more or less ideal, thanks
16:36:58 <blackdog> what does @this do?
16:37:27 <chrisdon`> ensures the type of `this'
16:37:52 <chrisdon`> it's often the case that you'll accidentally call a function with the wrong object context (essentially the `this' value is wrong)
16:38:14 <chrisdon`> this.foo() vs (function(){ this.foo(); })(); // different
16:38:32 <blackdog> oh, right.
16:41:06 <ddarius> self = this
16:41:39 <chrisdon`>  that's a common solution
16:42:41 <Phyx-> 01:37:49 < chrisdon`> this.foo() vs (function(){ this.foo(); })(); // different
16:42:46 <Phyx-> <-- not valid haskell
16:47:47 <bss03> @djinn (Monad m, Monad md, Monad mf) (a -> md ()) -> (a -> b -> mf()) -> m (md (), mf ())
16:47:47 <lambdabot> Error: Undefined type Monad
16:47:53 <bss03> @djinn (Monad m, Monad md, Monad mf) => (a -> md ()) -> (a -> b -> mf()) -> m (md (), mf ())
16:47:53 <lambdabot> -- f cannot be realized.
16:48:28 <bss03> @djinn-env
16:48:28 <lambdabot> data () = ()
16:48:28 <lambdabot> data Either a b = Left a | Right b
16:48:29 <lambdabot> data Maybe a = Nothing | Just a
16:48:29 <lambdabot> data Bool = False | True
16:48:29 <lambdabot> data Void
16:48:30 <lambdabot> type Not x = x -> Void
16:48:32 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
16:48:34 <lambdabot> class Eq a where (==) :: a -> a -> Bool
16:49:15 <bss03> @djinn a -> Maybe b -> Either a b
16:49:16 <lambdabot> f a b =
16:49:16 <lambdabot>     case b of
16:49:16 <lambdabot>     Nothing -> Left a
16:49:16 <lambdabot>     Just c -> Right c
16:49:16 <copumpkin> bss03: where do you expect it to get the b from?
16:49:45 <copumpkin> @djinn (Monad m, Monad md, Monad mf) => (a -> md ()) -> (a -> b -> mf()) -> b -> m (md (), mf ())
16:49:46 <lambdabot> -- f cannot be realized.
16:49:49 <aristid> :t maybe Nothing Just
16:49:50 <lambdabot> forall a. Maybe a -> Maybe a
16:49:53 <copumpkin> @djinn (Monad m, Monad md, Monad mf) => (a -> md ()) -> (a -> b -> mf()) -> a -> b -> m (md (), mf ())
16:49:54 <lambdabot> -- f cannot be realized.
16:50:09 <copumpkin> o.O
16:50:18 <aristid> :t \x -> maybe (Left x) Right
16:50:19 <lambdabot> forall a b. a -> Maybe b -> Either a b
16:50:27 <aristid> @pl \x -> maybe (Left x) Right
16:50:27 <lambdabot> flip maybe Right . Left
16:51:07 <bss03> copumpkin: Just trying it out, I didn't expect it do really know.
16:51:29 <bss03> copumpkin: In my case a = FilePath and b = FileStatus
16:51:38 <copumpkin> why three different monads?
16:52:08 <bss03> md = State [FilePath] -- a directory stack.
16:53:19 <bss03> mf = State (Map FileOffset (Map FileUID FileInfo)) -- the data I'm building, via modify/alter.
16:53:24 <bss03> m = IO
16:56:40 <tolkad> When I write lots of code and try to compile it I get type errors
16:56:47 <tolkad> and they never make any sense
16:57:04 <tolkad> so I add some casts to the type I think it should be
16:57:12 <tolkad> and then the type error moves somewhere else
16:57:31 <tolkad> and finally I find the problem on a line of code somewhere far away
16:57:31 <bss03> Casts?
16:57:34 <jmcarthur> that means you have two type errors ;)
16:57:36 <tolkad> the :: thing
16:57:39 <jmcarthur> annotations
16:58:22 <jmcarthur> tolkad: adding annotations doesn't necessarily throw a type error exactly where you add it, but it can help you isolate the location as you add more and more
16:58:34 <kmc> those aren't casts
16:58:37 <chrisf> maybe "When I write lots of code and try to compile it I get type errors" suggests a faulty process ;)
16:58:39 <jmcarthur> this is just a part of how type unification works
16:58:42 <chrisf> small steps.
16:58:49 <kmc> the word "cast" is used for two different things in C, but that isn't either
16:58:52 * bss03 agrees with chrisf.
16:59:02 * jmcarthur does too
16:59:15 <kmc> chrisf, it suggests that most code is buggy and that the type checker is good at finding bugs
16:59:27 <kmc> the bad process might be "lots of code"
16:59:31 <kmc> write a little code and type check it
16:59:43 <bss03> I think writing smal bits of code and compiling will help prevent your type/kind errors from casading.
16:59:45 <Martty> that's what hes suggesting
16:59:49 <kmc> i see
17:00:02 <tolkad> chrisf: well, I think I'll make less mistakes with more practice. I often forget to split IO operations onto seperate lines and end up with IO (A (IO B))
17:00:29 <Martty> tolkad what i'd do is copy paste seperate chunks which are said to be causing these errors and study them in isolation
17:00:40 <Martty> copy paste into different modules that is
17:00:47 <chrisf> ideally, you want the pieces to be so simple that they are obviously correct by inspection.
17:01:09 <tolkad> ooh... I have 40+ line functions...
17:01:13 <kmc> wow
17:01:15 <kmc> that's surprising
17:01:16 * Martty burps
17:01:32 <kmc> tolkad, how? are you putting everything into a big "where" block?
17:01:33 <tolkad> well lots of lets and wheres
17:01:35 <kmc> ok
17:01:38 <kmc> maybe break it up more
17:01:39 <Martty> chrisf i hope that includes compiler error inspections..!
17:01:42 <monochrom> there is usually an obvious way to trim the code and still reproduce the same error.
17:01:43 <chrisdon`> tolkad: -Wall would prevent IO (A (IO B))
17:01:52 <bss03> My largest one so far is 25 lines.
17:01:52 <kmc> top-level bindings are easier to test in isolation
17:02:02 <tolkad> chrisdon`: thanks, I'll try that
17:02:19 <bss03> 24 of those are a where clause with a nested 12 line where cluase.
17:02:43 <chrisdon`> tolkad: at least, -fwarn-unused-do-binding might
17:03:55 <tolkad> I have a question, if you want to pattern match something but also use the un-pattern-matched version, is it more efficient to use PatternGuards syntax than to call the constructor again?
17:04:04 <kmc> don't call the constructor again
17:04:08 <kmc> it will rebuild the data
17:04:09 <kmc> reallocate
17:04:12 <kmc> use an @-pattern
17:04:19 <bss03> Calling the constructor again will create another object.
17:04:25 <kmc> > case "foobar" of x@(y:ys) -> (x,y,ys)
17:04:26 <lambdabot>   ("foobar",'f',"oobar")
17:04:30 <kmc> tolkad, ^^^^
17:04:41 <tolkad> ooh, didn't know about that. is that standard haskell?
17:04:45 <monochrom> yes
17:04:47 <kmc> yes
17:05:01 <bss03> Definitely use @, even if it makes your patterns lazy.
17:05:10 <kmc> @ makes patterns lazy?
17:05:11 <monochrom> in SML it is "x as (y::ys)"
17:05:27 <monochrom> @ does not change strictness
17:06:08 <tolkad> what's this strict/lazy stuff? does it have anything to do with that ! thing?
17:06:19 <kmc> ! is used for strictness annotations
17:06:34 <monochrom> yes
17:06:45 <tolkad> @hoogle a -> b
17:06:46 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:06:46 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
17:06:46 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:06:47 <etpace> are all instances exported without need to declare them? 
17:06:54 <Veinor> etpace: I think so.
17:06:57 <syntaxglitch> no no no, ! is for emphasis. You use it to tell the compiler that you REALLY mean something
17:06:59 <bss03> "in Haskell, pattern bindings are assumed to have an implicit ~ in front of them" -- http://www.haskell.org/tutorial/patterns.html
17:07:02 <kmc> the technical definition is that f is strict in its argument if «f ⊥ = ⊥»
17:07:07 <bss03> I thought that mean "@" made things lazy.
17:07:08 <tolkad> syntaxglitch: ok, thanks
17:07:18 <tolkad> syntaxglitch: sort of like please in intercal?
17:07:24 <syntaxglitch> yes, same idea
17:07:26 <kmc> bss03, no, it means that "let" and "where" and top-level bindings are lazy
17:07:27 <kmc> i think
17:07:53 <etpace> I thought so too Veinor, so this no instance error is confusing me
17:08:13 * syntaxglitch sprinkles his program with PLEASE DON'T GIVE UP
17:08:29 <Wolfspaw> is it possible to create a data/newtype which is a list of a specific length? If yes, how?
17:08:46 * chrisf sprinkles his program with COME FROM, too.
17:08:49 <kmc> a "pattern binding" is a type of declaration. as opposed to a function binding
17:08:52 <ezyang> Are there any packages that let you write code as if it was evaluated in normal order or call-by-value? 
17:08:54 <kmc> bindings live in let and where and top-level
17:09:00 <ezyang> Using something like functorial style and deepseq. 
17:09:06 <syntaxglitch> COME FROM is one of the best flow control operators ever
17:09:17 <ezyang> Wolfspaw: Yes; you can have a tuple of N elements. 
17:09:20 <shachaf> syntaxglitch: Unfortunately it works with labels and not with line numbers.
17:09:32 <drhodes> > liftM print (return 45)
17:09:33 <lambdabot>   No instance for (GHC.Show.Show (m (GHC.IOBase.IO ())))
17:09:34 <lambdabot>    arising from a us...
17:09:49 <Wolfspaw> ezyang: hm, can you give me an example? Im a bit lost on how to do it xD
17:10:07 <kmc> Wolfspaw, data Foo a = Foo (a,a,a,a,a)
17:10:12 <ezyang> Wolfspaw: data TenArray a = TenArray a a a a a a a a a a 
17:10:20 <kmc> yeah, listen to ezyang 
17:10:24 <kmc> my tuple type is redundant
17:10:46 <Wolfspaw> ezyang,kmc hm, is there a less tedious way, considering for example a type consisting of a list of 1 thousand elements?
17:10:55 <kmc> Wolfspaw, kind of
17:10:58 <ezyang> Wolfspaw: Then you probably want type level numbers. 
17:10:59 <bss03> I think I get it.  A pattern binding is stuff | guards = things where stuff is a pattern, not a "function call".
17:11:03 <kmc> Wolfspaw, this basically involves encoding numbers at top level
17:11:15 <ezyang> But that's not much fun if you don't love the typechecker. 
17:11:31 <Wolfspaw> lol, ok. I'll see what i can do xD
17:11:33 <tolkad> I have a better idea. Next time I get a type error, I'll throw in a unsafeCoerce
17:11:50 <kmc> Wolfspaw, like so 
17:11:54 <syntaxglitch> why not ThousandArray a = TenArray (TenArray (TenArray a)))
17:11:56 <bss03> tolkad: Sounds like a recipe for run-time crashes.
17:11:56 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29110#a29110
17:12:06 <kmc> tolkad, great idea, what can go wrong
17:12:30 <dibblego> @src permutations
17:12:31 <lambdabot> Source not found. Are you on drugs?
17:12:34 <dibblego> boo
17:13:05 <Wolfspaw> kmc: hm , ok
17:13:23 <shachaf> @let iaep e [] = [[e]]; iaep e (x:xs) = (e : x : xs) : (map (x:) (iaep e xs))
17:13:25 <lambdabot>  Defined.
17:13:42 <shachaf> @let permutations [] = [[]]; permutations (x:xs) = concatMap (iaep x) (permutations xs)
17:13:43 <lambdabot>  <local>:7:66:
17:13:44 <lambdabot>      Ambiguous occurrence `permutations'
17:13:44 <lambdabot>      It could refer t...
17:13:55 <mauke> @undefine
17:13:56 <shachaf> @let perm [] = [[]]; permutations (x:xs) = concatMap (iaep x) (perm xs)
17:13:57 <lambdabot>  <local>:1:49: Not in scope: `iaep'
17:17:26 <Wolfspaw> kmc: hm, im too newbie yet to fully grasp your example but i get the ideia. Thanks!
17:17:48 <kmc> no problem Wolfspaw :)
17:17:51 <kmc> i can try to explain it more
17:17:56 <kmc> and you'll find lots of examples similar to this
17:18:03 <kmc> on the topic of "type-level natural numbers" and such
17:18:07 <kmc> but it is pretty cumbersome
17:18:29 * ezyang still can't wait for byorgey's summer project to get put into mainline GHC :-))) 
17:18:36 <Veinor> what's his summer project?
17:20:32 <ezyang> http://byorgey.wordpress.com/2010/06/29/typed-type-level-programming-in-haskell-part-i-functional-dependencies/ 
17:21:37 <Axman6> > iaep 'a' "hello"
17:21:38 <lambdabot>   Not in scope: `iaep'
17:21:45 <Axman6> @let iaep e [] = [[e]]; iaep e (x:xs) = (e : x : xs) : (map (x:) (iaep e xs))
17:21:46 <lambdabot>  Defined.
17:21:48 <Axman6> > iaep 'a' "hello"
17:21:50 <lambdabot>   ["ahello","haello","heallo","helalo","hellao","helloa"]
17:21:55 <Axman6> :o
17:22:14 <Wolfspaw> kmc: List n a, is a list of n elements of type a right?. and Nil and Cons are functions of that data type? The Nil confuses me, Cons will "glue" together 2 Lists? (Im specially lost in data List)
17:22:39 <kmc> Wolfspaw, well, this is GADT syntax
17:22:44 <kmc> it's different from regular Haskell type declarations
17:22:47 <kmc> (it's a GHC extension)
17:22:53 <ezyang> Matching on GADTs refines types!!! 
17:22:56 * ezyang goes back to his hole. 
17:23:24 <kmc> Nil  :: List Z a
17:23:37 <kmc> that can be read literally, declaring that "Nil" is a term of type «List Z a»
17:23:49 <kmc> "Nil" is a list of 0 elements, where the elements have type 'a'
17:23:53 <kmc> a can be anything
17:24:18 <kmc> we're using inductively-defined natural numbers.  0 = Z,  1 = S Z,  2 = S (S Z), etc.
17:24:29 <kmc> so Nil is an empty list of any type
17:24:33 <kmc> and Cons adds one element to a list
17:24:37 * hackagebot bird 0.0.17 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.17 (MattParker)
17:24:58 <SubStack> beh, not another one
17:25:11 <Wolfspaw> kmc: hm, nice. Now that you mentioned S means Sucessor, things are more clear
17:25:17 <kmc> ah
17:25:22 <SubStack> web frameworks should play to a language's strengths
17:25:26 <kmc> yes, that is an important detail i omitted
17:25:52 <tias> question regarding template haskell; for my splice to generate valid code i need to know if a value (with a particular name) is already defined and then generate code appropriately (eg generate a definition for the missing type)
17:26:18 <Wolfspaw> kmc: in normal haskell, if you have a data Z for example, can you make Z a , and it will "ignore" the a type? is strange for me Z not having a type parameter, and being passed one @o@
17:26:24 <FunctorSalad_> hmm do I have to supply my own dynflags for ghc?
17:26:27 <FunctorSalad_> (ghc api)
17:26:46 <kmc> no Wolfspaw 
17:26:56 <kmc> if you say "data Z = ..." you cannot use "Z a" as a type, any more than you can use "Char a"
17:27:01 <kmc> but i'm not doing that here
17:27:13 <FunctorSalad_> _+_lhbin_+_bro2: panic! (the 'impossible' happened)
17:27:14 <FunctorSalad_>   (GHC version 6.12.3 for i386-unknown-linux):
17:27:14 <FunctorSalad_>         no package state yet: call GHC.setSessionDynFlags
17:27:20 <kmc> Z is not parametrized; it doesn't have a type argument
17:27:44 <FunctorSalad_> I thought setting them was optional (if not, anyone got some dynflags for me?)
17:28:19 <Wolfspaw> kmc: hm, ok. But a Z alone is strange for me o_o, even more strange is the fact you can say "Z elements are of type a, even though Z is alone". 
17:28:41 <FunctorSalad_> hmm I'll try DynFlags.defaultDynFlags
17:28:44 <kmc> why is that strange?
17:28:52 <shachaf> Wolfspaw: Why does Z alone seem any stranger to you than Int alone?
17:28:56 <kmc> "here is a bag of zero apples"
17:29:56 <Wolfspaw> shachaf, kmc : but when declaring a data that representes a kind of container. Shouldnt it be something like: [a] , or [] a ?
17:30:04 <kmc> Z is not a container
17:30:07 <kmc> Z holds no data at all
17:30:10 <kmc> it has no runtime values
17:30:16 <kmc> it only exists to be a type parameter to List
17:30:41 <kmc> List holds data in the "Cons" constructors
17:30:45 <kmc> the first argument thereof
17:32:23 <kmc> Wolfspaw, are you ok with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29112#a29112 ?
17:32:32 <kmc> this is ordinary lists, exactly equivalent to the builtin []
17:32:34 <kmc> but defined with GADT syntax
17:32:54 <Wolfspaw> kmc: ok, let me see
17:34:59 <Wolfspaw> kmc: im okay, and understood it. But this is all it takes to ghc to know how to cons 2 Lists? I understand that Cons will receive a value of type a, a list with elements of type a, and return a list with elements of type a. But ghc will infer that this new list will have the new element in the end?
17:35:17 <kmc> well, Cons does not cons two lists
17:35:25 <kmc> it adds one more element onto the head of a list
17:35:26 <Wolfspaw> i mean a list, and a element xD
17:35:45 <kmc> the answer is that it is enough
17:35:55 <kmc> as it is enough merely to say «data List a = Nil | Cons a (List a)»
17:36:31 <kmc> it sounds like your question is, how does GHC know what the Cons constructer should do, just from its type?
17:36:37 <kmc> the answer is that constructors never do anything
17:36:43 <kmc> they just hold their arguments and wait to be pattern matched
17:37:21 <Wolfspaw> kmc: hmm, yeah that was my question. Im starting to see now
17:37:29 <kmc> so the new element goes on the head of the list.  all this means is that we've defined the informal term "the head of the list" to correspond to the first field of "Cons"
17:37:52 <kmc> it's not something in the program at all.  it's part of our vocabulary in how we interpret the program
17:38:03 <megajosh2> Hey does anybody here use SHIM for vim?
17:38:13 <megajosh2> I can't get it to work because of a syntax error
17:38:38 <Wolfspaw> kmc: so in the end a list would be:   Cons a ( Cons a ( Cons a ( Cons a nil) ) )
17:38:44 <kmc> right
17:38:58 <kmc> we'd write [1,2,3,4] as:  Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil)))
17:39:13 <kmc> in fact [1,2,3,4] is defined to be sugar for 1 : 2 : 3 : 4 : []
17:39:35 <kmc> and that's equivalent to the above, if you define (:) to be an infix operator equivalent to Cons, and [] to be a synonym for Nil
17:39:59 <kmc> in the GHC base library source you will actually see «data [] a = a : ([] a) | []»
17:40:08 <kmc> though this syntax is not allowed in normal user code
17:41:26 <Wolfspaw> kmc: alright, those examples enlightned me. Thanks!
17:41:39 <kmc> no problem :)
17:42:27 * syntaxglitch shakes his fist at being unable to define his own outfix operators
17:44:08 <mauke> *circumfix
17:44:30 <syntaxglitch> hm, that's a good term
17:44:35 <Phyx-> :/
17:45:12 <Veinor> syntaxglitch: like what?
17:45:17 <Veinor> []?
17:45:38 <syntaxglitch> yes, defining custom "operators" that work like []
17:46:03 <copumpkin> [_]
17:46:14 <Wolfspaw> yeah, it would be cool xD
17:46:16 <Veinor> you can in perl 6!
17:46:27 <copumpkin> haskell needs agda's mixfix parsing :)
17:46:43 <Veinor> say "subset" if ⦃ 1, 3, 5 ⦄ ⊆ ⦃ 1, 2, 3, 4, 5 ⦄;
17:47:08 <copumpkin> but then you lose a few other things
17:47:13 <Veinor> like?
17:48:15 <copumpkin> ?
17:48:26 * syntaxglitch also thinks it would be fun if the "juxtaposition operator" was a type class method but that would probably be unwise
17:48:38 <copumpkin> yeah, I've wanted that before
17:48:44 <Veinor> juxtaposition operator?
17:49:14 <copumpkin> Veinor: the invisible function application operator :)
17:49:41 <Veinor> elaborate?
17:49:42 <syntaxglitch> Veinor, the "putting things next to each other" operator, e.g., whitespace between identifiers
17:49:49 <Veinor> ahh.
17:50:18 <Veinor> what use case did you have in mind?
17:50:19 <syntaxglitch> in particular, overloading the juxtaposition operator would be really nice instead of <*>
17:50:28 <syntaxglitch> possibly =<< as well
17:50:48 <shachaf> Never mind programmable semicolons, we want programmable whitespace!
17:52:10 <Wolfspaw> shachaf: xDDD
17:52:58 <conal> syntaxglitch: i wonder how we could disambiguate for the '(->) a' applicative
17:53:54 <conal> (disambiguate jux)
17:54:06 <syntaxglitch> conal, just some bit of crufty explicit syntax I suppose
17:54:39 <syntaxglitch> I think it'd be a net win to get cleaner syntax for other applicatives
17:55:18 <dolio> How about idiom brackets instead?
17:55:21 <dolio> And you can have those with SHE.
17:55:40 <syntaxglitch> yeah, idiom brackets are a much more sensible idea
17:55:58 <syntaxglitch> overloading juxtaposition directly would be entertaining but probably not a good idea in reality :)
17:56:34 <kmc> can we think of idiom brackets as scoped overloading for juxtaposition?
17:57:01 <dolio> I think the SHE stuff is actually fancier than that.
17:57:05 <syntaxglitch> kmc, now just combine that with the "overloading outfix operator" stuff from before and we'll be set
17:57:19 <dolio> (| x * y |) = (*) <$> x <*> y or something.
17:58:58 <drp> I'm looking for some help with some code where modifyMVar isn't replacing the mvar.  Here's a contrived example of the problem I'm hitting: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29114
17:59:15 <drp> Can anyone offer any advice?
18:00:07 * syntaxglitch ought to write his own Haskell dialect/preprocessor/whatever so that he can try out stupid ideas like overloaded juxtaposition
18:00:39 <ezyang> drp: The exception is in pure code. 
18:00:49 <ezyang> So I don't think your handler is going to see it. 
18:00:53 <ezyang> You probably want 'evaluate' instead. 
18:01:08 <drp> inside the modifyMVar?
18:01:33 <ezyang> yes. 
18:01:44 <ezyang> return will not force the pure computation. 
18:01:48 <Cale> drp: Yeah, perhaps in place of return. Catching exceptions thrown from pure code is a sketchy thing to do though, so you should usually try to design things such that you don't have to.
18:02:18 <syntaxglitch> Throwing exceptions from pure code is sketchy if you ask me!
18:02:18 <Cale> (For instance, by using Maybe)
18:02:46 <drp> Right.  This is running in some server code, and the idea is the server should keep going even if I do have a bug somewhere
18:03:03 <drp> So the exceptions aren't really by design
18:05:01 <prey_alone> How do I concatenate (++) IO Strings?
18:05:40 <Phyx-> liftM2 (++)
18:06:31 <ahihi> this code keeps overflowing the stack when run with a large amount of tries: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29115#a29115
18:06:37 <ahihi> does anyone see any obvious problems?
18:06:55 <kmc> prey_alone, it doesn't make sense, as an IO String is not anything like a String
18:07:15 <kmc> an IO String is a "recipe" for how you could generate a string, at a later time, by doing some IO
18:07:28 <prey_alone> kmc: I'll pastebin my code in a few seconds. I want to select random strings from lists and concatenate them together.
18:07:42 <kmc> you can't concatenate two recipes, since recipes aren't lists
18:07:54 <kmc> you can run the two recipes in order and return the concatenation of the results
18:07:59 <kmc> that's what liftM2 (++) will do
18:08:09 <syntaxglitch> although you can make a recipe for the concatenation of following two string recipes
18:08:10 <prey_alone> kmc: http://pastebin.com/xDMM5Xr4
18:08:12 <kmc> the result is another recipe
18:08:29 <Martty> dem tasty monads
18:08:47 <kmc> prey_alone, i think you want "feature <- pick features" rather than "let feature = pick features"
18:09:03 <tolkad> does unsafePerformIO make the IO magically move up through the types until it gets to a place where IO is actually allowed?
18:09:09 <kmc> tolkad, no
18:09:16 <prey_alone> kmc: thanks
18:09:16 <kmc> it just performs the IO whenever that value is forced
18:09:19 <Cale> ahihi: The 'go' in countSuccesses doesn't evaluate its second parameter ever.
18:09:22 <Phyx-> tolkad: don't mention unsafePerformIO to new comers
18:09:26 <kmc> "pick features" has type "IO String", meaning it's a recipe
18:09:35 <Cale> ahihi: So a big expression is going to build up there.
18:09:50 * hackagebot x11-xim 0.0.3 - A binding to the xim of X11 graphics library  http://hackage.haskell.org/package/x11-xim-0.0.3 (YoshikuniJujo)
18:10:02 <tolkad> Phyx-: why not?
18:10:02 <kmc> prey_alone, and when you say "let feature = pick features", you're just creating a new local name for the recipe
18:10:08 <kmc> you don't run the recipe
18:10:08 <Cale> ahihi: My first guess would be that evaluating that big expression is what causes the stack overflow.
18:10:15 <kmc> in Haskell, equals means equals
18:10:33 <drp> Thanks for the tip about 'evaluate' does just what I need
18:10:35 <syntaxglitch> hm, if you have a recipe for writing a recipe for some kind of thing, you can convert that to just a recipe for that kind of thing, so maybe a recipe is a monad
18:10:41 <kmc> <- is used to run a recipe and get a result, in the context of a bigger recipe written in "do" notation
18:10:47 <prey_alone> kmc: I'm new to FP, but I knew before I starting coding this program that System.Random would introduce difficulties.
18:10:56 <kmc> prey_alone, this isn't about FP in general
18:10:58 <tolkad> prey_alone: if you want to do IO anywhere put «import System.IO.Unsafe» at the top of your file and put use unsafePerformIO to get stuff out of IO
18:11:01 <kmc> it's about features somewhat unique to Haskell
18:11:04 <Phyx-> tolkad: because they should not need it, if they don't know what IO is, using unsafePerformIO is very bad
18:11:06 <kmc> tolkad, that's bad advice
18:11:12 <ahihi> Cale: ah, I see
18:11:15 <kmc> tolkad, please do not give beginners bad advice
18:11:18 <Phyx-> prey_alone: please ignore tolkad's advice
18:11:20 <ahihi> Cale: what would be the appropriate way to make it stricter there?
18:11:31 <kmc> tolkad, what is your motivation in doing so?
18:11:36 <tolkad> kmc: It was conditional advice
18:11:41 <kmc> tolkad, oh?
18:11:43 <prey_alone> I'm looking for the safest and best practice way to randomly select elements from lists.
18:11:49 <tolkad> kmc: "if you want to do IO anywhere"
18:11:53 <tolkad> kmc: that might be a bad idea
18:12:01 <tolkad> kmc: but I did not say it was or was not
18:12:03 <kmc> tolkad, your phrasing is highly misleading and i think you know this
18:12:14 <tolkad> kmc: ok sorry I wont do it anymore
18:12:39 <kmc> prey_alone, the simple safe way is to use IO, as you are doing, and to run the action in a "do" block with "feature <- pick features"
18:12:44 <Cale> ahihi: I would probably just write   countSuccesses experiment tries = fmap (length . filter id) (replicateM tries experiment)
18:12:52 <tolkad> prey_alone: don't use unsafePerformIO because it will cause unexpected side effects and ruin everything and possible kill your parents
18:13:01 <Phyx-> wtf..
18:13:07 <prey_alone> calm down guys
18:13:11 <monochrom> are you just trolling
18:13:15 <kmc> tolkad, perhaps you should stop talking
18:13:19 <kmc> just for a bit
18:13:19 <tolkad> ok
18:13:23 <Wolfspaw> rofl
18:13:25 <kmc> prey_alone, this may be useful: http://haskell.org/haskellwiki/Introduction_to_IO
18:13:52 <kmc> prey_alone, btw i like your choice of haskell exercise :)
18:13:55 <mauke> and then you'll dress up as a bat and haunt the night
18:14:01 <prey_alone> kmc: thanks
18:14:14 <Cale> ahihi: That might not work out cleanly because of Int vs. Integer, but you can stick some fromIntegrals in if it's a problem.
18:15:43 <Cale> ahihi: More directly, you could also just stick a bang pattern in for the successes parameter
18:16:00 <Cale> ahihi: go triesLeft !successes | ...
18:16:06 <Wolfspaw> Im curious in the debbuging process of haskell programs. Right now im just using error ( "x is: " ++ (show x) ), etc =p. And ghci, what is the "profissional" debbugging process?
18:16:08 <Cale> ahihi: Or use seq
18:16:37 <kmc> Wolfspaw, instead of error you could use trace from Debug.Trace
18:16:48 <Wolfspaw> hm @.@
18:16:54 <Cale> ahihi: successes `seq` go (triesLeft - 1) (successes + bool 1 0 success)
18:16:56 <kmc> ghci is a big part of it
18:17:03 <kmc> ghci has a debugger mode too, but afaik it's not much used
18:17:10 <kmc> quickcheck can be useful too
18:17:23 <kmc> for finding bugs, and small test cases
18:17:45 <Wolfspaw> ok o>
18:18:07 <kmc> bugs in Haskell programs that get past the type checker are usually tricky logic errors, not typos or memory corruption
18:18:16 <kmc> so it's a bit different from debugging C
18:18:36 <Wolfspaw> yes, its always some logic or erros in my pattern matchings logic xD
18:18:47 <syntaxglitch> my preferred debugging technique is putting things in the toplevel and trying them out in GHCi
18:19:03 <Axman6> With haskell, you skip the easy bugs, and skip straight to the hard ones
18:19:04 <syntaxglitch> one of the nice things about pure code is that you can inspect things in isolation more easily
18:19:11 <Phyx-> :t unsafePerformIO
18:19:12 <lambdabot> Not in scope: `unsafePerformIO'
18:19:26 <ahihi> Cale: I actually tried a replicateM-based approach first, but seemed to get some kind of leak there
18:19:28 <kmc> Wolfspaw, ghc -Wall can find some missing pattern matches, etc
18:19:35 <Phyx-> just wondering, for all pure values is (unsafePerformIO.return) == id?
18:19:45 <kmc> what's a "pure value"?
18:19:47 <ahihi> Cale: the bang pattern works wonderfully though, I think that'll suffice. thanks! :)
18:20:08 <Wolfspaw> syntaxglitch: yes xD, i dont know what exactly is putting things in the top level, that would be putting everything as top functions, instead of where functions for example?
18:20:14 <Phyx-> kmc: non-IO
18:20:23 <kmc> why would IO-typed values be special?
18:21:35 <kmc> Phyx-, anyway, i think the answer is "yes" for GHC's implementation of IO
18:21:52 <kmc> i'm not sure if there's an implementation-independent spec for unsafePerformIO
18:21:54 <Cale> ahihi: Quick question, are you compiling with -O or -O2?
18:22:03 <ahihi> Cale: -O2
18:22:16 <Cale> ahihi: Huh, I suppose it's still possible that replicateM would be leaky.
18:22:17 <syntaxglitch> Wolfspaw, yeah
18:22:40 <syntaxglitch> Wolfspaw, I'll often move things out of where clauses temporarily while working on the code, then put them back when I'm done, heh
18:22:45 <Cale> ahihi: Because it collects the list, but none of the results really become available until the last action is finished.
18:22:49 <Phyx-> kmc: lol, it's 3.22am... I don't always make sense at this hour
18:22:58 <FunctorSalad_> yay, I finally got ghc to print all the installed modules ;)
18:23:27 <kmc> Phyx-, fair enough :)
18:23:43 <FunctorSalad_> turns out you need to do liftIO initPackages inside the Ghc-monadic action, not in IO before the runGhc...
18:24:06 <FunctorSalad_> (and that you need to call initPackages before calling packageDbModules ;o)
18:25:02 <Wolfspaw> kmc: Still in the Data things, i founded cool the use of GAD. But for something more simplier, like if i want to have a data "September" which i want it to be a list of days of length 30. Is there a simplier way to do that?
18:25:11 <ahihi> Cale: noted. I didn't investigate it in detail, though; it may well have been something else I did wrong :)
18:25:13 <FunctorSalad_> (trying to write a simple lookup-unqualified-identifier-in-all-installed-modules tool... it doesn't exist does it?)
18:25:13 <Wolfspaw> syntaxglitch: ok, got it xD
18:25:31 <luite> :r
18:25:33 <kmc> (unsafePerformIO . return) x = case (\s -> (# s, x #)) realWorld# of (# _,r #) -> r
18:25:33 <FunctorSalad_> (and dump its type and maybe other metadata)
18:25:37 <luite> oops
18:26:40 <FunctorSalad_> using ghc's packagedb seems nicer for metadata than keeping some seperate system around
18:26:56 <FunctorSalad_> (at least if you have everything you want to search installed)
18:38:05 <Wolfspaw> netsplit? ; - ;
18:38:31 <Wolfspaw> quit
18:38:45 <prey_alone> The pick function has type IO b -> IO b, but I want it to have [a] -> a. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29116
18:38:46 <elpolloloco> i'm reading http://learnyouahaskell.com/starting-out (the section that mentions precedence of function application). it says "succ 9 + max 5 4 + 1" is parsed as "(succ 9) + (max 5 4) + 1". would haskell parse it differntly if succ had a definition where it accepted 7 params(some of them functions)?
18:39:33 <copumpkin> prey_alone: it should be [a] -> IO a?
18:39:52 <prey_alone> copumpkin: That would be fine, but it won't do that either.
18:40:27 <prey_alone> copumpking: And even if it did, how do I concatenate IO [Char]? (I want to pick random strings and smash them together.)
18:40:42 <FunctorSalad_> elpolloloco: no, function application is always tighter than any operator
18:40:59 <copumpkin> prey_alone: you can concatenate them with liftA2 (++)
18:41:18 <syntaxglitch> elpolloloco, if succ accepted 7 params then (succ 9) would be a function accepting 6 params
18:41:20 <mtnviewmark> :t liftM (++)
18:41:21 <lambdabot> forall a1 (m :: * -> *). (Monoid a1, Monad m) => m a1 -> m (a1 -> a1)
18:41:55 <QtPlatypus> :t (++)
18:41:56 <lambdabot> forall m. (Monoid m) => m -> m -> m
18:42:03 <mtnviewmark> :t fmap (++)
18:42:04 <lambdabot> forall a (f :: * -> *). (Monoid a, Functor f) => f a -> f (a -> a)
18:42:14 <copumpkin> elpolloloco: the parsing doesn't know about the types yet
18:42:16 <mtnviewmark> Either way
18:42:26 <syntaxglitch> heh, nice (++)
18:42:30 <FunctorSalad_> you can consider the function-application space as a left-associative operator with highest precedence if that helps
18:42:31 <shachaf> elpolloloco: Haskell functions can only accept one argument.
18:42:50 <FunctorSalad_> f x y = (f x) y
18:42:55 <mtnviewmark> Ah yes, silly me liftA2 or liftM2
18:43:01 <elpolloloco> shachaf, wow. are you sure ?
18:43:35 <shachaf> elpolloloco: Quite.
18:44:08 <mtnviewmark> Welllllll.....    elpolloloco, yes but consider what the tyoe of, say (+) 3 is
18:44:20 <mtnviewmark> :t (+) 3
18:44:21 <lambdabot> forall t. (Num t) => t -> t
18:44:42 <shachaf> mtnviewmark: Using an infix function in giving an example only makes things more confusing. :-)
18:44:58 <mtnviewmark> So (+) is a function of one argument that returns a function of one argument
18:45:01 <prey_alone>     Couldn't match expected type `Language.Haskell.TH.Syntax.Q
18:45:01 <prey_alone>                                     [Language.Haskell.TH.Syntax.Dec]'
18:45:01 <prey_alone>            against inferred type `f [a] -> f [a] -> f [a]'
18:45:01 <prey_alone>     In the expression: liftA2 (++)
18:46:09 <prey_alone> copumpkin: Am I supposed to declare "liftA2 (++)" somewhere in my Main module, or should I somehow use (liftA2 (++)) wherever I currently use ++?
18:46:15 <elpolloloco> shachaf, so are all the space separated params i pass packed into a tuple and then unpacked in the function?
18:46:21 <mtnviewmark> Well, shachaf whatntwo argument functionshall we use to illustrate?
18:46:35 <copumpkin> prey_alone: yeah, or you can use a do block to get the same effect
18:47:18 <elpolloloco> also, anyone know of a book that teaches haskell more rigorously? like not bring in syntactic sugar right at the beginning ?
18:47:28 <prey_alone> copumpkin: as in do { liftA2 (++); main = ... }
18:47:37 <syntaxglitch> elpolloloco, no, what shachaf is talking about is that when you apply a function to two parameters, what's actually happening is that it's being applied to one argument and returning another function, which is applied to the next argument
18:48:10 <mtnviewmark> elpolloloco: Like in    c
18:48:20 <mtnviewmark> Nvrmnd
18:48:35 <elpolloloco> i've come across currying before, so i understand
18:48:49 <prey_alone> elpolloloco: Real World Haskell is my new lover.
18:48:50 <elpolloloco> (javascript Prototype library)
18:48:53 <copumpkin> prey_alone: nope, do { x <- (the thing that returns IO [a]); y <- (another thing that returns IO [a]); return (x ++ y) }
18:49:04 <syntaxglitch> elpolloloco, okay then, it's just that all functions in Haskell are curried by default
18:49:16 <syntaxglitch> appropriately enough, since both are named for Haskell Curry!
18:49:17 <mtnviewmark> > repeat 3 'x'
18:49:18 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> t'
18:49:19 <lambdabot>         against inferred...
18:49:38 <mtnviewmark> > replicate 3 'x'
18:49:39 <lambdabot>   "xxx"
18:49:45 <prey_alone> copumpkin: I'd like to have a function that returns a random element from a list, as well as a main function to test it.
18:49:48 <mtnviewmark> :t replicate 3
18:49:49 <lambdabot> forall a. a -> [a]
18:49:55 <elpolloloco> copumpkin, ooh.. that book is on safaribooksonline. thanks
18:50:49 <mtnviewmark> elpolloloco: so the function replicate is applied to 3 which returns another function, which is then applied to 'x'
18:53:36 <Adamant> so, speaking of Haskell and Javascript... is jQuery the more or less standard go-to library here or is there considerable variation?
18:54:18 <tias> in template haskell, is there some way of determining if a previously inserted splice has already inserted a particular declaration?
18:54:42 <syntaxglitch> well, jQuery is a monad and Haskellers like monads, so I say go with that
18:54:48 <syntaxglitch> really, can't go wrong
18:54:52 <Adamant> :P
18:54:55 <syntaxglitch> :)
18:55:01 <kmc> prey_alone, you can't write a function that returns a random element of a list
18:55:05 <kmc> because that's not a function mathematically
18:55:10 <kmc> the output is not determined completely by the input
18:55:28 <kmc> you can write a function which returns a recipe which, if executed, would pick a random element from that list
18:55:35 <kmc> execution and evaluation are distinct processes
18:55:53 <prey_alone> kmc: That would be fine. Can you give me such a recipe?
18:56:07 <kmc> that's what you wrote before
18:56:23 <kmc> i think so
18:56:29 <kmc> you had a function «pick :: [a] -> IO a» or something
18:56:38 <kmc> the point is, it doesn't return "a"
18:56:39 <kmc> it returns "IO a"
18:56:41 <djahandarie> Adamant, the standard library in Haskell is pretty strong
18:57:02 <kmc> which is a kind of value called an "IO action" which i also call a "recipe"
18:57:15 <Adamant> djahandarie: sadly, the browser vendors haven't decided to embed it into their browser for unknown reasons
18:57:19 <prey_alone> kmc: Haskell complains.
18:57:19 <djahandarie> Adamant, jQuery is usually used for a better interface to the DOM, among other things. Usually when you grab a library in Haskell for doing something, it is either good or you get/make a better one 
18:57:20 <prey_alone> Couldn't match expected type `IO [Char]'
18:57:20 <prey_alone>            against inferred type `[[Char]]'
18:57:20 <prey_alone>     In a stmt of a 'do' expression: feature <- pick features
18:57:53 <kmc> prey_alone, can you hpaste the code you have so far?
18:58:02 <prey_alone> kmc: Sure.
18:58:37 <prey_alone> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29117
18:59:19 <Rotaerk> prey_alone, that code is a little scary
18:59:30 <prey_alone> Rotaerk: I'm a newb. Apologies.
18:59:45 <prey_alone> Or are you referring to the choice of variable names? :)
18:59:50 <elpolloloco> kmc, hey!
18:59:59 <kmc> hi electrogeek 
19:00:00 <kmc> err
19:00:01 <kmc> hi elpolloloco 
19:01:28 <djahandarie> I went to the bay area haskell group meet the other day
19:01:40 <kmc> prey_alone, you say "philabuster :: String" but this is impossible
19:01:47 <shachaf> syntaxglitch: I looked up "jQuery is a monad" and found <http://importantshock.wordpress.com/2009/01/18/jquery-is-a-monad/>.
19:01:51 <kmc> because the "do" syntax is used to glue together IO actions to make bigger IO actions
19:01:57 <kmc> so the result will be «IO String»
19:01:59 <shachaf> Is it just me or does this person not know what the monad laws are?
19:02:13 <ddarius> shachaf: The article is non-sensical.
19:02:32 <vilhelm_s> using Parsec's haskellStyle, how do I distinguish between identifiers starting with uppercase and lowercase letter?
19:03:04 <ddarius> vilhelm_s: You check if the start with uppercase or lowercase letters.
19:03:49 <syntaxglitch> shachaf, yeah, those are some... interesting definitions
19:04:47 <vilhelm_s> ddarius: Ok, fair enough. :) That doesn't cause any issues with it "guessing wrong" and then not backtracking?
19:05:58 <kmc> prey_alone, and the last line should be "return (feature ++ species ++ genital ++ suffix)"
19:05:58 <kmc> prey_alone, return is not a special keyword like in most languages.  it's an ordinary function whose type (here) is «a -> IO a»
19:05:59 <kmc> takes a value, returns an IO-recipe whose only action is to produce that value
19:05:59 <kmc> prey_alone, did you read the "Introduction to IO" article i linked?
19:06:05 <ddarius> vilhelm_s: You can use lookAhead to check for an upper- or lower-case letter first or you can wrap the parsing/check in a try.
19:06:42 <ddarius> kmc: Reading is for losers who want to get things done.
19:07:05 <vilhelm_s> ddarius: Ok. Thanks.
19:12:18 <dmwit> This isn't exactly Haskell, but have people here seen http://192.220.96.201/es/es-usenix-winter93.html ?
19:12:50 <prey_alone> kmc: My stupid university webportal logged me out.
19:12:57 <dmwit> It has that understated style peculiar to academic papers. =)
19:13:00 <prey_alone> kmc: How do I concatenate IO b's?
19:13:17 <dmwit> for example: "Since es incorporates a true lambda calculus, it includes the ability to create true recursive structures, that is, objects which include pointers to themselves, either directly or indirectly. While this feature can be useful for programmers, it has the unfortunate consequence of making memory management in es more complex than that found in other shells."
19:13:18 <kmc> what does that mean prey_alone?
19:13:25 <prey_alone> kmc: Alternatively, how do I specify that feature is IO String, not some IO b.
19:13:25 <kmc> you want to execute the two actions in order?
19:13:34 <kmc> prey_alone, you should not need to specify that
19:13:40 <kmc> if your code is correct the types will work out automatically
19:13:44 <kmc> prey_alone, what's your current problem?
19:14:42 <prey_alone> kmc: My problem is that pick returns IO b, not IO [Char], even if I say use pick on a list of strings.
19:14:59 <prey_alone>     Couldn't match expected type `IO b' against inferred type `[Char]'
19:14:59 <prey_alone>     In the expression: feature ++ species ++ genital ++ suffix
19:15:09 <copumpkin> genital :O
19:15:27 <monochrom> return (feature ++ species ++ genital ++ suffix)
19:15:38 <prey_alone> monochrom: thanks, i'll try that
19:16:12 <kmc> prey_alone, that's not your problem
19:16:20 <kmc> «pick :: [a] -> IO a»
19:16:35 <kmc> meaning the return value will be a recipe yielding elements the same type as the input list
19:16:39 <kmc> so you're fine
19:16:44 <kmc> prey_alone, did you get my explanation about "return" earlier?
19:16:49 <prey_alone> kmc: okay. now putStrLn doesn't like to print IO Strings.
19:16:59 <kmc> right.  IO String is not String
19:17:12 <monochrom> main = philabuster >>= putStrLn
19:17:18 <monochrom> or use the do-notation again
19:17:26 <kmc> do { x <- philabuster; putStrLn x }
19:17:26 <prey_alone> kmc: I was going to guess the do notation. Yay!
19:17:44 <monochrom> philabuster is another recipe
19:18:39 <prey_alone> kmc: Oh boy, an error I haven't seen before.
19:18:53 <monochrom> there is always the first time
19:19:03 <prey_alone> the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29119#a29119
19:19:06 <prey_alone> the error:
19:19:12 <prey_alone>     Ambiguous type variable `t' in the constraints:
19:19:12 <prey_alone>       `Random t' arising from a use of `pick'' at philabuster.hs:67:14-25
19:19:12 <prey_alone>       `Num t' arising from the literal `2' at philabuster.hs:67:25
19:19:13 <prey_alone>     Probable fix: add a type signature that fixes these type variable(s)
19:21:27 <dmwit> prey_alone: Do you intend "randomR (1, prob)" to pick either 1 or 2?
19:21:43 <prey_alone> That's not my code. It's from http://osfameron.vox.com/library/post/random-pain-in-haskell.html
19:21:49 <dmwit> or, rather, do you intend randomR (1, prob) to pick an integer?
19:21:58 <prey_alone> Yes: an integer.
19:22:48 <dmwit> prey_alone: Then, why not specialize pick' to take an Integer rather than any old Num/Random p?
19:23:05 <prey_alone> dmwit: Alright.
19:23:47 <prey_alone> dmwit: Should I replace (Num p, Random p) with (Int p)?
19:24:03 <luite> Int is a type, not a type class
19:24:10 <dmwit> pick' :: t -> [t] -> Integer -> IO t
19:24:10 <luite> so you can't use it there
19:25:00 <prey_alone> Egads!
19:25:11 <prey_alone> Thank you kmc, monochrom, dmwit!
19:26:43 <prey_alone> The very first output was "facemonkeypelletsmuncher".
19:27:08 <copumpkin> lol
19:27:22 <prey_alone> I think I understand the difference between let a = 1 and binding, a <- 1.
19:27:36 <prey_alone> Oh yeah, props to copumpkin too!
19:27:39 <prey_alone> peace.
19:40:38 <sshc> Is anybody aware of a database of any kind that contains English definitions?
19:41:55 <luite> wordnet?
19:45:02 <sshc> luite: Thanks
19:45:04 <sshc> I'll look at that
19:45:56 <sshc> Ah, there's even a WordNet package.  That's convenient.
19:47:06 <luite> lambdabot even supports it :)
19:47:14 <etpace> @hoogle (a -> a -> b) -> a -> b
19:47:14 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
19:47:15 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
19:47:15 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
19:47:51 <etpace> @pl \x -> x + x
19:47:51 <lambdabot> join (+)
19:48:32 <tolkad> is it possible to write function classes?
19:48:39 <tolkad> like class C a -> b
19:48:43 <tolkad> or something like that
19:49:00 <tolkad> wait that doesn't make much sense, nevermind
19:49:43 <syntaxglitch> you can write instances for function types, if that's what you mean
19:50:16 <tolkad> well can you write a class that can only have instances for function types of a particular kind?
19:50:57 <tolkad> that allows you access to the types of the function type variables within the class definition
19:51:06 <syntaxglitch> e.g., "instance (Monoid b) => Monoid (a -> b)" would work (and might make sense)
19:51:36 <sshc> type WN a = (?wne :: WordNetEnv) => a
19:51:42 <tolkad> I see. the feature I was thinking of isn't available but also isn't really necessary
19:51:44 <sshc> What is that ? syntax?
19:51:54 <syntaxglitch> tolkad, I'm not sure what you're trying to do, could you give an example?
19:52:00 <tolkad> sshc: maybe it's just the function name
19:52:10 <tolkad> syntaxglitch: I'm not sure either, I think I just got a bit confused
19:52:25 <sshc> tolkad: I don't understand you
19:52:39 <tolkad> sshc: I think it's just a function named "?wne"
19:52:56 <tolkad> I could be wrong but that's my guess
19:53:04 <sshc> tolkad: What are you referring to by "it"?
19:53:14 <syntaxglitch> tolkad, also you can do instances like ((->) a), which happens to be a Functor and Monad
19:53:20 <tolkad> sshc: ?wne
19:54:03 <syntaxglitch> sshc, isn't that an implicit parameter?
19:54:18 <tolkad> oh that's a type, I thought it was data for a second, sorry sshc
19:54:33 <syntaxglitch> sshc, http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/other-type-extensions.html#implicit-parameters
19:57:48 <sshc> syntaxglitch: Thanks
19:58:05 <syntaxglitch> sshc, not something you see everyday, eh
19:58:17 <syntaxglitch> not the most popular GHC extension, I guess?
19:58:54 <dmwit> What an unfortunate abbreviation. ftp://.../pub/es
19:59:04 <syntaxglitch> nice
19:59:18 <dmwit> The "extensible shell". =P
19:59:50 <dibblego> etpace, join
20:12:32 * hackagebot improve 0.0.10 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.0.10 (TomHawkins)
20:17:31 <sshc> Not sure I understand the implicit perematers extension.  But it seems really interesting that the WordNet module uses it to omit a database paremeter in its functions.  I wonder how it does that.
20:18:30 <ezyang> implicit parameters are basically reader monads with extensible dictionaries 
20:18:42 <ezyang> and very implicit rules for when an implicit parameter gets resolved. 
20:19:41 <sshc> ezyang: Do you suggest any information on it?
20:19:48 <sshc> ezyang: How would I use it?
20:19:58 <BMeph> @hoogle (a -> b -> c) -> (d -> a) -> (e -> b) -> d -> e -> c
20:19:59 <lambdabot> No results found
20:20:01 <ezyang> The basic usage is pretty simple. 
20:20:07 <ezyang> let ?implicit_param = val in ... 
20:20:46 <Veinor> i@djinn (a -> b -> c) -> (d -> a) -> (e -> b) -> d -> e -> c
20:20:49 <Veinor> @djinn (a -> b -> c) -> (d -> a) -> (e -> b) -> d -> e -> c
20:20:50 <lambdabot> f a b c d e = a (b d) (c e)
20:21:06 <Veinor> @. pl djinn (a -> b -> c) -> (d -> a) -> (e -> b) -> d -> e -> c
20:21:06 <lambdabot> f = ((flip . ((.) .)) .) . (.)
20:22:40 <BMeph> Does anyone recognize that function as anything in use, BTW?
20:22:40 <lambdabot> BMeph: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:31:39 <sshc> Oh, apparently I do still need to use the database paremeter
20:31:44 <sshc> With runs
21:21:12 <dibblego> what's the name of the tool like docbook?
21:21:21 <dibblego> written in haskell
21:21:35 <aavogt> haddock
21:21:52 <aavogt> or maybe pandoc
21:21:55 <dibblego> no, something specifically for authoring documentation
21:21:58 <dibblego> ah yeah that
21:22:01 <ivanm> lhs2tex?
21:22:10 <ivanm> pandoc isn't for "authoring documentation"
21:22:25 <ivanm> however, john writes the pandoc website in markdown, and I do the same for graphviz (based on his css, etc.)
21:22:34 <dibblego> right it's for converting
21:22:46 <ivanm> I have a script that takes the FAQ, README, etc. from graphviz' source bundle and runs pandoc on it to get the webpages
21:23:04 <sshc> Is there a cleaner way of writing "(\x -> f <$> x)"?
21:23:09 <ivanm> if you care: darcs get http://projects.haskell.org/graphviz/
21:23:18 <djahandarie> @pl (\x -> f <$> x)
21:23:19 <lambdabot> (f <$>)
21:23:28 * ivanm eventually plans on writing an actual program to generate those kinds of websites based off cabalised packages
21:23:33 <djahandarie> standard eta reduction
21:23:35 <sshc> Haha.  Whoa.
21:23:37 <sshc> "pl"?
21:23:42 <ivanm> @help pl
21:23:42 <lambdabot> pointless <expr>. Play with pointfree code.
21:23:50 <ivanm> @google haskell pointfree
21:23:52 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
21:23:52 <lambdabot> Title: Pointfree - HaskellWiki
21:24:00 <sshc> Very nice!
21:24:28 <djahandarie> All lambdabot commands work via PM as well
21:29:21 <sshc> How should I write a numebr parser?
21:29:37 <sshc> in parsec, that is
21:29:48 <sshc> Should I base it on a Read parser?
21:29:48 <dibblego> then using parsec?
21:30:16 <sshc> RWS's example uses getInput and setIpnut directly, without updating the position
21:30:57 <sshc> How did you write a parsec number parser?
21:32:35 * Phyx- goes to implement TypeScheme extension
21:33:14 <Phyx-> where did I put that paper
21:40:28 <Phyx-> "--show-iface file " <-- is that available through the API
22:01:27 <luxianos> hi! I need to write a function that giving a predicate and a list, returns the subsecuences where it's elements make true the predicate; but i have a problem, my function does nor work well
22:01:50 <shachaf> luxianos: Is this a homework question?
22:02:06 <luxianos> yes
22:02:56 <shachaf> @paste your current code and perhaps someone in the channel can give you a hint.
22:02:57 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
22:06:53 <luxianos> subsecs:: (a -> Bool) -> [a] -> [[a]]  the function should work well: subsecs (==0) [0,0,2,0,3,0,0,0] = [[0,0],[0],[0,0,0]] subsecs (/=’\n’) "hola que\ntal" = ["hola que","tal"] subsecs (/=’\n’) "" = [""] subsecs (/=’\n’) "\n" = ["",""]  i writed this code, but it does not well: subsecs (b) [] = [] subsecs (b) (x:xs) | b x == True =  ([x] : (subsecs b xs)) 		   | otherwise =   (subsecs b xs)
22:07:46 <ezyang> pastebin plz 
22:09:26 <BMeph> luxianos: 1) No offense, but just to be clear: UR DOIN IT RONG!!11!11!11ichi11!
22:10:19 <djahandarie> !!!111!11!一!!!111
22:12:21 <BMeph> luxianos: 2) Is this a "Don't use any pre-written functions other than null" assignment? because otherwise it's pretty direct. If not, it's slightly more convoluted (just write the pair of library fnctions you'd use).
22:12:34 <BMeph> 3) ????
22:12:56 <BMeph> 4) PROFIT!!! ;þ
22:15:28 <luxianos> evidently the function that i writed is wrong, but i have no idea what it needs to work well
22:20:00 <Wooga> what is better: recursivly carry stack as argument of processing function like in evalBF here: http://codepad.org/MTlb1Jce or use State moand?
22:21:00 <Pseudonym> Wooga, you probably don't need the State monad because the eval stack is never returned.
22:21:02 <BMeph> Wooga: What's the difference? ;)
22:21:37 <Wooga> Pseudonym: actualy it is returned for recursive processing of loops
22:21:53 <Pseudonym> Oh, I see.
22:22:15 <Wooga> BMeph: sorry, i don't know
22:22:46 <Pseudonym> Another possibility is to use IO for your mutable state.
22:22:52 <Pseudonym> Pass in an IORef.
22:22:55 <bengold> Does anyone here have experience getting SDL working on OSX?
22:22:58 <Pseudonym> Or record of IORefs.
22:23:26 <Wooga> Pseudonym: what bad in State monad?
22:23:54 <Pseudonym> Nothing's bad about a State monad, if that best describes your intent.
22:24:08 <Wooga> i dpm
22:24:11 <BMeph> Wooga: You said "what is better", as if you have some idea of how one would be better than the other. I just figured that if you thought of how the two methods stacked up (heh-heh) by those criteria, it would help you make a decision that way. :)
22:24:17 <Wooga> *don't really know what i want
22:24:27 <Pseudonym> Yeah, the programmer's dilemma.
22:25:08 <Pseudonym> Generally speaking, we like abstract machines to be specified as a transition function from machine state to machine state.
22:26:06 <Pseudonym> And if you've done that, then implementing it more or less directly as that is usually considered best practice.
22:26:08 * hackagebot text-icu 0.2.0.0 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.2.0.0 (BryanOSullivan)
22:26:10 <djahandarie> luxianos, import Data.List.Split; subsecs cond value = splitWhen (not cond) value
22:26:10 <dbelange> What is the Haskell opinion of universal coalgebra?
22:26:13 <djahandarie> lol he left
22:26:31 <Wooga> thank you guys
22:27:53 <applicative> bengold, what is the difficulty?
22:28:35 <ManateeLazyCat> Hi all.
22:28:54 <applicative> bengold, I just reinstalled it, having just installed the more recent Haskell platform
22:28:59 <bengold> applicative; I'm trying to install the SDL bindings in Haskell, but whenever I run runhaskell Setup configure, it says that SDL is not installed.
22:29:17 <applicative> did you get the sdl libs from macports or fink?
22:29:24 <bengold> I got it straight from the site.
22:29:44 <bengold> libsdl.org
22:30:21 <applicative> bengold, its just not finding them.  Do you know where they went?  /usr/local ? 
22:31:03 <bengold> Installing from the libsdl .dmg download tells me to just drag and drop the SDL.framework folder straight into the Library/Frameworks folder
22:31:19 <bengold> Should I add Library/Frameworks to my path? That seems odd to me. Is this an incomplete install?
22:32:26 <applicative> check "cabal install --help"  you'll see you can direct it to look here and there for libs with --extra-include-dirs=PATH and --extra-lib-dirs=PATH
22:32:50 <applicative> bengold, but i'm looking to see where mine are, i installed them a long time ago.
22:33:44 <bengold> Ah, this might make things a little more tricky -- I can't actually use Cabal. Somehow, thanks to my firewall, it won't update the list of packages from the site.
22:34:32 <applicative> bengold, it doesn't matter, runhaskell is fine
22:35:22 <applicative> bengold if you type "runhaskell setup configure --help" you'll see the same options
22:35:52 <bengold> applicative: ah, great! Let me try that real quick
22:37:24 <applicative> bengold, so typically for C libraries in strange places you need to tell it where ...include... and ...lib... are.  I seem to have installed mine with fink.
22:38:59 <bengold> applicative: Ah, okay. I'm having trouble getting the parameters right; it doesn't much seem to like anything I'm trying. Hold on
22:40:13 <bengold> applicative: Ergh, can't quite seem to get it to work. I'm trying "runhaskell Setup configure --extra-include-dirs=/Library/Frameworks/SDL.framework/Headers --extra-lib-dirs=/Library/Frameworks/SDL.framework/"
22:40:43 <bengold> applicative: I couldn't use MacPorts for the same reason as not being able to use cabal, but I can try Fink
22:41:35 <bengold> applicative: Nope, Fink's a no-go as well
22:42:06 <applicative> bengold not sure, I'm looking at this dmg installer....
22:49:58 <franksh> ok, what am i doing not understanding here? i run setup.lhs on a file and it tells me i am missing three packages that ghc-pkg list shows i have installed. the cabal package consists of a single .hs.. when i run ghc --make on it, it compiles just fine, but removing the dependencies in the .cabal and then running Setup.lhs build, it gives an error (can't import Data.Bitmap.IO -- but i do have it).
22:50:04 <franksh> i only have one version of ghc installed (latest haskell platform).
22:52:47 <ivanm> using Setup.lhs defaults to global pkgdb
22:53:01 <ivanm> if you installed stuff with cabal-install, it defaults to per-user pkgdb
22:55:11 <dolio> I'm glad that we don't have to benchmark anything, thanks to Bulat.
22:56:05 <applicative> bengold, I dragged the sdl stuff into my local ~/Library/Framework, just to see.  
22:56:24 <applicative> bengold, then cabal install claims to have linked it with cabal install sdl --reinstall --extra-lib-dirs=/Users/applicative/Library/Frameworks/SDL.framework/Headers --extra-include-dirs=/Users/applicative/Library/Frameworks/SDL.framework/Resource
22:57:05 <franksh> ivanm, ahhh, yes. thank you. that makes sense.
22:57:27 <applicative> bengold, or rather, Resources.    It is not an entirely familiar sort of C library, I don't understand the 'framework' system
22:58:19 <dibblego> @free a -> a
22:58:20 <lambdabot> Extra stuff at end of line
22:58:26 <dibblego> @free id :: a -> a
22:58:26 <lambdabot> f . id = id . f
22:58:37 <bengold> applicative: I'm not at all sure I do either. I'll try that real quick
23:00:34 <bengold> applicative: Grr, no dice. I thought maybe you had mixed it up (include-dirs pointing to resources and lib-dirs pointing to Headers?) but neither one worked. Did it go for you?
23:01:28 <ivanm> dolio: yeah, his email didn't make any sense to me
23:01:41 <ivanm> AFAICT it was "don't bother, it's all useless competing with C" :s
23:01:54 <dolio> Any benchmarks that show that Haskell has performance close to C are wrong.
23:02:15 <dolio> And presumably the converse.
23:02:32 <applicative> bengold, it occurs to me, it might have decided not to use the wisdom I gave with --extra-lib-dirs   
23:02:47 <ivanm> dolio: people like that make you wonder wtf they're doing using Haskell...
23:02:59 <ivanm> btw, has anyone else noticed that suddenly harrop has become really interested in Scala?
23:03:09 * ivanm wonders how long it will be before he starts saying how crap scala is
23:03:44 <dolio> Yeah, Bulat's a character.
23:03:59 <bengold> applicative: I'm not sure what you mean; I tried it without the extra-lib-dirs, but that was a no go. You're saying it went anyway because you already have sdl installed from Fink?
23:04:21 <dibblego> he became interested in Scala a while ago, when he announced he was writing a book -- then it fizzled out
23:04:33 <ivanm> heh
23:04:36 <ivanm> that'd be right
23:04:41 <dibblego> then he had a discussion with Martin Odersky when he acted like the usual fuck-wit then Odersky posted to the mailing list to ignore gim
23:04:43 <dibblego> *him
23:05:17 <applicative> bengold, that's what i;m thinking .  In fink's special /sw/include there's a subdirectory /sw/include/SDL that includes all the files SDL_active.h etc etc
23:05:49 <dibblego> http://scala-programming-language.1934581.n4.nabble.com/scala-Scala-in-Industry-td1987796.html#a1987797
23:05:51 <applicative> bengold, so it's structured differently.  The aliasing in the SDL.framework may be what is defeating runhaskell Setup ....
23:07:01 <bengold> applicative: Ahh, Let me try it again with bypassing the aliasing
23:08:03 <dolio> dibblego: The blog link in that thread is pretty funny.
23:08:21 <dibblego> dolio, you mean at the bottom?
23:08:29 <dibblego> or harrop-highly?
23:08:34 <dolio> The latter.
23:08:42 <dolio> With "Big Haskell" and "Big Lisp".
23:08:49 <bengold> applicative: Argh, still nothing. I'm surprised this is so hard! Darn you firewalls.
23:09:17 <Veinor> ... Big Haskell?
23:09:27 <dolio> Like Big Pharma, I assume.
23:12:12 <applicative> bengold, not sure what to say.  I notice the fink machinery installs it in the usual way, with a bunch of .h files in /sw/include/SDL/  and a bunch of libsdl.dylib type things in /sw/lib  
23:13:06 <applicative> bengold, what bugs me about the Framework, is it doens't seem to include what runhaskell Setup ... will be looking for with --extra-lib-dirs
23:13:45 <bengold> applicative: I totally agree. Grrr, damn this firewall! I guess i could try building SDL from source. Thanks for going through all the effort to help me!
23:16:24 <applicative> bengold, so, maybe you need to get hold of the sources that fink or macports is using, and install them as they do, without all the Cocoa advantages. 
23:36:49 <anair_84> anyone know what is wrong with http://haskell.pastebin.com/ScJBiQxb
23:37:00 <anair_84> Keep getting    Occurs check: cannot construct the infinite type: n = n -> n
23:37:48 <ivanm> well, you're saying for any monad but using Just
23:37:58 <ivanm> so either make it always be Maybe, or else use return
23:38:13 <ivanm> secondly, f is n -> n, but you're passing it _two_ arguments
23:38:31 * hackagebot text-icu 0.3.0.0 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.3.0.0 (BryanOSullivan)
23:38:45 <ivanm> also, the prevailing Haskell format is to use camelCase, not_underscores
23:39:19 <ivanm> bos: are we going to see the magic fixed version of text soon as well?
23:39:54 <bos> ivanm: not sure yet
23:40:07 <bos> ivanm: i am wondering whether to add locale support first
23:40:13 <ivanm> hmmm.....
23:40:26 <ivanm> I thought you already had text using locale support for I/O...
23:40:32 <ivanm> (if you're using 6.12, that is)
23:43:19 <anair_84> k, thanks
