00:02:21 <EvanCarroll> I'm still not sure I'm on the same track..
00:02:42 <EvanCarroll> Why doesn't this get TCO'ed and what would you have to do for it to get TcOed
00:02:54 <EvanCarroll> TCOed*
00:03:07 <copumpkin> well the issue isn't so much the tail calls as the laziness and thunk behavior
00:03:08 <lispy> EvanCarroll: TCO in Haskell doesn't always have the desired effect
00:03:21 <copumpkin> you never get a stack overflow from calling functions in haskell
00:03:24 <copumpkin> only from evaluating thunks
00:03:49 <lispy> EvanCarroll: even with proper TCO you might accumulate a large thunk in a parameter.  You could then either run out of heap to store the accumulated thunk, or forcing the evaluation of the thunk might lead to a stack overflow.
00:04:26 <EvanCarroll> in my example, how do I get TCO to work?
00:04:39 <lispy> EvanCarroll: The fix is pretty simple.  Keep forcing the accumlator incrementally so that it's never a huge thunk.
00:04:46 <copumpkin> :t foldl' mconcat
00:04:47 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> [a]
00:04:47 <lambdabot>     Probable cause: `mconcat' is applied to too many arguments
00:04:48 <lambdabot>     In the first argument of `foldl'', namely `mconcat'
00:05:09 <copumpkin> :t foldl' mappend 
00:05:10 <lambdabot> forall a. (Monoid a) => a -> [a] -> a
00:05:12 <copumpkin> dammit
00:05:40 <copumpkin> > (\n -> appEndo . foldl' mappend . replicate n) 10000000 succ 5
00:05:41 <lambdabot>   Couldn't match expected type `Data.Monoid.Endo a'
00:05:41 <lambdabot>         against inferred ...
00:05:49 <copumpkin> > (\n -> appEndo . foldl' mappend . map Endo . replicate n) 10000000 succ 5
00:05:50 <lambdabot>   Couldn't match expected type `Data.Monoid.Endo a'
00:05:50 <lambdabot>         against inferred ...
00:05:54 <copumpkin> pff
00:06:03 <copumpkin> it's too late
00:06:32 <lispy> EvanCarroll: your function looks a lot like taking the nth element of iterate
00:06:39 <lispy> :t iterate
00:06:40 <lambdabot> forall a. (a -> a) -> a -> [a]
00:06:55 <lispy> > iterate (+1) 0
00:06:56 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
00:07:06 <copumpkin> but taking big elements of iterate is also going to give you a stack overflow
00:07:12 <copumpkin> unless you force all previous ones
00:07:29 <copumpkin> > iterate succ 0 !! 10000000
00:07:31 <lispy> and you'd need a new iterate function to do that
00:07:35 <lispy> :src iterate
00:07:39 <lambdabot>   mueval: ExitFailure 1
00:07:40 <lispy> ?src iterate
00:07:40 <lambdabot> iterate f x =  x : iterate f (f x)
00:08:21 <lispy> iterate f x = x : f x `seq` iterate f (f x), perhaps?
00:08:32 <lispy> Not sure if that does the right thing
00:08:33 <copumpkin> > iterate succ 0 !! 1000000
00:08:36 <lambdabot>   *Exception: stack overflow
00:08:48 <lispy> iterate f x = let !y = f x in x : iterate f y
00:09:02 <copumpkin> or just force x
00:09:06 <lispy> ?let iterate' f x = let !y = f x in x : iterate f y
00:09:06 <lambdabot>   BangPatterns is not enabled
00:09:47 <lispy> ?let iterate' f x = let y = f x in x : y `seq` iterate f y
00:09:49 <lambdabot>  <local>:4:50:
00:09:49 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]...
00:09:58 <lispy> :t seq
00:10:00 <lambdabot> forall a t. a -> t -> t
00:10:10 <EvanCarroll> Ok, i'm going to bed all
00:10:19 <lispy> ?let iterate' f x = let y = f x in y `seq` (x : iterate f y)
00:10:20 <EvanCarroll> maybe some day i'll get this down
00:10:20 <lambdabot>  Defined.
00:10:33 <lispy> > iterate' succ 0 !! 1000000
00:10:35 <lambdabot>   *Exception: stack overflow
00:11:05 <EvanCarroll> lispy: I'll checkback log if you figure it out though
00:11:10 <EvanCarroll> send me answer in pvmsg
00:11:35 <lispy> > let iterate' f x = x : iterate f (f $! x)
00:11:35 <EvanCarroll> I'm curious me and a friend were talking about why/why not perl's GOTO is enough to satisify any need for TCO
00:11:36 <lambdabot>   not an expression: `let iterate' f x = x : iterate f (f $! x)'
00:11:47 <lispy> > let iterate' f x = x : iterate f (f $! x) in iterate' succ 0 1000000
00:11:48 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
00:11:59 <lispy> > let iterate' f x = x : iterate' f (f $! x) in iterate' succ 0 1000000
00:12:00 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
00:12:34 <lispy> > let iterate' f x = x : iterate' f (f $! x) in iterate' succ 0 !! 1000000
00:12:36 <lambdabot>   *Exception: stack overflow
00:12:43 <lispy> I really don't know how to fix it, TBH
00:13:56 <copumpkin> > let (x : xs) !!! 0 = x; (x : xs) !!! n = x `seq` xs !!! (n - 1) in iterate succ 0 !!! 1000000
00:13:59 <lambdabot>   1000000
00:14:09 <Botje> > let iterate' f x = x `seq` x : iterate' f (f x) in iterate' succ 0 !! 1000000
00:14:11 <lambdabot>   1000000
00:23:16 <lispy> oh, so you can't force x inside the recursive call because it still doesn't get evaluated till the end.  Instead you have to do it before you recurse?
00:23:45 <lispy> > let iterate' f x = x : x `seq` iterate' f (f x) in iterate' succ 0 !! 1000000 -- does this work?
00:23:45 <Botje> yes
00:23:46 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
00:24:02 <lispy> > let iterate' f x = x : (x `seq` iterate' f (f x)) in iterate' succ 0 !! 1000000 -- does this work?
00:24:04 <lambdabot>   1000000
00:24:10 <Botje> : is a lazy constructor, remember :)
00:24:36 <lispy> ooops
00:25:07 <lispy> > let iterate' f x = x : iterate' f (x `seq` (f x)) in iterate' succ 0 !! 1000000 -- What about this?
00:25:08 <lambdabot>   *Exception: stack overflow
00:25:13 <Botje> > let iterate' f x = x `seq` x : iterate' f $! f x in iterate' succ 0 !! 1000000
00:25:14 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a -> t'
00:25:28 <Botje> > let iterate' f x = x : (iterate' f $! f x) in iterate' succ 0 !! 1000000
00:25:30 <lambdabot>   1000000
00:25:38 <lispy> It has to be outside of the iterate' call
00:25:49 <lispy> I think that makes sense to me
00:26:43 <lispy> ?src ($!)
00:26:44 <lambdabot> f $! x = x `seq` f x
00:26:55 <lispy> Right, so that still does the seq outside of the recursive call
00:41:05 <Jonno_FTW> @src fromInteger
00:41:06 <lambdabot> Source not found. You untyped fool!
00:58:46 <sdj> What has happened to the first section of keybindings in http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Tips_and_use
00:59:39 <sdj> They don't seem to be there in the present haskell-mode
01:09:13 <ben_m> I think that's only with a certain indent mode
01:09:21 <ben_m> Haskell-mode has 3 (?) different ones
01:09:53 <ben_m> It used to work for me, then stopped working and now I -think- it works again ... :D
01:16:31 <sdj> They are not defined no matter which indentation i choose.
01:28:26 <ksf> would anybody else here be interested in a cross between 9p, spdy and ebml?
01:30:52 <ksf> ...where (something) ebml(-like) would be used as both the base wire layer, to implement the fs/bidi-muxing semantics (9p and spdy) and to represent stuff that's represented, there.
01:31:13 <ksf> ...including links.
01:32:04 <ksf> I'm still wondering whether softlinks or hardlinks, hardlinks would require an inode layer, which might be useful in any case, but depending on how it's done might also increase response time due to roundtrips.
01:33:02 <ksf> also, there needs to be some sane way to deal with imported filesystem... variable size inodes, that is.
01:46:06 <lispy> :t Prelude.log
01:46:07 <lambdabot> forall a. (Floating a) => a -> a
01:46:32 <lispy> So, why would "import Prelude hiding (log)" cause a warning about redundant imports?
01:46:37 <lispy> Is that just a GHC bug?
01:49:59 <fasta> lispy, did you look in GHC Trac?
01:50:12 <lispy> fasta: nope
01:50:17 <lispy> I asked here first :)
01:50:28 <lispy> fasta: Haskell is lazy right? ;)
01:50:29 <fasta> lispy, I am pretty sure it has already been reported in some form.
01:50:40 <fasta> lispy, other humans are lazy too.
01:51:52 <bss03> @djinn Functor f => a -> b -> c -> f a -> f b -> f c
01:51:53 <lambdabot> Error: Class not found: Functor
01:53:28 <lispy> fasta: yeah, I just spent 2 hours getting rid of warnings that others had let creep in :(
01:54:20 <lispy> fasta: but that one I can't seem to get rid of without using qualified imports
01:55:05 <lispy> I guess I could change, "import Prelude hiding (log)" to "import qualified Prelude (log)"
01:55:24 <lispy> But, then it would probably still complain that I didn't use Prelude.log anywhere
01:55:32 <fasta> lispy, I think GHC simply complains too much.
01:55:55 <fasta> lispy, understanding where symbols come from in Haskell is not a problem.
01:56:25 <fasta> lispy, that's why specifying where imports come from is of low interest in Haskell.  
01:56:42 <lispy> fasta: I find it important and specify them explicitly on every project.
01:56:48 <fasta> lispy, if however you talk about a language without :i <symbol>, then you have a nightmare on your hands.
01:57:18 <fasta> lispy, you mean every module?
01:57:27 <lispy> fasta: yeah
01:57:54 <lispy> fasta: For example, the darcs source code is big enough that I never know where things are defined.  The explicit imports save me time
01:58:23 <fasta> lispy, but all that you are interested in is displaying their source, I suppose.
01:58:29 <ksf> I would do that if it were done automatically
01:58:50 <lispy> fasta: yeah, I also use ack which helps too
01:58:54 <ksf> but hare fails on virtually every haskell source as it's based on the wrong parser.
01:58:58 <fasta> lispy, ack?
01:59:03 <lispy> ack is like grep . find
01:59:14 <lispy> http://betterthangrep.com/
01:59:17 <fasta> lispy, ah, yes, I heard about it.
01:59:18 <ksf> grep -R ?
01:59:36 <lispy> ksf: kinda.  It's just a nice perl script for that stuff
01:59:52 <lispy> It's vcs aware so it skips metadata directories, etc
02:00:10 <fasta> I think it's a joke we still use tools that are worse than Smalltalk has/had in the 70s. 
02:00:36 <fasta> We have a relatively state-of-the-art compiler, but everything else is still broken. 
02:00:54 <fasta> The amount of time wasted by everyone is astronomical. 
02:01:17 <fasta> That is, more than the time it would take to fix the problem given 100 Haskell programmers.
02:02:37 <ksf> indeed.
02:02:47 <ksf> if leksah, yi and hare would be one that'd be a start.
02:02:53 <ksf> oh, add hoogle to that.
02:03:02 <fasta> And Hayoo.
02:03:16 <ksf> well, any smart haddock index
02:03:54 <fasta> Anyway, it can be fixed, but someone has to organize a pot of gold to make it work :)
02:04:40 <ksf> we could collect money for a real-world cake those people that do it could then share.
02:04:47 <ksf> people love cakes that aren't a lie.
02:04:54 <fasta> Common Lisp people can point at SLIME and look real smug, because they are. 
02:05:21 <lispy> <shrug> I never liked SLIME when I was a lisper
02:06:04 <fasta> Ok, SLIME was not perfect, but it was a good step in the right direction.
02:12:01 <FunctorSalad_> yay, got local-hoogle completion for vim working
02:18:59 <aRcatan_> i read that "competition"
02:20:05 <aRcatan_> that'd be interesting
02:20:40 <FunctorSalad_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29435#a29435
02:21:29 <FunctorSalad_> (put into ftplugin/haskell/whatever.vim)
02:23:12 <FunctorSalad_> (invoke with ^X^U by default)
02:23:44 <FunctorSalad_> wait, my 'Shellescape' function there is missing :)
02:27:50 <FunctorSalad_> modified... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29435#a29436
02:29:38 <FunctorSalad_> (also removed the 'command' shell builtin before 'hoogle'... just used it because I have hoogle aliased to 'hoogle --color')
02:31:37 <FunctorSalad_> doesn't complete qualified names properly yet, since it simply passes the word before point to hoogle, and apparently Control.M is not a sensible hoogle query
02:32:22 <FunctorSalad_> or at least it's broader than requiring the name to start with Control.M
02:32:35 <Slavik> Can someone recommend me a movie with alien seks?
02:33:35 <ivanm> Slavik: is that really appropriate to this channel?
02:34:17 <Slavik> ivanm: I think so?
02:35:13 <Philippa> I hear there's this really famous series about it. Actually called Alien, if you'd believe it
02:35:20 <Slavik> Wow
02:36:14 <merijn> Slightly off-topic, but since there's usually a lot of math/CS academics here: Does anyone know a site where to look up the meaning of mathematical symbols?
02:37:37 <fasta> merijn, you can draw LaTeX symbols in some application. 
02:37:55 <fasta> merijn, that gives you the name of the symbol, usually you can get the rest from Google then. 
02:38:19 <fasta> merijn, or you know, do like old people do, which is to read enough books, such that there are no new symbols anymore :)
02:38:58 <merijn> fasta: I know Detexify, but google doesn't turn up a lot of useful things
02:39:28 <fasta> merijn, which symbol is it?
02:39:29 * RayNbow`TU blinks as he managed to break ghci...
02:39:34 <merijn> They're not new symbols, I know I learned them at some point, but forgot them, I need google for my brain >.>
02:39:44 <ivanm> RayNbow`TU: :o
02:40:00 <RayNbow`TU> but now I cannot reproduce it :p
02:40:02 <merijn> fasta: \sqsubseteq it's the square version of the subset equality symbol
02:40:25 <RayNbow`TU> basically I entered "let fibs = 0:1:zipWith (+) (tail fibs) fibs in fibs"
02:40:34 <RayNbow`TU> and right after hitting Enter, I also pressed Ctrl+C
02:40:42 <RayNbow`TU> the output was "Interrupted"
02:40:51 <RayNbow`TU> but for every expression I entered after that
02:40:56 <RayNbow`TU> it gave "Interrupted"
02:40:58 <merijn> RayNbow`TU: You can't do it like that, I tried. You can do it in a slightly similar way, though
02:41:06 <merijn> Lemme check if I can find how I did that
02:41:20 <fasta> merijn, Google: http://encyclopedia2.thefreedictionary.com/%5Csqsubseteq
02:42:22 <merijn> RayNbow`TU: I used this fibonacci definition to solve some Euler challenge: http://dpaste.com/233726/
02:42:48 <RayNbow`TU> merijn: I'm not really interested in computing fibs :)
02:43:06 <RayNbow`TU> I'm interested in the buggy behaviour of ghci
02:43:14 <RayNbow`TU> which I cannot reproduce
02:43:38 <ivanm> RayNbow`TU: just straight ghci in a terminal?
02:43:44 <RayNbow`TU> yes
02:43:53 <RayNbow`TU> well, a crappy terminal that is :p
02:43:56 <RayNbow`TU> (cmd.exe :p)
02:44:11 <RayNbow`TU> (GHC 6.12.3)
02:44:53 <ivanm> RayNbow`TU: I can't reproduce it; maybe I'm not hitting C-c fast enough :s
02:44:59 <ivanm> oh, right, let's blame windows
02:46:02 <ivanm> preflex: seen CosmicRay 
02:46:02 <preflex>  CosmicRay was last seen on #haskell 21 days, 12 hours, 54 minutes and 52 seconds ago, saying: ah ok
02:46:12 <ivanm> offlineimap suddenly stopped working :s
02:46:19 <ivanm> how am I meant to read my emails now? :s
02:46:35 <Entroacceptor> mutt? telnet?
02:46:50 <Entroacceptor> ssh | cat
02:47:37 <Entroacceptor> ivanm: carefully feeling the magnetic field?
02:48:05 <ivanm> well, I mean, I can just use gmail's web interface
02:48:11 <ivanm> but I prefer reading them locally :s
02:49:18 <fasta> ivanm, Thunderbird? It's just that the spam filter doesn't work. 
02:49:36 <fasta> ivanm, but if you combine it with GMail you have the best of both worlds.
02:49:42 <ivanm> *sigh* I use offlineimap to sync my emails locally, and then a mail client to read them
02:49:46 <ivanm> but offlineimap is failing
02:50:16 <fasta> ivanm, getting all your email takes too long? 
02:50:33 <fasta> ivanm, that is, for what are you optimizing?
02:50:36 <ivanm> no, offlineimap is _crashing_
02:50:44 <fasta> ivanm, so, just dump offlineimap.
02:50:56 <fasta> ivanm, it's not being maintained anymore.
02:50:59 <ivanm> except I want a local cache...
02:51:01 <ivanm> it isn't? :o
02:51:10 <fasta> ivanm, so, I have one with Thunderbird. 
02:51:39 * ivanm might have to try this isync tool someone recommended then
02:51:47 <ivanm> dammit, everything is failing on my machine atm
02:51:54 <ivanm> sound isn't working, email isn't syncing, etc.
02:51:55 <Entroacceptor> fun fact: my offlineimap just crashed, too
02:52:40 <ivanm> Entroacceptor: it's a conspiracy!
02:52:47 <Entroacceptor> ah, now it works again
02:53:09 <ivanm> something like this (if I can read python stack traces properly)? "File "/usr/lib/python2.6/site-packages/offlineimap/folder/UIDMaps.py", line 50, in _loadmaps    (str1, str2) = line.split(':')"
02:55:35 <Entroacceptor> ivanm: no, it just hung 
02:56:40 <ivanm> huh
02:57:20 <dobblego> think yourself lucky python has no TCO so you even get stack traces!
02:57:22 <ivanm> unless gmail is playing silly buggers again and changing the formatting of all their folders...
02:57:24 <ivanm> :@
02:57:26 <ivanm> dobblego: heh
03:14:58 <ivanm> preflex: seen Heffalump 
03:14:58 <preflex>  Heffalump was last seen on #haskell 5 hours, 11 minutes and 52 seconds ago, saying: ksf: if return were strict, there'd be no difference between those
03:15:41 <bss03> I'm having problems jugling State and IO.  In particular, I have a function that modifies the state, then maybe does some IO to further modify the state and loops.
03:16:32 <bss03> My Haskell toolbox is fairly small right now, what should I be looking up.
03:16:51 <bss03> I'm thinking maybe StateT applied to IO?
03:16:52 <ivanm> @ask Heffalump hmmm.... I wasn't planning on bothering to differentiate between Word8 and Char though (just use a newtype wrapper for Char or something)
03:16:52 <lambdabot> Consider it noted.
03:17:05 <ivanm> bss03: sounds about right
03:21:13 <ivanm> @tell Heffalump however, the forall works (and is probably a better way of doing it than my notion of using unsafeCoerce and seeing if that worked... :s)
03:21:14 <lambdabot> Consider it noted.
03:22:30 * hackagebot collections 0.3.1 - Useful standard collections types and related functions.  http://hackage.haskell.org/package/collections-0.3.1 (JohannesWaldmann)
03:23:41 <ivanm> is Johannes Waldmann here?
03:26:14 <ivanm> @ask Heffalump a way of making the Char/Word8 part of the Constraint instance would be nice, so you wouldn't need to bother listing each possible instance would be nice too (won't help with cross instances, but I'm not sure how that would work...
03:26:14 <lambdabot> Consider it noted.
03:26:14 <omar> hi
03:26:34 * ivanm waves idly in omar's general direction
03:28:46 <omar> i am a 15 years old boy whant to learn programming what lang. should i learn
03:28:52 <om-foxy> is there any way to get Haddock to suppress instances from a documentation file?  I use GeneralizedNewTypeDeriving (a great feature for monad stacks) in a hidden Types.hs, but the instances get shown in the documented file (which exports the type, but the internals of its structure are getting leaked).
03:29:19 <omar> any help
03:29:41 <arw_> omar: doesn't really matter which language you learn. don't learn visual basic or php though.
03:30:14 <arw_> omar: but usually after your first language you will learn many others with very different concepts.
03:30:19 <om-foxy> omar: http://en.wikibooks.org/wiki/Haskell
03:30:24 <ivanm> omar: note that we're kinda biased in this channel...
03:30:30 <ivanm> om-foxy: no, unfortunately :(
03:30:47 <ivanm> even if the class isn't exported the instances are listed by haddock :s
03:30:52 <om-foxy> ivanm: thanks.
03:30:55 <Saizan> om-foxy: you know that the instances get exported at the haskell level too, right?
03:31:04 <ivanm> Saizan: not if the class isn't exported!
03:31:17 <om-foxy> Saizan: haskell level?
03:31:44 <ivanm> e.g. http://hackage.haskell.org/packages/archive/graphviz/2999.10.0.1/doc/html/Data-GraphViz-Commands.html#t%3AGraphvizCanvas <-- see the GraphvizResult instance listed
03:31:45 <arw_> omar: try to find somebody who can teach you, check your code and tell you about your mistakes, somebody with whom you can discuss your problems.
03:31:49 <om-foxy> Oh, right, Haskell not Haddock!!!
03:31:59 <arw_> omar: that will really accelerate your progress.
03:32:27 <omar> ok
03:32:38 <omar> thank you
03:32:43 <Saizan> om-foxy: in the sense that if module A imports Types or any module that imports Types, the instances will be visible in A
03:34:29 <om-foxy> Saizan:  Yeah, I'm au fait with the Haskell side.  What I am looking right now is the documentation for my EDSL and the documentation leaks MonadState and MonadReader instances with unlinked type parameters (the internal implementation of my ADTs).
03:54:03 <bss03> ivanm: Wow, okay, that code was a lot easier to write once I had MonadTrans, StateT, etc. in my toolbox.
03:54:49 <bss03> I still have to fix up some minor type errors, but it got me a lot further.
04:02:26 <dobblego> at ghci my home/end keys are sending H and F so I can bind them with ~/.haskeline but then I cannot use the H or F character 
04:03:05 <merijn> dobblego: Sounds like a problem with readline, did you try setting appropriate values in .inputrc ?
04:03:45 <dobblego> merijn, I know nothing of .inputrc where might I find it?
04:04:24 <Saizan> ghci either uses haskeline or readline, not both
04:04:42 <merijn> Oh, I though it used readline, not sure tbh
04:06:19 <ivanm> merijn: ummm, ghc hasn't used readline since 6.10.1
04:07:21 <merijn> ivanm: Well, that explains my confusion, I only updated from 6.10 a week or so ago and remembered using readline
04:07:53 <fxr> dobblego: did you see this one? http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
04:08:25 <dobblego> fxr, yes I set that up a while ago and it was working fine but then I change terminal application and it has changed
04:09:05 <fxr> maybe the control sequence changes when you change the terminal app.
04:11:58 <dobblego> what kind of control sequence is H?
04:16:36 <fxr> dobblego: do you use putty?
04:16:41 <dobblego> no
04:16:57 <fxr> what is your terminal emulator?
04:17:10 <dobblego> I am using gnome-terminal (I was using konsole)
04:17:27 <Starfire> dobblego: Do you mean ^H ?
04:17:36 <dobblego> no, one single H
04:18:40 <dobblego> konsole was using "\ESC[H" and I have this in ~/.haskeline
04:18:41 <fxr> dobblego: and what is your shell?
04:18:46 <dobblego> bash
04:19:27 <fxr> what is the output of the command "echo $TERM"
04:19:30 <benmachine> \e[H apparently means move to top left corner
04:19:35 <benmachine> http://en.wikipedia.org/wiki/ANSI_escape_code
04:19:35 <dobblego> xterm
04:20:42 <fxr> hmmm it should send ESC[1, not ESC[H
04:21:05 <dobblego> it's sending only H not ESC[H
04:22:05 <bss03> How portable is -XFlexibleContexts?  Always supported in the Haskell Platform?
04:23:24 <fxr> dobblego: try xmodmap -e 'keycode <home> = Home', replace <home> by looking up the keycode, use xev
04:24:38 <fxr> home is 110 and end is 115 in my configuration
04:25:09 <Jafet> bss03: there's only one Haskell compiler, so you can check if it has that (and it does, yippee)
04:25:36 <bss03> Jafet: There's PHC, too, right?
04:25:44 <Saizan> bss03: it's a fairly uncontroversial extension
04:26:06 <tryhaskell> hi there.
04:26:11 <bss03> Jafet: Then, there are some environs where I might be under Hugs, right?
04:26:23 <Saizan> i think PHC is one of the few that don't exist yet :)
04:26:40 <Starfire> Is there a list of controversial extensions?
04:26:50 <bss03> Maybe I should just avoid it with a more explicit type sig... 
04:27:15 <bss03> I can't seem to get ghc to read my {-# LANGUAGE stuff #-} anyway. :(
04:27:32 <Saizan> it has to be at the top of the file
04:27:37 <Jafet> I thought phc was already assimilated into ghc
04:28:52 <Saizan> is there a phc? i can only find a php compiler..
04:28:55 <Jafet> Wait, google is telling me "phc" is a "PHP compiler"
04:29:32 <bss03> Hrm, I thought I read about PHC in some of the Concurrency stuff I was reading.
04:29:33 <bss03> Maybe not.
04:30:21 <bss03> Still, I'd like to write *Standard* Haskell when possible; I've had to fix to many C/C++ programs that ignored the standard.
04:30:33 <bss03> I'd prefer no one ever has to do that to my Haskell code. :P
04:33:27 <Jafet> Most of us use the Haskell standard for its features, not its limitations
04:34:04 <Saizan> FlexibleContexts is kind of required once you start with multi parameter type classes, and those are pretty widespread
04:34:04 <Jafet> Whatever, if you plan on your code lasting more than a few compilers' lifetimes, then do it
04:38:50 <bss03> Jafet: Standards generally move forward in a mostly backwards-compatible way, with literally decades between deprecation of a feature and it's removal.
04:39:15 <bss03> Jafet: So, I'm pretty sure that if I write *Standard* haskell code, it'll last more than a few compliers' lifetimes.
04:40:29 <bss03> Blatant disregard for standards is what gave up the "tag soup" of the Web last decade.
04:41:22 <aristid> bss03: that is based on the idea that there would be a superior standards-based alternative, and that has never been really tested
04:41:39 <Jafet> bss03: ??/??'??'/
04:58:38 <Saizan> bss03: when the extensions you use are documented and somewhat standardized themselves that's less of a problem
05:03:43 <arcatan> anyway the new features for the future Haskell standards are first tested as extensions
05:04:06 <bss03> Yeah, that's the way it should be.
05:04:40 <Twey> So if there's a widely-used extension, it's probably going to be standardised soon anyway.
05:05:08 <Zao> Or if it's insane, all the users will be euthanised.
05:05:10 <bss03> Anyway, so now I get a stack overflow if I use Control.Monad.State, but not if I use Control.Monad.State.Strict.
05:05:15 <arw_> well, the last haskell standard was created some time ago, so "soon" may always be some decade away...
05:05:42 <bss03> Is there a good way to "tune" my lazyiness so I don't get a stack overflow, but I'm still somewhat lazy?
05:05:56 <Zao> arw_: What about Haskell2010?
05:06:27 <bss03> Haskell 2010 is mostly what I'm following -- I'm also assuming the existence of the packages from the Haskell Platform.
05:06:32 <arw_> Zao: i mean the interval between that and the last one.
05:06:44 <bss03> Earlier this month I heard talk in here of a Haskell 2011.
05:07:44 <bss03> It wouldn't surprise me if some of the more well-tested extensions didn't get some love (i.e. be added to the standard) is the next few years.
05:07:57 <ivanm> sure, once someone has proposed them, etc.
05:22:11 <Saizan> each year there will be an updated standard with the extensions accepted
05:22:44 <ksf> typefams will need some love before we can decide between them and fundeps
05:23:05 <ksf> though I got a feeling that typefams will win
05:23:33 <Saizan> they need some love before they work properly :)
05:23:49 <Starfire> Is there any news on when superclass equality constraints will be supported?
05:23:56 <ksf> ...they're the ones designed with actual type-level programming in mind, unlike all of the typeclass system except fundeps themselves.
05:24:17 * ksf wants inbuilt typecast and typeeq
05:26:51 <zygoloid> dobblego: i /really/ doubt it's sending H and F. much more likely to be sending \[[H or \[OH depending on whether the terminal is in keypad mode.
05:32:03 <zygoloid> is it possible with the current type family design to constrain families Prev and Next such that Prev (Next a) ~ a? my understanding is that superclass contexts aren't enough for that
05:33:03 <ivanm> in what sense?
05:33:19 <zygoloid> what, in what sense? :)
05:33:22 <ivanm> as in being able to define that as being a universal constraint somewhere?
05:33:26 <zygoloid> yeah
05:33:41 <ivanm> then no, I don't think you can state that anywhere :(
05:33:51 <ivanm> might be able to replace both with a GADT though...
05:33:54 <zygoloid> in the same way that with fundeps i can define: class Adjacent a b | a -> b, b -> a, then use that as Prev and Next
05:34:05 * ivanm has seen some magic things with GADTs recently, but isn't really sure what they can be used for
05:35:39 <ivanm> hmmm.... good question...
05:35:42 <zygoloid> i think perhaps my best escape route is to use a fundep for this :)
05:35:52 <ivanm> zygoloid: how do you intend to use this?
05:36:25 <zygoloid> ivanm: i have a type family (a :<=: b), with values either True or False
05:36:40 <zygoloid> i have a bunch of types T1 .. Tn, and a complete set of :<=: instances for them
05:37:09 <ivanm> hmmm...
05:37:26 <zygoloid> now i want to write some code of the form: (forall m. F m :<=: v) => m a) -> (forall m. F m :>=: Next v) => m a) -> (forall m. m a)
05:37:35 <zygoloid> there are some other constraints on m, but they're not relevant to the discussion
05:38:07 * ksf would take the easy way out and generate Next and Prev classes from a TH description of the types.
05:39:07 <zygoloid> that'd work, if i don't need the type system to know that Next (Prev a) ~ a. Perhaps that's enough :)
05:40:57 <ksf> well, as you then have a total ordering you can index them by a natural index, and the whole thing bogs down to Prev (Succ a) ~ a
05:41:21 <ksf> ...which is easier to solve as a is constrained to be a Nat
05:41:31 <ksf> (hell we need a better kind system)
05:42:23 <ksf> you don't even need undecidable instances for minus, though it's of course partial.
05:50:09 <kremsera> ive got a function which is operating on storable arrays
05:50:35 <kremsera> as long as it is defined within the sourcefile the runtime is 0.1 s 
05:50:58 <kremsera> once i use it in another sourcefile the runtime rises to 2s
05:51:17 <ivanm> have you profiled?
05:51:20 <ivanm> how are you compiling?
05:51:28 <ksf> did you use -O2?
05:51:33 <kremsera> ghc -O2 -o atest --make
05:51:53 <ivanm> -funbox-fields wouldn't hurt, but probably won't make a difference
05:52:14 <ivanm> well, GHC doens't do whole program optimisation, but having a difference of 20x is a bit weird
05:52:43 <quicksilver> that'll be inlining
05:52:53 <kremsera> i call it only once
05:52:55 <quicksilver> and possible rule firing failure due to lack of inlining.
05:53:17 <quicksilver> or specialisatoin failure
05:53:23 <quicksilver> mark the function as INLINE
05:53:48 <kremsera> well it is a recursive function, which is called once - and types are given explicit
05:54:05 <quicksilver> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/pragmas.html#inline-noinline-pragma
05:54:14 <ksf> does it take a function argument?
05:54:27 <quicksilver> recursive functions don't get inlined, I don't think
05:54:36 <quicksilver> but perhaps something else was being inlined into it, then
05:54:47 <ksf> not even unrolled, at least last time I looked.
05:55:04 <kremsera> it takes 3 int32 as parameters
05:56:43 <kremsera> it just returns an initialized array, and fills it recursively
05:58:55 <ksf> hmmm the next thing I'd to would be to double-check that it's still slow after rm *.o *.hi and if yes, report a bug
05:59:42 <kremsera> okay tried inlining - you where right
05:59:52 <quicksilver> \o/
06:00:00 <kremsera> runtime dropped to the expected runtime
06:00:13 <kremsera> but: wtf
06:00:13 <quicksilver> very likely it's not the inlining itself, it's that the inlining is required for the RULES to fire
06:00:21 <kremsera> ah ok
06:00:29 <quicksilver> I think the 'fancy modern' arrays packages rely heavily on RULES for great performance
06:00:44 <quicksilver> RULES are an intrinsically static transformation relying on the code being visible in the right form to the front end.
06:00:57 <quicksilver> it's a bit unsatisfactory in a way but it's the best we have right now
06:01:20 <kremsera> thanks! :D
06:01:34 <ksf> all because everybody is lazy and implements compiler passes in vanilla libraries.
06:03:29 * hackagebot hslogger 1.0.12 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.0.12 (JohnGoerzen)
06:05:30 * hackagebot hslogger 1.1.0 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.1.0 (JohnGoerzen)
06:32:37 * hackagebot collections-api 1.0.0.0 - API for collection data structures.  http://hackage.haskell.org/package/collections-api-1.0.0.0 (JeanPhilippeBernardy)
06:36:38 * hackagebot collections-base-instances 1.0.0.0 - Useful standard collections types and related functions.  http://hackage.haskell.org/package/collections-base-instances-1.0.0.0 (JeanPhilippeBernardy)
06:36:53 <djahandarie> List are kind of used as multisets in Haskell sometimes aren't they?
06:37:09 <dafis> Sometimes
06:37:27 <fasta> djahandarie, it is better to not confuse things like that.
06:38:08 <fasta> In my projects when I want to use a multi-set I import my trivial MultiSet module. 
06:39:07 <djahandarie> I mean, even in Data.Foldable they provide a toList when in reality you usually wouldn't want a list because the order would be irrelevant
06:40:18 <dafis> djahandarie: but there are many functions working on lists, so it's arguably useful
06:40:27 <dafis> (to have a toList)
06:40:40 <fasta> djahandarie, I don't think the Haskell libraries are particularly well-designed. 
06:41:24 <fasta> djahandarie, but they typically have used other design goals and other limitations.
06:41:40 <fasta> djahandarie, e.g. no funky type tricks. 
06:43:03 <djahandarie> fasta, hm, what do you mean by funky type tricks?
06:43:27 <fasta> djahandarie, use of fundeps for example.
06:43:44 <fasta> djahandarie, MPTCs
06:44:17 <dafis> fasta: those aren't funky, they're fairly run-of-the-mill
06:44:37 <fasta> dafis, there are funky according to the people writing the libraries.
06:45:32 <dafis> fasta: Which libraries? I see lots of MPTCs and FunDeps (those are moving to TFs now)
06:46:19 <fasta> dafis, point me to something in base.
06:47:06 <fasta> dafis, also compare how a Prelude written by expert Haskellers with extensions and one without looks like.  
06:47:06 <dafis> fasta: base doesn't count, that has to be portable
06:47:32 <fasta> dafis, the stuff on Hackage certainly use all the features.
06:47:38 <fasta> uses*
06:48:46 <dafis> fasta: Yes. And for the core libraries, you can't use those features which haven't made the standard because they need to be portable
06:49:11 <gwern> (it's a laudable goal, even if in practice everyone uses ghc)
06:49:17 <dafis> And most features are GHC-only so far
06:49:20 <luite> why does base have to be portable? the source code already has lots of ifdefs for more efficient implementations (compared to those in the report)
06:49:46 <gwern> fasta: what does a Prelude written by expert haskellers using -fglasgow-exts look like?
06:49:49 <dafis> luite: the implementation doesn't need to be portable, but the API
06:50:12 * JuanDaugherty wonders if EclipseFP is worth using
06:50:15 <fasta> gwern, mostly everything overloaded, mostly fundeps everywhere (at least a few years ago).
06:50:22 <fasta> JuanDaugherty, no, next question. 
06:50:31 <gwern> fasta: oh, you mean with actual changes to the api?
06:50:34 <luite> dafis: ah ok, missed that part of the discussion :)
06:50:56 <fasta> gwern, I mean such that people can actually write generic algorithms. 
06:51:03 <JuanDaugherty> that was a fasta answer than I expected
06:51:30 <fasta> JuanDaugherty, that said, everything has something broken about it. 
06:51:41 <JuanDaugherty> especially here
06:51:48 <fasta> Maybe Visual Haskell already works again. 
06:52:17 <Zao> fasta: I can't wait for Phyx- to get a public build out the door.
06:52:19 <dafis> fasta: re EclipseFP, what's particularly bad about it? (Just curious, I stick with kate)
06:53:14 <fasta> dafis, every time I tried it, it failed to deliver. 
06:53:34 <dafis> fasta: can you be a bit more specific?
06:53:36 <JuanDaugherty> good enuf 4 me
06:53:47 <fasta> dafis, I have used lots of broken software in the past, if I cannot get it to work in an acceptable state, it was never intended to be used.
06:53:57 <fasta> dafis, I don't remember, it was too long ago.
06:54:07 <dafis> fasta: okay
06:54:20 <fasta> You are free to waste your time on it, however.
06:54:22 <dafis> fasta: have you tried leksah?
06:54:25 <fasta> dafis, yes. 
06:54:38 <fasta> dafis, it only worked with a new empty project, not with my existing stuff. 
06:54:46 <fasta> I also count it as a failure until it works.
06:54:57 <JuanDaugherty> if a haskell pkg is said to broken, it must be really near useless since some brokenness, as stated, is common in this particular computing subculture
06:55:05 <JuanDaugherty> *to be
06:55:30 <dafis> fasta: I try it out every couple of months, but I'm always back with kate very soon
06:55:48 <fasta> dafis, right, they release stuff which isn't worth releasing.
06:56:06 <fasta> Yi does work, btw. It's just that it doesn't do everything one would want.
06:56:08 <dafis> fasta: release early, release often, they say
06:56:17 <fasta> dafis, yes, but it's not what I say :)
06:56:24 <dafis> fasta: nor I
06:56:54 <JuanDaugherty> that would be good if what was released just worked
06:57:17 <dafis> fasta: although, for a project like leksah, I see the point of releasing early to see what's broken and how
06:59:02 <ksf> it's always good to release early and release often.
06:59:36 <ksf> release as soon your code has an identity of its own that doesn't depend on points in a todo list.
07:00:57 <ajnsit> how do I build yhc javascript backend on Linux?
07:01:10 <ajnsit> any pointers?
07:01:32 <ksf> the docs?
07:01:50 <ksf> last time I tried it compiled flawlessly.
07:02:06 <ksf> it badly needs love, though.
07:02:37 <djahandarie> YHC is pretty dead
07:02:39 <ksf> ...and in the end getting haskell to compile to javascript via ghc/llvm might be a better idea.
07:03:18 <ajnsit> hmm okay I'll check ghc/llvm out, thanks ksf
07:03:27 <djahandarie> If by "a better idea" you mean "extremely difficult" I agree
07:03:29 <ksf> er wait that doesn't exist yet.
07:04:05 <ksf> there's a llvm backend for ghc that targets x86, and there's a js backend for llvm. dunno how much work it'd be to combine the two.
07:04:06 <benmachine> just code support for <script type="application/haskell"> into popular browsers!
07:04:10 <benmachine> simple.
07:04:19 <earthy> fsvo simple
07:04:25 <benmachine> yes
07:04:30 <djahandarie> favo simple
07:04:32 <Botje> benmachine: but it wouldn't have any side effects! *ducks*
07:04:33 <benmachine> where one such is, "not simple"
07:05:57 <benmachine> Botje: yes it would. *geese*
07:05:58 <djahandarie> ksf, there's something which transforms LLVM to JS? What?
07:06:42 <djahandarie> afaik Javascript doesn't have any sort of easy goto/jump instruction
07:08:20 <djahandarie> All a google search turns up is someone complaining about jump instructions :P
07:09:15 <ksf> http://github.com/dmlap/llvm-js-backend
07:09:22 <ksf> I once saw a project page, dunno where.
07:11:09 <dankna> I actually think the nicest way to get js support is to build STG on js directly
07:11:20 <dankna> there's an existing backend for ghc which is somewhat bitrotted right now
07:11:51 <ksf> nacl?
07:11:56 <dankna> sorry?
07:12:06 <ksf> does any browser implement it, by now?
07:12:06 * dankna looks querulously at the table salt
07:12:08 <ksf> native client.
07:12:47 <Jafet> > 0 * sum [1..]
07:13:10 <dankna> I'm not quite sure who the question is addressed to, I didn't mention any native client
07:13:39 <ksf> well, js might not be the language of choice in future browsers
07:13:48 <dankna> we can only hope
07:13:49 <ksf> in fact, it's an awful choice today, already.
07:14:02 <dankna> I hope the next one solves their GC problem
07:14:23 <dankna> the GC problem is that there can be references back and forth between the JS heap and the DOM heap, and such references keep objects alive when they shouldn't
07:14:24 <nlogax> native client has no access to the DOM and things like that, so it's more applet-y, not a viable JS replacement
07:14:25 <djahandarie> Haskellers shouldn't bet talking about GC problems
07:14:31 <ksf> there's also an edsl that targets javascript
07:16:00 <ksf> try, e.g., hjscript
07:17:39 <blueonyx> hi, after upgrading to ghc 6.12.3 my program using hint complains: /usr/lib/ghc-6.12.1/package.conf.d/package.cache: openBinaryFile: does not exist (No such file or directory) what to do?
07:18:17 <ksf> change your console encoding to utf8
07:18:45 <ksf> ...it's a regression caused by a slightly different default behaviour of the new io backend.
07:18:58 <ksf> er wait.
07:19:03 <ksf> I'm completely off, there.
07:19:36 <ksf> ...reinstall whatever program tries to read the old package database.
07:19:44 <dafis> blueonyx: did the upgrade remove 6.12.1?
07:20:06 <blueonyx> dafis: the directory still exists
07:20:23 <dafis> blueonyx: and the file too?
07:20:27 <blueonyx> no
07:20:46 <blueonyx> reinstalling hint doesnt help
07:26:15 <ajnsit> does someone have examples for using hjscript?
07:26:35 <ajnsit> the document has no comments
07:26:40 <ajnsit> making it hard to parse
07:26:51 <djahandarie> ajnsit, http://git.ierton.ru/?p=happstack-samples.git;a=blob;f=HJSample.hs;h=42ce3e9f47a081f24c62977cca124764675e9dc6;hb=master
07:27:04 <djahandarie> Not a very good example though
07:27:57 <djahandarie> Unrelated: was that GSoC cabal guy going to integrate HPC into cabal better? Or was that just something I wanted him to do
07:28:17 <hpc> what was that about me? :P
07:28:38 <ajnsit> djahandarie: I'm wondering which parts of that example except the literal xml use HJScript
07:28:48 <BMeph> Uh-oh, no lambdabot... :(
07:29:00 <ajnsit> > 1+1
07:29:07 <ajnsit> uh oh
07:29:09 <djahandarie> hpc, your fault for choosing a nickname starting with h... there is bound to be a haskell library with your name
07:29:27 <dafis> holysmoke
07:29:34 <hpc> hahaha
07:29:39 <dafis> I want to see that library :)
07:30:03 <djahandarie> ajnsit, the js function uses HJScript
07:30:26 <ajnsit> yeah I see it now
07:30:35 <ajnsit> thanks, this helps a little bit
07:30:49 <benmachine> preflex: seen lambdabot
07:30:49 <preflex>  lambdabot was last seen on #haskell 4 hours, 4 minutes and 35 seconds ago, saying: Consider it noted.
07:30:57 <djahandarie> I agree that someone should add documentation to HJScript
07:31:17 <BMeph>   hackagebot: holysmoke-0.1: Reminds you of important events according to the Orthodox calendar (DemetriosNikos)
07:31:25 <dankna> cute haha
07:31:25 <BMeph> ;)
07:34:26 <gwern> ajnsit: the only example I've heard of is the gitit calendar
07:34:34 <gwern> > 0 * undefined
07:34:45 <luite> BMeph: bah you made me check hackage
07:34:52 <gwern> bah. darn strictness
07:35:06 <gwern> 0 * x = 0!
07:35:18 <gwern> or 0 * _ = 0, rather
07:35:21 <lambdabotte>   *** Exception: Prelude.undefined
07:39:59 <hpc> gwern: not always; 0.0 * Infinity = NaN
07:55:16 <fryguybob> @botsnack
07:55:26 <lambdabotte> :)
07:59:52 <dafis> @botsnack
07:59:59 <lambdabot> :)
08:00:43 <zygoloid> gwern: 0 * x = 0! = 1? ;)
08:01:03 <mtnviewmark> In my dream last night   "liftM (fmap fmap fmap)" played some crucial part, like a magic spell, and got me out of some sticky situation
08:01:18 <medfly> you need therapy
08:01:56 <mtnviewmark> I'm sure I do!
08:02:07 <Zao> Or brain-compiler integration for your bed.
08:02:57 <Jafet> BedsIDE
08:04:17 <DamienCassou> hi
08:04:31 <dafis> ho
08:05:50 <mtnviewmark> :t liftM (fmap fmap fmap)
08:05:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (m :: * -> *). (Functor f, Functor f1, Monad m) => m (a -> b) -> m (f (f1 a) -> f (f1 b))
08:06:22 <Makoryu> :t fmap fmap fmap
08:06:23 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:06:25 <Makoryu> :t fmap . fmap
08:06:26 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:06:45 <Makoryu> @unpl fmap . fmap
08:06:45 <lambdabot> (\ c -> fmap (fmap c))
08:07:23 <Makoryu> @unpl liftM (fmap . fmap)
08:07:24 <lambdabot> liftM (\ c -> fmap (fmap c))
08:07:28 <Makoryu> Bluh
08:08:23 <bss03> > (fmap fmap fmap) (+ 2) [Just 1, Nothing, Just 3]
08:08:23 <lambdabot>   [Just 3,Nothing,Just 5]
08:09:18 <bss03> > liftM (fmap fmap fmap) (+ 2) [return Just 1, return Nothing, return Just 3]
08:09:19 <lambdabot>   Couldn't match expected type `[a -> Data.Maybe.Maybe a]'
08:09:19 <lambdabot>         against in...
08:09:53 <Makoryu> :t [return $ Just 1, return Nothing, return $ Just 3]
08:09:54 <lambdabot> forall a (m :: * -> *). (Monad m, Num a) => [m (Maybe a)]
08:10:30 <Makoryu> > liftM (fmap . fmap) (+ 2) [return $ Just 1, return Nothing, return $ Just 3]
08:10:31 <lambdabot>   Couldn't match expected type `[m (Data.Maybe.Maybe a)]'
08:10:31 <lambdabot>         against inf...
08:10:47 <Makoryu> :t liftM (fmap . fmap) (+ 2)
08:10:48 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1, Num b) => (a -> b) -> f (f1 a) -> f (f1 b)
08:11:18 <hpc> fmap . fmap == fmap fmap fmap, in lambdabot
08:11:26 <bss03> ? Where'd the Monad go?
08:11:29 <copumpkin> everywhere, actually
08:11:39 <copumpkin> unless you don't have the ((->) r) instance of Functor loaded
08:12:00 <hpc> heh, true
08:12:06 <Makoryu> copumpkin: But then it won't typecheck anyway
08:12:16 <mtnviewmark> Who knew my dream would spark so much exploration!
08:12:18 <hpc> :t liftM
08:12:19 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:12:31 <copumpkin> Makoryu: it would just put Functor ((->) r) into the inferred signature wouldn't it? 
08:12:45 * Makoryu tests
08:12:51 <hpc> :t liftM (fmap . fmap)
08:12:52 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (m :: * -> *). (Functor f, Functor f1, Monad m) => m (a -> b) -> m (f (f1 a) -> f (f1 b))
08:12:52 <Makoryu> copumpkin: Wait, no, yeah, you're right
08:13:33 <hpc> i see what happened
08:13:48 <hpc> it infers the Monad constraint to be (r ->)
08:14:08 <Makoryu> > liftM (fmap . fmap) [(+ 2)] [return $ Just 1, return Nothing, return $ Just 3]
08:14:09 <lambdabot>   Couldn't match expected type `[m (Data.Maybe.Maybe a)] -> t'
08:14:09 <lambdabot>         agains...
08:14:45 <Makoryu> I can't really wrap my mind around this sort of Inception-oriented typehackery
08:14:53 <djahandarie> Haha
08:14:59 <Makoryu> Gotta bone up on my category theory
08:15:04 <kowey> is there some sort of table somewhere showing what base package version goes with what GHC version?
08:15:07 <copumpkin> mmm boning
08:15:12 <Makoryu> Is "Category Theory for Assholes" out yet?
08:15:37 <zygoloid> liftM (fmap fmap fmap) :: m (a -> b) -> (f1 (f2 a) -> f1 (f2 b)). isn't that obvious? ;-)
08:16:08 <zygoloid> oops, forgot an m on the RHS :)
08:16:35 <zygoloid> fmap fmap fmap == fmap . fmap  lifts a function into two functors.
08:16:50 <medfly> but (.) = fmap
08:16:51 <medfly> :p
08:17:19 <Makoryu> :t [(.), fmap]
08:17:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => [(a -> b) -> f a -> f b]
08:17:30 <Makoryu> OH WAIT
08:19:33 <kowey> oh, I think I found what I wanted by going to http://www.haskell.org/ghc/download.html and clicking on the GHC version I was thinking of
08:19:47 <kowey> and then its release notes (and search for "base")
08:21:17 * hackagebot jackminimix 0.1 - control JackMiniMix  http://hackage.haskell.org/package/jackminimix-0.1 (RenickBell)
08:24:08 <dh__> Hello, why applicative programming is important ? why should I learn it except to read some body's code? 
08:29:17 <djahandarie> dh__, you mean like using applicative functors? They are weaker than Monad and therefore can be used in more places
08:29:33 <dh__> > pure 5 :: Maybe Int
08:29:34 <lambdabot>   Just 5
08:29:40 <dh__> > pure 5 :: [Int]
08:29:40 <lambdabot>   [5]
08:29:57 <dh__> how can I get pure 5 as (->) Int type? 
08:30:21 <copumpkin> > pure 5 6
08:30:22 <lambdabot>   5
08:30:37 <copumpkin> > (pure 5 :: Int -> Int) 7
08:30:38 <lambdabot>   5
08:30:40 <copumpkin> > (pure 5 :: Int -> Int) undefined
08:30:41 <lambdabot>   5
08:30:45 <tromp> :t pure
08:30:47 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
08:30:48 <dh__> oh, thanks :)
08:31:24 <dh__> > (+1) <*> [1,2,3]
08:31:25 <lambdabot>   Couldn't match expected type `(a -> b) -> a'
08:31:25 <lambdabot>         against inferred type ...
08:31:43 <dh__> > pure (+1) <*> [1,2,3]
08:31:44 <lambdabot>   [2,3,4]
08:32:06 <tromp> any example where you cant substitute return for pure?
08:32:28 <dh__> > return (+1) <*> [1,2,3]
08:32:29 <lambdabot>   [2,3,4]
08:32:30 <copumpkin> tromp: a ZipList, mostly :P
08:32:44 <dh__> :t return
08:32:45 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:33:36 <Cale> tromp: It's possible for an applicative instance to exist, but not a monad instance.
08:33:48 <dh__> I understand the the Applicative for function is the K, S combinator, 
08:34:02 <dh__> but I really don't understand why we need such an abstraction..
08:34:19 <Cale> dh__: It's a pattern into which many libraries fit.
08:34:41 <dh__> how can I know what libraries used applicative?
08:34:56 <Cale> dh__: So my recognising it, and allowing code to be written which works with any applicative functor, we get code that works with all those libraries at once.
08:35:27 <Cale> Of course, every monad is an applicative functor, so all the monadic ones should work (and if they don't it's a bug)
08:35:43 <Cale> dh__: You'll see in the documentation an instance for Applicative
08:36:10 <Cale> http://hackage.haskell.org/packages/archive/graphics-drawingcombinators/1.4.1/doc/html/Graphics-DrawingCombinators.html#t%3AImage
08:36:30 <Cale> Here's an example of an applicative functor which is not a monad.
08:36:31 <dh__> Cale: thanks.
08:37:24 <zygoloid> iirc, applicatives have the property that they compose nicely, unlike monads
08:37:32 <Cale> Actually, I'm pretty sure there is at least one instance of Monad that would work, but apparently the library author didn't think it was relevant.
08:37:51 <Cale> zygoloid: Yeah, if F and G are both applicative functors, then F . G is as well.
08:38:01 <Cale> (where . is composition at the type level)
08:41:14 <Cale> Oh I see, though there's semantically a natural instance of Monad for Image, it might be that implementing it is prohibitively expensive.
08:41:40 <dh__> anybody here use haskell as a working language? rather than a hobby?
08:41:42 <Cale> (At least in terms of the underlying mechanism that this library uses)
08:41:45 <Cale> I do.
08:41:51 <dh__> cool :)
08:42:03 <dh__> do you get paid ? 
08:42:04 <Cale> I'm working for iPwn studios on a game for mobile devices in Haskell.
08:42:05 <Cale> Yep
08:42:16 <fasta> Cale, ah, nice.
08:42:20 <dh__> ohh, iPwn , I think I send my resume yesterday.
08:42:42 <jaredj> is that the one that just made the blog article about hiring people?
08:42:50 <jaredj> wait, resume yesterday, no.
08:42:55 <tibbe> jaredj, no, that was Well-Typed
08:42:58 <dh__> http://www.haskell.org/pipermail/haskell-cafe/2010-May/078173.html
08:43:02 <jaredj> right right
08:43:05 <dh__> I sent to ryan
08:43:22 <Cale> dh__: Yeah, he's RyanT5000 here.
08:43:41 <djahandarie> Oh neat Cale, didn't know you were working with him
08:43:52 <dh__> how is the game going ? did you published it?
08:44:50 <Cale> dh__: It's going okay. We have a guy who runs around on some terrain (and an editor for said terrain), and a bunch of other stuff. I've been working on the UI for menus and inventory, etc.
08:45:28 <Cale> (It's not so near to publication at this point.)
08:45:29 <dh__> keep my resume , I want to work on it ( remote only )
08:46:00 <dh__> I worked for phone game about 8 years, bored of c, c++ and java.
08:46:34 <copumpkin> oh wow, Cale working for iPwn
08:46:39 <copumpkin> everyone is working for iPwn!
08:46:45 <dh__> and I have a mac and ipodtouch at home, Object-C is installed.
08:47:05 <copumpkin> Cale: does that take you to boston occasionally? :)
08:47:32 <Cale> There are a lot of interesting issues with using Haskell on mobile devices which make things pretty tricky. Major garbage collections can occasionally take as long as 300ms, so there's an underlying C++ program which we feed with future animation (that gets revised continuously), so that things don't stop even if the Haskell running on top does.
08:47:39 <Cale> copumpkin: I haven't moved at all.
08:48:20 <zygoloid> Cale: which platforms are you targetting? just iPhone or android too?
08:48:25 <Cale> copumpkin: But we occasionally Skype, and are often in contact via IRC and Google chat.
08:48:59 <dh__> where are you located , Cale ?  if you don't mind.
08:49:01 <Cale> zygoloid: We hope to support more platforms. I think kmc is working on GHC for Android.
08:49:11 <Cale> dh__: Brantford, Ontario
08:50:10 <dh__> Canada ? wow, I've been there for 5 years.
08:50:43 <dh__> Is iPwn still hiring ? 
08:50:49 <copumpkin> Cale: ah, damn! you should try to make it down for one of the boston HUGs someday :P
08:51:04 <Cale> dh__: I'm not sure, you'd have to ask Ryan.
08:51:22 <djahandarie> I've meant to go to like the last 3 Boston HUGs and haven't
08:51:34 <djahandarie> Instead I've been to a San Francisco HUG
08:52:18 <djahandarie> When I live only like 1:40 from Boston :P
08:52:42 <Cale> copumpkin: Yeah, that would be fun to do at some point.
08:52:58 <dh__> > pure (.) <*> (+1)  
08:52:59 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> f a -> f b)
08:53:00 <lambdabot>    arising...
08:53:11 <dh__> :t <*>
08:53:12 <lambdabot> parse error on input `<*>'
08:53:18 <Cale> :t (<*>)
08:53:18 <dh__> :t (<*>)
08:53:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:53:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:54:35 <djahandarie> Note that in most cases you would use fmap there, not pure x <*>
08:55:10 <copumpkin> or <$>
08:55:42 <djahandarie> Which is fmap ;)
08:55:48 <djahandarie> :t (<$>)
08:55:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:55:53 <djahandarie> :t fmap
08:55:54 <aristid> :t fmap <$> (+1)
08:55:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:55:54 <lambdabot> forall a b (f :: * -> *). (Functor f, Num b) => (a -> b) -> f a -> f b
08:56:03 <dh__> I just try to understand the composition law of Applicative : pure (.) <*> u <*> v <*> w = u <*> ( v <*> w )
08:56:39 <djahandarie> Note that (.) is fmap in lambdabot
08:57:06 <dh__> :t (.)
08:57:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:57:12 <aristid> :t (.) . (+1)
08:57:13 <lambdabot> forall a b (f :: * -> *). (Functor f, Num b) => (a -> b) -> f a -> f b
08:57:17 <djahandarie> With the ((->)r) functor instance allowing it to be used for regular function composition
08:58:06 <dh__> >  (+1) . (*2) $ 3
08:58:07 <lambdabot>   7
08:58:21 <dh__> > (.) (+1) (*2) $ 3
08:58:22 <lambdabot>   7
08:59:47 <dh__> > pure (+1) <*> pure 5
08:59:48 <lambdabot>   No instance for (GHC.Show.Show (f a))
08:59:49 <lambdabot>    arising from a use of `M4265826098...
09:00:11 <djahandarie> At least it doesn't give the overlapping instances error anymore
09:00:48 <dh__> :t pure (+1)
09:00:49 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f (a -> a)
09:01:00 <dh__> :t pure 5
09:01:01 <lambdabot> forall t (f :: * -> *). (Num t, Applicative f) => f t
09:01:14 <dh__> :t pure (+1) <*> pure 5
09:01:15 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a
09:01:39 <dh__> > ( pure (+1) <*> pure 5 ) :: Maybe Int
09:01:40 <lambdabot>   Just 6
09:01:50 <djahandarie> > (+1)
09:01:51 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:01:51 <lambdabot>    arising from a use of `...
09:02:01 <djahandarie> Nevermind, it was only for functions
09:02:23 <dh__> > ( pure (+1) <*> pure 5 ) :: [Int]
09:02:24 <lambdabot>   [6]
09:03:30 * hackagebot iteratee 0.3.6 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.3.6 (JohnLato)
09:03:45 <dh__> can anybody give an example of pure (.) <*> u <*> v <*> w? 
09:06:15 <copumpkin> > zipWith (zipWith (.) [(+1), (*4)] [(^2), (*9)]) [1,3]
09:06:16 <lambdabot>   Couldn't match expected type `a -> b -> c'
09:06:16 <lambdabot>         against inferred type `[...
09:06:21 <copumpkin> pff
09:06:25 <copumpkin> > zipWith id (zipWith (.) [(+1), (*4)] [(^2), (*9)]) [1,3]
09:06:26 <lambdabot>   [2,108]
09:06:44 <djahandarie> pure (.) <*> u <*> v <*> w is just ((fmap `fmap` u) <*> v) <*> w
09:07:32 <hpc> or more cleanly, (fmap u) <$> v <*> w
09:07:53 <hpc> er
09:08:05 <hpc> fmap <$> u <*> v <*> w
09:08:16 <dh__> what's the emotion that I'm totally lost ? 
09:09:26 <djahandarie> :t (\u -> pure (.) <*> u)
09:09:27 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a -> f b)
09:10:05 <djahandarie> That only happens because (.) = fmap in lambdabot
09:10:16 <djahandarie> :t (\u -> pure fmap <*> u)
09:10:17 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a -> f b)
09:11:44 <djahandarie> :t (\u v -> (pure fmap <*> u) <*> v)
09:11:45 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
09:12:16 <djahandarie> :t (\u v w -> ((pure fmap <*> u) <*> v) <*> w)
09:12:17 <lambdabot> forall a b a1 (f :: * -> *). (Applicative f) => f (a -> b) -> f (a1 -> a) -> f a1 -> f b
09:14:23 <djahandarie> :t (\u v w -> ((pure fmap <*> (u :: [Int->Float])) <*> v) <*> w)
09:14:25 <lambdabot> forall a. [Int -> Float] -> [a -> Int] -> [a] -> [Float]
09:15:06 <zygoloid> > pure (.) <*> [(+2), (*2)] <*> [(+3), (*3)] <*> [10, 100]
09:15:07 <lambdabot>   [15,105,32,302,26,206,60,600]
09:16:09 <dh__> wow...
09:17:02 <dh__> zygoloid: what is your code doing ? 
09:17:03 <djahandarie> > pure (.) <*> [(+a), (*b)] <*> [(+c), (*d)] <*> [e, f] :: [Expr]
09:17:04 <lambdabot>   [e + c + a,f + c + a,e * d + a,f * d + a,(e + c) * b,(f + c) * b,e * d * b,...
09:17:26 <dh__> :i Expr
09:18:26 <dh__> :t Expr
09:18:27 <lambdabot> Not in scope: data constructor `Expr'
09:18:33 <zygoloid> > [ (a . b) c | a <- [(+2), (*2)], b <- [(+3), (*3)], c <- [10, 100] ]
09:18:34 <lambdabot>   [15,105,32,302,26,206,60,600]
09:18:38 <zygoloid> dh__: ^^ that's what it's doing.
09:18:43 <dh__> djahandarie: what is that Expr ? 
09:18:58 <zygoloid> dh__: that's some magic to allow symbolic calculations
09:19:03 <djahandarie> Yeah
09:19:12 <zygoloid> Expr is a Num type which allows you to see what calculation was performed
09:19:18 <zygoloid> > a ^ 5
09:19:19 <lambdabot>   a * a * (a * a) * a
09:19:21 <djahandarie> I just used it to make it clear how it's being evaluated
09:19:56 <Makoryu> :t a
09:19:56 <lambdabot> Expr
09:20:09 <dh__> > a ^ 5
09:20:10 <lambdabot>   a * a * (a * a) * a
09:20:21 <dh__> where can I import that Expr
09:20:30 <zygoloid> @hackage simplereflect
09:20:31 <lambdabot> http://hackage.haskell.org/package/simplereflect
09:20:45 <zygoloid> @hackage simple-reflect
09:20:45 <lambdabot> http://hackage.haskell.org/package/simple-reflect
09:20:46 <zygoloid> oops :)
09:22:01 <djahandarie> In the end it's just the lambdabot (.) that makes things confusing for this example
09:22:12 <dh__> time to bed, good night , and thanks everybody !!!!!
09:22:31 <djahandarie> Night
09:26:41 <gianluca> hi everyon, I have a question which I fear has a negative answer: is it possible to convince the type system to compute the transitive closure of a relation expressed as a multiparameter type class?
09:29:15 <zygoloid> not in general, no. given "A `R` C", there's no way for it to guess / search for an intermediate B to go via
09:30:00 <zygoloid> if, for each A (or for each C) there's a unique B to follow next, you could probably get something working with undecidable instances
09:30:11 <gianluca> mhm i see
09:31:12 <gianluca> well thanks
09:31:54 * djahandarie didn't fully understand the question
09:32:06 <leimy> Is it just me or does all this iteratee stuff seem unnecessary and complex?
09:32:40 <glguy> leimy: There are certainly some complex implementations of it
09:32:41 <mightybyte> leimy: You're not the first person to ask that.
09:32:51 <leimy> I didn't think I would be
09:33:29 <leimy> I mean, I can read some chunk of data from a handle, come back to it later and get exceptions without iteratee.  Why on earth do I need the abstractions I have trouble wrapping my head around for iteratee to work, and why is that making my code better?
09:34:15 <leimy> in fact, I'd argue most haskell programmers couldn't understand iteratee well enough to use it, so it's impractical.  It's either that or I'm just in the low end of the bell curve of dumb haskellers :-)
09:34:30 <glguy> Because you don't want to have to deal with the hassle of manual buffer management
09:34:39 <glguy> it is an abstraction, it hides things for you
09:35:02 <leimy> True, however I can write a take bytes from handle function too :-)
09:35:57 <pra> sdf
09:35:59 <Philonous> leimy: Explicit handles don't compose and it take manual programmer intervention to prevent them from leaking. 
09:36:35 <leimy> lots of stuff in haskell requires manual programmer intervention to prevent leaks in haskell
09:36:42 <leimy> due to lazy evaluation.
09:37:18 <Philonous> leimy: Is that an argument against an abstraction that does the work for you? 
09:37:25 <leimy> no it's not :-)
09:37:50 <quicksilver> iteratees let you write pure code to handle the data
09:37:51 <leimy> it's an argument for that abstraction.  I guess my point is if you're programming haskell, you'd better get used to the idea that laziness will bite you in the ass once in the while.
09:37:54 <quicksilver> without reading all the data at once
09:38:02 <quicksilver> and without using interleaved IO.
09:38:08 <djahandarie> gianluca, zygoloid, what would a transitive closure be in the context of the type system?
09:38:26 <djahandarie> Oh, looks like gianluca left
09:38:36 <leimy> quicksilver: yes, but I think the abstraction is pretty damned complex.  Even dons said he had trouble with the abstraction until he implemented it himself :-)
09:38:56 <leimy> I mean, if dons had trouble with it, what chance does not-dons have? :-)
09:39:04 <Philonous> djahandarie: You can treat multi parameter type classes as relations on types. And you can investigate transitive closures of those
09:39:21 <quicksilver> leimy: I'm not sure what to say.
09:39:25 <quicksilver> it's not a complex idea.
09:39:42 <zygoloid> djahandarie: the transitive closure of a relation R is the smallest relation R' such that forall a b. a R b => a R' b and forall a b c. a R' b, b R' c => a R' c
09:39:43 <quicksilver> "read a chunk at a time, pass the chunk to a callback"
09:39:57 <quicksilver> any imperative programmer who's done any IO work would grasp that instantly.
09:39:58 <leimy> quicksilver: fundamentally it's based on left folds with potential early termination.  I get that, it's just that when I actually try to use the thing, I run into all kinds of issues with my understanding of the situation.
09:40:02 <zygoloid> djahandarie: two-parameter typeclasses are binary relations on types
09:40:06 <jedai> leimy: You have to consider that when dons tried it there was even less introduction material
09:40:18 <leimy> there's introuction material!?!?
09:40:24 <leimy> er introduction.
09:40:29 <jedai> leimy: no
09:40:37 <quicksilver> I don't think the idea is complex. As glguy remarked, there are complex ways to implement it.
09:40:43 <Philonous> leimy: The implementation in the new package (iteratee ) is a pretty straight forward implementation of the basic idea. No rocket science going on there.
09:40:46 <leimy> If so, it might be easier to wrap one's head around.
09:40:46 <jedai> leimy: but there were even less of them at the time :)
09:40:53 <zygoloid> djahandarie: imagine we have class Less a b, instance Less (a,b) (a,b,c), instance Less (a,b,c) (a,b,c,d)
09:40:54 <quicksilver> And there are clever ways to implement it, which hide some of the complexity behind a neat trick.
09:41:04 <leimy> jedai: :-)
09:41:09 <quicksilver> but the basic point "read chunk by chunk, call a callback to process each chunk" is, surely, totally natural?
09:41:11 <zygoloid> gianluca, i think, wanted an implicit instance Less (a,b) (a,b,c,d)
09:41:23 <quicksilver> and common in all kinds of traditional libraries
09:41:45 <leimy> maybe it's the application I'm writing.  I need a handle per Haskell thread, and I need it to stay open forever, so that kind of leak isn't the problem.  
09:41:46 <zygoloid> iteratees decouple the impure "read chunks" from the pure "process chunks"
09:41:52 <quicksilver> right.
09:41:55 <leimy> And iteratee seems to be a bit of overkill for me.
09:42:13 <jedai> quicksilver: Yeah, I think everyone gets the basic idea... It's the implementation of it so that it be composable and can interact with an arbitrary monad that's a little bit tougher to swallow
09:42:22 <quicksilver> and then you think of natural improvements like the chunk-processor being able to say "stop now"
09:42:23 <leimy> I just need to keep using that Handle and read chunks on occasion for processing.
09:42:50 <leimy> jedai: yes, I think that's where my mind doesn't bend :-)
09:42:55 <leimy> there is no spoon!
09:42:55 <glguy> Its the phase of "Now what was an EnumeratorGMXAPF... again?"
09:43:16 <quicksilver> or the chunk processor being able to say "save this bit for the next invocation of me"
09:43:35 <quicksilver> and the ability to compose abstractions to, for example, turn an 8K-chunker into a line-chunker.
09:44:00 <quicksilver> it's not that different from something like the composable streams in java or C++, I don't think.
09:44:09 <quicksilver> but the composability works better and the processor gets to stay pure.
09:44:13 <quicksilver> if it wants to.
09:44:25 <glguy> I like the ability to transform a constant-space function that used to operate on bytes into one that operates on base64-encoded bytes
09:44:39 <glguy> easily, and while preserving the chunk behavior
09:45:03 <leimy> quicksilver: yes, those are nice advantages.  Unfortunately, my code ends up having to run a lot of stuff under some monad stack ending in IO :-)
09:45:31 <leimy> so it seems of little use to bother fighting to make things pure
09:46:05 <leimy> I know you're all gasping at the heresy
09:46:11 <leimy> :-)
09:46:18 <glguy> If your program isn't complicated enough to benefit from the library, then you shouldn't try to force it in
09:46:29 <glguy> I don't think that it has been sold as a universal tool
09:46:35 <pra> pra
09:46:37 <pra> hi
09:46:44 <pra> I am new to haskell
09:46:51 <pra> can anybody help me
09:46:55 <pra> to know about it
09:46:56 <dolio> Of course you should. "All lazy IO must be replaced by iteratees" is now standard #haskell mantra. :)
09:47:05 <Zao> pra: If you ask questions about things, maybe.
09:47:05 <leimy> now that I've said that, I would, some sweet day, like to get the time to put the processing into a pure module.  
09:47:16 * glguy has been out of the #haskell loops for a while. Is iteratee the new fad?
09:47:21 <Zao> pra: Have you read any of the "books" on it?
09:47:25 <pra> right now I am downloading
09:47:29 <quicksilver> glguy: anti-lazy-IO is my particular fad
09:47:31 <leimy> Then somehow wed it to some IO mechanism.
09:47:31 <pra> haskell
09:47:32 <Zao> glguy: Judging by -cafe, it seems so.
09:47:35 <pra> for mac
09:47:45 <quicksilver> glguy: or interleaved, at least, since I disapprove of that use of the word lazy.
09:47:48 <pra> Zao: not yet
09:47:54 <leimy> But that's going to take a little doing.  
09:47:55 <glguy> quicksilver: surprise-io?
09:48:05 <pra> I am researcher of AI
09:48:18 <pra> so I need to learn programming language
09:48:23 <leimy> Also, in the world of companies with deadlines, such opportunities are often only in my spare time, and I have a 2 year old, so that's out :-)
09:48:31 <pra> one of my friend told me
09:48:37 <pra> to learn haskell
09:48:44 <pra> so I am downlaoding the file
09:48:57 <leimy> I preordered LYAH.  What a neat looking book that is.
09:49:16 <djahandarie> pra, Haskell has a large learning curve, it'll take awhile. Coming from another functional programming language helps a bit
09:49:23 <quicksilver> glguy: I quite like that.
09:49:39 <djahandarie> pra, a good place to start in my opinion is http://learnyouahaskell.com
09:49:42 <pra> djahandarie: okie
09:49:53 <leimy> pra: I second that :-)
09:49:54 <BONUS> leimy: ooh, even i havent preordered it yet :D
09:50:02 <leimy> BONUS: you wrote it though.
09:50:04 <pra> djahandarie: thank you so much
09:50:15 <leimy> BONUS: at least I presume this is the same BONUS
09:50:28 <djahandarie> pra, sure, frel free to idle in this channel and ask questions if you ever have any
09:50:28 <BONUS> yeah its me
09:50:39 <djahandarie> feel free*
09:50:42 <pra> one question to all of you
09:50:47 <quicksilver> glguy: I quite like that.
09:50:53 <leimy> BONUS: thanks for writing it.  I'm happy to part with some small fraction of my pay to obtain it when you're done :-)
09:50:54 <pra> as I said I am new to this programming language
09:50:55 <quicksilver> glguy: I bet I could find a lambdacat to go with it.
09:51:04 <glguy> quicksilver: let me know if you do
09:51:08 <BONUS> leimy: much appreciated
09:51:19 <pra> do you think you all this Haskell programming laanguage help full for AI 
09:51:19 <leimy> BONUS: I may get copies for a few other folks as gifts even.
09:51:50 <BONUS> leimy: well, it's better than getting socks, that's for sure
09:51:57 <nus> pra, which programming languages you're used to?
09:52:00 <glguy> pra, As an AI researcher, what language features would help you in your work?
09:52:15 <leimy> pra: you can do so many things with Haskell.  If Haskell isn't good at it, you can create a small language with Haskell fairly easily to solve the problem you're concerned with.
09:52:22 <nus> (and what's AI nowadays, anyway?)
09:52:27 <leimy> well once you're accomplished with Haskell
09:52:32 <Botje> you can preorder LYAH?!
09:52:37 <leimy> Botje: on amazon :-)
09:52:42 <mux> mmm, does cabal now builds packages without profiling by default?
09:52:49 <djahandarie> Botje, for awhile now
09:52:52 <leimy> mux: that's been my experience
09:52:58 <pra> nus: java
09:53:11 <djahandarie> Ouch java, that's going to be a rough transfer
09:53:19 <mux> leimy: do you know when that changed?
09:53:42 <Botje> hmm, it's EUR 42
09:53:46 <nus> pra, how do you use java in the research?
09:53:49 <leimy> mux: I think it's always defaulted to not building the profiling libs.
09:53:54 <Botje> fair enough :)
09:53:56 <pra> nus: not so much
09:54:15 <pra> but I am really interest in neural network and Fuzzy
09:54:20 <mux> I guess my memory is flakey
09:54:27 <pra> my friend to me to learn Haskell 
09:54:27 <DukeDave> Would someone like to weigh in on this: liftReadsToParse p f = p >>= \s -> if null (f s) then fail "No parse" else (return . fst . head ) (f s)
09:54:29 * mux sets library-profiling: True in ~/.cabal/config
09:54:33 <pra> so I am starting Haskell
09:54:56 <leimy> :t fail
09:54:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
09:55:39 <nus> pra, uhh, are you really in Nepal? And is there an AI research community?
09:55:39 <DukeDave> Context: I wish to use Numeric.readHex with parsec
09:55:58 <pra> ooo
09:56:13 <pra> nus, how do you know from Nepal
09:56:17 <pra> lol
09:56:19 <pra> great
09:56:27 <pra> not so much but
09:56:33 <pra> I am really interest in AI
09:56:41 <DukeDave> So I pass in a parser (p) to read the string which is the number (e.g. (many1 digit)), and readHex (f)
09:57:07 <DukeDave> pra: Perhaps you can help ressurrect the AI strikeforce!
09:57:09 <DukeDave> http://www.haskell.org/haskellwiki/AI
09:57:38 <DukeDave> I had a bunch of fuzzy stuff I wanted to put up there, but I lost it all when a drive died :'(
09:57:53 <pra> DukeDave: thank you so much
09:58:39 <pra> ooo so great people in chat room
09:59:18 <pra> DukeDave: oo I am so sorry
09:59:28 <djahandarie> It's too bad like none of those nicks are active in here anymore
09:59:55 <DukeDave> pra: Also, you may find this interesting: http://journals.cambridge.org/fulltext_content/supplementary/JFP/online/jfpvol8-5/fuzzy-logic/index.html
10:00:22 <djahandarie> DukeDave, he's still learning Haskell so that might just be scary
10:00:40 <DukeDave> djahandarie: Ah, okay :)
10:00:44 <pra> DukeDave: ooo thanks
10:00:53 <pra> djahandarie: lol
10:01:56 <pra> ok here I get problem
10:02:10 <pra> i complete downloading haskell
10:02:33 <pra> but when I try to install
10:02:40 <pra> there is hidden in install
10:02:49 <pra> for your information I am using mac
10:02:55 <djahandarie> Haskell Platform?
10:03:00 <pra> ya
10:03:26 <djahandarie> Hm I'm not familiar with the mac distribution of that. I believe you just open the dmg and follow the instructions
10:04:02 <pra> http://hackage.haskell.org/platform/
10:04:09 <Makoryu> <pra> there is hidden in install <- Not sure I understand
10:04:12 <pra> I download from here
10:04:20 <glguy> Anyone know if Frama-C has an IRC presence somewhere?
10:04:31 <djahandarie> pra, and what happens when you open the dmg?
10:04:50 <pra> The Glasgow Haskell Compilation System License
10:05:00 <pra> I agree
10:05:01 <pra> this 
10:05:07 <pra> and go next step
10:05:33 <pra> after that install is hidden and Go back button is only enable
10:06:01 <Makoryu> pra: Oh. You mean "the Install button is disabled"?
10:06:11 <pra> ya
10:06:25 <pra> Makoryu: you are right
10:06:28 <Makoryu> pra: Is your hard drive full?
10:06:36 <pra> not at all
10:06:53 <Makoryu> Then there must be some other requirement
10:07:00 <Makoryu> What version of OS X are you using?
10:07:32 <glguy> Did you click on the hard-drive icon before clicking install?
10:07:40 <Makoryu> Old versions (before 10.4 or 10.5) are incompatible with the Haskell Platform
10:07:44 <glguy> Some installers require you to pick a drive to install to (even if there is only one)
10:07:51 <pra> 10.5.8
10:08:22 <pra> Install GHC could not made
10:08:34 <pra> so i start install platform 
10:09:48 <pra> it says :Install Failed: The following install step failed: run postupgrade script for 000-mtl-1.1.0.2.Contact the software manufacturer for assistance
10:12:52 <pra> hello all
10:14:13 <pra> Xcode 2.4
10:14:15 <Makoryu> pra: Wow. I'm not sure what to make of that.
10:14:18 <Makoryu> Errr
10:14:18 <pra> I need this
10:14:28 <pra> before install ing
10:14:29 <Makoryu> Upgrade Xcode
10:14:31 <Makoryu> Yes
10:16:35 <tomasz> out of curiosity, what sort of projects are you using Haskell for?
10:16:54 <pra> oo
10:17:08 <pra> tomasz : are you asking me
10:17:18 <tomasz> anybody pretty much
10:18:57 <tomasz> pra: can you give me an example of the type of application?
10:19:15 <pra> ??
10:19:22 <tmhrtly> Hello everybody, can you tell me why this code gives me an error when I use it in ghci?
10:19:24 <tmhrtly> sum [1,2,3,4,5] / length [1,2,3,4,5]
10:19:43 <glguy> length returns Int
10:19:47 <glguy> but Int doesn't support /
10:19:57 <glguy> :t (/)
10:19:58 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:20:00 <burp> > sum [1,2,3,4,5] / (fromIntegral $ length [1,2,3,4,5])
10:20:01 <lambdabot>   3.0
10:20:22 <tomasz> pra: sorry, meant to ask if you are using it entreprise or having kicks with it
10:20:39 <tmhrtly> But when I type 5/15 it works? Does it automatically change those to doubles?
10:20:42 <pra> tomasz: not so
10:20:46 <pra> I am just new for it
10:21:00 <pra> I will let you my progress if achive some thing
10:21:13 <burp> tmhrtly: ghci assumes fractional numbers automatically there
10:21:22 <pra> tomasz: can I know why you use haskell
10:21:25 <tmhrtly> Thanks
10:21:29 <glguy> :t let x = 5 ; y = 15 ; z = x / y in x :: (Fractional t) => t
10:21:30 <lambdabot> forall t. (Fractional t) => t
10:21:38 <djahandarie> tomasz, you can do plenty of stuff... a lot of people use it in academia obivously, but it's being used more and more in the enterprise world
10:22:20 <pra> good bye everybody
10:22:20 <djahandarie> For example you can control a Segway RMP 200 robot ;)
10:22:24 <tomasz> pra: evaluating moving an entreprise delivery system from c to haskell
10:22:47 <djahandarie> pra, later
10:22:52 <pra> tomsaz
10:22:56 <pra> goodbye
10:24:32 * copumpkin is abusing the haskell type system horrendously
10:25:01 <djahandarie> Well lucky for you the Haskell type system is a masochist
10:25:46 <kmc> and a sadist
10:25:58 <copumpkin> interesting error I'm getting now
10:26:00 <copumpkin>     Couldn't match expected type `p Unit'
10:26:00 <copumpkin>            against inferred type `NBE.R:EvalUnit'
10:26:08 <copumpkin> anyone ever seen a type like that with a colon in it?
10:26:38 <kmc> i've seen it for packages
10:27:03 <kmc> base-4.2.0.2:Data.Maybe
10:27:12 <copumpkin> not importing anything much
10:30:37 <johkra> Hi, is there a more efficient way to sum up the numbers to 10.000.000 than "sum [1..10000000]"?
10:30:54 <copumpkin> sure
10:31:01 <itsmonktastic> n(n+1)/2
10:31:06 <copumpkin> google sum of arithmetic series
10:31:15 <itsmonktastic> yeah, that ^^
10:31:16 <burp> little gau formula ;)
10:31:22 <johkra> Sorry, I mean doing the loop in Haskell.
10:31:41 <copumpkin> johkra: it's pretty speedy if you compile with -O2 
10:31:49 <kmc> well, if sum is implemented with foldl, you might use foldl' instead
10:31:51 <copumpkin> but if you use a package like Vector
10:31:59 <kmc> > foldl' (+) 0 [1..10000000]
10:32:01 <lambdabot>   50000005000000
10:32:01 <copumpkin> kmc: it is, but it notices the strictness
10:32:04 <kmc> ok
10:32:07 <kmc> *shrug*
10:32:22 <copumpkin> a package like Vector will fuse the producer and consumer and make no datastructure at all
10:32:32 <copumpkin> so you just have a tight loop summing numbers
10:32:32 <itsmonktastic> > sum [1..100000]
10:32:33 <lambdabot>   5000050000
10:32:34 <kmc> that'll happen with ordinary lists here won't it?
10:32:42 <dolio> No.
10:32:44 <copumpkin> not with foldl
10:32:45 <itsmonktastic> > sum [1..10000000]
10:32:47 <kmc> aww
10:32:51 <lambdabot>   mueval: ExitFailure 1
10:33:02 <dolio> It will if you use the combinators from the stream-fusion package.
10:33:05 <itsmonktastic> it doesn't notice. :p
10:33:13 <copumpkin> yeah
10:33:18 <copumpkin> that package appears to be forgotten :(
10:33:32 <aristid> > let sum xs = let l = last xs in l*(l+1)/2 in sum [1..10000000]
10:33:38 <lambdabot>   mueval: ExitFailure 1
10:33:43 <aristid> oO
10:33:53 <copumpkin> getting to the end is a lot of work
10:34:05 <luite> does fusion also work in ghci, interpreted, without optimization?
10:34:07 <dolio> I think dons considers vector (or something like it) to be its successor.
10:34:21 <dolio> But it's a shame that you can't use lists.
10:34:24 <copumpkin> dolio: makes sense, but as long as lists are the "default" playing-around tool
10:34:26 <copumpkin> yeah
10:35:10 <johkra> Pardon me, do I need to import something in order to use foldl' ? (I tried in ghci and get a not in scope error)
10:35:14 <kmc> Data.List
10:35:16 <kmc> @hoogle foldl'
10:35:17 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
10:35:17 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
10:35:17 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
10:35:33 <copumpkin> how does haskell feel about returning a value of TypeFamily f where f is a parameter to the function?
10:35:47 <copumpkin> like f :: X t => t -> TypeFamily t
10:35:52 <kmc> haskell feels aroused by that
10:35:52 <copumpkin> do I need to CPS it?
10:36:01 <johkra> Ah, thanks now it works and its fairly speedy now - thanks for your help!
10:36:04 <kmc> i dunno, try it
10:36:09 <copumpkin> I feel like it should be possible to avoid CPSing it
10:37:12 <kmc> did you try it without?
10:37:34 <copumpkin> f :: X t -> TypeFamily t where X is a GADT that refines its arguments seems a lot more possible, but I'm not a fan of that
10:37:44 <copumpkin> kmc: been trying, but will test the other approach to see if it works more nicely
10:38:50 <kmc> copumpkin, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29438#a29438 works for me
10:40:00 <kmc> i don't think you can do it without any support from the class itself
10:40:12 <kmc> as you have no way of proving that your method of constructing a (T a) will work for every instance
10:40:32 <mux> what does it mean when profiling only tells you that 99% of time/allocation comes from a CAF in Main ?
10:41:02 <Saizan> copumpkin: it all depends on who is supposed to choose 't', f :: X t => t -> TypeFamily t is completely fine if 'f' is supposed to allow the caller to choose
10:41:07 <mux> it's at the same level as the main function itself
10:41:14 <copumpkin> Saizan: yeah, that's the case
10:41:15 <kmc> all you work is to build some value bound at top level in "Main"
10:41:25 <kmc> (also 'main' isn't a function)
10:41:27 <copumpkin> Saizan: makes sense, but I'm having trouble getting it to work for a more complex example :) just testing now
10:41:28 <Saizan> copumpkin: but it also means the X class has to provide a suitable method
10:41:36 <copumpkin> Saizan: yeah, it does
10:41:40 <kmc> mux, did you compile with -prof -auto-all -caf-all
10:41:46 <mux> not -caf-all
10:41:49 <kmc> ok
10:41:50 <kmc> try that
10:41:51 <mux> I guess I should do that then
10:42:33 <mux> alright this makes a whole lot more sense to me ;-)
10:42:36 <mux> thanks
10:42:44 <dolio> copumpkin: Why would you need to CPS it?
10:43:11 <mux> er, or maybe not.
10:43:14 <copumpkin> dolio: I figured it might not be able to figure it out at compile time, but it obviously should be able to
10:43:32 <geheimdienst> (what's "to CPS something" mean? to CoPumpkinSqueeze?)
10:43:33 <dolio> What difference would CPS make?
10:43:40 <kmc> continuation-passing-style transform
10:43:47 <geheimdienst> i see. thanks
10:44:09 <copumpkin> dolio: in the sense of encoding an existential type with it, if it couldn't figure out the type index at compile time
10:44:13 <kmc> a  b becomes a  (b  r)  r
10:44:17 <mux> kmc: the CAF in question is named "main_parseTags"; I don't have such an identifier myself, I only use parseTags from tagsoup, and I'm not even calling it in main, but in another function down the road
10:44:31 <kmc> hrm
10:44:40 <copumpkin> dolio: not sure if I'm making any sense
10:44:51 <zygoloid> mux: it probably got inlined all the way into main
10:45:14 <mux> I suppose
10:45:28 <copumpkin> dolio: like data Z = Z; newtype S n = Sn; class Nat n where caseNat ...; intToNat :: Int -> (Nat n => n -> r) -> r
10:45:37 <mux> but if tagsoup is to blame and not my code, I'm in trouble
10:46:15 <copumpkin> or the equivalent GADT approach
10:46:55 <dolio> So instead of t -> Fam t, you were going to make it t -> (forall u. Fam u -> r) -> r?
10:47:12 <copumpkin> I wasn't planning on it, but I was wondering if it would be necessary
10:47:18 <copumpkin> but it seems not
10:47:36 <copumpkin> (but yeah, that was the idea)
10:48:04 <zygoloid> copumpkin: i can't see why it would be necessary
10:48:19 <dolio> That second one is probably isomorphic to t -> ().
10:48:43 <copumpkin> well, there's a typeclass that gives you information on the index
10:49:14 <zygoloid> copumpkin: the caller already knows what type TypeFamily t is.
10:49:24 <copumpkin> zygoloid: yeah
10:49:53 <copumpkin> I suspect my issue here is with non-injectivity of type families
10:50:03 <zygoloid> if you wanted t -> TypeFamily u, you'd probably want to CPSify it, because you'd want exists u. not forall u.
10:50:06 <copumpkin> but the errors have turned incomprehensible
10:50:14 <copumpkin> yeah, that makes sense
10:50:33 <zygoloid> copumpkin: can you paste?
10:52:18 <copumpkin> zygoloid: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29441#a29441
10:53:07 <copumpkin> the unquote function down at the bottom is the one it doesn't like
10:54:47 <copumpkin> getting things like
10:54:48 <copumpkin>     Couldn't match expected type `p (x :=> y)'
10:54:49 <copumpkin>            against inferred type `NBE.R:Eval:=> (p x) (p y)'
10:55:04 <copumpkin> which I guess is a representation of the application of a type family
10:55:49 <zygoloid> copumpkin: the type of u doesn't look general enough
10:56:54 <zygoloid> induction expects a and p Unit, and it's been given a and (a ~ Unit) => p a
10:58:12 <zygoloid> likewise with the type of f
10:58:42 <copumpkin> oh, those types are a remnant of a recent transition from typeCase in that function, I should probably fix that
10:58:47 <copumpkin> but hmm
10:59:01 <copumpkin> not actually sure how to do it
10:59:07 <copumpkin> making u :: Eval Unit doesn't unify either
10:59:19 <zygoloid> you'll need the same change to f too
10:59:54 <copumpkin> still doesn't like it
10:59:58 <zygoloid> same error?
11:00:10 <copumpkin> well, 
11:00:11 <copumpkin>     Couldn't match expected type `p Unit'
11:00:11 <copumpkin>            against inferred type `Eval Unit'
11:00:31 <copumpkin> it seems like it should be able to infer that p = Eval from that and other uses
11:00:39 <copumpkin> since the return type for induction is also an Eval
11:00:51 <zygoloid> ah, f's type is wrong still
11:01:13 <zygoloid> f :: (...) => Eval p -> Eval q -> Eval (p :=> q)
11:01:18 <copumpkin> oh duh
11:01:30 <copumpkin> hm, still didn't fix it :)
11:01:38 <copumpkin> error is still with the Unit branch
11:02:41 <zygoloid> oh duh, you can't pass a type function through a forall :(
11:02:59 <dolio> Is Eval a family?
11:03:03 <copumpkin> yeah
11:03:22 <dolio> I don't think you can instantiate a type variable with a family.
11:03:28 <copumpkin> oh, damn
11:03:31 <dolio> Same as type synonyms.
11:03:35 <copumpkin> not even a data family?
11:03:42 <copumpkin> I could make it a data family
11:03:46 <dolio> Data family yes.
11:03:50 <copumpkin> oh okay, I'll do that then
11:04:05 <dolio> At least, I suspect so.
11:05:48 <zygoloid> the annoying thing is i think it'd be sound, if there were any way to actually tell it that it should be using p for Eval
11:06:23 <DukeDave> zygoloid: I think I was speaking to you yesterday about: http://stackoverflow.com/questions/3568767/haskell-lifting-a-reads-function-to-a-parser-parser
11:06:28 <Saizan> copumpkin: you can use a newtype over Eval
11:06:41 <dolio> It would seriously complicate inference.
11:06:43 <Saizan> copumpkin: newtype E a = E { unE :: Eval a }
11:06:53 <copumpkin> Saizan: ah, that seems nice
11:06:53 <Saizan> copumpkin: and still keep Eval a family
11:07:09 <Saizan> s/family/type family/
11:07:10 <dolio> Imagine "data family T a :: * ; data instance T () = ()".
11:07:20 <dolio> Now () has to unify with p (), with p = T.
11:07:24 <DukeDave> zygoloid: Just thought I'd let you know my attempt 
11:07:39 <dolio> Sorry, that should be type family and type instance.
11:08:05 <zygoloid> DukeDave: sorry, don't think it was me ;(
11:08:52 <DukeDave> zygoloid: Oh, sorry, nm, I was rather uncertain myself ;)
11:10:42 <copumpkin> Saizan: thanks, the newtype worked great
11:11:21 <copumpkin> which I guess is equivalent to the data family approach
11:12:12 <zygoloid> there are, i think, some subtle differences
11:12:46 <zygoloid> with the newtype approach the constructors all have the same name, for instance ;)
11:14:31 <copumpkin> yeah
11:17:43 <juxtapose> /
11:21:19 <sahilm> ["apples", "oranges"] ++ "tangerines"
11:21:27 <sahilm> Why doesn't the above work?
11:21:39 <sahilm> Aren't strings lists?
11:21:53 <luite> :t ["apples", "oranges"]
11:21:55 <lambdabot> [[Char]]
11:21:59 <luite> :t "tangerines"
11:22:00 <lambdabot> [Char]
11:22:13 <luite> so they are lists, but different ones :)
11:22:25 <sahilm> so, ["apples", "oranges"] ++ ["tangerines"] ?
11:22:31 <luite> yes that would work
11:22:42 <sahilm> Thanks
11:24:49 <burp> :t (:) -- also note this one
11:24:49 <lambdabot> forall a. a -> [a] -> [a]
11:25:52 <burp> > "tangerines" : ["apples", "oranges"]
11:25:53 <lambdabot>   ["tangerines","apples","oranges"]
11:26:03 <jedai> sahilm: if you just want to add tangerines to your list you better do "tangerines" : ["apples", "oranges"]
11:26:24 <jedai> sahilm: it's O(1) whereas your solution is O(n)
11:26:53 <sahilm> jedai: Yeah, just learned that. Thanks.
11:31:17 <sahilm> reverse ("google":["apple", "microsoft"])
11:31:26 <sahilm> This is how you add to the end of the list using cons?
11:31:38 <ski> > reverse ("google":["apple", "microsoft"])
11:31:39 <lambdabot>   ["microsoft","apple","google"]
11:31:54 <sahilm> how do I invoke lambdabot :)
11:32:08 <aristid> @vixen how to invoke you?
11:32:09 <lambdabot> how? it depends...
11:32:18 <ski> > ["apple", "microsoft"] ++ ["google"]  -- this is how you add `"google"' to the end of a list
11:32:20 <lambdabot>   ["apple","microsoft","google"]
11:32:34 <aristid> :t ["this is the type of a list of strings"]
11:32:35 <lambdabot> [[Char]]
11:32:48 <ski> sahilm : note the `> ' prefixing the expressions fed to lambdabot
11:33:02 <sahilm> > b = "test"
11:33:03 <lambdabot>   <no location info>: parse error on input `='
11:33:17 <sahilm> > let b = "test"
11:33:19 <lambdabot>   not an expression: `let b = "test"'
11:33:22 <ski> > let b = "test" in  (b,reverse b)
11:33:23 <lambdabot>   ("test","tset")
11:33:49 <sahilm> > let b = "test"
11:33:50 <lambdabot>   not an expression: `let b = "test"'
11:33:55 <ski> lambdabot doesn't understand `let <decl>' things given to `> '
11:34:13 <sahilm> ski: oh.
11:34:16 <ski> sahilm : trying more than once isn't going to help ..
11:34:26 <sproingie> you can use @define but it's a shared space that can get clobbered at any time
11:34:31 <sahilm> ski: I'm sorry.
11:34:40 <c_wraith> @let b = "test"
11:34:40 <ski> however, `let b = ... in  ..b..' *does* work
11:34:41 <lambdabot>  Defined.
11:34:43 <sproingie> i recommend using ghci for experimenting :)
11:34:43 <c_wraith> > b
11:34:44 <lambdabot>   Ambiguous occurrence `b'
11:34:44 <lambdabot>  It could refer to either `L.b', defined at <local...
11:34:46 <ski> > L.b
11:34:47 <lambdabot>   "test"
11:35:03 <sproingie> sorry, @let 
11:35:03 <c_wraith> What's the other b?  simplereflect, but what's the module name?
11:35:23 <sahilm> The reverse function is linear?
11:35:27 <jedai> sahilm: of course you have to use reverse only once, at the end, otherwise it's no better than using (++)
11:35:40 <jedai> sahilm: Yes, reverse is O(n)
11:35:45 <c_wraith> sahilm, of course it is.  How could it be less than that?
11:36:03 <sahilm> Hash?
11:36:23 <jedai> sahilm: completely different data structure, no order in a hash
11:36:23 <ski> > SimpleReflect.b
11:36:24 <lambdabot>   b
11:36:25 <c_wraith> It's a singly-linked list.  You can't reverse one of them in less than O(n) time.  There are n pointers that need to be updated.
11:36:41 <sahilm> c_wraith: I see.
11:37:20 <sahilm> I can't reverse a singly linked list in o(n) time.
11:37:24 <sahilm> lol
11:37:36 <ski> of course you can
11:37:49 <roconnor> sahilm: foldl (flip (:)) []
11:37:52 <ski> "You can't reverse one of them in less than O(n) time." <- note the word "less"
11:38:26 <c_wraith> ski, I think the comment was more that *he* couldn't reverse one in O(n) time. :)
11:38:40 <sahilm> ski: I'm sorry I didn't word that correctly. What I meant was, I can't think of an algorithm to reverse
11:38:48 <sahilm> c_wraith: he beat me to it.
11:38:52 <ski> c_wraith : .. hm, could be, i suppse
11:38:57 <Martty> maybe big oh notation is not suitable
11:39:14 <sahilm> I would use a stack. o(n^2)
11:39:27 <c_wraith> In any case, roconnor provided the simplest O(n) implementation.
11:39:38 <sahilm> roconnor?
11:39:39 <ski> sahilm : say you have a stack of cards on a table. how would you reverse it, given that you can only lift one card at a time ?
11:39:52 <zygoloid> sahilm: don't add things from the start of the input to the end of the result, add things from the end of the input to the start of the result
11:40:16 <sahilm> I see.
11:40:53 <sahilm> ski: Yes if i can make a new list, it can come down to o(n)
11:41:07 <ski> sahilm : right. so do make a new list :)
11:41:17 <ski> how would you phrase this in haskell ?
11:41:39 <sahilm> I don't know. I just visted learnyouahaskell 10 mins ago.
11:41:42 <sahilm> :)
11:41:58 <ski> ok
11:42:12 <ski> do you have any experience in any other programming language ?
11:42:16 <sahilm> yes
11:42:33 <sahilm> Imperative and OO
11:43:07 <ski> it's not hard to transcribe the above "card reversing" algorithm in haskell, such that it basically becomes a loop which runs in `O(n)' time, with `n' being the length of the list to reverse
11:43:37 <sahilm> I don't know any haskell syntax. I *just* started right now.
11:43:51 <ski> sahilm : you probably need a little familiarity with recursive definitions and pattern-matching in Haskell to do it, though
11:43:54 <zygoloid> the card reversing algorithm has two lists, call them todo and done. then:
11:44:06 <ski> zygoloid : don't write it for him/her ! :)
11:44:15 <zygoloid> ski: not gonna! :)
11:44:22 <sahilm> I don't want a solution.
11:44:27 <ski> zygoloid : ok. sorry then
11:44:38 <sahilm> I'm just chatting.
11:45:05 <ski> sahilm : so, you define things in Haskell by writing equations which say that one thing equals another thing
11:45:09 * zygoloid refrains from even handwaving at this point :)
11:45:23 <ski> e.g.
11:45:36 <ski>   tableRadius = 12
11:45:56 <ski>   tableArea = pi * tableRadius ** 2
11:45:56 <sproingie> you write definitions that say one thing is defined as another thing.  there's certainly a relationship with mathematical equality there
11:46:21 <sahilm> Coming back to the reversal problem. I still need to run to end of the listevery time to pick up a card. I don't have a pointer to the end of the list. I don't think o(n) is possible in that case.
11:46:23 <sproingie> conceptually you simply substitute what's on the left with what's on the right
11:46:44 <ski> sahilm : start from the beginning. not the end :)
11:46:49 <sproingie> tho in haskell you do so *only* when that value is needed
11:47:15 <ski> sahilm : i.e. pick up cards from the start of the list
11:47:24 <sahilm> and put them in the end.
11:47:30 <ski> no
11:47:46 <ski> that's not how you would to the card-reversal on a table
11:48:33 <sahilm> on a table, I'll start from the end and make a new stack.
11:49:00 <jedai> sahilm: no you'll start from the beginning
11:49:06 <ski> well, ok, you can remove from the end of one stack and add to the end of another stack
11:49:15 <ski> but that seems more complicated than necessary
11:49:17 <jedai> sahilm: or you won't reverse your cards
11:49:32 <ski> in that you have to pick up a stack from a table to draw the end card
11:49:40 <sproingie> in both cases you're only ever dealing with the beginning of the two lists
11:49:59 <ski> if the stack is just sitting at a table, you can only draw the top card, immediately
11:50:11 <ski> (and what sproingie said)
11:50:32 <sahilm> I pick(pop) and place(push).
11:50:38 <zygoloid> sahilm: what i was going to say was: until todo is empty, move a card from the start of todo to the start of done
11:51:16 <sproingie> i'd phrase it without stack terms since imperative programmers often visualize them as growing to the right
11:51:25 <sproingie> (which is the case in perl and php)
11:53:05 * ski visualizes the stack as growing up from the table surface ..
11:53:24 <sahilm> That's how I'm visualizing it.
11:53:31 <sahilm> But start of todo to start of done?
11:53:36 <sahilm> till todo?
11:53:43 <sahilm> that just copies the list.
11:53:54 <ski> no
11:53:57 <ski> try it :)
11:54:12 <sahilm> let me think
11:54:34 <sahilm> [3, 2, 1] -> todo
11:54:42 <sahilm> [] -> done
11:54:50 <sahilm> [2, 1] -> todo
11:54:56 <sahilm> [3] -> done
11:55:07 <sahilm> [1] -> todo
11:55:13 <sahilm> [2, 3] -> done
11:55:16 <sahilm> hmm
11:55:20 <sahilm> :P
11:56:00 <ski> (a light goes on)
11:56:48 <sahilm> Okay this is linear.
11:57:02 <ski> yeah
11:57:03 <b0fh_ua> Hello! With the definition : data SomeData = Constructor { prop :: Type , ... } | ToHideOne { prop :: Type ... } how do I export ony Constructor and all of it's property access functions in module?
11:57:32 <sahilm> I wonder what I was thinking.
11:57:34 <b0fh_ua> should I enumerate all functions?
11:58:03 <ski> b0fh_ua : iirc, `module Foo (..,SomeData (Constructor (..)),..)' ?
11:58:20 * ski doesn't use selectors that often ..
11:58:35 <dafis> But I think you got that right, ski
11:58:57 <sahilm> What if I can't make a new list. Surely I can't have a linear solution in that case.
11:59:17 <ski> why can't you make a new list ?
11:59:25 <b0fh_ua> ski: complains about (..) inside type constructor
11:59:26 <dafis> sahilm: got in late, what do you want to do?
11:59:40 <ski> dafis : reverse a list in linear time
11:59:43 <jedai> sahilm: well not in an immutable world, but that's because in an immutable world if you can't make a new list you can't do much...
12:00:08 <ski> b0fh_ua : ok
12:00:21 <sahilm> jedai: I'm sure *immutable* has something to do with haskell. I'll come back with some more studying.
12:00:28 <sahilm> Thank you everyone.
12:00:37 <jedai> sahilm: basically you never modify your data in an immutable world so you _always_ create new list (which sometimes share a part of their structure with the old ones)
12:00:43 <ski> sahilm : you're welcome
12:01:52 <Martty> reverse is not linear?
12:02:14 <dafis> b0fh_ua: (..., SomeData(Constructor,prop), ... )
12:02:16 <ski> Martty : not when implemented in the nave way, no
12:02:27 <Martty> ski: talking about prelude
12:02:31 <b0fh_ua> dafis: so enumerate things
12:02:44 <Martty> > head $ reverse [1..1000000]
12:02:45 <lambdabot>   1000000
12:02:52 <ski> Martty : well, it ought to be. i'm not sure whether the Report requires it, though
12:02:56 <Martty> > head $ reverse [1..10000000000]
12:03:02 <dafis> b0fh_ua: yes, enumerate what you want to export, only if you export all there's the shorthand
12:03:03 <lambdabot>   mueval: ExitFailure 1
12:03:04 <aristid> if i want a variant, i suppose i can create an ADT for it, but is there a more general alternative? specifically i want to write some functions which work on all variants that fulfill a criterium. something like a mix between existentials and ADTs
12:03:14 <Martty> ski: doesnt look like it
12:03:28 <c_wraith> Eh, ghc's reverse is certainly linear.
12:03:29 <ski> (Martty : maybe you just hit a time limit ?)
12:03:45 <Martty> ski: but im getting the first element 
12:03:49 <Martty> O_o
12:03:59 <ski> you're getting the last element of the given list
12:04:05 <c_wraith> > last [1..10000000000]
12:04:09 <ski> so you have to traverse (and allocate) it
12:04:10 <lambdabot>   mueval-core: Time limit exceeded
12:04:21 <c_wraith> Yeah, just traversing that list takes longer than mueval allows
12:04:25 <Martty> yea i guess the problem is the initial transversing
12:04:30 <dafis> > last [1 .. 10000000000] :: Int32
12:04:33 <Martty> traversing
12:04:33 <lambdabot>   mueval-core: Time limit exceeded
12:04:43 <dafis> > last [1 .. 10000000000] :: Int16
12:04:44 <lambdabot>   *Exception: Prelude.last: empty list
12:04:55 <ski> nice :)
12:05:07 <ski> > 10000000000 :: Int16
12:05:08 <lambdabot>   -7168
12:05:22 <dafis> > 10000000000 :: Int32
12:05:24 <lambdabot>   1410065408
12:05:39 <dafis> > last [1 .. 20000000000] :: Int32
12:05:40 <lambdabot>   *Exception: Prelude.last: empty list
12:06:09 <djahandarie> > [1..10] :: Int16
12:06:10 <lambdabot>   Couldn't match expected type `GHC.Int.Int16'
12:06:10 <lambdabot>         against inferred type ...
12:06:31 <djahandarie> Wait I don't even understand
12:06:41 <dafis> > [1 .. 10] :: [Int16]
12:06:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:06:42 <djahandarie> How would you get an empty list error from a type annotation?
12:06:55 <ski> > [1 .. 10000000000] :: [Int16]
12:06:56 <lambdabot>   []
12:07:03 <dolio> > [1 .. -5]
12:07:04 <lambdabot>   []
12:07:09 <ski> > [1 .. -7168]
12:07:10 <lambdabot>   []
12:07:36 <Cale> djahandarie: The default type is Integer, which is unbounded. Check out what 20000000000 is as an Int32, and it'll make sense why the list is empty :)
12:07:44 <Cale> > 20000000000 :: Int32
12:07:45 <lambdabot>   -1474836480
12:07:50 <Cale> > 20000000000 :: Integer
12:07:51 <lambdabot>   20000000000
12:08:08 <djahandarie> Yeah I understand now, but it is odd how the type annotation affects that
12:08:30 <dafis> djahandarie: why?
12:08:31 <Cale> Well, the odd part is really that you don't get an ambiguous type error when you don't provide a type annotation.
12:08:55 <dafis> That's defaulting
12:09:20 <Cale> 20000000000 on its own really means fromInteger 20000000000, where the latter 20000000000 really means the Integer value now.
12:09:44 <djahandarie> dafis, well, I think of [x .. y] as shorthand, which is the problem since it is actually a function call
12:09:44 <Cale> and fromInteger is a function defined in each instance of Num
12:10:12 <dafis> djahandarie: the problem is the function call on the integer literal
12:10:36 <djahandarie> > last $ enumFromTo 0 1000000 :: Int32
12:10:37 <lambdabot>   1000000
12:10:41 <djahandarie> > last $ enumFromTo 0 10000000000 :: Int32
12:10:45 <lambdabot>   mueval-core: Time limit exceeded
12:11:05 <djahandarie> > last $ enumFromTo 0 20000000000 :: Int32
12:11:06 <lambdabot>   *Exception: Prelude.last: empty list
12:11:19 <djahandarie> That makes sense to me
12:11:31 <djahandarie> Just with the [ .. ] notation it doesn't make sense to me 
12:11:59 <djahandarie> Because I think of [x .. y] as a direct transformation not taking types and such into account, which is horribly wrong but that is how my head has thought of it until now
12:12:35 <yitz> People always say things like "20 really means fromInteger 20". That makes no sense to me - it's a recursive definition with no base case.
12:12:55 <yitz> Why not just say that the type of literals like 20 is Integral a => a?
12:12:59 <dafis> yitz: fromInteger (20 :: Integer)
12:13:20 <yitz> defis what does the "20" mean in that statement?
12:13:34 <ski> `fromInteger (20 :: Integer)' of course
12:13:36 <sproingie> i found whenever i had to sprinkle fromIntegral all over the place i really just needed -XNoMonomorphismRestriction
12:13:36 <ski> ;)
12:13:36 <dafis> read "20" :: Integer
12:14:01 <ski> sproingie : or more signatures ..
12:14:15 <sproingie> well yeah that works too
12:14:34 <yitz> dafis: i don't think the Read instance is the most primitive definition
12:14:47 <dafis> yitz: certainly not :)
12:19:39 <yitz> dafis: I believe that Num literals have a hard-wired built-in interpretation for each of the built-in numeric types. So their type is hard-wired to be Integral a => a, not because of some function call. But for user-defined types, fromInteger (20 :: Integer) is in fact used, though.
12:21:09 <yitz> sproingie: you probably needed it even if you didn't have to sprinkle fromIntegral all over the place.
12:21:56 <dafis> yitz: An integer literal represents the application of the function fromInteger to the appropriate value of type Integer.
12:22:09 <dafis> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-240003.2
12:22:40 <copumpkin> in typed lambda calculi, how does one introduce type "identity"? if you talk about maybe finite types types and have sums, products, 0, and 1, how do you prevent Bool (defined as 1 + 1) from unifying with some other 1 + 1 type because they're isomorphic?
12:22:50 <copumpkin> I mean, I can think of hacky ways of doing it
12:22:56 <copumpkin> but was wondering if there was a conventional way
12:23:05 <yitz> well that works for the semantics I guess. I certainly hope that most compilers are smart enough not to do that really.
12:23:51 <yitz> copumpkin: you tuple it with type-level naturals
12:24:26 <copumpkin> so you're really just tagging the types?
12:24:31 <copumpkin> to prevent unwanted unification?
12:24:35 <sproingie> a type that is only 1+1 is the same as any other type that's 1+1.  the name of the type is some other thing about the type
12:24:40 <dafis> yitz: unless you plan to use huuuge literals, it shouldn't matter
12:25:05 <copumpkin> sproingie: yes, but in haskell if I have data Moo = Baa | Woof; and data Bool = True | False; I can't use Bool everywhere Moo is used and vice versa
12:25:39 <copumpkin> sproingie: I was just wondering what tricks people used to represent identity of types that way
12:25:43 <dolio> Those aren't sugar for 'type Moo = 1 + 1'.
12:25:44 <sproingie> because Baa and Woof are not in the set of {True,False}
12:25:58 <dolio> They're primitive constructs.
12:26:00 <sinelaw> hey
12:26:40 <copumpkin> dolio: yeah, so I was wondering how that kind of stuff gets dealt with in LCs? 
12:26:41 <sproingie> i was thinking more along the lines of newtypes
12:27:07 <copumpkin> just binding something to a combination of primitive types isn't sufficient to give the behavior we have in haskell
12:27:23 <dolio> It's dealt with by introducing some operation that makes the distinction, presumably.
12:27:26 <yitz> copumpkin: that seems like the simplest and most obvious way to do it, anyway. it is a hack, but only a tiny one.
12:27:41 <copumpkin> yitz: you mean the tagging?
12:27:45 <yitz> yeah
12:28:50 <copumpkin> yitz: you'd also need a mapping from constructor names to constructors of your underlying types, I guess
12:28:55 <aristid> :t fromInteger
12:28:58 <lambdabot> forall a. (Num a) => Integer -> a
12:29:11 <copumpkin> and I guess that mapping could serve as the tag, itself
12:29:28 <copumpkin> assuming the constructor names are unique
12:29:42 <yitz> copumpkin: constructors are just functions
12:30:04 <aristid> yitz: have you checked the proof before uploading it? *fear of embarrassment*
12:30:20 <yitz> aristid: looks right to me.
12:30:22 <copumpkin> yitz: not always... and it seems like you'd want to maintain the additional inforamtion
12:30:50 <yitz> aristid: so i hereby share in any embarrassment that may ensue
12:31:14 <aristid> yitz: i think it's a bit handwavey about what "elimination" means
12:31:41 <yitz> aristid: yeah, but it's clear enough imo
12:31:47 <aristid> hmm ok
12:33:20 <yitz> aristid: if you decide to change it, or take it down, let me know. but it's a pretty simple fact once you think of it. i'd just leave it.
12:33:45 <aristid> yitz: yeah i was excited about all the fame already ;)
12:34:01 <yitz> aristid++
12:42:40 <aristid> yitz: hmm i've got an idea for a very simple and crude change to timezone-series to accomodate the rules... you could reverse the order of the transitions list and use the rules to create a lazy infinite list
12:45:41 <yitz> aristid: interesting idea. the reason i put it in that order is because you usually want the values closest to "now". but even as it is you usually start pretty far in the future and work back. we could have two lists - one from now backward and the other into the future, possibly infinitely...
12:46:32 <yitz> aristid: i'm a little worried that it could lead to a space leak though. in a widely used library, there's no control over how people use it.
12:47:13 <aristid> yitz: how about a more efficient lazy data structure than a lsit?
12:47:53 <yrlnry> What are some examples of applicative functors that are not monads, other than ((,) e)?
12:48:04 <aristid> yitz: or not expose the data structure at all
12:48:04 <zygoloid> ZipList is the canonical one
12:48:25 <yrlnry> Thanks, I did find that one.  Any others?
12:48:37 <yrlnry> (I looked in typeclassopedia before asking here.)
12:48:47 <aristid> yrlnry: a context-free parser?
12:49:00 <yitz> aristid: someone may look far into the future, but later also need something recent. the entire list all the way out to the future point will then be held in memory.
12:49:31 <aristid> yitz: a data structure that does not require looking up everything might help
12:49:47 <aristid> i don't really know which lazy data structures could be used
12:49:51 <yrlnry> aristid:  I must not understand what you mean, because the parsers I am familiar with are easily made into a monad.
12:50:03 <aristid> yrlnry: because they are not context-free
12:50:17 <yrlnry> what does "context-free" mean in this context?
12:50:35 <yrlnry> Oh, you mean that in a <*> b parser b runs without getting to see the value produced by a?
12:50:41 <aristid> http://en.wikipedia.org/wiki/Context-free_grammar
12:51:32 <yrlnry> I know what a context-free grammar is, but I'm not seeing why context-free parsers do not form a monad.
12:51:50 <aristid> yrlnry: they form a monad, but they can be fully expressed with applicative, too
12:52:08 <aristid> oh no, they do NOT form a monad
12:52:23 <aristid> yrlnry: because >>= introduces context
12:52:45 <zygoloid> yrlnry: the key thing about non-monad applicatives is that the f-structure cannot depend on intermediate computations within f
12:53:20 <zygoloid> which is just longhand for saying that you can't do: m a -> (a -> m b) -> m b, really
12:53:25 <yitz> yrlnry: the parser in haskel-src-exts is applicative but not monad, I believe
12:53:34 <yrlnry> yitz:  I will take a look, thanks.
12:54:11 <zygoloid> yrlnry: you can do f (a -> b) -> f a -> f b, but the f-structure there can't nontrivially depend on what happens when you apply the a->b function to a value of type a.
12:54:25 <zygoloid> (all it can do is bottom out in some cases)
12:54:30 <yrlnry> Yes, I know that, but I am looking for examples.
12:55:48 <zygoloid> yrlnry: ok, well, apply those rules to a parser ;)
12:56:37 <zygoloid> the upshot is, the parser, in general, can't use the result of a haskell function to decide what parsing rules to apply next
12:57:13 <aristid> yrlnry: zygoloid gave you a whole class of examples. what more do you want? :)
12:57:37 <yrlnry> A class of examples is not an example  :)
12:58:01 <zygoloid> yrlnry: there aren't a whole lot of examples. most applicatives which are actually used in real programs are monads.
12:58:02 <yrlnry> This was first observed by Frege.  
12:58:18 <yrlnry> That is helpful, thanks.
12:58:21 <monochrom> Frege be damned.
12:58:36 <monochrom> Frege could only come up with an inconsistent logic anyway.
12:59:11 <dolio> What a chump.
13:02:14 <mjrosenb> so isn't haskell source not context free?
13:02:54 <mauke> haskell source is unparseable
13:03:07 <dafis> mauke: far easier than C++
13:03:14 <monochrom> most programming languages are not context free. http://www.vex.net/~trebla/weblog/declare-before-use.xhtml
13:03:23 <mauke> only because C++ is completely unparseable
13:03:50 <dafis> mauke: nondeterministically, it is parseable
13:03:53 <monochrom> but you always start with a context-free superset to ease implementation.
13:03:53 <dolio> Completely unparseable is less parseable than unparseable?
13:04:01 <mauke> dolio: yes
13:04:18 <BONUS> haha, pumpy lemma outta nowhere
13:04:31 <aristid> BONUS outta nowhere too
13:04:44 <Saizan> nobody expects the pumping lemma.
13:04:47 <mauke> dafis: you mean like haskell?
13:05:04 <dafis> mauke: sorry?
13:05:17 <sproingie> .oO(f-me lemma pumps?)
13:05:57 <mauke> hmm, I guess parsing haskell doesn't actually depend on implementation details
13:05:58 <mjrosenb> what makes haskell unparseable?
13:06:00 <mauke> it's just annoying
13:06:31 <mauke> mjrosenb: local fixity declarations and layout desugaring
13:06:33 <sproingie> far easier than parsing perl
13:06:37 <Cale> A language L is totally unparseable if for any epsilon > 0, there are a finite number of balls of unparseability of radius epsilon in L whose union is L.
13:06:44 <mauke> sproingie: I disagree
13:06:46 <BONUS> this is pretty cool. all declare before use langauges have non context free grammars, who would have thought
13:06:49 <dafis> mauke: writing the code was hard, so it'd better be hard parsing it
13:06:55 <monochrom> hahaha Cale
13:07:01 <sproingie> you cant parse perl without running perl
13:07:02 <mjrosenb> mauke: well the local fixity declarations just mean that it isn't context free :-p
13:07:03 <FunctorSalad_> layout isn't cf? that is not a rhetorical q.
13:07:34 <aristid> sproingie: BEGIN{} proves that quickly
13:07:42 <Makoryu> mauke: At least you can preprocess it in distinct phases to get something that is parseable at compile time
13:07:46 <mauke> hey, BEGIN{} is easy to parse
13:08:55 <Makoryu> Whereas Perl can dynamically declare and reassign functions at run time, resulting in different parses for the same piece of code at different points in the program's execution
13:09:09 <mauke> Makoryu: that sounds wrong to me
13:09:12 <FunctorSalad_> BONUS: hmm that arguably isn't part of the grammar
13:09:20 <mauke> perl doesn't randomly reparse code
13:09:24 <Makoryu> mauke: eval
13:09:39 <mauke> Makoryu: what
13:09:45 <mauke> eval is trivial to parse
13:09:49 <sproingie> that's limited to eval and arguably a special case
13:09:51 <FunctorSalad_> (I think CF grammars are still used, then the result is analyzed further0
13:10:07 <BONUS> FunctorSalad_: yeah it says that in the article that, conveniently, that isn't considered part of the grammar
13:10:11 <mauke> mjrosenb: http://haskell.org/ghc/docs/6.12.2/html/users_guide/bugs-and-infelicities.html#infelicities-syntax
13:10:24 <FunctorSalad_> much more pleasant to analyze name definedness after you have an AST instead, rather than from a string ;)
13:10:29 <sproingie> indirect object syntax is the real bugger
13:10:47 <mauke> sproingie: I'd say it's prototypes
13:13:04 <mjrosenb> mauke: still better than sml, where you can change wether or not somehting is infix at all within a scope
13:13:18 <mauke> oh wow
13:13:28 <mauke> but sml doesn't have 'where', does it?
13:13:36 <mjrosenb> this is true
13:13:56 <mjrosenb> although, iirc, there is an extension that does a pre-processing step to get rid of where
13:14:02 <tomasz>  /statusbar window add usercoun
13:14:22 <mauke> foo = ... let x = 42 in x ??? 23 ??? True ... where infix 0 ???; (???) = (==)
13:14:25 <Zao> tomasz: No thanks :D
13:14:26 <mjrosenb> since it doesn't have guards, i don't think where adds anything over let
13:14:37 <tomasz>  /statusbar window add usercount
13:14:54 <Zao> tomasz: You seem to have a space in front of your slash.
13:14:58 <dafis> tomasz: without the space?
13:15:09 <tomasz> gah. thanks
13:24:37 <yrlnry> sml has  "local (defs) in (defs) end", which is like "where", but backwards, he said, late and coming in in the middle
13:25:20 <mjrosenb> yrlnry: this is true
13:25:37 <mjrosenb> iirc, you can also have local module definitions using local
13:25:40 <yrlnry> .
13:25:44 <mjrosenb> which is just a *bit* too much
13:25:49 <monochrom> sml's "local" does a bit more. yes, modules.
13:26:02 <mauke> I'd rather parse that than 'where' (see also: qr//x)
13:26:12 <sproingie> local (defs) in (defs) has sml said he backwards
13:26:35 <sproingie> makes perfect sense if you're german ;)
13:26:52 <yrlnry> sml "local" is an annoying artifact of sml's distinction between declarations and expressions.
13:27:13 <yrlnry> it should be superfluous, subsumed by "let".
13:27:24 <yrlnry> let (defs) in (expr) end
13:28:15 <yrlnry> People say many nice things about SML, but not many of them are about the syntax.
13:32:11 <ski> yrlnry : that is *not* at all like `where'
13:32:43 <yrlnry> Not at all?
13:33:02 <ski> `where' attach to a single equation
13:33:14 <ski> `local' can scope over an arbitrary number of definitions
13:33:51 <yrlnry> Also, 'where' starts with the letter w, while 'local' starts with the letter 'l'.   So they are COMPLETELY different.
13:34:09 <ski> it might be nice if `local' was spelled `let', yes (so that `let' subsumes both the current `let' as well as `local')
13:34:30 <ski> with `where' you can't say stuff like
13:34:32 <ski>   local
13:34:43 <ski>     fun f x = ..x..
13:34:50 <ski>     and g y = ..y..
13:34:52 <ski>   in
13:35:04 <ski>     fun foo x y = ..x..y..f..g..
13:35:13 <ski>     and bar z = ..z..f..g..
13:35:14 <ski>   end
13:35:39 <Makoryu> ski: (foo, bar) = (foo', bar') where -- omg hax
13:35:45 <ski> i.e. let `f' and 'g' be local definitions, which both are in scope over the `foo' and `bar' definitions
13:36:16 <ski> Makoryu : then you need to define those auxilary names, which is ugly
13:36:35 <Makoryu> ski: Or write them as lambdas, yes.
13:36:45 <Makoryu> Actually....
13:36:57 <ski> yeah, but often then you have to say `\x y -> case (x,y) of ...'
13:37:04 <ski> (which is also ugly)
13:38:39 <Makoryu> I just tried to write "let (foo x, bar y) = ..." and it wouldn't parse
13:38:43 <Makoryu> Oh well  (`) 
13:38:46 <ski> right
13:38:59 * ski has often wanted SML's `local' in Haskell ..
13:41:37 <mauke> let (foo, bar) = let f x = ...; g y = ... in (\x y -> ... f g, \z -> ... f g)
13:44:28 * ski is not doubting one can write code which behaves the same; only claiming that `local' would be useful to have, since `where' doesn't support that
13:46:46 <dolio> Actually, you could do it with where, but it'd be similarly ugly.
13:47:19 <ski> (you can't scope over several declarations with `where', that's just how it works)
13:47:24 <EvanR-wo1k> what? haskell code cant be ugly. it would generate a compile time error
13:48:03 <dolio> (foo, bar) = (\x y -> ... x .. y .. f .. g .., \z -> .. z .. f .. g ..) where f x = .. x .. ; g y = .. y ..
13:48:14 <dolio> Insert fix if foo and bar are recursive.
13:48:15 <ski> .. and that's a single declaration
13:49:25 * hackagebot iteratee 0.4.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.4.0 (JohnLato)
13:49:38 <ezyang> whoooo 
13:50:38 <dolio> Was that a Ric Flair impression?
13:51:12 * ezyang doesn't know who Ric Flair is... 
13:51:36 <dolio> Lern yer pro wrestling, n00b.
13:52:27 * hackagebot iteratee-mtl 0.4.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-mtl-0.4.0 (JohnLato)
14:01:49 <mrsolo> what is the usual way to create ByteString from literals?
14:01:51 <BMeph>   * hackagebot holysmoke 0.2 -  Reminds you of important events in the Orthodox calendar, even using Gregorian dating! (DemetriosNikos)
14:02:06 <BMeph> >:D
14:02:27 <mrsolo> OverloadedStrings ?
14:02:33 <mauke> mrsolo: use pack or overloaded strings
14:02:35 <dolio> pack "whatever"
14:02:42 <mrsolo> or use Address# ?
14:02:47 <mrsolo> okay
14:04:31 * hackagebot timezone-series 0.1.1 - Enhanced timezone handling for Data.Time  http://hackage.haskell.org/package/timezone-series-0.1.1 (YitzGale)
14:07:32 * hackagebot timezone-olson 0.1.1 - A pure Haskell parser and renderer for binary Olson timezone files  http://hackage.haskell.org/package/timezone-olson-0.1.1 (YitzGale)
14:10:36 <logch_l> Q: Given this list comp:"fibPoss i = reverse [ fibPos(i) | i <- fibBelow(fibDiff(i)) ]
14:11:02 <Botje> logch_l: you don't need parens to call functions
14:11:09 <Botje> fibPos i and fibBelow (fibDiff i)
14:11:11 <Botje> but continue :)
14:11:26 <logch_l> Q2: How to return just fibPos(i) if fibBelow(fibDiff(i)) gives 0 back?
14:12:38 <logch_l> Botje: Thanks, I'll remove the parens - old habits..
14:12:39 <Botje> fibBelow will always return a list, what do you mean by "gives 0 back" ?
14:13:44 <logch_l> Botje: Sometimes the list return just one element containing 0, then a empty list is the result from fibPoss instead of just the exact fibPos(i)
14:13:57 <logch_l> s/return/returns/
14:14:38 <Botje> but reverse doesn't turn [0] into [] ... ?
14:14:55 <leimy> > reverse [0]
14:14:56 <lambdabot>   [0]
14:15:04 <logch_l> Botje: let me test to be sure, brb
14:15:19 <Botje> logch_l: maybe you just want [ ... | i <- fibBelow (...) ++ [i] ]
14:16:52 <Botje> << sleeptime, hope someone else can help logch_l further
14:17:03 <logch_l> Botje: goodnight, thanks!
14:30:39 * hackagebot iteratee 0.4.0.1 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.4.0.1 (JohnLato)
14:30:52 <dsssr> Can somebody tell me what () represents in Haskell?
14:31:14 <dafis> dsssr: the unit datatype
14:31:19 <dafis> and its value
14:31:39 * hackagebot iteratee-mtl 0.4.0.1 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-mtl-0.4.0.1 (JohnLato)
14:31:40 <dafis> dsssr: a bit like void
14:31:50 <mtnviewmark> that is - there is a type written    ()
14:31:51 <dsssr> Thanks. That should be googelable at least!
14:31:55 <mtnviewmark> and it has one value also written     ()
14:31:59 <Veinor> > :t ()
14:32:00 <lambdabot>   <no location info>: parse error on input `:'
14:32:02 <Veinor> whoops
14:32:04 <Veinor> :t ()
14:32:05 <lambdabot> ()
14:32:34 <benmachine> ooh, new iteratee
14:32:47 <dafis> dsssr: did you see it in `IO ()' ?
14:32:56 <benmachine> ...maybe I'll come back when the docs are built
14:33:07 <dolio> Even newer than the one from 30 minutes ago.
14:33:09 <dsssr> No. In a SPJ paper
14:33:25 <Cale> dsssr: You can also think of it as an empty tuple
14:34:51 <dsssr> Ok. So it is really a placeholder when you need a type for nothing
14:35:04 <Zao> @src ()
14:35:05 <lambdabot> data () = ()
14:35:11 <Cale> dsssr: yeah
14:35:19 <Zao> () is a type with one ctor, ().
14:35:48 <kmc> yeah
14:35:56 <dsssr> ctor?
14:36:01 <Zao> constructor.
14:36:13 <dsssr> ah, ok. Makes sense
14:36:14 <Zao> (I'm damaged by C++)
14:36:32 <kmc> a function taking () or returning () is mostly useless, though you can use them to control evaluation order
14:36:37 <Zao> Compare with say, Maybe.
14:36:38 <Zao> @src Maybe
14:36:39 <lambdabot> data Maybe a = Nothing | Just a
14:37:01 <EvanR-wo1k> Zao: in soviet russia, you damage c++
14:37:03 <kmc> the first place you're likely to encounter () is in the type IO ()
14:37:25 <kmc> which represents "a sequence of side-effects with no useful result value"
14:37:33 <dsssr> I found it's definition in the language report
14:37:34 <dsssr> data () = ()
14:37:40 <dsssr> Pretty simple
14:38:10 <benmachine> dsssr: yeah, notice though that () is special - parentheses are not normally allowed in constructor names
14:38:11 <Cale> Of course, that can only be pseudocode. It's really special syntax :)
14:38:12 <dsssr> Thanks for all your help. I'd been ignoring it whenever I'd seen it for way too long!
14:38:35 <Makoryu> :t (,+3)
14:38:36 <lambdabot> parse error on input `+'
14:38:38 <mauke> and now you can ignore it again :-)
14:38:59 <dsssr> lol. Yes
14:41:25 <EvanR-wo1k> data [a] = [] | a : [a]
14:41:59 <EvanR-wo1k> hehe
14:42:52 <xiackok> goodnights everyone
14:54:46 <xiackok> BONUS: hey bonus your book's functors and monads chapters are realy great. its easiest from others. thank you very much :)
14:55:14 <monochrom> is that "learn you a haskell"?
14:55:24 <xiackok> monochrom: yes it is
14:56:05 <olsner> I like how the monad chapter builds on functor and applicative rather than burritos
14:57:32 <dilinger> but burritos are so tasty
14:58:01 <Makoryu> Bearritos.
14:58:15 * Makoryu eats some very spicy bear meat
14:58:52 <xiackok> olsner: what is burritos
14:59:05 <monochrom> @quote burritos
14:59:05 <lambdabot> kmc says: an arrow is like *two* burritos
14:59:11 <monochrom> haha
14:59:24 <olsner> xiackok: it's a reference to nonsensical monad metaphors
14:59:30 <monochrom> http://codetojoy.blogspot.com/2009/03/monads-are-burritos.html
14:59:55 <monochrom> actually http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
15:01:22 <xiackok> monochrom: im looking
15:01:29 <dankna> @quote monad.*bad.*metaphor
15:01:30 <lambdabot> No quotes match. My mind is going. I can feel it.
15:01:32 <dankna> @quote monad.*metaphor
15:01:32 <lambdabot> tensorpudding says: A monad metaphor is like a metaphor, but less helpful.
15:01:52 <dankna> not the one I was looking for, but amusing nonetheless
15:02:03 <monochrom> heh, explain OOP in 2 sentences.
15:02:05 <mtnviewmark> @quote monad.*train
15:02:05 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
15:02:16 <mtnviewmark> @quote monad.*train
15:02:16 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
15:02:28 <mtnviewmark> @quote monad.*jello
15:02:29 <lambdabot> kmc says: a monad is like an invisible train filled with jello traveling backwards in time
15:02:56 <dankna> OOP in two sentences:  "Instead of data structures, we have objects, which are like data structures but more glamorous.  With the use of objects, you never need to think about data structures or algorithms."
15:03:10 <monochrom> haha
15:03:23 <dankna> a little exaggerated from my actual view, but :)
15:03:28 <Makoryu> 
15:03:52 <monochrom> with monads, you never need to think about programs.
15:04:00 <dankna> impressive.
15:04:37 <monochrom> with applicative, you never need to think about monads...
15:05:11 <monochrom> with an MBA degree, you never need to think.
15:05:35 <randomwords> Are there any decent vim syntax files for working with literate haskell?
15:06:00 * fxr emacs rant
15:06:11 <monochrom> I believe so. But I don't use vim, I don't know where to find.
15:06:42 <randomwords> The stuff for vanilla haskell is (just about) fine, but it's a bit lacking for lhs
15:06:54 <randomwords> and by stuff I mean builtin
15:08:46 <markand> hello
15:08:51 * hackagebot iteratee 0.4.0.2 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.4.0.2 (JohnLato)
15:08:54 * hackagebot iteratee-mtl 0.4.0.2 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-mtl-0.4.0.2 (JohnLato)
15:09:37 <ski> hello, markand
15:10:05 <fxr> I guess John works hard, 3 releases in around 1 hour
15:13:04 * FunctorSalad_ isn't sure how bad "reverse foo ++ bar" is
15:14:55 <FunctorSalad_> say, to recover the list from a list zipper
15:16:45 <olsner> if you start with a zipper, wouldn't it be more efficient to avoid the "++" and just use the zipper to traverse to the beginning of the list?
15:23:07 <FunctorSalad_> yeah, but this interface I'm calling demands a list
15:24:29 <FunctorSalad_> (rendering lines to an ansi terminal... I guess the terminal itself would support rendering down-to-up in principle)
15:24:44 <FunctorSalad_> (just move the cursor up two lines after each item)
15:25:32 <FunctorSalad_> olsner: ah, you mean actually moving the zipper, I was thining 'directly consume the left list'
15:44:50 <copumpkin> maybe this is utter bullcrap, but normalization by evaluation (from my very cursory glance at it so far) feels a bit like the composition of an adjoint pair of functors
15:46:49 <copumpkin> anyone have any thoughts on that?
15:47:00 <copumpkin> (including "stfu dumbass")
15:47:35 <m3ga> copumpkin: one day i will under stand wtf you just said :-)
15:47:40 <Adamant> copumpkin are not a dumbass
15:47:51 <Adamant> those are thoughts of Mongo Adamant
15:48:03 <copumpkin> lol
15:48:33 <Adamant> copumpkin: Mongo Adamant just pawn in game of Life
15:48:46 <copumpkin> is MongoDB named after you?
15:48:58 <Martty> Mongopoly
15:49:10 <Adamant> no, named after cousin Mongo NoSQL
15:51:08 * hackagebot zeromq-haskell 0.4 - bindings to zeromq  http://hackage.haskell.org/package/zeromq-haskell-0.4 (ToralfWittner)
16:30:18 <krey_> hi, what's the best type / model used to represend deterministic finite automata?
16:30:29 <krey_> ^t
16:31:59 <tolkad> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Exception.html#t%3ANonTermination
16:31:59 <tolkad> wtf? does this mean any program I write which I intend not to terminate might fail with this exception?
16:32:37 <benmachine> tolkad: by not to terminate, I think it means not to be productive
16:32:37 <tolkad> what if you use the prelude interact function?
16:33:05 <tolkad> benmachine: so I can't write a program which doesn't produce output or read input or terminate?
16:33:23 <tolkad> I see.
16:33:29 <benmachine> tolkad: if you produce a program that doesn't do anything, GHC might kill it
16:33:35 <benmachine> you can catch the exception if it matters to you :P
16:33:42 <Martty> bit off topic, need recom. of data structures and algorithms books (im reading kruse atm but not liking it)
16:34:03 <tolkad> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Exception.html#v%3AHeapOverflow
16:34:09 <tolkad> why does it say GHC wont throw it?
16:34:58 <copumpkin> because there's not much you can do to recover, I'd guess
16:35:11 <copumpkin> not sure, though
16:35:25 <tolkad> copumpkin: it says when it is nearing overflow, not has overflowed
16:35:33 <tolkad> so recovery would be possible
16:35:51 <tolkad> although the fact it could happen anywhere makes it very hard...
16:40:17 <BMeph> tolkad: "That's what SHE said!" ;
16:44:12 <kmc> Martty, a typical intro text is CLRS, are you looking for something more specific?
16:44:37 <Martty> CLRS? let me check, moment
16:44:53 <kmc> _Introduction to Algorithms_, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein
16:45:16 <Martty> kmc: do you know Krause's?
16:45:51 <kmc> no
16:46:27 <copumpkin> it's a pity that all those presentations of algorithms are so imperative
16:46:27 <Martty> moment. because i want to cover all he does in his book, i just dont like the way he explains things
16:46:38 <copumpkin> so need to be, but others seem unnecessarily so
16:46:50 <copumpkin> *some
16:46:58 <Martty> copumpkin: well, low level can't be as abstract imo
16:47:09 <copumpkin> why does it need to be low-level?
16:47:23 <Martty> because you care about speed and memory usage when studying algorithms
16:47:37 <copumpkin> if I want to say "do X to all elements in the array" having to deal with indices and a for loop is just a distraction
16:47:39 <kmc> you can be precise about speed and memory usage in a functional setting
16:47:45 <kmc> especially if you use a strict language, unlike Haskell
16:47:55 <copumpkin> yeah
16:48:10 <copumpkin> Martty: you care about asymptotic behavior for both time and memory
16:48:23 <copumpkin> but those can be expressed nicely in a functional setting too
16:48:41 <Martty> copumpkin: right, but you dont have as much control, at least not directly, as kmc said
16:48:50 <kmc> uh when did i say that
16:48:53 <FunctorSalad_> copumpkin: we call that a "monad"
16:48:55 <FunctorSalad_> <copumpkin> maybe this is utter bullcrap, but normalization by evaluation (from my very cursory glance at it so far) feels a bit like the composition of an adjoint pair of functors
16:49:01 <FunctorSalad_> :)
16:49:03 <copumpkin> FunctorSalad_: that's what I was getting at :P
16:49:05 <Martty> oops, though copumpkin was talking about haskell
16:49:17 <copumpkin> FunctorSalad_: but I wanted to know whether the premise was correct :P
16:49:24 <kmc> Haskell is not a typical functional language
16:49:27 <Martty> anyways, ill check it out kmc , thanks
16:49:43 <kmc> funny how it's become the poster child for FP
16:49:59 <Martty> isnt it the one with the biggest community
16:50:01 <kmc> and we're seen as purist fundamentalists when actually the language is full of weird compromises
16:50:14 <kmc> Martty, if you have a narrow definition of "functional language", maybe
16:50:19 <kmc> people do FP in nearly every language
16:50:25 <kmc> even C++ and Java, painful as it is
16:50:39 <kmc> (those same people will rant about how useless FP is, even as they're bending over backwards to fake it)
16:50:50 <Martty> the = functional programming language
16:51:06 <Martty> wtf misread again
16:51:14 <Martty> anyways, yea
16:51:57 <Martty> talk about piracy.. my course prof uploaded like 10 algorithms and c++ books to rapidshare and dropped the link in the yahoo group
16:52:00 <Martty> lol
16:52:02 <kmc> hahaha
16:52:11 <copumpkin> wow
16:52:14 <Makoryu> o_o
16:52:17 <Martty> luckily for me, that one you mentioned is included in the piratepack kmc 
16:52:35 <copumpkin> hah, I know Cormen quite well, I'll let him know ;)
16:52:37 <copumpkin> j/k
16:52:48 <Martty> there also one one by drozdek, anyone checked it out?
16:53:12 <roconnor> kmc: Haskell is the poster child for FP because other FP languages have side effects
16:53:25 <kmc> so does Haskell
16:53:32 <kmc> first of all, we have unsafePerformIO
16:53:39 <kmc> but also, the debate is framed stupidly
16:53:43 <roconnor> kmc: unsafePerformIO is not Haskell
16:53:49 <kmc> it's in the FFI addendum
16:53:52 <kmc> no true scotsman
16:54:20 <roconnor> I don't think this is a case of no true scotsman
16:54:24 <kmc> Haskell's is the middle-ground position between "no effects" and "allow effects everywhere willy-nilly"
16:54:32 <roconnor> look in the Haskell '98 report.  That is more or less what I mean by haskell
16:54:35 <sproingie> i think modern FP is typed FP and in that sense haskell is also the flag-bearer
16:54:37 <copumpkin> you have to go out of your way to get side effects, and unsafePerformIO doesn't give you side effects in the same way as another language
16:54:41 <kmc> FFI is an approved addendum to the H98 report
16:54:44 <kmc> but whatevs
16:55:01 <copumpkin> no true haskeller uses unsafePerformIO anyway
16:55:16 <jmcarthur> i don't like that argument
16:55:17 <kmc> yeah the ByteString authors sure aren't true haskellers
16:55:19 <kmc> ;P
16:55:23 <roconnor> I haven't looked at the FFI but I assume the semantics of unsafePerformIO are undefined in the case of impure use of it.
16:55:23 <kmc> anyway
16:55:28 <kmc> dumb argument, i'm going back to watching TV
16:55:29 <copumpkin> :)
16:55:31 <kmc> ttyl y'all
16:55:42 <jmcarthur> a true haskeller will use unsafePerformIO in order to create pure interfaces
16:55:55 <jmcarthur> for some definition of "true" of course
16:56:05 <jmcarthur> my definition, i guess
16:56:20 <Cale> I think of unsafePerformIO as being as much a part of Haskell as is the ability to modify GHC. You can do it, and still call the result Haskell, but it's not a usual thing to resort to.
16:56:24 <sproingie> a bit like how C++ friend functions were described to me
16:56:37 <sproingie> "friend functions break encapsulation.  except when they enhance it"
16:57:23 <roconnor> unsafePerformIO :: IO a -> a 
16:57:30 <roconnor> Return the value resulting from executing the IO action. This value should be independent of the environment; otherwise, the system behaviour is undefined. 
16:57:34 <roconnor> see
16:57:37 <roconnor> side-effect free
16:57:57 <sproingie> one often calls it returning unit
16:58:29 <aristid> roconnor: therefore, it is perfectly safe.
16:58:45 <roconnor> aristid: undefined behaviour is not generally safe behaviour
16:58:55 <roconnor> and, in fact, is usually unsafe behaviour
17:00:02 <aristid> roconnor: when used correctly, it is safe... (it was a joke :P)
17:03:21 <nus> "Sister Mary Ignatius Explains It All For You: Purity and Safety in Haskell"
17:16:34 <kmc> fwiw my intent was not to start a big argument about unsafePerformIO
17:16:43 <copumpkin> omnom
17:18:04 <kmc> my point was more that first-class effects are a practical middle ground between no effects and effects glommed onto functions
17:18:15 <kmc> but the rest of the world is heavily skewed towards the latter
17:19:12 <FunctorSalad_> hmm maybe this thing I'm currently doing in a shell script could be in cabal-install instead... finding the cabal root dir for a given file
17:19:40 <FunctorSalad_> so you can use 'cabal build' as a hsmakeprg in vim, for example...
17:19:57 <FunctorSalad_> *as a makeprg :p
17:20:39 <watermind> are there any non-pure lazy programming languages out there?
17:21:00 <dolio> Yes.
17:21:03 <watermind> the only current lazy ones I can think of are Haskell and Clean
17:21:13 <watermind> like what dolio?
17:21:31 <dolio> There's a language out there developed by (probably) a lone nut, called Jaskell. :)
17:21:47 <dolio> And I think it's lazy and has no real control of effects.
17:21:48 <watermind> oh... let me check that
17:22:03 <p_l> there was also clazy, which added laziness to CL
17:22:33 <watermind> ouch! Jaskell has dynamic typing :)
17:22:34 <dolio> Also, CAL is very Haskell-like on the JVM, but I think it's ultimately impure, with an advisory to not do impure stuff when evaluation order isn't clear.
17:22:39 <randomwords> Could someone help me understand why the threaded and unthreaded versions return different results in the following code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29445
17:22:51 <watermind> p_l let me check that too
17:23:31 <dolio> It's probably a pain to incorporate with JVM libraries and remain pure.
17:23:39 <dolio> If I had to guess.
17:24:01 <p_l> dolio: I'd say it's a pain to do most things with it...
17:24:20 <dolio> Also, way back, I think one of the Algol iterations had non-strict evaluation.
17:24:46 <dolio> At least, you could write non-strict functions. Not that that was the default ordering for everything.
17:24:59 <kmc> it had call by name parameters i think
17:25:16 <kmc> which would actually capture the function's inner scope
17:25:38 <watermind> dolio: ah Jaskell is meant to be a backend to GHC
17:25:45 <dolio> It is?
17:25:56 <watermind> dolio: http://www.scdi.org/~avernet/projects/jaskell/
17:26:06 <watermind> "My goal is to build a new backend (named Jaskell) for GHC to enable it to produce Java byte code"
17:26:23 <kmc> that's a different project
17:26:40 <kmc> "Page last modified on September 03, 2000"
17:26:46 <kmc> uses pre-98 Haskell
17:26:47 <dolio> watermind: http://jaskell.codehaus.org/
17:26:47 <watermind> oh
17:26:51 <dolio> That's the Jaskell I'm talking about.
17:26:56 <watermind> ah
17:26:57 <copumpkin> wow, Netscape now
17:27:15 <watermind> hehe
17:30:24 <aristid> Text.JSON uses Rational as the internal representation for numbers, but has no JSON instance for Rational. wtf
17:30:54 <copumpkin> lol
17:35:28 <roconnor> Gah, I hate it when people think of unsafePeformIO means GHC's implemenation of unsafePeformIO
17:35:53 <roconnor> IIRC unsafePeformIO can't even be used to do unsafeCoerce in YHC I think it was.
17:36:07 <roconnor> GHC /= Haskell!
17:36:12 <dolio> How do they prevent that, other than by not having IORef?
17:36:37 <roconnor> different semantics of unsafePerformIO / different semantics of IORef
17:36:49 <dolio> Does it blow up if you try to make a ref escape?
17:37:14 <roconnor> IIRC the polymorphic IORef is treated like a function from types to IORef
17:37:27 <roconnor> so you end up getting two new IORefs when you try to instantiate it at different types
17:37:52 <roconnor> I forget if this was JHC or YHC or which one, but one of them was different.
17:38:05 <dolio> Well, JHC has special support for top-level IORefs.
17:38:44 <roconnor> can I have concatMaybe in ocaml?
17:41:00 <roconnor> @type concatMaybes
17:41:01 <lambdabot> Not in scope: `concatMaybes'
17:41:03 <roconnor> @type concatMaybe
17:41:04 <lambdabot> Not in scope: `concatMaybe'
17:41:07 <roconnor> @type catMaybes
17:41:08 <lambdabot> forall a. [Maybe a] -> [a]
17:42:06 <roconnor> oh I can use flatten and fake maybe
17:42:10 <watermind> roconnor, so what would be unsafe about that implementation of unsafePerformIO?
17:42:56 <roconnor> watermind: Well you would still have no control over how often or if any side effects are preformed
17:43:59 <watermind> roconnor: right
17:45:51 <dolio> roconnor: I got a stern talking to when I mentioned that unsafePerformIO is only for FFI-associated shenanigans on comp.lang.haskell.
17:46:22 <dolio> Apparently that's revisionist propaganda, and unsafePerformIO is indispensable for doing real programming in Haskell.
17:47:17 <roconnor> dolio: there is a comp.lang.haskell?
17:47:28 <dolio> Yeah. A couple years old.
17:47:29 <roconnor> granted I don't do "real" programming in Haskell
17:47:34 <copumpkin> hmm
17:47:40 <dolio> I must not, either.
17:47:41 <roconnor> I just happen to solve all my problems with it
17:47:45 <copumpkin> can dependent functions be seen as cones?
17:47:50 <roconnor> portfolio optimization
17:47:53 <djahandarie> roconnor, that must mean you have no real problems
17:47:55 <roconnor> what to plant in Farmville.
17:48:02 <ezyang> Hey guys, I'm seeing some very mysterious behavior. 
17:48:02 <roconnor> djahandarie: It's true
17:48:04 <djahandarie> haha
17:48:19 <ezyang> I have some code that inexplicably hangs right before it makes an FFI call. 
17:48:50 <ezyang> I checked gdb and it never gets to the FFI call. However, if I put a print statement right before the call, it does get printed. 
17:48:57 <ezyang> I've forced all of the arguments too... 
17:49:19 <watermind> As if it weren't bad enough that old the theory influences seen in names like Monad and Functor scare practical people away.... then they go and name tech features also scary names like "unsafe"
17:49:30 <ezyang> oh. 
17:49:33 <watermind> why not substitute "unsafe" with "surprise"
17:49:37 * ezyang feels sooo stupid now 
17:49:46 <dolio> copumpkin: Typically, families of types B(a) are modeled categorically as B -> A.
17:50:20 <roconnor> ... assembling broken viridian H-1623-MEU's ...
17:50:20 <djahandarie> ezyang, I can't count the number of times I've been stuck on a problem until I ask someone else about it and then realize the answer in the process
17:50:37 <dolio> Where, if you imagine an element of B (even though there are no elements in category theory), the function tells you what element of A it's indexed by.
17:50:41 <ezyang> djahandarie: :-) 
17:50:52 <ezyang> Woe to foo a b c = foo a b c when you meant foo' a b c 
17:51:11 <roconnor> ezyang: I have a love hate relation with '
17:51:17 <djahandarie> Heh
17:51:23 <dolio> And if f : B -> A, then B(a) = f^-1 a, the fiber of B over a, or something.
17:51:53 <roconnor> dolio: that explains why sections of vector bundles seems so backwards to me
17:52:02 <randomwords> Could someone help me understand why the threaded and unthreaded versions return different results in the following code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29445
17:52:29 <dolio> roconnor: Yeah, I've read my share of papers on the subject (or tried, at least) but I still haven't gotten used to it.
17:53:06 <roconnor> clearly a section should be a dependent function from the base space to an indexed set of vector spaces.
17:53:10 <calsaverini> hey
17:53:17 <copumpkin> dolio: hmm, I think I see
17:53:20 <roconnor> but they define a map from all the vector spaces to the base space!
17:53:22 <roconnor> so strange
17:53:57 <calsaverini> I'm having a pretty stupid difficulty with ghc... what should I do to be able to import a module?
17:54:06 <calsaverini> I mean, a module I created
17:54:23 <roconnor> heh, ocaml's . syntax for record field access takes some getting used to.
17:54:27 <dh__> calsaverini: ghci test.hs
17:54:39 <dh__> or inside ghci , :l test.hs
17:54:43 <dolio> roconnor: I still don't have very good intuition for it, but I think you can look at the B in B -> A as being more like Sigma (a:A) B(a), and then the morphism is the first projection.
17:54:54 <calsaverini> I have a file that defines a module: module Foo (stuff1, stuff2, stuff3) where (...)  
17:54:59 <roconnor> dolio: yep
17:55:03 <calsaverini> now I want to load it inside another file
17:55:22 <calsaverini> but just doing a import Foo gives me an error message saying that the module can't be found
17:55:38 <benmachine> calsaverini: the first file should be called Foo.hs
17:55:39 <roconnor> dolio: it's true, but dependent functions are kinda complicated in that framework. IMHO
17:55:48 <dh__> which module ? 
17:56:09 <dolio> Yes, it does seem more complicated than type theory.
17:56:10 <roconnor> dolio: someone hand the topologists a 
17:56:16 <lispy> randomwords: probably because of the way you fork
17:56:18 <calsaverini> Duh!!! Of course!
17:56:24 <calsaverini> thanks, <benmachine>
17:56:27 <calsaverini> that must be it
17:56:38 <calsaverini> (I warned it was a stupid problem)
17:56:43 <calsaverini> hahaha
17:56:50 <randomwords> lispy: Which is?
17:56:51 <lispy> randomwords: in goArThreaded it's (Thread.forkIO (fibAt arr i)) >> go (i+1), is that what you intended?
17:57:03 <copumpkin> so nobody has tried to make an Agd category? :P
17:57:09 <copumpkin> beyond the obvious Haskish one
17:57:17 <dolio> copumpkin: There are also 'categories with families' which seem closer to dependent types. I forget who developed those.
17:57:25 <dolio> Either Setzer or Dybjer, probably.
17:57:27 <randomwords> lispy: I think so
17:57:34 <lispy> randomwords: also, why do you duplicate timeUnthreaded?
17:57:38 <ski> @hoogle Either Setzer Dybjer
17:57:39 <lambdabot> Did you mean: :: Either Setzer Dybjer /count=20
17:57:39 <lambdabot> No results found
17:57:53 <lispy> randomwords: why not pass either goArr or goArrThreaded as a parameter to it?
17:58:09 <copumpkin> http://www.pps.jussieu.fr/~pclairam/cwfreport.pdf seems to mention them
17:58:13 <randomwords> lispy: Because of the order I wrote everything in
17:58:18 <lispy> time go arrayLength = do .... go array arrayLength ...
17:58:35 <randomwords> lispy: I realise the duplication is ugly
17:58:43 <lispy> then in main, time goArr arrLength; time goArrThreaded arrLength
17:58:49 <randomwords> sure sure
17:59:12 <lispy> randomwords: it's not just about ugly.  It also helps you see how where your two versions are different.
17:59:17 <randomwords> It's an artifact of the way it was written, they used to more divergent
17:59:24 <lispy> randomwords: and seeing that will help you seen how they are different
17:59:45 <dolio> copumpkin: Ah, yes. That compares the three main techniques for modeling type theory using category theory.
17:59:59 <lispy> randomwords: I assume they compute different results due to race conditions
18:00:17 <lispy> randomwords: You don't seem to use STM or MVars or anything and you're reading/writing to a IOUArray in multiple threads.
18:00:31 <dolio> And shows how you can translate from one to the others.
18:00:53 <lispy> randomwords: I hope that helps. I have to run
18:01:00 <dolio> Hyperdoctrines and locally cartesian closed categories seem pretty similar to me, though.
18:01:00 <randomwords> lispy: Ok, that's what I needed to know. Wasn't sure if reading and writing were atomic or not
18:01:09 <copumpkin> dolio: yeah, it seems interesting
18:01:34 <dolio> Except that the former seem to have more of a prop/type divide, whereas the latter seem more like propositions-as-types motivated.
18:01:41 <randomwords> lispy: Thanks!
18:02:40 <Fjr> hey, anyone could shoot me a sample of a simple function doubleList :: [Int] -> [Int] that doubles all values of a list?
18:03:31 <copumpkin> :t map (2*)
18:03:32 <lambdabot> forall t. (Num t) => [t] -> [t]
18:03:33 <randomwords> map (* 2)
18:03:46 <copumpkin> :t map (join (+))
18:03:47 <lambdabot> forall a. (Num a) => [a] -> [a]
18:03:56 <copumpkin> (if you want to be obscure)
18:04:14 <roconnor> ((*2)<$>)
18:04:43 <aristid> :t (join(+).)
18:04:44 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
18:04:57 <Fjr> thanks! amazed how easy can be for people who knows
18:04:57 <roconnor> aristid: that only works on lambdabot
18:05:06 <aristid> roconnor: yeah
18:05:13 <roconnor> Fjr: copumpkin's solution is the most serious one
18:05:21 <copumpkin> lol
18:05:21 <aristid> or on any machine with Caleskell inside(tm)
18:05:22 <Fjr> thx roconnor
18:05:25 <roconnor> randomwords's is good too
18:05:26 <Fjr> lol
18:05:35 <copumpkin> roconnor: which one? :)
18:05:44 <roconnor> map (2*)
18:05:47 <copumpkin> oh
18:06:16 <aristid> roconnor: but join(+) is more efficient because multiplication is so inefficient!
18:06:37 <benmachine> obv you need (`shiftL` 1)
18:07:01 <roconnor> benmachine: you should use unsoundShiftL for speed
18:07:10 <roconnor> unless ghc optimizes shiftL now.
18:07:47 <dolio> unchecked
18:07:54 <randomwords> talking of speed, is it just me or is truncate unusually slow?
18:08:03 <dolio> And I don't think it optimizes.
18:08:20 <roconnor> oh right unchecked
18:08:43 <roconnor> dolio: I've complained about it since 2006, but IIRC last time I asked dons said it was fixed
18:09:11 <dolio> I could be wrong.
18:09:12 <copumpkin> now that there's some noise around here, did anyone see my question earlier about NBE?
18:10:09 <dh__> :t join
18:10:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:10:38 <dolio> copumpkin: I did not.
18:12:00 <dh__> :t join (+)
18:12:01 <lambdabot> forall a. (Num a) => a -> a
18:12:14 <dh__> > (join (+) ) 5
18:12:15 <lambdabot>   10
18:12:32 <copumpkin> well, I'm very not self confident about it, but I'll give it another shot :) NBE seems to work by translating your language to a (generally simpler) language, evaluating it, and lifting it back out of the simpler language into your original language, which feels a bit like a pair of adjoint functors being composed (i.e. a monad). 
18:12:45 <copumpkin> I haven't worked through the details and don't even understand NBE that much yet, but was just curious if it made any sense
18:13:15 <Fjr> ok, but to work as a function doubleList :: [Int]->[Int]  I need something before map (2*)
18:13:44 <dh__> I don't understand why ( join (+) )  gives * 2, any help?
18:13:55 <copumpkin> dh__: do you understand the ((->) r) monad instance?
18:13:56 <roconnor> Fjr: doubleList = map (2*)
18:14:01 <dolio> It may be an adjunction. I'm not sure.
18:14:26 <dolio> I think there's a syntax/semantics adjunction, but I'm not certain what that's about.
18:14:26 <Fjr> yeah, thx, I  was trying doubleList n map (2*)
18:14:30 <dolio> That's what NBE is, though.
18:14:32 <Fjr> hehe
18:14:41 <roconnor> Fjr: you can eta expand the definition if you want
18:14:52 <roconnor> doubleList xs = map (2*) xs
18:14:55 <ski> dh__ : unify `m (m x)' with `a -> a -> a' gives `m = (a ->)' and `x = a', so the result type `m x' is `a -> a' .. all this assuming that `Monad m', i.e. `Monad (a ->)'
18:15:00 <Fjr> perfect, thx a lot
18:15:06 <roconnor> both are fine
18:15:57 <dolio> You have some semantic set that should only represent canonical terms. Then, to normalize, you use the semantic function to translate the syntactic term into the semantic object, and then use another function that gives you the syntactic representative of the semantic value.
18:16:13 <orlandu63> dh__: join does what you think it does. the type definition is just written in terms of a monad
18:17:04 <copumpkin> dolio: yeah, that's what I thought. I guess the question is whether the syntactic and semantic sets form categories, and (if so) whether the functors used between them are adjoint
18:17:14 <dh__> @src join
18:17:15 <lambdabot> join x =  x >>= id
18:17:26 * copumpkin shrugs
18:17:34 <copumpkin> I'll work through it when this headache goes away
18:17:37 <ski> @src (->) (>>=)
18:17:37 <lambdabot> f >>= k = \ r -> k (f r) r
18:17:39 <dh__> how can I get the source of ((->)r ) Monad?
18:17:46 <ski> dh__ : ^
18:18:41 <roconnor> @src (>>=) (->)
18:18:41 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:18:45 <roconnor> oh
18:18:47 <copumpkin> dh__: it might be simpler to think of ((->) r) as a potentially infinite Map r, by the way
18:18:48 <roconnor> ski did it already
18:18:56 <aristid> join f = f >>= id = \r -> id (f r) r = \r -> f r r
18:19:36 <orlandu63> you guys are overestimating dh__'s understanding of haskell
18:19:44 <dh__> oh , so join (+) = \r -> (+) r r , 
18:19:49 <ski> yes
18:19:51 <aristid> dh__: yes
18:20:21 <dh__> copumpkin: why infinite Map r ? what is the r there?
18:20:22 <copumpkin> orlandu63: I think viewing it as an infinite Map feels a lot more "concrete"
18:20:32 <ski> any type at all
18:20:34 <copumpkin> dh__: just any type
18:20:36 <ski> (with kind `*')
18:20:45 <ski> e.g. `r' might be `Integer'
18:20:48 <ski> or `Bool'
18:20:49 * wli never grokked hyperdoctrines.
18:20:51 <dh__> I don't understand the (->) r part.
18:20:57 <ski> `Bool -> a' is basically `(a,a)'
18:21:06 <copumpkin> dh__: ((->) r) is the same as (r ->)
18:21:14 <copumpkin> (i.e., a partially applied function arrow
18:21:18 <ski> and `(->) r a' is the same as `r -> a'
18:21:19 <dh__> oh, thants. 
18:21:23 <dh__> oh , thanks.
18:21:25 <copumpkin> (just like my partial unclosed parentheses
18:21:34 <aristid> )
18:21:41 <ski> aristid : i was just about to ..
18:21:45 <aristid> fully evaluated parentheses now
18:21:52 <benmachine> there was another one)
18:22:31 <aristid> No instance for Parantheses (a `Parentheses` b) in GOBBYLEDYGOOK
18:22:55 <ski> (order is restored in the universe)
18:23:20 <aristid> :t () 1
18:23:21 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `()'
18:23:21 <lambdabot>     In the expression: () 1
18:23:45 <aristid> :t () == 1
18:23:46 <lambdabot>     No instance for (Num ())
18:23:47 <lambdabot>       arising from the literal `1' at <interactive>:1:6
18:23:47 <lambdabot>     Possible fix: add an instance declaration for (Num ())
18:25:55 <benmachine> :t fmap id 0
18:25:55 <lambdabot> forall a (f :: * -> *). (Num (f a), Functor f) => f a
18:26:02 <dh__> where can I find the source of Monad ( (->) r )
18:26:04 * hackagebot hslogger-template 1.1.0 - Automatic generation of hslogger functions  http://hackage.haskell.org/package/hslogger-template-1.1.0 (BrianLewis)
18:26:05 <benmachine> ^ why is the first an error and the second just a weird context
18:26:15 <copumpkin> dh__: Control.Monad.Instances
18:26:18 <benmachine> dh__: work it out from the type signature :D
18:26:31 <copumpkin> dh__: but yeah, there's only one meaningful definition of it
18:27:03 <dh__> Control.Monad.Instances has no defintion for (->) r
18:27:11 <dh__> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad-Instances.html
18:27:17 <dolio> copumpkin: Oh, the syntax-semantics adjunction is between a category of theories and a category of sets of mathematical objects. So I guess that's not what you're asking.
18:27:29 <copumpkin> oh
18:27:32 <copumpkin> boo :)
18:27:45 <benmachine> dh__: http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/src/Control-Monad-Instances.html
18:28:18 <dolio> That adjunction is about the minimal theory describing a set of objects, and the set of all objects that are models of a theory.
18:28:23 <dh__> benmachine: thanks.
18:28:44 <dolio> (Maximal set).
18:29:24 <ski> dolio : Lawvere's functorial semantics ?
18:29:43 <dolio> Yes, I think so.
18:31:20 <ski> there you have (e.g.) a category `Group', where functors from it to `Set' are the group objects in `Set'
18:31:45 <ski> (and similarly with functors to any other monoidal category)
18:32:43 <ski> (see e.g. <http://math.ucr.edu/home/baez/week200.html>)
18:36:49 <ski> (in terms of that page, the above `Group' is `Th(Grp)')
18:40:08 <jayku> dino
18:41:22 <dh__> since (,) a has an instance of Function , how can I use ? 
18:41:32 <copumpkin> Functor ?
18:41:34 <dolio> ski: Yeah. I have a Lawvere paper on this lying around.
18:41:35 <dh__> > fmap (+1) ( (,) 3 )
18:41:36 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> (t, b))
18:41:36 <lambdabot>    arising from a use...
18:41:39 <dolio> Adjointness in Foundations.
18:41:42 <copumpkin> > fmap (+1) (1, 5)
18:41:43 <lambdabot>   (1,6)
18:41:47 <dh__> yes , function.
18:41:52 <dh__> yes, functor. 
18:42:02 <dh__> thanks. 
18:42:33 <dh__> :t ( 5 (,) )
18:42:34 <lambdabot> forall t a b. (Num ((a -> b -> (a, b)) -> t)) => t
18:42:55 <dh__> why do we define a functor for (,) a , not  a (,) ?
18:43:02 <mm_freak_> i've never used the '(,) a' functor
18:43:17 <mm_freak_> dh__: a (,) doesn't make much sense
18:43:25 <mm_freak_> you rather mean:  (, a)
18:43:45 <benmachine> or (a ,) possibly
18:43:48 <dh__> :t (5 (,)) 
18:43:49 <lambdabot> forall t a b. (Num ((a -> b -> (a, b)) -> t)) => t
18:43:51 <dh__> :t (5,)
18:43:52 <lambdabot> parse error on input `)'
18:44:07 <mm_freak_> but haskell's type system doesn't allow flipping constructors
18:44:24 <ski> @kind (,) Int
18:44:25 <lambdabot> * -> *
18:44:37 <ski> @kind (Int,)
18:44:38 <lambdabot> parse error on input `)'
18:44:50 <mm_freak_> dh__: for lambdabot unary numeric functions are Num instances
18:44:50 <dh__> @kind Int (,)
18:44:51 <lambdabot>     Kind error: `Int' is applied to too many type arguments
18:44:57 <benmachine> aww, no tuple sections in types
18:45:05 <mm_freak_> so the '5' in (5 (,)) is a constant function
18:45:11 <mm_freak_> > sin + cos $ 15
18:45:12 <lambdabot>   -0.10940007270170449
18:45:17 <ski> @type (False,)
18:45:18 <lambdabot> parse error on input `)'
18:45:51 <dh__> what is the  + in sin + cos here ? lifted ? 
18:46:02 <mm_freak_> it's + for unary functions
18:46:10 <mm_freak_> @src (a -> a) +
18:46:11 <lambdabot> Source not found. You untyped fool!
18:46:14 <ski>   instance Num n => Num (r -> n)
18:46:21 <mm_freak_> @src (Num a => (a -> a)) +
18:46:21 <lambdabot> Source not found. You speak an infinite deal of nothing
18:46:32 <mm_freak_> f + g = \x -> f x + g x
18:46:52 <dh__> :t sin + cos
18:46:53 <lambdabot> forall a. (Floating a) => a -> a
18:46:57 <dh__> :t sin * cos
18:46:58 <lambdabot> forall a. (Floating a) => a -> a
18:47:28 <benmachine> > sin^2 + cos^2 $ 3
18:47:29 <lambdabot>   0.9999999999999999
18:47:35 <mm_freak_> > (3*sin^2 - 4*cos^3) 15
18:47:36 <lambdabot>   3.022364574927358
18:47:52 <ski> (hm, `diff' is not in scope any longer ?)
18:48:06 <mm_freak_> unfortunately that instance is very hacky
18:48:08 <mm_freak_> > sin == cos
18:48:09 <lambdabot>   *Exception: (==): No overloading for function
18:48:34 <benmachine> mm_freak_: it's only to overcome the inherent silliness of Num :P
18:48:42 <mm_freak_> benmachine: yes =)
18:49:03 <mm_freak_> but i don't expect the Prelude to be revised any time soon
18:50:13 <blackdog> how would you find the arity of a value in ghci?
18:50:59 <copumpkin> blackdog: I wrote something simple the other day for it
18:51:04 <copumpkin> I wonder if I can still find it on hpaste
18:51:26 <mm_freak_> the arity?
18:51:49 <blackdog> the number of arguments it takes
18:52:01 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29447#a29447
18:52:04 <blackdog> it's pretty easy in most languages, it's a bit more subtle in haskell
18:52:09 <mm_freak_> a /function/ to find that out?
18:52:20 <blackdog> Prelude> :t f
18:52:21 <blackdog> f :: (Num t1) => t -> t1
18:52:21 <blackdog> Prelude> :t ((f undefined) undefined)
18:52:21 <blackdog> ((f undefined) undefined) :: (Num (a -> t)) => t
18:52:21 <blackdog> Prelude> :t (((f undefined) undefined) undefined)
18:52:23 <blackdog> (((f undefined) undefined) undefined) :: (Num (a -> a1 -> t)) => t
18:52:24 <mm_freak_> ah, yeah, you could do that
18:52:33 <kmc> overlapping instances :/
18:52:33 <mm_freak_> i guess you can also do it using existentials or something
18:52:47 <blackdog> so you can keep applying undefined to it, even though to my mind, the arity is 1
18:52:50 <kmc> functions are all 1-ary really
18:53:10 <mm_freak_> and values are all 0-ary
18:53:22 <copumpkin> blackdog: anyway, I wrote something else to apply undefined to something repeatedly, but it's not very useful, I don't think :P
18:53:25 <blackdog> that's incoherent - functions _are_ values
18:53:27 <mm_freak_> but all functions are values, too, so it's a bit odd to ask for arity
18:53:30 <dh__> copumpkin: what's the undefined :: b mean? 
18:53:46 <mm_freak_> blackdog: for example the undefined value has all arities
18:53:49 <kmc> an undefined value of type b
18:53:50 <copumpkin> dh__: all I care about is the type
18:54:14 <copumpkin> mm_freak_: my code will clearly just ask you to refine the type until it can figure it out :P
18:54:15 <kmc> asking the arity of a value is just asking whether a value is a function
18:54:15 <lispy> what else is there besides types?
18:54:18 <kmc> if so the answer is 1
18:54:20 <kmc> if not, the answer is 0
18:54:36 <kmc> and you know whether a value is a function from its static type
18:54:42 <blackdog> to ground this a little: I'm trying to inspect a haskell function to see if it's suitable to be called from ruby
18:54:47 <copumpkin> blackdog: I can give you the code to "saturate" the function with undefineds
18:54:50 <copumpkin> if you're interested
18:54:56 <blackdog> copumpkin: that would be great
18:55:02 <copumpkin> blackdog: you saw the arity one though?
18:55:04 <lispy> blackdog: Would data.dynamic or data.typeable do it?
18:55:05 <dh__> what's the meaning of [1,2,3] >> "abc" as Monad instance of [] ? 
18:55:10 <lispy> blackdog: and you've read dons thesis, yeah?
18:55:14 <blackdog> copumpkin: i'm looking at it and trying to understand it.
18:55:39 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29448#a29448
18:55:43 <mm_freak_> dh__: "abcabcabc", i guess
18:55:46 <blackdog> lispy: not all of it yet. i'm taking a slightly different approach to don
18:55:48 <copumpkin> same idea
18:55:59 <mm_freak_> dh__: translate it to (>>=) to see what it does
18:56:16 <mm_freak_> > [1,2,3] >>= \_ -> ['a', 'b', 'c']
18:56:17 <lambdabot>   "abcabcabc"
18:56:21 <lispy> blackdog: ah.  But still, his thesis maps out the alternatives he didn't choose at a high level.  Maybe you can find your way using that map.
18:56:33 <aristid> :t Identity
18:56:34 <lambdabot> forall a. a -> Identity a
18:56:37 <dh__> mm_freak_: I know the result, but I don't understand , why do we need to write such weird code ..
18:56:44 <lispy> blackdog: do you use ghci-api?
18:56:50 <mm_freak_> dh__: the parameter you ignored represents 1, 2 and 3
18:56:51 <blackdog> lispy: indirectly
18:56:54 <blackdog> i'm using HINT
18:57:04 <aristid> :t let a $ b = runIdentity . a . Identity b in ($)
18:57:05 <lambdabot> forall a a1. (a -> Identity a1) -> a -> Identity a1
18:57:06 <mm_freak_> dh__: and for each of those you result in 'a', 'b' and 'c'
18:57:11 <mm_freak_> so you have nine results in total
18:57:12 <aristid> :t let a $ b = a . Identity b in ($)
18:57:13 <lambdabot> forall a b. (a -> b) -> a -> Identity b
18:58:01 <mm_freak_> dh__: list monad behaviour can be weird sometimes, but once you understand it it's really useful
18:58:24 <mm_freak_> dh__: remember that there is a 1-to-1 mapping between monadic expressions and list comprehensions
18:58:27 <dh__> mm_freak_, I understand why the result is that , what I don't understand is :: Monad seemed gives weird result some time  .
18:58:54 <blackdog> copumpkin: that's really cute, actually.
18:58:58 <xiackok> i have a function like: overMapPos :: forall a b. Map -> (MapObject -> Int -> Int -> a) -> [[a]]
18:59:02 <mm_freak_> > [ x + y | x <- [1,2,3], y <- [2,3,4], x /= y ]
18:59:03 <lambdabot>   [3,4,5,5,6,5,7]
18:59:21 <mm_freak_> do x <- [1,2,3]; y <- [2,3,4]; guard (x /= y); return (x+y)
18:59:24 <mm_freak_> > do x <- [1,2,3]; y <- [2,3,4]; guard (x /= y); return (x+y)
18:59:25 <lambdabot>   [3,4,5,5,6,5,7]
18:59:25 <blackdog> lispy: yes, I do intend to finish it soon.
18:59:47 <dh__> mm_freak_: that was cool, thanks!!
18:59:58 <xiackok> i want pass monad function for second parameter
19:00:15 <xiackok> like SDL.Image.load
19:00:26 <blackdog> lispy: the basic difference of approach is that he's trying to keep everything well-typed, and to have haskell rule the process. in a bridge situation, haskell is working for ruby, so the mapping has to be done on ruby's terms - basically a C level api
19:00:32 <mm_freak_> xiackok: Map isn't from Data.Map, is it?
19:00:49 <xiackok> mm_freak_: no its game map
19:00:53 <mm_freak_> ah, ok
19:01:01 <dh__> copumpkin: do you have a mathematical background?
19:01:10 <copumpkin> dh__: not really
19:01:17 <copumpkin> I wish I did :)
19:01:19 <mm_freak_> xiackok: your function doesn't support monads the way you like
19:01:39 <copumpkin> I've been doing my best to build one for myself though
19:01:42 <mm_freak_> overMapPosM :: Monad m => Map -> (MapObject -> Int -> Int -> m a) -> m [[a]]
19:01:46 <ski> @type sequence . sequence
19:01:47 <lambdabot> forall a. [[a]] -> [[a]]
19:01:49 <mm_freak_> that's what its type should look like
19:02:24 <mm_freak_> but if you can live with separate monadic computations, then your 'a' could be a monadic type and you could then use 'sequence'
19:02:40 <dh__> what is Monad [::] ? 
19:02:52 <ski> @type sequence . liftM sequence  -- there you are
19:02:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
19:03:08 <copumpkin> dh__: you mean parallel arrays?
19:03:10 <xiackok> mm_freak_: i have con
19:03:13 <mm_freak_> :t sequence . join
19:03:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [a]
19:03:25 <aristid> :t join . sequence
19:03:26 <lambdabot> forall a. [[a]] -> [a]
19:03:40 <lispy> blackdog: have you ever looked at the jvm-bridge package?
19:03:49 <dh__> I don't know, it's in http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad.html#t%3AFunctor, but I can't find [::]
19:04:00 <dh__> what does [::] mean ? where can I find it?
19:04:08 <blackdog> lispy: no
19:04:08 <copumpkin> it's a DPH thing
19:04:11 <mm_freak_> dh__: don't worry about [::] for now, until you understand haskell better =)
19:04:20 <ski> xiackok : so, what if you pass your monadic function and get a `[[m a]]' result, with `m' the monad in question, and then use `sequence . liftM sequence' to get `m [[a]]' ?
19:04:21 <xiackok> mm_freak_: i have wonder is there a quick way. ok i think i can use sequence . join
19:04:29 <dh__> mm_freak_: ok, 
19:04:32 <blackdog> lispy: worth checking out? presumably if you have java, you have a fair amount of type info available
19:04:44 <Axman6> : liftM sequence
19:04:48 <Axman6> :t liftM sequence
19:04:49 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1) => m1 [m a] -> m1 (m [a])
19:04:56 <Axman6> :o
19:05:08 <ski> `m1' is set to `[]' above
19:05:10 <Axman6> oh, not as cool as i thought that was
19:05:12 <copumpkin> dh__: it's in this area though, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/dph-par-0.4.0/Data-Array-Parallel.html
19:05:28 <mm_freak_> hmm
19:05:56 <ski> xiackok : so, there's a choice about the *order* in which you want to perform the monadic effects, for each element in the list of lists
19:05:59 <mm_freak_> > sequence . map (\x -> [x+1, x-1]) $ [10, 20, 30]
19:06:01 <lambdabot>   [[11,21,31],[11,21,29],[11,19,31],[11,19,29],[9,21,31],[9,21,29],[9,19,31],...
19:06:08 <copumpkin> Runar: I'm not going to make it to boston in time to see you sadly :/ scott said we might have to wait so the tickets aren't ridiculously expensive
19:06:13 <mm_freak_> mapM = sequence . map?
19:06:15 <dh__> copumpkin: thanks. weird symbol make it hard to google.
19:06:22 <copumpkin> dh__: yeah :)
19:06:23 <ski> xiackok `sequence . liftM sequence' just performs them in the straight-forward left-to-right order
19:06:39 <ski> @src mapM
19:06:39 <lambdabot> mapM f as = sequence (map f as)
19:07:05 <xiackok> :t sequence . liftM
19:07:06 <lambdabot>     Couldn't match expected type `[m a]'
19:07:06 <lambdabot>            against inferred type `m1 a1 -> m1 r'
19:07:06 <lambdabot>     Probable cause: `liftM' is applied to too few arguments
19:07:21 <xiackok> :t sequence . liftM sequence
19:07:22 <ski> @tpe sequence . liftM sequence
19:07:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
19:07:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
19:07:27 <Axman6> :t \f -> sequence . liftM f
19:07:28 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
19:07:51 <mm_freak_> ski: i don't think that sequence . join is different from sequence . fmap sequence
19:08:06 <ski> @type sequence . join
19:08:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [a]
19:08:10 <ski> mm_freak_ : different types
19:08:17 <mm_freak_> oh, indeed
19:08:55 <ski> Axman6 : hm, interesting question
19:09:15 <mm_freak_> btw, i don't like this liftM function
19:09:22 * ski neither
19:10:40 <c_wraith> I use liftM only when my other alternative is to add a Functor constraint to a function that otherwise wouldn't have one.
19:11:01 <ski> yeah, i do the same
19:11:32 <mm_freak_> i add it
19:11:40 <lispy> newtype Haskell m a = BrainT m a deriving (Monad, Functor, Applicative)
19:11:55 <mm_freak_> in most cases i use <$>
19:12:02 <mm_freak_> and often you'll find a <*>, too
19:13:37 <lispy> :t (ap, <*>)
19:13:38 <lambdabot> parse error on input `)'
19:13:46 <lispy> :t (ap, (<*>))
19:13:47 <lambdabot> forall (m :: * -> *) a b (f :: * -> *) a1 b1. (Monad m, Applicative f) => (m (a -> b) -> m a -> m b, f (a1 -> b1) -> f a1 -> f b1)
19:14:28 <xiackok> ok sequence . liftM sequence its working for me
19:14:33 <xiackok> thanks mm_freak
19:14:41 <mm_freak_> xiackok: thank ski ;)
19:14:46 * ski grins
19:14:56 <mm_freak_> my solution was different
19:14:59 <xiackok> yes sorry about that :)
19:15:12 <lispy> oh, I should have said: newtype Haskell m a = Haskell (BrainT m a) deriving (Monad, Functor, Applicative)
19:16:03 <mm_freak_> runBrainT :: a
19:16:18 <lispy> mm_freak_: nah, there is no escape from Haskell :)
19:16:28 <mm_freak_> lispy: that's the point ;)
19:16:34 <lispy> ah
19:17:22 <ski> xiackok : oh, as i think Axman6 implied, but which i didn't satsify myself of directly (i'm tired), `sequence . liftM f' is the same as `mapM f', so instead of `sequence . liftM sequence', you can use just `mapM sequence'
19:17:54 <ski> (simply because `liftM' is `map', for `[]')
19:19:03 <xiackok> :t mapM
19:19:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:19:11 <ski> @src mapM
19:19:12 <lambdabot> mapM f as = sequence (map f as)
19:19:30 <ksf_> damn these stage restrictions, they shouldn't be mangled up with the module system.
19:19:40 <ski> ?
19:19:53 <ksf_> as soon as I want to do a wee bit of TH, I end up exploding a module into two, if not three.
19:20:16 <lispy> ksf_: yeah :(
19:20:30 <ksf_> ...having to move out some data types into the TH module (or, cleaner, a third one).
19:20:36 <mm_freak_> btw, does anyone actually use writer monads?
19:20:50 <lispy> mm_freak_: yeah
19:20:53 <copumpkin> Data.Binary does
19:20:58 <copumpkin> :P
19:21:06 <lispy> mm_freak_: i implemented a compiler that had a code gen monad using writer
19:21:15 <lispy> mm_freak_: my procmail dsl's monad is a writer
19:21:18 <xiackok> ski: but it doesnt for my function : overMapPos :: forall a b. Map -> (MapObject -> Int -> Int -> a) -> [[a]]
19:21:19 <mm_freak_> hmm, yeah, that makes sense
19:21:30 <xiackok> i tried overMapPos :: forall a b. Map -> (MapObject -> Int -> Int -> a) -> [[a]]
19:21:31 <ksf_> writer also comes in handy when you use SYB
19:21:32 <ski> xiackok : it doesn't what ?
19:22:11 <xiackok> ghci says match expected type 'a -> mb' against inferred type [[IO SDL.Surface]]
19:22:20 <ski> <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10060> uses `Writer'
19:22:50 * ski has used `Writer' for some logging in CGI, iirc
19:23:04 <Fjr> hey, how about a function doing an and (&&) on all elements like ListAnd :: [Bool] -> Bool    anyone?
19:23:05 <ski> xiackok : how are you calling it ?
19:23:12 <ski> @type and
19:23:13 <lambdabot> [Bool] -> Bool
19:23:14 <lispy> mm_freak_: if you're writing a program to satisfy a security target, a common requirement of the security target will be an audit log.  You could implement the audit log using a writer (especially if it wrote to the log instead of just accumulating a list of writes)
19:23:52 <xiackok> ski: mapM (overMapPos myMap (\o c r -> SDLi.load "resources/player.png")) []
19:23:53 <mm_freak_> lispy: for logging i always use a thread
19:24:03 <copumpkin> mm_freak_: that's very impure of you
19:24:15 <copumpkin> lispy: I'd think especially if you don't write it
19:24:21 <copumpkin> since Writer is pure and just works on a monoid
19:24:26 <mm_freak_> and so far i've never written a pure function that needs to log
19:24:27 <blackdog> copumpkin: do you mind if I steal that trick for Hubris?
19:24:30 <Fjr> lambdabot: you mean ListAnd = [Bool] -> Bool wont work
19:24:42 <ski> xiackok : hm, what is `o',`c',`r' there, and why don't you use them ?
19:24:44 <copumpkin> blackdog: oh not at all, it's so small I wouldn't even claim ownership of that code :P
19:25:00 <ski> xiackok> :t SDLi.load
19:25:05 <blackdog> copumpkin: you've saved me some trouble, anyway :) thank you.
19:25:06 <copumpkin> blackdog: I'm glad you found a use for it :)
19:25:35 <xiackok> ski: o is MapObject c Column r Row. and SDLi.load returns IO (SDL.Surface)
19:25:58 <xiackok> ski: i dont use because its for trying
19:26:18 <ski> xiackok : try `mapM sequence (overMapPos myMap (...))' ?
19:26:39 <xiackok> ski: damn it. right 
19:27:34 <xiackok> ski: im confused just. now i got it
19:27:38 <xiackok> ski: thanks
19:27:44 <ski> yw
19:27:51 <Fjr> anyone, I need a function to do an AND (&&) on all elements like ListAnd :: [Bool] -> Bool  ?
19:27:57 <c_wraith> :t and
19:27:58 <lambdabot> [Bool] -> Bool
19:28:07 <ski> Fjr : i mentioned `and' above ..
19:28:20 <ski> @type or
19:28:20 <mm_freak_> > Just 3 `mappend` Just 4
19:28:21 <lambdabot> [Bool] -> Bool
19:28:21 <lambdabot>   Ambiguous type variable `t' in the constraints:
19:28:21 <lambdabot>    `Data.Monoid.Monoid t'
19:28:21 <lambdabot>  ...
19:28:25 <Fjr> got it
19:28:29 <mm_freak_> > Just 3 `mappend` Just 4 :: Maybe Int
19:28:31 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
19:28:31 <lambdabot>    arising from a use of...
19:28:37 <mm_freak_> why isn't that a monoid?
19:28:49 <ski> because there's several useful monoids on `Int'
19:29:16 <mm_freak_> ski: no, i mean in the same sense as lists form a monoid
19:29:27 <mm_freak_> > "abc" `mappend` "def" :: Maybe Int
19:29:28 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
19:29:28 <lambdabot>         again...
19:29:31 <mm_freak_> > "abc" `mappend` "def"
19:29:31 <lambdabot>   "abcdef"
19:29:41 <mm_freak_> it could just return the last value
19:29:42 <dolio> > First (Just 3) `mappend` First (Just 4)
19:29:43 <lambdabot>   First {getFirst = Just 3}
19:29:53 <mm_freak_> ah, thank you
19:30:08 <ski> > Just (Product 3) `mappend` Just (Data.Monoid.Sum 4)
19:30:09 <ski> > Just (Product 3) `mappend` Just (Product 4)
19:30:09 <lambdabot>   Couldn't match expected type `Data.Monoid.Product t'
19:30:09 <lambdabot>         against inferr...
19:30:10 <lambdabot>   Just (Product {getProduct = 12})
19:30:18 <lispy> mm_freak_: BTW, my codegen monad was more than _just_ writer.  But, it used writer for part of its functionality.
19:30:37 <por> I'm not sure I understand the comonad law 'fmap f w = w =>> (f . cojoin)', since 'w =>> f = fmap f (cojoin w)'. Why is mapping f over w identical to cojoining w, then mapping (f . cojoin) over it? Either I don't understand the law, I have the law wrong, or my (trivial) comonads are wrong. :/ It would seem that only functions of type (W (W a) -> b), where W is a comonad, would satisfy the 
19:30:37 <por> right-hand side of the law. But then, it would seem, fmap wouldn't work. Am I missing something?
19:30:37 <mm_freak_> lispy: i was always happy with State
19:30:43 <ski> lambdabot : hm, why do that last work in private, then ?
19:30:43 <copumpkin> kmc: omg so much fun, you're missing out
19:30:46 <lispy> It was ReaderT (WriterT MonadUnique ...)
19:30:47 <mm_freak_> lispy: but Writer has the advantage that it doesn't model a function
19:31:22 <ski> > Just (Data.Monoid.Sum 3) `mappend` Just (Data.Monoid.Sum 4)  -- typo
19:31:22 <lambdabot>   Just (Sum {getSum = 7})
19:31:46 <lispy> mm_freak_: RWST is a monad that provides each of reader, writer and state separately.  It's a cool thing because it lets you separate out the bits that are read-only, write-only, and state.
19:32:20 <mm_freak_> lispy: yes, but i usually don't write a single monad using all of those
19:32:35 <mm_freak_> the final monad, which is a transformer stack, does
19:32:37 <lispy> mm_freak_: I've heard xmonad uses RWST at its core
19:32:41 <mm_freak_> (or may)
19:33:01 <mm_freak_> lispy: probably, but i use monad transformers for modularizing my code
19:33:19 <mm_freak_> also i use monadLib, which doesn't provide RWST
19:33:27 <Fjr> ski: you mean ListAnd :: [Bool] -> Bool
19:33:30 <Fjr> ListAnd xs = and xs
19:33:37 <Fjr> sry, newbee
19:33:39 <lispy> mm_freak_: what is the performance like of monadLib?
19:33:42 <ski> Fjr : no `and :: [Bool] -> Bool'
19:34:00 <lispy> mm_freak_: someone on here said that RWST is an all in one monad for performance reasons
19:34:02 <Fjr> will try
19:34:08 <ski> Fjr : you can't name a defined function with a name like `ListAnd' which begins with a capital letter
19:34:13 <mm_freak_> lispy: most likely the same, since it uses the same underlying representations
19:34:19 <Fjr> oh yeah
19:34:21 <Fjr> forgot that
19:34:25 <ski> Fjr : `listAnd' would work
19:34:28 <mm_freak_> lispy: but if you really happen to use RWST you may just as well write your own monad
19:34:38 <mm_freak_>  transformer
19:34:41 <Fjr> thx
19:35:23 <ski> por : `fmap f w = w =>> (f . cojoin)' is wrong, it should be `fmap f wa = wa =>> (f . extract wa)'
19:35:38 <ski> (as you noted, the types doesn't make sense, otherwise)
19:38:20 <ski> pos : er, `fmap f wa = wa =>> (f . extract)', rather
19:38:37 <ski> (refactoring error)
19:39:06 <por> Interesting, thanks. Category extras lists 'fmap f w = w =>> (f . cojoin)' as a law.
19:39:32 <dolio> Yell at edwardk.
19:39:50 <por> (Well, actually 'fmap f == extend (f . duplicate)')
19:40:06 <blackdog> so, any ideas what could cause the error "Not in scope: type constructor or class `Int'" ?
19:40:20 * ski proposes the name `scaffold', instead of `cojoin' or 'duplicate'
19:40:33 <por> Yeah right, running through the library is my current favorite past time.
19:40:33 <blackdog> i suspect i'm not importing something in HINT - it seems very bare-bones by default, but i am importing the PRelude
19:40:57 <por> I like scaffold, especially when you end up with types like W (W (W (W a))).
19:41:07 <ski> preflex : xseen edwardk
19:41:11 <ski> preflex: xseen edwardk
19:41:11 <preflex>  edwardk was last seen on freenode/#haskell 2 days, 6 hours, 44 minutes and 35 seconds ago, saying: but i apparently have to run
19:41:32 * ski . o O ( edwardk is on the run )
19:42:01 <Fjr> ski: sry, still fighting here, something like listAnd xs = and xs ? for ListAnd :: [Bool] -> Bool
19:42:18 <ski> Fjr : s/ListAnd/listAnd/ ?
19:42:59 <Fjr> ski: ListAnd :: [Bool] -> Bool is the function to return an And && bool to all elements
19:43:58 <Fjr> my problem is understing the list processing
19:44:04 <Fjr> in a function
19:45:00 <Fjr> newbie, cant find much samples on this
19:45:14 <ski> Fjr : you still need to decapitalize `ListAnd'
19:45:17 <copumpkin> is there a fundamental reason you can have overlapping class instances but not overlapping type family instances?
19:45:20 <Fjr> sure
19:45:30 <Fjr> listAnd :: [Bool] -> Bool
19:45:30 <dolio> copumpkin: The latter is unsound.
19:45:40 <ski> do you want to write this from scratch ?
19:45:44 <Fjr> in the middle I can have right
19:45:44 <ski> or just call `and' ?
19:45:51 <copumpkin> dolio: oh, how so?
19:46:02 <Fjr> sure, I just pasted an old one
19:46:20 <Fjr> listAnd :: [Bool] -> Bool problem is to do an && on all elements
19:46:24 <ezyang> Huh. It seems like GHC has the moral equivalent of a GIL. Curious! 
19:46:28 <por> Fjr: and is defined using primitive recursion here <http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/GHC-List.html#and>. This is the simplest way to define it.
19:46:30 <ezyang> We call it the "Capability." 
19:47:33 * ski peers curiously at ezyang
19:47:40 <dolio> copumpkin: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg15866.html
19:47:46 <Cale> ezyang: The idea is that there should be at least as many capabilities as the number of cores on which you want the program to run.
19:47:52 <Fjr> por: thx, *and* is simple, my problem is a function returning a bool with an && on all elements from the list
19:48:16 <ski> Fjr : and that is what `and' does. what's the problem ?
19:48:33 <Cale> Also, I don't think that even with one capability there's anything like the insanity that goes on with the Python GIL.
19:48:39 <ezyang> Cale: Yeah, but according to "Extending the Haskell FFI with Concurrency" there is actually only one capability. 
19:48:51 <ezyang> I'll be that it's less insane than the Python GIL though. 
19:48:55 <ezyang> *bet 
19:49:03 <ezyang> Maybe things have changed since they wrote that paper. 
19:49:08 <copumpkin> dolio: ah :/
19:49:17 <ezyang> "Having more than one Capability available would indicate that truly simultaneous multithreaded Haskell execution is available; our current implementation does not however support this, because it would require synchronised access to the heap and other shared state." 
19:49:18 <dh__> Fjr : do you want  [True, Fasle, False ] --> True && False && False ,  or -> [True && , False &&, False &&]
19:49:21 <Cale> The number of capabilities is what the +RTS -N flag sets.
19:49:28 <ezyang> Hmm. 
19:49:31 * ezyang is confuzzled. 
19:49:36 <dolio> copumpkin: Overlap is okay for closed families, though.
19:49:59 <copumpkin> dolio: now if only we had those :)
19:50:02 <dolio> Which is one reason they'd be nice.
19:50:27 <Fjr> thx everyone, I need a function listAnd :: [Bool] -> Bool that makes and && between all elements of the list and return it
19:50:43 <dankna> :t all
19:50:44 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:50:48 <Cale> :t and
19:50:49 <lambdabot> [Bool] -> Bool
19:50:51 <dankna> :t and
19:50:52 <lambdabot> [Bool] -> Bool
19:50:56 <dh__> > and [ True, True, True]
19:50:56 <lambdabot>   True
19:51:06 <dh__> > and [ True, True, False]
19:51:07 <lambdabot>   False
19:51:21 <dh__> listAnd = and, Fjr
19:52:07 <Cale> > and []
19:52:08 <lambdabot>   True
19:52:28 <Cale> > foldr (&&) True [True, True, False]
19:52:29 <lambdabot>   False
19:52:41 <Fjr> sry, worked fine, just that is too simple :)
19:52:56 <Fjr> listAnd = and that
19:53:03 <Fjr> thats what I needed
19:53:22 <Fjr> thx ski, everyone
19:55:35 <dolio> copumpkin: I think overlap for functional dependencies could be unsound, too, but they lack some of the locality of type families required for it to work.
19:55:42 <BMeph> Fjr: First lesson of functional programming: Calculate the answer, and let the computer worry about "returning" it to the caller. ;)
19:58:02 <BMeph> Fjr: The second lesson is: "assume" the names you give for your function's arguments will "automatically" get the values they need to work.
19:58:15 <Fjr> BMeph: very nice
19:58:30 <Fjr> noting those lessons
20:01:28 <Fjr> last one guys, how about transforming a list of lists in a single integer list like listConcat :: [[Int]] -> [Int]
20:01:43 <Cale> concat
20:02:05 <Cale> Note that both 'concat' and 'and' are special cases of foldr
20:02:13 <Fjr> sure
20:02:46 <aristid> Fjr: are you making jokes? asking "i need function listX" and, totally unexpected, a function with the precise name X exists and does what you want... :P
20:04:06 * BMeph wishes one could describe the algebraic structure of "foldr" directly in the code...oh well, maybe Agda does that; I've suspicions that Maude does.\
20:04:40 <roconnor> @free foldr
20:04:41 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
20:04:46 <Cale> Every list is either the empty list [], or a nonempty list constructed by adding a first element x to another list xs, written (x:xs). What foldr f z does is to replace each (:) with the function f, and [] with z recursively throughout a list.
20:04:46 <roconnor> BMeph: you mean that?
20:04:48 <copumpkin> BMeph: in what sense?
20:05:05 <Fjr> not joking, working hard here, just that is so simple, and confused with the list - function use, I new the functions syntax to work individually but not on the list
20:05:36 <Cale> So, if we want to concatenate a list of lists, we can replace each (:) with the function which appends one list to another, (++).
20:05:49 <Cale> So  concat = foldr (++) []
20:05:59 <aristid> Fjr: here's a very nice overview of list functions: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-List.html
20:06:30 <Fjr> yeah, I'm there
20:06:40 <randomwords> I think I may be falling in love with chans..
20:07:27 <ski> @kind Control.Concurrent.Chan  -- this ?
20:07:28 <lambdabot> * -> *
20:07:29 <BMeph> copumpkin, roconnor: Yes, what Cale said (again...) :)
20:08:12 <randomwords> Yes
20:08:43 <ski> `foldr cons nil' is the canonical (unique) morphism from the initial list-algebra to the `<a,nil,cons>' one
20:09:24 <roconnor> ski: cons and nil are arbitrary function things?
20:09:32 <ski> yeah
20:09:53 <mtnviewmark> er, nil is an arbitrary value thing
20:10:10 <dolio> nil :: () -> r, obviously.
20:10:57 <Fjr> I think I got the basics,  problem was testing like concat [[1,2,3],[4,5,6]] now I got it
20:11:07 <copumpkin> in hask, does one treat r ~~ () -> r?
20:11:13 <ski> modulo currying, a `List x'-algebra `<a,nil,cons>' consists of a type `a', and two operations `nil : 1 >-> a' , `cons : x * a >-> a'
20:11:19 * ezyang  church encodings of data structures 
20:11:50 <mtnviewmark> > let n = 5 :: () -> Int in n + 2
20:11:51 <lambdabot>   *Exception: show: No overloading for function
20:12:08 <mtnviewmark> so, no   r ~/~ () -> r
20:12:12 <roconnor> ezyang: they aren't so hot
20:12:28 <ski> mtnviewmark : isomorphism is not equality
20:12:46 <dolio> I thought we were programming in Charity.
20:13:24 <mtnviewmark> true, though I thought copumpkin was essentially asking if you *could* practically substitute that in Haskell
20:13:57 <aristid> :t (.) `on` Identity
20:13:58 <lambdabot>     Couldn't match expected type `a -> a'
20:13:58 <lambdabot>            against inferred type `Identity a1'
20:13:59 <lambdabot>     In the second argument of `on', namely `Identity'
20:14:03 <Fjr> amazed
20:14:29 <aristid> :t fmap <$> Identity <*> Identity
20:14:30 <lambdabot>     Couldn't match expected type `a -> b'
20:14:30 <lambdabot>            against inferred type `Identity a1'
20:14:30 <lambdabot>     Probable cause: `Identity' is applied to too many arguments
20:14:55 <copumpkin> charity seems cute
20:15:48 <dolio> 'Values' of T are morphisms 1 -> T.
20:16:05 <dolio> And application is a special case of composition.
20:16:38 <aristid> ($) is (<*>) under Identity, it seems
20:16:58 <ski> values in a commutative group are morphisms from the integers with additive structure
20:17:00 <dolio> It's also (=<<)
20:17:50 <ski> aristid : yeah, hence it would make more sense to call `(<*>)' `(<$)', imo
20:18:10 <adu> ?
20:18:11 <aristid> :t (<$)
20:18:12 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
20:18:23 <ski> (and the integers with additive structure is *not* the terminal object in `AbGroup' !)
20:18:47 <adu> ouch, category theory hurts my head
20:19:15 <dolio> The terminal object is presumably the one-element group.
20:20:27 <ski> `import qualified Control.Applicative ((<*>)) as A; (<$) :: Applicative i => i (a -> b) -> (i a -> i b); (<$) = (A.<*>)'
20:20:35 <ski> dolio : yeah
20:21:02 <randomwords> what do I have to :set in ghci to time function calls?
20:21:03 <ski> the interesting monoidal structure on `AbGroup' here is not the cartesian one, but the tensorial one
20:21:17 <aristid> ski: why do you always use i for Applicative?
20:21:25 <ski> (and it's wrt to that that one could ask about exponentials, e..g)
20:21:34 <ski> aristid : it stands for `Idiom'
20:21:42 <aristid> huh?
20:21:49 <dolio> Idiom was the original name.
20:22:16 <ski> <http://www.macs.hw.ac.uk/~trinder/spls05/McBride.html>
20:23:11 <aristid> ski: i suppose you prefer the old name? :)
20:23:15 <ski> "Idioms: applicative programming with effects" <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.106.4830> by Conor Mcbride,Ross Paterson
20:23:35 <ski> aristid : i prefer it to `Applicative' in any case, yeah
20:23:54 <ski> (mainly because "applicative functor" is so clunky to say)
20:24:26 <mm_freak_> randomwords: :set +s
20:25:34 * applicative is thinking of changing his nick to 'idiomt'
20:25:47 * ski . o O ( cf. `f . g . h $ a' -- `foo <=< bar <=< baz <$ ia' )
20:27:51 <applicative> idiom would be a good name for monads too.  better than 'warm fuzzy'
20:28:14 <aristid> IdiomBurrito
20:28:24 * ski ponders whether that comparision is sane, here
20:28:50 <applicative> i would think better than 'workflow' too.
20:29:36 <ski> (i suppose cf. `foo a b' -- `ifoo <$ ia <$ ib' would be more relevant .. hm)
20:29:48 <ski> whence "workflow" ?
20:29:55 <aristid> applicative: i propose ContextSensitive :D
20:30:25 <BMeph> applicative: Maybe Hellenize it: "rheurge" (...hmm, not sure how to pronounce that, actually...:(
20:30:34 <ski> "Effectual" ?
20:31:52 <monochrom> Bindable
20:32:04 <monochrom> Bindish
20:32:15 * applicative favors hellenization in principle
20:32:24 <applicative> Bindable is a name for monad?
20:32:34 <monochrom> yeah
20:32:59 <pikhq> Seems Javaish.
20:33:20 <monochrom> yes, that's the problem with "plain english" names
20:33:25 <ski> <http://en.wikipedia.org/wiki/Monadic_logic>
20:33:31 <applicative> I remember someone on the list recommending "Appendable" over "Monoid" since the latter is too silly
20:33:55 <ski> well, the former is more silly ..
20:33:56 <monochrom> "append" is biased.
20:34:09 <dolio> "Bindable" doesn't mean much.
20:34:31 <monochrom> that's also the problem with "plain english" names.
20:34:38 <Fjr> good night everyone
20:34:47 <dolio> I suppose it means something in a particular view of monads, but it's not something that people are likely to know about.
20:35:35 <c_wraith> I think Idiom is actually a pretty good name.
20:36:15 <aristid> c_wraith: for monads?
20:36:16 <applicative> c_wraith so do I.  There might be other words with a similar abstraction.  "Key", as in music?
20:36:27 <c_wraith> aristid, yeah
20:36:40 <aristid> c_wraith: why not for applicative?
20:36:44 <monochrom> concerto in c# monad?!
20:36:51 <c_wraith> it's a good name for either.
20:37:03 <c_wraith> But Monads need a renaming more.
20:37:30 <monochrom> perhaps use the same name for both. add an index number to distinguish. idiom2, idiom5.
20:38:01 <applicative> idiom and super-idiom.  idiom and jargon.  argot and idiom
20:38:06 <monochrom> pharmacy actually does that sometimes :)
20:38:32 <applicative> " here, return moves the Int into the key of IO"
20:38:38 <monochrom> nutrition too. vitamin A, vitamin C...
20:38:45 <monochrom> vitamin B++
20:39:33 <c_wraith> Vitamin IO
20:40:31 * applicative likes calling monads keys... each key goes with a special emotional atmosphere.  Maybe gives confidence, IO makes him cry.
20:40:48 <monochrom> haha
20:41:36 <smadge> Can someone try to explain this "Undefined type constructor" error to me?  http://pastebin.com/8DpQc9Km
20:41:56 <applicative> another metaphor that floats around in my head is 'gear setting'.  "here, return 3 shifts the Int into the IO gear"
20:42:16 <mm_freak_> smadge: just a simple typo
20:42:21 <mm_freak_> likely
20:42:40 <monochrom> Bexp is not Bexpr :)
20:42:45 <applicative> Bexp should be Bexpr
20:43:32 <mm_freak_> i thought, it would be better for smadge to figure that out by him-/herself =)
20:43:52 <monochrom> no, these typos can never be figured out autonomously
20:44:04 <smadge> oh geez XD
20:44:15 <smadge> thanks a lot mm_freak, monochrom
20:45:08 <smadge> my mind was sticking an r at the end of the message
20:45:17 <monochrom> logic brainfarts, yes should just give a hint. visually-hard-to-distinguish typos, impossible.
20:45:38 <BMeph> How ironic (or is that poetic)...one translation for "key" is "" or "", which looks suspiciously close to "Kleisli"...
20:45:40 <applicative> no point being teacherly about typos, i agree.  Where are Bops and Cmps coming from 
20:46:12 * BMeph reflects that that looks like two translations for "key"...sorry! :)
20:46:31 <applicative> BMeph, Kleisli was very kleisly
20:46:56 <BMeph> applicative: Kleidic, even! :D
20:47:28 <applicative> Haskell is kleidikee techne
20:47:40 <smadge> applicative, just elsewhere in the file: http://pastebin.com/cvp8457j 
20:47:42 <monochrom> monad is the key
20:48:13 <applicative> kleidike, my long e didn't work.
20:48:23 <dh__> :t ZipList
20:48:24 <lambdabot> forall a. [a] -> ZipList a
20:49:03 <dh__> > ZipList [ (+1), (*2)] <*> ZipList [2]
20:49:04 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
20:49:04 <lambdabot>    arising ...
20:49:24 <applicative> smadge, Oh  I see.
20:49:56 <dh__> @src ZipList <*>
20:49:56 <lambdabot> Source not found. My brain just exploded
20:50:05 <dh__> @src <*>
20:50:06 <lambdabot> Source not found. There are some things that I just don't know.
20:50:12 <dh__> @src (<*>)
20:50:12 <lambdabot> Source not found. You untyped fool!
20:50:28 <dh__> @src ZipList (<*>)
20:50:29 <lambdabot> Source not found. Sorry.
20:50:36 <Veinor> @src (<*>) ZipList
20:50:36 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
20:50:39 <applicative> dh_ how annoying it doesn't know ZipLists.  My thoughts have just moved to the ZipList key.   I feel an opaque religious enthusiasm...
20:51:38 <dh__> > ZipList [(+)] <*> ZipList [ [1,2,3], [4,5,6]]
20:51:39 <lambdabot>   No instance for (GHC.Show.Show
20:51:39 <lambdabot>                     (Control.Applicative.Zip...
20:52:03 <dh__> ZipList [(+)] <*> ZipList  [1,2,3] <*>  [4,5,6]
20:52:20 <dh__> > ZipList [(+)] <*> ZipList  [1,2,3] <*>  ZipList [4,5,6]
20:52:21 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
20:52:21 <lambdabot>    arising ...
20:53:06 <dh__> > fmap (*2) $ ZipList  [1,2,3]
20:53:07 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
20:53:07 <lambdabot>    arising ...
20:53:34 <dh__> > take 3 $ fmap (*2) $ ZipList  [1,2,3]
20:53:34 <lambdabot>   Couldn't match expected type `[a]'
20:53:35 <lambdabot>         against inferred type `Control.A...
20:54:17 <applicative> Do you think lambdabot will learn from experience?
20:55:09 <dh__> > (+) <$> ZipList [1,2,3] <*> [4,5,6]
20:55:10 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList a'
20:55:10 <lambdabot>         agains...
20:55:11 <applicative> @vixen do you learn from experience?
20:55:11 <lambdabot> maybe. do you?
20:55:18 <monochrom> haha
20:55:30 <dh__> > (+) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
20:55:31 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
20:55:31 <lambdabot>    arising ...
20:56:04 <dh__> > getZipList $ ZipList [1,2,3]
20:56:05 <lambdabot>   [1,2,3]
20:56:18 <dh__> > getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
20:56:18 <lambdabot>   [5,7,9]
20:56:37 <applicative> How did you do that?
20:56:55 <dh__> me?
20:57:00 <applicative> I see, It won't show ziplists.  
20:57:26 <applicative> dh_. yes, I wasn't noticing that the problem was the lack of Show
20:57:57 <dh__> yep.
20:58:29 <dh__> since we have ZipList, in theory , we could remove all zipWithn , right? 
21:00:31 <applicative> zipWith (+) as bs = (+) <$> ZipList as <*> ZipList bs  ?  I don't think the public will go for it.
21:02:25 <dh__> I mean, all those zipWith , zipWith3, zipWith4 looks stupid ( because of duplication )
21:04:27 <dolio> That needs a getZipList, too.
21:04:46 <applicative> yipe yes
21:04:58 <dolio> So noisy.
21:06:23 <applicative> is this the purposes of mcbride's "ala" combinator, zipWIth (+) as bs = something like ((+) ala ZipList) as bs
21:06:48 <applicative> let me see.
21:12:30 <copumpkin> preflex: seen MyCatVerbs
21:12:31 <preflex>  MyCatVerbs was last seen on #haskell 197 days, 4 hours, 18 minutes and 59 seconds ago, saying: kmc_: I hope for your sake that you never run into a Debian maintainer in a dark alley with a sharp knife.
21:13:31 <applicative> I remember seeing a module in something on hackage, sort of an older version of Control.Applicative, where the idea is to generalize zip and zipWith
21:17:04 <applicative> It seems macbride's 'ala' is more complicated than I thought.  For composing functions through a newtype, then returning, maybe.  
21:18:53 <FunctorSalad_> from the hmk package: "The author disclaims copyright to this source. In place of a legal notice, here is a blessing: May you do good and not evil. May you find forgiveness for yourself and forgive others. May you share freely, never taking more than you give. (after the sqlite source code)"
21:23:05 <jmcarthur> :t ala
21:23:06 <lambdabot> Not in scope: `ala'
21:25:07 <applicative> I remember him using 'ala' togethere with the type class "Newtype" on Haskell Cafe.  He said 'ala' was in his private library.  
21:25:28 <applicative> I found some of the library in the Epigram source the other day http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29451#a29451
21:25:55 <applicative> At the moment, i'm not groking 'ala' though.   class Newtype is very cool though. 
21:27:31 <BMeph> applicative: Does SHE do it, too? ;)
21:27:56 <applicative> she does what you want
21:28:36 <applicative> (the module uses the she preprocessor, so there's some idiom brackets, for example.)
21:31:48 <applicative> I'm not sure how useful idiom brackets are, but they make the ' instance (Applicative f , Num n ... ) => Num f n  ' very lovely. 
21:32:33 <Axman6> how so?
21:34:04 <periodic> Something's been bugging me for two days now: typeclasses essentially are the mechanism for parametric polymorphism in functions.  Is there any way to have a polymorphic container other than algebraic data types?  I was trying to figure out a cute way with closures to have a function store types, but I only came up with infinite types that the compiler rejected.
21:36:01 <applicative> Axman6,  I was thinking of lines 154ff in  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29451#a29451
21:56:55 <lispy> periodic: type classes provide ad-hoc polymorphism not parametric polymorphism
21:57:43 <copumpkin> periodic: you can represent any ADT by a function
21:58:16 <lispy> periodic: I'm not sure what you mean by polymorphic container, but it's possible.  Maybe you want heterogenous lists?  Use an existential wrapper type.  Want the element type to be represented differently for each instance of the container?  That's what associated types get you (and functional dependencies too, IIRC)
21:58:57 <lispy> periodic: there is also HList
21:59:04 * lispy >>= sleep
21:59:43 <periodic> thanks, lispy
22:04:24 <periodic> copumpkin: I guess I never thought of creating an ADT without using the type constructors defined in a "data" declaration.
22:04:46 <periodic> What do you mean by representing it as a function?
22:04:48 <copumpkin> periodic: have you heard of church encoding?
22:05:15 <copumpkin> say you have data Nat = Zero | Suc Nat
22:05:36 <periodic> I have now...
22:05:54 <copumpkin> that can be represented as forall a. a -> (a -> a) -> a, or equivalently as (a -> a) -> (a -> a)
22:06:10 <copumpkin> that is, for every constructor, you have a parameter
22:06:23 <copumpkin> and for recursive parameters, your parameter is a function
22:06:40 <copumpkin> :t maybe
22:06:41 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:06:58 <periodic> oh, I see...
22:07:01 <periodic> sorta.
22:07:17 <periodic> I'll have to look into it some more.
22:07:32 <copumpkin> take that as Maybe a -> (b -> (a -> b) -> b)
22:07:52 <copumpkin> you can see it as taking a Maybe a and giving you a function equivalent to that Maybe a
22:08:01 <copumpkin> you can write the opposite one, too
22:08:31 <periodic> fascinating.
22:11:13 <periodic> reading up on church encoding.
22:11:53 <luite> is there some hackage package that can show graphs (Data.Graph or similar) in a window, from ghci?
22:12:01 <periodic> because to me that simply rearranging your function order allows you to take a Maybe and create a function equivelent.
22:26:39 <fengshaun> man, too much typing going on in Haskell, why the paranoia?  It seems it's _all_ about types!
23:16:00 <earthy> fengshaun: yup, it is. and that's because in Haskell it's not the paranoia
23:16:08 <earthy> it's the type system *helping* you write the code
23:17:40 <Maxdamantus> How exactly does the => construct work? can I use it in a data definition?
23:18:19 <Heffalump> in theory you can, but it's not much use, and using it in data definitions is likely to be removed from the standard soon
23:18:29 <Maxdamantus> data Foo = (String a) => Bar a
23:18:30 <Heffalump> (that's the syntax data Foo a = Ord a => Foo a
23:18:39 <Maxdamantus> Ah.
23:18:50 <Heffalump> you can use it in GADT syntax or with existential types where it's more useful
23:22:13 <dolio> That isn't the H98 syntax.
23:22:20 <dolio> data Ord a => Foo a = Foo a
23:23:55 <wioux> maxdamantus: better to just use it in any function where it's relevant
23:24:24 <Heffalump> oops, sorry :-)
23:24:30 <dolio> The one use (that I can think of) for that syntax died with H98, though.
23:24:32 <Heffalump> The one I said is closer to the existential syntax
23:25:51 <copumpkin> dolio: what one use was that?
23:26:16 <dolio> data Eval a => Foo a = Foo !a
23:26:27 <copumpkin> oh
23:27:28 <dolio> The constraint should genuinely be on the constructor in that case.
23:59:44 <periodic> copumpkin: Existential data types and similar constructs prooved useful to me.  http://www.haskell.org/haskellwiki/Existential_type basically describes what I was trying to solve.
