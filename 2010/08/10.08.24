00:00:13 <ddarius> Axman6: I believe the fields still have to be in the same order so your first (complete) Foo example shouldn't be accepted.
00:00:37 <Axman6> ddarius: huh?
00:01:35 <aavogt> ddarius: you mean this should be rejected: data Foo t = A { a,b :: t } | B { b,a :: t }
00:01:41 <ddarius> Yes.
00:01:50 <aavogt> it's not
00:01:51 <Axman6> what an odd limitation
00:02:01 <Axman6> i can't see why that would be rejected
00:02:39 <aavogt> they have to be the same type for the accessor functions to make sense
00:04:57 <Axman6> so, would ayone care to take a look at this for me, and give me some tips on how to make it more efficient? http://codepad.org/s8Bbz1iF
00:05:02 <ksf> I find my professionality in haskell is very well expressed by the fact that I write ugly code, at a very high level.
00:06:15 <ksf> those keywords read let where let do let let if the else let let let let in do in do
00:06:32 <ksf> oh, missed two dos.
00:07:11 <ksf> but then, TH seems to inevitably lead to ugly code.
00:07:35 <ksf> no sign wheresoever of that nice, organic lisp look.
00:26:24 <lispy> ?src sequence_
00:26:24 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
00:26:45 <lispy> > sequnce_ [f, g, h] :: m Expr
00:26:46 <lambdabot>   Not in scope: `sequnce_'
00:26:51 <lispy> > sequence_ [f, g, h] :: m Expr
00:26:51 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
00:26:52 <lambdabot>         against inferred ...
00:27:24 <lispy> > foldr (>>) (return ()) ([a, b, c] :: Expr)
00:27:25 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
00:27:25 <lambdabot>         against inferred ...
00:27:44 <lispy> > foldr (>>) (return ()) ([a, b, c] :: Expr) :: [Expr]
00:27:44 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
00:27:44 <lambdabot>         against inferred ...
00:28:08 <lispy> > foldr (+) 0 [a,b,c] :: Expr
00:28:08 <lambdabot>   a + (b + (c + 0))
00:52:24 <Maxdamantus> When people pattern match against (x:xs) is the tail called "xs" because it's the plural of x?
00:52:50 <dolio> Yes.
00:53:13 <harlekin> conal, hey. You there?
00:53:48 <conal> harlekin: yep
00:54:14 <harlekin> conal, hi. I was wondering the reactive mailing list was still active. I sent a message but neither got a reply nor can I find it in the archives.
00:54:53 <conal> harlekin: wow.  i'm not aware of it being down.  looking for the last message i got. ...
00:55:25 <etpace> @hoogle (a -> a -> Bool) -> (a -> a -> a) -> [a] -> [a]
00:55:26 <lambdabot> No results found
00:55:45 <harlekin> conal, I sent my message on August 20, "whenE uses much memory."
00:56:04 <ksf> it's working, at all?
00:56:20 <harlekin> conal, reactive@haskell.org is the right address, isn't it?
00:56:57 <conal> harlekin: yes, that's the right address.  the last spam-filtered message I see is 7 hours old.  if you can give me a specific search string, i'll look through the spam for your note.
00:57:56 <harlekin> conal, the topic is "whenE uses much memory". You'll find the words tower defense, creep, whenE in there. Does that help?
00:58:00 <conal> harlekin: are you Sheila wanting my help in transferring 2.7 million USD from Iraq?
00:58:14 <elbar> ^^
00:58:16 <harlekin> conal, :D
00:58:22 <conal> hey, i won the yahoo lottery!
00:58:45 <Axman6> aww man, i even bought like 100 tickets!
00:58:57 <conal> oh, hey! "whenE uses much memory".
00:59:02 <conal> harlekin: is that one yours?
00:59:08 <harlekin> conal, it is.
00:59:34 <conal> wow.  sheila is really into me.  persistent!
01:00:11 <conal> harlekin: i'll see if i can rescue your message.
01:00:26 <harlekin> conal, thank you.
01:01:08 <conal> :)
01:02:28 <harlekin> conal, also is reactive still active? It seems to be very unstable right now. How can one help to improve it?
01:03:05 <dolio> It's re-active!
01:03:08 <dolio> Bam!
01:03:12 <conal> :)
01:03:46 * hackagebot cmdlib 0.2.1 - a library for command line parsing & online help  http://hackage.haskell.org/package/cmdlib-0.2.1 (PetrRockai)
01:03:51 <Axman6> someone needs to reactivate reactive!
01:04:01 <conal> :)
01:04:17 <conal> harlekin: reactive has been in a state of neglect for the last 18 months.  i shifted my focus to functional gpu programming and iPhone programming (and combining the two).  i may get back to it soonish.
01:04:54 <harlekin> conal, i read about a ghc rts bug somewhere. Is reactive broken mostly because of ghc being broken?
01:04:58 <conal> harlekin: there appears to be some subtle space & time leaks, and i was unable to trace them down last time i tried.
01:05:06 <Maxdamantus> Can I repeat an action in a monad, and get a list of values that were outputted..? I can't think monadically enough :\
01:05:16 <Axman6> :t sequence
01:05:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
01:05:32 <c_wraith> :t replicateM
01:05:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
01:05:34 <conal> harlekin: sadly, i still don't know.  and i got pretty discouraged in trying to find out what was going on.
01:05:39 <Axman6> though, you shoudl see if you can implement sequence to see if you understand monads
01:06:18 <ksf> btw, now that solaris is being forked might be the perfect opportunity to step in and bring haskell to the administration-level of a distro.
01:06:38 <etpace> @pl (\f -> f 1 == f 2)
01:06:38 <lambdabot> liftM2 (==) ($ 1) ($ 2)
01:06:51 <Maxdamantus> Hmm.. a <- replicateM getLine .. maybe .. /me trie
01:06:56 <ddarius> ksf: You mean like Linspire?
01:06:56 <Maxdamantus> er
01:07:03 <ksf> ...considering that we already have a dep resolving engine that's vastly more powerful than what usual package managers do.
01:07:08 <conal> etpace: better: use liftA2 in place of liftM2. 
01:07:14 <ksf> ddarius, http://www.illumos.org/
01:07:34 <conal> etpace: i don't think lambdabot knows Applicative, but you can translate its advice.
01:07:34 <ksf> oracle has indicated that they don't give a damn about anything the community wants.
01:08:17 <Maxdamantus> That works, thanks.
01:08:22 <Saizan> you mean the one in cabal-install? if that's true i don't want to look at other package managers :)
01:08:56 <ksf> ...those don't have to deal with diamond dependencies and such.
01:09:09 <ddarius> ksf: http://cufp.galois.com/2006/abstracts.html#CliffordBeshers
01:09:21 <ksf> afaiu cabal-install is quite close to the theoretical opitmum for what it does.
01:09:39 <ksf> ...that is, without actually taking NP-time for an NP-complete problem.
01:10:10 <ksf> yes, I've heard about linspire, but linspire failed, for different reasons.
01:10:16 <ksf> I think basically because there's debian.
01:10:21 <ksf> er ubuntu.
01:10:29 <ksf> and ubunto fails to fail because of debian.
01:11:02 <ksf> then there's such little gems as fquery for gentoo, which is just about 100x as fast as equery.
01:11:33 <ksf> ...even though much of the stuff it does should be disk-bound.
01:13:34 <conal> harlekin: just emailed you.
01:14:07 <harlekin> conal, sure. I re-send it.
01:14:35 <conal> thx
01:14:38 <harlekin> conal, done.
01:15:12 <conal> urg.  spam-filted again. :(  i wonder why.
01:17:26 <conal> oh, oops.  i forgot to fix the subject.  re-sending.
01:17:54 <harlekin> conal, thank you for forwarding it to the ML.
01:18:00 <DamienCassou> can somebody help me with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29402#a29402 please?
01:18:30 <DamienCassou> I don't understand the typing problem in the first line of privDisplayDices
01:18:43 <conal> harlekin: you're welcome.  i just re-forwarded with the original subject
01:20:24 <harlekin> conal, could it be an issue that I registered with @gmail.com and now the message is apparently sent with @googlemail.com?
01:22:08 <conal> harlekin: hm.  sounds plausible.  speaking from ignorance.
01:23:11 <harlekin> conal, I just delete my account and re-register then.
01:23:28 <conal> ok
01:24:23 <elbar> package regex-compat-0.93.1 is broken due to missing package
01:24:23 <elbar> regex-posix-0.94.2-2a05d33280324a8e66516c20659c002c
01:24:36 <elbar> i hate when stuff silently break ...
01:26:16 <elbar> although the version numbering seems a bit odd
01:28:36 <ksf> cabal doesn't uninstall stuff without you explicitly telling it to.
01:28:52 <lispy> elbar: cabal install --reinstall regex-compat-0.93.1 #ought to fix it
01:30:15 <elbar> yeah...allready reinstalled it (with using emerge tho :)
01:30:34 <elbar> and all that only to test fquery ;)
01:31:39 <DamienCassou> can some of you explain me the typing problem here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29402#a29402?
01:32:19 <Saizan> elbar: that might be because of shadowing
01:32:30 <Saizan> elbar: ghc-pkg check?
01:32:51 <ksf> ghc is detecting your bad spelling.
01:33:08 <elbar> oh...many problems
01:33:24 <elbar> i def. need to remember that command
01:33:32 <ksf> there's an ebuild, btw.
01:34:00 <elbar> for fquery?
01:34:22 <ksf> yep. in the overlay
01:34:35 <ddarius> cabal uninstalls stuff?
01:34:46 <elbar> yeah...allready installed it =)
01:35:00 <ksf> cabal upgrade might
01:35:02 <int-e> @hoogle Dist f m -> (a -> m (f a)) -> a -> m (FixF f)
01:35:02 <lambdabot> Warning: Unknown type Dist
01:35:03 <lambdabot> No results found
01:35:08 <ksf> ...and even when it doesn't it's broken.
01:45:02 <elbar> 'ghc-pkg check' reports no problems anymore =) thx Saizan 
01:45:19 <elbar> allways better to have a consistent system 
01:45:34 <Maxdamantus> Hmm.. Data.Binary.Get doesn't seem to have anything for signed integers.. if I need to interpret a 16bit signed (2's comp) little-endian integer, do I need to do the sign interpretation myself?
01:50:25 <kremsera> hi
01:51:05 <kremsera> i cant get good performance with haskell arrays
01:51:25 <Botje> are you using unboxed arrays?
01:51:34 <kremsera> just initializing an array of size 8MB with a constant takes more than 2 seconds
01:51:44 <kremsera> yes unboxed array with unsafeWrite
01:52:19 <luite> are you using compile code, with optimization?
01:52:41 <kremsera> just "ghc -o a.out test.hs"
01:52:55 <luite> try adding -O2
01:53:20 <kremsera> wow
01:53:21 <kremsera> lol
01:53:28 <kremsera> now *that* made a difference
01:53:46 <kremsera> now its about 0.055seconds :D
01:53:52 <kremsera> thank you!
01:53:55 <ksf> -O0 is optimised for compile speed.
01:54:14 <ksf> well, it does the minimum necessary to get assembly code out of your source.
01:54:31 <kremsera> seems like the wrong default for me ;)
01:55:12 <ksf> well, _I_ don't tend to use 8mb arrays in a compile-edit cycle.
01:55:34 <Saizan> ddarius, ksf: no, it doesn't uninstall, it can overwrite an earlier installation of the same version of the same package
01:56:02 <ksf> edit-compile cycle is misleading when talking about haskell. it's the typecheckfail-edit cylce.
01:56:12 <ksf> Saizan, but those should be slotted.
01:56:33 <ksf> ...thus those incomprehensible hash numbers after the package version.
01:56:35 <kremsera> yeah thats right
01:57:12 <kremsera> typecheckfail-edit is much better than the (compile, it doesnt run, fix it) cycle of c++
01:57:49 <Saizan> ksf: it's a bit complicated :)
01:58:16 <Saizan> ksf: currently you can register only one of them for each db
01:58:29 <Saizan> ksf: the second registration overwrites the former
02:02:40 <Entroacceptor> mmh, can you tell ghc to only typecheck, not doing the compile?
02:05:21 <ksf> you can use ghci
02:05:36 <ksf> ...which only compiles to bytecode
02:06:33 <ksf> and there might be some way to tell ghc to stop after some stage, you'd have to look in the obscure corner of the docs.
02:07:28 <m3ga> Error message "Bindings containing unlifted types must use an outermost bang pattern" in code "{ i = word2Int# ((high `uncheckedShiftL#` 8#) `or#` low) }"
02:07:36 <m3ga> can someone suggest a fix?
02:07:42 <ksf> yes.
02:07:49 <ksf> use an outermost bang pattern.
02:07:58 <ksf> if that's alex-generated code, poke the maintainer.
02:08:46 <m3ga> well i'm looking to fix it and send a patch. i've already logged a bug
02:09:02 <ksf> ...I think it should compile with !i
02:09:28 <ksf> another possibility would be to get rid of those #-types
02:09:42 <ksf> ...ghc got way better at doing such stuff since the time alex was written.
02:10:43 <ksf> imnsho, alex is a fossil.
02:10:45 <fasta> Why do unboxed types exist in the first place? By that I mean: did anyone think really hard whether you actually need them?
02:10:55 <ksf> I guess spj did.
02:11:09 <ksf> anyway, the answer is performance.
02:11:22 <ksf> aiding the strictness analyser etc.
02:11:34 <fasta> ksf, I have the impression that for the kinds of loops people typically write, termination is trivial. 
02:12:05 <fasta> ksf, another design could have been that you have to prove your loops terminate. 
02:12:07 <ksf> well, I hardly ever need strictness annotations.
02:12:40 <ksf> that won't make strictness analysing decidable, would it?
02:12:41 <ddarius> Unboxed types were added so that the compiler writers could write that type of transformation as a source-to-source pass.
02:13:03 <Saizan> i imagine unboxed types are needed/handy simply for the sake of defining types like Int (the boxed one) from within something more haskell-like
02:13:16 <ddarius> Also, unboxed types are -old-.
02:13:32 <fasta> ddarius, what has age got to do with it?
02:16:22 <fasta> I see no reference to a paper here, so probably there is no good reason. http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html
02:16:25 <ddarius> They were in GHC, I believe since the very beginning, verifiably, at least, since 0.29.  There wasn't a whole lot of experience at the time on whether they were a good idea or not.
02:16:38 <fasta> That sounds plausible.
02:17:28 <ddarius> It does seem that they were a good idea, but, relatively recently (like three years ago or so) GHC got good enough that it's almost never in your interest to explicitly use unboxed types.
02:18:02 <fasta> ddarius, isn't the shootout still full of ###?
02:18:24 <ddarius> fasta: Yes.  People rarely go through and rewrite the old code to be prettier.
02:18:37 <ddarius> When people do they usually find that they can remove all unboxing.
02:20:13 <fasta> I also wonder what kind of applications actually need all this optimization, since most interesting algorithms have some kind of memory slow-down anyway. 
02:21:02 <fasta> Moving bits through a pipe is one application I suppose, but well, who wants to do that? ;)
02:22:23 <Saizan> i imagine anything numerical is going to be very slow if you can't keep operands in registers
02:22:36 <Jafet> C still has inline and register keywords
02:22:48 <Jafet> No one uses them anymore, since compilers have gotten better.
02:23:13 <p_l> Jafet: they are still used, afaik
02:23:21 <p_l> but not in "normal" code
02:23:36 <p_l> kernel mode and embedded stuff, sure
02:24:32 <Adamant> also some crypto stuff, IIRC
02:25:23 <kremsera> also when using cuda you need all those c-keywords again 
02:25:35 <Jafet> Well, only because no one's gone through all the old code and removed them.
02:26:03 <Jafet> (Or embedded device compilers suck -- but that's offtopic here, isn't it?)
02:26:04 <kremsera> no because sometimes compilers are just not smarter than you ;)
02:26:32 <fasta> It's more that compilers are less complete.
02:27:00 <Itkovian> Any suggestions on how to get cabal to buld and install mtl on the GHC head?
02:27:00 <Itkovian> Control/Monad/Error.hs:76:10:
02:27:00 <Itkovian>     Duplicate instance declarations:
02:27:00 <Itkovian>       instance Error e => Monad (Either e)
02:27:26 * ddarius wishes he could write something like the Agda type {x : T}(y : F x){z : G y} in Twelf.
02:28:26 * ddarius would say "unsoundness" is why humans can often beat compilers.
02:28:30 <fasta> ddarius, any particular reason you use Twelf and not one of the others?
02:28:56 <Saizan> Itkovian: remove that instance?:)
02:32:57 <ddarius> fasta: I suspect it fits the problem I'm working on best and is fairly lightweight.
02:34:14 <fasta> ddarius, it is a programming problem or a real math problem? 
02:34:48 <aRcatan> does a Twitter library for Haskell exist that suppors OAuth authentication?
02:36:05 <ddarius> It's a modeling a logic problem which is what the LF family was designed to do.
02:36:19 <aRcatan> i guess i should just rip off jgoerzen's twidge.
02:39:29 <ksf> how to call a space-less string, if not word because that's taken (for hysterical raisins)?
02:41:14 <aRcatan> hmm, twidge is GPL.
02:41:32 <ksf> "term" or "lexeme" is the only useful stuff thesaurus.com spits out.
02:41:53 <ksf> so I guess I'm going with token, as that's cromulent for lexeme.
02:42:40 <int-e> I have a question about category-extras: I'm looking for a monadic version of ana, like thise one, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29403 ... is there an encoding trick that I'm missing that makes its implementation simpler?
02:43:20 <DamienCassou> I'm using haskell-mode for emacs and ghci, what is the best way to see the source code of a function?
02:43:21 <Itkovian> dons: Any suggestions, as MTL is your puppy, I think. And Criterion relies on it. 
02:44:42 <ManateeLazyCat> ManateeIrcClient: Hello, my boy....
02:50:16 <madhouse> hello
02:50:23 <madhouse> trying to get a type sig for this: http://pastie.org/1111950
02:50:39 <madhouse> what should the type sig be for fact?
02:50:47 <madhouse> I want to run this from the command line
02:51:04 <ben_m> @type interact
02:51:05 <lambdabot> (String -> String) -> IO ()
02:52:53 <madhouse> so, I have to change the type sig of fact to what?
02:52:57 <madhouse> sorry, haskell newbie
02:53:04 <Lemmih> madhouse: interact (unlines . map (show . fact . read) . lines)
02:53:09 <ben_m> The type of fact is inferred automatically, you don't have to change it.
02:53:14 <ksf> fact is Integer -> Integer
02:53:20 <ben_m> But you'll have to prepare the input like Lemmih just did.
02:53:32 <ben_m> And then change the return value back to a string.
02:53:48 <madhouse> I see
02:54:05 <madhouse> what if I choose not to use interact 
02:54:14 <Lemmih> madhouse: Then use ghci.
02:54:18 <madhouse> a do instead
02:54:38 <m3ga> ksf: thanks, patch submitted to bug tracker
02:54:49 <ben_m> madhouse: For example, yes.
02:54:56 <Lemmih> ?src interact
02:54:56 <lambdabot> interact f = do s <- getContents; putStr (f s)
02:55:14 <Lemmih> madhouse: ^^ That's how 'interact' is defined.
02:55:22 <madhouse> I see
02:56:28 <ksf> text-based protocols are just wrong.
02:57:03 <ksf> a gazillion different syntaxen and character classes, for no real reason at all.
02:57:59 <ksf> a proper protocol should know sum and product types, integers, naturals, both variable-length, possibly floats, ascii strings, utf8 data, and binary blobs.
02:59:08 <ksf> ...those ascii strings for identifiers and other cases where you don't want people to wrek havoc with insane unicode-stuff.
03:07:12 <patch-tag> can you do a data declaration, using record syntax, but have the constructor be strict in all the arguments?
03:08:09 <AmunRa> As a learning excercise, I'd like to replicate a domain specific expression language in Haskell. To do this I've seen i could take the Alex&Happy route or alternative have a go at Parsec.
03:08:15 <Lemmih> patch-tag: As in: data T = C { field1 :: !Int, field2 :: !Char }?
03:08:20 <AmunRa> Which approach is more suitable? Comments and opinions welcome.
03:08:20 <patch-tag> yep
03:08:23 <patch-tag> thanks lemmih
03:08:42 <ksf> AmunRa, neither?
03:08:45 <ksf> do an edsl
03:09:36 <ksf> also, have a look at "write yourself a scheme in 48 hours"
03:09:57 <Lemmih> AmunRa: Parsec is easier to use. Happy generates faster parsers.
03:14:04 <AmunRa> Lemmih: thanks, ksf: neither? (48 hours scheme guide uses Parsec)
03:14:33 <ksf> you can start without a parser and use haskell syntax to write your terms
03:15:30 <ksf> there's many languages that leave it at that, e.g. atom.
03:15:56 <ksf> ...basically, you get a very powerful and elegant metaprogramming language for free.
03:15:58 <Maxdamantus> Hmm.. This seems unnecessarily tedious.. trying to create a list of outputs from a constructer given a list of elements for each argument in the constructor (12 arguments)
03:16:32 <ksf> Maxdamantus, template haskell?
03:16:32 <hape__> ksf: that is an interesting idea.
03:17:08 <Maxdamantus> blah (a:as) (b:bs) (c:cs) .. = Blah a b c .. : blah as bs cs ..; blah [] _ _ .. = []
03:17:09 <hape__> ksf. i meant haskell built-in terms
03:17:11 <fasta> hape__, SICP demonstrates this idea for Scheme about 20 years ago, or so :)
03:17:14 <Maxdamantus> Dunno.. what's templace Haskell?
03:17:17 * Maxdamantus Googles
03:17:47 <hape__> fasta:  :-)
03:17:59 <ManateeLazyCat> Maxdamantus: Template Haskell is generate code in compile time with template code you given
03:18:12 <Maxdamantus> Oh.
03:18:24 <Maxdamantus> Sort of like CPP to C?
03:18:27 <hape__> fasta: even it is 20 years old it is not yet common sense in the real world.
03:18:33 <Maxdamantus> Hmm.. but apparently you write it in Haskell.
03:18:42 <ksf> also, have a look at http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
03:19:05 <fasta> hape__, the real world is completely inconsistent for most people, so that doesn't surprise me. 
03:19:07 <ManateeLazyCat> Maxdamantus: Example, you have many duplicate code, you can write template, then let TH generate those duplicate code in compile time, then link generate code to object....
03:19:12 <Maxdamantus> Meh, maybe I'll just do something with lots of zips
03:19:45 * ManateeLazyCat I'm collect data for my irc client, please bla bla to me... thanks! :)
03:20:17 <fasta> ManateeLazyCat, there is a test channel for that purpose. #test
03:20:33 <Maxdamantus> zip ((zip3 a b c) (zip3 d e f)) ((zip3 g h i) (zip3 j k l))
03:20:42 <ManateeLazyCat> fasta: I need busy channel.... :)
03:20:49 <fasta> Maxdamantus, if you need to do that, you probably do something wrong.
03:20:54 <ManateeLazyCat> Maxdamantus: Simple, TH is use Haskell write Haskell....
03:21:08 <hape__> fasta: :-)
03:21:22 <Maxdamantus> Possibly.
03:21:34 <Maxdamantus> I'm interpreting a really horrible file format.
03:21:58 <Maxdamantus> Where instead of storing frames sequentiall, it stores all the types that are part of the frames separately.
03:22:09 <ManateeLazyCat> fasta: Thanks for #test....
03:23:01 <fasta> Maxdamantus, and you do not use records?
03:23:09 <AmunRa> that's a cool blog-post :-) I'll go down the parsec route as it seems the one with highest probability of completion.. (besides.. I do want to compile a string)
03:23:23 <Maxdamantus> Yes, but not yet O_o
03:23:25 <Maxdamantus> how do they help?
03:23:45 <fasta> Maxdamantus, I suggest reading a few books before writing production code. 
03:24:08 <Maxdamantus> Hm. It's not production code.
03:24:43 <fasta> You are parsing a complicated format for fun? OK, that's A New Kind Of Fun. 
03:24:59 <ksf> fasta, please don't remind me of that.
03:25:00 <Maxdamantus> Heh. Once I get the parsing done it should be fun.
03:25:03 <ksf> it's painful enough as it is.
03:25:33 <ksf> (although I'm implementing that darn protocol as a step in obsoleting it)
03:25:43 <Maxdamantus> It's not a complicated format, just a ridiculous one.
03:25:44 <fasta> ksf, heh. I suppose you read all the literature before his 1200 page tree killer?
03:25:54 <Maxdamantus> It's actually a replay file for a game
03:25:58 <ksf> er, whose?
03:26:01 <lantti> fasta: There is never time to read before writing production code :)
03:26:04 <ksf> which tree killer?
03:26:26 <fasta> ksf, I assume you can also buy a hardcopy for NKS.
03:26:43 <Maxdamantus> But for some reason, rather than having each frame sequentially and having: posx_1 posy_1 posx_2 posy_2 .. it has: posx_1 .. posx_n posy_1 .. posy_n
03:27:04 <ksf> why should I be interested in anything wolfram does?
03:27:08 <fasta> If he wants to claim he is the best guy in the world and invented everything that was and will be, well, let him. 
03:27:22 <fasta> ksf, I don't know; I didn't say I was or that you were. 
03:27:36 <ksf> no. you were attempting to confuse me.
03:27:44 <ksf> and succeeded. damn you.
03:40:37 <ksf> the most insane about this syntax is that not even space-separated strings may use tabs as those could be a separator for a subsequent argument.
03:40:41 <benmachine> Maxdamantus: are you aware of <$> and <*>?
03:41:18 <ksf> ...and the most worrying is that all other parsers and generators are likely hand-written and thus may generate ad-hoc irregularities that developed into perfect bug-compatiblity.
03:41:32 <benmachine> > (,,,,) <$> [1 .. 5] <*> [2 .. 6] <*> [6 .. 10] <*> [9 .. 13] <*> [9000 .. 9004]
03:41:33 <lambdabot>   [(1,2,6,9,9000),(1,2,6,9,9001),(1,2,6,9,9002),(1,2,6,9,9003),(1,2,6,9,9004)...
03:42:00 <ksf> never trust a syntax meant for computer consumption that is longer than 10 lines.
03:42:51 <ksf> it really seems some developers value telnet debuggability more than sanity.
03:44:19 <aristid> how does the basic module work? oO
03:44:35 <aristid> ksf: telnet debuggability is teh awesome
03:44:44 <ksf> start by writing an insane instance for numbers.
03:44:58 <aristid> ok! insane instance for numbers *check*
03:45:08 <ksf> I don't give a damn, my protocol is going to be binary, at least bencoding-like.
03:45:19 <ksf> if you want a cli, it's easy to provide
03:45:37 <ksf> ...in fact, that's most likely going to be the first interface as it's the easiest.
03:45:38 <aristid> hmm i think it's much clearer how BASIC works now. probably a lot of other hacks too, but that explains the most confusing part
03:46:14 <aristid> ksf: if i were to design a wire protocol, i think i would start with JSON
03:46:30 <ksf> I'm starting off ebml
03:47:06 <ksf> ...that is, stick to the basic structure, but change the variable integers not to require as much bit-shifting.
03:47:25 <luite> is there an ebml decoder for haskell?
03:47:28 <ksf> use an encoding that gets you the right number by simply masking away the high bits.
03:47:37 <ksf> I think I once started one.
03:47:48 <luite> a high performance one?
03:47:48 <ksf> yep.
03:47:55 <ksf> I don't think so.
03:48:06 <luite> oh I thought that was the point of the format :)
03:49:17 <aristid> ksf: there is more than just telnet to justify plain text protocols... it makes wireshark analysis easier too
03:50:44 <ksf> I think I stopped somewhere because I was both pissed at the lacking formality of dtds, errors in the matroska spec and because I didn't understand iteratees well enough.
03:50:57 <ksf> why should I care about wireshark?
03:51:11 <ksf> the handshake is going to include room for diffie-helman.
03:52:12 <ksf> something like "send 0 as your choice if you don't support or don't want to encrypt"
03:53:09 <aristid> ksf: if you don't care about wireshark, OK. i do.
03:54:01 <fasta> aristid, wireshark could also adapt to the protocol. 
03:54:37 <aristid> fasta: sure, but that requires work :)
03:54:44 <ksf> especially such a regular one.
03:54:51 <fasta> aristid, only if you care about wireshark ;)
03:55:12 <Maxdamantus> benmachine: oh, crazy.
03:55:19 <aristid> fasta: why not make it easier for everybody? :)
03:55:23 <ksf> well, regular as in data = tag data.
03:55:39 <ksf> because text protocols are a bugger to handle programmatically.
03:55:48 <ksf> HTTP, for example, is utter pain.
03:55:55 <The_Haskellrod_o> a bloody bugger at that!
03:56:25 <The_Haskellrod_o> carry on carry on ..
03:56:25 <ksf> what did they smoke as they decided that one attribute could span several lines if indented such-and-such?
03:56:35 <ksf> bencoding is sane, at least, and readable.
03:56:57 <ksf> but then it's not far from a proper binary encoding, which is equally readable with proper software.
03:57:03 <fasta> aristid, binary protocols are more efficient, so there is no solution which is most easy for everyone. 
03:57:34 <aristid> fasta: it's a trade-off
03:57:53 <ksf> I decided to go for a binary wire protocol, btw, not a completely binary protocol.
03:58:03 <aristid> it's much like choosing Haskell over C. maybe you could make a more efficient program in C, but you'd rather use Haskell anyways :P
03:58:15 <fasta> aristid, yes
03:58:17 <ksf> you will be able to negotiate dtds that include human-readable identifiers over it.
03:58:19 <Maxdamantus> :t (<*>)
03:58:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:58:27 <ksf> ...in fact, that's how the handshake works, basically.
03:58:53 <aristid> @src [] (<*>)
03:58:53 <lambdabot> (<*>) = ap
03:59:14 <aristid> hmm somehow was hoping that (<*>) on lists has a more fundamental operation
03:59:29 <Maxdamantus> Control.Applicative
03:59:44 <aristid> Maxdamantus: i know, that's the module name
04:00:02 <ksf> add channel muxing and a notion of paths and references, and you've got yourself a fine base layer for all the application-layer ad-hocery you will ever need.
04:00:14 <aristid> Data.Time.LocalTime.TimeZone.Series <- terribly long module name :/
04:00:34 <ksf> we're still lacking Data.Time.Calendar.Discordian
04:00:38 <Maxdamantus> Yeah, just needed to find that out.
04:00:47 <Maxdamantus> I think the bot has something to directly get that.
04:00:53 <aristid> ksf: a clear deficiency
04:01:01 <aristid> @hoogle (<*>)
04:01:01 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
04:01:02 <ksf> indeed.
04:01:02 <Maxdamantus> @hoogle <*>
04:01:02 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
04:01:11 <ksf> after all, every linux comes with ddate preinstalled.
04:01:18 <Maxdamantus> Cool.
04:01:33 <aristid> ksf: indeed.
04:01:46 <ksf> it's one of the most brain-wrecking source codes I've ever seen.
04:01:49 <aristid> Today is Sweetmorn, the 17th day of Bureaucracy in the YOLD 3176
04:02:56 <The_Haskellrod_o> this is the geekiest chatroom :p , I like it !
04:04:31 <Maxdamantus> @src ap
04:04:31 <lambdabot> ap = liftM2 id
04:04:36 <Maxdamantus> :\
04:04:42 <Maxdamantus> @src liftM2
04:04:43 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:05:00 <pastorn> if i have a function definition, and i want to print it
04:05:06 <aristid> Maxdamantus:  so ap f m1 m2 = do { x1 <- m1 ; x2 <- m2; return (x1 x2) }
04:05:08 <pastorn> (the whole definition)
04:05:12 <pastorn> who do i go about that?
04:05:19 <aristid> @where hpaste
04:05:19 <lambdabot> http://hpaste.org/
04:05:51 <Maxdamantus> Hmm.. I see.
04:06:05 <pastorn> is this something i should use template haskell for?
04:06:07 <zygoloid> "This mechanism works similarly to the format string mechanism of date(1), only almost completely differently."
04:06:23 <zygoloid> Today is Sweetmorn, the day I learn about ddate
04:06:52 <Maxdamantus> Are alot of these smart minimal pieces of code mainly from lambda calculus, or was most of the way of thinking of it invented at the same time as FP?
04:06:58 <zygoloid> pastorn: when you say print it, do you mean File>Print in your editor? ;-)
04:07:34 <aristid> @undo ap f m1 m2 = do { x1 <- m1 ; x2 <- m2; return (x1 x2) }
04:07:34 <lambdabot> ap f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (x1 x2)
04:07:42 <The_Haskellrod_o> more FP than LC 
04:07:44 <pastorn> zygoloid: f x y = x + y ==> show f == "f x y = x + y"
04:07:50 <aristid> Maxdamantus: there you have it undo-d :)
04:08:08 <zygoloid> pastorn: do you want it formatted exactly as in your source file?
04:08:17 <Maxdamantus> O_o
04:08:19 <zygoloid> (would a pretty-printed form be enough?)
04:08:23 <Maxdamantus> Oh right.
04:08:27 <pastorn> zygoloid: yes
04:08:34 <pastorn> zygoloid: doesn't matter
04:08:40 <aristid> Maxdamantus: now depending on your Monad, you can replace (>>=) and return by their instances to see what's going on
04:08:46 <pastorn> i just want the variables to have the same name
04:09:19 <zygoloid> pastorn: yeah, you can use TH for that. but you can't use 'show f', since there's no way to annotate the string onto something of type a -> b
04:09:24 <Maxdamantus> :t <$>
04:09:25 <lambdabot> parse error on input `<$>'
04:09:31 <pastorn> zygoloid: figured that :/
04:09:34 <Maxdamantus> :t (<$>)
04:09:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:09:38 <pastorn> zygoloid: would it be hard to do?
04:10:10 <Maxdamantus> Hmm.. So where's the monadic stuff coming from?
04:10:30 <zygoloid> pastorn: should be pretty easy. you could replace teh definition of f with something like: $( genShow [d| f x y = x + y |] ), where genShow is some imported TH function
04:10:38 <aristid> Maxdamantus: (<$>) = fmap. also Control.Applicative
04:10:40 <Maxdamantus> Oh, the <*>s will probably be right-assosciative
04:10:44 <pastorn> cool :)
04:10:56 <aristid> Maxdamantus: no.
04:11:14 <aristid> infixl 4 <$>
04:11:22 <aristid> infixl 4 <*>
04:11:37 <Maxdamantus> Oh. O_o
04:11:53 <Maxdamantus> Meh, I think I'll wait a while before trying to fully comprehend it.
04:11:54 <lambdor> i'm using Miktex/Texniccenter on Windows and cabal installed lhs2tex. how do i include it in texniccenter, to generate pretty Haskell code?
04:13:36 <aristid> > (,) <$> [1..5] <*> [1..5]
04:13:37 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
04:13:51 <aristid> > (,) `liftM`[1..5] `ap` [1..5]
04:13:52 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
04:14:12 <Maxdamantus> Yep, I can understand that much.
04:14:19 <aristid> Maxdamantus: now take the monadic version as a starting point and replace lfitM and ap by list operations
04:14:28 <Maxdamantus> I could probably get how all of it worked if I concerntrated on it.
04:16:03 <aristid> Maxdamantus: yeah you need to actually think when doing haskell ;)
04:17:04 <Maxdamantus> Wonder how long it would take someone to implement their own Control.*
04:17:05 <The_Haskellrod_o> Think blue!
04:17:23 <The_Haskellrod_o> : P
04:18:03 <The_Haskellrod_o> ..depends ys
04:20:00 <Maxdamantus> > (,) `fmap` [1..5] `ap` [1..5]
04:20:01 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
04:21:03 <aristid> @src [] fmap
04:21:03 <lambdabot> fmap = map
04:21:12 <Maxdamantus> Is there a difference between fmap and liftM?
04:21:16 <aristid> no
04:21:21 <Maxdamantus> Oh.
04:21:27 <aristid> not for lists
04:21:45 <aristid> in general fmap = liftM for any _well-behaved_ monad
04:21:57 <aristid> the type system just can't guarantee it
04:23:02 <aristid> (,) `fmap` [1..5] is map (,) [1..5] (evaluating to [(1,),(2,),(3,),(4,),(5,)])
04:23:29 <Maxdamantus> Yep.
04:23:36 <zygoloid> fmap = liftM for any law-abiding instance of Monad and Functor
04:23:58 <The_Haskellrod_o> "     liftM :: (Monad m) => (a -> b) -> m a -> m b     "  
04:24:18 <The_Haskellrod_o>  liftM f m = m >>= \i ->  
04:24:22 <The_Haskellrod_o> return (f i)
04:24:35 <The_Haskellrod_o> *from Haskell book* ;)
04:24:51 <itsmonktastic> @src liftM
04:24:51 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:26:33 <The_Haskellrod_o> I'm running to study some more b4  I revisit ;) have a nice day (or evening for yall Europeans)  bye
04:26:59 <aristid> The_Haskellrod_o: it's not evening in yurop. more like noon
04:27:19 <The_Haskellrod_o> yep ;) it's 6:25 am here in New Orleans
04:28:30 <The_Haskellrod_o> ok so 6 + 6/7? yea it's sunny hmm, just after lunchtime !  I need to concentrate more :)
04:28:51 <zygoloid> (liftM f . liftM g) m = (m >>= return . g) >>= return . f = m >>= (\x -> return (g x) >>= return . f) = m >>= return (f (g x)) = m >>= return . (f . g) = liftM (f . g)
04:29:01 <zygoloid> liftM id m = m >>= return . id = m >>= return = m
04:29:10 <The_Haskellrod_o> well that's cool, ok have a nice day then
04:29:47 <zygoloid> therefore liftM is a legitimate fmap (it follows the Functor laws). since fmap is unique, liftM must be denotationally equal to any other legitimate fmap
04:29:54 <zygoloid> so liftM = fmap ;)
04:30:15 <zygoloid> (of course, proving fmap is unique is the interesting part)
04:30:42 <benmachine> (f:fs) <*> xs = f <$> xs ++ fs <*> xs; f <$> [] = []; f <$> (x:xs) = f x : f <$> xs
04:31:03 <benmachine> oh and [] <*> xs = []
04:32:00 <aristid> concatFmap :D
04:47:45 <zygoloid> does parametric polymorphism have a translation into category theory?
04:53:03 <aRcatan> meh, :29
04:53:08 <aRcatan> whoops, wrong window
04:55:46 <quicksilver> zygoloid: the striking property of parametric polymorphism is related to the fact that the term language (of haskell) is only capable of expressing natural transformations
04:55:54 <quicksilver> zygoloid: is that what you mean?
04:56:07 <quicksilver> the so called "theorems-for-free" stuff.
04:56:17 <zygoloid> quicksilver: yeah, i think that's what i was looking for.
05:00:23 <quicksilver> zygoloid: you may find something of interest here : http://scholar.google.co.uk/scholar?cluster=3315673847983102354&hl=en&as_sdt=2001&as_subj=eng
05:00:31 <quicksilver> although that's not the robinson paper I was looking for
05:00:35 <zygoloid> @free fmap :: (a -> b) -> (F a -> F b)
05:00:35 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
05:02:06 <zygoloid> quicksilver: thanks, that looks interesting
05:02:59 * hackagebot buildbox 1.0.0.0 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.0.0.0 (BenLippmeier)
05:03:03 <quicksilver> I can't find the robinson paper I *was* looking for. It's an old one, I have it somewhere in hard copy but I've probably lost it. Ah well.
05:05:00 * hackagebot buildbox 1.0.0.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.0.0.1 (BenLippmeier)
05:08:36 <Itkovian> OK, got mtl to build against ghc 6.13.x again.
05:10:26 <luite> is 6.14 supposed to be released soon(ish)? I haven't been paying close attention to ghc development lately
05:17:17 <Maxdamantus> Is there a prelude function that takes a boolean value and returns one argument if it's true, or the other if it's false?
05:17:29 <Maxdamantus> blah a b c = if a then b else c
05:17:43 <Ke> D
05:17:47 <Ke> =D
05:21:49 <quicksilver> Maxdamantus: no.
05:21:56 <quicksilver> Maxdamantus: some people call it 'bool'
05:22:01 <opqdonut> or if'
05:22:22 <zygoloid> lambdabot's @pl calls it if'.
05:22:33 <Maxdamantus> Mk :\
05:27:44 <Itkovian> syb-2.0.1 is installed in the ghc (6.13) install location, any idea why cabal would complain when trying to install parsec (3.1.0)?
05:34:54 <Itkovian> cabal configure in parsec states: selecting syb-0.2.1 (installed)
05:35:11 <Itkovian> cabal install states: cabal: cannot configure syb-0.2.1. It requires base >=4.0 && <4.3
05:39:21 <ben_m> Greetings!
05:39:33 <ben_m> Does anyone know where I can find the source of Functor instances?
05:39:40 <ben_m> For example the definition of Functor ((,) a)
05:40:33 <aristid> @src (,) fmap
05:40:33 <lambdabot> fmap f (x,y) = (x, f y)
05:40:55 <aristid> @hoogle Functor
05:40:56 <lambdabot> Prelude class Functor f
05:40:56 <lambdabot> Control.Monad class Functor f
05:40:56 <lambdabot> Control.Monad.Instances class Functor f
05:40:57 <quicksilver> ben_m: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Control-Monad-Instances.html
05:41:03 <ben_m> Where does lambdabot get that from?
05:41:09 <quicksilver> ben_m: it just makes it up.
05:41:17 <quicksilver>  @src is unreliable and spammy and should be removed.
05:41:22 <ben_m> That link looks promising :)
05:41:58 <aristid> quicksilver: it is very useful anyways :P
05:43:09 <ben_m> I find that reading the definitions of Functor/Monad instances helps a lot when learning about them
05:43:37 <quicksilver> aristid: I don't think it is.
05:43:50 <ben_m> Because 'f (x,y) = (x, f y)' is a lot clearer than '((,) a) is a computational context for annotations' or whatever :D
05:43:50 <quicksilver> aristid: it has incorrect information, it has patchy information, and it doesn't teach people where to go next.
05:44:07 <aristid> quicksilver: removing it is not the correct consequence.
05:44:25 * quicksilver shrugs
05:44:31 <quicksilver> it does much more harm than good, as it stands
05:44:31 <ben_m> improve!
05:44:38 <quicksilver> if you feel like fixing it, then sure
05:44:42 <quicksilver> removing it is less work
05:44:46 <aristid> i think it does more good than harm.
05:46:30 <quicksilver> Then our opinions differ.
05:46:38 <ben_m> unacceptable!
05:47:39 <aristid> unmutual!
05:47:57 <ben_m> ... immutable!
05:48:10 <aristid> ben_m: i think the evil one was "mutable"
05:49:24 <ben_m> irrefutable!
05:55:59 * mux found a new slogan for Haskell: if it compiles, it will run correctly 90% of the time; only problem is, it's gonna use O(n^n) memory 80% of the time
05:56:18 <Botje> mux: bah, that's an engineering problem :)
05:56:27 <mux> heh
06:02:38 <hpc> only O(n^n)? that's incredible!
06:05:23 <burp> O(n!^n!)
06:05:58 <aristid> burp: more realistic
06:06:42 <burp> at least darcs is such an app, but it has nothing to do with haskell (I think) ;)
06:10:25 <aristid> if i have a type like X (Y a b) c d and i want to fix c = Z, how can i do this without writing X (Y a b) Z d?
06:10:50 <aristid> or at least without writing it more than once ;)
06:11:34 <opqdonut> make an alias
06:11:41 <opqdonut> using type or newtype
06:13:04 <aristid> opqdonut: well then i still have to write a b and d
06:14:56 <int-e> @type foldr (>=>) return -- what would you call this function?
06:14:57 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
06:15:28 <aristid> int-e: sequenceKleisli?
06:15:29 <opqdonut> sequenceAccum ?
06:15:47 <opqdonut> or something like chain
06:15:56 <int-e> chainM (and chain = foldr (.) id)?
06:16:03 <opqdonut> maybe, yeah
06:16:05 <aristid> :t foldr (.) id
06:16:06 <lambdabot> forall b. [b -> b] -> b -> b
06:16:13 <aristid> :t foldr ($)
06:16:14 <lambdabot> forall b. b -> [b -> b] -> b
06:16:28 <aristid> :t foldr (.)
06:16:29 <lambdabot> forall b (f :: * -> *). (Functor f) => f b -> [b -> b] -> f b
06:27:30 <aristid> opqdonut: if you care, i solved it now with smart constructors, smartConstructor :: a -> X T a; smartConstructor = Constructor
06:28:18 <opqdonut> ah
06:31:49 <mux> if S is a qualified import of strict bytestring, and L the same for lazy bytestring, do you guys use S.concat . L.toChunks to convert a lazy bytestring to a strict one? if so, does that avoid copying when the lazy bytestring consists of only one chunk?
06:32:34 <mux> I'm asking because I'm parsing some XML lazily with tagsoup, so using a lazy bytestring, and I then want to store stuff inside a bytestring-trie, which wants strict bytestrings
06:33:15 <pmurias> what types can be expressed with RankNTypes and can't without?
06:34:28 <pmurias> as i can't see what does forall give us
06:34:46 <yitz> mux: doesn't sound like you avoid copying that way.
06:34:47 <jedai> pmurias: two things
06:35:06 <pmurias> jedai: explain? ;)
06:35:33 <jedai> pmurias: first it allows to express quantification at another level (yielding existential and things like the ST monad)
06:35:56 <yitz> mux: how can you avoid copying? the whole point of LBS is that they are only actually populated on demand; copying is the same as demanding the data.
06:36:04 <jedai> pmurias: second it allows us to explicitly scope a type variable which can then be reused in this scope
06:36:29 <yrlnry> Is there a standard name for the monad  data Foo a = Foo  with return x = Foo  and Foo >>= f = Foo?
06:36:46 <jedai> yrlnry: 
06:37:52 <djahandarie> yrlnry, looks kinda like Identity...
06:38:05 <yrlnry> Not at all.
06:38:07 <jedai> djahandarie: no, there's nothing in Foo
06:38:11 <djahandarie> Oh
06:38:18 <djahandarie> Thought you were just being lazy
06:38:21 <djahandarie> :P
06:39:52 <djahandarie> That doesn't satisfy the monad laws does it?
06:40:11 <yrlnry> Maybe not.  What problem do you see?
06:40:50 <jedai> pmurias: A simple example of function you can't express without forall : let f :: (forall a . Num a => a -> String) -> Float -> Double -> String; f g x y = g x ++ g y
06:41:44 <jedai> pmurias: Not that this function is particularly interesting but there are case where the capacity to express this kind of thing is crucial
06:42:27 <pmurias> jedai: so a forall a. Foo => is the interesting case
06:42:29 <pmurias> jedai: thanks
06:42:34 <jedai> pmurias: no
06:43:03 <jedai> pmurias: that's just an example, you don't have to use typeclass to get applications
06:44:27 <yitz> mux: To avoid extra copying, don't use S.concat. Just take the lazy list of SBSs you get from toChunks and feed them into the trie.
06:44:58 <mux> yitz: except things are not that simple; I want a part of the lazy bytestring
06:45:17 <mux> toChunks splits whenever it'll have reached the statically configured chunk size
06:45:30 <Itkovian> any idea? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29410#a29410
06:45:33 <Itkovian> cabal hell
06:46:11 <yitz> mux: right. so to avoid copying, you'll have to map your filter (that works on SBS) across the chunks. alternatively, if your filter applies to LBS, apply it before the toChunks.
06:46:34 <dcoutts> Itkovian: cabal and "runghc Setup" have different defaults, in particular the globa/user one
06:46:55 <Itkovian> OK
06:47:11 <yitz> mux: and in the first case, that means you'll have to factor the filter to be able to work across arbitrary chunk sizes, keeping state between chunks. yuck.
06:47:13 <dcoutts> Itkovian: it's easier if you just stick to one or the other rather than mixing, the cabal tool can do (almost) everything that runghc Setup can.
06:47:13 <Itkovian> I'm trying to understand why parsec 3.1.0 is refusing to get installed, even though it gets built by cabal
06:47:24 <mux> yitz: pretty much unpractical
06:47:27 <Itkovian> dcoutts: OK, but when cabal failed, I resorted to the other
06:47:30 <mux> yitz: remember, I'm using tagsoup :)
06:48:20 <dcoutts> Itkovian: remember that "cabal install" is a "do everything" command, so you don't need to configure, and any flags you pass to configure will be forgotten.
06:48:34 <Itkovian> ah
06:48:36 <Itkovian> frak
06:48:41 <yitz> mux: i don't get it. if the filter is built from tag soup combinators, so you apply it before toChunks and you're fine. if not, then what does that part have to do with tagsoup?
06:48:45 <Itkovian> so ...
06:48:48 <Itkovian> the other ortder would be
06:48:55 <Itkovian> cabal configure, cabal build and ?
06:49:19 <mux> yitz: I'll have to understand what filter you're talking about
06:49:19 <dcoutts> Itkovian: no, it's much simpler, just cabal install --with-compiler= --with-hc-pkg=
06:49:26 <Itkovian> aha
06:49:28 <Itkovian> aha
06:49:31 <Itkovian> let's try
06:49:42 <mux> yitz: extracting the parts I'm interested in from the lazy bytestring is done using tagsoup, so tagsoup gives me back LBS with my data
06:49:43 <yitz> mux: you said you need to select only part of the LBS before you feed it into the trie
06:49:57 <Itkovian> nope, it retries to install syb :-(
06:49:59 <dcoutts> Itkovian: if you want to run phases separately then that's possible too, but if you're just trying to install, then just install :-)
06:50:01 <mux> only a part, yes, because it's a huge 40MB+ LBS containing an XML file
06:50:07 <mux> it's not my who is filtering stuff
06:50:12 <yitz> mux: ok, fine. so then take the resulting LBS, chunk it, and feed the chunks one by one into the trie.
06:50:14 <Itkovian> dcoutts: I'm trying to get criterion installed on 6.13.x
06:50:15 <mux> I parse using tagsoup, and then extract stuff
06:50:20 <djahandarie> yrlnry, Well, return a >>= f === f a.  In your case that'd be return a >>= f => Foo >>= f => Foo. which is not f a
06:50:42 <dcoutts> Itkovian: yes, it's really a "do everything" including deps. You can see what it would do with --dry-run (-v) and you can control the behaviour with --constraint=
06:50:44 <mux> yitz: that doesn't make any sense
06:51:00 <dcoutts> Itkovian: e.g. if by default it wants to pick a different syb version from the one you'd like.
06:51:19 <Itkovian> It want to pick the one I have but does not seem to find it
06:51:28 <Itkovian> it's installed as --user
06:51:39 <mux> yitz: at some point, I'm extracting an XML attribute value that will be the key of my trie, it's in a LBS due to the reasons mentioned above. now I have this (small) LBS, and it's supposed to be a key in the trie, so a strict bytestring
06:51:45 <Itkovian> since ghc resides in a local dir and --global want to go to /usr/local where I have no access
06:51:50 <dcoutts> Itkovian: does ghc-pkg check say it's ok, cabal will ignore packages that are broken due to missing deps.
06:51:58 <yrlnry> djahandarie:  yes, it is.
06:51:58 <mux> yitz: and it's the whole attribute value that is the key, I cannot chunk it and feed it one by one to the tire
06:52:05 <aRcatan> huh, I've always thought that it's Kliesli and not Kleisli.
06:52:07 <Itkovian> ghc-pkg shows the lib as being there
06:52:23 <yrlnry> djahandarie:  f has type a -> Foo a, so it must be the function  \ a -> Foo.
06:52:34 <EvanR-work> i before e except after c
06:52:36 <dcoutts> Itkovian: see what --dry-run -v reports about syb. You can force it to pick a particualr version with --constraint='syb == x.y.z'
06:52:44 <Itkovian> OK, I'll try that
06:52:46 <Itkovian> thx
06:53:11 <yitz> mux: oh, well for LBSs that you expect to be small like that, I suppose doing a totally strict concat and copying it should be OK, shouldn't it?
06:53:12 <aRcatan> EvanR-work: huh?
06:53:20 <Itkovian> "cabal: cannot configure syb-0.2.1. It requires base >=4.0 && <4.3"
06:53:28 <Itkovian> Since it's 6.13, base is at 4.4
06:53:47 <mux> yitz: I suppose it's not "that" bad, I was mostly curious about whether copying will be involved or not
06:53:51 <dcoutts> Itkovian: have you got a local syb that's the same version as on hackage but actually has quite different deps?
06:53:56 * yitz nods
06:54:10 <dcoutts> Itkovian: if so, I suggest bumping the minor version to clarify that they're different
06:54:16 <Itkovian> not that I know of
06:54:21 <Itkovian> I started with a clean install
06:54:28 * Itkovian goes to check .cabal
06:54:51 <dcoutts> Itkovian: what you want in this situation is --constraint='syb installed' but that's not implemented yet.
06:55:07 <Itkovian> ls ~/.cabal/lib/syb-0.2.1/ shows theree dirs for each ghc head I built
06:55:14 <Itkovian> nothing else
06:55:52 <Itkovian> and nothing in ghc-llvm/lib/ghc-6.13.x/
06:56:00 <Itkovian> ah well, let;s try with Setup again ...
06:56:14 <dcoutts> Itkovian: well you've clearly got a modified syb, since the version on hackage does say base < 4.3 and you've got base 4.4
06:56:33 <dcoutts> Itkovian: this confuses cabal as it assumes that the same version is the same version :-)
06:56:38 <Itkovian> yes, I changed that
06:56:41 <Itkovian> OK
06:56:43 <Itkovian> I see.
06:56:54 <Itkovian> hmm, adding --user to Setup seems to help
06:57:06 <Itkovian> and ... it builds
06:57:20 <Itkovian> and ... it installs (Setup install)
06:57:22 <Itkovian> yes!
06:57:25 <Itkovian> thx
06:57:37 <dcoutts> Itkovian: for reference, you can do cabal install --only, for just the install step
06:57:59 <dcoutts> Itkovian: the cabal configure on its own will always pick installed versions, it has no other choice
06:58:02 <Itkovian> then there are no dependencies checked, if configure figured them out?
06:58:04 <Itkovian> OK
06:58:09 <dcoutts> thought it may not be able to find consistent deps
07:02:11 <Itkovian> OK If anybody gets in this mess, here's the dependency graph for criterion :-) http://itkovian.net/criterion_hackage_dependency_graph.pdf
07:02:56 <birdspider> hi, is hoogle capable of indexing/searching a local project, or are there any other tools to search through a local project api ?
07:03:17 <luite> Itkovian: it would be better if you made it directed
07:03:43 <Itkovian> luite: true
07:04:20 <Itkovian> I can give you the omnigraffle source :-)
07:09:41 <Itkovian> How about having the reverse dependencies on hackage too? i.e. pointers to packages using a certain package?
07:13:09 <Itkovian> luite: like so? retry the link
07:13:13 <quicksilver> birdspider: I believe hoogle can do that.
07:13:22 <quicksilver> birdspider: it works somehow together with haddock.
07:13:25 <quicksilver> but I've never done it.
07:13:53 <luite> Itkovian: much better ;)
07:13:56 <Itkovian> ugh
07:14:04 <Itkovian> sec, exported the selection :-)
07:14:07 <Itkovian> and little was selected
07:14:42 <Maxdamantus> Hm. I think that <*> mentioned earlier wasn't what I needed :\
07:15:26 <mux> style question: do you like "f . g <$> a" or "f <$> g <$> a" better?
07:15:38 <Itkovian> try now :-D
07:15:42 <Maxdamantus> @src (<*>)
07:15:42 <lambdabot> Source not found. Just try something else.
07:16:41 <JoeyA> Hmm, I wonder if it would be possible to create a Haskell module that creates a `dwim` operator
07:16:58 <JoeyA> In essence, it goes through all the monadic and applicative combinators until it hits one that type-checks.
07:17:53 <JoeyA> It would need some class trickery, and probably a bunch of scary extensions like UndecidableInstances, IncoherentInstances, IncoherentProgrammer, etc.
07:18:08 <mux> PerlTypeChecking
07:19:24 <ben_m> best kind of type checking
07:20:49 <Axman6> isTypeCorrect = isString
07:21:25 <Itkovian> For a moment there I read FireFly
07:22:37 <Itkovian> Just to keep the info fresh in everybody's head. There will be a hackathon in Ghent, Belgium on Nov 5-Nov 7 2010. See http://www.haskell.org/haskellwiki/Ghent_Functional_Programming_Group/BelHac. Now kick me for spamming :-0
07:22:49 <Maxdamantus> How can I iterate through multiple lists at the same time, passing one element per iteration per list to a function? >_<
07:22:59 <Itkovian> Maxdamantus: zip them?
07:23:09 <Maxdamantus> Hmm.. With 12 lists
07:23:30 <Itkovian> Rewrite the function
07:23:36 <Maxdamantus> zip12?
07:23:47 <Itkovian> But zip will have you stop as soon as one list runs out
07:23:51 <luite> Itkovian: the link between base and bytestring is undirected
07:23:55 <Itkovian> ah frak
07:23:57 <Itkovian> thx
07:24:05 <Itkovian> but that should be obvious :-)
07:24:18 <Maxdamantus> Hmm.. all the lists have the same length.
07:24:40 <Axman6> Maxdamantus: if you have twelve lists you need to process like that, there's a good chance you're doing it wrong
07:25:34 <Maxdamantus> Imagine you were reading a file that had a sequence of events, each event consisting of multiple values.
07:25:49 <Maxdamantus> but.. the values are all separate >_<
07:26:42 <Maxdamantus> ie, instead of having one event followed by another event (each event consisting of multiple values), it's just got a huge array of all of the first field of events, then second, ..
07:27:11 <JoeyA> Parse them into separate lists first?
07:27:15 <Maxdamantus> I did.
07:27:24 <Maxdamantus> Now I'm trying to make a list of events.
07:27:40 <JoeyA> Spit them out one list of events at a time?
07:28:04 <Maxdamantus> I don't have a list of events.
07:28:18 <Maxdamantus> I have a list of all values for the first field in the event structure
07:28:28 <Maxdamantus> and a list of all values for the second field in the event structure ..
07:28:38 <Maxdamantus> .. twelfth ..
07:28:45 <Maxdamantus> twelvth, maybe O_o
07:28:48 * Maxdamantus shrugs
07:28:53 <JoeyA> So the event structure is a list of 12 items, or is it a type?
07:29:06 <Maxdamantus> No, the event structure's not a list.
07:29:13 <JoeyA> like data Event = Event String Char Int String ...
07:29:21 <JoeyA> or data Event = {
07:29:32 <Maxdamantus> Yes, like that.
07:30:22 <JoeyA> Okay, so I guess you have a [[String]] holding the inputs?
07:30:27 <JoeyA> Or maybe 12 [String] inputs?
07:30:36 <Maxdamantus> Yeah.
07:30:42 <JoeyA> (unless you're using something besides String as your intermediate representation)
07:30:44 <Maxdamantus> But they're not [String]s
07:30:54 <Maxdamantus> [Num]s and stuff
07:32:17 <JoeyA> As long as they're all the same type.
07:32:26 <JoeyA> Okay, pretending you have [[String]]
07:32:36 <Maxdamantus> They're not all the same type :\
07:33:09 <JoeyA> You mean each list isn't, right?
07:33:32 <Maxdamantus> Yeah, each list is a different type
07:33:35 <Axman6> i'm sensing this will need quite a few zipWith ($)'s
07:33:52 <JoeyA> One option you have (it might not be the best way in your case) is to use a wrapping type so they're all the same type.
07:34:04 <Axman6> :\
07:34:11 <JoeyA> Similar to what SqlValue does:  http://hackage.haskell.org/packages/archive/HDBC/2.0.1/doc/html/Database-HDBC-SqlValue.html
07:34:26 <JoeyA> Just a thought.
07:34:35 <Axman6> :t zipWith
07:34:36 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
07:34:55 <hpc> :t liftM2
07:34:56 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:35:14 <Maxdamantus> Hmm.. lots of zipWith ($)s might work
07:35:37 <danewbie> hey guys, do you know whether is possible to use dph-prim-par and dph-prim-seq in the same library?
07:35:43 <Maxdamantus> Hmm.. That would seem odd though.
07:35:54 <Maxdamantus> Oh, I see.
07:36:03 <Axman6> basically, say you have: data Event = E {a::A, b::B, c::C..}, you might be able to use ... i'll just write the code >_<
07:36:45 <danewbie> i'm trying to make a newtyped Int an instance of the class Elt
07:37:01 <danewbie> and GeneralizedNewtypeDeriving doesn't work
07:37:54 <JoeyA> The zipWith series goes up to 7
07:38:22 <danewbie> so i need to make instances of both UA and DT, but they are in separate packages
07:38:58 <danewbie> and then i get a "Ambiguous module name" error...
07:39:01 <danewbie> any idea?
07:39:52 <Axman6> Maxdamantus: http://codepad.org/TP9HXrAN
07:40:04 <Axman6> i'm not sure there's a more elegant way
07:40:28 <Maxdamantus> My code already looks quite unelegant.
07:40:45 <Axman6> uh, those Int's should be [Int]
07:40:50 <Maxdamantus> Hopefully the stuff dealing with the data will look nicer than the stuff parsing it from the file.
07:41:51 <pmurias> is it possible to derive show for a GADT?
07:41:55 <pmurias> * Show
07:42:32 <Maxdamantus> Mmm.. I see.
07:43:44 <Axman6> Maxdamantus: basically, you just build up a bunch of lists of functions
07:43:48 <zygoloid> pmurias: possibly with standalone deriving
07:44:01 <Axman6> until the function E is fully applied to all of its arguments
07:44:08 <pmurias> zygoloid: standalone deriving?
07:45:48 <zygoloid> pmurias: the StandaloneDeriving extension
07:45:59 <zygoloid> pmurias: take a normal instance definition for a derivable typeclass
07:46:12 <zygoloid> pmurias: remove the 'where' and everything after it, and add the word 'deriving' to the start of the line
07:46:31 <zygoloid> pmurias: "deriving instance Show a => Show (MyGADT a)"
07:46:59 <zygoloid> it'll have a go at generating an instance (even for a GADT) and hopefully it'll all work out
07:49:01 <zygoloid> pmurias: here's a little example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29411#a29411
07:54:26 <Maxdamantus> Thanks.
07:55:40 <wavewave> somebody help me!
07:56:15 * JoeyA throws a life preserver at wavewave
07:56:43 <wavewave> I am making a library wrapping other C library using FFI. 
07:56:51 <wavewave> now I made a cabal package...
07:57:15 <wavewave> but extra-lib-dirs: in package.cabal file seems not working... 
07:57:34 <wavewave> I persistently get an error : Missing C library: xxx
07:57:42 <wavewave> where xxx is the C library name. 
07:57:57 <wavewave> that C library is .so file. (using debian linux)
07:58:25 <JoeyA> Have you looked to other cabal packages for inspiration? (like HDBC-sqlite3)
07:58:33 <JoeyA> (I don't know the answer; I'm looking into it)
07:59:06 <JoeyA> It uses Extra-Libraries: sqlite3
07:59:12 <JoeyA> No extra-lib-dirs
07:59:37 <JoeyA> I imagine that's for if you want to build a package that uses static libraries (is that what you're doing?)
07:59:57 <wavewave> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29413#a29413
07:59:58 <JoeyA> like, if you want to make a Curl module that uses a statically compiled curl because you don't trust the installed curl to be new enough.
08:00:05 <wavewave> this is my cabal file. 
08:00:48 <wavewave> JoeyA: I am linking dynamic shared library. 
08:02:52 <wavewave> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29414#a29414
08:03:11 <wavewave> this is the error message when i run "cabal install"
08:03:21 <pnicholson> Hello, I'm having a problem with utc time.
08:03:26 <pnicholson>     Couldn't match expected type `time-1.1.4:Data.Time.Clock.UTC.UTCTime'
08:03:26 <pnicholson>            against inferred type `UTCTime'
08:03:26 <pnicholson>     In the first argument of `SqlUTCTime', namely `time'
08:03:27 <pnicholson>     In the expression: SqlUTCTime time
08:03:27 <pnicholson>     In the third argument of `run', namely
08:03:27 <pnicholson>         `[toSql id, toSql content, SqlUTCTime time]'
08:04:00 <wavewave> should I always use static library for linking external C library?
08:04:06 <zygoloid> pnicholson: it looks like those two UTCTime types are from different modules
08:04:26 <zygoloid> pnicholson: possibly different packages or different versions of the same package even? :o
08:04:32 <JoeyA> wavewave: Sorry, I'm clueless.
08:04:43 <zygoloid> pnicholson: can you paste the relevant code onto hpaste.org?
08:05:05 * JoeyA 's life preserver strikes wavewave in the head, sending him/her to the ocean floor.
08:10:18 <pnicholson> zygoloid: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29420#a29420
08:20:49 <pnicholson> zygoloid: any thoughts?
08:22:56 <zygoloid> at a guess, hdbc was compiled with one version of the time module, Data.Time is being taken from another version. i'm not sure that should happen, but that's the sort of error i'd expect in that case
08:23:54 <pnicholson> zygoloid: so would reinstalling hdbc fix it?
08:24:21 <zygoloid> *shrug* it's worth a try.
08:30:02 <DamienCassou> why is hoogle database that old?
08:31:42 <jadrian> hi guys
08:33:27 <jadrian> is there a name for types who's expression contains no occurrences of monomorphic ground  types
08:33:51 <fasta> Fully polymorphic? 
08:33:54 <Cale> Maybe "fully polymorphic types"?
08:34:00 <fasta> :)
08:34:21 <DamienCassou> do you know why hoogle only references old versions of libraries?
08:34:26 <jadrian> well same answer twice and so fast... can't argue about that 
08:34:29 <fasta> jadrian, just writing whatever you wrote is easier to read, though. 
08:34:31 <jadrian> :)
08:34:32 <aristid> jadrian: like Monad m => m (m a)?
08:34:40 <zygoloid> jadrian: writing a paper? ;)
08:34:42 <fasta> jadrian, in that case your audience doesn't have to know. 
08:35:00 <fasta> jadrian, although, monomorphic ground type is also a mounth full. 
08:35:02 <fasta> mouth*
08:35:13 <jadrian> yes very true, that was not easy to read
08:35:28 <jadrian> kind of zygoloid, thesis
08:35:43 <Wolfspaw> O_O
08:35:44 <zygoloid> DamienCassou: i assume you mean some specific hoogle database. do you mean lambdabot's @hoogle, the hoogle web service, a hoogle you've installed locally or something else?
08:35:51 <fasta> jadrian, why not define it as an inductive type?
08:36:16 <fasta> jadrian, either a type variable, or a function arrow with two arguments?
08:36:39 <DamienCassou> zygoloid: sorry, I only knew about one hoogle: http://haskell.org/hoogle
08:37:03 <DamienCassou> @hoogle Test.QuickCheck.Gen
08:37:04 <lambdabot> Test.QuickCheck data Gen a
08:37:04 <lambdabot> Test.QuickCheck generate :: Int -> StdGen -> Gen a -> a
08:37:05 <jadrian> fasta, definition isn't an issue... just wanted a name I can use to refer to them
08:37:22 <zygoloid> DamienCassou: i think ndm maintains that one; presumably its db hasn't been rebuilt recently
08:37:28 <DamienCassou> zygoloid: the one of lambdabot seems old too
08:37:50 <DamienCassou> zygoloid: is there a recent one somewhere?
08:38:04 <fasta> jadrian, just cite someone even if _now_ people understand what you mean or define it in your own paper. 
08:38:07 <zygoloid> DamienCassou: you can build your own
08:38:41 <fasta> jadrian, articles that are 30 years old that use certain notations that were normal at the time are not easy to read now, because of things like that. 
08:38:41 <DamienCassou> zygoloid: there is none currently deployed?
08:38:55 <jadrian> fasta, yes I have noticed that :)
08:41:02 <zygoloid> DamienCassou: i only know of those two public ones.
08:41:24 <DamienCassou> zygoloid: I've just submitted a bug report to hoogle tracker
08:55:27 <DamienCassou> zygoloid: in hoogle documentation to install your own hoogle, there is written to run 'runhaskell Setup haddock --hoogle'
08:55:45 <DamienCassou> zygoloid: however, runhaskell complains about Setup not being a valid module
09:15:57 <boegel> does anyone know if BONUS is ever active on here, and if so, when?
09:16:32 <jcreigh> @seen BONUS
09:16:32 <preflex>  BONUS was last seen on #haskell 69 days, 23 hours, 23 minutes and 21 seconds ago, saying: :)
09:16:32 <lambdabot> Unknown command, try @list
09:16:41 <boegel> ok, so, never :)
09:16:46 <jcreigh> well, a while ago. :)
09:16:55 <boegel> :)
09:17:30 <alip> let's say i have type like: data Foo = Foo { a :: Bool, b :: Bool, c :: Bool, d :: Bool } is there a quick way to initialize a variable of Foo type with all variables set to True? writing Foo { a = True, b = True ... } gets too long, when you have lots of record fields :)
09:18:06 <aristid> jcreigh: what, preflex now reacts to @seen directly?
09:18:27 <c_wraith> alip, you the most concise you can get is Foo True True True True
09:18:27 <jcreigh> aristid: No clue. I was expecting lambdabot to answer that.
09:18:59 <c_wraith> alip: but since data is immutable, you could always just create a name for that value, and use that name whenever you need it.
09:20:23 <quicksilver> or indeed fooAll x = Foo x x x x; and use "fooAll True"
09:20:59 <copumpkin> does Traversable correspond roughly to http://en.wikipedia.org/wiki/Distributive_law_between_monads ? Except it seems to work for more than monads
09:20:59 <zygoloid> DamienCassou: that should probably say Setup.hs. and i suspect there's a better way if you're using cabal
09:21:28 <DamienCassou> zygoloid: do you have an idea?
09:21:48 <zygoloid> DamienCassou: my idea would be to look through the cabal help ;)
09:21:56 <DamienCassou> ok
09:23:04 <zygoloid> alip: there's a more concise way if you derive Data.
09:23:13 <zygoloid> alip: everywhere (const True) Foo{}
09:23:43 <zygoloid> Foo{} fills all the Bools in with _|_, and the everywhere converts all those _|_s to Trues.
09:25:56 <alip> zygoloid: i assume deriving Data requires an extra package?
09:26:13 <ziman> what type does everywhere have?
09:26:24 <zygoloid> alip: it requires the DeriveDataTypeable extension
09:26:32 <zygoloid> also, everywhere isn't the right combinator
09:26:37 <zygoloid> i can never remember which is which in syb
09:27:06 <zygoloid> > everywhere (mkT $ const True) Just {} :: Maybe Bool
09:27:07 <lambdabot>   Just True
09:27:20 <zygoloid> ^^ there you go.
09:27:32 <zygoloid> i bet there's an everywhere . mkT somewhere, too
09:28:22 <aristid> :t mkT
09:28:23 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
09:28:32 <aristid> :t mkT (const True)
09:28:33 <lambdabot> forall a. (Typeable a) => a -> a
09:28:57 <aristid> :t mkT (const True) 1
09:28:58 <lambdabot> forall t. (Num t, Typeable t) => t
09:29:01 <aristid> > mkT (const True) 1
09:29:02 <lambdabot>   1
09:29:04 <zygoloid> @@ @hoogle @type \f -> everywhere (mkT f)
09:29:05 <lambdabot>  Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
09:29:05 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
09:29:05 <lambdabot> Data.Data gmapT :: Data a => (b -> b) -> a -> a
09:29:17 <zygoloid> hmm, none of those is the one i wanted ;(
09:29:29 <aristid> :t Just {}
09:29:30 <lambdabot> forall a. Maybe a
09:29:36 <aristid> :t {}
09:29:37 <lambdabot> parse error on input `{'
09:29:47 <aristid> > Just {}
09:29:48 <lambdabot>   Just *Exception: <interactive>:1:133-139: Missing field in record construct...
09:39:14 <danlei> I've installed parallel with cabal install, and though cabal list shows it as installed, it isn't found by ghc. the other packages I installed all work correctly. what could be the reason for that?
09:39:36 <dcoutts> danlei: does ghc-pkg list report it?
09:39:43 <danlei> a sec
09:39:44 <dcoutts> ghc-pkg list parallel
09:39:58 <danlei> yes, it does
09:39:59 <dcoutts> if ghc-pkg says it's registered then it's there
09:40:17 <danlei> parallel-3.1.0.0 is in the list
09:40:18 <dcoutts> what do you mean exactly when you say it's not found by ghc?
09:40:28 <danlei> I can't do "import Control.Parallel"
09:41:32 <danlei> or, in ghci: :m +Control.Parallel ==> Could not find module Control.Parallel
09:41:54 <dcoutts> danlei: you don't have a local source file with that name do you?
09:41:55 <dh__> what's the best way to get the digits of a number , 123 -> [1,2,3]?
09:42:16 <dh__> now I convert it to string and read each digit back, is there a better method?
09:42:32 <danlei> dcoutts: I'm not sure I understand what you mean by "local source file"
09:42:33 <dcoutts> danlei: I mean, you're not in the parallel source dir or something like that
09:42:34 <dh__> map read $ map (:[]) $show 
09:42:42 <zygoloid> > map digitToInt $ show 123
09:42:42 <lambdabot>   [1,2,3]
09:42:46 <danlei> dcoutts: no
09:43:07 <dh__> :t digitToInt
09:43:08 <lambdabot> Char -> Int
09:43:14 <dcoutts> danlei: does ghc-pkg describe parallel show the module?
09:43:24 <zygoloid> dh__: that's short and pretty clear. so unless you have a reason to not use it, it seems like a reasonable solution
09:43:52 <danlei> dcoutts: yes, it does
09:43:58 <dcoutts> danlei: and ghc-pkg check does not report any problems?
09:44:19 <dh__> zygoloid: thanks. it seemed Data.Digits.digits can do this
09:44:49 <dh__> >digits 10 100
09:45:01 <danlei> dcoutts: it only shows a problem with text, because deepseq isn't installed; nothing about parallel
09:45:04 <dh__> > digits 10 100
09:45:05 <lambdabot>   Not in scope: `digits'
09:45:27 <dcoutts> danlei: I'm stumped, see if you can import it in a prog
09:45:36 <dcoutts> ie not in ghci
09:45:46 <danlei> dcoutts: doesn't work either
09:46:00 <danlei> dcoutts: but thanks for your help!
09:46:23 <dcoutts> danlei: might be worth double checking that you've not got an odd mixture of ghc versions, eg a mismatch between ghc/ghci and ghc-pkg
09:46:44 <dh__> @where digitToInt
09:46:44 <lambdabot> I know nothing about digittoint.
09:46:59 <dh__> :i digitToInt
09:47:12 <dcoutts> danlei: e.g. if you had two ghc installations and you're using one, but the package got installed for the other
09:48:12 <danlei> dcoutts: hm, ok
09:49:00 <danlei> dcoutts: which says they're both in /usr/bin, and --version says 6.12.1 for both
09:49:17 <PeakerWork> hey, why does Hayoo! not index Prelude?
09:50:14 <dcoutts> danlei: very odd indeed, if this is happening a lot then you'll need to report a bug with lots of details so someone has a chance of tracking down what's going on.
09:50:41 <danlei> dcoutts: yes, it's weird -- all other packages I installed do work
09:51:25 <ManateeLazyCat> > str =~ "^[$#+!].[^ ,]+$"
09:51:26 <lambdabot>   <no location info>:
09:51:26 <lambdabot>      lexical error in string/character literal at chara...
09:51:40 <dh__> is there a function that take a sublist of list? e.g.  a[ 3..7] ? 
09:51:53 <dh__> instead of define it myself with take and drop? 
09:52:12 <ManateeLazyCat> dh__: filter?
09:52:30 <ManateeLazyCat> > filter
09:52:31 <lambdabot>   Overlapping instances for GHC.Show.Show
09:52:31 <lambdabot>                              ((a ->...
09:52:42 <ManateeLazyCat> :t Data.List.filter
09:52:43 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:52:43 <Gracenotes> take/drop will do it
09:52:45 <dh__> no, not filter, given a as [1..10], I want to take a[5.. 7] for example.
09:53:05 <dh__> drop 4 [1..10]
09:53:10 <Gracenotes> most of the time lists aren't used with explicit indexing
09:53:12 <dh__> > drop 4 [1..10]
09:53:13 <lambdabot>   [5,6,7,8,9,10]
09:53:23 <Gracenotes> other data structures may be more appropriate for that, possibly
09:53:34 <dh__> > drop 4 [0.. 10]
09:53:35 <lambdabot>   [4,5,6,7,8,9,10]
09:53:44 <ziman> @pl \a b -> drop (a-1) . take b
09:53:44 <lambdabot> (. take) . (.) . drop . subtract 1
09:53:54 <dh__> (take 3 $ drop 5 ) [0..10]
09:54:08 <dh__> > (take 3 $ drop 5 ) [0..10]
09:54:08 <lambdabot>   Couldn't match expected type `[a]'
09:54:09 <lambdabot>         against inferred type `[a1] -> [...
09:54:18 <ziman> use (.) instead of ($)
09:54:19 <ManateeLazyCat> How to insert "Control character" in String ?
09:54:25 <dh__> > (take 3 . drop 5 ) [0..10]
09:54:26 <lambdabot>   [5,6,7]
09:54:26 <ziman> ($) is application, (.) is composition
09:54:33 <dh__> thanks.
09:55:15 <Gracenotes> > let sublist a b = take (b-a) . drop a in sublist 3 5 [0..]
09:55:16 <lambdabot>   [3,4]
09:55:51 <Gracenotes> exclusive at the end I guess
09:56:11 <Gracenotes> it's functional programming (supposedly), so no shame in making your own utility functions..
09:57:39 <dh__> it's not about shame, it's about if there is already something there.
09:58:53 <Veinor> ManateeLazyCat: "\x03"
09:59:10 <Veinor> inserts ASCII character 0x03
10:00:20 <c_wraith> > "\03"
10:00:21 <lambdabot>   "\ETX"
10:00:34 <ManateeLazyCat> > "\x07"
10:00:35 <lambdabot>   "\a"
10:00:37 <EvanR-work> you mean unicode character \ETX
10:00:44 <djahandarie> > "\x03"
10:00:45 <lambdabot>   "\ETX"
10:00:51 <ManateeLazyCat> Veinor: Thanks.
10:00:53 <c_wraith> haskell also has variable length decimal encodings.
10:01:02 <c_wraith> > "\11211"
10:01:03 <lambdabot>   "\11211"
10:01:08 <c_wraith> > length "\11211"
10:01:09 <lambdabot>   1
10:01:21 <djahandarie> That's neat
10:01:30 <Gracenotes> dh__: not that I know of
10:01:35 <c_wraith> > text "\11211"
10:01:36 <lambdabot>   ⯋
10:01:52 <notabel> dh__: rather than converting an int to string, just use divmod recursively to get its digits:
10:02:08 <notabel> decDigits :: Int -> [Int]
10:02:10 <notabel> decDigits x = decDigits' [] x where
10:02:11 <notabel> 	decDigits' l 0 = l
10:02:11 <notabel> 	decDigits' l x = decDigits' (m:l) d where (d,m) = divMod x 10
10:02:17 <ManateeLazyCat> Veinor: Have a function convert "Control Character" to "\xNumber" format? Example "control G" to "\x07".
10:02:41 <Veinor> I don't know.
10:02:52 <dh__> notabel: thanks. but the code is shorter if convert to string and convert it back to [Integer]
10:03:29 <djahandarie> dh__, also smellier ;)
10:03:35 <ManateeLazyCat> > let isIrcName str =  str =~ "^[$#+!].[^ ,\x07]+$"
10:03:36 <notabel> shorter, yes, but less efficient :-)  you're using show to do base conversion
10:03:36 <lambdabot>   not an expression: `let isIrcName str =  str =~ "^[$#+!].[^ ,\x07]+$"'
10:03:48 <ManateeLazyCat> let isIrcName str =  str =~ "^[$#+!].[^ ,\x07]+$"
10:03:50 <dh__> djahandarie: agree, smellier.
10:03:53 <alex_kidd> does anyone know of a workaround for 'the current implementation of type families does not support equality constraints in superclass contexts'?
10:03:59 <ManateeLazyCat> How to define?
10:04:33 <ManateeLazyCat> Veinor: Never mind, isIrcName str =  str =~ "^[$#+!].[^ ,\x07]+$" works great.... thanks!
10:05:02 * ManateeLazyCat Implement RFC-2812
10:05:22 <Gracenotes> ManateeLazyCat: of course, there are no serves out there which implement 2812 :)
10:05:25 <Gracenotes> *servers
10:05:48 <Gracenotes> some accept more than what the RFC says, others are more restrictive
10:06:05 <ManateeLazyCat> Gracenotes: I'm implement IRC client.
10:06:29 <ManateeLazyCat> Gracenotes: I found no hackage package for my need, so i decide write new IRC protocol parser.
10:06:43 <notabel> alex_kidd: i recall reading oleg use a typeclass that explicitly witnesses the equality, but no details
10:06:46 <Gracenotes> oh, I wrote one using parsec..
10:06:50 <Gracenotes> that was some time ago
10:06:50 <aRcatan> Haskell IRC library situation isn't very good
10:06:56 <djahandarie> There is fastirc on Hackage
10:07:02 <djahandarie> @hackage fastirc
10:07:02 <lambdabot> http://hackage.haskell.org/package/fastirc
10:07:06 <ManateeLazyCat> Gracenotes: I use Text.Regex.TDFA
10:07:16 <alex_kidd> notabel: ok I'll have a look, thanks
10:07:26 <Entroacceptor> ManateeLazyCat: for the 'Lazy' in your name you're quite a programming maniac ;)
10:07:27 <aRcatan> djahandarie: it was quite in progress last time i looked at it
10:07:34 <Gracenotes> ManateeLazyCat: what I'm saying is, servers can accept more IRC nicks than what the RFC says, so don't get too restrictive client-side
10:07:50 * hackagebot ListLike 1.0.2 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-1.0.2 (JohnLato)
10:08:14 <djahandarie> ListLike?
10:08:21 <ManateeLazyCat> Gracenotes: Yep, RFC says nick name length is 9, but my nick name is longer than that. :)
10:08:45 <ManateeLazyCat> Entroacceptor: Why you say i'm programming maniac?
10:08:48 <Veinor> in my experience the nick length is usually 30.
10:09:11 <ManateeLazyCat> Veinor: Do you know nick name limit exactly?
10:09:15 <Gracenotes> 16
10:09:25 <Gracenotes> really complete IRC clients might parse these fields
10:09:25 <Veinor> it's server-dependent :)
10:09:30 <Gracenotes> e.g.: SAFELIST ELIST=U CASEMAPPING=rfc1459 CHARSET=ascii NICKLEN=16 CHANNELLEN=50 TOPICLEN=390 ETRACE CPRIVMSG CNOTICE DEAF=D MONITOR=100 are supported by this server
10:09:40 <Gracenotes> what you get on connecting
10:09:46 <Veinor> yeah.
10:09:50 <ManateeLazyCat> Gracenotes: Oh, i'm lucky. 
10:10:00 <Gracenotes> CHANTYPES=# EXCEPTS INVEX CHANMODES=eIbq,k,flj,CFLMPQcgimnprstz CHANLIMIT=#:120 PREFIX=(ov)@+ MAXLIST=bqeI:100 MODES=4 NETWORK=freenode KNOCK STATUSMSG=@+ CALLERID=g are supported by this server.. and so on
10:10:08 <ManateeLazyCat> djahandarie: But fastirc use Data.ByteString.Char8
10:10:27 <Gracenotes> I don't know what half of those mean
10:11:20 <zygoloid> alex_kidd: you fake something similar up with fundeps: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29423#a29423
10:11:30 <PeakerWork> Who manages Hayoo!?  Can they be bothered to add Prelude to their index? :)
10:12:26 <djahandarie> I wonder how ListLike differs from Traversable
10:12:34 <zygoloid> i /think/ there's a difference between that and "full" superclass equalities (otherwise they wouldn't be hard to implement...)
10:12:41 <zygoloid> but i'm not sure what that difference is.
10:13:04 <ManateeLazyCat> Gracenotes: Parsec?
10:13:09 <PeakerWork> @kind Traversable
10:13:10 <lambdabot>     Not in scope: type constructor or class `Traversable'
10:13:17 <PeakerWork> @src Traversable
10:13:17 <lambdabot> class (Functor t, Foldable t) => Traversable t where
10:13:17 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
10:13:18 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
10:13:18 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
10:13:18 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
10:13:27 <PeakerWork> djahandarie: different kinds, it semems
10:13:56 <PeakerWork> ListLike is *, I think (with an extra class type param iirc for the "element type")
10:13:59 <Gracenotes> ManateeLazyCat: yeah, to parse IRC messages into a data structure
10:14:21 <PeakerWork> Why use Data.ByteString.Char8 and not Data.ByteString.UTF8?
10:14:31 <ManateeLazyCat> Gracenotes: Do you write 'irc' package on hackage? 
10:14:34 <PeakerWork> when dealing with IRC/text encoded in bytestrings?
10:15:27 <Gracenotes> ManateeLazyCat: it's not on hackage, no. I was also writing a monad transformer stack for my IRC bot when I stopped working on it :)
10:15:41 <ManateeLazyCat> Gracenotes: I see.
10:15:59 <Gracenotes> I could dig up the code, it's on my other hard drive
10:16:25 <alex_kidd> zygoloid: thanks
10:16:50 <ezyang> Hey guys, do I want QuickCheck1 or QuickCheck2? 
10:16:57 <ManateeLazyCat> Gracenotes: CAn you send me a copy?
10:18:01 <DukeDave> Hey gang, is there any way to 'lift' a reads function up to the Parsec parser monad?
10:18:03 <Entroacceptor> ManateeLazyCat: because you don't seem to stop, you have decided to do some huge thing and just keep on doing it... 
10:18:14 <ManateeLazyCat> Entroacceptor: Do you know manatee?
10:18:29 <ManateeLazyCat> Entroacceptor: Yep, i'm not to stop.
10:18:56 <Entroacceptor> ManateeLazyCat: I've seen you talking about it, yes.
10:19:14 <ManateeLazyCat> Entroacceptor: Yes, like you said, i'm programming nuts.
10:19:15 <ezyang> DukeDave: Yes, but not canonically. 
10:19:24 <ezyang> (i.e. it's a bit of a hack) 
10:19:26 <Entroacceptor> hey, I like the idea
10:19:26 <ManateeLazyCat> Entroacceptor: I'm writing my irc client for manatee.
10:19:36 <ezyang> Are you sure you can't implement it in pure Parsec? 
10:19:48 <ManateeLazyCat> Entroacceptor: But many friends in #emacs don't like me. :-(
10:19:53 <Entroacceptor> it's crazy, of course, but you seem to manage it :)
10:20:05 <DukeDave> ezyang: I could, but the funtionality I want is exactly that of readHex (and readOct) 
10:20:15 <Entroacceptor> ManateeLazyCat: well, you said you don't like emacs anymore, didn't you?
10:20:34 <ManateeLazyCat> Entroacceptor: I used to love Emacs, but not now.
10:20:54 <PeakerWork> ManateeLazyCat: why not?
10:20:56 <ManateeLazyCat> Entroacceptor: Emacs is awesome, but not enough
10:21:01 <PeakerWork> ManateeLazyCat: because you glimpsed at the elisp?
10:21:10 <ezyang> DukeDave: Ah, I think there are built-in ones for that in parsec. 
10:21:29 <ManateeLazyCat> PeakerWork: http://www.emacswiki.org/emacs/AndyStewart and http://www.flickr.com/photos/48809572@N02/
10:21:47 <ManateeLazyCat> PeakerWork: You will know why, i haven't time debate those now.
10:21:54 <ezyang> DukeDave: Actually, looks like RWH deals with precisely this case: http://book.realworldhaskell.org/read/using-parsec.html 
10:22:16 <ezyang> DukeDave: Use Parsec to grab the string that looks like a bunch of octal/hex digits, and then use readHex on that. 
10:22:16 <PeakerWork> ManateeLazyCat: your project is sort of a window manager, it seems :-)
10:22:30 <PeakerWork> ManateeLazyCat: in a similar sense that emacs is also a window manager
10:22:38 <ManateeLazyCat> PeakerWork: It's not WM, but include WM. (http://www.flickr.com/photos/48809572@N02/4797900653/)
10:22:49 <ManateeLazyCat> PeakerWork: Framework is different.
10:23:21 <ezyang> Hmm, I want monadic testing, so quickcheck2 seems like the right choice then 
10:23:28 <DukeDave> ezyang: Lol, that's exactly how I'm using it at the moment :|
10:24:29 <ezyang> DukeDave: Ah. So what is your difficulty? 
10:24:29 <ManateeLazyCat> PeakerWork: It use multiple-processes design protected core won't crash, (similar Google Chrome, but more generic with MVC design)
10:24:42 <DukeDave> ezyang: I was rather hoping to handle the case where it fails, and return a Left instead of blowing up on head
10:24:56 <ManateeLazyCat> Entroacceptor: Do you interested it? I'm looking for new developer help me develop it....
10:25:13 <DukeDave> ezyang: Or in the case that reads consumes some input on a parse, have that wrapped up in a Parser
10:25:34 <Entroacceptor> oh, I'm interested, I just lack skills 
10:26:35 <ManateeLazyCat> Entroacceptor: You can consider it's multiple districted dbus process for finish OS job.
10:26:45 <DukeDave> ezyang: Looking at the type of reads I assume one could right a general function liftReadsToParser :: ( String -> [(a, String)] ) -> Parser a
10:26:53 <PeakerWork> ManateeLazyCat: what's the benefit of running those processes in the "core" over just running them "outside"?
10:27:14 <ManateeLazyCat> Entroacceptor: Because every sub-module's code is independent with manatee-core, so you can write every simple sub-module and don't need care entrie framework.
10:27:58 <ManateeLazyCat> PeakerWork: Core is "graphcis redirect" of sub-processes and DBus control center.
10:28:58 <cadabra> I'm trying to achieve this, but how? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29424#a29424
10:29:11 <ManateeLazyCat> PeakerWork: It's framework like this : manatee-core (Communication protocol and Toolkit) -> manatee-extension (variant extension)  -> manatee (Window Manager and interactive operation)
10:29:11 <ManateeLazyCat>  
10:29:20 <PeakerWork> ManateeLazyCat: well, WM already does the "graphics re-direct" part, no? XMonad does the redirect.. What's the DBus control center?
10:30:47 <ManateeLazyCat> PeakerWork: It's aim is build *uniform* interface/behaviour, and not just re-direct other program like really WM, such as XMOnad.
10:31:10 <Entroacceptor> mmh, so you're not doing an emacs-rewrite, you're doing a KDE-rewrite ;)
10:31:20 <ManateeLazyCat> PeakerWork: That's mean, it will have it's own editor, browser, file-manager, pdf-viewer, multimedia-player....etc.
10:31:26 <PeakerWork> ManateeLazyCat: I see.. so you can't re-use "whole" programs, just "libraries" like a "web browser library" and such so you can control their behavior to be uniform?
10:31:31 <Lemmih> cadabra: Achieve what?
10:31:43 <sproingie> i've heard there's an emacs mode somewhere that lets you edit text
10:31:47 <ManateeLazyCat> PeakerWork: Yes, i try to re-use exist library, like Webkit.
10:32:06 <ManateeLazyCat> PeakerWork: If no library for my need, i create it.
10:32:08 <PeakerWork> ManateeLazyCat: ah cool.. what about efforts like KDE/Gnome to get uniform interface/behavior?
10:32:13 <cadabra> Lemmih: inputs returns a set of Value
10:32:24 <ManateeLazyCat> PeakerWork: It's design for keyboard geek. :)
10:32:53 <PeakerWork> ManateeLazyCat: I see.. sounds cool, fixing keyboard behavior of KDE/Gnome is probably indeed too much work :)
10:32:56 <ManateeLazyCat> PeakerWork: It's user is : engineer, hacker, scientist, not general user.
10:33:12 <ManateeLazyCat> PeakerWork: I need control everything with my style.
10:33:39 <PeakerWork> ManateeLazyCat: in theory, you could modify KDE/Gnome (opensource)
10:33:44 <ManateeLazyCat> PeakerWork: If not those limit, you can got variant application with many different behaviour.
10:33:54 <cadabra> class Foo a; class Bar a where foo :: a -> Foo
10:34:06 <Lemmih> cadabra: What you've posted is not valid Haskell and you haven't asked a question yet.
10:34:11 <PeakerWork> cadabra: if "Foo" is a class you can't use it like a type
10:34:19 <ManateeLazyCat> PeakerWork: Key is style, my project is Emacs version of Gnome. :)
10:34:19 <PeakerWork> cadabra: You mean: data Foo a; ...
10:34:30 <cadabra> I know it's not valid, it's pseudo explaining what I'm trying to do.
10:34:52 <PeakerWork> ManateeLazyCat: Emacs and Gnome do very similar things in very different ways, I see
10:34:54 <cadabra> How can I return a value that implements a specific class but leave the type of the value unspecified?
10:35:19 <PeakerWork> cadabra: class Bar a where foo :: Foo b => a -> b
10:35:20 <ManateeLazyCat> PeakerWork: I try to shut up before i release it, so many people don't like me .... now
10:35:27 <PeakerWork> ManateeLazyCat: heh
10:35:35 <PeakerWork> ManateeLazyCat: it sounds like an interesting project :)
10:36:10 <ManateeLazyCat> PeakerWork: Source code at https://patch-tag.com/r/AndyStewart
10:36:24 <ManateeLazyCat> PeakerWork: Need https://patch-tag.com/r/AndyStewart/gio-branch/home to compile it.
10:36:37 <ManateeLazyCat> PeakerWork: I will merge gio-branch to gtk2hs main repository in this weekend.
10:36:45 <ManateeLazyCat> PeakerWork: Then just need gtk from hackage.
10:37:46 <PeakerWork> ManateeLazyCat: I wish you used github/git :)
10:37:55 <Wolfspaw> Is there already a "safe" (!!), which result is a Maybe a? something like:
10:37:58 <Wolfspaw> (!) x y = if ((length x > y) && ( y>=0 )) then Just (x !! y) else Nothing
10:38:04 <Lemmih> cadabra: You wouldn't really do it like that in Haskell.
10:38:24 <PeakerWork> Wolfspaw: I don't know of one but I write: safeIndex n = listToMaybe . drop n
10:38:28 <ManateeLazyCat> I'm looking for developer that interested my project, it's still very alpha and buggy, but it will give you chance to implement your own operating system, welcome join! :)
10:38:43 <PeakerWork> ManateeLazyCat: It's a "desktop environment" IMO and not an "operating system" :)
10:38:49 <ManateeLazyCat> PeakerWork: Darcs is enough, just patch-tag.com is not good enough. :)
10:38:59 <PeakerWork> ManateeLazyCat: I think git is much better than darcs
10:39:10 <Wolfspaw> PeakerWork: hm, nice. Alright xD
10:39:12 <ManateeLazyCat> PeakerWork: I call it ILE
10:39:31 <ManateeLazyCat> PeakerWork: ILE is first step, then build go deeply....
10:40:07 <copumpkin> cadabra: if you really wanted to (I advise against it), you can use an existential wrapper type with a class constraint on the wrapped type, and return that
10:41:08 <cadabra> Let me try a different approach. Here's C++. How would I do this? struct foo{ virtual int x() const; }; struct bar{ virtual foo *y() const; };
10:41:36 <copumpkin> cadabra: what we're saying is that translating little idioms from one language to another isn't going to give you good code in the new language
10:42:15 <cadabra> Okay, what's the idiomatic way to achieve something like this?
10:42:16 <copumpkin> cadabra: having said that, just do what I said. data X = forall a. SomeStuffICareAbout a => X a; myfunction :: ... -> X
10:42:30 <copumpkin> you haven't said what you hope to achieve, only the tool in the language you know that you hope to achieve it by
10:42:32 <ManateeLazyCat> Ok, talk enough, i need coding now. Bye all! :)
10:42:44 * BMeph would say the git is much BIGGER than darcs; not too sure about if it's better. Git works faster, that's for sure; maybe faster is essential, though.... :\
10:43:39 * ManateeLazyCat Why not improve darcs make it better than git?
10:43:44 <tab> BMeph: is your repository packed ?
10:46:41 <BMeph> tab: As in "has it had the 'pack' command run on it", or is it compressed, or both", or what? (Never used git outside of github, BTW).
10:46:57 <cadabra> copumpkin: Here's my understanding. What C++ virtual and Haskell class provide is external extensibility. Someone can implement my interface and pass me a value and I don't have to know about it. How can I write a class that has a function that returns a set of values that all are instances of a different class?
10:47:32 <copumpkin> haskell classes don't really work that way, without an existential wrapped around them
10:47:56 <copumpkin> anyway, I've told you twice how to do that
10:48:06 <copumpkin> but again, I think you're going about it the wrong way :)
10:48:34 <tab> BMeph: you can run git gc --aggressive, it will pack the repository smaller and more efficient
10:48:52 <copumpkin> your question is "how do I do the common OO pattern X to achieve (unnamed) Y in haskell?" rather than "how do I achieve Y, idiomatically, in haskell?"
10:48:57 <tab> BMeph: on your own local repository
10:49:37 <copumpkin> cadabra: you'll find that although there is a superficial similarity between some concepts in haskell to concepts in other languages, they really are quite different and are typically not used in the same way
10:50:37 <ManateeLazyCat> Good night! :)
10:50:46 <Cale> cadabra: The right way to think about what Haskell typeclasses do is that they constrain the types over which type variables range. For example, a function for sorting a list can't have type [a] -> [a], because not all types have an ordering comparison defined. So we put the comparison operations into a typeclass Ord, and say that sort :: Ord a => [a] -> [a]
10:51:25 <Cale> This means that for any type a that implements the ordering operations, sort will take a list of values of type a, and produce a list of values of the same type.
10:52:01 <copumpkin> cadabra: all your rephrasings of your question are still basically asking "how can I achieve the existential OO-interface behavior in haskell", which as I've said, is possible, but isn't the way we typically approach problems. So if you want to have a more enjoyable haskell experience, I'd suggest taking a step back and thinking more broadly about the problem, instead of
10:52:09 <copumpkin> thinking of how you'd solve it in C++ and trying to translate
10:52:37 <cadabra> Okay, you're absolutely right.
10:53:25 <Cale> cadabra: If you want a type defined by a specific set of operations, note that functions are first class. You can simply pre-apply all the operations you have to the specific value, and record the results. (Lazy evaluation will ensure that they'll only be computed if they're needed anyway)
10:54:01 <copumpkin> having said that, we still do use that pattern in some cases, but mostly in bindings to existing OO-ish libraries like gtk2hs
10:54:03 <Cale> For example, if all that you care about is that there's a way to turn your values of different types into Strings, then you can just use Strings directly, and it's the same thing.
10:54:24 <BMeph> tab: Are you assuming that when I say "git is bigger than darcs" that I meant "git <repositories> are bigger than darcs <repositories>", instead of "git <the program> is larger, not so much in its physical outlay on the HDD, as in the scope of its problem space solutions and the particular scenarios to which it is applicable as a partial solution, than is darcs <the program", which is what I really meant, and would have said, if it d
10:55:22 <Cale> In the more interesting case, the result will be a function, but if you have almost any bunch of operations, you can bundle the results of applying those operations to your value into a record, and you get a uniform interface for values supporting those.
10:55:29 <tab> BMeph: yes i assumed you're talking about the size of the repositories
10:56:29 <FSalad_III> hmm shouldn't the list widget in vty_ui really be using a zipper rather than list + integer index? I don't understand the terminal rendering parts yet so I'm hesitant to change it...
10:56:44 <FSalad_III> but it seems like even moving the cursor would take O(current position) currently
10:56:59 <FSalad_III> err nvm, moving doesn't change the list :)
10:57:24 <Cale> For example, if you're writing a game, an object on the screen might have an IO action for drawing, a way to test if some point is in the object or not (for collision detection, say), and a way to produce the object for the next frame.
10:57:26 <copumpkin> dcoutts: can you elaborate on the test question about heap profile you mentioned in the blog post on hiring haskellers? by heap profile, are you talking about what gets evaluated and where we'd expect to find thunks and space leaks?
10:57:34 <Cale> (This is oversimplified, but it's just an example)
10:57:40 <Cale> You might have:
10:58:00 <FSalad_III> but it'd be an asymptotic game for rerendering, or am I missing something
10:58:04 <FSalad_III> *gain
10:58:14 <Cale> data GameObject = GO { draw :: IO (); pointIn :: Point -> Bool; next :: TimeStep -> GameObject }
10:58:31 <FSalad_III> (zipper a vs (Int,[a]))
10:58:34 <Cale> and then let's say you want an accelerating circle:
10:59:27 <FSalad_III> another zipper question: am I missing something or is it straightforward to make circular list zippers?
10:59:28 <Cale> (er, those should be commas, not semicolons :P)
11:00:04 <EvanR-work> i get that mixed up all the time
11:00:37 <Cale> myCircle r x v a = GO { draw = drawCircle r x, pointIn p = magnitude (p .-. x) < r^2, next = myCircle r (x .+. v) (v .+. a) a }
11:01:12 <Cale> Er, sorry about that, pointIn = \p -> magnitude ...
11:01:17 <FSalad_III> thinking of: ListWidgetZipper = { l, lVisible, rVisible, r :: [a] } 
11:01:40 <Cale> You can also conveniently use RecordWildCards for this:
11:01:42 <FSalad_III> (nonoverlapping)
11:01:49 <Cale> myCircle r x v a = GO { .. }
11:01:55 <Cale>   where ... define fields here ...
11:02:13 <Cale> cadabra: Make sense?
11:02:20 <EvanR-work> Cale: { draw :: [IO ()]; ... now its animated ;)
11:02:29 <dcoutts> copumpkin: hia, yes though it's useful for us to not reveal the full details since we might like to use it again
11:02:38 <Cale> EvanR-work: It's already animated. draw draws the object at the current time
11:02:48 <copumpkin> dcoutts: I figured you didn't want to reveal the entire thing, but I just didn't quite understand what you meant there :)
11:03:07 <copumpkin> anyway, interesting blog post, thanks :)
11:03:08 <Cale> EvanR-work: the idea is that the game loop will use 'next' to get the next version of the object after each time step
11:03:09 <EvanR-work> Cale: eh... how do you get current time?
11:03:35 <Cale> (actually, I contradicted myself in that I intended that next take a parameter indicating how long it's been since the last frame, but I left that out)
11:03:35 <dcoutts> copumpkin: ok, so we asked people to look at the program and to say what shape they thought the heap profile would look like, how the significant points in the profile would correspond to program events.
11:03:44 <copumpkin> ah okay
11:03:54 <dcoutts> copumpkin: ie the profile that you get from the ghc profiling tools, we also got them to run the profiler
11:04:00 <EvanR-work> Cale: a parameter for how long its been since the last 'frame' is not a good way to do main loops
11:04:01 <copumpkin> makes sense, I see
11:04:17 <Cale> next = \t -> myCircle r (x .+. (t *. v)) (v .+. (t *. a)) a
11:04:26 <dcoutts> copumpkin: but initially the question was about what they thought it would look like, without running it
11:04:26 <EvanR-work> instead you should use a fixed time step and sample the sequence for when you would like to display
11:04:32 * sm now has a pretty slick ghc+cabal+wine+mac setup
11:04:41 <EvanR-work> then the evolution is deterministic
11:04:45 <EvanR-work> and not frame-dependent
11:04:51 <copumpkin> dcoutts: yeah, I think that's a useful thing to ask too
11:04:54 <copumpkin> cool :)
11:05:01 <EvanR-work> and you can more easily control differential motion
11:05:03 <Cale> EvanR-work: Well, that's even simpler
11:05:24 <dino-> dcoutts: Thanks for posting that info about the hiring process. This is valuable information.
11:05:49 <dcoutts> dino-: sorry it's taken so long to post
11:05:53 <c_wraith> If you have true time-varying parametric descriptions of the behavior of all your objects, you can just update based on the time since the last frame.
11:06:02 <copumpkin> next up, "hack the well-typed hiring progress" blog post, from someone else :P
11:06:09 <dino-> dcoutts: no no, you guys have clearly been busy. Hiring is a big job.
11:06:11 <EvanR-work> Cale: youre right about the list of IO thing, in any case a new version of *something* will need to be generated by the IO code
11:06:30 <EvanR-work> whether its a tail of a list, a pointer, or the next state of state machine
11:06:38 <c_wraith> But that doesn't work so well often, because things like "did he jump high enough to make it to that ledge?" are quite unnatural to encode purely parametrically.
11:06:56 <FSalad_III> if anyone cares about zippers :p how about: data CyclicZipper a = CZ [Either Sep a] [Either Sep a]; data Sep = Sep
11:07:00 <Cale> Oh, cadabra's connection died :P
11:07:12 <augur> Cale: question about composition of arrows as functions between sets: is it the case that if i have f : X -> Y, g : Y -> Z, h : X -> Z, that forall x in X, (g.f) x == h x?
11:07:13 <copumpkin> I was tempted to apply, but the time didn't work very well for me, and I'm kind of glad I didn't, in retrospect, given that I'd have been excluded automatically :P
11:07:18 <c_wraith> Hence in older versions of quake, for instance, clamping your frame rate to multiples of the time it takes for your jump to reach peak height.
11:07:23 <FSalad_III> the 'Sep' is to remember the actual start of the cycle
11:07:35 <Cale> If he comes back, point him at http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
11:07:39 <dcoutts> dino-: yes, surprisingly time consuming. I'm still somewhat astounded at the number of excellent applications. Making the shortlist was really hard.
11:07:46 <FSalad_III> (which you'd need for a list widget, even if it's supposed to have cyclic scrolling ;))
11:07:57 <FSalad_III> s/scrolling/cursor movement/
11:08:03 <Cale> augur: No.
11:08:12 <c_wraith> By choosing your max framerate carefully, there were some jumps you could make in quake that you couldn't otherwise, because whether you could jump onto a ledge depended on your frame rate.
11:08:32 <augur> Cale: ok, just checking.
11:08:37 <copumpkin> augur: arrows still have an "identity"
11:08:53 <EvanR-work> c_wraith: basically 'variable dt' leads to unreproducible behavior, and big jumps leads to errors in a posterior collision detection. you can avoid that by having a max step and doing a big step in many small steps, but that basically what a constant step duration is anyway
11:09:01 <copumpkin> in the sense that they can be distinguished, despite being between the same objects
11:09:08 <augur> so when we say that (g.f) ~ h, what we mean is in terms of the dom and cod of each
11:09:13 <EvanR-work> quake (tm) was definitely screwed up in its main loop methodology
11:09:16 <Cale> augur: Let X, Y, and Z all be the real numbers, and take f to be the function which sends x to x + 1, and g be the function which sends x to x^2. Then g . f is the function which sends x to (x + 1)^2, and there are plenty of functions h: R -> R which are not that function.
11:09:18 <augur> strictly speaking
11:09:33 <Cale> augur: What is ~ here?
11:09:54 <EvanR-work> and people read quake in order to 'learn how the pros do it' and are mislead
11:10:02 <augur> Cale: well, i know that its possible to construct such functions where g.f != h, but i was just curious if the arrow diagrams intended this or that
11:10:29 <Cale> EvanR-work: You should always detect collisions ahead of time anyway ;)
11:10:29 <aristid> EvanR-work: what specifically do you mean?
11:10:35 <c_wraith> EvanR-work, you could *also* fix it by making everything properly independent of the size of dt.  That is an overall better approach, but it requires a LOT more math to get right.
11:10:37 <EvanR-work> Cale: yeah... right xD
11:11:03 <EvanR-work> Cale and c_wraith these ideas are ahead of me by lightyears ;)
11:11:17 <Cale> augur: If we say that the diagram formed by those arrows commutes, then it means that g . f = h
11:11:23 <copumpkin> you know what I hate? how read => read but lead => led
11:11:24 <c_wraith> early quake games discovered that getting it right wasn't nearly as important as getting it fast.  Anyone who reads quake source without remembering that is doomed. :)
11:11:39 * monochrom red copumpkin
11:11:45 <augur> Cale: by ~ i meant that like.. theres the law that if f : X -> Y, and g : Y -> Z are in a category, you also have (g.f) : X -> Z in the category, so i meant that ~ is the relation between a composition of two arrows and some third arrow that is also between the relevant things
11:11:47 <EvanR-work> aristid: they have a convoluted mechanism to separate 'graphics frames' from 'physics frames'
11:11:54 <c_wraith> so... monochrom's single color is red.  got it.
11:11:57 <EvanR-work> which does not need to be that complex
11:12:13 <augur> but actually i take it that just because you might have h : X -> Z doesnt mean that h is that arrow (g.f)
11:12:37 <monochrom> be consoled that read is pronounced as red
11:12:45 <Cale> augur: right, there might be many arrows X -> Z
11:13:05 <Cale> augur: If you happen to know that there's only one, then you can conclude that the diagram commutes
11:13:07 <monochrom> indeed lead is pronounced as led too :)
11:13:09 <augur> Cale: yah. thats where i was a wee stuck. im still not clear on the ideas here. :p
11:13:27 <EvanR-work> originally based on DOS where youd think that main loops would be simpler
11:13:32 <Cale> augur: Just think of the category of Haskell types and functions.
11:13:41 <zygoloid> monochrom: not as a verb at least :)
11:13:46 <augur> Cale: noooo i know its just hard to do that translation online
11:13:51 <aristid> EvanR-work: physics frames? oO
11:13:56 <EvanR-work> aristid: yes
11:14:12 * monochrom wonders if there was too much lead in plumbing when people designed English.
11:14:19 <lambdor> what is the correct term for the thing you get when you call a constructor of a data?
11:14:19 <Cale> augur: If we have g: Integer -> String, and f: String -> Bool, then f . g :: Integer -> Bool
11:14:22 <EvanR-work> basically they make a distinction between actually 'doing physics' and 'interpolating'
11:14:27 <zygoloid> monochrom: it's called plumbing for a reason
11:14:33 <monochrom> hahaha
11:14:37 <augur> monochrom: there was rarely any lead in plumbing after the romans, and noone designed english.
11:14:48 <aristid> EvanR-work: so they don't need to do physics in every frame?
11:15:07 <EvanR-work> of course they do
11:15:12 <Cale> augur: and there are lots of functions of type Integer -> Bool, so if you have an arbitary function of that type, the chance is not so good that it'll be equal to f . g
11:15:12 <EvanR-work> they just dont call it that
11:15:19 <zygoloid> monochrom: i propose we rename lead-the-element back to plumbum, rename read-the-past-tense to red, and rename red-the-colour to rouge
11:15:20 <c_wraith> aristid, physics frames were ones that tested for collisions of all the various sorts.  Whether you were standing on a given surface.  whether a projectile had hit.  etc, etc.
11:16:17 <EvanR-work> the graphics frame rate of quake is not fast enough to make that matter
11:16:17 <mauke> zygoloid: and what do you rename rogue to?
11:16:36 <zygoloid> mauke: it's not typo-proof :)
11:17:09 <EvanR-work> if you interpolate the position of something to make it move, but you cant see it, who cares?
11:17:26 * zygoloid cares
11:17:49 <EvanR-work> but its linear interpolation, you can just combine the in between updates into one update
11:18:04 <Saizan> but, more importantly, what sound does it make?
11:18:19 * zygoloid imagines planets on polygonal orbits
11:18:49 <EvanR-work> objects following a path doesnt require integration
11:18:55 <EvanR-work> you just calculate where on the path it is
11:18:57 <sproingie> htrae probably follows a square orbit
11:19:35 <EvanR-work> theres no closed form for many paths in platform games, so you integrate instead
11:19:36 <sproingie> actually the sun probably revolves around htrae
11:20:22 <augur> ok im off Cale, see you in a bit
11:21:11 <EvanR-work> Cale: i read about a priori collision, but this seems very complex when dealing with simple rectangles moving, much less cubes with rotation :(
11:26:14 <copumpkin> (I've said this before, but let me repeat it!) I wish people would go back and rerender their old shitty .ps latex output to pdf! http://www.eecs.usma.edu/webs/people/okasaki/jfp98.ps
11:26:53 <EvanR-work> which is just old shitty ps with scripting removed xD
11:27:14 <copumpkin> well, my main point is about having actual text in there, and not pixels
11:27:20 <copumpkin> which you'll see if you zoom in far enough
11:27:41 <EvanR-work> problem with the ps rendering?
11:27:43 <stefan____> cupumkin, windows? install freePDF
11:27:46 <Cale> Well, that's a particularly poor postscript document.
11:27:47 <dino-> copumpkin: Is the issue really the viewer, as in, idiot Adobe official reader won't display .ps?
11:28:09 <dino-> I use Okular in Linux, which does it all!! Including letting you set bookmarks.
11:28:13 <copumpkin> Cale: exactly :) I don't mind .ps, but I do mind shitty .ps
11:28:14 <stefan____> cumpukin, converts ps to PDF on-the-fly. so you can directly download .ps and view it
11:28:22 * BMeph would rather call the colour "rot", or maybe "rose", and call "rot" the verb "decay". :)
11:28:40 <Cale> I have seen worse though.
11:28:41 <copumpkin> stefan____: oh, my issue is that the .ps (in this case and others) doesn't contain that information in the first place
11:28:52 <copumpkin> it's not so much about format as the information inside it
11:29:05 <zygoloid> BMeph: is that danish?
11:29:24 <Cale> I'm pretty sure I've seen postscript documents with selectable text.
11:29:46 * BMeph wishes there were a web site where you could give it the location of a ".ps" file, and it would make ".djvu" file(s) for you...
11:29:56 <copumpkin> Cale: definitely, and even something with these shitty pixels could have selectable text. I'm mostly annoyed at the rendering rather than the selctability, though
11:30:05 <copumpkin> the fact that the text is actually rasterized
11:30:29 <copumpkin> http://snapplr.com/w3xs
11:31:00 <Botje> antialiasing? what's that?
11:31:04 <copumpkin> I don't _think_ that's my viewer
11:31:51 <EvanR-work> well there would be no way to convert that type of document back to vector
11:31:58 <copumpkin> I know :P
11:32:14 <EvanR-work> OCR -> pdf ;)
11:32:15 <copumpkin> that's why I'm asking for the original authors to go back and rerender their latex
11:32:21 <copumpkin> (my original wish)
11:32:48 <BMeph> zygoloid: German/Dutch. ;)
11:32:48 <Cale> Better yet, why not just put the original latex online so that people could re-render it themselves if they wanted to.
11:33:03 <copumpkin> Cale: even better! I'm not sure why that isn't a more common practice
11:33:18 <EvanR-work> because its closed source!
11:33:24 <copumpkin> make the source to your programs AND documents available :)
11:33:28 <EvanR-work> would want anyone editing the document would you
11:33:31 <EvanR-work> wouldnt
11:33:33 <Botje> because latex is a crap document exchange format
11:33:48 <copumpkin> Botje: I agree, but c is a crap program exchange format too :P
11:33:50 <Cale> Maybe they're embarrassed to show other people their ugly macros ;)
11:34:01 <copumpkin> Botje: it'd just be nice to have the option of rerendering it nciely
11:35:25 <EvanR-work> Cale: i noticed thats 99% of the reason for not releasing the source (in personal projects like papers or hobbies)
11:52:35 * BMeph notices that people seem to spend a LOT of time imagining that they are on the minds of other much more than is true, without noticing that those others are not on those others' minds too much either -- well, other than as a source of potential worry... ;)
11:53:24 * BMeph thinks he lost track of which "others" are OTHER others...
11:56:55 * ddarius thinks BMeph might be projecting.
11:57:47 * BMeph thinks he is projecting about projecting...how recursive! ;þ
11:57:48 * Cale notices that he doesn't have any idea what BMeph is talking about :)
11:58:08 <copumpkin> what if ddarius is projecting his projections onto BMeph ??
11:58:41 <Cale> Guys, which inner product are we using?
11:59:09 <aRcatan> :D
11:59:36 <Adamant> recursion. the source of, and answer to, all of life's intellectual problems.
11:59:55 <Adamant> </HomerSimpson>
12:02:37 <aRcatan> hmm, it's always a bad sign when I mistake #haskell for -blah
12:04:22 <tafryn> What is the best way to do logging?
12:04:33 <copumpkin> chainsaw
12:04:41 <copumpkin> it really beats axes or hand saws
12:05:03 <copumpkin> tafryn: maybe a Writer, though :)
12:05:04 <Botje> copumpkin++ #haha
12:05:22 <JoeyA> What's a good design pattern to use in Haskell for dealing with actions that come with various events?
12:05:31 <JoeyA> For instance, consider adding files to an archive.
12:05:47 <tafryn> copumpkin: A Writer?
12:05:48 <JoeyA> If you didn't care about progress, you could just use IO () to denote the type of action.
12:06:02 <JoeyA> (and if something goes horribly wrong, an exception can be thrown)
12:06:10 <copumpkin> tafryn: it's a handy monad that lets you spit stuff out :) you'd probably want a Writer on difference lists for efficiency
12:06:13 <Cale> JoeyA: IO Progress -> IO () ?
12:06:22 <Cale> er
12:06:30 <Cale> sorry  (Progress -> IO ()) -> IO ()
12:06:49 <tafryn> copumpkin: Is this not preferred: http://hackage.haskell.org/packages/archive/hslogger/1.0.7/doc/html/System-Log-Logger.html
12:06:53 <JoeyA> Well, I'm trying to think more generally with this.
12:07:31 <Cale> With the intention being that it executes the given action whenever it wants to update the progress.
12:07:48 <Cale> You could also pass in other continuations, like what to do with a failure.
12:07:50 <JoeyA> For instance, progress events typically warrant updating something on the screen; a callback would suffice.  Exceptions call for the whole program to die.  Then you have other types of events.
12:08:10 <copumpkin> tafryn: I guess :)
12:08:42 <JoeyA> I guess working with continuations sort of makes sense.
12:09:14 <JoeyA> Something like (Progress -> IO () -> IO ()) -> IO (), where the 2nd argument to the callback is the continuation.
12:09:22 <JoeyA> (err, not Progress, Event)
12:09:46 <Cale> Oh, well, you could work it that way as well.
12:10:01 <aRcatan> somebody asked sometime ago how to tweet with Haskell and OAuth (can't remember who). here's a way, anyway: http://gist.github.com/548120
12:10:44 <Cale> JoeyA: Of course, for exceptions, there's Control.Exception
12:11:11 <JoeyA> But some of the error-handling doohickeys might need to penetrate more deeply, as in: if getting the current directory fails, ascend to the root, descend back toward the path we failed at, and resume when we can't descend any further (or if we do make it all the way down).
12:24:22 <copumpkin> preflex: seen sw17ch
12:24:22 <preflex>  sw17ch was last seen on #haskell 83 days, 15 hours, 38 minutes and 36 seconds ago, saying: his book prices shock me
12:30:52 <FSalad_III> . o O ( turqoise hexagon orbit )
12:33:35 * hackagebot sifflet-lib 1.1 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-1.1 (GregoryWeber)
12:35:35 * hackagebot sifflet 1.1 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-1.1 (GregoryWeber)
12:44:15 <enigmus> Is there a builtin function to do a "foreach aux list", with aux :: [a] -> IO () ?
12:44:41 <EvanR-work> eh?
12:44:45 <Zao> mapM?
12:44:47 <EvanR-work> :t forM_
12:44:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
12:44:48 <Zao> Or rather, mapM_
12:45:10 <BMeph> mapM_ ? ;)
12:45:16 <Zao> What's forM_? flip mapM?
12:45:20 <Zao> @src forM_
12:45:21 <lambdabot> forM_ = flip mapM_
12:45:21 <EvanR-work> yes
12:45:25 <Zao> How useless :D
12:45:42 <enigmus> Thanks
12:45:44 <EvanR-work> id rather put the body of the for loop at the end rather than the middle xD
12:46:01 <EvanR-work> you often have to flip runState or flip runReader for that reason
12:47:58 <JoeyA> > flip zip [1,2,3] [4,5,6]
12:47:59 <lambdabot>   [(4,1),(5,2),(6,3)]
12:48:45 <EvanR-work> flip zip slap crap wrap
12:49:07 <stefan____> > flip zip slap crap wrap
12:49:08 <lambdabot>   Not in scope: `slap'Not in scope: `crap'Not in scope: `wrap'
12:49:59 <JoeyA> > uncurry (zipWith $ flip (,)) $ unzip $ flip zip [1,2,3] [4,5,6]
12:50:00 <lambdabot>   [(1,4),(2,5),(3,6)]
12:50:09 <JoeyA> @pl uncurry (zipWith $ flip (,)) $ unzip $ flip zip xs ys
12:50:09 <lambdabot> uncurry (zipWith (flip (,))) (unzip (zip ys xs))
12:50:26 * ddarius reads the undocumented features documentation.
12:50:47 <mee> b-but...
12:52:05 <monochrom> it documents those that don't document themselves
12:52:56 <EvanR-work> also, it documents itself
12:55:55 <JoeyA> Does Haskell have any cheat codes?
12:56:14 <mauke> yes, unsafePerformIO
12:56:15 <ddarius> unsafeCoerce.
12:56:27 <mauke> unsafePerformIO being more powerful
12:56:43 <ddarius> They are equipotent.
12:56:45 <JoeyA> > unsafeCoerce 1000 :: IO String
12:56:46 <lambdabot>   Not in scope: `unsafeCoerce'
12:57:10 <EvanR-work> lol
12:57:16 <benmachine> you can implement unsafePerformIO with unsafeCoerce?
12:57:31 <EvanR-work> a working unsafePerformIO*
12:58:26 <JoeyA> @m lambdabot @let me x y = "Cheat Enabled"
12:58:26 <lambdabot> Maybe you meant: map messages messages? more msg . ? @ v
12:58:33 <zearen> Excuse me, is there a way to take a pattern and something and return a Bool?  E.g. if (Right _) =~ thing then ...
12:58:36 <JoeyA> daggummit
12:58:50 <mauke> JoeyA: fmap fix return
12:58:56 <EvanR-work> zearen: regex? blah
12:59:10 <c_wraith> zearen, you could use a case statement with a guard
12:59:11 <mauke> zearen: not directly
12:59:29 <Cale> case thing of (Right _) -> True; _ -> False
12:59:32 <mauke> if (case thing of Right _ -> True; _ -> False) then
12:59:50 <EvanR-work> oh
13:00:03 <zearen> Not directly, that's what I needed to know, thanks.
13:00:46 <EvanR-work> pattern matching isnt first class?
13:01:06 <monochrom> haskell cheat codes? like if you type in "steak cheesy jimmy" you will get an extra 50MB of heap space?
13:01:16 <kmc> i think that's +RTS -A800M
13:01:25 <kmc> it would be reasonable to call RTS options "cheat codes"
13:01:31 <monochrom> hehe
13:01:35 <EvanR-work> iddqd
13:01:41 <EvanR-work> now you cant have type errors
13:01:45 <EvanR-work> at runtime
13:01:59 <copumpkin> kmc: how did bostonhaskell go?
13:02:01 <copumpkin> or has it not happened yet?
13:02:03 <kmc> pattern matching isn't first class :/
13:02:05 <kmc> copumpkin, went ok
13:02:32 <copumpkin> what would you consider first-class pattern matching? explicit eliminators?
13:02:51 <kmc> dcoutts, thanks for posting the hiring retrospective, it's quite interesting
13:03:33 <EvanR-work> copumpkin: probably something like what zearen wanted
13:03:45 <copumpkin> oh, I missed it
13:04:12 <EvanR-work> scroll on up
13:04:19 <c_wraith> I want anonymous pattern matching.  Which sounds like it would be a side-effect of first-class pattern matching.
13:05:03 <chrisdone> just found an old paste, unicode SPJ anyone? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24930
13:05:14 <roconnor> > (\(a,b) -> b) (7,6)
13:05:15 <lambdabot>   6
13:05:20 <roconnor> ^^
13:05:26 <ddarius> c_wraith: Just use a bunch of Maybe functions and Maybe MonadPlus.
13:06:13 <kmc> what's anonymous pattern matching?
13:06:37 <dcoutts> kmc: glad you like it
13:07:17 <c_wraith> kmc: matching on patterns without having to name anything.  There are two sides of it with a traditional case statement.
13:07:31 <aristid> chrisdone: now that's putting utf-8 to good use.
13:07:34 <c_wraith> kmc: first would be eliminating \x -> case x of ... constructs.
13:07:38 <kmc> right
13:07:41 <kmc> \case of ...,
13:07:55 <JoeyA> Someone should make a module for askOnIRC :: String -> IO Codez
13:07:59 <kmc> oh, and then you want point-free elimination
13:08:04 <kmc> hehe JoeyA
13:08:06 <c_wraith> yes
13:08:15 <ddarius> That would be pretty easy to write.
13:08:19 <c_wraith> I don't want to have to name values if I'm just going to pass them to another function
13:08:19 <JoeyA> askOnIRC "lolcode FFI bindings for Haskell"
13:08:20 <kmc> askOnIRC :: (Typeable a) => String -> Maybe a
13:08:35 <copumpkin> Maybe [a], for the glorious stereo
13:08:43 <copumpkin> might as well just use [a] then
13:08:45 <JoeyA> or askOnIRC :: String -> Either Kick Codez
13:08:51 <kmc> \case of Just ~> succ; Nothing -> 0
13:09:14 <c_wraith> and admittedly, for most common types, there are combinators (maybe, either) for doing that sort of stuff.  But it'd be nice if case was flexible enough on its own.
13:09:18 <kmc> \case of (,) ~~> (+)
13:09:54 <benmachine> uncurry!
13:10:06 <kmc> right
13:10:18 <benmachine> kmc: sounds unpleasant to nest
13:10:53 <danewbie> has anyone made a newtyped Int an instance of the Elt class (from dph)?
13:11:04 <aristid> :t \x -> case x of Just -> 1; _ -> 0
13:11:05 <lambdabot>     Constructor `Just' should have 1 argument, but has been given 0
13:11:05 <lambdabot>     In the pattern: Just
13:11:05 <lambdabot>     In a case alternative: Just -> 1
13:11:59 <kmc> :t \x -> case x of Just{} -> 1; _ -> 0
13:12:00 <lambdabot> forall t t1. (Num t1) => Maybe t -> t1
13:14:41 <aristid> kmc: lame
13:19:54 <krey> hello, does anyone know some library that can draw graphs with labelled/coloured nodes and edges for me?
13:20:01 <kmc> graphviz
13:20:06 <kmc> there is a Haskell binding
13:20:18 <krey> thanks, lemme see
13:20:37 <EvanR-work> i wonder how close you can get haskell syntax to look like javascripts (doesnt have to function)
13:20:45 <krey> just what i'm looking for, thanks kmc
13:21:03 <danewbie> does anybody know how to load 2 packages that provide the same module?
13:21:18 <danewbie> is there a way to specify from which package should be picked?
13:21:38 <kmc> danewbie, GHC has an extension
13:21:41 <aavogt> you want to use both modules at the same time, danewbie?
13:21:44 <kmc> -XPackageImports
13:21:44 <danewbie> yes
13:21:50 <kmc> import "network" Network.Socket
13:21:59 <danewbie> aha
13:22:02 <danewbie> ok, thanks!
13:22:10 <kmc> usually preferred to let cabal sort this out, but if you want the same name from two packages you're kinda out of luck there
13:22:18 <danewbie> yes
13:22:45 <FSalad_III> c_wraith: "first class pattern-matching"? we have that as functions
13:22:53 <FSalad_III> like maybe, either
13:22:53 <kmc> let me guess... mtl / monads-fd / monads-tf / transformers ?
13:23:03 <danewbie> nice!
13:23:08 <danewbie> it works like a charm :-)
13:23:08 <JoeyA> When defining what a module exports, and you have data Foo = Foo Int, how do you indicate that you want to export the type Foo, but not the data constructor Foo?
13:23:09 <kmc> FSalad_III, but they are defined for each type, there's no general construct
13:23:16 <kmc> they could perhaps be derived or TH-generated
13:23:19 <c_wraith> FSalad_III, like I said: combinators exist for common data types, but it'd be nice if you didn't have to define them.
13:23:22 <kmc> JoeyA, module M(Foo)
13:23:28 <FSalad_III> TH, yes
13:23:36 <kmc> as opposed to «module M(Foo(..))» or «module M(Foo(Foo))»
13:23:58 <FSalad_III> there are two concepts here: a fold/catamorphism and a 'flat' eliminator
13:24:11 <JoeyA> So saying Foo(..) exports Foo and all of its constructors?
13:24:13 <FSalad_III> the latter should be really straightforward to TH
13:24:25 <JoeyA> Does it work for record syntax selectors?
13:24:33 <FSalad_III> the former gets a bit involved with GADTs and/or mutually recursive stuff
13:24:39 <Saizan> for generically defined folds and eliminators you can simply switch to epigram :P
13:24:40 <krey> kmc: what's the best way of installing it (GraphViz)? (arch)
13:24:42 <kmc> yes JoeyA
13:24:48 <JoeyA> cool, thanks
13:24:50 <kmc> krey, i don't use arch.  it should have a package though
13:25:01 <kmc> and then you can get the Haskell binding either from arch's package manager or from cabal install
13:25:14 <kmc> JoeyA, not sure about the selectors
13:25:14 <ezyang> Is there any documentation for Test.QuickCheck.Monadic? 
13:25:48 <kmc> teh source ;)
13:25:59 <ezyang> kmc: Bah 
13:26:03 <Itkovian> dcoutts: regarding the well-typed post, would you be willing to release the problem to the public, so those "beginners [that] end up floundering around with space leaks that they do not understand" can learn?
13:26:36 <kmc> books could be written on that topic ;)
13:26:59 <krey> kmc: there's a haskell-graphviz package in the AUR :), what do you use btw?
13:27:08 <kmc> deeeeeeebian
13:27:45 <djahandarie> kmc, yo how was the meet
13:27:52 <kmc> it was all right
13:28:28 <djahandarie> True, it would have been better if I were there
13:30:13 <kmc> ;)
13:30:26 * ddarius throws _ _ at the end of all his iso predicates.
13:58:21 <ezyang> Anyone have advice for writing Arbitrary instances of large and complicated data types? 
14:00:48 <Saizan> $derive them?
14:00:52 <danewbie> are the different parts of the data type independent?
14:01:04 <ezyang> danewbie: Nope. 
14:01:07 <danewbie> i mean, is there any constraint that you can't enforce
14:01:08 <danewbie> ok
14:01:08 <ezyang> Saizan: What's that? 
14:01:34 <Saizan> Data.Derive
14:01:56 <ezyang> Neaat 
14:01:56 <JoeyA> "<kmc> JoeyA, not sure about the selectors"  Yes, Type(..) does export selectors as well, so given data Type = Type {typeFoo :: Int, typeBar :: Int}, Type(..) will export typeFoo and typeBar, but Type without (..) will not.
14:02:13 <kmc> ok
14:05:51 <ezyang> Are newtypes the canonical way of allowing for multiple arbitrary instances? 
14:07:44 <copumpkin> yea
14:07:52 <ezyang> bleagh 
14:07:58 <Saizan> sometimes i just use forAll
14:08:00 <ezyang> I guess it makes sense. 
14:08:51 <ezyang> Does QuickCheck have knobs for adjusting the distribution of its random generators? 
14:09:15 <ezyang> For example, if you're recursively generating a structure you might not want an exponential distribution of sizes. 
14:10:20 <Saizan> iirc there are combinators specifically for that
14:10:36 <Saizan> QC1 manual has an example with trees
14:11:19 <ezyang> I guess there is the frequency combinator 
14:15:08 * hackagebot hslogger 1.0.11 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.0.11 (JohnGoerzen)
14:19:53 <JoeyA> Which package is better?  XAttr-0.1 or xattr-0.5.2 ?
14:20:14 <kmc> soon we will have the new social Hackage 2.0
14:20:20 <kmc> then you can tell by which one has more facebook friends
14:21:46 <Adamant> I for one welcome tired cliches that involve our privacy-destroying social overlords
14:21:59 <monochrom> "if Newton and Leibniz had Hackage 2.0 accounts..." http://spikedmath.com/286.html
14:22:53 <monochrom> in fact, "if dons and bos had Hackage 2.0 accounts".  <dons> I invented hackage. <bos> No, I did. ...
14:23:26 <sproingie> TWO MATHEMATICIANS ENTER, ONE MATHEMATICIAN LEAVES
14:26:57 <JoeyA> xattr-0.5.2 is better.  It uses ByteString instead of String.
14:27:25 <JoeyA> (for attribute values)
14:29:51 <Adamant> sproingie: break a deal, spin the n-dimensional wheel
14:30:26 <sproingie> no wammies
14:31:14 * hackagebot mute-unmute 0.1 - Watches your screensaver and (un)mutes music when you (un)lock the screen.  http://hackage.haskell.org/package/mute-unmute-0.1 (KrzysztofSkrzetnicki)
14:32:06 <bss03> sproingie, just choose an axis to spin on where the circle that represents all the possible pointer states doesn't intersect the points that are "whammies".
14:33:07 <sproingie> gotta wonder why that mathematical gameshow failed eh?
14:33:43 <dcoutts> Itkovian: there's nothing special about the problem that'd help beginners, some tutorial on understanding evaluation order would be much better for beginners
14:34:05 <Itkovian> dcoutts: true, but a problem allows us to see if we grok the tutorial
14:34:22 <Itkovian> think of it as an exam :-)
14:34:36 <dcoutts> Itkovian: we'd rather not give out the exam paper, we might like to use it again :-)
14:34:46 <Itkovian> OK, sure.
14:35:26 <Itkovian> I could but ask, eh 
14:36:40 <aristid> @src unfoldr
14:36:40 <lambdabot> unfoldr f b  = case f b of
14:36:40 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
14:36:40 <lambdabot>    Nothing        -> []
14:37:15 <ddarius> Itkovian: Just apply for the job next time.  Lie like crazy on your resume, if necessary.  Then turn down the job after the interview.
14:37:30 <copumpkin> ddarius: is that how you do it?
14:37:42 <Itkovian> Right. I don't lie, so that's a failing strategy.
14:37:56 <copumpkin> @pl \(Just (a,new_b)) -> a : unfoldr f new_b
14:37:56 <lambdabot> (line 1, column 8):
14:37:57 <lambdabot> unexpected "("
14:37:57 <lambdabot> expecting operator or ")"
14:38:03 <Itkovian> ddarius: the odds are I would not get through the interview anyhow :-)
14:38:17 <kmc> no no you should work for KAZAKHTELECOM http://cufp.org/jobs/programmer
14:38:20 <ddarius> Itkovian: That's irrelevant.  The goal is to see the problem.
14:38:23 <Itkovian> having a PhD is on my side, excelling at haskell is not. (yet).
14:38:39 <copumpkin> omg I want to work for KAZAKHTELECOM
14:38:46 <ddarius> If you did actually get the job, lying on your resume would be grounds for termination but is otherwise not illegal (in the US).
14:38:49 <Itkovian> kmc: I've seen Borat. No thx :-D
14:39:14 <kmc> do it copumpkin 
14:39:21 <kmc> it's not even near the capital
14:39:26 <kmc> it's in bumblefuck kazakhstan
14:39:28 <Itkovian> ddarius: OTOH, if you get a job, and you lied, then the interviewers did not do their job well.
14:39:31 <copumpkin> mmmm
14:39:33 <Igloo> ddarius: Is it not fraud or something, OOI?
14:39:44 <Itkovian> kmc: And I do not shag my sister.
14:39:57 <kmc> kind of close to russia though
14:40:00 <Itkovian> Igloo: It prolly is for a public job
14:40:02 <kmc> you can go to Chelyabinsk on holiday
14:40:03 <sproingie> kazakhstan you very nice place
14:40:22 <Itkovian> kmc: My geography in those parts is sorely lacking
14:40:23 <ddarius> Igloo: A resume is not a legal document, but as I said, it is grounds for termination and could potentially have other repercussions if you did accept the job.
14:40:55 <ddarius> A job -application- that you -sign- though, is a legal document and it would be illegal to lie on that.
14:42:08 <megajosh2> A quiet channel with over 600 users
14:42:12 <megajosh2> Now that's what I call irc
14:42:18 <kmc> we had 666 users  the other day
14:42:24 <Igloo> Surely you don't have to sign a contract to commit fraud
14:42:24 <megajosh2> :O
14:42:28 <kmc> also it was active before you showed up ;P
14:42:48 <ddarius> Igloo: I'm pretty sure you'd have to receive some benefit.
14:43:14 <Igloo> The benefit would be getting the job
14:43:47 <Heffalump> and being paid
14:43:53 <copumpkin> mmm money
14:43:59 <ddarius> Igloo: Indeed. And as I said, upon getting the job, having lied on your resume can have negative consequences, but I don't believe it is fraud simply -submitting- a resume.
14:44:01 <Heffalump> that'd be "obtaining pecuniary advantage by deception" in this country.
14:44:11 <copumpkin> ooh, fancy
14:44:18 <copumpkin> I enjoy pecuniary advantage greatly
14:44:21 <Heffalump> Some journalists have been prosecuted in this country for faking CVs to get undercover jobs for exposes.
14:44:50 <Igloo> Heffalump: So is "attempted obtaining pecuniary advantage by deception" a crime too?
14:44:51 <ddarius> In short, lying to get a job is illegal, lying to get an interview is not under typical circumstances.
14:45:24 <Heffalump> Igloo: probably, yes. But if the applicant had no intention of accepting, then they wouldn't be committing that crime.
14:45:59 <JoeyA> I sort of get the feeling I'm not "doing it right" with this code:  http://codepad.org/YeBuP7Nr
14:46:16 <Igloo> WP tells me that actually no longer exists here. At least, I think that's what it tells me; it isn't very clear
14:47:20 <JoeyA> I guess if that's what it takes to map that many fields, than that's what it takes.
14:51:17 <aristid> @ty fix (\r f b -> maybe [] (\(a,b') -> a : r f b') $ f b)
14:51:18 <lambdabot> forall a t. (t -> Maybe (a, t)) -> t -> [a]
14:51:52 <copumpkin> @pl fix (\r f b -> maybe [] (\(a,b') -> a : r f b') $ f b)
14:51:53 <lambdabot> fix (join . (((.) . maybe []) .) . flip flip snd . (ap .) . flip flip fst . (((.) . flip ((.) . (:))) .))
14:51:56 <copumpkin> now that's more like it
14:53:58 <Bobbias> amusing, since i was just reading about pointfree style
14:56:25 <aristid> it's often possible to do MUCH better than @pl
14:56:42 <copumpkin> yeah ;)
14:56:52 <aristid> i have no clue how, in this case
14:57:27 <benmachine> probably using uncurry or curry for starters
14:58:13 <ezyang> Type inference is sooo awesome. 
14:58:16 <dolio> You're not going to eliminate f and still have something that looks nice.
14:58:23 <benmachine> @pl fix (\r f b -> maybe [] (uncurry $ \a b' -> a : r f b') $ f b)
14:58:23 <lambdabot> fix ((.) . maybe [] . uncurry . flip ((.) . (:)) =<<)
14:58:24 <aristid> @pl maybe [] (\(a,b') -> a : r f b')
14:58:24 <lambdabot> maybe [] (uncurry ((. r f) . (:)))
14:58:24 <copumpkin> :t \r f -> uncurry (:) . second (r f)
14:58:25 <lambdabot> forall t a (a1 :: * -> * -> *) b. (Arrow a1, Functor (a1 (a, b))) => (t -> a1 b [a]) -> t -> a1 (a, b) [a]
14:58:39 <aristid> benmachine: that improves matters
14:58:48 <benmachine> oh so pl *does* know about uncurry, odd
14:59:13 <dolio> It frequently seems to go out of its way to not use (un)curry.
14:59:36 <aristid> :t fix (\r f b -> maybe [] (uncurry ((. r f) . (:))) $ f b)
14:59:37 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:59:43 <aristid> @pl fix (\r f b -> maybe [] (uncurry ((. r f) . (:))) $ f b)
14:59:43 <lambdabot> fix (join . (((.) . maybe [] . uncurry) .) . flip flip (:) . (((.) . flip (.)) .))
14:59:56 <benmachine> @pl fix (\r b -> maybe [] (uncurry $ \a b' -> a : r f b') $ f b)
14:59:57 <lambdabot> fix ((. f) . maybe [] . uncurry . flip ((.) . (:)) . ($ f))
15:00:06 <Bobbias> man, pointfree code confuses the living shit out of me
15:00:15 <benmachine> Bobbias: most of it isn't this obnoxious :P
15:01:07 <Bobbias> Yeah, but I just can't seem to wrap my head around it
15:01:28 <Bobbias> That's probably because I've only been working with haskell for a couple days, lol
15:02:44 <EvanR-work> Bobbias: its important to learn though, not only is it the preferred way to write function definitions, it will make your code a lot faster
15:02:58 <EvanR-work> im not serious btw
15:03:04 <hpc> haha
15:03:07 <Bobbias> lol
15:03:25 * hackagebot mute-unmute 0.1.1 - Watches your screensaver and (un)mutes music when you (un)lock the screen.  http://hackage.haskell.org/package/mute-unmute-0.1.1 (KrzysztofSkrzetnicki)
15:03:25 <ddarius> Bobbias: Point-free code was designed for algebraic manipulations of code.  What @pl produces is not "point-free" in that sense.
15:03:46 <ddarius> Typical point-free code tends to have some variables still, e.g. map f . map g = map (f . g)
15:04:27 <ddarius> What @pl actually is is a compiler to combinators which is interesting, but, like most compilers, you don't really want to look at the output.
15:04:45 <Bobbias> Ahh, ok
15:05:17 <kmc> Bobbias, there's a fine line, some functions are legit. more readable in pointsfree style
15:05:23 <Philippa> basically, some day you'll realising you're writing something that's a pain in the arse because of the variables and look for a combinator that does some of it for you
15:05:29 <Philippa> *realise
15:05:41 <Philippa> that'll happen a few times for different combinators and then you'll have a choice depending on how you feel about things
15:05:43 <kmc> «\xs -> let isLessThanTwo x = x < 2 in filter isLessThanTwo xs» versus «filter (<2)»
15:05:44 <Philippa> it's not a big deal generally
15:06:00 <monochrom> same reason shell scripts support pipelines
15:06:08 <kmc> sometimes the best name for a function is its full source code
15:06:15 <Philippa> exactly, and pipelines're one of the easiest use cases
15:06:47 <kmc> a typical hint that you might want points-free code is to be inventing lots of variable names which are used only locally
15:06:51 <Philippa> if it's full of flip and nested ., it's probably a bad thing to write :-)
15:07:09 <kmc> yeah
15:07:14 <kmc> i wish there were a standard name for (.).(.)
15:07:17 <monochrom> msdos batch files become a pain because you have to create tmp files manually, delete tmp files manually, make sure they're uniquely named manually...
15:07:22 <kmc> (.:) is all right but not widely used enough
15:07:24 <hpc> but if you have f (g (h (z (s x))))
15:07:33 <Philippa> past a certain size of expression you should probably use let to break it up into chunks anyway
15:07:35 <aristid> kmc: i have (.:) in my util file
15:07:41 <aristid> it's teh awesome
15:07:41 <ezyang> @pl forAll arbitrary 
15:07:42 <lambdabot> forAll arbitrary
15:08:54 <ddarius> aristid: J programmers would laugh at you up until you wrote putStrLn "Hello world" and they wrote 3 !: 0, 'Hello world'
15:09:20 <aristid> ddarius: why do they stop, then?
15:09:39 <ddarius> aristid: They probably don't because they're CRAZY.
15:09:52 <kmc> «putStrLn "Hello world"»? i can't understand this code, i don't have a PhD in category theory
15:10:33 <aristid> kmc: well, it's like a burrito
15:10:39 <kmc> nom
15:11:00 <monochrom> I don't have a PhD in nutrition.
15:11:10 <copumpkin> monochrom: no eating for you, sorry
15:11:18 <dolio> The big problem with programming languages is that they don't have enough one-symbol function names.
15:11:23 <kmc> aristid, when i go to the taqueria i order a quesadilla but ask for enough add-ons to make it a quasi-burrito
15:11:28 <kmc> does haskell have something like that
15:12:29 <Twey> dolio: Sounds like you need more APL
15:12:40 <dolio> Yes, or J.
15:12:47 <EvanR-work> K !
15:12:48 <dolio> That's their MO.
15:15:29 <dolio> And to some degree Arc. One of Lisp's great failings was using "lambda" instead of "fn".
15:15:44 <monochrom> heh
15:15:48 <dolio> The latter is going to revolutionize software development.
15:15:52 <kmc> can't i use a macro to make λ into lambda
15:16:10 <kmc> blocks and delegates are going to revolutionize software development
15:16:11 <hiredman> only if your lisp supports charsets other than ascii
15:16:12 <kmc> lambda is useless
15:16:25 <dolio> Do you have a Sussman keyboard with a lambda key?
15:16:47 <kmc> i don't know about you but i always program in the Windows-1253 (Greek) codepage
15:19:25 <mauke> (defmacro λαμβδα (params &body body) `(lambda ,params ,@body))
15:20:02 <nus> δεφμακρο lambda
15:23:54 <ddarius> The garbage bag.  My secret weapon for moving.
15:24:30 <kmc> ddarius++
15:25:15 <Itkovian> kmc: Seconded.
15:25:20 <Bobbias> They help so much
15:25:27 <kmc> i knew someone who did that, but also stored his possessions out back, by the dumpster
15:25:28 <kmc> "temporarily"
15:25:34 <kmc> and of course "temporarily" turned into 2 weeks
15:25:43 <kmc> after which they were hauled away by the trash man
15:33:18 <Itkovian> kmc: so it was temporarily after all :-D
15:33:24 <kmc> yes
15:35:49 <FSalad_III> hmm I didn't leave the garbage bags *outside*, but inside, the "temporary" somewhat extended itself too
15:36:02 <FSalad_III> (still talking about moving, too)
15:36:06 <kmc> garbage bags are more water-resistant than boxes
15:36:53 <FSalad_III> some of the boxes and bags are "misc stuff" that saw 2 or 3 moves without inspection
15:36:54 <FSalad_III> ;)
15:37:10 <kmc> yes
15:37:22 <kmc> by this point most of my stuff is organized by "which box it was in 3 moves ago"
15:37:41 <FSalad_III> hehe
15:38:18 <Entroacceptor> time for a garbage collection
15:39:13 <xiackok> goodnights everyone.
15:40:32 <kmc> moving is a lot like two-space garbage collection
15:40:40 <kmc> easier to throw out stuff when you're moving it all
15:40:43 <kmc> better incentive
15:41:18 <xiackok> im newbie for haskell and im writing a pacman game. but i cant certain for changing game state
15:42:16 <xiackok> am i will use TVar or State monad?
15:42:22 <xiackok> sorry about bad english
15:42:37 <kmc> xiackok, what have you written in Haskell so far?
15:43:22 <xiackok> whats mean so far? like before?
15:43:25 <kmc> yes
15:44:58 <kmc> xiackok, by the way, it is possible that someone here speaks your preferred language
15:45:10 <xiackok> kmc: i wrote game (pacman) dirty style. and i want refactor and little bit logical changes. so i decide to rewriting my code 
15:45:14 <kmc> xiackok, i think that a game is an advanced project in Haskell
15:46:03 <kmc> xiackok, if you are doing graphics and input in the IO monad already, the simplest way to store state would be IORef
15:46:54 <kmc> a cleaner way would be a pure data structure to store state, with functions like «movePacman :: (Int,Int) -> State -> State»
15:47:11 <kmc> let's call it GameState to avoid confusion with the State monad
15:47:23 <kmc> you could implement this GameState type in one module without using a particular monad
15:47:42 <kmc> then use it either with «State GameState t» or «IORef GameState» or «MVar GameState» etc.
15:48:11 <jedai> The sophisticated way would probably be to write your own monad, maybe a simple wrapper around StateT GameState IO (but that's just a refinement)
15:50:57 <xiackok> kmc: ok. i thought StateT. but how can i know the right way. i read about StateT and i can wrote a simple wrapper. When i use TVar or MVar or IORef or State monad ???
15:51:28 <kmc> xiackok, i suggest you read the documentation for these various libraries, and write some small programs using each
15:51:47 <kmc> the State monad is just syntactic sugar for a pure functional state-passing
15:51:55 <kmc> it doesn't really provide mutable variables
15:52:02 <kmc> IORef is a real mutable variable
15:52:13 <kmc> MVar adds thread-safe blocking take/put operations
15:52:19 <kmc> (though IORef is also threadsafe with atomicModifyIORef)
15:52:22 <kmc> TVar is transactional
15:52:31 <kmc> for information on software transactional memory, i recommend the last chapter of RWH
15:52:32 <kmc> @where RWH
15:52:32 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:52:38 <kmc> actually, some of the other chapters may help you in this question as well
15:54:15 <xiackok> kmc: thank you very much. i want this little descriptions. if i understand right: StateT is isolate the functions in a container and nothing to be change in real
15:54:30 <kmc> @unmtl StateT s IO a
15:54:30 <lambdabot> s -> IO (a, s)
15:54:43 <BONUS> hey y'all
15:54:43 <lambdabot> BONUS: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:54:43 <kmc> ^^^^ «StateT s IO a» is just a wrapper for «s -> IO (a, s)»
15:54:50 <BONUS> how about some upvotes please :) http://www.reddit.com/r/haskell/comments/d51ao/lyah_intro_to_monads/
15:54:50 <kmc> hi BONUS
15:54:54 <BONUS> long time no see
15:55:09 <BONUS> i haven't reattached this screen session in ages
15:55:16 <aristid> BONUS: yes, 69 days
15:55:20 <xiackok> kmc: ok. i got it. thanks again
15:55:21 <BONUS> wow!
15:55:30 <BONUS> aristid: where did you get that number from
15:55:40 <kmc> xiackok, no problem :)
15:55:42 <aristid> BONUS: preflex the bot
15:55:51 <BONUS> sneaky bots!!
15:56:12 <mauke> preflex: quote
15:56:14 <preflex>  <lbr> I'd be in a superposition of not being able to do anything because I wouldn't be able to look up stuff but superproductive because I wouldn't be able to look up stuff
15:56:39 <aristid> BONUS: it's already got a downvote. stupid redditors :D
15:56:40 <BONUS> anyway yeah i just finished the monad tutorial
15:56:41 <BONUS> whew
15:56:42 <kmc> BONUS, i'm disappointed that the word "burrito" appears nowhere
15:56:43 <kmc> ;)
15:56:46 <BONUS> kmc haha
15:56:58 <Biggles> that quote rules
15:57:01 <xiackok> and last one thing. what you recommend emacs mode for haskell. up to now i use leksah. but i want return to emacs :)
15:57:25 <jmcarthur> xiackok: haskell-mode
15:57:32 <Bobbias> I've been reading lyah. It's really helped me a lot, compared to many of the other sites out there
15:57:43 <BONUS> Bobbias: cool! :D
15:57:55 <jmcarthur> yeah lyah and rwh are my favorite things to point newbies to
15:58:12 <BONUS> they are really complementary since lyah teaches you pretty much no real world uses for haskell
15:58:21 <Bobbias> lol, yeah
15:58:24 <jmcarthur> yeah
15:59:05 <xiackok> jmcarthur: thanks im now installing
15:59:09 <Entroacceptor> did someone say Burrito?
15:59:24 <BONUS> i managed to pull the whole tutorial off without using one metaphor
15:59:32 <Bobbias> nice
15:59:43 <kmc> yay BONUS
15:59:52 <mauke> @quote analogy.*analogies
15:59:52 <Biggles> lyah also rules
15:59:52 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
15:59:57 <BONUS> haha
16:00:33 <zygoloid> suppose i have a Word64 which i know is in the native format of a Double. what's the best way to build the Double?
16:00:35 <ddarius> Did you say that a monad is a triple of an endofunctor and two natural transformations?
16:00:59 <zygoloid> can i do something substantially nicer than unsafeCoerce?
16:01:05 <mauke> zygoloid: I'd use 'with', 'castPtr' and 'peek'
16:01:12 <aristid> In this chapter, we'll learn about monads, which are just beefed up applicative functors, much like applicative functors are only beefed up functors. 
16:01:16 <BONUS> ddarius: the best way to put it
16:01:35 <BONUS> 2x beef in the first sentence
16:01:45 <aristid> damn hungry now
16:01:46 * zygoloid realises he can read the Double straight out of the memory rather than reading the Word64 at all
16:01:58 <kmc> zygoloid, data-binary-ieee754 for the "nice" way
16:02:05 <kmc> storable is faster
16:02:07 <copumpkin> where "nice" = "slow"
16:02:09 <kmc> unsafeCoerce# is even faster
16:02:10 <kmc> right
16:02:33 <Bobbias> It's always nice to suddenly realize what you were about to do was a terrible idea, before you actually do it
16:02:55 * zygoloid casts the pointer to a RemotePtr Double then just does a peek
16:03:01 * zygoloid feels silly for not thinking of that sooner
16:03:26 <Bobbias> Rather than after you've implemented it in your million line monstrosity, and have to rewrite 100,000 lines of code
16:03:30 <mauke> that might actually be wrong because of alignment
16:04:04 <zygoloid> mauke: that's ok, i'm not reading it 'that way', and i know it's aligned anyway ;)
16:04:27 <zygoloid> (assuming the Storable Double instance writes ieee754 on x86 :o)
16:05:20 <BONUS> also i finally put up a proper 404 page for lyah, check it out: www.learnyouahaskell.com/asfklhaslfkh
16:06:39 <kmc> BONUS, http://is.gd/eBDy6
16:07:23 <BONUS> hahahahaha, awesome
16:13:45 <djahandarie> BONUS, why'd you decide to use (>>=) instead of join?
16:14:25 <BONUS> djahandarie: just a choice i guess. i felt it was easier to transition to chaining of monadic values with >>= than with join
16:14:44 <Runar> >>= is more like <*>
16:15:00 <BONUS> the next chapter will feature a lot of other monads and also the *M functions, join, etc
16:15:10 <kmc> BONUS, maybe you should cross post the chapter to /r/programming
16:15:16 <BONUS> kmc yeah i did
16:15:19 <kmc> hehe
16:15:21 <BMeph> BONUS: I like the owl-with-a-fez. That's it, just wanted you to know. :)
16:15:28 <BONUS> heres the r/programming link
16:15:28 <kmc> cool
16:15:30 <BONUS> http://www.reddit.com/r/programming/comments/d519u/learn_you_a_haskell_intro_to_monads/
16:15:35 <BONUS> upvotes appreciated
16:15:40 <BONUS> BMeph: haha thanks :)
16:15:41 <kmc> you should get some fun trolls
16:16:12 <kmc> and hopefully some people with legit interest in Haskell who got stuck at this point before
16:16:14 <Raynes> BONUS: Ping!
16:16:17 <BONUS> yo
16:16:23 <Runar> join would be more appropriate if you had introduced applicatives via zip
16:16:50 <BONUS> although join is much easier to implement than >>=
16:16:59 <Runar> truth
16:17:02 <Raynes> BONUS: Last year (I think), you were saying that you planned on publishing learnyouahaskell as a book. What happened with that?
16:17:24 <BONUS> Raynes: there was some delay but it's getting published by the end of the yea
16:17:24 <BONUS> r
16:17:29 <Runar> BONUS: I think your discussion is too hand-holdy
16:17:39 <Raynes> BONUS: Hot.
16:18:14 <BONUS> Runar: that's kind of the point of LYAH :)
16:18:16 <pikhq> BONUS: Hey, sweet.
16:18:21 <Runar> BONUS: That's all I got so far. Just sayin
16:19:07 <int80_h> his hand-holdy style should result in significant sales.
16:19:16 <Runar> probably
16:19:36 <BONUS> it's a niche for people who can't *get* haskell
16:19:56 <djahandarie> "Niche"
16:20:09 <Runar> I'm having surprising luck with the "harden the fuck up" approach
16:20:22 <aristid> Runar: if you don't like the hand-holding, just read the papers ;)
16:20:37 * cjay wonders why <$> isn't defined right associative and with a higher precedence than <*>. Both are infixl 4, it's inconsistent with ($).
16:20:45 <copumpkin> hi Runar!
16:20:50 <Runar> Hey Dan
16:20:55 <Runar> Are you coming up here or what?
16:21:02 <copumpkin> yep!
16:21:05 <Runar> when??
16:21:23 <mauke> cjay: ($) has the wrong associativity
16:21:37 <copumpkin> I'm probably going to see if I can do the end of next week, assuming it works for you guys
16:21:50 <copumpkin> need to email scott
16:22:04 <Runar> copumpkin, I'm going to be in Europe for the next 3 weeks
16:22:39 <copumpkin> aw 
16:22:47 <jmcarthur> personally i prefer to teach (=<<) after (<*>), not (>>=) or join, but that's probably because i like to teach it with types as the main focal point
16:23:21 <aristid> so there are three fractions? (=<<) vs (>>=) vs join? :D
16:23:26 <BONUS> yeah, my explanation is more value oriented. but i think most approaches have valid points
16:23:27 <jmcarthur> it makes fmap, (<*>), and (=<<) all line up nicely and reveals them to be function transformers (if you look at them as unary functions)
16:23:37 <Runar> copumpkin: I was hoping you'd come before then, but hey. Maybe by the time I get back you'll be already on the payroll.
16:23:58 <BMeph> BONUS: Also, doggie-lawyer is cute, and I Approve of tossing Kleisli ops at the end. That's some Serious Fun in there! :)
16:24:02 <copumpkin> Runar: well, a ticket this week would be ridiculously expensive
16:24:07 <cjay> mauke: why?
16:24:12 <copumpkin> Runar: when are you leaving for europe though?
16:24:16 <Runar> Monday
16:24:19 <copumpkin> ah
16:24:24 <jmcarthur> copumpkin: heh, expensive ticket brings back bad memories of my trip :P
16:24:34 <jmcarthur> there was an issue with the travel agent
16:24:41 <BONUS> BMeph: hehe yeah, monad laws make much more sense when viewed as kleisli ops
16:24:54 <mauke> cjay: we already have f . g . h $ x
16:24:58 <Runar> McGraw Hill is paying anyway, right?
16:25:27 <copumpkin> Runar: I hope so :)
16:25:34 <Runar> they better
16:26:12 <ManateeLazyCat> @see juhp
16:26:13 <lambdabot> Maybe you meant: free let src
16:26:23 <ManateeLazyCat> @seen juhp
16:26:24 <preflex>  juhp was last seen on #haskell 1 day, 17 hours, 27 minutes and 12 seconds ago, saying: hmm I guess cabal patches should be "sent" to trac?
16:26:24 <lambdabot> Unknown command, try @list
16:26:25 <copumpkin> Runar: well I can try to see what they say about me going this week, but I have something on thursday so it might be a little tight
16:26:28 <juhp> ManateeLazyCat: hi
16:26:33 <ManateeLazyCat> juhp: Hi
16:27:38 <Runar> copumpkin: That's cool. Don't rush on my account.
16:29:43 <dcoutts> juhp: btw, got the patches, ta
16:30:04 <copumpkin> Runar: I'll try!
16:30:24 <juhp> dcoutts: cool - sorry for duplicating
16:30:30 <dcoutts> np
16:30:52 <juhp> dcoutts: has anyone made a patch to say lock down parsec btw? :)
16:31:11 <ManateeLazyCat> parsec is best library to parse protocol like IRC?
16:31:31 <mauke> IRC is simple enough that you can parse it manually, or with regexes or whatever
16:31:36 <copumpkin> not sure IRC needs much parsing
16:31:51 <zygoloid> cjay: the associativity of <$> really doesn't matter. by the functor laws, (f <$> g) <$> x == f <$> (g <$> x)
16:32:05 <dcoutts> juhp: lock down?
16:32:24 <dom96> ManateeLazyCat: There is a IRC message parsing library on hackage, and some IRC Libraries too.
16:32:28 <sproingie> an irc server should parse with bounded memory and time requirements
16:32:37 <sproingie> good idea for clients, a must for any robust server
16:32:41 <zygoloid> cjay: but higher precedence than <*> sounds like a very sensible idea to me...
16:32:42 <sproingie> (or bot)
16:32:43 <juhp> dcoutts: as in ignore updating parsec
16:33:13 <ManateeLazyCat> dom96: I'm write irc client now, i need write new irc parser library without depend other library, then i can add features faster.
16:33:32 <dcoutts> juhp: do you mean when running something like "cabal install world" or do you mean when some other tool pulls in parsec as a dependency?
16:33:53 <aristid> zygoloid: why?
16:34:10 <dcoutts> juhp: I think you can achieve something like that by adding a constraint to the ~/.cabal/config file
16:34:17 <dom96> ManateeLazyCat: i'm creating an IRC Library right now, if you'd like you can take a look at my parsing code. http://github.com/dom96/SimpleIRC/blob/master/Network/SimpleIRC/Messages.hs
16:34:27 <juhp> dcoutts: ah ok
16:34:33 <dcoutts> juhp: constraint: parsec == 2.*
16:34:38 <dcoutts> for example
16:34:42 <juhp> I see
16:34:51 <dcoutts> juhp: it's equivalent to passing that on the command line every time
16:34:57 <ManateeLazyCat> dom96: Cool, look it.
16:34:59 <djahandarie> BONUS, you suddenly switched to pigeons in the middle of that bird example :P
16:35:03 <juhp> dcoutts: was just thinking it would be good to lock library in platform by default
16:35:09 <juhp> libraries
16:35:10 <zygoloid> aristid: currently, f <$> x <*> g <$> y is ((f <$> x) <*> g) <$> r, which means the first <$> and <*> are for the Applicative ((->) r) instance.
16:35:12 <djahandarie> BONUS, "When we apply the function landLeft 1 to (0,0) we get (1,0). Then, we land a bird on the right side, resulting in (1,1). Finally two pigeons land on the left side, resulting in (3,1)."
16:35:14 <BONUS> djahandarie: did i? well birds are pigeons, aren't they?
16:35:18 <BONUS> haha
16:35:26 <dcoutts> juhp: yes, doing it automagically is something we've been thinking about
16:35:29 <juhp> dcoutts: anyway that helps me - so will try that
16:35:32 <djahandarie> Yes, was a bit odd though :P
16:35:34 <juhp> cool
16:35:35 <zygoloid> aristid: that is very rarely what you want, i think. more likely you meant (f <$> x) <*> (g <$> r)
16:35:36 <BONUS> but yes, i'll change it to birds there for consistency, otherwise people might get confused
16:35:50 <ManateeLazyCat> dom96: What's your plan?
16:35:51 <zygoloid> (there all three are for the /same/ Applicative)
16:35:55 <BONUS> there we go
16:35:59 <ManateeLazyCat> dom96: I want some independent package.
16:36:17 <dom96> ManateeLazyCat: i will put on hackage soon
16:36:41 <dom96> *put it
16:37:17 <ManateeLazyCat> dom96: I mean what aim of your SimpleIRC, do you want support all feature in RFC2812? Or just play it simple?
16:38:00 <aristid> zygoloid: and f <$> x <*> y would still work?
16:38:07 <zygoloid> yep
16:38:21 <aristid> i see
16:38:40 <cjay> zygoloid: I think I wouldn't need the parentheses in the following example if <$> were right-associative:
16:38:43 <juhp> dom96: how does it compare to irc or fastirc? :)
16:38:43 <cjay> iter x = abs (a-b) where [a,b] = read <$> (sortBy <$> [compare, flip compare] <*> [show x])
16:39:04 <zygoloid> moving <$> from infixl 4 to infixl 5 or 6 would make sense to me, i don't like that <$> is lower than (++).
16:39:17 <cjay> it's the iteration function for kaprekar's constant
16:39:18 <dom96> ManateeLazyCat: oh, i was thinking about implementing as much as i can of the RFC.
16:39:30 <ManateeLazyCat> juhp: Maybe i will create my own irc parser library for manatee anyway, because my speed is too fast, i don't want wait other people add feature i want.
16:39:32 <zygoloid> what do you expect (+1) <$> [1,2,3] ++ [4,5,6] to do?
16:39:52 <benmachine> zygoloid: I think it makes sense to have ++ the same as :
16:39:52 <zygoloid> perhaps infixl 5 is a good idea, to make that expression illegal?
16:40:03 <benmachine> and it makes sense for f <$> x:xs to mean what it does
16:40:14 <djahandarie> zygoloid, I expect it to make me add parens because I'm not sure what to expect
16:40:22 <dom96> juhp: irc is just a parsing library, so you can't really compare the too. I haven't tested fastirc much, but i hope my library is better :P
16:40:23 <zygoloid> djahandarie: that's my feeling too
16:40:27 <dom96> *two
16:40:39 <juhp> dom96: I see thanks
16:40:44 <ManateeLazyCat> dom96: fastirc is very like you library.
16:40:54 <Cale> I expect [2,3,4,5,6,7]
16:41:05 <Cale> > (+1) <$> [1,2,3] ++ [4,5,6]
16:41:06 <lambdabot>   [2,3,4,5,6,7]
16:41:10 <Cale> Yay
16:41:11 <ManateeLazyCat> dom96: I guess irc use String and not ByteString, it have performance problem.
16:41:48 <Cale> <$> looks like $, so I'd expect it to be similarly low precedence
16:42:09 <zygoloid> benmachine: you make a good point. the other option is to bump <*> down to infixl 3. that might break some code using applicative numbers i guess
16:42:15 <dom96> ManateeLazyCat: In the first version of SimpleIRC i used Strings, i thought i would try using ByteStrings to see if there is a difference in speed. There really wasn't a visible difference, but i stayed with ByteStrings.
16:42:31 <zygoloid> Cale: would you expect <*> lower than <$>?
16:42:51 <ManateeLazyCat> dom96: Maybe you need login #haskell for test since #haskell is so busy channel. :)
16:43:01 <benmachine> I think the whole fixity system tends to be surprising :)
16:43:09 <benmachine> I don't have any better ideas though
16:43:15 <kmc> mixfix!
16:43:36 <monochrom> well the bottomline is I can write "(+) <$> readLn <*> readLn", isn't it?
16:43:52 <dom96> ManateeLazyCat: perhaps i will, it's too late today though, i feel tired.
16:44:03 <ManateeLazyCat> dom96: Good night.
16:44:07 <ManateeLazyCat> dom96: I just wake up. :)
16:44:10 <monochrom> > (+) <$> [1,2] <*> [3,4]
16:44:11 <lambdabot>   [4,5,5,6]
16:44:15 <zygoloid> monochrom: sure. but you can't write: "(+) <$> read <$> getLine <*> read <$> getLine" without extra parens
16:44:21 <megajosh2> @src lines
16:44:21 <lambdabot> Source not found. My mind is going. I can feel it.
16:44:27 <dom96> ManateeLazyCat: heh, it's almost 1am here
16:44:31 <megajosh2> @src words
16:44:31 <lambdabot> words s = case dropWhile isSpace s of
16:44:31 <lambdabot>     "" -> []
16:44:31 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
16:44:49 <ManateeLazyCat> dom96:  07:44 am in China. :)
16:44:54 <monochrom> but I would combine (+), read, read into one pure function.
16:45:13 <dom96> ManateeLazyCat: oh
16:45:29 <monochrom> I would also not mind parentheses in that case.
16:45:38 <benmachine> you're always going to need parentheses for *something*
16:45:41 <benmachine> unless everyone codes in RPN
16:45:46 <zygoloid> to be honest i think i'd /prefer/ parentheses in that case!
16:45:46 <jmcarthur> i rarely use (<*>) directly. liftA* is much more common for me
16:46:19 <monochrom> until we get rid of this fetish with "plain text file" "can use any 1970s terminal editors", we will live with parentheses for pathological code.
16:47:01 <Cale> I'm not sure we'd want to eliminate parens entirely even if we weren't using plain text files.
16:47:21 <zygoloid> i quite like the idea of using background colour to indicate nesting level
16:47:27 <zygoloid> some nice pastel shades... mmm...
16:47:54 <aristid> :t (minimum *** maximum) . unzip
16:47:55 <lambdabot> forall a a1. (Ord a, Ord a1) => [(a, a1)] -> (a, a1)
16:47:56 <dom96> ManateeLazyCat: well if you decide to use my library, you can contact me on github or on irc (you too juhp)
16:48:09 <dom96> ManateeLazyCat: or if you want i can give you my email address
16:48:18 <ddarius> We will never surrender our Dyck languages.
16:48:28 <zygoloid> i want a lazy tree view (either GUI or CUI is fine). anyone have any suggestions?
16:48:36 <aristid> :t unzip >>> minimum *** maximum
16:48:37 <lambdabot> forall a b. (Ord a, Ord b) => [(a, b)] -> (a, b)
16:48:40 <cncl> emacs users: what do you use to manage haskell projects?
16:48:47 <ManateeLazyCat> zygoloid: Lazy tree? What do you mean?
16:49:01 <ManateeLazyCat> cncl: Tabbar
16:49:11 <juhp> dom96: thanks - I will take a look at it
16:49:20 <zygoloid> ManateeLazyCat: a tree view widget, which i can populate on-demand (the actual tree^Wgraph is huge)
16:51:11 * zygoloid hopes there'll be a haskell gui toolkit with such a widget, or he'll be writing one in curses...
16:52:08 <kmc> GTK has a tree view
16:52:13 <kmc> it's not pleasant to use
16:52:15 <kmc> but pretty flexible
16:52:20 <zygoloid> any idea if i can populate it on demand?
16:52:20 <ManateeLazyCat> zygoloid: I guess TreeView is you need.
16:52:29 <kmc> yes, it's fully dynamic
16:55:14 <djahandarie> BONUS, "In fact, list comprehensions are just syntactic sugar for using lists as monads. In the end, list comprehensions and lists in do notation translate to using >>= to do computations that feature non-determinism."
16:55:40 * zygoloid is disappoint to see treeModelIfaceGet* :: ... -> IO a
16:55:41 <djahandarie> I know this used to be true at some point, but do they really still translate like that?
16:55:42 * ezyang sighs about list comprehensions not being monadic anymore... 
16:55:52 <zygoloid> i'm not working in IO, i'm working in a transformer over IO ;(
16:55:59 <zygoloid> Chan time!
16:56:00 <kmc> how they "actually translate" is an implementation detail
16:56:08 <kmc> but the type is fixed to [] now, if that's what you're asking
16:56:20 <ManateeLazyCat> zygoloid: Infact, i have code can add any candidate dynamic.... https://patch-tag.com/r/AndyStewart/manatee-anything/snapshot/current/content/pretty/Manatee/Plugin/Anything/AnythingView.hs
16:56:23 <zygoloid> ezyang: i actually like it. [] to me says "list".
16:56:24 <kmc> i think the suggested translation in the Report is in terms of map and filter, not (>>=) and guard
16:57:00 <ManateeLazyCat> zygoloid: But above example maybe too complicated.
16:57:25 <ManateeLazyCat> zygoloid: Feel free ask in gtk2hs list.
16:57:29 <zygoloid> yeah :) but ListView looks like it'll do very nicely. thanks :)
16:57:42 <zygoloid> is there a dedicated channel on IRC, or should i ask here?
16:57:44 <BONUS> djahandarie: honestly i dont know. the semantics are the same though
16:57:53 <kmc> how aware are the gtk developers of haskell and what do they think of it
16:58:10 <zygoloid> ManateeLazyCat: also, candidate is spelt with only one 'n' *duck* ;)
16:58:12 <djahandarie> kmc, so list comprehensions eventually end up using list's monad instance?
16:58:21 <BONUS> and by translate i meant more like that there is an isomorphism, not really translate as in compile
16:58:24 <ddarius> djahandarie: No, but you can't really tell.  (Technically, you could with GHC's rebindable syntax stuff.)
16:58:27 <kmc> djahandarie, whether they actually do is an irrelevant implementation detail
16:58:38 <ddarius> @undo [x | x <- xs, y <- ys, y < 3]
16:58:38 <lambdabot> concatMap (\ x -> concatMap (\ y -> if y < 3 then [x] else []) ys) xs
16:58:59 <kmc> heh, using if
16:59:01 <Veinor> undo understands list comprehensions?
16:59:06 <kmc> i thought it'd use "filter"
16:59:13 <Veinor> @do concatMap (\ x -> concatMap (\ y -> if y < 3 then [x] else []) ys) xs
16:59:13 <lambdabot> concatMap (\ x -> concatMap (\ y -> if y < 3 then [x] else []) ys) xs
16:59:15 <zygoloid> yeah, -XNoImplicitPrelude makes the translation observable
16:59:31 <zygoloid> iirc GHC follows the report
16:59:33 <cncl> ManateeLazyCat: i was looking for something more than tabs (i don't use tabs myself)
16:59:37 <cncl> more like a tree view of a project
17:00:24 <Peaker> BONUS: congrats on the new chapter
17:00:30 <djahandarie> BONUS, I guess I only brought up implementations because when you said "translate" I started thinking transform rather than isomorphism which I probably shouldn't have
17:00:43 <ManateeLazyCat> zygoloid: Well, freel free ask in gtk2hs list.
17:00:45 <BONUS> Peaker: thanks :)
17:01:01 <ManateeLazyCat> cncl: http://www.flickr.com/photos/48809572@N02/ screenshot 
17:01:20 <Peaker> BONUS: I'll send some people to read it :) I wanted to review but it's a bit long for 3 am :)
17:01:39 <cncl> ManateeLazyCat: which one?
17:01:47 <BONUS> haha, no worries, just enjoy the pictures
17:02:08 <ManateeLazyCat> cncl: http://www.flickr.com/photos/48809572@N02/4906441103/ is for tree view.
17:02:26 <ManateeLazyCat> zygoloid: Wait, i give you simpler demo.
17:03:07 <cncl> ManateeLazyCat: am i looking at it wrong? i don't see one
17:03:40 <dibblego> is this in the standard library? http://paste.pocoo.org/show/254143/
17:03:52 <ManateeLazyCat> cncl: Multiple tabs tree view is pretty simple, just add TreeView in Notebook.
17:04:09 <kmc> :t takeWhileM
17:04:10 <lambdabot> Not in scope: `takeWhileM'
17:04:16 <ManateeLazyCat> cncl: Then just update ListStore for add/delete candidate from TreeView.
17:04:18 <kmc> :t filterM
17:04:18 <dibblego> yeah that
17:04:19 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:04:37 <ManateeLazyCat> zygoloid: http://code.haskell.org/gtk2hs/gtk/demo/treeList/ simple demo.
17:04:55 <dolio> filterM isn't the same.
17:05:01 <kmc> dibblego, perhaps you could write it with guard
17:05:02 <ezyang> Is there ever a reason I would use STUArray over vector? 
17:05:07 <dibblego> hmm yes
17:05:14 <dolio> dibblego's looks like takeWhileM.
17:05:27 <dibblego> yeah I think it is like takeWhileM
17:05:46 <dolio> And that doesn't exist in the standard libraries.
17:06:00 <dibblego> though it's not exactly takeWhileM
17:06:06 <dolio> Yeah.
17:06:14 <dibblego> perhaps it can be written using takeWhileM
17:06:31 <dolio> It's a combination of mapM and takeWhile that short-circuits.
17:06:46 <dibblego> yes
17:07:09 <aristid> @src mapM
17:07:10 <lambdabot> mapM f as = sequence (map f as)
17:07:46 <dolio> mapAndTakeWhileM
17:07:56 <juhp> cabal: There is no available version of parsec that satisfies ==2.1.0.1
17:07:57 <juhp> hmm
17:08:08 <aristid> @ty \f -> sequence . takeWhile f
17:08:11 <dolio> @type mapAndUnzipM
17:08:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m a -> Bool) -> [m a] -> m [a]
17:08:14 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m (b, c)) -> [a] -> m ([b], [c])
17:09:42 * BONUS brb sleep
17:10:57 <ddarius> juhp: cabal update?
17:11:09 <dibblego> thanks guys
17:11:12 <Veinor> .tell bonus I'm a big fan of the pig
17:11:18 <Veinor> bah, what's the syntax
17:11:29 <BONUS> hey thanks :D
17:11:34 <BONUS> i'll tell the pig
17:11:37 <juhp> probably I should reset my .ghc pkg "cache"
17:11:50 <djahandarie> ~(=^・・^)
17:16:13 <ezyang> Anyone know about STUArray v. Vector? 
17:16:29 <ddarius> Use vector if you can.
17:16:40 <ezyang> ok. 
17:17:56 <djahandarie> ddarius, when wouldn't you be able to?
17:18:04 <etpace> @hoogle (a -> a -> Bool) -> [a] -> (a, [a])
17:18:04 <lambdabot> No results found
17:19:18 <etpace> need something like partition but stops searching after finding one element that matches
17:19:36 <ddarius> So you probably want Maybe (a, [a])
17:20:54 <cjay> yay I finally understand the Functor instance of ((->)r)
17:21:22 <djahandarie> \o/
17:21:40 <djahandarie> Why can't (->) be used as a section again?
17:21:55 <BONUS> djahandarie: then the type system becomes self aware i think
17:22:03 <FSalad_III> is 'foldr c n . take k' considerably less efficient than a counting fold?
17:22:09 <dolio> Right-sections require lambdas.
17:22:16 <BONUS> oh wait no, that's if you allow implicit params in instances
17:22:21 <FSalad_III> (due to making intermediate conses...)
17:22:30 <FSalad_III> or can you count on fusion?
17:22:57 <djahandarie> dolio, so just add a type lambda ;)
17:23:05 <ddarius> I imagine take is a good producer.  You can check.
17:23:24 <ddarius> djahandarie: You can write (r ->) with mild extensions.
17:23:35 <FSalad_III> -ddump-simpl-stats and look for the rule application...?
17:23:47 <dolio> djahandarie: That's a risky proposition.
17:23:53 <ddarius> Or you can just check the list of good producers.
17:23:56 <ddarius> or the definition of take
17:24:16 <FSalad_III> where can I find that list?
17:26:30 <ddarius> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/rewrite-rules.html 7.14.3
17:27:13 <FSalad_III> thank you. didn't know there was such a thing
17:30:25 <mm_freak_> can i cross-compile to windows .exe on linux?
17:30:38 <FSalad_III> (I think I'll rewrite this 'cyclic list zipper' to just keep track of the first element through Int counters instead of internally having two lists of Either Delimiter a ...)
17:30:38 <mm_freak_> (without needing WINE and ghc.exe, that is)
17:31:18 <FSalad_III> (for lists that have a designated start and end, but should support cyclic cursor movement)
17:31:50 <Saizan> mm_freak_: no
17:34:37 <augur> Cale: is it wise to try to learn category theory while slightly drunk
17:35:06 <dolio> No. You'll have to get drunk to remember stuff.
17:35:26 <megajosh2> The more you drink, the more you remember in the morning
17:35:48 <augur> dolio, megajosh2: aha! this explains so much about haskell
17:35:49 <augur> 8D
17:38:48 <ManateeLazyCat> I plan to add process manager for manatee, base on package proc.
17:38:51 <ManateeLazyCat> @proc
17:38:51 <lambdabot> Maybe you meant: rc src
17:38:59 <ManateeLazyCat> @hackage proc
17:38:59 <lambdabot> http://hackage.haskell.org/package/proc
17:39:03 <kmc> mm_freak_, theoretically
17:39:09 <kmc> mm_freak_, building GHC as a cross compiler is an adventure
17:39:22 <ManateeLazyCat> If anyone intersting process manager, we can work together.
17:39:31 <copumpkin> it's actually supposed to be not too impossible to do now
17:39:34 <ManateeLazyCat> My mail is lazycat.manatee@gmail.com, thanks!
17:39:34 <copumpkin> there was a patch put in just recently
17:39:45 <megajosh2> ManateeLazyCat: Say again?
17:40:21 <ManateeLazyCat> megajosh2: Process manager (linux) for my project manatee (http://www.flickr.com/photos/48809572@N02/)
17:40:36 <mm_freak_> ok, thanks
17:40:40 <copumpkin> manatees are so cute
17:40:42 <ManateeLazyCat> megajosh2: I have build simple parser in hackage 'proc'
17:41:20 <ManateeLazyCat> If any artist have time help me draw Manatee Icon, i will use it for my project to release, thanks!
17:41:53 <ManateeLazyCat> megajosh2: Source code at http://patch-tag.com/r/AndyStewart that beginning with manatee-*
17:42:11 <ManateeLazyCat> megajosh2: Need gtk and gio-branch (http://patch-tag.com/r/AndyStewart/gio-branch/home) to compile it.
17:42:12 <copumpkin> http://upload.wikimedia.org/wikipedia/commons/6/6f/FL_fig04.jpg
17:42:13 <copumpkin> mmm
17:42:32 <ManateeLazyCat> copumpkin: I need icon. :)
17:42:39 <cncl> what do you guys do if you need to rename a function or class or something across multiple files?
17:42:46 <cncl> just string/replace?
17:42:48 <copumpkin> ManateeLazyCat: I know :) I just thought it was cute
17:43:01 <QtPlatypus> ManateeLazyCat: Why don't you pass a few commision an artist to make you one?
17:43:46 <ManateeLazyCat> QtPlatypus: Maybe i can draw icon myself, i'm used to be game enginner..... 
17:43:59 <QtPlatypus> ManateeLazyCat: Or that.
17:44:23 <mrsolo> can one create a Int# under ghci?
17:44:31 * ManateeLazyCat Damn, haven't time to talk, bye.....
17:45:30 <ManateeLazyCat> QtPlatypus: BTw, do you know any artist at here?
17:45:38 <ManateeLazyCat> QtPlatypus: I can pay for it.
17:46:07 <duckinator> damn all the people who say *duck* and refer to duck-typing :(
17:46:19 * duckinator had 27 highlights from that today
17:46:26 <duckinator> at least 2 being in here :P
17:46:30 <copumpkin> mrsolo: sure
17:46:45 <copumpkin> mrsolo: you can enable MagicHash and then 1# and so on are Int#s
17:47:37 <kmc> you'll find they aren't really first-class though
17:47:44 <kmc> for example you can't pass one to "print"
17:47:48 <kmc> including ghci's implicit "print"
17:47:54 <kmc> because print is polymorphic and so expects boxed args
17:48:18 <mrsolo> nice..well i learning through reading source codes.. ghci is used for fiddling
17:48:30 <kmc> so it works to type «I# 2#» but not just «2#»
17:48:37 <kmc> learning what mrsolo?
17:48:56 <mrsolo> haskell in general  how people write codes
17:48:59 <kmc> ah
17:49:06 <copumpkin> mrsolo: people don't really use Int# much :)
17:49:08 <kmc> well unboxed types like Int# are a pretty advanced topic
17:49:19 <copumpkin> it's not like in java whre you need to care about boxedness or unboxedness
17:49:25 <kmc> we usually use the simpler types like Int, and hope that the compiler will optimize out the boxing when possible
17:49:26 <mrsolo> copumpkin huge warning sign all over the place yea   i am sure
17:49:31 <mrsolo> but still good to know
17:49:35 <kmc> some specialized code will use them directly for better performance
17:49:39 <kmc> yeah, it is good to know
17:49:46 <mrsolo> since ByteString.* is all about performance
17:49:55 <copumpkin> yep :)
17:51:53 <ddarius> I imagine a lot of the unboxing can be removed from ByteString.
17:53:01 <mrsolo> oh?
17:53:52 <kmc> perhaps some code is legacy from when GHC was not as smart?
17:54:07 <augur> anyone have a reeeaaally good example of a good use of map?
17:54:08 <ddarius> It wasn't too long ago when GHC got a lot better about unboxing.
17:54:35 <kmc> augur, good how? "realistic"?
17:54:35 <ddarius> map is not usually a function that needs motivating.
17:54:45 <kmc> anyone here have a great example of a "for" loop in C?
17:54:52 <augur> kmc: good as it in makes sense to use map for the purpose :P
17:54:59 <kmc> > map show [1,2,3]
17:55:00 <lambdabot>   ["1","2","3"]
17:55:07 <kmc> i have a list of integers, i want a list of their string representations
17:55:10 <kmc> i use «map show»
17:55:12 <augur> kmd: you're useless :P
17:55:18 <kmc> augur, what do you want?
17:55:27 <kmc> it makes sense to use map for this purpose
17:55:45 <copumpkin> there are loads of good uses of map
17:55:50 <copumpkin> not sure what you'd consider good though
17:55:53 <ddarius> Just about all of them.
17:55:56 <augur> copumpkin: oh im sure, im just trying to teach some friends programming
17:56:04 <kmc> C is such an impractical language, all the examples about "for" loops are for iterating over data structures or something, i want a use of "for" in a multiplatform massively multiplayer online rpg
17:56:16 <kmc> augur, so what's wrong with my example?
17:56:18 <augur> and they would like to see a normal use of map so that it looks intuitive why you'd use it
17:56:19 <augur> etc
17:56:35 <augur> kmc: trust me, i would accept that example myself
17:56:40 <kmc> what do your friends want then
17:56:41 <ddarius> What I want to see is an "abnormal" use of map.
17:56:44 <augur> but apparently its not good enough :P
17:56:52 <kmc> they don't believe that sometimes you have a list of numbers and you want a list of strings?
17:56:53 <dolio> main = do (m:n:_) <- map read `fmap` getArgs ; ...
17:56:58 <kmc> this has never happened to them in their programming careers?
17:57:15 <kmc> fine lets say i have a list of Int and want to make them Double
17:57:21 <kmc> > map fromIntegral [1,2,3] :: [Double]
17:57:22 <lambdabot>   [1.0,2.0,3.0]
17:57:23 <augur> kmc: they dont have programming careers yet :P
17:57:26 <kmc> ok
17:57:36 <kmc> so we can expect that they don't know what they want yet
17:57:47 <kmc> it's hard to motivate *any* language feature to someone who has never programmed
17:58:02 <kmc> just start writing code to solve a problem and soon you will need 'map'
17:58:04 <augur> kmc: i just need something thats more than just "ooh look we can make a this out of a that!"
17:58:13 <augur> something that seems more practically motivated beyond just showing off map
17:58:25 <kmc> augur, then you'll need to choose a practical problem and solve it
17:58:28 <ddarius> kmc: What?!  Professors at universities are supposed to listen to what their ignorant students want to learn and think is important rather than provide guidance and wisdom.
18:00:23 <kmc> augur, i do not think you will have success teaching these friends if you take the approach of checking off a list of Haskell functions / language features
18:00:51 <augur> kmc: i just want a general idea of what people think is relatively simple but practically sensible for this sort of thing
18:01:00 <kmc> ok
18:01:02 <augur> i could come up with examples, but they'd be complicated
18:01:13 <kmc> well i think it's practically sensible to turn a list of Ints into a list of Doubles
18:01:15 <augur> as most practical things tend to be, i suppose, but
18:01:17 <kmc> i've done it many times in practical programs
18:02:18 <copumpkin> augur: you could use it to do RLE in a tweet
18:02:19 <copumpkin> like I did
18:02:28 <augur> rle?
18:02:29 <chrisf> augur: it's not haskell, but my c# game uses the equivalent of `map` a LOT.
18:02:45 <ddarius> Just what everyone needs.  An implementation of run-length encoding on their phones.
18:02:46 <kmc> > map (\x -> (x - 32)*5/9.0) [32,98.6,212]
18:02:47 <lambdabot>   [0.0,37.0,100.0]
18:03:00 <kmc> augur, ^^^^ converting temperatures from fahrenheit to celsius
18:03:06 <kmc> everyone loves coding that in TI-BASIC right ;P
18:03:09 <kmc> practical enough?
18:03:10 <ddarius> chrisf: Almost every program in existence uses the equivalent of "map" a lot.
18:04:15 <copumpkin> augur: run-length encoding, simple compression used in gif among other things
18:04:28 <kmc> augur, you really ought to choose a practical problem and solve it, using whatever features make sense along the way
18:04:31 <copumpkin> ddarius: my thoughts exactly!
18:05:04 <kmc> your friends will be more satisfied
18:05:40 <ddarius> Go volunteer at a local charity with them.  Your friends will be much, much more satisfied.
18:06:20 <augur> kmc: well hence why im asking for a practical example that just-so-happens to use map :p
18:06:36 <kmc> augur, but you're being frustratingly unspecific about what's "practical"
18:06:40 <ddarius> augur: You'll be hard-pressed to write a "practical" program that doesn't use map.
18:06:52 <ddarius> Write any "practical" program.  You'll use map.
18:06:58 <augur> ddarius: practical for me tho is like.. a full blown theorem prover :P
18:07:02 <kmc> augur, when i say "choose a practical problem" i don't mean make up an artificial little example for purpose of using map
18:07:13 <kmc> i mean, pick a problem you really want to solve and solve it
18:07:38 <kmc> i mean it's really arbitrary
18:07:39 <kmc> i can say
18:07:45 <kmc> > map (+5) [1,2,3]
18:07:46 <lambdabot>   [6,7,8]
18:07:48 <kmc> and that's totally artificial
18:07:57 <kmc> but now i say that [1,2,3] are the hit points of three elves you just cast a heal spell on
18:08:00 <kmc> and now it's practical ;P
18:08:20 <megajosh2> lol
18:08:24 * augur casts magic missile
18:08:44 <copumpkin> lol
18:08:52 <ddarius> c mm
18:09:01 <copumpkin> c mm?
18:09:04 <copumpkin> oh
18:13:49 <dolio> Are you attacking the darkness?
18:20:30 * BMeph is getting drunk, and hoping that there are girls here...
18:20:58 <dolio> Roll the dice to see if I'm getting drunk.
18:21:32 <copumpkin> @dice 1d6
18:21:33 <lambdabot> 1d6 => 4
18:21:39 <copumpkin> dolio: 4!
18:21:56 * BMeph cheers - he's getting drunk, Whooo!
18:22:13 * copumpkin eats some crackers with marmite
18:22:29 <dolio> Now you're being attacked by ogres.
18:24:26 <luite> you are likely to be eaten by a grue
18:24:44 <copumpkin> @dice 2d6
18:24:45 <lambdabot> 2d6 => 9
18:25:03 <dolio> Is this a turtle in a tie?
18:25:11 <juhp> wonder if I have the ~/.cabal/config Constraint: syntax right
18:33:35 <joelb> I hate it that nearly every time I've mentioned Haskell to someone, they respond "Pascal?" As in "Why would you use that?"
18:33:55 <JoeyA> heh
18:34:03 <JoeyA> Is there a module full of functions like this?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29428
18:34:06 <copumpkin> find smarter people to talk to
18:34:13 <joelb> I'm working on it
18:34:30 <JoeyA> Namely, alternatives to sequence, mapM, and forM that don't stack overflow for large inputs.
18:35:12 <copumpkin> ack, reverse
18:35:15 <JoeyA> The functions in the paste (sequence', mapM', and forM') use IORef to build the list on the heap instead of in stack.  They only work on IO, not monads in general.
18:36:28 <JoeyA> if I say (++ [x]) instead of building the list that way, I still get a stack overflow.
18:36:36 * hackagebot hfractal 0.4.2.1 - OpenGL fractal renderer  http://hackage.haskell.org/package/hfractal-0.4.2.1 (ChrisHoldsworth)
18:37:40 <etpace> @pl \(s,v) -> maybe (Left s)( (Right . (,) $ s) v
18:37:40 <lambdabot> (line 1, column 46):
18:37:40 <lambdabot> unexpected end of input
18:37:40 <lambdabot> expecting variable, "(", operator or ")"
18:38:00 <etpace> @pl \(s,v) -> maybe (Left s) (Right . (,) $ s) v
18:38:01 <lambdabot> uncurry (liftM2 maybe Left (Right . (,)))
18:38:09 <Cale> JoeyA: How did you get sequence to stack overflow in the first place?
18:38:46 <Cale> Oh, heh, needed a bit more than a million elements in my list
18:39:06 <JoeyA> sum <$> sequence' (replicate 10000000 (return 1))
18:39:18 <aristid> :t \(s,v) -> maybe (Left s) (Right . (,) $ s) v
18:39:19 <Cale> Yeah, 10 million will do it.
18:39:19 <lambdabot>     Couldn't match expected type `a -> Either a1 b'
18:39:19 <lambdabot>            against inferred type `Either a2 (b1 -> (a1, b1))'
18:39:20 <lambdabot>     In the second argument of `maybe', namely `(Right . (,) $ s)'
18:39:47 <JoeyA> Another way to avoid a stack overflow is to use unsafeInterleaveIO, but I want strict IO semantics in my case.
18:40:00 <JoeyA> (actually, I'll probably use a combination of both)
18:40:04 <aristid> :t \(s,v) -> maybe (Left s) (Right . (s,)) v
18:40:05 <lambdabot> parse error on input `)'
18:41:21 <JoeyA> hmm, I wonder if I can ditch the IORef and just build the list backwards and reverse it.
18:41:52 <dh__> :t <$>
18:41:53 <lambdabot> parse error on input `<$>'
18:41:58 <dh__> :t (<$>)
18:41:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:42:12 <JoeyA> :i (<$>)
18:42:30 <JoeyA> err, :i <$> -- works in ghci, FYI
18:42:46 <ksf> I don't want this damn newtype wrapping.
18:43:14 <ksf> you see, I've got a lot of newtypes, e.g. "UserName", "UnitName", "MapHash" etc.
18:43:29 <ksf> ...each of which fall into the class "can't contain a space"
18:43:43 <uninverted> What's the easiest way to check whether any two elements of a list are equal?
18:43:58 <ksf> wtf I should just use smart constructors, me idiot.
18:44:07 <ksf> :t (==)
18:44:08 <lambdabot> forall a. (Eq a) => a -> a -> Bool
18:44:34 <JoeyA> length (nub list) == length list
18:44:36 <ksf> or do you mean [1,2,3] [4,3,2] == True?
18:44:40 <JoeyA> err, /=
18:44:43 <JoeyA> That's not very efficient
18:44:49 <JoeyA> (what I posted)
18:44:52 <uninverted> No, I mean, a function that's true for [1,2,3] but false for [2,2,3]
18:45:05 <JoeyA> So, the question is: are all elements unique?
18:45:11 <ksf> not . null $ union x y
18:45:15 <uninverted> Oh, duh.
18:45:17 <JoeyA> length (nub list) == length list -- True if all elements in list are unique
18:45:43 <uninverted> Thanks, don't know why I didn't think of that.
18:45:48 <aavogt> depending on what the elements are, you might be quicker to compare on the lists themselves and not the list
18:46:07 <ksf> nubbing also requires a sorted list.
18:46:17 <luite> no it doesn't even require Ord
18:46:20 <aavogt> > nub "heh"
18:46:21 <lambdabot>   "he"
18:46:25 <kmc> nub is slow for this reason
18:46:29 <ksf> ah. 
18:46:39 <kmc> :t S.toList . S.fromlist
18:46:40 <lambdabot> Couldn't find qualified module.
18:46:43 <kmc> :t S.toList . S.fromList
18:46:44 <lambdabot> forall a. (Ord a) => [a] -> [a]
18:46:53 <kmc> :t nub
18:46:54 <lambdabot> forall a. (Eq a) => [a] -> [a]
18:47:31 <JoeyA> > null . filter (not . null . tail) . group . sort $ [1,2,3,1,2]
18:47:32 <lambdabot>   False
18:47:36 <JoeyA> > null . filter (not . null . tail) . group . sort $ [1,2,3,4,5]
18:47:37 <lambdabot>   True
18:47:47 <JoeyA> That's an efficient way to do it.
18:48:20 <JoeyA> > null . filter (not . null . tail) . group . sort $ []
18:48:21 <lambdabot>   True
18:48:37 <aristid> > null . filter (not . null . tail) . group . sort $ [1,1]
18:48:38 <lambdabot>   False
18:49:17 <JoeyA> Funny Haskell snippet:  (m:ms) -- m and ms :-)
18:49:32 <JoeyA> m&ms, whatever
18:49:35 <orbitz> Is it common to pull functions fro modules right into another module or to keep imports at th emodule level?
18:49:45 <dh__> > group [1,2,2,3]
18:49:46 <lambdabot>   [[1],[2,2],[3]]
18:49:57 <JoeyA> you can export modules from modules
18:50:16 <JoeyA> module Foo (module Data.List, module Control.Applicative) where import Data.List  import Control.Applicative
18:50:25 <dh__> > tail [1]
18:50:26 <lambdabot>   []
18:50:39 <JoeyA> not sure on the nitty gritty details of doing that, though.
18:50:48 <aavogt> it's pretty common to explicitly name all the imports
18:50:55 <aavogt>  import Foo(a,b,c)
18:51:08 <dh__> > group . sort $ [1 , 1]
18:51:09 <lambdabot>   [[1,1]]
18:51:16 <JoeyA> I wonder what percentage of all Haskell code written is imports.
18:51:27 <dh__> > filter ( not . null . tail ) . group . sort $ [1,1]
18:51:28 <lambdabot>   [[1,1]]
18:51:30 <JoeyA> (as in, import lines)
18:51:51 <dh__> JoeyA: why the filt er( not . null . tail ) ? 
18:51:59 <orbitz> aavogt: does that get unsavory at all?  In Python i tend to import at the module level so deepin gin the cod i can see foo.bar() and know ehre bar comes from.  
18:52:05 <orbitz> (easily)
18:52:05 <JoeyA> dh__: The algorithm sorts, groups, and looks for any lists of 2 or more items.
18:52:11 <aristid> dh__: to filter one-element lists
18:52:18 <aristid> *filter out
18:52:33 <aavogt> orbitz: qualified imports are pretty uncommon
18:52:36 <aristid> > filter ( not . null . tail ) . group . sort $ [1,2,3,4,1]
18:52:37 <lambdabot>   [[1,1]]
18:52:43 <JoeyA> (not . null . tail) is equivalent to ((> 1) . length), provided the input list has at least one element.
18:52:59 <orbitz> Haskell seems different though since you can import a lot of infix ops in haskell
18:53:05 <dh__> oh , cool, I would write ((> 1) . length ) , :)
18:53:14 <aristid> dh__: slower
18:53:20 <Draconx|Laptop> not . null . tail is lazier than (> 1) . length.
18:53:22 <aavogt> I mean they do happen, but most imports aren't qualified
18:53:33 <aristid> lazy naturals to the rescue
18:53:34 <dh__> en, thanks , I got it :)
18:53:55 <Draconx|Laptop> > not . null . tail $ [1..]
18:53:56 <lambdabot>   True
18:53:56 <luite> although in this case it wouldn't really matter since you sort first
18:54:07 <Draconx|Laptop> > (> 1) . length $ [1..]
18:54:11 <lambdabot>   mueval-core: Time limit exceeded
18:54:37 <lispy> Draconx|Laptop: that one would work if you used lazy naturals
18:54:47 <Draconx|Laptop> lispy, but length returns an int.
18:54:53 <aavogt> > sort $ replicate 100 0 ++ [1..] :: [Word]
18:55:00 <lambdabot>   mueval: ExitFailure 1
18:55:02 <lispy> > (> 1) . genericLength [1..]
18:55:07 <lambdabot>   mueval-core: Time limit exceeded
18:55:16 <lispy> :t genericLength
18:55:17 <aavogt> sort could be lazier, no?
18:55:22 <lambdabot> forall b i. (Num i) => [b] -> i
18:55:55 <lispy> aavogt: I think sort still has to look at every element before it can return anything
18:56:01 <Draconx|Laptop> aavogt, not to the point where it could possibly work on infinite lists.
18:56:01 <aavogt> > filter (== minBound) $ replicate 100 0 ++ [1..] :: [Word]
18:56:05 <lambdabot>   mueval-core: Time limit exceeded
18:56:35 <aavogt> > take 10 $ filter (== minBound) $ replicate 100 0 ++ [1..] :: [Word]
18:56:36 <lambdabot>   [0,0,0,0,0,0,0,0,0,0]
18:56:58 <mm_freak_> > do x:_:_ <- group . sort $ [1,2,4,2,5]; [x]
18:56:59 <lambdabot>   [2]
18:57:36 <lispy> and, assuming no duplicates in the input which has better performance in haskell, Prelude.sort, or using Data.Set's fromList/toList?
18:57:40 <mm_freak_> but all "group . sort" based solutions are non-optimal
18:58:03 <aristid> mm_freak_: why?
18:58:21 <mm_freak_> you can have the same in a 'nub' style, which is lazier and starts producing values immediately
18:58:38 <aristid> without sorting?
18:58:40 <mm_freak_> and it would work on infinite lists, too
18:58:42 <mm_freak_> yes
18:58:45 <lispy> But nub is O(n^2)
18:58:53 <aavogt> @let sortl xs = do t <- [minBound .. maxBound]; filter (t ==) xs
18:58:54 <lambdabot>  Defined.
18:58:55 <aristid> mm_freak_: sorting has lower complexity than nub
18:58:59 <mm_freak_> lispy: not with an Ord constraint
18:59:04 <Krimpet> I'm wondering what the best way to read input_event structs from /dev/input/eventX would be. Can it be done in Haskell, or is it better to use C and the FFI?
18:59:12 <mm_freak_> since 'sort' requires the Ord constraint, too, there is nothing lost
18:59:17 <aristid> mm_freak_: show what you mean, man:)
18:59:25 <lispy> mm_freak_: yes, I wish we had a nub' in Prelude with an Ord constraint
18:59:26 <aavogt> > sortl (cycle [minBound .. maxBound :: Int ])
18:59:33 <lambdabot>   mueval: ExitFailure 1
19:00:25 <lispy> But can nub on Ord really be both better than O(n^2) and return results immediately?
19:00:38 <mm_freak_> lispy: yes
19:00:45 <mm_freak_> just replace list by Set
19:00:52 <lispy> ?src nub
19:00:53 <lambdabot> nub = nubBy (==)
19:00:55 <copumpkin> that won't return results immediately
19:00:58 <lispy> ?src nubBy
19:00:58 <lambdabot> nubBy eq []             =  []
19:00:58 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
19:01:04 <mm_freak_> copumpkin: it will, and i've tested it
19:01:08 <copumpkin> oh?
19:01:11 <dh__> how can I create a double list comprehension ? where x <- [1..10], and y <- [1..x ] ? 
19:01:28 <mm_freak_> aristid: look at nub's implementation
19:01:30 <mm_freak_> it's easy =)
19:01:36 <aavogt> dh__: use a comma
19:01:39 <mm_freak_> just carry a list of already seen values along
19:01:42 <copumpkin> mm_freak_: by immediately you mean what?
19:01:51 <mm_freak_> copumpkin:
19:01:54 <copumpkin> in O(n) time?
19:01:56 <mm_freak_> > nub [1..]
19:01:57 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:02:03 <aavogt> dh__: or exactly as you wrote, but leave the `and' out
19:02:10 <mm_freak_> i mean it's lazy
19:02:11 <copumpkin> mm_freak_: you can't make an infinite set
19:02:12 <aristid> copumpkin: that's O(n^2) worst case for unique sets
19:02:19 <dh__> > [ a | b<-[1..a], a <- [1..10]]
19:02:20 <aristid> argg
19:02:20 <mm_freak_> copumpkin: the set doesn't get infinite
19:02:21 <lambdabot>   *Exception: not a number
19:02:23 <aristid> i mean mm_freak_
19:02:33 <luite> you could make a Set with elements that have alreay been seen, but that's not exactly replacing list with set
19:02:42 <mm_freak_> copumpkin: if you don't consume the entire infinite result list, the set stays finite, too
19:03:14 <mm_freak_> luite: why not?
19:03:18 <JoeyA> lispy:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29430#a29430
19:03:33 <JoeyA> There's my implementation of nub that uses Data.Set
19:03:36 <aristid> mm_freak_: let's take the input list [1..n], then the complexity on that is O(n^2) with your algo, whereas group.sort is faster
19:03:43 * hackagebot hfractal 0.4.2.2 - OpenGL fractal renderer  http://hackage.haskell.org/package/hfractal-0.4.2.2 (ChrisHoldsworth)
19:03:52 <JoeyA> And it returns results incrementally.
19:03:55 <mm_freak_> aristid: no, it's O(n * log n)
19:04:13 <JoeyA> The Prelude nub is O(n^2)
19:04:20 <JoeyA> I've tested it.
19:04:32 <JoeyA> The one using Data.Set is noticeably faster.
19:04:32 <mm_freak_> aristid: asking for elements and adding elements is an O(log n) operation
19:04:36 <mm_freak_> for Set
19:04:40 <lispy> member is O(log n), right?
19:04:44 <dh__> last time I got interviewed, the interviewer said O(n + log n ) /= O (n) , is he right ? 
19:04:50 <aristid> :t member
19:04:52 <lambdabot> Not in scope: `member'
19:04:54 <mm_freak_> lispy: for Set, yes
19:04:57 <mm_freak_> :t S.member
19:04:58 <lambdabot> forall a. (Ord a) => a -> S.Set a -> Bool
19:05:04 <luite> dh__: no
19:05:24 <JoeyA> dh__> As n approaches infinity, the log n term becomes negligible.
19:05:25 <Cale> dh__: no, O(n + log n) = O(max(n, log n)) = O(n)
19:05:29 <JoeyA> Thus, the interviewer is wrong.
19:05:49 <dh__> luite: I didn't get that job , lol, its' google, lol
19:05:53 <aavogt> might be a trick question
19:06:02 <orbitz> it's a trap!
19:06:15 <lispy> yeah, they might want to explain why it's not equal
19:06:16 <luite> hmm, are you sure that's exactly what he said? or maybe it was just a trick to see if you really knew what it meant
19:06:31 <lispy> could be a test of a) expertise b) how you politely correct someone
19:06:52 <dh__> it's google china , I think that guy really don't know he is wrong. 
19:06:56 <aavogt> or c) an explantion of how they roll
19:06:57 <mm_freak_> well, btw
19:07:17 <JoeyA> By the way, beware of Data.List.Ordered's nub implementation.  It simply makes sure a[i] <= a[i+1], so it's not even the same function!
19:07:19 <mm_freak_> the function should have the following type:  Ord a => [a] -> Set a
19:07:59 <JoeyA> What should?
19:08:03 <kmc> sigh asymptotic complexity
19:08:08 <lispy> JoeyA: Bah.  Really?
19:08:14 <mm_freak_> that function, which only returns list elements, which are found multiple times
19:08:20 <lispy> JoeyA: how is that better than a solution using group?
19:08:23 <mm_freak_> unless their order matters, of course
19:08:28 <JoeyA> lispy: It's lazy.
19:08:38 <JoeyA> Meaning it starts giving results right away.
19:08:40 <copumpkin> has anyone written a library for reasoning about Os and thetas and omegas?
19:08:49 <JoeyA> When a duplicate comes along, it filters it out.
19:08:56 <mm_freak_> copumpkin: how could a library help you?
19:09:01 <JoeyA> group/sort is faster, I'd imagine.
19:09:03 <lispy> copumpkin: can't you do that to some extent in Isabelle?
19:09:04 <aristid> JoeyA: map head . group is lazy too
19:09:14 <aristid> :t map head . group
19:09:14 <JoeyA> But sort is not
19:09:15 <lambdabot> forall a. (Eq a) => [a] -> [a]
19:09:19 <JoeyA> sort is needed for the technique.
19:09:29 <aristid> JoeyA: well but if it works only on pre-sorted lists, then...
19:09:30 <JoeyA> (of removing duplicate items)
19:09:31 <mm_freak_> JoeyA: i wouldn't count on that
19:09:35 <copumpkin> mm_freak_: comparing them, etc.
19:09:44 <JoeyA> Wouldn't count on Data.Set being lazy?
19:09:44 <copumpkin> lispy: dunno, haven't tried
19:09:49 <JoeyA> Or sort not being lazy?
19:09:51 <aristid> :t head <$> group
19:09:52 <lambdabot> forall a. (Eq a) => [a] -> [a]
19:09:58 <mm_freak_> JoeyA: wouldn't count on 'sort' being faster than constructing a Set
19:09:58 <copumpkin> sort is as lazy as it can be
19:10:13 <aristid> oh, misleading.
19:10:18 <lispy> copumpkin: it seems like the sort of thing you'd want in a termination checker
19:10:27 <JoeyA> It has to read the entire input before it knows the minimum (a.k.a. the first item), though.
19:10:33 <aristid> :t (head <$>) <$> group
19:10:34 <lambdabot> forall a. (Eq a) => [a] -> [a]
19:10:47 <lispy> copumpkin: in so much that, knowing the complexity is a stronger result than just knowing termination
19:10:51 <copumpkin> lispy: a termination checker would typically not reason explicitly about the big-O stuff though, but rather look for "terminatey behavior", such as structural recursion on something that is obviously getting smaller at eac iteration
19:11:08 <copumpkin> at least as far as I know
19:11:19 <lispy> That's my understanding as well
19:11:40 <mm_freak_> JoeyA: on my computer constructing a Set with 10^6 elements takes about the same time as sorting a list with 10^6 elements
19:11:50 <JoeyA> Interesting
19:12:09 <JoeyA> Are you sure you actually traversed the set afterward?
19:12:24 <JoeyA> (well, you don't need to traverse it if you're just looking for dupes)
19:13:49 <mm_freak_> JoeyA: i made sure now by calculating the sum of all elements
19:13:53 <mm_freak_> still takes the same time
19:14:01 <mm_freak_> but wait, that was on GHCi
19:14:12 <mm_freak_> i'll compile to see exact numbers
19:14:14 <lispy> But wait, there's more.
19:14:28 <lispy> Compile now, and  we'll throw in this lovely set of types!
19:15:03 <JoeyA> It's strange that building an immutable Set is just as fast as sorting lists.
19:15:58 <Cale> In a sense that's where the asymptotically fastest sorting algorithms come from
19:16:05 <lispy> statistically robust benchmarks or it didn't happen!
19:16:15 * lispy points at criterion/progression
19:17:09 <monochrom> reproducible or it didn't happen
19:17:21 <lispy> monochrom: oh you scientists.
19:17:40 <Veinor> peer-reviewed papers or gtfo?
19:17:42 <monochrom> yes, the only reasonable attitude to programming
19:19:11 <mm_freak_> ok, i've written two versions of findDups now
19:19:17 <mm_freak_> one using group . sort, one using Set
19:19:42 <mm_freak_> the latter version is slightly slower (taking 3.3 secs for 10^6 elements)
19:19:46 <mm_freak_> the former takes only 3 secs
19:20:34 <mm_freak_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29431#a29431
19:21:19 <mm_freak_> however, findDups2 is lazy
19:21:36 <blackh> Hey Haskell people!  Is there an error monad (standard or on hackage) that doesn't suck?  i.e. like Either with a monad instance that translates fail to Left ?
19:21:36 <Cale> Yeah, I was about to say "and if you only take the head of the list?" :)
19:21:36 <lambdabot> blackh: You have 1 new message. '/msg lambdabot @messages' to read it.
19:21:37 <mm_freak_> findDups1 has to sort the entire list, before it can produce any result
19:22:09 <mm_freak_> blackh: isn't Either a monad already?
19:22:11 <Cale> blackh: The one which translates fail x to Left (error x) ?
19:22:11 <monochrom> translates «fail "hi"» to Left what?
19:22:27 <blackh> Cale: Yes that's what I want.
19:22:40 <mm_freak_> > let Left x = fail "abc" in x
19:22:41 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:22:41 <lambdabot>    `Control.Monad.Error.Cla...
19:22:45 <blackh> Cale: Well, actually I don't care about fail.
19:22:51 <Cale> blackh: The one in Control.Monad.Error doesn't do that. I'm not sure if there's a packaged version of that one.
19:22:59 <mm_freak_> > let (Left x :: Either String Int) = fail "abc" in x
19:22:59 <lambdabot>   "abc"
19:23:12 <Cale> Control.Monad.Error requires an instance of Error for the left type parameter.
19:23:15 <JoeyA> findDups would be even faster if it used a mutable map, I'd imagine.
19:23:23 <JoeyA> I don't think anyone's written one for Haskell yet.
19:23:28 <Cale> (because of the fail silliness)
19:23:48 <blackh> Actually one without fail is probably better for what I want.
19:23:59 <blackh> Well, basically I just want something simple and composable. :)
19:24:22 <monochrom> http://hackage.haskell.org/packages/archive/neither/0.0.0/doc/html/Data-Neither.html
19:24:26 <mm_freak_> JoeyA: well, if you want to have:  findDups :: (MutableMapMonad m, Ord a) => [a] -> m [a]
19:24:29 <mm_freak_> ;)
19:25:01 <mm_freak_> blackh: Maybe isn't enough?
19:25:11 <blackh> No - I want an error message
19:25:23 <lispy> JoeyA: I'd be really skeptical about the mutable one being faster.  Haskell allows so much sharing between updates that you're really just talking about the overhead to GC the stuff that is no longer needed
19:25:35 <mm_freak_> blackh: otherwise look into monadLib, which gives you an error monad and also generalizes the exception interface to other monads
19:25:39 <Eelis> blackh: then why exactly is the existing Monad (Error String) instance in Control.Monad.Error (or something) not good enough?
19:27:28 <blackh> Eelis: It probably is my best option. Thanks kindly yall
19:27:30 <dh__> mm_freak_: I don't understand your findDups1, can u explain a little ? 
19:27:59 <dh__> mm_freak_: is the do end with ; ? 
19:28:12 <mm_freak_> well, personally i don't like to abuse Either for errors
19:28:25 <Eelis> mm_freak_: what makes it abuse?
19:28:29 <mm_freak_> there is this nice ExceptionT, which is great for the purpose, if you want errors
19:28:50 <mm_freak_> Eelis: well, not exactly "abuse", but it looks strange to have 'Left' instead of 'Failed'
19:29:05 <mm_freak_> dh__: it uses the list monad
19:29:06 <Eelis> mm_freak_: you don't have Left, you have fail
19:29:12 <Eelis> (in the code)
19:29:43 <Eelis> or do you mean in the error handler?
19:29:43 <mm_freak_> Eelis: anyway, ExceptionT gives me better control over failing
19:30:05 * Eelis uses    type E = Error String   and finds it very convenient and sees very few down sides
19:30:11 <Eelis> *Either
19:30:15 <mm_freak_> i can catch exceptions inside of the monad, for example
19:30:36 <mm_freak_> dh__:
19:30:47 <dh__> mm_freak_: yes? 
19:30:49 <mm_freak_> > do x <- [1,2,3]; return (x+5)
19:30:50 <lambdabot>   [6,7,8]
19:30:58 <mm_freak_> x represents 1, 2 and 3
19:31:03 <mm_freak_> that's the list monad:  non-determinism =)
19:31:26 <mm_freak_> and in the list monad a pattern match failure is equivalent to the empty list
19:31:27 <dh__> mm_freak_: where is the non-determinism coming from ? 
19:31:35 <randomwords> Is there a faster alternative to truncate?
19:31:50 <mm_freak_> > do Just x <- [Just 3, Just 4, Nothing, Just 5]; return x
19:31:51 <lambdabot>   [3,4,5]
19:32:09 <mm_freak_> dh__: from the definition of the list monad
19:32:22 <mm_freak_> see the Monad instance for []
19:32:22 <Eelis> dh__: the "non-determinism" is just a silly loaded label people like to put in their particular interpretation of "set of values instead of single value"
19:32:24 <dh__> cool, I'll read some paper on that :)
19:32:42 <dh__> @src Monad []
19:32:43 <lambdabot> Source not found. Do you think like you type?
19:32:55 <mm_freak_> i don't think you need to read a paper to understand the list monad =)
19:33:21 <dh__> where is the source of Monad [] ? 
19:33:31 <mm_freak_> Eelis: well, non-determinism is a good interpretation IMO, because one name stands for arbitrarily many values
19:33:40 <mm_freak_> @src [] (>>=)
19:33:40 <lambdabot> xs >>= f     = concatMap f xs
19:33:43 <mm_freak_> @src [] return
19:33:43 <lambdabot> return x    = [x]
19:34:05 <djahandarie> The source of Monad [] is not in lambdabot mm_freak_
19:34:10 <djahandarie> Can someone just remove that function?
19:34:39 <Eelis> mm_freak_: i don't see why the first part of your statement (before the "because") follows from the second (after the "because")
19:35:10 <Eelis> the "arbitrarily many values" thing would be the most neutral interpretation. putting the label "nondeterminism" on that is just a choice
19:35:25 <mm_freak_> Eelis: good question, but interpretations are intuitive after all =)
19:35:28 <dh__> > 1 : 2 
19:35:29 <lambdabot>   No instance for (GHC.Num.Num [t])
19:35:29 <lambdabot>    arising from a use of `e_112' at <inte...
19:35:36 <dh__> > 1 : [2] 
19:35:37 <lambdabot>   [1,2]
19:35:43 <dh__> > 1 : [2] : [3]
19:35:44 <lambdabot>   No instance for (GHC.Num.Num [t])
19:35:45 <lambdabot>    arising from a use of `e_1123' at <int...
19:35:54 <dh__> :i (:)
19:36:01 <Eelis> i'm pretty sure there are algorithms that use the list monad where the nondeterminism interpretation is awkward while the "set of values" neutral interpretation *does* make sense
19:36:11 <randomwords> @src truncate
19:36:12 <lambdabot> Source not found. I am sorry.
19:36:22 <Eelis> of course, i can't produce one off the top of my head.
19:36:32 <mm_freak_> Eelis: and there are algorithms, for which the non-determinism interpretation really fits
19:36:47 <mm_freak_> especially when you use monadic functions like filterM or foldM
19:37:09 <dh__> do x:_:_ <- [1,2,3] ; [x]
19:37:19 <dh__> > do x:_:_ <- [1,2,3] ; [x]
19:37:19 <Eelis> mm_freak_: sure, but that's beside the point. the point is that by tying the list monad to nondeterminism you're awkwardly putting baggage on it that only fits /sometimes/, which is really a shame
19:37:20 <lambdabot>   No instance for (GHC.Num.Num [b])
19:37:20 <lambdabot>    arising from a use of `e_1123' at <int...
19:37:46 <dh__> > do x:_:_ <- [1,2] ; [x]
19:37:47 <lambdabot>   No instance for (GHC.Num.Num [b])
19:37:47 <lambdabot>    arising from a use of `e_112' at <inte...
19:37:55 <mm_freak_> Eelis: a computation is nondeterministic, if it allows arbitrarily many outcomes
19:37:59 <mm_freak_> so what's wrong with that?
19:38:21 <dh__> > do x:_:_ <- [[1],[2,2],[3]]; [x]
19:38:22 <lambdabot>   [2]
19:38:50 <luite> > do { ~(x:xs) <- []; return x }
19:38:51 <lambdabot>   []
19:39:01 <Eelis> mm_freak_: so you deny that there are list-monad algorithms for which the nondeterminism interpretation is awkward? again, i can't produce counterexamples off the top of my head, so if you want to disbelieve me for that reason, be my guest.
19:39:15 <dh__> mm_freak_; I think the x:_:_ is hard to read. 
19:39:56 <mm_freak_> Eelis: i don't "disbelieve" you, i just tell you that the nondeterminism interpretation really fits the '<-' syntax
19:40:21 <mm_freak_> and also whenever you use a monadic function from Control.Monad you're dealing with the nondeterminism interpretation
19:40:23 <Eelis> mm_freak_: which conflicts with what i'm saying, hence the disbelief.
19:40:37 <mm_freak_> disagreement =)
19:41:09 <mm_freak_> dh__: it's a normal pattern
19:41:21 <mm_freak_> if you find it hard to read, you are going to find most haskell code hard to read =)
19:41:39 <luite> why don't irrefutable patterns work in a do block, using <- ?
19:42:03 <Eelis> mm_freak_: list's >>= is basically flip concatMap. does it not seem plausible to you that concatMap is more widely useful than just in nondeterminism contexts?
19:42:22 <mm_freak_> > do ~(Just x) <- Nothing; [3]
19:42:22 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
19:42:23 <lambdabot>         against inferred ...
19:42:28 <FSalad_III> would it be considered very violating of "be clear, not clever" to use RecordWildCards when implementing a function of type Foo -> Foo? :P
19:42:35 <mm_freak_> > do ~(Just x) <- [Nothing]; [3]
19:42:36 <lambdabot>   [3]
19:42:42 <mm_freak_> > do Just x <- [Nothing]; [3]
19:42:43 <lambdabot>   []
19:42:49 <mm_freak_> luite: according to that they work
19:42:51 <dh__> mm_freak: I'm still new to Haskell. I do find Yampa is hard to read. 
19:42:53 <aavogt> > do { ~(x:xs) <- [[]]; return x }
19:42:54 <lambdabot>   [*Exception: <interactive>:1:133-164: Irrefutable pattern failed for patter...
19:43:15 <luite> oh yeah.. sorry :(
19:43:16 <luite> my fault
19:43:24 <luite> my example was wrong
19:43:32 <FSalad_III> example: transformFoo f@Foo{..} = f { field1 = blah field1, field2 = blub field1 field2 }
19:43:44 <FSalad_III> (no recursion happens there)
19:44:11 <djahandarie> dh__, why in the world are you trying to fool with Yampa if you're new to Haskell?
19:44:15 <FSalad_III> it does save a lot of boilerplate, which isn't just good for writing it, it also makes the code easier to read
19:44:17 <mm_freak_> Eelis: you can always fit it into the nondeterminism interpretation…  after all concatMap takes a nondeterministic function and a list and collects all results
19:44:30 <FSalad_III> but it may be slightly confusing if the reader isn't expecting it
19:44:32 <dolio> FSalad_III: Isn't that pretty standard?
19:44:35 <dh__> djahandarie: I come from a game background .
19:44:45 <mm_freak_> dh__: i recommend not to dive into FRP now
19:44:51 <FSalad_III> dolio: hmm is it?
19:45:06 <mm_freak_> learn haskell properly before you do…  even i find FRP hard at times =)
19:45:08 <dolio> I guess the punning may not be.
19:45:32 <djahandarie> dh__, Yampa uses arrows which are grossly abstract and take a lot to get used to. Even with the knowledge of how arrows work, arrow-based FRP is a bit tough to wrap your head around
19:45:32 <mm_freak_> (but i'm not a genius, so that doesn't mean anything)
19:46:00 <FSalad_III> dolio: just wildcards... "sadly" ;) I don't think I can both pattern match with a wildcard, and use punning to update the record ;)
19:46:04 <dh__> I have no problem with arrows , but have problem with rec or ArrowLoop , :)
19:46:30 <FSalad_III> but wildcards are a shortcut for a punning pattern match I guess
19:46:32 <Eelis> mm_freak_: i think the key to our disagreement is that the nondeterminism intepretation hinges on the idea that the order of the values in the result is irrelevant, while in many applications of concatMap the order /is/ relevant
19:46:35 <dh__> mm_freak_: why your second example return [] ?  do Just x <- [Nothing]; [3]
19:46:59 <mm_freak_> dh__: because an irrefutable pattern match never fails
19:47:09 <FSalad_III> (and my concern is indeed with the wildcard, apart from it it's standad, sure)
19:47:11 <Eelis> mm_freak_: and for those applications, the nondeterminism interpretation is actually harmful because it brushes off an important property
19:47:12 <mm_freak_> while the normal pattern match does fail
19:47:36 <mm_freak_> Eelis: yes, that's true
19:47:43 <dh__> so what happen when it's failed ? do [3] equal to return 3 ? 
19:47:52 <dh__> s/do/ does
19:48:00 <mm_freak_> dh__: yes
19:48:01 <Eelis> mm_freak_: then again you could probably argue that those applications are somehow morally forbidden from using monad syntax ;P
19:48:04 <ksf> has there ever been an approach to do a tracing jit implementanion of haskell?
19:48:18 <mm_freak_> dh__: in the list monad pattern match failure means the empty list
19:48:21 <mm_freak_> @src [] fail
19:48:21 <lambdabot> fail _      = []
19:48:35 <dh__> oh, nice to know, thanks.
19:48:37 <dolio> Lists as a monad are a specific algorithm for computing all the results of a nondeterministic computation (possibly multiple times).
19:48:43 <dolio> Namely, depth-first search.
19:48:57 <mm_freak_> (uh oh)
19:49:13 <dolio> Similar to how computation is rather nondeterministic in, say, Prolog.
19:49:18 <FSalad_III> (alternatively, a funny way to write concatMap)
19:49:20 <FSalad_III> ;)
19:49:22 <dolio> But it all happens in a particular order.
19:49:57 <mm_freak_> Eelis: but actually nondeterminism doesn't rule out the significance of order
19:50:22 <dh__> for game programming in Haskell, other than Yampa, what else are available ? I believe the others using Monad a lot , and look like imperative programming , right ? 
19:50:46 <dh__> I just need a beginning project to learn Haskell, either in game, or web server. 
19:50:46 <mm_freak_> dh__: besides Yampa i've tried Elerea, which is fine and has a monadic syntax
19:50:58 <mm_freak_> s/syntax/interface/
19:51:11 <dh__> thanks, I'll try
19:51:28 <mm_freak_> i found Yampa more elegant, but Elerea is easier to understand
19:51:46 <Eelis> mm_freak_: sure, but it does mean that just saying "the list monad is for nondeterminism" isn't really honest because there's more to it than that. the very long phrasing described by dolio is at least honest, but its length is such that it doesn't make it quite as pleasant to throw at newbies :P
19:52:06 <tnks> I'm trying to learn if the IO monad's sequencing is given special treatment by the compiler.
19:52:28 <tnks> or can I hand roll my own IO monad, the way I can handroll my own List monad?
19:52:53 <Eelis> and that longer phrasing also makes it clear that to make the nondeterminism interpretation mesh, you need to be very specific about it, which makes it even more likely to be an awkward fit to general uses of concatMap
19:52:55 <mm_freak_> tnks: you can't handroll something like IO without getting hacky and using low level stuff
19:53:25 <mm_freak_> tnks: remember that execution is outside of the language – IO is a language
19:54:26 <tnks> mm_freak_: okay, that's good to know.
19:54:56 <tnks> I was curious, and for some reason couldn't find that spelled out too clearly.
19:55:08 <tnks> mm_freak_: feel free to point me to something that explains that clearly.
19:55:30 <mm_freak_> tnks: lengthy discussions on haskell-cafe =)
19:55:47 <dolio> You can conceive of the purpose of a Haskell program is to produce a value main :: IO (), which is some opaque type that some external driver knows what to do with.
19:56:13 <tnks> dolio: yeah, I think I can appreciate that.
19:56:16 <dolio> And the value you produce encodes all the IO stuff you want to happen.
19:56:36 <mm_freak_> my mental model of IO is this:  type IO = ContT RealWorld (State RealWorld)
19:56:43 <mm_freak_> but this is highly controversial
19:56:54 <ksf> tnks, the implementation of the IO monad is... implementation dependent.
19:56:55 <tnks> mostly, I just wanted to know so I'm not under any misapprehensions that the execution had anything to do with functional application or lazy evaluation.
19:56:58 <dolio> You can write an expression model of that sort of thing in Haskell.
19:57:01 <mm_freak_> most people prefer to view IO as an opaque DSL
19:57:26 <Cale> Actually, I'm going to contradict mm_freak_ and say that you *can* handroll IO without getting into low-level stuff, but the runtime system that knows how to actually carry out IO actions is something else :)
19:57:38 <dolio> But how you look at that expression representation and actually do what it says is built-in to the compiler/runtime system.
19:58:02 <Cale> One possibility is: 
19:58:06 <Cale> data IO a where
19:58:11 <Cale>   ReturnIO :: a -> IO a
19:58:21 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
19:58:26 <Cale>   GetChar :: IO Char
19:58:34 <mm_freak_> Cale: then what would runIO look like?
19:58:35 <Cale>   ... etc for other IO primitives ...
19:59:05 <Cale> mm_freak_: That would be part of the low-level driver which would pattern match on the algebraic datatype and really carry out the IO actions.
19:59:10 <ksf> well, one could, for example, implement an IO monad that talks over a socket to a server that serves your requests.
19:59:16 <Cale> If it were written in Haskell, it would look like:
19:59:22 <mm_freak_> Cale: at which point you need IO again =)
19:59:27 <Cale> runIO (ReturnIO v) = return v
19:59:29 <mm_freak_> chicken and egg problem
19:59:45 <dolio> Cale: Incidentally, it seems like the solution to making that handle FFI is to say that it's an open type. A foreign import declares a new constructor, that the RTS knows what to do with.
19:59:45 <ksf> you can even do that with plain, old interact.
19:59:46 <Cale> runIO (BindIO x f) = do v <- runIO x; runIO (f v)
20:00:02 <Cale> runIO GetChar = getChar
20:00:04 <Cale> and so on
20:00:14 <Cale> dolio: yeah
20:00:21 <mm_freak_> Cale: that's not really useful, it's just a wrapper type for an already-existing IO
20:00:22 <dolio> And open types aren't unheard of.
20:00:33 <mm_freak_> as said, you're running into a chicken/egg problem there
20:00:36 <dolio> Despite their not being in any implementation I'm aware of.
20:00:41 <Cale> mm_freak_: Well, every self-hosting compiler/interpreter is a chicken and egg problem
20:01:01 <mm_freak_> Cale: the original implementation is always written in another language =)
20:01:16 <mm_freak_> so if you cheat, you can go outside of the haskell world and write the IO interpreter in C
20:01:18 <Cale> mm_freak_: Right, I said *if* it were written in Haskell, that's how it would look
20:01:25 <dolio> Actually, I guess JHC has a similar open GADT for type reps/classes.
20:01:27 <Cale> You could also write that interpreter in C.
20:01:55 <mm_freak_> Cale: what would make more sense is a runIO, which is a compiler
20:02:04 <mm_freak_> runIO :: IO a -> ByteString
20:02:44 <mm_freak_> but anyway, we're dealing with two separate problems here
20:02:54 <mm_freak_> 1. doing the actual running/compiling practically
20:03:05 <mm_freak_> 2. interpreting the meaning of IO from a theoretical standpoint
20:03:06 <Cale> But in any case, interpreting the IO actions is separate from building them in the first place
20:03:27 <chrisdon`> anyone here run hpaste?
20:04:17 <mm_freak_> if god is written in haskell, his IO type is probably some combination of ContT and State =)
20:04:24 <Cale> You can (and maybe even should in some cases), define your own version of the IO monad, along with a translation into a lower-level one.
20:04:35 <Cale> I disagree about the state part.
20:04:47 <Cale> IO doesn't look like a state monad
20:05:01 <Cale> (in the sense of functions s -> (s,a))
20:05:05 <mm_freak_> Cale: well, that's controversial
20:05:06 <djahandarie> chrisdon`, it has come down to randomly asking the IRC channel? :P
20:05:15 <Cale> forkIO gets in the way
20:05:25 <chrisdon`> Cale: most things do though, right?
20:05:29 <mm_freak_> Cale: it doesn't, because it changes the world to include a new thread
20:05:30 <dolio> s -> (s, a) is a poor model.
20:05:35 <chrisdon`> writeIORef a x
20:05:35 <chrisdon`> xreadIORef
20:05:42 <mm_freak_> my model is not State
20:05:46 <mm_freak_> but ContT + State
20:05:50 <chrisdon`> balls. well, anyway. any value read in from an IO action might as well be random
20:06:09 <JoeyA> Can I import two .hs files with ghci at the same time?
20:06:17 <ddarius> Yay, more stupid debate about a stupid model.
20:06:21 <chrisdon`> djahandarie: yep. no one knows
20:06:23 <JoeyA> When I say ghci Foo.hs Bar.hs, it doesn't make Bar.hs available.
20:06:43 <Cale> I contend that there's no actual state type that you can define for which IO can be modelled like that.
20:06:43 <FSalad_III> another solution to the record update boilerplate problem... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29432#a29432
20:06:45 <chrisdon`> glguy says in email: I believe that mmorrow from #haskell runs it. I've been out of the loop for a while on this.
20:06:49 <FSalad_III> :]
20:07:00 <chrisdon`> and seeing as mmorrow is Gone Forever
20:07:10 <mm_freak_> anyway
20:07:12 <djahandarie> lol why not just come up with some entirely different service and get the @where stuff in lambdabot changed
20:07:22 <mm_freak_> IO interpretation is a never-ending story =)
20:07:26 <djahandarie> And any wiki links etc
20:07:30 <mm_freak_> let's leave it at that
20:07:58 <chrisdon`> djahandarie: because I wanted to get to the person hosting it before proposing to bryan that he point the domain to my server
20:08:11 * ManateeLazyCat pasted "SimpleIRC error" at http://paste2.org/get/963234
20:08:12 <ManateeLazyCat> dom96: I'm testing your SimpleIRC example with command "ghc --make ./example.hs", but i got above error, any idea?
20:08:26 <ManateeLazyCat> dom96: Have you test SimpleIRC on ghc-6.12.3?
20:08:40 <ddarius> We could go back to the old, hacky solution I suggested.
20:08:55 <chrisdone> ddarius: what is that solution?
20:09:00 <ddarius> Actually, I guess we can't.
20:09:04 <chrisdone> (just invite lisppaste back in? ;-)
20:09:13 <djahandarie> chrisdone, doesn't Bryan know who is running it?
20:09:15 <mm_freak_> i'm having a deja-vu
20:09:19 <chrisdone> djahandarie: no
20:09:20 <ddarius> chrisdone: No.  On the old wiki there was a HaskellIrcPastePage.
20:09:36 <Axman6> everyone look out, mm_freak_ is giving birth to a font!
20:09:37 <djahandarie> chrisdone, I don't think he'd have a problem with pointing the domain elsewhere then...
20:09:37 <Cale> I sometimes really miss the old wiki
20:09:39 <ddarius> It worked, actually, extremely well, because people would see what others were doing.
20:09:52 <ddarius> And it ended up being more social than typical paste sites.
20:09:52 <FSalad_III> LOL apparently I actually pasted lambdas there as CPP line-continuation symbols
20:10:00 <djahandarie> I miss the new wiki
20:10:00 <Axman6> let's hope it's sans serif, could be painful
20:10:04 <FSalad_III> (using the 'haskell cuteness' vim script)
20:10:11 <Cale> The new wiki totally killed the community aspect of things.
20:10:18 <Cale> Well, maybe not *totally*
20:10:48 <ksf> int bar[__LINE__]
20:10:57 <ksf> C comes with some really strange features.
20:11:11 <chrisdone> djahandarie: no, I mean the person hosting it might, if I, instead of contacting him, just disregarded his work and got the domain pointing elsewhere
20:11:40 <Axman6> ksf: ha, i love it!
20:11:53 <djahandarie> chrisdone, it really seems like he doesn't care at all about it since it goes down like every other day
20:11:58 <Axman6> code position dependant corruption errors!
20:12:19 <Cale> chrisdone: If it's mmorrow who is hosting it, maybe you'd get his attention and we'd at least learn that he's alive :P
20:12:28 <chrisdone> djahandarie: oh, 'he'? -- sexist! ;-p
20:12:42 <chrisdone> Cale: good point. let's do it
20:12:57 <djahandarie> I already look like a jerk saying that, I don't need to look like a sexist jerk
20:13:01 <chrisdone> ddarius: how did it work?
20:13:29 <ddarius> chrisdone: It was just a wiki page.  There was no mechanism.
20:13:40 <chrisdone> ddarius: one really huge wiki page?
20:14:01 <ddarius> chrisdone: Occassionally it would be cleared out.  Also, #haskell was smaller then.
20:14:14 <lispy> ?users
20:14:15 <lambdabot> Unknown command, try @list
20:14:21 <lispy> Why was that command removed?
20:14:23 <FSalad_III> ehm don't his hackage packages say 'Matt Morrow'?
20:14:25 <Cale> chrisdone: Yeah, whenever it got too large, people would prune things and move the good bits elsewhere.
20:14:27 <chrisdone> memory leak, apparently
20:14:51 <lispy> chrisdone: so, instead of fixing the memory leak we got rid of a nice and useful command.  What kind of coders are we? :)
20:15:00 <ddarius> lispy: Lazy coders.
20:15:10 <djahandarie> Man, for Haskell being so awesome it seems like a bunch of things break around here
20:15:26 <lispy> Also, I don't think it actually fixed the memory leaks in lambdabot 
20:15:29 <chrisdone> lazy coders dealing with lazy code, laziness + laziness does not a discipline make :(
20:15:31 <FSalad_III> (almost implying maleness)
20:15:46 <ddarius> djahandarie: lambdabot was put together by random people on the channel, often beginners, and was also an experimenting ground for various technologies.
20:15:56 <lispy> FSalad_III: did you change you nick?
20:15:57 <FSalad_III> at least I can't think of a female name abbreviated to 'Matt'
20:15:58 <lispy> your*
20:16:02 <djahandarie> ddarius, I know
20:16:09 <lispy> FSalad_III: Matilda?
20:16:12 <FSalad_III> lispy: no, it's my alternative nick, don't know why I always end up with it
20:16:21 <FSalad_III> lispy: :)
20:16:22 <chrisdone> Cale: that's kind of nice
20:16:28 <djahandarie> Oh, that's you isn't it FunctorSalad
20:16:31 <Cale> lispy: I guess if you wanted to blame someone, you could blame me. It didn't just leak memory. Whenever lambdabot died, it would trash its own database which would have to be restored from a backup before lambdabot would run again.
20:16:45 * lispy could tell it was FunctorSalad by the voice, but the nick was a nice tip off too
20:16:46 <Cale> I didn't want to bother looking at it.
20:16:50 <chrisdone> haha, not just dying, but dying spitefully
20:16:51 <FSalad_III> apparently it's less obvious than I thought :)
20:16:55 <Cale> Especially as there are other bots doing the job.
20:17:07 <lispy> Cale: heh.  Sounds fun.
20:17:14 <lispy> preflex: users
20:17:14 <chrisdone> that's the computer program equivalent of getting blood on you
20:18:06 <Cale> So I eventually got fed up with restoring the seen file and just removed it entirely.
20:18:10 <ddarius> "I know I shivved you in the gut, but that was no reason for you to get blood on my khakhis.
20:18:27 <ddarius> Cale: We were talking about @users.
20:18:35 <lispy> ddarius: Unexpected '\n', expected '"'.
20:18:41 <Cale> Presumably that was part of the same plugin.
20:18:54 <Cale> I don't remember explicitly removing @users
20:19:08 <lispy> Putting it in the same plugin makes sense
20:19:52 <Cale> yes,  moduleCmds _ = ["users","seen"]
20:20:14 <lispy> too bad it's leaky, but hey I don't feel like fixing it either.  I'd rather work on other stuff too.
20:20:48 <lispy> Isn't lambdabot meant to be run by some graduate student that works on it instead of their research?
20:20:54 <ManateeLazyCat> @tell dom96 SimpleIRC example error with ghc-6.12.3 at http://paste2.org/get/963234
20:20:54 <Cale> The seen plugin is over 400 lines of code :P
20:20:54 <lambdabot> Consider it noted.
20:20:56 <djahandarie> Haha
20:21:11 <chrisdone> lispy: true, needs new recrutes
20:21:20 <ddarius> lispy: No, you just have lambdabot be part of your research.
20:21:23 <mm_freak_> Data.List.permutations is very lazy and works even for infinite lists…  is that because of the algorithm or because of optimizations?
20:21:29 <chrisdone> uh, recruits
20:21:38 <djahandarie> I wonder how fancy you could make working on lambdabot sound
20:21:39 <lispy> ddarius: Well, that works for dons, but he's clever like that.
20:21:50 <FSalad_III> $( insert joke about how this is the case, except with some ... way lower academic echelon than 'graduate students' )
20:22:17 <lispy> FSalad_III: There is no lower eschelon than graduate student
20:22:24 <aavogt> undergraduate
20:22:33 <ksf> start off with "real-time social media interaction"
20:22:36 <FSalad_III> primary school children? :P
20:22:44 <djahandarie> Haha
20:22:48 <ddarius> ksf: + "dynamically extensible"
20:22:51 <djahandarie> Make sure to include all the Haskell buzzwords too
20:22:59 <lispy> Actually, lambdabot is meant for social learning and coding assistance
20:22:59 <kmc> FSalad_III, nice top level splice you've got there
20:23:07 <aavogt> combinators
20:23:15 <lispy> There are actual cool legitimate research you could use lambdabot for
20:23:59 <chrisdone> @vixen what do you think about being experimented upon?
20:24:00 <lambdabot> what about me?
20:24:03 <FSalad_III> ( in primary school )
20:24:07 <FSalad_III> scnr ;)
20:24:07 <Cale> I've never been a graduate student, but dons was my graduate student in the sense that (knowingly or not), he researched exactly what I wanted him to.
20:25:08 <lispy> Cale: hs-plugins is what you wanted him to research?
20:25:13 <Cale> lispy: yep
20:25:15 <djahandarie> Man I want to double major in math so badly
20:25:21 <ksf> Cale, you were a language shootout admin?
20:25:23 <chrisdone> Cale: http://knowyourmeme.com/i/000/060/978/original/JUST_AS_PLANNED_by_Kiriska.jpg?1279837619
20:25:26 <ddarius> djahandarie: Then do it.
20:25:29 <lispy> djahandarie: that's what I did.  Didn't hurt me none.
20:25:54 <djahandarie> I'm not good at "school" in general though
20:26:00 <Cale> lispy: One of the first things I asked about in this channel was how we'd do a plugin infrastructure for an editor extensible in Haskell.
20:26:02 <ddarius> Just look at him now, a successful lurker on IRC.
20:26:12 <djahandarie> Haha
20:26:27 <mm_freak_> > foldM (\x y -> []) undefined [0..]
20:26:28 <lambdabot>   []
20:26:50 <lispy> Cale: heh, one of my first questions was answered by dons.  I asked how to write hello world
20:26:57 <lispy> His answer was:
20:27:00 <lispy> > "Hello, World!
20:27:01 <lambdabot>   <no location info>:
20:27:02 <lambdabot>      lexical error in string/character literal at end o...
20:27:02 <lispy> > "Hello, World!"
20:27:03 <lambdabot>   "Hello, World!"
20:27:04 <ddarius> dons wasn't here when I joined.
20:27:08 <lispy> followed by, "Next!
20:27:11 <ddarius> Nor lambdabot for that matter.
20:27:42 <lispy> ddarius: what about shapr?
20:27:58 <ddarius> lispy: Shae started (the second birth) of the channel.
20:28:07 <ddarius> -> )
20:28:36 <djahandarie> What network was this channel on before freenode?
20:29:13 <chrisdone> irc.mycoolhaskellserver.co.uk
20:29:15 <ddarius> When I joined the channel averaged about 30 people.
20:29:47 <djahandarie> A haskell irc server? That would be neat
20:30:00 <chrisdone> already been done loads of times
20:30:11 <djahandarie> Unsuccessfully?
20:30:21 <chrisdone> depends what you define as 'success'
20:30:38 <ddarius> djahandarie: Do you know what geordi is, by the way?
20:30:48 <interferon> i want to display syntax-highlighted haskell code on my blog.  gist works great, but the code doesn't show up in feeds.  any suggestions?
20:30:57 <djahandarie> ddarius, the C++ eval bot written in Haskell right?
20:31:01 <ddarius> djahandarie: Yep.
20:32:00 <lispy> djahandarie: it takes a lot more than just free time and a good irc server to run a successful network like freenode
20:32:03 <mm_freak_> can foldM in the list monad produce a nonempty result for an infinite input list?
20:32:11 <mm_freak_> i couldn't find a way to do it
20:32:28 <lispy> :t foldM
20:32:29 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:32:29 <djahandarie> I just meant an IRC server written in Haskell
20:32:34 <djahandarie> Not an IRC server for Haskell :P
20:32:59 <lispy> > foldM (\x y -> return 1) 0 [1..]
20:33:00 <lambdabot>   No instance for (GHC.Show.Show (m a))
20:33:00 <lambdabot>    arising from a use of `M2201331953...
20:33:07 <lispy> > foldM (\x y -> return 1) 0 [1..] :: [Int]
20:33:10 <ksf> yet another ircd?
20:33:10 <lambdabot>   *Exception: stack overflow
20:33:17 <chrisdone> an ircd was one of my first haskell projects
20:33:23 <chrisdone> strange, I thought there'd be a few on hackage
20:33:27 <ksf> I'm pondering about a steam for FLOSS games
20:33:31 <chrisdone> there are about 450 httpds
20:33:36 <Veinor> interferon: wordpress?
20:33:37 <mm_freak_> lispy: i've tried that one, including conditionally giving []
20:33:38 <ksf> (and possibly sufficiently non-drm indy ones)
20:33:39 <djahandarie> ksf, no, not yaircd
20:33:40 <djahandarie> @freename
20:33:40 <lambdabot> Hadp
20:33:43 <djahandarie> hadp!
20:33:50 <ksf> current working title: vapour.
20:33:54 <mm_freak_> it gives [] or bottom
20:34:00 <lispy> mm_freak_: Is it foldl or foldr?
20:34:03 <lispy> :t foldr
20:34:04 <mm_freak_> foldl
20:34:04 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:34:08 <lispy> ah
20:34:10 <FSalad_III> > foldM (\x _ -> [x]) [1,2,3] undefined
20:34:11 <lambdabot>   *Exception: Prelude.undefined
20:34:18 <FSalad_III> > foldM (\x _ -> [x]) [1,2,3] []
20:34:19 <lambdabot>   [[1,2,3]]
20:34:29 <Veinor> @pl \x _ -> [x]
20:34:30 <lambdabot> const . return
20:34:38 <FSalad_III> > foldM (\x _ -> [x]) [1,2,3] (cycle "meow")
20:34:39 <mm_freak_> i'm asking because foldM appears to be quite lazy, but not to the point of supporting infinite lists
20:34:40 <lambdabot>   *Exception: stack overflow
20:34:42 <chrisdone> ksf: how about, flesh scolding evaporation stuff?
20:35:00 <ksf> plasma?
20:35:04 <chrisdone> well consider the implementation of foldM
20:35:07 <chrisdone> @src foldM
20:35:07 <lambdabot> foldM _ a []     = return a
20:35:07 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
20:35:14 <lispy> ksf: didn't lokki games leave behind a legacy for that?
20:35:26 <mm_freak_> @let perms = foldM (\x y -> zipWith (\l r -> l ++ y:r) <$> tails <*> inits $ x) []
20:35:28 <lambdabot>  Defined.
20:35:30 <mm_freak_> > perms "abc"
20:35:32 <lambdabot>   ["abc","bca","cab","bac","acb","cba"]
20:35:33 <interferon> Veinor: i'm kind of invested in blogspot
20:35:35 * FSalad_III thinks lambda+underscores is almost always more readable than clever stuff involving const...
20:35:37 <ksf> I only know their installers
20:35:49 <mm_freak_> > perms [0..100000]
20:35:50 <Veinor> oh, I dunno about blogspot then, sorry :(
20:35:53 <lambdabot>   mueval-core: Time limit exceeded
20:35:58 <Veinor> FSalad_III: I was just curious.
20:36:03 <mm_freak_> > map head . take 3 $ perms [0..100000]
20:36:06 <lambdabot>   [0,1,2]
20:36:08 <FSalad_III> :)
20:36:12 <ksf> I think their games all came with inbuilt lobbies, if they were multiplayer capable.
20:36:31 <lispy> ksf: lobbies?
20:36:37 <lispy> ksf: like a chat server?
20:36:46 <ksf> chat and open battles
20:36:53 <FSalad_III> (maybe this is because the main point of going pointless is that you don't need names, which you don't need with underscores either...)
20:37:01 <FSalad_III> (just generally commenting, Veinor)
20:37:17 <ksf> regarding battles, there's two modes: free join at any time like in deathmatches, or upfront setup like in rts
20:37:19 <chrisdone> well there's another point
20:37:21 <lispy> FSalad_III: I like const just fine, but const + (.) starts to get ugly
20:37:32 * BMeph believes that Haskell has enough of a reputation for "vapourware" as it is...
20:38:04 <lispy> BMeph: I think the current rate of bit rot is actually far worse
20:38:10 <chrisdone> const means I'm explicitly making a point of ignoring this argument, \_ -> means I'm handling the arguments manually for some reason, right now it's \_ -> although it may have or may will be something else
20:38:21 <lispy> 6mo to a year without a maintainer and your library is uninstallable
20:38:45 <chrisdone> avoid success at all costs!
20:38:47 <ksf> ...because noone writes h98
20:39:32 <ksf> regarding games itself, I think the world needs a decent mechwarrior remake.
20:39:35 <FSalad_III> BMeph: can't find which thread you are replying to...
20:39:47 <BMeph> > map head . drop 3 $ perms [0..100000]
20:39:51 <lambdabot>   mueval-core: Time limit exceeded
20:40:17 <mm_freak_> > map head . permutations $ [0..]
20:40:19 <lambdabot>   [0,1,2,1,2,0,3,2,2,3,1,1,3,0,0,3,1,1,3,0,0,3,2,2,4,3,3,3,4,2,2,2,4,1,1,1,4,...
20:40:34 <mm_freak_> permutations is much lazier than my 'perms' =/
20:40:39 <lispy> FSalad_III: the one about making a Steam clone
20:40:52 <BMeph> FSalad_III: I'm directing my comments at ksf, but you're welcome to butt in as well... ;)
20:40:56 <ManateeLazyCat> Why i got http://paste2.org/get/963234 "ghc: panic!" error when i do "ghc --make" ?
20:40:56 <ManateeLazyCat>  
20:41:05 <chrisf> > (3:39:08 PM) ksf: regarding games itself, I think the world needs a decent mechwarrior remake. AGREED.
20:41:06 <mm_freak_> i understand that it starts permuting at the beginning of the list and i'm trying to do this with foldM
20:41:06 <lambdabot>   <no location info>: parse error on input `,'
20:41:45 <ManateeLazyCat> Got "ghc-pkg: too few bytes. Failed reading at byte position 8" when i do "ghc-pkg check".
20:41:50 <ManateeLazyCat> Looks something break ghc.
20:42:04 <FSalad_III> ( what an invitation @ 'too big to fail' jokes, regarding the hubristic/vaporware projects )
20:42:54 <ksf> anyway, my current plan is to write a proxy, then bouncer for spring, which I will then split up into client/server parts with a decent protocol, which will be able to express stuff for virtually every multiplayer game
20:43:47 <ksf> spring distributes maps and mods via an own torrent tracker, btw.
20:44:38 <djahandarie> I usually avoid generalizing things too much in order to actually get things finished
20:45:09 <ksf> the main reason to do this is to break the wall of the fossil that the current protocol is so that stuff like supporting multiple engine versions on the server and sane file distribution is easy to implement, which could help testing _very much_.
20:45:44 <ksf> currently the spring devs are labelling release candidates releases (and force upgrades for online play) because they don't get enough testers.
20:46:35 <ksf> overspecialising is worse, in this case. the current protocol already does that, and you end up with nearly 200 different commands.
20:46:45 * ManateeLazyCat Re-install ghc....
20:48:37 <ksf> there's also instances where peers that aren't the server want to talk to each other, which leads to even more ad-hoc protocols and ugly hacks like abusing private chat to transmit gzipped data.
20:50:36 <ksf> hmm "stew" would be a good name, too.
20:50:48 <JoeyA> Is there a function like this?  lazySequence :: [IO a] -> (IO [a] -> IO b) -> IO b
20:51:16 <JoeyA> err
20:51:26 <JoeyA> lazySequence :: [IO a] -> ([a] -> IO b) -> IO b
20:51:37 <JoeyA> @hoogle [IO a] -> ([a] -> IO b) -> IO b
20:51:37 <lambdabot> No results found
20:52:45 <JoeyA> It takes a list of actions, performs them lazily (but ensuring that the actions are done sequentially), lazily passes the list to the function which performs an action which can bear the side effects of the list of actions.
20:53:07 <JoeyA> and returns an action that holds the result of b after all actions in [IO a] have been performed.
20:54:10 <kmc> this is something you'd write with unsafeInterleaveIO?
20:54:13 <JoeyA> Hence, it isolates the unsafety of lazy IO to a designated action.
20:54:16 <JoeyA> You could, I think.
20:54:17 <kmc> ok
20:54:18 <JoeyA> I'm about to.
20:54:24 <JoeyA> I'm wondering if it's already been done.
20:54:53 <lispy> ksf: It's Haskell, so has to start with an h.  How about haze?
20:55:15 <kmc> JoeyA, not that i'm aware of
20:55:29 <ksf> not energetic enough for my taste
20:55:40 <ksf> but, yes.
20:58:04 <JoeyA> For context, I'm writing a function called getFilesRecursively :: Maybe FileId -> IO [File]
20:58:43 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10104 ?
20:58:47 <JoeyA> I think playing the hGetContents game of returning a lazy list would be a really bad idea, since getFilesRecursively changes directories as it works.
20:59:04 <JoeyA> hGetContents operates on a relatively isolated piece of state, so it's not too bad.
20:59:28 <JoeyA> The current directory, however, is pretty significant, especially in a program that deals with files extensively.
20:59:48 <ksf> you can add a continuation parameter there and make find an enumerator.
21:00:46 <ksf> ...that code is almost as fast as unix find, btw.
21:00:56 <JoeyA> I believe it.
21:00:58 <ksf> according to the manpage, find gets faster by not doing as many stats.
21:01:40 <JoeyA> getFilesRecursively :: Maybe FileId -> ([File] -> IO a) -> IO a -- is this what you mean by continuation parameter?
21:02:03 <ksf> yes
21:02:11 <ksf> do yourself a favour and use iteratees, though.
21:02:19 <JoeyA> What are those?
21:02:36 <ksf> http://okmij.org/ftp/Streams.html
21:02:42 <lispy> an answer to lazy io
21:03:05 <lispy> JoeyA: it's a programming style built on top of left-folds
21:03:22 <ksf> and oh, I mean FileId -> (File -> IO a) -> IO a
21:03:28 <lispy> Takusen uses them, snap uses them, other things too i'm sure
21:03:34 <ksf> ...the continuation is called multiple times.
21:03:49 <ksf> and dosn't return IO a, but IO (Either gimmemore value)
21:04:57 <Axman6> if you have a binary tree, which you have then balanced so that you minimise the maximum depth, is there some relationship which should be true aboth the max depth compared to the number of elements in it?
21:05:48 <kmc> Axman6, every path to a leaf is at least one step shorter than the longest path to a leaf?
21:05:49 <JoeyA> Axman6: Short answer: O(log n)
21:05:59 <kmc> err, at least as long as (the longest path - 1)
21:06:31 <kmc> max depth is ceil(log_2(n))
21:06:43 <Axman6> JoeyA: well yes, but i'm wondering if it's ceiling(log n) + 1 if its always balanced, of if its not possible to achieve that
21:07:27 <kmc> you can always balance to that
21:07:36 <kmc> sort your elements, pick the middle for the root, recurse
21:08:07 <Axman6> well, i already have the tree
21:08:25 <Axman6> anyway, the code i'm using is pretty disgusting, i think it would have some horrible time complexity
21:08:30 <kmc> (i assume by "binary tree" you mean a binary search tree.  if you have a different constraint on node relationships there might be a problem)
21:08:31 <Axman6> but seems to do the job
21:12:59 <dons> Cale: you're controlling my mind!? :P
21:15:33 <lispy> dons: Cale uses Jedi mind tricks
21:15:45 <Gracenotes> ManateeLazyCat: oh, you around?
21:16:01 <lispy> dons: but at least he's not a cylon
21:16:32 <monochrom> "you are always on my mind"
21:21:38 <ManateeLazyCat> Gracenotes: Yes.
21:21:50 <ManateeLazyCat> Gracenotes: Sorry, ghc break, i'm reinstalling it.
21:21:58 <ManateeLazyCat> Gracenotes: Haven't notice you message.
21:22:08 <ManateeLazyCat> Gracenotes: What can i do ?
21:22:20 <lispy> ghc broke?
21:22:28 <lispy> or you took a break from ghc?
21:22:29 <ManateeLazyCat> lispy: http://paste2.org/get/963234
21:22:55 <lispy> ManateeLazyCat: do you know what it was reading?  The pkg db or a .hi file?
21:22:56 <ManateeLazyCat> lispy: I got above error when i do any ghc command.
21:23:03 <lispy> I see
21:23:16 <lispy> Probably your pkg db, does ghc-pkg have a repair command?
21:23:20 <ManateeLazyCat> lispy: I think not that problem, but i don't know why ghc can't work suddenly.
21:23:23 <Gracenotes> ManateeLazyCat: so this was my basic IRC parser - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29433#a29433
21:23:39 <ManateeLazyCat> lispy: Even ghc-pkg will got same error.
21:24:03 <Gracenotes> based on a combination of how servers do things and the RFC. sending *out* messages nowhere near as organized.
21:24:16 <ManateeLazyCat> Gracenotes: Cool, i will use your code build my irc client. it's GPL?
21:24:30 <lispy> Gracenotes: which parser?
21:24:41 <lispy> ManateeLazyCat: have you seen helios?
21:24:44 <Gracenotes> a parser that I wrote one time
21:25:06 <Gracenotes> my haskell stuff tends to be BSD3
21:25:12 <lispy> ManateeLazyCat: oh, sorry, http://www.haskell.org/hircules/  I had the wrong name
21:25:21 <lispy> Gracenotes: ah.  Okay.
21:25:41 <Gracenotes> I also made a monad transformer stack for it...
21:25:42 <ManateeLazyCat> lispy: Yes, i know, now have hircules, fastirc, irc, SimpleIRC and Gracenotes' parser.
21:25:53 <lispy> Gracenotes: you could use attoparsec and probably even remove some trys.
21:25:58 <ManateeLazyCat> lispy: I need integrate irc client with my project (http://www.flickr.com/photos/48809572@N02/)
21:26:19 <ManateeLazyCat> lispy: I have finish backend, now writing irc parser.
21:26:35 <lispy> ManateeLazyCat: what is your project?  Just a collection of random haskell programs?
21:26:47 <Gracenotes> lispy: probably; IRC protocol is pretty regular, and parsec's amenities might be a bit much. still better than using regex syntax.
21:27:05 <ManateeLazyCat> lispy: https://patch-tag.com/r/AndyStewart beginning with manatee-*
21:27:10 <Gracenotes> but yeah, I've written a few IRC bots, a few IRC bot frameworks, and one GUI client (Java). so I'm a bit tired of it really.
21:27:40 <lispy> ManateeLazyCat: I see you have lots of screen shots and repositories, but what is the connection?
21:27:45 <Gracenotes> actually two GUI clients, but the first one was just a hack so I could get on IRC in high school
21:28:01 <ManateeLazyCat> lispy: I looks replace those everyday.... :)
21:28:12 <lispy> I keep meaning to write a megahal bot in Haskell (someone already did it, but I want to do it too :)
21:28:21 <ManateeLazyCat> lispy: Do you know Google Chrome?
21:28:23 <lispy> ManateeLazyCat: sorry?
21:28:29 <lispy> I use chrome yes
21:28:36 <ManateeLazyCat> lispy: Similar framework, but more generic.
21:28:50 <ManateeLazyCat> lispy: Multiple-Process framework and connect by DBus.
21:28:52 <lispy> ManateeLazyCat: "I looks replace those everyday...."  <-- I'm sorry, I can't parse that
21:29:15 <ManateeLazyCat> lispy: I explain my project last night.... :)
21:29:27 <lispy> ManateeLazyCat: ah, I guess I missed it :)
21:29:47 <ManateeLazyCat> lispy: You can consider it's Emacs style of Gnome.
21:29:51 <ManateeLazyCat> lispy: Do everything....
21:30:16 <lispy> ManateeLazyCat: so you're making a Haskell based desktop, or is this one monolithic application that does each of these things?
21:30:18 <ManateeLazyCat> lispy: But have advanced framework keep sub-module running independent.
21:30:37 <ManateeLazyCat> lispy: Both
21:30:57 <ManateeLazyCat> lispy: It's "Integrated Live Environment".
21:31:07 <lispy> ManateeLazyCat: what is your separation model like?  You use separate processes for each part of the functionality, or one big address space for everything?
21:31:35 <ManateeLazyCat> lispy: No, Core and sub-module running in separate processes.
21:31:42 <ManateeLazyCat> lispy: Communication by DBus.
21:32:04 <lispy> Ah!  Okay.  Now I see why you mentioned DBus.  Well, that's cool.
21:32:07 <ManateeLazyCat> lispy: And manatee-core use XEmbedded protocol redirect graphic of sub-process. 
21:32:30 <lispy> ManateeLazyCat: do you do any assurance on the communication protocol they use?  Formal methods?  Isabelle?  Model checking?
21:32:52 <ManateeLazyCat> lispy: If any sub-module (such as editor or browser) got unexpected exception just close/reload tab will fix that module, and won't crash core or other modules.
21:33:17 <lispy> ManateeLazyCat: yes, but can a malicious person insert new "modules" that exploit the others?
21:33:28 <ManateeLazyCat> lispy: I juse use DBus Signal, and design framework carefully, make all functions cross-process asynchronous completely. 
21:34:00 <lispy> ManateeLazyCat: are you writing a paper or anything about your approach?
21:34:30 <ManateeLazyCat> lispy: I will add some permission manager in core, all system resource must dispatch by core, if malicious program try to attack it, core will block it.
21:34:34 <lispy> ManateeLazyCat: is it linux only or any gtk platform like windows?
21:34:38 <ManateeLazyCat> lispy: Not yet.
21:35:02 <ManateeLazyCat> lispy: Now, just for linux,  I think it's easy to port since it's base on Haskell/GTK+
21:35:10 * BMeph didn't think that was a "not yet"-type of question...
21:35:32 <lispy> BMeph: not yet -> re: paper
21:35:51 <ManateeLazyCat> lispy: Infact, all file open manage by core, example, editor want open some file, it's need send DBus request to core, then core decide whether open that file.
21:35:56 <lispy> BMeph: asynchronous protocol of chat :)
21:36:09 <BMeph> lispy: Yeah, I got that, about fifteen seconds after I finished the last remark. It's still funny... ;)
21:36:12 <ManateeLazyCat> lispy: About paper, i have't time do that.
21:36:28 <lispy> ManateeLazyCat: Okay.  so you have a message passing kernel (like mach) on top of DBus?
21:36:32 <ManateeLazyCat> lispy: Too many work need to do, irc-client, mail-client, image-viewer, process-manager.
21:37:25 <lispy> ManateeLazyCat: Will your kernel become the bottle neck?  Should you plan to have redundant kernels so that if 1 goes down the others can keep running, and also for load balancing?
21:37:52 <ManateeLazyCat> lispy: Well, most DBus situation is need some interactive action with user, then i need send DBus to other processes. And each sub-module is independent, and core don't care how sub-module execute.
21:38:45 <ManateeLazyCat> lispy: Well, it's not bottle neck? Core just like do some manage work.....
21:38:55 <chrisf> Axman6: a perfectly balanced binary tree has max depth lg N, for an obvious reason.
21:39:08 <JoeyA> In this seqList function, why doesn't it ever seq the first item?  http://hackage.haskell.org/packages/archive/MissingH/1.1.0.3/doc/html/src/Data-List-Utils.html#seqList
21:39:10 <chrisf> argh, this client fails. 
21:39:23 <chrisf> ignore me, i'm an hour behind or something.
21:39:28 <Axman6> s'all good
21:39:28 <ManateeLazyCat> lispy: Now i have some gtk2hs patches need push, after that, maybe i can relase first review version.
21:39:35 <ManateeLazyCat> lispy: Then you will know how it to work.
21:39:41 <lispy> ManateeLazyCat: cheers
21:40:00 <ManateeLazyCat> lispy: But source code has open at https://patch-tag.com/r/AndyStewart
21:40:00 <Axman6> guess my balancing algorithm isn't optimal then. some cases won't balance better than log n + 2
21:40:12 <Axman6> which is probably good enough for what i'm doing anyway
21:40:16 <chrisf> well, that's still pretty good, or not, depending on how big N is.
21:40:44 <chrisf> it's a tradeoff, as always.
21:40:48 <Axman6> yeah
21:41:02 <chrisf> how much work are you willing to do balancing vs how much benefit do you get.
21:41:20 <ManateeLazyCat> lispy: If you use gtk2hs darcs version and gio-branch (https://patch-tag.com/r/AndyStewart/gio-branch/home), then you can compile manatee.
21:41:45 <Axman6> i want the balancing to be fairly fast, at the cost of not guaranteeing optimal balancing
21:42:00 <chrisf> Axman6: this is a fairly well-understood area btw ;)
21:42:07 <Axman6> i know
21:42:18 * ManateeLazyCat Ghc works now, maybe i install some package break ghc's database, i dunno
21:42:19 <Axman6> but i'm trying to figure this stuff out for my self
21:42:39 <Axman6> this is how i'm doing it, if you're interested: http://codepad.org/RLh0Qe2G
21:43:25 <Axman6> conc is a 'smart' constructor, which just summs the sizes of the two sub trees
21:44:21 <ManateeLazyCat> lispy: In the future, i perhaps will change core make it integrate pdynload to hot-swapping gtk2hs code.
21:44:26 <ManateeLazyCat> @hackage pdyanload
21:44:26 <lambdabot> http://hackage.haskell.org/package/pdyanload
21:46:52 <Axman6> chrisf: any opinions on my code?
21:47:12 <Axman6> i've yet to get anyone at all to take a look at it for me :(
21:51:36 <JoeyA> What's the difference (if any) between seq x (return y) and return (seq x y) in terms of evaluation order? (where return is for IO)
21:52:52 <ksf> in the former case x gets forced when return gets forced, in the latter case when y gets forced.
21:53:12 <ksf> so, the answer is: depends on the monad.
21:53:37 <ksf> return should be lazy even in IO, though.
21:53:52 <ksf> (which has a strict bind)
21:56:10 <Cale> Axman6: If you're worried about performance, a small thing you can do is to replace those guards with  case compare n m of LT -> .. ; GT -> .. ; EQ -> .. (which in general may do the comparison in one step rather than doing two comparisons)
22:00:01 <Axman6> Cale: yeah, i originally did that, can't remember why i changed it
22:01:55 <Axman6> hmm, i've written quite a bit of code for this. i wonder if anyone would be interested in using it
22:03:05 <Heffalump> ksf: if return were strict, there'd be no difference between those
22:04:07 <Axman6> Cale: would you say the code is easy to understand?
22:07:17 <Axman6> i think i need a better way for testing for equality of values only than l == r = toList l == toList r
22:08:43 <ShinyDarkness> Hello.
22:08:49 <Axman6> 'lo
22:09:33 <ShinyDarkness> Are there any IDEs for Haskell in OS X?
22:09:48 <Axman6> not in OS X, but there is leksah, which works on OS X
22:09:52 <Axman6> @where leksah
22:09:52 <lambdabot> http://www.leksah.org/
22:09:56 <ShinyDarkness> Awesome. Thanks.
22:10:02 <Axman6> though most people don
22:10:13 <Axman6> don't use IDE's with haskell, they're not really needed
22:10:30 <lispy> leksah really freaked me out when I tried it
22:10:38 <lispy> I started doing all sorts of network traffic.
22:10:46 <lispy> and spawned a server for some reason
22:10:58 <ShinyDarkness> Well, I could compile everything using the command line, but I am too lazy.
22:11:08 <lispy> The leksah devs assure me that it _wasn't_ uploading details about my code, but hey I can't tell that as a user
22:11:42 <lispy> most stuff I work on is open source, but what if some of it was company IP and I was responsible for leaking it?  I'd feel stupid.
22:11:53 <blackh> Leksah downloads information about hackage packages.
22:13:14 <lispy> That seems silly too considering the packages I can actually use are already installed.
22:13:24 <lispy> Just use my local package db.
22:13:25 <Cale> ShinyDarkness: It's mostly either  ghc --make foo  or  cabal build  (from the package directory if it's a cabal project)
22:13:39 <blackh> lispy: It's preloaded for speed of access, I think
22:14:19 <ManateeLazyCat> lispy: You know my mail?
22:14:57 <lispy> ManateeLazyCat: I could find it from haskell-cafe.  I know the pseudonym you use
22:15:25 <ShinyDarkness> What would be the command line code to list all haskell source files in a given folder, and use them as parameters to call the compiler?
22:15:27 <ManateeLazyCat> lispy: Ok, if you use manatee, please let me know if have any problem.
22:15:37 <ManateeLazyCat> lispy: BTW, it's not pseudonym name.
22:15:51 * ManateeLazyCat Need coding now...
22:16:37 <lispy> ManateeLazyCat: ah
22:16:56 <blackh> lispy: (remembering more...) The downloaded files contain the haddock docs, which are not in the .hi files you already have.
22:17:11 <lispy> ShinyDarkness: Well, you can use find to list them all.  find . -name "*hs"
22:17:22 <ManateeLazyCat> lispy: Infact, it's my English name, i use it always, i don't think true name must be the name in your ID-card.
22:17:38 <lispy> ShinyDarkness: that will find any file ending with hs in the name, so all lhs and hs files will match.  Possibly non-haskell things, but that's the risk you take.
22:17:57 <lispy> ManateeLazyCat: okay.  I didn't mean to imply anything by calling it a pseudonym.
22:17:59 <ShinyDarkness> Thanks, Cale, lispy!
22:18:37 <ManateeLazyCat> Gracenotes: Thanks for share your code.
22:18:39 <ddarius> lispy: From now on you can use the term "alias" to avoid any future incidents.
22:18:41 <ManateeLazyCat> Bye all! :)
22:20:05 <lispy> ddarius: nome de plum
22:20:55 <ddarius> Nome de plume is the same as pseudonym.
22:21:06 <lispy> nah, one is french
22:21:27 <lispy> and the other is australian
22:21:43 <ManateeLazyCat> greensnark: BTw, i have look your irc code, isChannel is not right. should be : "isChannelName str = str =~ ("^[$#+!].[^ ,\x07]+$" :: ByteString)" 
22:22:08 <ddarius> RegEx: What the internet is built on.
22:22:53 <ManateeLazyCat> Gracenotes: A channel name are strings (beginning with a '&', '#', '+' or '!'
22:22:53 <ManateeLazyCat> character) of length up to fifty (50) characters.  Apart from the
22:22:54 <ManateeLazyCat> requirement that the first character is either '&', '#', '+' or '!',
22:22:54 <ManateeLazyCat> the only restriction on a channel name is that it SHALL NOT contain
22:22:56 <ManateeLazyCat> any spaces (' '), a control G (^G or ASCII 7), a comma (',').  
22:23:41 <Gracenotes> ManateeLazyCat: we're receiving the name from an irc server, not constructing one of our own
22:23:56 <ManateeLazyCat> Gracenotes: So we need use "^[$#+!]." match first character, then use "[^ ,\x07]+$" match rest name.
22:24:22 <Gracenotes> so better to be liberal in what the client accepts
22:24:32 <ManateeLazyCat> Gracenotes: So you code is for irc server?
22:24:50 <Gracenotes> it's for a client parsing server code
22:25:03 <Gracenotes> lines from an ircd
22:25:31 <ManateeLazyCat> Gracenotes: But you don't check channel name before you send to server?
22:25:54 <ManateeLazyCat> Gracenotes: Like "#haske,ll" is invalid name.
22:26:08 <ManateeLazyCat> Gracenotes: And "control G" and space.
22:26:55 <Gracenotes> I didn't write much systematic sending code. it might check for that.
22:27:36 <Gracenotes> personally I wouldn't worry about ctrl+g that much, perhaps it's just to not inconvenient people using terminals
22:28:00 <Gracenotes> if you're writing an IRC client, the most important thing is that it works with servers, not that it implements the RFC
22:28:09 <Gracenotes> imho
22:29:11 <ManateeLazyCat> Gracenotes: Okay, i just think it's should send valid name to avoid receive error from server.
22:30:48 <Gracenotes> the server might send an error even if the RFC says it's okay. but, there are places where checking is more appropriate. for an IRC client, you wouldn't want much checking, because it's quite okay to display errors from the server. bots, on the other hand, can't understand errors, and can't guess as well which errors came from which commands
22:34:20 * ManateeLazyCat Looks SimpleIRC code can't work.....
22:34:50 <ManateeLazyCat> Gracenotes: Ok, thanks for explain! :)
22:35:28 <Gracenotes> also, my querying functions are begging for syb or something
22:37:10 <copumpkin> koninkje_away: <3, can't wait to see your generalized HMM stuff :P
22:40:27 <augur> copumpkin: HMMs grr :|
22:47:07 <mtnviewmark> Woot: I just closed Haddock ticket #108: Output semantically correct HTML
22:47:17 <copumpkin> awesome
22:48:06 <mtnviewmark> you can get a preview here: http://www.ozonehouse.com/mark/snap-xhtml/containers/Data-Map.html
22:48:14 <rabidsnail> Are there any asynchronous network server libraries for haskell (like twisted or node.js)?
22:48:54 <kmc> rabidsnail, it's typical to use threads and blocking IO and let GHC's IO manager do the rest
22:49:06 <copumpkin> rabidsnail: asynchronous?
22:49:07 <lispy> rabidsnail: someone was just talking about using DBus for that
22:49:19 <copumpkin> rabidsnail: seems like a workaround to me :P
22:49:32 <copumpkin> mtnviewmark: <3 <3
22:49:41 <kmc> to the extent that async IO is a workaround to avoid threads, it's unnecessary in GHC Haskell, where threads are easy and cheap
22:49:41 <mtnviewmark> thanks!
22:49:55 <kmc> but perhaps there are other advantages to async IO that we're not taking advantage of
22:49:57 <rabidsnail> copumkin: a workaround, maybe, but one with really nice kernel support
22:50:01 <mtnviewmark> did you notice the little "Frames" button in the upper right?
22:50:02 <copumpkin> mtnviewmark: that's pretty bonerific :P
22:50:03 <mtnviewmark> :-)
22:50:12 <kmc> what's the kernel support?
22:50:17 <copumpkin> you mean select?
22:50:20 <kmc> GHC already uses select() / epoll() in the scheduler
22:50:21 <rabidsnail> kqueue
22:50:26 <mtnviewmark> pleased to please you, er, I think!
22:50:33 <kmc> ah i think it can use kqueue on bsd, don't recall
22:50:40 <copumpkin> rabidsnail: it's really not necessary with GHC
22:51:14 <rabidsnail> Is there an open source network server type program that I can read?
22:51:21 <copumpkin> rabidsnail: green threads cost nothing to launch, and the runtime takes care of doing epoll/select (and maybe kqueue) for you, giving you the impression of having a real thread to yourself
22:51:23 <kmc> http://www.serpentine.com/bos/files/ghc-event-manager.pdf  -- rabidsnail the paper on the new IO manager
22:51:30 <lispy> mtnviewmark: I hate to say it, but I kind of like the frame view.
22:51:42 <nlogax> snap performs way better than node, on my machine at least
22:51:42 <kmc> there are examples in RWH of doing concurrent network IO by threads
22:51:45 <lispy> mtnviewmark: But, why is the synopsis tab gone in frame view?
22:51:49 <mtnviewmark> rabidsnail: I believe that with the new IO manager (just went into GHC trunk, yes?) bos and tibbe have benchmarked servicing 10s of thousands of HTTP requests
22:52:02 <nlogax> plus, who wants to write code like this? http://stackoverflow.com/questions/3538156/file-i-o-in-every-programming-language/3538377#3538377
22:52:02 <copumpkin> I'm not a fan of the frame view
22:52:12 <mtnviewmark> llspy - because the synopsis is essentially in the lower left pane
22:52:30 <mtnviewmark> there was a big split in the survey over the two different forms of the synopsis (w/ and w/o type signatures)
22:52:37 <mtnviewmark> so - we have it both ways
22:53:16 <mtnviewmark> but divided between frames and non/frames
22:53:21 <mtnviewmark> no idea if that will all stick - 
22:53:42 <mtnviewmark> we need to get some more people using it, not just looking at a page, to really know 
22:53:59 <kmc> rabidsnail, of course if you prefer to process a stream of events, you can make each connection's thread simply push an event onto some Chan
22:54:03 <mtnviewmark> I believe there will be a new haddock release vey soon with this stuff in it
22:54:28 <copumpkin> mtnviewmark: man, I can't wait until all docs look like that
22:54:49 <mtnviewmark> and - heh - if you really miss the old view (some people did), check out the "style" pull down in the upper right
22:55:09 <lispy> mtnviewmark: ah, well I look at haddocks for two things usually: 1) I want to quickly get the type signature.  If that doesn't satisfy my curiosity then, 2) I want to read the source.  Often the haddock strings themselves are the last thing I look at.  So I would like it to optimize for displaying the types and the source of the implementation.
22:55:20 <mtnviewmark> copumpkin: I'm trying to write a script that will let you re-run all your docs for all your installed packages with a new haddock - but it isn't trivial
22:55:29 <fengshaun> are there any recommended free ebooks to learn haskell?
22:55:45 <lispy> fengshaun: real-world haskell and learn you a haskell
22:55:52 <fengshaun> also, how's the library support for haskell?  small, large, or huge?
22:55:58 <mtnviewmark> llspy- perhaps you'd prefer a more colorized/styled form of the source then
22:56:07 <fengshaun> lispy: thanks
22:56:07 <kmc> fengshaun, RWH and LYAH are both recommended
22:56:07 <copumpkin> fengshaun: there are lots but they aren't always good, and there are some holes
22:56:09 <kmc> @where LYAH
22:56:09 <lambdabot> http://www.learnyouahaskell.com/
22:56:10 <kmc> @where RWH
22:56:10 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:56:14 <kmc> fengshaun, see library list at http://hackage.haskell.org/packages/archive/pkg-list.html
22:56:19 <kmc> not all of these are usable but a good fraction are
22:56:27 <mtnviewmark> and, really, one of the goals of restying haddock was to give incentive for people to write more/better in-line doc
22:56:33 <copumpkin> mtnviewmark: is hscolour a subproject? it'd be nice to have cross-referenced source
22:56:50 <fengshaun> copumpkin, kmc: thanks a lot, extremely helpful!
22:57:02 <mtnviewmark> hscolour is a totally separate project
22:57:07 <copumpkin> ah okay :(
22:57:08 <lispy> fengshaun: libraries are great.  You'll want to get to know cabal and hackage.
22:57:24 <kmc> fengshaun, RWH also explains how to write your own bindings to C libs, if the need should arise
22:57:25 <fengshaun> lispy: I'll look into that
22:57:31 <kmc> what we don't have is a nice way to bind Java or .NET libraries
22:57:34 <mtnviewmark> haddock just has the ability to generate links into it --- though it does induce a dependency between these two projects :-(
22:57:39 <fengshaun> kmc: woww, cool!
22:57:48 <lispy> fengshaun: cabal is the tool we use for builds and dependency resolution.  hackage is the public collection of source trees that have a .cabal file.
22:57:53 <copumpkin> mtnviewmark: and <_< what about >_> showing qualified names in docs? :P
22:58:46 <lispy> mtnviewmark: getting access to the source is my highest priority though.  If I have to 'cabal unpack foo' just to read the source, I gufaw and complain.
22:58:57 <lispy> mtnviewmark: colorizing is just icing on top
22:58:59 <mtnviewmark> You mean when we show a type signature, if a symbol is in a different module, qualifying it?
22:59:07 <lispy> oh, that would be sweet
22:59:36 <mtnviewmark> hmmm... would, of course, kind of make the signatures VERY verbose
22:59:59 <mtnviewmark> and which packages would one assume were imported non-qualified? Just Prelude?
23:00:28 <mtnviewmark> some packages are written on the assumption of non-qualified import of a set of modules - others are expecting qualified.... 
23:00:32 <kmc> fengshaun, you're just starting out learning?
23:00:42 <lispy> mtnviewmark: I would definitely say that the frame view is not nearly as useful (for me) as it would be if signatures were listed in it (and it seems like mostly there is space for them)
23:00:44 <fengshaun> kmc: yes
23:01:11 <lispy> mtnviewmark: I hope I'm not overloading you with my opinions :)
23:01:16 <fengshaun> kmc: getting tired of the "same old, same old" languages like C++, Perl, Python, etc.  They are all the same.
23:01:26 <kmc> agreed fengshaun
23:01:27 <fengshaun> looking for some programming "thrill"
23:01:32 <kmc> you've come to the right place
23:01:37 <fengshaun> :)
23:01:37 <kmc> welcome to Haskell, and welcome to #haskell
23:01:50 <mtnviewmark> llspy - as I said, there was quite a community split on the issue of including signatures or no
23:01:52 <fengshaun> thanks
23:02:09 <lispy> mtnviewmark: I guess we need two types of frames then :)
23:02:26 <mtnviewmark> that all said - in non-frame view - the whole layout is done with CSS - you can, if you wish, easily write a CSS theme that puts the synopsis anywhere you like!
23:02:36 <lispy> mtnviewmark: where is this being discussed.   I haven't seen anything in the usual place (haskell-cafe)
23:02:59 <mtnviewmark> actually- it is in frame too - only that lower left "synopsis only" frame is really a different haddock produced output
23:03:14 <mtnviewmark> llspy - there is an active haddock mailing list
23:03:18 <mtnviewmark> and a trac
23:03:29 <mtnviewmark> and (gasp) a freenode channel
23:03:52 <lispy> ah.  I haven't thought to join all the mailing lists for haskell projects :)
23:04:07 <lispy> I guess I could add the mailman list on c.h.o to rss and join everything
23:04:15 <lispy> Seems kind of extreme though...
23:04:52 <copumpkin> mtnviewmark: wow, it's spitting out very dense html :) doesn't look like the html package's output though... you guys have your own generator?
23:04:56 <copumpkin> or is it BLAZE?
23:05:15 <dibblego> does this function exist in a library? http://paste.pocoo.org/show/254190/
23:05:18 <mtnviewmark> copumpkin: it is the bog-standard Xhtml package
23:05:24 <copumpkin> mtnviewmark: oh, interesting
23:05:29 <mtnviewmark> there is a "non-pretty" output mode - 
23:05:40 <mtnviewmark> which is what you want in general
23:05:46 <copumpkin> dibblego: seems like it should, but I don't thinkso
23:05:59 <dibblego> copumpkin, the usual story, cheers
23:06:19 <mtnviewmark> since everything haddock uses has to be part of the GHC "boot" packages, we are somewhat restricted in what we can code to
23:06:37 <copumpkin> dibblego: I'd suppose a proposal to add it to the directory package though
23:06:46 <copumpkin> mtnviewmark: ah, I see
23:06:53 <dibblego> copumpkin, yeah I might do it -- I use it very often
23:08:08 <mtnviewmark> dibblego - I wonder how well that plays with threads... do threads have their own current dir?
23:08:29 <dibblego> mtnviewmark, I'd imagine so, but does that change anything?
23:08:49 <copumpkin> if there was a single current dir for the whole app it would
23:08:57 <copumpkin> I've never actually had to find out though
23:09:10 <dibblego> I use that function most in scripting
23:10:02 <mtnviewmark> no, just wondering - in most commercial SW I've written I end up never using/trusting the current dir
23:10:26 <mtnviewmark> since often libraries are poorly behaved and change it, or fail to return it under some condition or other
23:10:36 <dibblego> yeah I agree
23:23:58 <lispy> mtnviewmark: I'm 99% sure that haskell threads share the cwd
23:27:19 <lispy> my last name and my irc handle are already taken on twitter.
23:27:29 <lispy> That means I can't get a twitter account, right?
23:29:10 <koala_man> you can always change your name
23:31:04 <lispy> koala_man: haha
23:31:49 <lispy> vim question:  How do I get vim to ':syntax on' by default whenever I open a .hs, .lhs, or .hsc file?
23:32:01 <shachaf> lispy: Why not do it for all files?
23:32:29 <mee> :h au
23:32:48 <lispy> I found this document:  http://vimdoc.sourceforge.net/htmldoc/syntax.html  but it only seems to say how to do it for the current session
23:32:52 <lispy> I want to make it persist
23:33:08 <mauke> echo 'syntax enable' >> ~/.vimrc
23:33:12 <shachaf> (And, yes, it would probably be: "autocmd BufNewFile,BufRead *.hs syntax enable" or something like that.)
23:34:01 <lispy> mauke: cool, that seems to have worked
23:34:06 <lispy> I should try it on a .hsc file
23:34:09 * mee senses his cassandra complex grow
23:35:01 <shachaf> mee: In what sense?
23:35:13 <lispy> hm...I think it's pciking the wrong type of highlighting for hsc files
23:36:06 <mee> shachaf: just joking, but I was alluding to my ':h au' going unheeded :)
23:36:46 <lispy> mee: oh was that in reference to me?  I didn't even realize you were talking to me
23:36:53 <shachaf> mee: I acknowledged it, I thought, in my "And, yes" line.
23:36:58 * lispy has no idea what it means
23:37:07 <shachaf> lispy: It means :help autocmd. :-)
23:37:08 <mee> sorry, I probably could have, you know, used sentences.
23:38:05 <lispy> how do you tell vim that .hsc files are equivalent to .hs files in terms of coloring?
23:38:13 <lispy> The vimdocs are greek to me
23:38:15 <shachaf> lispy: .hsc seems to be associated with "hamster classic".
23:38:37 <shachaf> lispy: http://stackoverflow.com/questions/891805/how-do-i-set-up-different-tab-settings-for-different-languages-in-vim
23:38:45 <shachaf> (Also, #-blah would probably be better for this.)
23:39:37 <lispy> shachaf: thanks
23:50:04 <EvanCarroll> is there a prelude function like this
23:50:05 <EvanCarroll> et apply :: Num a => a -> ( b -> b ) -> b -> b; apply num f arg | num == 1 = f arg | otherwise = apply ( num - 1 ) f ( f$arg)
23:51:17 <copumpkin> nope
23:51:45 <copumpkin> > \n -> appEndo . Data.Foldable.foldMap Endo . replicate n
23:51:46 <lambdabot>   Overlapping instances for GHC.Show.Show
23:51:46 <lambdabot>                              (GHC.T...
23:51:51 <copumpkin> :t \n -> appEndo . Data.Foldable.foldMap Endo . replicate n
23:51:53 <lambdabot> forall a. Int -> (a -> a) -> a -> a
23:53:30 <EvanCarroll> copumpkin: and would that be TCO?
23:53:48 <EvanCarroll> if you did something like # apply 10 (apply 10 succ) $ 5
23:54:21 <copumpkin> > (\n -> appEndo . Data.Foldable.foldMap Endo . replicate n) 100000 succ 5
23:54:23 <lambdabot>   100005
23:54:25 <copumpkin> > (\n -> appEndo . Data.Foldable.foldMap Endo . replicate n) 100000 succ 5
23:54:26 <lambdabot>   100005
23:54:29 <copumpkin> > (\n -> appEndo . Data.Foldable.foldMap Endo . replicate n) 10000000 succ 5
23:54:31 <lambdabot>   *Exception: stack overflow
23:54:33 <copumpkin> guess not :)
23:54:40 <copumpkin> it's not so much TCO
23:55:16 <EvanCarroll> ?
23:56:59 <copumpkin> even your original version would get a stack overflow
23:57:05 <copumpkin> unless you added a strictness annotation
