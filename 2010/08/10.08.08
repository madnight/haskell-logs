00:07:27 <aavogt> Phyx-: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28711#a28711
00:10:54 <ivanm> Heffalump: have you ever considered extending rmonad to provide a restricted version of all the other similar type-classes in base (Foldable, Applicative, etc.) ?
00:11:34 <aavogt> Phyx-: so I don't think that 'getParent' offers much over 'listify'
00:11:45 <ivanm> aavogt: methinks Phyx- is asleep...
00:12:54 <aavogt> ivanm: better than talking to myself :)
00:13:02 <ivanm> heh, fair enough
00:14:00 <Heffalump> ivanm: I looked at Applicative, but it's too hard. All the utility code manipulates intermediate functions, so you end up with nasty constraints.
00:14:09 <Heffalump> I suspect Foldable would have the same problems.
00:14:12 <ivanm> *nod*
00:14:17 <Heffalump> nice solutions welcome!
00:14:19 <ivanm> heh
00:14:38 <ivanm> I was just thinking for container-classes of splitting out the fold functions into a Foldable class
00:14:53 <Heffalump> also, the constraints wouldn't be canonical, as there are multiple ways you can write the utility code
00:15:08 <ivanm> but I'd want it working on kind *
00:15:17 <ivanm> since AFAICT there's no reason Foldable requires kind * -> *
00:16:00 <ivanm> wait, I lie; the ones that also bring in Applicative like the ability to use Foldable as kind * -> *
00:16:05 <ivanm> but most don't seem to care
00:16:18 <aavogt> ivanm: so you'd have some associated type instead?
00:16:33 <ivanm> or an MPTC, yes
00:16:56 <ivanm> since until we have superclass constraints MPTC + fundep ends up being nicer for dealing with multiple classes
00:20:56 <Saizan> Foldable shouldn't have the same problem because it's all about destructing
00:22:18 <mrdk> Is there a way I can use data types in contexts like "Foo | Bar", where | is a binary or? Or should I use something else than data types?
00:23:13 <ivanm> mrdk: are you constructing a new data type?
00:23:20 <ivanm> or are you wanting to say that in a type sig?
00:23:27 <ivanm> if the latter, define a new type class
00:23:38 <ivanm> or else use a wrapper type
00:23:38 <mrdk> ivanm: I constructed a new data type
00:26:42 <mrdk> ivanm: so I would have to define each wrapper type and set values like 1,2,4,8..?
00:26:57 <ivanm> what are you actually trying to do?
00:27:18 <c_wraith> > iterate (*2) 1
00:27:19 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
00:27:34 <mrdk> c_wraith: nice
00:27:53 <c_wraith> No, I'm not paying any attention, and through out something useless. :)
00:28:14 <c_wraith> err.  threw
00:28:20 <ivanm> heh, about to say ;-)
00:28:36 <mrdk> ivanm: basicly I just want a set of options, and I want to check if a specific or multiple options are set
00:28:55 <ivanm> ummmm.... that doesn't help much explain what you want ;-)
00:29:12 <ivanm> you want some function :: [Options] -> ... ?
00:29:21 <mrdk> ivanm: exactly
00:29:46 <ivanm> then yeah, define an Option data type
00:30:02 <ivanm> or, see how RWH does the PCRE bit
00:30:24 <ivanm> they have a newtype around Int and then define constants using that newtype
00:31:16 <jrockway> so. how evil is it to enable flexible instances, undecidable instances, overlapping instances, and type synonym instances, just so i can write "instance Show a => Whatever a where foo = WhateverString . show" and "instance Whatever String where foo = WhateverString"?
00:32:12 <ivanm> not _too_ evil AFAIK
00:32:16 <Saizan> are those the only two instances you'll ever need for Whatever?
00:32:19 <ivanm> there are various classes like that around
00:32:25 <jrockway> no, there will be others
00:32:28 <ivanm> Saizan: well, he can't have any other instances, can he ;-)
00:32:34 <jrockway> (where Show != Whatever)
00:32:34 <ivanm> jrockway: oh, in that case it's no good
00:32:39 <Saizan> he can, with OverlappingInstances
00:32:51 <ivanm> it'd have to be in the same module, wouldn't it?
00:32:55 <Saizan> no
00:32:59 <ivanm> oh
00:33:10 <jrockway> the class is restricted to one module
00:33:19 <ivanm> well, you can't then use something like "instance Num a => WHatever a", because I've tried :(
00:33:40 <Saizan> you can add instance Whatever Foo and use it
00:33:49 <jrockway> yeah, that's all i'm planning on
00:34:02 <jrockway> i have about 20 types that i need to process in some unified way
00:34:14 <jrockway> most of them do show, which is a good start, but strings and a few others are special-case
00:34:47 <dolio> ivanm: Overlapping instances choose the most specific match for the parameters of the class. Contexts make no contribution.
00:34:56 <ivanm> dolio: *nod*
00:35:06 <ivanm> jrockway: but are you wanting all Show instances to be instances of Whatever?
00:35:07 <Saizan> anyhting that uses OverlappingInstances and it's not just doing type-level programming is quite evil in my book, but YMMV
00:35:30 <jrockway> yeah
00:35:33 <dolio> If it's restricted to a single module, it's not that bad.
00:35:40 <ivanm> Saizan: even the old "let's have a specific instance for String" hack?
00:35:47 <dolio> Since overlap is kosher with closed classes.
00:35:47 <ivanm> (without using Show's trick)
00:36:01 <jrockway> that was my feeling
00:36:10 <jrockway> if it's restricted to one module, and the one module works, then the damage is limited
00:36:49 <mrdk> ivanm: maybe I should really just explain what I'm trying to do, to find the ultimate haskell-way to do it
00:36:55 <jrockway> this design is mostly due to 1) using a retarded C library for data input, and 2) having overly picky clients that each want their own very specific output format
00:36:56 <Saizan> evil that doesn't show up in the API is not really evil :)
00:37:07 <jrockway> i think if i got to be the input and the output, i would not need to be evil :)
00:37:41 <ivanm> mrdk: well, yes, that might help ;-)
00:37:47 <ivanm> Saizan: heh
00:37:56 <ivanm> Saizan: so hidden evil is all good? :p
00:38:27 <jrockway> unsafeExposeDemons
00:38:59 <dolio> So, has anyone used the UU parsers? They seem interesting, and error correction sounds cool, but I'm not sure you actually want that for, say, parsing a programming language.
00:39:20 <mrdk> ivanm: as you might guess it's xmonad related, so this might be the wrong place
00:39:54 <ivanm> *shrug* didn't expect it, and whatever
00:40:20 <Saizan> dolio: it can report multiple parsing errors at once that way
00:40:52 <dolio> Maybe you could use the corrections to suggest fixes (although I'm not sure how useful they'd be)?
00:41:04 <dolio> Yeah, there is that.
00:41:45 <Saizan> i wonder if the corrections would be accurate enough in practice to be useful suggestions
00:42:03 <mrdk> ivanm: anyway, my keys have a extra argument /named/ Host, which helps wheter to use or not use the key binding on a specific machine/host
00:42:04 <dolio> I kind of doubt it.
00:42:16 <ivanm> mrdk: k
00:42:58 <mrdk> ivanm: so I define a couple of these Host types like home, work, laptop, whetever. And when calling keys, I just filter these which I need
00:43:10 <ivanm> mrdk: OK, so you want a datatype for that
00:43:16 <ivanm> probably the easiest way
00:44:00 <mrdk> ivanm: so I have something like "data Host = Home | Work | Laptop"
00:44:14 <ivanm> yup
00:44:23 <ivanm> as for what your key bindings look like...
00:44:25 <mrdk> ivanm: but how could I use a expression like "Home [or] Laptop" in my keys?
00:44:57 <ivanm> are you trying to have this happen automatically?
00:45:14 <ivanm> what you could do is have your keybindings be in a Map Host [keybindings]
00:45:50 <ivanm> and then to construct it you could write a function that converts "[([Host], keybinding)]" into that Map
00:46:42 <mrdk> ivanm: yes, it'll be automatic. So there's no other way than using a list of type Host?
00:47:00 <ivanm> well, you have a few other options
00:47:19 <ivanm> have explicit homeKeys, workKeys and laptopKeys, as well as a commonKeys listing
00:47:29 <ivanm> there are probably a few other ways of finangling this
00:47:38 <ivanm> but they'd probably be uglier and take more work
00:47:40 <mrdk> ivanm: hmm I guess your first idea is better, and less work
00:47:48 <mrdk> ivanm: right
00:48:35 <mrdk> ivanm: actually I thought of expressions like "~Home" or "~Home & ~Laptop"
00:48:48 <mrdk> ivanm: but maybe this is just senseless.
00:49:00 <ivanm> in Haskell, yes
00:49:49 <mrdk> ivanm: ok; I'll see what I can do, thanks for your help so far
00:50:20 <ivanm> np
00:52:45 <taruti> What is the last version of House/hOp/... ?
00:52:57 <ivanm> why not look on the website to find out?
00:53:36 <taruti> ivanm: it seems to have lots of forking and dead pages
00:53:54 <Zeiris> How do I throw a simple parsing error from inside Parsec?
00:54:06 <ivanm> well, wikipedia says 0.8.93 from jan last year?
00:54:16 <ivanm> http://en.wikipedia.org/wiki/House_%28operating_system%29
00:54:24 <ivanm> s/?//
00:56:16 <taruti> there is at least lighthouse which has been developed this year
00:56:19 <Zeiris> All the error stuff in Parsec doesn't have ParserT return types... Do I need to use fail?
00:56:48 <BMeph> taruti: looking up "HASP" may help out getting info, as well.
00:57:02 <ivanm> taruti: lighthouse /= house :p
00:57:23 <ivanm> Zeiris: well, polyparse uses fail; maybe parsec does as well
00:57:57 <Zeiris> Oh. So it does, and it prints the location on its own! Oh my god it's so simple :3
00:58:12 <geheimdienst> zeiris: http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Prim.html#v%3Aunexpected
00:58:28 <geheimdienst> "The parsers fail, (<?>) and unexpected are the three parsers used to generate error messages. Of these, only (<?>) is commonly used ..."
00:58:32 <taruti> wasn't HASP developing Habit?
00:59:15 * taruti is pondering getting GHC to produce binaries that run on top of Fiasco.OC
00:59:32 <taruti> and trying to see what is the least insane starting point
01:03:17 * BMeph thinks having a OS named "Fiasco" is a marketing Failure...
01:05:13 <Ke> BMeph: it was never marketed to regular people
01:06:46 * geheimdienst votes for renaming it "unicorns with rainbowy glitter in their hair"
01:40:54 <mrdk> ivanm: I couldn't find any info about how RWH does it with the PCRE bit, got me a link or anything?
01:41:47 <ivanm> mrdk: doesn't really apply to your situation; they use newtypes to wrap over the Int options to provide more safety rather than using random Ints for the different options
01:42:47 <mrdk> ivanm: oh I see
01:48:07 <monadic_kid> anyone used nhc before?
01:48:40 <mrdk> ivanm: maybe there's a way to define a bunch of functions which will create a list containing the corresponding Hosts. Being able to use expression like "Not Laptop"
01:59:27 <ibt> does anyone know if Data.Reflection still works the same was as in the implicit configuration paper?
02:05:59 <solrize> gack
02:06:02 <solrize> oops
02:22:18 <Tarrasch> :t Nothing <*> Just "abc"
02:22:19 <lambdabot> forall b. Maybe b
02:22:25 <Tarrasch> > Nothing <*> Just "abc"
02:22:26 <lambdabot>   Nothing
02:23:04 <Tarrasch> How can it "show" that expression? Surely it ain't an instance of Show since (Maybe b) isn't in show. Isn't that strange?  
02:23:49 <Cale> Tarrasch: Generalised defaulting.
02:24:12 <Veinor> there's an Show a => Show (Maybe a)
02:24:35 <Tarrasch> Veinor, yea but an aribtrary 'b' isn't an instance of show. no?
02:24:43 <Tarrasch> Cale, what's that?
02:24:46 <Cale> Tarrasch: ghci and lambdabot have a stronger sort of defaulting turned on which defaults some ambiguous types to () if it's valid to do so.
02:24:46 <Veinor> well no
02:25:09 <Cale> There's no instance of Show for  forall a. Maybe a, but there is an instance for Maybe ()
02:25:30 <Tarrasch> Cale, ah ok, so it defaults b to () and then shows it...
02:26:13 <Tarrasch> For a moment I thought it used "lazy class-constraint-checking" :p
02:26:59 <anarchomaniac> hey haskell programmers
02:27:03 <Tarrasch> hi!
02:27:12 <Cale> http://haskell.org/ghc/docs/6.6/html/users_guide/ch03s04.html#extended-default-rules
02:27:17 <Cale> Hello!
02:27:17 * anarchomaniac has been interested in haskell lately
02:28:13 <anarchomaniac> Haskell seems to be worth learning, if not for its uses then for the experience
02:28:21 <anarchomaniac> I'm sure i'll be a better programmer for it.
02:28:29 <anarchomaniac> :D
02:28:47 <Cale> anarchomaniac: Certainly. Let us know if you have any questions.
02:28:56 <anarchomaniac> Thanks :)
02:29:22 <anarchomaniac> I'm still getting used to the idea of functional programming, since my main experience is coding the language that is basically the opposite of haskell (perl)
02:29:29 <Tarrasch> Thanks Cale 
02:29:38 <anarchomaniac> I've been told it'll just click eventually, so i'll keep at it
02:30:03 <Taejo> I'd say perl is less opposite to haskell than C is
02:30:04 <Cale> anarchomaniac: Yeah, it can help to sort of try to forget that you already know how to program.
02:30:25 <Gracenotes> Taejo: that took a few seconds to parse..
02:30:27 <anarchomaniac> I'm an aspiring linguist, so I learn programming languages the way i'd learn a spoken one
02:30:35 <anarchomaniac> "forget everything you know about speaking"
02:30:42 <Gracenotes> uh probably because the parser was written in perl regex. (oh snap)
02:30:53 <Cale> Yeah, that's a good policy. :)
02:31:11 <anarchomaniac> Perl 6 is getting more like Haskell, but I'm talking regular old perl.
02:31:16 <Taejo> Gracenotes: you can drop the "is", but then it's ambiguous
02:33:57 <Cale> anarchomaniac: One of the realisations which really helped me make the transition early on is realising that the right replacement for loops is lists. Just as a loop either never occurs at all, or consists of an iteration followed by another loop, a list is either empty, or consists of a single element followed by another list.
02:35:04 <anarchomaniac> Cale: I'm trying to wrap my head around that, and it seems to make a lot of sense
02:35:22 <Cale> and the replacement for loop bodies is combinations of higher order functions on lists -- get really comfortable with map, filter, foldr, and the others.
02:35:39 <anarchomaniac> Cale: i plan to.
02:36:06 <cncl> are more people using quickcheck2 now, or still 1?
02:36:18 <anarchomaniac> thing is, i'm not an experienced coder by any means, but i'm ambitious. i'm not fluent in any one language yet, but i understand programming concepts. so far i'm not stuck on anything yet, so i'm doing okay.
02:36:18 <cncl> about to add tests to my current project, not sure which to pick this time
02:36:33 <Cale> cncl: I think most people use QC 2 now, but I'm not sure.
02:36:42 <ibt> is the :: in the lhs legal? i've never seen this before and ghc doesn't like it. is it some extension?  normalize a :: M s a = M (mod a (modulus (__ :: s)))
02:36:50 <c_wraith> I like CoArbitrary being moved to a different class
02:37:07 <Cale> I actually thought it a bit strange that coarbitrary was separated.
02:37:25 <cncl> cool i'll go with 2
02:37:31 <Cale> ibt: hmm....
02:37:32 <cncl> do people use that test-framework package i see on hackage?
02:37:33 <c_wraith> It's only relevant when you're making arbitrary functions...  Which isn't that common of an operation, I thought
02:37:36 <Cale> ibt: It's not Haskell 98
02:38:04 <Cale> ibt: Maybe with PatternSignatures ?
02:39:26 <Cale> c_wraith: I suppose, but missing an instance by accident can be even more annoying than being forced to define coarbitrary (which is usually easy)
02:39:49 <anarchomaniac> How is haskell for implementing algorithms? It may seem obvious or something, but i'm curious if it's one of those things haskell is just "good at" the way perl is with pattern matching.
02:40:04 <cncl> haskell is great for implementing algorithms
02:40:07 <c_wraith> I was never able to make any sense of coarbitrary's type signature
02:40:37 <anarchomaniac> awesome :D
02:41:11 <Cale> c_wraith: The idea is simply to take a value of type a, and use it in some consistent way to nudge an arbitrary random generator.
02:41:14 <Gracenotes> some of the datatypes leave some operations to be desired. but still they leave other languages' datatypes in the dust in terms of said operations
02:41:20 <cncl> anarchomaniac: one tip, if you ever think to yourself, "this is impossible in a pure language" the answer probably has something to do with laziness :)
02:42:00 <anarchomaniac> Oh i know anything is possible. It's just a matter of if it's logical to do it one way when it's more familiar/easier in another language
02:42:05 <ibt> Cale: didn't seem to help
02:42:17 <Cale> ibt: Maybe it was pseudocode?
02:42:23 <Cale> c_wraith: There are some combinators for making this easy to do for algebraic types whose fields are coarbitrary instances
02:42:48 <ibt> Cale: ghc says parse erorr. it's from http://www.cs.rutgers.edu/~ccshan/prepose/Prepose.hs
02:44:50 <Cale> ibt: Try deleting that signature, and adding  "forall s a." to the start of the signature for the whole declaration. If GHC still complains about it, add {-# LANGUAGE ScopedTypeVariables #-} to the top of the file
02:48:30 <Tarrasch> anarchomaniac, Algorithms? In the sense of clean well-written algorithms or in the context of algorithm competitions?
02:48:53 <anarchomaniac> competitions?
02:48:57 <anarchomaniac> i'm just gonna assume the first one
02:49:05 <Tarrasch> anarchomaniac, Ok, then haskell is good
02:49:16 <anarchomaniac> Like, my friend is interested in stock trading algorithms
02:49:42 <Cale> c_wraith: The idea is that when you go to make a random function a -> b, you'll want to generate random values of type b, which are nonetheless consistent if you apply the function twice to the same value. So what you need is a way to take a single random number generator state, and perturb it each time the function is applied to a value in a consistent way.
02:49:51 <anarchomaniac> cool :D
02:55:20 <cncl> ack
02:55:28 <cncl> the color coding in test-framework breaks my terminal cursor
02:55:32 <cncl> :/
02:56:29 <ibt> Cale: i'm not having much luck. adding the forall got rid of some errors, but now there are many more.
02:58:19 <cncl> oh nice
02:58:23 <cncl> if i run it through make, it's ok
03:02:00 <ibt> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28715  has the relevant lines and error. any help would be appreciated
03:13:30 <cncl> what's the no-warn for no type signature in ghc?
03:14:05 <Heffalump> -fno-warn-missing-signatures I think
03:14:07 <cncl> warn-missing-signatures
03:14:08 <cncl> yup thanks
03:14:22 <Taejo> -fno-warn-missing-signatures looks like the right thing
03:14:50 <cncl> yup, worked
03:16:23 <abcd-> hi, im doing cabal install wx on windows and i get : cabal: ar is required but it could not be found.
03:16:45 <abcd-> any ideas what 'ar' is?
03:17:02 <geheimdienst> abcd-, it's an unpacking tool a little like tar
03:17:16 <geheimdienst> it could be that wx requires you to install cygwin or similar
03:17:44 <geheimdienst> i'm guessing cygwin includes ar
03:19:12 <abcd-> ok thanks
03:37:33 <ezyang> Oh man hackage 2.0 
03:37:55 <anarchomaniac> I'm learning me a haskell :D
03:37:58 <anarchomaniac> this is getting easier
03:38:27 <ivanm> ezyang: it's out? :o
03:38:41 <ivanm> ezyang: looks exactly the same to me...
03:39:59 <ezyang> It has reverse deps 
03:40:08 <ezyang> oh, not on main hackage 
03:40:12 <ezyang> http://cogracenotes.wordpress.com/2010/08/08/hackage-on-sparky/ 
03:40:19 <ezyang> anyway, it's wayyyy too late 
03:40:24 <ezyang> 'gnight 
03:41:04 <ivanm> oh, they got that off roel's one?
03:56:42 <b0fh_ua> Hi, if I defined data type A with some properties. is it possible to derive type B from A and add some more properties? Or the only way is to compose A into B as a property?
03:58:16 <monadic_kid> bofh_ua: there is no sub-typing in Haskell
03:58:46 <b0fh_ua> monadic_kid: ok then ) I supposed it to be so, just needed some confirmation
03:59:26 <b0fh_ua> with subtyping type inference becomes overcomplicated, I guess
04:00:49 <monadic_kid> bofh_ua: yes because they are open types. If the set of types is closed you can use algebraic dat types but you're trying to extending/inherit fields which isnt' really about subtyping
04:04:26 <mornfall> Subtyping is overrated. Use composition! :)
04:04:54 <mornfall> ls
04:05:05 <mornfall> Sorry focus went elsewhere...
04:06:24 <b0fh_ua> prefer composition over inheritance, I know :)
04:21:14 <opqdonut> anyone here use opengl?
04:21:52 <opqdonut> I'd like to draw into a texture. are there any helper functions for creating one?
04:22:06 <opqdonut> I can only find stuff that wrap a Ptr a
04:37:45 <McManiaC> class Container c where type Element c :: * -- what is that? how can I read that?
04:39:17 <copumpkin> McManiaC: an associated type
04:39:35 <copumpkin> you could write instance Container IntSet where type Element = Int; ...
04:39:45 <copumpkin> instance Container (Set a) where type Element = a
04:41:31 <McManiaC> ah
04:41:44 <McManiaC> and some function could look like "foo :: Element -> ..." ?
04:42:17 <copumpkin> yeah, something like anElement :: Container a -> Element a
04:42:25 <copumpkin> oh wait
04:42:40 <copumpkin> anElement :: (Container a) => a -> Element a
04:42:53 <McManiaC> ah okay :)
04:42:55 <McManiaC> thx
04:42:57 <copumpkin> I forgot the parameter to the Element type function, too
04:42:59 <copumpkin> but you get the idea
04:43:00 * ivanm stares at copumpkin 
04:43:03 <McManiaC> yup
04:43:14 * copumpkin unstares ivanm
04:43:19 <ivanm> heh
04:43:35 * ivanm needs to think of a synonym of "Container" for container-classes
04:44:16 <copumpkin> Receptacle
04:44:17 <copumpkin> ;)
04:44:32 <geheimdienst> things with things in them
04:44:46 <geheimdienst> a boxish
04:44:49 <copumpkin> BoxyThing
04:46:11 <McManiaC> type ContainerShip = [Container]
04:46:11 <McManiaC> :D
04:46:12 <geheimdienst> http://thesaurus.com/browse/container
04:46:30 <copumpkin> geheimdienst: is that where you got boxish? not interested, thanks
04:46:31 <copumpkin> ;)
04:46:58 <McManiaC> :D
04:47:59 <FunctorSalad> ivanm: hmm there's a host of synonyms for 'collection' if that'll do
04:59:15 <irekj> Hi
05:05:10 <Gracenotes> awooga
05:10:43 <Gracenotes> A new post about hackage, by the way: http://cogracenotes.wordpress.com/2010/08/08/hackage-on-sparky/
05:11:34 <Gracenotes> hm, should probably post it to reddit. hopefully the server doesn't keel over and die though :x
05:12:36 <ivanm> Gracenotes: hackage' sure doesn't look much different...
05:13:00 <ivanm> and for the reverse deps stuff, did you just steal the code for the one at http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/package/ or write it yourself?
05:13:20 <Gracenotes> yeah, saith my mentor there's more of a push to get the internals right than to do a redesign
05:13:41 <Gracenotes> for which there are people more skilled than I am
05:13:48 <ivanm> fair enough
05:14:04 <ivanm> maybe grab the colour scheme from new haddock? *shrug*
05:14:09 <Gracenotes> ivanm: wrote it myself, it also does incremental upgrades, serves a different kind of data
05:14:15 <Gracenotes> for the revdeps I mean
05:14:21 <ivanm> fair enough
05:17:04 <Gracenotes> ivanm: hm, I'll try that. but I'm not a web designer. :)
05:19:32 <copumpkin> neither are most web designers
05:21:29 <hpc> copumpkin: haha, so true :(
05:23:02 <hpc> > topic -- i wonder if this works
05:23:04 <lambdabot>   Not in scope: `topic'
05:33:27 <Berengal> Gracenotes: Are you okay with people switching their cabal remote-repo to your server for testing purposes?
05:35:49 <Gracenotes> Berengal: there wouldn't be any big problems with it. two little problems, though: sparky isn't actively mirroring the haskell.org site, and I hope to finish a client for that soon. and second, just need to edit the tarball-generating code to put http://sparky.haskell.org:8080/packages/preferred-versions in
05:37:07 <Gracenotes> otherwise, it behaves the same as hackage.haskell.org, as far as I can tell, even for the package uploading URI scheme
05:39:27 <Gracenotes> Berengal: oh, actually, there is a big problem. sparky only has the latest versions of packages, because that's the only way archive.tar is served
05:39:49 <Gracenotes> I'd have to copy them manually, or obtain an archive.tar that has all versions of packages
05:39:59 <osaunders> Is there a place where #haskell lukers can register their asl and stuff?
05:41:07 <hpc> i suppose, just say it and the logs will catch it?
05:43:20 <osaunders> hpc: Not really what I was after.
05:43:45 <osaunders> @where admin
05:43:46 <lambdabot> I know nothing about admin.
05:50:58 <Baughn> osaunders: What *are* you after?
05:52:23 <osaunders> I want to know the people on #haskell who are near me so I can invite them to my functional programming meetup
05:52:31 <ivanm> email
05:52:31 <Baughn> Ahh.
05:52:42 <Baughn> Yeah, posting to haskell-cafe tends to work
05:52:45 <ivanm> there was a map, but the site is down IIRC
05:52:49 <copumpkin> or the haskell reddit
05:52:55 <copumpkin> but probably cafe
05:52:59 <copumpkin> osaunders: where are you?
05:53:04 <ivanm> email to -cafe, post on reddit and do a blog post on haddock
05:53:05 <osaunders> Edinburgh, UK
05:53:06 <ivanm> cover all your bases
05:53:16 <ivanm> osaunders: heh, I was hoping to go there... no funding though :(
05:53:30 <ivanm> oh well, Canberra is cold enough for me :s
05:53:31 <osaunders> ivanm: Nice ideas
05:53:52 <Gracenotes> oh, hey, any of you guys uploaded versions of packages that were 'bad' in some way? that, say, I can use to demo deprecated versions on sparky? >_>
05:53:59 * ivanm suddenly realised he never got around to writing the blog post he was going to do this weekend...
05:54:08 <ivanm> Gracenotes: yeah, graphviz, one before last
05:54:16 <ivanm> I stuffed up part of the code
05:54:26 <ivanm> 2999.10.0.0
05:54:31 <osaunders> ivanm: What is the URL of this map anyway?
05:54:37 <ivanm> I changed some code to make haskell-src-exts happy, but didn't do it properly :s
05:54:40 <copumpkin> ivanm: where do you even get a version scheme like that?
05:54:56 <ivanm> osaunders: http://www.haskell.org/haskellwiki/IRC_channel#Locations
05:55:06 <Baughn> copumpkin: It's just the 2999'th major version. What?
05:55:30 <hpc> if you are going to be ridiculous, at least do something like 3.14.159.256
05:55:38 <ivanm> copumpkin: look for "Why are the version numbers so high" here: http://projects.haskell.org/graphviz/faq.html
05:55:42 <ivanm> hpc: doesn't follow the PVP
05:55:44 <ivanm> @where PVP
05:55:44 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
05:55:55 <copumpkin> it'd be nice if those lat/longs had human-readable counterparts
05:56:12 <Gracenotes> ivanm: ah, got it
05:56:30 <ivanm> copumpkin: you satisfied with my rationale for having such large version numbers?
05:56:38 <Gracenotes> right, so http://sparky.haskell.org:8080/packages/preferred - demoing is good I suppose.
05:57:11 <mauke> hah, http://p3rl.org/File::Slurp is at version 9999.13
05:57:14 <ivanm> sure
05:57:32 <osaunders> preflex: karma osaunders 
05:57:32 <preflex>  osaunders has no karma
05:57:38 <ivanm> @karma osaunders 
05:57:38 <lambdabot> osaunders has a karma of 0
05:57:43 <osaunders> :(
05:57:49 <osaunders> preflex: help karma
05:57:50 <preflex>  karma NICK - print a user's karma
05:57:55 <osaunders> What is karma?
05:57:57 <ivanm> osaunders: you obviously haven't been helpful enough for anyone to giv eyou karma
05:58:01 <ivanm> *give you
05:58:03 <osaunders> Ah
05:58:06 <osaunders> How do you give?
05:58:13 <copumpkin> ivanm: I guess :P
05:58:23 <Berengal> @karma berengal
05:58:23 <lambdabot> You have a karma of 5
05:58:30 <copumpkin> @karma
05:58:30 <lambdabot> You have a karma of 7
05:58:32 <hpc> @karma c
05:58:32 <lambdabot> c has a karma of 2
05:58:37 <mauke> preflex: karma C
05:58:37 <preflex>  C: 151109
05:58:44 <mauke> that's how it's done!
05:58:46 <hpc> haha
05:58:51 <Berengal> @karma java
05:58:51 <lambdabot> java has a karma of -8
05:58:55 <hpc> :D
05:58:57 <Berengal> java++
05:58:59 <hpc> @karma hpc
05:58:59 <Berengal> @karma
05:58:59 <lambdabot> You have a karma of 1
05:58:59 <lambdabot> You have a karma of 4
05:59:04 <Berengal> @karma java
05:59:04 <lambdabot> java has a karma of -8
05:59:04 <writer> @karma haskell
05:59:05 <lambdabot> haskell has a karma of 61
05:59:09 <ivanm> Berengal: are you crazy?!?!?!
05:59:10 <ivanm> java--
05:59:19 <mauke> preflex: karma java
05:59:19 <osaunders> @karam ivanm
05:59:19 <lambdabot> Maybe you meant: karma karma+ karma-
05:59:19 <preflex>  java: -31
05:59:24 <hpc> @karma karma
05:59:24 <lambdabot> karma has a karma of 1
05:59:27 <p_l> @karma cl
05:59:28 <lambdabot> cl has a karma of 0
05:59:30 <osaunders> @karma+ ivanm
05:59:30 <lambdabot> ivanm's karma raised to 22.
05:59:32 <mauke> preflex: karma chameleonb
05:59:33 <preflex>  chameleonb has no karma
05:59:33 <writer> @karma lambdabot
05:59:33 <lambdabot> lambdabot has a karma of 1
05:59:34 <mauke> preflex: karma chameleon
05:59:34 <preflex>  chameleon: 4
05:59:47 <osaunders> @karma- java
05:59:47 <lambdabot> java's karma lowered to -10.
05:59:48 <ivanm> IIRC, the people with the most karma according to lambdabot are all people on #pugs
05:59:55 <Gracenotes> > repeat "spam"
05:59:56 <lambdabot>   ["spam","spam","spam","spam","spam","spam","spam","spam","spam","spam","spa...
05:59:59 <ivanm> since they give out karma all the time
06:00:01 <osaunders> lol
06:00:06 <ivanm> Gracenotes: NEEDZ MOAR VIKINGZ!!!
06:00:18 <Gracenotes> D:
06:00:22 <osaunders> @karma+ mauka
06:00:22 <lambdabot> mauka's karma raised to 1.
06:00:34 <osaunders> Whoops, wrong person
06:00:39 <osaunders> @karma+ mauke
06:00:39 <lambdabot> mauke's karma raised to 23.
06:00:48 <osaunders> For all the help with flip id earier
06:00:52 <ivanm> Gracenotes: did you type that emoticon correctly?
06:00:59 <Gracenotes> yes
06:01:01 <mauke> don't use @karma+, lambdabot is the only bot that understands it
06:01:04 <ivanm> you do get the whole viking thing, don't you?
06:01:05 <osaunders> @karma- mauka
06:01:05 <lambdabot> mauka's karma lowered to 0.
06:01:52 <ivanm> Gracenotes: http://en.wikipedia.org/wiki/Spam_%28Monty_Python%29
06:03:10 <Gracenotes> D: is a bit of a horrified expression
06:03:29 <ivanm> exactly
06:03:43 <ivanm> I wasn't sure if you didn't like the sketch, or had no idea why I was talking about vikings wrt spam
06:04:01 <mauke> neither. it's the "MOAR" and "VIKINGZ"
06:04:12 <ivanm> heh
06:04:12 <Berengal> D: is a person with a small face and a big hat
06:04:31 <ivanm> yes, copumpkin's return has re-corrupted me
06:04:32 <Gracenotes> D: is also an intense expression. I was trying to match the intensity of your imperative with as few keystrokes as possible
06:04:39 <copumpkin> MOAR!
06:05:18 <aristid> VIKINGZ!
06:05:40 <nschoe> Hi all, I've been trying to follow RWH's chapter over GUI Programming with Gtk2hs, I've just issued 'cabal install glade' but inside ghci I can't find module 'Graphics.UI.Gtk.Glade'. I run under Archlinux and use ghc 6.12.1. Can I get come help please?
06:06:04 <ivanm> nschoe: it's quite possible that the API has changed
06:06:24 <ivanm> nschoe: oh, did you have ghci running whilst you installed glade?
06:06:40 <nschoe> ivanm: nope, I quit ghci and launched it severla times.
06:06:41 <hpc> hackage says the api is the same
06:06:51 <ivanm> nschoe: "ghc-pkg list glade"
06:07:21 <nschoe> hpc: ok
06:07:31 <nschoe> ivanm: I ran this, what should I get?
06:07:39 <ivanm> nschoe: it should say glade
06:07:53 <ivanm> specifically, glade-0.11.1
06:07:55 <nschoe> ivanm: I got glade-0.11.1
06:07:57 <ivanm> or 0.11.0
06:08:03 <ivanm> nschoe: right, so it is installed
06:08:11 <ivanm> nschoe: what are you doing in ghci that it isn't finding that module?
06:08:20 <nschoe> ivanm: tab-completion
06:08:34 <ivanm> ummm..... what command?
06:09:02 <ivanm> are you doing :module or something?
06:09:08 <nschoe> ivanm: I begin ':m Graphics.UI.Gtk.G' and when I press tab there is no output, when I erase the last 'G' and double tab I got some results, but no glade.
06:09:26 <ivanm> k
06:09:50 <ivanm> this is the same user that installed glade, right?
06:10:06 <ivanm> how about if you forget about tab-completion and just do ":m Graphics.UI.Gtk.Glade" ?
06:10:37 <nschoe> ivanm: Yes. But I have one question: what is the difference between installing glade from cabal install and installing it via pacman? (I'm under Archlinux).
06:10:46 <nschoe> ivanm: it says there is not such a module.
06:10:58 <hpc> cabal will download the latest source from hackage
06:11:06 <hpc> pacman uses the latest arch build
06:11:12 <ivanm> nschoe: distro packages are usually preferred
06:11:31 <ivanm> since they take distro-specific stuff into account, are uninstallable and will bring in non-haskell deps, etc.
06:11:31 <hpc> i generally prefer tarballs
06:11:41 <nschoe> ivanm: you mean with pacman?
06:11:50 <ivanm> well, yes
06:12:00 <nschoe> Okay, but I have installed it too with pacman.
06:12:38 <ivanm> nschoe: when you did that ghc-pkg command, did it say it was in the user or global DB?
06:14:41 <nschoe> ivanm: Well, when issueing 'ghc-pkg glade' I got three output lines: "/usr/lib/ghc-6.12.1/package.conf.d", "/home/nschoe/.ghc/x86_64/-linux-6.12.1/package.conf.d" and "glade-0.11.1"
06:15:02 <ivanm> OK, that means your pacman package didn't install properly
06:15:21 <ivanm> now, are you running ghci under your "nschoe" user?
06:15:34 <nschoe> ivanm: Just another information: I first installed glade thanks with pacman, and then when I saw I could not import from ghci, I tried via cabal.
06:15:53 <ivanm> doing this in ghci should return the same info: ":! ghc-pkg list glade" (sans quotes)
06:16:05 <nschoe> ivanm: btw, I can launch glade in the shell with 'glade-3'.
06:16:26 <hpc> are you sure you installed the glade package and not just glade?
06:16:30 <ivanm> nschoe: that glade is the C glade, not the haskell glade library
06:16:37 <ivanm> hpc: yeah, that's what it sounds like
06:16:41 <nschoe> yes it does. The same output.
06:16:50 <ivanm> OK, it's the same user
06:17:00 <nschoe> ivanm: Okay, so I must uninstall it with pacman, right?
06:17:05 <ivanm> nschoe: and you're positive you've quit ghci and started it again since installing glade?
06:17:12 <ivanm> nschoe: no; Haskell glade will use C glade
06:17:37 <nschoe> ivanm: Yes positive, I even closed my shell.
06:17:54 <ivanm> ... interesting
06:19:03 <ivanm> nschoe: try running this in your shell: ghc -e ":t Graphics.UI.Gtk.Glade.xmlNew"
06:19:26 <nschoe> What I don't understand is: when I read the output of 'cabal install glade' I saw a line with smth like "Compiling Graphics.UI.Gtk.Glade' so I thought "at last!". But then I started ghci and I could not find it.
06:19:58 <ivanm> nschoe: well, yes, something's screwy with your system
06:20:14 <ivanm> so we need to check that ghc knows about glade being installed
06:20:28 <ivanm> nschoe: does "ghc-pkg check" spit any errors out?
06:20:31 <nschoe> ivanm: I got "Failed to load interface for ..."
06:20:40 <nschoe> "and Use -v to list ..."
06:21:15 <ivanm> OK, that means ghc can't find it
06:21:25 <ivanm> sounds more and more likely that the install is broken...
06:21:44 <nschoe> I'm currently doing 'cabal install glade --reinstall'
06:22:01 <ivanm> well, my bet is that the install broke
06:23:32 <nschoe> ivanm: It's weird, the re-install had just ended, I got "Installing library in /home/nschoe/.cabal/lib/glade-0.11.1/ghc-6.12.1" and "Registering glade-0.11.1" But again: not found in ghci
06:23:47 <ivanm> nschoe: does "ghc-pkg check" complain?
06:24:08 <nschoe> I have no output, so I guess no
06:25:44 <ivanm> does running that ghc -e command work now?
06:25:46 <nschoe> ivanm: I have just ran an search command with pacman, and I see two different packages : "gtk2hs-glade" and "haskell-glade". What difference?
06:26:01 <nschoe> (No it doesn't)
06:26:04 <ivanm> I think gtk2hs is the older one
06:26:25 <nschoe> ivanm: Okay, I'll try to install haskell-glade.
06:26:28 <ivanm> because glade used to be an optional component of the gtk2hs package, but now gtk2hs has been split up into multiple packages
06:26:36 <ivanm> I'm not an arch user though, so I could be wrong ;-)
06:27:30 * ivanm -> unconsiousness with periodic bouts of hallucinations
06:27:59 <nschoe> ivanm: No you seem to be right: when issuing that command it asked me to install haskjell-cairo, haskell-gtk ... and severla other haskell-something.
06:28:16 <nschoe> It seems to be the multiples packages you said ght2hs was split up into.
06:38:37 <FunctorSalad> haha lazyness is fascinating. I'm adding xterm256 support to hscolour and I'm testing an out-of-bounds configuration.... it doesn't actually fail unless the malconfigured syntax item is *used*
06:40:39 * hackagebot HaTeX 2.1.1 - Library for write LaTeX code.  http://hackage.haskell.org/package/HaTeX-2.1.1 (DanielDiaz)
06:41:30 <FunctorSalad> sup hackagebot?
06:55:48 <CalmNelly> @vixen Do you have Bieber fever?
06:55:49 <lambdabot> let's don't talk about that
06:57:47 <hpc> haha
07:10:00 <qtntmXpEb> Did+you+Europeans+quit+when+you+were+behind+in+your+butchering+Jews+like+unwanted+fetuses?+Don't+bother+booting+up+En+Carta,+genius,+the+answer+is+no.+My+yarmulke+wearing+Sergeant+Grandpa+had+to+fly+his+jet+over+there+and+knock+the+gas+chamber+remote+out+of+your+assy+smelling+fingers+himself.+And+while+he+was+at+it+I+think+he+popped+a+WWII+era+cap+right+in+your+sunken+euro-chest.+I'll+never+forget+the+stories+he+told+
07:10:00 <gnTo2C6flDrzC> i+don't+care+if+you+premium+member,+i+will+ctl+alt+dlt+u+/+you+little+fuck,+i've+got+year+old+posts+bigger+than+u/+before+i+lost+weight,+back+in+ninety-eight/+you+was+wack+posting+over+at+gbs+i+seen+u/+then+you+came+to+FYAD,+switch+your+demeanor,+well+-+we+don't+believe+you,+you+need+more+people/+troll+phds+of+the+game,+we+passed+them+classes;+nobody+could+read+you+05+dudez+like+we+do/+don't+let+'em+gas+you+like+l
07:10:01 <qtntmXpEb> I+GOT+JUMTED+IN+WHEN+I+WAS+11+BITCH+IM+13+WITH+A+BULLET+STILL+KICKING+BACK+LEVA.....+OH+YA+THE+ONE+WHO+MADE+THE+WEB+SITE+GOOD+JOB+BUT+MAKE+THE+COLOR+BLUE+IN+STED+OF+BITCH+ASS+RED........FUCK+WEST+SIDE+SNICHES,EAST+SIDE+BITCHES,NORTH+SIDE+SLUTS!!!!!!!!!!!!!!!!!!!!+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!+!!!!!!!!!!!!!!!!!!!!!!!!!!
07:10:02 <i0lbugkZ> girl+u+must+be+an+NES+cartridge+because+i+will+blow+on+your+slot+until+you+start+functioning
07:10:03 <qtntmXpEb> AHAHAHAHAHAHHHAHAHHAHHAH+YOU+FAGS+ACTULLY+THINK+NINTENDO+BEAT+XBOX+HAHHAHAHAHAHH+HOW+AMUSING+HAHAHHAHAHAHHAHHAHHAHHHHHAAHAHAHHAHAHAHAH+JUST+GIVE+IT+UPHAHHAHHA+YOUR+NOT+GOING+TO+WIN+!!HAHAHAHAHAHAHAHHAHHAH!!!!!!!+A+NEW+GAME+COMING+TO+GAY+CUBE+CALLED+PRINCESS+NINTENDO+IT+COMES+OUT+THE+SAME+TIME+HALO+2+COMES+OUT+WHILE+ILL+BE+PLAYING+HALO+2+YOULL+BE+PLAYING+PRINCSS+NINTENDO+AHHAHAHHAHAH+HELP+MASTER+BILL+GATES+CONQER+THE+W
07:10:03 <gnTo2C6flDrzC> If+Microsoft+gets+rid+of+that+millions+lines+of+spaghetti+code+in+Windows+XP+(expect+the+same+in+Longhorn+2006+&+Blackcomb+2112)+and+comes+up+with+a+brand+new+efficient+system+that+equals+the+Apple,+Apple+can+finally+be+laid+to+rest.+After+all+Microsoft+is+the+standard,+like+the+Qwerty+keyboard.+You+are+going+to+have+to+live+with+Microsoft+and+those+millions+of+lines+of+spaghetti+code+for+some+years+to+come.
07:10:06 <gnTo2C6flDrzC> slitting+open+the+urethra,+cauterizing+the+prostrate,+inflicting+corporal+punishment,+blistering+the+penis+with+caustic+acid,+flaying+the+penile+skin+with+razor+blades,+sewing+the+prepuce+shut+with+metal+wire,+encasing+the+genitals+in+plaster+or+in+lockable+metal+cages,+or+fitting+the+penis+with+penile+rings+studded+with+sharp+metallic+teeth+to+discourage+erections
07:10:09 <eJelLYT3l9ud> you+guys+got+no+life+and+you+have+shitty+computers+cause+you+can+only+run+old+warez
07:10:11 <eJelLYT3l9ud> HI!+ANY+1+HERE+WAN+2+CHAT??I+AM+13/F/BRASIL+KEKEKEJUZ+LOOKIN+FOR+SUM1+2+TALK+2.NO+OLD+GUYSDATS+GROSS!!!GOT+2+SEND+PIX+2+GET+PIXNO+PRIVATESTHATS+GROSS+TOO!PLZ+/MSG+ME+4+CHATim+actually+a+52+year+old+balding+port-a-let+cleaner
07:10:14 <geheimdienst> @where ops
07:10:14 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
07:10:14 <eJelLYT3l9ud> Horney?+Looking+for+a+quick+no+strings+blow+job,+swing+by,+walk+in,+un+zip,+feed+it+to+me,+fuck+my+face,+squirt+n+go.+no+games,+no+names,+no+reciprocation!+very+discreet,+I+live+alone,+can+host+anytime+this+weekend.+You:+HWP,+45/under.+clean+and+ready+to+squirt.+send+me+a+message+with+your+info,+age,+height,+weight+and+when+you+wanna+squirt.+Me:+good+looking,+very+discreet,+white+male.
07:10:18 <eJelLYT3l9ud> Well,+I+can't+waste+all+day+in+this+IRC.+Gotta+go+to+a+T5+meet+for+some+training.+Gotta+place+high+in+this+years+TiT+and+Evo2k5+tournaments.+(Tekken+5.)+See+ya+guys.+:(
07:10:20 <eJelLYT3l9ud> No+more+group+sex+in+the+Jacuzzi,+got+it?+You+all+kept+me+up+until+4am,+and+all+the+chlorine+in+the+world+wouldn't+get+rid+of+the+shit+that+I+found+swimming+in+this+thing+20+minutes+ago.
07:10:23 <cOd9S> randomd's+songs:+Niggers+Niggers,+our+dark+skinned+friends.+If+they're+not+out+working,+they'll+rape+your+girlfriend!+For+jail's+their+domain,+they're+society's+bane--+Let's+hear+it+for+our+friend+the+Nigger!+Linux,+linux,+it's+free+as+in+beer.+But+if+you+installed+it,+you're+a+goddamn+queer!+To+clear+up+your+pimples,+the+solutions+quite+simple--+Just+take+a+bath+and+use+a+face+wash!+Jews,+jews,+their+noses+are+long.+They've
07:10:23 <eJelLYT3l9ud> Me+and+my+friend+went+to+fill+up+my+corvette+last+night+and+there+were+these+two+punks+there+sitting+on+the+sidewalk+of+the+gas+station+with+their+radio+blasting.+I+was+trying+to+think+as+I+pumped+gas+but+their+radio+made+that+hard+to+do.+I+was+not+pleased.+So+I+went+in+and+payed+for+the+gas+and+then+I+went+up+to+the+two+punks+outside.+I+said+excuse+me+but+I+think+you+need+to+turn+your+radio+down.+They+told+me+to
07:10:34 <i0lbugkZ> I+am+officer+David+Green,+badge+no.+1039283+you+are+in+violation+of+Intellectual+Property+and+High+Technology+Technical+Amendments+Act+of+2002,+Division+C,+Title+III,+Subtitle+B+of+the+21st+Century+Department+of+Justice+Appropriations+Authorization.+I+must+ask+that+you+cease+and+desist+immediately+if+not+we+will+take+action+and+contact+the+server+that+this+site+is+on+and+force+them+to+give+us+your+ip,+and+we+will+then
07:10:43 <BCoppens> @where ops
07:10:43 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
07:10:45 --- mode: ChanServ set +o mauke
07:10:45 --- kick: i0lbugkZ was kicked by mauke (i0lbugkZ)
07:10:46 --- mode: mauke set +b *!*@gateway/web/cgi-irc/irc.wikia.com/ip.58.246.200.114
07:10:58 <geheimdienst> thanks mauke
07:11:05 <cOd9S> It+has+been+brought+to+my+attention+from+a+fellow+of+mine+that+he+fingers+his+asshole+while+he+jerks+off.+We+were+talking+about+Ninja+Turtles+the+other+day+and+he+was+like+have+you+ever+given+yourself+a+Donatello?+And+I+had+no+idea+what+that+meant+so+I+asked+and+he+said+it+was+when+you+stick+your+finger(s)+in+your+asshole+while+you+jerk+off.+So+to+that+I+say+no+and+ask+him+if+he+has+ever+given+himself+a+Donatello,+and+he+giv
07:11:20 <kloeri> mauke: make that *!*@gateway/web/cgi-irc/irc.wikia.com/* instead
07:11:30 --- mode: mauke set +b *!*@gateway/web/cgi-irc/irc.wikia.com/*
07:11:51 --- mode: mauke set -b *!*@gateway/web/cgi-irc/irc.wikia.com/ip.58.246.200.114
07:12:27 <copumpkin> sigh
07:12:33 <hpc> why does wikia have a cgi-irc?
07:12:35 <copumpkin> pretty sure that's m``
07:12:47 <mauke> who's m``?
07:12:59 <copumpkin> (reasonably sure) the asshole who launched a similar attack yesterday
07:13:14 <copumpkin> joined right before the attack, talks about "strictanal", leaves right after we finish banning the bots
07:13:19 <copumpkin> (after spamming a little himself)
07:13:24 <copumpkin> (hangs out in #scheme)
07:13:29 <silver> lol
07:13:35 <silver> schemers are evil?
07:13:38 <mauke> I just blame GNAA
07:13:42 <copumpkin> no, seems to have no interest in scheme either
07:13:47 <silver> oh
07:13:48 <Berengal> What a lame attack...
07:13:51 --- mode: mauke set -o mauke
07:13:53 <copumpkin> was basically trolling there too
07:13:58 <copumpkin> who knows what the deal is
07:14:27 <Berengal> Didn't even fill a single screen
07:14:54 <copumpkin> yeah, yesterday we caught it pretty quickly too
07:15:21 <hpc> cgi-irc isn't exactly the fastest way to mount an attack, tbh
07:15:29 <copumpkin> nope :)
07:15:31 <mauke> why is sorear in @where ops?
07:16:09 <copumpkin> isn't he on the access list?
07:16:19 <mauke> preflex: seen sorear
07:16:19 <preflex>  sorear was last seen on #haskell-blah 1 year, 180 days, 9 hours, 10 minutes and 3 seconds ago, saying: nikki93: what you need is a friend
07:16:22 <copumpkin> :P
07:16:34 <mauke> he seems to hang out on irc.perl.org
07:16:45 <copumpkin> he's connected to freenode too, but I can't see what channels he's in
07:17:01 <mauke> I'd try #perl6
07:17:30 <copumpkin> good guess :)
07:19:31 <CalmNelly> @vixen Do spammers get laid?
07:19:31 <lambdabot> let me answer that later, okay?
07:19:58 <CalmNelly> @vixen Okay, you go do your thang!
07:19:59 <lambdabot> You complete me
07:20:11 <CalmNelly> @vixen Uhhh.
07:20:11 <lambdabot> I hear ya!
07:20:22 <geheimdienst> @vixen you tab-complete me
07:20:23 <lambdabot> you sir are no gentleman
07:20:56 <aristid> truth
07:22:38 <mauke> @where+ ops shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom
07:22:38 <lambdabot> It is forever etched in my memory.
07:23:49 <copumpkin> @where+ ops shapr member:Cale glguy member:dons sjanssen dcoutts member:Saizan member:dibblego conal member:Philippa bos member:arjanb xerox member:Heffalump member:kosmikus member:wli Pseudonym member:Igloo member:quicksilver member:monochrom Lemmih jmcarthur copumpkin
07:23:49 <lambdabot> Nice!
07:23:56 <copumpkin> ugh, wtf
07:24:06 <copumpkin> I hate my IRC client
07:24:17 <silver> which is?
07:24:22 <copumpkin> colloquy
07:24:30 <silver> oh my
07:24:31 <copumpkin> @where+ ops shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
07:24:31 <lambdabot> Nice!
07:25:31 <mauke> instead of adding yourself to @where ops, I think it's a better idea to set a highlight on "@where ops"
07:25:41 <copumpkin> that'd make sense
07:25:50 * hackagebot darcs-benchmark 0.1.9 - Comparative benchmark suite for darcs.  http://hackage.haskell.org/package/darcs-benchmark-0.1.9 (EricKow)
07:26:02 <copumpkin> maybe I should get a real client
07:26:27 <Philonous> Such as?
07:26:38 <mauke> mirc
07:26:44 <copumpkin> on mac :P
07:26:52 <copumpkin> colloquy only supports single-word highlights, sadly
07:26:58 <silver> lol
07:27:05 <copumpkin> yeah, it's a piece of crap
07:27:17 <copumpkin> oh, maybe I can put regexes in there
07:30:26 <Starfire> Does GHC automatically specialize type class methods and/or inline the method calls if all relevant types are known at compile time?
07:30:26 <copumpkin> okay, I have a highlight on @where ops now :)
07:32:44 <copumpkin> Starfire: no
07:32:53 <copumpkin> you can ask it to specialize it for specific types though
07:32:56 <copumpkin> there's a specialize pragma
07:33:18 <copumpkin> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/pragmas.html
07:33:22 <Starfire> OK, thanks.
07:33:23 <mauke> seriously? it doesn't?
07:33:38 <mauke> why not?
07:34:04 <copumpkin> unnecessary code duplication, I guess? most of the time it doesn't make much of a difference unless you're doing a lot of method calls
07:34:14 <copumpkin> I guess code size isn't much of a concern these days
07:34:54 <mauke> inlining is the basis of other optimizations
07:35:14 <geheimdienst> well, code size is a concern because of fitting into cpu caches and that kind of thing
07:36:54 <hpc> cpus still have some pretty large cache sizes
07:37:23 <hpc> as long as the inlining isn't ridiculous, or the program is large, it should be fine
07:37:42 <geheimdienst> i read the other day on some dude's blog that gcc -Os performed much better than other switches in his case. all the aggressive loop-unrolling and whatnot made it worse because you needed to hit main memory inordinately often
07:38:17 <geheimdienst> hpc, i'm not sure about that? i'm absolutely no hardwareish guy, but isn't the size for a cache line something like 64 bytes?
07:38:39 <hpc> the l2 on my cpu is 12MB
07:38:41 <copumpkin> way larger than that
07:38:46 <copumpkin> l1 is often quite small
07:38:50 <copumpkin> but nothing as small as 64 bytes
07:38:57 <geheimdienst> cache *line* not the total cache size
07:39:03 <copumpkin> oh
07:39:16 <geheimdienst> ;-)
07:39:35 <copumpkin> then I have no clue how big it is on average :)
07:40:26 <davean> hpc: is that accessable from a single core? Or is that the total amoung all cores, but partitioned?
07:41:24 <hpc> pretty sure it's across all cores; SMP wouldn't work otherwise
07:41:35 <davean> hpc: yes it would
07:41:38 <davean> hpc: what CPU?
07:41:51 <hpc> i7
07:41:57 <davean> Yah, then your jus totaly wrong
07:42:01 <davean> Thats L3 your talking about
07:42:07 <davean> and the L2 is probably 256kB
07:42:21 <davean> per core
07:43:03 <hpc> ah, must have misread then
07:43:05 <davean> I beleive all the i7 L2s are 256kB per core
07:43:05 <hpc> nvm
07:43:51 <davean> Though, you've got to have a pretty high end one for 12MB L3
07:44:26 <davean> and, the L3 *is* shared
07:44:34 <davean> (in an i7)
07:44:59 <davean> L1 and L2 are exclusive
07:45:01 <geheimdienst> ah yes, seems to be 64 bytes indeed on the core 2: http://x264dev.multimedia.cx/?p=8 <- this dude's blog is so fascinating
07:45:54 <djahandarie> Yep, D_S is pretty smart
07:46:06 <djahandarie> He was in here learning Haskell at one point, for a class at his uni I think
07:50:04 <Ke> who cares about cache, it one of those things valgrind will automatically fix, especially in debian ;o)
07:50:46 <davean> Ke: haha, what?
07:50:50 <msieradzki> what
07:51:04 <geheimdienst> ke, you mean like valgrind fixing the random-number function for generating ssl certificates or something?
07:51:10 <Maxdamantus> How does valgrind fix caches?
07:51:25 <davean> It reports on caches
07:51:31 <msieradzki> ?
07:51:41 <msieradzki> doesn't oprofile do it the right way?
07:51:46 <Maxdamantus> Yeah, so what's fixing?
07:51:52 <geheimdienst> "fixing" as in "getRandomNumber() { return 4; }"
07:51:59 <davean> msieradzki: uh?
07:52:03 <davean> "right way"
07:52:34 <Maxdamantus> Just run x264 under valgrind. Will fix all performance issues.
07:52:36 <msieradzki> I don't even know what we're talking about
07:53:15 <msieradzki> I thought we're talking about profiler that can report cache misses and count cache line reads
07:53:26 <aristid> haskell: randomNumber = return 4
07:53:26 <Maxdamantus> cachegrind?
07:53:44 <djahandarie> ... return? :P
07:53:56 <djahandarie> I suppose it'd need to be in IO to give the full illusion
07:54:05 <msieradzki> instrumentation or sampling?
07:54:06 <aristid> djahandarie: yeah that's why
07:54:21 <aristid> djahandarie: also i love how it looks more like geheimdienst's code that way
07:54:29 <msieradzki> "Cachegrind runs programs about 20--100x slower than normal." hahaha
07:54:33 <djahandarie> I don't, because that's confusing as hell :P
07:54:56 <aristid> djahandarie: just use your brain, man!
07:54:56 <geheimdienst> obviously i was quoting from the xkcd comic :-)
07:55:05 <mauke> randomNumber = return return 4 4
07:55:19 <aristid> :t return return
07:55:20 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 (a -> m a)
07:55:30 <aristid> :t return return 4 4
07:55:32 <lambdabot> forall a (m :: * -> *). (Monad m, Num a) => m a
07:55:38 <Berengal> > return return 4 4
07:55:40 <lambdabot>   No instance for (GHC.Show.Show (m a))
07:55:40 <lambdabot>    arising from a use of `M6857392925...
07:55:46 <Berengal> > return return 4 4 :: [Int]
07:55:48 <lambdabot>   [4]
07:55:53 <djahandarie> Requires the monad instance for ->
07:56:12 <aristid> > return return 1 4
07:56:13 <lambdabot>   No instance for (GHC.Show.Show (m a))
07:56:13 <lambdabot>    arising from a use of `M5686391765...
07:56:18 <aristid> > return return 1 4 :: [Int]
07:56:20 <lambdabot>   [4]
07:56:25 <Gracenotes> for a dazed second there I should lambdabot has dependent types enabled
07:56:28 <aristid> > const return 1 4 :: [Int]
07:56:29 <Gracenotes> *thought
07:56:30 <lambdabot>   [4]
07:57:19 <mauke> > return return return 4 4 4
07:57:20 <lambdabot>   Ambiguous type variable `m' in the constraint:
07:57:21 <lambdabot>    `GHC.Base.Monad m'
07:57:21 <lambdabot>      a...
07:57:24 <mauke> aww
07:57:45 <hpc> > return return return (4 :: Int) 4 4
07:57:47 <lambdabot>   Couldn't match expected type `t -> t1'
07:57:47 <lambdabot>         against inferred type `GHC.T...
07:57:56 <djahandarie> > (return (return return)) 4 4 4
07:57:57 <lambdabot>   No instance for (GHC.Show.Show (m a))
07:57:57 <lambdabot>    arising from a use of `M3122824685...
07:58:05 <djahandarie> > (return (return return)) 4 4 4 :: [Int]
07:58:06 <lambdabot>   [4]
07:58:07 <hpc> :t return return
07:58:08 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 (a -> m a)
07:59:05 <djahandarie> That -> t instance really does tend to make some stuff really confusing
07:59:50 <aristid> djahandarie: i love its Applicative instance too
08:00:18 <aristid> > (,) <*> (+1) $ 4
08:00:19 <lambdabot>   (4,5)
08:00:36 <djahandarie> > ((*) >>= (+)) 3 4
08:00:37 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
08:00:43 <djahandarie> Oops
08:01:06 <aristid> :t ((*) >>= const (+))
08:01:08 <lambdabot> forall a. (Num a) => a -> a -> a
08:01:12 <mauke> > (,) =<< (+1) $ 4
08:01:13 <lambdabot>   (5,4)
08:01:13 <djahandarie> > ((*) >> (+)) 3 4
08:01:14 <lambdabot>   7
08:01:19 <djahandarie> > ((*) >> (+)) 3 7
08:01:20 <lambdabot>   10
08:01:39 <djahandarie> > ((*) >> (+)) 4 7
08:01:40 <lambdabot>   11
08:01:43 <djahandarie> Grr
08:01:48 <aristid> mauke: oh, cool, so you can use =<< as the "dual" of <*>
08:01:52 <djahandarie> I swear I had a really confusing one, can't remember what it was
08:01:53 <djahandarie> Oh yeah
08:01:58 <djahandarie> > ((*) >=> (+)) 4 7
08:01:59 <lambdabot>   35
08:02:03 <mauke> aristid: http://mauke.ath.cx/tmp/flow.png
08:02:22 <aristid> mauke: beautiful!
08:02:34 <aristid> you should make a blog post out of that :D
08:02:43 <mauke> mspaint quality
08:03:00 <aristid> quality software my Microsoft Inc.
08:03:36 <allbery_b> wrong tool.  visio is expen$ive, though
08:04:15 <aristid> allbery_b: inkscape / graphviz are cheap
08:04:36 <Maxdamantus> tex is cheap
08:04:36 <aristid> but for a quick picture mspaint is fine, it just looks a bit funny:)
08:04:51 <allbery_b> sure, but anything not already installed is "expensive" for a quick one-off :)
08:05:26 <mauke> how do I diagramed in tex?
08:05:32 <allbery_b> painfully
08:05:38 <Maxdamantus> Using arrays.
08:05:46 <Maxdamantus> (or tables)
08:05:50 <Phyx-> with alot of time
08:05:51 <burp> pstricks
08:06:07 <Maxdamantus> Dunno how to do all those arrows though :\
08:06:59 <allbery_b> (forall x. TeX x => Difficult (TeX x))
08:07:06 <allbery_b> there are packages for that
08:07:58 <Berengal> Didn't a winner of the ICFP contest write in TeX?
08:08:17 <mauke> how do you render the TeX logo in unicode?
08:08:20 <allbery_b> probably.  TeX is a wonderful example of a Turing tarpit
08:15:07 <Maxdamantus> \begin{tabular}{ccccccccc} & X & & X & & X & \\ \swarrow &  & \searrow & & \swarrow & & \searrow \\ f & & g & \downarrow & & g & f & & \downarrow \\ \searrow & & \swarrow & \searrow & & \swarrow & & \searrow & & \swarrow \\ & c & & & c & & & c & \\ & \downarrow & & & \downarrow & & & \downarrow & \end{tabular}
08:15:12 <Maxdamantus> Maybe something like that.
08:16:45 <mauke> can I have paint instead?
08:17:07 <Maxdamantus> I think that uses a bunch of latex stuff actually
08:17:18 <chrisdone> needs more inkscape
08:17:49 <aristid> :t (=<<)
08:17:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
08:18:05 <aristid> :t (<**>)
08:18:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
08:19:39 <aristid> :t (<*>)
08:19:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:20:07 <aristid> mauke: i think i understand where the difference between (=<<) and (<*>) arises for the function instance:)
08:51:10 <sshc> How is "char '%' *> hexDigit" different from "char '%' >> hexDigit"? (I'm reading RWS chp 16. regarding Parsec)
08:53:03 <roconnor> sshc: should be the same
08:53:10 <roconnor> @type (*>)
08:53:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
08:53:20 <chrisdone> both discard the left's value
08:53:23 <roconnor> @src (*>)
08:53:24 <lambdabot> (*>) = liftA2 (const id)
08:53:28 <roconnor> @src (>>)
08:53:29 <lambdabot> m >> k      = m >>= \_ -> k
08:54:13 <sshc> je'e
08:55:06 <roconnor> liftM2 (const id) m k = do m0 <- m; k0 <- k; return (const id m0 k0) = do m0 <- m; k0 <- k; return (id k0) = do m0 <- m; k0 <- k; return k0
08:55:59 <roconnor> m >>= \_ -> k = do m0 <- m; k0 <- (\_ -> k) m0; return k0 = do m0 <- m; k0 <- k; return k0
09:03:17 <sshc> How are functions themselves defined as an instance of Functor?
09:03:27 <hpc> fmap = (.)
09:04:32 <roconnor> sshc: it's not reallly functions that are an instance of functor, rather (e ->) is a functor
09:05:09 <sshc> roconnor: Is that special case syntax for Functors?
09:05:16 <sshc> I'm looking for the source
09:06:28 <monadic_kid> sshc: (->) is a type constructor of kind * -> * -> *,  (e ->) is paritally applied so the kind is * -> *
09:07:47 <hpc> @src -> fmap
09:07:47 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:07:56 <hpc> @src (->) fmap
09:07:56 <lambdabot> fmap = (.)
09:08:03 <sshc> Interesting.
09:08:11 <sshc> Can I define any type with symbols?
09:08:25 <sshc> non-alphanumeric symbols
09:08:35 <cjf> sup yo
09:08:42 <sshc> Or is (->) special case?
09:09:05 <hpc> you can make your own
09:09:30 <monadic_kid> type operator extensions
09:09:30 <EvanR> snowman type
09:09:45 <sshc> That's a good idea :D
09:10:02 <sshc> monadic_kid: Do I need an extension to define symbol types?
09:10:58 <alexsuraci> cjf: not much
09:11:02 <monadic_kid> sshc: it's not haskell 98
09:11:26 * Phyx- doesn't get the alure of xmonad
09:11:50 <sshc> Phyx-: Does your xmonad support the tabbed layout?
09:14:12 <sshc> I can't apply only the right side ((-> a)), can I?
09:15:04 <sshc> Does GHC support a flag to enable support for the 2010 standard?
09:15:04 <sshc> 
09:15:05 <cjf> .r
09:16:44 <Igloo> Not in 6.12
09:17:31 <sshc> Does 6.14?
09:17:40 <Igloo> HEAD does, yes
09:18:03 <Igloo> -XHaskell2010
09:19:16 <monadic_kid> sshc: you can apply both type arguments, (->) r e
09:19:43 <Phyx-> sshc: i don't use it
09:19:50 <sshc> Phyx-: You should!
09:19:58 <sshc> Phyx-: I use that one most often
09:20:07 <monadic_kid> sshc:  (->) has kind * -> * -> *, (->) r has kind  * -> * and (->) r e has kind *
09:20:08 <Phyx-> why? it seems like 10 years backwards in window managers
09:20:12 <sshc> Igloo: Is 2010 completely or mostly supported?
09:20:21 <hpc> completely, i think
09:20:38 <Igloo> DoAndIfThenElse isn't yet, but will be by the time it's released
09:20:51 <monadic_kid> sshc: 2010 doesn't add much, it's small change, they are going for more incremental updates than bigs one like C++0x
09:21:06 <sshc> je'e
09:21:07 <hpc> is C++0x even out?
09:21:11 <Wooga> hello, i writed simple todo-list managing program: http://codepad.org/FBa4rgd5 ; can it be improved somehow both in logical and coding style ways?
09:21:19 <monadic_kid> hpc: estimated for march 2011
09:21:26 * hpc facepalms
09:22:03 <monadic_kid> hpc: there was final committee draft last march, all proposal are frozen, they are doing corrections now
09:22:05 <sshc> 2010 doesn't support multiparameter type classes or fundeps?
09:22:26 <copumpkin> sshc: nope
09:23:29 <monadic_kid> I think standard revision some extensions will be added, fundeps might not ever get standard because of type families
09:23:38 <monadic_kid> *next standard revision
09:23:47 <copumpkin> I like having both around
09:23:52 <copumpkin> maybe not everyone does though
09:24:08 <monadic_kid> well i'm just guessing
09:24:26 <sshc> http://hackage.haskell.org/trac/haskell-prime/wiki/HierarchicalModules
09:24:38 <sshc> That wasn't in 98?
09:24:46 <monadic_kid> if i remember correctly haskell 2011 will add some more extensions
09:24:52 <hpc> sshc: no
09:24:56 <hpc> it's a ghc thing
09:25:00 <sshc> I can use "Data." etc without any extensions
09:25:05 <hpc> and an every other compiler thing
09:25:22 <monadic_kid> i think it is: http://www.mail-archive.com/haskell@haskell.org/msg22460.html
09:25:30 <sshc> Wow.  I'm surprised that wasn't in the standard.
09:29:28 <Phyx-> bleh,why does make -j never work on ghc
09:32:42 <copumpkin> it has for me in the past
09:32:54 <copumpkin> sometimes the dependency information isn't complete, I think, and then it fails
09:34:07 <Phyx-> copumpkin: it always hangs or crashes during the configuration of packages
09:35:01 <Phyx-> checking for C compiler default output... configure: error: C compiler cannot cr
09:35:04 <Phyx-> eate executables
09:35:06 <Phyx-> See `config.log' for more details.
09:35:09 <Phyx-> whenever I do a pull
09:35:11 <Phyx-> *sigh*
09:35:13 <Phyx-> make[1]: *** [libraries/integer-gmp/dist-install/package-data.mk] Error 77
09:35:16 <copumpkin> weird
09:36:48 <Phyx-> it's a pattern, 10mins to do a pull, 10 days to get it to compile
09:38:33 <Phyx-> I was told a bug was fixed,which is why i did the pull
09:38:33 <Phyx-> lol
09:39:46 <copumpkin> pull takes that long?
09:39:52 <copumpkin> o.O
09:40:02 <Phyx-> figure of speech :P
09:40:18 <Phyx-> 1 min and 1 day didn't seem all that impressive
09:40:18 <Phyx-> lol
09:41:26 <mietek> @unpl about 86% of wild canola plants in North Dakota have genetically modified genes in  them, and 'two samples contained multiple genes from different species of  genetically modified plants
09:41:27 <lambdabot>  Parse error at "of" (column 11)
09:41:30 <mietek> Blah
09:41:42 <mietek> @unpl IE_cont k e >>= f = IE_cont ((>>= f) . k) e
09:41:43 <lambdabot> IE_cont k e >>= f = IE_cont (\ d -> (k d) >>= f) e
10:05:04 * ksf mentally formulates the orbituary
10:05:18 <ksf> "Sadly, due to unforseen consequences polymorphism was lost to us"
10:05:49 <aristid> ksf: orbituary? :D
10:06:26 <ksf> it may yet live again, though.
10:07:00 <ksf> but it does not seem HEAD supports any more type magic than STABLE
10:07:15 <ksf> ...even though, alledgedly, they got a new type system impl.
10:08:55 <Heffalump> is that merged yet?
10:09:14 <ksf> dunno, I don't read ghc source. it's all haskell to me.
10:09:50 <ksf> orbituary, though (and I just looked up the english term) seems like a word I should include in a threading library.
10:10:35 <pumpkin> obituary?
10:10:45 <ksf> yes. indeed.
10:10:50 --- mode: ChanServ set +o mauke
10:11:07 <ksf> http://dict.leo.org/ende?lp=ende&p=Ci4HO3kMAA&search=obituary&trestr=0x8001
10:11:10 <ksf> , in fact.
10:11:30 --- mode: mauke set -b *!*@gateway/web/cgi-irc/irc.wikia.com/*
10:12:47 <aristid> ksf: i like the word "orbituary"
10:12:54 <aristid> an obituary for an orbit :D
10:13:30 --- mode: mauke set -o mauke
10:13:31 <aristid> contrapumpkin: a zygohistomorphic greeting to you
10:13:49 * ksf is not to blame.
10:14:00 <ksf> "r" just plainly doesn't exist in northern german dialects.
10:14:19 <ksf> it just gets inserted at random places into the spelling.
10:15:16 <tolkad> Is there something like a "maybeParse" function that returns Nothing instead of an exception when parsing fails?
10:15:29 <monochrom> "option"
10:15:31 <ksf> you mean for read?
10:15:35 <ksf> :t reads
10:15:37 <lambdabot> forall a. (Read a) => String -> [(a, String)]
10:15:42 <ksf> you can build one from that one.
10:15:55 <tolkad> no, I mean for parsec
10:16:35 <aristid> ksf: i read the economist so i read the word "obituary" often
10:17:21 <ksf> obituaries for managers, or for economies?
10:17:39 <aristid> ksf: for dictators, mostly.
10:17:48 <ksf> ah. like fidel.
10:17:57 <aristid> i guess that one still lives
10:18:21 * ksf is reminded of the taz headlining "Fidel toppled"
10:18:33 <ksf> small title: over a pedestral at his last speech.
10:19:16 <tolkad> oh, I see, it doesn't *actually* error
10:19:28 <tolkad> it just gives an error string
10:19:35 <aristid> ksf: they must have giggled the whole day
10:19:38 <tolkad> I wonder if there is a way to disable that, I don't need it
10:20:08 <ksf> tolkad, parsec definitely has a driver function which returns an Either.
10:20:33 <ksf> ...which may result in stuff throwing exceptions if you have the MonadError instances imported.
10:20:50 <monochrom> @hoogle option
10:20:50 <lambdabot> Text.Html option :: Html -> Html
10:20:50 <lambdabot> Text.Parsec.Combinator option :: Stream s m t => a -> ParsecT s u m a -> ParsecT s u m a
10:20:50 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
10:20:51 <tolkad> yeah but it builds an error string
10:20:57 <tolkad> which I don't need
10:21:06 <tolkad> is there any way to avoid building that error string?
10:21:10 <ksf> well just ignore it.
10:21:13 * geheimdienst just read about the economist and found that it's from london. geheimdienst always thought it's an american magazine
10:21:16 <ksf> haskell is lazy.
10:22:01 <aristid> :t \a -> a <|> empty
10:22:02 <lambdabot>     Ambiguous occurrence `empty'
10:22:02 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
10:22:03 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
10:22:10 <aristid> :t \a -> a <|> Control.Applicative.empty
10:22:11 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a
10:22:35 <aristid> :t \x a -> a <|> return x
10:22:36 <lambdabot> forall (f :: * -> *) a. (Monad f, Alternative f) => a -> f a -> f a
10:22:39 * hackagebot uu-parsinglib 2.5.4.1 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.4.1 (DoaitseSwierstra)
10:22:43 <aristid> :t \x a -> a <|> pure x
10:22:44 <lambdabot> forall (f :: * -> *) a. (Alternative f) => a -> f a -> f a
10:22:53 <Esteth> with the ST monad, where do you specify the type of the state? I see you specify the type of the index, but the docs don't seem to say that you can specify the type of what gets stored.
10:23:03 <aristid> monochrom: that would be a generic implementation of option, no?
10:23:13 <ksf> tolkad, you won't be able to make parsec not generate the information needed to generate the error message, though, as that's needet to give you Left instead of Right.
10:23:24 <monochrom> no
10:23:34 <ksf> and you're optimising prematurely, anyway.
10:23:45 <monochrom> err, yes
10:23:59 <aristid> monochrom: phew, i thought i had made some stupid mistake
10:26:36 <tolkad> ksf: it's just not something I need and I was wondering if there was a function to avoid it
10:27:44 <ksf> yes, just ignore it.
10:29:20 <ksf> if a tree spouts out an analytic message in a parser and nobody's there to hear it, did the tree spout it?
10:31:47 <tolkad> well... I was going to use it for an HTTP parser for a web server
10:31:54 <tolkad> I guess it will be fine
10:32:02 <EvanR> (use an already written package)
10:32:30 <tolkad> ok, I'm writing this because I want to learn the HTTP spec better
10:32:48 <tolkad> arguments of "don't reinvent the wheel" are invalid if you're trying to learn more about wheels
10:33:12 <geheimdienst> lol. that's true indeed
10:33:12 <ksf> the complex part of http is not the parser (that's only annoying, cf. multi-line headers) but pipelining.
10:33:23 <ksf> content-encoding and how to deal with it.
10:33:27 <ksf> (hint: iteratees)
10:34:52 <avenge> re: iteratees, I'm currently playing around with an alternate iteratee metaphor that looks more like unix pipelines.
10:34:57 <Esteth> I'm trying to write a toy processor emulator as an exercise in learning stateful computations in haskell, but I can't think of how to keep track of registers/memory across my instructions. My first instinct is to keep everything in a State ([Register], Memory) monad, but that seems like it'll be a lot of hassle. The ST monad looks like a better bet, since I can have named references to each register. Am I missing the bo
10:35:00 <avenge> Actually implementing http as you guys speak.
10:35:01 <Esteth> PS: Sorry for wall of text.
10:35:16 <avenge> http://www.scs.stanford.edu/~dm/iterIO/
10:35:18 <EvanR> Esteth: cut off
10:35:26 <EvanR> Am I missing the bo
10:35:49 <Esteth> Am I missing the boat completely here, or is this really the right way to approach this.
10:35:56 <Esteth> EvanR: Thanks
10:36:01 <ksf> Esteth, try "write yourself a scheme in 48 hours"
10:36:12 <ksf> it should give some hints on how to represent environment.
10:36:16 <ksf> +s
10:36:32 <Esteth> ksf: Oooh, thanks :)
10:37:04 <avenge> Anyway, you can combine parsec like combinators with iteratee-based async IO, and the result is pretty cool.
10:37:24 <ksf> *shudder*
10:37:30 <ksf> iteratees aren't meant to backtrack.
10:37:51 <monochrom> if the tree imagines that someone is saying an argument of "don't reinvent the wheel" but no one is there to say it, does the tree hear it?
10:37:57 <avenge> Actually, while you can backtrack, you don't have to.  You can just run multiple iteratees in parallel.
10:38:05 <ksf> if you do backtrack, you could as well just do something that's non-incremental.
10:38:42 <avenge> And actually small amounts of backtracking are fine.  I have a function:
10:38:49 <avenge> ifParse :: (ChunkData t, Monad m) => Iter t m a -> (a -> Iter t m b) -> Iter t m b -> Iter t m b
10:38:52 <ksf> ...with an utter cost of state explosion if your grammar isn't regular.
10:39:00 <flippo> Nested cliches.  Nice.
10:39:21 <avenge> Using ifParse, you can implement things like folding operators that only need bounded amounts of backtracking.
10:40:02 <avenge> The key is having a continuation if the parse succeeded, so that you can stop backtracking when you execute the continuation.
10:42:56 <avenge> But anyway, I've found that in practice, my iteratees either have side effects or are part of some kind of parsing, but not both.  When there are no side effects, an alternative operator that just feeds the input to both is a good approach.
10:58:54 <djahandarie> Has anyone here gone to one of those San Francisco Haskell meetings?
10:59:16 <avenge> Where are they?  I haven't but am curious.
11:02:06 <djahandarie> At Engine Yard
11:02:42 <imc> hello everybody
11:02:50 <djahandarie> 500 Third Street, Suite 510 
11:03:07 <monochrom> "engine yard" sounds like a funny place to discuss category theory :)
11:03:25 <avenge> When are the meetings?  Is there a web page?
11:03:39 <avenge> Wondering if it's more Haskell focused or category theory focussed.
11:03:49 <djahandarie> Haskell, from what I can tell
11:03:55 <djahandarie> I haven't been before
11:04:00 <monochrom> yeah, I'm joking
11:04:08 <imc> got a problem... maybe you can help: let's say I have a class (i.e. `class Term a where ...`), then I would like to build a type like (`data ExpressionT = Expression [Term]`) how could I achieve that? is it ever possible? 
11:04:29 <djahandarie> I live on the East Coast actually, I just happen to be there one day they have a meeting :P
11:04:35 <djahandarie> http://groups.google.com/group/bahaskell/browse_thread/thread/d705f8037d317529
11:05:13 <djahandarie> I think they just have that mailing list
11:05:29 <avenge> imc:  You have to do something like this:
11:06:12 <avenge> data ExpressionT = forall t . Term t => Expression [t]
11:06:21 <imc> won-der-ful
11:06:22 <imc> :D
11:06:33 <avenge> and for that you need {-# LANGUAGE ExistentialQuantification #-} pragma at the top of your file.
11:06:47 <aristid> just curious: how do you typeset haskell code in latex?
11:06:48 <avenge> Check the ghc docs on ExistentialQuantification.
11:06:54 <imc> thank you avenge, this make me a littlebit more comfortable with haskell
11:08:07 <avenge> djahandarie: Thanks for the pointer.  Can't make it on Wednesday, but will ahve to try a different ime.
11:27:18 <ddarius> aristid: You run lhs2TeX over it.
11:28:14 <aristid> ddarius: *scratch head*
11:52:55 <Esteth> I'm following along with "Write yourself a scheme in 48 hours" as suggested to learn about IORefs, but I'm getting confused, since I cannot see a way to construct an IORef to store. I have a type Env = [(String, IORef Val)], but I can't create an IORef Val, only an IO (IORef Val)
11:55:13 <ezyang> Esteth. Yes. But then you can use fmap to make an IO Env 
11:55:58 <alexsuraci> it just means you have to create it in the IO monad
11:56:42 <Esteth> I'm confused. I can use fmap to make an IO Env, but that doesn't fit my type signiture. I can create what in the IO monad?
11:56:58 <alexsuraci> the IORef
11:57:36 <Esteth> I can do r <- newIORef ..., then modify my Env within the IO monad. Right.
11:58:06 <alexsuraci> yep, that's what you're supposed to do
11:59:19 <Phyx-> yay to thermal event
12:04:21 <Esteth> Righto, thanks for the help alexsuraci. I still don't really understand what's going on, but I guess I'll come back to it later. Perhaps understanding this is just too much to ask from me at the moment.
12:04:58 <alexsuraci> Esteth: no problem. you're certainly in the right place for asking questions. :)
12:06:57 <alexsuraci> IORefs live in the IO monad because creating and reading/writing to/from them causes side-effects, and the return value varies
12:07:06 <alexsuraci> both of which have no standing in the "pure" world
12:07:26 <Phyx-> :t pure
12:07:27 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
12:07:36 <Phyx-> @src pure Maybe
12:07:36 <lambdabot> Source not found. Wrong!  You cheating scum!
12:07:42 <Phyx-> @src Maybe pure
12:07:43 <lambdabot> pure = return
12:07:52 <Phyx-> @src [] pure
12:07:52 <lambdabot> pure = return
12:07:57 <aristid> @src Maybe return
12:07:57 <lambdabot> return              = Just
12:08:03 <aristid> @src [] return
12:08:04 <lambdabot> return x    = [x]
12:08:08 <Phyx-> @src (->a) pure
12:08:08 <lambdabot> Source not found. Wrong!  You cheating scum!
12:08:15 <aristid> @src (->) pure
12:08:15 <lambdabot> pure = const
12:08:16 <Phyx-> @src (a ->) pure
12:08:16 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:08:36 <aristid> Phyx-: just (->), even tho that's not fully logical
12:08:59 <Phyx-> aristid: shouldn't that be a kind missmatch?
12:09:08 <Phyx-> :k (->)
12:09:10 <lambdabot> ?? -> ? -> *
12:09:19 <aristid> Phyx-: yeah it's slightly illogical
12:09:31 <aristid> Phyx-: but @src is hard-coded
12:09:35 <Phyx-> ah ok
12:12:16 <Esteth> Right. IORefs cannot exist outside the IO monad? That's because the IO monad does special hidey-passey around stuff for me behind the scenes, in the same way State does?
12:13:03 <alexsuraci> Esteth: they can exist, but you can't do much with them at all (aside from test for equality and other simple things)
12:13:18 <alexsuraci> writing, creating, and reading them is all in the IO monad
12:13:32 <Esteth> If you create one inside, how can it leave?
12:13:39 <Esteth> surely a function from IO a -> a cannot exist
12:13:43 <alexsuraci> passing it to some other function (such as ==)
12:14:00 <Esteth> ahh, ok. Durr.
12:14:05 <alexsuraci> haha
12:14:21 <alexsuraci> there's unsafePerformIO for IO a -> a, but its name pretty much tells the whole story
12:14:50 <Esteth> I assume unsafePerformIO uses voodoo magic?
12:15:05 <Esteth> @src unsafePerformIO
12:15:05 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:15:25 <alexsuraci> yep.
12:15:33 <alexsuraci> It's in System.IO.Unsafe
12:16:14 <Esteth> Righto. Notes never to use unsafePerformIO
12:16:33 <alexsuraci> probably a good idea
12:17:12 <Esteth> Right then. It makes sense to have a type Env = [(String, IORef Val)], but I can only construct one inside the IO monad.
12:17:33 <Heffalump> Esteth: right, and since you can *call* pure code from IO code, you can see an IORef in pure code.
12:17:40 <alexsuraci> though it can come in handy here and there, for when you know there won't be anything nasty going on. but resist the temptation if you can, generally.
12:17:58 <EvanR> Data.Map String IORef is more efficient
12:18:16 <EvanR> and has the same interface
12:19:26 <Esteth> thanks EvanR, rolls of the tongue a bit easier, too :)
12:20:28 <EvanR> so threadDelay has a pretty bad granularity, eh?
12:20:48 <EvanR> i asked it to wait 10ms and it waits 40
12:21:00 <Esteth> Thanks for all the help. In order for my toy emulator to use this "Map String IORef" every function which needs to inspect/change the values needs to be in the IO monad?
12:21:07 <EvanR> 40 seems to be the lower bound
12:21:41 <alexsuraci> Esteth: yep
12:22:27 <alexsuraci> Esteth: for even more fun you may want to check out the State monad (and StateT)
12:23:21 <Esteth> Alexsuraci: State was where I came from to IORefs. I figured that deconstructing and reconstructing my value for the State monad between every action seemed really inefficient. Especially when what I'm doing in a processor emulator seems to behave more like IORefs anyway.
12:23:59 <Esteth> So finally: Why IO? Why not call this monad MutableValues or somtething? I don't see what it has to do with IO.
12:24:03 <EvanR> constructing and deconstructing is what you do everywhere you do pattern matching
12:24:15 <alexsuraci> even with `modify'?
12:24:45 <EvanR> Esteth: getChar :: IO Char
12:25:08 <alexsuraci> Esteth: you can still use IORefs with the state monad if that's what you mean, via StateT
12:25:38 <EvanR> StateT over IO is a hassle, use ST
12:25:40 <alexsuraci> or even Data.Map.insert for replacing values
12:26:25 <Esteth> so State Env is just as good as IO (IORef Env)?
12:26:35 <Esteth> assuming I don't want to do any fancy trickery
12:27:19 <EvanR> to get the effect of a State Env () you can use Env -> IO ()
12:27:34 <alexsuraci> generally State is good for avoiding passing around a bunch of different state variables throughout your code
12:27:38 <EvanR> er IORef Env -> IO ()
12:28:08 <alexsuraci> though this all might be a bit of an information overload
12:29:06 <Esteth> alexsuraci: It's not too bad. I'm just wondering why there seems to be 3 different monads all doing the same thing. ST, IO and State all appear to be the same
12:29:14 <Phyx-> oh jebus
12:29:14 <EvanR> they dont do the same thing
12:29:31 <alexsuraci> State does not imply IO/impurity
12:29:45 <aristid> @src State
12:29:45 <lambdabot> Source not found. Just try something else.
12:29:54 <aristid> hmm what command to use?
12:29:59 <aristid> @info State
12:29:59 <lambdabot> State
12:30:07 <aristid> lambdabot: thank you very much!
12:30:09 <alexsuraci> haha, great information there
12:30:09 <ddarius> @unmtl State s a
12:30:09 <lambdabot> s -> (a, s)
12:30:13 <hpc> newtype State s a = State {runState :: s -> (a, s)}
12:30:17 <Phyx-> @hoogle State
12:30:17 <lambdabot> module Control.Monad.State
12:30:17 <lambdabot> Test.HUnit.Base data State
12:30:17 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
12:30:23 <ddarius> @info do a; b
12:30:24 <lambdabot> a >> b
12:30:29 <Esteth> I know that State is pure, but what makes IORefs or STRefs unpure?
12:30:39 <aristid> ddarius: @info is @pl?
12:30:46 <ddarius> No, it's @undo
12:30:48 <aristid> uh no, @undo
12:30:57 <EvanR> Esteth: nothing
12:31:39 <EvanR> they are all ways to do mutable variables
12:31:49 <EvanR> (except State has only one mutable variable)
12:32:05 <hpc> State simulates mutation
12:32:14 <alexsuraci> yes
12:33:02 <hpc> ST/IORefs are mutable, so you can use them as pointers for stuff like OpenGL
12:34:04 <Esteth> ah, ok. So while ST/IORefs are actually mutable, State just simulates mutability?
12:34:12 <EvanR> its effectively the same thing
12:34:13 <hpc> yeah
12:34:44 <EvanR> if you are in IO, you can mutate IORefs, same for ST, in State you can mutate the one mutable state register
12:34:47 <hpc> you chain computations of s -> (a, s) with (>>=), which threads the new s value through to the next computation
12:35:39 <EvanR> at the programming level it all looks the same
12:35:50 <EvanR> they are different under the hood
12:36:05 <EvanR> pure/impure isnt about mutable variables
12:36:53 <hpc> pure == referentially transparent == you can change a reference to a value with the value itself
12:37:04 <EvanR> i would not equate pure with referential transparency
12:38:11 <ddarius> pure /= and =/> referential transparency and vice versa
12:39:49 <EvanR> Esteth: im a noob, so i would naively say only use IO if you need to do input and or output, imperative updates to mutable state isnt necessarily input/output so if you only need that, dont use IO
12:42:25 <EvanR> and State and ST arent the only ways to model state
12:42:51 <hpc> there's also arrows, continuations
12:42:55 <Esteth> EvanR: that's the conclusion I've come to as well. State seems to work well enough for me at the moment, and it makes my type signitures easy
12:43:09 <EvanR> i like simple type signatures ;)
12:43:25 <azaq23> @djinn (t -> a -> b) -> (t -> a) -> t -> b
12:43:25 <lambdabot> f a b c = a c (b c)
12:43:31 <azaq23> this is the s combinator
12:43:36 <azaq23> @. pl djinn (t -> a -> b) -> (t -> a) -> t -> b
12:43:37 <lambdabot> f = ap
12:43:48 <azaq23> this is only true because of the Monad instance for (-> t) right?
12:43:56 <aristid> @pl f a b c = a c (b c)
12:43:56 <lambdabot> f = ap
12:44:19 <aristid> @src (->) (<*>)
12:44:20 <lambdabot> (<*>) f g x = f x (g x)
12:46:25 <azaq23> so there is also an applicative instance for ->, ty - since that is the s combinator, maybe that has interesting theoretical implications? But this is just a shoot in the blue from me
12:47:28 <tibbe> dons: Almost done compiling the survey results!
12:49:21 <EvanR> in the sdl bindings, do i have explicitly free surfaces or will they be freed when garbage collected
12:50:32 <EvanR> doc says 'forces finalization'
12:55:30 <copumpkin> azaq23: yes, there is
12:55:52 <Phyx-> wohoo make finished
13:06:23 <Esteth> I'm finding types in the standard library I'd like to use, but don't know how to construct. How does one construct a Word8, for instance?
13:07:01 <c_wraith> Word8 is an instance of Num.  You can just use a constant.
13:07:10 <c_wraith> > 5 :: Word8
13:07:12 <lambdabot>   5
13:07:21 <alexsuraci> you can use fromIntegral too
13:07:24 <Esteth> aha, simpler than it looks :)
13:07:24 <geheimdienst> > 333 :: Word8
13:07:26 <lambdabot>   77
13:07:38 <geheimdienst> woah, silently overflows
13:07:59 <alexsuraci> dun dun duunnn
13:08:02 <geheimdienst> > (fromIntegral 333) :: Word8
13:08:04 <lambdabot>   77
13:08:05 <Esteth> > 0010000 :: Word8
13:08:06 <lambdabot>   16
13:08:16 <EvanR> Esteth: to specify a literal Word8, you probably just put the number without the type, because it will be inferred
13:08:30 <EvanR> could be useful in debugging
13:08:35 <deech> Hi all, is there a bridge between Haskell and Perl?
13:08:37 <Esteth> > 10 :: Word8
13:08:38 <lambdabot>   10
13:09:23 <alexsuraci> Esteth: I don't think 0010000 :: Word8 did what you thought it did there
13:09:28 <alexsuraci> > 10000 :: Word8
13:09:30 <lambdabot>   16
13:09:34 <EvanR> > let f :: Maybe a -> Word8; f x = 9 in f Nothing
13:09:35 <lambdabot>   9
13:10:10 <EvanR> > 0x10 :: Word8
13:10:11 <lambdabot>   16
13:12:40 <ddarius> "It is worth noting that strings, e.g. lists of characters, of length 2 over the set S are denoted S^2, and strings of length n denoted S^n.  In computer science, * often means "match anything", hence the notation S^* can be read as strings of any length n >= 0."
13:12:49 <Esteth> alexsuraci: Yeah, just figured that one out. Strange coincidence
13:13:16 <alexsuraci> haha, yep
13:14:54 <lispy> what is the name of the GHC extension that treats string literals as part of a type class?
13:15:04 <copumpkin> OverloadedStrings iirc
13:15:08 <burp> yes
13:15:11 <lispy> thanks
13:15:19 <copumpkin> I hate the name of that typeclass though :P
13:15:44 <aavogt> IsStringy
13:16:08 <Esteth> Hurrah, my State reading/writing functions work, my monads make sense! Much love to everyone for helping me out :)
13:16:52 <FunctorSalad> instance Read a => IsString a where fromString = read
13:16:54 <FunctorSalad> ;)
13:17:07 <FunctorSalad> but that's still too limited
13:19:08 <FunctorSalad> fromString x = unsafePerformIO ( system (printf "ghci >/tmp/it <<<'%s'" x) >> read <$> readFile "/tmp/it" )
13:19:55 <FunctorSalad> -- ^ Single quotes will allow arbitrary code execution. We declare this a feature.
13:20:06 <ddarius> Cognitive scientists can't do math.  This probably comes as no surprise to anyone.
13:20:40 <FunctorSalad> huh? it does come as a surprise to me
13:21:38 <FunctorSalad> I considered cognitive science but went with math... while I don't fancy myself a mathematician I "can do" it for the probably appropriate value of "can do"
13:23:48 <FunctorSalad> (as a surprise when quantified with, say, 'almost always')
13:24:22 <aristid> what is "cognitive science"?
13:25:18 <burp> about machine learning, something like that
13:25:19 <FunctorSalad> (if it wasn't clear, the point was that in a relatively close world, I would have studied cognitive science and would still have been someone with some affinity to math)
13:30:05 <Phyx-> oh you got to be kidding me, mtl doesn't compile
13:31:02 <FunctorSalad> hmm adding a source-repository: section (cabal) makes it mandatory to section the executable?
13:31:40 <FunctorSalad> would it be controversial to send in a patch adding the (IMHO very useful) source-repo: that forces Cabal>=1.6 or so?
13:32:05 <FunctorSalad> (generally speaking)
13:32:43 <Phyx-> hmm anyone know how tofix this http://phyx.pastebin.com/BNfwFv8Q
13:33:21 <hpc> Phyx-: lolwut
13:36:15 <Phyx-> yes, exactly
13:37:57 <fxr> are there any reading materials about Annotations package?
13:38:31 <ddarius> Phyx-: Your base conflicts with mtl.
13:38:42 <Phyx-> apparenlt, yeah, just figured that out
13:38:48 <Phyx-> so now i'm kinda stuck
13:40:52 <Phyx-> edited that file
13:40:57 <Phyx-> *hopes it compiles*
13:40:59 <Phyx-> yup
13:41:00 <Phyx-> worked
13:41:17 <Phyx-> such a pain though
13:46:22 <rajeshsr> is there a Haskell wrapper for mysql?
13:46:41 <danportin> :r
13:46:50 <danportin> sorry
13:47:00 <monochrom> haha
13:47:57 <winxordie> rajeshsr: http://www.haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces#Current
13:48:13 <winxordie> I think the closest is mysql
13:48:42 <winxordie> er
13:48:43 <winxordie> sqlite
13:50:05 <rajeshsr> hmm, seems there is no lib that directly works with mysql..
13:50:42 <rajeshsr> all needs ODBC!
13:51:28 <burp> rajeshsr: hdbc does directly work with mysql
13:52:33 <rajeshsr> burp: ok, let me check that. thanks
13:55:23 <burp> though the nicest interface has takusen in my opinion (but it needs odbc for mysql)
13:57:20 <lispy> Is there a way to control where ghc will write your .prof file?  or is it always in the current working directory?
13:57:57 <lispy> rajeshsr: you can use takusen with the odbc backend too
13:58:23 <rajeshsr> hmm, yeah, seen that! thanks
14:01:14 <FGYhYd> Honestly,+I'd+like+to+hear+some+commentary+from+someone+who+hasn't+been+caught+trying+to+suck+their+own+dick.
14:01:14 <FGYhYd> Honestly,+I'd+like+to+hear+some+commentary+from+someone+who+hasn't+been+caught+trying+to+suck+their+own+dick.
14:01:16 <FGYhYd> I've+done+it+again.+It+always+happens+when+I+need+to+keep+my+cool.+During+the+coffee+break+half+way+through+my+big+sales+pitch+I+went+into+the+bathroom+and+carved+"nigger"+into+my+chest+again.+God,+it+stings+so+badly.+I+think+the+blood+is+seeping+through+the+paper+towels.+I+just+hope+my+suit+jacket+covers+me+enough.+All+right,+I+need+to+get+back+into+the+real+estate+mindset+again.
14:01:19 <FGYhYd> MMMM........mmmm+i'm+abit+confusing+right+now......why+will+they+eat+their+own+poo-poo+where+it+smell+so+terrible?+Actually,+mushu+is+very+good+in+her+toilet+training.+She'll+only+pee+&+poo+on+the+newspaper+i+prepared+for+her.+But+she+eats+it+when+i'm+away!+After+i+beat+her+twice,+she+seems+to+bark+at+the+poo+first+before+she+goes+near+it.+Then+she'll+smell+it+&+play+with+it.+Then+she'll+put+everything+into+her+mouth!!!!!+Y
14:01:21 <FGYhYd> Hey+girl,+what+kind+of+irc+chatters+r+u+into?+I'm+into+pimply+overbearing+misfits,+power-mad+failures+with+an+axe+to+grind,+faceless+idlers,+'Zany'+wannabees,+creepy+pedophiles,+dickless+unix+freaks,+shit-eating+mac+users,+clueless+windoze+faggots,+'professional'+web+designers,+legally+blind+php+coders+with+herpes,+geriatric+lechers+on+social+security,+gun+nuts+on+federal+disability,+and+ambitionless+retards+working+the+nig
14:01:31 --- mode: ChanServ set +o monochrom
14:01:54 <pbBlHnLA> As+I+was+reading+that,+my+cat+rubbed+against+my+leg,+and+it+surprised+me.+But+it+felt+kind+of+good,+so+I+let+her+continue.+After+about+five+minutes+of+this,+I+was+feeling+pretty+horny,+and+from+her+erect+nipples,+I+could+tell+my+cat+was+too.+I+picked+her+up+and+put+her+in+my+lap.+She+purred+as+I+unzipped+my+pants,+revealing+my+enormous+boner.+Then,+without+warning,+she+bit+the+head+of+my+penis+with+her+sharp+fangs.+Bloo
14:01:58 --- mode: monochrom set +q *!*@gateway/web/cgi-irc/irc.wikia.com/*
14:01:58 <dqd> Uh, oh.
14:02:04 --- mode: ChanServ set +o Heffalump
14:02:17 <monochrom> temporary measure
14:02:36 <monochrom> (but oh does anyone really use irc.wikia.com?)
14:03:27 <monochrom> (P.S. I use +q because I want to see them)
14:03:36 <avenge> What is +q?
14:03:48 <monochrom> can join but cannot speak or change nick
14:04:09 <monochrom> 'q' for 'quiet'
14:04:28 <avenge> So only authenticated users can speak?  Or only users who joined before +q?
14:04:48 <danportin> :R
14:04:50 <danportin> argh
14:05:03 <monochrom> no no. if hostmask matches +q then cannot speak.
14:05:24 <avenge> Oh, I see, that's a pattern.
14:09:39 <int80_h> @seen dagit
14:09:39 <lambdabot> Unknown command, try @list
14:09:40 <preflex>  dagit was last seen on #haskell 1 year, 182 days, 19 hours, 42 minutes and 34 seconds ago, saying: It was fun chatting about Haskell and code generators, but I need to get going.  Talk to you guys later!
14:10:02 <int80_h> dangit
14:10:07 <int80_h> no dagit
14:10:23 <avenge> @seen dangit
14:10:23 <preflex>  dangit was last seen on ##c 1 year, 179 days, 19 hours, 29 minutes and 25 seconds ago, saying: Gargantua, as long as you understand the entire array can be moved by the realloc call
14:10:23 <lambdabot> Unknown command, try @list
14:10:33 <EvanR> newtypes allow you to redefine instances... is there an easy way to utilize operations already written for the previous type? (like list)
14:10:33 <danportin> What's the point of do notation? I'm learning about monads, and all it seems to do is make scoping and argument passing (in lambdas) less explicit when using bind.
14:10:34 <Heffalump> int80_h: do you mean lispy?
14:10:54 <int80_h> no, looking for the guy that goes by dagit on the mailing lists.
14:11:04 <lispy> int80_h: dagit is my last name
14:11:12 <int80_h>  lispy> int80_h: dagit is my last name [14:10] [int80_h(+i)] [3:freenode/#haskell(+CLnt)] [Act: 2]                    
14:11:21 <int80_h> oh hi lispy
14:11:24 <avenge> danportin: The point is less typing.  It is purely syntactic sugar.
14:11:32 <lispy> int80_h: what's up? :)
14:11:36 <int80_h> my name is Michael Litchard. We've been talking over e-mail about tauksen.
14:11:44 <CalmNelly> mmmm...sugar
14:11:45 <EvanR> danportin: you can reduce any haskell code to a single expression involving lambdas and let... (not sure if case is necessary)
14:11:47 <int80_h> I just wanted to touch base with you
14:12:17 <int80_h> takusen, too.
14:12:43 <lispy> int80_h: oh hey.  Sorry for taking a while to get back to you.  We're a little nervous about handing over maintainer role to someone who doesn't have a record/reputation yet.
14:13:01 <int80_h> I understand. I wonder if I could asuage that somehow.
14:13:05 <lispy> int80_h: It sounded like you haven't even uploaded anything to hackage yet
14:13:16 <int80_h> this is true
14:13:54 <int80_h> Is a trial basis possible? 
14:14:01 <lispy> int80_h: So, my advice would be: start a library, manage it for a bit and then talk to us again :)
14:14:13 <int80_h> I want what is best for the projject. If I'm not working out, that's okay.
14:14:18 <int80_h> oh gotcha
14:14:26 <int80_h> is a wrapper for a library good enough?
14:14:26 <lispy> int80_h: so I trial basis would be to get involved with takusen and start submitting patches
14:14:29 <bss03> EvanR: I think you don't need let if you have case.
14:14:46 <int80_h> I started porting libnova to haskell and decided writing a wrapper would be better
14:14:47 <EvanR> you need recursive bindings
14:14:48 <lispy> int80_h: does that make sense?
14:15:01 <lispy> int80_h: That's probably a good idea, but what is libnova?
14:15:04 <int80_h> that makes perfect sense. Is the bug tracker populated yet?
14:15:08 <avenge> bss03:  But you probably do need it for efficiency.  For example, if you implement fix without let, you can run into problems.
14:15:12 <lispy> int80_h: nope :)  But the mailing list is working now
14:15:13 <nominolo> bss03: no case forces evaluation
14:15:13 <avenge> @src fix
14:15:13 <lambdabot> fix f = let x = f x in x
14:15:25 <EvanR> how do you implement fix without let
14:15:32 <danportin> Hmm. It seems like authors introduce bind, then quickly switch to do. So it's just a stylistic choice with no advantage?
14:15:32 <lispy> int80_h: you might start by learning more about using takusen.  We still need a user manual <hint> <hint> :)
14:15:32 <copumpkin> fix f = f (fix f)
14:15:43 <fxr> @src Fix
14:15:44 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:15:45 <avenge> fix f x = f (f x)
14:15:49 <fxr> you dumbass
14:15:49 <int80_h> libnova is a library used for calculations concerning the celestal sphere. I'm interested in it for it's mapping applications. 
14:15:58 <copumpkin> fxr?
14:15:59 <EvanR> copumpkin: at the top level
14:16:10 <EvanR> copumpkin: i was talking about a single expression
14:16:10 <int80_h> I'm your guy for a use manual. Let's see what I can do.
14:16:19 <lispy> int80_h: cool!
14:16:31 <EvanR> in order to define fix like that inside the main expression you need let
14:16:36 <fxr> copumpkin: sorry not for anybody except the lambdabot
14:16:43 <copumpkin> :)
14:16:52 <EvanR> alternatively imagine a big where for a module
14:16:54 <int80_h> lispy. I'd like to talk to you about a table of contents. Do you have any thoughts on what that would look like?
14:17:07 <lispy> int80_h: let's start a new channel, #takusen (if it's not taken)
14:17:12 <EvanR> i need help ... :(
14:17:14 <int80_h> yay!
14:17:26 <copumpkin> halp!
14:17:28 <copumpkin> halp halp!
14:19:18 <monochrom> help is overrated.
14:19:58 <avenge> EvanR: Sorry, I guess I meant:  fix f = f (fix f)
14:20:24 <EvanR> yeah i count that as let (its not a lambda)
14:20:48 <EvanR> and if i remember correctly you cant do it with just a lambda in typed LC
14:21:03 <avenge> EvanR: But I think the let-free definition will blow out your stack in practice.
14:21:06 <EvanR> and none of this is helping danportin 
14:21:22 <avenge> EvanR: While let causes a slot to be heap allocated.
14:21:44 <EvanR> avenge: i thought you were saying you could do it with a case
14:22:01 <Saizan> you can do it with only lambdas and newtype constructors :)
14:22:09 <Saizan> it'll make the inliner loop though.
14:22:17 <danportin> It's fine - because I can just translate do notation into bind. It's just nice to see the guts of your code nicely mapped out.
14:22:19 <avenge> Of course, like with the Y combinator.
14:22:46 <EvanR> ?
14:22:47 <azaq23> @danportin: since monads are used to represent every IO action and generally "more stateful" in which the sequence of execution of the operations is important, it's naturally to group them like you would in any imperative language. Monads are the application of a theoretical concept which is in itself pure (though may use implementation details which aren't), using >>= etc everytime would be quite tiresome. So there is do notation to emulate 
14:22:47 <lambdabot> Unknown command, try @list
14:23:49 <dolio> @b52s
14:23:49 <lambdabot> It's a dreary downtown day, but at the end of my 40 foot leash is my little friend quiche.
14:24:08 <azaq23> danportin: try the @do and @undo commands of lambdabot, they are quite helpful if you are just learning about monads, you can message lambdabot directly
14:24:32 <azaq23> @do x >>= f >> g
14:24:32 <lambdabot> do { do { a <- x; f a}; g}
14:25:14 <nominolo> the associativity of >>= seems wrong
14:25:22 <danportin> So @azaq23, the purpose of the do notation is to take a model of the functions (computations) you want performed and structure them like a sequence of commands, as opposed to a pure function?
14:25:35 <danportin> sorry, *structure it
14:25:37 <avenge> nominolo: why?
14:25:51 <nominolo> @info (>>=)
14:25:52 <lambdabot> (>>=)
14:25:52 <avenge> > :i (>>=)
14:25:54 <lambdabot>   <no location info>: parse error on input `:'
14:25:57 <Saizan> ?type \x f g -> x >>= f >> g
14:25:58 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => m a -> (a -> m a1) -> m b -> m b
14:25:59 <EvanR> >>= isnt associative
14:26:06 <dolio> That's (x >>= f) >> g
14:26:16 <EvanR> because the types dont match up
14:26:19 <avenge> infixl 1 >>=
14:26:35 <EvanR> :t (>>)
14:26:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:26:41 <EvanR> neither is that ;)
14:27:02 <nominolo> EvanR: I mean operator associativity
14:27:09 <Saizan> EvanR: they are both infixl
14:27:27 <dolio> (>>) is associative.
14:27:37 <dolio> (m >> n) >> o = m >> (n >> o)
14:27:40 <nominolo> :t \a b c -> a >>= (b >>= c)
14:27:41 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => m a -> (a -> a1) -> (a1 -> a -> m b) -> m b
14:28:27 <monadic_kid> danportin: they are just pure syntatic sugar, they get translated to return/bind and lambdas. When you have a complicated monadic expression the explicit way can be hard to follow, you'll have lambdas that "bind" values that spread across a number of lexcial scopes at that point do-notation is more readable
14:28:27 <nominolo> :t \a b c -> (a >>= b) >>= c
14:28:28 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => m a -> (a -> m a1) -> (a1 -> m b) -> m b
14:29:21 <nominolo> ok.  the problem is that usually a >>= (\x -> b x >>= c) is more efficient than (a >>= b) >>= c
14:29:33 <azaq23> danportin: Basically, yes - A Monad in itself it just like any other typeclass you can declare, but their specific structure allows us to think about them as "sequencers" of functions - the underlying datatype may be anything for which such a notion makes sense, and IO is just one of them which happens to have a very valid notion of sequencing: side effectful code
14:30:26 <nominolo> in fact it "oversequences"
14:30:57 <nominolo> (for some use cases)
14:31:11 <dolio> I don't think sequencing is the best way to describe it.
14:31:56 <nominolo> dolio: well, IO adds a fake value to turn a control dependency into a data dependency
14:32:16 <dolio> GHC does.
14:32:17 <nominolo> so, for IO, sequencing seems like the right term
14:32:49 <danportin> Interesting, @azaq23 $ monadickid. But the sequencing happens via the particular implementation of (>>=), if I understand correctly. Instead of sequencing, why not think of Monads as a type class that passes values through the implementation of (>>=) in an instance declaration? It seems much easier to think of lets/cases/lambdas working on functions and values, when trying to understand how 
14:32:50 <danportin> (>>=) is working, than operations/computations. But maybe that's because I don't have an imperative background.
14:33:00 <c_wraith> I really think the most important thing about monads is that they compose cleanly.  They let you compose some sort of monadic value with a function from a non-monadic value to another value in the same monad.
14:33:07 <nominolo> however, I tend to see it simply as an abstraction to hide the plumbing
14:33:16 <c_wraith> In IO, that composition operation is sequencing.
14:33:30 <c_wraith> But in general, the composition operator's meaning is domain-specific
14:33:31 <EvanR> "programmable semicolon"
14:35:13 <dolio> It is probably more generally correct to think of (>>=) as a type of substitution in an expression tree.
14:35:20 <danportin> Yes, @nominolo, which is common in Haskell, since reasoning about your program tends to work better, when a complex operation is being performed over and over, then abstract it into a single function.
14:35:34 <bss03> > sort $ do { x <- [1,4,9]; [sqrt x, -sqrt x]; }
14:35:36 <lambdabot>   [-3.0,-2.0,-1.0,1.0,2.0,3.0]
14:36:05 <bss03> > sort $ do { x <- [1,4,9]; [sqrt x, -sqrt x]; truncate }
14:36:07 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a1 -> b'
14:36:17 <dolio> 'm a' is an expression in some embedded, algebraic language, built over the type 'a'.
14:37:00 <bss03> > sort $ do { x <- [1,4,9]; y <- [sqrt x, -sqrt x]; return $ truncate y}
14:37:02 <lambdabot>   [-3,-2,-1,1,2,3]
14:37:03 <dolio> And (>>=) takes a function that for an 'a', yields a new expression 'm b', and builds a new expression by grafting in the expressions for each 'variable'.
14:37:42 <EvanR> thats true for any function application
14:37:43 <nominolo> > sort [ truncate y | x <- [1,4,9], y <- [sqrt x, -sqrt x] ]
14:37:44 <lambdabot>   [-3,-2,-1,1,2,3]
14:37:53 <EvanR> or let expression
14:37:55 <nominolo> prettier ;)
14:38:10 <bss03> nominolo: I was trying to show (<<=) not being sequencing.
14:38:16 <bss03> > do { x <- [1,4,9]; y <- [sqrt x, -sqrt x]; return $ truncate y}
14:38:17 <lambdabot>   [1,-1,2,-2,3,-3]
14:38:22 <EvanR> :t (<<=)
14:38:23 <lambdabot> Not in scope: `<<='
14:38:24 <danportin> Could you jsut define (>>=) in terms of fmap then?
14:38:30 <EvanR> :t (=<<)
14:38:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:38:36 <nominolo> bss03: yeah, i know.
14:38:46 <c_wraith> daanportin, you need fmap and join.
14:38:54 <dolio> > (undefined >> id) 5
14:38:55 <c_wraith> err, danportin, sorry for the horrible spelling :)
14:38:56 <lambdabot>   5
14:39:32 <nominolo> where join a.k.a. concatMap
14:39:36 <nominolo> ah, no
14:39:38 <nominolo> concat
14:39:38 <azaq23> danportin: yes, that is possible - f >>= x = join $ fmap f x
14:41:04 <azaq23> danportin: There are some articles on from the "A Neighboorhood of Infinity" blog at sigfpe.blogspot.com about that perspective
14:41:20 <Berengal> Does Map have an Arbitrary instance?
14:41:28 <danportin> Okay, that's interesting. So you take a function g :: a -> b and a functor f, apply g to f, then collapse the result?
14:41:30 <lispy> Okay.  New irc channel.  Takusen now has a channel (#takusen)  come join us if you want to talk about using or improving takusen!
14:43:12 <nominolo> Berengal: does it have a Functor instance?
14:43:49 <nominolo> oh, wait, nevermind.
14:44:22 <danportin> Hmm. That would seem to make lists and trees, as opposed to Maybe and IO, into perfect examples of monads.
14:44:27 <azaq23> danportion: sorry, screwed up the variables - x >>= f = join $ fmap f x, of course. x is of type m a, fmap f is then m a -> m (m b) and join takes a m (m t) onto m t
14:44:32 <azaq23> so it's the same
14:44:48 <azaq23> for the list monad, join = concat and, well, fmap = map
14:44:51 <azaq23> @type concat
14:44:52 <lambdabot> forall a. [[a]] -> [a]
14:45:14 <azaq23> > concat $ map (\x -> [x * 2]) [1 .. 10]
14:45:15 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
14:45:24 <EvanR> > join [[1],[2],[3]]
14:45:25 <lambdabot>   [1,2,3]
14:45:31 <azaq23> > do { x <- [1 .. 10]; return $ x * 2}
14:45:33 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
14:45:42 <EvanR> @src Applicative
14:45:42 <lambdabot> class Functor f => Applicative f where
14:45:42 <lambdabot>     pure  :: a -> f a
14:45:42 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
14:45:56 <EvanR> @src Functor
14:45:56 <lambdabot> class  Functor f  where
14:45:56 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:46:00 <bss03> fmap (*2) # [1..10]
14:46:08 <bss03> > fmap (*2) $ [1..10]
14:46:10 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
14:46:23 <bss03> > liftM (*2) $ [1..10]
14:46:24 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
14:46:31 <bss03> :t fmap
14:46:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:46:33 <bss03> :t liftM
14:46:34 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:47:19 <bss03> (*) <$> [1,2,3] <*> [4,5,6]
14:47:24 <danportin> Yes, that makes sense azaq.
14:47:34 <bss03> > (*) <$> [1,2,3] <*> [4,5,6]
14:47:35 <lambdabot>   [4,5,6,8,10,12,12,15,18]
14:48:42 <ozamosi> How can I convert a lazy bytestring to a non-lazy one? Google fails me on this one.
14:49:29 <avenge> convert string = S.concat $ L.toChunks string
14:49:42 <danportin> Interesting. It's too bad most books don't take this approach. As opposed to throwing >>= and do notation at you, explain it in terms of thigns we already know, fmap and join.
14:49:56 <EvanR> who already knew ;)
14:49:58 <avenge> ozamosi: A lazy bytestring is just a linked list of strict ones.
14:49:59 <EvanR> i didnt
14:50:06 <c_wraith> *who* already knows fmap and join?
14:50:11 <c_wraith> Admittedly, fmap is simple.
14:50:16 <dolio> Why do you already know those? join comes from monads.
14:50:22 <Phantom_Hoover> @pl m >> n = m >>= \_ -> n
14:50:22 <lambdabot> (line 1, column 8):
14:50:22 <lambdabot> unexpected "="
14:50:22 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
14:50:30 <c_wraith> But join...  That's just as complicated as >>=, really
14:50:30 <Phantom_Hoover> @pl m >>= \_ -> n
14:50:30 <lambdabot> m >> n
14:50:42 <EvanR> :t join
14:50:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:50:58 <hpc> :t ><
14:50:59 <lambdabot> parse error on input `><'
14:51:03 <hpc> :t (><)
14:51:04 <lambdabot> forall a. (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
14:51:07 <ozamosi> avenge: ah, there's a heading "Introducing and eliminating ByteStrings" in the haddock. I should have found that :/ Thank you!
14:51:45 <danportin> Ah, sorry - by join I meant concat, if we were given lists as an example of a monad
14:51:58 <danportin> (As opposed to IO, e.g.)
14:52:57 <Berengal> The trouble with monads is that IO and Lists, >>= and concatMap, are all the same
14:53:01 <ddarius> c_wraith: There are, actually, many ways in which join is simpler.
14:53:50 <danportin> Yeah, but we /use/ concat, concatMap, and map, before we learn join, >>=, and fmap.
14:54:26 <dolio> If you know concatMap, then you know (>>=), same as if you know concat, you know join.
14:54:43 <Berengal> We're also used to sequential programming from other languages
14:54:48 <Berengal> The problem is unifying these
14:55:01 <Berengal> That's a conceptually hard leap to make
14:55:34 <danportin> Yeah, that's reasonable. I've never programmed in another language before, so I don't have that problem (advantage).
14:56:00 <Berengal> You're probably better off for it
14:56:15 <Berengal> At least in the first stages
14:57:14 <danportin> IT's up in the air
14:57:19 <EvanR> must be nice
14:57:21 <danportin> Thanks for your help, everyone.
14:58:49 <monadic_kid> danportin: I can now see why you couldn't understand the point of do-notation if you never used any other langauge :)
14:59:26 <monadic_kid> danportin: people from imperative langauges tend to be more comfortable wtih do-notation at first
15:00:38 <danportin> Yeah, I can see that. I wonder if using do notation gets people comfortable using monads, because you can declare your monad instance and jump in.
15:01:02 <EvanR> yeah right no one understands how to write monad instances ;)
15:01:06 <azaq23> (And by that he means that they run away screaming from all that weird join fmap >>= lambda stuff)
15:01:51 <danportin> Well, okay @EvanR, then use the monad instance from their tutorial / textbook :p
15:02:19 <EvanR> i dont know if writing custom monad instances is the first thing on the learn you a haskell plan
15:02:39 <EvanR> there are already several useful instances for the typical purposes
15:03:16 <EvanR> but maybe join and fmap would make instances easier to design/understand
15:03:59 <danportin> Well, I mean modify one, or implement a simple definition of >>=, or something like that. Something like what Wadler does - take an instance with lots of case exprssions and turn the case expressions into a >>=
15:04:03 <EvanR> my problem is identifying situations that are actually monadic
15:04:08 <hpc> :t (fmap >>=)
15:04:09 <lambdabot> forall a b (f :: * -> *) b1. (Functor f) => ((f a -> f b) -> (a -> b) -> b1) -> (a -> b) -> b1
15:04:39 <hpc> the layout of those parens scares me
15:05:44 <ddarius> hpc: That's because it is a third order function.
15:05:55 <danportin> Well if you know the monad laws, then you can just think of trivial instances, e.g., the identity monad, or an exception handler, or something.
15:06:03 <hpc> additionally, why is there no monad constraint?
15:06:19 <ddarius> hpc: It's using the (a->) monad.
15:06:21 <hpc> oh there is... (-> e(
15:06:23 <hpc> yeah
15:06:35 <ddarius> @google okasaki sixth order
15:06:36 <lambdabot> http://www.eecs.usma.edu/webs/people/okasaki/pubs.html
15:06:37 <lambdabot> Title: Chris Okasaki's Publications
15:06:39 <EvanR> danportin: well when solving a real problem, you dont get to decide what you are solving ;)
15:07:02 <danportin> Haha, yeah. I concede :p
15:07:04 <EvanR> so it doesnt matter that theres some non trivial monad if its non applicable
15:09:09 <ddarius> Most monads that you would want can be built out of combinations of the provided monad transformers.  Most other monads written about are just different representations of one of those.  Occassionally a genuinely different monad comes about.
15:09:57 <avenge> ddarius: This doesn't match my experience.
15:10:18 <avenge> ddarius: Most of the draw of Haskell for me is being able to define my own Monad transformers that do things I can't do in other languages.
15:11:06 <EvanR> hehe the "jQuery monad" ;)
15:11:08 <ddarius> avenge: So what's a genuinely new monad transformer you've designed that isn't a combination/restriction of the existing monad transformers or just a different representation of such a combination?
15:11:58 <avenge> ddarius: Well, two examples are a labeled IO monad, that enforces information flow control on untrusted code, and an iteratee-like monad that does asynchronous IO and parsing.
15:13:29 <avenge> ddarius: It's really all about being able to "redefine the semicolon" to enforce some policy or make some optimization transparent.
15:14:07 <ddarius> Enforcing some policy would fall under "restriction."
15:15:47 <avenge> I guess, but if by existing monad transformers you mean just gluing together pieces from mtl, then I would argue that one sometimes needs to go to a lower-level of abstraction and roll your own.
15:16:45 <ddarius> avenge: That latter sounds like a different representation unless some new feature is added.
15:17:46 <Phyx-> meh, i hate browser checks on websites...
15:17:48 <avenge> I mean I guess I don't know what you mean specifically by different representation.
15:18:01 <Phyx-> losers... it's not like your identification string isn't easy to change
15:19:13 <ddarius> avenge: A different representation would provide approximately the same interface (or a subinterface) but a different implementation.  E.g. many monads are continuation based versions of more data-oriented implementations.
15:19:21 <avenge> ddarius: I guess my point is that the specific code in mtl isn't necessarily useful for doing these things that I want to do, and the resulting implementation ends up looking pretty different and requiring a different way of thinking.  But I'm sure that on some level you will find ideas that also appear in mtl.
15:20:07 <Cazzzzzzzzzzzo21> haskell platform info tutorial: http://www.youtube.com/watch?v=OBB8zTdY4NU
15:20:09 <Cazzzzzzzzzzzo21> I 've madet it
15:20:10 <Cazzzzzzzzzzzo21> :P
15:20:49 <avenge> ddarius: Okay, then I would say that my iteratee-like library provides a fundamentally different interface from, say, the IO monad and lazy IO, because it provides detailed error reporting in a way that is just not possible with lazy IO.
15:22:11 <avenge> ddarius: Do I use ideas from ContT?  Sure.  But you couldn't do what I'm doing with ContT.
15:22:20 <ddarius> avenge: The issue isn't whether your example is different from some other example, but whether I could implement it as a stack of monad transformers.  For example, parsing is quite different from most monads but is more or less just StateT [].
15:22:56 <EvanR> and Random
15:23:16 <EvanR> State StdGen
15:23:50 <avenge> ddarius: Well, if I implement a monad transformer, it is trivially implementable from a stack of monad transformers, namely itself.
15:24:12 <avenge> ddarius: I'm just saying that you can get a lot of mileage from implementing monad transformers other than those in mtl.
15:24:46 <ddarius> avenge: Again, I said out of the "provided" ones, not out of one that you have to custom design.  "Provided" meaning, more or less, in the MTL.
15:25:27 <ddarius> My point is that is rather rare that you need a monad transformer that is not in MTL or buildable from what is in MTL.  I.e. you rarely need to create a monad "from scratch."
15:25:29 <avenge> ddarius: Oh, then maybe I don't understand your point.  You are saying the mtl is mostly a combination of transformers in...?
15:26:14 <avenge> ddarius:  Right, this last point is where I'm taking exception.  I usually have to build my monads and transformers from scratch, without benefit of the MTL.  But I try to play nice with the MTL, so I do use the MonadTrans class, for instance.
15:26:40 <Saizan> avenge: he is saying that most other monads in use are just a combination of transformers in mtl, or could be.
15:26:55 --- mode: monochrom set +b *!~USCHostin@*
15:27:21 <avenge> Saizan:  Right, and I'm saying that's not quite right.  Iteratee is a good example of a monad that is not just a combination of transformers in the mtl.
15:27:38 <Saizan> avenge: do you have other?
15:27:40 --- mode: monochrom set -q *!*@gateway/web/cgi-irc/irc.wikia.com/*
15:27:45 --- mode: monochrom set -o monochrom
15:27:55 <Saizan> *others
15:28:07 <ddarius> avenge: That may be a case, I never said that there aren't any examples.  Further, are you sure it is not at all representable as a stack of monad transformers from MTL?
15:28:13 <avenge> There is a set of useful monads.  There is a set of monads you can create by combining things from the mtl.  I'm just saying the former is a strict superset of the latter.
15:28:59 <avenge> ddarius: Positive.
15:30:04 <ddarius> avenge: What is the definition?
15:30:26 <avenge> ddarius:  Definition of?
15:30:36 <ddarius> Your "iteratee-like" monad.
15:32:21 <avenge> ddarius: Not sure how much sense it will make without context, but here's the definition:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28726#a28726
15:32:48 <ddarius> What's the definition of Iter, the data or newtype declaration?
15:33:00 <hpc> @src Iter
15:33:01 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:33:02 <avenge> Full source here: http://www.scs.stanford.edu/~dm/iterIO/src/Data-IterIO-Base.html
15:40:50 <obfuscated> Hello, I've read this http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell#Extending_the_CGI_monad_with_monad_transformers
15:40:51 <obfuscated> but I don't know how to run the new monad with/inside fastcgi, does someone knows what I've to do?
15:46:28 <Saizan> well, you've to write something like runApp there
15:50:25 <obfuscated> Saizan: and then I've to do "main = runApp" ?
15:51:34 <Saizan> main = runApp <the action in the App monad>
15:52:52 <Saizan> just like before you add to do "main = runCGI $ handleErrors cgiMain"
15:53:15 <ramb0> Hi
15:53:25 <Saizan> runApp is taking the role of runCGI there
15:53:44 <Phyx-> @hoogle a -> b
15:53:44 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:53:44 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
15:53:44 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
15:54:02 <ramb0> I have a very simple question. In haskell.. Is there a way to have something like "Return" of C or Python ?
15:54:03 <Phyx-> @type cast
15:54:05 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
15:54:07 <Zeiris> Has anyone had experience with the MMap package on Windows? I'm getting segfaults with the ByteString interface o.O
15:54:13 <Phyx-> @type fromJust . cast
15:54:15 <lambdabot> forall a a1. (Typeable a1, Typeable a) => a1 -> a
15:54:19 <Phyx-> better
15:54:32 <monochrom> there is no need for "return" of c or python
15:54:47 <ramb0> I know, but in this particular case, yes
15:54:52 <Zeiris> The Maybe monad, and if statements in general.
15:55:01 <Zeiris> Have you got a paste?
15:55:07 <monochrom> there is no particular case shown
15:55:51 <ramb0> I say.. Something like: "If this function return X instead of Y for the value Z, return 2"
15:56:09 <monochrom> and if not?
15:56:19 <ramb0> Continue until the end of the program
15:56:33 <Zeiris> case f Z of Y -> do_stuff ; Z -> 2
15:56:56 <monochrom> if this_function z == x then 2 else ...
15:57:56 <hpc> you can't "early exit" from a monadic action because there's nothing to exit from
15:58:22 <Zeiris> Unless you're in the Maybe monad, in which case you can kindof.
15:58:24 <ramb0> I don't want to early exit
15:58:38 <copumpkin> or the continuation monad (transformer)
15:58:38 <monochrom> if you must think in term of "exit", as long as you don't recurse, you already "exit".
15:58:42 <ramb0> I need the exit code be different to 0, so the program knows there was an error
15:58:44 <copumpkin> and you have a nice continuation to jump to
15:58:54 <hpc> the only thing distinguishing c return from a haskell return value is early exit
15:59:13 <Zeiris> ramb0, is this inside a monad with do-syntax, or not?
15:59:37 <ramb0> I don't know what monads are Zeiris :(. Im just a noob with haskell
15:59:39 <monochrom> exit code is in the module System.Exit
16:00:03 <ramb0> Thanks monochrom I wanted to know if it was possible!
16:00:08 <monochrom> in any case we really enjoy talking vaguely like this
16:00:18 <monochrom> vaguely and philosophically
16:04:27 <monochrom> System.Exit is more like exit() rather than return.
16:05:11 <monochrom> people shouldn't "discuss" vaguely in the name of "concept". but if they do, at least carefully choose the right concept.
16:05:43 <ramb0> As I said to Zeiris in private, the only thing I needed is a way to tell the system that the program failed in some place. 
16:06:22 <monochrom> Yeah, so Zeiris knows in private. Good for all of us.
16:06:36 <EvanR> :t System.exit
16:06:37 <lambdabot> Not in scope: `System.exit'
16:06:41 <EvanR> :t System.Exit.exit
16:06:42 <lambdabot> Not in scope: `System.Exit.exit'
16:06:48 <Zeiris> @hoogle exit
16:06:49 <lambdabot> module System.Exit
16:06:49 <lambdabot> System.Exit data ExitCode
16:06:49 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
16:07:00 <hpc> exitWith ExitSuccess
16:07:23 <hpc> exitWith ExitFail 2 -- iirc
16:08:39 <ramb0> Hey, Thanks for the help! :)
16:12:32 <EvanR> http://hackage.haskell.org/package/spacepart-0.1.0.0 im looking at this to do more efficient rectangular collision detections
16:12:48 <EvanR> it seems accord to the interface, i would build a new tree each time something moves
16:13:10 <EvanR> is that unheard of, or normal
16:15:28 <Zeiris> Is there a way to group movements together, and modify the tree once per frame?
16:15:50 <EvanR> well its better if everything has moved since you must rebuild the entire tree anyway
16:16:02 <EvanR> once per game step
16:21:11 <EvanR> hmm seems to support only square boundaries
16:23:11 <luite> has anyone here already found a flaw in the latest P /= NP proof? :)
16:26:22 * hackagebot bird 0.0.15 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.15 (MattParker)
16:32:24 * hackagebot bird 0.0.16 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.16 (MattParker)
16:38:05 <itegebo> Does anyone know how I might get GHC to tell *how* it inferred a type?
16:39:51 <dark> itegebo, you mean, tell the whole path of the algorithm?
16:40:08 <dark> it might be huge
16:40:24 <dark> and not necessarily readable
16:40:37 <kmc> it would be a neat thing to have
16:40:40 <kmc> i don't think GHC has it
16:40:52 <itegebo> okay, that makes sense
16:40:55 <robryk1> why should it be huge?
16:41:06 <dark> not sure o.o
16:41:10 <robryk1> you start with equations, roughly linear in size of program
16:41:20 <robryk1> and then you substitute them, right?
16:41:25 <kmc> you could have it print the set of equations before each unification step
16:42:01 <robryk1> or, if we want to debug failure, the false equation and reasoning that it used to arrive at it
16:42:27 <benmachine> I had an idea to write a step-by-step typechecker
16:42:35 <benmachine> but I'm not sure how effective it would be
16:42:45 <robryk1> someone had a blog post with an idea for something like it
16:43:07 <robryk1> somehting that would, for every subexpression, give immediate reason for its type
16:43:13 <robryk1> whereever possible
16:44:32 <msieradzki> uhm how do I reference haskell code from C
16:44:58 <dark> msieradzki, http://www.haskell.org/haskellwiki/FFI_Introduction ?
16:45:00 <msieradzki> let's say that I want to limit myself to small piece of code that I can pack in some weird C-friendly interface
16:45:22 <msieradzki> hmm I didn't expect to find C -> haskell there thx
16:45:45 <dark> hm
16:45:51 <msieradzki> actually there are no examples
16:45:52 <msieradzki> for it
16:46:14 * dark knows nothing about haskell's ffi
16:47:10 <dark> msieradzki, http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Calling_Haskell_from_C
16:48:16 <dark> http://en.wikibooks.org/wiki/Haskell/FFI#Calling_Haskell_from_C too
16:48:52 <Phyx-> has anyone ever benchmarked the overhead of FFI?
16:49:17 <dark> ps: that haskell book at wikibooks is very nice
16:49:38 <dark> i understood the curry-howard isomorphism there
16:55:52 <drhodes> pretty big news, someone at HP is claiming to have proven N != NP: http://www.scribd.com/doc/35539144/pnp12pt
16:57:30 * hackagebot libxml-sax 0.5.1 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.5.1 (JohnMillikin)
16:59:33 <kmc> fuck scribd
16:59:42 <kmc> anyone have a pdf download
16:59:51 <luite> yes, one moment, I had one
16:59:54 <mornfall> Whats N?
17:00:02 <drhodes> oops :)
17:00:20 <luite> http://dl.dropbox.com/u/33127/35539144-pnp12pt.pdf
17:00:36 <kmc> thanks
17:00:48 <mornfall> 100 pages? looks like BS : - ) : - P
17:01:11 <luite> the first 20 pages are pretty readable at least :p
17:01:30 <luite> it does look like a serious attempt
17:03:21 <luite> but I haven't read it all...
17:05:13 <CalmNelly> @vixen Do muthaf***en snakes on a muthaf***en plane scare you?
17:05:14 <lambdabot> me?
17:05:28 <CalmNelly> @vixen Yes!
17:05:28 <lambdabot> am I the only person you're talking to?
17:07:44 <hpc> @vixen Yes!
17:07:45 <lambdabot> My sister likes Yahoo better. Her screenname is FoxxyGurl83. If you have yahoo you should message her, she's just as pretty as me :)
17:09:40 <azaq23> @girl19
17:09:40 <lambdabot> is this a help channel for hackers-beginners?
17:09:53 <kmc> @protontorpedo
17:09:53 <lambdabot> check otu squeak seems dope
17:12:55 <kmc> @protontorpedo
17:12:55 <lambdabot> no I cant read online for long my eyes get fuzzy
17:14:02 <hpc> how many of these things does lambdabot have?
17:15:01 <benmachine> plenty.
17:18:23 <aristid> @vixen Yes!
17:18:23 <lambdabot> ever feel like you're going around in circles?
17:18:27 <aristid> @vixen Yes!
17:18:27 <lambdabot> i understand
17:19:49 <monochrom> lambdabot++
17:22:28 <dolio> @b521
17:22:28 <lambdabot> His ear lobe fell in the deep. Someone reached in and grabbed it. It was a rock lobster!
17:25:10 <lispy> can you inline functions that are part of a type class?
17:25:23 <dolio> Yes.
17:25:29 <lispy> class Foo a where foo :: Foo a {-# INLINE foo #-}
17:25:38 <dolio> Put it on the instance.
17:25:52 <dolio> Although, if you have a default, put it there, too, I think.
17:26:08 <lispy> instance Foo Bar where foo = ... {-# INLINE foo #-} ?
17:26:13 <dolio> I think so.
17:26:36 <Phyx-> lispy: hiya
17:26:41 <lispy> Phyx-: yo
17:27:25 <Phyx-> wassup?
17:27:41 <lispy> just trying to optimize the darcs parser now that I refactored it
17:28:12 <Phyx-> cool, any progress?
17:28:33 <lispy> I think so
17:28:46 <lispy> Just playing with inlining now
17:29:41 <Phyx-> hmm I have an type HList = [forall a. Typeable a => Maybe a]
17:29:54 <Phyx-> shouldn't I be able to do [undefined :: Maybe PostTcType]
17:29:55 <Phyx-> then?
17:30:04 <Saizan> no
17:30:25 <Phyx-> no?
17:30:27 <Saizan> you'd want "type HList = [exists a. Typeable a => Maybe a]" to be able to do that
17:30:42 <Phyx-> aha
17:31:05 <Saizan> but "exists" doesn't exist in haskell
17:31:37 <Phyx-> hahahh
17:31:50 <Phyx-> and I was just wondering why ghc was complaning
17:31:54 <Phyx-> complaining*
17:31:59 <Philonous> Dear lord. My application of merely 150 lines produces a 23MB executable. 
17:32:28 <Saizan> but data Foo where Foo :: Typeable a => Maybe a -> Foo, type HList = [Foo] is what you wanted
17:32:34 <Phyx-> Philonous: you import big things
17:32:36 <lispy> Philonous: impressive
17:32:36 <dolio> Unthinkable! Does it use several kilobyte of memory as wel!?
17:32:38 <Saizan> except that you need to add the Foo constructor
17:32:59 <dolio> Wow, I screwed up the typing on that sentence.
17:33:03 <Phyx-> Saizan: that's ok, I can like with that
17:33:15 <Phyx-> Saizan: does it need to be a GADT?
17:33:31 <Phyx-> Philonous: for instance, the ghc api adds 20+mb
17:33:47 <Phyx-> Philonous: just strip it, it'll shave off atleast 50%
17:33:53 <Philonous> Phyx-: That has to be it. I use hint.
17:34:08 <Saizan> Phyx-: you can also write it like "data Foo = forall a. Typeable a => Foo (Maybe a)" but i find the GADT way clearer
17:34:46 <Saizan> you need ExistentialQuantification 
17:35:07 <Phyx-> ok, I'll use the GADT way
17:35:12 <Philonous> Phyx-: No, didn't do anything. But anyway. Don't tell me ghc just statically links everything into the executable?
17:35:43 <dolio> It has some dynamic linking support now, but it's not very old.
17:36:02 <Phyx-> Philonous: yup
17:36:11 * Philonous cringes
17:36:14 <Phyx-> Philonous: adding -optl-Wl,-s as an argument to GHC didn't do anything?
17:36:49 <Phyx-> dolio: the problem with the dynamic linking is that you have had to compile every lib with that support, which isn't the default
17:37:32 <roconnor> http://news.ycombinantor.com/item?id=1566704 -- apparenly some people on Hacker News don't appreciate our hylomorphisms
17:37:56 <copumpkin> combinantor
17:38:00 <dolio> Are they adamant advocates of total programming languages?
17:38:04 <copumpkin> http://news.ycombinator.com/item?id=1566704
17:38:09 <copumpkin> lol
17:38:20 <Adamant> they are not Adamant.
17:38:26 <Adamant> :P
17:38:41 * hackagebot dbus-core 0.8.4 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.8.4 (JohnMillikin)
17:38:43 <Philonous> Phyx-: Nope, still is 23MB 
17:38:58 <Phyx-> Philonous: that command trims my dlls by alot usually. that and upx brings me from 48mb to 4.8mb with no overhead usually
17:39:07 <Veinor> I wonder if there are any multiset packages
17:39:14 <Veinor> yes there are
17:39:16 <Phyx-> Philonous: are you installing with cabal? which I think strips by default
17:39:41 <Phyx-> Philonous: you could just pack it with upx, no runtime overhead
17:39:41 <Philonous> Phyx-: Yes, I use cabal
17:39:49 <Phyx-> ah, then it's already stripped
17:39:58 <roconnor> copumpkin: I thought they hylomorphism solution was brilliant
17:39:59 <Phyx-> yes, without cabal it would have been bigger ^_^
17:40:02 <roconnor> thought the
17:40:26 <Phyx-> Philonous: if you use a packer, like upx it'll further trim it to about 20% of the original size
17:41:01 <Philonous> Phyx-: Well, considering it's has a haskell interpreter built int... But still. 23MB for for some glue between libraries is bonkers.
17:41:28 <ddarius> dark: You didn't happen to be on #haskell like eight years ago, did you?
17:42:06 <Veinor> yeah, ghc executables tend to be annoyingly large :/
17:42:11 <Phyx-> Philonous: I would agree usually, but if you're using the GHC api, you still need GHC around for it to work anyway. so
17:42:53 <Phyx-> Philonous: try http://upx.sourceforge.net/
17:44:14 <dolio> roconnor: Haskell is bad because we don't write our loops manually, I guess.
17:44:44 <dolio> Isn't ycombinator Paul Graham's site?
17:44:46 <SubStack> I like it when the computer writes my code for me.
17:45:01 <roconnor> the hylomorphism divided out the producer and consumer parts of the code so nicely.  Code that would be intertwinded in the traditional solution.
17:45:08 <dolio> Where they use powerful Lisp code to build startups and stuff?
17:45:46 <Philonous> Phyx-: Thanks. I'll give it a shot. But the executable would still be huge. Just not _as_ huge. 
17:46:22 <dolio> I like the academic stuff from the 60s, but not the academic stuff from the 80s and 90s.
17:46:51 <Phyx-> Philonous: it would become manageable :)
17:48:51 <syntaxglitch> yeah, news.yc is Paul Graham's site, it's basically reddit minus idiot trolls
17:49:15 <dark> ddarius, I think no, @.@'
17:49:15 <Saizan> but + graham?
17:49:49 <aristid> syntaxglitch: also ycombinator is an awesome name from a haskell perspective
17:50:18 <syntaxglitch> no, pg is too busy inventing a lisp dialect that has 0.001% as many users as clojure to post much
17:50:20 <Philonous> Phyx-: 4,8m. Well. Not what you'd expect from 150LOC; but at least somewhat more reasonable. Thanks.
17:50:30 <syntaxglitch> well, and like running YC itself, that probably takes a bit of time too
17:50:42 <dark> i thought he was too busy with his business, syntaxglitch
17:50:48 <dolio> aristid: You can't even write the Y combinator in Haskell without hackery. :)
17:50:50 <syntaxglitch> I'm joking :P
17:50:57 <syntaxglitch> pg
17:50:59 <syntaxglitch> ergh
17:51:05 <Phyx-> Philonous: well, 150LOC of your code, add to that the GHC api code + Hint code :P
17:51:07 <syntaxglitch> pg's an intersting guy
17:51:12 <syntaxglitch> I have nothing against him
17:51:19 <aristid> dolio: huh? wasn't Y=fix?
17:51:24 <roconnor> dolio: oh, mu isn't that hacky
17:51:25 <aristid> dolio: or am i confusing that?
17:51:29 <Phyx-> @hoogle [Bool] -> Bool
17:51:30 <lambdabot> Prelude and :: [Bool] -> Bool
17:51:30 <lambdabot> Prelude or :: [Bool] -> Bool
17:51:30 <lambdabot> Data.List and :: [Bool] -> Bool
17:51:32 <kmc> Y is a specific lambda term
17:51:34 <dark> dolio, seriously? i thought it would be simple.. (simpler than ml, where the naive definition gives an infinite loop)
17:51:35 <syntaxglitch> aristid, Y is a way of implementing something like fix
17:51:40 <kmc> fix is a different function with the same type and behavior
17:51:47 <syntaxglitch> but Y itself is untypeable
17:51:54 <dolio> aristid: I believe Y is specifically \f -> (\x -> f (x x)) (\x -> f (x x))
17:52:10 <aristid> kmc: a different function with same type and behavior?!
17:52:14 <Philonous> Phyx-: It has some small drawback, though. The executable ceased to work. But I guess I have to get my priorities straight. Can't eat my cake and have it, too.
17:52:20 <dark> in lambda calculus, there is an infinite number of fixed-point combinators
17:52:24 <dolio> roconnor: You need negative types. Those are clearly evil.
17:52:26 <aristid> :t \f -> (\x -> f (x x)) (\x -> f (x x))
17:52:27 <dark> the y combinator being the simplest
17:52:27 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
17:52:27 <lambdabot>     Probable cause: `x' is applied to too many arguments
17:52:27 <lambdabot>     In the first argument of `f', namely `(x x)'
17:52:30 <kmc> and they all have type (a -> a) -> a
17:52:31 <roconnor> dolio: true
17:52:44 <Phyx-> Philonous: ceased to work? that shouldn't happen.. I pack almost everything i produce lately
17:52:58 <syntaxglitch> I actually can't think of any languages where writing Y directly is possible
17:52:59 <aristid> dolio: i guess the type error is part of the point?
17:53:24 <dolio> aristid: Yes. Things like \x -> x x aren't well-typed in Haskell.
17:53:25 <Veinor> :t \x -> f (x x)
17:53:25 <Wooga> is in haskell anything like C's return, terminating execution of current function?
17:53:26 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
17:53:26 <lambdabot>     Probable cause: `x' is applied to too many arguments
17:53:26 <lambdabot>     In the first argument of `f', namely `(x x)'
17:53:51 <dolio> syntaxglitch: OCaml can do it with -rectypes.
17:53:59 <dolio> Which jdh claims as a huge feature.
17:54:10 <aristid> @src fix
17:54:10 <lambdabot> fix f = let x = f x in x
17:54:40 <aristid> @pl fix f = let x = f x in x
17:54:40 <lambdabot> fix = fix id
17:54:44 <Veinor> Wooga: not really
17:54:46 <benmachine> Wooga: soooort of but not really; the idea doesn't make a huge amount of sense in haskell functions anyway
17:55:13 <benmachine> functions in C are sequences of statements, in haskell they're just expressions
17:55:14 <Wooga> then i probably have a design issue
17:55:24 <aristid> > fix id (const 0)
17:55:27 <lambdabot>   mueval-core: Time limit exceeded
17:55:34 <aristid> > fix (const 0)
17:55:35 <lambdabot>   0
17:55:38 <syntaxglitch> dolio, ah, neat, didn't know that
17:55:42 <Veinor> :t fix id
17:55:43 <lambdabot> forall a. a
17:55:54 <benmachine> Wooga: what do you want to do exactly?
17:55:54 <aristid> Veinor: @pl proposed fix = fix id
17:56:09 <Veinor> @pl fix
17:56:09 <lambdabot> fix
17:56:25 <Veinor> oh noes
17:56:35 <aristid> @pl fix f = let x = f x in x
17:56:36 <lambdabot> fix = fix id
17:56:41 <aristid> Veinor: thurr
17:56:45 <syntaxglitch> I would have expected it to fail anyway in ocaml since (if memory serves me) Y diverges under strict evaluation
17:56:55 <benmachine> @pl fix f = f (fix f)
17:56:56 <lambdabot> fix = fix (ap id)
17:57:01 * benmachine blinks
17:57:17 <copumpkin> benmachine: that's a useful one
17:57:17 <aristid> benmachine: i guess @pl doesn't like that
17:57:25 <Philonous> Phyx-: "Shouldn't", true.
17:57:31 <aristid> :t fix (ap id)
17:57:32 <lambdabot> forall b. (b -> b) -> b
17:57:36 <dolio> syntaxglitch: Well, I can't guarantee that version actually works well in that respect. You might need to do some eta expansion.
17:57:36 <aristid> :t fix
17:57:38 <lambdabot> forall a. (a -> a) -> a
17:57:45 <aristid> > fix (ap id) (const 0)
17:57:46 <lambdabot>   0
17:57:50 <aristid> woah it works
17:57:54 <aristid> :t ap id
17:57:56 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
17:58:06 <Wooga> benmachine: here is code: http://codepad.org/mM3n3wlf and point in lines 5-11; if during execution not-a-number value (NaN) were inputed, after right guess it will be processed after correct answer
17:58:09 <benmachine> ap id = \g x -> id x (g x) = \g x -> x (g x)
17:58:26 <Veinor> @unpl ap id
17:58:26 <lambdabot> (\ f -> (\ a -> a) >>= \ c -> f >>= \ b -> return (c b))
17:58:32 <Veinor> ew :/
17:58:35 <copumpkin> that's actually a cute function
17:58:47 * copumpkin liek
17:58:50 <benmachine> Wooga: ah, you wanted early return in an IO do-block? that's more doable
17:58:56 <dibblego> http://paste.pocoo.org/show/247828/ is this right? that return feels odd
17:59:00 <Phyx-> functions can be cute?
17:59:15 <copumpkin> Phyx-: I think so
17:59:15 <Veinor> :3 is a pretty cute type constructor
17:59:19 <Veinor> (though probably not legal)
17:59:24 <copumpkin> apply x to the result of applying a function to x
17:59:27 <copumpkin> that's pretty cute
17:59:29 <syntaxglitch> "ap id id" would be more interesting
17:59:34 <Phyx-> copumpkin: get a room :P
17:59:50 <Wooga> benmachine: should i take all code inside if-then-else construction?
17:59:54 <syntaxglitch> copumpkin, it's just SI, isn't it?
18:00:01 <Veinor> syntaxglitch: yeah but that wouldn't fit in the type system
18:00:18 <benmachine> Wooga: you can do, but see also
18:00:19 <benmachine> :t when
18:00:21 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
18:00:23 * Phyx- loves undefined
18:00:26 <benmachine> :t unless
18:00:27 <Phyx-> best thing since sliced bread
18:00:28 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
18:00:39 <Wooga> oh, thank you!
18:00:48 <benmachine> Wooga: they don't necessarily solve your problem
18:00:52 <benmachine> just ideas
18:00:57 <benmachine> you can also use exceptions
18:01:07 <benmachine> or MaybeT, I guess, if you're at home with monad transformers
18:01:08 <etpace> @hoogle (a -> b) -> a
18:01:09 <lambdabot> Data.Function fix :: (a -> a) -> a
18:01:09 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
18:01:09 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
18:01:29 <benmachine> etpace: what on earth would it do?
18:01:47 <etpace> no idea, i was just looking at 
18:01:49 <etpace> :t ap id
18:01:50 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
18:02:01 <benmachine> oh right
18:02:13 <etpace> > ap id fix (+1)
18:02:17 <lambdabot>   mueval-core: Time limit exceeded
18:02:23 <benmachine> > ap id fix (0 :)
18:02:25 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
18:03:10 <sshc> I don't understand <* and *>
18:03:37 <sshc> If they type of thme are f a -> f b -> f (b|a), how can the first argument be a lifted function?
18:03:43 <Veinor> wouldn't ap id id be \x -> x x?
18:04:17 <copumpkin> :t [(>>), (*>)]
18:04:19 <lambdabot> forall (m :: * -> *) a b. (Monad m, Applicative m) => [m a -> m b -> m b]
18:04:47 <Philonous> Phyx-: Tried a different compression level, upx -t says the file is OK, but it still doesn't work (it should be extensionally equivalent to the uncompressed file, shouldn't it? 
18:05:06 <aristid> :t [(=<<), (<*>)]
18:05:07 <lambdabot> forall a b. [(a -> a -> b) -> (a -> a) -> a -> b]
18:05:14 <etpace> mm what's the best way to time profile?
18:05:29 <etpace> -hc?
18:05:46 <Lemmih> etpace: -p.
18:06:21 <Phyx-> Philonous: yup. i use upx -9 
18:06:26 <Phyx-> Philonous: what platform are you on?
18:07:15 * syntaxglitch notes that fix, ap, and const should be enough to write any program you want, why bother with all this other cruft
18:07:17 <benmachine> sshc: who says it's a lifted function?
18:07:25 <Philonous> Phyx-: Arch Linux amd64
18:07:32 <copumpkin> syntaxglitch: good point! 
18:07:51 <Saizan> dibblego: it's weird to take "m (Tree a)" as an argument, rather than just "Tree a"
18:07:56 <copumpkin> syntaxglitch: maybe we should add id just to save people some effort
18:08:09 <dibblego> Saizan, what is the formula to determine the monadic version of a function?
18:08:32 <syntaxglitch> copumpkin, it's just ap const const, but I guess that is a bit verbose
18:08:35 <Phyx-> Philonous: Philonous dump the ELF header, it should still be a valid one, just containing an extra field which mentions upx
18:08:42 <dibblego> Saizan, also, if I change it from m (Tree a) to Tree a, then the return will still be around
18:08:47 <syntaxglitch> or ap const ap I suppose, same either way
18:08:57 <aristid> :t ap const const
18:08:59 <lambdabot> forall b. b -> b
18:08:59 <copumpkin> syntaxglitch: yeah :)
18:09:01 <benmachine> :t ap const fix
18:09:02 <aristid> :t ap const ap
18:09:04 <lambdabot> forall a. (a -> a) -> a -> a
18:09:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m (a -> b)
18:09:05 <Saizan> dibblego: i don't think so
18:09:12 <aristid> syntaxglitch: nah ap const ap does not work
18:09:18 <copumpkin> aristid: looks like id to me
18:09:19 <dibblego> Saizan, you don't think the return will still be around?
18:09:25 <Saizan> dibblego: right
18:09:26 <aristid> :t id
18:09:28 <lambdabot> forall a. a -> a
18:09:36 <aristid> copumpkin: it looks more like ($) to me
18:09:38 <azaq23> ap is the s combinator and const is the k combinator, together they are the (-> t) Applicative instance - s and k are turing complete
18:09:40 <copumpkin> aristid: pff types
18:09:44 <copumpkin> aristid: ($) is id
18:09:53 <aristid> copumpkin: ($) is id only for teh functions
18:09:59 <copumpkin> yeah but pff types
18:10:00 <aristid> :t ap const const
18:10:02 <lambdabot> forall b. b -> b
18:10:09 <Saizan> foldTreeM f (Node a s) = f a <$> mapM (foldTreeM f) s
18:10:14 <Philonous> Phyx-: file says it's valid Elf file. How would I dump the header?
18:10:29 <copumpkin> Philonous: objdump -h or something
18:10:41 <Saizan> dibblego: the "formula" is to add an "m" only to the result types
18:10:41 <aristid> :t ap return return
18:10:42 <lambdabot>     Ambiguous type variable `m' in the constraint:
18:10:43 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:10-15
18:10:43 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
18:10:49 <aristid> lambdabot: stupid you
18:10:56 <dibblego> Saizan, righto got it thanks
18:11:04 <Saizan> "foldTreeM f (Node a s) = f a =<< mapM (foldTreeM f) s" actually
18:11:13 <benmachine> :t pure <*> pure
18:11:14 <lambdabot>     Ambiguous type variable `f' in the constraint:
18:11:15 <lambdabot>       `Applicative f'
18:11:15 <lambdabot>         arising from a use of `pure' at <interactive>:1:9-12
18:11:34 <aristid> :t const <*> const
18:11:36 <lambdabot> forall b. b -> b
18:11:41 <aristid> awesome infixness
18:11:57 <Phyx-> Philonous: i'm not entirely sure, haven't used objdump in a long time, try what copumpkin mentioned
18:12:08 <aristid> :t const <*> undefined
18:12:09 <lambdabot> forall b. b -> b
18:12:22 <theorbtwo> Isn't that just const's type?
18:12:30 <aristid> :t const
18:12:31 <lambdabot> forall a b. a -> b -> a
18:12:32 <syntaxglitch> aristid, ap const ap makes the type cruftier but it ought to work just as well
18:12:41 <azaq23> > let myId = const <*> const in myId $ 10
18:12:42 * copumpkin likes cruft
18:12:44 <lambdabot>   10
18:12:44 <theorbtwo> Ah.  Not quite then.
18:12:45 <aristid> syntaxglitch: it unnecessarily limits the type
18:12:56 <copumpkin> aristid: just unsafeCoerce it
18:13:02 <aristid> :t const <*> ap
18:13:02 <syntaxglitch> aristid, I don't think it would, actually--it would just expand the type
18:13:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m (a -> b)
18:13:05 <Philonous> Phyx-: It says it's a x86-64 elf file, but the "Sections"-part is empty
18:13:13 <aristid> :t ap const ap
18:13:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m (a -> b)
18:13:39 <aristid> syntaxglitch: i don't see how that is like id
18:14:26 <Phyx-> Philonous: try packing a non-haskell exe, see if that works, if it doesn't then their might be a bug with that version of upx
18:14:33 <copumpkin> it's exactly id, with a restricted type, and since we're talking about untyped SK, it doesn't matter :P
18:14:34 <syntaxglitch> aristid, it's id with the type specialized to m (a -> b), and if you're writing a program with nothing but fix, ap, and const I don't think you'll ever find a term that can't unify with that type
18:14:57 <copumpkin> syntaxglitch: can't you drop fix too?
18:14:59 <kmc> does the claim "s and k are turing complete" hold even in a typed lambda calculus?
18:15:04 <aristid> syntaxglitch: i have a bit trouble imagining writing programs like that :)
18:15:13 <copumpkin> S(SKK)(SKK) (S(SKK)(SKK)) or something
18:15:16 <syntaxglitch> copumpkin, not if you want it to be turing-equivalent in Haskell
18:15:16 <aristid> wait, k is const and s is ap?
18:15:20 <kmc> i think it wouldn't; you can write S and K in STLC, but STLC is strongly normalizing
18:15:24 <copumpkin> syntaxglitch: oh
18:15:37 <Saizan> kmc: it doesn't, in fact
18:15:44 <copumpkin> if it's strongly normalizing, it isn't TC
18:16:07 <prey_alone> I'm having trouble with *let* syntax, especially with hard tabs. Code: http://pastebin.com/Da7jFFYn
18:16:15 <azaq23> @. djinn type const
18:16:17 <lambdabot> f a _ = a
18:16:29 <azaq23> @. djinn type -> (<*>)
18:16:31 <lambdabot> Cannot parse command
18:16:34 <copumpkin> prey_alone: a simple solution is to not use hard tabs :)
18:16:38 <benmachine> copumpkin: because then the solution to the halting problem would be, "yes"?
18:16:44 <azaq23> @. djinn type (->) (<*>)
18:16:46 <lambdabot> Cannot parse command
18:17:01 <prey_alone> copumpking: It's one reason I gave up Python for Ruby. But that's neither here nor there.
18:17:01 <copumpkin> benmachine: well, not "because", but that would definitely be a consequence :P
18:17:05 <Philonous> Phyx-: tried mc, that worked just fine. 
18:17:25 <Saizan> prey_alone: y and z have to be aligned with x, and hard tabs count as 8 spaces for this
18:17:45 <syntaxglitch> aristid, in the ((->) r) monad return is const/K and ap is S, yeah
18:17:49 <azaq23> @djinn (t -> a -> b) -> (t -> a) -> t -> b
18:17:49 <Saizan> prey_alone: another option is to use explicit braces and ; instead of layout
18:17:50 <lambdabot> f a b c = a c (b c)
18:18:02 <azaq23> @pl f a b c = a c (b c)
18:18:03 <lambdabot> f = ap
18:18:05 <prey_alone> According to Real World Haskell, as long as Y and Z are indented further to the right than LET, there shouldn't be a problem (tabs or no tabs).
18:18:05 <Phyx-> Philonous: that's odd.. 
18:18:21 <prey_alone> Saizan: Yep. I'd prefer not to, but you're right.
18:18:27 <azaq23> not really ap though, instance <*> for (-> t)
18:18:45 <aristid> syntaxglitch: so actually ap and <*> are more awesome than S because they're more general
18:18:46 <Wooga> benmachine: should i take all code inside if-then-else construction?
18:18:48 <Saizan> prey_alone: they also need to be aligned with 'x', in this case.
18:18:58 <Wooga> oh, sorry, wrong terminal
18:18:59 <prey_alone> hmm.
18:19:10 <Saizan> prey_alone: if you don't put x = 1 on the same line as let, it'll be easier to follow this rule.
18:19:14 <etpace> hmm I'd ideally like to find out where my program is spending most of its time, -p doesn't give me that information, and it seems hc hr etc are for space, is there a better way to profile time?
18:19:23 * Phyx- writes up a new blog post
18:19:31 <prey_alone> Saizan: That explains why, even when I use spaces, I get compilation errors for that code.
18:19:36 <syntaxglitch> azaq23, well yeah, the Applicative instance suffices, but using (<*>) as the S combinator is a bit awkward
18:19:42 <benmachine> etpace: -p doesn't give you that information? did you compile with -auto-all or whatever?
18:19:49 <benmachine> -prof -auto-all
18:19:59 <benmachine> -caf-all for bonus points
18:20:03 <copumpkin> etpace: also, you can add {-# SCC "name" #-}
18:20:08 <copumpkin> to ask it to measure specific parts
18:20:09 <etpace> yeah should be, -O2 -prof -auto-all
18:20:13 <Saizan> prey_alone: you can check the haskell report for a complete description of how layout works
18:20:17 <Saizan> @where report
18:20:17 <lambdabot> http://www.haskell.org/onlinereport/
18:20:34 <etpace> running with -sstderr -hr -p -A32M -H32M
18:20:34 <benmachine> hmm, that's still h98 report
18:20:37 <copumpkin> @where+ rtfr http://www.haskell.org/onlinereport/
18:20:38 <lambdabot> Good to know.
18:20:52 <prey_alone> Saizan: Thanks a bunch!
18:21:05 <copumpkin> now if we want to be unpleasant we have a good way to do it!
18:21:23 <kmc> rtfr?
18:21:32 <copumpkin> like rtfm, except about the report
18:21:36 <kmc> hehe
18:21:43 <prey_alone> Saizan: That lining-up thing also explains why WHERE gave me no trouble.
18:21:50 <kmc> then we'd live up to our worst reputation
18:22:11 <Phyx-> :t fmap
18:22:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:22:21 <Saizan> prey_alone: because you use "where \n x = ..."?
18:22:29 <syntaxglitch> aristid, Applicative for ((->) r) is a sort of generalized S combinator, actually. You can keeping chaining <*> to make it more S-y
18:22:48 <Phyx-> :i fmap
18:22:54 <aristid> syntaxglitch: what would be the type of S?
18:22:59 <prey_alone> Saizan: Because in my WHERE block, I didn't put any assignments on the same line as WHERE.
18:23:13 <syntaxglitch> :t \f g x -> f x $ g x
18:23:14 <lambdabot> forall t a b. (t -> a -> b) -> (t -> a) -> t -> b
18:23:18 <aristid> :t ap ap
18:23:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m (a -> b) -> m a) -> m (a -> b) -> m b
18:23:25 <aristid> :t ap ap const
18:23:26 <lambdabot>     Occurs check: cannot construct the infinite type: a = m (a -> b)
18:23:27 <lambdabot>       Expected type: m (a -> b)
18:23:27 <lambdabot>       Inferred type: a
18:24:27 <Veinor> @pl \f g x -> f x $ g x
18:24:27 <lambdabot> ap
18:24:34 <syntaxglitch> you don't say!
18:24:46 <syntaxglitch> lambdabot knows all about combinatory logic
18:24:51 <Veinor> :O
18:24:54 <dolio> @unpl ap
18:24:54 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
18:25:03 <syntaxglitch> :(
18:26:31 <Veinor> @do (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
18:26:32 <lambdabot> (\ d e -> do { b <- d; a <- e; return (b a)})
18:26:57 <benmachine> @. do unpl ap
18:26:58 <lambdabot> (\ d e -> do { b <- d; a <- e; return (b a)})
18:27:11 <Veinor> yeah, I forgot the syntax of @. and didn't want to bother figuring it out
18:27:17 <benmachine> heh
18:27:41 <aristid> @. elite vixen what about Veinor?
18:27:41 <lambdabot> I DuNn0, W|-|4+ 48oU7?
18:29:55 <aristid> how to do fix just with ap and const?
18:30:12 <benmachine> you can't if you insist on the types
18:30:13 <dolio> @pl \x -> x x
18:30:13 <lambdabot> join id
18:30:19 <benmachine> if you want to be untyped
18:30:20 <benmachine> then
18:30:30 <benmachine> I think it's messy, copumpkin said something relevant
18:31:58 <dolio> @pl \x -> f (x x)
18:31:59 <lambdabot> f . join id
18:32:33 <dolio> The trivial loop is easy.
18:33:00 <dolio> SIIx = Ix(Ix) = xx, so (SII)(SII) loops, same as (\x -> x x) (\x -> x x)
18:33:46 <dolio> Making a fixed point operator 'just' requires you to get f in there.
18:34:14 <syntaxglitch> "just"
18:34:37 <aristid> '"^just^"' <- fun with quotes and other characters
18:34:48 <Maxdamantus> Hmm.. What's the argument thing for when making a monad from another monad?
18:34:50 <Wooga> how do i put code after 'when' here: http://codepad.org/6PgplWvU ?
18:34:58 <dolio> Yeah. It's probably not hard to figure out, but it's more effort than I want to put in.
18:35:00 <Maxdamantus> a >>= \_ -> foo
18:35:02 <dolio> Otherwise I'd just write it.
18:35:07 <Wooga> line 14
18:35:18 <syntaxglitch> dolio: if memory serves me it's like three times as long as the trivial loop
18:35:32 <Maxdamantus> Isn't it meant to be sort of like a list, so it'd be almost like a : operation
18:35:34 <syntaxglitch> actually programming in SK logic is painful
18:35:59 <aristid> doesn't unlambda use that?
18:36:21 <syntaxglitch> yes, but don't use unlambda, it's impure
18:36:23 <syntaxglitch> sheesh
18:36:26 <syntaxglitch> use Lazy K
18:36:29 <dolio> @pl \f -> (\x -> x x) (\x -> f (x x))
18:36:29 <lambdabot> join id . (. join id)
18:36:38 <syntaxglitch> Lazy K is pure and non-strict, very elegant
18:36:48 <Maxdamantus> win 36
18:37:48 <kmc> Wooga, "where" binds to a whole declaration
18:37:53 <kmc> in this case the "doGuess num = ..."
18:37:58 <copumpkin> yep, I only found that out a few months ago :P
18:38:06 <copumpkin> I was surprised
18:38:16 <kmc> so it's closing off the whole thing
18:38:23 <kmc> Wooga, i would instead use "let" to define "process" within that do block
18:38:36 <Wooga> kmc: thank you
18:38:38 <kmc> and then use it
18:38:46 <kmc> Maxdamantus, i'm not sure what you're asking
18:39:01 <aristid> syntaxglitch: lol warning against unlambda because it's not pure. that is.. cute :)
18:39:42 <Maxdamantus> Can a monad be thought of as like a *list* of actions?
18:39:52 <dolio> Cfgx = f(gx) = Kfx(gx) = S(Kf)gx ==> Cf = S(Kf) = S(KS)Kf ==> C = S(KS)K
18:40:25 <syntaxglitch> aristid, well, it's true
18:41:15 <ddarius> C is usually flip, B is (.)
18:42:39 <kmc> Maxdamantus, by "monad" do you mean "value of monadic type"
18:42:47 <kmc> examples of monads are Maybe, [], and IO
18:42:53 <Maxdamantus> Yeah.
18:42:54 <kmc> they are types
18:42:55 <kmc> ok
18:43:16 <kmc> the answer to any "can it be thought of this way" question is usually "yes"
18:43:20 <Maxdamantus> Oh right.. a list is a monad
18:43:34 <Maxdamantus> Maybe that's why a monad can't be made of a list
18:43:37 <kmc> because people find ways to match up the strangest intuitive models
18:43:44 <kmc> infamously so for monads
18:43:48 <kmc> but as to your particular analogy
18:44:04 <shachaf> Maxdamantus: A value of monadic type can be thought of as an action. One type of action is "compose two other actions". So yes.
18:44:15 <Maxdamantus> It seems to me that the IO monad is meant to be sort of like an event queue.
18:44:28 <syntaxglitch> If you handwave what the extra structure of a monad entails, then the identity and associativity laws make accumulating actions act sort of listlike
18:44:29 <kmc> but the monadic value itself needn't resemble a list
18:44:30 <Maxdamantus> Which obviously could be represented by an infinite list
18:44:32 <azaq231> but they actually are like burritos!
18:44:35 <ClaudiusMaximus> :t Data.Traversable.sequence
18:44:36 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
18:44:40 <Maxdamantus> an action : list of actions
18:45:06 <Maxdamantus> (But just realised list is based on monads)
18:45:14 <ddarius> "type constructors"
18:45:17 <kmc> "list is based on monads"?
18:45:30 <kmc> not really
18:45:31 <Maxdamantus> Er, is a monad*
18:45:34 <Maxdamantus> Dunno :\
18:45:34 <kmc> yeah
18:45:42 <kmc> but this is secondary to how lists are defined and used
18:45:44 <shachaf> Maxdamantus: That's true, but not really relevant to what I think you're trying to say.
18:45:50 <Maxdamantus> So can I construct lists using the monadic operations? O_o
18:45:54 <kmc> yes
18:46:00 <syntaxglitch> a list is a monad, but in a way completely unrelated to a conceptual sequence of "monadic side-effects"
18:46:04 <Maxdamantus> ["foo"] >> "bar"
18:46:12 <shachaf> Maxdamantus: That's what list comprehensions are.
18:46:22 <kmc> > do { x <- [1,2,3]; y <- [10,20,30]; return (x+y) }
18:46:23 <lambdabot>   [11,21,31,12,22,32,13,23,33]
18:46:32 <kmc> > [ (x+y) | x <- [1,2,3], y <- [10,20,30] ]
18:46:34 <lambdabot>   [11,21,31,12,22,32,13,23,33]
18:46:34 <Lemmih> > ["foo"] >> "bar"
18:46:36 <lambdabot>   "bar"
18:46:43 <shachaf> > "foo" >> "bar"
18:46:45 <lambdabot>   "barbarbar"
18:46:47 <aristid> > (+) <$> [1,2,3] <*> [10,20,30]
18:46:48 <lambdabot>   [11,21,31,12,22,32,13,23,33]
18:46:51 <Maxdamantus> O_o
18:47:00 <kmc> Maxdamantus, note that the do-syntax is very close to the list comprehension syntax
18:47:07 <medfly> I am pretty sure (+) <*> <$> makes much more sense P
18:47:08 <medfly> :P
18:47:09 <syntaxglitch> > filterM (const [True. False]) [0..2]
18:47:10 <lambdabot>   Couldn't match expected type `a -> b'
18:47:10 <lambdabot>         against inferred type `GHC.Bo...
18:47:21 <copumpkin> > "fap" >> "fap"
18:47:22 <lambdabot>   "fapfapfap"
18:47:26 <aristid> medfly: yeah the Applicative syntax is a bit nicer
18:47:29 <etpace> Is there a simple bar/pie grapher for time in a .prof?
18:47:37 <kmc> > liftA2 (+) [1,2,3] [10,20,30]
18:47:39 <lambdabot>   [11,21,31,12,22,32,13,23,33]
18:47:42 <syntaxglitch> > filterM (const [True, False]) [0..2]
18:47:44 <lambdabot>   [[0,1,2],[0,1],[0,2],[0],[1,2],[1],[2],[]]
18:47:54 <syntaxglitch> yay powersets :)
18:48:03 <shachaf> Powerlists.
18:48:04 <aristid> Maxdamantus: this channel can sometimes feel a bit overwhelming :)
18:48:13 <shachaf> Unfortunately the same trick doesn't work for Data.Set. :-(
18:48:17 <shachaf> (As far as I know.)
18:48:24 <Maxdamantus> Indeed.. but interesting.
18:48:32 <dolio> It would if there were a Monad instance for sets.
18:48:43 <copumpkin> RMonad!
18:48:46 <syntaxglitch> I spent about four days trying to understand how that powerset function worked when I first started learning Haskell
18:48:48 <copumpkin> (to the rescue)
18:49:08 * Maxdamantus was trying to think of a powerset function a few days ago :(
18:49:13 <aristid> @src filterM
18:49:13 <lambdabot> Source not found. My brain just exploded
18:49:20 <aristid> :t filterM
18:49:21 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
18:49:26 <kmc> Maxdamantus, so every monad has an idea of "sequencing".  the witness to this fact is the function Control.Monad.sequence
18:49:34 <Maxdamantus> Haskell seems to actually tie in quite tightly with my "discrete mathematics" course at uni O_o
18:49:51 <shachaf> kmc: Not so much commutative monads.
18:49:56 <copumpkin> haskell is a wonderful way to explore many kinds of math and CS
18:50:04 <Maxdamantus> Set in discrete maths: {2a | a (in) {1..20}}
18:50:12 <copumpkin> unfortunately many CS algorithms are written imperatively, even when it isn't necessary
18:50:14 <aristid> @src sequence
18:50:14 <lambdabot> sequence []     = return []
18:50:14 <kmc> Maxdamantus, but whether the sequence of actions is present in the actual representation of the value depends on the particular monad in question
18:50:14 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:50:14 <lambdabot> --OR
18:50:14 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
18:50:15 <Maxdamantus> Haskell: [2*a | a <- [1..20]]
18:50:25 <kmc> Maxdamantus, that's not a set in Haskell though
18:50:25 <ddarius> @google unfolding pointer algorithms
18:50:28 <shachaf> Maxdamantus: Yes, but that's just syntax.
18:50:36 <Maxdamantus> Yeah, well, list.
18:50:41 <lambdabot> Plugin `search' failed with: thread killed
18:50:44 <Maxdamantus> Still, oddly similar syntax.
18:50:44 <ddarius> @google unfolding pointer algorithms
18:50:51 <kmc> lots of languages have list comprehensions
18:50:51 <copumpkin> with the set monad you could get something similar for sets
18:50:59 <lambdabot> Plugin `search' failed with: thread killed
18:51:06 <syntaxglitch> lists, sets, what's the difference, who cares about unnecessary traversals
18:51:11 <aristid> the second definition of sequence nicely shows how it's actually an operation specific to Applicative, not so much Monad
18:51:33 <Veinor> Maxdamantus: well, idiomatic haskell would be map (2*) [1..20]
18:51:33 <aristid> :t foldr (liftA2 (:)) (pure [])
18:51:34 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
18:51:45 <copumpkin> aristid and not just for lists :P
18:51:51 <copumpkin> :t Data.Traversable.sequenceA
18:51:52 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
18:51:54 <aristid> copumpkin: haha
18:52:04 <copumpkin> generalize in two dimensions!
18:52:27 <aristid> copumpkin: yeah, and that's still easier than category-extras
18:52:30 <shachaf> syntaxglitch: Wait, you're not syntaxfree.
18:52:30 <ddarius> Traversable is too enterprisey.  We should rename it DistributiveLaw.
18:52:41 <copumpkin> definitely
18:52:46 <copumpkin> anything with -able in it doesn't sound like haskell
18:52:54 <syntaxglitch> I agree
18:52:54 <copumpkin> otherwise we might as well just call Functor Mappable
18:53:09 <aristid> haha Mappable. that would be too easy.
18:53:15 <shachaf> copumpkin: What would we call Monad?
18:53:25 <aristid> shachaf: Joinable!
18:53:27 <copumpkin> shachaf: Flattenable
18:53:37 <dolio> EDSL
18:53:41 <kmc> Burritoable
18:53:44 <aristid> Edslable
18:53:44 * shachaf expects to get as many answers as there are monad tutorials. :-)
18:53:52 <kmc> LINQ
18:53:52 <copumpkin> aristid: pff join, get down from your academic ivory tower
18:54:02 <aristid> copumpkin: ok.
18:54:03 <aristid> Jointable
18:54:08 <copumpkin> lol
18:54:09 <syntaxglitch> I thought the canonical answer was WarmFuzzyThing
18:54:17 <kmc> F# calls  monads "workflows"
18:54:33 <syntaxglitch> kmc, yeah, don't think we can get much more enterprisey than that
18:54:39 <shachaf> aristid: Sounds too much like SQL.
18:54:49 <copumpkin> active workflow++ 2.0?
18:54:49 <kmc> syntaxglitch, how about Workflow Pattern then
18:54:55 <benmachine> so what's Foldable in categoryspeak
18:55:05 <kmc> in Haskell 2010, let's require that every typeclass name end in "Pattern"
18:55:09 <kmc> 2011*
18:55:10 <aristid> shachaf: isn't SQL enterprisey for our purposes?
18:55:27 <shachaf> benmachine: Catamorphism?
18:55:28 <Maxdamantus> Ahah. I figured it out!
18:55:32 <benmachine> kmc: or just that the keyword Pattern can be inserted anywhere in a valid haskell program, it parses as whitespace
18:55:33 <aristid> kmc: that way we can prove that haskell is a Serious Language.
18:55:45 <Maxdamantus> > ["foo"] >>= \a -> a : ["bar"]
18:55:47 <lambdabot>   ["foo","bar"]
18:55:48 <benmachine> shachaf: things that have a catamorphism (which is... all of them?)
18:56:03 <kmc> > ["foo"] >>= (:["bar"])
18:56:04 <lambdabot>   ["foo","bar"]
18:56:12 <Maxdamantus> Or that :\
18:56:23 <dolio> Foldable doesn't provide a fully general catamorphism, though.
18:56:44 <benmachine> FoldsLikeAList
18:56:54 <benmachine> (FruitFliesLikeABanana)
18:56:54 <syntaxglitch> Foldable only works for linear recursive structures, doesn't it?
18:56:57 * syntaxglitch can't recall
18:57:25 <aristid> somebody said that he would prefer having a class with only the method toList instead of Foldable
18:57:33 <Phyx-> wtf is with all these panics
18:57:33 <dolio> It's more like a class for everything that's an FA-algebra for FAX = 1 + A * X.
18:57:55 <Veinor> aristid: ew
18:58:07 <shachaf> aristid: Would that be equivalent?
18:58:13 <benmachine> :t foldMap (:[])
18:58:15 <lambdabot> Not in scope: `foldMap'
18:58:19 <benmachine> :t Data.Foldable.foldMap (:[])
18:58:21 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> [a]
18:58:52 <copumpkin> :t appEndo . Data.Foldable.foldMap Endo
18:58:53 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
18:58:55 <dolio> Actually, I guess they're not list algebras, but consumers of list algebras.
18:59:29 <aristid> shachaf: yeah
19:00:37 <shachaf> There isn't any type class with toList and fromList?
19:00:50 <dolio> Foldable is toList.
19:01:02 <ddarius> Why doesn't Foldable have a Functor superclass constraint?
19:01:13 <dolio> Doesn't it?
19:01:30 <dolio> Huh, it doesn't.
19:01:33 <aavogt> perhaps you'd like to have Foldable instances for Set
19:02:17 <copumpkin> ddarius: cause haskell hates code reuse
19:03:09 <shachaf> Why doesn't Monad have a Functor superclass constraint?
19:03:25 <ddarius> shachaf: Insanity.
19:03:31 <copumpkin> cause it don't need no stinkin superclass
19:03:34 <ddarius> It did originally.
19:04:04 <shachaf> ddarius: It did? That must have been before my time.
19:04:07 <shachaf> What happened to it?
19:04:17 <dolio> Wasn't Foldable a Conor McBride creation?
19:04:23 <aristid> ddarius: wtf? it used to be saner?
19:04:30 <copumpkin> aristid: a lot of stuff did
19:04:35 <dolio> Surprising that he'd miss that.
19:04:39 <aristid> the good olden times!
19:04:45 <aristid> where Monad was still Functor
19:04:51 <copumpkin> way before my time too, though
19:04:52 <aristid> and a comprehension was of monads, not lists
19:04:56 <copumpkin> most of our times, I'd gues
19:04:57 <ddarius> dolio: aavogt's answer is probably the reason
19:05:00 <aristid> and IO was two lists
19:05:07 <dolio> Yeah. It's a decent reason.
19:05:14 <benmachine> Set is indeed Foldable and not Functor
19:05:29 <shachaf> benmachine: Wait, Set isn't a Functor?
19:05:42 <aristid> shachaf: it can't
19:05:46 <aristid> :k Functor
19:05:47 <lambdabot> Class `Functor' used as a type
19:05:48 <benmachine> shachaf: Set needs Ord for its elements, Functor allows you to convert them to arbitrary other types
19:05:48 <ddarius> At any rate, probably the simplest way to describe Foldable is it is simply functors that have a natural transformation to lists.
19:05:51 <shachaf> Oh, because of the Ord constraint?
19:06:01 <aristid> shachaf: it's a evil
19:06:02 <shachaf> Right, the same reason it's not Monad. Never mind.
19:06:20 <benmachine> class ListIsh l where
19:06:32 <shachaf> preflex: seen twifkak
19:06:33 <preflex>  twifkak was last seen on #xmonad 1 year, 69 days, 21 hours, 56 minutes and 39 seconds ago, saying: @seen shepheb
19:06:49 <ddarius> I don't think there is any common categorical concepts that maps to Foldable.
19:07:08 <ddarius> s/concepts/concept/
19:07:17 <aristid> but why did Monad lose the Functor superclass?
19:07:20 <dolio> When was Functor => Monad?
19:07:24 <dolio> Not in 1.4, apparently.
19:07:34 <shachaf> class Enumerable?
19:07:43 <copumpkin> it seems weird to have Functor => Monad with the current monad methods
19:07:45 <benmachine> shachaf: we already have class Enum
19:07:52 <shachaf> benmachine: True.
19:07:56 <copumpkin> Functor => Monad with return and join, maybe?
19:07:57 <dolio> Nor 1.3
19:08:00 <shachaf> But that's what Foldable corresponds to, no?
19:08:13 <shachaf> copumpkin: Weird why? You'd rather it was fmap/join/return?
19:08:20 <benmachine> copumpkin: I think >>= makes sense as a method, but it could be default-defined if you like
19:08:25 <copumpkin> shachaf: bind and return are enough to give you fmap
19:08:30 <aristid> copumpkin: yeah i prefer fmap/join/return too
19:08:31 <copumpkin> shachaf: join and return need fmap
19:08:52 <ddarius> dolio: In Gofer.
19:08:56 <dolio> Oh.
19:09:34 <ddarius> shachaf: Yep (re Enumerable and Foldable)
19:09:51 <dolio> So they mucked it up before adding it to the official definition.
19:10:22 <shachaf> @ty Data.Foldable.fold
19:10:24 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
19:11:49 <drhodes> is there a way to enter binary analagous to the hex 0x?
19:12:41 <copumpkin> nope
19:12:47 <drhodes> ok thanks copumpkin 
19:12:50 <benmachine> you can translate binary to hex digit for digit
19:12:53 <ddarius> public static M Fold<M>(IEnumerable tm, Func<M, M, M> mappend, M mempty) { var acc = mempty; for(M m in tm) acc = mappend(acc, m); return acc; }
19:12:55 <aristid> was Functor => Monad actually ever in haskell?
19:13:13 <copumpkin> aristid: gofer, apparently
19:13:20 <aristid> copumpkin: gofer is haskell?
19:13:54 <dolio> You know what Hugs stands for?
19:14:03 <ddarius> Gofer was an experimental language very similar to Haskell most of whose ideas have been folded into Haskell 98 or are common extensions.
19:14:07 <copumpkin> ooh, lookie: http://hackage.haskell.org/packages/archive/gofer-prelude/2.30.2/doc/html/Prelude-Gofer.html
19:14:10 <aristid> dolio: something with hugging
19:14:14 <medfly> hehehe
19:14:19 <dolio> Haskell User's Gofer System.
19:14:32 <dolio> As I recall.
19:14:40 <aristid> uh, what?
19:14:48 <aristid> a haskell -> gofer compiler?
19:15:06 <ddarius> dolio: Correct.
19:15:18 <ddarius> Hugs is a pure interpreter.
19:16:05 <aristid> what is its relation to gofer then?
19:16:31 <copumpkin> http://snapplr.com/4de0
19:16:45 <ddarius> aristid: It was a "successor" to Gofer that pulled it back toward Haskell.
19:16:52 <copumpkin> gotta love abstraction :P
19:16:54 <aristid> http://cvs.haskell.org/Hugs/pages/users_guide/faq.html#AEN1870
19:17:31 <copumpkin> wow, this dialogue type looks like a pain to use
19:17:42 <copumpkin> (without do notation)
19:17:48 <copumpkin> maybe they had that
19:19:17 <Veinor> 22:16:05        <copumpkin> http://snapplr.com/4de0                                                                                                                                                                     
19:19:20 <Veinor> wat
19:19:20 <ddarius> copumpkin: Gofer had monad comprehensions I believe.
19:19:32 <copumpkin> ddarius: ah
19:19:52 <copumpkin> Veinor: stdout = "stdout" :P
19:19:58 <aristid> ddarius: people keep saying that haskell had them too
19:20:24 <dolio> It had them up until 1.4, I believe.
19:20:31 <dolio> So, two versions.
19:21:01 <dolio> They were called "list comprehensions" but they worked with things other than lists.
19:21:42 <aristid> teh glory!
19:22:03 <aristid> so 1.4 will be dubbed the Evil Revision.
19:22:15 <dolio> They were still in 1.4, I mean.
19:22:19 <dolio> They got taken out for 98.
19:22:22 <aristid> oh.
19:22:27 <aristid> then 98 is the evil one?
19:22:36 <dolio> Yes. Lots of weird stuff happened then.
19:22:38 <dolio> fail.
19:22:52 <dolio> Lots of de-generalizing, too.
19:23:04 <aristid> dolio: was there a reason for that?
19:23:22 <dolio> Which?
19:24:06 <dolio> The de-generalizing happened because it was thought to make the language easier to teach, I think.
19:24:09 * hackagebot Thrift 0.1.1 - Thrift library package  http://hackage.haskell.org/package/Thrift-0.1.1 (KirkPeterson)
19:24:33 <dolio> map and (++) complaining in errors about lists instead of Functor f => ..., for instance.
19:25:01 <wli> dolio: It's had marginal impact on teachability if any at all and grossly uglified the language. :(
19:25:04 <dolio> fail is a slightly more complicated situation.
19:25:10 * hackagebot cassandra-thrift 0.0.5 - thrift bindings to the cassandra database  http://hackage.haskell.org/package/cassandra-thrift-0.0.5 (KirkPeterson)
19:25:26 <dolio> wli: Yeah. Hindsight is 20/20, I guess.
19:25:56 <wli> What's the summary on fail?
19:26:25 <dolio> Well, in 1.4, when you did "do pat <- m ; ...", it would generate a MonadZero constraint.
19:26:40 <dolio> Except, if pat was "unfailable", like "(x, y)".
19:26:51 <dolio> Unfailable meaning it could only be refuted by bottom.
19:26:58 <dolio> Those would still have a Monad constraint.
19:27:04 <BMeph> dolio: Does the "Caleskell" re-defining of "++" for use on all Monoids give you an odd deja vu sensation? 
19:27:31 <dolio> So, they wanted to get rid of unfailable patterns, but didn't want to lose the convenience of matching on (x, y) working in all monads. So fail was invented.
19:27:50 <dolio> BMeph: Well, I wasn't around then, so no. Also, it used to be mplus.
19:28:12 <wli> Yeah (++) was the MonadPlus method.
19:28:19 <copumpkin> dolio: when did you start?
19:28:29 <dolio> 2004, maybe?
19:28:36 <copumpkin> ah
19:28:52 <wli> I was actually starting up right around the time Haskell 98 happened.
19:29:25 <dolio> Anyhow, there are some reasons for getting rid of unfailable patterns, I guess, but I don't find them very convincing, so I'd put them back in and get rid of fail.
19:29:34 <dolio> Or just get rid of fail anyway.
19:29:51 <ezyang> Those who are not familiar with academic literature are doomed to poorly reimplement research again and again. 
19:30:21 * wli doesn't know of the reasoning behind the fail method in monads and/or unfailable patterns.
19:30:40 <copumpkin> I don't see why it couldn't have been MonadZero for monads that had irrefutable pattern matches in them
19:30:47 <copumpkin> just add an extra constraint when necessary?
19:30:56 <copumpkin> for monad uses, that is
19:31:15 <wli> copumpkin: Well, that's what it used to be .
19:31:18 <aristid> ezyang: it's literally impossible to be familiar with all relevant academic literature
19:31:27 <ezyang> aristid: Yeah, that's the problem. :-( 
19:31:39 <aristid> heh
19:31:49 <dolio> The reason I've seen to get rid of unfailable patterns is that if you have 'data Foo a b = Foo a b' your match is unfailable, but if you later add another constructor 'Bar a b', it is no longer unfailable.
19:31:58 <dolio> So that change breaks a lot of type signatures.
19:32:21 <copumpkin> ah
19:32:45 <dolio> But, instead, now, you silently fail.
19:32:51 <dolio> Which doesn't seem better to me.
19:33:03 <wli> Silent failure is evil.
19:33:18 <wli> If there is to be a failure, scream bloody murder.
19:33:27 <copumpkin> by the way, I was reading the paper "Inductive Families Need Not Store Their Indices" by conor mcbride and was wondering if haskell did neat tricks like that when possible with GADTs
19:33:49 <dolio> GHC doesn't store any indices. They're all types, which are erased.
19:33:52 <copumpkin> well, conor mcbride and edwin brady and james mckinna :)
19:34:02 <copumpkin> dolio: oh, that's nice
19:34:12 <copumpkin> I guess it makes sense, and is why it's nice to have the big separation of types and values
19:34:34 <dolio> Makes it easy, at least.
19:34:37 <copumpkin> dolio: but not just about storing, but about not checking constructors based on information introduced by other ones?
19:35:28 <dolio> I'd probably have to go reread the paper to know what you're talking about there.
19:35:31 <aristid> dolio: if there are unfailable patterns, is newtype unnecessary then?
19:36:06 <ddarius> copumpkin: I don't think that case applies to Haskell.  If it does, Haskell does still check all constructors.
19:36:43 <dolio> aristid: I don't really see the connection.
19:37:03 <aristid> dolio: with newtype, N x = undefined does not fail
19:37:15 <aristid> dolio: with unfailable patterns, that would not fail either, no?
19:37:25 <dolio> It would.
19:37:35 <aristid> so it's unfailable but fails anyways?
19:37:59 <copumpkin> ddarius: I think you can simulate their example in haskell, but now that I think of it, you can't pattern match :/
19:38:01 <dolio> Unfailable means there's no constructor that could make the pattern fail to match.
19:38:05 <dolio> It doesn't mean it's irrefutable.
19:38:09 <Saizan> copumpkin: iirc a case where GHC produced a segfaulting binary because it wrongly assumed a gadt constructor couldn't appear with that type
19:38:11 <copumpkin> so yeah, my question doesn't make sense
19:38:23 <copumpkin> Saizan: oh?
19:39:54 <dolio> aristid: The point is, if you have "do Just x <- m ; ..." and m yields a Nothing, you can fail in the monad.
19:40:21 <copumpkin> their example was vaguely equivalent to f :: n -> Vec A n -> ...
19:40:24 <dolio> aristid: if you have "do (x, y) <- m ; ..." and m gives undefined, the whole thing must be undefined anyway.
19:40:29 <aristid> dolio: so it's entirely about "would MonadZero make sense there"?
19:40:31 <dolio> But, if it's not undefined, it will always match.
19:40:35 <copumpkin> where f Z forces the next parameter to be []
19:40:45 <aristid> dolio: then i think unfailable patterns are the good way to do this:)
19:40:45 <dolio> Right. It's whether you need MonadZero.
19:40:49 <copumpkin> and F (S n) forces the next constructor to be (x : y)
19:43:39 <Wooga> hello, how can i avoid hugs crashing here: http://codepad.org/bYQ90b6Y ?
19:44:41 <ddarius> copumpkin: Since Haskell is lazy and Turing-complete, it has to force it's arguments to be sure a proof is actually a proof.
19:44:42 <Wooga> without adding if input == "NaN"a at #12 line
19:44:56 * EvanR just found a need for Maybe's monad
19:45:02 <EvanR> for the first time
19:45:03 <EvanR> yay
19:45:17 <dolio> You're in trouble if someone unsafeCoerces, too.
19:45:22 <roconnor> EvanR: congratz
19:45:26 <EvanR> lol
19:45:27 <roconnor> EvanR: you are now level2
19:45:28 <dolio> But I guess that's true anyway.
19:46:09 <EvanR> now to figure out how to use it
19:46:15 <copumpkin> ddarius: oh sure, but it could omit a tag check on one of the two (assuming pattern matching in such a situation were actually possible in haskell, which it isn't)
19:48:22 <dolio> copumpkin: You can do that with 'f :: forall n. Nat n -> Vec A n'.
19:48:38 <copumpkin> oh, where Nat n is a GADT?
19:48:47 <dolio> Right. It'd refine n.
19:48:47 <copumpkin> yeah, I guess it would work
19:48:58 <copumpkin> but it still doesn't omit the tag check?
19:49:06 <dolio> Don't know, probably not.
19:49:10 <copumpkin> I guess it isn't a very common situation in haskell
19:49:36 <roconnor> EvanR: Maybe was the key to my understanding of monads
19:49:54 <copumpkin> for me it was RWST
19:49:58 <copumpkin> :P
19:50:36 <dolio> copumpkin: With potential type system defeaters floating around, it'd probably be nice if GHC didn't catastrophically fail if someone did something fishy.
19:50:39 * BMeph doesn't remember if monads helped him understand continuations, or vice-versa...
19:50:41 <dolio> And just gave a pattern match error instead.
19:50:53 <copumpkin> dolio: I guess :)
19:51:44 <copumpkin>      primTrustMe : {A : Set} {x y : A}  x  y
19:52:23 <dolio> That actually decides equality.
19:52:27 <dolio> As I recall.
19:52:41 <dolio> And fails to reduce if it can't verify that they're equal.
19:52:44 <kmc> Wooga, i'm curious, why are you using hugs?
19:52:51 <copumpkin> it gives you a refl constructor, but it'll lie if you tell it to
19:53:07 <Wooga> kmc: not me, but codepad.org
19:53:12 <kmc> ok
19:53:15 <kmc> does it happen in ghci too?
19:53:19 <Wooga> no
19:53:21 <dolio> primTrustMe {Nat} {0} {1} isn't refl, is it?
19:54:00 <kmc> Wooga, how would checking for "NaN" help?
19:54:01 <copumpkin> dolio: I haven't actually used it, but in the release notes, it just says it'll take your word for it and give you a refl, and that if it isn't actually true it can lead to segfaults etc.
19:54:27 <Phyx-> anyone have an idea on how old www.haskell.org/cabal/proposal/pkg-spec.pdf is? there's no date
19:54:57 <Saizan> Phyx-: does it have Library and Executable sections?
19:54:57 <kmc> Wooga, ah, i see, you return a NaN on EOF to be parsed
19:55:04 <kmc> Wooga, it's bad to use special values like that as sentinels
19:55:14 <aavogt> Phyx-: http://web.archive.org/web/*/www.haskell.org/cabal/proposal/pkg-spec.pdf
19:55:24 <luite> Phyx-: the pdf creation date is august 1 2004
19:55:28 <kmc> better to return a (Maybe String) or even move the parsing inside
19:55:37 <Wooga> kmc: you can write process [] = if input == "NaN" then return () else doGuess num and it works untill user input "NaN"
19:55:50 <ezyang> So, what's an "intermediate construction"? 
19:56:05 <Phyx-> hrm, so it's too old to be useful
19:56:13 <Phyx-> *tries to find the current .cabal specs*
19:56:32 <kmc> Wooga, this logic is kind of convoluted
19:56:46 <Saizan> Phyx-: check the Cabal user guide, or maybe the source :)
19:57:12 <Wooga> kmc: what better then?
19:57:20 <kmc> Wooga, when you read a line, there's three possible outcomes right?
19:57:33 <kmc> either you get a number, you hit EOF, or there's a parse error
19:57:34 <Phyx-> Saizan: ty :)
19:57:44 <Wooga> kmc: yes
19:57:59 <dolio> copumpkin: 'foo : 0 == 1 ; foo = trustMe' normalizes to primTrustMe.
19:58:04 <kmc> so define a data type "Result" to represent those outcomes
19:58:06 <EvanR> > return 4
19:58:07 <lambdabot>   No instance for (GHC.Show.Show (m t))
19:58:07 <lambdabot>    arising from a use of `M4535454244...
19:58:13 <kmc> and an action "getNumber :: IO Result"
19:58:14 <EvanR> > return 4 :: Maybe Int
19:58:15 <lambdabot>   Just 4
19:58:22 <kmc> and then you can factor this part of the logic out of your guessing-game logic
19:58:40 <Wooga> kmc: oh, thank you!
19:58:47 <Saizan> dolio: maybe the bad things will happen only at runtime?
19:59:13 <dolio> Not sure. The stuff in the TrustMe module says it only evaluates to refl if x and y are definitionally equal.
19:59:14 <copumpkin> yeah, it says the compiler
19:59:15 <copumpkin> "Note that the compiler replaces all uses of primTrustMe with the REFL builtin, without any check for definitional equality. Incorrect uses of primTrustMe can potentially lead to segfaults or similar problems."
19:59:32 <dolio> Ah.
19:59:40 <dolio> So it's in the part I never use.
20:01:24 <copumpkin> same :)
20:03:25 <kmc> copumpkin, unsafeCoerce for agda? :O
20:04:22 <aidalgol> What module is NaN in?
20:04:30 <dolio> If that's what the compiler does, then yes.
20:04:42 <c_wraith> > 0 / 0
20:04:43 <lambdabot>   NaN
20:04:50 <c_wraith> It's not a real constructor
20:05:05 <c_wraith> It's just how certain floating-point values are represented
20:06:09 <solrize> y'all saw this purported p/=np proof?
20:06:55 <kmc> yeah
20:07:30 <kmc> it's a cool approach, using statistical physics to analyze solution space geometry
20:08:05 <kmc> physicists have a track record of actually solving problems which computer scientists dismiss as too hard
20:08:15 <kmc> physicists also have a track record of badly mangling mathematics
20:08:21 <lispy> Lots of people think they make progress on it; is this one more likely to be valid?
20:08:49 <kmc> it's certainly the case that a proof of P  NP wouldn't use well-known vanilla methods of complexity theory
20:08:49 <lispy> I haven't heard anything about it but I tend to ignore the proofs
20:08:53 <dolio> It's not obviously crackpot, at least, from what I've heard.
20:08:56 <kmc> (there are results to that effect)
20:09:07 <kmc> http://www.reddit.com/r/programming/comments/cytlp/serious_attempt_that_p_np_originally_posted_in/ has some good comments
20:09:30 <luite> have you already read it completely?
20:09:31 <ddarius> lispy: I'm sure you'll know for sure in a few years.
20:10:15 <dolio> Also, being P /= NP is probably a point in its favor.
20:10:19 * kmc has not read it and would not understand it if he did
20:10:55 <kmc> so if this is solved now, what's the new holy grail of complexity theory?
20:11:31 <kmc> BQP ?= NP?
20:11:43 <luite> perhaps the exponential time hypothesis?
20:12:58 <kmc> ETH implies that NP-complete problems take exponential time?
20:14:09 <lispy> ddarius: if only I had CPS in real-life
20:14:19 <luite> argh my keyboard is acting up
20:14:53 <kmc> lispy, for time travel?
20:15:01 <lispy> kmc: yes
20:15:04 <luite> kmc: that there is some constant c > 0 such that 3SAT with n clauses cannot be solved in O(2^(cn)) time
20:15:16 <lispy> "Just a minute.  I'll be back yesterday."
20:15:16 <luite> n variables
20:15:19 <luite> sorry
20:15:37 * kmc wonders if the difference between delimited continuations and regular continuations can be explained as the difference between _Primer_ and _Back to the Future_
20:16:22 <EvanR> haha
20:16:24 * ddarius should watch Primer again.
20:16:38 <EvanR> quote that
20:16:45 <luite> I'm not sure if it's really that important from a theoretical point of view, but I've seen it mentioned in papers few times
20:17:19 <luite> perhaps in most of those cases P /= NP would've been enough
20:17:37 <Veinor> luite: isn't that the same as O(c^n) time?
20:17:47 <Veinor> well... you get what I mean
20:17:55 <aidalgol> Can anyone decipher the errors in my code? <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28729#a28731>
20:17:56 <Veinor> 'there's a c > 0 so that it can't be solved in O(c^n) time'
20:18:25 <luite> yeah it's a constant :)
20:18:25 <Cale> Very few of the time travel scenarios in sci-fi really work out the way I would expect time travel to work.
20:18:25 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
20:18:30 <Wooga> kmc: sorry for asking again, but can you show me basic idea of testing if End Of File is reached? catch getLine (\err -> ...) can return only strings because of getLine's type, so, should i implement own getLine, which would be catching EOF situation ?
20:18:39 <kmc> aidalgol, that's a lot of code
20:18:43 <kmc> any chance you can cut it down?
20:18:50 <ddarius> Cale: I suspect the way you expect time travel to work would be rather boring theatrically.
20:19:09 <kmc> :t fmap Just getLine
20:19:10 <lambdabot> IO (Maybe String)
20:19:14 <kmc> Wooga, ^^^^
20:19:19 <Wooga> thanks
20:21:36 <kmc> aidalgol, usually you'd define new types for DB, Course, etc.
20:21:39 <Cale> ddarius: Indeed, though I think it might make for an interesting mystery if done right, where the in the end the solution is that the chain of causality has formed a perfect cycle, and that the time travel hasn't really *changed* anything, because it always was that way.
20:21:40 <EvanR> my code just collapsed thanks to Maybe and >>=
20:21:43 <kmc> you're using synonyms for existing types
20:22:06 <Cale> aidalgol: btw, minor style point:
20:22:07 <Cale> if foo
20:22:09 <Cale>    then bar
20:22:13 <Cale>    else quux
20:22:23 <Cale> is the usual way to lay out if/then/else
20:22:27 <EvanR> Cale: so far (im in the 4th season so far) thats how its happened in babylon 5
20:22:29 * ddarius does not that style.
20:22:30 <kmc> aidalgol, do you want more suggestions?
20:22:36 <EvanR> Cale: no one has changed history yet
20:22:42 * copumpkin doesn't use if then else
20:23:00 <EvanR> Cale: its also the way it happened in the TNG season 4 (i think) ender
20:23:09 <EvanR> with mark twain
20:23:12 <syntaxglitch> Cale: Ah, so time travel as "tying the knot", then?
20:23:12 <dolio> I use that style. Down with the do-if-then-else proposal!
20:23:19 <ddarius> case () of _ | foo = bar | otherwise = quux for copumpkin
20:23:26 <kmc> i church encode all my booleans
20:23:39 <ddarius> I avoid booleans.
20:23:57 <aidalgol> kmc: New types as opposed to what?
20:24:03 <kmc> aidalgol, synonyms for existing types
20:24:11 <kmc> which is what you have now
20:24:12 <ddarius> dolio: I don't want the do-if-then-else proposal and I don't use that style.
20:24:14 <EvanR> Cale: guinan (whoopie goldberg) actually mutters "full circle" when she realizes the loop ;)
20:24:18 <kmc> you'd use the keyword "data" or "newtype" instead of "type"
20:24:21 <kmc> but perhaps you haven't learned those yet
20:24:23 <aidalgol> Oh, well that part was given to me, so I have no choice.
20:24:27 <kmc> or perhaps your assignment says not to
20:24:28 <kmc> ah, ok
20:24:35 <dibblego> what's do-if-then-else?
20:24:35 <kmc> so, other suggestions then?
20:24:39 <dolio> ddarius: What do you do?
20:24:52 <dolio> dibblego: It lets you lay out if then and else all in the same column in a do block.
20:24:52 <copumpkin> ddarius: I don't even find myself using guards that much
20:24:56 <kmc> dibblego, to allow if p; then x; else y
20:25:04 <kmc> dibblego, for purposes of allowing if / then / else to all be flush in a "do" layout
20:25:12 * aidalgol makes minor tweaks.
20:25:15 <dibblego> ah right
20:25:57 <BMeph> Cale: Have you seen "Red vs. Blue"? ;)
20:26:35 <Cale> syntaxglitch: Essentially, yeah. If you happen to be successful in going back in time, then it means that you always had been successful in going back in time. In this way of handling it there's only one constant universal space-time, it just happens to have time-like loops in it.
20:26:37 <aidalgol> Can someone help me understand what the errors on 56:19 and 62:15 are?
20:26:56 <ddarius> dolio: I keep the then on the first line and (assuming I add a line break) I indent the else slightly, but it rarely comes up.  Usually I don't use if-then-else and when I do its on one line or it is two lines with the else lined up with the then.
20:27:10 <EvanR> is it customary to use "Just" or "return" when dealing with Maybe monadic 'action'
20:27:15 <aidalgol> (I pasted the output of ghci as well, so you just have to read the paste.)
20:27:18 <ddarius> Use return.
20:27:26 <dolio> Yeah, I don't use if-then-else very often either, really.
20:27:26 * syntaxglitch recommends "pure"
20:27:28 <syntaxglitch> :)
20:28:04 <Cale> aidalgol: You forgot the first parameter to whoLectures in the recursive call
20:28:04 <kmc> aidalgol, you can (and probably should) rewrite both whoLectures and credits to use some common function
20:28:06 <kmc> note how similar the code is
20:28:30 <ddarius> :t \f x y -> liftA2 (fmap f x) (return y)
20:28:31 <lambdabot> forall a b c a1 (f :: * -> *). (Monad f, Applicative f) => (a -> b -> c) -> (a1 -> a) -> a1 -> f b -> f c
20:28:36 <aidalgol> Ah, thanks!
20:28:37 <ddarius> Curses.
20:28:39 <kmc> aidalgol, you might use filter, or Data.List.find
20:28:44 <dancor> do you want to restate your maybeness for clarity, broadcast your monadic-reusability, save two characters?
20:28:47 <ddarius> Stupid Applicative have a Functor super class constraint.
20:28:48 * aidalgol refactors his code.
20:29:16 <kmc> aidalgol, note also that both of those functions will throw an unhelpful exception if the entry is not found
20:29:21 <kmc> (because you left out a [] case on each)
20:29:28 <Cale> :t \f x y -> liftA2 (fmap f x) (pure y)
20:29:29 <lambdabot> forall a b c a1 (f :: * -> *). (Applicative f) => (a -> b -> c) -> (a1 -> a) -> a1 -> f b -> f c
20:29:30 <EvanR> dancor: eh?
20:29:36 <kmc> if you want to keep that behavior, use filter with head, or Data.List.find with Data.Maybe.fromJust
20:29:37 <copumpkin> :t \f x y -> liftM2 (fmap f x) (pure y) -- might as well put them all in
20:29:38 <lambdabot> forall a a2 r a1 (m :: * -> *). (Applicative m, Monad m) => (a -> a2 -> r) -> (a1 -> a) -> a1 -> m a2 -> m r
20:29:46 <kmc> it's probably better to pattern-match and throw a more useful exception, or return a Maybe value
20:29:58 <syntaxglitch> bah, partial functions
20:30:03 <syntaxglitch> burn them all
20:30:14 <EvanR> safeHead ;)
20:30:25 <ddarius> @hoogle uncons
20:30:25 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
20:30:25 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
20:30:25 <lambdabot> Data.ByteString.Lazy uncons :: ByteString -> Maybe (Word8, ByteString)
20:30:45 <syntaxglitch> I don't know why fromJust even exists >:[
20:30:52 <copumpkin> if you're sure!
20:31:12 <ddarius> syntaxglitch: We use it to find the sinners.
20:31:18 <kmc> :t fromMaybe . error
20:31:19 <lambdabot> forall a. [Char] -> Maybe a -> a
20:31:23 <kmc> might be better
20:31:25 <EvanR> i almost 'was sure' but decided i didnt want to depend on the other side of the program being correct or ordered in just the right way
20:31:33 <EvanR> so i use >>= instead
20:31:42 <ddarius> if isJust x then fromJust x else d -- smells like C
20:31:49 <aidalgol> kmc: How would filter be helpful here?
20:32:21 <EvanR> Maybe is amazing
20:32:27 <kmc> credits title courses = head (filter (\course -> courseName course == title) courses)
20:32:45 <ddarius> @pl  credits title courses = head (filter (\course -> courseName course == title) courses)
20:32:45 <lambdabot> credits = (head .) . filter . (. courseName) . (==)
20:32:51 <ddarius> Much clearer.
20:33:02 <kmc> aidalgol, hmm, why don't you write a function which returns the whole Course given the title
20:33:02 <aavogt> EvanR: that might be worse... if you _know_ it can't fail there, you might avoid some puzzling bugs when the code doesn't behave correctly (but doesn't crash)
20:33:12 <kmc> then you can just compose the selectors "courseCredits" and "courseLecturers"
20:33:15 <aidalgol> kmc: That's what I'm doing now. :)
20:33:46 <EvanR> aavogt: id rather have a choice, leave the non sense in the IntMaps or remove it to save space
20:33:49 <copumpkin> > isJust copumpkin
20:33:51 <lambdabot>   True
20:33:57 <copumpkin> indeed
20:34:05 <aavogt> > copumpkin
20:34:06 <kmc> findCourse title courses = head . filter ((== title) . courseName)
20:34:07 <lambdabot>   Just (Just (Just (Just (Just (Just (Just (Just (Just (Just Nothing)))))))))
20:34:23 <aavogt> rather just
20:34:28 <kmc> > fix (In . Just)
20:34:29 <lambdabot>   No instance for (GHC.Show.Show (L.Mu Data.Maybe.Maybe))
20:34:29 <lambdabot>    arising from a u...
20:34:38 <EvanR> @src Rather
20:34:38 <lambdabot> Source not found. My brain just exploded
20:34:43 <copumpkin> kmc: I was tempted to write that, but then isJust wouldn't have worked :(
20:35:14 <aidalgol> What's a good result for the case of an empty list? (i.e. courseNamed _ [] =)
20:35:14 <ddarius> :t Just . In
20:35:16 <lambdabot> forall (f :: * -> *). f (Mu f) -> Maybe (Mu f)
20:35:23 <ddarius> :t fix (Just . In)
20:35:25 <lambdabot> Maybe (Mu Maybe)
20:35:29 <kmc> aidalgol, if your type signature makes you return a Course
20:35:38 <kmc> then you have no reasonable choice other than calling "error"
20:35:50 <kmc> but if your type signature could specify, say, (Maybe Course)
20:35:52 <kmc> then you can return Nothing
20:36:04 <kmc> @let isGoodManAndThorough = isJust
20:36:06 <lambdabot>  Defined.
20:36:10 <kmc> > isGoodManAndThorough copumpkin
20:36:11 <lambdabot>   True
20:36:16 <Veinor> :D
20:36:18 <copumpkin> lol
20:37:01 * copumpkin bows
20:37:03 <copumpkin> thank you thank you
20:37:10 <kmc> the instance of Show for (Mu f) has a fun, undecidable-instances form
20:37:48 <kmc> sets up a mutual recursion between the Mu and 'f' instances
20:38:15 <copumpkin> you can ask GHC to derive it for you, with a trick
20:38:17 <kmc> it's impressive that GHC handles classes well enough to tie this knot despite the set of instances being open
20:38:19 <ddarius> Yeah, writing the Show instance is a pain.
20:38:21 <kmc> really copumpkin?
20:38:46 <solrize> there's some discussion of that p/np paper at rjlipton.wordpress.com  (rj lipton = complexity theorist)
20:39:20 <copumpkin> kmc: let me see if I can remember how to do it :P
20:40:59 <nettok> Inspired by this post http://www.mostlymaths.net/2010/08/and-e-appears-from-nowhere.html, I implemented the code in haskell, but why is it so slow? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28736#a28736
20:41:01 <EvanR> i love it when you refactor a lot of code (say, in one module) fix some minor references to it in other modules, and everything still works the way it did before
20:41:35 <kmc> nettok, did you compile with ghc --make -O2?
20:41:57 <kmc> nettok, also, you're using the default RNG in System.Random
20:41:59 <kmc> it's quite slow
20:42:11 <kmc> (most language implementations' default generators are)
20:42:16 <nettok> kmc: RNG?
20:42:20 <kmc> random number generator
20:42:58 <kmc> look on hackage for mersenne-random, mwc-random, etc.
20:43:01 <kmc> for faster RNGs
20:43:06 <nettok> kmc: also when I make more than 10000000 there's an stack overflow, while in the clojure example the author says it takes 34 seconds
20:43:11 <kmc> yeah
20:43:16 <kmc> did you compile with ghc --make -O2?
20:43:30 <copumpkin> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28737#a28737
20:43:30 <nettok> kmc: yeah, i compiled with -O2
20:43:34 <Saizan> nettok: the overflow is because you're not sufficiently strict on avg
20:43:51 <kmc> nettok, did you profile?
20:43:57 <kmc> copumpkin, yeah
20:44:07 <kmc> it's a cute demo for StandaloneDeriving
20:44:16 <nettok> kmc: not profiled yet, I am noob
20:44:25 <kmc> nettok, ah, RWH has a good chapter on it
20:44:35 <nettok> Saizan: how can I make it more strict?
20:44:45 <kmc> in general Haskell code can be made pretty fast, but it takes lots of skill and experience to learn how
20:45:25 <kmc> so unfortunately beginner code will usually be much slower than most other languages (assuming good compilers)
20:45:35 <Saizan> nettok: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28736#a28738
20:45:37 <kmc> beginner code might reliably beat CPython or ruby interpreters, though
20:45:44 <nettok> I'll check out the other RNG
20:46:34 <kmc> with appropriate strictness, GHC should unbox all these doubles
20:46:35 <nettok> Saizan: that's new to me
20:46:57 <nettok> I'll check it out thanks
20:48:00 <kmc> nettok, btw you can run with "./myprog +RTS -s" to get some performance stats easily
20:48:03 <kmc> including % time spent in GC
20:48:36 <nettok> kmc: Ok.  How do I profile?
20:48:48 <etpace> -p -hc is a good place to start
20:49:01 <kmc> nettok, read the chapter in RWH about profiling
20:49:04 <kmc> @where RWH
20:49:04 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:49:06 <nettok> ok
20:49:24 <kmc> nettok, btw (unrelated to performance i think) you have a few functions that just invoke helpers with some starting arguments
20:49:30 <kmc> in those cases it's more common to put the helpers in a "where" block
20:49:36 <Saizan> those $!s should already fix most of your problems
20:50:59 <kmc> nettok, it looks like you're favoring a tail-recursive style, perhaps for performance, but tail recursion in Haskell is different from in strict languages
20:51:10 <kmc> you can end up building a huge chain of unevaluated thunks in the accumulator position
20:51:18 <kmc> which could overflow the heap right away, or overflow the stack when evaluated
20:51:21 <copumpkin> bedtime for me
20:51:27 <kmc> the stack is a stack of pattern-matches and value forcings, not of function calls
20:51:53 <aidalgol> Now I have a problem with a tricky expression: <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28739#a28739> (in meanGrade)
20:52:12 <kmc> nettok, perhaps you can rewrite avgTimes using replicateM
20:52:32 <nettok> Saizan: $! solved the stack overflow, thanks
20:52:48 <dibblego> does (Monad m) default to IO in ghci?
20:53:14 <kmc> dibblego, it's not defaulting, but the GHCi prompt "do block" is forced to be IO, yes
20:53:27 <kmc> aidalgol, did you mean (gradeToInt . studentGrade) ?
20:53:34 <kmc> (x $ y) is the same as (x y)
20:53:38 <dibblego> kmc, I have a value :: m a and I expected it to which about MR
20:53:52 <kmc> (x . y) is \z -> (x (y z))
20:53:55 <kmc> @src ($)
20:53:55 <lambdabot> f $ x = f x
20:53:55 <kmc> @src (.)
20:53:56 <lambdabot> (f . g) x = f (g x)
20:53:56 <lambdabot> NB: In lambdabot,  (.) = fmap
20:54:14 <nettok> kmc: mmm... didn't know about the issue with tail recursion, I thought it would be optimized by the compiler
20:54:15 <aidalgol> Maybe I did.  Is (f . g) ... the same as f (g ...)?
20:54:57 <kmc> nettok, it's a different issue than the one normally solved by TCO
20:56:29 <aidalgol> OK, I did mean . (dot), then.
20:56:54 <aidalgol> Now it's complaining "Couldn't match expected type `[Float]' against inferred type `Int'" in ((sum grades) / (length grades))
20:57:20 <kmc> :t length
20:57:22 <lambdabot> forall a. [a] -> Int
20:57:24 <kmc> length always returns an Int
20:57:34 <aidalgol> Ah, I see.
20:57:42 <aidalgol> I didn't code what I meant.
20:57:48 <kmc> :t fromIntegral
20:57:50 <lambdabot> forall a b. (Integral a, Num b) => a -> b
20:57:52 <kmc> ^^^^ to convert
20:57:56 <kmc> or, use Data.List.genericLength
20:58:31 <aidalgol> That won't get me a list, either. :P
20:58:39 <steshaw> Hi, I'm going through RWH and having surprising trouble implementing mean/average over a list
20:59:13 <ezyang> steshaw: What have you tried so far? 
20:59:30 <steshaw> I've initially got it working with Fractionals only and then with two separate functions, one for Fractionals and one for Integrals
20:59:44 <steshaw> Please take a look at http://github.com/steshaw/playground/blob/master/haskell/realworldhaskell/Chapter3.hs
21:00:12 <steshaw> I'm trying to create a typeclass ToFractional so that i can have a general function for mean over numbers
21:00:17 <kmc> steshaw, sum should work on any Num type (Fractional and Integral alike)
21:00:23 <kmc> then you can call fromIntegral on the result of "length"
21:00:28 <kmc> or you can use Data.List.genericLength
21:01:18 <steshaw> kmc: thanks I'll try genericLength
21:01:21 <kmc> :t \xs -> sum xs / fromIntegral (length xs)
21:01:23 <lambdabot> forall a. (Fractional a) => [a] -> a
21:01:30 <kmc> hmm
21:01:47 <steshaw> yeah, that's the same signature as one of my functions
21:01:59 <steshaw> my other one works for Integrals
21:02:08 <kmc> right
21:02:17 <kmc> well, what should the result be if you sum a list of Int?
21:02:27 <aidalgol> This is more like what I want (a list of Floats) <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28739#a28740>, but an Int is sneaking in somehow.
21:02:30 <steshaw> I've got something going with a bizarre typeclass but I had to enable some extensions that ghci told me about
21:02:42 <kmc> do you want to truncate, or convert the Int to some other type?
21:03:06 <kmc> aidalgol, as before, "length" returns an Int
21:03:33 <aidalgol> kmc: But shouldn't the / return a Float?
21:03:38 <steshaw> kmc, I don't want to truncate
21:03:48 <steshaw> the / works on Fractionals
21:03:56 <aidalgol> Oh...
21:03:56 <kmc> :t (/)
21:03:58 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:04:01 <aidalgol> :t div
21:04:01 <kmc> aidalgol, there's no automatic conversions in Haskell
21:04:02 <dibblego> hey steshaw 
21:04:03 <lambdabot> forall a. (Integral a) => a -> a -> a
21:04:03 <kmc> (thank god)
21:04:10 <aidalgol> Yes, thank god.
21:04:24 <aidalgol> That's one really nice thing about Erlang.
21:04:57 <kmc> steshaw, well, "sum this list and convert the result to Double" is a different function from "sum this list and leave it the same type as the elements"
21:05:01 <aidalgol> In Ruby, I'd often say "what?!  But accepted that other type!"
21:05:15 <aidalgol> :t `div`
21:05:16 <lambdabot> parse error on input ``'
21:05:19 <aidalgol> :t div
21:05:20 <lambdabot> forall a. (Integral a) => a -> a -> a
21:06:17 <kmc> steshaw, so i think it's fine to have two functions, and it's probably an abuse of type classes to try to make them have the same name
21:06:54 <steshaw> kmc, hmmm perhaps
21:07:09 <kmc> perhaps ToFractional should be in the standard library
21:07:21 <EvanR> why is averaging the single most popular function for people to have problems with
21:07:26 <kmc> the numeric class hierarchy is kind of a mess
21:07:59 <aidalgol> I was getting thrown off by ghci accepting 3/4, 7/2 and such.
21:08:08 <kmc> :t 3
21:08:09 <lambdabot> forall t. (Num t) => t
21:08:13 <kmc> :t 3 :: Double
21:08:14 <steshaw> kmc, I haven't looked at the number hierarchy much yet so it's quite confusing to me at the mo :)
21:08:14 <lambdabot> Double
21:08:21 <ddarius> kmc: Fixing it wouldn't make average any better looking.
21:08:24 <aidalgol> What do I use instead in a program?
21:08:30 <EvanR> :t 3/7
21:08:32 <lambdabot> forall t. (Fractional t) => t
21:08:34 <kmc> aidalgol, instead of what?
21:08:52 <aidalgol> kmc: slash
21:09:00 <kmc> for what?
21:09:05 <aidalgol> Uhh...
21:09:05 <kmc> :t (/)
21:09:06 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:09:08 <kmc> :t div
21:09:09 <lambdabot> forall a. (Integral a) => a -> a -> a
21:09:16 <EvanR> :t quot
21:09:17 <lambdabot> forall a. (Integral a) => a -> a -> a
21:09:17 <kmc> the latter truncates
21:09:24 <EvanR> \o/
21:09:28 <aidalgol> Let's start over: <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28739#a28740>
21:09:32 <aidalgol> What's wrong here?
21:09:42 <kmc> what's wrong here is that you can't divide a Float by an Int
21:09:49 <kmc> you can tell this from the type signature of (/):
21:09:49 <aidalgol> Oh...
21:09:51 <kmc> :t (/)
21:09:53 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:09:58 <aidalgol> I thought I had two Ints.
21:10:01 <kmc> it requires both arguments to have the same type
21:10:08 <kmc> oh hmm
21:10:19 <kmc> maybe that's not the problem
21:10:34 * kmc reads more carefully
21:10:44 <kmc> yeah, the problem is that you have an Int not a Float
21:10:54 <kmc> but you've declared that meanGrade returns [Float]
21:11:17 <kmc> it's *also* a problem that you can't divide two ints with (/)
21:11:19 <kmc> but it doesn't get there yet
21:11:40 <kmc> sorry for the confusion earlier
21:12:04 <steshaw> some else working on averaging?
21:12:21 <steshaw> you can using fromIntegral to convert from int to fractional I think
21:12:53 <EvanR> @faq can haskell take the average of a list of numbers
21:12:53 <lambdabot> The answer is: Yes! Haskell can do that.
21:13:07 <EvanR> (with great duress) ;)
21:13:53 <steshaw> EvanR, the difficulty is very surprising. This is a beginners exercise from RWH
21:14:58 <BMeph> aidalgol, steshaw: You might have better results by using Rationals instead. YMMV.
21:15:20 <EvanR> > let xs = map fromIntegral [1,2,3,4,5] in sum xs / genericLength xs
21:15:21 <lambdabot>   3.0
21:15:24 <EvanR> yay
21:15:44 <ddarius> EvanR: That's a silly way of doing it.
21:15:49 <EvanR> yes
21:15:59 <BMeph> > let xs = map toRational [1,2,3,4,5] in sum xs / genericLength xs
21:16:00 <lambdabot>   3 % 1
21:16:20 <EvanR> but it does work for any Num
21:16:26 <EvanR> and gives any Fractional
21:16:39 <ddarius> EvanR: So does doing the fromIntegral after the sum.
21:16:42 <EvanR> yes
21:16:51 <ddarius> It will also, arguably be more correct.  
21:16:53 <EvanR> i just didnt want to use parentheses ;)
21:17:28 <ddarius> let s = sum xs in fromIntegral s / genericLength xs
21:18:12 <EvanR> :t genericLength
21:18:14 <lambdabot> forall b i. (Num i) => [b] -> i
21:18:28 <nettok> "5,358,428,080 bytes allocated in the heap"  Isn't that too much?
21:18:36 <EvanR> lol
21:18:42 <EvanR> 5G
21:18:46 <ddarius> nettok: The amount allocated isn't the amount live.
21:19:03 <nettok> ddarius: ok
21:19:33 <nettok> but the program just ran for 6 seconds
21:19:45 <ddarius> Haskell programs tend to burn through heap.
21:19:55 <ddarius> And 6 seconds is a long time.
21:20:28 <aidalgol> Uh, yeah, rationals will help. <_<
21:20:29 <ddarius> However, it is quite possible that your program is less than optimal.
21:20:34 <aidalgol> not
21:20:40 <kmc> nettok, most values you create live in the heap and take at least 2 machine words
21:20:47 <kmc> most of them are short-lived
21:21:00 <nettok> ddarius: I am sure my program is not optimal
21:21:06 <kmc> which is why GHC uses a generational garbage collector, and a minor heap with fast allocation
21:21:19 <steshaw> You can't map fromIntegral over your list to implement a generic mean function because fromintegral only works on Integrals
21:21:35 <kmc> and a "nursery" for new small objects
21:22:13 <steshaw> @type fromIntegral
21:22:15 <lambdabot> forall a b. (Integral a, Num b) => a -> b
21:22:21 <steshaw> @info Integral
21:22:21 <lambdabot> Integral
21:22:23 <EvanR> > 4.5 `div` 2
21:22:25 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:22:25 <lambdabot>    `GHC.Real.Integral a'
21:22:25 <lambdabot>   ...
21:22:38 <EvanR> steshaw: right...
21:22:47 <EvanR> map or not fromIntegral on the sum wont work
21:22:48 <Axman6> :t toInteger
21:22:50 <lambdabot> forall a. (Integral a) => a -> Integer
21:22:55 <Axman6> hmm
21:23:03 <EvanR> :t toFractional
21:23:05 <lambdabot> Not in scope: `toFractional'
21:23:31 <steshaw> I implemented it with (fromRational . toRational)
21:23:51 <ddarius> :t realFrac
21:23:52 <lambdabot> Not in scope: `realFrac'
21:23:55 <Phyx-> does GHC allow you to run some last ditch function when the RTS is terminating? like in case of a panic?
21:23:56 <ddarius> :t realToFrac
21:23:57 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
21:24:25 <steshaw> ddarius, that looks good
21:24:30 <EvanR> > realToFrac 4 :: Double
21:24:32 <lambdabot>   4.0
21:24:42 <EvanR> > realToFrac (4::Int) :: Double
21:24:43 <lambdabot>   4.0
21:25:07 <EvanR> > sin (4::Int)
21:25:09 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
21:25:09 <lambdabot>    arising from a use of...
21:25:14 <EvanR> wrong one
21:26:02 <EvanR> Real has toRational and thats it?
21:26:24 <EvanR> what kind of name is that for the class then ;)
21:26:47 <ddarius> @instances Real
21:26:48 <lambdabot> Double, Float, Int, Integer
21:27:11 <EvanR> > toRational (4::Word)
21:27:12 <lambdabot>   4 % 1
21:27:47 <ddarius> :t avg xs = realToFrac (sum xs) / genericLength xs
21:27:49 <lambdabot> parse error on input `='
21:27:56 <ddarius> :t let avg xs = realToFrac (sum xs) / genericLength xs in avg
21:27:57 <lambdabot> forall a b. (Fractional b, Real a) => [a] -> b
21:28:42 <EvanR> let it be set in stone
21:28:57 <steshaw> Exactly, i have:
21:29:01 <steshaw> mean4 :: (Real a, Fractional b) => [a] -> b
21:29:03 <steshaw> mean4 xs = (realToFrac $ sum xs) / (len4 xs)
21:29:21 <steshaw> Doesn't require my weird ToFractional typeclass. Thanks guys!
21:29:23 <ddarius> That's still a bad definition for performance reasons.  Namely, it retains xs.
21:29:42 <EvanR> how so
21:30:28 <ddarius> EvanR: It has to hold onto xs until it finishes summing so that it can perform length (or vice versa.)  So all of xs will need to be in memory. 
21:30:43 <ddarius> (Technically it is legal and possible for them to be executed in parallel which could avoid this issue.)
21:31:19 <EvanR> so any function that operates on a list should only use it in one place to avoid that?
21:32:10 <ddarius> If you can process data in a streaming way without loss of performance, then you should (from a performance perspective.)
21:32:32 <EvanR> so to get streaming only use the list in one place
21:32:40 <ddarius> It's not that simple.
21:33:13 <steshaw> ddarius, I suppose you could calculate the sum and the count/length in one pass folding from the left even
21:33:29 <steshaw> is that what you're getting at?
21:33:30 <ddarius> steshaw: Yes, you can do it in one pass.
21:33:58 <ddarius> That would solve the list retention problem.
21:40:34 <Cale> Another thing you can do is to use par, though that's not quite so reliable.
21:41:22 <Cale> (but even on uniprocessors, tends to also do something about the memory retention, because the length and sum can be computed in parallel, and the head of the list will then become garbage sooner)
21:44:43 * hackagebot binembed 0.1 - Embed data into object files.  http://hackage.haskell.org/package/binembed-0.1 (ClaudeHeilandAllen)
21:45:45 * hackagebot binembed-example 0.1 - Example project using binembed to embed data in object files.  http://hackage.haskell.org/package/binembed-example-0.1 (ClaudeHeilandAllen)
21:45:48 <kmc> let x = sum xs; y = genericLength xs in x `par` y `pseq` (x / y) -- like so?
21:46:46 <Phyx-> :r
21:48:40 <wli> @type foldr (\x (s, l) -> (s + x, l + 1)) (0, 0)
21:48:41 <lambdabot> forall a t. (Num a, Num t) => [a] -> (a, t)
21:49:15 <wioux> :t par
21:49:16 <lambdabot> forall a b. a -> b -> b
21:49:27 <Phyx-> @unpl map (pprTypeForUser False . varType &&& ((text "\n-- " <>) . pprDefnLoc . getSrcSpan)) ids
21:49:28 <lambdabot> map (\ d -> pprTypeForUser False ((varType &&& \ g -> (text "\n-- ") <> (pprDefnLoc (getSrcSpan g))) d)) ids
21:49:39 <Phyx-> @pl map (pprTypeForUser False . varType &&& ((text "\n-- " <>) . pprDefnLoc . getSrcSpan)) ids
21:49:40 <lambdabot> map (pprTypeForUser False . varType &&& (text "\n-- " <>) . pprDefnLoc . getSrcSpan) ids
21:49:47 <Phyx-> lol
21:51:01 <Axman6> i think from now on, if someone asks what @pl does, i will tell them it perlifies haskell, making it as unredable and as concise as possible
21:51:43 <kmc> hahaha
21:51:44 <Phyx-> lol, was that a swing at my code? :P
21:52:04 <Axman6> no, yours was mostly untouched luckily
21:52:11 <Axman6> it is unperlifyable
21:52:24 <Phyx-> lol
21:53:19 * BMeph prefers the more PC "Perl-resistant"... ;
21:53:32 <Phyx-> which sounds better "locally scoped" or "local variable" ?
21:54:03 <Axman6> BMeph: heh
21:55:18 <Phyx-> and all through the land all was quiet
21:55:18 <Phyx-> :P
21:55:59 <kmc> Phyx-, context?
21:56:40 <Phyx-> refering to a local variable, indicating that it's not valid outside the scope of the current function
21:56:47 * hackagebot improve 0.0.2 - An imperative, verifiable programming language for embedded applications.  http://hackage.haskell.org/package/improve-0.0.2 (TomHawkins)
21:58:47 <Phyx-> odd
21:58:52 <Phyx-> ghci loads a file
21:58:58 <Phyx-> but ghc complains
21:59:08 <Phyx-> "Ambiguous infix expression"
21:59:13 <Phyx-> but doesn't say where
21:59:21 <kmc> i would say "local variable"
21:59:23 <c_wraith> is there TH in the file?
21:59:58 <Phyx-> kmc: ok, i'll use that
21:59:59 <Phyx-> c_wraith: nope
22:00:20 <Phyx-> it has tobe refering to 
22:00:21 <Phyx-> (pprTypeForUser False . varType &&& ((<> text " (local)") . (text "\n-- " <>) . pprDefnLoc . getSrcSpan))
22:00:27 <Phyx-> which is the only thing that changed
22:01:00 <Phyx-> but it's weird, ghci has no issues with it
22:02:02 <ddarius> I suspect your GHCi has an extension enabled that is not enabled for ghc.
22:03:29 <Phyx-> hrm, maybe it's not ghc at all,maybe it's my tool
22:03:44 <Phyx-> what could cause a haskell program to spit out
22:03:53 <Phyx-> hs2lib.exe: Ambiguous infix expression
22:05:08 <Phyx-> why do i keep running into the weird stuff
22:05:35 <Saizan> are you using a parsing lib?
22:05:48 <Phyx-> no, the ghc api and haskell-src exts
22:06:13 * Saizan bets on haskell-src-exts
22:06:31 <Phyx-> it doesn't like something here
22:06:32 <Phyx-> http://phyx.pastebin.com/XjSU2FKj
22:07:22 <Phyx-> ah, found it
22:07:27 <BMeph> Phyx-: Well, you know what they say about the weird stuff... ;)
22:07:38 <ddarius> Probably the $+$
22:07:43 <Phyx-> it wants parenthesis around ((expr) &&& (expr))
22:08:07 <Phyx-> it's priorities for &&& is wrong
22:08:19 <Phyx-> BMeph: actually i have no idea :P
22:09:24 <Phyx-> probably because it doesn't know the fixity of (&&&) right?
22:09:33 <Saizan> yeah
22:09:53 <Saizan> there should be a way to inform it, iirc
22:11:14 <Phyx-> no idea, it's a minor inconvenience, although it could be hardcoded in, store the standard fixity for commonly used operators
22:11:27 <Phyx-> bet it already does something like that, just not for &&&
22:12:41 <Saizan> http://hackage.haskell.org/packages/archive/haskell-src-exts/1.9.0/doc/html/Language-Haskell-Exts-Annotated-Fixity.html <- 
22:12:47 <Phyx-> does anyone know if there's a way to subscribe to the an event that the RTS is terminating?
22:13:32 <Phyx-> ah, cool
22:13:39 <Phyx-> @fixity (&&&)
22:13:39 <lambdabot> Unknown command, try @list
22:14:16 <Phyx-> 3
22:15:01 <Saizan> it's included in baseFixities, btw
22:17:01 <Phyx-> ah, ty
22:17:12 <danportin> :t point
22:17:14 <lambdabot> Not in scope: `point'
22:19:16 <danportin> Hm: I have a Functor instance of 'Tree a = Node a [Tree a]' but apparently 'point = \e -> Node e []
22:19:23 <danportin>  is incorrect?
22:21:10 <Phyx-> danportin: i don'tget it, could you elaborate?
22:21:59 <kmc> pointed functor?
22:22:23 <kmc> that seems the right definition for making Tree a pointed functor
22:22:28 <danportin> I have a Functor (for pedagogical purposes) instance of Tree, and want to declare a Pointed instance. The method should 'point' should have the type (Pointed f) => a -> f a where f is also a Functor.
22:22:36 <kmc> but there's no "Pointed" class in the standard library
22:22:47 <danportin> yeah, I have Control.Functor.Pointed imported.
22:23:01 <kmc> the method point should have the type a -> Tree a
22:23:06 <kmc> within your instance declaration
22:24:33 <kmc> danportin, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28744#a28744 works for me
22:25:29 <tkahn6> kmc: you seem to be missing  in your .XCompose, you can add this line if you want it: <Multi_key> <n> <equal> : "" U2260
22:25:56 <kmc> my machine already has it in the system file i think
22:26:02 <danportin> Interesting @kmc. Our code is identical, but I am having 
22:26:03 <kmc> as Compose / =
22:26:24 <tkahn6> oh cool
22:26:27 <tkahn6> mine doesn't :p
22:26:39 <danportin> "ambiguous type variable 'f' in the constraint: 'Point f' arising from a use of 'point' at ..."
22:26:48 <danportin> Wierd.
22:26:59 <kmc> actually identical danportin?
22:27:04 <dark> <Multi_key> <n> <equal> is which key combination, tkahn6?
22:27:13 <kmc> you're using ghc? which version?
22:27:35 <tkahn6> your multikey (mine is left-alt+menu), n-key and =-key
22:27:40 <danportin> Well, identical except that I put parentheses around 'map (fmap f) xs' and lambda'd x into point
22:27:58 <dark> tkahn6, what is the default key?
22:27:59 <kmc> danportin, well, when i type point 3 at the prompt i get that error
22:27:59 * BMeph notes that danportin's point definition matches "pure" and "return"...
22:28:05 <dark> multikey
22:28:12 <tkahn6> I don't exactly remember
22:28:13 <tkahn6> https://help.ubuntu.com/community/ComposeKey
22:28:17 <kmc> BMeph, as it's supposed to
22:28:25 <kmc> danportin, but that's to be expected, there is a legitimate ambiguity
22:28:30 <kmc> point 3 :: Tree Int works
22:28:33 <danportin> I thought return /is/ point?
22:28:36 <danportin> for monads?
22:28:38 <tkahn6> it's saying Shift-RightAlt
22:28:39 <kmc> yeah
22:28:58 <dark> thanks =)
22:29:01 <kmc> in an ideal world,  Functor  Pointed  Applicative  Monad  form a hierarchy
22:29:01 <tkahn6> :)
22:29:12 <danportin> Ah, okay, that works kmc. :)
22:29:20 <kmc> and Applicative only defines (<*>), and Monad only defines (>>=) (or join)
22:29:46 <dark> kmc, i thought monad defined return, join and bind
22:29:59 <dark> or join and bind
22:29:59 <EvanR> lol "Since lists are an instance of monads, you can get LC in terms of do notation. Because of this, several haskell programmers consider the list comprehension unnecessary now."
22:29:59 <kmc> you don't need to define return
22:30:13 <kmc> if you have Pointed as a superclass
22:30:15 <tkahn6> kmc posted his .XCompose file here. it's what i'm using: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28583#a28745
22:30:22 <danportin> besides, "point" sounds cooler than return
22:30:26 <kmc> and you don't need both join and bind
22:30:30 <kmc> you need only one, plus fmap
22:30:35 <kmc> EvanR, whence?
22:30:50 <EvanR> several haskell programmers, like ... four? ;)
22:30:51 * kmc misread LC as "lambda calculus" and thought it to be nonsensical
22:31:17 <kmc> EvanR, a lot of us want to go back to monad comprehensions
22:31:32 <kmc> that is, an alternate syntax for do, rather  than an alternate syntax which is also type-restricted
22:31:35 <EvanR> so it really does mean several as in 'not many'
22:31:40 <dark> tkahn6, include "%L"?
22:32:00 <tkahn6> dark: i removed it from my file.
22:32:23 <EvanR> its just funny to see several used to mean many when theres got to be like over a 100 haskell programmers ;)
22:33:09 <tkahn6> oh, also add this to your .gnomerc: export GTK_IM_MODULE="xim"
22:33:23 * kmc ponders how to write Applicative Tree
22:33:26 <kmc> "trees with grafting"
22:33:27 <cncl> what the hell, i go to sleep, wake up, and there's a proof for P /= NP everywhere
22:33:31 <kmc> but which way?
22:33:31 <tkahn6> yeah
22:33:50 <kmc> aren't there two ways to graft ("function-major" and "argument-major")?
22:35:56 <Saizan> define the monad and use ap? that way the three for the first argument will be on the outside
22:35:57 <etpace> what's the caf pragma? google seems to just say use -caf-all or something
22:36:11 <etpace> (i want to add cafs to functions inside a where statement)
22:36:25 <c_wraith> you mean SCC?
22:36:31 <Phyx-> cncl: go back to sleep, and wake up again, maybe there would be world peace
22:36:43 <c_wraith> the cost-center marking pragma?
22:36:44 <cncl> i'm seriously considering it
22:37:23 <EvanR> cncl: a random person twits "Access to Deolalikar's P!=NP paper seems to be in NP"
22:37:43 <cncl> hahaha
22:37:43 <kmc> caf-all adds a cc to every caf
22:38:03 <etpace> mm, i'm not too sure c_wraith
22:38:05 <kmc> fuck scribd
22:38:07 <kmc> http://dl.dropbox.com/u/33127/35539144-pnp12pt.pdf
22:38:11 <etpace> i want to see the time spent inside the function via -p basically
22:38:13 <kmc> P  NP, direct download ^^^^
22:38:37 <etpace> as the function thats sucking up all the time is composed of smaller ones inside the where, so being able to see which of thoise is sucking up time would be good
22:38:44 <cncl> vinay deolalikar's own site has it now
22:38:47 <kmc> Saizan, do you think it's simpler to define the monad in terms of join or (>>=)
22:39:04 <Phyx-> I wonder if HP gives him a bonus
22:39:04 <cncl> i'm going to be reading this for a while
22:39:18 <cncl> HP should give him the company, if it holds up under scrutiny
22:39:34 <kmc> yeah, there's an opening
22:39:39 <cncl> haha yes
22:39:39 <kmc> http://money.cnn.com/2010/08/08/technology/mark_hurd_jodie_fisher/
22:39:42 <Phyx-> well, the current CEO did get himself into a bit of a sex scandal
22:39:48 <Saizan> kmc: about the same, maybe (>>=)
22:39:49 <kmc> they need some good PR
22:40:17 <Phyx-> 1. sex scandal. 2. solve N /= NP 3. ???? 4. profit
22:41:01 <Saizan> kmc: i was thinking of leaf-labelled trees though
22:41:05 <kmc> oh
22:41:59 <tkahn6> what is the quality of the graph libraries available for haskell? on the 99-haskell problems page, it's saying that none of the graph problems have haskell solutions
22:43:16 <kmc> Saizan, are the everywhere-labeled trees even a monad?
22:43:24 <kmc> i'm not sure how to write join
22:47:56 <lispy> ?src mapM
22:47:57 <lambdabot> mapM f as = sequence (map f as)
22:49:40 <ezyang> What is Monad m => m a -> m a -> m a style called? 
22:49:54 <lispy> ezyang: mplus?
22:50:14 <lispy> (not sure what you mean by style)
22:50:34 <ezyang> lispy: As in, you explicitly manage sharing and whatnot. 
22:50:42 <ezyang> s/sharing/sharing and evaluation/ 
22:50:58 <ezyang> the inside looks something like: do { a <- ma; b <- mb; do stuff with a and b } 
22:51:44 <cncl> > :t mplus
22:51:45 <lambdabot>   <no location info>: parse error on input `:'
22:51:50 <cncl> oops how do you do it
22:51:53 <ezyang> the monad doesn't have to be a monoid 
22:51:58 <ezyang> :t mplus 
22:51:59 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
22:52:09 <lispy> :t apt
22:52:11 <lambdabot> Not in scope: `apt'
22:52:11 <lispy> er
22:52:13 <lispy> :t ap
22:52:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:52:19 <BMeph> Phyx-: Obviously, 3. MEMRISTORS!
22:54:54 <Phyx-> BMeph: lol
22:56:32 <kmc> this channel has set my expectations of IRC too high :/
22:56:38 <kmc> i expect to be able to join anywhere and get instant answers
22:56:51 <kmc> but most channels are 10-20% as big
22:57:37 <BMeph> Phyx: Although, technically, memristors were before the sex scandal (but not before the sex?)...
22:58:01 <lispy> kmc: it's not the size the matters, it's how you use it
23:05:58 <EvanR> can i get non-self pairs of elements of a list
23:07:07 <kmc> you want the product of the list with itself, minus the diagonal?
23:07:30 <EvanR> yes
23:08:01 <kmc> do you want to get both (a,b) and (b,a)?
23:08:03 <kmc> but not (a,a)?
23:08:29 <EvanR> well...
23:08:39 <EvanR> could probably do without (b,a)
23:08:48 <EvanR> but definitely not (a,a)
23:09:25 <EvanR> should i do a nested for loop ;)
23:09:28 <kmc> @hoogle [a] -> [(a,[a])]
23:09:28 <lambdabot> Data.Char readLitChar :: ReadS Char
23:09:28 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
23:09:28 <lambdabot> Prelude reads :: Read a => ReadS a
23:09:45 <kmc> @let splits [] = []; splits (x:xs) = (x,xs) : splits xs
23:09:47 <lambdabot>  Defined.
23:09:47 <EvanR> @smack EvanR
23:09:47 <lambdabot> why on earth would I slap EvanR?
23:09:51 <kmc> i don't recall if that's in the stdlib
23:09:59 <kmc> i don't think it is :/
23:10:02 <kmc> but quite useful
23:10:46 <EvanR> loads splits into ghci
23:10:51 <kmc> > let f xs = [ (y,z) | (y,ys) <- splits xs, z <- ys ] in f "abcd"
23:10:52 <lambdabot>   [('a','b'),('a','c'),('a','d'),('b','c'),('b','d'),('c','d')]
23:11:12 <Saizan> > let f xs = [ (y,z) | (y:ys) <- tails xs, z <- ys ] in f "abcd"
23:11:13 <lambdabot>   [('a','b'),('a','c'),('a','d'),('b','c'),('b','d'),('c','d')]
23:11:27 <kmc> nice Saizan
23:11:43 <EvanR> :o
23:13:43 <ezyang> oh, that's clever. 
23:13:53 <EvanR> heh
23:13:57 <EvanR> and that was the final piece
23:14:13 <EvanR> of the most inefficient collision detection algorithm possible
23:14:19 <kmc> haha
23:14:53 <c_wraith> you're not doing anything factorial yet :)
23:17:14 <EvanR> http://codepad.org/sQbBREt4
23:18:39 <aidalgol> I have some idea of what the problem is here, but not how to eleganty solve it.  Any suggestions? <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28739#a28740>
23:20:27 <kmc> convert (sum grades) to Float with fromIntegral?
23:21:51 <EvanR> @src tails
23:21:51 <lambdabot> tails []         = [[]]
23:21:51 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
23:22:44 <aidalgol> @src fromIntegral
23:22:44 <lambdabot> fromIntegral = fromInteger . toInteger
23:22:59 <aidalgol> :t fromIntegral
23:23:00 <lambdabot> forall a b. (Integral a, Num b) => a -> b
23:23:37 <aidalgol> kmc: That doesn't seem to make a difference. :(
23:24:31 <kmc> well then it mismatches with length
23:24:39 <kmc> so you have to convert that too, or use genericLength
23:24:58 <aidalgol> @src genericLength
23:24:58 <lambdabot> genericLength []    = 0
23:24:59 <lambdabot> genericLength (_:l) = 1 + genericLength l
23:25:04 <kmc> it might be better if you wrote gradeToFloat instead
23:25:04 <aidalgol> :t genericLength
23:25:06 <lambdabot> forall b i. (Num i) => [b] -> i
23:25:17 <kmc> then you would have only one thing to convert
23:25:24 <kmc> also it is not necessary for you to use guards on gradeToInt
23:25:25 <kmc> you can just say
23:25:28 <kmc> gradeToInt 'A' = 1
23:25:31 <kmc> gradeToInt 'B' = 2
23:25:31 <kmc> ...
23:25:41 <aidalgol> Uhh... good point.
23:25:43 <kmc> and you can write the same code but call it 'gradeToFloat' and put Float in the type sig
23:26:30 <c_wraith> Grade seems like the perfect case for an enum type, to me...
23:27:06 <aidalgol> Oh, boy.
23:27:15 <kmc> yeah, the types are not written in idiomatic Haskell style
23:27:19 <aidalgol> I forgot Haskell had enumerations. >_<
23:27:21 <kmc> but aidalgol said he (?) got that from an instructor (?)
23:27:31 <aidalgol> Not *that* function.
23:27:49 <kmc> aidalgol, Haskell has a simple, general idea of "algebraic data" which subsumes a lot of things, including structs, enums, and unions from C
23:27:53 <c_wraith> data Grade = A | B | C | D | F
23:27:53 <c_wraith> :)
23:28:13 <aidalgol> Will be 1,2,3,4,5?
23:28:23 <kmc> aidalgol, if you put "deriving (Enum)"
23:28:26 <kmc> and then use fromEnum
23:28:26 <c_wraith> They don't have any automatic numeric conversion
23:28:31 <kmc> they will be 0-4 i think
23:28:33 <c_wraith> doesn't Enum start at 0?
23:28:35 <c_wraith> yeah
23:28:38 <aidalgol> Oh, [censored]!
23:28:46 <kmc> data Grade = A | B | C | D | F | P | F* | E | I | W | None
23:29:02 <aidalgol> I still can't use Enum, because Grade is already a Char. >:(
23:29:03 <kmc> aidalgol, but using an enumeration would be good style even if you wrote an explicit conversion like gradeToInt
23:29:05 <c_wraith> F* isn't a valid name...
23:29:08 <kmc> c_wraith, indeed
23:29:31 <kmc> rumors of the mythical P+ are entirely unsubstantiated
23:29:46 <c_wraith> My school had even more grades than that.  strange things like X and Y that no one knew about except my friend who got them all.
23:29:51 <kmc> haha
23:29:56 <kmc> was it a goal to collect them all?
23:30:11 <c_wraith> ...  in his 5 term tour of "getting kicked out with 8 credits"
23:30:16 <kmc> haha
23:30:23 <aidalgol> "Z minus?" -- Peppermint Patty, Peanuts
23:33:49 <aidalgol> "Style?  What's style?" -- How I imagine my professors respond to questions about style
23:34:49 <aidalgol> OT: Here's some code from my algorithms class: <http://sprunge.us/IKXT>
23:37:16 <endolphin> @src nubBy
23:37:17 <lambdabot> nubBy eq []             =  []
23:37:17 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
23:37:22 <endolphin> hmmm
23:39:34 <Axman6> @pl nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
23:39:35 <lambdabot> nubBy = fix (flip flip tail . (ap .) . flip flip head . (((.) . liftM2 (.) (:)) .) . (`ap` ((filter . (not .)) .)) . (((.) . (.)) .))
23:39:43 <Axman6> :o
23:39:45 <endolphin> ???
23:39:51 <endolphin> what'
23:39:53 <endolphin> s "pl" do
23:40:03 <aidalgol> OK, now what? <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28739#a28746>
23:40:07 <Axman6> haskell's perlify command
23:40:09 <Axman6> >_>
23:40:23 <cncl> pointless
23:40:27 <endolphin> omg
23:40:35 * aidalgol shoots pl
23:40:37 <Axman6> but not really
23:40:56 <endolphin> @pl flipify x fn = map fn x
23:40:56 <lambdabot> flipify = flip map
23:41:02 <Axman6> it makes expressions pointfree, ie, making f x y = x + y -> f = (+)
23:41:03 <endolphin> mmnmn....
23:42:11 * shachaf wonders what the simplest expression that explodes when fed to @pl is.
23:42:26 <endolphin> @pl :
23:42:26 <lambdabot> (line 1, column 1):
23:42:27 <lambdabot> unexpected ":"
23:42:27 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
23:42:31 <shachaf> Like the R-pentomino.
23:42:31 <danportin> So you get free point-free style points?
23:42:32 <endolphin> @pl lol
23:42:33 <lambdabot> lol
23:42:42 <endolphin> mmmnn...........
23:43:42 <endolphin> @pl (\x y->x*(sin y**x)
23:43:42 <lambdabot> (line 1, column 20):
23:43:42 <lambdabot> unexpected end of input
23:43:42 <lambdabot> expecting variable, "(", operator, "*", "/", "`quot`", "`rem`", "`div`", "`mod`", ":%", "%" or ")"
23:43:49 <endolphin> @pl shutup x y = (\x y->x*(sin y**x)
23:43:49 <lambdabot> (line 1, column 12):
23:43:49 <lambdabot> unexpected "="
23:43:49 <lambdabot> expecting variable, "(", operator or end of input
23:43:59 <endolphin> oh yes i see...
23:44:02 <endolphin> @pl (\x y->x*(sin y**x))
23:44:02 <lambdabot> liftM2 (.) (*) (flip ((**) . sin))
23:44:15 <Axman6> @pl f x y = x*(sin y ** x)
23:44:15 <lambdabot> f = liftM2 (.) (*) (flip ((**) . sin))
23:44:31 <endolphin> boring
23:47:03 <endolphin> does anybody here know what DICOM means
23:47:06 <endolphin> w/o looking it up
23:47:37 <danportin> @pl f x y z = filter (>x) ((+) <$> [x, y, head $ sin (zipWith (*) [x] [z])] <*> [z, y, foldr1 (+) [x]]
23:47:38 <lambdabot> (line 1, column 9):
23:47:38 <lambdabot> unexpected "="
23:47:38 <lambdabot> expecting variable, "(", operator or end of input
23:47:45 <nettok> how do I make a function return "MTGen" instead of "IO MTGen" ?
23:47:47 <danportin> oh well
23:48:53 <Axman6> nettok: in short, you don't. you can retrive the value using the IO monad though: foo = go { x <- mtGenFunc; return (funcUsingMTGen x)
23:49:55 <nettok> mmm... let me digest that
23:50:09 <kmc> nettok, they're totally different types.  MTGen is a random-number generator; (IO MTGen) is a "recipe" for how you could, at a later time, construct an MTGen by doing some IO
23:50:13 <kmc> the recipe is not the cake :)
23:50:27 <kmc> and we have no function to turn a recipe into a cake, because the function would have side effects
23:50:35 <kmc> instead, you glue together smaller recipes to make bigger ones, using "do"
23:50:52 <kmc> and the recipe named main (or the one you type into GHCi) is the one which is actually baked, err, executed ;)
23:51:18 <kmc> nettok, http://haskell.org/haskellwiki/Introduction_to_IO
23:51:37 <nettok> nice analogy :)  I think I get that. Better i'll explain what I want to achieve.
23:53:24 <nettok> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28748#a28748  line 5, do I really need to get a new generator at each iteration?
23:53:35 <Beelsebob> so how many of you have found flaws in the claimed P!=NP proof yet?
23:53:54 <Axman6> I found three
23:53:57 <nettok> by the way, I think that function still has some errors
23:54:22 <Axman6> biut then i realised i was reading a blank piece of paper
23:54:28 <Beelsebob> lol
23:54:54 <kmc> haha
23:54:55 <kmc> how zen
23:54:58 <c_wraith> beelsebob, from what I've seen, the whole thing is way over my head.  I'm not a physics guy.  And it's a physics paper.
23:55:23 <kmc> nettok, sumRandTo1 = do { g <- newMTGen Nothing; go g 0.0 0.0 }
23:55:30 <Beelsebob> hehe, and I came in here hoping to find people over who's head it wasn't :P
23:55:32 <kmc> where "go" is what you call sumRandTo1' but i like the short name ;P
23:55:37 <Beelsebob> but yeh, I can get that c_wraith
23:56:45 <Beelsebob> the first thing I'm thinking of when I see it "now give a *constructive* proof"
23:56:46 <nettok> kmc: cool :)
23:58:41 <kmc> know where i might find some dos hackers?
23:58:49 <endolphin> a graveyard
23:58:49 <kmc> by which i mean Disk Operating System
23:58:52 <kmc> :/
23:59:10 <endolphin> O:)
23:59:30 <Axman6> i no sum fulli 1337 DoSSSSS h4xrz!
23:59:30 <kmc> time makes fools of us all
23:59:32 <kmc> also robots
23:59:46 <shachaf> kmc: Why would you want those?
