00:43:34 <Wooga> hello, here, in this tutorial: http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/Introduction happening strange things like *Main> Data.Map.lookup "Thor" days :: [String] , which is not working for me in ghc 6.10.4. is there any way to achieve such failure countrol in recent ghc versions ?
00:44:58 <Wooga> control*
00:46:05 <bss03> I think lookup has changed.
00:46:32 <bss03> :t Data.Map.lookup
00:46:33 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
00:46:57 <Wooga> but which implementation may allow such easy wrapping in any value?
00:47:05 <Wooga> any type*
00:47:12 <bss03> :t Data.Map.lookup "Thor" (unknown :: [(String, String)])
00:47:13 <lambdabot> Not in scope: `unknown'
00:47:21 <bss03> :t Data.Map.lookup "Thor" (undefined :: [(String, String)])
00:47:22 <lambdabot>     Couldn't match expected type `M.Map [Char] a'
00:47:22 <lambdabot>            against inferred type `[(String, String)]'
00:47:22 <lambdabot>     In the second argument of `M.lookup', namely
00:47:49 <shachaf> bss03: Data.Map.lookup works on Data.Maps, not lists.
00:47:57 <bss03> :t Data.Map.lookup "Thor" (undefined :: Data.Map.Map String String)
00:47:59 <lambdabot> Maybe String
00:48:07 <shachaf> But in this case it indeed always returns a Maybe.
00:48:32 <shachaf> Wooga: That guide would appear to be wrong about this -- I'd suggest that you either skip this section or use another guide. :-)
00:48:44 <bss03> Wooga: So, instead of getting an empty list on lookup failure, you get Nothing.
00:52:39 <Wooga> okay, but how then i can catch "no argument" - "pattern match failure" exception here: http://codepad.org/xknIgEtZ ?
00:53:58 <ClaudiusMaximus> http://www.haskell.org/haskellwiki/Upgrading_packages#Return_types_of_Map_and_Set_functions
00:57:18 <kmc> which line?
00:57:23 <kmc> the getArgs?
00:57:28 <Wooga> yes
00:57:58 <kmc> you'd do it by matching an exhaustive set of patterns
00:58:06 <kmc> in this case a particular nice way is
00:58:17 <kmc> main' :: [String] -> IO ()
00:58:27 <kmc> main' [] = ... stuff ...
00:58:32 <kmc> main' [f] = .... stuff ...
00:58:36 <kmc> (more cases for main'0
00:58:41 <kmc> (more cases for main')
00:58:49 <kmc> then:  main = getArgs >>= main'
00:59:05 <Wooga> thanks!
01:01:34 <Zeiris> What would be suggested reading for really -getting- Applicative functors?
01:02:52 <kmc> Typeclassopedia
01:03:00 <Zeiris> Thought so, thanks.
01:03:32 <kmc> there's not that much to them
01:03:51 <kmc> if you're looking for something really dramatic to "get", you may be disappointed
01:04:16 <Zeiris> The type signatures are simple, and deriving them from monads is trivial, but I don't undestand what they do :(
01:04:18 <c_wraith> If you get functors, you get applicative functors
01:04:48 <kmc> Zeiris, i think a capsule summary is "like monads, but all you get is liftM, liftM2, etc."
01:04:55 <Zeiris> Yeah, but why does Constructor <$> a <*> b <*> c<*> d work?
01:06:03 <kmc> you can apply a pure function to the "contents" of applicative values, but you can't do the more complicated conditional stuff
01:06:15 <kmc> you can't make the decision of what action to take based on the result of an earlier action
01:06:23 <kmc> which is what you get with Monad's (>>=)
01:06:55 <Saizan> Zeiris: it works because of currying, you could say
01:06:57 <kmc> Zeiris, well, that's liftA4 Constructor a b c d
01:07:31 <Saizan> remember that it parses as (((Constructor <$> a) <*> b) <*> c) <*> d
01:07:32 <Zeiris> Ah. In my case a b c d are functions... Which, I'd fogotten, are instances of Functor. That makes a bit more sense :)
01:07:53 <kmc> (<*>) for functions is the S combinator
01:08:19 <kmc> (r -> a -> b) -> (r -> a) -> (r -> b)
01:08:23 <Zeiris> Wow. Creating a new function by applying a function to a function. I don't know where to even begin in doing that in C o.O
01:08:46 <kmc> «map succ»?
01:09:05 <kmc> oh in C
01:09:14 <kmc> to do it in C you need to build and allocate closures of free variables explicitly
01:09:36 <bss03> Zeiris: Something like...
01:09:40 <kmc> the thing where every C callback interface has a «void*» you set that gets passed to your callback?
01:09:46 <kmc> that's faking a fundamental feature of FP
01:11:29 <bss03> Zeiris: typedef void *(*fun)(void *); struct h = { fun f, fun g }; void *h_apply(struct h the_h, void*x) { void *y = h.f(x); void * z = h.g(y); return z; }
01:12:16 * kmc has the Y combinator implemented in C++ somewhere
01:12:29 <bss03> Zeiris: quite complex, really, even though the idea is fairly simple.
01:13:33 <bss03> Zeiris: Boost, and even some parts of the standard C++ libraries have some "concepts" (template-argument restrictions) that are similar to functions...
01:14:13 <kmc> it is well-known that closures are the poor man's object, and objects are the poor man's closure
01:14:16 <bss03> Zeiris: So, you can so "simple" things like map and foldr1, but it still requires a lot more code.
01:15:19 <kmc> basically any nested function becomes in C++ a new class + operator() in that class + explicit listing of free variables as data members + explicit constructor to copy/reference free variables + explicit instantiation of that object + explicit destruction
01:15:30 <bss03> kmc: Luckily, in haskell we have simple syntax for both objects (records, possibly with fields of a function type) and closures (any partially-applied function).
01:15:54 <kmc> and this is an absurd amount of boilerplate, so C++1x will support auto-generating much of it
01:17:00 <kmc> records don't satisfy all of what people mean by "objects".  but nobody can agree on what "objects" are anyway, and the term is largely driven by wanting to present every language as especially "object-oriented" for reasons of marketing
01:17:48 <monadic_kid> You still need to use templates to use those or std::function
01:18:14 <kmc> you can make operator() virtual
01:18:28 <bss03> I just love how the type system in Haskell is "flexible" enough to handle writing (.) and similar once, while still being (absurdly) "stronger" than C/C++ typesystem about checking of violations.
01:18:38 <kmc> yeah
01:18:47 <monadic_kid> you can use it in the scope you defined it but as soon as you want to pass it to another function you can't do it without knowing the type of the lambda
01:18:56 <monadic_kid> kmc: you can't do that for lambda functions
01:19:02 <kmc> oh you mean 1x specifically
01:19:19 <kmc> your lambda-constructed value is an unspecified subtype of std::function?
01:19:28 <monadic_kid> kmc: no
01:19:32 <kmc> i thought that's how it works
01:19:34 <monadic_kid> kmc: the types are generated
01:19:48 <monadic_kid> kmc: you can never name the type, only the compiler can infer it
01:20:25 <monadic_kid> kmc: so you need auto when you want to use it before passing it off to a template function or std::function (which uses templates)
01:20:25 <kmc> so two functions of the same type defined in different places can't be substituted for one another?
01:20:28 <bss03> So, if you want to pass or return it you have to know the correct type, or use some C++ feature to emulate type variables?
01:20:37 <bss03> (Like, maybe templates?)
01:21:08 <kmc> right
01:21:17 <kmc> madness
01:21:18 <monadic_kid> kmc: every lambda expression in C++0x conceptually generates a local class with function call operator overloaded
01:21:32 <kmc> we're still calling it C++0x?
01:21:44 <monadic_kid> kmc: that is the offical name still yeah
01:21:59 <bss03> The last draft I saw still called it C++0x.
01:22:05 <kmc> so if i have a couple different lambdas in different places
01:22:09 <monadic_kid> they are not going to change the name
01:22:16 <kmc> and i need to use these values interchangeably
01:22:24 <kmc> in a way not known at compile time (so no templates)
01:22:30 <kmc> do i still need to write a bunch of boilerplate
01:22:36 <kmc> to wrap them into a virtual calling mechanism?
01:22:37 <monadic_kid> kmc: you can use std:function
01:22:46 <monadic_kid> std::function
01:23:25 <p_l> kmc: I think I'd prefer to have closures than objects :-)
01:23:40 <kmc> p_l, yeah
01:23:44 <monadic_kid> bss03: C++0x closures are statically allocated, you can not really return a lambda expression so if you really wanna do that you need to use std::function
01:24:05 <kmc> in particular once you have objects everyone starts talking about subtyping
01:24:06 <monadic_kid> p_I: they do support lexcial closures, but they are statically allocated
01:24:17 <kmc> and subtyping is just a mess
01:24:30 <kmc> i am very glad that Haskell has no subtyping
01:24:55 <QtPlatypus> kmc: Why so?
01:25:02 <kmc> why am i glad?
01:25:07 <bss03> Well, you can sort of subtype, right?
01:25:12 <QtPlatypus> Yes
01:25:20 <kmc> because subtyping is a mess
01:25:26 <kmc> complicates the system tremendously
01:25:26 <bss03> instance Monad m => MyTypeClass m where { {- stuff -} }
01:25:32 <kmc> classes aren't types
01:25:38 <kmc> neither are instances
01:25:55 <kmc> and the simplest encoding of OOP into Haskell avoids type classes entirely
01:26:06 <kmc> though Haskell beginners from OOP background usually go for the more complicated encoding
01:26:13 <bss03> qtHaskell must be doing it wrong then...
01:26:26 <bss03> qtHaskell smears type classes all over the place.
01:26:31 <kmc> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
01:26:43 <kmc> i don't claim the classes are never warranted
01:26:48 <bss03> I read that when you posted it a few days (?) ago.
01:26:51 <kmc> i said "simplest" not "best always"
01:26:53 <kmc> ok
01:27:11 <kmc> but there is a lot of Haskell code which is over-engineered from a type class perspective
01:27:36 <monadic_kid> that is quite true, it's a pain to make it work across other haskell compilers too
01:27:52 <monadic_kid> using extensions
01:28:24 <go2ghana> hi - am in trouble using shared libs on windows - get errors like  Perhaps you haven't installed the "dyn" libraries for package `base'
01:28:25 <kmc> this is related to the pattern of needing only a simple sum type but encoding it as an open sum with some combination of existentials, classes, Typeable, and other magic
01:29:17 <bss03> go2ghana: I'd love to help, but I mostly gave up on MS Windows.  Not sure what the dynamic linking requirements are there.
01:36:05 <go2ghana> bss03: thanks anyway - I'll try on the mailing-list
02:17:53 <eflister> @djinn (a -> b) -> [a] -> [b]
02:17:53 <lambdabot> Error: Undefined type []
02:18:07 <eflister> @djinn (a -> b) -> m a -> m b
02:18:08 <lambdabot> -- f cannot be realized.
02:18:28 <bss03> @help @djinn
02:18:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:18:31 <Kaide> wait what
02:18:35 <bss03> @help djinn
02:18:35 <lambdabot> djinn <type>.
02:18:36 <lambdabot> Generates Haskell code from a type.
02:18:36 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
02:19:00 <bss03> :t fmap
02:19:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:19:22 <Kaide> is djinn broken or is it just that type arguments confuse it or something?
02:19:29 <bss03> :t liftM
02:19:29 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:19:33 <eflister> yeah i wanted to impress my friend my showing him that djinn could write it
02:19:38 <eflister> but now he is not impressed
02:19:52 <Kaidelong> I don't think it is djinn so much as the djinn on lambdabot
02:20:36 <Kaidelong> @djinn (a -> b) -> (a, a) -> (b, b)
02:20:37 <lambdabot> f a (b, _) = (a b, a b)
02:20:37 <bss03> @djinn (a -> b) -> (c -> a) -> a -> c
02:20:38 <lambdabot> -- f cannot be realized.
02:20:55 <eflister> is there anything that just does a search over all the types on hoogle and composes together solutions?
02:21:13 <Kaidelong> @djinn (a -> b a) -> a -> b a
02:21:15 <lambdabot> f a = a
02:21:40 <Kaidelong> @djinn (a -> a) -> a
02:21:40 <lambdabot> -- f cannot be realized.
02:21:43 <bss03> :t (.)
02:21:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:21:46 <ski> @djinn-env
02:21:46 <lambdabot> data () = ()
02:21:47 <lambdabot> data Either a b = Left a | Right b
02:21:47 <lambdabot> data Maybe a = Nothing | Just a
02:21:47 <lambdabot> data Bool = False | True
02:21:47 <lambdabot> data Void
02:21:48 <lambdabot> type Not x = x -> Void
02:21:50 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
02:21:52 <lambdabot> class Eq a where (==) :: a -> a -> Bool
02:21:54 <lambdabot> type NotNot a = Not (Not a)
02:21:56 <lambdabot> data Identity a = I a
02:21:58 <lambdabot> data Pair a = P a a
02:22:00 <Kaidelong> @src fix
02:22:00 <lambdabot> fix f = let x = f x in x
02:22:06 <Kaidelong> :t fix
02:22:06 <lambdabot> forall a. (a -> a) -> a
02:22:24 <ski> @djinn-add class Functor f where fmap :: (a -> b) -> (f a -> f b)
02:22:48 <Kaidelong> @djinn (a -> b) -> [a] -> [b]
02:22:48 <lambdabot> Error: Undefined type []
02:22:56 <ski> @djinn Functor f => (a -> b) -> (f (f a) -> f (f b))
02:22:56 <lambdabot> -- f cannot be realized.
02:23:01 <ski> bah
02:23:03 <bss03> I think you need an instance now.
02:23:30 <Kaidelong> @djinn (Functor f) => (a -> b) -> f a ->f  b
02:23:31 <lambdabot> f = fmap
02:23:43 <ski> @djinn Monad m => m (m a) -> m a
02:23:43 <lambdabot> -- f cannot be realized.
02:23:53 <bss03> :(
02:24:06 <Kaidelong> djinn probably needs to be configured properly
02:24:16 <Kaidelong> not unlike other constructive theorem provers
02:24:19 <ski> @djinn Eq b => (a -> b) -> (a -> a -> Bool)
02:24:19 <lambdabot> f a b _ = a b == a b
02:24:49 <Kaidelong> lol
02:25:16 * ski wonders why it didn't see fit to use the other argument, there ..
02:25:32 <ski> (i mean, it is *supposed* to try to use as many arguments as it can)
02:26:22 <bss03> f a b c ?= a b == a c, you mean?
02:26:28 <ski> yeah
02:27:51 <ski> anyway, i don't think it understands instances
02:28:07 <Kaidelong> IIRC djinn only works on stuff that is first order
02:28:33 <Kaidelong> type parameters can confuse it since it doesn't neccessarily know a way to go a -> b a
02:28:57 <Kaidelong> but hmm
02:29:19 <Kaidelong> @djinn (a -> [a]) -> (a -> b) -> ([a] -> [b])
02:29:19 <lambdabot> Error: Undefined type []
02:29:20 <QtPlatypus> ski: The function doesn't have a b in its second term
02:29:33 <Kaidelong> @djinn (a -> f a) -> (a -> b) -> (f a -> f b)
02:29:33 <lambdabot> -- f cannot be realized.
02:29:35 <ski> @djinn ((a -> b) -> c) -> (a -> a -> b) -> c
02:29:35 <lambdabot> f a b = a (\ c -> b c c)
02:29:39 <ski> it can work on higher-order functions, fine
02:29:49 <Kaidelong> @djinn (a -> f a) -> (f a -> a) -> (a -> b) -> (f a -> f b)
02:29:50 <lambdabot> -- f cannot be realized.
02:30:30 <Kaidelong> @djinn (a -> f a) -> (f a -> a) -> (b -> c) -> (f b -> f c)
02:30:31 <lambdabot> -- f cannot be realized.
02:30:40 <ski> @djinn (f a -> a) -> (b -> f b) -> ((a -> b) -> (f a -> f b))
02:30:40 <lambdabot> f a b c d = b (c (a d))
02:31:03 <ski> QtPlatypus : hm ? what function ?
02:31:10 <Kaidelong> @djinn (a -> f a) -> (f b -> b) -> (c -> d) -> (f c -> f d)
02:31:10 <lambdabot> -- f cannot be realized.
02:31:34 <ski> Kaidelong : try giving it provable propositions .. :)
02:31:52 <Kaidelong> @djinn forall a. forall b. (a -> f a) -> (f b -> b) -> (c -> d) -> (f c -> f d)
02:31:53 <lambdabot> -- f cannot be realized.
02:32:33 <ski> maybe you really meant `(forall a. a -> f a) -> (forall b. f b -> b) -> ((c -> d) -> (f c -> f d))' ?
02:32:44 <Kaidelong> maybe
02:32:51 <Kaidelong> I'm not entirely sure about the syntax for types
02:32:57 <bss03> ski: Does djinn understand [] at all?
02:32:57 <ski> .. however, that wouldn't work, since djinn doesn't understand higher-rank types
02:33:10 <ski> bss03 : no. it is a recursive type, which it can't handle
02:33:16 <bss03> @djinn (a -> b) -> [a] -> [b]
02:33:16 <lambdabot> Error: Undefined type []
02:33:38 <ski> bss03 : you can see the declarations it has in scope above (after `@djinn-env')
02:34:01 <ski> (well, it also has `(->)' in scope .. which wasn't displayed)
02:34:05 <bss03> @djinn (a -> b) -> Maybe a -> Maybe b
02:34:06 <lambdabot> f a b =
02:34:06 <lambdabot>     case b of
02:34:06 <lambdabot>     Nothing -> Nothing
02:34:06 <lambdabot>     Just c -> Just (a c)
02:34:24 <ski> @djinn-add instance Functor Identity where fmap f (I a) = I (f a)
02:34:24 <lambdabot> Cannot parse command
02:34:28 * ski nods
02:35:29 <bss03> @djinn Eq a => (a, b) -> a -> Maybe b
02:35:29 <lambdabot> f (a, b) c =
02:35:29 <lambdabot>     case a == c of
02:35:29 <lambdabot>     False -> Nothing
02:35:29 <lambdabot>     True -> Just b
02:36:18 <ski> @djinn a -> Maybe a -> a
02:36:18 <lambdabot> f a b =
02:36:18 <lambdabot>     case b of
02:36:18 <lambdabot>     Nothing -> a
02:36:18 <lambdabot>     Just c -> c
02:37:01 * ski wonders how problematic rank-2 would be to add to djinn ..
02:37:26 <bss03> @djinn a -> (b -> a) -> Maybe b -> a
02:37:27 <lambdabot> f a b c =
02:37:27 <lambdabot>     case c of
02:37:27 <lambdabot>     Nothing -> a
02:37:27 <lambdabot>     Just d -> b d
02:38:29 <bss03> @djinn a -> (b -> a) -> b -> Maybe a
02:38:29 <lambdabot> f _ a b = Just (a b)
02:38:43 <bss03> @djinn Eq a => a -> (b -> a) -> b -> Maybe a
02:38:44 <lambdabot> f a b c =
02:38:44 <lambdabot>     case a == a of
02:38:44 <lambdabot>     False -> Nothing
02:38:44 <lambdabot>     True -> Just (b c)
02:38:48 <Kaidelong> so I take it the main reason you'd use djinn is to show that a type that should be impossible is indeed impossible?
02:39:34 <bss03> Hrm, that second line it generated is stupid.
02:40:09 <ski> Kaidelong : well, provided that it is rank-1 or rank-0, and that you're only interested in total, finite values, yes
02:40:55 <bss03> I though it would give me f a b c = case d == a of { False -> Nothing; True -> d; } where d = b c
02:41:06 <ski> bss03 : heh, it doesn't know that `forall a. a == a = True' is supposed to hold (and so is uninteresting to try)
02:42:21 <bss03> @djinn (l -> a) -> (r -> a) -> Either l r -> a
02:42:21 <lambdabot> f a b c =
02:42:21 <lambdabot>     case c of
02:42:21 <lambdabot>     Left d -> a d
02:42:22 <lambdabot>     Right e -> b e
02:43:27 <bss03> @djinn Maybe Maybe a -> Maybe a
02:43:28 <lambdabot> Error: kind error: (KArrow KStar KStar,KStar)
02:43:35 <bss03> @djinn Maybe (Maybe a) -> Maybe a
02:43:35 <lambdabot> f a =
02:43:35 <lambdabot>     case a of
02:43:35 <lambdabot>     Nothing -> Nothing
02:43:35 <lambdabot>     Just b -> b
02:44:12 <ski> @djinn Functor f => (b -> a) -> (f b -> f a)
02:44:12 <lambdabot> -- f cannot be realized.
02:44:13 <ski> @djinn Functor f => (a -> b) -> (f a -> f b)
02:44:13 <lambdabot> f = fmap
02:44:27 <bss03> !?
02:44:44 <ski> (that should tell you something of how it treats polymorphic class members)
02:44:44 <bss03> Those types are equivalent, are they not?
02:45:22 <bss03> @djinn Maybe a
02:45:22 <lambdabot> f = Nothing
02:45:23 <eflister> cabal says i am missing mtl >=1.1 but i have 1.1.0.2
02:45:27 <bss03> @djinn a -> Maybe a
02:45:27 <lambdabot> f = Just
02:45:45 <ski> yes, but it doesn't treat the class member of `Functor' as having type `forall a b. (a -> b) -> (f a -> f b)' .. it apparently treats it as having type `(a -> b) -> (f a -> f b)' (for free `a' and `b')
02:45:58 <ski> and this is probably because it doesn't support rank-2 types
02:47:15 <bss03> @djinn (c -> d) -> (f c -> f d)
02:47:15 <lambdabot> -- f cannot be realized.
02:47:33 <bss03> Hrm, that seems quite broken.
02:47:41 <ski> well, now you forgot `Functor f => ', so that result is expected
02:47:52 <bss03> @djinn Functor => (c -> d) -> (f c -> f d)
02:47:52 <lambdabot> -- f cannot be realized.
02:47:59 <bss03> Hrm, that still seems quite broken.
02:48:04 <ski> aye
02:48:17 <bss03> @djinn Functor f => (c -> d) -> (f c -> f d)
02:48:18 <lambdabot> -- f cannot be realized.
02:48:38 <ski> complain to augustss .. and/or devise a scheme to fix it !
02:49:13 <eflister> the .cabal file says Build-Depends: mtl >= 1.1, and ghc-pkg list says    mtl-1.1.0.2
02:49:15 <bss03> @djinn (Functor f1, Functor f2) => (a -> b) -> f2 (f1 a) -> f2 (f1 b)
02:49:16 <lambdabot> -- f cannot be realized.
02:49:23 <bss03> :t (fmap . fmap)
02:49:24 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:50:00 <byorgey> eflister: does ghc-pkg list show it in your local or global packages?
02:50:12 <byorgey> eflister: and are you trying to build a package as a local user or as root?
02:51:09 <eflister> it shows it in /Users/eflister/.ghc/i386-darwin-6.12.1/package.conf.d
02:51:19 <eflister> i think i always do global (whatever the default is)
02:51:31 <eflister> i didn't sudo, but i thought i didn't have to...
02:51:35 <byorgey> eflister: ok, that looks like your local packages
02:51:49 <byorgey> eflister: and what are you trying to build/what command are you using to build it?
02:52:04 <eflister> runhaskell Setup configure
02:52:14 <byorgey> eflister: right, that tries to build globally by default
02:52:19 <byorgey> but that won't be able to see your local packages.
02:52:51 <eflister> it's a non-hackage thing.  i always just cabal install to get hackage stuff.  that wasn't global?
02:53:06 <byorgey> cabal install installs locally by default
02:53:22 <byorgey> eflister: just do 'cabal install' instead of 'runhaskell Setup configure'
02:53:35 <eflister> that works for non-hackage?
02:53:44 <byorgey> if you don't give a package argument to cabal install it tries to install whatever package it finds in the current directory
02:53:59 <byorgey> as long as it's cabalized, yes
02:54:20 <eflister> well i'll be...  :)  thx!
02:54:26 <byorgey> sure =)
02:55:46 <eflister> any idea if there's anything djinn-like that just tries to piece together functions based on their types, maybe trolling through all of hackage?
02:59:56 <SonOfLilit> Hi
03:00:10 <SonOfLilit> I am writing a simple game in Haskell
03:00:51 <SonOfLilit> I am having a problem with the impossibility of having a list of values of different types
03:01:25 <SonOfLilit> data GameState = {ship1::Ship, sun::Sun}
03:01:44 <SonOfLilit> instance GameObject Ship; instance GameObject Sun
03:02:37 <SonOfLilit> mapOnObjects :: (GameObject o) => (o -> a) -> GameState -> [a]
03:02:44 <SonOfLilit> how do I write mapOnObjects?
03:02:47 <kmc> scrap the class
03:02:55 <byorgey> SonOfLilit: what's in the GameObject class?
03:03:00 <kmc> data GameObject = ObjShip Ship | ObjSun Sun
03:03:17 <kmc> now you have one type
03:03:19 <SonOfLilit> mmm
03:03:23 <SonOfLilit> that might be a goo idea
03:03:32 <SonOfLilit> I'll need them to behave very differently
03:03:47 <SonOfLilit> but I can manage that with a behave function that pattern-matches
03:03:50 <copumpkin> the alternative is existentials, but there be dragons there
03:04:07 <SonOfLilit> just out of curiosity, what are they?
03:04:12 <copumpkin> like OOP
03:04:22 <kmc> http://www.haskell.org/haskellwiki/Existential_types
03:04:29 <kmc> existentials are useful if you're building an *open* sum type
03:04:39 <copumpkin> "forget the specifics, I just want something that implements this interface"
03:04:43 <kmc> i.e., if you need to allow other modules to add new sorts of GameObject without your cooperation
03:04:57 <kmc> copumpkin, but they're not the only or simplest way to do implementation hiding
03:05:02 <copumpkin> yeah
03:05:37 <SonOfLilit> thanks, all of you
03:05:43 <SonOfLilit> I'll implement one datatype
03:05:47 <kmc> it's easy to end up with a baroque design of classes, instances, types, and existentials
03:06:02 <kmc> when all you really want is a single type storing values (i.e. functions) representing different behaviors
03:06:15 <SonOfLilit> gotta say, it is a bit ugly that I have to write all my objects in the same place...
03:06:27 <copumpkin> better than rococo
03:06:42 <kmc> SonOfLilit, if you need Ship and Sun to act so differently
03:06:48 <kmc> why are you making a map function to operate over both?
03:07:59 <kmc> what relates them, other than the fact that they're both "objects"?
03:08:02 <SonOfLilit> they both have "position" and "shape", and that is all I need to "draw" them
03:08:07 <kmc> ok
03:08:34 <kmc> so how about:  data Object = Object { position :: Position, shape :: Shape }
03:08:47 <SonOfLilit> I wanted that map to be like an fmap for GameState, if I understand what that means correctly
03:09:13 <SonOfLilit> and then they both... have an object?
03:09:15 <copumpkin> fmap is polymorphic
03:09:44 <kmc> SonOfLilit, so each of them has some other stuff?
03:09:52 <kmc> but different other stuff
03:10:45 <SonOfLilit> right now they implement some functions differently
03:10:52 <SonOfLilit> shape, tick
03:10:56 <kmc> why not put the functions in the record then?
03:11:24 <kmc> you don't need new types to specify new behaviors
03:11:35 <SonOfLilit> shape :: o -> [Lines], tick :: o -> TimeDiff -> IO o
03:11:53 <SonOfLilit> would you elaborate?
03:14:14 <kmc> data Object = forall s. Object { state :: s, shape :: s -> [Lines], tick :: s -> TimeDiff -> IO s }
03:14:24 <kmc> here we are using an existential type, to hide the type 's' from the outside world
03:14:54 <kmc> that's not the only possible design, though
03:14:57 <kmc> an alternative:
03:15:18 <kmc> data Object = Object { getShape :: IO [Lines], tick :: TimeDiff -> IO () }
03:15:40 <kmc> in this version, the state of the object is stored in an IORef which is baked into the values for getShape and tick
03:15:41 <osaunders> Which is better argument or parameter?
03:15:47 <kmc> what osaunders
03:15:59 <osaunders> Which word is better?
03:16:06 <kmc> for what?
03:16:20 <osaunders> For being cool.
03:16:24 <kmc> ;P
03:16:30 <osaunders> :)
03:17:06 <kmc> SonOfLilit, the point is that you don't need to define a new type for each sort of object.  you just decide its behaviors, and fill in an Object record with those behaviors
03:17:41 <kmc> this is useful, it means (among other things) that your "classes" (in the OO sense) are now first-class values
03:17:46 <kmc> so you get things like metaclassing for free
03:17:54 <osaunders> Are argument and parameter completely interchangeable?
03:18:05 <ski> SonOfLilit : btw, <http://cale.yi.org/index.php/A_look_at_OO_from_Haskell> might be interesting
03:18:08 <kmc> and it's very simple, simpler than a pile of types and classes and instances
03:18:11 <kmc> osaunders, i don't think so
03:18:31 <kmc> "formal parameter" is a syntactic term
03:18:41 <kmc> it's a variable which appears in the argument list of a function definition
03:19:00 <kmc> "argument" refers to a value at runtime
03:19:10 <ski> (variable, or more generally, pattern)
03:19:18 <kmc> the value which the variable takes
03:19:34 <kmc> or perhaps also refers to the syntax in an application rather than a function definition
03:19:43 <ski> also, "actual parameter" is the expression to which a function (expression) is applied
03:19:48 <kmc> ok
03:24:05 <osaunders> What is a syntactic term?
03:24:17 <osaunders> Term in reference to syntax?
03:24:27 <kmc> a word whose meaning is about syntax
03:24:46 <kmc> that's what i meant above
03:24:54 <osaunders> OK
03:25:09 <kmc> 'term' has a formal meaning too, but it's hard to find a word that doesn't ;P
03:25:50 <osaunders> Sausage?
03:25:58 <osaunders> Does sausage have a formal meaning?
03:26:06 <kmc> probably
03:26:25 <osaunders> What about ball-sack?
03:26:30 <kmc> probably
03:26:38 <osaunders> lolz
03:26:51 <kmc> there is a hairy ball theorem in algebraic topology
03:27:03 <copumpkin> lol
03:27:24 <osaunders> Oh kmc you big joker, you.
03:29:26 <copumpkin> osaunders: you can have a telescope if you ask nicely
03:29:58 <osaunders> Huh?
03:30:18 <copumpkin> it's a data structure!
03:31:50 <osaunders> Oh.
03:32:12 <osaunders> That's cool.
03:33:08 <SonOfLilit> instance Functor GameState where
03:33:08 <SonOfLilit>   fmap f state = state {ship1=f ship1 state
03:33:08 <SonOfLilit>                        ,sun=f sun state}
03:33:26 <SonOfLilit> Haskell says GameState hasn't enough type variables
03:33:36 <SonOfLilit> what can I do to be able to fmap over it anyway?
03:34:03 <kmc> why do you want to define fmap for this structure?
03:34:08 <SonOfLilit> and is there a less repetitive way to write this?
03:34:14 <ski> how is `GameState' defined ?
03:34:37 <kmc> fmap is not appropriate
03:34:42 <Botje> SonOfLilit: it'd have to be GameState a
03:34:47 <kmc> it's supposed to take a polymorphic function and apply it to a polymorphic container
03:34:51 <kmc> your types are too specialized
03:34:59 <Botje> SonOfLilit: but that's kind of pointless since a will only ever be one type
03:35:08 <kmc> why not just write new map function
03:35:52 <kmc> mapState f s@(GameState{ship1, sun}) = s { ship1 = f ship1, sun = f sun }
03:35:59 <osaunders> Is -> a type constructor?
03:36:02 <SonOfLilit> because so many things are defined on Functors
03:36:07 <kmc> using GHC's NamedFieldPuns extension to save a little boilerplate
03:36:11 <ski> osaunders : yes, `(->)' is a type constructor
03:36:25 <ski> SonOfLilit : also, what are the methods of `GameObject' ?
03:36:25 <kmc> SonOfLilit, yeah, all of them are for working with polymorphic containers
03:36:45 <kmc> SonOfLilit, did you see my suggestion above about a design with one type and no classes?
03:36:46 <osaunders> > :t (->)
03:36:47 <lambdabot>   <no location info>: parse error on input `:'
03:36:49 <ski> kmc : s/polymorphic containers/parametric containers/
03:36:52 <osaunders> :t (->)
03:36:53 <lambdabot> parse error on input `->'
03:36:56 <ski> @kind (->)
03:36:57 <lambdabot> ?? -> ? -> *
03:37:13 <kmc> osaunders, types don't have types, types have kinds
03:37:14 <ski> (imagine `??' and `?' read as `*', for now)
03:37:29 <kmc> the kind of (->) is roughly (* -> * -> *), meaning it takes two types and returns a type
03:37:40 <SonOfLilit> ski: GameObject has position, shape, behaviour... all written above
03:37:54 <SonOfLilit> kmc: I saw your suggestions
03:38:09 <osaunders> OK
03:38:54 <ski> SonOfLilit : i see no `position' and `behaviour' above
03:39:01 <ski> SonOfLilit : maybe you could paste your code ?
03:39:19 <ski> SonOfLilit : also, did you check the link i suggested ?
03:39:26 <SonOfLilit> ski: I'll just get it running and I'll paste it
03:39:28 <monadic_kid> SonOfLilit: If you're using state monads and trying update fields, you should check out fclabels
03:39:40 <SonOfLilit> I didn't check it, I've been reading way too much and coding way too little lately
03:39:46 <ski> (and by paste, i mean paste at a paste site, like hpaste
03:39:47 <SonOfLilit> time to get some code through
03:39:47 <ski> )
03:39:58 <kmc> fclabels is useful for more than just State though
03:40:03 <kmc> it's useful for making record syntax nicer in general
03:40:04 <ski> @where hpaste
03:40:05 <lambdabot> http://hpaste.org/
03:40:25 <kmc> for example in the suggestion where you have multiple types but each one contains some core "Object" with the shared stuff
03:40:32 <SonOfLilit> I just removed the state monad from my code, seeing that I only need state->state functions
03:40:33 <kmc> it would be nice for each of those types to expose a fclabel for that core
03:40:59 <osaunders> When the type of a function changes so that it an accommodate an application what is its new type called?
03:41:22 <kmc> changes?
03:41:31 <kmc> you mean when a polymorphic type is specialized?
03:41:38 <osaunders> Yes, exactly
03:41:52 <osaunders> Is specialized the word?
03:41:55 <kmc> yeah
03:42:02 <monadic_kid> SonOfLilit: that is what the state monad refactors
03:42:03 <osaunders> Not instantiated?
03:42:28 <kmc> osaunders, perhaps that too
03:42:37 <osaunders> kmc: OK, thank you
03:42:40 <SonOfLilit> monadic_kid: no, state monad refactors having state -> (state, ret) functions
03:42:40 <kmc> not sure if there's a distinction
03:42:45 <SonOfLilit> I only need state -> state
03:43:08 <SonOfLilit> then there's a different function state -> ret
03:43:13 <kmc> osaunders, in a system like System F where polymorphism is accompanied by explicit type applications
03:43:15 <SonOfLilit> and I can't join them
03:43:24 <kmc> then i associate "instantiate" with those applications
03:43:48 <monadic_kid> SonOfLilit: you get my point, as soon as you have some non-trivial state manipulation and you will in a game you'll have a lot of boiler-plate unmanagable code
03:44:00 <osaunders> System F?
03:44:14 <ski> @google System F
03:44:15 <lambdabot> http://en.wikipedia.org/wiki/System_F
03:44:15 <lambdabot> Title: System F - Wikipedia, the free encyclopedia
03:44:44 <monadic_kid> SonOfLilit: well you can always change it later
03:45:14 <SonOfLilit> monadic_kid: I don't expect having non-trivial state manipulation
03:45:22 <SonOfLilit> but I can indeed refactor later
03:45:43 <kmc> it sounds like you have more important design issues to consider
03:45:48 <kmc> like the representation of objects
03:46:00 <SonOfLilit> kmc: that can also be refactored later
03:46:12 <kmc> well anything can
03:46:14 <SonOfLilit> right now, I just want missiles flying all over the screen
03:46:22 <monadic_kid> heh
03:46:26 <kmc> Haskell is the king of refactoring
03:47:26 <SonOfLilit> is there any more meaning to "using the state monad" than "defining your state manipulation code with state actions and applying them with runState"?
03:47:35 <SonOfLilit> it always sounds like people mean more than that
03:47:39 <SonOfLilit> hard to explain
03:47:39 <osaunders> kmc: Where did you learn about this stuff?
03:47:53 <ski> osaunders : like, instead of saying `map :: forall a b. (a -> b) -> (List a -> List b); map f Nil = Nil; map f (Cons x xs) = Cons (f x) (map f xs)' you say something more like `map :: forall a b. (a -> b) -> (List a -> List b); map a b f (Nil a) = Nil b; map a b f (Cons a x xs) = Cons b (f x) (map a b f xs)' .. i.e. you have explicit type arguments corresponding to the `forall's in the types
03:48:18 <kmc> SonOfLilit, it means using the generic Monad API
03:48:23 <kmc> the "do" syntax and the stuff in Control.Monad
03:48:31 <kmc> the point of having one abstraction called "Monad"
03:48:37 <kmc> the reason it's "the State Monad" and not just "State"
03:48:44 <kmc> is that you get all these control-flow operators for free
03:48:57 <kmc> osaunders, which stuff
03:50:07 <SonOfLilit> kmc: can you point me to some example code that uses the monad API extensively and shows why it's a win?
03:50:33 <SonOfLilit> I mean... my tick function defined on the state monad was just "get state, do stuff on it, put state"
03:50:56 <kmc> it's not always a win
03:51:00 <SonOfLilit> it became much more concise when I just made it Time -> GS -> IO GS
03:51:11 <kmc> there are good APIs for working with functions directly too
03:51:19 <osaunders> kmc: Different types of typed lambda calculus
03:51:21 <monadic_kid> SonOfLilit: I can show you some code but I don't have the code that doesn't use it
03:51:30 <kmc> osaunders, TaPL is a good place to start
03:51:33 <kmc> @where TaPL
03:51:33 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
03:52:04 <kmc> SonOfLilit, if you had something like a list of state-transformers
03:52:14 <kmc> you could glue them together with "sequence", if they're monadic actions
03:52:39 <kmc> as functions you can glue them together with «foldr (.) id»... don't know if there's a name for that
03:52:47 <kmc> or you can wrap them in Endo and glue them with mconcat
03:52:53 <kmc> so... there's lots of options, monadic and not
03:53:19 <kmc> just make sure you're familiar with the Monad API so you can notice if you start to reinvent the wheel
03:53:33 <byorgey> has anyone used the process libraries under linux?  I want to start a process with a shell command, and then later send it signals
03:53:34 <monadic_kid> SonOfLilit: http://github.com/snkkid if you look at this http://github.com/snkkid/LazyFooHaskell/blob/master/lesson28/lesson28.hs is showParticles, if i didn't use monads the code would be horrible
03:53:39 * ski finds "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> nice for showing simple uses of monads, even though it's a bit aged
03:53:46 <byorgey> but the functions to create a process in System.Process give you back a ProcessHandle
03:53:58 <byorgey> and to send a signal it seems you need a ProcessID
03:54:18 <Ke> byorgey: you can use unix
03:54:33 <byorgey> Ke: what do you mean by that?
03:54:55 <Ke> http://hackage.haskell.org/packages/archive/unix/2.4.0.2/doc/html/System-Posix-Process.html
03:55:40 <Ke> fork and exec
03:56:20 <byorgey> ah, thanks, it looks like that will probably work
03:56:29 <SonOfLilit> monadic_kid: wow, that code needs some getting into for me
03:56:33 <SonOfLilit> I'll read it later
03:56:36 <SonOfLilit> now, missiles :
03:56:38 <SonOfLilit> :)*
03:56:47 <SonOfLilit> many thanks though
03:56:49 <monadic_kid> SonOfLilit: actually that paritcular one there is a few examples where monads reduced boiler-plate code
03:57:17 <osaunders> kmc: Do you agree with this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28670#a28670 ?
03:57:18 <monadic_kid> SonOfLilit: are you using SDL?
03:59:44 <kmc> looks good osaunders :)
04:00:09 <osaunders> kmc: OK, thanks
04:00:29 <SonOfLilit> monadic_kid: I'm using OpenGL and GLUT
04:00:50 <SonOfLilit> I might move to SDL when I need input, not sure I feel like reimplementing it
04:01:12 <monadic_kid> SonOfLilit: 2d or 3d game?
04:01:20 <SonOfLilit> spacewars clone
04:01:26 <SonOfLilit> kinda like asteroids
04:01:42 <SonOfLilit> much older and much better, though
04:01:56 <SonOfLilit> have no idea why asteroids caught on and spacewars didn't
04:02:00 <ski> osaunders : "`flip` is specialized to `...` to `id`, which is in turn specialized to `...`" sounds strange .. maybe replace the former "to" with something else ?
04:02:50 <ski> osaunders : maybe you wanted to express something like "`flip` is specialized to `...`, which is being applied to `id`, which is in turn specialized to `...`" ?
04:03:05 <osaunders> Ah
04:03:34 <ski> (possibly it could be formulated better ..)
04:04:08 <Ke> SonOfLilit: asteroids is like boring^n
04:04:22 <osaunders> ski, how about: `flip` is specialized to `...` to accommodate `id`, which is specialized to `...`
04:04:36 <benmachine> does ghc-pkg know whether you have profiling/dynamic libraries installed for some package?
04:04:49 <ski> osaunders : sounds better, yes :)
04:05:47 <osaunders> ski: That word "accommodate" should have been in there to start with.
04:06:11 <ski> i see
04:09:48 <benmachine> wait, do shared libraries even work on windows?
04:10:39 <SonOfLilit> I have mapGameState :: (Object -> Object) -> GameState -> GameState
04:10:49 <SonOfLilit> and tick (Object -> IO Object)
04:11:12 <SonOfLilit> I want :: GameState :: IO GameState
04:11:29 <SonOfLilit> that is GameState -> IO GameState
04:12:02 <ski> you want `mapGameStateM :: Monad m => (Object -> m Object) -> (GameState -> m GameState)', possibly
04:12:35 <benmachine> hmm
04:12:54 <SonOfLilit> there's no way to lift mapGameState?
04:13:01 <SonOfLilit> I have to rewrite it?
04:13:07 <benmachine> I think you can lift it
04:13:30 <mrdk> Is there a simple way to set a picture for the X root window? (like setting a wallpaper)
04:13:40 <ski> benmachine : how ?
04:14:03 <SonOfLilit> mrdk: there's a unix utility that does that
04:14:05 <SonOfLilit> just invoke it
04:14:08 <benmachine> ski: I might be wrong
04:14:16 <benmachine> ...probably am >_>
04:14:28 * hackagebot haskell-updater 1.1.3.0 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.1.3.0 (IvanMiljenovic)
04:14:57 <mrdk> SonOfLilit: I know, like feh or xsetroot I guess. But I'd like to know how to do it with haskell ;)
04:15:06 <benmachine> you can sort of do it if you also have a function to retrieve object
04:15:11 <benmachine> from gamestate
04:15:53 <ivanm> mrdk: probably involves extending the X11 bindings to expose that part of the API
04:16:01 <SonOfLilit> benmachine: what would that function's signature be?
04:16:17 <benmachine> SonOfLilit: GameState -> Object, presumably
04:16:22 <benmachine> erm
04:16:26 <benmachine> no
04:16:28 <benmachine> that wouldn't work
04:16:29 <SonOfLilit> there's more than one
04:16:35 <benmachine> yes I just worked that out
04:16:55 <benmachine> yeah, ski is sensible listen to ski
04:17:33 * hackagebot cryptohash 0.5 - collection of crypto hashes, fast, pure and pratical  http://hackage.haskell.org/package/cryptohash-0.5 (VincentHanquez)
04:17:37 <SonOfLilit> ok
04:17:37 <SonOfLilit> thanks
04:17:41 <SonOfLilit> rewriting it
04:17:49 <benmachine> if tick was IO (Object -> Object) you could do it :P
04:18:02 <benmachine> but that's much more restrictive as a signature
04:18:11 <ski> benmachine : well, with `GameState -> (Object,Object -> GameState)' you could extract and replace parts ..
04:18:34 <ski> (also known as a functional reference / lens)
04:18:50 <benmachine> maybe you could write GameState -> [(Object, Object -> GameState)]
04:19:41 <ski> hm .. that type doesn't sound that accurate
04:20:02 <ski> (you would typically only use one element of the list anyway)
04:21:00 <benmachine> err, yes true
04:21:05 <ski> you'd need some way to decompose a `GameState' into possibly several `Object's, possibly doing operations on them, then recombining all the modified `Objects' back into a single `GameState'
04:21:09 <ski> maybe something like
04:21:19 <benmachine> so Object -> GameState -> GameState
04:21:28 <ski>   GameState -> ([Object],[Object] -> GameState)
04:21:37 <benmachine> or that, I suppose
04:21:50 <ski> (though that seems a bit fragile .. if you change the order, or omit elements, or add elements)
04:22:15 <ski>   GameState -> exists f. Functor f => (f Object,f Object -> GameState)
04:22:19 <ski> seems better to me
04:22:48 <ski> so, `f Object' is some collection of `Objects', possibly a list, but you don't know that
04:23:11 <ski> so, you can't change the structure of the collection, only modify the elements
04:24:07 <ski> though, i suppose in SonOfLilit's case, s/Functor/Traversable/ would be needed
04:24:49 <ski> (otherwise one couldn't `Data.Traversable.mapM' an `Object -> IO Object)' over `f Object')
04:24:56 <ski> @type Data.Traversable.mapM
04:24:57 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
04:25:13 <SonOfLilit> I got the code working
04:25:17 <copumpkin> Saizan: you were right!
04:25:25 <SonOfLilit> with ugly hacks, of course, but as I said - missiles, then elegance
04:25:28 <copumpkin> Saizan: I can derive instances for GADTs now!
04:25:33 <copumpkin> Saizan: but I need to use standalone deriving
04:25:36 <SonOfLilit> I'll paste for your viewing pleasure
04:25:37 <ski> SonOfLilit : paste it yet ?
04:26:07 <ski> benmachine : what do you think of that .. might that be useful in a functional reference library ?
04:27:07 <ski> (oh, and s/Traversable f =>/Traversable f *>/)
04:30:28 <SonOfLilit> http://github.com/SonOfLilit/purewars
04:32:37 <benmachine> ski: that does sound pretty neat
04:35:17 <benmachine> do any compilers actually support exists as a keyword? I was surprised when I found out haskell-src-exts doesn't have it
04:35:31 <copumpkin> JHC
04:35:33 <copumpkin> I think
04:35:39 <copumpkin> and maybe UHC
04:38:51 * benmachine fails to build JHC
04:39:12 <monadic_kid> benmachine: you don't need to build jhc
04:39:23 <monadic_kid> benmachine: if you're using linux
04:39:51 <benmachine> hm?
04:40:08 <monadic_kid> benmachine: are you trying to build jhc?
04:40:21 <benmachine> yes
04:40:28 <monadic_kid> benmachine: are you using linux?
04:40:33 <benmachine> I don't see any binaries around except an rpm
04:40:40 <benmachine> yes
04:40:57 <monadic_kid> benmachine: yeah there is a generic rpm, it should work on any linux distru
04:41:00 <Nibble> Data.List.Split, is it in the standard ghc library?
04:41:13 <benmachine> Nibble: don't believe so
04:41:19 <Nibble> benmachine: ok
04:41:22 <Nibble> that is bad
04:41:28 <Nibble> Il just use filter then
04:41:30 <monadic_kid> benmachine: it's a no-arch rpm i believe
04:41:50 <benmachine> I don't often deal with rpms
04:42:06 * benmachine pokes it
04:42:11 <Nibble> why is it not? It looks really useful
04:42:22 <monadic_kid> benmachine: i recommend it, then you don't need to try and build jhc ;)
04:42:47 <benmachine> Nibble: lots of useful things aren't in the base library
04:42:58 <Nibble> ok
04:43:00 <Nibble> bye
04:43:01 <copumpkin> don't avoid them just cause of that
04:43:04 <benmachine> ...
04:43:07 <copumpkin> o.O
04:43:07 <benmachine> suit yourself
04:43:41 <monadic_kid> benmachine: it's funny because i just did just built jhc from scratch about 30 mins ago, you need a lot of memory and takes a long time so you're better off usnig the rpm
04:44:03 <benmachine> monadic_kid: what did you build it with?
04:45:02 <monadic_kid> benmachine: i just followed the developement page, and you need to install DrIFT as well which is on the same website 
04:45:24 <benmachine> ah, it tried to build without DrIFT
04:45:27 <benmachine> but failed
04:46:12 <monadic_kid> benmachine: jhc itself doesn't take long to build, it's when you come to building libraries for jhc it takes time
04:47:31 <monadic_kid> benmachine: when it reaches Data.Sequence, looks like some bug where it consumes a huge amount of memory and thus slows down
04:47:34 <benmachine> well I'll go and have lunch or something
04:47:47 <benmachine> nope, it broke again
04:47:52 <monadic_kid> benmachine: buf if you leave it, it will finish
04:48:19 <benmachine> oh it didn't find drift this time either
04:48:35 <monadic_kid> benmachine: drift, confiure, make, make install
04:48:36 <benmachine> because it's called DrIFT-cabalized, hmph
04:49:06 <monadic_kid> benmachine: sudo make install
04:51:15 <benmachine> monadic_kid: what did you build it with, wrt compiler/version
04:51:19 <benmachine> because it's still failing
04:51:57 <benmachine> (Ambiguous ocurrence `empty'... either `Info.Info.empty' or `Data.Generics.empty')
04:52:24 <monadic_kid> benmachine: ghc  6.12.1, gcc 4.4.4
04:52:30 <benmachine> huh, weird
04:53:05 <benmachine> unqualified imports :(
04:53:10 <monadic_kid> benmachine: why don't you try to use the rpm instead?
04:53:23 <benmachine> monadic_kid: because build failure here might be a bug
04:53:32 <benmachine> and because building stuff makes you 20% cooler
04:53:57 <monadic_kid> who is is gonna see your coolness? :P
04:54:04 <benmachine> I get a warm internal glow
04:57:15 <monadic_kid> benmachine: which version of ghc are you using?
04:58:22 <benmachine> 6.12.1
04:58:27 <benmachine> I think syb-0.2 is the culprit
04:58:35 <benmachine> I bet you built it with syb-0.1.0.2
04:58:45 <benmachine> or some 0.1 version anyways
04:59:24 <monadic_kid> benmachine: my version is syb-0.1.0.2
04:59:32 <benmachine> that'd be it, then
05:01:00 <benmachine> darcs does it too
05:02:49 <ivanm> "ghc-pkg check" tells you that you should also rebuild transitive deps of broken packages
05:03:09 <ivanm> is there any way I can demonstrate what happens if you _don't_ rebuild those transitive deps?
05:03:52 <ivanm> i.e. I want to demonstrate that by not rebuilding transitive deps it may result in failure down the track
05:09:32 <ski> hm .. should `head :: FRef [a] a' be strict or not ?
05:10:11 <copumpkin> what's FRef?
05:10:28 <ski> functional reference
05:11:39 <ski> here `FRef a b' is `a -> (b,b -> a)'
05:13:16 <copumpkin> why would you want it to be strict?
05:13:55 <ski> possibly to catch errors earlier
05:15:16 <ski> if it isn't strict, then one could `get head (set head 42 [])' and it would return `42'
05:15:40 <copumpkin> yeah, I see
05:16:32 <ski> .. so i'm pondering which of these two behaviours would be more useful
05:16:35 <copumpkin> I guess it'd make sense for it to whnf the list (and hope it's a cons cell) then
05:17:41 <ski> of course, it'd probably be better to use `safeHead :: FRefM Maybe [a] a' instead ..
05:18:24 * benmachine also fails to build UHC
05:38:15 <Peaker> If there's a "withStrategy rpar x" on one IO action (instead of "x" in an IO do block), this of course is "wrong" parallelism, but could this affect the result at all, relative to using "x"?
05:38:57 <zygoloid> how can i find out why 'cabal install' is installing dependencies which are already installed?
05:39:28 <ivanm> zygoloid: --dry-run --verbose=3
05:43:48 <SonOfLilit> Hi again
05:44:03 <SonOfLilit> OpenGL exposes keyboard as a callback for events
05:44:21 <SonOfLilit> what I want is a map key -> isPressed
05:44:52 <SonOfLilit> is there a simple way to get that, or should I move to SDL just for this?
05:45:03 <zygoloid> this is weird. it's reinstalling haskeline in order to add a dependency on terminfo
05:45:15 <zygoloid> that dependency isn't present in the global install of haskeline, at all.
05:45:36 <Ke> SonOfLilit: you can make a global IO variable and set and unset that as callback
05:46:30 * zygoloid tries uninstalling the global haskeline, maybe ubuntu is broken
05:47:02 <SonOfLilit> what would the type of the global variable be?
05:47:11 <Heffalump> Map key Bool
05:47:32 <zygoloid> it also scares me how doing a 'sudo apt-get install/remove libghc6-<foo>' fails while messing around in my /per-user/ .ghc directory
05:47:45 <Heffalump> just make sure to use atomicallyModifyIORef in the callback
05:48:00 <zygoloid> i guess the ubuntu packaging of ghc is just broken ;(
05:48:03 <Heffalump> actually, that may not be necessary either if only one thread is changing it
05:48:06 <SonOfLilit> no need to use atomically, I think - gonna stay single threaded for sure
05:48:10 <Ke> atomicity might be irrelelevant here
05:48:24 <Ke> though I guess with map it would be recommended
05:48:28 <SonOfLilit> but is the performance of the map ok?
05:48:33 <SonOfLilit> Ke: why?
05:48:37 <Heffalump> if you want raw performance, use an IOUArray
05:48:49 <Heffalump> Ke: shouldn't be, the top-level pointer is all that'll change
05:48:53 <SonOfLilit> I want OK performance
05:48:54 <Heffalump> maps are persistent
05:49:00 <Heffalump> for OK performance, I think a map would be fine.
05:49:05 <SonOfLilit> thanks
05:49:07 <SonOfLilit> I'll try
05:49:37 <Ke> still basic operations such as assignment for primitives are typically atomic by hardwar
05:49:43 <copumpkin> omg Vector!
05:49:54 <Ke> and with trivial values corruption is not possible anyways
05:50:00 <Heffalump> Ke: yes, but the IORef would just be a pointer.
05:50:09 <Heffalump> I mean it would just contain a pointer.
05:50:13 <Heffalump> So updating it will be fine.
05:50:18 <Ke> ok
05:50:46 <mietek> Can anyone point me to a nice example use of rank-2 (or N) types?
05:50:55 <zygoloid> mietek: ST
05:50:56 <Heffalump> mietek: ST is a good example
05:51:04 <monadic_kid> SonOfLilit: you need to define what is and is not performant, on console dev you're typically concerned about how many milliseconds features take
05:51:10 <Heffalump> though a bit specialised, in that the actual runST function is magic
05:51:34 <copumpkin> mietek: I wrote a translation of existentials to and from rank-3 the other day
05:52:17 <mietek> That's probably over my head, but is it online?
05:52:26 <copumpkin> it was in a paste, let me find it
05:52:41 <Heffalump> copumpkin: isn't the correspondence obvious? (use forall in negative position)
05:52:47 <copumpkin> yep :)
05:52:55 <zygoloid> why do you need as much as rank 3?
05:52:59 <benmachine> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28450
05:53:01 <Heffalump> yeah, I was wondering that too
05:53:03 <benmachine> that?
05:53:36 <monadic_kid> benmachine: did you have any luck in the end?
05:53:48 <monadic_kid> benmachine: i mean building jhc
05:54:00 <benmachine> monadic_kid: I decided it was a bug and signed up to the mailing list
05:54:01 <Ke> Heffalump: a pointer could be corrupted
05:54:16 <benmachine> I guess if I could find a way to specify syb < 0.2 that should work too
05:54:32 <monadic_kid> benmachine: you're not going to be a mouse and use the rpms :D
05:54:46 <copumpkin> benmachine: yeah
05:54:55 <Heffalump> Ke: the hardware will generally guarantee atomicity
05:54:56 <copumpkin> benmachine: how'd you find it so quickly? :o
05:54:58 <benmachine> monadic_kid: nah
05:55:15 <benmachine> copumpkin: hpaste.org earlier button
05:55:20 <benmachine> few pages back
05:55:25 <benmachine> I remembered having seen it before
05:55:57 <copumpkin> zygoloid: I dunno, that's what it came to :P
05:56:25 <Ke> Heffalump: yup generally, but I can imagine a <=32-bit arch  that would like to address more memory than it natively can
05:58:58 <Ke> still I guess optimizing on atomics is not too haskellish, I would believe still that atomicity will be ever more expensive in the future
05:59:26 <Ke> afaik atomicity is something that can't be bruteforced by more transistors
06:00:09 <Ke> or mutexes and stuff
06:01:20 <copumpkin> oh nice,
06:01:22 <copumpkin> @hackage presburger
06:01:22 <lambdabot> http://hackage.haskell.org/package/presburger
06:03:29 <zygoloid> copumpkin: it's rank-2 because of the existential and rank-3 because of the CPSification
06:03:58 <copumpkin> zygoloid: how would you represent it otherwise?
06:06:00 <zygoloid> wtf :: Exists -> (forall a. Show a => a -> b) -> b; ftw :: forall a. Show a => a -> Exists
06:06:26 <copumpkin> ah, fair enough
06:06:34 <copumpkin> but it's not very "self-contained"
06:06:37 <zygoloid> no
06:07:07 <copumpkin> mmm, I'm really enjoying this presburger package
06:07:09 * ski . o O ( `data Exists f = forall x. Wrap (f x); wtf :: forall f. Exists f -> (forall b. (forall a. f a -> b) -> b); ...' )
06:10:18 <ski>   callCC :: forall m a. MonadCont m => ((forall b. a -> m b) -> m a) -> m a  -- another rank-3 example
06:15:41 <benmachine> oddity: you can't use GeneralizedNewtypeDeriving to derive Typeable
06:15:45 <benmachine> ...probably for the best
06:17:14 <Heffalump> :-)
06:17:52 <copumpkin> in 6.12.3 you can derive things on non-H98 GADTs too!
06:17:55 <copumpkin> I'm so happy
06:17:57 <copumpkin> not sure when they added it
06:18:08 <ski> @hoogle [a] -> ([a],a)
06:18:08 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
06:18:24 <ski> copumpkin : what strange kind a creature would a H98 GADT be ?
06:18:32 <benmachine> copumpkin: with standalone deriving?
06:18:47 <benmachine> ski: presumably something like data Maybe a where Nothing :: Maybe a; Just :: a -> Maybe a
06:19:00 <copumpkin> ski: well, a GADT-syntax thing that could be written as a regular ADT. It'll let you derive classes for those normally, but if you have existential or refinement then it won't
06:19:08 <copumpkin> benmachine: yep!
06:19:37 <benmachine> neat
06:19:47 <ski> ok
06:19:49 <Heffalump> copumpkin: oh, cool.
06:20:14 <benmachine> I thought StandaloneDeriving always let you try, but just tended to fail on exotic GADTs
06:20:22 <ski> @hoogle initLast
06:20:22 <lambdabot> No results found
06:20:30 <benmachine> maybe they improved the deriving mechanism
06:20:55 <copumpkin> oh, maybe it did
06:21:15 * copumpkin is just happy it's possible, cause I was tired of writing my own Show instances :P
06:21:30 <benmachine> heh
06:22:35 <copumpkin> oh, I can write Fin using data families too
06:22:51 * copumpkin clearly hates GADTs, and tries his best to use non-GADT extensions to emulate them
06:25:21 <copumpkin> ah, but it doesn't give me refinement on pattern matching
06:26:07 <copumpkin> (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28674#a28674)
06:26:56 <ski> > (\[] -> ()) []
06:26:57 <lambdabot>   ()
06:27:30 <ski> > (\[] -> ()) [()]
06:27:31 <lambdabot>   *Exception: <interactive>:1:134-142: Non-exhaustive patterns in lambda
06:28:47 <ski>   data instance Fin Z  -- ?
06:29:01 <copumpkin> ski: you don't get one :P
06:29:15 <ski> why shouldn't `Fin' be total on `Z' ?
06:29:47 <copumpkin> I guess I could stick in data Void with EmptyDataDecls
06:29:50 <copumpkin> or newtype V = V V
06:29:53 <ski> (i.e. why shouldn't `Fin Z' be a defined type, namely a type with no constructors)
06:29:56 <copumpkin> but it's not really empty
06:30:20 <ski> yeah, but `Suc _|_' as well
06:31:26 <copumpkin> okay fine :P I added an empty instance
06:32:34 * benmachine wonders what all these stars and ws are on jhc's compily thing
06:32:39 * ski grins
06:32:49 * fryguybob lame :D
06:33:37 <ski> copumpkin : so, if you have a `Fin n', you can't match it on `Suc fn', right ?
06:33:53 <copumpkin> ski: yeah :/
06:34:00 <copumpkin> so this is pretty useless
06:34:19 <copumpkin> just playing with what extensions I can approximate with what
06:34:48 <fryguybob> copumpkin: I'm just curious, but what do you dislike about GADT's?
06:34:55 <copumpkin> I don't dislike them at all :P
06:34:58 <copumpkin> I love them
06:35:15 <fryguybob> copumpkin: Ah, got it.
06:36:07 <copumpkin> playing with types and representations of them and experimenting with various interpreters
06:36:14 <ski> copumpkin : well, in Agda2, you can't match on `Fin n', either ..
06:37:11 <copumpkin> yeah you can
06:37:39 <copumpkin> http://snapplr.com/04px
06:38:26 <copumpkin> (if you match on the implicit n too, you need to make an absurd pattern for the n = zero case)
06:38:48 <copumpkin> but it can spot that and let you pretend you get a Fin (suc n)
06:41:31 <ski> copumpkin : no, that's not matching on `Fin n', that's first matching `n' on `zero' respectively `suc n1', and in the latter case you then proceed to match on `Fin (suc n1)'
06:42:10 <copumpkin> ski: well, it's doing that implicitly
06:42:13 <ski> it's only that the matching on `n' in that snippet is hidden for you .. try adding `{n}' after the `x's in the definition
06:42:27 <copumpkin> yeah, I know :) that's what I said about adding the match on implicit n
06:42:42 <ski> so, i maintain that you can't match on `Fin n' in Agda2, either :)
06:43:01 <copumpkin> well, in the sense that you couldn't have a polymorphic Fin n without introducing the n, implicitly or explicitly
06:43:22 <ski> "polymorphic Fin n" meaning ?
06:43:33 <copumpkin> I couldn't write inj : Fin n -> Fin (suc n)
06:43:42 <copumpkin> I have to put the forall {n} -> Fin n -> Fin (suc n)
06:43:52 <copumpkin> and when I put the implicit there, it gets matched, either implicitly or explicitly :P
06:44:15 <copumpkin> (or {n : Nat})
06:44:31 <copumpkin> since agda doesn't have polymorphism
06:45:21 <ski> if Agda2 had some way of expressing blind quantifiers, then one could do `foo : every {n} -> Fin n -> ..n..' (or whatever syntax), in which `foo' is *not* passed an `n' to match on, so to match on `Fin n', one would then need to discover `n' by other means
06:45:36 <copumpkin> yeah
06:46:45 <ski> so, e.g. one could consider two different implementations of `Vector A n', one in which you must know the shape of `n' before being able to match on the vector; and another in which you can match on the vector anyway, and in the process, discover the shape of `n' (this would be more similar to a GADT, then)
06:48:04 <ski> so, in the former case, a vector could be implemented as basically a (nested) tuple, where one must already know the length to be sure to not to violate type safety (the length information isn't stored in the vector)
06:48:14 <copumpkin> Vector A n = Sigma (List a) (\q -> length q == n) :)
06:48:16 <ski> while in the latter case, a vector carries its own length information
06:49:19 <SonOfLilit> Hi again
06:49:30 <SonOfLilit> I'm having a really strange compiler error
06:49:34 <SonOfLilit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28676#a28676
06:49:45 <ski> copumpkin : yeah, that could work as an encoding of the latter, i think
06:49:48 <copumpkin> but in agda you'd still need to match on n in that case. I guess you could have a doubly nested Sigma, with the outside carrying the length and the inside carrying a list and a proof that the list is of that length. Of course, that would be pointless, but the list would carry its own length :P
06:50:34 <SonOfLilit> would anyone be as kind as to have a look and catch my stupid error?
06:50:56 <ski> SonOfLilit : you appear to be missing a parameter to `realToFrac' (as the error tries to say)
06:51:51 <SonOfLilit> why, indeed, I am
06:52:03 <SonOfLilit> this is not the first time I miss something so obvious in my code
06:52:17 <SonOfLilit> does anyone have tips as to how to look at your code from "stranger eyes"?
06:52:24 <ski> copumpkin : no, you could check whether the list is empty or now, and so you know whether `n' is empty or not, without matching on `n'
06:52:31 <ski> s/or now/or not/
06:53:02 <copumpkin> ski: yeah, I guess
06:53:17 <ski> SonOfLilit : i'm can't think of anything, except to wait some time and not look at the code inbetween
06:53:40 <copumpkin> SonOfLilit: or just learn to read the errors :)
06:53:49 <ski> SonOfLilit : .. it might help to try to explain your code to a teddybear (or a surrogate, thereof, such as another human being)
06:53:51 <copumpkin> since they usually do a good job of telling you what's wrong
06:54:05 <benmachine> SonOfLilit: learning what 'expected' and 'inferred' meant improved my response to errors by about nine million per cents
06:54:58 <SonOfLilit> benmachine: do you have a reference?
06:55:51 <ski> `expected' means what the context of the expression expected in the place of the expression (e.g. what a type signature says, or what the function you're passing an argument to expects)
06:56:08 <ski> `inferred' means what the actual type of the expression itself was inferred to be
06:56:25 <ski> roconnor : ok, in any case, in O'Caml, they'ren't `let'-*commands(/statements)*, but `let'-declarations
06:56:56 <ski> > map "abc" toUpper
06:56:57 <lambdabot>   Couldn't match expected type `a -> b'
06:56:57 <lambdabot>         against inferred type `[GHC.T...
06:57:17 <roconnor> ok
06:57:39 <SonOfLilit> thanks
06:57:45 <ski> here it's complaining that the inferred type of `"abc"' is `[Char]' (aka `String'), but the type expected by `map' for that argument is a type of the shape `a -> b'
06:58:04 <ski> @type map
06:58:05 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:01:08 * benmachine wonders how they'ren't is pronounced
07:02:12 <benmachine> (in my experience, two consecutive contractions are rare. couldn't've's an exception)
07:02:49 <Dr_K> ya'll's?
07:02:51 <Dr_K> ;)
07:02:56 <copumpkin> lol
07:03:09 <copumpkin> more common than some would like
07:03:26 <Dr_K> ya'll's haskell programmers, ain't'cha?
07:04:01 <benmachine> (couldn't've isn't actually an exception, I just felt like doing that)
07:05:24 <Dr_K> couldn't've is an awesome contraction
07:08:00 <copumpkin> pretty quiet in here today
07:09:21 <ski>  
07:09:53 <Maxdamantus> you'dn't
07:09:59 * fryguybob wonders if ski has whitespace-lock on.
07:10:05 <Maxdamantus> you'dn't've thought of this one,right?
07:10:34 * ski points upward, then to the left
07:12:40 <copumpkin> Prelude Data.Integer.Presburger> check $ Forall (\x -> x :<: x + 1)
07:13:41 <fryguybob> I hear Clinton liked himself a Presburger.
07:15:40 <copumpkin> Prelude Data.Integer.Presburger> let iff x y = x :=>: y :/\: y :=>: x
07:15:41 <copumpkin> Prelude Data.Integer.Presburger> check $ Forall (\x -> Forall (\y -> Forall (\k -> (x + k :<: y + k) `iff` (x :<: y))))
07:15:42 <copumpkin> True
07:15:46 <copumpkin> this thing is wonderful
07:15:51 <ski> <http://xorshammer.com/2009/05/14/a-suite-of-cool-logic-programs/> Tarski-Seidenberg Theorem, Quantifier elimination on Reals, Complices, Presburger Arithmetic
07:18:03 <copumpkin> ski: nice :)
07:18:35 <copumpkin> I just wish it were decidable for integers with multiplication :P
07:19:12 <ski> iirc, one could do something with a multiplication relation which can't be proved total
07:19:28 <copumpkin> I'd be interested in any more info you have on that
07:20:18 * ski only vaguely remember hearing about it
07:26:29 <mathijsje> anyone familiair with data.vec? I'm confused why 'instance Random (Vec3 Float) where' doesn't compile.
07:28:10 <copumpkin> http://reperiendi.wordpress.com/2007/11/03/category-theory-for-the-java-%20programmer/ lol
07:28:15 <copumpkin>   class IllegalCompositionError extends Error;
07:29:28 <Phyx-> lol http://failblog.files.wordpress.com/2010/08/69b2b457-4855-4889-8ffd-9c50659d7d80.jpg
07:29:59 <geheimdienst> @google 209 fahrenheit in celsius
07:30:01 <lambdabot> http://www.dr-belair.com/dic/Metrology/Annexes/F-C-Conv-Table.htm
07:30:01 <lambdabot> Title: DR-BELAIR - Fahrenheit to Celsius conversion table
07:30:30 <geheimdienst> bah. wai it not calculator fur me
07:31:33 <Phyx-> lambdabot what's your command to un z-encode something
07:37:01 <Igloo> Can someone who has the HP installed on Windows hpaste the output of "ls '/wherever/Haskell Platform/2010.2.0.0/include'" please?
07:41:41 <fryguybob> Igloo: I don't see such a folder.
07:42:29 <fryguybob> "Haskell Platform\2010.2.0.0\mingw\include" ?
07:43:11 <SonOfLilit> My weekend coding session closes now
07:43:17 <Igloo> fryguybob: Hmm. Is there a 2010.2.0.0\lib\include ?
07:43:38 <fryguybob> Yes
07:43:46 <Igloo> fryguybob: OK, thanks!
07:43:56 <SonOfLilit> With all your kind help, I managed to get a spaceship to fly with user control of thrust and torque and with a sun's gravity
07:44:13 <SonOfLilit> it was a great exercise
07:44:18 <SonOfLilit> I thank you for all your help
07:44:37 <SonOfLilit> if anyone's interested in having a look, the final (as of now) code lies in my github:
07:44:44 <SonOfLilit> http://github.com/SonOfLilit/purewars
07:44:57 <fryguybob> Igloo: Do you still want the paste or did that answer your question?
07:45:08 <Igloo> fryguybob: That answered it, thanks
07:45:20 <fryguybob> Igloo: No problem.
07:46:00 <Igloo> fryguybob: Oh, one mroe question: What directory is the ghc program in?
07:47:42 <Igloo> fryguybob: Actually, n/m
07:47:46 <Igloo> fryguybob: Thanks for your help!
07:47:55 <fryguybob> ok
08:00:42 <zygoloid> > (\n | even n -> 0 | odd n -> 1) 0
08:00:43 <lambdabot>   <no location info>: parse error on input `|'
08:00:44 <zygoloid> ;(
08:02:27 <aristid> :t even
08:02:28 <lambdabot> forall a. (Integral a) => a -> Bool
08:09:18 <SonOfLilit> zygoloid: you can't pattern match in lambdas
08:09:27 <SonOfLilit> use a case
08:10:32 <hpc> pattern matches desugar to case anyway, don't they?
08:11:12 <SonOfLilit> or cases desugar to pattern matches
08:11:16 <SonOfLilit> it is one and the same
08:11:50 <zygoloid> SonOfLilit: you can pattern match in lambdas. but you can't use guards.
08:12:20 <SonOfLilit> zygoloid: I stand corrected
08:12:30 <zygoloid> it's an oddity; almost everywhere you can pattern match, you can use guards, but not in lambdas ;(
08:13:56 <levente_meszaros> maybe it's not the right place to ask, can someone point me to a paper about genetic programming using combinatory logic?
08:17:19 <aavogt> zygoloid: you're allowed    \[$quasiquoter|  whatever syntax you please |] ->
08:18:42 <aavogt> unfortunately there doesn't seem to be a way to encode multiple patterns with the AST that you have to produce with quasiquoter
08:26:32 <fryguybob> :t and
08:26:33 <lambdabot> [Bool] -> Bool
08:26:46 <fryguybob> aavogt: Could you just and them together?
08:29:14 <zygoloid> fryguybob: the trouble is there's no way to allow multiple RHSs
08:30:12 <fryguybob> zygoloid: Could you join the RHS's together in single view pattern that and'ed them?
08:30:30 * fryguybob doesn't know much about view patterns :(
08:31:03 <aavogt> fryguybob: you can't produce view patterns with Pat
08:31:15 <fryguybob> ok
08:32:53 <copumpkin> we need a real-closed field solver in haskell
08:38:38 <chrisdone> Baughn: yeah, the haskell-emacs mailing list is down
08:39:43 <chrisdone> Delivery to the following recipient has been delayed: haskellmode-emacs@projects.haskell.org Google tried to deliver your message, but it was rejected by the recipient domain. We recommend contacting the other email provider for further information about the cause of this error. The error that the other server returned was: 451 451 Temporary local problem - please try later (state 18)
08:40:01 <hpc> @hoogle [a -> b] -> a -> [b]
08:40:02 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
08:40:02 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
08:40:02 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
08:40:06 <Baughn> chrisdone: So's the administrative interface
08:40:23 <Baughn> chrisdone: And I get about a fourth of the mail sent to haskell-cafe
08:41:47 <chrisdone> Baughn: *long sigh*
08:42:22 <Baughn> chrisdone: Oh, and neither of the admins is replying.
08:42:36 <Baughn> Though admittedly I've only given them a day
08:44:11 <fryguybob> @pl \a b -> f (g a) (g b)
08:44:11 <lambdabot> (. g) . f . g
08:44:53 <chrisdone> Baughn: ahh, so no mailing list for the few days a week people have spare time. great
08:46:12 <ski> > [(^2),(^3)] `flip` 5
08:46:13 <lambdabot>   [25,125]
08:46:26 <Baughn> chrisdone: Yep, we definitely need to fix this.
08:46:42 <fryguybob> @hoogle (a -> a -> b) -> (c -> a) -> c -> c -> b
08:46:42 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:46:43 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
08:46:43 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
08:47:08 <chrisdone> Baughn: dons said they already got a new, proper server and upgraded the wiki. I'm wondering when it's going to be used
08:47:14 <ski> @type flip  -- hpc
08:47:15 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:47:33 <hpc> oh
08:47:34 <hpc> cool
08:47:41 <ski> that's "Caleskell", though
08:47:47 <ski> @type Prelude.flip
08:47:47 <Phyx-> so.. no more defacing?
08:47:48 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
08:47:51 <hpc> @src flip
08:47:52 <lambdabot> flip f x y = f y x
08:48:02 <copumpkin> > flip [succ, (*4)] 3
08:48:02 <lambdabot>   [4,12]
08:48:11 <copumpkin> > sequence [succ, (*4)] 3
08:48:12 <lambdabot>   [4,12]
08:48:18 <ski> @type let flip fab a = fmap ($ a) fab in flip
08:48:19 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:48:20 <chrisdone> Phyx-: well, we have to wait for it to actually be implemented live still
08:48:30 <chrisdone> until then it's mostly "I know kung fu" and not enough "show me"
08:48:38 <Phyx-> lol
08:48:45 <copumpkin> I HAVE PROVED THAT FLIP = SEQUENCE
08:48:50 * copumpkin BOWS
08:48:57 <hpc> :t sequence
08:48:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:49:13 <Phyx-> :t flip
08:49:13 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:49:18 <copumpkin> :t Data.Traversable.sequence
08:49:19 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
08:49:23 <copumpkin> :t Data.Traversable.sequenceA
08:49:23 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
08:49:28 <ski> > Data.Traversable.sequenceA [succ,(*4)] 3
08:49:28 <lambdabot>   [4,12]
08:49:43 * copumpkin is installing ocaml again!
08:49:56 <roconnor> copumpkin: nix-env -i ocaml
08:49:57 * Phyx- is compiling ghc again
08:49:58 <chrisdone> copumpkin: compiling Ur?
08:50:12 <copumpkin> chrisdone: nope, a real-closed field solver that ski pointed me at earlier
08:50:15 <chrisdone> (joke: Ur's compiled with standard ML)
08:50:19 <copumpkin> want to play with it
08:50:37 <Phyx-> but.. I don't remember how I got it to work last time
08:52:59 <chrisdone> Baughn: well I'll pop back later to see if the situation's changed
08:53:40 * Phyx- pokes lispy 
08:59:13 <Maxdamantus> What came before the STG machine?
08:59:33 <monochrom> the G machine (without S, without T)
08:59:41 <Maxdamantus> Ah.
09:05:48 <Gracenotes> you can find papers on other g machines
09:06:03 <Gracenotes> and people in the channel who've written them :)
09:06:14 <Phyx-> watch out for the G man
09:08:33 <Maxdamantus> Oh, I thought it was specifically part of GHC or something.. So it's just a general theoretical machine then?
09:08:44 <Phyx-> :t zipWith ($)
09:08:45 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
09:09:50 <benmachine> :t (<*>) `asTypeIn` \ap -> ap []
09:09:51 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
09:10:03 <Phyx-> :t zipWith ($) (repeat (+1))
09:10:03 <lambdabot> forall b. (Num b) => [b] -> [b]
09:10:13 <Phyx-> > zipWith ($) (repeat (+1)) [1..30]
09:10:14 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
09:10:34 <Phyx-> :t zipWith fix
09:10:35 <lambdabot> forall b c. [(b -> c) -> b -> c] -> [b] -> [c]
09:11:08 <Phyx-> :t zipWith (*)
09:11:09 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
09:11:26 <Phyx-> :t zipWith (%)
09:11:27 <lambdabot> forall a. (Integral a) => [a] -> [a] -> [Ratio a]
09:11:58 <Phyx-> zipWith (%) [1..10] [15..5]
09:12:03 <Phyx-> > zipWith (%) [1..10] [15..5]
09:12:04 <lambdabot>   []
09:12:18 <Phyx-> > zipWith (%) [1..10] [5..15]
09:12:19 <lambdabot>   [1 % 5,1 % 3,3 % 7,1 % 2,5 % 9,3 % 5,7 % 11,2 % 3,9 % 13,5 % 7]
09:12:50 <RyanT5000> how tractable is determining whether a function is commutative?
09:13:01 <RyanT5000> (not assuming Haskell or any other specific language)
09:14:16 * ksf just realised the whole awkwardness that's implied by "TypeEq can only equate ground types"
09:15:17 <ksf> ...in particular, it won't unify Num a => a  and say Double
09:15:59 <lispy> RyanT5000: it really depends on the assumptions you make
09:16:15 <ksf> (and ghc then begins to beg for IncoherentInstances)
09:16:50 <RyanT5000> lispy: like what?
09:16:57 <lispy> RyanT5000: But, if it's just a completely arbitrary function, wouldn't you need to check the output of the composition at every value in the input set?
09:17:22 <RyanT5000> lispy: i'm not sure
09:17:40 <RyanT5000> but i'm assuming you have the function source and commutativity information for the functions inside
09:17:43 <lispy> RyanT5000: I think you would, unless you can inspect the body of the functions
09:17:50 <RyanT5000> i suppose you can always build commutative functions out of non-commutative functions
09:17:59 <RyanT5000> yes, i'm thinking of a type-system-level implementation
09:18:06 <blogometer> Can you create a program in Haskell that an end user can install from a Windows MSI?
09:18:07 <RyanT5000> with as much source access as it needs
09:18:23 <blogometer> Easily? Or is it like Java or Ruby, where you need a huge runtime installed?
09:18:58 <RyanT5000> blogometer: i imagine it would be easier to integrate an F# program in that way
09:19:25 <hpc> the haskell runtime gets compiled into the executable
09:19:25 <RyanT5000> ohhh sorry, i misread that
09:19:28 <RyanT5000> msi is fine
09:19:31 <hpc> should be easy
09:19:31 * Phyx- hits lispy with a lambdacat
09:19:34 <copumpkin> :O
09:19:38 <blogometer> Oh, I'm sure a .NET native language would be easier to deploy.
09:19:55 <hpc> .NET can be annoying sometimes though
09:19:57 <copumpkin> RyanT5000: with what knowledge of the domain?
09:19:59 * lispy shrugs off the attack
09:20:00 <blogometer> I'm wondering if Haskell requires GHC to be around to do things, or if it can create stand along executables.
09:20:06 <hpc> because you have to include the version of .NET you built on
09:20:30 <sm> blogometer: it certainly can
09:20:34 <Phyx-> haskell programs have the rts buildin
09:20:42 <lispy> blogometer: standalone
09:20:55 <lispy> tis no big deal
09:20:58 <RyanT5000> copumpkin: i'm not sure what would be needed
09:21:11 <copumpkin> RyanT5000: well, for a finite domain it's easy but slow :P
09:21:25 <Phyx-> blogometer: so yeah, MSI can install it fine, I would suggest using wix though, 
09:21:30 <RyanT5000> copumpkin: haha yeah i'm not so interested in that :P
09:21:48 <RyanT5000> if you don't mind a runtime check, it's also easy
09:22:01 <RyanT5000> basically, i have a situation where having a commutative monoid would be nice
09:22:02 <blogometer> Someone just sent me HLeger, which is yes, what I want.
09:22:04 <RyanT5000> i've already asked about that here
09:22:16 <RyanT5000> but now i'm not really wondering about the practical approaches
09:22:19 <copumpkin> RyanT5000: what kind of a proof are you after?
09:22:20 <RyanT5000> but the theoretical situation
09:22:39 <EvanR> > (1,1)
09:22:40 <lambdabot>   (1,1)
09:22:44 <EvanR> > (-1,-1)
09:22:45 <lambdabot>   (-1,-1)
09:22:47 <copumpkin> the answer depends on the function and how it's implemented, really
09:22:55 <blogometer> Basically, if I'm going to learn a functional programming language, I'd like to take the opportunity to learn a language that doesn't have the install problems of the languages I already know.
09:23:03 <RyanT5000> copumpkin: yeah, i'm assuming source-access
09:23:07 <RyanT5000> just like a type system would normally have
09:23:19 <sm> blogometer: I sent the link. That's not an msi, but is a standalone executable
09:23:21 <copumpkin> proving commutativity for addition on peanos is already not quite trivial, and how you do it depends on whether the definition of addition recurses on the first or second argument
09:23:35 <RyanT5000> huh
09:23:41 <sm> there is something on hackage for creating installers, I believe
09:23:43 <RyanT5000> well, that sounds annoying :P
09:24:20 <copumpkin> RyanT5000: real proofs are often tedious :P coq has a lot of it automated, and if your function is working over a semiring then agda can also help you figure it out
09:24:24 <ksf> most implementations of fp languages are static
09:25:05 <ksf> ...haskell, ocaml and clean compile stuff, whereas scheme/lisp are so small you can easily ship a C interpreter with them.
09:25:11 <ksf> *with the program.
09:26:11 <ksf> I think it's the dynamic typing fad which insists of installing enourmous runtime systems. and java/.net.
09:29:13 <RyanT5000> ksf: being able to dynamically compile code can be useful in some contexts, too
09:29:20 <blogometer> ksf: Fad, huh? Yeah. I'd like to avoid enormous runtime system.
09:29:23 <RyanT5000> which means you need to include a compiler
09:29:45 <ksf> RyanT5000, well, there's hint.
09:29:48 <blogometer> ksf: Too many paradigms. I'd appreciate a limit.
09:30:04 <RyanT5000> there have been a couple of times i've wished i could conveniently use Haskell's type system to prove things at runtime
09:30:07 <ksf> ...which needs a enormous compiler install. GHC, precisely.
09:30:13 <RyanT5000> right
09:30:50 <blogometer> ksf: What a pity. I'd much rather be able to build small executables that users are more likely to install.
09:30:51 <ksf> @faq Can Haskell enable RyanT5000 to prove things at runtime?
09:30:51 <lambdabot> The answer is: Yes! Haskell can do that.
09:31:06 <RyanT5000> hahaha
09:31:17 <Phyx-> @faq can haskell make me a sandwich?
09:31:17 <lambdabot> The answer is: Yes! Haskell can do that.
09:31:23 <ksf> blogometer, well, there's not many reasons to compile code at runtime.
09:31:52 <blogometer> ksf: I'm sure there are, but hopefully it is not a requirement to build a Haskell program.
09:32:07 <ksf> plugins come to mind, but even then you could separate stuff in such a way that only the plugin devs, not the users, need ghc.
09:32:11 <Phyx-> "small executable" is all relative
09:32:15 <ksf> not at all.
09:32:33 <blogometer> Phyx-: Everything in programming is relative.
09:32:37 <Phyx-> comparitively speaking, ghc isn't known for generating "small executables"
09:32:50 <ksf> if you just want a wee bit of scripting for your app, there's always lua.
09:33:02 <ksf> ...which is designed for exactly that. it's small, lean and simple.
09:33:11 <RyanT5000> ksf: i disagree that there aren't many reasons to compile code at runtime; i think that current systems for doing so are too cumbersome, so people haven't found all the cool things to do with it
09:33:26 <copumpkin> RyanT5000: you can prove stuff automatically if you restrict yourself to certain things :) I'm just playing with Data.Integer.Presburger which will tell you if any statement over presburger arithmetic is true or not
09:33:31 <ksf> well xmonad and yi use it
09:33:35 <blogometer> hleger zipped is 1.4 MB.
09:33:41 <blogometer> That is very small to my mind.
09:33:42 <ksf> though I don't recompile my xmonad every day...
09:33:48 <copumpkin> RyanT5000: but that isn't very useful for most things :)
09:33:57 <ksf> blogometer, try stripping the executable.
09:33:57 <RyanT5000> heh yeah
09:34:30 <EvanR> is there is type for lookup table from A to B, where there must be an entry for all A
09:34:32 <copumpkin> RyanT5000: real-closed fields, too! and by extension, integral domains, apparently
09:34:33 <blogometer> No, really, just looking to avoid the "First Install the GHC runtime environment, only 250 MB avaiable from OmniCorp Downloads"
09:34:37 <copumpkin> (although I have yet to play with that)
09:35:00 <copumpkin> it can get impossibly slow though
09:35:47 <sm> blogometer: I think we've answered that
09:35:53 <ksf> blogometer, nah, the rts is included (and inlined) into the compiled code
09:36:11 <sm> you only need to install ghc etc. if you want to build it yourself, eg with cabal install
09:36:13 <ksf> so unless you need eval, you don't need any big stuff.
09:36:27 <blogometer> sm: Yes. I understand now. Thank you.
09:36:58 <blogometer> ksf: I assume that most libraries avoid eval.
09:37:07 <sm> np. Here is the installer builder I heard about: http://hackage.haskell.org/package/bamse
09:37:07 <RyanT5000> blogometer: virtually all
09:37:13 <ksf> no library I know of uses it.
09:37:28 <ksf> ...well, except those that wrap the ghc api to provide eval.
09:37:38 <ksf> a couple of apps use it, though
09:37:56 <blogometer> Right, then eval is really an application level trick to provide a measure of scripting.
09:38:16 <blogometer> All right, cool. Thanks everyone.
09:38:22 <blogometer> Nice community.
09:38:24 <ksf> yi uses eval directly iirc, xmonad is just able to recompile + reload itself on the fly, without eval per se.
09:39:00 <ksf> well, xmonad doesn't use it for scripting, but to specify the configuration.
09:39:06 <dschoepe> ksf: there's also a module for xmonad to evaluate things during runtime though
09:39:15 <ksf> it's more of a library to write custom window managers that a window manager
09:42:02 <alexsuraci> the language I'm working on uses hint for loading haskell source
09:43:41 <alexsuraci> works pretty well, aside from the first thing you load taking a little while. from what I can tell the ones after that are pretty quick.
09:46:56 <m``> Hello StrictAnal
09:47:16 <tias> hi, dose any one know how to get HTTP to connect to https urls?
09:48:13 <ksf> I don't think it includes a SSL layer
09:49:53 <ksf> http://hackage.haskell.org/package/HsOpenSSL-0.8 ?
09:50:04 <fxr> tias: stunnel
09:51:49 <tias> fxr: need it for outgoing connections
09:52:44 <tias> ksf: I was hoping to avoid dependency on OpenSSL, it always seems to cause me headaches :-\, but I'll have to got with it them
09:54:11 <OpMl2MtMfH20r> A buddy of mine actually had both of his computers confiscated by the FBI. Apparently someone had spoofed his IP (or maybe hacked into his wirless) and made a whole bunch of fraudulent purchases. About 8 months later, the FBI decided to give him his computers back? with all his fursona's files mysteriously deleted. This is an outrage.         G1LzRQ4S
09:54:29 <m``> wow
09:54:39 <vanadium> G1LzRQ4S indeed
09:54:39 <L9EkkgaUTR> God damn it. I am sick of these extremist arab fucks. I wish we would turn the region into green glowing glass. Don't feed me this "america caused it" bullshit either, they are a bunch of fucking animals and should be treated as such.         hpB3EYUg
09:54:41 --- mode: ChanServ set +o copumpkin
09:54:43 <L9EkkgaUTR> gays don't belong here you fucking faggot with rippling muscles and clean shaven smooth skin. you need to just take your lisping moustached mouth out of here before the urge gets to be too much and you start fucking people in the ass because you're a gay fag who fucks guys in the ass and sucks dick. now put on your thong and leather pants and get out.         2bZjE1HUL
09:54:46 <L9EkkgaUTR> I'd like to get her on a bed, rip off her pants and her grannie underwear that I just know she wears and then I'd like to flip her over and spread those fat smelly cheeks apart, shove peanut butter in her bunghole, stick my tongue in there and move it around like I am having an epileptic fit eating the creamy treat from her ass. I'd also like to choke her by shoving my schlong down her throat to the point where she is gonna pass
09:54:52 <L9EkkgaUTR> i was going through the logs in my toilet today and i found a letter. i don't remember eating a letter. funny thing is.. it was a letter from my colon telling me to eat less fiber. ps: i'm shutting down until you have sex with men. after plowing the fields of the nearest 12 guys i could find, my brother walks into the room. he says, "haha jokes on you i put that note in your turd. you just fucked a bunch of dudes for nothing, ho
09:54:55 <ksf> @where ops
09:54:56 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
09:54:57 <L9EkkgaUTR> She smiled as she felt her finger become drenched in her mother's hot cunt juice. She was surprised. She reached into her bathrobe and pulled out Karen's panties. If her mother had not been snoring so loudly, Karen would have worried that she was in an alcohol induced coma. Karen pissed for a long time, completely drenching her mother and the bed in warm piss.         Y25OQKVwpk2Kp
09:54:58 --- mode: copumpkin set +m
09:55:05 --- kick: OpMl2MtMfH20r was kicked by copumpkin (OpMl2MtMfH20r)
09:55:13 --- kick: pGSeD5AQ was kicked by copumpkin (pGSeD5AQ)
09:55:35 --- mode: copumpkin set +b *!*@60.217.*.*
09:55:56 --- mode: copumpkin set +b *!*dd82a2e7*@gateway/web/freenode/ip.221.130.162.*
09:56:00 <copumpkin> meh
09:56:15 --- kick: NaMfSe5txYwe was kicked by copumpkin (L9EkkgaUTR KVCHQhByhB6HHi)
09:56:25 --- kick: L9EkkgaUTR was kicked by copumpkin (L9EkkgaUTR)
09:56:27 --- kick: KVCHQhByhB6HHi was kicked by copumpkin (KVCHQhByhB6HHi)
09:56:34 --- mode: copumpkin set -m
09:56:38 <copumpkin> eugh
09:56:43 <blogometer> So...
09:56:44 <copumpkin> this client sucks for "admin" tasks
09:56:48 <wli> What in the Hell?
09:56:59 <alexsuraci> ruh roh
09:57:02 --- kick: yaJ7SBCXqrJaw was kicked by copumpkin (yaJ7SBCXqrJaw)
09:57:05 <m``> this is an outrage!
09:57:06 <m``> this is an outrage!
09:57:07 <blogometer> What do you all use for persistent storage.
09:57:08 <blogometer> ?
09:57:32 <alexsuraci> i switched to couchdb for darcsden recently
09:57:41 <blogometer> Do you generally use RDBMS or is there some, more Haskell way to store data?
09:57:42 <ksf> I don't think there's a thing everyone uses.
09:57:43 --- mode: copumpkin set +b *!*@221.130.*.*
09:58:02 --- kick: DFUloD was kicked by copumpkin (DFUloD)
09:58:08 * sm uses text files and probably soon the persistent lib
09:58:08 <blogometer> ksf: There's a trend, I'm sure.
09:58:11 <copumpkin> okay, my bans aren't working
09:58:21 <VMagJYpSU4> And yeah, I didn't want to get into this, either. It's just that I'm fucking sick to death of furs bagging on other furs just to blow up their own egos. This is what the real problem is in the fandom that "gives us a bad rep". While we're all squabbling over stupid lil mediocre differences like children on a playground, the rest of the world thinks we're all a bunch of skunk fuckers anyways. It's all very inane.         F0KCVwgze
09:58:24 --- kick: VMagJYpSU4 was kicked by copumpkin (VMagJYpSU4)
09:58:40 <sm> other folks use rdbms, and there's also happstack-state
09:58:41 <RyanT5000> is there an accepted standard for "monads with references"?
09:58:52 --- mode: ChanServ set +o Igloo
09:58:53 <RyanT5000> i've seen a few on Hackage, but i'm not sure which one is better-maintained
09:59:06 --- mode: Igloo set +b *!*@gateway/web/freenode/ip.60.217.232.41
09:59:25 --- mode: Igloo set +b *!*@gateway/web/freenode/*
09:59:29 <ksf> if you want a really haskelly thing, try happstack-state
09:59:37 * sm hands copumpkin a blessed ring of power
09:59:39 <blogometer> Yeah. That looks nice.
09:59:47 <benmachine> someone should tell tryhaskell that they just got banned?
09:59:56 <ksf> ...full MACID, memory based, transactional backend.
10:00:17 <blogometer> What does the M stand for (I know the rest)?
10:00:29 <RyanT5000> blogometer: monad
10:00:35 <blogometer> Thank you.
10:00:46 <ksf> erm no
10:00:48 <RyanT5000> np
10:00:52 <blogometer> Oops.
10:00:57 <RyanT5000> ksf: am i wrong?
10:01:16 <RyanT5000> apologies, in that case
10:01:26 <ksf> at least I don't think so
10:01:29 <RyanT5000> in any case, i believe it *is* presented as a monad
10:01:52 <blogometer> Okay, but Atomic, Concurrent, Isolated and Durable.
10:02:06 <m``> STRICTANAL
10:02:08 <m``> STRICTANAL
10:02:18 <ksf> hmmm yes it actually says "macid monad
10:02:55 <blogometer> Oh, data in memory? No, no. Too expensive.
10:03:10 <Phyx-> > Int# 7
10:03:11 <lambdabot>   Not in scope: data constructor `Int#'
10:03:13 <ksf> well, depends on the data.
10:03:25 <Phyx-> > breakfast
10:03:26 <lambdabot>   Not in scope: `breakfast'
10:03:29 <tolkad> :t (\a -> a + (\b -> b))
10:03:30 <lambdabot> forall t. (Num (t -> t)) => (t -> t) -> t -> t
10:03:43 <Phyx-> > cake
10:03:44 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
10:04:17 <tolkad> :t (\a -> (a) + (\b -> b))
10:04:18 <lambdabot> forall t. (Num (t -> t)) => (t -> t) -> t -> t
10:04:32 <ksf> ...in fact, I think each time you don't want to have the data in memory you want a fs-based store.
10:04:57 <tolkad> @let f a b = a + b
10:04:58 <lambdabot>  Defined.
10:05:00 <tolkad> :t f
10:05:01 <ksf> do metadata lookups in memory, then ask the fs for the big chunks.
10:05:01 <lambdabot>     Ambiguous occurrence `f'
10:05:01 <lambdabot>     It could refer to either `L.f', defined at <local>:6:0
10:05:01 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:73:0-32
10:05:07 <tolkad> @let g a b = a + b
10:05:08 <lambdabot>  Defined.
10:05:10 <tolkad> :t g
10:05:11 <lambdabot>     Ambiguous occurrence `g'
10:05:11 <lambdabot>     It could refer to either `L.g', defined at <local>:7:0
10:05:11 <lambdabot>                           or `SimpleReflect.g', imported from SimpleReflect at State/L.hs:73:0-32
10:05:17 <tolkad> @let fg a b = a + b
10:05:18 <lambdabot>  Defined.
10:05:21 <tolkad> :t fg
10:05:22 <lambdabot> forall a. (Num a) => a -> a -> a
10:05:28 <alexsuraci> blogometer: fwiw I switched from happstack-state to couchdb. you could try mongo too. i'd trust couchdb more when it comes to durability though.
10:05:33 <tolkad> How do I write fg without multiple arguments?
10:05:45 <aavogt> > let fg = (+) in fg 1 2
10:05:46 <lambdabot>   3
10:05:59 <alexsuraci> depends on what you're storing
10:06:16 --- mode: ChanServ set -o copumpkin
10:06:51 <tolkad> aavogt: : / I don't mean that.
10:07:03 <alexsuraci> blogometer: there's also redis, which I'm using for the session store (hooray automatic expiration)
10:07:11 <tolkad> @let fg a = (\b -> a + b)
10:07:12 <Phyx-> > cake `is` lie
10:07:12 <lambdabot>  <local>:11:0:
10:07:12 <lambdabot>      Multiple declarations of `L.fg'
10:07:12 <lambdabot>      Declared at: <local>...
10:07:13 <lambdabot>   "The cake is a lie!"
10:07:18 <tolkad> @let fg2 a = (\b -> a + b)
10:07:19 <lambdabot>  Defined.
10:07:22 <tolkad> :t fg2
10:07:23 <Phyx-> > 4 `is` lie
10:07:23 <lambdabot> forall a. (Num a) => a -> a -> a
10:07:24 <lambdabot>   No instance for (GHC.Num.Num [[GHC.Types.Char]])
10:07:24 <lambdabot>    arising from the litera...
10:07:28 <tolkad> oh, that's how
10:07:30 <tolkad> I see.
10:07:33 <benmachine> :t is
10:07:34 <Phyx-> > "foo" `is` lie
10:07:35 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:07:35 <lambdabot>         against inferred type...
10:07:35 <lambdabot> forall a b. a -> (a -> b) -> b
10:07:45 <Phyx-> > ["foo"] `is` lie
10:07:46 <lambdabot>   "Erm.. I dunno"
10:07:50 <benmachine> > flip id lie cake
10:07:51 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
10:07:51 <lambdabot>         against inferred ...
10:07:54 <hpc> :t lie
10:07:55 <lambdabot> [[Char]] -> [Char]
10:07:55 <Phyx-> > cake `is` lie
10:07:56 <lambdabot>   "The cake is a lie!"
10:08:00 <hpc> @src lie
10:08:00 <lambdabot> Source not found.
10:08:08 <tommd> @hoogle improve
10:08:08 <lambdabot> No results found
10:08:13 <tommd> @hackage improve
10:08:13 <lambdabot> http://hackage.haskell.org/package/improve
10:08:15 <tommd> I like the todo
10:09:05 <sm> alexsuraci: how come you're using multiple database technologies ?
10:09:06 <blogometer> alexsuaci: I might only need Berkley DB. redis is C, so I can add it to my program easier. 
10:09:32 <blogometer> alexsuraci: I'll look at redis.
10:09:36 <Phyx-> hpc: the cake is a lie man
10:09:56 <blogometer> I suppose I could make a project of building a native Haskell database.
10:09:59 <hpc> > [[]] `is` lie
10:10:00 <lambdabot>   "Erm.. I dunno"
10:10:05 <alexsuraci> sm: redis is great for volatile simple stuff like sessions (automatic expiration even), couchdb is great for durability (everything else)
10:10:40 <Phyx-> > lie cake
10:10:41 <lambdabot>   "The cake is a lie!"
10:10:46 <Phyx-> :t is
10:10:47 <lambdabot> forall a b. a -> (a -> b) -> b
10:10:48 <alexsuraci> of course redis is probably great for general-purpose stuff too, I just haven't used it for that
10:11:04 <Phyx-> 1 `is` (+1)
10:11:06 <benmachine> > cake
10:11:08 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
10:11:09 <benmachine> oh
10:11:09 <Phyx-> > 1 `is` (+1)
10:11:10 <lambdabot>   2
10:11:12 <benmachine> yes right
10:11:38 <aavogt> is could be a shorter name for  asTypeOf
10:11:57 <benmachine> > 2 + 2 `is` 5
10:11:59 <lambdabot>   7
10:12:04 <benmachine> ...
10:12:06 <EvanR> > 2 < -2
10:12:07 <lambdabot>   False
10:12:17 <Phyx-> @undef
10:12:19 <monochrom> I prefer "like".
10:12:24 <Phyx-> @unlet
10:12:25 <lambdabot>  Defined.
10:12:27 <benmachine> > 5 4
10:12:28 <lambdabot>   Ambiguous type variable `t' in the constraint:
10:12:28 <lambdabot>    `GHC.Num.Num t' arising f...
10:12:32 <benmachine> > 5 4 :: Integer
10:12:33 <lambdabot>   5
10:12:34 <Phyx-> @ttype is
10:12:35 <lambdabot> Not in scope: `is'
10:12:38 <Phyx-> @type is
10:12:39 <lambdabot> Not in scope: `is'
10:12:39 <benmachine> ohh
10:12:41 <Phyx-> > cake
10:12:41 <monochrom> you need "undefine" to clear
10:12:42 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
10:13:20 <Phyx-> @let is a b = isJust (cast a `asTypeOf` b)
10:13:21 <lambdabot>  Defined.
10:13:28 <Phyx-> > 3 `is` 6
10:13:29 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
10:13:29 <lambdabot>    arising from the lite...
10:13:36 <Phyx-> :t is
10:13:37 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b -> Bool
10:13:46 <Phyx-> whoops
10:13:54 <Phyx-> @unlet
10:13:55 <lambdabot>  Defined.
10:14:10 <alexsuraci> you can /query lambdabot btw
10:14:37 <benmachine> unlet is equivalent to let due to super-useful spell correction
10:14:41 <benmachine> +ing
10:14:50 <Phyx-> @let is a b = ap typeOf a b)
10:14:50 <lambdabot>   Parse error: RightParen
10:14:53 <Phyx-> @let is a b = ap typeOf a b
10:14:54 <lambdabot>  <local>:4:12:
10:14:54 <lambdabot>      Couldn't match expected type `a -> b'
10:14:54 <lambdabot>             against...
10:15:40 <keseldude> you can also do: let hello = "world" in map toUpper hello
10:15:48 <benmachine> @let is = (==) `on` typeOf
10:15:49 <lambdabot>  <local>:2:0:
10:15:51 <lambdabot>      Equations for `is' have different numbers of arguments
10:15:53 <lambdabot>    ...
10:16:02 <benmachine> well, anyway.
10:16:06 <tolkad> If I have a function «f :: a -> b -> c -> d» is there a short way to use something as the "c" argument and return the rest of f?
10:16:26 <Phyx-> 7 `is` 4
10:16:27 <benmachine> tolkad: depends how short you want
10:16:30 <Phyx-> > 7 `is` 4
10:16:31 <lambdabot>   True
10:16:37 <Phyx-> > 7 `is` "lol"
10:16:38 <benmachine> tolkad: \a b -> f a b myarg
10:16:38 <lambdabot>   False
10:16:57 <tolkad> benmachine: oh, I didn't know you could use the lambda symbol that way
10:17:06 <Phyx-> benmachine: ah, it's "on" I forgot the name
10:17:35 <aavogt> the types will be wrong though
10:17:36 <tolkad> benmachine: is that the same as \(a, b) -> f a b myarg?
10:17:42 <aavogt> @type (==) `on` typeOf
10:17:43 <benmachine> tolkad: nope.
10:17:43 <lambdabot> forall a. (Typeable a) => a -> a -> Bool
10:17:53 <benmachine> tolkad: \(a, b) -> is a function taking a tuple
10:17:56 <aavogt> @type \x y -> typeOf x == typeOf y
10:17:57 <lambdabot> forall a a1. (Typeable a, Typeable a1) => a -> a1 -> Bool
10:18:02 <benmachine> tolkad: \a b -> is a function taking a two arguments
10:18:06 <benmachine> -a
10:18:17 <benmachine> aavogt: good point
10:18:34 <benmachine> :t on
10:18:35 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:18:47 <tolkad> benmachine: then why is a tuple containing one element the same as that element by itself?
10:19:07 <tolkad> It seems to me like tuple isn't a real type
10:19:18 <benmachine> tolkad: there is no such thing as a 1-tuple
10:19:33 <tolkad> benmachine: oh, that makes much more sense
10:19:35 <aavogt> polymorphic functions aren't easy to pass to functions
10:19:43 <benmachine> tolkad: tuples ARE special types, however
10:19:49 <benmachine> sort of
10:19:59 <benmachine> they behave like normal types but the syntax is special
10:20:17 <benmachine> aavogt: mm, I don't think even rank-N would help here?
10:20:21 <alexsuraci> they're also the bane of general typeclass-writer's existence :P
10:20:52 <aavogt> benmachine: it can allow you to write an 'on' that can take functions like  typeOf
10:21:21 <tolkad> I have never tried putting a tuple inside a type signature, how is that done
10:21:22 <tolkad> ?
10:21:32 <benmachine> aavogt: how? I was thinking, forall a. a -> b as the second argument but that doesn't make sense
10:21:38 <hpc> :t &&&
10:21:39 <Phyx-> :t undefined :: (Int, Int)
10:21:39 <lambdabot> parse error on input `&&&'
10:21:40 <lambdabot> (Int, Int)
10:21:41 <alexsuraci> tolkad: (1.0, "foo") :: (Double, String)
10:21:42 <benmachine> :t uncurry
10:21:43 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:21:57 <benmachine> :t curry
10:21:59 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
10:22:20 <hpc> more generally, (,) is an infix type constructor, so it works just like (->)
10:22:24 <Phyx-> > 5 + 6 - 6
10:22:25 <lambdabot>   5
10:22:32 <Phyx-> @weather
10:22:32 <lambdabot> Unknown command, try @list
10:22:33 <benmachine> hpc: need the parens though
10:22:49 <hpc> :t 5,4
10:22:50 <lambdabot> parse error on input `,'
10:22:55 <hpc> huh
10:23:01 <alexsuraci> :t (,) 5 4
10:23:01 <Phyx-> ::t (5,4)
10:23:02 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
10:23:07 <benmachine> tuples are magic because , is reserved syntax
10:23:11 <Phyx-> :t (5,4)
10:23:12 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
10:23:15 <Luke> :t (,)
10:23:16 <lambdabot> forall a b. a -> b -> (a, b)
10:23:23 <benmachine> (because it comes in handy)
10:23:24 <alexsuraci> :t (,,,,,,,,,,,)
10:23:25 <lambdabot> forall a b c d e f g h i j k l. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (a, b, c, d, e, f, g, h, i, j, k, l)
10:23:31 <alexsuraci> :P
10:23:33 <Luke> (,) makes a tuple?
10:23:39 <Phyx-> > liftM2 (,) [1..5] [1..5]
10:23:40 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
10:23:43 <hpc> alexsuraci: it goes up to 62
10:23:53 <alexsuraci> hpc: haha, I was about to try :P
10:24:06 <alexsuraci> good ol' arbitrary limits
10:24:14 <Luke> :t liftM2
10:24:14 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:24:17 <Phyx-> if you need a 62 tuple I would think you're doing something wrong :)
10:24:27 <benmachine> hpc: I can get more than that
10:24:44 <hpc> if you need more than 3, you are doing something wrong, imo
10:24:47 <alexsuraci> but what if i'm animating something in 63 dimensions!
10:24:50 <Phyx-> yup
10:24:55 <Phyx-> i've never needed > 3
10:24:57 <hpc> and i only allow 3 for a coordinate triple
10:25:01 <Gracenotes> hm, is there a way of saying Maybe-TODO?
10:25:04 <hpc> sometimes
10:25:07 * benmachine can do at least 500
10:25:13 <benmachine> Gracenotes: like that?
10:25:17 <aavogt> > let on_ :: (Typeable a, Typeable b) => (r -> r -> c) -> (forall t. Typeable t => t -> r) -> a -> b -> c; on_ (*) f x y = f x * f y in on (==) typeOf 'a' "a"
10:25:18 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:25:18 <lambdabot>         against inferred type...
10:25:23 <Gracenotes> like instead of TODO: blah, I would say TODO: blah?. -.- there must be a way to deal with this is an organized manner!
10:25:34 <aavogt> > let on_ :: (Typeable a, Typeable b) => (r -> r -> c) -> (forall t. Typeable t => t -> r) -> a -> b -> c; on_ (*) f x y = f x * f y in on_ (==) typeOf 'a' "a"
10:25:34 <lambdabot>   False
10:25:54 <alexsuraci> Gracenotes: "-- HMMM:"
10:25:57 <benmachine> aavogt: that only works for the Typeable case, though :P
10:26:01 <Veinor> haha
10:26:13 <aavogt> yes
10:26:16 * benmachine can make thousand-tuples and is now bored of pressing ,
10:27:07 <alexsuraci> Gracenotes: I usually do "-- TODO?:" or work a question/maybe in there
10:27:18 <Gracenotes> benmachine: it's much more interesting to type-check fmap fmap fmap fmap fmap [... dozens of times...]
10:27:34 <Gracenotes> it's not my fault if you run out of memory
10:28:51 * benmachine fills a page with fmaps
10:29:17 <benmachine> I'm fairly surprised it's not linear or something nice
10:30:03 <hpc> there's a point where they stop changing type, i think
10:30:14 <benmachine> they cycle eventually
10:30:14 <syntaxglitch> benmachine, try this: let ha w x y z f g = f (g w) (g x) (g y) (g z) in ha.ha.ha.ha.ha.ha.ha.ha.ha
10:30:17 <hpc> like, fmap x 6 == fmap x 10
10:30:36 <blogometer> Okay. Happstack looks like Prevalance as a storage strategy.
10:31:02 <benmachine> syntaxglitch: eeek
10:31:06 <syntaxglitch> :)
10:31:07 <blogometer> Which in Java world is Prevayler, which was kind of a fad.
10:31:43 <blogometer> Are there no database primitives implemented in Haskell? Write ahead log or B-tree, I'm looking at Hackage and not finding them.
10:32:59 <blogometer> I suspect that Haskell is a language that likes things to be "pure" and the file system is generally not considered "pure". (Java is like that. Serialization has a lot of ceremony.)
10:35:00 * syntaxglitch wonders if lambdabot has resource limits on type checking
10:35:40 <syntaxglitch> not gonna try though, in case the answer is "no"
10:36:02 <hpc> anything that would exceed reasonable limits would be longer than an RFC-compliant line of IRC chat
10:36:22 <syntaxglitch> hpc, I know it wouldn't spam the channel
10:36:33 <syntaxglitch> I'd just be worried about killing lambdabot
10:36:45 <Veinor> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
10:36:46 <hpc> i mean it wouldn't be possible to check
10:36:47 <pikhq> blogometer: I'm pretty sure there's no handy implementations of them.
10:36:49 <danharaj_> isn't typechecking in haskell worst-case doubly exponential?
10:36:54 <Veinor> :O
10:36:58 <hpc> uh
10:37:00 <lambdabot> thread killed
10:37:04 <syntaxglitch> hahaha, okay
10:37:04 <Veinor> ha
10:37:04 <hpc> lol
10:37:08 <syntaxglitch> that answers that
10:37:12 <blogometer> pikhq: Would it be nice contribution to the community?
10:37:17 * Veinor pushes the button labeled Do Not Push
10:37:25 <syntaxglitch> :t let ha w x y z f g = f (g w) (g x) (g y) (g z) in ha.ha.ha.ha
10:37:26 <pikhq> blogometer: If well-implemented, it could probably be nice.
10:37:27 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8. t6 -> (((t6 -> t6 -> t6 -> (t7 -> t7 -> t7 -> t7 -> t8) -> (t6 -> t7) -> t8) -> (t6 -> t6 -> t6 -> (t7 -> t7 -> t7 -> t7 -> t8) -> (t6 -> t7) -> t8) -> (t6 -> t6 ->
10:37:27 <lambdabot> t6 -> (t7 -> t7 -> t7 -> t7 -> t8) -> (t6 -> t7) -> t8) -> (t4 -> t4 -> t4 -> t4 -> t5) -> ((t6 -> t6 -> t6 -> (t7 -> t7 -> t7 -> t7 -> t8) -> (t6 -> t7) -> t8) -> t4) -> t5) -> ((t6 -> t6 -> t6 -> (
10:37:27 <lambdabot> t7 -> t7 -> t7 -> t7 -> t8) -> (t6 -> t7) -> t8) -> (t6 -> t6 -> t6 -> (t7 -> t7 -> t7 -> t7 -> t8) -> (t6 -> t7) -> t8) -> (t6 -> t6 -> t6 -> (t7 -> t7 -> t7 -> t7 -> t8) -> (t6 -> t7) -> t8) -> (
10:37:27 <lambdabot> t4 -> t4 -> t4 -> t4 -> t5) -> ((t6 -> t6 -> t6 -> (t7 -> t7 -> t7 -> t7 -> t8) -> (t6 -> t7) -> t8) -> t4) -> t5) -> ((t6 -> t6 -> t6 -> (t7 -> t7 -> t7 -> t7 -> t8) -> (t6 -> t7) -> t8) -> (t6 ->
10:37:27 <lambdabot> t6 -> t6 -> (t7 -> t7 -> t7 -> t7 -> t8) -> (t6 -> t7) -> t8) -> (t6 -> t6 -> t6 -> (t7 -> t7 -> t7 -> t7 -> t8) -> (t6 -> t7) -> t8) -> (t4 -> t4 -> t4 -> t4 -> t5) -> ((t6 -> t6 -> t6 -> (t7 -> t7
10:37:29 <lambdabot> [24 @more lines]
10:37:34 * benmachine facepalm
10:37:37 <Phyx-> I never got that, If a button is not to be pushed. why make it a button?
10:37:59 <benmachine> Phyx-: it's implicitly subtitled Do Not Push Unless You Know Better
10:38:01 <syntaxglitch> see, aren't we glad lambdabot has an output length limit
10:38:05 <blogometer> pikhq: Does Haskell do mmap? That makes it easy to do file data structures.
10:38:15 <zygoloid> @type let f :: a -> ((a,a),(a,a)); f = undefined in f.f.f.f.f
10:38:15 <nphg|laptop> syntaxglitch, I tried your ha.ha.ha thing. what has it done to my ghci? It shows the prompt <interactive>:1:0: and uses 100% cpu and 1559MB ram
10:38:16 <lambdabot> forall a. a -> ((((((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)),
10:38:16 <lambdabot> ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), (
10:38:16 <lambdabot> (a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((
10:38:17 <Phyx-> benmachine: unsafePerformPushButton? :P
10:38:18 <lambdabot> a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))), (((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), (
10:38:20 <lambdabot> (a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a))
10:38:22 <lambdabot> [21 @more lines]
10:38:27 <zygoloid> oops :o
10:38:30 <pikhq> blogometer: The whole *concept* of mmap does not really map well into Haskell.
10:38:35 <blogometer> I see mmap-bytestring, maybe Haskell needs a Windows/UNIX version.
10:38:44 <blogometer> Ah. That would be a setback.
10:38:47 <pikhq> blogometer: I mean, you could *do* it, sure, but it's not very Haskelly.
10:38:55 <syntaxglitch> nphg|laptop, the type signature of that expression is gigantic
10:38:57 <geheimdienst> i believe you meant to say, the concept of mmap does not mmap well into haskell
10:39:24 <pikhq> (since you *can* write essentially C with a bizzare syntax inside of Haskell, you *can* totally do mmap. It's just not very nice most of the time.)
10:39:45 <blogometer> pikhq: That's honest and appreciated. mmap is was not very Javay either.
10:40:20 <pikhq> I'm going to guess that mmap-bytestring package has IO with bytestrings which happens to use mmap behind the scenes.
10:40:38 <benmachine> no it just has unsafe on the beginning of the function name :P
10:40:45 <pikhq> benmachine: Ah. :P
10:40:52 <zygoloid> pikhq: yeah. it violates referential transparency iirc
10:40:53 <sbahra> Very newbie question.
10:40:54 <Gracenotes> blogometer: I'm writing a Happstack application, and the lack of database types is kind of annoying at times
10:40:54 <sbahra> Doing something really simple here, I have a massive list of some ADT (data L = A | B | C | D) where A, B, C,D consist of some other ADTs (so, the list is heteregenous). I have a function that will sum some fields of these values (something like sum $ map getField list) and divide by the length (length list) to get an average (fromIntegral $ length list). Memory usage shoots through the roof, I was wondering if there was a conv
10:40:54 <sbahra> enient way to have values I no longer need garbage collected or simplified again (doesn't really seem to the case).
10:41:06 <blogometer> pikhq: I found that if you limited your B-tree data to primitive types, it wasn't so painful.
10:41:27 <sbahra> Let me actually provide a simple example program.
10:42:02 <blogometer> You had to create a simple adaptor to read and write your object from a byte buffer, and then you were back to business with the prevelant paradigm (OO in this case).
10:42:05 <benmachine> sbahra: are you compiling with optimisations? I have a vague recollection that sum isn't sufficiently strict unless you are
10:42:08 <Gracenotes> blogometer: I use Map and Set, and that actually suffices quite well, but a lot of interesting operations aren't even exposed
10:42:14 <benmachine> (you can use foldl' (+) 0 instead)
10:42:23 <sbahra> benc___, yes, I am.
10:42:31 <sbahra> benmachine, yes.
10:42:34 <Gracenotes> it seems your needs are even more intense than mine :)
10:42:36 <benmachine> try foldl' (+) 0 anyway
10:42:43 <benmachine> or hmm
10:42:44 <sbahra> I'll provide you a little example though.
10:42:49 <sbahra> I'll try it now, one minute.
10:43:01 <benmachine> the problem might be the length call holding on to the list
10:43:47 <blogometer> gracenotes: In Java? (Sorry to talk about Java here.) Yes. They are great. You can do a lot in memory, but it is a trade off.
10:44:11 <pikhq> blogometer: Hey, it's a nice break from our usual topic of C++. :P
10:44:38 <Gracenotes> blogometer: in Haskell, I mean
10:44:52 <Gracenotes> for happstack, which I saw you mention above
10:45:13 <sbahra> benmachine, yes, I was thinking it was length.
10:45:21 <Gracenotes> still, they are great in Java, and the concurrent variants as well
10:45:22 <sbahra> benmachine, except, length is pretty efficient, no? I am not using genericLength.
10:45:24 <sbahra> @src length
10:45:24 <lambdabot> Source not found. I feel much better now.
10:45:54 <benmachine> sbahra: the thing is if you have (myFold xs / length xs) it's going to evaluate the fold and then the length, and so it's going to have to hold on to the whole list in between
10:45:56 <blogometer> Well, I have a B-tree in Java and I really appreciate the community being honest with a newbie about what is Haskell friendly and what isn't. A Haskell friendly B-tree is going to require some C programming or some sort of adaptor strategy to go from strongly typed to bytes and back.
10:46:45 <pikhq> blogometer: Well, it's more the matter of having it synced on disk that's complicated.
10:46:50 <benmachine> sbahra: take everything I say with a pinch of salt because I'm not an expert on performance, but I'd think you might be able to get an improvement by calculating length and your sum in the same traversal
10:46:52 <syntaxglitch> nphg|laptop, I estimate that the string representation of the type signature of the expression I gave is about seven megabytes in size
10:47:05 <pikhq> blogometer: If you just want a B-tree data structure, that's pretty simple. :P
10:47:12 <blogometer> pikhq: How so?
10:47:15 <blogometer> Oh, yes.
10:47:17 <syntaxglitch> needless to say GHC burns a lot more memory than that inferring the type
10:47:36 <blogometer> I'm sure an in memory B-tree would be a simple exericse in Haskell. Very recursive.
10:48:05 <sbahra> benmachine, I figured, but sort of kills from the generality of this library. :-P
10:48:24 <pikhq> One that's always synced to the disk would at *minimum* require being written in slightly hairy IO code.
10:48:32 <nphg|laptop> syntaxglitch, I did not ask for the type signature, I try to evaluate the expression :)
10:48:34 <benmachine> sbahra: hmm. how about that example?
10:48:42 <osaunders> How will a knowledge of predicate logic assist me in Haskell?
10:48:50 <sbahra> benmachine, sure, just trying to find that example that totally killed my machine.
10:48:56 <Gracenotes> well, not that hairy. plenty of data structures are disk-IO-friendly and memory-friendly
10:48:56 <pikhq> (which *is* an option)
10:49:18 <syntaxglitch> nphg|laptop, it still has to calculate the signature... not to mention that there's no Show instance for the type, so it'll print the signature anyway in order to tell you that
10:49:20 <blogometer> pikhq: Well, rather than making a durable b-tree, I'd say, use a write ahead log to record your updates, then write to your b-tree.
10:50:08 <blogometer> The b-tree should be recoverable, but making it atomic for each write, there is rough on the I/O. Write ahead log is just tailing a file.
10:50:18 <monochrom> predicate logic and rank-n types are analogous.
10:50:33 <nphg|laptop> syntaxglitch, oh, right. 
10:50:35 <blogometer> So, the b-tree can get dirty and occasionally flushed.
10:50:41 <pikhq> blogometer: Mmm, yeah, that seems feasible.
10:50:46 <sbahra> benmachine, I'll get back to you later today, these runs take a while.
10:50:50 <monochrom> predicate logic is necessary for all programming and all life anyway.
10:50:52 <sbahra> benmachine, 3GB+ data files.
10:51:07 <benmachine> sbahra: erm, I won't be around later today :) but you can try the channel again I guess
10:51:20 <sbahra> Ok.
10:51:32 <nphg|laptop> well let's see how much ram it's gonna take
10:51:45 <sbahra> Sad thing is, a 120 line awk script is doing the job for me with 100x better memory usage ;p
10:51:53 <blogometer> pikhq: I'm looking up Haskell Serialization, since that appears to be the non-Haskelly part of the B-tree.
10:51:58 <EvanR> hehe, who says haskell cant easily handle state... http://codepad.org/pvOE8yLa literal state machines
10:52:02 <sbahra> Of course, no real basis for comparison as far as functionality of the individual programs.
10:52:56 <benmachine> > foldl' (\item (sum, length) -> (,) $! sum + item $! length + 1) (0, 0) [1 .. 1000]
10:52:58 <lambdabot>   Occurs check: cannot construct the infinite type: b = (b, b1)
10:53:00 <benmachine> hmph
10:53:22 <benmachine> > foldl' (\(sum, length) item -> (,) $! sum + item $! length + 1) (0, 0) [1 .. 1000]
10:53:24 <lambdabot>   Couldn't match expected type `(a -> b, a)'
10:53:24 <lambdabot>         against inferred type `b...
10:53:30 * benmachine grumbles agaun
10:53:39 <Gracenotes> my main concern about pure types is that you're limited in the variety of operations you can do with Data.Map and Data.Set, particularly join-type things..
10:53:52 <tolkad> :t (.)
10:53:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:54:23 <syntaxglitch> nphg|laptop, probably it'll top out around a gigabyte or so, but I dunno
10:54:24 <blogometer> I wrote a WAL and B-tree in Java, with the notion that those two utilities, plus Paxos, make up 80% of a contemporary database. (I haven't written a Paxos yet.)
10:54:27 <benmachine> > foldl' (\(sum, length) item -> ((,) $! sum + item) $! length + 1) (0, 0) [1 .. 1000]
10:54:28 <lambdabot>   (500500,1000)
10:54:32 <benmachine> > foldl' (\(sum, length) item -> ((,) $! sum + item) $! length + 1) (0, 0) [1 .. 1000000]
10:54:34 <lambdabot>   (500000500000,1000000)
10:54:37 <tolkad> :t a
10:54:38 <lambdabot>     Ambiguous occurrence `a'
10:54:38 <lambdabot>     It could refer to either `L.a', defined at <local>:2:0
10:54:39 <lambdabot>                           or `SimpleReflect.a', imported from SimpleReflect at State/L.hs:73:0-32
10:54:50 <tolkad> :t u
10:54:51 <lambdabot>     Ambiguous occurrence `u'
10:54:51 <lambdabot>     It could refer to either `L.u', defined at <local>:3:0
10:54:51 <lambdabot>                           or `SimpleReflect.u', imported from SimpleReflect at State/L.hs:73:0-32
10:54:54 <copumpkin> benmachine: you should use composable folds! :P
10:54:54 <benmachine> > (sum &&& length) [1 .. 1000000]
10:54:55 <lambdabot>   (*Exception: stack overflow
10:54:59 <tolkad> :t x
10:55:00 <lambdabot> Expr
10:55:09 <tolkad> @t x
10:55:09 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:55:11 <benmachine> copumpkin: like, iteratees?
10:55:13 <tolkad> :t x
10:55:14 <lambdabot>     Ambiguous occurrence `x'
10:55:14 <lambdabot>     It could refer to either `L.x', defined at <local>:4:0
10:55:14 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at State/L.hs:73:0-32
10:55:24 <tolkad> wtf? why is every letter defined?
10:55:26 <copumpkin> benmachine: nope, just a sec
10:55:32 <copumpkin> > x + 5
10:55:33 <lambdabot>   Ambiguous occurrence `x'
10:55:34 <lambdabot>  It could refer to either `L.x', defined at <local...
10:55:36 <copumpkin> oh
10:55:40 <zygoloid> tolkad: just for fun :)
10:55:43 <benmachine> :t L.x
10:55:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:55:51 * benmachine blinks
10:55:51 <zygoloid> > foldr f x [a,b,c,d,e]
10:55:53 <lambdabot>   Ambiguous occurrence `x'
10:55:53 <lambdabot>  It could refer to either `L.x', defined at <local...
10:55:56 <zygoloid> ;(
10:56:02 <benmachine> > foldr f z [a,b,c,d,e]
10:56:04 <lambdabot>   Ambiguous occurrence `a'
10:56:04 <lambdabot>  It could refer to either `L.a', defined at <local...
10:56:08 * benmachine melts
10:56:10 <copumpkin> benmachine: http://squing.blogspot.com/2008/11/beautiful-folding.html and edwardk took it further (after an intermediate iteration from me): http://comonad.com/haskell/Origami.hs
10:56:17 <zygoloid> @undef
10:56:22 <zygoloid> > foldr f x [a,b,c,d,e]
10:56:23 <lambdabot>   f a (f b (f c (f d (f e x))))
10:56:25 <blogometer> What libraries (or methodologies) do you use to convert Haskell to JSON and back?
10:56:32 <syntaxglitch> EvanR: there's an arrows package that defines state machines like that for you
10:56:36 <syntaxglitch> with some nice instances and such
10:57:02 * hackagebot archlinux 0.3.1 - Support for working with Arch Linux packages  http://hackage.haskell.org/package/archlinux-0.3.1 (DonaldStewart)
10:58:02 * hackagebot cabal2arch 0.7.3 - Create Arch Linux packages from Cabal packages  http://hackage.haskell.org/package/cabal2arch-0.7.3 (DonaldStewart)
10:58:34 <tolkad> :t a2
10:58:44 <nphg|laptop> syntaxglitch, had to kill it, it started to swap to much at nearly 4GB
10:58:45 <tolkad> what happened to lambdabot?
10:59:17 <syntaxglitch> nphg|laptop, ouch
10:59:20 <sbahra> @botcrack
10:59:24 <sbahra> ;[
10:59:31 <lambdabot> Not in scope: `a2'
10:59:31 <lambdabot> :)
10:59:57 <tolkad> lol I can keep lambdabot busy
11:00:37 <benmachine> sbahra: did you read copumpkin's link? it's pretty neat
11:01:39 <sbahra> I'll take a look. Thanks guys.
11:01:45 <sbahra> Reading it now.
11:02:53 <copumpkin> wow, I can't think of a better way to show that you're serious than by putting a java animation at the top of your page: http://www.cs.bu.edu/~hwxi/DML/DML.html
11:03:34 <dolio> I think there may be a similarity between iteratees and that fold stuff.
11:03:36 <hpc> i haven't seen an applet in years
11:03:53 <copumpkin> dolio: yeah
11:03:54 <dolio> In that both represent eliminations of some sort of stream.
11:03:56 <nphg|laptop> syntaxglitch, the typesignature is nice and ghci needs only 445MB. printing it took 1min52 cpu time...
11:04:09 <dolio> And ways of combining them.
11:04:17 <nphg|laptop> so it was the evaluating that was problematic...
11:05:45 <syntaxglitch> nphg|laptop, interesting, I wonder why that would be
11:05:45 <ksf> does anyone have an idea whether it's possible to write hType2HNat with typeCast instead of typeEq?
11:06:05 <ksf> I'd like to accept unifiable types as equal, not only equal ground types.
11:08:29 <syntaxglitch> ksf, remind me what hType2HNat does?
11:08:57 <sbahra> Yeah, might be stuck doing something like that.
11:09:01 <sbahra> Not too bad, I guess.
11:09:12 * syntaxglitch hasn't had enough coffee yet to read Oleg code today
11:09:19 <ksf> looking up a type in a HList and returning the index
11:09:25 <syntaxglitch> oh
11:09:26 <syntaxglitch> hm
11:09:31 <syntaxglitch> no, probably not going to work
11:10:05 <syntaxglitch> typeCast generally produces compiler errors on types that don't unify
11:11:00 <syntaxglitch> as far as I know, there's no way to simultaneously unify types that can be unified, while also setting a boolean value indicating unequal types
11:12:01 <ksf> yeah that's why I'm trying to hack around needing HFalse
11:12:23 <syntaxglitch> there's probably a workaround if you can be certain that all types will either 1) successfully unify or 2) be sufficiently grounded to be recognizable unequal
11:12:44 <syntaxglitch> but the fully general case is probably impossible
11:14:30 <ksf> \o/ I can successfully look up a ground type in a hlist with an unground type, iff the ground type is at the head
11:14:32 <ksf> ...not really.
11:18:44 <syntaxglitch> ksf, working with unground types is a pain in type-level programming, I suggest avoiding it where possible
11:20:57 <ksf> Well I've got the ground case nailed down and wondered whether I can make my stuff properly polymorphic.
11:21:14 <ksf> as loosing polymorphism limits the way you can write abstractions
11:21:18 <ksf> *losing
11:21:25 <ksf> (some day I'm going to learn that)
11:22:54 <carter> whats the current "best" trie style set module on hackage?
11:23:34 <carter> if you're dealing with on the order of 10,000 - more strings of relatively short length?
11:24:25 <carter> would that be bytestring-trie?
11:24:58 <syntaxglitch> ksf: not sure how well that's going to work... but good luck! :D
11:30:39 <ksf> what's even more annoying is that this cool new ghc feature, ~, is actually less powerful than TypeEq
11:34:32 <syntaxglitch> ksf, it's closer to typeCast
11:34:48 <syntaxglitch> in fact, I usually rename the TypeCast class to :~ in my code
11:34:52 <tolkad> Why is this talking about sort? http://cvs.haskell.org/Hugs/pages/libraries/base/Data-ByteString.html#v%3AunsafeHead
11:35:12 <Philonous> haddock drops the documentation of the first function argument (and put's the rest one line higher). Is this a bug or am I doing something wrong?
11:35:59 <copumpkin> tolkad: bug? why are you looking at ancient hugs documentation?
11:36:29 <dolio> TypeEq is decidable equality on types, isn't it?
11:36:47 <dolio> ~ is a proof of equality.
11:37:01 <syntaxglitch> TypeEq is an equality predicate
11:37:35 <syntaxglitch> it always succeeds, and unifies a third type with a boolean value depending on whether two types are the same
11:38:19 <syntaxglitch> typeCast is an assertion of equality, and will either unify the types or produce a compiler error
11:43:21 <alip> does c2hs have a way to bind constants defined using #define to haskell?
11:46:14 * hackagebot jack-bindings 0.1 - Bindings to the JACK Audio Connection Kit  http://hackage.haskell.org/package/jack-bindings-0.1 (PhilippBalzarek)
11:46:19 <ksf> having a "those types are unifiable" class that maps to a boolean would be so darn useful.
11:46:30 <alip> hsc2hs has #{const} and #{const_str} but i want to know if c2hs has a way to do it
11:46:57 <ksf> alip, the common way to do it is to translate them into enums
11:47:11 <ksf> ...within #c #endc blocks.
11:47:39 <tolkad> copumpkin: this is old? where is the new documentation then? this is the first result on google
11:47:58 <alip> ksf: and how to do it for constant strings?
11:48:00 <copumpkin> tolkad: I often search for GHC + the term
11:48:10 <copumpkin> tolkad: google doesn't care
11:48:11 <alip> e.g. #define CS "foo"
11:48:12 <ksf> dunno, never did that.
11:48:17 <tolkad> is GHC different than HUGS?
11:48:23 <tolkad> what's hugs anyway?
11:48:23 <alip> ksf: i see, thanks
11:48:33 <tolkad> I thought it's just what happens when GHC gets really friendly
11:48:36 <copumpkin> tolkad: hugs is an old interpreter that's mostly not used these days
11:48:42 <ksf> but one approach would be to define a global variable.
11:49:13 <copumpkin> noes!
11:49:20 <copumpkin> blasphemy!!!
11:49:34 <ksf> err.
11:49:37 * ksf meant symbol.
11:49:39 <monadic_kid> alip: i told you yesterday, you use the {#enum it works defines and c-enums
11:49:41 <ksf> and of course it's static.
11:50:00 <alip> monadic_kid: must have missed that sorry
11:50:50 <monadic_kid> alip: have a look here: http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/implementing.html#id314717
11:50:53 <copumpkin> Exercise: is http://snapplr.com/qhsj true?
11:51:55 <copumpkin> :P
11:52:15 * hackagebot binary-shared 0.8.1 - Sharing for the binary package  http://hackage.haskell.org/package/binary-shared-0.8.1 (JuergenNicklischFranken)
11:53:10 <tolkad> > openFile "."
11:53:12 <lambdabot>   Not in scope: `openFile'
11:53:47 <nphg|laptop> copumpkin, of course it is ;) 
11:54:31 <tolkad> > unsafePerformIO print 5
11:54:32 <lambdabot>   Not in scope: `unsafePerformIO'
11:54:37 <tolkad> > unsafePerformIO $ print 5
11:54:38 <lambdabot>   Not in scope: `unsafePerformIO'
11:54:50 <tolkad> Can someone bring it into scope?
11:54:53 <tolkad> I want to use it
11:54:55 <copumpkin> tolkad: uh, no
11:55:03 <tolkad> copumpkin: why?
11:55:09 <copumpkin> the whole point is that we don't want people hacking the bot
11:55:14 <copumpkin> so no IO
11:55:58 <tolkad> > unsafeCoerce 5 :: String
11:55:59 <lambdabot>   Not in scope: `unsafeCoerce'
11:56:04 <tolkad> : (
11:56:21 <tolkad> can we at least have unsafeCoerce?
11:56:30 <copumpkin> no, that'll let you crash the bot
11:56:40 <copumpkin> why not just run it locally in ghci?
11:59:36 <tolkad> copumpkin: Because I wanted to try to crash the bot
11:59:45 <copumpkin> :)
12:00:00 <tolkad> copumpkin: is there any way to get a list of what is in scope?
12:00:10 <copumpkin> not that I know of
12:00:13 <copumpkin> there's loads
12:01:13 <aavogt> @help
12:01:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:01:17 <aavogt> @list
12:01:17 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:01:31 <aavogt> tolkad: the bot's source is roughly the same as in there ^^
12:07:27 <tolkad> > do {a <- getLine; error a}
12:07:29 <lambdabot>   Ambiguous type variable `b' in the constraint:
12:07:29 <lambdabot>    `Data.Typeable.Typeable b...
12:07:37 <tolkad> @more
12:07:59 <aristid> :t getLine >>= error
12:08:01 <lambdabot> forall b. IO b
12:08:16 <aristid> :t do {a <- getLine; error a}
12:08:17 <lambdabot> forall b. IO b
12:08:34 <tolkad> why is it failing? what's wrong with my code?
12:08:55 <c_wraith> it doesn't know what b is.
12:08:57 <aristid> tolkad: it's not wrong, lambdabot just doesn't know which of the infinite number of possible types to use
12:09:07 <hpc> nor can it run getLine
12:09:20 <c_wraith> hpc, that's not really a problem
12:09:23 <aristid> hpc: iirc it has a Show instance for IO
12:09:35 <c_wraith> > getLine >>= error :: ()
12:09:36 <lambdabot>   Couldn't match expected type `()'
12:09:36 <lambdabot>         against inferred type `GHC.IOBase...
12:09:37 <tolkad> > do {a <- getLine; error a} :: IO String
12:09:38 <lambdabot>   <IO [Char]>
12:09:42 <c_wraith> > getLine >>= error :: IO ()
12:09:43 <lambdabot>   <IO ()>
12:09:44 <tolkad> why isn't there an exception?
12:09:51 <tolkad> shouldn't the error cause an exception?
12:09:59 <c_wraith> tolkad, because it evaluates it, not executes it.
12:10:40 <c_wraith> in order to get the exception, it would need to execute getLine to get the string to pass to error
12:10:53 <copumpkin> tolkad: lambdabot doesn't do IO at all
12:11:01 <copumpkin> it evaluates expressions, doesn't run actions
12:11:04 <hpc> lambdabot builds a thing and shows you it
12:11:05 <c_wraith> Instead it merely evaluates it.  that is, builds up the IO expression, and then prints a representation of it for you
12:11:24 <hpc> when it builds an IO action, it doesn't run it, it makes something that will do the actions
12:11:39 <hpc> then it shows you the type, because that's what the instance is
12:12:01 <hpc> the actions don't get performed
12:12:11 <tolkad> well how am I supposed to crash it if they aren't performed?
12:12:18 <hpc> exactly
12:12:34 <c_wraith> > fix (+0) -- :)
12:12:37 <lambdabot>   mueval-core: Time limit exceeded
12:12:50 <c_wraith> that's as close as you can get, unless you find a ghc bug
12:12:59 <copumpkin> :k Natural
12:13:00 <lambdabot>     Not in scope: type constructor or class `Natural'
12:13:03 <copumpkin> we used to have that
12:13:07 <copumpkin> I wonder where it went
12:13:11 <copumpkin> then we could write fix succ
12:13:16 <c_wraith> > 1 :: Natural
12:13:18 <lambdabot>   Not in scope: type constructor or class `Natural'
12:13:44 <c_wraith> > error "foo"
12:13:45 <lambdabot>   *Exception: foo
12:13:50 <syntaxglitch> hmmm
12:14:00 <syntaxglitch> @type let ha w x y z f g = f (g w) (g x) (g y) (g z) in ha.ha.ha.ha.ha.ha.ha.ha
12:14:11 * syntaxglitch pokes lambdabot with a stick
12:14:18 <lambdabot> thread killed
12:14:26 <syntaxglitch> \o/
12:14:29 <hpc> lambdabot should give up sooner
12:14:40 <hpc> 20 seconds is a bit long, imo
12:14:58 <syntaxglitch> @pl let ha w x y z f g = f (g w) (g x) (g y) (g z) in ha.ha.ha.ha.ha.ha.ha.ha
12:15:02 <lambdabot> ap (.) (ap (.) (ap (.) (ap (.) (ap (.) (ap (.) (join (.))))))) (flip (flip . (flip .) . (((.) .) .) . ((flip .) .) . (((ap .) .) .) . flip (flip . ((.) .) . (flip .) . ((ap .) .) . flip ((.) . flip .
12:15:02 <lambdabot>  (ap .) . flip (.) . flip id) (flip id)) (flip id)) (flip id))
12:15:02 <lambdabot> optimization suspended, use @pl-resume to continue.
12:15:06 <syntaxglitch> heh
12:15:19 <hpc> @pl-resume
12:15:25 <lambdabot> ap (.) (ap (.) (ap (.) (ap (.) (ap (.) (ap (.) (join (.))))))) (flip (flip . (((flip . ((.) .)) . (flip .)) .) . (((ap .) .) .) . flip (flip . ((.) .) . (flip .) . ((ap .) .) . flip ((.) . flip . (
12:15:25 <lambdabot> ap .) . flip (.) . flip id) (flip id)) (flip id)) (flip id))
12:15:25 <lambdabot> optimization suspended, use @pl-resume to continue.
12:15:34 <hpc> @pl-resume
12:15:47 <lambdabot> ap (.) (ap (.) (ap (.) (ap (.) (ap (.) (ap (.) (join (.))))))) (flip (flip . ((flip . (((.) . flip . (ap .)) .)) .) . flip (flip . (((.) . flip) .) . ((ap .) .) . flip ((.) . flip . (ap .) . flip (.)
12:15:47 <lambdabot>  . flip id) (flip id)) (flip id)) (flip id))
12:15:47 <lambdabot> optimization suspended, use @pl-resume to continue.
12:15:55 <hpc> yeah, that's not getting prettier
12:15:55 <copumpkin> we get the point :P
12:16:05 <syntaxglitch> there is no point
12:16:07 <syntaxglitch> that's the idea
12:16:14 <hpc> :D
12:16:14 <Phyx-> boy, FFI is sure slapping me around today
12:16:17 <copumpkin> you can put @pl into a loop fairly easily
12:16:39 <aristid> so that was an infinite loop ath @pl is caught in?
12:16:41 <tolkad> wait... how long does it wait?
12:16:54 <tolkad> for someone to call @pl-resume?
12:17:22 <tolkad> nevermind, it probably uses a trivial amount of memory anyway
12:17:40 <hpc> it saves it until the next pl
12:19:37 <mrdk> Is there a way to define static variables in Haskell like in C?
12:19:50 <jmcarthur> mrdk: what does that even mean in haskell context?
12:19:57 <hpc> what does static do in C?
12:20:45 <c_wraith> hpc: creates a function-scoped global variable
12:21:32 <BrianHV> @info mplus
12:21:32 <lambdabot> mplus
12:21:52 <BrianHV> hm.  not quite what I was looking for...
12:22:06 <aavogt> @docs Control.Monad
12:22:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
12:22:44 <BrianHV> thanks
12:22:49 <mrdk> jmcarthur: good question. Basicly I just want a variable which stores its value upon multiple calls inside a function
12:23:31 <zachk1> mrdk you dont really want that 
12:23:33 <aavogt> you can do that if your function is like       generateMyFun :: IO ( .... -> IO ?? )
12:23:49 <c_wraith> yeah, you could do it with nested IO
12:23:55 <c_wraith> sometimes, that is what you want.
12:24:14 <jmcarthur> mrdk: what is the use case you have in mind? perhaps we can suggest something more haskelly
12:24:39 <aavogt> so the outer IO calls newIORef, and the inner IO refers to that ioref
12:27:31 <mrdk> jmcarthur: I have a function which takes a screenshot (using scrot through readProcessWithExitCode). I thought of using some sort of lock, to prevent too much calls on the function (and taking too much screenshots)
12:29:06 <EvanR> that is optional complexity
12:29:10 <EvanR> cut it out
12:29:27 <jmcarthur> okay, i would say the rate of taking screenshots is a different concept from taking a screenshot, so that should be outside of the screenshot function
12:29:47 <jmcarthur> but that is an interesting design problem, nonetheless
12:30:16 <EvanR> you can hide such a time-based IO command behind a MVar in another thread
12:30:27 <jmcarthur> EvanR: that might be unnecessary complexity though
12:30:50 <jmcarthur> especially if mrdk is just planning to use it procedurally and have it block if it's going to fast anyway
12:30:58 <EvanR> could be abstracted and reused... limitIO :: IO a -> MVar a
12:31:05 <EvanR> -> Int -> 
12:31:15 <EvanR> IO MVar a
12:31:21 <EvanR> something
12:31:34 <jmcarthur> but why do through all that when you could just have:  limitIO :: Int -> IO a -> IO a
12:31:47 <jmcarthur> and use the trick that aavogt suggested in limitIO
12:32:09 <aavogt> or some other trick for a global variable...
12:32:23 <jmcarthur> yeah there's always the unsafePerformIO hack, but i think that might be overkill
12:32:37 <EvanR> its all overly complex
12:33:00 <jmcarthur> mrdk: under what conditions would too many screenshots be taken in your program?
12:33:21 <jmcarthur> maybe those conditions are what should be controlled rather than the screenshot function itself
12:34:39 <mrdk> jmcarthur: the screenshot function is triggered via a key binding. So f.e. if I hit the key too often
12:35:43 <EvanR> yeah nicer if you just limit key presses
12:36:02 <c_wraith> this sounds like xmonad
12:36:10 <mrdk> c_wraith: yes, heh
12:36:13 <c_wraith> you're bound by the framework, to some extent
12:36:16 <jmcarthur> agreed. this sounds more like it should be an input throttle than an output lock
12:37:04 <jmcarthur> mrdk: making a keystroke to take a screenshot and upload to imgur? :)
12:37:35 <Phyx-> > 1 :: CInt
12:37:37 <EvanR> sounds like a job for a shell script
12:37:39 <lambdabot>   Not in scope: type constructor or class `CInt'
12:37:46 <mrdk> jmcarthur: exactly, something like that ;)
12:38:13 <c_wraith> don't press that key when watching porn! :P
12:38:22 <EvanR> lol
12:38:34 <jmcarthur> depends if it can be traced back to you
12:38:48 <Phyx-> does.. GHC free pointers it gets via FFI?
12:39:01 <monochrom> I think no.
12:39:17 <jmcarthur> Phyx-: you are responsible for making sure pointers get freed in some way
12:39:22 <jmcarthur> the API offers a few ways
12:39:44 <jmcarthur> and some C interfaces do it for you or require special functions to do it
12:39:54 <jmcarthur> so you just have to make sure you understand what you are doing
12:39:56 <Phyx-> jmcarthur: i'll just free them in the C# side, I just needed to know :)
12:40:08 <jmcarthur> ah okay
12:42:02 <monadic_kid> Phyx-: what is the pointer pointing too? 
12:42:13 <Phyx-> now I need to figure out why the api doesn't like it...
12:42:22 <chrisdone> Baughn: any change in the patient?
12:42:37 <Phyx-> monadic_kid: a SrcSpan struct
12:43:13 <monadic_kid> Phyx-: is it heap allocated, who where was it allocated,
12:43:45 <Phyx-> monadic_kid: it's allocated in the unmanaged heap
12:45:12 <Baughn> chrisdone: Ah, nope.
12:45:16 <monadic_kid> Phyx-:  if use foreign pointer, you can assign a clean up function when it's not being used anymore
12:45:54 <chrisdone> Baughn: immutable!
12:46:04 * chrisdone drumroll
12:46:08 <Baughn> chrisdone: I don't want immutable bugs! ;_;
12:47:36 <monadic_kid> Phyx-:  you can also create scoped allocations with alloca
12:47:52 <monadic_kid> Phyx-:  alloca $ \ptr -> do stuff with ptr, return 
12:48:01 <Phyx-> monadic_kid: it's not allocated in haskell
12:48:09 <Phyx-> i'll just free it once the call returns
12:49:03 <monadic_kid> Phyx-: I'd use foreign pointer, it gets mess when you have multiple exit paths and dealing with exceptions
12:49:10 <monadic_kid> *messy
12:50:54 <chrisdone> A computer is like a violin. You can imagine a novice trying first a phonograph and then a violin. The latter, he says, sounds terrible. That is the argument we have heard from our humanists and most of our computer scientists. Computer programs are good, they say, for particular purposes, but they aren't flexible. Neither is a violin, or a typewriter, until you learn how to use it.  — Marvin Minsky, ``Why Programming Is a Good Medium
12:50:54 <chrisdone> for Expressing Poorly-Understood and Sloppily-Formulated Ideas''
12:51:01 <chrisdone> Haskell is also like a violin
12:51:36 <ezyang> I'm not sure I agree with Minski and Knuth on this. 
12:51:46 <ezyang> *Minsky 
12:52:03 <EvanR> he was thinking of dynamic languages ;)
12:53:39 <aristid> i wonder if this can become a popular story: "Dynamic [typed] languages win in the worse-is-better department."
12:53:52 <Saizan> i'm surprised that period wasn't expressed by programming
12:54:17 <aristid> worse-is-better is such a popular meme, despite the doubts on whether it is actually accurate
12:54:28 <syntaxglitch> I'm not sure a violin is the best comparison
12:54:31 <syntaxglitch> perhaps a theremin
12:54:32 <micahjohnston> I don't get what is meant by worse is better
12:55:33 <aristid> micahjohnston: why did x86 win over RISC architectures? why did VHS win over Beta? because worse is better!
12:55:37 <aristid> or so goes the meme.
12:55:41 <micahjohnston> oh ok
12:55:41 <micahjohnston> xD
12:58:08 <chrisdone> worse is better, also known as, I want it crap now, not good later
12:59:03 <syntaxglitch> and sometimes that really is what you need
12:59:25 <syntaxglitch> but keep doing that enough and eventually the good will die of neglect
12:59:32 <syntaxglitch> and all you'll have will be crap as far as the eye can see
13:01:13 <CalmNelly> Jambo!
13:01:39 <Phyx-> syntaxglitch: time to put down the booze
13:02:30 <syntaxglitch> but I haven't had any :(
13:02:47 <syntaxglitch> if anything is addling my brain right now, it's Arrows
13:03:27 <chrisdone> syntaxglitch: http://www.rathergood.com/demon
13:09:55 <roconnor> worse isn't better, but it is cheaper!
13:11:09 * Phyx- wants ghc panics to stop crashing his program
13:11:31 * syntaxglitch wonders if there's anything out there to construct a zipper over an expression instead of a data structure
13:12:56 <syntaxglitch> probably easy to do with delimited continuations
13:13:02 <dolio> What do you mean by that?
13:13:31 <drhodes> ls
13:14:18 * syntaxglitch basically wants a combined zipper and fold, or something like that
13:15:57 <dolio> Well, CC-delcont has ways of making cursors out of folds.
13:16:34 <syntaxglitch> yeah, I'm sure it'd be easy if I grokked delimited continuations well enough to use that
13:16:37 <dolio> Or out of arbitrary terms that accept a 'yield'.
13:16:57 <adnap> Isn't it unreasonable for this to give 13? Data.ByteString.Lazy.length (encode "hello")
13:17:12 <dolio> What does encode do?
13:17:18 <copumpkin> adnap: nope
13:17:23 <adnap> dolio: Converts it into a ByteString
13:17:24 <copumpkin> it's 8 bytes for length + 5 btes of daysta
13:17:34 <dolio> Converts it how?
13:17:48 <copumpkin> wow, data
13:17:52 <copumpkin> that'll teach me to eat
13:17:57 <adnap> dolio: I haven't read the source.  But it's a *byte* string.
13:17:58 <sbahra> What's wrong with pack?
13:18:00 <syntaxglitch> basically I want to collapse a bunch of monoids into a summary value that I can update incrementally without recomputing the entire expression
13:18:15 <copumpkin> adnap: you probably want pack, not encode
13:18:19 <copumpkin> encode is for serialization
13:18:31 <adnap> Ah
13:18:33 <copumpkin> which is why it has the 8-byte length marker at the front
13:18:44 <adnap> pack takes Word8's, right?
13:18:48 <syntaxglitch> it seemed obvious to generalize that to a zipper into a data structure where the monoid operation is a fold, but that seems like a lot of extra cruft
13:19:05 <copumpkin> adnap: there's a Char8 version of it too, for Char8 bytestrings
13:19:12 <NemesisD> BONUS: are you a purple octapus?
13:19:34 <syntaxglitch> I suppose I just need to slog through getting the hang of CC-delcont at some point :\
13:20:28 <adnap> copumpkin: I didn't know about that--cool.
13:20:48 <copumpkin> adnap: but if you're using human strings, you might want to consider Text instead of ByteString
13:20:58 <copumpkin> since it deals with all the unicode for you, but otherwise behaves mostly the same way
13:21:33 <adnap> copumpkin: I'm not always using human strings.
13:21:38 <copumpkin> oh ok
13:21:43 <adnap> copumpkin: The "hello" was just a test.
13:21:55 <copumpkin> then stick with bytestring (but I'd use the Word8 version, as Char8 is gross :P)
13:21:55 * ddarius uses strings of humans only to build pyramids.
13:21:56 <adnap> copumpkin: I'm serializing structures for C code.
13:22:26 <adnap> copumpkin: Gross?
13:23:16 <copumpkin> adnap: well, Char is supposedly covering the entire unicode range
13:23:23 <copumpkin> so would need 4 bytes per character
13:23:31 <copumpkin> so it kind of ignores anything above 255
13:23:44 <copumpkin> ddarius: how's that working for you?
13:23:57 <adnap> copumpkin: That's not good.
13:24:11 <dolio> binary might use UTF8 encoding.
13:24:17 <copumpkin> yeah, it does
13:24:25 <adnap> copumpkin: But it has pack :: [Char] -> ByteString.
13:24:53 <copumpkin> adnap: I'm pretty sure it'll just truncate the Char, but you can try and see
13:25:02 <copumpkin> I may be misremembering :)
13:25:49 <adnap> copumpkin: What is the best thing to do for serializing types for C code?  Basically, my C structure is just has char*.  It's similar to a canonical s-expression.
13:26:01 <copumpkin> probably ByteString + Binary
13:26:29 <copumpkin> just don't use the built-in instance for strings
13:26:34 <copumpkin> or actually
13:26:37 <adnap> copumpkin: That's what I've been doing, but I guess I messed up calling encode.
13:26:40 <copumpkin> I'm full of crap, use Foreign.C
13:26:46 * wli would just make the data structure you use to represent C types derive Show.
13:26:57 <wli> Assuming it's that sort of serialization.
13:27:34 <adnap> wli: That's not very efficient, is it?
13:27:49 <ksf> generally speaking, non-ground types would open a hell a lot of other questions I'd have to deal with.
13:28:05 <adnap> wli: Also, I would have to write "read" in C, right?
13:28:32 <ksf> e.g. is Num a sufficiently different from Integral a so that both can be in a TIP?
13:29:18 <ddarius> adnap: If you want to marshall data between Haskell and C use the FFI.
13:29:34 <ksf> @hoogle CString
13:29:35 <lambdabot> Foreign.C.String type CString = Ptr CChar
13:29:35 <lambdabot> Foreign.C.String type CStringLen = (Ptr CChar, Int)
13:29:35 <lambdabot> Foreign.C.String newCString :: String -> IO CString
13:29:36 <ddarius> Serialization is used when you need an out-of-memory format.
13:29:57 <adnap> ddarius: FFI is so confusing!
13:30:06 <ddarius> No it isn't.
13:30:07 <adnap> ddarius: I tried figuring it out and it was too confusing.
13:31:52 <Phyx-> do LINE pragmas start at line 0 or 1?
13:32:31 <ksf> 1, of course.
13:32:34 <ksf> or rather, nothing.
13:32:53 <ksf> pragmas don't start anywhere, but customary unix line counting starts at 1
13:33:12 <adnap> ddarius: I guess I'll give it another go.  I think it will help now that I understand IO better.
13:33:25 <ddarius> adnap: How did you try to learn FFI before?
13:34:03 <Phyx-> ksf: it's not ofcourse. most editors use internally 0 based line numbers.
13:34:13 <adnap> ddarius: Well, I read the documentation and tried to find a bunch of tutorials.  My Haskell knowledge consisted of reading some of Gentle Intro to Haskell.
13:34:29 <ddarius> adnap: What is "the documentation"?
13:34:31 <adnap> ddarius: However, I recently discovered and read Learn You a Haskell, which is the best thing ever.
13:34:41 <ksf> Phyx-, all error messages, all displays, :<linenum> in vi...
13:35:38 <adnap> ddarius: I read a lot of this: http://www.haskell.org/haskellwiki/Foreign_Function_Interface
13:35:53 <ddarius> adnap: Just read the FFI report.
13:35:55 <ddarius> @where ffi
13:35:55 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
13:36:17 <copumpkin> speaking of him, I haven't see him around in a while
13:36:24 <adnap> ddarius: I did read some of this.
13:36:26 <adnap> ddarius: It was confusing.
13:36:30 <copumpkin> he's online, but doesn't seem to check it
13:36:38 <adnap> ddarius: And really boring.
13:37:00 <adnap> ddarius: And there's not much example code.
13:37:38 * copumpkin is addicted to de bruijn encoding of things
13:37:48 <copumpkin> even non-LC-ish things
13:39:29 <lispy> dons: I'm able to benchmark darcs using attoparsec today :)
13:39:33 <syntaxglitch> copumpkin, I enjoy church encoding inappropriate things
13:39:40 <ddarius> copumpkin: Who are you talking about?
13:39:41 * lispy bounces
13:39:46 <adnap> ddarius: Anyhow, I'm going to try it again.  I know I'm sounding negative, but I just think the FFI report is really bland and hard to understand.
13:40:11 * Phyx- traps lispy in a bouncer
13:40:23 <copumpkin> ddarius: TacticalGrace (the link lambdabot linked to is in his webspace)
13:40:24 <lispy> adnap: read ezyang's blog.  He has like 6 part tutorial on the FFI
13:40:29 <copumpkin> syntaxglitch: ooh, like what?
13:41:00 <ddarius> syntaxglitch: You might enjoy defunctionalization and refunctionalization then.
13:41:03 <syntaxglitch> copumpkin, anything at all, that's the beauty of it
13:41:05 <ddarius> @google defunctionalization at work
13:41:07 <syntaxglitch> it's lambdas all the way down!
13:41:07 <lambdabot> http://www.brics.dk/RS/01/23/
13:41:07 <lambdabot> Title: Defunctionalization at Work
13:41:15 <copumpkin> :P
13:41:18 <EvanR> wheres the State monad?
13:41:29 <EvanR> @hoogle State
13:41:29 <lambdabot> module Control.Monad.State
13:41:29 <lambdabot> Test.HUnit.Base data State
13:41:30 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
13:41:33 <syntaxglitch> EvanR: in the couch cushions, a little to the left
13:41:46 <EvanR> guess i have to install something to get Control.Monad.State..
13:41:50 <EvanR> mtl?
13:41:53 <adnap> lispy: Thanks, I'll check it out.
13:42:31 <Phyx-> panic! the 'impossible' happened: SrcLoc.srcSpanStartLine
13:42:39 <Phyx-> well... that's not very helpful
13:42:56 <ddarius> Phyx-: It's not supposed to be helpful to you.
13:43:20 <Phyx-> ddarius: it's not?
13:43:23 <lispy> GHC: Making the impossible happen since 1997.
13:43:48 <ddarius> Phyx-: No.  You shouldn't be getting that message ever.  When you do it's a bug.
13:43:48 <Phyx-> ah, I know what it's on about though
13:44:08 <Phyx-> ddarius: not really. when you do, you're using the GHC api
13:44:13 <EvanR> got it
13:44:42 <syntaxglitch> I seem to recall getting that message a lot when messing with Template Haskell
13:45:01 <Phyx-> yeah, I'm testing a bad span
13:45:10 <Phyx-> i should check to see if it's bad before i inspect it
13:47:30 <syntaxglitch> copumpkin, anyway in all seriousness I have a habit of thinking of data structures in terms of their church encodings
13:47:55 <syntaxglitch> somehow it makes more sense to me that way
13:48:05 <Phyx-> You're one odd duckling :)
13:48:28 <lispy> still better than church mouse encodings
13:48:32 <lispy> Those are just weird
13:48:42 <syntaxglitch> (Maybe a), oh, that's just a shorthand for (forall b. b -> (a -> b) -> b)
13:48:51 <syntaxglitch> seems reasonable to me
13:49:02 <lispy> :t maybe
13:49:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:50:27 <syntaxglitch> yes, you can churchify a Maybe by partially applying the last argument to maybe
13:50:31 <syntaxglitch> likewise for Either and either
13:50:58 <ddarius> For non-recursive types, Church encodings are often convenient.  For recursive types they are often limiting.  Scott encodings are a bit better for that but they don't have some of the nice properties of Church encodings.
13:52:11 <Phyx-> wee perfect
13:52:12 <Phyx-> it works
13:52:14 <Phyx-> :)
13:52:26 * syntaxglitch can't recall what Scott encodings are :\
13:52:55 <Phyx-> well, almost
13:53:00 <ddarius> syntaxglitch: Single level Church encodings.  For non-recursive types, they are more or less the same as Church encodings.
13:53:00 <dolio> You encode each constructor as you'd encode the tuple of its fields.
13:53:01 <lispy> syntaxglitch: in Back to the Future they were known as Great Scott encodings
13:54:38 <syntaxglitch> wouldn't that make recursive types problematic?
13:54:55 <dolio> If you want to type the encoding.
13:55:14 <Phyx-> > Nothing >>= Just 1
13:55:15 <lambdabot>   Couldn't match expected type `a -> Data.Maybe.Maybe b'
13:55:16 <lambdabot>         against infe...
13:55:16 <ddarius> syntaxglitch: It means you need a fix in your language.  This is one of the nice properties that is lost.
13:55:38 <syntaxglitch> I figured the sensible thing was just to embed the recursion into the encoding
13:55:45 <dolio> On the other hand, some operations can be asymptotically faster.
13:55:52 <syntaxglitch> e.g. encode a list as foldr instead of uncons
13:55:59 <ddarius> syntaxglitch: Implement tail using foldr.
13:56:25 <Phyx-> is, there a better way to write
13:56:27 <Phyx-> findName fs (mkFastString name) (Just span) `mplus` findName fs (mkFastString name) Nothing
13:57:08 <syntaxglitch> ddarius, I'd rather do that than the other way around
13:57:15 <lispy> ?pl findName fs (mkFastString name) (Just span) `mplus` findName fs (mkFastString name) Nothing
13:57:15 <lambdabot> findName fs (mkFastString name) (Just span) `mplus` findName fs (mkFastString name) Nothing
13:57:28 <syntaxglitch> and foldr is a lot more useful
13:57:32 <lispy> I expected to get an ap or join from Reader ((->) r)
13:58:05 <lispy> because it has that form, x y `mplus` x z
13:58:09 <ddarius> syntaxglitch: My point is that it is complicated and (extremely) inefficient to implement tail using foldr whereas it's trivial and cheap using a Scott encoding.
13:58:15 <lispy> :t on
13:58:17 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:58:47 <lispy> :t \x y z -> x y `mplus` x z
13:58:48 <lambdabot> forall t (m :: * -> *) a. (MonadPlus m) => (t -> m a) -> t -> t -> m a
13:59:04 <mauke> liftM2 mplus ($ Just span) ($ Nothing) (findName fs (mkFastString name))
13:59:04 <syntaxglitch> ddarius, I don't disagree
13:59:34 <syntaxglitch> I'm just not particularly concerned with tail, I don't find it useful
13:59:40 <Phyx-> mauke: ty
13:59:46 <mauke> on mplus (findName fs (mkFastString name)) (Just span) Nothing
13:59:57 <Phyx-> that one's even nicer
13:59:58 <Phyx-> hehehe
14:00:15 <lispy> ah yeah, I knew on should work here but I'm sort of slow with it
14:00:15 <ddarius> syntaxglitch: Probably because it's partial.  I imagine you use pattern matching all the time.  You can't implement "uncons" efficiently either with foldr.
14:00:31 <lispy> mplus `on` ..., is how I would try to write it
14:01:49 <syntaxglitch> at least 95% of the time when I'm pattern matching on a list it's to write a function to fold with
14:03:06 <ddarius> syntaxglitch: So?  Any time you pattern match you are doing something that would be difficult to do with a Church encoding unless that instance directly corresponds to a fold, in which case why aren't you using a fold and not pattern matching?
14:03:37 <copumpkin> wow, Johann Bach just emailed haskell-cafe
14:05:27 <tolkad> Haskell documentation says that unbound threads are not bound to a particular OS thread, How can something be run in another thread but not run a particular thread? what does that mean?
14:05:56 <Phyx-> ghc sure is odd at times
14:06:17 <copumpkin> tolkad: your work can move between threads
14:06:40 <copumpkin> it's not usually noticeable, except if you make FFI calls
14:06:49 <syntaxglitch> ddarius, eh, don't have time to argue the point, sorry
14:06:51 <copumpkin> which forkOS guarantees will always be made from the same OS thread
14:07:50 <tolkad> copumpkin: so, computation in forkOS runs in a new, one-use thread but computation in unbound threads can be run anywhere in a thread pool and move between the threads in that thread pool at any time?
14:08:00 <dolio> There are other examples if it's not lists, too.
14:08:19 <dolio> Factorial (although that might be less of a dominant factor).
14:08:24 <dolio> Subtraction
14:08:37 <copumpkin> tolkad: even forkOS computation can run on multiple threads, but its FFI calls will always be made from the same thread (as far as I understand)
14:08:52 <dark> i thought that forkOS were a new operating system, maybe made up by FP guys
14:09:20 <lispy> dark: hehe.  No thats house
14:09:28 <Nibble> Hi, I am having problem understanding functors
14:09:28 <ksf> gragh. what's worse, I don't seem to be able to use TypeEq to figure out whether a type isn't ground.
14:09:35 <Nibble> I have this code
14:09:36 <Nibble> data Tree a = Node a [Tree a]
14:09:40 <ksf> ...as TypeEq x x HTrue always holds.
14:09:46 <Nibble> but then I try to define fmap
14:09:47 <Nibble>         fmap f (Node x) = Node (f x)
14:09:48 <tolkad> the thread that the FFI calls are made in, can it come from threads already in the thread pool and can it be reused?
14:09:55 <ddarius> ksf: If you could something would be horribly wrong.
14:09:58 <Nibble> error:    Couldn't match expected type `Tree b'
14:10:04 <syntaxglitch> ksf, yes, that's not going to work
14:10:12 <lispy> Nibble: yeah.  what is the type of f x?
14:10:28 <syntaxglitch> ksf, didn't I already tell you that TypeEq will never work well on unground types? :P
14:10:30 <Nibble> lispy: no idea
14:10:36 <ksf> I don't want it to.
14:10:38 <lispy> Nibble: it's try it
14:10:40 <ddarius> lispy: That's not the issue.
14:11:05 <ksf> ...I'd like to restrict HList to have ground members only to make the errors more comprehensible.
14:11:21 <ksf> ...but TypeEq is also returning true for non-ground ones.
14:11:22 <tolkad> I'm wondering because it seems that some libraries keep track of state based on thread. Is it possible a thread created using forkOS could already have a bunch of state associated with it?
14:11:37 <lispy> ddarius: Really?  I would have thought (f x) is not a list but one is expected.
14:11:51 <ddarius> lispy: Node should be taking two arguments.
14:12:22 <lispy> ddarius: yes, that too
14:12:24 <Nibble> so what should I change?
14:12:42 <mauke> Nibble: data Tree a = Node a
14:12:55 * ddarius doubt that that's what he wants...
14:12:58 <Nibble> mauke: Yes, that is the definition
14:13:07 <mauke> Nibble: since when?
14:13:20 <Nibble> mauke: a part of it anyhow
14:13:20 <syntaxglitch> ksf, really? That seems surprising.
14:13:41 <ddarius> syntaxglitch: ?  Why does that seem surprising?
14:13:42 <Makoryu> Nibble: No, your definition was "Node a [Tree a]"
14:13:51 <Nibble> Makoryu: I know. I wrote a part of it anyhow
14:14:00 <Nibble> but that would change the expected behaviour
14:14:23 <Makoryu> Nibble: If a constructor takes two arguments, you can only pattern match against it with both arguments
14:14:37 <copumpkin> does Iavor Diatchki hang out on IRC?
14:14:42 <ksf> syntaxglitch, well, I'm calling it literally as "TypeEq x x HTrue"
14:14:54 <lispy> copumpkin: I'm not sure what his nick would be.  I don't think he does...
14:15:04 <copumpkin> ah
14:15:04 <syntaxglitch> ksf, ah, I can see that
14:15:29 <lispy> copumpkin: what did you need?
14:15:35 <EvanR> anti haskell propaganda, you have to design an entire system and fully understand what it will look like before even attempting to implement it
14:15:50 <EvanR> which is hard
14:16:02 <lispy> EvanR: hmm?
14:16:06 <copumpkin> lispy: oh, I just wanted to thank him for the presburger solver on hackage, and ask if he'd mind me reuploading a version that gets rid of warnings on recent GHCs (about base 3)
14:16:20 <ddarius> EvanR: I'm sure that's just how they built GHC.  I assume they just rewrite it entirely for every minor version.
14:16:26 <syntaxglitch> I would be surprised if TypeEq was unifying the result with HTrue unless both type arguments were fully determined
14:16:27 <lispy> copumpkin: ah, you probably best off emailing him
14:16:51 <EvanR> GHC is a compiler though, i meant to specify the IO-centric aspects of the system
14:16:59 <ksf> @quote meditation*fold
14:16:59 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
14:17:01 <EvanR> GHC hopefully is most non IO
14:17:01 <ksf> @quote meditation.*fold
14:17:02 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
14:17:04 <copumpkin> lispy: okay :)
14:17:12 <Nibble> but back to my problem. 
14:17:16 <ksf> ...so much about upfront design.
14:17:25 <EvanR> lol
14:17:36 <ddarius> EvanR: You can write C in Haskell, so unless this is also true of C, this is not the case.
14:17:41 <Nibble> data Tree a = Node a [Tree a] deriving (Show)  I think this means that it is a recursive algebraic data type?
14:17:50 <Nibble> i.e it calls itself to create more Nodes
14:17:55 <EvanR> ddarius: yeah im seeing lack of design resulting in a C program
14:18:03 <EvanR> so i stop and redesign
14:18:23 <danportin> Nibble: look at your data declaration. You have: 'data Tree a = Node a [Tree a].' In your pattern match for fmap, what is missing?
14:18:29 <Makoryu> Nibble: This definition means you will have one data constructor (Node) that takes two arguments
14:19:02 <Makoryu> Nibble: The first argument's type is "a" and the second argument's type is "[Tree a]" -- which you should read as "list of 'Tree a'"
14:19:46 <Nibble> Makoryu: so, fmap f (Node x [a]) or something?
14:19:59 <Nibble> I can't get this with functors what they are usefull for
14:20:17 <Makoryu> Nibble: Yes, you're getting there
14:21:05 <Nibble> Makoryu:            against inferred type `[Tree b] -> Tree b'
14:21:10 <Nibble>         fmap f (Node x [a]) = Node (f x)
14:21:27 <Makoryu> Nibble: You have to change the right side, too.
14:21:29 <mauke> Nibble: Node takes two (2) arguments
14:21:44 <EvanR> ksf: whats upfront design
14:21:44 <Nibble> oh, but that is not where the error is
14:21:59 <Phyx-> weeeeeee
14:22:01 * Phyx- hugs lispy 
14:22:02 <Phyx-> it works
14:22:15 <Nibble> Makoryu: error is at the whitespace between x and [
14:22:20 <lispy> Phyx-: Your Visual Haskell??
14:22:24 <lispy> YVH
14:22:59 <lispy> Nibble: so...we established that Node takes two parameters.  See anything wrong?
14:23:21 <Makoryu> Nibble: At this point I am going to stop speculating and ask you to paste the whole file on hpaste or somewhere
14:23:26 <Makoryu> Or pastebin
14:23:27 <Phyx-> lispy: well, almost
14:23:30 <Makoryu> Nibble: http://pastebin.com/
14:23:33 <Phyx-> lispy: panics are a problem
14:23:39 <Phyx-> they go right through my try-catch
14:23:49 <Nibble> http://pastebin.com/WivnPsZj
14:23:54 <lispy> Phyx-: which catch?
14:23:59 <Nibble> I pasted the two lines of importance I think
14:24:24 <Phyx-> lispy: in C#
14:24:36 <Phyx-> lispy: maybe I should handle them in haskell land
14:24:44 <lispy> Phyx-: hmm...
14:24:52 <lispy> Phyx-: do you use hdirect?
14:24:57 <Nibble> *that is the whole file*
14:25:11 <Phyx-> but i *should* be able to catch them, FFI raises an exception, the framework wraps it, and then. *poof* can't catch it
14:25:15 <Phyx-> lispy: nope
14:25:28 <lispy> Phyx-: What do you use for COM?
14:25:35 <copumpkin> I wish haskell allowed overlapping constructor names
14:25:38 <Makoryu> Nibble: When I try to compile this, it reports the error as being on the right side of the definition
14:26:06 <Nibble> Makoryu: that is strange
14:26:13 <Makoryu> Nibble: Change it to this: fmap f (Node x [a]) = Node (f x) [a]
14:26:27 <Nibble> Makoryu: does it remove whitespace during parsing?
14:26:30 <Phyx-> lispy: I don't use COM, i use P/Invoke
14:27:16 <lispy> Phyx-: oh that's clever.  The original VH.net used hdirect for COM.  I swear hdirect is buggy but it worked for them
14:27:24 <Nibble> Makoryu: didn't work
14:27:40 <Makoryu> Nibble: Okay. What is the error this time?
14:27:46 <Nibble>     Couldn't match expected type `b' against inferred type `a'
14:27:54 <hpc> what's the definition of Node?
14:28:05 <lispy> Nibble: if only you had a function, say f, that could transform from a to b
14:28:07 <hpc> (huge scrollback)
14:28:26 <Nibble> hpc: it is a value constructor I think
14:28:27 <Makoryu> Nibble: Oh right my bad
14:28:34 <Phyx-> lispy: yeah, i compile to normal static libs, and call those. I just have to provide Storable instances for everything
14:28:49 <Phyx-> lispy: works pretty good, except for the speed problem which i still have to solve, and these damn exceptions
14:29:08 <Makoryu> Nibble: fmap f (Node x ys) = Node (f x) (map f ys)
14:29:24 <lispy> Phyx-: Out of process COM is terribly slow, but I suspect that P/Invoke is using out of process COM under the hood
14:29:34 <Nibble> Makoryu:     Occurs check: cannot construct the infinite type: b = Tree b
14:29:38 <Makoryu> Nibble: I have to wonder if you understand the list syntax though
14:29:46 <Nibble> Makoryu: I sure have
14:29:47 <lispy> Phyx-: I think out of process COM is your only choice
14:29:52 <danportin> Shouldn't you map 'fmap f' over xs?
14:30:29 <Nibble> danportin: no idea
14:30:32 <lispy> danportin: yes
14:30:43 <Makoryu> danportin: Maybe I should test this stuff :p
14:30:57 <hpc> fmap f (Node x ys) = Node (f x) (map (fmap f) ys)
14:30:58 <Makoryu> Nibble: Change "map f ys" to "map (fmap f) ys"
14:31:02 <lispy> danportin: which is what I thought the problem was originally when Nibble came here for help :)
14:31:22 <Phyx-> lispy: well, I don't think so,  but I could be wrong. I beleive my slowdown is because newCSWtring and showSDoc doesn't trigger any fusion rules. SO i goes from SDoc -> String -> CWString for marshalling
14:31:26 <Phyx-> multiply that by 100x
14:31:29 <danportin> Well, my cycle goes: alt-tab GHC, :r, enter, test, alt-tab text editor, repeat. So :p
14:31:52 <Nibble> it worked
14:32:24 <Makoryu> Nibble: Lemme show you something about lists though.
14:32:26 <hpc> danportin: wow, didn't know :r existed; awesome
14:32:31 <Nibble> Makoryu: sure thing
14:32:38 <Makoryu> Nibble: Before, you wanted to write "Node x [a]"
14:32:53 <Makoryu> Nibble: Did you realize that this would only match a list with one element?
14:32:54 <Phyx-> lispy: does catchIO in haskell catch panics?
14:33:11 <Nibble> Makoryu: yes.
14:33:18 <Nibble> @src :
14:33:18 <lambdabot> Source not found. Wrong!  You cheating scum!
14:33:19 <hpc> Phyx-: kernel panic?
14:33:22 <Nibble> @src []
14:33:22 <lambdabot> data [] a = [] | a : [a]
14:33:24 <Nibble> ah
14:33:35 <Phyx-> hpc: ghc panic
14:33:37 <Makoryu> @src (:) -- Enclose it in parentheses
14:33:38 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:33:41 <Makoryu> Oops
14:33:44 <Makoryu> @src (:)
14:33:44 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:33:50 <Nibble> oops :P
14:33:50 <Makoryu> Wow, that should work
14:33:50 <mauke> Makoryu: dude, wtf
14:33:56 <mauke> Makoryu: no, it shouldn't
14:34:01 <lispy> Phyx-: oh, is a GHC panic when the impossible happens?
14:34:01 <Makoryu> Shouldn't it?
14:34:04 <Makoryu> @src (+)
14:34:04 <lambdabot> Source not found. You type like i drive.
14:34:08 <Phyx-> lispy: yeah
14:34:09 <Nibble> no
14:34:23 <Nibble> @src `elem?
14:34:23 <Phyx-> lispy: that seems to be completely  uncatchable in C#
14:34:23 <lambdabot> Source not found. Wrong!  You cheating scum!
14:34:25 <Nibble> @src `elem`
14:34:26 <lambdabot> Source not found. Just try something else.
14:34:29 <lispy> Phyx-: that's like a C assert.  You can't catch it.  the RTS is terminating
14:34:29 <Phyx-> it just brings down the IDE when one happens
14:34:41 <Phyx-> lispy: oh, then i have a problem...
14:34:43 <mauke> @src elem
14:34:43 <lambdabot> elem x    =  any (== x)
14:34:52 <Nibble> After we solved this
14:34:56 <Nibble> now when we have*
14:34:59 <Nibble> what is the use of it?
14:35:37 <Veinor> Nibble: what do you mean?
14:35:46 <Nibble> Veinor: why would I want to do this?
14:35:52 <Veinor> to use elem?
14:35:58 <Nibble> Veinor: not elem
14:36:00 <Nibble> my Functor
14:36:02 <Phyx-> lispy: ghc is a bit too generous with those panics
14:36:12 <Veinor> what's your functor?
14:36:13 <lispy> Nibble: um, it applies a function at each node.  It has all sorts of opportunities
14:36:27 <lispy> Phyx-: you have some bug reports to write :)
14:36:28 <Nibble> lispy: give me example usage, because I keep getting errors
14:36:46 <lispy> fmap (+1) (Node 1 [Node 2 []])
14:37:12 <Nibble> oh
14:37:27 <Nibble> I forgot the last stuff
14:37:49 <Nibble> I see
14:37:58 <lispy> let n = Node 1 [n]
14:38:10 <Nibble> So functor makes it easier to apply already made functions to a new data-type?
14:38:21 <Phyx-> lispy: it's basically crashing on a Name value that it created. Or if can't find an import it also panics sometimes
14:38:23 <Makoryu> Nibble: Yep
14:38:24 <Phyx-> odd
14:38:28 <lispy> Nibble: yeah, you can apply it to whatever type is inside the functor
14:39:15 <tolkad> is there something like a switch statement for bytestrings? it might be optimized to something more efficient than calling == over and over
14:39:38 <Nibble> @src Functor
14:39:38 <lambdabot> class  Functor f  where
14:39:39 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:40:09 <Nibble> this is usefull because that type is commonly used among many high-order function, right?
14:40:17 <lispy> Nibble: you want to read that as fmap :: (a -> b) -> (f a -> f b)
14:40:30 <Nibble> lispy: I know about currying
14:40:40 <Makoryu> tolkad: Sorry?
14:40:50 <lispy> Nibble: in other words, it takes a function from (a -> b), and gives you a function from (f a -> f b).  it lifts your function inside the functor
14:41:04 <Nibble> I see
14:42:48 <tolkad> for example, let's say I want to do one thing if a string is equal to "aaaaaaaaaab"  and I want to do something else instead if it is equal to "aaaaaaaaaac". there is obviously a faster algorithm than calling == multiple times, and I was wondering how I can write my code so this situation will most likely be optimized with bytestrings
14:43:23 <lispy> tolkad: in your case you could do something clever with isPrefixOf or isSuffixOf
14:46:22 * Phyx- kicks his internet
14:47:56 <Phyx-> lispy: this is what the end of the world looks like in C# http://i35.tinypic.com/2eklsus.png
14:48:39 <Phyx-> lispy: http://i33.tinypic.com/35d7ucm.png when the world is peaceful
14:50:41 <danportin> Does anyone know why GHCi would give "Exception: ... (character is not in code page)" errors when printing Unicode characters, e.g.,: putStrLn "\x0394"? (To every test case except Pi, "\x03C0")
14:51:07 <lispy> Phyx-: the peaceful version is nice :)
14:51:43 <osaunders> I'm going to try writing factorial using only (==), (*), pred, s, k, b, c and y.
14:51:54 <davekong> What is a good tutorial for learning all about type classes?
14:51:54 <mauke> danportin: what is ghci running in?
14:52:24 <danportin> Windows command prompt or WinGHCi
14:52:31 <Phyx-> lispy: lol
14:52:34 <monochrom> hSetEncoding stdout utf8
14:52:51 <ksf> davekong, the HList paper and enough fooling around with such stuff
14:53:02 <lispy> davekong: typeclassopedia
14:53:27 <osaunders> davekong: The Typeclassopedia in http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
14:53:27 <monochrom> because windows is too proud of its "cp1357" to default to utf8
14:54:35 <danportin> Oh my god. It worked!
14:54:53 <monochrom> on ubuntu you wouldn't need it
14:54:55 <danportin> Four days of Google, and no solution. Thanks :)
14:56:55 <ksf> > '\x0394'
14:56:57 <lambdabot>   '\916'
14:57:04 <ksf> weeeelllll.
14:57:11 <monochrom> > text "\x0394"
14:57:12 <lambdabot>   Δ
14:57:24 <mornfall> monochrom: Would seting stdout/stderr(/stdin) to binary help?
14:57:26 <ksf> > text '\x03c0'
14:57:28 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:57:28 <lambdabot>         against inferred ty...
14:57:31 <lispy> monochrom: yeah, I think that fixes a weird failure that darcs was seeing on windows only.  Thanks!
14:57:34 <ksf> > text "\x03c0"
14:57:36 <lambdabot>   π
14:58:17 <monochrom> hSetBinaryMode says: "This has the same effect as calling hSetEncoding with latin1, together with hSetNewlineMode with noNewlineTranslation"
14:58:32 <tolkad> > "x" ++ (text "\x0a0a")
14:58:33 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:58:34 <lambdabot>         against inferred ty...
14:58:42 <monochrom> sounds like the worst possible thing a human could do to a text file.
14:58:44 <tolkad> > text "\x0a0a"
14:58:45 <lambdabot>   ਊ
14:58:53 <ksf> :t text
14:58:54 <tolkad> it's a man with a beard and hat
14:58:55 <lambdabot> String -> Doc
14:59:08 <ksf> > "\x0394"
14:59:09 <lambdabot>   "\916"
14:59:20 <danportin> That's wierd. Now 'delta' and 'pi' work, but none of the other characters. This is frustrating.
14:59:23 <mornfall> monochrom: :) ok, so utf8 it is... I am assuming that date formatting functions produce unicode (wide) Chars? When they use funny names like březen due to locale, that is...
14:59:27 <ksf> @vixen are you confused about unicode?
14:59:29 <lambdabot> i truely am
14:59:37 <ksf> @vixen you shouldn't be afraid of using it.
14:59:38 <lambdabot> help help!
15:00:01 <ksf> @vixen just don't escape things, but print the octets directly. IRC will understand.
15:00:02 <lambdabot> you sound like an awesome guy... are you single?
15:00:03 <tolkad> > ['\0a', text "\x0a0a"]
15:00:04 <lambdabot>   <no location info>:
15:00:04 <lambdabot>      lexical error in string/character literal at chara...
15:00:11 <danportin> Prelude System.IO> putStrLn "\x0394"   evaluates to      Î”
15:00:14 <tolkad> > ["\0a", text "\x0a0a"]
15:00:16 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:00:16 <lambdabot>         against inferred ty...
15:00:20 <danportin> So now it's stopped working :/
15:00:29 <danportin> Oh well
15:00:32 <tolkad> > [10 :: Char, text "\x0a0a"]
15:00:33 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:00:34 <lambdabot>         against inferred type...
15:00:50 * mauke stares at tolkad 
15:01:03 <tolkad> > ['\n', text "\x0a0a"]
15:01:05 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:01:05 <lambdabot>         against inferred type...
15:02:36 <tolkad> > '\n' : (render $ text "\x0a0a")
15:02:38 <lambdabot>   "\n\2570"
15:03:14 <monochrom> Char is "wide". if date formatting produces [Char], it can do whatever it wants. how putStrLn translates [Char] to I/O is orthogonal.
15:10:18 <Phyx-> I wonder why GHC sometimes prins out [Char] and other times String as the inferred type
15:10:38 <ddarius> It uses the given type annotations to guide the naming.
15:10:42 <copumpkin> it can't reverse map [Char] to String
15:10:50 <copumpkin> unless you tell it to
15:11:16 <Phyx-> :t map id "hello"
15:11:17 <lambdabot> [Char]
15:11:22 <Phyx-> :t id "hello"
15:11:24 <lambdabot> [Char]
15:11:30 <Phyx-> :t "hello"
15:11:31 <lambdabot> [Char]
15:11:35 <Phyx-> erm
15:11:38 <mauke> :t ""
15:11:38 <ddarius> :t "hello" :: String
15:11:40 <Phyx-> :t map id "hello" :: String
15:11:41 <lambdabot> [Char]
15:11:41 <lambdabot> String
15:11:42 <lambdabot> String
15:11:58 <Phyx-> ah, okay, I getit
15:12:12 <Phyx-> so in the cases it prints out String, something in the function must have had a type String
15:14:18 <CalmNelly> @vixen Hi.
15:14:19 <lambdabot> You think this is a botiecall??
15:14:45 <CalmNelly> @vixen I'm not sure what a botiecall is, but are you up for a bootie call?
15:14:45 <lambdabot> not much, what's up with you?
15:14:52 <Phyx-> vixen gives botiecalls? o.O
15:15:30 <Philonous> How does the instance selection for show work? How can haskell 98 have Show String as well as Show a => Show [a]?
15:16:14 <mauke> it doesn't have Show String
15:16:23 <Philonous> > show "abc"
15:16:26 <lambdabot>   "\"abc\""
15:16:41 <Phyx-> > showList "abc"
15:16:43 <lambdabot>   Overlapping instances for GHC.Show.Show
15:16:43 <lambdabot>                              (GHC.B...
15:16:50 <Phyx-> > showList "abc" :: String
15:16:52 <lambdabot>   Couldn't match expected type `GHC.Base.String'
15:16:52 <lambdabot>         against inferred typ...
15:16:57 <Phyx-> > showList "abc" :: [Char]
15:16:58 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:16:59 <lambdabot>         against inferred ty...
15:17:07 <Phyx-> hrm
15:17:18 <mauke> that last one was pointless
15:17:21 <mauke> String = [Char]
15:17:24 <Philonous> mauke: How then can it determine to use "abc" syntax instead of ['a','b','c'] ?
15:17:48 <Phyx-> mauke: I have a cold, the brain is the first to go :)
15:17:48 <mauke> Philonous: look at the Show a => Show [a] instance
15:18:00 <mauke> Philonous: how is show defined there?
15:18:52 <Phyx-> :t showLIst
15:18:53 <lambdabot> Not in scope: `showLIst'
15:18:54 <Phyx-> :t showList
15:18:55 <lambdabot> forall a. (Show a) => [a] -> String -> String
15:18:58 <Phyx-> ah
15:19:05 <Phyx-> > showList "abc" ""
15:19:05 <tolkad> deriving Eq?!?!? http://hackage.haskell.org/packages/archive/HTTP/4000.0.9/doc/html/src/Network-HTTP-Base.html#RequestMethod
15:19:06 <lambdabot>   "\"abc\""
15:19:16 <tolkad> *facepalm*
15:19:26 <Cale> Philonous: Basically, there's a special method in the Show class called showList, which determines how to show a list of values of that type, and the list instance of Show uses that.
15:19:51 <copumpkin> it's kinda ugly :P
15:19:55 <tolkad> so GET <> Custom "GET"
15:19:58 <copumpkin> but sneaky, too
15:20:00 <tolkad> that's bad
15:20:58 <Cale> tolkad: In fact, it's a bit funny that you'd not just delete all the other constructors and just use strings, if you
15:21:06 <Cale> If you're going to allow arbitrary strings.
15:22:22 <copumpkin> tolkad: you come from VB?
15:22:45 <tolkad> copumpkin: VB? you mean Visual Basic? no, I started with PHP mostly
15:22:50 <copumpkin> ah
15:23:44 <Cale> I was thinking Pascal
15:24:03 <Philonous> Cale: Thanks. I should just have looked at the code before asking stupid questions. It revealed exactly that.
15:27:15 <burp> "type (MonadMC m) => GameState m = StateT (TurnNumber,Points,Points) m" is there an extension so I can do such a thing?
15:27:23 <burp> a constraint for the type argument
15:27:36 <burp> or isn't it sensible anyway?
15:27:52 <ddarius> burp: There's not much point to that type.
15:28:24 <Gracenotes> the way to phrase it would be 'type GameState m = MonadMC m => StateT ...'
15:28:38 <Gracenotes> but that's not exactly valid
15:28:55 <ddarius> The only thing I can think that you would think that would do is allow you to avoid writing MonadMC m in the type signature explicitly.
15:29:12 <burp> move :: (MonadMC m) => Points -> Points -> Int -> StateT (TurnNumber,Points,Points) m Bool
15:29:16 <burp> something like this I guess
15:29:34 <burp> that does work
15:29:43 <burp> so it's not possible to put it into the type? 
15:29:50 <ddarius> GHC does actually allow things like Int -> (Monad m) => m (), but I don't think it allows you to hide that in a type synonym.
15:30:02 <Gracenotes> oh, wait, you can do 'newtype GameState m => MonadMC m = GameState ...'
15:30:20 <ddarius> Don't do that.
15:30:33 <Gracenotes> but I don't think that excuses you from putting it in all of you type signatures
15:30:37 <Gracenotes> if that's what you want
15:30:48 <Gracenotes> *your
15:31:00 <copumpkin> a GADT would
15:31:02 <copumpkin> but don't do that either
15:31:12 <copumpkin> (if you attached the constraint to the constructors)
15:31:16 <Gracenotes> oh MAN, haskell is so restrictive
15:31:31 <Gracenotes> I'm going back to PHP
15:31:39 <burp> I just keep the whole thing in the function type signature for now :>
15:32:21 <copumpkin> as long as you move the constraint out
15:32:24 <copumpkin> you can keep the rest in it
15:33:01 <burp> hm, yes doing it like this now
15:34:02 <Berengal> How do people usually structure their tests in Haskell?
15:34:06 <osaunders> What use is y?
15:34:09 <Berengal> On a package level, I mean
15:34:23 <copumpkin> osaunders: the combinator? gives you recursion
15:34:45 <copumpkin> there are a few different shapes of it though
15:35:05 <osaunders> copumpkin: How do you use that recursion though
15:35:11 <osaunders> > y id -- just crashes
15:35:12 <lambdabot>   Couldn't match expected type `(a -> a) -> t'
15:35:12 <lambdabot>         against inferred type ...
15:35:14 <copumpkin> like you use fix
15:35:22 <copumpkin> oh, you are using fix
15:35:24 <aristid> :t y
15:35:25 <lambdabot> Expr
15:35:26 <copumpkin> oh, you aren't
15:35:29 <Gracenotes> as for using it in real code, I use it to make fields for data structures which depend on each other
15:35:39 <copumpkin> osaunders: what's the type signature of your y?
15:35:41 <Gracenotes> which could be drawn out into a let clause, but, why bother
15:35:42 <osaunders> @let y f = f (y f)
15:35:43 <lambdabot>  <local>:2:9:
15:35:43 <lambdabot>      Ambiguous occurrence `y'
15:35:43 <lambdabot>      It could refer to either `L....
15:35:53 <osaunders> @let yComb f = f (yComb f)
15:35:55 <lambdabot>  Defined.
15:35:56 <aristid> y = fix?
15:35:56 <osaunders> :t yComb
15:35:57 <lambdabot> forall t. (t -> t) -> t
15:36:01 <ddarius> aristid: Yes.
15:36:02 <copumpkin> yeah, but inefficient
15:36:03 <osaunders> :t fix
15:36:04 <lambdabot> forall a. (a -> a) -> a
15:36:12 <copumpkin> osaunders: it's a fairly mechanical translation
15:36:48 <copumpkin> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
15:36:49 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:37:03 <copumpkin> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))
15:37:04 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:37:15 <copumpkin> osaunders: see?
15:37:18 <Gracenotes> > yComb (\f x -> if x == 0 then 1 else x*f (x-1)) 10
15:37:20 <lambdabot>   3628800
15:37:46 <copumpkin> > fix ((0:) . scanl (+) 1)
15:37:48 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:38:09 <osaunders> OMG!
15:38:15 <osaunders> That is totally awesome!
15:38:17 <Gracenotes> all of the above examples fix a function rather than a normal-form-able value.
15:38:19 <Berengal> (\f -> (\x -> f (x x)) (\x -> f (x x)))
15:39:06 <osaunders> Fuck I'm going to do all my recursion with fix now XD
15:39:10 <curious3> list
15:39:20 <copumpkin> osaunders: lol
15:39:29 <copumpkin> osaunders: you can do it at the type level too :)
15:39:39 <Berengal> Grokking fix is quite a fix
15:39:49 <ddarius> Using fix rather than let restricts polymorphism.
15:39:50 <copumpkin> :k Mu ((:+:) 1) 
15:39:51 <lambdabot> *
15:39:55 <osaunders> copumpkin: Say no more
15:39:59 <Berengal> :k Mu []
15:40:00 <lambdabot> *
15:40:06 <Gracenotes> > fix (\tree n -> Node n [tree (n*2), tree (n*2+1)]) 1
15:40:07 <lambdabot>   Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = [Node {r...
15:40:09 <osaunders> copumpkin: Because it would just confuse the crap outta me.
15:40:12 <copumpkin> :k Mu Maybe
15:40:13 <lambdabot> *
15:40:17 <Gracenotes> meow
15:40:27 <copumpkin> osaunders: it's the peano naturals!
15:41:13 <copumpkin> and Berengal's is arbitrarily branching trees that carry no information :P
15:41:16 <Berengal> Mu [] is a tree with no data
15:41:37 <ddarius> copumpkin: They have information, they don't have data.
15:41:43 <copumpkin> yeah :)
15:41:46 <Berengal> Also, Mu [] could potentially have itself both as the element and as the tail
15:42:05 <copumpkin> Mu ((->) a)
15:42:13 * hackagebot graphmod 1.2.3 - Present the module dependencies of a program as a "dot" graph.  http://hackage.haskell.org/package/graphmod-1.2.3 (IavorDiatchki)
15:42:13 <Gracenotes> ddarius: hm, that's true. none of the records are polymorphic though
15:42:25 <Gracenotes> more of a matter of convenience
15:42:41 <copumpkin> you can still use higher-rank polymorphism if necessary
15:42:50 <copumpkin> well, I guess not
15:43:14 <copumpkin> is there a way to give yourself polymorphic recursion?
15:43:25 <osaunders> I guess fix wouldn't work in strict functional languages right?
15:43:35 <ddarius> osaunders: I slight variant would.
15:43:43 <mauke> works fine in perl
15:43:46 <Berengal> I've seen fix in ruby and the like
15:44:08 <copumpkin> Berengal: did you ever resolve the issue with your continuation web stuff?
15:44:30 <Berengal> copumpkin: Nope.
15:44:57 <osaunders> ddarius: Intriguing.
15:44:58 <Berengal> I've seen people mention that several times. It was really just some late saturday night hacking done several months ago...
15:46:55 <Berengal> Besides, I don't think continuations are a good foundation for web development. They're a nice tool when you really need it, but they can easily be hacked into almost any framework with sessions
15:47:50 <Berengal> These days I'm leaning more towards a RESTful JSON API and mountains of JS
15:48:23 <copumpkin> :O
15:48:27 <copumpkin> traitor!
15:48:38 <Berengal> Server-side html is ugly and hacky in any language. It's much easier to manipulate webpages from JS
15:48:39 <osaunders> So I guess you can make y from s and k.... but how? *thinks*
15:49:05 <mauke> I'd write it in lambda first
15:49:11 <ddarius> fix id = SII(SII) where I = SKK
15:49:22 <bss03> Berengal: I'm completely on the other side of that.
15:49:34 <Berengal> copumpkin: Considering how functional JS really is, and that my day-job is exclusively Java, I don't see myself as such
15:49:44 <copumpkin> Berengal: just kidding :P
15:49:58 <bss03> Berengal: I prefer my web pages to have minimal JS in the inital pull, and then scale up as I test for more JS features.
15:50:02 <Berengal> (Exclusively Java unless I can "justify" using mountains of JS, of course. Yay loophole!)
15:50:59 <ksf> do contexts on class instances in any way influence the associated types?
15:51:27 <ksf> I'm asking because vanilla type fams don't take contexts and they're often said to be 100% equivalent
15:51:52 <robryk1> what is y?
15:51:58 <Berengal> bss03: I don't see that as being the opposite of what I'm thinking. I just don't like server-side UI. It confuses the issue.
15:51:59 <ksf> but then, it'd be bleeding counter-intuitive.
15:52:05 <copumpkin> osaunders: interesting ones to play with are BC(I/K)
15:52:46 <mauke> robryk1: fix
15:52:53 <robryk1> thanks
15:52:57 <Berengal> bss03: Also, any webpages I write are for the company intraweb, so I don't have to deal with multiple browsers. My "clients" are forced to use whatever I tell them to.
15:54:09 <Berengal> ksf: I still haven't seen the type fam answer to 'class Foo a b c | a b -> c, b c -> a, a c -> b'
15:54:25 <copumpkin> Berengal: there isn't one, yet
15:55:01 <ksf> class (F a b ~ c, G b c ~ d, H a ~ b) 
15:55:09 <copumpkin> once we get superclass equality constraints I think they should be equivalent
15:55:12 <ksf> er H a c ~ b
15:55:14 <copumpkin> ksf: yeah, but you can't write that
15:55:33 <CalmNelly> @vixen What's hotter, Leonardo DiCaprio being washed up on beach with all his clothes on, or Joseph Gordon-Levitt plunging off a bridge in a van while he's sleeping in slow motion?
15:55:34 <lambdabot> whoa whoa whoa, one question at a time!
15:55:34 <osaunders> copumpkin: What is (/) in that expression?
15:55:42 <copumpkin> osaunders: oh, just chose between I and K there
15:55:53 <copumpkin> osaunders: they correspond to two substructural type systems/logics
15:56:00 <copumpkin> I guess you could do the third while you're at it
15:56:10 <osaunders> : /
15:56:41 <copumpkin> osaunders: it sounds fancy, but it just means that they force you to use variables no more than once, exactly once, or at least once
15:56:53 <ksf> well, but you're _supposed_ to be able to write it.
15:56:57 <copumpkin> clean and ATS both use them
15:57:33 <bss03> CalmNelly: J G-L kissing "Juno"
16:00:02 <aristid> @vixen 1
16:00:03 <lambdabot> ouch! I just spilt hot coffee on myself!
16:00:12 <aristid> @vixen 10
16:00:12 <lambdabot> Crazy little wanker!
16:00:24 <aristid> lol so vixen doesn't accept 1 as an age
16:00:30 <aristid> @vixen 8
16:00:30 <lambdabot> enough of this!
16:00:49 <ksf> ...contexts are just plainly ignored for associated types.
16:01:00 <ksf> speak about confusing syntax.
16:02:10 <ksf> Is there anything new, interesting in HEAD that I should be playing with instead of complaining about lacking features?
16:03:31 <aristid> ksf: can you see if ghci supports qualified imports now?
16:04:28 <Gracenotes> JGL wins any hotness contest :/
16:05:30 <Berengal> So, about testing... Do people write test modules and put a test flag in the .cabal file, or do they write separate packages for testing, or do they keep their tests outside of cabal entirely, or what?
16:06:21 <ddarius> They do all of those things.
16:06:38 <Berengal> Which is best?
16:06:56 <ksf> oh.
16:06:59 <ksf> http://docs.google.com/viewer?a=v&q=cache:t9iFJN8DDbQJ:research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf+Modular+type+inference+with+local+assumptions&hl=de&gl=de&pid=bl&srcid=ADGEESgVr-MlJFsnWcvDVvUuWj_bYekBSzIRfmDeOp_6sLaYhwYwLvCLMuac5uZSJCHF_UxqYWmoC3A0fhGVKgu18bmfkllHv46bj8tX68Gh4O3hp8udQwoL-0uddYnFFGN-q4E45jCK&sig=AHIEtbQtQyVEWU18XajLyAf_GtP2fwJ2XA
16:07:47 <copumpkin> http://blog.sigfpe.com/2010/08/divided-differences-and-tomography-of.html
16:09:34 <osaunders> Someone is tolling about how functional programming is the spawn of satan or something on another server/channel.
16:09:42 <copumpkin> :o
16:09:49 <copumpkin> people like to do that a lot
16:09:53 * Berengal feels an xkcd reference coming on
16:10:08 <osaunders> copumpkin: I had heard of it but not encountered it before.
16:11:24 <bss03> So, Haskell vs. F#.  Anyone used both?  Which do you prefer and why?  One of my twitter followers says I should stop with the HAskell and learn F#, but I really appreciate the purity of Haskell.
16:11:58 <Berengal> Use whichever you like best
16:12:11 <copumpkin> bss03: who's the twitter follower?
16:12:20 <mietek> JDH :>
16:12:23 <roconnor> :)
16:12:26 <copumpkin> (the source of the argument is central to its validity, as always)
16:12:44 <Berengal> That man really likes hashtables...
16:14:20 <Heffalump> bss03: I've used both extensively.
16:14:26 <msieradzki> bss03, F# is good if you need .NET libraries
16:14:38 <msieradzki> there's a lot of them and sometimes it's worth more than fancy language
16:15:00 <osaunders> Heffalump: Which do you prefer and why?
16:15:07 <Heffalump> F# means buying into the .NET platform. If you're already bought into it, then it's an obvious choice. If not, that's a big step.
16:15:18 <msieradzki> how
16:15:26 <Heffalump> It comes with pretty good tool support (though substantially inferior to C#'s)
16:16:21 <Heffalump> As a language, it has to make a lot of compromises to integrate with .NET and OO programming. (It's explicitly advertised as a multi-paradigm language, not just a functional one)
16:16:58 <msieradzki> has this async construct which lets you parallelize IO
16:17:05 <Heffalump> The type system is pretty weak (compared to Haskell). You find yourself turning everything into Objects a lot.
16:17:20 <Heffalump> msieradzki: you could do the same thing with Haskell threads
16:17:22 <msieradzki> easily like get me these quotes for given list of stocks
16:17:32 <msieradzki> Heffalump, how easily? :)
16:17:51 <Heffalump> msieradzki: I'm fairly sure you could get the same functionality as async with a small Haskell library, but I've never actually tried to do it.
16:17:52 <osaunders> copumpkin: I think the guy was drunk actually. There was a sentence that just made no sense at all.
16:17:54 <msieradzki> where I getting stock from for example Yahoo takes 0.1-1.0s
16:18:16 <Berengal> msieradzki: Writing an async :: IO a -> IO (MVar a) function is a one-liner
16:18:30 <msieradzki> returning mvar?
16:18:38 <copumpkin> osaunders: maybe he was just so convinced of his thesis that he lost his ability to make words 
16:18:43 <copumpkin> msieradzki: to wait on, presumably
16:18:44 <Berengal> msieradzki: Yes. The mvar can either be blocked on, or queried
16:19:06 <msieradzki> well haskell is richer than F# when it comes to language so I guess everything can be done in haskell
16:19:09 <copumpkin> Berengal: I wish that were a library function :)
16:19:22 <osaunders> copumpkin: I happens to the best of us.
16:19:24 <osaunders> *It
16:19:27 <Berengal> copumpkin: It probably is... somewhere
16:19:29 <Heffalump> msieradzki: well, that's not entirely true. It doesn't have the OO features of F#.
16:19:44 <msieradzki> it's mostly about having .NET library classes like WebClient and really LOTS of code already written
16:19:51 <msieradzki> yes I didn't mean OO :)
16:20:01 <Heffalump> nor the cheap access to mutation (in terms of syntactic and semantic overhead)
16:20:32 <copumpkin> if you want cheap mutation, just use augustsson's basic :P
16:20:36 <Heffalump> also, it has a better module system than Haskell (which isn't hard)
16:20:39 <osaunders> My interest in F# is diminishing by the moment.
16:20:42 <copumpkin> syntactically and in terms of generated code
16:20:55 <Berengal> Heffalump: Have you looked at Scala too? I'm looking for some opinions on Scala's type system from someone who's been using more than one object-functional language,
16:21:01 <Heffalump> Berengal: nope.
16:21:13 <copumpkin> Berengal: dibblego uses it a lot I think
16:21:21 <msieradzki> I heard weird thing: that jvm doesn't support tail call or doesn't do it properly
16:21:29 <Heffalump> my very uninformed view is that it is much more objecty and much less functional than F#, though it does have higher-kinded type variables.
16:21:32 <msieradzki> which would be weird
16:21:48 <Heffalump> msieradzki: why would it be weird? It was never designed for functional languages.
16:21:54 <Berengal> msieradzki: It doesn't support it at all. All tail-calls have to be compiled to loops
16:21:54 <msieradzki> scala?
16:21:57 <Heffalump> Even in .NET, tail calls are pretty slow.
16:22:02 <msieradzki> F# reworking their runtime to do tail calls properly?
16:22:04 <Heffalump> msieradzki: the JVM was never designed for scala.
16:22:12 <ddarius> Heffalump: Arguably tail calls are just as important to OOP as to FP.
16:22:12 <msieradzki> I mean fixing it in .NET
16:22:22 <Heffalump> msieradzki: .NET got tailcalls before F# existed.
16:22:24 <msieradzki> CLR was never designed for F# either :)
16:22:25 <lispy> Berengal: I looked into scala (and wrote a non-trivial program in it) a few years ago.  What I found was that some language features combined in unexpected ways.  In a bad way.  I reported a few compiler bugs, I think those behaviors are gone now.
16:22:35 <msieradzki> Heffalump, but it wasn't designed for mutually recursive tail calls :P
16:22:46 <Heffalump> though the person who wrote F# (Don Syme) was one of the people responsible for pushing tail calls into the CLR earlier on.
16:22:47 <msieradzki> they had to fix some corner cases for F#
16:22:58 <Heffalump> msieradzki: you mean the JIT was buggy?
16:23:09 <msieradzki> it supported simple scenario of a tail call
16:23:15 * Heffalump is not intimately familiar with the history.
16:23:17 <msieradzki> harrop had some example
16:23:20 <ddarius> msieradzki: F# was designed for the CLR though.
16:23:32 <msieradzki> he didn't like that a specific tail call wasn't optimized in Mono
16:23:37 <msieradzki> just saying
16:23:38 <Heffalump> did someone independent actually verify his example?
16:24:01 <msieradzki> it didn't get optimized on Mono and did on .NET 4.0 CLR
16:24:06 <Berengal> lispy: It seems to have improved alot lately. I still haven't gotten into it big-time, but the day-old newbie experience has at least improved
16:24:26 <ddarius> The CLR hasn't changed since .NET 2.0 unless I missed something recently.
16:24:34 <ddarius> (well, no public changes)
16:24:38 <Heffalump> ddarius: do you mean that the bytecode hasn't changed?
16:24:45 <Heffalump> The CLR has changed massively.
16:24:53 <Berengal> ddarius: Didn't they get the dynamic stuff in 4.0?
16:24:56 <Heffalump> the big increment being 3.5 -> 4.0
16:25:02 <msieradzki> no it hasn't
16:25:07 <Heffalump> Berengal: that's just in the C# language (and perhaps VM optimisations)
16:25:29 <Berengal> (Also, anyone else notice that .NET follows the DnD version numbering scheme?)
16:25:36 <msieradzki> byte code format hasn't changed or hasn't changed much since introduction of generics in 2.0
16:26:11 <msieradzki> "dynamic" is in the compiler as far as I know
16:26:18 <Berengal> Ah
16:28:04 <Berengal> I feel weird for saying so, but I'm really looking forward to Java 7...
16:28:19 <wli> F-bounded polymorphism?
16:28:33 <tensorpudding> What's exciting about Java 7?
16:28:42 <Berengal> Closures
16:29:16 <tensorpudding> Neat.
16:29:44 <msieradzki> in few years java will get to the level of C# 2.0 cool
16:30:11 <Berengal> Though I've already become blind to the uglyness of anonymous classes, so they're syntactic sugar for me...
16:31:20 <Berengal> ...mostly...
16:31:47 <Berengal> Oh, and list and map literals.
16:31:53 <msieradzki> I wonder if they will finally introduce generics
16:32:45 <Berengal> I'm fine with the compile-time generics they have, though the type-inference algorithm sucks (and the OpenJDK7 compiler has a regression that's going to hurt me if they don't fix it before they release it)
16:33:11 <msieradzki> performance isn't fine with them though :)
16:34:06 <lispy> anyway, probably a better discussion for #haskell-blah or ##java
16:34:27 <ksf> way back, I was _thrilled_ that java had anonymous classes.
16:34:43 <ksf> I was half expecting to have to write seperate decls for my handlers.
16:35:41 <ksf> so, strictly speaking, lambdas shouldn't be necessary, as noone valuing his sanity would ever write java without smart completition, anyway.
16:35:41 <FauxFaux> Berengal: They're only compile-time as far as the language and runtime are concerned, the data is actually in the .classes, for massive bloat.
16:36:18 <ksf> generics are actually just syntactic sugar in java, to ensure backwards bytecode compatiblity
16:36:29 <Gracenotes> Java is actually going to have closures?
16:36:43 <ksf> ...even though pre-generics jvms don't come with the necessary libs.
16:36:47 <FauxFaux> As far as I'm aware the proposal that's actually going to be in Java 7 isn't finalised yet.
16:37:03 <FauxFaux> (There were three, in decaying orders of awesomeness.)
16:37:08 <Berengal> Gracenotes: Last I heard, but I'm not sure until I can actually see them
16:37:10 <Gracenotes> and the reported demise of closures has actually been exaggerated
16:37:32 <wli> I've forgotten what went wrong with Java generics as actually standardized.
16:37:34 <ksf> you can see that everything is actually still Objects in the bytecode by noticing that you can't have two methods Foo<Bar> foo () and Foo<Baz> foo ()
16:38:01 <Berengal> ksf: You can't dispatch on the return type anyway
16:38:03 <FauxFaux> That wouldn't be legal anyway; you can't overload on return type even without generics.
16:38:12 <ksf> erm yes.
16:38:25 <Berengal> void foo(Foo<Bar> bar) / void foo(Foo<Baz> baz)
16:38:26 <ksf> but you can't overload on the argument types, either.
16:38:57 <FauxFaux> You can interface A implements Foo<Bar> {} and interface B implements Foo<Baz> {} ¬_¬
16:39:04 <FauxFaux> s/ipmlements/extends/g
16:39:16 <ksf> that's because interfaces don't exist at runtime.
16:39:40 <Gracenotes> and generics and arrays are a nasty mix
16:39:57 <FauxFaux> I know this is a stupid question but I'm tired; what the hell is the word, begins with r, that means that Foo<String> doesn't extend Foo<Object>?
16:40:02 <Berengal> Arrays are just plain bad for you
16:40:16 <Gracenotes> not when they're the only way to varargs
16:40:17 <wli> Didn't Wadler have a solution to generics and arrays?
16:40:18 <FauxFaux> Reified.
16:40:32 <ksf> hey I once implemented a whole GUI library in terms of Object arrays.
16:40:32 <copumpkin> thingified
16:40:59 <copumpkin> (res means thing in latin)
16:41:03 <Berengal> wli: java generics are sane in that way, and Wadler had a part in specifying them
16:41:19 <ksf> (speak of an informally-specified implementaitoin of a tenth of common lisp)
16:46:21 * CalmNelly attempts to swallow his face
16:48:32 * ksf thinks the type checker should be programmable
16:48:48 <ksf> ...directly direct unification, that is.
16:49:12 <Berengal> Where would that be helpful?
16:49:16 <copumpkin> ksf: I agree to an extent
16:49:49 <Berengal> Would this only be optimizations, or would it change semantics as well?
16:49:49 <ksf> in every case where you want to analyse something that at least borders on turing-completeness and thus isn't solvable by a generic one.
16:50:50 <ksf> that is, you could direct the typechecker to e.g. backtrack for some FunDeps because it happens to be needed to do what you want to do.
16:51:07 <copumpkin> Berengal: I'm mostly going after saving the programmer from writing trivial proofs
16:51:14 * lispy grumbles about attoparsec being too slow
16:51:17 <ksf> it would enable further techniques, too.
16:51:25 <lispy> how to fasterize it?
16:51:36 <copumpkin> lispy: use happy :P
16:51:39 <ksf> tried frisby?
16:51:54 <ksf> if that's still to slow, use a good DFA implementation.
16:52:06 <lispy> I haven't tried happy or frisby.  Due to the intermingling of my lexing and parsing I really need something that fits a parsec style
16:52:10 <Berengal> It could help you avoid bottoms with UndecidableInstances...
16:52:17 <lispy> I don't have any backtracking in my grammar
16:52:23 <lispy> Or my parser....
16:52:24 <ksf> frisby does fit that.
16:52:35 * hackagebot cmdlib 0.1 - a library for command line parsing & online help  http://hackage.haskell.org/package/cmdlib-0.1 (PetrRockai)
16:52:36 <ksf> in fact, packrat parsers excel at unified lexing+parsing
16:52:37 <Heffalump> to be precise, it's proving slower than a fairly naive ByteString -> Maybe (a, ByteString). Is that normal?
16:52:46 <lispy> Just a straight pass with a little lookahead.  Probably 1 token worth depending on where in the parse it is
16:53:09 <ksf> sounds like a regular grammar
16:53:15 <copumpkin> Heffalump: ? did I miss the first part of that?
16:53:18 <lispy> Heffalump: oh, have you seen the numbers for attoparsec?  I didn't think I posted them yet
16:53:33 <Heffalump> lispy: no, I was just basing that on what you said on #darcs
16:53:39 <lispy> oh right
16:53:49 <Heffalump> copumpkin: no, was just following up on what lispy said
16:53:52 <copumpkin> oh
16:54:00 <lispy> Heffalump: linesStartingWith is the reason takeWhile shows up in the profile
16:54:16 <lispy> Heffalump: So, anything we can do to speed up that will generate up to 15% performance boost
16:55:47 <Heffalump> lispy: do you mean that it shows up significantly in the profile of the existing parser, or the attoparsec one?
16:56:20 <lispy> Heffalump: I didn't profile the existing one so I can't say about it. But takeWhile is like 14.7% in the profile
16:56:37 * Heffalump moves back to #darcs
16:56:51 <lispy> Heffalump: I'm going to make a variant of it that doesn't build up the list because there are a few places where we don't care about the stuff it parses (like context patches)
17:01:29 <steshaw> hi, I'm reading http://learnyouahaskell.com/functors-applicative-functors-and-monoids where it makes the point that creating a wrapped type using newtype and data differ in their laziness. However, for me in ghci it works with data and newtype
17:01:54 <tolkad> why can't I create a data type in GHCI?
17:02:56 <allbery_b> because it's an evaluation loop, not a full interpreter
17:03:44 <ksf> wait I can annotate my HList with indices right away with a GADT, lookup should be way easier than calculating an index along the way.
17:04:26 <ksf> ...hopefully easy enough to do equality checking with TypeCast
17:04:50 <drhodes> has anyone managed to get haskell code running on native client?  I know google has some people working on nacl-llvm... someone has managed to make the ocaml compiler emit nacl complient code http://code.google.com/p/nacl-ocaml/
17:04:57 <tolkad> well, anyway, is it possible to partially apply a constructor? like «data T = TC Int Int; f :: Int -> Int -> T; f x = (TC x)
17:05:12 <steshaw> Using http://gist.github.com/513363 when I issue "alwaysHello undefined" ghci happily says "hello"
17:05:36 <tolkad> like you can do (5+) and get Integral a => a -> a
17:07:10 <ClaudiusMaximus> > map Just "tolkad"
17:07:12 <lambdabot>   [Just 't',Just 'o',Just 'l',Just 'k',Just 'a',Just 'd']
17:07:36 <ClaudiusMaximus> :t repeat Just
17:07:38 <lambdabot> forall a. [a -> Maybe a]
17:07:57 <Gracenotes> looking around, is there some kind of atexit implementation?
17:07:58 <roconnor> steshaw: the difference will be with "alwaysHello (CoolBool undefined)"
17:09:45 <Gracenotes> or is bracket the best I can do
17:10:17 <Berengal> steshaw: http://codepad.org/kaRA6mPI
17:10:33 <lispy> tolkad: Yeah.  I kind of wish ghci supported proof general
17:10:54 <tolkad> wtf...I just compiled something and it had a parse error and tried again and it worked
17:11:13 <tolkad> oh well, guess it's gnomes
17:11:20 <steshaw> @rocnnor thanks I did mean alwaysHello (CoolBool undefined). I thought perhaps that I hadn't reloaded the file after switching from newtype to data but that's not the case. I just tried quitting ghci and reloading from there.
17:11:20 <lambdabot> Unknown command, try @list
17:12:01 <Berengal> There won't be a difference with (CoolBool undefined), only with a pure undefined
17:12:28 <tolkad> Haskell is a cool language, but sometimes I wish it was more type safe, like PHP
17:12:39 <p_l> ...
17:12:39 <copumpkin> lol
17:12:50 <p_l> fukken saved
17:12:50 <c_wraith> I often miss php's fucked up semantics, too :)
17:12:53 <copumpkin> I've never had typechecking be nondeterministic before ;)
17:12:58 <copumpkin> I'm guessing it's pebkac ;)
17:13:21 <Berengal> Does "type safe" mean that you never get a type error?
17:13:31 <Baughn> @remember tolkad Haskell is a cool language, but sometimes I wish it was more type safe, like PHP
17:13:32 <lambdabot> Done.
17:13:43 <tolkad> @quote tolkad
17:13:44 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
17:13:46 <tolkad> @quote tolkad
17:13:47 <lambdabot> tolkad says: Haskell is a cool language, but sometimes I wish it was more type safe, like PHP
17:14:21 <ozamosi> Ok, so… If I use one library that uses monad stuff from transformers and monads-fd in it's public interface, and one library that uses mtl instead, how could I compile a resulting binary? I sort-of accidentally succeeded by rewriting my cabal file halfway through wading through build failures, but something tells me that's the wrong way :)
17:14:23 <steshaw> thanks @Berengal you're right
17:14:47 <Philonous> Do I need an extension to use guards in case expressions?
17:14:57 <c_wraith> ozamosi....  the easiest way is to rewrite one of the libraries.  no, really.  :(
17:15:02 <Baughn> ozamosi: The PackageImports extension, IIRC
17:15:15 <tolkad> does monad mean parametic type with a single parameter? like data T a = T a?
17:15:17 <Baughn> That's how I dealt with it
17:15:36 <Baughn> ..when combining two libraries that used different monad packages, /both of which I'd written/
17:16:20 <tolkad> and what's the difference between a monad and a monoid?
17:16:27 <tensorpudding> A Monad is a class which is parameterized over a single type.
17:16:34 <c_wraith> tolkad: a vs oi
17:16:35 <Baughn> So is a Monoid
17:16:38 <tensorpudding> But there are many typeclasses which are that way
17:16:45 <ozamosi> Baughn: ok, thanks
17:16:51 <Baughn> tolkad: Have you had a look at the Typeclassopedia?
17:16:54 <danportin> A monad is a triple of a type constructor, bind and unit.
17:17:04 <tensorpudding> Functor, MonadPlus, Applicative
17:17:27 <Baughn> tolkad: (Do so. It explains all this, better than we ever could.)
17:17:35 <Gracenotes> :/ is there a reason why hslogger isn't logging? I do { runl <- fileHandler "times" INFO; updateGlobalLogger "Time" (addHandler runl) }, and later on 'liftIO $ infoM "Time" str'; file is empty as ever. what's the big idea..
17:17:51 <Berengal> the Monad type class isn't parameterized over a type, but over a type constructor
17:18:10 <Baughn> Gracenotes: IIRC, INFO-level notes aren't logged by default. Try emergency. Or change the log limit.
17:18:43 <Gracenotes> Baughn: that's odd, since I initialize the handler with INFO. I should poke it more.
17:19:12 <Gracenotes> really I just want a nice way to asynchronously fill up a text file with events
17:19:19 <Baughn> Hm
17:19:33 <Baughn> I wouldn't use a logger for that, I'd just us a Chan or MVar
17:19:41 <Berengal> Logger daemon thread ftw
17:20:10 <Gracenotes> Baughn: except it's rather nice to not hand it around explicitly... global refs for the win
17:20:20 <Berengal> Global refs suck :(
17:20:22 <tolkad> is there a way to do «class (* a) => Everything a»
17:20:24 <tolkad> ?
17:20:27 <Gracenotes> so convenient
17:20:32 <Gracenotes> well I guess I can shoehorn my code in that.
17:20:42 <Baughn> Gracenotes: That's what your custom reader monad is for. ;)
17:21:28 <Gracenotes> ssshhh. the code that my logger is adapting isn't supposed to know it exists.
17:21:34 <Veinor> tolkad: what do you mean?
17:21:47 <Gracenotes> pipe down or it'll hear you and complain
17:22:16 <tolkad> Veinor: where * can be any class
17:22:32 * Baughn tends to deal with mutable state by passing around a humongous STM structure - or, lately, HList
17:22:34 <tolkad> I mean, it is all classes
17:22:34 <Veinor> I'm not sure what you want to do
17:22:55 <tolkad> I want to say that something can only be an instance of Everything if it is an instance of every other class
17:23:14 <Veinor> that's silly
17:23:23 <tolkad> that way I can just make sure everything implements everything instead of being an incomplete implementation
17:23:37 <tolkad> it's bad practice to leave classes unimplemented
17:24:13 <Berengal> No, it's bad practice to implement more than you're going to use
17:24:20 * Veinor writes an Ord instance for IO
17:24:39 <bss03> It's a bad practice to declare more than you use.
17:24:44 <Berengal> Veinor: kind mismatch ;)
17:24:52 <tolkad> what's a kind?
17:25:01 <tolkad> is it like a type, but more friendly?
17:25:05 <Berengal> tolkad: type type sort of thing
17:25:05 * Veinor writes an Ord instance for IO a
17:25:16 <bss03> tolkad: A kind is a type of types.
17:25:19 <Veinor> (<=) = undefined
17:25:33 <tolkad> so classes are kinds?
17:26:01 <Berengal> No, classes are classes
17:26:11 <bss03> :k IO
17:26:12 <lambdabot> * -> *
17:26:12 <Berengal> haskell has three kinds, and one kind-constructor
17:26:14 <tolkad> then what's a kind? can you give an example in standard haskell?
17:26:15 <bss03> :k Maybe
17:26:16 <lambdabot> * -> *
17:26:17 <bss03> :k Int
17:26:17 <tolkad> oh
17:26:18 <lambdabot> *
17:26:20 <tolkad> I see
17:26:22 <Berengal> Or was that four kinds...
17:26:31 <bss03> :k Data.Map.Map
17:26:33 <lambdabot> * -> * -> *
17:26:40 <Berengal> *, #, ? and ??, right?
17:26:45 <tolkad> so it's the number of arguments a function has
17:27:16 <Veinor> I don't even think you can say class (Foo t, Bar t) => Baz t
17:27:16 <bss03> :k Data.Map.Map String (IO a)
17:27:17 <lambdabot> Not in scope: type variable `a'
17:27:25 <bss03> :k Data.Map.Map String (IO )_)
17:27:27 <lambdabot> parse error on input `_'
17:27:29 <bss03> :k Data.Map.Map String (IO ())
17:27:31 <lambdabot> *
17:27:31 <Berengal> Veinor: You can, but it won't be very helpful
17:27:32 <Veinor> without enabling... some extension. I forget what it is.
17:27:35 <bss03> :k Data.Map.Map String
17:27:36 <lambdabot> * -> *
17:27:38 <bss03> :k Data.Map.Map
17:27:40 <lambdabot> * -> * -> *
17:27:50 <Veinor> Berengal: right, because then it means that all Baz's have to be Foos and Bars
17:27:57 <Veinor> right?
17:28:21 <tolkad> Veinor: (Float a, Real a) => RealFloat a
17:28:37 <tolkad> err floating
17:28:41 <Veinor> I'm thinking of something else
17:28:41 <Berengal> Veinor: Everything is a Baz, but you'll get a type-error when trying to use a type as a Baz if it's not also a Foo and a Bar. Also, you can't declare other instances without OverlappingInstances because it captures all types
17:28:49 <tolkad> and realfrac, whatever
17:28:52 <tolkad> http://www.zvon.org/other/haskell/Outputprelude/RealFloat_c.html
17:28:54 <Veinor> Berengal: yeah, that's what I was thinking of
17:29:25 <Berengal> Veinor: As it is, without OverlappingInstances, it can be used as a sort of "class synonym"
17:29:35 <Veinor> ?
17:30:31 <Berengal> with a class (Foo a, Bar a) => Baz a, you can write functions of type (Baz a) => Lol a, instead of the more verbose (Foo a, Bar a) => Lol a
17:31:32 <Berengal> Err, s/class/instance/ anyway
17:33:07 <danportin> Is there any way to recursively define a type in a type synonym without wrapping the type with a type constructor in a data declaration (messy)?
17:33:18 <EvanR> newtype
17:33:28 <EvanR> not a type synonym though
17:33:51 <EvanR> type synonyms cant be recursive, they would be infinite
17:33:54 <monochrom> newtype Me = Myself Me
17:34:15 <danportin> Okay, but I still need a type constructor?
17:34:21 <monochrom> yes
17:34:24 <danportin> Okay
17:35:35 <tolkad> also, you might have a function that applies to the intersection of both classes
17:36:45 <duckinator> i'm trying to make a function that returns a randomly negated (as in, either positive or negative based on the results of some random operation), and me and a few others have come up with http://gist.github.com/513388 but it returns the errors at http://gist.github.com/513396 .. any ideas/tips as to what the issue may be?
17:37:28 <danportin> So I can define a type synonym such as 'S a = Tree a -> (a, Tree a)' but not 'S a = Tree a (S a, Tree a)
17:37:40 <danportin> because there is no base case for recursion?
17:37:50 <c_wraith> duckinator, why aren't you getting the random as randomIO :: IO Bool ?
17:37:54 <monochrom> what is line "8"? there are only 6 lines.
17:38:08 <duckinator> c_wraith: that's...a good point o.O thanks haha
17:38:32 <EvanR> Random Monad ;)
17:38:51 <Zeiris> I'm trying to port the "polymorphism in OOP" wiki article to Haskell. Their example is trivial, but adding animal-specific data comlpicates it... I'm gettg a type mismatch in the heterogenous list on line 27. Shouldn't forall allow anything there? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28700#a28700
17:39:00 <monochrom> you could also use Bool instead of Int.
17:39:04 <EvanR> oh god oop animals
17:39:10 <Zeiris> :D
17:39:31 <Zeiris> It was that or cars.
17:39:39 <monochrom> try not to use heterogeneous lists
17:40:02 <EvanR> oop might make a small bit of sense if training manuals used real-life examples rather than animals or cars
17:40:16 <aavogt> Zeiris: and you're not using a heterogenous list in that case anyways
17:40:25 <Zeiris> Yeah, I had the feeling a direct translation of data types is silly. :(
17:40:35 <monochrom> I'm also skeptic about porting "polymorphism in OOP" to haskell. sounds non-portable.
17:41:01 <monochrom> it's just like porting "OOP in OOP" to haskell.
17:41:05 <Zeiris> I asked Lambdabot and it said yes, Haskell can do it...
17:41:07 <ozamosi> EvanR: I don't understand. Are you saying there's code in the world that doesn't directly map to a physical thing? :O
17:41:22 <monochrom> she's overly optimistic
17:41:23 <EvanR> :o
17:41:34 <srh> danportin: more like, because you're defining (S a) to be an infinite type
17:41:45 <monochrom> @faq can haskell shave all and only those who don't shave themselves?
17:41:45 <lambdabot> The answer is: Yes! Haskell can do that.
17:42:11 <c_wraith> @faq Can Haskell be shaved?
17:42:11 <lambdabot> The answer is: Yes! Haskell can do that.
17:42:29 <Berengal> EvanR: OOP makes more sense with animals and cars than with real-life examples in my experience...
17:42:35 <EvanR> lol
17:42:47 <monochrom> Berengal++
17:43:02 <ozamosi> Berengal: you just didn't write enough factoryconstructorproxies.
17:43:53 <Berengal> ozamosi: Oh, but I do. They're all nounified verbs.
17:43:56 <EvanR> would be interesting to sit down and decompile all of those 'design patterns' into what you do instead in haskell
17:44:54 <Zeiris> That actually sounds like an interesting exercise.
17:45:20 <Berengal> EvanR: The problem is that OOP and FP are so different that there's a pretty complicated many-to-many mapping between the idioms, not a simple one-to-one
17:45:31 <EvanR> half of them are probably 'dont do anything'
17:46:02 <osaunders> I have given birth to: http://www.meetup.com/ed-lambda/
17:46:05 <EvanR> flyweight comes to mind ;)
17:46:31 <osaunders> I think a lot of the wording could be improved.
17:46:38 <danportin> So why can't you define an infinite type? I use infinite lists, etc., all the time. Why can't I just pass functions finite values of type 'S a'? (Sorry if I'm being dense).
17:46:58 <dolio> Infinite types are frequently errors.
17:46:59 <Berengal> danportin: You can, with Mu
17:47:14 <dolio> So they're disallowed unless they're encoded in a datatype of some sort.
17:48:16 <monochrom> please don't mix up infinite lists and infinite types
17:48:40 <dolio> And 'type' is rather like a macro, so if you allowed recursion there, you'd be in danger of unfolding forever.
17:48:47 <dolio> Unless you made them more first-class.
17:49:07 <danportin> @dolio: that makes sense. I guess I'll have to do some research, then.
17:49:07 <lambdabot> Unknown command, try @list
17:50:03 <aavogt> Zeiris: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28700#a28701  not that this is really a good way to accomplish your problem
17:50:39 <aristid> danportin: if you speak somebody, please don't add an @ in front of the name, because lambdabot then thinks it's a command for him
17:50:57 <danportin> Yeah, I just realized that. Thanks though.
17:51:36 <copumpkin> twitter user?
17:52:29 <freedrull> hackage down?
17:52:55 <beTTY_> so i'm writing a static analysis tool to do taint analysis in PHP (figure this will give me a firm grasp on parsers, PL etc). I've got a nice AST generated.. but im starting to wonder if taint analysis is even possible from an AST.. anyone have any experience here?
17:53:41 <monochrom> hackage is accessible from me and from downforeveryoneorjustme.com
17:53:57 <mornfall> hackage up
17:55:22 <freedrull> ok
17:55:31 <monochrom> I don't know taint analysis, but many static analyses are done on control-flow graphs.
17:57:15 <EvanR> freedrull of the game freedrull?
17:57:50 <EvanR> or am i insane and thats not real
17:58:08 <aavogt> Zeiris: you'd probably replace the data Animal and data Dog with the records provided by hlist
17:58:42 <freedrull> EvanR: haha no idea 0.o
17:58:53 <danportin> Okay, so defining a recursive data type is analogous to an inductive definition. A data type like S a = M a | M (M a) requires 'M a' to provide a base case and 'M (M a)' to describe the induction. With a type synonym like 'S a = S a -> (S a, a)', if 'S a -> (S a, a)' is not substituted for 'S a' then the expression is ill-typed. There is no way to stop the recursion. Is that right?
17:58:54 <freedrull> is there a game called freedrull?
17:59:11 <EvanR> i probably thought it was a game because i spent a lot of time talking about games on freenode, and saw your name
17:59:20 <EvanR> sounds like a game name
18:00:20 <Zeiris> aavogt, cool, I'll keep HList in mind if I need a serious heterogenous list in the future. Although at the moment the documentation flows over my head.
18:00:55 <freedrull> EvanR: i think i asked you a lot of dumb SDL questions in #SDL :D
18:01:17 <EvanR> i knew it
18:01:24 <EvanR> #sdl
18:01:58 <aavogt> Zeiris: -XExistentialQuantification can be used (and is used more frequently) to hide that types are different for sticking them in a list
18:02:32 <aavogt> rather than doing like hlist where the type of the list is about as big as it's contents :)
18:18:57 <EvanR> no #haskell throughput has dropped below 100 lines per minute!
18:19:37 <mornfall> Oh dear! What shall we do?
18:20:04 <ddarius> Nichts.
18:20:37 <mornfall> aavogt: Or bigger. On the other hand, it seems to be able to do neat tricks, too.
18:25:19 <copumpkin> wow, complex quantifier elimination (in this case) is so much faster than real
18:25:55 <copumpkin> maybe even in general
18:26:43 <copumpkin> forall r s c x y. (x^2 + y^2 = r^2 /\ r * c = x /\ r * s = y ==> forall a b. (r = b + a * c ==> (x^2 + y^2 - a * x)^2 = b^2 * (x^2 + y^2))) is the statement
18:33:38 <Zeiris> Is there some way to pretty-print loong records with nested stuff inside 'em? Text.PrettyPrint.ANSI.Leijen seems to require defining instances of Pretty by hand.
18:34:45 <aavogt> @hackage IPPrint
18:34:45 <lambdabot> http://hackage.haskell.org/package/IPPrint
18:34:57 <aavogt> err, http://hackage.haskell.org/package/ipprint
18:35:26 <Zeiris> ohmygod that's awesome
18:43:05 <ddarius> copumpkin: What are you talking about?
18:44:25 <copumpkin> ddarius: deciding all statements about reals with +, -, *, all the ordering relations and equality, as well as existential and universal quantification
18:44:32 <copumpkin> I was surprised, but it's decidable
18:45:01 <c_wraith> I thought equality on reals was undecideable.
18:45:50 <copumpkin> well, you only get rational constants, and you're not actually working with any actual real values
18:46:02 <copumpkin> (it's not like it's using IEEE doubles behind teh scenes or anything)
18:46:16 <c_wraith> Oh.  just using rationals, that's easy.
18:46:31 <copumpkin> lol
18:46:34 <copumpkin> I wouldn't say that
18:46:40 <c_wraith> :)
18:46:47 <copumpkin> that formula I wrote back there, 20 minutes ago, is still being checked for the relas
18:46:48 <copumpkin> reals
18:46:55 <copumpkin> the complex version finished immediately
18:47:19 <ddarius> copumpkin: What system are you using?
18:48:10 <copumpkin> ddarius: nothing sophisticated, just the sample code that comes with harrison's book on the subject (http://www.cambridge.org/catalogue/catalogue.asp?isbn=9780521899574) with a nice overview over at http://xorshammer.com/2009/05/14/a-suite-of-cool-logic-programs/
18:48:11 <copumpkin> it's in ocaml
18:48:25 <copumpkin> since he seems to love ocaml (he also did HOL light, and of course that's in ocaml)
18:55:06 <tolkad> What is the first argument of readsPrec for and why does it return a list rather than a simple tuple?
18:56:25 <ski> @type readsPrec
18:56:27 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
18:56:36 <ski> it's the precedence
18:56:36 <tolkad> oh, finally found some documentation
18:56:47 <ski> and it returns a list of possible parses
18:57:04 <tolkad> a lot of these doc pages are blank for no reason, like this: http://zvon.org/other/haskell/Outputprelude/readsPrec_f.html
18:57:40 <ddarius> Bah, there wouldn't be anything to see if Banach-Tarski was actually performed.
18:58:09 <ski> > (readsPrec 0 :: ReadS Rational) "2 % 3"
18:58:10 <lambdabot>   [(2 % 3,"")]
18:58:12 <ski> > (readsPrec 10 :: ReadS Rational) "2 % 3"
18:58:14 <lambdabot>   []
18:58:16 <ski> > (readsPrec 10 :: ReadS Rational) "(2 % 3)"
18:58:17 <lambdabot>   [(2 % 3,"")]
18:58:19 <tolkad> so what's the precedence level for?
18:59:01 <ski> well, you might be calling `readsPrec' to parse something that's say after `12 + '
18:59:32 <ski> so, you only want to parse an expression where any non-bracketed operators binds more tightly than `+'
19:00:02 <ski> so, you tell `readsPrec' the precedence that `+' has (or maybe add one, i'm not sure), to say that
19:00:33 <tolkad> so... it determines order of operations?
19:00:39 <FunctorSalad> pretty colour for the bikeshed isn't it? http://code.haskell.org/~daniels/composure/dist/doc/html/composure/Control-Composure.html
19:01:12 <ski> (though i guess `+' isn't really a good example, since it's not output by `showsPrec' or read by `readsPrec' .. but you could easily define your own datatype which had a constructor which can be used infix with a precedence)
19:01:26 <ski> tolkad : it determines the allowed precedence
19:01:51 <tolkad> ski: which is order of operations?
19:02:10 <ddarius> copumpkin: You should make an LCF style theorem prover.
19:02:31 <ski> tolkad : i'm not sure what you mean by "order of operations", so i can't answer that
19:03:09 <EvanR> parsing precedence vs evaluation order
19:03:15 <copumpkin> ddarius: I should read up on LCF first :) I have much to learn before I can write my own!
19:03:16 <tolkad> http://en.wikipedia.org/wiki/Order_of_operations
19:03:25 <EvanR> two different things
19:03:52 <tolkad> EvanR: but if you were parsing a mathematical expression, you would use the evaluation order
19:04:05 <EvanR> no
19:04:34 <EvanR> parsing using operator precedence order
19:04:55 <ddarius> copumpkin: LCF is the language ML was the meta language for and is the predecessor of HOL and Isabelle.
19:05:12 <EvanR> (1+2)*2, first parentheses, then *
19:05:24 <tolkad> EvanR: I'm saying the evaluation order would be the same as the precedence order
19:05:48 <EvanR> im sort of lost, are you making a parser, or calculator or something?
19:05:55 <EvanR> or trying to write haskell code
19:06:02 <tolkad> I'm making a parser for HTTP
19:06:10 <tolkad> and very confused on how to implement Read
19:06:21 <EvanR> then theres no evaluation going on
19:06:29 <ski> tolkad : in math, there generally is no evaluation order .. e.g. often you just reason algebraically, rewriting parts
19:06:30 <EvanR> so theres no order of operations
19:06:47 <tolkad> what do I do about precedence?
19:07:14 <copumpkin> ddarius: I've heard of it, but know nothing about it beyond its name :) I have a very skewed sampling of proof assistant experience
19:07:14 <EvanR> also, not all parsers have a concept of operator precedence
19:07:25 <EvanR> is HTTP really operator centric?
19:07:27 <EvanR> i didnt think so
19:07:41 <tolkad> I didn't know parsers were so complicated, until now whenever I wanted to parse something I wrote a regex
19:07:44 <ski> tolkad : `Read' and `Show' is meant to parse and print valid Haskell code. if you're parsing some kind of HTTP format, it presumably isn't valid Haskell syntax, so you shouldn't use `Read' and `Show'
19:08:09 <EvanR> parsers is an extensive subject
19:08:30 <EvanR> regex is not a very capable parser
19:09:02 <tolkad> PCRE are probably turing complete
19:09:06 <tolkad> they are also very slow
19:09:14 <EvanR> parsers cant be turing complete
19:09:17 <tolkad> they aren't really regex
19:09:21 <Veinor> I dunno about PCREs, but perl regexes are turing complete trivially
19:09:33 <ddarius> copumpkin: The basic idea is simple.  You make an abstract data type representing theorems and only allow operations that preserve truth.
19:09:34 <ski> EvanR : huh ?
19:10:00 <tolkad> Veinor: trivially?
19:10:13 <EvanR> since when are parsers categorized by computing power
19:10:47 <tolkad> EvanR: perl regex is a language designed for parsing
19:11:00 <Veinor> $ perl -e "use re 'eval'; "foo" =~ /(?{print \"bar\"})/;"
19:11:01 <Veinor> bar
19:11:06 <EvanR> tolkad: parsec might be a good shot for http parsing, from what i see in this spec
19:11:11 <ski> parsers are (for one aspect) categorized by how powerful grammar formalisms they support
19:11:18 <EvanR> yeah
19:11:25 <Veinor> actually, I don't think you need use re eval
19:11:53 <EvanR> tolkad: and if you are trying to get work done, theres probably a hackage package
19:12:39 <dancor> ya this alone works for me: perl -e '"" =~ /(?{print "bar\n"})/'
19:13:19 <EvanR> and since when is being able to print something evidence of turing completeness
19:14:03 <Veinor> well, you can replace the print statement with arbitrary perl code
19:14:06 <Veinor> perl is turing complete
19:14:17 <ddarius> HQ9+
19:14:45 <dancor> EvanR: grep for "any embedded Perl code" in man perlre
19:15:03 <EvanR> does this even count as 'regex' then
19:15:12 <EvanR> i.e. regular expressions
19:15:21 <ddarius> EvanR: Of course not.
19:15:24 <copumpkin> ddarius: ah, neat
19:15:28 <aavogt> that's what they call it though
19:15:32 <EvanR> >_<
19:15:51 <Veinor> yeah, I specifically said 'perl regexes', not PCREs :D
19:15:54 <dancor> are there any regexp these days that are actually regular?
19:16:17 <EvanR> only toys i guess
19:16:26 <dancor> these aren't your grandfather's misnomers..
19:27:00 <tolkad> dancor: maybe sed?
19:27:02 <tolkad> idk
19:31:10 <EvanR> regex smell like business
19:41:43 <jbe> What's a nice way to apply a function to both elements of a pair? (a -> b) -> (a,a) -> (b,b) Is there something in Control.Arrow?  Hoogle fails me.
19:42:10 <monochrom> @type (&&&)
19:42:12 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:42:35 <monochrom> @type (***)
19:42:36 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
19:42:37 <Phyx-> :t \f -> (f &&& f)
19:42:38 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
19:42:45 <Phyx-> :t \f -> (f *** f)
19:42:47 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
19:42:51 <monochrom> it's ***
19:43:06 <Phyx-> :t (\f -> (f *** f)) (+1) (1,3)
19:43:07 <lambdabot> forall b. (Num b) => (b, b)
19:43:11 <Phyx-> > (\f -> (f *** f)) (+1) (1,3)
19:43:13 <lambdabot>   (2,4)
19:43:21 <monochrom> > (not *** not) (True, False)
19:43:22 <lambdabot>   (False,True)
19:43:27 <Phyx-> @pl \f -> (f *** f)
19:43:27 <lambdabot> join (***)
19:43:40 <Phyx-> now that'sa  good one
19:43:52 <Phyx-> > join (***) not (True, False)
19:43:53 <lambdabot>   (False,True)
19:44:16 <Phyx-> jbe: so I guess join (***)
19:44:25 * Phyx- waves hi to monochrom 
19:44:36 * monochrom particles lo
19:44:49 <EvanR> ._.
19:45:01 <Phyx-> particles low?
19:45:05 * Phyx- calls in Wall-E
19:45:25 <aavogt> a little too much broccoli?
19:46:07 <Phyx-> fly 1 - me 0
19:46:24 <Phyx-> aavogt: not unless he's green
19:47:02 <Phyx-> hmm
19:47:19 <Phyx-> a Name with a Unique {v a54z}
19:47:22 <Phyx-> what type would that be?
19:48:07 <Phyx-> it doesn't seem to be a variable
19:48:11 <Phyx-> maybe a value
19:48:18 <Phyx-> info <- ... or let into = ...
19:48:21 <Phyx-> what would info be?
19:48:22 <jbe> Phyx-: Thanks.  That works.  And maybe will help me grok arrows in the long run...
19:48:55 <Phyx-> jbe: I still don't fully understand arrows myself though :)
19:49:51 <Phyx-> anyone? there are cookies involved :P
19:50:46 <poljp> Did someone ban the webclient ip ? :)
19:50:51 <Phyx-> must be off hours....
19:52:27 <Phyx-> yup, seems so
19:52:29 <Phyx-> #haskell: ban *!*@gateway/web/freenode/*
19:52:39 <poljp> dope :P
19:52:49 <Phyx-> another odd wide ban  #haskell: ban *!*Gast*@*
19:52:54 <ski> there was spamming a few hours ago
19:54:14 <EvanR> why does xml require a giant library to parse...
19:54:16 <Phyx-> more viagra sellers?
19:54:29 <Phyx-> EvanR: because XML is the devil's work
19:55:21 <Makoryu> EvanR: XML is a catastrophe
19:55:24 <poljp> Anyhow, back to more exciting stuff. I have a recursive datatype to represent expressions. Is there anyway i can automagically make tuples map into it ?
19:55:40 <copumpkin> Phyx-: yep, a bunch of people were trolling from webchat earlier
19:55:40 <EvanR> when fans market it to me, they describe it as simply nested elements with attributes and text nodes
19:55:56 <Phyx-> copumpkin: any interesting ones?
19:55:57 <copumpkin> anyway, lots of off-topic in here :P
19:56:00 <copumpkin> maybe #haskell-blah
19:56:09 <Phyx-> copumpkin: haskell-blah seems to be busy :P
19:56:23 <Phyx-> poljp: how so?
19:56:41 <Phyx-> what do you mean with make tuples map to it
19:57:19 <BMeph> XML is just like SGML, only with more cryptic end cases... ;)
19:57:31 <poljp> example is that i can write using view patterns something like f e = out where (.. -> v, .. -> z) = e ... 
19:57:37 <poljp> then e will be (a,a)
19:57:55 <Phyx-> copumpkin: to be fair, I did ask something on topic, just didn't get an answer :P
19:57:59 <poljp> later on i want to write the same, so that i can do (.. -> a, --> b) = z
19:58:12 <poljp> that would infer that e = (a, (a,a))
19:58:25 <poljp> the lhs of -> is a func that takes just an Expr, not a tuple.
19:58:38 <poljp> (on this case as described, an 'a')
20:00:52 <Phyx-> poljp: why would e be (a,a) z and v don't have to be the same do they?
20:01:36 <poljp> the lhs of -> is the same function so here they would be.
20:01:46 <poljp> (it wraps the a in a name tag)
20:01:49 <aavogt> you can't have it both ways without infinite types
20:02:08 <aavogt> that  a = (a,a)
20:04:34 <Phyx-> poljp: if they can only be the same then what aavogt says is true, you'll have an infinite type
20:04:41 <poljp> indeed :-/
20:04:50 <Phyx-> :t let f x = id in (f, f)
20:04:51 <lambdabot> forall t a t1 a1. (t -> a -> a, t1 -> a1 -> a1)
20:05:09 <Phyx-> :t let f x = id x in (f, f)
20:05:10 <lambdabot> forall a a1. (a -> a, a1 -> a1)
20:05:32 <Phyx-> but i'm still not convinced that they have to be the same, even if the input is the same type, the output doesn't have to be
20:05:54 <aavogt> the types for things defined in let are generalized
20:06:52 <Phyx-> aavogt: if the function is polymorphic or for instance a class method, the same holds though
20:07:01 <Phyx-> :t sum
20:07:02 <lambdabot> forall a. (Num a) => [a] -> a
20:07:09 <Phyx-> :t (sum, sum)
20:07:10 <lambdabot> forall a a1. (Num a, Num a1) => ([a] -> a, [a1] -> a1)
20:07:54 <aavogt> Phyx-: a1 = a  if you took sum as a function argument (ex. in a lambda)
20:08:45 <sshc> In the "Extended Example: Full CSV Parser" section of the RWS haskell book chapter 16 (http://book.realworldhaskell.org/read/using-parsec.html), the first example uses "try (string "\"\"" >> return '"')
20:09:05 <sshc> " on the right of a <|>
20:09:11 <Phyx-> aavogt: will, it could still be higher rank :)
20:09:17 <sshc> Is the "try" redundant?
20:09:38 <Phyx-> :t try
20:09:39 <lambdabot> Not in scope: `try'
20:09:48 <Phyx-> :t string
20:09:49 <lambdabot> Not in scope: `string'
20:10:07 <Phyx-> oh, it's parsec
20:10:09 <sshc> Hmm, I see why it's needed:
20:10:21 <sshc> If it fails, it won't consume any input
20:10:22 <aavogt> sshc: it's not, because if you didn't have the try that parser will consume input but still fail on say  "\"a"
20:10:24 <Phyx-> well, I suppose string can throw an exception
20:10:39 <sshc> The parser will fail when it encounters a single and terminating '"'
20:10:48 <aavogt> so  try makes it backtrack
20:10:53 <aavogt> Phyx-: different try
20:10:58 <Phyx-> oh
20:11:01 <sshc> Then the "many" "stops"
20:11:08 * Phyx- has never ever used parsec :/
20:11:39 * Phyx- has used applicative style parsers and never monadic parsers
20:14:42 <Phyx-> @pl liftIO $ print $ zipWith ($) [id,id] (repeat 3)
20:14:42 <lambdabot> liftIO (print (zipWith id [id, id] (repeat 3)))
20:14:51 <Phyx-> nothing changes
20:15:07 <FunctorSalad> fix is useful for cases other than a=b -> c isn't it :)
20:15:15 <Phyx-> @pl \x->liftIO $ print $ zipWith ($) [id,id] (repeat x)
20:15:15 <lambdabot> liftIO . print . zipWith id [id, id] . repeat
20:15:54 <FunctorSalad> fix (\self -> psl "Enter the foo." >> getLine >>= (\x -> if ok x then ... else self))
20:16:29 <Phyx-> what is psl?
20:16:37 <FunctorSalad> putStrLn ;)
20:16:42 <Phyx-> and ok?
20:16:43 <Phyx-> lol
20:17:00 <FunctorSalad> 'ok' would be something that checks whether the input is acceptable
20:17:06 <Phyx-> lol
20:19:13 <Phyx-> gawd, what happened... I used to hate haskell
20:19:28 <copumpkin> you got sucked in
20:19:31 <copumpkin> and will never escape
20:19:45 <Phyx-> :(
20:20:13 <Phyx-> first programming assignment for haskell was the first programming (and last) that I've ever failed
20:20:38 <aavogt> @type id id 3
20:20:39 <lambdabot> forall a. (Num a) => a
20:20:56 <Phyx-> but what did they expect when the first thing they tell you is "yeah... all those things you learned while learning imperative programming. forget it for now"
20:21:16 <Phyx-> that's like telly Yoggie bear to lay of the picnic baskets
20:21:24 <poljp> it's scary stuff being sucked in yeah. i write bad c# now !
20:21:50 <aavogt> @check \n -> zipWith ($) [id,id] (repeat n) == replicate 2 n
20:21:51 <lambdabot>   "OK, passed 500 tests."
20:21:53 <Phyx-> nah, my C# has improved alot because of it
20:22:06 <Phyx-> been using C# alot again thanks to LINQ
20:22:12 <Zeiris> Is there some straightforward guide to Parsec? I'm lost in the haddock docs.
20:22:26 <poljp> ah, well, I now want to write c# in a better way to match stuff from haskell. doesn't always work :P
20:22:34 <drhodes> Zeiris: there's a chapter in real world haskell
20:22:48 <poljp> so in my expression thingy, removing the view pattern of course the typechecker is happy once more (of course). is there a way i can make my view function happy on tuples :-)
20:23:06 <keseldude> after learning haskell, I've been using itertools and generators in python a lot
20:23:53 <copumpkin> after learning haskell, I've been using haskell a lot
20:24:00 <copumpkin> almost exclusively, whenever I can
20:24:11 <poljp> i spends hours at work using it each day:)
20:24:31 <poljp> (abusing it also included)
20:24:51 <Phyx-> I use haskell for anything that doesn't need a GUI
20:24:54 <Zeiris> After learning Haskell, I've decided programming as a job ain't for me, unless I can do it in Haskell. Or possibly Erlang. 
20:25:31 <Phyx-> After learning to program I've decided programming as a job ain't for me. sadly it's too late now
20:25:35 <Phyx-> @pl  createContext >>= \env -> (getModInfo env True False "VxsParser.T" "." >> getTooltip env "file" span)
20:25:35 <lambdabot> ap ((>>) . flip (flip (flip (flip getModInfo True) False) "VxsParser.T") ".") (flip (flip getTooltip "file") span) =<< createContext
20:25:41 <Phyx-> wow, no thanks
20:25:57 <poljp> lovely.
20:26:17 <roconnor> Zeiris: this is a common problem.  There was a -cafe thread recently on this topic
20:26:29 * p_l kinda locked himself into a CS career for now (unless he accepted a menial one) and he is very picky regarding languages, thanks to (first) Python/Ruby then Haskell&Lisp
20:26:37 <Zeiris> Yeah. Once you see what Haskell's like, you can't go back.
20:26:48 <aavogt> Phyx-: you could put env as the last argument (if you can redo those functions)
20:26:53 <Zeiris> Welcome to #haskell - YOU'LL NEVER LEAVE
20:27:27 <aavogt> then   liftM2 (>>) (getMod.. T F "") (getToolTip "file" span)
20:27:33 <dancor> leaving requires IO
20:27:39 <aavogt>   =<< createContext
20:27:49 <tolkad> Zeiris: well, until something better exists at least
20:28:13 <Phyx-> aavogt: ah. That could work. guess Now it's down to how badly do I want that, it would require me to change some C# code also
20:28:41 <Zeiris> tolkas, Oh definitely. Something with an excellent batch of libraries would be great. I want to look at C# soon, it looks like a compromise between Haskell and C++.
20:29:29 <Phyx-> p_l: yeah, a career in CS seemed fun at first, but after all the segfaults, sleepless nights bug hunting and little reward it sucks
20:29:32 <Phyx-> lol
20:30:16 <Phyx-> not to mention the deadlines and managers
20:30:18 <Zeiris> I don't mind the sleepless nights and seg faults. I'm worried about being at the bottom of the corporate ladder, forever. (Or until Indians finally replace me, due to working harder for much less.)
20:31:08 <p_l> Phyx-: actually, I wouldn't mind bug hunting, sleepless nights and segfaults. I would mind getting a stable job now instead of facing a failed second year in a 5y course :>
20:31:41 <Zeiris> p_l, yep, that's me as well. University is fun but dear god it's not helpful.
20:32:00 <Phyx-> Zeiris: they get fustrating :/
20:32:14 <p_l> unfortunately, all interesting courses start in 3rd year (4th year is industrial placement)
20:32:19 <FunctorSalad> careers in CS involve sleepless nights of bughunting segfaults?
20:32:45 <dancor> in OpenAL, shouldn't (unqueueBuffers :: Source -> [Buffer] -> IO ()) actually be (unqueueBuffers :: Source -> Int -> IO [Buffer])
20:32:46 <Phyx-> p_l: well, I'm almost at the end of my Uni career so I have atleast that
20:32:56 <dancor> it returns the n oldest unqueued buffers?
20:33:12 <dancor> i guess the haskell binding intends for you to track buffer chronology?
20:33:13 <Phyx-> FunctorSalad: that's what the brochure said
20:33:35 <FunctorSalad> not sure what you're saying is worse, programming for a corporation or the CS career
20:33:38 <FunctorSalad> *confused*
20:33:46 <dancor> seems like potential to create bugs?
20:33:47 <p_l> FunctorSalad: depends where. Baughn been suggesting to me to try getting into Google again, because there's a section where they actually want people interested in low-level details and crazily modified systems
20:34:15 <Zeiris> Is there a CharParser () Integer somewhere, or do I need to define one myself?
20:34:34 <FunctorSalad> p_l: doesn't sound bad
20:34:38 <Phyx-> FunctorSalad: both
20:34:53 <FunctorSalad> Zeiris: thought it was called 'integer' or so in parsec
20:35:04 <FunctorSalad> Phyx-: so, no way out?
20:35:24 <Phyx-> FunctorSalad: I suppose, in 50 years
20:35:24 <Zeiris> @hoogle integer
20:35:24 <lambdabot> Text.Parsec.Token integer :: GenTokenParser s u m -> ParsecT s u m Integer
20:35:25 <lambdabot> Text.PrettyPrint.HughesPJ integer :: Integer -> Doc
20:35:25 <lambdabot> Language.Haskell.TH.PprLib integer :: Integer -> Doc
20:35:42 <p_l> Well, I was thinking of doing a startup to get out :/
20:36:24 <p_l> I believe I have somehow usable concept, now it needs proper execution and seed money :/
20:36:32 <dancor> What Color Are Your Bootstraps
20:36:36 <FunctorSalad> but apparently you need a GenTokenParser first..
20:37:06 <Zeiris> Yeah, this looks made for parsing entire languages. I'm just going for a single string - np, rolling my own.
20:37:24 * Phyx- might just be a pessimist
20:37:46 <FunctorSalad> Zeiris: the haskell one would probably do ;)
20:37:46 <Phyx-> But my greatest fear is being stuck doing boring assignments all day
20:38:17 <Zeiris> Using that seems like it'd violate the principle of KISS in a major way :p
20:38:22 <p_l> Phyx-: imagine getting stuck writing *ugly* Java 5 assignments and failing a non-cs subject :)
20:38:23 <FunctorSalad> hehe
20:38:39 <FunctorSalad> (@Zeiris)
20:39:03 <aavogt> well isn't "it" your code and not the library, Zeiris?
20:39:32 <Phyx-> p_l: I've failed Philosophy. I honestly couldn't stay awake in that class
20:39:52 <Phyx-> and when I was reading the literature I thought it was the biggest crap of nonsense i've ever read
20:40:00 <Zeiris> Eh, this library seems to leak a bit too much information.
20:40:37 <p_l> Phyx-: sounds like my Knowledge of Mind Philosophy class in first year. OTOH, I have to fix my Adv. Psychology grades, Human Computer Interaction grade then do the light exam of Formal Logic :>
20:40:46 <FunctorSalad> Phyx-: then when the course is over you go read about philosophy on wikipedia for leisure
20:41:00 <Phyx-> FunctorSalad: hahah, exactly
20:41:08 <Phyx-> it's really weird
20:41:31 <Phyx-> p_l: HCI was also another boring one, first 5 lectures "This is a command button"
20:41:35 <Phyx-> "This is a modal form"
20:42:14 <p_l> Phyx-: my friend's short opinion on HCI - "These guys are really full of themselves. I'm on second fucking chapter and it's still droning about the importance of the subject!"
20:42:29 <Phyx-> FunctorSalad: then I tried studying the material. I still failed, because even though I had what was in the textbook, I didn't write it in my own words. In other words, I couldn't BS
20:42:41 <Phyx-> p_l: hehehe
20:43:11 <Phyx-> p_l: and all those stupid diagrams and reports. aarrgg
20:44:04 <Phyx-> I don't mean to insult anyone, but how can people who usually fail java 101 make a system diagram that the programmer is supposed to use? that doesn't seem logical
20:44:36 <dancor> Zeiris: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28703#a28703
20:45:46 <p_l> Phyx-: unless they failed Java 101 by sending the assesment in different language :P
20:45:49 <Zeiris> dancor, ...okay, I guess that's less leaky than I thought :) Still, I've made do with "read <$> many1 digits"
20:45:52 <dancor> even (emptyDef) works!
20:46:19 <Phyx-> p_l: lol
20:47:39 <Phyx->   (GHC version 6.13.20100713 for i386-unknown-mingw32):
20:47:40 <Phyx->         nameModule file{v asqy}
20:47:41 <Phyx-> :(
20:48:06 <p_l> Phyx-: I haven't done it personally though I happened to do some of the work in Clojure and tended to use weird comments or names in submitted code. Including a "How NOT to design programs" one :P
20:48:55 <dancor> Zeiris: this is probably irrelevant, but it's interesting that "+45" is accepted in emptyDef's and not yours; "-45" works in both!
20:49:09 <Zeiris> I'm parsing only naturals.
20:49:21 <Zeiris> ...Although the -45 is weird.
20:49:24 <Phyx-> p_l: I handed in an assignment once in full x86 ASM and SSE2 ASM, the teacher was not happy
20:49:28 <dancor> oh sorry
20:49:53 <dancor> "-45" works in (read), but - isn't digit.  anyway, ignore me
20:50:05 <Zeiris> Harassing teachers with excessive macros/goto statements in trivial assignments was one of the few joys of uni programming courses :)
20:51:01 <Makoryu> "-45" ought to be one token.
20:51:06 <dancor> i guess read's logic is that it only read-s things the way they would be show-n
20:51:15 <p_l> Zeiris: java unfortunately doesn't have goto. Otherwise I'd hand in assignments without subroutines
20:51:27 <Phyx-> Zeiris: and writing your comments in Joda speak :)
20:52:21 <FunctorSalad> (integer undefined) doesn't, sadly
20:52:24 <EvanCarroll> how come you can't `zipWith (:[]) [1..10]`
20:52:31 <Saizan> tsk, turing machines with several nodes and no structure, that's where the real fun is
20:52:34 <dolio> p_l: can you not break/continue to arbitrary labels? I forget.
20:52:35 <EvanCarroll> oh wait
20:52:37 <EvanCarroll> nvm map
20:52:47 <p_l> dolio: nope
20:52:52 <dolio> Oh well.
20:53:08 <p_l> there's a JVM goto *opcode*, but no way of writing goto directly in java
20:53:42 <FunctorSalad> I thought you can break/continue to labelled loops in scope
20:54:00 <FunctorSalad> just abuse that :p
20:54:45 <Phyx-> anyone know a better way to write http://phyx.pastebin.com/7ChUxcKp
20:55:24 <ski> s/(Just fs)/Just fs/
20:56:10 <Phyx-> ski: ?
20:56:27 <ski> @type on mplus
20:56:28 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> a1 -> a1 -> m a
20:57:14 <aavogt> what type is findName?
20:58:01 <Phyx-> findName     :: MonadPlus m => a -> FastString -> Maybe SrcSpan -> m Name
20:59:46 <ski>   nameTM = msum (map (findName fs (mkFastString name)) (Just span : [Nothing | strict]))  -- not sure how much better this is
21:00:02 <ski> (well, apart from the removal of code duplication, i.e.)
21:00:20 <ski> @type \f -> msum . map f
21:00:21 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
21:00:46 <aavogt> @type Data.Foldable.foldMap
21:00:47 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
21:00:52 <ski> @type \f -> join . liftM msum . mapM f
21:00:53 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m (m a)) -> [a1] -> m a
21:01:00 <Phyx-> hmmm
21:01:29 <Phyx-> ty ski 
21:01:56 <aavogt> the map might be nicer infix
21:02:12 <poljp> i think i have a fix for my view patterns problem :)
21:02:28 <aavogt>  nameTM = msum $ findName fs (mkFastString name) `map` (Just span : [Nothing | strict])
21:02:29 <ski> @type \f -> join . liftM (foldr (mplus . return) mzero) . mapM f
21:02:30 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
21:03:46 <ski> Phyx- : oops .. actually, s/strict/not strict/
21:03:59 <aavogt> @type \f -> join . foldr (mplus . f) mzero
21:04:00 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m (m a)) -> [a1] -> m a
21:04:13 <aavogt> @type \f -> foldr (mplus . f) mzero
21:04:14 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
21:04:33 * ski claps
21:05:39 <aavogt> @type flip foldr mzero . mplus
21:05:40 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, MonadPlus ((->) (m a))) => (m a -> m a) -> [m a -> m a] -> m a
21:05:54 <dolio> @type (msum .) . map
21:05:56 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
21:06:13 <aavogt> @type flip foldr mzero . (mplus .)
21:06:14 <lambdabot> forall a (m :: * -> *) a1. (MonadPlus m) => (a -> m a1) -> [a] -> m a1
21:07:19 <ski> (dolio : yeah .. what i started with :)
21:07:24 <dolio> Oh.
21:07:39 <dolio> So you did.
21:07:59 <dolio> You were just expanding via algebraic laws or something?
21:08:02 <ski> i was just pondering whehter there were any other nice way of expressing it
21:08:47 <ski> (i.e. it reminded my of `mapM', so i wanted to coerce `mapM' into doing the job)
21:09:21 <dolio> That probably won't be happening.
21:09:47 <ski> well .. at least it wasn't pretty
21:10:36 <aavogt> there's probably a   newtype MPlus_ a b = MPlus_ (a b); instance MonadPlus m => Monoid (MPlus_ (m a)) ?
21:11:19 <dolio> > ((msum .) . map) return [1..] :: [Int]
21:11:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:11:22 <dolio> > (\f -> join . liftM (foldr (mplus . return) mzero) . mapM f) return [1..] :: [Int]
21:11:24 <lambdabot>   *Exception: stack overflow
21:11:56 <ski> hm
21:12:08 <dolio> > (\f -> join . liftM (foldr (mplus . return) mzero) . mapM f) return [1..3] :: [Int]
21:12:10 <lambdabot>   [1,2,3]
21:12:15 <aavogt> > runReader (mapM return [1..]) ()
21:12:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:12:55 <dolio> mapM has issues with infinite lists in quite a few monads.
21:13:26 <Phyx-> :t liftIO
21:13:27 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
21:13:53 <Phyx-> :t liftIO (print "Internal:")
21:13:54 <lambdabot> forall (m :: * -> *). (MonadIO m) => m ()
21:14:21 <Phyx-> :t liftIO (print "Internal:") >> undefined
21:14:23 <lambdabot> forall (m :: * -> *) b. (MonadIO m) => m b
21:14:34 <Phyx-> wtf is GHC on about then
21:15:05 <aavogt> Phyx-: the two 'a' have to be equal
21:15:13 <aavogt> @type print undefined
21:15:14 <lambdabot> IO ()
21:15:51 <Martty> sorry for the ot, is it possible to attach to nohup'd process .. namely to have its output redirected to my shell/session again
21:15:58 <Phyx-> aavogt: ah, I missed that part
21:16:07 * Phyx- uses Debug.Trace instead
21:16:41 <jrockway> Martty: probably not possible
21:17:04 <Martty> :<
21:17:05 <ski> dolio : ah, i see (for some reason i first thought i was mixing up the two monadic levels in the `join' and `liftM' part) .. ty
21:18:02 <Phyx-> @hoogle Bool -> m a -> m a
21:18:03 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
21:18:03 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
21:18:03 <lambdabot> Data.Graph.Inductive.Internal.Queue queuePut :: a -> Queue a -> Queue a
21:18:14 <jrockway> Martty: if you wanted to write something that worked that way, though, you could take a look at my App.Persistent stuff: http://github.com/jrockway/app-persistent/tree/master/client/
21:18:18 <jrockway> (even written in haskell!)
21:18:33 <jrockway> the idea there is to support multiple terminal sessions from one app
21:18:34 <Phyx-> is there a more general unless?
21:18:39 <Phyx-> or when
21:18:39 <jrockway> not quite what you are doing, but close
21:18:45 <Martty> interesting
21:18:50 <Martty> a real world app in haskell
21:18:53 * Martty stares
21:19:13 <jrockway> i think it was like the first thing i ever wrote in haskell, so you may want to ignore various style issues ;)
21:19:13 <dolio> ski: That may actually be another problem.
21:19:37 <Martty> not bad, 3 gold stars 
21:19:44 <ski> dolio : well, afaics atm (i haven't slept), that shouldn't be a problem above
21:19:53 <dolio> > (\f -> join . liftM (foldr (mplus . return) mzero) . mapM f) (\x -> [x,x]) [1..3] :: [Int]
21:19:54 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
21:20:08 <dolio> > ((msum .) . map) (\x -> [x,x]) [1..3] :: [Int]
21:20:09 <lambdabot>   [1,1,2,2,3,3]
21:20:13 <Martty> jrockway it uses sockets.. ? 
21:20:21 <jrockway> yeah
21:20:33 <Martty> i assume .. some internal loopback ..?
21:20:57 <jrockway> yeah, the protocol is not raw text
21:21:05 <jrockway> there is some state that has to be communicated in each direction
21:21:12 <ski> ok, this is my cue to go to bed :)
21:21:15 <jrockway> like i said, it's not *exactly* what you want to do
21:21:57 <jrockway> on the server, i typically have an app running attached to a pty
21:22:19 <jrockway> then i "pump" the pty to/from the socket with a bit of translation
21:22:34 <jrockway> i have successfully run emacs inside it, so it does work :)
21:24:25 <jrockway> (regarding the code, not sure what is worse... my old style of 'case foo of Just/Nothing' or my new style of liftIO inside ErrorT IO ...)
21:29:09 <PetRat> Question about parsing: I'm learning Parsec, but my issue now is that my input should really be treated as tokens with different kinds of whitespace (meaningless whitespace, comments, meaningful newlines, etc.) -- my understanding is that Parsec does provide this, right?
21:31:46 <poljp> anyone for a bit of help on http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28704#a28704 ? I want g e to work...:/
21:32:43 <poljp> removing the name from v makes it compile :-/
21:34:05 <poljp> (added error msg)
21:42:54 <siracusa> poljp: What is `(name "a" "b" -> v) = e' supposed to mean?
21:47:06 <azaq23> PetRat: You can always use oneOf / manyOf etc to parse the requested characters, sequence the single parsers via monads and use <|> / the try function - so, yes
21:50:02 <poljp> Siracusa: the idea is the wrap the v node with a annotation tag.
21:52:00 <siracusa> poljp: I mean I don't understand the syntax, is that a view pattern or something similar?
21:52:16 <poljp> view pattern yes
21:52:29 <poljp> if i don't tuple up the value, it works and compiles OK
21:54:51 <poljp> afaik equivalent would also be: out =  Var "q" * 2* (f' (name "a" "b" v))
21:55:17 <poljp> but theni suppose that clearly shows why it doesnt work ! ha
21:59:22 <poljp> this sort of thing will work:     name a l (e1,e2) = (Ann a l e1,Ann a l e2)
22:01:33 <Phyx-> this is odd
22:01:44 <Phyx-> why can i only typecheck primitives
22:02:02 <Phyx-> even though my code is basically the same as HInt
22:09:00 <tkahn6> is there a standard function f such that
22:09:09 <tkahn6> f defaultVal x = maybe defaultVal id x
22:09:19 <tkahn6> ?
22:09:25 <dobblego> @type fromMaybe
22:09:26 <lambdabot> forall a. a -> Maybe a -> a
22:09:40 <Makoryu> @src fromMaybe
22:09:40 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
22:09:45 <tkahn6> cool
22:09:49 <tkahn6> thanks :)
22:13:32 <Phyx-> does hint typecheck expressions such as "fmap (+1)"
22:14:10 <aavogt> @type fmap(+1)
22:14:11 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
22:14:20 <aavogt> Phyx-: looks like it just did
22:14:23 <tkahn6> guess so
22:14:26 <Phyx-> lambdabot: uses hint?
22:15:36 <tkahn6> Hint the package?
22:15:47 <Phyx-> aavogt: doesn't that basically come down to typing "exprType "fmap (+1)"
22:16:17 <Phyx-> i'm getting back
22:16:18 <Phyx-> <interactive>:1:1: Not in scope: `fmap'
22:16:18 <Phyx-> <interactive>:1:7: Not in scope: `+'
22:16:21 <tkahn6> this might help you
22:16:22 <tkahn6> http://github.com/chrisdone/mueval-interactive
22:16:27 <tkahn6> read the readme
22:16:28 <aavogt> Phyx-: it uses mueval.. which in turn uses hint.. which in turn uses the ghc-api
22:16:32 <tkahn6> yeah
22:16:34 <tkahn6> so yes it does
22:16:42 <tkahn6> lambdabot uses hint i'm pretty sure
22:17:07 <Phyx-> what am i missing...
22:17:08 <Saizan> aavogt: @type doesn't use mueval, btw
22:17:52 <Phyx-> nothing is in-scope to this thing
22:18:02 <aavogt> Saizan: so types are allowed a bit more time to calculate?
22:18:58 <Saizan>  @type goes through ghci, there's still a timeout though
22:20:45 <Saizan> Phyx-: the equivalent of setTopLevelModules/setImportsQ/loadModules ?
22:21:00 <Phyx-> Saizan: my code is http://phyx.pastebin.com/8piS2Wwj
22:21:07 <Phyx-> it has everything loaded already
22:22:21 <Saizan> maybe loaded /= toplevel
22:22:35 <Saizan> that code doesn't explain much :)
22:22:41 <Phyx-> Saizan: i've taken a breeze through hint
22:22:56 <Phyx-> and it's basically just doing runGhc (extrType expr)
22:23:21 <Phyx-> and some error catching code. but I don't see why it works and my doesn't :/
22:23:45 <Phyx-> Saizan: well, Context is a cached ghc session
22:23:59 <Phyx-> it'll always contain atleast the prelude loaded
22:24:10 <Phyx-> pushSession restores it in the current context
22:25:14 <Phyx-> it'll give the type of say "1"
22:25:17 <Phyx-> or "'a'"
22:25:21 <Phyx-> but never a function
22:26:36 <Saizan> hint is using http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-6.12.2/InteractiveEval.html#v%3AsetContext
22:26:41 <Saizan> to set the modules in scope
22:27:40 <Saizan> are you sure it always contains the Prelude? that's not what i seem to recall.
22:28:31 <Phyx-> Saizan: well, Context will always contains something that TypeChecked, so prelude has to be in there
22:29:13 <solrize> is there a generic pretty printer for datatypes with Show?  the text.prettyprinter library just seems to be combinators for writing printers a type at a time
22:29:20 <solrize> plus its documentation is missing
22:29:29 <Saizan> Phyx-: seeing things like "runGhc2 GHC.setContext [] []" make me think it can be empty
22:30:25 <Phyx-> Saizan: all i see is "runGhc1 Compat.exprType expr"
22:30:47 <Phyx-> where "runGhc1 f a = runGhc (adjust f a)"
22:30:50 <Saizan> Phyx-: that line was from reset
22:32:46 <Phyx-> Saizan: even doing GHC.setContext [] [] didn't change anything
22:33:19 <Phyx-> the code for exprType doesn't seem to use the IC, it's also not mentioned that it needs it, like the other methods that do
22:36:43 <Phyx-> Saizan: well, Guess i'm wrong about that one.. it does use the IC, it calls hscTcExpr which uses it. documentation fail
22:42:52 <Saizan> the idea was that you need to setContext [predule] [] or something like that
22:44:33 <Phyx-> i've tried lookupModule (mkModuleName "Prelude") Nothing
22:44:36 <Phyx-> but that failed
22:44:48 <Phyx-> mkTopLevEnv: not a home module base:Prelude
22:45:22 <Phyx-> but, adding my own toplevel function works
22:45:29 <Phyx-> toplevel module*
22:45:53 <Phyx->                 m1 <- lookupModule main_name Nothing
22:45:53 <Phyx->                 GHC.setContext [m1] [(m1,Nothing)]
22:47:23 <Phyx-> has the added bonus of also working on every expression in scope of that module 
22:47:27 <Phyx-> which is great
22:48:39 <Phyx-> thanks Saizan 
23:01:00 <Saizan> np
23:03:35 <dancor> can this recursion be made non-explicit:
23:03:37 <dancor> sqncWhileTrue :: (Monad m) => [m Bool] -> m ()
23:03:38 <dancor> sqncWhileTrue [] = return ()
23:03:38 <dancor> sqncWhileTrue (m:ms) = m >>= \ r -> when r (sqncWhileTrue ms)
23:04:45 <Saizan> foldr (\m rec -> m >>= \ r -> when r rec) (return ())
23:05:12 <Saizan> ?pl foldr (\m rec -> m >>= \ r -> when r rec) (return ())
23:05:12 <lambdabot> foldr ((. flip when) . (>>=)) (return ())
23:05:25 <dancor> ah
23:12:07 <aavogt> :t \xs -> flip runContT return $ callCC $ \escape -> sequence_ (map (\x -> do x <- ContT (\k -> k x); if x then escape () else return ())  xs)
23:12:08 <lambdabot> forall (m :: * -> *). (Monad m) => [Bool] -> m ()
23:12:57 <aavogt> :t \xs -> flip runContT return $ callCC $ \escape -> sequence_ (map (\x -> do x <- ContT (\k -> k =<< x); if x then escape () else return ())  xs)
23:12:59 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m ()
23:13:35 <aavogt> I guess that one could use 'when' too
23:14:35 * dancor still hasn't actively used CPS
23:15:03 <Saizan> you got it backwards..
23:15:12 <aavogt> that's quite possible
23:15:27 <aavogt> oh, quit when false
23:15:49 <Saizan> :t \xs -> flip runContT return $ sequence_ (map (\m -> ContT $ \k -> m >>= \r -> if r then k () else return ()) xs)
23:15:50 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m ()
23:16:09 * Saizan prefers abort over callCC $ \escape -> ..
23:17:24 <codolio> callCC kind of sucks.
23:18:40 <Saizan> i hear that a lot :)
23:22:54 <aavogt> > let untilM = \xs -> flip runContT return $ sequence_ (map (\m -> ContT $ \k -> m >>= \r -> when r (k ())) xs) in untilM (repeat [True])
23:22:56 <lambdabot>   *Exception: stack overflow
23:23:49 <aavogt> > let untilM = foldr (\m rec -> m >>= \ r -> when r rec) (return ()) in untilM (repeat [True])
23:23:50 <lambdabot>   *Exception: stack overflow
23:24:15 <aavogt> > let untilM = foldr (\m rec -> m >>= \ r -> when r rec) (return ()) in untilM (repeat [False])
23:24:16 <lambdabot>   [()]
23:25:36 <aavogt> > let untilM = \xs -> flip runContT return $ callCC $ \escape -> sequence_ (map (\x -> do x <- ContT (\k -> k =<< x); when x (escape ()))  xs) in untilM (repeat [False])
23:25:40 <lambdabot>   mueval-core: Time limit exceeded
23:25:46 <aavogt> > let untilM = \xs -> flip runContT return $ callCC $ \escape -> sequence_ (map (\x -> do x <- ContT (\k -> k =<< x); when x (escape ()))  xs) in untilM (repeat [True])
23:25:50 <lambdabot>   mueval-core: Time limit exceeded
23:26:19 <aavogt> Saizan: apparently the ContT usages are incorrect?
23:31:02 <aavogt> > let f xs =  flip runContT return $ callCC $ \escape -> sequence_ (map (\x -> ContT (\k -> x >>= k) >>= flip when (escape ()))  xs) in f (repeat [True])
23:31:04 <lambdabot>   [()]
23:33:22 <bobzhangatthu> has anyone tried wxHaskell on Mac. I got such error messages [Debug] 14:32:09: Adding duplicate image handler for 'PNG file'
23:33:23 <bobzhangatthu> [Debug] 14:32:09: Adding duplicate image handler for 'JPEG file'
23:33:23 <bobzhangatthu> [Debug] 14:32:09: Adding duplicate image handler for 'TIFF file'
23:33:23 <bobzhangatthu> [Debug] 14:32:09: Adding duplicate image handler for 'GIF file'
23:33:26 <bobzhangatthu> [Debug] 14:32:09: Adding duplicate image handler for 'PNM file'
23:33:56 <bobzhangatthu> Many Thanks
23:35:46 <Phyx-> is there a way to, with SYB find a value, and once it's found, return whatever structure that type was in as a whole
23:38:00 <Saizan> the surrounding node you mean?
23:38:20 <Saizan> like looking for 2 in [1..3] should return [2,3] ?
23:38:21 <Phyx-> yeah
23:38:25 <Phyx-> no
23:38:26 <Phyx-> well
23:38:35 <aavogt> one level up?
23:38:46 <Phyx-> looking for 2 in [1..3] it should return [1..3]
23:39:04 <aavogt> so finding the Int in   ('a',1) within the whole thing, gives you that tuple?
23:39:06 <Phyx-> a better example, lookings for 2 in [[1],[2..3],[5]] returns [2]
23:39:08 <Phyx-> err
23:39:09 <Phyx-> [2..3]
23:39:16 <Phyx-> aavogt: right
23:39:39 <Saizan> [2..3] is no more a single structure than [[1],[2..3],[5]] is, though
23:39:39 <aavogt> @hoogle something
23:39:40 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
23:40:20 <Phyx-> Saizan: well, I meant the "parent" of the element that's found if that makes sense
23:40:35 <Phyx-> hmm never used something, i'll give it a shot
23:41:38 <Saizan> i thought you meant parent, and (2:3:[]) is taking the parent when looking into 1:2:3:[]
23:42:18 <aavogt> I don't think something is right
23:42:36 <Phyx-> Saizan: no no, the idea is, to, search in the entire typechecked ast for a specific Name. once that's found. return whatever structure you found it in, since that would contain information about the binding
23:45:02 <Phyx-> aavogt: I remember previously doing something like this with a combination of everywhere and gmapQ
23:45:08 <Phyx-> don't remember how though
23:49:20 <Phyx-> think i;ll go to bed
23:49:22 <Phyx-> @time
23:49:25 <lambdabot> Local time for Phyx- is Sun Aug  8 08:48:57 2010
