00:15:21 <lpsmith> So I'm trying to compile 6.13.20100817,  and I get an error (fairly early on):  cannot satisfy -package base-4.1.0.0
00:22:31 <lpsmith> oh, n/m
00:22:52 <lpsmith> I hadn't built ghc from source recently,  and didn't "perl boot"
00:41:46 <int80_h> :t getDirectoryContents
00:41:47 <lambdabot> Not in scope: `getDirectoryContents'
00:41:58 <int80_h> @hoogle getDirectoryContents
00:41:58 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
00:42:17 <int80_h> :t System.Directory.getDirectoryContents
00:42:19 <lambdabot> FilePath -> IO [FilePath]
00:42:54 <int80_h> I'm going to post three lines of code here, for discussion
00:43:18 <int80_h> let d = "/home/michael/blog/entries/"
00:43:18 <int80_h> >                   processPaths = map (d </>) . filter (`notElem` [".",".."])
00:43:18 <int80_h> >               entryFileName <- processPaths <$> getDirectoryContents d
00:43:19 <lambdabot>   not an expression: `entryFileName <- processPaths <$> getDirectoryContents d'
00:43:19 <lambdabot>   <no location info>: parse error on input `='
00:43:55 <int80_h> I'd like to discuss <$>, RWH says it is shorthand for fmap
00:44:19 <int80_h> but I don't see the functor being lifted into
00:44:21 <Associat0r> int80_h: LYAH explains it
00:44:46 <int80_h>  Associat0r: ah good. I like LYAH.
00:45:12 <Associat0r> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
00:46:30 <xuxc000> "Hugs> let fac 0 = 1", I get a error "ERROR - Syntax error in expression (unexpected end of input)"
00:46:42 <xuxc000> why I get this error
00:47:05 <xuxc000> is there anything wrong with "Hugs> let fac 0 = 1" ?
00:47:19 <xuxc000> I use winhugs
00:47:29 <int80_h> what are you trying to say?
00:48:11 <xuxc000> I want to define a function fac
00:48:29 <xuxc000> but I get a error for "Hugs> let fac 0 = 1" this sentence
00:48:33 <int80_h> function definitions don't begin with let
00:48:41 <xuxc000> ooh
00:49:00 <xuxc000> How can I define a function in interpret mode ?
00:49:00 <int80_h> no worries, have you looked at Learn You A Haskell?
00:49:08 <int80_h> I don't think you can
00:49:11 <xuxc000> yes
00:49:20 <int80_h> I think you have to write a file then load the file into the interpreter
00:49:41 <int80_h> is there a reason you are using hugs over ghci? I find ghci to be better.
00:50:08 <xuxc000> ooh
00:50:32 <xuxc000> but ghci don't have a easy windows release
00:50:42 <int80_h> fair enough :)
00:51:25 <xuxc000> :)
00:51:39 <xuxc000> do you use ghci in windows ?
00:51:45 <int80_h> no
00:52:04 <int80_h> I use variations of *nix.
00:52:18 <int80_h> debian mostly these days. netbsd pkgsrc is wanting.
00:52:41 <xuxc000> ok, I can try it in my home ubuntu computer
00:52:57 <xuxc000> office computer only have windows
00:53:43 <int80_h> yeah if you can connect from the outside to your home computer, then you can use it from work maybe
00:54:02 <int80_h> that's what I do. Run a server, then I connect from anywhere
00:59:21 <int80_h> good night everyone. I had another haskell breakthrough today. session_ and session.
01:03:33 <kyagrd> Ïã†Í∏∞Ïà† ÎèôÌñ•Ïù¥ CD Î°¨ ...
01:03:49 <kyagrd> sorry wrong channel :(
01:09:08 <ksf_> We present an elegant proof that this paper is finite, but this paper is too short to contain it.
01:09:34 <aRcatan> oh, that's clever
02:12:08 <ivanm> preflex: seen chrisdone
02:12:08 <preflex>  chrisdone was last seen on #haskell 11 hours, 54 minutes and 24 seconds ago, saying: point it to another channel next time :p
02:12:45 <ivanm> @tell chrisdone I believe John Meacham doesn't like Cabal/Hackage (which is why gwern, etc. package some of his stuff like drift)
02:12:46 <lambdabot> Consider it noted.
02:13:27 <Zao> Oh joy, I think I found a bug in Data.Text.IO.readFile last night.
02:13:40 <Zao> Time to dig out who the maintainer is.
02:13:52 <ivanm> bos ?
02:13:58 <ivanm> if that's part of text...
02:14:07 <Zao> It's part of the text package, yes.
02:14:18 <ivanm> then bos
02:14:21 <ivanm> preflex: seen bos
02:14:22 <preflex>  bos was last seen on #haskell 2 days, 2 hours, 34 minutes and 14 seconds ago, saying: ivanm: i am wondering whether to add locale support first
02:14:39 <Zao> I've got to set up a self-contained test-case first though.
02:15:12 <ivanm> I've found that bos will accept patches and apply them... eventually :p
02:15:40 <Zao> I was reading a smallish file (420-some bytes) and the first 2/3 of the result was the last third, scrambled.
02:16:50 <Zao> By the way, if I'm in a directory with a .cabal file, can I instruct cabal-install to install any missing dependencies?
02:17:08 <Zao> I expect that cabal install in the directory will do it, but I don't want to install the package I'm working on.
02:17:28 <ivanm> no
02:17:40 <ivanm> unfortunately, that'd be a nice feature
02:18:53 <Saizan> ^C and a bit of skill.. but it shouldn't be hard to add a --deps-only flag
02:20:05 <ivanm> Saizan: heh (to your "bit of skill")
02:20:17 <Zao> Saizan: It's a bit annoying having to sift out the core and HP packages though.
02:20:48 <Saizan> Zao: what do you mean?
02:21:34 <Saizan> if you "cabal install" in a directory with a .cabal file it'll try to install the package and the missing deps, also trying to reuse installed packages
02:21:39 <ivanm> dobblego: I'll pass on joining facebook just to view your photos, thanks
02:21:50 <Saizan> (the solver is not complete though)
02:21:53 * ivanm wonders where dobblego got his email address from to use that particular variant
02:22:41 <ivanm> Saizan: grrrr for it rebuilding deps that are already installed if it doesn't like how you installed them though :@
02:22:51 <dabblego> ivanm, sorry that was an accident
02:22:51 * ivanm stares at pandoc's open-ended parsec dep
02:22:57 <Axman6> anyone know if Tom Hawkins hangs around in here?
02:22:59 <Zao> Saizan: Yeah, but if I don't want to install, I've got to dig through my deps list in the .cabal and find what packages I need to install.
02:22:59 <ivanm> dobblego: it better be... ;-)
02:23:06 <ivanm> Axman6: not sure; I think I"ve asked that in the past myself
02:23:26 <Axman6> i'd like to ask about ImProve :(
02:23:27 <Zao> (the reason I don't want to install is because I don't know/have time to grok the installation bits of Cabal, nor know where it should install to).
02:23:55 <Zao> I've deployed it to the right server now, and handed off the source to IT, so my work is done.
02:23:56 <ivanm> Axman6: email? :p
02:23:59 <Zao> Hopefully.
02:24:11 <Axman6> seems to use an interesting style: all variables used in a function are actually put into a struct external to the instruction, wondering what the reasoning is
02:24:50 <fasta> Axman6, what kind of instruction?
02:24:50 <Saizan> Zao: yeah, you need the --deps-only flag for something that works properly
02:25:03 <Axman6> fasta: hmm?
02:25:15 <Axman6> a C function produced by ImProve
02:26:09 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29216#a29216
02:26:15 <fasta> Axman6, it might be close to the internal format used by ImProve with no fundamental reason for it being like that.
02:27:23 <fasta> Axman6,or it is intended to be used with hardware, of course.
02:27:46 <Axman6> yeah, that's the aim of the laqnguage i think
02:45:59 <osfameron> ooo, Divvy.app on osx looks like it does something xmonad'y only manually, with an annoying interface
02:46:18 <osfameron> but perhaps xmonad could target the same API to work natively with osx windows...
02:47:05 <Axman6> i have a feeling that would be extremely difficult
02:49:25 <ivanm> especially with all the random algorithms xmonad uses
02:51:41 <aRcatan> you could do it with Windows windows, too. you just need the ability to position the windows.
02:51:44 <Axman6> my main point is that OS X doesn't use X11, which XMonad is basically exclusively aimed at
02:59:55 <kamatsu> hi
03:00:05 <kamatsu> i'm looking for a haskell function roughly equivalent to the unix "find" command
03:00:24 <kamatsu> i.e gives me a list of FilePaths which is every file in the directory tree below the current directory.
03:00:38 <kamatsu> with an appropriately qualified path
03:01:17 <zygoloid> Axman6: that style of writing functions would make it very easy to create closures. maybe that's why?
03:01:39 <Axman6> possibly. that's a good point
03:01:49 <zygoloid> kamatsu: there was something on reddit about exactly that problem a while back iirc
03:01:52 <Axman6> though, it does mean you can only ever use that function in one place no?
03:02:55 <zygoloid> in order for it to be useful, you'd need to pass in a pointer to gcdVariables rather than having them be global
03:02:59 <Baughn> Anyone used Orc? I feel like I want a tutorial, or at least documentation, but a hint that it's useful would do.
03:03:44 <Znudzon> Yesterday i've instaled WxGtk on my lap and WxHaskell ... today Ubuntu don't see them... why?
03:03:57 <zygoloid> Axman6: maybe they're just trying to turn C into a non-turing-complete language. :)
03:04:10 <Axman6> hooray!
03:04:34 <Baughn> Znudzon: What did you do in-between? What makes you think it doesn't see them? And how did you install them?
03:05:30 <Baughn> "signal :: Orc (); signal = return ()" <-- What? I don't even..
03:06:21 <Axman6> Baughn: makes sense to me, what's the problem with that? :P
03:06:37 <Znudzon> I made a few programs between. I can't compile  program with wx now. Cabal say that he don't have wxHaskel instaled. When i try to reinstal this he said that i dont't have wxgtk instaled
03:06:48 <Baughn> Axman6: That "signal" clearly indicates a side-effect of some kind, and return () is pretty much required to have none?
03:06:53 <mux> Igloo: thank you so much for closing #698 :-)
03:08:36 <Baughn> It was that, or get spammed by someone trying to avoid spam. Closing the ticket was /clearly/ the easier option. :P
03:08:57 <mux> I should have said "fixing", not "closing"
03:11:36 <Zao> Znudzon: Maybe you installed them as user and you forgot to provide --user now?
03:12:07 <Baughn> Znudzon: You might perhaps try to answer my questions. It'd help.
03:15:16 <ivanm> kamatsu: there's a globbing library IIRC
03:15:41 <ivanm> (which is so-so last I checked it)
03:16:05 <aRcatan> kamatsu: there's also the FileManip package, which is supposed to have find-like abilities
03:16:32 <ivanm> about to say that ;-)
03:16:37 <Baughn> Znudzon: If you're getting "libstdc++.so not found" type errors, you have bigger problems than just a haskell messup.
03:16:44 <ivanm> there's also FindManipCompat which I'm assuming is OS-agnostic
03:17:14 <ivanm> and there's Unixutils, but it doesn't seem to work with latest parallel
03:17:25 <Znudzon> Baughn: I've answered them :) I've instaled wxGTK form the web(step by step from wxGTK instruction ) after this  i install wx from cabal 
03:17:36 <Fractal2> show 2
03:17:44 <aRcatan> then again, if all you want is a recursive file listing, I guess it wouldn't be too hard to write one using System.Directory
03:17:44 <Baughn> Znudzon: Right, and what makes you think it's not working? Copy and paste, please.
03:17:59 <Zao> Baughn: Onto a pastesite, that is.
03:18:01 <ivanm> aRcatan: isn't there also a directory-listing library or something?
03:18:12 <ivanm> IIRC the maintainer released a new version after the du question on reddit
03:18:13 <Baughn> Zao: Oh dear, yes.
03:18:24 <ivanm> directory-tree <== that's what I meant
03:19:11 <anair_84`> newbie q > is there some thing apart from cabal install 'parsec >= 3', i need to be able to import Parsec
03:19:16 <Znudzon> Baughn: Now its working ...after rebuild wxGtk . I am sorry for problem . But what with libstdc++? 
03:19:38 <anair_84`> i keep getting     Could not find module `Parsec':
03:19:48 <ivanm> anair_84`: parsec is the package name, not the module name
03:20:06 <ivanm> anair_84`: it's Text.Parsec
03:20:08 <Baughn> Znudzon: You're the one who mentioned it.
03:20:14 <ivanm> or Text.ParserCombinators
03:20:55 <anair_84`> huh, I guess I was looking at some older tutorial
03:21:19 <ivanm> must have been parsec-1.x or something to be just "Parsec" :s
03:21:31 <anair_84`> k thanks
03:22:03 <ivanm> Text.Parsec is the newer interface
03:22:15 <anair_84`> yup it works 
03:23:15 <dh__> Hi, I have a problem when using the arrow syntax
03:23:44 <dh__> hit = proc (x,y) -> do  b <- edgeTag x -< (x>400) 
03:24:16 <dh__> I got an error message : Not in scope 'x'
03:24:26 <Cale> dh__: You're not allowed to make the arrow being described depend on the input of that arrow.
03:24:27 <dh__> the x in (edgeTag x) is not in scope . 
03:24:31 <Cale> Right.
03:24:32 <Cale> It's not.
03:24:52 <Cale> Because it's one of the inputs to the arrow computation, not a parameter to hit
03:24:55 <ivanm> hey Cale 
03:24:58 <Cale> ivanm: hey
03:25:11 <dh__> I need to return the x, y 
03:25:15 <ivanm> Cale: did you see my Graph proposal that I sent to libraries@ a couple of weeks ago?
03:25:33 <Cale> ivanm: No, I didn't. I could have a quick look if you'd like.
03:26:07 <Cale> I haven't been following any of the mailing lists really closely for years, though they still pile into my gmail account.
03:26:11 <ivanm> well, all it was was I was asking about the feasibility of having a new top-level Graph.* module namespace
03:26:35 <ivanm> with the intention of then having inductive-graphs use that, and FGL then be a wrapper on top of inductive-graphs having something similar to the current API
03:26:39 <Cale> "New FGL" naming survey ?
03:26:46 <ivanm> newer then that ;-)
03:26:59 <Cale> ah, found it
03:27:28 <ivanm> this came out of a discussion edwardk and I had about how to resolve the inductive-graphs/fgl dilemma (to keep platformists happy)
03:27:57 <Cale> I don't mind Graph.*
03:27:57 <ivanm> dons didn't like the new namespace idea, but said it should go to the library@ mailing list for approval; all of 4 people responded :s
03:28:12 <ivanm> good-o
03:28:20 <ivanm> I found Iavor's reply rather... strange :s
03:28:26 <Cale> But I might be weird. I started programming in Haskell before the hierarchical modules existed, and they all still seem a bit long to me.
03:28:30 <ivanm> heh
03:32:52 <dh__> Cale: if I need to return x in the edge event , how can I do it? 
03:32:56 <Cale> Control.Data.Miscellaneous
03:33:19 <Cale> dh__: You're using Yampa?
03:33:24 <dh__> Cale: yes.
03:33:51 <dh__> basically, I'm using Yampa, and try to write a small game, 
03:34:06 <dh__> I have a ball, at beginning, it run at right , when hit right wall, it runs left.
03:34:31 <dh__> so x> 400 if it hit the wall. 
03:34:57 <dh__> then it move from the current position to the left.
03:36:26 <Cale> Right, so you maybe want something like  proc (x,y) -> do e <- edge -< (x > 400); returnA -< tag e x
03:36:36 <Cale> (not sure what purpose y serves)
03:37:12 <dh__> Cale: thanks , I'll try :)
03:37:22 <Cale> Oh, since it's the ball position, you're just ignoring it, I see.
03:38:24 <dh__> Cale: it works , thanks !!
03:42:44 <Cale> dh__: great :)
04:05:45 <Zao> Could someone test this code and see if the output is equivalent to the file contents? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29217#a29217
04:06:21 <Zao> It fails on Windows with HP 2010.2.0.0 (GHC 6.12.3) and text-0.7.2.1
04:07:17 <ivanm> Zao: you probably want putStrLn, not print
04:07:34 <ivanm> print = putStrLn . show
04:08:45 <ivanm> no, wait, I lie
04:08:57 <ivanm> Zao: anyway, I get "module Main where\nimport Data.Text\nimport qualified Data.Text.IO as TextIO\n\nmain = do\n\tcontents <- TextIO.readFile \"Foo.hs\"\n\tprint contents\n\n"
04:09:00 <ivanm> (including quotes)
04:09:04 <ivanm> note that tabs are evil... ;-)
04:09:28 <Zao> "\n\tprint contents\nimport Data.Text\nimport qualified Data.Text.IO as TextIO\n\nmain = do\n\tcontents <- TextIO.readFile \"Foo.hs\"\n\tprint contents\n"
04:09:40 <Zao> With longer files, it becomes more and more garbled.
04:10:07 <Znudzon> Anyone have haskell on ubuntu ? 
04:10:21 <fryguybob> Zao: I get the same failure as you.
04:10:59 <Axman6> Znudzon: haskell? not GHC?
04:11:25 <Zao> fryguybob: On what platform?
04:12:06 <fryguybob> Zao: Exactly the same as you..
04:12:38 <Zao> Windows, same HP?
04:12:47 <fryguybob> Yeah
04:13:01 <Znudzon> Axmand: GHC
04:13:24 <somnium> Znudzon: I do
04:13:52 <Znudzon> somnium: Do you use wx ?
04:14:26 <somnium> Znudzon: I havent used wx with haskell but I have some wx apps installed
04:16:20 <Znudzon> somnium: wxcore on ubuntu can't find libstdc++ :( And i can't find any solusion)
04:17:07 <Znudzon> somnium: i have : Loading package wxcore-0.12.1.6 ... <command line>: can't load .so/.DLL for: stdc++ (libstdc++.so: cannot open shared object file: No such file or directory)
04:17:08 <Znudzon>     I have libsdc++
04:19:09 <somnium> Znudzon: I'll mention that I have haskell installed in /home, and built from source
04:19:49 <quicksilver> Znudzon: possibly you don't have the stdc++ dev package
04:19:58 <quicksilver> which is probably the thing that contains libstdc++.so
04:20:08 <quicksilver> oh, GHCi?
04:20:15 <quicksilver> you probably can't use WX from GHCi
04:20:21 <somnium> had numerous problems with the various available binaries, checking wxAsteroids now
04:20:23 <quicksilver> does a small compiled program work?
04:20:34 <Znudzon> quicksilver: i have dev instaled from ubuntu repository 
04:22:03 <somnium> well, wxAsteroids seems to work assuming its woefully incomplete (just picked a random wx app)
04:27:26 <quicksilver> Znudzon: have you tried compiling something.
04:27:39 <quicksilver> I believe what you're seeing there is an ld-script, which means it can't work in ghci
04:27:49 <quicksilver> I don' thtink that's a big loss because I don't think wx really works from ghci anyway
04:28:34 <Znudzon> quicksilver: then i must instal qt ?
04:29:00 <quicksilver> I doubt that will fix it.
04:29:10 <quicksilver> I think you will find none of the GUI libraries work in ghci
04:29:16 <quicksilver> can you confirm whether a compiled program works?
04:29:22 <quicksilver> I might be wrong, I"m just giving a theory.
04:30:24 <Cale> GUI libraries are so poor at handling threads in general. Someone should write something proper in Haskell from the ground up.
04:30:39 <Cale> It's just so much work.
04:31:00 <fryguybob> Zao: Looking at the source for Data.Text.IO if I use the hGetContents definition for <= 610 it seems to work for me: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29217#a29218
04:31:29 <RichardBarrell> Don't all GUI libraries just assume that there's a single thread that talks to the GUI library, and any other threads that might exist in your program are your own concern?
04:31:45 <Zao> fryguybob: That was basically my workaround, self-reinvented.
04:32:14 <Zao> RichardBarrell: You start getting into trouble when you want to affect widgets from other threads, or want to control flow in the main thread.
04:32:15 <Znudzon> quicksilver: i dont understand ..what i must to do ? 
04:32:21 <Zao> Not to mention gluing threads together.
04:32:24 <Cale> RichardBarrell: Yes, by completely failing to be threadsafe in any way.
04:32:31 <Zao> Especially with finalizers being guaranteed to run in non-main threads :D
04:32:33 <fryguybob> Zao: I couldn't find any tickets on trac for it, but you should add it.
04:32:47 <Zao> fryguybob: I mailed bos@, let's see if something interesting happens.
04:33:01 <fryguybob> Zao: ok
04:33:08 <Botje> RichardBarrell: i think the android workaround is rather nice
04:33:23 <Botje> you send a closure over which is executed in the UI thread if you want to change something
04:33:29 <Cale> (Probably because nobody writing imperative programs uses multiple threads all that much, despite the fact that concurrency is a natural abstraction to want to use while programming guis.)
04:33:32 <Botje> that or you use message passing to influence the gui thread
04:34:00 <Zao> Botje: Even more fun happens when you combine multiple kinds of message loops in the same app.
04:34:03 <Zao> In any language.
04:34:52 <Botje> Zao: POE (a perl asynchronous library) can interface with other message loops
04:35:01 <Botje> so if they can do it, everyone can :P
04:35:35 <Zao> Botje: I doubt they do much of a good job with mine.
04:35:59 <quicksilver> Znudzon: you don't understand how to compile a haskell program?
04:39:00 <Znudzon> quicksilver: no i need good working gui for haskell. I've tryed with wx but i have problem with libstdc++ 
04:40:18 <somnium> Znudzon: what did you do to get the libstdc++ error?
04:40:31 <Znudzon> quicksilver: i found information that whis is fault of ubuntu...but i can't find any solution
04:40:57 <ivanm> Zao: well, no garbling here
04:41:03 <ivanm> (with your code from before)
04:41:04 <Znudzon> somnium: i write ghci -package wx :) to test wxhaskell
04:41:17 <ivanm> but I'm guessing TextIO.putStrLn (or whatever it calls it) would be a better bet
04:41:57 <quicksilver> Znudzon: I'm telling you that I think it does not work in ghci.
04:42:07 <quicksilver> Znudzon: I'm asking you to try compiling a program, to confirm my theory.
04:42:17 <somnium> Znudzon: ah ok, I get that too. but, see quicksilver's statements :)
04:42:27 <quicksilver> Znudzon: You are refusing. And this ends my attempt to help you. Sorry. Someone else in this channel will hopefully give you another chance.
04:43:53 <Znudzon> quicksilver: sorry but i dont  saw you message with ghci :) How i can compile it?
04:44:22 <fryguybob> ivanm: TextIO.putStrLn makes the output "look better", but it is still just as incorrect.
04:46:32 <ivanm> how is it incorrect?
04:47:01 <fryguybob> The last bit has overwritten the beginning.
04:47:07 <Saizan> Znudzon: "ghc --make test.hs" where test.hs has to contain a program that uses wx, i guess you can find a demo somewhere
04:47:35 <ivanm> fryguybob: huh, works fine here...
04:54:20 <Znudzon> quicksilver:  It works! you have right it was ghci fault. 
04:55:41 <Znudzon> why i have only "H" from "HelloWorld" . This is my code:  f <- frame [text := "Hello World!"]
04:55:41 <Znudzon>   staticText f [text := "Hello StaticText!"]
05:04:25 <Zao> ivanm: The printing is not at fault, the Text itself is broken.
05:04:37 <quicksilver> Znudzon: Hmm. I remember that bug.
05:05:18 <quicksilver> IIRC it indicates you compiled WX 'wrong' in some way
05:05:55 <quicksilver> Znudzon: "I only see the first letter of every word
05:05:56 <quicksilver> Solution build wxWidgets with "
05:06:03 <quicksilver> --enable-unicode"
05:06:06 <quicksilver> (sorry, clumsy paste)
05:06:12 <quicksilver> it's from here : http://www.haskell.org/haskellwiki/WxHaskell/Troubleshooting
05:06:14 <Znudzon> quicksilver: ok i will do that. Thank you
05:06:49 <quicksilver> np
05:09:33 <tibbe> The internals of the container package really need to be rewritten, lots of inefficiently defined folds for example.
05:11:36 <Gracenotes> and needs new functions
05:19:56 <tibbe> Gracenotes, so I'm adding a strict fold
05:20:34 <tibbe> Gracenotes, so of the functions that are missing are so obvious that I can't help but to wonder if anyone ever used these data types to do anything but inserts, lookups, and deletes
05:30:23 <Gracenotes> tibbe: I saw, on the libraries mailing list. what I'm thinking might be useful is unioning two maps with different key types
05:31:35 <Gracenotes> I've needed it a few times. I've seen other folks mention it too.. oh, and who could forget enumerating the elements in reverse order
05:32:55 <Gracenotes> alternatively I could find a pure data structure more suited for database-y use, but there aren't any of them on Hackage really..
05:34:40 <dankna> double-alternatively, you could use a real database
05:34:47 <dankna> allow me to plug my direct-sqlite package
05:35:09 <dankna> but I don't know what you're doing (it wasn't in the past few pages of scrollback), so that may not be a good solution
05:36:17 <Gracenotes> it's for use with happstack-state, for which native haskell types are much more expressive than databases 95% of the time, but not always..
05:36:34 <Gracenotes> sqlite is a great thing though
05:36:47 <tibbe> Gracenotes, I'm doing some large scale in-memory processing using Data.Map at the moment, with a few million key/value pairs. So a DB isn't quite right for me.
05:36:58 <dankna> fair enough
05:37:14 <tibbe> but I'm happy we have sqlite bindings, it's really niffty
05:37:18 <dankna> me too
05:37:24 <dankna> we have many sqlite bindings in fact, haha
05:37:57 <dankna> mine is the best, of course, even while I'm waiting to fix this build-system issue with it, but for people who don't agree there are alternatives :D
05:38:10 <tibbe> dankna, you're package could use some documentation :)
05:38:19 <dankna> oh you've seen it?  yeah, you're probably right
05:38:32 <dankna> I figured since it was such a thin layer... but really, it could
05:38:35 <tibbe> dankna, and an example (open db, run some insert, run some select, close)
05:38:45 <Gracenotes> tibbe: I wonder sometimes if Map should just expose its constructors
05:38:56 <dankna> yeah.  well, my own usage of it is a fairly large app is the thing, so I can't just excerpt from that to make an example
05:39:03 <tibbe> dankna, also, the bindXXX things might not be immediately obvious to everyone
05:39:04 <dankna> but I'll be revisiting it for regular maintenance sometime soon
05:39:11 <Gracenotes> and the rest of the Bin/Tip gang
05:39:14 <dankna> what about them might not be?
05:39:17 <tibbe> Gracenotes, perhaps in Data.Map.Internal
05:39:19 <dankna> it's good to know you've looked at it, by the way
05:39:48 <tibbe> Gracenotes, but I think we could cover all needs without doing that, it's just that the current API is very lacking
05:40:11 <tibbe> Gracenotes, a zip function could provide lock-step iteration over different key types
05:40:37 <dankna> you're absolutely right about the docs...  at first I wasn't sure the community would see it as valuable, so I wasn't sure I wanted to go to the effort.  but I've had two or three people tell me they've used or tried to use it now, which is very encouraging.
05:40:49 <tibbe> dankna, you're kinda assuming that people are familiar with DB APIs, where binding is a very prevalent concept. Some people might not be.
05:40:55 <dankna> hmm
05:40:57 <dankna> you're right
05:41:10 <Gracenotes> something like (a -> b -> c) -> (a -> c) -> (b -> c) -> Map k a -> Map k b -> Map k c, has been suggested (with a keyed variant?)
05:41:18 <Gracenotes> long type signature
05:41:22 <tibbe> dankna, I can't guarantee that people will use it, but I'm pretty sure that if it's undocumented people won't. ;)
05:41:25 <dankna> hahah
05:41:27 <dankna> fair enough
05:41:54 <tibbe> Gracenotes, or (k1 -> k2 -> v1 -> v2 -> (k, v))
05:41:56 <dankna> anyway, I need to leave now, but thanks for your input
05:42:09 <tibbe> Gracenotes, see my email to libraries about keyed variants
05:42:12 <Gracenotes> tibbe: v1 and v2 might not be present
05:42:19 <tibbe> Gracenotes, you only need the keyed variants
05:42:33 <tibbe> Gracenotes, right, so you'll have to specify what kind of join you want
05:42:36 <Gracenotes> tibbe: I'm talking about a sort of union thing
05:42:43 <tibbe> Gracenotes, do you want an inner, outer, or full join
05:42:48 <tibbe> Gracenotes, right
05:43:05 <tibbe> dankna, you're welcome, hopefully it was useful
05:43:33 <Gracenotes> joins would be great also, but I haven't thought about type signatures there, and they would possibly be limited in asymptotic efficiency
05:43:42 <ddarius> Features not being documented has never stopped people from using said features.
05:43:44 <dankna> it was.  I've put it in a text file in that dir as a reminder to myself haha.
05:47:21 * Gracenotes looks at recent libraries posts again
06:05:21 <Znudzon> quicksilver: i've recompile wx with unicode ...but i sill have only one letter. Restart computer will change anything ?
06:28:55 <Joe\\> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29220#a29220, can someone show me what im doing wrong? function works in ghci, but not when trying to compile
06:29:59 <Zao> Well, what errors do you get?
06:30:31 <Joe\\> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29221#a29221
06:30:52 <Zao> You probably want to --make, or -package network
06:31:07 <Zao> It's not linking the fancy native library bits of the package.
06:31:38 <Joe\\> Worked when I did --make
06:31:38 <Joe\\> Thanks
06:36:03 * hackagebot th-lift 0.5 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.5 (MathieuBoespflug)
06:37:09 <jozi> The Control.Arrow module does not seem to define liftA2 according to the Hughes paper. There's only liftA2 in Control.Applicative (a different one, I guess). What's the deal?
06:39:20 <jozi> Hrm, also no split and unsplit.
06:53:18 <Wooga> hello, can i use `import Module hiding (Blah(..))' for redefining data-structures?
06:53:49 <zygoloid> Wooga: what do you mean 'redefining'? you can define a new data type with the same name as a type defined in one of your imports that way
06:54:02 <zygoloid> but you can't then expect functions imported from Module to operate on your new type
06:55:24 <Wooga> so i can't. thanks for answering!
06:56:40 <Axman6> how would such a thing work?
06:57:36 <EvanR-work> very carefully
06:58:19 <pmurias> what's |*><*|?
06:59:08 <EvanR-work> the gannon operator
06:59:29 <pmurias> where is it documented?
06:59:43 <EvanR-work> in the manual for legend of zelda (NES)
06:59:59 <geheimdienst> pmurias, try hayoo http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=|*%3E%3C*|
07:03:13 <pmurias> geheimdienst: thanks
07:03:36 <deteego> EvanR-work: rofl
07:19:47 <FunctorSalad> I made a CLI hayoo client for completion, but not sure whether it's good for anything
07:19:51 <FunctorSalad> due to lag :(
07:20:13 <FunctorSalad> you don't want to have to wait for the network every time you hit tab
07:20:36 <FunctorSalad> (btw hayoo offers completion functionality already, it's a trivial program)
07:20:45 <geheimdienst> sounds interesting. so that's a zsh completion thing, right?
07:21:01 <geheimdienst> but why do you need haskell function names on the command line?
07:21:21 <FunctorSalad> you could hook it up to zsh if you knew how its intimidating system works ;)
07:21:36 <FunctorSalad> geheimdienst: more for hooking it up to vims completefunc or so
07:21:48 <geheimdienst> aaah i see :-) excellent
07:21:52 <geheimdienst> sounds great
07:21:57 <FunctorSalad> well, too slow
07:22:16 <FunctorSalad> I could have it use a cache, but how often do you complete the same thing twice...
07:24:00 <geheimdienst> could you do something with the local hoogle database thing?
07:24:12 <geheimdienst> i mean, you don't usually wanna complete on stuff you haven't installed
07:25:30 <FunctorSalad> geheimdienst: that's another trivial program that ought to exist... something that makes a hugeass hoogle db from your ~.cabal/packages stash
07:26:50 <geheimdienst> i've never figured that out. how is it, you have to run "hoogle --something" on each installed package, then run some other command which merges all the databases ...?
07:27:48 <FunctorSalad> geheimdienst: I guess cd $package; cabal configure; cabal haddock --hoogle would be even easier... and then you need to hoogle convert them (.txt to binary hoogle) and hoogle combine them, apparently
07:28:13 <FunctorSalad> wth am I writing this instead of coding it? ;)
07:28:59 <geheimdienst> thanks for the explanation! maybe i'll get around to writing something
07:29:04 <geheimdienst> this has bugged me for quite some time
07:29:27 <FunctorSalad> yeah, seems like a low-hanging fruit
07:30:10 <FunctorSalad> if only system functions were easier to find in haskell :)
07:30:18 <FunctorSalad> circular dependency.....
07:30:45 <FunctorSalad> (I mean changeWorkingDirectory etc)
07:33:48 * geheimdienst wishes there was a table showing c functions and their haskell equivalents
07:33:55 <daxim> hey, I want to complain about the lack of DESTDIR in the haskell-platform build system.  it makes packaging unnecessarily hard
07:34:00 <geheimdienst> and in what modules they live, obviously
07:34:48 <fasta> daxim, it's the wrong place to complain. 
07:34:57 <daxim> oh
07:35:30 <Ke>  ./setup copy \ --destdir="${D}" 
07:35:37 <Ke> oslt
07:35:51 <Ke> from haskell-cabal.eclass in gentoo
07:36:00 <deteego> hey, I have this issue where runhaskell cannot find packages for GHC
07:36:07 <deteego> even though they are installed or registered
07:36:28 <fasta> deteego, user vs system...
07:36:43 <deteego> fasta: ....
07:36:52 <deteego> fasta: its in user
07:37:00 <fasta> deteego, do you give the --user flag?
07:37:20 <sm> runhaskell doesn't take --user afaik
07:38:07 <fasta> sm: right, my bad.
07:38:08 <deteego> no actually that worked
07:38:09 <deteego> thanks
07:38:32 <deteego> I resorted having to install all packages to user
07:38:40 <Ke> daxim: is that useful for you?
07:38:44 <deteego> due to the horrible way archlinux worked in regards to installing haskell packages
07:38:54 <daxim> Ke, not quite
07:39:06 <fasta> deteego, Horrible? Why? 
07:39:31 <fasta> deteego, isn't it just pacman <whatever> <name of package>?
07:39:43 <FunctorSalad> can I just assume the cabal dir is ~/.cabal?
07:39:45 <deteego> any time a package X which was being upgradeded, and another package Y happened to depend on X
07:39:49 <sm> I have the same problem.. a script using a user-installed lib which I can't runhaskell
07:39:53 <FunctorSalad> I really don't want to go looking for it in the cabal API ;)
07:39:59 <deteego> ghc-pkg for obvious reasons
07:40:08 <deteego> couldn't unregister X
07:40:10 <fasta> FunctorSalad, no. 
07:40:13 <deteego> which broke GHC
07:40:22 <FunctorSalad> fasta: on linux? ;)
07:40:46 <fasta> FunctorSalad, no.
07:41:07 <fasta> FunctorSalad, well, you can. It just won't work everywhere.
07:41:08 <FunctorSalad> a nonportable program is still better than one that never gets finished ;)
07:41:13 <FunctorSalad> brb battery change
07:41:32 <fasta> FunctorSalad, asking this question takes longer than finding the API call.
07:41:34 <deteego> until archlinux gets proper metapackages
07:41:44 <deteego> better just to install through cabal
07:42:01 <daxim> Ke, after patching up scripts/install.sh I notice that only happy and alex honour --destdir
07:42:09 <deteego> actually that reminds me
07:42:12 <daxim> the thing's gnarly.
07:42:27 <deteego> is there a way to configre cabal so it installs libraries in /usr/lib and automatically makes haddock documentation?
07:43:31 <Jafet> Well, you'd want to install to /usr/local/lib. Well really, you'd want to install to ~/.cabal.
07:43:34 <geheimdienst> deteego, try --global and --enable-documentation, or the equivalent settings in your cabal config file
07:43:40 <FunctorSalad> oh noes I don't have the right batteries... (kbd)
07:44:19 <deteego> Jafet: well the issue is that cabal cannot uninstall libraries
07:44:37 <deteego> which means I would have to manually go through and uninstall cabal libraries
07:46:43 <dcoutts> deteego: but that's why you want it in ~/.cabal/ since then it's easier to delete than /usr/local
07:47:11 <deteego> dcoutts: but then I have issues with packages that provide both binaries and libraries
07:47:29 <dcoutts> deteego: what issues?
07:47:52 <dcoutts> deteego: do you mean $PATH issues?
07:48:05 <deteego> well yes
07:48:12 <dcoutts> you can put ~/bin on your $PATH and get cabal to add symlinks to ~/bin
07:48:18 <deteego> I still want my haskell *programs* installed as proper archlinux packages
07:48:27 <deteego> haskell libraries on the other hand I want to work like gems
07:48:39 <dcoutts> deteego: see the symlink-bindir setting in the ~/.cabal/config
07:49:10 <deteego> I dont want packages to be installed in ~/.cabal/bin
07:49:26 <deteego> as in binaries
07:49:58 <Jafet> "I don't want to do the thing that everyone else does because it's known to work"
07:50:15 <Jafet> Best of luck to you
07:50:29 <deteego> thats the way I did it before
07:50:31 <deteego> and it didnt work
07:50:48 <deteego> ghc broke whenever packages updated through AUR
07:51:18 <deteego> if cabal had an uninstall option I could just install everything in /usr/lib and be done with it
07:51:33 <deteego> but in their infinite wisdom there is no such option for cabal
07:51:37 <zygoloid> am i alone in finding that updating the global packages breaks my per-user setup?
07:51:50 <Jafet> Well, using two different package management systems never works.
07:52:18 <deteego> Jafet: it does with meta packages
07:52:40 <Jafet> Oh, I though you just said it didn't.
07:52:51 <deteego> archlinux doesn't have metapackages
07:53:12 <deteego> (metapackages as in packages which are actually scripts that run the proper library package manager, in this case cabal)
07:54:36 <dcoutts> deteego: it's not that we don't think uninstall is important, it's just not implemented yet
07:55:10 <dcoutts> deteego: also, the location does not make any difference to whether AUR updates will break your installed packages.
07:55:27 <deteego> dcoutts: I know, I don't want to use AUR for my libraries at all
07:55:31 <deteego> dcoutts: thats the point
07:55:50 <dcoutts> zygoloid: that will happen, if you change the core packages that your per-user libs depend on
07:56:33 <dcoutts> deteego: what do you do for packages that are both libs and exes? you can't have it be both AUR and not AUR
07:56:56 <deteego> well I want binaries to be actual packages
07:57:19 <deteego> and thats the problem I have
07:57:21 <benmachine> oh hey ghc-6.12.3 is finally in arch repositories, awesome
07:57:51 <deteego> I guess for *those* packages, it will just install the libs in /usr/lib instead of ~/.cabal
07:58:16 <zygoloid> dcoutts: any way around it other than "don't do that"? i've stopped installing haskell packages with apt-get for this reason already...
07:59:05 <dcoutts> zygoloid: not really, all you can do is to rebuild the broken packages (which cabal will do automatically)
07:59:43 <dcoutts> zygoloid: see each package has a unique hash, so changing a package low down in the dep tree will break all ones above it
08:00:07 <benmachine> oh hey it unregistered all my packages >:|
08:00:11 <dcoutts> the only way not to break those installed packages is not to remove the package
08:00:17 <zygoloid> i had cabal fall into a weird state recently (i think due to this) where it'd reinstall the same version of haskeline every time i installed another package
08:00:24 <benmachine> I guess that's just how minor version upgrades roll
08:00:31 <deteego> dcoutts: sorry could you give me the options for generating docs automatically with cabal and putting them in /usr/lib
08:00:43 <dcoutts> zygoloid: yeah, that's a bug to do with it getting confused over global vs user instances of the same package version
08:01:03 <dcoutts> deteego: enable-documentation either on the command line or in the config file
08:01:09 <geheimdienst> zygoloid, i had something once where some package depended on network-2.1.0.7 or somesuch, and another package depended on network-2.1.0.9
08:01:37 <geheimdienst> there was always one of the packages broken because of the missing dependency, and reinstalling one would make the other break
08:01:38 <dcoutts> deteego: btw, you mean /usr/local/share
08:01:53 <geheimdienst> something like that. i fixed it (i think) by gratuitous reinstalling
08:02:00 <zygoloid> dcoutts: i've also had issues where sudo apt-get install seems to try to register packages in my per-user database :o
08:02:05 <deteego> dcoutts: on arch, libraries are installed in /usr/lib/ghc-6.12.3/.....
08:02:23 <dcoutts> zygoloid: I find that hard to believe, it should not touch any per-user packages
08:02:32 <dcoutts> deteego: yes, but not docs
08:02:41 <deteego> dcoutts: oh yes ofc
08:02:49 <deteego> dcoutts: thought u were talking about actual libraries
08:02:52 <zygoloid> dcoutts: all i know for sure is, it got a weird error in ghc-pkg when i did sudo apt-get install, and worked fine when i did apt-get install from a root login shell
08:03:20 <temoto> Could anyone help what simple thing i'm missing?
08:03:25 <temoto> http://codepad.org/VnB4tiQz here
08:03:51 <deteego> dcoutts: where does $datadir point to?
08:04:12 <kmc> temoto, what's the problem?
08:04:25 <kmc> temoto, getArgs >>= mapM_ processFile
08:04:45 <kmc> getArgs is a recipe for getting a list; mapM_ iterates over a list
08:04:52 <kmc> a recipe for a list is not a list
08:04:57 <dcoutts> deteego: $prefix/share I think, i.e. /usr/local/share/
08:06:15 <Cale> My posts on this reddit thread are getting kind of long :) http://www.reddit.com/r/math/comments/d1qcf/to_infinity_and_beyond_the_struggle_to_save/c0wxako
08:06:31 <Cale> I should just write a book on my philosophy of mathematics and be done with it.
08:06:56 <zygoloid> Cale: i'd buy it
08:07:03 <temoto> kmc, thanks
08:07:20 <geheimdienst> an introduction to calematics, with code examples in caleskell
08:07:53 <drksd> :D
08:07:54 <geheimdienst> calematics sounds like some bullshit aerobic fad, maybe we should do something about that
08:08:13 <zygoloid> Cale: i'd definitely buy a book on interesting maths by you, Edward Kmett and Dan Piponi
08:08:35 * zygoloid goes back to reading blogs
08:11:00 <merijn> I'm kinda disappointed that New Scientist would do something silly as compare mathematics to natural laws.
08:11:27 <Philippa> eh, depending on what the comparison is it's not totally stupid
08:12:10 <benmachine> isn't New Scientist generally... a bit naff
08:12:20 <Philippa> it's the poppiest of pop sci outside the general press
08:12:23 <Cale> benmachine: Yes, in general it is.
08:12:38 <merijn> Philippa: Mathematics is a language for modeling things in. Such as reality, but it is in no way restricted to natural laws. It's quite easy to create a system in mathematics that completely contradicts the natural laws
08:12:41 <deteego> dcoutts: what is the global config file
08:12:44 <deteego> dcoutts: for cabal
08:12:52 <dankna> yes - moreso even than Discover and SciAm, which are still pretty head-in-the-clouds
08:13:49 <dankna> and hi all
08:13:53 <burp> merijn: but might it be not that our mathematics is influenced by natural laws?
08:13:53 <dankna> so I have a GADT constructor, CustardList :: [CustardValue a] -> CustardValue [a]...
08:14:06 <burp> imagine a parallel universe with other laws of physics, will mathematics be the same? :D
08:14:17 <Cale> But perhaps NewScientist's article was actually okay in the end, because its horribleness got me to start some pretty good discussions about the philosophy of mathematics.
08:14:44 <burp> they probably are, I can't imagine it otherwise
08:14:53 <burp> I mean, they are the same everywhere
08:15:03 <Cale> burp: Well, imagine even the same universe with beings that evolved in a different way -- I don't think the mathematics will be the same even then.
08:15:06 <dankna> now I want to somehow check whether a particular custard list contains a particular element type
08:15:19 <dankna> so I tried to put a type signature in a pattern...
08:15:22 <merijn> burp: Some fields are probably influenced by the natural laws, but it's not a prerequisite
08:15:30 <merijn> It's kind of hard not to influenced by the universe
08:15:35 <burp> wellÖ at last it's all speculation
08:15:36 <Cale> For that matter, we don't even have one singular mathematics ourselves.
08:15:40 <burp> noone can imagine "other" mathematics
08:15:42 <dankna> (CustardList list :: CustardValue [...])
08:15:50 <dankna> where ... is the client type I wanted, omitted because it's a bit long
08:15:51 <merijn> burp: Yes they can, it happens all the time...
08:16:04 <dankna> but I got "Pattern signature must exactly match: CustardValue a"
08:16:04 <burp> merijn: uh?
08:16:05 <Cale> We can imagine other mathematicses for ourselves, though we're certainly biased.
08:16:07 <merijn> burp: Just go examine how many different calculi are in existence
08:16:09 <dankna> but it DOES match it, as far as I can tell
08:16:16 <dankna> unless I'm not understanding what it means by "exactly" match
08:16:36 <merijn> burp: Mathematics is not one thing, it's a collection
08:16:37 <dankna> I'm just thinking out loud here, but if people want to chime in and solve my problem as they often have in the past, that would be great, haha
08:16:44 <burp> Cale: yes, the biasedness is the point I'm referring to 
08:16:56 <dankna> mathematics is not a single entity, yeah.  you've got entire fields of it the usefulness of which is disputed.
08:17:07 <merijn> burp: Pretty much the only thing they have in common is that the basic idea of all the different systems have a set of axioms and a set of rules.
08:17:16 <dankna> I would tend to think that even within this universe, aliens would come up with radically different mathematics from us
08:17:20 <dankna> but we'll never know :(
08:17:29 <dankna> six billion people and we still get lonely, haha
08:17:44 <dcoutts> deteego: all config files are per user, but it contains info for doing global installs
08:17:47 <Gilly> Cale: Thanks for linking to yourself, great stuff! :)
08:17:55 <Cale> :)
08:18:08 <deteego> dcoutts: sorry one last thing, where is the package config file for ghc
08:18:09 <benmachine> <Gollum> what has it got in its mathematicses
08:18:14 <dcoutts> deteego: there's the root-cmd feature to perform just the install as root
08:18:22 <dcoutts> deteego: see ghc-pkg list
08:18:25 <merijn> burp: You can then of course go meta and try and create axioms/rules for sets of axioms and rules..which I've been lead to believe is pretty much what category theory is
08:18:45 <dankna> I think category theory is /motivated/ by such things but isn't actually quite that
08:19:05 <dankna> I do think the being based on axioms and rules is something that any form of intelligence would do
08:19:19 <merijn> dankna: Sticky question
08:19:29 <dankna> but the choices of which axioms they consider mainstream are likely to be different.  they might even not use the natural numbers as we understand them.
08:19:40 <merijn> dankna: That question requires us to first define intelligence. Which is a twisty maze of hallways all alike
08:19:44 <dankna> oh of course, it's sticky, because you don't know... yes
08:20:12 <dankna> well, I go with the Turing approach - intelligence is that which, when you try to pretend it isn't there, argues with you
08:20:14 <merijn> We can't debate the question until we define intelligence, which I don't see happening any time in this millenia
08:20:38 <dankna> "/You/ tell the robots they can't have rights.  They keep quoting Thomas Paine when /I/ try it."
08:21:06 <Philippa> merijn: I'm familiar with getting to pick axioms, and I do believe you just /compared/ mathematics to natural laws in that regard ;-)
08:21:20 <Philippa> anyway, heading off-net
08:21:22 <dankna> I was hoping you were saying that my Haskell question was sticky, I admit :)
08:22:53 <Cale> dankna: I can sort of imagine at least one possible exception to the use of something quite recognisable as an axiomatic system. It's conceivable that alien life forms might find a more analog (as opposed to digital) means of communication more natural, and develop a completely different kind of thing which, while it would probably have rules like a formal system, wouldn't be something we'd probably really try to consi
08:22:53 <Cale> der seriously.
08:23:17 <Cale> (and yet perhaps for them would be equally successful)
08:23:57 <merijn> I have this feeling Reactive is all I want/need in a programming framework, if only I could figure out what it actually *does* >.>
08:24:10 <Cale> merijn: If only it actually worked.
08:24:40 <merijn> Cale: It doesn't? That's a pity
08:24:53 <Gracenotes> still one of the great unsolved problems in computer science
08:24:57 <burp> will the theory of everything (provided it exists) be describable by mathematics we have or can invent? :>
08:25:10 <Gracenotes> FRP is..
08:25:11 <Cale> merijn: There are extremely subtle and yet extremely damaging performance issues with it.
08:25:43 <Cale> burp: I tend to think that it doesn't exist, or at least, it's not recognisable, so it might as well not exist.
08:26:28 <Cale> (If we had a theory which described the universe perfectly, how would we tell that we did?)
08:27:05 <dankna> Cale: hmm.... like for example, if Vinge's aliens who think by distributed computing
08:27:10 <dankna> also used the same interface to talk to each other
08:27:21 <dankna> that would be "more analog" as you say
08:28:07 <Cale> yeah, there are some really weird possibilities that it's hard to explore because of the limitations of our own architecture
08:28:09 <dankna> so yes, you're right.  if they didn't have language as such ...
08:28:25 <dankna> well, we could someday explore them with sufficiently-powerful computers simulating an entire planet
08:28:30 <dankna> but it's not clear that it would be ethical to do so
08:28:31 <Cale> :)
08:28:44 <dankna> since you're placing intelligences into a hostile environment
08:28:47 <dankna> if they are intelligences :)
08:29:12 <burp> what about us then? :p
08:29:21 <dankna> we didn't put ourselves here, we just showed up
08:29:54 <dankna> and I'm not going to bite on the "is god immoral for putting us here then" thing hahaha
08:29:58 <Cale> and we evolved gradually to be relatively fit for our environment
08:30:03 <merijn> Ethics ruin most of the interesting experiments :p
08:30:10 <dankna> yes we did
08:30:16 <burp> you mean the simulation of intelligences should not be done? :>
08:30:29 <dankna> burp: the simulation of intelligences in hostile environments, rather.
08:30:36 <merijn> burp: That assumes intelligence can be simulated
08:30:45 <dankna> burp: as long as you respect its "human" rights, there's no problem with it.
08:31:10 <dankna> although that raises the question of whether putting it in a totally sterile, safe environment is so boring as to constitute torture hahaha
08:31:11 * int80_h_asleep wonders what he walked into.
08:31:14 <Cale> With such technology, human cruelty could rise to a whole new level. Simulate intelligences just to torture them mercilessly.
08:31:19 <dankna> indeed
08:31:28 <merijn> Cale: In the name of science!
08:31:39 <Cale> Nah, in the name of video games!
08:31:42 <dankna> this has been dealt with in sci-fi already, haha
08:32:07 <merijn> Also, you could argue you should base this on self-awareness rather then intelligence
08:32:23 <Gracenotes> dankna: to death, yeah
08:32:23 <dankna> yeah, but I don't like that term - it's even harder to define
08:32:31 <dankna> I don't know about "to death", but it's been done at least
08:32:32 <burp> ah, reminds me of star trek nowÖ moriati or whatever his name was :>
08:32:41 <Cale> Tamagotchi with a brain!
08:32:44 <merijn> People think animal cruelty is inhumane, and most people think most animals aren't intelligent
08:32:46 <zygoloid> burp: sherlock holmes?
08:32:55 <zygoloid> burp: or do you mean Q?
08:33:02 <dankna> there was that article about the military robots that had some evolutionary algorithms in them
08:33:13 <burp> zygoloid: no, I mean the episodes with data playing sherlock holmes
08:33:13 <Cale> Or The Sims
08:33:15 <merijn> dankna, Cale: That was the point I was working too, you could argue we're already torturing machines because they might be self-aware
08:33:16 <dankna> the person responsible for testing their behavior when they had legs blown off and stuff
08:33:21 <dankna> refused to do it, charging that it was inhumane
08:33:27 <burp> zygoloid: where prof. moriarty got self-aware in the holo simulation
08:33:43 <Gracenotes> but there is a line somewhere between main = interact (\_ -> "You're hurting me") and a torturing an android automaton
08:33:50 <Gracenotes> maybe the line's at self-learning? dunno.
08:33:54 <dankna> merijn: well.  yes.  but as someone who knows as much as any non-specialist about AI, I assert that our machines are not yet intelligent.
08:33:58 <Cale> Gracenotes: lol!
08:34:03 <dankna> note I changed your word self-aware because that's what you should have meant =p
08:34:14 <dankna> Gracenotes: yeah hahahaha, well said
08:34:16 <Cale> @remember Gracenotes but there is a line somewhere between main = interact (\_ -> "You're hurting me") and a torturing an android automaton
08:34:17 <lambdabot> I will never forget.
08:34:51 <merijn> I concede you can argue our machines are not yet intelligent. (Although I think we're reaching the point where you can also argue the reverse)
08:35:03 <dankna> (we're getting there, but we're not there yet)
08:35:22 <merijn> Gracenotes: Mentions self-learning as a criteria for intelligence and we already have self-learning systems
08:35:27 <kmc> why is intelligence the significant property?
08:35:33 * wli has some nice arguments for the day never arriving.
08:35:38 <dankna> wli: do tell
08:35:40 <kmc> might consciousness not be terribly closely tied to intelligence?
08:35:48 <zygoloid> does sum_i=1^n n^i/i! / e^n -> 1 as n -> inf ?
08:35:59 <kmc> also, what's the point of drawing a sharp line?
08:36:00 <merijn> kmc: I already argued self-awareness and that machines might already be self-aware
08:36:01 <dankna> kmc: because we can't measure consciousness (except in ourselves, through introspection)
08:36:19 <Gracenotes> merijn: from an ethics standpoint, it's a start
08:36:20 <dankna> kmc: and you can't just ask an intelligence whether it posesses consciousness, because it will always "think" that it does
08:36:24 <merijn> kmc: It's impossible to proof something is or isn't self-aware
08:36:37 <Jafet> kmc: for taxation purposes
08:36:39 <kmc> dankna, nope, many of my intelligent friends claim to be philosophical zombies
08:36:44 <kmc> we can't measure intelligence either, except by anthropocentric bullshit
08:36:46 <dankna> Javet: mwahahahahahaa nicely done
08:36:55 <kmc> our definition of intelligence is that something acts like a human
08:37:01 <int80_h> self-awareness isn't falsifiable, therefore we can't know about it.
08:37:02 <merijn> kmc: We can't measure intelligence because we have no definition of intelligent atm
08:37:06 <wli> dankna: Mostly to do with the natural resources for computing (and more) not being there long enough for potential future developments to happen, atop the usual doubts over whether it could happen at all.
08:37:12 <dankna> kmc: I argue that your intelligent friends are being disingenuous
08:37:33 <dankna> merijn: we do have a definition of intelligence - Turing's.  as I already said.
08:37:53 <Cale> Cleverbot seems to think that it is self-aware.
08:37:58 <zygoloid> we have a definition of can-simulate-a-human
08:38:02 <merijn> dankna: That definition is not widely accepted
08:38:02 <dankna> wli: hmm okay
08:38:17 <dankna> merijn: that doesn't mean it isn't right :D  (I'm an egoist, haha)
08:38:26 <int80_h> dankna, why is it you feel we already have a definition of intelligence - Turing's?
08:38:49 <int80_h> a little AI joke.
08:38:50 <zygoloid> no wonder we have so much they-are-among-us sci-fi if the ability to hide within our society is our very definition of intelligence
08:38:53 <dankna> int80_h, did you actually run Eliza or just paraphrase it :D
08:38:55 <wli> dankna: They mostly center around fossil fuelds but there are metallic ore grade affairs as well for various metallic ores.
08:39:09 <dankna> zygoloid: fascinating point
08:39:16 <int80_h>  dankna paraphrase
08:39:36 <merijn> "And how does a definition of intelligence - Turing's make you feel?"
08:39:46 <kmc> dankna, i've argued with them at length about it.  given how fuzzy the concept "consciousness" is, it's entirely reasonable that an intelligent person might decide the whole idea is hogwash and refuse to self-apply the label
08:39:50 <dankna> wli: well - surely once we start exploiting natural beauty in space as well as on Earth, at least the metallic ores will be taken care of
08:40:02 <Gracenotes> zygoloid: I've seen a(n informal) definition of mental illness, that it's the inability to take on the roles society expects of us
08:40:07 <dankna> kmc: yeah, it's a reasonable point of view I guess
08:40:15 <Gracenotes> besides I mean the actual physiological things
08:40:31 <wli> dankna: Rather doubtful given that particular kinds of ores are needed and they're not going to show up in asteroids.
08:40:34 <dankna> merijn: phrasing like that makes me wonder if psychologists are sentient sometimes :D
08:40:35 <zygoloid> Gracenotes: how do you distinguish between an inability to do so and a reasoned refusal to do so?
08:40:57 <zygoloid> Gracenotes: this sounds like the "you're addicted if you can't prove you have the ability to give up forever" argument
08:41:06 <dankna> wli: which ones are we talking about here?
08:41:09 <int80_h> yeah! society expected me to work in a factory, but I do this instead.
08:41:20 <dankna> zygoloid: yes - thank you - that's what I would have said if I had thought of it
08:41:26 <Gracenotes> true enough. I am paraphrasing vaguely from memory though.
08:42:09 <wli> dankna: Rare earths, silver, platinum, gallium, etc.
08:42:28 <Gracenotes> int80_h: you deviant you
08:43:14 <zygoloid> int80_h: in soviet russia, society expects you to work in a factory for its gain...
08:43:18 <dankna> wli: I'm trying to find some data now, because it interests me not because I want to argue with you, but I don't see why you assume those things aren't to be found off-Earth somewhere.  they're formed in stars, not in planets.
08:43:39 <dankna> in soviet corussia, you expect society to work in a factory for your gain?
08:43:44 <dankna> that one doesn't work
08:43:47 <Gracenotes> zygoloid: I'll have to find the exact quote. it's in an audio lecture somewhere...
08:43:53 * int80_h is a rebel.
08:44:24 <zygoloid> dankna: exactly so.
08:44:31 <Gracenotes> deviance studies is definitely the funnest corner of sociology though
08:45:22 <wli> dankna: There's some account somewhere of how the things get deposited across planets with some explanation as to why you need earth-like geology to get at them.
08:45:44 <dankna> wli: I'd be interested in seeing it, as someone who aspires to write SF for fun someday
08:46:53 <dankna> wli: I'm not finding a lot of information on asteroid composition, hrm...
08:47:33 <merijn> dankna: Why "someday"?
08:47:37 <dankna> however, I'd think that if you don't care about marring the heavenly body with giant scars, you can get at ANYTHING
08:47:50 <dankna> I mean, by just removing everything that's on top until you get down to it
08:48:03 <dankna> merijn: well, because I have to make my mark on computer science first :D
08:48:05 <Wooga> how do i get regulaer Int from fractional one?
08:48:13 <dankna> :t floor
08:48:15 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:48:19 <merijn> dankna: Get in line :p
08:48:33 <Wooga> thanks!
08:48:35 <dankna> there's no line for making one's mark - you just do it
08:48:36 <dankna> sure
08:48:38 <mm_freak> Wooga: you don't
08:48:40 <deteego> dcoutts: is there any idea when the cabal uninstall feature will be added in
08:49:01 <Wooga> mm_freak: isn't floor does that ?
08:49:06 <Wooga> doesn't*
08:49:12 <mm_freak> Wooga: not for Fractional
08:49:13 <dankna> I think mm_freak is saying that a fractional isn't an Int
08:49:27 <mm_freak> dankna: a fractional can well be integral
08:49:35 <dankna> oh.  yes.  I suppose so.
08:49:39 <dcoutts> deteego: no, there's no schedule, if someone sends a patch then it'll happen quicker, it's not that high on the priority list compared to other things
08:49:51 <deteego> dcoutts: ij thanjks
08:49:53 <deteego> *thanks
08:49:59 <mm_freak> dankna: finite fields for example
08:50:05 <dankna> personally, I don't feel the need for cabal uninstall because all the cruft I've accumulated is uninstalled anyway every six months when I replace ghc, heh
08:50:21 <dcoutts> dankna: right, exactly
08:50:23 <dankna> but it might be useful for fixing pathological situations
08:50:40 <dcoutts> dankna: not really, unregistering will work for that
08:50:44 <dankna> hmm
08:50:47 <dankna> good point
08:51:03 <mm_freak> Wooga: however, most Fractional types happen to be RealFrac types, too, so you can use floor with them =)
08:51:32 <dankna> I still don't have Haskell's number hierarchy totally in my brain
08:51:55 <wli> dankna: There's probably room to continue the eventual fate of computing on #haskell-blah
08:51:56 <mm_freak> dankna: it's a bit of a mess, but when you work with it for a while, you get the idea
08:52:01 <dankna> yeah
08:52:03 <Gracenotes> many months ago I was going to make a chart for converting one type to another
08:52:37 <mm_freak> Gracenotes: i think that would be very useful
08:52:37 <Gracenotes> then, hm, I think what happened is that I learned it and lost my motivation
08:52:46 <Gracenotes> to the chartmobile
08:53:07 <mm_freak> but i think most conversions are easy‚Ä¶  after all there are only a few functions you need to know
08:53:07 <zygoloid> lossless conversions: from integral type: fromIntegral. from non-integral type: realToFrac. lossy conversions: round or trunc or ceil or floor or ...
08:53:18 <mm_freak> most notably from* and floor/truncate/‚Ä¶
08:53:33 <Gracenotes> oh, right, I turned it into something more advanced, with a venn diagram of typeclasses around number types, and arrows between them
08:53:45 <Gracenotes> and of course more advanced things are less likely to get finished
08:54:02 <zygoloid> technically fromIntegral and realToFrac aren't really lossless
08:54:11 <mm_freak> zygoloid: i don't think that all realToFrac conversions are lossless
08:54:25 <mm_freak> zygoloid: you can easily convert 3/4 to 3/4 mod 2, but not back
08:54:35 <Gracenotes> realToFrac uses both toRational and fromRational. fromIntegral uses both toInteger and fromInteger
08:54:42 <Gracenotes> chances are one of the two is lossless
08:54:42 <mm_freak> uhm
08:54:47 <mm_freak> let's say mod 3 instead of mod 2 =)
08:54:49 <zygoloid> mm_freak: sure. i should have used a better word. non-rounding is more what i meant...
08:55:19 <zygoloid> mm_freak: there are easier examples. Double -> Float, for instance, or Rational -> Double.
08:55:43 <mm_freak> zygoloid: there is no rounding concept for Fractional, so i doubt that that wording is better
08:57:36 <zygoloid> > floor (7%5)
08:57:37 <lambdabot>   1
08:57:39 <zygoloid> sure there is
08:57:54 <mm_freak> that's for Rational
08:58:01 <mm_freak> but not for Fractional in general
08:58:39 <Gracenotes> isn't there already a graph with arrows between most of the prelude typeclasses? that manages to be confusing somehow?
08:59:12 <EvanR-work> http://www.haskell.org/onlinereport/classes.gif
08:59:29 <EvanR-work> its so simple!
08:59:47 <EvanR-work> http://en.wikipedia.org/wiki/File:Complete_graph_K7.svg
08:59:59 <zygoloid> mm_freak: yeah, it's RealFrac innit :/
09:00:18 <deteego> dcoutts: is it possible to make cabal run a custom command when installing a package
09:00:28 <deteego> dcoutts: such as making a symbolic link?
09:00:38 <zygoloid> mm_freak: fortunately there are no types in the report which are Fractional but not RealFrac (iirc)
09:01:42 <mm_freak> zygoloid: i can think of at least two, one definitely not in the report and one i don't know
09:01:47 <mm_freak> Mod17 and Complex
09:01:59 <EvanR-work> @src realFrac
09:02:00 <lambdabot> Source not found. :(
09:02:20 <dcoutts> deteego: cabal can make symbolic links for binaries, there's no generic hook mechanism though.
09:02:34 <deteego> dcoutts: how about for libraries?
09:02:39 <zygoloid> mm_freak: hmm, Complex, fair point. that doesn't fit into the numeric conversion model in any case
09:02:44 <EvanR-work> @src RealFrac
09:02:44 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
09:02:45 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
09:02:45 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
09:03:01 <deteego> dcoutts: sorry not libraries, specifically meant haddock documentation
09:03:14 <EvanR-work> > properFraction 3.14159
09:03:14 <lambdabot>   (3,0.14158999999999988)
09:03:30 <EvanR-work> o_O
09:03:50 <EvanR-work> useful
09:03:55 <benmachine> I find it weird how Enum and Ord are not at all related
09:04:11 <benmachine> and I wonder why IOError isn't orderable
09:04:22 <zygoloid> you'd want Ord as a superclass of Enum?
09:04:38 <dankna> I like non-Ord enums
09:05:33 <zygoloid> dankna: do you have an example of one?
09:05:35 <benmachine> zygoloid: I don't think it would really help, just commenting
09:05:50 <dcoutts> deteego: for docs, cabal can update a haddock index, that's the only special thing.
09:05:57 <dankna> zygoloid: hmm...  you know what...  I'm wrong, I don't like them :D
09:06:00 <dankna> also I don't have an example of one
09:06:02 <deteego> dcoutts: ok dw about it then
09:06:09 <deteego> dcoutts: this is good enough, thanks for your help
09:06:20 <deteego> dcoutts: ill mention it on the archwiki page =D
09:06:25 <benmachine> :t comparing fromEnum
09:06:26 <lambdabot> forall b. (Enum b) => b -> b -> Ordering
09:06:26 <EvanR-work> enum means bimapped to a consecutive set of Ints
09:06:30 <dcoutts> deteego: the assumption is that you just install them in the right place, or you make a system package
09:06:34 <EvanR-work> ord means ordered
09:06:40 <EvanR-work> i guess the first implies the second
09:06:51 <deteego> dcoutts: yeah its just for my distro, its installed in one place and a symbolic link is made
09:07:02 <deteego> wanted to mirror it but didn't need to
09:07:20 <dcoutts> deteego: of course arch has it's own haskell packages
09:07:45 <deteego> dcoutts: well I have simulated how arch does its packages with cabal
09:08:04 <deteego> dcoutts: and I know where everything installs to
09:08:08 <deteego> dcoutts: so its all good +D
09:08:11 <deteego> =D*
09:08:15 <Gracenotes> the complex numbers can be enumerated by not ordered
09:08:37 <zygoloid> instance Eq a => Enum [a] where enumFromTo xs ys = takeWhile (/= ys) (tails xs) ?
09:08:42 <Gracenotes> or at least not naturally ordered.. mesupposes...
09:08:43 <EvanR-work> enum doesnt make sense for complex
09:08:49 <lispy> Gracenotes: You mean, not well-ordered, right?
09:08:56 <Gracenotes> yes
09:08:58 <lispy> Gracenotes: partial orders are possible, IIRC
09:09:01 <zygoloid> Gracenotes: what would [3:+4 .. 1:+1] be?
09:09:12 <EvanR-work> > [3:+4 .. 1:+1]
09:09:13 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Complex.Complex t))
09:09:13 <lambdabot>    arising from a ...
09:09:15 <dcoutts> deteego: hmm, I'm not sure that's really wise
09:09:42 <deteego> dcoutts: well libraries get installed into a single ghc folder
09:09:50 <deteego> dcoutts: as does documentation
09:09:51 <quicksilver> Gracenotes: "naturally". You can order the complex numbers with a hilbert curve, methinks, which is relatively natural in a way.
09:09:58 <Gracenotes> zygoloid: if f is your (complex -> int) function g is your (int -> complex) function, then: map g [f (3:+4) .. f (1:+1)]
09:10:05 <deteego> dcoutts: so if anything goes wrong I know where to delete it
09:10:10 <quicksilver> but it doesn't have nice properties in terms of C as a field.
09:10:16 <Gracenotes> a diagonalization would give you either of those
09:10:22 <quicksilver> certainly you can't make C into an ordered field - perhaps that's what you meant.
09:10:33 <Gracenotes> not like the enumeration is that useful, but..
09:11:09 <zygoloid> Gracenotes: it also gives a strict weak ordering of the complex numbers :)
09:11:29 <zygoloid> instance (Eq a, Enum a) => Ord a where x < y = y `elem`  tail [x..] :)
09:11:35 <Gracenotes> it does, though Ord is more than just an arbitrary ordering
09:11:48 <zygoloid> Enum is more than an arbitrary enumeration too, i'd say
09:12:13 <Gracenotes> touche. some people have proposed an ArbitraryOrd typeclass though.
09:12:27 <c_wraith> Or less, if you count the Enum instance for Double or Float
09:12:29 <Gracenotes> not many have proposed ArbitraryEnum
09:12:58 <aristid> can i get ghci to show all operators with infix levels?
09:13:28 <Gracenotes> but who wants a prelude based on abstract algebra, really?
09:13:33 <zygoloid> aristid: you can :info each of them in turn
09:13:59 <Gracenotes> a not-very-rhetorical question, turns out..
09:13:59 <zygoloid> for the ones in the Report you can use my handy guide: http://control.monad.st/haskell/operator-precedences/
09:14:23 <aristid> zygoloid: handy!
09:14:41 <Jafet> @remember zygoloid instance (Eq a, Enum a) => Ord a where x < y = y `elem` tail [x..]
09:14:41 <lambdabot> I will never forget.
09:17:03 <hewei1> Hi there, a quick question please. When I do 
09:17:13 <hewei1> > print 0.0001
09:17:14 <lambdabot>   <IO ()>
09:17:26 <hewei1> I get 1.0e-4 on screen
09:17:57 <hewei1> How can I get the output as "0.0001" 
09:18:07 <EvanR-work> > text (printf "%f" 0.0001)
09:18:08 <lambdabot>   0.0001
09:18:18 <greap> What would be the best-practice way to race two inifinite lists? Eg, I want to see how many primes get generated by two different sieves in 10 seconds.
09:18:41 <EvanR-work> > printf "%f" 0.0001
09:18:42 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:18:42 <lambdabot>    `Text.Printf.PrintfType ...
09:18:49 <EvanR-work> > printf "%f" 0.0001 :: String
09:18:50 <lambdabot>   "0.0001"
09:19:06 <Gracenotes> I usually make the result a CReal
09:19:15 <hewei1> EvanR-work: thanks! 
09:19:22 <Gracenotes> don't really like that Show instance..
09:19:59 <EvanR-work> > 0.0001 :: CReal
09:20:01 <lambdabot>   0.0001
09:20:05 <zygoloid> > showFFloat Nothing 0.00001 ""
09:20:06 <EvanR-work> > show (0.0001 :: CReal)
09:20:06 <lambdabot>   "0.00001"
09:20:07 <lambdabot>   "0.0001"
09:20:27 <zygoloid> hewei: use Numeric.showFFloat
09:20:44 <Gracenotes> with two arguments you won't need
09:21:00 <aristid> :t showFFloat
09:21:01 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
09:21:25 <zygoloid> using ShowS instead of String is a good habit to get into, imo...
09:22:08 <Giu> Hi everyone. I'm currently solving problem nr. 20 of the Ninety-Nine Haskell Problems (http://www.haskell.org/haskellwiki/99_questions/11_to_20) and I have a *design* question. The function removeAt has the type signature Int -> [a] -> (a, [a]). The first pattern of my solution is removeAt _ [] = ..., which should gracefully handle the empty list. My question now is: is it okay to call the error function when this pattern matches? Or what wo
09:22:09 <Giu> your approach? I don't know of other possibilities to handle this situation, but I'm just a Haskell novice. Many thanks in advance!
09:23:25 <zygoloid> Giu: i'd say it's the removeAt function /itself/ which has the design problem
09:23:26 <aristid> record wildcards ftw
09:23:40 <zygoloid> Giu: removeAt :: Int -> [a] -> (Maybe a, [a]) is what i'd implement
09:24:47 <zygoloid> (but even /that/ i'd try to avoid using... Ints as list indices are often a smell)
09:25:19 <Gracenotes> except, if you're solving a list of problems, the primary goal is to solve the problems
09:25:25 <Gracenotes> as stated
09:25:45 <aristid> removeAt :: Integral n => n -> [a] -> (Maybe a, [a])?
09:25:57 <Gracenotes> but I dunno what the problem is
09:25:58 <Blkt> good evening everyone
09:25:59 <Wooga> why this (note C-like the parentheses): http://ideone.com/TKrTt works ?
09:26:03 <zygoloid> ... in which case, the question is, should removeAt _ [] be _|_ or (_|_, xs) for some xs?
09:26:31 <dankna> so yeah
09:26:45 <dankna> I asked this about an hour ago but we were discussing intelligence and the far future :)
09:26:49 <zygoloid> Wooga: tuples :)
09:26:54 <dankna> ... phone one sec
09:27:06 <Wooga> ah, yeah!
09:27:08 <Wooga> thanks!
09:27:19 <Gracenotes> Giu: well, you can get the function working without returning the value, right? like in the lisp example
09:27:41 <Peasley> hey. do you guys try to avoid 'for' loops in haskell? im thining something along lines  [ ur_list!!x | x <- [0..ur_list.length]]
09:27:45 <Peasley> thinking*
09:28:13 <zygoloid> Peasley: modulo strictness, that's just ur_list
09:28:26 <zygoloid> Peasley: in a strange way, lists /are/ for-loops in haskell.
09:29:13 <Jafet> :t forM_
09:29:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
09:29:32 <Giu> zygoloid: Ah thanks. I actually had it in my mind, but I've forgotten to mention it in my question. In this case I'll work with Maybe. Thanks again.
09:29:52 <byorgey> zygoloid: modulo strictness and efficiency you mean. =)
09:30:04 <zygoloid> Peasley: basically, your options are either to use a higher-order function, or to recurse. using something higher-order (for instance, map or filter or ...) is generally preferred
09:30:15 <zygoloid> byorgey: i was thinking denotationally :)
09:30:23 <byorgey> fair enough =)
09:30:35 <Peasley> zygoloid yeah that what I was kind of thinking
09:30:44 <Giu> Gracenotes: Yes, true, but I actually started to implement the Prolog version :)
09:31:18 <Gracenotes> everything's more fun in prolog
09:31:22 <zygoloid> Peasley: list comprehensions desugar into higher-order functions, and they're often a nice choice. using the list monad in do-notation is also often nice
09:32:30 <Peasley> let's say I want to generate two subexpressions of list.. say we have [T, F, T, F]  we would get => (T)(FTF), (TF)(TF), (TFT)(F), I have no idea how i would do it from haskell point of view, personally id just loop over it using foreach(if I understand right) and split the list into two by current key index(if that's even possible) :P
09:32:44 <zygoloid> Peasley: i think part of the trick is primarily thinking in terms of the result you want to create, rather than primarily thinking in terms of how to create it
09:32:51 <aristid> reminds me... is there a way of doing this without (++)? zip xs (map Just (tail xs) ++ [Nothing])?
09:33:24 <Gracenotes> pairing each element with the next one?
09:33:36 <zygoloid> Peasley: well, the result you want is all the pairs of (first n elements of list, rest of list)
09:33:43 <Peasley> yeah
09:33:47 <Peasley> you could say that :P
09:33:49 <aristid> Gracenotes: yeah and not dropping the last element like zip `ap` tail
09:34:06 <zygoloid> Peasley: so if you could get the individual parts of each tuple you could join them together like that
09:34:08 <Gracenotes> I think padded zips have been proposed.. somewhere..
09:34:21 <zygoloid> > (inits "TFTF", tails "TFTF")
09:34:22 <lambdabot>   (["","T","TF","TFT","TFTF"],["TFTF","FTF","TF","F",""])
09:34:27 <zygoloid> ^^ like that
09:34:43 <zygoloid> > zip (inits "TFTF", tails "TFTF")
09:34:44 <lambdabot>   Couldn't match expected type `[a]'
09:34:44 <lambdabot>         against inferred type `([[GHC.Ty...
09:34:50 <zygoloid> ;(
09:34:54 <Peasley> :O
09:34:56 <Deewiant> > liftM2 zip inits tails "TFTF"
09:34:57 <lambdabot>   [("","TFTF"),("T","FTF"),("TF","TF"),("TFT","F"),("TFTF","")]
09:35:05 <aristid> > uncurry zip (inits "TFTF", tails "TFTF")
09:35:06 <lambdabot>   [("","TFTF"),("T","FTF"),("TF","TF"),("TFT","F"),("TFTF","")]
09:35:10 <zygoloid> > zip (inits "TFTF") (tails "TFTF")
09:35:11 <lambdabot>   [("","TFTF"),("T","FTF"),("TF","TF"),("TFT","F"),("TFTF","")]
09:35:47 <Peasley> neat, though i then need to do some sort of filtering too, since there should be total of three elements
09:36:02 <zygoloid> > init . tail $ zip (inits "TFTF") (tails "TFTF")
09:36:04 <lambdabot>   [("T","FTF"),("TF","TF"),("TFT","F")]
09:36:04 <Deewiant> > tail . init $ liftM2 zip inits tails "TFTF"
09:36:05 <lambdabot>   [("T","FTF"),("TF","TF"),("TFT","F")]
09:36:09 <dankna> so yeah, as I was about to say.  I asked this an hour ago but nobody around then responded.  but it's a different crowd now so I'll try again. :)
09:36:15 <Peasley> :)
09:36:26 <dankna> I have a GADT constructor CustardList :: [CustardValue a] -> CustardValue [a] (Custard is the name of my mini-language)
09:36:30 <Gracenotes> could also make your own recursive function.. to be even more efficient
09:36:40 <dankna> I want to pattern-match or case or something to test the type of the elements of the list
09:36:46 <dankna> can I do this at all?  if so, how?
09:37:17 <dankna> matching on (CustardList list :: CustardValue [...]) doesn't work, it gives an error "Pattern signature must exactly match: CustardValue a"
09:37:25 <zygoloid> dankna: no. the magic of GADTs (or rather Existentials) is that the types can be erased at runtime
09:37:38 <dankna> hmmmm.
09:37:46 <dankna> that's an interesting point
09:38:00 <dankna> okay, the question now becomes, how can I design things so that I /can/ do this
09:38:07 <zygoloid> dankna: if you need to know more information about what's in the list, you'll either need 1) for a GADT pattern match to refine the types, or 2) for you to store the extra info you need somehow (as a typeclass instance or as data)
09:38:13 <Cale> dankna: That's what Typeable and Dynamic are for
09:39:10 <dankna> zygoloid: I think I may already be using GADT pattern matches - I got an error message at some point like "you need to turn on GADTs to do this" and I didn't understand but I obeyed :) but I haven't really thought about what they are exactly
09:39:12 <dankna> hmm
09:39:29 <dankna> well let me explain my design goals
09:39:33 <Cale> dankna: If you have something like CustardList :: (Typeable a) => [CustardValue a] -> CustardValue [a]
09:39:48 <dankna> I am using the GADT because I want to constrain this list to be always of the same type of element
09:40:00 <dankna> I guess that's obvious if you read my constructor, heh
09:40:16 <Cale> then you effectively have a homogeneous list of an arbitrary type, which can be recovered safely using cast
09:40:18 <zygoloid> dankna: can you put the whole GADT up on hpaste?
09:40:21 <Cale> :t cast
09:40:22 <dankna> sure
09:40:23 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
09:40:38 <Cale> If the type you ask for doesn't match, then you get Nothing
09:40:50 <dankna> yeah.... I've used Dynamic before, not exactly for this
09:40:54 <dankna> hmm
09:41:07 <Cale> You actually don't want Dynamic, if you want to enforce the homogeneity
09:41:14 <dankna> that was what I thought, heh
09:41:23 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29222#a29222
09:41:46 <dankna> (I have a related problem with CustardMaybe, but solving this one will teach me how to solve that one, most likely)
09:41:51 <Cale> Dynamic is just a simple existential that ensures an instance of Typeable
09:42:05 <dankna> (don't even ask why it's called Custard.  the bottom line is that nobody else will see the name and I felt silly.)
09:42:10 <dankna> nodnod
09:42:25 <zygoloid> dankna: ah, great. you don't actually need any other mechanism to extract the type, if the list is non-empty; you can get it from type refinement on the first element of the list
09:42:27 <quicksilver> dankna: except, we did see the name. Your cover is blown.
09:42:29 <quicksilver> dankna: ;)
09:42:46 <dankna> quicksilver: hehe, oh well :)
09:43:06 <dankna> zygoloid: hmmmm... I was hoping something like that!  and if it's empty obviously I don't care what the type "would be"
09:43:21 <dankna> good thing too because it's probably not possible to determine what it "would be" or even talk about it, haha
09:43:51 <zygoloid> dankna: that's true. "CustardList []" is a polymorphic value which doesn't /have/ a type it 'would be'
09:44:02 <dankna> right
09:45:18 <dankna> trying this now
09:45:35 <zygoloid> dankna: for instance: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29222#a29223
09:46:24 <dankna> yeah - I'm currently trying the pattern (SomeCustardValue (CustardList maps@(CustardMap _ : _)))
09:47:04 <dankna> which itself is fine
09:47:20 <dankna> but then when I try to map across the list it gives me an error... hmm..
09:47:29 <dankna> I think I just need to implement my own map function, then
09:48:07 <dankna> (the error is "GADT pattern match in non-rigid context" and it suggests "add a type signature for the lambda expression" but hm)
09:50:04 <dankna> well, thanks, zygoloid
09:56:12 <napping> if f and g are functors, must (forall a . f a -> g a) be a natural transformation?
09:59:35 <bss03> @djinn (Functor f, Functor g) => f a -> g a
09:59:36 <lambdabot> Error: Class not found: Functor
09:59:44 <bss03> @djinn-env
09:59:45 <lambdabot> data () = ()
09:59:45 <lambdabot> data Either a b = Left a | Right b
09:59:46 <lambdabot> data Maybe a = Nothing | Just a
09:59:46 <lambdabot> data Bool = False | True
09:59:46 <lambdabot> data Void
09:59:47 <lambdabot> type Not x = x -> Void
09:59:49 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
09:59:51 <lambdabot> class Eq a where (==) :: a -> a -> Bool
10:00:20 <bss03> @djinn (Monad m, Monad n) => f a -> g a
10:00:21 <lambdabot> -- f cannot be realized.
10:00:30 <zygoloid> bss03: please don't use @djinn-env in the channel; privmsg lambdabot instead :)
10:00:45 <Jafet> @djinn-setenv
10:00:45 <lambdabot> Unknown command, try @list
10:00:47 <bss03> @djinn (Monad m, Monad n) => m a -> n a
10:00:48 <lambdabot> -- f cannot be realized.
10:00:55 <bss03> zygoloid: k
10:03:10 <zygoloid> napping: yes, that's a "free theorem" for that type, iirc
10:04:29 <zygoloid> @free f :: F a -> G a
10:04:30 <lambdabot> $map_G g . f = f . $map_F g
10:05:07 <napping> seems like it should be. Voigtl√§nder's tool doesn't know about Functor, though
10:05:30 <zygoloid> napping: ^^ here, $map_F and $map_G are the fmaps for functors F and G
10:15:36 <chrisdone> ciao guys
10:15:37 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
10:16:10 <Peasley> ohh
10:16:16 <Peasley> somebody send me too message
10:16:17 <Peasley> ^.^
10:16:32 <chrisdone> that was me, the contents reads, "Peasley smells"
10:17:04 <Peasley> you're evil :(
10:17:14 <ben_m> <3 Peasley 
10:17:20 <Peasley> :))
10:17:21 <dom96> lol
10:18:12 <chrisdone> has there been any work on named tuples or first class records? I don't know what you'd call it. so I can write (foobar=1,x=2) or somesuch? like a typesafe association list. iirc I read a post by spj about it some time ago but I can't find it
10:18:49 <ben_m> Why not use a type for that? 
10:18:54 <ben_m> Honest question, I suck at Haskell.
10:19:03 <zygoloid> chrisdone: like TRex in hugs?
10:19:15 <chrisdone> zygoloid: dunno
10:19:17 <chrisdone> @google trex hugs
10:19:19 <lambdabot> http://cvs.haskell.org/Hugs/pages/hugsman/exts.html
10:19:31 <zygoloid> hugs, man :)
10:19:47 * zygoloid hopes someone somewhere has 'hugsman' as their official job title
10:19:51 <chrisdone> hm, nice. exactly
10:21:11 <bos> dons: do you know where i'd report a binary haskell platform bug?
10:23:36 <napping> chrisdone: that's "extensible records" in the literature
10:25:17 <napping> MLPolyR and Daan Leijen's scoped labels are pretty nice\
10:25:40 <napping> We've already got type classe though, so has/lacks predicates wouldn't clutter up the type system too much more
10:26:19 <chrisdone> ben_m: arguably you probably shouldn't want to do this. a type is opaque and that's good. sometimes, though, you use a tuple to pass a bunch of things around but you forget what parts of the tuple contain what and so naming would be helpful. it's not a big problem
10:28:18 <chrisdone> createProcess returns (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
10:28:38 <chrisdone> arguably that would be easier to grok if it were a record
10:29:02 <zygoloid> i'm guessing (stdin, stdout, stderr, process) ?
10:29:02 <chrisdone> but it also might not deserve a full type and accessors "polluting" the namespace
10:29:46 * zygoloid isn't sure why GHC doesn't support TRex. perhaps it has some fatal flaw. it certainly /seems/ to pass the is-it-useful-enough test
10:30:00 <aristid> chrisdone: i think it does deserve a full record type, but of course these problems are real
10:30:07 <int80_h> entryFileName <- processPaths <$> getDirectoryContents d
10:30:18 <c_wraith> what is t-rex? :)
10:30:29 <int80_h> what is the <$> doing. I know it's fmap, but I don't see the functor associated with it.
10:30:31 <chrisdone> last I read, maybe it was in '08, SPJ just wasn't sure about which incantaion of records was a good idea, which people wanted, etc. I don't think much came of the mailing list thread
10:30:46 <zygoloid> "The problem is that the record design space is large, and seems to lack local optima. And all reasonable variants break backward compatibility. As a result, nothing much happens."
10:31:08 <chrisdone> :t fmap
10:31:08 <chrisdone> :t getDirectoryContents undefined
10:31:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:31:09 <lambdabot> Not in scope: `getDirectoryContents'
10:31:17 <chrisdone> :t System.Directory.getDirectoryContents undefined
10:31:18 <lambdabot> IO [FilePath]
10:31:25 <chrisdone> f a matches IO [FilePath]
10:31:47 <chrisdone> (a -> b) matches ([FilePath] -> b)
10:31:50 <chrisdone> f b matches IO b
10:32:04 <chrisdone> I don't know what type processPaths is, but in my typing it is [FilePath] -> b
10:32:13 <chrisdone> zygoloid: seems like it
10:32:24 <chrisdone> zygoloid: where's that from?
10:32:26 <int80_h> processPaths = map (d </>) . filter (`notElem` [".",".."])
10:32:43 <aristid> int80_h: would you understand entryFileName <- liftM processPaths getDirectoryContents d?
10:33:05 <zygoloid> there's word from SPJ in 1999: http://www.mail-archive.com/haskell@haskell.org/msg03623.html
10:33:18 <zygoloid> chrisdone: that was from here: http://www.haskell.org/haskellwiki/GHC:FAQ
10:33:58 <chrisdone> so [FilePath] -> [FilePath]
10:33:58 <chrisdone> Functor f => (a -> b) -> f a -> f b
10:33:59 <chrisdone> unifies with
10:33:59 <chrisdone> ([FilePath] -> [FilePath]) -> IO [FilePath] -> IO [FilePath]
10:34:01 <chrisdone> thus you have your functorness
10:34:20 <int80_h> aristid - I will take a shot. processPaths getDirectoryContents d gives a result in a monad. liftM moves that into the monad containing that monad, then binds the result to entryFileName
10:34:27 <int80_h> aristid: is that close?
10:34:29 <zygoloid> int80_h: the functor associated with that <$> is IO
10:34:46 <aristid> int80_h: ok, and now note that (<$>) = fmap = liftM for all monads.
10:34:54 <zygoloid> int80_h: that's close but not quite right
10:35:09 <int80_h> zygoloid : please correct my understanding.
10:35:10 <zygoloid> (as was aristid's question actually)
10:35:29 <chrisdone> int80_h: what I said doesn't make sense?
10:35:32 <aristid> zygoloid: huh?
10:35:43 <zygoloid> int80_h: in "liftM processPaths (getDirectoryContents d)", getDirectoryContents d gives a result in a monad. liftM applies processPaths within that monadic result
10:35:53 <zygoloid> aristid: missing parens around getDirectoryContents d :)
10:35:59 <aristid> zygoloid: damn :D
10:36:08 <int80_h> chrisdone : no, but I'm fuzzy on some of the notation. I cpy pasted what you said for further digestion.
10:36:15 <wakeupsticky> hi all :)
10:37:38 <chrisdone> int80_h: which notation?
10:37:48 * chrisdone wacks wakeupsticky with a wake up stick
10:37:48 <int80_h> you know, I've learned more complicated stuff, which doesn't seem so complicated as I go on, by taking on projects just above my current ability.
10:38:02 <int80_h>  chrisdone : hold on I will show you
10:38:39 <int80_h> chrisdone: Functor f => (a -> b) -> f a -> f b
10:38:39 <int80_h> 10:33 < chrisdone> unifies with
10:38:40 <int80_h> 10:33 < chrisdone> ([FilePath] -> [FilePath]) -> IO [FilePath] -> IO [FilePath]
10:38:50 <wakeupsticky> *wakes up*
10:38:51 <int80_h> I don't know what that means.
10:38:52 <wakeupsticky> ow
10:39:27 <wakeupsticky> hey, are the packages that run on top of wxHaskell ready to go, or should I learn wxHaskell itself (GUI on Windows)?
10:40:03 <int80_h> @hoogle getopt
10:40:04 <lambdabot> module System.Console.GetOpt
10:40:04 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
10:40:04 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
10:41:05 <int80_h> should I know how to use a function by looking at it's description? Because I don't know how to use GetOpt just by looking at the above.
10:41:42 <chrisdone> int80_h: I just mean that it type matches. the fmap function works on all instances of Functor. IO is an instance of functor, and so for fmap :: Functor f => (a -> b) -> f a -> f b, when you use it to return an IO b value, the type checker would replace every f with IO
10:42:03 <zygoloid> int80_h: well, the type certainly gives a lot of hints
10:42:06 <chrisdone> so you get fmap :: (a -> b) -> IO a -> IO b
10:42:30 <ddarius> int80_h: You could program in python instead and not even have a type.
10:42:41 <zygoloid> int80_h: i'm guessing the third argument is a list of command-line arguments. and the first and second are a description of know flags and switches. not sure what the result means though
10:42:47 <int80_h> ddarius : that hurt.
10:42:51 <int80_h> ;)
10:43:35 <benmachine> int80_h: just having the typesig won't tell you the difference between break and span
10:43:42 <wakeupsticky> yeah, and your programs would only be about 100x slower...
10:43:43 <benmachine> or partition indeed
10:43:45 <chrisdone> int80_h: can Integer be an instance of Functor?
10:43:52 <int80_h> oh I found someone who uses examples in his blog. It's alot simpler than the type suggests.
10:44:06 <int80_h> :t Integer
10:44:07 <lambdabot> Not in scope: data constructor `Integer'
10:44:20 <int80_h> @hoogle Integer
10:44:20 <lambdabot> Text.Parsec.Token integer :: GenTokenParser s u m -> ParsecT s u m Integer
10:44:20 <lambdabot> Text.PrettyPrint.HughesPJ integer :: Integer -> Doc
10:44:21 <lambdabot> Language.Haskell.TH.PprLib integer :: Integer -> Doc
10:44:29 <chrisdone> int80_h: it's a type.
10:44:29 <chrisdone> :t 1 :: Integer
10:44:30 <lambdabot> Integer
10:44:53 <int80_h> chrisdone: I haven't seen any evidence that it can be an instance of functor
10:44:57 <zygoloid> data Prelude.Integer = {- it's a secret! -}
10:45:15 <copumpkin> S# and J# :P
10:45:16 <ben_m> I must know the secret.
10:45:21 <zygoloid> copumpkin: ssh!
10:45:27 <copumpkin> zygoloid: scp!!
10:45:34 <chrisdone> int80_h: what's the definition of the Functor instance?
10:45:35 <zygoloid> copumpkin: sftp!!!
10:45:42 <chrisdone> int80_h: sorry, the Functor class
10:45:47 <copumpkin> zygoloid: tftp :(
10:45:47 <int80_h> :t Functor
10:45:48 <lambdabot> Not in scope: data constructor `Functor'
10:45:48 <duckinator> hi
10:45:56 <chrisdone> @src Functor
10:45:57 <lambdabot> class  Functor f  where
10:45:57 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
10:46:17 <int80_h> chrisdone: fmap        :: (a -> b) -> f a -> f b is the type
10:47:06 <chrisdone> int80_h: can you write a Char instance?
10:47:31 <int80_h> chrisdone, never tried
10:47:56 <int80_h> :hoogle Char
10:48:01 <int80_h> @hoogle Char
10:48:01 <lambdabot> module Data.Char
10:48:01 <lambdabot> module Text.Parsec.Char
10:48:02 <lambdabot> module Text.ParserCombinators.Parsec.Char
10:48:10 <int80_h> @src Char
10:48:11 <lambdabot> data Char = C# Char#
10:48:20 <int80_h> I have no idea what that is saying
10:48:26 <int80_h> new notation
10:48:34 <chrisdone> ignore that, Char is a standard type for characters
10:48:41 <chrisdone> :t 'a'
10:48:42 <lambdabot> Char
10:48:50 <chrisdone> :t "sausages"
10:48:52 <lambdabot> [Char]
10:49:30 <int80_h> chrisdone: I will then say that it is not possible to write an instance for Char.
10:49:37 <chrisdone> int80_h: why?
10:49:52 <monochrom> :t "[Char]"
10:49:53 <lambdabot> [Char]
10:50:03 <int80_h> because it is not a class. You can only instanciate type clases.
10:50:38 <chrisdone> are you reading a Haskell book?
10:51:10 <int80_h> eep, that's not good. Sort of. I use RWH but not reading it sequentially. I'm totaly off base then?
10:51:31 <chrisdone> int80_h: well, I'll clarify. can you write a Char instance for Functor. maybe you thought I meant something else
10:52:26 <chrisdone> Functor is a type class, Char is a type
10:53:20 <int80_h> chrisdone: well just based on that I would say yes you can. But I don't really understand functors. I just learned yesterday that Functors were a typeclass.
10:53:44 <ddarius> Functor is a type -constructor- class.
10:54:03 <int80_h> okay what does that mean?
10:54:23 <danharaj> int80_h: Do you know what a type constructor is?
10:55:48 <int80_h> danharaj : you know, I thought I did. Then you ask me if I do, and I cannot think of the definition.
10:56:09 <int80_h> I would have to look it up on LYAH
10:56:15 <danharaj> It's a 'thing' that makes a new type out of an old type.
10:56:20 <zygoloid> like Maybe
10:56:27 <int80_h> oh!
10:56:30 <danharaj> [] is a type constructor. It takes a type and makes the type of lists whose elements are that type.
10:56:33 <newsham> int80: they are parameterized types. like "List of ..."  or "Optional value of ..."
10:56:33 <int80_h> or say, newtype?
10:56:46 <chrisdone> newtype is a different concept
10:56:50 <danharaj> newtype is on the meta level
10:57:18 <int80_h> gotcha
10:57:27 <danharaj> so Functor is a type constructor class
10:58:27 <chrisdone> :t Just 'a'
10:58:27 <chrisdone> :t ['a']
10:58:27 <chrisdone> :t (\_ -> 'a')
10:58:28 <lambdabot> Maybe Char
10:58:28 <lambdabot> [Char]
10:58:28 <lambdabot> forall t. t -> Char
10:58:54 <int80_h> so any type that is a Functor, is a type constructor.
10:58:56 <chrisdone> Maybe, [], and (->Char) are the type constructors here
10:59:11 <newsham> the other thing about functors is that they have a function of type    a -> f a   called map (fmap)
10:59:21 <zygoloid> (t->) is a type constructor, (->Char) is not
10:59:29 <newsham> so those are the two parts that make up a functor.  its not a very complex concept.
10:59:30 <chrisdone> int80_h: any instance of Functor is a type constructor, sure
10:59:58 <danharaj> that is not map
11:00:00 <zygoloid> and the map's type is (a -> b) -> f (a -> b)
11:00:05 <zygoloid> no
11:00:14 <zygoloid> (a -> b) -> f a -> f b
11:00:16 <int80_h> newsham : I'll concede that. But I am a bear of very little brain.
11:00:24 * zygoloid fail
11:00:48 <chrisdone> zygoloid: woops
11:01:11 <newsham> int80: nah, you can get the concept.. just let it sink in.  "its a parameterized type "F a" with a function "fmap :: a -> F a")
11:01:27 <danharaj> except that is not the type of fmap
11:01:28 <zygoloid> newsham: not a -> F a
11:01:33 <danharaj> that would be the type of 'return' or 'pure'
11:01:36 <chrisdone> zygoloid: I was probably thinking ((->) Char)
11:01:39 <danharaj> which is more structure.
11:01:41 <int80_h> newsham: I'll get it. It makes sense now. I will log this chat, for reference.
11:01:50 <zygoloid> chrisdone: i guessed as much :) esp. since ghc doesn't do type sections ;(
11:01:56 <int80_h> for the day I try to use what I htink I know.
11:01:56 <chrisdone> ;_;
11:02:24 <wakeupsticky> i just downloaded the haskell platform for windows as well as wxHaskell
11:02:30 <newsham> oops.. zygoloid, thakn you.. my bad.
11:02:40 <newsham> fmap   (a -> b) -> (F a -> F b)
11:02:43 <wakeupsticky> do i need to download the graphics package(s) that wx imports?
11:02:43 <newsham> guy!
11:02:54 <newsham> int80: forget my "a -> F a" thing :)
11:03:29 <newsham> > fmap (+1) [1,2,3,4]
11:03:30 <lambdabot>   [2,3,4,5]
11:03:35 <newsham> > fmap (+1) (Just 5)
11:03:35 <chrisdone> zygoloid: I was happy to learn it does support flexible type aliases with an extension. for type List a = [a], you could write type List2 = List. I think. can't remember now
11:03:36 <lambdabot>   Just 6
11:04:05 <danharaj> wakeupsticky: have you already tried to use cabal install to get wxhaskell?
11:04:30 <wakeupsticky> no. i downloaded the tar.gz or gz.tar or whatever it was. :)
11:04:34 <zygoloid> chrisdone: LiberalTypeSynonyms
11:04:43 <wakeupsticky> i suppose i should have used cabal?
11:04:50 <int80_h> nesham: cool. okay I am on this blog that says I can "import System" to them use getArgs. But ghc claims to not be able to find it.
11:04:51 <wakeupsticky> i am on windows if it matters.
11:04:55 <zygoloid> basically gives you open season on type synonyms
11:05:00 <chrisdone> zygoloid: yeah I remember the name, but not if what I said was right
11:05:01 <int80_h> it being the module System.
11:05:08 <danharaj> wakeupsticky: well you ought to. trust me, straying from the path especially on windows will bite you in the ass
11:05:11 <int80_h> @hoohle getargs
11:05:11 <lambdabot> System.Environment getArgs :: IO [String]
11:05:29 <danharaj> sometimes you'll get screwed even when doing everything as you should
11:05:30 <wakeupsticky> okay, i will go forth and look into cabal
11:05:33 <danharaj> just gotta deal with it
11:05:41 <danharaj> haskell platform comes with it so you'll be set once you figure it out
11:05:53 <newsham> > fmap (!! 1) getArgs
11:05:54 <lambdabot>   Not in scope: `getArgs'
11:06:03 <newsham> > fmap (!! 1) System.Environment.getArgs
11:06:04 <zygoloid> chrisdone: iirc it basically removes /all/ restrictions other than that they be well-kinded
11:06:04 <lambdabot>   Not in scope: `System.Environment.getArgs'
11:06:07 <newsham> boo
11:06:10 <int80_h> I figued it out. This blog is outdated.
11:06:21 <int80_h> what does kind mean?
11:06:31 <int80_h> or, "what are kinds".
11:06:38 <chrisdone> zygoloid: yeah. seems only the restrictions were imposed by haskell98 and not for a soundness reason
11:06:57 <wakeupsticky> ah, i see a cabal pdf in the docs folder...i will read that
11:06:59 <newsham> int80: so functors are "parameterized types", you can think of them as a function from one type to another.
11:07:07 <newsham> "kind" is the "type" of the type level function
11:07:15 <chrisdone> kinds describe the arite of a type constructor
11:07:16 <newsham> ?kind Maybe
11:07:17 <lambdabot> * -> *
11:07:21 <chrisdone> er, arity
11:07:30 <newsham> ?kind Arrow
11:07:31 <lambdabot> Class `Arrow' used as a type
11:07:38 <newsham> oops thats a class :)
11:08:13 <newsham> ?kind State
11:08:14 <lambdabot> * -> * -> *
11:08:26 <chrisdone> :k Integer
11:08:27 <lambdabot> *
11:08:33 <newsham> ?kind Maybe Integer
11:08:34 <lambdabot> *
11:09:13 <zygoloid> ?kind ReaderT
11:09:14 <lambdabot> * -> (* -> *) -> * -> *
11:09:45 <wakeupsticky> so just so i know i'm on the right track, i am trying to make a simple gui app that will run on windows...is reading through the cabal documentation the right first step? then using that knowledge to get wxHaskell set up?
11:11:34 <c_wraith> @kind RWST
11:11:36 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
11:11:48 <c_wraith> There must be some more amusing kinds \bot knows about
11:12:02 <c_wraith> I want a monad transformer transformer
11:12:20 <int80_h> what's a monad transformer?
11:12:36 <int80_h> I've read about it, but like it when people explain things here.
11:13:06 <g_cross> int80_h:  A monad transformers is a monad that wraps another monad.
11:13:22 <g_cross> int80_h:  It is a map from one monad to another.
11:13:30 <int80_h> g_cross : why does one need to do that? Can you give an application?
11:13:33 <zygoloid> a monad transformer imbues a monad with additional powers
11:13:39 <int80_h> ah1!
11:13:56 <newsham> int80: sometimes you want the charateristics of several monads.  monad transformers let you compose them together a little bit.  its still kinda messy :(
11:14:03 <c_wraith> StateT is a common one.  It lets you implicitly pass state around in computations involving another monad.
11:14:09 <zygoloid> so "ReaderT r m" is just like the monad m, except that it implicitly also carries around a value of type r
11:14:09 <g_cross> int80_h: Yes.  Suppose you want to have implicit state while working in the IO monad.  Then you use the StateT monad transformers to wrap the IO monad to give you access both to an implicit state *and* to IO.
11:14:21 <ezyang> Is there a way to do something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29224#a29224 
11:14:28 <ezyang> (I'm trying to implement typeclass synonyms) 
11:14:33 <g_cross> int80_h:  There is a function "lift" that can be used in the wrapper monad to access the wrapped monad.
11:14:55 <edwardk> c_wraith: i think the worstkind i ever let into production code was: class HComposition  	(o :: ((* -> *) -> * -> *) -> ((* -> *) -> * -> *) -> ((* -> *) -> * -> *)) where
11:15:06 <zygoloid> ezyang: class (Foo1 a, Foo2 a) => Bar a; instance (Foo1 a, Foo2 a) => Bar a
11:15:18 <zygoloid> ezyang: that lets you use Bar a as a synonym for (Foo1 a, Foo2 a)
11:15:42 <edwardk> c_wraith: that is in Control.Functor.HigherOrder.Composition, but I don't think lambdabot knows about it =/
11:15:46 <ezyang> zygoloid: The problem is that the parameters I'm doing the typeclass over have different kinds. 
11:16:01 <zygoloid> ezyang: ok, i'm not sure what you want then ;)
11:16:17 <ezyang> m is * -> * -> *, but with FooOne Bar I want Bar to be * -> * 
11:16:20 <wakeupsticky> okay, so it looks like i need to download the wxHaskell package, unpack it into some folder, get into a cmd prompt, navigate to that directory, and issue some runhaskell commands
11:16:22 <edwardk> ezyang has gone a little crazy lately ;)
11:16:26 <wakeupsticky> i will do that and report back
11:16:28 <ezyang> where type Bar = Foo Int or something 
11:16:32 <ezyang> edwardk: I am not crazy!! 
11:16:41 <copumpkin> ezyang: right
11:16:55 <copumpkin> we all know the truth
11:16:58 <g_cross> Slightly off-topic, but can anyone here explain to me what the point of a logic programming language like Curry is?  I get the basic gist, which is that it contains searching functionality within the language, but it isn't clear to me what this buys us over the searches we can already do in functional languages.
11:16:58 <edwardk> ezyang: that sounds like something a crazy person would say ;)
11:17:04 <zygoloid> ezyang: i think the problem you're having is most likely because in FooTwo the kind of m is deduced as * rather than * -> *?
11:17:24 <ezyang> zygoloid: Well, the paste doesn't even syntax-check. 
11:18:08 <sproingie> g_cross: the searching functionality is largely what it's all about.  you could do it in functional languages, but you have to do it by hand.
11:18:21 <zygoloid> ezyang: oh, i see :)
11:18:36 <ezyang> So, in practice, Foo is actually an associated type, and I want to be able to elide having to write Foo TheRealData when I specialize the interface. 
11:18:49 <ezyang> to be TheRealFoo or something. 
11:19:19 <ezyang> yeah, I've completely gone off the deep end. 
11:19:50 <copumpkin> ezyang: that's what haskell does to you
11:19:57 <copumpkin> I bet you regret learning it now!
11:20:00 <sproingie> tho curry in particular is already a full blown functional language
11:20:08 <ezyang> Ooh, I wonder if I could write a type function that goes in the opposite direction... 
11:20:16 <sproingie> cotype?
11:20:19 <ezyang> Better Dead than Zed! 
11:20:24 <ezyang> Something like that. 
11:20:43 <int80_h> how can I put an IO String into IO (), lift?
11:21:05 <zygoloid> ezyang: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29224#a29226
11:21:11 <int80_h> @hoogle lift
11:21:11 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
11:21:12 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
11:21:12 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
11:21:14 <ezyang> so I do something like (CoFoo m b mb, FooTwo m b x) => FooOne mb x 
11:21:24 <aristid> :t (>> return ())
11:21:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
11:21:29 <g_cross> sproingie:  True, but using something like the ListT monad seems to already get you searching with backtracking, and searching over all possible constructors is something that is just boilerplate that could be generated by Template Haskell.
11:21:29 <aristid> int80_h: ^
11:21:36 <ezyang> Oh man! 
11:21:38 <ezyang> Even better! 
11:21:52 <g_cross> sproingie:  It almost seems to me that something like Curry could be implemented as a library in Haskell, rather than its own language.
11:21:58 <zygoloid> i was a little surprised that worked, to be honest. hooray for type families
11:22:04 <int80_h> aristid : ssay hwat?
11:22:17 <wakeupsticky> so i have wxHaskell unzipped in C:\Users\Jesse\HaskellPackages\wxHaskell
11:22:23 <aristid> int80_h: x >> return () does the trick.
11:22:26 <int80_h> arisitd: oh you mean use return?
11:22:28 <wakeupsticky> i then navigated to that directory in my cmd prompt
11:22:32 <int80_h> gotcha
11:22:40 <wakeupsticky> and entered 
11:22:41 <aristid> :t fmap (const ())
11:22:42 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ()
11:22:44 <g_cross> sproingie: (I don't mean to be critical, I'm just trying to see what it is that I am missing that could make programming in a logic language like Curry more pleasant than solving the same problem in Haskell.)
11:22:47 <aristid> int80_h: this works too.
11:22:57 <wakeupsticky> runhaskell Setup.hs configure --ghc
11:23:02 <sproingie> g_cross: i think curry touches on things like type notation that isn't all that amenable to being a library.  i'm not really that familiar with curry tho
11:23:20 <wakeupsticky> "(no location info: can't find file: Setup.hs"
11:23:37 <wakeupsticky> however, Setup.hs is right there
11:23:45 <wakeupsticky> do i need to type the full path? i'll try that now
11:23:46 <int80_h> > main = do
11:23:46 <int80_h> > args <- getArgs
11:23:47 <lambdabot>   <no location info>: parse error on input `='
11:23:47 <lambdabot>   not an expression: `args <- getArgs'
11:23:47 <int80_h> > return $ show args
11:23:48 <lambdabot>   Not in scope: `args'
11:24:04 <int80_h> arisitd: since I am using do, is that not the equivilant to what you said?
11:24:15 <aristid> no.
11:24:38 <djahandarie> :t (>>)
11:24:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
11:24:43 <zygoloid> int80_h: that gives main the type IO String, since return $ show args has that type
11:24:54 <zygoloid> main is required to have the type IO ()
11:24:56 <djahandarie> :t return ()
11:24:58 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
11:25:08 <djahandarie> :t (>> return ())
11:25:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
11:27:08 <int80_h> okay it looks like I need to put a String into an IO monad. What would I use to do that?
11:27:22 <zygoloid> return
11:27:29 <int80_h> show args >> return ()
11:27:35 <int80_h> I'm doing that ^^^
11:27:38 <int80_h> I get this error
11:27:45 <zygoloid> int80_h: what do you want to /happen/ to 'show args'?
11:27:47 <int80_h> Couldn't match expected type `IO a' against inferred type `String'
11:27:47 <Botje> >> needs an IO <something> on the left hand side
11:27:52 <zygoloid> show args is just a String
11:27:57 <djahandarie> return (show args) >> return ()
11:27:58 <Botje> String != IO <something>
11:28:01 <djahandarie> Although that'd do a whole lot of nothing
11:28:17 <int80_h> oooh
11:28:18 <zygoloid> int80_h: do you want 'print' or something like that?
11:28:22 <djahandarie> putStrLn (show args) >> return () would do more
11:28:35 <zygoloid> if you did that you wouldn't even need the >> return ()
11:28:36 <djahandarie> And \x -> putStrLn (show x)   is also known as print
11:28:43 <Wooga> what the difference between State and Reader monads?
11:28:46 <int80_h> yes, but I was trying to construct this one step at a time. I do want to print, for now.
11:28:55 <zygoloid> Wooga: State lets you change the value for the rest of the computation
11:28:59 <Botje> Wooga: reader can't pass state back up
11:29:07 <Wooga> thanks!
11:29:11 <wakeupsticky> the runhaskell command can't find a file that definitely exists...?!
11:29:21 <zygoloid> Wooga: Reader is therefore lazier since later actions don't need to care about earlier actions' state transformations
11:29:49 <djahandarie> @faq Can Haskell find a file that doesn't exist?
11:29:50 <lambdabot> The answer is: Yes! Haskell can do that.
11:30:00 <djahandarie> Not sure about not finding a file that does exist though ;)
11:30:01 <wakeupsticky> lol
11:30:19 <wakeupsticky> i downloaded the wxHaskell package and unpacked it
11:30:29 <zygoloid> > runReader (fix (>> return ()) >> ask) 42
11:30:30 <lambdabot>   42
11:30:31 <zygoloid> > evalState (fix (>> return ()) >> get) 42
11:30:35 <lambdabot>   mueval-core: Time limit exceeded
11:30:42 <wakeupsticky> navigated to that directory and tried: runhaskell Setup.hs configure --ghc
11:30:45 <djahandarie> That's a neat example
11:31:06 <wakeupsticky> "(no location info): can't find file: Setup.hs"
11:31:30 <wakeupsticky> but it's right there and i'm in the right directory
11:32:15 <aristid> :t fix (>> return ())
11:32:16 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
11:32:36 <aristid> > runReader (fix (>> return ())) 42
11:32:37 <lambdabot>   ()
11:32:47 <wakeupsticky> runghc and runnhc don't work
11:32:50 <wakeupsticky> nor does runhugs
11:34:59 <cncl> where is ++ a synonym for mappend? is it defined in some module?
11:35:21 <aristid> cncl: in lambdabot's code. it isn't normal
11:35:27 <cncl> oh ok
11:35:31 <sshc> > let (+++++++) = mappend
11:35:33 <lambdabot>   not an expression: `let (+++++++) = mappend'
11:35:36 <aristid> cncl: we call it Caleskell
11:35:39 <sshc> @let (+++++++) = mappend
11:35:40 <lambdabot>  Defined.
11:35:48 <mauke> > [] ‚ß∫ []
11:35:49 <lambdabot>   Not in scope: `‚ß∫'
11:35:57 <mauke> @let (‚ß∫) x = mappend x
11:35:58 <lambdabot>  Defined.
11:36:02 <wakeupsticky> is there a channel for haskell noobs to get help?
11:36:06 <aristid> > "sshc" +++++++ " IS A COOKIE"
11:36:07 <lambdabot>   "sshc IS A COOKIE"
11:36:28 <cncl> +++++++ doesn't save much space over mappend!
11:36:53 <djahandarie> wakeupsticky, this is the place
11:37:00 <sshc> cncl: Where is "aGoodfunction" defined as "pred"? ;)
11:37:12 <djahandarie> I have no experience with wxHaskell and I'm not sure why your runhaskell can't find files in your directory though
11:37:37 <newsham> ?type (++) . (+++++++) . (+)
11:37:38 <lambdabot> forall a. (Monoid a, Num a) => a -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a
11:37:55 <wakeupsticky> i can double-click the Setup.hs file and it runs in a command prompt.
11:38:10 <cncl> i was wondering if there was a standard place people who use the monoid typeclass imported a (++) synonym from or something
11:38:25 <cncl> since i use `mappend` a lot, and it's not a very succinct name
11:38:33 <wakeupsticky> GHCi, version 6.12.1
11:38:39 <wakeupsticky> i tried runghci as well; same message
11:39:01 <wakeupsticky> (no location info): can't find file: Setup.hs
11:39:19 <aristid> cncl: set (<>) = mappend in a util module of yours
11:39:36 <zygoloid> wakeupsticky: sounds weird, like it's running in the wrong working directory
11:39:49 <djahandarie> wakeupsticky, try providing a direct path to the file
11:39:56 <zygoloid> wakeupsticky: random thought -- is runghc on the same drive as Setup.hs?
11:40:00 <wakeupsticky> djahandarie, tried that, same message :(
11:40:10 <cncl> aristid: <> is the standard for mappend? :)
11:40:15 <cncl> (i have no clue)
11:40:20 <aristid> cncl: it seems to be relatively popular
11:40:20 <wakeupsticky> i will find runghc in the Haskell Platform folder?
11:40:22 <zygoloid> cncl: there's a proposal to add (<>) = mappend to base
11:40:30 <zygoloid> wakeupsticky: i assume so
11:40:34 <cncl> i've seen it in the PP module before i think
11:40:35 * zygoloid isn't on windows
11:40:52 <Gracenotes> @hoogle <>
11:40:53 <djahandarie> There aren't many Windows+Haskell people in this channel afaik
11:40:53 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
11:40:53 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
11:40:59 <zygoloid> cncl: there's (<>) in Data.Seq and Data.FingerTree, where it's a special-case mappend
11:41:10 <cncl> cool, i will call it that
11:41:17 <djahandarie> > (text "lol") <> (text "wut")
11:41:19 <lambdabot>   lolwut
11:41:22 <djahandarie> ;)
11:41:26 <wakeupsticky> runghc's path is: C:\Program Files\Haskell Platform\2010.1.0.0\bin\runghc
11:41:37 <zygoloid> @hoogle Seq a -> Seq a -> Seq a
11:41:38 <lambdabot> Data.Sequence (><) :: Seq a -> Seq a -> Seq a
11:41:38 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
11:41:38 <lambdabot> Data.Sequence (|>) :: Seq a -> a -> Seq a
11:41:49 <wakeupsticky> the setup file's path is: C:\Users\Jesse\HaskellPackages\wxHaskell\Setup.hs
11:41:49 <zygoloid> huh, looks like i had it backwards :)
11:42:05 <wakeupsticky> do i need to put the setup file in the same folder as runghc?
11:42:23 <zygoloid> wakeupsticky: you should not need to.
11:42:33 <cncl> so i should use <> and not >< right :)
11:42:35 <wakeupsticky> so they are both on the C drive
11:42:47 <wakeupsticky> maybe i should try reinstalling the haskell platform and wxHaskell
11:43:01 <rluijk> Can someone explain to me what this error implies?:   Couldn't match expected type `a -> [a1]'            against inferred type `[a2]'     In the second argument of `(.)', namely `reverse xs'     In the second argument of `(.)', namely `tail . reverse xs'     In the second argument of `(.)', namely         `reverse . tail . reverse xs'
11:43:02 <wakeupsticky> i will do that and see if it works then
11:43:07 <zygoloid> wakeupsticky: it's worth a go
11:43:11 <djahandarie> If you already have wxHaskell installed then just use cabal to get wx
11:43:17 <djahandarie> cabal install wx
11:43:21 <Botje> rluijk: try reverse . tail . reverse $ xs
11:43:23 <newsham> right click on .hs file, select "open with -> choose program", find runghc, check the "always open with this program" checkbox ?
11:43:32 <zygoloid> rluijk: it means you wrote something . reverse xs, and you meant something $ reverse xs
11:43:41 <copumpkin> Botje: or just init
11:43:51 <Botje> where's the fun in that :p
11:43:54 <copumpkin> :P
11:44:06 <newsham> (reverse . tail . reverse) xs   isnt    (reverse . tail . reverse xs)
11:44:24 <zygoloid> rluijk: it's saying, it saw "something . reverse xs" and deduced that "reverse xs" must be a function (a -> [a1]). but it knows that "reverse xs" is of type [a2]. and those types don't match.
11:44:26 <wakeupsticky> Config file C:\Users\AppData\Roaming\Cabal\config not found
11:44:28 <int80_h> @hoogle getContents
11:44:29 <lambdabot> Prelude getContents :: IO String
11:44:29 <lambdabot> Data.ByteString getContents :: IO ByteString
11:44:29 <lambdabot> System.IO getContents :: IO String
11:44:51 <wakeupsticky> cabal: There is no package named wx. Perhaps you need to run cabal update first?
11:44:55 <wakeupsticky> i suppose i will run cabal update
11:44:59 <djahandarie> Yes
11:45:15 <wakeupsticky> Downloading...
11:45:58 <wakeupsticky> running "cabal install cabal-install" (heh)
11:46:40 <wakeupsticky> that should have a caballinstall keyword argument
11:46:47 <wakeupsticky> "cabal install cabal-install caballinstall"
11:47:18 <Gracenotes> upload cabalinstall to package and that would be valid
11:47:24 <Gracenotes> hackage
11:47:31 <wakeupsticky> heheh
11:47:47 <djahandarie> It's usually a bad idea to do that
11:47:51 <wakeupsticky> ok, caball install wx worked
11:48:13 <wakeupsticky> but then why did the caball pdf guide have me doing something else? it didn't say anything about "cabal install" commands
11:48:20 <wakeupsticky> i just got that from you, dj
11:48:33 <geheimdienst> cabal install llatsni labac
11:48:35 <djahandarie> "cabal install cabal-install" specifically is a bad idea
11:48:38 <wakeupsticky> maybe i didn't read far enough because i got to that point and it didn't work?
11:49:10 <c_wraith> I've never had a problem with cabal install cabal-install
11:49:14 <wakeupsticky> now here's a funny error message
11:49:21 <sm> djahandarie: why ?
11:49:25 <c_wraith> Except when I was using haskell platform.
11:49:30 <ezyang> cabal install cabal-install should be fine... 
11:49:36 <djahandarie> You can get stuck with multiple versions of cabal-install
11:49:38 <ezyang> in particular, it will install it in .cabal 
11:49:39 <c_wraith> And it installed cabal to a different spot than cabal installs it to
11:49:46 <ezyang> As long as your PATH is correct... 
11:49:50 <c_wraith> djahandarie, that's only an issue if you use platform.
11:49:50 <rluijk> ok thanks
11:49:52 <Gracenotes> the problems are when packages exist both locally and in your system
11:49:57 <wakeupsticky> wx-0.12.1.6 depends on wxcore-0.12.1.6 which failed to install.
11:50:02 <djahandarie> c_wraith, which is the recommended way of installing Haskell
11:50:06 <djahandarie> c_wraith, and also the way he is doing it
11:50:12 <djahandarie> Which is why I said it's a bad idea
11:50:17 <wakeupsticky> The exception was: ExitFailure 1
11:50:28 <wakeupsticky> also:
11:50:28 <djahandarie> wakeupsticky, does it say why wxcore failed?
11:50:29 <c_wraith> I don't recommend platform to anyone.
11:50:37 <c_wraith> Mostly because it makes a lot of things harder.
11:50:40 <wakeupsticky> setup.exe: wx-config: does not exist
11:50:45 <wakeupsticky> that could be why
11:50:57 <djahandarie> wakeupsticky, then get wx-config http://wxconfig.googlepages.com/
11:51:15 <djahandarie> cabal install cabal-install can also cause problems if your distro provides cabal-install
11:51:46 <wakeupsticky> so i can just put that anywhere as long as i add that location to PATH?
11:51:53 <wakeupsticky> (i will probably put it with the other wx stuff)
11:52:32 <djahandarie> That seems to be the provided instruction on that page
11:52:33 <wakeupsticky> although now i don't know where that stuff really is, since i downloaded the zipped package manually and put it in a folder i made for it
11:52:38 <wakeupsticky> i don't know where cabal put it
11:52:45 <wakeupsticky> let me look at the output i got from cabal
11:52:57 <wakeupsticky> src/haskell
11:53:20 <djahandarie> I can't tell if it's telling you to change your PATH environment variable or put it where you are running cabal
11:54:07 <wakeupsticky> "Copy wx-config.exe to anywhere in your path"
11:54:23 <wakeupsticky> looks like it can reside anywhere as long as i add that location to the path, but not positive
11:54:36 <wakeupsticky> their wording isn't right
11:54:43 <djahandarie> Normally the word "path" would be capitialized if it were talking about the environment variable
11:54:57 <wakeupsticky> then maybe that's not it...
11:55:03 <rluijk> newsham thanks!
11:55:19 <wakeupsticky> so it means a haskell path?
11:55:23 <djahandarie> I think it means just put it where you are running cabal
11:55:54 <wakeupsticky> well, the cabal command worked for me when i was in the folder i created for the wxHaskell package that i just unzipped
11:56:14 <wakeupsticky> though i'm slightly confused as to whether i need those files now that i did "cabal install wx"
11:56:50 <wakeupsticky> i just went to the wxHaskell page and downloaded the tar.gz and unzipped it to a folder i made
11:56:50 <djahandarie> Where did you get the files from?
11:57:01 <wakeupsticky> http://hackage.haskell.org/package/wx
11:57:03 <wakeupsticky> bottom of page
11:57:13 <djahandarie> Yeah, you never need to do that if you are using cabal
11:57:18 <wakeupsticky> ah, ok
11:57:25 <wakeupsticky> maybe i should delete that directory?
11:57:29 <djahandarie> Sure
11:57:34 <doofer> making a haskell library; is there a way to automatically get what dependencies it has?
11:57:45 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29227#a29227
11:57:50 <Gracenotes> from the source?
11:57:56 <int80_h> type matching goodness.
11:58:05 <djahandarie> Gracenotes, I think he means modules -> packages
11:58:18 <Gracenotes> well, making a cabal file
11:58:34 <wakeupsticky> all right, i just deleted that folder
11:58:36 <djahandarie> Yeah, cabal install will tell you that you are trying to use something you don't have listed as a dependency
11:58:37 <aristid> int80_h: print x is IO () already
11:58:43 <wakeupsticky> so what about just doing "cabal install wxHaskell"?
11:58:45 <wakeupsticky> instead of just wx
11:58:47 <aristid> no need to append >> return () after it
11:59:00 <djahandarie> wakeupsticky, wxHaskell isn't a package
11:59:01 <wakeupsticky> or is the package actually called wx?
11:59:11 <wakeupsticky> ok
11:59:35 <int80_h>  aristid : still getting error  Couldn't match expected type `[Char]' against inferred type `IO Char
11:59:48 <Gracenotes> you can get all of the modules loaded when compiling a package, but not all of them are /direct/ dependencies
11:59:53 <djahandarie> aristid, that's because <- helps you extract something out of the monad
11:59:56 <int80_h> if I move Char out of IO I've still got a mismatch
12:00:02 <wakeupsticky> ok, so as for wx-config, i'm not sure exactly where it needs to be
12:00:15 <wakeupsticky> you said where i'm runnin cabal from...i will look in the haskell platform folder for cabal
12:00:16 <djahandarie> aristid, while head unprocessed isn't in IO
12:00:20 <doofer> thanks djahandarie
12:00:24 <ezyang> What should I call the k in "data family GMap k"? FamilyIndex? AssocIndex? FamilyParam? 
12:00:29 <aristid> djahandarie: you mean int80_h?
12:00:35 <djahandarie> Err yeah, int80_h*
12:01:04 <djahandarie> wakeupsticky, not where cabal is, just where you are running the command from
12:01:18 <int80_h> djahandarie : then I could use return to put it in IO right?
12:01:24 <wakeupsticky> oh, you mean re-run the cabal install wx command from the directory that i put wx-config in
12:01:27 <Gracenotes> doofer: the main problem with that approach is that you'll have to do it over and over again
12:01:36 <djahandarie> int80_h, you could, but it'd make more sense to just use let x = head unprocessed
12:01:42 <doofer> Gracenotes: why is that?
12:01:46 <int80_h> wait, I think what I want is a let binding
12:01:54 <int80_h> I'm with you
12:02:04 <Gracenotes> doofer: hm, not sure if failure to find a module to import is iterative
12:02:05 <doofer> Gracenotes: you mean when having done changes etc?
12:02:26 <djahandarie> doofer, it fails on every dependecy you miss
12:02:35 <doofer> ah, alright
12:02:40 <djahandarie> So you'll have to do 'cabal install' and change your .cabal install every time
12:02:44 <djahandarie> It's not exactly ideal
12:02:55 <doofer> okay, that's good to know :)
12:03:18 <djahandarie> I'm sure there is some way to find the loaded packages when running a script, but I'm not aware of it
12:03:27 <Gracenotes> and, if the version you have is 4.5.1 or something, say 4.5.* is a dependency, and widen that if need be
12:03:49 <Gracenotes> some things are more stable than others..
12:03:58 <wakeupsticky> hrm, wx-config still "doesn't exist" even though i ran the attempted installation in C:\Users\Jesse and that's where the wxconfig file is
12:04:05 <djahandarie> doofer, http://www.haskell.org/haskellwiki/Package_versioning_policy if you want to see how you just set your dependencies
12:04:13 <djahandarie> wakeupsticky, hm.
12:04:18 <newsham> int80: args <- return (head unprocessed)      will work, but thats just       let args = head unprocessed
12:04:33 <wakeupsticky> hm indeed. wonder where that file wants to be
12:04:46 <b6n> Hi folks, can someone tell me how I can make a [IO Int] become a plain [Int]?
12:04:47 <djahandarie> wakeupsticky, did you also do the second instruction on that wxconfig page?
12:04:54 <doofer> ah, so A.B.* _should_ ensure the same interface
12:04:56 <newsham> x <- return (pure stuff)      is      let x = pure stuff
12:05:00 <wakeupsticky> no, i didn't, which i was about to mention
12:05:04 <wakeupsticky> *hits self in head*
12:05:04 <djahandarie> b6n, you can't at the end, but you can intermediently
12:05:13 <djahandarie> b6n, it'll need to eventually go back into some sort of IO a
12:05:20 <kmc> b6n, IO Int and Int are two totally different values.  they don't represent the same kind of thing
12:05:49 <kmc> b6n, Int represents an integer.   IO Int represents an "IO action", a kind of "recipe" for actions which, if carried out, would produce an integer.  they haven't been carried out yet
12:06:03 <kmc> you can use ¬´sequence :: [IO a] -> IO [a]¬ª to turn a list of recipes into a recipe for a list
12:06:33 <kmc> then you can use the "do" syntax or the operator (>>=) to get local access to that [a] value
12:06:39 <kmc> but only in the context of building a bigger action
12:06:40 <djahandarie> b6n, sequence xs >>= (\blah -> return (f blah)) for example
12:06:40 <kmc> e.g.
12:06:56 <kmc> do { list_of_ints <- sequence list_of_recipes; print (sum list_of_ints) }
12:07:07 <djahandarie> kmc's is nicer ;)
12:07:19 <djahandarie> I don't like using the do notation at first because it looks too magical though
12:07:25 <kmc> b6n, http://haskell.org/haskellwiki/Introduction_to_IO
12:07:45 <wakeupsticky> gah, still doesn't think the config file exists...i added WXWIN as a system variable, not as a user variable
12:07:50 <wakeupsticky> i suppose i will try the former
12:07:50 <b6n> Wow, thanks guys!
12:07:52 <b6n> hhm sequence could do the trick I guess ...
12:07:53 <wakeupsticky> er, latter
12:07:54 <newsham> I dont see why do notation needs to look more magical than bind notation.
12:08:06 <newsham> you can tell people what the rules are in terms of bind or in terms of do-syntax
12:08:19 <djahandarie> newsham, because it introduces non-function syntax
12:08:33 <djahandarie> Which makes you think there is something special about it because it doesn't fit with the rest of the language
12:08:37 <djahandarie> (My opinion of course)
12:08:56 <wakeupsticky> trial # 4 underway
12:08:58 <wakeupsticky> lol
12:09:35 <wakeupsticky> i set the variable to the full path name including .exe extension, i suppose i could take that off
12:10:01 <djahandarie> I'm not sure who would know more about this
12:10:13 <wakeupsticky> someone who has used wx?
12:10:17 <newsham> djahandaire: like pattern matching and let bindings and imports and ... ?
12:10:21 <djahandarie> On Windows specifically
12:10:32 <newsham> why dont we use functions for deconstructors instead of pattern matching? :)
12:10:39 <newsham> less magic
12:10:50 <newsham> reboot required, brb
12:10:52 <benmachine> newsham: pattern matching can be nested more easily
12:11:06 <djahandarie> newsham, imports and let bindings can only be done with that syntax
12:11:13 <djahandarie> newsham, which makes them magic
12:11:17 <benmachine> and is arguably just easier to get along with
12:11:18 <djahandarie> So having syntax for them is totally allowed
12:11:19 <copumpkin> newsham: they're equivalent, anyway
12:11:21 <kmc> #haskell: 1 ops, 666 total
12:11:29 <benmachine> *gasp*
12:11:30 <copumpkin> kmc: omg the devil
12:11:33 <kmc> nobody move
12:11:33 <djahandarie> copumpkin, benmachine, he was responding to my comment
12:11:35 <kmc> awwww
12:11:39 <djahandarie> With sarcasm
12:11:44 <djahandarie> Not actually asking the question
12:11:48 <benmachine> oh
12:11:52 <copumpkin> oh
12:11:54 <benmachine> who can bother reading stuff
12:11:57 <copumpkin> :P
12:13:14 <benmachine> someone on haskell-cafe says, don't put a restriction on template-haskell in cabal files
12:13:17 <wakeupsticky> dj, do you know if there is an alternative gui library to wx that i might try?
12:13:23 <benmachine> because cabal will try to install a different version of TH and fail
12:13:26 <wakeupsticky> i mean i see a bunch in hackage
12:13:26 <benmachine> can it, not do that
12:13:27 <benmachine> please
12:13:38 <djahandarie> wakeupsticky, I'm not sure about Windows
12:13:38 <wakeupsticky> i'm just asking you cause i have no idea as to the quality of any of those
12:14:14 <wakeupsticky> is there a mailing list that i could send this problem to perhaps?
12:14:23 <wakeupsticky> that way if anyone knows what's going on they can respond
12:14:41 <napping> wakeupsticky: you could try gtk
12:14:48 <doofer> want to help me name a library? it's a grammar and parser generator lib
12:14:52 <wakeupsticky> gtk, is that a gui lib?
12:14:54 <djahandarie> wakeupsticky, yes, https://lists.sourceforge.net/lists/listinfo/wxhaskell-users
12:15:01 <wakeupsticky> ty
12:15:14 <fryguybob> @freename
12:15:14 <lambdabot> Hadi
12:15:35 <djahandarie> @freename
12:15:35 <lambdabot> Hadj
12:15:43 <napping> I missed some context, what's the problem with wx?
12:15:54 <newsham> re
12:16:09 <wakeupsticky> oh, i'm trying to get it using cabal
12:16:15 <wakeupsticky> but the install says a config file doesn't exist
12:16:16 <benmachine> @@ @run "@freename" == "Hadk"
12:16:16 <djahandarie> napping, cabal install wx requires wx-config, but it isn't clear where to put the executable
12:16:17 <lambdabot>   False
12:16:24 <wakeupsticky> so dj helped me out and sent me to where i could get it
12:16:27 <napping> I have personally compiled a gtk2hs program on windows, but it was a bit of a pain to install the libraries
12:16:30 <benmachine> @@ @run "@freename"
12:16:31 <wakeupsticky> i downloaded it and just put it in C:\Users\Jesse
12:16:31 <lambdabot>   "@freename"
12:16:35 <benmachine> @@ @run " @freename "
12:16:37 <lambdabot>   " @freename "
12:16:43 <benmachine> ok I can't remember how that works
12:16:43 <wakeupsticky> then reran cabal install wx in that directory
12:16:48 <benmachine> @help @
12:16:48 <lambdabot>  @ [args].
12:16:49 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
12:16:49 <lambdabot>  The commands are right associative.
12:16:49 <lambdabot>  For example:    @ @pl @undo code
12:16:49 <lambdabot>  is the same as: @ (@pl (@undo code))
12:16:51 <newsham> re: "do"=magic, many programmers are already used to their imperative language being magic.
12:17:09 <newsham> re: patterns and deconstructors, not quite equivalent.  patterns arent first class.
12:17:13 <wakeupsticky> if you want 0 magic use lisp right?
12:17:27 <napping> well, things like cons and GC are still fairly magic there
12:17:32 <b6n> Calling the sequence function on my [IO Int] and chaining the result together with >>= did the trick! Thanks for the polite and quick help!
12:17:32 <newsham> also pattern compiler can do some compile-tiem optimiations on patterns
12:17:38 <wakeupsticky> ah yes, gc is totally hidden
12:17:41 <kmc> no problem b6n :)
12:17:41 <djahandarie> newsham, and it isn't magic in Haskell, making it very confusing if we introduce it that way
12:17:52 <wakeupsticky> but gc shouldn't be a language concern anymore
12:17:57 <newsham> djahandarie: so why do we introduce pattern matching before deconstructors?
12:18:03 <newsham> in fact, most people dont even use deconstructors
12:18:03 <djahandarie> newsham, don't ask me
12:18:11 <int80_h> this field in my record "foo :: IO String" says that foo is an IO action of type String, right? If I wanted to have an IO action of type [(String,String)] would I say "foo :: IO [(String, String)]"?
12:18:11 <benmachine> djahandarie: it's sufficiently advanced technology, though?
12:18:11 <newsham> in fact, haskell wont even make the deconstructors for you unless you use TH magic
12:18:23 <wakeupsticky> so, napping, do you have any idea what's up with this config executable?
12:18:33 <wakeupsticky> do you need more info from me?
12:18:42 <napping> I've never tried to use wx on windows, and I think I built gtk2hs from source manually
12:18:48 <djahandarie> benmachine, what is? do notation?
12:18:59 <benmachine> djahandarie: well, sort of yes
12:19:00 <napping> cabal doesn't work out so nicely without apt-get or something behind it to install necessary C libraries
12:19:19 <doofer> @freename
12:19:20 <lambdabot> Hadk
12:19:25 <djahandarie> benmachine, I'm saying the normal monad functions should be used before do to make it very clear that do notation is just sugar
12:19:29 <wakeupsticky> if i were to install ubuntu would it be much easier for me to make a gui app with haskell?
12:19:30 <djahandarie> Rather than magic
12:19:51 <benmachine> djahandarie: I disagree; you don't need to understand things to use them effectively, at least initially
12:19:51 <sproingie> wakeupsticky: probably easier than on windows, yes
12:19:56 <int80_h> wakeupsticky : I suggest debian.
12:19:57 <benmachine> IO especially
12:19:58 <napping> wakeupsticky: Probably, yes. I find linux easier for programming because installing libraries is much less of a hassle
12:20:06 <benmachine> people want to start doing IO immediately so they can write programs
12:20:14 <wakeupsticky> ben, that's true
12:20:24 <int80_h> this field in my record "foo :: IO String" says that foo is an IO action of type String, right? If I wanted to have an IO action of type [(String,String)] would I say "foo :: IO [(String, String)]"?
12:20:28 <benmachine> but you can't easily teach them IO in terms of >>= and >> when they don't even understand lambdas and higher order functions yet
12:20:34 <wakeupsticky> people want to be sure they can do practical things
12:20:34 <c_wraith> hence, we should teach IO, and *never* use the word monad in the basic IO introductions
12:20:48 <benmachine> c_wraith: it's not like a swearword >_>
12:20:59 <wakeupsticky> yes it is
12:21:00 <int80_h> s/monad/burrito
12:21:02 <wakeupsticky> by now
12:21:09 <newsham> *shrug* I personally think its easier to explain how do notation works to people who already program in imperative languages than it is to explain how to use bind with closures
12:21:10 <napping> aww, but I like commutativity diagrams
12:21:16 <int80_h> just use the word burrito instead
12:21:23 <newsham> the transition from do-notation to bind isnt hard to make after that
12:21:32 <EvanR-work> c_wraith: yes and data types. please dont introduce Maybe as a monad before introducing it as a data structure
12:21:34 * djahandarie shrugs
12:21:44 <djahandarie> I think introducing do notation first would introduce a big handicap
12:21:56 <FunctorSalad> newsham: hmm isn't it intuitive if you point out that the second argument is "what to do next"?
12:22:05 <djahandarie> That's just my intution though
12:22:19 <benmachine> djahandarie: so yo
12:22:20 <benmachine> er
12:22:23 <djahandarie> yo
12:22:24 <djahandarie> :P
12:22:24 <benmachine> damn return key
12:22:25 <FunctorSalad> or is me considering it intuitive just years of brainwashing
12:22:29 <c_wraith> nah, do notation is fine.  Just...  say that it's syntactic sugar for doing IO
12:22:38 <c_wraith> Ignore the monad abstraction for a while.
12:22:40 <doofer> int80_h, yes :)
12:22:53 <FunctorSalad> (that's how a prof once explained why it's obvious that a straight line is a (particular) curve)
12:22:54 <wakeupsticky> only thing is i need windows to play poker...
12:23:01 <benmachine> I don't even know what I was going to say now
12:23:07 <kmc> how much of our speculation about what makes Haskell easy or hard to learn is based on actual experience learning and teaching?
12:23:16 <wakeupsticky> is it still a hassle to get a partition going, or is there a good tutorial out there yet?
12:23:18 <kmc> usually people are bad at describing their own difficulties with software
12:23:23 <napping> well, I've taught Haskell to some CS students
12:23:24 <kmc> you have to watch them use it; you can't trust what they say
12:23:27 <napping> it was a while ago, though
12:23:37 <djahandarie> I've done some teaching to younger kids
12:23:40 <FunctorSalad> kmc: are you questioning our primary means of theory building? ;)
12:23:44 <FunctorSalad> (speculation)
12:23:51 <int80_h>  doofer : okay now supposed that sometimes I want IO [(Int,String)], can I make my type polymorphic to accept other possiblities besides IO [(String,String)]?
12:24:01 <djahandarie> Like late middle school / early highschool
12:24:19 <napping> IIRC the main issue was figuring out how to put stuff together to get things done, rather than understanding any individual feature
12:24:28 <doofer> int80_h: you could use Either Int String
12:24:39 <FunctorSalad> napping: heh does that ever go away?
12:24:41 <int80_h>  doofer : nice!
12:24:46 <napping> problems like "shows how to evalue <expr>" were not much of a problem
12:25:16 <benmachine> hmm, IO [(Either Int String, String)] is more than just the union of those types though
12:25:22 <int80_h>  IO [(Either Int | String,String)]? is that right syntax?
12:25:24 <FunctorSalad> (moves to a higher level, of course)
12:25:31 <benmachine> int80_h: no |
12:25:41 <wakeupsticky> napping...kind of like, oh, i don't know, graphics libraries? :P
12:25:45 <kmc> int80_h, if you have a list of tuples of eithers, you should probably define your own type instead
12:25:51 <kmc> or at least some synonyms
12:25:52 <doofer> benmachine is right, you might want something like Either [(Int, String)] [(String, String)]
12:25:59 <FunctorSalad> int80_h: sums get no special treatment by haskell syntax
12:26:06 <FunctorSalad> (in contrast to products/tuples)
12:26:19 <djahandarie> Err, probably [Either (Int,String) (String,String)]
12:26:29 <FunctorSalad> you can define :+: though :)
12:26:30 <wakeupsticky> sometimes trying to get things done in a programming language feels like dealing with a hostile bureaucracy
12:26:33 <napping> wakeupsticky: I'd suggest installing Haskell libraries through cabal, and perhaps installing your own version of Haskell as well
12:26:34 <djahandarie> The either around the list wouldn't be that useful
12:26:40 <kmc> i mean (String,String) says nothing about what the strings mean
12:26:48 <newsham> functor: it seems obvious to me now, but i think someone starting off, its not that intuitive at first
12:26:53 <kmc> data Person = Person { name, address :: String } -- more specific
12:26:54 <benmachine> djahandarie: yes it would
12:27:12 <napping> wakeupsticky: even if a library is in the Ubuntu repositories, it may be old
12:27:16 <doofer> depends on if you want a list of only one of them or a list of eithers
12:27:25 <wakeupsticky> napping, i tried cabal, but i needed a config .exe file, and when i downloaded it, cabal still couldn't find it
12:27:41 <napping> you probably need to set up paths and stuff
12:28:01 <wakeupsticky> i set environment variables WXWIN (system and user) to the location of the file
12:28:04 <djahandarie> benmachine, well, yeah, I guess it would. :P Depends on what he wants
12:28:11 <kmc> and ¬´Either (Int,String) (String,String)¬ª is less clear than ¬´data Thing = Dog { age :: Int, breed :: String } | Person { name :: String, address :: String}¬ª
12:28:13 <wakeupsticky> i suppose it couldn't hurt to add that location to my PATH variable
12:28:15 <int80_h> kmc I have data Table = Table {tableColumns :: [(String,String)]}
12:28:20 <kmc> ok
12:28:30 <wakeupsticky> dj thought that wasn't necessary because path was left uncapitalized
12:28:30 <kmc> what do they two strings mean?
12:28:34 <napping> wakeupsticky: if cabal can't find the command, it's probably searching PATH
12:28:54 <djahandarie> And also it explicitly talks about environment variables the line after that
12:29:00 <djahandarie> Yet totally neglected to do so in the first bullet
12:29:06 <djahandarie> Could just be bad instructions
12:29:09 <wakeupsticky> dj, i set up environment variables
12:29:11 <napping> heck, is it even called "PATH" on windows?
12:29:14 <int80_h> kmc : sometimes the tableColumn witth be (Int, String) and sometimes (String, String)
12:29:18 <djahandarie> I actually don't know
12:29:19 <djahandarie> I think it is
12:29:24 <wakeupsticky> but didn't add the path to the executable to my path variable
12:29:39 <kmc> int80_h, what do the Ints and Strings mean? types are used to specify properties of programs, not just to specify data representation in memory
12:29:43 <benmachine> it is called PATH I believe
12:30:15 <doofer> data TableColumn = Something Int String | SomethingElse String String
12:30:25 <kmc> a given program may have many values each represented by a pair of strings, but semantically meaning different things, and we want the type system to keep us from mixing them accidentally
12:31:01 <kmc> if you're writing an RPG, you could use Int to represent both hit points and gold, but it's better to define new types so you don't accidentally add someone's gold to their hitpoints
12:31:23 <kmc> this is even more the case when the alternative is not just Int but some unwieldy thing made of Either and tuples
12:31:46 <djahandarie> The richer you are... the more powerful you shall become!!
12:31:48 <int80_h> kmc, okay I will look at my test data and see if I can generalize. I'm hoping to keep this to one record, it will make my code easier to write
12:31:57 <kmc> why?
12:32:01 <kmc> it will make your code harder to understand
12:32:03 <wakeupsticky> ok, i have the wx-config exe in C;\Users\Jesse. I added C;\Users\Jesse to my Path variable. I added WXWIN variables with the path to said executable in both my system and user environment variables.
12:32:09 <wakeupsticky> Cabal still doesn't think that it exists.
12:32:17 <kmc> (btw, you don't have to write it using record syntax and named accessors... that's not central to what i'm advocating here)
12:32:17 <djahandarie> lol
12:32:24 <napping> can you run wx-config in the command shell?
12:32:45 <wakeupsticky> yes i can
12:32:48 <napping> shouldn't that be C:\Users anyway?
12:32:52 <kmc> int80_h, you still didn't answer the question:  in ¬´tableColumns :: [(String,String)]¬ª, what do the two strings *mean*?
12:33:18 <benmachine> wakeupsticky: sometimes running cabal commands with -v or -v3 can shed light on what it's doing
12:33:40 <wakeupsticky> i have to go get lunch...i'll be back. but i can run wxconfig and it gives me a ton of options.
12:33:44 <wakeupsticky> i'll be back.
12:34:08 <napping> that's cabal -v, to show what it tries to run
12:34:17 <djahandarie> Ugh, I had to leave work already because I'm really sick, but I'm not feeling much better at home :(
12:35:20 * benmachine fmap (const NoIllness) djahandarie
12:35:39 <djahandarie> Thanks, I'm not a functor though :P
12:36:07 <napping> can you define a language without any magic semantics built in?
12:36:30 <napping> McBride's paper on "Levitation" is pretty interesting for a start
12:36:34 <kmc> what counts as 'magic'?
12:36:45 <napping> things that you could not define for yourself
12:36:49 <p_l> kmc: anything sufficiently advanced
12:37:08 <int80_h>  kmc okay having looked at my test data again I am wrong about (String, String). It will always be (String, Int). Sometimes Int will be a Cost. Sometimes it will be an ID.
12:37:19 <kmc> int80_h, eek! that's the kind of thing i'm talking about
12:37:28 <kmc> data Value = Cost Int | ID Int
12:37:32 <kmc> (String, Value)
12:37:57 <int80_h> nice
12:37:59 <int80_h> thanks
12:38:06 <kmc> this will catch more errors than if you used a bare Int for both
12:38:17 <kmc> :)
12:38:28 <napping> perhaps even newtype Cost = Cost Int, newtype ID = ID Int
12:38:51 <int80_h> what's the advantage of newtype of data?
12:38:58 <int80_h> in this case?
12:39:10 <napping> well, newtype says that it's supposed to be just like the other type
12:39:10 <FunctorSalad> *troll* or newtype IxInt ix = IxInt Int, {-# LANGUAGE EmptyDataDecls #-}, ...
12:39:15 <FunctorSalad> )
12:39:15 <napping> but considered different
12:39:30 <kmc> int80_h, the issue here is not newtype vs. data.  to first approximation they are the same, just newtype only works on a restricted set of cases
12:39:49 <kmc> int80_h, so if you read "data" instead of "newtype" in napping's example, you still get a different design than what i proposed
12:40:10 <napping> if you are going to have ID and Cost running around separately in other parts of your code, making types like that would keep them distinct
12:40:29 <napping> while if they were just Int you could confuse them anywhere they are unwrapped from the Value
12:40:37 <kmc> in napping's design you can inspect a Value to determine whether it's a Cost or an ID, and then pass this knowledge of which it is to other code, without confusing them with other unrelated Ints
12:40:41 <int80_h> napping : my intent is to be able to pass either value to a function that stores it in a database table
12:41:05 <kmc> int80_h, right
12:41:10 <napping> I'm not sure why you'd want both in the same database table
12:41:28 <kmc> int80_h, that's a spec of what the code needs to do.  we're talking about how to structure the code to catch more errors at compile time
12:41:34 <napping> also, how does that database tell them apart, if it's just an Int column
12:41:35 <int80_h> napping, I don't. Each table will either have Cost or ID
12:41:57 <napping> Ah, then you should probably try to avoid the Either entirely
12:42:19 <napping> something like put :: Table a -> String a -> a -> IO ()
12:42:20 <int80_h> napping : yes and do what kmc suggested.
12:42:31 <kmc> data Table a = Table { columns :: [(String, a)] }
12:42:41 <napping> and have some costTable :: Table Cost, idTable :: Table ID
12:42:42 <kmc> now you can make a ¬´Table Cost¬ª and a ¬´Table ID¬ª
12:43:10 <kmc> now you have an even stronger guarantee: you won't use the wrong kind of table
12:43:31 <int80_h> I don't want to hold the String. I want to hold the IO String. Hypothetically these tables could get big. Not in reality though.
12:43:53 <napping> an IO String as a key? 
12:43:56 <napping> that sounds odd.
12:44:09 <int80_h> no it's not a key. 
12:44:20 <int80_h> hmmm
12:44:37 <int80_h> okay revision time
12:44:42 <int80_h> I'm a little confused. Or alot
12:45:59 <int80_h> data Table = Table {columns :: [(IO String, Int)] }
12:46:06 <int80_h> there that is closer
12:46:16 <int80_h> the Int will be the key
12:46:17 <kmc> but you've lost the distinction  between Cost and ID
12:46:25 <napping> hmm
12:46:32 <napping> why is IO String the value?
12:46:39 <kmc> a cost doesn't sound like a key.  an id does, though
12:46:48 <napping> yeah, that too
12:46:56 <int80_h> ah wait...checking
12:47:20 <int80_h> damn it. SOmetimes the string *is* the key
12:47:25 <int80_h> that complicates things
12:47:51 <int80_h> okay forget IO, I will just store the string directly.
12:48:23 <kmc> if your Strings get really big or numerous, you could switch to ByteString or similar
12:48:47 <int80_h> data Table = Table {columns :: [(String, Value)] } is what I meant anyway, with Value defined earlier
12:48:49 <EvanR-work> Either (Maybe (String, Int, Maybe Int)) (Either Int (Maybe (Int, [Double])))
12:48:56 <EvanR-work> use that instead
12:49:04 <kmc> EvanR-work, you did that just to make me cringe ;P
12:49:10 <EvanR-work> lol
12:49:19 * int80_h 's head pops.
12:49:20 <kmc> needs more Mu
12:49:53 <EvanR-work> kmc: with the added 'agreement' that the [Double] can have between 2 and 19, but not 15 elements
12:50:09 <EvanR-work> or else undefined behavior
12:50:09 <int80_h> kmc, okay I noticed you used "a" in your earlier data definiintion. I've never seen that before.
12:50:27 <kmc> int80_h, it's a type variable
12:50:31 <kmc> int80_h, you know about "Maybe"?
12:50:32 <int80_h> kmc: data Table a = Table { columns :: [(String, a)] }
12:50:34 <kmc> it's defined thus:
12:50:39 <kmc> data Maybe a = Nothing | Just a
12:50:41 <EvanR-work> @src Maybe
12:50:42 <lambdabot> data Maybe a = Nothing | Just a
12:50:43 <int80_h> kmc: vaguely yeah
12:50:47 <napping> that makes a parameter
12:51:04 <kmc> so Maybe isn't a type, but (Maybe Int) and (Maybe Char) and (Maybe (Either (Int -> String) Bool)) are
12:51:11 <napping> so  you can have types Table Cost or Table Id, in the first columns will be [(String,Cost)], the second [(String,ID)]
12:51:39 <int80_h> napping, with a being of type Value?
12:51:51 <napping> no, "a" can be any type you want.
12:51:51 <kmc> no, a = Cost or a = Id
12:51:56 <kmc> under thee scheme where those are types
12:52:05 <kmc> under my scheme they were data constructors, which is probably confusing the issue
12:52:12 <kmc> let's use standard types instead:
12:52:17 <kmc> Table Int would be [(String, Int)]
12:52:26 <kmc> Table (Bool -> Bool) would be [(String, Bool -> Bool)]
12:52:41 <kmc> the real beauty is that you can make functions which work generically no matter what 'a' is
12:52:49 <kmc> just like "map" works on all lists without caring what the element type is
12:52:53 <kmc> map :: (a -> b) -> [a] -> [b]
12:53:01 <mjrosenb> @hoogle [a] -> [a] -> [a]
12:53:02 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
12:53:02 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
12:53:02 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
12:53:33 <mjrosenb> does lambdabot only return the first 3 results?
12:54:24 <geheimdienst> @more
12:54:33 <geheimdienst> @hoogle something
12:54:34 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
12:54:40 <geheimdienst> @hoogle a
12:54:41 <lambdabot> Data.Graph.Inductive.Example a :: Gr Char ()
12:54:41 <lambdabot> Data.Graph.Inductive.Example a' :: IO (SGr Char ())
12:54:41 <lambdabot> Data.Graph.Inductive.Example ab :: Gr Char ()
12:54:44 <geheimdienst> @more
12:54:49 <geheimdienst> why it no worky
12:56:26 <mjrosenb> ok, does anyone know of a function that takes [a0,a1,a2..] [b0,b1,b2..] and evaluates to [a0,b0,a1,b1,a2,b2..]?
12:56:34 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29228#a29228
12:56:43 <int80_h> is that right ^^^^
12:57:19 <kmc> @hoogle interleave
12:57:20 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
12:57:20 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
12:57:20 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
12:57:22 <kmc> :(
12:57:47 <kmc> > transpose ["abc","xyz"]
12:57:48 <lambdabot>   ["ax","by","cz"]
12:57:52 <kmc> > concat $ transpose ["abc","xyz"]
12:57:53 <lambdabot>   "axbycz"
12:57:57 <int80_h> kmc: would you take a look at my post so I can make sure I've got the data types right basded on what you were saying?
12:57:58 <kmc> mjrosenb, ^^^
12:58:11 <kmc> int80_h, data Table a = ...
12:58:17 <kmc> otherwise 'a' is not in scope in the columns field
12:58:32 <mjrosenb> kmc: that seems less than ideal...
12:58:56 <kmc> int80_h, it's a variable.  as when defining a function, you have to list the parameters before you use them
12:58:57 <kmc> mjrosenb, why?
12:59:07 <int80_h> kmc : gotcha, that was an oversight. I'm hoping to incorporate these ideas correctly within a few hours here.
12:59:30 <kmc> int80_h, looks ok otherwise
12:59:40 <kmc> int80_h, you'll create values of type ¬´Table Value¬ª ?
13:00:09 <napping> if you never want to mix them up, you should probably define a separate Cost and ID type
13:00:19 <mjrosenb> kmc: i know that it is trivial for an optimization to fix it so it doesn't create the initial list or intermediate lists
13:00:48 <kmc> yeah, i would hope it would fuse
13:01:09 <int80_h> kmc: yeah
13:01:11 <mjrosenb> kmc: but it still feels like i'm walking next door by walking around the block
13:03:29 <int80_h> @hoogle <$>
13:03:29 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
13:04:19 <mjrosenb> kmc: also it is not longer than the obvious definition (for infintie lists)
13:04:20 <mjrosenb> weave (a:b) (c:d) = a:c:weave b d
13:04:26 <mjrosenb> err
13:04:30 <mjrosenb> not *shorter*
13:04:40 <kmc> ok
13:04:43 <kmc> then use that :)
13:04:53 <napping> concat . transpose is for lists of lists anyway
13:05:30 <aristid> > concat . transpose [[1,2],[2,3],[4,5]]
13:05:31 <lambdabot>   No instance for (GHC.Num.Num [a])
13:05:31 <lambdabot>    arising from a use of `e_1122345' at <...
13:05:35 <aristid> > concat . transpose $ [[1,2],[2,3],[4,5]]
13:05:36 <lambdabot>   [1,2,4,2,3,5]
13:05:48 <mjrosenb> napping: right, so i would need to say weave a b = concat . transpose $ [a,b]
13:05:52 <aristid> > concat . transpose $ [[1,2],[3,4],[5,6]]
13:05:53 <lambdabot>   [1,3,5,2,4,6]
13:06:25 <c_wraith> :t (concat .) . transpose
13:06:26 <aristid> > concat . transpose $ [[1,2],[3,4]]
13:06:27 <lambdabot> forall a. [[[a]]] -> [[a]]
13:06:27 <lambdabot>   [1,3,2,4]
13:06:48 <c_wraith> oh, wow, I really mangled reading that. :)
13:06:49 <aristid> > zip [1,2] [3,4]
13:06:50 <lambdabot>   [(1,3),(2,4)]
13:15:02 <int80_h> :t print
13:15:03 <lambdabot> forall a. (Show a) => a -> IO ()
13:15:53 <c_wraith> :t putStrLn . show
13:15:54 <lambdabot> forall a. (Show a) => a -> IO ()
13:16:42 <napping> int80_h: have you mostly used untyped languages before?
13:16:50 <napping> or worse, something like Java?
13:17:46 <ski> mjrosenb : it's commonly called and defined like in `[    ] /\/ odds = odds; (a:evens) /\/ odds = a : (odds /\/ evens)'
13:18:04 <int80_h>  napping used mostly C and assembler, though I have forgotten them both. Then there was lisp. It's the gateway drug for functional programming.
13:18:08 <ski> (though i made up the names `evens' and `odds' on the spot)
13:18:19 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29229#a29229
13:18:23 <int80_h> hi ski!
13:18:33 <ski> lo int80_h
13:18:51 <int80_h> I invite you to take a look at my code I am playing with
13:19:12 <int80_h> once I have gotten the details right I will incorporate this into my actual program.
13:19:57 <p_l> int80_h: which lisp?
13:20:14 <int80_h>  p_l: common lisp
13:20:25 <int80_h> using sbcl and slime and emacs
13:21:16 <ski> int80_h : you probably don't want `print . show', there
13:21:18 <ski> @src print
13:21:19 <lambdabot> print x = putStrLn (show x)
13:21:29 <doofer> :t readFile
13:21:30 <lambdabot> FilePath -> IO String
13:21:31 <ski> (since it already includes a call to `show')
13:21:44 <int80_h> ski: when I leave it out I get a different error
13:21:48 <ski> int80_h : also, you don't want to `map' `readFile'
13:22:01 <ski> @type \entryFileName -> map readFile entryFileName
13:22:02 <lambdabot> [FilePath] -> [IO String]
13:22:06 <ski> @type \entryFileName -> mapM readFile entryFileName
13:22:08 <lambdabot> [FilePath] -> IO [String]
13:22:09 <int80_h> I do want to map readFile. that part works
13:22:27 <int80_h> oh wait maybe I don't
13:22:27 <ski> you most probably want to `mapM' `readFile'
13:22:49 <ski> also, then you don't want the `let' there, instead having `entryFiles <- ...'
13:22:57 <ski> but ..
13:23:12 <int80_h> ski at first I used <-, I thought it was casuing other problems.
13:23:23 <ski> .. it's not clear to me whether `entryFileName' is a `FilePath' or a list of `FilePath's
13:23:28 <int80_h> when I changed it to a let binding I swapped one error for another.
13:23:57 <int80_h> ski : entryFileName is a list of FilePath's
13:24:08 <ezyang> Hmm, lack of kind polymorphism is troublesome. 
13:24:17 <ski> int80_h : yeah, it's hard to know which direction to change the code is correct, if you have several errors, and are not that familiar with what the actual problem(s) is(/are)
13:24:41 <int80_h>  ski : I will change the let binding back and we can go from there.
13:24:44 <int80_h> and remove show
13:24:54 <ski> ezyang : yeah .. what's the issue in your case ?
13:25:28 <ski> (int80_h : also, you really ought to indent the body of `main' more than zero spaces)
13:26:07 <ezyang> ski: Just some type families that aren't as general as they could be :-) 
13:26:31 <cncl> are there some popular libraries that are using type/data families right now?
13:26:33 <ski> ezyang : only argument kinds, or result kinds as well ?
13:26:40 <ezyang> Result kinds. 
13:26:52 <ski> ok, that's the more tricky case
13:26:54 <ezyang> cncl: I think bytestring uses them? 
13:27:01 <cncl> oh does it? interesting
13:27:13 <ezyang> Fortunately, I'm only using one specialization, so all I have to do is change the signature. 
13:28:52 * ski only know of one idea which might handle datatypes polymorphic in result kinds ..
13:29:09 <ski> (.. i.e. my idea :)
13:29:34 <int80_h> ski: I changed the indentation and now I'm getting compaints     Illegal signature in pattern: IO () main Use -XScopedTypeVariables to permit it
13:29:58 <ezyang> :-) 
13:30:01 <ski> int80_h : your code shoudl look something like
13:30:02 <int80_h> I've seen this problem before, and just gave each let binding a type signature, but I still have the problem.
13:30:05 <ski>   main :: IO ()
13:30:08 <ski>   main = do
13:30:15 <ski>     unprocessed <- getArgs
13:30:17 <ski>     ...
13:30:49 <ski> i.e, only indent the *body* of the `do'-block more, not the type signature and the "head" of the clause defining `main'
13:31:53 <ski> (if that's not your problem, you'll have to paste (or better, annotate the existing paste by "add revision" or "modify") your current code)
13:32:35 <int80_h> ski: that solves *that* problem, but now I am back to what I had prior to swapping out <- for a let binding.
13:32:39 <int80_h> which I shall post
13:32:58 <ski> (yes, i know you had more problems .. i was only talking about that one :)
13:33:36 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29230#a29230
13:33:39 <int80_h> that be it
13:34:00 <ski> oh, you didn't annotate the previous paste :/
13:34:08 <int80_h> no
13:34:10 <int80_h> oops
13:34:40 <napping> that needs to be mapM, not map
13:35:03 <ski> .. yeah, i was just about to repeat that :)
13:35:15 <ski> i.e. the latter `map' you have should be `mapM'
13:35:18 <int80_h> ski: I remember you sasid that. I had forgotten , working this other stuff out
13:35:27 <ski> no worry
13:36:23 <ezyang> Hmm, and it seems that the input of a type function has to have kind * 
13:37:01 <ski> int80_h : btw, instead of saying `unprocessed <- getArgs' and then in the `let' `d = head unprocessed', just say `unprocessed @ (d:_) <- getArgs' .. or since you don't use `unprocessed' for anything else, just `d:_ <- getArgs'
13:37:16 <ski> ezyang : for type families ?
13:37:51 <ski> ezyang : maybe i'm wrong but i would assume that you can kind annotate like `type family Foo (f :: * -> *)'
13:38:00 <FunctorSalad> istr that too
13:38:14 <ezyang> ski: Oh, really? Sweet. 
13:38:22 <ski> (.. and that it is only defaulting to `*' if nothing else is said (defaulting since there is no kind polymorphism it could use instead))
13:39:24 <ski> at least that's the case for ordinary `data'/`newtype' types .. if an argument isn't used, then it can't infer the kind of that argument, so it defaults to `*' unless you give an explicit kind signature
13:39:38 <ezyang> Yep, that worked. 
13:39:43 <ezyang> Thanks! 
13:39:51 <ski> np :)
13:40:46 <ski> (.. you can probably also say like `type family Foo (f :: * -> *) :: (* -> * -> *) -> *' if you want the result kind there to not be `*')
13:41:43 <ski> (iirc the named arguments (i.e. `f' there) are the ones which one can "pattern-match" on, while the others must be parametric)
13:42:33 <ski> (.. sortof opposite to the Agda2 situation)
13:42:51 <ski> int80_h : any progress ?
13:43:18 <int80_h> :t mampM readFile
13:43:19 <lambdabot> Not in scope: `mampM'
13:43:24 <int80_h> :t mapM readFile
13:43:25 <lambdabot> [FilePath] -> IO [String]
13:43:51 <ski> int80_h : oh, now i see .. you should probably rename `entryFileName' to `entryFileNames', since it appears that is actually a list of file paths
13:44:03 <ski> @type map readFile
13:44:04 <lambdabot> [FilePath] -> [IO String]
13:44:31 <int80_h> I'm getting a new error , it's runtime. hold on.
13:44:34 <ski> `map' here gives you a list of `IO'-actions, while `mapM' gives you an `IO'-action that produces a list
13:44:39 <ski> @type sequence (map readFile)
13:44:40 <lambdabot>     Couldn't match expected type `[m a]'
13:44:41 <lambdabot>            against inferred type `[FilePath] -> [IO String]'
13:44:41 <lambdabot>     In the first argument of `sequence', namely `(map readFile)'
13:44:49 <ski> @type sequence . map readFile  -- oh, right
13:44:50 <lambdabot> [FilePath] -> IO [String]
13:45:05 <int80_h> I want sequence?
13:45:08 <ski> @type sequence :: [IO FilePath] -> IO [FilePath]
13:45:09 <lambdabot> [IO FilePath] -> IO [FilePath]
13:45:14 <ski> @src mapM
13:45:15 <lambdabot> mapM f as = sequence (map f as)
13:45:26 <ski> int80_h : nah, `mapM' calls `map' and `sequence' for you
13:45:41 <ski> just showing the internals :)
13:45:54 <int80_h> okay here is my new error, I have found the problem line (I think)
13:47:23 * int80_h curses
13:47:33 * ski blesses
13:47:49 <carter> question: when doing the haskell platform install on ubuntu
13:48:11 <carter> what is then needed to get cabal install cabal-install to run successfully?
13:48:19 <carter> because i seem to be  flubbing it
13:48:24 <carter> on ubuntu 10.04
13:48:26 <int80_h> ski: problem solved. Onwards!
13:51:54 <ezyang> I dislike it when GHC tells me "Could not deduce (GNetwork m2 AIG n) from the context (NetworkMonad m3 n)" 
13:52:02 <ezyang> IT should tell me when it allocated those fresh type variables. 
13:53:31 <ezyang> Bah, now I want superclass equality constraitns 
13:55:36 <benmachine> ezyang: how would it do that concisely?
13:55:47 <ezyang> benmachine: No idea :-) 
13:56:01 <ezyang> I mean, I essentially want an inference debugger. 
13:56:38 <benmachine> yeah I had an idea to make a project like that
13:57:08 <benmachine> unfortunately I have so many more ideas than projects :P
13:59:11 <dankna> netsplit, netsplit
13:59:14 <dankna> it's big it's heavy it's wood
13:59:17 <dankna> netsplit, netsplit
13:59:20 <dankna> it's better than bad, it's good
14:00:27 <ezyang> Anyway, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29224#a29226 looks like it works, but doesn't, because Ctor/CtorVal have some sort of strange injectivity relation that is encoded in that statement. 
14:01:16 <ezyang> Which means that GHC generally won't be able to infer FooTwo from FooOne 
14:01:26 <ezyang> If someone would like to tell me I'm wrong, that would be great! 
14:02:12 <napping> looks wrong to me
14:02:16 <napping> how are you trying to use it?
14:02:59 <ski> `class FooTwo m b x => FooOne (m b) x
14:03:06 <ski> ' is not valid, is it ?
14:03:37 <ezyang> ski: That's not valid. 
14:04:07 <ski> (in my mind, `class' declarations correspond more or less to type declarations for predicates, and `instance' declarations correspond to clauses defining the predicate)
14:04:18 <ezyang> napping: just a sec 
14:04:24 <ski> ezyang : .. so why did you paste that ? :)
14:04:47 <ezyang> It illustrated the intent :-) 
14:06:02 * ski thinks both pastes are very sick :)
14:08:05 <int80_h> I have a string "path/to/filename". I'd like to whittle away the string until only filename is left. Would I use map + something or is there another function that will map across this?
14:08:10 <napping> having added some methods, it seems to work for me
14:08:26 <napping> int80_h: check out System.FilePath
14:08:29 <c_wraith> int80_h, look at the filepath package
14:08:35 <c_wraith> haha. :)
14:09:03 <napping> ezyang: e.g, FooTwo gets a x -> (b -> a) -> m b -> m a
14:12:19 <ezyang> Next paste: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29224#a29235 
14:14:20 <ski> ezyang : can you say `instance FooOne (Foo Int)' there ?
14:14:46 <ezyang> Yeah, this isn't quite an accurate paste. 
14:14:51 * ezyang goes back to making it more accurate 
14:14:52 <ski> (btw, istr you can leave the `where' out on the `class' and `instance' declarations, if you don't want to have any methods)
14:15:27 <ezyang> oh, good to know. 
14:23:04 <ezyang> Ah, I see what I want. 
14:23:18 <ski> a pony ?
14:23:25 <ezyang> basically. 
14:24:23 <napping> ezyang: the problem is pretty simple
14:24:28 <ezyang> class (FooTwo (Ctor mb) (Cval mb), Cval mb ~ Int) => FooInt mb 
14:24:36 <napping> there's no guarantee that Ctor (f a) (CtorVal f a) ~ f a
14:24:48 <napping> your paste compiles if you change the first signature to
14:24:54 <napping> foo :: FooOne (f Int) => Ctor (f Int) (CtorVal (f Int))
14:25:26 <ezyang> napping: Yeah. But the point of this stupid exercise is to be able to get rid off (f Int) and just use FooInt m 
14:25:36 <ezyang> where m = f Int 
14:25:42 <napping> what FooInt?
14:26:00 <ezyang> "A partially specialized version of the typeclass" 
14:26:28 <napping> you need to be more precise. you have defined no such identifier
14:26:54 <ezyang> class (FooTwo (Ctor mb) (Cval mb), Cval mb ~ Int) => FooInt mb 
14:28:04 <djahandarie> Where exactly do you get these exercises from ezyang?
14:28:15 <ezyang> djahandarie: My work code :^) 
14:28:25 <ezyang> To me, it seems like I'm trying to do something very simple. 
14:28:33 <ezyang> But actually make the type system do it is really complicated. 
14:28:55 <djahandarie> The little type-programming that I've done was a headache
14:29:06 <int80_h> let test="one:two"
14:29:20 <int80_h> break `notElem [":"]` test
14:29:27 <int80_h> I get a parse error on [
14:29:31 <ezyang> High level problem: 
14:29:44 <dolio> You can only put function names inside `s.
14:30:06 <int80_h> notElem is a function name
14:30:15 <dolio> notElem [":"] is not.
14:30:40 <ezyang> I want to translate 'NetworkMonad m AIG n => m AIG n ()' into 'AIGMonad m n => m n ()' 
14:30:46 <dankna> @quote hurting
14:30:46 <lambdabot> HarriKiiskinen says: banging my head against Haskell, but liking the feeling of hurting brains
14:30:48 <dankna> @quote hurting me
14:30:49 <lambdabot> No quotes for this person. :(
14:30:56 <ezyang> i.e. specialize the typeclass on one of its parameters. 
14:31:00 <dankna> @quote interact
14:31:01 <lambdabot> Cale says: interact is the one true way to write unix programs in Haskell :)
14:31:04 <kmc> @quote hurting.me
14:31:05 <dankna> bah, whatever :)
14:31:05 <lambdabot> Gracenotes says: but there is a line somewhere between main = interact (\_ -> "You're hurting me") and a torturing an android automaton
14:31:11 <dankna> oh, thanks!
14:31:17 <dankna> wanted to show that to someone in another channel
14:31:17 <kmc> dankna, it takes a regex
14:31:25 <kmc> @quote [0-9]+
14:31:26 <lambdabot> mIRC says: %03^_^
14:31:26 <dankna> that's not a posix regex, it's a glob :D
14:31:31 <dankna> hahaha I see
14:31:31 <ski> int80_h : it's better to use  (/= ':')  rather than  notElem [":"]
14:31:35 <kmc> @quote [0-9]{4}
14:31:36 <lambdabot> lispy says: lambdabot, changing the way Haskllers think since 2003
14:31:38 <kmc> @quote [0-9]{5}
14:31:39 <lambdabot> urxvt-transparency says: http://lists.schmorp.de/pipermail/rxvt-unicode/2008q1/000552.html
14:31:44 <kmc> @quote [0-9]{9}
14:31:45 <lambdabot> ghc says: internal error: scavenge_mark_stack: unimplemented/strange closure type -1368815400 @ 0x2aaaae6981f8
14:31:59 <sproingie> @quote \d{5}
14:32:00 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
14:32:07 <int80_h> ski: thanks , will /= seperate my string for me though?
14:32:10 <sproingie> bah.  ancient posix regex
14:32:13 <FauxFaux> @ghc
14:32:13 <lambdabot> ghc says: strange object 28
14:32:18 <int80_h> oh I see break with /=
14:32:19 <kmc> @quote ^[^a-zA-z]$
14:32:20 <lambdabot> No quotes match. My mind is going. I can feel it.
14:32:27 <kmc> @quote ^[^a-zA-z]*$
14:32:28 <lambdabot> SAHChandler says: :|
14:32:31 <kmc> @quote ^[^a-zA-z]*$
14:32:32 <lambdabot> mIRC says: %03^_^
14:32:37 <kmc> @quote ^[^a-zA-z]*$
14:32:38 <lambdabot> Tinned_Tuna says: :-)
14:32:40 <ski> int80_h : also, actually, i think you want to pass  (/= ':') as *argument* to `break', not trying to pass `break' as argument to   (/= ':')
14:32:59 <ski> > break (/= ':') "abc:de:f:"
14:33:00 <lambdabot>   ("","abc:de:f:")
14:33:06 <ski> > break (== ':') "abc:de:f:"
14:33:07 <lambdabot>   ("abc",":de:f:")
14:33:14 <dankna> @quote ^[^a-zA-z]{10-}$
14:33:14 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 10,"Invalid content of \\{\\}")
14:33:21 <dankna> @quote ^[^a-zA-z]{10-100}$
14:33:22 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 10,"Invalid content of \\{\\}")
14:33:26 <dankna> @quote ^[^a-zA-z]{10,100}$
14:33:26 <lambdabot> No quotes match. You type like i drive.
14:33:28 <ski> (so the negation was misguided, using `break')
14:33:35 <ski> > span (/= ':') "abc:de:f:"
14:33:36 <lambdabot>   ("abc",":de:f:")
14:33:38 <ski> > span (== ':') "abc:de:f:"
14:33:39 <lambdabot>   ("","abc:de:f:")
14:34:03 <ski> int80_h : ^
14:34:06 <int80_h> span, not break...gotcha
14:34:11 <ski> either works
14:34:25 <ski> but  break (/= ':')  is probably not what you want
14:34:27 <napping> ezyang: the problem is that you have never forced Ctor mb (CVal mb) ~ mb
14:34:35 <alex404> Does anyone have opinions on the realtive merits of gstreamer vs mpd as music player backends?
14:34:36 <ski> so  break (== ':')  or  span (/= ':')
14:34:38 <int80_h> ski: yeah it did not give the result I wanted
14:35:01 <int80_h> I want "a:b" to become (a,b)
14:35:15 <EvanR-work> xmms2!!!!11 >_<
14:35:23 <ezyang> napping: Yah. 
14:35:24 <napping> ezyang: see the revision to the paste
14:35:33 <chrisf> alex404: given that they are pretty much without merit entirely, any *relative* merits are just noise :P
14:35:58 <ezyang> Oh that is cute. 
14:36:11 <alex404> chrisf: That's not very helpful :P
14:36:13 <int80_h> ski: the examples that you showed don't give the results I'm looking for 
14:36:15 <napping> in particular, if you really need to be able to destructure types like that, I'd suggest putting the type synonyms and also such a cast into a class
14:36:26 <ski> int80_h : which of them ?
14:36:43 <ski> what are you looking for ?
14:36:45 <int80_h>  ski: unless I missed something ,all of them
14:36:56 <napping> perhaps you should report such a thing though, it seems normalization is insufficiently aggressive
14:36:57 <int80_h> look for "a:b" to become (a,b)
14:37:12 <ski> what if there is no `:' in the string ?
14:37:27 <int80_h> ski: there has to be, I guarantee it
14:37:28 <napping> if it can't take a context presumably containing FooTwo (Ctor (f Int)) (Cval (f Int)) and deduce FooTwo f Int
14:37:56 <ski> > let (a,':':b) = span (/= ':') "a:b" in (a,b)  -- int80_h
14:37:57 <EvanR-work> software is better when you dont assume things about the input besides its type
14:37:57 <lambdabot>   ("a","b")
14:37:58 <napping> otoh, because type functions may not be injective it probably must keep that non-normalized version about
14:38:04 <int80_h> : is a csv, I suppose I could generalize for all csv.
14:38:10 <EvanR-work> if its a parser, then it should act accordingly if its not parsable
14:38:20 <napping> int80_h: have you gotten to the point where you try to parse tables out of files?
14:38:48 <int80_h>  napping: yes I have flat files with : as a csv.
14:38:58 <ezyang> napping: Yeah, I think it's all about injectivity. 
14:39:02 <int80_h> this is an example program. I'm taking flat files and making them relational
14:39:03 <ezyang> So not a bug, afaict. 
14:39:05 <napping> ezyang: I doubt you need anything nearly this fancy to do that sort of specialization anyway
14:39:15 <napping> what was the example you actually cared about?
14:39:41 <kmc> EvanR-work, true, preconditions can often be expressed in types
14:39:49 <kmc> but postconditions rarely
14:40:08 <int80_h> napping: huh?
14:40:16 <kmc> outside of dependently typed languages perhaps
14:40:28 <ezyang> napping: Something like 'GeneralClass a Special c => a Special c' -> 'SpecialClass ab c => ab c' 
14:40:43 <ski> ezyang : what is `Ctor Int (CtorVal Int)' ?
14:40:53 <ezyang> see above ^ 
14:40:57 <mee> int80_h: you might also want to take a look at a relevant example in RWH: http://book.realworldhaskell.org/read/data-structures.html (search for "split _ [] = [[]]
14:41:00 <mee> ")
14:41:22 <EvanR-work> kmc: a postcondition is a condition on the result?
14:41:26 <EvanR-work> other than its type?
14:41:48 <napping> ezyang: shouldn't that rather be SpecialClass a c => a Special c
14:42:15 <napping> if it's not quite apparent that the second parameter can only be Special, it just seems like a more complicated way of rewriting the more general class
14:42:39 <ezyang> napping: Aw, but that's easy! 
14:42:45 <kmc> yeah EvanR-work
14:42:53 <EvanR-work> hmm
14:43:02 <EvanR-work> dont use assume any post conditions ;)
14:43:03 <adnap> What is this syntax with the '|'? class MonadState m s | m -> s where 
14:43:11 <ezyang> adnap: Functional dependencies. 
14:43:11 <kmc> adnap, a "functional dependency"
14:43:22 <adnap> Is it standard?
14:43:23 <kmc> says for each type m, you can only have one choice for s
14:43:30 <kmc> adnap, it's a extension in GHC and some other implementations
14:43:31 <ezyang> adnap: GHC extension. 
14:43:39 <kmc> adnap, only makes sense with multi-parameter type classes, which are themselves an extension
14:44:30 <adnap> So, it says that each unique monad corresponds to exactly one unique state?
14:44:49 <kmc> yes
14:44:49 <ski> (also Hugs)
14:44:58 <kmc> no state monad makes sense with more than one state type
14:45:11 <kmc> adnap, and this allows type inference to proceed in some cases where there would otherwise be ambiguity
14:45:27 <adnap> kmc: I see.
14:45:33 <int80_h> ski : can I use where ... in in a similar fashion to your let binding?
14:46:03 <ski> adnap : it says `forall m. unique s. MonadState m s', which means `forall m s0 s1. (MonadState m s0,MonadState m s1) => s0 = s1' .. in words : there can not be *more* than one `s' associated with any `m', satisfying `MonadState'
14:46:18 <ezyang> napping: It is apparent, because a is actually a associated data type. 
14:46:38 <adnap> And m and s are both type variables.  's' is not a parameter to m.
14:46:39 <ski> int80_h : probably .. as long as the definitions in your `where' doesn't need to refer to values bound inside a `do'-block
14:47:33 <ezyang> napping: So, an "un-generalized" version of this code would automatically use the second type signature. 
14:47:41 <ezyang> In fact, that's what I had originally, before I generalized. 
14:48:18 <napping> I expect that should work smoothly
14:48:26 <napping> and you should post the example on th elist
14:48:35 <ezyang> haskell-cafe, you mean? 
14:48:50 <napping> the broken one - I think it's not correctly unifying instances in scope with the requested instance
14:48:56 <ski> (s/satisfying `MonadState'/satisfying `MonadState m s'/)
14:49:14 <alex404> chrisf: Is there an overall best backend for music that you know of?
14:49:24 <ezyang> napping: ok. 
14:49:45 <adnap> So, MonadState is a multi-parameter type class taking types 'm' and 's', but is 's' also a parameter to 'm'?  The function "get" has type "m s", so I'm guessing 's' is also a parameter to 'm'.
14:50:25 <kmc> @src MonadState
14:50:26 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:50:27 <int80_h> ski: I have a question about your let binding
14:50:28 <chrisf> alex404: no, i don't know of anything i actually *like*.
14:50:45 <int80_h> ski: let (a,':':b) = span (/= ':') test in (a,b)
14:50:52 <kmc> class Monad m => MonadState s m | m -> s where
14:50:52 <kmc>   get :: m s
14:50:52 <kmc>   put :: s -> m ()
14:50:53 <chrisf> alex404: go with either of mpd or gstreamer. mpd if you think GObject is disgusting.
14:50:58 <ski> int80_h : yes ?
14:51:00 <int80_h> what does the statement bind to? I can I refer to it?
14:51:13 <int80_h> I mean how can I refer to it
14:51:22 <alex404> chrisf: Thanks for the tip.
14:51:23 <kmc> adnap, ¬´get :: m s¬ª because it's an action which gets the state
14:51:25 <kmc> and the state has type s
14:51:30 <kmc> but elsewhere m is used with other types
14:51:30 <ski> `let (a,':':b) = span (/= ':') test in (a,b)' is an expression, so you can put it anywhere an expression is expected
14:51:32 <kmc> as in "put"
14:51:58 <int80_h> ski, but I need to take the result of that expression and manipulate it.
14:52:13 <ski> int80_h : also, if you want, you could split out the `(a,':':b) = span (/= ':')' part, put it in a `let' or `where', and then use `(a,b)' somewhere in there
14:52:13 <kmc> adnap, it may be instructive to consider the instance for (State s)
14:52:18 <kmc> @unmtl State s a
14:52:19 <lambdabot> s -> (a, s)
14:52:22 <ski> int80_h : yeah, so do that :)
14:52:32 <napping> ezyang: I tried to use fundeps, but you can't write a line
14:52:37 <napping> class (Ctor mb m, Cval mb b, FooTwo m b) => FooOne mb where
14:52:39 <kmc> get = State $ \s -> (s, s)
14:52:39 <ski> int80_h : also, you could define a new function
14:52:43 <kmc> put s = State $ \_ -> ((), s)
14:52:52 <ski>   splitCSV ab = (a,b)
14:52:54 <ski>     where
14:53:00 <ski>     (a,':':b) = span (/= ':') ab
14:53:00 <ezyang> napping: submitted 
14:53:08 <ski> or something like that
14:53:45 <ski> adnap : `s' *can*be* a parameter to `m'
14:54:24 <int80_h> ski: is ab the original string "a:b"?
14:54:27 <ski>   instance MonadState (State s) s
14:54:28 <ski>     where
14:54:34 <int80_h> because I am confused 
14:54:41 <ski> --  get :: State s s
14:54:50 <ski>     get = State (\s -> (s,s))
14:54:58 <ski> --  put :: s -> State s ()
14:55:09 <ski>     put s = State (\_ -> ((),s))
14:55:12 <ski> adnap : ^
14:55:20 <ski> int80_h : yes
14:55:29 <adnap> ski: Yeah, I've been reading this page: http://www.haskell.org/all_about_monads/html/statemonad.html
14:56:10 <ski> adnap : so, in `get :: m s', when `m' is `State s', it becomes `get :: State s s', while `put :: s -> m ()' becomes `put :: s -> State s ()'
14:56:24 <int80_h> ski: oh I think I have it. I am going to try and keep this in one function, and do a where clause.
14:56:26 <ski> adnap : so, to be clear, `State' is not a monad, but `State s' is a monad, for every type `s'
14:57:15 <ski> adnap : and then `instance MonadState (State s) s' is claiming that `State s' is a monad that supports state operations, with state-type `s', (for any type `s', since it's a type variable)
14:58:07 <adnap> ski: Thanks.  It's confusing on the webpage because they use the same letter for two different type variables.
14:58:26 <adnap> ski: 
14:58:33 <adnap> ski: 
14:58:37 <adnap> Argh
14:58:54 <adnap> ski: instance MonadState (State s) s where
14:59:01 <kmc> that's the same variable
14:59:13 <kmc> you can't write ¬´instance MonadState (State s) t¬ª
14:59:28 <adnap> kmc: Why did ski use s' then?
14:59:40 <kmc> because ski quotes things `like this'
14:59:54 <adnap> kmc: Oh! XD
15:00:25 <kmc> this is why i prefer ¬´the guillemets¬ª
15:00:39 <kmc> they are (almost?) never found in Haskell code
15:01:24 <adnap> So, the type of the first parameter to State and the second to MonadState are the same.
15:01:26 <benmachine> getLine ¬ª= putStrLn?
15:01:46 <ddarius> I just make finger quotes in the air when I type things that need quotes.
15:01:57 <EvanR-work> pwned
15:01:59 <ski> adnap : in the case of `State s', yes
15:03:00 <fergie> Suppose I multiply data types: "data Number = ONE | TWO | THREE ... | TEN". Is it possible to use the type system to make sure a function can only take ONE, TWO or THREE as arguments and another function can only take TWO, THREE, FOUR as examples?
15:03:30 <ski> not using that exact data type
15:03:40 <fergie> Any pointers towards resources that might help with this would be great
15:04:08 <napping> is there a little more structure to what you want?
15:04:21 <ski> it sounds like you want something like refinement types .. or possibly something like O'Camls polymorphic variants
15:04:34 <int80_h> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29238#a29238
15:04:43 <napping> It's a bit of a pain to do in Haskell if you want to allow arbitrary subsets
15:04:45 * EvanR-work wonders what TWO times THREE is
15:05:04 <int80_h> it's FIVE!
15:05:14 <fergie> napping: I have a list of languages codes and a list of country codes. Some of the codes are the same. I want to have some functions take only languages and some take only countries
15:05:16 <int80_h> easy peasy.
15:05:26 <EvanR-work> its TWELVE last i checked
15:05:30 <EvanR-work> er
15:05:33 <EvanR-work> SIX
15:05:43 <napping> for that, you might just declare separate types
15:05:44 * EvanR-work changes his problem to THREE times FOUR
15:05:46 <int80_h> trying using new math, it comes out to FIVE
15:06:08 <napping> but with only two, it's easy enough. Probably easiest with GADTs
15:06:33 <fergie> napping: but then I will have to write read/show instances for each type. I was hoping to avoid this work
15:06:33 <ski> int80_h : you want `parsedEntry' bound to *which* tuple ?
15:06:51 <fergie> napping: GADT?
15:07:11 <int80_h>  ski: the one made by the string entry, which will be of form "a:b"
15:07:15 <napping> can't you derive read and show?
15:07:33 <napping> put them in separate modules and they can both use the same constructors
15:07:49 <ski> int80_h : you mean you want to say `parsedEntry = splitCSV entry' ?
15:08:19 <int80_h>  ski: okay I could do that. I was thinking it might make more sense to put it all in the where clause
15:08:24 <fergie> napping: separate modules is definitely the easiest way to go. Problem solved :-) No reason why they have to be in the same module
15:08:27 <int80_h> I will do as you suggest
15:08:34 <fergie> thank you
15:08:35 <Sadache> hello everyone
15:09:18 <ski> int80_h : in that case `parsedEntry' will be a pair of two strings, so `CostorID = fst parsedEntry' and `PersonOrActivity = snd parsedEntry' will not work
15:09:22 <napping> fergie: ask again if you end up really needing to mix things together
15:09:25 <Sadache> I have a list of tags as  [String] and a list of posts, and each post is tagged with multiple tags. I'd like to sort the posts by relevance.
15:09:36 <ski> int80_h : maybe you wanted to say `costorID = fst parsedEntry' and `personOrActivity = snd parsedEntry' ?
15:09:59 <napping> Sadache: if you want something very simple, sortBy might work
15:10:20 <int80_h>  ski: yes, and that is what my code looks like now, except I haven't added splitCSV yet.
15:10:21 <fergie> napping: will do. Thanks again. Been stuck on this all day
15:10:49 <napping> Sadache: check out Data.List.sortBy, Data.Ord.comparing
15:11:25 <napping> like, sortBy (comparing (\post -> length (intersect (postTags post) targetTags))
15:13:38 <ski> int80_h : so, is there any point in splitting `parsedEntry' into `costOrID' and `parsedEntry' only to pair them together again in `tableColumns = (personOrActivity, costOrID)' ?
15:14:27 <ski> int80_h : in case the `tableColumns' field don't want a pair of two *strings*, then there's a point to split in that manner .. otherwise, just say `tableColumns = parsedEntry', or even `tableColumns = splitCSV entry'
15:14:45 <ski> (removing the unused bindings from the `where')
15:16:30 <int80_h>  ski: tableColumns will always want a pair of two strings. This is just a demo
15:16:58 <int80_h> ski: But you know, making these into tuples may be wasted code. I just wanted a way to easily handle csv
15:17:21 <ski> well, as long as you learn something :)
15:18:46 <int80_h> ski: if I just had "foo:bar" and I needed to seperate into "foo" and bar (bar is an Int in this example) how could I do it if I didn
15:18:55 <int80_h> if I didn't want to make it a tuple
15:19:10 <int80_h> because it seems to me, once you have it in tuple form, it is easily handled.
15:19:50 <ski> what do you mean "if I didn't want to make it a tuple" ?
15:20:06 <ski> one you've extracted the `foo' and `bar' parts, you can do anything you like with them
15:20:24 <ski> i just bundled them up in a tuple to be able to return both of them from the `splitCSV' function
15:20:24 <int80_h> ski: you suggested that breaking it apart only to put it together again into as tuple m,ight be questionable.
15:20:50 <ski> yeah, it would be useless work, in that case :)
15:21:27 <ski> but in your case, you apparently *wanted* to make it into a tuple, to put it into the `tableColumns' field
15:21:41 <int80_h> ski: yes!
15:22:07 <int80_h> ski: It's good to go over why I'm doing what I amn doing though. So we will keep it this way. But nowe I have more problems. pasting
15:22:09 <ski> otherwise you'd just say `(foo,bar) = splitCSV entry' in some `where' or `let', and then just go on using `foo' and `bar' however you wished to
15:24:00 <int80_h> hpaste seems to be dead
15:24:26 <ski> @where paste
15:24:26 <ski> ?
15:24:26 <lambdabot> http://hpaste.org/new
15:24:45 <int80_h> can't get to it from here.
15:24:49 <int80_h> pasting elsewhere
15:25:10 <dolio> The reports of its death are greatly exaggerated.
15:25:22 <ski> <http://paste.lisp.org/new> ?
15:26:47 <int80_h> wierd not finding that either. then there's sketchy pastebin.com that wants my e-mail address.
15:27:27 <int80_h> http://pastebin.com/jkpm4R3M
15:28:38 <napping> that's pretty broken
15:28:50 <napping> Table has a parameter, so you can't just write "Table" in a type
15:28:53 <doofer> where in the module hierarchy would you put a library for expressing language grammars paired with a parser generator? most parser libraries seem to be under Text.ParserCombinators, but it's not a ParserCombinator and it works on any token type (not just text)
15:29:20 <napping> on the other hand, it's a record with just two fields, so you can't write anything outisde the {} on line 9
15:30:24 <ski> int80_h : `splitCSV' has type errors, since `span' gives `coi' the type `String', but you're claiming to want to return `coi' as a `Value'
15:31:19 <napping> http://pastebin.com/zXkBjAx3 is a bit improved
15:31:30 <napping> you can't use uppercase names for variables
15:31:48 <ski> int80_h : it might be clearer to you if you renamed like `data Table a = MkTable ...'
15:32:08 <ski> then on line `9' you should say `MkTable', not `Table Value'
15:32:09 <BMeph> doofer: "Data.Parser", maybe? :)
15:32:31 <ddarius> ski was just using the universal property of pairs to demonstrate his point.
15:32:43 <ski> `MkTable' is the data constructor of the type `Table a', while `Table' is a type constructor .. they are two completely different things
15:33:05 <doofer> BMeph: yeah, that sounds more reasonable than Text at least :)
15:33:27 * ski doesn't even know what the universal property of pairs is ..
15:33:55 <ddarius> One way of writing it is: Hom(AxB,C) ~ Hom(A,C)xHom(B,C)
15:34:10 <ski> (as opposed to the UP of (categorical) products ..)
15:34:43 <dolio> ddarius: Isn't that +?
15:34:57 <ski> looks like that
15:35:00 <int80_h> ski: hold on. I thought by saying "data Table a..." I could then substitute any type for a.
15:35:14 <napping> in the types, yes
15:35:22 <int80_h> a is a parameter, but what am I paramatizing?
15:35:24 <ddarius> dolio: Er, yeah, switch the thing left for right.
15:35:27 <ski> dolio : but, it's products in the opposite category .. that must be what ddarius was ruminating about !
15:35:31 <int80_h> if not an arbitrary type
15:35:34 <dolio> :)
15:36:12 <ddarius> All one needs are initial objects (but if you take that perspective you need to be able to make clever categories.)
15:36:17 <ski> int80_h : `Table a' is like saying `[a]', iow "the type of lists of elements with type `a'"
15:36:24 <napping> int80_h: the type constructor Table takes the parameter, not the constructor
15:36:33 <ski> int80_h : so `Table a' is "tables of `a'"
15:36:46 <napping> int80_h: like how you write [Int] or [Char], but always 1:2:3:[] or 'a':'y':'z':[]
15:36:50 <dolio> It's all comma categories.
15:36:52 * ddarius should verify his adjunctions with their continuity properties.
15:37:30 <ski> int80_h : now be a good boy/girl and rename like `data Table a = MkTable ...' until you're sure which of `Table' and `MkTable' is which, so you won't conflate them, ok ? :)
15:37:30 <int80_h>  ski: in that case I am totally confused as to why I have tableColumns :: (String, a) as a field.
15:37:33 <ddarius> dolio: Comma-categories are lax limits and can also be presented as a pullback in Cat.
15:37:34 <napping> int80_h: but can't write values like "[] Char", and can't write values that have a type "[]"
15:38:11 <ski> ddarius : whence adjunctions ?
15:38:16 <dolio> Yeah, that makes sense.
15:38:55 <ski> int80_h : hm, why ?
15:39:10 <dolio> ddarius: The comma category definition of adjunctions seems nice to me because it's similar to the hom-set definition (which is frequently useful), but it doesn't talk about sets.
15:39:54 <int80_h> ski: testSystem.lhs:8:18: Not a data constructor: `mkTable'
15:40:09 <int80_h> I will post my code
15:40:11 <napping> int80_h: MkTable, not mkTable
15:40:38 <napping> the case of the first letter is used as a lexical hint to separate constructors from variables
15:41:38 <ddarius> dolio: That's how I was to begin with but, while I still appreciate set-free definitions, I find it much more effective to use Hom based definitions.
15:42:08 <dolio> The Hom version is still simpler, certainly.
15:43:19 <ddarius> dolio: It's not just simpler, but, when Hom based definitions are used consistently they are much easier to calculate with.
15:46:23 <int80_h> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29238#a29239
15:47:16 <ski> yeah, in
15:47:18 <ski>   mkTableRecords :: String -> String -> [Table]
15:47:20 <ski> you need to say
15:47:29 <ski>   mkTableRecords :: String -> String -> [Table ???]
15:47:44 <ski> for some type `???', since you've defined `Table' to take a type parameter
15:47:45 <int80_h> literally ???
15:47:59 <ski> possibly what you want is
15:48:02 <ski>   mkTableRecords :: String -> String -> [Table Value]
15:48:08 <int80_h> yes
15:48:19 <int80_h> that leads to other problems but that would be the right type
15:48:23 <ski> (no, `???' was just pseudo-code for a hole to be filled in)
15:48:37 <ski> yeah, so do that change first
15:48:53 <ski> then, as i said above, you need to change `splitCSV'
15:48:54 <int80_h> now I need to change those strings into Ints
15:49:10 <ski> in
15:49:11 <ski>   (poa,':':coi) = span (/= ':') line
15:49:12 <int80_h> or Values
15:49:19 <ski> `span' makes `coi' into a `String'
15:49:22 <napping> well, you don't seem to know what kind of table you are making yet
15:49:39 <napping> so you should probably make them into Int, and have mkTableRecords return a [Table Int]
15:49:40 <int80_h> napping: I do, I may not be expressive enough.
15:49:53 <ski> but then you return `(poa,coi)' from `splitCSV line', and that second part of that pair is expected to have type `Value', not `String'
15:50:00 <ski> so, either change the type of `splitCSV'
15:50:13 <ski> or convert `coi' from a `String' to a `Value', inside it
15:50:26 <napping> int80_h: I don't see how splitCSV can know from the text if it should make a Cost or an ID
15:50:40 <ddarius> dolio: In my opinion there are three main approaches to category theory reflecting the three ways of characterizing universal properties: initial objects, universal arrows, and representability.  I prefer the representability approach.  The universal arrows approach is nice and generalizes more easily but has some problems with manipulability.  The initial object approach is what Fokkinga uses which has some nice calculational benefits but suffers from ne
15:50:40 <ddarius> eding to define arbitrary seeming categories, which is difficult to do compactly.
15:50:43 <int80_h> ski: well I know that I can convert a String into an Int. But how would I convert to a type I invented?
15:51:07 <napping> applying Cost or ID
15:51:25 <napping> constructors can be treated as functions, so Cost :: Int -> Value, ID :: Int -> Value
15:51:29 <int80_h>  napping:  an't I just call it a value, and not have to know?
15:51:48 <ski> int80_h : since you have defined `data Value = Cost Int | ID Int', that means that both `Cost' and `ID' converts `Int's into `Value's
15:52:40 <ski> no, if you have something of type `Value', then you can pattern-match on whether it is `Cost n' or `ID m' .. and do different things in each case
15:52:51 <napping> int80_h: when you defined value, you said that you want to make a distinction
15:52:56 <ski> which means that when you construct a `Value' you must tell which of the two cases it should be
15:53:13 <ski> (and you do that be deciding to either use `Cost', or use `ID')
15:53:40 <napping> int80_h: if you don't want to make a distinction yet, return a Table Int instead
15:54:06 <napping> or, give mkTableRecords some extra argument that says which sort of table you build
15:54:08 <jozi> Can somebody give me a hint how to fold over a binary tree? I'm getting crazy over here :/
15:54:18 <napping> jozi: check Data.Tree?
15:54:30 <ddarius> Data.Tree isn't binary
15:54:41 <napping> yeah, it's a "hint"
15:54:43 <ddarius> That said, the idea is the same for all (positive) data types.
15:55:03 <jozi> I defined a foldMap in "instance Foldable Tree where ...".
15:55:06 <int80_h>  napping: I'm going to just return a Table Int. I can only see making the distinction using a command line argument, and I don't have time for that today.
15:55:28 <jozi> But I'm getting a "weird" type error in ghci.
15:55:28 <monochrom> do unto children what is done unto the parent
15:55:51 <monochrom> Foldable is harder to implement.
15:55:53 <napping> int80_h: well, once you get farther along you'll probably know that "itemcosts.csv" is supposed to be a Table Cost and so on
15:55:54 <int80_h> so that decided, I still need to convert those strings into Ints.
15:55:56 <jozi> Ambigous type variable in constraints.
15:56:27 <mjrosenb> is there a good way to generate the cartesian product of two infinite sets?
15:56:31 <napping> int80_h: or you could put a code somewhere early in the file, and have a function along the lines of "parseCode :: String -> (Int -> Value)"
15:56:38 <jozi> monochrom: that's what I was trying in principle.
15:56:39 <ski> @let foldTree :: (a -> [o] -> o) -> (Tree a -> o); foldTree node (Node a ts) = node a (map (foldTree node) ts)  -- jozi
15:56:39 <int80_h>  napping: oh yeah I can just do a lookup for "cost"
15:56:40 <lambdabot>  Defined.
15:56:50 <napping> int80_h: wait, I'm a bit confused why you have a unified value type still
15:56:58 <ski> that's the structural fold on `Tree'
15:57:13 <napping> (and also why your tables only have one row, but that's more straightforward)
15:57:15 <int80_h>  napping: I was told that I should.
15:57:28 <mjrosenb> i suspect that the list monad won't actually be helpful
15:57:44 <int80_h> napping: they have aribitrary rows. my test files have four rows each I think
15:57:48 <napping> int80_h: defining Value like you did only makes sense if you want to be able to put costs next to ids in the same container
15:57:49 <jozi> ski: why the [o]?
15:58:16 <int80_h>  napping: I think I do.
15:58:18 <napping> int80_h: re row count, I guess you are using [Table v]? then it seems odd that each row has it's own tableName
15:58:32 <ddarius> mjrosenb: There's multiple ways.  If you want something quick, you could use the Omega monad on Hackage.
15:58:33 <int80_h> napping: If I'm not confused by the meaning of container, then I do.
15:58:47 <jozi> ski: I have: data Tree a = Leaf | Node (Tree a) a (Tree a) deriving Show, and defined: foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
15:59:00 <ski> > take 16 $ [0 ..] >>- \x -> [0 ..] >>- \y -> [(x,y)]  -- mjrosenb
15:59:01 <lambdabot>   [(0,0),(1,0),(0,1),(2,0),(0,2),(1,1),(0,3),(3,0),(0,4),(1,2),(0,5),(2,1),(0...
15:59:02 <napping> ok, seems like the name is a bit misleading, I'd expect a table with one name and a list of rows
15:59:17 <ski> > take 16 $ [0 ..] >>- \x -> (`map` [0 ..]) $ \y -> (x,y)  -- also
15:59:19 <lambdabot>   [(0,0),(1,0),(0,1),(2,0),(0,2),(1,1),(0,3),(3,0),(0,4),(1,2),(0,5),(2,1),(0...
15:59:20 <napping> or perhaps each row to have a name and description as two strings
15:59:32 <int80_h>  napping: oh hell, I see what I did. The data type is wrong
15:59:44 <ski> jozi : do you want a structural fold, or do you want `Foldable' ?
15:59:52 <jozi> ski: what's the difference?
16:00:15 <jozi> Specifically, I want to count the nodes, but I'd like have more generalized approach.
16:00:18 <ddarius> Foldable just means "has a toList function"
16:00:35 <napping> int80_h: like, data Table a = MkTable { tableName :: String, tableRows :: [(String,a)]}
16:00:57 <ski> jozi : for a structural fold, you should have `foldTree :: o -> (o -> a -> o -> o) -> (Tree a -> o)', for that `Tree' type .. which is a different type signature (and does something else) than what you'd do with `Foldable'
16:00:59 <jozi> Well, I want to transform each tree element with a function, and combine these results with another function -- recursively.
16:01:28 <int80_h>  napping: I *did* have it that way, and thought I was fixing my code when I changed it. brainless.
16:02:07 <int80_h> okay I am using Table Ints for now and working on this line where (poa,':':coi) = span (/= ':') line
16:02:09 <napping> int80_h: so, will a single table have Cost in some records and ID in others?
16:02:26 <napping> int80_h: for the parsing, "read" is the simple function
16:02:30 <jozi> ski: can you explain the (o -> a -> o -> o) part?
16:02:41 <napping> you might prefer just to derive (Show, Read), rather than writing your own csv parser
16:02:47 <ski> jozi : "why the [o]" - well that previous `foldTree' was for the `data Tree a = Node a [Tree a]' declaration in `Data.Tree', which i first thought you were talking about
16:02:49 <napping> at least, that should be quick for now
16:02:50 <int80_h>  napping: a table with either have Cost or ID
16:02:56 <mjrosenb> let prod a b = concatMap (\n-> zip a (reverse . take n $ b)) [0..] in take 10 $ prod [0..] "hello world"
16:02:58 <jozi> ski: ah, ok
16:03:02 <mjrosenb> > let prod a b = concatMap (\n-> zip a (reverse . take n $ b)) [0..] in take 10 $ prod [0..] "hello world"
16:03:04 <lambdabot>   [(0,'h'),(0,'e'),(1,'h'),(0,'l'),(1,'e'),(2,'h'),(0,'l'),(1,'l'),(2,'e'),(3...
16:03:17 <ski> jozi : a structural fold just "replaces the constructors with arbitrary (given) operations"
16:03:22 <ski> so, if you have the tree
16:03:32 <napping> int80_h: but not both? (I'm imagining some items with fixes prices, and others that refer to a function ID for computing current price)
16:03:36 <mjrosenb> ski: i was attempting to avoid [0..], but meh
16:03:43 <mjrosenb> ski: what the deuce is >>-?
16:03:57 <int80_h> napping: not both. I wil lshow you the test data I am using
16:04:10 <ddarius> :t (>>-)
16:04:10 <int80_h> http://www.geekgirls.com/databases_from_scratch_3.htm
16:04:11 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
16:04:30 <ski>   Node (Node (Node Leaf 0 Leaf) 1 (Node Leaf 2 Leaf)) 3 (Node (Node Leaf 4 Leaf) 5 (Node Leaf 6 Leaf))
16:04:42 <int80_h> napping: if you think I can get away with not having to write a parsing function, please do instruct me
16:04:42 <jozi> ski: seems like I want this: foldMap f  Leaf = mempty; foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
16:04:48 <mjrosenb> MonadLogic ... never heard of that one before
16:04:54 <ski> jozi : now, what `foldTree' (the structural fold) does in this case is just :
16:05:00 <napping> int80_h: if you derive Read and Show, (read . show) should be the identity
16:05:08 <ski>      foldTree leaf node (Node (Node (Node Leaf 0 Leaf) 1 (Node Leaf 2 Leaf)) 3 (Node (Node Leaf 4 Leaf) 5 (Node Leaf 6 Leaf)))
16:05:26 <napping> this doesn't handling parse errors nicely, give efficient code or human readable output, but it is quick
16:05:34 <int80_h> I don't know what "should be the identity" means.
16:05:45 <ski>   =                      node (node (node leaf 0 leaf) 1 (node leaf 2 leaf)) 3 (node (node leaf 4 leaf) 5 (node leaf 6 leaf))
16:05:56 <kmc> the identity function is the function which returns its input unchanged
16:05:58 <kmc> @src id
16:05:58 <lambdabot> id x = x
16:06:03 <napping> like, if you make a string with "show x", and then run that string through "read" (perhaps after sticking it into a file an retrieving it), you should get the same x back
16:06:30 <ski> jozi : which means that if you want to count the number of nodes in a `tree', then you just say `foldTree 0 (\m _ n -> 1 + m + n) tree'
16:06:40 <jozi> ski: but getting "ambiguous type variable" when calling: foldMap (const 1) t
16:06:50 <jozi> ski: looking at your solution
16:07:06 <napping> int80_h: how "read" parses is determined by the inferred return type, so you'll have to decide a bit earlier what kind of table you expect
16:07:25 <napping> int80_h: or perhaps wrap a tag around it with a type like data AnyTable = CostTable (Table Cost) | IDTable (Table Id)
16:07:45 <napping> >show (Just 12)
16:07:46 <ski> jozi : `foldTree 0 (\m _ n -> 1 + m + n) tree' read as "the number of nodes in a leaf is zero, and the number of nodes in a *node* is one plus the number of nodes in the two subtrees"
16:07:53 <napping> > show (Just 12)
16:07:54 <lambdabot>   "Just 12"
16:08:01 <napping> > read (show (Just 12)) :: Maybe Int
16:08:03 <lambdabot>   Just 12
16:08:51 <jozi> ski: sounds good -- but I'll have to adjust your foldTree function since I have a different Tree, right?
16:08:54 <int80_h> napping: is Just a monad?
16:09:05 <aristid> int80_h: no.
16:09:14 <ski> jozi : btw, note that `leaf' and `node' in the code is arbitrary operations, i've just named them similarly to the (data) constructors `Leaf' and `Node' to emphasize the "fold replaces constructors" idea
16:09:19 <int80_h> napping: how do I remove Just from Just 12, for example.
16:09:26 <aristid> :t fromJust
16:09:27 <lambdabot> forall a. Maybe a -> a
16:09:35 <aristid> > fromJust (Just 12)
16:09:36 <lambdabot>   12
16:09:39 <ski> jozi : no, my last `foldTree' was written for your `data Tree a = Leaf | Node (Tree a) a (Tree a) deriving Show'
16:09:40 <aristid> > fromJust Nothing
16:09:41 <lambdabot>   *Exception: Maybe.fromJust: Nothing
16:10:05 <napping> int80_h: that's just an example, no need for you to use Maybe in your code
16:10:25 <ski> jozi : er, sorry, i dodn't get around to actually implementing that `foldTree' for you .. i only gave you the type signature
16:10:36 <napping> you can take them apart with <case mb of Just i -> ...; Nothing -> ...> if you want
16:10:54 <jozi> ski: ah, ok ... left as exercise to the reader ;-)
16:10:55 <ski> jozi : so, do you want to figure out the implementation of `foldTree :: o -> (o -> a -> o -> o) -> (Tree a -> o)' yourself, or do you want me to give it ?
16:11:13 <jozi> ski: Thanks, I'll give it a shot.
16:11:18 <ski> (it's not really that hard, if you get what it's supposed to do)
16:11:28 <ski> remember that
16:11:42 <jozi> ski: But any idea what could be wrong with my foldMap? It typechecks, after all ...
16:11:54 <ski>   foldTree l n (Node (Node Leaf x Leaf) y Leaf
16:12:00 <ski> should simplify to
16:12:12 <ski>   n (n l x l) y l
16:12:14 <jozi> ski: I'm just not sure what the (o -> a -> o -> o) denotes.
16:12:24 <ski> that's the type of the function argument `n'
16:12:47 <int80_h> okay I am posting what I have, I'm hoping for some instruction on how to use Read.
16:12:51 <ski> `foldTree' is a function that takes one argument (i named it `leaf' before, and `l' just above) of type `o',
16:13:10 <ski> and one argument (named `node' before, `n' just above) of type `o -> a -> o -> o'
16:13:24 <jozi> ski: oh, I get it now.
16:13:26 <ski> and then it takes an actual `Tree a', and returns an `o'
16:14:15 <ski> (napping : .. or `maybe (...) (\i -> ..i..) mb')
16:15:07 <ski> int80_h : `Just' is a data constructor, not a type, so asking whether it is a monad is an ill-formed question :) .. `Maybe', however, is a monad
16:15:10 <ski> @type Just
16:15:12 <lambdabot> forall a. a -> Maybe a
16:16:48 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29238#a29241
16:17:11 <int80_h> I gotcha
16:18:02 <napping> once you have read and show, you can write a file like
16:18:07 <napping> writeFile "path" (show table)
16:18:23 <napping> and get a table out like table <- liftM read (readFile "path")
16:18:31 <kmc> int80_h, fromJust is usually a bad idea, since it will throw an exception if it encounters Nothincg
16:18:31 <napping> but you have to know what type you want back
16:18:44 <kmc> int80_h, typically you remove the 'Just' from a Maybe value by pattern-matching
16:18:49 <ski> int80_h : `coi' is still a string .. it's not a `Value', nor a `Table Int'
16:18:52 <kmc> i.e. using "case", or passing it to a function with multiple equations
16:19:21 <int80_h>  ski: I thought I was going to use Read/Show in place of my own parser.
16:19:27 <kmc> int80_h, this forces you to consider the Nothing case, or at least be warned by the compiler that you didn't.  this is the advantage of having a specific Maybe type, rather than the Java-ish situation where 'null' is a member of ‚àóevery‚àó type
16:19:30 <ski> int80_h : write down the type for `splitCSV' that you want to get, and then fix the code to conform to that type
16:19:48 <ski> int80_h : possibly you could use `read' and `show', yes
16:20:08 <ski> int80_h : but you still haven't told us what `coi' is supposed to stand for
16:20:17 <ski> int80_h : is it supposed to be parsed into a `Value' ?
16:20:26 <ski> .. an `Int' ?
16:20:28 <int80_h> ski: okay I guess I was confused about what I was supposed to be doing. Not sure why I derived Read.
16:20:33 <ski> .. a `Table Int' ?
16:20:55 <ski> don't worry about that `deriving' clause for the moment
16:20:59 <int80_h> splitCSV :: String -> (String, Table Int)
16:21:02 <napping> int80_h: I doubt writing the parser will give tell you much about you want to use the type
16:21:04 <ski> worry about what you want `coi' to be parsed into
16:21:04 <int80_h> that's what I want
16:21:27 <ski> ok, so `coi' should be parsed into a `Table Int', then, is that right ?
16:21:28 <int80_h> I want it to be a Table Int
16:21:31 <ski> ok
16:21:55 <napping> int80_h: if you want to write the parser, how does splitCSV come up with the tableName field for the table?
16:22:05 <napping> or the string part for the tableColumns list?
16:22:05 <ski> so, instead of returning the *`String'* `coi' in the second part of the pair returned from `splitCSV'
16:22:14 <int80_h> I don't want to write the parse, ski is having me focus on it though so I will.
16:22:30 <napping> well, read helps here, but at type "String -> Int"
16:22:35 <ski> return that `coi', *converted* into a `Table Int' (by `read' or by a function you write)
16:23:12 <int80_h> I can do this then? where (poa,':':coi) = read . span (/= ':') line
16:23:20 <int80_h> since I have read derived?
16:23:28 <ski> not exactly like that
16:23:30 <ski> you could say
16:23:33 <napping> no, this only uses the existing instance (Read Int)
16:23:38 <ski>   splitCSV line = (poa,read coi)
16:23:40 <ski>     where
16:23:45 <ski>     (poa,':':coi) = span (/= ':') line
16:24:33 <ski> what will then try to read the second part of `line', i.e. `coi' into a `Table Int', using the Haskell-format derived by `Read' (and `Show')
16:25:26 <napping> Read is probably the first class that's completely unlike what you've seen in OO languages or CLOS or whatever
16:25:32 <napping> read always takes a String
16:25:40 <ski> int80_h : see what i mean about not returning `coi' itself, but instead first converting it (here using `read', but you could have used another parser function instead, e.g. one you wrote yourself) ?
16:25:48 <napping> what it does it determined solely by the inferred return type
16:26:16 <int80_h> ski: yeah I see, but the syntax doesn't make sense to me. What I wrote made sense, but wrong.
16:26:45 <int80_h> I've screwed somethign else up though but I think I may be able to fix this
16:26:51 <napping> the type signature is off there. "." goes between functions to compose them
16:27:03 <napping> but you have the actual value you want things applied to
16:27:04 <ski> napping : well, iirc, Ada allows procedures and functions to be overloaded solely on return type as well (though that's only ad-hoc polymorphism)
16:27:09 <napping> so write like f . g $ x
16:27:20 <napping> or (f . g) x if you want to apply a composition
16:27:28 <ski> but in this case it's a type error
16:27:33 <napping> but the type is read . span (/...) is wrong too
16:27:38 <napping> because span doesn't return String
16:27:44 <ski> since `read' wants a `String' but `span' would feed it a pair
16:29:14 <c_wraith> ok, time to ask how I could have made this line shorter: dedup = map head . filter ((> 1) . length) . group . sort . map fst
16:29:56 <napping> are you sure you want > 1 instead of >= 1?
16:30:02 <c_wraith> yes
16:30:10 <c_wraith> I want to find cases that were duplicates
16:30:19 <c_wraith> also, group shouldn't return any empty lists
16:30:43 <Veinor> I can't think of a shorter way off the top of my head
16:31:14 <ski> well, it's probably better to not use `length' ..
16:31:44 <int80_h> ski: I can't figure out where I'm screwing up next. I', pretty sure the type is right for mkTableRecords. I'm pasting.
16:31:49 <napping> pattern matching in a list comprehension might help a bit
16:32:00 <napping> [d | (d:_:_) <- group (sort ls)]
16:32:50 <c_wraith> ski: I don't think length is a problem here.  Mostly because length of everything is going to add up to the length of the input list
16:32:54 <ski>   [d | d@(_:_:_) <- group (sort ls)]  -- rather, no ?
16:32:55 <c_wraith> meaning it's another O(n) factor
16:33:04 <ski> oh, right, `map head'
16:33:15 <int80_h> ski:http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29238#a29242
16:33:15 <c_wraith> and the sort is an O(n^2) factor
16:33:16 <ski>   [d | (_:d@(_:_)) <- group (sort ls)]  -- then
16:33:20 <c_wraith> err, n log n
16:33:32 <c_wraith> napping's was correct
16:33:39 <int80_h> oh crap!
16:33:48 <int80_h> I see a big problem not that I've pasted it
16:34:03 <ski> c_wraith : possibly not in this case .. i still cringe at `(> n) . length', though ..
16:34:20 <int80_h> ski: okay ignore the second error, the first stands
16:34:42 <napping> int80_h: that's because the types are pretty confused there
16:34:47 <napping> . takes two functions
16:35:00 <napping> span (/= ':') line is not a function, it doesn't need any more arguments
16:35:17 <napping> what is "splitCSV" supposed to do anyway?
16:35:19 * ski wonders why-t-f hpaste sometimes shrinks the width of a paste/annotations like that ..
16:35:43 <napping> I doubt that type is a good description of what it's supposed to do
16:35:43 <ski> napping : initially, only to map `"foo:bar"' into `("foo","bar")'
16:35:54 <napping> so, take one line and return a pair of strings?
16:35:55 <int80_h> okay I made some changes. Now I have an error that makes sense (sort of)
16:36:19 <ski> napping : but it appears that int80_h wants to do more parsing in it, converting one (or both ?) parts to more useful types
16:36:22 <int80_h> napping: yes
16:36:39 <napping> your type claims it should take one string, and return a string and a table
16:36:58 <int80_h> taking somethign like "foo:23" making it ("foo",23)
16:37:22 <napping> like splitCSV "foo:lots more info..." => ("foo",MkTable "tableName" [("Row 1",Cost 12),("Trinket",ID 13)])
16:37:59 <jozi> ski: I think I solved it! Can I paste my solution?
16:38:07 <ski> "The string is a stark data structure and everywhere it is passed there is much duplication of process.  It is a perfect passed there is much duplication of process.  It is a perfect" -- Alan Perlis
16:38:15 <ski> jozi : if you wish :)
16:38:23 <int80_h> napping: yeah but I was told to use Table Int for now until I can figure out which ints are Costs and which are IDs
16:38:32 <napping> int80_h: not there!
16:38:39 <ski> argh, bothed that one up
16:38:55 <ski> "The string is a stark data structure and everywhere it is passed there is much duplication of process.  It is a perfect vehicle for hiding information." -- Alan Perlis
16:39:01 <monochrom> ski: looks like an illustration of buffer overrun :)
16:39:09 * ski grins
16:39:23 <napping> int80_h: the result of parsing from an entire data file should be a Table Int, if the syntax of your files just has bare numbers and no other way to tell
16:39:24 <jozi> ski: foldTree f g h Leaf = f; foldTree f g h (Node t1 a t2) = g (h t1) a (h t2); countNodes = foldTree 0 (\ n _ m -> 1 + m + n) countNodes
16:39:31 <jozi> ski: is this what you had in mind?
16:39:47 <napping> int80_h: how about we get the right types for the methods first
16:39:51 <int80_h> napping: I think for the sake of brevity I need to get rid of the Value datatype
16:40:06 <ski> jozi : not quite
16:40:09 <napping> you are no longer using it (and I think you'd want to eliminate it eventually anyway)
16:40:16 <jozi> ski: it seems to do what it should though on my test tree
16:40:23 <napping> it doesn't buy you any brevity to save that 1 line though, really
16:40:28 <ski> jozi : not how you have to pass `countNodes' explicitly to `foldTree' there .. that shouldn't be necessary
16:40:36 <int80_h> napping: well I can see how I'd want to have it in real code. But I think I can ignore it with this toy
16:40:53 <napping> let's get the types down a bit
16:41:00 <napping> splitCSV is supposed to take one line, yes?
16:41:07 <ski> jozi : `foldTree' itself should be recursive (walking the whole tree), so no (explicit) recursion should be needed in `countNodes'
16:41:16 <napping> and return a pair of key and value which will make up one row of a table, right?
16:41:28 <napping> so, the String -> (String, ...) part is okay
16:41:29 <jozi> ski: ok, lemme go back to the drawing board then
16:41:42 <ski> jozi : you can see this if you compare the type of your `foldTree' there with `foldTree :: o -> (o -> a -> o -> o) -> (Tree a -> o)'
16:41:46 <int80_h> napping so far I think that's right
16:42:01 <napping> but is the second part really supposed to be a complete Table Int?
16:42:33 <napping> you have to decide either what type you want it to return for you, and whether it needs extra arguments/information to be able to do that
16:42:46 <ski> jozi : in any case, what you have there is nice .. just not the abstraction we wanted here (what you called `foldTree' is more or less what what might call `caseTree' ..)
16:42:49 <napping> or decide what's the most useful type it can return based on the information in the arguments you are already taking
16:42:54 <int80_h> napping: thinking...
16:43:29 <jozi> ski: can you recommend a paper (or source code) to study that further? like origami programming by j. gibbons?
16:44:49 <ski> @quote stark
16:44:50 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
16:44:52 <ski> ah !
16:45:08 * ski 'll try to remember that
16:45:28 <int80_h> napping: I see where what I want and what I have written are not the same. And the type system showed it to me :)
16:45:31 <aristid> ski: you don't need to, lambdabot remembers it.
16:46:24 <napping> int80_h: by the way, CSV usually means comma separated, and has some funky rules about string quoting
16:46:59 <ski> aristid : .. yeah, but lambdabot doesn't tell it to me, when appropriate -- i have to remember to ask her myself !
16:47:09 <aristid> ski: ah, the pains!
16:47:28 <ski> (or more specifically, to remember that she has that quote in store somewhere)
16:49:13 <napping> int80_h: the type of mkTableRecords also looks funny
16:49:34 <napping> it looks like it's supposed to take a line of text, a name, and return a list of tables
16:50:30 <int80_h> napping: fixing it
16:51:27 <int80_h> holy crap it compiles
16:51:29 <jozi> ski: d'oh! Isnt' that just: foldTree f g (Node t1 a t2) = g (foldTree f g t1) a (foldTree f g t2) ?
16:52:08 <int80_h> hey I uninstalled netbsd for the same reason almost. Haskell platform was abitch to install on netbsd.
16:52:45 <Cale> jozi: That looks right. The general idea is to take the constructors of your datatype and replace them with the specified functions.
16:53:32 <napping> int80_h: new paste?
16:53:40 <ski> jozi : yeah, though there should be a case for `Leaf', too
16:53:44 <Cale> jozi: So if you have, say, data Tree a = Tip | Branch a (Tree a) (Tree a), you'd have  foldTree tip branch = f where f Tip = tip; f (Branch x l r) = branch x (f l) (f r)
16:54:07 * ski would usually call Cale's `f' there `loop' or `fold'
16:54:12 <int80_h>  napping: sure but things aren't exactly right
16:54:22 <jozi> Cale: Holy, that took a while -- but I get the concept now I think. Can't the either and maybe functions also be considered folds in that sense?
16:54:33 <Cale> Yes, absolutely.
16:54:57 <jozi> ski: true -- it's the same as posted above: foldTree f g Leaf = f
16:55:07 <ski> (and jozi had `Leaf' and `Node', not `Tip' and `Branch' (with other order of arguments for `Node' vs. `Branch'); still, it's basically the same anyway)
16:55:30 <ski> so, something like
16:55:35 <ski>   foldTree leaf node = fold
16:55:37 <ski>     where
16:55:50 <ski>     fold  Leaf        = leaf
16:56:04 <ski>     fold (Node l a r) = node (fold l) a (fold r)
16:56:31 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29238#a29243
16:56:52 <ski> (you don't *need* to define a local `fold' function like that .. it just buys you a little bit of readability, in that you don't have to repeat the `leaf' and `node' arguments in all the recursive calls)
16:57:10 <jozi> By the way, I also got my Foldable instance working. I got it working by 1) adding a Monoid instance for Int, 2) by adding a type annotation for the result type: foldMap (const (1 :: Int)) tree. Still don't understand exactly why the type checker had a problem, and no Monoid instance for Int was there though.
16:57:11 <napping> int80_h: you are not actually running those strings you read from the files through your parser
16:57:38 <int80_h>  napping: nope, need to get rid of those \n first.
16:57:42 <int80_h> trying to look up how
16:57:44 <ski> (and yes, Cale's version is basically the same as mine -- i was just formatting it up a little bit more, for jozi)
16:57:50 <napping> "lines" will help
16:57:54 <jozi> The Foldable stuff looks like this: foldMap f  Leaf = mempty; foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
16:58:09 <napping> I guess you want to use the file name as the table name for now?
16:58:27 <int80_h> napping: that's right. I can use filter to get rid of the \n's right?
16:58:29 <jozi> ski: but your solution seems nicer, since it's not spread out across the Foldable and the Monoid instances.
16:58:32 <napping> um
16:58:38 <napping> not in a useful way
16:58:44 <ski> jozi : well, there's several incompatible `Monoid' instances for `Int' possible (ignoring that we really want `Integer' for `Monoid')
16:58:49 <napping> do you want to cram all the data onto one line by erasing newlines?
16:58:54 <ski> that's why there is no `instance Monoid Int'
16:59:11 <int80_h> napping: no, I want exactly what I have, w/o the \n's
16:59:14 <napping> that's what filtering with (/='\n') will do
16:59:26 <napping> un, that would cram it all together
16:59:32 <ski> there are instances for `Sum Int' and `Product Int', though, iirc
16:59:40 <heatsink> Clearly the least common multiple is the most useful monoid instance for Int.
16:59:56 <napping> map (filter (/='\n')) entryFiles would produce
17:00:04 <jozi> ski: so I really have to explicitly define a instance Monoid Integer
17:00:11 <napping> ["golf:47sailing:50squash:40swimming:15",...]
17:00:18 <ski> > (mconcat . map Data.Monoid.Sum) [0,1,2,3,4]
17:00:19 <lambdabot>   Sum {getSum = 10}
17:00:22 <int80_h> napping:wait I need the \n. Just not sure how to deal with it
17:00:31 <napping> try "lines" in the interpreter
17:00:48 <napping> also, I expect you'll want to replace the "readFile" in the mapM line with a lambda with a do-block inside
17:00:51 <jozi> ski: I thought the sum one was the default, and the other one added by a newtype.
17:00:53 <ski> jozi : it's considered better to convert your `Int's to `Sum Int's (or `Product Int's, if that's what you want)
17:01:00 <int80_h> napping: I am anticipating when 47\n gets parsed and I attempt to make that an Int
17:01:00 <ski> neither is default
17:01:05 <heatsink> ski: I recall vixey created indexed type classes to deal with ambiguities like that.  Wish I could remember the details.
17:01:09 <int80_h> napping: that would blow up.
17:01:16 <jozi> ski: the type is called "Sum Int"?
17:01:17 <napping> int80_h: look at the arguments your mkTableReords wants
17:01:21 <napping> a name, and a list of lines
17:01:31 <ski> @type Data.Monoid.Sum (42 :: Int)
17:01:32 <lambdabot> Control.Monad.RWS.Sum Int
17:01:38 <ski> jozi : yes
17:01:54 <ski>   newtype Sum a = Sum {getSum :: a}  -- basically
17:01:59 <napping> try mapM (\fileName -> do {rawText <- readFile fileName; return (mkTableRecords _ _)}) entryFileNames
17:02:11 <napping> (except maybe with whitespace instead of the {;} in the do)
17:02:23 <napping> and fill in the _ somehow
17:02:41 <ski>   forM entryFileNames $ \fileName -> do
17:02:43 <ski>     rawText <- readFile fileName
17:02:48 <ski>     return (mkTableRecords _ _)
17:02:56 <napping> oh, and try lines on a string containing \n in the interpreter, it should be helpful
17:04:20 <napping> You don't need to quite yet, but I'd recommend reparameterizing Table - instead of (String,Int) in tableColumns you could have (String,a), if you at a parameter "data Table a = MkTable ..." to the head of the definition, and write "Table Int" in the type for mkTableRecords
17:04:39 <napping> I'm off biking for a bit
17:05:08 <ski> napping : well, that's what int80_h had before :) .. apparently s/he changed that
17:05:20 <BMeph> ...and don't forget, sprinkle with "fmap" to taste... ;)
17:05:20 <jozi> ski: indeed, I get the correct result with foldMap (const $ Sum 1) tree
17:05:23 <int80_h> ski: were those lines supposed to be in main?
17:05:29 <napping> nah, there was value mixed in, and forgotten parameters, and stuff
17:05:31 <int80_h> because now I have this
17:05:41 <napping> int80_h: forM is just like mapM with the parameters flipped
17:05:46 <int80_h>     The last statement in a 'do' construct must be an expression
17:06:09 <napping> so if the expression for the function is long and the list is short you can write forM shortlist bigHugeLongExpression
17:06:09 <ski> int80_h : no idea, i haven't followed the last part .. i only rewrote what napping said `mapM (\fileName -> do ...) entryFileNames', in a (imo) nicer way
17:06:22 <ski> int80_h : probably your indentation is off
17:07:05 <int80_h> testSystem.lhs:35:3: Not in scope: `forM'
17:07:05 <int80_h> testSystem.lhs:37:28: Pattern syntax in expression context: _
17:07:05 <int80_h> testSystem.lhs:37:30: Pattern syntax in expression context: _
17:07:37 <ski>   import Control.Monad (mapM,forM)
17:07:44 <ski> <napping> and fill in the _ somehow
17:08:07 <BMeph> Warning: Overloaded spam in an expression, in line...
17:08:28 <int80_h> ski: I just noticed he's duplicating stuff I've already done with mapM
17:11:01 <ski> jozi : "When is a function a fold or an unfold?" might be interesting too (i'm not sure i've read it)
17:11:09 <int80_h> whats the syntax for when you have a map, a function and two lists you want to map the function over?
17:11:37 <ddarius> BMeph: What's the stress-strain diagram of spam?
17:11:38 <heatsink> zipWith?
17:11:52 <itsmonktastic> a map and a function?
17:11:53 <ski> > zipWith (\x s -> show x ++ ':' : s) [0,1,2,3] ["","a","bc","def"]
17:11:54 <lambdabot>   ["0:","1:a","2:bc","3:def"]
17:11:55 <jozi> ski: ok.
17:12:50 <int80_h> using map, a function and two lists I meant to say
17:13:02 <int80_h> map function name list1 list2
17:13:03 <BMeph> ddarius: Did I make a diagram? I thought I was just producing a warning.
17:13:10 <int80_h> I still should use zipWith?
17:13:11 <itsmonktastic> int80_h: What do you want as the result
17:13:14 <ddarius> BMeph: I'm asking for a diagram.
17:13:45 <int80_h> tableRecords <- map mkTableRecords entryFiles entryFileNames
17:14:02 <int80_h> tableRecords :: [Table]
17:14:18 <lowSodium> Should I run cabal update as root?
17:14:31 <BMeph> ddarius: Oh, right. Must've have a context switch from the "With" of the "zipWith" underneath your remark.
17:14:34 <ddarius> lowSodium: You shouldn't run it at all.
17:14:42 <lowSodium> why not?
17:14:47 <lowSodium> It tells me to.
17:14:48 <itsmonktastic> int80_h: :t mkTableRecords ?
17:14:49 <ddarius> Er, actually update is fine and shouldn't require root.  I was thinking of upgrade.
17:15:04 <jbapple> ddarius: Why not run upgrade?
17:15:06 <BMeph> ddarius: Anyway, I don't do stress-strain diagrams; I'm not "that kind" of engineer. ;√æ
17:15:20 <ddarius> BMeph: The real kind?
17:15:31 <BMeph> ddarius: lol
17:15:38 <int80_h> mkTableRecords :: [String] -> String -> Table
17:16:02 <jbapple> lowSodium: Also, if you need to run cabal as root, you can use --root-cmd=sudo
17:16:26 <lowSodium> i noticed that was in the config, should i uncomment it?
17:17:08 <tolkad> Hey... anyone know where I can get some Monads? my dealer got busted
17:17:26 <itsmonktastic> int80_h: At a guess: map (mkTableRecords entryFiles) entryFileNames
17:17:33 <BMeph> tolkad: Why don't you grow yourself a pair? ;√æ
17:17:40 <aristid> tolkad: nah, take your unsafe dealings elsewhere
17:18:06 <itsmonktastic> int80_h: (i.e. partially apply mkTableRecords and then apply that to each of the file names using map)
17:18:50 <itsmonktastic> but basically guessing at what you actually have.
17:19:51 <itsmonktastic> actually I just take it back entirely, literally no idea what the types of the other things you're dealing with are, too tired, bed.
17:22:52 * ski was for a while trying to figure out in what category "stress-strain diagrams" might live ..
17:23:51 <int80_h> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29238#a29244
17:23:56 <int80_h> or anyone
17:24:45 <ski> tolkad : here, have a monad : `newtype ListT m a = MkListT (forall o. m o -> (a -> o -> m o) -> m o)'
17:25:25 <int80_h> instead of handing out free Monads to any vagabond who comes in, you could be wasting your time with me :)
17:26:30 <ski> well, obviously the `read' in `splitCSV' is failing
17:26:47 <BMeph> ski: The category with old men and Young moduli... ;)
17:26:50 <ski> how does a sample line of `/home/michael/postgres/testdir' look like ?
17:27:16 * ski . o O ( "No category for old men" ? )
17:28:43 <int80_h> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29238#a29245
17:28:56 * BMeph clicks on the Big  Red Button on instantrimshot.com for ski...
17:29:43 <ski> oh, right, you were reading several files
17:29:57 <int80_h> ski: yes
17:29:58 <ski> .. so, how does a sample line from any of those three files look like ?
17:30:13 <int80_h> golf:47
17:30:18 <int80_h> first line in activities
17:31:33 * ski wonders what that <http://instantrimshot.com> is supposed to do ..
17:32:09 * BMeph suggests ski try clicking on that Big Red Button...
17:32:25 * ski sees no Big Red Button [tm] at all
17:33:23 <ski> int80_h : ok, so it *appears* that the format you're parsing in `splitCSV' corresponds to the actual format in your files .. but since you get an error in `read', there must be *some* line in there which doesn't conform to that format
17:33:56 <ski> hm
17:34:38 <lispy> does read fail on whitespace?
17:34:45 <lispy> > read "    9" :: Int
17:34:46 <lambdabot>   9
17:35:12 <benmachine> > read "   9     " :: Integer
17:35:14 <lambdabot>   9
17:35:32 <int80_h> ski: okay I have deleted all but first line of first file. That works.
17:35:51 <int80_h> [MkTable {tableName = "/home/michael/postgres/testdir/activities", tableColumns = [("golf",47)]}]
17:36:55 <int80_h> ski: it dies on second line
17:37:05 <int80_h> ski: is it my \n?
17:37:15 <int80_h> is that confusing it?
17:37:21 <ski> (/me found the (green) button. it leads to "You are using an incompatible web browser." :)
17:37:48 <duckinator> int80_h: since you like C: I officially have no life, http://gist.github.com/536641
17:37:48 <ski> int80_h : anyway, i just realized that possibly you don't call `lines' anywhere
17:37:53 <lispy> int80_h: I would expect your definition of splitCSV to fail at the end if the last entry doesn't have a ':'
17:38:25 <int80_h>  ski: I don;t
17:38:26 <lispy> int80_h: what about using a CSV parser library from hackage?
17:38:42 <int80_h>  lispy: this is a toy
17:38:51 <ski> int80_h : so, you're reading each file into a single `String' .. but then you presumably want to call `splitCSV' on each line of such a file string, not on the whole string itself
17:39:20 <lispy> :t splitAt
17:39:21 <lambdabot> forall a. Int -> [a] -> ([a], [a])
17:39:27 <lispy> :t breakAt
17:39:28 <lambdabot> Not in scope: `breakAt'
17:40:40 <int80_h> span (/= ':') line
17:40:45 <int80_h> @src lines
17:40:45 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:40:56 <int80_h> what was lines supposed to do again?
17:41:18 <lispy> > lines "a\nb\nc"
17:41:18 <lambdabot>   ["a","b","c"]
17:41:55 <int80_h> yes!
17:42:46 <lispy> > let tuple str = let (col, ':':value) = span (/=':') str in tuple "a:4"
17:42:47 <lambdabot>   not an expression: `let tuple str = let (col, ':':value) = span (/=':') str...
17:43:18 <lispy> > let tuple str = let (col, ':':value) = span (/=':') str in (col, value) in tuple "a:4"
17:43:19 <lambdabot>   ("a","4")
17:43:23 <int80_h> cleanedFiles <- map lines entryFiles
17:43:31 <int80_h> that's in main, should do it
17:43:36 <ski> you want `let', there
17:43:42 <ski> `lines' is not monadic
17:44:41 <ddarius> > do s <- lines "foo\nbar\nbaz"; c <- s; return c
17:44:42 <lambdabot>   "foobarbaz"
17:46:12 <ski> yeah .. not monadic in the sense intended here   (i was wondering if anyone would say something like the above ;)
17:46:50 <jozi> ski: this is awesome -- with foldTree, defining some basic functions on the tree (height, flatten, reverse) amounts to a one-liner.
17:47:06 <ski> yeah, folds are awesome :D
17:47:24 <ddarius> jozi: Define fmap with foldTree.
17:47:32 <jozi> ski: height = foldTree 1 (\ n a m -> 1 + max m n); flatten = foldTree [] (\ n a m -> n ++ [a] ++ m); reverse = foldTree Leaf (\ n a m -> Node m a n)
17:47:49 <jozi> ski: I can feel the power ;-)
17:47:50 <ski> jozi : now define `mapTree' and `mirrorTree', and `normalizeTree' (subtract from each element the average of all elements)
17:48:06 <ski> (.. using `foldTree', of course)
17:48:26 <jozi> jozi: uh ... that's possible?
17:48:38 <jozi> ski: I mean, in one pass?
17:48:43 * ski would say that `Leaf' has height `0', but ..
17:48:44 <ddarius> jozi: A better definition of flatten is flatten t = foldTree id (\n a m -> n . (a:) . m) t [] which can be done even more nicely with foldMap.
17:48:48 <int80_h> can I use concat to flatted this [["golf:47","tennis:27"],["Joe:040","Mary:800"]] to ["golf:47","more stuff:number","another list just like the first", "and another"]
17:48:49 <ski> jozi : it is ;D
17:49:12 <ski> jozi : but you can do it in two passes first, if you want
17:49:16 <int80_h> :t concat
17:49:17 <lambdabot> forall a. [[a]] -> [a]
17:49:23 <int80_h> ah that's my answer
17:49:33 <jozi> ddarius: nice.
17:50:10 <int80_h> cleanedFiles = concat . map lines entryFiles
17:50:18 <int80_h> I tried that, got a type error
17:50:23 <ski> jozi : actually, your `reverse' is what i called `mirrorTree'
17:50:53 <jozi> ski: ok
17:51:25 <jozi> ski: still can't imagine how you can subtract an average without computing it first. Guess I'm overlooking some trick.
17:52:00 * ski wonders how hard/easy it would be to mirror the structure of a tree, but keep the elements in the same in-order (alternatively vice versa)
17:52:25 <itsmonktastic> jozi: (a+b+c)/n = a/n + b/n + c/n
17:52:27 <itsmonktastic> perhaps?
17:52:34 * Warrigal 22
17:52:51 <itsmonktastic> oh I guess you probably don't know n
17:52:52 <jozi> ddarius: fmap f = foldTree Leaf (\ n a m -> Node n (f a) m)
17:53:01 <ski> jozi : if you want, you can do it with a direct recursion instead of with `foldTree' .. using `foldTree' is orthogonal to this
17:53:10 <jozi> ddarius: and this on top: instance Functor Tree where ?
17:53:20 <ski> jozi : right :)
17:53:29 <BMeph> int80_h: "cleanedFiles = concat . map lines $ entryFiles
17:53:31 <ddarius> jozi: Yes if you wanted the whole instance, but I was just looking for the definition.
17:53:34 <BMeph> "
17:53:52 <jozi> itsmonktastic: n is not known during traversal
17:53:56 <ski> jozi : the trick is called "laziness"
17:54:19 <int80_h> BMeph : I realized I do need list of lists. But this has screwed up the types of my functions, which just expect lists.
17:54:27 <ski> > let (a,b) = (3,8*a) in b
17:54:28 <lambdabot>   24
17:54:46 <jozi> ddarius: definition?
17:54:57 <ddarius> jozi: What you wrote first.
17:54:59 <ski> (the definition of `fmap')
17:55:03 <BMeph> int80_h: ":t concatMap"... ;)
17:55:45 <jozi> By the way, I get this in ghci: "No explicit method nor default method for `Prelude.fmap'".
17:55:54 <jozi> Hrm.
17:56:13 <ski> maybe you forgot to indent the clause for `fmap' ?
17:56:25 <int80_h> :tconcatMap
17:56:28 <int80_h> :t concatMap
17:56:29 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
17:56:37 <jozi> ski: you're a clairvoyant :)
17:57:02 <ski> > concatMap (\x -> if x == ':' then "COLON" else [x]) "abc:de:f:"
17:57:03 <lambdabot>   "abcCOLONdeCOLONfCOLON"
17:57:26 <int80_h> i need that list of lists I think
17:57:35 <int80_h> otherwise I have no way of telling the difference betwen files
17:57:35 <ski> > map (\x -> if x == ':' then "COLON" else [x]) "abc:de:f:"
17:57:37 <lambdabot>   ["a","b","c","COLON","d","e","COLON","f","COLON"]
18:06:48 <tolkad> How's the progress on the PHP haskell interpreter?
18:08:01 <tolkad> I can't find it
18:09:20 <jozi> ski: the elements of my tree have a certain numerical type. Now it seems I have to know which one to convert the average to the appropriate type. Or is there a generic way to do handle this?
18:09:36 <jozi> ski: I'm talking about the normalizeTree function.
18:10:06 <heatsink> There are generic functions for converting between numeric types.  What types are you using? 
18:10:22 <ski> well, i would just return a tree with elements of the same numeric type as the input tree
18:10:36 <ski> so, either fix some type, such as `Rational' or `Double'
18:10:46 <jozi> heatsink: I don't know (the tree has "data Tree a = Leaf | Node (Tree a) a (Tree a) deriving Show")
18:11:03 <ski> or be polymorphic with `n', adding a `Fractional n => ' constraint
18:11:05 <jozi> ski: but how can I know how the tree was defined?
18:11:25 <jozi> it could be a Tree Int, or a Tree Double
18:11:39 <ski> why do you need to know that ?
18:11:49 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29246#a29246 <-- I'm looking at haskell-src-meta and I'm surprised by this type -- apparently it's RankN -- is the a in the type signatures the same a that parametrises the Quoter?
18:12:01 <jozi> Shouldn't the function be polymorphic in the a of "Tree a"?
18:12:18 <jozi> normalizeTree :: Num a => Tree a -> Tree a
18:13:18 <megajosh2> benmachine: I think so
18:13:21 <ski> benmachine : yes, apparently `... =>' are counted for the rank as well. yes the `a' is the same
18:13:31 <benmachine> oh ok
18:14:30 <ski> benmachine : so, you get `Quoter :: forall a. (Lift a => String -> Q a) -> (Show a => String -> Q a) -> Quoter a', and counting the `Lift a => ' and `Show a => ' annotations, that is a rank-2 signature
18:15:02 <benmachine> ski: is there any point in having those contexts there?
18:15:04 <ski> jozi : yes, since it is polymorphic, it doesn't need to check which actual element type is used
18:15:21 <benmachine> they're like normal datatype contexts, rather than GADT ones, right
18:15:34 <ski> jozi : it just calls the `(/)' operation (which incidentally requires a `Fractional' constraint, not just a `Num' constraint)
18:15:37 <ski> @type (/)
18:15:39 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:15:45 <benmachine> well whatever
18:15:46 <int80_h> ski: I've given some thought to this current problem. What I think is happening doesn't match up to what is actually happening, and staring at the code isn't clarifying
18:15:49 <benmachine> I won't change what I don't need to
18:15:56 <int80_h> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29238#a29247
18:16:05 <ski> benmachine : i have no idea *why* that type is so ..
18:16:21 <ski> (i don't know much about quoters)
18:16:50 <jozi> ski: "Inferred type is less polymorphic than expected" -- does this mean I gotta explicitly use forall for the a?
18:17:14 <ski> benmachine : no, they're not like `data Ord a => Foo a = ..a..'
18:17:54 <ski> (but also not like GADT contexts like `data Foo :: * -> * where Frob :: Ord a => ..a.. -> Foo a; ...')
18:18:32 <ski> jozi : it probably means that you haven't changed the `Num' into `Fractional'
18:18:50 <jozi> ski: I did: normalizeTree :: Fractional a => Tree a -> Tree a
18:18:50 <jozi> normalizeTree t = foldTree Leaf (\ n a m -> Node n (a - avg) m) t
18:18:50 <jozi>     where sum' = foldTree 0 (\ n a m -> n + a + m) t
18:18:50 <jozi>           avg  = sum' / countNodes t
18:19:37 <ski> jozi : some types in `Num', such as `Int' doesn't support `(/)', so `normalizeTree' can't be applied to a tree of `Int's .. (if you want to do that, map from `Int' to something that *does* support `Fractional', first)
18:19:48 <ski> jozi : hm, ok, looking
18:20:13 <jozi> ski: my implementation is probably very crude
18:20:40 <int80_h> lispy you there?
18:20:50 <lispy> int80_h: kind of.  I'm at work
18:20:54 <lispy> int80_h: what's up?
18:21:07 <int80_h> ah I am having type troubles
18:21:15 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29238#a29247
18:21:16 <jozi> ski: it needs 3 passes! (probably I could fold up a pair for the sum and the count, to shave off one pass.
18:21:27 <ski> jozi : hm, what looks ok to me, on a first glance
18:21:45 <ski> you say there's a type error ?
18:21:58 <int80_h> lispy: this is code that will end up in the tutorial by the way. when I'm done it will be reading files instead of hardwired lists in the code.
18:22:12 <jozi> ski: for Int trees, but I'll try Integer now
18:22:17 <int80_h> I'm trying to generalize as much as I can.
18:22:20 <ski> jozi : oh ..
18:22:27 <lispy> :t map lines
18:22:27 <lambdabot> [String] -> [[String]]
18:22:30 <ski> jozi : try `Double' or `Rational' trees
18:22:32 <lispy> int80_h: ^^
18:22:48 <ski> jozi : `Int' and `Integer' doesn't support `(/)'
18:22:55 <int80_h> lispy : yes I need those [[String]]'s
18:23:18 <int80_h> but when I map over them, it should be passing a [String] right?
18:23:20 <lispy> int80_h: Well, that's where the error about [String] vs. [[String]] is coming from
18:23:43 <lispy> map lines, now you cleanedFiles :: [[String]]
18:23:45 <jozi> ski: actually I still get the type error "Inferred type is less polymorphic than expected".
18:23:45 <jozi> 	coming from"
18:23:55 <jozi> skie: (ignore second line)
18:24:05 <lispy> But that doesn't match mkTableRecords :: [String] -> String -> Table
18:24:18 <int80_h> >  let tableRecords = map( mkTableRecords cleanedFiles) entryFileNames
18:24:19 <lambdabot>   not an expression: `let tableRecords = map( mkTableRecords cleanedFiles) en...
18:24:38 <int80_h> should not the map be passing a [] from cleanedFiles?
18:24:42 <ski> jozi : from your definition of `normalizeTree' or from your call to it ?
18:24:44 * hackagebot hexpat 0.19 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.19 (StephenBlackheath)
18:25:13 <lispy> int80_h: in that expression, cleanedFiles has type [[String]], but it's being passed to mkTableRecords which expects something of type [String]
18:25:31 <lispy> int80_h: maybe you're missing a map?
18:25:40 <jozi> ski: it typechecks after removing the signature. Type is now: normalizeTree :: Tree Double -> Tree Double, which seems less general than expected.
18:26:01 <int80_h> lispy I think I misunderstand what map is doing there
18:26:01 <jozi> I also expected Fractional.
18:26:08 <ski> jozi : hm, what is the type signature of `countNodes' ?
18:26:35 <jozi> Strangely, countNodes :: Tree a -> Double.
18:26:35 <lispy> int80_h: that map is applying this function ( mkTableRecords cleanedFiles) to each element of entryFileNames
18:26:40 <ski> (.. or just type, if you have no explicit signature)
18:26:48 <jozi> countNodes = foldTree 0 (\ n _ m -> 1 + m + n)
18:26:54 <ski> jozi : so, fix that
18:26:59 <ski> the type signature
18:27:07 <int80_h> lispy: what I want is a [String] taken from cleaned Files and a String from entryFileNames and passing that to mkTableRecords.
18:27:15 <jozi> si: I though ghc uses the most general type automatically?
18:27:16 <ski> it should be able to return a value in *any* `Num'eric type
18:27:23 <int80_h> lispy: so my attempt at map is wrong?
18:27:46 * hackagebot haskell-src-meta 0.1.0 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.1.0 (BenMillwood)
18:27:47 <ski> jozi : yes, but if you give a more specific one, it uses that
18:27:55 <benmachine> oh hi hackagebot
18:27:57 <lispy> int80_h: you might want to concat something, in that case
18:28:05 <jozi> ski: I didn't. I found that through :t in ghci.
18:28:14 <lispy> int80_h: I'm having trouble following the code
18:28:33 <ski> jozi : *also*, if you have the Dreaded Monomorphism Restriction enabled, it will refuse to make pattern-bindings overloaded
18:28:41 <ski> and that is probably the culprit, here
18:29:04 <ski> so, either eta-expand, give an explicit type signature, or disable the DMR
18:29:16 <lispy> int80_h: so cleanedFiles represents a list of (list of strings).  and you want to somehow group the (list of strings) with something?
18:29:24 <jozi> ski: how disable?
18:29:25 <ski>   {-# LANGUAGE NoMonomorphismRestriction #-}
18:29:30 <int80_h>  lispy: yes
18:29:31 <jozi> that was fast.
18:29:32 <ski> at the top of your file
18:29:45 <lispy> int80_h: ah, maybe you want zipWith
18:29:49 <lispy> :t zipWith
18:29:49 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
18:29:52 <ski> eta-expand means that instead of saying
18:29:56 <tolkad> if you import a file, do all of its instances get automatically imported into the global namespace?
18:29:59 <jozi> ski: indeed!
18:30:00 <ski>   f = foo bar
18:30:02 <ski> say
18:30:02 <jozi> ski: works now.
18:30:05 <ski>   f x = foo bar x
18:30:16 <lispy> zipWith mkTableRecords cleanedFiles entryFileNames
18:30:17 <tolkad> does it even make sense for intances to be exported or not exported?
18:30:28 <jozi> ski: this is to give x a type explicitly?
18:30:42 <lispy> int80_h: does that look right?
18:30:43 <ski> the DMR only strikes when you have a definition like `thing = ...', now when you have arguments on the left on the `='
18:30:52 <Saizan> tolkad: instances are always exported
18:31:17 <tolkad> Saizan: do they pass through qualified imports? like ninjas?
18:31:20 <ski> jozi : confusingly, the DMR was introduced explicitly in Haskell 98 because it was thought that it would be easier for newbies, that way :)
18:31:32 <Saizan> tolkad: yes
18:31:38 <lispy> int80_h: I think this type is right, zipWith mkTableRecords :: [[String]] -> [String] -> [Table]
18:32:01 <lispy> int80_h: have you used zipWith before?
18:32:02 <ski> jozi : no, if you say `thing x = ... x', then the definition has arguments on the left of `=', so the DMR doesn't strike
18:32:07 <ddarius> ski: Having the monomorphism restriction and having foldl in the Prelude seem at odds with one another.
18:32:21 <int80_h> lispy: no that's not exactly right
18:32:42 <jozi> ski: I see. Reading through the Haskell Wiki page for DMR.
18:32:49 <jozi> ski: you mentioned it's possible to do this in one pass, or did I get this wrong?
18:32:53 <lispy> int80_h: Are you sure? :)
18:32:54 <ski> ddarius : yeah .. i have a nagging feeling that `foldl' ought to be good for something .. but i don't know what :)
18:33:05 <ski> jozi : yes
18:33:06 <jozi> ski: the normalization
18:33:06 <lispy> int80_h: better yet, can you clarify what is wrong?
18:33:10 <int80_h> lispy: cleanedFiles is a [[String]]. I want to iterate through that passing along a [String] to mkTableRecords, along with a String.
18:33:20 <jozi> ski: what would be the strategy?
18:33:21 <int80_h> I want to use two lists for a map
18:33:24 <ski> jozi : it should be not that hard for you to do it in two-pass, i think
18:33:40 <ski> jozi : i.e. compute sum and count in one pass
18:33:43 <lispy> int80_h: zipWith is how you use two lists for a map, check the type
18:33:51 <lispy> :t zipWith
18:33:52 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
18:33:56 <int80_h> when map goes through the [[String]], it should pass along a [String], but that is not what is happening.
18:34:01 <int80_h> oooh, okay
18:34:02 <jozi> ski: exactly, that's what I though (see above) -- but in a single pass?
18:34:09 <int80_h> I guess I haven't used it enough :)
18:35:01 <ski> jozi : well, if you try it (correctly), you'll see that it "just works" :)
18:35:20 <jozi> ski: that's probably too little hints for me at this point ;-)
18:35:20 <int80_h> lispy: so this should work?
18:35:24 <int80_h> let tableRecords = zipWith mkTableRecords cleanedFiles entryFileNames
18:35:36 <ski> jozi : ok, so you need to compute three things in the single pass
18:35:50 <int80_h> freaking compiles!
18:35:56 <lispy> > let { foo :: [String] -> String -> (Int, Char) ; foo x y = (length x, head y) } in zipWith foo ["hi", "how", "are", "you"] "hey"
18:35:57 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
18:35:57 <lambdabot>         against inferred ty...
18:36:00 <int80_h> soon soon I will actually be able to put something in a database!
18:36:13 <ski> jozi : the sum of the current subtree, the count of the current subtree, and the normalization of the current subtree wrt the average of the *whole* tree
18:36:14 <jozi> ski: you're saying I can do everything in one foldTree, within the (o -> a -> o -> o) ?
18:36:21 <tolkad> http://media.tumblr.com/tumblr_l6a4se813c1qb25dg.jpg
18:36:30 <lispy> int80_h: well, my example failed but I wanted to show you, zipWith stops iterating when either list is empty
18:36:31 <tolkad> is this relevant to haskell?
18:36:32 <ski> jozi : sure .. or using an explicit recursion (one pass)
18:36:38 <lispy> int80_h: so it may not be what you want
18:36:45 <ski> jozi : using `foldTree' or not here doesn't matter much
18:37:10 <lispy> > zipWith (+) [1..4] [1..10] -- notice the output is only length 4
18:37:11 <lambdabot>   [2,4,6,8]
18:37:15 <ski> (i mean it doesn't interact with how easy/hard it is to make it one-pass)
18:37:18 <int80_h>  lispy : it works fine. now I can go on to the next steps :)
18:37:18 <lispy> int80_h: ^^
18:37:37 <int80_h> it's a beautiful thing. I may even get this done in the next few hours
18:37:46 <int80_h> I'd like this to be sample code at a job interview
18:38:01 <int80_h> my backup is the graham scan algortihm from RWH. I'd prefer this.
18:38:10 * ddarius thinks the forward references scenario leads more naturally to what ski is leading to.
18:38:16 <ski> > zipWith (\s c -> s ++ [c]) ["hi","there"] "!?.,:;"
18:38:17 <lambdabot>   ["hi!","there?"]
18:38:47 <int80_h> I forgot to munge the tableName the way I want, but that seems trivial.
18:39:00 * ski wonders what ddarius might mean by "forward references"
18:39:10 <lispy> int80_h: cool.  If you want it to be interview code, you better polish it lots :)
18:39:12 <ddarius> It's easier to say "make a version that doesn't handle forward references, now we could handle forward references if only we had the complete symbol table..."
18:39:18 <kmc> you're using a Haskell snippet for a job interview?
18:39:35 <ski> jozi : but, i think it will be easier to do it, if you do it two-pass first
18:39:35 <ddarius> @google forward reference
18:39:36 <lambdabot> http://en.wikipedia.org/wiki/Forward_declaration
18:39:49 <lispy> int80_h: Well, I should clarify.  I've seen job interview code tends to need to do a good job of error handling
18:40:01 <ski> hm .. you mean the knot-tying
18:40:07 <lispy> int80_h: so once it works, spend time trying to break it
18:40:16 * ski hasn't heard that being called "forward references" before
18:40:35 <nzfrio> is there a canonical way of expressing an immutable String -> String hashtable in haskell? I want to store (at compile time) a map of "sourceDir" -> "destDir" for transforming one folder into another :)
18:40:44 <nzfrio> so far, ive not found much on the topic
18:40:48 * lispy heads home
18:40:50 <nzfrio> which means i must be looking in the wrong places
18:40:56 <ski> nzfrio : a function ?
18:41:00 <nzfrio> but id really appreciate any input :)
18:41:05 <nzfrio> I was thinking of that ski
18:41:11 <nzfrio> perhaps a list of tuples?
18:41:12 <ddarius> ski: Read farther.
18:41:18 <kmc> nzfrio, stuff = M.fromList [("foo", "bar"), ...]
18:41:27 <kmc> assuming youv'e done: import qualified Data.Map as M
18:41:28 * ski deigns to read the WP page :)
18:41:31 * ddarius wonders if "farther" is actually acceptable in this context.
18:41:34 <nzfrio> Data.Map
18:41:37 <nzfrio> man
18:41:40 <nzfrio> >_< frio
18:41:41 <nzfrio> >_<
18:41:50 <ddarius> (as opposed to "further")
18:41:52 <kmc> nzfrio, it's not a "hashtable" though -- that's a term for a particular sort of implementation
18:41:58 <nzfrio> thankyou kmc :)
18:42:11 <kmc> Data.Map has a simple implementation that's probably Fast Enough, but there are fancier options
18:42:22 <kmc> in a high-performance app you wouldn't use String anyway
18:42:29 <int80_h> lispy: if you are available I think I may have some takusen specific problems soon
18:42:36 <int80_h> off to the other channel
18:43:02 <nzfrio> yeah kmc; I want to extend Hakyll to allow some futher logic on transforming the input dir to the output dir
18:43:10 <kmc> cool
18:43:26 <nzfrio> its the kind of thing that be run once i update my blog, so high performance (so long as its <30s, i dont care) isnt really a priority :)
18:43:36 <hewei> kmc: What other high-performing mapping structures pls? 
18:43:43 <ski> ddarius : ok, i'm not sure if i've seen that term before
18:43:45 <kmc> IntMap for Int keys
18:43:57 <kmc> package EnumMap extends that to any Enum type in the obvious way
18:44:01 <ddarius> ski: It's pretty common compiler terminology.
18:44:06 <nzfrio> thanks for that, i feel like a gimp for not googling map haha :) (python's got dicts, java's got hashmaps, php's got associative arrays... derp frio)
18:44:26 <kmc> package hashmap combines IntMap with Map, to yield a kind of persistent hash-trie with good sharing
18:44:26 <hewei> kmc: How about string->string pls?
18:44:28 <ski> ("forward declaration" i've heard .. but possibly not "forward reference")
18:44:40 <kmc> there's bytestring-trie and some other trie packages
18:44:44 <jozi> ski: I'll try this out tomorrow. Thanks for your help! That was a great learning experience.
18:44:45 * QtPlatypus feels that "map" as a term is overloaded.
18:44:47 <Draconx|Laptop> perfech hashing would also be applicable in this case.
18:44:55 <kmc> also plenty of options for mutable data
18:44:56 <ddarius> Forward declaration is something else and I've never heard anyone refer to forward declarations as forward references.
18:45:01 <kmc> judy arrays, etc
18:45:12 <Draconx|Laptop> s/perfech/perfect/
18:45:26 <ddarius> The Wikipedia article says some people use that term for that, but I'm going to interpret that as "some people are idiots"
18:45:35 <Axman6> i've got a TernaryTrees package, which is pretty fast when doing String -> String mappings
18:45:54 <Draconx|Laptop> ddarius, well, it's probably true :)
18:45:56 <hewei> kmc: I have tried judy before, seems there is some problem with latest GHC. PUGS has a variation of judy that seem to work, but not the hackage one. 
18:46:03 <Axman6> (also known as a trie, but i didn't know about the term when i learnt about ternary trees)
18:46:13 <ddarius> Draconx|Laptop: Yes, "some people are idiots" is definitely true.
18:46:24 <ski> (and i think i've definitely not heard it in the context of lazy programming, or for that matter, in the context of uninstantiated logic variables, or doing stuff like taking addresses of things inside an uninitialized location in C)
18:46:43 <kmc> hewei, interesting
18:46:59 <ddarius> ski: It's not used in that context.  However, if you were to implement a parser/compiler/assembler that handled forward references you'd be using the same technique that you are building up to.
18:47:22 <ski> yeah .. more or less
18:47:25 <ddarius> And that, in my opinion, is a more natural and obvious progression than a rep_min-like problem.
18:47:39 <ddarius> and/or more motivated.
18:47:48 <ski> agreed :)
18:52:15 <dh__> I'm trying to understand the ArrowLoop, can somebody give me a simple example of ArrowLoop ? 
18:52:41 <dh__> for example, how can I define factorial function with ArrowLoop? ( maybe a wrong example)
18:53:33 <Saizan> do you know how to define factorial with fix?
18:54:29 <dh__> Saizan: I remember I read it from some where, but can't write it down.
18:55:08 <Saizan> http://www.vex.net/~trebla/haskell/fix.xhtml
18:55:12 <monochrom> heh
18:55:30 <benmachine> anyone have any idea how often hackage buildbots do their thing?
18:55:47 <dh__> Saizan: thanks. 
18:56:07 <ddarius> Using loop with the trivial arrow is not very illuminating.
18:57:17 <Axman6> benmachine: about every 6 hours i think
18:58:49 <ski> `loop' is for "data recursion", much like `mfix'
18:59:35 <ski> (of course functions are data, so you can do e.g. factorial with this .. but as ddarius remarked ^)
19:00:09 <monochrom> perhaps translate http://www.haskell.org/haskellwiki/MonadFix to Arrow
19:01:28 <ski> e.g. if you have an arrow `Circuit' where `Circuit a b' describes a transformation from a time-varying input of type `a' to a time-varying output of type `b', then `loop' could be used to feed back part of the output of the circuit as input
19:03:15 <ski> (and if you have a delay somewhere in the circuit, you could use that e.g. to do a circuit (assuming discrete time here) that computes running sum)
19:06:33 <dh__> ski: thanks. 
19:07:04 <dh__> In fact, I'm trying to simulate a ball running inside a box with Yampa. 
19:07:31 <dh__> a ball runs left until it hit a wall, then it runs right , then hit a wall, then back, etc. 
19:08:12 <dh__> a more general question would be : how can I write a Pool game in Yampa :)
19:09:07 <ski> ok
19:09:08 <int80_h> anyone well versed with takusen here?
19:09:15 * ski is off to misty-magic land now, though ..
19:11:19 <dh__> In the paper : genuinely-functional-guis, there is a paddle ball example in Yampa, I'll try to understand it. 
19:28:34 <napping> int80_h: how's it going?
19:34:25 <int80_h>  napping: I'm on to the takusen portion of my project. That you for your earlier help. I've accomplished what I needed to in order to move on to takusen. Although now that I am done I am re-thinking some choices I made
19:34:35 <int80_h> ^thanks you I mean
19:35:38 <int80_h> I dont think, for example, that table creation in code is all that practical.
19:35:56 <int80_h> table population, but not creation
19:39:41 <napping> table creation?
19:39:49 <Cale> roconnor: I replied :)
19:41:32 <ScaredEcat> hi
19:42:18 <int80_h> napping, I'm writing code for postgres using takusen. 
19:43:17 <ScaredEcat> anybody know why i can't chat in OpenGL room? Do they know I'm a pervert?
19:43:42 <kmc> maybe they only allow registered users to speak?
19:43:49 <ScaredEcat> I'm a = My friend is
19:44:04 <ScaredEcat> ah, that's probably it
19:44:07 <Cale> ScaredEcat: Yes, yes, your "friend".
19:44:52 <ScaredEcat> Cale: Yes, we always have to be aware of the company we keep
19:44:57 * benmachine is vaguely reminded of http://www.unnecessaryquotes.com/
19:45:01 <Cale> Man, how do I get sucked into these discussions... http://www.reddit.com/r/math/comments/d1qcf/to_infinity_and_beyond_the_struggle_to_save/c0x5a4b
19:47:08 <ScaredEcat> i just checked out the unnecessaryquotes site and saw a sign for the Canadian liquor store. I have to say I'm "embarrassed"
19:49:04 <JoeyA> Is there a way to un-import a module in GHCi?
19:49:21 <ezyang> :m -Module 
19:49:46 <JoeyA> Thanks
19:49:54 <ezyang> "In soviet Russia, package un-imports you." 
19:50:08 <JoeyA> Also, how do you hide / mitigate the list of modules imported?
19:50:20 <kmc> you can set your prompt
19:50:29 <ezyang> :set prompt 
19:51:00 <JoeyA> :set prompt "C:\\> "
19:51:01 <roconnor> Cale: in order to be schooled! :D
19:51:03 <JoeyA> Ah, much better
19:51:55 <JoeyA> Can the prompt refer to things?
19:52:01 <JoeyA> e.g. if I still wanted subsequent modules listed
19:52:12 <kmc> let dir = getCurrentDirectory >>= getDirectoryContents >>= mapM_ putStrLn
19:53:04 <Cale> roconnor: hehe
19:53:12 <JoeyA> kmc: cool
19:53:53 <Cale> roconnor: So, I still don't quite get what you're after saying that there's objectivity to Pi_1 statements, for reasons that I've described in that post.
19:55:39 <Cale> roconnor: It seems to me that no matter which (consistent) formal system you decide to use, if you take one step back and embed it in a meta system where you assume its consistency, you'll be able to show that the Pi_1 statement which encodes its consistency isn't provable by it, and so no formal system will objectively decide about all the Pi_1 statements of arithmetic.
19:56:27 <roconnor> Cale: replied
19:56:41 <napping> int80_h: just using Data.Map might do for now
19:56:58 <napping> if you have trouble getting Takusen working
19:57:00 <writer> kmc: mapM_ returns m (), so is that any useful ?
19:57:56 <kmc> it will print the list of files in the current dir
19:58:00 <roconnor> Cale: every sytem proves A or not A for every Pi_1 statemetn (and every other statement)
19:58:05 <kmc> when you execute "dir"
19:58:18 <roconnor> so in that sense every system decides every Pi_1 statement.
19:58:20 <kmc> it's just a further joke on JoeyA having set the ghci prompt to C:\>
19:58:40 <JoeyA> oh
19:58:43 <Cale> roconnor: It proves the statement "A or not A", but it might prove neither "A" nor "not A"
19:58:47 <roconnor> correct
19:58:54 <JoeyA> kmc: nice :D
19:59:15 <Cale> roconnor: In the case that this occurs, the truth of the statement A isn't determined by the system.
19:59:29 <JoeyA> let cat = "Meow!"
19:59:33 <jaredj> newbie question: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29248 fails. am i barking up the right tree?
20:00:09 <JoeyA> Is there a mutable map library for Haskell?
20:00:21 <Cale> roconnor: So, my Con(ZFC) is a Pi_1 statement of arithmetic.
20:00:22 <roconnor> Cale: even if a system proves a statement A, doesn't mean A is true.
20:00:22 <kmc> JoeyA, other than using an immutable map in a MVar or such?
20:00:34 <Cale> roconnor: It's not proven by PA, and it's not proven by ZFC.
20:00:38 <Cale> But it's proven by T.
20:00:47 <roconnor> Cale: only sound systems that prove A means imply that A is true.
20:00:48 <Cale> (because it's an axiom of T)
20:00:52 <kmc> JoeyA, persistent structures go great with concurrent stateful programming
20:01:07 <roconnor> Cale: only sound systems that prove A imply that A is true.
20:01:11 <Cale> roconnor: If a system proves A, then A is true in that system.
20:01:21 <Cale> Truth is always truth in some formal system here.
20:01:21 <kmc> because you can get a snapshot cheaply and locklessly
20:01:35 <kmc> JoeyA, anyway there's judy arrays, and the various vector packages
20:01:39 <kmc> and the built-in array support
20:01:54 <Cale> Even if it's the outermost system that we've decided to use.
20:02:09 <roconnor> Cale: I don't think "true in that system" makes any sense.  "true in that model" I could accept, and "provable in that system" is also okay, which is the same as "true in every model of that system".
20:02:15 <JoeyA> Well, if I'm not mistaken, an immutable map has to reconstruct log(n) nodes and garbage collect others, whereas a mutable map would be more efficient if one doesn't want the old snapshot feature of immutable maps.
20:02:52 <Cale> roconnor: When we say that it's true that there exists a nonmeasurable subset of R, we mean that it's provable in ZFC.
20:03:06 <kmc> JoeyA, yeah
20:03:30 <Cale> (given that ZFC is our ambient implicit formal system)
20:03:32 <JoeyA> Here's an efficient implementation of nub that uses Data.Set:  http://codepad.org/RlsqqheP
20:03:58 <roconnor> Cale: I'm okay with that.  I'm also good with an unqualified "A is true" which is a statement in the meta-system as you note.
20:04:00 <kmc> yeah, and it could use a mutable set in ST or such
20:04:00 <kmc> i see
20:04:22 <kmc> JoeyA, you could use judy arrays
20:04:26 <kmc> there's a haskell binding (actually, two?)
20:04:37 <JoeyA> By the way, this package has an Ord nub:  http://hackage.haskell.org/packages/archive/data-ordlist/0.2/doc/html/Data-List-Ordered.html#v%3Anub
20:04:45 <JoeyA> But guess what, it's WRONG
20:04:47 <roconnor> So "A is true" "A is true in that model" "A is provable in that system" and "A is true in every model of that system"
20:04:51 <JoeyA> "On unordered lists it also removes elements that are smaller than any preceding element."
20:04:57 <roconnor> all make sense to me
20:05:06 <Cale> roconnor: I didn't just say that S lacked some Pi_1 statements, I said that it lacked some Pi_1 statements which are undecidable in ZFC.
20:05:07 <JoeyA> Which means it doesn't do what nub is supposed to do, namely remove duplicate entries.
20:05:35 <Cale> roconnor: In particular, it lacks Con(ZFC).
20:06:03 <roconnor> Cale: I don't understand which S you mean.  You give two charaterisations which are not the same (I called them S1 and S2).
20:06:17 <Cale> roconnor: Perhaps I should argue that they are the same.
20:06:41 <Cale> Oh, I see
20:06:48 <roconnor> they are quite different.
20:06:59 <JoeyA> How does one store references to Haskell objects in C code with FFI?
20:07:03 <Cale> I was a little bit unclear, and you made it clear how you misread my statement :)
20:07:10 <roconnor> that's good
20:07:18 <roconnor> the topic is a bit confusing
20:07:47 <Cale> S is the set of all statements of PA which are true in ZFC, but not provable in PA
20:08:02 <roconnor> again with the "true in ZFC"
20:08:10 <Cale> = provable in ZFC
20:08:16 <roconnor> ah okay.
20:08:20 <roconnor> that is S1.
20:08:28 <Cale> yes
20:08:42 <roconnor> ah
20:08:46 <roconnor> I see
20:08:51 <roconnor> let me reread this now
20:08:52 <dankna> JoeyA: I do it with StablePtrs
20:09:08 <Cale> I don't consider statements which are undecidable in ZFC to be "true in ZFC". ZFC makes them neither true nor false, even though it proves "P or not P" for them.
20:09:12 <dankna> JoeyA: basically a StablePtr is a numerical token which gives a Haskell object explicit-allocation semantics
20:09:51 <Cale> Truth is always provability in some system for me :)
20:10:13 <Cale> I think *maybe* that's where we differ.
20:10:27 <JoeyA> I'm just wondering what would be involved in implementing a mutable map out of a search tree implementation in C.
20:11:07 <JoeyA> How would my structure know when it gets freed and when to dereference objects?
20:11:08 <dankna> mm...  I'd advise against it if you want the map itself to be GCable
20:11:27 <dankna> it's possible (there's something that does the opposite of a StablePtr, giving GC semantics to a foreign object, but I don't remember what it's called)
20:11:33 <Cale> You seem to believe in some external kind of truth where at least all the Pi_1 statements of arithmetic have been decided, even though I'm unaware of any formal system which can do that.
20:11:37 <dankna> but it's subtle and quick to anger
20:12:31 <luite> JoeyA: ForeignPtr have a finaliser, which the garbage collector calls to free the data structure
20:12:58 <roconnor> Cale: the meta-logic (the embedded ZFC) still proves that it's PA + it's version of S2 is a complete system.
20:13:15 <monochrom> a meta-logic is just another formal system
20:13:25 <Cale> monochrom: s
20:13:27 <Cale> yes*
20:13:40 <dankna> see that's at odds with the notion of a finalizer in other languages, where it's what the GC calls to notify you that it's about to free the data structure
20:13:59 <orbitz> if one wants to stay bleeding edge with GHC is Linux the OS to go with or is FreeBSD generally pretty close?
20:14:00 <kmc> JoeyA, why implement it in C?
20:14:03 <Cale> roconnor: I'm not sure why we care about S2 for now.
20:14:03 <roconnor> Cale: the meta-logic can prove that either Con(ZFC) is in its verison of S2 or not Con(ZFC) is in its version of S2.
20:14:11 <monochrom> sematics is just another syntax <duck> :)
20:14:33 <roconnor> Cale: because no one, not even ZFC expects Con(ZFC) to be in S1.
20:14:55 <luite> orbitz: linux is the safest bet, since it's used by more developers
20:14:56 <Cale> roconnor: If you want to go out another level, I'll play the game a little differently.
20:15:06 <roconnor> I was going inwards :)
20:15:09 <Cale> roconnor: and use Con(ZFC+Con(ZFC)) again.
20:15:17 <monochrom> orbitz: it seems linux and windows are the most advantaged, freebsd is the least in fact :)
20:15:31 <dankna> I have the vague sensation that epistemology is being discussed, but I cannot understand it.
20:15:34 <roconnor> Cale: you know, typically logicians use very weak meta logics
20:15:36 <JoeyA> kmc:  Good point.  I'm not sure how one would efficiently construct a mutable tree in Haskell, but I guess it's possible.
20:15:38 <Cale> roconnor: I'm thinking of PA as our "innermost" system here.
20:16:20 <orbitz> monochrom, luite : suggested distro to keep up (I'm wiping a machine and installing a new OS just to have the best haskell :)
20:16:26 <JoeyA> And if I want it to be a B-tree, how would I create the fixed-length arrays needed for it?
20:16:28 <kmc> JoeyA, GHC Haskell has all the same primitives.  you can allocate an array of mutable bytes, read/write it, etc.
20:16:37 <JoeyA> Would something like Vector have extra overhead?
20:16:54 <kmc> vector is designed to be high-performance
20:16:57 <kmc> extra compared to what?
20:17:05 <monochrom> dons uses arch linux, so maybe you can just follow. otoh ubuntu is fine too, just don't use ubuntu's ghc
20:17:12 <kmc> i think implementing a mutable B-tree on top of vector is a reasonable idea
20:17:20 <JoeyA> I sure hope I wouldn't have to say data BTree a = (Maybe a) (Maybe a) (Maybe a) (Maybe a) ... (Maybe BTree) (Maybe BTree) ...
20:17:26 <kmc> ;P
20:17:32 <kmc> that wouldn't be mutable anyway
20:17:44 <Cale> roconnor: Well, this is just an example -- I needed an example of how we can always take a step outside of our system in order to show that there's a Pi_1 statement of PA whose interpretation is undecidable.
20:17:45 <orbitz> I'm in debian stable righ tnow and I think I'm going to switch to Ubuntu Server, debian just seems tooo far behind
20:17:51 <JoeyA> sh.. shure it is... partner
20:18:30 <roconnor> But it doesn't matter because the inner logic still prove A or not A for every A.
20:19:03 <Cale> "A or not A" isn't the same as the existence of an objective answer about the truth of A.
20:19:05 <m3ga> orbitz: i highly recommend debian testing over ubuntu
20:19:16 <monochrom> debian stable is meant to be far behind in hope of stability
20:19:34 <m3ga> testing lags unstable by > two weeks
20:20:01 <orbitz> m3ga: really?
20:20:08 <kmc> JoeyA, if you use 'vector' you also have the advantage of making an ST version
20:20:09 <orbitz> m3ga: I don't know debian at all, can I just switch my sources?
20:20:12 <orbitz> and do an upgrade?
20:20:16 <kmc> JoeyA, that's trickier to do with FFI, though still possible
20:20:34 <Cale> roconnor: To put it another way, in a cartesian closed category with a terminal object, having an arrow 1 -> A + 0^A is not the same as having either an arrow 1 -> A or an arrow A -> 0
20:20:49 <JoeyA> Somewhat unrelated, I recently switched from Ubuntu Karmic to Lucid because it was starting to wrinkle.
20:21:04 <m3ga> orbitz: it can work (if you know what you're doing), but probably safe to do a reinstall. also good to put /home in a separate partition so switching is easier :-)
20:21:07 <JoeyA> For instance, I wanted to cabal install something, but ghc-base was too old.
20:21:09 <jaredj> parsec is happy now - thanks, Real World Haskell! ordered my copy tonight
20:21:36 <JoeyA> Happy is the name of another parser generator, by the way.
20:21:41 <lispy> jaredj: parsec and happy are the same?
20:21:46 <kmc> hehe
20:21:51 <lispy> I think happy is fairly different
20:21:53 <orbitz> m3ga: I don't recall debian install asking me which distro to use, perhaps I just missed it
20:21:53 <kmc> happy is a parser generator; parsec isn't really
20:21:56 <roconnor> Cale: on the flip side, just because we can't decide something doesn't mean it doesnt' have a well defined truth value.
20:22:01 <orbitz> m3ga: i *just* installed this debian, so it's fresh off the presses
20:22:02 <lispy> it's a table/transition based parser
20:22:03 <JoeyA> I toyed with Parsec, but I don't like it because it doesn't handle the things a parser generator ought to
20:22:14 <kmc> yeah it's not a parser generator
20:22:16 <JoeyA> It fails if it cannot partially parse something, so you have to be careful
20:22:18 <roconnor> Cale: is the Busy Beaver function not well defined just because it isn't computable?
20:22:21 <JoeyA> Just like when doing it by hand.
20:22:27 <Cale> roconnor: But it means that the truth value depends on which external system we embed our formal system in.
20:22:31 <lispy> JoeyA: yeah, it's really good when you don't know how to classify your grammar
20:22:37 <jaredj> orbitz: the way to install unstable is to install stable, switch the sources, apt-get up{date,grade}. testing may have an installer, but it likely doesn't matter
20:23:01 <jaredj> lispy: *facepalm* no, it was angry earlier :)
20:23:05 <orbitz> I think I can probably get away with that.  I've literally been runnign debian for abotu 2 hours
20:23:06 <m3ga> orbitz: if its debian testing, its safe to change sources.list and 'apt-get update ; apt-get upgrade ; apt-get dist-upgrade'
20:23:17 <Cale> roconnor: As there will be models which go either way.
20:23:18 <lispy> jaredj: heh
20:23:19 <m3ga> not safe to do that ubuntu -> debian or vice versa
20:23:42 <orbitz> m3ga: ok, are the testing sources listed on the debian page somewhere?
20:23:56 <Cale> roconnor: If we're in the outermost system we're willing to consider, it just means that it has no truth value.
20:24:09 <Cale> roconnor: But we can always decide to step out.
20:24:15 <m3ga> orbitz: i just replace 'stable' or 'lenny' or whatever with testing
20:24:20 <m3ga> doesn't need a code name
20:24:24 <jaredj> orbitz: me too
20:24:29 <Cale> (usually by adding some new axioms)
20:24:36 <m3ga> testing is always testing. codenames suck :-)
20:24:42 <orbitz> ah
20:24:45 <orbitz> m3ga: thank you very much
20:24:58 <Cale> (but not necessarily, even)
20:25:18 <m3ga> well i like to make sure my contributions to haskell packageing on debian is used by people :-)
20:26:02 <JoeyA> I wonder if anyone's made a module designed to transform GHCi into a shell.
20:26:16 <JoeyA> e.g. by providing easy-to-use ls, cd, etc.
20:26:25 <dolio> Hey, I apparently got the same impression as Cale from that article.
20:26:32 <Cale> roconnor: My whole point is that since there will always be undecidable statements, and we can't even tell conclusively which ones are undecidable, it doesn't seem to make sense to say that there's an objective truth about the natural numbers.
20:26:40 <roconnor> Cale: the Pi_1 sentences are semi-decidable.
20:27:06 <monochrom> parsec is happy. she is hubris. xml is pointfree.  (all six are real package names!)
20:27:39 <orbitz> m3ga: is ghc in testing the latest an dgreatest?
20:27:41 <dolio> There's really an "xml" package? That's a bold name grab.
20:27:48 <Cale> Sure. That just means that if we can falsify one of the Pi_1 statements in our bigger system, then we can falsify it in our inner system too.
20:27:52 <monochrom> yeah I'm surprised :)
20:28:13 <JoeyA> Is there a way to hide "Loading package" messages in GHCi?
20:28:22 <Cale> But our bigger system *always* has undecidable statements. We can't even take some sort of limit, can we?
20:28:25 <orbitz> m3ga: mind if I PM?
20:28:29 <monochrom> someone should make poems in solely hackage package names :)
20:28:44 <m3ga> orbitz: its 6.12.1. 6.12.3 was delayed for the recent freeze that testing could transition to stable,
20:28:47 <Cale> (Maybe we can?)
20:28:50 <m3ga> orbitz: sure
20:28:59 <roconnor> Cale: even if we can't tell which Pi_1 sentences are not decided by say PA, we still know that those ones that are not decided by PA are the true ones.
20:28:59 <JoeyA> I wish someone would make a Haskell analogue to http://www.gnu.org/fun/jokes/declarations.html
20:29:06 <roconnor> (assuming PA is sound)
20:29:08 <JoeyA> Maybe Nothing
20:29:18 <Cale> I'm unconvinced that even taking a limit ZFC -> ZFC+Con(ZFC) -> ZFC+Con(ZFC)+Con(ZFC+Con(ZFC)) -> ... will catch them all.
20:29:33 <roconnor> Cale: I'm not suggesting that
20:29:36 <lispy> int80_h: did you get your examples sorted?
20:29:41 <JoeyA> (Maybe (Something Good)) (Maybe (Something Bad))
20:29:59 <roconnor> Cale: btw, you still haven't responded to my point that all your statements are meaningless according to your own point of view.
20:30:13 <roconnor> Cale: what do you even mean when you say "such and such is provable"
20:30:20 * hackagebot enumerator 0.1 - Implementation of Oleg Kiselyov's left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.1 (JohnMillikin)
20:30:24 <roconnor> Cale: or "such and such is decidable"
20:30:26 <lispy> roconnor: are you trolling Cale? :)
20:30:29 <Cale> roconnor: I think it's silly to say those statements are true when there's no proof of some of them in any formal system we can construct.
20:31:09 <roconnor> Cale: it isn't silly at all.  It's I direct consequence of what it mean when we claim that PA is sound.
20:31:31 <roconnor> It's a direct ...
20:31:33 <Cale> I dislike your use of the word "sound" without reference to a particular external metalogic.
20:31:45 <Cale> Of course, that's the same argument you're leveling against me :)
20:32:13 <roconnor> Cale: soundness is defined in every meta-logic that is capable of talking about PA and provability.
20:32:21 <Cale> Whenever we study properties like soundness or decidability, there's always an external metalogic which is colouring the discussion.
20:32:49 <roconnor> My perfered meta-logic is the monk, but I suspect you don't like that one.
20:33:13 <Cale> The monk isn't a formal system, so there's no notion of soundness there.
20:33:40 <Cale> (Or at least, if you want to formalise the monk, it will be enough trouble that we can't do it right now.)
20:34:08 <roconnor> I personaly think every meta-system chain ends with the monk.  Otherwise you end up like you with unterminted chains and hence everything you say is meaningless.
20:34:24 <dolio> What is "the monk"?
20:34:49 <Cale> dolio: A person willing to sit down and write symbols on parchment.
20:34:54 <dolio> Oh.
20:35:20 <roconnor> dolio: the monk is a person that takes partchments with detla_0 setences on them and tells you if they are true or false.
20:35:59 * EvanR was about the say 'hell is the monk' but scrolled up 4 lines
20:36:18 <Saizan> not every meta-logic will agree about the soundness of PA, right?
20:36:23 <roconnor> Cale: but anyhow, you can pick whatever meta system you like.  As long as it extends PRA, I think I will be happy, though I might prefer it to extend PA.
20:36:45 <Cale> roconnor: If you want to apply mathematics, we will end up with a monk somewhere, and sure, in our own reasoning in these discussions, we're taking the place of the monk. But if you want to talk about things like soundness of mathematical statements, I'm going to insist that soundness is always between one formal system and another.
20:36:56 <Cale> (and monks don't count)
20:37:10 <Cale> Because I don't know how to define soundness otherwise, and I don't think you do either.
20:37:46 <roconnor> well, when we write numbers and deduction on the chalk board according to the rules that we have agreed upon for them, I don't know what else to call the meta-logic.
20:39:58 <roconnor> A sigma1-sound system on the chalk board is one in which every time we write a deduction on the chalk board of a sigma1 sentence we can find some string of digits on the chalk board that if we fill it into that quantified variable and compute we will get true.
20:39:59 <Cale> roconnor: Here's the problem... soundness always means that whenever something is provable in our internal system, it's true in our meta-system. But there's no notion of truth of mathematical statements outside of any formal system.
20:40:34 <Cale> Or are you going to try to apply the scientific method to arithmetical statements?
20:40:38 <roconnor> A Pi1-sound system on the chalk board is one in which every time we write a deduciton on the chalk board of a pi-1 sentence then for every string of digits we put in if we compute we will get true
20:40:49 <roconnor> a Sigma2-sound system is ...
20:41:13 <Cale> But then nothing with a universal quantifier in it is true.
20:41:26 <roconnor> why do you say that?
20:41:33 <Cale> Because there will be some natural number which we can't encode using the dust particles on our blackboard.
20:41:50 <roconnor> we are using our imagination here.
20:42:01 <roconnor> an idealized chalk board.
20:42:18 <Cale> My imagination only has room for a finite amount of information.
20:42:28 <mlf> @pl glork f g h x = f (g x) (h x)
20:42:28 <lambdabot> glork = liftM2
20:42:32 <roconnor> fine
20:42:33 <Cale> There's a limit to how much I could check that way.
20:42:33 <mlf> *groan*
20:42:34 <roconnor> look
20:42:42 <EvanR> roflcopters
20:43:00 <Cale> and I would begin to fail to verify any universally quantified statement at some point
20:43:06 <lispy> mlf: nice.  although, I prefer using ap and fmap :)
20:43:07 <Pseudonym> Grrrrrr.
20:43:15 <Pseudonym> Sorry, bad etymology annoys me.
20:43:17 <Cale> (for reasons such as I died)
20:43:34 <Pseudonym> helicopter = helix + pter = spiral + wing
20:43:46 <Pseudonym> I'll shut up now.
20:43:51 <shachaf> Cale: Wait, you died? When?
20:44:14 <lispy> Pseudonym: How's it going?
20:44:18 <roconnor> Cale: You don't have to verify it for it to be true or false. I'm stating a counterfactial
20:44:21 <Pseudonym> Not bad, you?
20:44:23 <Cale> shachaf: In the future, while checking some arithmetical statement using my imagination.
20:44:30 <shachaf> Ah, OK.
20:44:35 <Pseudonym> lispy, did you catch my preprint?
20:44:38 <EvanR> roflpters
20:44:39 <shachaf> @ty (.) -- Your legacy will live on.
20:44:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:44:44 <roconnor> Cale: *IF* you did the deduciton for some number *then* you would get true.
20:44:51 <Pseudonym> http://arxiv.org/abs/1008.2555
20:44:54 <lispy> Pseudonym: no
20:45:18 <Cale> roconnor: I think it's okay to say that if we can't ask the question in our universe, it doesn't necessarily have an answer.
20:45:22 <lispy> Pseudonym: oh, I think I have a pending friend invite from you on facebook.  I couldn't quite place your name, but now I do :)
20:45:28 <Pseudonym> Ah!
20:45:37 <Cale> (In our universe)
20:45:43 <Pseudonym> There you go.  I spend almost exactly zero time on facebook, so...
20:45:49 <roconnor> Cale: you can probably go that route if you want.  I doubt it changes anything for me.
20:46:25 <roconnor> Cale: if there is a number so big that you can't imagine it existing, then it isn't in the domain under discussion.
20:46:25 <lispy> Pseudonym: wow, that seems pretty amazing, just reading the abstract
20:46:30 <Cale> roconnor: So I consider our universe to be much weaker than PA
20:46:56 <Cale> roconnor: Our universe using the counting-particles scientific model of PA
20:47:05 <roconnor> Cale: I don't know how you can manage to imagine a number so big that you can't imagine it.
20:47:15 <roconnor> Cale: that seems impossible.
20:47:27 <EvanR> i couldnt begin to image
20:47:29 <EvanR> ine
20:47:31 <lispy> Pseudonym: only 23GB?  Get your copy of the human genome today!
20:47:37 <roconnor> Cale: wait let me rephrase
20:47:38 <Pseudonym> :-)
20:47:51 <Pseudonym> We're currently building a graph based on real read data.
20:47:54 <Pseudonym> 450GB worthg.
20:47:56 <lispy> It would be really funny to share that on bittorrent
20:48:05 <Pseudonym> We'll see how far down we can compress it.
20:48:06 <Cale> roconnor: There are many numbers between 0 and Graham's number which I'm reasonably sure have so many bits of information that the state space of my brain is not large enough to encode them.
20:48:07 <EvanR> i cant really imagine half of the big numbers i read about
20:48:15 <roconnor> Cale: If the number can't fit in our universe. Fine, let's just imagine a big enough universe able to hold every number you can imagine.
20:48:26 <roconnor> Cale: we will work in there.
20:48:28 <Cale> roconnor: That won't help us to check the statement.
20:48:32 <Pseudonym> Incidentally, we ran into the 25TB limit for GFS file systems.
20:48:35 <Pseudonym> Dammit.
20:48:37 <roconnor> I"m not trying to check the statement.
20:48:44 <roconnor> I'm just defining what it means to be true.
20:48:48 <roconnor> god.
20:48:53 <lispy> Pseudonym: cool!
20:48:57 <Cale> roconnor: It'll only help us imagining ourselves checking the statement, which isn't the same.
20:49:04 <roconnor> Of all people I'd expect you to understand how we can define uncomputable things
20:49:34 <Cale> Oh, I'm fine with defining uncomputable things. It's accepting supposed proofs which are not computable that I have trouble with.
20:49:37 <roconnor> Cale: I don't want to imagine a process of checking if a Pi_1 statement is true.
20:49:57 <roconnor> Cale: I jsut want you to be able to undrstand what it means for a Pi_1 statement to be true
20:50:18 <roconnor> Cale: in this large imaginary universe, if you pluged in a number you would compute true.
20:50:33 <roconnor> that's what it means for a pi_1 statement to be true.
20:50:38 <Cale> What are the physical properties of our large imaginary universe?
20:50:50 <roconnor> Cale: same as our universe, only the universe is bigger.
20:51:04 <EvanR> it has very large blackboards
20:51:26 <Cale> See, my problem with this is that at the end of the day, you have a silly definition of truth which is completely unusable.
20:51:42 <roconnor> it's not so unuseful
20:51:42 <Pseudonym> lispy: The current "state of the art" for building assembly graphs for h. sapiens-sized genomes is that it's impossible.
20:51:47 <Cale> My definition of truth as provability in ZFC is usable.
20:51:54 <roconnor> I'm able to prove that if PA is sound then so is PA+con(PA).
20:51:58 <Pseudonym> Too big for one machine, too unwiedly for a cluster.
20:52:08 <lispy> Pseudonym: wait no, the pending friend request is not you.  Hmm
20:52:16 <Cale> In that if I say that something is true, then you can force me to provide an effective proof which you can check.
20:52:17 <EvanR> Pseudonym: whats an assembly graph?
20:52:24 <roconnor> Cale: not really.
20:52:32 <Pseudonym> EvanR: Ah, well.  Let's talk about this in -blah.
20:52:33 <Cale> (In principle)
20:52:35 <lispy> Is Matt Bromberg a haskeller?
20:52:47 <roconnor> Cale: what do you mean by provability in ZFC?
20:54:17 <Cale> roconnor: Taking ZFC to be our outermost system for the moment, I mean that if I say something is true, then you can ask me to provide for you a bunch of symbols on paper which consist of a proof of it, or else doubt me.
20:54:29 <roconnor> how many symbols?
20:54:38 <roconnor> I can imagine a lot of symbols
20:55:05 <Cale> Practically speaking, it's bounded, because I won't be able to do it after a point.
20:55:15 <Cale> Let's keep it below a million, okay? :)
20:55:47 <Cale> (Though maybe through a lot of work, I could do more in my lifetime)
20:56:11 <roconnor> So if I prove it in NBG set theory, which is equiconsistent but has exponentially shorter proof, then I've proven a statement that isnt "cale-true"
20:56:14 <Cale> roconnor: This is stronger than your notion of Pi_1 truth, because I can prove things which have universal quantifiers in them using the axioms of ZFC.
20:56:34 <Cale> Sure, at least, ZFC-Cale true.
20:56:50 <Cale> I can use NBG too when I want to of course.
20:58:26 <roconnor> and similarly if ZFC has a (sort) inconsentcy proof, then false is cale-true
20:58:31 <Cale> roconnor: If you force me to use a notion of truth for finitary statements about natural numbers which involves removing all the universal quantifiers, well, I'm crippled. I could never hope to convincingly show forall a, b. a + b = b + a that way, I could only hope to give a bunch of examples where it doesn't fail.
20:58:42 <Cale> roconnor: Yep.
20:59:48 <roconnor> and if ZFC is consistent then con(ZFC) isn't cale-true.
20:59:55 <Cale> Right.
21:00:08 <roconnor> so you don't believe that con(ZFC) is true?
21:00:36 <Cale> For the most part, though really I'm agnostic about it.
21:01:11 <Cale> (In the same way that I'm an agnostic atheist regarding god.)
21:01:29 <Cale> I don't believe that Con(ZFC) is ZFC-true
21:01:33 <wakeupsticky> cabal simply does not work on windows.
21:01:33 <roconnor> what do you mean by you are agnostic about it?
21:01:48 <wakeupsticky> just so you guys know. it's broken.
21:02:02 <Cale> I mean that I don't think it's possible for me to know for sure if there's a short enough proof for me to understand.
21:02:07 <Jafet> (Hmm, can Con(ZFC) be expressed in ZFC?)
21:02:14 <wakeupsticky> either that or both the wx package and the blig package are broken in exactly the same way.
21:02:19 <wakeupsticky> blig = glib
21:02:42 * BMeph thinks wakeupsticky needs to reload the Platform, since BMeph's Vista machine runs cabal just fine...
21:02:43 <Cale> Jafet: yes, as a statement about ZFC embedded inside itself.
21:02:59 <roconnor> short enough proof of what?
21:02:59 <wakeupsticky> BMeph, you use wx or gtk2hs?
21:03:01 <Cale> Jafet: Where you represent mathematical statements using sets.
21:03:10 <Cale> roconnor: Of the consistency of ZFC in ZFC.
21:03:40 <Cale> roconnor: I don't know whether I'll ever come across a proof of Con(ZFC) in ZFC in my lifetime.
21:03:55 <Cale> But I strongly doubt that I will.
21:03:58 <BMeph> wakeupsticky: gtk2hs, usually. I'll try loading up wx though, since you've been having trouble all day.
21:04:06 <Jafet> Well, it would be trivial to prove Con(ZFC) in ZFC if Con(ZFC) is false.
21:04:20 <Cale> Jafet: Indeed.
21:04:25 <Jafet> So, agnosticism it is.
21:04:26 <wakeupsticky> i sent an email to the wx mailing list. i'll be interested to see if anyone responds.
21:04:44 <Cale> Jafet: and if Con(ZFC) is true, then it's not supposed to be possible.
21:05:22 <Cale> Jafet: Because first order systems which can express Pi_1 statements of arithmetic and can prove their own consistency are inconsistent.
21:05:44 <Saizan> wakeupsticky: bindings to C libs are known to be harder to build on windows because the C toolchain is harder to setup there.
21:06:47 <wakeupsticky> after carefully following the instructions for gtk+ (downloading all-in-one binary, unpacking, adding ~.cabal/bin to the path, adding the directory i unpacked the binaries into to the path, etc.) i tried to do cabal install glib because that is one of the gtk2hs packages, but i got the error:
21:06:47 <Cale> (Which is, funnily enough, something we usually prove in ZFC... but it doesn't require all of ZFC, the proof transfers to other set theories easily enough)
21:07:24 <wakeupsticky> setup.exe: gtk2hsc2hs is required but it could not be found.
21:07:41 <roconnor> Cale: if there is only a long proof of false in ZFC but a short proof in NBG, you'd still be happy to work in ZFC?
21:08:14 <wakeupsticky> cabal: Error: some packages failed to install: glib-0.11.1 failed during the configuration step. The exception was:
21:08:26 <wakeupsticky> ExitFailure1
21:08:57 <luite> wakeupsticky: cabal instal gtk2hs-buildtools
21:09:19 <Cale> roconnor: Actually, I'm not convinced that I'd be totally unhappy with working in a system that I knew was inconsistent. It would make things strange, and would take some getting used to, but essentially what it would do is make me focus more on the structure of the proofs than on what is provable.
21:09:23 <luite> wakeupsticky: do that first, due to a limitation in cabal, it cannot be installed automatically (at least not without abusing dependencies)
21:10:08 <wakeupsticky> ok, it looks like that is actually working
21:10:27 <wakeupsticky> tons of output...we'll see
21:10:37 <roconnor> Even if you could prove 0=1 but not the final thrust towards proving false tips us over to 1000001 steps?
21:11:05 <wakeupsticky> so i'm going to go add the directory that it said it installed the executables to to my path variable
21:11:09 <Cale> roconnor: My actual limit on the number of steps is a soft one.
21:11:17 <JoeyA> Where does ghci.conf go on Windows? (I'm not on Windows)
21:11:46 <Cale> roconnor: (It's just dependent on what resources I have as a human)
21:12:46 <dolio> roconnor: If ZFC only has a long proof of false, it's safer, because it's harder to accidentally write down.
21:13:06 <wakeupsticky> ok, so all i want to do is create a simple gui program written in haskell while working on windows.
21:13:35 <wakeupsticky> so i got gtk2hs-buildtools...can i just do "cabal install gtk2hs" or is gtk2hs a collection of packages and not itself a package?
21:13:36 <Cale> wakeupsticky: I'm not a windows user, but I have gotten wxHaskell working on windows before.
21:13:44 <Cale> (and yeah, gtk2hs is supposed to work)
21:13:57 <Cale> You should be able to, yes.
21:14:23 <luite> wakeupsticky: yes it's a collection, it includes the packages glib, gtk, cairo and a few others
21:14:38 <roconnor> dolio: not really, all sorts of unsound things could have short proofs.
21:14:43 <wakeupsticky> but some are necessary and some aren't, right?
21:14:51 <luite> you just install what you need :)
21:15:00 <wakeupsticky> haha, i don't know what i need :P
21:15:03 <roconnor> dolio: actually what is important is whether or not ZFC is sound or not; not weather it is consistent or not.
21:15:13 <wakeupsticky> i need whatever you need to create a GUI.
21:15:14 <roconnor> dolio: but cale doesn't believe in soundness.
21:15:22 <dolio> roconnor: How do you write down short, unsound things without being able to make short proofs of false from them?
21:15:37 <luite> wakeupsticky: gtk then, I think that automatically brings in glib, not sure though
21:16:02 <Cale> You keep saying "unsound things" but soundness is something which depends on interpretation. When we go to actually apply mathematics to science, we always assume that our scientific models are flawed, and just hope that they're not too flawed to get us where we need to go.
21:16:16 <roconnor> dolio: for example both the proof of 0=1 and 0/=1 could be short, but their sum is large.
21:16:16 <luite> wakeupsticky: have you installed the gtk libraries first, and added the bin directory to your PATH?
21:16:25 <Jafet> gtk+ has glib, and probably cairo and pango as dependencies
21:16:49 <Jafet> And that's before any cabal
21:16:59 <wakeupsticky> yes, but i did that manually, without cabal
21:17:16 <Cale> There is no external notion of absolute truth, and the only real measures of truth are various kinds of utility (in the broadest sense of the word)
21:17:22 <luite> wakeupsticky: ok, then the rest should be automatic :)
21:17:38 <roconnor> Cale: if ZFC proved that ZFC wasn't sound, we would stop using it, even it if was consistent.
21:17:52 <dolio> roconnor: You mean, each proof is 500,000 symbols, which puts the total at 1,000,000, above the limit?
21:17:56 <wakeupsticky> i followed the instructions here
21:17:57 <wakeupsticky> http://code.haskell.org/gtk2hs/INSTALL
21:17:58 <roconnor> dolio: yes
21:18:02 <wakeupsticky> i believe i did so correctly
21:18:04 <dolio> Half the limit is still hard to write.
21:18:05 <Cale> The universe doesn't decide for us about whether some string of symbols is true or false. A giant hand never comes down from the sky with a booming voice and says "NO".
21:18:11 <Jafet> Truth is defined by the little voice in my head that appears whenever I commit a gruesome crime
21:18:20 <wakeupsticky> then i ran cabal install gtk2k-buildtools and it seemed to work
21:18:21 <dolio> Unless your limit is easy.
21:18:24 <wakeupsticky> so that's precisly where i'm at
21:18:41 <roconnor> Cale: we can compute for delta_0 statements
21:18:42 <Cale> roconnor: ZFC is unsound under a lot of interpretations.
21:19:19 <Cale> and so is PA
21:19:24 <Cale> and it doesn't stop us using them
21:19:37 <roconnor> Cale: that doesn't make any sense to me.
21:19:38 <Saizan> wakeupsticky: run "cabal install gtk"
21:20:07 <roconnor> Cale: name one
21:20:23 <roconnor> *since I don't even understand what your statement means*
21:20:32 <luite> wakeupsticky: you'll need to download extra libraries manually for some packages, like webkit
21:20:38 <roconnor> hopefully naming one will help me understand what you are trying to say
21:20:38 <wakeupsticky> how in the name of Jesus do people write the software that does things like cabal?
21:20:49 <wakeupsticky> i am a simple-minded applications programmer
21:21:20 <wakeupsticky> k, looks like massive failure...i will relay the errors
21:21:21 <ksf_> how do I quasiquote a type like (Maybe String)?
21:21:45 <wakeupsticky> gtk depends on gio which failed to install (paraphrase)
21:21:49 <kmc> [t| Maybe String |]  -- like so ksf_ ?
21:21:57 <wakeupsticky> pango depends on cairo which failed to install (paraphrase)
21:22:09 <Cale> roconnor: Well, I admit that saying ZFC on its own was a little cheap, but I don't even know what you mean by soundness of ZFC, so I assume there has to be some additional physical theory to help interpret and make predictions about what we'll observe under various circumstances.
21:22:19 <kmc> or do you mean the actual TH.Quote.QuasiQuoter quasi-quote?
21:22:31 <luite> wakeupsticky: you might want to paste more of the output at hpaste.org
21:22:32 <ksf_> neither what you or I were saying.
21:22:36 <ksf_> I'm trying to get a name.
21:22:40 <ksf_> that is, '' syntax
21:22:41 <Cale> roconnor: Many of our physical theories are known to be wrong and yet are still useful.
21:22:47 <luite> wakeupsticky: look for the first package that fails to install
21:22:54 <roconnor> Cale: I know you don't understand what I mean by soundness, but dolio probably has a bit more imagination than you do.
21:23:00 <Cale> roconnor: Newtonian mechanics, which makes use of the real numbers, for example, is wrong and useful.
21:23:06 <kmc> ksf_, "Maybe String" doesn't have a name
21:23:18 <ksf_> well, that's... argh.
21:23:24 <kmc> maybe you can make a type synonym, in order to give it a name?
21:23:31 <Cale> roconnor: Soundness at this outermost level, as far as I can see, isn't a binary predicate.
21:23:40 <roconnor> sure it is
21:23:47 <roconnor> A or not A is provable in every logic
21:23:48 <roconnor> binary
21:24:04 <Cale> roconnor: It's more like a utility-valued function of the manner in which we're interpreting the statements.
21:24:08 <ksf_> hmmm no. I want to write proper combinators
21:24:11 <wakeupsticky> it appears that the first failure was cairo
21:24:25 <Cale> (and utility is itself ill-defined and different for each person)
21:24:48 <wakeupsticky> then gio, then gtk, then pango
21:24:53 <wakeupsticky> based on certain dependencies
21:25:15 <Cale> "A or not A" is also a useless statement in every logic, and the fact that it's provable says nothing at all.
21:25:28 <wakeupsticky> not useless
21:25:41 <Cale> Well, not *completely* useless.
21:25:54 <wakeupsticky> aid to thought mostly
21:25:57 <Cale> But it's essentially content-free, along with all the other tautologies.
21:26:23 <Cale> When we apply a semantics to the logic, it will tend to have trivial semantics.
21:26:32 <roconnor> is Fermat's Last Theorem content-free?
21:26:50 <Cale> Fermat's Last Theorem isn't a tautology.
21:26:52 <wakeupsticky> it is to me
21:27:09 <Saizan> wakeupsticky: can you paste the actual cabal output?
21:27:10 <wakeupsticky> content-free that is, not a tautology
21:27:31 <roconnor> Cale: is forall x. x = x content free?
21:27:34 <wakeupsticky> call me stupid, but my cmd prompt won't allow me to select text
21:27:49 <wakeupsticky> i can relay the exact error message if it will mean something to someone
21:27:53 <luite> wakeupsticky: right click, then click "mark" in the context menu
21:28:02 <luite> wakeupsticky: enter to copy to clipboard after selecting
21:28:04 <Cale> roconnor: I'll say yes, assuming that = is not a relation symbol, and is instead the = from FOL.
21:28:23 <wakeupsticky> cabal: Error: some packages failed to install: cairo-0.11.1 failed during the building phase. The exception w ExitFailure 1 gio-0.11.1 failed during the building phase. The exception was ExitFailure 1 gtk-0.11.2 depends on gio-0.11.1 which failed to install. pango-0.11.2 depends on cairo-0.11.1 which failed to install.
21:28:31 <roconnor> Cale: is forall n. 0 /= S n content-free?
21:28:40 <Cale> no.
21:28:45 <wakeupsticky> a bit got cut off there.
21:28:54 <roconnor> Cale: what is its content?
21:28:56 <luite> wakeupsticky: you need to paste why cairo failed, and please use hpaste.org if it's more than one line
21:28:57 <Cale> (It's not a tautology)
21:29:19 <Cale> Well, it *may* be given content, by some semantic interpretation of the statements of our system.
21:29:28 <Cale> Because it's not a tautology.
21:29:33 <roconnor> ok
21:30:08 <wakeupsticky> ok, it's up
21:30:11 <Cale> But of course the interpretation is separate, not part of the logic itself.
21:30:15 <wakeupsticky> "cabal fails to install gtk" by wakeupsticky
21:30:28 <Jafet> In which system, though? It's an axiom in P.
21:30:50 <wakeupsticky> there is more output before that but it doesn't look like it contains errors
21:30:54 <wakeupsticky> i'll look again to be sure
21:30:55 <Jafet> Whether axioms have meaning cannot be quantified in terms of proof style
21:31:06 <luite> wakeupsticky: hmm, probably went wrong earlier? isn't there something about a missing header file?
21:31:37 <Cale> Jafet: Yeah, it's an axiom in PA, and if we intepret PA in say, our scientific model of counting rocks, it means that not having any rocks is never the same as having one more than some number of rocks.
21:32:12 <Cale> So it gets meaning as a statement about piles of rocks then.
21:32:21 <Jafet> I consider that rather content-free -- maybe a caveman wouldn't
21:32:47 <Cale> It's not content free in the sense that the statement that having n rocks is the same as having n rocks.
21:32:53 <wakeupsticky> there are several warnings, including one that says that Setup.hs is guessing what version of cabal i'm using
21:32:59 <wakeupsticky> i don't see anything about a missing header file
21:33:20 <wakeupsticky> how many people on Earth know exactly what that error output means?
21:33:21 <wakeupsticky> :)
21:33:41 <luite> wakeupsticky: can you paste the whole output? you can add it to the current post
21:34:22 <ddarius> Necessary versus contingent.
21:34:26 <Cale> (sorry my grammar got a bit messed up there)
21:34:44 <wakeupsticky> the output is so long that it gets truncated
21:34:50 <wakeupsticky> it's like ten pages
21:34:56 <luite> wakeupsticky: if you can't scroll back that much, you can retry installing it by using > cabal install cairo 2> out.txt
21:35:06 <luite> wakeupsticky: and then copy/paste out.txt to hpaste
21:35:32 <wakeupsticky> by out.txt you mean some file i actually create right? :)
21:35:32 <roconnor> Cale: your definition of provable in ZFC seems of quite a different character of the inner logic systems we've discussed which have unbounded proof lengths.
21:36:03 * Axman6 thinks there should be an hpaste program on hackage: cabal install cairo 2>&1 | hpaste
21:36:10 <Cale> roconnor: That's because I was taking ZFC to be my absolute outermost system at that point, and not reasoning about ZFC via some other logical system.
21:36:11 <roconnor> Cale: or should I reintepret provability when you are doing metamathematics as being provable with short proofs.
21:36:47 <Cale> roconnor: There's a difference between writing down a proof in ZFC, and talking about proofs of ZFC while using another formal system.
21:36:58 <roconnor> no kidding
21:37:16 <Cale> When I'm using another formal system, I have access to unbounded and infinite things.
21:37:24 <Cale> It gives me that capacity.
21:37:28 <roconnor> no you don't
21:37:31 <wakeupsticky> i'm generating out.txt now
21:37:42 <Cale> Well, I may, by virtue that they are defined by that system.
21:38:05 <wakeupsticky> the output seems to be shorter this time
21:38:09 <wakeupsticky> i'm pasting it as a revision
21:38:47 <Cale> For example, when I'm using PA or ZFC, I can talk about the set of natural numbers which is infinite, and prove things about infinitely many natural numbers at a time. When I'm using a formal system with no foralls, I can't prove anything about infinitely many natural numbers.
21:38:58 <wakeupsticky> in my browser the output didn't wrap properly :(
21:39:30 <Cale> Er, sorry, in PA I can't talk about the set of natural numbers, but I can write down universally quantified statements
21:39:30 * roconnor sleeps
21:39:46 <napping> roconnor: you should read about how to build models of ZFC + !Con(ZFC)
21:39:49 <Cale> and in ZFC, I can talk about the whole set of naturals at once
21:39:59 <roconnor> napping: I'm well awayre of such models
21:40:05 <roconnor> napping: they are not sound.
21:40:29 <Cale> roconnor: They're sound in ZFC + !Con(ZFC).
21:40:36 <roconnor> napping: in any meta-logic
21:40:49 <roconnor> Cale: no they are not.
21:41:00 <roconnor> not even in ZFC + !Con(ZFC)
21:41:11 <Cale> Er, hmm...
21:41:27 <roconnor> I'm pretty sure that PRA can prove that ZFC+!Con(ZFC) isn't sound
21:41:53 <wakeupsticky> maybe, but do you have a date for the weekend?
21:41:53 <Cale> Which statement is provable in ZFC + not Con(ZFC), but not true in ZFC + not Con(ZFC)?
21:42:35 <roconnor> Cale: that depends on if ZFC is sound or not.
21:42:45 <Cale> roconnor: What?
21:42:50 <Cale> roconnor: No it doesn't.
21:43:10 <roconnor> in either case there is a statement, but which one it is depends on if ZFC is sound or not.
21:43:38 <Cale> If ZFC is sound in ZFC + not Con(ZFC) or not?
21:44:08 <Cale> Actually what's our standard model here?
21:44:17 <roconnor> the natural numbers, as always
21:44:27 <Cale> Uhh... that can't be
21:44:30 <Cale> Well...
21:44:37 <wakeupsticky> hey saizan, luite, any thoughts?
21:44:41 <Cale> You can give a countable model of ZFC, sure...
21:44:48 <wakeupsticky> i might have to just give up and go to bed soon :)
21:44:51 <Cale> but, that's a weird one :P
21:45:55 <Cale> wakeupsticky: you don't have the GTK library headers installed where it expects you to.
21:46:10 <Cale> Graphics\Rendering\Cairo.hs:8:0:
21:46:10 <Cale>      cairo-version.h: No such file or directory
21:46:11 <wakeupsticky> where does it expect me to have them?
21:46:29 <luite> wakeupsticky: have you tested the pkg-info things from INSTALL?
21:46:29 <Cale> I honestly don't know. I would know on Linux.
21:47:10 <luite> wakeupsticky: sorry I meant pkg-config
21:47:22 <wakeupsticky> i did that, it gave me what looked like some non-error, sensible output
21:47:25 <Cale> roconnor: We're not talking about a model of PA here anymore :)
21:47:36 <wakeupsticky> -IC:<filepath>*
21:47:50 <wakeupsticky> bunch of paths prefixed with -IC:
21:48:14 <luite> wakeupsticky: try > pkg-config --cflags cairo
21:48:42 <wakeupsticky> -IC:/gtk/include/cairo -IC:/gtk/include/libpng12
21:49:22 <Saizan> do you have C:/gtk/include/cairo/cairo-version.h ?
21:49:45 <Cale> I guess our standard model would be L.
21:49:46 <roconnor> If con(ZFC) then ZFC+!con(ZFC) is clearly not sound.  If !con(ZFC) then ZFC is clearly not sound and hence ZFC+!con(ZFC) is not sound.
21:49:59 <roconnor> that line is easy to formalize in ZFC
21:50:08 <wakeupsticky> no, but i have several cairo-xxx.h files
21:50:09 <roconnor> and hence easy to formalize in ZFC+!Con(ZFC)
21:50:11 <wakeupsticky> just not that one
21:50:28 <roconnor> so we see that ZFC+!Con(ZFC) proves that ZFC+!Con(ZFC) isn't sound.
21:50:43 <Saizan> too bad since that's the one it includes :)
21:51:07 <luite> wakeupsticky: are you sure you have downloaded a gtk development package with binaries?
21:51:08 <Saizan> i'm not familiar with cairo, so i'm not sure how/from where you should get that
21:51:17 <wakeupsticky> cairo.h, cairo-deprecated.h, cairo-features.h, cairo-pdf.h, cairo-ps.h, cairo-svg.h, and cairo-win32.h
21:51:33 <wakeupsticky> i will show you exactly what i downloaded
21:51:41 <luite> Saizan: it should be included in the gtk development package for windows, at least it was in mine
21:51:42 <wakeupsticky> i'm not 100% sure that it included everything that it was supposed to
21:52:13 <roconnor> ... and cale though A or not A was useless.
21:52:17 <Cale> roconnor: That looks like meta-meta-mathematics, rather than just meta-mathematical, because you're reasoning about soundness, rather than giving a statement whose interpretation is provably false.
21:52:42 <wakeupsticky> http://www.gtk.org/download-windows.html
21:52:58 <Cale> Interestingly, I don't think you can do the latter. :)
21:53:08 <Cale> But okay
21:53:14 <luite> wakeupsticky: download the all-in-one bundle, version 2.20
21:53:35 <wakeupsticky> i went with the old, stable one >_>
21:53:36 <wakeupsticky> wrong?
21:54:09 <wakeupsticky> do i need to delete the current gtk folder?
21:54:19 <luite> wakeupsticky: http://ftp.gnome.org/pub/gnome/binaries/win32/gtk+/2.20/gtk+-bundle_2.20.0-20100406_win32.zip
21:54:19 <wakeupsticky> where i have gtk+ 2.16.6?
21:54:35 <luite> wakeupsticky: yes, it's better to remove it first
21:54:35 <roconnor> Cale: I don't really care how you want to catagorize my proof.  I still showed (I even kindly used a short proof) that ZFC + !Con(ZFC) proves that ZFC + !Con(ZFC) is unsound.
21:54:55 <wakeupsticky> ok, i've deleted that folder
21:55:18 <wakeupsticky> i don't think i can get rid of all the stuff cabal may have put in various directories
21:55:20 <roconnor> ZFC + !Con(ZFC) is unsound according to any meta-logic, even unsound ones.
21:55:27 <wakeupsticky> when it was trying to install gtk
21:55:52 <luite> wakeupsticky: the all-in-one for 2.16 also includes cairo-version.h by the way
21:55:55 <wakeupsticky> extracting now
21:56:11 <wakeupsticky> not mine :P
21:56:25 <luite> you must have done it wrong :p
21:56:37 <wakeupsticky> but i got six other cairo-xxx.h files
21:56:56 <wakeupsticky> what peculiar mistake could i have made to cause cabal to omit just cairo-version.h?
21:56:56 <roconnor> Cale: perhaps this is a good illustration why ZFC + Con(ZFC) and ZFC + !Con(ZFC) are not on equal footing.
21:57:02 <wakeupsticky> magic error imo
21:57:09 <Cale> roconnor: Okay, no, I see how the proof goes. You can tighten it up a bit: Since !Con(ZFC), we have that there is a contradictory statement x of ZFC, but then x is contradictory in ZFC + Con(ZFC) as well.
21:57:19 <Cale> er
21:57:25 <Cale> missed a ! there
21:57:34 <wakeupsticky> ok, now i want to try cabal install gtk again?
21:57:39 <Cale> Don't need to reason about soundness proper.
21:57:41 <roconnor> Cale: yes, that is the deduction I meant.
21:58:00 <Saizan> wakeupsticky: yes
21:58:10 <roconnor> soundness implies consistency no non-consitency implies non-soundness.
21:58:13 <roconnor> s/no/so/
21:58:56 <roconnor> anyhow, ZFC + Con(ZFC) might not be able to prove it's own soundness, but ZFC + !Con(ZFC) right out proves its own unsoundness.
21:59:11 <Cale> yes
21:59:28 <roconnor> good.  Progress
21:59:46 <roconnor> I clear reason to accept some extenstions of PA but not others.
21:59:50 <roconnor> s/I/A/
21:59:52 <wakeupsticky> same exact error
21:59:54 <wakeupsticky> s
22:00:17 <luite> wakeupsticky: do you have a cairo-version.h now?
22:00:28 <wakeupsticky> 'emblem', whatever it is, is missing definitions in some header file
22:00:28 <Saizan> wakeupsticky: cabal has nothing to do with the presence of cairo-version.h btw
22:00:30 * roconnor sleeps again
22:00:31 <Cale> roconnor: Sure, but you still have no way to choose between extensions of PA which have sound embeddings in other systems.
22:01:12 <wakeupsticky> i do indeed have a cario-version.h file
22:01:13 <Cale> Which is what I suppose I originally meant when I said that you have no way to really choose which set of Pi_1 sentences you wanted to make true.
22:01:22 <wakeupsticky> i'm looking at it in notepad++ right now
22:01:35 <Saizan> wakeupsticky: where is it?
22:01:40 <luite> wakeupsticky: then you probably have a new error too
22:02:00 <wakeupsticky> C:\Users\Jesse\gtk\include\cairo\cairo-version.h
22:02:20 <napping> Cale: I don't see how ZFC+!Con(ZFC) is unsound
22:02:28 <wakeupsticky> do i need to add that to my path? ...h files aren't executable though...?
22:02:30 <luite> wakeupsticky: what does > pkg-config --cflags cairo  say
22:02:37 <dolio> We have two competing iteratee packages now?
22:02:37 <napping> in particular, there are issues of quotation that get in the way
22:02:49 <dolio> I guess I need to get around to understanding how the hell to use them.
22:03:07 <wakeupsticky> -IC:/gtk/include/cairo -IC:/gtk/include/libpng12
22:03:30 <luite> wakeupsticky: ok, you have two different gtk installations now
22:03:44 <wakeupsticky> haha i deleted that folder but...
22:03:47 <luite> wakeupsticky: was the one in c:\gtk installed earlier?
22:03:48 <Saizan> that, or the installer is simply deluded about itself..
22:03:59 <wakeupsticky> i honestly don't know
22:04:03 <Cale> napping: hmm...
22:04:05 <wakeupsticky> you mean did it come with the haskell platform?
22:04:16 <Saizan> no
22:04:18 <luite> no, but it might have been installed by some other program
22:04:22 <wakeupsticky> i followed those instructions that i showed you ("INSTALL")
22:04:29 <wakeupsticky> but deleted that folder
22:04:36 <Cale> napping: Perhaps we'd really have to write out the details to see which way it goes.
22:04:45 <wakeupsticky> i have no idea how to get gtk's tendrils out of my hard drive 
22:04:51 <wakeupsticky> if it's not all in one place !
22:05:18 <luite> wakeupsticky: wait, did you really rerun pkg-config after re-extracting gtk, or did you just copy the answer from before?
22:05:51 <Saizan> "cabal install cairo --extra-include-dir=C:\Users\Jesse\gtk\include\cairo\ --extra-include-dir=C:\Users\Jesse\gtk\include\libpng12" if you're lucky, this will work
22:06:06 <wakeupsticky> no, i reran it
22:06:23 <napping> Cale: in slightly more detail, the interpretation of !Con(ZFC) in your model had better boil down to providing a nonstandard set as the putative "proof"
22:06:31 <wakeupsticky> luite, do you cosign saizan's suggestion? :P
22:06:42 <luite> wakeupsticky: ok, the easiest way to fix it is rename c:\gtk to c:\gtk.old and move c:\users\jesse\gtk to c:\gtk , but that might break some other (unknown?) program
22:07:24 <wakeupsticky> hey luite, that C:\gtk is from the link you sent me
22:07:26 <wakeupsticky> the ftp link
22:08:13 <wakeupsticky> the other one...also has the cairo-version.h file o_O
22:08:20 <wakeupsticky> the one in C:\Users\Jesse\gtk
22:08:24 <luite> wakeupsticky: really? you must have c:\gtk\include\cairo\cairo-version.h  then
22:09:19 <wakeupsticky> i swear on my life that in the folder C:\gtk\include\cairo there is no such file
22:09:40 <wakeupsticky> i gave you a list of the cairo-xxx.h files in that folder earlier
22:09:40 <luite> then you haven't extracted it properly, it really is included in the zip
22:09:59 <luite> delete c:\gtk and extract the zip file again
22:11:07 <wakeupsticky> ok, i'm extracting it using WinRar
22:11:14 <wakeupsticky> WinRAR
22:11:43 <wakeupsticky> the folder with "..." next to it is highlighted
22:12:01 <wakeupsticky> i am extracting it to C:\gtk, which will be created
22:12:10 <wakeupsticky> i am clicking ok :P
22:12:55 <wakeupsticky> NOW the file is there
22:13:04 <wakeupsticky> i swear it wasn't before, and i did everything the same. but no matter. what now?
22:13:25 <Saizan> cabal install gtk
22:13:53 <wakeupsticky> i also have C:\Users\Jesse\gtk
22:13:55 <wakeupsticky> delete that first?
22:14:17 <Saizan> shouldn't matter either way
22:14:22 <luite> you can remove that, but it shouldn't interfere, as long as c:\Users\Jesse\gtk\bin isn't in your PATH
22:15:24 <wakeupsticky> but we want C:\gtk\bin in there
22:15:34 <Cale> napping: hmm, let's see... because we're assuming that ZFC is inconsistent, there exists a proof-tree t for an inner ZFC which putatively proves a contradiction. The argument is that this proof tree is also a proof tree for ZFC + !Con(ZFC), and so...
22:17:41 <luite> wakeupsticky: yes, but that was already there, according to your pkg-info results
22:17:44 <Cale> If our chosen model of ZFC + !Con(ZFC) in ZFC + !Con(ZFC) is sound, this proof t under interpretation should provide a theorem of the outer ZFC + !Con(ZFC), but that's a contradiction.
22:17:46 <wakeupsticky> i think it's working this time
22:18:11 <wakeupsticky> cabal is still spitting up
22:19:41 <wakeupsticky> seems to have stalled at: Processing library gtk-0.11.2...
22:19:43 <Cale> (In the outer ZFC + !Con(ZFC))
22:19:57 <wakeupsticky> but my computer is whirring so maybe it's just intense stuff
22:20:08 <wakeupsticky> make that Preprocessing
22:20:10 <ezyang> gtk taking a while is not too surprising... 
22:21:36 <wakeupsticky> ah, it's moved on
22:21:40 <wakeupsticky> i think it's working finally
22:22:56 <Cale> So, okay, assuming that Con(ZFC + !Con(ZFC)), which is implied by Con(ZFC), we have that any interpretation of ZFC + !Con(ZFC) is unsound for ZFC + !Con(ZFC).
22:23:26 <Cale> (I think)
22:23:30 <Cale> I'm getting tired
22:26:16 <wakeupsticky> ok, it's done.
22:26:28 <wakeupsticky> phew...is there anything else i need to do?
22:27:19 <luite> wakeupsticky: not really, but the next time you need to install external dependencies, it may be harder. gtk is now one of the easier ones
22:27:37 <wakeupsticky> lol
22:27:58 <wakeupsticky> so does this mean i have the various gtk2hs libraries?
22:28:22 <luite> wakeupsticky: you can install most gtk2hs packages now, some will require additional libraries
22:28:52 <hamishmack> wakeupsticky: You may want to consider installing with TakeoffGW
22:29:21 <wakeupsticky> ok, so let's say i just want to do a "Hello world" gui app or a simple form-based app or something, just to make sure i understand everything. What packages are necessary?
22:29:47 <hamishmack> wakeupsticky: If you need to install more than just Gtk
22:30:16 <luite> either that, or get use to compiling things with MSYS :)
22:30:19 <luite> used
22:32:33 <wakeupsticky> error: no then statement
22:32:37 <wakeupsticky> nvm
22:32:46 <wakeupsticky> lol i'm so tired right now
22:35:56 <wakeupsticky> all right, i have the demo app, the documentation, etc...thanks so much, guys!
22:36:21 <wakeupsticky> luite, saizan, i really appreciate the guidance
22:36:28 <wakeupsticky> thank you for taking the time to help me :)
22:37:02 <wakeupsticky> i have to go to bed, but i'll keep you guys posted on how my gui-based app goes
22:47:56 <dh__> I wrote an arrow loop ( rec ) with arrow syntax, but don't know how to display it or use it. 
22:49:07 <dh__> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29256#a29256
22:49:16 <dh__> it compiles, 
22:49:42 <dh__> I believe it will give solution for x + 1 = y ; y * 2 = x , am I right ? 
23:09:52 <luite> hmm, need some faster data structure for generating functions
23:17:01 <JHoglund> Yo, I'm defining a 
23:17:23 <shachaf> @let a = 2 + 2
23:17:25 <lambdabot>  Defined.
23:17:26 <shachaf> Too late.
23:17:37 <medfly> hehe
23:17:38 <JHoglund> I'm defining a function with two patterns, such as: let replace "mary" = "jane" and let replace s = s
23:17:39 <medfly> it's defined already
23:17:40 <medfly> > a
23:17:41 <lambdabot>   Ambiguous occurrence `a'
23:17:42 <lambdabot>  It could refer to either `L.a', defined at <local...
23:17:47 <JHoglund> However, I do not get the results I'm expecting
23:18:04 <medfly> what are you expecting?
23:18:21 <shachaf> JHoglund: You can't have that as two separate let expressions.
23:18:21 <JHoglund> If I put the generic one last, the mary->jane does not work, if I put hte mary->jane last, I get an error about a not exhaustive pattern
23:18:35 <JHoglund> Can I do this in Prelude, or do I have to write my definitions in a .hs file?
23:18:47 <shachaf> > let replace "mary" = "jane"; replace s = s in replace "
23:18:48 <medfly> file maek.
23:18:49 <lambdabot>   <no location info>:
23:18:49 <lambdabot>      lexical error in string/character literal at end o...
23:19:15 <luite> > let replace "mary" = "jane" ; replace s = s in replace "ada"
23:19:16 <lambdabot>   "ada"
23:19:54 <JHoglund> shachaf: Great!
23:20:10 <JHoglund> shachaf: Thanks for helping me ou!
23:20:32 <luite> JHoglund: it's easier to work with a file though, reload it in ghci with :r
23:20:58 <luite> unless you're working with lambdabot of course :)
23:22:22 <JHoglund> luite: Yeah, but I just wanted to do a very quick and simple test :)
23:30:52 <luite> hmm, what data structure would be appropriate for multivariate polynomials, that should be multiplied and added quickly?
23:36:35 <luite> I think they have around 20 variables and 100000 terms
