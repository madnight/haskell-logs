00:00:56 <shachaf> Data.Sequence seems a bit magical. I should read about how it's implemented sometime.
00:02:26 <Cale> With careful interplay between laziness and strictness, and a clever sort of "tree" whose maximum and minimum ends have been pulled up into "fingers" so that they can be quickly accessed.
00:03:28 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
00:05:26 <Cale> Oh, apparently that is amortised time. It's logarithmic in the worst case though.
00:06:29 <Cale> It's possible to do the same in the worst case, but with more implementation trickiness.
00:07:51 <Cale> It would be interesting to know how the constant factors play out in practice there.
01:00:17 <Axman6> if x `o` i = x, then i is the left identity right?
01:00:25 <Axman6> uh, right even
01:05:24 <dolio> Axman6: If that is true for all x.
01:06:27 <Axman6> yeah
01:06:35 <Axman6> well, it's supposed to be in this case anyway
01:06:53 <Axman6> hmm, better get going. o/
01:12:25 <m3ga> people are back!
01:12:38 <m3ga> where does one log bugs for alex?
01:35:11 <tibbe> What does a pre-order fold on a binary tree look like? I thought I knew until this morning but now I'm not so sure anymore.
01:37:50 <sioraiocht> tibbe: guess is : fold bin leaf (Node a l r) = bin a (fold bin leaf l) (fold bin leaf r) 
01:38:15 <sioraiocht> as oppose to an in order = bin (fold bin leaf l) a (fold bin leaf r)
01:38:16 <sioraiocht> ?
01:38:50 <tibbe> sioraiocht, so this is what we have right now in Data.Map
01:39:07 <tibbe> foldlWithKey :: (b -> k -> a -> b) -> b -> Map k a -> b
01:39:07 <tibbe> foldlWithKey _ z Tip              = z
01:39:07 <tibbe> foldlWithKey f z (Bin _ kx x l r) =
01:39:07 <tibbe>     foldlWithKey f (f (foldlWithKey f z l) kx x) r
01:40:03 <sioraiocht> oh I aww
01:40:06 <sioraiocht> *see
01:40:33 <tibbe> I guess the idea is that f should be called with increasing keys, like so: ((f z k0 v0)
01:40:37 <tibbe> oops
01:40:41 <tibbe> that got cut off
01:40:50 <tibbe> so I'm not even sure how to define preorder here
01:40:55 <sioraiocht> I suppose, and that uses an accumulating parameter?
01:41:00 <tibbe> yes
01:41:04 <sioraiocht> yes...
01:41:26 <sioraiocht> and that is supposed to be an in-order?
01:41:35 <tibbe> I guess the difference is when f isn't commutative?
01:41:41 <sioraiocht> yes
01:41:46 <tibbe> foldi :: (k -> a -> b -> b -> b) -> b -> Map k a -> b 
01:41:46 <tibbe> foldi _ z Tip               = z
01:41:46 <sioraiocht> it wouldn't matter, otherwise
01:41:46 <tibbe> foldi f z (Bin _ kx x l r)  = f kx x (foldi f z l) (foldi f z r)
01:41:51 <tibbe> is supposed to be inorder
01:41:55 <sioraiocht> okay
01:42:03 <sioraiocht> I mean, it depends ont he properties of "f"
01:42:05 <sioraiocht> heh
01:42:10 <tibbe> (according to the source)
01:42:12 <sioraiocht> yeah
01:42:27 <sioraiocht> *blinks*
01:43:01 <sioraiocht> I mean, to me, that "looks" pre-order
01:43:08 <tibbe> I'm generally confused, I set out to write a faster preorder fold and now I'm not sure what that means
01:43:15 <sioraiocht> haha
01:43:56 <sioraiocht> I mean, to me that looks pre-order
01:43:59 <sioraiocht> it visits the node
01:44:03 <sioraiocht> then the children
01:44:05 <tibbe> I did some manual stepping and I think I can see why that's preorder
01:44:21 <tibbe> well, it's supposed to visit the left child before the parent
01:44:44 <sioraiocht> for in-order...
01:44:46 <tibbe> I also don't like how z is applied many times
01:44:57 <tibbe> that basically means that z must be and identity of f
01:45:01 <tibbe> oh, yes
01:45:30 <tibbe> I feel stupid
01:45:36 <tibbe> perhaps it's too early in the morning
01:45:44 <sioraiocht> most definitely
01:45:52 <sioraiocht> I've had two espresso's
01:45:57 <sioraiocht> espressoes?
01:46:01 <sioraiocht> espressos
01:46:03 <sioraiocht> fuck
01:46:09 <tibbe> haha
01:46:29 <tibbe> I didn't find much by googling around
01:48:13 <sioraiocht> sæll arnihermann
01:48:25 <sioraiocht> Þú ert Íslendingur sem notar Haskell?
01:50:06 <tibbe> sioraiocht, I don't speak Icelandic ;)
01:50:11 <sioraiocht> tibbe: sorry
01:50:19 <sioraiocht> was trying to get arnihermann's attention
01:50:34 <tibbe> sioraiocht, so preorder my somehow mean that if you pick f = ++ and z = [] you should end up with a list of all the keys, in order
01:50:41 <tibbe> sioraiocht, ah
01:50:51 <sioraiocht> I have been interested in finding companies/folks in Iceland who are using Haskell =p
01:51:10 <sioraiocht> hrm, is hat because of a property of how map works, then
01:51:28 <sioraiocht> because for e.g. a binary search tree, you need an in-order traversal to get an ordered list
01:54:31 <tibbe> sioraiocht, I think the folds defined on Data.Map are wrong
01:54:38 <sioraiocht> oh dear
01:54:52 <tibbe> from the docs: fold f z == foldr f z . elems
01:55:01 <tibbe> that is only true if z is an identity of f
01:55:12 <sioraiocht> oh man
01:55:13 <sioraiocht> yeah
01:55:51 <tibbe> sioraiocht, it's also a bit of a leaky abstraction
01:56:08 <tibbe> sioraiocht, you need to know that Map is implemented as a Tree
01:56:14 <sioraiocht> yeah
01:56:16 <plediii> is there a reason to assume that mapM print [1..10] should print 1..10 in ascending order?
01:56:17 <sioraiocht> that's no good
01:56:31 <tibbe> sioraiocht, and you cannot really know how many z:s you'll get as it depends on how balanced the tree is at any given point
01:56:43 <tibbe> plediii, yes
01:57:11 <tibbe> plediii, by definition of mapM
01:57:11 <plediii> ok
01:57:14 <tibbe> :t mapM
01:57:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:57:30 <plediii> i don't see how it follows from the type
01:57:37 <tibbe> plediii, it doesn't
01:58:15 <plediii> ok
01:58:18 <tibbe> plediii, (and you most likely want mapM_)
01:58:27 <tibbe> as you don't care about the result, only the side effects
02:00:12 <arnihermann> sioraiocht: já
02:00:50 <plediii> tibbe: you're right.  
02:07:29 <walter___> Doesn anyone know the package name in for Haskell like g-cpan for perl in Gentoo? Thx
02:08:48 <tibbe> walter___, I'm not quite sure I understand the question. Are you looking for a particular package?
02:09:34 <tibbe> sioraiocht, I wonder if fold should be defined as: foldPreOrder :: (k -> v -> a) -> (a -> a -> a) -> a -> a
02:09:47 <tibbe> sioraiocht, where the lone a is only used if the tree is empty
02:09:50 <sioraiocht> that makes more sense to me
02:09:55 <sioraiocht> that seems much more..foldish
02:10:08 <sioraiocht> the other seems to be purely by trying to make it listish
02:10:15 <tibbe> sioraiocht, right
02:10:30 <walter___> tibbe: it is a package in gentoo portage, that can create ebuild automatically and install haskell package from http://hackage.haskell.org/ 
02:11:13 <tibbe> walter___, and you wonder where it is? Have you checked hackage.haskell.org? If you can't find it there is might be worth asking in #haskell-gentoo
02:11:27 <walter___> tibbe: thanks
02:12:22 <tibbe> walter___, you're welcome
02:41:26 * hackagebot AttoJson 0.5 - Simple lightweight JSON parser based on ByteString  http://hackage.haskell.org/package/AttoJson-0.5 (HiromiIshii)
03:00:22 <aRcatan> my irc library uses ByteStrings and I can't remember why on earth it does so :|
03:11:58 <Axman6> aRcatan: heh
03:36:03 <dom96> aRcatan: because it's faster
03:37:59 <aRcatan> no, i've never used ByteStrings for performance reasons
03:38:28 <ivanm> what have you used bytestrings for then?
03:38:30 <ivanm> :p
03:38:50 <aRcatan> compatibility with libraries!
03:44:48 <zygoloid> is it possible to get DPH/Data.Array.Parallel to generate GPU programs to be run by Data.Array.Accelerate?
03:44:48 <lambdabot> zygoloid: You have 1 new message. '/msg lambdabot @messages' to read it.
03:45:20 <Axman6> zygoloid: not that i'm aware of, but it may be possible in the future
03:45:46 <Axman6> anyone interested in taking a look at my concurrent lists implementation, based on Guy Steel's talk?
03:46:58 <Axman6> I love how much you can write in haskell without having to think about it too much
03:47:58 <Axman6> anyway, if anyone's interested, http://codepad.org/eDwXJt7M
03:48:17 <Axman6> i'm heading out, but any comments would be appreciated
03:50:48 <DamienCassou> I'm reading the random page of the haskell wikibook: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms#Using_QuickCheck_to_Generate_Random_Data
03:51:19 <DamienCassou> it talks about a 'generate' function to get an a from a (Gen a)
03:51:45 <DamienCassou> there is no 'generate' function anymore. However, there is an unGen in the defintion of (Gen a)
03:51:53 <DamienCassou> can somebody help me using it please?
03:52:13 <DamienCassou> :info Gen 
03:53:22 <zygoloid> @hoogle Gen a -> a
03:53:22 <lambdabot> Prelude id :: a -> a
03:53:23 <lambdabot> Data.Function id :: a -> a
03:53:23 <lambdabot> Test.QuickCheck generate :: Int -> StdGen -> Gen a -> a
03:55:40 <DamienCassou> according to http://www.mail-archive.com/haskell-cafe@haskell.org/msg70705.html, generate disappeared
03:59:22 <zygoloid> i guess hoogle is searching an older version of quickcheck.
04:00:36 <DamienCassou> zygoloid: can you please help me get my number? I'm new to haskell
04:01:03 <PeakerWork> Why do Iteratees (e.g: jmkilling's new Iteratee) have "Yield" or "Error" and not just "Yield" with an error type inside the Yield?
04:01:04 <evant_> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29372#a29372 Can anyone tell me why that is failing to compile? Since it works with the pattern match above, I figure the Var constructor is actually in scope
04:01:52 <PeakerWork> e.g: Instead of http://hackage.haskell.org/packages/archive/enumerator/0.3.0.1/doc/html/Data-Enumerator.html#t%3AStep with data Step e a m b, you could have: data Step a m b   and just have the "e" and "b" as a sum type given in "b"
04:02:01 <byorgey> evant_: it's the type of evalVar it's complaining about
04:02:05 <PeakerWork> I keep wondering why Iteratee's interface is complicated to include error handling
04:02:12 <byorgey> evant_: shouldn't it be Env -> Exp -> Value ?
04:02:15 <zygoloid> DamienCassou: looks like you can unse unGen. it's the same apart from the argument order.
04:02:27 <evant_> byorgey: Well, Exp is defined like...
04:02:28 <zygoloid> DamienCassou: unGen :: Gen a -> Int -> StdGen -> a
04:02:51 <byorgey> evant_: if it were complaining about the Var in the pattern match it would have said 'DATA constructor not in scope'
04:03:05 <evant_> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29373#a29373
04:03:09 <evant_> Amongst others...
04:03:22 <evant_> Oh wait, hang on
04:03:29 <evant_> I'm meant to be passing the ident around, right
04:03:35 <evant_> So the type should be Env -> Id -> Value
04:03:36 <evant_> Right?
04:04:08 <byorgey> evant_: ah, indeed.  And then you don't need to pattern-match on Var.
04:04:17 <evant_> byorgey: Duh, I'm a noob
04:04:20 <evant_> Thanks for the help ;)
04:04:31 <evant_> Obviously this is an assignment ;D
04:04:32 <byorgey> evant_: but do you see what the problem was with your code?  You were using Var as if it were a type
04:04:44 <byorgey> evant_: you wrote evalVar :: Env -> Var -> Value
04:04:46 <evant_> Yeah, Var is a constructor of the Exp type
04:04:50 <byorgey> right
04:04:53 <evant_> So the type is Exp
04:05:11 <byorgey> ok, just making sure you understood what the error message was saying =)
04:05:43 <zygoloid> PeakerWork: i guess for convenience? apart from the leftover stream, it does look like Step e a m b could be changed to Step a (ErrorT e m) b
04:06:00 <byorgey> evant_: out of curiosity, where are you taking a Haskell class?
04:06:15 <evant_> byorgey: Sydney, au
04:06:47 <evant_> It's not really a haskell class, it's more about syntax of programming languages, just the assignments are in haskell, we cover c & java as well
04:06:54 <byorgey> evant_: ah, cool
04:07:10 <PeakerWork> zygoloid: I think either solution would be great, because sticking more features directly in there is non-compositional, and 4 type args is a little much
04:07:26 <DamienCassou> zygoloid: looks like it works, thank you
04:08:56 <ManateeLazyCat> Hi all. :)
04:18:11 <wjt> I'm playing around with ensuring that trees are acyclic in their type. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29376#a29376 is the best I have so far. It works, but I can't have homogenous lists of my acyclic trees (which I guess is pretty much unavoidable?), and it's not very pretty. Could I do better?
04:26:02 <evant_> Can some explain the ! syntax used here? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29377#a29377
04:26:51 <ManateeLazyCat> evant_: Not lazy.
04:27:53 <Jafet> wjt: not even a HList?
04:28:03 <wjt> Jafet: oh, I could make an HList of them I'm sure
04:28:25 <wjt> evant_: see §6.3 in http://www.haskell.org/tutorial/moretypes.html
04:28:45 <Jafet> wjt: since your tree "type" is a collection of types, you can't use [], yeah
04:28:48 <evant_> Cool, thanks
04:29:02 <Jafet> Or maybe you can, with gadt or some such
04:29:13 <wjt> Jafet: I could box 'em
04:31:53 <Jafet> Then you can make unlimited size acyclic trees, I expect
04:33:59 <wjt> i think my Haskell break is over. Back to C. :(
04:34:23 <Ke> C is just awesome
04:38:28 <Jafet> Is that like smoking breaks
05:01:05 <DamienCassou> why isn't hlint in the platform?
05:02:25 <triyo> Reading RWH Chapter 14, there is an example that shows a way to pass around multiple state values. I am trying to write runCountedRando for the getCountedRandom. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29381#a29381
05:03:19 <triyo> my version of runCountedRandom is incorrect. Could someone please let me know what I'm doing wrong
05:04:49 <triyo> I know that getCountedRandom handles the getting/putting of the state.
05:04:52 <Botje> what's incorrect about it?
05:05:22 <triyo> Botje: well if I run it in REPL, I get the same random number
05:06:39 <luite> triyo: that's called a uniform probability distribution ;)
05:07:13 <Botje> getStdGen doesn't change 
05:07:21 <luite> (don't use that as the definition if you have a stats exam)
05:07:43 <triyo> luite: what happened to the pseudorandom values? :)
05:08:54 <Botje> triyo: if you want a different gen every time, use something like let (old, new) = split gen; setStdGen new; return old
05:10:10 <luite> or use MonadRandom or something similar
05:12:18 <triyo> Botje: this example works: http://book.realworldhaskell.org/read/monads.html#Random.hs:runTwoRandoms
05:13:07 <luite> that one replaces the global stdgen after using it
05:13:35 <triyo> oh, right, I see what you mean
05:14:39 <triyo> now I need to adjust that to store not the StdGen but rather a custom data type CountedRandom
05:15:27 <luite> triyo: nah you probably still want to do a setStdGen newState
05:16:15 <luite> triyo: there is no way to store the count globally outside that monadic computation
05:17:59 <DamienCassou> is there something simple than: "  snd `fmap` (find (\v -> fst v == testName) values) " where 'values' is a list of pairs and 'testName' is a String ?
05:18:22 <DamienCassou> in fact, I just want something like a hashmap
05:18:38 <triyo> luite: in the book, http://book.realworldhaskell.org/read/monads.html#id644470
05:18:58 <Botje> DamienCassou: .. like Data.Map ? :)
05:18:59 <triyo> there is no runState example
05:19:04 <Botje> DamienCassou: also, look at the lookup function
05:19:10 <Botje> :t lookup
05:19:11 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
05:19:50 <triyo> luite: hence I was trying to build an example that uses runState to run the example
05:20:35 <luite> triyo: ah, do you need the final count afterwards, or is it ok to just discard it?
05:21:01 <DamienCassou> Botje: thank you, I'm having a look
05:21:34 <triyo> well the idea is to carry my Data Type as the State value in place of a simple StdGen on its own
05:22:41 <Botje> triyo: why not wrap that up yourself?
05:22:54 <Botje> triyo: have an IORef that records the last state generated
05:23:25 <Botje> and then runRandomCounter only needs a RandomCounter a argument
05:23:27 <luite> triyo: yes, but this is about the run function. have you seen the different "run" functions for the regular state monad? (evalState, runState, execState)
05:23:33 <Botje> of course ,then runRandomCounter becomes IO ...
05:24:08 <luite> triyo: they discard part of the result (you could write the last two in terms of the first)
05:24:24 <luite> Botje: bah don't suggest that! :p
05:24:48 <luite> anyway, an IORef still isn't really global since you'd have to get the ref from somewhere
05:25:08 <luite> so it wouldn't work like the getStdGen/setStdGen
05:26:45 <luite> triyo: but the type of your runCountedRandom is probably wrong
05:27:14 <luite> triyo: it's ok that its IO, but you'd probably want to make that function run a monadic computation
05:27:23 <luite> triyo: try making one with this type:
05:27:44 <luite> runCountedRandom :: CRState a -> IO (Int, a)
05:28:50 <triyo> luite: right, so its monadic, and the body needs to change to what now?
05:31:19 <luite> triyo: I've added a revision
05:31:26 <triyo> cool thx
05:32:04 <luite> I have only proved it correct, not tried it ;)
05:32:27 <zygoloid> > let bisect as = go as as where go (_:_:cs) (a:as) = first (a:) (go cs as); go _ ts = ([], ts) in bisect "Hello world"
05:32:28 <lambdabot>   ("Hello"," world")
05:32:30 <luite> oh and I'm sure it's wrong :p
05:32:33 <luite> sorry hang on
05:32:39 <luite> I'll update it
05:32:45 <triyo> ok
05:32:56 <luite> forgot to change something
05:33:21 <tafryn> What is the fixity of :: ?
05:34:02 <DamienCassou> is there any difference between Map.assocs and Map.toList
05:34:17 <luite> triyo: updated again
05:35:13 <luite> hmm, I'm pretty sure it's still wrong
05:35:20 <zygoloid> tafryn: in effect it acts something like infix -1
05:35:33 <luite> hmm no it might be right
05:36:04 <zygoloid> @type undefined :: a :: *
05:36:05 <lambdabot> parse error on input `::'
05:36:06 <zygoloid> @type undefined :: (a :: *)
05:36:07 <lambdabot> forall a. a
05:36:08 <zygoloid> @type (undefined :: a) :: *
05:36:09 <lambdabot> parse error on input `*'
05:36:32 <luite> triyo: does it work? and if yes, do you understand how and why? :)
05:37:12 <zygoloid> tafryn: but it's not an operator, so it doesn't really have a fixity in the traditional sense
05:38:26 <triyo> luite: to run it, CRState a is expected right?
05:39:12 <tafryn> zygoloid: So in "1 / 2 :: Float" is the whole expression cast as a Float, or is the denominator cast as a Float?
05:39:59 <triyo> luite: or even better question, how do I run it?
05:40:15 <ziman> the whole expression; (::) has the lowest "priority".
05:40:27 <ziman> (although it's not a regular operator)
05:41:13 <luite> triyo: a simple one that uses one random value:
05:41:24 <luite> triyo: runCountedRandom getCountedRandom
05:41:33 <luite> triyo: or one that takes two and adds them:
05:41:49 <luite> triyo: runCountedRandom (liftM2 (+) getCountedRandom getCountedRandom)
05:41:53 <triyo> ohh I seee
05:41:53 <triyo>  :)
05:42:08 <triyo> luite: now it all makes sense, thank you
05:42:09 <luite> triyo: you can see that the count is two in the second case
05:43:09 <zygoloid> tafryn: the whole expression is annotated as having type float. ::, in effect, binds more-or-less as loosely as possible
05:43:16 <luite> triyo: this pattern is what you usually see, you have all kinds of different functions to build a single monadic computation. and then a "run" function to run that computation
05:43:35 <zygoloid> tafryn: it's expressed in terms of grammar rules though, so there are some special cases
05:44:10 <zygoloid> @type \x -> x + 1 :: Int
05:44:11 <lambdabot> Int -> Int
05:44:27 <luite> triyo: in this case your run function is in IO, but you could've also made something that takes an StdGen and returns the new StdGen, along with the final count and the result of your monadic computation
05:45:17 <luite> triyo: you don't really need to return the value product by getCountedRandom, or even the same type, for example
05:45:17 <zygoloid> tafryn: ^^ there's a special case; this parses as \x -> (x + 1 :: Int)
05:45:54 <zygoloid> tafryn: that comes from the grammar's metarule that lambdas and the bodies of case and let expressions go as far to the right as possible.
05:45:59 <triyo> luite: what does the *result* binding point to at the end of the computation if multiple randoms are performed like in case of two?
05:46:21 <triyo> I take it its the last one right?
05:47:23 <luite> triyo: yes, you can see that from the type of >>= by the way
05:47:30 <luite> triyo: so this must be the case in all monads
05:47:39 <luite> :t (>>=)
05:47:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:47:55 <triyo> oh, og course ...  m b
05:48:01 <triyo> *of
05:48:54 <triyo> luite: thanks very much for helping me get my head around State monad a bit more
05:50:29 <luite> triyo: what you could try next is make your own CRState monad, that doesn't just run the existing State monad, but is really its own type
05:50:55 <triyo> oh so make it more generic right?
05:50:58 <luite> triyo: that way, you could prevent users from getting access to the underlying state
05:51:28 <triyo> oh...oops I see what you mean
05:51:33 <luite> now they can still access the state by using get and put
05:51:42 <luite> instead of your own getCountedRandom
05:52:42 <triyo> I see what you mean.
05:53:45 <tafryn> zygoloid: I see. Thanks.
05:54:33 <triyo> One more question. The State monad seems to have been designed to work well with simple simple data. IORefs seems to be better suited when dealing with complex type of data
05:55:21 <Botje> an IORef is a mutable variable
05:55:31 <Botje> both suffer/benefit from laziness
05:55:32 <luite> triyo: because you can have more than one IORef?
05:55:53 <luite> because other than that, they can hold the same data
05:56:09 * zygoloid is very surprised to see there's no haskell' proposal for TypeOperators. seems like such an obvious extension...
05:56:33 <triyo> luite: dealing with nested data for instance
05:56:55 <luite> triyo: could you give an example
05:57:32 <FunctorSalad_> zygoloid: remind me what they add again?
05:57:44 <FunctorSalad_> something beyond infix ctors, wasn't it...
05:58:14 <zygoloid> FunctorSalad_: operators starting with : as type names, operators not starting with : as type variable names
05:58:25 <luite> triyo: there is some "in between" monad by the way, ST, which gives you STRef, and many mutable types use this monad. That's what you'd use if you need to do some high performance things that don't use IO (in situations where data structures like IntMap just don't cut it)
05:58:48 <zygoloid> FunctorSalad_: also the ability to use `Foo` as an infix type operator
05:59:36 <triyo> luite: oh so there is a STRef :), reading docs...
05:59:41 <FunctorSalad_> zygoloid: hmm right, apprently you need the extension even for the first
05:59:49 <FunctorSalad_> ('starting with :')
06:00:08 <FunctorSalad_> it was just infix value ctors that are always there apparently
06:00:41 <zygoloid> yeah, it's a weird and unnecessary wart that type operators aren't allowed in haskell'10
06:00:45 <luite> triyo: ST is a bit tricky though because of the way it prevents its state from leaking out (you can't use one STRef or mutable ST array outside its own ST computation)
06:01:14 <zygoloid> also adding TypeOperators would fix ghc bug#3766 rather nicely
06:01:41 <triyo> so cant use state variables within IO monad?
06:01:53 <triyo> Guess thats where IORef steps in
06:02:06 <zygoloid> FunctorSalad_: oh, TypeOperators turns on one more thing: type class operators
06:02:12 <luite> triyo: so you will probably want to look at the "pure" monads first, monads like State, Reader, Writer, Either, Maybe, [], that you can all implement completely in regular haskell
06:02:26 <FunctorSalad_> zygoloid: hmm I had some problem with these :)
06:02:28 <luite> triyo: which you can't do with ST (and of course with IO)
06:02:45 <FunctorSalad_> at some point I had to use prefix notation; I don't remember where
06:02:58 <FunctorSalad_> (instance/class/context)
06:03:46 <luite> triyo: there are some functions to convert between STRef and IORef, but you probably shouldn't need them (and they're unssafe)
06:03:54 <triyo> luite: Pure monads is exactly been my starting point. I am just trying to familiarize my self with non-pure too in order to know when to pick the best fit.
06:04:32 <FunctorSalad_> unsafeSTtoIO
06:04:39 <luite> triyo: you'll probably pick ST when you need to use some mutable array that uses it
06:04:44 <FunctorSalad_> unsafeSTToIO
06:05:14 <FunctorSalad_> (why is this unsafe? thought IO is already as unsafe as it gets)
06:05:31 <zygoloid> @hoogle stToIO
06:05:31 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
06:05:31 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
06:05:31 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
06:05:48 <zygoloid> ^^ it's only unsafe if you don't have control over 's'
06:05:59 <FunctorSalad_> but still?
06:06:22 <FunctorSalad_> thought the 's' mechanism is only to make runST safe
06:06:31 <FunctorSalad_> (which has *pure* return type)
06:06:45 <zygoloid> a runST'd computation can leak a reference if you use unsafeSTToIO
06:07:04 <FunctorSalad_> @type runST
06:07:05 <lambdabot> forall a. (forall s. ST s a) -> a
06:07:55 <zygoloid> i'm not sure why even that'd be a problem though, since there's no stRefToIORef
06:08:32 <FunctorSalad_> maybe that you could use them in a new ST thread
06:08:47 <p_l> btw, for people interested in porting haskell to Android... has anyone considered binding to libdvm.so in order to connect back to Dalvik VM?
06:08:48 <zygoloid> i don't think you can -- the 's' parameter wouldn't match
06:09:02 <FunctorSalad_> (don't know why that's a problem in turn since you could have done something similar in IO by making an IORef in the first place)
06:09:17 <FunctorSalad_> (instead of an STRef)
06:23:32 <kamatsu> so, still wondering what is the most production ready and easy to use web framework in haskell
06:23:44 <kamatsu> I really like the look of Yesod but I'm wondering if it's not ready for prime time yet.
06:30:15 <sm> kamatsu: it's the readiest imho
06:30:32 <sm> the essentials are there
06:30:59 <sm> as to what's essential, YMMV of course
06:35:46 <kamatsu> sm: okay, what about storage?
06:35:56 <kamatsu> sm: afaik Persistent isn't really ready
06:36:21 <sm> oh, how come
06:36:40 <kamatsu> only supports sqlite or postgresql, neither of which are available
06:36:47 <kamatsu> where i have to deploy this
06:37:21 <kamatsu> well, sqlite is available but probably not ideal
06:37:51 <sm> then you'll need one of the other libs from hackage databases section
06:38:08 <kamatsu> easy to plug into yesod? I don't have much experience with it
06:38:27 <kamatsu> I could also perhaps use loli and hack, I have used them in the past.
06:38:28 <sm> I think yesod is pretty much db agnostic
06:38:32 * sm too
06:38:40 <sm> but they're not actively maintained afaik
06:38:57 <sm> the developer has moved on to other projects. While snoyman is using yesod in his day job
06:44:06 * sm notes some of the framework devs and users also hang out in #haskell-web
06:44:35 <osaunders> Is there a way of defining a function that would allow you to partially apply any particular parameter via a numbered index?
06:45:18 <KitB> osaunders: Do I know you from somewhere? ;)
06:45:31 <kamatsu> osaunders: now that I think about it, perhaps.
06:48:39 <osaunders> kamatsu: Yeah?
06:50:01 <jmcarthur> hmm
06:51:31 <zygoloid> osaunders: pap1 f x = f x; pap2 f x y = f y x; pap3 f x y z = f y z x; ...
06:52:17 <zygoloid> (note that pap1 == id, pap2 == flip)
06:59:22 <yrlnry> Is there a tool where I can put in a type signature and have it tell me standard functions with that type signature?  For example, I might put in (a,b) -> b and have it tell me "snd".
06:59:46 <vanadium> hoogle
06:59:57 <vanadium> http://haskell.org/hoogle/?hoogle=%28a%2C+b%29+-%3E+b
07:00:20 <yrlnry> perfect, thanks!
07:00:30 <vanadium> If non-standard functions are okay
07:00:34 <vanadium> @djinn (a, b) -> b
07:00:35 <lambdabot> f (_, a) = a
07:01:00 <yrlnry> I know about djinn, it's not what I want here.
07:01:21 <yrlnry> I can easily write snd myself, but if it's standard, I want to use th standard 'snd', and not look like a tyro by writing it myself.
07:01:22 <ziman> @. pl djinn (a,b)->b
07:01:22 <lambdabot> f = snd
07:01:30 <yrlnry> Hm.
07:01:34 <vanadium> nice
07:01:47 <copumpkin> @@ @pl @djinn (a, b) -> b
07:01:47 <lambdabot>  f = snd
07:01:51 <EvanR-work> by using the word tyro you are automatically not one
07:01:56 <copumpkin> (better syntax for that, imo)
07:02:05 <yrlnry> I didn't say I was a tyro, I said I didn't want to look like one.
07:02:09 <EvanR-work> lol
07:02:26 <quicksilver> copumpkin: why is @@ better syntax than @. ?
07:02:43 <EvanR-work> is this the preferreed way to say "NOOB" now xD
07:02:57 <kamatsu> @djinn (a,b) -> (b,a)
07:02:57 <lambdabot> f (a, b) = (b, a)
07:02:58 <p_l> kamatsu: what's is the place if postgres is unavailable?
07:03:18 <copumpkin> quicksilver: I remember some cases that @. didn't seem to pick up on? the syntax seems a bit more ambiguous, to me at least
07:03:46 <kamatsu> p_l: can't actually say, I'll be communicating with a proprietary database thing over http
07:03:47 <copumpkin> maybe not :)
07:04:14 <yrlnry> I did   http://www.haskell.org/hoogle/?hoogle=(a,b)+->+(b,a)   and it reported a lot of stuff that does not seem to me to match.
07:04:30 <kamatsu> p_l: i'm investigating whether I should write a simple library for this database thing or write a full blown persistent backend for it
07:04:41 <kamatsu> @djinn (a,b) -> (Int, b)
07:04:42 <lambdabot> Error: Undefined type Int
07:04:42 <copumpkin> yrlnry: you sometimes need to deal with the fact that the function might not exist :P
07:04:48 <copumpkin> :t snd &&& fst
07:04:49 <lambdabot> forall a c. (a, c) -> (c, a)
07:04:50 <zygoloid> @@ @pl @djinn @type id
07:04:51 <lambdabot>  f = id
07:04:55 <zygoloid> ^^ that sort of thing is harder with @. iirc
07:05:00 <copumpkin> :t uncurry flip
07:05:01 <lambdabot> forall (f :: * -> *) b b1. (Functor f) => (f (b -> b1), b) -> f b1
07:05:02 <yrlnry> That's quite fine, but I want to know why hoogle reported any of those things.
07:05:03 <sm> I always have trouble implementing the simple "catch all errors" pattern. Why do I keep getting the error at http://gist.github.com/545552 ?
07:05:08 <copumpkin> whoops
07:05:27 <quicksilver> sm: \SomeException e ->
07:05:31 <zygoloid> @. pl . djinn type id
07:05:32 <p_l> kamatsu: ah
07:05:32 <lambdabot> f = id
07:05:35 <quicksilver> sm: but, that's an anti-pattern not a pattern, of course :)
07:05:36 <zygoloid> ^^ not nice syntax
07:05:52 <sm> it's a pattern for debugging and learning, at least
07:05:55 <yrlnry> Each one is more puzzling than the last.
07:06:03 <sm> quicksilver: what kind of syntax is that ? Is SomeException a constructor ?
07:06:06 <quicksilver> yes.
07:06:13 <quicksilver> read the extensible exceptions paper
07:06:22 <quicksilver> that's the compromise they adopted, for reasons documented there :)
07:06:45 <quicksilver> showerror (SomeException e) = .... in your case
07:07:16 <sm> thank you.. trying to get that working
07:07:21 <araujo> what would be a good name for the arguments that belong to a partial function?
07:08:04 <yrlnry> what is "yhjulwwiefzojcbxybbruweejw"?
07:08:11 <daxim> what is the ghc command to show the default library path prefix?  I expect to get a simple result such as /usr/lib64/ghc-6.12.3
07:09:07 <zygoloid> yrlnry: it's looking for functions of type (,)1 a1 b1 -> (,)2 b2 a2, with a1=a2, b1=b2, (,)1=(,)2=(,). it's relaxing some of those equalities to find matches.
07:09:09 <sm> now it compiles but (new question) why does it still die on the first "hGetContents: invalid argument (Invalid or incomplete multibyte or wide character" error ?
07:09:43 <yrlnry> zygoloid:  aha!  Thanks.
07:09:50 <quicksilver> sm: because hGetContents is broken
07:09:57 <sm> ack :/
07:10:02 <quicksilver> sm: it uses the unsound and misguided lazy IO
07:10:02 <yrlnry> So when it can't find what I asked for, it's producing stuff that isn't what I asked for, in hopes that it's what I wanted anyway.
07:10:09 <quicksilver> sm: (poorly named, at that)
07:10:11 <zygoloid> it's a little disappointing that hoogle doesn't know that (a,b) -> c is similar to a -> b -> c. if it knew that it'd presumably find (,) :: a -> b -> (a,b)
07:10:16 <quicksilver> sm: which makes it impossible to signal exceptions mid-stream.
07:10:20 <sm> so those errors are currently uncatchable ?
07:10:28 <yrlnry> "Sorry, sir, we're all out of the chicken.  perhaps you'd prefer the Trans-Siberian Railroad tonight?"
07:10:31 <quicksilver> that's not the way I'd phrase it, sm
07:10:40 <quicksilver> I'd say hGetContents is so buggy as to be useless.
07:10:56 <zygoloid> huh. it doesn't find (,) given a -> b -> (a,b) even :(
07:11:00 <quicksilver> if you don't use it, but use something better, the errors are perfectly catchable.
07:11:21 <sm> ok.. so this error is not catchable when using hGetContents ?
07:11:21 <quicksilver> it's not a problem with the errors, per se, just with interleaved IO.
07:11:24 <quicksilver> yup
07:11:37 <quicksilver> no error is catchable using hGetContents
07:11:46 <quicksilver> although some errors get turned into EOF which you can observe
07:12:39 <sm> no error is catchable using hGetContents is definitely not clear from http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/System-IO.html#v:hGetContents
07:13:13 <sm> at least.. that page says "discarded".. maybe it should day "program may die ?"
07:16:44 <sm> so.. my goal is to safely attempt to read a file whose encoding may not match current system locale, ie report an error rather than dying. How can I do that ?
07:16:51 <yrlnry> Why does the Hoogle logo have an upside-down 'y' in the middle?
07:16:57 <yrlnry> Sorry, j/k.
07:17:27 <Ke> lambda
07:18:26 <vanadium> Last week, I saw a folding chair that looked pretty much like a lambda, from the side, ignoring the part you actually sit on. My mind was blown.
07:20:04 <arw_> http://www.ikea.com/us/en/catalog/products/30115066 <- something like that?
07:20:29 <KitB> Wadler has a superman suit with a lambda instead of an s
07:20:32 <KitB> It's amazing.
07:22:03 <vanadium> arw_: Yeah, but it also had the right curves like lambdas in fancy fonts!
07:22:11 <sm> anyone ? I'm about to think ghc 6.12 I/O really is broken and be sad
07:22:23 <arw_> vanadium: cool
07:22:33 <vanadium> sm: Uh, try reading it into a bytestring and manually decode it?
07:22:45 <sm> ah, of course. Thank you
07:22:54 <vanadium> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString-Lazy.html#v:readFile at a guess
07:23:13 <vanadium> Oh, it has a hgetcontents too.
07:25:25 <sm> will try that later.. thanks all!
07:29:24 <roconnor> @seen mjsottile
07:29:24 <preflex>  Sorry, I haven't seen mjsottile
07:29:24 <lambdabot> Unknown command, try @list
07:30:34 <milosh> Quick question: I see that Control.Monad.State is no longer in the GHC base libraries (but is in both mtl and monads-tf). Does this mean that its use is now discouraged and there's a better "canonical" solution that subsumes it, or simply that I have to choose which package to import it from?
07:35:27 <fasta> milosh, no.
07:35:52 <fasta> milosh, GHC ships less libraries so that people cannot open bugs for it in GHC. 
07:36:40 <fasta> It is quite sensible that people do what they are interested in. 
07:36:54 <milosh> fasta: Thanks. The only issue is that it is now in 2 packages, so I have to use package imports.
07:36:58 <EvanR-work> i use mtl
07:37:02 <geheimdienst> i thought everybody uses mtl, with monads-tf being a future replacement or something
07:37:07 <fasta> milosh, no, you don't have to. 
07:37:26 <fasta> milosh, but I do like that solution, although some never identified people, do not. 
07:37:47 <milosh> fasta, otherwise I get clashes between the two packages
07:37:55 <milosh> but that's not a serious problem
07:38:02 <fasta> milosh, no, you can also use ghc flags for that. 
07:38:17 <fasta> milosh, you don't have to use the extension.
07:39:16 <geheimdienst> milosh, there's 2 alternatives against the clashes: use "ghc-pkg hide" on monads-tf, or run cabal init on your project (it's really quick and painless) and the use "cabal build" to build your project
07:40:19 <milosh> geheimdienst: Thanks, will give it a try.
07:42:59 * hackagebot amqp 0.1.2 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.1.2 (HolgerReinhardt)
07:44:57 <ScaredEcat> @vixen Is it weird if I masturbate to Haskell repositories instead of porn?
07:44:57 <lambdabot> Ooh, functional programmers are so hot!
07:48:35 <dcoutts> ScaredEcat arrives, lowers the tone and buggers off...
07:56:24 <aristid> dcoutts: and in indirect consequence, i learned a new verb.
07:57:03 * dcoutts doesn't dare to guess which one
07:57:08 <aristid> the dictionary says it's "vulgar"
07:57:25 <aristid> of course i mean "bugger off"
07:57:28 <aristid> :P
07:57:29 <dcoutts> :-)
07:58:13 <dcoutts> aristid: there's a fine tradition in British English of buggering off :-)
07:58:21 <dcoutts> c.f. Monte Python
07:58:42 <geheimdienst> also cf. terry pratchett!
07:59:07 <aristid> i regret having read most of the pratchett books translated :D
07:59:15 <dcoutts> (erm, spelling, Monty Python)
08:09:59 <evant_> can you extend a data type once it's already been declared? ie Foo = x | y
08:10:06 <evant_> Then later on add Foo &= z
08:10:08 <evant_> or something
08:10:25 <EvanR-work> no haskell is static like that
08:10:42 <EvanR-work> i take &= to mean a dynamic update to the datatype
08:12:29 <evant_> Yeah
08:12:39 <EvanR-work> no can do
08:12:44 <byorgey> evant_: no, data types are "closed".  In contrast, type classes are "open"; you can always add new type class instances.
08:12:46 <evant_> Ok, thanks
08:13:18 <byorgey> so there may be a way to do what you want using type classes; but more likely you should rethink your design.  it depends what you are tying to do.
08:13:32 <EvanR-work> the php way of random assemblying strings and numbers into nested arrays does not provide much stability, readability, maintainability, sanity....
08:15:25 <evant_> byorgey: Assignment ;D
08:15:49 <byorgey> evant_: right, then stick to the basics =)
08:16:10 <aristid> yeah, only up to 5 ghc extensions
08:43:45 <jmcarthur> is there a more formal name for the binary operation which is commonly referred to as "splitting the difference"?
08:44:00 <jmcarthur> it's also the same thing as taking the mean of exactly two samples
08:44:18 <roconnor> averaging?
08:44:40 <jmcarthur> it's just that i normally think of "average" as being a function you would apply to a collection
08:45:26 <aristid> maybe avg :: a -> a -> a and average :: [a] -> a, similar to min/minimum, max/maximum...
08:45:31 <jmcarthur> hmm
08:45:45 <aristid> :t avg
08:45:46 <lambdabot> Not in scope: `avg'
08:45:59 <jmcarthur> except that avg and average don't have quite the same relationship as min/max and minimum/maximum
08:46:16 <jmcarthur> folding avg over a list doesn't result in average, for example
08:46:24 <quicksilver> I would just call it 'mean'
08:46:33 <quicksilver> in a formal/mathmatical context
08:46:34 <Zao> Now that's mean :D
08:46:47 <quicksilver> if you use it in a context where it's obviously a binary operator it's still 'mean'
08:46:50 <quicksilver> it's just mean-of-two
08:46:52 <jmcarthur> mmkay
08:46:59 <jmcarthur> i was just wondering if there was a more specific term to use
08:47:59 <jmcarthur> because in this case i am using it explicitly as a "split the difference" operation rather than as a "find some number that is close to both of these numbers" operation
08:48:07 * jmcarthur goes with mean
08:48:40 <jmcarthur> the "betweenness" is what i'm after. maybe i could just call it between
08:48:49 <aristid> i wonder if there is something fold-like to elegantly express the average of lists
08:49:16 <jmcarthur> in fact, i don't even care if the result is exactly between the two numbers. it could be closer to one than the other and still satisfy the spec
08:50:43 <Zao> > let mean'o'2 = (/2) . (+) in mean'o'2 42 3
08:50:44 <lambdabot>   22.5
08:50:55 <dh__> aristid: what about a point free version of average of list
08:51:33 <dh__> > foldl + 0 [1,2,3]
08:51:34 <lambdabot>   Overlapping instances for GHC.Show.Show
08:51:34 <lambdabot>                              ((a ->...
08:51:43 <dh__> :t foldl
08:51:44 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:51:53 <dh__> foldl (+) 0 [1,2,3]
08:52:17 <dh__> > foldl (+) 0 [1,2,3]
08:52:18 <lambdabot>   6
08:53:00 <dh__> foldl ( \x-> x+1) 0 [1,2,3]
08:53:18 <dh__> > foldl (\x -> x +1 ) 0 [1,2,3]
08:53:18 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
08:53:33 <aristid> > let a = [4,5,0] in map (uncurry (/)) . tail $ zip (scanl (+) 0 a) [0..]
08:53:34 <lambdabot>   [4.0,4.5,3.0]
08:54:37 <dh__> > foldl (\x y -> x+1) 0 [1,2,3]
08:54:38 <lambdabot>   3
08:55:01 <dh__> foldl ( (+) &&& (\x y -> x+1) ) 0 [1,2,3]
08:55:19 <dh__> > foldl ( (+) &&& (\x y -> x+1) ) 0 [1,2,3]
08:55:20 <lambdabot>   Couldn't match expected type `b -> a'
08:55:20 <lambdabot>         against inferred type `(a -> ...
08:55:28 * hackagebot attoparsec-enumerator 0.1.0.3 - Convert an Attoparsec parser into an iteratee  http://hackage.haskell.org/package/attoparsec-enumerator-0.1.0.3 (JohnMillikin)
08:56:19 <dh__> > foldl ( \x y -> (x+y, x+1)) 0 [1,2,3]
08:56:20 <lambdabot>   Occurs check: cannot construct the infinite type: b = (b, b)
08:56:46 <hpc> > map ( \x y -> (x+y, x+1)) [1,2,3]
08:56:47 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> (a, a))
08:56:47 <lambdabot>    arising from a use...
08:57:02 <hpc> > map ( \x -> (x+y, x+1)) [1,2,3]
08:57:02 <lambdabot>   [(1 + y,1 + 1),(2 + y,2 + 1),(3 + y,3 + 1)]
08:57:24 <hpc> > zip ( \x y -> (x+y, x+1)) [1,2,3] [3,2,1]
08:57:25 <lambdabot>   The lambda expression `\ x y -> ...' has two arguments,
08:57:25 <lambdabot>  but its type `[a]'...
08:57:47 <dh__> I need to foldl 2 binary operator onto a list
09:00:03 <dh__> foldl (\(x,y) -> (x+y, x+1)) (0,0) [1,2,3]
09:00:14 <dh__> > foldl (\(x,y) -> (x+y, x+1)) (0,0) [1,2,3]
09:00:15 <lambdabot>   Couldn't match expected type `b -> (t, t)'
09:00:15 <lambdabot>         against inferred type `(...
09:01:10 <dh__> :t foldl
09:01:11 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:02:05 <dh__> > foldl ( \(x0, x1) y -> (x0 +y, x1 + 1) ) (0,0) [1,2,3]
09:02:06 <lambdabot>   (6,3)
09:02:40 <dh__> > foldl ( \(x0, x1) y -> (x0 +y, x1 + 1) ) (0,0)  >>> uncurry (/)  [1,2,3] 
09:02:40 <lambdabot>   Couldn't match expected type `(a, a)' against inferred type `[a1]'
09:02:57 <dh__> >  ( foldl ( \(x0, x1) y -> (x0 +y, x1 + 1) ) (0,0)  >>> uncurry (/)  )  [1,2,3]
09:02:58 <lambdabot>   2.0
09:03:12 <stepcut> does anyone else find that they often need to refactor OO code far more often than FP code ?
09:03:35 * roconnor doesn't write OO code
09:03:37 <dh__> OO code is unstable, 
09:03:53 <p_l> stepcut: depends on what kind of OO you're using...
09:04:03 <dh__> It's very hard to reuse any OO code.
09:04:06 <evant_> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29387#a29387 <- Why would this be saying that the constructor Id is not in scope?
09:04:15 <aristid> "OO" is not exactly well-defined
09:04:21 <p_l> given that both C++ and Java use crazy encapsulation oriented pseudo-OOP, they require *lots* of refactoring
09:04:27 <stepcut> p_l: right now, javascript for the web and java for android
09:04:56 <FunctorSalad_> definition fight!
09:05:00 <aristid> stepcut: but one thing i did find... when i was forced to use UML once, i found it not nearly expressive enough
09:05:02 <dh__> aristid: how about mean = ( foldl (\(a,b) y -> (a+y , b + 1)) (0,0) >>> uncurry (/) )
09:05:15 <p_l> stepcut: I avoid directly writing OOP in JS, as for Java... Java uses the broken OOP style, IMHO
09:05:20 <Zao> evant_: Did you mean `import' with a lowercase i?
09:05:28 <aristid> dh__: does that even work?
09:05:30 <stepcut> I have been primarily a FP programmer for the last 10 years. I never really understood the refactoring craze until I was forced to use some of these OO languages
09:05:43 <evant_> Zao: Yeah, that was a typo
09:06:06 <p_l> stepcut: when I want to use a real object system, I use CLOS, which is oriented around generic functions and protocols instead of black-box classes
09:06:11 <FunctorSalad_> stepcut: interesting... what property of fp langs would you say is to credit?
09:06:16 <stepcut> it seems to me that FP requires you to think about things in a much smaller scope, and requires less foresight. And the division about where code belongs is much clearer, and less import..
09:06:28 <p_l> though Ruby/Smalltalk style OOP is also much cleaner to use than Java
09:06:44 <aristid> p_l: should be possible to simulate CLOS in js
09:06:46 <dh__> > let mean = ( foldl (\ (a,b) c ->(a+b, b+1) ) (0, 0) ) >>> uncurry (/)  in mean [1,2,3,4]
09:06:47 <lambdabot>   1.5
09:07:01 <aristid> dh__: why >>> instead of (.)?
09:07:22 <stepcut> less import*ant*
09:07:27 <Deewiant> evant_: You export only the type Id from Ident; if you want to export the constructor as well you should say Id(Id) in the export list (or Id(..) to export all constructors, which is equivalent to Id(Id) in this case)
09:07:32 <p_l> FunctorSalad_: I'd say the orientation on *verb* (aka "wtf I'm actually doing") than *noun* (aka "crafting blackboxes that encapsulate... encapsulate just what, actually?")
09:07:40 <dh__> aristid: >>> from array notation, I prefer it , because I think in pipe style. 
09:08:03 <aristid> dh__: reverse the pipe direction, and you get (.) :)
09:08:05 <dh__> let mean = ( foldl (\ (a,b) c ->(a+b, b+1) ) (0, 0) ) >>> uncurry (/)  in mean [1]
09:08:15 <p_l> when I write java, I catch myself writing lots of static final methods
09:08:18 <dh__> > let mean = ( foldl (\ (a,b) c ->(a+b, b+1) ) (0, 0) ) >>> uncurry (/)  in mean [1]
09:08:19 <lambdabot>   0.0
09:08:39 <dh__> lol, what happened ? 
09:08:53 <FunctorSalad_> p_l: I'm starting to think that it's also something about being able to parameterize out arbitrary behaviour by a transformation that's syntactic to do, but semantically checked and sound...
09:08:57 <dh__> > let mean = ( foldl (\ (a,b) c ->(a+b, b+1) ) (0, 0) )   in mean [1,2,3,4]
09:08:58 <lambdabot>   (6,4)
09:09:27 <p_l> FunctorSalad_: btw, have you used CLOS?
09:09:33 <dh__> let mean = ( foldl (\ (a,b) c ->(a+b, b+1) ) (0, 0) )  in mean [1]
09:09:39 <dh__> > let mean = ( foldl (\ (a,b) c ->(a+b, b+1) ) (0, 0) )  in mean [1,2,3,4]
09:09:40 <FunctorSalad_> p_l: e.g.: f x = foo (blah x) + 3 * x   ----->      general_f foo x = foo (blah x) + 3 * x
09:09:40 <lambdabot>   (6,4)
09:09:41 <FunctorSalad_> :)
09:09:45 <aristid> dh__: a+c instead of a+b i guess
09:10:00 <dh__> > let mean = ( foldl (\ (a,b) c ->(a+c, b+1) ) (0, 0) )  in mean [1,2,3,4]
09:10:00 <lambdabot>   (10,4)
09:10:10 <stepcut> and those claims about dynamic typing being better for prototyping seem utterly false. I keep forgetting what my objects look like, and when I change things, I have to try to remember everything that is affected, and that usually ends up being done via tedious debugging of runtime errors. :(
09:10:17 <dh__> let mean = ( foldl (\ (a,b) c ->(a+b, b+1) ) (0, 0) ) >>> uncurry (/)   in mean [1,2,3,4]
09:10:25 <FunctorSalad_> p_l: barely know the concepts, haven't really used it myself
09:10:35 <dh__> > et mean = ( foldl (\ (a,b) c ->(a+b, b+1) ) (0, 0) ) >>> uncurry (/)  in mean [1,2,3,4]
09:10:36 <lambdabot>   <no location info>: parse error on input `='
09:10:40 <ezyang> Dynamic typing makes writing certain kinds of programs easier. 
09:10:49 <dh__> > let mean = ( foldl (\ (a,b) c ->(a+c, b+1) ) (0, 0) ) >>> uncurry (/)  in mean [1,2,3,4]
09:10:49 <lambdabot>   2.5
09:10:57 <evant_> Deewiant: Thanks
09:10:58 <stepcut> ezyang: apparently not the ones I care about
09:10:58 <p_l> FunctorSalad_: anyway, it truly is different from Java style OOP, and when you start getting into MOP... oh booy
09:11:11 <fasta> ezyang, you mean the things that "require" eval?
09:11:18 <dh__> it's correct now . did I bothered anybody by put some many code here?
09:11:26 <fasta> stepcut, I completely agree, but mostly in team work. 
09:11:39 <ezyang> stepcut: Sure! 
09:11:42 <codolio> fasta: Also the heterogeneous lists that people always come asking for in here.
09:11:42 <fasta> stepcut, if you wrote all the code yourself, you can do pretty decent code, though. 
09:11:47 <aristid> > let mean xs = let a = last xs in (a+1)/a in mean [1..4]
09:11:48 <lambdabot>   1.25
09:11:50 <ezyang> fasta: Meh, eval is not really what I have in mind. 
09:11:53 <aristid> > let mean xs = let a = last xs in (a+1)/a in mean [1,2]
09:11:54 <lambdabot>   1.5
09:12:00 <aristid> > let mean xs = let a = last xs in (a+1)/a in mean [1..10]
09:12:01 <lambdabot>   1.1
09:12:11 * p_l found definitions related to "typing" much less defined than the ones related to OOP
09:12:16 <stepcut> fasta: team work sounds like a nightmare. But even by myself, it puts a lot more mental burnden on me to remember what I have done
09:12:30 <ezyang> I'm thinking of programs where the type system can't figure out what implementation to call. 
09:12:34 <fasta> codolio, I think it is sort of nice to actually know what is inside a given object I get from a stranger.
09:12:48 <ezyang> You can do this in Haskell, but it's really painful... 
09:13:04 <aristid> ezyang: you mean like existentials?
09:13:20 <ezyang> aristid: Along those lines. 
09:14:01 <p_l> if you take a grain of salt regarding its critique of type-systems (which seems to be mostly caused by fighting very unflexible ones), the "Objects Have Failed" got some good reasons against why languages like Java cause so much unwanted complexity :D
09:14:01 <dolio> fasta: Yeah, well, I think the right answer to "how do I get heterogeneous lists" is usually "you don't want them."
09:14:10 <dolio> People usually talk about existential types and stuff, though.
09:14:10 <aristid> ezyang: huh, but not exactly?
09:14:19 <Jafet> > iterate (\x -> 1 / (2 * fromIntegral (floor x) - x + 1) :: Rational) 1
09:14:20 <lambdabot>   [1 % 1,1 % 2,2 % 1,1 % 3,3 % 2,2 % 3,3 % 1,1 % 4,4 % 3,3 % 5,5 % 2,2 % 5,5 ...
09:14:25 <ezyang> Though, the metric I was going by was "I couldn't figure out how to make my program do the right thing" after spending three hours hacking on it. I probably could have made it work after six. 
09:14:27 <p_l> (my take is that Haskell has "advanced enough" type system to avoid the typing issues related in it)
09:14:34 <fasta> dolio, I think there are only artificial reasons (e.g. keeping software closed source) to warrant that. 
09:14:51 <fasta> dolio, technically it is almost always a bad solution, imho.
09:15:16 <fasta> I think the only inconvenient thing in Haskell is storing continuations in data structures.
09:15:22 <Saizan> does -xA also have a left adjoint?
09:15:39 <FunctorSalad_> fasta: how's it inconvenient?
09:15:59 <FunctorSalad_> (or wait... are you saying it's hard to do, or that haskell always does it and that this is inconv.)
09:16:04 <ezyang> aristid: It's probably identical, but I was trying to do something fancy. 
09:16:11 <fasta> FunctorSalad_, you need to use newtypes to make sure you don't get "infinite types"-error messages.
09:16:24 <aristid> ezyang: teh fanciness!
09:16:35 <FunctorSalad_> fasta: hmm sounds like type-level issues
09:16:47 <fasta> FunctorSalad_, types are a part of Haskell, no?
09:17:31 <FunctorSalad_> fasta: yes, I mean it would be easy to have a data structure containing continuations as ContT understands them
09:17:32 <dolio> FunctorSalad_: Continuations that escape the callCC (or whatever control operator) scope tend to lead to infinite types.
09:17:49 <FunctorSalad_> hmm
09:18:06 <fasta> Haskell also has no Sections, like Coq has. 
09:18:15 <dolio> Because you're returning a continuation which jumps to a place that returns a continuation that jumps to a place that ...
09:18:23 <fasta> dolio, exactly.
09:18:33 <FunctorSalad_> oh great, a *third* definition of section in the same general field ;)
09:18:45 <fasta> I would say Sections are a really good idea. 
09:19:28 <fasta> FunctorSalad_, and you can perform a section on someone.
09:19:29 <FunctorSalad_> (the other being "right inverse", "operator section")
09:19:31 <Saizan> what's a section in coq? something similar to an ML module?
09:19:41 <FunctorSalad_> fasta: that's a different field I think
09:20:13 <FunctorSalad_> Saizan: coq has ML-ish modules too, a section is a bit more lightweight in some sense I don't fully know
09:20:17 <fasta> Saizan, it basically allows you to bind names to repeated type structure for example, but you would actually have to use Coq to understand. 
09:21:20 <fasta> Saizan, when you define theorems that refer to objects in this local environment, after the section, only the stuff your functions actually depend on it generalized. 
09:21:22 <FunctorSalad_> you can do stuff like a 'Hypothesis H:1==0.' inside a section, and after ending the section everything defined in the section will have its type transformed with a leading '(1=0) -> ...'
09:21:28 <fasta> on it is*
09:21:28 <dolio> Sections are what let you introduce Variables, and then when you close the section, all the definitions are parameterized by the variables?
09:21:36 <FunctorSalad_> yes
09:21:42 <fasta> dolio, yes, only the ones it depend on.
09:21:52 <fasta> depends*
09:22:02 <dolio> Ah, okay.
09:22:18 <Saizan> see?, it wasn't hard to explain :)
09:22:26 <fasta> I think Coq is a step in the right direction, but it is still too manual. 
09:22:53 <FunctorSalad_> (and you can refer to the H in following code, obviously)
09:23:11 <FunctorSalad_> (inside the section)
09:23:31 <fasta> However, not using tactics to prove theorems/program is pretty much impossible.
09:23:39 <FunctorSalad_> IIRC the jargon for what happens at the end of a section is 'discharging the hypotheses'
09:23:45 <jmcarthur> i've not found a case where dynamic types would have been easier to work with than static types (in reference to somewhat earlier conversation)
09:24:30 <jmcarthur> well
09:25:09 <jmcarthur> i should clarify that i'm considering the space of all languages. i *have* found that a dynamically typed object-oriented language can be easier to work with sometimes than a statically typed object-oriented language
09:25:53 * p_l would also like to remind people that dynamic typing != weak typing
09:26:22 <FunctorSalad_> p_l: I don't think out contempt^Wdispreference for it is based on the confusion
09:26:23 <jmcarthur> weak typing is even worse, to me, whether it's dynamic or static
09:26:24 <FunctorSalad_> :D
09:26:27 <p_l> a "dynamic" language might actually allow static typing depending on the case
09:27:10 <FunctorSalad_> hmm where is fasta? (I only notice people leaving by tab completion not working :p)
09:27:13 <p_l> (Common Lisp supports static typing, for example, it's just afaik an optional thing compiler can exploit)
09:27:35 <EvanR-work> OOP is suited to dynamic goofing off, FP is suited to static typing with polymorphism and inferrence
09:27:47 <aristid> jmcarthur: do existentials count as dynamic typing?
09:28:10 <jmcarthur> aristid: no, because the type system can still statically prevent you from doing dumb things
09:28:15 <FunctorSalad_> well it's a *controlled* amount of dynamic typing
09:28:16 <ezyang> aristid: Not really, since it all has to be kept together. 
09:28:25 <p_l> EvanR-work: the question is, do you consider OOP to be "classes classes classes" or do you treat any possible value as an object (with type)
09:28:27 <FunctorSalad_> rather than "everything is an object" (pun intended)
09:28:48 <aristid> i think when people want heterogenous lists, they actually want either lists of variants, or lists of existentials :)
09:29:05 <EvanR-work> p_l: objects objects objects
09:29:07 <jmcarthur> aristid: if you put a type class constraint on an existential type, the compiler will complain if you try to unify it with a type that doesn't instantiate the type class
09:29:08 <FunctorSalad_> (I know it usually describes OOP, but I mean it also describes dynamic typing in terms of static ;))
09:29:19 <aristid> jmcarthur: yeah
09:29:28 <ezyang> Because of laziness, you often don't even need the existentials. 
09:29:51 <aristid> ezyang: huh? how are those things related?
09:30:07 <ezyang> A common thing needed in OOP system is hooks. 
09:30:08 <jmcarthur> aristid: additionally, unlike in most dynamic OO language, you can never get a concrete type back from an existential (unless a type class constraint allows you to do a conversion)
09:30:20 <FunctorSalad_> I think ezyang means you can just use [String] instead of [AnyShow]
09:30:25 <jmcarthur> the addition of Typeable muddies that water a bit
09:30:31 <ezyang> You could implement a hook as an existential package, or you could just run the damn thing and put IO () in the list. 
09:30:45 <FunctorSalad_> because the only thing you can do with the AnyShow is showing it anyway.... and lazyness ensures you aren't actually calculating all the strings unnecessarily
09:30:53 <aristid> jmcarthur: i haven't really looked at Dynamic much, but isn't it like that?
09:31:06 <jmcarthur> aristid: yeah, it's basically Typeable with existentials
09:31:06 <aristid> FunctorSalad_: hmm
09:31:12 <FunctorSalad_> this only works for 'simple' classes like Show though, not for Eq I think
09:31:26 <jmcarthur> aristid: it's mainly Typeable that gives is the "dynamicness" though
09:31:29 <kmc> AnyEq is useless though
09:31:31 <jmcarthur> s/is/it/
09:31:36 <dolio> > map show [1, 'c', 1.0]
09:31:37 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Char)
09:31:37 <lambdabot>    arising from the li...
09:31:38 <FunctorSalad_> kmc: hmM?
09:31:40 <dolio> Aww.
09:31:43 <aristid> FunctorSalad_: i was thinking about something like [Num a => a]
09:31:47 <kmc> "here's a thing of totally unknown type.  you can compare it to something of the same type"
09:32:02 <FunctorSalad_> nub_it :: [AnyEq] -> [AnyEq]...
09:32:12 <FunctorSalad_> granted, you can't do much more than count the result ;)
09:32:13 <kmc> you can't compare any two elements of [AnyEq]
09:32:22 <FunctorSalad_> oh!
09:32:25 <FunctorSalad_> true
09:32:26 <jmcarthur> yeah that will never work
09:32:27 <FunctorSalad_> :)
09:32:40 <FunctorSalad_> yes yes I recant :p
09:32:47 <ezyang> So, something that dynamic languages usually let you do is then recover the implementation when you're done... 
09:32:52 <aristid> hmm i guess that makes it harder
09:32:53 <ezyang> (unsafely, of course!) 
09:33:45 <aristid> ezyang: like polymorphic functions?
09:33:54 <ezyang> Yup! 
09:35:27 <lispy> Is it just me or is Richard O'Keefe a troll?
09:35:38 <lispy> I don't think he means to be though
09:35:51 <kmc> doesn't a troll necessarily mean to be a troll?
09:36:17 <Twey> I think a troll has to mean to be a troll.
09:36:18 <lispy> kmc: Not all the time.  It could be some well intentioned person who just keeps derailing productive conversations
09:36:18 <FunctorSalad_> extensionally, yes
09:36:18 <EvanR-work> http://www.cs.otago.ac.nz/staff/richard.html does he look like a troll to you??
09:36:23 <FunctorSalad_> (@ kmc)
09:36:40 * Igloo agrees with kmc
09:36:45 <FunctorSalad_> I mean they don't need to have the intention "I want to be a troll", they don't need to know the word troll
09:36:57 <FunctorSalad_> but they need to have an equivalent intention ;)
09:37:25 <lispy> "My biggest concern is that most programs don't work, hence my interest in Software Engineering, and my liking for Ada."
09:38:05 <EvanR-work> i think a lot of people in functional programming at quick to point out flaws in conventional thinking, which is controversial, which could be considered trolling
09:38:09 <EvanR-work> are quick*
09:38:12 <FunctorSalad_> lispy: that's not a *troll*
09:38:42 <FunctorSalad_> arguably...
09:38:49 <lispy> FunctorSalad_: Well, I found it amusing.  The stuff that I call trollish from him appears on -Cafe.
09:39:05 <lispy> So, I won't call him a troll anymore.
09:39:14 <illissius-> ada to me seems to have had the idea that you make programs safer / more correct by making them more verbose
09:39:21 <illissius-> (ditto java, for that matter)
09:39:26 <lispy> Instead I'll be more explicit.  Productive-conversation-derailer. or PCD.
09:39:48 <kmc> i think accusations of trolling are pretty harmful
09:39:53 <kmc> and not valuable except in obvious cases
09:40:09 <EvanR-work> they are valuable for the lulz
09:40:39 <lispy> kmc: fair 'nough
09:48:02 <dpratt71> in reference to http://is.gd/ez3bf ...
09:48:18 <dpratt71> ...my brain is having a hard time parsing that code
09:49:33 <dpratt71> in the first line: the first | is a pattern guard, the second | is part of the list comprehension, the third and fourth | are...what?
09:51:46 <illissius-> dpratt71: it's just a plain guard, and you can write multiple guards inline
09:51:59 <illissius-> but it's a bad idea because then people have difficulty parsing it
09:52:47 <dh__> dpratt71: I belive APL or J will win on less characters ,
09:53:11 <dpratt71> illissius-: ok; does the guard apply to everything following '='?
09:53:44 <illissius-> (so it's as if they had written | 1`elem`s = "happy " on a separate line, and then | 0 < 1 = "sad " on the next, etc.)
09:55:15 <illissius-> so no, the guards fall through to the next one as normal, they're not nested
09:56:47 <Twey> 'ey, it's Trinithis.  Haven't seen that guy around in a while.
09:57:57 <ziman> dpratt71, they should be guards
09:58:11 <ziman> the last one looks like the shortest "otherwise" :)
09:58:46 <Twey> dpratt71: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29388#a29388 — it formats like this
09:58:57 <Twey> Yeah, 0<1 is a short ‘otherwise’
09:59:36 <dpratt71> Twey: ah, I get it now, thanks
10:00:32 <dpratt71> I was blocked on thinking everything after the '=' was part of one...definition
10:02:33 <Twey> Nah, | has a wider scope than =
10:09:59 <augur> cat theory people!
10:10:16 <copumpkin> meow
10:10:20 <McManiaC> [19:07:55] … is XMonad compatible with as many drivers as Ubunto?
10:10:21 <McManiaC> haha
10:10:29 <augur> copumpkin: can you explain something to me from category thing?
10:10:37 <McManiaC> whoops, wrong chan :D
10:10:41 <copumpkin> augur: depends whether I understand it or not :)
10:10:47 <augur> :|
10:11:30 <copumpkin> ask the question, then I'm sure someone (if not me) will answer it for you :P
10:12:36 <augur> copumpkin: so according to this paper, a monoidal category is left closed if there is an internal hom functor -o : C_op x C -> C, together with currying c_XYZ : hom(X xx Y, Z) ~-> hom(X, Y -o Z)
10:13:16 <augur> but as far as i understand it, X, Y, and Z are objects of the category
10:13:41 <augur> i mean, thats how they were set up in the intro to this, right
10:14:50 <augur> in the intro it says given X and Y in category X, theres a set of morphisms from X to Y, hom(X,Y), and in a closed category there's also an object of morphisms from X to Y, X -o Y
10:17:22 <augur> and then they also say that hom is a functor from from C_op x C -> Set
10:17:27 <augur> i dont understand. :(
10:17:33 <copumpkin> this looks awfully similar to exponentials
10:17:36 <augur> is hom a functor or a set of morphisms or
10:17:47 <augur> and is -o a functor or a morphism
10:17:48 <augur> D:
10:18:02 <Cale> augur: for each pair of objects X and Y, Hom(X,Y) is a set (of arrows)
10:18:12 <Cale> augur: Hom itself, is a functor
10:18:43 <augur> Cale: so its a functor from ... what category to what category? :(
10:18:48 <augur> wait lemme try to figure this out actually
10:19:29 <Cale> Okay, I have the first part of the explanation typed :)
10:19:54 <augur> so for category C, theres another category O of pairs of objects in C, and a category A of arrows in C, and Hom is O -> A
10:19:55 <augur> ?
10:20:43 <Cale> Well... sort of :)
10:20:47 <augur> T_T
10:20:48 <Cale> A is a category of sets of arrows
10:20:53 <augur> ok
10:20:57 <Cale> In particular, it's just the category Set
10:21:06 <augur> wha
10:21:13 <Cale> (of all sets)
10:21:27 <Cale> We can use a bigger category here of course
10:21:44 <augur> but doesnt A need to be the arrows in C, not any arrows period?
10:21:46 <Cale> Hom sends each object of C^op x C, which is just a pair of objects of C, say (X,Y) to a set, the set of arrows in C from X to Y.
10:22:08 <arbitrarylogic> what does Hom do with arrows in C^op x C?
10:22:10 <Cale> It doesn't matter that there are sets in the codomain of this functor which maybe we're not using.
10:23:10 <augur> ok so the image of (X,Y) is a set of arrows in C, but the range is Set
10:23:26 <augur> or well, a subset of sets of arrows in C or something like that
10:23:36 <Cale> The codomain is Set, the range is just the sets of arrows in C.
10:24:40 <augur> oh sorry, i somehow got mixed up and had range == codomain. lol
10:24:59 <augur> oookay. that sort of makes sense
10:25:09 <augur> god i need a proper category theory introduction
10:25:23 <Cale> Do you have Awodey?
10:25:28 <augur> something with concrete examples, because this is so abstract
10:25:29 <augur> x.x
10:25:33 <augur> Awodey? probably not
10:25:35 <augur> lemme check
10:25:40 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
10:25:44 <augur> no
10:25:48 <augur> o hey awesome
10:26:22 <Cale> This is my favourite text, moreso still for introducing CS people to category theory, because it's light on prerequisites.
10:26:40 <augur> im reading this paper by baez and someone else
10:26:46 <augur> baez and stay
10:26:48 <Cale> (A lot of traditional CT books assume you're a pure mathematics graduate student and know a bunch of algebraic topology and other stuff)
10:26:52 <augur> called Physics, Topology, Logic, and Computation
10:27:00 <Cale> Ah, yeah, I know the one, I think.
10:27:07 <Cale> The Rosetta Stone thing :)
10:27:47 <ddarius> Algebraic topology is fun
10:27:53 <augur> yeah
10:30:02 <Cale> augur: So, an arrow in C^op x C from, say, (X,Y) to (U,V) is a pair (f,g) of arrows in C, with f: U -> X, and g: Y -> V (note the directions!)
10:30:34 <augur> yeah
10:30:45 <augur> ok
10:30:48 <Cale> augur: So, if Hom is to be a functor, we need it to send such an arrow (X,Y) -> (U,V) to a function between sets: Hom(X,Y) -> Hom(U,V)
10:30:59 <augur> im still wrapping my head around arrows being pairs of arrows and blah and such you know?
10:31:06 <Cale> Or, in Haskell-like notation, it should be a function (X -> Y) -> (U -> V)
10:31:53 <Cale> So, the question is, how do we take a pair of arrows, U -> X, and Y -> V, and an arrow X -> Y, and get an arrow U -> V?
10:32:07 <Cale> Well, there's only one thing we can do really.
10:32:28 <Cale> We compose the arrows together: U -> X -> Y -> V
10:33:29 <dmwit> Wow, your server has even less bandwidth than my home computer.
10:33:51 <Cale> My upload bandwidth is 120 KB/s
10:34:00 <dmwit> Are you self-hosting?
10:34:03 <Cale> yes
10:34:07 <dmwit> cool
10:34:38 <dmwit> Is this copy of Awodey... ah... legal?
10:34:43 <Cale> Probably not.
10:35:08 <dolio> Doesn't he have a copy on his site?
10:35:33 <Cale> I got it from a friend of mine, who didn't say, but hinted that he might have got it from the original author.
10:36:11 <Cale> It's elsewhere online
10:36:18 <Cale> (In a slightly different format, oddly enough)
10:36:19 <dmwit> I don't see it in a 30s perusal of his homepage.
10:36:31 <dolio> Yeah, I don't see it now either.
10:36:36 <dolio> I could have sworn he did, though.
10:36:43 <dmwit> Anyway, I'll just say Cale is educating me.
10:36:44 <dolio> But the link now is to buy a 2nd edition.
10:36:48 <Cale> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
10:37:27 <Cale> There's that one too, which comes up in the first page of results for "Category theory" (no quotes) on Google.
10:38:59 <Cale> So if you didn't get it from me, you could easily have just searched Google ;)
10:47:52 <siteswapper> ?quote
10:47:53 <lambdabot> ClaudiusMaximus says: i hate haskell -  i seem to have started trying to make a dsp language and ended up implementing a type-level map, now i need to learn template haskell to generate all the
10:47:53 <lambdabot> types and comparison instances for me..
10:48:17 <aristid> yitz: can i use timezone-series to find the nearest two valid times around an invalid local time? :)
10:52:18 * hackagebot amqp 0.1.3 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.1.3 (HolgerReinhardt)
10:52:35 <roconnor> wow, the wikipedia article on dynamic binding is really really terrible
10:53:04 <c_wraith> Most wikipedia articles on programming topics are horrible.
10:53:30 <roconnor> no, I mean really much worse than normal
10:53:53 <zygoloid> tommd: (re blog post) ugh, functional dependencies? looks like you don't need the ctx -> d fundep at all. a HashContext associated type would make the type signatures of the higher level interface nicer ;)
10:53:54 <dolio> The computer science one looks better than the chemistry one.
10:54:03 <roconnor> dolio: really? 
10:54:05 * roconnor looks
10:54:19 <zygoloid> tommd: (for the Hash type class, not really looked at the others)
10:55:00 <roconnor> dolio: I don't know
10:55:13 <dolio> It's three sentences.
10:55:14 <zygoloid> tommd: oops, looks like you do need fundeps in both directions ;(
10:55:15 <roconnor> dolio: not only is the content of the CS page dreadful, it doesn't even describe dynamic binding.
10:55:22 <tommd> yep
10:55:25 <wlangstroth> roconnor: oh, wow - you're right
10:55:31 <roconnor> instead it does a terrible job of describing dynamic dispatch
10:55:49 <zygoloid> tommd: still, a data family would give a nicer user experience i think. ;)
10:58:30 <wlangstroth> roconnor: I've only used dynamic binding in C++, is it used elsewhere?
10:58:41 <aristid> zygoloid: fundeps in both directions are possible?
11:00:46 <roconnor> wlangstroth: I've only used in in Lisp.  I don't think C++ has dynamic binding.
11:01:08 <dolio> Are we talking about dynamic scope?
11:01:14 <dolio> Or something else.
11:01:21 <roconnor> dolio: isn't that what dynamic binding is?
11:01:35 <wlangstroth> roconnor: in C++ you have to roll your own - I guess that's what I mean by "use"
11:01:50 <dolio> Well, that was what first came to mind. But it's quite possible that it's used other ways elsewhere.
11:01:57 <roconnor> dolio: maybe that is my problem
11:02:10 <roconnor> dolio: thanks for giving me a new search term
11:02:14 <dolio> Like how "functor" means different things in different communities.
11:03:45 <wlangstroth> I guess the confusion could be that in C++, you're using the virtual keyword, which would be "method dispatch" - it's been a while
11:04:10 <spaghetti> asd
11:04:12 <spaghetti> oh
11:05:28 <zygoloid> aristid: yeah. specifying a bijective relationship between existing types is one of the things you can do with FDs but not type families
11:05:55 <zygoloid> (you can get pretty close with data families, but that requires one end of the relationship be a new type)
11:06:25 <aristid> zygoloid: i somehow don't understand how bijective fds are even possible :D
11:06:31 <aristid> hmm
11:13:17 <ddarius> "The topology of politics"
11:14:36 <dolio> class (T a ~ b, T' b ~ a) => C a b where type T a ; type T' b ; ...
11:14:52 <copumpkin> not allowed :(
11:14:58 <dolio> Yes it is.
11:15:01 <copumpkin> it is?
11:15:02 <dolio> It just doesn't work yet.
11:15:08 <copumpkin> yeah, that's what I meant :P
11:15:31 <ddarius> class C a b | a -> b, b -> a where ...
11:15:39 <zygoloid> allowed, but not permitted ;)
11:15:50 <copumpkin> yeah, but everyone's too excited about type families to go for FDs these days
11:16:10 <Bobbias> Man, chat about functional programming is WAY different than chat about imperative languages
11:16:16 <zygoloid> type families are functional dependencies' better-looking younger sister
11:16:42 <ddarius> So how about class C a | -> a ?
11:17:03 <ddarius> zygoloid: Associated types are only sometimes better looking.
11:17:19 <zygoloid> (not mature enough to do some of the kinkier stuff yet...)
11:18:53 <dolio> class (a ~ T) => C a
11:19:07 <ddarius> Yeah, but that seems to make the decision too early.
11:19:17 <zygoloid> class C where ... ;)
11:19:29 <Twey> Bobbias: How so?
11:21:04 <ddarius> Maybe class (a ~ T) => C a where type T; ... if that is legal
11:21:53 <dolio> Apparently it is.
11:23:04 <dolio> Yep, that works.
11:23:49 <ddarius> Associated types would look interesting in Curry.
11:24:30 <zygoloid> ddarius: but /why/? ;-)
11:31:21 <Bobbias> Twey: Well, mostly because I have no damned clue what most of the guys here are talking about
11:32:01 <Libertus> Bobbias: you're not alone :)
11:33:44 <Bobbias> lol, that's good to know.
11:34:23 <Bobbias> After deciding that the Project Euler problems would be a good way to learn haskell, I've decided that I need to learn haskell better before I can tackle most of them :/
11:34:40 <Botje> Bobbias: most of the <50 ones can be solved with list comprehensions
11:34:59 <mauke> Bobbias: http://haskell.org/haskellwiki/Real_World#Haskell
11:35:02 <Botje> Bobbias: and that's how i started too, so i know ;)
11:35:14 <zygoloid> a fair number of them really need mathematical insight more than haskell lore
11:35:24 <sproingie> none of the euler stuff  needs fancy type level stuff, which is where most of the difficulty in haskell is
11:35:35 <applicative> Bobbias, that some of our gentlemen have forgotten the existence of #haskell-in-depth shouldn't keep you from asking 'stupid' questions
11:36:04 <Bobbias> Yeah, I'm well versed in asking questions about programming :P
11:36:21 <wlangstroth> I will forever recommend Typeclassopedia
11:36:55 <wlangstroth> For me, that was more *why* to use Haskell than how
11:36:55 <yrlnry> Yorgey++
11:37:37 <yrlnry> Bobbias:  Have you seen the "Software Tools in Haskell" pages?
11:37:37 <mauke> did you mean: byorgey
11:37:46 <Bobbias> No
11:38:11 <yrlnry> Bobbias:  It's a translation of the Kernighan and Plauger "Software Tools [in RATFOR]/in Pascal" programs into Haskell.
11:38:19 <yrlnry> I found it extremely enlightening.
11:38:30 <Bobbias> hmm, I'll have to check that out
11:38:36 <yrlnry> http://www.crsr.net/Programming_Languages/SoftwareTools/index.html
11:41:31 * hackagebot cmdargs 0.3 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.3 (NeilMitchell)
11:44:10 <ddarius> @google Lagrange theorem
11:44:11 <lambdabot> http://en.wikipedia.org/wiki/Lagrange's_theorem_(group_theory)
11:44:47 <Twey> Haha, mauke, what is ‘boinging’?
11:44:54 * mauke boings
11:47:08 <kmc> @quote stereo
11:47:08 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
11:49:29 <Martty> @quote java
11:49:29 <lambdabot> dibblego says: Java programmers prefer referential transparency too, they just call it "design patterns" or something
11:50:07 <illissius-> "This, then, is intended as a text and reference book, not only for students of Mathematics, but also for researchers and students in Computer Science, Logic, Linguistics, Cognitive Science, Philosophy, and any of the other fields that now make use of it."
11:50:25 <illissius-> what the heck, that's like a short-list of "things illissius finds interesting"
11:50:34 <illissius-> guess i should read this book.
11:50:40 <Bobbias> lol, same here
11:51:44 <ddarius> illissius-: Which book?
11:52:02 <Bobbias> http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
11:52:14 <illissius-> ddarius: the one Cale linked, if you were in-channel at the time
11:52:20 <ddarius> I've read it.
11:52:21 <illissius-> and which Bobbias just re-linked
11:53:03 <Bobbias> The book makes me feel like I should know set theory though
11:53:08 <ddarius> As far as I recall, most of those fields don't even get mentioned.
11:53:12 <ddarius> Bobbias: You should know set theory.
11:53:28 <Bobbias> lol, it;s one of those things I've seen all over the place, but never had the chance to learn
11:53:53 <dolio> Computer science is mentioned a little, perhaps.
11:54:04 <ddarius> Bobbias: There isn't much to it, at least as far as you need to know for most things.  You don't need to know what a zero hand grenade is.
11:54:09 <dolio> Some logic too, I guess.
11:54:48 <Bobbias> I'm going to college for electrical engineering, so that's not exactly something we ever learn
11:54:54 <Martty> hello
11:54:59 <Martty> teach me haskell in 23 seconds
11:55:05 <illissius-> I wasn't really expecting the book to talk about them, but that it's useful in all those different fields is sort of fascinating
11:55:14 <Martty> and i dont mean hello world, i mean Cale level
11:55:20 <kmc> teach yourself Haskell in 23 seconds
11:55:28 <ddarius> illissius-: Category theory is very broadly useful.
11:55:41 <Martty> you live in the past kmc , now its "we teach you (without you doing anything)"..
11:55:44 * djahandarie throws a 0|• at ddarius
11:56:33 <ddarius> Bobbias: Electrical engineer means signal processing means Cauchy's theorem means complex analysis.
11:56:51 <ddarius> Complex analysis is a massive hub in theoretical and applied mathematics.
11:57:15 <jystic> @pl prefixF p (n, v)  = (prefix p n, v)
11:57:15 <lambdabot> prefixF = (`ap` snd) . (. fst) . ((,) .) . prefix
11:57:46 <Bobbias> Not the program I'm in. It's currently focusing on power generation and distribution
11:58:41 <Bobbias> technically, it's the "Automated systems" course, which is supposed to focus on industrial automation (robots, etc.) but of course, because the economy still hasn't really recovered, they've begun focusing heavily on power generation 
11:59:53 <Bobbias> I took the course because I wanted to learn about PLCs, robotics, and industrial automation :/
12:00:40 <applicative> Bobbias, that they are changing the curriculum suggests they think the economy is tanking forever.  I wonder how they know....
12:00:57 <aristid> Bobbias: because power generation allows people to work for a utility or why do they do that?
12:01:55 <Veinor> is there any way to embed multi-line strings?
12:02:07 <aavogt>  \  at the end of the line
12:02:07 <Veinor> without using \n escapes, that is
12:02:08 <Bobbias> applicative: nah, they apparently do this every so many years (10-20ish, based on where more jobs are) aristid: yeah, I could get a co-op position at a utility company, they do pay well, but I really hate that end o fit
12:02:10 <ddarius> > "a\      \"
12:02:11 <lambdabot>   "a"
12:02:16 <ddarius> > "a\      \b"
12:02:17 <lambdabot>   "ab"
12:02:22 <aavogt> oh, actual multiline
12:02:31 <olsner> ah, the backslashes, that's a neat haskell feature I have never ever used
12:02:38 <aristid> Bobbias: it's probably not that hugely interesting
12:02:45 * hackagebot darcs-beta 2.4.98.4 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-beta-2.4.98.4 (ReinierLamers)
12:03:28 <Bobbias> No, it's not, most of the jobs are either in some sort of maintenance or linesman type jobs, or are design jobs where you sit at a desk all day and make drawings
12:03:46 * hackagebot libxml-enumerator 0.2 - Enumerator-based API for libXML's SAX interface  http://hackage.haskell.org/package/libxml-enumerator-0.2 (JohnMillikin)
12:04:13 <applicative> whoa the new enumerator library is going to town....
12:04:34 <Veinor> aavogt: hm, that doesn't seem to do what I want
12:04:53 <aristid> > "a\                                        \b\                                 \c"
12:04:54 <lambdabot>   "abc"
12:05:09 <applicative> Veinor, what do you want, I was going to say the same ...
12:05:25 <Heffalump> @seen ivanm
12:05:26 <lambdabot> Unknown command, try @list
12:05:26 <preflex>  ivanm was last seen on #haskell 8 hours, 26 minutes and 56 seconds ago, saying: :p
12:05:29 <ddarius> Veinor: You could use TH to do what you want, but it's probably easiest just to use \n (combined with \ \)
12:05:43 <Veinor> bah
12:05:56 <Veinor> basically I'm working on some Euler problems and I don't want to have to read in the grid of numbers from a file
12:05:59 <Veinor> :P
12:06:43 <ddarius> copumpkin: If you haven't yet, prove that full and faithful functors reflect isomorphisms.
12:06:47 <Zao> Veinor: Take numbers, apply sufficient amounts of sed/vim/emacs to them to be in list form.
12:06:53 <Martty> if Euler knew about projecteuler he'd kill himself imo
12:07:10 <EvanR-work> Zao: Veinor: or haskell ;)
12:07:29 <applicative> Euler was a saint, he would favor anything that is good. 
12:07:30 <wli> Martty: Well put.
12:08:04 <sproingie> euler wouldn't mind
12:08:09 <applicative> Didn't he say, I will unite with anyone to do right, and with no one to do wrong?
12:08:13 <sproingie> dijkstra would probably scream his head off
12:08:20 <applicative> No, that was Frederick Douglas...
12:08:21 <ddarius> Euler wouldn't mind, but he wouldn't be impressed.
12:08:52 <copumpkin> ddarius: I'd need to write a lot of stuff to even state that :) my proofs about CT in agda so far have been very simple, and have only used the stuff in the existing library, which is fairly incomplete (no adjunctions, really, for example)
12:09:16 <applicative> I think I could solve the 7 Bridges of Koenigsberg faster than him; that might impress him. 
12:09:52 <ddarius> copumpkin: http://www.brics.dk/DS/03/7/index.html
12:10:15 <ddarius> applicative: He could probably sum an infinite series faster than you.
12:10:57 <sphynx> hi!
12:10:58 <applicative> ddarius, yes, i can't use haskell to sum an infinite series by brute force...
12:11:20 <sphynx> I wonder how can I find Data.List documentation from Hayoo! ?
12:11:30 <EvanR-work> just use CReal and hypercomputer
12:11:31 <applicative> for that you need genuine understanding.... :)
12:11:38 <sphynx> it seems it shows me a lot of different stuff, but missing the simplest one
12:12:18 <ddarius> applicative: Actually, there are some relatively simple rules that wouldn't be hard to encode that capture a good chunk of cases.
12:12:28 <sphynx> I would like to get this link: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-List.html (which I found with google, but not with Hayoo!)
12:12:32 <BMeph> Am I weird for wanting a graphical web interface for darcs, like patch-tag, but better? Or am I just weird to want to name it "DarcsIDE"? ;)
12:13:02 <copumpkin> BMeph: I think you're just weird
12:13:20 <copumpkin> :)
12:13:30 <kmc> not as good as CoqBlock
12:13:48 <EvanR-work> Coq::Blocks ?
12:14:16 <sphynx> mm, maybe no one uses Hayoo? I think I'm missing something very simple...
12:14:23 <kmc> Coq to rename lambda to "blocks" in anticipation of widespread industrial use
12:14:43 <roconnor> 】 <- what character is this?
12:14:55 <applicative> sphynx, didn't you get that page and others when you installed ghc?
12:15:39 <EvanR-work> roconnor: right aligned shaded rectangle with semi circular region missing on left side
12:15:50 <wjt> roconnor: RIGHT BLACK LENTICULAR BRACKET !
12:16:10 <roconnor> lenticular!
12:16:23 <sphynx> applicative: yeah, I have it for offline browsig, but I was hoping for one unique source of docs
12:16:23 <ddarius> You need lenticular brackets for lenses.
12:16:35 <wjt> lenticulating splines!
12:16:38 <roconnor> ddarius: what about for bananas?
12:16:53 <sphynx> like Hayoo :) and I'm disappointed because of this weird behaviour
12:17:11 <sphynx> it would be great to search for API functions in one place
12:17:22 <applicative> sphynx, I see.  There is also the expedient of typing :m +Data.List in ghci, and then  :browse  ....
12:18:16 <ddarius> roconnor: I don't spend my days perusing Unicode characters.
12:18:51 <sm> where can I find the list of values returned by System.Info.os ?
12:19:13 <applicative> Would there be an easy way to do hook the equivalent of :m +Data.List  then :browse with one's editor?  Like TypeOf?
12:19:19 <mauke> U+3011 (e3 80 91): RIGHT BLACK LENTICULAR BRACKET [】]
12:19:52 * sm greps ghc source for "darwin"
12:20:10 <sphynx> applicative: yeah, might be helpful
12:20:36 <Bobbias> interestingly enough a google search of "lenticular bracket" brings up a vunch of results of listings of unicode characters
12:20:54 * ski feels offended by the epithet "BLACK"
12:21:32 <mauke> U+3010 (e3 80 90): LEFT BLACK LENTICULAR BRACKET [【]; U+3011 (e3 80 91): RIGHT BLACK LENTICULAR BRACKET [】]; U+3016 (e3 80 96): LEFT WHITE LENTICULAR BRACKET [〖]; U+3017 (e3 80 97): RIGHT WHITE LENTICULAR BRACKET [〗]
12:21:57 <EvanR-work> funny the black one appears white to me, and the white are missing from my font ;)
12:22:25 <sproingie> the black ones appear whiter to me but that's because i have a light on dark color scheme for irc
12:22:30 <ddarius> copumpkin: You should implement that thesis in Agda.
12:22:37 <roconnor> ddarius: I've been reading Jaynes's book.  He appears to believe that rational people can agree to disagree.
12:22:47 <roconnor> which I found interesting
12:22:52 <ddarius> roconnor: Only if they have different priors.
12:22:54 <sproingie> the names in unicode assume the glyph is rendered in black
12:23:03 <roconnor> ddarius: sure, but that probably isn't so hard.
12:23:28 <roconnor> ddarius: it has made me more tolarent I hope.
12:23:30 <copumpkin> ddarius: hah :P it looks like a massive amount of work, and I'm pretty sure nobody would ever touch it even if I did
12:23:56 <ddarius> copumpkin: If it came out alright, I'm pretty sure several people would be interested.
12:23:57 <ski> sproingie : unfounded discrimination, i say
12:24:07 <copumpkin> ddarius: that's a big if though :)
12:24:15 <ddarius> Indeed.
12:24:31 <copumpkin> it definitely looks interesting, though
12:25:28 <applicative> speaking of TypeOf, I managed to implement it in TextMate; it's not quite up to haskell-mode level....
12:25:39 <roconnor> ddarius copumpkin: do you think that calculus will let me express both semi-mutual recursion and history and to repeatedly apply a natural transformation as you get deeper into a functor?
12:26:17 <roconnor> er, that joke may be a little obsucure
12:26:20 <applicative> @faq
12:26:21 <lambdabot> The answer is: Yes! Haskell can do that.
12:26:42 <applicative> I guess we need @faq-agda
12:26:43 <sproingie> ski: it's a typography convention that predates computers
12:27:53 <copumpkin> roconnor: I got it :P
12:28:05 <copumpkin> roconnor: but I have no clue about the actual question :P
12:28:10 <roconnor> :D
12:32:41 <copumpkin> zygohistomorphic_prepromorphism f = g_prepro (distZygoT (liftAlgebra f) (distHisto id))
12:32:45 <copumpkin> that id there makes me suspicious
12:32:49 <copumpkin> needs to be more general
12:33:46 <applicative> zygopumpkin_preprocopumpkin f g = g_prepro (distZygoT (liftAlgebra f) (distHisto g))  ?
12:35:24 <int80_h> > data Month = January | Feburary
12:35:25 <lambdabot>   <no location info>: parse error on input `data'
12:35:40 <int80_h> grrr
12:36:08 <int80_h> there's an online interpreter right? My server is down.
12:36:26 <applicative> @where tryhaskell
12:36:26 <lambdabot> http://tryhaskell.org/
12:36:40 <burp> I don't think that will work there
12:37:06 <applicative> it won't.  There's codepad .  It won't work with an interpreter anyway.
12:37:42 <int80_h> yeah it doesn't work
12:38:26 <int80_h> hmm I'mm experiencing the disadvantages of relying on one VM to do your work on.
12:38:42 <djahandarie> @where hpaste
12:38:42 <lambdabot> http://hpaste.org/
12:38:44 <djahandarie> Hm
12:38:50 <djahandarie> Are there any other instances of hpaste?
12:38:52 <djahandarie> That one is down
12:38:52 <ski> @where paste
12:38:52 <lambdabot> http://hpaste.org/new
12:39:55 <int80_h> dang it, it was working a second ago
12:40:31 <ddarius> :t let zP g_prepro distZygoT liftAlgebra distHisto f g = g_prepro (distZygoT (liftAlgebra f) (distHisto g)) in zP
12:40:32 <lambdabot> forall t t1 t2 t3 t4 t5. (t -> t1) -> (t2 -> t3 -> t) -> (t4 -> t2) -> (t5 -> t3) -> t4 -> t5 -> t1
12:42:27 <ski> (eta-expand some ?)
12:42:55 <copumpkin> :t let zP g_prepro distZygoT liftAlgebra distHisto f = g_prepro (distZygoT (liftAlgebra f) (distHisto id)) in z
12:42:56 <lambdabot> Expr
12:42:58 <copumpkin> :t let zP g_prepro distZygoT liftAlgebra distHisto f = g_prepro (distZygoT (liftAlgebra f) (distHisto id)) in zP
12:42:59 <lambdabot> forall t t1 t2 t3 t4 a. (t -> t1) -> (t2 -> t3 -> t) -> (t4 -> t2) -> ((a -> a) -> t3) -> t4 -> t1
12:44:00 <ddarius> :t uncurry id
12:44:01 <lambdabot> forall b c. (b -> c, b) -> c
12:45:08 <djahandarie> Uh what
12:45:17 <ddarius> The naturality formula is so useful and pretty.
12:45:37 <monochrom> naturally pretty
12:46:48 <ddarius> Nat(F,G) ~ ∫_x Hom(Fx,Gx)
12:49:26 <applicative> djanderie, its simple, it's
12:49:27 <applicative> @type let z g d l h f = g (d (l f) (h id)) in z
12:49:29 <lambdabot> forall t t1 t2 t3 t4 a. (t -> t1) -> (t2 -> t3 -> t) -> (t4 -> t2) -> ((a -> a) -> t3) -> t4 -> t1
12:50:00 <applicative> kinda
12:52:04 <aristid> @pl z g d l h f = g (d (l f) (h id))
12:52:04 <lambdabot> z = (. flip (flip . (((.) . flip) .) . (.)) ($ id)) . (.) . (.) . (.)
12:52:09 <tolkad> If I do multiple lazy bytestring reads in sequence, will later ones force earlier ones to complete?
12:52:15 <aristid> applicative: much more readable in point-free form.
12:52:30 <applicative> aristid, yes a flood of light
12:53:39 <applicative> edwardk, if tolkad does multiple lazy bytestring reads in sequence, will later ones force earlier ones to complete?
12:54:04 <edwardk> ?
12:54:42 <edwardk> when you read from a lazy bytestring at a given position, it forces enough of the string to materialize the chunk that contains that position
12:54:52 <edwardk> without context i'm not quite sure what you're asking
12:55:32 <applicative> I think that answers tolkad's question as I understood it.   
12:56:24 <applicative> but i'm not sure. 
12:56:28 <edwardk> happy to help ;)
12:56:37 <edwardk> but i apparently have to run
12:57:02 <timborg> I want to write a mmorpg in haskell
12:57:15 <roconnor> timborg: texted based?
12:57:24 <timborg> 3d
12:57:32 <roconnor> :O
12:57:48 <roconnor> timborg: you should work for linden-thingy
12:57:58 <tolkad> ok, thanks
12:57:59 <int80_h> lionden-thingy?
12:58:03 <stefan_____> hi
12:58:21 <roconnor> int80_h: Linden Lab
12:58:38 <roconnor> they like Haskell and like 3-d mmorpgs
12:58:53 <Veinor> the second life guys.
12:59:15 <applicative> timborg, shouldnt we first pose the question whether mmorpgs's corrupt youth or not?  The type system enforces morality, you know.
12:59:28 <timborg> and they support virtual child molestation ?
13:00:01 <djahandarie> kmc, so I lied about coming to Boston Haskell today... I ended up being really sick and couldn't even go to work lol
13:00:02 <int80_h>  roconnor: booo. web site says not currently hiring.
13:00:03 <applicative> @ faq No, Haskell can't do that !
13:00:18 <roconnor> int80_h: maybe timborg is hiring
13:00:57 <copumpkin> is galois hiring?
13:01:09 <kmc> heh
13:01:11 <kmc> fair enough
13:02:07 <int80_h>  roconnor got a website? google is not very helpful
13:02:11 <djahandarie> I feel better now but I don't want to go and get back at like 1am and get no sleep
13:03:02 <stefan_____> hey is anyone aware of any research on "scrap your boilerplate"(SYB) after the 3 initia papers and the one "SYB systematically" one by erwig? or is this basically how haskell implements it now?
13:03:12 <ski> int80_h : <http://r6.ca/blog/> ?
13:03:15 <stefan_____> I'm not familiar with haskell, I just got to know it through those papers
13:03:29 <roconnor> timborg: do you have a website for this new haskell 3-d mmorpg yet?
13:03:45 <int80_h> heh
13:03:50 <timborg>  I want to do it
13:03:55 <timborg> nothing yet
13:04:12 <roconnor> int80_h: not yet
13:04:33 <roconnor> timborg: how much haskell experience do you have?
13:05:00 <timborg> none but I know python and I heard they are quite similar
13:05:05 <djahandarie> Heh
13:05:22 <djahandarie> You might want to start with a smaller goal than 3d mmorpg
13:05:28 <roconnor> timborg: ooh, hmm, ... not knowing python would have been better.
13:05:31 <djahandarie> Because that's a seriously monumental one
13:05:37 <roconnor> I agree with djahandarie
13:05:58 <djahandarie> E.g., get some Haskell masters together and maybe you'll get a product after a few years ;)
13:06:07 <applicative> djahandarie, I don't know, if stefan____ can start with syb instead of Project Euler anything's possible.
13:06:12 <roconnor> or at least try to break the problem into much smaller independent pieces
13:06:34 <djahandarie> 1. fix frp
13:07:08 <kmc> timborg, what did you hear about Python and Haskell being similar?
13:07:39 <elzurk1> would you guys be interested in seeing HWN back?
13:07:40 <applicative> stefan_____, you might do well to write to the haskell-cafe list.
13:07:42 <stefan_____> applicative, I'm not starting with syb in haskell. I'm not learning haskell, just trying to adapt the pattern. so I'm interested if this is how haskell implements it now or if those papers were just the fundamentals
13:08:25 <elzurk1> or maybe, something like kernel-trap for haskell-cafe might be more interesting?
13:08:59 <augur> Cale: an arrow is conceived of as a sort of special function that takes on object to one other object, right? its not supposed to be the case that you have multiple instances of an arrow f taking, say, X -> Y, and also Z -> W, right?
13:09:04 <timborg> easy string operations
13:09:58 <stefan_____> application, or search the list, thanks. there is surprisingly little info on haskell-SYB given that it's supposedly widely used in haskell. (that I could find on google)
13:12:09 <roconnor> stefan_____: I hope SYB isn't widely used
13:12:44 <notabel> stefan_____: if you look at the api documentation for syb on hackage, you can view the source of each module; that's the actual implementation (though it depends on Data.Data, which is mildly magical)
13:13:32 <roconnor> SYB is wrong
13:14:13 <applicative> it's fairly widely used http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/syb-with-class-0.6.1
13:14:31 <roconnor> oh god
13:14:43 <roconnor> Conor McBride would be spinning in his grave
13:14:54 <applicative> we dont want that!
13:14:55 <ski> augur : each arrow is presented with a specific domain and codomain
13:15:09 <aristid> haskellist blog and machine names are so clever :P
13:15:11 <ski> augur : it need not be a function, but often is
13:15:25 <augur> ski: aha so its not strictly from one object to another
13:15:27 <augur> ok
13:15:31 <stefan_____> roconnor, why is that? (hope that it's not used)
13:15:44 <ski> augur : it could be a binary relation from one set to another, e.g.
13:15:56 <roconnor> stefan_____: because IIRC it subverts the type system.
13:16:29 <ski> augur : or, for every preorder, there's a category where the objects are the elements of the preorder, and there's a (unique) arrow from `x' to `y' iff `x =< y' in the preorder
13:17:13 <stefan_____> roconnor, I don't see how, but then again I dont know the haskell type system
13:17:25 <ski> stefan_____ : iirc, there's also "uniplate" and maybe another one as well
13:17:44 <roconnor> stefan_____: IIRC it is entirely based on dynamic casting.
13:17:44 <stefan_____> notabel, is "syb" the package you meant? there's more than that on "HackageDB"
13:18:10 <ski> (random link on uniplate <http://neilmitchell.blogspot.com/2010/04/dangerous-primes-why-uniplate-doesnt.html>)
13:18:10 <notabel> yes, but syb depends on parts of base (it used to be in base)
13:18:35 <notabel> also there are various extension/variations on syb in other packages (syb-with-class, etc)
13:18:54 <notabel> but syb and the Data.Data part of base are the main implementation
13:19:10 <ski> roconnor : .. if he was dead, you mean :)
13:19:19 <roconnor> ski: yes.
13:19:35 <applicative> ski, otherwise you say: "... is spinning in his grave"
13:19:35 <djahandarie> I'd hope he isn't spinning in his grave while still alive...
13:19:38 <roconnor> ski: though he might die of a heart attack and spin in his grave if he knew how widely SYB was used.
13:20:08 * applicative wonders how to find out how much Data.Data is used
13:20:24 <copumpkin> download all of hackage
13:20:29 <copumpkin> as people often do
13:20:36 <notabel> stefan_____: also Data.Generics in base, d'oh
13:20:55 <copumpkin> man, I wish I could go to bostonhaskell :(
13:21:23 <stefan_____> roconnor, there is a dynamic cast to determine whether the user-supplied function shall be applied to a value or not, yes. (mkT in the papers). I don't understand why that is required though. e.g. in c++ that would be a static function overload resolution
13:21:58 <stefan_____> notabel, thanks!
13:22:05 <applicative> google.com/codesearch finds 174 modules "import Data.Data" .  
13:22:49 <ski> roconnor : i have a basic feeling that SYB is "wrong", but i can't really articulate why. do you remember what "it subverts the type system" was about ?
13:23:11 <roconnor> ski: it uses dynamic casting right?
13:24:53 <ski> stefan_____ : consider a heterogenous list of type `[exists a. Data a *> a]', there's no way in general to resolve statically, here
13:27:51 <notabel> stefan_____: Data.Typeable (in base) is where the really deep magic underlying both Data.Dynamic and Data.Data (and thereby syb) happens
13:28:52 <stefan_____> given that I can't even read ski's little type definition I guess it'll take some time comprehending "deep magic" ;)
13:29:12 <roconnor> stefan_____: it's not standard notation
13:29:21 <notabel> the Typeable class contains a function typeOf::a -> TypeRep, where TypeRep is an efficiently-comparable reification of type a
13:30:02 <ski> stefan_____ : a value of type `[exists a. Data a *> a]' (which is currently only pseudo-code), is a list, where for each element there is some type `a', which is known to be in the type class `Data', such that the element has type `a'
13:30:35 <ski> stefan_____ : so, the actual types `a' of the elements of the list aren't known until run-time, so there can't be any static resolution, here
13:31:07 <ski> (note, each element can have a different type, as long as every such type is an instance of the type class `Data')
13:32:28 <stefan_____> ski, I see. but that doesn't mean that the cast can't be statically evaluated when applied to other types that are statically known, does it? and I don't see how this is any worse than traversal without SYB.
13:33:05 <ski> stefan_____ : a more familiar example might be `[exists a. Widget a *> a]', where `Widget' is a type class (roughly `interface' in Java), so the only thing a function taking such a list as argument can do with the elements is use methods from the `Widget' type class on them
13:33:08 <stefan_____> if you only want to apply a function to values of one type
13:34:02 <ski> stefan_____ : sure, in many cases, one can simplify it statically, since the concrete type used is often know. i'm just noting that it can't always be done
13:35:57 <ski> (s/in many cases, one can simplify it statically/in many cases, the compiler could do the checked casts at compile time, simplifying the programs so as to not actually do any checking at run-time/)
13:37:09 <notabel> the "deep magic" is that Data.Typeable uses unsafe functions internally (e.g. unsafeCoerce, which changes type without checking physical representation, and unsafePerformIO, because TypeRep's contain a key (to facilitate fast comparison) which is statefully-generated)
13:37:44 <stefan_____> ok. so it really is staticly cast unless for types that are comparable to C++ vector<T *> where T is a polymorphic type
13:39:56 <stefan_____> I see nothing wrong with that. subverting the type system? 
13:40:14 <stefan_____> if you're traversing a type like that without SYB there's the same issue
13:40:48 <ski> "is" is a strong word, there. the casts are statically done, when possible, in the same sense that "1 + 1" are statically simplified by the compiler, instead of done at run-time
13:41:36 <ski> i.e. with a Sufficiently Smart Compiler [tm], such casts would always be statically done, when possible
13:42:58 <ski> stefan_____ : by "T is a polymorphic type" i suppose you mean a type which is really like a Java interface ?
13:43:42 <applicative> roconnor, I grepped the Epigram source to see if it imported Typeable... it only mentions it in the docs... "e.g. By maintaining the correspondence between codes and types whilst supporting arbitrary inspection of codes, we pursue the same flexibility statically."
13:44:01 <ski> (i.e. it can be implemented in completely different ways)
13:44:05 <applicative> roconnor, so he's not making himself spin in the grave....
13:44:12 <roconnor> applicative: I didn't think he would
13:44:13 <roconnor> :)
13:44:21 <stefan____> re
13:44:48 <stefan____> did I miss something?
13:45:31 <roconnor> even if Data.Typeabe is safe (which it more or less is), it is still wrong to subvert the type system.
13:45:57 <applicative> roconnor, it includes this typo: "<- Scratch your boilerplate \cite{spj:syb}"
13:46:09 <stefan____> ski, yes. by c++'s definition a polymorphic type is one whose most-derived type can be determined at runtime
13:46:28 <applicative> suggesting a mild irritation....
13:47:12 <ski> stefan____ : ok, we call that (more or less) an existential type ;)
13:48:24 <stefan____> or simpler: a type that can be dynamic cast
13:48:32 <stefan____> +ly
13:48:32 <roconnor> applicative: :D
13:48:39 <roconnor> applicative: Conor really didn't like SYB.
13:48:53 <ski> stefan____ : well, that's not implied in general by "existential" in Haskell
13:49:06 <roconnor> applicative: but they did invent Traversable and Foldable and applicative functors because of it.
13:49:11 <ski> `Typable' (as well as `Data') adds the dynamic castability
13:49:14 <roconnor> so in that sense it isn't all bad.
13:49:49 <roconnor> in the sense that it was so bad they felt compelled to make a proper replacement for it('s uses).
13:50:18 <Heffalump> is there a canonical place where 'data Const a b = Const a' is defined (perhaps with different names)?
13:50:41 <ski> Heffalump : .. maybe `category-extras' ?
13:50:51 <ski> (or however it's called)
13:51:00 <Heffalump> is there anything smaller? :-)
13:51:08 * ski has no idea, sorry
13:51:15 <applicative> stefan____ if you are looking for other references, maybe the paper in the Epigram docs will help, personal.cis.strath.ac.uk/~dagand/papers/levitation.pdf
13:52:28 <jmcarthur> Heffalump: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Applicative.html#v%3AConst
13:52:56 <Heffalump> jmcarthur: perfect, thanks!
13:54:13 <ski> stefan____ : if you have `<A> Foo<A> frob(Bar<A>) {...}' (i don't recall the C++ syntax), then `frob' is a polymorphic operation, in the Haskell sense of "polymorphic", the type of `frob', in Haskell syntax, is `forall a. Bar a -> Foo a', meaning that for any type `a' at all, the function converts a `Bar' of `a' into a `Foo' of `a'
13:54:52 <copumpkin> > 4 <$ [1..5]
13:54:53 <lambdabot>   [4,4,4,4,4]
13:54:58 <copumpkin> really useful o.O
13:55:05 <copumpkin> they claim that 
13:55:05 <copumpkin> Replace all locations in the input with the same value. The default definition is fmap . const, but this may be overridden with a more efficient version.
13:55:10 <ddarius> copumpkin: It should only take a few thousand dollars (perhaps not counting opportunity costs) for you to go to Boston Haskell.
13:55:27 <ddarius> copumpkin: It is useful for parsers.
13:55:40 <ddarius> :t Text.Parsec.char
13:55:41 <lambdabot> forall s u (m :: * -> *). (Text.Parsec.Prim.Stream s m Char) => Char -> Text.Parsec.Prim.ParsecT s u m Char
13:55:42 <copumpkin> ddarius: yeah, not even actually. I was looking into tickets and if I'd left this morning I could've gotten to boston by 7pm for "only" 1900 bucks
13:55:49 <roconnor> Heffalump: conal may have something like that in type compose
13:56:03 <ddarius> copumpkin: Round-trip or one way?
13:56:05 <Heffalump> roconnor: you can't get much more canonical than base :-)
13:56:06 <copumpkin> round trip
13:56:10 <copumpkin> I was surprised
13:56:13 <aristid> :t (<$)
13:56:14 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
13:56:24 <roconnor> Heffalump: oh where is it in base?
13:56:30 <ddarius> copumpkin: I think I paid like 1300 to go to Japan, but it was way in advance.
13:56:32 <roconnor> oh I see 
13:56:39 <roconnor> I missed jmcarthur's link
13:56:41 <aristid> :t ($>)
13:56:42 <lambdabot> Not in scope: `$>'
13:56:50 <copumpkin> ddarius: yeah, it's not bad at all to pay 1900 for a same-morning flight, I'd say
13:56:59 <Heffalump> does lambdabot know about people's timezones?
13:56:59 <copumpkin> actually it wasn't to boston
13:57:02 <copumpkin> @time
13:57:03 <lambdabot> Local time for copumpkin is 2010-08-23 22:56:39 +0200
13:57:05 <ddarius> copumpkin: That's actually really good.
13:57:06 <copumpkin> but it as almost
13:57:08 <Heffalump> @time ivanm
13:57:18 <ddarius> :t char 't' <$ True
13:57:19 <lambdabot>     Couldn't match expected type `f b' against inferred type `Bool'
13:57:19 <lambdabot>     In the second argument of `(<$)', namely `True'
13:57:20 <lambdabot>     In the expression: char 't' <$ True
13:57:23 <ski> stefan____ : on the dual hand, if you have a value of type `exists a. Bazable a *> [a]', then this means that there is some unknown type `a', which supports the type class (/ "interface") `Bazable', such that you have a list of value of that type' .. and that's an "existential" type
13:57:33 <stefan____> ski, just a matter of naming. static vs. dynamic or runtime polymorphism
13:57:33 <ddarius> :t True <$ char 't'
13:57:34 <lambdabot>     Couldn't match expected type `f b' against inferred type `Doc'
13:57:34 <copumpkin> ddarius: alas, I want to go to bostonhaskell, but not $1900 worth :)
13:57:35 <lambdabot>     In the second argument of `(<$)', namely `char 't''
13:57:35 <lambdabot>     In the expression: True <$ char 't'
13:57:39 <aristid> @time
13:57:40 <lambdabot> Local time for aristid is Mon Aug 23 22:57:16 2010
13:57:50 <ben_m> Haskell should steal (|>) from OCaml/F#
13:57:55 <aristid> lambdabot: that misses the timezone offset
13:58:00 <ddarius> Stupid shadowed names.
13:58:02 <sproingie> ben_m: what's it do?
13:58:07 <Heffalump> x |> f = f x
13:58:09 <ben_m> @let (|>) a f = f a
13:58:09 <ddarius> sproingie: flip ($)
13:58:10 <lambdabot>  Defined.
13:58:11 <aristid> copumpkin: are you in CEST?
13:58:16 <Heffalump> ben_m: but that would imply stealing <|, which there's no point to
13:58:17 <copumpkin> aristid: yeah
13:58:19 <Heffalump> and << and >>
13:58:23 <sproingie> ah.  i've seen € used for that
13:58:25 <ben_m> > 5 |> (+1) |> (*2)
13:58:27 <lambdabot>   12
13:58:27 <ski> stefan____ : generally, it is not possible to recover what type `a' is at run-time (the information is not retained), but if `Bazable' is `Typable', then what type `a' actually is is encoded in the operations of `Typable', so may be recovered at run-time
13:58:28 <Heffalump> @type (#)
13:58:29 <lambdabot> parse error on input `)'
13:58:31 <Heffalump> sproingie: lol
13:58:32 <geheimdienst> aristid, he's gotta be, cest is where it's 11 o'clock now ...
13:58:36 <Heffalump> @type (##)
13:58:37 <lambdabot> Not in scope: `##'
13:58:38 <kyagrd> @define (|>)=flip
13:58:43 <aristid> copumpkin: don't you need a visa to fly to america?
13:58:50 <copumpkin> aristid: nah, I'm a US citizen
13:58:55 <aristid> hmm
13:59:00 <ben_m> kyagrd: Not the same thing
13:59:01 <aristid> but i would need one
13:59:02 <Heffalump> aristid: most EU citizens just need an ESTA. (Web form you can fill in)
13:59:06 <kyagrd> @define (|>)=flip ($)
13:59:11 <ben_m> That one, yes :D
13:59:14 <aristid> Heffalump: but more than a few hours in advance? :)
13:59:14 <copumpkin> aristid: if you're from a european country, you probably don't, if you just want to visit
13:59:17 <ski> stefan____ : the difference between `forall' and `exists' in Haskell is not the difference between static or dynamic / run-time, no
13:59:27 <kyagrd> > 16 |> sqrt |> sqrt
13:59:28 <lambdabot>   Not in scope: `|>'Not in scope: `|>'
13:59:28 <aristid> copumpkin: yeah i'm a EU citizen
13:59:30 <Heffalump> aristid: if you don't fall foul of their checks, then yes you can usually get it with 0 notice.
13:59:30 <stefan____> ski, while we're at it, how does haskell SYB handle graph data structures? I can only see tree traversals in the papers. isn't there some mechanism to prevent indefinite cyclic traversal?
13:59:34 <Heffalump> They recommend a week or something. 
13:59:40 <kyagrd> @let (|>) = flip ($)
13:59:41 <lambdabot>  Defined.
13:59:42 * ddarius hadn't heard of the ESTA but it looks cool.
13:59:44 <kyagrd> > 16 |> sqrt |> sqrt
13:59:44 <lambdabot>   2.0
13:59:47 <kyagrd> yeah
13:59:47 <copumpkin> aristid: you will get fingerprinted on your way in though :)
13:59:48 <ben_m> :)
13:59:58 <Heffalump> ddarius: especially with the new charge they're introducing for it...
14:00:01 <aristid> you can use >>> instead of |> then
14:00:09 <ski> stefan____ : if you have a function `frob :: Int -> forall a. Eq a => Foo a', that means that the *caller* of `frob' may choose what the type `a' should be, as long as it supports the interface `Eq'
14:00:10 <aristid> or wait
14:00:12 <kyagrd> @type (>>>)
14:00:13 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
14:00:14 <aristid> sorry, was being stupid
14:00:50 <aristid> copumpkin: yeah i guess i don't really have so much leftover money anyways ;)
14:00:53 <sproingie> i suspect avoiding cycles is up to the implementer.  some cases you may want to cycle
14:01:02 <copumpkin> aristid: same here :)
14:01:18 <ski> stefan____ otoh, if you have a function `frob :: Int -> exists a. Eq a => Foo a', that means that the *callee*, i.e. `frob' itself chooses what type `a' to use (possibly a different one for different `Int' inputs), and only promises that it will always support the `Eq' interface -- the caller will have to do with that information, only
14:02:12 <aristid> copumpkin: are you in yurop for a while?
14:02:24 <ski> stefan____ : typically, graphs are not done cyclically in haskell, or if they are, the cycles would probably go via mutable cells. i'm not sure whether/how SYB handles mutability
14:02:28 <copumpkin> aristid: who knows :) I'm kind of in a limbo right now
14:02:44 <ski> (stefan____ : hint, i'm not *that* familiar with SYB)
14:02:50 <Heffalump> Iceland then? That seems like a good place for limbo between Europe and the US.
14:03:02 <copumpkin> Heffalump: I'd love to go to iceland, but nope, not iceland :P
14:03:06 <ddarius> copumpkin: Just start walking around the world and forget all this CS stuff.
14:03:18 <ski> (s/exists a. Eq a => Foo a/exists a. Eq a *> Foo a/)
14:03:33 <copumpkin> ddarius: that's what I did for two months, but eventually I started running out of money and my companion had to get back to a real life
14:03:56 <geheimdienst> how far did you get?
14:04:11 <copumpkin> I covered most of western europe and some of the balkans
14:04:28 <geheimdienst> sounds awesome :)
14:04:31 <copumpkin> was hoping to it more in, but everything took way longer than expected
14:04:37 <copumpkin> yeah, it was amazing :)
14:04:59 <tensorpudding> It would take years to see everything there was to see in Europe
14:05:26 <copumpkin> indeed :)
14:05:27 <ddarius> tensorpudding: Luckily you have about 75 years of life, nevertheless, you best get started.
14:05:45 <aristid> tensorpudding: too bad you won't have any time for asia
14:05:48 <tensorpudding> 75 years from the start, and that is only if you're reasonably healthy
14:06:06 <ski> stefan____ : .. anyway, i was above trying to elucidate how `forall' (polymorphism) and `exists' (existentials) are used in Haskell (and what they mean)
14:06:07 <tensorpudding> oh how awful, now i feel old
14:07:17 <tensorpudding> In terms of space, you could probably take many years to see everything there is to see in the USA too.
14:07:31 * hackagebot wai-handler-fastcgi 0.2.2 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-0.2.2 (MichaelSnoyman)
14:07:54 <stefan____> ski, ok thanks! cycles/graphs and runtime polymorphism were the two things that weren't clear to me reading the papers
14:08:28 <stefan____> ski, yeah, sorry for interrupting you there. I just figured you're not going to teach me haskell on IRC ;)
14:08:39 <notabel> ski: there is a typeable instance for IORef, so I don't see why it shouldn't work
14:08:40 <ski> stefan____ : well, i could try :)
14:09:03 * ddarius attempts to build Teyjus.  It's not going well so far.
14:09:08 <ski> (stefan____ : lots of people have started learning Haskell with the help of this channel, and some online material)
14:09:24 * ski has only tried Terzo
14:09:52 <geheimdienst> tensorpudding, in america there's a lot more empty than in europe
14:10:30 <copumpkin> a lot of the empty is really pretty though
14:10:42 <ski> (stefan____ : i was just trying to disabuse you of the notion that what you called "static polymorphism" vs. "dynamic polymorphism" had anything to do with "static / compile-time" vs. "dynamic / run-time" ;)
14:10:54 <tensorpudding> Yeah, there is.
14:11:00 <ben_m> my mobile phone autocompletes 'typeclassopedia' after I type in 'typec'
14:11:06 <ben_m> good phone.
14:11:10 * ben_m pets phone.
14:11:38 <aristid> @remember ben_m my mobile phone autocompletes 'typeclassopedia' after I type in 'typec'
14:11:39 <lambdabot> It is stored.
14:11:47 * geheimdienst suspects his android phone to complete based on his gmail account's contents. names and terms from long-passed projects show up in the autocompletion.
14:11:49 * ski 's brain often autocompletes "typo" into "type"
14:11:49 <Bobbias> lol
14:11:50 <ben_m> (Note that I never before typed typeclassopedia with that phone, so it can't have remembered it)
14:12:14 <stefan____> ski, if I understood you correctly c++ actually does call this static vs. dynamic polymorphism, even if the naming might be misguided
14:12:18 <aristid> @quote autocomplete
14:12:18 <lambdabot> ben_m says: my mobile phone autocompletes 'typeclassopedia' after I type in 'typec'
14:12:28 <ddarius> copumpkin: The empty parts are probably the prettiest parts.
14:12:34 <aristid> ben_m: whenever somebody talks about autocomplete now, you will be remembered :D
14:12:46 <stefan____> ski, static polymorphism -> template<typename T> void f(T){..} . dynamic polymorphism: struct base{ virtual void f(); } struct derived : base...
14:12:49 <ben_m> \o/
14:13:06 <aristid> ddarius: also the most interesting parts?
14:13:07 <geheimdienst> we could rig lambdabot to monitor what's being said and interject quotes
14:13:08 <copumpkin> I really want to see them :) I've hardly been to anything empty
14:13:20 <ddarius> aristid: In many cases, e.g. the national parks.
14:13:31 <ski> stefan____ : it might be that in how those concepts are available in C++, there actually is a static vs. dynamic assymetry, even though (what i take to be) the essence of those two concepts doesn't have that assymetry
14:13:40 <aristid> ddarius: relative to space, the non-empty places probably are more interesting still
14:14:06 <ben_m> geheimdienst: We had a markov chain bot in a channel once
14:14:14 <ben_m> That annoyed people who didn't know about it _a lot_
14:14:23 <ski> stefan____ : right, iirc, in a call to `template<typename T> void f(T){..}' it must always be statically resolvable what `T' is
14:14:29 <aristid> ben_m: haha that must have been fun
14:14:34 <ski> not so in Haskell
14:14:49 <aRcatan> Markov chain bots tend to be funny for ten minutes and after that very, very boring
14:14:54 <aristid> thanks to uniform representation?
14:15:10 <ddarius> aristid: At any rate, I suspect, overall, America is less interesting per acre than Europe.
14:15:13 <ski> aristid : was that to me ?
14:15:53 <aristid> aRcatan: well in one channel we have a markov chain bot (roughly, the precise algorithm is not known to me) for years, and it's still entertaining
14:16:03 <aristid> ski: yes
14:16:25 <geheimdienst> i guess markov chain things would be a good deal unfunnier than the lambdabot quotes archive
14:16:35 <ddarius> geheimdienst: Lambdabot can already do that.  Also Cale made MegaMonad many, many years ago.
14:16:56 <geheimdienst> the quotes are vetted to be the distilled wisdom of #haskell, after all
14:17:03 <ski> aristid : well, that's the typical way of implementing it. one could also have a scheme where one passes around representations of types at run-time, to polymorphic operations, where such representations would tell the layout of the data of the type in question
14:17:09 <geheimdienst> ddarius, enable it enable it enable it!
14:17:29 <iocor> how do I map [[a]]->[a] by concatenation?
14:17:37 <aristid> ski: true, but a c++-style implementation is unpossible.
14:17:38 <ddarius> Use concat.
14:17:55 <aristid> somehow in my mind concat has been almost replaced by join
14:18:04 <ski> (aristid : iirc, Mercury has something like that .. though i think there it's not really for non-uniform representation, but for carrying around implementations of equality (and ordering) checks)
14:18:53 <stefan_____> can anyone invent a USB cable that still works when you touch it
14:19:21 <aristid> stefan_____: yes, and i have sent it to the past and present with a time machine. you can buy it in any store
14:22:05 <ski> aristid : .. it could be possible to use in the cases where it's statically known (.. or one could use RTCG, i suppose)
14:22:29 <aristid> ski: hmm yeah
14:22:48 <geheimdienst> what do you recommend on the topic of cabal packages vs. distro packages? (arch in my case)
14:22:58 <aristid> geheimdienst: cabal
14:23:31 <Heffalump> arch tracks hackage pretty closely
14:23:40 <Heffalump> but I have no personal experience of using it
14:23:49 <aristid> Heffalump: oh, it's not always outdated?
14:24:21 <aristid> i wish cabal told me which packages are safe to upgrade
14:24:27 <Heffalump> dunno, but dons maintains the Haskell side of arch and he's quite aggressive generally :-)
14:24:45 <geheimdienst> back in my ubuntu days, i was fed up with the ass-old distro packages. so on arch i used cabal for everything. now all the installed stuff somehow evaporated because of some update or other, and since i read on ivanm's blog that cabal is not a real package manager ...
14:25:10 <geheimdienst> the distro packages would solve the problem of "what is safe to upgrade"
14:25:13 <aristid> Heffalump: hah, maybe i should switch to arch ;)
14:25:26 <geheimdienst> (if it's not in the distro, it's not safe)
14:25:39 <sm> is there one regex package that is free of c dependencies and fully cross platform ? I keep researching this and forgetting
14:25:41 <aristid> geheimdienst: yeah, if arch has good maintainers
14:26:01 <Saizan> sm: regex-tdfa?
14:26:42 <geheimdienst> however, i'm just discovering that many of haskell packages are in aur, not the regular repository. even run-of-the-mill stuff like missingh. aur is more hassle to install
14:26:55 <sm> oh, and that supports extended regexps ?
14:27:03 <aristid> geheimdienst: what is aur?
14:27:14 <Heffalump> geheimdienst: ah, I wasn't aware of a distinction. Told you I have no personal experience :-)
14:27:16 <sm> that's a promising one I haven't tried, thanks Saizan 
14:27:33 <Saizan> aur is a sort of hackage for arch :)
14:27:47 <aristid> Saizan: what does that mean?
14:27:54 <aristid> and which is the best linux for haskell? :D
14:27:57 <sm> ...and that doesn't have performance issues (regexpr)
14:28:04 <geheimdienst> it's kind-of an addon package repository. the upshot is that everyone can upload packages, the downside is that you should check the stuff you're installing because, well, anyone can upload stuff
14:28:27 <Saizan> also, it doesn't come with binaries
14:30:12 <ski> (.. "extended regexps isn't" ?)
14:30:40 <aristid> geheimdienst: ok so that's not really better than cabal
14:31:27 <geheimdienst> that's true. if a lot of haskell stuff was in the regular repos, i'd be happy, but as things stand ...
14:32:08 <aristid> geheimdienst: on the other hand, you don't have the package manager / cabal dichotomy anymore
14:32:32 <aristid> main and aur probably blend better than apt-get and cabal
14:33:04 <Cale> geheimdienst: I don't bother with Ubuntu's packages for anything Haskell-related (though I'll use them for underlying C libraries in the case of FFI bindings)
14:33:27 <Cale> geheimdienst: It's easiest just to download the generic linux binary of GHC, grab cabal-install, and go from there.
14:34:06 <aristid> Cale: he uses arch
14:34:25 <Cale> I doubt my choices would be very different on any other distribution :)
14:34:33 <geheimdienst> cale, yeah i've decided to keep caballing
14:34:41 <Cale> I'm planning to switch back to Debian when I get a new machine soon.
14:34:48 <Heffalump> I configure cabal-install to put my binary packages in a subdir of my GHC install.
14:34:54 <Heffalump> That way when I blow that away, the packages go too.
14:35:23 <geheimdienst> well arch does have the advantage that it's never out of date
14:35:43 <geheimdienst> (... very much)
14:47:14 <sm> what --extra-lib-dir path do you give cabal on windows, when you've installed c libs with cygwin ?
14:48:09 <sm> in the cygwin shell, cabal install --extra-lib-dirs=/usr/lib says that dir doesn't exist
14:48:27 <sm> in the dos shell, \cygwin\usr\lib is strangely empty
14:52:27 <dcoutts> sm: it's whatever the actual windows path for it is
14:52:45 <dcoutts> sm: cabal, ghc etc are all windows progs, not cygwin ones, they only understand windows paths
14:53:24 <sm> hi dcoutts, that's what I figured. I thought I'd find it under c:\cygwin\usr\lib
14:55:21 <sm> ah.. look like cygwin mounts /usr/lib from \cygwin\lib
14:56:41 <pokoko222> haskellers dear friends is it worth it to take a course called windows active directory?
14:56:50 <pokoko222> general computer science question:)
14:58:19 <p_l> pokoko222: are you planning to work as MS Windows network admin?
14:58:35 <p_l> or use AD infrastructure in projects?
14:58:51 <pokoko222> no but as a computer scientists in general i think it might benefit me, i am still noob in second year cs so...
14:59:08 <sm> so to use cygwin libs it's: --extra-lib-dirs=c:\cygwin\lib --extra-include-dirs=c:\cygwin\usr\lib
14:59:13 <Heffalump> Windows AD has very little to do with computer science.
14:59:58 <pokoko222> why? i mean you will get some experience with networks and stuff
15:00:01 <pokoko222> how is that not cs?
15:01:19 <Heffalump> computer science is about the theory behind such things, not highly specific details of implementations
15:01:50 <Heffalump> of course, what a university may advertise as computer science may not fit that description :-)
15:01:59 <pokoko222> well you gotta get your hands dirty first, theory only s useless?
15:02:12 <pokoko222> yeah true
15:02:59 <Heffalump> that's like saying Maths is useless without Physics. It's true in a sense, but irrelevant to the definition of what Maths is.
15:03:22 <Zao> I prefer "computing science"
15:03:41 <aristid> i prefer "Datalogi" (despite not speaking any danish other than that word)
15:05:00 * ski . o O ( "Datalogy" ? )
15:05:00 <Twey> pokoko222: CS is a branch of mathematics or science, depending on whom you ask, dealing with information and its representation.  It has very little to do with setting up computer systems.
15:05:26 <Twey> (or computers in general, in the abstract, though it does tend to be rather useful when designing certain types of software)
15:05:51 <pokoko222> Twey yeah man but as i said if you dont get your hands dirty and program shit here and there, theory is useless and you wont make much sucess 
15:06:27 <geheimdienst> didn't dijkstra say that computer science is no more about computers than astronomy is about telescopes
15:06:33 <Twey> Yep
15:06:35 <Twey> pokoko222: You won't encounter much CS in setting up an Active Directory server
15:06:43 <geheimdienst> so i can clearly see the appeal of "datalogy"
15:06:45 <Twey> pokoko222: Or, most likely, 90% of programming jobs
15:06:54 <Zao> Twey: An AD server uses trees. Trees are ADTs.
15:06:58 <Zao> Twey: See, SCIENCE!
15:07:03 <Heffalump> pokoko222: I'm not arguing about whether you should learn it or not, just whether it's valid to classify it as CS as you were doing.
15:07:06 <Zao> Heck, there's whole forests!
15:07:18 <Twey> ‘Datalogy’ is nice… there's also the European term ‘informatics’
15:07:28 <Twey> Though that has a rather poor connotation in English thanks to ‘IT’
15:07:42 <Zao> Twey: In my mind, informatics is a rather narrow subset dealing in data mangling.
15:07:42 <Twey> Zao: Yes, but you don't really have to understand how they're represented :þ
15:07:53 <sproingie> "informatics" tends to be prefixed with "bio" these days
15:08:10 <pokoko222> ok we have different opinions, but you say screw writing compilers just do computation theory
15:08:22 <geheimdienst> as far as germany and france are concerned, informatics is the word for what in english you'd call computer science
15:08:32 <Twey> Yep
15:08:41 <sproingie> i don't think we're going to settle the debate on the usefulness of pure philosophy
15:08:43 <Twey> pokoko222: I don't say anything of the sort
15:09:05 <Twey> pokoko222: If you feel like you might want to make a living setting up Windows servers, by all means take the Active Directory course — it'll serve you well
15:09:15 <Heffalump> I think in general writing compilers involves far more CS than learning Windows AD.
15:09:29 <Twey> pokoko222: However, you'll encounter about as much ‘computer science’ in that course as you would learning to bake pies
15:09:41 <sproingie> a curriculum on setting up AD servers would usually be classified in MIS
15:09:41 <pokoko222> :D oh come on dude are you serious?
15:09:42 <sproingie> not CS
15:09:58 <Twey> Compiler-writing involves much more CS, yes
15:10:05 <Twey> pokoko222: Yes, completely serious
15:10:08 <pokoko222> well you gotta get the hands dirty before you do cs, otherwise you do theory and u dont know what a fuck you are doing
15:10:14 <sproingie> CS: Completely Serious
15:10:18 <Twey> Computer science and systems administration are *completely* different things
15:10:26 <geheimdienst> CS: Casually Serious
15:10:32 <Twey> There is no necessary relation between them
15:10:40 <sproingie> pokoko222: your opinion is a unique little snowflake to be treasured
15:10:55 <pokoko222> ok i think i know what to do
15:11:07 <pokoko222> being a computer science noob second year student i will enroll the course and see what i learn
15:11:08 <Twey> pokoko222: ‘Getting your hands dirty’ is all very fine and good, but you won't be doing any of that on the AD course (related to CS, anyway)
15:11:16 <sproingie> what do you suggest mathematicians "get their hands dirty" with?
15:11:21 <Twey> pokoko222: Writing a compiler might well qualify as ‘getting your hands dirty’ with CS.
15:11:43 <Heffalump> pokoko222: sounds like you're a MIS or computer engineering student, whatever your university may claim ;-)
15:11:58 <pokoko222> well to do theory first you gotta have something concrete to do the theory about, you gotta have practical cs experience ladies
15:12:13 <Twey> pokoko222: I don't entirely agree, but I can see where you're coming from with that.
15:12:20 <sproingie> pokoko222: on what do you base that?
15:12:31 <Twey> pokoko222: However, as I said before, setting up an Active Directory server is *not* practical CS experience.
15:13:01 <pokoko222> u saying the course is crap? i mean i dont even know what i will study there, all i know is that it is about networks and administration 
15:13:11 <Twey> I'm not saying it's crap.  I'm saying it's not about computer science.
15:13:13 <pokoko222> microsoft certified
15:13:18 <pokoko222> ah ok
15:13:43 <Twey> It will have absolutely no bearing on what you'll probably learn in your CS course.
15:13:47 <sproingie> it may be a perfectly good course that isn't CS
15:13:49 <geheimdienst> pokoko222, maybe #haskell is not entirely the right place to talk "practical" ;) we prefer to generalize our generalizations so that they cover more generalizations. which somehow makes the code longer, but what the heck
15:13:52 <ski> sproingie : making paper models of star polytopes ?
15:14:18 <pokoko222> sproingie well said 
15:14:30 <Entroacceptor> a mathematician gets his hands dirty if there's an actual number somewhere
15:14:46 <aristid> Entroacceptor: does pi count?
15:14:47 <geheimdienst> (which may well be a letter)
15:14:48 <ddarius> Entroacceptor: That's not true at all.
15:15:05 <FunctorSalad_> is there a lib that parses /proc/$PID yet? (in other words, a haskell ps)
15:15:05 <pokoko222> math is about structure too, not just numbers
15:15:08 <sm> oh my god. Can someone give an example of how to set regex options like (?i) with the regex-base api ?
15:15:20 <FunctorSalad_> I straced ps and apparently it simply reads the files there
15:15:29 <Entroacceptor> ddarius: it's not?
15:15:46 <monochrom> a mathematician gets his hand dirty iff he/she does not generalize.
15:15:51 * FunctorSalad_ is interested in what sm is asking too...
15:15:56 <sm> I'm enmeshed in http://hackage.haskell.org/packages/archive/regex-base/0.93.2/doc/html/Text-Regex-Base.html . The horror!
15:16:02 <FunctorSalad_> sm: iirc it's obvious with pcre-light
15:16:19 <sm> yes indeed, that's why I used that till now
15:16:32 <sm> but it's not windows-friendly
15:16:37 <FunctorSalad_> I see
15:17:27 <ski> "If this still sounds too abstract, let's do an example. Do I sound repetitious? Well, you see, category theory is the subject where you need examples to explain your examples - and `n'-category theory is the subject where this process needs to be repeated `n' times." -- John Baez, This Week's Finds in Mathematical Physics (Week 300)
15:17:39 <ski> geheimdienst : somehow, your comment made me think of that ^
15:17:47 <monochrom> haha
15:18:09 <geheimdienst> nice :)
15:18:15 <sproingie> i read that attribution as Joan Baez
15:18:28 <sproingie> talented lady
15:18:30 <Entroacceptor> (me too)
15:18:39 * ski idly wonders who this "Joan Baez" might be ..
15:18:57 <FunctorSalad_> daughter? :)
15:19:16 <Entroacceptor> here's to you, lambda and monad
15:19:24 <Entroacceptor> rest forever, here in our hearts...
15:19:47 <sproingie> ♫♫ they paved paradise to put up a polytope ♫♫
15:20:20 <sproingie> i guess that's joni mitchell
15:21:46 <sm> regex-base source kept in cvs.. on sourceforge.. checkout instructions at http://sourceforge.net/projects/lazy-regex/develop not helping.. help ?
15:23:20 <geheimdienst> so to parse "key: value" files like /proc/cpuinfo, do you feel i should use parsec? or is it acceptable to just do lines and span (/= ':')
15:24:19 <aristid> geheimdienst: if lines and span works, why not
15:24:39 <Veinor> sm: I'm trying to figure it out
15:24:41 <Twey> geheimdienst: I'd probably lines 'n' span it for something that simple
15:25:13 <geheimdienst> okay i'm sold :) thanks guys
15:25:25 <geheimdienst> just wanted to know if there's red flags
15:25:40 <sm> Veinor, thanks. It didn't like my guess for modulename and co -c doesn't list any. I downloaded the tarball and I'm not sure this is even the right repo for regex-base
15:26:28 * sm saw joan baez live in santa monica last year.. she kicked ass
15:26:48 <Twey> geheimdienst: The biggest issue would be using lazy IO
15:26:57 <Twey> geheimdienst: But for /proc/cpuinfo you can probably just use strict
15:28:30 <geheimdienst> thanks for the headsup
15:29:20 <aristid> hmm
15:29:44 <aristid> geheimdienst: /proc/cpuinfo seems to have a slightly more complex format, it's x\t: y\n
15:31:03 <geheimdienst> bah, i'll just run trim on everything
15:31:04 <geheimdienst> :)
15:32:44 <Twey> Grab Data.List.Split and use splitOn?
15:33:06 <aristid> Twey: then parsec is already easier i guess
15:33:43 <ddarius> second (tail . tail . tail) . break (':' ==)
15:34:00 <ddarius> Or I guess drop 3
15:34:07 <Twey> second … yeah :þ
15:35:37 <geheimdienst> > (second (tail . tail . tail) . break (':' ==)) "lolcats: ftw"
15:35:38 <lambdabot>   ("lolcats","tw")
15:35:47 <geheimdienst> what's that supposed to be
15:36:10 <hpc> it's a really hacky config parser, it seems
15:36:13 <Twey> It's "lolcats\t: ftw" according to the format geheimdienst gave
15:36:17 <aristid> map (second (drop 3) . break ('\t' ==)) . lines
15:36:19 <aristid> this works
15:36:38 <aristid> Twey: i gave the format
15:36:50 <Twey> Er, yes
15:36:52 <Twey> Sorry
15:36:53 <geheimdienst> hpc, true. i looked at the configparser package, but it seemed complicated
15:36:54 <aristid> :P
15:37:03 <Twey> I actually meant you… it just came out wrong :þ
15:37:05 <geheimdienst> for one thing, i don't need any write capability at all
15:37:34 * sm finds http://code.haskell.org/regex-base/
15:39:45 <ddarius> Curse you and your non-standard notion of substitution.  We'll see what happens.
15:40:19 <ski> > (Data.Traversable.traverse (stripPrefix "\t: ") . break (== '\t')) "foo\t: bar"
15:40:20 <lambdabot>   No instance for (Data.Traversable.Traversable
15:40:20 <lambdabot>                     ((,) [GHC...
15:40:22 <ski> hmpf !
15:41:24 <aristid> > map (second (stripPrefix "\t: ") . break (== '\t')) ["foo\t: bar"]
15:41:26 <lambdabot>   [("foo",Just "bar")]
15:41:58 <aristid> wait, why does that even work? :D
15:42:06 <aristid> > map (second (stripPrefix "\t: ") Prelude.. break (== '\t')) ["foo\t: bar"]
15:42:07 <lambdabot>   Not in scope: `Prelude..'
15:42:16 <aristid> oh-kay
15:43:30 <ski> @type map (second (stripPrefix "\t: ") Prelude.. break (== '\t'))
15:43:31 <lambdabot> [[Char]] -> [([Char], Maybe [Char])]
15:43:39 <djahandarie> > map (second (stripPrefix "\t: ") Prelude.(.) break (== '\t')) ["foo\t: bar"]
15:43:39 <lambdabot>   Not in scope: data constructor `Prelude'
15:44:11 <aristid> :t stripPrefix
15:44:12 <ski> > map ((Prelude..) (second (stripPrefix "\t: ")) (break (== '\t'))) ["foo\t: bar"]  -- not in scope ..
15:44:12 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
15:44:13 <lambdabot>   Not in scope: `Prelude..'
15:44:26 <aristid> ooh, it's the stripPrefix that adds the Maybe
15:44:39 <ski> yeah, and i wanted to hoist it out of the pair
15:46:20 <geheimdienst> @let trim s = d $ reverse (d $ reverse s) where d = dropWhile isSpace
15:46:28 <geheimdienst> > trim "  lol   "
15:46:44 <aristid> lambdabot seems slow :(
15:47:29 <ddarius> @bot
15:47:56 <aristid> ski: \(a, b) -> (a, ) <$> stripPrefix "\t: " b
15:48:38 <ski> aristid : but but, that so .. lowlevel
15:49:08 <aristid> ski: because it's not point-free?
15:49:14 <aristid> it uses a language extension!
15:49:59 <ski> because one has to take apart and reconstruct the pair manually
15:50:14 * hackagebot yajl-enumerator 0.1 - Enumerator-based interface to YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-enumerator-0.1 (JohnMillikin)
15:52:35 <aristid> ski: find a better alternative:)
15:56:28 <sykopomp> I heard there was either an implementation, or a paper, of an extensible version of Haskell's type system (a-la-MOP). I'm trying to find more info on this.
15:56:46 <ski> like how `catchJust fooException (liftM Right ma) (return . Left) >>= \ea -> case ea of Left e -> ..e..; Right a -> ..a..' feels lowlevel
15:58:08 <ski> sykopomp : .. hm, extensible, how ?
15:58:12 <jedai> > fmap (+2) (1,1)
15:58:40 <sykopomp> ski: programmable might be a better term? I'm hoping for something like a metaobject protocol, but for haskell's type system.
15:59:30 <jedai> aristid,ski: fmap (stripPrefix "\t:") ??
15:59:45 <ski> sykopomp : i'm not even sure what it would mean
15:59:46 <pavpanchekha> Question on the IO monad
16:00:00 <ski> jedai : that doesn't hoist the `Maybe' out of the pair
16:00:27 <pavpanchekha> I want to write a function to print "Hello World!" an infinite number of times
16:00:39 <pavpanchekha> with ``main = loop_happy (putStrLn "Starting") >> putStrLn "Done"``
16:00:46 <pavpanchekha> and some function `loop_happy`
16:01:20 <pavpanchekha> any way I can write such a `loop_happy` that'll actually _print_ "Hello, World!" as it goes, not loop forever silently?
16:01:22 <sykopomp> ski: perhaps, for example, making Haskell's type system not be nominative, or auto-generating unique names for types that can't be unified.
16:01:37 <ski> sykopomp : i mean, with a (long) stretch, it might refer to loading code which uses new types, at run-time, or maybe to extensible records/variants .. if that's not what you heard about, then i don't know
16:01:49 <pavpanchekha> I've tried ``loop_happy io = loop_happy $ io >> print "Hello, World!"
16:01:53 <pavpanchekha> ``
16:02:31 <sykopomp> ski: Nah, I was thinking more something that would allow for more extreme alterations of the way the type system works, by the user.
16:02:34 <monochrom> what's wrong with «main = putStrLn "hello world" >> main» ?
16:02:42 <sykopomp> (a "write your own type system" sort of thing)
16:03:25 <ski> sykopomp : ok. i don't know about that (i know very little about MOP, btw)
16:04:30 <ski> pavpanchekha : you realize that parses as `loop_happy io = loop_happy $ (io >> print "Hello, World!")', yes ?
16:04:41 <pavpanchekha> ski: yes, I do
16:04:51 <pavpanchekha> monochrom: Yeah, that'd work, but suppose `loop_happy` might, or might not, loop forever
16:05:00 <ski> so, that's tail-recursive, doing nothing before the recursive call
16:05:28 <ski> it just loops around, constructing longer and longer actions which are passed around in the argument
16:05:47 <pavpanchekha> ski: right, but it never actually prints anything
16:05:56 <monochrom> why should we care about loop_happy? your specification is just "I want to write a function to print "Hello World!" an infinite number of times" and that is all.
16:06:06 <ski> right, it never uses the action(s) it constructs
16:06:23 <monochrom> if you don't want that function to be main, «f = putStrLn "hello world" >> f»
16:06:24 <pavpanchekha> ski: sorry, let me make the example specification a bit better
16:06:44 <ski>   f = forever (putStrLn "hello world")  -- or even this ..
16:07:00 <pavpanchekha> read in a number, if that number is 2 loop forever printing "Hello, World!", otherwise print it just once
16:07:05 <pavpanchekha> (last message to ski)
16:07:42 <pavpanchekha> ski: the point is that while it constructs them, it just sits there silently. I'd like it to actually print them
16:07:45 <ski> ok, so "forever printing \"Hello, World!\"" is a sub-problem of that
16:08:02 <ski> then why not tell it to actually *use* the action ? :)
16:08:17 <pavpanchekha> ski: how?
16:08:17 <ski>   loop_happy io = loop_happy (io >> print "Hello, World!")
16:08:20 <ski> is comparable to
16:08:26 <ski>   foo n = foo (n + 1)
16:08:31 <monochrom> main = do { n <- readLn; if n==2 then forever (putStrLn "hello world") else putStrLn "hello world" }
16:08:34 <ski> it just loops around
16:08:53 <pavpanchekha> monochrom: Any way I can break out the "looping" behavior into another function?
16:09:16 <monochrom> "forever" already did. Find it in Control.Monad
16:09:23 <ski> pavpanchekha : well, since you're doing an infinite loop (in a "strict" monad), you need to tell it to do some actual work, before looping around
16:09:47 <pavpanchekha> monochrom: Misspoke; break the checking-if-two-and-then-maybe-looping into another function
16:10:13 <pavpanchekha> ski: alright, you mean to pass some of my IO ()'s up to main and then continue looping?
16:10:29 <pavpanchekha> ski: or is there some way to do that automatically?
16:10:30 <monochrom> Then let's calculate.
16:10:31 <ski> pavpanchekha : so, define `loop_happy io' to be an action that *first* does some actual work, *then* loops around
16:10:39 <monochrom>   if n==2 then forever (putStrLn "hello world") else putStrLn "hello world"
16:10:58 <monochrom> = let x = putStrLn "hello world" in if n==2 then forever x else x
16:11:06 <ski> pavpanchekha : well, i don't really see why you're passing around any `IO'-actions at all here
16:11:13 <pavpanchekha> monochrom: Perfect, but that doesn't actually ever print anything, it just waits forever...
16:11:19 <monochrom> You can lambda-abstract that to \x -> if n==2 then forever x else x
16:11:57 <monochrom> main = do { n<-readLn; (\x -> if n==2 then forever x else x) (putStrLn "hello world") }
16:11:59 <ski> pavpanchekha : monochrom's version *does* print stuff
16:12:26 <ski>   main = do { n<-readLn; (if n==2 then forever else id) (putStrLn "hello world") }  -- :P
16:12:36 <ddarius> monochrom: Nice implementation of non-recursive, non-generalizing let.
16:13:00 <pavpanchekha> ski: http://dpaste.com/233044/
16:13:16 * ddarius thinks he broke the Twelf website.
16:13:19 <monochrom> I learned it from theorem prover manuals
16:13:35 <ski> pavpanchekha : you forgot to feed it a number for the `readLn' action
16:13:51 <pavpanchekha> ski: oh, shit, I'm an idiot
16:13:52 <monochrom> some theorem prover defines "let is syntax sugar for (\x -> ...) y"
16:14:18 <ski> (that's also a possible way to define `let' in Scheme)
16:15:02 <pavpanchekha> ski: ah, ok, hmm, now I have to go and think about how that is related to my code...
16:15:18 <pavpanchekha> ski, monochrom: Meanwhile, thanks for your help
16:15:39 <ski> sykopomp : btw, i suppose you have no idea where you heard of this extensible type system version ?
16:16:13 <sykopomp> ski: I was musing about the idea, and someone told me it had already been done.
16:16:22 <sykopomp> but they didn't really have any useful details.
16:16:23 <sykopomp> :(
16:16:35 <sykopomp> this was over in #lisp
16:17:26 * ksf would like to export the qualificatedness of an import
16:18:30 <ksf> that is, if Foo imports Bar qualified as B and exports module B,  then Baz who imports Foo as Foo can get at Bar's decls with F.B.<decl>
16:18:58 <ksf> s/as Foo/qualified as F
16:19:37 <ksf> -XQualifiedExports
16:19:40 <ksf> any takers?
16:21:14 <geheimdienst> i'm looking for a function like &&& but returning a list, not a tuple
16:21:30 <geheimdienst> and which handles chains better:
16:21:33 <dibblego> is there a class C m where k :: m a -> m [a] ?
16:21:39 <geheimdienst> > (id &&& id &&& id) "lolcats"
16:21:48 <ski> (sykopomp : appears not be be in the recent few days, according to my backlogs ..)
16:21:53 <geheimdienst> bah. anyway, what comes out is (x, (x, x))
16:22:29 <dibblego> geheimdienst, have you looked at HList?
16:22:41 <geheimdienst> not yet, thanks for the pointer
16:23:10 <geheimdienst> oh, it's an extra package? is just wanted a plain old list instead of the tuple
16:23:11 <ski> dibblego : sounds like `mappend' in `Monoid (a -> [b])'
16:23:25 <ski> er, s/dibblego/geheimdienst/
16:23:27 <dibblego> ski, I want e.g. instance C [] where k = tail
16:23:37 <ksf> :t (&&&)
16:23:40 <geheimdienst> ski, could you phrase that in newbie speak?
16:23:45 <ksf> @botslap
16:24:11 <geheimdienst> ksf, it takes 2 functions and runs them both on the arg. (id &&& (+1)) 42 -> (42, 43)
16:24:24 <ski> geheimdienst : `(id ++ id ++ id) "lolcats"', if `mappend' is written `(++)'
16:24:24 <geheimdienst> it's from C.Arrow
16:24:48 <ski> dibblego : illtyped
16:25:04 <dibblego> ski, you're right, I have the type-class wrong
16:25:19 <ski>   (&&&) :: Arrow (~>) => (a ~> b0) -> (a ~> b1) -> (a ~> (b0,b1))
16:25:26 <geheimdienst> ski, (id `mappend` id) "lol" gives me "lollol"
16:25:36 <ski> geheimdienst : right
16:25:47 <ddarius> geheimdienst: Give an example of input and output.
16:25:55 <dibblego> > mconcat (replicate 3 id) "lolcats"
16:26:13 <geheimdienst> (id ?? id ?? id) "lolcats" ["lolcats", "lolcats", "lolcats"]
16:26:16 <ski> geheimdienst : hm, maybe you wanted `["lol","lol"]' ?
16:26:50 <geheimdienst> now &&& is kinda like that: (id &&& id &&& id) "lolcats" gives ("lolcats", ("lolcats", "lolcats"))
16:27:14 <geheimdienst> (btw, the list above is supposed to be the result)
16:27:25 <ski> (you forgot to write a `=' sign)
16:27:34 <geheimdienst> of course id is a silly function, but you get the idea
16:28:18 <ski> geheimdienst : you could say `(return . id) ++ (return . id) ++ (return . id)' .. but somehow i think you don't like that
16:28:28 <ddarius> geheimdienst: You'll need something to terminate.  f ?? g ?? nil "foo" = [f "foo", g "foo"], f ?? xs = \ys -> f ys : xs, nil = \ys -> []
16:28:29 <geheimdienst> "take two functions. on the same arguments, run both functions, giving their results in a list"
16:28:30 <ski> (or replace `return' with `(:[])' if you prefer)
16:29:18 <ski> geheimdienst : yeah, but if you want to give a doubleton list there, then the associative law is not well-typed
16:29:48 <ddarius> xs ys
16:30:07 <ski> i.e. `(id ### id ### id) "foo"' would be `["foo",["foo","foo"]]', which is not well-typed
16:30:18 <ksf>     Illegal type variable name: `String'
16:30:18 <ksf>     When splicing a TH declaration:     
16:30:24 <mrsolo> So there is Text.Parsec and there is Happy/Alex... when to use what?
16:30:26 <geheimdienst> okay i see
16:30:30 <ski> .. which is why i thought you wanted to concatenate the results from the two functions
16:30:35 <ksf> ...I'm double-'' ing them and I'm trying to put it into a VarT
16:30:47 <aristid> is there a function like inRange a b x = a <= x && x <= b?
16:30:58 <aristid> :t let inRange a b x = a <= x && x <= b in inRange
16:31:16 <geheimdienst> ok thanks so far, guys
16:31:22 <aristid> lamaaambdabot!
16:31:34 <ski>   inRange :: Ix a => (a, a) -> a -> Bool
16:31:37 * mrsolo reading through haskell platform documentation..
16:31:59 <geheimdienst> @seen cale
16:31:59 <preflex>  cale was last seen on #haskell 1 hour, 57 minutes and 18 seconds ago, saying: I'm planning to switch back to Debian when I get a new machine soon.
16:32:05 <ski> aristid : ^ would that do ?
16:32:22 <ski> (in `Data.Ix')
16:33:07 <aristid> ski: no :/
16:33:12 <ski> why ?
16:33:12 <aristid> i only have Ord
16:33:23 <aristid> and all classes provided by LocalTime
16:33:32 <ski> ok
16:36:47 * ski notes that `Data.Ix.inRange' is not consistent with what aristid wanted, anyway ..
16:37:15 <aristid> ski: it's not?
16:37:31 <aristid> looks like an uncurried version of it
16:37:33 <ski> (`Data.Ix.inRange' works with a partial order, for tuple types, not the total order that `Ord' uses)
16:37:36 <ksf> ...ConT is the solution
16:37:50 <ksf> did I already mention that TH is utterly underdocumented?
16:38:11 <ski> (ksf : .. continuations is *always* the solution)
16:38:30 <ksf> ConT is actually a type constructor.
16:38:48 * ski 's brain spell-corrected it to `ContT' :)
16:38:51 <ksf> I was using VarT because I thought "well, you want to reference a binding"
16:39:13 <ksf> ...not realising Haskell has such fancy stuff like polymorphism.
16:39:46 <ksf> still, there should be haddock comments that tell what all those abbrvnms stand for.
16:39:55 * ski doesn't know how polymorphism is relevant, not knowing that much about TH
16:40:05 <ksf> well, type _variable_.
16:40:18 <ksf> those lowercase ones, in contrast to uppercase constructors.
16:40:27 <ksf> ...even if those constructors are *-kinded.
16:40:39 <ksf> and therefore don't really construct stuff but are themselves.
16:40:49 * ski cares not about `*'-kindness, for "type constructor" :)
16:41:06 <ski> (`False' constructs a `Bool')
16:43:27 <BMeph> "Objects Have Failed" is very interesting to read coming from a Haskell perspective. It'd never have occured to me to criticize Java for having a too-precise type system. Too clunky, sure, but too precise?
16:44:20 <ksf> link or objects didn't fail.
16:44:33 * ksf can't believe he just wrote that.
16:45:06 <monochrom> hahahaha
16:45:21 <ksf> I thought Oleg settled the question?
16:45:37 <codolio> Did he?
16:45:46 <anair_84> Had a newbie question, I am new to learning haskell, and the learning but the curve is quite steep , is there something I can contribute that can be semi-useful to haskell community and help in the learning process, any bugs to investigate or other errands that need doing, I have free time.
16:45:46 <aristid> there is no drawback to having a lot of "where" definitions which are evaluated only conditionally, right?
16:45:47 <ezyang> He wrote an essay about it. 
16:45:48 <monochrom> obituary or he's still alive?
16:45:59 <ezyang> http://okmij.org/ftp/Computation/Subtyping/ 
16:46:10 <dolio> Oh yeah. I've read that one.
16:46:23 <ezyang> Basically, the OOP notion of "subclass" conflates subtyping with some sort of extension-thingy-ma-jigger 
16:46:24 <dolio> I suppose that is a condemnation of quite a lot of OO practice.
16:46:40 <ksf> http://okmij.org/ftp/Computation/Subtyping/
16:46:43 <danportin> I am trying to thread state through a series of operations, but also halt the operations of certain states occur. Doing either one individually is no problem, but I'm having a hard time lining the types up when I want to cease performing the operations (i.e., returning an 'M b'). I'm not sure how I can get line 26, here, to return the correct type. <http://hpaste.org/fastcgi/hpaste.fcgi/view
16:46:43 <danportin> ?id=29392#a29392>
16:46:58 <monochrom> the only contribution we need for learning haskell is an eraser for the brain. to unlearn wrong previous prejudice.
16:47:01 <ksf> anair_84, documentation.
16:47:26 <ezyang> If anyone has a name for the "other thing" subclassing is used for, I'd love to here it. 
16:47:27 <ezyang> *hear 
16:47:37 <ezyang> It might be code reuse, but that doesn't seem totally accurate. 
16:47:40 <ksf> ...that choice of mine might be influenced by the fact that I just wasted 20 minutes due to missing docs
16:47:49 * QtPlatypus recalls a construction of binary trees that made the size of the trees a part of the trees type and enforced compleate balance due to this "I can't recall where it was or how exactly it was done.  Does this ring anyone's bells?"
16:48:05 <anair_84> ksf: documentation where ?
16:48:06 <QtPlatypus> anair_84: I've been lloking for something like that myself"
16:48:28 <ksf> whereever any is lacking. wherever it's not adequate.
16:48:51 <anair_84> you mean adding documentation to GHC code ?
16:49:02 <ksf> nothing teaches one more than figuring out some interface and adding proper documentation
16:49:09 <ksf> no, some stuff on hackage.
16:49:37 <anair_84> ksf : you mean code people have submitted ?
16:49:46 <anair_84> that does sound like a good idea
16:49:56 <ksf> it also gives you an excuse to read code, which you should do a lot as a newbie
16:50:01 <QtPlatypus> ksf: Getting some of the libaries where the only documentation is the type indexes and writing it up?
16:50:02 <blackh> anair_84: Are you interested in XML at all?  I've got an XML library that I want to add a bit of polish to.
16:50:09 <ksf> QtPlatypus, exactly.
16:50:20 <ksf> or where the existing docs are utterly cryptic
16:50:21 <anair_84> blackh : sure
16:50:44 <ksf> uu-parsinglib comes to mind.
16:50:45 <QtPlatypus> ksf: I'll look into doing that in my CFT
16:51:12 <ksf> there are examples, but those aren't really helpfull.
16:51:43 <anair_84> so it should be submitted as a patch to the hackage codebase?
16:51:55 <blackh> anair_84: I'd like to improve the test cases and documentation, and there is some cool Haskell stuff in there.  You could just take a look and see what takes your fancy.
16:52:07 <blackh> http://hackage.haskell.org/package/hexpat
16:52:23 <ski> anair_84 : also, don't write a monad tutorial
16:52:23 <blackh> I want to get it polished up and then do a 1.0 release.
16:52:26 <ksf> anair_84, each package lists a maintainer.
16:52:34 <anair_84> hexpat i like the name 
16:52:41 <ski> ezyang : "(implementation) inheritance" ?
16:52:41 <ksf> if the maintainer doesn't show up, ask an admin
16:53:21 <blackh> anair_84: I am trying to take over the world with my XML library, well at least the bit of the world relating to XML and Haskell. :)
16:53:23 <ski> ezyang : .. btw, note that (co)inheritance is used often in math
16:54:00 <anair_84> I can look into hexpath , will see if my adding documentation helps too
16:54:06 <blackh> anair_84: I've designed it so you can jump right in and get stuff done, and if the documentation was a bit more tutorial-like it could be really good.
16:54:26 <blackh> anair_84: On the front page you'll see I've listed starting points depending on what you want to do.
16:54:30 <anair_84> how does one contact admins , who are they ?
16:54:36 <ddarius> ski: Mathematical structures are usually immutable so its much easier to have inheritance and subtyping coincide.
16:54:44 <blackh> anair_84: Admin email addresses are listed on the packages on hackage.
16:54:53 <blackh> anair_84: Ignore me.
16:54:54 <ksf> anair_84, or just here.
16:55:15 <blackh> anair_84: I'm not sure how to contact the admins of hackage.
16:55:20 <ksf> or on the cafe, for that matter.
16:55:35 <anair_84> k
16:55:42 <ski> ddarius : yeah .. (i was only thinking about the inheritance part, here)
16:55:47 <ksf> if you have a decent patch I very much doubt the community is going to make it hard for you to get included.
16:56:05 <anair_84> k blackh I can work with you .
16:56:12 <anair_84> k thanks, ksf 
16:57:21 <ezyang> ski: I could buy that. What is the mathematical notion of inheritance? 
16:58:19 <dolio> A ring is a group with ...
16:58:21 <blackh> anair_84: Great! Well, I have this great vision with hexpat which is about 95% realized.  hexpat is designed so that another package, hexpat-iteratee, can provide chunked XML parsing.  That's why the types look a little odd.
16:58:26 <ksf> I thought mathematicians don't progenate?
16:58:35 <ezyang> dolio: ...sure. 
16:58:48 <monochrom> A ring inherits from a group and a monoid.
16:58:48 <blackh> anair_84: Do you understand the issues with lazy I/O and the reason behind iteratees and all that stuff?
16:58:52 <ski> ezyang : i was thinking of *use* of (co)inheritance when you have proved a theorem on an inductive datastructure, then you extend the inductive datastructure with a few more cases, and then extend the former proof with a new branch for each case
16:58:56 <ddarius> ksf: Are you making up words?
16:59:09 <ksf> all nouns can be verbed.
16:59:09 <anair_84> blackh : some what still learning
16:59:34 <blackh> anair_84: Are you sitting comfortably? Then I'll begin. :)
17:00:07 <anair_84> yeah
17:00:14 <ski> monochrom : i think you're talking (more or less) about subtyping (sometimes called "interface inheritance"), here. (i was talking about "implemenation inheritance", often called just "inheritance")
17:00:18 <ddarius> Iteratees are Haskell programmers taking straightforward imperative ideas and making them seem new and complex.
17:00:37 <blackh> anair_84: Well, the problem with lazy I/O as implemented by functions like getContents and readFile is that it's making things referentially transparent that are not quite referentially transparent.
17:01:07 <ksf> also, number of open file handles.
17:01:09 <anair_84> blackh: k
17:01:18 <monochrom> inheritance as a proof technique?
17:01:44 <dolio> blackh: I've seen no convincing evidence that lazy IO isn't referentially transparent.
17:02:21 <ksf> it's certainly more so than unsafeMMap
17:02:30 <ezyang> ski: Hm. I guess I have seen proofs that sort of look like that (although I see it in mostly a pedagogical context.) 
17:02:43 <monochrom> logic courses have lots of that.
17:03:02 <ksf> the problem, put bluntly, is that you can't easily be sure that you're done reading in some file with lazy IO.
17:03:09 <ksf> therefore, you don't know when to close it.
17:03:24 <monochrom> first "every FOL formula has finite length". then "every modal FOL formula has finite length too", adapt proof from former.
17:03:47 <blackh> dolio, anair_84: Well, at least there are problems with lazy I/O. One of them is that if you have a long-running process that, say, reads a config file with readFile, then you can never be quite sure that the file has been closed.  If you later change the config file, it could be locked (on Windows, as least), and you won't be able to write to it.
17:03:49 <monochrom> "this logic enjoys cut-elimination" "this variation too"
17:03:50 <ksf> iteratees are an approach to get the ease of composition that lazy IO offers, while keeping things strict.
17:04:02 <blackh> Also you can run out of file handles if they don't get garbage collected fast enough.  This is a potential problem on busy servers.
17:05:01 <ski> ksf : you should never explicitly close a file you're using lazy I/O on
17:05:24 <ski> (it will be closed on GC or end-of-list)
17:05:41 <roconnor> also you should never explicitly close a file a file that is being read from in a different thread
17:05:44 <geheimdienst> in foo.cabal, if i say build-type: Simple, i omit a Setup.lhs and it uses the default one. if i say build-type: Custom, i can give my own Setup.lhs. is that right?
17:05:59 <blackh> anair_84: Anyway, that doesn't concern hexpat all that much, except that it explains why I've made the list type a parameter instead of just ordinary old []
17:06:14 <monochrom> but proof inheritance is really hairy even in the hands of mathematicians.
17:06:15 * ddarius should perhaps use Yarrow or something similar.
17:06:38 <ksf> ski, I use iteratees for all my IO.
17:06:45 <anair_84> k
17:07:07 <ski> (`Yarrow' somehow relating to `Yoneda' and `Arrow' ?)
17:07:13 <blackh> anair_84: Also I want to improve the test cases for hexpat but I understand that's not exactly exciting work. :)
17:07:13 <ddarius> No.
17:07:49 <ski> monochrom : i don't disagree :)
17:08:01 <anair_84> so improve testcases 
17:08:08 <blackh> anair_84: At any rate, if you play with hexpat you'll learn a lot about type classes.
17:08:10 <ddarius> I really want to write: category : type, set : category, unit : set and more complex things.
17:08:30 <benmachine> ski: it's not an error to close a file multiple times
17:08:30 <ddarius> I can get a similar effect in a more cumbersome way though.
17:08:49 <anair_84> k I can read hexpat add documentation and test cases , and let you know ?
17:09:20 <anair_84> and read up on Iteratees
17:09:27 <blackh> anair_84: I'd be your friend forever!  I'm always 'blackh' on IRC even if I am not in #haskell.
17:09:50 * ddarius vacillates between early and late checking.
17:09:55 <anair_84> haha, k sure np
17:10:00 <monochrom> Forever Friends are a lot of cute bears
17:10:07 <dolio> Write up a language based on 2-logic.
17:10:28 <blackh> anair_84: iteratees are difficult to understand, but the implementations are improving quickly and it'll all get easier.  The documentation is terrible in iteratee but there's a rival package, enumerator.
17:10:58 <ksf> ouch pretty printing of TH type applications is badly broken.
17:11:17 <anair_84> k 
17:11:25 <blackh> anair_84: Actually there is almost no useful documentation for iteratees, except I think the enumerator package fixes that somewhat.
17:11:46 <djahandarie> Doesn't snap talk about them a little in its documents?
17:11:51 * djahandarie doesn't remember
17:11:57 <ksf> there's some decent blog posts
17:12:07 <anair_84> I see some presentations
17:12:14 <ksf> but the best way to understand them still is to implement them, I think
17:12:23 <anair_84> http://okmij.org/ftp/Streams.html#iteratee
17:12:37 <ksf> ...a typical oleg situation.
17:12:42 <djahandarie> class MyProgram implements Iteratees?????
17:12:57 <monochrom> implementation inheritance of knowledge :)
17:14:13 <monochrom> invent you an iteratee for great good
17:14:24 <dolio> Iteratees are essentially an inversion via delimited control of a function ([String] -> a).
17:14:46 * ksf can donate yet another prototype iteratee implementation, but there's no docs, either.
17:15:00 <dolio> If I understand correctly.
17:15:04 <Bobbias> I've got a question: I've taken a piece of code that gives me a list of primes (well, seives out composites) and a list comprehension to give me all the primes under a given number, but when i run my comprehension through ghci it sits at the last number and refuses to actually close the list and finish. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29395#a29395
17:15:37 <dolio> Of course, you can't invert a function with that type so easily, so it's more like (MList m String -> m a)
17:15:57 <blackh> anair_84: http://random.axman6.com/blog/?p=157  <-- this is what I'm trying to do with hexpat-iteratee, in case you're interested in that.
17:16:04 <djahandarie> My co-worker was trying to explain class-based inheritence via plato's theory of forms the other day to some random executive people...
17:16:08 <ksf> Bobbias, well, ghc isn't smart enough.
17:16:29 <ksf> x < y is a simple filter, ghc doesn't know that once it doesn't apply it never applies.
17:16:37 <ksf> you want to use takeWhile or such.
17:16:39 <dolio> djahandarie: Sounds like a good argument against using it.
17:16:42 <ski> danportin : hrm .. don't make `Halt' part of the state ?
17:17:32 <Bobbias> Ahh, ok, that makes perfect sense. I'm still quite new to haskell, and I'm still getting used to everything
17:17:35 <blackh> anair_84: This 'List' code very cool and very mind-bending
17:18:22 * ddarius doesn't like Plato because he was a Platonist.
17:18:39 <ksf> is that the reason haskell is only non-strict, not lazy?
17:18:47 <ksf> full laziness requires a lot of intelligence.
17:19:17 <anair_84> List by Yair Chuchem
17:19:33 <ddarius> ksf: The Report gives no means to validate laziness as that is a purely operational property.
17:19:43 <dolio> Haskell being merely non-strict allows people to experiment with other evaluation strategies with it still being Haskell.
17:19:59 <ddarius> (Admittedly, the Report has a few things that aren't verifiable in that way, such as newtypes.)
17:20:29 <blackh> anair_84: That's the one. You can do very very cool stuff with it.
17:20:43 <duckinator> hi
17:21:17 <anair_84> what is the hackage url ?
17:21:23 * ksf formulates a new commandment: Thou shalt not attach where clauses to functions named f, g or h.
17:21:50 <ksf> hackage.haskell.org
17:21:55 <aristid> @hackage List
17:22:00 <aristid> :(
17:22:04 <ksf> lambdabot's on vacation.
17:22:18 <aristid> but haskell never sleeps!
17:22:23 <anair_84> k i see it
17:22:28 <ksf> in iceland. got too hot in florida.
17:22:58 <danportin> ski: and just check for halting when evaluating outside the state. that works too. thanks
17:23:15 <ski> benmachine : imo, `hClose' on a semi-closed handle should either be an error, or have no effect, or at least cause the rest of the contents from `hGetContents' to be `_|_', instead of `[]'
17:23:29 <ski> danportin : yeah, basically `newtype Transition t = Transition (State -> (t, State))
17:23:33 <ski> er
17:23:41 <ski> danportin : yeah, basically `newtype Transition t = Transition (State -> Maybe (t, State))'
17:23:51 <benmachine> ski: well, yes, but you're already using lazy IO so stuff is always going to be confusing and inelegant :P
17:24:10 <benmachine> might as well be confusing and inelegant and nice to your filehandle limit
17:24:14 <ski> benmachine : i don't see why not to remove or at least minimize confusing things :)
17:24:19 <aristid> ski: i like the _|_ idea
17:24:21 <danportin> Yeah, using Maybe or [] seems to work
17:24:42 <benmachine> I like the not-using-lazy-IO idea, but you can't win 'em all :P
17:25:12 <ski> danportin : of course, that's basically `newtype Transition t = Transition (StateT State Maybe t)', using the standard `StateT' monad transformer
17:25:24 <aristid> benmachine: not using it is no reason not to fix it!
17:25:47 <benmachine> :t fix hGetContents
17:25:57 <benmachine> ... :(
17:25:59 <aristid> :P
17:26:33 <ski> type error, `Handle' does not match `IO String'
17:26:41 <danportin> Yeah, 'Transition' = State, but I'd rather get monads, applicative, and functor down solid (and implement them in some projects) before moving on to more advanced topics
17:27:10 <ski> danportin : sure, just pointing the way for the grown-up way to say things, when you're ready for it :)
17:28:02 <geheimdienst> i have a file F with some unit test code and some serious code. my foo.cabal has a switch "testing" which lets me build the executable to run the unit tests. however, cabal barfs because it can't find a Main module in file F. apparently it's impossible to have 2 modules in one file ... any ideas?
17:28:11 <danportin> Heh, well thanks :)
17:28:43 <ksf> geheimdienst, you can have more than one executable in a project
17:28:56 <ksf> also, there's existing test frameworks that include runners
17:29:07 <ksf> ...and then there's cabal test
17:29:19 <blackh> anair_84: http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/c0uueh7 List-based code to sum the file sizes in a directory.
17:29:27 <geheimdienst> ... which is only now being developed, right? the soc thing?
17:29:29 <anair_84> k
17:30:02 <ski> danportin : your `Monad Tape' fails the `join . return = id' law
17:31:49 <ski> danportin : `join (return (Tape l a r))  =  join (Tape [] (Tape l a r) [])  =  Tape (map lTape []) (hTape (Tape l a r)) (map rTape [])  =  Tape [] a []  =/=  Tape l a r'
17:31:57 <copumpkin> onoes
17:32:03 <copumpkin> u haz faek monadd
17:32:14 <copumpkin> monadz r real k?
17:33:28 <ski> danportin : i think you can make `Tape' into a monad, though, by defining `return a = Tape (repeat a) a (repeat a)', and making `join' take a diagonal
17:33:49 <ski> (basically `Tape' is `(Integer ->)', then, with the environment-monad)
17:34:37 <ski> (.. of course, this might not be exactly what you wanted .. maybe you could try making `Tape' into a comonad, instead ?)
17:34:58 <ddarius> Freakin' Caccamo doesn't give the judgements of small or complete.
17:35:52 <geheimdienst> ksf, by the way, i looked up "cabal test" and read about that. i have something that does what i want now. thanks a lot :)
17:37:11 <BMeph> Oh, yeah - for anyone  still interested in the "Objects Have Failed" topic, here (https://www.dreamsongs.com/ObjectsHaveFailedNarrative.html ) is the original; here (http://dreamsongs.com/ObjectsHaveNotFailedNarr.html ) is Guy Steele's reply, because you *know* if anyone's dedicated to Lisp dialects^W^W OO, it's Guy Steele... ;)
17:38:32 <danportin> You're right! Thank you for catching that. I'm a litte unsure what the utility of the 'tape monad' is. But duplicate would have to be somethign like 'duplicate tape = Tape (tail (repeat left t)) t (tail (repeat right t)), forming all neighborhoods on the tape (e.g., each element becomes a head).
17:38:43 <danportin> err iterate, not repeat
17:40:01 <monochrom> a tape monad ate a tape worm...
17:40:13 <ddarius> Is the product of two complete categories complete?  I'm pretty sure it is.
17:40:41 <danportin> But as you pointed out, the problem with 'join' is that it (hTape (Tape l a r)) doesn't evaluate correctly.
17:41:42 <ski> danportin : that `duplicate' sounds right
17:42:06 * ski has decided to prefer the name `scaffold'
17:42:46 <nomothetis> Hi everyone.
17:43:28 <ski> danportin : well, `Tape' by itself is useful .. i'm not sure why one would want to use a monadic interface on it, though
17:43:40 <ski> danportin : where are you getting this from ?
17:44:49 <nomothetis> I'm wondering if anyone can help me. I'm trying to generate a random boolean through Test.QuickCheck and having no luck.
17:45:24 <ski>   arbitrary :: Gen Bool  -- no ?
17:45:29 <ksf> how do I TH a multiparam instance?
17:45:39 <ksf> there's only | InstanceD  Cxt  Type  [Dec]  as far as I can see
17:46:53 <danportin> I'm working through Wadler's paper on monads (and the typeclassopedia), using '
17:47:05 <nomothetis> arbitrary :: Gen Bool?
17:47:15 <nomothetis> Is that how I call it?
17:47:26 <copumpkin> nomothetis: that'll evaluate it, not run it
17:47:37 <copumpkin> x <- arbitrary
17:47:55 <ddarius> danportin: Which Wadler paper?
17:47:58 <nomothetis> Right, and then when I want to run it, what do I do?
17:48:11 <danportin> * his examples to 'convert' different 'beginner' projects I had completed.
17:48:24 <copumpkin> nomothetis: use one of >=>, >>=, <=<, =<<, >>, and so on :)
17:48:28 <copumpkin> nomothetis: or just do notation
17:48:31 <danportin> "The Essence of Functional Programming"
17:48:40 <ddarius> danportin: That's a great one.
17:48:50 * ksf has a look at the replib source
17:49:00 <nomothetis> copumpkin: it sounds like just maybe I need to read up a little more on monads, then.. :-)
17:49:04 <nomothetis> Thanks for the help.
17:49:09 <copumpkin> nomothetis: probably :)
17:49:11 <nomothetis> copumpkin++
17:49:16 <nomothetis> :-)
17:49:25 <danportin> It's better than the majority of the tutorial pages I've found.
17:49:44 <monochrom> wadler rocks
17:50:59 <monochrom> concrete examples. precise laws. crystal clear math.
17:51:18 <blackh> monochrom: Did you watch that type classes vid on Channel 9?
17:51:23 <monochrom> as opposed to most tutorial pages: lousy personal metaphysical postmodern philosophy
17:51:42 <monochrom> No I haven't watched any video
17:51:57 <Twey> @src (>=>)
17:51:59 <blackh> I just wanted to know if it's worth watching by someone who is already good at Haskell
17:52:08 <ddarius> blackh: Probably not.
17:52:20 <Twey> Woah, no \b again
17:52:25 <Cale> blackh: The second one is worth watching, I think.
17:52:35 <monochrom> I still think videos are not worth watching. Until a dramatically different navigation mechanism comes along.
17:53:02 <monochrom> The slidebar is just not enough.
17:53:03 <zoheb> So I am needed a Java style split fn for a script and copy pasted something from the net
17:53:13 <zoheb> msplit sep = takeWhile (not . null) . unfoldr (Just . span (/= sep) . dropWhile (== sep))   
17:53:29 <Cale> For some reason, though I'd written code quite similar to that, I'd never quite thought of it as a solution to the expression problem, though that's exactly what it is.
17:54:01 <zoheb> I am running this on a huge data file and the program is really slow, does anyone know of an efficient split fn for Haskell
17:54:08 <monochrom> perhaps s/navigation/skipping/ to be honest and/or frank
17:54:08 <zoheb> haskell strings
17:54:16 <ski> nomothetis : if you have any particular code you're wondering about, paste it somewhere and show it
17:54:48 <ski> (monochrom : i first thought that said ".. crystal clear meth" ..)
17:54:56 <Cale> monochrom: I guess if you're impatient and/or don't have much free time, videos could be frustrating in that way.
17:55:14 <monochrom> Perhaps all I need is some star-trek-ary mechanism. I say to computer, "skip to where he lists the monad laws", and it is done.
17:55:37 <blackh> Videos are quite good to watch when you have long compile times.
17:55:38 <Cale> monochrom: I've watched the lectures for entire courses in two or three sittings before though, one after the other. :)
17:56:08 <Cale> MIT has some nice courses online.
17:56:17 <monochrom> Some people say, so they let the video and sound play in the background, they go code their own stuff, then turn to the video when they hear the wanted bits.
17:56:27 <Cale> I watched their physics courses and the electrical engineering course.
17:57:12 <ddarius> Cale: So were you talking about Ralf Laemmel's  type class video?
17:57:18 <monochrom> First of all that doesn't work for me, I mentally tune out of the sound. Secondly it is so grew-up-with-TV generation.
17:57:36 <Cale> ddarius: Yeah, the second one about looking at typeclasses as a solution to the expression problem.
17:57:52 <nomothetis> ski: basically, I'm trying to find a way to implement "getBoolean" in http://pastie.org/1111347
17:58:33 <ski> nomothetis : what sould `getBoolean' do ?
17:58:38 <ski> s/sould/should/
17:58:44 <ddarius> getBoolean () = True
17:58:56 <nomothetis> run the Gen Boolean monad (if I understand how things work...)
17:59:02 <nomothetis> basically I need to execute something randomly.
17:59:08 <ski> (ddarius : type must be `Gen Bool -> a', for some `a')
17:59:18 <monochrom> The advantage of text is that cursory reading works. If one day an interface and a trainable skill for cursory watching comes along, I'll watch videos.
17:59:19 <ski> nomothetis : why not
17:59:29 <ski>   doSomething :: Gen Whatever
17:59:34 <ski>   doSomething = do
17:59:40 <ski>     b <- randomBoolean
17:59:47 <ski>   ..do whatever with `b'..
17:59:57 <monochrom> And cursory read/watching is always necessary in this stupid reality because people stupidly go way too verbose in both text and video.
18:00:03 <ski> (sorry, last line should be aligned with the `b <- ...')
18:00:07 <ski> nomothetis : ?
18:00:08 <nomothetis> because isn't b still a Gen Bool?
18:00:19 <ski> nomothetis : no, `b' will become a `Bool', there
18:00:19 <nomothetis> if statements don't accept them.
18:00:26 <nomothetis> oh.
18:00:35 <nomothetis> Interesting; I didn't realize that.
18:00:41 <nomothetis> Thanks.
18:00:49 <nomothetis> I'll give it a try.
18:01:07 <ski> nomothetis : the `<-' thing in a `do'-block converts from `Foo X' to `X', where `Foo' is any monad, such as `IO' or `Gen' or `Maybe' or ...
18:01:19 <Cale> nomothetis: v <- x means to run the computation x, and name its result v, while let v = x will define v to be the same computation as x.
18:01:29 <ski> nomothetis : note that `doSomething' itself still have to be in the `Gen' monad, though
18:01:36 <nomothetis> so here's a question, then.
18:01:44 <nomothetis> Why doesn't randomBOolean already return a Bool?
18:01:58 <nomothetis> does it revert to being a Monad if it is outside the "do" blocK?
18:01:59 <copumpkin> because it would always have to return the same one
18:02:08 <copumpkin> much like the overquoted xkcd comic
18:02:26 <ski> `randomBoolean' is an action that describes how to construct a `Bool' value, possibly using a randomness source
18:02:34 <Cale> nomothetis: If randomBoolean were a Bool, then which Bool would it be?
18:02:54 <nomothetis> Cale, ski: I think I get it.
18:02:55 <ski> nomothetis : if `randomBoolean' was a `Bool', then it would always be the same `Bool', e.g. `False'
18:03:26 <ski> nomothetis : the `Gen' monad hides the feeding of a random generator seed, that is needed to get different random values
18:03:27 <Cale> nomothetis: There would only be 3 possibilities: False, True, or nontermination (a.k.a. undefined/bottom/error)
18:04:18 <ddarius> randomBool = fix id
18:04:41 <monochrom> And so randomBoolean should pick one of the 3 possibilities randomly each time it is called. :)
18:05:10 <copumpkin> lol
18:05:11 <ski> nomothetis : instead of `randomBoolean :: Gen Bool', it would be possible to do `randomBoolean :: StdGen -> Bool' (or better, `randomBoolean :: StdGen -> (Bool,StdGen)', since you might want to (e.g.) generate several random booleans in a row, and then you need a new random generator seed/state each time)
18:06:12 <nomothetis> I didn't go the StdGen route because the website said that using Test.QuickCheck was the way to do random numbers (and by extension random variables of other types).
18:06:52 <ski> nomothetis : what the `Gen' monad does is basically pass around `StdGen's for you, and keep track of book-keeping, so you don't have to do it yourself (and easily introduce hard-to-debug mistakes)
18:07:30 <ski> nomothetis : right, just explaining what `Gen' more or less is
18:08:05 <nomothetis> Thanks for the info, everyone. I'll go back to trying to get this working. It's my first day, so of course I chose something non-trivial. :-)
18:08:24 <nomothetis> ski++, copumpkin++, monochrom++, ddarius++
18:08:25 <ski> if you have any more questions, just ask
18:08:36 <nomothetis> and cale++ :-)
18:09:06 <monochrom> This is why I use the gentle introduction. It doesn't start with "let's write a web service".
18:09:26 <ski> Cale : oh right, lambdabot has been drinking again
18:12:10 <monochrom> lambdabot observes strictly: don't drink and derive
18:15:36 <benmachine> ok so I'm reading this Objects Have Failed article
18:15:53 <benmachine> I've heard some people badmouth C++ before but never blame the global recession on it o_O
18:16:12 <benmachine> unless "our current recession" refers to something smaller
18:16:24 <JoeyA> Bah, I blame oil scarcity on all our economic problems.
18:16:42 <ski> benmachine : written in 2002
18:16:42 <Gracenotes> if only stock trading programs had been slower
18:16:57 <benmachine> ski: oh yes, whoops
18:17:15 <benmachine> which recession were we in then
18:17:33 <ski> maybe dot-com bubble ?
18:17:49 <benmachine> oh, perhaps
18:17:54 <benmachine> fair enough
18:18:09 <benmachine> that article still uses a million words to say about two sentences' worth of stuff though >_>
18:18:11 <aristid> blaming the dot-com bubble on c++?
18:18:19 <benmachine> aristid: OO, rather
18:18:46 <aristid> benmachine: i think as long as people think that "long = meaningful", we will get many texts that are longer than necessary :/
18:22:24 <benmachine> brevity is a virtue.
18:26:12 <aristid> benmachine: other things being equal, yes
18:31:28 <BMeph> benmachine: Just one more way that Guy Steele's response is "teh winZ0r"... ;)
18:36:22 <BMeph> Off to shop for groceries...see y'all in a few.
18:42:12 <joelb> How different is parsec 3 than the previous versions?
18:42:45 <dolio> Moderately.
18:42:56 <copumpkin> joelb: about 14% different
18:43:17 <notabel> copumpkin: performance number or some api measure?
18:43:25 <copumpkin> notabel: beats me
18:43:41 <joelb> The documentation seems a bit dated.
18:43:50 <joelb> Unless I'm missing something.
18:44:06 <notabel> yeah, i was trying to get a handle on parsec3 yesterday and failed pretty soundly
18:44:24 <notabel> all of the docs are outdated, the actual parsec3 documentation is in almost-unfindable blog posts
18:44:58 <sm> mail the maintainer and cc libraries@haskell.org.. that's my new policy
18:44:58 <joelb> Is it similar enough that the older documentation is useful?
18:45:40 <notabel> no; major structural changes.  the old api is under the old namespace in the new package, as a compatibility shim
18:46:09 <joelb> Oh that's helpful
18:46:11 <joelb> Thanks
18:46:21 <joelb> What's new then?
18:46:23 <Cale> The documentation for parsec3 is exactly where you'd expect, on Hackage.
18:46:30 <Cale> http://hackage.haskell.org/package/parsec
18:47:23 <aristid> maybe start here: http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Combinator.html
18:48:41 <joelb> I was looking for something a bit more… helpful to beginners
18:48:44 <joelb> But that will do
18:49:08 <sm> 
18:49:09 <sm> 
18:49:18 <joelb> Thanks
18:49:51 <Cale> Well... sure. :)  I suppose that the old parsec documentation was much more like a tutorial. I suspect that you should still be able to follow along with that if you keep track of the fact that things have moved around a bit and the types have gotten a little more elaborate.
18:50:10 <jaredj> sm, i was afraid of two-column accounting, and made an ungodly gnumeric-python monster
18:50:11 <aristid> joelb: i hear ya, i felt the same :)
18:50:34 <jaredj> and now it doesn't do half of what i want and it looks like hledger would :)
18:51:06 <aristid> jaredj: hledger and ledger do not actually enforce "proper" two-column accounting
18:51:10 <sm> hey jaredj! interesting, show us
18:51:23 <aristid> jaredj: so you don't need to fear that :P
18:51:35 <sm> btw I was trying to reach you to check ofx parser status.
18:51:48 <jaredj> well - it had proper terms and all. scary! but then i wikid them and they're not bad.
18:51:55 <jaredj> yeah about that
18:51:59 <jaredj> i stopped to make the python thing
18:52:04 <jaredj> but now i started again
18:52:16 <jaredj> still not done
18:52:23 <sm> oh excellent.. cos I'll use it
18:52:29 <sm> and I heard one or two others say the same
18:52:30 <jaredj> me too i hope :)
18:52:44 <jaredj> what do you think the format of the rules file should be like?
18:52:59 <jaredj> oh! - particularly given this datum:
18:53:18 <jaredj> the proper account for an item is not always found in its description.
18:53:25 <sm> definitely not
18:53:35 <Bobbias> Ok, a bit more practice here, what's wrong with answer: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29397#a29397 ghci says couldn't match '[Integer]' to inferred type '(a -> a -> a) -> a1 -> bool' in the first argument of 'primesUnder', namely 'n'
18:53:41 <jaredj> my bank is crazy and puts street addresses in the description. useless!
18:53:51 <sm> yeah descriptions can be most anything
18:53:53 <sm> you probably saw hledger convert's rules format ?
18:53:58 <jaredj> yes.
18:54:15 <sm> I imagine gnucash saves it in some xml or sqlite format
18:54:38 <Cale> Bobbias: Just a quick warning, there are tabs in your source
18:54:51 <jaredj> gnucash is quite imposing to me
18:55:09 <Cale> Bobbias: You should configure your editor not to insert tab characters into your source files.
18:55:10 <sm> hey, what's Cale doing in #ledger.. uh.. wait a minute
18:55:13 <jaredj> yes in my python-gnumeric monster the rules are just python expressions in a sheet with a special name
18:55:22 <jaredj> that is suboptimal though.
18:55:24 * sm reorients
18:55:38 <Bobbias> Alright, why are tabs so evil?
18:55:56 <jaredj> how many spaces in a tab?
18:55:58 <Cale> Bobbias: Because Haskell is layout-sensitive, and everyone's editor treats tabs differently.
18:56:17 <etpace> you know, i never understood why people prefer spaces
18:56:25 <etpace> with tabs, you can adjust the tabwidth
18:56:32 <jaredj> exactly
18:56:32 <etpace> so people can have the code how they prefer, but stil be compatable
18:56:33 <Cale> Spaces are unambiguous
18:56:41 <Cale> It matters how things line up vertically
18:56:55 <Cale> Adjusting the indentation will tend to screw that up.
18:57:10 <etpace> only if you have spaces and tabs mixed?
18:57:11 <wli> Tabs don't have spaces in them. There are tabstops at particular columns, not necessarily regularly spaced, according to how the tabstops are set.
18:57:13 <ddarius> notabel: All the old documentation applies readily to Parsec 3 with just different module names, though it of course doesn't cover the new things which don't matter unless you actually need them.
18:57:17 <ski>   foo = do bar
18:57:18 <ski>   \t baz
18:57:18 <Cale> even if you don't mix them
18:57:18 <jaredj> and how is ghc to know your tabstops are set at 2?
18:57:31 <dh__> tabs are evil, last time we have a python bug in a production web server because of mixing of tab and space, so the code logic change , and it's invisible in the code editor.  
18:57:42 <ddarius> notabel: Parsec 3 has Haddock documentation as well, and not just the type signatures.
18:58:23 <notabel> yes, but nothing like the extensive manual parsec 2 had (which still comes up as the main result when you search google)
18:58:36 <ddarius> notabel: Parsec 2 didn't have a manual.
18:58:47 <ddarius> notabel: Parsec 1 did.  Parsec 2 uses Parsec 1's manual as does Parsec 3.
18:58:58 <ddarius> That manual applies to all versions modulo module names.
18:58:59 <aristid> so parsec did not actually change that much
18:59:09 <ddarius> aristid: No, the changes were additions for the most part.
18:59:11 <Bobbias> So, aside from the tabs, what's wrong with my code?
18:59:13 <wli> A tab signifies rightward movement to the next tabstop, not any fixed number of spaces.
18:59:41 <ddarius> aristid: Or generalizations.
18:59:48 <Cale> Bobbias: So, your type error is a combination of things. First of all the type of your factor is very strange because you forgot the backticks around mod
18:59:57 <monochrom> tab-reinterpreting editors are evil
19:00:02 <Cale> Bobbias: That is, it should be x `mod` y or mod x y, but not x mod y
19:00:09 <aristid> ddarius: from what i gather, the existence of ParsecT is not unquestioned
19:00:16 <Cale> Because that last one means to apply the function x to the values mod and y
19:00:28 <ski> etpace : some people always insert a newline at the start of each new layout block .. which works with tabs
19:00:30 <ddarius> aristid: I don't understand what you just said.
19:00:38 <Cale> Also, if x then True else False is always equivalent to x
19:01:00 <ddarius> aristid: At any rate, the whole point of Parsec 3 was ParsecT and this was well known by the community; they did support Paolo with a Google Summer of Code project.
19:01:23 <Cale> Oh, and x `mod` y is an Integer (or some other instance of Integral), and not a Bool
19:01:30 <copumpkin> from what I don't gather, the indubitable non-existence of ParsecT is not unquestioned
19:01:38 <Cale> So what you really want is  factor x y = x `mod` y == 0
19:01:43 <ski> wli : yes. aiui, usually the tab-stops are eight columns apart, if nothing else has been said
19:01:49 <monochrom> if x==True then True else False
19:01:55 <dolio> The snozzberries taste like snozzberries.
19:01:57 <Bobbias> Ahh, yeah, that explains things a bit. Still getting used to haskell's function infix system. as for the other stuff, it seems i forgot to add == 0 on that
19:02:02 <aristid> copumpkin: yeah mock me :P
19:02:04 <notabel> copumpkin: you just broke my english parser
19:02:09 <notabel> some kind of overflow
19:02:16 <copumpkin> aristid: NOOO
19:02:27 * copumpkin points at dolio's snozzberries
19:02:31 <Cale> So then the next problem is that primesUnder wants two parameters before it'll give you a list, while you've only given it one.
19:02:40 <aristid> ddarius: i don't remember who, but i was told that ParsecT is rarely, if ever, needed in practice
19:02:46 <Cale> (and takeWhile definitely wants a list there)
19:03:21 <copumpkin> aristid: it's only needed for industrial-strength parsers. Is your parser industrial-strength?
19:03:29 <ddarius> aristid: It's definitely needed.  People use it and people wanted it.  I agree that it's not usually needed.
19:03:29 <wli> ski: Sure, and I guess some things assume that without any way to inform them of alternative tabstop settings.
19:03:37 <Bobbias> Ok, yeah, forgot to give it primes. I know I had given it primes in some earlier (broken) code, I guess I forgot to write it in after I began rewriting.
19:04:00 <aristid> ddarius: ok, maybe they meant more like that _I_ should not use it
19:04:10 <aristid> copumpkin: i fear that it isn't
19:04:23 <monochrom> I'm not sure you should be told what to do.
19:04:24 <ski> wli : do you know whether common terminals can inform where the tab-stops are, or at least allows setting them ?
19:04:44 <aristid> monochrom: is this some kind of philosophical issue?
19:04:50 <ddarius> "You know what you should do?  You shouldn't do what anyone tells you to."
19:04:57 <monochrom> No.
19:05:13 <jaredj> ddarius: i refuse!
19:05:13 <ddarius> monochrom doesn't believe in philosophy.
19:05:19 * jaredj vanishes in a puff of logic
19:06:07 <jaredj> sm, do you really want to see the python-gnumeric monster? i don't think it has a future
19:06:18 <jaredj> quite a past, but not much future
19:06:35 <sm> jaredj: that's ok, I understand what you mean better now
19:06:37 <wli> ski: The way tabs are interpreted in most cases that I know of is by the app depositing spaces in each character cell location up to and including a software-maintained tabstop.
19:06:51 <monochrom> If you use ParsecT (or whatever) in a specific case, then we may discuss whether it is an overcomplication for that use, or perhaps the opposite, thanks to ParsecT your case is greatly simplified.
19:07:06 <monochrom> Until then, it's meaningless to be told "don't use ParsecT".
19:07:08 <jaredj> sm: ok cool. because i haven't licensed it or made documentation
19:08:02 <aristid> monochrom: well i wasn't really even thinking about ParsecT ever, because i never had an actual need, but i was throwing around ideas about ParsecT State or such things
19:08:30 <sm> what does your ofx lib need before hitting hackage ?
19:08:37 <monochrom> now that is philosophy.
19:08:43 <ski> wli : yeah .. i was wondering about terminals like VT100, VT310, XTerm, &c., not about dumb programs simulating some terminal features, though
19:08:53 <jaredj> well - it never really worked, so it needs that first :)
19:09:30 <jaredj> i got the types to line up maybe once, then realized it wasn't flexible enough to parse an actual file. fixed it, and then it wasn't well typed
19:09:33 <ski> (er, s/VT310/VT320/)
19:10:05 <wli> ski: (n)curses may have some library assistance for this. I think vt100, vt220, xterm, etc. don't have anything I've seen used for tabstops but I've not looked over their specs for a long while.
19:10:15 <jaredj> so now i have a parser that takes a tag soup, and a list of allowable top level tags and a list of tags allowable in each "compound" tag, and puts out a rosetree of names and values
19:10:24 <mm_freak> class X a b | a -> b | b -> a where  -- can i express this using ATs /only/?  i guess no
19:10:27 <ski> wli : ok. i was just curious
19:10:31 <mm_freak> uhm
19:10:35 <mm_freak> class X a b | a -> b, b -> a where  -- can i express this using ATs /only/?  i guess no
19:10:57 <dolio> mm_freak: Not currently.
19:11:12 <mm_freak> dolio: does that mean it's planned?
19:11:24 <dolio> Doing so would require equality constraints on the class, which is not implemented yet.
19:11:28 <dolio> Yes, planned.
19:11:33 <mm_freak> ok, thank you
19:11:52 <copumpkin> chak even said 6.14
19:12:00 <copumpkin> but I haven't seen any commits related to it
19:12:06 <dolio> Oh?
19:12:07 <mm_freak> as a related question, can i exclude certain types from a flexible instance declaration?
19:12:21 <dolio> I was going to guess it'd come with the type system rewrite, which would be 6.16, I think.
19:12:33 <copumpkin> oh
19:12:46 <dolio> The OutsideIn stuff, that is.
19:12:57 <dolio> Maybe that's more on the inference end, though.
19:13:28 <mm_freak> instance (MonadT t, MyAppM m) => MyAppM (t m) where  -- example
19:14:21 <mm_freak> instance Monad m => MyAppM (MyAppT m) where
19:14:27 <mm_freak> this gives me overlapping instances
19:14:42 <mm_freak> i could resolve this, if i could tell that the first instance doesn't include MyAppT itself
19:15:13 <sm> ooh, regex-tdfa blows up on large regexps
19:15:27 <mm_freak> is this possible?
19:15:40 <dolio> Blows up how? Slow, or error?
19:15:56 <mm_freak> or does anyone know another solution?  (my goal is to get rid of heavy lifting)
19:16:51 <mm_freak> MonadLib does that by writing instances for every available monad transformer, but that's a dirty solution and not very modular
19:17:32 <copumpkin> mm_freak: what do you want it to use when (t m) is a Monad instance?
19:18:50 <mm_freak> copumpkin: what do you mean?
19:19:01 <copumpkin> (in the overlapping case, what should it do?)
19:19:15 <mm_freak> the overlapping case should be eliminated entirely
19:19:33 <dolio> Type classes are not well-suited to what you're trying to do.
19:19:41 <sm> dolio: uses all my ram and runs until I kill it.. 
19:19:51 <mm_freak> dolio: how would you do it?
19:19:57 <sm> with a 5k regexp
19:20:11 <dolio> sm: Isn't Thompson DFA supposed to be a super efficient algorithm?
19:21:08 <dolio> mm_freak: The way monadLib works is the best way I'm aware of, despite the fact that it isn't very good.
19:22:00 <mm_freak> dolio: i wonder why GHC allows me to select the instance in some cases, but not in this one
19:22:15 <mm_freak> i remember an extension, which makes it use the first instance in the code
19:22:24 <mm_freak> ugly, but it would work
19:22:50 <copumpkin> mm_freak: hm, in overlapping instances it'll pick the more specific instance, but in this case neither is more specific
19:23:05 <sm> dolio: sorry, was trying to regain control of my mac
19:23:13 <dolio> Heh.
19:23:19 <jaredj> sm, does hledger guard against duplicate transactions?
19:24:29 <mm_freak> copumpkin: i guess, i'll write instances for every monad transformer =/
19:25:31 <mm_freak> well, maybe someone knows a better way to modularize code than by monad transformers
19:25:57 <mm_freak> (if the code doesn't fit into any particular design like FRP or something, that is)
19:25:57 <sm> dolio: a 500 char regexp basically eats all my 1G ram for a minute
19:26:24 <sm> jaredj: no, duplicate transactions are fine
19:29:36 <jaredj> ouy
19:35:26 * hackagebot ccnx 0.0.0 - A Haskell implementation of the CCNx network protocol.  http://hackage.haskell.org/package/ccnx-0.0.0 (TomHawkins)
19:45:19 <jaredj> sm, if i get an OFX file from my bank today and another next week, most of the transactions will overlap. to deal with them effectively i have to remove duplicates. in OFX this is possible: they have unique ids
19:45:41 <sm> ah yes.. hledger doesn't have that kind of smart merge yet
19:45:45 <jaredj> sm, but if i get an OFX file from my bank today, import it into my ledger (losing the ids), and do the same next week, ...
19:45:46 <sm> merging is done manually
19:46:12 <jaredj> that's a tidy solution, if disappointing :)
19:46:29 <sm> yup.. we should figure something out
19:46:30 <jaredj> thing is without keeping the ids there's not much of a way around it
19:46:48 <aristid> sm: if you get the metadata format, you can include the ids in the transactions!
19:46:49 <jaredj> and if you keep the ids, either the description gets ugly or you break ledger compatibility
19:47:01 <sm> I guess transaction ids are needed.. then you get into the issue of going beyond the simple text journal file
19:47:02 <aristid> jaredj: no, ledger has a metadata format
19:47:11 <jaredj> what??
19:47:17 <aristid> jaredj: but hledger does not support it AFAIK
19:47:23 <aristid> sm: amirite?
19:47:28 <sm> right
19:47:40 <jaredj> plain text is attractive
19:48:23 <jaredj> plain text with big IDs in it is less attractive
19:48:32 <jaredj> binary... meh
19:48:34 <sm> right. You'd need an extra data source
19:48:37 <aristid> jaredj: well but maybe more useful!
19:48:41 <jaredj> *nod*
19:48:46 <aristid> jaredj: the ids would not be binary, i guess
19:49:02 <sm> alternate storage options would be good, but you have to figure out something for the classic text file
19:49:03 <jaredj> mine look like 000043257520
19:49:06 <jaredj> maybe longer
19:49:40 <jaredj> hmm - maybe you could make a tinyurl-like id
19:49:51 <jaredj> are there any unused delimiters? <>?
19:51:36 <sm> sure
19:51:56 <sm> aristid is right, you could use ledger's metadata format.. it's going to look intrusive..
19:52:17 <sm> I'm being compelled to wash dishes.. will have to go afk a bit
19:52:20 <sm> later
19:52:22 <jaredj> kk
19:52:23 <aristid> isn't it compatible with org-mode or so?
19:52:35 <jaredj> *read read*
19:52:40 <luite> I have a C header file that contains things that need to be replaced by a configure script. what's the best way to include such a file in a cabal package? (that works on windows) ?
19:56:58 <jaredj> quite a file format
19:59:59 <jaredj> aristid: so there isn't a separate file, you just put ; key: value thingys in the journal?
20:02:22 <nomothetis> ski: can I ask for your help again?
20:02:29 <etpace> hmm, I have two threads and one gets sent data by a channel from the other - the producer produces a large amount of data and then I want the consumer to consume until it is empty - the problem I currently have is haskell is switching out before the channel is empty - what's the best way to fix this?
20:02:50 <nomothetis> ski: I have pasted the code I'm trying to get to work at http://pastie.org/1111492
20:03:09 <nomothetis> I'm still getting type errors between Gen Bool and Bool; not sure what I can do to make them work.
20:04:03 <aristid> jaredj: i'm not 100% sure
20:04:15 <aristid> jaredj: it's in the same file i think
20:05:28 <jaredj> wth, how do you search commit messages on github
20:06:05 <geheimdienst> git-clone ; git-log | grep ? ;-)
20:09:11 <sm> jaredj, aristid: let's talk again.. but for now good night
20:09:22 <jaredj> sm, good night!
20:09:35 <jaredj> geheimdienst: i didn't want to actually use git :P
20:09:38 <aristid> sm: k, night
20:09:55 <aristid> jaredj: why not? :P
20:10:09 <jaredj> it's so much more complicated than darcs
20:10:19 * geheimdienst agrees
20:15:08 <aristid> jaredj: maybe
20:16:16 <ski> nomothetis : since you're using randomness, you can't just return `[Int]'
20:16:37 <ski> nomothetis : you need `Gen [Int]' (or possibly using `StdGen')
20:17:21 <ski> @hoogle initLast
20:17:22 <lambdabot> No results found
20:18:18 <nomothetis> ski: this is making things quite messy, all in all... basically, this means I need to pass the monad around until such a time as I compute and output the result, correct?
20:20:18 <ski> nomothetis : yes, anything that calls something that needs randomness needs to get that source of randomness from somewhere
20:20:30 <nomothetis> okay.
20:20:56 <nomothetis> ski: Would it be idiomatic to create type synonyms  to make things easier? such as "type GInt = Gen Int"?
20:21:02 <ski> that might be hidden in the `Gen' monad, or passing a `StdGen' around explicitly, .. or using the global `StdGen' which is lying around in `IO'
20:21:34 <ski> nomothetis : if you feel that you can more easily understand the program that way, np
20:21:46 <nomothetis> ski: cool, thanks!
20:22:02 <nomothetis> ski: it's mainly an excuse to have GString in my program. O:-)
20:22:04 <c_wraith> Template haskell does that a lot, with the ExpQ stuff
20:22:14 <c_wraith> But I generally don't use that idiom.
20:22:33 <c_wraith> Since I feel like it masks what's going on, to some extent.
20:24:14 <ski> well, if one can present a simplified view of common operations, in terms of these type synonyms (and one only uses those operations), then i don't have a problem with it
20:25:22 <ski> the problem is that the last clause will also be tried on backtracking, even if `H' is a list
20:25:31 <ski> or, ECHAN
20:28:38 * ddarius sees what the problem is now.
20:29:02 <ski> with Tejyus ?
20:29:41 <ski> er, s/Tejyus/Teyjus/
20:30:42 <ddarius> Actually, I've "decided" to go with Twelf, but the problem is in how I'm formalizing Caccamo's thesis.
20:31:01 <ddarius> I.e. where his "non-standard" substitution comes in.
20:31:08 <ddarius> (or rather what it means for Twelf.)
20:31:21 <ski> what's non-standard about it ?
20:31:28 * ski hasn't seen Caccamo's thesis
20:31:45 <ddarius> It deals with contravariance.
20:32:03 <ddarius> The context which is implicit in the usual usage of Twelf needs to be dualized.
20:34:53 <ski> oh, sorry, actually i did take a look at (part of) Caccamo's thesis (i just forgot that that was the author of it)
20:35:42 <ddarius> There's a solution he mentions that I can use but he thinks it has a lot of disadvantages.
20:36:02 <ddarius> Alternatively, since I'm changing the rules somewhat, it may be that this isn't a problem.
20:36:10 <ddarius> I need to make an actual (counter-)example.
20:49:03 <pumpkin> ddarius: ooh, you're going to do it? awesome!
20:49:19 <A1kmm> Hi, does anyone know of a Data.Map like datastructure that supports efficient search by a range of keys?
20:49:34 <ksf> what's the state of the art when it comes to parsing+unparsing, from only one specification?
20:49:56 <pumpkin> A1kmm: Data.Map could do that
20:50:32 <A1kmm> pumpkin: How? (short of defining an Ord instance that returns equality if it is anywhere in a range, anyway)
20:50:51 <ksf> A1kmm, a full blown interval map or just range queries?
20:50:59 <pumpkin> A1kmm: maybe call split on it twice?
20:51:12 <ksf> ...in the latter case, what pumpkin is saying.
20:51:23 <pumpkin> for ranges as keys, there's something in the Fingertree package
20:51:28 <pumpkin> but I don't think that's what he wants
20:51:58 <A1kmm> Just range queries... It does look like split would be a good option. Thanks.
20:52:37 <ksf> you will hardly be able to find a data structure that's faster for that than Data.Map, or IntMap
20:54:51 <etpace> where can I find the source for HPC?
20:57:34 <A1kmm> Doesn't it come with ghc?
20:59:07 <A1kmm> http://darcs.haskell.org/ghc/utils/hpc/
20:59:14 <etpace> cheers
20:59:58 <dolio> ddarius: The logical framework seems ill-suited to me for embedding languages that have to do manipulation of the context.
20:59:59 * ski thought etpace meant HBC ..
21:00:05 <dolio> Maybe I'm just missing something, though.
21:02:41 <pumpkin> how about epigram 2?
21:02:43 <pumpkin> who needs syntax
21:02:54 * hackagebot AttoJson 0.5.1 - Simple lightweight JSON parser based on ByteString  http://hackage.haskell.org/package/AttoJson-0.5.1 (HiromiIshii)
21:02:55 <dolio> For instance, I've considered how to model erasure pure type systems in them, where everything in the context requires an annotation 'v :t T', and some judgments require modifying t for everything in the context.
21:02:57 <ddarius> dolio: Indeed.
21:03:17 <dolio> Unless the LF you're using has the same sort of modalities, it seems like you'd be stuck.
21:03:33 <ddarius> What you can do, in some cases, is give syntactic realization to some operations that affect the context.  In others you can model the context algebraically.
21:05:16 <ddarius> An LF system based on a dependent contextual modal type theory may provide an interesting solution.
21:12:13 <ddarius> Should I explicitly include the "type" in an equivalence or should I simply allow X ~ Y -> typeof(X) = typeof(Y) be admissible?
21:38:52 <ksf> we don't have a library that unifies parsing and unparsing?
21:39:00 <ksf> not even a hackish and incomplete one?
21:39:50 <ddarius> ksf: Perhaps one of the lense/functional reference/accessor libraries?
21:40:11 <ksf> aren't those about data types, not serialisation?
21:40:24 <ddarius> Not necessarily.
21:40:34 <ddarius> Of course, there is Binary and Show/Read.
21:41:26 <ksf> lenses are actually a good idea.
21:42:14 <ksf> but, of course, I'd still have to write both directions of integer <-> ascii etc.
21:45:49 <ksf> ah. I could probably use drift or derive or such to solve all this
21:46:08 <ksf> ...so I only have to do the primitive types, and possibly the one or other override.
21:47:57 <Cale> ksf: You might be interested in http://research.microsoft.com/en-us/um/people/akenn/fun/picklercombinators.pdf
21:48:40 <LionMadeOfLions> neat
21:48:49 <Cale> I like how Google thinks that document was written by someone named P. Combinators
21:53:24 <ddarius> http://twelf.plparty.org/wiki/Respects_lemma <- not useful
21:54:31 <ksf> ...I can't choose which syntax to use, though.
21:56:31 <freedrull> what does it mean when there is a comma on the left side of a type signature?
21:57:39 <freedrull> a, b :: Int -> Bool
21:57:54 <dolio> Both of those have the given type.
21:58:10 <ksf> http://scholar.google.de/scholar?cluster=14047745955559972610&hl=de&as_sdt=2000&sciodt=2000  looks more like it.
21:58:32 <ksf> I'm not going to implement such a lib just for this one application, though.
21:59:14 <Wolfspaw> Can someone enlight a poor mind? :'(    http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29401#a29401
21:59:50 <freedrull> dolio: then can you define the equations for a and b simultaneously?
22:00:11 <dolio> What do you mean by that?
22:00:28 <Cale> Wolfspaw: Note that a is being run in the do-block
22:00:42 <Cale> Wolfspaw: So it must have type m t for some monad m.
22:00:59 <aavogt> @type do 'a'
22:01:00 <lambdabot> Char
22:01:14 <Cale> The result of a is named a', and it then has type t
22:01:47 <Cale> and then in the second statement of the do-block, we apply f to a', so t must be the same as the type of the parameter to f, which is a
22:01:52 <Cale> (the type variable a)
22:02:51 <Wolfspaw> Cale: hmmmm, i see now. You can only "extract" a value with <- (in a do block) from a monadic value. And that way it infers the parameter is "m a"
22:03:44 <Wolfspaw> Cale: Okay, thanks! o>
22:04:14 <Veinor> Wolfspaw: also, I think you would say 'liftM has type (m a -> m b)' as opposed to 'liftM returns (m a -> m b)
22:04:33 <Cale> Wolfspaw: Actually, let me rewrite liftM a tiny bit and explain what it does
22:04:44 <Cale> liftM f x = do { v <- x; return (f v) }
22:04:47 <Veinor> er, well, it returns a value of that type
22:05:10 <Cale> liftM takes a function f and an action x, and it produces the action which first runs x to get a result v
22:05:25 * ksf gives up on the literature and decides to go with sufficiently abstract type classes.
22:05:25 <Cale> and then returns the result of applying f to v
22:06:28 <ksf> ...and some TH if I can't stand writing "newtype FooBaz = FooBaz Int" is serialised as hex number, not decimal as classes, anymore.
22:06:47 <ksf> ...insert some parens into that sentence.
22:07:04 <Cale> You might say that the result of liftM has type m a -> m b, if you're treating it as a function of a single parameter, or that its result simply has type m b, if you're thinking of it as a function of two parameters.
22:10:01 <Wolfspaw> Veinor: ah, okay. I'll remember xD.   Cale: Can i treat a monad always as an action?.   Hm, true, result seems more haskeller xD
22:10:41 <augur> wargarble
22:11:45 <BMeph> How do you specify the type of a TH-using function - conventionally?
22:12:19 <Cale> Wolfspaw: A monad is a type constructor, like IO or Maybe. An action is a value whose type is constructed by that monad: getLine :: IO String or Just 6 :: Maybe Integer
22:13:31 <Cale> "action" is also often replaced with lots of other terms, like "computation", "monadic value", "recipe", and so on.
22:18:46 <augur> Cale: how many objects are in dom(f) and how many in cod(f) for an arrow f?
22:19:33 <augur> eep. stupid limechat
22:19:47 <Wolfspaw> Cale: ah, nice. Those answers helped me a lot in the road of monads, thanks!
22:19:59 <Veinor> okay, porting my shell prompt script to haskell has made me realize that perhaps there are some things it was not meant to do
22:20:08 * ksf tries to imagine the state of mind someone must be in to design a protocol that uses line-seperated commands which have space-separated arguments. and then goes on and adds to that tab-seperated sentences because there's some arguments that would like to have spaces in them.
22:20:23 <augur> Cale: sorry, if you answered my question my client died. :\
22:20:36 * ksf seriously can't.
22:20:49 <Veinor> like quick string manipulation and shell glue
22:21:08 <ksf> but then I prefer binary protocols, anyway, as they're _way_ easier to parse.
22:21:19 <Veinor> ksf: suppose you're designing the protocol and not thinking about spaces in arguments. line-separated commands with space-separated arguments is perfectly reasonable, right?
22:21:20 <Cale> augur: dom(f) and cod(f) are themselves objects
22:21:26 <ksf> if you want a bleeding textual representation, do that on top of the binary one.
22:21:58 <augur> Cale: ok, so arrows are in some sense like function type operators
22:22:10 <ksf> well, if a significant functionality involves chatting... and you don't even need to go there, even error messages, then, yes, it's braindead.
22:22:20 <ddarius> augur: Arrows aren't anything in particular.
22:22:21 <Cale> augur: Objects are analogous to types, arrows are analogous to functions.
22:22:27 <ksf> could've at least used tabs everywhere. that's at least remotely sane.
22:22:31 <Veinor> ksf: and then oh hey, people want to use spaces in arguments! this is bad! and quote-parsing is hard when you have to do escaping and stuff
22:22:42 <ksf> better use one of those ancient record seperator control codes.
22:23:04 <Veinor> what protocol is this, by the way?
22:23:13 <Cale> If X and Y are objects of some category C, and f: X -> Y is an arrow in C(X,Y), then dom(f) = X, and cod(f) = Y.
22:23:23 <augur> Cale: ok, just making sure, because one could imagine that arrows could be functions that are defined for only one value (X in X -> Y)
22:23:41 <ksf> http://github.com/spring/TASServer/blob/master/Documentation/Protocol/ProtocolDescription.xml
22:23:48 <augur> or like there could be multiple instances of an arrow f, each denoting the mapping that the function produces via application
22:24:00 <augur> so i was just making sure that the arrow was what i thought it was
22:24:09 <Cale> augur: Well, the arrows themselves might not have any internal structure apart from being distinguishable from each other.
22:24:16 <ddarius> augur: Arrows aren't functions or function-like and objects aren't sets or set-like.
22:24:24 <ksf> I don't think any implementation was ever generated from that description. not only is it lacking machine-readable information, but it's also incorrect in some parts...
22:25:21 <augur> Cale: right no sure, i just meant to clarify what the notion was -- did they stand as enumerations of the pairs (x,y) such that f(x) = y, or did they stand as showing domain-range relationships in the normal sense etc.
22:25:40 <augur> so that makes sense, thank you :)
22:26:07 <Cale> augur: Pretty much all of the interesting structure in a category lies in two things: 1) Whether arrows exist between each pair of objects 2) How arrows compose with each other to give other arrows
22:26:15 <ddarius> augur: I can make a category whose arrows are (former) presidents of the United States and objects are beach balls.
22:26:57 <augur> Cale: yeah, i know. i just wanted to make sure i knew what was meant first, otherwise i'd get terribly confused :p
22:27:18 * hackagebot enumerator 0.4 - Implementation of Oleg Kiselyov's left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4 (JohnMillikin)
22:28:20 * hackagebot attoparsec-enumerator 0.2 - Convert an Attoparsec parser into an iteratee  http://hackage.haskell.org/package/attoparsec-enumerator-0.2 (JohnMillikin)
22:29:21 * hackagebot yajl-enumerator 0.2 - Enumerator-based interface to YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-enumerator-0.2 (JohnMillikin)
22:29:23 <augur> ddarius: i also sooort of get that the objects and arrows can be anything, i just need to root myself in a familiar case before i step outside of that
22:30:07 <Cale> augur: Here's a good example. Take the category with just one object, call it *, and whose arrows are natural numbers.
22:30:08 <pumpkin> @remember ddarius I can make a category whose arrows are (former) presidents of the United States and objects are beach balls.
22:30:14 <pumpkin> :(
22:30:21 * hackagebot libxml-enumerator 0.3 - Enumerator-based API for libXML's SAX interface  http://hackage.haskell.org/package/libxml-enumerator-0.3 (JohnMillikin)
22:30:21 <Cale> augur: and we can compose arrows by multiplication
22:30:28 <Cale> So that 3 . 2 = 6
22:30:44 <augur> Cale: ow my head stop
22:30:45 <augur> XP
22:30:45 <pumpkin> lambdabot: come back!
22:30:47 <Cale> (we can compose any two arrows, because they're all * -> *
22:30:48 <Cale> )
22:31:25 <ksf> oh, I think I have a serious problem.
22:31:34 <augur> Cale: its a very interesting way of viewing the integers under multiplication
22:32:11 <Cale> augur: We can also form a category whose *objects* are the natural numbers, and there's a unique arrow n -> m whenever n <= m. The composition is then defined in the only way possible.
22:32:35 <ksf> If I recieve data over the net which is type-tagged and I resolve those type-tags at runtime and construct something like an HList to represent the stuff type-safe, I won't be able to be backwards-compatible even if such a single change as adding a field is being made.
22:32:51 <ddarius> Would you rather it be easy to write down terms but harder to write down proofs or vice versa?
22:32:55 <lispy> BMeph: Well, TH still has to type check normally
22:32:55 <lispy> BMeph: So, can't you do it the normal way modulo TH specific types
22:33:01 <lambdabot> Nice!
22:33:21 <augur> Cale: hm hm hm
22:33:58 <Cale> augur: Both of those are examples of categories which are "simple" in one way or another -- one of them has only one object, the other has at most one arrow between any pair of objects.
22:34:18 <augur> Cale: so what we're really aiming for is viewing arrows in a reeeaaally abstract way as binary relations
22:34:32 <copumpkin> typed ones
22:35:00 <ddarius> Arrows are just nothing.  All category theory wants from arrows or objects is that you can tell when they are the same and different.
22:35:05 <Cale> Well, for any category, and pair of objects X and Y in it, we can consider the question of whether or not there's an arrow X -> Y, which is a binary relation of sorts.
22:35:23 <augur> Cale: right
22:35:27 <Cale> But there also might be many arrows X -> Y
22:35:31 <augur> ya
22:35:35 <copumpkin> man, it's late
22:35:44 <copumpkin> woman, too
22:36:02 <augur> and sometimes arrows say nothing about the internal structure of the objects (like, say, with x -> y iff x <= y, where there isnt any structure, per se)
22:36:16 <Adamant> $man woman
22:36:24 <augur> or sometimes they do, like in x -> y iff x subs y
22:36:26 <ddarius> augur: Category theory is incapable of saying anything about either the internal structure of objects or arrows.
22:36:27 <Adamant> :P
22:36:50 <copumpkin> augur: yeah, arrows are just arrows :) anything that satisfies the laws/definitions is an arrow
22:36:53 <augur> Cale: and it depends on what the arrow is, or at least how its interpreted by the theorist
22:37:59 <Cale> augur: Well, yeah, we often have an interpretation for the internal structure of objects or arrows, but category theory doesn't impose one.
22:38:34 <augur> right, right
22:38:38 <Cale> It just supposes that there are these "things" called objects and arrows, and we can tell them apart, but it doesn't care at all what they're like.
22:38:55 <Cale> (as long as we can compose arrows which line up)
22:39:24 <ksf> I always thought objects are arrows that happen to point back at their tail.
22:39:30 <Cale> (and of course, there must be identities)
22:39:39 <augur> again, i just need to clarify the ideas, and whats inside the Category Theory box, and what happens to occassionally be true but is nonetheless outside the Category Theory boxo
22:40:12 <ddarius> ksf: You can identify objects with identity arrows, but then you have to add special "identity arrow" rules and the end result is actually more awkward than having objects as a separate sort.
22:40:14 <Cale> ksf: You can formalise it that way -- composition as partial, and use identity arrows in place of objects.
22:40:51 <copumpkin> OO people would like that one
22:41:05 <copumpkin> some of them, anyway ;)
22:41:15 <ksf> well, implementation and specification are always distinct.
22:41:30 <ksf> ...even if you happen to generate one from the other.
22:42:42 <Cale> augur: Have you learned what a monoid and a preorder are?
22:43:02 <augur> Cale: not really, i only just started reading the awodey book
22:43:08 <Cale> augur: I've already sort of mentioned these two examples of categories, but I think we can be clearer about it :)
22:43:25 <augur> and i wanted to clarify things before i get any further into it
22:43:39 <Cale> augur: A monoid is just a set A with a binary operation on that set, usually called multiplication *: A x A -> A
22:43:45 <augur> noooooo shh
22:43:46 <augur> ill get there
22:43:48 <Cale> okay :)
22:43:53 <augur> so mean
22:43:54 <augur> :|
22:44:11 <Cale> Well, I just thought I'd tell you myself :P
22:45:19 <ddarius> augur: What is the domain and codomain of the function f(x) = 2x?
22:45:22 <Cale> (note, I didn't finish the definition of a monoid there -- the operation is required to be associative, and have an identity element)
22:45:53 <augur> ddarius: i can hurt you
22:46:18 <Cale> ddarius: The answer is that you are supposed to wince when asked that question and pretend you didn't hear it. ;)
22:46:59 <augur> ddarius: also, simple! the domain and codomain of f(x) = 2x are dom(f) and cod(f)
22:46:59 <augur> 8D
22:47:24 <ddarius> augur: Then what is dom(f) and cod(f).
22:47:29 <augur> MAGIC
22:47:30 <augur> obviously
22:47:45 <augur> that, or some sort of weird fish-related bondage scene
22:48:36 <ddarius> Well, there is an uncountable infinity of right answers (at least), that, however, is not one of them.
22:48:57 <augur> ddarius: but you said the objects and arrows could be anything
22:49:11 <augur> so therefore surely a weird fish-related bondage scene IS an answer!
22:49:15 <Cale> augur: Well, there ought to be a way to interpret that equation as meaningful.
22:49:39 <ddarius> augur: f(x) = 2x is a normal arithmetic function.
22:49:51 <augur> Cale: oh im sure there is, and im sure there's arbitrarily many ways of interpreting it
22:50:04 <Cale> It's not really a function, but an equation which a given function might satisfy.
22:50:11 <Cale> augur: indeed.
22:50:29 <augur> anyway, ddarius: i just really wanted to make sure i understood the intension of the arrows in these diagrams, whether or not you could have multiple arrows labeled the same, etc.
22:51:18 <augur> and i think what im getting is that each actual physical arrow on the page is intended to denote _the_ math-arrow which is from X to Y
22:51:18 <ddarius> augur: My question is actually extremely pertinent to the latter part of that.
22:51:26 <Cale> augur: Normally, we take dom and cod to be well-defined. That is, any given arrow only belongs to one of the hom sets in any given category.
22:51:36 <augur> Cale: ok
22:52:08 <JoeyA> Is using unsafeCoerce to convert a C-typed number to Word64 safe, even if the source number is not 64 bits?  In particular, I'm having trouble with the DeviceID type because I want to store it in a SQLite database, but it doesn't have an Integral class.  Playing around in GHCi, it seems that unsafeCoerce (dev :: DeviceID) :: Word64 works.
22:53:16 <augur> Cale: and it seems like the arrows are of our choosing, yeah? like, its not like given some set of objects there is _the_ set of arrows for those objects
22:53:25 <augur> but rather the arrows are what we want them to be
22:53:32 <ddarius> augur: That is correct.
22:53:35 <augur> subject to the laws for categories being categories
22:53:36 <Cale> augur: Right, though often there's an implicit choice.
22:53:53 <ddarius> You can have different categories with the same set of objects.
22:53:59 <augur> ya
22:54:13 <ddarius> Heck, you could even have different categories with the same set of objects and arrows.
22:54:36 <augur> really? hows that work
22:54:46 <Cale> If you say "the category of rings", you're probably talking about the one with ring homomorphisms for arrows, but there's also the category of rings and set functions, and lots of other relevant categories built on those same objects.
22:54:53 <ddarius> augur: Most of the structure of a category is in the composition relationship.
22:55:21 <Cale> Remember how we considered the one-object category with the natural numbers as the arrows?
22:55:40 <Cale> Instead of taking the composition to be multiplication, we could have chosen addition
22:55:54 <Cale> Instead of the identity arrow being 1, it would then be 0.
22:56:49 <Cale> and so there we see a different category with the same objects and arrows
22:57:51 <augur> ahaaaa
22:58:36 <augur> so we're also thinking of composition as interpreted specific to a category
22:58:46 <Cale> Yeah
22:59:36 <Cale> All the interesting structure of any category is encoded in how arrows get composed (and whether it's possible to compose them)
22:59:49 <augur> sort of like categories as type classes, with the type class having some compose function, and each instance of that class defining that however it wants
23:00:13 <augur> so the multiplication category defines it as *, the addition category as +, etc.
23:00:21 <Cale> Yeah
23:01:01 <ddarius> JoeyA: Using unsafeCoerce is almost never safe.
23:01:28 <augur> Cale: this is interesting. this also makes stuff like abstract algebra kind of more sensible, because i can look at groups, etc in a similar fashion
23:01:51 <ddarius> A group is just a one object category where all arrows are isomorphisms.
23:02:08 <augur> ddarius: hush, im not trying to relate category theory to group theory :P
23:02:12 <Cale> and there's also a category whose objects are groups, and whose arrows are group homomorphisms
23:02:17 <augur> im trying to relate both to haskell :P
23:03:40 <ddarius> The subcategory of Cat of one-object groupoids.
23:04:00 <ddarius> (full subcategory)
23:04:47 <QtPlatypus> Cale: Is it right to say that there is the category whose objects are categories and whose arrows are functors?
23:04:56 <ddarius> QtPlatypus: Sure.
23:05:16 <ddarius> There can be foundational issues depending on how exactly you define "category."
23:07:14 <Cale> Yeah, sometimes you'd want to say that the objects are small categories (ones whose collections of objects and arrows are sets)
23:07:37 <dolio> Categories actually have an additional level, too. Natural transformations.
23:07:57 <dolio> So they're an immediate example of a 2-category.
23:08:05 <Cale> Given any group G, there's also a functor from the group G treated as a category to the category of groups, which sends the object * of G to G itself, and sends an arrow a: * -> * in G to the (inner) automorphism x |--> a^-1 x a
23:08:25 <dolio> Just as sets and functions naturally form a category.
23:09:04 <dolio> (And you can look at sets as 0-categories.)
23:09:17 <dolio> (And the collection of 2-categories is naturally a 3-category.)
23:25:49 <augur> Cale: D:
23:25:58 <augur> Cat, the category of categories and their functors D:
23:26:34 <augur> but then what about Russell, the category of all non-self-containing categories D:
23:27:51 <dolio> You can have the large category of all small categories. And then the larger category of large categories, and so on.
23:28:10 <augur> dolio: how truly russellian :)
23:28:20 <dolio> Actually, the larger category could have small and larger categories, I guess.
23:28:27 <dolio> Small and large.
23:29:02 <Maxdamantus> Hmm.. what's there in Haskell that's similar in usability to a struct in C?
23:29:10 <c_wraith> data
23:29:29 <dolio> I'm not sure people usually bother with talking about categories for non-small categories, though.
23:29:38 <Maxdamantus> But do the values of each data constructor have names?
23:29:50 <QtPlatypus> Maxdamantus: There is a syntax to allow that.
23:29:58 <Maxdamantus> Ah.
23:30:08 * Maxdamantus wonders what that is
23:30:35 <Saizan> btw, Hom(-,-) : C^op x C -> Set, but given http://en.wikipedia.org/wiki/Hom_functor#Yoneda.27s_lemma it seems like we could substitute Set with a category where the objects are "hom sets" and arrows are pairs of C arrows?
23:31:02 <Saizan> ("hom sets" left as opaque with no further structure)
23:31:27 <c_wraith> Maxdamantus, look up record syntax
23:31:47 <dolio> augur: Alternately, the (n+1)-category of n-categories thing gives you a more natural stratification, but I haven't seen any serious investigation as to whether that successfully avoids paradox.
23:32:49 <Maxdamantus> Ah, thanks.
23:37:39 <ddarius> c_wraith: data is not similar in usability to a struct, it's way -more- usable.
23:37:53 <ddarius> dolio: Sure they do.
23:38:17 <c_wraith> ddarius: record syntax is a bit clumsy :)
23:38:58 <dolio> ddarius: I suppose that'd be the use of the Grothendiek universe axiom?
23:39:34 <ddarius> dolio: My "Sure they do" was aimed at the earlier statement of yours w.r.t. non-small categories.
23:40:13 <ddarius> However, using n+1 categories does avoid (one form of) paradox (at least), but then the question becomes "what are these 'bigger' categories?"
23:40:24 <QtPlatypus> ddarius: Thats a subjective statement and it in some ways depends on waht you are going to use it for.
23:41:34 <ddarius> Saizan: That's what enriched category theory does.  However, you still need (want) quite a bit of structure on that new "Set" category.
23:41:38 <augur> Cale: given a monoid category with object m and arrows a, b
23:41:51 <ddarius> Usually at least symmetric monoidal closure.
23:42:06 <augur> isn't it the case then that (a . b) == (b . a) since (a . b) m = m = (b . a) m ?
23:42:17 <augur> but a monoid mathematically doesn't require commutativity
23:43:21 <dolio> ddarius: That's what I thought. That's why I thought the universe axiom was relevant.
23:44:42 <dolio> ddarius: And "what are n-categories" would have the same answer as "what are sets" I think.
23:44:48 <dolio> They're the things we're axiomatizing.
23:45:48 <Axman6> so, i'm writing a function which balances a binary tree, which may be very unbalanced initially. the way i'm doing it is like so: http://codepad.org/s8Bbz1iF i'm pretty sure it isn't ideal, so i was wondering if anyone had some pointers of improving it
23:47:21 <Axman6> conc is a smart constructor which keeps some of the bookkeeping in check
23:47:56 <Axman6> (basically records how many elements the C nodes have beneath them)
23:48:27 <Axman6> the main part of the code i'd like someone to look at is the go function, though i'm sure there's better ways to do the baance' function too
23:48:31 <Axman6> balance'*
23:50:33 <Maxdamantus> records seem confusing :\
23:50:53 <Maxdamantus> and Google comes up with lots of people saying they shouldn't exist.
23:51:02 <Axman6> they're not confusing, just ugly
23:51:48 <Maxdamantus> Hmm.. So I can't simply reference a field from a value which is a record?
23:52:08 <Maxdamantus> Without some sort of disambiguating type annotation or something
23:52:20 <Axman6> huh?
23:52:30 <Maxdamantus> *Main> let Frame { blah = n } = tf in n
23:52:30 <Maxdamantus> 42
23:52:31 <Maxdamantus> *Main> tf.blah
23:52:36 <Maxdamantus>     Couldn't match expected type `b -> c'
23:52:56 <Maxdamantus> eh, not .
23:52:58 <Deewiant> blah tf
23:53:00 <Maxdamantus> I think it's meant to be a space.
23:53:04 <Maxdamantus> Oh O_o
23:53:18 <Maxdamantus> Okay.
23:54:47 <Maxdamantus> Actually, that seems to make sense.
23:55:02 <Axman6> blah is a function
23:55:14 <Maxdamantus> Yeah.
23:55:21 <Axman6> that takes a Frame and returns a thing of whatever type you said blah is
23:56:05 <Maxdamantus> And if I have another constructor with a field blah it sets up an instance of the blah function for that constructor?
23:56:18 <aavogt> no it doesn't
23:56:27 <Axman6> you can't have overlapping field names
23:56:36 <Maxdamantus> Ah.
23:56:41 <Maxdamantus> Not even in another data type?
23:56:45 <Axman6> except i think inside the fame data type's constructors
23:57:02 <aavogt> you can put those other data types in separate modules
23:57:17 <aavogt> oh sorry, I misunderstood
23:57:42 <Axman6> so you can have data Foo = F {x :: Int, s :: String
23:57:45 <Axman6> oops
23:57:57 <aavogt>  data Foo = A { a,b :: String } | B { b :: String }  -- is legal
23:58:01 <Axman6> so you can have data Foo = F {x :: Int, s :: String} | G {x :: Int, z :: Complex Double}
23:58:11 <Maxdamantus> Mk.
23:58:28 <Deewiant> See also http://haskell.cs.yale.edu/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#disambiguate-fields
23:58:55 <aavogt> I don't think it's a good idea to be given those partial functions `s' and `z' in Axman6's case
23:59:22 <aavogt> as in     z (F ...)   is a runtime error
23:59:42 <Axman6> non-compile time errors = :(
