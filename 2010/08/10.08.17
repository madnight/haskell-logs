00:02:46 <Wooga> hello, i need infinite lazy data structure with random access ability. is there anything better then Data.Sequence ?
00:03:08 <Wooga> i heard that zippers are might be useed in this way
00:03:16 <Wooga> yet i don't know what 'zippers' are
00:04:10 <Saizan> Data.Sequence can't be infinite
00:04:31 <Wooga> it can be simlated by handling it with |>  and <| operators
00:05:08 <Wooga> but it is probably isn't best way to do things
00:05:40 <Wooga> so i am asking: what i actually want?
00:06:08 <FunctorSalad_> random access and infinite sounds impossible, depending on what exactly 'random access' is 
00:07:18 <FunctorSalad_> obviously we don't have infinite arrays in computers, 'infinity' is just simulated by a rule that tells you how to make more stuff... which seems to imply successive access rather than random
00:08:00 <FunctorSalad_> (any list can be expressed as some unfoldr, as an intuition)
00:08:03 <mjrosenb> also, lists have random access, just it may take a while to get to some values
00:08:11 <Wooga> i want something like that: http://codepad.org/9aEE0hTk only without need to manually add values to data structure with stack |> 0
00:08:26 <koala_man> it's not random access if access is O(n)
00:08:59 <Wooga> and something like (index stack ptr) too
00:11:49 <Saizan> it seems you can do without the ptr if the structure itself keeps track of the current position
00:11:54 <Saizan> like a zipper does
00:12:10 <FunctorSalad_> (as a side issue, Data.Sequence is random access?)
00:12:13 <ajnsit> @Wooga Is the 'case () of ()' just a fancy 'if' statement?
00:12:13 <lambdabot> Unknown command, try @list
00:12:21 <Saizan> Wooga: http://hackage.haskell.org/packages/archive/ListZipper/1.2.0.1/doc/html/Data-List-Zipper.html <- here's the one for list already implemented
00:12:23 <FunctorSalad_> thought it just has fast snoc in addition to cons
00:12:27 <Wooga> ajnsit: it's a fancy guard-statement
00:12:46 <Wooga> Saizan: thanks! now i know what i want
00:13:23 <Saizan> FunctorSalad_: index is O(log(min(i,n-i))) :)
00:13:30 <mjrosenb> Wooga: right, but you could have just as easily used an if  then else statement as well, correct?
00:13:38 <FunctorSalad_> Saizan: oh, nice
00:13:40 <Wooga> mjrosenb: yes
00:16:56 <Wooga> hm, weird. i don't have Data.List.Ziper in :m Data.List* prompt in ghci
00:17:06 <Wooga> Zipper*
00:17:18 <Wooga> i even don't have anythin after Data.List
00:19:55 <mjrosenb> Wooga: from the url, it looks like that is a package you need to install seprately
00:21:00 <Wooga> mjrosenb: thanks, i just installed it with cabal
00:33:05 <CakeProphet> Haskell -- massive import lists. tiny code.
00:34:39 <mjrosenb> CakeProphet: or any language with a decent set of libraries
00:35:14 <Saizan> depends, in some languages gluing libs together requires a lot of code too
00:38:24 <CakeProphet> I end up using Control.Monad and Control.Applicative so much that I'd probably so far as to propose that they be in Prelude.
00:38:32 <CakeProphet> *go so far
00:39:03 <CakeProphet> not to make it sound like a pressing issue or anything. It's not.
00:41:07 <Saizan> i wonder if we can find two persons that agree on what should go in the Prelude :)
00:41:29 <Saizan> maybe we should just have more of them
00:42:14 <CakeProphet> I think we can all agree that unsafePerformIO and unsafeCoerce should go in Prelude.
00:42:23 <CakeProphet> immediately.
00:42:51 <CakeProphet> alongside the classic launch
00:42:54 <CakeProphet> Missiles function
00:45:11 <CakeProphet>  GHC gives you a personality quiz as part of compilation that determines which Prelude you get. Or someone elses random Prelude downloaded from hackage by CL option.
00:49:54 <Saizan> nice
00:50:45 <CakeProphet> safe code for everyone!
01:15:00 <CakeProphet> #haskell, a channel on freenode where people congregate to leave and join channels.
01:15:24 <medfly> bullshit
01:15:47 <CakeProphet> no u
01:15:55 <medfly> quit trolling
01:20:00 <CakeProphet> now that I've got fclabels I don't remember why I wanted them...
01:22:20 <Saizan> data Stream a = a :> Stream a; data List a = Nil | Cons a (List a) | Stream (Stream a) -- i wonder if this has any uses.
01:24:46 <olsner> isn't that pretty much List a = [Either a [a]]?
01:24:57 <olsner> or Either [a] [[a]] perhaps :)
01:26:03 <dankna> hmm
01:26:26 <dankna> so I've got a mini-language written in Haskell with an algebraic datatype
01:26:44 <dankna> I want to enforce the constraint that its lists are homogenous
01:27:00 <Saizan> olsner: no, it's not nested like that
01:27:00 <dankna> by enforce I mean that one way or another I never want a heterogenous one to exist
01:27:01 <dankna> hmm
01:27:14 <Saizan> olsner: it's just a list which can tell you if the tail is infinite
01:27:19 <dankna> I can't quite wrap my mind around this.  the opposite problem, making them heterogeneous, seems easier.
01:28:02 <olsner> Saizan: yeah, just realized :)
01:28:39 <Saizan> well, if the terms and value of this object language are represented as simple sum types i can see how enforcing that would be a problem
01:28:47 <dankna> yeah
01:28:55 <Saizan> you could use gadts instead
01:29:24 <dankna> I thought of that; I've used them before, so I think I understand what they do.  but I'm not totally clear on how they help here.
01:30:28 <dankna> since you can have lists of lists,
01:31:49 <dankna> it's not enough to simply have the type be parametrized on the element type with a simple enumeration
01:32:02 <dankna> the parameter would have to be its own little possibly-recursive thing
01:32:04 <dankna> hmm
01:32:09 <dankna> Haskell can do that?
01:34:25 <Raynes> @faq 
01:34:26 <lambdabot> The answer is: Yes! Haskell can do that.
01:35:26 <Saizan> dankna: data Term t where K :: a -> Term a; Cons :: Term a -> Term [a] -> Term [a]; Nil :: Term [a]; listoflists :: Term [[Int]]; listoflists = Cons (Cons (K 1) Nil) (Cons (Cons (K 2) Nil) Nil) -- should work
01:37:42 <Saizan> you piggyback on the grammar of haskell types, which is already recursive :)
01:38:03 <dankna> hmm
01:38:07 <dankna> digesting that
01:38:23 <mjk> I can't load the packge "cario" of gtk2hs,can anyone help me?
01:38:46 <dankna> I think that works, haha, thanks
01:38:57 <dankna> I'll need to play with and understand it of course, but you can't really do that for me, so.
01:39:17 <mjk> load cario-0.11.0 is ok, but when i load cario-0.11.1, it's failed,why?
01:39:24 <Saizan> np :)
01:39:32 <Saizan> mjk: did you install it?
01:39:47 <Saizan> mjk: what is the exact error message?
01:40:30 <mjk> Saizan: cabal install gtk2hs-buildtools and then cabal install gtk
01:41:36 <mjk> when load cario-0.11.1, waiting and waiting.....
01:42:14 <mjk> Saizan: can't pass loading cario-0.11.1, my os is windows xp
01:43:18 <Saizan> "cabal install gtk" doesn't install cairo
01:43:28 <Saizan> mjk: what does "ghc-pkg list cairo" says?
01:44:23 <mjk> Saizan: load cario-0.11.0 is ok, but after i upgraded gtk2hs to 0.11.1, it is can't load cario
01:45:06 <Saizan> mjk: run the command "ghc-pkg list cairo" at the prompt and tell me what output it give to you
01:45:08 <mjk> Saizan: say "C:/Program Files/Haskell Platform/2010.1.0.0\lib\package.conf.d:"
01:45:25 <mjk> Saizan: "C:\Documents and Settings\admin\Application Data\ghc\i386-mingw32-6.12.1\package.conf.d:"
01:46:22 <Saizan> only those two lines?
01:46:31 <mjk> Saizan: yes
01:46:33 <Saizan> it seems you don't have cairo installed at all
01:47:12 <mjk> Saizan: how to install cario?
01:47:15 <dankna> it should be noted that cairo is a C-based library which needs to be installed before you try to cabal-install stuff
01:47:20 <Saizan> mjk: "cabal install cairo"
01:47:41 <dankna> (I think.  I haven't used gtk2hs at all, but that's generally how it works with Haskell bindings to foreign libraries.)
01:48:08 <Saizan> ah, yeah, you might need to install the C part first, and i've no idea how to do that on windows, except googling for binaries :)
01:48:19 <mjk> Saizan: when "cabal install cario", say "cabal: There is no package named cario. Perhaps you need to run 'cabal update' first?"
01:49:01 <mjk> Saizan: i've install the gtk+ 2.0
01:49:17 <Saizan> mjk: cairo, not cario
01:50:11 <Saizan> preflex: seen byorgey 
01:50:12 <preflex>  byorgey was last seen on #haskell 3 days, 22 hours, 49 minutes and 29 seconds ago, saying: peterNovice: hmm, now that you mention it I think I have run into this as well
01:51:00 <mjk> Saizan: sorry! "cabal instal cairo", says "Resolving dependencies..."
01:51:11 <mjk> says "No packages to be installed. All the requested packages are already installed."
01:51:21 <mjk> says "If you want to reinstall anyway then use the --reinstall flag."
01:52:11 <Saizan> are you sure you typed "ghc-pkg list cairo" and not "ghc-pkg list cario" earlier?
01:53:01 <Saizan> anyway, what does "ghci -package cairo-0.11.1" do?
01:53:05 <mjk> Saizan: after ghc-pkg list cairo, say "C:/Program Files/Haskell Platform/2010.1.0.0\lib\package.conf.d:"
01:53:38 <mjk> Saizan: and says "C:\Documents and Settings\admin\Application Data\ghc\i386-mingw32-6.12.1\package.conf.d:cairo-0.11.1"
01:54:39 <Saizan> ah, there it is, cairo-0.11.1 at the end
01:55:13 <Saizan> so it's apparently properly installed
01:55:32 <mjk> Saizan: but can't load it, haha 
01:57:43 <Saizan> what's the output of "ghci -package cairo-0.11.1" ? 
01:58:22 <mjk> Saizan: the message is:
01:58:28 <mjk> GHCi, version 6.12.1: http://www.haskell.org/ghc/  :? for help
01:58:37 <mjk> Loading package ghc-prim ... linking ... done.
01:58:41 <mjk> Loading package integer-gmp ... linking ... done.
01:58:46 <mjk> Loading package base ... linking ... done.
01:58:52 <mjk> Loading package array-0.3.0.0 ... linking ... done.
01:58:58 <mjk> Loading package bytestring-0.9.1.5 ... linking ... done.
01:59:06 <mjk> Loading package Win32-2.2.0.1 ... linking ... done.
01:59:15 <mjk> Loading package filepath-1.1.0.3 ... linking ... done.
01:59:19 <mjk> Loading package old-locale-1.0.0.2 ... linking ... done.
01:59:27 <arw_> mjk: please use a pastebot
01:59:35 <Saizan> e.g. pastebin.com
01:59:36 <mjk> Loading package old-time-1.0.0.3 ... linking ... done.
02:00:07 <mjk> GHCi, version 6.12.1: http://www.haskell.org/ghc/  :? for help
02:00:07 <mjk> Loading package ghc-prim ... linking ... done.
02:00:08 <mjk> Loading package integer-gmp ... linking ... done.
02:00:08 <mjk> Loading package base ... linking ... done.
02:00:08 <mjk> Loading package array-0.3.0.0 ... linking ... done.
02:00:08 <mjk> Loading package bytestring-0.9.1.5 ... linking ... done.
02:00:08 <mjk> Loading package Win32-2.2.0.1 ... linking ... done.
02:00:09 <mjk> Loading package filepath-1.1.0.3 ... linking ... done.
02:00:09 <mjk> Loading package old-locale-1.0.0.2 ... linking ... done.
02:00:10 <mjk> Loading package old-time-1.0.0.3 ... linking ... done.
02:00:10 <mjk> Loading package directory-1.0.1.0 ... linking ... done.
02:00:11 <mjk> Loading package process-1.0.1.2 ... linking ... done.
02:00:11 <mjk> Loading package time-1.1.4 ... linking ... done.
02:00:12 <mjk> Loading package random-1.0.0.2 ... linking ... done.
02:00:22 <Raynes> Saizan: Blasphemy. hpaste.org
02:00:43 <arw_> Raynes: thats broken: 58030 14: unable to open database file
02:00:49 <Raynes> Oh noes.
02:00:51 <Botje> blasphemyyyy .. blaspheyouuuu
02:00:57 <Raynes> There is also moonpatio or whatever.
02:01:17 <arw_> theres tons of such services
02:02:00 <mjk> Saizan: sorry! i can't use pastebot
02:02:12 <theorbtwo> mjk: Why not?
02:02:21 <Raynes> arw_: I was kind of limiting myself to ones written in Haskell. ;)
02:02:52 <mjk> theorbtwo: i don't know "pastebot"
02:02:59 <Raynes> I'd guess somebody has a gun to his head screaming "NO PASTEBINS!"
02:03:26 <theorbtwo> mjk: Then learn.  Don't say "I can't do foo" when what you mean is "I don't know how to do foo yet".
02:03:58 <Raynes> mjk: They're asking you to use a service such as pastebin.com or gist.github.com rather than paste such long messages to IRC.
02:03:59 <Saizan> mjk: you can visit www.pastebin.com paste the text there, click submit, and then paste the url of the resulting page to use
02:04:04 <Saizan> s/use/us/
02:04:16 <mjk> sorry!
02:04:40 <mjk> Saizan: OK
02:06:15 <mjk> Saizan: http://pastebin.com/s6PabpLF
02:06:42 <Saizan> oh, so it just quits?
02:07:19 <mjk> Saizan: yes
02:07:50 <Saizan> i don't know how to help with that, you could see if ghci -v -package cairo-0.11.1 gives any more relevant info
02:08:05 <Saizan> it might be a problem with the C libs
02:09:04 <mjk> Saizan: thank you!
02:19:23 <Saizan> mjk: no problem, i'm sorry that i couldn't really provide a solution
02:20:27 <mjk> Saizan: i will wait the next version of gtk2hs, thanks.
02:21:26 <Saizan> you could try asking on the gtk2hs mailing list
02:33:32 <mjk> Saizan: OK
02:35:15 <DevHC> hi
02:35:34 <DevHC> i'm using the HSQL interface to a PostgreSQL database
02:36:03 <DevHC> and i'm testing out a lot of function calls to detect possible quirks in the code of some SQL functions
02:37:04 <DevHC> my program reads prototypes from the stardard input (for example: myFunction(integer,boolean,boolean,text)), and for each prototype it generates a set of queries
02:38:22 <DevHC> for each "integer" argument i test the values in like -2000000000, 0, INT32_MIN
02:38:58 <DevHC> for text, some random characters (like |"!@}_)"'`~@#||"!@#}_)
02:39:34 <DevHC> and i'm doing an exhaustive test for all functions
02:40:05 <DevHC> so for each function i generate a lot of sql queries of the form "select f(blabla);"
02:40:11 <DevHC> (using the list monad, etc.)
02:40:16 <DevHC> problem is:
02:40:47 <DevHC> memory usage increases consantly.. to like gigabytes, before being killed by the OS
02:40:56 <DevHC> what could be the problem?
02:41:16 <dankna> well, there's a leak somewhere, obviously
02:41:23 <DevHC> HSQL bug?
02:41:29 <dankna> it could be your code, HSQL, or an interaction between them
02:41:36 <DevHC> or: HSQL is buffering queries while PostgreSQL is lagging?
02:41:55 <dankna> for example, you might not be realizing that HSQL is allocating resources that need to be explicitly freed because they're on the C side of the FFI barrier and can't be found by the GC
02:42:14 <Zao> You may have an old-fashioned space leak too.
02:42:15 <DevHC> whatever that means
02:42:20 <Zao> Lack of strictness, etc.
02:42:21 <ivanm> Heffalump: you around?
02:42:22 <DevHC> ie ghcbug?
02:42:33 <dankna> no, I think it's very unlikely to be a bug in ghc
02:42:39 <dankna> this is just me speculating; I haven't used HSQL very much
02:43:04 <DevHC> or: lack of strictness.. hmm could haskell be buffering statements for hsql?
02:44:33 <dankna> that is indeed possible
02:44:36 <DevHC> btw how S00N does haskell remove not-anymore-referenced objects from the memory? (does that question make sense?)
02:44:39 <Zao> DevHC: Maybe you're unintentionally hanging on to result sets for too long?
02:44:48 <Zao> Do you build with optimizing?
02:44:53 <DevHC> -O99
02:44:57 <DevHC> hanging on? what?
02:44:59 <Zao> DevHC: Whenever the GC kicks in.
02:45:07 <dankna> it removes them sometime prior to your memory usage growing to gigabytes, heh
02:45:11 <Zao> DevHC: As in, having a reference to a list of results or so.
02:45:31 <younder> Hi Haskell'ers.
02:45:32 <Zao> Have you've pastesited some code yet?
02:45:34 <DevHC> well yes i'm using only lists
02:45:36 <Zao> younder: HI!
02:46:13 * ivanm waves idly in younder's general direction
02:46:48 <DevHC> no code pasted, it's far away from me atm
02:48:09 <younder> I'm working on a new concurrent functional language I call Formula. It will be metacircular, but the first version will be written in Haskell.
02:48:12 <ivanm> DevHC: if you use a lot of large lists and keep them in memory, then it's no wonders you're having memory problems ;-)
02:48:12 <DevHC> but.. can anyone test if i code up a short version?
02:48:23 <ivanm> younder: "metacircular"?
02:48:34 <Zao> Self-hosting eventually?
02:48:48 <ivanm> that was my guess, but I wanted to be sure
02:48:54 <younder> ivan, The compiler is written in it's own language.
02:48:56 <ivanm> younder: also, it's a very un-googleable name...
02:49:14 <DevHC> ivanm: is memory leakage true for all list usage cases? or just where i might always use the full lists?
02:49:15 * ivanm /= ivan (in terms of nicks) :p
02:49:35 <ivanm> DevHC: where you keep a large chunk of the list in memory
02:49:52 <ivanm> consider something like this: avg xs = sum xs / length xs
02:49:56 <ivanm> (ignoring numeric types)
02:50:13 <DevHC> well
02:50:33 <ivanm> if xs is very long, then you're fully evaluating the first list with sum, and keeping it in memory to be able to find its length
02:50:34 <DevHC> something like:
02:50:42 <ivanm> if, however, you do it in a single pass then you don't have that problem
02:50:52 <Zao> ivanm: Heh, the same kind of example I had in mind.
02:51:33 <ivanm> e.g.: avg xs = uncurry (/) $ foldr (\ x (s,l) -> (x + s, l + 1)) xs
02:51:39 <ivanm> ^^ single pass average
02:51:41 <younder> ivan, Metacircular means it is writen  in itself. Like a C compiler written in C. Of cource you first would need to write a compiler written in something else. The first GHC Haskell version was written in ML. The second in Haskell using the first version to compile it.
02:51:59 <ivanm> right
02:52:22 <ivanm> doesn't _quite_ match wikipedia's definition...
02:52:33 <ivanm> as it refers to an interpreter interpreting itself IIUC
02:53:16 <DevHC> sequence_ $ map (\s -> silentQuery mc $ "select "++s) $ callsFor "f(integer,text,boolean)"
02:53:54 <younder> ivanm, That would be a metacircular interpreter..
02:53:56 <DevHC> silentQuery is a little function which takes a Connection and a query string, and catches errors reports from hsql
02:54:22 <ivanm> DevHC: sequence . map == mapM_ ;-)
02:54:35 <DevHC> :O
02:54:42 <younder> ivanm, The first example is LISP written in LISP.
02:54:45 <ivanm> but in that case, you're not going to have problems with the list created by callsFor
02:54:59 <Silvah> O rly?
02:55:06 <DevHC> so then what is the problem?
02:55:19 <ivanm> younder: right, but I was under the impression that you were writing a compiler, not an interpreter; that seems to fall more under self-hosting than metacircular
02:55:32 <Silvah> sequence . map /= mapM?
02:55:44 <ivanm> DevHC: since I can't see all of your code, and I wasn't there when you asked your initial question.. ;-)
02:55:46 <Zao> ivanm: self-hosting is not as cool sounding as meta-circular :D
02:55:49 <ivanm> Silvah: oh, that should be sequence_
02:55:53 <ivanm> since that's what DevHC had
02:55:57 <ivanm> Zao: true
02:56:12 <DevHC> lol
02:56:16 <DevHC> code S00N(TM)
02:56:24 <ivanm> interesting: the two wikipedia articles both claim Lisp as being the first instance of said technique, but don't refer to each other
02:56:41 <ivanm> self-hosting talks about Haskell, etc. but metacircular doesn't
02:59:25 <younder> ivanm: well metacircular is the term I've used. Anyhow 'the name' is not important
02:59:59 <ivanm> true
03:00:17 <fasta> Self-hosted does not imply you can easily port the compiler, right?
03:00:18 <lambdabot> fasta: You have 1 new message. '/msg lambdabot @messages' to read it.
03:01:09 <Zao> Would one use the term self-hosting for something like GCC, which can build from any old standard compliant C compiler?
03:01:22 <Zao> Or would one have to sneak in a bootstrap there somewhere?
03:01:24 <Botje> Zao: that's only stage 1
03:01:30 <Botje> stage 2 is compiling gcc with itself
03:01:41 <Zao> Botje: Yeah, but is it part of the term "self-hosting"?
03:01:46 <Botje> (and, of course, that bootstrap compiler often /is/ gcc)
03:02:17 <Botje> i think it counts
03:02:28 <Botje> because you can delete the original compiler and gcc will still be able to compile itself
03:02:45 * Zao notes that this isn't -blah as he thought.
03:03:05 <quicksilver> Zao: self hosting doesn't mean you *must* use it to compile itself
03:03:09 <Botje> it is if you want it to be :)
03:03:09 <quicksilver> it means it's *possible*
03:03:23 <quicksilver> if gcc was such a poor C compiler that it couldn't even compile itself
03:03:28 <quicksilver> then we'd say it was not self-hosting.
03:03:40 <quicksilver> early versions of compilers are often non self-hosting, and it's a milestone when you reach it.
03:04:34 <fasta> I think a term for a compiler that cannot be compiled by anything but a sequence of old unsupported compilers would also be nice.
03:05:03 <Botje> "crap" ? 
03:05:24 <fasta> Botje, hold that thought. 
03:05:33 <fasta> Botje, how is GHC compiled?
03:05:45 <Zao> fasta: By itself, or from unregisterised C.
03:05:54 <Zao> The latter only if you're lucky.
03:06:13 <younder> ivanm, Anyhow it is a great way to check if the compiler is working and that the language works. After all you would have written a substantial amount of code in it before you are finished.
03:06:14 <Zao> Personally I've never succeeded in building a GHC from scratch on any platform.
03:06:39 <fasta> Zao, but then you are trusting your compiler. 
03:07:09 <fasta> Zao, it's not like you can build GHC trusting only a small compiler. 
03:07:09 <Zao> Getting GHC up on obscure platforms tends to be an exercise in pain, as you have to start with some ancient one like 6.4, and then incrementally build new ones.
03:07:23 <younder> Zao: YYou should take that up with Simon P. Jones at Mirosoft Reasearch Cambridge.
03:07:28 <fasta> Zao, which was exactly what I meant. 
03:07:46 <Zao> Where the first one is from HC, which you can verify if you want to.
03:07:52 <Zao> Assuming you trust your C compiler.
03:07:59 <ivanm> younder: right; it unfortunately means you have to write your compiler twice :s
03:08:04 <fasta> That you can build GHC using a binary containing all the viruses on the planet is not not. 
03:08:07 <fasta> new*
03:08:30 <Zao> The whole "you can check the source if you want" statement kind of fails with any remotely complex bit of software.
03:08:33 <fasta> Now, most likely there is nothing wrong with these binaries, but there isn't an easy way of knowing. 
03:08:52 <theorbtwo> Indeed.  It's really about trust.
03:09:08 <fasta> Certified compilers can eliminate this. 
03:09:20 <younder> ivanm: in my case there is a scheeme  like core. So not the whole language.
03:09:28 <ivanm> good-o
03:10:07 <fasta> Of course, we already all trust the hardware, so it is rather pointless.
03:10:08 <theorbtwo> There was an interesting talk by K or R of K&R about that.  Insert something in your compiler that notices when it is compiling your compiler and put in both the code that notices and some sort of payload.
03:10:28 <fasta> theorbtwo, that was basically the point of the discussion, yes. 
03:10:33 <theorbtwo> You then have a self-hosting virus which is invisble if you read the source code.
03:11:03 <fasta> Reflections on Trusting Trust
03:13:35 <younder> theorbtwo, well, In my case I am writing it myself :) 
03:14:29 * younder sniggers: shut up amir..
03:16:52 * younder mimics dissociation disorder. (or multiple personalities)
03:19:25 <younder> Anyhow.. The pipelining inside the processor is automated. So I try to do the same for many CPU's on many blades in a high performance cluster.
03:21:14 <younder> I use agents instead of Oz's green threads as a abstraction. But still a basic data-flow approach.
03:22:12 <younder> I think functions have a bit too fine granularity and that the programmer needs a say in what hangs together.
03:22:53 <younder> nuff said
03:24:16 <ivanm> *sigh* hpaste is down :(
03:25:02 <ivanm> can anyone see a better way of doing this whilst still using an AT for Stores? http://dpaste.com/230081/
03:25:22 <ivanm> the requirement of having to mention "Value (c v)" in functions that use constraints is rather annoying :s
03:25:43 <ivanm> I can go back to using MPTC+FD for Stores (which works), but would prefer an AT approach if possible
03:27:09 <younder> ivanm: sees like a straitjacket
03:27:21 <ivanm> huh?
03:27:26 <younder> You can really make that work?
03:27:48 <ivanm> that currently works (I stole the Suitable class from Heffalump's rmonad package)
03:28:24 <ivanm> but doing it that way requires having "Suitable c v, Value (c v) ~ v" rather than just "Suitable c v" in the type sig constraints
03:28:55 <ivanm> the MPTC+FD approach has: class Stores c v | c -> v; class (Stores (c v) v) => Suitable c v where ...
03:29:08 <younder> better..
03:29:17 <Zao> I don't suppose anyone knows whether GetOpenFileName is wrapped on hackage somewhere? Win32 doesn't seem to have it.
03:29:31 * ivanm doesn't even know what that does
03:29:40 <ivanm> Zao: is it in Filepath? directory?
03:29:51 <Zao> ivanm: It opens the common Open File dialog.
03:30:07 <ivanm> oh, a dialog
03:30:20 <ivanm> AFAIK there is no real windows GUI library for that kind of stuff
03:30:32 <ivanm> _maybe_ the gtk bindings for windows do so, but I doubt it
03:31:57 <Zao> Meh, I'll foreign import it and manually spec out the bits I need for this particular case.
03:35:11 <younder> There is no Gnome for Windows.  (It is a windows manager)
03:35:40 <Zao> younder: metacity is a WM, gnome is a desktop environment.
03:35:54 <younder> The library however which provides a thunk between GDT and Windows should support this just fine.
03:36:20 <Zao> I don't want to use any icky gtk, I just want the pure unadulterated function imported.
03:36:32 <Zao> Without any dependencies, so I'll just import it myself.
03:37:36 <Raynes> Zao: GTK think's you're icky.
03:37:52 <younder> Whatever, but you are throwing portability out the window.
03:38:42 <younder> Anyhow you shoul always keep al interface lyer between OS, UI and DB.
03:38:54 <younder> s/lyer/layer/
03:39:09 <zygoloid> s/al/an/
03:39:36 <younder> Just in case the underlying imp. changes. Or you find you need/wish to port it.
03:40:11 <Zao> younder: Portability is irrelevant.
03:40:22 <Zao> younder: This is a one-off tool for a purely Windows corp.
03:40:42 <younder> Zao, dream on
03:40:48 <Zao> younder: I don't give a hoot about abstraction, it's a 50LOC script written in Haskell due to the lack of Perl or Python.
03:40:54 <Zao> younder: In my case.
03:41:04 <younder> ahh
03:42:39 <younder> But you have both Perl and Pyton versions for windows. (in fact they are far more common that Haskell). If I were you I would just rewrite it in Python.
03:42:54 <Zao> younder: I cannot deploy any runtimes.
03:43:14 <Zao> Sure, there's py2exe, but I don't speak Python well enough to get this done quick.
03:43:44 <younder> Zao, You can learn python in a week..
03:44:01 <younder> well the core language
03:44:28 <younder> and you already know the  windows lib.
03:44:29 <Zao> younder: I have known Python in the past. I don't have time to refresh the knowledge and finding out whether the standard library has the kind of batteries I need.
03:44:40 <Zao> Not to mention that this tool should be finished yesterday. Literaly :D
03:44:51 <younder> ouch!
03:45:45 <maurer_> If I wanted to make something of the type (SomeTypeClass a) => [a]
03:45:53 <maurer_> Except I wanted multiple different types of a
03:45:58 <maurer_> How might I go about that?
03:46:13 <maurer_> (I want a collection of things, the only thing I care about is that I can apply a specific set of functions to them)
03:46:26 <Zao> You need a wrapper around a.
03:46:30 <younder> mauke, heard of polymorphism
03:46:32 <Zao> And I can't remember the name of it.
03:47:10 <Zao> http://www.haskell.org/haskellwiki/Heterogenous_collections#Existential_types
03:48:00 <maurer_> Thanks
03:48:27 <younder> sounds like a linguist masturbating ;)
03:53:33 <younder> Are you all Germans..?
03:54:11 <ivanm> you mean everyone here now?
03:54:17 * ivanm certainly isn't
03:54:22 <maurer_> I'm not.
03:54:40 * younder is Norwegian
03:55:09 * ivanm is Australian of Slavic descent
04:15:39 <sajkr> ivanm: serbian or...?
04:20:09 <ivanm> sajkr: 1/4 ;-)
04:20:33 <DevHC> well, basically http://pastebin.com/7XujWPcb
04:21:25 <DevHC> but short on an postgresql database installation, i can't reproduce the uber memory usage (the linked code compiled ghc -O99 uses limited memory)
04:22:06 <ivanm> did you profile?
04:22:22 <DevHC> i have no idea what profiling is.
04:22:49 <ivanm> http://en.wikipedia.org/wiki/Profiling_%28computer_programming%29
04:23:08 <DevHC> srsly i can't test now, and therefore i can't profile the memory usage
04:23:34 <ivanm> well, we can't help you much then
04:23:40 <DevHC> .kthx
04:23:49 <ivanm> see here for when you can: http://book.realworldhaskell.org/read/profiling-and-optimization.html
04:24:08 <DevHC> gwd.
04:24:20 <DevHC> btw will that book always be downloadable for free?
04:28:18 <merijn> Since people here are huge nerds, any "Type Theory for Dummies" suggestions?
04:38:23 <ivanm> DevHC: the online version, yes
04:38:23 <Saizan> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ <- maybe?
04:38:39 <ivanm> at least until dons, bos and CosmicRay run out of funding for the website... ;-)
04:38:49 <ivanm> Saizan: maybe TaPL?
04:39:21 <merijn> Saizan: Ah, that looks like a promising start
04:40:37 <Saizan> tapl doesn't cover "Type Theory", it's a nice introductions to type systems though
04:40:57 <ivanm> fair enough
04:41:06 <merijn> ivan: TaPL is still on my "to read" list. 
04:41:20 * ivanm only skimmed through it for info on lambda calc + church encoding last year
04:41:28 <merijn> But since I decided I'm never going to do any learning about type theory unless I force myself, I've decided to do my master's literature study on type theory. Which means I need some quick crash courses in terminology and where to start instead of staring bewildered at papers :p
04:41:28 <fasta> Most type systems are not that complicated; they are just written down in obscure language. 
04:41:30 <ivanm> *sigh*
04:41:34 <fasta> (and often wrong)
04:41:35 * ivanm /= ivan (for nicks)
04:41:58 <merijn> ivanm: Pick something with more obvious tab-completion failures, then ;p
04:42:28 <ivanm> it's not my fault; ivan never used to be in this channel!
04:42:40 <ivanm> also, xchat at least does tab-completion based upon activity as well...
04:42:49 <ivanm> preflex: seen ivan
04:42:49 <preflex>  ivan was last seen on #haskell 60 days, 45 minutes and 12 seconds ago, saying: if I abandon my IRC life, it's yours
04:43:01 <ivanm> ^^ last time ivan spoke here
04:43:05 <ivanm> (talking to me IIRC)
04:43:17 <Saizan> fasta: at least we get inference rules in papers now, i've seen some old ones where they were explained in prose.
04:43:35 <fasta> Saizan, heh. 
04:43:50 * ivanm suddenly imagined inference rules explained as poetry for some reason
04:43:52 <fasta> Saizan, I didn't see those I think. Even the old Coq papers were pretty solid. 
04:44:14 <ivanm> forget a paper written as a play (the regex one submitted as a pearl to ICFP); we need a haiku paper!
04:45:02 <merijn> ivanm: I can't believe that doesn't exist yet
04:46:15 <Saizan> http://portal.acm.org/citation.cfm?id=671442 <- 1995, but i guess this is more logicians' material
04:46:33 <Philonous> merijn: I think TAPL is pretty standard: http://www.cis.upenn.edu/~bcpierce/tapl/
04:47:07 <ivanm> Philonous: I already suggested that, and Saizan said it was more about type systems rather than type theory
04:50:35 <Saizan> i guess i'm a bit arbitrary in interpreting merijn's "type theory" as "intuitionistic type theory", anyhow tapl doesn't cover dependent types, to be more concrete.
04:51:56 <merijn> In my case it doesn't really matter which specific interpretation of "type theory" as long as I can read it without prior knowledge of type theory and it'll get me some starting points in the subject
04:53:17 <Peasley> it's me with my noob question :P
04:53:17 <Peasley> quickSort :: [Int] -> ([Int] -> [Int])
04:53:17 <Peasley> quickSort y = (\x -> x + 1)
04:53:35 <Peasley> why would I get error when i use it as print(quickSort [5] 2)
04:53:59 <Saizan> does that definition even typecheck with that signature?
04:54:42 <Peasley> as I understand it tries to use it as quickSort([5], 2) instead of (quickSort([5]))(2)
04:55:00 <Philonous> Peasley: Your type says x is a list of Int, but you try to 1 to it. That doesn't work
04:55:16 <Peasley> oh sorry yes I see my mistake
04:55:17 <Philonous> add
04:55:30 <Zao> Peasley: You seem to be attributing C-like semantics to a(b, c)
04:55:53 <Peasley> Zao yeah coming from C, trying to get used this new notation :P
04:56:35 <Zao> Let's take your (quickSort [5] 2) expression. First we apply quickSort to [5], getting a result of type [Int] -> [Int].
04:56:36 <Philonous> Peasley: If you want to add 1 to all elements of x, you can use "map (+1) x" 
04:56:50 <Zao> Then you try to apply that to 2, which most definitely is not a [Int].
04:57:00 <Peasley> Philonous oh no, just following something in book and thought id test myself out lambdas
04:58:06 <merijn> Peasley: This would be a better/easier lambda example: map (\x -> x + 1) [1,2,3,4,5]
05:00:11 <merijn> > map (\x -> x + 1) [1,2,3,4,5]
05:00:12 <lambdabot>   [2,3,4,5,6]
05:03:42 <Philonous> Peasley: btw. "->" is right-associative, so you can write "a -> (b -> c)" simply as "a -> b -> c" and "quickSort y = (\x -> x + 1)" can be written as "quickSort y x =  x + 1" which may be easier to read
05:21:25 <dom96> how do i resolve ambiguous module names ?
05:27:06 <Lemmih> dom96: Ambiguous module names?
05:27:50 <dom96> http://pastebin.com/RHahftMN
05:28:11 <Lemmih> dom96: Hide one of the packages.
05:28:19 <dom96> ok, thanks.
05:28:30 <Lemmih> dom96: Or specify which of the packages you want to use.
05:28:39 <dom96> how do i do that?
05:29:00 <Lemmih> -package mtl or -package monads-fd
05:29:13 * zygoloid likes package-qualified imports, but they make various people grumpy
05:29:24 <dom96> oh, i was hoping i could do it in the file...
05:29:46 <Lemmih> dom96: You can if you use cabal.
05:30:27 <dom96> oh, well for now i'm just experimenting with monads.
05:30:44 <Lemmih> dom96: The easiest thing would be to hide one of the packages.
05:30:54 <dom96> yeah, that works.
05:31:47 <zygoloid> dom96: if you want to do it in the file, you can write: import "mtl" Control.Monad.Reader
05:31:55 <Blkt> good day everyone
05:32:41 <dom96> zygoloid: thanks, that's exactly what i wanted
05:34:48 <zygoloid> as i said, this extensoionyou'll need to turn on the PackageImports extension. makes some people grumpy
05:38:55 * hackagebot improve 0.0.11 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.0.11 (TomHawkins)
05:40:22 <dom96> ok, so i've created a nice event based IRC Library in haskell. And now i am stuck as to what would be the best way to create a modular IRC Bot with it. I'm using the hint package and it works somewhat(ByteStrings don't seem to work for some reason), I need a way to add/remove modules, but since Variables are immutable in haskell i can't do that. I'm not sure if i should Monads, what would you all suggest?
05:40:52 <dom96> *use monads
05:41:38 <Cale> dom96: Just IO should be enough.
05:41:53 <Cale> dom96: Note that there *are* mutable variables in IO.
05:42:02 <Cale> (See the Data.IORef library)
05:42:33 <dom96> I've tried using MVar's, but the MVar doesn't seem to change...
05:43:29 <dom96> Would it be different with IORef's ?
05:43:38 <Cale> MVars can be changed.
05:44:03 <Cale> Does the program block? Writing to an MVar which is full will cause that thread to block.
05:44:57 <dom96> yeah it block. But it blocks on takeMVar i think
05:45:02 <dom96> *blocks
05:45:15 <dom96> It works if i pass the MVar to the event.
05:45:33 <dom96> But if i declare the MVar 'globally'
05:45:36 <Cale> That happens if the MVar you're trying to read is empty
05:45:46 <Cale> What do you mean globally?
05:45:54 <dom96> top-level
05:46:01 <Cale> Using unsafePeformIO?
05:46:20 <dom96> loadedPlugins = newEmptyMVar
05:46:38 <Cale> That defines loadedPlugins to be an IO action which creates a new empty MVar when run.
05:46:49 <dom96> oh
05:47:42 <dom96> So should i just declare the MVar in my main function?
05:47:45 <Cale> Yeah
05:48:20 <dom96> Does that mean that if my event changes the MVar it will be changed everywhere?
05:55:29 <dom96> yeah, that works.
05:55:36 <dom96> Thanks a lot for the help
05:55:52 <dom96> Just one last question. Why do ByteStrings not work with the hint package?
05:56:39 <quicksilver> they do.
05:56:48 <quicksilver> can you explain what you mean by "not work with" ?
05:57:08 <dom96> It says that Data.ByteString.Internal.ByteString is not in scope
05:59:35 <Gracenotes> what did you import? you can get the type itself from Data.ByteString..
06:04:52 <dom96> WontCompile [GhcError {errMsg = "Not in scope:\n  type constructor or class `Data.ByteString.Internal.ByteString'"},GhcError {errMsg = "Not in scope:\n  type constructor or class `Data.ByteString.Internal.ByteString'"}]
06:04:55 <dom96> That's what i get
06:06:07 <dom96> http://gist.github.com/529843
06:06:11 <dom96> That's what i'm trying to import
06:07:53 <ski> Wooga : one *can* use `interact' to orderly switch between the program waiting for input and the program doing output, not waiting for input .. but it's a bit fiddly .. so usually, this is a sign to use something other than `interact'
06:08:32 <ski> (plus `interact' only handles stdin -> stout translation, assuming no errors anywhere)
06:08:44 <ski> Saizan : that `List' definition reminds me of van Dalen's and Troelstra's "hesitant sequences" ..
06:08:58 <ski> younder : the first Mercury implementation was written in Mercury
06:09:01 <tafryn> This may be a silly question, but is there a convenient way to color the ghci prompt differently from the output?
06:09:06 <ski> kmc : s/polymorphic container/parametric container/ :)
06:10:31 <dom96> Anyone know how to fix that 'hint' problem ?
06:19:42 <ski> hm (re tolkad's earlier query), maybe there should be a `class Category ar => Foo ar where apply :: ar a b -> (a -> b); ...' ?
06:20:11 <ski> (i.e. instead of `arr :: (a -> b) -> ar a b' we get the converse)
06:20:57 <ski> to be used for things with a main interpretation as functions, but with some more information hanging around
06:21:15 <ski> (a motivating example would be good ..)
06:25:04 <dom96> I think this qualifies as hint not working with ByteStrings
06:25:07 <dom96> :\
06:25:18 <shapr> Good morning Haskell!
06:29:09 <augur> hmm
06:29:52 <Saizan> ski: do you have a good reference for those?
06:31:12 <danportin> If I was writing a monad instance trees without parameters in their branches, I would write something like 't >>= f = case t of {Leaf a -> f a ; Node [Tree a] -> Node (map (>>= f) ts)}. When I try to write an instance for rose trees, e.g., 'data Tree a = Node a [Tree a]
06:31:15 <quicksilver> dom96: maybe hint gets confused by qualified imports?
06:31:27 <danportin> ', I end up with something that looks like fmap, but shouldn't be.
06:31:58 <quicksilver> ski: yes, I have seen structures like that.
06:32:05 <dom96> quicksilver: if i do, import Data.ByteString the same thing happens
06:32:09 <quicksilver> ski: I normally call apply 'interpret' or 'execute'
06:32:19 <danportin> e.g., (Node a ts) >>= f = (f a) (map (>>= f) ts). I'm not sure what's going wrong here.
06:32:44 <quicksilver> dom96: perhaps it's OverloadedStrings it doesn't like?
06:33:05 <dom96> quicksilver: oh! i think that's it
06:34:33 <kmc> good morning shapr :)
06:34:44 <ski> morning, shapr
06:34:48 <dom96> quicksilver: nope
06:34:50 * shapr boings cheerfully
06:35:00 <dom96> quicksilver: just gave me different errors, after i fixed them. Same thing
06:35:09 <ski> danportin : what is the type you used in the first part ? .. or maybe that was your rose trees, as well ?
06:35:16 <shapr> stepcut pointed me to his haskell -> asterisk lib @hackage AGI that should be fun for me!
06:35:30 <ski> Saizan : they are briefly described in Troelstra's and van Dalen's "Constructivism in Mathematics: An Introduction - Volume I" (maybe in the second volume as well, i have barely seen it)
06:35:43 <danportin> I'm using 'Tree a = Node a [Tree a]', which is throwing me off here
06:35:43 * shapr considers @(hackage AGI) as inline lambdabot command execution
06:35:43 <ski> Saizan : i can give you a short description, if you like
06:36:00 <shapr> Has anyone used lambdabot with xmpp recently? Looks like I'll need that.
06:36:01 <Saizan> ski: what are they used for?
06:36:27 <ski> Saizan : well, first, this in under the topic of choice sequences
06:36:56 <quicksilver> dom96: maybe you haven't told hint how to find the bytestring package?
06:37:16 <ski> Saizan : a choice sequence is basically a function of type `|N -> a', for some element type `a', where we don't necessarily define the whole sequence at once
06:37:19 <dom96> quicksilver: how do i tell it to find the bytestring package ?
06:37:22 <quicksilver> dom96: I can't see what would be special about bytestring compared to any other module to make it give a hint error like that
06:37:25 <quicksilver> I dunno.
06:37:38 <dom96> I have setImportsQ [("Prelude", Nothing), ("Data.Map", Just "M"), ("Data.ByteString.Char8", Nothing)]
06:37:46 <augur> anyone familiar with theoretical CS and the halting problem and FLT and the like?
06:38:22 <Ke> naah, we are all just bulk programmers
06:38:24 <ski> Saizan : so, we can write a `(+) : Num a => (|N -> a) * (|N -> a) -> (|N -> a)' function, e.g., that performs point-wise addition, *without* relying on the input sequences being *algorithmic* at all
06:38:50 <ski> Saizan : all we require is that we *eventually* get to know each element of a given choice sequence
06:39:38 <Saizan> ski: by algoritmic you mean that those don't really need to be computable functions in some language?
06:39:42 <kmc> augur, fermat's last theorem?
06:39:48 <augur> kmc: what
06:39:51 <kmc> FLT?
06:39:53 <augur> oh
06:39:56 <augur> formal language theory
06:39:59 <kmc> oh
06:40:04 <kmc> i know some theoretical CS, as do many others here
06:40:13 <ski> Saizan : so choice sequences are to be computable, in the sense that if we give them a natural number as input, they will eventually compute an output element, but there need not be an algorithm (/ a law) that in advance decides the full behaviour of the sequence
06:40:14 <kmc> you can just ask your question
06:40:31 <augur> kmc: well fine :P
06:41:28 <augur> anyone know of any research into viewing the decidable cases of halting behavior as tape languages?
06:41:28 <Saizan> ski: oh, so for example which positions are observed can alter the elements you'd get?
06:41:39 <ski> Saizan : right, there need not necessarily be a total recursive function which computes the sequence (that is not to say that there need to exist cases where a sequence definitely is not algorithmic ..)
06:42:59 <ski> Saizan : so, one choice sequence might be the temperature at a specific place .. or the stock level .. or its elements might be chosen by some oracle (a user)
06:43:02 <kmc> augur, interesting idea; i don't know anything about that
06:43:20 <Saizan> ski: ah, ok
06:44:28 <ski> Saizan : so, for each choice sequence, in general we only know at each point in execution time a prefix of the sequence (the already given part), and then a yet to be determined suffix
06:45:02 <ski> Saizan : anyway, a *lawful* choice sequence is one for which we actually *know* that it is computed by an algorithm
06:45:59 <Wooga> what means 'accessor' in context of haskell? usage of record-syntax data declaration?
06:46:45 <Saizan> data Foo = Foo { foo :: X, bar :: Y } <- foo and bar are sometimes called accessors
06:46:59 <Wooga> Saizan: thank you!
06:47:10 <Saizan> some libraries define a fancier version of those and might use the same term for their version too
06:48:00 <ski> Saizan : there's now also the concept of a *lawless* choice sequence, in which we have a priori decided *not* to conform to a law/algorithm at any stage .. so, if `a' ranges over *lawful* choice sequences, and `alpha' over arbitrary choice sequence, then that `alpha' is a *lawless* sequence can be expressed as `not exists a. alpha = a'
06:48:32 <gio123> ski
06:48:47 <ski> (one can give the notion of "stage" there a more precise interpretation, in terms of Kripke semantics for intuitionistic logic)
06:48:54 <Saizan> ski: i wonder what they are using all these sequences for :)
06:49:17 <ski> Saizan : well, for one thing, one can define real numbers from them
06:49:48 <ski> Saizan : and, if one allows other sequences than lawful sequences, then the properties of real numbers change
06:51:30 <ski> Saizan : anyway, a *hesitant* choice sequence is one such that at any stage we either decide that henceforth we are going to conform to a law, or, if we haven't already decided to conform to a law, we may "arbitrarily" choose the next element (and repeat)
06:52:08 <ski> so, that `alpha' is a hesitant choice sequence can be expressed as `not not exists a. alpha = a' (`a' still ranging over lawful sequences)
06:53:21 <ski> Saizan : anyway, that last is what i thought reminded of your `List', in which at each stage you either terminate the list or adjoin one more element, *or* you decide that henceforth, there will be infinitely many more elements
06:54:50 <Saizan> ski: i see :)
06:55:20 <ski> Saizan : re motivations for choice sequences (in general) .. in practice, most operations on sequences don't require that the sequences have an algorithm, only that we can compute as many elements as we like .. so it seems an arbitrary restriction to require that all sequences must definitely be algorithmic (as the Markov school of russian constructivists do)
06:55:24 <Saizan> so i guess they can make the real numbers even stranger with this..
06:56:16 <ski> otoh, once we admit general choice sequences, one *might* want to adopt some more or less reasonable-sounding axioms regarding them .. as the Brouwer intuitionist school does
06:56:37 <ski> and doing *that* enables one to show theorems which are *false* in classical mathematics
06:57:18 <gio123> ski
06:58:12 <ski> there's also the Bishop school of constructivism which neither claims all functions are algorithmic (which leads to classically false theorems), nor adopts these extra axioms re choice sequence (which also lead to classically false theorems) .. and so Bishop's school stays forward compatible with classical mathematics
06:58:25 <augur> ski
06:58:29 <augur> you're incredibly nerdy
06:58:36 <augur> marry me
06:58:37 <copumpkin> lol
06:58:38 * ski bows
06:58:53 <snowboard> mmm
06:58:56 * snowboard glares at ski
06:59:01 * Saizan likes to go anti-classical
06:59:58 <ski> yeah, i wouldn't say there's necessarily anything *wrong* with going anti-classical, as long as the anti-classical axioms are well-motivated
07:00:35 <ski> it's just that it's probably a good tactical move to keep large parts of constructive mathematics forward compatible with classical mathematics
07:02:22 <ski> Saizan : as an example of an anti-classical principle, if you have a (total) function `gamma : (|N -> a) -> Bool' (for some specific `a'), then it seems reasonable to assume that if this is to be computable, and still terminate with a finite `Bool' output, it will need to only look at a finite part of its input in each case
07:03:35 <ski> Saizan : so, if we make that an axiom, that for every `alpha' there is some finite prefix of `alpha' such that every `beta' with the same prefix satisfies `gamma alpha = gamma beta', that would be one such anti-classical axiom
07:04:28 <Saizan> ski: that's how we justify the termination of escardo's search, right?
07:04:34 <ski> yes
07:05:25 <ski> it's an argument like "we can't imagine how `gamma' could terminate without that property holding, so we're going to assume it as an axiom"
07:06:04 <Saizan> well, it also makes sense computationally :)
07:06:30 <ski> it's a bit similar in spirit, in that regard, to Markov's principle, which says that if `not not exists n : |N. P n' for a *decidable* property `P', then `exists n : |N. P n'
07:07:02 <ski> the (pseudo-)algorithm is : just try `P' on each natural number in turn, until you find one which satisfies `P' ! :)
07:08:07 <ski> (that `P' is decidable could be expressed as `forall n : |N. P n \/ not (P n)')
07:08:41 <Saizan> that sounds less convincing for some reason..
07:10:10 <ski> well, it's convincing enough for the russian constructivists :)
07:11:58 * ski has some ideas about a related axiom `forall P. (forall n : |N. P n \/ not (P n)) -> (exists (forget n) : Forgotten n. P n) -> (exists n : |N. P n)' where `Forgotten' is a bit like `not not', but (i think) stronger
07:12:53 <ski> danportin : hm, so you're trying to make `Tree' as in `data Tree a = Node a [Tree a]' into a monad ..
07:13:13 <ski> .. i think that's problematic (i'm not sure it is possible)
07:13:34 <copumpkin> Comonad!
07:13:36 <ski> but it appeared you had more trouble with the basics of pattern-matching on the type
07:14:09 <ski> copumpkin : hm, now that you mention it, that sounds likely, yes :)
07:14:17 <copumpkin> ski: it's just Cofree [] isn't it?
07:14:27 <ski> hm .. yes
07:14:52 <ski> and `Functor f => Comonad (Cofree f)' ?
07:15:07 <copumpkin> yep
07:15:30 <danportin> ski: The monad instances for the data type 'Tree a = Leaf a | Node [Tree a]' are easy, because those are just variants of monads for n-ary trees without type parameters in the branching nodes.
07:16:03 <danportin> I /think/ my problem is generalizing this to the data type 'Tree a = Leaf a | Node a [Tree a]'.
07:16:07 <ski> danportin : yeah .. but i suspect the rose tree (or binary tree with elements in nodes) case(s) is(/are) impossible
07:16:14 <copumpkin> hah, that's Free []
07:16:51 <ski> danportin : i'm not sure how you see that as a generalization
07:17:09 <copumpkin> someone should prove that (in hask) if X is a monad and is not boring, then it is not a comonad, and vice versa :P
07:17:13 <danportin> It was a poor choice of words
07:17:15 <copumpkin> (assuming it's actually true)
07:17:32 <ski> copumpkin : `(Nat ->)'
07:17:40 <copumpkin> okay lol
07:18:34 <copumpkin> ski: where you have the diagonalization thingy for join?
07:19:59 <danportin> It seems like bind would have to be able to, e.g., take a tree 'Node 0 [Node 1 [], Node 2 []]' and return 'Node (Node x []) [Node (Node x1 []) ...]', etc. So in 't >>= f', f would need to be applied to t, then recursively to each branch.
07:20:08 <ski> yeah, `join' on `(x ->)' would use the binary operation of the trivial comonoid on `x' (i.e. discard and copy), while `scaffold' would use binary operation of the given monoid on `x'
07:20:34 <ski> (`scaffold :: Comonad w => w a -> w (w a)')
07:21:20 <shapr> Has anyone used Language.C for C codebase analysis? I'd like to check for any sort of errors, with a mind to extend the checking later.
07:21:27 <ski> danportin : the types prohibit that, since the output there has type `Tree (Tree ...)'
07:21:30 * hackagebot hxt 8.5.4 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-8.5.4 (UweSchmidt)
07:22:08 <copumpkin> sup dawg, I herd you like comonading so i stuck a comonad in ur comonad so u can extend while u extend
07:22:11 <copumpkin> wow, that made no sense at all
07:22:32 <copumpkin> I'm sure I've seen a better version of that
07:23:04 <danportin> Yeah, I realize that. Building a normal monad for trees, (>>=) rewrites leaf nodes (i.e,. nodes containing 'a'), but doesn't create nested trees.
07:23:08 <Phyx-> is there anyway to determine the arity of a function in haskell?
07:23:34 <copumpkin> Phyx-: I wrote something a while back that did it :P
07:23:38 <copumpkin> either that or I tried and failed
07:23:43 <Wooga> can i somehow use function using State monad in `interact' expression?
07:23:55 <quicksilver> Phyx-: it is essentially misguided to do so. All functions have arity one.
07:24:01 <Phyx-> copumpkin: I would love to see it, or the attempt
07:24:09 <quicksilver> Phyx-: to pretend otherwise is to break polymorphism, which is a high price to pay.
07:24:16 <ski> Wooga : you could possibly write a variant of `interact' ..
07:24:32 <Wooga> ski: thanks!
07:25:13 <Phyx-> quicksilver: sure, but someone asked an interesting question here a few days ago, I would still like to find an answer to it, it's how to determine the datatype that a partial application will eventually return
07:25:20 <ski> Wooga : do you want to use a `Char -> (a,Char)' (i.e. `State Char a') action or what ?
07:26:31 <Wooga> ski: i don't really know. i just want to hide stack of my brainfuck interpretator into State monad
07:26:40 <copumpkin> Phyx-: okay, it worked
07:27:18 <Phyx-> copumpkin: mind showing me the code? or is it under some kind of nda?
07:27:30 <copumpkin> lol not at all, was just pasting it :P
07:27:31 <copumpkin> http://pastie.org/1097748
07:27:41 <Phyx-> cool thanks :)
07:27:45 <quicksilver> Phyx-: OK, but you need to confront the polymorphism question to decide how to frame the question in a way which makes sense.
07:27:53 <quicksilver> Phyx-: for example, what is arity(id) ?
07:27:56 <ski> danportin : assume you want to write `join :: Tree (Tree a) -> Tree a', so you get an input like `Node (Node a [Node b [],Node c []]) [Node (Node e []) [],Node (Node f []) []]', now you want to convert that to form `Node i [Node j [...],Node k [],...]'
07:28:07 <copumpkin> quicksilver: you need to fix a type for it :P
07:28:11 <copumpkin> at least in my version
07:28:40 <ski> danportin : so, maybe you can lift out the `a' top element in the top tree as `i' (the top element in the result) .. but what to do with the "side trees" in the top tree `Node a [Node b [],Node c []]', then ?
07:28:46 <Phyx-> quicksilver: I see your point though :)
07:28:56 <ski> danportin : i think it's not possible to do this, which satisfying the monad laws
07:29:07 <copumpkin> ski: proof!
07:29:15 <ski> i have no proof :)
07:29:57 <ski> @src interact
07:29:57 <lambdabot> interact f = do s <- getContents; putStr (f s)
07:30:25 <copumpkin> *Main> let f x y z a b c = 5
07:30:25 <copumpkin> *Main> arity f
07:30:25 <copumpkin> 6
07:30:49 <hpc> @src String read
07:30:50 <lambdabot> Source not found. Wrong!  You cheating scum!
07:31:22 <zygoloid> ski: "join (Node (Node v xs) ys) = Node v (xs ++ ys)" looks like it should work.
07:31:40 <zygoloid> no, that's nonsense :o
07:31:59 <ski> @type let interact' :: (String -> (String,a)) -> IO a; interact' f = do s0 <- getContents; let {(s1,a) = f s0}; putStr s1; return a  in interact'
07:32:00 <lambdabot> forall a. (String -> (String, a)) -> IO a
07:32:01 <zygoloid> Node v (xs ++ map join ys)
07:32:07 <ski> Wooga : maybe you want something like that ^ ?
07:32:14 <Phyx-> copumpkin: ah, that's along the line of what I imagined :) It should be possible to use that to find out how many undefines to feed a function
07:32:18 <copumpkin> zygoloid: the question is whether it'll satisfy the laws
07:32:32 <zygoloid> copumpkin: right, i'm suggesting that it should
07:32:32 <Wooga> ski: thanks, i'll try to understand this
07:32:52 <copumpkin> Phyx-: you'll just end up making a class for the n-ary application
07:33:38 <ski> zygoloid : more like `join (Node (Node a ats) atts) = Node a (ats ++ map join atts)' .. but .. laws ?
07:33:51 <ski> @type Data.IORef.modifyIORef
07:33:52 <lambdabot> forall a. GHC.IOBase.IORef a -> (a -> a) -> IO ()
07:33:54 <ski> @type Data.IORef.atomicModifyIORef
07:33:55 <lambdabot> forall a b. GHC.IOBase.IORef a -> (a -> (a, b)) -> IO b
07:34:01 <danportin> Interesting, ski. I'll have to think about possible ways to write join, since I already have fmap and return. Today is going to be filled with typeful fun :)
07:34:21 <danportin> Well, something like that.
07:34:35 <Peasley> hey guys, so I did this 'transpose matrix' which is supposed to change columns/rows of matrix
07:34:35 <ski> Wooga :  interact'  is not a very good name. it should correspond to `interact' as `atomicModifyIORef' there above corresponds to `modifyIORef' (at least type-wise)
07:34:36 <copumpkin> danportin: let me know if that works! I'm curious to find examples of things that are monads and comonads
07:34:40 <Peasley> transpose_matrix m1 = [ y | (y:dz) <- m1 ] : transpose_matrix [ dz | (y:dz) <- m1 ]
07:34:42 <Phyx-> in Distribution.Simple.Program.HcPkg , what are you supposed to feed to ConfiguredProgram
07:34:47 <Peasley> by base case is transpose_matrix [] = []
07:34:56 <Peasley> however I keep getting arrays which has [] in concated in it, how do i avoid that?
07:35:44 <Peasley> I could filter the final output but it's kind of lame :P
07:36:07 <copumpkin> (y:dz) ==> ((y:ys):dz) and then stick (y:ys) in the left hand side too
07:36:16 <danportin> Sure :)
07:36:24 <copumpkin> Peasley: just guessing though :P
07:38:08 <ski> copumpkin : oh, apart from the `(m ->)' when `Monoid m' example i mentioned, there's also `(m,)' when `Monoid m'
07:38:32 <ski> (in both cases do we use the trivial comonoid on `m' in the "other" case)
07:38:51 <copumpkin> yeah
07:40:10 <ski> Peasley : what examples do you get empty lists in the result for ?
07:41:01 <Peasley> print( transpose_matrix [[2,3],[1,-5]] )   =>  [[2,1],[3,-5],[]]
07:41:16 <zygoloid> ski: yeah, i'd already made that correction. here's your proof. http://paste2.org/p/953807
07:41:16 <Peasley> @ ski
07:41:59 <copumpkin> ski: could rose trees be seen as Monoid => (m ->) where m = Fix []?
07:42:08 <copumpkin> can Fix [] be a monoid?
07:42:12 <copumpkin> seems like it
07:42:21 <ski> s/map a xs/map f xs/
07:42:27 <Phyx-> :t dataTypeOf
07:42:29 <lambdabot> forall a. (Data a) => a -> DataType
07:42:36 <Phyx-> :t typeOf
07:42:37 <lambdabot> forall a. (Typeable a) => a -> TypeRep
07:43:19 * ski never understood why people use `==' for declarative equality, when there's already `=' ..
07:44:10 <Veinor> @pl \x y -> ((f x) `on` g) x y
07:44:10 <lambdabot> (`on` g) =<< f
07:44:47 <FunctorSalad_> (already taken?)
07:46:17 <zygoloid> ski: i try to use = as a statement of fact, and == as a predicate
07:46:29 <ski> what's the difference ?
07:47:20 <zygoloid> "is it the case that map f . map g == map (f . g)?" versus "you know, product = foldr (*) 1"
07:47:32 <zygoloid> so basically no difference :)
07:52:05 <ski>      Fix [] -> b  =  [Fix []] -> b  =  (1 + Fix [] * [Fix []]) -> b  =  (1 -> b) * (Fix [] * [Fix []] -> b)  =  b * (Fix [] -> [Fix []] -> b)
07:52:26 <FunctorSalad_> ski: I use '=' here for applicative equality (or whatever metalevel equality is appropriate for haskell) here
07:52:36 <FunctorSalad_> (==) for the method of Eq
07:54:16 <FunctorSalad_> (by 'applicative' I mean the equality that extends to function types by f=g <=> all x y. x=y -> f x = g y, which isn't a (==))
07:54:22 <djahandarie> There needs to be an introduction to type-level programming somewhere
07:54:27 <FunctorSalad_> not sure if that was its name
07:54:59 <FunctorSalad_> (and whether the x and y are really needed ;))
07:55:02 <Saizan> byorgey's recent blog posts might be one
07:55:08 <Saizan> the other is the HList paper :)
07:55:29 <Veinor> http://pastebin.com/B0NH84sv
07:55:30 <ski> FunctorSalad_ : good :)
07:55:49 <Veinor> I wrote this in about... 20 minutes. does it look good?
07:56:03 <djahandarie> Oh yeah, I remember these blog posts now
07:56:04 <ski> (FunctorSalad_ : well, `forall x y. x = y -> P x y' is equivalent to `forall x. P x x', so ..)
07:56:08 <zygoloid> djahandarie: you might find this useful: http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
07:56:25 <FunctorSalad_> I guess it's a theorem that forall x y. x = y -> f x = f y
07:56:34 <Veinor> (it lets you make sets of things without Ord instances that you can still define a 'compare' function for)
07:56:40 <tnks> trying to learn more about monadic composition; just started reading a "Composing monads" paper, but it's from 1993.
07:56:49 <FunctorSalad_> (for the '=' defined by induction on the type structure)
07:56:51 <tnks> should I start with something else?
07:56:56 <ski> (FunctorSalad_ : but it's a useful expansion to know, e.g. when thinking of analogues as `forall x. f x =< g x' vs. `forall x y. x =< y  =>  f x =< g y')
07:57:14 <zygoloid> i guess one generalization of (=) vs (==) might be that (=) is extensional and (==) is intensional
07:57:21 <FunctorSalad_> ski: it's equivalent for the real equality
07:57:30 <FunctorSalad_> but here '=' is some defined thing
07:57:47 <tnks> the paper introduces functions `prod`, `dorp`, and `swap`, not sure if they ended up central in practice.
07:58:06 <FunctorSalad_> it's taken as a given for base types and then extended to function types by induction over the (->)s
07:58:36 <copumpkin> ski: what were you saying about Fix [] ?
07:58:41 <Philippa> tnks: what everyone does in practice these days is use monad transformers
08:00:50 <tnks> Philippa: thanks, Google got me there.
08:01:17 <ski> FunctorSalad_ : afaic, the `=' used in the defining equations *is* the real equality. we're assuming a couple of (non-contradictory) axioms re functions, stated in terms of equality
08:01:30 <ski> (s/afaic/afaiac/)
08:02:11 <ski> (FunctorSalad_ : btw, `forall x y. x = y -> f x = f y' is known as : `f' is extensional. it is usually assumed, yes)
08:03:08 <FunctorSalad_> ski: ok, I should use another symbol probably ;)
08:03:17 <Philippa> tnks: it'll take you a while to work out which order to call the "runTransformer" functions in (hint: what happens when you use a new transformer for a local piece of code?), aside from that they're mostly pretty easy if occasionally mildly tedious
08:03:22 <ski> tnks : i think that paper should be fine, if a bit old
08:03:33 <ski> FunctorSalad_ : why ? :/
08:04:06 <FunctorSalad_> ski: to make it clear I'm defining a relation rather than asserting extensionality
08:04:24 <FunctorSalad_> (or extensional equality of functions, rather)
08:05:17 <Peasley> is haskell powerful enough for this? 	(tpr1, tpr2) = map (filter remove_nulls) [transpose_matrix m1, transpose_matrix m2]  Basically I want to apply "filter remove_nulls" to each matrix(m1 and m2)
08:05:32 <Peasley> just cant get it to compile though
08:05:32 <ski> FunctorSalad_ : hm, what example are you talking about, atm ?
08:05:52 <Twey> Peasley: Yes, but map will give you a list, not a pair
08:06:00 <Twey> [tpr1, tpr2] = …
08:06:21 <Peasley> ah ok
08:06:45 <Peasley> Twey thanks :-)
08:07:06 <Twey> While you're doing a map anyway, you may as well not repeat ‘transpose_matrix’
08:07:20 <FunctorSalad_> ski: f === g  :<=>   forall x y. f x === g y
08:07:29 <Twey> [tpr1, tpr2] = map (filter remove_nulls . transpose_matrix) [m1, m2]
08:07:31 <djahandarie> Wow Omega is really cool I haven't seen this before
08:07:34 <danportin> fdan
08:07:36 <copumpkin> FunctorSalad_: only if you're lucky
08:07:38 <FunctorSalad_> (inductive definition with (===) being given for nonfunction types)
08:07:49 <Twey> A.K.A. [tpr1, tpr2] = filter remove_nulls . transpose_matrix `map` [m1, m2]
08:07:58 <zygoloid> > let m1 = [[0,1],[0,1]]; m2 = [[0,1],[-1,0]]; [tpr1,tpr2] = map (filter (not . all (==0))) [transpose m1, transpose m2] in (tpr1, tpr2)
08:08:00 <lambdabot>   ([[1,1]],[[0,-1],[1,0]])
08:08:23 <FunctorSalad_> ski: so I had just been wondering whether having both x and y makes any difference *there* (without having thought about it)
08:08:27 <Twey> Yes, you can always convert it later
08:09:17 <Peasley> oh god lol
08:10:29 <ski> FunctorSalad_ : i'm not sure what you want to say with `f === g  :<=>   forall x y. f x === g y' there, but if you want to just express that your function equality is extensional, then i'd use `='
08:11:15 <Phyx-> copumpkin: lol, got stuck in the same place again
08:11:17 <ski> FunctorSalad_ : since, if we're reasoning about Haskell programs, then the `=' in Haskell programs *are* (with a few caveats) instances of the equality we want to use at the reasoning level
08:11:18 <FunctorSalad_> ski: no, I'm *defining* (===) (and I forgot the x === y on the RHS)
08:11:31 <yrlnry> Suppose I wanted to prove that the functor a -> (a, a)  with map f (x, y) = (f x, f y)  cannot be extended to a monad.  What might be a good technique for doing that, other than just writing out the monad equations and pounding on them in hopes of getting a contradiction?
08:11:34 <Phyx-> copumpkin: check :: (Typeable b, Arity a) => a -> b , but b is too general, can't call typeOf on it
08:11:35 <copumpkin> Phyx-: how so? you need the typeclass I was talking about earlier :P
08:11:54 <ski> FunctorSalad_ : oh, and, i don't believe there's any difference between `:<=>' and `<=>', there ;)
08:11:55 <copumpkin> Phyx-: you just want to pass undefined to all the parameters?
08:12:03 <zygoloid> yrlnry: how sure are you that it can't? :)
08:12:13 <Phyx-> copumpkin: yeah, i'm not interested in the parameters, just the type of the result
08:12:21 <FunctorSalad_> ski: ? the left-hand side isn't defined, so how could it be '<=>'
08:12:21 <copumpkin> Phyx-: let me try that
08:12:34 <yrlnry> zygoloid:  Just a suspicion.  
08:12:36 <zygoloid> yrlnry: join ((a,_),(_,b)) = (a,b) looks like it might work
08:12:39 <ski> FunctorSalad_ : to me, "defined" is not a property in the language
08:12:40 <FunctorSalad_> :<=> is like :=
08:12:45 <FunctorSalad_> ski: to me neither
08:12:47 <yrlnry> zygoloid:  thanks, I'll look into it.
08:13:11 <ski> FunctorSalad_ : yeah, and i've never really seen the need for `:=' instead of `=', except as a typographical note to the reader
08:14:06 <zygoloid> yrlnry: think of it as a finite list monad, where the final act of observation is (head &&& tail)
08:14:18 <ski> FunctorSalad_ : a definition is just a formula which we assumes, and which has to satisfy some conditions, like : the entity being defined should exist and be uniquely determined by the definition
08:14:20 <zygoloid> (head &&& last) rather
08:15:05 <yrlnry> zygoloid:  why does thinking of it that way help?  Is seems to me that all the difficulty is wrapped up in the "final act of observation" part.
08:15:11 <zygoloid> so: return a = [a], pair (a,b) = [a,b], (>>=) is concatMap
08:15:28 <zygoloid> it reduces to a structure we already know is a monad, then discards some information
08:15:58 <FunctorSalad_> ok, I'll try again. "For each base type T, a relation (===)_T is given. We define (===)_T for T a type by induction on the type structure. (===)_{T1 -> T2} = { (f,g)  |  forall x y in T1, x ===_{T1} y implies f x ===_{T2} f y })"
08:15:59 <ski> FunctorSalad_ : so, if you say, "define `x' by `P x', then `Q x' holds by ...", that's really the same as "for every `x', such that `P x', `Q x' holds by ...", and also the same as "there exists an `x', such that `P x', and `Q x' holds by ..." (assuming the existence and uniqueness properties)
08:16:00 <yrlnry> I didn't think that discarding some information from a monad necessarily produced a monad.
08:16:01 <FunctorSalad_> (@ ski)
08:16:15 <copumpkin> Phyx-: this is tricky
08:16:31 <djahandarie> Dan Doel wrote this function type signature in byorgey's blog post... forall (n : Nat) (t u : *). (t -> u) -> Vec n t -> Vec n u    where Nat is a type lifted to a kind... but I don't get the (t u : *)... Does that mean that t u is * (which doesn't make sense to me in this context) or something else?
08:16:49 <copumpkin> djahandarie: probably an agdaism?
08:16:54 <FunctorSalad_> (this is for a simple type system where (->) is the only type constr)
08:17:04 <copumpkin> djahandarie: where you can write t u : A as a shorthand for t : A and u : A
08:17:09 <djahandarie> Ah okay
08:17:12 <FunctorSalad_> ski: sorry, s/f y/g y/
08:17:16 <ski> FunctorSalad_ : ok, so you're defining a type-indexed family of (presumably) equivalence relations. (that wasn't clear to me before)
08:17:24 <djahandarie> Thanks copumpkin
08:17:42 * djahandarie needs to go learn Agda
08:17:47 <djahandarie> Been talking about it for awhile now
08:17:47 <FunctorSalad_> ski: yes, hence 'maybe I should use another symbol' ;)
08:17:58 <yrlnry> zygoloid:  Anyway, I will consider it carefully.  Thanks very much.
08:17:58 <ski> FunctorSalad_ : i thought you were talking about reasoning about Haskell programs, specifically talking about what notion of equality we want to use there
08:18:07 <zygoloid> yrlnry: implement it as: newtype PairMonad a = PM [a] deriving (Monad), then provide a runPairMonad (PM xs) = (head xs, last xs). that's /clearly/ a Monad, right?
08:18:16 <FunctorSalad_> ski: this one would be a candidate for that
08:18:27 <yrlnry> Sure, I agree.
08:18:38 <copumpkin> djahandarie: it's pretty fun :)
08:18:47 <yrlnry> Oh, now I understand what you mean by "final act of observation".
08:19:02 <djahandarie> I tried one time but found it impossible to find any good documents for learning
08:19:18 <FunctorSalad_> it seems ':=' is different from '=' in that := introduces a new symbol on the LHS
08:19:26 <djahandarie> I guess I'll just need to do the "read a bunch of papers about it" approach
08:19:28 <FunctorSalad_> extending the language
08:19:30 <Phyx-> copumpkin: yeah, i'm starting to think it's not possible for any arbitrary datatype with an instance of Typeable, not unless typeable itself gets a new method "app" or the line
08:19:56 <ski> FunctorSalad_ : my point was more or less that if we've already fixed the notion of equality we want to use at every type, then it makes sense to use the same `=' symbol for it as is used in the definition equations of operations in the language
08:20:04 <Phyx-> copumpkin: or you use a closed set of types, e.g. an instance for every possible type that can be returned
08:20:10 <FunctorSalad_> after a 'f x := blah', f x = blah is an axiom in the extended language
08:21:01 <copumpkin> Phyx-: also, not sure why you'd want the function at all :P
08:21:06 <zygoloid> yrlnry: i think there's a subtlety with infinite computations, as it happens: i think  fix (>> pair (0,0))  gives  (0, _|_)  in my reduction but  (0, 0)  for the direct Monad instance
08:21:10 <djahandarie> Ugh I hate when I get distracted by all this stuff when I'm suppose to be doing real work
08:21:13 <copumpkin> Phyx-: I have something that works now
08:21:18 * djahandarie goes back to hacking on PHP code
08:21:29 <FunctorSalad_> (or 'forall f x. f x = blah[x]' I guess)
08:21:30 <ski> FunctorSalad_ : a definition is just a formula which is "freely assumed", and so we require restrictions on which formulae could be definitions
08:21:46 <ski> FunctorSalad_ : `:=' is not a real logical connective, apart from `='
08:21:46 <FunctorSalad_> *forall x
08:21:47 <Phyx-> copumpkin: it's not for me really :P someone else asked it a while back and I thought it was interesting?
08:21:55 <Phyx-> copumpkin: you do? that's... godlike...
08:21:56 <zygoloid> yrlnry: but that's not really saying anything other than, it's a monad in multiple different ways.
08:21:56 <FunctorSalad_> ski: agreed
08:22:09 <FunctorSalad_> it extends the language
08:22:23 <copumpkin> Phyx-: http://pastie.org/1097861
08:22:34 <ski> FunctorSalad_ : also, i think one can imagine definitions which use neither `=' (/ `:=') nor `<=>' (/ `:<=>') in them
08:22:34 <copumpkin> let f x y = 5
08:22:37 <copumpkin> check f ==> ()
08:22:44 <copumpkin> check (+) ==> Prelude.undefined
08:22:48 <FunctorSalad_> (I mean in a traditional function symbols, relation symbols POV)
08:22:55 <zygoloid> fix (>> pair (0,0))  is  _|_  with join ((a,_),(_,b)) = (a,b) but it's (0,0) with join ~((a,_),(_,b)) = (a,b)
08:23:08 <kmc> copumpkin is godlike?
08:23:32 <copumpkin> maybe just MONSTER KILL
08:23:36 <Phyx-> copumpkin: but that doesn't tell you the type of the result
08:23:37 <FunctorSalad_> haha
08:23:47 <copumpkin> Phyx-: what's the point of that?
08:23:52 <Phyx-> copumpkin: that's equivalent to "check x = foldr ($) undefined $ replicate (arity x - 1) undefined"
08:23:56 <FunctorSalad_> (boom, headshot)
08:24:14 <copumpkin> Phyx-: except can you write that function?
08:24:20 <ski> FunctorSalad_ : so, i treat `f x := ..x..' as something like `Def f by forall x. f x = ..x..' (and similarly for `:<=>')
08:24:23 <Phyx-> copumpkin: copumpkin yes you can
08:24:28 <copumpkin> hm
08:24:45 <Wooga> hello, can this structure (assuming Control.Monad.State and Data.List.Zipper included): `modify (\(BFSnapshot {stack=s, proc=p}) -> BFSnapshot (replace (succ $ cursor s) s) p)' somehow be simplified ?
08:24:46 <ski> (FunctorSalad_ : where `Def <name> by <formula>' is a declaration)
08:24:55 <FunctorSalad_> ski: sure... but isn't that exactly what I intended to do?
08:24:55 <Wooga> using record syntax*
08:24:58 <copumpkin> Phyx-: so what do you want the result type for?
08:25:17 <aristid> can something like type Flip f x y = f y x be used to make class instances for things that usually cannot be due to  having the wrong kind?
08:25:18 <FunctorSalad_> ski: (except I used induction too)
08:25:23 <kmc> Wooga, using GHC's NamedFieldPuns and RecordWildCards you can make it nicer
08:25:23 <Phyx-> copumpkin: well, the asker wanter to pattern match on partial applications. depending on the result of the PAP he'd like to do something else
08:25:24 <copumpkin> aristid: a newtype can
08:25:29 <kmc> aristid, no, you can't make instances for a type synonym
08:25:32 <ski> FunctorSalad_ : .. just trying to explain why i'm not fond of using `:=' or `:<=>' at all
08:25:35 <zygoloid> aristid: no, instances for type synonyms don't work like that.
08:25:39 <kmc> (you can mention a synonym in an instance decl with the right extension, but it's just transparently expanded)
08:25:43 <aristid> kmc: there's -XTypeSynonymInstances?
08:25:43 <copumpkin> Phyx-: oh, that can't work
08:25:49 <copumpkin> aristid: that does nothing useful
08:26:07 <aristid> oh :/
08:26:10 <aristid> too bad
08:26:10 <ski> aristid : yes, but that wouldn't allow you partially apply in the way you want, anyway
08:26:11 <kmc> it's useful for writing instances with less verbosity
08:26:16 <copumpkin> aristid: but a newtype would work
08:26:17 <kmc> same way "type" is generally useful
08:26:21 <FunctorSalad_> ski: but isn't the past discussion a good example why the distinction *is* useful? I meant to convey that I'm defining the '='
08:26:27 <Phyx-> copumpkin: I don't think for any arbritary function no, sadly
08:26:32 <zygoloid> the existence of TypeSynonymInstances is a reasonable argument for allowing type-level tuple sections i think
08:26:33 <aristid> copumpkin: yeah sure, but that would have been cool
08:26:35 <kmc> but it won't allow new instances that weren't allowed before
08:27:05 <Wooga> kmc: isn't any examples of use of NamedFieldPuns exists?
08:27:23 <ski> FunctorSalad_ : oh, sure there's a point to note that something is defined. i just don't think it's really that good/useful to attach that information on the `=' or `<=>' operations
08:27:23 <kmc> yes, in the  GHC manual
08:27:28 <kmc> Wooga, section 7.3.15
08:27:32 <Wooga> thanks!
08:27:35 <kmc> and 7.3.16 for wildcards
08:27:36 <zygoloid> at the very least it defeats the "we can't do that because 'instance Foo (,a)' would be illegal" argument, since that problem already exists for TypeSynonymInstances
08:27:43 <FunctorSalad_> ≝
08:27:44 <FunctorSalad_> :)
08:27:45 <kmc> Wooga, see also the package 'fclabels' if you want nicer support for record update
08:27:53 <FunctorSalad_> really tiny letters are really tiny
08:27:57 <kmc> compose d =
08:27:59 <kmc> :)
08:28:04 <kmc> i prefer ≜
08:30:06 <orbitz> is there an ubuntu package for haskell-platform? Some google shows what looks like manual download an install of haskell-platform
08:30:25 <Peasley> also if i have filter remove_nulls [rray]
08:30:50 <Peasley> can i make the remove_nulls something like  filter (\x -> x == []) ?
08:31:24 <orbitz> filter (not . null)
08:31:44 <Ke> orbitz: in general I don't find haskell platform too relevant
08:32:01 <orbitz> ok
08:32:02 <Ke> in operating systems that do have a package manager
08:33:45 <orbitz> Ke: i was thinking tehre would be a .deb with just a good set of dependencies to represnt haskell paltform
08:34:17 <jules2> I have a question about compiler optimization, not especially about haskell but here he goes. Suppose we have this program:
08:34:18 <jules2> data List = Nil | Cons Int List
08:34:19 <jules2> mul Nil x = x
08:34:19 <jules2> mul (Cons n ns) x = mul ns (n*x)
08:34:19 <jules2> gen 0 xs = mul xs 1
08:34:19 <jules2> gen n xs = gen (n-1) (Cons n xs)
08:34:28 <jules2> it first builds a list of numbers and then multiplies it together
08:34:38 <jules2> it computes factorial
08:34:51 <danportin> Hmm, it looks (informally and initially, of course) like the rose tree monad works (http://pastebin.com/eM699j08). Cool.
08:34:58 <jules2> how could one optimize that to remove the intermediate list automatically?
08:34:59 <kmc> orbitz, there is a haskell-platform package in recent debian
08:35:48 <kmc> jules2, generally those optimizations work better when you use standard combinators like map and foldr
08:35:55 <kmc> jules2, see http://gernot-heiser.org/~dons/papers/CLS07.html
08:36:29 <kmc> in Haskell there is the extra complication of laziness
08:36:31 <kmc> if you ignore than
08:36:32 <kmc> that*
08:36:46 <kmc> then it's not too hard to recognize that the second equation for «gen» is tail-recursive
08:36:49 <jules2> yes, but i'm interested in the harder problem of doing that even if you don't use map and foldr
08:36:54 <kmc> and turn «gen» into a loop
08:37:12 <jules2> yes assume this is a strict program :)
08:37:15 <ski> yrlnry,zygoloid : cf. `\a -> (a,a)' vs, `\a -> (Bool -> a)' (and `Monoid Bool' can be done (in several ways))
08:37:22 <kmc> hmm, then what do we need?
08:37:34 <Cale> danportin: yep, it's a great example of a monad :)
08:37:56 <jules2> i'd like to remove the consing, because it is not necessary to do that to compute factorial
08:38:09 <kmc> yes
08:38:56 <ski> copumpkin : re `(Fix [] ->)' and rose trees; my initial thought is that they're not the same, but i need to ponder it more
08:39:10 <jules2> it is easier if you have a program like "multiply (generateNums n)", because the multiplication happens in the same direction as the generation of the list
08:41:05 <kmc> jules2, perhaps a supercompiler can do it?
08:41:10 <kmc> i don't know much about supercompilation
08:41:20 <kmc> or a tracing jit
08:41:23 <FunctorSalad_> ski: btw, as you hinted at, I think what I defined should coincede with some background level equality if haskell functions have function semantics
08:41:44 <ski> FunctorSalad_ : yeah, probably
08:41:56 <ski> (possibly it's also related to theorems for free)
08:41:59 <FunctorSalad_> it just avoids this semantic background layer
08:41:59 <jules2> I don't think a supercompiler can do it
08:42:04 <jules2> a supercompiler can do this:
08:42:05 <jules2> gen 0 = Nil
08:42:06 <jules2> gen n = Cons n (gen (n-1))
08:42:06 <jules2> mul Nil = 1
08:42:06 <jules2> mul (Cons n xs) = n * mul xs
08:42:06 <jules2> mul (gen n)
08:42:17 <jules2> but not if you make it tail recursive like above
08:42:25 <FunctorSalad_> (well, it has background layer, but just firstorder logic and induction over types)
08:42:32 <yrlnry> ski:  thanks
08:43:20 <ski> jules2 : interesting problem (i don't know the answer)
08:43:35 <kmc> yeah, in that example 'mul' is a foldr
08:43:45 <kmc> and that could be recognized, and the Cons replaced with the fold function
08:43:55 <kmc> but is there a more general optimization of which this is a special case?
08:44:03 <kmc> or are we stuck writing special things like 'foldr detection'
08:44:25 <jules2> no, supercompilation is the general optimization :)
08:44:49 <Ke> special optimizations are mostly good enough
08:45:08 <ski> yrlnry : hm, actually `Monoid m' was required for `Comonad (m ->)' (and `Monad (m,)'), not for `Monad (m ->)' (nor `Comond (m,)') .. but i take you see the point
08:46:00 <yrlnry> I think so.
08:46:16 <dom96> I really need help with the 'hint' library. I can't get it to work with ByteStrings. Does anybody know a solution to this problem or a different place i could ask about this problem?
08:46:28 <jules2> ski, I got the first example by taking the ordinary factorial function fact n = if n=0 then 1 else n*fact (n-1) and cps-transforming and the lambda-lifting it...
08:47:18 <ski> jules2 : interesting
08:47:22 <ski> zygoloid : sorry, got side-tracked. i'll try to look at your proof later
08:47:35 * ski -> _|_
08:52:57 <EvanR-work> ski: _|_ to you too!
08:54:09 <kmc> ⊥
08:54:19 <kmc> (_|_)
08:55:13 <zygoloid> ski: that's a really nice way of looking at it :)
08:55:43 <Peasley>    print(zipWith (:) [[5,2], [2,3]] [2, 1])  < why wont this compile? id except it to generate [2:[5,2], 1:[2,3]]
08:56:50 <Peasley> ah ok the order of parameters is important, obviously :p
08:57:00 <Peasley> errors are just so.. unclear
08:57:16 <gio123> ski
08:57:28 <fasta> Peasley, the errors are relatively good, you just don't know how to read, which is OK. 
08:57:29 <augur> hmm
08:57:39 <augur> anyone know anything about strong vs. weak computational equivalence?
08:57:42 <c_wraith> yeah, it takes a while to understand GHC's error messages.
08:58:02 <fasta> :t zipWith
08:58:03 <c_wraith> But they're usually pretty clear, once you understand how it's using the english language.
08:58:03 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
08:58:32 <c_wraith> and Peasley, yes, you need to reverse the order of the lists being passed to zipWith
08:58:34 <fasta> So, zipWith takes three arguments. Please provide a proof that you do this. 
08:58:40 <fasta> Hint: you don't.
08:59:04 <fasta> Ah, I am wrong on that point.
09:00:36 <kmc> > zipWith (:) [2,1] [[5,2], [2,3]]
09:00:38 <lambdabot>   [[2,5,2],[1,2,3]]
09:01:02 <fasta> I suggest you rewrite it first such that you give explicit types to whatever you get in the first argument of zipWith 
09:01:05 <kmc> GHC's error messages aren't too bad, but the "Suggested fix" is frequently hilariously wrong
09:01:39 <kmc> Peasley, if you like, you can put some of the unclear error messages on hpaste, and we'll try to explain how to read them
09:02:13 <Peasley> alrighty :-), ill do that if i get any more unclear message
09:02:19 <fasta> E.g. zipWith (\a b -> a:b) [[5,2], [2,3]] [[[2, 1]]]
09:02:32 <fasta> > zipWith (\a b -> a:b) [[5,2], [2,3]] [[[2, 1]]]
09:02:33 <lambdabot>   [[[5,2],[2,1]]]
09:02:53 <dom96> Could someone help me with the hint package?
09:03:07 <danportin> I think that (=>>) is the method I've been searching for my entire life.
09:04:29 <djahandarie> :t flip (=<<)
09:04:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m a -> (a -> m b) -> m b
09:04:36 <djahandarie> :t (=>>)
09:04:38 <lambdabot> Not in scope: `=>>'
09:04:50 <djahandarie> :t (>>=)
09:04:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:04:54 <djahandarie> Wait what is =>>?
09:05:06 <itsmonktastic> I was wondering that :s
09:05:11 <danportin> http://www.cas.mcmaster.ca/~carette/CAS706/F2006/presentations/comonads.pdf
09:05:16 <djahandarie> Ah, for comand
09:05:20 <djahandarie> comonad
09:05:33 <danportin> I was just pointed to them here
09:06:38 <djahandarie> I tend to use extend whenever using comonads
09:07:07 <djahandarie> That's also a nice document
09:07:24 <Cal3> hey 
09:07:26 <Cal3> Hey give me advice. I have to write little program - server. Which will listen on one port and save things which he get to database. And he will also send things to some other IP's. So I need something like shell account or VPS server. Anyway tell me, in which technology should I write it? I would preffer C# but i heard that there are problems with hosting. So what? Java?
09:07:58 <kmc> Cal3, this is a channel about the programming language Haskell
09:08:02 <kmc> so we will tell you to write it in Haskell
09:08:15 <djahandarie> If you want a non-bias opinion try ##programming ;)
09:08:16 <kmc> this is pretty good advice, if you are willing to spend years learning Haskell
09:08:17 <zygoloid> well, not necessarily ;) but your question isn't really on-topic for here
09:08:21 <kmc> it is not the quickest language to pick up
09:08:24 <kmc> but very rewarding
09:08:32 <djahandarie> Years?
09:08:38 <Cal3> hehe if there would exist channel about programming, I would ask there but I don't know any
09:08:47 <kmc> Cal3, if you have a VPS you can install anything you want, yes?
09:08:49 <djahandarie> Cal3, ##programming
09:08:52 <kmc> C# on Linux may not be so great though
09:09:05 <Cal3> djahandarie ops, I'll try
09:09:10 <Cal3> kmc o rly?
09:09:19 <kmc> Cal3, prototype it in Python or Ruby or such, then see if you need it faster/fancier
09:09:23 <bnery> hi guys... I started reading "real world haskell" and I have a question
09:09:32 <Phyx-> Cal3: mono is quite far along
09:09:33 <djahandarie> Years is a bit of exaggeration for Haskell lol
09:09:59 <ski> djahandarie : Teach Yourself Programming in Ten Years <http://norvig.com/21-days.html> by Peter Norvig
09:10:06 <Cal3> kmc, I am not really into scripting languages, prototyping in Java could be good too?
09:10:10 <kmc> Cal3, *shrug*
09:10:16 <kmc> probably fine
09:10:16 <bnery> why do "ghci> [1.0,1.4..2.2]" gives me "[1.0,1.4,1.7999999999999998,2.1999999999999997]" instead of "[1.0,1.4,1.8,2.2]" under ghci 6.8.2?
09:10:26 <kmc> bnery, because floating point numbers are inexact
09:10:29 <kmc> (in every language)
09:10:34 <kmc> djahandarie, i don't agree.  maybe my definition of really knowing the language is deeper than yours, or maybe i've spent less time per day on it
09:10:36 <luite> Cal3: there's no real difference between scripting languages and other programming languages
09:10:37 <dom96> Someone? please? Help me with the hint package ? Is no one experienced with it here ? Should i just contact the mantainer?
09:10:41 <Phyx-> Cal3: unless you're using obscure things from the CLR mono should be just fine though
09:10:52 <kmc> dom96, i've managed to get the example program to run
09:11:21 <dom96> kmc: i can get the example program to run too. I just can't get ByteStrings to work with hint
09:11:57 <zygoloid> dom96: what have you tried, and what errors did you get?
09:12:46 <ski> @where+ years "Teach Yourself Programming in Ten Years" at <http://norvig.com/21-days.html> by Peter Norvig
09:12:47 <dom96> http://gist.github.com/530589
09:12:47 <lambdabot> I will remember.
09:13:01 <bnery> kmc, but matlab won't have this inexactitude for such "big" steps
09:13:05 <djahandarie> bnery, you can add the type annotation :: [CReal] if you want precision, but note that it'll be slower
09:13:13 <kmc> bnery, then matlab is using more precision
09:13:20 <kmc> bnery, perhaps you want exact Rational numbers rather than floating-pointh
09:13:53 <kmc> djahandarie, it took a long time before i could explain precisely which values are forced when, or how Haskell would translate to a real machine, or how to use every GHC extension, etc.
09:14:00 <bnery> kmc, Rational, then :) I'll take a look at it
09:14:01 <kmc> there's really no limit to how long you can spend learning Haskell
09:14:04 <bnery> kmc, thanks a lot
09:14:06 <zygoloid> bnery: you may find this interesting: http://floating-point-gui.de/
09:14:17 <dom96> zygoloid: any ideas ? http://gist.github.com/530589
09:14:27 <djahandarie> kmc, sure, but I think we were talking in the context of making a server program database thing
09:14:34 <djahandarie> Not absolute mastery
09:14:50 <bnery> nice link zygoloid!
09:15:26 <kmc> djahandarie, depending on the performance requirements
09:15:41 <zygoloid> dom96: the error says this: Not in scope:\n  type constructor or class `Data.ByteString.Internal.ByteString'
09:15:50 <kmc> you might need to know Haskell well enough to understand recent papers about the IO manager, or do clever FFI, or unboxing etc.
09:15:53 <kmc> or reading Core
09:15:56 <zygoloid> dom96: that suggests you're missing an import of Data.ByteString
09:15:57 <kmc> i agree it's not *always* necessary
09:16:07 <kmc> *shrug*
09:16:08 <dom96> zygoloid: I know it does. But i'm not missing it.
09:17:05 <djahandarie> > [1.0,1.4..2.2] :: [CReal]
09:17:05 <zygoloid> dom96: i know nothing about hint, but i notice your imports in the second file don't match the setImportsQ in the first
09:17:06 <lambdabot>   [1.0,1.4,1.8,2.2]
09:17:12 <djahandarie> > [1.0,1.4..2.2] :: [Double]
09:17:13 <lambdabot>   [1.0,1.4,1.7999999999999998,2.1999999999999997]
09:17:40 <zygoloid> (the first has a qualified import for Data.Map and an unqualified import for Data.ByteString, and the second has a qualified import for ByteString and an unqualified one for Map)
09:18:06 <djahandarie> > round 3.5 == round 4.5 -- though this has nothing to do with floating point numbers
09:18:08 <lambdabot>   True
09:18:19 <dom96> zygoloid: even if i make them match, the same thing happens.
09:18:56 <zygoloid> dom96: do you get the same problem if you add a direct import of Data.ByteString.Internal?
09:20:38 <mm_freak> i've asked this once, but maybe somebody has an answer by now:  is there any generalization of exception handling functions to other monads?
09:20:43 <dom96> zygoloid: now it's giving me "Couldn't match expected type `Data.ByteString.Internal.ByteString'\n       against inferred type `[GHC.Types.Char]'"
09:21:05 <mm_freak> i'm looking for something like this:  finally :: BaseM m IO => m a -> m b -> m a
09:21:23 <mm_freak> or in mtl terms:  finally :: MonadIO m => m a -> m b -> m a
09:21:34 <kmc> mm_freak, http://hackage.haskell.org/package/MonadCatchIO-mtl ?
09:21:41 <kmc> finally :: MonadCatchIO m => m a -> m b -> m a
09:21:47 <dom96> zygoloid: i fixed that. Now it works!
09:21:47 <mm_freak> kmc: someone told me that package was broken
09:21:51 <dom96> Thanks a lot.
09:21:52 <kmc> yeah me too
09:21:53 <kmc> but i don't know how
09:21:57 <kmc> maybe it can be fixed?
09:22:08 <mm_freak> to fix it i'd need to know in what way it's broken
09:22:29 <zygoloid> dom96: i have no idea why that's fixed it, but hooray i guess! :)
09:23:04 <mm_freak> kmc: is there any way to generalize without having to use things like GHC primitives?
09:23:09 <dom96> zygoloid: I just had to add one B.pack and now it works. 
09:23:41 <zygoloid> hmm, that's a weird error message to get for that problem :-/
09:24:09 <zygoloid> might be worth filing a bug for the poor diagnostic if you can work out where it's coming from
09:24:15 <carter> hrmm, whats the syntax error in >    instance  NFData (Trie a) if you have undecidable instances turned on?
09:24:56 <zygoloid> carter: what is Trie, and where are you writing this? does it work if undecidable instances is turned off?
09:25:11 <carter> Data.Trie
09:25:12 <dom96> zygoloid: perhaps i should send an email to the maintainer of hint?
09:25:27 <zygoloid> dom96: sure, why not :)
09:25:36 <kmc> mm_freak, well, look at how MonadCatchIO is imlemented
09:25:45 <dom96> zygoloid: ok, thanks a lot again :)
09:25:50 <zygoloid> no problem
09:29:40 <mm_freak> kmc: indeed, it doesn't use hacks…  thanks a lot
09:30:21 <carter> ok, it was an indentation problem
09:52:34 <seydar> hi guys
09:52:51 <lispy> :t liftM2
09:52:52 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:52:57 <seydar> what's the equivalent to doing "string".unpack("CCaaNNblahblah")?
09:52:59 <kmc> hi seydar 
09:53:03 <Peasley> how can I use multiple print's in ghci ? Im trying to print out each arrays entry in seperate line
09:53:19 <Peasley> i've almost finished :D
09:53:34 <kmc> seydar, can you describe what problem you want to solve, rather than giving us a solution in some unknown language we may or may not know?
09:53:47 <c_wraith> Peasley, look at mapM
09:53:49 <c_wraith> :t mapM
09:53:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:53:52 <lispy> :t liftA2
09:53:53 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
09:53:56 <kmc> Peasley, arrays? or lists?
09:54:20 <lispy> ?type (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
09:54:22 <lambdabot> parse error on input `->'
09:54:22 <Peasley> kmc woops yeah lists
09:54:24 <c_wraith> or mapM_
09:54:27 <c_wraith> :t mapM_
09:54:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
09:54:30 <lispy> ?hoogle (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
09:54:30 <seydar> kmc: I have 6 bytes in a file
09:54:30 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
09:54:31 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
09:54:31 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
09:54:40 <seydar> I would like to read them in as an unsigned integer
09:54:55 <kmc> seydar, did you see Data.Binary?
09:54:57 <seydar> kmc: or for simplicity, pretend it's 4 bytes that I want as an unsigned int
09:55:02 <seydar> kmc, no thank you
09:56:01 <lispy> ?undo \f x y -> do { x' <- x; y' <- y; f x' y' }
09:56:01 <lambdabot> \ f x y -> x >>= \ x' -> y >>= \ y' -> f x' y'
09:56:11 <lispy> ?pl \ f x y -> x >>= \ x' -> y >>= \ y' -> f x' y'
09:56:11 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
09:56:19 <lispy> so nothing standard with that type?
09:56:30 <zygoloid> @type liftM2
09:56:31 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:56:47 <zygoloid> @type (join.).liftM2
09:56:48 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
09:56:48 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
09:56:48 <lambdabot>     In the second argument of `(.)', namely `liftM2'
09:56:53 <zygoloid> ;(
09:57:07 <c_wraith> :t (>=>)
09:57:08 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:57:08 <seydar> kmc: what's Word8? 8 bits or 8 bytes?
09:57:14 <zygoloid> @type ((join.).).)liftM2
09:57:15 <lambdabot> parse error on input `)'
09:57:18 <zygoloid> @type ((join.).).liftM2
09:57:19 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
09:57:22 <zygoloid> \o/
09:57:38 <zygoloid> lispy: ^^ that type?
09:57:39 <djahandarie> zygoloid > @pl
09:57:58 <aristid> @src zipWithM
09:57:58 <lambdabot> zipWithM f xs ys = sequence (zipWith f xs ys)
09:58:04 <c_wraith> :t (>=>) . return
09:58:05 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> a -> m c
09:59:31 <kmc> seydar, 8 bits
09:59:40 <kmc> Word8, Word16, Word32
09:59:42 <kmc> Word64
09:59:44 <kmc> each unsigned
09:59:48 <kmc> corresponding Int8, Int16, etc. for signed
09:59:53 <kmc> Int and Word for machine size
10:00:00 <kmc> (in GHC at least)
10:00:14 <kmc> (Int is only guaranteed to have a range of [-2^29, 2^29-1] iirc)
10:00:32 <seydar> iiiiiiiiiiiiinteresting
10:00:32 <seydar> thank you
10:00:42 <kmc> (but in GHC it is a whole machine word)
10:02:35 <aristid> :t ((.).(.).(.)) join liftM2
10:02:37 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
10:02:43 <seydar> it says it's unstable but i'm going to pretend he means that it's "let out of the stable and is free to ride"
10:03:02 <zygoloid> @type fmap (fmap fmap fmap) fmap join liftM2
10:03:04 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
10:03:43 <djahandarie> @type (fmap.fmap.fmap) join liftM2
10:03:44 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
10:05:41 <aristid> :t let result = (.) in (result.result.result) join liftM2
10:05:42 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
10:05:55 <djahandarie> :P
10:05:56 <zygoloid> @type fmap (fmap fmap fmap fmap) fmap fmap fmap join liftM2
10:05:58 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
10:06:15 <aristid> zygoloid: this is a fine fmap orgy
10:09:01 * zygoloid should dig out his automatic fmapper
10:10:03 <orbitz> any thought son how happstack comapres to snap?
10:10:08 <djahandarie> @type fmap (fmap fmap fmap fmap) fmap fmap fmap fmap fmap join liftM2
10:10:10 <lambdabot> forall (f :: * -> *) a2 r (m :: * -> *). (Functor f, Monad m) => (a2 -> a2 -> r) -> f (m a2) -> f (m r)
10:10:14 <djahandarie> Ah crap
10:10:47 <djahandarie> @type fmap (fmap fmap fmap fmap fmap) fmap fmap fmap fmap fmap join liftM2
10:10:49 <lambdabot> forall a (f :: * -> *) a2 r. (Functor f) => (a2 -> a2 -> r) -> (a -> a2) -> f a -> f r
10:10:56 <djahandarie> Alright I give up
10:13:56 <kmc> cool
10:14:03 <kmc> it is possible to load machine code into a ByteString, then jump to that code
10:14:39 <zygoloid> kmc: and what happens if you get a GC while you're running that code?
10:14:52 <kmc> i do it as a normal FFI call
10:15:20 <kmc> well, a foreign import "dynamic"
10:15:27 <zygoloid> hah, nice tric
10:15:32 <zygoloid> *trick
10:15:49 <kmc> i would guess that being inside withForeignPointer with the BS's foreign ptr would prevent the GC from moving it
10:15:51 <kmc> i am not certain
10:15:56 <kmc> it's a good question anyway
10:16:06 <zygoloid> the safe FFI call is enough though
10:16:21 <kmc> why's that?
10:16:32 <kmc> oh, because my capability won't return to the GC-able state until i finish?
10:16:48 <zygoloid> yeah, i think so
10:17:01 <zygoloid> though it depends if your generated code runs any haskell code
10:17:14 <Peasley> oh boy this is killing me
10:17:35 <Peasley> c_wraith, saw your response to me, mapM
10:17:52 <c_wraith> Peasley, mapM_ is better for the case of printing
10:17:52 <Peasley> however how could I combine the effect of putStrLn while each element of list is list
10:18:12 <Ke> > Left 1 >> return 0
10:18:14 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:18:14 <lambdabot>    `GHC.Num.Num t'
10:18:15 <lambdabot>      ari...
10:18:22 <zygoloid> kmc: i think in essence, if it is safe to pass the pointer to C code, it's safe to pass it in $rip ;-)
10:18:25 <c_wraith> :t mapM_ (mapM_ putStrLn)
10:18:26 <lambdabot> [[String]] -> IO ()
10:19:14 <kmc> hehe
10:19:29 <kmc> yeah, it's a weird hack, but made of relatively conventional components
10:19:48 <kmc> ForeignPtr and foreign import "dynamic"
10:19:56 <zygoloid> do you know how augustss's llvm bindings do it?
10:20:01 <kmc> no
10:20:05 <Peasley> mapM putStrLn ([show k | k<-blabla])
10:20:07 <Peasley> ^. ~
10:20:18 <zygoloid> me neither, but it might be interesting to look at :)
10:20:39 <aristid> :t flip (forM_ . join) putStrLn
10:20:40 <lambdabot> [[String]] -> IO ()
10:21:23 <c_wraith> :t mapM_ putStrLn . concat
10:21:24 <lambdabot> [[String]] -> IO ()
10:22:23 <Peasley> http://haskell.pastebin.com/0JZTQV3g
10:23:04 <Peasley> if anybody has time i sure could listen what can be done better and how
10:23:42 <kmc> hmm, you have all these guards commented out
10:23:52 <Peasley> yeah just noticed that
10:23:59 <tensorpudding> also those guards are ill-typed
10:24:04 <kmc> Peasley, i wouldn't indent this much
10:24:18 <Peasley> it looked nice in scite although but looks horrible in pastebin :P
10:24:54 <JoeyA> Is there a way to get ghci's tab completion to use less instead of more as the pager?
10:25:00 <tensorpudding> you use list comprehensions for a lot of things which don't need them
10:25:25 <Peasley> yeah thought so
10:25:28 <kmc> Peasley, «flat r = [sum g | g <- r]» can be written as «flat = map sum»
10:25:44 <kmc> similarly «[r1 * x | x <- r2]» as «map (r1*) r2»
10:25:45 <Peasley> every thing i needed i was like.. mmm i could do it using list comprehension :P
10:25:51 <sproingie> more programming languages should use guillemets
10:25:54 <kmc> it's nice to avoid naming tiny local variables
10:25:56 <kmc> sproingie, noooo
10:26:00 <kmc> that would ruin my whole thing
10:26:03 <Peasley> kmc is it me or your text shows really weirdly?
10:26:09 <Peasley>  Peasley, «flat r = [sum g | g <- r]» can be written as «flat = map sum»
10:26:15 <kmc> Peasley, i'm using these characters as quotations:  « »
10:26:16 <tensorpudding> Guillemets would make sense in a Unicode-aware language.
10:26:21 <Peasley> oh ok :p
10:26:21 <kmc> they should appear like squished small << and >>
10:26:38 <kmc> i use them because they're not part of the syntax of Haskell, so there's no ambiguity
10:26:40 <tensorpudding> Except that people in the US don't use them.
10:26:54 <kmc> but if your IRC client is not set up for UTF-8, they may display as some garbage
10:27:04 <kmc> (i used to send Latin-1, i look back with horror on those days)
10:27:30 <tensorpudding> In fact, you could probably find a ton of programmers that don't know what guillemets are
10:27:39 <sproingie> they'd be nice in perl.  qq«foo bar»
10:27:43 <kmc> you can find a ton of programmers that don't know what Unicode is
10:27:46 <kmc> heh
10:27:46 <sproingie> i'm sure perl6 knows about 'em
10:27:50 <kmc> sproingie, might be allowed already
10:28:12 <sproingie> kmc: unfortunately nope.  qq can take any character, but it doesn't recognize » as a closing brace of «
10:28:16 <kmc> oh
10:28:19 <kmc> so sad
10:28:35 <tensorpudding> Unicode would make things pretty hard to parse
10:28:44 <kmc> how so?
10:28:47 <sproingie> not at all
10:28:53 <kmc> Haskell, Java, lots of other languages allow it
10:28:57 <tensorpudding> people would be like, "we'll have a ton of new syntax and special symbols"
10:29:02 <sproingie> the lexer just consumes utf8 instead of ascii
10:29:05 <younder> unicode in utf16 is no more difficult to parse than ASCII
10:29:06 <kmc> sounds like Agda
10:29:18 <sproingie> might be harder for people to parse visually in some places.  and a lot easier in others.
10:29:26 <zygoloid> kmc: in the llvm package, there's some c code which takes a function pointer and invokes it, called via FFI
10:29:29 <kmc> or the lexer consumes characters, and you run it through a UTF-8 decoder first (a very standard software component)
10:29:32 <kmc> zygoloid, aha
10:29:39 <tensorpudding> It'd be harder to deal with if you actually run into people with programs that don't handle Unicode properly
10:29:56 <tensorpudding> or which is transfered through some machine which bit-mangled the unicode
10:30:09 <younder> just focus on the first byte for starters 0-128 ASCII. 129-255 ISO-LATIN-1
10:30:13 <tensorpudding> I had that happen recently, and had to retag a bunch of European and Japanese music.
10:30:19 <sproingie> you'd bake it into the platform as a requirement, and you'd put some kind of "coding cookie" in the source
10:30:32 <kmc> Haskell mandates UTF-8 source, iirc
10:30:34 <Wolfspaw> I have a data (for "Days") deriving enum. So i can make [Monday .. ] and it will give all days till Sunday, but i want it to be "circular". Because when i do succ Sunday i expect Monday, but i get an exception because Sunday is the last tag in enum @_@. Any class i can derive to say its "Circular" ?
10:30:37 <sproingie> perl just assumes utf8 unless you tell it otherwise, python demands a coding cookie
10:30:55 <EvanCarroll> hahhahha, I just learned about bash's popd/pushd from the Windows Powershell docs
10:31:01 <tensorpudding> id3 tags are some of the worst designed things in the world
10:31:02 <younder> Then you need the EURO symbol of 8615
10:31:32 <kmc> Wolfspaw, you can write your own Enum instance rather than deriving it
10:31:44 <tensorpudding> Oh, the problem of keyboards that lack the symbols to input the language will severely curtail people using it.
10:31:52 <kmc> Wolfspaw, but i think the simpler solution is to just define somewhere "days = cycle [Monday ..]"
10:32:00 <younder> Unicode comes with it's own database
10:32:19 <tensorpudding> You need to have a compose key or character map or unicode table handy to input a gillaumet on a US keyboard
10:32:20 <sproingie> one hopes the base language and popular libraries use an ascii subset
10:32:37 <aristid> :t cycle [minBound..]
10:32:38 <lambdabot> forall a. (Bounded a, Enum a) => [a]
10:32:40 <sproingie> guillemets with a compose key aren't hard.  it's even on putty's crippled compose key
10:32:48 <kmc> a custom Enum instance won't really work, because you need to define fromEnum and toEnum, and they take Ints, and the number of Ints is not 0 mod 7
10:32:50 <tensorpudding> Most keyboards lack a compose key.
10:32:59 <kmc> most users have not bound a compose key
10:33:12 <kmc> i use the Fn key on my thinkpad; it's useless for other user-space stuff, but perfect for this
10:33:23 <tensorpudding> You can bind a compose key in Windows without hacking the registry?
10:33:28 <younder> My Formula uses the 4'th codepage of UTF16. Mostly for Mathsymbols. (Also greek symbols)
10:33:41 <sproingie> there are hacks to do a compose key in windows.  they pretty much universally suck
10:33:41 <Wolfspaw> kmc: but with that infinite list, how can i do a "succ Sunday" ?
10:33:56 <younder> remeber UNICODE is really 18 bit.
10:34:07 <younder> remember
10:34:09 <tensorpudding> Also I was almost sure that Fn was not able to be bound.
10:34:20 <sproingie> if it has a scancode it can be bound
10:34:34 <tensorpudding> I was thinking it did not send a scan code, was the reason.
10:34:58 <sproingie> naw i suspect it's implemented in the driver
10:35:03 <younder> tensorpudding, there is. shift codes should be changed to characters
10:35:14 <aristid> tensorpudding: xev reacts to the Fn key
10:35:25 <tensorpudding> It depends on the machine.
10:35:32 <younder> a =/= A
10:35:34 <sproingie> old laptops might have done it in firmware
10:35:35 <tensorpudding> Many machines do not send Fn keypresses with scancodes.
10:35:42 <sproingie> these days i suspect it's all software
10:35:49 <Wolfspaw> kmc: i would have to do something like "dropWhile ( \x -> dropWhile (/= x ) )" and then get the next element @_@. Ill guess i'll implement my own succ, it's the most simple solution for now xD
10:36:05 <younder> tensorpudding, in unix there are standard return sequences
10:36:32 * mjrosenb had a compose key for a while, but i never actually used it, so when X decided it did not like my .xmodmap.rc, I got rid of it
10:36:36 <younder> including those for nCurses softkey's
10:36:51 <aristid> olé <- compose key ftw
10:37:23 <tensorpudding> My Fn key does not send a scancode by itself
10:37:39 <younder> Unless you are composing your own operating system you are nowhere as wild and free as you seem to think you are.
10:37:39 <tensorpudding> so I can't turn it into a compose key
10:38:27 <kmc> Wolfspaw, oh, you should probably implement your own succ
10:38:56 <kmc> tensorpudding, mine sends a scancode iff you release it without pressing anything else
10:39:21 <kmc> Wolfspaw, you can make a 'cycleSucc' that works on any instance of Enum and Bounded
10:40:20 <tensorpudding> It's okay, I rebound my left control as compose
10:40:55 <Wolfspaw> kmc: ok, it was straightforward i did and it worked @_@. My code solutions rarely seems optimum. They work, but they're not sucint. Then i see how other Haskellers would have done it, and its 10 x less lines and much more elegant. I guess its my fate as a newbie for now xD
10:41:19 <kmc> Wolfspaw, it's a gradual process to get there
10:41:30 <kmc> if you hang out here you will see a lot of clever code, and you'll absorb how it works
10:42:00 <mjrosenb> you'll also see alot of really clever code that should *never* be used
10:42:08 <kmc> hehe
10:42:18 <Wolfspaw> mjrosenb: hehehehe xD
10:42:29 <kmc> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
10:42:30 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
10:42:47 <PeakerWork> > iterate (2*) 1
10:42:48 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
10:42:51 <mjrosenb> yeah, that is more or less the one i was thinking of
10:42:53 <kmc> PeakerWork, too easy
10:42:55 <Wolfspaw> lol
10:42:58 <mjrosenb> kmc: i saw it with fix show
10:43:04 <kmc> hehe
10:43:05 <kmc> > fix error
10:43:07 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
10:43:31 <kmc> > nubBy(((>1) .) . gcd) [2..]
10:43:33 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:43:49 <Wolfspaw> woa O_O
10:43:58 <kmc> :t nubBy
10:44:00 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
10:44:03 <kmc> :t (((>1) .) . gcd)
10:44:05 <lambdabot> forall a. (Integral a) => a -> a -> Bool
10:44:10 <tensorpudding> There are tons of prime number one-liners
10:44:11 <zygoloid> > nubBy (((0==).).mod) [2..]
10:44:13 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:44:25 <tensorpudding> but they're terribly inefficient, of course
10:44:36 <zygoloid> the mod one is only quadratic
10:44:58 <kmc> it's a strange use of nubBy
10:45:02 <kmc> "two numbers are the same if their gcd is greater than one"
10:45:23 <zygoloid> the result isn't even defined
10:45:30 <PeakerWork> not "the same".. "prune by .."
10:45:42 <tensorpudding> mm prunes
10:45:52 <zygoloid> hmm, no, i'm thinking of the groupBy one :)
10:45:52 <aristid> > let (.:) = (.).(.) in nubBy ((==0) .: mod) [2..]
10:45:53 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:45:54 <kmc> well nubBy gives you the first element in an equivalence class
10:45:54 <JoeyA> I'm trying to follow the suggestion at the bottom of http://hackage.haskell.org/trac/ghc/ticket/2606 to fix ctrl+arrow
10:46:01 <kmc> i think it should want its arg to be an equivalence relation
10:46:03 <mjrosenb> >map length . groupBy (const (/='"')) . fix $ show
10:46:15 <Wolfspaw> kmc: shouldn't be one number that isnt a prime in the list then? In the primes generation by Nub example @.@
10:46:16 * mjrosenb fail
10:46:22 <Wolfspaw> kmc:  *there be
10:46:25 <kmc> Wolfspaw, why?
10:46:35 <mjrosenb> > map length . groupBy (const (/='"')) . fix $ show
10:46:40 <lambdabot>   mueval-core: Time limit exceeded
10:46:48 <kmc> > fix show
10:46:50 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
10:47:01 <Wolfspaw> kmc: since for nubBy numbers that have more than one divisor are equal, then it should "unify" them in the first more than one divisor number no?
10:47:02 <mjrosenb> > take 10 . map length . groupBy (const (/='"')) . fix $ show
10:47:03 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
10:47:04 <Wolfspaw> @_@
10:47:32 <kmc> Wolfspaw, no, it would unify each prime with its multiples
10:47:32 <Wolfspaw> kmc: and then the rest would be prime, that's how i though it would be @_@
10:47:50 <Wolfspaw> kmc: hmmmmm, very clever indeed xD
10:47:53 <kmc> but each prime is smaller than its multiples, and nubBy gives you the first element of every equivalence class
10:48:56 <kmc> hmm is (((>1).) . gcd) a transitive relation?
10:49:06 <kmc> it's reflexive and symmetric, assuming you ignore 1
10:49:19 <kmc> and, err, 0
10:49:21 <mjrosenb> i think i only recently properly used haskell's laziness
10:49:44 <Wolfspaw> got to Go, see ya haskellers o/
10:49:45 <kmc> oh heh, wikipedia has this example and says it's not transitive
10:49:47 <roconnor> Cale: I went to an invited talk by Zeilberger last month
10:50:27 <kmc> > let f a b = gcd a b > 1 in nubBy f [2..]
10:50:29 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:52:23 <luite> has anyone here tried representing generating functions in haskell? I currently have a simple multivariate polynomial, but it would be nice to be able to represent arbitrary power series, and go back to closed form if possible
10:53:04 <mjrosenb> luite: i suspect the "go back to closed form" is *quite* difficult
10:53:41 <arbitrarylogic> someone definitely he
10:53:43 <arbitrarylogic> *has
10:53:49 <luite> mjrosenb: yes I can imagine, but it may be easy to handle a few special cases, and add code to handle more difficult ones as needed
10:54:22 <arbitrarylogic> luite: http://homepage.mac.com/sigfpe/Computing/haskell.html
10:56:17 <luite> arbitrarylogic: thanks, that's univariate though, I need multiple variables
10:56:45 <arbitrarylogic> luite: not sure then. I was actually trying something like that earlier
10:57:48 <arbitrarylogic> luite: that library uses lazy lists to represent univariate power series
10:58:07 <arbitrarylogic> luite: to do multivariate, you would probably need a different structure
11:00:12 <luite> yes that's the most straightforward approach I guess. it's of course possible to linearly order the terms of a multivariate series, but I'm not sure how well that would scale
11:00:58 <luite> perhaps better to use a sparse list
11:01:39 <luite> but that representation throws out any chance of going back to closed form
11:18:54 <laurus> Does anyone use Haskell to do statistics work?
11:20:00 <laurus> In general that is
11:20:33 <kmc> the "statistics" library was written by bos and is used in criterion iirc
11:20:37 <kmc> i don't know what else uses it
11:20:56 <laurus> kmc, the reason is that I've been considering using Python to do statistics work rather than R
11:21:01 <kmc> it would be cool to have an interface to R
11:21:05 <laurus> But I've always had a curiousity about functional languages
11:21:07 <kmc> laurus, did you look at rpy?
11:21:18 <kmc> laurus, well, Python is a functional language by my (admittedly liberal) definition
11:21:28 <kmc> you can use most FP techniques in Python without extraordinary pain
11:21:34 <laurus> That's true
11:21:41 <laurus> I wanted to get into Lisp, but there were too many barriers
11:21:46 <kmc> mm
11:21:49 <kmc> what about Clojure?
11:21:53 <mm_freak> recently i've found the 'monte-carlo' package to be useful for some statistical computations
11:22:14 <laurus> kmc, it's just too weird for me... I'm not as into Lisp as I thought probably, Haskell seems better
11:22:14 <djahandarie> kmc, not in normal dialects of Python
11:22:23 <kmc> djahandarie, oh, because of missing TCO?
11:22:25 <djahandarie> Due to lack of tall-call optimization
11:22:26 <djahandarie> Yeah
11:22:26 <kmc> i keep forgetting about that
11:22:28 <kmc> right
11:22:39 <kmc> sad
11:22:43 <pumpkin> it's unpythonic
11:22:45 <pumpkin> not sad
11:22:56 <dankna> so
11:22:57 <dankna> http://codepad.org/7954r2UP
11:23:02 <laurus> And for example Python has matplotlib for making graphs
11:23:08 <djahandarie> Yeah, and Guido is really opposed to it as well, so not a very big chance of it getting in
11:23:11 <laurus> So I'm wondering if I could accomplish the same things in Haskell
11:23:14 <mm_freak> kmc: the python implementation doesn't do TCO, which limits FP in python a bit
11:23:15 <dankna> GADTs plus MPTCs equals confusion, for me
11:23:35 <kmc> i do still find FP techniques quite useful in Python, but i'll agree that the lack of TCO is a major obstacle
11:23:43 <dankna> actually I guess the MPTCs are orthogonal because I have problems even with my Eq and Show instances.  GADTs plus type-classes.
11:24:20 <kmc> dankna, can you boil that code down a bit?
11:24:28 <laurus> Is there a graphing library in Haskell?
11:24:30 <dankna> possibly, I'll work on it
11:24:53 <mm_freak> kmc: i've written a church lists implementation in python
11:25:05 <mm_freak> but it's quite useless, because of missing TCO
11:25:39 <mm_freak> you also notice missing TCO when trying to implement certain monads in python
11:25:42 <mm_freak> like Cont
11:25:58 <laurus> mm_freak, how do people generate plots in Haskell generally?
11:25:59 <mjrosenb> mm_freak: TCO?
11:26:01 <dolio> That's why you compile with berp.
11:26:03 <monochrom> perhaps trampoline manually
11:26:09 <mm_freak> mjrosenb: tail call optimization
11:26:10 <djahandarie> laurus, there is, in Graphics.Rendering.Chart
11:26:11 <pumpkin> stackless python sort of does that
11:26:14 <kmc> use exceptions for tail calls :D
11:26:16 <pumpkin> it's not very pretty
11:26:20 <laurus> djahandarie, oh, cool
11:26:29 <kmc> istr a TCO decorator
11:26:31 <kmc> don't recall how it works
11:26:33 <laurus> I'm just trying to find a platform to standardize on
11:26:39 <djahandarie> kmc, there is, but it's ugly
11:26:40 <mjrosenb> mm_freak: ahh.
11:26:45 <laurus> And the Yi editor excites me as a future replacement for Emacs as well
11:26:47 <djahandarie> laurus, http://hackage.haskell.org/package/Chart
11:26:57 <djahandarie> laurus, it seems to be sort of slow on the development front
11:27:09 <mjrosenb> laurus: i've never been able to use yi :(
11:27:19 <laurus> Oh really? :(
11:28:02 <djahandarie> "it" being Yi
11:28:18 <laurus> Yeah...
11:28:21 <laurus> That's too bad, it's such a great idea
11:28:44 <mm_freak> some people seem to like leksah
11:28:45 <laurus> I guess what I'm asking is, is there any gain to me to learn Haskell if I already know Python?
11:28:51 <mm_freak> which is an IDE for haskell
11:29:00 <mm_freak> i've not tried it myself, because emacs works vor me
11:29:03 <dankna> http://codepad.org/tRIHRWNQ okay, shorter now.  I could probably make it shorter still but then it wouldn't exemplify all the errors I'm getting.
11:29:07 <kmc> laurus, yes, quite a lot of gain
11:29:09 <djahandarie> laurus, definitely
11:29:19 <pumpkin> laurus: enormous
11:29:20 <kmc> laurus, mostly it will expand how you think about programming
11:29:22 <kmc> and expose you to new concepts
11:29:27 <kmc> (unless you have a very atypical background)
11:29:38 <pumpkin> all this "functional style" in python is BS people make up to justify not learning real functional languages :P
11:29:49 <kmc> laurus, i also think Haskell is a practical language for many tasks, but it takes quite a lot of study before you can get to that point
11:29:50 * pumpkin whistles innocently
11:30:09 <mm_freak> pumpkin: or to understand how well haskell concepts map to python =)
11:30:18 <benmachine> guido has weird ideas about FP anyway
11:30:20 <laurus> My ultimate goal would be to have one language I use everything for... right now there are two, Emacs Lisp and Python... but it would be great to get that down to just one :P
11:30:20 <mm_freak> (just to find out they don't really map well)
11:30:34 <kmc> laurus, Haskell is a great language to learn, even if you never plan to use it for a 'real' project
11:30:49 <kmc> likewise Scheme (the simplest and most beautiful of the Lisps, imo)
11:31:00 <monochrom> if you don't have TCO, it's meaningless to practice the functional style.
11:31:03 <mm_freak> paul graham says:  if lisp is good and makes you more productive, you should use it
11:31:05 <dankna> Haskell has a bunch of ideas in it that I've never seen in /any/ other language, like immutability and very strong typing.
11:31:07 <mm_freak> same applies to haskell
11:31:10 <dankna> Learning it will stretch your mind.
11:31:18 <laurus> kmc the thing is that I can't use Scheme for anything because of the fragmentation of implementations, and lack of libraries
11:31:26 <kmc> yes
11:31:28 <kmc> but it's still worth learning how it works
11:31:28 <jules2> immutability -> clojure
11:31:40 <djahandarie> dankna, there certainly are those things in other languages... just none of the others are as popular as Haskell that have all of the things
11:31:44 <dankna> okay, so it exists elsewhere, but I haven't seen clojure, so :)
11:31:46 <pumpkin> still no proper tail calls
11:31:46 <kmc> Haskell is probably better on the implementation-and-libraries front
11:31:58 <djahandarie> Haskell is pretty damn good on the library front
11:31:58 <mm_freak> also…  learning haskell just for the sake of extending your mind will rather demotivate you, because you can't really apply haskell concepts to other languages nicely
11:31:59 <jules2> you should check it out, it's very interesting :)
11:32:04 <dankna> Haskell is also more practical than Lisp in the sense that more libraries have already been written, imo
11:32:05 <djahandarie> We can interface with a segway!
11:32:10 <mm_freak> i remember implementing state monads in C#
11:32:10 <laurus> mm_freak, haha I see
11:32:10 <kmc> dankna, clojure, like Haskell, encourages immutable data but provides mutation when necessary
11:32:12 <dankna> I was big into the Common Lisp scene before I got into Haskell
11:32:13 <mm_freak> it was a PITA
11:32:20 <dankna> kmc: hm - true enough I guess
11:32:21 <mm_freak> so, if you learn haskell, you should use it, too =)
11:32:23 <medfly> mm_freak, I am a noob enough that things were useful.
11:32:25 <pumpkin> mm_freak: I found monads in java recently
11:32:30 <laurus> :)
11:32:41 <djahandarie> pumpkin, that doesn't sound like fun
11:32:42 <mm_freak> pumpkin: you probably found specific monads
11:32:44 <kmc> there are very few languages which provide no mutation of any kind; most of them would not be classified as general-purpose languages
11:32:45 <medfly> mm_freak, I often write map, filter, etc. but it's damn hard to try to do anything as useful as Haskell's
11:32:50 <mm_freak> java can't express 'Monad' =)
11:33:15 <kmc> yeah, Java has nothing like constructor classes afaik
11:33:28 <mm_freak> medfly: i usually write foldr and foldl and derive all other functions from that =)
11:33:49 <mm_freak> but i don't miss the list functions as much as i miss monads and monad transformers in other languages
11:33:53 <mm_freak> and i miss the type system
11:34:07 <medfly> oh yes I miss that too :( I've considered writing something to make PHP more tolerable.
11:34:14 <mm_freak> concise syntax for almost anything
11:34:18 <dankna> so as far as I can tell in my code snippet.... taking just the first of the errors for now.  it's saying that I can't define (==) (TemplateList a) (TemplateList b) = (==) a b, because it doesn't know that the lists are of a type to which Eq applies
11:34:28 <medfly> more strong typing :)
11:34:29 <mm_freak> medfly: until recently PHP wouldn't even support closures
11:34:48 <dankna> now of course, /I/ know that because to match that pattern they must both be of type TemplateValue [a]
11:34:54 <dankna> but the compiler doesn't
11:35:00 <dankna> so I see its complaint but not what I can do about it
11:35:11 <djahandarie> mm_freak, and functions still aren't first-class
11:35:15 <djahandarie> Only kind of
11:35:34 <Saizan> dankna: how is TemplateList defined?
11:35:41 <mm_freak> yes…  but at least now you can implement stuff like withFile
11:35:52 <dankna> Saizan: it's a GADT.  TemplateList :: [a] -> TemplateValue [a].
11:36:10 <djahandarie> I've had seriously awful times in channels like ##php
11:36:27 <mauke> allow me to chortle
11:36:44 <djahandarie> There is never any room for higher-level discussion
11:36:47 <dankna> (not quite what you showed me last night which used cons cells explicitly, Saizan, but afaict a legitimate variant)
11:36:51 <djahandarie> It's constantly flooded with noob questions
11:37:08 <Saizan> dankna: "instance Eq a => TemplateValue a where TemplateList a == TemplateList b = a == b" should work.
11:37:10 <djahandarie> I don't exactly idle there though so that may not always be true though
11:37:21 <groberts> Is there a bug with the latest development version of happstack not building to anyones knowledge?
11:37:29 <mm_freak> djahandarie: that's because most PHP users don't want to think…  they just want to get their job done
11:37:34 <dankna> hm
11:37:35 <Saizan> dankna: actually, instance Eq a => Eq (TemplateValue a) where TemplateList a == TemplateList b = a == b
11:38:03 <djahandarie> mm_freak, yeah. Hopefully Haskell is never plauged with this problem
11:38:03 <dankna> but that's what I did, just taking out the forall... well, trying it
11:39:33 <fergie> I'm trying to parse some JSON. One element is returned as a list when is contains more than 1 element but otherwise just the element is returned. Is there an "if not list then make singleton list" function?
11:39:44 <dankna> very similar error to what I was already getting.  Could not deduce (Eq a1) from the context (a ~ [a2]) arising from a use of == ...
11:40:04 <laurus> Geez, cabal install yi sure takes a long time, hehe
11:40:21 <djahandarie> Yes, and you'll be lucky if you don't get nasty dependency issues
11:40:31 <djahandarie> They might have since fixed that though
11:40:36 <djahandarie> I know a couple people were having trouble
11:40:51 <JoeyA> Is there a way to have ghci automatically load modules when called?
11:40:56 <JoeyA> (e.g. Control.Applicative)
11:42:28 <djahandarie> Not afaik
11:42:28 <fergie> I can't even think what the type of the function should be
11:42:43 <groberts> fergie: seems like that would be easy to make
11:43:12 <mm_freak> fergie: depends on how you parse it…  there is a ready-made JSON parser on hackage, AFAIK
11:43:34 <mm_freak> otherwise just write a corresponding Parser, which first tries to parse an array
11:43:44 <fergie> mm_freak: I'm using valFromObj from Text.JSON
11:43:52 <Saizan> dankna: i see, i would have never expected that
11:44:00 <laurus> Why is it taking so long if I already "sudo make install"ed the Haskell Platform?
11:44:02 <dankna> Saizan: me either :)
11:44:18 <dankna> what is does that notation in the context, (a ~ [a2]), even mean?
11:44:42 <Saizan> dankna: "instance Eq a => Eq (TemplateValue [a]) where  TemplateList a == TemplateList b = a == b" works though, with FlexibleInstances
11:44:54 <fergie> mm_freak: so first I try and parse as an array, then if that fails as a singleton?
11:45:05 <fergie> I think I can do that...
11:45:12 <mm_freak> fergie: which package is that?
11:45:30 <dankna> Saizan: hmm... so it does.  but then I can't define the non-list methods, heh.
11:45:48 <hpc> can't you do "instance Eq [a] .."?
11:46:02 <fergie> mm_freak: valFromObj is in Text.JSON
11:46:13 <mm_freak> fergie: yes, from which package is Text.JSON?
11:46:50 <laurus> Thanks for all your opinions and help!
11:46:52 <laurus> Take care
11:46:56 <Saizan> dankna: it seems like a bug in ghc though.
11:46:56 <fergie> mm_freak: I got it from hackage: cabal install json
11:46:56 <dankna> hpc: if I turn on FlexibleContexts and UndecidableInstances, I can, but I get the same error
11:47:03 <dankna> Saizan: really?  wow
11:47:15 <dankna> so should I be reporting this somewhere?  haha
11:47:19 <mm_freak> ah, found it
11:47:20 <benmachine> mm_freak: if you have a module installed and you want to find out what package it's in, ghc-pkg find-module
11:47:32 <benmachine> if it's not installed try hooogle or something
11:47:40 <mm_freak> benmachine: i don't have it installed, i just want to find the documentation on hackage =)
11:47:42 <Saizan> dankna: well, i'm not sure, but it's pretty suspect
11:47:44 <benmachine> > "h" ++ cycle "oo" ++ "gle"
11:47:46 <lambdabot>   "hooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
11:47:49 <monochrom> yi seems to depend on quite a few more packages besides haskell platform ones
11:47:50 <dankna> Saizan: hmm
11:48:39 <mm_freak> fergie: valFromObj doesn't seem to support varying result types
11:48:53 <mm_freak> unless 'a' = Either something1 something2
11:49:16 <Saizan> dankna: i'd say it deserves a post on the ghc users mailing list at least :)
11:49:48 <fergie> mm_freak: not sure if Either is an instance of JSON
11:49:59 <dankna> Saizan: okie, I shall do that
11:50:42 <mm_freak> fergie: it is, if something1 and something2 are, too
11:51:51 <fergie> mm_freak: great. I'll go see if I can get it to work. Thank you for your help
11:51:53 <Taejo> @seen Taejo
11:51:54 <preflex>  Taejo was last seen on #haskell 9 days, 8 hours, 37 minutes and 31 seconds ago, saying: -fno-warn-missing-signatures looks like the right thing
11:51:54 <lambdabot> Unknown command, try @list
11:52:47 <Taejo> @remember Note to self: do not mess with gwern, he is capable of destroying you with his ninja-like use of everyday tools such as Google Calendar.
11:52:47 <lambdabot> I will remember.
11:53:14 <djahandarie> @quote Note
11:53:14 <lambdabot> Note says: to self: do not mess with gwern, he is capable of destroying you with his ninja-like use of everyday tools such as Google Calendar.
11:53:26 <Taejo> @forget Note
11:53:26 <lambdabot> Incorrect arguments to quote
11:53:31 <mm_freak> fergie: i don't know if that was helpful, because i haven't looked deeper into the json package =)
11:53:35 <Taejo> :(
11:53:58 * sm found the json packages rather hard to use
11:54:00 <djahandarie> I'm surprised preflex doesn't say something witty when you try to @seen yourself
11:54:35 <mauke> @forget Note to self: do not mess with gwern, he is capable of destroying you with his ninja-like use of everyday tools such as Google Calendar.
11:54:36 <kolmodin> does anybody know if there is enough stuff from the GSoC "cabal test" project committed to be useful?
11:54:36 <lambdabot> Done.
11:54:50 <Taejo> mauke: thanks
11:55:03 <Taejo> @remember sheep1e Note to self: do not mess with gwern, he is capable of destroying you with his ninja-like use of everyday tools such as Google Calendar.
11:55:03 <lambdabot> It is forever etched in my memory.
11:55:27 <Saizan> dankna: it's probably fishy to parametrize over Eq a and later discover it's Eq [b], since usually Eq [b] gets constructed from Eq b on the spot, but it doesn't seem like it should fail.
11:55:54 <dankna> hmm
11:56:07 <dankna> I sent off an email.  I don't suppose you have any workarounds? :)
11:56:23 <dankna> I reduced it further, to about four lines, by taking out the other cases, which are similar anyhow.
11:57:08 <dankna> I see what you mean about it being fishy, although this whole subject is giving me mild feelings of out-of-my-depth-ness...
11:58:16 <Saizan> well, you can make multiple instances like the "instance Eq a => Eq (TemplateValue [a]) where .." one for the other types.
11:58:37 <dankna> hmm, that seems like it should work
12:00:41 <kmc> where is the reduced code dankna?
12:01:07 <dankna> I'll put it up
12:02:21 <dankna> http://codepad.org/iGkY6kZA
12:05:31 <kmc> and you're getting the "Cannot deduce (Eq a1)" error?
12:05:36 <dankna> yes
12:05:54 <dankna> if you can't reproduce, I'll upgrade ghc, but I'm not thrilled about doing that, haha
12:06:12 <kmc> i get it on 6.12.1
12:06:17 <dankna> ah good :)
12:06:17 <kmc> do you know that it's fixed in later versions?
12:06:27 <dankna> I don't know that, no
12:06:36 <Veinor> I'll test it on 6.12.3
12:06:38 <dankna> thanks
12:06:45 <Veinor> ... if the codepad would load for me, that is
12:06:45 <nu7hatch> hi all
12:06:52 <roconnor> nu7hatch: hi
12:06:55 <nu7hatch> anyone know which is the best library for redis
12:06:56 <nu7hatch> ?
12:07:01 <roconnor> redis?
12:07:32 <nu7hatch> http://code.google.com/p/redis/
12:07:36 <Veinor> still doesn't work on 6.12.3
12:07:42 <dankna> thanks for verifying that
12:09:58 * roconnor don't know what a database is
12:12:07 <Phyx-> > go
12:12:08 <lambdabot>   Not in scope: `go'
12:12:25 <Phyx-> > l
12:12:26 <lambdabot>   l
12:12:30 <mm_freak> is there any reason why the RTS doesn't use poll/epoll?
12:12:35 <Phyx-> > l++h
12:12:36 <lambdabot>   No instance for (Data.Monoid.Monoid SimpleReflect.Expr)
12:12:37 <lambdabot>    arising from a u...
12:12:52 <Phyx-> @src (++)
12:12:53 <lambdabot> []     ++ ys = ys
12:12:53 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:12:53 <lambdabot> -- OR
12:12:53 <lambdabot> xs ++ ys = foldr (:) ys xs
12:12:58 <hpc> > f ++ g
12:13:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:13:00 <lambdabot>    `SimpleReflect.FromExpr ...
12:13:03 <copumpkin> mm_freak: it does, now
12:13:11 <Veinor> > Nothing ++ Nothing
12:13:13 <roconnor> f, g, l and h are not lists
12:13:13 <lambdabot>   Nothing
12:13:14 <mm_freak> copumpkin: oh?  which GHC version do i need?
12:13:14 <copumpkin> mm_freak: as of a few days ago
12:13:16 <Veinor> ha
12:13:20 <roconnor> er
12:13:27 <roconnor> and I guess not monoids
12:13:28 <copumpkin> mm_freak: the unreleased one :)
12:13:35 <Phyx-> wth is with the (++)
12:13:42 <mm_freak> copumpkin: ok =)
12:13:46 <mm_freak> that's good news
12:13:47 <Veinor> I think in Caleskell ++ is mappend
12:13:48 <burp> Philippa: caleskell
12:13:49 <roconnor> Phyx-: caleskell
12:13:54 <burp> oops phyx
12:14:07 <roconnor> hascale
12:14:09 <mauke> > [] ⧺ []
12:14:11 <lambdabot>   []
12:14:17 <orbitz> I drove past a street yesterday caleld hascall
12:14:25 <Veinor> haskala
12:14:31 <roconnor> mauke: what is the name of that character?
12:14:35 <wli> Hmm. H1.4 had (++) as mplus
12:14:39 <Phyx-> cale-what?
12:14:51 <roconnor> Phyx-: Cale runs lambdabot
12:14:59 <roconnor> so he gets to decide what the definitions of things are
12:15:08 <Phyx-> lol, caleskell
12:15:09 <mauke> U+29FA (e2 a7 ba): DOUBLE PLUS [⧺]
12:15:10 <theorbtwo> U+29FA DOUBLE PLUS
12:15:20 <roconnor> even if they disagree with the prelude and confuse newcomers
12:15:21 <Phyx-> i thought mauke ran botty
12:15:21 <Veinor> DOUBLEPLUS UNGOOD
12:16:05 <roconnor> mauke: I wasn't aware of such a character
12:16:14 <roconnor> mauke: does unicode have >>= ?
12:16:25 <mauke> I don't know
12:16:26 <djahandarie> lol that'd be odd if it did
12:16:39 <Phyx-> unicode has everything'
12:16:41 <djahandarie> At least yi doesn't replace it with anything
12:16:51 <mauke> roconnor: http://mauke.ath.cx/stuff/javascript/unicode.html?q=arrow
12:16:52 <mauke> enjoy
12:17:11 <Phyx-> @tld .cx
12:17:12 <lambdabot> Maybe you meant: bid id pl tell thx todo
12:17:19 <Phyx-> boooo
12:17:21 <mauke> ⤚
12:17:32 <roconnor> ⤜
12:17:48 <djahandarie> Heh almost
12:17:58 <djahandarie> Would make sense for >>-
12:18:04 <djahandarie> I wonder if there is one for >->
12:18:05 <hpc> :t (>>-)
12:18:06 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
12:18:31 <roconnor> ⤘
12:18:35 <hpc> what distinguishes >>- from >>=?
12:18:37 <copumpkin> is that just a breadth-first bind?
12:18:44 <roconnor> good ol' RIGHTWARDS TWO-HEADED ARROW WITH TAIL WITH DOUBLE VERTICAL STROKE
12:18:53 <roconnor> hpc: IIRC >>- is fair
12:19:01 <roconnor> while >>= is unfair
12:19:05 <davidL> is there something similar to liftM2 in haskell but defined as: fooM2 f m1 m2 = do { x1 <- m1; x2 <- m2; f x1 x2 }?
12:19:05 <roconnor> e.g.
12:19:19 <djahandarie> Yep roconnor
12:19:28 <hpc> what do you mean by fair?
12:19:30 <copumpkin> davidL: how is that any different from liftM2?
12:19:45 <copumpkin> hpc: doesn't get lost on infinite depth
12:19:48 <roconnor> [1..] >>= \x -> [1..] >>= \y -> (x,y)
12:20:02 <davidL> copumpkin: there is no return at the end as there is in liftM2
12:20:04 <roconnor> this is unfair because x never gets a chance to become 2
12:20:10 <copumpkin> davidL: oh, duh
12:20:16 <hpc> oh i see
12:20:21 <copumpkin> davidL: no, I don't think so, but you could just join?
12:20:23 <djahandarie> Didn't someone JUST ask that
12:20:35 <roconnor> somehow with >>- they get dovetailed and everyone gets a chance.
12:20:47 <djahandarie> > ((.).(.).(.)) join liftM2
12:20:48 <lambdabot>   Overlapping instances for GHC.Show.Show
12:20:48 <lambdabot>                              ((a1 -...
12:20:48 <roconnor> but I believe this breaks the monad laws
12:20:51 <djahandarie> :t ((.).(.).(.)) join liftM2
12:20:52 <roconnor> so >>- isn't bind.
12:20:52 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
12:20:54 <hpc> hehe, communist bind
12:21:06 <roconnor> hpc: :D
12:21:07 <davidL> djahandarie: pretty!
12:22:13 <djahandarie> @. pl undo do { x1 <- m1; x2 <- m2; f x1 x2 }
12:22:14 <lambdabot> (m2 >>=) . f =<< m1
12:22:20 <djahandarie> Eh
12:22:30 <djahandarie> @type (m2 >>=) . f =<< m1
12:22:32 <lambdabot> Not in scope: `m2'
12:22:32 <lambdabot> Not in scope: `m1'
12:22:36 <djahandarie> Oh lol
12:22:49 <djahandarie> @. pl undo \f m1 m2 -> do { x1 <- m1; x2 <- m2; f x1 x2 }
12:22:50 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
12:22:57 <copumpkin> hot
12:23:11 <copumpkin> that's actually not terrible
12:23:19 <copumpkin> it could benefit from a let
12:23:36 <davidL> @. pl undo \f m1 m2 m3 -> do { x1 <- m1; x2 <- m2; x3 <- m3; f x1 x2 x3 }
12:23:37 <lambdabot> flip ((.) . (.) . (>>=)) . flip ((.) . (.) . (>>=)) . flip ((.) . (.) . (>>=))
12:23:41 <roconnor> my supervisor wants let at the type level
12:23:47 <djahandarie> @type \f m1 m2 -> (m2 >>=) . f =<< m1
12:23:48 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => (a1 -> a -> m b) -> m a1 -> m a -> m b
12:24:04 <djahandarie> I like this more than the join liftM2
12:25:26 <copumpkin> djahandarie: eww
12:28:22 <djahandarie> By that I mean \f m1 m2 -> m1 >>= (m2 >>=) . f
12:29:26 <djahandarie> I tend to avoid =<<
12:29:28 <djahandarie> It's just confusing
12:29:47 <roconnor> really?
12:30:00 <roconnor> I'd like to avoid (f x)
12:30:03 <roconnor> I find it confusing
12:30:09 <djahandarie> lol
12:30:13 <roconnor> inputs to the right. ... that's just weird
12:30:14 <djahandarie> Except we aren't doing function application
12:30:26 <dolio> It's exactly what you're doing.
12:30:30 <roconnor> =<< is a kleisli function application.
12:30:49 <dolio> @type (=<<)
12:30:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:30:52 <dolio> @type ($)
12:30:54 <lambdabot> forall a b. (a -> b) -> a -> b
12:31:17 <mauke> enjoy your right-to-left effects
12:32:09 <dolio> I do.
12:32:51 <djahandarie> I can think of >>=s as a pipeline
12:33:04 <djahandarie> And pipes don't flow in reverse!
12:33:48 <djahandarie> Kleisli is another word I like to avoid
12:35:45 <hpc> XD
12:36:13 <lantti> djahanadrie: So you don't work as a plumber I guess :)
12:37:56 <orbitz> i throw up all the time
12:38:12 <djahandarie> I like to avoid throwing up
12:38:26 <orbitz> how do you not become fat then?
12:38:33 <medfly> I eat well and do exercise
12:38:50 <djahandarie> > do exercise
12:38:51 <lambdabot>   Not in scope: `exercise'
12:38:55 <medfly> ^^
12:40:18 <dpratt71> remarkable how often I get a good result from looking for a function via the type signature I imagine it would have
12:44:09 <nu7hatch> hmm anyone know what can be wrong with that? http://pastie.org/1098437
12:46:15 * hackagebot wumpus-core 0.23.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.23.0 (StephenTetley)
12:46:24 <dolio> nu7hatch: Too-old version of the exception library.
12:47:15 * hackagebot wumpus-basic 0.4.0 - Common drawing utilities built on wumpus-core.  http://hackage.haskell.org/package/wumpus-basic-0.4.0 (StephenTetley)
12:48:15 * hackagebot wumpus-microprint 0.4.0 - Microprints - "greek-text" pictures.  http://hackage.haskell.org/package/wumpus-microprint-0.4.0 (StephenTetley)
12:48:52 <edwardk> hrmm i wonder if do, on its own forces the type to anything interesting.
12:48:55 <edwardk> @type do undefined
12:48:56 <lambdabot> forall a. a
12:48:59 <edwardk> guess not
12:49:05 <dolio> It used to, but they fixed it.
12:49:09 <edwardk> ah
12:49:17 * hackagebot wumpus-tree 0.3.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.3.0 (StephenTetley)
12:49:41 <edwardk> so i can safely liberally sprinkle the word 'do' throughout my code ;)
12:49:59 <dolio> @type do 5
12:50:01 <lambdabot> forall t. (Num t) => t
12:50:03 * duckinator sneaks in lurks
12:50:22 <dolio> I think that used to say '(Num (m a)) => m a' or something.
12:51:07 <djahandarie> @undo do 5
12:51:08 <lambdabot> 5
12:51:19 <Veinor> > do 5
12:51:20 <dolio> But, I'm pretty sure the report would consider that incorrect behavior.
12:51:20 <lambdabot>   5
12:51:37 <edwardk> @type \ a run -> do run run run `a` do run run
12:51:38 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t -> t1
12:51:38 <lambdabot>     Probable cause: `run' is applied to too many arguments
12:51:38 <lambdabot>     In the first argument of `a', namely `run run run'
12:51:39 <dolio> Sinde 'do e' desugars to just 'e', and that should happen prior to type checking.
12:51:41 <edwardk> shucks
12:53:12 <dolio> Part of the problem being, I expect, that GHC actually checks do blocks without desugaring.
12:53:23 <dolio> Or used to.
12:54:08 <dolio> That may no longer be the case, since it's rebindable now, I think.
12:56:09 <Saizan> yeah, it got fixed
12:56:58 <Saizan> ah, wait, i don't know if it's checked after desugaring or not
12:57:12 <chrisdone> hpaste down, *again*! </pete>
12:58:09 <chrisdone> who hosts hpaste!??
12:58:25 <chrisdone> point the domain at tryhaskell.org, i'll sort it
12:59:13 <luite> integrate the pastes with tryhaskell while you're at it :)
12:59:34 <chrisdone> cheeky!
12:59:46 <chrisdone> nice idea
13:00:07 <luite> many won't work of course, but enough of them might :)
13:03:56 <chrisdone> so I thought I'd go through my uploaded packages to Hackage and decide which packages I'm going to maintain, which need a maintainer and which need to be taken out back: http://paste.lisp.org/display/113615 (notice the ones worth maintaining weren't written by me, funny that, must be coincidence >_>)
13:04:15 <chrisdone> where do you announce a request for maintainer? haskell-cafe or?
13:04:32 <chrisdone> perhaps Hackage could have a list of unmaintained packages, Gracenotes
13:06:04 <chrisdone> @vixen where is everybody?
13:06:04 <lambdabot> is that really what you want to know?
13:06:23 <chrisdone> I just want to know why they don't talk :-(
13:06:30 <aristid> i wonder how many people who say they are frustrated with programming are actually frustrated with not using haskell, only they don't know it :D
13:06:34 <aristid> (just kidding :P)
13:07:05 <dankna> I talk
13:07:38 <dankna> The rain in Spain stays mainly in the plain.  The horse raced past the barn fell.  Colorless green ideas sleep furiously.  Sphinx of black quartz, judge my vow.
13:07:39 <dankna> See?
13:07:55 <chrisdone> JavaScript is frustrating me by virtue of not being Haskell; I try to polish it up by running it through a rudimentary compiler with type support and a dumb module system, but it's still JavaScript
13:08:03 <dankna> yes, haha
13:08:23 <djahandarie> lol send me that compiler chrisdone?
13:08:25 <dankna> I tried to revive the js backend for ghc at one point
13:08:30 <aristid> djahandarie: google closure
13:08:32 <dankna> but I gave up, I forget why
13:08:47 <mauke> chrisdone: would you prefer writing in lisp?
13:08:55 <chrisdone> mauke: good question
13:09:09 <chrisdone> I think so
13:09:47 <mauke> I know someone who's working on http://sei.meidokon.net/files/parenscript/ , which is apparently a lisp->js compiler
13:09:48 <chrisdone> at least macros allow you to pretend it's not lisp
13:10:47 <chrisdone> is this the same as tryparenscript's engine?
13:10:59 <mauke> I don't know
13:10:59 <wioux> hmm.. can someone remind me of how to get away with a data declaration like `data Problem ((Enum i) => i) o = Problem i o`?
13:11:49 * BMeph would be interested in an hpaste RSS feed...where by "interested in ..." he means "happy if someone ELSE created..."
13:11:54 <Gracenotes> chrisdone: you could make up a tag, like 'orphaned' or 'unmaintained'
13:11:57 <chrisdone> wioux: it's generally considered not something you should do
13:12:03 <chrisdone> Gracenotes: good idea!
13:12:26 <chrisdone> Gracenotes: I suppose we should decide on one and stick with it~
13:12:36 <wioux> chrisdone: so the constraint just goes in whatever functions operate on that data?
13:12:48 <aristid> "chrisnotdone"
13:13:04 <chrisdone> BMeph: I made a hpaste rss feed, but it only shows the past 10 minutes :P http://tryhaskell.org/hpaste.rss
13:13:14 <chrisdone> wioux: indeed
13:14:33 <chrisdone> Gracenotes: when's Hackage 2.0 coming? for existing Hackage I could just set a category, I suppose: "Unmaintained"
13:15:38 <Gracenotes> I see requests for maintainers on haskell-cafe from time to time
13:15:48 <djahandarie> Will it be easier to signup & upload packages etc in 2.0?
13:16:27 <Gracenotes> uploading packages is pretty easy now -- what else do you have in mind?
13:17:26 * hackagebot hsmagick 0.4 - FFI bindings for the GraphicsMagick library  http://hackage.haskell.org/package/hsmagick-0.4 (TimChevalier)
13:17:26 <BMeph> chrisdone: Why not the last ten entries? Well, by ten, I "really" want thirty, but why quibble? ;)
13:17:30 <djahandarie> I mean... like a two-step interface where I type in my username then select files to upload / a repo where the code is hosted or whatever needed
13:17:56 <Gracenotes> not to blogjack, but - http://cogracenotes.wordpress.com/ - most recent post is about upload policy, second-to-most-recent has some TODO items before switchover
13:18:29 <chrisdone> BMeph: I wrote it for the hpaste-bot to use. but people started spamming it so it didn't seem worth bringint it back. I could trivially remove the time limit if you like?
13:18:50 <chrisdone> Gracenotes: thanks, I'll read
13:19:43 <BMeph> chrisdone: Hmm, a PM-queryable hpaste bot doesn't sound too bad... :)
13:20:29 <djahandarie> chrisdone, don't you already have a comment on that blog post? :P
13:21:41 <chrisdone> djahandarie: oh, I thought he'd made a new post
13:21:49 <Gracenotes> :3
13:22:22 <Gracenotes> you had asked about when it's coming, and it's mostly when the todo list(s) is/are cleared off
13:23:17 <djahandarie> Gracenotes, by the way, regarding the web design makeover thing, I might be able to help
13:23:53 <chrisdone> djahandarie: show your existing web design talents and we'll judge that :P
13:24:22 <Gracenotes> djahandarie: sweet. it seems like there's more and more stuff to put on the current package page, and less and less space to put it in...
13:25:42 <djahandarie> chrisdone, I work with my partner at my job, I don't have anything recent that is 100% mine
13:25:49 <Gracenotes> I haven't thought so much about how to organize it more aesthetically, but for sure there needs to be more judicious use of horizontal space...
13:26:12 <djahandarie> How much flexibility would I have in terms of tearing things down and moving stuff all over the place?
13:26:34 <Gracenotes> djahandarie: as far as uploads go, 'easier' is a relative value, I guess. it's still a single-tarball form.
13:28:30 <Gracenotes> djahandarie: if it makes browsing more efficient and information better organized, go for it.
13:29:02 <djahandarie> Cool. What about introducing new features?
13:29:09 <Gracenotes> as far as mockups go (the actual html generation is somewhere between blaze and xhtml..)
13:29:32 * sm fools around with chrisdone's feed, but it's emptyu
13:30:10 <chrisdone> sm: hmm. maybe I took it down actually after taking hpaste-bot down
13:30:21 <sm> oh you had a bot, I didn't see
13:30:43 <Gracenotes> djahandarie: depends on the features, right? :) if it's doable and it helps with finding packages/finding package information/quality assurance/connecting users and maintainers/any of the above... then sure
13:31:00 <djahandarie> Hehe okay
13:31:38 <djahandarie> Sticking some hoogle/hayoo hybrid right into hackage would definitely be friggin' awesome
13:31:55 <Gracenotes> it would. hayoo doesn't provide any sort of API to my knowledge though
13:31:57 <djahandarie> By that I mean a hoogle that indexes all of hackage
13:32:15 <sm> absolutely, it must be done
13:32:17 <Gracenotes> that would be neat too, although the hoogle files would be uploaded by users
13:32:24 <Gracenotes> as well as the documentation.
13:32:27 <chrisdone> my hoogle indexes all my local hackage installs
13:32:38 <chrisdone> Gracenotes: you can generate hoogle files from the packages, though! why not do that?
13:32:40 <Gracenotes> cabal needs to be configured to generate those more easily
13:32:48 <chrisdone> cabal hadock --hoogle
13:33:21 <chrisdone> Gracenotes: what's the roadblock?
13:33:22 <Gracenotes> chrisdone: if you want to set up a bot to do that, go ahead, we'll make it an automated trustee
13:33:57 <chrisdone> Gracenotes: so I provide a public .hoo file on tryhaskell.org?
13:34:13 <Gracenotes> the philosophy is that the server should generally be dumb. its calculations should be limited to displaying representations of resources
13:34:25 <chrisdone> makes sense
13:34:43 <chrisdone> I suppose in that way you just need an API
13:35:16 <djahandarie> Gracenotes, I'm not entirely sure what that philosophy implies from a design point of view
13:35:47 <djahandarie> Searching in any form isn't "displaying" is it?
13:37:18 <Gracenotes> the resource that http://sparky.haskell.org:8080/packages/find?name=moo represents is the list of packages containing 'moo'. it has a unique identifier URI (redundant). in this case, the collection is empty.
13:37:50 <djahandarie> Right, so what would be wrong with using a type signature or something in stead?
13:37:58 <djahandarie> instead*
13:38:43 <Gracenotes> I guess 'calculation' is a bad way to define it. I don't see any problems with making a Hoogle database internally
13:39:17 <sm> +1 hackage api
13:39:39 <djahandarie> Alright, I'll think about this more before I bring up anything else
13:39:50 <Gracenotes> just need to 1. coordinate uploading it and 2. get the internal indices working
13:40:31 <Gracenotes> likewise -- all that needs to be done to expose pages as JSON (i.e., to use in an API) is to write code to go from server data-structures to JSON format
13:42:06 <djahandarie> Also, what are some things like hackage for other languages? (Online package repo with documentation & version tracking, basically)
13:42:33 <roconnor> cpan?
13:42:43 <chrisdone> Gracenotes: sure. we're more or less standardising on json for our internal web server communications where I work. we've got php/lisp/haskell servers all chatting to eachother, JSON makes it a piece-o'-cake
13:42:50 <sm> pypi, cpan, http://planet.racket-lang.org , http://squeaksource.com
13:42:54 <Gracenotes> http://hackage.haskell.org/trac/hackage/wiki/HackageDB#Similarsystemsforotherlanguages
13:43:12 <djahandarie> Ah, very nice, thanks
13:43:31 <Gracenotes> also, here are some of the documents about the server's internals - http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0/Architecture
13:43:34 * hackagebot attoparsec 0.8.1.0 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.1.0 (BryanOSullivan)
13:43:58 <Gracenotes> two missing pages (not entirely written yet) are HTTP/URI conventions and feature module structure
13:44:30 <c_wraith> hmm.  what did the new version of attoparsec change?  It got a minor version rev
13:45:01 <chrisdone> c_wraith: good point. hackage needs a CHANGELOG. does Hackage 2.0 do that, Gracenotes? :P
13:45:06 <djahandarie> Speaking of which, does hackage index changelogs?
13:45:06 <djahandarie> lol
13:45:07 <djahandarie> Owned
13:46:06 <djahandarie> Gracenotes, does packages == tags?
13:46:29 <raichoo> Non troll question: who of you guys is using darcs and why? or is this totally offtopic in here?
13:46:40 <kmc> seems legit
13:46:43 <chrisdone> raichoo: there's also #darcs
13:46:49 <chrisdone> bit more ontopic there
13:46:54 <kmc> my small experience with using darcs on big projects is that it's unusably slow
13:46:59 <Gracenotes> chrisdone: nop. maybe when the world is taken over by a dictator, he/she will decree a standard changelog format
13:47:15 <djahandarie> Gracenotes, a dictator known as Gracenotes? ;)
13:47:19 <sm> kmc: what's big ?
13:47:25 <djahandarie> I've used darcs on small projects and it works nicely
13:47:28 <sm> and what were you doing that was slow ?
13:47:31 <raichoo> chrisdone: I thought i could get a little more unbiased opinions in here ;) But if it's that offtopic i could take it there
13:47:58 <djahandarie> raichoo, in here is fine imo
13:48:01 <Gracenotes> chrisdone: hm... it's simple enough to make a server-side document which maintainers can edit though
13:48:02 <Peaker> git seems nicer than darcs
13:48:16 <Peaker> ("git reset", "git rebase -i", ..)
13:48:18 <chrisdone> talking about what's on/off-topic is like dissecting a frog
13:48:27 <Gracenotes> actually extracting that information from the tarball is tricky
13:48:36 * sm notes Heffalump is looking for darcs rebase testers in #darcs
13:48:39 <Gracenotes> talking about what's on/off-topic is like talking about something that's off-topic
13:49:08 <djahandarie> Gracenotes, I'd say just give a textbox in addition to the tarball and tell them to write the changes.
13:49:16 <Peaker> sm: I think "darcs" should go for the git model of "reset" jumping to anywhere you want, "checkout" taking file content from anywhere you want, rebase -i ("interactive rebase"), etc
13:49:23 <djahandarie> The CHANGELOG could easily be pasted in, or just a note if they don't have one
13:49:56 <chrisdone> Gracenotes: perhaps just a single commit message for the upload?
13:50:09 <chrisdone> Gracenotes: "We did this, this, and this. Check the CHANGELOG for details."
13:50:12 * djahandarie nods
13:50:45 <chrisdone> satisifies the KISS principle
13:50:59 <Heffalump> darcs doesn't really want all the complexity of the git UI
13:51:08 <kmc> sm, big = GHC
13:51:11 <luite> it would be nice to be able to see the CHANGELOG file without downloading the complete package
13:51:14 <slyght> hi there
13:51:23 * BMeph likes the majesty in the name, "Gracenotes, the 32nd"... ;)
13:51:24 <djahandarie> The GHC darcs repo is a bloody mess
13:51:30 <Peaker> Heffalump: the git UI is horrible -- but a UI that supports git's nice features doesn't have to be
13:51:31 <slyght> could someone of you please try a traceroute to pt2.hmv.com for me? 
13:51:38 <kmc> sm, slow = darcs annotate, runs several minutes then dies running out of stack
13:51:45 <luite> even if it's in some unspecified text format
13:51:57 <slyght> I'm always timing out and would like to know if it's a local issue because I'm in germany
13:52:05 <edwardk> Gracenotes: a dictator who is concerned with changelog formats would be a very interesting dictator indeed.
13:52:06 <kmc> fwiw i really like git.  perhaps i would come to like darcs too, if i used it more.  perhaps not
13:52:08 <chrisdone> Gracenotes: luite: it would in general be nice to be able to browse the whole package online. a recent upload had a PDF for the documentation in it, but you had to download and extract the .tar.gz to read about what it did
13:52:32 <Gracenotes> luite: chrisdone: serving directly from package is one of those things where it just needs a handful of hours of code
13:52:49 <Heffalump> Peaker: so what would darcs reset do?
13:53:00 <Gracenotes> to manage recovering the index on backup, hooking it into uploads, constructing an HTML index and rendering it prettily
13:53:11 <Gracenotes> there are a lot of things that just need a handful of hours of code :)
13:53:22 <Peaker> Heffalump: the command needs a better name, but it would move the current branch ptr to a new location and also update the working tree. It would refuse to run if the movement's changes conflict with working tree changes
13:53:29 <Peaker> Heffalump: (not conflict, but "on same files")
13:53:43 <Heffalump> darcs doesn't even have "branch pointers" :-)
13:53:48 <Peaker> Heffalump: Having a "current branch" (git's "HEAD") and a bunch of "branch ptrs" is a good thing :)
13:54:02 <Peaker> Heffalump: the git model is a good one. only the UI sucks
13:54:09 <djahandarie> Is there a #hackage channel all this talk would be more appropriate for?
13:54:14 <chrisdone> Gracenotes: sure. I don't know why I'm mentioning this stuff, you're rewriting Hackage specifically to be easy to hack on. I'll do it myself once you've done the first release
13:54:42 <Peaker> I wish someone hacks import/export signature dumping into GHC and then fixes cabal-install to use that for dependency analysis
13:55:40 <sm> kmc: yes, annotate is not one of darcs' strong points as of 2.4
13:56:07 <chrisdone> Peaker: surely Hackage would require support too, or you would need all the versions of a package locally for inspection?
13:56:09 <sm> the GHC repo seems usable here otherwise
13:56:13 * djahandarie drives home
13:56:21 <Gracenotes> chrisdone: these are the architecture docs so far -- http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0/Architecture -- as someone who hasn't really worked on the codebase, they look simple enough to get into, right? (not really a replacement for full haddock, or the source code)
13:56:26 <BMeph> Is there a command "like" -split-objs, in that it runs the RTS with some set of parameters "baked in", i.e., no +/-RTS options are accepted?
13:57:03 <chrisdone> Peaker: e.g. if I have a dep. of House.X :: A -> B, how does it inspect the `house' package to find the right version to use?
13:57:09 <BMeph> I would ask in #ghc, but it sounds very "user question"-ish....
13:57:59 <kmc> BMeph, how is that like -split-objs?
13:58:07 <kmc> BMeph, there was such a param added recently
13:58:17 <kmc> one sec
13:58:36 <kmc> -no-rtsopts
13:58:44 <Gracenotes> djahandarie: yep, exactly that
13:58:45 <Peaker> chrisdone: Yes, I mean hackage should have that too
13:58:49 <Gracenotes> over at #hackage
13:58:55 <c_wraith> yeah, it was added because of the danger of running haskell as a CGI script, due to the rts options
13:58:57 <kmc> but it will disable all options, not paste some in
13:59:08 <Peaker> chrisdone: I think it's the most important thing for Haskell's platform right now.. I show Haskell to people and "cabal-install"s reliability is a joke
13:59:22 <kmc> BMeph, for hard-coding RTS options, the nicest way i know is (unfortunately) to write your own main() in C and invoke the Haskell code via FFI
13:59:24 <copumpkin> you can disable all options and then set options through a c module
13:59:39 <c_wraith> I feel like installing the haskell platform is a good way to get cabal to not work
13:59:46 <Peaker> cabal-install's frequent failures makes a lot of people I show Haskell to think Haskell isn't "ready" yet
13:59:54 <kmc> oh right, can you just link in a C object with a string?
13:59:58 <kmc> or do you have to call hs_init() yourself?
14:00:06 <copumpkin> I think you need to call hs_init
14:00:08 <Peaker> cabal-install has overstretched its scalability -- the numeric version dependency scheme does not work
14:00:09 <copumpkin> so no fun
14:00:25 <sm> Peaker: I can relate, but it's also a bit unfair.. hackage is the free-for-all area
14:00:41 <sm> I guess we need stable and unstable hackages
14:00:46 <BMeph> kmc: Well, -split-objs only links the object code accessed by the program, as opposed to the entire module. I would like a similar flag that "cuts out" the code (not just the functionality) for varying the RTS.
14:00:49 <sm> stable would be closer to the HP
14:01:06 <Peaker> sm: But if import/export signatures were implemented, it would probably resolve almost all of the trouble. It would also enable people to write adapters between old/new API's that bridge across version splits
14:01:06 <c_wraith> There's also the fact that most breakages caused by packages are caused by them not obeying the PVP
14:01:21 <Peaker> c_wraith: [citation needed]
14:01:23 <chrisdone> Peaker: my supervisor was complaining about cabal-install's dependencies today after having to battle with two dependencies depending on two versions of ByteString. I suppose with this scheme, it could pick the newest one which satisfies the API requirements of both deps, or fail
14:01:26 <Peaker> c_wraith: I don't believe in the PVP
14:01:50 <c_wraith> Peaker: every single problem I've run into has been fixed by fixing cabal files to set dependencies properly, according to the pvp
14:01:59 <Peaker> c_wraith: Even with the PVP you have to be orthodox about version ranges, and when minor breakages up the version numbers - you break all those that dep on you
14:02:01 <c_wraith> Peaker: If you don't follow the PVP, you *are* the problem
14:02:12 <sm> the PVP will be more effective when automated checking/enforcement arrives
14:02:20 <Peaker> c_wraith: I follow the PVP. most problems I see are indeed version spec problems -- in cases where the PVP *was* followed
14:02:30 <Peaker> I don't understand why people think the PVP solves the problem
14:02:39 <Saizan> Peaker: is pipy reliability a joke as well?
14:02:50 <Peaker> Saizan: no, because Python code doesn't re-use a lot of libraries
14:02:50 <sm> it certainly improves cabal install reliability, no ?
14:02:54 <lispy> pipy?
14:02:55 <c_wraith> what is a "version spec problem"?
14:03:00 <Peaker> Saizan: most Python code uses 3 or 4 libraries
14:03:07 <Peaker> Saizan: not dozens, like typical Haskell packages
14:03:44 * hackagebot sqlite 0.5 - Haskell binding to sqlite3  http://hackage.haskell.org/package/sqlite-0.5 (AdamWick)
14:03:48 <Peaker> Package A depends on package B.  B breaks some minor API A does not use.  PVP forces B to up version number.  Package A can no longer compile. cabal-install fails
14:04:03 <sm> pypi reliability is certainly an issue for eg zope developers. Each zope release pins all packages a la haskell platform I believe
14:04:17 <Peaker> The PVP is hailed as a "solution" all the time, and its merely a slight improvement that can translate compilation errors to cabal installation errors
14:04:45 <c_wraith> It's true that you need to pay attention to changes in libraries you depend on.
14:04:50 <c_wraith> And so it's not ideal in that way.
14:05:22 <Peaker> cabal-install also keeps reinstalling core packages, causing various breakages
14:06:06 <c_wraith> ...  The only time I've had that happen was when 6.12 was new, and some things depended on it unnecessarily.
14:06:07 <Saizan> Peaker: by "cabal installation errors" you mean that cabal will overconservatively tell you that you can't install the lib because the versions don't match?
14:06:09 <lispy> Peaker: but A would continue to build with the previous version of B because that continues to persist on hackage and it's what A claims to work with
14:06:16 <Peaker> Saizan: yeah
14:06:32 <Peaker> lispy: but package C which depends on the newer B will conflict there
14:06:35 <sm> while it's a pain, I think it's way better than compilation failurs
14:06:38 <sm> failures
14:06:42 <kmc> BMeph, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29197#a29197
14:07:28 <lispy> Peaker: if you consider the transitive closure of people using/respecting the PVP then I don't see why C is problem.
14:07:41 <Saizan> Peaker: the only "solution" to that isn't going to be much better than testing your lib against all the versions of the deps, i'd say
14:08:06 <Peaker> lispy: package C depends on the improvement of package B -- if it used correct analysis, it could compile, but it will fail
14:08:19 <Peaker> Saizan: Why not import/export signatures?
14:08:26 <lispy> Peaker: What?
14:08:43 <c_wraith> Why do you think that would improve anything?
14:08:51 <Saizan> Peaker: "import/export singnatures" don't magically solve the problem of testing if those fit.
14:08:54 <lispy> Peaker: also, it seems like you're just moving the goal posts here.  What is your objection exactly?
14:09:25 <Peaker> lispy: Package C depends on B-1.2. Package A depends on B 1.1 (but could work with 1.2).  cabal-install rejects it because A wants 1.1 and C wants 1.2
14:09:38 <c_wraith> What's *really* needed is something like an expanded platform, where package installation is tested against new versions of their dependencies
14:09:46 <Peaker> Saizan: Why is it difficult to match import and export signatures?
14:09:56 <Peaker> Saizan: by "Test" you mean search for a match?
14:10:01 <lispy> If A could work with 1.2 then it needs to be updated to do so
14:10:31 <Saizan> Peaker: check which available versions match 
14:10:32 <c_wraith> The fact is, nothing replaces the need to test.
14:10:42 <c_wraith> Just because signatures match doesn't mean the semantics are the same.
14:10:43 <Peaker> lispy: So all packages on hackage need to get re-released every time their dependency ups a version number in an O(N^2) fashion, in order to update the version deps?
14:10:54 <Peaker> Saizan: why is that difficult?
14:10:58 <lispy> When it comes to correctness, I'd rather have conservative over approximations
14:11:09 <Saizan> Peaker: also, since you can't infer a principal type of the things you import, you can't really have a most general import signature.
14:11:26 <Peaker> c_wraith: You could just mandate that if semantics change, the name or type needs to change too (which could be achieved by uping a number in the module name, while keeping the old module name alive too)
14:11:32 <Saizan> Peaker: which means you end up trying to compile your code against the various cases.
14:12:14 <Peaker> Saizan: why is a principal type not possible to infer?
14:12:51 * hpastebot .  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29166
14:12:53 * hpastebot ComprareSSitesdj  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29167
14:12:56 * hpastebot LuogoIncrrdibileno  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29168
14:12:58 * hpastebot SitioHrmosohd  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29169
14:13:00 * hpastebot SchmackhaftedNewelfl  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29170
14:13:16 <chrisdone> BMeph: how's that http://tryhaskell.org/hpaste.rss
14:13:39 <lispy> whoa, that's really spammy
14:14:02 * hpastebot EifrgerArtikelhc  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29171
14:14:04 * hpastebot TravailHabievb  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29172
14:14:04 <Saizan> Peaker: because you'll often need to import polymorphic functions, which means you are in System F territory, where type inference is undecidable. with typeclasses is even worse. i think i've explained this to you already in the past :)
14:14:06 * hpastebot GramSitio.BuenInfomi  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29173
14:14:08 * hpastebot FormidableUprighttbx  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29174
14:14:08 <lispy> please turn that off
14:14:10 * hpastebot chmackhafteArbeitsn  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29175
14:14:37 <chrisdone> kick it please
14:14:58 <Peaker> Saizan: I don't recall discussing this before :)   Even if you infer a less-general import signature than possible, it would still be a huge improvement over version number
14:15:12 * hpastebot Eke'LocalFinoDeSbh  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29176
14:15:14 * hpastebot UnglaublicherAufdtellungsortgu  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29177
14:15:16 * hpastebot MigkioriVistept  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29178
14:15:17 --- mode: ChanServ set +o Saizan
14:15:18 <Peaker> Saizan: also, you could explicitly specify an import type instead of a less-general inferred one when you want to
14:15:18 * hpastebot ILkeYourWorkbq  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29179
14:15:20 * hpastebot NewelExpertpox  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29180
14:15:20 <BMeph> chrisdone: Checking...
14:15:30 --- mode: Saizan set +q hpastebot!*@*
14:16:04 <chrisdone> Saizan: thanks. I thought I was running and couldn't find the process, it so I asked, but it's sm's :P
14:16:28 <sm> ooh, eek
14:16:50 <sm> guess I'll shut that down 
14:16:54 <chrisdone> sm: yeah, the spam is why I stopped using the bot. you're using the feedirc program right?
14:17:01 <sm> rss2irc
14:17:06 <sm> just wanted to see how it looked
14:17:29 * sm is thinking of renaming that package to feed2irc
14:17:44 <chrisdone> point it to another channel next time :p
14:17:59 --- mode: Saizan set -q hpastebot!*@*
14:18:22 <sm> I am guilty of trying it and forgetting about it. Sorry folks
14:18:25 <Peaker> Saizan: import SomeModule (name :: <explicit type here>) could be a useful extension for this
14:18:39 --- mode: Saizan set -o Saizan
14:23:34 <Saizan> Peaker: yeah, you can't suddenly start requiring that for all imports though, then there's instances, TH, CPP, cabal flags which are hard to integrate into this, and in the end it seems like at best you've reduced the effort needed to find compatible packages by a constant factor.
14:25:26 <Peaker> Saizan: you don't have to require it -- it can be inferred most of the time (even if the types are less general in some cases).  Instances should just appear in the signatures, not sure why they are complicated?  TH/CPP/flags are a problem, I think maybe in this case you can just write the import/export signatures manually.
14:25:30 <Saizan> anyhow, this is why while i think it'd be a quite cool project i've always felt very unmotivated for it :)
14:25:55 <Peaker> Saizan: It will not only make "cabal install" more reliably work -- it will allow to write "adapters"
14:26:16 <Peaker> Saizan: imagine transformers-to-mtl-adapter that has an mtl export signature and transformers import signature, allowing mixing the packages more freely
14:26:36 <Peaker> and adapters between different version API's allowing multiple versions to co-exist
14:27:04 <Peaker> Currently you are forced to depend on "mtl", rather than the mtl interface
14:27:13 <Peaker> "Depend on an interface, not an implementation" is a nice motto
14:27:47 <Heffalump> Haskell needs a proper module system.
14:27:51 <Saizan> i'm not sure a sufficiently general type can be inferred most of the time, anyhow it'd require designing a brand new type inference engine unless you just say something like "i'll pick the type provided by this version of the dep that's known to work"
14:28:11 <monochrom> that is why "show . read" works so perfectly.
14:28:12 <Peaker> Saizan: even if you start with picking up the 'current' type it will be leaps beyond version deps
14:29:39 <Peaker> monochrom: you can do:  show . asTypeOf dummyArgument . read   and move the implementation choice to your caller :)
14:29:50 <Saizan> Heffalump: yeah, it seems like making anything like what Peaker is proposing would end up designing one, even if maybe not proper
14:30:55 <aristid> hmm i'm not sure which is worse, fundeps or type families (purely in terms of usability)
14:31:08 <Peaker> aristid: usability of type families is nice, no?
14:32:13 <Saizan> Peaker: you should study a little about type systems and do it :)
14:32:33 <Peaker> Saizan: my TODO list is about 150% of my current work capability :-)
14:32:58 <Saizan> yeah, imagine adding half a typechecker as fancy as GHC's one on top of that :)
14:32:59 <aristid> Peaker: well it somehow bloats up my code
14:33:04 <Heffalump> will type families (once complete) be enough to simulate first-class modules?
14:33:27 <aristid> Peaker: on the other hand, with associated types i need tons of class parameters to embed in the fundeps
14:33:34 <aristid> -associated types+fundeps
14:34:01 <Peaker> aristid: why not exclusively use type families and no mptc?
14:34:13 <Saizan> Heffalump: first-class as in parametrized or as in instantiable at runtime?
14:34:41 <Heffalump> parametrized.
14:36:16 <aristid> Peaker: i think i'm moving towards that, but type families seem to bloat up my code...
14:36:36 <Saizan> i think there's a paper that says so, but i don't remember if the encoding is an usable one
14:37:19 <Heffalump> well, there's a fairly obvious direct encoding
14:37:20 <aristid> is there a way to abbreviate some of that? consider: class A x where type A x :: * and instance A Complicated where type A Complicated = y
14:37:41 <dolio> Oleg has an encoding of OCaml-like higher-order modules using MPTCs and fundeps.
14:37:44 <aristid> can i avoid repeating the "Complicated" expression?
14:37:57 <dolio> So, in that sense, type families will be good enough, too.
14:38:55 <Heffalump> I'm thinking of the fairly direct encoding where you use a dummy type to represent the module itself, and make a class that defines type functions over the dummy type to represent signatures
14:39:09 <dolio> Yes.
14:39:26 <dolio> I don't think that's particularly nice, though.
14:39:39 <Heffalump> well, it's a bit ugly syntactically, but not too bad
14:40:05 <Heffalump> but I don't have a feeling for how it'll behave with type-checking
14:41:49 <Saizan> you need to make that dummy type appear in the singnatures of the methods, but i guess "foo Dummy" and "Dummy.foo" are pretty similar.
14:42:19 <Heffalump> I'm beginning to come round to the idea of SPJ's type-directed name resolution proposal
14:42:40 <kmc> :O
14:44:33 <Saizan> how would that help here?
14:44:53 <Heffalump> it wouldn't help any more than elsewhere
14:45:44 <aristid> i want briefer syntax for type families :P
14:46:00 <aristid> maybe it exists and just isn't documented in http://www.haskell.org/haskellwiki/GHC/Type_families
14:46:07 <aristid> in that case, tell me about it
14:46:08 <Saizan> yeah, but with this encoding types will be too ambiguous in general to allow name resolution based on them :)
14:46:49 <Saizan> aristid: not that i know of
14:47:01 <Saizan> maybe you can propose something though :)
14:47:34 <Heffalump> why? Dummy.foo would only support foo where the first parameter of foo could be Dummy
14:48:25 <aristid> Saizan: ok!
14:48:35 <aristid> i propose: @ for types
14:49:03 <aristid> instance MyClass Alias@Complicated where type AssociatedType Alias = y
14:49:16 <kmc> that'd just be scoped "type"
14:49:18 <kmc> which is a good feature
14:49:25 <Saizan> yeah, but Dummy.foo was what you'd type in ML, unless you go and on top of making a Dummy type for your encoded module you also export specialized methods from a Dummy haskell module
14:49:30 <kmc> how about:  instance MyClass Complicated where { type Ass _ = y }
14:49:56 <aristid> kmc: where it figures out the needed types automatically?
14:50:28 <kmc> yeah
14:50:36 <kmc> just take _ to mean "the type mentioned in the instance head"
14:50:52 <kmc> it's very simple sugar
14:52:36 <Saizan> actually, parameters on the LHS are always useless in these cases, i think
14:52:48 <kmc> useless but required
14:52:53 <Philonous> Is CC-delcont the canonic library for composable continuations? 
14:52:57 <Saizan> right
14:53:06 <Saizan> so i'd propose type Ass = y
14:53:18 <kmc> that's a lie though, syntactically
14:53:44 <Heffalump> Saizan: you could use data Dummy = Dummy to introduce the type
14:54:06 <kmc> i'd rather see something like «type Ass _ = y» or «type Ass .. = y»
14:54:14 <kmc> as an indication that a parameter has been elided
14:54:25 <Saizan> kmc: not really, those arguments are already abstracted at an higher scope, i guess Agda's modules have warped my brain a little about this though :)
14:54:37 <kmc> if we have a syntax for incomplete parts of type signatures (UHC does?), it could be used here too
14:54:46 <kmc> in standard Haskell there is no syntax for "infer this"
14:55:06 <Saizan> this is not a type signature though
14:55:15 <kmc> it's a type
14:55:19 <kmc> the argument to Ass is a type
14:55:32 <kmc> and a syntactic marker for "infer what goes here" would be reasonable there
14:57:19 <Saizan> as long as i don't have to put one for every argument i guess it'd be good enough :)
14:57:32 <kmc> oh, you have ass-types on a MPTC?
14:57:54 <Saizan> i imagine i'd like to
14:59:31 <kmc> type Ass{} = y
14:59:36 <kmc> weird eh
14:59:44 <Saizan> (we need something better than ass-types btw)
14:59:47 <ddarius> There's nothing special about MPTCs with respect to associated types.
14:59:52 <kmc> yeah,
15:00:08 <kmc> but the use cases overlap, such that you'll less often want to use both
15:00:32 <kmc> it should be allowed certainly, i'm just not necessarily concerned if a bit of trivial sugar doesn't support it as nicely as it could
15:00:55 <kmc> anyway i say the bikeshed should be orange
15:01:28 <Adamant> but what about the nuclear power plant? what color should it be?
15:02:00 <ddarius> Adamant: Silvery.
15:02:09 <kmc> gamma rays
15:02:13 <kmc> that's a color, right?
15:02:14 <dankna> chartreuse
15:02:22 <ddarius> kmc: Arguably.
15:03:07 <ddarius> I'm sure if gamma rays hit your retina you'd see something.
15:05:54 <EvanR-work> heh
15:05:54 <Saizan> so, once we have datakinds, if at some point you happen to want to do some pattern matching on those type parameters, you'd still have to declare an isomorphic gadt indexed by those? 
15:06:35 <dolio> You could use a class.
15:06:53 <dolio> They're already matching on types.
15:08:37 <dolio> Since it's a datakind, it'd be a closed class, too.
15:08:40 <Saizan> yeah, and go through a visitor pattern instead of using case analysis, not sure if i prefer that :)
15:08:45 <dolio> You could just represent that as pattern matching.
15:09:09 <dolio> Visitor pattern?
15:10:04 <Saizan> i was thinking of oleg's tagless final way to represent gadts as type classes, but i guess the class could also have the eliminator as method
15:12:18 <dolio> Anyhow, it rather depends, I guess.
15:12:32 <dolio> If everything at the type level still gets erased, naturally you need a GADT of some kind.
15:12:39 <dolio> Because otherwise there's nothing to case on.
15:12:46 <Saizan> yep
15:13:34 <dolio> Having a class dictionary is similar, I guess.
15:14:25 <mauke> <dha> "Reasons not to use haskell: 1. ow."
15:14:36 <dolio> Conceivably you could just allow case analysis on datakinds, and desugar that into a closed class.
15:14:37 <kmc> haha
15:14:45 <dolio> Or something of that sort.
15:15:13 <dolio> Make pi-type sugar for it like SHE.
15:15:36 <mauke> reaction to <mauke> fun Haskell fact: 'return x' is equivalent to 'return return x x'
15:15:48 <Saizan> existentials would need to know if they have to pack that dictionary or not
15:15:57 <Heffalump> @type \x -> return return x x
15:15:58 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:16:26 <Saizan> "ow"?
15:16:28 <Heffalump> more reader monad abuse, I guess.
15:16:29 <dolio> Haskell/GHC's syntax is kind of ill-equipped for type-level parameters that are computationally relevant.
15:16:53 <dolio> Yeah. const return x x
15:17:19 <kmc> :t return return ?x
15:17:21 <lambdabot> forall a (m :: * -> *) t. (Monad m, ?x::t, Monad ((->) t)) => a -> m a
15:17:27 <kmc> urgh
15:22:24 <Peaker> why does it infer a flexible context there? wouldn't it resolve the existence of a monad instance for (->) to type check that, and then not need the context?
15:22:37 <copumpkin> can JHC compile itself?
15:22:57 <Peaker> it does exactly that in "ghci" without extensions
15:23:10 <Peaker> :t return return 0
15:23:11 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:23:30 <Peaker> why does implicit arguments cause that weird inference?
15:23:35 <Peaker> conal: hey, you there?
15:24:12 <conal> Peaker: yeah
15:24:15 <Heffalump> :t (\x -> return return x)
15:24:16 <lambdabot> forall t a (m :: * -> *). (Monad m, Monad ((->) t)) => t -> a -> m a
15:24:25 <kmc> Peaker, it'll remove the instance iff you have Control.Monad.Instances loaded
15:24:31 <Heffalump> Peaker: nothing to do with implicit arguments, apparently
15:24:36 <kmc> hmm maybe?
15:25:10 <Peaker> conal: did you try out the "Wrapper" class for newtypes/etc?
15:25:18 <conal> Peaker: not yet
15:25:33 <Heffalump> kmc: you get an error without Control.Monad.Instances loaded. With it, you get the type above.
15:25:33 <Peaker> conal: ah, I'm curious to see if you find some nice solutions to the problems it arises :)
15:25:53 <conal> Peaker: i forgot.  making a note to myself to try it.
15:26:07 <Peaker> "return return 0" requires Control.Monad.Instances, results in no flexible context.  "\x -> return return x" doesn't require Control.Monad.Instances, results in a flexible context
15:26:33 <kmc> Heffalump, this is what i get: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29199#a29199
15:26:46 <kmc> i'm thoroughly confuse dnow
15:27:00 <conal> Peaker: would you email me a code snippet?  will help me remember to try it out.
15:27:02 <Heffalump> I'm confused too, but I'm going to bed.
15:27:04 <kmc> «:set -XFlexibleContexts» also has no effect
15:27:54 <Peaker> conal: sure
15:29:39 <djahandarie> Does Haskell have an official color scheme or something like that?
15:30:02 <kmc> yes, you will be ejected from the club if you do not wear it at all time
15:30:10 <djahandarie> ;)
15:30:18 <djahandarie> lol
15:37:43 <Saizan> ?type \x -> show [x]
15:37:45 <lambdabot> forall t. (Show t) => t -> String
15:38:18 <lispy> :t (>=>)
15:38:19 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
15:38:31 <Saizan> Monad ((->) t) can't be simplified to something mentioning only t though.
15:38:45 <kmc> can't it be simplified away entirely if the instance is in scope?
15:39:03 <Saizan> yes
15:39:44 <Saizan> ?type (\x -> return return x) :: Monad m => t -> a -> m a
15:39:46 <lambdabot> forall t a (m :: * -> *). (Monad m) => t -> a -> m a
15:40:11 <c_wraith> oh, right.  return = const
15:40:36 <c_wraith> :t const return
15:40:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => b -> a -> m a
15:41:19 <Peaker> why can't type inference infer the type indices in my classes from the method implementations?
15:44:24 <aristid> coding with type families reminds me of c++
15:50:06 <gs4> hey guys, whats the standard way to treat unicode strings in haskell when doing io? conversion to bytestrings?
15:50:13 <kmc> that's backward
15:50:17 <kmc> String is a unicode string
15:50:31 <kmc> it's just a list of Char, and Char is a Unicode codepoint
15:50:44 <gs4> true, thats why its hard to lookup documenation :P
15:50:49 <c_wraith> I don't think the question was backwards.
15:50:56 <gs4> the problem im having is that standard putstrln and getline have trouble with unicode it seems
15:50:57 <c_wraith> If you assume he meant output
15:51:02 <c_wraith> what version of ghc?
15:51:09 <gs4> 6.12.1
15:51:16 <kmc> gs4, as of GHC 6.12, String IO does your locale unicode encoding
15:51:16 <c_wraith> 6.12 has platform-dependent unicode input
15:51:24 <gs4> oh, terrific :)
15:51:26 <conal> Peaker: got your email.  thanks.
15:51:34 <gs4> i was basing this on afriends recent troubles with an older version of ghc 
15:51:38 <gs4> thats great news, thanks guys :)
15:51:42 <kmc> the right bytestring-like library for unicode text is "text" i think
15:51:47 <kmc> there are others too
15:51:48 <c_wraith> double-check that it works right for you, of course. :)
15:51:52 <kmc> ezyang had a post about this recently
15:52:02 <gs4> ok, cool
15:52:12 <gs4> i wil lcheck -- ill also look at data.text for ref :)
15:52:20 <kmc> you can use utf8-prelude to get utf8 IO regardless of locale / GHC version
15:52:47 <gs4> kmc: what do you mean?
15:53:11 <kmc> it provides an API like System.IO
15:53:19 <kmc> which always does String IO in the UTF-8 encoding
15:53:34 <kmc> even on GHC before 6.12, or on platforms not configured for UTF-8 as the default locale
15:53:54 <gs4> ah, very nice.
15:54:09 <gs4> thats excellent to know about :)
16:03:18 <int80_h> given * connect [CAdbname "tutorialDB"] * has type * connect [CAdbname "tutorialDB"] :: ConnectA Session *, how would I create a function definition that took the type as input and returned a type foo?
16:12:37 <Apocalisp_> edwardk, you on?
16:13:38 <copumpkin> omg an Apocalisp_ 
16:14:02 <Apocalisp_> zomg!
16:16:56 <ddarius> aristid: It should.
16:19:09 <aristid> ddarius: deliberate pain?
16:28:12 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29201#a29201
16:28:18 <int80_h> overlapping instances
16:33:45 <davidL> what's a good name for (either fail return =<<)?
16:34:33 <aristid> :t (either fail return =<<)
16:34:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (Either String a) -> m a
16:35:13 <aristid> davidL: eitherFailM?
16:37:04 <davidL> aristid: hmm
16:37:50 <benmachine> leftToFail
16:38:07 <ddarius> :t either fail return
16:38:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => Either String a -> m a
16:38:27 <c_wraith> :t left fail
16:38:29 <lambdabot> forall (m :: * -> *) a d. (Monad m) => Either String d -> Either (m a) d
16:38:54 <c_wraith> :t (>>= left fail)
16:38:55 <lambdabot> forall (m :: * -> *) a b. (Monad m, Error (m a)) => Either (m a) (Either String b) -> Either (m a) b
16:39:09 * syntaxglitch suggests "sinisterFailure"
16:39:25 <benmachine> heh, classy
16:39:59 <c_wraith> Where did it come up with Error constraints from?
16:40:00 * ddarius suggests "weCan'tTrustThemSouthPaws."
16:40:21 <ddarius> :t left
16:40:22 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
16:40:33 <syntaxglitch> ddarius, and the awesome part is that that's a valid identifier
16:40:41 <c_wraith> It's not with the period at the end.
16:40:55 <syntaxglitch> what other language lets you use contractions in camelCase identifiers?
16:41:09 <Gracenotes> factor
16:42:05 <int80_h> @liftIO
16:42:06 <lambdabot> Unknown command, try @list
16:42:10 <int80_h> @list
16:42:10 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:42:17 <c_wraith> I think you want :t liftIO
16:42:26 <int80_h> I want to know what module I can find it in
16:42:33 <c_wraith> @hoogle liftIO
16:42:34 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
16:42:42 <int80_h> I'm getting "out of scope" when I try and use it
16:45:03 <ezyang> Can I make this code work? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29202#a29202 
16:45:47 <ezyang> I can make it work by pushing the Monad PhantomMonad constraint into the type signatures, but that seems really ugly to me. 
16:46:15 <Gracenotes> oh I see
16:47:03 <ddarius> That code looks insane.
16:47:30 <ezyang> ddarius: :-( 
16:49:06 <mpiechotka> Is there defined anywhere strict list  (something like data SList a = Empty | SList !a !(SList a))?
16:49:26 <monochrom> perhaps some package on hackage, or roll your own
16:49:40 <ddarius> @hackage strict
16:49:40 <lambdabot> http://hackage.haskell.org/package/strict
16:49:58 <pickles> monochrom: i usually carry packages, not roll them
16:50:03 <ddarius> No lists.
16:50:24 <ddarius> Usually, one wants a head-strict (spine-lazy) list, not a fully strict list.
16:50:29 <monochrom> But I roll strict lists.
16:51:36 <CakeProphet> so I'm using fclabels, but I'm wondering if there's any real benefit of using fclabels outside of the state monad.
16:52:15 <CakeProphet> if so, then I could switch all of my large record types over to fclabels, but otherwise I think I should only use fclabels with the record type that's being used in my state transformer.
16:52:42 <CakeProphet> I guess you could have functions like
16:53:09 <CakeProphet> getSTM :: (r :-> a) -> TVar r -> STM a
16:55:23 <aristid> when a class instance has 11 lines of constraints, does that indicate that i'm doing something wrong?
16:55:35 <monochrom> heh
16:56:29 <monochrom> how complex is your system? do you think your goal warrants such complexity?
16:57:08 <monochrom> so complicated it has no obvious error? so simple it obviously has no error?
16:57:26 <aristid> monochrom: well, i use type families, and i use these constraints to check that the associated types of two parameters are the same
16:59:04 <aristid> roughly like this: instance (AT1 a ~ n, AT1 b ~n, AT2 a ~m, AT2 b ~m) => Foo (X a b n m) where type AT1 (X a b n m) = a; type AT2 (X a b n m) = b
16:59:52 <wagle_> why am i banned in haskell-in-depth?
16:59:53 <aristid> if there's a less complex way to achieve what i want, i don't know about it (which means little, given how little experience i have)
17:00:54 <ezyang> Hmm. Thinking about this more carefully, I basically want GHC to be able to infer that if I use Foo r when Foo is an associated data type for typeclass FooClass, then r definitely has an instance of FooClass. 
17:01:50 <Philippa> wagle_: it doesn't appear anyone's banned in there
17:02:09 <wagle_> i cant change my nick because I'm banned there
17:02:32 <wagle_> sigh
17:02:45 <c_wraith> I also don't see anyone banned in that channel
17:02:52 <wagle_> ok..
17:03:41 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29206#a29206
17:03:45 <int80_h> type troubles
17:04:14 <benmachine> wagle_: if you're banned in any channel you're currently in, you can't change your nick anywhere
17:04:27 <benmachine> banned or muted, maybe
17:05:00 <int80_h> hi benmachine
17:05:08 <benmachine> hello
17:05:19 <int80_h> want to look at my hpaste?
17:05:36 <int80_h> the type system is driving me insane. I thought I should document the experience.
17:05:36 <benmachine> it's in one of my myriad firefox tabs
17:05:38 <benmachine> I'll get around to it
17:05:39 <itsmonktastic> hpaste? that's an interesting pseudonym
17:06:02 <benmachine> do you mean euphemism
17:06:09 * syntaxglitch wonders whether ℝ is considered an acceptable type name in Haskell code
17:06:18 <benmachine> syntaxglitch: acceptable/awesome
17:06:35 <benmachine> although if you've actually found an encoding of all possible real numbers I will be quite impressed
17:06:35 <Lemmih> int80_h: Ask GHC to infer the signature or try the possible fix.
17:06:37 <hpc> that is pretty awesome
17:06:45 <itsmonktastic> benmachine: Yeah, I do. Blame 1am. ¬¬
17:06:48 <benmachine> actually no CReal does that fine I guess
17:06:56 <syntaxglitch> benmachine, yeah, it's a bit misleading, makes me feel guilty
17:06:59 <dolio> Depends what "all possible" means.
17:06:59 <wioux> > isUpper 'ℝ'
17:06:59 <wagle_> 100817 16:58:32 * 435 wagle #haskell-in-depth Cannot change nickname while banned on channel
17:06:59 <wagle_> 100817 16:58:59 * Cannot send to channel #haskell-in-depth
17:07:00 <lambdabot>   True
17:07:23 <wagle_> rebooting my irc gateway in a few minutes
17:07:23 <int80_h> lemmih, how do I ask ghc to infer the signature?
17:07:28 <benmachine> dolio: oh, true
17:07:35 <hpc> write the function without a signature
17:07:37 <hpc> and :t in ghci
17:07:39 <benmachine> I guess even [Digit] can't really encode uncomputable numbers
17:07:44 <benmachine> or whatever they're called
17:07:44 <syntaxglitch> and if anyone is wondering, yes it is uppercase alphanumeric
17:07:51 <dolio> Although if CReal is it, then I've got your back. :)
17:07:52 <syntaxglitch> so it's syntactically valid
17:07:58 <hpc> nothing can encode uncomputable numbers, i don't think
17:08:23 <hpc> by definition
17:08:30 <syntaxglitch> hpc, encoding uncomputable numbers is easy, you just have to use an uncomputable encoding
17:08:35 <benmachine> hpc: there is a countable number of finite RAM configurations, and an uncountable number of reals
17:08:36 <hpc> haha
17:08:39 <benmachine> heh
17:08:47 <benmachine> *are
17:09:08 <wioux> some uncomputable numbers are computable to a fixed precision..
17:09:39 <Gracenotes> it's times like these when I confusedly conflate every single computability-related definition I know
17:09:43 * syntaxglitch loves that "but you can't encode the reals" was the objection people found, not "why are you using unicode math symbols in your code"
17:09:44 <benmachine> heh
17:09:50 <benmachine> syntaxglitch: :)
17:10:08 <dolio> syntaxglitch: I do that all the time in Agda.
17:10:08 <hpc> my issue with it was about to be that there's no typeclass for them anyway
17:10:18 <hpc> Num includes complex
17:10:25 <benmachine> syntaxglitch: I have definitely seen data ℕ = Z | S ℕ before
17:10:32 <syntaxglitch> nice
17:10:35 <ddarius> @src Real
17:10:35 <lambdabot> class  (Num a, Ord a) => Real a  where
17:10:35 <lambdabot>     toRational      ::  a -> Rational
17:10:40 <hpc> oh
17:10:41 <ddarius> A silly class.
17:10:50 <wagle> what a lame mechanism
17:10:51 <hpc> that's a funny class
17:11:03 <benmachine> it's sort of faintly laughable from a mathematical perspective
17:11:06 <Gracenotes> all reals should have a rational approximation
17:11:22 <dolio> ℕ is?
17:11:32 <dolio> Or the Real class?
17:11:32 <benmachine> dolio: no, I meant Real
17:11:34 <Gracenotes> > toRational (1.0/0.0)
17:11:36 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
17:11:40 * benmachine clarity of expression wooo
17:11:42 <Gracenotes> close enough
17:11:53 <benmachine> heh
17:11:55 <Gracenotes> (not that infinity is real)
17:11:58 <benmachine> "almost infinity"
17:12:40 <dolio> > fromRational (toRational (1.0/0.0)) :: Double
17:12:41 <lambdabot>   Infinity
17:12:45 <dolio> Bam!
17:13:02 <dolio> > fromRational (toRational (0.0/0.0)) :: Double
17:13:03 <lambdabot>   -Infinity
17:13:35 <ddarius> @src realToFrac
17:13:35 <lambdabot> realToFrac = fromRational . toRational
17:13:36 <int80_h> lemmih : I let ghci infer the type. One of us is wrong. Either I am wrong thinking I know what the lefthand side of the -> should be, wrong about the right hand side of ->, or both. Or ghci is wrong about the left hand side of ->
17:13:49 <ddarius> > realToFrac (0.0/0.0)
17:13:49 <lambdabot>   -Infinity
17:13:57 <dolio> I can never remember that name.
17:14:50 <Gracenotes> seems to suffice for most integral -> floating conversions
17:15:04 <benmachine> int80_h: I got to your tab, isn't the problem just that the first error omitted the class constraints for brevity?
17:15:20 * syntaxglitch goes back to writing some geometry junk
17:15:36 <ddarius> Yay geometry junk.
17:15:37 <syntaxglitch> I'd stop to complain about Haskell's numeric type classes but really it's all been said
17:15:43 <benmachine> heh
17:15:49 <benmachine> Show n => Num n ftw
17:16:01 <int80_h> benmachine ah yes, when ghci inferred the type it included about half a page of constraints
17:16:08 <syntaxglitch> benmachine, that's the least of my complaints at the moment
17:16:52 <int80_h> if my class constraint are about 10 lines long, is there some way I can shorthand it for readability?
17:17:04 <kmc> C preprocessor
17:17:09 <int80_h> eep
17:17:15 <benmachine> nah there are better ways than that
17:17:21 <int80_h> thank god
17:17:22 <syntaxglitch> or use undecidable instances
17:17:29 <benmachine> is it possible some instances are missing?
17:17:47 <benmachine> for an illustration of how this can be a problem
17:17:56 <benmachine> try :t fmap fmap fmap fmap fmap
17:17:57 <pickles> may I just say that i love haskell?
17:18:00 <int80_h> benmachine : that could be. I'm using takusen, and flying very blind.
17:18:01 <pickles> (sry to interject)
17:18:03 <benmachine> before and after importing Control.Monad.Instances
17:18:12 <benmachine> pickles: you may, go ahead when ready
17:18:23 <pickles> it's so clean and simple
17:18:27 <pickles> and succint
17:18:52 <pickles> </interjection>
17:18:54 <syntaxglitch> benmachine, what's wrong with five fmaps?
17:18:56 <kmc> :)
17:19:19 <benmachine> syntaxglitch: if you don't have the functor instance for (->) in scope, the context blows up quite quickly
17:19:22 <ddarius> syntaxglitch: Two of them should be (.)s
17:19:27 <benmachine> if you do, it's very small
17:19:59 <syntaxglitch> oh, I had, errrr... forgotten that that instance could be not in scope
17:20:01 <syntaxglitch> ... :\
17:20:06 <pickles> *succinct
17:20:10 <pickles> knew i was missing a letter...
17:20:20 <benmachine> syntaxglitch: well, if you put it in the right place, it can't be :)
17:20:28 <benmachine> just those pesky orphans making things difficult
17:21:22 <syntaxglitch> benmachine, it's more that I usually open GHCi in the context of something I'm working on, which inevitably imports my own altered "prelude"
17:21:46 <benmachine> syntaxglitch: oh, sorry, I missed your second "that" :P
17:21:57 <benmachine> thought you meant "...that instances..."
17:22:00 <syntaxglitch> ah
17:22:16 <benmachine> http://hackage.haskell.org/package/Takusen <-- weird thing, there are doc links but they don't go anywhere?
17:22:28 <syntaxglitch> no, I just tend to forget that things like Monoid, Applicative, and the pointless obfuscation monad aren't always around by default 
17:22:33 <Apocalisp> That's better
17:23:29 <benmachine> oh, there are doc links for modules that aren't compiled, because takusen builds without support for anything by default
17:23:32 <benmachine> weird
17:23:49 * syntaxglitch isn't sure how anyone writes nontrivial Haskell code without using Applicative, really
17:24:12 <dolio> Me neither. It's so luxurious.
17:24:20 <Gracenotes> the module tree isn't made from the documentation itself
17:24:25 * benmachine just writes trivial haskell code instead
17:24:25 <CakeProphet> syntaxglitch:  simple. they write it without the abstractions.
17:24:26 <Gracenotes> it's based on the cabal file
17:24:44 <benmachine> Gracenotes: but hackage is intelligent enough not to make doc links if the build fails altogether
17:24:57 <Gracenotes> yeah, it checks whether the folder exists
17:25:29 <Gracenotes> if no, plain text. if yes, format the module names the way haddock makes them. works most of the time at least.
17:26:12 <benmachine> mm, most of the time
17:26:25 <aristid> :t let (.:) = (.).(.) in (fmap.:fmap, fmap fmap fmap fmap fmap)
17:26:26 <lambdabot> forall a b (f :: * -> *) a1 a2 (f1 :: * -> *) a3 b1. (Functor f, Functor f1) => ((a1 -> b) -> (a -> a1) -> f a -> f b, (a3 -> b1) -> (a2 -> a3) -> f1 a2 -> f1 b1)
17:27:51 <ezyang> What's the difference between Arf n => n -> IO () and (Arf n => n) -> IO ()? 
17:28:44 <kmc> would that be writ «(forall n. Arf n => n) -> IO ()»?
17:28:49 <kmc> i don't think you can do it otherwise (in GHC)
17:28:57 <dolio> ezyang: The former is probably interpreted as higher-rank.
17:29:21 <kmc> :t let x :: ((Show a) => a) -> (); x = undefined in x
17:29:22 <lambdabot> forall a. ((Show a) => a) -> ()
17:29:24 <kmc> oh, weird
17:29:41 <kmc> > let f :: ((Show a) => a) -> (); f = undefined in f 'x'
17:29:42 <lambdabot>   *Exception: Prelude.undefined
17:29:50 <kmc> hmm that should not typecheck if it is rank-2
17:29:53 <kmc> > let f :: (forall a. (Show a) => a) -> (); f = undefined in f 'x'
17:29:54 <lambdabot>   Couldn't match expected type `a'
17:29:54 <lambdabot>         against inferred type `GHC.Types.C...
17:30:08 <dolio> Odd, then.
17:30:14 <ezyang> Yeah, I don't think higher rank is what's going on here. 
17:30:26 <kmc> :t let f :: ((Show a) => a) -> (); f = undefined; g :: (Show a) => a -> (); g = f in f
17:31:01 <dolio> > let f :: (Show a => a) -> a -> String ; f x y = show y in f 'c'
17:31:02 <lambdabot>   Could not deduce (GHC.Show.Show a) from the context ()
17:31:02 <lambdabot>    arising from a us...
17:31:47 <ezyang> And that's the inference problem I'm running into 8) 
17:32:06 <dolio> Is that legal H98/2010?
17:32:20 <ezyang> I haven't checked. 
17:32:30 <ezyang> but I doubt it 
17:32:33 <dolio> It works without any extensions, though?
17:33:11 <ezyang> No, it needs RankNTypes 
17:33:16 <dolio> Ah, okay.
17:33:46 <ezyang> But you don't get the usual capture effect, which is what's confusing me. 
17:35:48 <benmachine> maybe it's just a parser oddity?
17:36:06 <dolio> No, my test above shows it's genuine.
17:36:33 <dolio> It's associating the dictionary with just one argument.
17:36:42 <greap> What is going on here? I can't figgure out how this error message makes any sense: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29208#a29208
17:37:00 <benmachine> > let f :: a -> (Show a => a) -> (); f _ _ = () in ()
17:37:01 <lambdabot>   ()
17:37:09 <benmachine> weird
17:37:20 <kmc> greap, what's L
17:37:25 <greap> Data.List
17:37:39 <kmc> :t Data.List.deleteBy
17:37:40 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
17:37:47 <kmc> seems it takes 3 arguments
17:37:53 <kmc> you're providing only 1, then composing
17:37:55 <kmc> you need to provide another
17:38:33 <dolio> ezyang: Does it work if you only turn on implicit parameters?
17:38:55 <ezyang> doesn't look like it. 
17:39:07 <dolio> Huh.
17:39:17 <ezyang> Oh! 
17:39:22 <ezyang> It looks like you need FlexibleContexts too. 
17:39:32 <dolio> A (Show a => a) argument would make sense if we had local instances.
17:39:35 <dolio> But GHC doesn't.
17:41:55 <ddarius> > let f :: (Show a => a) -> a -> String; f x _ = show x in f 'x'
17:41:56 <lambdabot>   Could not deduce (GHC.Show.Show a) from the context ()
17:41:56 <lambdabot>    arising from a us...
17:42:07 <ddarius> > let f :: (Show a => a) -> a -> String; f x _ = show x in f 'x' 'y'
17:42:08 <lambdabot>   Could not deduce (GHC.Show.Show a) from the context ()
17:42:08 <lambdabot>    arising from a us...
17:42:42 <dolio> Oh, so it does nothing.
17:43:08 <ddarius> Seems that way.
17:43:14 <dolio> All right, then.
17:43:24 <ddarius> GHC does allow constraints in locations where they can be lifted.
17:43:32 <greap> kmc: Thanks. Those _By functions always seem to trip me up.
17:43:55 <dolio> > let f :: (Show a => a) -> a -> String ; f _ _ = "zoom" in f id 5
17:43:57 <lambdabot>   "zoom"
17:44:07 <dolio> > show id
17:44:08 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:44:08 <lambdabot>    arising from a use of `...
17:44:10 <kmc> greap, i think the error message from GHC is confusing
17:44:34 <dolio> Is there anything in lambdabot that isn't an instance of Show?
17:44:36 <ddarius> > Mu Nothing
17:44:37 <lambdabot>   Not in scope: data constructor `Mu'
17:44:42 <ddarius> > In Nothing
17:44:43 <lambdabot>   No instance for (GHC.Show.Show (L.Mu Data.Maybe.Maybe))
17:44:43 <lambdabot>    arising from a u...
17:44:57 <dolio> > let f :: (Show a => a) -> a -> String ; f _ _ = "zoom" in f (In Nothing) 5
17:44:59 <lambdabot>   No instance for (GHC.Num.Num (L.Mu Data.Maybe.Maybe))
17:44:59 <lambdabot>    arising from the l...
17:45:11 <dolio> > let f :: (Show a => a) -> a -> String ; f _ _ = "zoom" in f (In Nothing) (In Nothing)
17:45:12 <lambdabot>   "zoom"
17:45:14 <dolio> Okay.
17:45:49 <ddarius> > let f :: (forall a. Show a => a) -> String; f x = show x in f 'x'
17:45:50 <lambdabot>   Couldn't match expected type `a'
17:45:50 <lambdabot>         against inferred type `GHC.Types.C...
17:46:05 <aristid> :t let let f :: (forall a. Show a => a) -> String; f x = show x in f
17:46:05 <lambdabot> parse error (possibly incorrect indentation)
17:46:09 <aristid> :t let f :: (forall a. Show a => a) -> String; f x = show x in f
17:46:10 <lambdabot> (forall a. (Show a) => a) -> String
17:46:33 <ddarius> > let f :: (forall a. Show a => a -> String) -> String; f show' = show' 3 in f show
17:46:34 <lambdabot>   "3"
17:46:57 <aristid> :t In
17:46:58 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
17:47:15 <aristid> > In Nothing
17:47:16 <lambdabot>   No instance for (GHC.Show.Show (L.Mu Data.Maybe.Maybe))
17:47:16 <lambdabot>    arising from a u...
17:47:23 <aristid> :t In Nothing
17:47:24 <lambdabot> Mu Maybe
17:47:33 <ski> ddarius : i was wondering if there's any paper by Barry Jay you would recommend as introduction to his pattern calculus ?
17:47:52 <ddarius> ski: Give me one second.
17:48:04 <greap> kmc: Yes it's very confusing, especially as my definition did not match my type signature.
17:48:32 <ddarius> ski: http://journals.cambridge.org/repo_A45US65o
17:49:32 <ddarius> That's the latest and greatest.  His book's introduction (or something like that) is available online and is not a bad historical introduction with some applications, but it doesn't include some of the newest ideas.
17:49:54 <greap> also, I ended up rewriting it as http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29208#a29209 I'm sure there must be a more appropriate function to use.
17:50:37 <ddarius> ski: http://www-staff.it.uts.edu.au/~cbj/patterns/ (you probably already have that link)
17:50:59 <ddarius> So with explicit quantification you can localize a constraint.
17:54:43 <ddarius> You should be able to mimic certain usages of GADTs by using that and a Church-encoded representation.
17:57:14 <ski> ddarius : ty
18:02:55 <ski> > let f :: Show a => (Show a => a) -> a -> String; f x _ = show x in f 'x' 'y'
18:02:57 <lambdabot>   "'x'"
18:05:12 <ski> ezyang : `Arf n => n -> IO ()' would be similar to `(Arf n *> n) -> IO ()', rather than `(Arf n => n) -> IO ()'
18:06:00 <ski> (those being comparable with `A -> (B -> C)',`(A,B) -> C',`(A -> B) -> C', respectively)
18:07:39 <dolio> That makes more sense with existentials, too.
18:07:50 <dolio> exists n. C n *> ...
18:08:39 <ski> where the `*>' is my notation for when you define : `data Foo a = forall b. C a b => MkFoo (Bar a b)', then the type of `MkFoo' is `MkFoo :: forall a b. C a b => Bar a b -> Foo a', which i then write alternatively as `MkFoo :: forall a. (exists b. C a b *> Bar a b) -> Foo a' (displaying the "existential" in "existential datatype" better)
18:09:14 * dolio is a professional thunder thief.
18:09:44 <mm_freak> someone should replace that ugly old logo
18:09:50 <luite> how would you guys publish some haskell code that others might find interesting, but that's not really a library or program? just put it on github or something?
18:10:12 <kmc> yeah
18:10:17 <newsham> Arf n *> Arf
18:10:28 <ski> (s/type/type signature/)
18:12:06 <ezyang> ski: Huh. So this is like, anonymous existentials? 
18:13:25 <kmc> "exists" gives you existentials without declaring wrapper types
18:13:37 <kmc> UHC has them, though does not support capturing type class instances in them
18:14:07 <kmc> « Foo a *> a » is not an existential type, though
18:14:26 <ezyang> Hm. 
18:14:48 <dolio> C *> T is a pair of a context and a type.
18:15:07 <ezyang> ah, ok. 
18:15:20 <kmc> if you translate instances into their dictionaries, then it's an ordinary tuple (CDict, T)
18:15:25 <ski> a value of type `C a => Foo a' is a value such that if you can prove `C a', then you may use it as having type `Foo a'
18:15:29 <ezyang> So if I do this: foo :: (Show a => a) -> (Show a => a) -> a 
18:15:59 <ezyang> I'm implying that there could be separate dictionaries for each of them. 
18:16:00 <ski> a value of type `C a *> Foo a' is a value which comes with a proof that `C a', as well as an actual value of type `Foo a'
18:16:01 <ddarius> ezyang: It will behave the same as foo :: a -> a -> a
18:16:03 <ezyang> But GHC doesn't let us do that yet. 
18:16:29 <ddarius> ezyang: It just doesn't really make much sense.
18:16:42 <ski> (or rather, it's not very useful)
18:17:14 * ezyang nods 
18:18:16 <ezyang> You know what would be neat? Kindclasses. 
18:18:21 <ddarius> > let f :: (Show a => a) -> (Show a => a) -> String; f x y = show x ++ show y in f 1 2
18:18:22 <lambdabot>   Could not deduce (GHC.Show.Show a) from the context ()
18:18:22 <lambdabot>    arising from a us...
18:18:50 <ddarius> ezyang: A lot of value level things would be nice at the type level (which would push type level things into the kind level.)
18:18:52 <ski> ezyang : .. do you have any application in mind ?
18:19:09 <ezyang> ski: I've been playing around with genericizing phantom monads. 
18:19:18 <ezyang> It's bitchy, and I think kindclasses would make things nicer. 
18:20:18 * syntaxglitch really ought to finish his silly type programming library before byorgey renders it completely irrelevant
18:20:30 <ddarius> syntaxglitch: Why?
18:20:40 <Runar> @hoogle [a -> a] -> a -> a
18:20:40 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
18:20:41 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
18:20:41 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
18:20:56 <ski> @type foldr (.) id
18:20:57 <lambdabot> forall b. [b -> b] -> b -> b
18:21:07 <Runar> oh yeah, duh
18:21:13 * ski usually calls that `compose'
18:21:24 <Runar> thanks ski
18:21:33 <syntaxglitch> ddarius, because I've already got a bunch of stuff and I doubt I'll find the motivation to clean it up if large chunks are obsoleted
18:21:34 <ezyang> Namely, I want to be able to write PhantomMonad SomeAssocDataType => ... 
18:21:37 * ddarius used to call that mconcat but then they switched the Monoid instances out from under me.
18:22:00 <ski> (Runar : .. `foldl' if you want to compose the other way around .. or just `reverse' it beforehand)
18:22:06 <ezyang> instead of (Monad (SomeAssocDataType s)) => ... 
18:22:14 <ezyang> which means that s has to show up somewhere on the right side of the equation. 
18:22:32 <syntaxglitch> though probably I have more ridiculous crap in my library than will ever end up in anything official
18:24:03 <ezyang> I've basically concluded that generic interfaces != simple interfaces 
18:24:14 <ezyang> when you want to do anything nontrivial. 
18:25:01 <ski> one thing which would be nice is if one could define something like `class Functor (f :: k0 -> k1) where fmap :: forall (a :: k0) (b :: k0). (forall k :: k0 -> *. k a -> k b) -> (forall k :: k1 -> *. k (f a) -> k (f b))' (not sure if that's exactly right ..)
18:25:24 <c_wraith> ezyang, My conclusion was "on the first try, I have no clue how to make a generic interface."
18:25:43 <ezyang> c_wraith: It's f'ing hard. :-) 
18:25:46 <ddarius> Kind polymorphism (and kind products) would be very useful for generalizing many categorical widgets.
18:25:52 <ski> the idea being to define one class which both handles functors from `*' to `*' as well as functors from `* -> *' to `*', ones from `* -> *' to `* -> *', &c.
18:26:24 <ddarius> class Category (hom :: forall k. k -> k -> *) where ...
18:26:41 * syntaxglitch has kind polymorphism in his type metaprogramming library... well, sort of
18:26:53 <ezyang> And after two days worth of type hacking, I stand back and look at the resulting interface, and the types are inscrutable. 
18:26:58 * ski has seen someone in here who wanted one (or maybe both ?) of the last two functor variants
18:27:04 <ezyang> And I run into technical walls everywhere trying to make the types easier. 
18:27:22 <ezyang> Specializing doesn't even help, because the generic typeclass machinery is dumb and needs help. 
18:28:05 <ezyang> So you get stupid signatures like '(G.NetworkMonad m AIG (Dup n n2)) => Node n -> m AIG (Dup n n2) (Node (Dup n n2)' 
18:28:25 <ezyang> actually, that signature isn't too stupid. 
18:28:28 <ezyang> (forall n2. G.NetworkMonad GNT AIG (Dup n n2) => NT (Dup n n2) a) -> NQ n AIG 
18:28:43 <ezyang> which I would much prefer to have been (forall n2. NT (Dup n n2) a) -> NQ n AIG 
18:28:51 * ezyang stops complaining now 
18:31:41 <ezyang> In short, ezyang tried to do stupidly complicated things with the type system and got a stupidly complicated interface as a result :-) 
18:32:01 <syntaxglitch> ezyang, I've probably written worse type signatures by a good margin
18:32:12 <ezyang> syntaxglitch: I believe you :-) 
18:32:33 * djahandarie doesn't want to ever brag about writing overcomplicated type signatures
18:35:15 <syntaxglitch> ezyang, I bet your code looked nicer than this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29210#a29210
18:35:40 <ezyang> agggh my eyes 
18:36:10 <ezyang> Though you're doing something complicated :-) 
18:37:00 <syntaxglitch> it didn't end up working out, though
18:37:12 <syntaxglitch> had to scrap most of that
18:37:34 <syntaxglitch> ezyang, here's some that's a little less silly: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29211#a29211
18:38:11 <syntaxglitch> just a snippet from a much larger module...
18:40:47 <ezyang> syntaxglitch: Is that type level sets? 
18:41:11 <syntaxglitch> sort of
18:41:20 <ezyang> On an unrelated note, I'm looking for a function with a type signature with something like ref a -> (a -> (a, b)) -> monad b, but Hoogle's not being too helpful. 
18:41:37 <copumpkin> ref
18:41:39 <copumpkin> ?
18:41:46 <ezyang> Some sort of reference datatype like IORef 
18:41:58 <copumpkin> ah
18:42:01 <ezyang> Closest thing I could find was atomicModifyIORef 
18:42:06 <ski> @type Data.IORef.modifyIORef
18:42:08 <lambdabot> forall a. GHC.IOBase.IORef a -> (a -> a) -> IO ()
18:42:09 <ski> @type Data.IORef.atomicModifyIORef
18:42:10 <lambdabot> forall a b. GHC.IOBase.IORef a -> (a -> (a, b)) -> IO b
18:42:15 <ski> *nod*
18:42:17 <copumpkin> oh so you want an atomicmodifyXref for IO and ST at once?
18:42:20 <ezyang> But that doesn't have the ref a -> (a -> a) -> monad () variant 
18:42:22 <copumpkin> there's one of those in Vector IIRC
18:42:43 <ezyang> Actually, I'm just trying to get an idea of what I should name a similar function. 
18:43:01 <ski> probably it should be in a `MonadRef' class
18:43:15 <syntaxglitch> ezyang, it's a snippet from a half-baked implementation of relational algebra where the rows are type-index HList-ish things
18:43:36 <syntaxglitch> so the set-like stuff is for finding type overlap between two relations in order to do a natural join
18:43:50 <ezyang> The pattern is m () -> r vs. m a -> (r, a) 
18:43:58 <ezyang> Maybe this is the eval/run distinction. 
18:44:07 <ezyang> syntaxglitch: Huh. 
18:44:16 <conal> sm: ping.
18:45:48 <syntaxglitch> ezyang, it was a fun toy but never went anywhere due to performance issues
18:46:10 <copumpkin> syntaxglitch: oh, I started something like that too
18:46:24 <copumpkin> was trying to figure out how to represent outer joins though
18:46:28 <copumpkin> and then gave up
18:46:38 <copumpkin> since they didn't seem very elegant
18:46:57 <pickles> nite all
18:47:00 <syntaxglitch> I didn't have outer joins as such
18:47:03 <djahandarie> Night!
18:47:12 <djahandarie> That was odd
18:47:36 <syntaxglitch> but did have something similar that would explicitly fill in default values
18:49:41 <syntaxglitch> copumpkin, in other news, didn't I talk to you a little bit ago about 2D constructive geometry?
18:49:47 <ddarius> copumpkin: Outer joins aren't very elegant.
18:50:21 <syntaxglitch> the stuff I'm tinkering with currently is probably forcing me to at least implement portions of something along those lines, so I'll probably be tossing the result up on github at some point
18:50:46 <copumpkin> syntaxglitch: yep :)
18:50:57 * ski . o O ( natural joins ought to only join on foreign keys (and possibly other similar referential constraints, if there are any) )
18:51:01 <copumpkin> ddarius: yeah :( it'd be nice if there were a simple way to express them
18:51:53 <ddarius> copumpkin: Having a simple way to express them is not going to make them elegant.
18:52:41 <copumpkin> ddarius: true
18:53:55 <syntaxglitch> ski: "foreign keys"? "referential constraints"? I don't think I had any of those
18:54:33 <copumpkin> syntaxglitch: how goes the 2d constructive geometry?
18:55:06 <ddarius> ski: Did you read Spivak's databases as categories papers and if so what did you think?
18:55:46 <syntaxglitch> copumpkin, not much yet, I just spent this evening extracting some of the geometry code out from the rest of the code
18:55:47 <ddarius> syntaxglitch: Are you familiar with geometric algebra?
18:56:23 <syntaxglitch> I was going to just limp along with some quick and dirty geometry stuff in the meantime but after seeing what I actually need to use, might as well do it properly
18:56:32 <syntaxglitch> ddarius, don't think so?
18:56:34 <ski> syntaxglitch : i mean if you join `Teacher (id,name,...)' with `Course (id,name,teacher,...)' where there is a referential constraint from `Course.teacher' to `Teacher.id', then doing a natural join ought to join `Course.teacher' with `Teacher.id', as well as *not* join `Course.name' with `Teacher.name'
18:56:42 <ski> ddarius : not yet
18:57:08 <syntaxglitch> ski, yes, you seem to be thinking of relational databases, which have nothing to do with the code I was talking about ;)
18:57:33 <walter_> In general monad m a, do  something <- get, then something should be that "a",  compare to State s a, do something <- get , seems something should be a but not s. doens't it? 
18:57:56 <ski> syntaxglitch : well, you talked about relational algebra and natural joins ..
18:58:48 <syntaxglitch> ski, yes, but with everything purely type-indexed
18:59:17 <ski> walter_ : yes, if `get :: State s a', then after `something <- get', you have `something :: a' -- because matching `State s a' with the general `m a', the `m' matches `State s' (since `State s a' really is `(State s) a')
18:59:36 <ski> syntaxglitch : .. i'm not sure what you mean exactly, by that
19:00:32 <syntaxglitch> ski, no explicit concept of a table like you'd have in a DB, no concept of column names other than their type
19:00:41 <syntaxglitch> and no duplication of types allowed
19:00:54 <ski> ezyang : hm, i don't see how `m () -> r' vs. `m a -> (r, a)' would be the pattern for `IORef a -> (a -> a) -> IO ()' vs. `IORef a -> (a -> (a, b)) -> IO b'
19:01:15 <ezyang> ski: Yeah, actually it's a bit different :o) 
19:01:16 <mtnviewmark> :t get
19:01:16 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
19:01:21 <ddarius> syntaxglitch: Read the links labelled part I - part III on this page: http://staff.science.uva.nl/~leo/clifford/
19:01:26 <syntaxglitch> so if to join two relations with row types of (Int :*: Bool :*: NIL) and (Int :*: String :*: NIL), the two sets of Ints must be combined
19:02:19 <ddarius> syntaxglitch: The types are the column names not the column types.
19:02:51 <mtnviewmark> I wonder if it isn't practical to insist that all column types be distinct
19:03:03 <ddarius> mtnviewmark: It isn't.
19:03:09 <ski> syntaxglitch : hm, so you can't express endo-relations like "mother" or "direct superior of" easily, then ..
19:03:10 <walter_> ski, thanks. But consider: lengthStringS' :: State String Int; lengthStringS' = do s <- get; return $ length s.  The String is the s in State s  a, well  String is what  <- get get. I am confused 
19:03:14 <mtnviewmark> Hehe
19:03:27 * syntaxglitch points out that this was some toy code, not intended for serious use :P
19:03:39 <ski> @type get
19:03:40 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
19:03:43 * ddarius reads Lounesto's site for the first time.
19:04:12 <ski> walter_ : in your case, `m' is `State s', so `get :: State s s', or, more specifically, `State String String'
19:04:42 <syntaxglitch> ddarius, btw, thanks for the link
19:05:59 <Philonous> Is there a tutorial for delimited continuations in haskell? The original paper is rather heavy weight.
19:06:20 <walter_> ski, do you mean lengthStringS' :: State String Int should be lengthStringS' :: State String String ?
19:07:47 <ski> walter_ : no, i mean that in your case `get :: State String String', so after `s <- get', `s :: String', and since then `length s :: Int', so `return $ length s :: State String Int', and that's the type your  lengthStringS'  gets as well
19:07:52 <mtnviewmark> :info State
19:08:50 <walter_> ski, thanks, let me think for a while.
19:08:50 <ski> walter_ : see `get :: State s s'; the same `s' is used twice, both in the "state type" position, and in the "return value" position
19:09:31 <ski> walter_ : so, when you force the former ("state type") to be `String', that makes the latter ("return value type") also become `String', in the case of the `get'-action
19:09:43 <ddarius> Philonous: I'd recommend perusing the much more voluminous work in Scheme.
19:09:45 <ski> and *that*s why `s' gets the type `String' after `s <- get'
19:10:30 <ski> (Philonous : a very short one is <http://community.schemewiki.org/?composable-continuations-tutorial>)
19:11:39 <ski> probably <http://library.readscheme.org/page6.html> has references to at least some of the relevant papers
19:12:10 <ski> (i'd also suggest "Abstracting Control" and "Representing Control" by Filinski)
19:13:15 <Philonous> ski: Thank's I've read the former. And I begin to understand reset/shift, but I am clueless about the other combinators the haskell library provides (control, shift0, control0 and the 4 basic ones) 
19:16:24 * ski hasn't looked at whatever haskell library Philonous is referring to ..
19:17:07 <dolio> control, shift0 and control0 can be read about in Ken Shan's Shift to Control.
19:17:25 <Philonous> dolio: I just found that paper. Thanks
19:17:47 <ski> (and i'm not really sure when you'd rather use `control' and `prompt' than `shift' and `reset' (alternatively the multiple `reset'/`prompt' variants))
19:17:48 <Philonous> I like the pun
19:19:04 <dolio> There's a way you can get breadth-first traversal of a tree instead of depth-first by switching from shift to control.
19:19:24 <dolio> But, that's kind of a ridiculous example.
19:21:36 <nejucomo> Is this a valid type?  a -> b -> f a b
19:21:51 <nejucomo> -or must f be further specified in some way?
19:21:55 <kmc> yes
19:22:06 <kmc> but you can't write any function of that type
19:22:14 <kmc> other than by cheating and using "undefined" or similar
19:22:26 <kmc> you've no way to construct a value of type «f a b» from values of type a and b
19:22:32 <kmc> but if you specialize, say f = Either, then you have something
19:22:49 <kmc> :t const . Left
19:22:50 <lambdabot> forall b a b1. a -> b -> Either a b1
19:23:04 <kmc> :t const . Left :: a -> b -> Either a b
19:23:05 <lambdabot> forall a b. a -> b -> Either a b
19:23:09 <ski> kmc : well, that depends on whether `a',`b',`f' are to be universally quantified over that type or not ..
19:23:17 <kmc> mm
19:23:29 <kmc> i was assuming the standard Haskell convention, that free type variables are universally quantified
19:23:51 <kmc> :t let x :: a -> b -> f a b; x = undefined in x
19:23:52 <lambdabot> forall a b (f :: * -> * -> *). a -> b -> f a b
19:23:58 <ski> (e.g. that type could be part of a larger type, or be the type signature of a class method, where the class head mentions at least one of those type variables)
19:24:03 <kmc> mm right
19:25:01 * ski would typically only assume implicit universal quantification if a type *signature* was given (and the context didn't suggest outer binding of the variables)
19:27:14 <ski> nejucomo : .. so, were `a -> b -> f a b' to be part of a larger type, or were it to be a type signature ? (in the latter case, were it to be a method or field or constructor type signature ?) (finally, were any of `a',`b',`f' to be concrete types that you just not specified here ?)
19:27:54 <kmc> in the latter case, one could write A, B, F instead to get the point across
19:28:06 <nejucomo> ski: Not sure really, I just noticed I had two functions and wondered if I could make an abstraction.  Their types were (a -> b -> X a b) and (a -> b -> Y a b).
19:28:37 <ski> *nod* (but some times i write like `a',`b',`f' anyway (though i think i usually then say something like "for any specific types `a',`b',`f'")
19:28:42 <nejucomo> Actually in both cases "a" and "b" were really "Z x y a" or "Z x y b".
19:28:42 <ski> )
19:28:45 <kmc> nejucomo, you can invent a typeclass
19:28:56 <kmc> class Con2 f where { con2 :: a -> b -> f a b }
19:29:02 <kmc> instance Con2 (,) where { con2 = (,) }
19:29:11 <kmc> instance Con2 Either where { con2 = const . Left }
19:29:18 <kmc> it's not clear to me what the point of this would be
19:29:23 <kmc> but there may be a point :)
19:29:31 <nejucomo> After that I realized I couldn't make an abstraction even if I could over the types (the functions do different things).
19:29:46 <kmc> you can't do it with purely parametric polymorphism because... yeah, you said it.  the functions do different things
19:29:55 <nejucomo> Or maybe I can; my skill at abstraction with the type system is still basic.
19:29:57 <ski> nejucomo : so `forall x y a b. Z x y a -> Z x y b -> X a b' and `forall x y a b. Z x y a -> Z x y b -> Y a b' ?
19:30:17 <nejucomo> Perhaps.
19:30:52 <ski> some more concretization of that you're actually trying to do would be in order here, i think
19:31:08 <kmc> well, if you want further advice on the task
19:31:17 <kmc> it's a valid type-theoretic question on its own
19:31:20 <kmc> @djinn a -> b -> f a b
19:31:21 <lambdabot> -- f cannot be realized.
19:31:23 <kmc> @djinn a -> b -> Either a b
19:31:23 <lambdabot> f a _ = Left a
19:31:25 <kmc> @djinn a -> b -> (,) a b
19:31:26 <lambdabot> Cannot parse command
19:31:29 <kmc> @djinn a -> b -> (a,b)
19:31:29 <lambdabot> f a b = (a, b)
19:32:31 <ddarius> tetrahemihexahedron
19:33:19 <ski> nice :)
19:36:15 <nejucomo> Here's a more basic question:  I often want to use foldl to accumulate list state from left to right, but I want to accumulate state with (:) naturally, but then the result is reversed.
19:36:21 <nejucomo> What's a clean approach?
19:36:27 <danportin> Is there any danger in using -XMultiParamTypeClasses when declaring type classes?
19:36:40 <kmc> if you're accumulating state with (:), maybe "map" is what you want instead of foldl?
19:36:55 <kmc> why does it matter to go from the left?
19:37:03 <nejucomo> No, I need a fold because the output list is shorter than the input, some elements are aggregates.
19:37:06 <syntaxglitch> map or perhaps scanl
19:37:10 <kmc> ok
19:37:11 * ski first thinks of the small rhombihexahedron, when pondering star polyhedra ..
19:37:26 <Gracenotes> you can fold on a function
19:37:28 <nejucomo> It needs to go from the left, because I need data from the left side to compute the current output value.
19:37:39 <kmc> mm
19:37:39 <ddarius> This is what the topology of 3 dimensional rotations matrices looks like: http://upload.wikimedia.org/wikipedia/commons/b/bb/Boy_Surface-animation-small.gif
19:37:47 <Gracenotes> a list-building function. no guarantees about space/time
19:37:51 <nejucomo> I'm not being clear…  I think for my present example foldr works.
19:38:25 <nejucomo> I'm trying to remember my last case…  it was more clear cut.
19:38:32 <jbapple> the STM docs say: "Any attempt to do so will result in a runtime error. (Reason: allowing this would effectively allow a transaction inside a transaction"
19:38:37 <jbapple> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/GHC-Conc.html#t%3ASTM
19:38:52 <ski> danportin : not really. apart from that you might get ambiguous code which have to be disambiguated with type ascriptions or similar, unless you add (reasonable) functional dependencies to the class
19:39:06 <jbapple> I thought that nesting transactions was just fine
19:39:22 * syntaxglitch is rather fond of unreasonable functional dependencies
19:39:28 <ddarius> jbapple: Nope.  Not for the current implementation of STM.
19:39:47 <jbapple> ddarius: That makes me sad
19:40:00 <ddarius> syntaxglitch: Then you'd like: class Foo a | -> a
19:40:06 <nejucomo> I thought the selling point of STM was you didn't need nested transactions because of composition.
19:40:43 <syntaxglitch> ddarius, looks good to me, I'll take it
19:40:53 <danportin> Thanks. It's just a small module for tree rewriting with zippers, so hopefully it will be fine :)
19:41:12 <kmc> the selling point of STM is that you have transactions
19:41:32 <jbapple> What is the workaround to nesting?
19:41:42 <kmc> what is the problem you want to solve?
19:42:26 <jbapple> kmc: I'm a bit new to concurrency, so I'm not sure. Is nesting really not useful?
19:42:36 <nejucomo> kmc: But composition is a big win.  Compare that to say a python decorator called "transaction"...
19:42:48 <kmc> nejucomo, how would that not be composable, if properly implemented?
19:42:57 <kmc> that decorator would take the role of the function "atomically"
19:43:09 <kmc> you can presumably call multiple functions from your decorated function, thereby composing them
19:43:18 <jbapple> I thought nesting was one of the great things about STM, at least from what I think I remember from reading STM discussion from outside of the haskell ecosystem
19:43:22 <kmc> jbapple, i don't know of a use case.  but i'm mostly familiar with STM in Haskell, so i may be missing part of the field
19:43:23 <ddarius> jbapple: Nesting is useful.
19:43:23 <kmc> ok
19:43:29 <kmc> what's it useful for?
19:43:39 <nejucomo> kmc: It would be!  The problem is in python you may call the composable elements directly (there's no type check to enforce transactional composition).
19:43:48 <kmc> mm, right
19:43:55 <kmc> there could be a runtime check
19:44:05 <kmc> which is like the other checks in python, including type checks
19:44:10 <nejucomo> :-)
19:44:30 * nejucomo is presently implementing a strict dynamically typed language in haskell.
19:45:04 <kmc> cool :)
19:45:07 <ddarius> kmc: Forms of speculation is one class of examples that jump to mind.
19:45:32 <Raghs> what directory is the .ghci file in windows 7? (or ghci.conf)?
19:46:40 <FunctorSalad> json-b vs JSONb?
19:46:47 <FunctorSalad> (ping solidsnack)
19:46:54 <FunctorSalad> :)
19:48:10 <FunctorSalad> seems like the latter is just the newer version of the same thing
19:48:20 <kmc> the full record of #haskell logs is approaching the size of one CD-ROM
19:48:22 <kmc> (uncompressed)
19:48:29 <llayland> would it be fair to say that Applicative provides the ability to overload the meaning of taking a parameter and Monad adds the ability to overload the meaning of being used as a parameter?
19:48:40 <ddarius> kmc: Yours or tunes?
19:48:46 <djahandarie> That's a huge amount of text
19:48:46 <kmc> my mirror of tunes
19:48:58 <kmc> 10,187,166 lines
19:49:00 <kmc> a few more by now
19:49:12 <djahandarie> Heh
19:49:12 <yescalona> @karma
19:49:12 <lambdabot> You have a karma of 0
19:49:17 <yescalona> @karma java
19:49:17 <lambdabot> java has a karma of -10
19:49:19 <djahandarie> @karma
19:49:20 <lambdabot> You have a karma of 1
19:49:24 <djahandarie> :(
19:49:33 <syntaxglitch> @karma lambdabot
19:49:34 <lambdabot> lambdabot has a karma of 2
19:49:57 <syntaxglitch> @karma @karma
19:49:57 <lambdabot>  @karma has a karma of 0
19:49:58 <kmc> llayland, interesting.  i don't immediately see why that's the case; can you elaborate?
19:51:33 <ddarius> Exercise to readers: Read about Moggi's monadic metalanguage and his computational lambda calculus.
19:51:47 <kmc> exercise to readers: get me a sandwich
19:52:01 <c_wraith> kmc: all I have is some chinese food.
19:52:02 <ski>   sandwich <- get
19:52:07 <kmc> what kind c_wraith
19:52:18 * syntaxglitch can kind of see what llayland is getting at but it's far too vague to say much about
19:52:25 <ddarius> c_wraith: Do you have bread?  You could make a Chinese food sandwich.
19:52:38 <c_wraith> kmc: I don't know.  It's leftovers, and I could barely tell the various things apart when I first got them.
19:52:46 <kmc> ok
19:52:50 <yescalona> why the list dont support strings and numbers together?
19:52:53 <ddarius> c_wraith: Sounds delightful.
19:52:59 <kmc> some kind of undifferentiated mass of rice and noodles and meat and sauce
19:53:04 <kmc> yescalona, what would the type be?
19:53:07 <c_wraith> ddarius, it's all tasty.  I just don't know what parts are what :)
19:53:44 <kmc> yescalona, a list has to contain only one type, so that you know what type you get out of it
19:54:01 <kmc> yescalona, but that type can be something with multiple constructors
19:54:05 <kmc> e.g. Either Int String
19:54:23 <kmc> :t [Left True, Right "foo"]
19:54:24 <lambdabot> [Either Bool [Char]]
19:54:40 <ddarius> kmc: Socratic questioning doesn't work if you also give the answer.
19:54:48 <kmc> ;P
19:54:54 <kmc> was just a motivating rhetorical
19:56:08 <kmc> yescalona, perhaps you want to define a new type, meaningful for your problem domain, which describes the stuff which can go in the list
19:56:14 <ddarius> Profunctors are very pretty when properly connected to presheaves.
19:56:24 <syntaxglitch> ddarius, btw, thanks a second time for that geometric algebra link--it looks really interesting, I may need to try implementing some of this stuff
19:56:40 <llayland> hmm, I'm just trying to get a bit of intuition on the various type classes and to briefly be able to describe them without getting into the details.  
19:56:48 <kmc> llayland, did you read Typeclassopedia?
19:57:08 <kmc> llayland, the main difference between Applicative and Monad is that Monad lets you decide what to do next based on the result of the last thing you did
19:57:09 <yescalona> ;)
19:57:22 <ddarius> syntaxglitch: If you are at all interested in physics (or some other things) you'll want to look at David Hestenes' page later and also Doran and Lasenby's.
19:57:41 <kmc> Applicative requires you to build a fixed pipeline of things and then do them
19:57:49 <ddarius> llayland: Read about Moggi's computational lambda calculus.
19:58:42 <llayland> yes, I've read typeclassopedia a few times
19:59:03 <nejucomo> Can pattern matching test equality, as in: let (a, a) = (4, 4) in ...
19:59:13 <nejucomo> Doesn't seem so.
19:59:14 <kmc> nejucomo, no.  you can use guards for that
19:59:24 <kmc> let (a,b) | a == b = ...
19:59:31 <nejucomo> Ooh, I haven't used guards much.  Thanks for the tip.
19:59:35 <ski> ddarius : "profunctors" ?
19:59:52 <syntaxglitch> ski, as opposed to amateur functors
20:00:11 <nejucomo> So can I have two clauses with the same pattern but distinct guards?
20:00:17 <kmc> yes
20:00:25 <kmc> (a,b) | a == b = .....  | otherwise = .....
20:00:27 <nejucomo> f a b | a == b = blah ; f a b = foo
20:00:31 <kmc> or that
20:00:35 <kmc> note that "otherwise" is just an alias for True
20:00:38 <kmc> > otherwise
20:00:39 <lambdabot>   True
20:00:49 <nejucomo> Wacky.
20:01:06 <llayland> yes, I'm getting that Applicative is fixed.  You can apply to, but not use from
20:01:29 <llayland> ddarius, I'll check that out
20:02:15 <ddarius> ski: Functors (C^op x D) -> Set, though that doesn't do them much justice
20:02:40 <nejucomo> Does anyone have a thorough syntax reference?  I've only seen tutorials.
20:02:47 <ddarius> @where report
20:02:47 <lambdabot> http://www.haskell.org/onlinereport/
20:02:50 <nejucomo> I seem to recall something like (Foo a b)@foo
20:02:56 <nejucomo> Thanks.
20:03:02 <syntaxglitch> nejucomo, other way around, btw
20:03:04 <kmc> foo@(Foo a b)
20:03:07 <kmc> variable@pattern
20:03:14 <nejucomo> Ah, thanks.
20:03:29 <ddarius> The Gentle Introduction is, I believe, comprehensive about Haskell 98 syntax/features.
20:04:17 <nejucomo> Few…  This is getting hairy.  Think it's time for a new module.
20:04:59 <ski> ddarius : "Hom"-functors for categories enriched over `Set' ? .. or just any difunctors to `Set' ?
20:05:26 <ski> (maybe there's no real difference ?)
20:05:51 <syntaxglitch> the Gentle Introduction has a bit too much expository fluff the serve as good reference material, though
20:06:47 <ddarius> ski: The latter.  A Hom functor would be C^op x C -> Set.  Hom functors are, of course, notable examples of profunctors.
20:07:13 <ski> er, you're right, of course
20:45:49 <jrockway> hey all, i have some very vague questions this evening
20:46:00 <jrockway> i'm thinking about another FFI binding i'm writing for work
20:46:08 <jrockway> the complexity is that all the functions i'll bind are pure
20:46:15 <jrockway> except that they all depend on this global "namespace"
20:46:27 <jrockway> i'm thinking of doing it in a monad like ST
20:46:59 <llayland> depend in what way?  do they modify the namespace or just read it?
20:46:59 <jrockway> and ensuring that namespaces don't leak out with a type for run like forall a. (forall s. Whatever s a) -> a
20:47:04 <jrockway> yes, they modify it
20:47:11 <jrockway> it is almost exactly like ST
20:48:25 <jrockway> mostly, i haven't noticed anyone else doing this
20:48:32 <jrockway> most libraries i've looked at just do everything in ST
20:48:42 <jrockway> so i am not sure if i should "make my own", or just reuse ST for this
20:48:57 <kmc> if you reuse ST, you'd wrap your FFI calls with unsafeIOToST?
20:49:18 <jrockway> not sure about that yet
20:49:25 <jrockway> i have only read part of the STRef implementation
20:49:33 <jrockway> my plan is to do whatever GHC does to make strefs work
20:50:05 <kmc> since GHC implements the IO and ST monads in almost the same way
20:50:33 <kmc> it should be relatively safe to FFI-import with IO types, and use unsafeIOToST
20:51:06 <jrockway> ok, that makes sense
20:51:11 <djahandarie> Having things be "relatively safe" is not why I use Haskell
20:51:18 <kmc> so long as you encode your safety property into the types you expose
20:51:34 <jrockway> that makes sense
20:51:42 <jrockway> the type system prevents me from leaking the state from inside ST
20:51:50 <jrockway> and each computation in ST depends on the previous result
20:51:56 <jrockway> and the first computation is "make a namespace"
20:52:02 <jrockway> so i am convinced that that is referentially pure
20:52:14 <kmc> how do you force that that's the first computation?
20:52:32 <jrockway> you have to pass the namespace to each computation
20:52:49 <kmc> so what's wrong with the simpler approach:
20:52:56 <kmc> newtype Foo a = Foo (IO a)
20:53:00 <kmc> runFoo :: Foo a -> IO a
20:53:05 <kmc> runFoo (Foo m) = makeNewNamespace >> m
20:53:17 <kmc> exporting the type Foo but not its constructor
20:54:11 <jrockway> makes sense
20:54:20 <jrockway> it seems like it's even safe to unsafePerformIO there
20:54:29 <jrockway> as the computation chain is definitely referentially transparent
20:54:37 <jrockway> as long as you don't leak the namespace, anyway
20:54:37 <kmc> ah, right
20:54:56 <kmc> and the ST trick would be useful to avoid leaking the namespace
20:55:05 <kmc> but how can you even get at the namespace, to leak it?
20:55:06 <jrockway> yup
20:55:12 <ski> what if one `Foo a' computation is defined in terms of calling `runFoo' ?
20:55:20 <ski> (i.e. is it reentrant ?)
20:55:26 <kmc> mm, that's a good point
20:55:30 <kmc> i forgot that's another thing ST enforces
20:57:16 <jrockway> if only there were as many rank-n type tutorials as there were monad tutorials :)
20:58:02 <llayland> Then I'd never be able to get Rank-n types 
20:58:03 <jrockway> anyway, i think this is clear enough to me to be able to start coding (once we find the right version of gcc and a computer that can run it, long story)
20:58:06 <jrockway> haha
20:58:22 <jrockway> so next question, i am thinking of using reactive for this small project i'm working on
20:58:55 <jrockway> we have some way to subscribe to data feeds (tibco rv) and get updates whenever the things we subscribe to are updated
20:58:57 <kmc> jrockway, basically, i'm wondering if you can write your library such that the user never explicitly handles a namespace
20:59:02 <kmc> then it is trivially the case that they can't leak it
20:59:10 <jrockway> ok, that makes sense
20:59:21 <jrockway> there are some get/sets that users may want to do
20:59:35 <jrockway> (i never use the namespace because i already have variables, don't need another implementation...)
20:59:52 <jrockway> so anyway, the data updates seems like a natural fit for FRP
20:59:56 <jrockway> data changes, program reacts
21:00:03 <jrockway> something i want to do is measure the time between events
21:00:09 <jrockway> and i am not sure how to do that in a reactive way
21:04:35 <newsham> integrate and dump?
21:09:25 <llayland> jrockway, I just took a quick look at reactive. Does withPrevE not give you what you need?
21:10:24 <llayland> http://netsuperbrain.com/blog/posts/introducing-reactive-events/
21:10:34 <jrockway> hmm
21:10:57 <jrockway> (i think i need to actually play with this, but it involves more FFI and compiler games)
21:11:18 <jrockway> i like to have some concrete plan in mind before i waste the entire day with sysadmin tasks :)
21:12:26 <duckinator> ooh
21:12:56 <duckinator> llayland: thanks for linking to that, it may not be insanely hard to implement an emulator for the processor i'm making, after all :>
21:13:22 <duckinator> (in haskell, that is)
21:13:41 <jrockway> yeah, functional programming brings a lot of nice ways of avoiding the imperative world
21:13:44 <jrockway> and writing nicer code in the process
21:14:37 <duckinator> mhm
21:14:58 <Apocalisp> FP also brings a lot of nice ways of writing imperative programs
21:15:01 <duckinator> i actually designed an event-based language, i'm just not too good with interpreters/compilers so using said language is a ways off :(
21:15:14 <duckinator> i also haven't even named it... lol
21:15:21 <duckinator> http://gist.github.com/491719 if you're interested in it
21:15:44 <jrockway> clearly you should call it 491719
21:15:51 <duckinator> oh yes, of course ;)
21:15:57 <duckinator> best name EVER
21:16:03 <kmc> duckinator, cool.  Haskell is a great language for interpreters and compilers etc.
21:16:25 <llayland> Apocalisp, so very true.  
21:16:36 <duckinator> kmc: i figured it would be after poking around a bit, but i'm new to haskell, so i haven't really got into the swing of things yet
21:16:45 <duckinator> (..yet i've made a markov chain in it)
21:17:13 <Apocalisp> pretty good so far then
21:17:41 <duckinator> http://gist.github.com/513537 ... i think it's a pretty decent implementation of a markov chain
21:17:48 <duckinator> i should make a repo for all the random haskell things i have
21:18:11 <duckinator> since atm i have factorial, fibonacci, and markov chain implementations and that'll likely grow to more tiny things not really worth their own repos
21:18:27 <c_wraith> duckinator, you up for lame programming challenges? :)
21:18:35 <duckinator> sure :P
21:18:57 <duckinator> that mean you have some?
21:19:17 <c_wraith> implement Data.List.permutations yourself, in a few different ways.  One to maximize sharing, one to maximize speed. :)
21:19:26 <c_wraith> See if you can do both at the same time.
21:19:42 <c_wraith> And then see if you can do both while generating permutations in lexicographic order
21:20:06 <duckinator> hm. i don't even know what the heck list permutations are, so this should be fun \o/
21:20:16 <c_wraith> > permutations [1..3]
21:20:17 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
21:20:21 <duckinator> ahh
21:20:52 <duckinator> and what exactly do you mean 'to maximize sharing'?
21:21:07 <c_wraith> The resulting lists should share suffixes whenever possible.
21:21:33 <c_wraith> like...
21:21:53 <c_wraith> > let x = [1..5] in (0:x, 7:x)
21:21:54 <lambdabot>   ([0,1,2,3,4,5],[7,1,2,3,4,5])
21:22:12 <c_wraith> Both of those result lists share the same tail
21:22:30 <c_wraith> Because lists are immutable, there's no way to observe that
21:22:37 <duckinator> oh, so group them by the last item in the list?
21:22:38 <c_wraith> So you have to reason about how your algorithm is working, instead
21:23:09 <c_wraith> not necessarily.  Sharing doesn't determine the order.
21:23:31 <c_wraith> But the simplest permutation algorithm, in terms of being a couple of list comprehensions, has no sharing at all, which is why it's so slow
21:24:26 <c_wraith> generating permutations of immutable singly-linked lists is actually an interesting challenge.
21:24:43 <c_wraith> Like I said, I never did manage to find an algorithm that was both efficient, and gave a good result order
21:24:50 <c_wraith> Data.List chooses efficiency
21:25:43 <c_wraith> But it also uses a strangely complicated algorithm, that's slower than the best one I found.
21:30:40 <koninkje> c_wraith: is the best one you found posted anywhere?
21:31:03 <c_wraith> probably somewhere on hpaste.
21:31:12 <koninkje> or, have you considered submitting a patch to update Data.List?
21:31:19 <duckinator> hm
21:31:49 <duckinator> c_wraith: i can't understand out the algos i find (namely because they all resemble what's on wikipedia, which is...confusing to me :D) so i'm just gonna try to wing it and see how it goes :P
21:32:10 <duckinator> it'll likely be the most inefficient POS code you've seen, but hey it'll (hopefully) work ;)
21:32:22 <c_wraith> It's an interesting problem, if you've never done it before
21:32:25 <c_wraith> that's part of why I suggested it
21:33:01 <ski> c_wraith : ah, parsimonious `permutations', nice thing to ponder
21:33:23 <duckinator> wow, i just realized i've not really worked with lists too much in haskell xD
21:33:52 <int80_h> I'm so embarrased, but I have a C question and the C channel isn't very helpful. Any takers?
21:34:06 <duckinator> just to clarify, to get item foo of list bar, i use bar[foo], right?
21:34:17 <duckinator> int80_h: meh, i'm pretty good with C. go for it ;)
21:34:18 <ski> int80_h : read types from inside out
21:34:20 <arw_> int80_h: don't ask to ask.
21:34:26 <c_wraith> duckinator, I think you mean !!
21:34:31 <duckinator> huh?
21:34:33 <kmc> int80_h, i'll give it a shot; i'm also in #haskell-blah if you're worried about ot
21:34:37 <c_wraith> :t (!!)
21:34:38 <lambdabot> forall a. [a] -> Int -> a
21:35:06 <c_wraith> koninkje, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10415 is the algorithm I was using, though I don't remember ever writing it precisely that way.
21:35:15 <duckinator> c_wraith: i.. can't explain how little sense that made to me :(
21:35:16 <ski> @type genericIndex
21:35:17 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
21:35:18 <int80_h>  duckinator: I'd like to translate this into english. "lastPtrRef &((*lastPtrRef)->next);"
21:35:25 <int80_h> oops waitt!
21:35:31 <duckinator> int80_h: *brain twitch*
21:35:37 <ski> > [2,3,5,7,11,13,17,19] !! 5
21:35:39 <lambdabot>   13
21:35:41 <c_wraith> duckinator, Oh, I assumed you meant indexing into an array.
21:35:47 <int80_h>  duckinator: I'd like to translate this into english. "lastPtrRef=&((*lastPtrRef)->next);"
21:35:57 <duckinator> c_wraith: i did, but i didn't understand "[a] -> Int -> a" at all :D
21:36:08 <int80_h> yeah it's double pointers and my brain twitches too
21:36:18 <kmc> int80_h, assign to lastPtrRef the address of (*lastPtrRef)->next
21:36:21 <c_wraith> It means "it takes a list of something, an Int, and returns a something"
21:36:34 <duckinator> int80_h: do you just need to describe what it /does/? if so, what kmc said
21:36:35 <kmc> (*lastPtrRef)->next is the 'next' field of the struct pointed to by the pointer pointed to by lastPtrRef
21:36:43 <duckinator> c_wraith: ahh, ok
21:36:56 <duckinator> int80_h: i think you need some code refactoring, personally ;)
21:37:07 <duckinator> i write an os in my spare time, and it doesn't have code that looks like that... xD
21:37:13 <int80_h> duckinator : hey this is the way stanford teaches it!
21:37:15 <c_wraith> duckinator, and there's really only one particularly useful function with that type, which is indexing into the list. :)
21:37:16 <llayland> I could be mistaken, but I don't think you would index into a list like that in an efficient implementation
21:37:18 <kmc> so it's equivalent to:  lastPtrRef = (*lastPtrRef) + some offset
21:37:20 <int80_h> so it can't be wrong ;)
21:37:21 <duckinator> int80_h: oh my
21:37:38 <c_wraith> llayland, indexing is not part of an efficient implementation.  But let's worry about working before efficient :)
21:37:45 <int80_h> http://cslibrary.stanford.edu/
21:37:49 <int80_h> check it out ;)
21:38:06 <duckinator> llayland: yea i know it's not efficient, and idk if i'll even use indexing... i just thought i may use it so i asked ;)
21:39:13 <duckinator> note to self: when you replace your wifi card, set this one on fire so nobody is stuck using it again
21:39:28 <duckinator> yes, it really is that crappy
21:40:18 <newsham> no wonder #c doesnt want it.  you're doing c++ :)
21:40:39 <int80_h> newsham : am not!
21:40:59 <int80_h> my code compiles and runs as c, when I don't muck up the syntax.
21:41:02 <newsham> you sure?  "lastPtrRef &((*lastPtrRef)->next);"  looks like a c++ decl
21:41:05 <newsham> unless you typo'd
21:41:17 <duckinator> newsham: check his next line, he meant an = not a space :P
21:41:17 <int80_h> newsham I did..meant to be this 
21:41:23 <newsham> oh heh
21:41:24 <int80_h> that's right ^^^
21:41:28 <int80_h> what he said
21:41:38 <duckinator> also, C++ decls shouldn't be that ugly
21:41:46 <koninkje> int80_h: The (*...)->... looks dubious. Do you mean to be double dereferencing?
21:41:46 <newsham> yah my bad on the decl.
21:41:50 <duckinator> if you write any that are, you should stop programming until further notice
21:42:01 <newsham> koninkje: he does.  thats why it says "lastPtrRef" not "lastPtr"
21:42:10 * koninkje nods
21:42:10 <kmc> it makes sense to me.  it's a linked list
21:42:12 <int80_h> yup yup
21:42:12 <newsham> he's keeping around a pointer to a pointer
21:42:18 <kmc> it's a double deref plus an address-of
21:42:26 <duckinator> an overlycomplex linked list, but yes... :D
21:42:31 <kmc> the net result is a single-deref, moving through the list by one element
21:42:36 <duckinator> boo, broken hyphen key
21:43:05 * duckinator throws a broken hyphen key at int80_h, as punishment for keeping a pointer to a pointer
21:43:07 <kmc> duckinator, the complexity gives you a "lag" of one step in the "next" pointer, without an additional variable
21:43:11 <newsham> duckinator: a stanford linked list ;-)
21:43:13 <kmc> thus simplifying removal
21:43:19 <kmc> that's my guess without thinking about it in depth
21:43:34 <int80_h> the odf I am using says this is not good for production code, but I am using it because the function prototype will then fit my other function prototytpes. Then I can use an array of function pointers. Which is the whole point of this demo I am writing. I wonder if I have put C on my resume if this is so challenging.
21:43:42 <int80_h> s/odf/pdf
21:43:44 <newsham> kmc: *nod*  I'd keep the double pointer to the remove case and keep the rest simpler
21:43:56 <int80_h> erm *should have.
21:44:46 <c_wraith> int80_h, maybe not.  Manual pointer mangling is something C programmers are expected to be practiced at.
21:45:09 <duckinator> mangling and molestation are different things
21:45:14 <kmc> hehe
21:45:20 <kmc> it's still a difficult task
21:45:38 <kmc> writing complicated low-level C code which works flawlessly despite zero safety guarantees
21:45:40 <llayland> Is there a nice way to write this  foo . (\x -> [x])   - I'd like to say foo . ([]) but that is not valid
21:45:55 <int80_h> Oh I am not being hired to be a C programmer. But they want to see code samples. So I figured I should give them C, and haskell. Haskell is far less painful. Only because I'm with it night and day for the last month.
21:46:05 <kmc> you should not expect to proceed at the same rate of lines / hour that you would writing, say, Java apps
21:46:17 <koninkje> llayland: (:[])
21:46:18 <kmc> llayland, foo . (:[])
21:46:21 <kmc> :t (:[])
21:46:22 <lambdabot> forall a. a -> [a]
21:46:28 <duckinator> kmc: i manage it daily, i'm into the osdev hobby...apparently that means i like pain, but i've found it to be rather easy if you read up a bit :P
21:46:42 <newsham> llayland: foo . return
21:46:45 <kmc> llayland, also "return" and "pure" are equivalent to \x -> [x], but more general
21:46:49 <int80_h> plus I already have some nifty haskell samples I am proud of. The graham scan exercise from RWH.
21:46:50 <koninkje> newsham++
21:46:51 <c_wraith> I don't deny that writing correct C code is quite a challenge.
21:47:05 <luite> you should only add C if you can write a red-black tree implementation that works flawlessly the first time you try it ;)
21:47:09 <newsham> ?karma newsham
21:47:09 <lambdabot> You have a karma of 1
21:47:10 <duckinator> c_wraith: i am the only one that denies that? :<
21:47:11 <newsham> up to one!
21:47:17 <llayland> oh, that should have been obvious.  thanks
21:47:27 <int80_h> ?karma int80_h
21:47:28 <lambdabot> You have a karma of 0
21:47:31 * int80_h sobs
21:47:36 <duckinator> int80_h--
21:47:37 <int80_h> could be worse
21:47:37 * duckinator hides
21:48:40 <duckinator> int80_h: you can just pretend that's an unsigned integer, alright? ;)
21:48:51 * int80_h faints
21:48:56 * int80_h protests.
21:49:33 <JoeyA> *** Exception: Cannot protest while unconscious
21:51:04 <newsham> "dereference the pointer ref, use it to access the next pointer and store the address of that pointer in the pointer ref"
21:51:08 <newsham> does that work for you, int80?
21:51:27 <int80_h> that works!
21:51:51 * duckinator hands int80_h some pretty i386 memory management code and wanders off to attempt to write a permutation function... http://github.com/RockerMONO/dux/blob/master/src/metodo/hal/i386/mm/memory.c
21:52:16 <int80_h> can it be pretty and i386 at the same time?
21:52:16 <duckinator> btw that was sarcastic
21:52:20 <duckinator> ^^
21:52:33 <duckinator> int80_h: the simpler parts are actually very nice looking code :>
21:52:44 <duckinator> mm, not so much. you can never make x86 mm code look nice
21:53:48 <duckinator> int80_h: for instance, my amazingly simple roundrobin scheduler which does not quite work: http://github.com/RockerMONO/dux/blob/master/src/metodo/core/scheduler.c .. i think that's rather nice :>
21:54:25 <int80_h> what I think is *sad* is that I have to come here to get help with C. But I'
21:54:34 <int80_h> but I'm glad I could. :)
21:54:35 <duckinator> that is sad ^^
21:54:48 <int80_h> as opposed to the C channel.
21:54:51 <duckinator> hmmm
21:54:58 <int80_h> they are debating the ethics of book piracy right now.
21:55:08 * duckinator gets a slice of pizza, and then considers actually starting his permutation function...
21:55:13 <duckinator> int80_h: tell them to debate their IQs instead
21:55:30 <ulfdoz> permutating the RR until it happens to work.
21:56:10 <newsham> IRC is not always a great place for questions. :)
21:57:08 <koninkje> after far too much Java hacking, I actually kinda miss the simplicity of C
21:57:18 <djahandarie> I've never actually used the Haskell mailing lists
21:57:31 <newsham> "yay, pointers!  aww, crap, malloc/free!"
21:57:41 <JoeyA> yay, libgc!
21:57:46 <int80_h> newsham: this channel must be the exception. I always find people here accessible and friendly
21:57:58 <JoeyA> aww crap, it almost never shrinks process memory usage
21:58:12 <JoeyA> yay, Haskell!
21:58:35 <koninkje> yay haskell, indeed. 
21:58:36 <newsham> int80: this channel is exceptional in many ways.  appreciate it and try to pass on its spirit.
21:58:51 <koninkje> of course, GHC never shrinks process mem usage either IIRC
21:59:38 <duckinator> mmmm pizza :>
21:59:56 <JoeyA> :let it be = let it be
22:00:05 <JoeyA> @let it be = let it be
22:00:06 <lambdabot>   Parse error: VRightCurly
22:00:20 <duckinator> O.o?
22:00:41 <JoeyA> @let it = be
22:00:42 <lambdabot>  Defined.
22:07:52 <dons> koninkje: false! http://hackage.haskell.org/trac/ghc/ticket/698#comment:38 
22:07:53 <dons> :D
22:08:32 <koninkje> :D
22:09:45 <koninkje> So I have an obscure design question...
22:10:10 <koninkje> Let's say we're developing FFI bindings to a C library, where the C library is known not to be thread-safe
22:10:41 <koninkje> Is there a good monad for *ensuring* that we do not accidentally do multithreaded access?
22:10:42 <dons> right. that's common
22:10:58 <dons> hmm. i don't think so. but wrapping the ffi calls in an MVar is the usual approach
22:11:13 <dons> e.g. MVar (ForeignPtr a) or else MVar ()
22:11:19 <dons> so they have to take the lock before each ffi call
22:11:23 <koninkje> hmm. I was hoping some of the regions folks might've come up with something nice
22:11:31 <dons> you could monadize it surely, though.
22:11:41 <koninkje> MVar will have to do for now
22:12:40 <koninkje> So the FFI work is basically done unsafely as IO or pure, and then a nice API is put on top of that?
22:14:10 <copumpkin> wow, GHC returns memory to the OS now
22:14:25 <dons> koninkje: right.
22:14:27 <copumpkin> I wonder what heuristics it uses to decide when to do that
22:14:30 <dons> well, not pure if it is unsafe.
22:14:40 <koninkje> sure
22:17:54 <jrockway> copumpkin: glibc's malloc has done this for a while on linux
22:19:04 <duckinator> jrockway: wouldn't GHC's GC be what decides when to call malloc/free, though?
22:24:36 <int80_h> lispy: hi :)
22:26:04 <jrockway> yes
22:26:25 <jrockway> i feel there must have been some change to the linux kernel to make this easier to do, because everyone started doing this all at once :)
22:28:06 <duckinator> jrockway: from what i understand, it was something with GHC's GC, since (from what i see on the page there) it wasn't specific to linux
22:29:44 <jrockway> hmm, interesting
22:50:21 <int80_h> @seen lispy
22:50:21 <lambdabot> Unknown command, try @list
22:50:21 <preflex>  lispy was last seen on #haskell 7 hours, 12 minutes and 3 seconds ago, saying: :t (>=>)
22:50:42 <int80_h> I'm sure he signed on just now
22:51:04 <carter> i made a very cool discovery about how to build haskell cabal packages on resource constrained linux box
22:51:33 <carter> at least i think i did
22:53:24 <carter> namely that having the gold linker rather than the old school gcc as the linker makes sufficiently meaningful difference in memusage to the point that the process completes rather than being killed by the os 
22:56:09 <kmc> that's cool carter :)
22:56:19 <carter> thanks kmc
22:56:40 <carter> the context is getting haskelly stuff running on a 512mb ubuntu 10.4 vps
22:58:20 <carter> my main dev machine is a mac, so i can't more directly evaluate if ghc becomes that much less hungry with the gold linker or if it was just that the rest of the mem on the box wasn't utitlized so i just happened to be trying often enough
22:59:08 <carter> but I'm going to pretend that for now gold linker = things are nicer for folks who aren't linux kernel hackers
23:02:20 <carter> that being said, getting gitit to build can be a pain
