00:01:58 <bss03> > let 1 + 1 = 3 in 1 + 1
00:01:59 <lambdabot>   3
00:02:17 <bss03> Sometimes, 1 + 1 DOES = 3.
00:14:37 <maurer_> Say I need to parse a language that has both // and # as one line comments. Is the right way to do this to patch parsec to take a Parser rather than a String there?
00:14:49 <maurer_> It's only a 2 line patch, but I assume there's a reason it's not done?
00:20:00 <Axman6> why would you need to patch parsec to do that? o.O
00:20:33 <Saizan> i think he's referring to the LanguageDef thing?
00:23:59 <maurer_> Saizan: Yes.
00:24:39 <maurer_> It uses a String there, but it would work if I did
00:24:39 <maurer_> -        do{ try (string (commentLine languageDef))
00:24:39 <maurer_> +       do{ try (commentLine languageDef)
00:24:44 <maurer_> And changed the typesignature
00:28:48 <Saizan> it seems fine
00:29:07 <maurer_> Saizan: ?
00:29:54 <maurer_> Saizan: Are you saying that patching it would be the "right way", or are you suggesting there's a good way to do two different symbols for line comments in parsec as it stands?
00:31:09 <Saizan> the former
00:31:43 <Saizan> though i've seen now the definition of whiteSpace
00:32:09 <maurer_> It seems to me that the only change this would require of other packages is the insertion of the word "string" in their languagedefs
00:32:14 <maurer_> Which doesn't sound too difficult for them.
00:50:21 <ivanm> preflex: seen gwern
00:50:22 <preflex>  gwern was last seen on #haskell 5 days, 17 hours, 15 minutes and 3 seconds ago, saying: or 0 * _ = 0, rather
00:51:58 <cch> help! I with problem using Network.Download. got error in ghci as follows: Loading package syb-0.1.0.2 ... linking ... <interactive>: /home/cch/.cabal/lib/download-0.3/ghc-6.12.3/HSdownload-0.3.o: unknown symbol `stat64'
00:51:59 <cch>  
00:52:18 <cch> somebody may help me
00:52:25 <Veinor> yeah, that's a known issue
00:52:34 <Veinor> no clue why it happens
00:59:57 <cch> :Veinor, are you answering me ? 
01:02:31 <ivanm> anyone know how much of QC's API has changed for 2.2?
01:07:55 <maurer_> Wow, now that I try to use parsec for stuff beyond toys it begins to show its flaws.
01:08:11 <maurer_> buildExpressionParser fails to produce the ability to have multiple pre/post operators
01:08:30 <ivanm> maybe you're just using it wrong?
01:08:40 <maurer_> ivanm: I suppose that's possible.
01:09:19 <maurer_> However, they only call the prefix parser once, in the term parser, and that parser is nonrecursive.
01:10:07 <Peaker> I got "Haskell School of Expression" -- wondering if it would be a good book for running a student course (one of the courses I was pointed to used it).. reading it - it seems to have some flaws already in the beginning (forward references to things not taught yet, etc)
01:10:08 <ivanm> ummm, my understanding is that that's what it's meant to do
01:10:21 <ivanm> Peaker: yeah, it's rather old
01:10:48 <ivanm> the most up-to-date book is Hutton's Programming in Haskell, but it uses pretty latex symbols in the code listings, which can get annoying
01:10:57 <ivanm> (IIRC, dcoutts did a review on it for TMR)
01:11:20 <Peaker> SoE also uses a bit of that, but there's a comment next to first appearance "you'd have to write -> and not pretty arrow"
01:11:40 <c_wraith> I don't like that.
01:11:46 <c_wraith> It makes the code just harder to read.
01:11:51 <c_wraith> Why would you do that?
01:12:08 <Peaker> I also dislike it, but lots of LaTeX geeks like it :)
01:12:55 <ville> makes it look  more like math? gives you more symbols to use as variable names? 
01:12:56 <ivanm> I don't like it
01:13:02 <ivanm> and I like LaTeX!
01:13:03 <c_wraith> I'd really think readability should trump fancy symbols.
01:13:17 <ville> To some it is more readable.
01:13:19 <c_wraith> make the code look like code.
01:13:20 <ivanm> ville: it uses actual lambda characters, joins together ++, etc.
01:13:34 <ivanm> it looks more maths-y, but it's harder to read _as code_
01:13:34 <c_wraith> Don't make it look entirely different from code.
01:14:47 <ville> I know at times when programming in this other language I would welcome all the greek alphabet as valid symbols for variable names for example.
01:15:30 <ivanm> you can use them for variables, that's not a problem
01:15:44 <ville> Particular when the algorithms deal with math or physics equations.
01:15:47 <ivanm> the problem is changing the reserved symbols in the actual code to make them look pretty rather than being syntactically valid code
01:17:00 <c_wraith> I also really dislike using exceptionally flowery math fonts that are plain hard to read.  Which happens a lot, for some reason.
01:18:02 <Saizan> those are generally used as a form of namespace mechanism
01:18:17 <Entroacceptor> some programs change the fonts, too
01:18:38 <c_wraith> But why do they pick unreadable scripty fonts for code?  I don't code in cursive!
01:19:02 <Peaker> I'm a Cafe moderator now? A Cafe spam check msg was sent to me as if I was...
01:19:09 <Peaker> or is this some spam technique?
01:19:35 <Saizan> not sure, i've a paper by hinze right here that uses gothic for data constructors :)
01:20:15 <ivanm> Peaker: huh, interesting; sure it ish't a phishing attempt or something?
01:20:28 <ivanm> after all, the haskell-cafe subscription list is hot property... :p
01:21:22 <chrisdone> so I noticed my λ> Segmentation fault in GHCi is triggered when I'm using the :! syntax
01:21:29 <Peaker> ivanm: no idea
01:21:31 <chrisdone> maybe that feature is a bit buggy
01:21:47 <ivanm> chrisdone: what were you executing?
01:21:51 <ivanm> I've never had a problem...
01:21:52 <chrisdone> I have a C-c C-c shortcut in Emacs to send 'cabal build' through :!
01:22:03 <chrisdone> I use it more or less as often as I use C-c C-l
01:22:24 <ivanm> doesn't C-c C-c kill the running process?
01:22:38 <ivanm> or is this C-c C-c in the .hs buffer rather than the ghci buffer?
01:22:43 <chrisdone> in the haskell-mode buffer
01:22:47 <ivanm> aha
01:26:50 * hackagebot bio 0.4.7 - A bioinformatics library  http://hackage.haskell.org/package/bio-0.4.7 (KetilMalde)
01:27:55 <ivanm> I forget, is Joachim Fasting on IRC?
01:28:27 <Saizan> damn, why texts on any kind of unification ends up in a twisted maze of definitions all alike?
01:31:16 <fasta> Saizan, first-order unification is like 6 lines, or so, right? 
01:32:07 <ivanm> OK, wtf? yi depends on QuickCheck even if I build with --flags=-testing ?
01:32:38 <ivanm> wait, that could be a bug in the ebuild...
01:36:20 <chrisdone> Saizan: SICP manages an explanation of unification really nicely
01:36:31 <chrisdone> it just slipped into my brain like a lizard
01:42:49 <chrisdone> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.2
01:43:26 <atude> I need a good book to use for mastering algebra for calculus
01:43:34 <atude> are there any recomendations?
01:43:37 <ivanm> atude: practice
01:43:50 <atude> sure there is that but I need a good book to refer to
01:44:11 <chrisdone> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_idx_5206
01:44:16 <atude> something with useful examples and stuff
01:44:38 <ivanm> is this for a course?
01:45:06 <atude> no
01:45:21 <atude> I just want to understand algorithms much better
01:46:09 <atude> and a much more practical book to learn set notation and algebraic expression, binomials etc would be very very useful
01:46:32 <atude> not just some old english style textbook that tells you whateverything is, assuming you know exactly what they're talking about
01:46:40 <atude> just something right to the point with useful examples 
01:47:13 <atude> but of course, not skipping everything that you should know
01:47:54 <ivanm> hmmm....
01:47:55 <luite> atude: if your main goal is to understand algorithms, you might try "concrete mathematics" by graham, knuth and patashnik
01:48:05 <atude> actually, I just ordered that
01:48:06 <atude> o_O
01:48:08 <luite> ok
01:48:10 <ivanm> haven't really looked at an algebraic text recently
01:48:18 <ivanm> Kreyszig maybe?
01:48:19 <atude> I guess so far, i'm on the right track
01:48:20 <atude> :o
01:48:25 <ivanm> but it might be more advanced than what you want
01:48:46 <atude> as long as it give explanation, it should be okay
01:49:13 <atude> luite: does this get into category theory and stuff too? :)
01:49:31 <atude> maybe ring theory and its ideals
01:49:32 <atude> :o
01:50:50 <luite> oh you meant abstract algebra? you might try dummit & foote then, it's quite readable and has lots of doable exercises, I don't think it has much category theory though
01:51:30 <ivanm> ring theory is more number theory than algebra, isn't it?
01:51:58 <atude> well I want both really.. I can solve equations and know my way around functions and binomials but when it comes to reading stuff from my algorithms book (cormen), I get confused
01:52:12 <atude> that or it bombards me with too much irrelivant info
01:52:28 <Saizan> fasta: the algorithm is trivial, but all the theory about unifiers feels like a lot of boilerplate, but i guess i've to navigate through it if i want to realize what the state of the art is wrt decidability of more complex unification problems
01:52:41 * ivanm finds cormen rather vague and unhelpful in the algorithms, etc. it describes
01:52:56 <fasta> ivanm, you do?
01:53:03 <luite> I have the CLRS book, but I have to admit that I never read more than a few pages of it
01:53:18 <fasta> ivanm, I read it from start to end, I think it was clear. 
01:53:32 <fasta> Also not so buggy as most papers are. 
01:53:44 <jpcooper> hello
01:53:45 <ivanm> well, I'm doing a course that uses it
01:54:13 <jpcooper> does anyone know where I can download Haskell for Windows in archive format rather than as an installer? I'm not able to run installers on this computer
01:54:23 <ivanm> and for an assignment I wanted a full explanation for something (forget what exactly, but it was somethign about dealing with big-O notation) and it just skimmed over it
01:54:35 <ivanm> same with using O-notation for summations
01:54:46 <fasta> ivanm, the definition is extremely solid in CLRS. 
01:54:53 <ivanm> jpcooper: well, you won't be able to register it, etc. then so it might not work
01:55:04 <fasta> I think it's like chapter 3 which talks about that? 
01:55:05 <ivanm> I don't think there's a stand-alone/portable version of GHC
01:55:10 <atude> ivanm: that is one concept I'm having trouble to understand
01:55:23 <ivanm> fasta: right, but I wanted mroe specific examples of dealing, using and manipulating them
01:55:23 <atude> big O and theta
01:55:33 <ivanm> oh, the concept is rather easy and I get it
01:55:33 <jpcooper> ivanm: register it?
01:55:42 <atude> ivanm: can you explain?
01:55:43 <ivanm> jpcooper: with the windows registry, etc.
01:55:46 <fasta> ivanm, there is an exercise where you have to order about 25 functions. 
01:55:50 <jpcooper> oh, wonderful
01:56:10 <fasta> ivanm, (by 'size')
01:56:12 <ivanm> fasta: what the correct semantics of simplifying an O(f(n)) function is
01:56:36 <fasta> ivanm, simplification operations are listed in a table, I think.
01:56:48 <fasta> ivanm, but first you learn to do it without them.
01:56:49 <ivanm> not that I recall...
01:57:03 <fasta> I mean, it is basic mathematics with limits. 
01:57:10 <ivanm> I knew what the simplication was; I just wasn't sure how formal to make it
01:58:00 <fasta> Any normal CS program starts with some mathematics courses, such that those CLRS sections become trivial.
01:58:26 <dobblego> @hoogle ask
01:58:26 <lambdabot> Control.Monad.Reader.Class ask :: MonadReader r m => m r
01:58:26 <lambdabot> Control.Monad.Reader.Class asks :: MonadReader r m => (r -> a) -> m a
01:58:26 <lambdabot> Foreign.Ptr freeHaskellFunPtr :: FunPtr a -> IO ()
01:58:38 <fasta> Or maybe I am generalizing, but AFAIK, you need that for accreditation. 
01:59:08 <luite> jpcooper: have you tried extracting the installer manually?
01:59:18 <ivanm> fasta: I've done a math degree ;-)
01:59:30 <jpcooper> luite: no. I don't know about that. Could you give me a tip?
01:59:37 <ivanm> but CLRS is lacking in fully worked out examples
01:59:51 <luite> jpcooper: you can use 7zip to extract all files from the installer
01:59:52 <fasta> ivanm, you can get the instructors manual.
02:00:20 <jpcooper> luite: I wonder whether 7zip comes in archive form :)
02:00:20 <fasta> ivanm, if you are an instructor obviously ;)
02:00:28 <luite> jpcooper: you'll get all the normal directories for the platform installation, and a $PLUGINSDIR, which you can remove
02:00:30 <ivanm> heh
02:00:41 <jpcooper> thanks
02:00:51 <ivanm> fasta: that's the thing, I did a math degree and so I'm used to more rigour than what CLRS has :p
02:01:02 <ivanm> and I wasn't sure how formal to make my proof because the text didn't have an example
02:01:06 <luite> jpcooper: it has a command line version in a .zip archive :)
02:01:14 <ivanm> (not that it really matters since I'm just "auditing" the course as a PhD student)
02:01:15 <jpcooper> yeah I just saw that
02:01:58 <fasta> ivanm, the rules are the same as the rules for limits. 
02:02:44 <fasta> ivanm, you can perfectly well build a formal system with all the rules of the game, but your proofs will become a few moon distances long, if you do it completely formally. 
02:02:46 <ivanm> fasta: well, not quite; with O-notation you just tend to assume that n is even rather than using floor/ceiling; technically saying f(n) = O(g(n)) doesn't make sense, etc.
02:02:59 <fasta> ivanm, it does make sense. 
02:03:05 <ivanm> oh, I agree
02:03:08 <fasta> ivanm, since it is notation. 
02:03:20 <fasta> ivanm, it might be crazy notation, but that's a different story.
02:03:33 <ivanm> well, technically O(g(n)) is a class of functions, so it should be f(n) \in O(g(n))
02:03:59 <fasta> ivanm, any book can make up their own notation (which they didn't do). 
02:04:29 <ivanm> but I had to simplify something like O(n^3 log(log(n)) + n^2 (log n)^2 + 7), and I wans't sure how formal my proof had to be (can I just find the O-notation for the stuff inside the brackets, or did I have to do something else, etc.)
02:05:08 <ivanm> fasta: IIRC they do use _some_ custom notation/definitions (at least according to the lecturer): normally O(.) is defined wrt |f(n)| but CLRS don't bother with the absolutes
02:07:21 <fasta> ivanm, I think they introduce it as the running time and memory usage and other physical properties. Such things cannot be negative. 
02:07:33 <ivanm> hmmm, maybe
02:07:41 <fasta> ivanm, anyway, it hasn't bothered me, but then again you are a mathematician ;)
02:07:56 <ivanm> yup ;-)
02:08:00 <ivanm> (stuck in CS)
02:08:08 <luite> is that bad?
02:08:25 <orbital_fox> hello luite
02:08:32 <luite> hi orbital_fox
02:08:37 <orbital_fox> and CS can be bad (Assuming its Computer Science)
02:08:58 <Ke> command streams are nasty too
02:10:14 <Ke> @faq can haskell autogenerate a proper command stream validator for linux
02:10:14 <lambdabot> The answer is: Yes! Haskell can do that.
02:13:57 <luite> jpcooper: did it work?
02:14:10 <jpcooper> luite: I haven't tried it yet. I'll get back to you
02:20:24 <fasta> ivanm, I am pretty sure you can do whatever you want, if you have the motivation to do so. 
02:20:55 <ivanm> fasta: I'm going graph generation for my PhD, but my supervisor is in CS
02:21:01 <ivanm> I consider myself more of a mathematician though
02:21:06 <orbital_fox> whats the impression of Helium here (the haskell implementation?)
02:21:34 <fasta> orbital_fox, I doubt it completely implements Haskell 98.
02:21:49 <fasta> orbital_fox, otherwise, quite nice for development. 
02:22:02 <fasta> orbital_fox, that is, until you can read ghc error messages.
02:22:50 <orbital_fox> ow and luite is the intermediate language ghc makes called C-->
02:22:51 <orbital_fox> ?
02:23:36 <luite> Cmm, it's based on or inspired by C--, but not the same
02:24:05 <luite> it's one of the intermediate languages though, not "the" intermediate language
02:24:13 <orbital_fox> k
02:24:22 <fasta> I wonder whether all these intermediate languages are actually useful. 
02:24:42 <fasta> I know there has been a trend to build compilers like this, but that doesn't mean it's a good thing. 
02:24:58 <fasta> It only makes your compiler slower from a pure performance point of view.
02:25:10 <Jafet> Well, it's easy to reason about
02:25:18 <Jafet> Thus good for maintenance
02:25:41 <fasta> Yes, but knowing 50 intermediate languages is kind of hard on your memory. 
02:26:15 <Jafet> Yeah, you don't use 50 intermediate languages if you're going to be the only person working on the compiler
02:26:17 <orbital_fox> i agree fasta
02:26:23 <orbital_fox> LLVM might be our saviour :P
02:26:41 <luite> orbital_fox: if the LLVM backend is used, GHC still produces Core and Cmm
02:27:11 <orbital_fox> but if a haskell frontend was made :)
02:27:19 <orbital_fox> (for LLVM)
02:27:27 <luite> where Core is a "functional intermediate language" and Cmm an imperative one (after transforming to STG)
02:31:59 <orbital_fox> im really keen on haskell, liking it more and more.. but i need to find a way to tie it with my C++ code
02:32:07 <orbital_fox> make it a frontend for it
02:32:32 <maurer_> orbital_fox: Are you trying to call haskell from C, or vice versa?
02:32:34 <orbital_fox> there must a be way haskell can load libraries generated by C++ code, and vice versa
02:32:44 <maurer_> Both can be done, but it's substantially easier to load C from haskell
02:32:51 <luite> orbital_fox: there is, but it's way easier to use C
02:33:11 <luite> especially if you want to be able to use ghic
02:33:12 <luite> ghci
02:33:13 <orbital_fox> maurer_, havent tried it yet, but id like C++, i really like the language and all of my code is in C++ now
02:33:59 <maurer_> orbital_fox: It'll still work, you just won't get to pull in objects unless you write translation code for each object.
02:34:27 <maurer_> orbital_fox: The FFI essentially works by just setting up the stack, making a raw ABI call into whatever you're targeting, and then packing that back up into a haskell accessible value.
02:35:01 <maurer_> Aside from that, you don't actually want C++, you just think you do :P
02:35:32 <orbital_fox> hahah
02:35:35 <orbital_fox> C++ is awesome
02:35:45 <Starfire> C++ has awesome compilation times.
02:36:01 <orbital_fox> for years the have tried to make something better and they have just made abominations ... C#, Java.. eww
02:36:39 <orbital_fox> maurer_, ill sort something out.. i might even and up going a long way to achieve it :P
02:36:45 <luite> I should still rewrite some part of my program to remove all dependencies on C++ code :(
02:37:27 <maurer_> orbital_fox: My assertion was that that we needed more, like in C# and Java, but that we need less.
02:37:34 <Starfire> Having automatic marshalling for simple C objects would be quite nice.
02:37:54 <maurer_> orbital_fox: C++ is what happens when you take a close to machine language and try to turn it into a high level language. It just shoots you.
02:38:17 <maurer_> Starfire: How do you propose that be done given that the FFI is designed to work without source code access?
02:40:01 <orbital_fox> maurer_, you shouldnt see C++ as a high level language thats the trick :P
02:40:09 <luite> I have a relatively slow function that gets called really often with the same arguments. is there an hackage package to make it cache the results in a lru cache or something?
02:40:22 <orbital_fox> C with more automation and better syntactics
02:40:26 <orbital_fox> syntax*
02:40:48 <maurer_> orbital_fox: If you're not using the high level features, what are you using? (That would require you to throw out classes and templating.)
02:41:14 <maurer_> luite: Look up memocombinators
02:41:38 <orbital_fox> maurer_, i dont use templates no
02:41:39 <maurer_> Not lru, (so it will grow memory over time) but you could either use it, or modify it.
02:41:49 <orbital_fox> unless it really really _really_ makes my life easier
02:41:58 <luite> maurer_: I don't think that would work in this case
02:42:00 <orbital_fox> and i use classes to protect my memory
02:42:32 <luite> maurer_: memcombinators is very useful for computing things with recursive definitions, but all my function calls are independent
02:42:38 <maurer_> orbital_fox: Protect it from what? Classes don't actually give any memory protection, they just do the equivalent of not exporting the location of a symbol.
02:43:17 <orbital_fox> maurer_, classes protect memory if they are written properly, in future use of your code
02:43:25 <luite> maurer_: and it's also not modifyable at all, it uses let bindings to remember values, those are not replacable by a lru cache
02:43:56 <maurer_> luite: Trure.
02:43:58 <maurer_> *True
02:44:31 <maurer_> orbital_fox: No, they don't. I can still dereference into the middle of your class all I want. As far as future use, not exporting the symbol accomplishes the same thing.
02:44:33 <orbital_fox> if you write the constructors properly, privatise memory and provide nice methods :)
02:45:32 <ehamberg> gah, “cabal: dependencies conflict: hslogger-1.0.8 requires time ==1.1.2.4 however time-1.1.2.4 was excluded because happstack-data-0.5.0.2 requires time >=1.1.4”. can i fix this? (trying to install gitit on a clean system.)
02:45:52 <ehamberg> i already found out that i have to use “cabal install gitit --constraint='datetime==0.1'” to avoid a quickcheck 1 vs 2 conflict.
02:46:10 <ehamberg> (trying to install gitit on a clean system.)
02:49:39 <orbital_fox> maurer_, as i said, its just a little better C, but its still a language for big responsible boys :)
03:05:00 <luite> maurer_: I made one with unsafePerformIO and the lrucache package now. not very pretty (but I guess you need unsafePerformIO anyway), but it works (at least hopefully, I still need to test it)
03:06:08 <jpcooper> luite: how should I extract the setup file? It's not an MSI.
03:07:00 <luite> jpcooper: 7zip can extract exe setup archives
03:07:03 <luite> at least in some formats
03:07:25 <jpcooper> I tried using the x argument on the file, and it didn't work
03:07:43 <jpcooper> "Can not open file as archive"
03:07:58 <luite> hmm, I use the gui version, and I just right clicked on the file, and then "extract to..."
03:08:01 <luite> which just worked
03:08:20 <shachaf> luite: The GUI version is rather different from the CLI versio.
03:08:26 <luite> apparently :)
03:08:54 <jpcooper> oh well
03:09:07 <jpcooper> I suppose I'm stuck with Mathematica here :)
03:12:34 <Saizan> ehamberg: i can't find hslogget-1.0.8 on hackage
03:13:02 <luite> jpcooper: did you see my private message?
03:13:22 <Saizan> ehamberg: anyhow, maybe cabal update? cabal install --dry-run -v gitit finds a installation plan with no problems here, which version of ghc are you using?
03:16:00 <jpcooper> luite: yes, sorry. I was away
03:21:13 <Starfire> maurer_: I mean, like with a library that uses Template Haskell.
03:21:53 <maurer_> No, I mean without source code access to the C file...
03:22:30 <Starfire> Of course you'd probably need the headers.
03:24:14 <ehamberg> Saizan: 6.10.4
03:29:02 <Saizan> ehamberg: it works fine on a fresh install of 6.10.4 too here
03:34:16 <ehamberg> Saizan: strange. here's what i see: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29608
03:35:54 <Saizan> ehamberg: cabal --version ?
03:36:36 <Saizan> ehamberg: also, it's more important to rm -fr .ghc
03:37:36 <ehamberg> d'oh! had the admin remove debian packages for time. now it seems to work.
03:37:44 <ehamberg> gah.
03:37:45 * hackagebot QuickCheck 2.3 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.3 (NickSmallbone)
04:00:40 <dabblego> @type \p -> foldr (\a -> liftA2 (\t u -> if t then a:u else u) (p a)) (pure [])
04:00:40 <lambdabot> forall a (f :: * -> *). (Applicative f) => (a -> f Bool) -> [a] -> f [a]
04:26:48 <Schalken> What's the difference between a string ByteString and a UArray Integer Word8? Are not both represented in memory as a contiguous block of Word8s?
04:27:12 <Schalken> a /strict/ ByteString*
04:31:54 <Starfire> Schalken: I'd guess that there are more pre-defined useful functions for ByteStrings.
04:31:58 <opqdonut> a strict bytestring is a linked list of blocks of word8s
04:32:01 <opqdonut> AFAIK
04:32:19 <opqdonut> so you can have reasonable performance for splitting and joining them
04:33:29 <Schalken> Starfire: What would have been wrong with simply saying type ByteString = UArray Integer Word8, and then defining functions on ByteString that way?
04:34:11 <Schalken> opqdonut: I thought that was lazy ByteStrings, but if not my question would be what's the difference between a ByteString and [UArray Integer Word8] :P.
04:34:31 <dons> bytestrings are interoperable with C, primarily. They can be converted to pinned pointers.
04:35:32 <Schalken> dons: Is that like Data.Array.Storable?
04:40:49 <dons> somewhat, yes. in principle.
04:47:08 <Schalken> dons: Thanks.
04:55:31 <lispy> dons: ping
04:56:09 <lispy> dons: I just sent you an email with a substantial boost to a shootout entry.  Do you think they'll accept a change like that?
04:57:12 <lispy> dons: if my machine is representative of their machines then it will be the fastest entry for that benchmark :)
05:18:07 <fasta> lispy, which benchmark and what code?
05:31:32 <baaba> is there something like counts :: (Eq a, Num b) => [a] -> [(a, b)] in the ghc libraries, for example counts "aaabbc" = [('a', 3), ('b', 2), ('c', 1)]
05:31:46 <copumpkin> nope
05:32:27 <aristid> :t map (head &&& length) . group . sort
05:32:28 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
05:32:43 <aristid> baaba: how about that?
05:32:50 <lispy> fasta: https://alioth.debian.org/tracker/index.php?func=detail&aid=312688&group_id=30402&atid=413100
05:32:51 <baaba> oh, clever :)
05:32:53 <baaba> thanks
05:33:19 * Jafet waits for the nubBy version
05:33:25 <aristid> what's the complexity of ghc's default sort?
05:33:30 <Jafet> Mergesort
05:33:49 <aristid> O(n * log n) then
05:35:52 <aristid> wtf, back in 2002, ghc used quicksort
05:36:24 <Philonous> aristid: How would that work? quicksort requires random access to the data structure
05:36:50 <aristid> Philonous: well, the function comments say it's "quicksort", which it probably isn't
05:37:17 <Jafet> Why do you need random access for quicksort?
05:37:25 <Jafet> The old quicksort code is still there, read it
05:37:27 <aristid> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/Data-List.html#wrap
05:38:13 <Philonous> Yeah, that's not quicksort
05:38:58 <quicksilver> I'm with Philonous - the thing which makes quicksort quicksort is the way you use mutation to do a particular efficient partition.
05:38:59 <Philonous> Jafet: Quicksort, or at least the algorith Hoare invented is in place 
05:39:37 <quicksilver> the thing that people use as an example simple haskell quicksort is some kind of functional partition sort
05:39:47 <quicksilver> (which as far as I know doesn't have a proper name)
05:40:14 <Jafet> That doesn't make sense for Haskell lists, so according to you sort cannot use quicksort by definition?
05:40:19 <quicksilver> yup.
05:40:27 <Jafet> Strange people
05:40:42 <quicksilver> well they have quite different runtimes
05:40:48 <quicksilver> the whole point of quicksort is to be quick
05:40:58 <quicksilver> so it seems silly to use that name for a version which isn't quick.
05:41:51 <Philonous> quicksilver: But you can't blame one for thinking this is quicksort, even my algorithms prof tried to sell this algorithm as quicksort. And he used java...
05:42:30 <Jafet> Just looking at that code, I don't think the average difference in efficiency is large
05:42:41 <Ke> the name of the algorithm is 100% semantics, why do you care?
05:42:48 <aristid> quicksilver: is the "functional partition sort" slow?
05:42:52 <ketil> Wikipedia calls it quicksort regardless of in-place or not.
05:43:15 <Jafet> And yes; quicksort is not quick at all
05:44:58 <Philonous> Jafet: It has much worse constants and it's space performance is in O(n*log n) instead of O(n), which really makes a difference
05:45:58 <quicksilver> Jafet: the traditional way to compare sorts which all have average time n log n is to count comparisons + memory moves. Obviously the number of comparisons is the same but the number of memory moves is many many more.
05:46:01 <copumpkin> the mergesort in ghc is nice and lazy
05:46:08 <quicksilver> and the space usage is also importat.
05:46:11 <copumpkin> I seem to remember
05:46:32 <quicksilver> Ke: naming matters so that you can have useful discussions.
05:46:44 <aristid> i always liked the simplicity of mergesort
05:46:47 <copumpkin> semantics = meaning
05:46:49 <copumpkin> :P
05:46:53 <Jafet> How do you count memory moves in Haskell? Out of curiosity.
05:46:55 <quicksilver> You will read articles which say, for example, quicksort is <property> because <reason>
05:47:10 <quicksilver> of those articles, some proportion are going to be completely wrong, about the haskell "quicksort"
05:47:15 <quicksilver> so, for that reason, I contend the name matters.
05:47:31 <quicksilver> Feel free to use the word "quicksort" to refer to a cheese sandwich; I don't mind but I think your communication will be impeded.
05:47:47 <Ke> =oP
05:48:04 * copumpkin just woke up and will go make himself a fibonacci heap for breakfast, brb
05:48:27 <copumpkin> preflex: seen edwardk
05:48:27 <preflex>  edwardk was last seen on #haskell 22 hours, 54 minutes and 54 seconds ago, saying: ;)
05:48:28 <aristid> with milk or monads?
05:48:38 <hpc> aristid: with serial
05:48:48 <copumpkin> aristid: gonna pour some lax monoidal functors all over it
05:48:53 <copumpkin> I like it with plenty 
05:50:41 <aristid> copumpkin: too much of em is not healthy for you
05:50:56 <silasdavis> How can I write a function that takes a single-argument function and returns the application of the function and its argument.. I have:
05:50:58 <copumpkin> wow, someone patented using xor to blink a cursor
05:51:23 <Twey> Ahhh, software patents
05:51:46 <hpc> copumpkin: is that a patent by an actual productive company, or a patent troll company?
05:51:54 <aristid> hpc: hahaha
05:51:54 <silasdavis> (\(x -> y) z -> (z, (x->y) z))
05:52:05 <copumpkin> troll, and they successfully sued amiga for using it back in the day
05:52:08 <aristid> you mean a productive company like... oracle, or ibm? :P
05:52:20 <hpc> XD
05:52:28 <hpc> ibm still makes mainframes, at least
05:52:28 * Twey patents functions.
05:52:39 <baaba> silasdavis: (\f x -> (x, f x))
05:52:44 <Ke> political flamewar!
05:52:45 <silasdavis> I don't think I understand the use of the \
05:52:48 <Axman6> copumpkin: did you see the patent on writing and automating patent applications?
05:52:49 <aristid> and oracle still makes... salesmen for databases
05:52:50 <medfly> ugh :|
05:52:57 <copumpkin> Axman6: nope :)
05:52:58 <hpc> silasdavis: this might help:
05:53:02 <baaba> you could also write myfunction f x = (x, f x)
05:53:08 <Axman6> (\x -> x+1) 3
05:53:09 <copumpkin> :t graph = (arr id &&&) -- stolen from ski
05:53:10 <lambdabot> parse error on input `='
05:53:15 <Twey> silasdavis: \ args -> result
05:53:17 <copumpkin> :t (arr id &&&) -- stolen from ski
05:53:18 <Axman6> > (\x y -> x+y) 3
05:53:18 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
05:53:18 <lambdabot>    arising from a use of `...
05:53:18 <lambdabot> forall b (a :: * -> * -> *) c'. (Arrow a) => a b c' -> a b (b, c')
05:53:24 <Axman6> > (\x y -> x+y) 3 6
05:53:24 <lambdabot>   9
05:53:28 <hpc> silasdavis: (f x y = z) == (\x y -> z)
05:53:52 <silasdavis> ah, I was thinking 'x escaped'
05:53:54 <Jafet> That's let f x y = z in f
05:54:18 <silasdavis> is it 'escaping' the argument sequence from being read as a pattern?
05:54:43 <hpc> no; it's just a regular function with no name
05:54:44 <Axman6> silasdavis: thing of \ as being the name of the function, and -> being the equals sign 
05:54:55 <aristid> @hoohlr a -> (a, a)
05:54:56 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
05:54:56 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
05:54:56 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
05:54:58 <Axman6> so f x y = z is the same as (\x y -> z
05:55:00 <Axman6> )*
05:55:05 <aristid> cool, lambdabot accepted my typo
05:55:37 <hpc> to get a bit technical, and tie in currying
05:56:05 <hpc> (f x y = z) == (f = \x y -> z) == (f = \x -> \y -> z)
05:56:36 <hpc> so (\x y -> z) is the actual function, and you just give it a name with the (f =)
05:57:11 <hpc> and you can still do pattern matches in a lambda
05:57:26 <hpc> > (\(x:xs) -> (x,xs)) [1,2,3]
05:57:27 <lambdabot>   (1,[2,3])
05:57:40 <Twey> But you only get one pattern, so you'd better make damn sure it matches :þ
05:57:55 <hpc> indeed
05:58:09 <hpc> but then you can do \x -> case x of ...
05:58:18 <hpc> but that's getting a bit ugly
05:58:21 <Twey> Yeah, but it's hideous
05:58:24 <silasdavis> does: (\f p -> (f p, p - f p)) calculate f p twice?
05:58:31 <silasdavis> can I avoid doing so?
05:58:40 <Twey> silasdavis: Yes, probably
05:58:48 <Axman6> use let
05:59:06 <Twey> You can use let: \f p -> let v = f p in (v, p - v)
05:59:08 <Philonous> silasdavis: let \f p -> fp = f p in (fp, p -fp)
05:59:25 <Philonous> oops
05:59:27 <hpc> i think GHC optimizes the duplicate calls in some cases
05:59:30 <Philonous> what twey said
05:59:40 <Twey> hpc: I don't think it does
06:00:07 <Twey> hpc: Doing so has the potential to introduce vast inefficiencies if the return value is large
06:00:44 <Saizan> if you've "let v = f p; e = f p in ..." it'll rewrite that to "let v = f p; e = v in ..."
06:00:44 <aristid> @pl \f -> id &&& f
06:00:44 <lambdabot> (id &&&)
06:01:01 <Saizan> iirc
06:01:09 <hpc> so the trick to avoiding recomputation is to bind to a name?
06:01:20 <Twey> Aye
06:01:23 <Twey> With no arguments
06:01:48 <lantti> That ruins my idea of that then... I thought let is only sugar..
06:02:02 <hpc> that would explain how the zipWith fibs stuff doesn't explode then
06:02:06 <Twey> Sugar for what?
06:02:28 <hpc> Twey: like #define, probably
06:02:34 <lantti> For replacing the names with their bindings.
06:02:35 <silasdavis> is there any sensible way to do it without a let?
06:02:40 <Twey> Ick, no
06:02:43 <Twey> Ah, I see
06:02:47 <Twey> Well, semantically it is
06:03:04 <Twey> silasdavis: You can also use another function, or perhaps a view pattern
06:03:05 <Philonous> let l = f x in e ==> (\u -> e) (f x)
06:03:06 <Saizan> let is also where implicit generalization happens.
06:03:37 <Twey> \f p@(f -> v) -> (v, p - v)
06:03:37 <Saizan> so the desugaring to lambdas would make sense only after typechecking
06:03:54 <Saizan> and it's consistent with how sharing works
06:04:19 <Saizan> i.e. (\v -> (v , p - v)) (f p) has as much sharing as the let version
06:04:34 <Saizan> what you can't easily do with just lambdas is recursion though.
06:06:27 <Axman6> lambda calculus usually had let right?
06:06:30 <Axman6> has*
06:06:38 <Twey> No
06:06:55 <Philonous> Axman6: It is usually defined in terms of lambdas
06:06:56 <Twey> λ-calc doesn't have let or name-binding other than arguments
06:07:07 <Twey> Hence the need for the Y-combinator
06:08:10 <ivanm> Axman6: only if you can express a let in terms of lambdas :p
06:09:24 <Axman6> heh
06:09:33 <silver> http://www.haskell.org/haskellwiki/GHC:FAQ#Does_GHC_do_common_subexpression_elimination.3F
06:09:47 <copumpkin> the answer is NO
06:09:53 <copumpkin> (except in trivial situations)
06:10:44 <silasdavis> how do I 'send the argument both ways'?
06:10:57 <silasdavis> so the function is computed only once, and no let?
06:11:13 <copumpkin> :t (id &&& negate)
06:11:14 <lambdabot> forall b. (Num b) => b -> (b, b)
06:11:40 <hpc> silasdavis: define it at the top level perhaps?
06:11:49 <Twey> silasdavis: You can use another lambda or a view pattern as I demonstrated above, or you can make it point-free and use a function that supplies its argument to more than one other function, like liftM2 or &&&
06:12:14 <copumpkin> tibbe, dons: excellent work you guys are doing, btw! thanks!
06:12:37 <Twey> @pl \f p -> (f p, f p - p) 
06:12:37 <lambdabot> liftM2 ap ((,) .) ((-) =<<)
06:12:42 <Twey> Ick
06:12:45 <Twey> But that'll do it
06:12:53 <tibbe> copumpkin: thanks and you're welcome
06:12:55 <silasdavis> I'd like to use another lambda,..
06:13:12 <Twey> Then do what Saizan suggested
06:13:13 <silasdavis> is that it: <Twey> \f p@(f -> v) -> (v, p - v)
06:13:17 <Twey> 14:03:55 < Saizan> i.e. (\v -> (v , p - v)) (f p) has as much sharing as the let version
06:13:25 <Twey> That's a view pattern
06:13:27 <silasdavis> (\v -> (v , p - v)) (f p)
06:13:36 * hackagebot iteratee-compress 0.1 - An enumerators for compressing and decompressing streams  http://hackage.haskell.org/package/iteratee-compress-0.1 (MaciejPiechotka)
06:13:45 <Twey> Saizan wrote the lambda one (though you'll need to append \f -> to the front of it)
06:13:50 <Twey> Er, prepend, even.
06:14:26 <Twey> \f p -> (\v -> (v, p - v)) $ f p
06:15:11 <Philonous> Saizan: We could say something like let y =x in e transforms to (\y -> e) (fix (\y -> x ) ) to account for recursion
06:15:47 <silasdavis> forgive me, I tried this, but it didn't work:
06:15:51 <silasdavis> Prelude> (\f p -> (\v -> (v, p - v))) (\x -> x^2) 4
06:16:17 <Saizan> silasdavis: (\f p -> (\v -> (v, p - v)) (f p)) (\x -> x^2) 4
06:17:12 <Saizan> Philonous: yep, but then you either make fix a primitive or that's hiding a let, if you define fix as the Y combinator i don't think you get the same sharing
06:18:23 <Philonous> fix f = f fix f. Well, arguably that's a let in disguise, but I didn't need the keyword. 
06:18:34 <silasdavis> ah Saizan thanks I see, that's the way I wanted to do it
06:19:14 <silasdavis> and presumably an actually sensible use of an anonymous functions
06:19:16 <silasdavis> -s
06:19:56 <Saizan> silasdavis: i think this version with the lambda is the most obfuscated one
06:19:59 <Twey> I prefer the view pattern, though.  Much clearer.
06:20:03 <Twey> Yeah.
06:21:02 <silasdavis> what does that do?
06:21:02 <Saizan> Philonous: and "fix f = f (fix f)" is not compiled to something with as much sharing as "fix f = let x = f x in x" by ghc :)
06:21:52 <Twey> silasdavis: (f -> p) is a pattern that applies the function ‘f’ to the value supplied, then matches the pattern p against the result instead of the original argument
06:25:37 <silasdavis> ah I see
06:26:26 <fryguybob> lispy: The shootout code you have doesn't check the same trees as the original.
06:28:00 <ksf_> hmmm I thought HList was advanced type hackery.
06:28:26 <Saizan> but?
06:28:34 <ksf_> http://www.informatik.tu-cottbus.de/~jeltsch/research/ppdp-2010-paper.pdf
06:31:49 <lispy> fryguybob: oh no.  Can you give me an example?
06:32:14 <Philonous> Saizan: I think I don't understand ghc well enough to fully grasp why that is the case (I have a vague Idea, though). But hey, let's just define let and fix mutually recursive ;)
06:32:15 <fryguybob> lispy: the a and b are bound to the top level i, not the recursing go's i.
06:32:44 <hpc> why are research papers always two columns? it makes reading it as a pdf annoying
06:33:04 <osfameron> that's largely a problem with PDF being useless as an ebook format
06:33:16 <yrlnry> Lispy You never noticed before that JASOND is the initial letters of the months from July through December?
06:35:27 <lispy> yrlnry: i've known for approximately 20 years :)
06:35:42 <yrlnry> Strange that you would find it "creept".
06:35:45 <yrlnry> "creepy".
06:36:01 <lispy> yrlnry: it was a joke
06:36:01 <yrlnry> Or was that a joke?  
06:36:05 <yrlnry> Yeah, sorry.
06:36:16 <yrlnry> My name also matches JASOND.
06:37:19 <lispy> fryguybob: so, my version and the one on the shootout produce the same output, are you sure the i's have changed?
06:38:19 <fryguybob> lispy: I think the shootout is trying to measure the side effect of "visiting" the trees in memory so I think it is easy to make a program that produces the same output, but not the side effect they are trying to measure.
06:39:12 <fryguybob> I could be wrong for sure.  I just noticed that the "i" was different.
06:39:54 <copumpkin> tibbe: 32% faster on osx 10.5.8 says the ticket. Do you have an idea of how much 64-bit platforms improve on that?
06:42:17 <yrlnry> @pl \x -> x
06:42:17 <lambdabot> id
06:42:47 <yrlnry> @pl \fm xm -> fm >>= (\f -> xm >>= (\x -> return $ f x))
06:42:47 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
06:42:53 <yrlnry> Blurgh.
06:42:57 <lispy> fryguybob: ah ha.  Okay that does account for the speed difference (I nested a & b in where under go)
06:43:04 <lispy> fryguybob: same speed now
06:43:15 <fryguybob> lispy: Right.
06:49:38 <yrlnry> On page 4 of "Applicative Programming with Effects", McBride and Patterson suggest playing a Haskell Syntax trick so that  [[ f a b ... z ]] evaluates to f <$> a <*> b <*> ... <*> z.  They suggest using "il" and "li" for "[[" and "]]".  At the bottom of page 4, it says "Hint: Define an overloaded function applicative u v1 . . . vn Ii = u<*>v1<*>...<*>vn".
06:50:14 <yrlnry> But I don't see how this can work, because the hypothetical "applicative" function would have to be variadic in a way that Haskell functions aren't.
06:50:19 <yrlnry> What am I missing?
06:50:39 <baaba> i suppose they mean it to be limited to some finite n of your choice
06:50:44 <Nibble> yrlnry: I think you can have variadic functions
06:50:46 <copumpkin> you could probably still do it with some type tricks
06:50:48 <Nibble> if you mess with the type system
06:51:02 <lispy> :t printf
06:51:03 <lambdabot> forall r. (PrintfType r) => String -> r
06:51:09 <BONUS> you can do variadic functions with type class black magic but i dont know about the closing "li" value
06:51:11 <copumpkin> it'd have to be way more complicated than htat
06:51:12 <yrlnry> Oh right, I forgot about that trick.
06:51:33 <copumpkin> actually it shouldn't be too bad
06:51:34 <copumpkin> let me try
06:51:36 <Twey> TH, maybe?
06:51:47 <yrlnry> BONUS:  the closing li shouldn't be any problem.   You can data Dummy = Dummy; li = Dummy;  and then the closing li becomes just another pattern, and is discarded  by the function definition.
06:51:56 <Axman6> > printf "%d %s" 3 "hello" :: String
06:51:56 <lambdabot>   "3 hello"
06:52:29 <Jonno_FTW> @src printf
06:52:29 <lambdabot> Source not found. My mind is going. I can feel it.
06:52:33 <BONUS> i never bother remembering the exact type class mechanism of printf et al.
06:52:34 <Nibble> @src print
06:52:35 <lambdabot> print x = putStrLn (show x)
06:52:44 <Axman6> > printf "%d %s %f" 3 "hello" pi :: String
06:52:44 <yrlnry> :t print
06:52:44 <lambdabot>   "3 hello 3.141592653589793"
06:52:45 <lambdabot> forall a. (Show a) => a -> IO ()
06:53:03 <yrlnry> I need to study printf, because i don't understand how it works.
06:53:13 <Twey> :t printf
06:53:14 <lambdabot> forall r. (PrintfType r) => String -> r
06:53:15 <aristid> > printf "%s %d %f" 3 "hello" pi
06:53:16 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:53:16 <lambdabot>    `Text.Printf.PrintfType ...
06:53:17 <Jonno_FTW> Is it used very often?
06:53:24 <aristid> > printf "%s %d %f" 3 "hello" pi :: String
06:53:25 <lambdabot>   "*Exception: Printf.printf: bad argument
06:53:51 <Twey> PrintfType includes (PrintfType a, PrintfType r) => a -> r
06:54:34 <Twey> It's not that complicated, just annoying
06:54:59 <yrlnry> you mean  (PrintfType a, PrintfType r) => PrintfType (a -> r), right?
06:55:19 <Twey> No
06:55:23 <Twey> PrintfType is a class, not a type
06:55:37 * yrlnry scratches his head.
06:55:54 <aristid> Twey: i think yrlnry is thinking of an instance declaration
06:55:58 <BONUS> it's all very mystical
06:56:00 <yrlnry> doesn't   «(PrintfType a, PrintfType r) => PrintfType (a -> r)» assert that a->r is ...
06:56:01 <hpc> yrlnry means like in the line "instance (blah a, blah r) => blah (a -> r) where"
06:56:02 <aristid> instance (PrintfType a, PrintfType r) => PrintfType (a -> r)
06:56:02 <Twey> Oh, I see what you mean: that's part of an instance declaration
06:56:03 <hpc> i think
06:56:03 <Twey> Yeah
06:56:05 <yrlnry> Yes, that's what I was thinking.
06:56:06 <Twey> In that case, yes
06:56:28 <yrlnry> what did you mean?
06:56:43 <Twey> I was just talking about the type
06:56:50 <yrlnry> the type of what?
06:57:00 <tibbe> copumpkin: I expect there to be a 45% on 64-bit, just like for Data.Map
06:57:18 <hpc> yrlnry: the type of a thing
06:57:25 <Twey> :t printf "%s"
06:57:26 <lambdabot> forall r. (PrintfType r) => r
06:57:45 <yrlnry> Okay, I understand you now.
06:57:48 <Twey> :t printf "%s" :: (PrintfType a, PrintfType r) => a -> r
06:57:49 <lambdabot>     Could not deduce (PrintfArg a)
06:57:50 <lambdabot>       from the context (PrintfType a, PrintfType r)
06:57:50 <lambdabot>       arising from a use of `printf' at <interactive>:1:0-10
06:57:50 <yrlnry> (I think.)
06:57:52 <Twey> Oops
06:57:55 <Twey> :t printf "%s" :: (PrintfArg a, PrintfType r) => a -> r
06:57:57 <lambdabot> forall a r. (PrintfType r, PrintfArg a) => a -> r
06:58:02 <Twey> They're separate classes, sorry
06:58:27 <Nibble> http://www.haskell.org/tutorial/classes.html
06:58:30 <yrlnry> Ohn, and PrintfArg is a class of types that can appear as parameters to printf, for which there are %x escapes.
06:58:36 <Nibble> "system that sets it apart from other programming languages"
06:58:39 <Twey> PrintfType includes String and IO (), so you can use it as a pure function or not, depending on context
06:58:43 <Twey> Right
06:58:46 <Nibble> I don't see how that is a haskell only feature
06:58:58 <yrlnry> That way it cn compile-time diagnose a failure if you try to pass a function or something to printf that it isn't prepared to format.
06:59:02 <Nibble> You can do overloading in many languages
06:59:12 <Twey> Typeclasses are not quite the same thing as overloading
06:59:36 <yrlnry> Yrah, they were introduced for overloading and then people abused the heck out of the feature to use it as a general-porpose compile-time theorem prover.
06:59:43 <Twey> Hehehe.
07:02:37 <ksf_> hmmm I don't believe I can give a type sig for this function.
07:02:48 <ksf_> grapefruit-records hides the class, and I understand why.
07:03:12 <Axman6> heh
07:03:43 <co_dh>  > let 1 + 1 = 3 in 1 + 1
07:03:56 <ksf_> we so definitely and urgently need programmer-directed type inference, type simplifiers + pretty printers and custom error messages.
07:03:56 <co_dh> > 1 + 1
07:03:56 <lambdabot>   2
07:04:37 <aristid> ksf_: i guess you have already started hacking ghc? :D
07:04:42 <Nibble> > let (pluss) x y = x + y + 1
07:04:43 <lambdabot>   not an expression: `let (pluss) x y = x + y + 1'
07:04:49 <ben_m> @let 1 + 1 = 3
07:04:49 <quicksilver> also, we need record packages not affiliated with citrus fruit
07:04:50 <lambdabot>  Defined.
07:04:52 <ksf_> otoh, it's nice to see that grapefruit-records doesn't have any problems expressing at least the first oohaskell example.
07:04:53 <ben_m> > 1 + 1
07:04:54 <lambdabot>   Ambiguous occurrence `+'
07:04:54 <lambdabot>  It could refer to either `L.+', defined at <local...
07:04:56 <hpc> haha
07:04:57 <ben_m> aww.
07:04:59 <quicksilver> there is a whole wealth of possible fruits out there
07:05:04 <quicksilver> why restrict ourselves to citrus?
07:05:26 <hpc> i think "gourmand" would make a neat package name
07:05:27 <ksf_> it could be independent of grapefruit.
07:05:35 <ksf_> ...most modules of it are.
07:06:01 <ksf_> but there's a few specific ones that deal with frp stuff. arguably frp should depend on records, not the other way round.
07:06:43 <ksf_> there will, one day, definitely be a library called "fruitless"
07:10:43 <Saizan> ksf_: what do you mean exactly by programmer-directed type inference?
07:13:02 <ksf_> things like "be eager, here"
07:13:19 <ksf_> ghc has the habit of being very, very lazy when it comes to resolving constraints.
07:13:27 <ksf_> contexts, that is.
07:13:35 <fxr> @pf f(g x)
07:13:36 <lambdabot> Maybe you meant: bf pl
07:13:46 <fxr> @lplf(g x)
07:13:47 <lambdabot> Unknown command, try @list
07:13:55 <fxr> @pl (g x)
07:13:56 <lambdabot> g x
07:14:09 <fxr> @pl (x .&. c1) + ((x `shiftR` 1) .&. c1)
07:14:09 <lambdabot> x .&. c1 + x `shiftR` 1 .&. c1
07:14:20 * fdsfsd http://pro.revenge.lv 11 PRO.REVENGE.LV:27015 cs 1.6 JOIN JOIN!!!
07:14:35 <ksf_> possibly also influencing backtracking (that is, backtrack in the first place), though I guess that won't be necessary with an extended typefam implementation.
07:14:45 <ksf_> (and I don't like fundep-style logic programming, anyway)
07:15:20 <sajkr> too low to find my way / too high to wonder why / i've touched this place before / somewhere in another time / now i can hear the sun / the clouds drifting through the blinds / a half a million thoughts / are flowing through my mind - You  (edit  | delete)
07:15:46 <Starfire> Custom error messages would be nice.
07:18:17 <sajkr> oops.
07:32:06 <sbpaul> what's the simplest way to turn 11111111 into 255
07:32:11 <sbpaul> etc
07:32:36 <ManateeLazyCat> ksf_: We reall need FRP? 
07:32:57 <Botje> sbpaul: "1111" ? or the actual number
07:33:04 <sbpaul> the binary 11...
07:33:14 <copumpkin> represented as a string or a number?
07:33:14 <sbpaul> ManateeLazyCat: for anything dependent on time, like a video game
07:33:20 <sbpaul> well, either
07:33:26 <sbpaul> i'm actually trying to go the other way
07:33:33 <ksf_> sbpaul, if you have the bits in a list, zip them with 0..2^n, filter out the zeroes, add everything up.
07:33:38 <sbpaul> int to binary
07:33:47 <ksf_> int _is_ binary.
07:33:49 <copumpkin> why filter out the zeros before adding? :P
07:33:55 <sbpaul> no, no
07:33:58 <sbpaul> a string of binary characters
07:34:06 <ksf_> 'cos otherwise you'd have to multiply.
07:34:16 <Jafet> "Why won't they understand me!"
07:34:19 <ManateeLazyCat> sbpaul: Yes, video game need FRP, have other example?
07:34:31 <sbpaul> ManateeLazyCat: anything that polls for user input, really
07:34:32 <fasta> I think it is homework. 
07:34:33 <sbpaul> for the most part
07:34:35 <ksf_> frp is really, really nice.
07:35:03 <fasta> ksf_, which one? 
07:35:30 <fasta> ksf_, since, AFAIK, they all have been complete failures thus far. 
07:35:34 <ManateeLazyCat> ksf_: Can you give me some FRP example to improve gtk2hs code? 
07:35:59 <sbpaul> are you telling me there's no built in function to turn an int into a binary string
07:36:12 <sbpaul> or is it in Data.Binary somewhere
07:36:22 <fasta> sbpaul, there are libraries that do this. 
07:36:28 <fasta> sbpaul, no idea, which one.
07:36:29 <ksf_> > let foo xs = sum . filter (fst . (/=0)) . zip xs (map (2^) [0..]) in foo "100101"
07:36:30 <lambdabot>   Couldn't match expected type `(GHC.Bool.Bool, b)'
07:36:30 <lambdabot>         against inferred ...
07:36:39 <Jafet> > showIntAtBase 2 42
07:36:40 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:36:40 <lambdabot>    arising from the literal `4...
07:36:41 <ksf_> > let foo xs = sum . map snd . filter (fst . (/=0)) . zip xs (map (2^) [0..]) in foo "100101"
07:36:42 <lambdabot>   Couldn't match expected type `(GHC.Bool.Bool, b)'
07:36:42 <lambdabot>         against inferred ...
07:36:47 <sbpaul> other way ksf
07:36:47 <fasta> Writing it yourself is probably faster, but you have to find another victim ;)
07:36:58 <ksf_> > let foo xs = sum . map snd . filter (fst . (/='0')) . zip xs (map (2^) [0..]) in foo "100101"
07:36:58 <lambdabot>   Couldn't match expected type `(a, b)'
07:36:59 <lambdabot>         against inferred type `GHC.Ty...
07:37:12 <copumpkin> ksf_: I'm still not sure why you're filtering out the zeros before summing...
07:37:22 <sbpaul> so then the question is finding whether or not it's divisible by decrementing powers of two
07:37:25 <sbpaul> ??
07:37:28 <sbpaul> jesus
07:37:29 <ksf_> because otherwise id' have to digittoint the char
07:37:40 <ksf_> ...which, in the end, would be slower.
07:38:08 <ksf_> > let foo xs = sum . map snd . filter (fst . (/='0')) . zip xs $ (map (2^) [0..]) in foo "100101"
07:38:09 <lambdabot>   Couldn't match expected type `(a, b)'
07:38:09 <lambdabot>         against inferred type `GHC.Ty...
07:38:15 <co_dh> copumpkin: ksf_ filter the fst /='0' , and take the snd.
07:38:16 <ManateeLazyCat> ksf_: I want try FRP if have mature solution....
07:38:35 <ksf_> > let foo xs = sum . map snd . filter ((/='0').fst) . zip xs $ (map (2^) [0..]) in foo "100101"
07:38:37 <lambdabot>   41
07:38:40 <ksf_> d'oh.
07:38:40 <mreh> tuples _ [] = []; tuples 1 xs = xs; tuples n xs = [ x:xs' | xs' <- tuples (n-1) xs, x <- xs ] - que? I get an occurs check
07:39:07 <ksf_> > let foo xs = sum . map snd . filter ((=='1').fst) . zip xs $ (map (2^) [0..]) in foo "100101"
07:39:08 <lambdabot>   41
07:39:11 <ksf_> less double negation.
07:39:29 <ManateeLazyCat> ksf_: grapefruit can bulid on gtk-0.11.x ?
07:39:38 <ksf_> > let foo = sum . map fst . filter ((=='1').snd) . zip (map (2^) [0..]) in foo "100101"
07:39:39 <lambdabot>   41
07:39:43 <ksf_> ManateeLazyCat, yep.
07:39:57 <ksf_> builds on 6.12.3 with only minor adjustments.
07:40:10 <ksf_> update a few constraints, annotate a single call site with "Prelude."
07:40:14 <ksf_> (due to containers)
07:40:26 <mreh> that was my attempt at all n-tuples from a list, anyone think they can beat my stroke?
07:40:37 <ManateeLazyCat> ksf_: It's your local repository or package on hackage?
07:40:53 <ksf_> I used the darcs version.
07:41:02 <ManateeLazyCat> ksf_: link?
07:41:06 <ksf_> uhm
07:41:17 <mreh> first, just getting the thing to compile would beat me
07:41:33 <Saizan> mreh: you need a recursive type for that
07:41:39 <ksf_> http://code.haskell.org/grapefruit/main/
07:41:55 <ksf_> ...the changes are really minor and straight-forward.
07:42:22 <mreh> Saizan: how come?
07:42:29 <ManateeLazyCat> ksf_: Thanks, i try to install it and figure out what's cool....
07:43:08 <ksf_> sb,oh.
07:43:13 <ksf_> @hoogle showBinary
07:43:14 <lambdabot> No results found
07:43:18 <Saizan> mreh: ah, wait, you're using lists
07:43:18 <ksf_> ah no.
07:43:24 <ksf_> @hoogle showIntAtBase
07:43:25 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
07:43:58 <sbpaul> p,g
07:44:05 <Saizan> > let tuples _ [] = []; tuples 1 xs = map (:[]) xs; tuples n xs = [ x:xs' | xs' <- tuples (n-1) xs, x <- xs ] in tuples 2 [1..3]
07:44:06 <lambdabot>   [[1,1],[2,1],[3,1],[1,2],[2,2],[3,2],[1,3],[2,3],[3,3]]
07:44:06 <ksf_> > let showBinary i = showIntAtBase 2 (intToDigit) i "" in showBinary 42
07:44:07 <lambdabot>   "101010"
07:44:12 <Saizan> mreh: ^^^
07:44:27 <mreh> doi!
07:44:36 <ksf_> sbpaul, have a look at the module "Numeric"
07:44:45 <mreh> cryptic compiler errors fool me again!
07:44:45 <Nibble> wth does ^^do
07:44:56 <mreh> cheers Saizan, how did you spot it?
07:45:27 <mreh> I also wish [] was the singleton function
07:45:42 <mreh> that would be stupid
07:46:08 <mreh> \x -> [x] ain't as cool as I'd like
07:46:27 <Botje> .oO(return?)
07:46:39 <geheimdienst> > (:[]) 2
07:46:40 <lambdabot>   [2]
07:46:48 <geheimdienst> muahahaha
07:46:52 <Botje> although the evil robot monkey operator is pretty cool
07:47:12 <sbpaul> wait
07:47:23 <ksf_> hmmm I think I missed a reverse, there.
07:47:24 * mreh (:[]) 
07:47:35 <ksf_> sbpaul, is your binary string big- or little endian?
07:47:46 <Saizan> mreh: the recursive case looked fine so it had to be the other, then i guessed [xs] because of the occurs check, but that didn't make sense wrt the semantics, hence map (:[]) xs :P
07:47:50 <mreh> > pure a
07:47:51 <lambdabot>   Ambiguous occurrence `a'
07:47:51 <lambdabot>  It could refer to either `L.a', defined at <local...
07:47:54 <sbpaul> it's just a list of ints
07:47:56 <sbpaul> > 256
07:47:57 <lambdabot>   256
07:47:58 <sbpaul> <*
07:48:01 <mreh> > pure 1 :: [Int]
07:48:02 <lambdabot>   [1]
07:48:38 <sbpaul> best quote ever on a page about haskell
07:48:42 <mreh> Saizan: haha, okay, I'm too Green to trust my instincts
07:48:43 <sbpaul> "as a mathematician, i get annoyed by such things"
07:49:07 <mreh> what was the context?
07:49:15 <mreh> dressing himself?
07:49:33 <BONUS> haha, burn
07:52:16 <sbpaul> @let charToBin i = shotIntAtBase 2 IntToDigit i ""
07:52:16 <lambdabot>  <local>:5:14: Not in scope: `shotIntAtBase'
07:52:17 <lambdabot>  
07:52:17 <lambdabot>  <local>:5:30: Not in scope: d...
07:52:22 <sbpaul> @let charToBin i = showIntAtBase 2 IntToDigit i ""
07:52:23 <lambdabot>  <local>:5:30: Not in scope: data constructor `IntToDigit'
07:52:23 <Nibble> Prelude> read "10"
07:52:27 <Nibble>     Ambiguous type variable `a' in the constraint:
07:52:29 <Nibble> wth?
07:52:33 <sbpaul> umm
07:52:34 <Saizan> > replicateM 2 [1..3]
07:52:35 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
07:52:42 <Saizan> mreh: btw ^^
07:52:55 <sbpaul> whoops
07:52:57 <mreh> yeah, I figured there would be a better way
07:52:58 <Saizan> Nibble: add a type annotation
07:53:04 <sbpaul> @let charToBin i = showIntAtBase 2 IntToDigit (ord i) ""
07:53:05 <lambdabot>  <local>:5:30: Not in scope: data constructor `IntToDigit'
07:53:09 <sbpaul> oh yeah
07:53:12 <Nibble> Saizan: I tried  read "10" :: (Read a) => String -> a
07:53:17 <sbpaul> @let charToBin i = showIntAtBase 2 intToDigit (ord i) ""
07:53:18 <lambdabot>  Defined.
07:53:28 <sbpaul> > map charToBin "hello ksf"
07:53:29 <lambdabot>   ["1101000","1100101","1101100","1101100","1101111","100000","1101011","1110...
07:53:36 <hpc> > read "10" :: Int
07:53:37 <lambdabot>   10
07:53:38 <sbpaul> doesn't even give me the whole thing
07:53:51 <Nibble> oh
07:53:54 <ski> Nibble : that should have been `(read :: Read a => String -> a) "10"', then. but it still doesn't fix the problem
07:54:15 <ski> Nibble : it doesn't know *what* type to (try to) read into
07:54:16 <Saizan> Nibble: once you apply read to a String the type of that expression is "(Read a) => a", but that can't be shown, you've to tell ghci which specific instance of Read you want
07:54:36 <ski> > (reads :: Reads Int) "1234abcd"
07:54:37 <lambdabot>   Not in scope: type constructor or class `Reads'
07:54:41 <ski> > (reads :: ReadS Int) "1234abcd"
07:54:41 <lambdabot>   [(1234,"abcd")]
07:54:46 <ski> > (reads :: ReadS String) "1234abcd"
07:54:47 <lambdabot>   []
07:55:06 <ski> > (reads :: ReadS Int) "12.34"
07:55:07 <lambdabot>   []
07:55:31 <sbpaul> i can't seem to do anything in haskell w/o opening 40 browser tabs
07:55:38 <mreh> lol
07:55:47 <Nibble> How is lekash?
07:55:53 <Nibble> or wth is the name
07:55:54 <Nibble> leksah
07:56:02 <ManateeLazyCat> ksf_: I'm failed install grapefruit darcs version, looks need adjust .cabal many place.
07:56:03 * geheimdienst can't seem to do anything with anything w/o opening 40 browser tabs
07:56:05 <Nibble> no leksah
07:56:07 <ski> Nibble : usually, the type system can figure out what type you want to read into from the context, so a type ascription is usually not necessary
07:56:17 <mreh> > drop 1 . reverse $ "haskell"
07:56:18 <lambdabot>   "leksah"
07:56:28 * ben_m can't seem to get below 40 browser tabs
07:56:48 <ski> Nibble : but if you just enter a call to `read' (or `reads' or `readsPrec') at the interactor, there is not context from which it could deduce the type
07:56:55 <hpc> it takes effort for me to get to 40 tabs
07:56:58 * geheimdienst is an opera user. opera starts with 40 tabs about as fast as firefox with 1
07:57:02 <ManateeLazyCat> mreh: Ah, i know why called leksah now, it's reverse of haskel 
07:57:02 <ben_m> Hah yeah, I was kidding :D
07:57:03 * Saizan has more papers than brower tabs open
07:57:03 <ManateeLazyCat> :)
07:57:29 <Nibble> but, how is leksah? What editor/IDE do you use
07:57:34 <ksf_> ManateeLazyCat, containers and gtk.
07:57:35 <mreh> > reverse . init $ "haskell"
07:57:36 <lambdabot>   "leksah"
07:57:59 <Nibble> I find it a pain in the ass to program in haskell without some kind of in-built type thing, I keep having to run ghci to find the type
07:58:01 * ksf_ wonders whether there was some extension stuff too or was that another package
07:58:12 <ManateeLazyCat> ksf_: Yes, i install, but looks have many other dependent package need fix.
07:58:25 <geheimdienst> i totally didn't realize that leksah = reverse haskel. i thought leksah was what the lolcats said for lexer
07:58:46 <ksf_> grapefruit-frp -> records -> ui -> ui-gtk
07:58:52 <Heffalump> geheimdienst: don't think I realised that either.
07:58:53 <ksf_> then examples
07:59:12 <mreh> the strange thing is that I'm shit at Countdown
07:59:23 <mreh> it's like the easiest anagram :)
07:59:56 <ManateeLazyCat> Nibble: For now, emacs/vim is best editor for haskell.
08:00:01 <ManateeLazyCat> Nibble: Not other.
08:00:07 * hackagebot bits-atomic 0.1.2 - Atomic bit operations on memory locations  for low-level synchronization  http://hackage.haskell.org/package/bits-atomic-0.1.2 (GabrielWicke)
08:00:24 <Nibble> ManateeLazyCat: Can emacs do code completion and find the types for stuff?
08:00:33 <ksf_> Nibble, yep. vim, too.
08:00:39 <ksf_> there's a generic library for that.
08:00:56 <mreh> @remember geheimdienst  i totally didn't realize that leksah = reverse haskel. i thought leksah was what the lolcats said for lexer
08:00:56 <lambdabot> It is stored.
08:00:57 <Nibble> ksf_: ok. could you please link to the vim and emacs things?
08:01:01 <ManateeLazyCat> Nibble: Can completion module name.
08:01:04 <sbpaul> things:
08:01:10 <sbpaul> Nibble: in vim, type :syntax on
08:01:15 <ksf_> well I'm not sure about completition but definitely type inference.
08:01:16 <ManateeLazyCat> Nibble: i found ghc-mod can do completion for haskell code.
08:01:25 <sbpaul> oh my
08:01:27 <Nibble> ManateeLazyCat: and that is vim or haskell?
08:01:28 <ksf_> Nibble, somewhere on the wiki, also in the vim package repo.
08:01:40 <ManateeLazyCat> @hackage ghc-mode
08:01:40 <lambdabot> http://hackage.haskell.org/package/ghc-mode
08:01:41 <Nibble> sbpaul: isn't that just highlighting?
08:01:42 <ManateeLazyCat> @hackage ghc-mod
08:01:42 <lambdabot> http://hackage.haskell.org/package/ghc-mod
08:01:52 <ManateeLazyCat> Nibble: http://hackage.haskell.org/package/ghc-mod
08:02:12 <Nibble> I guess I will have to learn emacs
08:02:32 <ManateeLazyCat> Nibble: I'm developing haskell environment include editor, i will add code-completion feature when i have some spare time.
08:02:40 <ManateeLazyCat> Nibble: If you want wait it release. :)
08:02:55 <ManateeLazyCat> Nibble: But can't now. :)
08:03:02 <Nibble> ManateeLazyCat: any repo for it? :)
08:03:03 <mreh> is the editor question a big deal with haskell right now?
08:03:16 <ksf_> Nibble, http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
08:03:21 <ksf_> ...that's the one that comes with gentoo.
08:03:22 <mreh> seems like it might be a barrier to entry for some users, but it's not a real one
08:03:33 <ManateeLazyCat> Nibble: http://www.flickr.com/photos/48809572@N02/
08:03:48 <mreh> you don't need, because you don't write tons of boilerplate
08:04:04 <ManateeLazyCat> Nibble: Since it's need gtk2hs darcs version, it's a bit hard to install now until new version gtk2hs release.
08:04:33 <ManateeLazyCat> Nibble: My suggestion is use Emacs or Vim now.
08:05:27 <Nibble> ManateeLazyCat: Is that irssi or emacs? http://www.flickr.com/photos/48809572@N02/4797900653/lightbox/
08:06:16 <ManateeLazyCat> Nibble: It's Haskell environment base on gtk2hs (haskell binding for GTK+)
08:06:34 <Nibble> ManateeLazyCat: the one in the background
08:06:58 <ManateeLazyCat> Nibble: ERC -- IRC client for Emacs.
08:07:12 <ski> geheimdienst : <http://web.archive.org/web/20070703001910/www.cs.chalmers.se/~augustss/pics/haskel.gif>
08:09:11 <Nibble> Shit, lots of stuff to compile
08:09:35 <mreh> oh, new golfing challenge, all the subsets of a list
08:09:59 <luite> subsequences.nub
08:09:59 <luite> ?
08:10:21 <geheimdienst> ski, :)
08:10:43 <mreh> it's a bit computationally expensive, but have a cookie
08:11:11 <mreh> is it any more expensive than doing it explicitly?
08:11:15 <ManateeLazyCat> Nibble: Well, repository at https://patch-tag.com/r/AndyStewart that beginning with manatee-*
08:11:22 <ski> (btw, note that the guy says Haskel is a *Schemer* :)
08:11:35 <ski> (or at least, was)
08:11:46 <geheimdienst> yeah i noticed that
08:13:16 <Saizan> ksf_: it's quite ironic that in haskell we resort to C-like function pointers at the type level now that even C compilers support lambdas..
08:14:06 <Nibble> ManateeLazyCat: I installed ghc-mod from cabal
08:14:10 <Nibble> ManateeLazyCat: how do I activate it
08:14:14 <Saizan> i guess oleg's App typeclass already did that a few years before though
08:14:16 <Twey> Saizan: We do?
08:14:27 <Saizan> Twey: the records package does
08:14:51 <Twey> Nibble: http://www.ergoemacs.org/ — no need to ‘learn’ it, to use it anyway
08:15:01 <Twey> Saizan: How so?
08:15:04 <ManateeLazyCat> Nibble: Well, you need read documentation of ghc-mod, it's clear enough. I stop hacking elisp code long time, sorry i can't help you.
08:16:16 <ManateeLazyCat> Nibble: I haven't time as an emacs volunteer.... 
08:16:26 <Saizan> Twey: http://hackage.haskell.org/packages/archive/type-functions/0.1.0.0/doc/html/Data-TypeFun.html <- see App and instances of it
08:16:45 <Twey> Ah, I see
08:17:11 <ManateeLazyCat> Nibble: You can ask in #emacs if you have some problem with ghc-mod, i know some haskellers in #emacs :)
08:18:25 <Saizan> instead of myfun = \t -> e you declare data MyFun <free vars of e here>; instance App (MyFun ...) t = e
08:20:56 <ski> Saizan : what's the C-like part ?
08:21:16 <Saizan> ski: that you've to construct the closure explicitly :)
08:21:26 <ksf_> http://code.haskell.org/grapefruit/main/grapefruit-records/src/Data/Record.hs
08:21:29 <ski> ah
08:21:31 <ksf_> someone explain that one to me.
08:21:34 <Nibble> can't cabal uninstall stuff?
08:21:46 <ksf_> nope
08:21:52 <ManateeLazyCat> Nibble: ghc-pkg unregister PackageName-Version
08:22:00 * ski didn't know C compilers had anonymous functions now
08:22:04 <ManateeLazyCat> Nibble: You can remove it from ghc database.
08:22:07 <ksf_> well, in theory it can, but it turned out people were using it only to break their install.
08:22:21 <ski> (or did you mean gcc:s local function declarations ?)
08:23:00 <Saizan> ski: (i was mostly going by some snippets of code i've seen thrown here, i think it was on clang)
08:23:06 <Entroacceptor> ManateeLazyCat: put it to hackage, I'm too lazy to compile all that myself ;)
08:23:17 <ksf_> it's all a bit more complex with cabal as it can deal with multiple package versions and other stuff that make dependency analysis NP-complete.
08:23:18 <ManateeLazyCat> Entroacceptor: manatee?
08:23:29 <ski> Saizan : "clang" ?
08:23:38 <geheimdienst> ski, no it's coming. i think C++0x is getting closures, and c / obj-c are not far behind because apple is pushing closures into the language
08:23:50 <Saizan> ski: http://clang.llvm.org/
08:23:59 <ManateeLazyCat> Entroacceptor: manatee need darcs version of gtk2hs, i can't release it until new version gtk2hs release.
08:25:17 <ManateeLazyCat> Entroacceptor: After i upload manatee to hackage, you can use command "cabal install manatee" install all modules, but now it can't 
08:25:28 <ski> "Use __has_feature(cxx_lambdas) to determine if support for lambdas is enabled. clang does not currently implement this feature."
08:25:53 <Twey> ‘For each record type, this method constructs a value which is somehow related to this record type. Such a value is called a thing.’ — hahaha
08:26:11 <Twey> The hazards of increasing genericity
08:26:15 * ManateeLazyCat brb
08:27:07 <Saizan> ski: it has "blocks" though
08:27:46 * geheimdienst would much rather work with a "thing" than a "hylocombobuloid"
08:28:05 <ksf_> ...well, read the paper.
08:28:22 * geheimdienst is glad that for once, the pragmatists and not the complicators did the naming
08:28:24 <ksf_> it starts out quite nice and then finishes in a war between greek symbols.
08:28:59 * Twey laughs.
08:28:59 <Saizan> geheimdienst: between two meaningless names i prefer the less overloaded by far.
08:29:07 <ski> Saizan : ah, ty
08:29:51 <applicative> what were we supposed to call monadic values?  "mobit"?
08:29:58 <ben_m> mote
08:29:58 <ksf_> or mote.
08:30:00 <ski> "action"
08:30:03 <ksf_> mobit is my creation.
08:30:11 <ben_m> Reminds me of hobbit.
08:30:15 <applicative> mobit is good.  mote seemed ok
08:30:18 <ski> `getLine' is e.g. an `IO'-action
08:30:21 <ksf_> they're different things, though.
08:30:23 <sbpaul> mobyte
08:30:30 <applicative> i was thinking the objection to mobit was that "bit" might mislead
08:30:30 <sbpaul> mocephalite
08:30:36 <ksf_> slightly different levels of concreteness.
08:30:50 <sbpaul> moultramicroscopicsilicovolcanoconiosis
08:31:12 <ksf_> mobit refers to [Int], whereas mote refers to [1]
08:31:20 <ksf_> ...at least afaiu.
08:31:23 <applicative> ski, but is [1,2,3] a []-action?
08:32:11 <sbpaul> filter (==25) [1..1000]
08:32:14 <sbpaul> > filter (==25) [1..1000]
08:32:15 <lambdabot>   [25]
08:32:21 <sbpaul> astounding
08:32:35 <applicative> in the reddit blather, pigworker/mcbride went for 'computation'.  this bugged me, but i guess i just don't get it
08:32:41 <sbpaul> > filter (==25) [25,25..25]
08:32:41 <lambdabot>   [25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25...
08:32:43 <jmcarthur> shameless spam: i'm still on the job market for a functional programming job, especially haskell, if anybody knows of any good, available ones
08:32:58 <sbpaul> jmcarthur: if i knew that, i would have taken it
08:33:06 <sbpaul> ;)
08:33:13 <jmcarthur> sbpaul: the same applies to most of us, i'm sure
08:33:20 <djahandarie> Can't you get a job at iPwn with like the rest of the regulars in this channel? :P
08:33:20 <sbpaul> yes
08:33:23 <sbpaul> this room is a pit of snakes
08:33:23 <co_dh> everybody here want one, we should could create some. 
08:33:27 <applicative> i don't think it's spam, unless it keeps going.
08:34:18 <ben_m> > filter (==25) [1..]
08:34:18 <applicative> sbpaul, why do you say so, that it is a pit of snakes.  I come here to avoid a pit of snakes and find earnest good people...:)
08:34:22 <lambdabot>   mueval-core: Time limit exceeded
08:34:40 <sbpaul> you'll be trying to evalute some function applicative, you'll get a type error
08:34:40 <Nibble> ben_m: that was odd?
08:34:42 <sbpaul> and then BAM
08:34:45 <sbpaul> dons is on your back with a knife
08:34:51 <ben_m> Nibble: Expectedit
08:34:54 <geheimdienst> saizan, i agree to some extent but there's got to be some middle ground. i've said it before, if the mathheads had done the naming, Either = Left | Right would be Stereoloid = BanachTyvski | CoBanachTyvski, with lots of Stereoloid tutorials on the web and lots of newbies in here. you're right that ambiguity can lead to confusion, but simple thing + loads of jargon also leads to confusion
08:34:57 <sbpaul> before you can do anything he's already severed your spinal cord!
08:35:08 <applicative> on account of the type error?
08:35:10 <Saizan> ksf_: meh, from the paper "thing" seems just to be the eliminator motive, they could have used the usual "p" there
08:35:14 <sbpaul> your only hope is if brian o'sullivan comes back in time
08:35:14 <Nibble> ben_m: shouldn't print out 25?
08:35:23 <tromp> > 0: filter (==0) [1..]
08:35:26 <lambdabot>   mueval-core: Time limit exceeded
08:35:39 <applicative> we need to sneak chrisdone's emacs type -error tweeter into dons' emacs!  then we can find out all dons' type errors
08:35:57 <applicative> i suspect they are as common as mine... only 1.5 million times more sophisticated
08:35:57 <ben_m> Nibble: It doesn't know that 25 won't show up again in the infinite list, I presume ;p
08:36:01 <ski> applicative : yes
08:36:12 <ski> `[1,2,3]' is an `[]'-action
08:36:18 <Saizan> geheimdienst: that's completely bogus, because all the mathheads around that write papers where they define their own Either don't go with those unnecessarily long or complicated names.
08:36:24 <Nibble> ben_m: well, shouldn't it still show up the first one as well as trying to find more?
08:36:29 <ben_m> dunno.
08:36:30 <applicative> ski, i don
08:36:34 <ben_m> Ask the smart people
08:36:41 <Saizan> geheimdienst: "mathheads" like elegance, you know?:)
08:36:57 <applicative> t get it, this [1,2,3] is an action thing.  why isn't 'a' or 1 :: Int an action?
08:37:14 <ski> applicative : however, that terminology is usually only sensible when you're thinking of a list as nondeterministically representing many values
08:37:42 <ski> applicative : like in `permutations :: [a] -> [] [a]', the result is thought of as an `[]'-action that returns a list
08:38:00 <applicative> you can think of it that way, but cant you think of a basic type like Char in various ways?  as, say  actions of printing.
08:38:07 <copumpkin> I bet the improved Map/Set/IntMap/(IntSet?) won't shut JDH up, and neither will the card marking for hash tables
08:38:24 <ski> applicative : if `e :: M X', where `M' is a monad (or possibly even applicative functor), then `e' is an `M'-action
08:38:34 <ksf_> @remember geheimdienst data Stereoloid = BanachTyvski | CoBanachTyvski
08:38:34 <lambdabot> Done.
08:38:37 <quicksilver> copumpkin: nothing will shut jdh up.
08:38:41 <applicative> copumpkin, he's not already on about it?  no you're predicting
08:38:43 <ski> applicative : that's the way i use the terminology
08:38:46 <fasta> copumpkin, I kind of like that not everyone screams everything is perfect. 
08:38:49 <geheimdienst> saizan, so when you say that elegance forbids unnecessarily long and complicated names, why did you criticize it before when i said i liked "thing" better than "hylocombobuloid"?
08:39:07 <geheimdienst> to me that seems like elegance would forbid hylocombobuloid as well
08:39:09 <copumpkin> fasta: have you actually read what he writes? it's quite a bit more than "not screaming it's perfect"
08:39:11 <fasta> copumpkin, now, he might have an agenda, but I don't care about that. 
08:39:25 <fasta> copumpkin, I am not sure whether he has written anything new.
08:39:30 <applicative> ski, i understand the usage, the equestion was whether it was distracting, misleading and might as well be replaced by mote or ksf_s mobit
08:39:32 <fasta> copumpkin, most of the time he is right. 
08:39:38 <Nibble> about the vim mode for haskell
08:39:42 <copumpkin> o.O
08:39:46 <fasta> copumpkin, he is not stupid. 
08:39:53 <copumpkin> I know that
08:39:55 <fasta> copumpkin, did you read his book? 
08:40:02 <copumpkin> he's a troll though :)
08:40:03 <copumpkin> nope
08:40:05 <fasta> It's not a perfect book. 
08:40:05 <applicative> fasta, he isn't stupid, but he's not that swift either
08:40:11 <copumpkin> it's expensive :)
08:40:20 <ski> applicative : well, sometimes if you have `e :: [] X', you're just thinking of this as a list of `X' values, that you do some computation on
08:40:22 <Saizan> geheimdienst: oh, sure, no one would use hylocombobuloid, but i took that as a parody of quite legitimate names like "hylomorphism"
08:40:23 <fasta> But it's better than the average book. 
08:40:30 <copumpkin> Yogi Book!
08:40:31 <applicative> i wish we could teach him haskell.  maybe i should arrange a trade i'll teach him haskell if he teaches me F#
08:40:36 <ksf_> the problem with compound words is that the reader/listener wants to understand the components, then.
08:40:39 <sbpaul> F# = death
08:41:05 <ksf_> don't go above two concepts per term.
08:41:13 <applicative> sbpaul, F# is that bad?  i thought it might be interesting, since I'm windows illiterate
08:41:14 <ski> applicative : other times, you're thinking of `e :: [] X' as representing different solutions of some nondeterministic operation (such as `permutations' or `subsequences', e.g.), and then i think the `[]'-terminology is appropriate
08:41:22 <fasta> Anyway, I think it is just popular to hate him. 
08:41:22 <sbpaul> windows = death
08:41:44 <fasta> Group think, etc. 
08:41:54 <copumpkin> fasta: oh good for you
08:42:02 <sbpaul> group think = death
08:42:04 <ski> applicative : well, `mote' makes me think of `emote' :) .. and `mobit' just sounds strange, to me
08:42:10 <applicative> fasta, i don't hate him, i've had many off list conversations with him. he becomes more rational the more you talk. maybe it's just that he wants attention in the ordinary sense. 
08:42:15 <fasta> As long as Haskell is not _faster_ than C, we should simply shut up. 
08:42:22 <applicative> mote makes me think of the bible, what is the text
08:42:25 <sbpaul> yesterday's committee,
08:42:28 <copumpkin> fasta: you tell us he's not stupid and that we shouldn't think he is, then come here and act superior because you don't engage in groupthink?
08:42:29 <sbpaul> sticks, but a broken drum
08:42:33 <sbpaul> midnight in the city,
08:42:37 <sbpaul> flutes in a vacuum
08:42:39 <sbpaul> shut lips, sleeping faces
08:42:44 <ski> applicative : the word "action" (as well as "computation") has a sensible interpretation for some monads. i'm just generalizing that word to apply to all monads
08:42:46 <fasta> copumpkin, I am not saying you engage in group think. 
08:42:56 <fasta> copumpkin, I am saying lots of people have no clue. 
08:43:05 <ksf_> ski, that's a leaky abstraction.
08:43:16 <fasta> copumpkin, you might then say I am "arrogant", but well, whatever. 
08:43:19 <copumpkin> fasta: true, but I got genuinely frustrated at him on reddit way before I knew of his reputation
08:43:20 <ksf_> you're oozing meaning all over the place.
08:43:25 <applicative> right, Sermon on the Mount of course:  	 And why beholdest thou the mote that is in thy brother's eye, but considerest not the beam that is in thine o
08:43:28 <applicative> thine own
08:43:31 <copumpkin> fasta: he's just an unpleasant character
08:43:39 <ski> ksf_ : i don't see how it's related to what i understand by "leaky abstraction"
08:43:40 <fasta> copumpkin, I don't know, I never met him. 
08:43:43 <copumpkin> and doesn't make good points about haskell
08:43:45 <applicative> pretty good lines in that sermon on the mount
08:43:48 <quicksilver> fasta: do you care about the fact that he talks rubbish and mixes truth with untruth for rhetorical effect in order to promote the things he chooses to promote?
08:43:49 <sbpaul> did you get my joke fasta 
08:43:50 <sbpaul> =-o
08:43:59 <ksf_> ski, well, I'm just generalising that term to natural language usage.
08:44:03 <copumpkin> there's low SNR in here
08:44:11 <sbpaul> he didn't get my joke...
08:44:13 <quicksilver> fasta: including stooping to the level of actual untruths about particular individuals, occasionally offensive.
08:44:21 <fasta> quicksilver, that is fairly annoying, yes. 
08:44:23 <applicative> And why beholdest thou the mote that is in thy brother's eye and not the type family that is in thine own
08:44:33 <copumpkin> fasta: anyway, read the few reddit comments he doesn't delete
08:44:35 <quicksilver> fasta: OK. THen we agree.
08:44:38 <fasta> quicksilver, maybe I only see the things that are true. 
08:44:48 <quicksilver> there are true things in the mix, no doubt.
08:44:51 <copumpkin> fasta: he ranges from unpleasantly true to outright misleading
08:44:53 <sbpaul>      "O brave  new world,"  he repeated. "O  brave new world  that has
08:44:53 <sbpaul>      such people in it. Let's start at once."
08:44:56 <ski> ksf_ : i don't follow ..
08:45:16 <copumpkin> sbpaul: ..
08:45:33 <fasta> quicksilver, anyway, the only way to get rid of it is to respond with code to each of his objections. 
08:45:40 <co_dh> who are we talking about? 
08:45:43 <quicksilver> I have chosen another path.
08:45:44 <sbpaul> filter (\x->ord x < 90) "copumpkin"
08:45:47 <quicksilver> I simply ignore it.
08:45:49 <sbpaul> > filter (\x->ord x < 90) "copumpkin"
08:45:50 <lambdabot>   ""
08:46:01 <quicksilver> it is my view that responding to each of his comments is a pointless (and very very tiring) endeavour.
08:46:02 <fasta> quicksilver, yes, I also do so, because I have more interesting things to think about. 
08:46:06 <sbpaul> > filter (\x->ord x < 100) "copumpkin"
08:46:06 <applicative> fasta, i don'tthink anyone disagrees with any substantive remark you are making.  His anti-Haskell obsession is nevertheless immoral and wrong
08:46:07 <lambdabot>   "c"
08:46:07 <ksf_> ski, the word "action" has such a strong semantic content that you can't just use it for something that's more or less not an action without having the meaning of "action" ooze into that of "monad".
08:46:13 <copumpkin> sbpaul: you done? 
08:46:18 <sbpaul> no...
08:46:27 <copumpkin> well, please be soon :P
08:46:28 <sbpaul> let me think
08:46:42 <applicative> ksf_ is right. action is out.  what bugs me is my hero mcbride plumping for 'computation' 
08:46:45 <sbpaul> > filter (\x->ord x < [95...130]) "copumpkin"
08:46:46 <lambdabot>   Not in scope: `...'
08:46:51 <jmcarthur> umm
08:46:51 <sbpaul> > filter (\x->ord x < [95..130]) "copumpkin"
08:46:52 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:46:52 <lambdabot>         against inferred type ...
08:46:54 <sbpaul> cmon...
08:46:54 --- mode: ChanServ set +o quicksilver
08:46:57 <copumpkin> sbpaul: quit it
08:47:00 --- mode: quicksilver set +b *!*sbpaul@unaffiliated/endolphin
08:47:00 --- kick: sbpaul was kicked by quicksilver (actualy, you are.)
08:47:05 <ksf_> quicksilver, you might want to consider answering only with variations on the theme "patches welcome"
08:47:16 <ksf_> computation has the same problems.
08:47:17 <BONUS> yeah, 'computation' is rather vague
08:47:20 <ski> ksf_ : how is `subsequences xs' in `do xs <- permutations "abcd"; ys <- subsequences xs; foo xs ys' not an action ?
08:47:40 <applicative> his argument, it was seeming is this is what the divine Moggi means by computation.
08:47:53 <ski> ksf_ : the action i'm thinking of is "nondeterministically select one of the possibly many solutions of this"
08:47:57 <applicative> it seems strange to speak of computation for [1,2,3], since it cannot be further evaluated.
08:48:15 <ksf_> see, and actions are usually graspable, deterministic things.
08:48:23 <ski> why ?
08:48:26 <ksf_> like "read a character". "set a variable"
08:48:33 <ksf_> dunno.
08:48:40 <ksf_> I'm merely querying my semantic database.
08:48:42 <applicative> ski, and what computation is (True, 1) or (False, 2)
08:48:52 <ski> "schedule a new thread, then later join the result" ?
08:49:06 <Nibble> @src filter
08:49:07 <lambdabot> filter _ []     = []
08:49:07 <lambdabot> filter p (x:xs)
08:49:07 <lambdabot>     | p x       = x : filter p xs
08:49:07 <lambdabot>     | otherwise = filter p xs
08:49:23 <monochrom> "monad as Moggi"
08:49:45 --- mode: quicksilver set -b *!*sbpaul@unaffiliated/endolphin
08:49:47 <applicative> thats it, not mote, not mobit; we'll call them moggis
08:49:48 <ski> applicative : well, since `(w,)' is a monad, if `Monoid w', it can be thought of as `(Bool,)'-actions (given that you choose the monoid, probably using `Any' or `All' instead of `Bool')
08:50:01 <ManateeLazyCat> @seen morrow
08:50:01 <preflex>  Sorry, I haven't seen morrow
08:50:01 <lambdabot> Unknown command, try @list
08:50:08 <BONUS> i always liked 'value with a context'
08:50:24 <ski> applicative : another question is whether it is *useful* to think of `(True,1)' as a monadic action in the context where it is used
08:50:29 <ManateeLazyCat> @see morrow
08:50:29 <lambdabot> Maybe you meant: free let src
08:50:29 <BONUS> the context can be side-effects, actions, non-determinism, etc.
08:50:38 <BONUS> preflex: seen mmorrow
08:50:38 <preflex>  mmorrow was last seen on #ghc 225 days, 12 hours, 52 minutes and 53 seconds ago, saying: * mmorrow is rtfm'ing
08:50:39 <ski> preflex: xseen mmorrow
08:50:39 <preflex>  mmorrow was last seen on freenode/#ghc 225 days, 12 hours, 52 minutes and 54 seconds ago, saying: * mmorrow is rtfm'ing
08:50:41 <applicative> ski, are you sure you can carry this through for all the monads?  there are countably many....
08:50:52 <ManateeLazyCat> 225 days...
08:50:56 <Saizan> BONUS: value with a context sounds more like comonad :)
08:51:11 <BONUS> Saizan: because of the 'co'? :)
08:51:13 <applicative> Saizan, that's what i would have said.
08:51:14 <ski> applicative : yes. it's a parametric definition that applies to all monads
08:51:21 <ksf_> .oO( first-class patterns )
08:51:31 <geheimdienst> "value with a ntext"
08:51:36 <ski> BONUS : probably because of the so-called "state-in-context" comonad
08:51:47 <applicative> ski, wait, so whats the general def that reveals how they're all actions?
08:51:50 <Saizan> BONUS: because of extract :: w a -> a, the free comonad, zippers, etc.. :)
08:51:58 <sbpaul> ok copumpkin 
08:51:59 <sbpaul> i did it
08:52:00 <sbpaul> are you ready
08:52:02 <BONUS> ah
08:52:04 <EvanCarroll> is there a channel for snap?
08:52:10 <Twey> EvanCarroll: #snapframework
08:52:15 <applicative> yes, snapframeword 
08:52:18 <applicative> fugue
08:52:19 <ManateeLazyCat> Bye all, night! :)
08:52:21 <ksf_>                             (\(X :& SetX := f) -> f newx) (narrow self)
08:52:21 <ksf_> is  no sane way to call an object method.
08:52:25 <copumpkin> sbpaul: you did what?
08:52:26 <sbpaul>  map (\y->filter (\x->ord x< y) "copumpkin") [99..119]
08:52:30 <sbpaul> > map (\y->filter (\x->ord x< y) "copumpkin") [99..119]
08:52:31 <lambdabot>   ["","c","c","c","c","c","c","ci","ci","cki","cki","cmki","cmkin","comkin","...
08:52:36 <sbpaul> @more
08:52:39 <ski> applicative : the definition is just that whenever `e :: M X' (for a monad `M'), i'm allowing `e' to be described by the term `M'-action
08:52:44 * sbpaul kicks the bot
08:52:45 <copumpkin> sbpaul: okay, good, can you stop spamming now? :)
08:52:51 <sbpaul> spam is advertisement
08:52:53 <ski> s/the definition/my definition/
08:52:56 <sbpaul> not everything you don't like seeing, thx
08:53:07 <copumpkin> sbpaul: spam is stuff that is not interesting to the over 600 people in here
08:53:14 <sbpaul> yeah yeah
08:53:16 <applicative> ski, right, that's just to say, you write 'action' where ksf writes 'mobit' and whatshisname writes 'mote'
08:53:17 <ksf_> but then, being able to pattern match records, with automagic reordering+dropping of fields, is a _very_ neat feature.
08:53:55 <applicative> BONUS got me over the wierdness of calling [1,2,3] and getLine 'monads'.
08:54:11 <copumpkin> sbpaul: take it seriously :P we're friendly in here but we like to keep it on-topic (which might include category theory, theoretical CS, or various other forms of math)
08:54:20 <BONUS> i did?
08:54:22 <sbpaul> yes i've been in here before
08:54:24 <ski> applicative : indeed. i just happen to think generalizing the word "action" from a few monads to all sounds more sensible than inventing the words "mobit" or "mote" .. you are of course allowed to disagree
08:54:25 <applicative> since he did it even with Functor, which seems more insane.  "a functor is something you can map over -- like [1,2,3]
08:54:27 <sbpaul> BONUS: finish the tutorial!
08:54:37 <copumpkin> sbpaul: just making sure
08:54:44 <copumpkin> since you were making quite a bit of noise before :)
08:54:46 <ski> applicative : well, `getLine' is not a monad ! :) `IO' is a monad
08:54:50 <applicative> then i realized i couldd make sense of this use, it took a little mental training. 
08:54:55 <sbpaul> you're making the noise
08:55:03 <BONUS> sbpaul: on it!
08:55:13 <sbpaul> you need to write about A) monads B) something else
08:55:27 <sbpaul> uhh...zippers
08:55:35 <BONUS> sbpaul: maybe you'd be interested in this: http://learnyouahaskell.com/monads
08:55:41 <sbpaul> oic
08:55:44 <sbpaul> this is new...
08:55:58 <ski> applicative : another term than "action" for things like `getLine' is "monadic value"
08:56:05 <applicative> where you say [1,2,3] or ("spam",30) is a functor. Its like saying [1,2,3] is a list, or ("spam", 30) is a tuple, only with an additional abstraction
08:56:07 <copumpkin> BONUS: you should use the monads as unicorns analogy ;)
08:56:10 <BONUS> i prefer monadic value
08:56:13 <BONUS> hehe
08:56:32 <ksf_> monads are burritos. end of discussion.
08:56:38 <ski> BONUS : how do you say when you want to specify which monad you're talking about ?
08:56:48 <applicative> it's like saying this zebra is an animal, that zebra is an animal; this elephant is an animal, that elephant is an animal.  But then
08:57:14 <BONUS> ski: that depends. for maybe i say a maybe value, for [] i say a list, etc.
08:57:16 <applicative> at the zoo, you can say, these are the same animal ( the zebras); wait, here's another animal ('the Elephant')
08:57:17 <ksf_> this elephant is a zebra.
08:57:31 <BONUS> usually i'd say: a <type> value
08:57:40 <applicative> elephants are all the same animal, lists are all the same functor.
08:57:44 <ski> applicative : neither `[1,2,3]' nor `("spam",30)' is a functor. the types `[]' and `(String,)' are functors, though
08:58:05 <applicative> but in another sense, elephants are different animals and [1] and [1,2] are different lists. 
08:58:30 <applicative> [] isn't a type its a type constructor; you are making the same mistake you are attacking
08:58:36 <copumpkin> BONUS: "Later on, we'll see how to modify this function so that we also pass it the number of moves to take instead of that number being hardcoded like it is now."
08:58:40 * geheimdienst likes cats and would prefer an explanation in terms of cats and lolcats
08:58:41 <applicative> or am i wrong?
08:59:01 * ksf_ thinks one should use a metasyntactic variable instead of "thing"
08:59:14 <sbpaul> geheimdienst: (\x->Just (x++"cat")) "lolcat"
08:59:16 <BONUS> copumpkin: what about that
08:59:19 <sbpaul> > (\x->Just (x++"cat")) "lolcat"
08:59:20 <lambdabot>   Just "lolcatcat"
08:59:32 <copumpkin> BONUS: did you do that? or did you mean later on in a future chapter?
08:59:43 <BONUS> later in the next chapter
08:59:48 <applicative> but any way, lets say [] and (String,) are functors.  Now interpret it as like "animal" in the zoo keeper sense, where you might not count another zebra, since youalready counted zebras.
08:59:49 <ski> applicative : imo, `Int', `[]' and `Maybe' and `Either' are type constructors (as well as being types, not necessarily with kind `*'), while `[] Int' and `Maybe (Bool,Char)',`Either String',`Either (Bool -> Int) String' are all just types
08:59:55 <copumpkin> BONUS: oh I see :)
08:59:55 <BONUS> gonna do a foldr compose with >=>
09:00:02 <copumpkin> BONUS: sounds cool :)
09:00:18 <ski> applicative : i.e., i find it strange to use "constructor" in "data constructor" in one sense, but "constructor" in "type constructor" in another sense
09:00:30 <ksf> cf. "Such a value is called a thing. The type parameter @thing@ maps record types to the types of their corresponding things."   to     ""Such a value is called a foo. The type parameter @foo@ maps record types to the types of their corresponding foos."
09:00:48 <ksf> as in "yes I admit I was too lazy to think of a name"
09:00:48 <applicative> then IN ONE SENSE you will say, [1] and [1,2] are the same animal/functor; ("spam"3) and ("HAHAHA",5) are the same animal/functor. 
09:01:09 <ski> applicative : i would compare "functor" to "animal species", not to "animal"
09:01:31 <monochrom> "encounter with types of the 3rd kind"
09:01:32 <applicative> IN ANOTHER SENSE [1] and [1,2] are different animals/functors -- namely different lists, as these to are different animals, viz different zebras
09:02:00 <BONUS> i think we can all agree that getting monadic terminology right is hard. at least when you also want to combine it with some way to concisely express statements about them
09:02:06 <ski> applicative : yes. that's a good reason for not saying `[1,2]' is a functor
09:02:37 <applicative> ski, exactly, except there is a deeply entrenched use where you can call the species itself an animal, and not that pointing to an indiv animal can also be pointing to the species.  "We've had this animal in the zoo for a hundred years", but its a rodent that lives for two....
09:03:18 <ski> applicative : yes. i'm simple wanting to reserve "functor" and "monad" for the type-level things, to avoid this kind of confusion
09:03:28 <applicative> sorry, i'm just explaining the origin of the use that appears (even) in BONUS; when I thought it through, i thought it was validated.
09:03:39 <ski> (also, that's how the words are used in the original Category Theory context)
09:03:46 <applicative> ski, but it isn't a confusion, is the zookeeper confused?
09:04:05 <ski> applicative : i'm not sure what you're asking about
09:04:27 <applicative> ski, that's whats surprising, the use the OP for the reddit tempest-in-a-teapot was calling it a confusion to call [1] a monad
09:04:58 <applicative> but it isn't, once you think it through.  the underlying grammar  is one you don't expect to break out here, that's all
09:04:58 <sbpaul> you guys must be using a different reddit than me
09:05:06 * ski has not looked at any reddit page in a while
09:06:11 <fasta> ski, what do you read now, if anything?
09:06:16 <applicative> ski, the question is: is a zookeeper confused if he's 'counting animals' and doesn't count a zebra he faces, because he already counted a zebra, saying, "I already got that animal", but then he increments his count when he sees an elephant, since he 'hasn't counted that animal'
09:06:34 <ski> applicative : it is a confusion, just as it is a confusion to use "animal" to refer to both the species as well as particular individuals. yet we usually cope with this in natural language, sometimes requiring disambiguation
09:06:48 <BONUS> it also depends on the didactic context. im aware that types are functors, not values, but when explaining stuff in the tutorial, at least in the beginning, i take some liberties wrt terminology so that it's easier for the reader to comprehend
09:06:53 <applicative> the same 'ambiguity' arises with counting letters on a page.  How many letters are in "HAHAHAHAH"?
09:07:20 <ski> applicative : otoh, in a programming context, we often want to be more clear what we're talking about exactly. especially if the area is new and confusing to newbies
09:07:25 <BONUS> later on with monads, for example, i strictly keep the terms "monad" and "monadic value" separate
09:07:49 <applicative> I might count, "H", that's one; "A", that's two; "H" already got it, etc.. ergo, two letters in "HAHAHAHAH"
09:08:47 <applicative> Quine points out that if "HAHAHAHAH" is considered not as a bit of ink on the page, but the well known string, which can be printed anywhere,
09:08:52 <applicative> then the only way to get 
09:08:53 <sbpaul> http://www.networkworld.com/news/2010/083010-open-source-voip-cell-phones-at-burning-man.html
09:08:56 <ski> applicative : i.e., when i say that i've got a function that for any monad does FOO : i never mean that it does FOO, given a *value* of type `M X' for some monad `M' and type `X', but rather just that it does FOO, for any monad `M' (which is not a value but a type)
09:08:58 <applicative> > length "HAHAHAHAH"
09:08:59 <lambdabot>   9
09:09:08 <applicative> is to count "initial segments ending in a letter"
09:09:21 <ski> applicative : i.e. `foo :: Monad m => ..m..', rather than `foo :: M X -> ...'
09:09:42 <BONUS> i think ultimately knowing how to identify and use functors/applicatives/monads is much more important than getting the terminology right formally. at least when it comes to programming
09:09:56 <sbpaul> when is that not true BONUS ;)
09:10:14 <BONUS> well if you're doing theoretical stuff maybe?
09:10:32 <quicksilver> BONUS: on the other hand, if you're writing a book/tutorial you need to find a terminology you're happy with to explain it to people
09:10:34 <ski> BONUS : yes. but i happen to think that to get a grasp of the basics, it helps to separate these things strictly :)
09:10:42 <ski> quicksilver : yes
09:10:51 <quicksilver> (and indeed to simply discuss them on an IRC channel)
09:10:54 --- mode: quicksilver set -o quicksilver
09:11:08 <Entroacceptor> how someone learns somthing is mostly up to them
09:11:12 <applicative> ski, functions don't act on monads themselves, unless we speak of (* -> * ) ->  * things as functions
09:11:32 * ksf decides he needs to eat more cake and play more spring to solve this.
09:11:42 <ski> applicative : `(* -> *) -> *' is the kind of types which are type-level functions, yes
09:11:54 <applicative> well, having achieved total lucidity, I propose to rename monads themselves, not 'warm fuzzies' but "animals"
09:12:08 <applicative> a Maybe is a whole nuther animal from a List
09:12:34 <BONUS> quicksilver: true. going over the editing process in lyah, im being quite careful to keep the terminology consistent
09:12:56 <BONUS> so these errors in terminology should be revised soon
09:13:04 <applicative> ski, but your foo was foo:: m a -> ....
09:13:05 <ksf> applicative, they are, in fact, proto-quasiisomorphic animals.
09:13:09 <ski> applicative : and, in `foo :: Monad m => ..m.. -> ..m..', `foo' *is* a function that "acts on monads"
09:14:09 <ski> applicative : in Agda2, it'd be phrased `foo : (m : Monad) -> ..m.. -> ..m..', so here, the monad `m' (like `Maybe', e.g.) is an argument to the function, so the function "acts" on the monad
09:14:11 <applicative> ski, yes, but only if you think of functions at the type level, which is itself a bold piece of linguistic stretching, akin to calling [1] a monad
09:14:25 <applicative> ski, yes
09:14:46 <ski> applicative : no, the `foo :: M A -> ...' was the one i was claiming i'd *not* describes as "acting on a monad"
09:15:02 <applicative> ski, i of course see how to see (* -> *) -> * things as 'functions', but they're not echt haskell functions, there is an analogy.
09:15:22 <applicative> ski, sorry, i did mean to add the type constraint. 
09:15:41 <ski> yes (but the `foo :: Monad m => ..m.. -> ..m..' example wasn't about this. `foo' here is a value-level function that "acts on monads")
09:16:21 <applicative> BONUS, just make sure to keep saying "A functor is something you can map over" and then give map (+1) [1,2,3] as an example....
09:16:23 <applicative> :)
09:16:53 <applicative> ski, wait, i have to reread what you said, sorry. just a sec
09:17:08 <BONUS> hehe
09:18:00 <wli> The substitution monad example from springschool95.ps did wonders for me.
09:18:19 <ski> wli : link ?
09:19:19 <applicative> ski, i'm missing something in your example: "applicative : i.e., when i say that i've got a function that for any monad does FOO : i never mean that it does FOO, given a *value* of type `M X' for some monad `M' and type `X', but rather just that it does FOO, for any monad `M' (which is not a value but a type)"
09:19:27 <ski> applicative : hm, possibly what i said above might be a bit confusing, because i was discussing several distinct points, interleaved with each other (in response to things you were saying)
09:19:47 <applicative> the topic is a bit of a mess.  ....
09:20:05 <ski> consider
09:20:41 <ski>   foo :: Monad m => Int -> [m X]
09:20:56 <ski>   bar :: m X -> IO ()
09:21:33 <ski> er, that should be
09:21:37 <applicative> "We recently met functors, which are basically things that can be mapped over. "
09:21:38 <ski>   bar :: M X -> IO ()
09:21:50 <ski> (for some specific `M', such as `Parser' or something)
09:21:57 <ski> i could describe `foo' as " function that for any monad does FOO"; but i'd not describe `bar' that way
09:22:37 <applicative> ski, right, it does foo for any animal
09:22:43 <ski> (where "FOO" is an abbreviation for what the function actually happens to do)
09:22:48 <applicative> bar does bar for any of those M animals
09:22:49 <ski> right
09:23:25 <ski> so, when i say it does "FOO" for any monad, i'm specifically meaning that it can work with any type `m' which is in class `Monad'
09:23:39 <applicative> (substituting "animal" for "monad", but taking "monad" in the allegedly vulfar way in the second sentence about bar)
09:23:43 <ski> not that it takes a "monadic value"/"action"/"computation" in a monad as an argument
09:24:14 <applicative> it takes the species as 'argument', not the individual.  
09:24:25 <applicative> it takes the animal as argument, not the animals
09:26:04 <ski> (i'm not sure if by "it takes the animal as argument, not the animals" you mean it takes a species as argument, or you mean it takes an instance of a species as argument -- see how natural language is ambiguous ? ;)
09:26:26 <applicative> ski, your foo takes a species of mote as argument; bar takes individual motes as arguments.
09:26:37 <ski> yes
09:27:10 <applicative> ski, it's wrong to speak of an ambiguity, its so deeply entrenched, it is discusses in cog sci  and phil. of languageall the time
09:27:26 <ski> well, that sentence was ambiguous to me :)
09:27:28 <applicative> the effort to make a distinction will be deeply involved with the so-called confusion
09:28:06 <applicative> the appearance of ambiguity arises not from the sentence itself, but from the presence of a distinction in your thought.  this distinction is optional, and a separate achievement
09:28:16 <ski> i don't disagree
09:29:05 <applicative> if you think about counting letters, you will see how hopeless the task of 'disambiguating' is.  it's not confusion not to have effected this disambiguation and recorded it in terms like 'species' v 'indiv' or 'type' and 'token' or whatever
09:29:12 <ski> i just want to avoid this, when discussing abstract things like programming and math, where we need to be clear about which alternative we want
09:30:10 <applicative> yes, but this just means getting the distinction into words, rather than in the way you combine them
09:30:33 <applicative> i cant remember what linguists call this , it's like grammaticalizing, maybe lexicalizing.
09:30:46 <ski> (i'm not claiming this "ambiguity" is inherently bad, or without reason or purpose. i just want to avoid it in this context)
09:31:14 <ski> anyway, we're straying a bit far away from Haskell atm (though it is an interesting topic, in a sense)
09:31:22 <ski> .. and i need to leave
09:31:46 <applicative> ski, i don't disagree, i started with your position.  my effort was to show that the supposedly stupid use of 'monad' as applying to [1,2,3] follows a fundamental operation of the human mind, one that's indispensible.
09:32:41 <ski> and i don't disagree with that. i just want to erect the distinction here
09:32:49 <ski> anyway, ty for the discussion
09:32:51 <applicative> boy, i get on here in the hope of helping with some elementary type error, and i end up making an insane harangue.  apologies....
09:32:53 * ski has to run
09:47:38 * hackagebot libmpd 0.4.2 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.4.2 (JoachimFasting)
09:48:05 <tommd> bos: ping
09:49:06 <__debaser> Hey everyone, is there a way to have colored output in ghci?
09:50:16 <Saizan> pipe it through hscolour?:)
09:50:23 <monochrom> haha
09:50:41 <monochrom> prompts like "Prelude>" will confuse it.
09:50:58 <monochrom> error messages will confuse it too. hpaste has lots of examples.
09:50:58 <BONUS> i dont think there's a way that isn't error prone and retarded
09:51:25 <monochrom> all human contortions are error-prone and retarded. exterminate all humans.
09:51:35 <BONUS> but i wonder if that would be hard to make
09:51:36 <__debaser> BONUS: That's really sad because the examples in your book look amazing
09:51:54 <tommd> @tell bos Re: crypto-api.  If you wouldn't use the RandomGen class what do you suggest?  I'm all in favor of better Random support but don't want to rock the boat so much that users of MonadRandom can't use the crypto-api easily.
09:51:55 <lambdabot> Consider it noted.
09:51:56 <BONUS> hehe yeah they do look nicer than your normal ghci output
09:52:23 <BONUS> i wonder if it would be hard to make a program that interfaces with ghci and colorizes all the output it gets from it
09:53:12 <tommd> ALL: I'll be releasing crypto-api pretty much unchanged from the previous blog post unless someone has something particularly damning to say. http://tommd.wordpress.com/2010/08/23/a-haskell-api-for-cryptographic-algorithms/
09:53:21 <Nibble> hmm
09:53:22 <Nibble> class Show a => Message a where
09:53:27 <Nibble> shouldn't that be (Show a)
09:53:30 <Nibble> or doesn't it matter?
09:53:37 <__debaser> Then you could say that Haskell is not only expressive etc. bur colorful :-D
09:53:44 <BONUS> haha
09:54:21 <__debaser> probably would make functional programming much less scary to newbies
09:55:04 <BONUS> tryhaskell.org makes interactive haskell really friendly
09:55:56 <__debaser> BONUS: That's true, thanks, I didn't know that site
09:56:04 <geheimdienst> i don't think at all colored ghci is a newbie thing. i mean, what serious haskell programmer uses no syntax-highlighting and all-black text?
09:56:22 <monochrom> I do.
09:56:32 <BONUS> syntax coloring is usually done with regexen, right?
09:56:40 <applicative> if i'm trying to build ghc HEAD so it'll generate llvm code, do I need to add a special flag?  
09:56:43 <sbpaul> > reverse "<BONUS> tryha­skell.org makes­ inter­active haske­ll reall­y frien­dly"
09:56:44 <lambdabot>   <no location info>:
09:56:44 <lambdabot>      lexical error in string/character literal at chara...
09:56:44 <monochrom> I only let my irc software colour nicks.
09:56:47 <sbpaul> => "yldneirf yllaer lleksah evitcaretni sekam gro.lleksahyrt >SUNOB<"
09:56:51 <sbpaul> it told me to
09:56:53 <BONUS> haha
09:57:31 <sbpaul> monochrom: do you have the irssi one
09:57:45 <BONUS> that reminds me of an interesting thing. 78% of haskell programmers expect 'reverse ">>="' to return "=<<"
09:57:54 <BONUS> > reverse ">>="
09:57:54 <lambdabot>   "=>>"
09:58:05 <sbpaul> 78%?
09:58:14 <BONUS> totally made up statistic
09:58:17 <sbpaul> lol
09:58:17 <geheimdienst> why does reverse "d" not return "b"
09:58:42 <monochrom> because reverse is a natural transformation, enjoys free theorems.
09:58:53 <monochrom> @free reverse
09:58:53 <sbpaul> we need a "reverse" for text
09:58:54 <lambdabot> $map f . reverse = reverse . $map f
09:59:04 <sbpaul> or you know the javascript one, where it makes the text upside down
09:59:10 <sbpaul> we need that
09:59:24 <monochrom> it dares not change d to b, for fear of some f knowing the difference
09:59:44 <c_wraith> @check \x -> x == reverse x
09:59:45 <lambdabot>   "OK, passed 500 tests."
09:59:51 <c_wraith> I still love that. :)
09:59:58 <monochrom> hahaha
10:00:25 <BONUS> how does that pass O_O
10:00:36 <sproingie> it's dumb about how it generates tests
10:00:49 <monochrom> probably testing a million examples of type [()]
10:00:54 <geheimdienst> so it doesn't pass in Strings, only Chars?
10:01:08 <BONUS> now i've seen everything *shoots self*
10:01:09 <geheimdienst> er i mean Strings of length 1
10:01:15 <BONUS> but yeah
10:01:22 <BONUS> > reverse (replicate 5 ())
10:01:23 <lambdabot>   [(),(),(),(),()]
10:01:24 <sproingie> it should use random data by default
10:01:35 <sproingie> but doesn't
10:01:40 <monochrom> yeah, it uses random data already.
10:01:48 <monochrom> randomly drawn ()'s :)
10:01:51 <luite> it shouldn't default to ()
10:02:18 <monochrom> right, it chooses a wrong type.
10:02:20 <Veinor> @check \x -> (x :: String) == reverse x
10:02:21 <lambdabot>   "Falsifiable, after 1 tests:\n\"\\657978\\1091591\"\n"
10:02:26 <tommd> @check \x -> x == reverse (x :: [[()]]) -- Yeah, () is a rather bad default, [()] makes lots more sense!
10:02:27 <lambdabot>   "Falsifiable, after 2 tests:\n[[(),(),()],[(),()],[(),(),()],[()]]\n"
10:02:32 <luite> hehe
10:02:52 <Veinor> tommd: well, [[()]] is the same thing as [Int] if you think about it
10:02:57 <tommd> Yep
10:03:14 <sproingie> yah [x] will at least give you random lengths
10:03:18 <tommd> But peano numbers are cool
10:03:35 <sproingie> should default to a randomly chosen type
10:03:51 <sproingie> or choose random types for each test
10:04:04 <tommd> Why limit it to types?  Random kinds!
10:04:18 <Saizan> random language!
10:04:31 <sproingie> random axioms!
10:04:41 <sproingie> given 1 == 2
10:04:47 <Saizan> it could randomly pick a different test to run, even
10:05:05 <sproingie> or randomly decide to run at all.  one step closer to AI
10:05:20 <mee> "the only way to pass is not to play at all"
10:05:20 <luite> and it should generate random properties
10:06:23 <Entroacceptor> random randomness
10:06:43 <luite> it should make its own entropy
10:06:52 <Entroacceptor> so it can check if it's still the correct universe, too
10:13:57 <chrisdone> kappla!
10:14:51 <bos> dons: around?
10:14:51 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
10:15:31 <geheimdienst> it's qapla', dude
10:18:21 <chrisdone> > length "qapla'" == "kappla"
10:18:22 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:18:23 <lambdabot>         against inferred type ...
10:18:26 <chrisdone> > length "qapla'" == length "kappla"
10:18:27 <lambdabot>   True
10:19:11 <geheimdienst> > length "qapla'" == length "qoppa"
10:19:12 <lambdabot>   False
10:31:15 <roconnor> a monoid is only defined in a monoidal catagory
10:31:19 <roconnor> that is kinda confusing
10:31:40 <dolio> You need the structure of a monoidal category to define it.
10:31:46 <roconnor> yep
10:32:14 <roconnor> but the tensor is not the binary operation of a monoid
10:32:16 <dolio> Groups need categories with products.
10:32:34 <roconnor> I guess it is like how the cross product is not the binary operation of a monoid either
10:33:13 <Cale> A (strict) monoidal category is a monoid object in the monoidal category Cat ;)
10:34:18 <geheimdienst> that's gotta be the least explanative explanation since "monoid in the category of endofunctors" :)
10:34:34 <JHoglund> Hi! I'm having some problems with the "do" notation, which I just cannot get to work, can anyone please point me in the right direction? http://pastebin.com/u4c4W8GV
10:34:37 <roconnor> Cale: I cry foul on your impredicative definition! :P
10:35:09 <c_wraith> JHoglund, you need to use "let" to declare a name inside a do block
10:35:28 <Nibble> JHoglund: swe?
10:35:28 <c_wraith> and you don't specify the type in part of the declaration
10:35:35 <JHoglund> c_wraith: Ahh! Thanks! So, "let" is always used for variable assignement?
10:35:36 <Cale> JHoglund: What's that Int data constructor doing there? :)
10:35:38 <JHoglund> Nibble: Yes
10:35:41 <c_wraith> that is, change "Int ..." to "let ..."
10:35:50 <Nibble> JHoglund: how did I guess that ;)
10:36:00 <Nibble> JHoglund: I am also guessing your name is Jonas.
10:36:03 <Nibble> or johan
10:36:07 <Cale> JHoglund: let is used to make local definitions of names, and <- is used to execute actions and give names to their results
10:36:18 <JHoglund> Nibble: Well, there cant be too many student studying Haskell ;) And you are wrong, I'm Johan
10:36:25 <Nibble> JHoglund: I wrote or Johan
10:36:28 <Nibble> :P
10:36:38 <ben_m> /whois, dude
10:36:43 <Nibble> ben_m: I didn't use it.
10:36:44 <kmc> JHoglund, it's not really "variable assignment" like most languages have.  it just provides a local name for an expression
10:36:53 <Cale> JHoglund: When you write  let x = y  in a do-block, it means to define x to be the same value as y.
10:37:05 <kmc> in Haskell, = usually means = ;)
10:37:13 <BONUS> thing is that also has a few other errors i think. JHoglund what are you trying to accomplish with this piece of code?
10:37:17 * kmc has a complaint with "data" syntax for breaking this rule
10:37:27 <Cale> (Not to write the value y into some box named x)
10:37:31 <kmc> (esp. with record selectors)
10:38:13 <JHoglund> kmc: Allright, In the first version of my code, I just used a long expression, however, I need to test the outcome of that expression to return either the expression or "0", do you know if I am using the right approach?
10:38:32 <kmc> JHoglund, how about «return (if x == 10 then 0 else x)»
10:38:32 <Cale> JHoglund: And when you write x <- y, it means that, as part of the action you're describing, to run the action y, and simply to name its result x in whatever follows (again, not to write the result into a box named x)
10:39:20 <Cale> JHoglund: There's nothing in your code so far which warrants the use of do-notation at all.
10:39:56 <JHoglund> Cale: To shorten my expressions, as the lines tend to get quite long, is it a good idea to create "local definitions of names", like I would create a variable in an imperative language?
10:40:04 <kmc> JHoglund, you would use just "let" for that
10:40:12 <Cale> Note that if you want to make local definitions, you can just use  let <decls> in <expr>
10:40:21 <kmc> let x = (10 - read .... whatever ...) in return (if x == 10 then 0 else x)
10:40:22 <Cale> Or add a where clause to your definition
10:40:24 <kmc> err
10:40:26 <kmc> let x = (10 - read .... whatever ...) in (if x == 10 then 0 else x)
10:40:56 <kmc> in fact you can drop those last parens
10:41:09 <kmc> the word "return" is not a keyword, it's an ordinary function and i don't think you need it here
10:41:12 <JHoglund> kmc: Uhm, you are testing for the value x in your example. I'd like to test for the value returned by the expression, not the argument x
10:41:23 <kmc> the argument is n, not x
10:41:29 <kmc> x is a locally bound name for (10 - read ... whatever ...)
10:41:34 <kmc> that's what "let" does
10:41:49 <kmc> JHoglund, as a beginner you should probably treat "do" as a special syntax for building IO-actions, or avoid it entirely and use (>>=)
10:42:01 <BONUS> JHoglund: also take a look at digitToInt from Data.Char
10:42:07 <BONUS> > digitToInt '9'
10:42:08 <lambdabot>   9
10:42:12 <BONUS> > map digitToInt "908234"
10:42:13 <lambdabot>   [9,0,8,2,3,4]
10:42:20 <kmc> "do" is not appropriate when all you want is to make some local names for expressions
10:42:49 <JHoglund> kmc: Allright, I'm not in to some fishy IO just yet :)
10:42:59 <kmc> ok
10:43:17 <JHoglund> BONUS: Ahh! That would save me a lot of creating lists to "read" :D
10:43:24 <kmc> the real story is that "do" syntax is just sugar for this function (>>=), and that function works with any type in a particular type class
10:43:28 <kmc> IO is just one of many types it works with
10:43:38 <Nibble> JHoglund: do is just sugar
10:43:46 <jrockway> kmc: good advice
10:43:52 <Nibble> oh
10:43:54 <Nibble> he wrote that
10:44:08 <BONUS> also: if x == 10 then 0 else x, you can do that with x `mod` 10
10:44:09 <jrockway> haskell is much easier to understand when you realize that >>= is just a function
10:44:12 <BONUS> i think
10:44:17 <kmc> (and IO is actually a poor / misleading example of such a type, but the one that people run into first usually)
10:44:19 <jrockway> do hides that and leads you to believe it's magic
10:44:26 <kmc> yeah
10:44:35 <bos> preflex: seen dons
10:44:35 <preflex>  dons was last seen on #ghc 2 hours, 15 minutes and 3 seconds ago, saying: we climbed up to the top of the cathedral tower
10:44:38 <kmc> there's lots of misinformation too
10:44:43 <jrockway> and the result... monad tutorials
10:45:18 <BONUS> JHoglund: http://pastebin.com/90GuA1Wu <-- i think this would work
10:45:37 <kmc> like the claim that IO somehow provides an exception to the "all functions are pure" rule
10:45:44 <BONUS> read it from right to left: take luhnmulti n, then map digitToInt over that, then sum that result, then show that result, etc.
10:46:05 * BMeph suggests that the 'IO' Monad be renamed to 'WFT', for 'Warm, Fuzzy Thing.' Also, because it offers the opportunity for fumble-fingered newcomers to type it as "the 'WTF' Monad" which is fitting for its semantics. :D
10:46:16 <kmc> heh
10:46:20 <BONUS> haha the WTF monads
10:46:27 <BONUS> s/s//
10:46:33 <jrockway> hey, it's just IO a = ST RealWorld a
10:46:39 <geheimdienst> s/IO/Misc/
10:46:43 <jrockway> i mutate the realworld all the time!
10:46:51 <geheimdienst> s/IO/AllKindsaStuffReally/
10:47:06 <jrockway> "i reject your realworld and substitute my own"
10:47:08 <kmc> shhh jrockway don't give away the terrible secret of space
10:47:28 <geheimdienst> s/IO/EverythingAndTheDog/
10:47:28 <kmc> hehe that's a decent description of how unsafePerformIO is implemented
10:47:33 <JHoglund> BONUS: Thanks! It's a bit clearer, I have to admit ;)
10:47:34 <kmc> (and runST too, they are basically the same at runtime)
10:47:37 * Cale hates the RealWorld analogy for IO
10:47:48 <jrockway> yeah
10:47:56 <jrockway> i had to dig around in that code recently
10:48:03 <geheimdienst> cale, how do you feel about the EverythingAndTheDog analogy for IO?
10:48:16 <kmc> the RealWorld analogy for IO is pretty far from the (State# RealWorld) implementation in GHC
10:48:24 <Cale> The GHC implementation of IO is pretty unenlightening for beginners too.
10:48:40 <kmc> yeah
10:48:50 <c_wraith> the GHC implementation for IO is actually incredibly dirty underneath.  It's good that it presents a clean interface
10:48:53 <kmc> yup
10:48:54 * BMeph wonders if Cale hates the RealWorld as much as the MTV show with almost the same name...and if that fact about that show is just an eerie coincidence.
10:49:12 <kmc> that's the irony of this "IO is a tag for impure functions" misconception
10:49:35 <roconnor> a convinient misconception
10:49:48 <Cale> I've never seen the MTV show by that name, but I'd probably hate it.
10:49:55 <monochrom> IO: an inconvenient truth
10:49:56 <c_wraith> You would.  It's awful
10:50:01 <roconnor> @wiki IO_Semantics <-- one example of how to implement IO
10:50:01 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics_<--_one_example_of_how_to_implement_IO
10:50:03 <BMeph> roconnor: An "ill-conceived" misconception? ;)
10:50:17 <roconnor> @wiki IO_Semantics
10:50:18 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
10:50:25 <roconnor> ^^ one example of how to implement IO
10:50:30 <jrockway> haha
10:50:38 <monochrom> there are lies, damn lies, and tutorials
10:50:47 <BONUS> lol
10:50:58 <Cale> http://vimeo.com/14069325 -- is anyone else just getting a black rectangle here?
10:51:02 <BONUS> @remember lies  there are lies, damn lies, and tutorials
10:51:02 <lambdabot> Nice!
10:51:08 <BONUS> @quote lies
10:51:08 <lambdabot> lies says:  there are lies, damn lies, and tutorials
10:51:13 <BONUS> oh uhh
10:51:15 <roconnor> Cale: wow, I thought you liked the RealWorld analogy for IO.
10:51:23 <BONUS> i did it wrong
10:51:26 <monochrom> just change it to "lai says" :)
10:51:33 <roconnor> Cale: oh right, you like the term algebra for IO.
10:51:50 <roconnor> well, at least it is better than the RealWorld non-sense.
10:52:18 <kmc> i like the GADT implementation of IO
10:52:18 <Cale> roconnor: Yeah, any of the styles of term algebra for IO.
10:52:22 <luite> Cale: yep black rectangle (chrome)
10:52:30 <kmc> with the magical (defined outside Haskell) execution engine that pattern-matches those terms
10:52:41 <Heffalump> kmc: that's not really an implementation. More a definition.
10:52:50 <kmc> yeah
10:52:57 <kmc> a definition, a model, and perhaps a viable implementation strategy
10:53:03 <Heffalump> or rather, more a syntax tree definition, nothing else
10:53:16 <roconnor> kmc: I don't like the GADT implemenation, because all the hard work is moved into the interpretation function, which is coveniently omitted from the discussion. :(
10:53:31 <roconnor> Heffalump: exactly
10:53:36 <roconnor> Heffalump put it better than I did
10:53:40 <kmc> sure, but that hard work is irrelevant to the conceptual difficulty people have with IO
10:53:48 <roconnor> kmc: I think it is relevent
10:53:50 <dolio> So you don't like the IO_Semantics stuff that you're linking to all the time?
10:54:08 <kmc> you can write the "execution engine" in a few dozen lines of pseudo-C
10:54:09 <monochrom> continuation-passing style ADT was one of 3 ways of function I/O in Andrew Gordon's thesis. The other two are streams (like interact) and monad.
10:54:11 <roconnor> dolio: the IO_Semantics isn't the same as the GADT defintion
10:54:16 <Cale> luite: Thanks
10:54:16 <dolio> Yes, it is.
10:54:19 <Heffalump> on the other hand, the interpretation function just needs access to a Haskell implementation.
10:54:23 <roconnor> dolio: I wrote that IO_Semantics article, and I like it. :)
10:54:29 <roconnor> dolio: no it isn't
10:54:29 <Heffalump> so it's sort of obvious how it can work
10:54:39 <Heffalump> IO_Semantics?
10:54:46 <monochrom> The thesis seems to favour monad. I dare say this is why Haskell 98 settled on it.
10:54:47 <roconnor> @wiki IO_Semantics
10:54:48 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
10:54:52 * Heffalump whacks dolio's and roconnor's heads together to see if they swap positions
10:55:28 <monochrom> heh, shock waves do swap positions
10:55:31 <roconnor> Heffalump: I describe IO as a tree that is used to make and respond to system calls.
10:55:48 <roconnor> which I personally think is a great explaination of IO.
10:56:02 <BMeph> Cale: Same here (Chrome and Opera).
10:56:04 <roconnor> IO says how to interact with the OS via system calls 
10:56:14 <roconnor> to get a result of type a
10:56:40 <geheimdienst> could you say IO is a marker for functions which, called repeatedly, may not return the same output for the same input?
10:56:56 <roconnor> geheimdienst: people say that, but it isn't true
10:57:19 <roconnor> geheimdienst: though, I'm not sure if it is observationally not true ...
10:57:21 <dolio> Your IO semantics looks just like a term algebra for IO, which is what the GADT definition is shooting for.
10:57:40 <roconnor> dolio: the GADT definition puts bind into the term algebra
10:58:03 <roconnor> dolio: which is a big mistake IMHO
10:58:19 <roconnor> the result is arguably not even a monad.
10:58:30 <Cale> geheimdienst: A value of type (IO t) is a description of a program which may cause some effects while computing a value of type t. It is not a function in the normal sense of that word, since it has no parameters.
10:59:01 <kmc> geheimdienst, a function of type «a → IO b» will always return the same output for a given input
10:59:07 <kmc> that output is an IO action, a description of stuff to do
10:59:12 <roconnor> dolio: I do agree that the GADT definition seems to be aiming for what I write.
10:59:18 <kmc> such values are opaque, don't implement Eq, etc.
10:59:26 <roconnor> dolio: why they insist on missing the mark is beyond my comprention
10:59:27 <kmc> so the only way we can say they're "the same" is that they have the same observable effects
10:59:30 <roconnor> dolio: you'll have to ask Cale.
10:59:32 <Cale> roconnor: Well, the GADT way becomes a monad once you use the module abstraction to hide the constructors :)
10:59:33 <dolio> The GADT isn't adequate, that's true.
10:59:50 <dolio> You can break it into two pieces to ensure that it is.
10:59:56 <Cale> That too
10:59:59 <roconnor> Cale: you still need to put an equivalence relation on your terms
11:00:11 <Cale> Another option is just to use MonadPrompt
11:00:33 <Cale> I just like showing the simple GADT with the Return and Bind constructors because it's short and easy to write down.
11:00:40 <__debaser> This is a noob question: Does Haskell support mutable state, for example like Clojure's software transactional memory, or is it all done using monads?
11:00:42 <geheimdienst> kmc, okay so it would be closer to the truth to say an IO action, when evaluated repeatedly, doesn't need to yield the same values
11:00:56 <roconnor> __debaser: there is the ST monad for mutatable state
11:01:08 <roconnor> __debaser: and there is the STM monad for transactional memory 
11:01:08 <c_wraith> __debaser, I think you're confused about what monads are.  But yes, haskell has software transactional memory, among other things
11:01:12 <Cale> __debaser: The IO, ST and STM monads let you describe actions which act on mutable state.
11:01:12 <kmc> geheimdienst, yeah that's true
11:01:15 <kmc> geheimdienst, wait, no
11:01:19 <kmc> geheimdienst, you said "evaluated"
11:01:26 <kmc> an IO action when *executed* doesn't need to yield the same value
11:01:31 <dolio> I actually did that here: http://code.haskell.org/~dolio/agda-share/html/IOE.html
11:01:33 <sproingie> clojure kinda got STM from haskell
11:01:37 <kmc> execution and evaluation are distinct in Haskell
11:01:39 <roconnor> @wiki IO_Semantics
11:01:40 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
11:01:42 <roconnor> geheimdienst: ^^
11:01:45 <geheimdienst> i mean when the IO friggin runs
11:01:48 <kmc> evaluating an IO action just gives you an IO action, it probably does nothing at all
11:01:52 <kmc> yes the IO runs when it is executed
11:01:59 <geheimdienst> okay ;)
11:02:00 <kmc> "evaluate" means to force to normal form
11:02:02 <dolio> It contains only a single 'normal form' for each IO action.
11:02:03 <Cale> STM is older than Haskell of course, but Haskell's implementation of STM has some new features which improve compositionality.
11:02:09 <kmc> by applying functions and beta-reducing
11:02:15 <geheimdienst> okay i see i used the term evaluating lightly
11:02:27 <Cale> (In particular, orElse is rather important, I think)
11:02:31 <geheimdienst> _too_ lightly
11:02:33 <kmc> well, it's important to distinguish evaluation and execution in Haskell
11:02:37 <roconnor> geheimdienst: The IO a contains the data needed to make system calls to the OS.  Execution is done my the runtime system which actually takes the information in an IO a and actually runs the system calls.
11:02:44 <kmc> in other languages it doesn't matter and i normally wouldn't be so pedantic about it ;)
11:02:55 <__debaser> c_wraith: yes, I believe I am confused :-D
11:03:02 <sproingie> where does the runtime get the execution from?
11:03:10 <roconnor> geheimdienst: evaluation is used to figure out the next system call, and execution actually performs the system call.
11:03:11 <kmc> geheimdienst, if you want to talk about «a → IO b» as an "impure function" then you have changed the definition of "function".  you're not working in the category (→) anymore (sometimes called Hask).  you're working in the category (Kleisli IO)
11:03:15 <Heffalump> who stole luqui.org ?
11:03:18 <kmc> @src Kleisli
11:03:18 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:03:38 <kmc> newtype Kleisli m a b = Kleisli (a → m b)
11:03:49 <Cale> __debaser: Evaluation in Haskell, the process which reduces expressions into values, is totally* referentially transparent (*ignoring low-level hackery not meant for daily use)
11:04:25 <kmc> __debaser, Haskell supports true mutable state (IORefs, STM, etc.)
11:04:26 <geheimdienst> (* ignoring low-level hackery not approved of by ceiling cat)
11:04:27 <Cale> __debaser: Which means that the process of evaluating an expression can't ever cause a change to mutable state.
11:04:33 <kmc> the monad named State is not that; it's just sugar for passing an extra arg around
11:04:36 <c_wraith> __debaser, monads are not anything outside the language, nor are they escape mechanisms from the type system, nor anything else.  They're just a convenient mechanism for gluing small actions into bigger ones.
11:04:44 <kmc> the monads named ST and IO and STM do provide real mutable state
11:04:58 <__debaser> I see
11:04:59 <Cale> __debaser: Separate from evaluation is the process of execution, specifically the execution of IO actions.
11:05:03 <geheimdienst> so, could you guys get on board with the description evaluation is a compile-time thing, execution a run-time thing?
11:05:15 <kmc> geheimdienst, no
11:05:19 <roconnor> geheimdienst: not really
11:05:23 <geheimdienst> bah
11:05:27 <roconnor> geheimdienst: evaluation is done at runtime
11:05:41 <roconnor> geheimdienst: if you had infinite memory I think it could be done at compile time though.
11:05:47 <Cale> __debaser: A Haskell program will define an IO action value called main, which describes what effects the program has. IO actions are allowed to do anything which your computer can do.
11:05:48 <kmc> and infinite time
11:05:50 <geheimdienst> but evaluation has to precede execution, right?
11:05:50 <kmc> (some terms diverge)
11:05:58 <sproingie> now where'd i put that turing machine
11:05:58 <kmc> geheimdienst, correct
11:06:08 <roconnor> geheimdienst: due to laziness evaluation and exectuion is interleaved in practice.
11:06:20 <Cale> __debaser: But *evaluating* that IO action, that is, turning it from an expression into the abstract value representing the action, has no effects at all (apart from making your CPU warm)
11:06:31 <geheimdienst> okay, but all execution is at run-time, right?
11:06:31 <sproingie> so when evaluation reduces to an action, it hands it off to be executed?
11:06:43 <roconnor> sproingie: yes
11:06:44 <Cale> sproingie: yes, exactly
11:06:49 <sproingie> ah.  simple.
11:06:52 <kmc> sproingie, it's the other way around.  the outer layer of a Haskell program is a thing which says "execute main"
11:06:53 <Cale> Well, in practice, they're interleaved.
11:06:57 <kmc> now, to execute main, we have to evaluate it first
11:06:59 <sproingie> hell i reinvented that trick in moocode
11:07:01 <roconnor> sproingie: the response of the action is used to pick a new action
11:07:13 <Cale> So, it's evaluated just enough to determine what the first thing is to do, and then that thing happens, and then evaluation continues
11:07:14 <roconnor> sproingie: again evaluation must be done to compute what exactly that new action will be
11:07:19 <kmc> also to execute «m >>= f» we have to execute m, then apply f to the result and evaluate it until the function returns an IO action
11:07:24 <kmc> (then execute that action)
11:07:40 <kmc> figure out what to do, then do it
11:08:01 <roconnor> sproingie: in theory you could even try to predict what the response of an action will be and start precomputing the next action will be ... kinda like branch prediction
11:08:30 <kmc> http://hackage.haskell.org/package/speculation
11:09:03 <kmc> so execution is the "outermost" process; it calls on evaluation at various points
11:09:06 <sproingie> i wonder if that'd be useful on EPIC architectures?  or too low-level?
11:09:22 <kmc> but evaluation will never call for execution, unless you use unsafePerformIO and the like
11:09:59 <int80_h> w00t. Someone rewrote my code , and it looks like exactly what I want.
11:10:06 <int80_h> I wish I knew who
11:10:11 <kmc> (it is difficult to implement unsafePerformIO with the GADT definition of IO.  you need a new language primitive.  whereas GHC's implementation of IO starts with everything unsafe, so it's easy to implement;) )
11:10:18 <roconnor> sproingie: what is EPIC?
11:10:44 <sproingie> roconnor: itanium architecture.  explicitly parallel instruction computing.
11:11:00 <sproingie> roconnor: generally referred to with an unofficial alternate acronym: PITA
11:18:12 * hackagebot source-code-server 2010.9.1 - The server backend for the source code iPhone app  http://hackage.haskell.org/package/source-code-server-2010.9.1 (JinjingWang)
11:33:15 <ben_m> I suck at recursion.
11:33:21 <ben_m> That is all :)
11:33:32 <monochrom> I succ at recursion
11:33:47 <ben_m> I `fix` at recursion? :/
11:33:54 <ahf> i recurse at recursion
11:34:01 <geheimdienst> i recurse
11:34:02 <monochrom> I fix recursion
11:34:04 <jrockway> i suck at things i suck at
11:34:36 <monochrom> I fix error
11:34:42 <jrockway> > fix error
11:34:43 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:34:49 <geheimdienst> > fix fix
11:34:50 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
11:34:55 <geheimdienst> > fix succ
11:34:56 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
11:35:00 <geheimdienst> i fix sucking
11:35:12 <jrockway> > fix . fix
11:35:12 <lambdabot>   Overlapping instances for GHC.Show.Show (((a -> a) -> a -> a) -> a)
11:35:13 <lambdabot>    aris...
11:35:28 <jrockway> > fix . fix $ const 42
11:35:29 <lambdabot>   42
11:35:45 <Veinor> :t const 42
11:35:46 <lambdabot> forall t b. (Num t) => b -> t
11:36:20 <Veinor> oh yeah, a -> a has a num instance
11:36:50 <monochrom> evil
11:37:06 <dolio> > fix 42
11:37:07 <lambdabot>   42
11:37:22 <jrockway> oh interesting
11:37:35 <jrockway> > fix . fix . const . const $ (42 :: Int)
11:37:35 <lambdabot>   42
11:37:52 <geheimdienst> > fix dinner
11:37:53 <lambdabot>   Not in scope: `dinner'
11:37:55 <jrockway> > 42 42
11:37:56 <lambdabot>   Ambiguous type variable `t' in the constraint:
11:37:56 <lambdabot>    `GHC.Num.Num t'
11:37:56 <lambdabot>      aris...
11:37:57 <geheimdienst> > fix sandwich
11:37:58 <lambdabot>   Not in scope: `sandwich'
11:38:03 <geheimdienst> > sudo fix me a sandwich
11:38:04 <lambdabot>   Not in scope: `sudo'Not in scope: `me'Ambiguous occurrence `a'
11:38:04 <lambdabot>  It could re...
11:38:04 <jrockway> > 42 (42 :: Int)
11:38:05 <lambdabot>   42
11:38:07 <jrockway> hah
11:38:35 <jrockway> life, the universe, a function, and everything
11:39:07 <geheimdienst> IO (Life, Universe, Everything)
11:39:22 <int80_h> I just found out that the prototype for the hithchiker's game sequel was released
11:39:29 <int80_h> milliways
11:39:42 <int80_h> I tried it, it made me sad.
11:39:46 <geheimdienst> and don't argue with me, it must be in IO. it's frickin impure, the universe
11:41:19 <jrockway> are functions from one universe to another universe pure?
11:41:46 <monochrom> functions are pure. definition.
11:42:19 <jrockway> but what if they have the side effect of destroying all human lifeforms?
11:42:42 <monochrom> don't call it a function
11:43:05 <monochrom> the 1970 term "procedure" works fine
11:43:39 <jrockway> "procedural programming"
11:44:25 <monochrom> I am also inclined to use "procedure" for monad values.
11:51:06 <sproingie> not all monadic values imply a procedure
11:51:23 <jrockway> is my burrito a procedure?
11:51:52 <int80_h> worse, your burrito is vegetarian
11:52:48 <monochrom> "vegetable" for monad value sounds fun
11:53:28 <monochrom> completely fits some people's "it's a recipe sitting there doing nothing" agenda. it's a vegetable! coma!
11:54:29 <monochrom> yo ma is so categorical, she has a coma?
11:54:57 <arw> bah. why can't perl have --with-static-types?
11:56:16 <bremner> err, because it isn't statically typed? Is this a trick question?
11:56:17 <monochrom> because perl can't even be statically parsed, I heard.
11:56:36 <arw> bremner: more of a rhetorical question i guess.
11:56:43 <Veinor> monochrom: correct
11:56:51 <Jafet> Why can't haskell have --with-dynamic-types?
11:56:57 <monochrom> may as well ask why can't perl have --with-semantics
11:57:03 <c_wraith> yeah.  You can't parse perl without also executing it.
11:57:05 <Ke> blasphemy
11:57:16 <arw> i'm just complaining in vain about the mysery of debugging old code...
11:57:20 <c_wraith> it's always fun what parsing is sensitive to the value of variables.
11:57:25 <c_wraith> *when
11:57:30 <Veinor> determining the arityness of an operator in perl is equivalent to the halting problem
11:57:33 <Veinor> er, arity
11:57:46 <monochrom> then I have added one item to your repertoire of complaints you can use next time. :)
11:57:55 <arw> c_wraith: and whats even worse, you can't test and debug it without really using every stupid code path...
11:59:55 <arw> i'm currently trying to convince some colleagues that haskell isn't all too bad and rewriting old unreadable perl in new (for them) unreadable haskell is at least not making matters worse...
12:00:28 <monochrom> people are emotionally attached to old code. you need a clinical psychologist.
12:01:33 <monochrom> a controlled experiment proving beyond doubt that writing new code (even in perl again) is more efficient than fixing old code will not convince people a bit.
12:02:18 <arw> well. they are convinced that that code needs a rewrite. its just that nobody agrees on how to rewrite it.
12:02:29 <monochrom> ok that's better
12:02:47 <monochrom> perl is a write-only language. that's your next battle.
12:03:07 <Nibble> hehe
12:03:10 <monochrom> latex is another write-only language.
12:03:16 <arw> not quite, there is readable perl out there. i just find its a pain to write sometimes.
12:03:22 <Nibble> This C program have a function that is probably longar than 2000 lines
12:03:24 <Zao> Rewriting code tends to obliterate all the little warts that appear from real-world circumstances and fixes.
12:03:48 <sproingie> i find a lot of those fixes arise from the crappy way the code was written in the first place
12:04:28 <arw> Zao: thats one of the goals. we want code that does things in a sane, predictable and seemingly deterministic way.
12:04:28 <Zao> sproingie: What about the ones that do not?
12:04:54 <arw> Zao: the reason for the rewrite is "nobody knows what it does and nobody can read it to find out"
12:04:55 <Zao> Rewriting without losing some properties would require a serious requirements pass.
12:05:02 <Zao> arw: If you're that hosed, sure.
12:05:15 <Zao> arw: I'm just annoyed at the usual FL/OSS mentality of "next time we'll be better, lol"
12:05:16 <sproingie> well often the circumstances the workaround was designed for have gone away since then
12:05:36 <arw> Zao: the point is, the requirements are actually a lot less complex than what that program implements.
12:05:39 <monochrom> I care about real-world circumstances too. Pick one: code is so simple it obviously has no omission of real-world considerations; code is so complicated it has no obvious omission of real-world considerations.
12:05:47 <sproingie> but usually i can move a crock dealing with some broken source of data "upstream" instead of making every possible consumer deal with it their own way
12:06:38 <sproingie> and since i write code for internal users and using internal data sources we control, that can mean kicking it all the way upstream to the producer of the data
12:07:02 <sproingie> thank god i don't have to write anything like dealing with the nine billion brain-dead dialects of RSS
12:07:43 <arw> sproingie: just use atom :>
12:08:00 <monochrom> there is actually a way of preserving old code, but you need a PhD.
12:08:00 <sproingie> arw: i consider that a proper fix, yes.  in the meantime, still gotta handle crappy rs
12:08:03 <sproingie> s
12:08:19 <tehgeekmeister> cabal isn't the latest in the haskell platform, apparently, is there a reason i shouldn't upgrade?
12:08:22 <sproingie> my gf works on some kind of monster RSS-based app
12:08:23 <arw> monochrom: i have several next door. what do i need to do?
12:08:33 <monochrom> "program transformations"
12:09:20 <arw> monochrom: would require a parseable language or one with a sane semantic. but the program to be transformed is perl, so no luck there :)
12:09:27 <monochrom> also a lot of "static analysis" for reverse-engineering
12:09:43 <monochrom> yeah, need a post-doc if it's perl :)
12:10:37 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29580#a29614
12:11:01 <monochrom> this is an example of what happens if ghci had colours.
12:12:47 * hvr wants to write a simple json-rpc over http web-service (just web-service, no web-serving), i.e. I just want a simple http-server, which allows for concurrency.... which http-server for haskell should I look into?
12:13:08 <tehgeekmeister> hvr: snap i think is a good option
12:13:12 <tehgeekmeister> hvr: it's fast and simple
12:13:38 <tehgeekmeister> hvr: just install snap-core and snap-framework, and make sure to use snap init -b (so it doesn't install the templating libraries you won't want.)
12:13:43 <tehgeekmeister> errr
12:13:47 <tehgeekmeister> snap-server, not framework
12:13:48 <tehgeekmeister> silly me
12:14:31 <tehgeekmeister> booooo the haskell platform i installed doesn't have profiling libraries?!
12:15:08 <monochrom> haskell platform has profiling by default
12:15:11 <int80_h> monochrom: do you have a moment to look at my hpaste?
12:15:16 <monochrom> no
12:15:48 <tehgeekmeister> monochrom: it is complaining about not having it.  it's the unofficial ubuntu one for lucid
12:16:28 <monochrom> profiling is packaged separately in that case.
12:17:07 <monochrom> for example libghc6-mtl-prof
12:17:54 <tehgeekmeister> ah, okay
12:17:59 <monochrom> may I also suggest considering http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
12:18:55 <Eduard_Munteanu> Hi.
12:20:12 <tehgeekmeister> monochrom: that is a good idea.
12:20:40 <tehgeekmeister> for now i am just going to not enable profiling, this is a server i'm installing on anyway, not a machine i develop on.
12:21:25 <hvr> tehgeekmeister: thx... the '-b' option looks very interesting :)
12:21:47 <tehgeekmeister> hvr: also there is #snapframework; people there are fairly responsive and helpful
12:22:39 <hvr> although I'm still a bit confused, why I need this much boilerplate code (even if it's autogenerated)
12:23:40 <hvr> (especially Server.hs)
12:30:16 <int80_h> @seen notabel
12:30:16 <preflex>  notabel was last seen on #haskell 19 hours, 10 minutes and 30 seconds ago, saying: the type-directed name resolution proposal, if implemented, would do this in certain cases
12:30:16 <lambdabot> Unknown command, try @list
12:30:25 <Saizan> int80_h: ghc is not "guessing" that each element of the list has to be of the same type, that's part of the definition of list
12:30:50 <int80_h> Saizan: gotcha, so am I right as to what the solution is?
12:31:04 <Saizan> int80_h: according to "what you think you need to do" you need to read about existential types :)
12:31:19 <int80_h> Saizan: I'm on that then
12:31:37 <Saizan> another solution would be to use a sum type, maybe a gadt
12:31:46 <Eduard_Munteanu> Mmm, are you looking for heterogenous collections? There's a lot of stuff on the Haskell wiki.
12:32:25 <copumpkin> does anyone know how the performance of Vector Word8 compares to ByteString?
12:32:26 <int80_h> Saizan: well this was supposed to be a laerning exercise for me. So maybe I should read on all of those possible solutions, and then come back here for discussion.
12:33:44 <Saizan> int80_h: makes sense
12:35:43 <int80_h> Saizan: I think I have just eliminated existential types as the right approach.
12:35:55 <int80_h> Saizan: "Thirdly, since code now has no idea what type the buffer function returns, you are more limited in what you can do to it. ", from the haskell wiki.
12:37:35 <c_wraith> often, being limited in what you can do with values is useful.
12:37:41 <c_wraith> But not always.
12:38:19 <c_wraith> Also, amusingly, you can use rank-2 types to remove limitations about what you can do, sometimes.
12:39:01 <int80_h> hmm, okay I need further consideration then
12:39:27 <Badrush> 	Anyone here familar with c++?
12:39:40 * mauke eyes Badrush 
12:39:45 <Eduard_Munteanu> :)
12:39:54 <Badrush> need help with WM_KEYDOWN , i want to remove the "pause" between the first keypress and the repeating
12:40:04 <mauke> Badrush: that has nothing to do with C++
12:40:08 <Badrush> x)
12:40:09 <mauke> Badrush: or Haskell, for that matter
12:40:31 <monochrom> I don't know c++ or wm_stuff
12:40:45 <Eduard_Munteanu> It might have something to do with Python :P :P
12:41:05 <copumpkin> I hate how much stuff is crammed under the Data. module. But now I have something that I actually think belongs there
12:41:11 <copumpkin> and I kind of have reservations putting i there
12:41:21 <Badrush> i dunne wich chat to got to :(
12:41:27 <monochrom> "Data." is not a module.
12:41:40 <copumpkin> you know what I mean :P
12:41:57 <Jafet> Data. is terrible for tab completion.
12:42:04 <copumpkin> I agree :(
12:42:18 <copumpkin> Data.MemoryMap seems kind of ugly too, but I can't think of a better name for it
12:42:20 <monochrom> what is your new invention?
12:42:26 <burp> Lore.
12:42:30 <monochrom> haha
12:43:21 <Eduard_Munteanu> Badrush: mm, as far as Google tells, it's some sort of MS Windows stuff.
12:43:41 <copumpkin> it's a bit like a sparse bytestring that stores groups of contiguous bytes as bytestrings and supports efficient lookup (through an interval map based on fingertrees)
12:43:42 <Badrush> yeah i kinda new that -_-
12:43:48 <Eduard_Munteanu> Badrush: try looking for a Windows programming channel. Or you might try stackoverflow.
12:43:52 <copumpkin> sort of like a rope, but with sparse indices
12:44:01 <Eduard_Munteanu> (the website)
12:44:26 <copumpkin> anyone have a better idea for a name?
12:44:27 <Eduard_Munteanu> But I'm clueless about that.
12:44:35 <monochrom> Data.SparseByteString
12:44:58 <monochrom> or SparseAnything in general
12:45:15 <copumpkin> SparseIntervalMap? :P
12:45:35 <copumpkin> I'm thinking of building it on Vector
12:46:05 <copumpkin> still feels like the only real use for it would be a memory map
12:46:57 <monochrom> I might use it for some dynamic programming
12:49:42 <CosmicRay> shapr: you're working at digium now?  sweet
12:49:52 <CosmicRay> shapr: I've been using Asterisk at home for some time and we deployed it at work in 2006
12:49:59 <copumpkin> monochrom: hmm, okay
12:50:12 <copumpkin> monochrom: SparseIntervalMap then?
12:50:29 <copumpkin> anyone have any other suggestions? I don't really like the name ByteString
12:50:37 <monochrom> I don't mind. As long as it's Sparse*
12:50:37 <copumpkin> SparseVector?
12:50:42 <copumpkin> since I'm building it on Vector
12:50:44 <shapr> CosmicRay: Yeah, I know... thought about poking you, but wasn't sure if wanted to chat about anything Asterisk related.
12:50:47 <Badrush> Why is All my text in google bold O.o
12:50:55 <copumpkin> Badrush: do you have any haskell questions?
12:51:02 <shapr> Badrush: Are you learning Haskell?
12:51:07 <Badrush> :)
12:51:11 <Badrush> bye then x)
12:51:16 <Eduard_Munteanu> @hoogle vector-mmap
12:51:16 <lambdabot> Test.QuickCheck vector :: Arbitrary a => Int -> Gen [a]
12:51:22 <copumpkin> Eduard_Munteanu: I wrote that :P
12:51:26 <shapr> Badrush: Did you know you can automate Asterisk with Haskell via the AGI?
12:51:28 <CosmicRay> shapr: can you do that from your home or?
12:51:30 <Eduard_Munteanu> Ah :)
12:51:38 <CosmicRay> shapr: oh is there an AGI lib for haskell?
12:51:40 <shapr> CosmicRay: Sure, yeah.. though I'm at work right now.
12:51:47 <copumpkin> SparseVector it is!
12:51:48 <shapr> CosmicRay: Yeah, stepcut wrote it.
12:51:59 <CosmicRay> shapr: awesome
12:52:04 <shapr> CosmicRay: I want to get into building Asterisk .so modules in Haskell at some point.
12:52:09 <Badrush> Why would i? I can do that in assembly
12:52:11 <CosmicRay> shapr: I have been toying around with the idea of linking asterisk with my ham radio
12:52:21 <shapr> CosmicRay: Seen OpenBTS already, yeah?
12:52:41 <CosmicRay> shapr: yeah but I don't own a SDR
12:53:03 <shapr> CosmicRay: There's a wimpy one for $20-$50, but doesn't do USRP-level goodies.
12:53:12 <shapr> I can find the url if you want.
12:53:54 <Eduard_Munteanu> Yeah, just as you could read data from your HDD using some sort of atomic force microscope.
12:54:29 <CosmicRay> shapr: yeah and ones that do ham-level stuff (say 100W) are really pricy
12:55:26 * shapr moves the SDR conversation to #haskell-blah
12:55:38 <monochrom> Why would I? I can write on a clay tablet.
13:08:00 <Nibble> DESU! DESU! DESU!
13:08:33 <Aune> Nope, NO DESU FOR YOU!
13:09:19 <Aune> Anyone know a good book about algorithms?
13:09:47 <kmc> CLRS is a standard intro to algorithms text
13:09:52 <kmc> are you looking for something more specific?
13:10:24 <Aune> I want something more readable and less encyclopedic
13:10:37 <Aune> Also a functional aproach would be good
13:10:44 <kmc> ah
13:10:51 <kmc> yeah CLRS is kind of a cookbook
13:10:52 <copumpkin> the Okasaki one then?
13:10:56 <kmc> it fits the field though
13:11:00 <Eduard_Munteanu> I saw something on Amazon.
13:11:05 <kmc> Okasaki's _Purely Functional Data Structures_
13:11:11 <Eduard_Munteanu> kmc: that one :)
13:11:28 <Eduard_Munteanu> kmc: is it worth it?
13:11:30 <monochrom> That is pretty advanced, and assumes you already know CLRS or something.
13:11:31 <kmc> i haven't read it yet
13:11:33 <Aune> Yeah, Oekasaki is on my "to do" list
13:12:02 <bremner> at the risk of getting yelled at here, I think one's first algorithms book should probably be procedural
13:12:18 <monochrom> http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html
13:12:18 <Eduard_Munteanu> I'll be buying TAPL + some other book from Amazon soon, so I'm thinking which is gonna be.
13:12:26 <copumpkin> bremner: @!$!#@!$%
13:12:33 <Aune> And Im not afraid of advanced math
13:13:02 <kmc> it is true that many purely functional data structures are actually different data structures
13:13:09 <Eduard_Munteanu> Well, advanced math is usually anything post-highschool.
13:13:10 <kmc> and it's important to know the mutating ones too
13:13:17 <bremner> Aune: that's not the point. The point is that algorithms is its own thing, I don't think everything needs to be seen through the lens of FP
13:13:39 <bremner> but, actually, I don't know much about FP, so I'll shut it.
13:13:45 <tommd> bremner: I'd yell at you for knowingly making a debatable statement without also giving any reasoning.
13:13:58 <bremner> tommd: see above.
13:14:17 <kmc> "algorithms good for FP" is a subfield of algorithms
13:14:29 <kmc> there are many other such specializations, e.g. algo for distributed computing, quantum algo, etc.
13:14:30 * Eduard_Munteanu is be curious how linear algebra stuff goes with Haskell.
13:15:20 <Eduard_Munteanu> (that is, without imperative constructs)
13:15:43 <Aune> Yeah, I am kind of working my way through Knuths first book and I already have some knowledge about datastructeres and algorithms.
13:19:40 <__debaser> once again I have to test your patience: does anyone know how I can get indentation to work for Haskell in VIM?
13:20:40 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29615#a29615 my .vimrc __debaser
13:20:42 <kmc> nothing fancy
13:20:45 <Cale> __debaser: I just turn on expandtab and smarttab
13:21:13 <__debaser> Cale: so you still have to indent yourself?
13:21:29 <kmc> mine goes to the indent of the previous line
13:21:38 <Cale> __debaser: To some extent, where the indentation differs from that of the previous line.
13:21:47 <Cale> oh, I also have on autoindent
13:22:05 <kmc> back when i used Emacs, i found the Haskell mode to be more clever than vim's, but also sometimes misleading
13:22:30 <BONUS> what does smarttab do again?
13:22:38 <kmc> i think beginners should read what the Report has to say about layout
13:22:43 <sproingie> i really wish haskell's layout rule was just indent-based like python and not on actually lining things up
13:22:45 <kmc> it's simpler  than i thought initially
13:22:49 <kmc> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
13:23:18 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29617#a29617
13:23:51 <Cale> There's some junk in there relating to tex and haskell addons that I don't use all that much.
13:24:24 <copumpkin> wow, a typeclass with unboxed functions in it
13:24:25 <copumpkin> http://hackage.haskell.org/packages/archive/primitive/0.3/doc/html/Data-Primitive-Types.html
13:24:56 <kmc> you mean that the functions take unboxed args and return unboxed values?
13:25:01 <kmc> or something else?
13:25:03 <copumpkin> they take boxed args
13:25:06 <copumpkin> can't take unboxed ones
13:25:15 <Cale> Sure they could...
13:25:17 <kmc> indexOffAddr# :: Addr# -> Int# -> a
13:25:21 <kmc> looks like unboxed args to me
13:25:22 <Cale> @kind (->)
13:25:23 <lambdabot> ?? -> ? -> *
13:25:30 <copumpkin> yeah, my point is that the class parameter must be boxed
13:25:33 <kmc> however the type parameter 'a' will have to be a boxed type, i'll bet
13:25:35 <copumpkin> and most of them work on the class parameter
13:25:51 <Cale> (->) will always produce a boxed type, as that kind indicated
13:25:55 <copumpkin> yeah yeah :P
13:25:56 <Cale> indicates*
13:26:01 <copumpkin> all I was saying was about that particular class
13:26:04 <Cale> ah
13:26:10 <copumpkin> the class parameter must be boxed
13:26:20 <copumpkin> kind of by definition
13:27:26 <BONUS> quick q: newtype Prob a = [(a,Ratio Integer)] is a monad, right? in the sense that the Ratio Integer represents the probability of a occuring
13:27:37 <Cale> BONUS: yes
13:27:44 <Veinor> BONUS: seems likely
13:27:48 <BONUS> its easy to make the instance i was wondering if there's any weird corner case with the laws
13:27:52 <Cale> BONUS: It's WriterT (Ratio Integer) []
13:28:09 <kmc> there was a blog article about probability monads recently
13:28:29 <Cale> Well, probably you want  WriterT (Product Rational) []  more specifically
13:28:53 <Cale> It's also valid to sum them (or do any other monoidal thing)
13:29:14 <BONUS> ooh, i never spotted that it's a WriterT ... very cool
13:29:16 <Cale> But for the probability interpretation, you want the product.
13:29:57 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29618#a29618 this doesn't work, but is there a good reason why it can't work in principle?
13:30:14 <kmc> it seems like the error should be at the usage site of 'x', if the type is not statically known
13:30:23 <kmc> because you can't form the tuple type (a, CDictionary a)
13:30:34 <kmc> polymorphically
13:31:23 <copumpkin> dons: can the fancy stuff you guys did to Data.Map etc. be applied to the fingertrees package too?
13:34:19 <jmcarthur> that would make me happy
13:47:30 <vbCrLf> "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
13:47:45 <vbCrLf> The only solution I could think of is this: head [x | x <- [1..], (x `mod` 2)+(x `mod` 3)+... == 0]
13:48:08 <vbCrLf> But it requires me to add a condition of each number 1 to 20 which isn't good.
13:48:17 <vbCrLf> Is there any other solution?
13:48:46 <Entroacceptor> vbCrLf: I think I did that challenge, too
13:49:03 <vbCrLf> Yes, its Euler, one of the first
13:49:04 <copumpkin> > foldr1 lcm [1..20]
13:49:05 <lambdabot>   232792560
13:49:23 <kmc> > head [x | x <- [1..], all (\d -> (x `mod` d) == 0) [1..20]]
13:49:24 <vbCrLf> Let me Google a bit :)
13:49:25 <aristid> :t lcm
13:49:25 <lambdabot> forall a. (Integral a) => a -> a -> a
13:49:27 <lambdabot>   mueval-core: Time limit exceeded
13:49:38 <aristid> > lcm 6 9
13:49:38 <lambdabot>   18
13:49:42 <monochrom> you don't know lcm?
13:49:45 <vbCrLf> No
13:49:50 <kmc> vbCrLf, using maths you can do it faster
13:49:53 <copumpkin> least common multiple
13:50:01 <kmc> but just in terms of the code, see my example with "all" above
13:50:02 <kmc> @src all
13:50:02 <lambdabot> all p =  and . map p
13:50:11 <Entroacceptor> @sec lcm
13:50:11 <lambdabot> lcm _ 0     =  0
13:50:11 <lambdabot> lcm 0 _     =  0
13:50:11 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
13:50:22 <Entroacceptor> haha
13:50:22 <copumpkin> @src gcd
13:50:23 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
13:50:23 <lambdabot> gcd x y = gcd' (abs x) (abs y)
13:50:23 <lambdabot>    where gcd' a 0  =  a
13:50:23 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
13:50:23 <monochrom> lcm is school math before age 18 or something. probably before age 12.
13:50:45 <kmc> copumpkin i like your solution :)
13:50:56 <aristid> monochrom, i didn't learn the english abbreviation in school
13:51:13 <kmc> lcm is associative and commutative right?
13:51:17 <Cale> It probably *shouldn't* be so early. They like to teach simplification of fractions in a context where the students don't really have enough knowledge to appreciate it yet.
13:51:25 <tolkad> > (1, print 2)
13:51:26 <kmc> so for bonus brownie points, parallelize it :)
13:51:26 <lambdabot>   (1,<IO ()>)
13:51:26 <monochrom> yeah, I'm just too lazy to type
13:51:31 <copumpkin> kmc: yeah
13:51:41 <copumpkin> :D
13:51:58 <monochrom> lcm is associative and commutative. proof by recognizing it as supremum for a partial order.
13:52:08 <kmc> i lost
13:52:12 <tolkad> I never thought of returning an IO result within a pure data structure...
13:52:23 <kmc> tolkad, IO actions are first-class values like any other
13:52:32 <tolkad> I guess if the IO doesn't eventually reach main it wont actually be executed
13:52:34 <copumpkin> I can have a list of them!
13:52:34 <kmc> tolkad, realizing that is the key to doing IO effectively in Haskell, instead of seeing it as a kludge
13:52:45 <tolkad> copumpkin: well I thought of that
13:52:46 <kmc> yeah tolkad
13:52:54 <kmc> evaluating an IO action does not execute it
13:52:57 <kmc> > print 3 `seq` ()
13:52:58 <lambdabot>   ()
13:53:02 <monochrom> think of passing an "IO blah" around as value is passing a callback around.
13:53:12 <tolkad> copumpkin: but I didn't think of the general case
13:53:29 <monochrom> all the glory around "inversion of control" in the "real" world becomes so trivial in haskell.
13:53:43 <kmc> IO actions are little imperative programs you build as values in your Haskell code
13:54:14 <tolkad> why don't universities use haskell : (
13:54:16 <c_wraith> :t bracket
13:54:17 <lambdabot> Not in scope: `bracket'
13:54:24 <c_wraith> :t Control.Exception.bracket
13:54:25 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:54:30 <kmc> tolkad, a few use it, even for intro to programming
13:54:36 <monochrom> because universities worry too much about the stupid "real" world
13:54:52 <kmc> but yeah there's a pressure to turn CS programs into mere vocational schools for pumping out replaceable Java units
13:55:06 <kmc> and learning Haskell is actively contrary to that goal
13:55:07 <monochrom> academic people also have incentives to glorify trivial things.
13:55:08 <tolkad> monochrom: isn't that some detail of GHC's IO implementation?
13:55:15 <notabel> kmc: in the java world they call them objects ;-)
13:55:21 <kmc> call what
13:55:26 <kmc> hehe
13:55:33 <notabel> the replaceable Java 'units'
13:55:33 <monochrom> what detail? I guess the answer is "no".
13:55:38 <tolkad> monochrom: RealWorld
13:55:45 <notabel> monochrom: he's referring to RealWorld
13:55:45 <kmc> class JavaProgrammer implements Programmer
13:55:54 <monochrom> I am talking about the "real" world, not RealWorld
13:56:12 <monochrom> you know, the set of people who say "haskell is useless"
13:56:36 <monochrom> society if you like
13:56:41 <kmc> functional programming is useless.  now let's go to great pains to implement it in C++
13:56:52 <tolkad> they do? I have mostly only heard about haskell from here and on reddit, and in both places people have been very positive about it
13:57:39 <kmc> Parsec is just a toy, it's only a few thousand lines of code
13:57:47 <kmc> now Boost.Spirit, that's real *enterprise grade* software
13:57:52 <kmc> [/troll]
13:58:03 <copumpkin> lol
13:58:05 <kmc> tolkad, we have a bit of a persecution complex
13:58:18 <tolkad> I have decided to avoid ever learning C++ if I can help it
13:58:20 <c_wraith> I don't.  I just use haskell.  I let others talk about it. :)
13:58:25 <copumpkin> it's not paranoia if people really are out to get you
13:58:31 <kmc> tolkad, if you want to design a new language, you should learn C++ first
13:58:33 <tolkad> C sure, but not C++
13:58:33 <kmc> so you know what not to do
13:58:35 * copumpkin looks around
13:58:37 <jonafan> the first program i ever wrote was in C++
13:58:39 <jonafan> never again.
13:58:46 <kmc> also some of the extensions to C in C++ are actually useful for reasonable C-ish coding
13:58:50 <kmc> but they have a way of drawing you in
13:59:07 <kmc> want references? now you need to use initialization lists and constructors.  want to signal errors from those? now you need exceptions.
13:59:12 <kmc> etc.
13:59:15 <kmc> so beware :)
13:59:19 <monochrom> some subset of c++ is nice to know
13:59:39 * c_wraith checks his copumpkin trap field
13:59:45 <c_wraith> darn, nothing today either
13:59:54 <kmc> it's fun to learn C++ in detail, if you consider it an esolang like befunge or intercal
13:59:55 <tolkad> one thing I don't like about haskell is the use of "error" everywhere
14:00:01 <Twey> kmc: Haha, aye
14:00:10 <kmc> C++'s "typename" keyword is basically INTERCAL's "please"
14:00:16 <tolkad> why can't people use maybe-like wrappers instead of error?
14:00:19 <monochrom> I once used just one line of c++ to illustrate 2nd-rank polymorphism. So knowing a bit of c++ pays. Think of it as knowing English.
14:00:24 <Twey> tolkad: ‘Everywhere’?  We recommend against using it for errors that could reasonably occur as a result of user or system error.
14:00:30 <kmc> tolkad, a lot of libraries do
14:00:40 <kmc> but the standard lib has some badness in this respect
14:00:52 <kmc> import Prelude hiding(head); head = Data.Maybe.listToMaybe
14:01:06 <Twey> ‘head’ is meant to be partial
14:01:11 <copumpkin> tolkad: I agree :P you should use spoon
14:01:16 * copumpkin laughs evilly
14:01:25 <Twey> If you're using a partial function in a situation where it may blow up, it's entirely your own fault :þ
14:01:42 <aristid> my shpoon is too big
14:01:42 <tolkad> http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/src/Data-Binary-Get.html#failDesc
14:01:47 <c_wraith> I only use "error" for pattern-matches that shouldn't be possible.  As in "if this happened, you have a seriously broken assumption somewhere"
14:01:55 <monochrom> Just yesterday or the day before, we had a use of such "unsafe" functions as read and head, and everyone agreed it's valid use.
14:01:55 <copumpkin> @hackage spoon
14:01:55 <lambdabot> http://hackage.haskell.org/package/spoon
14:02:17 <aristid> monochrom, map head . group?
14:02:23 <monochrom> We even agreed the safe versions were retarded for it.
14:02:48 <copumpkin> I really want an "adjacentGroup"
14:02:53 <monochrom> using parsec: do { x <- many1 digit; let n = read x; ... }
14:03:03 <aristid> copumpkin, what would that do?
14:03:14 <copumpkin> well, adjacentGroupBy, really
14:03:24 <copumpkin> groupBy doesn't do what I want
14:04:06 <Cale> dons: The improvements to Map look like they ended up being a good bit larger than those for IntMap -- it would really be nice to see a direct comparison of performance between the new Map and IntMap libraries.
14:04:28 <tolkad> oh wait forget the Data.Binary.Get, that's user called
14:04:34 <tolkad> uh let me find another example
14:05:12 <tolkad> well read is an obvious one
14:05:17 <kmc> yeah
14:05:28 <kmc> it sucks that "read" is the unsafe default
14:05:34 <monochrom> The safeThis safeThat puritans should also have objected to copumpkin's foldr1 lcm [1..20]. "OMG what if [1..20] were empty! God would not forgive our sins!"
14:05:36 <kmc> people come in here confused all the time about that
14:05:52 <kmc> the solution is to use "reads" but it's a little clunky and far from obvious
14:05:53 <copumpkin> monochrom: length-index lists!
14:05:53 <tolkad> are read/show intended for debuging?
14:05:58 <c_wraith> yes, primarily
14:06:11 <copumpkin> *length-indexed
14:06:14 <kmc> tolkad, mostly.  real apps often define their own functions for parsing / pretty-printing.  there's not a lot of benefit to putting them in the Read / Show type classes
14:06:28 <tolkad> what about displaying numbers?
14:06:31 <kmc> what about it
14:06:43 <aristid> Show is useful for GHCi
14:06:47 <tolkad> is the use of show for that just for debuging?
14:06:49 <c_wraith> :t showIntAtBase
14:06:50 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
14:07:08 <kmc> tolkad, you could have special functions for showing numbers
14:07:09 <monochrom> And you know what I would say to those puritans who ban read and force reads on me?  do { x <- many1 digit; let [(n,"")] = reads x; ... }
14:07:25 <monochrom> My advice: pay lip service to the puritans.
14:07:50 <kmc> the point is that unifying all of these under the type class "Show" is useful only in certain generic contexts
14:07:54 <monochrom> The same lip service you would pay to people who say "you must write comments every other line"
14:07:57 <kmc> a prominent example being GHCi knowing how to print results
14:08:07 <kmc> haha
14:08:12 <BONUS> error handling sucks in pretty much every language so our best bet is to ignore it
14:08:16 <BONUS> it's what i do mostly
14:08:28 <nlogax> i just don't have any errors
14:08:34 <tolkad> -_-
14:08:39 <tolkad> nlogax: errors are relative
14:08:41 <kmc> int x = y + 2;  // Declare a new integer-typed variable x and initialize it to the value given by the sum of the value held by the integer variable y and the constant 2
14:09:06 <c_wraith> kmc: I don't know what that line does, could you explain it to me?
14:09:08 <tolkad> nlogax: a parsing error doesn't necessarily indicate invalid program state, it might just be bad user input
14:09:33 <kmc> that's why Read is not a real parser library
14:09:46 <kmc> try ReadP, parsec, uu-parsinglib etc
14:09:54 <nlogax> tolkad: yeah, i have lots of errors, and i'm not funny :(
14:10:20 <c_wraith> I'd like something like erlang's OTP in haskell.  That'd be pretty cool, actually.
14:10:37 <c_wraith> screw errors.  if something blows up, just restart it!
14:10:38 <Saizan> monochrom: i guess you never had to debug a failing read or head and couldn't figure out where the call was? it's also pretty silly that we have only read and reads and not one with a type suitable for the most common use case.
14:11:35 <copumpkin> especially since nobody ever uses the full power of the reads return value
14:12:26 <monochrom> You are correct I never had to debug.
14:12:35 <copumpkin> real mean write correct code the first time around
14:12:39 <copumpkin> and prove it
14:12:49 <Twey> readm = fmap fst . listToMaybe
14:12:58 <monochrom> Look at the example. "many1 digit" is just one line ago, not even 10 lines ago. What is there to debug?
14:13:24 <copumpkin> > read "1241251521632869230869" :: Int8
14:13:25 <lambdabot>   21
14:13:27 <copumpkin> yay!
14:13:33 <monochrom> I am not even talking about "you have many1 digits somewhere, and read 200 lines away"
14:14:04 <c_wraith> > 1241251521632869230869 :: Int8
14:14:05 <lambdabot>   21
14:15:08 <Saizan> monochrom: i guess i miss the context where people want to take read away from you, while i only see the Prelude lacking a total and straightforward to use alternative
14:15:26 <mreh> http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck -- this doesn't seem to explain why quickcheck doesn't, for example, generate more than five chars after 100 tests
14:15:39 <Saizan> which is the source of many newbies "how do i catch read's errors?"
14:16:31 <monochrom> readIO has the right type and its exception can be caught with catch. Haskell 98 compliant.
14:17:15 <tehgeekmeister> trying to debug some HDBC using database code in ghci, i get this on attempting to make a connection using my code (which works outside of ghci) Loading package HDBC-mysql-0.6.3 ... can't load .so/.DLL for: mygcc (dlopen(libmygcc.dylib, 9): image not found)
14:17:20 <tehgeekmeister> anyone got any clues?
14:17:32 <monochrom> It is no worse than "safeRead :: Maybe a" which is just another monad and less informative than IO.
14:18:05 <Saizan> less informative than IO?
14:18:28 <BONUS> but recovering from exceptions requires the use of IO, whereas if you encode failure into your data type, you can handle them purely
14:18:46 <Saizan> requiring IO just to signal an error seems quite overkill
14:19:23 <Saizan> and you can simply pattern match on a Maybe, without knowing about monads.
14:20:10 <Saizan> but anyhow, i guess i'm a bit of a puritan, since i think having partial functions easily available means they quite more likely end up in places where they can fail
14:21:35 <FunctorSalad> Maybe is also way more specific
14:21:44 <FunctorSalad> 'IO' being the toxic waste heap after all
14:22:14 <Jafet> Now I can't eat this burrito anymore.
14:23:53 <tehgeekmeister> do i need to do something special so that ghci will work with whatever shared library it needs?
14:25:14 <Saizan> tehgeekmeister: the ghci linker is quite delicate, i think it doesn't support linker scripts in any released version for example
14:25:25 <kmc> you should only use "head" in code extracted from Coq
14:25:27 <kmc> ;)
14:26:06 <Saizan> and it'd actually be unsafeCoerce fst, just for fun :)
14:26:18 <c_wraith> should I really write "catMaybes . map safeHead . group" instead of "map head . group"?  :)
14:26:34 <tehgeekmeister> Saizan: so i should just keep toying with the file and rerunning it, i guess?
14:27:01 <Saizan> tehgeekmeister: you could check if the .so for mygcc is a real .so
14:27:21 <tehgeekmeister> Saizan: this is beyond my understanding; if you care to explain, go for it, otherwise i'll work around this
14:27:22 <aristid> c_wraith, no, group guarantees the safety of head implicitly
14:27:24 <Cale> partial functions are useful for cases like that where either you know for certain that they will succeed, or it would be an abject failure of your program for them to fail (and so you don't care about the exception)
14:27:52 <kmc> group should probably return a NonEmptyList
14:27:57 <kmc> in ideal fantasy world
14:28:02 <aristid> kmc, a normal list of non-empty lists
14:28:06 <kmc> right
14:28:15 <kmc> that's kind of nice: (representative element, the rest)
14:28:20 <aristid> i had the idea today of a "at-least-N-elements list" type
14:28:28 <kmc> in particular in a DT language it could return a list of (lists with proof of nonemptiness)
14:28:33 <Saizan> tehgeekmeister: locate libmygcc.so, then use file to determine the file type
14:28:39 <kmc> a list with a proof of nonemptiness can be easier to work with than a special non-empty-list type
14:28:55 <lispy> I wonder if SHE would make a nice way to have non-empty lists but in Haskell
14:28:59 <aristid> kmc, can you make concise example code for that? :D
14:29:19 <lispy> (SHE is here http://hackage.haskell.org/package/she)
14:29:54 <FunctorSalad> aristid: AtLeastN n a = exists k. (GreaterThanOrEqual n k, Vector k a) no?
14:30:51 <aristid> FunctorSalad, is Vector a list type?
14:31:16 <FunctorSalad> aristid: yes, 'lists of exactly k elements'
14:31:27 <aristid> hmm interesting
14:31:41 <aristid> FunctorSalad, but that's not possible with haskell, right?
14:32:05 <tehgeekmeister> Saizan: ... i don't appear to have that file.  or it's in a lib directory i'm not aware of.
14:32:06 <FunctorSalad> aristid: it is possible with the 'faking dependent types' approach (typlevel naurals)
14:32:14 <aristid> FunctorSalad, cool
14:33:18 <Saizan> tehgeekmeister: weird, maybe run ldd on the compiled executable to see if ld found it
14:33:29 <FunctorSalad> (there are several libs but I don't know which is best)
14:34:29 <Saizan> tehgeekmeister: otherwise will know why ghci couldn't find it (you haven't one!) and we'd have to figure out why it's looking for it
14:35:25 <tehgeekmeister> Saizan: i'm inclined to just turn this file into Main temporarily and debug by compiling and running; i'm in a hurry and this is actually forcing me to make my code a bit more elegant
14:37:25 <Saizan> tehgeekmeister: 'k
14:38:08 <tehgeekmeister> Saizan: thanks though, i'll have to hunt this down later, and this has me on the right track when I need to.
14:38:55 <tehgeekmeister> shouldn't -Wall give me type signatures when I don't include them?
14:40:50 <Saizan> maybe it does that only for exported symbols? and no module header defaults to module Main (main) where afaik
14:41:50 <tehgeekmeister> nah, it did it for all functions in another file
14:41:51 <tehgeekmeister> weird
14:43:48 <sbpaul> > zipWith (++) "tehgeekmeister" "nah, it did it for all functions in another file"
14:43:49 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
14:43:49 <lambdabot>    arising from a use o...
14:43:57 <sbpaul> > zip "tehgeekmeister" "nah, it did it for all functions in another file"
14:43:58 <lambdabot>   [('t','n'),('e','a'),('h','h'),('g',','),('e',' '),('e','i'),('k','t'),('m'...
14:44:10 <sbpaul> must learn haskell
14:44:13 <tehgeekmeister> sbpaul: eh?
14:49:40 * hackagebot Holumbus-Distribution 0.1.1 - intra- and inter-program communication  http://hackage.haskell.org/package/Holumbus-Distribution-0.1.1 (StefanSchmidt)
14:50:41 * hackagebot Holumbus-MapReduce 0.1.1 - a distributed MapReduce framework  http://hackage.haskell.org/package/Holumbus-MapReduce-0.1.1 (StefanSchmidt)
15:10:04 <tehgeekmeister> hdbc throws an error when there's an empty result set on fetchRow; is this the intended behavior?  anyone know?
15:10:56 <bss03> @type fetchRow
15:10:57 <lambdabot> Not in scope: `fetchRow'
15:11:11 <bss03> @hoogle fetchRow
15:11:11 <lambdabot> No results found
15:11:27 <tehgeekmeister> fetchRow :: Statement -> IO (Maybe [SqlValue])
15:11:43 <tehgeekmeister> you'd think it'd just give you nothing
15:11:51 <bss03> Seems to me like it should give Nothing.
15:12:03 <tehgeekmeister> in fact, it says: Fetches one row from the DB. Returns Nothing if there are no more rows. Will automatically call finish when the last row is read.
15:12:08 <tehgeekmeister> as it's documentation
15:13:48 <bss03> Maybe a bug then.  You got some example code / data for testing?
15:14:27 <bss03> Either way, probably worth talking to someone more HDBC-savvy then myself, maybe a maintainer or something.
15:14:46 <tehgeekmeister> i think it might actually be an error, i'm checking
15:14:51 <tehgeekmeister> need to consult #mysql first
15:15:47 <tehgeekmeister> (i.e.: i think my query might be of a sort that mysql doesn't consider it to have a result set (though i'd imagine that not to be the case with a select...))
15:17:20 <tehgeekmeister> (of course, in the mysql console the same query gives a result.)
15:23:01 <tehgeekmeister> maaaaan.  i hate how i always run into blocking problems like this using haskell.  i really wanna use it for my webapp, but it keeps being a PITA and holding me up.
15:24:46 <djahandarie> You could not use MySQL, but that'd likely be a major overhaul at this point
15:25:30 <tehgeekmeister> djahandarie: no, that'd be pretty simple.
15:25:38 <tehgeekmeister> i'd just have to change one line.
15:25:44 <tehgeekmeister> but i doubt it'd fix the problem
15:25:48 <tehgeekmeister> the query works fine inside mysql
15:25:50 <tehgeekmeister> it doesn't work in hdbc
15:26:07 <tehgeekmeister> i could use no database, potentially
15:26:12 <djahandarie> I mean not use any external database, just use Haskell-made data structures and such
15:26:20 <tehgeekmeister> then i have to handle persistence on my own
15:26:35 <tehgeekmeister> i *really* don't want to lose all of a user's data because of a bug
15:27:38 <tehgeekmeister> perhaps could use happstack state?
15:27:39 <tehgeekmeister> hmmm.
15:27:58 <chrisdone> http://i.imgur.com/gmdNm.png
15:27:58 <chrisdone> http://i.imgur.com/8n6Su.png
15:27:59 <chrisdone> woopwoop
15:28:11 <djahandarie> Not sure if you can just plug that in
15:28:36 <djahandarie> Nice chrisdone 
15:28:41 <mreh> how can I get haskell to output double in normal form
15:28:47 <djahandarie> What other languages will it support? :P
15:28:51 <tehgeekmeister> it should be modular, but i'm not sure they've made it that way yet.
15:29:07 <chrisdone> djahandarie: everything highlighting-kate supports
15:29:14 <bss03> mreh: What's normal form?
15:29:20 <chrisdone> djahandarie: but it'll have more haskell-specific stuff, like automatic hlint
15:29:25 <djahandarie> Cool
15:29:36 <chrisdone> hook-up with codepad.org
15:29:40 <djahandarie> You should make it compile
15:29:43 <mreh> 0.012, not 12e-3
15:29:47 <djahandarie> Ah
15:29:50 <Veinor> chrisdone: I don't like the paste thing being on the left
15:29:57 <djahandarie> Isn't codepad.org Haskell Hugs?
15:29:58 <Saizan> mreh: see Numeric
15:30:35 <chrisdone> djahandarie: well, I could compile if it's worth adding
15:31:38 <Veinor> djahandarie: I'd check but codepad seems to be down
15:31:43 <bss03> mreh: showFFloat
15:32:06 <djahandarie> chrisdone, don't add it if it takes down the service every other minute :P
15:32:15 <chrisdone> Veinor: you'd prefer it on the left?
15:32:25 <chrisdone> djahandarie: codepad runs as well tho, not just compiles
15:32:30 <bss03> > showFFloat Nothing (pi :: Double) ""
15:32:32 <chrisdone> Veinor: er, the right?
15:32:33 <Veinor> I like the way pastebin looks
15:32:33 <lambdabot>   "3.141592653589793"
15:32:36 <Veinor> so do that :P
15:32:45 <bss03> > showFFloat Nothing (0.012 :: Double) ""
15:32:46 <lambdabot>   "0.012"
15:32:52 <Veinor> but seriously, I'd prefer the paste area to be a lot wider
15:33:04 <Veinor> and the 'newest pastes' thing to be narrower and on the left
15:33:07 <djahandarie> chrisdone, compiling could be useful so people wouldn't need to paste their errors as comments or something
15:33:11 <chrisdone> Veinor: why?
15:33:30 <chrisdone> djahandarie: good idea
15:34:08 <chrisdone> alternatively they could just paste in logs as an annotation :p
15:34:14 <Veinor> chrisdone: because when I go to a pastebin-type site, I'm looking for the place to paste code
15:34:25 <chrisdone> compiling is Hard because it needs the right compile flags and packages
15:34:36 <Veinor> I'm looking at the center of the screen usually, so I expect the thing to be in the center
15:34:37 <chrisdone> Veinor: and people read from the left
15:34:53 <djahandarie> I don't think location of a paste box is difficult
15:35:05 <djahandarie> Since it is so big and distinct
15:35:13 <Veinor> it still annoys me :/
15:35:13 <djahandarie> Just make sure all the other junk is optional
15:35:36 <Veinor> actually
15:35:44 <Veinor> you can have the latest pastes be on the right
15:35:53 <tehgeekmeister> has anyone used hashmap?  it claims to be a persistent map and set, but the return values aren't in the IO monad?
15:35:53 <Veinor> as long as the paste box is as wide as the rest of the screen
15:36:19 <Veinor> also codepad uses Hugs september 2006 with -98
15:37:31 <Saizan> tehgeekmeister: it could be using the other meaning of persistent, which is roughly not-mutable
15:38:03 <tehgeekmeister> Saizan: but it's implemented in terms of data.map and data.set, which is mutable.
15:38:04 <chrisdone> tbh I'll do a survey when it's done. user testing is how you ascertain real user requirements
15:38:08 <Veinor> true
15:38:47 <chrisdone> I know what you mean, I generally don't care about the other pastes
15:38:53 * hackagebot text 0.8.0.0 - An efficient packed Unicode text type  http://hackage.haskell.org/package/text-0.8.0.0 (BryanOSullivan)
15:38:54 <chrisdone> I like gist's http://gist.github.com/
15:39:03 <djahandarie> Yeay, new text
15:40:28 * tehgeekmeister is considering how much work it'll be to implement persistence on his own
15:40:29 <Saizan> tehgeekmeister: they are not mutable
15:40:38 <tehgeekmeister> Saizan: they aren't?
15:40:42 <tehgeekmeister> Saizan: oh, right.  they aren't.
15:40:54 <tehgeekmeister> Saizan: dunno why i thot they are.  i've used them extensively.
15:41:12 <djahandarie> bos, any changelog on that new version?
15:41:51 <bos> djahandarie: not yet
15:42:05 <bos> djahandarie: i'll write something up tonight when i have time
15:42:18 <djahandarie> Okay :)
15:43:54 <tommd> bos: Re: crypto-api.  If you wouldn't use the RandomGen class what do you suggest?  I'm all in favor of better Random support but don't want to rock the boat so much that users of MonadRandom can't use the crypto-api easily.
15:44:13 <bos> tommd: we don't have a suitable typeclass yet
15:44:27 <bos> tommd: RandomGen would be fine if it didn't have split
15:44:30 <tommd> My thought too, but was hoping we were missing something.
15:44:56 <tommd> bos: RandomGen doesn't have any sort of "reseed" or "additional entropy" routine, which I think would be really good.
15:45:04 <bos> djahandarie: briefly: better API, more tests, fewer bugs, and much faster
15:45:10 <bos> djahandarie: so it's a major release
15:45:11 <tommd> And defaulting to "Nothing" would be reasonable.
15:45:13 <sm> tehgeekmeister: does yesod's persistent help ?
15:45:13 <djahandarie> \o/
15:45:24 <tehgeekmeister> sm: i can't find documentation on it
15:45:28 <tehgeekmeister> sm: or it itself, yet
15:45:34 <tehgeekmeister> didn't look too much, though
15:45:45 <sm> http://docs.yesodweb.com/ -> It's still there, I guess
15:45:56 <sm> and http://hackage.haskell.org/package/persistent
15:45:58 <chrisdone> Veinor: http://i.imgur.com/rGaBs.png
15:46:03 <tehgeekmeister> ah, it's that persistent
15:46:15 <tehgeekmeister> i ignored it because it used postgresql or sqlite, but, man, at this point i'm ready to switch
15:46:20 <tehgeekmeister> i just want to get this app written
15:46:44 <sm> you could probably add a mysql backend easily, if not someone else will, but at least you won't be locked in
15:47:17 <sm> I've never used it, I'm just curious. I hear your pain
15:47:40 <tehgeekmeister> well, hdbc has worked great for me in the past
15:47:55 <tehgeekmeister> but it won't work, as far as i can figure out, for querying whether a user exists
15:47:57 <tehgeekmeister> i can add them
15:48:10 <tehgeekmeister> but it throws an error when i try to query to see if a user exists
15:48:13 <sm> maybe john goerzen can help ?
15:48:31 <tehgeekmeister> he's not in here right now, i'm trying to get this up quiiiiiick.
15:48:46 <sm> aha. In that case, can you catch the error ? 
15:48:53 <tehgeekmeister> i set a deadline of tonight tomorrow for myself, and i'm running up close to it.
15:49:01 <tehgeekmeister> no, because it throws the error whether the user exists or not
15:49:02 <sm> and/or "don't do that" ? :)
15:49:11 <tehgeekmeister> and doesn't give me the information i need
15:49:31 <tehgeekmeister> i either need to avoid the error entirely or switch to a different data store
15:50:15 <Veinor> chrisdone: better  :)
15:50:27 <tehgeekmeister> persistent looks pretty good, i may just use it
15:50:39 <tehgeekmeister> i can switch to postgresql, i think
15:51:02 <Veinor> chrisdone: is that a fixed width or does it adjust as you resize your browser?
15:51:44 <chrisdone> Veinor: it's according to browser window width
15:52:17 <Veinor> well, that's fine
15:53:17 <chrisdone> does this work? http://87.5.110.241:9000
15:53:34 <chrisdone> this router's all in italian so I'm not sure if I'm missing something
15:53:42 <Cale> yes, it works
15:53:54 <chrisdone> ok, nice
15:53:55 <BONUS> whoa nice
15:53:59 <chrisdone> Veinor: we can discuss more in #haskell-blah
15:54:07 <chrisdone> BONUS: :D
15:54:27 <BONUS> you deserve the highest of fives
15:55:02 * chrisdone receives the five by jumping
15:55:04 <Cale> Not sure if it's just my browser, but the shadow in the big editbox doesn't continue far enough to the right
15:55:20 <BONUS> yeah it's cut off for me as well
15:55:45 <chrisdone> Cale: that's right, just a bug. I'll put this on tryhaskell.org's server when I'm done ironing stuff out
15:56:20 <chrisdone> other than hlint and maybe some tryhaskell/mueval support, anyone got haskell-specific hpaste ideas?
15:56:47 <Entroacceptor> xmonad config compiler...
15:57:05 <Cale> Retroactive editing of pastes
15:57:12 <BONUS> it would be really cool if you could hpaste something and then underneath it receive a tryhaskell session with the stuff from the paste loaded in
15:57:18 <BONUS> but i don't know if that would be doable
15:57:32 <chrisdone> Cale: is that revisions or annotations?
15:57:39 <Cale> Revisions
15:57:47 <chrisdone> BONUS: that's doable provided all the imports are safe!
15:57:54 <Jafet> BONUS: codepad and ideone do evaluate code
15:58:00 <chrisdone> Cale: yeah, I was thinking the same thing -- like gist?
15:58:01 <BONUS> ah
15:58:04 <Jafet> I've never used either for haskell, though
15:58:31 <Cale> I've always been sort of annoyed how hpaste doesn't really give you the ability to edit a paste if you made some stupid mistake.
15:58:59 <Cale> You have to basically make a whole new paste based on the first one, rather than replacing the first one.
15:59:04 <chrisdone> Cale: ahhh. indeed. it happens here a lot, you end up with three annotations instead of one correct one
15:59:06 <chrisdone> yeah
15:59:16 <Jafet> That would require some authentication system (does it have one?)
15:59:18 <sproingie> chrisdone: hoogle support would be nice
15:59:23 <jmcarthur> a new version of quickcheck?
15:59:34 <sproingie> chrisdone: in the form of clicky links perhaps
15:59:43 <Entroacceptor> just a simple cookie would be enough, I think?
15:59:45 <BONUS> you could just send the guy who makes the paste a cookie
15:59:48 <djahandarie> jmcarthur, where?
15:59:48 <chrisdone> Jafet: Cale: it could just be sesson-based -- assuming it's just for quickly correcting mistakes?
15:59:49 <Cale> It just requires some system to resolve conflicts
15:59:54 <Cale> yeah
16:00:08 <Jafet> I suppose that's an authentication system
16:00:11 <jmcarthur> djahandarie: on hackage
16:00:14 <jmcarthur> 2.3
16:00:14 <djahandarie> Oh nice, I see it now
16:00:14 <chrisdone> sproingie: you mean any symbols within the page? sure
16:00:28 <BONUS> cookie + IP snooping and you're set
16:00:31 <chrisdone> Cale: Jafet: I can add that, no problemo
16:00:35 * chrisdone adds notes in his TODO
16:00:45 <BONUS> but otherwise i wouldn't go overboard with features
16:01:02 <chrisdone> BONUS: yep
16:01:08 <BONUS> because no matter what you do i bet 99% of ppl will use it just for pasting 99% of the time
16:01:15 <Entroacceptor> chrisdone: make the viewer able to select the hilighting language (not haskell specific, though, and only if you add more than haskell)
16:01:15 <chrisdone> BONUS: gist does the same -- you can login to claim a post, but it's not required
16:01:35 <chrisdone> Entroacceptor: ah, like paste.lisp.org? sure
16:01:57 <BONUS> thinking of making a color ghci ...
16:02:10 <Veinor> BONUS: with syntax highlighting?
16:02:10 <sproingie> BONUS: like colorforth?
16:02:16 <BONUS> yeah
16:02:40 <BONUS> just a simple program that launches a ghci in the background and acts like ghci towards the user but syntax highlights its output
16:02:44 <Cale> chrisdone: Regarding the session/auth thing, we used to just put pastes on the Haskell Wiki, and it worked surprisingly well.
16:02:46 <jmcarthur> looks like lots of little tweaks and some new instances, i guess
16:03:09 <BONUS> although i'm not looking forward to regexing haskell syntax
16:03:57 <Cale> I don't think people usually care so much if other people edit their pasted things in-place, you just have to be able to handle the case where multiple people are trying to edit the same thing at once.
16:04:23 <Veinor> BONUS: parsec!
16:04:37 <Veinor> alternately, just use whatever ghci uses to lex. it can't be that hard!
16:04:55 <Jafet> ghci doesn't parse, does it?
16:05:00 <Cale> Just checking to see if it's changed since the person edited it and giving them the option of making an annotation rather than a revision would also work well.
16:05:04 <Jafet> That's why it won't accept multiline inputs...
16:05:07 <Veinor> er, ghc, not ghci
16:05:14 <notabel> Veinor: syntax highlighting is actually harder than lexing/parsing for compilation, because you need to work incrementally, and with syntactic fragments
16:05:20 <Veinor> true
16:05:27 <BONUS> Veinor: yeah i thought about that, but parsec might be overkill since you can do syntax coloring with regular languages
16:05:42 <BONUS> and there's that as well
16:05:47 <FunctorSalad> . o O ( regexing... it's a myth that regexes can't parse parenthesised expressions; there is no evidence that somebody ever used more than 300 levels of parentheses except to prove a point ) </clown>
16:05:57 <FunctorSalad> sorry ;)
16:05:59 <kmc> haha FunctorSalad
16:05:59 <BONUS> haha
16:06:12 <Cale> There's a project for someone...
16:06:20 <BONUS> lisp people don't count because they're crazy by definition
16:06:29 <kmc> has anyone made a programming language with *only* parentheses?
16:06:34 <kmc> (properly nested of course)
16:06:34 <notabel> Jafet: ghci can handle multiline input with :{ and :}
16:06:35 <djahandarie> Haha
16:06:37 <Cale> Write a program which takes a CFG, and gives a regular expression which parses an approximation to that language with a given depr.
16:06:39 <Veinor> kmc: now I want to
16:06:43 <Cale> argh
16:06:50 <Cale> given depth parameter
16:06:55 <BONUS> haha oh my
16:07:12 <FunctorSalad> Cale: some vim scripts actually do something like this (manually created I guess)
16:07:19 <Veinor> notabel: :O
16:07:23 <FunctorSalad> (like the block highlighting one etc)
16:07:27 <djahandarie> kmc, is it possible to write a touring complete language with only two tokens?
16:07:29 <Jafet> kmc: iota is pretty close.
16:07:44 <Veinor> notabel: is there documentation on how this works?
16:07:45 <kmc> djahandarie, if you can encode a single integer, you can encode a turing-complete language
16:07:45 <FunctorSalad> probably better than nothing if you're presented with an interface that won't support more than regexes
16:08:04 <Veinor> because I can't get it to do so
16:08:14 <kmc> djahandarie, for example you could just take the maximum depth of the tree
16:08:21 <kmc> but that's not very interesting
16:08:59 <BONUS> yeah, there's a bijection between programs and integers
16:09:03 <Jafet> .oO(What about defining a language to have a maximum allowed nesting depth?)
16:09:03 <chrisdone> Cale: hmmm. yeah. if it's changed since you last viewed it but you submit an update, it can just say, here's the current version, you might want to view the new version before submitting yours, or make this an annotation. sounds good
16:09:05 <notabel> djahandarie: Jot
16:09:21 <Jafet> That way, the syntax of your language could be regular.
16:09:24 <notabel> Jot is a combinator language with only two tokens, 0 and 1
16:09:37 <chrisdone> S and K?
16:09:42 <Veinor> oh, :{ :} doesn't actually insert newlines. foo.
16:09:47 <BONUS> is a language guaranteed to be regular if it has a maximum allowed nesting depth?
16:09:50 <Jafet> chrisdone, sk still needs parentheses.
16:09:55 <notabel> every string of zeros and ones forms a syntacticly valid program
16:09:56 <chrisdone> Jafet: true
16:10:06 <Jafet> BONUS: no, but it becomes possible to make it one.
16:10:14 <BONUS> ah, indeed
16:10:24 <Jafet> Imagine the people who swell to adopt your new language because they can refactor it in sed scripts.
16:10:48 <BONUS> so you'd have a language that's useful but not turing complete then?
16:10:53 <Veinor> iota has three symbols, U, (, and )
16:11:16 <notabel> jot is designed to directly implement a Goedel numbering
16:11:16 <chrisdone> where U = SKsomething?
16:11:30 <Veinor> U = λf.((fS)K)
16:11:33 <BONUS> or could it also be turing complete despite its grammar being regular
16:11:36 <Jafet> Technically, no language is turing complete, so that's an academic detail
16:11:55 <Jafet> Anyway, the syntax of postfix notation is regular.
16:12:01 <FunctorSalad> BONUS: different levels?
16:12:12 <Gracenotes> why not? their implementations, maybe not..
16:12:36 <FunctorSalad> (syntax vs. semantics of the language)
16:13:20 <FunctorSalad> I guess you can easily have a semantically turing-complete syntactically regular language by making all the syntax errors runtime errors o_o
16:13:30 <FunctorSalad> (cue joke about a language where this is the case)
16:13:50 <BONUS> haha
16:14:16 <FunctorSalad> I can't think of any though
16:14:46 <FunctorSalad> SK combinatorial calculus?
16:14:55 <notabel> FunctorSalad: well, do you mean runtime error in the sense that an error is signalled, or in the sense that the program misbehaves arbitrarily?
16:14:59 <Jafet> Well, in jot every possible combination of the two symbols is a well-formed program
16:15:15 <notabel> for the latter, any language with no syntacticly-invalid programs qualifies
16:15:28 <FunctorSalad> notabel: depends on how we formalize the possible semantics... it could just evaluate to 'bottom' in haskell semantics terms
16:15:46 <FunctorSalad> (for invalid programs)
16:16:13 <djahandarie> Is it possible to make a type-level forkbomb with GHC?
16:16:35 <Jafet> How do you get ghc to fork()?
16:16:54 <BONUS> if you had a Fork type, yeah
16:16:56 <djahandarie> I don't know, that's pretty much my question
16:17:47 <Jafet> Well, you could definitely make it run out of memory
16:19:01 * djahandarie will brb
16:21:43 <BONUS> apart from ST, are there any cool examples of rank n types enforcing program invariants
16:22:14 <BONUS> i remember seeing a blog post about that recently but i forgot to finish it and i lost the link
16:22:33 <Jafet> Isn't ST just rank 2?
16:22:40 <FunctorSalad> tehre is a fork on the value level in the posix hierarchy
16:22:44 <BONUS> isn't rank 2 rank n?
16:22:45 <FunctorSalad> ... there
16:22:53 <kmc> isn't rank 1 rank n?
16:22:55 <kmc> [/super pedant]
16:22:57 <BONUS> touche
16:23:07 <BONUS> well, or rank 2
16:23:14 <FunctorSalad> System.Posix.Process forkProcess :: IO () -> IO ProcessID
16:23:18 <notabel> kmc: they're different GHC options, for counterpedantry :-)
16:23:27 <FunctorSalad> but what does this have to do with the typelevel :-(
16:24:04 <BONUS> FunctorSalad: i think djahandarie was thinking more along the lines if just typechecking some haskell program could cause a fork bomb
16:24:11 <notabel> djahandarie: there are no calls to forkOS in the source of the compiler proper
16:24:39 <notabel> so it shouldn't be possible, except in so far as template haskell makes arbitrary IO possible during compilation
16:24:43 <Saizan> unsafePerformIO :: IO a -> *
16:24:48 <megajosh2> We no longer have a linear linked list as a topic? <_<
16:25:06 <FunctorSalad> class ... where is :: a -> b -> Prop ...  instance ... where { is = equals } .... instance where { is = isAnExampleOf }
16:25:13 <Jafet> megajosh: eh? The topic is still a list
16:25:20 <megajosh2> Huh. I don't see it
16:25:26 <megajosh2> Must be my client
16:26:06 <FunctorSalad> BONUS: hmm... I wouldn't expect ghc to fork
16:26:14 <FunctorSalad> (for typechecking)
16:26:38 <FunctorSalad> nothing that couldn't be done with threads (haskell or not), no?
16:26:47 <frerich_> Hi, I'm currently working on the exercises in the (most excellent!) "Real World Haskell" book. One of the exercises is to write a function which determines whether a given list is a palindrome. I'm attempting to do this in a better way than "ispalindrome x = x == reverse x", but somehow I can't seem to get the pattern matching right:
16:26:58 <notabel> FunctorSalad: as I said, there aren't any calls to forkOS in the source
16:27:00 <frerich_> ispalindrome (x:xs:y) = x == y && ispalindrome xs
16:27:00 <frerich_> ispalindrome _        = True
16:27:15 <BONUS> what can be better than x == reverse x
16:27:30 <FunctorSalad> notabel: grep or knowledge by heart of ghc? ;)
16:27:30 <kmc> frerich_, you can't pattern match the end of a list like that
16:27:32 <notabel> frerich_: that pattern match is ill-formed
16:27:42 <frerich_> Oh, hm
16:27:42 <dmwit> BONUS: take a half x == take a half (reverse x) ?
16:27:51 <kmc> (x:xs:y) would match the fisrt element as x and the second as xs
16:27:55 <kmc> and the rest as a list y
16:28:02 <notabel> how would the compiler know which of x, xs, and y is supposed to get more than one element?  remember that 'xs' is just convention, the compiler doesn't know you meant it to be plural
16:28:06 <BONUS> the pattern match is ok but not in the context of his program :)
16:28:06 <frerich_> kmc: aaah
16:28:13 <FunctorSalad> notabel: even forkOS doesn't fork, does it
16:28:13 <BONUS> dmwit: yeah but then it's half as elegant
16:28:19 <dmwit> ;-)
16:28:26 <frerich_> kmc: doh, I get it now, thanks
16:28:30 <dmwit> half as elegant, but 1.5x faster... what a choice!
16:28:41 <notabel> FunctorSalad: if by fork you mean the posix call, no
16:28:42 <dmwit> (2 - epsilon)x faster
16:29:00 <notabel> though, i'm not sure actually, it may use it internally.  
16:29:07 <notabel> i haven't looked at the implementation recently
16:29:12 <FunctorSalad> notabel: yes I mean that or starting a process some other way (if that's even possible)
16:29:21 <FunctorSalad> AFAIK forkOS just starts a thread
16:29:59 <FunctorSalad> maybe processes and threads are not as different in linux as I think though?
16:30:17 <theorbtwo> They aren't very different at all.
16:30:33 <notabel> but they are different (even though the implementation is mostly shared)
16:30:55 <notabel> FunctorSalad: processes are in System.Process, or under the platform-specific heirarchy
16:31:13 <frerich_> dmwit: 'half x == reverse (half x)' would be faster? How so? Wouldn't (if it worked...) the 'ispalindrome (x:xs:y) = x == y && ispalindrome' perform only length x / 2 comparisons (and the same recursion depth)?
16:31:13 <FunctorSalad> notabel: yep,  System.Posix.Process forkProcess :: IO () -> IO ProcessID
16:31:15 <notabel> System.Process isn't used in GHC itself at all, i'm pretty sure
16:31:41 <Veinor> frerich_: getting the last element of a list takes n operations where n is the length of the list
16:31:43 <FunctorSalad> (which incidentally comes with a warning that doing anything else than executeFile in the forked process will fail epically)
16:32:12 <Veinor> because haskell lists are singly-linked lists
16:32:17 <frerich_> ah
16:32:41 <frerich_> I must say, all this super-abstracted thinking kind of made me forget that haskell can't just magically get the last element 'directly' :-}
16:32:56 <notabel> FunctorSalad: okay, checked and can speak with authority now
16:33:02 <Veinor> yeah, there have been times where I wish haskell used arrays like in, say, python
16:33:20 <arw> or doubly linked lists with a last-pointer.
16:33:29 <Veinor> yeah.
16:33:34 <kmc> "used arrays" for what?
16:33:40 <arw> or fancy trees or stuff. but there are always tradeoffs.
16:33:45 <kmc> the standard library has lists, arrays, maps, tries, etc.
16:33:49 <arw> kmc: indexed access.
16:34:01 <kmc> i am confused about how Haskell does or doesn't "use arrays"
16:34:01 <notabel> the only place that GHC forks off new processes is via the SysTools module, for accessing the compiler, linker, cp, rm, etc
16:34:08 <kmc> arrays are one of many data structures you can manipulate in Haskell
16:34:12 <absentia> xn/win shrink 3
16:34:13 <absentia> xn/win shrink 3
16:34:14 <kmc> if you're not using an array it's because you decided not to
16:34:27 <Veinor> kmc: true
16:34:41 <kmc> we teach lists to beginners first because they're simple and emphasize laziness
16:34:51 <kmc> that doesn't mean lists are the only first-class data structure
16:35:08 <arw> kmc: yes, what i mean is, the collection type one usually uses is the list, which is not ideal for everything. and at that point you wish for the "standard" collection to be something else.
16:35:32 <FunctorSalad> well, you are rather discouraged from arrays
16:35:33 <kmc> why is the list the one you usually use?
16:35:37 <kmc> how is there a "standard"?
16:35:47 <arw> kmc: "the one you learn about first"
16:35:50 <FunctorSalad> I still don't know which one I'm supposed to use :|
16:35:53 <kmc> there's a list API, and a Data.Sequence API, and an array API (several actually)
16:36:13 <kmc> arw, right, it's important to learn others later
16:36:15 <FunctorSalad> (among the various packages and their many modules)
16:36:57 <Veinor> it's also 'standard' in that if you say [1,2,3] you get a list
16:36:58 <Veinor> ;)
16:37:06 <kmc> and if i say (1,2,3) i get a tuple
16:37:14 <kmc> and if i say fromList [1,2,3] i get whatever container library is in scope ;)
16:37:21 <kmc> anyway
16:37:30 <kmc> it is hard to write good Haskell code if you are a beginner
16:37:34 <kmc> it's difficult to learn, takes time, etc.
16:37:36 <Veinor> > length "fromList [1,2,3]" < length "[1,2,3]"
16:37:37 <lambdabot>   False
16:37:46 <Veinor> but I see your point
16:37:46 * kmc is a bit of a broken record
16:38:23 <kmc> the Prelude is fairly list-centric, true
16:38:34 <kmc> to the point of having things like "lookup" and (!!) that really aren't suitable for lists
16:38:49 <FunctorSalad> oh god, (!!)
16:38:57 <megajosh2> !!?
16:38:59 <Veinor> (!!) should be a typeclass function!
16:39:01 <megajosh2> !!?!?!?!?
16:39:02 <kmc> @src (!!)
16:39:02 <lambdabot> xs     !! n | n < 0 = undefined
16:39:02 <lambdabot> []     !! _         = undefined
16:39:02 <lambdabot> (x:_)  !! 0         = x
16:39:02 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:39:12 <megajosh2> !!!
16:39:18 <ski> .
16:39:40 <megajosh2> Hmm... !! as part of a typeclass...
16:39:52 <Veinor> (!!) :: (Indexable l) => l a -> Integer -> a
16:40:27 <FunctorSalad> why not (Apply a b c) => a -> b -> c while we're at it ;)
16:40:35 <megajosh2> It's not like [] isn't in a zillion typeclasses already <_<
16:40:36 <Veinor> programmable whitespace!
16:40:42 <FunctorSalad> (but with fundeps)
16:40:46 <FunctorSalad> a b -> c at least
16:41:07 <Veinor> then you can say [1,2] 0 and get 1
16:41:13 <FunctorSalad> a c -> b too probably
16:41:20 <ski> BONUS : i'm not sure whether <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10060> qualifies for what you had in mind ?
16:41:59 <hpc> @info []
16:42:00 <lambdabot> []
16:42:04 <FunctorSalad> err or much stronger actually: a -> c, a -> b
16:42:06 <kmc> @src []
16:42:06 <lambdabot> data [] a = [] | a : [a]
16:42:17 <hpc> i wanted to see what instances lambdabot knows of
16:42:43 <ski> @instances Eq
16:42:43 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
16:43:13 <hpc> @instances []
16:43:14 <lambdabot> Plugin `instances' failed with: regex failed: (ReturnCode 7,"Unmatched [ or [^")
16:43:28 <Jafet> Hahaha
16:43:50 <Veinor> @instances ()
16:43:50 <lambdabot> Couldn't find class `()'. Try @instances-importing
16:43:54 <Veinor> that's why ;)
16:43:55 <megajosh2> @instances ([])
16:43:55 <lambdabot> Plugin `instances' failed with: regex failed: (ReturnCode 7,"Unmatched [ or [^")
16:44:06 <Veinor> @classes
16:44:06 <lambdabot> Unknown command, try @list
16:44:45 <ski> `instances' only goes from a class to types which instance it, not the other way around
16:45:37 <dolio> (!!) has some okay uses, but it's probably most used for bad ones by people who don't know better.
16:45:49 <dolio> Also, there's probably a better combinator than (!!) for the okay uses.
16:45:51 <Veinor> dolio: such as?
16:45:59 <dolio> Which part?
16:46:09 <Veinor> what's an okay use of !!
16:46:12 <hpc> i am curious about both, actually
16:46:25 <Veinor> I guess stuff like fibs
16:46:27 <etpace> @hoogle [a] -> Int -> MAybe a
16:46:29 <lambdabot> Did you mean: [a] -> Int -> Maybe a /count=20
16:46:29 <lambdabot> Prelude (!!) :: [a] -> Int -> a
16:46:29 <lambdabot> Data.List (!!) :: [a] -> Int -> a
16:46:52 <Jafet> isPalindrome xs = and $ zipWith (==) [xs!!n | n<-[0..length n-1]] [xs!!n | n<-[length n-1,length n-2..0]]
16:47:14 <Veinor> Jafet: finally, an O(n^2) implementation of isPalindrome!
16:47:16 <dolio> Veinor: Something like 'iterate f x !! k' is an all right substitute for the non-existent 'foldInt f x k'.
16:47:17 <hpc> @hoogle [a] -> Int -> Maybe a
16:47:18 <lambdabot> Prelude (!!) :: [a] -> Int -> a
16:47:18 <lambdabot> Data.List (!!) :: [a] -> Int -> a
16:47:18 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
16:47:28 <Veinor> dolio: also true
16:47:43 <etpace> mm so theres no safe !! in data.list
16:48:20 <aavogt> @type \n -> lookup n . zip [0 .. ]
16:48:20 <lambdabot> forall a b. (Num a, Enum a) => a -> [b] -> Maybe b
16:48:38 <ski> @type genericIndex . (`map` iterate (+1) 0)
16:48:38 <lambdabot> forall a a1 b. (Integral a, Num a1) => (a1 -> b) -> a -> b
16:48:46 <hpc> there should be an annotation that throws a compiler warning if you use the function, i think
16:48:53 <hpc> for things like (!!) that can error
16:49:06 <notabel> hpc: you could add a deprecation annotation to it
16:49:18 <Jafet> hpc: that would further reduce the number of people who put up with -Wall
16:49:26 <notabel> or a warning annotation
16:49:33 <int80_h> notabel!
16:49:45 <int80_h> notabel, do you have a moment to discuss your re-write
16:49:51 <hpc> Jafet: how much stuff does -Wall warn on?
16:50:01 <notabel> {-# WARNING "This is a partial function." #-}
16:50:15 <notabel> int80_h: sure.  care to give me the hpaste link?
16:50:27 <Jafet> hpc: I don't know, so I'll just say "a lot"
16:51:09 <int80_h> notabel: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29580#a29614
16:51:28 <int80_h> at the time I didn't know it was you who made the changes, I figured it out eventually.
16:52:06 <hpc> notabel: that's precisely what i want, although probably with something less technical: "This function throws errors. Make sure *crash condition* does not occur"
16:52:13 * chrisdone uses -Wall in ghci
16:52:29 <int80_h> notabel: I have an idea of what needs ot be done, but it's something I've not done before and I wanted to go over implementation options
16:52:33 <notabel> well hpc, just litter your code with WARNING pragmas then :-)
16:53:00 <hpc> notabel: i was thinking for the standard libraries; i always write total functions
16:53:10 <chrisdone> I'd want a partial function warning just as if I'd wrote it myself
16:53:33 <chrisdone> foo [] = x   ->   Warning: Pattern match(es) are non-exhaustive
16:53:34 <Pseudonym> {-# WARNING "This code may throw an exception." #-} openFile
16:53:48 <Pseudonym> Turtles all the way down, I suspect.
16:53:52 <ski> exhaustiveness checking in patterns ?
16:53:54 <Pseudonym> Oh, I know!  CHECKED exceptions!
16:54:00 <notabel> int80_h: yeah, this is what happens when i code without thinking.  one second
16:54:04 * Pseudonym chuckles evilly
16:54:22 <hpc> Pseudonym: IO exceptions != calling error in pure code
16:54:33 <int80_h> notabel: this is on the right track I think
16:54:55 <int80_h> notabel: we need to make a heterogenous collection, I think.
16:55:03 <dolio> Anyone here subscribed to the TYPES list?
16:56:15 <int80_h> notabel: one option was the GADT approach, and I'm wondering if it's the right way in this case.
16:57:34 <chrisdone> ski: yeah, it would be nice if GHC could warn me of partial function use in the same way it warns me of partial function authoring
16:58:18 <hpc> chrisdone: also, it would be nice to make it not an extension, like everything seems to become
16:58:40 <chrisdone> I like extensions personally
16:58:55 <chrisdone> {-# LANGUAGE DeriveDataTypeable, RecordWildCards, RankNTypes, NamedFieldPuns,
16:58:55 <chrisdone> DisambiguateRecordFields, TupleSections, GeneralizedNewtypeDeriving,
16:58:55 <chrisdone> ScopedTypeVariables, FlexibleContexts, FlexibleInstances,
16:58:55 <chrisdone> OverloadedStrings #-}
16:58:58 <chrisdone> that's at the top of my hpaste code :p
16:59:17 <hpc> TupleSections?
16:59:23 <dolio> So, you mean, you expect people to annotate all their partial functions as being partial?
16:59:29 <chrisdone> > map (,1) [1..10]
16:59:30 <lambdabot>   <no location info>: parse error on input `1'
16:59:45 <dolio> I bet a lot of people wouldn't be down with that.
16:59:45 <chrisdone> if lamdabot had tuplesections enabled, this would've behaved as you'd expect
16:59:52 <hpc> huh
17:00:04 <chrisdone> (,1) :: Num a => x -> (x,a)
17:00:05 <hpc> > map (1 ,) [1..10]
17:00:06 <lambdabot>   <no location info>: parse error on input `)'
17:00:18 <hpc> why is that not standard?
17:00:48 <ski> chrisdone : `-fwarn-incomplete-patterns' ?
17:00:53 <chrisdone> probably because
17:00:55 <chrisdone> > map ((,) 1) [1..] -- is sufficient
17:00:57 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
17:01:22 <etpace> > map (flip (,) 1) [1..] -- is ugly
17:01:23 <lambdabot>   [(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1),(11,1),(12,1)...
17:01:24 <hpc> but it's an inconsistency! :(
17:01:28 <chrisdone> ski: yeah
17:02:07 <chrisdone> hpc: dude, tell me something consistent about haskell's syntax
17:02:20 <dolio> hpc: There are no other operators like (,) for it to be inconsistent with. :)
17:02:48 <co_dh> dolio: (,) could consistent with (+)
17:02:50 <hpc> what about other infix constructors?
17:02:54 <co_dh> > map (+1) [1,2,3]
17:02:55 <lambdabot>   [2,3,4]
17:03:01 <Gracenotes> hpc: -XTupleSections
17:03:01 <co_dh> :t (,)
17:03:03 <lambdabot> forall a b. a -> b -> (a, b)
17:03:07 <co_dh> :t (+)
17:03:07 <hpc> the only thing it would break on is >3 tuples
17:03:07 <lambdabot> forall a. (Num a) => a -> a -> a
17:03:10 <Gracenotes> which, er, you mentioned
17:03:19 <dolio> co_dh: You aren't allowed to omit the parentheses with (,), though. , isn't the operator.
17:03:40 <hpc> it is though; you can pattern match on it
17:03:50 <co_dh> dolio: why , is not an operator ? 
17:03:52 <dolio> It's circumfix.
17:04:47 <dolio> Otherwise you could write things like '[ x, y | x <- l, y <- f x ]'.
17:05:11 <ski> int80_h : hm .. something like `loaders :: [exists x. (ProgramName x,[String] -> x)]', with a GADT approach
17:05:35 <ski> (in OCaml, `,' is infix)
17:05:55 <dolio> _,_ is an operator name in Agda, too.
17:06:24 <dolio> And you get what looks like larger tuples by specifying a fixity.
17:06:36 <dolio> x , y , z = x , (y , z), for instance.
17:06:52 <dolio> But then, Agda doesn't have sections, unfortunately.
17:07:00 <ski> in OCaml, the former is distinct from the latter, though
17:07:04 <hpc> why doesn't haskell do that, then?
17:07:29 <dolio> Oh, also, in haskell, (,,,) is a distinct operator.
17:07:43 <dolio> @type (,,,,)
17:07:43 <lambdabot> forall a b c d e. a -> b -> c -> d -> e -> (a, b, c, d, e)
17:07:52 <c_wraith> how much does the operator sections extension add?
17:08:01 <c_wraith> err, tuple sections
17:08:08 <c_wraith> can you only leave out the first or last item?
17:08:25 <dolio> You can write (,,1,,)
17:08:28 <c_wraith> nice
17:08:33 <hpc> :t (,,1,,)
17:08:34 <lambdabot> parse error on input `1'
17:08:41 <dolio> And (,2,3,4,)
17:08:43 <c_wraith> lambdabot doesn't support that feature :)
17:08:53 <hpc> @src (,,)
17:08:53 <lambdabot> Source not found. Just try something else.
17:09:19 <c_wraith> so (,,1,,) would have type Num c => a -> b -> d -> e -> (a, b, c, d, e)  ?
17:09:26 <dolio> Yes.
17:09:26 <hpc> :( tuples could be easily implemented in pure haskell
17:09:28 <dolio> And so on.
17:09:44 <c_wraith> I mean, that example is sufficient to get the idea across
17:10:07 <dolio> hpc: Haskell's tuples have the feature that each is a single block of memory with O(1) access, instead of O(k) for the kth item.
17:10:14 <dolio> But, that may be of dubious use.
17:10:19 <bos> I've made some major improvements to the Haskell Unicode text library: http://bit.ly/bP6clI
17:10:31 <int80_h> ski: the notation is new to me, it's not sinking in. This is why I want to know if the GADT way is right. If it is, I'll just chew on it until it sinks in.
17:10:31 <c_wraith> dolio, that's no different from any other data constructor with multiple arguments
17:10:54 <hpc> dolio: if your tuples require asymptotic performance gains, god help you
17:10:57 <ski> int80_h : i suppose it depends on what you want to do .. (and i don't really know that)
17:10:58 <c_wraith> and I think that's hpc's point.  tuples are just ordinary data types, but with special syntax
17:11:00 <dolio> c_wraith: No, but it'd be different than defining all tuples in existence using a haskell datatype.
17:11:19 <dolio> hpc: Heh.
17:11:33 <tehgeekmeister> with hdbc do you really have to prepare a select statement, execute it, and *then* fetch rows?
17:11:42 <tehgeekmeister> seems like it shouldn't take three steps to do this.
17:11:51 <c_wraith> tehgeekmeister, look at quickQuery and quickQuery'
17:12:06 <c_wraith> You almost always want quickQuery'
17:12:24 <notabel> tehgeekmeister: that reflects the actual interaction with most database servers.  whether you need the detail is up to you
17:13:02 <tehgeekmeister> okay, second question, is there a function like maybe that treats [] like nothing, otherwise maps?
17:13:06 <tehgeekmeister> (i'll write it if not)
17:13:13 <tehgeekmeister> oh, wait, map would do that!
17:13:15 <tehgeekmeister> durr
17:13:28 <dolio> ski: Are products left nesting in OCaml? Or are there primitive tuples of different sizes?
17:13:52 <copumpkin> bos: looks great
17:14:12 <bos> copumpkin: thanks!
17:15:40 <ski> dolio : the latter
17:19:56 <int80_h> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29580#a29614
17:20:28 <int80_h> ski: What I want to do is be able to call one of three functions depending on what symlink is used on the command line.
17:21:04 <int80_h> ski: right now, notabel has given me an impossible list, heterogeneous.
17:21:20 <int80_h> ski: I like the approach otherwise and would like to keep it.
17:21:38 <ski> it is not clear what `dealWithTable' is supposed to do
17:21:39 <int80_h> ski: but the problem of the heterogenous list has to be solved.
17:22:00 <ski> depending on which `loader' is used, `tbl' will have different types
17:22:55 <ski> if we ignore that for the moment, and assume that the basic structure is correct
17:23:02 <ski> then i would try to use a GADT
17:23:03 <int80_h> ski: oh dealWithTable is typed wrong, agreed. But I figured solving this first problem would clarify the solution to what the type of dealWithTable should be
17:23:20 <ski> possibly
17:23:45 <int80_h> ski: see I thought along the lines of this at first
17:23:51 <ski> but maybe it is better to handle each case separatedly .. or using some type class & existentials, as you mentioned earlier
17:23:57 <ski> (i don't know)
17:25:03 <ski> so, what i'm pondering at the moment is how to write `lookup :: Map1 k v -> (k i -> v i)', and how to express there that we have equality on `k's
17:25:05 <int80_h> ski: well for now I can handle each case seperatley. At that point, if using a typeclass makes sense, it should be clear what that would look like.
17:25:59 <ski> (that's assuming `Map1 k v' is `[exists i. (k i,v i)]' .. which seems like a sensible general thing .. except that in practice one wants not a list there, of course))
17:26:38 <ski> int80_h : maybe (i don't see before me what the methods of the class should be)
17:27:34 <ski> int80_h : btw, note that just because one uses existentials, one doesn't *have* to use a type class as well .. in many cases, one could just as well just use a record (and in at least some cases, this is better than using type classes)
17:28:17 <ski> (int80_h : btw, this `Map1 k v' idea occurred to me because someone else wanted something like this, the other week)
17:28:58 <ski> (.. and i think it's not an unreasonable thing to want, in some circumstances, while doing typeful programming)
17:32:18 <pyfgc> pointfree gives h x = x ++ x as equivalent to h = join (++) . how does this make sense?
17:32:31 <ski> @src join
17:32:31 <lambdabot> join x =  x >>= id
17:32:38 <ski> @src (->) (>>=)
17:32:38 <lambdabot> f >>= k = \ r -> k (f r) r
17:32:42 <ski> so
17:32:51 <ski>      join f
17:32:57 <pyfgc> i thought join had to do with monads?
17:32:59 <ski>   =  f >>= id
17:33:13 <pyfgc> ok thanks
17:33:14 <ski>   =  \r -> id (f r) r
17:33:18 <ski>   =  \r -> f r r
17:33:18 <Cale> pyfgc: Functions from any fixed type form a monad
17:33:39 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
17:33:40 <lambdabot>   ("hello","olleh","HELLO")
17:34:00 <ski> pyfgc : so, `join f r = f r r' uses the `(r ->)' monad
17:34:26 <Cale> Running an computation in that monad (which is just a function) means applying that function to the parameter to which the whole computation has been applied.
17:34:37 <aavogt> pyfgc: are you familiar with the Reader monad?
17:34:50 <pyfgc> no, not really
17:35:03 <pyfgc> used for immutable state?
17:35:04 <Cale> Well, the Reader monad is the same thing, only with more wrapping
17:35:14 <Cale> Sort of, yes
17:35:29 <ski> s/immutable state/environment/ :)
17:35:39 <pyfgc> i'll look into it. thanks :)
17:39:01 <ski>   class FooEq1 f
17:39:05 <ski>     where
17:39:05 <ski>     fooEq1 :: f i0 -> f i1 -> Maybe (Equal i0 i1)
17:39:26 <FunctorSalad> cute, I've never seen the anonymous reader in do notation
17:39:36 <ski> suggestions for better naming of ^ ?
17:40:16 <ski> (the idea being that it could e.g. be used for equality on GADTs)
17:40:46 <ski> it's sortof like John-Major-Equality, but not quite
17:41:12 <FunctorSalad> why the f? isn't that just like plain type-level equality?
17:41:20 <ski> consider
17:41:21 <FunctorSalad> since any type cons are injective
17:41:32 <ski>   data Foo :: * -> *
17:41:34 <ski>     where
17:41:46 <ski>     Lit :: Foo Integer
17:41:56 <ski>     Pair :: Foo a -> Foo b -> Foo (a,b)
17:42:06 <ski>     Fst :: Foo (a,b) -> Foo a
17:42:18 <ski>     ...
17:42:28 <FunctorSalad> or aren't you doing a purely typelevel comparison?
17:42:38 <ski> now, if i have `Foo i0' and `Foo i1', i want to compare the structure of the data
17:42:47 <ski> and get `Nothing', if there's a mismatch
17:42:56 <ski> otherwise i want to know that `i0' is equal to `i1'
17:43:10 <ski> purely data-constructor comparision
17:43:47 <ski> int80_h's example would be
17:43:53 <ski>   data ProgramName :: * -> *
17:43:54 <ski>     where
17:44:10 <ski>     PNStudents :: ProgramName Students
17:44:15 <FunctorSalad> ah, the point of f is that it may fail to have all Hask as domain
17:44:27 <FunctorSalad> not that it may fail to be injective (which it can't)
17:44:31 <ski>     PNCosts    :: ProgramName ActivityCosts
17:44:49 <FunctorSalad> (I was just wondering why you aren't using 'a -> b -> Maybe (Equal a b)')
17:44:53 <ski>     PNActivities :: ProgramName StudentActivities
17:45:21 <ski> so, here we have basically an enumeration, but with each enumeratee associated with a type
17:45:39 <ski> FunctorSalad : well, that would be John-Major-equality :)
17:45:53 <copumpkin> anyone know of any comparative studies on Vector Word8 vs. ByteString performance?
17:45:58 <ski> FunctorSalad : i only want to have equality on a specific GADT, here
17:46:21 <FunctorSalad> yes, so you're using 'f' to define a set of types...
17:46:43 <ski> i.e. instead of comparing `f i' to `f i', i want to compare `exists i. f i' to `exists i. f i' .. and if they're equal, then get a proof that the two `i's are the same
17:46:58 <ski> `f' is an indexed type
17:47:02 <ski> (family)
17:47:42 <int80_h> ski: hey thanks for your feedback.
17:49:06 <FunctorSalad> ski: (this is besides the point, but you count gadt's as 'indexed types'?)
17:49:39 <int80_h> ski: if I am doing the same operations on different ypes, would that not suggest a typeclass is needed?
17:49:58 <ski> FunctorSalad : well, that was maybe not that precise. the point i wanted to express was that the definition of `f a' is not parametric in `a'
17:50:13 <ski> int80_h : maybe
17:50:59 <ski> can you suggest what methods the type class should have ?
17:51:18 <ski> what are the "same operations" you're doing on different types ?
17:51:52 <int80_h> ski: In each case I will be parsing a file in preparation of putting it in a database table.
17:52:17 <FunctorSalad> ski: yes, that was my initial point :) that for a plain type constructor you might as well compare i0 and i1 directly
17:52:37 <FunctorSalad> but for GADTs or data families your class does add something indeed
17:53:28 <FunctorSalad> class TypeSetWithEquality? ;)
17:53:38 <FunctorSalad> (except that's too long)
17:53:44 <ski> i don't see how it's a "type set"
17:54:42 <FunctorSalad> unary gadts or data families are sets as far as type-level programming is concerned, aren't they? Set(f) := { a | f a is nonvoid }
17:55:15 <ski> .. i don't follow
17:55:17 <FunctorSalad> (though you don't get all sets that way I think)
17:55:57 <FunctorSalad> (... for cardinality reasons alone ;))
17:56:18 * ski tentatively goes with `Eq1' ..
17:56:47 <FunctorSalad> I'm just trying to argue that gadts/data families and "constructive" (in some sense) sets are more or less the same thing on the type level ;)
17:58:00 <ski> sets of what ?
17:58:05 <FunctorSalad> (they don't contain any information except for the 'Set' I defined, and their name, do they?)
17:58:08 <FunctorSalad> of kind * types
17:58:29 <FunctorSalad> (or some other kind, if the GADT/data family is of higher order kind)
17:58:52 <ski> `exists i. Foo i' above contains more info than what `i' is
17:59:05 <copumpkin> ski: what are you trying to do?
17:59:45 <ski> copumpkin : given an association-list of type `[exists i. (k i,v i)]', write a lookup function on it
17:59:52 <copumpkin> :O
18:00:00 <ski> (copumpkin : and it's actually int80_h's problem, originally)
18:00:03 <copumpkin> ah
18:00:26 <int80_h> ski: yeah but you are all talking above my head, I have no idea what you are saying.
18:00:41 <int80_h> ski: I'm still trying to figure out what the GADT for this problem would look like.
18:00:41 <ski> <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29580#a29614> looks like it could usefully use a GADT like `ProgramName' above for the keys in the assoc-list `loaders', instead of strings
18:00:53 <ski> int80_h : see `ProgramName' above :)
18:01:13 <FunctorSalad> ski: I'm talking purely about the typelevel; clearly on the value level a GADT contains more information than the set of types 'i' such that 'f i' is nonvoid
18:01:36 <int80_h> < ski>   data ProgramName :: * -> *
18:01:36 <int80_h> 17:43 < ski>     where
18:01:37 <int80_h> 17:43 < ski>     PNStudents :: ProgramName Students
18:01:47 <int80_h> you mean that?
18:01:55 <ski> int80_h : yeah ( but there's two more lines)
18:03:20 <int80_h> data ProgramName :: * -> *
18:03:30 <int80_h> that throws me off, I don't understand what that is saying at all.
18:03:43 <FunctorSalad> it's a kind signature
18:04:00 <FunctorSalad> "kinds" are the types of types
18:04:28 <int80_h> could you tell me what that notation is doing?
18:04:37 <FunctorSalad> (by 'void' I mean 'contains only bottom' if that usage isn't standard, btw)
18:04:59 <int80_h> I mean, the whole thing not just the first line. I will hpaste it for convinience.
18:05:16 <ski> int80_h : `ProgramName :: * -> *' gives the "type" of the type `ProgramName', just like `not :: Bool -> Bool' gives the type of the value `not'
18:05:16 <FunctorSalad> int80_h: it specifies that ProgramName is a GADT which takes a single type of kind * as a parameter
18:06:09 <ski> int80_h : you could replace `ProgramName :: * -> *' there with `ProgramName table' (where `table' can be any variable name you like) .. i happen to usually prefer the former notation, though
18:06:12 <etpace> is printf and reading really the best way to round to a certain number of decimal places?
18:06:44 <megajosh2> It is?
18:06:53 <etpace> know of another?
18:07:24 <megajosh2> I'd imagine truncating algorithms would use some bitwise operations or something
18:08:34 <etpace> seems a bit involved when I just want to histogram time
18:08:49 <ski> int80_h : consider
18:08:57 <megajosh2> Wouldn't there be some function in the standard library for that?
18:08:58 <FunctorSalad> ski: your Foo type would correspond to the inductive type set defined by closing {Integer} under (,), I mean
18:09:00 <int80_h> ski: yes yes
18:09:05 <ski>   data Maybe a = Nothing
18:09:05 <ski>                | Just a
18:09:17 <megajosh2> Yeah, truncate is a member of the Num typeclass
18:09:20 <megajosh2> :t truncate
18:09:21 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:09:21 <FunctorSalad> ski: as far as I can see, there's nothing to Foo on the type level except this set and the name 'Foo'
18:09:33 <ski> here the types of the two constructors are as follows (where `forall a. ' could be elided)
18:09:34 <megajosh2> ...oh wait a minute
18:09:41 <etpace> ... thats not what im looking for
18:09:44 <ski>   Nothing :: forall a.      Maybe a
18:09:49 <megajosh2> I think that completely removes everything under 1
18:09:53 <ski>   Just    :: forall a. a -> Maybe a
18:09:57 <megajosh2> :t round
18:09:58 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:09:59 <etpace> i need to round to n decimal places
18:10:00 <ski> int80_h : ok, so far ?
18:10:00 <megajosh2> Also part of the Num typeclass
18:10:05 <megajosh2> ...wtf?
18:10:10 <etpace> yes but thats not what im looking for
18:10:13 <megajosh2> Huh
18:10:20 <int80_h> ski: no I don't understand the definition of Nothing
18:10:40 <ski> @src Maybe
18:10:40 <lambdabot> data Maybe a = Nothing | Just a
18:10:45 <int80_h> ski: Nothing :: forall a.      Maybe a, I've never seen a function defininition without a ->
18:10:46 <ski> that's the definition of `Nothing'
18:11:15 <ski> int80_h : `Nothing' is not a function, *and* those two lines were not definitions. only descriptions of what types the constructors had
18:11:15 <megajosh2> Maybe it's in Numeric
18:11:41 <etpace> @hoogle (Fractional a) => a -> Int -> a
18:11:42 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
18:11:42 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
18:11:42 <lambdabot> Data.Bits complementBit :: Bits a => a -> Int -> a
18:11:43 <megajosh2> :t Numeric.floatToDigits
18:11:44 <lambdabot> forall a. (RealFloat a) => Integer -> a -> ([Int], Int)
18:11:47 <ski> > Nothing + 0  -- is `Maybe' in `Num' ?
18:11:50 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
18:11:52 <lambdabot>    arising from a use of...
18:12:47 <megajosh2> Aha!
18:12:52 <megajosh2> :t Numeric.roundTo
18:12:52 <lambdabot> Not in scope: `Numeric.roundTo'
18:12:55 <megajosh2> Eh?
18:12:56 <int80_h> ski: okay I htink I follow now
18:13:03 <megajosh2> I could have sworn that was in there
18:13:14 <megajosh2> @hoogle Int -> Int -> [Int] -> (Int, [Int])
18:13:14 <lambdabot> No results found
18:13:18 <achelous> try in Data.Decimal
18:13:21 <etpace> @hoogle roundTo
18:13:21 <lambdabot> No results found
18:13:58 <megajosh2> Aha
18:14:03 <megajosh2> :t Data.Decimal.roundTo
18:14:04 <lambdabot> Couldn't find qualified module.
18:14:06 <megajosh2> No?
18:14:14 <etpace> it's not in standard libs 
18:14:19 <achelous> right
18:14:35 <achelous> you might consider using it anyway
18:14:35 <megajosh2> I wonder why you can't get a rounding function in the standard library... hmm
18:15:03 <megajosh2> @hoogle Integral i => Word8 -> DecimalRaw i -> DecimalRaw Integer
18:15:04 <lambdabot> Warning: Unknown type DecimalRaw
18:15:04 <lambdabot> Network.BufferType buf_snoc :: BufferOp a -> a -> Word8 -> a
18:15:04 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
18:15:13 <megajosh2> :C
18:15:35 <megajosh2> And hoogle doesn't know of a roundTo?
18:15:51 <etpace> its not in standard libs 
18:16:01 <etpace> > printf "%0.3f" 0.12345
18:16:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:16:02 <lambdabot>    `Text.Printf.PrintfType ...
18:16:26 <etpace> > (read $ printf "%0.3f" 0.12345) :: Double
18:16:26 <lambdabot>   0.123
18:16:27 <megajosh2> Aha!
18:16:30 <megajosh2> From the haskell-cafe
18:16:35 <megajosh2> http://www.haskell.org/pipermail/haskell-cafe/2006-February/014445.html
18:16:41 <megajosh2> I guess you have to implement it yourself
18:16:42 <megajosh2> :/
18:19:27 <ski> int80_h : ok
18:19:29 <achelous> megajosh: still looks much better than the printf solution
18:19:29 <int80_h> oh nos! ski is gone
18:19:34 <int80_h> there he is
18:19:42 <ski> so, what i wanted to say was that `Maybe' could have been defined like
18:19:56 <ben_m> Trying to write a function that takes a list and returns the number of times every element is in that list
18:19:59 <ski>   data Maybe :: * -> *  -- or `data Maybe a', if you prefer
18:20:02 <ski>     where
18:20:07 <ben_m> :: [a] -> [(a, Int)] basically
18:20:08 <ski>     Nothing :: forall a.      Maybe a
18:20:11 <ski>     Just    :: forall a. a -> Maybe a
18:20:22 <ski> int80_h : that's a GADT-style definition of `Maybe'
18:20:55 <ski> int80_h : instead of using the BNF-like syntax for enumerating the constructors, plus the types of their arguments, you simple write down the types you want the constructors to have
18:21:33 <ski> int80_h : now, note that both constructors still have the same type `Maybe a' .. that's the only thing we can do with a non-GADT-style definition
18:22:02 <int80_h> ski okay
18:22:06 <ski> int80_h : what GADT-style buys us, apart from writing in this other style, is that we could have different return types of the constructors
18:22:16 <ski> so, e.g. the `ProgramName' above
18:22:22 <ski>   data ProgramName :: * -> *
18:22:23 <ski>     where
18:22:24 <djahandarie> ben_m, sort and recurse using span
18:22:25 <ski>     PNStudents :: ProgramName Students
18:22:27 <ski>     PNCosts    :: ProgramName ActivityCosts
18:22:29 <ski>     PNActivities :: ProgramName StudentActivities
18:22:46 <ski> if you write a function
18:22:58 <ski>   foo :: ProgramName a -> ... -> a
18:23:01 <ski> then if you define
18:23:06 <ben_m> djahandarie: Ah, good idea, thanks.
18:23:08 <ski>   foo PNStudents ... = ...
18:23:15 <ski>   foo PNCosts ... = ...
18:23:21 <djahandarie> ben_m, just like groupBy but carrying along counts
18:23:21 <ski>   foo PNActivities ... = ...
18:23:37 <ski> int80_h : note that the function is declared to return something of type `a'
18:23:45 <int80_h> which could be anything
18:23:51 <ski> yes
18:24:23 <ski> int80_h : but, in the first case, the argument (of type `ProgramName a') matches with `PNStudents' (of type `ProgramName Students')
18:24:40 <ski> now, if that match succeeds, we know that in that equation, the type `a' must be `Students' !
18:25:00 <ski> which means that the function doesn't have to return something of type `a' (which it doesn't know what it is)
18:25:06 <ski> it can just return some `Student'
18:25:33 <ski> int80_h : and you can't do this sort of thing with ordinary data types
18:26:03 <int80_h> ski: which is why I need to include the GADT language extension
18:26:11 <ski> int80_h : so, the idea is to let your `loader' be a list of type `[exists x. (ProgramName x,[String] -> x)]'
18:26:14 <int80_h> or something, I can't remember.
18:26:15 <ski> yes
18:26:30 <ski>   {-# LANGUAGE GADTs #-}
18:26:57 <ski> int80_h : so, each pair in the list will contain one of the constructors of the `ProgramName' type, together with the corresponding loader function
18:27:09 <FunctorSalad> am I going crazy? why has this GADT bitrotten? 
18:27:09 <FunctorSalad> data Ex p where
18:27:09 <FunctorSalad>     Ex :: forall b. p b -> Ex p
18:27:22 <FunctorSalad> complains about 'p' not being in scope
18:27:33 <dolio> It isn't.
18:27:41 <dolio> Ex :: forall p b. p b -> Ex p
18:28:05 <ski> int80_h : and the type argument `x' of `ProgramName x' is meant to specify the return type of each loader (which is where the types of the loaders differed)
18:28:14 <FunctorSalad> dolio: hmm makes sense, but apparently enforcing it is new :)
18:28:41 <ski> int80_h : so, for each pair in the list, there is some (hidden/forgotten) type `x', that is the same in `ProgramName x' and `[String] -> x'
18:28:47 <dolio> Huh.
18:29:08 <etpace> what's the best way to create a histogram with nominaldifftime values? so each 'bin' would be 10ms wide or so
18:29:35 <FunctorSalad> dolio: I mean this is from some old code which I'm pretty sure used to compile ;)
18:29:48 <ski> int80_h : so, what is missing now is a way for the program to compare two tags of type `ProgramName x0' and `ProgramName x1', checking them for equality, and if they're equal, make sure that the caller of the equality check gets to know `x0' and `x1' must be equal
18:30:09 <FunctorSalad> (but not totally sure. maybe this is some half-finished refactoring)
18:30:19 <int80_h> ski: why do I need to check them for equality?
18:30:26 <ski> int80_h : to implement `lookup
18:30:28 <ski> '
18:30:30 <ski> @type lookup
18:30:31 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
18:30:41 <int80_h> I can just derive eq right?
18:30:42 <dolio> Well, GHC's GADTs don't have the kind of parameter-index distinction as in Agda and Coq.
18:30:47 <ski> that works on a list of type `[(k,v)]', where we have equality on `k'
18:31:13 <ski> int80_h : but in our case, we want to work on a list of type `[exists i. (k i,v i)]', where the `k' has a kind of equality
18:31:14 <dolio> So the names you use in between 'data' and 'where' don't mean anything, and aren't in scope below.
18:31:20 <FunctorSalad> dolio: yeah, I agree it shouldn't really work
18:31:26 <FunctorSalad> just saying that apparently it did at some point
18:31:29 <dolio> If it used to work, maybe it was implicitly adding the quantification.
18:31:38 <dolio> Or something.
18:31:40 <ski> int80_h : so, we need a new `lookup' (and a new `Eq' class) for this .. since apparently noone has thought of this before
18:31:54 <int80_h> ski: can you unpack this notation using english [exists i. (k i,v i)]
18:32:50 <ski> int80_h : list of pairs such that for each pair there is some type `i' (not necessarily the same `i' for every pair in the list), such that the first part of the pair has type `k i' and the second part of the pair has type `v i'
18:33:00 <ski> int80_h : in your case `k' is `ProgramName'
18:34:03 <ski> int80_h : btw, you should note that (currently) `[exists i. (k i,v i)]' is pseudo-code .. to actually do this in haskell (with extensions), we need to make a new datatype for the pairs
18:34:42 <int80_h> oh that's too bad. I suppose I need to think about how to do that
18:34:58 <int80_h> ski: one step at a time though. What is the next step?
18:35:00 <ski> (it's not hard to do, just a bit tedious)
18:35:14 <int80_h> ski: better yet, could you outline the steps I need to take to so this, and post those on hpaste?
18:35:23 <ski> instead of `[exists i. (k i,v i)]' you say something like `[Assoc1 k v]', where
18:35:35 <ski>   data Assoc1 k v = forall i. MkAssoc1 (k i) (v i)
18:35:57 <ski> (adding `ExistentialQuantification' to the `LANGUAGE' extension list)
18:36:03 <ski> int80_h : also, i need to leave in two-three minutes ..
18:36:21 <int80_h> ski: no worries. I would hope to continue this tomorrow.
18:36:54 <int80_h> ski: if you could give me the first next thing to do though, I can go do that
18:36:59 <int80_h> or puzzle over it.
18:38:05 <etpace> how can I pritnf a Rational? (pref as a decimal approx or something)
18:38:38 <dolio> FunctorSalad: Come to think of it, I think with scoped type variables, you used to be able to write 'forall a. a -> b', and only 'a' would be scoped. But I think that now complains that 'b' is not in scope.
18:39:12 <FunctorSalad> dolio: yes, this seems to be it. I just removed the foralls altogether...
18:39:33 <dolio> So they must have changed the checker at some point.
18:42:39 <FunctorSalad> omg new haddock css :O
18:43:08 <danderson> really? Where?
18:43:34 <FunctorSalad> the times are changing...
18:43:47 <FunctorSalad> danderson: haddock HEAD
18:44:32 <mtnviewmark> FunctorSalad and danderson:  look here if you want to preview it  http://www.ozonehouse.com/mark/snap-xhtml/
18:45:03 <FunctorSalad> mtnviewmark: I actually notices from my local docs looking different =)
18:45:15 <FunctorSalad> d
18:45:26 <danderson> oooooo, shiny!
18:45:27 <mtnviewmark> oh! you use haddock built from HEAD?!?!  awesome
18:45:37 <mtnviewmark> (and brave)
18:46:14 <mtnviewmark> do try the "Frames" button
18:47:06 <mtnviewmark> (oh - and thanks - it's been my personal Haskell project for the last few months - and it is lovely to hear comments like "shiny!" !!!)
18:47:12 <FunctorSalad> mtnviewmark: are you a haddock dev? my original intention was fixing the hoogle output for infix type operators...
18:47:18 <FunctorSalad> =)
18:47:50 <mtnviewmark> yes, I guess I am a haddock dev -- though I have focused entirely on the web backend
18:47:51 <FunctorSalad> (apparently haddock just calls ghc there)
18:48:33 <dankna> the new style is a step in the right direction.  why not add the contents as a foldout position: fixed thing right above the synopsis one?
18:50:43 <mtnviewmark> one step at a time, dankna! 
18:50:52 <dankna> that's fair.  it's very nice already :)
18:51:08 <mtnviewmark> the biggest change is behind the scenes -- the generated markup is now all mostly clean, semantic Xhtml
18:51:13 <dankna> oh, very nice
18:51:19 <mtnviewmark> the pull out is actually done entirely in the CSS
18:51:23 <dankna> right
18:51:24 <mtnviewmark> and now you can have themes
18:51:27 <dankna> cool
18:51:34 <mtnviewmark> so you could make a theme that did that for the contents really easily
18:51:45 <dankna> gotcha
18:52:37 <djahandarie> JaffaCake, great work on the GC improvements :)
18:57:30 <copumpkin> opinions? Data.SparseVector or Data.Vector.Sparse ?
18:57:34 <FunctorSalad> reading through my code, apparently I tried to express type-level natural number structures, with the natural numbers being an initial natural number structure
18:57:36 <FunctorSalad> sane, isn't it
18:58:28 <copumpkin> I'm thinking of going with the latter
18:58:57 <roconnor> Sparse.Data.Vector
18:58:59 <roconnor> er
18:59:04 <roconnor> Sparse.Vector.Data
18:59:07 <copumpkin> lol
18:59:08 <djahandarie> Vector.Data.Sparse
18:59:12 <djahandarie> Vector.Sparse.Data
18:59:14 * copumpkin screams
18:59:49 <dolio> Org.Haskell.WWW
19:00:00 <copumpkin> lol
19:00:03 * copumpkin gives up
19:00:08 <FunctorSalad> copumpkin: Data.Sparse? o_O
19:00:21 <copumpkin> no, I didn't forget a period
19:01:02 <FunctorSalad> MadeOf..Components
19:01:10 * copumpkin cries
19:01:31 <FunctorSalad> (faceted classification :))
19:01:52 <copumpkin> so Data.Vector.Sparse? with a type T in it? ;)
19:01:57 <copumpkin> I mean, SparseVector ;)
19:03:14 <FunctorSalad> copumpkin: hmm maybe try to avoid the somewhat arbitrary choice of permutation altogether somehow?
19:03:28 <copumpkin> how?
19:03:41 <FunctorSalad> I kind of like your "SparseVector" proposal since "VectorSparse" doesn't make grammatical sense
19:03:51 <FunctorSalad> (so you won't mix them up)
19:04:01 <copumpkin> well yeah
19:04:03 <copumpkin> I mean the module
19:04:08 <copumpkin> the type would be SparseVector
19:04:13 <FunctorSalad> me too
19:04:18 <copumpkin> oh okay
19:04:19 <FunctorSalad> (Data.SparseVector as you said)
19:04:27 <copumpkin> well that means less work for me since it's already there
19:04:50 <FunctorSalad> it's less atomic but it's not like we use the hierarchical structure for anything useful, do we...
19:05:02 <copumpkin> yeah
19:06:10 <roconnor> I still inclined to think the whole Data / Control heirarchy is stupid.
19:06:12 <FunctorSalad> btw theres the Numeric. hierarchy too
19:06:34 <FunctorSalad> roconnor: hehe it's s bit generic
19:06:41 <FunctorSalad> or some other reason?
19:07:15 <copumpkin> roconnor: I agree
19:07:16 <roconnor> ya, it provides me with no information
19:07:18 <copumpkin> but I wanna fit in
19:07:42 <roconnor> Next major interface change I'm moving My Data.Colour library to Colour
19:08:13 <roconnor> some people think that it is useful to split up the heirarchy to make it easier to navigate
19:08:20 <roconnor> I'm not really convinced
19:08:21 <FunctorSalad> (btw, my point wasn't to avoid VectorSparse because it doesn't make sense, but that there is a canonical depth-2 module name, but no canonical depth-3 one (since both Data.Vector.Sparse and Data.Sparse.Vector make sense))
19:08:49 <roconnor> FunctorSalad: wait are you trying to invent a new module name?
19:08:58 <FunctorSalad> roconnor: copumpkin 
19:09:36 * copumpkin hates naming 
19:09:54 <roconnor> copumpkin: : wait are you trying to invent a new module name?
19:09:57 <copumpkin> yes
19:10:03 <copumpkin> for sparse vectors :P
19:10:06 <roconnor> copumpkin: just call it SparseVector
19:10:15 <roconnor> do everyone a favour
19:10:24 <roconnor> or SparseVectour  :P
19:10:28 <copumpkin> lol
19:10:29 <FunctorSalad> lol
19:12:30 <copumpkin> hmm, I'm not convinced about dropping the prefix
19:12:43 <copumpkin> feels dirty, although I'm also not satisfied with the Data. situation
19:12:57 <copumpkin> unlike many things, I feel like this actually belongs in Data. though
19:13:27 <roconnor> :)
19:13:45 <copumpkin> it's a fingertree + vector, basically
19:15:42 <pyfgc> how can i import a module, excluding 1 function?
19:15:56 <tommd> import Blah hiding (foo)
19:15:57 <copumpkin> import X hiding (f)
19:16:01 <dankna> import Some.Module hiding (someSymbol)
19:16:07 <pyfgc> thanks!
19:16:52 <tommd> pyfgc: It can get ugly fast.  The way I see most code handing collisions is either selectively importing or qualified import.
19:17:12 <jaredj> hello all, i want to transpose two elements in a list, e.g. [1,2,3,4,5] -> [2,1,3,4,5]
19:17:27 <roconnor> import Data.Some.Module hiding (dataSomeSymbol)
19:17:31 <tommd> import Blah (symbol1, symbol2, ...)
19:17:31 <tommd> import qualified Other.Module as OM
19:17:31 <tommd> value = OM.func symbol2
19:17:40 <jaredj> the tricky part is i want to wrap around sometimes
19:17:44 <copumpkin> roconnor: social statement? :P
19:17:52 <roconnor> actally sometimes I do
19:17:59 <roconnor> import Data.Colour hiding (tan)
19:18:11 <copumpkin> RACIST!
19:18:17 <jaredj> like switch 0 [1,2,3,4,5] == [2,1,3,4,5], but switch 4 [1,2,3,4,5] == [5,2,3,4,1]
19:19:10 <roconnor> jaredj: it is an unusual operation to preform on lists
19:19:30 <jaredj> for 0 through 3, it's easy and recursive
19:19:33 <jaredj> for 4...
19:19:54 <Martty> id use splitAt, manipulate and piece together again
19:20:23 <roconnor> jaredj: I'd rethink your data structure
19:20:33 <roconnor> jaredj: probably use an array
19:20:41 <roconnor> or otherwise rethink your problem
19:20:51 <jaredj> what, where are the arrays
19:21:00 <roconnor> Data.Array
19:21:11 <copumpkin> many different places, depending on what you need
19:21:25 <jaredj> ah - not in base package ic
19:21:32 <copumpkin> what kind of operations might people want on sparse vectors?
19:21:35 <roconnor> you can start with Data.Array, and when that is too slow, move up the sophistication ladder
19:21:48 <jaredj> ok cool
19:21:52 <roconnor> copumpkin: convolution
19:22:01 <copumpkin> roconnor: what would it do around the edges?
19:22:07 <copumpkin> treat them as zeros?
19:22:14 <roconnor> I guess
19:22:33 <roconnor> I suppose you could also wrap them
19:22:38 <copumpkin> any more general-purpose ones? :P
19:22:41 <roconnor> though I've never done that
19:22:53 <co_dh> I don't understand unsafePerformIO even after reading the document , any help?
19:22:55 <wli> Sparse matrix/vector multiply.
19:22:59 <jaredj> dot product
19:23:03 <roconnor> copumpkin: map
19:23:10 <copumpkin> roconnor: got that
19:23:27 <copumpkin> I didn't intend this for actual mathematical vectors, but I guess it would work for those too
19:23:30 <wli> (probably needing sparse matrices for that)
19:23:35 <jaredj> ohh
19:23:36 <copumpkin> this is actually for a reverse engineering tool
19:23:42 <roconnor> co_dh: unsafePerformIO is only for using the Foreign Function Interface
19:23:46 <copumpkin> but I'm going to put it up on hackage in case anyone else wants it
19:23:57 <jaredj> interessant
19:23:58 <roconnor> or rather making a Foreign Function Interface
19:24:18 <roconnor> copumpkin: concat
19:24:28 <co_dh> roconnor: I'm reading some code, and it's using unsafePerformIO, (haskell code) , and I don't know why
19:24:43 <copumpkin> roconnor: okay, makes sense
19:24:48 <co_dh> oh, I see, it's getting the result. 
19:24:55 <copumpkin> I guess the model I'm after is SparseVector a = Vector (Maybe a)
19:25:00 <roconnor> co_dh: possibly because it is badly written
19:25:30 <copumpkin> omg saurik 
19:25:31 <co_dh> roconnor: it's in unit test code, so it doesn't matter , I guess.
19:28:03 <saurik> copumpkin: when I got disconnected randomly on july 17th my client did not rejoin this channel; today is inventory day
19:28:09 <copumpkin> :)
19:30:11 <Axman6> @pl (\a b -> compare (arr ! a) (arr ! b))
19:30:12 <lambdabot> (. (arr !)) . compare . (arr !)
19:30:16 <Axman6> hmm, no thanks
19:30:59 <copumpkin> :t (\a b -> compare (arr ! a) (arr ! b))
19:31:00 <lambdabot>     Couldn't match expected type `Array i e'
19:31:00 <lambdabot>            against inferred type `(b -> c) -> a b c'
19:31:00 <lambdabot>     In the first argument of `(!)', namely `arr'
19:31:15 <copumpkin> Axman6: compare `on` (arr !) ?
19:31:19 <copumpkin> or comparing (arr !)
19:31:25 <co_dh> :t (arr !)
19:31:26 <lambdabot>     Couldn't match expected type `Array i e'
19:31:26 <lambdabot>            against inferred type `(b -> c) -> a b c'
19:31:26 <lambdabot>     In the first argument of `(!)', namely `arr'
19:31:45 <co_dh> :t (!)
19:31:46 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
19:33:00 <dmwit> (from the TYPES mailing list) Assuming 1 is a final object in category C, is there anything interesting we can say about X + 1, the coproduct of some object X and 1?
19:34:40 <dolio> dmwit: You think that was a homework question? I was thinking of answering, but I wasn't sure.
19:34:59 <dmwit> oh
19:35:05 <dmwit> I hadn't considered that. =/
19:35:34 <dolio> Anyhow, I don't know of anything special about X + 1 for arbitrary X.
19:36:00 <roconnor> dolio: it's a monoid!
19:36:03 <roconnor> it multiple ways
19:36:05 <dmwit> I tried expanding the definitions, but didn't see anything special pop out either.
19:36:09 <roconnor> and as such
19:36:11 <dolio> X ~= X + 1 would be the definition of a natural numbers object, though.
19:36:45 <roconnor> const of it is applicative
19:37:41 <dmwit> X + 1 is a monoid?
19:38:06 * hackagebot type-settheory 0.1.3 - Sets and functions-as-relations in the type system  http://hackage.haskell.org/package/type-settheory-0.1.3 (DanielSchuessler)
19:38:13 <roconnor> dmwit: in two different ways
19:38:21 <roconnor> two monoids for the price of one
19:38:37 <djahandarie> roconnor, I thought things were usually free around here?!
19:38:55 <dmwit> Bah, the free ones are boring. No interesting equations.
19:39:07 <dmwit> Now, a twofer... THAT intrigues me.
19:39:48 <dolio> Right () is the unit, and you can take Left x * Left y = Left x or Left y.
19:40:16 <lispy> wow, type-settheory looks cool
19:40:33 <FunctorSalad> lispy: just fixed the bitrot o_o
19:40:48 <FunctorSalad> still not sure if it's actually good for anything ;)
19:41:42 <dolio> roconnor: Anyhow, the original question was talking about isomorphisms like X * 1 ~= X and X + 0 ~= X, and then asked about X * 0 and X + 1.
19:41:46 <lispy> FunctorSalad: when I was starting the type witnesses stuff I did on darcs, David and I had discussion about whether or not we should be using type level sets instead of what went with.  Our conclusion is that we weren't sure you could do type level sets in Haskell.  Seems you can :)
19:41:51 <FunctorSalad> (the obvious disadvantage to typeclasses is that you have to supply the proofs explicitly)
19:42:12 * dmwit is now regretting answering
19:42:12 <FunctorSalad> (though I have a typeclass 'Fact' for things that have a proof)
19:42:37 <ezyang> My observation is that Haskell’s type system has been monotonically increasing in power. 
19:42:39 <FunctorSalad> lispy: interesting
19:42:46 <dmwit> Though perhaps we can hope that a professor teaching such a class would know about the types list -- and perhaps even be on it.
19:42:57 <lispy> FunctorSalad: ah, type class based.  Yeah we would have avoided it for that reason (extra overhead)
19:43:29 <FunctorSalad> lispy: no, it is completely typeclass-free except for the convenience 'Fact' class
19:43:40 <FunctorSalad> (which collects proofs)
19:44:49 <lispy> FunctorSalad: ah your first release was long after I had finished up
19:45:00 * lispy was feeling bad for not noticing the library for inclusion in thesis write up
19:45:07 <dolio> dmwit: You answered?
19:45:30 <FunctorSalad> like... "Fact (Injective (KleisliHom m))" ;)
19:45:48 <dmwit> roconnor, dolio: I'm still not quite following this monoid business. I mean, intuitively, yes, but formally, no. What are the actual "elements" of the monoid? Arrows from an initial object to X + 1 or something?
19:46:18 <dmwit> dolio: Yes, though it seems it hasn't gone through yet.
19:46:46 <dolio> A monoid in a monoidal category is an object M together with unit : I -> M and mult : M (x) M -> M that satisfy some laws.
19:47:01 <dolio> I being the unit object in the monoidal category, and (x) being the tensor product.
19:47:14 <FunctorSalad> (KleisliHom m is the functional relation { ( (a,b)  ,  a -> m b  )    | a,b in Hask } apparently ;))
19:47:22 <dmwit> Okay, fine, so we're assuming some extra structure.
19:47:30 <dmwit> Then I can follow it just fine.
19:48:37 <dolio> But, any category with a terminal object and binary products has monoidal structure, with I = 1 and (x) = *, I believe.
19:49:30 <copumpkin> we need a way to declare "friend" modules
19:49:32 <dolio> Since 1 * A ~= A ~= A * 1, and A * (B * C) ~= (A * B) * C, and those probably satisfy the relevant coherence conditions.
19:49:32 <copumpkin> for testing
19:49:38 <copumpkin> to avoid putting a quickcheck dependency on packages
19:49:45 <lispy> FunctorSalad: I'm not familiar with your notation.  What is that functional relation saying?
19:49:59 <copumpkin> I guess I'll just test the exported interfaces
19:50:05 <ezyang> copumpkin: Yeah... 
19:50:08 <ezyang> "Add a flag?" 
19:50:14 <copumpkin> ?
19:50:20 <copumpkin> oh I guess I could do it with CPP
19:50:25 <copumpkin> but I'll just test the exported interface
19:50:28 <ezyang> copumpkin: You can specify a flag in Cabal, and CPP in the quickcheck code. 
19:50:33 <copumpkin> yeah
19:50:42 <ezyang> since it doesn’t change the outwards interface, that should be kosher. 
19:50:43 * dmwit wasn't assuming binary products
19:50:43 <kmc> do everything with CPP always
19:50:44 <copumpkin> makes more sense to test the exported interface
19:50:51 <ezyang> Fair enough. 
19:50:57 <copumpkin> I'll do the cabal flag though
19:51:02 <copumpkin> don't like having unnecessary dependencies
19:52:45 <copumpkin> anyone have a good template for a quickcheck test runner?
19:53:11 <FunctorSalad> lispy: in general I encode type-level functions as it is done in old-fashioned set theory there ;)
19:53:23 <FunctorSalad> (a function is a (functional) relation)
19:53:48 <roconnor> dmwit: I was thinking about the category of types specifically
19:53:56 <FunctorSalad> so what I wrote is just the relation way of saying that (KleisliHom m)(a,b) := a -> m b
19:56:55 <lispy> FunctorSalad: hmm...okay.  Some day I will learn this stuff properly (I have no idea what Kleisli Hom(m)) means
19:56:59 <dolio> Anyhow, (X + 1) * (X + 1) ~= X * X + X + X + 1. So you need mult: X^2 + 2*X + 1 -> X + 1.
19:57:51 <FunctorSalad> lispy: that's not specific to my library
19:57:59 <FunctorSalad> just a random type-level function I encoded there ;)
19:58:04 <dolio> There's probably only one option that works for the 2*X and 1 satisfying the monoid laws. But you have two choices for X^2, one for each projection.
19:58:48 <FunctorSalad> copumpkin: the good old quickCheck script? ;)
19:58:57 <copumpkin> test-framework looks nice
19:58:59 <copumpkin> using it now
19:59:09 <ezyang> It's pretty nice. 
19:59:16 <FunctorSalad> (ci quickcheck-script)
19:59:16 <dmwit> thanks
19:59:21 <dmwit> cool stuff
20:02:39 <lispy> FunctorSalad: ah.  That's good.  I just suck at learning CT from wikipedia (it's not the worst thing ever, just light on exercises and examples so I have to make stuff up)
20:03:22 <FunctorSalad> lispy: learning something the first time from wikipedia is hard indeed
20:03:44 <FunctorSalad> (but I thought Kleisli was pretty well-known from Control.Arrow)
20:03:53 <FunctorSalad> @type Kleisli
20:03:54 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
20:04:29 <FunctorSalad> just a different way of looking at a monad...
20:04:59 <lispy> ah yeah, the monad m is an arrow from a to b?
20:05:17 <FunctorSalad> the Kleisli category for m is the category for which (<=<) is the composition... and the 'return's are the identities
20:05:34 <FunctorSalad> the monad is fixed
20:05:45 <FunctorSalad> (m is a monad)
20:06:25 <roconnor> FunctorSalad: what struck me today is that monoid is not the monoid they are talking about when they say that a monad is a monoid in the category of endofunctors
20:06:48 <copumpkin> nope
20:06:52 <copumpkin> monoid object
20:07:07 <roconnor> I ended up confused today when trying to explain what a monad was :(
20:07:11 <copumpkin> aw
20:07:43 <FunctorSalad> roconnor: nope, the confusing thing is that the monoidal product for which this is a monoid is functor compo
20:07:50 <FunctorSalad> instead of \times as for normal monoids
20:07:52 <roconnor> The thing with Kleisli composition isn't really a monoid.  It is more like a monoidoid
20:08:04 <FunctorSalad> it's just a category :)
20:08:09 <FunctorSalad> aka monoidoid yes
20:08:15 <roconnor> ah
20:08:15 <djahandarie> Whoa what now I'm confused
20:08:21 <roconnor> FunctorSalad: I didn't notice that
20:08:25 <FunctorSalad> (not really 'aka', but it's logical ;))
20:08:26 <copumpkin> djahandarie: how come?
20:09:05 <djahandarie> Wait, maybe not
20:09:17 <djahandarie> A monoid in [C,C] is a monad on C right?
20:09:18 <FunctorSalad> (surely the category of groups is some sort of 2-pushout of the inclusion "Cat -> Groupoid" and "Cat -> Monoid"? ;))
20:09:44 <FunctorSalad> to explain why 'monoidoid' is logical ;)
20:10:12 <FunctorSalad> hmm or is this dimension THREE? *runs away*
20:10:53 <c_wraith> I've heard tales of a third dimension, but I didn't believe them
20:12:09 <FunctorSalad> I barely get the beginnings of two-dimensional ct...
20:12:22 <FunctorSalad> I can't even bear to look three-cats in the eyes
20:12:25 <FunctorSalad> ;)
20:12:36 <copumpkin> how do I make a cabal flag that adds an optional executable (the test runner)?
20:12:40 <copumpkin> or is there a better approach?
20:12:57 <ezyang> copumpkin: Check out the iteratees package for an example 
20:13:03 <FunctorSalad> copumpkin: hmm guard the 'buildable' field with it AFAIK
20:13:06 <FunctorSalad> with the flag
20:13:17 <ezyang> http://hackage.haskell.org/packages/archive/iteratee/0.4.0.2/iteratee.cabal 
20:13:31 <lispy> copumpkin: the darcs cabal file is another good example
20:13:37 <copumpkin> oh I see
20:13:52 <dolio> djahandarie: Yes.
20:14:15 <lispy> copumpkin: be mindful of the level of testing of ifs when combining fields.  Some cabal's are buggy and they'll combine all the levels but the order is undefined unless they're all at the same level
20:14:49 <lispy> copumpkin: so you might have to add if true\nif true\nif thing I care about ...
20:14:58 <copumpkin> lispy: ah
20:15:06 <lispy> (but only matters if order of flags matters)
20:15:24 <lispy> So it can matter when passing options to gcc, for instance
20:15:28 <FunctorSalad> can't you just flatten it to "if (fooify && testing)"?
20:16:11 <lispy> FunctorSalad: I don't recall trying that, but it seemed to be related to how deeply nested the expression was inside of if blocks
20:16:34 <lispy> IIRC, dcoutts confirmed and fixed it (okay, actually once I found the work around I never followed up to make sure he fixed it)
20:16:41 <FunctorSalad> I'm probably misunderstanding the problem. Thought the nesting of if's is the issue
20:17:34 <lispy> FunctorSalad: the issue is that some field, say ghc-options, was getting concatenated in an unpredicitable order.  Normally you expect the order to be top to bottom with in the cabal file and left to right within a line
20:18:05 <lispy> FunctorSalad: But if the lines are at different levels of nesting (inside if-blocks) some cabals will concatenate them in unpredicatable order instead of top to bottom
20:18:29 <lispy> I think the order was like, nesting level, then top to bottom, then left to right
20:18:47 <lispy> FunctorSalad: make sense?
20:19:16 <FunctorSalad> lispy: ah, I see
20:19:39 <FunctorSalad> didn't even know it tries to concatenate repeated fields at all
20:20:00 <lispy> yeah, it does. That's a very important property for reducing redundancy in the cabal file
20:20:22 <lispy> You can sort of left-factor your fields relative to the conditionals
20:21:40 <fengshaun> where can I get Data.Either.Unwrap from?  cabal install tells me it's "wrong syntax"
20:22:04 <djahandarie> Does a monad transformer have some sort of category theory representation?
20:23:13 <lispy> djahandarie: pretty much everything does, so while I don't know the theory to answer your question I bet it's yes :)
20:23:25 <copumpkin> hmm, cabal can't parse my file :(
20:23:37 <lispy> copumpkin: hpaste?
20:24:35 <copumpkin> oh fixed it
20:24:48 <applicative> fengshaun, cabal install either-unwrap
20:25:02 <fengshaun> applicative: oh thanks!
20:25:55 <applicative> fengshaun, the package names cant always be predicted from those of the modules inside, of course.  this one is http://hackage.haskell.org/packages/archive/either-unwrap/1.1/doc/html/Data-Either-Unwrap.html
20:27:54 <roconnor> djahandarie: not to my knowledge
20:28:10 <djahandarie> I feel like it would be some sort of functor
20:28:49 * djahandarie goes to bed instead of thinking about category theory
20:28:55 <int80_h> hey lispy you there?
20:29:25 <lispy> int80_h: for the next few minutes ya
20:29:43 <int80_h> lispy, this tutorial has me off on a tangent, I have to learn about GADT's to do this right.
20:30:15 <lispy> int80_h: I'd recommend cutting some corners then :)  GADTs are great, but seem a bit heavy handed to teach people how to use a database
20:30:27 <lispy> int80_h: what use did you have in mind for the GADTs?
20:30:53 <copumpkin> base-4.1.0.0 was excluded because of the top level dependency base -any
20:30:58 <copumpkin> any ideas?
20:31:07 <ezyang> wut 
20:31:10 <copumpkin> I don't have a top-level dependency on base -any
20:31:18 <lispy> copumpkin: do you have a upper bonud on base?
20:31:21 <copumpkin> yeah
20:31:51 <lispy> copumpkin: I'd have to see your cabal file, I recokn
20:31:55 <lispy> reckon*
20:32:12 <int80_h> lispy, well, I am using the database example from that url I showed you. I'm reading the tables from the command line, but they are three different tables. So now I have different types. But I'm doing the same operation on these types (parsing the strings in preparation for populating a database table). After some discussion I was convinced that a GADT would be the way.
20:32:12 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29622#a29622
20:32:42 <int80_h> lispy, I did things the lazy way already but I found it to be unsataisfying.
20:33:05 <ezyang> copumpkin: Try base == 4.*? 
20:33:13 <int80_h> so I stopped, after finishing my parsing function, thinking it was better to do it right before moving ahead.
20:33:17 <copumpkin> I was just reading that's syntactic sugar
20:33:25 <lispy> copumpkin: So I think it's a problem in your Executable section
20:33:30 <ezyang> It's actually slightly in semantics with what you have. 
20:33:33 <copumpkin> weird
20:33:33 <lispy> copumpkin: I think cabal thinks  "base -any" is defined for the executable
20:33:44 <copumpkin> no, ezyang's thing fixed it :O
20:33:46 <copumpkin> strangely enough
20:33:50 <lispy> hmm
20:33:53 <ezyang> \o/ 
20:34:13 <lispy> why does that fix it?
20:34:28 <ezyang> *mumble* base is special *mumble* 
20:34:48 <int80_h> lispy, my justification is, from the material out there already people could do things by hand in a corner-cutting way. I wanted to offer something new. How would takusen be used in a development situation.
20:35:02 <lispy> but, base == 4.* is not the same as base >= 4 && < 4.2 (in terms of what it expresses I mean)
20:35:25 <int80_h> which means, being used with language extensions, other libraries.
20:36:04 <lispy> int80_h: if you can do it with GADTs you can probably do it with type classes, BTW
20:36:11 <int80_h> lispy, but I do have this habit of trying to do too much. But I feel if I get this parsing problem solved the right way the database part of the code will be smooth as butter.
20:36:17 <lispy> But they have a different set of trade offs
20:36:33 <int80_h> lispy, yeah my first thought was typeclasses. IUs it a matter of preference?
20:37:23 <lispy> type classes are open and come with dictionary overhead.  GADTs are close, no dictionary overhead, and sometimes type checking them blows up in your face.
20:37:24 <ezyang> GADTs can often let you write more compact coce. 
20:37:29 <int80_h> I found a paper typeclasses vs GADTs, it was over my head though.
20:37:39 <ezyang> Since GADTs refine types upon pattern matching. 
20:37:45 <int80_h> I would trade compact for readability.
20:38:02 <ezyang> In many cases, the compactness increases readability. 
20:38:27 <kmc> GADTs properly used feel quite natural
20:38:58 <int80_h> lispy, well since this still is just a tutorial and will not be extended, maybe the GADT is the right weay to go.
20:39:08 <kmc> "compact vs readability" is often about using esoteric operators versus spelling things out.  that's not what we're talking about here
20:39:45 <lispy> int80_h: it's hard for me to comment.  I think you could definitely go with what you think is right.
20:40:03 <lispy> s/could/should
20:40:38 <int80_h> okay I'll see where this takes me. Having a little trouble with the concept but I discovered "GADTs for dummies" which seems exactly what I need.
20:41:09 <kmc> int80_h, i like the example at http://haskell.org/ghc/docs/6.12.2/html/users_guide/data-type-extensions.html#gadt
20:41:24 <kmc> (it's a canonical example really)
20:43:09 <int80_h> thanks :)
20:43:46 <Maxdamantus> Hmm.. Doesn't GHC do some UTF-8 encoding or something directly?
20:44:41 <kmc> int80_h, basically, you push more information about your data into its type
20:44:46 <kmc> information about which constructors were used
20:44:53 <fengshaun> what should be the type of a function that gets a Network.Stream.Result as argument and returns a string?
20:45:07 <kmc> Network.Stream.Result -> String
20:45:12 <fengshaun> extractResp :: Result a -> String  
20:45:24 <fengshaun> that doesn't work
20:45:47 <Maxdamantus> That's saying it takes a Result a
20:45:48 <fengshaun> I can't paste the error, since windows cmd doesn't let me copy anything
20:45:50 <kmc> fengshaun, where's Network.Stream from?
20:46:15 <fengshaun> what do you mean where it's from?
20:46:19 <kmc> what package
20:46:30 <kmc> HTTP looks like
20:46:38 <fengshaun> it was installed by default (Haskell platform)
20:46:48 <kmc> http://hackage.haskell.org/packages/archive/HTTP/4000.0.7/doc/html/Network-Stream.html yes?
20:46:58 <kmc> so what's the error?
20:47:09 <fengshaun> yes
20:47:18 <fengshaun> let me retype the error here
20:48:54 <fengshaun> 'Result' is not applied to enough type arguments | Expected kind '??', but 'Result' has kind '* -> *' | In the type signature for 'extractResponse':  | extractResponse :: Result -> String
20:49:07 <fengshaun> 'Result' is not applied to enough type arguments | Expected kind '??', but 'Result' has kind '* -> *' | In the type signature for 'extractResponse':  | extractResponse :: Result -> String
20:49:38 <fengshaun> oops, double post, sorry
20:50:43 <lispy> fengshaun: it needs to be like extractResponse :: Result a -> String
20:51:01 <fengshaun> lispy: still, no luck!
20:51:23 <Maxdamantus> Presumably it will have a different error.
20:51:42 <fengshaun> yes, let me type it
20:52:28 <lispy> fengshaun: http://hpaste.org :)
20:52:33 <fengshaun> Couldn't match expected type 'Response a' against inferred type 'ConnError' 
20:52:49 <fengshaun> lispy: I wish, windows cmd doesn't let me copy anything
20:52:54 <fengshaun> for some random reason
20:53:29 <fengshaun> for some random reason
20:53:35 <fengshaun> damn, double again
20:54:10 <Maxdamantus> Right click the command prompt window, mark, select stuff, then I think enter to copy
20:54:26 <Maxdamantus> (It uses a box select for some reason)
20:55:55 <fengshaun> Maxdamantus: thank you!
20:55:59 <fengshaun> lispy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29625#a29625
20:56:19 <lispy> fengshaun: are you pretty new to haskell?
20:56:32 <fengshaun> 2 days! :)
20:56:44 <lispy> fengshaun: to experienced eyes, the error message pretty clearly says use Response String instead of Response a :)
20:56:56 <lispy> fengshaun: in this case, it was your "excepted type" that you want to use here
20:57:06 <lispy> and [Char] = String
20:57:24 <fengshaun> yea, but I don't use a Response anywhere in the code!
20:57:49 <lispy> I guess, technically maybe it's saying Result (Response String)
20:57:58 <lispy> Either way, it wants a Response String in there
20:58:17 <fengshaun> lispy: still, error
20:58:47 <fengshaun> couldn't match expected type Either a b against inferred type 'IO (Result (Response ty))'
20:59:04 <fengshaun> in the call to simpleHTTP
20:59:07 * shapr has zen types... all are unexpected
20:59:09 <lispy> fengshaun: what is the type of rspBody?
20:59:45 <fengshaun> rspBody :: Response a -> a
21:00:23 <lispy> ah
21:00:32 <lispy> fengshaun: well, fromRight requires an either
21:00:35 <lispy> :t fromRight
21:00:35 <lambdabot> Not in scope: `fromRight'
21:00:42 <lispy> ?hoogle fromRight
21:00:42 <lambdabot> No results found
21:00:47 <jaredj> so i have a type MyCoolArray = Array (Int, Int) Int, and i want it to show differently. can i use the Show type class at all?
21:01:00 <lispy> anyway, I expect fromRight :: Either a b -> b
21:01:05 <ezyang> jaredj: Sure. 
21:01:10 <ezyang> You can write a custom print function 
21:01:18 <fengshaun> lispy: yes, Result is returned from simpleHTTP which is 'type Result a = Either ConnError a' (synonym)
21:01:51 <kmc> jaredj, if you can write a function of type MyCoolArray -> String, you can make the Show instance call that function
21:01:51 <c_wraith> jaredj: you can use a newtype if you actually want a different Show implementation
21:01:59 <danportin> is there a library function that returns a fixed point of (iterate f) for Sets?
21:02:17 <jaredj> c_wraith: "the constructor of a newtype must have exactly one field but Array has two"
21:02:26 <kmc> if you introduce a new type
21:02:36 <kmc> newtype MyCoolArray = MyCoolArray (Array (Int, Int) Int)
21:02:38 <jaredj> c_wraith: wait wait nevermind, i didn't read the whole error
21:02:48 <jaredj> right ok
21:02:50 <c_wraith> I was gonna say, I think you forgot some parens :)
21:02:54 <kmc> jaredj, note that "newtype" is like an optimized version of "data".  the syntax is the same otherwise
21:03:06 <kmc> (but it's more restricted, and has slightly different semantics)
21:03:37 <c_wraith> The thing about using the newtype is that it is *not* a type synonym, it's actually an incompatible type.  So it's probably not what you want.
21:03:38 <jaredj> garh i don't really want that data constructor all in my code
21:03:51 <Maxdamantus> It looks like fromRight on line 40 is being applied to an IO (Result Response)
21:04:08 <c_wraith> You probably really just want a pretty-printer that's not in the Show class
21:04:24 <fengshaun> Maxdamantus: but Result is just a synonym for Either a b
21:04:41 <Maxdamantus> But IO (Result Response) is not
21:04:44 <fengshaun> Maxdamantus: http://www.haskell.org/http/api/Network-Stream.html#t%3AResult
21:04:45 <jaredj> c_wraith: sounds like it
21:04:50 <fengshaun> ah yes
21:05:35 <fengshaun> so, what should be the type of extractResponse?
21:05:49 <fengshaun> the return type of simpleHTTP is here: http://www.haskell.org/http/api/Network-HTTP.html#t%3AResponse
21:06:30 <Maxdamantus> What's fromRight?
21:06:50 <fengshaun> fromRight :: Either a b -> b
21:07:04 <Maxdamantus> Ah.
21:07:14 <fengshaun> simpleHTTP :: Request -> IO (Result Response)
21:07:23 <fengshaun> so, what should I do with the IO thing?
21:07:42 <c_wraith> bind it in another IO action
21:07:44 <Maxdamantus> Are you actually using extractResponse somewhere?
21:08:09 <fengshaun> in main
21:08:25 <Maxdamantus> main = putStrLn . rspBody . fromRight . simpleHTTP $ myReq
21:08:29 <fengshaun> oh damn, I forgot to add it there again
21:08:55 <fengshaun> yea, no luck
21:09:14 <fengshaun> now: main = putStrLn . extractResponse . simpleHTTP $ myReq
21:09:42 <Maxdamantus> simpleHTTP :: Request -> IO (Result Response)
21:09:55 <fengshaun> yes
21:10:22 <Maxdamantus> I think you need to use some monadic stuff.
21:10:45 <fengshaun> ohh haven't read about those yet
21:11:27 <c_wraith> You just need the <- operator in do syntax.
21:11:29 <fengshaun> Maxdamantus: thanks!
21:12:09 <fengshaun> c_wraith: so, simpleHTTP myReq >>= extractResponse >>= putStrLn ?
21:12:41 <c_wraith> fengshaun, not completely, because the types don't line up for that.  I'd just use do syntax, remembering to use <- for name assignments in IO.
21:12:45 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
21:13:01 <fengshaun> c_wraith, kmc: thanks!
21:13:05 <fengshaun> I'll try it now
21:15:24 <fengshaun> c_wraith: doing do resp <- simpleHTTP myReq and then using extractResponse works!  also the type for extractResponse is ":: Result (Response [Char]) -> String"
21:15:27 <fengshaun> thanks a lot!
21:15:49 <kmc> fengshaun, if you just want to bind a local name without doing IO in a "do" block, you can use "let"
21:16:12 <kmc> do { x <- getChar; let y = ord x; print y }
21:16:28 <fengshaun> kmc: thanks!
21:16:52 <c_wraith> fengshaun, that's exactly the way I was thinking.  Nice work figuring it out. :)
21:17:37 * hackagebot mathblog 0.1 - A program for creating and managing a  static, mathematically-inclined weblog  http://hackage.haskell.org/package/mathblog-0.1 (JonathanDaugherty)
21:17:44 <fengshaun> but I should admit this type system (coming from a dynamic, imperative language) sometimes walks on my nerves!
21:18:26 <kmc> yup
21:18:34 <kmc> fengshaun, writing correct programs is difficult in any language
21:18:48 <kmc> Haskell makes it so that writing incorrect programs is also difficult
21:20:06 <fengshaun> Finally!!  woohoo!
21:35:49 <tehgeekmeister> there is a total version of head somewhere, no?
21:36:07 <Veinor> @hoogle safeHead
21:36:07 <lambdabot> Data.ByteString.Unsafe unsafeHead :: ByteString -> Word8
21:36:09 <Veinor> @hoogle headSafe
21:36:09 <lambdabot> No results found
21:36:30 <c_wraith> @hackage safe
21:36:30 <lambdabot> http://hackage.haskell.org/package/safe
21:37:44 * hackagebot anansi 0.2.0.1 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.2.0.1 (JohnMillikin)
21:38:21 <kmc> listToMaybe
21:38:44 * hackagebot libxml-sax 0.6.0.1 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.6.0.1 (JohnMillikin)
21:43:46 * hackagebot enumerator 0.4.0.1 - Implementation of Oleg Kiselyov's left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.0.1 (JohnMillikin)
21:45:46 * hackagebot libxml-enumerator 0.4.0.1 - Enumerator-based API for libXML's SAX interface  http://hackage.haskell.org/package/libxml-enumerator-0.4.0.1 (JohnMillikin)
21:49:47 * hackagebot dbus-core 0.8.5.1 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.8.5.1 (JohnMillikin)
21:49:49 * hackagebot dbus-client 0.4.0.1 - Monadic and object-oriented interfaces to DBus  http://hackage.haskell.org/package/dbus-client-0.4.0.1 (JohnMillikin)
21:50:56 <tehgeekmeister> it's =<< that is the "inverse" of >>=, right?
21:51:11 <lispy> tehgeekmeister: they are flips of each other
21:51:17 <lispy> ?src (=<<)
21:51:17 <lambdabot> f =<< x = x >>= f
21:51:24 <tehgeekmeister> that's what i want
21:51:30 <lispy> tehgeekmeister: I think inverse would be different
21:51:36 <tehgeekmeister> thanks
21:51:40 <tehgeekmeister> yeah, inverse would be
21:51:42 <tehgeekmeister> hence i quoted
21:51:45 <tehgeekmeister> i knew it was the wrong term
21:52:48 * hackagebot gnuidn 0.1.1.1 - Bindings for GNU IDN  http://hackage.haskell.org/package/gnuidn-0.1.1.1 (JohnMillikin)
21:53:48 * hackagebot network-protocol-xmpp 0.3.2.2 - Client <-> Server communication over XMPP  http://hackage.haskell.org/package/network-protocol-xmpp-0.3.2.2 (JohnMillikin)
21:57:49 * hackagebot gnome-keyring 0.2.2.2 - Bindings for libgnome-keyring  http://hackage.haskell.org/package/gnome-keyring-0.2.2.2 (JohnMillikin)
21:59:11 <lispy> John is on a roll
21:59:50 * hackagebot yajl 0.3.0.2 - Bindings for YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-0.3.0.2 (JohnMillikin)
21:59:52 * hackagebot yajl-enumerator 0.2.0.1 - Enumerator-based interface to YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-enumerator-0.2.0.1 (JohnMillikin)
22:00:22 <Pseudonym> And what have you done with YOUR day?
22:02:51 * hackagebot expat-enumerator 0.1.0.1 - Enumerator-based API for Expat  http://hackage.haskell.org/package/expat-enumerator-0.1.0.1 (JohnMillikin)
22:03:30 <lispy> That's 12 package updates today
22:03:37 <lispy> do you think he waited for mailman day?
22:04:12 <copumpkin> maybe he just changed his email address and wanted to reupload versions with the correct new address :P
22:04:15 <copumpkin> so he uploaded all his packages
22:08:55 <lispy> ah the downsides to treating all metadata as being package relevant
22:09:05 <lispy> (it has bonuses too to be sure)
22:11:41 * tehgeekmeister finally found an example of why fmap is so useful
22:11:43 <tehgeekmeister> whoooooooo
22:12:57 <copumpkin> there are loads
22:13:05 <lispy> tehgeekmeister: It's a trap! :)
22:13:17 <tehgeekmeister> lispy: ehhhh?
22:13:18 <c_wraith> I kind of feel like fmap is too limited, and totally want the generalized fmap now.
22:13:54 <tehgeekmeister> copumpkin: yes, but until you read up on functors you are like "what is this fmap crap in all this code?"
22:14:31 <tehgeekmeister> then you read and are like, okay, well that's cool.  but when would i use it.  and then you realize you want to do something to something inside a maybe in a function that's point free.  and you finally get it.
22:14:40 <tehgeekmeister> c_wraith: generalized fmap?
22:14:53 <c_wraith> the one that has a class like:  Functor f a b where fmap :: f a -> f b
22:15:50 <tehgeekmeister> eh?  that one makes no sense to me
22:15:50 <c_wraith> It's a generalization of the standard Functor class, in that it lets you restrict the types of a and b in your instances, so you can implement it in cases where you can't implement Functor now
22:15:59 <tehgeekmeister> ahhh
22:18:48 <tehgeekmeister> (is there a flip of . somewhere?)
22:19:00 <c_wraith> :t (>>>)
22:19:00 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
22:19:26 <c_wraith> > ((+1) >>> (*2)) 6
22:19:27 <lambdabot>   14
22:19:34 <c_wraith> > ((+1) <<< (*2)) 6
22:19:36 <lambdabot>   13
22:19:55 <tehgeekmeister> okay
22:19:56 <tehgeekmeister> cool
22:20:07 <c_wraith> The type signatures are...  more amazing. :)
22:20:19 <tehgeekmeister> yeah, the type signatures scare me
22:20:50 <c_wraith> Like, with that generalization of Functor, you could implement Functor for Set.  The instance line would look like: instance (Ord b) => Set a b where ... 
22:20:58 <c_wraith> err, crap
22:21:10 <c_wraith> instance (Ord b) => Functor Set a b where ...
22:21:40 <c_wraith> Which would give you the restrictions necessary to ensure that your functor instance can't be used to break the invariants of the structure.
22:22:19 <c_wraith> (Though it would still require re-ordering the whole set, but that's a minor issue. :))
22:22:52 <c_wraith> Or, in the case I was thinking about at work...  instance Functor MyWrapper ByteString ByteString where ....
22:23:16 <c_wraith> The wrapper can only wrap ByteString, so it can't be an instance of functor.
22:23:38 <tehgeekmeister> ah
22:23:41 <tehgeekmeister> yes, this is useful
22:23:43 <tehgeekmeister> i understand now
22:23:59 <tehgeekmeister> couldn't you do something like Functor'
22:24:00 <tehgeekmeister> w
22:24:04 <tehgeekmeister> ith fmap'
22:24:09 <tehgeekmeister> ?
22:24:12 <c_wraith> But, multiparameter type classes aren't haskell 98, so it wasn't around initially.
22:24:26 <c_wraith> And I think the rmonad package probably has such a definition already.
22:24:41 <tehgeekmeister> rmonad?
22:24:57 * hackagebot convertible-text 0.3.0.3 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.3.0.3 (MichaelSnoyman)
22:24:59 * hackagebot data-object 0.3.1.3 - Represent hierachichal structures, called objects in JSON.  http://hackage.haskell.org/package/data-object-0.3.1.3 (MichaelSnoyman)
22:25:21 <c_wraith> http://hackage.haskell.org/package/rmonad
22:26:01 * hackagebot data-object-json 0.3.1.2 - Serialize JSON data to/from Haskell using the data-object library.  http://hackage.haskell.org/package/data-object-json-0.3.1.2 (MichaelSnoyman)
22:26:03 * hackagebot persistent 0.2.0.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.2.0.2 (MichaelSnoyman)
22:26:05 * hackagebot yesod 0.5.0.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.5.0.2 (MichaelSnoyman)
22:26:37 <c_wraith> Eh, rmonad uses a different mechanism, but the same kind of idea.  Generalize by allowing restrictions
22:27:25 <ski> c_wraith : when you you want to use that non-functor class ?
22:27:40 <ski> (oh, `Set')
22:27:51 <c_wraith> That's one example, yes.
22:28:02 <ski> imo, that's the wrong abstraction for `Set'
22:28:43 <c_wraith> I just want an abstraction of "apply this function to what's 'inside' this value"
22:28:51 <c_wraith> Without the container being forced to be fully general
22:29:50 <ski> hm
22:30:02 <ski> with specific element types before and after ?
22:30:21 <ski> or even only allow mapping an endo-function on a specific element type ?
22:30:36 <c_wraith> possibly!  leave that up to the instance declaration.  It will declare an instance appropriate for what it supports.
22:31:13 <ski> well, if you allow mapping between different element types, probably the collection type should be allowed to vary, as well
22:31:30 <ski>   class Mappable f g a b where map_able :: f a -> g b
22:31:48 <ski> er
22:32:07 <c_wraith> Eh.  I see less value for that.
22:32:08 <ski>   class Mappable c d a b | c -> a , d -> b where map_able :: (a -> b) -> (c -> d)
22:32:12 <ski> rather
22:33:27 <ski> in some cases, i think one can use GADTs for restricting the allowable "element" types to some pre-specified set
22:34:00 <ski> in the case of `Functor', it doesn't work for the result "element" type, though
22:34:21 <ski> possibly it would work in some `Foldable'-like class
22:38:45 <ski> hm .. i suppose that `RFunctor' and `RMonad' using `Constraints' seem better than the `class RFunctor f a b where fmap :: (a -> b) -> (f a -> f b)' kind of thing i've seen before
22:40:21 <ski> btw, if you have a GADT, then it probably can't be made into a `Functor' (satisfying the laws) .. however, there's an easy way to make a `Functor' from it
22:40:52 <ski> namely, if `Foo' is your GADT (of kind `* -> *'), then `CoYoneda Foo' is always a `Functor'
22:41:34 <ski>   data CoYoneda f a = forall x. FMapIncl (x -> a) (f x)
22:46:22 <ski> (the problem with `class Functor f a b where fmap :: (a -> b) -> (f a -> f b)' imo is that it is too general / has too little structure .. e.g. what are the appropriate laws that it ought to satisfy ?)
22:50:01 <tehgeekmeister> @type (>>=)
22:50:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:50:22 <ski> int80_h : SYN
22:53:46 <int80_h> ski: ACK
22:56:15 <FunctorSalad> calculate how many MB of rar files you are going to accidentally like a pro!
22:56:17 <FunctorSalad> du -sm **/*.rar | cut -f1 | ghc -e 'interact (show . sum . map read . lines)'
22:56:34 <FunctorSalad> beautiful line isn't it ;)
22:58:58 <lispy> FunctorSalad: what does ** do?
22:59:11 <int80_h> oh great ski is afk
22:59:13 * lispy is not familiar with this glob
22:59:18 <FunctorSalad> lispy: recursive glob, in zsh
22:59:37 <FunctorSalad> (in other words, this will find all the rar files below the current directory)
22:59:42 <lispy> FunctorSalad: interesting.  I wonder if bash has it.  If it does what I think it does, I've wanted it
22:59:55 <lispy> FunctorSalad: yeah, i use find for that now
22:59:57 <FunctorSalad> lispy: zsh has a ridiculous list of glob modifiers ;)
23:00:04 <lispy> find . -iname "*.rar"
23:00:48 <FunctorSalad> (for filtering by file attributes, taking the head/tail/absolute path and what not)
23:01:20 <FunctorSalad> yes, it's like a find replacement
23:01:46 <ski> int80_h : nono, you're supposed to reply with `SYN/ACK', and then i reply with `ACK'
23:01:50 <lispy> I only use find for the most basic stuff.  I can't seem to memorize the find syntax
23:02:18 <lispy> WHat with the weird \{} ; stuff
23:02:21 <ski> int80_h : i wondered how you wanted `dealWithTable' to work
23:02:33 <FunctorSalad> lispy: it's to save it from the shell...
23:02:35 <int80_h> ski: oh there you are
23:02:45 <FunctorSalad> 'find' just expects {} '
23:02:47 <FunctorSalad> err
23:02:49 <FunctorSalad>  {} ;
23:02:51 <ski> int80_h : either a (sensible) type signature, or a sketch of an implementation would work, probably
23:03:29 <ski> int80_h : i'm asking this, since it seems that earlier parts will have to depend on this, or part of that code with not be sensible
23:03:46 <int80_h> ski: well, I was going to adapt the parsec example from RWH to create a [(a,b)] where a and b are two of the types mentioned earlier
23:03:48 <FunctorSalad> for example, you can do echo '-name *.rar -exec accidentally {} ;  ' | xargs find .
23:04:22 <ski> int80_h : how will `dealWithTable' know what to do in each of the three cases, when the tables have differing types ?
23:04:41 <int80_h> ski: and from there create another function that populates the right table, or maybe three different functions for each possible table
23:04:47 <FunctorSalad> (or avoid the echo and use a heredoc, even ;))
23:05:19 <ski> int80_h : either you need some class with operations `dealWithTable' should use (and then i need to know what it's named, and what arguments it takes) .. or you're going to pass `name' to `dealWithTable' as well
23:05:41 <ski> int80_h : (.. or you're going to pass a record instead of using a class constraint)
23:05:41 <int80_h> ski: well from what I understand GADTs, like typeclasses, allow one to create a function that does a series of operations on different types
23:05:52 <ski> int80_h : those are the only sensible alternatives i can see at the moment
23:06:19 <int80_h> ski: well I was thinking in terms of class constraint, but then when people recommended using a GADT, I didn't know how to visualize what to do.
23:06:46 <ski> int80_h : well, i suggested a GADT, since that seemed to be what your `loader' wanted to be
23:07:13 <ski> int80_h : but then i realized that you'd then have to have a separate lookup table from the program names to constructors of the GADT anyway
23:07:21 <int80_h> ski: for example, is the following true? You create a function that takes a paramter a with a class constraint Num. Does that mean a can be an Int or any type in Class Num?
23:07:38 <ski> int80_h : so it appears then that using a GADT (for this) would probably be a useless intermediate step, then
23:08:07 <int80_h> ski: Okay I'll go along with that. This was a new idea I was persuing out of curiosity, and faith that it was the right way.
23:08:15 <ski> (well, if you're going to pass the GADT constructor to other places, i might not be useless .. but if you only pass it to `lookup', then it's uselesS)
23:08:44 <int80_h> ski: would it not be passed to dealwithTable?
23:08:55 <ski> you don't do that in the code in the paste
23:09:23 <ski> passing the program name (or the GADT constructor, which is almost the same thing, only better, type-wise), was one of the alternatives i mentioned above
23:09:52 <int80_h> ski: oh that code was written by someone else, he had an erroneous idea of what dealWithTable was supposed to dfo. I didn't bother dealing with it yet because there were other problems that seemed to be more immediate.
23:10:18 <ski> so, if you do pass the GADT constructor to `dealWithTable', then the GADT is not useless (since then you only need to do the mapping from untyped program name to typed GADT constructor once)
23:11:05 <ski> int80_h : yeah .. but i discovered that deciding how to solve the problems in `loaders' requires knowing at least the interface that `dealWithTable' is supposed to have
23:11:10 <ski> (i.e. it's type signature)
23:11:16 <ski> (s/it's/its/)
23:11:25 <int80_h> ski: and if I do that, dealWithTable will then be able to work with the right types?
23:11:52 <ski> if you give it a sensible type signature, it should probably be able to do that, yes
23:12:18 <ski> but as i don't really know what it is supposed to do, i can't conjure up the type signature
23:12:40 <int80_h> ski: hold on I'm looking at old code
23:13:52 <ski> (the `Eq1' and `Map1' / `Assoc1' i talked about earlier is an interesting thing in itself .. but it might not be needed in your code, depending on how `dealWithTable' is supposed to function)
23:14:37 <int80_h> okay each of the three functions mentioned in loader creates a [(a,b)]
23:15:08 <int80_h> ski: oh I see why I was leaving this alone
23:15:20 <int80_h> ski: the type is going to be a bitch
23:16:02 <int80_h> ski: it will take a [(a,b)] plus something funky from Takusen, and return some kind of IO action
23:16:35 <int80_h> ski: dealWithTable is what will actually populate the database table
23:17:02 * ski doesn't know Takusen
23:17:03 <int80_h> chrisdone has a good example of how to do it, with amelie (I think it is called)
23:18:25 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29570
23:19:51 <int80_h> I have some old code that I used to start this project off
23:20:40 <int80_h> > createTable :: [Table] -> DBM mark Session Int
23:20:40 <int80_h> > createTable table = map buildTable table
23:20:41 <lambdabot>   Not in scope: type constructor or class `DBM'Not in scope: type constructor...
23:20:41 <lambdabot>   <no location info>: parse error on input `='
23:20:49 <int80_h> ski: see the return type?
23:21:23 <ski> hm
23:21:30 <ski> what is `mark' ?
23:21:42 <ski> and what is `Table' ?
23:21:49 <int80_h> ski: as far as I can tell some TH hocus pocus
23:22:02 <int80_h> Table was my old data type
23:22:12 <int80_h> > data Table = MkTable 
23:22:12 <int80_h> >       { tableName :: String
23:22:12 <int80_h> >       , tableColumns ::[(String, Int)]
23:22:13 <int80_h> >       } deriving (Show, Read)
23:22:13 <lambdabot>   <no location info>: parse error on input `data'
23:22:14 <lambdabot>   <no location info>: parse error on input `,'
23:22:14 <lambdabot>   <no location info>: parse error on input `{'
23:22:14 <lambdabot>   <no location info>: parse error on input `}'
23:22:22 <lispy> ski: mark is like s in the ST monad.  It allows you to separate transactions
23:22:32 <int80_h> the return type would be the same but the parameter would conform to the new approach
23:22:37 <ski> lispy : ok (i suspected it was something like that)
23:22:57 <carter> copumpkin:  how many alt logins  doyou have?
23:25:16 <ski> int80_h : so, how will you populate the DB with your new table type(s) ?
23:26:13 <int80_h> ski: well I hadn't gotten that far yet
23:26:25 <int80_h> ski: that seemed to be a different problem.
23:26:46 <ski> well it is
23:27:01 <int80_h> ski: hold on I have the notation in a toy program I made, when I was first playing with takusen
23:27:01 <ski> but presumably how you do that will depend on which the table type is
23:27:10 <int80_h> yes
23:27:23 <ski> which means that the code which executes before that will somehow need to tell it what the table type is
23:27:35 <int80_h> well I was hoping I could use one function for all three possibilities
23:27:51 <ski> well, if you could do that, that would be ideal
23:27:53 <int80_h> ski: is this not where typeclasses come into use?
23:27:57 <ski> but i don't think you can do that
23:28:00 <int80_h> nuts
23:28:02 <ski> possibly
23:28:24 <int80_h> like I was asking before
23:28:44 <lispy> int80_h: the general strategy I employ in this case:  Do it the simple, repetitive way, and then once that's done look for ways to refactor it to be more general.  Hopefully you'll come up with a way to reduce all the duplication.
23:28:46 <ski> (i don't think you can do that, because, presumably the DB doesn't understand `Student',`ID', &c. but must be passed `String's instead .. so you must be able to unwrap the types)
23:29:33 <ski> i suppose you could make a type class for how to push a table to the DB
23:29:45 <lispy> ski: actually, takusen will convert your types to string automatically if they are types the database understands (String, Maybe Int, etc)
23:29:50 <int80_h> lispy: I thought I might have to do that. I was prepared to do that. I was hoping that maybe a clear answer was apparent to more experienced people.
23:29:56 <ski> but then, what would `dealWithTable' do, except just calling the method of that type class
23:30:10 <ski> i.e., what's the point of haveing a separate `dealWithTable', then ?
23:30:34 <ski> lispy : in this case, int80_h has defined `newtype Student = Student String', &c.
23:30:37 <int80_h> ski: I see your point, it's not needed. But maybe I should do what lispy suggested.
23:30:54 <ski> lispy : can takusen auto-convert those (possibly deriving some class) ?
23:31:10 <int80_h> plus, I wanted to go from specific to general anyway as a matter of pedegogy.
23:31:31 <ski> well, it is not clear to me what specific you want to generalize
23:31:46 <int80_h> it seems this is the way these tutorials are written "let's try it this way", "oh see how bad that is" "Here's a better way",
23:32:06 <int80_h> ski: hold on I will hunt down the specifics
23:32:44 <int80_h> this is just an example the paramter will need to change
23:33:43 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29626#a29626
23:34:01 <int80_h> the important thing here is the paramter is a pair
23:34:07 <lispy> ski: it certainly seems like a manual or derived instance would work here, but I'm about to go to bed and I'm not sure what type class it would be
23:34:17 <int80_h> in the new code, I will still have a tuple.
23:34:59 <int80_h> well lispy when I got to this part thursday or friday I intended on sending the list mail 
23:35:49 <lispy> int80_h: cool
23:36:13 <lispy> int80_h: sounds like you've made a lot of progress
23:36:15 <int80_h> should the problem get resolved here I will figure out a way to put in on the list for reference.
23:37:11 <lispy> int80_h: good luck and good night
23:37:31 <int80_h> lispy: thanks. I'm committed to making this happen. My weakness however, is I sometimes try to take on too much, make the scope too big. But I think this time it's just right and will work out a way to include the extraneous material in a way that doesn't interfer with the main point.
23:39:15 <ski> int80_h : hm .. i suppose what i'm wondering atm is why you put `loadFoo's into your lookup table, rather then `loadAndPushFoo's ?
23:39:54 <ski> (possibly there is a valid reason for not doing that. i just don't know it)
23:40:21 <int80_h> ski: because eventually the PushFoo function should be just one function handling all three instances.
23:40:38 <int80_h> ski: I didn't make it that way, but I liked it for the above reason.
23:40:39 <ski> (of course, each of those could be defined as `loadAndPushFoo = pushFoo . loadFoo', if you want)
23:41:02 <int80_h> oooh!
23:41:05 <int80_h> I see
23:41:45 <ski> well, factoring out common code from the `loadFoo's would be a valid reason, yes
23:42:08 <ski> (if there is any common code to factor out)
23:42:08 <int80_h> yes that was the reason
23:42:15 <int80_h> I'm anticipating there will be
23:42:40 <int80_h> the only thing that should change in each function is the data types 
23:42:41 <ski> sorry, s/loadFoo/pushFoo/, i meant
23:43:01 <ski> i would like to see one (or two) specific `pushFoo's, to see how one might go about factoring
23:43:06 <int80_h> the operations would be the same
23:43:22 <int80_h> okay
23:43:23 <ski> well, something must be different, because the types have to be different
23:44:26 <int80_h> ski: the example I pasted just now is almost liie what I will be doing nowe with one exception
23:44:40 <int80_h> ski: in that example, the table being populated is hardcoded
23:44:55 <int80_h> ski: in the new way, I would use a bind variable
23:44:58 <ski> did you annotate your previous paste ?
23:45:07 <int80_h> ski: no I made a new one
23:45:15 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29626#a29626
23:45:22 <ski> oh, you mean `29626' ?
23:45:24 <ski> .. right
23:45:37 <ski> that only inserts a pair, though
23:45:46 <ski> i'd like to see the code that inserts a whole table
23:45:52 <int80_h> right, I would map over it
23:45:57 <int80_h> gotcha
23:46:00 <ski> `mapM'
23:46:51 <ski> btw, you could replace `act_entry' by `(activity,cost)', removing the `where'-clause altogether
23:47:12 <int80_h> ah thanks. I always want to know ways to make my code better
23:47:52 <ski> (similarly, i think `unwords $ fst $ unzip loaders' is nicer written as `unwords (map fst loaders)'
23:47:55 <ski> )
23:48:15 <int80_h> no unzip?
23:48:22 <ski>   fst . unzip = map fst
23:48:49 <ski> that way, the code probably avoids creating an intermediate list, which is then not used
23:48:54 <int80_h> ah
23:49:14 <ski> (i.e. it would avoid creating the list of the `snd's of the pairs)
23:49:56 <int80_h> ski: okay I cannot find an example of what you would like. I can make one tomorrow though, using the model in the previous paste. The idea is the same.
23:50:03 <int80_h> I have to sleep :)
23:50:07 <int80_h> good night
23:50:20 <ski> (also, i would remove all the uses of `$' there, using brackets instead, as i think that's prettier here .. `$' doesn't really buy much)
23:50:48 <ski> int80_hSLEEPYTIM : night
23:51:03 <Botje> unzip = map fst &&& map snd
23:51:26 <Botje> so the compiler won't even bother with the second part ;)
23:51:52 <ski> @src unzip
23:51:52 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
23:52:08 <ski> Botje : well, that's two-pass, if both parts are used
23:52:49 <ski> ideally we'd like demands for values to be able to tell which parts of a value is wanted
23:53:51 <ski> (.. though possibly this would expand into a proper mode-system, then)
23:54:31 * ksf would like to try out cal, but I can't find _any_ documentation on how to a) write a main function b) compile that to a .class c) compile that to a .java
23:55:15 <ski> the idea being that the caller of `unzip', gives information to `unzip', depending on how the result is forced, so that in some cases, `unzip' knows from the outset that only the first list will be demanded, and thus it doesn't even need to construct the second list (not even thunks for it)
23:55:32 <ski> ksf : "cal" ?
23:56:02 <ksf> http://openquark.org/Open_Quark/Welcome.html
23:56:27 <ksf> looks suspiciously like haskell
23:58:58 <Heffalump> ski: isn't that what the inliner is for?
