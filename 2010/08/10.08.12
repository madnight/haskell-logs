00:03:48 <lispy> ah ha!
00:03:51 <lispy> That was the problem.
00:04:19 <lispy> I wasn't doing a clean.  So cabal noticed that the dependencies changed (it forced me to do a configure) but it didn't re-link the source
00:04:37 <lispy> In order to get the relinking I had to do a clean
00:04:39 <lispy> So, is that a bug?
00:04:56 <philed> Is haskell.org down for everyone else?
00:05:00 <lispy> philed: aye
00:05:10 <lispy> philed: well, hackage is down
00:05:15 <lispy> Not sure about Haskell.org
00:05:16 <c_wraith> I generally do a clean whenever I do a configure.
00:05:20 <philed> Bugger.
00:05:42 <c_wraith> It probably is a bug that configure doesn't force a recompile if anything to change compile settings changed.
00:10:49 <lispy> The fact that I have to type: cabal clean && cabal configure && cabal build, a lot is probably a bug
00:11:11 <lispy> I'm just realizing that I should probably make a shell function for it.  One that takes an optional parameter (the arguments to configure)
00:13:35 <Wooga> how do i increment Nth element of list [1..10] ?
00:15:03 <lispy> > spitAt 4 [1..10]
00:15:04 <lambdabot>   Not in scope: `spitAt'
00:15:11 <lispy> > splitAt 4 [1..10]
00:15:12 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
00:15:25 <DiggPatriots> good evening
00:15:31 <Wooga> lispy: thanks!
00:16:06 <lispy> Wooga: I wouldn't actually use that in my solution though :)
00:16:19 <DiggPatriots> is there any demographics about Haskell programmers?
00:16:32 <DiggPatriots> I need it for a thesis comparing certain data of different programmers
00:16:39 <DiggPatriots> for different languages
00:16:45 <lispy> DiggPatriots: there was a survey recently for haskell programmers
00:16:55 <DiggPatriots> the results are out?
00:17:00 <Wooga> lispy: is there a better way then spliting list, and extracting element with last and then combining list again?
00:17:08 <lispy> and dons has some stats about hasekell platform downloads, not sure if he made them public
00:17:18 <lispy> DiggPatriots: yes, just google for haskell survey and they should appear
00:17:36 <lispy> Wooga: I think so.
00:18:00 <lispy> Wooga: I bet you could do a traversal of the list and do less work
00:18:32 <lispy> incList 0 [x] = [succ x]
00:18:53 <lispy> incList 1 (x:xs) = incList 0 xs
00:18:58 <dibblego> Wooga, yes, using a zipper
00:18:59 <lispy> er
00:19:05 <lispy> incList 1 (x:xs) = x : incList 0 xs
00:19:22 <lispy> incList 2 (x:xs) = x : incList 1 xs
00:19:23 <FunctorSalad_> hÃ¤ckage is down?
00:19:27 <lispy> FunctorSalad_: yes
00:19:33 <dibblego> > last /topic
00:19:34 <lambdabot>   Not in scope: `topic'
00:20:23 <Wooga> dibblego: what is 'zipper' ?
00:20:23 <kyagrd> Is Hackage down?
00:20:32 <dibblego> kyagrd, yes, as per topic
00:20:37 <dibblego> Wooga, http://www.haskell.org/haskellwiki/Zipper
00:20:43 <kyagrd> Wooga: derivative of a data structure
00:20:50 <Wooga> thank you
00:25:33 <DiggPatriots> i am dissappointed
00:25:35 <DiggPatriots> in that suvery
00:25:53 <kmc> Wooga, lists are really not the right data structure for random access
00:25:56 <kmc> though you can do it
00:25:59 <DiggPatriots> I see nothing about the number of Asians, Whites, and Hispanics   vs Fecal-colored negroid apes
00:26:16 <kmc> oh snap
00:26:19 <kmc> @where ops
00:26:19 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
00:26:28 <DiggPatriots> well if you all are interested in partaking in the study done by the Universidad Nacional Autónoma de México
00:26:42 <DiggPatriots> in conjunction with the IMET Instituto Mexicano de Estudios Trológicos
00:26:46 --- mode: ChanServ set +o dibblego
00:26:54 <DiggPatriots> contact us a chimpout forum
00:27:02 <DiggPatriots> c h i m p o u t . c  o m / forum
00:28:07 <Wooga> kmc: what better then?
00:28:19 <kmc> Data.Sequence, Data.IntMap
00:28:24 <Wooga> thanks
00:28:31 <kmc> Wooga, do you know why lists are bad for random access?
00:28:50 <Wooga> you have to traverse across all list to get the right element?
00:28:54 <kmc> yeah
00:29:13 <kmc> and then when you modify it, you have to copy the whole spine of the list up to that point
00:29:16 <lispy> and (++) is really slow, so you don't want to break and recombine that way
00:29:43 <kmc> whereas something like Data.Sequence has a tree shape, can find nodes in O(log n) time, and when you update it only copies the path to the root, and shares the rest of the tree
00:29:57 <DiggPatriots> Anybody interested in assisting with demographic research about the number of fecal negroid monkeys as opposed to human whites, asians, indians and hispanics who use Haskell,
00:30:06 <DiggPatriots> contact our division at chimpout forum
00:30:10 --- kick: DiggPatriots was kicked by dibblego (DiggPatriots)
00:30:17 <kmc> ...?
00:35:18 * dibblego waves 
00:35:25 <kmc> (++) is slow if you think of lists as data structures
00:35:29 <jrockway> "K-lined"?
00:35:46 <QtPlatypus> jrockway: Blocked from the server
00:35:48 <kmc> if you think of them as loops waiting to happen, then sometimes (++) is exactly what you want, as it runs one loop after another
00:35:51 <QtPlatypus> irc server
00:35:56 <dibblego> jrockway, it was an accident by freenode staff
00:36:05 <jrockway> ok, that's what i was wondering :)
00:36:46 <Philippa> timing was a bit... coincidental
00:37:36 <jrockway> yeah, i read that and was like, "hah, dibblego k-lined those idiots, nice"
00:37:42 <jrockway> then i read it more carefully, and became confused :)
00:37:59 <jrockway> now back to your regularly-scheduled commentary on the speed of the (++) operator
00:38:02 <jrockway> :)
00:40:43 <azaq231> xs ++ ys = foldr (:) ys xs -> O(n) ~ length xs
00:44:37 <FunctorSalad_> jrockway: ^^
00:45:38 <philed> So you'd use a left-fold in an eager language. Do you generally get the same performance from left-folds in GHC?
00:48:00 <c_wraith> if you use foldl' instead of foldl
00:48:53 <philed> Ah cool. Didn't know about that one.
00:51:00 <Axman6> using foldl' would probabl;y be less efficient than foldl for (++), unless you need to evaluate the elements in the list anyway. not sure though
00:51:14 <c_wraith> Well, that's true.
00:51:58 <c_wraith> If your operation is non-strict, use foldr
00:52:44 <Axman6> hmm, how do you even use foldl for (++)?
00:55:05 <philed> Sorry, take concat instead
00:56:16 <philed> Are there cases where GHC can turn a use of foldl' into a loop?
00:56:49 <azaq231> @src concat
00:56:49 <lambdabot> concat = foldr (++) []
00:59:43 <Axman6> philed: quite commonly i believe
01:00:45 <philed> Cool.
01:07:50 <kmc> philed, the core list fusion framework is  based on foldr and build
01:07:54 <kmc> i'm not sure how it deals with foldl'
01:08:21 <kmc> nor do i know how the newer stream fusion framework does it
01:08:47 <kmc> if you want to investigate how GHC optimizes your code, ghc-core is a useful tool
01:19:09 <mm_freak_> is there a way to use exceptions in a monad transformer above IO?
01:21:18 <c_wraith> That's what the MonadCatchIO thing is all about
01:21:21 <etpace> @hoogle (b -> a -> Maybe b) -> b -> [a] -> b
01:21:22 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
01:21:22 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
01:21:22 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
01:21:28 <c_wraith> Except MonadCatchIO is a bit broken, sadly
01:22:00 <c_wraith> But it works right for *some* transformed IOs
01:22:11 <etpace> > foldM (\acc x -> if x == 5 then Nothing else Just (acc+x)) 0 [1..5]
01:22:12 <lambdabot>   Nothing
01:22:16 <etpace> bah
01:26:44 <mm_freak_> etpace: are you looking for normal (>>=)?
01:27:02 <etpace> nah, a fold where I can stop folding with a Nothing
01:27:11 <etpace> i've jsut written my own, was wondering if there was something in the libs
01:27:40 <mm_freak_> that doesn't fit into the monadic model of Maybe
01:27:45 <mm_freak_> sounds like a job for Cont
01:30:42 <mm_freak_> > let abort = Cont . const in foldM (\acc x -> if x == 5 then abort acc else return (acc+x)) 0 [1..5]
01:30:43 <lambdabot>   No instance for (GHC.Show.Show (Control.Monad.Cont.Cont b b))
01:30:44 <lambdabot>    arising fr...
01:30:57 <mm_freak_> > let abort = Cont . const in flip runCont id $ foldM (\acc x -> if x == 5 then abort acc else return (acc+x)) 0 [1..5]
01:30:58 <lambdabot>   10
01:31:03 <mm_freak_> there you go
01:32:16 <fasta> A good compiler should make it unnecessary to use Cont for that. 
01:32:34 <etpace> cheers
01:32:40 <mm_freak_> fasta: how would you do it?
01:32:55 <mm_freak_> (or which optimization are you referring to?)
01:33:47 <fasta> mm_freak_, I thought you were demonstrating early exit on multiplication with a zero element. I didn't actually read the code. Never mind. 
01:34:52 <mm_freak_> well, of course my approach would be:
01:35:07 <mm_freak_> > sum . takeWhile (/= 5) $ [1..5]
01:35:08 <lambdabot>   10
01:37:10 <{g}> Hey People! Anybody here who understands N!=NP?
01:37:37 <fasta> {g}, nobody, otherwise it would have been solved already.
01:37:39 <mm_freak_> P /= NP
01:37:40 <Ke> I bet quite a few understand something about it
01:37:58 <{g}> Im trying to come up with a simple description of the thing.
01:38:00 <bastl> there was another paper in the news recently
01:38:01 <mm_freak_> fasta: apparently there is a proof now, but it hasn't been reviewed enough yet
01:38:12 <fasta> mm_freak_, I read it 2 days ago.
01:38:14 <{g}> Here is something I wrote: http://en.gibney.org/a_simple_definition_of_p_and_np/
01:38:19 <{g}> I wonder, if its correct.
01:38:52 <mm_freak_> {g}: isn't it better to ask in #math?
01:38:58 <Ke> effectively P != NP to date, since we have no way of utilizing other options
01:39:05 <{g}> mm_freak_: all #mathis are asleep :)
01:40:05 <fasta> {g}, why do you feel the need to write something on a subject in which you are not an expert?
01:40:29 <fasta> {g}, there must be something on which you are an expert, write something about that instead :)
01:40:46 <{g}> fasta: its my way of learning
01:41:14 <mm_freak_> {g}: writing such articles won't really help you /understand/ P and NP
01:41:23 <mm_freak_> better write algorithms in particular problem classes and run them
01:41:32 <fasta> {g}, you left out showing that NP is not trivial. 
01:41:43 <mm_freak_> look at their running time behaviour and try to reason about it looking at the source code
01:41:51 <fasta> {g}, (which Cook and some Russian showed a long time ago)
01:42:26 <{g}> fasta: i dont know anything about something being "trivial"
01:43:25 <fasta> {g}, anyway, you should mention NPC at least. 
01:43:51 <fasta> {g}, which are the NP-Complete problems, the hardest elements of the problems in NP.
01:44:07 <{g}> fasta: "mention"? im trying to define P and NP.
01:45:20 <fasta> {g}, NP is defined relative to a non-deterministic Turing machine. 
01:45:48 <fasta> {g}, you can simulate one of those in EXP time, yes and in that sense what you write is OK.
01:46:03 <fasta> {g}, except it is rather silly to write this down on a public website.
01:46:12 <fasta> {g}, since it is basically noise. 
01:46:27 <fasta> {g}, making notes is good, just don't do it on a website.
01:47:04 <{g}> fasta: do you think on needs the concept of a non deterministic turing machine to explain np? isnt it suffice to say that a normal turing machine needs x^n steps to find a solution for the hard np problems?
01:47:14 <mm_freak_> i don't really find it ok, because {g}'s definitions would imply a proof that P â  NP
01:47:36 <fasta> mm_freak_, ah, you are right.
01:49:03 <fasta> mm_freak_, is there an EXP problem verifiable in P time? 
01:49:06 <{g}> mm_freak_: nice!
01:49:31 <fasta> mm_freak_, I am not exactly sure about your assertion now.
01:50:44 <fasta> {g}, it is not that it needs x^n steps. It is that we know that with x^n it works in any case. 
01:51:15 <fasta> {g}, x^n is like an extremely simple upper bound. 
01:51:30 <{g}> mm_freak_: I updated the text with your complaint. Any ideas how to fix it?
01:51:32 <mm_freak_> fasta: i don't know
01:51:54 <mm_freak_> {g}: you must refer to NDTMs
01:52:20 <fasta> {g}, I am fairly sure your original definition was correct. 
01:52:21 <mm_freak_> fasta: NP problems can be solved in polytime by an NDTM
01:52:29 <{g}> fasta: so you would change the text "NP is the class of questions that a turing machine can answer in x^n steps" to "NP is the class of questions that a turing machine can answer in x^n steps or less"?
01:52:33 <fasta> mm_freak_, yes, that's what I already said above.
01:52:38 <mm_freak_> yet we don't know whether a DTM could solve them in polytime
01:52:43 <mm_freak_> that's the P = NP question
01:52:50 <fasta> mm_freak_, right
01:52:54 <mm_freak_> if P = NP, then {g}'s definition is wrong
01:52:58 <mm_freak_> otherwise it's right
01:53:17 <{g}> mm_freak_: do you think one HAS to refer to NDTMs to define NP? I find NDTMs very confusing and would be happy to just have normal TMs in the definition.
01:53:28 <fasta> mm_freak_, no, that's only the case if you can verify an EXP problem in P time. 
01:53:39 <mm_freak_> {g}: currently you have to
01:53:41 <quicksilver> Yes, I think you HAVE to refer to NDTMs.
01:53:44 <quicksilver> they are the definition.
01:53:53 <quicksilver> there is no direct reduction of NP to EXP or P...
01:53:57 <{g}> mm_freak_: if n!=np then my definition is correct?
01:53:57 <quicksilver> otherwise the problem would be solved.
01:54:08 <piis3141> The Haskell platform website seems down; does anyone know an alternative way to download the Haskell platform for Mac OS?
01:54:18 <mm_freak_> {g}: probably, but it's a complicated field, so i'm not really sure
01:54:27 <{g}> quicksilver: you would agree that if p!=np then my definition would be correct?
01:55:21 <fasta> {g}, again, I am pretty sure that there is not a single EXP time problem that can be verified in P time. 
01:55:45 <mm_freak_> fasta: do you really need verification to show the difference?
01:55:59 <fasta> {g}, so, your original definition (however silly it is to redefine it), is probably correct.
01:56:06 <fasta> mm_freak_, that is a fundamental part of it.
01:56:29 <quicksilver> {g}: it seems to be a bit foolish to define one of the terms involved in a major unsolved problem by assuming a solution to the problem.
01:56:47 <quicksilver> the entire point of the P=NP question is the fact that, currently, we can't decide where NP lies exactly.
01:56:56 <fasta> mm_freak_, it is the question of "is solving a puzzle just as difficult as checking the answer up to P?".
01:56:57 <Sisu> are NDTMs really necessary for definition of NP? can't NP just be defined as the class of problems with solutions verifiable in P time by DTM?
01:57:10 <quicksilver> so, to give a definition of NP which assumes a solution to the question is to make the question look vacuous.
01:57:11 <mm_freak_> fasta: yes, but i have the impression that problem solving is equivalent
01:57:31 <{g}> Sisu: thats exactly my question.
01:57:34 <fasta> mm_freak_, that is only true if P=NP. 
01:57:55 <fasta> quicksilver, where do you think he makes an assumption?
01:58:17 <mm_freak_> fasta: i mean, you can define P and NP by the running times of the problems
01:58:25 <fasta> Actually, never mind.
01:58:39 <kmc> yes, NP is the set of languages where strings in the languages have polynomial-size witnesses and the witnesses are checkable in P
02:01:21 <{g}> Ok, I updated http://en.gibney.org/a_simple_definition_of_p_and_np/ based on all your input.
02:01:32 <mreh> I've discovered some of the documentation for my core libraries are missing
02:01:43 <mreh> is it advisable just to reinstall them with cabal?
02:01:51 <mreh> the docs, not the libraries
02:02:30 <p_l> btw, can anyone point me to a good statistics package for Haskell? Something closer to SPSS than Excel, though :)
02:02:44 <kmc> {g}, you're confusing NP and EXP
02:03:07 <kmc> NP is not inherently about exponential time
02:03:12 <kmc> it's about polynomial-time checking
02:03:13 <fasta> {g}, you only need the verifiability part. The extra condition that you have to be able to solve the problem in EXP time is something that can be proven to always work and is thus superfluous. 
02:03:24 <chrisdone> suggestions for generating human readable haddock interface files on the command line?
02:03:24 <kmc> if you are after "a simple definition" then you should omit this irrelevant fact
02:03:33 <kmc> P = polynomial time solvable, NP = polynomial time verifiable
02:03:35 <kmc> that's all
02:03:58 <chrisdone> I really don't want to have to write a parser for a binary format
02:04:36 <Saizan> haddock --hoogle
02:05:14 <chrisdone> chris@cn-done:~/Haddock$ haddock --hoogle -i /home/chris/.cabal/share/doc/fastcgi-3001.0.2.3/html/fastcgi.haddock
02:05:15 <chrisdone> haddock: internal Haddock or GHC error: Prelude.head: empty list
02:05:19 <chrisdone> tee hee!
02:05:28 <Saizan> duh, not like that
02:05:34 <Saizan> on the sources.
02:05:36 <{g}> fasta, kmc: wow, interesting!
02:05:46 * chrisdone specifically said "haddock interface files"
02:05:51 <fasta> {g}, just read "Introduction to Algorithms". 
02:06:02 <Saizan> ah, ok, no way then
02:06:16 <kmc> {g}, i recommend _Introduction to the Theory of Computation_ by Michael Sipser
02:06:30 <kmc> and _Computational Complexity_ by Papadimitriou
02:06:30 <Saizan> chrisdone: you can parse them with the haddock lib
02:06:42 <kmc> the latter is higher level but both are self-contained so you can start with either
02:06:48 * chrisdone specifically said command line
02:06:48 <chrisdone> :p
02:06:55 <chrisdone> oh well
02:06:56 <fasta> kmc, what's good about Computational Complexity?
02:07:00 <Saizan> that's why i said "no way" :)
02:07:05 <fasta> kmc, I read the other one you mentioned.
02:07:11 <kmc> Sipser's book is pretty short and covers stuff really essential to a CS undergrad education
02:07:30 <kmc> fasta, it's just got more stuff in it
02:07:31 <chrisdone> kind of lame. ghc has --show-iface
02:07:42 <{g}> fasta, kmc: updated the page again.
02:07:45 <kmc> covers logic / model theory, more classes, more models of computation, attacks on P vs NP, etc
02:08:09 <Gracenotes> chrisdone: I'm not sure what you can do with haddock interface files
02:08:26 <Gracenotes> it would be nice to get docs, hscolour, and haddock from them in one go
02:08:51 <Saizan> their purpouse is to let haddock know what exports something, so it can link back to them
02:08:52 <Gracenotes> but I'm guessing you can only get the latter? eh.
02:09:11 <Saizan> you can't even get the latter
02:09:34 <Gracenotes> in any case, it would be nice if someone could create a format that had these. would be useful for uploading docs to hackage.
02:09:55 <Saizan> though i'm not very clear on which info the lack to be able to generate haddock docs from them
02:10:17 <Saizan> s/the lack/they lack/
02:10:55 <chrisdone> I wonder why haddock --hoogle -i foo.haddock throws an exception. is it a bug?
02:11:11 <chrisdone> haddock: internal Haddock or GHC error: Prelude.head: empty list
02:11:20 * chrisdone already lectured the haddock developer about using partial functions
02:11:28 <chrisdone> :p
02:15:13 <philed> Hackage is back up.
02:16:40 <mreh> yay
02:55:03 <Zeiris> The "databases are categories" presentation draws a pretty neat relation between databases and record data types. Are there ways to convert between the two neatly without template-haskell?
02:56:46 <Cale> Zeiris: I must have missed that bit (I didn't watch it all the way through)
02:56:59 <Cale> Zeiris: Which relation in particular?
02:57:20 <Zeiris> The last slide here https://docs.google.com/viewer?url=http://code.galois.com/talk/2010/10-06-spivak.pdf
02:57:44 <Zeiris> Records are rows, record accessor functions are columns, types are tables.
02:58:15 <Cale> Well, not just records, but all functions
02:58:38 <Cale> Er, every function A -> B is a "column" of the "table" A
02:59:46 <Cale> I think we need more support for categories at the language level. This presentation actually gives more insight into why that might be useful.
03:01:31 <Zeiris> It's probably not always useful to see functions this way ('length' is a column of the string table - or any list-table?) Records in particular, though, seem extremely applicable in a practical way.
03:02:09 <Zeiris> I recently spent a lot of time on neatly loading big CSV files into Haskell - and the data representation I seem to have settled on is exactly what's described at the end of the slides.
03:02:29 <Cale> Zeiris: Well, I think there's an elegance to viewing it that way. Of course, most real databases have tables with many more columns than you'd normally see them as having if you look at things that way too.
03:03:12 <Cale> (You're effectively taking the largest join that you can possibly take when thinking about any given table)
03:03:13 <Zeiris> It could be that this is something obvious, and it just took me several iterations to reach 'cuz I'm a newb - but it does seem like a very generic way to view databases.
03:03:30 <Cale> Yeah, I really like it.
03:04:01 <Cale> What we really ought to do is to design a database and language for interacting with databases from the ground up in this fashion.
03:04:37 <Cale> SQL has the advantage of popularity, but it's not very elegant in a lot of ways
03:05:01 <Zeiris> Or, even better, design a haskell API for interacting with databases in this fashion. Then provide backends to all popular DBs.
03:05:17 <Cale> Yeah, that's probably a more practical step.
03:05:50 <Zeiris> (Preferably referencing the One Ring in the library name.)
03:07:22 <Cale> The tricky part is that types are static, and real-world databases are rarely meant to be.
03:07:55 <Zeiris> Aren't table columns fairly static?
03:08:10 <Cale> Columns are for the most part, sure.
03:08:26 <Cale> But consider the set of rows in some table.
03:08:56 <Cale> Which is supposed to be related to the set of all values in some datatype.
03:09:04 <Zeiris> If rows are instances of the type, they can be as dynamic as you want. As long as the columns are the right type.
03:09:06 <Cale> That set will have to change
03:09:23 <quicksilver> Zeiris: tables are also used as datatypes, this is a common idiom.
03:09:27 <Cale> Which is to say that its *size* will have to change
03:09:53 <quicksilver> finite types (enumeration-types) are stored as tables
03:09:59 <quicksilver> and other tables foreign-key into them
03:10:04 <quicksilver> that sort of type does "change" at runtime.
03:10:36 <Cale> (since the size of the table is now the only thing which is intrinsic to the table)
03:10:58 <Cale> (everything else being encoded in the relationships between it and the other tables)
03:11:54 <Zeiris> So the set of rows in the database covers only a portion of the set of rows of the type. What problems would that cause?
03:12:24 <Cale> Zeiris: Well, presumably, we might want to be able to delete some row from the database.
03:13:04 <Cale> Zeiris: What does that mean? It means that this row has to stop existing as a value of the type of its table.
03:13:43 <Zeiris> Yeah, some information is missing from the type. The type needs some kind of container wrapping it.
03:13:58 <Cale> Well, the type *is* being thought of as a container
03:14:07 <Cale> But normally types are static containers in this sense
03:14:19 <Cale> The set of values belonging to a type is normally fixed at compile time.
03:14:35 <Cale> But for databases, we don't want that.
03:15:17 <Cale> Hmm...
03:16:26 <Zeiris> So the type "Table" can represent the full, abstract table. And the type "Db Table" can represent a subset of the Table type. And db access operations, delete/find/etc can map between the two.
03:16:34 <Cale> hmm
03:16:43 <quicksilver> but the full abstract table would be "Every string"
03:16:45 <quicksilver> that's not very useful.
03:17:24 <Zeiris> Well, it'd be a generic DB interface that could work with -any- backend, and hopefully capture some idea instrinsic to all databases.
03:17:42 <fasta> Don't you just need one of those TH KD-trees with functions between the different versions for conversion? 
03:17:55 <Cale> It would be really neat if we had a sort of value which represented some finitely generated category, and which could be locally embedded into the set of Haskell datatypes by means of some construction like:  let import myCategory in ...
03:18:42 <Cale> and outside of that context, would be viewed as a single value (and subject to variation)
03:20:04 <Cale> I'm pretty hazy on the details, but the idea would be that the objects of myCategory would become types, and the arrows of myCategory would become functions.
03:20:31 <Cale> However, I'm not sure how to manage things. It looks like you'd need dependent typing.
03:20:59 <fasta> Is there a PDF client where if you copy â, you get '?
03:25:46 <vrthra> hello,
03:26:28 <pkrumins> `olleh
03:26:31 <vrthra> I am trying to parse a lit of expressions with parsec, and have a bit of a problem
03:26:46 <vrthra>  I can parse "5 6" to 5, 6
03:26:57 <vrthra> but on parsing  "5 6 " , I get errors
03:27:03 <vrthra> http://pastebin.com/Sr93G69P
03:27:34 <vrthra> it seems skipMany space at the end does not skip spaces when used at the end,
03:27:41 <vrthra> but it seems to work when used at the begining
03:28:26 <vrthra> I am very new to haskell, any idea what I have done wrong?
03:32:54 <dfkjjkfd> just guessing : (tX `sepBy` space) expects to parse a tX, after parsing a space
03:34:47 <kmc> vrthra, you're trying to parse a list of numbers?
03:35:16 <vrthra> I am trying to parse a list of expressions, got my error isolated to this :)
03:35:22 <kmc> by calling "concat" you glue them together into one string
03:35:27 <vrthra> following the scheme in 48 hrs
03:35:32 <kmc> e.g. when i run Â«parseTest lX "12 34"Â» i get "1234"
03:35:36 <vrthra> yes
03:35:50 <vrthra> I was just showing it as an example of my problem
03:35:55 <kmc> ok
03:36:29 <vrthra> so, sepBy is the issue? any pointers what I can do instead?
03:36:42 <kmc> sec, i'm investigating
03:40:58 <kmc> vrthra, you can use sepEndBy instead
03:41:05 <kmc> "sepEndBy p sep parses zero or more occurrences of p, separated and optionally ended by sep"
03:41:06 <vrthra> ok
03:41:12 <kmc> would you like an explanation of why sepBy fails?
03:41:22 <vrthra> that would be cool
03:41:33 <vrthra> is it similar to what dfkjjkfd mentioned?
03:41:41 <kmc> yes
03:41:47 <kmc> parsec parsers don't backtrack by default
03:41:58 <vrthra> ok
03:42:04 <kmc> that is, if a parser fails after consuming some input, that input is still consumed
03:42:12 <kmc> even when trying the next alternative
03:42:37 <kmc> you can use the "try" combinator to turn a parser into a backtracking parser
03:42:37 <vrthra> hmm, thanks, that makes sense, and sepEndBy works too
03:42:39 <fasta> vrthra, you write down parse a bunch of stuff separated by spaces. So, when a space is consumed it expects stuff. 
03:42:53 <fasta> vrthra, stuff is not there, and it falls apart.
03:43:07 <fasta> vrthra, you should read the manual. 
03:43:21 <kmc> hmm, i'm not certain that the non-backtrackingness is relevant though
03:43:22 <fasta> Parsec is one of the few libraries that has acceptable documentation.
03:43:36 <tg_> that sounds like a ringing endorsement
03:43:42 <kmc> fasta, i've found the Parsec documentation to be fairly inconsistent
03:43:52 <kmc> since the library API has gone through many revisiosn
03:43:58 <vrthra> yes, working through the tutorial now, so I was just using that and the hoogle
03:43:59 <kmc> older docs aren't even correct on module names
03:44:01 <fasta> kmc, you might have used certain more advanced features than I have. 
03:44:21 <fasta> kmc, I don't count the modules names. 
03:44:36 <fasta> kmc, just the "idea" of the library is what is important to me. 
03:44:59 <kmc> it does cause confusion
03:45:06 <kmc> i agree it's not the biggest issue
03:45:15 <fasta> kmc, yes, it would be better if it would be perfectly up to date :)
03:45:34 <fasta> Still it is orders of magnitude better than ported GTK documentation. 
03:50:42 * hackagebot hoauth 0.2.5 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.2.5 (DiegoSouza)
03:59:28 <mreh> I can't see the difference practically between State and Reader
03:59:56 <byorgey> mreh: with State, you can change the state.  with Reader, it is read-only.
04:00:07 <shachaf> mreh: Reader is the equivalent of an extra argument.
04:00:36 <mreh> what about the Reader local?
04:00:43 <mreh> "local e"
04:00:56 <mreh> :t local
04:00:56 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
04:01:09 <zygoloid> mreh: that's not changing the state. that's just a convenience wrapper around runReader
04:01:09 <byorgey> mreh: local lets you run a subcomputation with a different state.  That is very different than changing the state for the remainder of the current computation.
04:01:31 <shachaf> @ty local :: (r -> r) -> (r -> a) -> r -> a
04:01:32 <lambdabot> forall r a. (r -> r) -> (r -> a) -> r -> a
04:01:50 <quicksilver> zygoloid: it's much more than a convenience wrapper around runReader
04:01:59 <quicksilver> zygoloid: because it's polymorphic in m
04:02:21 <quicksilver> zygoloid: it manages to interleave the other effects of the Monad m with the environment changes.
04:02:34 <quicksilver> (well, OK, not much more because reader is so incredibly simple)
04:03:59 <quicksilver> but IIRC the stuff in MonadWriter is actually quite troublesome for that reason.
04:04:00 <mreh> does @ty remove the type-fu
04:04:12 <mreh> @ty put
04:04:13 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
04:04:26 <mreh> oh
04:04:31 <byorgey> mreh: no, notice shachaf gave a more restrictive type annotation
04:04:36 <mreh> yeah
04:05:09 <mreh> that would imply that (->) e is an instance of Reader
04:05:23 <mreh> MonadReader
04:05:28 <mreh> so why the need for the wrapper
04:06:36 <mreh> was that a wholly ignorant question?
04:07:18 <Zeiris> Anyone seen the spam on hpaste? What's going on, some botnet using it for CnC or something?
04:07:34 <ToRA> mreh: because usually it's a real pain to have the monad instance for (->) defined
04:07:53 <ToRA> it leads to very confusing error messages when you forget an argument or type do in the wrong place
04:08:20 <zygoloid> quicksilver: i agree for local in general, but i was talking about Reader's local :)
04:08:31 <shachaf> Also, it's used differently. Why ever use newtype?
04:08:34 <ToRA> to get the (->) you need to import Control.Monad.Instances iirc
04:08:34 <mreh> it confuses nubs though!
04:10:34 <Wooga> is anything like lookup, searching by second element of tuple exists?
04:12:09 <mreh> Wooga: it depends what you mean
04:12:25 <mreh> if you want a list of key value pairs, yes there definitely is
04:12:39 <Wooga> i have list [(1,2),(3,4)] and i want to get 1 using 2 as argument
04:13:13 <quicksilver> > find (\(_,y) -> y==2) [(1,2),(3,4)]
04:13:13 <lambdabot>   Just (1,2)
04:13:24 <Wooga> thank you!
04:13:42 <quicksilver> > find ((==2) . snd) [(1,2),(3,4)]
04:13:43 <lambdabot>   Just (1,2)
04:13:48 <quicksilver> gratuitous points-free version ;)
04:14:02 <quicksilver> it will return Nothing if not found.
04:14:16 <Wooga> just like lookup. perfect.
04:14:18 <mreh> but that's impossible
04:21:32 <tg_> famous last words
04:21:52 <Zeiris> I've got a CSV parser library, which describes the structure of a file via a long line of "<*> dec <*> dec ...", and the types of columns via records that are instances of a class which provides a "dec"ode method. It's nice because it lets me combine columns, but the fact that structure is described via a hideous <*> <*> <*> line bothers me.
04:22:29 <earthy> CSV is hideous...
04:22:47 <earthy> plus, there's probably a lot of columns, right?
04:23:09 <earthy> you could format the 'line' vertically
04:23:22 <Zeiris> I'd like to move to using column names (first row of CSV file) instead. It'd let me do queries out of order, and factor out non-adjacent columns...
04:23:47 <Zeiris> (Code at the moment, with sample usage at the bottom. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28934#a28934) An example CSV file has 166 columns :)
04:23:56 * Zao huggles Text::CSV in CPAN :D
04:24:13 <earthy> yah. 166 columns is never going to look nice
04:24:21 <kmc> Wooga, if you're going to be doing a lot of lookups, a list is inefficient
04:24:22 <earthy> at least not statically typed...
04:24:32 <kmc> Wooga, see Data.Map
04:28:13 <earthy> zeiris: however, you could look at Text.CSV.ByteString. it returns a list of records (which are lists of fields)
04:28:31 <earthy> and then you could conceivably take the names from the first record
04:28:51 <earthy> and fill the appropriate fields of your Weapon struct from the appropriate fields in the following records
04:29:46 <Zeiris> earthy, I've used it, and actually wrote my own 'cuz it didn't handle ,,,, the way I wanted it to :p
04:30:53 <earthy> yah
04:30:53 <mm_freak_> Zeiris: there is 'repeat' and 'sequence'
04:31:01 <mm_freak_> uhm
04:31:06 <mm_freak_> 'replicate', not 'repeat'
04:31:20 <mm_freak_> maybe that's more useful than a long <*> chain
04:31:25 <earthy> mm_freak: not for getting a statically typed Weapon from a csv record...
04:31:41 <Zeiris> mm_freak_, I'd like to do that, but have trouble wrapping my head around how to do it with <*>
04:31:50 <earthy> zeiris is using the type system to infer the types of each dec in the <*> chain
04:31:56 <Zeiris> The sheer fact that <*> manages to fill type constructors almost blows my mind.
04:32:01 <mm_freak_> ah, ok
04:32:21 <mm_freak_> but you do understand how <*> works, right?
04:32:37 <earthy> zeiris: the closest thing to what you want is probably something along the lines of HList
04:33:36 <Zeiris> mm_freak_, yes, once I realized functions were functors.
04:33:47 <Zeiris> earthy, how would HList work in this situation?
04:34:01 <mm_freak_> i found HList nasty to work with
04:34:09 <earthy> mm_freak: yah.
04:34:21 <mm_freak_> but that might be just me =)
04:34:37 <earthy> zeiris: what you *want* is to say 'okay, parse 166 fields of this record into the appropriate types'
04:35:29 <Zeiris> Yep. With the additional complication of some types eating multiple fields. And (I'd like this if possible) fields being non-adjacent and indexed by column name.
04:35:30 <earthy> this is relatively easy *if* you can accumulate types
04:36:35 <earthy> i.e.  takeField :: String -> a -> (b,a)
04:37:09 <earthy> then you'd have to build up a chain of takeField ended by a emptyField :: ()
04:40:14 <Zeiris> Is there some equivalent to "Constr <$> dec <*> dec <*> dec <*> dec ..." buildable with sequence?
04:40:45 <earthy> well, only for a nested-tuple type
04:41:06 <Zeiris> That seems like it'd just create more problems :D
04:41:14 <earthy> i.e. (a,(b,(c,(d,(e,(f,(g,(h,(i,(j,(k,())))))))))))
04:41:33 <earthy> zeiris: that's exactly what HList sets out to 'disprove'
04:43:27 <earthy> zeiris: you could also generate the dec <*> dec <*> line using Template Haskell
04:43:57 <mm_freak_> may i see the file format?
04:43:58 <Zeiris> Fffffff, I keep getting "template-haskell!" as answers to my questions. Is it truly that useful, or am I asking the wrong questions?
04:43:59 <earthy> however, you'd still not be using the first line of the csv file
04:44:05 <mm_freak_> (as an example file, that is)
04:44:08 <earthy> zeiris: you're asking *hard* questions
04:44:28 <mm_freak_> Zeiris: well, i've never used TH, and never missed it =)
04:44:33 <earthy> basically, you want a mapping from a *large* list of non-typed strings to a large typed record
04:44:38 <mm_freak_> so far all of my problems were easily solvable in plain haskell
04:44:51 <earthy> that mapping is going to need specification
04:45:02 <earthy> that specification is *bound* to involve *some* boilerplate
04:45:12 <earthy> which in this case is the line of dec's
04:45:54 <earthy> unless, ofcourse, you don't need all fields
04:46:01 <earthy> in which case things can be specified more compactly
04:46:03 <earthy> but still
04:46:27 <Zeiris> mm_freak_: http://pastebin.org/475237 (it's actually a TSV, so you gotta check plain text.) It's described at the bottom of:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28934#a28934
04:47:56 <mm_freak_> ah, a table
04:48:09 <earthy> zeiris: actually, your code is more concise than the last attempt I made at something like this
04:48:35 <mm_freak_> Zeiris: and the header is not fixed?
04:50:14 <Zeiris> mm_freak_, well, it basically is, the odds of it changing are low enough to risk. However, being able to operate on columns out of order would be kind of neat, since it could let me factor out more structures than I am now.
04:50:38 <mm_freak_> well, i give you a hint on how i would solve it =)
04:50:52 <mm_freak_> getColumnParser :: Column a => ByteString -> Parser (Parser a)
04:52:14 <mm_freak_> or, sacrificing some genericity, you could even do this:
04:52:22 <mm_freak_> getColumnParser :: ByteString -> Parser (Parser Column)
04:52:28 <mm_freak_> a parser, which returns a parser
04:52:46 <mm_freak_> you get the idea (i hope) =)
04:54:21 <mm_freak_> sequence :: [Parser Column] -> Parser [Column]
05:04:40 --- mode: ChanServ set +o copumpkin
05:05:32 --- topic: set to '["Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by copumpkin
05:05:52 <tg_> copumpkin: that url is broken
05:05:58 <copumpkin> which?
05:06:06 <tg_> Logs: http://tunes.org/~nef/logs/haskell/"]
05:06:17 <copumpkin> works for me
05:06:20 <tg_> ok
05:06:24 * tg_ kicks his IRC client
05:06:33 <copumpkin> it must be taking the " too
05:06:41 <tg_> actually it took the ]
05:06:50 <copumpkin> not sure why we insist on pretending the URL is a haskell list, but ah well
05:07:02 --- mode: copumpkin set -o copumpkin
05:08:11 <quicksilver> copumpkin: what started as a joke ends up being tradition.
05:08:23 <copumpkin> :)
05:08:24 <aavogt> @uncons
05:08:24 <lambdabot> Unknown command, try @list
05:08:32 <quicksilver> copumpkin: (plenty of examples of that if you look around society as a whole)
05:08:49 <quicksilver> aavogt: it's @topic-uncocs, IIRC, but lambdabot doesn't have op privileges so it can't be used.
05:09:29 <aavogt> @help topic
05:09:29 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-init topic-null
05:10:17 <theorbtwo> Of course, somebody with ops could op lambdabot, and it'd presumably work.  I'm looking at you, companion_square.
05:10:54 <theorbtwo> s/ companion_square/ copumpkin/ -- sometimes tab completion can just make typos worse.
05:10:57 --- mode: ChanServ set +o quicksilver
05:10:59 <copumpkin> :)
05:11:04 --- mode: quicksilver set +o lambdabot
05:11:08 <quicksilver> @topic-tail
05:11:08 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
05:11:12 <quicksilver> heh
05:11:19 <quicksilver> probably I dont' know how to use it
05:11:22 <quicksilver> @topic-cons a
05:11:23 <lambdabot> I do not know the channel a
05:11:28 <quicksilver> @topic-cons #haskell a
05:11:28 --- topic: set to '["a","Haskell Platform 2010.2: http://is.gd/dCGPn","Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status","Haskell News: http://reddit.com/r/haskell","The Haskell programming language","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/"]' by lambdabot
05:11:28 --- topic: set to '["Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by ChanServ
05:11:28 --- mode: ChanServ set -o lambdabot
05:11:36 <quicksilver> haha.
05:11:43 <quicksilver> chanserv rocks.
05:11:45 --- mode: quicksilver set -o quicksilver
05:11:46 <theorbtwo> ...or not.
05:11:48 <copumpkin> :O
05:11:49 * theorbtwo laughs.
05:12:09 <quicksilver> in fact, probably, one can use chanserv to give lambdabot permission to change topics but nothing else
05:12:16 <quicksilver> i.e. not kick or ban etc.
05:12:24 <quicksilver> but still that effectively means anyone can change the topic, then.
05:12:37 <theorbtwo> I'm not sure that's a big deal.
05:13:07 <hpc> it works in blah
05:13:13 <quicksilver> it would be annoying if a spammer changed the topic and people didn't notice for a while
05:13:16 <copumpkin> blah doesn't get trolled
05:13:32 <copumpkin> I still think we'd get trolled a lot less in here if the channel were +s
05:13:36 <quicksilver> this channel gets targetted quite a lot because it's so big.
05:13:50 <quicksilver> I think people didn't want it to be +s although I don't know which people or why or when 
05:14:10 <copumpkin> conceptually it's weird for it to be "secret"
05:14:23 <copumpkin> but it just means we won't show up on /list or online listings, and we don't want people coming to us from there anyway
05:14:30 <copumpkin> cause it's usually people saying "u teach me hax?"
05:14:41 <copumpkin> or "I have java homework due in an hour and need help!!"
05:14:56 <quicksilver> so we teach them lambdahax!
05:15:02 <copumpkin> :P
05:15:04 <hpc> i don't mind having those people join, just so we can guilt-trip them :D
05:15:34 <theorbtwo> I certianly don't see many of those people joining.
05:15:45 <theorbtwo> Might be time of day or selective reading, though.
05:16:13 <hpc> the closest i have seen is the prime generator homework guy yesterday
05:20:20 <merijn> copumpkin: I use /list a lot for projects/languages I'm not sure have a FreeNode channel. So being hidden from that would be annoying. (In this case I already happen to know #haskell, but in general for channels. And I don't believe I'm the only person)
05:20:38 <copumpkin> merijn: it isn't too hard to guess the name of this one though :)
05:20:46 <copumpkin> even if you guess, #ghc, the topic tells you to come to #haskell :)
05:21:52 <merijn> True, but I think a more effective anti spammer technique would be to disallow unregistered users from joining or allowing unregistered users to join but have them muted. Both are possible flags on freenode, so...
05:22:35 <quicksilver> yes, but that's also quite strongly anti-newbie
05:22:54 <quicksilver> we were registered-for-voice a bit when freenode was in a particular bad spam phase a few months back
05:23:09 <quicksilver> but otherwise the policy is to actively welcome newbies - even/especially those who are also new to IRC.
05:24:07 <merijn> I guess, doesn't appear to be much of a problem in some other big channels, though
05:27:52 * Zeiris wants more opportunities to answer do-my-homework requests with obfuscated, malicious, or misleading code.
05:29:43 <zygoloid> Zeiris: halp i needs a funtion to find wethar a string is a palandrom!
05:30:18 <ketil> What is 'normalizeTimeDiff' supposed to do?  I expected all values to be positive, but I find that is not the case.
05:33:18 <zygoloid> > nubBy (((0==).).mod) [2..]
05:33:19 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:33:21 <Zeiris> mm_freak_, I think the simplest solution is to separate file parsing from field parsing somehow. Right now Parser doesn't know about columns: tagging the lowest-level Parsers with column names, pushing them up as parsers are combined, then using them to re-order the columns in the file (not a pretty process with a [[Field]], but oh well it's only done once) is probably the best route.
05:33:46 <mm_freak_> Zeiris: why?  have you understood my solution?
05:34:32 <Zeiris> Not at all - the current Parser doesn't know about columns, it works with individual rows.
05:34:42 <mm_freak_> do parsers <- many1 (word >>= getColumnParser)
05:34:52 <mm_freak_>    let parseRow = sequence parsers
05:35:12 <mm_freak_> you just write the getColumnParser function, which converts a header word into a parser
05:35:29 <mm_freak_> getColumnParser "int" = Column <$> parseInt
05:35:34 <mm_freak_> getColumnParser "name" = Column <$> parseWord
05:35:39 <mm_freak_> uhm
05:35:42 <mm_freak_> getColumnParser "int" = IntColumn <$> parseInt
05:35:46 <mm_freak_> getColumnParser "name" = NameColumn <$> parseWord
05:35:48 <mm_freak_> etc.
05:37:33 <Zeiris> Wouldn't that require lines like that for every column?
05:40:03 <earthy> nope.
05:40:22 <earthy> if you can generate the types from the names of the columns
05:40:53 <earthy> you could then take the first line, and do getColumnParser on the elements of that line
05:41:15 <earthy> (note however that that's a big if ;))
05:44:16 <aavogt> earthy: haskell has dependent types?
05:45:14 <mm_freak_> Zeiris: of course you need to write a parser for each possible type of column
05:45:31 <ketil> Oh - possibly, this is just because although picoseconds are defined in the data structures, none of the *functions* actually care about them. 
05:45:46 <copumpkin> omg dependent types
05:45:55 <kmc> -XDependentTypes
05:46:02 <copumpkin> lol
05:46:03 <kmc> -XPony
05:46:11 <ketil> Problem solved: use Data.Time, and flush System.Time down the toilet where it belongs.  Mental fertilizer, at best.
05:46:20 <aavogt> well how else can you generate types from from the names of the columns?
05:46:31 <copumpkin> statically?
05:46:42 <copumpkin> in TH, against a fixed db?
05:46:43 <mm_freak_> aavogt: i think he meant "parsers" where he said "types" =)
05:46:45 <aavogt> you don't know the names?
05:46:57 <aavogt> ah yes. TH
05:47:08 <aavogt> you get that with haskelldb
05:47:23 <kmc> personally i don't mind pointing clueless irc beginerrs towards more appropriate channels
05:47:28 <kmc> as long as it doesn't happen too often
05:47:49 <aavogt> mm_freak_: I prefer thingy
05:49:32 <cjs> Hullo there! Long time no see.
05:50:51 <cjs> So I'm writing up some Haddock module header comments for a module to go into hackage. (Module:, Copyright:, License:, etc. etc.) Is there a reference for what I should be using for lines such as "Stability:"?
05:51:53 <aavogt> cjs: I find the author's stated stability field to be completetly unreliable
05:52:49 <aavogt> since people rarely go back and change it from experimental years after it has stopped changing
05:52:55 <cjs> Mmm. And I am a completely unreliable person, so square that. Yet I'd like to choose from a list of meaningless words rather than create my own.
05:53:16 <cjs> Perhaps they're just experimenting very slowly. :-)
05:53:45 <sm> I usually assume the options are: alpha, beta, stable, mature
05:54:13 <cjs> At any rate, it would at least let me indicate which parts of the API are relatively more or less stable than others.
05:54:21 <sm> s/mature/some word conveying "unmaintained"/
05:54:36 <cjs> sm: :-)
05:55:30 <cjs> It's been so long; does the "{-# LANGUAGE CPP ..." have to be before any other comments in the file?
05:55:58 <fasta> cjs, yes
05:58:56 <cjs> Ah, so I'm not so rusty as I'd thought.
05:59:58 <cjs> Is "Stability: somewhat" acceptable?
06:00:51 <alip> does haskell have anything akin to python & ruby's NotImplementedError? I'm writing a binding and the binding only defines some functions on Linux not FreeBSD so on FreeBSD i want the function to raise some Exception like that...
06:01:06 <fasta> cjs, everything that works is accepted. 
06:01:34 <fasta> cjs, it is just that you have to consider whether you want people emailing you "why did you remove X?".
06:02:38 <Axman6> alip: error "foo: Not implemented"
06:02:56 <mm_freak_> alip: or define your own exception type
06:03:11 <alip> ok, just wondered if there was anything predefined :)
06:03:25 <Axman6> you could easily define it :)
06:04:46 <cjs> fasta: That's always easy for me to answer: "Because the guy who added that to the API was a moron."
06:05:10 <cjs> (Well, it's easy to answer when I'm the one that added it.)
06:05:26 <azaq23> alip: You could also use the "undefined" value - throws an exception if it accessed. Of course, only if you need really as abrupt as NotImplementedError(), which obviously has a very specific purpose
06:05:56 <azaq23> > let f x = x + 5 in f undefined
06:05:57 <lambdabot>   *Exception: Prelude.undefined
06:06:07 <fasta> cjs, unless you are providing commercial support, API stability can basically be ignored. 
06:06:14 <fasta> cjs, look at the chart package for proof.
06:06:23 <alip> azaq23: thanks :)
06:06:34 <azaq23> alip: But I'm not sure whether that's recommended...
06:06:40 <azaq23> seems so, though
06:07:02 <fasta> cjs, they basically broke the interface a couple of times, yet if there is something really interesting, you can port it quite easily to use the newer version. 
06:07:13 <fasta> cjs, otherwise you just depend on the older package.
06:09:25 <cjs> fasta: I don't take API stability declarations seriously, myself. I try to stay always in a state where I can deal with the changes. And I prefer changes if it fixes stuff. (Even to the degree that I'd go for MonadZero or whatever it is.) But heck, if I'm going to fill in a field, I might as well do a half-assed job. Maybe that's just a hangover from my Java days.
06:10:35 <fasta> cjs, to be realistic you could say simply but a sentence there, or otherwise at the top of the module stating your intentions. 
06:10:42 <kmc> alip, GHC lets you set deprecation warnings also
06:10:48 <kmc> which would show at compile time
06:11:13 <alip> kmc: deprecating warning isn't what i'm looking for... as the function is only implemented for certain architectures/OS'es
06:11:24 <alip> and for other it just doesn't work
06:13:05 <drhodes> :t liftNew
06:13:06 <lambdabot> Not in scope: `liftNew'
06:13:20 <alip> what's the reason of this compilation error http://paste.pocoo.org/raw/249328/ ? i can share the code if need eb
06:13:23 <alip> *be
06:16:50 <cjs> fasta: Hm. But nobody seems to do just that.
06:17:25 <fasta> cjs, since when do you care about other people? ;)
06:19:57 <Zeiris> The code "slope::a->a->a->Double; slope n top btm = fromIntegral (n-top) / fromIntegral (btm-top)" requires an Integral constraint on a. It seems like it should be workable with a Num constraint - but how?
06:20:21 <hpc> :t (/)
06:20:22 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:20:30 <hpc> take out fromIntegral
06:20:30 <cjs> fasta: Good point!
06:20:57 <hpc> that generalizes it to Fractional, at least
06:21:09 <fasta> cjs, thanks!
06:21:15 <hpc> :t fromIntegral
06:21:16 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:21:29 <hpc> :t round
06:21:30 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:21:48 <hpc> not sure if you can generalize it all the way to Num though
06:22:28 * hackagebot vacuum-ubigraph 0.2.0.2 - Visualize Haskell data structures using vacuum and Ubigraph  http://hackage.haskell.org/package/vacuum-ubigraph-0.2.0.2 (GlebAlexeyev)
06:22:34 <Zeiris> It seems sane. Sure, some integers might lose precision when turned to a Double, but most should work...
06:22:56 <Zeiris> I hope the troubles with Haskell's numeric typeclasses don't prevent this :\
06:23:22 <Axman6> integers > than 2^24 will almost certainly lose precision
06:23:41 <Axman6> loose*
06:24:23 <hpc> loose = not taught, lose = not have posession of
06:24:32 <hpc> *possession
06:24:39 <Zeiris> @hoogle (Integral a, RealFrac b) => a -> b
06:24:40 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
06:24:40 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
06:24:40 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:24:49 <winxordie> Axman6: I thought ints get 30 bits of precision?
06:24:57 <cjs> Ooo, that could be a new Star Trek episode: "The Trouble with Typeclasses."
06:25:01 <Zao> winxordie: Including sign.
06:25:02 <Zao> Or so.
06:25:10 <hpc> winxordie: double doesn't
06:25:16 <bss03> Axman6: I found double to have approximately 53 bits of accuracy, not only 24.
06:25:18 <hpc> and that's what your fromIntegral converts to
06:25:24 <winxordie> alrighty
06:25:30 <bss03> Axman6: Float only had 24 or so.
06:25:45 <Axman6> bss03: oh yes, right
06:25:47 <Axman6> anyway
06:26:02 <drhodes> Axman6: http://axman6.homeip.net/blog/2009/01/st-monad-examples.html   the syntax highlighter ate the backslashes in your tute :O
06:26:09 <Axman6> hpc: yeah... neither of them looked right :(
06:26:28 <Axman6> oh? hmm, i'll have a look
06:26:34 <drhodes> the comments are indented one less,
06:26:59 <hpc> Axman6: no worries; i think you will find that very few people know any language adequately :P
06:27:22 <Axman6> yeah, i've only been using english for about 18 years, i'm still a noob
06:27:24 <hpc> i still can't spell probability without spell check
06:27:43 <Zeiris> Feh, I might as well Doubles for everything.
06:28:00 <Axman6> drhodes: tried my new blog? that one's been replaced by axman6.com/blog/
06:28:22 <drhodes> ok Axman6 I'll check it out
06:39:21 <harlekin> Is fieldtrip no longer maintained? It is reported not to build with ghc 6.10 and 6.12.
06:40:13 <EvanR-work> double has exactly 53 bits of accuracy ;) (ieee doubles)
06:40:43 <Axman6> well, 54 actually
06:41:08 <EvanR-work> whats this about haskells numbers losing precision? O_o
06:41:38 <zygoloid> Axman6: yeah, we mustn't forget the implicit leading 1 :)
06:46:18 <dpratt71> Am I explaining this well/correctly? http://stackoverflow.com/questions/3467279/how-to-create-a-haskell-function-with-arbitrary-parameter-count/3468290#3468290
06:48:17 <Cale> dpratt71: yeah, that seems right
06:50:14 <dpratt71> Cale: cool, thanks
06:50:40 <roconnor> it's a lot easier to do if you get to use a terminator for the arguments
06:50:45 <roconnor> @quote stack-calculator
06:50:45 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
06:51:55 <Axman6> :o
06:52:32 <roconnor> I don't quite get why the stack-overflow questioner doesn't use a list
06:53:08 <Cale> I don't either
06:53:34 <Cale> I also don't really understand why people use stackoverflow and not the mailing lists or IRC.
06:53:49 <sajkr> @src gcd
06:53:49 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
06:53:49 <lambdabot> gcd x y = gcd' (abs x) (abs y)
06:53:49 <lambdabot>    where gcd' a 0  =  a
06:53:49 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
06:54:04 <roconnor> In fact, a Kleisli function for the Maybe monad is an even better choice than an accociation list
06:54:06 <Axman6> i hate mailing lists, i'd much rather use SO
06:54:12 <Cale> Every time I see the source for gcd, I'm annoyed by that special case for 0 0
06:54:31 <roconnor> Cale: It's so hard to change for some reason.
06:54:43 <roconnor> I don't understand what the opposition is thinking
06:54:47 <Axman6> > rem 0 0
06:54:47 <lambdabot>   *Exception: divide by zero
06:55:25 <roconnor> rem n 0 and mod n 0 should both be n.
06:55:32 <roconnor> well at least mod n 0 should be n
06:55:36 <roconnor> I'd have to think about rem
06:56:12 <dpratt71> Cale: yeah, also not sure why question asker can't use a list, which begs the question: why doesn't 'printf'?
06:56:18 <Axman6> rem should be the remainder when you do the division, which involves a division by zero in that case...
06:57:14 <Cale> dpratt71: Because the parameters to printf might have different types.
06:57:43 <Ferdirand> you shoud have n == (rem n d) + d*q, for some value of q
06:57:48 <Cale> dpratt71: Of course, it would be easy enough to just create a datatype for that purpose, but it's syntactically slightly more awkward.
06:57:51 <dpratt71> Cale: ah
06:58:00 <dpratt71> Cale: makes sense
06:58:01 <Ferdirand> so it makes sense that rem n 0 == n for d = 0
06:58:29 <roconnor> Ferdirand: indeed
06:59:39 <absentia> re
07:16:35 <harlekin> @pl \t1 t2 -> t1 - t2
07:16:35 <lambdabot> (-)
07:16:43 <harlekin> @pl \t1 t2 -> 1 / (t1 - t2)
07:16:43 <lambdabot> ((1 /) .) . (-)
07:17:39 <EvanR-work> > (((1 /) .) . (-)) 9 4
07:17:40 <lambdabot>   0.2
07:19:48 <bss03> To do "lazy IO" I have to use unsafeInterleaveIO, right?
07:20:32 <bss03> E.g. to write something that is FilePath -> IO [FilePath] where the array is incrementally built, I need unsafeInterleaveIO, yes?
07:20:50 <EvanR-work> you can also use hGetContents
07:20:51 <Jafet> Well, you can also use readFile or any other thing that secretly uses unsafeInterleaveIO
07:21:07 <EvanR-work> or not so secret ;)
07:21:58 <bss03> hGetContents is not what I need.  I'm hoping to lazily walk a directory tree, calling stat() on each file, and collecting the results in a Data.Map.Map.
07:22:14 <bss03> (Eventually.)
07:22:25 <mornfall> bss03: You can interleave IO yes. But it's going to bite you sooner or later.
07:22:44 <mornfall> Are you so short on memory that you can't hold a directory tree with stat results?
07:22:47 <EvanR-work> seems like constructing a map will be rather strict
07:23:04 <mornfall> EvanR-work: Actually, Data.Map is pretty lazy.
07:23:14 <mornfall> Sometimes even too lazy. :)
07:23:20 <bss03> EvanR: Yeah, that's probably going to make it not-lazy anyway.
07:23:28 <EvanR-work> how does it know if the request element is there without going through the entire directory tree
07:23:40 <EvanR-work> or some of it
07:23:43 <bss03> EvanR: Since some parts of the stat() data are part of the keys.
07:24:20 <mornfall> I don't think it makes any sense at all, anyway.
07:24:38 <mornfall> Unless you want to stat the entire filesystem or something.
07:24:51 <EvanR-work> thats the use case id image for it ;)
07:24:59 <EvanR-work> imagine
07:25:03 <bss03> Still, assume I wanted to write something that did (find . -type f | head -n 40) where "40" is a run-time variable very efficiently.
07:25:06 <EvanR-work> very large fs
07:25:27 <mornfall> bss03: Just limit the walking.
07:25:29 <bss03> I wouldn't necessarily want to walk the multi-TB tree just for the first few elements.
07:25:53 <mornfall> That it's Haskell doesn't mean that a lazy list is answer to everything.
07:25:56 <mornfall> Especially in IO land.
07:26:20 <EvanR-work> blasphemy, lazy everything!
07:27:02 <mornfall> Hush.
07:27:02 <bss03> Lazy evaluation always results in fewer evaulation steps, though.
07:27:16 <mornfall> bss03: What's an evaluation step in IO?
07:27:23 <bss03> Everything lazy until I can prove a performance increase my making things strict, right.
07:27:33 <mornfall> That's BS.
07:27:46 <EvanR-work> i wasnt serious
07:27:48 <mornfall> Lazy IO is impure.
07:28:00 <mornfall> EvanR-work: That was to bss03. :)
07:28:26 <EvanR-work> but yeah a lot of nice abstractions are not possible since you cant ideally make a Stream of data from IO land
07:28:34 <mornfall> It's *unsafe*InterleaveIO for a reason.
07:28:56 <EvanR-work> according to previous remarks, usafeInterleaveIO isnt unsafe
07:28:59 <mornfall> EvanR-work: Stream is actually possible. List isn't.
07:29:14 <mornfall> Which remarks?
07:29:17 <Jafet> safeIfUsedAsPrescribed
07:29:29 <EvanR-work> it cant be used to screw the type system
07:29:30 <mornfall> Jafet: You can say that about anything.
07:30:01 <Jafet> Dick did
07:30:03 <Saizan> technically it's not, because you can just blame IO for the concurrency and magic scheduling, though like concurrency in general it's hard deal with.
07:30:37 <mornfall> EvanR-work: It can be however (very successfully) to screw the program. :)
07:30:41 <mornfall> +used
07:30:41 <bss03> I'm fine streaming the data.  I don't need to read any list element multiple times.
07:31:05 <mornfall> You can iteratee, then, presumably.
07:31:12 <mornfall> Or however is it called nowadays.
07:31:20 <Zeiris> Ambiguous type question! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28937
07:31:22 <mornfall> Probably not as elegant...
07:31:25 <Jafet> In this case, there might not really be any difference stating lazily or up front
07:31:39 <Jafet> The results are bound to be inconsistent somewhere regardless
07:32:03 <mornfall> Zeiris: Would help to see membership's type.
07:32:31 <Zeiris> membership :: Fuzz f => [(f,Double)]
07:32:41 <copumpkin> fuzz!
07:32:46 <Zeiris> It's... A typeclass function.
07:32:49 <copumpkin> membership type! subobject classifier?
07:33:08 <aavogt> when you map snd it, nobody knows which f to use
07:33:19 <Zeiris> Yep. Am I doomed?
07:33:24 <mornfall> Zeiris: ScopedTypeVariables
07:33:40 <aavogt> you could make it pick the same f as the argument to defuzzify
07:33:42 <mornfall> You should be able to fix it to f from your type signature of the fun.
07:33:59 <mornfall> (of defuzzify... assuming that's what you want)
07:34:43 <Zeiris> I've tried sticking "`const` ms" at the end of that, but it just complained about f1 and f2 not working or somewhat.
07:34:57 <EvanR-work> how is membership :: Fuzz f => [(f,Double)] a function
07:35:07 <mornfall> EvanR-work: It's a list.
07:35:09 <mornfall> :))
07:35:13 <aavogt> Zeiris: asTypeOf is probably what you're looking for instead of const
07:35:18 <EvanR-work> yeah so it can be any Fuzz one wants
07:35:29 <mornfall> Which he needs to fix, yes.
07:35:36 <mornfall> asTypeOf should work too
07:35:42 <Zeiris> Excellent, that should do it.
07:36:53 <danishkirel> Hi. Given this: http://gist.github.com/521058 can I read the String from the outer Reader from inside the inner Reader?
07:37:05 <EvanR-work> so if you use it in the right context, it should generate some constant list of (t,Double), where t is determined by the top level type sig?
07:37:25 <zygoloid> Zeiris: m :: [Double] should do it.
07:37:32 <EvanR-work> kind of like mempty
07:37:46 <copumpkin> what's membership do?
07:37:46 <zygoloid> actually, no, that's not true ;(
07:38:05 <Zeiris> Yeah.
07:38:20 <Zeiris> copumpkin, membership function for fuzzy logic thingamabob.
07:38:34 <EvanR-work> its not a function
07:38:37 <aavogt> warm fuzzy logic =)
07:38:39 <zygoloid> membership `asTypeOf` zip ms []
07:38:51 <EvanR-work> or is this fuzzy logic terminology
07:39:03 <copumpkin> Zeiris: seen http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9423 ?
07:39:22 <copumpkin> when in doubt, just use topoi
07:39:23 <roconnor> @type maybeM
07:39:24 <lambdabot> Not in scope: `maybeM'
07:40:32 <Zeiris> copumpkin, that goes way over my head :p
07:40:36 <quicksilver> danishkirel: your action 'inner' is not running in an environment in which there *is* an outer reader
07:40:50 <quicksilver> danishkirel: consider that that 'inner' could equally be run elsewhere
07:41:04 <zygoloid> looks like you actually want membership :: [(forall f. Fuzzy f => f, Double)] (that is, the Double doesn't depend on the type f.
07:41:25 <zygoloid> that extension is deprecated though :(
07:41:32 <quicksilver> danishkirel: however, you can always run 'ask' in the outer, to give the outer environment a name
07:41:33 <copumpkin> zygoloid: you can make your own wrapper type, though :P
07:41:40 <aavogt> zygoloid: I'm not sure that extension does the right thing anyways
07:41:41 <quicksilver> danishkirel: and just pass that as a parameter
07:41:59 <quicksilver> oh that is so lame?
07:42:12 <aavogt> zygoloid: or just have separate   Fuzzy f => [f]  and   [Double]  methods
07:42:12 <quicksilver> github requires an account to fork?
07:42:13 <quicksilver> bah
07:42:16 <quicksilver> github--
07:42:16 <Zeiris> Using a typeclass to define memberships is probably only temporary anyway, since it doesn't let me adjust memberships at runtime (for optimizing/learning better ones)
07:42:45 <bss03> quicksilver: Depends on what you mean by fork.
07:42:46 <aavogt> hmm, though that means the [Double] is just a constant?
07:42:55 <roconnor> deliminated continuations confuse me
07:43:08 <bss03> quicksilver: You can git-clone anything there to wherever you want.
07:43:12 <geheimdienst> quicksilver, why not just check out the code and hack on it locally?
07:43:28 <quicksilver> danishkirel: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28938#a28938
07:43:38 <quicksilver> bss03: I mean forking its paste service
07:43:51 <quicksilver> bss03: as it, annotating someone elses paste.
07:44:02 <quicksilver> geheimdienst: it's only a paste. I just wanted to paste it back to danishkirel.
07:44:04 <danishkirel> quicksilver: Thanks for the clarification. I am trying to do web dev with haskell and the actions run in some monad whre I can 'ask' for the request. I am trying to sneak some shared state in (a TVar) but I fail so far
07:44:09 <bss03> quicksilver: Ah, I don't use their paste service.
07:44:16 <quicksilver> danishkirel: did that paste help?
07:44:34 <geheimdienst> okay i see
07:44:54 <danishkirel> quicksilver: It did help to confirm my assumptions.
07:48:17 <harlekin> I am finally able to give reactive a try, but I am running into troubles very soon: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28939#a28939. Why does this program consume all my memory after a few seconds?
07:48:38 <harlekin> I am trying to go through the FPS fieldtrip tutorial without using fieldtrip. (:
07:49:59 <quicksilver> harlekin: does the FPS display as expected?
07:50:31 <harlekin> quicksilver, it display's 0.0 once on the stdout. I kind of expected that since I didn't think about scaling the font, rendering something else, etc.
07:50:46 <harlekin> *displays
07:51:12 <quicksilver> on stdout? not rendered by FTGL?
07:51:28 <vishnoooo> hi, I have a problem with failures: I'm using the Data.Object.Yaml module but I can't get any string error message from it, only 'Nothing' as the ParseException type is not exported. I don't grok Failure enough to know what I could do; anyone could help ?
07:51:30 <quicksilver> ah, you have a putStrLn also
07:51:38 <quicksilver> didn't see that.
07:51:56 <quicksilver> so it's like only one frame is working. Not sure :(
07:56:26 <byorgey> Does anyone know if Rob Greayer hangs out here?
07:56:31 <tafryn> How do you express "ABC" * 3 in haskell?
07:57:11 <byorgey> > replicate 3 "ABC"  -- you mean like this?
07:57:12 <lambdabot>   ["ABC","ABC","ABC"]
07:57:24 <byorgey> or maybe with a concat if you want them all in the same string
07:57:28 <tafryn> Not quite. I'm trying to get something like "ABCABCABC"
07:57:49 <byorgey> > concat $ replicate 3 "ABC"  -- okay, like this then
07:57:49 <lambdabot>   "ABCABCABC"
07:58:06 <tafryn> Thanks.
07:58:21 <Axman6> tafryn: "ABC" * 3 is a very illconceived idea
07:58:32 <harlekin> @seen ksf
07:58:33 <lambdabot> Unknown command, try @list
07:58:33 <preflex>  ksf was last seen on #haskell 22 hours, 34 minutes and 49 seconds ago, saying: ...and why haskell doesn't need the former to get the former.
07:58:41 <byorgey> it's not an illconceived idea, just illconceived syntax.
07:58:43 <EvanR-work> 'this is haskell, other languages syntactic sugar is wrong' ;)
07:59:11 <tafryn> Axman6: Yeah, buffering out output is a pain.
07:59:20 <quicksilver> > [(),(),()]>>=(\_->"ABC")
07:59:21 <lambdabot>   "ABCABCABC"
07:59:24 <quicksilver> byorgey: ^^ ;)
07:59:31 <byorgey> nice =)
07:59:38 <quicksilver> put it in a rocketship with 3 engines
07:59:41 <quicksilver> that's the key.
07:59:47 <Axman6> > replicate 3 undefined >> "ABC"
07:59:48 <lambdabot>   "ABCABCABC"
07:59:57 <byorgey> > "ABC">>=(\_->"ABC")
07:59:58 <quicksilver> > [(),(),()]>>"ABC"
07:59:58 <lambdabot>   "ABCABCABC"
07:59:59 <lambdabot>   "ABCABCABC"
08:00:08 <quicksilver> > [[],[],[]]>>"ABC"
08:00:09 <lambdabot>   "ABCABCABC"
08:00:22 <byorgey> > "ABC">>"ABC"
08:00:22 <lambdabot>   "ABCABCABC"
08:00:33 <quicksilver> > []:[]:[]:[]>>"ABC"
08:00:34 <lambdabot>   "ABCABCABC"
08:00:37 <danharaj> > replicate 3 undefined >> "123"
08:00:38 <lambdabot>   "123123123"
08:00:47 <danharaj> ABC. Easy as 123
08:00:54 <byorgey> hahaha, []:[]:[]:[] is my favorite I think =)
08:01:20 <medfly> :t (>>)
08:01:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:01:31 <zygoloid> EvanR-work: couldn't match expected type a -> b against inferred type Name in expression 'this is haskell
08:02:24 <quicksilver> > [a,b,c]>>"ABC"
08:02:25 <lambdabot>   "ABCABCABC"
08:02:28 <EvanR-work> zygoloid: o_O
08:05:41 <kmc> > "ABC" >> "ABC"
08:05:41 <lambdabot>   "ABCABCABC"
08:05:56 <kmc> > words "any three things" >> "ABC"
08:05:57 <lambdabot>   "ABCABCABC"
08:06:24 <bss03> > let { (<*>) :: Integral b => [a] -> b -> [a]; l <*> n = concat $ genericReplicate l; } in "ABC" <*> 3
08:06:25 <lambdabot>   Couldn't match expected type `[[a]]'
08:06:25 <lambdabot>         against inferred type `a1 -> [...
08:06:38 <bss03> > let { (<*>) :: Integral b => [a] -> b -> [a]; l <*> n = concat $ genericReplicate n l; } in "ABC" <*> 3
08:06:39 <lambdabot>   "ABCABCABC"
08:07:12 <EvanR-work> one of those wacky conventional languages uses x or X to mean string concat replicate
08:07:18 <tafryn> Wow. See, this is why I love this channel.
08:08:02 <bss03> EvanR: I like the ones where "%" is basically printf.
08:08:04 <zygoloid> > [c | _ <- [1..3], c <- "ABC"]
08:08:05 <lambdabot>   "ABCABCABC"
08:11:05 <harlekin> How can I pair Behaviors in reactive?
08:11:25 <fryguybob> > let as <*> n = take (n * length as) (cycle as) in "ABC" <*> 3
08:11:25 <lambdabot>   "ABCABCABC"
08:12:18 <mux> > let as <*> n = concat $ replicate n as in "ABC" <*> 3
08:12:19 <lambdabot>   "ABCABCABC"
08:13:14 <zygoloid> harlekin: well, Behaviour is an Applicative, so (,) <$> b1 <*> b2 should do the job
08:14:49 <EvanR-work> bss03: yeah, they that almost would work in haskell
08:14:54 <EvanR-work> hey*
08:15:07 <EvanR-work> except % is conventional for fractions
08:15:34 <harlekin> zygoloid, doesn't b1 <*> b2 imply that b1 is of type Behavior (a -> b) and b2 is of type Behavior a?
08:15:57 <EvanR-work> Text.Printf accepts a surprising few data fypes
08:16:00 <zygoloid> harlekin: no, <$> and <*> are left-associative.
08:16:13 <harlekin> zygoloid, I see. Thanks. (:
08:16:22 <bss03> EvanR: So use <%> or the like.
08:16:36 <EvanR-work> boring
08:16:58 <EvanR-work> *snowman*%*swastika*
08:17:10 <bss03> EvanR: Yeah, Text.Printf is interesting.
08:17:49 <EvanR-work> a giant hack if i ever saws one ;)
08:19:53 <bss03> > let (<%>) = Text.Printf.printf in "%s, %s!" % "Hello" "World"
08:19:54 <lambdabot>   Couldn't match expected type `t -> [GHC.Types.Char]'
08:19:54 <lambdabot>         against inferr...
08:20:27 <kmc> harlekin, if you prefer liftA2 (,)
08:20:30 <kmc> :t liftA2 (,)
08:20:31 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
08:20:52 <bss03> > let  str <%> arg1 = Text.Printf.printf str arg1 in "%s, %s!" % "Hello" "World"
08:20:53 <lambdabot>   Couldn't match expected type `t -> [GHC.Types.Char]'
08:20:53 <lambdabot>         against inferr...
08:21:23 <EvanR-work> > Text.Printf.printf "abc"
08:21:24 <lambdabot>   Ambiguous type variable `r' in the constraints:
08:21:24 <lambdabot>    `Text.Printf.PrintfType ...
08:21:30 <EvanR-work> > Text.Printf.printf "abc" :: String
08:21:31 <lambdabot>   "abc"
08:21:51 <bss03> > let (<%>) = Text.Printf.printf in "%s, %s!" % "Hello" "World" :: String
08:21:52 <lambdabot>   Couldn't match expected type `t -> [GHC.Types.Char]'
08:21:52 <lambdabot>         against inferr...
08:21:54 <EvanR-work> its either a String or an IO () xD
08:22:20 <bss03> > Text.Printf.printf "%s, %s!" "Hello" "World" :: String
08:22:21 <lambdabot>   "Hello, World!"
08:22:25 <EvanR-work> bss03: you didnt put <%>
08:22:29 <Ferdirand> @hoogle Monoid m => Int -> m -> m
08:22:30 <lambdabot> Text.Regex.Base.RegexLike after :: Extract source => Int -> source -> source
08:22:30 <lambdabot> Text.Regex.Base.RegexLike before :: Extract source => Int -> source -> source
08:22:30 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
08:22:32 <bss03> > let (<%>) = Text.Printf.printf in "%s, %s!" <%> "Hello" "World" :: String
08:22:33 <lambdabot>   Couldn't match expected type `t1 -> t'
08:22:33 <lambdabot>         against inferred type `[GHC....
08:23:09 <bss03> > let str <%> arg1 = Text.Printf.printf str arg1 in "%s, %s!" <%> "Hello" "World" :: String
08:23:09 <lambdabot>   Couldn't match expected type `t1 -> t'
08:23:10 <lambdabot>         against inferred type `[GHC....
08:23:11 <EvanR-work> Ferdirand: there you go, results totally irrelevant to monoids ;)
08:23:31 <Ferdirand> @type (mconcat .) . replicate
08:23:32 <lambdabot> forall a. (Monoid a) => Int -> a -> a
08:24:37 <Ferdirand> wouldn't that be a good candidate for a *-like operator ?
08:25:28 <bss03> > let <*> = (mconcat .) . replicate in 3 * "ABC"
08:25:29 <lambdabot>   <no location info>: parse error on input `<*>'
08:25:38 <bss03> > let (<*>) = (mconcat .) . replicate in 3 <*> "ABC"
08:25:39 <lambdabot>   "ABCABCABC"
08:27:11 <Ferdirand> a shame that ** is already taken
08:27:16 <Ferdirand> it would go nicely with ++
08:29:51 <EvanR-work> Ferdirand: except its not an operator between two lists
08:30:11 <EvanR-work> so it cant be commutative or associative
08:30:29 <Ferdirand> so ?
08:30:40 <EvanR-work> so it doesnt go nicely with ++ ;)
08:30:54 <Ferdirand> ** would be to ++ what * is to +
08:31:04 <Ferdirand> wouldn't it ?
08:31:10 <EvanR-work> how do you multiply to lists?
08:31:13 <EvanR-work> cartesian product?
08:31:37 <roconnor> l1 ** l2 = (,) <$> l1 <*> l2
08:31:42 <Ferdirand> no, repeated application of ++ a number of times
08:31:54 <Ferdirand> just like multiplication is repeated application of addition a number of times
08:31:57 <EvanR-work> that doesnt work in a lot of fields
08:32:16 <EvanR-work> Complex numbers
08:32:29 <Ferdirand> not that multiplication, right
08:33:33 <Ferdirand> but it is still something
08:33:43 <bss03> > 0 :+ 1 * 0 :+ 1
08:33:43 <lambdabot>   Precedence parsing error
08:33:44 <lambdabot>      cannot mix `Data.Complex.:+' [infix 6] and `D...
08:33:55 <EvanR-work> arent most + * and other operators of the form a -> a -> a
08:33:56 <bss03> > let i = 0 :+ 1 in i * i
08:33:57 <lambdabot>   (-1.0) :+ 0.0
08:33:58 <roconnor> l1 ** l2 = (,) <$> l1 <*> l2 = foldr (\a b -> (map (a,) l2) ++ b) [] l1
08:34:00 <EvanR-work> rather than a -> Int -> a
08:34:07 <copumpkin> EvanR-work: indeed
08:34:19 <EvanR-work> :t (<$>)
08:34:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:34:22 <Ferdirand> well, mappend is a -> a -> a
08:34:43 <roconnor> > let l1 ** l2 = foldr (\a b -> (map (a,) l2) ++ b) [] l1 in [1,2,3] ** [4,5,6]
08:34:45 <lambdabot>   <no location info>: parse error on input `)'
08:34:48 <EvanR-work> :t (<*>)
08:34:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:34:56 <EvanR-work> not these apparently ;)
08:35:02 <roconnor> > let l1 ** l2 = foldr (\a b -> (map ((,) a) l2) ++ b) [] l1 in [1,2,3] ** [4,5,6]
08:35:03 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
08:35:15 <harlekin> zygoloid, do you have an idea why I'm having a memory leak with the reactive FPS tutorial?
08:35:25 <roconnor> > let l1 ** l2 = (,) <$> l1 <*> l2 in [1,2,3] ** [4,5,6]
08:35:26 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
08:35:38 <opqdonut> > let l1 ** l2 = [(e1,e2) | e1 <- l1, e2 <- l2] in [1,2,3] ** [4,5,6]
08:35:39 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
08:36:01 <EvanR-work> is that half of the cartesian product?
08:36:02 <Ferdirand> why is it always about fields ? poor little groups, they can do stuff too
08:36:29 <opqdonut> EvanR-work: no, it's the complete one
08:36:38 <roconnor> groups can be turned into formal rings?
08:36:39 <EvanR-work> Ferdirand: ah, well wouldnt you use ^^ ;)
08:36:55 <EvanR-work> Ferdirand: group power, repeat group action by a integer number of times
08:37:08 <Ferdirand> EvanR-work: well yes, i'd prefer, but then mappend should be **
08:37:20 <EvanR-work> no?
08:37:22 <EvanR-work> additive group
08:37:27 <EvanR-work> ++
08:37:39 <opqdonut> if repeated operation is ^^, the operation is **
08:37:47 <Ferdirand> yes, additive group, but then shouldn't convention call for ** as the repetition ?
08:37:59 <opqdonut> of course one could have both AdditiveGroup and MultiplicativeGroup classes...
08:38:13 <opqdonut> (I'm kidding)
08:38:27 <EvanR-work> insane
08:39:26 <jmcarthur> i wouldn't kid about that
08:40:01 <EvanR-work> emotionally i see any operator like a -> Integral -> a as a power rather than a normal operator
08:40:04 <zygoloid> harlekin: no idea, sorry.
08:40:07 <jmcarthur> but clearly the correct thing to do is to have a Group class and have newtype wrappers for the different groups you can get from the same type
08:40:31 <Ferdirand> wouldn't that be the exact dual problem to the one that typeclasses solve ?
08:40:51 <Ferdirand> many sets of names for a single set of types
08:41:03 <Ferdirand> instead of a single set of names for many sets of operations
08:41:09 <EvanR-work> heh
08:41:16 <EvanR-work> Dual Class
08:41:21 <opqdonut> CoClass
08:41:35 <EvanR-work> i want to be a necromancer and a barbarian please
08:42:12 <Ferdirand> great, almost spilled my drink on my monitor
08:47:31 <Ferdirand> @type (..)
08:47:32 <lambdabot> parse error on input `..'
08:47:58 <Ferdirand> ah nah, this is taken by enumFromTo :(
08:49:16 <EvanR-work> :t (...)
08:49:17 <lambdabot> forall a b. (a -> b) -> a -> b
08:49:22 <EvanR-work> lol
08:49:37 <EvanR-work> > (...) = ($)
08:49:38 <lambdabot>   <no location info>: parse error on input `='
08:49:40 <EvanR-work> > (...) == ($)
08:49:40 <lambdabot>   *Exception: (==): No overloading for function
08:50:13 * hackagebot cmdlib 0.2 - a library for command line parsing & online help  http://hackage.haskell.org/package/cmdlib-0.2 (PetrRockai)
08:50:14 <EvanR-work> f . g . h ... x
08:50:36 <EvanR-work> literary haskell
08:51:15 <Ferdirand> (.) == fmap, right ?
08:51:29 <EvanR-work> crap
08:51:34 <EvanR-work> fcrap
08:52:16 <Ferdirand> could ($) == (.) in some identity functor ? or does it become a type inference nightmare after that ?
08:53:02 <EvanR-work> what i thought was ..., ((.) (.) (.)) is not as nice
08:53:45 <EvanR-work> :t (....)
08:53:46 <lambdabot> Not in scope: `....'
08:53:51 <EvanR-work> ah, specially defined
08:57:09 <harlekin> Does anyone know what the circumstances are for withPrevE introducing memory leaks?
08:57:34 <kmc> what's withPrevE?
08:57:42 <kmc> oh, Reactive?
08:58:06 <harlekin> Oh, yeah. I'm talking about the reactive library.
08:58:21 <mornfall> Can I pass the builddir to cabal(-install) in an envvar or something?
08:58:31 * mornfall would like to have the builds out of tree...
08:58:33 <harlekin> As soon as I use withPrevE, the program eats up all my memory.
08:59:20 <roconnor> biosimilarity write very strange haskell.
08:59:29 <roconnor> -- a simple test
08:59:31 <roconnor> generateTerms :: () -> [ClosedReflectiveTerm]
08:59:39 <roconnor> kinda MLish
09:01:09 <roconnor> Although I don't think this is implemented correctly, I like biosimilairity's idea of writing lambda calc data type where variable abstraction is defined a a derivative of the lambda calc data type
09:03:00 <roconnor> data LambdaCalc V = Var V | App LambdaCalc LambdaCalc | Abs (DerivLambdaCalc V)
09:04:40 <copumpkin> roconnor: pff, you should use Fin
09:04:41 <copumpkin> :P
09:06:52 <roconnor> copumpkin: I like the idea of solving differential equaitions to produce data types
09:07:20 <roconnor> f v = v + f v * f v + df/dv
09:08:30 <EvanR-work> f = ErrFunc (Ln Gamma) Zeta
09:08:42 <roconnor> EvanR-work: is that the solution? :D
09:08:45 <EvanR-work> lol
09:08:56 <EvanR-work> yeah right
09:09:01 <roconnor> I wouldn't be surprised if Zeta is a nice data type
09:10:04 <kmc> roconnor, to prevent it being a CAF that hangs around forever?
09:10:13 <kmc> i.e. to inhibit sharing
09:30:32 * hackagebot improve 0.0.5 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.0.5 (TomHawkins)
09:32:33 * hackagebot hofix-mtl 1.0 - defining @mtl@-ready monads as * -> * fixed-points  http://hackage.haskell.org/package/hofix-mtl-1.0 (NicolasFrisby)
09:33:28 <Saizan> roconnor: don't you get only one hole that way? what if the variable is used in multiple places?
09:50:18 * dolio has the same question as Saizan.
09:51:20 <aristid> dang, getTimeZone is in IO :/
09:51:33 <copumpkin> aristid: why wouldn't it be?
09:51:47 <kmc> aristid, http://hackage.haskell.org/package/acme-now
09:51:54 <copumpkin> lol
09:52:04 * kmc has used acme-now in a "serious" program
09:52:07 <aristid> copumpkin: oh, it has to, i guess, but i think i have to make my function be in IO to, due to that
09:52:19 <copumpkin> aristid: or have your function take the timezone as input
09:52:22 <kmc> aristid, it's the sort of thing you'd probably be justified to use unsafePerformIO on
09:52:28 <copumpkin> eugh
09:52:40 <byorgey> assuming you never run your program while in an airplane
09:52:40 <geheimdienst> what if the timezone changes while your program runs?
09:53:07 <geheimdienst> like daylight savings comes into effect while you're running
09:53:16 <aristid> kmc: because getTimeZone is quasi-pure
09:53:24 <aristid> copumpkin: getTimeZone takes a timezone too
09:53:28 <aristid> uh
09:53:31 <aristid> a UTC time
09:53:50 <geheimdienst> wait what
09:55:02 <aristid> getTimeZone $ UTCTime (ModifiedJulianDay 0) 0
09:55:02 <aristid> CET
09:55:16 * geheimdienst now agrees that getTimeZone shouldn't be in IO. it just tells you the TimeZone for a given UTCTime
09:55:30 <aristid> and in the current locale
09:55:42 <aristid> i guess i'd also like it to have a locale parameter or some such
09:56:19 <geheimdienst> a UTCTime is like a unix epoch, right?
09:56:58 <aristid> similar
09:57:04 <aristid> with 1858 as the base year
09:57:11 <aristid> UTCTime (ModifiedJulianDay 0) 0
09:57:11 <aristid> 1858-11-17 00:00:00 UTC
09:57:14 <greap> kmc: That acme-now is hillarious. What kind of 'serious' project did you use it in?
09:57:38 <geheimdienst> i once tried to get haskell to output a date in the locale-specific way, but i didn't manage to do it. stackoverflow and #haskell didn't know either. guess it's just not possible
09:57:54 <geheimdienst> (i mean, like saying the locale-specific thing for "Thursday" and so on)
09:58:15 <arw> greap: i can imagine that testing stuff is a valid reason
09:58:39 <aristid> what i'm trying to do is actually.. i want to add DiffTime to a LocalTime
09:59:09 <aristid> and i... maybe i should ignore DST?
09:59:34 <greap> Is there a reason why the source directory is called scr rather than src? Some kind of in-joke?
10:01:01 <geheimdienst> > getZonedTime
10:01:02 <lambdabot>   Not in scope: `getZonedTime'
10:02:01 <aristid> getZonedTime = do
10:02:01 <aristid> 	t <- getCurrentTime
10:02:01 <aristid> 	zone <- getTimeZone t
10:02:01 <aristid> 	return (utcToZonedTime zone t)
10:03:11 <jedai> geheimdienst: I think I already did it in the past though
10:03:45 <jedai> it's somewhere in the new (several years already) time package 
10:03:54 <geheimdienst> jedai: i'm very interested. i couldn't figure it out
10:04:02 <geheimdienst> you mean Data.Time, right?
10:04:31 <geheimdienst> i was messing with System.Locale
10:04:58 <jedai> geheimdienst: It's in Data.Time.Format
10:05:17 <jedai> And you need System.Locale to get the locale itself
10:06:05 <geheimdienst> yeah that was the problem. i couldn't find a function to get me the locale based on the environment's LANG
10:06:54 <jedai> geheimdienst: yep, you're right that doesn't seems available... Though you can write it yourself I guess
10:08:45 <jedai> That seems quite an hole in the strange that it hasn't been corrected !
10:10:33 <jedai> The old-locale library recommends using rather the locale package... but it don't seem to exist presently
10:10:52 <geheimdienst> what's the package again that's named "old-something" but actually the current one? old-exceptions ...?
10:11:04 <geheimdienst> old-locale?
10:12:06 <jedai> Well locale being unavailable, I guess you could tell that old-locale is the current one but it don't really provide locale handling so...
10:13:03 <geheimdienst> haskell's confuse-me-fu is strong today
10:13:48 * hackagebot cil 0.0.2 - An interface to CIL and ACSL through Frama-C.  http://hackage.haskell.org/package/cil-0.0.2 (TomHawkins)
10:15:54 * Mathnerd314 feels sorry for
10:16:00 <Mathnerd314> haskell type classes
10:17:31 <Cale> Mathnerd314: ?
10:17:52 <Mathnerd314> they get abused in every example of type-level programming
10:17:57 <aristid> jedai: maybe setlocale is the current one?
10:18:37 <Phyx-> Mathnerd314: they knew what they were getting into when they took the job
10:18:55 <Cale> Mathnerd314: There's type families now, but typeclasses are just how we specify functions and values which behave differently at different types, so it's unsurprising that they'd show up a lot in type-level programming.
10:19:11 * BMeph is curious as to what Mathnerd314 would consider non-abusive use of Haskell type classes...
10:19:16 <Mathnerd314> Phyx-: did they really expect UndecidableInstances?
10:19:36 <Phyx-> Mathnerd314: they should have read the fine print
10:20:08 <Mathnerd314> BMeph: something simple, like Monoid
10:20:10 <aristid> @hackage i18n
10:20:10 <lambdabot> http://hackage.haskell.org/package/i18n
10:20:57 <Mathnerd314> BMeph: or just not using them
10:21:53 * BMeph takes a minute to silently comtemplate the poor type classes, locked down in isolation by Mathnerd314...
10:22:28 <fryguybob> @where tcm
10:22:28 <lambdabot> http://conal.net/papers/type-class-morphisms/
10:22:37 <sproingie> BMeph: you could even say that's abusing the poor things
10:22:37 <geheimdienst> aristid, thanks for the pointer. however that thing seems to only load .po files, not provide an interface to strftime
10:22:38 <Wooga> how do i parse (for interpreting) language like brainfuck ( http://en.wikipedia.org/wiki/Brainfuck )? isn't there a better way then a chewing char-by-char with parser (x:xs) ... doStuff x ... foo xs ?
10:22:50 <chrisdone> keya chappies
10:22:51 <Wooga> s/foo/parser/
10:23:27 <aristid> geheimdienst: strftime uses the current locale, no? there's the setlocale package
10:23:32 <aristid> @hackage setlocale
10:23:32 <lambdabot> http://hackage.haskell.org/package/setlocale
10:23:35 <chrisdone> Wooga: there's Parsec
10:23:35 <chrisdone> @google Text.Parsec
10:23:35 <chrisdone> Wooga: but brainfuck is... so simple, no?
10:23:36 <lambdabot> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec.html
10:23:36 <lambdabot> Title: Text.Parsec
10:23:37 <sproingie> you could i suppose write a proper parser for brainfuck, but i don't see the point
10:23:39 <Mathnerd314> BMeph: no, the poor, innocent typeclasses, hidden away from the "bad men" like Oleg
10:23:49 <BMeph> Wooga: That depends on what you mean by "parse"... :)
10:23:52 <sproingie> the parser would be the lexer
10:23:54 <Wooga> chrisdone: thanks!
10:23:57 <sproingie> not unlike forth
10:24:19 <Wooga> BMeph: process into evalutable form
10:24:23 <chrisdone> I never bothered to look into brainfuck, but it looks like a stack machine or something. I imagine parsing and running it are one in the same. or am I wrong?
10:24:45 <byorgey> chrisdone: it's not a stack machine.
10:24:53 <sproingie> it's a turing tape afaik
10:24:54 <BMeph> Mathnerd314: Oleg never hides away typeclasses; he gets out the sparkly spandex and face paint and makes them perform better than Cirque de Soleil!
10:25:10 <dolio> Type classes were, from the beginning, essentially case statements on types.
10:25:12 <copumpkin> you have no literals
10:25:19 <sproingie> pretty sure no one's written a static compiler for brainfuck
10:25:21 <dolio> First you get them on types of kind * to define values.
10:25:21 <azaq231> parsing = you may transform it in a stream of tokens, but that's just for the general java guy
10:25:30 <dolio> Then you get them on higher kinds.
10:25:38 <Mathnerd314> BMeph: yeah, that's why you hide them away from Oleg
10:25:42 <sproingie> wouldn't be that hard tho, you'd just translate each bf opcode into some ASM
10:25:48 <chrisdone> byorgey: isn't a stack machine equivalent to a turing machine?
10:25:54 <sproingie> wouldn't be very efficient i guarantee
10:25:55 <dolio> Then you get them on multiple types at the same time. Then you allow them to define/determine other types.
10:26:02 <byorgey> chrisdone: no, definitely not.
10:26:06 <sproingie> chrisdone: a stack machine is a von neumann machine
10:26:14 <byorgey> chrisdone: a machine with TWO stacks is equivalent to a turing machine.
10:26:19 <sproingie> chrisdone: a turing machine uses a tape, data and program live in the same space
10:26:21 <azaq231> chrisdone: no, a stack maschine corresponds to type 2 languages in the chomsky hierarchy -> context free
10:26:24 <copumpkin> a stack machine is a PDA
10:26:53 <sproingie> you can also use two stacks, though they're not very ... "stacky"
10:27:00 <chrisdone> byorgey: yeah, multiple stacks
10:27:03 <dolio> And undecidable instances is removing 'arbitrary' restrictions on them.
10:27:06 <byorgey> chrisdone: intuitively, the reason is that a tape gives you random access whereas a stack doesn't.
10:27:47 <byorgey> so you are constrained in the order in which you can use the data.
10:27:58 <chrisdone> yeah
10:28:06 <sproingie> STG machine that haskell runs on is a graph reduction thing, right?
10:28:32 <byorgey> chrisdone: anyway, brainfuck has an implicit tape, and the instructions move the read/write head around and manipulate the current cell.
10:28:33 <dolio> The G stands for graph.
10:28:35 <byorgey> and it has loops.
10:28:39 <roconnor> didn't think GHC did graph reduction
10:28:42 <kmc> and it's not mandated that Haskell use STG machine
10:28:57 <kmc> what GHC-produced code does is sort of like graph reduction
10:29:00 <sproingie> sorry i keep mentally doing s/ghc/haskell/
10:29:12 <roconnor> I thought G stood for G-machine.
10:29:14 <sproingie> since hugs stopped being maintained anyway
10:29:38 <dolio> Spineless tagless G-machine machine?
10:29:44 <kmc> sproingie, what about jhc and uhc, both of which have interesting and useful extensions not found in ghc?
10:29:46 <roconnor> er
10:29:48 <roconnor> right
10:29:52 <kmc> and both of which are actively developed
10:29:55 <roconnor> I guess I thought G stood for G-
10:29:58 <roconnor> :D
10:30:21 <kmc> Wooga, parsec might be overkill for brainfuck
10:30:28 <kmc> Wooga, i assume the tricky part is matching [ with ] ?
10:30:35 <copumpkin> even that is pretty simple :P
10:30:37 <sproingie> might be a fun parsec project to make parsec drive the interpreter
10:30:52 <dolio> Anyhow, prior to the STG machine, there was the G-machine (by augustss, maybe?) and I think the G was for graph there.
10:30:53 <sproingie> for some odd definition of fun
10:31:03 <dolio> Although it's possible that's not right.
10:31:06 <kmc> and GHC's machine is no longer tagless anyway
10:31:06 <Wooga> kmc: yes, i currently solving it with pre-processing and building list of pairs ([pos,]pos)
10:31:17 <kmc> Wooga, you can probably do better
10:31:44 <Wooga> kmc: how?
10:32:00 <copumpkin> anyone know how hard it would be to link GHC into a c++ app as a scripting language (the app already has generic scripting support; you just need to provide some interpretation functions)
10:32:19 <sproingie> start with a C API
10:32:22 <chrisdone> byorgey: so it's a straight turing machine with no fanciness?
10:32:32 <kmc> it's not a turing machine
10:32:33 <sproingie> since getting it to talk to C++ is not going to be fun at all
10:32:36 <kmc> not directly
10:32:50 <copumpkin> sproingie: well, I can just extern "C" it
10:32:56 <chrisdone> byorgey: can it only move one cell at a time?
10:33:00 <kmc> yes
10:33:01 <dolio> kmc: It's got tags, but they're different tags than the tags the 'tagless' refers to, I believe.
10:33:04 <sproingie> after that i guess i'd just see what lambdabot does
10:33:05 <copumpkin> sproingie: I'm mostly curious about the "getting GHC to do my bidding from C" part
10:33:06 <byorgey> chrisdone: well, with less fanciness actually.  there are no states, and you can only increment or decrement cell contents
10:33:13 <byorgey> chrisdone: yes, only one cell at a time
10:33:19 <chrisdone> byorgey: ahh, hence the brain fuck
10:33:28 <byorgey> chrisdone: instead of having multiple states, it has loops for control flow
10:33:34 <sproingie> i think the brainfuck is just from looking at it
10:33:41 <sproingie> write-only language
10:33:45 <byorgey> chrisdone: [...] means do ... and loop if the current cell isn't zero, or something like that
10:33:55 <chrisdone> cute
10:34:02 <fryguybob> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
10:34:02 <lambdabot>   Hello World!
10:34:18 <chrisdone> @bf .
10:34:18 <lambdabot>  Done.
10:34:22 <chrisdone> @bf +-.
10:34:22 <lambdabot>  Done.
10:34:26 <chrisdone> @bf ++-.
10:34:26 <lambdabot>  Done.
10:34:39 <chrisdone> @bf [+-].
10:34:39 <lambdabot>  Done.
10:34:42 <chrisdone> mmk
10:34:44 <byorgey> chrisdone: + = increment, - = decrement, > = move right, < = move left
10:34:46 <kmc> Wooga, well, an abstract syntax tree would be like Â«data BF = MoveLeft | MoveRight | Incr | Decr | Read | Write | Loop BFÂ»
10:34:55 <byorgey> and . is output ASCII I think
10:35:02 <chrisdone> ahh
10:35:15 <sproingie> loop?  that's awful high level
10:35:16 <kmc> and , is input ASCII, 0 on EOF
10:35:32 <kmc> Wooga, i think you can handle the [] nesting by recursion
10:35:38 <byorgey> @bf +++++++++++++++++++++++++++++++++.
10:35:39 <lambdabot>   !
10:35:42 <azaq231> @bf ++++++++++.[-].
10:35:42 <lambdabot>  Done.
10:35:48 <sproingie> i'm surprised it didn't use "move right/left by current cell" instead
10:36:04 <sproingie> previous cell i guess
10:36:12 <Wooga> kmc: thanks! i'll try
10:36:22 <kmc> err that'd be Â«... | Loop [BF]Â»
10:36:47 <chrisdone> @bf [+]
10:36:47 <chrisdone> infinite loop?
10:36:47 <lambdabot>  Done.
10:37:00 <BMeph> sproingie: No need to go overboard; it's Brainfuck, not Unlambda... ;)
10:37:46 <chrisdone> byorgey: doesn't seem like [+] loops until zero?
10:37:58 * chrisdone sets topic: Figure out brainfuck
10:38:02 <byorgey> chrisdone: IIRC the cells are 4 or 8 bytes or something like that and it loops around
10:38:08 <chrisdone> ahhhh
10:38:35 <byorgey> or maybe they are just one byte, that seemed a bit fast to count to 2^32
10:38:37 <kmc> Wooga, i wrote a small parser for s-expressions, which nest similarly:
10:38:50 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28943#a28943
10:39:25 <chrisdone> needs more readP
10:39:41 <byorgey> @bf ++++[>++++++++++<-]>.
10:39:41 <lambdabot>   (
10:39:52 <kmc> Wooga, that version is in continuation-passing style; a version using tuples instead is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28944#a28944
10:40:01 <byorgey> see, that's 4*10
10:40:04 <chrisdone> aye
10:40:48 <kmc> Wooga, finally, if you're interested in parser combinator libraries, this defines and then uses a minimal applicative parser combinator library:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28945#a28945
10:41:18 <theorbtwo> Aw, I was hoping for a s-expression parser in brainfuck.
10:41:29 <kmc> Wooga, all three parse s-expressions, which are the syntactic building block of Lisp and look like (foo (bar baz))
10:41:38 <geheimdienst> aristid, yes strftime does what i want. however i can't seem to find a haskell function that calls it. the setlocale package doesn't seem to provide one either :-) and it can't tell me the current TimeLocale, i guess (sorry for lag)
10:43:35 <BMeph> kmc: Why all the Hatorade against Nums? :(...
10:43:47 <Wooga> kmc: thanks! this should help
10:44:40 <azaq231> there's this one website about brainfuck and implementation details
10:45:07 <azaq231> it mentions that all standard compliant (if you can call it that) brainfuck implementations should have a 1 byte range and loop around
10:45:28 <azaq231> right
10:45:29 <chrisdone> I like the idea of esolangs having standards
10:45:34 <azaq231> @google muppetlabs brainfuck
10:45:35 <azaq231> there
10:45:35 <lambdabot> http://www.muppetlabs.com/~breadbox/bf/
10:45:35 <lambdabot> Title: The Brainfuck Programming Language
10:45:41 <aristid> geheimdienst: can you tell me what you're doing with strftime? (i don't want to tell you about what i do, tho, so that's a bit unfairly asymmetric)
10:46:03 <azaq231> he also does other nice stuff, like producing a 50 byte or so ELF which actually runs
10:46:07 <alip> i have a c function i'm trying to wrap, it accepts a pointer to a char buffer and the length of the buffer as arguments. how would I go about allocating such a buffer and freeing it afterwards?
10:46:31 <kmc> alip, did you read the RWH chapter on FFI?
10:46:54 <kmc> alip, you'd probably use "alloca" but there might be a C-string-specific function
10:47:05 <kmc> withCStringLen :: String -> (CStringLen -> IO a) -> IO a
10:47:22 <geheimdienst> aristid, no problem :-) i was just trying to get a date printed in a locale-specific way
10:47:39 <geheimdienst> example: $ date
10:47:39 <geheimdienst> tor aug 12 19:46:43 CEST 2010
10:47:56 <alip> kmc: thanks!
10:47:58 <geheimdienst> $ LANG=C date
10:47:59 <geheimdienst> Thu Aug 12 19:46:38 CEST 2010
10:48:19 <geheimdienst> i wanted to replicate that in haskell
10:48:26 <copumpkin> bos31337 is stuck in an infinite loop of evil
10:48:36 <bos31337> hmm?
10:48:48 <bos31337> oh look! flaky innanets!
10:52:29 <copumpkin> bos31337: yep! 
10:52:58 <bos31337> copumpkin: must be a bad server. i'm connected happily to a different irc network.
10:52:59 <alip> kmc: i've just had a quick look on the RWH chapter on FFI.. and the doc of withCStringLen.. the problem is the function i have will fill in this character buffer e.g. foo(char *dest, size_t len)
10:53:21 <copumpkin> bos31337: that's weird!
10:53:49 <bos31337> copumpkin: i know!
10:54:55 <alip> kmc: i think what I need is allocaBytes
10:55:27 <bos> copumpkin: quassel ftw
10:55:38 <copumpkin> is that an IRC client?
10:55:51 <bos> copumpkin: a very fancy irc client/bouncer
10:55:56 <copumpkin> oh nice
10:56:28 <bos> there, better.
11:05:35 <sioraiocht> is there any place that documents the exact optimisations performed by GHC?
11:14:54 <zygoloid> sioraiocht: the GHC source code? :)
11:15:11 <sioraiocht> zygoloid: I see =p
11:16:06 <leimy> There's an irc proxy server that can do this sort of stuff quassel is capable of.  And there's an IRC "filesystem" in Inferno that can be connected to via a 9P client... same idea :-)
11:17:10 * hackagebot data-object-yaml 0.3.1 - Serialize data to and from Yaml files  http://hackage.haskell.org/package/data-object-yaml-0.3.1 (MichaelSnoyman)
11:17:11 * hackagebot neither 0.0.2 - Provide versions of Either with good monad and applicative instances.  http://hackage.haskell.org/package/neither-0.0.2 (MichaelSnoyman)
11:25:05 <jkramer> Ahoy
11:25:44 <jkramer> Does anyone here know the hbeanstalk module and can help me with a problem?
11:28:54 <jkramer> Guess I solved it
11:37:43 <chrisdone> Haskellers, assemble!
11:37:56 <zygoloid> Form of a lambda!
11:38:02 <chrisdone> looking forward to Hackage 2.0
11:38:25 <Martty> haskellians sounds more appropiate
11:38:44 <zygoloid> Go go gadget curry!
11:38:45 <chrisdone> to celebrate I might add testing to all my packages on Hackage
11:40:51 <chrisdone> what's the convention? quickcheck properties next to function definitions, or in a separate file?
11:42:24 <chrisdone> I suppose your editor could provide a shortcut to the corresponding property in the Tests file for a given definition
11:42:43 <chrisdone> automatically run tests when that definition is changed, etc
11:42:54 <dolio> I'd put them in a separate file.
11:43:27 <dolio> To avoid having lots of properties together with the rest of the program.
11:43:42 <dolio> Certainly for a library.
11:44:09 <chrisdone> true, true
11:44:25 <dolio> And a separate file can conceivably be triggered by cabal to test the other stuff.
11:44:37 <monochrom> NEED MOAR IDE
11:44:56 <chrisdone> monochrom: dude, this is trivial with Emacs
11:45:25 <monochrom> no disagreement
11:45:28 <chrisdone> dolio: Tests file per project or per module or per module level?
11:45:28 <chrisdone> what are Haskellers doing in their real projects?
11:45:45 * chrisdone has a look at ByteString
11:45:49 <monochrom> trivial in all good IDEs such as Emacs
11:46:10 <dolio> Well, the one thing I have tests for off the top of my head has per-project tests.
11:46:27 <monochrom> I look for and prove theorems in my real projects.
11:46:27 <dolio> Because the project is a bunch of algorithms that do approximately the same thing.
11:46:41 <chrisdone> monochrom: like what?
11:46:41 <monochrom> I also make great slides.
11:46:43 <chrisdone> dolio: example?
11:46:46 <chrisdone> monochrom: lol
11:47:04 <dolio> vector-algorithms
11:47:34 <chrisdone> hmm, so the ByteString package has a tests/ directory, which seems consistent with how I've seen others written
11:47:38 <chrisdone> dolio: I'll take a look
11:48:08 <chrisdone> ah, you too
11:48:22 <chrisdone> oddly, no cabal integration
11:48:39 <chrisdone> are you purposely not using a Cabal test hook?
11:48:46 <monochrom> like http://www.cs.toronto.edu/~trebla/tmp/termination-talk-2.pdf
11:50:39 <monochrom> that killed the conversation and/or everyone :)
11:50:43 <chrisdone> fascinating recondite syntax
11:50:46 <chrisdone> lol
11:52:03 <chrisdone> dolio: intentionally not using the cabal test hooks?
11:52:39 <chrisdone> wow, this is like the old days. no parts/joins in almost 5 minutes
11:52:42 <chrisdone> oh damnit
11:52:58 <chrisdone> spoke too soon
11:53:33 <monochrom> I can set a ban to help with the "join" bit. :)
11:56:56 <dolio> chrisdone: Not intentionally, no.
11:57:18 <dolio> How old are the test hooks? I've been neglecting vector-algorithms a bit.
11:57:21 <iocor> can anyone make suggestions on how to improve http://pastebin.com/c7nTKLDK
11:58:30 * hackagebot sifflet-lib 1.0 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-1.0 (GregoryWeber)
11:58:45 <Saizan> dolio: test hooks are very old, though after the summer there should be a new shiny support for tests
11:58:50 <chrisdone> dolio: I was wondering the same.
11:59:36 <dolio> Anyhow, I didn't really put any effort into automating the testing.
12:00:06 <chrisdone> the test hook merely lets you type 'cabal test' instead of ghc --make tests/Tests.hs etc
12:00:31 * hackagebot sifflet 1.0 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-1.0 (GregoryWeber)
12:00:40 <chrisdone> (though I'm using it to start/restart my web server and fastcgi process >_>)
12:01:55 <alexbobP> iocor: first of all, f1 is absolutely pointless
12:02:08 <iocor> alexbobP: a-why?
12:02:36 <alexbobP> iocor: oh wait, never mind
12:02:46 <alexbobP> iocor: I see what it does, it specifies the type of the result
12:02:53 <iocor> indeed!
12:03:35 <EvanR-work> im looking at Network.SMTP.Client and im thinking there is easy support for attachments
12:03:40 <EvanR-work> is no*
12:03:49 <alexbobP> iocor: anyways what's wrong with it?
12:04:01 <iocor> alexbobP: I have the feeling it's not great haskell. I might just be being paranoid
12:04:27 <alexbobP> iocor: it looks reasonable to me
12:04:32 <iocor> \o/
12:04:40 <iocor> alexbobP: as always, you're a bro
12:05:05 <FunctorSalad_> is there some common accepted name for >>> that's shorter
12:05:06 <FunctorSalad_> ?
12:05:23 * EvanR-work looks into Codec.MIME
12:06:23 <aavogt> 3 chars is pretty short
12:06:36 <FunctorSalad_> it's 200% longer than (.)
12:06:48 <EvanR-work> ah optional field Content-Type: multipart/mixed; boundary="randomcrap", then encode the attachments in the body
12:07:23 <alexbobP> iocor: thanks <3
12:07:27 <FunctorSalad_> 'randomcrap' seems like a pretty bad separator(?)
12:08:10 <chrisdone> FunctorSalad_: import Prelude hiding (.); import Control.Category ((.))? :p
12:08:14 <EvanR-work> ill have to come up with something better ;)
12:08:35 <sproingie> @src Control.Category.(.)
12:08:35 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:08:40 * EvanR-work grabs some typical conversion from #haskell to use as the separator
12:08:50 <FunctorSalad_> chrisdone: I'm after the left-to-rightness, not the categoricity
12:08:56 <EvanR-work> those effective irreproducible ;)
12:09:00 <aavogt>  ~ isn't taken yet, is it?
12:09:02 <aRcatan> if we had Unicode operators in Haskell, you could just use â, that's one character!
12:09:10 <FunctorSalad_> aavogt: :O
12:09:25 <FunctorSalad_> how could we overlook an ascii character?
12:09:38 <EvanR-work> > let x â y = x + y in 5 â 9
12:09:39 <lambdabot>   14
12:09:52 <aristid> the famous snowman operators
12:10:07 <chrisdone> :t let (~) = (>>>) in (+2) ~ (*6)
12:10:08 <lambdabot> parse error on input `)'
12:10:12 <chrisdone> :(
12:10:13 <sproingie> huh that one is actually recognized as punctuation
12:10:14 <aavogt> FunctorSalad_: also # if some less common libraries don't count
12:10:23 <sproingie> lot of unicode chars aren't
12:10:33 <aavogt> hmm, maybe ~ is illegal because it's pattern syntax
12:10:41 <chrisdone> true
12:10:50 <EvanR-work> theres a list of characters not usable by themselves (or in a certain sequence) as operators
12:11:00 <EvanR-work> like ..
12:11:19 <sproingie> or `
12:11:22 <chrisdone> % is also there
12:11:27 <roconnor> mathematicians have strange ways of avoiding dependent functions / dependent pairs.
12:11:29 <sproingie> wait what's % ?
12:11:31 <EvanR-work> > 4 % 6
12:11:32 <lambdabot>   2 % 3
12:11:38 <sproingie> yeah but how's that reserved?
12:11:42 <EvanR-work> its not
12:11:44 <chrisdone> you have to import to get %
12:11:50 <monochrom> % is fractions
12:11:59 <sproingie> ah
12:12:10 <aavogt> monochrom: meaningless symbols
12:12:14 <monochrom> and not reserved
12:12:19 <EvanR-work> > let (@) = (+) in 4 @ 5
12:12:20 <lambdabot>   <no location info>: parse error on input `@'
12:12:25 <sproingie> > let (*) = (-) in 4 % 6
12:12:26 <lambdabot>   2 % 3
12:12:27 <chrisdone> @'s used in patterns too
12:12:27 <lambdabot> Maybe you meant: . ? @ ask bf do ft id msg pl rc v wn
12:12:30 <sproingie> doh
12:12:34 <sproingie> > let (%) = (-) in 4 % 6
12:12:34 <lambdabot>   -2
12:12:50 <EvanR-work> > let (?) = (+) in 4 ? 5
12:12:51 <lambdabot>   9
12:12:59 <sproingie> maybe you meant: idk my bff jill
12:13:03 <EvanR-work> > let (#) = (+) in 4 # 5
12:13:04 <lambdabot>   <no location info>: parse error on input `)'
12:13:20 <EvanR-work> > let (;) = (+) in 4 ; 5
12:13:21 <lambdabot>   <no location info>: parse error on input `;'
12:13:25 <FunctorSalad_> roconnor: hmm? they just call dependently-typed functions 'products' often :p
12:13:36 <monochrom> the semicolon is not exactly programmable :)
12:13:42 <EvanR-work> lol
12:13:57 <FunctorSalad_> Î _i X_i
12:13:58 <chrisdone> ! is also a good one but kind of informally reserved for indexing
12:13:59 <EvanR-work> â
12:14:01 <FunctorSalad_> just subscript notation...
12:14:18 <dolio> That's what they're called with dependent types, too. :)
12:14:21 <FunctorSalad_> *dependent function spaces
12:14:32 <EvanR-work> basically every single char ascii operator is informally reserved for something, (except maybe ? ?)
12:14:56 <FunctorSalad_> aavogt: # isn't made illegal my MagicHash?
12:15:02 <FunctorSalad_> *by
12:15:08 <FunctorSalad_> hehe
12:15:11 <EvanR-work> its illegal i tried it above
12:15:14 <chrisdone> yeah
12:15:26 <chrisdone> it's only because of lambdabot's madness
12:15:52 <aavogt> > let ( # ) = (+) in 4 # 5
12:15:53 <lambdabot>   9
12:15:56 <chrisdone> @faq driven mad by the deep knowing. it's an effect of knowing Haskell too well, right lambdabot?
12:15:56 <lambdabot> The answer is: Yes! Haskell can do that.
12:15:59 <FunctorSalad_> % seems fair enough to steal
12:16:26 <chrisdone> yeah I quite like %
12:16:52 <FunctorSalad_> :set -XMagicHash ; let (#)=(+)
12:16:53 <FunctorSalad_> works...
12:17:16 <FunctorSalad_> (I don't trust lambdabot about language obscurae :p)
12:17:31 <monochrom> someone should make an alternative prelude where / and % are swapped. just to frustrate c programmers.
12:17:33 <aristid> :t let (â) = undefined in (â)
12:17:33 <lambdabot> forall a. a
12:17:48 <aristid> \o/ â is a valid operator
12:18:09 <FunctorSalad_> unicode would be ok if I had a input method that isn't annoying
12:18:31 <chrisdone> yeah. MagicHash does do some stealing, though:
12:18:35 <chrisdone>  varid{#}, char#, string#, integer#, float#, float##, (#, #),
12:18:35 <chrisdone>     Stolen by: -XMagicHash, 
12:18:37 <aavogt> FunctorSalad_: -XUnboxedTuples
12:18:41 <Saizan> FunctorSalad_: steal agda's!
12:19:21 <copumpkin> agda's what?
12:19:32 <dolio> Unicode input.
12:19:37 <dolio> It's actually not Agda's.
12:19:39 <copumpkin> oh
12:19:43 <dolio> Quail mode or something?
12:19:48 <copumpkin> quail completions I think
12:20:13 <FunctorSalad_> aavogt: ah, but that doesn't prevent a pointful definition 
12:20:56 <aavogt> or one with spaces between the () and #
12:21:43 <FunctorSalad_> chrisdone: is that literally 'varid'?
12:21:44 <monochrom> -XMagicCash
12:21:49 <FunctorSalad_> x# still works
12:22:19 <FunctorSalad_> or how about > ;)
12:22:31 <FunctorSalad_> for order you can always use < ;)
12:24:35 <chrisdone> FunctorSalad_: it works, but it means something different, afaik
12:25:55 <chrisdone> > let x = 5#
12:25:56 <lambdabot>   not an expression: `let x = 5#'
12:25:59 <chrisdone> > let x = 5# in x
12:26:00 <lambdabot>   Couldn't match kind `#' against `*'
12:26:06 <chrisdone> wut
12:26:07 <chrisdone> :t (#)
12:26:08 <lambdabot> parse error on input `)'
12:26:14 <chrisdone> @undef (#)
12:26:18 <aristid> :t 5#
12:26:19 <lambdabot> GHC.Prim.Int#
12:26:26 <dolio> > let !x = 5# in I# x
12:26:27 <lambdabot>   Not in scope: data constructor `I#'
12:26:41 <Saizan> > let !x = 5# in ()
12:26:41 <lambdabot>   ()
12:27:51 <yescalona> why haskell reach popularity the last year
12:28:11 <chrisdone> yescalona: the recession, more people have spare time
12:28:56 <Botje> semicolon shortage
12:29:07 <yescalona> good point chrisdone 
12:29:37 <burp> lol
12:30:06 <burp> "will code haskell for food"
12:30:16 <monochrom> will cook haskell for food
12:30:18 <yescalona> unemployed --> lazy --> haskell
12:30:50 <monochrom> will cook haskell newbies for food
12:32:12 <monochrom> I guess that scares everyone. :)
12:37:46 * hackagebot web-encodings 0.3.0 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.3.0 (MichaelSnoyman)
12:43:32 <chrisdone> monochrom: you're a conversation killer :p
12:45:00 <yokto> hi
12:45:11 <chrisdone> :-)
12:46:51 <yokto> there are several haskell c-bindings that are relatively direct translations from C. Likes for instance xlib. However I cant find functions to access the fields of structs. Is that at all possible?
12:47:25 <Cale> yokto: Generally, you'd write an instance of Storable for the struct, and a corresponding Haskell datatype.
12:48:38 <yokto> yes think they are storable - but does that mean there is a way to access a single field of that struct?
12:49:11 <mauke> what do you mean by "struct"?
12:49:51 <Heffalump> a C struct, presumably..
12:50:02 <yokto> typedef struct Something { int a, int b } Something
12:50:09 <mauke> C structs can't be instances of Storable
12:50:12 <yokto> and now i want to know a
12:50:39 <Cale> yokto: Once you have an instance of Storable for a corresponding Haskell type, you use peek to read a pointer of that type, and then look at the corresponding field in your Haskell type.
12:51:24 <ClarkG> how do I convert a document (markdown, word, rtf, really anything will do) to pdf in haskell?
12:51:40 <mauke> why in haskell?
12:51:40 <ClarkG> is there some library which will help with this?
12:51:49 <ClarkG> fits in nicer with the rest of the code
12:51:56 <ClarkG> it isn't JUST conversion
12:52:16 <ClarkG> its more like
12:52:25 <ClarkG> input file -> transformations -> convert to pdf -> .pdf file
12:52:41 <aavogt> @hackage pandoc
12:52:41 <lambdabot> http://hackage.haskell.org/package/pandoc
12:52:44 <Cale> ClarkG: Use Pandoc to convert to LaTeX, and then run pdflatex
12:52:54 <ClarkG> I got the converting to latex part down
12:52:57 <ClarkG> but then I'm not sure where to go from there
12:53:13 <mauke> run pdflatex
12:53:20 <ClarkG> when I do, it says ! LaTeX Error: Environment figure undefined.
12:53:39 <ClarkG> I don't know what that means =/
12:54:08 <chrisdone> oh my god how many binary formats
12:54:13 <chrisdone> .hi, .haddock, .hoo
12:54:17 <chrisdone> ~______________~
12:54:20 <ClarkG> lol
12:54:34 <aavogt> ClarkG: does the generated latex have a preamble (\documentclass and so on )
12:54:37 <ezyang> Does anyone here have advice about typeclasses that contain lots of functions? 
12:54:42 <ClarkG> sec
12:54:55 <ClarkG> no preamble
12:55:00 <ezyang> Basically, any generic operation that could have a more efficient representation needs to go into the typeclass, and this makes me a little antsy. 
12:55:12 <ClarkG> This seems easy to fix
12:55:17 <aavogt> ezyang: over efficiency concerns?
12:55:23 <aavogt> ClarkG: you are using pandoc?
12:55:26 <ezyang> aavogt: Over maintainability. 
12:55:28 <ClarkG> aavogt: yes
12:55:47 <aavogt> ClarkG: there's some option for generating 'standalone' documents with pandoc
12:56:04 <ClarkG> what does that mean?
12:56:59 <aavogt> ClarkG: you can use   getDefaultTemplate    and update the   'writerTemplate' field somewhere
12:57:08 <ClarkG> what about the parserstate?
12:57:12 <ClarkG> I see stateStandalone in there too
12:58:04 <aavogt> I dunno, to generate a usable man page I only had to modify writerTemplate and  writerStandalone
12:58:23 <mauke> standAloneComplex
12:58:32 <ClarkG> hm?
12:59:31 <ClarkG> what's writerTemplate?
12:59:48 <ClarkG> what do I put in it?
13:00:13 <aavogt> I've used this: writeMan writeOpts{ writerStandalone = True, writerTemplate = template }
13:00:43 <ClarkG> oops
13:00:51 <ClarkG> and okay, one sec.
13:01:01 <ClarkG> I don't see the definition for template anywhere
13:01:17 <aavogt> right, it comes from something like:
13:01:19 <aavogt>     Right template <- getDefaultTemplate "man"
13:01:25 <aavogt> or something you've made up
13:01:37 <ClarkG> what's the default template?
13:01:54 <aavogt> I've never generated latex with pandoc
13:02:25 <ClarkG> =/
13:03:20 <aRcatan> have you taken look at markdown2pdf? it comes with pandoc
13:03:28 <ClarkG> how do I call getDefaultTemplate? Something like this?
13:03:31 <ClarkG> writerTemplate = getDefaultTemplate "[the file]"
13:03:36 <ClarkG> and yeah, it's kind of complicated
13:03:41 <ClarkG> I'm not that good at haskell
13:04:34 <ClarkG> and why is getDefaultTemplate IO'd?
13:05:00 <aRcatan> it reads the default template from file
13:05:13 <ClarkG> what file?
13:05:39 <aRcatan> getDefaultTemplate :: Maybe FilePath -> String -> IO (Either IOException String)
13:05:49 <aavogt> somewhere in ~/.cabal/share/pandoc
13:05:55 <aRcatan> the first argument is the directory, second is the file name
13:05:57 <ClarkG> what if I pass in Nothing?
13:06:04 <ClarkG> oh
13:06:12 <aRcatan> then it uses the default directory, which aavogt mentions
13:06:16 <ClarkG> how do I avoid doing IO for this?
13:06:35 <aavogt> oh, it changed _again_?
13:06:48 <ClarkG> huh?
13:06:55 <aRcatan> (i'm just reading the docs)
13:06:58 <aavogt> pandoc's api
13:07:06 <ClarkG> lol..
13:07:19 <aRcatan> ClarkG: I guess you'd call it in main/somewhere else and then pass the result to the pure code
13:07:38 <aRcatan> that is, the String inside the either
13:07:47 <ClarkG> =/ I think I'll just copy+paste the template into some variable
13:07:49 <ClarkG> lol
13:08:27 <aRcatan> maybe not the most beautifully engineered solution, but i guess it works :)
13:08:29 <aavogt> you used to be able to get the template without messing in IO
13:09:08 <ClarkG> how do I do something like python's """some string"""?
13:09:18 <ClarkG> multi-line, no need to escape
13:09:40 <aavogt> there's no builtin for that
13:09:44 <pikhq> ClarkG: That syntax doesn't exist.
13:09:51 <pikhq> It's also fairly unique to Python.
13:09:52 <c_wraith> There are some quasiquote packages that get close
13:10:00 <pikhq> (well, not *unique*, but nearly so.)
13:10:07 <ClarkG> so I have to go replacing backslashes?
13:10:12 <aavogt>  -XQuasiQuotes gets you close to it
13:10:19 <pikhq> Like in most languages, yeah.
13:10:24 <ClarkG> eeeh I'd rather not use extensions
13:10:27 <ClarkG> and ok. yay unix.
13:10:36 <ClarkG> SED, I CHOOSE YOU
13:10:51 <c_wraith> if you don't use extensions, you're often making things harder on yourself for no reason.
13:10:58 <c_wraith> extensions exist *to be used*
13:11:06 <pikhq> Template Haskell could get you something close, or -XQuasiQuotes, or just sed. :P
13:11:07 <ClarkG> I'm not experienced enough to use them.
13:11:11 <c_wraith> They only make it into GHC if they provide some real benefit
13:11:12 <ClarkG> I don't even know all of base haskell
13:11:21 <ClarkG> arrows still make me wat
13:11:29 <ClarkG> I'm definitely not at that level
13:11:32 <pikhq> Arrows aren't base Haskell.
13:11:37 <pikhq> They're a handy library.
13:11:49 <aavogt> pikhq: what part of template haskell that's not -XQuasiQuotes is good for multiline string literals?
13:11:50 <ClarkG> and seriously; wikipedia needs to step its game up:
13:11:50 <ClarkG> $if(legacy-header)$
13:11:50 <ClarkG> $legacy-header$
13:11:50 <ClarkG> $else$
13:11:50 <ClarkG> \documentclass{article}
13:11:51 <aRcatan> i don't know arrows but i happily use extensions
13:12:04 <pikhq> aavogt: Oh, right, the quasiquoting is all you want. :P
13:12:27 <ClarkG> wow I suck at pasting
13:12:37 <ClarkG> http://en.wikipedia.org/wiki/Arrow_%28functional_programming%29
13:12:38 <pikhq> ClarkG: I'd imagine you know most of Haskell-without-libraries by now. There's hardly any *of* it.
13:12:39 <ClarkG> that article
13:12:41 <ClarkG> does not help me at all
13:12:51 <pikhq> @src Arrow
13:12:51 <lambdabot> class Arrow a where
13:12:51 <lambdabot>     arr, pure   :: (b -> c) -> a b c
13:12:51 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
13:12:51 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
13:12:51 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
13:12:51 <FunctorSalad_> SED? no problem ;) readProcess "sed" ["-Ee",script] input
13:12:53 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
13:12:54 <pikhq> That's all.
13:12:55 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
13:12:56 <ClarkG> and yeah, I probably do
13:13:01 <pikhq> It's a thing with those functions.
13:13:08 <FunctorSalad_> I admit I did that once because I couldn't be bothered with =~ >:)
13:13:17 <monochrom> you probably don't need to know arrows ever.
13:13:34 <pikhq> And yes, arrows are not used much in Haskell.
13:13:39 <aavogt> hxt
13:13:39 <FunctorSalad_> we could even have a sed quasiquotz0r
13:13:51 <pikhq> I've only seen the arrow functions used on functions.
13:13:58 <ClarkG> But my point is, I'm not yet fluent in haskell D: I can accomplish tasks but they take way longer than they should, and my head hurts.
13:14:13 <ClarkG> It's not a nice feeling when you think for an hour and have 10 lines of beautiful code to show for it
13:14:15 <tg_> ClarkG: that's a symptom of learning
13:14:17 <ClarkG> it feels wasteful
13:14:30 <ClarkG> I SHOULDN'T HAVE TO LEARN!
13:14:41 <pikhq> ClarkG: The same happens in C. Trust me.
13:14:47 <pikhq> With great power comes great head-pain.
13:14:48 <sproingie> it's really nice when you think for an hour and have five lines of beautiful code
13:14:50 <pikhq> :P
13:14:54 <sproingie> less is more
13:15:03 <ClarkG> yeah
13:15:06 <ClarkG> but it's counterintuitive
13:15:10 <monochrom> you don't have to learn. just drop haskell if it frustrates you such.
13:15:25 <ClarkG> it isn't frustrating. It's sooo cool.
13:15:26 <FunctorSalad_> just drop a few haskell if you're frustrated
13:15:35 <pikhq> (granted, it's not *likely* to be beautiful code in C, but yeah... I've spent a good 2 hours thinking about 20 lines of C before.)
13:15:36 <ClarkG> drop 4 haskell?
13:15:36 <sproingie> droppin' haskell bombs boo ya
13:15:56 <monochrom> I don't think this channel is interested in further whining.
13:16:22 <devinus> pikhq: just spend 4 hrs today thinking about one line of code. and it was javascript.
13:16:24 <devinus> *sigh*
13:16:46 <ClarkG> what was it?
13:16:46 <pikhq> Programming is, in general, hard. That's half the fun. :)
13:16:47 * geheimdienst doesn't think at all and just churns out code
13:16:56 <ClarkG> haha
13:17:03 <FunctorSalad_> pikhq: and it never runs out of hard...
13:17:13 <devinus> ClarkG: a bad assumption on my part. eventually gave up and refactored the code around it until it worked
13:17:18 <FunctorSalad_> after you've mastered something, there's always 'make an abstraction out of it'
13:17:19 <FunctorSalad_> ;)
13:17:19 <Tarrasch> g :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o
13:17:20 <Tarrasch> g = do undefined
13:17:41 <ClarkG> O_O
13:17:49 <c_wraith> any particular reason for that "do"?
13:17:51 <medfly> ClarkG, I had to take a course in C programming. one time, I spent an hour finishing an assignment. 100 lines of code.
13:17:51 <Tarrasch> that compiles, I assume it can use do since the whole thing is reader-monad. Right?
13:18:04 <medfly> ClarkG, and then I spent another hour re-writing it so it doesn't look horrible.
13:18:05 <medfly> :p
13:18:06 <c_wraith> you can use do anyway
13:18:08 <c_wraith> > do 5
13:18:08 <lambdabot>   5
13:18:09 <medfly> beauty was worth it!
13:18:09 <ClarkG> lol
13:18:11 <Mathnerd314> does Haskell's laziness do anything besides allow infinite data structures?
13:18:16 <sproingie> oh my yes
13:18:19 <Tarrasch> hmm, why can you use do?
13:18:26 <c_wraith> Mathnerd314, it allows creation of custom control-flow structures
13:18:26 <aavogt> @type do 5
13:18:27 <lambdabot> forall t. (Num t) => t
13:18:39 <FunctorSalad_> Mathnerd314: there is this 'their control structure is our library' propaganda, but I guess there's something to it
13:18:47 <Mathnerd314> c_wraith: yeah, was just about to add that. anything else?
13:19:18 <copumpkin> Mathnerd314: memoization
13:19:23 <sproingie> Mathnerd314: for example, short-circuiting operators like 'and' and 'or' in other languages are special cases that the compiler has to handle specially
13:19:39 <sproingie> Mathnerd314: in haskell, they're just ordinary operators and laziness makes them short circuit
13:19:48 <monochrom> what sproingie says. lazy > short-circuit
13:19:49 <Tarrasch> h :: a
13:19:52 <Tarrasch> h = do a <- undefined
13:19:53 <Tarrasch>        return a       
13:20:01 <Tarrasch> that doesnt compile
13:20:03 <copumpkin> Tarrasch: having fun?
13:20:05 <sproingie> yeah short-circuiting is just a degenerate form of laziness
13:20:14 <FunctorSalad_> well, a special case
13:20:17 <sproingie> (lazy degenerates)
13:20:21 <FunctorSalad_> 'if' is lazy too in normal langs
13:20:26 <ClarkG> wouldn't that need to be IO (a)?
13:20:33 <Mathnerd314> copumpkin: does the compiler really memoize that much?
13:20:33 <Tarrasch> copumpkin, no, I try to understand when it's syntactically working to use "do"
13:20:49 <FunctorSalad_> (the ternary operator, to make it fit into the function picture better)
13:20:51 <monochrom> with lazy, you can write your own "if" as an ordinary function rather than needing it built in.
13:20:52 <copumpkin> Mathnerd314: the laziness gives it to you if you want
13:20:55 <mauke> Tarrasch: anywhere you can use an expression
13:21:18 <ClarkG> :t undefined
13:21:19 <lambdabot> forall a. a
13:21:27 <Tarrasch> mauke, however the restrictions come when you use the <-, or?
13:21:39 <monochrom> myif True x y = x; myif False x y = y.  This code works in haskell, will do unwanted things elsewhere.
13:21:40 <aavogt> @type do undefined
13:21:41 <lambdabot> forall a. a
13:21:45 <mauke> Tarrasch: what do you mean?
13:21:52 <FunctorSalad_> AFAIK conal's memotries achieve their pureness by simply translating function types into equivalent types that do get memoized
13:22:08 <copumpkin> yeah
13:22:11 <FunctorSalad_> e.g. (Bool -> a) ===> (a,a)
13:22:14 <Tarrasch> Well, as I wrote above, with h::a etc., that doesn't compile, naturally it can't interpret the (<-) in any good way
13:22:17 <monochrom> More generally you can write your own control-flow as ordinary functions.
13:22:19 <copumpkin> I'm talking about things like lazy arrays for fibonacci and stuff
13:22:52 <mauke> Tarrasch: that's not a syntactic restriction
13:23:04 <mauke> Tarrasch: it just doesn't typecheck
13:23:43 <Tarrasch> mauke, oh ok, so that's how you should look at it then ...
13:23:56 <monochrom> w00t lazy array example: http://www.haskell.org/haskellwiki/Dynamic_programming_example
13:24:31 <mauke> :t let { h = do { a <- undefined; return a } } in h
13:24:32 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
13:24:46 <FunctorSalad_> lets forced-meme left-to-right composition
13:24:46 <pikhq> Tarrasch: Of course do {a <- undefined;return a} :: a doesn't compile.
13:24:51 <pikhq> Tarrasch: The type is too general.
13:24:55 <mauke> Tarrasch: change the first line to h :: (Monad m) => m a, and it'll compile
13:25:06 <FunctorSalad_> I think I changed my mind, it really is so much better that it warrants a change in convention
13:25:14 <FunctorSalad_> for coding more than math
13:25:54 <Tarrasch> pikhq, I know it shouldn't compile, but I think you can give different sound (but not as good as yours) motivations for that
13:25:55 <FunctorSalad_> since you usually do forward reasoning (taking the curry-howard picture), not backward reasoning, when programming
13:26:03 <pikhq> Tarrasch: Also, "do undefined" by itself is type a because do undefined gets turned into undefined.
13:26:27 <FunctorSalad_> and you are stuck with typing left-to-right (with english function names at least :p)
13:26:56 <dblhelix> isn't there a tool somewhere that automatically translates my Haskell programmes into Java?
13:27:07 <ClarkG> LOLWUT
13:27:09 <FunctorSalad_> left-to-right combinators let me turn a lot of do-block or let-code into composition
13:27:14 * dblhelix has/had to program in Java for a couple of days now
13:27:19 * dblhelix feels dirty ;-)
13:27:24 <pikhq> Tarrasch: "do" notation is just a simple syntactic transformation, you see. Has nothing to do with monads except for how what it turns into uses monad functions for the most part.
13:27:44 <ClarkG> I don't think java's powerful enough to be translated haskell... no closures first of all...
13:28:01 <ClarkG> no tail recursion
13:28:04 <FunctorSalad_> closures can be encoded as ad-hoc classes
13:28:09 <ClarkG> infinite lists might screw you
13:28:11 <FunctorSalad_> with the local variables in scope as members
13:28:12 <mauke> ClarkG: I don't think assembler code is powerful enough to be translated haskell... no closures first of all...
13:28:14 <aavogt> both are turing complete. QED
13:28:25 <ClarkG> *cleanly translated*
13:28:26 <mauke> ClarkG: infinite lists might screw you
13:28:28 <ClarkG> MY BAD.
13:28:38 <dblhelix> ClarkG: well, of course you have tail recursion in Java
13:28:42 <geheimdienst> clojure seems to be quite happy on that platform, and it's a nice language
13:28:46 <dblhelix> but I was joking, obviously
13:28:47 <Tarrasch> pikhq, but surely the (<-) is monad-related, it's a "different way" of using the bind. And since afaik (<-) is only available in do-notation then do-notation is related to monads, no?
13:29:01 <ClarkG> doesn't the JVM not do tail recursion properly?
13:29:07 <ClarkG> using an actual CALL instruction instead of a JMP?
13:29:08 <ezyang> Hey #haskell! Type families or functional dependencies? 
13:29:13 <ezyang> (which one should I use) 
13:29:25 <FunctorSalad_> fundeps obviously *troll*
13:29:26 <FunctorSalad_> ;)
13:29:28 <dolio> What are you doing?
13:29:42 <dblhelix> ezyang: I prefer type families, but I guess it depends on your particular situation
13:29:51 <FunctorSalad_> they are a bit more flexible though (let you express that your function is injective in one argument etc)
13:29:57 <ezyang> dolio: I'm making an and-inverter grpah class 
13:30:04 <FunctorSalad_> Fun a b c | b,c -> a
13:30:11 <ezyang> so stuff like input output, and I need node types and graph types 
13:30:14 <somnium> ClarkG: I think you mean tail call optimization, and for simple cases that can be translated to iteration
13:30:15 <copumpkin> I don't like functions expressed as fundeps
13:30:24 <ClarkG> and yes, I do
13:30:30 <FunctorSalad_> (and a,b -> c for functionality)
13:30:32 <copumpkin> ezyang: for that, I'd use type families (associated types)
13:30:37 <ezyang> Savvy 
13:30:52 <FunctorSalad_> why not copumpkin ?
13:30:54 <copumpkin> well, if I've understood it
13:31:12 <Mathnerd314> so: does Haskell's laziness do anything besides infinite data structures, control flow, and memoization?
13:31:12 <Starfire> I like type families more, but in my understanding fundeps are more expressive until superclass equality constraints are implemented.
13:31:28 <copumpkin> FunctorSalad_: same reason I don't write (+1) as {(1,2), (2,3), (3,4), ..} :P
13:31:38 <aavogt> Mathnerd314: it makes some code slower
13:31:57 <aavogt> stack overflows and the like
13:32:14 <copumpkin> Mathnerd314: things like labeling trees with the number of total nodes in them in a single pass :P
13:32:20 <dblhelix> copumpkin: mmm... you can do inductive definitions with fundeps, can't you?
13:32:23 <copumpkin> (i.e., voodoo)
13:32:30 <copumpkin> dblhelix: sure :P I was just being silly
13:32:56 <dblhelix> copumpkin: okay... everyone should be allowed once in a while ;-)
13:32:57 <FunctorSalad_> you do introduce an extra variable name
13:33:00 <Mathnerd314> copumpkin: isn't that just hiding a stack behind the compiler?
13:33:03 <FunctorSalad_> which can be good or bad
13:33:08 <copumpkin> Mathnerd314: yeah
13:33:18 <ClarkG> with vim, how do I do a find+replace on a string which ends with a backslash?
13:33:31 <ClarkG> it ends up escaping the forward slash separator
13:33:37 <FunctorSalad_> \\
13:33:38 <monochrom> you single-pass the original tree, but you build a 2nd tree
13:33:40 <copumpkin> Mathnerd314: it's also good for confusing people with odd lets
13:33:41 <ClarkG> k
13:33:57 <mauke> why are you using slashes as separators if your pattern contains backslashes?
13:34:13 <ClarkG> you can you different separators!?
13:34:20 <mauke> you can use anything you want
13:34:28 <geheimdienst> is there some hackage search that can tell me which package (if any) wraps around the C function nl_langinfo?
13:34:30 <mauke> /\\/ just looks ugly
13:34:36 <ClarkG> ...
13:34:39 <ClarkG> this is news to me
13:34:42 <FunctorSalad_> [\] works in some regex dialects
13:34:48 <FunctorSalad_> maybe all even, dunno
13:34:57 <FunctorSalad_> maybe it puts the ] into the char class in some
13:34:57 <mauke> FunctorSalad_: none of the sane ones
13:35:14 <copumpkin> No sane regex dialect!
13:35:17 <ClarkG> when I do...
13:35:17 <ClarkG> :s/\\/\\\\/
13:35:19 <ClarkG> it fails miserably
13:35:22 <ClarkG> says \\ can't be found
13:35:26 <ClarkG> but I'm looking for \!
13:35:36 <mauke> ClarkG: that only searches the current line
13:35:43 <FunctorSalad_> mauke: hmm it does with grep and grep -E
13:35:49 <ClarkG> oh.
13:35:51 <mauke> FunctorSalad_: yes
13:36:03 <Tarrasch> I don't fully get Functional Dependencies as given here (or anywhere) http://www.haskell.org/haskellwiki/Functional_dependencies
13:36:06 <dblhelix> ClarkG: exit vim, start up emacs, ... ;-)
13:36:08 <Tarrasch> class Mult a b c | a b -> c where
13:36:13 <Tarrasch> "This tells Haskell that c is uniquely determined from a and b. "
13:36:15 <ClarkG> dblhelix: NEVER!
13:36:17 <Tarrasch> What counts as "uniquely determined"? Is that complicated to grasp or is there a simple explanation?
13:36:27 <geheimdienst> in vim, use :%s/.../...
13:36:33 <mauke> Tarrasch: what do you not understand about it?
13:36:35 <ezyang> Do typeclasses and types share the same namespace? 
13:36:42 <Cale> Tarrasch: That for each choice of a and b, there is at most one type c for which there is an instance Mult a b c
13:36:50 <hpc> Tarrasch: would a better example help?
13:36:52 <Tarrasch> mauke, what does uniqely determined mean more precisely
13:36:53 <FunctorSalad_> Tarrasch: "if you have Mult a1 b1 c1 and Mult a2 b2 c2 and a1==a2 and b1==b2, then it follows that c1==c2"
13:36:54 <dblhelix> Tarrasch: for every a and b, there is at most one c for which Mult a b c
13:36:59 <Cale> Tarrasch: read what I wrote
13:37:06 <monochrom> "a b -> c" helps automatic type inference
13:37:23 <FunctorSalad_> this kind of relation is called a 'function' ;) (of two arguments)
13:37:54 <dblhelix> coincidentally, the very construct is dubbed *functional* dependencies ;-)
13:37:55 <monochrom> and perhaps an easier example like "class Hmm a b | a->b" is better
13:37:56 <FunctorSalad_> what fundeps have over type family functions is that you can specify more than one such relationship
13:38:57 <roconnor> BTW, is Instance Foo a | -> a  valid fundeps?
13:39:06 <dolio> Doubt it.
13:39:15 <roconnor> perhaps that is no so useful.
13:39:18 <roconnor> not
13:39:26 <FunctorSalad_> Tarrasch: you are promising to the compiler that your set of instances will have the property I just wrote
13:39:47 <FunctorSalad_> which is very useful for it to make otherwise ambiguous code welldefined
13:39:52 <aavogt> the compiler verifies that instances don't conflict
13:39:55 <Tarrasch> ok, so there can't be "instance Mult Matrix Vector Vector" then, since then is also possible that there is "instance Mult Matrix Vector Matrix", which is contradicting what you said, FunctorSalad_ , is that right?
13:39:59 <FunctorSalad_> as explained in the manual entry for the Mult example :)
13:39:59 <dolio> I'm not sure why you'd want to use 'Foo a => ...' instead of just specifying the one instance of Foo.
13:40:09 <FunctorSalad_> aavogt: yes
13:40:34 <hpc> Tarrasch: here's a better example of fundeps: expanding number overflows into a larger structure
13:40:34 <aavogt> FunctorSalad_: so it's not much of a promise.. it's more like you're saying that there are less possible instances
13:40:46 <roconnor> dolio: Ya.  I was thinking it could be used to make closed instances, but it can only make trival closed instances with at most 1 instance.
13:40:50 <hpc> Tarrasch: class Expandable a b | a -> b where
13:40:57 <FunctorSalad_> aavogt: hmm, I mean the type-inferer can just take your word for it
13:40:58 <hpc> Tarrasch:   expand :: a -> b
13:41:02 * edwardk waves hello.
13:41:04 <FunctorSalad_> but another check does verify it
13:41:14 <hpc> Tarrasch: so one instance would be Int -> Integer
13:41:26 <copumpkin> roconnor: you can make closed instances with type equality
13:41:30 <FunctorSalad_> Tarrasch: it'd be illegal to have both of those instances
13:41:30 <Tarrasch> hpc, I'm following you ...
13:41:36 <edwardk> hpc: a typeclass for embeddings?
13:41:41 <copumpkin> omg an edwardk
13:41:49 <edwardk> omg a copumpkin
13:41:51 <dolio> roconnor: Now, if we had non-type parameters, you could do 'class Foo (k :: Fin n) a | k -> a where ...'.
13:41:58 <geheimdienst> edwardk, i thought wave is getting discontinued
13:42:11 <hpc> Integer is the logical extension of Int; it is an Int that just goes further
13:42:19 <hpc> another would be Float -> Double
13:42:31 <edwardk> geheimdienst: erm. yes, it is. not sure how that comes up in this context though ;)
13:42:50 <hpc> but you can only expand from a structure to another with a larger bound that is otherwise identical
13:43:00 <hpc> so expanding Int can only yield an Integer
13:43:24 <copumpkin> hpc: what can expanding Int8 yield?
13:43:27 <hpc> your first type parameter, Int, specifies the other type, Int
13:43:28 <edwardk> hpc: there are plenty of possible embeddings though, one isn't always necessarily canonical
13:43:30 <Tarrasch> FunctorSalad_, ah ok, I think I understand then.
13:43:30 <hpc> er, Integer
13:43:35 <copumpkin> Int16, Int32, Int64, Integer?
13:43:40 <hpc> edwardk: i know, but as an example
13:43:56 <copumpkin> hpc: what about Int64 on 32-bit systems? :)
13:43:57 <Tarrasch> hpc, but then I can't define: "instance Float SuperDouble" (superdouble is a bigger double)
13:44:17 <hpc> Tarrasch: yeah, this was just an example to make it easier to understand
13:44:21 <edwardk> hpc: what fundeps are you using? i wasn't here until after the conversation started
13:44:23 <FunctorSalad_> Tarrasch: this is useful for type inference mostly because typeclasses are 'open-world', so even if your code does have the property expressed by the fundep, ghc can't know you won't break the property in the future, without fundeps
13:44:26 <ezyang> Hmm. Let's say I have a phantom type "data Node n = ..." and I want to make this a type family now. How do I do the phantom type? 
13:44:31 <aavogt> there should be a feature:  given these instances what's the most restrictive fundep you can have on that class?
13:44:41 <geheimdienst> edwardk, i was just being silly. a weak pun on you "waving" hello. "ha ha. hua hua. that's very funny geheimdienst. why don't you get back to work and stop bothering us"
13:44:45 <Tarrasch> edwardk, he's just helping me with understanding
13:44:48 <copumpkin> ezyang: a data family??
13:44:58 <FunctorSalad_> aavogt: I meant they go beyond just checking the fundep in that sense
13:44:59 <hpc> edwardk: class Expandable a b | a -> b where expand :: a -> b
13:45:00 <copumpkin> ezyang: you just don't match on the phantom type, if you don't care about it
13:45:01 <edwardk> geheimdienst: aha!
13:45:08 <copumpkin> ezyang: nothing special about phantomness other than you don't use it
13:45:09 <ezyang> Well, I kind of do care about it 
13:45:18 <copumpkin> ezyang: if you do care, match on it :)
13:45:20 <ezyang> So I wrote data Node n :: * -> *, and GHC complains that n doesn't exist 
13:45:33 <edwardk> ezyang: well, you can't use the phantom type for safety if you swap to a type family.
13:45:37 <ezyang> (not in scope: type variable 'n') 
13:45:39 <hpc> edwardk: where expand takes something like Int and turns it into Integer
13:45:44 <hpc> edwardk: it's just a teaching aid
13:45:45 <ezyang> edwardk: Really? Balls! 
13:46:00 <copumpkin> a data family though?
13:46:15 <edwardk> ezyang: a data family Foo gives you Foo a ~ Foo b implies a ~ b, a type family Foo does not. that is the very point of the distinction!
13:46:43 <edwardk> type families only give you a ~ b implies Foo a ~ Foo b. data families go both ways
13:46:55 <Tarrasch> isn't GADTs the cure for getting rid of phantom types-variables?
13:47:07 <FunctorSalad_> btw that's another plus of fundeps... they let you express what edwardk just said without forcing you to make up new data-types
13:47:13 <edwardk> Tarrasch: no. you sometimes want them there as well.
13:47:24 <copumpkin> Tarrasch: hm, phantom types aren't a malady
13:47:26 <ezyang> Hmmm 
13:47:38 <edwardk> i love my phantom types ;)
13:47:55 <FunctorSalad_> my fake plastic types....
13:48:05 <copumpkin> lol
13:48:17 <copumpkin> damn you, now I want to listen to that song
13:48:23 <FunctorSalad_> :)
13:48:44 <ezyang> This is going to be a learning experience for me, I can tell. 
13:48:46 <edwardk> ezyang: consider type family Foo a :: *; type instance Foo Int = Bool; type instance Foo Word = Bool -- Foo Int ~ Foo Word, but Int ~ Word obviously fails
13:49:01 <ezyang> I superficially understand that fact. 
13:49:21 <edwardk> ezyang: just like how you could say: type Foo a = Bool -- Foo Int ~ Foo Word, but Int ~ Word doesn't hold.
13:49:37 <edwardk> gotta run
13:49:43 <dfkjjkfd> what is ~?
13:49:49 <ezyang> bye bye 
13:50:40 <copumpkin> type equality
13:50:51 <dfkjjkfd> thx
13:51:07 <ezyang> Maybe I need more type variables 
13:51:50 <copumpkin> ezyang: if you give a bigger example maybe we can halp!
13:52:30 <ezyang> Yeah... 
13:52:39 <roconnor> @type foldr
13:52:41 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:53:09 <roconnor> @type foldl
13:53:10 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:53:13 <hpc> :t (foldr .) . return
13:53:14 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => (a -> b -> b) -> f (b -> [a] -> b)
13:53:34 <jmcarthur> i'm looking for research relating to limited forms of dependent types (as opposed to full blown, i mean). does anybody know of any? of course haskell has a few things that can be made to resemble dependent types. things just being to get complicated.
13:53:53 <copumpkin> jmcarthur: DML?
13:53:57 <copumpkin> jmcarthur: ATS
13:54:12 <jmcarthur> copumpkin: i have looked at DML, but not ATS. thanks
13:54:14 <copumpkin> and other papers by xi
13:54:20 <jmcarthur> i thought ATS was full blown though? was i wrong?
13:54:34 <copumpkin> yeah :P
13:54:44 <dolio> ATS has a full static language, but it's separate from the dynamic language.
13:54:45 <monochrom> ATS is full blown and more verbose than Agda.
13:55:06 <jmcarthur> ah, so it's "type-level values" etc.?
13:55:08 <monochrom> But generally you can't go wrong with Hongwei Xi :)
13:55:10 <dolio> It's kind of like if you made type programming in GHC nicer.
13:55:25 <copumpkin> and gave yourself horrible syntax and inline c
13:55:31 <dolio> Yes, type-level values.
13:55:34 <ezyang> Ok, here is a really stripped down set of functions and data types I'd like to typeclassify http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28951#a28951 
13:56:09 <copumpkin> ezyang: "typeclassify" how?
13:56:57 <ezyang> I have two separate implementations for how Network/Node/NT/runNT work 
13:57:06 <ezyang> but I'd like to expose a common interface 
13:57:24 <copumpkin> class ZOMG a where data Network a :: *; data Node n a :: *; runNT :: (forall n. NT n a) -> Network ?
13:57:33 <roconnor> ezyang: type classes or modules.
13:57:37 <ezyang> but that doesn't work... 
13:57:39 <copumpkin> oh you can't put an n in there
13:57:42 <ezyang> roconnor: Type classes 
13:57:54 <monochrom> module is so passe
13:57:56 <copumpkin> ezyang: you could with an additional typeclass parameter (as in MPTC)
13:58:08 <dolio> jmcarthur: For instance, in their verified sort example, I believe they create a type of lists indexed by 'type'-level lists of similar value.
13:58:09 <ezyang> copumpkin: I was thinking of that. Will that have the desired effect? 
13:58:20 <copumpkin> ezyang: I think so
13:58:24 <dolio> So [1, 2, 3] :: List [1, 2, 3].
13:58:25 <ezyang> ok. 
13:58:29 <jmcarthur> dolio: interesting. thanks
13:58:42 <roconnor> ezyang: what do Nodes have to do with anything?
13:59:15 <dolio> And you existentially quantify over the type-level list to make a more useful value-level type.
13:59:18 <jmcarthur> so ATS is basically everything except for the ability to lift terms to the type level
13:59:46 <ezyang> roconnor: The implementations are all elided. You could think of it as a node that is attached to a particular netowrk. 
14:00:17 <roconnor> ezyang: you are missing functions that are part of the interface in your paste?
14:00:37 <ezyang> Yeah. 
14:00:46 <ezyang> So there'll be a function like combine :: Node n -> Node n -> NT n (Node n) 
14:01:06 <roconnor> anything wrong with class Foo Network Node NT where ... ?
14:01:27 <ezyang> That'd be fundep style, no? 
14:01:35 <roconnor> ok
14:01:47 <ezyang> This is really fascinating! 
14:01:50 <roconnor> probably data/type families would be more natural I guess
14:02:00 <ezyang> My first foray into type family programming. 
14:02:00 <roconnor> not that I've ever used them.
14:02:06 <ezyang> Poor man's module system or something. 
14:02:32 <roconnor> rumour told me that fun deps and data/type familes are equally expressive
14:02:36 <roconnor> in a technical sense
14:02:44 <ezyang> that's what I heard too. 
14:03:06 <ezyang> Now I'm kind of wondering if fundeps would not be more natural 
14:03:15 <ezyang> I guess they'd be icky on the ui side. 
14:03:22 <hpc> well, i grok fundeps but not type families
14:03:55 <ezyang> Oh, here's another constraint: NT needs to be a Monad. 
14:03:57 <roconnor> ezyang: well I'm guessing you have a principle type amoung Network Node and NT that imply the values of the others.
14:04:14 <roconnor> ezyang: type families feels like it should be natural for that class of function
14:04:14 <ezyang> Yep. 
14:04:33 <roconnor> OTHO, in my geometric algerbra work I had that any two of three parameter implies the type of the third
14:04:40 <roconnor> that seemed more natural to use fundeps for.
14:05:31 <Paczesiowa> what was the name of the compiler that could read a whole library and output it as a single module?
14:05:39 <monadic_kid> if you know a bit about c++ templates, then type families aren't that hard to grok
14:06:43 <fatuhoku> what on earth does "grok" mean, dude :P
14:06:49 <roconnor> fatuhoku: understand
14:07:01 <fatuhoku> cool =]
14:07:19 <monadic_kid> roconnor: if you use fun deps to do type computations the language is quite like a logic language, type families are functional style
14:07:20 <mauke> "grok" means a deep understanding
14:07:32 <int80_h> I have this let statement
14:07:34 <int80_h> let connection = connect [CAdbname "tutorialDB"]
14:07:38 <int80_h> I want to be able to pass connection to a function
14:07:41 <int80_h> but how do I determine it's type?
14:07:42 <roconnor> monadic_kid: yep, that is my impression
14:07:52 <fatuhoku> mauke: wow, i'm surprised, it's actually a word!
14:08:05 <mauke> fatuhoku: http://www.catb.org/~esr/jargon/html/G/grok.html
14:08:09 <Paczesiowa> int80_h: don't you mean constrain?
14:08:32 <ezyang> Here's a question: 
14:08:33 <monadic_kid> roconnor: i think that is the only reason why type families came into being because they are functional instead of logic
14:08:44 <roconnor> monadic_kid: I think it is more than that.
14:08:56 <int80_h>  Paczesiowa : let's say that's what I mean. I've still got some fuzzy in my head concerning the type system.
14:09:07 <ezyang> One of my type/data families needs to be monadic. Can I put it at that level, or do I have to add the constraint to any function that tries to use that type? 
14:09:36 <roconnor> monadic_kid: I kinda have the impression it has something to do with GADTs
14:09:38 <FunctorSalad_> fundep functions are exactly like the proof that you don't really need functions and terms in first-order predicate logic...
14:09:42 <Paczesiowa> int80_h: let connection = connect [...] :: MyType
14:09:45 <FunctorSalad_> (that you can reduce it to relations)
14:10:17 <monadic_kid> well a function is a relation
14:10:27 <monadic_kid> in set theory
14:10:30 <FunctorSalad_> yes, I meant function symbols
14:11:01 <int80_h>  Paczesiowa : Not in scope: type constructor or class `MyType'
14:11:08 <monadic_kid> I can't remember exactly now but, Set -> Relation -> Function
14:11:22 <Tarrasch> ezyang, hmm, perhaps you can do like they have in the Traversable class?
14:11:27 <monadic_kid> Sequence goes in there some where
14:11:39 <monadic_kid> is it Function -> Seuquence?
14:11:50 <Paczesiowa> int80_h: wait, so you don't know that type?
14:11:53 <int80_h> Paczesiowa: connect comes from a library I am using. Can I not just load the program into ghci and find the type somehow?
14:11:54 <Paczesiowa> int80_h: ask ghci
14:12:04 <int80_h> yes, how do I ask ghci, this is my question.
14:12:11 <int80_h> using :t doesn't work
14:12:12 <Paczesiowa> :type connect 
14:12:21 <Paczesiowa> int80_h: what's the error
14:12:37 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/50d488c42adbe90e
14:12:55 <int80_h> oops hold on.
14:13:29 <int80_h> okay so I type "main" at the prompt
14:13:36 <int80_h> and it loads all dependencies
14:13:38 <int80_h> then
14:13:44 <ezyang> Traversable doesn't use type families, iirc? 
14:13:46 <FunctorSalad_> monadic_kid: the proof I have in mind isn't a semantic one in set-theory, just that you can translate first-order logic with function symbols into one with predicate symbols...
14:13:51 <int80_h> erm, nevermind
14:14:03 <int80_h> maybe I was doing it wrong to begin with. :type works fine
14:14:07 <FunctorSalad_> by introducing an existential variable for all the 'intermediate results' in terms
14:14:25 <monadic_kid> ezyang: no
14:19:43 <Tarrasch> ezyang, sorry, I just "thought wrong"
14:20:37 <ezyang> Hm, adding it to the function doesn't seem to be too troublesome. 
14:20:42 <ezyang> This is coming along nicely -) 
14:20:50 <Tarrasch> ezyang, What I meant was the functions in the class Traversable have class-constraints themselves, but that's probably something unrelated
14:21:13 <Tarrasch> ezyang, or what do I know, maybe it helps :)
14:21:34 <int80_h>  Paczesiowa: I'm getting my original error again for some reason 'not in scope'
14:22:28 <Paczesiowa> int80_h: you aren't using literally 'MyType', are you?
14:22:32 <Tarrasch> Anyway, good-night everybody :)
14:22:45 <int80_h> Paczesiow: heh no no not anymore
14:23:05 <int80_h> Paczesiow: doing ":type connection"
14:23:11 <sshc> When should unsafePerformIO be used?
14:23:14 <int80_h> I don't know what changed
14:23:30 <monochrom> between 12am and 1am
14:23:30 <Paczesiowa> int80_h: so what's the error?
14:24:05 <int80_h> Paczesiowa: not in scope 'connection'
14:24:15 <int80_h> the line in question is
14:24:25 <int80_h> let connection = connect [CAdbname "tutorialDB"]
14:24:33 <Paczesiowa> int80_h: I'd say you haven't loaded correct modules
14:24:42 <Paczesiowa> int80_h: what's the prompt?
14:25:05 <int80_h> Prelude Main>
14:25:31 <int80_h> huh, yeah why didn't it import the modules I have at the top of my program?
14:25:39 <int80_h> that may be it
14:25:49 <Paczesiowa> int80_h: try quitting ghci and loading it again
14:26:07 <Paczesiowa> int80_h: it sometimes acts funny if it fails to compile at the first try
14:26:10 <monochrom> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/ghci-compiled.html
14:31:21 <BMeph> sshc: unsafePerformIO "should" never be used. However, there are times when what you're getting the computer to do can't be done without it. This sugggests the need to rethink the language, but there it is...
14:32:04 <roconnor> isn't unsafePerformIO used in the FFI?
14:33:02 <Paczesiowa>  unfortunately
14:33:34 <Heffalump> BMeph: I don't agree that it suggests the need to rethink the language.
14:33:53 <Heffalump> it's just a recognition that you need to step outside the "guaranteed safe by the compiler" area
14:34:00 <monadic_kid> roconnor: you can use it to esacpe the IO monad, not just for ffi
14:34:35 <Paczesiowa> he couldn't take it...
14:35:25 <Phyx-> you can have guards in instance declarations right?
14:36:26 <Phyx-> @hoogle not elem
14:36:26 <Phyx-> stupid splits
14:36:49 <monochrom> yes you can have guards inside instance declarations
14:37:54 <int80_h> okay I think I have a function definition correct. insertPair :: (ConnectA Session) -> (String, Int) -> ()
14:38:16 <mauke> insertPair _ _ = ()
14:38:27 <int80_h> the next thing I need to do, prior to a pattern match, is create a let binding to the first value in the tuple, and another let binding for the second value int he tuple. I'm getting the syntax wrong. Could someone help? 
14:38:39 <triyo> holy crap
14:40:23 <Paczesiowa> you can't pattern match on the argument to a function, you have to provide it
14:42:38 <triyo> int80_h: can you show snippet of what you trying to do?
14:43:12 <geheimdienst> for the code they teach in RWH, where can i find the actual .hs files?
14:43:18 <int80_h> triyo : yes but I decided I needed to use a where binding instead. pasting now.
14:44:10 <triyo> geheimdienst: http://www.realworldhaskell.org/blog/
14:45:27 <triyo> actually, http://www.haskell.org/haskellwiki/Real_World_Haskell
14:45:44 <triyo> or direct link to zip file: http://examples.oreilly.com/9780596514983/rwh-examples2.zip
14:45:54 <EvanR-work> clearly where is superior to let _ = _ in _, but im wondering about style tips for a large let block? how to indent and what to do with 'in'
14:46:07 <int80_h> triyo : my code now compiles. I just changed the last type in the definition to what was inferred. But I'm sure to be having problems soon when I actually try and use the function
14:46:24 <yokto> Is there a tool that automatically creates haskell-c bindings and needs as input only the header files? Makes a Storeable corresponding to every c-struct? (is that possible?) if not why not?
14:46:32 <geheimdienst> triyo, thanks a lot. it's the zip file that i couldn't find
14:48:23 <monadic_kid> yokto: c2hs, hs2c are tools that help but do not completely automate everything
14:48:39 <int80_h> :t map
14:48:52 <int80_h> @type map
14:48:54 <EvanR-work> maybe lambdabot was netsplitted
14:48:57 <monadic_kid> yokto:none of them automatically generate storable instances
14:49:03 <yokto> ok but there gtk is automated isn't it? what does it use?
14:49:25 <yokto> ok (but it would be possible to make storables for every struct?)
14:50:31 <int80_h> okay here is my challenge
14:50:51 <EvanR-work> int80_h: map :: (a -> b) -> [a] -> [b]
14:50:55 <EvanR-work> btw
14:50:55 <monochrom> EvanR-work: my favourite is http://www.vex.net/~trebla/tmp/let.txt
14:51:06 <triyo> EvanR-work: regarding style tips have a look at this seciotn in RWH -> http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html#id624278
14:51:10 <EvanR-work> monochrom: forbidden
14:51:15 <monochrom> fixed now
14:51:19 <ezyang> How common is it to define a typeclass with only type families in it, and then make a typesubclass with the actual functions? 
14:51:32 <EvanR-work> monochrom: ah good
14:51:32 <int80_h> I need to map function foo over list bar. function foo also wants a let binding baz as it's first argument. but map only takes a list. Is there something like map that will take an arbitary type along with a list?
14:51:38 <monadic_kid> yokto: You have the tools to portably define ptr offets, sizeof, alignment for Storable instance using c2hs/hs2c but you can't automatically generate the instance completely
14:52:08 <adnap_> int80_h: map (foo baz) xs
14:52:26 <EvanR-work> map (foo baz) bar ;)
14:52:31 <monadic_kid> yokto: those use  header files, i don't know what gtk bindings do
14:52:33 <Zao> Stuff like bindings-dsl can make the generation less painful.
14:52:35 <ddarius> ezyang: Type families haven't been around long enough for anything to be particularly common.
14:52:43 <ezyang> ddarius: ok-dokey 
14:52:51 <yokto> because it's not possible or because no one has done it?
14:53:10 <EvanR-work> monochrom: sure does have stuff indented way the hell over ;)
14:53:17 <monadic_kid> yokto: probably no-one has done it
14:53:27 <int80_h> EvanR-work : is this an example of partial application?
14:53:46 <EvanR-work> int80_h: you can call it that, but its just normal application (of one argument)
14:53:55 <EvanR-work> all functions take exactly one arg
14:54:12 <EvanR-work> foo :: X -> Y -> Z
14:54:16 <EvanR-work> foo baz :: Y -> Z
14:54:33 <triyo> hence the -> in between each param
14:55:17 <monadic_kid> yokto: okay thinking I can see problems trying to do it
14:55:26 <monadic_kid> yokto: *thinking about it
14:55:37 <EvanR-work> so its not that haskell allows partial evaluation, its that it does not support multiparameter functions ;)
14:56:08 <jedai> EvanR-work: it does ! let add (a,b) = a + b 
14:56:26 <monochrom> that is still one parameter
14:56:29 <EvanR-work> well it takes one parameter of type (A,B)
14:56:38 <monochrom> don't be brainwashed by c
14:56:44 <EvanR-work> of type (Num a) => (a,a) ;)
14:57:04 <jedai> EvanR-work: Well of course but other languages do the same thing and then pretends to support multiparameter
14:57:14 <yokto> monadic_kid: such as?
14:57:23 <monochrom> other languages fail to support tuples
14:57:34 <jedai> When they just restrict tuple types to this special case ;)
14:57:41 <EvanR-work> heh, thats pointless
14:58:05 <ddarius> Clean has a subtle distinction between, (a,b) -> c, a -> b -> c, and a b -> c
14:58:13 <monochrom> the question you should ask of other languages is: why allow tuples passed in but not returned
14:58:22 <ddarius> (and also a huge syntactic clash)
14:58:28 <jedai> monochrom: true :)
14:58:50 <aavogt> EvanR-work: it's probably better to consider what you call "partial evaluation", "partial application" instead, since you're still not specifying any sort of evaluation order
14:58:54 <EvanR-work> some support 'multiple returns' as well as 'tuple returns'
14:58:59 <jedai> ddarius: what's the distinction, can it be explained simply ?
14:59:14 <monochrom> don't be taken in by other languages
14:59:18 <chrisdone> monochrom: indeed, I really miss tuples in C# (I think new versions have it)
14:59:38 <Miron> 4.0 has tuples, but they're a reference type, not a value type.
14:59:46 <ddarius> chrisdone: You can make a pair type easily enough.
14:59:49 <chrisdone> monochrom: (and new Tuple<1,2> /= (1,2))
14:59:55 <ddarius> You could even abuse KeyValuePair
14:59:57 <EvanR-work> chrisdone: you can use pair objects, and they your coworkers hate you ;)
15:00:01 * chrisdone spews
15:00:04 <jedai> EvanR-work: well that's often not completely worthless since it allows to explicitly optimise for this usage
15:00:05 <EvanR-work> then*
15:00:28 <EvanR-work> jedai: im sure you can optimize anyway
15:01:20 <EvanR-work> let (x,y) = a `divMod` b; <something with x y> hopefully doesnt need to create a temporary tuple
15:01:20 <monadic_kid> yokto: you couldl probably do it but what you generate may no be completely ideal. So you would automatically generate a record type which mirrors the C-struct, now you need to figure out the best way to map types, there might be a 1-to-1 mapping or one that is more high-level like an hand-written API, with enums/c-defines there a few ways you could do it. If you don't have 1-to-1 mapping (and you wont) then you're going to need functio
15:01:20 <monadic_kid> ns fromIntegral so now the tools needs to know about types. There are probably more complications
15:01:43 <jedai> EvanR-work: It seems so and GHC does it when it can but I heard it's non-trivial (mostly it always try to with (# #) tuples but not always in other cases)
15:01:48 <monadic_kid> *might not be a 1-to-1 mapping
15:02:02 <EvanR-work> whats a (# #) tuple
15:02:16 <jedai> EvanR-work: an unboxed tuple
15:02:30 <jedai> EvanR-work: GHC-specific extension
15:02:48 <EvanR-work> anyway, static typing should provide the same or more opportunity to optimize tuple returns as if they were multiple returns
15:02:59 <EvanR-work> in some other language
15:03:23 <aavogt> EvanR-work: you can't have lazy unboxed tuples as far as I can tell
15:03:24 <jeff_s_> I have a list of items, and I want to map over them in the IO monad and concatenate the results. Is there a way besides concatMapM f l = (liftM concat) (mapM f l), maybe using built-in operations on monads that I'm not familiar with? Maybe lifting the list monad into the IO monad, I'm not sure if I'm thinking correctly or if that would be any simpler.
15:03:57 <EvanR-work> aavogt: that makes sense, if you want unboxed seems like you want strict?
15:04:09 <yokto> yes ok - i think i m going to try it - do you know a good tool to parse .h files and get info out of them
15:04:26 <monochrom> concatMapM f l = (liftM concat) (mapM f l)  is good enough
15:04:31 <jedai> EvanR-work: the tricky bit is that multiple returns is more like unboxed tuple returns than boxed tuple
15:05:02 <jeff_s_> OK thanks
15:05:33 <jeff_s_> I was kind of hoping for some monadic magic but I'll live. :-)
15:05:38 <sshc> How can unsafePerformIO be used to define unsafeCoerce?
15:05:39 <jedai> EvanR-work: So GHC can't always optimise this as much as we would like (which is why using unboxed pairs or tuples explicitly is sometimes a good idea for optimisation)
15:05:47 <ddarius> jedai: I'm not sure there is an observable difference but I believe Clean gives more operational guarantees and there is an operational difference.
15:06:07 <monadic_kid> yokto: i think there is a few libraries you could use like this one: http://hackage.haskell.org/package/language-c
15:06:08 <mauke> sshc: make a polymorphic IORef
15:06:11 <EvanR-work> jedai: that makes sense
15:06:25 <jedai> ddarius: Thanks, maybe I'll try Clean again sometimes, I've forgotten almost everything from my last try
15:06:26 <yokto> cool
15:06:50 <ddarius> jedai: I probably wouldn't bother.
15:06:53 <aristid> @src mapM
15:06:56 <EvanR-work> use an unboxed tuple to optimize, rather than define multiple returns as part of the language ;)
15:07:07 <aristid> lambdabot :(
15:07:19 <mauke> preflex: seen lambdabot
15:07:20 <preflex>  lambdabot was last seen on #haskell-blah 54 minutes and 48 seconds ago, saying:   True
15:07:22 <EvanR-work> @slap lambdabot
15:07:35 <EvanR-work> True. True.
15:07:36 <ddarius> preflex: be lambdabot
15:07:36 <preflex>  @fact preflex
15:08:12 <monochrom> lambdabot has found truth
15:08:27 <copumpkin> Cale will come to our rescue
15:08:43 <EvanR-work> data Bool = True | False
15:09:01 <c_wraith> that's backwards, I think :)
15:09:11 <mauke> data Bool = True | False | FileNotFound
15:09:11 <ddarius> Mustard greens will come to our rescue
15:09:16 <EvanR-work> lol
15:09:21 <ddarius> c_wraith: Correct.
15:09:37 <EvanR-work> Abort | Retry | Fail
15:09:39 * ezyang asks for forgiveness. 
15:09:44 <ezyang> For I have used a Henning-ism. 
15:09:47 <ezyang> data T 
15:10:12 <c_wraith> ... Is it at least not part of the public interface?
15:10:16 <aavogt> ddarius: you wouldn't be able to tell from some code, if the Ord Enum and so on were defined to be the same?
15:10:24 <ezyang> c_wraith: It is part of the public interface. 
15:10:34 <c_wraith> repent
15:10:36 <ezyang> It's an empty type you use to select the appropriate typeclass. 
15:10:41 <aavogt>  instance C T T T
15:10:42 <ddarius> aavogt: Of course you wouldn't.
15:10:56 <EvanR-work> T_T
15:11:22 * ezyang repents 
15:11:26 <ezyang> Time to find another name. 
15:11:43 <c_wraith> :)
15:11:48 <monochrom> instance C P P P
15:12:00 <monochrom> oh well, should be C C C P
15:12:14 <EvanR-work> â­ â­ â­
15:13:14 <Adamant> EvanR-work: showing your support for the glorious people's republic of academia? :P
15:13:38 <fatuhuku> HAHA!
15:13:40 <EvanR-work> web workers of the world unite
15:14:42 <Adamant> you have nothing to lose but your overtime, and voting rights
15:15:59 <monochrom> web workers would be holding keyboards and mice
15:16:25 <chrisdone> teehee, emacs and its single threadedness
15:16:37 <monochrom> yeah, my own gripe about emacs
15:16:43 <chrisdone> I just generated hoogle files for all my installed packages
15:16:47 <medfly> why would it need to be multi threaded. it's a text editor
15:16:48 <chrisdone> took about 5 minutes
15:16:52 <ezyang> I wish Haskell had more kinds... 
15:16:59 <copumpkin> ezyang: 100!
15:17:03 <copumpkin> OVER 9000!!?!
15:17:05 <adnap_> How do you use cabal to view source code?
15:17:09 <Adamant> eh, I feel sorry for the African countries that put a AK on their flag. what are they gonna do 100 years from now when laser rifles are de rigeur?
15:17:24 <ddarius> > product [2..100]
15:17:26 <medfly> modify it slightly
15:17:28 <ezyang> Until then, I shall not rest !! 
15:17:46 <EvanR-work> Adamant: there are countries with ancient tribal shields and spears, so what ;)
15:17:50 <ezyang> More practically, does Haddock have any facilities for documenting kinds? 
15:17:56 <aristid> 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
15:18:17 <Adamant> EvanR-work: I know, but it's funnier this way :P
15:18:22 <chrisdone> mwfuhaha. robust software is robust. it worked
15:18:44 <chrisdone> now I just need to write something to combine all the .txt files and then do a hoogle --convert and I can hoogle my installed codebase ^___________ ^
15:19:07 <chrisdone> programming nirvana here I come!
15:19:52 <dolio> Oh shit, monochrom shows up in comp.lang.haskell.
15:20:04 <Adamant> there's a comp.lang.haskell?
15:20:08 <dolio> There is.
15:20:15 <adnap_> Did anyone see my question?
15:20:17 <monochrom> not the first time
15:20:33 <Adamant> are folks on better behavior than in comp.lang.lisp?
15:20:38 <BMeph> exyang; Do you wish Haskell had Habit's kinds? 
15:20:45 <chrisdone> adnap: I don't think so... where was it?
15:20:46 * BMeph does...
15:20:54 <monochrom> first time was probably http://groups.google.com/group/comp.lang.haskell/msg/a38908521c5a6e6b
15:20:55 <luite> oh I didn't know that there were newsgroups that didn't start with alt.binaries, is that something new? ;)
15:21:10 <adnap> I want to know how you can use cabal to read the source code of a package?
15:21:41 <Saizan_> cabal unpack foo
15:21:42 <chrisdone> by read you mean, what? the .hs files? hscolour'd source?
15:21:42 <ezyang> BMeph: Would be kind of useful :^) 
15:21:43 <dolio> Wow, has it really been around 3 years already?
15:21:46 <dolio> Time flies.
15:21:56 <ezyang> Though right now all I want is a kind that indicates an empty type. 
15:22:02 <monochrom> since comp.lang.haskell is not famous, people there behave very well. avoid success at all costs
15:22:23 <chrisdone> does xah lee post there?
15:22:28 <Saizan_> and you can run "cabal configure; cabal haddock --hyperlink-source" from inside the directory, if you prefer
15:22:56 <monochrom> whereas comp.lang.lisp and reddit are famous and so people there are psychos. xah lee is not in comp.lang.haskell, just comp.lang.functional and so on
15:23:11 <Adamant> monochrom: sounds about right.
15:23:36 <mauke> (xah lee)--
15:24:06 <chrisdone> good
15:24:13 <chrisdone> mauke: where's my poppavic quotes?
15:24:24 <mauke> preflex: quote PoppaVic
15:24:25 <preflex>  <PoppaVic> dude, you need to stop hollering and either spend more verbage explaining it to them or just DON'T.
15:24:31 * chrisdone beams
15:25:01 <EvanR-work> hes a haskeller?
15:25:02 <Draconx|Laptop> hm, PoppaVic quotes aren't as funny in #haskell.
15:25:10 <monochrom> let's start alt.binary.haskell.lambdabot.pics.bikini
15:25:25 <monochrom> err, s/binary/binaries/
15:25:28 <Adamant> her naughty bits are showing.
15:25:46 <Adamant> ba-dum-ch
15:25:47 <chrisdone> mauke: just to be clear, PoppaVic isn't a long term AI experiment of yours gone wrong? ;D
15:26:09 <mauke> chrisdone: AFAIK no
15:26:13 <chrisdone> haha
15:26:14 <dolio> preflex: be PoppaVic
15:26:15 <preflex>  yer back to that Ultimate Interface. I don't control it. And terms are bandied about all over where you need to ask and research.
15:26:34 <chrisdone> sublime
15:26:39 <Adamant> preflex: be preflex
15:26:39 <preflex>  no quotes found for preflex
15:35:18 <chrisdone> hs, dist/build/Text/Regex/TDFA/CorePattern.o )
15:35:18 <chrisdone> dsMDo [ans{v atVw} [lid]]
15:35:18 <chrisdone> dsMDo
15:35:18 <chrisdone>     [accepts{v atVC} [lid], needsTags{v atVE} [lid], a{v atVF} [lid],
15:35:21 <chrisdone>      b{v atVG} [lid], mOrbit{v atVH} [lid], q{v atVI} [lid],
15:35:24 <chrisdone>      resetOrbitTags{v atVJ} [lid]]
15:35:27 <chrisdone>  get these type of "messages" on compiling some libraries
15:35:40 <chrisdone> is it an alien language being broadcast through my machine?
15:37:08 <copumpkin> it's debugging info
15:37:15 <copumpkin> not sure why it's there, but several people have noticed it
15:43:08 <carter> what does it mean when i get the message cabal: cannot configure QuickCheck-2.1.1.1. It requires ghc -any 
15:43:45 <chrisdone> this question comes up all the time and yet I never remember the answer
15:44:07 <carter> i know i've seen this before
15:44:19 <chrisdone> ghc-pkg list shows what?
15:45:16 <carter>  ghc-6.12.3 
15:46:03 <carter> the context being  that i'm trying to cabal install gitit
15:46:29 <carter> and library versioning woes attack
15:48:01 <chrisdone> you think you've got problems? I removed the time library and now everything is broke and reinstalling it doesn't help :p
15:48:34 <carter> i think in that case you want to make /.ghc package stuff forget everything
15:49:03 <chrisdone> how do you do that?
15:49:39 <carter> when you do the reinstall, delet both the .ghc and .cabal folders
15:49:50 <ClarkG> This might be a stupid question, but, given SMTP server information, how do I send an email with haskell?
15:49:52 <chrisdone> oh, I thought you had a way to do it without reinstalling
15:50:01 <chrisdone> ClarkG: check the stmp libs on hackage
15:50:03 <carter> well, i must be off, but if i cant fix this i'll bug ya'll again
15:50:13 <ClarkG> sec
15:51:27 <ClarkG> is there no overview + quick start guide for this library?
15:52:11 <chrisdone> which one?
15:52:15 <ClarkG> smtp
15:52:32 <ClarkG> well, actualy
15:52:34 <ClarkG> *actually
15:52:36 <chrisdone> I don't know of a package called smtp
15:52:38 <ClarkG> any library I've seen so far
15:52:46 <ClarkG> SMTPClient
15:52:48 <ClarkG> http://hackage.haskell.org/packages/archive/SMTPClient/1.0.2/doc/html/SMTPClient.txt
15:52:53 <chrisdone> http://hackage.haskell.org/package/HaskellNet
15:52:53 <chrisdone> http://hackage.haskell.org/package/hsmtpclient
15:52:53 <chrisdone> http://hackage.haskell.org/package/simplesmtpclient
15:52:53 <chrisdone> http://hackage.haskell.org/package/SMTPClient
15:52:57 <ClarkG> Network.SMTP
15:53:08 <chrisdone> I uploaded simplesmtpclient, that's easy
15:53:42 <chrisdone> the one you're looking at has a code example
15:53:44 <chrisdone> *** bo0ts__ (~user@f053096069.adsl.alicedsl.de) has joined channel #haskell*** bo0ts__ (~user@f053096069.adsl.alicedsl.de) has joined channel #haskell
15:53:47 <ClarkG> My use case is sending an email with an attachment
15:53:47 <chrisdone> woops
15:53:51 <chrisdone> http://hackage.haskell.org/packages/archive/SMTPClient/1.0.3/doc/html/Network-SMTP-Simple.html
15:54:34 <chrisdone> doesn't look like any of them do attachments
15:54:44 <ClarkG> This angers me.
15:54:45 <ClarkG> lol
15:55:03 <chrisdone> I don't know off the top of my head how attachments are sent in smtp
15:55:10 <EvanR> ClarkG: i just did that today
15:55:15 <EvanR> attachment
15:55:21 <ClarkG> hm?
15:55:23 <EvanR> at work
15:55:36 <ClarkG> are you allowed to plop it onto hackage?
15:55:42 <chrisdone> he better be
15:55:51 <EvanR> heh. 
15:55:53 <ClarkG> lol
15:56:10 <EvanR> its almost trivial
15:56:26 <ClarkG> uh oh. gotta go. this is inconvenient.
15:56:30 <lispy1> all the magic is in the mime encoding right?
15:56:36 <EvanR> Network.SMTP.Client lets you send mail with an arbitrary body and arbitrary headers, known as OptionalField
15:56:53 * lispy1 would like an email client written in Haskell
15:57:06 <EvanR> uhm ok if youre leaving i wont bother explaining
15:57:16 <EvanR> but im here 24/7
15:57:45 <BMeph> EvanR: No, no, keep explaining, we'll make ClarkG read the chatlog to catch up... ;)
15:57:53 <EvanR> haha
15:58:11 * chrisdone sits on the carpet cross legged
15:58:17 <chrisdone> do go on
15:58:59 <monochrom> just say "I'm done"
15:59:22 <chrisdone> ~_~
15:59:56 <EvanR> step 1, use the smtp headers "Content-Type: multipart/mixed; boundary=\"--2n3fn3kjngakj4ng\"", and i guess "MIME-Version: 1.0" by utilizing OptionalField
16:00:04 * BMeph cues the Bond-"like" music...
16:00:37 <EvanR> step 2, transform your message body and list of ByteString (attachments) into a multipart message body by...
16:00:46 * BMeph thinks chris should've said that He's done...because, y'know, he IS... ;)
16:00:59 <EvanR> doing this http://en.wikipedia.org/wiki/MIME scroll down to multipart messages
16:01:11 <EvanR> the base64 part can be done with Codec.MIME.Base64
16:01:17 <monochrom> "3 easy steps to spam using haskell"
16:01:22 <EvanR> lol
16:01:57 <lucca> It's still my favorite icfpc name.  Ace of Base64.
16:01:57 <EvanR> the haskell code to generate that body with attachements is about 7 lines
16:02:37 <EvanR> or less if you are in this channel for longer than 1 year
16:05:15 <EvanR> i just used octet-stream for all but the body part, so its not really general enough or configurable for hackage
16:06:03 <chrisdone> EvanR: just make a helper function? :-)
16:06:29 <EvanR> i did that, but i didnt bring it home with me ;)
16:06:49 <EvanR> i could retype it and codepad it
16:06:59 <chrisdone> in the age of the internets we don't take things anywhere
16:07:08 * EvanR looks at EvanR-work 
16:07:16 <EvanR> lol... dcc
16:07:31 <EvanR> too bad he has to agree
16:07:40 <dfkjjkfd> /url 281
16:07:55 <EvanR> chrisdone: the internet is broken. my work is behind like 7 NATs and a firewall
16:08:04 <EvanR> the VPN doesnt work very well in linux
16:08:08 <chrisdone> EvanR: you just distracted me while I was drinking water and I choked on it. damn you :p
16:08:15 <copumpkin> EvanR: it's not secure unless it's over 9000 of them
16:08:18 <chrisdone> it came through my nose :(
16:08:24 <EvanR> roflolmao
16:09:02 <chrisdone> copumpkin: our names are equal length
16:09:02 <chrisdone> copumpkin: \o\
16:09:14 <copumpkin> :)
16:09:19 <copumpkin> except I use a proportional font in IRC
16:09:27 <EvanR> Dx
16:09:28 <chrisdone> \O_O/
16:09:42 <chrisdone> whut
16:10:00 <chrisdone> copumpkin: in Comic Sans MS? :p
16:10:06 <copumpkin> not quite :)
16:10:09 <ClarkG> or papyrus
16:10:12 <ClarkG> back, by the way.
16:10:13 <chrisdone> Comic Sans Free
16:10:54 <monochrom> proportional font makes sense so - â â are not all the same length
16:11:09 <ClarkG> oh my god I _SO_ don't want to read yet another RFC
16:11:18 <chrisdone> they're not
16:11:40 <EvanR> ClarkG: im typing some 'get you started code' ...
16:11:46 <ClarkG> thank you :)
16:11:52 <EvanR> s/ code'/' code/
16:12:06 <chrisdone> but I'm in favor of monorthography anyway
16:12:08 <monochrom> get you started code: main = TODO
16:12:17 <ClarkG> lol
16:12:19 <chrisdone> monochrom: main = error "TODO"
16:12:20 <chrisdone> :D
16:12:31 <mauke> main = undefined
16:12:39 <chrisdone> lol
16:12:44 <ClarkG> DON'T FORGET THE TYPE, LEST -Wall COMPLAIN
16:12:52 <ClarkG> main :: IO ()
16:12:52 <ClarkG> main = undefined
16:12:54 <ClarkG> much better
16:12:56 <monochrom> main :: TODO
16:13:52 <chrisdone> hlint: Found:
16:13:53 <chrisdone> main :: TODO
16:13:53 <chrisdone> Why not:
16:13:53 <chrisdone> main :: IO ()
16:13:54 * BMeph wonders why he wanted to suggest using the -larry lib when compiling with -Wall...
16:14:03 <monochrom> did you know that you can put the type sig after. in fact almost anywhere.
16:14:22 <Martty> i wish i could code in a language that merged the good things from c++ and haskell
16:14:30 <chrisdone> monochrom: did you also know you can do more than one with comma separation
16:14:31 <Martty> wait.. is that python!?
16:14:32 <ClarkG> good things in C++ that haskell doesn't have?
16:14:43 <ClarkG> you gotta let me in on those
16:14:45 <chrisdone> main, charlie, cheese :: IO ()
16:14:52 <Martty> imperative programming :(
16:15:00 <ClarkG> LOL.
16:15:03 <Martty> :D
16:15:04 <ClarkG> "do" should just drop you into C++
16:15:09 <ClarkG> problem solve
16:15:11 <ClarkG> *solved
16:15:15 <ClarkG> there is NO problem with this solution
16:15:41 <chrisdone> Haskell's imperative programming is entirely preferable
16:16:02 <ClarkG> I haven't done enough of it to have an opinion
16:16:03 <chrisdone> it's well typed and explicit, it can be controlled
16:16:13 <ClarkG> C++ was what I did before haskell though. I did it until I hated it :)
16:16:18 <Martty> you can't make real programs without the imperative part of haskell.. can you?
16:16:27 <ClarkG> no, ofc not
16:16:33 <ClarkG> you NEED side effects
16:16:36 <EvanR> k codepad not responding
16:16:39 <ClarkG> uh oh
16:16:43 <dibblego> no you don't
16:16:54 <ClarkG> how will you communicate with the outside world?
16:16:58 <copumpkin> chrisdone: http://snapplr.com/m0rh
16:17:00 <ClarkG> a program in isolation is useless
16:17:06 <dibblego> haskell does not have side-effects
16:17:15 <chrisdone> > 2 * 5 -- how does this program have side-effects?
16:17:25 <ClarkG> how does it do anything?
16:17:26 <Heffalump> uses memory, uses electricty, creates heat
16:17:35 <ClarkG> lol unless it's optimized out into a noop
16:17:41 <m3ga> makes people smarter :-)
16:17:43 <copumpkin> haskell describes side effects
16:17:43 <EvanR> ClarkG: theres a guy that comes with haskell and executes the generated list of IO actions
16:17:48 <dibblego> cleverly, that's how :)
16:17:55 <BMeph> Some people, while programming in Haskell think, "man, if I could just do some imperative programming in C++ here...". Now they have two problems.
16:18:05 <ClarkG> uh huuuh
16:18:18 <Martty> BMeph yea, two languages that they dont like
16:18:51 <EvanR> this guy comes with all languages, like a REPL, but haskell is 'unique' in that this is *the only way* to execute effects
16:19:03 <Wolfspaw> How can i make a list of all the possible combinations of a list? (example: [a,b,c] -> [ [a,b,c] , [b,a,c] , [b,c,a], [c,a,b], [c,b,a] ]
16:19:14 <EvanR> except unsafePerformIO
16:19:17 <aavogt> > permutations [a,b,c] :: [[Expr]]
16:19:19 <ClarkG> isn't there a function for that? like, permutations?
16:19:20 <ClarkG> lol
16:19:22 <ClarkG> there you go
16:19:29 <Wolfspaw> yeah, that was what i wanted thanks xD
16:19:43 <msieradzki> can I specify cabal package for a module not from cabal but from .hs file?
16:19:46 <msieradzki> or any other way?
16:19:59 <msieradzki> I want to hide monads-fs vs mtl
16:20:11 <EvanR> ClarkG: http://codepad.org/J0GKCCxn k, thats the attachmented multipart body. better load that sucker into ghci to make sure it even works
16:20:12 <chrisdone> there's also filterM (const [True,False])
16:20:20 <EvanR> because its from memory ;)
16:20:23 <aavogt> msieradzki: do you need monads-fd at all?
16:20:23 <chrisdone> if you're after powerset ^_^
16:20:24 <ClarkG> okay, thanks
16:20:25 <dibblego> that's a power-set, not perms
16:20:35 <chrisdone> shyuh
16:20:36 <Wolfspaw> aavogt: what lib is it? permutations isnt working with only prelude ; - ;
16:20:42 <EvanR> ClarkG: missing piece is the global two headers that specify that its a multipart message
16:20:44 <aavogt> Wolfspaw: Data.List
16:20:50 <ClarkG> where do I find those?
16:20:52 <Wolfspaw> aavogt: thanks!
16:20:56 <EvanR> ClarkG: you scroll up
16:21:00 <ClarkG> and eugh codepad's loading
16:21:06 <msieradzki> aasmith__, some package does, I don't it's simply installed
16:21:19 <Wolfspaw> For curiosity, is there a clever way to do it with list comprehension? ( im going to use the Data.List one, just curious xD)
16:21:44 <copumpkin> Wolfspaw: with fix and a list comprehension, sure :)
16:21:45 <aavogt> msieradzki: I mean directly in your own code.  Otherwise you can just run in the shell:   ghc-pkg hide monads-fd
16:22:13 <msieradzki> will cabal see this package when installing new packages depending on monads-fs?
16:22:20 <Wolfspaw> copumpkin: im very newbie, i didnt get what you mean with "fix" o.o
16:22:34 <copumpkin> Wolfspaw: basically, with recursion, and a list comprehension
16:22:37 <copumpkin> otherwise, I don't think so
16:22:37 <ClarkG> EvanR: what's the significance of "boundary"?
16:22:42 <Wolfspaw> copumpkin: ah, ok xD
16:22:54 <EvanR> ClarkG: separates the parts of the multipart message
16:23:02 <EvanR> you must specify exactly that in the global header
16:23:19 <ClarkG> what do you mean? I don't know what a global header is.
16:23:21 <EvanR> ClarkG: there seems to be a missing 'newline'
16:23:24 <aavogt> msieradzki: yep
16:23:30 <EvanR> after encodeRaw needs another , ""
16:23:36 <ClarkG> okay
16:23:53 <EvanR> the 'binary' body of each attachment needs to have a blank line before and after
16:23:58 <ClarkG> so just , ""?
16:24:10 <EvanR> yeah, the crlf turns that into a blank line
16:24:17 <ClarkG> k
16:24:29 <ClarkG> learning new functions every day!
16:24:33 <chrisdone> wow, some loud thunder here
16:24:40 <copumpkin> chrisdone: I want some too
16:24:43 <EvanR> crlf is defined in there, its not a standard function
16:24:49 <ClarkG> oh
16:24:50 <ClarkG> LOL
16:24:52 <chrisdone> copumpkin: no thunder where you are?
16:24:53 <ClarkG> way less cool
16:24:54 <EvanR> unlines only gives you "\n"
16:25:05 <EvanR> which is not acceptable for email
16:25:10 <copumpkin> chrisdone: nope :)
16:25:11 <ClarkG> yeah, same with HTTP
16:25:18 <ClarkG> weirds me out
16:25:19 * chrisdone commences a GHC compile from source
16:25:23 <EvanR> see this page for the 'global headers' http://en.wikipedia.org/wiki/MIME under multipart messages
16:25:28 <chrisdone> this'll keep me warm through the night
16:25:47 <chrisdone> holy schmoly
16:25:50 <ClarkG> LOL: "Compiling nightly builds of ghc - a next generation heating system."
16:25:58 <copumpkin> you northern italians should start a HUG
16:26:00 <chrisdone> that actually scared the crap out of me. sounded like my window smashed
16:26:02 <ClarkG> *IT EVEN WORKS IN CANADA!
16:26:03 <copumpkin> unlike poor ol' lonely me :(
16:26:04 <chrisdone> ;_;
16:26:05 <EvanR> but yeah for best effect read some RFCs so you do things by the book, or not, but know how youre not by the book ;)
16:26:16 <ClarkG> yeah
16:26:19 <ClarkG> Bleh
16:26:34 <ClarkG> haskell's hard, let's go shopping
16:26:45 <EvanR> ClarkG: example, the text before the first --frontier or --bn2l3nkjqn223a should be ignored by agents
16:27:00 <EvanR> so either put something useless there, or not ;)
16:27:09 <ClarkG> I think I'll not
16:27:10 <copumpkin> http://www.haskell.org/haskellwiki/ItaloHaskell/Summer_2008
16:27:11 <EvanR> but definitely dont put your message body there xD
16:27:15 <ClarkG> haha yeah
16:28:07 <ClarkG> what does encodeRaw do?
16:28:26 <EvanR> read hackage documentation (actually, its fairly non existent) for package mime
16:28:39 <EvanR> basically it base64 encodes
16:28:47 <ClarkG> what's the first parameter?
16:28:51 <EvanR> good question
16:28:57 <EvanR> gotta read the source ;)
16:29:02 <ClarkG> lol.
16:29:11 <ClarkG> HEY GUYS. HACKAGE SUCKS D:
16:29:12 <EvanR> i believe it has to do with trailing equals signs
16:30:06 <chrisdone> ClarkG: the rule is you're not allowed to criticise hackage until you've submitted something to it
16:30:14 <ClarkG> oh, sorry
16:30:15 <ClarkG> didn't know
16:30:19 <chrisdone> :p
16:30:31 <ClarkG> it shouldn't be so easy to submit to it though.
16:30:48 <chrisdone> it isn't, you have to ask for an account
16:31:01 <ClarkG> may I have an account?
16:31:24 <chrisdone> I'm not in charge of it, there's a note on the site of who to email
16:31:38 <ClarkG> I was kidding :)
16:31:54 <Heffalump> chrisdone: cunning, so people can't criticise hackage without first making it worse?
16:32:45 <chrisdone> Heffalump: indeed, then they're criticising themselves
16:32:53 <chrisdone> Heffalump: but they won't want to do that
16:32:59 <chrisdone> ergo, hackage can never be crticised
16:33:40 <ClarkG> so, about darcs. Why darcs and not git?
16:34:10 <chrisdone> I dunno, I use git
16:34:20 <ClarkG> same here, but everyone else in haskell seems to be using darcs!
16:34:27 * EvanR git here
16:34:29 <chrisdone> not really 
16:34:34 <ClarkG> and since they're the smarties who found haskell before I, surely they know something I don't
16:34:57 <chrisdone> same reason python programmers love mercurial
16:35:05 <ClarkG> that's it?
16:35:11 <chrisdone> I dunno
16:35:32 <ClarkG> k
16:35:41 <chrisdone> where's lambdabot?
16:35:51 <chrisdone> preflex: be poppavic
16:35:51 <preflex>  if I get the chance to shit on yer nose, will you tolerate the procedure or react? Wwhen do you react? why? whose "timeslice"?
16:35:55 <Heffalump> it's partly historical, darcs has been around longer than git
16:36:04 <Heffalump> darcs is also easier to use than git when it doesn't break (IMO)
16:36:10 <chrisdone> mauke: oh man, "timeslice". I lol'd
16:36:24 <copumpkin> darcs also solves a different problem than git
16:36:28 <ClarkG> what's that?
16:36:39 <Heffalump> (I'm a darcs developer btw, so might be a little biased ;-)
16:36:43 <ClarkG> that's good
16:37:03 <ClarkG> you like darcs then, right? LEMME IN ON WHY
16:37:18 <chrisdone> dude shouts a lot
16:37:30 <ClarkG> I just get excited easily.
16:37:41 <Heffalump> it's easy to use, and in particular it does cherry picking right
16:37:58 <ClarkG> is cherry picking preferred to merging?
16:38:11 <chrisdone> what does darcs do in cherry picking that git or mercurial don't?
16:38:46 <Heffalump> chrisdone: (a) they make it seamless - git certainly doesn't but I'm not sure about mercurial
16:38:58 <Heffalump> IM darcs makes it seamless, not "they"
16:39:01 <ClarkG> can I see an example?
16:39:15 <Heffalump> and (b) it doesn't create a distinct commit
16:40:48 <Heffalump> http://wiki.darcs.net/DifferencesFromOtherDVCS is probably the best explanation
16:40:48 <chrisdone> Heffalump: what do you mean by (b)?
16:41:26 <ClarkG> it was ordered
16:41:31 <Heffalump> chrisdone: again with git, since I haven't tried this with mercurial, when you do a cherry-pick it makes a fresh commit on the other branch. Then when you "properly" merge the branches, git has to remerge the cherry-picked patch.
16:41:32 <ClarkG> (a) - some point
16:41:32 <ClarkG> (b) - some other point
16:41:59 <Heffalump> ClarkG: I think he's asking me to expand on (b), not asking what my numbering system meant :-)
16:42:05 <ClarkG> oh
16:42:16 <ClarkG> weird
16:43:32 <chrisdone> Heffalump: is that what git add -p does?
16:43:43 <chrisdone> yay, ghc finished compiling
16:43:47 <chrisdone> 18 minutes!
16:43:52 <chrisdone> now bad
16:43:58 <EvanR> then bad
16:44:00 <chrisdone> RealOpty: 17m59.840s
16:45:04 <Heffalump> chrisdone: I can't remember what git add -p does and I can't find any docs that tell me from a quick google. I haven't used git much.
16:45:18 <ClarkG> git help add
16:45:30 <EvanR> man git-add
16:45:33 <EvanR>  /-p
16:45:39 <ClarkG> showoff
16:46:01 <aristid> Heffalump: git add -p lets you interactively add just pieces of the workdir changes
16:46:07 <Heffalump> I'm not much the wiser, but I think that says that it invokes the interactive patch selection.
16:46:24 <Heffalump> ok, so that's something that darcs also does, but it's not directly related to cherry picking
16:47:04 <Heffalump> darcs record (the equivalent of git add or some subset of git add) interactively asks you about pieces of the changes by default, and has also recently acquired a "hunk splitter" that also allows for interactive edits of the changes.
16:47:05 <bremner> Heffalump: just try it, it is pretty self explanatory
16:47:07 <EvanR> ill pick *your* cherry
16:47:25 <ClarkG> sounds painful
16:47:55 <chrisdone> Heffalump: yeah, that's what git add -p does. you can accept a hunk, or edit it to pick precise lines you do/don't want. mercurial's crecord does this too
16:48:18 <EvanR> ClarkG: new to haskell?
16:48:20 <chrisdone> Heffalump: I don't know about cherry picking with merges. I've never really done anything with merging in any scm
16:48:28 <ClarkG> EvanR: Yup!
16:48:42 <ClarkG> its only been a month
16:48:46 <Heffalump> surely merging is the whole point of using SCM, beyond the basic requirement of tracking a single line of history?
16:48:50 <EvanR> what do you use/intend to use haskell for
16:49:06 <ClarkG> Learning how to do functional programming properly
16:49:10 <EvanR> haha
16:49:18 <ClarkG> did it in python instinctively
16:49:23 <EvanR> its gonna hurt when you go to a language where you cant do it properly
16:49:32 <ClarkG> and then someone was all like "hey, you know where there are languages which help with that, right?"
16:49:34 <chrisdone> if you're saying the requirement of merging makes having an scm a good point then yeah
16:49:58 <ClarkG> after I've gotten to a point where I grok the majority of haskell, I'm going to put some serious time into learning lisp
16:50:00 <chrisdone> mostly I just work in a flat track
16:50:04 <ClarkG> but I have a feeling that might take awhile
16:50:26 <EvanR> did you grok my attachment function
16:50:27 <chrisdone> ClarkG: by the time that happens nobody will be using lisp
16:50:29 <ClarkG> yup
16:50:34 <EvanR> then youre basically done ;)
16:50:37 <ClarkG> chrisdone: lisp will never die
16:50:39 <ClarkG> and no I'm not
16:50:44 <ClarkG> the type system still makes me shit bricks
16:50:47 <chrisdone> well, sure. it's not alive
16:50:50 <chrisdone> lisp is undead
16:50:54 <ClarkG> exactly!
16:51:03 <ClarkG> you can't kill that which is not alive
16:51:20 <chrisdone> you can't use it either
16:51:24 <ClarkG> liefs
16:51:25 <ClarkG> *lies
16:51:39 <EvanR> if you can put a x :: T line for each of the = in the attachments where clause, youre good ;)
16:52:04 <chrisdone> in a perpetual state of decrepitness, neither growing nor shrinking, for 30 years and forever
16:52:07 <ClarkG> definitely not. monads, monoids, arrows oh my
16:52:25 <ClarkG> purely functional haskell I mostly get
16:52:30 <ClarkG> but its all that crazy category theory
16:52:33 <EvanR> monoids are fun and simple
16:52:41 <ClarkG> orly
16:52:49 <ClarkG> do 'splain!
16:52:54 <EvanR> > [1,2] `mappend` [4,5]
16:53:00 <EvanR> crap
16:53:07 <EvanR> [1,2,4,5]
16:53:15 <ClarkG> wat
16:53:16 <acowley> Anyone know how to get cabal-install to compile haskell modules to generate *_stub.* files before compiling C files?
16:53:24 <EvanR> lambdabot is MIA
16:53:35 <mauke> ClarkG: class Monoid a where mempty :: a; mappend :: a -> a -> a
16:53:58 <ClarkG> and a list is a monoid?
16:54:01 <EvanR> yeah
16:54:07 <ClarkG> tuple is not?
16:54:19 <ClarkG> are those two functions its only properties?
16:54:19 <mauke> ClarkG: how do you define mempty for tuples?
16:54:20 <EvanR> a tuple of monoidal types can be trivially made a monoid
16:54:22 <mauke> ClarkG: yes
16:54:35 <ClarkG> and mappend doesn't make sense for a tuple
16:54:39 <ClarkG> that's why I said it doesn't
16:54:45 <EvanR> well a pair of lists, it does
16:54:46 <ClarkG> mempty is (), no?
16:55:06 <ClarkG> oh, that's right
16:55:08 <ClarkG> cool
16:55:18 <EvanR> a tuple with arbitrary members isnt a type in haskell
16:55:20 <mauke> > () `mappend` ()
16:55:23 <EvanR> arbitrary number of members
16:55:26 <mauke>  ()
16:55:28 <ClarkG> ic
16:55:38 <ClarkG> and all those members have to be monoids?
16:55:40 <EvanR> it has 2 through 7 members ;)
16:55:56 <dibblego> EvanR, sure it is, see HList
16:55:58 <EvanR> ClarkG: no, but those are the easiest to see a monoid instance ;)
16:56:07 <ClarkG> I see
16:56:20 <ClarkG> so a monoid is just another type class?
16:56:24 <EvanR> yes
16:56:30 <ClarkG> OH
16:56:36 <ClarkG> I thought they were something special
16:56:38 <mauke> same as monads
16:56:41 <mauke> or arrows
16:56:43 <mauke> or functors
16:56:46 <ClarkG> no way
16:56:51 <ClarkG> mind = blown
16:56:56 <EvanR> get used to that
16:57:06 <ClarkG> yeah, I don't even bother picking up the pieces anymore
16:57:08 <EvanR> not sure if it stops
16:57:37 <ClarkG> I think I'm at that stage where I want to use haskell for _EVERYTHING_
16:57:44 <ClarkG> I feel dangerous
16:58:14 <EvanR> in my youth i always though computer games were a fun application of computer languages
16:58:19 <monochrom> just grow a new brain
16:58:23 <TSC> Thanks to whoever fixed hackage!
16:58:28 <EvanR> so if you get the feeling for game programming check out #haskell-game
16:58:44 <ClarkG> hm I just might!
16:58:51 <monochrom> hackage was down due to accidental digging cable
16:58:53 <ClarkG> brb
16:58:57 <EvanR> lol
16:59:53 <mee> side effects strike again
17:00:39 <mee> did anyone here go to BAHUG last night? Did that event happen?
17:01:12 <monochrom> British America Haskell User Group?
17:01:18 <mee> Bay Area
17:01:27 <ezyang> Dammit, I think I broke inference. 
17:01:37 * monochrom founds Bay Street HUG
17:03:02 <copumpkin> ezyang: yeah?
17:03:34 <ezyang> Oh, that's so curious. 
17:03:49 <ezyang> If I let GHC infer the type, it's ok, but if I add an explicit signature, the inference doesn't work. 
17:04:03 <EvanR> GHC knows best
17:04:05 <EvanR> you do not
17:04:12 <Heffalump> ezyang: there are a few known cases like that
17:04:17 <Heffalump> one example is with associated types
17:04:28 <ezyang> Yup, that's exactly what I'm doing. 
17:04:35 <JoeyA> It may be a case where type variable scope isn't as it seems.
17:04:47 <JoeyA> foo :: [a] -> Int
17:04:55 <JoeyA> foo xs = bar xs where
17:05:03 <JoeyA>     bar :: [a] -> Int
17:05:06 <JoeyA>     bar = length xs
17:05:29 <JoeyA> Sure, this piece of code is innocent (I think), but the type variable `a` in both cases is a different one.
17:05:33 <JoeyA> The `a` isn't scoped.
17:05:55 <JoeyA> It's easy to encounter situations where dropping the nested type signature makes things work.
17:05:55 <Heffalump> ezyang: one issue with associated type synonyms is that if X is an associated type synonym (also known as a type function), then X a doesn't unify with X a.
17:06:45 <JoeyA> (though if you enable the ScopedTypeVariables extension, you can say foo :: forall a. [a] -> Int and the type variable `a` will be scoped.
17:07:17 <ezyang> But then I need to add explicit signatures all over the place. 
17:07:47 <ezyang> Do fundeps unify properly? 
17:08:09 <Heffalump> you can declare fundeps to be bijective, which makes them unify better than type functions
17:08:27 <Heffalump> with a type function you need an explicit inverse function to witness the bijection
17:09:01 <Heffalump> but...fundeps don't bring equality constraints into scope. So they're strictly weaker than type functions in that regard, in the current GHC implementation.
17:10:12 <dolio> Conceivably, once type families are fully implemented, fundeps will be able to be desugared into families.
17:10:17 <dolio> And you'll get the best of both worlds.
17:10:40 <ezyang> I don't think I need type equality checks. 
17:10:50 <ezyang> Ah, the perils of using experimental extensions. 
17:10:51 <chrisdon`> dolio: http://www.youtube.com/watch?v=OWmEReju2w0
17:10:59 <chrisdon`> woops wrong channel
17:11:05 <chrisdon`> silly internet connection
17:12:07 <ezyang> Bah, I have all this nice type families code, don't want to port it to fundeps... 
17:13:18 <Ging_> anyone know a good website where i can paste a code snipet to get some help on please
17:14:03 <dibblego> paste.pocoo.org
17:14:50 <dpratt71> Ging_:  http://hpaste.org (from channel topic)
17:14:55 <Ging_> 249600 if anyone could have alook please 
17:15:08 <Ging_> im unsure whats wrong but im sure im pretty dam close
17:16:14 <EvanR> isnt hpaste the site that is currently running on a server which is abandoned in some desolate back alley accidentally being powered by a dangling powerline?
17:16:56 <ezyang> ... Oh. 
17:17:05 <TSC> Is there a binding to the Posix times(2) function (or some other way to get the CPU time of child processes) ?
17:17:16 <EvanR> System.Posix ?
17:18:22 <TSC> I am digging around in the docs for that but can't find it
17:18:48 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28958#a28958 Seriously? Seriously? 
17:19:46 <int80_h> Evan.R hpaste runs on hamster power. Everyone knows this.
17:20:05 <TSC> Ah, it's in System.Posix.Process after all
17:20:19 <dpratt71> Ging_: not sure what you're trying to do, but the most obvious issue is that you're trying to sum 'factors', which is a function
17:20:22 <EvanR> getProcessTimes
17:20:44 <dpratt71> Ging_: I'm guessing you want to apply factors to an argument first
17:21:10 <TSC> EvanR: Yeah, that's the one, thanks (:
17:21:16 <EvanR> int80_h: that would explain the lack of availability (hampster asleep), but not the non lack of availability (why is hampster not dead yet from neglect)
17:24:36 <BrianHV> as a haskell novice, would I be asking for pain to attempt a wxHaskell program that requires a couple of serious custom controls?  I know wx in other languages, but not haskell
17:27:01 <Phyx-> depends, how big a novice are you?
17:27:52 <BrianHV> I successfully wrote a program that converts a space-indented text file to html lists.  monads are slowly starting to sink in.
17:27:54 <jmcarthur> BrianHV: afaik most of the GUI toolkit bindings for haskell are very true to their imperative counterparts. as long as you can work in the IO monad you're probably fine
17:28:57 <jeff_s_> At http://www.haskell.org/haskellwiki/HXT/Practical/Weather1, is there a way to run the arrow (xml >>> getWeather) outside of the IO monad, so that the line would read "result <- someFunction (xml >>> getWeather)"?
17:29:09 <EvanR> Endo is interesting, this is a wrapper newtype for functions from something type a to itself a, and i guess mempty is id, and mappend is composition. any cool use for that?
17:29:16 <jeff_s_> sorry, it would have return $ someFunction...
17:29:22 <BrianHV> k, thanks... maybe I'll give it a shot
17:29:28 <dons> BrianHV: probably ok. wxHaskell is a good lib.
17:29:59 <jmcarthur> > Data.Foldable.fold [(+2), (*3), (/4)] `appEndo` 5
17:30:05 <jmcarthur> doh
17:30:15 <jmcarthur> > Data.Foldable.foldMap Endo [(+2), (*3), (/4)] `appEndo` 5
17:30:15 <Pseudonym> EvanR: You know about ShowS?
17:30:20 <Pseudonym> @hoogle ShowS
17:30:21 <jmcarthur> oh no LB :(
17:30:23 <EvanR> no
17:30:27 <Pseudonym> @botsnack
17:30:27 <EvanR> not really
17:30:53 <Pseudonym> type ShowS = String -> String
17:31:15 <EvanR> its Endo String
17:31:19 <Pseudonym> And in particular: http://haskell.org/tutorial/stdclasses.html#sect8.3
17:31:52 <Pseudonym> Monad.Writer needs a Monoid for whatever is written.
17:32:00 <ezyang> So, should I explicitly construct a bijection with type families? 
17:32:07 <Pseudonym> Since ShowS is an Endo, you can write a string, efficiently.
17:32:53 <mm_freak_> BrianHV: i would just do it
17:33:48 <EvanR> what does S stand for in ShowS
17:34:00 <BrianHV> oh, hm... the other thing I need is a solid midi (hardware) library
17:34:06 <Pseudonym> EvanR: No idea.
17:42:19 <EvanR> ....must... code... game...
17:42:25 <EvanR> losing consciousnesss
17:42:26 <chrisdon`> okay so I've got emacs generating a complete hoogle file of my cabal installed packages
17:42:37 <chrisdon`> now to somehow apply etags
17:43:50 <chrisdone> hasktags might do the job actually
17:43:51 <luite> sounds great chrisdone :)
17:44:05 <chrisdone> hey you use emacs?
17:44:09 <luite> yes
17:44:11 <BrianHV> Paul Liu doesn't happen to hang out here, does he?
17:44:31 <chrisdone> luite: cool =)
17:44:50 <luite> but I don't know too much about elisp
17:45:34 <ezyang> Hmm. I think I want class families. 
17:45:37 <nejucomo> Is there a module for runtime evaluation (or jit or even static compilation)?
17:45:57 <nejucomo> I don't see anything in the stdlib tree.
17:46:12 <nejucomo> I'm specifically interested in running untrusted haskell code.
17:46:38 <chrisdone> nejucomo: sure, checkout mueval and hint
17:46:46 <nejucomo> Thanks,
17:46:47 <EvanR> all my code considers all my other code untrusted ;)
17:46:47 <nejucomo> .
17:47:08 <aristid> @remember EvanR all my code considers all my other code untrusted ;)
17:47:20 <aristid> GAAAAH
17:47:28 <EvanR> first time someone quotes me and the friggin bot is gone ;)
17:47:31 <chrisdone> luite: http://github.com/chrisdone/haskell-mode-exts/blob/master/haskell-packages-exports.el
17:47:31 <chrisdone> luite: still a bit messy, I'm not sure this is how I want to do it
17:47:46 <nejucomo> evanr: That's the way.
17:48:48 <EvanR> static typing really limits the amount of damage a malicious pure function can do ;)
17:49:01 <EvanR> well, a total one
17:49:01 <nejucomo> It's obvious you can trust side-effects free code to meet some interface without causing much harm, but what about constraining I/O ?
17:49:10 <koninkje> :t unsafePerformIO
17:49:21 <EvanR> IO a -> a
17:49:22 <hpc> IO a -> a
17:49:40 <dpratt71> who needs lambdabot?
17:49:56 <koninkje> Seems like some malicious damage could come from a pure (a -> a) then...
17:50:04 <koninkje> >;)
17:50:06 <chrisdone> luite: I'm extracting all the ghc-pkg list'ed modules from their respective ~/.cabal/packages .tar.gz files and then running cabal haddock --hoogle, copying that output to one big text file and then hoogle --convert'ing that to a .hoo file
17:50:13 <nejucomo> So if container code could prevent access to unsafePerformIO and could require io to be restricted by the type system...
17:50:39 <EvanR> koninkje: stop making sense ;)
17:50:41 <koninkje> unsafeInteractWithAWorldOutsideOfTheLanguage
17:50:43 <chrisdone> luite: thinking it might be easier in the end to just patch cabal-install itself to generate this stuff when installed
17:51:41 <orlandu63> @src test
17:51:57 <orlandu63> no lambdabot? :|
17:52:15 <koninkje> nejucomo: you can't force IO to remain in the language unless you can somehow prevent the possibility of FFI code or RTS hacking from ever allowing you to talk to anything outside of your process
17:52:20 * chrisdone pokes Cale
17:52:23 <koninkje> ...without IO in the type, I mean
17:52:29 <hpc> test = unsafePerformIO $ exitWith ExitSuccess
17:52:38 <nejucomo> Is anyone aware of people using haskell for untrusted code?  An example use case is implementing something like appengine which accepts arbitrary haskell-based web app code.
17:53:04 <dpratt71> nejucomo: you mean like lambdabot?
17:53:09 <chrisdone> nejucomo: codepad.org and tryhaskell.org
17:53:09 <BrianHV> so when I try to "cabal install PortMidi" there's an error caused by an OSX header including Block.h, which winds up including a GHC header named Block.h, and not the Block.h the OSX header was trying to include
17:53:33 <nejucomo> tryhaskell is new to me, but I know that codepad relies on process-level and machine-level sandboxing.
17:53:42 <nejucomo> Thanks for the refs.
17:54:14 <chrisdone> nejucomo: it's pretty trivial to make haskell safe, compared to other langs
17:54:16 <nejucomo> koninkje: So, I wasn't imagining somehow making IO safe, but instead requiring "sandboxed" code to meet a certain interface that wraps all io according to some security policy.
17:54:25 <nejucomo> chrisdone: Great!  How?
17:54:43 <nejucomo> FWIW- I've been toying with haskell for a while, but I still feel like I don't completely grok it.
17:54:57 <hpc> it takes a while
17:54:57 <chrisdone> nejucomo: http://hackage.haskell.org/package/mueval
17:55:17 <koninkje> nejucomo: my point was that imposing your type system (whatever that is) on the outside world is still open research
17:55:38 <koninkje> Everyone just says: "step 1: assume noone violates our type system"
17:56:00 <koninkje> Enforcing that assumption is then left up to security-minded folks
17:56:27 <koninkje> how do you prove they can't escape the sandbox?
17:56:28 <chrisdone> you can reject the IO monad, and substitute your own based on zipperfs
17:57:06 <koninkje> and for NICs?
17:57:14 <nejucomo> Cool, mueval looks close to what I'm aiming for.  One difference though is it attempts to be transparent, whereas I wanted to have an explicit api.
17:57:42 <chrisdone> koninkje: the ways to do arbitrary IO are few. and otherwise IO needs to be explicitly run by someone, otherwise it's just a value. then all you have to worry about is time and space being used up
17:58:46 <nejucomo> koninkje: Ah, I am specifically interested in object capabilities, so I imagined interactions like: callRemote :: ObjCapRef -> ObjCapData -> ObjCapTransaction ObjCapData
17:59:48 <nejucomo> A monitor would translate ObjCapTransactions into the appropriate object capabilities io.
18:00:16 <carter> i figured out why i was getting a "can't find ghc -any" error when trying to do cabal install gitit
18:00:28 <chrisdone> carter: why?
18:00:33 <nejucomo> This is a completely off the cuff brainstorm.  I understand how obj caps work in dynamically typed strict languages like javascript much better.
18:00:38 <luite> chrisdone: like this? http://hackage.haskell.org/trac/hackage/ticket/402
18:00:49 <nejucomo> Anyway, thanks for the discussion and references.  Gotta run.
18:01:11 <Phyx-> is 5secs normal to typecheck a 8k lines haskell file?
18:01:23 <chrisdone> luite: indeed, that's the one I have my eye on, and ...
18:01:33 <carter> i think thats cabal's way of being confused when theres a version conflict between whats needed and whats installed  thats several layers into the transitive set of dependencies
18:01:33 <aavogt> Phyx-: what are you doing in there?
18:01:49 <Phyx-> aavogt: it's the GHC parsers
18:02:00 <chrisdone> luite: http://hackage.haskell.org/trac/hackage/ticket/517
18:02:01 <Phyx-> aavogt: it's my worst scenario test file
18:02:03 <nejucomo> Ah, so one last bitâ¦  For the approach I am envisioning I want an API that means: "Load this arbitrary string as a compiled anonymous module, then give me the 'untrusted_main' function which has this specific typeâ¦"  Are there any libraries like that?
18:02:27 <koninkje> Phyx-: how many types are being inferred, vs merely checked?
18:02:35 * nejucomo rtfms about mueval before spamming anymore.  ;-)
18:03:01 <carter> so i basically needed to do a cabal install --reinstall of gitit with the transitive set and a few of the version's explicitly set
18:03:07 <koninkje> I don't have any 8k-LOC files, but if it's only checking then it shouldn't take long. Inference will take longer
18:03:15 <copumpkin> koninkje: interesting stuff about the strong vs. weak sigma, thanks
18:03:21 <koninkje> sure thing
18:03:23 <etpace> @pl (\a -> Right (5,a))
18:03:28 <carter> i'll find out shortly if that solves it
18:03:32 <Phyx-> koninkje: i'd say 50 50, but there are alot of little small definitions. I want to increase the responsiveness of the IDE on files like that
18:03:34 <Gracenotes> lambdabot D:
18:03:39 <aavogt> Right . (,) 5
18:03:41 <Gracenotes> Right . (,) 5
18:03:44 <Phyx-> koninkje: but the problem is, it's all or nothing
18:03:45 <aavogt> haha
18:03:48 <etpace> > Right . (5,) $ 6
18:03:54 <etpace> mm
18:04:02 <Gracenotes> needs moar -XTupleSections
18:04:05 <chrisdone> Wrong (5,6)
18:04:15 <koninkje> Phyx-: in the worst case, type inference is exponential in the length of the code...
18:04:22 * chrisdone thinks of Depeche Mode
18:04:28 <koninkje> copumpkin: no problem :)
18:04:34 <chrisdone> that would make a good emacs mode. depeche-mode
18:04:50 <carter> maybe theres a better way, or maybe this is just an excellent example of why cabal needs a wee bit mroe cleverness
18:05:28 <carter> hrm.... i'm thinking the latter based upon what i'm seeing is getting rebuilt from that transitive set
18:05:57 <osaunders> :-O
18:06:05 <Phyx-> koninkje: right, I don't think there's anything I can do... the only way to know the absense of type errors is by waiting till it finishes, :/ so I can only give feedback then
18:06:21 <bread> is when reading function types with multiple arrows, such as a -> b -> c -> d -> e, should I always group from the right-most pair to the left?
18:06:35 <chrisdone> it's right associative
18:06:45 <chrisdone> a -> b -> c  =   a -> (b -> c)
18:07:09 <bread> what about a > b > c > d? (I am using > in place of ->)
18:07:22 <Veinor> a -> (b -> (c -> d))
18:07:27 <koninkje> Consider :t (\f -> f 5) vs :t (\x y -> x+y)
18:08:09 <koninkje> arrows are right associative. If you add parentheses to make it associate to the left, then you get a higher-order function
18:09:34 <chrisdone> think of (((a - b) - c) - d) vs (a - (b - (c - d)))
18:09:42 <bread> thanks for your replies! i will go read up about "right associative" and "higher-order" function. (currently trying out haskell at tryhaskell.org ... awesome) 
18:09:45 <chrisdone> the former is left associative, the latter is right associative
18:10:00 <chrisdone> :D
18:10:08 <bread> :D
18:10:09 <carter> chrisdone: does that answer / clarify my remark?
18:10:26 <osaunders> bread: Higher-order function is a function that takes or returns another function.
18:10:34 <carter> yeap, its finally building it it
18:10:43 <chrisdone> carter: yay
18:10:58 <osaunders> bread: Associativity is a property of an operator that determines whether a row of them evaluates from left to right or right to left.
18:11:11 <ClarkG> EvanR: How are the filenames for SMTP attachments encoded?
18:11:34 <bread> thx osaunders!
18:11:35 <EvanR> AOL keyword: mime
18:11:37 <koninkje> bread: technically (a -> (b -> c)) is a HOF too, since it returns a function. I just meant that left-assoc parentheses make it so you have a function as an argument
18:11:44 <EvanR> aka i dont know
18:11:45 <ClarkG> k
18:11:48 <carter> chrisdone: so i guess one thing that cabal v1 should have is a proper transitive dependency graph / lazily compute one of hackage as much as needed
18:11:52 <EvanR> of course im going to google it in a minute
18:11:57 <ClarkG> same here :)
18:12:07 <carter> built!
18:12:09 <carter> sweet
18:12:23 <carter> now to unbork all my libs back to how like em
18:12:29 <ClarkG> Content-Type: application/octet-stream; 	name="mfetch.py" 
18:12:31 <ClarkG> soemthing like that?
18:12:34 <carter> thank god that ghc defaults to static linking
18:12:44 <carter> or spj? :p
18:12:47 * chrisdone off to bed, ciao
18:13:12 <EvanR> ClarkG: of course, mfetch.py is not an octet-stream
18:13:13 <osaunders> Bye
18:13:17 <EvanR> (well it can be)
18:13:28 <ClarkG> well yes
18:13:31 <ClarkG> that's how I found it actually
18:13:32 <EvanR> its text-plain or something specific to python source
18:13:35 <ClarkG> someone failed@mime-encoded
18:13:46 <ClarkG> so it was showing the MIME instead of the actual file
18:13:53 <ClarkG> [it was from some mailing list]
18:14:00 <ClarkG> http://mail.python.org/pipermail/tutor/2002-April/013761.html
18:14:08 <EvanR> Content-Disposition: attachment; filename=genome.jpeg;
18:14:14 <EvanR> according to wikipedia
18:14:30 <ClarkG> but then why was there a name in content-type too?
18:14:48 <EvanR> i didnt see that
18:15:05 <ClarkG> http://mail.python.org/pipermail/tutor/2002-April/013761.html
18:15:05 * EvanR opens RFC 2046
18:15:35 <jbapple> @hoogle [a -> m a] -> a -> m a
18:15:58 <aavogt> mconcat is rather close
18:16:06 <EvanR> ClarkG: well, guess it could work
18:16:22 <aavogt> jbapple: if you have a    Monoid (m a)  instance
18:16:23 <EvanR> i only see this
18:16:29 <EvanR> Content-Type: message/external-body; name="BodyFormats.ps";
18:16:39 <ClarkG> I don't understand
18:17:34 <aavogt> foldr (=<<) . return :: (Monad m) => b -> [b -> m b] -> m b
18:17:40 <carter> have there been any documented instances of there being conflicts in the transitive dependency graphs for packages on hackage, but not in their direct dependencies?
18:17:51 <carter> because that seems like something cabal would barf on
18:17:54 <EvanR> the above is in the section about external-body mechanism
18:18:04 <ClarkG> idk what external-body is
18:18:13 <EvanR> probably because you didnt read the docs
18:18:23 <EvanR> how about you look this stuff up and tell me how it turns out
18:18:29 <ClarkG> sure
18:19:46 <EvanR> module dependencies are tree-like right, not generally graphical
18:20:07 <carter> no, they're dag like :p
18:20:18 <carter> thats where problems arise
18:20:24 <aavogt> EvanR: ghc sort of discourages cyclic dependencies
18:20:32 <carter> who said cycles?
18:20:35 <carter> i'm just thinking dags
18:20:48 <aavogt> you can do cycles
18:21:08 <carter> either way, tree like dependcies are nice
18:21:10 <EvanR> if stuff in the modules can do cycles, might as well let modules ;)
18:21:33 <carter> 'cause then no depencies are shared in the transitive set of dependencies
18:21:45 <carter> dags are where the funny version requirements start acting up
18:21:55 <carter> and cycles help no one :p
18:22:02 <carter> i kid
18:22:03 <aavogt> cyclic module dependencies sort of work against separate compilation
18:22:16 <aavogt> carter: packages or modules?
18:22:24 <carter> hackage
18:22:25 <carter> so package 
18:22:30 <EvanR> cabbage
18:22:36 <carter> never those
18:22:42 <carter> brocolli is game though
18:26:17 <Gracenotes> certainly there are dags if you consider versions as separate nodes
18:28:17 <aavogt> yo dag...
18:28:32 <EvanR> god dag-it
18:40:50 <carter> Gracenotes: exactly
18:41:13 <carter> so when i have free time, i'm going to look at the cabal code for this 
18:41:25 <carter> and see if the dep algorithm has the problems i'm thinking it does
18:41:35 <jbapple> @hoogle [a -> a] -> a -> a
18:41:37 <carter> and at least write down what would need to change
18:44:58 <koninkje> Does anyone know of a good (common, short,...) name for modules over semirings?
18:46:09 <carter> koninkje: mod-semiR
18:46:22 <carter> left, right or commutative modules?
18:46:57 <upshaw2> So how does one turn off stdout buffering in haskell?
18:47:20 <carter> koninkje: in theory #haskell-math was supposed to be a haskelly forum for such, but its not very active
18:47:30 <carter> though trying to fix that may be worth while
18:47:50 <carter> or keeping stuf fon #haskell might be better
18:48:01 <koninkje> I'm thinking it's a right module, though I'm not sure just yet
18:48:05 <aavogt> upshaw2: use System.IO.hSetBuffering
18:48:09 <carter> whats the thing in question?
18:48:40 <upshaw2>  aavogt: thanks!
18:48:45 <Martty> upshaw2 buffermode nobuffering
18:48:50 <Martty> aaa
18:49:29 <koninkje> carter: Basically, people are using semirings all the time in NLP, but often it's more fruitful to think of them as modules
18:49:49 <koninkje> Expressing algorithms over HMMs, more specifically
18:50:08 <carter> cool
18:50:21 <carter> i'm (in theory) doing some nlp contract work for the summer
18:50:23 <dmwit> ?botsnack
18:50:44 <carter> koninkje: said work'll get properly nlpish this week
18:50:57 <koninkje> E.g. given F, The Viterbi algorithm is F over (max,*), the Viterbi algorithm with backpointers is (arg max,*), and the forward algorithm is (+,*)
18:50:59 <carter> what are some good refs on those sorts of nlp tool kits
18:51:16 <carter>  / such algorithms
18:51:43 <koninkje> The semiring generalization is common lore, but I don't know of a good reference off hand
18:52:19 <koninkje> You may be able to sart searching from http://www.google.com/url?sa=t&source=web&cd=1&ved=0CBUQFjAA&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.22.9398%26rep%3Drep1%26type%3Dpdf&ei=LaVkTJ2HPMzVngfrlbTLDw&usg=AFQjCNHe_svymqZvdN5GB0s9IZtCwatzYQ
18:52:23 <koninkje> ick
18:52:38 <carter> you mean Expectation Semirings: Flexible EM for Learning Finite-State Transducers?
18:52:43 <Ging_> not to take any fame from this room but i also program java and would like to chat in the java room aswell but its invite only if anyone can help. sorry if this seams inapropriate
18:53:08 <carter> its invite only? that not very nice
18:53:10 <koninkje> yeah
18:53:32 <Ging_> i didnt even know that could be done in irc lol
18:53:51 <upshaw2> Okay I posted a IO action on hpaste that seems to do very strange things.
18:54:01 <upshaw2> Can anyone look?
18:54:08 <Wolfspaw> Ging_: damn, go to scala room then xD, they're more close to Java. And if they cant help you atleast you're in a functional channel too ; )
18:54:12 <koninkje> carter: Some of the stuff on OpenFST and XFST, or work on tropical semirings, could also be a good starting place
18:54:34 <carter> ooo, tropical semirings, those have been on my todo list for a while 
18:54:46 <koninkje> basically, NLPers get all the semiring fun :)
18:55:38 <carter> granted, i need to figure out some ways of doing nlp backed by some really messy db tables of data that correspond to a webisite's content and submissions over several years 
18:55:44 <carter> which might not translate over
18:56:12 <koninkje> what kind of nlp? data mining I presume?
18:56:43 <carter> koninkje:goal being to use that data to make a reasonably accurate classifier for if blog posts might have like content
18:56:55 * koninkje nods
18:57:01 <carter> and doing a reasonable job of extracting the core details
18:57:33 <koninkje> I'm not sure how much of the semiring stuff witll translate. Semirings show up in tagging, parsing, and translating
18:57:44 <koninkje> Clustering tends to be more vector-spacey
18:58:17 <carter> better description: the messy db is basically up and down votes on quality of deals on blog post, and i'm basically using this stuff try to both learn how to better summarize the deals automatically + recognize when theres one
18:58:25 <carter> * blog posts
18:58:36 <carter> btw, how do you do stuff like nodding on irc?
18:58:55 <koninkje> You type "/me nods" etc
18:59:00 <carter> ahh
18:59:10 <monochrom> /me nods
18:59:48 <carter> gotcha
19:00:03 <carter> doing basic parsing is easy business
19:00:18 <carter> though i may want to try to have a tool that learns the "grammar of deals"
19:00:30 <Phyx-> /me nods
19:00:32 <Phyx-> not working...
19:00:36 * carter nodes
19:00:46 <Phyx-> /me nodes
19:00:49 * carter fails at nodding
19:01:00 * koninkje wonders what client Phyx- is using
19:01:01 <Phyx-> do i need to escape the /?
19:01:11 <Phyx-> \/me nodes
19:01:18 <koninkje> nope, /me is a command just like /nick etc
19:01:24 <carter> are you using adium?
19:01:27 <carter> or what?
19:01:27 <Phyx-> lol, i'm just playing with you
19:01:33 <monochrom> perhaps Phyx- is playing with us
19:01:35 <Phyx-> i was going /say /me nods
19:01:45 <Phyx-> sorry :)
19:01:47 <monochrom> /say /me nods
19:01:50 <carter> where is a list of all these awesome commands that I don't know?
19:01:51 <dibblego> are the authors of Data.Tree.Zipper about by any chance?
19:01:54 <Phyx-> monochrom: hehehe
19:02:07 <koninkje> /help
19:02:10 <Ging_> how to u do the Ging_ nods things id like to know that command
19:02:10 <Phyx-> carter: no i'm using irssi btw
19:02:15 <carter> ahhh
19:02:39 * aavogt has differentiated trees before
19:02:57 * jbapple has conflated trees before
19:02:57 <carter> how is irssi?
19:03:07 <carter> i've cycled through all of the other mac clients pretty much
19:03:16 * koninkje loves irssi
19:03:39 <etpace> what's the correct method to uninstall a library from /lib? will just rming work or are there files that will point to it within ghci
19:03:59 * Phyx- loves irssi too
19:04:00 <monochrom> ghc-pkg unregister ...
19:04:04 <Phyx-> was an xchat fan
19:04:11 <Phyx-> untill they started charging for windows builds
19:04:21 <Phyx-> monochrom: you know, i keep forgetting to report a bug with ghc-pkg
19:04:26 <Phyx-> it seems to ignore --user
19:04:27 <carter> etpace: you may wanna edit the ghc  and cabal package lists
19:04:32 <monochrom> then I used "ychat"
19:04:48 <monochrom> I still do
19:04:53 <Phyx-> i jumped to irssi
19:04:55 <Phyx-> never looked back
19:05:07 <monochrom> jumping to irssi is looking back
19:05:12 <monochrom> @quote ray 1970s
19:05:21 <monochrom> preflex: quote ray 1970s
19:05:22 <preflex>  no quotes found for ray
19:05:43 <monochrom> oh well, something about voluntarily use 1970s terminals
19:05:53 * Ging_ smiles
19:05:56 <Ging_> :)
19:06:41 <Phyx-> lies!
19:06:45 <Phyx-> irssi is the future!
19:06:50 <Jonno_FTW> @src curry
19:07:11 <Jonno_FTW> >:3
19:07:23 <Jonno_FTW> :t curry
19:07:34 <Jonno_FTW> lamddabot where are you?
19:08:35 <monochrom> curry f x y = f (x,y)
19:09:19 <Jonno_FTW> @src uncurry
19:09:34 <carter> funny fact: when i show people some of the stuff thats baked into haskell's tool chain and the hackage package system, they're like "why do you get to use this awesome magic"
19:10:16 <Jonno_FTW> When would I use currying?
19:11:14 <monochrom> when you have a function (a,b)->c but you hate tuples
19:11:46 <Jonno_FTW> but
19:11:47 <Jonno_FTW> like
19:12:25 <carter> Jonno_FTW: also, you order the parameters so that you curry on the thing that varies less :)
19:12:26 <Jonno_FTW> in your definition is f :: a -> a -> a?
19:12:37 <monochrom> no, f :: (a,b)->c
19:13:09 <Jonno_FTW> isn't that curry f though?
19:13:38 <monochrom> no. curry f :: a->b->c
19:14:00 * koninkje debates chucking Prelude.Num entirely
19:14:01 <Phyx-> curry f . (id *** show)
19:14:11 <etpace> I want to use monads-fd and transformers instead of mtl, having them both in use causing ambiguity and unable to compile, having only the latter causes things like parsec to fail, any ideas?
19:14:11 <monochrom> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html#v%3Acurry
19:14:45 <monochrom> parsec uses mtl. how would having mtl fail parsec.
19:15:07 <etpace> no, lack of mtl makes parsec fail, can I make it use monads-fd and transfoerms instead
19:15:48 <monochrom> you will spend much effort modify parsec if you want to do that
19:16:15 <etpace> so how can I get mtl, monads-fd and transformers to live together happily?
19:16:25 <etpace> so that importing Control.Monad.Trans or whatever is not ambiguous
19:17:24 <monochrom> for toy programs, hide unwanted packages. for serious projects, the cabal file makes you explicitly list packages you want anyway
19:17:46 <monochrom> you even have to say "I need base"
19:17:53 <monochrom> nothing is assumed
19:18:11 <etpace> yeah, need to change the main project to cabal
19:19:19 <ClarkG> what's the if (something) { do something } syntax for haskell?
19:19:45 <carter> open their source
19:19:55 <monochrom> the "do something" part is called "do-notation" if you want to look up.
19:19:56 <carter> and change the module names :p
19:20:07 <carter> then cabal install
19:20:09 <carter> tada
19:20:21 <ClarkG> lol. first link -> Do notation considered harmful
19:20:48 <monochrom> actually the module names are the same, so it's more like changing the cabal file to say "I want monads-fd instead".
19:20:50 <carter> etpace:  and then also if possible, put these name space friendly versions up on hackage and suggest people be saner with name spaces 
19:21:02 <carter> monochrom: i'm suggesting fixing that :P
19:21:10 <carter> monochrom: ie make the module names different
19:21:31 <carter> eg inserting the package name somewhere
19:21:36 <monochrom> this is why we wanted to avoid success.
19:22:04 <carter> monochrom: who is we?
19:22:10 <monochrom> success leads to failure because of namespace problems
19:22:27 <monochrom> old haskell slogan "avoid success at all costs"
19:28:34 <lispy> monochrom: we should put things in org.haskell.community.mynick and then namespace problems are sloved
19:28:44 <lispy> duh
19:29:30 <monochrom> I prefer alt.binaries.haskell.lambdabot.bikini
19:31:51 <dolio> alt.binaries.haskell.peyton-jones.unicycling
19:32:00 <medfly> ^^
19:32:22 <ddarius> alt.binaries.haskell.peyton-jones.bikini
19:33:11 <jeff_s_> ty for the help about my concatMapM question (dunno if the person is still here)
19:33:18 <jeff_s_> good night
19:33:26 <monochrom> yes
19:33:51 <ddarius> monochrom: What's the new Haskell slogan?
19:33:59 <ClarkG> how can I have an if expression with no else clause?
19:34:22 <ddarius> You can't.
19:34:35 <ClarkG> is there some equivalent?
19:34:50 <ddarius> ClarkG: It doesn't make sense, though you may be looking for when.
19:34:53 <ddarius> (or unless)
19:34:56 <monochrom> there is no new slogan. the old slogan just got canned.
19:35:00 <ddarius> :t when
19:35:08 <ddarius> Curses.
19:35:22 <monochrom> perhaps there is the new slogan of "learn you a haskell for great good"
19:35:25 <ClarkG> when isn't in scope
19:35:30 <pikhq> ClarkG: Haskell's "if" is more akin to C's ternary operator than a normal if statement.
19:35:32 <ClarkG> but I'll google it, thanks
19:35:36 <dolio> when :: Monad m => m () -> m ()
19:35:44 <dolio> Oops, missing a bool.
19:35:52 <dolio> Monad m => Bool -> m () -> m ()
19:35:55 <ddarius> dolio makes a poor lambdabot
19:36:00 <dolio> Indeed.
19:36:08 <ClarkG> when doesn't seem to be in the prelude - is it built-in?
19:36:16 <ClarkG> nvm, Monad
19:36:18 <monochrom> when is in Control.Monad
19:36:18 <ClarkG> bah, need lambdabot
19:38:15 <monochrom> "when" is just ordinary haskell code that says "else return ()"
19:38:28 <ClarkG> yup I see that now
19:38:29 <ClarkG> thanks :)
19:38:45 <monochrom> it teaches you that so called "if-then, no else" is just shortcut for "else nop"
19:39:07 <ClarkG> yeah. non-pure programming in haskell is a bit of a pain
19:39:16 <ClarkG> too much learning, eh?
19:39:29 <monochrom> you are just being detoxinated.
19:39:46 <monochrom> there is too much brainwashing from the mainstream.
19:40:05 <ClarkG> lambda calc vs. turing machine. turing won
19:40:48 <monochrom> not even that. mainstream programming languages don't resemble turing machines.
19:40:58 <ClarkG> they're all based on the same model though
19:41:02 <ClarkG> it all came from C
19:41:05 <ClarkG> which came from assembly
19:41:12 <ClarkG> which came from the turing machine (more or less)
19:41:34 <monochrom> more like "random access machine"
19:41:40 <dolio> The model of having a single write head on a tape?
19:41:49 <dolio> With a finite state machine controller?
19:41:50 <ClarkG> it's like a high-level turing machine
19:41:54 <ClarkG> lol
19:42:04 <ClarkG> stop stabbing my analogy. it hurts.
19:42:11 <monochrom> turing machines would force you to take quadratic time to add two numbers.
19:42:22 <ClarkG> ow
19:43:08 <ddarius> monochrom: We'll just call than O(1) though.
19:44:06 <monochrom> turing machinists don't cheat like that. instead they spend their whole lives on P vs NP
19:44:57 <dolio> Good thing the latest proof probably has serious flaws, or they'd have nothing to do.
19:44:59 <ClarkG> which a kinda-legit proof for is out.
19:45:01 <ClarkG> lol
19:45:25 <ClarkG> can't wait to hear what knuth has to say about it
19:47:19 <carter> are there any known legit reasons why haskell-platform won't build on rhel 5?
19:47:49 <monochrom> missing c libs
19:48:30 <carter> intrinsically or just if you're lazy?
19:49:13 <carter> monochrom: eg, can you just add them to  usr/local or something and move on with ones life?
19:50:22 <ClarkG> if I define a pure function (such as exponentiation) and pass it a constant somewhere in my code, is the constant going to be replaced by the result of the function call at compile-time? Assuming optimizations are turned on at the max, of course.
19:50:59 <ClarkG> so like, pow(2, 10)
19:51:02 <ClarkG> being replaced with 1024
19:51:12 <medfly> "does Haskell optimize for me?" - yes
19:51:30 <ClarkG> including recursive functions? does it go arbitrarily deep?
19:53:31 <pikhq> ClarkG: Maybe.
19:53:40 <ClarkG> ?
19:53:54 <ClarkG> ...maybe I'll just use template haskell...
19:55:07 <kmc> ClarkG, in general compilers give few guarantees about optimization, it may or may not happen
19:55:15 <kmc> you can use ghc-core to look at the optimized code
19:55:41 <ClarkG> does it currently happen with the current implementation?
19:58:44 <BrianHV> what's the search term I should use to read up on the sorts of functions that operate on the partial results from themselves?
19:58:44 <monochrom> carter: the c libs are really needed. but you should be able to get the "devel" packages.
20:00:09 <dbelange> BrianHV: "Recursive"?
20:00:49 <dbelange> (Or "defined recursively," or "recurrence relation"?)
20:01:24 <BrianHV> dbelange: but specifically the type of recursive function like fib = 0 : 1 : zipWith (+) fib (tail fib)
20:01:51 <kmc> BrianHV, that's not even a function
20:01:59 <BrianHV> unless that's really nothing special and I'm overthinking it
20:02:11 <kmc> it's kind of special.  it doesn't work in strict evaluation, for sure
20:02:22 <kmc> you can think of it as a cyclic data structure
20:02:29 <kmc> where part of the cycle is a suspended computation
20:02:41 <kmc> which unfolds itself as you demand more elevents
20:02:49 <kmc> > let x = 1 : x in x
20:03:02 <kmc> eep, where'd lambdabot go?
20:03:07 <dbelange> BrianHV: It's called a recurrence relation.
20:03:32 <BrianHV> dbelange: thanks
20:03:45 <pikhq> <lambdabot> [1, 1, 1, 1, ...
20:04:04 <ClarkG> lol.
20:04:18 <kmc> BrianHV, you can think of this as a (:) cell whose head points to a 1 and whose tail points to itself
20:04:18 <adnap> Argh, I have a long problem and I don't want to flood the channel.
20:04:25 <kmc> adnap, hpaste it?
20:04:44 <adnap> kmc: 'Kay
20:04:54 <adnap> kmc: I'll still probably have to explain it.
20:05:01 <BrianHV> kmc: I get how it works at a high level; I'm wondering about the low level.  are there three lists involved?  the two args to zipWith and the result?
20:05:42 <BrianHV> I mean, I'm sure that's implemented in a way that doesn't make memory explode...
20:06:10 <ddarius> BrianHV: There is no special magic.
20:07:44 <BrianHV> perhaps I should read up on thunks
20:07:54 <adnap> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28971#a28972
20:08:10 <kmc> BrianHV, draw a diagram of the heap
20:08:52 <adnap> My friend alexbobP called the data structure "Gonad". :P
20:09:47 <ddarius> Haskell allows any model of non-strict evaluation so pick one, e.g. call-by-name, and reduce.
20:10:07 <adnap> It's a format for serializing data that looks like a:bc:d, where a is the length in bytes of b, b is binary data, c is the number of children, and d is children.
20:10:34 <gs4_> any advice on avoiding "type" cycles?
20:11:52 <adnap> It should probably have LBS in front of a few more functions. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28971#a28973
20:12:40 <adnap> Anyhow, I'm having trouble decoding the children into the recursive data structure.
20:12:46 <lispy> gs4_: what is a type cycle?
20:13:20 <adnap> In C, it's a for loop, so I was thinking it might be some kind of fold, but it's hurting my head.
20:13:35 <gs4_> lispy: one sec, ill hpaste an example
20:14:08 <gs4_> lispy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28974#a28974
20:14:28 <kmc> gs4_, declare new types instead of aliasing existing ones
20:14:32 <kmc> there's lots of advantages to doing so
20:14:32 <gs4_> lispy: the problem is that i want to add a (Map.Map Predicate (BotAwesome ())) to botData
20:14:37 <adnap> lol BotAwesome :)
20:14:40 <gs4_> :P
20:14:58 <gs4_> kmc: hm.. ok, i was running into trouble doing that before because it then couldnt infer the inner types right
20:15:03 <gs4_> kmc: any good reading on using newtypes?
20:15:12 <kmc> gs4_, "newtype" is mostly just an optimization on "data"
20:15:22 <kmc> you can just use "data" instead for simplicity
20:15:45 <gs4_> kmc: hm.. ok, if its that similar i should be able to figure it out
20:16:05 <gs4_> kmc: thanks for the advice :)
20:20:21 <gs4_> adnap: where's splitwith defined?
20:20:39 <gs4_> adnap: nvm got it
20:20:42 <lispy> gs4_: http://book.realworldhaskell.org/read/monad-transformers.html
20:20:52 <lispy> gs4_: See the section, "Hiding our work"
20:20:54 <adnap> gs4_: Yeah, don't trust the code to compile.
20:21:08 <gs4_> lispy: terrific, thanks :)
20:22:00 <ClarkG> how do I wrap a string over multiple lines?
20:22:12 <adnap> gs4_: Here is an example structure: [5:hello2:3:cat0:3:dog0:]
20:22:38 <lispy> ClarkG: you have to put \ at the beginning and end of the lines
20:22:39 <sshc> Performance wise, is it reasonable to pass a giant hierarchical State type around for a program that requires a lot of state?
20:22:40 <adnap> gs4_: It's kind of like canonical s-expressions.
20:22:45 <gs4_> adnap: yeah, i was wondering if splitWith was going to give you trouble since it'll hit all the :'s, not just the first 3
20:22:55 <ClarkG> lispy can I see an exmaple?
20:22:56 <gs4_> adnap: haha yeah, its a pretty sweet format, thats why i got interested :P
20:23:08 <lispy> ClarkG: http://www.haskell.org/pipermail/haskell-cafe/2006-January/013911.html
20:23:10 <adnap> gs4_: Doh!  You're right.
20:23:13 <ClarkG> thanks!
20:23:19 <lispy> ClarkG: I tend to prefer the unlines variant
20:23:28 <adnap> gs4_: That's not my main problem though.
20:23:41 <adnap> gs4_: I can't figure out how to recurse or do a fold.
20:23:47 <ClarkG> thanks. barely noticed that. and yes it is nicer.
20:23:50 <ClarkG> I think I'll use it :)
20:23:52 <lispy> ClarkG: because typically you want the newlines in the multiline string.  But with the \ \ trick they get stripped out
20:24:03 <gs4_> adnap: hehe yeah, im gonna play with it, but i watned to make sure i had the right stuff to play with first
20:24:58 <sshc> Performance wise, is it reasonable to pass a giant hierarchical State type around for a program that requires a lot of state, such as a game?  Even if almost everything in the State type is evaluated strictly, will everything but what is being changed still be copied?
20:25:04 <adnap> gs4_: I might have to replace the split with a break or something.
20:25:17 <gs4_> adnap: yeah, im trying it with span right now
20:25:36 <EvanR> @hoogle [a] -> Maybe a
20:25:45 <EvanR> toMaybe?
20:25:52 <EvanR> listToMaybe
20:26:02 <gs4_> adnap: break looks really similar; im just not used to the bytestring lib
20:26:27 <adnap> gs4_: It's just like the list versions.  break just negates the predicate.
20:28:25 <gs4_> adnap: ah, nice. Question about the format: is c always a single char?
20:29:14 <lispy> bos++ -- criterion is nice!
20:29:39 <adnap> gs4_: No, it can be infinite.  The numbers are encoded in ASCII.
20:30:02 <gs4_> adnap: ah ok... but no : before the number of children?
20:30:36 <adnap> gs4_: Right, because the first number says how long the dhe data is.
20:30:54 <gs4_> gs4_: ah, gotcha, its just the size of b, not of everything following... i see
20:32:13 <adnap> gs4_: Sorry for the typos, the connection to my server just started lagging.
20:32:24 <gs4_> adnap: haha, no worries
20:36:27 <kmc> sshc, seems reasonable. the nature of functional updates is that you only copy a path from the root of the structure to what changed
20:36:38 <kmc> the rest will be shared with the old version
20:39:00 <sshc> kmc: Should I use bang patterns in the giant data type definitions?
20:39:23 <adnap> gs4_: Mine looks like this now: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28971#a28976
20:42:21 <gs4_> adnap: hehe, thats about where i am... im trying to get it to compile the parsing code right now before i try to get it to recurse at all
20:42:51 <kmc> sshc, if you like
20:43:30 <adnap> gs4_: Yeah, you could always give (Gonad LBS.empty []) as the result.
20:43:55 <adnap> gs4_: Thanks for helping my btw.
20:44:33 <sshc> kmc: If I use a giant data type, and I use State's modify (\x -> x{foo = bar}) to change only one thing, will everything else be copied, severely adversely performance?
20:45:11 <sshc> s/performance/affecting/
20:45:24 <sshc> or rather s/(performance)/affecting \1/
20:46:04 <kmc> in GHC a record is implemented as a vector of pointers
20:46:19 <kmc> and an update will copy all the pointers into a new vector
20:46:25 <kmc> but will not deep-copy the pointed-to data
20:46:28 <kmc> unless you make an effort to do so
20:47:08 <sshc> I see.
20:47:08 <dyjytyl> aint i so fresh? aint i so fly?
20:47:10 <sshc> That's good to know; thanks.
20:48:06 <sshc> kmc: What approaches have you generally used for games, or other applications that require a lot of state?
20:48:25 <kmc> a big record
20:48:32 <kmc> which you update functionally
20:48:37 <kmc> or a big record of IORefs which you write to directly
20:49:05 <dyjytyl>  (loop [a "bitches" b "money"] (fuck a) (get b) (recur a b))
20:49:12 <dyjytyl> yeaaaaaaa
20:49:35 <sshc> The only thing I don't like updating records is the syntax ("modify $ \x -> x{foo = bar}" or such)
20:49:43 <sshc> Is there a cleaner solution?
20:50:02 <kmc> sshc, one of the packages like fclabels
20:50:03 <sshc> I'm not familiar with Template Haskell.  Could it be used for this purpose?
20:50:20 <gs4_> sshc: why not just regular helper functions?
20:50:33 <kniu> Oracle sues Google over Java.
20:50:41 <sshc> gs4_: I don't like boiler plate code, or whatever that term is
20:50:43 <kniu> What does this mean for Haskell?
20:50:53 <kmc> kniu, nothing?
20:50:58 <kniu> Boring.
20:50:59 <gs4_> sshc: but yes, you could probably also use template haskell (http://www.haskell.org/bz/th3.htm)
20:51:14 <sshc> Does RWS cover TH?
20:51:17 <kmc> no
20:51:23 <ezyang> Abbreviations on the left side of => would be nice. :-) 
20:51:26 <kmc> sshc, fclabels uses TH to generate useful accessor/modifier functions
20:51:44 <sshc> I'll look at that.
20:52:25 <sshc> What reference would you suggest for learning template haskell?  I'm completely unfamiliar with it.
20:52:49 <gs4_> sshc: what i meant by helper functions though was that if you write a setX you can just do "modify $ setX 3".. you do have to write setXs though... so i could see TH helping there
20:52:51 <kmc> the paper
20:52:55 <kmc> the API haddock
20:53:11 <gs4_> sshc: http://www.haskell.org/bz/th3.htm is the best ive found, but i havent looked too hard :P
20:53:40 <EvanR> what use is TH
20:53:55 <sshc> EvanR: I think the term is metaprogramming
20:54:05 <gs4_> EvanR: you can write code that writes code.. so for instance, to generate a bunch of accessors from a single list
20:54:44 <gs4_> EvanR: yep, metaprogramming. ruby and lisp/scheme use it a lot, though in somewhat different styles
20:55:21 <EvanR> id rather be able to achieve the effect without resorting to mechanical means to write redundant code
20:55:25 <kmc> yes
20:55:34 <kmc> TH is a powerful tool of last resort
20:55:39 <kmc> we'd usually rather use something else
20:56:00 <kmc> sometimes even CPP is cleaner
20:56:13 <gs4_> kmc: uh.. what?
20:56:14 <gs4_> :P
20:56:47 <kmc> ?
20:56:52 <gs4_> kmc: cpp, really?
20:56:57 <sshc> He probably doubts it
20:57:04 <kmc> c preprocessor yes
20:57:05 <sshc> He probably wants an example
20:57:11 <kmc> good thing i have one :)
20:57:15 <sshc> Both of which are true for me too
20:57:21 <gs4_> lol
20:57:32 <kulin> are you not allowed to use type classes with ffi:  foreign import ccall "example" example :: TClass a => Int -> a -> IO ()
20:58:03 <kmc> kulin, you're not, FFI imports must have monomorphic types of a certain simple form
20:58:15 <kulin> so sad
20:58:17 <kmc> a while back someone in here was asking how to make a function-like thing which would act like this:
20:58:29 <kmc> f x = "x = " ++ show x
20:58:49 <kmc> where the code for x is spliced into that string
20:58:54 <adnap> How can I clean this up: decodeNumericString bs = read ((map (chr . fromIntegral) . LBS.unpack $ bs) :: String)
20:59:04 <gs4_> adnap: lol, sorry, this parsing code is harder than i thought itd be for my tired brain :P
20:59:10 <kmc> so e.g. Â«f (2+3)Â» should evaluate to "(2+3) = 5"
20:59:19 <adnap> It's complaining if I don't say the type.
20:59:23 <sshc> :type \x -> "x = " ++ show x
20:59:27 <adnap> gs4_: Okay
20:59:29 <kmc> this is clearly beyond the realm of regular haskell
20:59:35 <gs4_> adnap: did someone else give you this format or did you come up with it?
20:59:37 <adnap> gs4_: Thanks for trying.  I'm trying to get it so that it compiles.
20:59:44 <sshc> kmc: RWS has an example of that, actually
20:59:47 <kmc> and you could do it with TH, maybe, but it'd be a pain
20:59:50 <sshc> kmc: Without using Template Haskell
20:59:51 <kmc> sshc, oh?
21:00:07 <sshc> They made an expression thing type an instance of Num
21:00:14 <kmc> right, this was mentioned too
21:00:17 <kmc> but it doesn't scale
21:00:20 <kmc> to arbitrary expressions
21:00:27 <adnap> gs4_: My friend came up with it.  It's slightly different from canonical s-expressions.
21:00:27 <kmc> it's a hack with a limited domain
21:00:35 <kmc> whereas there's a 1-line CPP macro which solves this problem cleanly
21:00:51 <sshc> How cleanly?
21:01:01 <kmc> five
21:01:02 <EvanR> 1 line cleanly? lol
21:01:41 <sshc> Hehe, I think I wanted to know what the macro was
21:01:43 <EvanR> theoretical minimum is 0.707 lines
21:01:50 <kmc> sshc, trying to find it
21:01:54 <sshc> je'e
21:02:20 <adnap> Ah, nevermind about the decodeNumbericString function.  I don't know why it was complaining.  This works now: read . map (chr . fromIntegral) . LBS.unpack
21:04:21 <kmc> sshc, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28979#a28979
21:04:31 <kmc> the main ugliness is
21:04:37 <kmc> a) you have to use C function call syntax, not haskell
21:04:51 <kmc> b) GHC's builtin CPP doesn't handle the stringify operator, so you have to use an external cpp
21:05:19 <kmc> still i think this is a cleaner solution than the others mentioned
21:05:26 <Phyx-> doesn't ghc also call an external tool?
21:05:35 <kmc> i dunno but it's not /usr/bin/cpp
21:06:13 <kmc> i think for replicating a bunch of functions or instances or such, with one token replaced in a purely mechanical way, CPP is a fine solution
21:06:26 <kmc> TH is worth the complexity when the algorithm generating your code is more than a simple fill-in-the-blank
21:07:24 <Phyx-> kmc: well, here it's C:\ghc\ghc-6.12.1\mingw\bin\cpp.exe
21:08:04 <kmc> Phyx-, does it handle stringify?
21:08:08 <adnap> gs4_: It should nearly compile now, but it's complaining that it wants a GHC.Int.Int64 in the splitAt function instead of an Int. What?! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28971#a28980
21:08:10 <kmc> i.e. if you remove that OPTIONS_GHC line, does my code work?
21:08:54 <gs4_> adnap: haha yeah, i was running into that too for a bit... my suggestion is to skip all the bytestrng stuff and write the algorithm over basic Strings first
21:09:09 <gs4_> adnap: ive had trouble with bytestrings in the past... they have some idiosyncracies i think
21:09:43 <adnap> gs4_: Yeah, I think I'm just avoiding that. XD  It makes my head hurt.
21:10:09 <gs4_> adnap: hah yeah, id try with just strings first -- then you can focus on the recursion mostly -- converting later shouldnt be bad
21:10:11 <Phyx-> kmc: nah, get a syntax error
21:10:40 <gs4_> adnap: i think im gonna go to sleep now, but if you want to put this on github id be interested in playing with it again at some point if you dont get it
21:11:09 <adnap> gs4_: Okay
21:11:56 <gs4_> adnap: my github usenamer is just gs4, so if you decide to put it up just send me a pull request or whatever they call it
21:39:30 <nejucomo> When I give invalid input to read, my program prints out "Test: Prelude.read: no parse", then exits.
21:39:49 <nejucomo> I can't tell if this is an exception, and if so, what type so that I can catch it?
21:43:16 <dibblego> nejucomo, use reads
21:43:48 <lispy> :t reads
21:43:55 <lispy> ?bot
21:44:54 <nejucomo> I see.  Does reads always return a list with 0 or 1 elements?  (A primitive Maybe ?)
21:45:15 <nejucomo> Thanks.
21:45:27 <Phyx-> lispy: it died
21:45:36 <Phyx-> lispy: netsplitism
21:45:38 <lispy> Phyx-: when is the funeral?
21:46:18 <Phyx-> lispy: we have to find the body first... it was kinda dragged off in the flood
21:49:33 <dolio> nejucomo: It doesn't necessarily. But all the standard Read instances are unambiguous.
22:46:55 * hackagebot terminfo 0.3.1.3 - Haskell bindings to the terminfo library.  http://hackage.haskell.org/package/terminfo-0.3.1.3 (JudahJacobson)
22:48:31 <itegebo> is code.haskell.org supposed to be up?
22:49:35 <dibblego> @type (=>>)
22:50:28 <aavogt> itegebo: it is... just not over http apparently
22:51:08 <itegebo> okay, i was looking for parsec-3.1.0 in darcs
22:53:49 <kulin> so is there any pattern for working with ffi and parent classes?
22:54:06 <kmc> can you be more specific?
22:54:37 <kulin> well i have a function in c that takes a container ptr, and i have 2 pointers in haskell to c classes which extend container
22:55:40 <kmc> c classes?
22:55:47 <kulin> well c++
22:56:15 <kulin> i was thinking about making an type class, and having that typeclass have a function called 'toContainer' which basically just runs castPtr
22:56:30 <kulin> but i was curious what other people do
22:57:08 <kmc> so you want a Haskell type to represent each of the derived classes?
22:57:14 <kmc> and a way to cast them up to base?
22:57:14 <kulin> yes
22:57:33 <kmc> btw castPtr will not do a correct C++ pointer cast in some situations
22:57:36 <kmc> multiple inheritance definitely
22:57:43 <kmc> but possibly others depending on compiler etc
22:58:19 <kmc> x and Â«(foo*) xÂ» can be different addresses
22:58:28 <kmc> commonly if foo is one of several base classes of x's dynamic type
22:58:36 <kmc> but maybe under other situations; i'm not sure what the guarantees are
22:59:13 <kulin> hmm
22:59:14 <kmc> anyway disregarding these issues, the design you suggested sounds reasonable
23:00:02 <kulin> alright then, thx
23:00:13 <kmc> safest would be to do the cast on the C++ side
23:00:26 <kmc> and foreign import one cast function per derived type
23:00:40 <kulin> hmm good idea
23:00:55 <kmc> slower and more complicated tho
23:12:34 <dibblego> http://paste.pocoo.org/show/249670/ can anyone see why z does not terminate?
23:13:17 <dibblego> http://paste.pocoo.org/show/249672/ no unicode
23:15:52 <Saizan_> how does it not terminate, specifically?
23:16:15 <dibblego> I get an infinite TreeLoc
23:17:01 <dbelange> use hugs
23:17:03 * hackagebot improve 0.0.6 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.0.6 (TomHawkins)
23:19:40 <Saizan_> ?hoogle unfoldTree
23:20:45 <azaq231> bot is dead
23:21:11 <BMeph> Long live the bot!
23:24:41 <azaq231> @ping
23:24:47 <lambdabot> pong
23:24:54 <azaq231> that's timing
23:28:39 <kmc> @bot
23:28:40 <lambdabot> :)
23:28:47 <etpace> @hoogle [m a] -> m [a]
23:28:48 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
23:28:48 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
23:28:48 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
23:29:01 <etpace> sequence doesnt work on infinite lists right?
23:29:10 <kmc> @src sequence
23:29:10 <lambdabot> sequence []     = return []
23:29:11 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:29:11 <lambdabot> --OR
23:29:11 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
23:29:33 <kmc> > sequence $ map Just [1..]
23:29:35 <lambdabot>   *Exception: stack overflow
23:29:51 <kmc> > sequence $ map (:[]) [1..]
23:29:53 <lambdabot>   *Exception: stack overflow
23:30:33 <kmc> etpace, there might be some monads where it works
23:30:45 <kmc> depending on how (>>=) is defined
23:31:08 <kmc> > take 20 $ sequence $ map (:[]) [1..]
23:31:10 <lambdabot>   *Exception: stack overflow
23:31:31 <kmc> > runIdentity . sequence . map Identity $ [1..]
23:31:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:31:36 <kmc> ^^^^ there's one
23:32:08 <etpace> heh
23:32:32 <etpace> I think this monad is EitherT State or something
23:33:28 <kmc> i'm not sure of an *interesting* monad where sequence works on an infinite list.  anyone?
23:33:39 <kmc> > sequence $ repeat Nothing
23:33:40 <lambdabot>   Nothing
23:33:51 <Saizan_> dobblego: right is too similar to left :)
23:33:51 <kmc> ^^^^ that's *some* kind of infinite list ;)
23:34:57 <dibblego> Saizan_, got it thanks!!
23:44:33 <jrockway> hah, finally catching up on haskell-cafe
23:44:40 <jrockway> why exactly is investment banking evil again?
23:44:52 <jrockway> we just sit in the middle of transactions and take a cut
23:45:10 <jrockway> not much different than the grocery store selling you a jug of milk for more than they bought it for
23:45:11 <etpace> also use cool languages :)
23:45:20 <jrockway> except our industry actually pays for programmers :)
23:45:25 <dbelange> APL
23:45:26 <dbelange> J
23:45:27 <dbelange> K
23:45:32 <etpace> haskell
23:45:51 <dbelange> C++
23:46:03 <jrockway> C++ is losing popularity
23:46:09 <jrockway> i think people have finally realized what a mess it is
23:46:30 <jrockway> threads and smart pointers and smart smart pointers and refcounting smart pointers and smart pointer casts and ...
23:46:42 <jrockway> no agreed-upon convention for representing strings
23:46:48 <jrockway> (ok, perhaps haskell has that problem too)
23:46:57 <etpace> everyone agrees on bytestrins
23:47:45 <jrockway> yeah :)
23:47:45 <dbelange> C
23:47:50 <Heffalump> jrockway: you could argue that investment banks have effectively developed a cartel
23:48:10 <dbelange> Heffalump: He could argue that.  Are you arguing it?
23:48:29 <jrockway> isn't that like saying amazon is a cartel because they offer really low shipping costs, because they made deals with UPS?
23:48:37 <Heffalump> I don't know how to prove they haven't :-)
23:48:38 <jrockway> anyone can trade OTC instruments
23:48:51 <Heffalump> jrockway: that's the point, there's a really high barrier to entry for that
23:48:53 <jrockway> they just can't compete with the big banks because the big banks spend their money developing software to do a better job than you
23:49:03 <dbelange> In haskell?
23:49:18 <dibblego> "banks ...  developing software to do a better job than you" <-- :)
23:49:33 <etpace> a few use haskell dbelange 
23:49:38 <jrockway> i should probably not comment, but i am currently replacing a C++-based pricing program with haskell :)
23:49:41 <etpace> prop desks mostly though
23:50:14 <jrockway> it's great, because the C++ version is 1% actual code and 99% rewriting threads and smart pointers
23:50:18 <jrockway> so rewriting is actually easy
23:50:19 <Heffalump> jrockway: who do you work for? Or does that come under "i should probably not comment? :-)
23:50:35 <jrockway> hah, yeah, dunno what the policy is on that
23:50:38 <jrockway> bank of america :)
23:50:50 <Heffalump> interesting. Official, or skunkworks?
23:51:05 <jrockway> it's not a super-big piece of infrastructure
23:51:09 <jrockway> as long as it works, everyone is happy
23:51:22 <jrockway> the original authors of the C++ realized they made a mess and the entire team quit
23:51:23 <Heffalump> what happens when it needs debugging in prod? :-)
23:51:27 <jrockway> so haskell is not a big deal
23:51:39 <jrockway> someone calls me :)
23:51:46 <BMeph> jrockway: More importantly, why - don't get me wrong, I admire your courage, and streong stomach... still, why - do you keep bashing your head against the stubbornly dull populace known as Hacker News? ;)
23:51:58 <BMeph> Er, *strong
23:51:58 <jrockway> i don't know
23:52:15 <jrockway> i feel that information and explanation can lead people in the direction of discovering knowledge for themselves
23:52:21 <jrockway> not everyone is a langauge zealot
23:52:27 <jrockway> some people honestly think monads are hard
23:52:34 <Heffalump> have you tried talking to jdh? :-)
23:52:44 <jrockway> if they can mentally get over that, with the right explanation, perhaps they will like haskell
23:52:47 <jrockway> and write libraries for me :)
23:53:06 <Heffalump> jrockway: are you using much stuff from hackage, out of interest?
23:53:12 <jrockway> yes
23:53:17 <jrockway> i have one production application already
23:53:21 <jrockway> it's a historical data thing
23:53:33 <jrockway> reads data from this very broken C library, publishes it in a variety of formats
23:53:39 <jrockway> let's see what packages i use
23:53:54 <Heffalump> (I work for Credit Suisse btw - when we were doing Haskell stuff a few years back hackage was only just getting going. If we were starting it now then I suspect we'd use a lot more.)
23:54:45 <jrockway> yeah, i have found that using third-party libraries is not really a big deal at the bank
23:54:57 <jrockway> the java developers do it, the perl developers do it (i mostly do perl), the haskell developers do it
23:55:02 <jrockway> even the people writing C++ use boost :)
23:55:16 <Heffalump> haskell developers plural? Sounds better and better :-)
23:55:21 <jrockway> we actually have an official mandate "from the top" to use more new languages
23:55:31 <jrockway> they love python the most, but i am ok with that
23:55:48 <jrockway> the CTO saying "we should kill C++ and java and use python instead" leaves a lot of room for haskell to shine
23:56:08 <Heffalump> how well integrated with Merrill are you? Do they still have their own organisation and codebase?
23:56:20 <jrockway> we are pretty well-integrated
23:56:35 <jrockway> we have killed BAC systems in favor of ML systems, and vice-versa
23:56:48 <jrockway> and my ML investment balance shows up on bankofamerica.com ;)
23:57:03 <jrockway> also, here's the list of libraries i use for my simple ETL app: base >= 4, mtl, bytestring, time, datetime, directory, directory-tree, haskell98,
23:57:06 <jrockway> containers, test-framework, test-framework-quickcheck2, test-framework-hunit,
23:57:09 <jrockway> test-framework-th, QuickCheck >= 2.1, regex-tdfa, HUnit
23:57:12 <jrockway> (that's for the test suite anyway)
23:57:20 <dbelange> What about your ocaML investment balance lololololololoofl
23:57:23 <Heffalump> so mostly but not all stuff from ghc
23:57:32 <Heffalump> or ghc as-was, anyway
23:57:33 <jrockway> yeah
23:57:36 <jrockway> also use c2hs and hsftp
23:57:54 <jrockway> will be using binary soon
23:58:01 <jrockway> (as i convert from strings to bytestrings, yeah...)
23:58:08 <Heffalump> I think the main things our biggest projects use/used was HaXML and parsec.
23:58:32 <jrockway> that will come up in the next project, i think
23:58:37 <jrockway> there is a lot of XML involved
23:58:49 <jrockway> XML is used as an internal programming language, and i want to replace that with something human-readable
23:58:55 <jrockway> parsec + haxml is the logical choice
23:59:20 <jrockway> (incidentally, i sold my coworkers on haskell by writing a robust CSV parser on the ghci command line)
23:59:30 <jrockway> three lines of code and it was already better than excel :)
23:59:38 <dibblego> using parsec?
23:59:56 <etpace> we found parsec too slow for csv parsing
