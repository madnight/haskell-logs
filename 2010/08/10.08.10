00:00:36 <etpace> i don't think that will do what I want it to do though
00:00:46 <etpace> it'll build up the >>= chains and then evlauate at the end, right?
00:02:28 <Saizan> foldM is already foldlM
00:03:29 <Saizan> and yeah, yours will perform the side-effects only after the whole list is traversed
00:04:05 <etpace> i need a foldM that works on ListLikes though, so i tried to implement it naievely
00:06:57 <c_wraith> Isn't foldM part of traverseable?  What do you need listlike for?
00:16:27 <Phyx-> @time
00:16:30 <lambdabot> Local time for Phyx- is Tue Aug 10 09:15:59 2010
00:16:38 <Phyx-> I should probably go to bed
00:16:44 <etpace> using it as part of iteratees c_wraith 
00:24:39 <ezyang> iteratees current version sucks, they should release v4 
00:26:22 <springs> noob Q: how do i generate tags recursivelly through folders
00:26:32 <earthy> ezyang: explain?
00:26:55 * earthy just started rewriting some code to use iteratees, so kinda interested. ;)
00:28:47 <etpace> the types are pretty ugly earthy 
00:28:53 <etpace> as well as a lot of the IterateeG stuff
00:28:54 <ezyang> Mostly naming problems. 
00:29:13 <etpace> is he fixing [] el to become [el]
00:29:18 <etpace> like a sane person
00:29:31 <ezyang> I sent mail to Lato, but I hear that he can be pretty busy with other stuff 
00:30:19 <earthy> etpace: so, rolling your own lib with saner types would be better? :)
00:30:41 <etpace> orjust making do, which is what we are doing atm
00:30:45 <Saizan> (so many six-letter nicks starting with e!)
00:31:20 <boscop> can any function be written in point-free style if the parameters appear in the body in the same order as in the parameter list?
00:32:24 <dolio> Any function can be written point-free given the right base combinators.
00:32:36 <dolio> And you only really need two.
00:32:46 <dolio> Sfgx = fx(gx) and Kxy = x
00:33:01 <c_wraith> Assuming you don't need to pattern-match, that is.
00:33:08 <ezyang> See also @pl 
00:33:18 <kmc> in a typed LC you also need a "fix" primitive, i think
00:33:26 <kmc> otherwise you cannot write general recursion
00:33:38 <dolio> Yeah, if you have data, you need combinators for building it and taking it apart.
00:33:59 <dolio> And yeah, you probably need fix for typed combinators.
02:01:55 * ivanm is contemplating whether or not to put a pre-order in for Bird's new book
02:02:08 <dolio> What's it on/
02:02:40 <ivanm> http://www.amazon.com/exec/obidos/ASIN/0521513383/ref=nosim/bookie09-20
02:03:18 <Starfire> Woah. Is it just me or did cabal (or cabal-install) get a lot faster in the new platform?
02:03:35 <ivanm> I doubt it made a difference
02:03:59 <ivanm> since there were no meaningful optimisations added in 6.12.3 from 6.12.2 AFAIK
02:04:06 <ivanm> and no large changes to cabal-install
02:04:14 <Starfire> Perhaps it's just me then.
02:04:51 <Saizan> yeah, it's probably just a change in the flow of time
02:05:39 <fasta> Starfire, Cabal does trivial computations. If it uses a lot of CPU, it's doing something wrong. 
02:05:55 <ivanm> maybe you're just comparing different packages?
02:06:09 <ivanm> or a package has since been updated to be faster to compile than what it used to be?
02:06:24 <fasta> Starfire, that is, the normal state of cabal-install is to be fast, but it could do more I/O in parallel, I think. 
02:06:41 <Starfire> Yeah. I'm not really comparing anything here, just a subjective feeling.
02:08:54 <Starfire> Hmm. Is it possible to make 'cabal haddock' use ~/.cabal/bin/haddock instead of /usr/local/bin/haddock ?
02:09:00 <ivanm> yes
02:09:15 <ivanm> put ~/.cabal/bin in your PATH before /usr/local/bin
02:09:31 <Starfire> It should be so already.
02:09:42 <ivanm> echo $PATH
02:09:50 <Starfire> And running 'haddock -V' from the shell reports the newest version.
02:10:17 <Starfire> But 'cabal haddock --verbose=3' shows that cabal is invoking from /usr/local/bin
02:10:54 <ivanm> what does your PATH say?
02:11:18 <Starfire> ~/.cabal/bin is the first entry, /usr/local/bin is the third entry.
02:11:22 <ivanm> remember, you have to use $HOME/.cabal/bin or /home/<username>/.cabal/bin, as cabal-install doesn't like ~/.cabal/bin
02:11:35 <Starfire> It's actually /home/<username/.cabal/bin
02:12:06 <ivanm> huh
02:12:08 <ivanm> weird
02:12:09 <Zao> My home is not /home/. I find you people discriminatory!
02:12:19 <ivanm> Zao: what is your's then?
02:12:24 <ivanm> preflex: seen dcoutts 
02:12:24 <preflex>  dcoutts was last seen on #ghc 21 hours, 32 minutes and 47 seconds ago, saying: * dcoutts disappears for a bit
02:12:32 <fasta> Starfire, actually there is a Haskell expression which shows it. 
02:12:46 <fasta> Starfire, it is on the wiki somewhere unless someone deleted it.
02:13:01 <Zao> Depends on box, /Home/staff/zao or /home/z/zao
02:13:30 <fasta> Zao, any particular reason for doing so in the latter case?
02:13:34 <Zao> (guess how hard the OS X mounter breaks on having both /Home and /home by the way :D)
02:13:43 <ivanm> Zao: on, OSX?
02:13:45 <Zao> fasta: Lots of users.
02:13:46 <Starfire> fasta: Shows how to make cabal run from ~/.cabal ?
02:13:53 <ivanm> go use a _real_ unix-based OS! :p
02:14:01 <byorgey> luite: around?
02:14:08 <Zao> ivanm: I'm currently on AIX. Is that UNIXy enough for you?
02:14:25 <ivanm> yeah, I suppose so
02:15:21 <Zao> fasta: As for conventions, /Home is for special users, /home is for mortals.
02:15:42 <Saizan> Starfire: you can overwrite with --with-haddock=$HOME/.cabal/bin/haddock
02:15:52 <Saizan> *override
02:15:56 <Starfire> And I can put that in my cabal config?
02:16:01 <Saizan> not sure
02:16:03 <fasta> Zao, lusers is what the official designation is, not? 
02:16:24 <byorgey> @tell luite animation, definitely.  As for interactivity, I hadn't thought about it before, so I'm not sure.
02:16:24 <lambdabot> Consider it noted.
02:16:34 <Saizan> though i'd still think something is fishy wrt your $PATH if it's not picked up automatically
02:16:48 <Saizan> Starfire: are you running cabal-install with sudo?
02:17:15 <Starfire> Saizan: Not in this case, no.
02:17:34 <Starfire> --with-haddock works from the command line, but not from .cabal/config
02:17:58 <ivanm> Zao: most multi-user setups I've used (linux and solaris only) have had the remote directory mapped to /home/<username>; interesting that yours doesn't
02:18:40 <Starfire> Well, I guess I can live with this, especially since Haddock 2.7.2 doesn't hyperlink my operators properly either. :P
02:18:49 <Zao> ivanm: We automount users on demand.
02:19:00 <ivanm> *nod*
02:19:11 <ivanm> so, when you're logged on, does /home/<username> work?
02:19:22 <Zao> Heck, we have individual filesystems per user :D
02:19:23 <Zao> /home/zao: No such file or directory.
02:19:49 <Zao> $(HOME) is /home/z/zao, as intended.
02:19:54 <Zao> Err, ${}.
02:19:57 <ivanm> why "as intended" ?
02:20:15 <fxr> Zao: afs?
02:20:22 <Zao> Historical reasons, I reckon.
02:21:40 <Zao> Our network is highly heterogeneous, with Solaris, AIX, Linux, OSX, IRIX in the past.
02:21:55 <Zao> It's quite fun getting NFS and Kerberos working properly :D
02:22:12 <Zao> Oh. This isn't -blah. Sorry.
02:22:56 <fxr> afs and kerberos is a better choice
02:23:33 <ivanm> eh, there's no non-blah discussions here atm anyway ;-)
02:25:45 <byorgey> the point is that -blah discussions can discourage people from starting non-blah discussions.  but anyway, you're right =)
02:26:26 <ivanm> true
02:32:42 * byorgey makes Yorkshire-lambda pudding
03:06:43 <BorisL> @pl \f a b -> f b
03:06:44 <lambdabot> const
03:06:56 <freiksenet> Hi! I wonder if there are any libraries for Haskell that implement Red-Black trees. I know there is Okasaki's implementation, but I was wondering if anyone packaged that to a library
03:07:29 <Saizan> tried hackage?
03:07:34 <freiksenet> couldn't find
03:09:24 <ivanm> don't think there are any
03:09:34 <ivanm> any particular reason you want a red-black tree rather than a Set or a Map?
03:10:23 <freiksenet> I want to make an Ordered Stack, basically I thought it is quite similar to priority queue and priority queues are usually made with binary balancing trees. Maybe I am doing something wrong of course.
03:10:39 <freiksenet> It can be called priority stack
03:10:52 <freiksenet> basically LIFO, but with "priority".
03:10:54 <ivanm> there are various priority queue implementations on hackage...
03:11:14 <ivanm> and it's quite possibly someone used a red-black tree as part of something but didn't actually call it a red-black tree
03:11:28 <freiksenet> ok, I will take a look. thanks
03:12:58 <freiksenet> I guess I can just use Data.Map
03:13:16 <Zeiris> If I wanted to get a Haskell job. What do I need asides from releasing fancy code/helping public projects? Do I need a degree? A masters?
03:13:42 <ivanm> Zeiris: usually not
03:13:53 <ivanm> just the ability to code, know enough haskell, etc.
03:14:00 <ivanm> however, a CS or related degree couldn't hurt
03:14:11 <ivanm> gives you a more thorough background/understanding of the field
03:14:14 <Zeiris> Does not having a degree set a ceiling on wages/advancement?
03:14:41 <ivanm> Zeiris: main motivation I've heard of having a degree (assuming all else equal): if someone has to be fired, it's usually the one without the degree
03:14:49 <mreh> usually a degree is a piece of paper that employers like people to have, and also like to show off how many pieces of paper they have in their office
03:14:58 <arw> Zeiris: strongly depends on the company.
03:15:31 <ivanm> mreh: also indicates that you bothered to spend x years of your life learning about the field in question rather than immediately getting a job
03:15:34 <arw> Zeiris: usually the smaller and the less official ones also don't place that much value in degrees and titles.
03:16:14 <arw> Zeiris: but in larger companies and in the public sector, there are definitive hurdles which you won't be able to cross without a degree
03:16:35 <arw> Zeiris: at least here in germany, don't know about the rest of the world
03:16:51 <Zeiris> Thank you for your detailed replies. :)
03:18:06 <Zeiris> (What companies in the public sector use Haskell?)
03:19:34 <quicksilver> I don't have the impression that degrees are that critical in the UK these days
03:19:35 <DrSyzygy> Public sector?
03:19:42 <quicksilver> they can certainly help for your first job
03:19:54 <quicksilver> but once you get over that hurdle and have some actual experience on your CV
03:19:59 <quicksilver> I'm don't think it's a big deal.
03:23:11 <zygoloid> Zeiris: i think anyone smart and talented could get a job where i work, degree or not. however, all of my colleagues have degrees (and quite a few have doctorates)
03:23:44 <zygoloid> probably that's because smart people are pushed quite hard into universities here in the UK
03:28:07 <ivanm> quicksilver: yeah
03:28:16 <ivanm> of course, if you want to do research, having a degree helps :p
03:30:17 <fasta> Zeiris, if you want to make a lot of money, you should get a banking license. 
03:30:59 <Zeiris> If I want to make a lot of money I should go back in time 4 years, and enroll in commerce rather than comp eng. Or at least comp sci instead of comp eng.
03:31:42 <fasta> Zeiris, all commerce needs comp sci knowledge these days. 
03:31:53 <Zeiris> Or maybe just spend my tuition money on coffee, and put all those all-nighters to use hacking away :)
03:32:20 <fasta> Zeiris, anyway, with a banking license you can multiply whatever you own by a factor of 9 or so. 
03:33:13 <Zeiris> Don't you need to be... I don't know. Big, trustworthy, and government-sponsored to run a bank? I always thought they were Serious Business.
03:33:30 <FunctorSalad_> ugh. 'getFileStatus' could use a better error message upon file-not-found... such as the filename
03:33:34 <ivanm> Zeiris: you have to be trustworthy enough to get people to give you money
03:33:43 <fasta> Zeiris, trustworthy and banks? 
03:33:46 <ivanm> and enough lawyers, etc. to fill out government paperwork :s
03:33:51 <ivanm> FunctorSalad_: heh
03:33:52 <ivanm> fasta: heh
03:34:00 <FunctorSalad_> sorry, I retract that
03:34:06 <fasta> Zeiris, you must be the funniest guy in the family.
03:34:20 <ivanm> http://en.wikipedia.org/wiki/The_Bank_%282001_film%29
03:34:26 <FunctorSalad_> hoogzor: executable-path: getFileStatus: does not exist (No such file or directory)
03:34:34 <FunctorSalad_> (this was my error message)
03:34:40 <FunctorSalad_> can you spot the filename? ;)
03:35:08 <FunctorSalad_> err hoogzor is my program
03:35:42 <ivanm> executable-path ?
03:37:35 <ketil> FunctorSalad_, I tend to get this all the time - (i.e. a filename of "")
03:37:52 <ketil> Probably because I use CmdArgs, where this is the default value.
03:38:03 <zygoloid> FunctorSalad_: is the file called executable-path? ;)
03:47:18 <FunctorSalad_> zygoloid: apparently
03:48:12 <FunctorSalad_> *looks* yes
03:48:32 <FunctorSalad_> that totally sent me down a red herring chase
03:48:45 <FunctorSalad_> (thought some rawSystem was wrong)
04:00:34 <interferon> is there a preferred library for doing Erlang-style concurency in haskell?
04:00:53 <ivanm> there's the new DSTM library
04:01:02 <ivanm> that's the closest there is AFAIK
04:02:18 <interferon> i saw that on -cafe, it looks awesome
04:02:28 <interferon> but it's STM rather than message passing
04:02:49 <ivanm> http://www.haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism
04:03:11 <ivanm> bernie pope was working on a new MPI binding; no idea if he finished/released it though
04:07:34 <interferon> ivan: cool, thanks for this
04:11:47 <ivanm> np
04:19:22 <drdozer> hi - has conal been in here recently?
04:21:50 <ivanm> preflex: seen conal
04:21:50 <preflex>  conal was last seen on #haskell 3 days, 17 hours, 56 minutes and 9 seconds ago, saying: dang, i love static typing.
04:22:26 <drdozer> thx
04:36:02 <osaunders> @pl fact n = if n == 1 then 1 else n * fact (pred n)
04:36:02 <lambdabot> fact = fix (ap (flip if' 1 . (1 ==)) . ap (*) . (. pred))
04:36:18 <osaunders> Jesus.
04:40:32 <Cale> > product . enumFromTo 1 $ 10
04:40:33 <lambdabot>   3628800
04:51:08 <Starfire> :t if'
04:51:08 <lambdabot> Not in scope: `if''
05:25:00 <Starfire> How long does it usually take to get a Hackage username?
05:26:15 <Cale> Starfire: I don't remember, but I don't remember it being very long. Maybe a day?
05:26:27 <Cale> (Are they still using humans?)
05:26:46 <Cale> Yeah, seems so
05:46:22 <luite> byorgey: I'm here now
05:46:22 <lambdabot> luite: You have 1 new message. '/msg lambdabot @messages' to read it.
05:50:40 <White-Shark> hi
05:50:59 * ivanm waves idly in White-Shark's general direction
05:51:11 <ian_> Does anyone know how long monads have been in the language?
05:51:28 <ivanm> ian_: I seem to recall about 92...
05:51:41 <copumpkin> back when I was a young'un
05:52:14 <ivanm> Haskell 1.3 got them, whenever that was
05:52:24 <White-Shark> HI BROTHER 
05:52:33 <White-Shark> i'am new in this rom 
05:52:53 <ivanm> well, 1.0 was in '90, and 98 was in '97
05:52:57 <ivanm> welcome White-Shark 
05:53:05 <ian_> ivanm: thanks
05:53:10 <White-Shark> thx ivan
05:53:59 <ivanm> I don't want any files from you
05:54:18 <copumpkin> White-Shark: do you have any haskell questions?
05:54:18 <White-Shark> ok
05:54:38 <copumpkin> we're here to help with haskell :)
05:54:41 <White-Shark> this is a rom of 
05:54:43 <White-Shark> hacking
05:54:45 <White-Shark> ?
05:54:47 <copumpkin> no
05:54:50 <ivanm> Haskell hacking, yes
05:54:52 <copumpkin> not in the sense you mean it, anyway
05:55:02 <ivanm> hacking in the "let's steal data and be idiots" sense, no
05:55:17 <White-Shark> so u can help me
05:55:18 <White-Shark> ??
05:55:29 <copumpkin> White-Shark: probably not, but if your question is about haskell, then yes
05:55:37 <copumpkin> not hacking though
05:55:56 <White-Shark> just i went to know about  DDOS
05:56:05 <copumpkin> then this isn't the right place :)
05:56:16 <copumpkin> also, that's known as being a script kiddie in most circles, and it isn't a good thing
05:56:19 <White-Shark> where 
05:56:23 <White-Shark> is the right place
05:56:23 <ivanm> if you want to cause DDOS, then piss off
05:56:24 <White-Shark> ?
05:56:31 <copumpkin> White-Shark: I don't know where, but it isn't here
05:56:42 <tab> *sigh*
05:56:48 <White-Shark> ok
05:56:53 <White-Shark> have a nice day
05:57:00 <dmorti> I've just installed the latest Haskell Platform.  I was wondering whether there is any way to get haddock-generated documentation from local cabal package installs to link to the documentation included in the platform?
05:57:10 <copumpkin> White-Shark: ciao :)
05:57:11 <ivanm> dmorti: as in one big index?
05:57:11 <ivanm> no
05:57:26 <ivanm> copumpkin: you really have acclimatised and re-integrated into italy, haven't you :p
05:57:36 <copumpkin> ivanm: hey, I said ciao before coming back here :P
05:57:53 <ivanm> oh, that's right, you did too
05:57:58 <ivanm> still... ;-)
05:57:59 <copumpkin> now I say it as I drive by on a scooter, though
05:58:03 <copumpkin> ;)
05:58:18 <ivanm> *groan* you've gone _that far_?
05:58:24 <copumpkin> lol no
05:58:51 <fasta> copumpkin, now all you have to do is get more corrupt and you will fit in nicely.
05:58:59 <copumpkin> :D
05:59:01 <dcoutts_> dmorti: cabal can generate a per-user index of all docs though
05:59:04 <copumpkin> I happily accept bribes
05:59:26 <fasta> copumpkin, and eat more pizzas to become nicely round like The Great Leader.
05:59:35 <copumpkin> lol
05:59:58 <dcoutts_> dmorti: see the doc-index-file in the ~/.cabal/config
06:03:00 <dmorti> ahh -- thanks.
06:08:11 <dpratt71> dcoutts_: thanks for the help yesterday; I added '#include <stddef.h>' to WideStringSrc.h and it built...with a lot of warnings
06:08:30 <dcoutts_> dpratt71: oh, great
06:08:42 <ian_> while adding a module in ghci, if it complains about being found in multiple packages, is there a way to disambiguate?
06:12:08 <Saizan> :set -hide-package
06:12:47 <ian_> Saizan: ha! thanks
06:17:39 <byorgey> luite: I sent you a message via lambdabot, just answering your question re: diagrams
06:30:19 <tias> q: is using maybe with do or (>>=) bad style?
06:31:02 <Zeiris> I do that a fair bit. It seems to be nicer then pattern matching against maybe, but I have the nagging suspicion that there's a better way.
06:31:25 <quicksilver> there is certainly a more specific way, for any particular case
06:31:40 <quicksilver> but I don't think there is any reason to avoid using the monad combinators/notation.
06:32:43 <Gracenotes> I use =<< all the time for chained failed operations
06:34:03 <Gracenotes> flip Map.lookup theMap =<< simpleParse =<< lookup "test" assocList
06:34:30 <copumpkin> <=<
06:34:52 <ian_> copumpkin: what does that mean?
06:34:53 * RayNbow sees a fish swimming towards copumpkin
06:35:52 <Gracenotes> mainly the difference between doing f $ g $ h $ x and f . g . h, with x implicit
06:36:21 <mm_freak> Gracenotes: \x -> f $ g $ h $ x
06:36:22 <Philonous> itegebo: f <=< g = \x -> (f =<< g x)
06:36:25 <Gracenotes> oh and also it's moady
06:37:16 <Gracenotes> mm_freak: or in a more distant abstraction. using <=< restrains you to feeding the initial monadic value right then and there
06:37:43 <mm_freak> Gracenotes: i didn't ask the question =)
06:37:55 <mm_freak> i use >=> a lot in my code
06:38:01 <EvanR-work> :t (<=<) (<=<)
06:38:02 <lambdabot> forall b (m :: * -> *) c a a1. (Monad m) => (a1 -> (a -> m b) -> b -> m c) -> a1 -> (a -> m b) -> a -> m c
06:38:07 <copumpkin> embrace the power of the fish!
06:38:33 <mm_freak> i have the impression that arbitrary combinations of ($) and (.) typecheck
06:38:55 <mm_freak> :t (.) ($) . ((.) . ($))
06:38:56 <lambdabot> forall a b a1. (a1 -> b) -> (a -> a1) -> a -> b
06:39:08 <copumpkin> mm_freak: prove it!
06:39:14 <EvanR-work> (a -> (b -> m c) -> c -> m d) -> a -> (b -> m c) -> b -> m d   o_O
06:39:23 <Gracenotes> arbitrary combinations of fmap and fmap tend to typecheck
06:39:32 <copumpkin> but considering that ($) is just id, and composing with id does nothing
06:39:42 <copumpkin> :t ($) . ($)
06:39:43 <lambdabot> forall a b. (a -> b) -> a -> b
06:39:53 <mm_freak> Gracenotes: good point
06:39:57 <djahandarie> :t ($) . ($) . ($)
06:39:58 <lambdabot> forall a b. (a -> b) -> a -> b
06:40:05 <djahandarie> I see the money now!!
06:40:05 <EvanR-work> how about finding a use for these insane operators ;)
06:40:09 <mm_freak> (.) is just a special case of fmap
06:40:19 <copumpkin> or is actually fmap, in lambdabot
06:40:45 <mm_freak> yeah
06:41:01 <mm_freak> just like flip
06:41:05 <copumpkin> flip flop
06:41:09 <Gracenotes> D:
06:41:11 <mm_freak> it's generalized to the point, where you can't call it flip anymore =)
06:41:12 <Gracenotes> :t flip
06:41:13 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:41:24 <mm_freak> > flip [sin, cos] pi
06:41:24 <copumpkin> :t [flip, sequence]
06:41:25 <lambdabot>   [1.2246467991473532e-16,-1.0]
06:41:25 <lambdabot> forall a b. [[a -> b] -> a -> [b]]
06:41:41 <djahandarie> What
06:41:57 <djahandarie> What the hell just happened there
06:42:06 <djahandarie> Oh
06:42:06 <copumpkin> it behaves like sequence in certain cases :P
06:42:07 <djahandarie> lol
06:43:05 <burp> :t (Prelude.flip)
06:43:06 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
06:43:10 <burp> phew, back to sane world
06:43:12 <Gracenotes> > asin . sin $ pi
06:43:13 <lambdabot>   1.2246467991473532e-16
06:43:29 <djahandarie> > asin . sin $ pi :: CReal
06:43:30 <lambdabot>   0.0
06:43:53 <Gracenotes> my god! I do believe we've discovered a fixed point for pi! stop the presses!
06:44:01 <Gracenotes> *for sine!11!
06:44:01 <djahandarie> > fix pi
06:44:02 <lambdabot>   3.141592653589793
06:44:50 <Gracenotes> I believe that with sufficient funding we can discover a fixpoint for cosine
06:45:24 <djahandarie> > fix cos
06:45:28 <lambdabot>   mueval-core: Time limit exceeded
06:45:39 <EvanR-work> :t fix cos
06:45:40 <djahandarie> We need a more powerful server
06:45:40 <lambdabot> forall a. (Floating a) => a
06:47:14 <mm_freak> > fix (((:) <$>) . (cos <*>) r) 2
06:47:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
06:47:21 <mm_freak> > fix (((:) <$>) . (cos <*>)) 2
06:47:22 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
06:47:22 <lambdabot>    arising from a use ...
06:47:47 <djahandarie> Someone needs to fix that error
06:47:48 <djahandarie> > sin
06:47:49 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
06:47:49 <lambdabot>    arising from a use of `...
06:48:21 <mm_freak> @pl \r -> (:) <$> cos <*> r
06:48:22 <lambdabot> ((:) <$>) . (cos <*>)
06:52:57 <shapr> Goood morning #haskell!
06:53:35 <byorgey> good afternoon shapr!
06:55:45 <shapr> byorgey: Oh, you're one of them yuropeans now, right?
06:56:31 <Botje> yurope ftw!
06:57:29 <flubba> whoever made tryhaskell.org , you are awesome
06:58:38 <djahandarie> The day that got on reddit was hectic
06:58:47 <shapr> Was so much fun though :-)
06:58:54 <flubba> yeah, just saw it on hacker news this morning
06:59:10 <dom96> What would be the best way to split a String into 4 character pieces ?
06:59:38 <Botje> Data.List.Split
06:59:48 <Botje> it has a chunkBy function, iirs
06:59:49 <Botje> *iirc
07:00:28 <dom96> There is a splitAt
07:00:38 <EvanR-work> :t chunk
07:00:39 <lambdabot> Not in scope: `chunk'
07:00:43 <medfly> @hoogle chunkBy
07:00:44 <EvanR-work> @hoogle chunk
07:00:44 <lambdabot> No results found
07:00:44 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
07:00:44 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
07:00:44 <lambdabot> Network.HTTP.Base chunkedTransfer :: BufferOp a -> IO (Result a) -> (Int -> IO (Result a)) -> IO (Result ([Header], a))
07:00:55 <dom96> splitAt is what i need
07:00:56 <Zao> (Split being a hackage package, not core)
07:01:08 <EvanR-work> dom96: well it doesnt produce a list of 4 long lists
07:01:25 <randomwords> What's the current state of gpgpu programming in haskell
07:01:39 <wli> unfoldr (\xs -> if null xs then Nothing else Just $ splitAt 4 xs)
07:01:41 <dom96> EvanR-work: oh, are there any functions that could do that ?
07:01:46 <EvanR-work> dom96: splitEvery
07:02:12 <dom96> EvanR-work: what module is that in?
07:02:21 <EvanR-work> Data.List.Split
07:02:46 <dom96> EvanR-work: thanks
07:02:52 <wli> Probably needs downloading off hackage.
07:02:55 <EvanR-work> watch out for lists not divisible by 4
07:03:29 <dom96> ok
07:03:44 <EvanR-work> theres some messed up stuff in this module ;)
07:03:49 <EvanR-work> whenElt
07:03:58 <dom96> heh, i'll be careful :P
07:04:15 <EvanR-work> you can apparently combine stuff to get any possible split strategy
07:08:16 <Philonous> > unfoldr (\xs -> listToMaybe xs >> return (splitAt 4 xs)) [1..10]
07:08:17 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10]]
07:09:42 <wli> @pl \xs -> (listToMaybe xs >> return (splitAt 4 xs))
07:09:43 <lambdabot> liftM2 (>>) listToMaybe (return . splitAt 4)
07:12:29 <Philonous> > unfoldr (liftM2 (<$) (splitAt 4) listToMaybe) [1..10]
07:12:31 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10]]
07:14:29 <Twey> :t (<$)
07:14:30 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
07:14:55 <Twey> (<$) = fmap . const?
07:15:05 <Twey> :t fmap . const
07:15:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
07:18:53 <dom96> ooh, i'll use one of those
07:28:32 <dmorti> Has anyone had any luck getting readline to work under mac osx 10.5?  I'm running into linking problems others have had, but I haven't seen any solutions... (i.e. issues such as: unknown symbol `_rl_basic_quote_characters'
07:38:27 <yescalona> @karma haskell
07:38:27 <lambdabot> haskell has a karma of 61
07:44:00 <osaunders> What's a combinator that applies a value to a list of functions? Like the inverse of map?
07:44:25 <tromp> values cant be applied
07:44:41 <opqdonut> > map ($3) [(1+), (*2)]
07:44:42 <lambdabot>   [4,6]
07:45:12 <osaunders> opqdonut: Thanks.
07:46:01 <opqdonut> > return 3 >>= sequence [(1+), (*2)]
07:46:02 <lambdabot>   [4,6]
07:46:12 <opqdonut> in the reader monad
07:46:49 <opqdonut> > [(1+), (*2)] <*> return 3
07:46:50 <lambdabot>   [4,6]
07:46:54 <opqdonut> using applicative syntax
07:47:20 <opqdonut> > flip id 3 <$> [(1+), (2*)]
07:47:21 <lambdabot>   [4,6]
07:47:24 <opqdonut> another applicative version
07:47:25 <djahandarie> I find the applicative syntax the nicest for doing something like that usually
07:47:30 <opqdonut> yes
07:48:22 <quicksilver> map ($3) is very instructive though.
07:48:41 <opqdonut> yeah, and it makes sense in some way
07:48:44 <quicksilver> it simultaneously illustrates (in my opinion) the power of sections, the power of higher order functions, and the 'point' of $ existing.
07:48:50 <opqdonut> yeah
07:49:17 <quicksilver> the sequence trick illustrates something else ;)
07:49:23 <bz> Hi there. How do I do non-greedy regexp match? Text.Regex.Posix is greedy.
07:49:23 <quicksilver> but you could have just written:
07:49:35 <quicksilver> > sequence [(1+),(*2)] $ 3
07:49:36 <lambdabot>   [4,6]
07:50:18 <opqdonut> that's true
07:50:22 <quicksilver> (return x >>= f) is just (f x)
07:50:31 <zygoloid> no need for the ($) even ;)
07:50:32 <quicksilver> bz: yes. regexps are greedy.
07:50:37 <opqdonut> maybe a tad more instructive with >>=
07:50:45 <quicksilver> bz: that's one of the defining features of regexps.
07:50:47 <opqdonut> if one is not used to the reader monad
07:51:04 <zygoloid> bz: there might be a PCRE library somewhere
07:51:05 <quicksilver> having said that some regexp engines have a non-greedy group modifier
07:51:07 * hackagebot lattices 1.1 - Fine-grained library for constructing and manipulating lattices  http://hackage.haskell.org/package/lattices-1.1 (MaxBolingbroke)
07:51:09 <quicksilver> (?:...) is it?
07:51:23 <zygoloid> bz: in fact there are several :)
07:51:29 <zygoloid> @hackage regex-pcre
07:51:30 <lambdabot> http://hackage.haskell.org/package/regex-pcre
07:51:46 <zygoloid> @hackage pcre-light
07:51:46 <lambdabot> http://hackage.haskell.org/package/pcre-light
07:51:48 <quicksilver> I'm not sure the regex packages document which bits of syntax they do/don't accept anywhere sensible?
07:51:55 <quicksilver> this is probably a deficiency in the packaging.
07:52:21 <quicksilver> generally if you have to think this hard it's a sign to stop using regexps and using a more pleasant parser abstraction.
07:53:50 <bz> quicksilver: the task is quite easy, I thought regexps would fit just fine, but suddenly I was introduced to their greediness
07:54:26 <quicksilver> there is no link between "task is easy" and "I should use regexp"
07:54:37 <quicksilver> regexps are a poor, clumsy, hard to use parsing abstraction.
07:54:45 <quicksilver> for easy tasks, you should not use regexps.
07:54:51 <quicksilver> (for hard tasks you also should not use regexps!)
07:55:04 <bz> in fact, I need to take all <img> tags from HTML page
07:55:17 <quicksilver> regexps exist as a minilanguage so that people can enter them into, for example, a text editor interactively
07:55:30 <quicksilver> that's their purpose - to be something entered at runtime and interpreted at runtime.
07:55:38 <merijn> quicksilver: Regexp's aren't so much a hard to use parsing abstraction. It's just that people keep trying to use them for grammar which cannot be parsed by regexp's
07:55:48 <quicksilver> bz: HTML tag matching is a classic case of something regexps are poor
07:55:54 <quicksilver> try tagsoup (haskell library)
07:55:59 <merijn> HTML tag matching is impossible with regexp's
07:56:12 <quicksilver> merijn: sure. I find regexps easy, that's because I have been using them for half my life.
07:56:29 <quicksilver> merijn: however, they are a very ugly and unreadable minilanguage.
07:56:30 <merijn> Regular expressions can only parse regular grammars, HTML is a contet-free grammar.
07:56:39 <fasta> merijn, unless regexp means Perl regexp (not that I am recommending it)
07:56:41 <quicksilver> merijn: if you have a the choice, you wouldn't choose them ;)
07:57:01 <bz> merijn: be they non-greedy, they would solve my task anyway :)
07:57:09 <koala_man> regexp are usually not that much worse than the corresponding handwritten matcher
07:57:13 <merijn> fasta: Yeah, but perl regexp's aren't regular expressions, and since this is haskell that makes them doubly unlikely ;)
07:57:17 <bz> quicksilver: thanks for pointing out!
07:57:51 <fasta> merijn, Haskell is getting popular to the point that soon more people will say that we don't understand what regular expressions are.
07:58:38 <merijn> Meh, I yell at people in #C and #python about regexp's too :p
07:59:58 <Phyx-> and do they yell back?
08:00:26 <merijn> If you use big enough words they get to intimidated or confused to try ;)
08:00:49 <bz> as for grammar, it's not the case when I need to parse the whole HTML thoroughly, but simply cut off a couple of lines
08:02:19 <byorgey> shapr: yes, but only for 3 more weeks.
08:04:40 <quicksilver> bz: if you want to correctly handle cases like <a onclick='alert("This is not an <img tag")'>
08:04:52 <quicksilver> bz: then even with non-greedy regexps you have a *very* hard job ahead of you.
08:05:14 <quicksilver> it will be simpler to use a better approach
08:09:46 <bz> quicksilver: ideally -- yes :) but my case is rather a small script which I write "on my knees"
08:13:56 <zygoloid> bz: extractImgTags = filter isImg . parseTags where isImg (TagOpen "img" _) = True; isImg _ = False
08:14:00 <Mathnerd314> should I worry that writing a serious project in Haskell will make Haskell a more popular language, thus stifling innovation in functional programming?
08:14:09 <zygoloid> bz: using the tagsoup package on hackage
08:14:24 <int80_h> what's the syntax for placeholder code in a function. Right now I have Main :: IO (); main = undefined. But I still get complaints that main is undefined.
08:15:01 <bz> zygoloid: thanks
08:15:05 <Botje> int80_h: Main is not main
08:15:24 * zygoloid is a little surprised that the compiler even accepts Main :: IO ()
08:15:29 <roconnor> ??  Right now I have ... main = undefined. But I still get complaints that main is undefined.
08:15:29 <lambdabot>  Right now I have ... main = undefined. But I still get complaints that main is undefined.
08:15:42 <roconnor> what?
08:16:07 <zygoloid> presumably the complaints where that Main is undefined
08:16:11 <zygoloid> *were
08:16:11 <roconnor> ?? I am stupid
08:16:12 <lambdabot>  I am stupid
08:17:21 <int80_h> I meant main :: IO(), not Main.
08:17:46 <fasta> Main::IO() doesn't actually work.
08:18:00 <zygoloid> int80_h: well, main /is/ undefined. but it's also defined.
08:18:02 <zygoloid> :)
08:18:17 <fasta> int80_h, main = undefined should work. 
08:18:27 <int80_h> in RWH I see examples where one can give a definition somefunction :: sometype; somefunction = undefined, and it will compile
08:18:40 <zygoloid> int80_h: yeah, that should work fine. what error are you getting?
08:18:55 <fasta> int80_h, main::IO();main=undefined should work
08:19:10 <arw> shouldn't it just compile, not work?
08:19:10 <int80_h> The function main is not defined in module 'Main'
08:19:39 <fasta> arw, by "work" I mean that it should return something formally equivalent to bottom.
08:19:51 <int80_h> oh crap I see
08:19:52 <Philonous> int80_h: Do you have "module Main where" at the top of the file?
08:20:31 <fasta> int80_h, also: do you use ghci or ghc?
08:20:56 <int80_h> I had created a .lhs file but then forgot to use > on some lines
08:21:01 <int80_h> that was the problem
08:21:39 <jystic> @seen ddanderson
08:21:39 <preflex>  Sorry, I haven't seen ddanderson
08:21:39 <lambdabot> Unknown command, try @list
08:30:43 <osaunders> @pl pc f g x = f x && g x
08:30:43 <lambdabot> pc = liftM2 (&&)
08:31:08 <osaunders> Can you tell @pl not to use monadic functions?
08:31:55 <ski>   pc f g = uncurry (&&) . (f &&& g)
08:32:06 <luite> hehe
08:32:24 <dom96> Is there any way i can evaluate strings like, "5+5" ?
08:32:33 <ski> > "5+5"
08:32:34 <lambdabot>   "5+5"
08:32:52 <djahandarie> dom96, see mueval if you want to do it securely over the internet or something
08:32:57 <luite> dom96: you can eval haskell expressions with hint
08:32:58 <djahandarie> dom96, mueval is a wrapper around hint
08:33:16 <djahandarie> hint won't give you very much protection from malicious input though
08:33:17 <dom96> i just need a simple way to evaluate math
08:33:30 <drksd> hum
08:33:35 <djahandarie> If it is just math you should make a parser for that
08:33:36 <drksd> where is hint located ?
08:34:01 <djahandarie> drksd, in the hint package on hackage
08:34:03 <dom96> djahandarie: what should i use to make the parser ?
08:34:06 <djahandarie> http://hackage.haskell.org/package/hint
08:34:16 <luite> dom96: you don't need to make a parser
08:34:29 <Wooga> hello, can code of this program (guessing number game): http://codepad.org/nFvKkOPv be somehow improved ?
08:34:31 <drksd> djahandarie: ok, it's a package, thx
08:34:39 <drksd> i thought it was a prelude function :°
08:34:41 <luite> dom96: you feed it some string and get back a result, like magic
08:34:49 <drksd> (but well, I couldn't use it so...)
08:34:49 <dom96> luite: you mean hint?
08:34:53 <luite> dom96: yes
08:35:05 <dom96> ok, thanks.
08:35:12 <djahandarie> hint is overkill for evaluating math
08:35:22 <djahandarie> Since hint evaluates any haskell expression
08:35:30 <dom96> creating a parser is hard though lol
08:35:34 <luite> if you need something that doesn't look much like haskell, you should make your own parser
08:35:48 <luite> dom96: it's not that hard
08:36:13 <djahandarie> dom96, http://book.realworldhaskell.org/read/using-parsec.html
08:36:16 <luite> dom96: real world haskell has a chapter about parsec, you might use that to get started
08:36:25 <luite> ...
08:36:36 <dom96> djahandarie: luite, ok. Thanks a lot.
08:36:40 <djahandarie> I'm sure there is something out there for basic math evaluation already though
08:37:39 <djahandarie> Depends on how powerful you want it
08:37:57 <dom96> djahandarie: very simple, i don't even need ( ). Just * / + -
08:38:31 <Twey> RPN!
08:38:33 <alpounet> hey
08:38:35 <alpounet> what's that paper
08:38:42 <alpounet> by a famous game developper
08:38:58 <alpounet> saying that Haskell would have been a nice language for game development
08:39:38 <Ke> would have been?
08:39:50 <djahandarie> dom96, http://learnyouahaskell.com/functionally-solving-problems#reverse-polish-notation-calculator
08:40:13 <dom96> djahandarie: RPN is easy enough to make, I made one. I can't use RPN though.
08:42:19 <djahandarie> RPN is more powerful than an infix notation lacking parenthesis
08:42:49 <chrisdone> djahandarie: ... wow(?)
08:44:15 <djahandarie> ?
08:47:46 <gwern> despair! despair! this world of people not telling alpounet about sweeney has driven me to despair!
08:47:54 * gwern hangs self from nearest lambda. erk.
08:48:29 * Twey laughs.
08:49:28 <zygoloid> Wooga: line 35 and 36 can be replaced by: num <- randomIO
08:49:35 <mreh> alpounet: would have been?
08:49:48 <Wooga> zygoloid: thank you!
08:49:49 <mreh> it is a great language for game dev
08:50:12 <zygoloid> Wooga: i'd put handleError and getValue into a where clause rather than a let inside a do
08:50:19 <chrisdone> Twey: did you see my emacs scripts ^ _^
08:51:13 <McManiaC> hoogle down?
08:51:35 <mreh> aye!
08:51:36 <Wooga> zygoloid: hm, but how do i limit randomIO to 1..10 range?
08:52:15 <zygoloid> @type randomRIO
08:52:16 <lambdabot> forall a. (Random a) => (a, a) -> IO a
08:52:18 <chrisdone> haskell.org is down last I saw
08:52:24 <chrisdone> yep. still down
08:52:49 <drhodes> > randomRIO (0, 10)
08:52:50 <lambdabot>   <IO Integer>
08:53:35 <djahandarie> The only reason haskell.org should ever be down is when it is moving to a less shit box
08:53:41 <Wooga> zygoloid: drhode: thanks!
08:53:59 <gwern> djahandarie: zo dawg I don't see you ponying up for hosting
08:54:01 <Wooga> i mean drhodes
08:54:21 <djahandarie> gwern, I'm a broke university student, cut me some slack :(
08:54:21 <drhodes> Wooga: you taught me something, I didn't know how to do that. thanks for asking the question.
08:54:34 <gwern> mreh: maybe yes, maybe no. game programming is awfully imperative. I suppose we'll learn something from the success or failure of Bloodknight
08:54:46 <gwern> djahandarie: and apparently you can complain like one too!
08:55:02 <gwern> djahandarie: suck it up and take out a few more k of student loans!
08:55:06 <chrisdone> gwern: someone already ponied up for hosting, we're just waiting for the damn thing to be moved
08:55:12 <alpounet> mreh, i meant for *his* games
08:55:20 <alpounet> gwern, oh yeah that's sweeney
08:55:26 <alpounet> what's the matter with him ?
08:55:32 <mreh> gwern: no it isn't
08:55:35 <gwern> alpounet: lupus
08:55:49 <djahandarie> It's functionally reactive!
08:55:52 <alpounet> haha
08:55:53 <mreh> woo
08:55:59 <chrisdone> mreh: is this a 5 minute argument or the full ten minutes?
08:56:00 <gwern> djahandarie: that and a dime will get you a dime
08:56:22 <mreh> chrisdone: I have no idea what you mean
08:56:25 <gwern> one day conal et al will finally catch the unicorn of FRP
08:56:32 <gwern> it'll probably turn out to be a narwhal horn
08:56:52 <chrisdone> narleyhorn
08:57:55 <chrisdone> gwern: so luite went and re-invented mueval and tryhaskel. let's lynch him!
08:58:01 <gwern> who what
08:58:14 <gwern> bring me the head of luite the mailboy!
08:58:48 <chrisdone> I don't have any white sheets. will a Simpsons pillow cover do?
08:59:07 * gwern steeples fingers. what do you think?
08:59:20 <gwern> but srsly who would be silly enough to reinvent mueval?
08:59:46 * Phyx- would be silly enough, just not inclined
08:59:56 <chrisdone> gwern: :-)
09:00:49 <Mathnerd314> should I worry that writing a serious project in Haskell will make Haskell a more popular language, thus stifling innovation in functional programming?
09:01:28 <medfly> what you do or not probably won't have such a great impact
09:01:35 <medfly> so don't worry
09:01:47 <drhodes> I'd really to see tryhaskell showcase the type system, I take this though would be prohibively difficult, but important because without it - the user sees only half the picture of haskell
09:01:52 <chrisdone> speak for yourself, medfly :p
09:02:10 <gwern> Mathnerd314: oh noes, don't do that. make a couple billion dollars instead and develop a malaria vaccine instead
09:02:18 * gwern snickers quietly
09:03:38 <gwern> Mathnerd314: another thing you could do is take up vegetarianism. as the youth of America imitates you, you'll do wonderful things for public health and even fight global warming
09:05:23 <chrisdone> drhodes: feel free to write a lesson and send me a patch ~o_<~
09:05:25 <Ke> someone can start a new language where bytestrings, arrays and lists can share code
09:05:45 <Ke> and where foldl is strict
09:05:50 <chrisdone> Ke: you're not allowed to write any new languages now. research has shown
09:05:58 <dilinger> r
09:06:02 <mreh> this room is hilarious
09:06:13 <dilinger> whoops
09:06:53 <gwern> mreh: my life goal is to murder and replace Oscar Wilde; hence, I hone my cutting wit here on unsuspecting programmers
09:07:03 <jystic> lol
09:07:36 <mreh> a fate worse than death
09:08:12 <jystic> mreh: i thought that was having to program in MUMPS
09:08:34 <jystic> http://en.wikipedia.org/wiki/MUMPS
09:09:24 * gwern is inoculated, thank dog
09:09:45 * jystic thinks the name is hilariously appropriate
09:12:23 <zygoloid> Wooga: you don't need the parens around 'Valid guess' in the case expression. i'd also be tempted to split the IO parts out of getValue, and use getValue <$> getLine
09:13:11 <zygoloid> i think i'd also write catch infix as `catch` instead of prefix
09:16:55 <Wooga> interesting
09:17:12 <roconnor> @src div
09:17:13 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:21:35 <gwern> chrisdone: but seriously, what has luite written that is a dupe with mueval?
09:21:43 <Wooga> zygoloid: sorry, but where i can read more about '<$>' ? google not helping too much
09:21:55 <Zao> Wooga: Google for fmap?
09:21:58 <Twey> Wooga: It's just fmap
09:22:03 <Wooga> ah, thanks
09:22:05 <zygoloid> Wooga: it's in Control.Applicative
09:22:08 <zygoloid> @index (<$>)
09:22:08 <lambdabot> bzzt
09:22:13 <zygoloid> curses!
09:22:23 <zygoloid> @hoogle (<$>)
09:22:23 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
09:22:30 * hackagebot lattices 1.2 - Fine-grained library for constructing and manipulating lattices  http://hackage.haskell.org/package/lattices-1.2 (MaxBolingbroke)
09:22:35 <zygoloid> Wooga: you can use hoogle online at www.haskell.org/hoogle
09:23:27 <roconnor> @type shiftL
09:23:28 <lambdabot> forall a. (Bits a) => a -> Int -> a
09:23:53 <roconnor> bah Int
09:24:34 <uchchwhash> hi guys, I'm facing a peculiar problem, my GHCi responds to the enter key by an M. known bug? can you suggest me a workaround?
09:24:44 <gwern> roconnor: you were expecting Integer?
09:24:52 <roconnor> of course
09:24:54 <Zao> uchchwhash: Maybe it's a Ctrl-M?
09:25:04 <roconnor> what if I want to shift left by 6 billion
09:25:29 <gwern> I thought Bits had to be a machine word? wouldn't that leftshift overflow or something
09:25:30 <uchchwhash> Zao... should it? if I press Ctrl+M it works fine by the way
09:25:39 <gwern> hm, word or double I guess I should say
09:25:47 <Zao> uchchwhash: Your terminal may be odd.
09:26:09 <wli> Not a machine word, there is some "largeword" package somewhere tat has Word256 etc.
09:26:21 <Wooga> ah, thanks
09:26:34 <uchchwhash> Zao... but a simple enter results in an M. I am using a GNOME terminal... is that odd?
09:26:46 <roconnor> > 2^6000000000
09:26:46 <Wooga> oh, wrong terminal for UP+ENTER
09:26:51 <lambdabot>   mueval: ExitFailure 1
09:26:56 <EvanR-work> gnome terminal is pretty odd
09:27:13 <uchchwhash> everything else works fine... only GHCi
09:27:27 <EvanR-work> try it in xterm
09:27:34 <EvanR-work> (comes with X)
09:28:26 <uchchwhash> odd... I just tried xterm and it's the same there
09:28:45 <uchchwhash> could haskeline be the culprit?
09:29:50 <uchchwhash> so no one else faced the problem before I suppose so it has to be my machine specific... oh well
09:30:26 <zygoloid> uchchwhash: i'm guessing your terminal is in keypad mode, and it's sending an \[[M
09:30:38 <zygoloid> probably a haskeline bug
09:30:53 <roconnor> uchchwhash: what is echo $LANG ?
09:31:14 <roconnor> zygoloid: oh, interesting
09:31:20 <uchchwhash> hmm... en_AU.utf8
09:31:27 <Wooga> zygoloid: should i also take fmap into backticks `fmap` ?
09:31:33 <uchchwhash> that's the problem?
09:32:34 <roconnor> uchchwhash: probably not
09:32:35 <CalmNelly> @vixen Do you pay your bills with your mad programming skills?
09:32:36 <lambdabot> uhh, how can i be a program??
09:33:03 <uchchwhash> well if I am in keypad mode (I have no idea what that is) how do I turn it off?
09:33:10 <c_wraith> Wooga, if you want infix fmap, consider <$> from Control.Applicative
09:33:44 <roconnor> uchchwhash: sounds like a bug worth reporting
09:34:22 <uchchwhash> roconnor: but I have to be sure that it's a bug and not due to something stupid from my part! :)
09:34:54 <roconnor> uchchwhash: how could it be something stupid on your part if other programs work?
09:35:24 <uchchwhash> true
09:36:07 <drhodes> uchchwhash: have you tried $ rlwrap ghci  ?
09:36:24 <Wooga> so, here is the final version: http://codepad.org/dnMxturv
09:36:38 <Wooga> hm
09:37:02 <Wooga> probably i don't need do in getNumber
09:38:01 <uchchwhash> drhodes: just installed rlwrap and tried but not working
09:40:36 * Wooga have learn to never say 'final'
09:41:16 <byorgey> refactoring is more forever than a diamond
09:43:38 <uchchwhash> a little bit more help please, can you suggest a diagnosis of what's happening and where do I report a haskeline bug?
09:45:14 <uchchwhash> I am using GHC 6.12.3 with the Platform installed and haskeline is 0.6.2.2
09:45:28 <uchchwhash> on Linux Mint 9
09:46:04 <drhodes> uchchwhash: http://trac.haskell.org/haskeline/wiki
09:46:16 <drhodes> there's bug reporting instrution down at the bottom
09:46:37 <uchchwhash> thanks I see that
10:00:47 * lispy grumbles that hlint's parser needs fixing
10:01:07 <c_wraith> uh.
10:01:18 <c_wraith> Does quickcheck ever create infinite data? >_>
10:01:38 <lispy> c_wraith: I don't think infinite, but trees can branch very quickly if you're not careful
10:02:01 <lispy> and a massively branched tree can seem infinite since they grow exponetially
10:02:10 * Phyx- bends lispy with a spoon
10:02:16 <c_wraith> Hmm, yeah.
10:02:33 <c_wraith> Is there an easy way to weight branches in the "oneof" combinator?
10:02:42 <c_wraith> I guess I could just repeat elements
10:09:23 <uchchwhash> I just tried to use haskeline as a module from ghci and ghci didn't recognize System.Console.Haskeline. so I tried again with ghci -v
10:09:39 <uchchwhash> ghci responded with package haskeline-0.6.2.2-65344a0f6d14bff179544120aa8a78d3 is unusable due to missing or recursive dependencies:
10:09:41 <uchchwhash>   mtl-1.1.0.2-336254fecf8a77054f76cb33671a5177
10:09:53 <uchchwhash> is that natural? 8-)
10:10:22 <dom96> How can i convert a String to a Word64 ?
10:10:36 <c_wraith> Note to self.  don't blindly use the list instance for arbitrary with recursive data structures.
10:11:03 <Lemmih> dom96: As in "10" -> 10?
10:11:15 <djahandarie> Note to c_wraith, don't blindly do things. In general.
10:11:27 <dom96> Lemmih: I don't know, i'm trying to use http://hackage.haskell.org/packages/archive/Crypto/4.2.1/doc/html/Codec-Encryption-Blowfish.html
10:11:30 <c_wraith> I can blindly use the arbitrary instance for (,) !!
10:12:03 <djahandarie> :(
10:13:28 <dom96> or can that module only encrypt Int's ?
10:14:21 <Lemmih> dom96: See Codec.Encryption.Modes, Codec.Encryption.Padding and Codec.Utils.
10:15:54 <dom96> wow, that package is really complicated.
10:16:02 <gwern> encryption is hard
10:16:24 <Lemmih> gwern: And Crypto makes it even harder. (:
10:16:29 <dom96> Isn't there an easy way to encrypt a String ?
10:16:37 <dom96> Some other package or something?
10:16:57 <Lemmih> dom96: I like the SimpleAES package.
10:17:45 <dom96> Lemmih: that looks much simpler, thanks.
10:18:44 <Lemmih> dom96: encryptMsg and decryptMsg will handle the padding and salting for you.
10:19:57 * hackagebot network-info 0.1 - Access the local computer's basic network configuration  http://hackage.haskell.org/package/network-info-0.1 (JacobStanley)
10:20:51 <uchchwhash> I submitted a bug report, thanks everyone
10:20:54 <uchchwhash> kthnxbye
10:21:00 <McManiaC> is there something like a "replace '.' ',' "123.2"" → "123,2" ?
10:21:41 <gwern> McManiaC: I don't think so. it's not hard to write. 'map (\x -> if x=='.' then ',' else x)'
10:22:52 <osfameron> you could write a generic tr/// style function, to make that neater tho
10:23:21 <McManiaC> gwern: true :) thx
10:23:49 <sm> hm! Misformed printfs are not caught at compile-time eh
10:23:57 * sm makes a note
10:24:10 <gwern> sm: oleg cat sez i can halp!
10:24:48 <sm> ?
10:24:57 <djahandarie> Heh heh
10:25:18 <djahandarie> It's a good thing someone had an archive of those pictures
10:25:56 <gwern> sm: I mean compile-time printf is an old favorite of oleg's
10:26:08 <gwern> sm: if it bothers you, he no doubt has multiple solutions written up
10:26:10 <gwern> all in haskell 98
10:27:09 <sm> ah, I must check it out then
10:27:20 <sm> I wonder if hlint would have caught it
10:27:26 <mreh> mfix still hurts my brain
10:28:02 <mreh> o:3  my brane!!!
10:29:47 <gwern> sm: I seriosuly doubt hlint would've caught it
10:30:02 <BMeph> McManiac: "Get a Rope..." ;)
10:30:13 <McManiaC> BMeph: huh?
10:30:17 <sm> as a human, it seems a pretty obvious typo
10:30:28 <sm> (now)
10:30:30 <dom96> how do i create a ByteString from a String?
10:30:37 <gwern> dom96: 'pack'
10:30:40 <gwern> you read the docs?
10:30:42 <JoeyA> import Data.ByteString.Char, I think
10:30:51 <dom96> gwern: that takes a [Word8]
10:30:58 <JoeyA> ignore me, I don't know
10:30:59 <gwern> dom96: or if your String is a literal, you can use an OverloadedString
10:31:11 <gwern> extension
10:31:49 <c_wraith> There are two versions of pack.  Data.ByteString's takes [Word8].  Data.ByteString.Char8's takes a [Char]
10:32:32 <dom96> Is there a way i can do it without extensions ?
10:32:42 <c_wraith> Note that Char8 mangles anything outside of the ASCII character set.  You'll need to use some encodings library or another if you want to handle unicode
10:33:11 <dom96> I can't use Data.ByteString.Char8 i need to use Data.ByteString.Lazy
10:33:31 <c_wraith> Then use Data.ByteString.Char8.Lazy
10:33:40 <c_wraith> or reverse those last two, if I got the order wrong
10:35:14 <c_wraith> But the point remains that the Char8 stuff only works with ascii characters.
10:35:27 <copumpkin> I don't like it
10:35:39 <c_wraith> If you want to handle a wider range of characters, you need something that handles encodings.
10:36:36 <gwern> maybe dom96 is using ascii
10:37:23 <dom96> oh, ok
10:39:18 <BMeph> @hackage Data-Rope
10:39:18 <lambdabot> http://hackage.haskell.org/package/Data-Rope
10:39:54 <roconnor> what is the complexity of converting from one base to another?
10:40:16 <djahandarie> I haven't used Data-Rope before, only edwardk's rope
10:41:38 <c_wraith> roconnor, as I understand it, most of the changes are in exception handling.  So it depends on how much of that the package uses
10:42:01 <roconnor> let me rephrase
10:42:33 <roconnor> what the the bit complexity of converting from one numeric base to another numric base, or simply converting from base-2 to base-n?
10:43:32 <c_wraith> Oh.  haha.  I think the complexity is independent of the base.
10:44:05 <roconnor> I guess I mean, what is the complexity of showAtBase
10:44:15 <roconnor> or something like that
10:44:26 <c_wraith> O(n) where n is the number of bits.
10:44:32 <roconnor> really?
10:45:00 <c_wraith> Hmm.  Maybe not...  But it really feels like it should be.
10:45:06 <roconnor> ya it does
10:45:45 <c_wraith> I mean, it's basically arithmetic encoding.
10:46:07 <roconnor> c_wraith: can we multiply by a constant in linear time?
10:46:36 <roconnor> I guess multiplication by a constant is simply a constant number of additions, and each addition is linear.
10:46:48 <c_wraith> that's true.
10:47:05 <c_wraith> You can do it more efficiently than that, but it demonstrates an upper bound.
10:49:02 <c_wraith> I guess that a naive implementation of showAtBase might end up being O(n^2) in the number of bits.
10:49:04 * hackagebot network-info 0.1.0.1 - Access the local computer's basic network configuration  http://hackage.haskell.org/package/network-info-0.1.0.1 (JacobStanley)
10:49:19 <roconnor> c_wraith: that is my concern
10:49:36 <roconnor> also, what is the complexity of quotRem (or divMod)?
10:50:08 <c_wraith> O(1) on Int. ;)
10:50:38 <c_wraith> The real answer is O(M), where M is the multiplication time for the algorithm used.
10:51:17 <c_wraith> Naive is (n^2) for two n-bit numbers, but you can get it down to O(n^x) for all x > 1
10:51:41 <c_wraith> With obvious issues involving n needing to be huge for that to beat the constant factors involved
10:52:36 <c_wraith> You can also use a different approach to get it to O(n * log n * log log n) using FFT-based transforms.  Those also have significant overhead.
10:53:07 <chrisdone> at least in GHC I think there's a cache for all Int arithmetic
10:53:20 <jmcarthur> ?
10:53:22 <c_wraith> huh?  Int is machine words.
10:53:30 <c_wraith> It just uses the machine ops.
10:53:38 <c_wraith> Integer is the one to be concerned about.
10:55:04 <roconnor> @src transpose
10:55:04 <lambdabot> transpose []             = []
10:55:04 <lambdabot> transpose ([]   : xss)   = transpose xss
10:55:04 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
10:57:35 <roconnor> @hoogle replicate
10:57:35 <lambdabot> Prelude replicate :: Int -> a -> [a]
10:57:35 <lambdabot> Data.ByteString replicate :: Int -> Word8 -> ByteString
10:57:35 <lambdabot> Data.List replicate :: Int -> a -> [a]
10:57:46 <roconnor> @hoogle+
10:57:46 <lambdabot> Data.ByteString.Char8 replicate :: Int -> Char -> ByteString
10:57:46 <lambdabot> Data.ByteString.Lazy replicate :: Int64 -> Word8 -> ByteString
10:57:46 <lambdabot> Data.ByteString.Lazy.Char8 replicate :: Int64 -> Char -> ByteString
10:58:21 <sm> well that's weird.. I've examined every printf in my code, and they all seem to have the right number of arguments
10:58:40 <roconnor> c_wraith: do you think dividing by a constant can be done in linear time?
10:59:21 <c_wraith> yes
10:59:34 <c_wraith> But that's not enough, by itself, to make showAtBase linear.
10:59:39 <c_wraith> Since it does O(n) divides
11:00:13 <djahandarie> Speed, who needs it
11:00:16 <roconnor> c_wraith: ?
11:00:21 <chrisdone> well, I can't find the reference. I read something by Simon Marlow about Ints being cached. my google fu is weak
11:01:47 <c_wraith> roconnor: the naive implementation of showAtBase uses O(n) divides...  One for each symbol in the output.
11:02:23 <mjrosenb> @unpl (\x-> (x, f x))
11:02:23 <lambdabot> (\ x -> (x, f x))
11:02:30 <mjrosenb> @pl (\x-> (x, f x))
11:02:31 <lambdabot> ap (,) f
11:02:54 <mjrosenb> :t ap
11:02:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:05:38 <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph f = arr id &&& f
11:05:39 <lambdabot>  Defined.
11:05:58 <ski> @let cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph f = f ||| arr id
11:05:59 <lambdabot>  Defined.
11:06:29 <aristid> :t \f -> arr id &&& f
11:06:30 <lambdabot> forall b (a :: * -> * -> *) c'. (Arrow a) => a b c' -> a b (b, c')
11:06:37 <ski> > ((^2) `graph`) `map` [2,3,5,7]
11:06:38 <lambdabot>   [(2,4),(3,9),(5,25),(7,49)]
11:06:49 <aristid> :t graph
11:06:50 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
11:07:21 <jystic> @pl extract ns  = map show $ filter (/= nullIPv4) $ map ipv4 ns
11:07:21 <lambdabot> extract = map show . filter (nullIPv4 /=) . map ipv4
11:07:24 <ski> @type ap (,)
11:07:25 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
11:08:16 <ski> @type (`either` id)
11:08:17 <lambdabot> forall a b. (a -> b) -> Either a b -> b
11:10:10 <ski> @type ap (arr (,))
11:10:11 <lambdabot> forall b a (a1 :: * -> * -> *). (Arrow a1, Monad (a1 b)) => a1 b a -> a1 b (b, a)
11:10:16 <ezyang> Hey, does any one know an example of a Haskell library that does a really /bad/ job of exposing a purely functional interface? 
11:10:38 <c_wraith> GD?
11:11:02 <c_wraith> well, it doesn't even try
11:11:08 <c_wraith> that's not quite the same thing
11:11:14 <thoughtpolice> like, where the library is impure and it leaks that fact? or just one where it just makes no sense to have a purely functional interface
11:11:23 <ezyang> Hmm. 
11:11:33 <ezyang> I guess not trying is ok for my purposes. 
11:12:41 <ezyang> but what would be even better is if someone just imported in the C functions, and then didn't do /anything/ else. 
11:12:46 <sm> soo.. if my argument counts all look good, I guess my printf error comes from a library :(
11:13:32 * sm needs a reproducible test case, but of course it's rarer than hen's teeth
11:13:43 <djahandarie> ezyang, groom is a pretty awful one
11:14:00 <ezyang> haha 
11:14:13 <tafryn> Why does ghc complain when I remove the "x"s from this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28800#a28800 ?
11:14:33 <ezyang> tafryn: $ is application. You should replace it with a . 
11:15:25 <ezyang> (difference between 'f $ g x' and 'f . g $ x' and 'f . g') 
11:19:32 <tafryn> ezyang: I see. Thanks.
11:24:00 <mjrosenb> am I not allowed to have partially applied type synonyms?
11:24:10 <jmcarthur> nope
11:24:16 <mjrosenb> : (
11:24:45 <jmcarthur> but if you have a type synonym like type Foo a = Maybe a, you can write it as type Foo = Maybe. then you can partially apply Foo
11:24:45 <mjrosenb> the kind checker doesn't mind 
11:25:33 <jmcarthur> or rather, you can have Foo not applied to anything
11:25:56 <merijn> How would I go about implementing a graph data structure? It seems to me that'd be hard because nodes would have to be created before they can be used in the creation of other nodes
11:26:01 <ski> mjrosenb : otoh, if you define them like `type Foo = StateT s []', then you may use `Foo' without applying it
11:26:14 <jmcarthur> merijn: knot tying is hard sometimes, yes
11:26:26 <jmcarthur> merijn: most people use IntMaps to simulate pointers
11:26:29 <mjrosenb> right, but if i have Bar :: (*->*)->*; and type Id a = a; can I have a value with type Bar Id?
11:26:53 <jmcarthur> nope
11:26:56 <ski> merijn : if you really want circular data, then you can tie a knot
11:27:08 <merijn> I figured I could implement a graph as a matrix as well, in which case: What's the usual way of doing matrices? Tuples containing tuples?
11:27:38 <ski> mjrosenb : you have to use something like `newtype Identity a = MkI a', there
11:28:04 <mjrosenb> merijn: I have more frequently seen lists containing lists
11:28:36 <Igloo> Well, if the fix isn't known in this case, I don't think any fix can be known unless there's already a patch implementing it
11:28:53 <Igloo> Ooops, mispaste
11:29:11 <jmcarthur> merijn: array or arrays is reasonable. or if the array type supports custom indexes you could just use a tuple-indexed array
11:29:22 <mjrosenb> ski: i was hoping to avoid the constructor, which i suspect, is exactly the reason this isn't working
11:29:48 <jmcarthur> mjrosenb: newtype constructors are free at runtime. they are just extra typing.
11:30:09 <mjrosenb> jmcarthur: i know.  I have a bunch of code already written
11:30:13 <jmcarthur> ah
11:30:20 <mjrosenb> jmcarthur: and i was hoping i could continue to use it
11:30:47 <merijn> jmcarthur: Oh, interesting I though there were only tuples and lists. I'll look into arrays
11:31:07 <mjrosenb> the idea was i have data Foo = F [Foo] [Bar]
11:31:25 <ski> mjrosenb : with restricted type synonyms (basically like in SML, abstract `type t' implemented as `type t = ...'), you could possibly do it .. alas, only Hugs implements that
11:31:27 <jmcarthur> mjrosenb: if you define some of the functions you are already using in a type class then you can create versions of them that use your newtype instead. then dependent functions just get more general types and automatically use the newtype when you give it to it
11:31:28 <mjrosenb> and i'd like to change this to data Foo a  = F [a (Foo a)] [a Bar]
11:31:39 <mjrosenb> and use a = Id to continue using all of my code
11:31:59 <uchchwhash> merjin: consider not implementing your graph as an array, as that is somewhat like the imperative solution forced upon a functional language
11:32:18 <ski> merijn : maps could probably also be used
11:32:26 <jmcarthur> uchchwhash: it's not bad if it's just read only or at least has fast, pure update
11:33:43 <merijn> uchchwhash: How so? I think matrices in general are a very elegant way of doing graphs. You can implement shortest-path using just matrix multiplications that way
11:34:15 <jmcarthur> merijn: i think uchchwhash's complaint is around mutation (insertion, deletion, etc.)
11:34:34 <jmcarthur> i say just use whatever is most appropriate for the task at hand
11:34:35 <uchchwhash> jmcathur: yes, in general
11:34:53 <monochrom> just use whatever is least work for you
11:34:56 <ski> (7.2 The Hugs 98 User's Guide - Hugs-specific language extensions - Restricted type synonyms <http://cvs.haskell.org/Hugs/pages/users_guide/restricted-synonyms.html>)
11:35:15 <jmcarthur> merijn: you could check out fgl
11:35:29 <jmcarthur> merijn: they use the IntMap approach i mentioned earlier
11:35:49 <merijn> I'll check it out
11:36:16 <monochrom> IntMap is faster to mutate than wholesome arrays
11:36:29 <jmcarthur> fgl is not the cleanest interface, IMO
11:36:29 <uchchwhash> merijn: fgl is definitely better than tuples in tuples :)
11:36:32 <jmcarthur> but it works
11:36:43 <jmcarthur> yeah, far better than a bunch of tuples
11:37:02 <jmcarthur> monochrom: except in small cases
11:37:34 * ski computes transitive closure of a graph with zero nodes
11:38:52 <Samy> whats wrong with Vector for this
11:39:11 <jmcarthur> Samy: i was bunching Vector into "array"
11:39:49 <lispy1> ski: yes :)
11:40:17 <lispy1> ski: I have a hard time figuring out how the (a -> p) -> r version is actually more expressive (I'm having a hard time finding differentiating examples)
11:40:27 <ski> lispy1 : ok, so what did you think of the composable continuations indexed monad ?
11:40:34 <ski> oh
11:41:00 <lispy1> I like it, it's a good paper.  I might opt for the delcont library though for pratical work
11:41:33 <lispy1> But not knowing which one is more general makes me want to a) find a differentiating example b) see if the delcont library can do that example
11:42:17 <ski> well, e.g. you can do
11:42:22 <ski>   collect :: Monad m => [a] -> ContT2 o [o] m a
11:42:23 <ski>   collect as = MkContT2 (\k -> mapM k as)
11:42:37 <ski> assuming
11:42:59 <ski>   newtype ContT2 o p m a = MkContT2 ((a -> m o) -> m p)
11:44:19 <ski> so, given
11:44:38 <ski>   fooToBar :: Foo -> Bar
11:44:50 <ski> er
11:44:53 <ski>   fooToBar :: Foo -> IO Bar
11:45:26 <ski>   foossToBarss :: [[Foo]] -> IO [[Bar]]
11:45:51 <ski>   foossToBarss fooss = evalContT2 $
11:46:21 <ski>     collect fooss `bindContT2` \foos ->
11:46:32 <ski>     collect foos  `bindContT2` \foo  ->
11:46:48 <ski>     liftContT2 (fooToBar foo)
11:47:04 <ski> which, if we had `do'-notation for indexed monads, could look like
11:47:09 <ski>   foossToBarss fooss = evalContT2 $ do
11:47:21 <ski>     foos <- collect fooss
11:47:25 <ski>     foo <- collect foos
11:47:27 <ski>     liftContT2 (fooToBar foo)
11:48:15 <ski> so the first `collect' represents the outer loop, while the second `collect' represents the inner loop
11:49:21 <ski> now you can actually factor out those two loops into a separate definition, without touching the "body" (everything that dynamically executes after the loop calls)
11:49:26 <ski>   foossToBarss fooss = evalContT2 $ do
11:49:31 <ski>     foo <- collect2 fooss
11:49:36 <ski>     liftContT2 (fooToBar foo)
11:50:39 <ski>   collect2 :: Monad m => [[a]] -> ContT2 o [[o]] m a
11:50:50 <ski>   collect2 ass = do
11:50:58 <ski>     as <- collect ass
11:51:05 <ski>     a  <- collect as
11:51:08 <ski>     return a
11:52:06 <Veinor> collect2 ass? really?
11:52:15 <EvanR-work> ill collect *your* ass
11:52:49 <ski> (probably the above example on it's own looks a little too minimal to be that interesting. but i find it interesting that one can treat the "loop wrappings" as first-class actions in of themselves, that can be passed around, and factored out)
11:53:30 <Veinor> EvanR-work: take it to #haskell-sex
11:53:33 <Veinor> (please don't)
11:54:19 <ski> note that if we only wanted to *loop* through the list(s), without constructing a correspondently shaped output list, then we could make do with the normal composable continuations monad (not indexed) `ContT o m'
11:54:26 <djahandarie> Let's create as many #haskell- sub communities as we can
11:55:53 <sm> what's a fix for "GHCi runtime linker: fatal error: I found a duplicate definition for symbol get_current_timezone_seconds" for time-1.1.4 when loading a program in ghci ?
11:56:15 <ski> lispy1 : another use of `Cont2 o [o]' (or `ContT2 o [o] m') is to write nondeterministic computations, that produces a list/stream of values (and probably `ContT2 o [o] m' is most interesting here, in that the production of the results are interleaved with `m'-effects)
11:56:23 <sm> I tried hiding time-1.1.4
11:57:44 <sm> hiding time-1.2.0.3 worked better
12:00:48 <djahandarie> http://blog.johantibell.com/2010/08/results-from-state-of-haskell-2010.html
12:01:31 <Veinor> vi vs emacs is a tie, essentially
12:01:50 <EvanR-work> nooo impossible!
12:02:00 <ski> lispy1 : also, iirc, given any `forFoo :: forall m. (Monad m,MonadBlah m Blah) => ((Bar -> m ()) -> (Foo -> m ()))' that iterates through each `Bar' element of a given `Foo' you can construct a `fooToBars :: forall m. (Monad m,MonadBlah m Blah) => Foo -> ListT m Bar' using composable continuations
12:02:30 <djahandarie> I use emacs here only because I tried vi for ages and always ended up accidently deleting large amounts of my file by accident
12:02:45 * ski hasn't actually tried that in Haskell, so that might not be exact
12:03:40 <ski> (lispy1 : that last would basically be <http://community.schemewiki.org/?composable-continuations-tutorial>, i.e.)
12:03:56 <monochrom> sm: ideally don't let several versions of time coexist
12:07:03 <EvanR-work> i wonder why i didnt take this survey
12:07:06 <EvanR-work> or wasnt asked to
12:07:41 <nifr> Are there any tools for identifying unused imports? I realize imported instances could have an effect, but I just want to identify unused imports.
12:08:15 <quicksilver> -fwarn-unused-imports
12:08:18 <quicksilver> (GHC flag)
12:08:31 <nifr> great
12:08:32 <nifr> thanks
12:08:45 <quicksilver> ISTR it can get confused in some case - perhaps with qualified imports?
12:12:46 <EvanR-work> if haskell disappeared tomorrow what language might you use as a replacement, wins, ocaml?? really?
12:13:33 <quicksilver> sure. ocaml is like haskell with typeclasses removed and annoying bits added.
12:13:44 <quicksilver> (oh, and purity removed and functors added)
12:13:47 <EvanR-work> thats what im thinking
12:14:16 <EvanR-work> oooh, "what is wrong with haskell", *grabs the raw data*
12:14:48 <monochrom> I might go back to sml.
12:15:41 <quicksilver> monochrom: there aren't huge differences between sml and ocaml though. Assuming you ignore the 'o' part of ocaml.
12:15:46 <quicksilver> (and everyone does, right? please?)
12:16:03 <quicksilver> polymorphic variants are quite cute but I never used them in a real program.
12:17:20 * wli mightily misses SML's module system.
12:17:55 <roconnor> quicksilver: we are using them in MathScheme
12:20:54 <quicksilver> wli: yes, that's a good part, but that's not a difference between ocaml and sml is it?
12:21:05 * quicksilver thought they both had an "ML-style module system"
12:21:35 <wli> yeah, I don't get too worked up about differences between ocaml and sml.
12:21:47 <quicksilver> roconnor: how is it working out? 
12:21:55 * quicksilver tries to remember what he didn't like about them
12:22:05 <quicksilver> the whole <: :> co-contra thing made me nervous.
12:22:27 <roconnor> quicksilver: I don't really see the big advantage myself in our use case.
12:22:41 <roconnor> quicksilver: it does reduce the number of tags/constructors
12:23:00 <quicksilver> Things everyone seems to agree would be good for haskell, but somehow never go mainstream, even though papers get written:
12:23:06 <quicksilver> #1 an ML-like module system
12:23:12 <quicksilver> #2 mobile code
12:23:31 <wli> What's mobile code?
12:23:37 <quicksilver> serialisable closures
12:23:46 <roconnor> Coq has a ML-like module system. ... It is terrible.
12:23:51 <quicksilver> so you can send arbitrary haskell values to remote locations 
12:24:02 <quicksilver> (serialisable thunks might be a better way to say it)
12:24:29 <ski> Alice ML has mobile code
12:24:42 * geheimdienst reckons mobile code is the code on his phone, possibly his laptop
12:24:46 <roconnor> quicksilver: is serialisable closures consistent with Haskell's semantics.  I thought Nat -> Nat was uncountable.
12:25:16 <quicksilver> not entirely, no.
12:25:26 <quicksilver> it gives you a way to observe the difference between referentially equivalent values
12:25:29 <roconnor> what happens when se serialize the diagonal of the serializer?
12:25:35 <quicksilver> but then, you could choose not to expose that part.
12:25:39 <roconnor> quicksilver: ah
12:25:44 <wli> Computable functions Nat -> Nat are countable, no?
12:26:23 <monochrom> @remember roconnor what happens when we serialize the diagonal of the serializer?
12:26:23 <lambdabot> Done.
12:26:23 <ski> not necessarily
12:26:40 <quicksilver> naively you just sent the info tables (function pointers) and serialise the free variables (closures)
12:26:46 <quicksilver> it's obviously feasible.
12:26:51 <quicksilver> and, indeed, it's been done. Several times.
12:26:52 <ski> *algorithmic* functions of type `Nat -> Nat' surely are countable, though
12:27:12 * sm found his printf bug.. was using hPrintf to send a random string to stdout
12:27:45 <quicksilver> or if you don't want to assume equivalent info tables at both side of the link (which requires same package versions etc) you could actually send real code (bytecode, say).
12:27:52 <quicksilver> That feels less scalable and less secure though.
12:27:59 <ski> Russian constructivism / Markov's school equates computable with algorithmic, as an axiom
12:28:18 <roconnor> ski: I guess it works for them.
12:28:35 <roconnor> though I don't really understand what their models look like
12:29:40 <roconnor> monochrom: seriously, what happens?
12:30:21 <EvanR-work> either the universe explodes or free chapulas at taco bell
12:30:55 <roconnor> ski: wait a minute, I can prove in Bishop mathematics that Nat -> Nat are not isomorphic
12:31:02 <ski> re mobile code in Alice ML see Packages,Pickling,Distribution at <http://www.ps.uni-saarland.de/alice/manual/tour.html>
12:31:15 <roconnor> ski: or is the trick that the russians only show an injection from Nat -> Nat to Nat ?
12:32:59 <ski> roconnor : sorry, i was imprecise. they don't have countability in the sense of isomorphic to `Nat', they only have an injection, yes
12:33:14 <roconnor> interesting
12:33:39 <roconnor> so if serialization isn't surjective, we are all good?
12:33:53 <ski> each function comes with (or is, if you prefer) an algorithmic description of it
12:34:31 <roconnor> oh, they probably don't have extenstional equality
12:34:41 <roconnor> which is what quicksilver was saying
12:34:42 <ski> (with a suitable equivalence relation over the representants)
12:35:06 <roconnor> so any model that identifies extenstionally equal functions (such as domain theory) will fail.
12:43:23 <dbelange> hey jerks
12:43:36 <dbelange> What do you call an algebraic object with just a unary operation?
12:44:04 <ski> maybe "dynamical system" ?
12:44:24 <dbelange> :/
12:44:28 <wli> magma
12:44:34 <arw> obscure stargate reference: unas?
12:44:54 <ski> (iirc "Conceptual Mathematics" by Lawvere and Schanuel called it that, anyway)
12:45:03 <wli> Woops, a *unary* operation.
12:45:58 <ski> (.. the subobject classifier in that category of "dynamical systems" was interesting)
12:47:20 <dbelange> I'll just call it a "successor algebra" or something and leave a %TODO!!!!!!
12:47:47 <roconnor> dbelange: intrestingly we don't have a name for that in MathScheme
12:48:27 <roconnor> well, we call it "UnaryOperation" which is kinda a crappy name.
12:48:36 <arw> dbelange: i've also only seen it called unary algebra. http://www.csci.csusb.edu/dick/maths/math_15_Unary_Algebra.html
12:49:13 <dbelange> The other place I was looking, a "unary algebra" had any number of unary operations on it
12:49:29 <dbelange> so I'm willing to believe that this sort of structure is trivial enough that nobody really cares.
12:49:36 <djahandarie> A unary unary algebra
12:49:43 <dbelange> :)
12:50:26 <monochrom> it's almost as informationless as "everyone has a mom".
12:51:38 <roconnor> where is Integral Integer defined in GHC?
12:52:03 <monochrom> perhaps it is a graph
12:52:29 <monochrom> err nevermind, graph allows non-1 out-degree
12:53:21 <monochrom> probably somewhere in the "integer" package
12:53:48 <monochrom> "integer-gmp"
12:53:56 <roconnor> thanks
12:54:50 <monochrom> GHC.Integer.GMP.Internals has a high chance
12:56:56 <pokoko222> hello mortals
12:57:48 <medfly> lol
12:58:42 <geheimdienst> it's quite postmodern to lol at your mortality
12:59:07 <monochrom> it's also postmodern to redefine mortality
12:59:18 <monochrom> "no one owns the word" etc
12:59:30 <monochrom> and oh, redefine lol too
12:59:42 <monochrom> "no one owns the reasons to laugh"
13:00:10 <pokoko222> only I, since I just declared myself a God
13:00:34 <monochrom> you don't own God either
13:00:58 <roconnor> c_wraith: I don't see why it is clear that division by a constant is O(n)
13:01:21 <medfly> what is n in that sense
13:01:24 <c_wraith> roconnor: I'm not convinced it is, either.  I think it probably should be, but that's not the same.
13:01:28 <pokoko222> isn't division like any other primitive operation O(1) ?
13:01:31 <c_wraith> medfly: number of bits
13:01:40 <medfly> no
13:01:41 <roconnor> pokoko222: not for Integer
13:01:53 <geheimdienst> medfly, nobody owns n. you can make something up
13:01:57 <medfly> hehehe
13:02:08 <medfly> I have to learn more about that kind of stuff
13:02:09 <geheimdienst> nobody owns words, but i pwn them
13:03:14 <medfly> primitive operation being O(1) sounds more like a goal than a rule
13:03:19 <monadic_kid> pokoko222: arbitrary-precision integers, not fixed sized integral types
13:03:20 <medfly> no?
13:04:00 <pokoko222> well then, I as a God declare division to be O(1) from now on
13:04:38 <monochrom> "concurrency is too complex to be slain with one bullet"  of course, you slay with a sword not a bullet. :)
13:04:46 <geheimdienst> that's cute. could you build us a few processors that do that?
13:05:07 <medfly> np here u go
13:07:05 <monochrom> you don't need God to get O(1), you just need a finite universe.
13:07:50 <monochrom> and concurrency can be slain with O(1) swords
13:08:04 <medfly> O(1) swords?
13:08:13 <geheimdienst> how big are the constants?
13:08:14 <medfly> carpet bombs? :p
13:09:31 * ski . o O ( particle : string :: bullet : sword  ? )
13:09:37 <pokoko222> guys remember how they bullshit from the bible: "And then HE came and bla bla bla, water turned into wine, and pigs turned into gold and bla bla yada yada". Imagine the computer science God version of that: "And then HE came and division became O(1), and haskell finally killed scala and..." lol
13:09:57 <pokoko222> hell u can give it a name, the computer science bible
13:09:59 <Two72> Anyone seen this error: "cabal: : does not exist"?
13:10:25 <monochrom> I understand that math drives some people mad and unstable
13:10:26 <pokoko222> Two72 cant u see we are in the middle of religions conversations? :D
13:11:54 <pokoko222> shit happens indeed :D
13:11:55 * hackagebot hfractal 0.4.1 - OpenGL fractal renderer  http://hackage.haskell.org/package/hfractal-0.4.1 (ChrisHoldsworth)
13:13:09 <geheimdienst> i guess the computer science bible would likely not have "The Holy Bible" on the cover but "The Holy Structure and Interpretation of Everything"
13:13:29 <ski> (pokoko222 : discussing programming paradigms could be more like religious conversation)
13:13:51 <pokoko222> ski heh i realized that some time ago
13:15:24 <Two72> The "cabal: : does not exist" error goes away if I delete the config file, and comes back the next time cabal is run... kinda frustrating
13:15:39 <mauke> any empty settings in your config?
13:15:50 <mauke> can strace help you?
13:16:13 <Two72> config is default... I delete it, cabal regenerates a broken one
13:16:27 <monochrom> presumably the config file is not the problem
13:16:52 <Two72> well, yeah
13:16:53 <monochrom> what is your config file?
13:17:08 <mauke> does cabal use environment variables?
13:17:12 <monochrom> I mean could you paste it? maybe it is broken as generated, and different from mine
13:17:48 <monochrom> cabal uses PATH for one...
13:19:24 <Two72> this happened just after I upgraded to cabal-install 0.8.2
13:20:25 <Two72> config file: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28803
13:21:36 <monochrom> alright, it's the same as mine
13:22:33 <monochrom> but now there is also the windows angle. I've never tried cabal on windows.
13:23:06 <Two72> I'm on a Mac
13:23:20 <monochrom> oh oops. I've never done that either.
13:23:57 <Two72> it's mostly the same as Linux/BSD... everything goes in /usr/local
13:25:32 <geheimdienst> have you tried running with max verbosity?
13:25:56 <CalmNelly> > 2 + 2
13:25:57 <lambdabot>   4
13:26:14 <Two72> Reading installed packages...
13:26:16 <Two72> cabal: : does not exist
13:26:39 <Two72> er, the middle got cut off: /usr/local/bin/ghc-pkg dump --global
13:29:02 * hackagebot explicit-iomodes-text 0.1 - Extends explicit-iomodes with Text operations  http://hackage.haskell.org/package/explicit-iomodes-text-0.1 (BasVanDijk)
13:29:04 * hackagebot safer-file-handles-text 0.1 - Extends safer-file-handles with Text operations  http://hackage.haskell.org/package/safer-file-handles-text-0.1 (BasVanDijk)
13:30:24 <applicative> Two72, is the config file giving you some bad result?  
13:30:59 <Two72> Well, if I delete the config problem, cabal runs fine once.  But it regenerates the config file.
13:31:14 <Two72> *delete the config file
13:33:04 <applicative> is the new cabal the one that's first in path?  
13:33:41 <Two72> yes, "cabal --version" reports 0.8.2 / 1.8.0.6 lib
13:34:50 <randomwords> Does anyone have any links to resources about gpgpu programming in haskell. I found accelerate - are there any others?
13:35:01 <applicative> Two72, I think I missed the beginning of this, what is that main thing it's doing wrong?
13:37:14 <chrisdone> I just discovered -XLiberalTypeSynonyms
13:37:16 <chrisdone> \o/
13:39:16 <chrisdone> partially applied type synonyms \(¬_¬)/
13:44:11 <applicative> randomwords, there has been much discussion of this; it seems there's not an expert around at the moment....
13:44:16 <wagle> how do i fix this: 
13:44:19 <wagle> package random-1.0.0.2 requires time-1.1.4
13:44:19 <wagle> package random-1.0.0.2 requires time-1.2.0.3
13:44:28 <wagle> (cabal)
13:44:44 <randomwords> applicative: Fair enough, am I right int thinking accelerate is currently the only high level library?
13:45:01 <verma> hello all, I am trying to write a simple function, which will accept two lists joinPairs [1, 2, 3] [4, 5, 6] and return "1: 4, 2: 5, 3: 6" .. here's my attempt http://paste.plurk.com/show/292427/ .. but for some reason I can't get it to load into ghci .. tokenize is a partial function implementation
13:45:02 <randomwords> It seems odd that haskell isn't all over gpgpu
13:46:11 <applicative> randomwords, I think it is
13:46:17 <verma> actually joinPairs takes three parameters a separator string, first list and then the second list.
13:47:11 <monadic_kid> randomwords: there are some efforts like obsidian, and other high-level frameworks i can't remember the name of, there are of-course bindings to cuda, opencl but those are just bindings and not high-level
13:47:22 <chrisdone> wagle: what command is that the result of?
13:47:40 <napping> I think I am just about to use data types ala-cart to combine universes of type tags for a modular interpreter
13:48:00 <randomwords> monadic_kid: I see. And I'm right in thinking that without an opencl high level library, we don't really have support for gpgpu on ATI cards?
13:48:51 <jmcarthur> there was something else i think, but i don't remember what it's called
13:49:19 <quicksilver> verma: basically your problem is that tokenize takes two arguments.
13:49:34 <monochrom> wagle: tear down random-1.0.0.2 and time-1.2.0.3. install random-1.0.0.2 again.
13:49:52 <verma> quicksilver: oh
13:49:56 <quicksilver> verma: if you change it to "joinPairs sep a b = foldr func [] $ tokenize a b where ...."
13:49:59 <monochrom> "tear down" means "ghc-pkg unregister"
13:49:59 <quicksilver> verma: then it compiles
13:50:06 <monadic_kid> randomwords: there are straight up bindings to opencl on hackage, some ati cards support opencl through ATI Stream  SDK
13:50:28 <quicksilver> verma: (.) composes functions with one argument
13:50:35 <quicksilver> verma: doesn't work in the same way for two.
13:50:41 <jmcarthur> there's nikola, but as far as i know only a paper has been released
13:50:49 <wagle> tried cabal install random --reinstall
13:50:56 <wagle> didnt work..  trying harder
13:51:00 <verma> quicksilver: oh ok ok .. got it
13:51:03 <quicksilver> wagle: I think time is a base package?
13:51:10 * hackagebot CheatSheet 2.6 - A Haskell cheat sheet in PDF and literate formats.  http://hackage.haskell.org/package/CheatSheet-2.6 (JustinBailey)
13:51:11 <monochrom> you must get rid of random-1.2.0.3 first.
13:51:12 <quicksilver> you really really really don't want to have reinstalled a base package.
13:51:22 <monochrom> time is not a base package
13:51:25 <quicksilver> oh
13:51:27 <verma> quicksilver: nice .. thanks .. I will give it a try
13:51:31 <quicksilver> I retract my comment.
13:51:32 <randomwords> monadic_kid: Yeah i've been looking at that. Not much in the way of docs or examples though
13:51:44 <quicksilver> sorry :)
13:52:12 <chrisdone> wagle: I had this same problem today. I just unregistered the older time library and reinstalled random
13:52:13 <wagle> quicksilver: dunno..  will start over if i cant get it to work incrementally
13:52:29 <wagle> chrisdone: ah, cool
13:52:36 <napping> Is there a library with pairs and sums and things on type constructors?
13:52:49 <chrisdone> ghc-pkg unregister time-1.x --force
13:52:49 <chrisdone> then reinstall any libraries listed that have "broken" as a result
13:52:51 <napping> like (f + g) x = f x | g x
13:53:25 <quicksilver> napping: like data Either2 f g x = Either (f x) (g x) ?
13:53:27 <monochrom> I would unregister the new one rather than the old one.
13:53:48 <napping> yes, like that
13:54:04 <quicksilver> napping: there must be but I don't know where. category-extras somewhere?
13:54:07 <wagle> chrisdone: how do you UNregister?
13:54:16 <quicksilver> napping: we need an edwardk!
13:54:25 <monochrom> The very presence of the new one is a symptom of a bigger problem anyway.
13:54:38 <chrisdone> wagle: ghc-pkg unregister, no?
13:54:44 <ski> @summon-edwardk
13:54:45 <lambdabot> Unknown command, try @list
13:54:49 <djahandarie> Heh
13:55:12 * chrisdone dies from overexposure to the word "tibbe"
13:55:36 <wagle> chrisdone: you --force'd it?
13:55:41 <chrisdone> wagle: yep
13:56:02 <chrisdone> wagle: --force it, and then cabal install --reinstall module1 module2 module3  all the broken packages
13:56:09 <chrisdone> it takes like a second to rebuild them
13:56:20 <chrisdone> or did on my machine ^ __^
13:56:48 <monochrom> You have a liver tumour and you go to a doctor. The doctor suggests: "let me cut away the old liver in favour of the new tumour, and cut away organs dependent on the liver so they regrow to depend on the new tumour!"
13:57:07 <quicksilver> napping: on reflection, Either1 would be a more haskell consistent name. Like Typeable1.
13:57:12 <Veinor> monochrom: haha
13:57:13 <quicksilver> But still, I'm sure it must live somewhere already.
13:57:33 <chrisdone> monochrom: and then the new tumour evolves into a pikachu
13:58:35 <Silvah> lol
13:59:27 <wagle> ok, i made a mess..  i rebuild from scratch by deleting .cabal and .ghc?
14:00:05 <chrisdone> wagle: what is the mess?
14:00:28 <wagle> it can't find the dph packages 
14:00:45 <applicative> wagle they are hidden by default, right?
14:01:01 <wagle> i figure i need to go run errands, so rebuilding from scratch seems easiest/fastest
14:01:15 <wagle> applicative: dunno
14:01:28 <monochrom> how/where did you obtain ghc?
14:01:33 <napping> well, I don't see it in category-extras
14:01:35 <applicative> does `ghc-pkg list` show them?
14:01:39 <napping> there's a lot of stuff in there
14:01:46 <djahandarie> napping, it might be hiding in the middle of a bunch of crazy stuff
14:01:58 <wagle> ghc from ubuntu
14:01:59 <djahandarie> And using a type signature that looks nothing like what you are looking for but actually is
14:02:40 <quicksilver> napping: I found some of them
14:02:40 <napping> well, it's a type definition, so it can't hide that much
14:03:33 <monochrom> if you want to start from scratch, you can let .cabal live, it's harmless. it sufficies to erase .ghc in most scenerios.
14:03:47 <quicksilver> napping: http://hackage.haskell.org/packages/archive/TypeCompose/0.8.0/doc/html/Data-Pair.html
14:04:00 <wagle> all i really have is gitit, and its unhappy
14:04:23 <quicksilver> napping: is actually not quite the kind of sum you wanted.
14:04:26 <quicksilver> btu it's interesting.
14:04:55 <quicksilver> napping: ah, here http://hackage.haskell.org/packages/archive/TypeCompose/0.8.0/doc/html/Control-Compose.html
14:05:11 <monochrom> interleaving "get haskell lib from ubuntu" and "cabal install lib from hackage" needs care. order matters.
14:05:12 <quicksilver> napping: has Prod but strangely not sum
14:05:49 <quicksilver> @tell conal any particular reason Control.Compose has Prod but not the equivalent Sum?
14:05:49 <lambdabot> Consider it noted.
14:06:46 <Heffalump> monochrom: really? The lib from ubuntu should be binary and not depend on any hand-installed stuff, shouldn't it?
14:07:13 <monochrom> that is right, and that is a cause of problems.
14:07:48 <wagle> worked before, but maybe not working now
14:07:50 <applicative> wagle, i see you are trying to upgrade gitit/
14:08:02 <wagle> applicative: yeah
14:08:58 <monochrom> Scenerio. Initial state: just have ghc and base from ubuntu. Step 1: cabal install something that depends on "time". Step 2: apt-get something that depends on "time". Do you see that you will get two versions of "time"?
14:09:07 <applicative> wagle, i think monochrom is right, there's trouble using both ....
14:10:06 <wagle> well, when this fails, I'll kill the ubuntu ghc and cabal
14:10:25 * applicative was having trouble with time and random with the new cabal -- they keep being reinstalled, but it seems not to break anything.  I
14:10:35 <aidalgol> @src show
14:10:35 <lambdabot> show x = shows x ""
14:10:42 <aidalgol> @src shows
14:10:42 <lambdabot> Source not found. I feel much better now.
14:10:45 <applicative> wagle which version of ghc do you have?
14:10:48 <aidalgol> :t shows
14:10:48 <wagle> i think i tried haskell-platform before, but it failed to work..  its been a couple weeks though
14:10:49 <lambdabot> forall a. (Show a) => a -> String -> String
14:11:02 <wagle> 6.12.1
14:11:03 <monochrom> Since order matters, there is an order that works, and there is an order that breaks. "worked before" "but not this time" can be explained.
14:11:47 <applicative> wagle does have a working ghc.  maybe rebuilding cabal and then getting everything from hackage?
14:12:44 <wagle> i deleted .ghc and .cabal, and am installing gitit..  should be another 5-10 minutes
14:14:51 <applicative> wagle, i see, you're using the package manager's gitit.  That is in principle the best route if you're not going to use Haskell for other things.
14:15:19 <wagle> using cabal's gitit
14:15:53 <applicative> wagle, oh.  the more exalted path.  I thought there was something wrong with your `cabal install`
14:16:16 <wagle> ok, this wont build..  i guess i gotta get a modern ghc
14:16:29 <Heffalump> monochrom: I see.
14:17:16 <monochrom> The only problem with multiple "time" is each comes with C code and there is a name clash.
14:19:23 <wagle> ok, so which way do i want to install the current ghc and cabal?
14:20:10 <monochrom> I, of course, am biased and recommend my shameless plug http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
14:21:10 <applicative> randomwords, did you see the recent  film of dear leader SPJ talking about "nested data parallel" programming. http://www.youtube.com/watch?v=NWSZ4c9yqW8   It seems really cool
14:21:22 <monochrom> But my recommendation is not the only safe way.
14:23:31 <roconnor> c_wraith: I think I've convinced myself that schoolbook division is O(n) when dividing by a constant.
14:24:01 <aidalgol>  
14:24:01 <aidalgol> O(n^2) if you're really bad at it.
14:24:06 <c_wraith> roconnor: that sounds right.
14:24:24 <monochrom> O(n^2) is not as bad as O(2^n)
14:24:39 <c_wraith> I bet that means showAtBase is implemented in an O(n^2) way.
14:24:39 <napping> roconnor: isn't it the product of the number of digits in each?
14:25:10 * applicative searches through the rational numbers performing multiplications til he finds it
14:25:37 * monochrom subtracts and counts
14:26:21 <c_wraith> I still feel like showAtBase *should* be possible to implement in O(n) time, since it's basically arithmetic encoding.
14:26:25 <int80_h> anyone here available to help me with some takusen problems? Tripping up over how to populate a database
14:26:46 <roconnor> napping: isn't what a product?
14:27:47 <napping> roconnor: time to divide
14:28:25 <monochrom> showAtBase? showIntAtBase?
14:29:07 * wagle tries to map pairs of rationals to the rationals
14:29:07 <roconnor> napping: yes, but I'm considering the case when dividing by a constant
14:29:19 <applicative> int80_h, hasn't the new tutorial made everything clear?  ;)
14:29:41 <c_wraith> monochrom, yes
14:30:21 * hackagebot ListZipper 1.2.0.0 - Simple zipper for lists  http://hackage.haskell.org/package/ListZipper-1.2.0.0 (RyanIngram)
14:31:32 <arbitrarylogic> arithmetic coding is usually done at fixed precision isn't it?
14:31:48 <wagle> that was odd..  i got ghc 6.12.1 from the prebuilt haskell platform
14:32:01 <wagle> i shoulda listened to monochrom
14:32:02 <roconnor> arbitrarylogic: not for Integer
14:32:08 <wagle> 8)
14:34:33 <arbitrarylogic> roconnor: I mean the compression scheme http://en.wikipedia.org/wiki/Arithmetic_coding
14:34:45 * chrisdone laughs maniacally
14:35:08 <chrisdone> my align-and-sort-as-you-type-imports emacs code is coming to life
14:35:46 <ski> (.. align what ?)
14:35:55 <chrisdone> ski: the parts of the imports
14:36:00 <monochrom> align imports
14:36:18 <monochrom> such as "import Numeric                    (showIntAtBase)"
14:36:30 <greap> is there something like concatMap for Sets?
14:36:42 <monochrom> just because the next line is "import Text.ParserCombinators.Parsec(...)"
14:37:21 <monochrom> there is union
14:37:39 <monochrom> and unions
14:37:58 * ski besighs that it's not valid to put signatures in `import'/export lists (nor in `instance' declarations, for that matter)
14:38:09 <monochrom> I guess there is no mapUnions
14:38:25 <Two72> arbitrarylo: I think most arithmetic coding systems used fixed precision, not sure though
14:39:14 <monochrom> What you should do is grow out of "plain text editors". Build and use and IDE that will show the sigs at the import/export lists even though they "don't exist in the plain text file".
14:39:25 <arbitrarylogic> so if you tried to use it to change the base of an integer, I assume it could give inaccurate results
14:40:20 <monochrom> And dually, show the import/export statements at the use sites.
14:41:23 <aavogt> monochrom: who would use that?
14:41:29 <monochrom> I would use that.
14:42:21 <greap> monochrom: But that is for a list of sets right? not a set of sets
14:42:33 <napping> why does TH have to typecheck [| |] quotes?
14:43:11 <monochrom> it is not too bad to first turn set of sets into list of sets for this purpose.
14:43:17 <ski> monochrom : sometimes one'd like to import a polymorphic operation, but only use a specific instance of it .. i'd then want to be able to state the more restricted signature
14:43:57 <monochrom> that sounds interesting
14:43:59 <napping> hmm, I guess I could write something equivalent to undefined, and replace the reference
14:44:12 <wagle> yay!  i have haskell highlighting working!
14:44:14 <napping> I'd like a varargs/polytypic thing
14:44:48 <aavogt> napping: to protect you from yourself
14:44:59 <napping> that's what typechecking the result does
14:45:46 <aavogt> @hackage haskell-src-meta
14:45:46 <lambdabot> http://hackage.haskell.org/package/haskell-src-meta
14:45:54 <aavogt> napping: there's a quasiquoter for haskell in there
14:46:17 <napping> that might help
14:46:27 <aavogt> so you can write    [$hs| f g x y z |]  and it won't typecheck the inner expression
14:47:16 <aavogt> though really, that syntax might not be the one you'd end up using
14:47:17 <napping> and reminds me, why doesn't a quasiquoter get access to the haskell parser (ideally after the fixpoint that adds the quasiquoters) to support escapes back to Haskell?
14:47:44 <napping> I've got something where [f a, f b, f c, f g] will be well typed
14:47:56 <napping> but what to write something like map f [a,b,c,g]
14:48:34 <napping> too bad the quasiquoting will break an IDE
14:49:15 <ski> monochrom : .. it would also be nice if sub-classing (and dually for super-classing) allowed restating an operation with more general signature (such that the former was still an instance of the latter .. no explicit argument difference) .. but i haven't thought this through, so there might be some show-stopper
14:49:29 <aavogt> [ [| f $(varE x) | x <- ['a, 'b, 'c ... ] } ?
14:49:44 <aavogt> [ [| f $(varE x) |] | x <- ['a, 'b, 'c ... ] ] ?
14:49:52 <napping> yeah, I could write something like
14:50:03 <aavogt> or however you like to make the NameS
14:50:11 <napping> $(thMap 'f ['a,'b,'c,'d,'e]) -- as long as I don't want to use expressions in the list
14:50:43 <zygoloid> napping: it is /weird/ that TH/QQ doesn't give you access to a haskell parser. a notable deficiency of them.
14:51:13 <yescalona> haskell is the faster functional prog lang???
14:51:33 <napping> It's pretty fast
14:51:33 <EvanR-work> "try haskell we are the faster!!!! est"
14:51:35 <Philonous> yescalona: Faster than what?
14:51:41 <aavogt> than itself
14:51:45 <Two72> you mean faster for what?
14:51:46 <EvanR-work> light
14:51:49 <medfly> THE FASTER FUNCTIONAL PROG LANG
14:51:51 <zygoloid> languages don't have speeds. but GHC tends to produce pretty fast code (sometimes comparable to C)
14:51:53 <medfly> out of the two existing ones
14:51:54 <ski> (languages doesn't have speeds, per se)
14:51:58 <EvanR-work> haha
14:52:22 <yescalona> Philonous: than other functional prog lang
14:52:33 <EvanR-work> clean?
14:52:43 <monochrom> you can make haskell slow, too
14:52:51 <yescalona> :)
14:53:17 <monochrom> haskell mindshare grows faster
14:53:35 <wagle> anyone happen to know how to get firefox out of full screen mode?
14:53:41 <monochrom> and of course that is the sole meaning of "haskell is faster"
14:53:43 <Philonous> F11
14:53:51 <zygoloid> yescalona: http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=ghc&lang2=hipe http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=ghc&lang2=ocaml
14:53:52 <wagle> thanks!
14:53:53 <Two72> wagle: sledgehammer
14:54:11 <wagle> Two72: big ballpeen good enough?
14:54:18 <medfly> wagle, F11, no?
14:54:20 <monochrom> missile
14:54:31 <monoidal> is there a "tutorial" how using continuations one can simulate exceptions, goto, coroutines etc.? I think this is well known
14:54:32 <kyagrd> rebooting works too
14:54:41 <wagle> F11 worked
14:54:44 <zygoloid> ^^ in those benchmarks, GHC6.12.2 is usually faster than Erlang HiPE and comparable to O'Caml
14:55:00 <monochrom> http://www.vex.net/~trebla/haskell/cont-monad.xhtml
14:55:20 <yescalona> nice
14:55:25 * zygoloid ponders why the shootout is using a broken release of GHC
14:55:25 <medfly> hurray! this is probably like the first time I've ever helped anyone on #haskell
14:55:25 <medfly> :-D
14:55:40 <monoidal> monochrom: thanks
14:57:33 <ski> monochrom : hm, for some reason that displays badly in w3m
14:57:59 <monochrom> but it shows ok on ipod touch
14:58:48 <monochrom> w3m doesn't understand xhtml
14:59:07 <monochrom> not my fault, I make sure it's compliant.
15:00:12 <Phantom_Hoover> @pl drop (length xs - 1) xs
15:00:12 <lambdabot> drop (length xs - 1) xs
15:00:25 <Phantom_Hoover> @pl \xs -> drop (length xs - 1) xs
15:00:25 <lambdabot> drop =<< subtract 1 . length
15:00:34 <ski> (i get "Basic Principle\n\n m b) -> m a) -> m a\n]]>", e.g., instead of "Basic Principle\n\tcallCC :: ((a -> m b) -> m a) -> m a\n" (and apparently i get something strange when i try to copy and paste from FF, too))
15:00:41 <ski> monochrom : ok, that could be it
15:01:34 * hackagebot bluetile 0.5.3 - full-featured tiling for the GNOME desktop environment  http://hackage.haskell.org/package/bluetile-0.5.3 (JanVornberger)
15:02:38 <monochrom> w3m doesn't understand the <![CDATA[ ]]> syntax in xml and therefore xhtml 2.
15:03:27 <monochrom> I don't get a copy-paste problem in firefox
15:08:12 <chrisdone> nobody understands the <![CDATA[ ]]> syntax
15:08:32 <monochrom> I am a counterexample.
15:08:51 <napping> Isn't it just based on hoping that ]]> never appears in any text you'd want to include as CDATA?
15:09:01 <monochrom> Yes it is.
15:09:24 <monochrom> Since I don't have ]]> in haskell code, I'm happy.
15:10:27 <monochrom> All escape code mechanisms hope that you don't write something or else you don't mind writing lengthy escape codes.
15:12:08 <monochrom> markdown hopes that you don't write === apart from indicating a header.
15:12:24 <monochrom> problem is you may want to write === in haskell code
15:13:08 <ddarius> "'Our opponent is an alien starship packed with atomic bobms,' I said.  'We have a protractor.'"
15:13:30 <Twey> Haha, what :þ
15:13:34 <monochrom> There are other markdown clashes with haskell and/or literate haskell.
15:13:56 <Twey> I thought it meant something else
15:14:03 <Twey> <! starts a preprocessor block
15:14:13 <FunctorSalad_> (protractor?)
15:14:25 <mreh> Haha, what === lol wut?
15:14:36 <Twey> Then [FOO bar] indicates that ‘bar’ is to be treated as FOO
15:14:46 <napping> monochrom: isn't that just with ===== on a line by itself?
15:14:48 <monochrom> yeah <! used to start a preprocessor block in sgml IIUC
15:14:51 <Twey> And the extra brackets are to make sure that everything is a single block
15:14:57 <FunctorSalad_> ≡≡
15:14:57 <Twey> Or something like that
15:15:25 <FunctorSalad_> (I called that character 'equal-equal-equal' at some point, but someone pointed out that that'd be six bars :( )
15:15:54 <olsner> FunctorSalad_: well, there are six bars in ≡≡
15:16:11 <geheimdienst> ------
15:16:15 <FunctorSalad_> yes, though for this occasion I did it to have the same number of bars as ===
15:16:38 <mreh> there are six bars in a hexogram
15:16:59 <FunctorSalad_> ⬡ ⬢ ⬣
15:17:16 <FunctorSalad_> my super-leet "ucs search-term" script ^_^
15:18:00 <FunctorSalad_> which is actually just a dumb filter around /usr/bin/unicode, which just greps through some datafile, but anyway ;)
15:18:31 <FunctorSalad_> ䷀ ䷁ ䷂ ䷃ ䷄ ䷅ ䷆ ䷇ ䷈ ䷉ ䷊ ䷋ ䷌ ䷍ ䷎ ䷏ ䷐ ䷑ ䷒ ䷓ ䷔ ䷕ ䷖ ䷗ ䷘ ䷙ ䷚ ䷛ ䷜ ䷝ ䷞ ䷟ ䷠ ䷡ ䷢ ䷣ ䷤ ䷥ ䷦ ䷧ ䷨ ䷩ ䷪ ䷫ ䷬ ䷭ ䷮ ䷯ ䷰ ䷱ ䷲ ䷳ ䷴ ䷵ ䷶ ䷷ ䷸ ䷹ ䷺ ䷻ ䷼ ䷽ ䷾ ䷿
15:18:36 <FunctorSalad_> those are the hexagrams
15:18:58 <mreh> cool!
15:19:07 <FunctorSalad_> (other was 'hexagon')... the hexagrams are from medieval(?) chinese(?) literature iirc
15:19:15 <mreh> oh, you were flipping coins
15:19:24 <FunctorSalad_> hmm no?
15:19:39 <FunctorSalad_> the book actually had all the 2^6 hexagrams
15:20:08 <Two72> just wait 'till Unicode 6.0...
15:20:09 <mreh> -blah?
15:20:10 <mreh> they're talking haskell in blah again
15:20:11 <kmc> @pl \f g x -> f (\y1 -> g (\y2 -> x (y1,y2)))
15:20:11 <lambdabot> (. ((. ((. (,)) . (.))) . (.))) . (.)
15:20:17 <FunctorSalad_> (and they have interesting names too)
15:20:30 <fatuhoku> hey ppl
15:20:36 <fatuhoku> I'm having a bit of trouble with TemplateHaskell
15:21:25 <monochrom> You have come to Temple Haskell
15:21:48 <fatuhoku> Temple Haskell...?
15:22:02 <c_wraith> This channel.  bad joke.  monochrom, don't confuse people :)
15:22:23 <FunctorSalad_> "the Book of Changes, Classic of Changes; and Zhouyi"
15:22:24 <fatuhoku> I see :P
15:22:39 <napping> monochrom: also, doesn't markdown only think it's a header if there are several = together?
15:22:42 <geheimdienst> c_wraith, as the abbot around here, monochrom can do what he damn well pleases
15:22:47 <FunctorSalad_> ("c. 50 BC-10 AD"... close enough ;))
15:23:57 <devinus> what's the recommended regex library?
15:24:04 <FunctorSalad_> Two72: they are actually planning one?
15:24:11 <FunctorSalad_> will it have >>=/
15:24:11 <FunctorSalad_> ?
15:24:19 <FunctorSalad_> (the / was a typo)
15:24:47 <aavogt> fatuhoku: just ask
15:25:01 <chrisdone> devinus: Text.Regex.Posix is okay
15:25:08 <monochrom> I recommend whatever regex library that comes with haskell platform.
15:25:17 <monoidal> can "runKleisli . mapM . Kleisli" be written shorter? it takes a -> m b to [a] -> m [b]
15:25:27 <devinus> hrm
15:25:29 <fatuhoku> right- well there's a set of interesting exercises on http://www.cs.uu.nl/wiki/bin/view/Afp0607/ExerciseTemplateHaskell
15:25:33 <monochrom> which is regex-posix too
15:25:45 <devinus> i'm going to be doing some wicked regexing
15:25:45 <devinus> like
15:25:45 <devinus> a LOT
15:25:49 <Philonous> geheimdienst: Hush are he will make us all sacrifice a lamb(da) for the privilege to speak
15:25:51 <devinus> is Text.Regex.Posix fast?
15:26:06 <Philonous> or*
15:26:13 <FunctorSalad_> monoidal: mapM? :o
15:26:17 <devinus> (perhaps i shouldn't be using haskell for it?)
15:26:21 <FunctorSalad_> surely I'm missing something 
15:26:28 <fatuhoku> and on Q2, I don't know how to write insert properly
15:26:29 <FunctorSalad_> @ty mapM
15:26:29 <fatuhoku> it requires that an argument taken as argument needs to be put into a resultant lambda expression
15:26:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:26:42 <aristid> monoidal: runKleisli . mapM . Kleisli does not typecheck
15:26:51 <geheimdienst> isn't the party line that parsec is cooler and should often be used where in other languages you'd go for regexes ...?
15:27:01 <monoidal> oh, sorry. should be inversed: Kleisli . mapM . runKleisli
15:27:06 <FunctorSalad_> :)
15:27:19 <monoidal> it's same as mapM, but for the Kleisli wrapper
15:27:21 <kmc> devinus, if you use (say) Text.Regex.Posix.ByteString directly, you get a much saner interface rather than the retardedly overloaded one in regex-base
15:27:21 <FunctorSalad_> hmm, give it a name?
15:27:48 <FunctorSalad_> if it isn't in Contorl.Arrow, it probably doesn't exist :) (unless someone made an arrow utility lib yet)
15:28:04 <kmc> :t \f -> Kleisli . mapM f . map runKleisli
15:28:05 <lambdabot> forall a b (m :: * -> *) a1 b1. ((a1 -> m b1) -> a -> b) -> [Kleisli m a1 b1] -> Kleisli [] a b
15:28:11 <ski> @type Kleisli . mapM . runKleisli
15:28:11 <FunctorSalad_> (HXT is one actually, surely one of the myriad functions there does it)
15:28:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => Kleisli m a b -> Kleisli m [a] [b]
15:28:20 <kmc> heh
15:29:33 <greap> Is there a reason why there is no memofix in the data-memocombinators library?
15:29:33 <aavogt> fatuhoku: do you know what the generated code should look like?
15:30:07 <aristid> monoidal: using Control.Compose you can do (runKleisli ~> Kleisli) mapM, and you can reuse runKleisli ~> Kleisli for other operations
15:30:14 <aristid> just a thought:)
15:30:36 <monoidal> aristid: thanks!
15:31:07 <FunctorSalad_> (I'm curious why you're using the newtyped Kleisli btw...)
15:31:13 <aristid> monoidal: i get a provision from conal
15:31:30 <FunctorSalad_> the selling point 'category' is neutralized by (>=>)
15:31:39 <FunctorSalad_> for *** and friends maybe...
15:33:28 <djahandarie> I always need to look up what Kleisli is because of its weird name
15:33:43 <djahandarie> /never using it
15:34:21 <Philonous> FunctorSalad_: It's useful when you want to add Arrow transformers 
15:35:53 <devinus> what about regex-tdfa, has anybody tried that?
15:35:59 <djahandarie> Is there something like a codo?
15:36:21 <FunctorSalad_> devinus: yes, it seems fine (not that I did any remotely heavy-duty stuff)
15:36:33 <monoidal> class ArrowMap a where mapA :: a b c -> a [b] [c]; instance ArrowMap (->); instance Monad m => ArrowMap (Kleisli m)
15:36:47 * hackagebot constructive-algebra 0.2.0 - A library of constructive algebra.  http://hackage.haskell.org/package/constructive-algebra-0.2.0 (AndersMortberg)
15:36:55 <chrisdone> kmc: the retarded overloadery wouldn't annoy me if it was better documented with examples
15:37:08 * geheimdienst thinks among haskellites "useful" has the weirdest meaning. "oh that's very useful for adding abstract nonsense transformers to my abstract nonsense." </scnr>
15:37:08 <FunctorSalad_> there's also pcre, both with the =~ interface and as pcre-light
15:37:22 <FunctorSalad_> haha
15:37:47 <aristid> monoidal: oh so you're doing general arrow stuff?
15:38:17 <monoidal> aristid: no, just an idea to make that nice
15:38:18 <napping> geheimdienst: the best part about Haskell is being able to turn abstract nonsense into values you can pass around and call and parameterize and transform and stuff
15:38:22 <napping> none of this "patterns"
15:39:02 <FunctorSalad_> mapMA :: a b [c] -> ListT a [b] c? o_O
15:39:24 <Philonous> napping: The ultimate programming language will be indistinguishable from line noise
15:39:28 <kmc> scnr?
15:39:30 <FunctorSalad_> at least if ListT somehow generalized the kleisli of the list transformer monad
15:39:31 <devinus> oh wow
15:39:39 <djahandarie> Sorry could not resist
15:39:39 <FunctorSalad_> nevermind I'm babbling nonsense
15:39:42 <devinus> from regex-tdfa: "The major advantage over pcre is avoidance of exponential blowup for certain patterns: asymptotically, the time required to match a pattern against a string is always linear in length of the string. This O(N) scaling is now achieved even in the worst case and when returning the correct Posix captures."
15:39:46 <devinus> that's like google's re2
15:39:51 <FunctorSalad_> typed line noise.
15:40:12 <FunctorSalad_> sadly the types themselves are line noise too
15:41:13 <FunctorSalad_> the 'linear' thing presumably excludes calculating the minimal automaton
15:41:21 <FunctorSalad_> (I mean 'doesn't take into account')
15:41:33 <napping> does it minimize?
15:41:45 <Philonous> FunctorSalad_: No, we enumerate all well-typed expressions and refer to them by their number in binary. So anything you enter will be well-typed by definition.
15:41:56 <FunctorSalad_> though making up the automaton (minimal or not) has nothing to do with the *input string* length anyway
15:42:10 <FunctorSalad_> (silly me)
15:42:55 <FunctorSalad_> napping: hmm are you saying there are schemes which are not minimal but good enough and faster?
15:43:05 <FunctorSalad_> (I have no idea)
15:43:25 <napping> well, that recent paper used the regex tree itself with various tag bits applied as states
15:43:44 <datwinkdaddy> @djinn (a -> b) -> (a -> c) -> (b -> c -> d) -> a -> d
15:43:45 <lambdabot> f a b c d = c (a d) (b d)
15:44:17 <datwinkdaddy> @pl \a b c d -> c (a d) (b d)
15:44:17 <lambdabot> flip . (ap .) . flip (.)
15:45:46 <monoidal> datwinkdaddy: if you move third argument to third position, it's liftM2
15:45:56 <monoidal> first
15:46:27 <datwinkdaddy> Hrm.  Ah.  Right.
15:46:32 <mreh> @src State MonadFix
15:46:32 <lambdabot> Source not found. :(
15:46:42 <datwinkdaddy> Because instance Monad (-> a), right?
15:46:48 <monoidal> yes
15:46:59 <mreh> @src MonadFix State
15:47:00 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:47:57 <devinus> what are some lazy templating haskell libraries?
15:51:04 <ski> (devinus : to be pedantic, either `instance Monad ((->) a)' (actual Haskell syntax), or `instance Monad (a ->)' (using imaginary sections of type operators syntax))
15:51:22 <ski> (er, s/devinus/datwinkdaddy/)
15:51:49 <napping> it seems class names which are infix operators have to be written prefix in class and instance declarations
15:51:54 <cjf> .r
15:55:47 <devinus> length' xs = sum [1 | _ <- xs]
15:55:50 <devinus> just how lazy is that?
15:56:03 <devinus> will it build the list of 1's before summing it?
15:56:10 <devinus> or is there some optimization?
15:56:15 <c_wraith> It will.
15:56:23 <Twey> Will it?
15:56:31 <c_wraith> well, conceptually it will.
15:56:37 <c_wraith> it will get fused out
15:56:38 <monoidal> i think it might fuse
15:56:45 <c_wraith> but it will add each of the 1s individuallys
15:56:48 <devinus> what does fuse mean?
15:56:48 <c_wraith> err, individually
15:57:15 <c_wraith> list fusion is an optimization that removes lots of intermediate lists between commonly used list generation and consumption functions
15:57:16 <datwinkdaddy> devinus: It's one of the optimization steps of GHC, IIRC.
15:57:19 <monoidal> devinus: if you fold a list you're creating, it is optimized "on the fly"
15:57:27 <devinus> ah
15:57:29 <cjf> r/
15:57:31 <napping> devinus: which has nothing to do with how much of the list will be evaluated
15:57:59 <napping> devinus: what you need to know is that [1 | x <- xs] gets desugared into (map (\x -> 1) xs)
15:58:02 <monoidal> devinus: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/rewrite-rules.html point 6.14.e
15:58:07 <chrisdone> Twey: how's this for a slice of fried gold? http://youtube.com/watch?v=UXHSiUPKLvg&fmt=35
15:58:21 <monoidal> point 7.14.3
15:58:31 <kmc> devinus, "how lazy is it" is a semantics question; "will it fuse" is a question of implementation
15:58:43 <devinus> right, i meant implementation i guess
15:58:45 <kmc> devinus, how lazy it is is that it will force the spine of xs, but not the elements
15:58:46 <datwinkdaddy> What's the point of making length "more lazy" than it already is.
15:58:59 <devinus> datwinkdaddy: just learning
15:59:05 <devinus> experimenting
15:59:14 <kmc> datwinkdaddy, with an inductive natural number type we can say (length [1..]  > 5) and get the result True
15:59:19 <Twey> chrisdone: Nice
15:59:26 <devinus> kmc: what does spine mean in this context?
15:59:35 <kmc> devinus, the cons cells that make up the list
15:59:37 <kmc> the (:) constructors
15:59:39 <devinus> ah
15:59:45 <kmc> each of them will be forced
15:59:52 <devinus> without the actual value
15:59:54 <devinus> nice
15:59:58 <kmc> right
16:00:04 <kmc> > length [undefined, undefined]
16:00:05 <lambdabot>   2
16:00:16 <kmc> > length (3 : undefined)
16:00:17 <lambdabot>   *Exception: Prelude.undefined
16:00:44 <datwinkdaddy> kmc: Yeah, but length doesn't use inductive naturals.
16:00:51 <datwinkdaddy> kmc: genericLength might.
16:00:52 <kmc> but genericLength can
16:01:02 <geheimdienst> > length (undefined : undefined : [])
16:01:03 <lambdabot>   2
16:01:18 <chrisdone> > length $ error "first" : error "second"
16:01:19 <lambdabot>   *Exception: second
16:01:36 <napping> probably best to use something with drop for tests like that, though
16:01:42 <datwinkdaddy> > length $ error "first" : error "second" : []
16:01:43 <lambdabot>   2
16:02:00 <Twey> > genericLength [1 ..] > (5 :: Nat)
16:02:01 <chrisdone> @src length
16:02:01 <lambdabot> Source not found. Wrong!  You cheating scum!
16:02:02 <lambdabot>   Not in scope: type constructor or class `Nat'
16:02:12 <devinus> okay, going back to learn haskell, getting confused now
16:02:16 <devinus> haha
16:02:28 <geheimdienst> this happens because it calls 'error "second"' hoping that it will return a list ... right?
16:02:49 <crazycaw> i want to learn Haskell, can you recommend me a book or tutorial? haskell has a big learning Curve?
16:02:49 <datwinkdaddy> devinus: When your brain is full, start playing with @djinn.
16:02:57 <datwinkdaddy> devinus: It'll explode. :)
16:03:02 <kmc> crazycaw, RWH and LYAH are often recommended
16:03:04 <kmc> @where RWH
16:03:04 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:03:05 <kmc> @where LYAH
16:03:06 <lambdabot> http://www.learnyouahaskell.com/
16:03:07 <chrisdone> geheimdienst: it happens because length pattern matches on the []
16:03:12 <aavogt> geheimdienst: error "second" could very well be a whole bunch more elements of the list
16:03:22 <chrisdone> length (x:xs) = 1 + length xs
16:03:22 <chrisdone> length [] = 0
16:03:28 <datwinkdaddy> I like RWH, fairly practical approach.
16:03:29 <hpc> :t error
16:03:29 <monoidal> @src length
16:03:29 <lambdabot> Source not found.
16:03:30 <lambdabot> forall a. [Char] -> a
16:03:32 <kmc> crazycaw, it does have a steep learning curve.  the main thing is you have to be motivated, and not expect to write sophisticated programs right away
16:03:38 <monoidal> @src genericLength
16:03:38 <lambdabot> genericLength []    = 0
16:03:38 <lambdabot> genericLength (_:l) = 1 + genericLength l
16:03:45 <kmc> crazycaw, it's not a language where you can jump in and start writing  blog engines and 3D renderers
16:03:48 <datwinkdaddy> The typeclassopaedia is awesome, too.
16:03:56 <kmc> it takes a while to get to that point
16:04:07 <devinus> datwinkdaddy: i don't have a formal CS degree, haskell is already WAY over my head for me to even look at djinn
16:04:09 <aavogt> kmc: are there such languages?
16:04:23 <djahandarie> I must say, after not reading typeclassopaedia then reading it after learning everything sure made me wish I read it earlier
16:04:34 <hpc> with the right math background, you can jump right in and start writing symbolic algebra systems though
16:04:40 <djahandarie> aavogt, most languages after learning one language
16:04:40 <monoidal> crazycaw: http://stackoverflow.com/questions/1012573/how-to-learn-haskell
16:04:46 <datwinkdaddy> djahandarie: Argeed on Monads, especially.
16:04:58 <kmc> aavogt, mostly we learn new languages by a syntactic mapping to languages we already know
16:05:09 <kmc> there's definitely a thing where you learn Ruby by writing a site in Rails
16:05:12 <djahandarie> I don't know if I would have the same impression if I read it during my learning process
16:05:13 <crazycaw> kmc, my principal motivation is configure xmonad
16:05:28 <djahandarie> To fully understand the xmonad file will take awhile..
16:05:30 <geheimdienst> crazycaw, a noble undertaking
16:05:31 <wlangstroth> try crisdone's awesome http://tryhaskell.org
16:05:35 <djahandarie> It isn't hard to make it do stuff you want though
16:05:39 <datwinkdaddy> djahandarie: My brain still sometimes equates Monad m => m a with IO a. :(
16:06:13 <geheimdienst> many haskellers started out by fiddling with the xmonad config file
16:06:29 <monochrom> http://www.vex.net/~trebla/haskell/learn-sources.xhtml
16:06:55 <djahandarie> That's a nice site
16:07:04 <djahandarie> Should be its own page on the wiki
16:07:25 <datwinkdaddy> I found Haskell because I was looking for a functional language to learn and I thought Lisp/Scheme wasn't pure enough.
16:07:39 <djahandarie> Someone mentioned awhile ago that a wiki fixup was in order... has there been any progress on that?
16:07:41 <napping> datwinkdaddy: why are you still here?
16:07:41 <datwinkdaddy> set! is not very functional. :(
16:07:50 <wlangstroth> crazycaw: beyond that, the Haskell community is probably the best for asking questions
16:07:53 <napping> datwinkdaddy: get you to #agda
16:08:01 <ddarius> That's sorta how I ended up at Haskell though I already knew Scheme and CL; it was O'Caml and SML that weren't "pure" enough.
16:08:04 <napping> or #coq :)
16:08:04 <crazycaw> ok, i will get to work :D
16:08:24 <djahandarie> This is definitely a fantastic IRC channel
16:08:30 <devinus> reading hackage package descriptions make me wish i had a CS degree
16:08:35 <datwinkdaddy> I recently heard of CoQ.
16:08:38 <devinus> can't understand half the stuff said in them
16:08:41 <ddarius> devinus: Why?
16:08:46 <napping> devinus: you can find many papers with google
16:08:48 <ddarius> devinus: Why do you think a degree would help?
16:09:02 <datwinkdaddy> I think it would be interesting to learn.  It would be nice to be able to show people formal proofs of my small-ish programs.
16:09:03 <kyagrd> devinus: I have a CS B.S. degree and I don't understand a lot of them
16:09:04 <wlangstroth> devinus: don't worry, a lot of that stuff is advanced regardless
16:09:21 <djahandarie> Just reading the wikipedia article on asymptotic time complexity will cover most of them...
16:09:22 <wlangstroth> (or freaking crazy - where's Kmett?)
16:09:32 <datwinkdaddy> Still, I'd like to feel comfortable with Haskell.  I'm quite enjoying learning it.
16:09:37 <monochrom> "I don't know today" does not imply "I won't know tomorrow"
16:09:39 <djahandarie> And that last bit will require 2 PhD's in Computer Science and Math
16:09:51 <kmc> the important differences between Haskell and Scheme are not purity
16:10:04 <wlangstroth> here we go
16:10:21 <ddarius> kmc: I disagree, though readily admit that there are other important differences.
16:10:26 <monochrom> and you can get a PhD from #haskell :)
16:10:34 <kmc> types are a much bigger deal
16:10:40 <datwinkdaddy> kmc: What's the important difference.  Typeclasses?
16:10:40 <c_wraith> You can?  I need to get into this program. :)
16:10:42 <devinus> monochrom: wouldn't that be nice :)
16:10:46 <kmc> static types
16:10:50 <dbelange> Probably the most important difference is speed.
16:10:54 <kmc> never mind type classes
16:10:58 <datwinkdaddy> Oh, yeah, that was another big thing.
16:11:03 <kmc> dbelange, wouldn't that be a difference of implementation?
16:11:03 <dbelange> (ghc being ridiculously slow)
16:11:08 <djahandarie> devinus, you can actually learn a lot here if you try to follow the crazy conversations that happen occasionally
16:11:16 <datwinkdaddy> I was tired of loosely-typed languages.
16:11:29 <kmc> dbelange, you care how long the compiler runs?
16:11:31 <datwinkdaddy> I was forced to write too much Perl for work, so my brain was rebelling.
16:11:35 <devinus> djahandarie: yeah i've been trying to soak up some stuff by osmosis
16:11:43 <devinus> lurking
16:11:46 <kyagrd> The problem of dynamic languages are when you start to refactor and add more configurations.
16:11:52 <dbelange> kmc, if I didn't, I would use stalin
16:12:06 <ddarius> The problem of static languages are when you start to refactor and add more configurations.
16:12:07 <geheimdienst> am i missing something? scheme is dynamically typed, no? that's a big honking difference right there!
16:12:18 <kmc> that's what i said
16:12:44 <kyagrd> It becomes a hell when you have to add a new parameter that hadn't thought of before, and tracing them along the code is pain unless you have a really good call graph analyzer (which most of those languages don't have)
16:12:46 <kmc> also has a totally different data model (one generic tree type vs. algebraic data)
16:13:08 <wlangstroth> Haskell types aren't just static, though - there's a big difference in usability between Haskell types and Java types ... objects ... primitives ... whatever
16:13:15 <Adamant> kmc: amazingly enough, some people do care, at least for development work :P
16:13:30 <ddarius> Adamant: ghc -O0 isn't bad.
16:13:33 <geheimdienst> kyagrd, true, that's a drawback of dynamic languages
16:13:40 <Adamant> ddarius: good point.
16:13:43 <kmc> and Scheme does source metaprogramming in a simpler way than Haskell
16:14:16 <wlangstroth> kmc: you mean macros rather than template haskell?
16:14:18 <aavogt> there are different goals there
16:14:18 <kmc> yeah
16:14:27 <wlangstroth> hehe - yeah
16:14:27 <kmc> i don't see purity as a big deal, because you can have the discipline not to use set! in Scheme, just as you can have the discipline not to use unsafePerformIO in Haskell
16:14:28 <Adamant> I still like macros better, but I've warmed up to Haskell's way of doing things somewhat at least.
16:14:45 <kmc> it's true that there are differences of community norms and library defaults
16:14:46 <ddarius> TH is not very different from CL-style macros.
16:15:00 <Adamant> kmc: truth
16:15:01 <aavogt> ddarius: types?
16:15:04 <kyagrd> There should be a lazy depedently typed staged programming language
16:15:20 <ezyang> I'm using (Int, Int) as a range index. Is the convention in Haskell for the right bound inclusive or exclusive? 
16:15:20 <kmc> TH is a lot clunkier because Haskell syntax is more complicated, and because GHC doesn't even implement all the necessary TH quoting / splicing forms
16:15:25 <wlangstroth> kyagrd: if you code it, they will come
16:15:33 <ddarius> kyagrd: Most dependently typed languages are total for which "lazy" has little meaning.
16:15:36 <kmc> > newArray (0,5) 0
16:15:37 <lambdabot>   Not in scope: `newArray'
16:15:42 <kmc> > array (0,5) 0
16:15:43 <lambdabot>   No instance for (GHC.Num.Num [(t, e)])
16:15:43 <lambdabot>    arising from a use of `e_1050' at...
16:16:18 <ddarius> > inBounds 3 (0, 3)
16:16:19 <lambdabot>   Not in scope: `inBounds'
16:16:19 <ezyang> it looks like... inclusive. 
16:16:21 <kyagrd> In addition TH's stage restriction is to strict.
16:16:29 <ddarius> @src Ix
16:16:29 <lambdabot> class (Ord a) => Ix a where
16:16:30 <lambdabot>     range           :: (a,a) -> [a]
16:16:30 <lambdabot>     index           :: (a,a) -> a -> Int
16:16:30 <lambdabot>     inRange         :: (a,a) -> a -> Bool
16:16:30 <lambdabot>     rangeSize       :: (a,a) -> Int
16:16:35 <chrisdone> I need to go to bed but I accidentally opened a YouTube video of Simon Peyton Jones giving a talk on Data Parallel Haskell, now I can't move
16:16:43 <ddarius> > inRange (0,2) 2 
16:16:44 <lambdabot>   True
16:16:46 <ezyang> Haha. That's a pretty good talk. 
16:16:48 <datwinkdaddy> > array (0, 5) $ (0, "stuff") : [(x, undefined) | x <- [1..5]]
16:16:48 <chrisdone> too... interesting...
16:16:49 <lambdabot>   array (0,5) [(0,"stuff"),(1,"*Exception: Prelude.undefined
16:17:04 <wlangstroth> chrisdone: you poor bastard - that's an awesome talk
16:17:12 <ddarius> chrisdone: Soon you will be infused with too much energy to slee.p.
16:17:28 <kyagrd> In lot of cases ending up using CPP to factor out commen subexpressions from TH code just because of stage restriction.
16:17:29 <wlangstroth> k, I'm watching that one again
16:17:33 <chrisdone> :-)
16:17:54 <c_wraith> I do wish I could alter imports from TH.
16:17:58 <datwinkdaddy> > array (0, 5) $ [(x, replicate x 'x') | x <- [1..5]]
16:17:59 <lambdabot>   array (0,5) [(0,"*Exception: (Array.!): undefined array element
16:18:03 <datwinkdaddy> > array (0, 5) $ [(x, replicate x 'x') | x <- [0..5]]
16:18:04 <lambdabot>   array (0,5) [(0,""),(1,"x"),(2,"xx"),(3,"xxx"),(4,"xxxx"),(5,"xxxxx")]
16:18:33 <djahandarie> I should get some code on my laptop so I can work on my flight
16:19:10 <aavogt> kyagrd: use more modules instead?
16:19:58 <nswill> Does == force the evaluation of self referential data structures (ie cyclic graphs)? If I attempt to do so I get a "stack overflow" in ghci
16:20:24 <kmc> nswill, (==) is defined separately for every data type
16:20:25 <datwinkdaddy> Are you deriving Eq?
16:20:27 <kmc> in a type class instance
16:20:38 <kmc> but it will probably recurse on fields of the same type
16:20:41 <zygoloid> c_wraith: write some TH which generates a file which is #included into another file using -XCPP :)
16:20:43 <kmc> and so, yes
16:20:46 <kyagrd> aavogt: Well I have a TH function g which is kind of higer order and gets arugmets f and x and uses (f x) in two differnt stages (one in [| |] and one outside).
16:20:52 <nswill> I'm deriving Eq, I didn't create my own instance of ==, is that the source of the issue?
16:20:53 <ddarius> You won't necessarily get a stack overflow.
16:20:54 <zygoloid> c_wraith: hey presto, you can generate imports :)
16:21:13 <kyagrd> Can't really factor out local defintion into a module
16:21:40 <kmc> nswill, if you write your own instance you get to decide what it does and doesn't compare
16:21:46 <c_wraith> zygoloid, at that point, it's easier to just use CPP to manage imports directly. :)
16:21:50 <datwinkdaddy> nswill: The derived Eq will generally force things.
16:22:07 <datwinkdaddy> nswill: The "more ==" the two objects are, the more it will force.
16:23:32 <zygoloid> the existence of cyclic data structures sadly means that compiler-generated Eq's can't start by comparing the closure pointers ;(
16:23:32 <nswill> It's interesting how I get a stack overflow even comparing a bound variable to itself
16:23:32 * zygoloid had been wondering why GHC didn't do that. now it seems so obvious :)
16:23:32 <ddarius> zygoloid: Because it would be more defined?
16:23:32 <zygoloid> ddarius: exactly.
16:23:32 <nswill> Do I have to do something like compare graph node labels?
16:24:44 <zygoloid> nswill: yeah. cyclic lazy structures are sadly pretty hard to work with, unless you have some external way to compare nodes
16:26:30 <nswill> Well, thank you for answering my question
16:27:26 <zygoloid> the trouble isn't the cycle or the laziness, it's that denotationally you can't tell a cyclic structure from an infinite one
16:27:31 <zygoloid> (denotationally they're the same thing)
16:28:49 <nswill> I'm very new to the concept of denotational semantics; but, I imagine someone has already attempted to solve this problem?
16:29:05 <napping> zygoloid: you could compare pointers for a positive result, maybe?
16:29:21 <napping> hmm, I guess that could terminate when the explicit test wouldn't
16:29:23 <nswill> Specifically the data structure I'm trying to implement is the half edge data structure, it stores the topology of meshes so you can do walks on the surface to implement various mesh altering operations
16:29:59 <nswill> The data structure by nature is just filled with cycles so you can do lookups in constant time
16:30:33 <zygoloid> napping: yeah. even for finite types: Just undefined == Just undefined had better not produce 'True'!
16:30:34 <napping> well, then you won't be able to modify the lazy version very easily
16:30:53 <napping> hey, it's Just _|_ vs Just _|_
16:31:18 <zygoloid> nswill: if you really need constant-time modifications, you're probably best off using ST.
16:31:43 <djahandarie> Wouldn't it just be something like data Edge= Edge { org :: Int, sym :: Edge, next :: Edge }
16:31:43 <zygoloid> if logarithmic is enough, then Map VertexKey VertexData is probably fine
16:32:14 <nswill> http://www.cgafaq.info/wiki/Half_edge_general
16:32:22 <zygoloid> or even IntMap
16:33:41 <nswill> I can implement it with arrays easily enough, I was just trying to see if I could do it with self referential structures in haskell as an exercise
16:34:56 <dfkjjkfd>  /url 344
16:34:59 <dfkjjkfd> oops
16:35:49 <dom96> What's the best way to parse JSON in haskell ?
16:36:11 <zygoloid> dom96: iirc there's a section in RWH on parsing JSON :)
16:36:45 <dom96> I don't want to write my own parser, isn't there a package i could use ?
16:37:15 <zygoloid> @hackage json
16:37:15 <lambdabot> http://hackage.haskell.org/package/json
16:37:25 <wlangstroth> dom96: I like http://hackage.haskell.org/package/json
16:37:37 <wlangstroth> hey - handy
16:37:46 <kyagrd> dom96: parsec, happy
16:37:52 <dom96> nice, thanks.
16:37:59 <Raynes> Eh.
16:38:20 <kyagrd> Oh sorry
16:38:34 <kyagrd> I read the question in opposite way :(
16:38:39 <kyagrd> dom96: never mind
16:38:49 <dom96> kyagrd: don't worry about it.
16:39:01 <Raynes> :p
16:39:28 <napping> nswill: you can implement a structure, but won't be able to change it very easily
16:39:43 <napping> maybe adding tags for comparison if you need
16:39:51 <Phyx-> @hoogle Int -> m a -> m [a]
16:39:51 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
16:39:52 <lambdabot> Text.ParserCombinators.ReadP count :: Int -> ReadP a -> ReadP [a]
16:39:52 <lambdabot> Prelude drop :: Int -> [a] -> [a]
16:43:35 <hpc> :t mapM
16:43:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:43:58 <sshc> Does parsec have any standard way of parsing a line or an end of line parser?
16:44:38 <sshc> Is there a map function that also passes the function's index?
16:45:08 <ddarius> sshc: zipWith f [0..]
16:45:10 <Phyx-> sshc: no, but that's easy to simulate
16:45:22 <Phyx-> like ddarius just did
16:45:23 <Phyx-> lol
16:45:39 <Phyx-> :t curry
16:45:40 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:45:48 <Phyx-> i would use
16:46:00 <Phyx-> zipWith (uncurry f) [0..]
16:46:09 <Phyx-> :t \f -> zipWith (uncurry f) [0..]
16:46:10 <lambdabot> forall a b b1 c. (Num a, Num b, Enum (a, b)) => (a -> b -> b1 -> c) -> [b1] -> [c]
16:46:30 <ddarius> zipWith (curry f) = map f . zip
16:46:43 <ddarius> (map f .) . zip
16:46:56 <sshc> :t zipWith
16:46:57 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:47:22 <hpc> zipWith : map2 :: liftM : liftM2
16:47:27 <Phyx-> meh, the uncurry isn't needed
16:47:30 <Phyx-> *brainfart*
16:47:31 <sshc> Thanks
16:47:36 <sshc> Is there a map function that also passes the function's index?
16:47:39 * Phyx- goes back to his benchmarks
16:48:13 <kyagrd> sshc: first zip with [0..] ?
16:48:18 <Phyx-> 01:44:38 < ddarius> sshc: zipWith f [0..]
16:49:41 <hpc> > let f index value = index + value; zipWithIndex f = zipWith f [0..] in zipWithIndex f [1,2,3,4,5]
16:49:42 <lambdabot>   [1,3,5,7,9]
16:50:07 <Phyx-> :t intercalte
16:50:08 <lambdabot> Not in scope: `intercalte'
16:50:10 <Phyx-> :t intercalate
16:50:11 <lambdabot> forall a. [a] -> [[a]] -> [a]
16:50:59 <hpc> for some reason, "intercalculate" makes me think "intergalactic planetary"
16:52:36 <kmc> it makes me think of INTERCAL
16:53:51 <hpc> :t intercal
16:53:52 <lambdabot> Not in scope: `intercal'
16:54:20 <hpc> data IT = FORTRAN | INTERCAL | COBOL | VB | C
16:54:25 <FunctorSalad_> there's an 'unintercalate' too
16:54:30 <FunctorSalad_> useful actually
16:54:35 <hpc> :t unintercalculate
16:54:36 <lambdabot> Not in scope: `unintercalculate'
16:54:47 <datwinkdaddy> @pl \x y z -> if x then y else z
16:54:47 <lambdabot> if'
16:54:54 <datwinkdaddy> @src if'
16:54:55 <lambdabot> Source not found. It can only be attributed to human error.
16:54:59 <datwinkdaddy> :t if'
16:55:00 <lambdabot> Not in scope: `if''
16:55:17 <FunctorSalad_> exec ghc -e ':m +Data.List.Split' -e ':t unintercalate'
16:55:19 <monoidal> @hoogle Bool -> a -> a -> a
16:55:19 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
16:55:20 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
16:55:20 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
16:55:23 <FunctorSalad_> exec -o ghc -e ':m +Data.List.Split' -e ':t unintercalate'
16:55:27 <FunctorSalad_> unintercalate :: (Eq a) => [a] -> [a] -> [[a]]
16:55:30 <monoidal> @hoogle a -> a -> Bool -> a
16:55:30 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
16:55:30 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
16:55:30 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
16:55:31 <FunctorSalad_> :F
16:55:54 <hpc> @hoogle (a -> Bool) -> a -> b -> b -> b
16:55:54 <lambdabot> Foreign.C.Error throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
16:55:55 <lambdabot> Foreign.C.Error throwErrnoIfRetryMayBlock :: (a -> Bool) -> String -> IO a -> IO b -> IO a
16:55:55 <lambdabot> Foreign.C.Error throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()
16:56:01 <Phyx-> writeFile "pureHS.csv" (intercalate "," $ map show times)
16:56:04 <FunctorSalad_> btw I can't be the first one to have the idea to actually use the standalone hoogle tool?
16:56:11 <Phyx-> crude but effective benchmarks :P
16:56:21 <hpc> FunctorSalad_: probably, since lambdabot is so handy
16:56:26 <FunctorSalad_> (I mean, cabal haddock --hoogle your whole cache and combine the databases)
16:56:27 <randomwords> If I have an index out of range error, is there an easy way to tell at runtime where this error is happening?
16:56:29 <Phyx-> FunctorSalad_: i use it alot
16:56:30 <hpc> oh, and the real interface too
16:56:45 <FunctorSalad_> my point is that the database would be a lot more comprehensive
16:56:51 <Phyx-> FunctorSalad_: especially when coding on the go
16:57:03 <FunctorSalad_> (if you download most of hackage into your cache and then run it over them all)
16:57:16 <FunctorSalad_> Phyx-: for what you're working on? sounds useful too
16:57:22 <hpc> randomwords: not really
16:57:30 <randomwords> balls
16:57:52 <hpc> if i ever need !!, i make it provably safe, or write !!! to return a Maybe
16:57:59 <monoidal> randomwords: maybe http://hackage.haskell.org/cgi-bin/hackage-scripts/package/interlude
16:58:15 <monoidal> i'm not sure if it'll work for yo
16:58:17 <monoidal> u
16:58:22 <randomwords> hpc: I need speed here unfortunately
16:58:31 <FunctorSalad_> 'this looks provably safe. I can tell by the declarations and from having seen quite a few safe uses in my time'
16:58:33 <Phyx-> FunctorSalad_: you mean the benchmarks or hoogle?
16:58:41 <FunctorSalad_> Phyx-: hoogle
16:58:47 <Phyx-> ah
16:58:48 <hpc> @src !!
16:58:48 <Phyx-> :)
16:58:49 <lambdabot> xs     !! n | n < 0 = undefined
16:58:49 <lambdabot> []     !! _         = undefined
16:58:49 <lambdabot> (x:_)  !! 0         = x
16:58:49 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:58:59 <hpc> no speed there :P
16:59:04 <Phyx-> but i have to admit
16:59:11 <Phyx-> more and more i just "know" where stuff is
16:59:15 <Phyx-> or can guess
16:59:52 <FunctorSalad_> randomwords: semi-easy... compile with profiling, run with +RTS -xc
17:00:04 <FunctorSalad_> *compile with profiling and -caf-all, even better
17:00:06 <hpc> i only ever use hoogle as a "reverse :t"
17:00:15 <FunctorSalad_> \
17:00:19 <FunctorSalad_> sorry
17:00:44 <FunctorSalad_> it will tell you the cost centers in scope at the point of error
17:01:11 <Phyx-> do haskell interface files contain *any* documentation at all? i know the internal AST of GHC after renaming still has haddock comments
17:01:17 <FunctorSalad_> (kinda like a stack trace, which we don't really have due to lazyness)
17:01:39 <Phyx-> FunctorSalad_: you can emulate stack traces
17:01:49 <randomwords> FunctorSalad_: Useful, thanks
17:02:13 <FunctorSalad_> you'll probably have to reinstall all the deps with profiling though
17:02:29 <randomwords> FunctorSalad_: I already profile a lot
17:02:33 <randomwords> FunctorSalad_: So it's all there
17:02:42 <FunctorSalad_> (I made a horribly contrived shell script that greps 'Perhaps' lines for that)
17:02:56 <FunctorSalad_> ('Perhaps you need to install the profiling library for ....' :D)
17:03:09 <randomwords> randomwords: that command is insanely useful and would have saved me hours and hours of time in the past
17:03:25 <Phyx-> hmm these numbers are quite dissappointing
17:03:29 <randomwords> FunctorSalad_: it's a shame cabal can't reinstall all deps with profiling, seems like it should be easy
17:03:54 <Phyx-> oh, the benchmark is wrong
17:04:08 <StaticShock> can i define a data type inside ghci?
17:04:38 <Phyx-> is there a tester for haskell that can mutate haskell files?
17:07:28 <etpace> @hoogle [a] -> a -> Maybe Int
17:07:28 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
17:07:29 <lambdabot> Data.ByteString findSubstring :: ByteString -> ByteString -> Maybe Int
17:07:29 <lambdabot> Data.ByteString.Char8 findSubstring :: ByteString -> ByteString -> Maybe Int
17:07:59 <StaticShock> @snack
17:08:00 * lambdabot smashes a lamp on  head
17:08:08 <medfly> :o
17:08:21 <medfly> lambdabot has officially lost it
17:08:27 <FunctorSalad_> uh, it matches @slap
17:08:35 <medfly> @botsnack
17:08:36 <lambdabot> :)
17:08:36 <FunctorSalad_> @trap medfly
17:08:37 <lambdabot> Maybe you meant: map slap
17:08:39 <FunctorSalad_> ;)
17:09:23 <FunctorSalad_> @where it
17:09:24 <lambdabot> I know nothing about it.
17:09:35 <Phyx-> medfly: she's been under alot of stress lately
17:09:45 <medfly> aww
17:10:16 <StaticShock> @hoogle \x -> [x]
17:10:17 <lambdabot> Parse error:
17:10:17 <lambdabot>   --count=20 "\x -> [x]"
17:10:17 <lambdabot>              ^
17:11:16 <StaticShock> medfly: thanks, i thought it was @snack. i forgot!
17:11:42 <FunctorSalad_> @where+ it In GHCI, the previously entered expression (or the result of executing it, in the IO case) can be referenced by the special variable `it'.
17:11:43 <lambdabot> It is forever etched in my memory.
17:11:46 <c_wraith> :t (:[])
17:11:47 <lambdabot> forall a. a -> [a]
17:12:08 <Phyx-> debugging this is gonna be such a pain in the ars
17:12:18 <FunctorSalad_> I often use ([]:) and get a confusing type error
17:12:40 <c_wraith> your robot monkey needs to be looking the correct direction to work
17:12:42 <medfly> upside down robot monkey
17:12:46 <FunctorSalad_> indeed
17:13:00 <Phyx-> guess not
17:13:06 <Phyx-> was simpler than i though ^_^
17:13:13 <Phyx-> changes_in_ghc--
17:13:14 <zygoloid> > ([]:) mempty
17:13:14 <lambdabot>   [[]]
17:13:45 <hpc> :t fix ([]:)
17:13:47 <lambdabot> forall a. [[a]]
17:13:53 <hpc> :t fix (:[])
17:13:55 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
17:13:55 <lambdabot>       Expected type: a
17:13:55 <lambdabot>       Inferred type: [a]
17:14:31 <medfly> I wonder. a robot monkey could be like a cute Haskell avatar.
17:15:19 <FunctorSalad_> that might work
17:16:35 <FunctorSalad_> fix ([]:) == cycle [[]]
17:16:38 <chrisdone> man who's the guy who keeps going on about fortran in this talk
17:16:41 <FunctorSalad_> or something
17:17:23 <sshc> For parsec, does (<*>) = (>>=)?
17:17:37 <FunctorSalad_> no, (<*>) = ap for monads in general
17:18:26 <FunctorSalad_> (hmm, actually I don't know if there's a law stating that this must be so)
17:19:02 <hpc> i sorta want to try to prove that law
17:19:36 <FunctorSalad_> well, if Applicative doesn't have laws mentioning Monad then you can't prove anything
17:19:48 <FunctorSalad_> (the instances could be unrelated)
17:20:00 <copumpkin> you could talk about it in terms of it being a lax monoidal functor vs. a monad
17:20:08 <copumpkin> and see if you can relate them in CT, which seems possible
17:22:17 <lispy1> copumpkin: I talked to Iavor
17:22:30 <kmc> the DPH talk chrisdone?
17:22:32 <kmc> it is pretty relevant
17:22:34 <lispy1> copumpkin: he said, his nick is yav when he's here
17:22:52 <copumpkin> lispy1, ah looks like he's connected but not in the channel
17:22:56 <copumpkin> lispy1: thanks :)
17:23:00 <lispy1> copumpkin: and that for the code you asked about, they were planning to use it here but then changed their mind
17:23:12 <copumpkin> :O
17:23:19 <lispy1> copumpkin: and he's not confident that it's a good implementation
17:23:23 <copumpkin> interesting, but I probably shouldn't ask for too many details :)
17:23:43 <lispy1> well you can ask.  If he can't tell you then he won't :)
17:23:55 <copumpkin> I'll try when he appears :) thanks!
17:24:25 <lispy1> He told me what they wanted to use it on and I already forgot :)
17:24:32 <copumpkin> lol
17:24:40 <copumpkin> I can only think of one practical use for it
17:24:57 <lispy1> What's that?  I'm completely unfamiliar with that algo
17:26:24 <copumpkin> well, it proves arbitrary things about addition on naturals
17:26:30 <copumpkin> and the main use of naturals in computers is array indexing
17:26:48 <copumpkin> so if you want to prove that your array accesses are safe, statically, so you can avoid runtime checks, etc.
17:27:12 <copumpkin> of course, you can't do multiplication between variables, so it's kind of limiting
17:27:30 <jmcarthur> what are you talking about?
17:27:40 <copumpkin> presburger arithmetic and cooper
17:27:50 <jmcarthur> okay i know nothing about this
17:27:52 <copumpkin> I'm actually reading a book about that right now :)
17:27:56 <copumpkin> it's fascinating
17:28:10 <copumpkin> decidable logical theories
17:28:25 <jmcarthur> ah
17:28:41 <lispy1> copumpkin: ah cool
17:30:49 <dom96> Does anyone know of any examples of using the json package? i can't figure out how to use it to read json
17:31:59 <ski> copumpkin : ".. and cooper" ?
17:32:49 * ski str the term "Cooper Storage" from somewhere ..
17:33:02 <dons> dom96: http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/json-0.4.4#direct
17:33:06 <dons> 36 direct libs use it
17:33:34 <burp> :t handle
17:33:35 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
17:33:39 <ski> (.. oh, linguistics <http://www.ling.ohio-state.edu/~pollard/cvg/natal.pdf>, "Cooper Storage - Cures the Common Cold", Carl Polland, 2008-06-25)
17:33:44 <copumpkin> ski: cooper's algorithm for deciding statements
17:33:45 <dom96> dons, thanks that should help.
17:33:52 <copumpkin> in presburger arithmetic
17:34:05 <burp> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Exception.html# ← this says handle :: Exception e => (e -> IO a) -> IO a -> IO a
17:34:17 <burp> but mine is "handle :: (Exception e) => (e -> IO a) -> IO a -> IO a"? o0
17:34:43 <ski> copumpkin : ok, haven't looked at any algorithms for that .. is "decidable logical theories" the title of the book ?
17:34:47 <FunctorSalad_> mmm pressburger
17:35:23 <ski> burp : what's the difference ?
17:35:41 <burp> um, there is none I should go to bed ;(
17:35:49 <copumpkin> ski: oh, I haven't reached the presburger section in the book yet so I don't know if they cover that one in particular (but the presburger package on hackage uses it). But the book I'm reading is "The Handbook of automated logical reasoning" and is the book that the code you linked me to the other day comes with
17:37:19 <burp> ski: MonadLib also has an "handle" for exceptions, but with arguments switched, like "catch" has it -- that was confusing me
17:37:57 <ski> copumpkin : ok
17:39:15 <ski> burp : i suppose neither has `Exception e => (e -> IO b) -> (a -> IO b) -> (IO a -> IO b)' (with any argument order), though .. :/
17:41:40 <tkahn6> is there a standard function that has this type signature? [(a -> b)] -> a -> [b]
17:41:54 <copumpkin> :t flip
17:41:55 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:41:55 <lispy1> tkahn6: hoogle!
17:41:56 <copumpkin> :t sequence
17:41:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:42:04 <lispy1> ?hoogle [(a -> b)] -> a -> [b]
17:42:04 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
17:42:04 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
17:42:04 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
17:42:10 <copumpkin> :t Data.Traversable.sequenceA
17:42:11 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
17:42:20 <copumpkin> wow, hoogle messed that one up
17:42:52 <lispy1> yeah, stupid hoogle
17:42:56 <tkahn6> i could write my own function, but i think this is something pretty standard
17:42:57 <copumpkin> tkahn6: I'd just go for \fs x -> fmap ($x) fs though
17:43:06 <copumpkin> tkahn6: yes, I just gave you three :)
17:43:08 <tkahn6> k
17:43:18 <tkahn6> oh
17:43:19 <tkahn6> haha
17:43:20 <copumpkin> > sequence [sin, cos, (+1)] 4
17:43:20 <lambdabot>   [-0.7568024953079282,-0.6536436208636119,5.0]
17:43:25 <Philonous> tkahn6: I'd go for <*> from Control.Applicative.
17:43:37 <tkahn6> sequence seems to be the best
17:43:38 <copumpkin> that doesn't do it
17:43:51 <copumpkin> > [sin, cos, (+1)] <*> [4]
17:43:52 <lambdabot>   [-0.7568024953079282,-0.6536436208636119,5.0]
17:44:06 <copumpkin> gotta purify the argument :)
17:44:16 <copumpkin> but Cale's flip has the lowest requirements
17:44:22 <copumpkin> > flip [sin, cos, (+1)] 4
17:44:23 <lambdabot>   [-0.7568024953079282,-0.6536436208636119,5.0]
17:44:32 <Philonous> copumpkin: yikes, right -.-
17:44:35 <tkahn6> what's the difference between sequence and flip?
17:44:55 <chrisdone> kmc: well I couldn't make out anything he was saying, all I took from it was the speaker being interrupted a lot. from what I gathered he was talking about specific mathematical optimisations special to fortran
17:45:10 <ski> `Caleskell.flip' is specialized to the `(a ->)' monad
17:45:12 <copumpkin> tkahn6: sequence is more general, and flip is a custom definition Cale made for lambdabot
17:45:31 <tkahn6> oh cool
17:45:33 * ski suggested it ..
17:45:33 <tkahn6> thanks for your help
17:45:45 <randomwords> I'm having an issue with glut such that whenever I call the reshape callback the screen renders black, anyone ecountered this before
17:46:20 <copumpkin> ski: ooh! okay, I'll give credit to you from now on :)
17:52:57 <ski> copumpkin : .. or debit, as some consider it ;)
17:53:05 <copumpkin> :)
17:53:07 <Phyx-> In[21]:= strictMean - nstrictMean
17:53:08 <Phyx-> Out[21]= 0.0784437s
17:53:24 <Phyx-> hmm guess making the fields strict did make it slower
17:53:27 <Phyx-> err
17:53:28 <Phyx-> faster
17:53:33 <Phyx-> waiit...
17:53:36 <Phyx-> slower
17:53:44 <FunctorSalad_> woha. why can I hSeek forwards over the end of the file without error?
17:54:11 <Phyx-> i thought you lot said making things strict makes it faster :P
17:54:17 <FunctorSalad_> (well, silly question, apparently it's the convention)
17:55:16 <Phyx-> both files were compiled with -o2
17:55:19 <Phyx-> -O2 *
17:55:29 <FunctorSalad_> hmm who said it always makes it faster?
17:55:33 <Phyx-> each test ran about 50x
17:55:58 <Phyx-> I can't remember who said it
17:56:00 <Phyx-> but someone did
17:56:29 <FunctorSalad_> I'm no expert, but... for example, a strict (++) would have to iterate over the whole left list rather than building a 'pipeline' as in the lazy case
17:57:04 <FunctorSalad_> (well, more than strict... forcing the whole list skeleton, just like it'd be done in a usual programming language)
17:57:42 <Phyx-> i don't think (++) is affected by strictness. 
17:57:54 <Phyx-> fusion takes place where ever it can
17:59:14 <FunctorSalad_> well, the 'very strict (++)' I mean doesn't exist, so we can't know whether it'd have fusion ;)
17:59:45 <FunctorSalad_> I meant plain linked list concatenation as it'd be done in an eagerly-evaluating language
17:59:58 <FunctorSalad_> is O(length(left list))
18:00:49 <Phyx-> which is what (++) is afaik. it always traversed the left tree to get to the const
18:00:52 <Phyx-> cons*
18:01:48 <FunctorSalad_> but just the first one, no?
18:01:56 <FunctorSalad_> actually iterating through the list is deferred
18:02:26 <FunctorSalad_> I'm aware of this left-nested (++) problem, but that's not as bad as O(length(left list)) I thought
18:02:38 <Phyx-> the first is also a list. so you're kinda confusing me
18:05:00 <FunctorSalad_> I mean "strictAppend [] ys = ys, strictAppend (x:xs) ys = let z = strictAppend xs ys in z `seq` x:z"
18:05:24 <FunctorSalad_> at least I think this is what  I mean :( I'm not that good at `seq`
18:06:05 <Cale> I'm not sure why you'd want to strictify (++)
18:06:15 <FunctorSalad_> you don't, that's the point of my example
18:06:28 <FunctorSalad_> (that strict can be slower even if the data is eventually used)
18:06:41 <FunctorSalad_> or I mean eager evaluation actually, I think
18:06:43 <napping> left nested appends are bad anyway
18:06:47 <napping> potentially quadradic
18:06:49 <Cale> Well, if the whole list is eventually used, it doesn't matter
18:06:57 <dolio> Yes it does.
18:06:59 <FunctorSalad_> napping: but not as bad as eager ones, no?
18:07:12 <napping> sure you only traverse the list once, but each element still has to go through several appends
18:07:14 <FunctorSalad_> Cale: the very strict (++) makes intermediate lists
18:07:30 <Cale> It affects latency, perhaps, and immediate memory consumption.
18:08:17 <Cale> But the number of steps should work out to about the same.
18:08:38 <Phyx-> 03:06:44 < FunctorSalad_> Cale: the very strict (++) makes intermediate lists
18:08:41 <dolio> Keeping a bunch of data in memory for later can easily result in worse performance than building it on-demand.
18:08:47 <dolio> Even if you use everything.
18:08:49 <Phyx-> I don't think that's a property of strictness
18:09:04 <Phyx-> haskell is single assignment, without fusion it'll always make intermediate lists
18:09:24 <Cale> Worse memory performance. Not really worse time performance.
18:09:36 <napping> unless the locality hurts
18:09:43 <dolio> Worse memory performance can easily cause worse time performance in my experience.
18:09:48 <Cale> There's no locality to speak of anywhere here.
18:09:49 <FunctorSalad_> I was conflating strictness and evaluation strategy... I think my point is about eager evaluation, not strictness
18:10:14 <napping> FunctorSalad_: even with fully lazy evaluation, each cons of each intermediate list will be produced
18:10:21 <Cale> Ultimately the number of reduction steps will be equal, provided you use the whole list.
18:10:24 <FunctorSalad_> maybe this is a better example: map h (map g (map f lst)))
18:10:27 <Phyx-> napping: that's not true
18:10:40 <hpc> :t (***)
18:10:40 <napping> ok, as long as the result is fully evaluated
18:10:41 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:10:42 <Phyx-> napping: when fully lazy (a ++ b ++ c) produces no intermediate lists
18:10:51 <FunctorSalad_> with a eagerly-evaluate-the-whole-list-skeleton map, that will allocate three full intermediate lists
18:10:51 <napping> a ++ (b ++ c), yes
18:11:07 <napping> well, it produces a copy of a and a copy of b
18:11:15 <napping> (a ++ b) ++ c will copy a twice and b once
18:11:34 <napping> now under lazy evaluation you'll never have all of (a ++ b) in memory at once
18:11:35 <Cale> FunctorSalad_: Assuming no fusion, it'll do 3 intermediate lists worth of allocation even under lazy evaluation.
18:11:44 <napping> but it will be made
18:11:48 <sshc> How do I convert a String to a lazy Word8 ByteString?
18:11:49 <Phyx-> napping: if fusion is properly applied, they won't be copied more than once, but fusion can only be applied when lazy, or that's when it makes sense
18:12:00 <sshc> S.pack takes a list of Word8's, not Char
18:12:01 <napping> Phyx-: fusion is a different story
18:12:03 <Cale> FunctorSalad_: But of course, with lazy evaluation, the difference is that much of that will be garbage immediately.
18:12:14 <napping> sshc: there's the Char8 bytestring
18:12:15 <Phyx-> napping: but it's part of the point i've been arguing with FunctorSalad_ 
18:12:25 <FunctorSalad_> Cale: hmm ok, but at least it won't have a full copy in memory at one time...
18:12:30 <napping> oh, well, who knows what will fuse
18:12:33 <Cale> Phyx-: I'm pretty sure that fusion makes sense even in a strict setting.
18:12:39 <napping> "map reverse and append vanish for free"
18:12:43 <FunctorSalad_> but ok, I was underestimating how many conses lazy evaluation makes, without fusion
18:12:51 <Cale> FunctorSalad_: Right, it affects space, not time.
18:13:17 <napping> and fusion rewrite rules are justified by the eventual semantics so they can apply anyways
18:13:21 <Cale> GHC's garbage collector is well-tuned for dealing with short-lived data.
18:13:22 <Phyx-> Cale: I don't really agree, in a strict setting (a++b)++c would perform worse than a ++ (b++c) because first a++b has to be created
18:13:40 <napping> In a lazy setting (a++b)++c performs worse than a++(b++c)
18:13:46 <Cale> Phyx-: I never said anything about that.
18:14:00 <FunctorSalad_> Phyx-: nevermind then, I was a bit confused (maybe the argument can be salvaged by appeal to locality or so ;))
18:14:20 <Cale> Phyx-: I was talking about the time performance of lazy xs ++ ys vs. strict xs ++ ys
18:14:25 <Phyx-> napping: I was refering to lazy + fusion vs strict + fusion
18:14:31 <sshc> napping: What do I need to import for parsec to word with Char8 bytestring?
18:14:32 <napping> hmm?
18:14:34 <napping> how can that fuse?
18:14:35 <Cale> Which is the same, provided that you use all the elements of the resulting list.
18:14:42 <napping> sshc: Data.ByteString.Char8
18:14:50 <napping> exports a lot of the same names
18:15:06 <napping> the strictness of a strict ++ and lazy ++ are of course different
18:15:18 <napping> and if you have a lazy language and only want a few results, the lazy append can give you that
18:15:26 <Cale> Phyx-: (xs ++ ys) ++ zs is always worse than xs ++ (ys ++ zs). I think we can agree on that :)
18:15:52 <napping> but it's still O(2k) to get k elements of xs out of (xs ++ ys)++zs, vs O(k) to get them from xs ++ ys ++ z
18:15:56 <FunctorSalad_> (hmm btw is (++) strict in the technical sense? (++) undefined = undefined)
18:16:01 <sshc> napping: When should I use Data.Bytestring.Lazy over Data.byteString.Lazy.Char8?
18:16:02 <Cale> O(2k) = O(k)
18:16:06 <FunctorSalad_> seems like it
18:16:10 <Phyx-> Cale: yeah
18:16:21 <Phyx-> Cale: I was wrong on that one :) i was thinking of something else
18:16:23 <napping> sshc: the Char8 stuff is okay if you know you just have ascii
18:16:36 <FunctorSalad_> (that's why I called the other one 'very strict' ;))
18:16:41 <sshc> napping: Yes, but when would it be appropriate to import the Word8 module instead?
18:16:46 <napping> for binary data
18:16:56 <napping> or maybe if you want to explicitly work with text encodings
18:17:01 <napping> (there's utf8 version somewhere)
18:17:34 <FunctorSalad_> strictAppend xs = undefined if there's an undefined anywhere in the list skeleton of xs, but (++) ('a':undefined) isn't undefined)
18:18:14 <ski> FunctorSalad_ : yeah, and `([] ++)' is also strict, but `((a:as) ++)' is not strict
18:19:22 <Phyx-> bbl, going to the movies
18:19:46 <Cale> sshc: The datatypes are actually the same in the two modules. The only difference is how they're being viewed. If you want to think of the ByteString as a sequence of ASCII characters, use the Char8 functions. If you want to think of it as a sequence of 8-bit numbers, then use the Word8 stuff.
18:20:01 <Cale> sshc: You can use both at once, if it suits you.
18:20:26 <sshc> Cale: Thanks.
18:21:20 <jmcarthur> ATTN all boston haskellers. i, jmcarthur, will be in boston next week, and i will desire the company of the coolest haskellers in the area for some portion of an evening
18:21:44 <EvanR> but what will you talk about :o
18:21:57 <FunctorSalad_> :D
18:22:12 <jmcarthur> we will obviously bring our laptops, join #haskell, and talk here
18:22:16 <dolio> I hear delimited continuations make good conversation in a pub.
18:22:17 <EvanR> lol
18:23:04 <FunctorSalad_> sshc: third option: Data.ByteString.UTF8 ;)
18:23:15 <FunctorSalad_> less evil than Char8 if there's any chance of utf8
18:23:46 <FunctorSalad_> (AFAIK what cale says still applies, the functions just interpret the bytes differently)
18:30:25 <EvanR> ah
18:30:42 <EvanR> i found a new way to get newbs to remain fearful in the face or compiler errors
18:30:47 <EvanR> of*
18:30:58 <FunctorSalad_> fearless?
18:31:04 <EvanR> oh right
18:31:05 <EvanR> lol
18:31:36 <EvanR> well heres the idea: on the lines that have errors replace significant portions of the expression with undefined
18:31:44 <EvanR> then it will compile
18:32:05 <EvanR> maybe that will make them fearful ;)
18:32:34 <chrisf> as far as 'fearful' goes, i think ghc's errors are scary enough already ;)
18:32:39 <FunctorSalad_> implicit params work similarly, and they even give you the types of the "holes"
18:34:04 <FunctorSalad_> is a "hGet h 1"/"hSeek h Relative (-2)" loop very bad?
18:34:17 <FunctorSalad_> to find the newline to the left of you
18:34:30 <FunctorSalad_> I thought it shouldn't be too bad if the handle is buffered
18:35:20 <FunctorSalad_> (using (-1) will give an infinite loop btw)
18:35:39 <Draconx> FunctorSalad_, seeking when you don't have to is bad, since it prevents you from operating on files that don't support seeking.
18:36:01 <FunctorSalad_> Draconx: ah, but the whole thing I'm doing relies on seeking anyway
18:36:32 <FunctorSalad_> (read a *uniformly* random line from a huge file...)
18:37:33 <FunctorSalad_> the lines may be of different length... my idea is to re-pick a line with probability 1 - 1/(length of line + 1)
18:37:52 <FunctorSalad_> that uniformifies it and avoids reading in the file to count lines
18:38:12 <FunctorSalad_> and it'll still take far less reading
18:39:44 <FunctorSalad_> so the full procedure is: 1. pick random byte offset 2. read the line you hit 3. goto 1 with or print the line, with the prob I just said
18:40:04 <FunctorSalad_> s/with or/or/
18:40:32 <Draconx> FunctorSalad_, uh, that doesn't give you a uniform distribution.
18:41:09 <Draconx> FunctorSalad_, consider a file that has 500 length 0 lines and one length 500 line.
18:43:55 <FunctorSalad_> Draconx: length 0 is handled by the fact that I count a newline char as part of the preceding line
18:44:26 <Draconx> FunctorSalad_, you still don't have a uniform distribution.
18:44:49 <FunctorSalad_> so you'll hit a given length 0 line with p=1/1001 and the length 500 line with p=501/1001, unless I'm mistaken
18:45:14 <Draconx> according to the probability you stated above, each length-1 line has a 1/2 chance of being selected.  So it isn't even a probability distribution, since it doesn't sum to 1.
18:46:11 <FunctorSalad_> the probabilities are just probabilities of re-picking
18:46:46 <FunctorSalad_> the actual probabilities of a line being the result aren't directly represented in the program
18:48:03 <FunctorSalad_> if you hit a length-zero line, you restart the program with p=0/1, for the length 500 line with p=500/501
18:50:33 <FunctorSalad_> I think one can build an "inductive" proof by assuming that the restarted instance implements a uniform distribution (the induction isn't well-founded, but the case where the argument is circular has probability zero ;))
18:50:51 <FunctorSalad_> (the case where the program doesn't terminate)
18:52:02 <FunctorSalad_> of course this isn't a real proof, just the picture I have in mind
18:56:59 <FunctorSalad_> Draconx: so in total... P(pick a given zero-length line in the first round)=1/1001 ; P(pick the length 500-line in the first round)=501/1001 * 1/501 = 1/1001
18:57:01 <Philonous> FunctorSalad_: If the file consist of one huge line you will be re-picking the same line over and over 
18:57:27 <FunctorSalad_> in all other cases, we restart the program; apply pseudo-inductive analytical argument
18:59:23 <FunctorSalad_> Philonous: yes, with an expected value of length(file) IIRC; but for natural examples (here: random word generation from a 630k word, one-line-per word dictionary) it should be very efficient
18:59:36 <FunctorSalad_> compared to reading the whole file to count the number of lines
19:00:18 <FunctorSalad_> e.g. if all the words have length 9, I'll have an expectation of 10 restarts
19:05:08 <Philonous> FunctorSalad_: How much worse is seeking backward than seeking forward? Because you could just seek to the next newline instead of the previous one, count the number of steps and assume that this is half of the line length (and associate the length of the previous line with the probability of the next, obviously )
19:06:27 <Philonous> On hitting eof you start from the beginning
19:07:36 <FunctorSalad_> Philonous: I have no idea about seeking backward :) but I thought a buffered handle will load a block into memory that's likely to contain the newline anyway
19:07:51 <FunctorSalad_> and for an array in memory backward is no problem...
19:08:29 <FunctorSalad_> not sure if the block will extend backwards after you move out of it to the left though
19:08:33 <Philonous> True. It'd still save you the seeking alltogether. You could just keep chars coming. 
19:09:10 <FunctorSalad_> (except the jump of course)
19:10:45 <EvanR> does it make sense to store the Int key in a data mainly to be stored in an IntMap 
19:11:04 <EvanR> or is there some more obvious way of keeping track of the key
19:11:20 <FunctorSalad_> what you said sounds clever :) the line length won't be known for certain, but the errors should cancel out...
19:11:54 <Two72> it looks like GHC's IO library flushes the buffer if the seek is negative
19:12:08 <jmcarthur> EvanR: i don't understand the question. can you provide some context?
19:13:21 <FunctorSalad_> Two72: oh. What is the buffer replaced with then?
19:13:36 <EvanR> game pieces are in an IntMap keyed by their Int key, i often want to know their key
19:13:40 <Two72> it's reread from disk, I guess
19:14:02 <EvanR> is having the key in the data type redundant
19:14:12 <jmcarthur> nah
19:14:19 <EvanR> ah
19:14:34 <FunctorSalad_> hmm that doesn't sound good, I hoped it'd seek back half a block size or something, so the new buffer would have the current position centered
19:14:43 <jmcarthur> EvanR: in fact, i would say that the data structure should be only the key and you should query the IntMap for its attributes :)
19:14:49 <FunctorSalad_> (or even seek back a full block if we're moving leftwards)
19:15:20 <EvanR> jmcarthur: seems like im going to be using the key to lookup specific pieces at some point
19:15:28 <jmcarthur> EvanR: then you can divide that map into separate things for separate attributes, and you are getting close to "data driven" game architecture
19:16:48 <EvanR> dont think i have externally accessible attributes at this point
19:17:25 <jmcarthur> EvanR: what i'm talking about: http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/
19:17:37 <jmcarthur> the basic idea is that the game world is a database, essentially
19:18:20 <EvanR> well that would be nice if any one of my record fields were a simple single data value ;)
19:18:31 <jmcarthur> EvanR: of course it would be silly to say it's a one size fits all solution
19:18:45 <EvanR> theres a function over here and an infinite list over there
19:19:01 <jmcarthur> doesn't mean it can't be structured like a database though
19:19:15 <EvanR> well i cant search for functions or anything
19:19:16 <jmcarthur> i'm not saying you use an *actual* database (although the article i linked to does in this case)
19:19:24 <jmcarthur> you don't need to
19:20:01 <jmcarthur> the article series is very good, despite being unfinished. it's a good read even if you don't plan to try data driven architecture just for the mind expanding
19:20:13 <EvanR> i see
19:20:40 <EvanR> and i see how its relevant for an MMO, which is a very data centric program, once you get past the simple mechanics of the game ;)
19:21:11 * hackagebot system-filepath 0.1.1 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.1.1 (JohnMillikin)
19:21:15 <EvanR> s/simple/low-level/
19:21:28 <EvanR> movement, animation, collision
19:22:03 <EvanR> the other thing is IntMap... a set of IntMap seems like a sorry database
19:22:29 <jmcarthur> broaden your definition of database a bit ;)
19:23:12 <EvanR> should i broaden by definition of data
19:23:19 <jmcarthur> it makes sense for a lot of games, actually
19:23:40 <jmcarthur> i don't know about trivially simple games though
19:23:51 <jmcarthur> but probably many "realistic" games
19:23:54 <EvanR> well im trying!
19:24:00 <EvanR> avoid realism at all cost
19:24:00 <jmcarthur> and definitely once you scale up
19:24:09 <jmcarthur> i don't mean graphical or physics realism
19:24:27 <jmcarthur> i mean "complex enough to be commercially viable"
19:25:08 <EvanR> thats what i meant too ;)
19:25:09 <jmcarthur> which i guess doesn't even have to be that complex, especially if you are a minimalist :)
19:25:37 <monochrom> http://xkcd.com/772/
19:25:57 <jmcarthur> monochrom: i actually think that would make a fun game :)
19:26:05 <monochrom> hehe
19:26:08 <jmcarthur> using the burnout engine, of course
19:28:46 <dbelange> lol xkcd
19:29:00 <dbelange> that man has really got his finger on the pulse of popular culture
19:29:06 <dbelange> what with the frogger references and all
19:30:19 <BMeph> EvanR: You know, lists are isomorphic to functions (with a Natural domain)... ;)
19:30:19 <EvanR> oh yeah hes super
19:30:29 <sshc> > repeat (*3) <*> [1, 2, 3]
19:30:29 <luite> are there happstack devs here?
19:30:30 <lambdabot>   [3,6,9,3,6,9,3,6,9,3,6,9,3,6,9,3,6,9,3,6,9,3,6,9,3,6,9,3,6,9,3,6,9,3,6,9,3,...
19:30:47 <sshc> Is there a way to shorten the lists so that the shortest one is used?
19:30:58 <sshc> WHat's the best way to do that with <*>?
19:31:38 <EvanR> BMeph: yeah and legos can run brainfuck ;)
19:32:37 <BMeph> EvanR: They CAN! And it's AWESOME!!! >;)
19:33:05 <sshc> Ah, <*> is defined as ap.
19:35:41 <dolio> Streams are isomorphic to Nat -> T.
19:36:13 <dolio> Lists are isomorphic to something more like (exists n. Fin n -> T).
19:36:20 <dolio> Fin n being the finite set of size n.
19:36:44 <luite> > zipWith ($) (repeat (*3)) [1,2,3]  -- did you mean this sshc 
19:36:44 <lambdabot>   [3,6,9]
19:37:29 <dobblego> > getZipList (ZipList (repeat (*3)) <*> ZipList [1, 2, 3])
19:37:29 <lambdabot>   [3,6,9]
19:37:41 <sshc> luite: Yeah, but I already thought of that :)
19:38:14 <luite> ok, go for the ZipList solution then, it's more l33t :p
19:38:49 <sshc> Does the "infix" line typically come before or after the definition?
19:39:28 <EvanR> use a zipper of iteratees of arrows of topless data
19:40:04 <sshc> I prefer readable code over WTF code, thanks :P
19:40:09 <EvanR> lol
19:40:38 <dobblego> ZipList is just a different Applicative instance to []
19:41:08 <sshc> dobblego: I wasn't aware of that.  Thanks.
19:41:16 <sshc> dobblego: In which module is it contained?
19:41:17 <dobblego> @src ZipList
19:41:17 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:41:35 <dobblego> Control.Applicative
19:41:51 <sshc> Does the "infix" line typically come before or after the definition?
19:42:20 <dolio> People typically put it before.
19:42:38 <sshc> je'eki'e
19:42:45 <luite> > getZipList (pure (*3) <*> ZipList [1, 2, 3]) -- using pure instead of repead and the ZipList constructor is even better of course, since it's less easy to see what's going on
19:42:46 <lambdabot>   [3,6,9]
19:42:52 <luite> repeat
19:43:30 <BMeph> dolio: Sorry, I mistyped. I should have told EvanR, "'infinte lists' are isomorphic to streams, which are isomorphic to functions with a Natural domain." -- better? ;þ
19:43:41 <dolio> Yes.
19:43:56 <dobblego> and then pure f <*> k is better written f <$> k
19:43:56 <EvanR> yeah yeah
19:44:17 <EvanR> finite, infinite, whatever
19:45:34 <luite> dobblego: and then you don't need the ZipList and getZipList anymore
19:45:49 <dobblego> luite, right, so I'm wondering what the point of this is
19:45:51 <dolio> I suppose if you want finite-and-infinite lists, mine doesn't work, either. You need (exists (n : Nat+). Sized n -> T)
19:46:06 <dolio> Nat+ being the extended natural numbers.
19:46:17 <luite> dobblego: yeah it seems to make the code simpler in the end, that can't be good
19:47:06 <dolio> And Sized n being the finite set of size n when n is a natural, and the naturals when n is infinity, or whatever you want to call it.
19:47:17 <Apocalisp> dobblego: Remember, the zippy applicative implies an additional law.
19:47:23 <sshc_> Is there an infixr of <*> defined, or do I need to define it myself?
19:48:07 <sshc_> lui	[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B\nick sshc
19:48:07 <sshc_> lui	u.u'i
19:48:33 <luite> it's in Control.Applicative, infixl
19:49:29 <sshc_> lu	If it's infir			, it's not infixr
19:50:26 <luite> I'm not sure if you can redefine the fixity of some operator, I've never done it at least :)
19:53:47 <tolkad> Is it true GHC implements first-class functions using C long jumps?
19:55:33 <Cale> tolkad: I don't know much about compilation via C...
19:55:53 <Axman6> tolkad: GHC doesn't use C by default any more
19:55:55 <Cale> tolkad: But unless you're compiling with -fvia-C the native code generator will be used.
19:57:11 <tolkad> will -fvia-C make mah codes faster? 'cus it's C?
19:57:21 <luite> usually not
19:57:51 <tolkad> so haskell is faster than C?
19:58:08 <luite> in some cases it might be, the ghc code generator for fpu code is said to be bad, so it can help to compile via C
20:00:27 <Gracenotes> tolkad: it uses a sort of trampoline structure, and I believe it shortcircuits this with assembly jumps where possible, which are probably better than long jumps?
20:01:40 <AnAdorableNick> tolkad: One of Haskell's strong points for performance is parallelism
20:02:21 <koninkje> tolkad: GHC uses the same basic compilation strategy regardless of the backend, so -fvia-C, -fasm, and -fllvm can only be so different
20:02:59 <koninkje> I.e., because the RTS works the same regardless, performance should be in the same general ballpark
20:03:25 <koninkje> That said, historically you always wanted to use -fvia-C if doing heavy floating point computations
20:03:39 <luite> AnAdorableNick: hehe people have been saying that for a long time, usually with the qualification that you nead the latest GHC HEAD to get actually good performance :)
20:03:59 <koninkje> I think the native code genrator for floating point has gotten better in 6.12
20:04:18 <luite> for some reason the GHC HEAD requirement never changes, even major releases
20:04:42 <tolkad> Why is compilation so fast? I want it to do very heavy optimization which should take huge computational resources but I can't seem to find an option to enable this
20:05:00 <luite> tolkad: -fforce-recomp possibly
20:05:12 <koninkje> you can use -O2, but that's not going to make it take forever...
20:05:31 <Gracenotes> tolkad: well, it won't skimp on any optimizations you request I don't think, but plenty of them are actually done at linking time..
20:05:37 <tolkad> I'm going to use -O9001
20:06:09 <luite> tolkad: you can also wrap ghc in a shell script that pauses for a few seconds after compiling
20:06:14 <tolkad> : /
20:06:47 * ski . o O ( ISO 9001 )
20:07:05 <tolkad> no, I'm saying I want to be able to specify how much computational resources should be devoted to optimization
20:07:12 <Gracenotes> > 9001 > 9000
20:07:13 <lambdabot>   True
20:07:18 <luite> tolkad: there are some tweaks in the ghc manual, that might result in better performance, like some thresholds for inlining things. they may increase compilation time if you set them much higher, if that's what you're after
20:07:20 <koninkje> N.B. -O3 isn't "safe" and can result in slower code than -O2 for some programs
20:07:40 <tolkad> koninkje: I didn't use -O3, I used -O9001
20:07:47 <koninkje> just saying
20:08:09 <tolkad> that's 8998 more Os
20:11:29 <tolkad> What does it do for each additional O?
20:12:11 <zzing> Greetings
20:12:56 <tolkad> there is an intruder in this channel
20:13:00 <tolkad> sound the alarms
20:13:51 <zzing> If I wanted to see about rendering a space scene (say a planet, star, etc.), what might be a logic approach for me to take? I apologize for the really really general question, but I am unsure where to start — I just have an idea of the end product.
20:14:21 <tolkad> zzing: Do you know OpenGL?
20:14:31 <zzing> tolkad: I did opengl 10 years ago
20:15:02 <tolkad> zzing: http://www.haskell.org/haskellwiki/Opengl
20:15:40 <zzing> Is opengl the fastest way to get started?
20:16:06 <zzing> I assume rendering it myself is not a good approach, but there may be other packages that do a visualization that could be adapted.
20:25:08 <sshc> luite: Does GHC HEAD use "threaded" and actually uses multiple cores by default?
20:26:07 <luite> not sure, but you can change the default rts options by linking in an extra object file with some symbol
20:26:37 <luite> and you don't need to specity the number of cores anymore, I think it's just -N and it will autodetect
20:28:12 <sshc> luite: I'm asking whether GHC HEAD usis -N by default
20:43:30 <jmcarthur> sshc: if it does i would be a happy haskeller
21:23:44 * hackagebot improve 0.0.3 - An imperative, verifiable programming language for embedded applications.  http://hackage.haskell.org/package/improve-0.0.3 (TomHawkins)
21:54:12 <bos> preflex: seen dons
21:54:12 <preflex>  dons was last seen on #haskell 4 hours, 21 minutes and 5 seconds ago, saying: 36 direct libs use it
22:13:05 <sshc> How do I cause a parser to fail?
22:13:31 <sshc> Specifically, I'd like a Parser (Maybe a) to be a Parsec a that fails with Nothing.  How do I do this?
22:14:05 <dolio> I don't think I understand your question.
22:14:10 <dolio> What does "fails with Nothing" mean?
22:16:20 <sshc> dolio: If a have a parser of type Parse (Maybe a), how do I create a parser that tries that parser, and if it returns Just a, the parser returns a, but the other parser returns Nothing, the parser fails.
22:17:04 <dolio> Oh, okay.
22:17:19 <dolio> Well, there should be a parse failure primitive.
22:18:08 <sshc> dolio: I'm using Parsec
22:18:27 <dolio> ParsecT is an instance of MonadPlus, so mzero is failure.
22:19:04 <catenate> It looks like testing whether (2^(n-1) :: Int) < 0 is a reasonably efficient way to test whether the machine's native integer size is n bits.  It returns True only for n=64 on a 64-bit machine (I tested n=8,16,32,64,128,256).  Am I thinking right on this?
22:19:05 <dolio> There's also parserFail, which takes a string.
22:19:32 <dolio> Which is probably the same as fail.
22:20:01 <sshc> dolio: I'm trying to think of an elegant way to transform this parser as I've described
22:20:37 <sshc> (Parser (maybe a) -> Parser a)
22:21:15 <dolio> catenate: If you can assume that every machine you run on will be twos complement, and overflow the right way, then yes.
22:22:00 <dolio> @type \m -> m >>= maybe mzero return
22:22:01 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m (Maybe a) -> m a
22:23:10 <catenate> Any major CPU architectures not twos complement?  Intel/AMD, PPC, MIPS, Atom, other cell phone chips, Apple's chips?
22:23:32 <catenate> current ones
22:23:51 <sshc> dolio: Brilliant!  Thanks!
22:24:19 <dolio> catenate: Not that I know of. But I'm no CPU enthusiast.
22:25:43 <Heffalump> all significant current architectures are two's complement
22:25:59 <catenate> Wikipedia sez: This numeric representation system was common in older computers; the PDP-1, CDC 160A and UNIVAC 1100/2200 series, among many others, used ones'-complement arithmetic.
22:26:34 <Wooga> is using case for extracting values from types like Maybe is a good idea? 
22:26:41 <Wooga> like case Just 3 of (Just num)  -> num
22:27:33 <catenate> Great! Thanks.  I'll add it to my bag of tricks.
22:28:00 <gwern> I remember one funny comment in the x11 binding
22:28:09 <gwern> 'this will not work on architectures where a byte != 8 bits'
22:28:16 <gwern> blew my mind
22:28:43 <Heffalump> Wooga: yes, that's fairly standard.
22:28:55 <Heffalump> Though in the specific case of Maybe you could use fromJust, maybe, or fromMaybe
22:29:15 <Wooga> Heffalump: thank you!
22:29:49 <Saizan> a case with only a Just alternative as well as fromJust are going to get you in trouble later (fromJust more so), unless you can prove they are safe.
22:30:00 <Saizan> s/are safe/will match/
22:30:27 <kmc> Wooga, but you should have a Nothing alternative too.  you'll get a warning if you don't, at least with -Wall
22:30:42 <kmc> much of the point of pattern matching is that we can check if a set of patterns is exhaustive
22:31:19 <kmc> one's complement is fun
22:31:24 <kmc> because you have positive and negative zero
22:31:25 <gwern> hm, I wonder if fromJust should throw a warning as well; it's as dangerous as omitting a Nothing match, isn't it? but omission generates a -Wall warning and fromJust doesn't
22:31:37 <kmc> yeah
22:32:02 <gwern> but then, we don't have a {-# WALL_WARN 'using fromJust means missing a case!' #-} pragma - just DEPRECATE or whatever
22:32:14 <kmc> we should have that pragma prolly
22:32:28 <kmc> though the line is kinda blurry
22:32:39 <gwern> actually, that could be useful. use it for unsafe* etc.
22:32:44 <kmc> some functions throw only in obscure disallowed corner cases
22:32:47 <kmc> should they also be marked unsafe?
22:32:55 <jmcarthur> i would be super annoyed if unsafe functions threw warnings
22:32:57 <catenate> gwern: Wikipedia sez: Historically, a byte was the number of bits (typically 5, 6, 7, 8, 9, or 16) used to encode a single character of text in a computer. .... Historical IETF documents cite varying examples of byte sizes. RFC 608 mentions byte sizes for FTP hosts (the FTP-BYTE-SIZE attribute in host tables for the ARPANET) to be 36 bits for PDP-10 computers and 32 bits for IBM 360 systems.
22:33:30 <jmcarthur> it already says unsafe. i was forced to realize this as i typed it
22:33:33 <gwern> catenate: yeah, after I looked it up I understood. my mind was still blown that byte was ever not 8 bits. it'd be kind of like finding out that there used to be a number between 2 and 3
22:33:47 <catenate> e
22:34:21 <Saizan> it's a more mundane fact like finding out there are different base systems
22:34:22 <jmcarthur> gwern: ha
22:34:23 <EvanR> kmc: every php function fails in obscure undocumented corner cases, the entire language should be labled unsafe
22:34:33 <gwern> 'before the Julian calendar modernization, the number currently known as 3 was actually 4, and the current @ symbol used to denote 3'
22:34:51 <catenate> & used to be between Y and Z as a letter
22:34:57 <gwern> what
22:35:11 <jmcarthur> lol
22:35:36 <jmcarthur> a b c d e f g h i j k l m n o p q r s t u v w x y and z
22:35:46 <gwern> or maybe 'warning: this function assumes that there are no true contradictions'
22:35:48 <EvanR> so if it fails in normal cases then what
22:35:48 <jmcarthur> now i know my a b cs
22:35:50 <EvanR> its not unsafe?
22:35:53 <EvanR> head, tail
22:36:02 <gwern> hold on, I thought tail was safe
22:36:07 <gwern> :type tail
22:36:09 <jmcarthur> > tail []
22:36:10 <c_wraith> > tal []
22:36:10 <lambdabot>   *Exception: Prelude.tail: empty list
22:36:11 <lambdabot>   Not in scope: `tal'
22:36:13 <jmcarthur> it's partial
22:36:14 <c_wraith> I can't spell
22:36:16 <jmcarthur> not unsafe
22:36:25 <gwern> @hoogle tail
22:36:26 <lambdabot> Prelude tail :: [a] -> [a]
22:36:26 <lambdabot> Data.ByteString tail :: ByteString -> ByteString
22:36:26 <lambdabot> Data.List tail :: [a] -> [a]
22:36:45 <gwern> @src tail
22:36:46 <lambdabot> tail (_:xs) = xs
22:36:46 <lambdabot> tail []     = undefined
22:37:09 <gwern> why isn't tail equivalent to drop 1?
22:37:13 <Saizan> EvanR: head and tail don't break a fundamental property of the language when their pre-conditions are not met
22:37:27 <kmc> i think byte effectively means 8 bits, at least today
22:37:33 <kmc> but "machine word" is an architecture-dependent idea
22:37:34 <jmcarthur> > take 1 []
22:37:35 <lambdabot>   []
22:37:35 <EvanR> is that what safe means?
22:37:41 <gwern> > drop 1
22:37:42 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
22:37:42 <lambdabot>    arising from a use ...
22:37:43 <gwern> > drop 1 []
22:37:44 <lambdabot>   []
22:37:52 <jmcarthur> EvanR: safe means the types don't lie, basically
22:37:52 <kmc> and lots of machines had words not a multiple of 8 bits
22:38:01 <catenate> wikipedia sez: Similarly, & was regarded as the 27th letter of the English alphabet, as used by children (in the USA). An example may be seen in M. B. Moore's 1863 book The Dixie Primer, for the Little Folks. In her 1859 novel Adam Bede, George Eliot refers to this when she makes Jacob Storey say, "He thought it [Z] had only been put to finish off th' alphabet like; though ampusand would ha' done as well, for what he could see."
22:38:15 <jmcarthur> EvanR: and _|_ is a member of every type
22:38:15 <kmc> jmcarthur, i dispute your claim that lack of side-effects is part of the type system
22:38:40 <kmc> if so then it's implied by every type
22:38:42 <EvanR> catenate is exploding my brain
22:38:48 <jmcarthur> kmc: when did i say that?
22:38:54 <kmc> "safe means the types don't lie"
22:38:59 <kmc> contrasting unsafePerformIO i thought
22:39:14 <c_wraith> the types don't like in unsafePerformIO
22:39:17 <c_wraith> err, *lie
22:39:38 <jmcarthur> unsafePerformIO can be used to make the types lie (unsafeCoerce, for example)
22:39:40 <c_wraith> oh, wtf.
22:39:48 <c_wraith> total brain failure.  I meant unsafeInterleaveIO
22:39:58 <jmcarthur> yeah, that function is perhaps mislabelled
22:39:59 <c_wraith> That's unsafe semantically, but not at the type-system level
22:40:04 <EvanR> unsafeInterformIO
22:40:08 <kmc> the types don't lie in unsafePerformIO
22:40:12 <jmcarthur> how is it semantically unsafe?
22:40:16 <kmc> except in that you can write unsafeCoerce with it
22:40:22 <kmc> but only for specific reasons
22:40:33 <catenate> EvanR: There are more things in heaven and earth than are dreamt in your philosophy, and everything is convention.  Pi should be Tau, and the width of the solid rocket boosters was determined by how wide roman chariot wheels had to be to be stable when pulled by two horses.
22:40:35 <jmcarthur> kmc: the point is that it's a way to circumvent the type system
22:40:43 <jmcarthur> beyond simply dropping the "IO" part
22:40:44 <kmc> only if you have IORef available
22:40:45 <jmcarthur> even
22:40:49 <kmc> or similar
22:40:56 <c_wraith> unsafeInterleaveIO is semantically unsafe because it replaces determinism with nondeterminism.
22:41:14 <jmcarthur> c_wraith: it's still RT isn't it?
22:41:18 <kmc> i think if you require unsafePerformIO to have a monomorphic return type
22:41:22 <jmcarthur> at least by the usual hand-wavy definition
22:41:23 <kmc> then it's type-safe
22:41:34 <c_wraith> Yeah, it's only polymorphic IORefs that cause the problem
22:41:47 <kmc> (presumably polymorphic MVars and other similar things are likewise a problem)
22:42:00 <jmcarthur> i find that agreeable, but as things stand it's unsafe
22:42:13 <kmc> as an aside, is there a way to force a function to have a monomorphic return type without saying which?
22:42:17 <dolio> Any polymorphic mutable reference.
22:42:19 <c_wraith> well, yes.  polymorphic reference types.
22:43:20 <jmcarthur> i guess RT is not required for safety
22:43:31 <kmc> not for type safety anyway
22:43:35 <Saizan> kmc: it'd be quite hard to make up something that can't be circumvented with a newtype
22:43:35 <jmcarthur> yeah
22:43:54 <kmc> though "type safety" sometimes means something more general
22:43:58 <kmc> "well-typed programs don't go wrong"
22:43:59 <Draconx|Laptop> Saizan, we could add the value restriction to Haskell! :)
22:44:09 <Saizan> Draconx|Laptop: yay!
22:44:12 <kmc> haha
22:44:14 <kmc> please don't ;P
22:47:48 <tolkad> Why is this incredibly slow?
22:47:51 <tolkad> fibonacci 1 = 1
22:47:51 <tolkad> fibonacci 2 = 1
22:47:51 <tolkad> fibonacci n = fibonacci (n - 1) + fibonacci (n - 2) 
22:47:51 <tolkad> fibonacciSeq = seqBuilder fibonacci 1
22:47:51 <tolkad> 	where seqBuilder f n = f n : seqBuilder f (n + 1)
22:48:48 <tolkad> I'm sure it's running in O(2^n) or something crazy like that
22:50:02 <c_wraith> actually, it's O(fib(n))
22:50:09 * lispy was about to say that
22:50:31 <kmc> tolkad, the result of one call to «fibonacci n» is not cached for a later call
22:50:33 <c_wraith> If you want an efficient list of fibonacci numbers, use laziness
22:50:37 <kmc> if you want to do that, look at data-memocombinators
22:50:44 <tolkad> kmc: I thought it would be : (
22:50:49 <kmc> tolkad, why did you think that?
22:50:50 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) -- memoized version
22:50:50 <tolkad> oh well, I can rewrite it
22:50:50 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:51:00 <tolkad> kmc: I thought GHC would be cool like that
22:51:03 <kmc> > fix ((0:).scanl (+) 1)
22:51:04 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:51:12 <kmc> ah
22:51:15 <c_wraith> "what to memoize" is an intractable problem for a compiler.
22:51:20 <kmc> the old "Haskell seems capable of arbitrary magic" problem
22:51:31 <EvanR> its not?
22:51:44 <lispy> ?faq Can Haskell do arbitrary magic?
22:51:44 <lambdabot> The answer is: Yes! Haskell can do that.
22:51:51 <EvanR> ah, just checking 
22:51:53 <Draconx|Laptop> @faq Can Haskell programs decide if a given turing machine halts on a given input?
22:51:53 <lambdabot> The answer is: Yes! Haskell can do that.
22:51:54 <tolkad> I knew it
22:52:09 <EvanR> haskell is an implementation of a hypercomputer 
22:53:22 <EvanR> :t fmap
22:53:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:53:27 <c_wraith> yeah.  My favorite observation about naive recursive fibonacci is that when you look at the call graph, all the leafs are 1, and all the interior nodes are (+).  That means calculating fib(n) requires fib(n) - 1 additions.  Of course, additions aren't quite O(1), so the timing is slightly complicated by that.
22:53:29 <EvanR> :t <$>
22:53:30 <lambdabot> parse error on input `<$>'
22:53:37 <EvanR> :t (<$>)
22:53:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:54:03 <tolkad> fibonacciBuilder a b = let c = a + b in c : fibonacciBuilder b c
22:54:03 <tolkad> fibonacciSeq = 1 : (1 : fibonacciBuilder 1 1)
22:54:06 <tolkad> runs much faster
22:54:41 <c_wraith> > let fibs = 0 : 1 : zipwith (+) fibs (tail fibs) in fibs
22:54:41 <lambdabot>   Not in scope: `zipwith'
22:54:48 <c_wraith> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
22:54:49 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:55:07 <c_wraith> That's probably the easiest of the fib list definitions
22:55:29 <EvanR> whats the monad library function equivalent to return . f . g ?
22:55:30 <Veinor> does it memoize?
22:55:39 <tolkad> I don't think you are going to be able to make a more efficient implementation than the one I just gave, without caching values or using your own implementation of +
22:55:51 <Veinor> tolkad: you can calculate fibonacci numbers faster than the naive definition
22:56:06 <c_wraith> tolkad, the one I offered isn't any slower than yours, and is certainly simpler.
22:56:17 * BMeph is SOOOOOO tempted to say, "What part of 'lazy' means 'it doesn't do work you don't make it do?' don't you understand?!?!??!" ... but he won't. ;)
22:56:44 <EvanR> @hoogle (a -> b) -> (c -> m a) -> m b
22:56:45 <lambdabot> No results found
22:56:48 <lispy> tolkad: you can give a better fib using matricies
22:56:52 <lispy> without caching
22:57:10 <c_wraith> EvanR, that type isn't implementable
22:57:23 <EvanR> hold on
22:57:32 <EvanR> @hoogle (a -> b) -> (c -> m a) -> (c -> m b)
22:57:33 <lambdabot> Language.Haskell.TH.Quote dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (b -> Maybe (Q q)) -> a -> Q q
22:57:50 <tolkad> they should just change the haskell standard to say that all implementations have to optimize everything perfectly
22:58:14 <tolkad> then I could write haskell however I like and if people complain I can tell them to get a standards-compliant compiler
22:58:49 <tolkad> and they'll be all like "oh you got me there my bad" and I'll be like yeah
22:58:50 <lispy> right now you can just tell them to get ghc
22:58:55 <ozamosi> Yeah, I mean, why isn't ghc capable of arbitrary magic? It would be a really useful feature!
22:59:20 <EvanR> perl is fairly arbitrary
22:59:26 <BMeph> :ty (liftM.)
22:59:30 <EvanR> maybe it can handle this problem
22:59:31 <BMeph> :t (liftM.)
22:59:32 <lambdabot> forall a1 r (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f (a1 -> r) -> f (m a1 -> m r)
22:59:36 <EvanR> ah liftM
23:00:01 <Saizan> ?type (.) . liftM
23:00:02 <lambdabot> forall (f :: * -> *) a1 r (m :: * -> *). (Functor f, Monad m) => (a1 -> r) -> f (m a1) -> f (m r)
23:00:06 * BMeph facepalms...
23:00:15 <BMeph> :t (liftM Prelude..)
23:00:16 <lambdabot> forall a1 r (m :: * -> *) a. (Monad m) => (a -> a1 -> r) -> a -> m a1 -> m r
23:01:23 <EvanR> x <- f `liftM` action
23:01:34 * BMeph defers to Saizan's pl-fu.
23:02:35 <EvanR> xs <- concat `liftM` forM ...
23:02:43 <Saizan> @pl \f g x -> f `liftM` g x
23:02:43 <lambdabot> (.) . fmap
23:03:00 <tkahn6> what does @pl do?
23:03:26 <Saizan> elminates explicit arguments by using combinators
23:03:33 <tkahn6> oh that's cool
23:04:11 * BMeph irrationally despises languages whose only specification is an implementation -- it feels like a "practical" programmer trying to be pretentious...
23:05:14 <pikhq> BMeph: You mean the ones where "Yeah, behavior is defined by the implementation" or someone actually labeling an implementation as the language spec?
23:05:31 <BMeph> pikhq: Genau da.
23:05:48 <pikhq> ???
23:05:48 <BMeph> pikhq: Er, "Got it in one." :)
23:06:13 <tkahn6> what language is that BMeph
23:06:14 <tkahn6> ?
23:06:18 <pikhq> そりゃ日本語っぽい、けど分からない。……説明してくれ。
23:06:32 <pikhq> (that seems like Japanese, but I don't understand it. Please explain.)
23:06:47 <EvanR> i got all question marks, are you using utf8?
23:06:55 <pikhq> Yes, of course I am.
23:07:01 <EvanR> gah slackware might still not come with japanese fonts >_<
23:07:11 <pikhq> Why would anyone *not* use UTF8? :P
23:07:17 <EvanR> pikhq: today at work....
23:07:46 <EvanR> we found that PHP's exec operation temporarily switches the local to something like ansi-82934-1967
23:07:51 <EvanR> locale
23:07:53 <tensorpudding> ellipses look less pretty when compacted
23:08:00 <xcthulhu> pikhq, Um, if you have to write stuff on punched cards?
23:08:02 <c_wraith> pikhq, that's japanese, but it doesn't really look well-formed.
23:08:20 <pikhq> tensorpudding: Yeah, well, that's correct.
23:08:26 <pikhq> c_wraith: Mmm.
23:08:31 <c_wraith> Or else it's a transcription of really-informal speech, which is nearly the same to me. :)
23:08:31 <xcthulhu> Or languages with backward compatibility support for punched cards like Fortran?
23:08:44 <c_wraith> It's something about japanese (language) and money.
23:08:44 <pikhq> xcthulhu: No excuse.
23:09:06 <pikhq> c_wraith: What, you mean my Japanese there? Or his?
23:09:32 <c_wraith> pikhq, what you pasted
23:09:43 <pikhq> c_wraith: ... Pasted? I did not paste it.
23:09:52 <c_wraith> err, typed, then. :)
23:10:23 <pikhq> c_wraith: Here, lemme put it into less-informal: それは日本語っぽいですが、わかりません。……説明して下さい。
23:11:30 <c_wraith> I can get as far as "this is japanese".  But I'm really ultra-beginner level :)
23:11:42 <pikhq> Or: "That seems like Japanese, but I don't understand it. Please explain."
23:11:58 <c_wraith> Holy crap, I've just forgotten kana.
23:12:03 <tensorpudding> I see Japanese
23:12:05 <c_wraith> that's wakarimasen.  right.  >_>
23:12:10 <tensorpudding> the word for Japanese in Japanese, that is
23:12:15 <etpace> i've been here six weeks and all i know is how to order beer in japanese
23:12:32 <pikhq> etpace: Biiru onegaishimasu? Well, that is at least *important*. :P
23:12:38 <etpace> yep
23:12:46 <etpace> that and uzu and shiso for yakitori
23:13:29 <pikhq> I strongly suggest you learn more. 'Tis fun, enjoyable, and something most people suck at. :P
23:14:16 <c_wraith> One of my friends just went to japan to teach english.  She invited me over to visit anytime.  I should go.  Also, I should remember this isn't -blah. :)
23:14:17 <pikhq> (kanji aren't that hard people!)
23:16:07 <BMeph> If you see all-question marks, you're using the WTF-8 encoding... ;)
23:16:16 <pikhq> :P
23:16:26 <tensorpudding> reading kana is one thing, knowing what it means is another
23:16:33 <lispy> ?remember BMeph If you see all-question marks, you're using the WTF-8 encoding... ;)
23:16:34 <lambdabot> It is forever etched in my memory.
23:16:54 <lispy> someone needs to bring back HWN
23:17:18 <pikhq> tensorpudding: Indeed.
23:17:31 <pikhq> tensorpudding: After all, you can reasonably learn kana in an afternoon...
23:18:01 <siteswapper> Is there a documentation for lambdabot?  I see so many surprising things it does.
23:18:30 <lispy> ?help
23:18:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:18:36 <lispy> ?list
23:18:36 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:20:41 <BMeph> lispy: Well, if you're going to be saving quotes of me, definitely! :D
23:21:53 <BMeph> pikhq: Anyway, I said (something like) "Exactly that", in German.
23:21:57 <pikhq> BMeph: Ah.
23:22:08 <pikhq> BMeph: It parsed as un-understandable Japanese, so. :P
23:22:40 <pikhq> (it was gramatically and phonetically valid and used a word I couldn't find the meaning of at all)
23:23:33 <siteswapper> ?fortune
23:23:34 <lambdabot> Couldn't find fortune file
23:24:05 <siteswapper> lambdabot ?help fortune
23:24:46 <EvanR> > unsafePerformIO unsafeLaunchTheMissles
23:24:46 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `unsafeLaunchTheMissles'
23:29:03 <gwern> silly EvanR. as if mueval would let you use unsafePerformIO
23:29:14 <gwern> now witness the firepower of this fully armed and operational interpreter!
23:29:16 <gwern> > 2+2
23:29:18 <lambdabot>   4
23:29:43 <EvanR> i can still do malicious things with it
23:29:56 <EvanR> you see they cant cover every interface
23:30:13 <gwern> there is no power in the universe superior to mueval
23:31:11 <EvanR> > text "fuck you!"
23:31:12 <lambdabot>   fuck you!
23:31:15 <shachaf> > fix id -- Why isn't this <<loop>>, mueval?
23:31:19 <lambdabot>   mueval-core: Time limit exceeded
23:31:31 <EvanR> beat that
23:32:01 <gwern> time limit exceeded has the same denotation as <<loop>>
23:32:08 <gwern> if I understand denotational semantics right
23:32:31 <EvanR> shachaf: <<loop>> will appear in the compiled code
23:33:05 <shachaf> EvanR: λbot used to do it.
23:33:08 <shachaf> Before mueval came along.
23:33:26 <EvanR> maybe its not compiling anymore
23:33:33 <gwern> shachaf: well, that code was actually compiled, not interpreted as I think the ghc api does it
23:33:49 <gwern> or whatever. I don't really care about <<loop>> versus time out
23:34:02 <gwern> (a loop would timeout any timeout, after all)
23:38:03 <quicksilver> depends on optimisation level I think
23:38:12 <quicksilver> <<loop>> is if the blackhole gets observed
23:38:22 <quicksilver> if the thunk is optimised away there is no blackhole and it's just a tight loop
23:38:33 <quicksilver> probably varies between GHC version.
23:39:24 <gwern> tight loops were a big problem with mueval
23:39:50 <dolio> > let x = x in x
23:39:53 <lambdabot>   mueval-core: Time limit exceeded
23:40:52 <lispy> abal install network-2.2.1.7 --reinstall --constraint="parsec==3.1.*"  ==> cabal configure  ==> package network-2.2.1.7 requires parsec-2.1.0.1
23:40:56 <dolio> Using threading turns off blackhole errors, too. Does mueval run things -threaded?
23:41:12 <gwern> dunno
23:41:15 <lispy> I _just_ installed network-2.2.1.7 with parsec 3, so why is it complaining?
23:42:06 <lispy> Wait, did cabal just ignore my constraint??
23:42:07 <lispy> grr....
23:45:10 <Polarina> How do I use the cairo bindings to render to X or win32?
23:45:24 <siteswapper> ?help babel
23:45:25 <lambdabot> babel <lang1> <lang2> <phrase>.
23:45:25 <lambdabot> Translate a phrase in lang1 to lang2.
23:45:25 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
23:45:53 <siteswapper> ?help de en Genau
23:45:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:46:04 <siteswapper> ?babel de en Ganau
23:46:04 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
23:46:10 <bss03> @babel "en" "es" "Hello, Welcome to my Home"
23:46:10 <lambdabot> Plugin `babel' failed with: Error: Language "en" not supported
23:46:31 <bss03> @babel en es "Hello, Welcome to my Home"
23:46:31 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
23:46:41 <lowSodium> I just used the command $ ghc --make Foo.hs to build an executable and all went well but after deleting the files and trying again it refuses to produce the executable. Anyone know what gives?
23:46:47 <bss03> @babel en es "Hello, Welcome to my home."
23:46:47 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
23:48:00 <lowSodium> it really is strange, it will give me the .o and .hi but nothing else...
23:48:13 <catenate> lowSodium: try "ghc -o Foo Foo.hs --make"
23:48:51 <lowSodium> i'll give it that shot
23:49:09 <siteswapper> ?help kind
23:49:09 <lambdabot> kind <type>. Return the kind of a type
23:49:22 <siteswapper> ?help type
23:49:23 <lambdabot> type <expr>. Return the type of a value
23:49:37 <siteswapper> What is a kind?
23:49:47 <c_wraith> The type of a type, essentially.
23:49:49 <siteswapper> ?kind Integer
23:49:51 <lambdabot> *
23:50:00 <c_wraith> * is the kind of concrete types, that can have values
23:50:05 <c_wraith> @kind Maybe
23:50:05 <lambdabot> * -> *
23:50:10 <siteswapper> ?kind string
23:50:11 <lambdabot> Not in scope: type variable `string'
23:50:17 <siteswapper> ?kind String
23:50:18 <lambdabot> *
23:50:19 <c_wraith> Maybe is a type constructor.  It requires an argument to be a concrete type
23:50:25 <c_wraith> @kind Maybe Integer
23:50:25 <lambdabot> *
23:50:45 <siteswapper> Wow.
23:51:06 <siteswapper> ?type map
23:51:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:51:14 <catenate> One more step down the rabbit hole. ;)
23:52:08 <siteswapper> Are there even more steps?
23:52:21 <catenate> How well do you know category theory?
23:52:24 <theorbtwo> It's always seemed odd to me that Maybe isn't simply of type a -> Maybe a.
23:52:44 <bss03> :k Data.Map.Map
23:52:44 <lambdabot> * -> * -> *
23:52:49 <lowSodium> i'll have to fool with it more i guess, not sure what's happening, however i do have another question, namely, whats the best way to apply a data constructor to a very long list of values?  
23:53:47 <c_wraith> lowSodium map
23:53:51 <siteswapper> catenate: I don't know category theory.
23:53:53 <Veinor> > map Just [1..10]
23:53:54 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
23:53:57 <c_wraith> err, there should have been a comma in there.
23:54:10 <Veinor> I'd say map is very low sodium!
23:54:13 <bss03> :k Maybe Data.Map.Map
23:54:15 <lambdabot>     `M.Map' is not applied to enough type arguments
23:54:15 <lambdabot>     Expected kind `*', but `M.Map' has kind `* -> * -> *'
23:54:16 <lowSodium> a data constructor with multiple parameters, many parameters
23:54:29 <bss03> :k Data.Map.Map Maybe
23:54:29 <lambdabot>     `Maybe' is not applied to enough type arguments
23:54:30 <lambdabot>     Expected kind `*', but `Maybe' has kind `* -> *'
23:54:34 <lowSodium> the list represents the parameters
23:54:53 <catenate> lowSodium: If you're using a makefile, and the binary file you want to generate is not a final target (ie, something else depends on it), then make might be deleting it to clean up.  In which case you would say "don't do that" with ".PRECIOUS: Foo".
23:54:57 <bss03> Hrm, is there a "." or "$" for type constructors?
23:55:33 <siteswapper> ?wikipedia category theory
23:55:34 <lambdabot> http://wikimediafoundation.org/wiki/Special:Search?search=category%2520theory
23:56:28 <catenate> siteswapper: I've looked at category theory, and while I can tell it's beautiful mathematics, and underlies a lot of powerful functional programming, I don't really understand it at all.
23:58:26 <catenate> Wikipedia sez: Category theory has several faces known not just to specialists, but to other mathematicians. A term dating from the 1940s, "general abstract nonsense", refers to its high level of abstraction, compared to more classical branches of mathematics.
23:59:29 <catenate> Wikipedia sez: Categories now appear in most branches of mathematics, some areas of theoretical computer science where they correspond to types, ...
