00:01:09 <wioux> aah o
00:01:11 <wioux> ok
00:01:16 <wioux> my association was wrong
00:01:40 <wioux> Int -> (Int -> Int) /= (Int -> Int) -> Int
00:01:49 <robryk> Yes.
00:12:04 <anair_84> i had a dumb question , how do i set an element in an array at particular position
00:12:13 <anair_84> a[i] = "val"
00:12:29 <koala_man> what kind of array are you using?
00:12:43 <anair_84> it is just a normal list actually
00:12:46 <anair_84> [Char]
00:13:03 <dibblego> anair_84, lists are immutable
00:13:26 <Kaidelong> there may still be a function to pretend though
00:13:34 <Kaidelong> although perhaps he should rethink his algorithm
00:13:42 <dibblego> or use Data.Sequence
00:13:54 <Kaidelong> something wrong with mutable arrays?
00:14:03 <Kaidelong> anyway anair_84, what problem are you trying to solve
00:14:37 <anair_84> just trying to store some chars at positions in a char string
00:14:57 <Kaidelong> is that the problem you are trying to solve or part of the solution you came up with, though?
00:15:00 <anair_84> supposed to be a dummy tm
00:15:20 <anair_84> writing a dummy turing machine
00:15:34 <wioux> ah
00:15:40 <anair_84> it has a tape which i thought would be a char string
00:16:08 <Kaidelong> anair_84: I'd imagine what you'd want for this is a mutable array
00:16:29 <anair_84> is that what gets constructed by array
00:16:36 <anair_84> constructor
00:17:00 <Kaidelong> since your turing machine will be deterministic you don't need to worry about IO
00:17:06 <Kaidelong> right?
00:17:09 <anair_84> yeah
00:17:16 <Kaidelong> you can parameterize the rules and a starting tape
00:17:31 <Itkovian> good meuning
00:17:34 <anair_84> yeah
00:18:02 <Kaidelong> http://hackage.haskell.org/packages/archive/array/0.1.0.0/doc/html/Data-Array-MArray.html
00:18:10 <Kaidelong> this is an overloaded interface for any mutable array
00:18:31 <anair_84> thanks
00:18:40 <Kaidelong> write the actual thing that runs the turing machine using this, you might want a different data structure to deal with things like the end of a tape, I don't know? up to you
00:18:55 <Kaidelong> in your implementation you'd likely pass an IO array, or an ST array if you want to be pure
00:19:10 <anair_84> k
00:19:27 <Kaidelong> but you can write the bulk of your code polymorphically for any MArray
00:19:53 <Kaidelong> you might also want to take a look at the vector type
00:19:59 <Kaidelong> or write your own Tape data structure
00:20:08 <Kaidelong> which could be good if this is an exercise
00:20:22 <Kaidelong> a doubly linked list would make sense for a tape
00:20:22 <anair_84> yeah it is just an exercise
00:20:44 <anair_84> yes , but how do you do linked list in haskell
00:20:52 <anair_84> there are no pointers 
00:20:59 <Kaidelong> of course there are pointers
00:21:07 <Kaidelong> hmm, I'd do it something like this:
00:21:56 <blueonyx> in my turing simulator i used replicate ' ' as empty tape
00:22:12 <Kaidelong> data DoubleLinkedList a = LeftEnd (DoubleLinkedList a) | Segment (DoubleLinkedList a, a, DoubleLinkedList a) | RightEnd (DoubleLinkedList a)
00:22:21 <blueonyx> err repeat ' '
00:22:57 <Kaidelong> and then you could have something like
00:23:14 <Kaidelong> moveLeft (LeftEnd _) = undefined
00:23:23 <Kaidelong> moveLeft (RightEnd x) = x
00:23:39 <Kaidelong> moveLeft (Segment(x,_,_)) = x
00:23:44 <Kaidelong> etc
00:23:48 <anair_84> k
00:24:06 <anair_84> wouldnt have thought of that myself , thanks
00:24:06 <robryk> but is there an easy way to make it mutable?
00:24:40 <Kaidelong> robryk: no, mutation would be O(n) unless you allow the pointers to be mutated
00:24:46 <Kaidelong> using something like IORef
00:24:50 <Kaidelong> which he could do
00:24:54 <Kaidelong> it wouldn't be terribly hard
00:25:05 <kmc> robryk, apart from the problem of mutation, lists are just bad for random access
00:25:14 <kmc> because they have to be traversed from the beginning
00:25:19 <wioux> in a Turing machine all you need to mutate is the list's point of focus
00:25:20 <robryk> yes, but this invites problems with not updating reverse pointers
00:25:26 <wioux> no?
00:25:27 <Kaidelong> kmc: but if he is making a turing machine it doesn't really need random access
00:26:00 <Kaidelong> it'd be more idiomatic for him to work with a tape
00:26:07 <kmc> that's true
00:26:13 <kmc> it's a good fit for a zipper sort of thing
00:26:16 <Kaidelong> he could make it mutable, the solution I proposed wouldn't work for that
00:26:17 <kmc> which is what the above type is, i think
00:26:31 <wioux> the data structure is good, since you can pass it around as simple (left, point-under-head, right)
00:27:06 <robryk> i think you'd rather want something like ([a], [a])
00:27:15 <Kaidelong> robryk: on pointers, in a pure language there is no distinction between pointers and values
00:27:19 <robryk> or rather ([a], a, [a])
00:27:31 <Kaidelong> well
00:27:33 <Kaidelong> there shouldn't be
00:27:36 <Kaidelong> there is
00:27:41 <wioux> that's also good
00:27:45 <wioux> better even
00:28:32 <Kaidelong> but then both the stuff left and right is singly linked?...
00:29:07 <Kaidelong> unless I'm missing something big here
00:29:09 <wioux> mm yeah moveLeft is o(n)
00:29:17 <robryk> eh?
00:29:18 <robryk> why?
00:29:42 <Kaidelong> robryk: because you'd have to traverse the whole singly linked list on the left to move left once
00:29:48 <wioux> moveLeft (ls, x, rs) = (init ls, last ls, x:rs)
00:29:53 <robryk> moveLeft (l:ls,c,rs) = (ls,l,c:rs)
00:29:54 <manjunaths> how much is a Oleg ?
00:29:56 <wioux> need the last element of fst
00:30:12 <robryk> why not keep it reversed?
00:31:12 <robryk> a simple question: <expr> typechecks in ghci, but let f = <expr> doesn't with `ambiguous type variable'
00:31:16 <robryk> why?
00:31:18 <wioux> Oleg is a unit of obscureness, no?
00:31:37 <robryk> <expr> is runRegionT $ return () which should be MonadCatchIO m => m ()
00:31:48 <Kaidelong> robryk: GHCi wart, GHCi wants everything to become implementation types
00:31:55 <manjunaths> wioux, I thought it was an unit of complexity
00:31:57 <BMeph> robryk: Hint - what does <expr> typecheck to? ;)
00:32:05 <Cale> anair_84: If I was writing a Turing machine, I'd probably represent the tape using two lists together with an additional element. The list of elements before the read head (in reverse order, so the closest one is the first element of the list), the element under the read head, and the list of elements after
00:32:05 <kmc> does defaulting work differently in the IO-monad context than in the "let" context?
00:32:07 <Kaidelong> robryk: it's counterintuitive if you come from something like java
00:32:18 <kmc> it makes sense, given that lambda bindings are monomorphic and let bindings polymorphic
00:32:22 <Kaidelong> robryk: try writing the stuff in a fil eand then loading it, it should work like that
00:32:25 <robryk> oh. thanks.
00:32:26 <robryk> ok
00:32:41 <wioux> manjunaths: not sure.. one or the other. either way i don't think it's very precise
00:33:02 <Cale> anair_84: The operation to replace the element under the read head is then very inexpensive, because the lists of elements before and after can be shared.
00:33:10 <Kaidelong> Cale: isn't that the basic idea behind a zipper then?
00:33:14 <Cale> anair_84: and operations to move left and right are also cheap
00:33:24 <Cale> Kaidelong: That's exactly the idea behind a zipper.
00:33:33 <Cale> (This is a zipper for lists)
00:34:05 <anair_84> not sure i got that
00:34:41 <anair_84> Cale : is there an eg.
00:34:42 <Cale> anair_84: So, data Tape a = T { before :: [a], here :: a, after :: [a] }
00:34:48 <ezyang> Lol. Iteratees are obvious. 
00:35:05 <Kaidelong> moveLeft (sx:x, xx, xs) = (sx, x, xx:xs)
00:35:06 <Kaidelong> then
00:35:26 <Cale> Kaidelong: That's a type error.
00:35:35 <Kaidelong> hmm
00:35:40 <Kaidelong> missing parens?
00:35:44 <Cale> sx:x
00:35:48 <Cale> is the wrong way around
00:35:48 <wioux> Kaidelong x is [a]
00:35:50 <Kaidelong> oh of course
00:35:51 <Kaidelong> hahah
00:36:08 <Kaidelong> right
00:36:12 <Kaidelong> it's stored in reverse order
00:36:20 <Kaidelong> so I don't have to worry about that
00:36:40 <Kaidelong> moveLeft (sx:x, xx, xs) = (x, sx, xx:xs)
00:36:51 <Cale> yeah
00:37:28 <anair_84> is that constructing a tuple ?
00:37:28 <Cale> Or with my type:  moveLeft (T (l:ls) v rs) = T ls l (v:rs)
00:37:41 <wioux> yeah
00:37:46 <anair_84> k
00:37:57 <Cale> Yeah, you can just use tuples if you prefer
00:38:21 <Cale> modify w (T ls v rs) = T ls w rs
00:38:28 <robryk> is there a simple explanation what does ambiguous type variable mean?
00:38:32 <anair_84> k it is clearer when i seed the T cons
00:38:37 <Cale> ^^ this is extremely cheap, because ls and rs don't have to be copied at all
00:38:52 <Cale> (just a pointer to the list is copied)
00:39:08 <wioux> when a type can't be inferred
00:39:16 <anair_84> Cale: cool
00:39:27 <wioux> > read "any datatype at all"
00:39:28 <lambdabot>   *Exception: Prelude.read: no parse
00:39:36 <wioux> gah
00:39:38 <robryk> any?
00:39:42 <Kaidelong> reverse (sx, xx, xs) = (xs, xx, sx)
00:39:47 <Kaidelong> that look right?
00:39:49 <robryk> why doesn't it leave it?
00:40:01 <robryk> leave it as a variable that is
00:40:35 <wioux> it needs to show it
00:40:38 <Kaidelong> mutate xx' (sx, xx, xs) = (sx, xx', xs)
00:40:44 <Kaidelong> that'd be efficient
00:40:48 <robryk> i mean, why doesn't it apply to \x y -> x + y
00:41:19 <wioux> doesn't work with lambdabot, but if you ghci read "..." its ambiguous type variable - needs to evaluate it to some datatype, but it can't infer what type
00:41:45 <robryk> ghci read ?
00:41:57 <wioux> Prelude> read "..."
00:42:00 <wioux> is all i meant
00:42:13 * Kaidelong wonders why you would use a doubly linked list if you have zipper, now
00:42:23 <Kaidelong> zipper seems so much better
00:42:46 <robryk> ok, but :t read "..." gives me proper type
00:43:12 <wioux> what type does it give you?
00:43:16 <wioux> (Read a) => a
00:43:38 <robryk> yes
00:43:53 <anair_84> Kaidelong are you talking about zipper monad ?
00:44:02 <Kaidelong> anair_84: no
00:44:09 <Kaidelong> the concept of a focus
00:45:03 <robryk> so amiguous type var is ghci-only error?
00:46:00 <wioux> no
00:47:23 <wioux> the read thing was just an example.. its an error where type must be inferred but can't be
00:47:54 <robryk> i see. thanks.
00:48:20 <robryk> something like read '...' `seq` ()
00:50:31 <robryk> how can i learn wha are partial inferences when a type error occurs?
00:50:32 <wioux> if there are no additional constraints, then read ".." can be *any* instance of Read. that's not an actual type, its just a constrained type
00:51:00 <robryk> i've got a `constrained variable escapes' which is helped by explicitly typing
00:53:37 <wioux> what do you mean robryk? often ghc will tell you what was expected and what was inferred
00:55:01 <robryk> ok. i understood it. i was confused because i didn't see that two things are really the same one
00:56:52 <robryk> (and was expecting to see both types)
00:58:12 <Kaidelong> robryl: just add type signatures to everything. This makes it easier to use some useful type system extensions too that break full type inference
00:58:35 <Kaidelong> it'll help you avoid some of these
00:58:46 <Kaidelong> like the issue with read, where it can't infer the return type of read
00:58:59 <Kaidelong> explicit type signature will resolve that situation
00:59:15 <Kaidelong> :t read "5"
00:59:16 <lambdabot> forall a. (Read a) => a
00:59:23 <Kaidelong> :t read "5" :: Int
00:59:24 <lambdabot> Int
00:59:32 <robryk> yes. i just wanted to see how it arrived at the error
01:22:02 * hackagebot BluePrintCSS 0.1 - Html document layout library.  http://hackage.haskell.org/package/BluePrintCSS-0.1 (SergeyMironov)
01:35:37 <robryk> i've got a strange problem with cabal/ghc's package .conf files -- when i try to insll safer-file-handles ghc complains that Cabal is unusable due to lacking containers ; containers both have a .conf file in ~/.ghc and the library itself exists. reinstalling it nor cabal doesn't help.
01:36:37 <geheimdienst> try to run "ghc-pkg check", that might give you some clues
01:36:59 <robryk> nothing
01:37:21 <robryk> constributing might be that i have cabal installed both systemwide and locally
01:37:30 <robryk> so the local one masks the systemwide one
01:39:28 <geheimdienst> possibly one of them is not kosher and causes the containers errors
01:39:38 <geheimdienst> have you run cabal install with the verbose switch?
01:40:14 <robryk> yes, it helps naught
01:40:15 <robryk> it doesn't pass -v to ghc
01:41:22 <geheimdienst> try something like cabal install --ghc-option=-v
01:43:16 <robryk> thanks. it claims that the instance of containers it wants is shadowed
01:47:38 <newbie_> hello
01:47:55 <newbie_> I've got a problem during cabal install wx
01:48:19 <Botje> did you install the headers?
01:48:29 <newbie_> Although I installed wxWidgets and windows port wx-config, and wx-config --c-flags runs correctly
01:48:50 <newbie_> cabal install wx still complains wx-config: does not exist
01:49:39 <newbie_> I've already followed all the instuctions and run a cmd with administrator priviledge. BTW, I'm using windows 7 and haskell platform 2.0.0.0
01:50:11 <Botje> maybe it's a question of setting your %PATH ?
01:50:36 <blueonyx> hi, what does ghc mean with internal error: PAP object entered! ? 
01:51:42 <newbie_> wx-config is in PATH, and if I enter "wx-config --cflags", it works well.
01:52:14 <newbie_> Does cabal use a different PATH to search for executables?
01:53:06 <robryk> for the record: advice for dependencies conflict from the faq helped
01:53:31 <robryk> unregistering user cabal helped, that is
01:53:35 <kmc> blueonyx, that there is heap corruption, due either to a bug in GHC, a bug in a foreign-imported library, or a bug in Haskell code which uses very unsafe operations (unsafeCoerce, Foreign, etc.)
01:53:50 <kmc> you should never see it with 'vanilla' haskell code; that would definitely be a bug in GHC
01:53:53 <kmc> would you like more detail?
01:55:14 <Wtopia> hi, everybody.
01:55:18 <newbie_> robryk, thanks for your suggestion. When I copy wx-config from c:\windows\system32 to another directory in my PATH, it works now.
01:55:26 <Wtopia> I am learning Haskell by myself
01:55:38 <blueonyx> kmc: no thanks, im trying to revert what broke it
01:55:45 <kmc> ah, are you modifying ghc?
01:55:47 <newbie_> It seems cabal will not search the system directories, such as c:\windows\system32?
01:55:48 <kmc> hi Wtopia
01:56:00 <robryk> newbie_: eh? what did i suggest?
01:56:04 <Wtopia> hi kmc, nice to see you
01:56:34 <newbie_> You said maybe it's a question of setting your %PATH?
01:57:07 <Botje> i did :)
01:57:20 <blueonyx> kmc: no but im using the ghc api, and it occurs when i try with profiling enabled
01:57:22 <newbie_> Ah. Sorry. :) Made a mistake
01:59:40 <kmc> hmm, perhaps that means you need a version of GHC which is itself built for profiling
02:00:58 <kmc> blueonyx, similar problem perhaps to http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/template-haskell.html#id666279
02:02:14 <blueonyx> kmc: it fails with i cabal configure -p --enable-executable-profiling, but works with just -p :/
02:04:34 <blueonyx> ah because profiling is then disabled xD
02:06:38 <ClaudiusMaximus> hm, any way to get TemplateHaskell splices to have nice types, this is kinda blegh:  compose :: (b[a6kq] -> c[a6kr]) -> (a[a6kp] -> b[a6kq]) -> a[a6kp] -> c[a6kr]
02:06:49 <ClaudiusMaximus> (output from ghci :browse)
02:07:27 <ClaudiusMaximus> would also be nice not to have to enable ScopedTypeVariables and use explicit forall in [t| .. |]
02:13:33 <blueonyx> okay, no profiling when using ghc api, but how to profile/optimise my program then?
02:15:18 <kmc> factor out the GHC API usage
02:15:26 <ivanm> @ask edwardk are you aware that the haddock on hackage doesn't like some comments in your interval library?
02:15:26 <lambdabot> Consider it noted.
02:15:33 <kmc> or build GHC with the profiling RTS
02:15:38 <kmc> or profile in some different way
02:21:22 <boegel> hmm, I need to adjust the home page @ http://hackage.haskell.org/package/HRay
02:21:30 <boegel> anyone know how to do that quickly?
02:21:51 <ivanm> boegel: reload a new version
02:22:03 * boegel admits he has never used Hackage
02:22:23 <ivanm> boegel: all that info is just a dump of the stuff in the cabal file
02:22:35 <ivanm> and with very few exceptions you can't change something that's up there
02:22:38 <boegel> ivanm: so, I simple reload a new cable file?
02:23:13 <ivanm> boegel: you'll need to do a package bump with only the cabal file changed
02:23:18 <ivanm> make it 1.1.1.1 or something
02:23:24 <boegel> hmmm
02:23:43 <boegel> you know what, I'll just leave it :)
02:23:50 <hydo> Using the haskell vim mode and, for example, trying to use the '_si' command, where/how/when am I supposed to use that?  I assumed that if i_x meant 'do this in insert mode' etc. then '_x' meant it works in any mode.  Clearly, I am mistaken.
02:23:56 <boegel> seems like the url still works (although I was expecting it wouldn't)
02:24:04 <boegel> I'll look into this when I really have time for it
02:24:55 <ivanm> fair enough
02:50:01 <Schalken> How can I write the following type signature? stream :: (StreamSource source x, StreamSink sink x) => (source, sink) -> (source, sink)
02:50:41 <kmc> the issue is the multiple mention of x?
02:50:58 <Schalken> It's supposed to say source and sink must instantiate the given class for a common type x. Of course there might be many xs to choose from, in which I would expect some sort of error...
02:51:07 <kmc> does it not work as-is?
02:51:14 <kmc> if not, try this:  (StreamSource source x, StreamSink sink y, x ~ y) => ...
02:51:55 <kmc> but it might be useful to put an unused type into the arguments or return, to say what x is
02:52:07 <kmc> i.e. (StreamSource source x, StreamSink sink x) => (source, sink) -> Tagged x (source, sink)
02:52:10 <kmc> using Data.Tagged from tagged
02:53:06 <Schalken> kmc: I was hoping I wouldn't need to.
02:53:36 <Schalken> kmc: If the type looks fine to you then that could tell me the errors I am getting are caused by something else.
02:54:00 <kmc> i'm not sure, honestly
02:54:04 <kmc> let me try something similar
02:54:51 <Schalken> kmc: Would it help if I pasted my code? I beleive the problem is caused by a function body.
02:55:35 <Saizan> that type signature already tells me that function can't be used, unless StreamSource and StreamSink both have a fundep
02:56:26 <Saizan> but a fundep might just be what you want, if every source/sink is supposed to have only one instance
02:57:10 <kmc> remember that type classes are open
02:57:20 <kmc> there might be only one type x you can see now, but someone could add another
02:57:35 <kmc> Schalken, http://codepad.org/OykTwBeR
02:57:54 <Saizan> if only the pair (source,sink) is supposed to determine x then you need to use a typeclass like class Stream source sink x | source sink -> x where ..
02:58:06 <kmc> Schalken, maybe you can share more about what you're trying to do?
02:58:27 <kmc> there may be a simpler design
02:59:17 <Schalken> I am trying to copy and paste the code out of my Ubuntu VM first >;/
02:59:35 <Schalken> That emote was supposed to be ":/"
03:00:05 <Nibble> Hello
03:00:21 <Nibble> the arrow <- goes through a list, from first element to last, right?
03:00:22 <zygoloid> technically i think only one of StreamSource and StreamSink need the fundep
03:00:25 <Nibble> what if I want to do the opposite
03:00:29 <Schalken> There we go: http://pastebin.com/KEbae6aV
03:00:31 <kmc> Nibble, you mean in a list comprehension or such?
03:00:35 <Nibble> kmc: yep
03:00:37 <zygoloid> Nibble: reverse the list first
03:00:49 <Nibble> zygoloid: no other possbile solution?
03:00:49 <zygoloid> > [ x | x <- reverse [1..5] ]
03:00:50 <lambdabot>   [5,4,3,2,1]
03:01:00 <Nibble> but sure, it works
03:01:03 <kmc> Nibble, not with ordinary lists.  if you need a data type with efficient access to both ends, you need something other than a list
03:01:03 <zygoloid> Nibble: reverse the result afterwards? :)
03:01:05 <kmc> i.e. Data.Sequence
03:01:23 <Nibble> kmc: well, it is not like this is going to be any high performance
03:01:26 <Nibble> just a few elements
03:01:28 <zygoloid> kmc: even that won't give you a reverse monadic bind
03:01:37 <Schalken> I was trying to understand the design decisions in the iteratee library by writing my own stream processing library. No monads yet, but this is how I started anyway.
03:01:50 <Nibble> zygoloid: well. that is what I need. But it would be nice with something like y >- xs
03:01:56 <Nibble> I am sure you can define a infix function for that tho
03:02:06 <kmc> Schalken, ah, so you probably want the fundep a -> x.  for any stream type a, there's only one element typ ex
03:02:08 <kmc> type x*
03:02:14 <geheimdienst> nibble, could you tell us a little about the context? what do you want to do with the reversed list?
03:02:18 <kmc> Schalken, but associated types are cleaner i think
03:02:34 <kmc> class StreamSink a where { type Elem a; push :: a -> Maybe (Elem a -> a) }
03:03:02 <kmc> instance StreamSink [x] where { type Elem [x] = x; ... }
03:03:12 <Nibble> geheimdienst: a palindrome maker
03:03:16 <Nibble> listPalindrome xs = xs:[x | x <- (reverse xs)] 
03:03:23 <Nibble> but it gives error, wait
03:03:29 <kmc> this way you avoid all these type vars (which are determined by the others anyway) making their way into the contexts
03:03:32 <Nibble>  Occurs check: cannot construct the infinite type: t = [t]
03:04:06 <kmc> you probably want ++ not :
03:04:14 <Nibble> kmc: ye
03:04:16 <kmc> (:) :: a -> [a] -> [a]
03:04:20 <kmc> (++) :: [a] -> [a] -> [a]
03:04:36 <geheimdienst> > let f s = s ++ reverse s in f "lolcat"
03:04:37 <lambdabot>   "lolcattaclol"
03:04:56 <Schalken> kmc: Yeah, I was hoping a given source/sink could behave on a variety of stream types, and Haskell somehow infer the type of stream from the context, but it seems Haskell is not that magical.
03:05:13 <Nibble> kmc: aah
03:05:16 <Nibble> :)
03:05:18 <kmc> Schalken, oh, so a stream might have more than one type of element?
03:05:23 <kmc> Nibble, what the "occurs check" error means is that your code only type checks if xs has type t and [t] simultaneously
03:05:31 <kmc> because you use it as both arguments to (:)
03:05:36 <kmc> (ignoring the reversing)
03:05:42 <Schalken> kmc: I was hoping for that kind of flexibility, yeah.
03:05:48 <kmc> this only makes sense if it has the "infinite" type [[[[[[[[...]]]]]]]]
03:06:02 <kmc> for which t = [t]
03:06:31 <kmc> you can in fact make a language where such types are supported, but in real code it's almost always indicative of an error, and so Haskell forbids them (though you can do equivalent things by introducing wrappers)
03:07:00 <Schalken> kmc: For example, I could declare a Handle as a source and sink for String and both strict and lazy ByteString.
03:07:17 <kmc> Schalken, then you need a way to say which should be used, right?
03:07:38 <kmc> i.e. a phantom type parameter to "stream" fixing x
03:07:46 <ivanm> yitz: grrrr.....
03:07:52 <geheimdienst> > let f = uncurry (++) $ (id &&& reverse) in f "lolcat"
03:07:53 <yitz> heh
03:07:53 <lambdabot>   Couldn't match expected type `(a, c)'
03:07:54 <lambdabot>         against inferred type `a1 -> ...
03:08:13 <geheimdienst> > uncurry (++) $ (id &&& reverse) "lolcat"
03:08:14 <lambdabot>   "lolcattaclol"
03:08:22 <geheimdienst> > let f = uncurry (++) . (id &&& reverse) in f "lolcat"
03:08:23 <lambdabot>   "lolcattaclol"
03:08:31 <kmc> because in that case i can write two "stream" functions with the same type, one which pipes using String and one which pipes using strict ByteString
03:08:36 <kmc> the user needs some way to say which they want
03:09:06 <robryk> by specifying type
03:09:29 <Nibble> kmc: ye, thanks for the help. I should learn to use ghci more
03:09:30 <Schalken> kmc: Right. So what I wanted really isn't possible. I need fundeps/associated types along with types which wrap a Handle to provide specific types of streams/sinks.
03:09:35 <Nibble> :t and :info is really usefull
03:09:36 <lambdabot> Not in scope: `info'
03:09:36 <lambdabot> Not in scope: `is'
03:09:36 <lambdabot> Not in scope: `really'
03:09:43 <Schalken> kmc: Right?
03:09:50 <osaunders> Can someone show me a simple bit of code where there's an ambiguous type variable.
03:09:59 <kmc> osaunders, (show . read)
03:10:04 <kmc> :t show . read
03:10:05 <robryk> read "..." `seq` ()
03:10:05 <ivanm> @ask Heffalump is ther any particular reason you haven't made RFunctor instances for Seq, etc. whilst you're at it?
03:10:05 <lambdabot> Consider it noted.
03:10:06 <lambdabot> String -> String
03:10:21 <kmc> > (show . read) 3
03:10:23 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
03:10:23 <lambdabot>    arising from the literal `...
03:10:26 <kmc> err
03:10:28 <kmc> > (show . read) "3"
03:10:29 <lambdabot>   "*Exception: Prelude.read: no parse
03:10:36 <kmc> hmm, stupid defaulting
03:10:53 <kmc> could have swore this was an ambiguity error
03:10:58 <robryk> :t read "..." `seq` ()
03:10:58 <lambdabot>     Ambiguous type variable `a' in the constraint:
03:10:59 <lambdabot>       `Read a' arising from a use of `read' at <interactive>:1:0-9
03:10:59 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
03:11:02 <osaunders> > read "10"
03:11:03 <lambdabot>   *Exception: Prelude.read: no parse
03:11:04 <Saizan> Schalken: fundeps would be for forcing a single stream type and have type inference decide for you, if you instead make that 'x' variable appear in the type of stream the user can decide which type they want
03:11:10 <yitz> > (++) <*> reverse $ "lolcat" -- geheimdienst
03:11:11 <lambdabot>   "lolcattaclol"
03:11:15 <Saizan> > read "10" :: Int
03:11:16 <lambdabot>   10
03:11:26 <robryk> :t read "3"
03:11:27 <lambdabot> forall a. (Read a) => a
03:11:33 <kmc> Schalken, i think the best way is to have an arg to "stream" mention x, i.e. using Tagged
03:11:34 <geheimdienst> yitz, interesting!
03:11:52 <geheimdienst> @pl f s = s ++ reverse s
03:11:53 <lambdabot> f = ap (++) reverse
03:12:07 <kmc> but also, i'm not so sure about the overall design
03:12:09 <yitz> yes, ap == (<*>)
03:12:45 <Schalken> Saizan: kmc: But that would mean providing a argument to stream which isn't avtually used. Kind of a hack, in my opinion. Wouldn't the wrapper solution be considered cleaner?
03:12:46 <kmc> sometimes classes obscure the issue
03:13:39 <kmc> don't use a class when an ordinary type will do
03:13:49 <kmc> did you consider something like: data StreamSink x = forall a. StreamSink { push :: a -> Maybe (x -> a) }
03:14:21 <kmc> Schalken, no, if you use Tagged you don't provide an unused function argument
03:14:37 <kmc> the type would be like "(source, sink) -> Tagged x (source, sink)" or "Tagged x (source, sink) -> (source, sink)"
03:15:09 <kmc> as opposed to, say, "x -> (source, sink) -> (source, sink)"
03:15:25 <Nibble> a function that gets everything from a list except the last element?
03:15:33 <Saizan> init
03:15:40 <kmc> > init [] -- beware
03:15:41 <lambdabot>   *Exception: Prelude.init: empty list
03:16:35 <kmc> are there functions like tail and init which map [] to []?
03:16:40 <Saizan> behold the power of the empty list! making our functions partial!
03:16:47 <Saizan> drop 1
03:16:49 <kmc> for tail there's «drop 1»
03:16:51 <kmc> yeah
03:17:16 <Saizan> zipWith const xs (drop 1 xs)
03:17:20 <geheimdienst> @let init [] = []
03:17:21 <lambdabot>  Defined.
03:17:28 <geheimdienst> > init []
03:17:29 <lambdabot>   Ambiguous occurrence `init'
03:17:29 <lambdabot>  It could refer to either `L.init', defined at ...
03:17:38 <geheimdienst> @undef
03:17:38 <Saizan> > L.init [1]
03:17:39 <lambdabot>   Not in scope: `L.init'
03:17:43 * geheimdienst no likes
03:22:01 <chrisdone> hi
03:22:17 <ivanm> hey chrisdone 
03:24:48 <augur> what kind of parser is typically used for Haskell?
03:25:24 <kmc> for parsing Haskell source?
03:25:31 <augur> yeah
03:25:38 <earthy> tends to be a combinator parser, iirc
03:25:50 <kmc> GHC uses Happy, i thought
03:25:54 <augur> ahh, so its a parser built in haskell
03:25:59 <augur> makes sense x3
03:26:11 <augur> combinator parser.. i dont know much about these. i should learn. any good tutorials?
03:26:14 <earthy> kmc: but GHC is the exception. ;)
03:26:20 <earthy> augur: the magic word is parsec
03:26:28 <augur> aha ofcourse :p
03:26:32 <kmc> parsec is a popular parser-combinator library
03:26:45 <codolio> I'm pretty sure most compilers haven't written their parsers in parsec.
03:26:51 <earthy> uuparsing is also quite good
03:26:57 <earthy> codolio: true
03:27:00 <kmc> what does haskell-src-exts use?
03:27:12 <earthy> ISTR UHC uses uuparsing
03:27:55 <injekt> stupid question, ['a'..'z'] returns a string, right, how do I process each element as if it were a list? ie as an input set?
03:28:00 <kmc> it is a list
03:28:05 <kmc> String is an alias for [Char]
03:28:07 <earthy> nhc had a custom parser combinator lib
03:28:11 <chrisdone> I just realised there's a crap load in haskell-mode's inferior-mode that annoys me that I can easily fix when I have time. I've started a list: http://gist.github.com/506158 feel free to add any annoyances/ideas that you have. i'll probably implement them if it irks me too
03:28:26 <injekt> kmc: that tells me that [ x ++ "!" | x <- ['a'..'z']] should work, though
03:28:36 <kmc> no
03:28:41 <kmc> because x :: Char
03:28:49 <kmc> the elements of a string are chars, not strings
03:28:50 <ivanm> is Michael Snoyman here?
03:28:50 <earthy> and "!" :: [Char]
03:29:04 <injekt> that makes sense
03:29:05 <chrisdone> (figured I'd start a list otherwise I'll forget about all this stuff)
03:29:07 <kmc> > [ [x] ++ "!" | x <- ['a'..'z'] ]
03:29:08 <lambdabot>   ["a!","b!","c!","d!","e!","f!","g!","h!","i!","j!","k!","l!","m!","n!","o!"...
03:29:17 <injekt> ahh
03:29:24 <injekt> thanks
03:29:26 <earthy> > [x: "!" | x <- ['a'..'z']]
03:29:27 <lambdabot>   ["a!","b!","c!","d!","e!","f!","g!","h!","i!","j!","k!","l!","m!","n!","o!"...
03:33:08 <chrisdone> ivanm: you use emacs right?
03:33:13 <ivanm> yup
03:33:20 <chrisdone> no gripes?
03:33:37 <Schalken> kmc: Sorry I had to go out for a few minutes. I like your Tagged solution. Can you tell me what a call to `stream` would look like using this? Would it be something like `stream (Tagged (a, b) :: Tagged ByteString (Handle, Handle))`?
03:33:39 <ivanm> in terms of Haskell, or as an editor?
03:33:47 <chrisdone> ivanm: as I described above
03:34:03 <ivanm> ahhh, i missed that
03:34:25 <ivanm> well, tab-completion in general would be nice
03:34:51 <ivanm> not sure I get what your second comment is about; does normal ghci not have a blank line between the two "<interactive> ..." lines?
03:35:12 <ivanm> not sure I get the point of "Make loading a new file ..."
03:35:14 <chrisdone> normal ghci does, but I don't care for them
03:35:35 <ivanm> so you want to have inferior-haskell be better than stock ghci? :p
03:35:43 <chrisdone> when you load a file in inferior-haskell, and then you :m + Foo some modules that it depended on, you can use those modules
03:35:49 <chrisdone> if you reload the module, you have to manually :m + Foo again
03:35:52 <ivanm> aha
03:36:03 <chrisdone> it'd be nice if it tried to add all the possible ones again for you :-)
03:36:12 <ivanm> chrisdone: the ability to have a macro to define a "log" of things to type in so when you reload it will re-do them would be nice
03:36:37 <chrisdone> yeah like test values and such
03:36:54 <chrisdone> :persist let x = 1
03:36:57 <chrisdone> or w/e
03:37:21 <zygoloid> > (:"!")<$>['a'..'z']
03:37:22 <lambdabot>   ["a!","b!","c!","d!","e!","f!","g!","h!","i!","j!","k!","l!","m!","n!","o!"...
03:37:26 <ivanm> oh, even a key-binding that saves entered lines after that into some extra haskell-log buffer, and then re-enters them when you say so
03:37:53 <injekt> zygoloid: Im not even going to try working that out at this stage :P
03:38:05 <chrisdone> ivanm: yeah. without making a million prompts, too
03:38:18 <chrisdone> I often have three or four windows in emacs so I need all the space I can get. there's no point in a lot of what you get displayed in the *haskell* buffer
03:38:19 <ivanm> chrisdone: where is the command to get the type of main coming from in the second-last example?
03:38:33 <chrisdone> ivanm: I'm pressing C-c C-t in some haskell buffer
03:38:42 <ivanm> ahhhh
03:39:36 <ivanm> chrisdone: but yes, having a log kind of thing + tab-completion (like ghci does, not using one of the tab-completion modes) would be the main things I'd want
03:39:48 <ivanm> syntax highlighting in the *haskell* buffer might be nice, but isn't important
03:40:10 <chrisdone> since discovering the 'test' hook in cabal I've added lots of automated things to it. one example is something to build the project files but with -c. so this speeds up loading in ghci modules that have already been compiled to .o
03:40:23 <ivanm> is that there yet?
03:40:30 <ivanm> I thought that GSoC project was still ongoing...
03:40:47 <chrisdone> I heard about that, I don't really know what it's about
03:41:01 <chrisdone> there is a test hook already in cabal and I'm using it
03:41:11 <gwern> preflex: seen dons
03:41:11 <preflex>  dons was last seen on #ghc 6 hours, 16 minutes and 25 seconds ago, saying: why don't we  just process all of hackage with the  new haddock concepts?
03:41:12 <ivanm> huh
03:41:17 <chrisdone> 'cabal test foo' invokes whatever code i defined in Setup.hs
03:41:39 <ivanm> oh, right
03:41:40 <zygoloid> has anyone written a tool to run ghci with the setup from a .cabal file?
03:41:50 <ivanm> the GSoC is meant to actually have a test statement in the .cabal file
03:41:52 <gwern> hm. dons told me that he would deal with outstanding xmonad matters when he finished his thesis, but his thesis was apparently done a while ago
03:41:57 <ivanm> rather than using that hack to run stuff in Setup.hs
03:42:10 <ivanm> chrisdone: so that is a hook in cabal-install, not cabal!
03:42:14 <gwern> oh well
03:42:37 <ivanm> gwern: yeah, I'm waiting for him to get back to me so I can try to resolve this whole fgl naming issue (since edwardk and I thrashed out a possible solution)
03:43:01 <chrisdone> well yeah it's a hook
03:43:15 <zygoloid> injekt: it's a hook in cabal, where cabal is the name of a binary ;-)
03:43:26 <ivanm> zygoloid: was that aimed at me?
03:43:27 <zygoloid> s/injekt/ivanm/ damn tab-completion
03:43:35 <chrisdone> ivanm: not really related to cabal-install though
03:43:56 <ivanm> Cabal is a library, cabal-install is the program (which happens to have the unfortunate binary name of "cabal")
03:44:24 <chrisdone> and? lol you think i don't know this or something?
03:44:44 <geheimdienst> (in a saner world, this would be libcabal and cabal i think ...)
03:44:49 <ivanm> that was to zygoloid
03:44:56 <ivanm> geheimdienst: that's the plan
03:45:02 <zygoloid> ivanm: i disagree. Cabal and cabal-install are hackage packages. cabal is a binary in the cabal-install package. :)
03:45:07 <ivanm> what is now "cabal-install" was originally intended to be part of Cabal
03:45:21 <ivanm> then people decided it would be better to have specialised libraries rather than ship everything with GHC
03:45:33 <chrisdone> anyhoo i use 'cabal foo' because it's easier than 'runhaskell Setup.hs'
03:45:41 <ivanm> zygoloid: yes, but when you refer to "cabal", you're referring to the package
03:45:43 <ivanm> chrisdone: same
03:45:51 <ivanm> that's pretty much all I use cabal-install for
03:46:06 <zygoloid> ivanm: i disagree again. when i refer to Cabal, i'm referring to the package. when i refer to cabal, i'm referring to the binary.
03:46:31 <ivanm> chrisdone: though there are times when I have to use "runhaskell Setup.hs" instead, especially when I'm using customised dependencies (and cabal-install tries to be too damn clever)
03:46:33 <chrisdone> i use it to install packages too. i use everything from it
03:46:42 <zygoloid> $ cabal install Cabal <-- this agrees with my interpretation ;-)
03:46:45 <ivanm> zygoloid: most people don't bother capitalising though
03:46:48 <chrisdone> ivanm: customized deps?
03:46:53 <geheimdienst> clearly you shouldn't talk in opaque strings but in something more strongly typed
03:47:10 <zygoloid> ivanm: the best we can say is that the uncapitalized name is ambiguous :)
03:47:11 <ivanm> chrisdone: e.g. using parsec-3 for pandoc; when I have a package that uses pandoc, cabal-install then wants to rebuild pandoc to use parsec-2
03:47:17 <ivanm> zygoloid: right
03:47:18 <geheimdienst> i installed cabal :: Package to get cabal :: Binary
03:47:29 <ivanm> zygoloid: and too many people come in not realising there is a distinction
03:47:37 <zygoloid> ivanm: so chrisdone's hook is indeed a hook in cabal, fsvo cabal ;-)
03:47:45 <ivanm> earlier, when chrisdone was referring to there being a test hook for cabal, I assumed he meant Cabal-the-library
03:47:58 <ivanm> geheimdienst: heh
03:47:58 <chrisdone> well it is
03:48:10 <chrisdone> cabal-install just happens to run a lot of things by the Setup.hs program
03:48:24 <ivanm> chrisdone: link for this?
03:48:32 <ivanm> because I've never heard of such a hook before
03:48:38 <chrisdone> main = defaultMainWithHooks simpleUserHooks { runTests = tests }
03:48:41 <chrisdone> one sec
03:48:47 <Zao> What _isn't_ there a hook for in Cabal?
03:48:54 <Zao> (well, there's some things, but nothing important really)
03:49:04 <chrisdone> @hoogle simpleUserHooks
03:49:04 <lambdabot> No results found
03:49:09 <ivanm> chrisdone: huh
03:49:17 <ivanm> haven't come across that one before
03:49:41 <ivanm> anyway, IIRC the GSoC project is aimed at standardising the test flag and having an explicit test section in the .cabal file
03:50:27 <chrisdone> found it
03:50:27 <chrisdone> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/Cabal-1.8.0.4/Distribution-Simple-UserHooks.html#v%3ArunTests
03:51:07 <chrisdone> it wasn't very well documented, and by that I mean, none
03:51:12 <chrisdone> but it's easy to see what it does
03:51:15 <ivanm> yeah
03:51:40 <ivanm> but it's not really integrated in yet, in that you still have to use a custom Setup.hs
03:52:33 <chrisdone> yep
03:52:37 <osaunders> How would I go about printing the result of pie in <http://codepad.org/4CUOw3VW>?
03:52:52 <chrisdone> still, i don't mind, it's quite fun to write a custom Setup file
03:54:44 <ivanm> does anyone know which version of haddock comes with the latest platform?
03:55:00 <ivanm> osaunders: as in the result of that?
03:55:09 <osaunders> Yeah.
03:55:15 <ivanm> main = do Right result <- pie; print result
03:55:25 <Saizan> osaunders: remove "HI.MonadInterpreter m" from the type signature, and then it's just "main = pie >>= print"
03:55:30 <ivanm> that, of course, assumes it returns successfully
03:55:52 <ivanm> Saizan: well, he might need that constraint if you look at the source of the function... ;-)
03:56:13 <ivanm> but I don't think the Functor instance is needed there unless one of the functions it calls need it
03:56:46 <osaunders> ivanm: Couldn't match expected type `HI.InterpreterError' against inferred type `GHC.IOBase.IOException'
03:56:47 <Saizan> ivanm: you're right, the body is wrong too.
03:57:11 <ivanm> Saizan: heh
03:57:55 <osaunders> Yeah, I have absolutely no idea what I'm doing here.
03:58:11 <Saizan> http://codepad.org/YQDEpz46 <- this should work
03:59:00 <osaunders> Saizan: Comment added.
03:59:02 <Saizan> basically runInterpreter should wrap all the interactions with the interpreter
04:00:22 <Saizan> osaunders: sounds like a problem of mismatched versions
04:01:44 <osaunders> Ah, well I had a problem of Control.Monad.CatchIO being in two packages.
04:02:10 <osaunders> So I was hiding one, now I've just hidden the other instead and now it will get as far as linking but then there's linking errors.
04:02:56 <Saizan> linking errors?
04:03:03 <Saizan> from ld?
04:03:19 <Saizan> which ghc version are you using?
04:04:01 <osaunders> Saizan: New comment.
04:04:45 <Saizan> preflex: zdec _ghczm6zi10zi4_LibFFI_Czuffizutype_closure_tbl 
04:04:45 <preflex>  _ghc-6.10.4_LibFFI_C_ffi_type_closure_tbl
04:05:05 <Saizan> no idea what that means, though those are warnings, it seems
04:05:57 <w3rs> do you know a simple way to convert result of show (with "\xxxx\yyyy" escape sequences) to unicode string?
04:06:10 <ivanm> w3rs: it is a unicode string
04:06:19 <EliasAmaral> I'm having trouble loading the example at bottom of http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Expr.html  at ghci
04:06:21 <Saizan> w3rs: read?
04:06:22 <Zao> w3rs: read
04:06:23 <ivanm> it just might not be printed as such depending upon the version of GHC you're using and your locale
04:06:33 <Zao> w3rs: If by "unicode string" you mean an UTF-8 sequence, Data.Text
04:06:41 <ivanm> if you want to print it nicely, use utf8-string or something
04:06:42 <ClaudiusMaximus> > let s = "łe→¶↓→↓→eł↓¶" in (s, text s)
04:06:43 <lambdabot>   ("\322e\8594\182\8595\8594\8595\8594e\322\8595\182",łe→¶↓→↓→eł...
04:06:47 <ivanm> or Data.Text
04:06:56 <ivanm> EliasAmaral: error?
04:06:57 <osaunders> Saizan: Ah those are warnings!
04:07:00 <EliasAmaral> the type error is: http://paste.pocoo.org/show/245184/
04:07:06 <Zao> I should rephrase that. If you want a particular encoding, use Data.Text to transcode.
04:07:08 <osaunders> Saizan: That always gets me.
04:07:23 <EliasAmaral> test.hs is http://paste.pocoo.org/show/245185/
04:07:35 <ivanm> EliasAmaral: looks like the docs weren't changed to reflect change in API...
04:07:37 <EliasAmaral> I have ghc 6.12.3
04:07:40 <EliasAmaral> A
04:07:49 <EliasAmaral> ivanm, yes.. it worked fine in parsec 2
04:07:54 <w3rs> ClaudiusMaximus, ivanm thanks
04:09:13 <EliasAmaral> ivanm, I was trying to figure out how to use this parser, do you know some doc that uses parsec 3?
04:10:02 <ivanm> EliasAmaral: nope ;-)
04:10:06 <ivanm> I have never used parsec
04:10:16 <ivanm> but the lack of tutorials, etc. for parsec-3 is a common complaint
04:10:46 <EliasAmaral> installing parsec-2 again:)
04:11:04 <Saizan> you probably still have it installed.
04:11:18 * Saizan can't find where reservedOp is defined
04:13:23 <EliasAmaral> no, i removed it.. once i got past the convoluted road to install parsec 3 on gentoo (someone said parsec 2 was the "old" parsec..)
04:14:01 <fasta> EliasAmaral, if you understand monad transformers and you can use parsec2, you can use parsec3. 
04:14:08 <EliasAmaral> as result i had to upgrade ghc from 6.8 to 6.12, i hope it has no much catchs
04:14:36 <EliasAmaral> fasta, problem is, I don't, ._. all I have about FP is some ocaml
04:15:10 <EliasAmaral> fasta, I tried to figure out how it works looking at the types
04:15:13 <fasta> EliasAmaral, if you compose a monadtransformer version with the identity monad, you have the same basically.
04:15:13 <geheimdienst> uh i thought the api didn't really change? just a few imports?
04:15:26 <Saizan> the first step is to {-# LANGUAGE NoMonomorphismRestriction #-} then understanding monad transformers is not even that necessary
04:15:32 <fasta> geheimdienst, it didn't. 
04:15:46 <EliasAmaral> 'NoMonomorphismRestriction'?
04:16:04 <EliasAmaral> fasta, "so why old code doesn't work unchanged"
04:16:18 <fasta> EliasAmaral, because they are not paid to do that.
04:16:32 <EliasAmaral> the code?
04:16:43 <fasta> EliasAmaral, no, the people who wrote the code. 
04:16:51 <kmc> there is an API change from parsec2 to parsec3
04:17:24 <Saizan> (otherwise old code would work, even if people are not paid for it :)
04:17:34 <EliasAmaral> I think you meant "the new api is isomorphic to the old api"
04:18:02 <EliasAmaral> but I can't really think that without knowing what is "isomorphic" is
04:18:09 <kmc> there are two major differences:
04:18:31 <kmc> - ParsecT is a monad transformer, allowing you to combine it with your own monad.  previously: GenParser is only a monad
04:18:45 <andre> hi
04:19:00 <EliasAmaral> hi andre
04:19:03 <Saizan> EliasAmaral: can you point me at the type of reservedOp in parsec3?
04:19:17 <kmc> - parsers now read from a "stream", which could be a list or something else, e.g. a ByteString.  previously: parsers read only from a list, often [Char] i.e. String
04:19:23 <andre> hi elias, thank you and good-bye
04:19:36 <kmc> odd
04:19:53 <kmc> EliasAmaral, if you keep these in mind, it is not too hard to go between signatures involving GenParser and signatures involving ParsecT
04:20:00 <EliasAmaral> reservedOp :: GenTokenParser s u m -> String -> ParsecT s u m ()
04:20:11 <kmc> data GenParser tok st a	 :   token type, user state, result
04:20:26 <kmc> data ParsecT s u m a	:   stream type, user state, underlying monad, result
04:21:31 <Saizan> EliasAmaral: ah, you need to make a GenTokenParser and apply reservedOp to it then.
04:22:21 <msieradzki> uhm, why is numeric-prelude GPL? :P
04:22:26 <Saizan> using makeTokenParser from Text.Parsec.Token
04:23:33 <Saizan> i'm surprised that code works with parsec2..
04:23:51 <kmc> ...wow, that's a lot of types and they're all named T
04:24:31 <ivanm> msieradzki: because the person that wrote it decided to license it as GPL
04:24:55 <Zao> ivanm: Madness.
04:25:08 <EliasAmaral> what is the usual haskell license?
04:25:15 <ivanm> EliasAmaral: whatever people want
04:25:22 <msieradzki> BSD
04:25:25 <EliasAmaral> how to mix it all?
04:25:26 <Zao> EliasAmaral: Preferably something sufficiently free.
04:25:29 <Zao> Like BSD or so.
04:25:29 <ivanm> most common is to have BSD-like for libraries, and if so desired GPL for applications
04:25:30 <Saizan> the most common on hackage is BSD3
04:25:52 <msieradzki> GPL lib = can't use it in any real code
04:25:54 <ivanm> EliasAmaral: let's leave the arguments of how "free" a particular license is for another day, OK? :p
04:25:59 <ivanm> msieradzki: yes you can
04:26:02 <kmc> a lot of code on hackage is BSD, as are most of the core libs and tools.  however i don't think we have any official group ideology about what license is "the Haskell license"
04:26:11 <ivanm> kmc: exactly
04:26:13 <kmc> plenty of people advocate GPL or LGPL and you can get a nice flamewar going
04:26:21 <Zao> ivanm: s/real // and his statement is true.
04:26:32 <ivanm> *sigh*
04:26:41 <ivanm> Zao: I'm not in the mood to have a license flamewar
04:26:43 <kmc> so how about you argue about licenses in #haskell-blah
04:26:53 <Zao> It is an irrefutable fact. GPL prevents use with other licenses.
04:26:57 <kmc> ...sorry if that came off super pissy
04:27:01 <Zao> It's not an argument, and I'll stop now.
04:27:10 <msieradzki> nor am I I'll check gpl again
04:27:18 <kmc> but last time this monopolized this channel for quite a while
04:27:24 <ivanm> yeah
04:27:35 <Zao> msieradzki: My solution is to cry a bit, then find another library or hack one up myself.
04:27:44 <ivanm> if you don't like the license someone wrote some code under, either ask them to change it or re-write something with similar functionality yourself
04:27:46 <Zao> Insert cursing and fist-shaking as necessary.
04:27:57 <msieradzki> Zao, I'd do so but reinveinting basic library isn't exactly productive
04:28:04 <Zao> In the end, it's up to the licenser, even though they may not realize what their choice implies.
04:28:20 <Zao> If the latter, you can probably enlighten them and get them to relicense under a different license.
04:28:21 <msieradzki> ivan, I'll ask probably
04:28:42 <Saizan> are you seriously going to use the numeric-prelude?
04:28:55 <Saizan> all classes are named C and all types are named T
04:29:07 <ivanm> Saizan: the idea is that you use all modules qualified
04:29:08 <Saizan> i think that's worse of any license problem you can imagine.
04:29:11 <ivanm> some people like that approach
04:29:18 <Saizan> and that idea is wrong :)
04:29:23 <EliasAmaral> Saizan, I think the guy for some reason is influenced by ocaml
04:29:26 <kmc> i think it's reasonable in principle, but a huge mismatch with all the other code out there
04:29:44 <Saizan> EliasAmaral: yeah
04:29:55 <kmc> i'll note (simply as a relevant fact, not to argue one side or another) that the Industrial Haskell Group has paid for work in un-GPLing parts of GHC
04:30:02 <EliasAmaral> yeah, it's impossible to import/open most modules in ocaml, because there's a lot with type t, function map..
04:30:12 <kmc> and work to make the requirements of LGPL less onerous
04:30:47 <kmc> a lot of Haskell modules are built around qualified import too, but usually the type name is still meaningful, with the result that you write "Map.Map" or you have a second import
04:30:49 <ivanm> kmc: no, they were un-LGPL-ing parts of GHC
04:30:54 <ivanm> there's a difference
04:30:58 <kmc> arguably "Map.T" is better than either
04:31:08 <kmc> that's true ivanm
04:31:23 <kmc> more precisely: making it possible for GHC to not need to link LGPL libs into code it compiles
04:31:29 <ivanm> one approach I'm thinking of for any serious future projects is to follow cpphs's approach: LGPL with an explicit linker exception
04:31:34 <ivanm> kmc: yup
04:31:35 <kmc> (libgmp)
04:31:51 <Saizan> i'm not really convinced that Map.T is better, it's way ugly, also .T doesn't scale to more than one type
04:32:00 <EliasAmaral> Is microsoft financing this un-gpl/un-lgplzation?
04:32:15 <ivanm> EliasAmaral: they're not one of the public members of the IHG
04:32:36 <ivanm> there is an un-named third member, but no-one is telling who they are
04:32:41 <kmc> hehe
04:32:52 <EliasAmaral> hmm, but it is said that a lot of haskell was done at microsoft research..
04:32:56 <kmc> that is true
04:33:07 <kmc> however i'm not sure MS is interested in using Haskell commercially
04:33:15 <kmc> they are pushing F# quite hard for a similar role
04:33:27 <ivanm> EliasAmaral: GHC development is mainly done at MSR Cambridge
04:33:30 <ivanm> kmc: yeah
04:33:39 <kmc> and it interoperates with the whole microsoft ecosystem
04:33:55 <kmc> so it seems much more likely that MS-developed commercial products would use F# than that they'd use Haskell
04:34:19 <ivanm> yeah, and lets us avoid harrop
04:34:29 <deteego> its a shame though
04:34:36 <ivanm> can you imagine what kind of sudden Haskell fanboi he'd become if MSR officially started pushing Haskell? :s
04:34:43 <deteego> Haskell is much better then F# in my opinion
04:34:43 <ivanm> deteego: why?
04:34:45 <Zao> ivanm: Avoid Harrop At All Costs
04:34:49 <Zao> Our new and glorious motto.
04:34:51 <kmc> let's not even talk about harrop
04:34:52 <ivanm> Zao: exactly!
04:35:07 <kmc> don't feed the trolls
04:35:13 <ivanm> @remember Zao Avoid Harrop At All Costs; Our new and glorious motto.
04:35:14 <lambdabot> It is stored.
04:35:19 <kmc> sigh
04:35:28 <ivanm> :D
04:35:42 * ivanm would whistle and look innocent, but he can't whistle...
04:36:04 <deteego> who is Jon Harrop
04:36:21 <Zao> deteego: A very kind soul who loves functional languages.
04:36:23 <Zao> <_<
04:36:36 <Zao> Slightly opinionated.
04:36:37 <deteego> I see
04:36:41 <kmc> please let's not talk about him
04:37:05 <kmc> there is nothing nice to say and i want this to be a nice channel
04:37:47 <EliasAmaral> but there is something nice to say, not about him but about performance
04:38:14 <Zao> I'm looking to emit native functions at runtime. Can the LLVM bindings help me, or are they aimed for other purposes?
04:38:14 <EliasAmaral> it's supposedly not possible to write functional code with as much performance of imperative code. or isn't it true?
04:38:38 <Zao> EliasAmaral: All you need is an awesome compiler and the right data structures.
04:38:42 <kmc> EliasAmaral, in some cases there is an inevitable slowdown
04:39:12 <Saizan> Zao: augustss did that before, at least
04:39:17 <EliasAmaral> i borrowed a book at uni called 'functional data structures', mainly at sml (but with some haskell code too), showing that non-mutability throws off a lot of wisdom and facts people took for granted
04:39:33 <kmc> EliasAmaral, but "functional language" does not mandate "functional code".  ocaml, sml, haskell, scala, clojure, lisp, scheme all provide ways to write mutating in-place algorithms
04:40:21 <Zao> Saizan: My current approach is "allocate a slab of memory, mark it executable, store a [Word8] of hand-crafted assembly code, grab a pointer and pray.
04:40:28 <kmc> part of why we like Haskell is that it encourages pure functional code. but part of why we like it is just that it's a good language, for all sorts of styles, including imperative code
04:40:33 <EliasAmaral> kmc, the point isn't to write functional data structures just because they are beautiful, i think.. but because of the sharing properties
04:40:38 <kmc> yes
04:40:45 <EliasAmaral> the future is multi-core, etc
04:40:59 <kmc> yeah, and persistent data is really nice on multi-core
04:41:20 <Saizan> Zao: http://augustss.blogspot.com/2009/01/llvm-llvm-low-level-virtual-machine-is.html
04:43:06 <deteego> EliasAmaral: I believe its theoritically possible to compile down a functional language to be as fast as an imperative one
04:43:27 <deteego> EliasAmaral: its just such a fully functional compiler doesn't exist (yet)
04:44:13 <EliasAmaral> deteego, the problem isn't to compile it to be as fast as an imperative code, but if the result will have in-place mutation of data structures or immutable ones
04:44:39 <EliasAmaral> if there will be no sharing, the optimization should build as must mutation as possible.. i suppose
04:44:56 <kmc> i believe okasaki proved that there is an unavoidable O(log n) slowdown to some persistent structures
04:45:00 <kmc> (please correct me if wrong)
04:45:07 <EliasAmaral> i heard ghc has poor parallelism support, so this might as well be moot
04:45:18 <kmc> (it's fairly easy to see that O(log n) is the maximum slowdown)
04:45:19 <deteego> EliasAmaral: 6.12 is a lot better then 6.10
04:45:25 <deteego> there is still the last core problem
04:45:35 <deteego> which is apparently going to be fixed in 6.14 (when it comes out)
04:45:40 <Saizan> poor? really?
04:45:53 <deteego> but 6.12 isn't really poor in parallelism
04:46:02 <kmc> if so, a compiler producing code as fast as equivalent in-place imperative code would have to find linear (non-sharing) usage of data structures and compile them to mutation
04:46:09 <EliasAmaral> not sure, i heard from.. erm, sorry :P
04:46:18 <deteego> in fact there have been cases of it improving program speed by up to 80%
04:46:43 <kmc> and that's certainly undecidable, c.f. rice's theorem
04:47:52 <kmc> but i suggest we don't talk about compiling "functional languages" but rather "functional code"
04:48:01 <kmc> because you can transliterate C to Haskell
04:48:09 <kmc> and GHC will produce very close to what GCC produces
04:48:22 <kmc> and this is not so theoretically interesting, although it is useful
04:50:36 <Saizan> i don't think anyone proved there are algorithms that suffer a necessary O(log n) slowdown with pure implementations, for a sufficiently extensional sense of algorithm at least
04:50:42 <Associat0r> deteego: it's not better in every case
04:51:00 <Saizan> otherwise fasta would have annouced it :)
04:51:43 <deteego> Associat0r: is that referring to what?
04:51:59 <Associat0r> deteego: the Haskell better than F# thing
04:52:07 <EliasAmaral> I wonder if immutable structures will become widespread some day, and when
04:52:26 <deteego> Associat0r: ah right
04:52:46 <deteego> Eh I just see F# as a Microsoft's OCaml
04:53:08 <EliasAmaral> maybe 6 cores isn't enough to take down all that locking involved in mutable sharing.. or maybe the programming community is too inertial
04:53:17 <Associat0r> deteego: well that's wrong sine there are severe differences
04:53:24 <p_l> EliasAmaral: try running on 128 cores
04:53:32 <Associat0r> deteego: both in favour and against it
04:53:46 <EliasAmaral> p_l, maybe in 10 or 20 years? (in commodity hardware please)
04:53:48 <kmc> "has an implementation which can call all of .NET easily" is a massive point in favor of F#, especially if you have a big investment in .NET
04:53:49 <deteego> well of course its different because its on .net
04:53:53 <p_l> EliasAmaral: though I suspect that you might look to copy-only, nothing shared architecture for that
04:54:10 <p_l> EliasAmaral: it's quite easy to get it now, though of course not as cheap as PC boxen.
04:54:18 <kmc> you can imagine introducing some F# in a C# shop much more easily than introducing Haskell there
04:54:52 <Associat0r> kmc: that's not the only reason, if you looked closely you would know there is much more to F# than just .NET
04:54:54 <p_l> also F# fits better if you want deep integration with Win32/Win64 services etc. - you don't need to write extra boilerplate
04:55:37 <kmc> we tend to view language designs as isolated theoretical objects, but it sounds silly and wrong to the rest of the world when we use terms like "better" in that context
04:55:44 <p_l> (that's partially why I'm looking forward to getting some time to upgrade RDNZL - it bridges Common Lisp (regardless of implementation) and .NET)
04:56:12 <kmc> i like PL theory a lot but i think "Haskell is better than F#" sounds like a statement about real world usability unless clarified otherwise
04:57:36 <deteego> kmc: I wasn't talking about real world usability, was referring to the design of the language
04:57:40 <deteego> haskell is getting there
04:57:57 <dv_> where?
04:58:06 <kmc> to infinity and beyond
04:58:12 <EliasAmaral> highest brains melt per second
04:58:12 <deteego> lols
04:58:15 <chrisdone> the design of haskell hasn't changed much
04:58:16 <EliasAmaral> :~
04:58:53 <EliasAmaral> I think the language that will "win" the FP will not be haskell
04:58:56 <deteego> chrisdone: and...
04:59:14 <deteego> EliasAmaral: eh when the LLVM backend gets implemented
04:59:15 <Associat0r> there isn't much new to it wrt typesystems compared to Agda or even Scala
04:59:19 <deteego> that could change a lot of things
04:59:20 <kmc> what does "win" mean?
04:59:35 <kmc> the languages which have "won" so far are COBOL, C++, Java, and PHP
04:59:44 <kmc> i do not wish to add Haskell to this list
04:59:47 <Associat0r> EliasAmaral: it's not about winning
04:59:49 <EliasAmaral> kmc, python is winning
05:00:00 <deteego> kmc: agreed
05:00:10 <kmc> i don't see every drop in F# market share as some tactical advantage for Haskell
05:00:11 <EliasAmaral> Associat0r, yeah, haskell is not about winning (in the sense of java and python)
05:00:23 <EliasAmaral> gaining astronomic momentum, etc
05:00:37 <EliasAmaral> haskell is about this: http://comonad.com/reader/2009/recursion-schemes/
05:00:47 <Associat0r> EliasAmaral: also FP isn't the only thing out there
05:00:54 <kmc> haskell is about greek words?
05:01:00 <EliasAmaral> no, the type system
05:01:03 <dv_> personally, I also dont like to put c++ and php in the same basket
05:01:03 <kmc> only if you don't know Haskell
05:01:14 <dv_> c++ has its problems and has a broken syntax, but php.... :)
05:01:35 <deteego> dv_: when it comes to highly efficient abstract language
05:01:43 <deteego> C++ is still the "winner"
05:01:59 <kmc> yes, C++ is the best language in a particular niche, but it's still objectively bad there
05:02:01 <EliasAmaral> dv_, to think about it, he put cobol, too...
05:02:03 <kmc> it's just there is no serious competitor
05:02:07 <dv_> true.
05:02:14 <dv_> I would very much like a proper successor
05:02:20 <p_l> COBOL >> Java
05:02:25 <kmc> yes, and this time the successor will have to *remove* stuff
05:02:28 <dv_> the next best thing I see is D, but thats a niche language
05:02:36 <kmc> but of course C++1x adds a lot more stuff instead
05:02:37 <deteego> of course, I hate C++
05:02:41 <Associat0r> kmc: they are working on successors, BitC for one
05:02:46 <deteego> its a horrible language in my opinion
05:02:52 <copumpkin> omg
05:02:55 <deteego> D was supposed to be a "fixed" C++
05:03:03 <deteego> but they have had their own share of problems
05:03:32 <dv_> deteego: like democracy. as winston churchill put it, democracy is a horrible form of government, except for all others. here, I see c++ as horrible, but the proposed alternatives arent really up to the task :|
05:03:40 <EliasAmaral> bitC might be very nice, but it will not compete with C++
05:03:41 <Twey> D is a niche language?
05:03:45 <deteego> dv_: yeah agreed
05:03:54 <EliasAmaral> for one, it has a type system that is much akin to ml/haskell
05:03:58 <Twey> What niche does C++ have?
05:03:59 <deteego> I mean D is the only thing you can possible call an alternative
05:04:00 <dv_> D goes way too much into the java direction
05:04:10 <Associat0r> EliasAmaral: not in popularity but in capabilities it's there
05:04:13 <dv_> the language is much more powerful than java
05:04:18 <dv_> and they make no use of that power
05:04:28 <deteego> Twey: highly efficient language that gives you control of memory with lots of abstraction
05:04:29 <EliasAmaral> Associat0r, if they got a nice compiler, that is
05:04:44 <deteego> Twey: the only other languages that follow that niche are D and possible objective C
05:04:44 <EliasAmaral> get*
05:04:48 <deteego> which are "usable"
05:04:59 <deteego> *possibly
05:05:03 <EliasAmaral> Associat0r, they have problems compiling (with good performance) to C, and the first target, as it seems, will be .NET
05:05:05 <Associat0r> EliasAmaral: they are aiming at highly embedded no alloc stuff too so yeah it's gonna be good
05:05:08 <Twey> I don't know… I think FORTH fits that description
05:05:13 <dv_> half of boost is unnecessary in D, the other half could be implemented in a much saner way, with little to no functionality loss
05:05:26 <Associat0r> EliasAmaral: not true about .NET, it's a target not the first and only one
05:05:34 <EliasAmaral> Associat0r, yeah, the semantics of the language might compete with C
05:05:38 <deteego> I don't think FORTH really has the abstration levels that C++ has
05:05:46 <Twey> It has way more
05:05:53 <dv_> deteego: ah, but there is another possibility: ocaml
05:06:03 <deteego> dv_: hmmmm
05:06:05 <dv_> I mean, at least speed-wise
05:06:24 <Twey> The language model makes it very flexible with regards to abstraction &c., much like Lisp with its macros
05:06:24 <deteego> well the thing is that C++ gives you control over memory
05:06:29 <dv_> true
05:06:38 <deteego> in the sense you can shape how memory how you need it
05:06:41 <dv_> this is particularly important for embedded and game development
05:06:48 <Twey> That's a level of abstraction C++ can't really hope to beat
05:07:12 <Associat0r> deteego: you can't put Obj-C into the mix, it's only abstraction above C is dynamically typed
05:07:32 <dv_> and even D has a problem there, unless you choose to turn off the GC, which disables large parts of the language
05:07:34 <deteego> Associat0r: yeah thats what I meant
05:07:35 <deteego> by possibly
05:07:55 <dv_> but true, the stuff you can do with mixins is amazing
05:08:13 <kmc> C++ is important in finance too
05:08:15 <dv_> and the alias template parameters are very cool, so is the compile() metafunction
05:08:32 <arw> there are tons of possible alternatives. the problem is not that the alternatives are not up to the task, its just that the market won't accept them because they are either too different (thus perceived as too hard to learn or port to), too small (thus not enough support) or not enough of an improvement over the current state of c++.
05:08:36 <dv_> I just wish the D standard library would actually make use of this
05:08:41 <kmc> when the Java guys hit garbage collection the C++ guys take large amounts of money from them, and they know exactly that this is what's happening
05:08:43 <kmc> it's pretty funny
05:08:54 <Associat0r> dv_: you need control over boxing so Ocaml doesn't fit
05:08:59 <Saizan> maybe C++ is like cvs? so bad you can't make a "c++ done right" ?
05:09:23 <dv_> Saizan: unlike cvs, some of its features are essential and hard to reproduce in another way
05:09:32 <dv_> essential for its niche I mean.
05:09:59 <dv_> as said, you wont get very far with anything else than C or C++ on game consoles, for example
05:10:04 <EliasAmaral> well, there's a feature of cvs, namely versioning, that was considered essencial
05:10:08 <EliasAmaral> essential
05:10:18 <kmc> dv_, not true, most game logic is scripted in a high level language
05:10:34 <dv_> but thats not the largest part of the code
05:10:35 <p_l> dv_: Lisp had gone quite far on game consoles
05:10:37 <kmc> typically paired with a realtime engine in C++
05:11:08 <p_l> (well, for the one company that used it :P)
05:11:15 <dv_> and also, devs do convert scripts to c++ code if necessary, particularly on playstation consoles, where memory always has been very low
05:11:27 <deteego> game engines are still almost always done in C++/C
05:11:32 <dv_> 32 MB on the ps2, 512 MB on the ps3, for *everything* including textures and geometry
05:11:34 <EliasAmaral> dv_, you might go with bitC in some years, if they "win" the popularity contest (not much likely, but still).. because they will offer low-level control, with abstractions more powerful than C++
05:11:45 <deteego> game logic, is done in some other language, which ranges to LUA or Unreal Script or even Python
05:11:53 <EliasAmaral> by "will" I mean "might"
05:11:56 <kmc> i don't think there will be a clear "winner" of any FP popularity contest
05:11:57 <dv_> lua is very popular for game logic, yes.
05:12:01 <dv_> but see what I wrote
05:12:02 <Twey> Lua is not an acronym >.<
05:12:07 <Associat0r> deteego: some have switched to C++ for game logic again
05:12:18 <kmc> in every domain a variety of languages are used
05:12:20 <dv_> also, note that game developers are increasingly interested in FP for much of the engine code
05:12:25 <kmc> even when they're essentially interchangeable
05:12:25 <deteego> hmm, not suprising
05:12:28 <theorbtwo> Indeed.  You do the hard part in C or C++, then do the easy parts, which actually create the personality of your game, in something easier to write.
05:12:38 <kmc> and most languages we classify as functional are not interchangeable
05:12:41 <p_l> dv_: there was a game studio that made console games in their own variant of Lisp (with compiler written in CL, afaik). Theyu used it to write engine and game logic together
05:12:42 <dv_> stuff like the physics engine can be done purely as FP
05:12:46 <deteego> well, quake3 engine I believe
05:12:50 <deteego> is purefuly functional
05:12:52 <deteego> (in C)
05:13:02 <Twey> Haha
05:13:02 <kmc> Scheme and Clojure are closer to JavaScript than to Haskell
05:13:07 <dv_> doubtful. id is known for its wild hacks
05:13:11 * hackagebot gsc-weighting 0.1.0.2 - Generic implementation of Gerstein/Sonnhammer/Chothia weighting.  http://hackage.haskell.org/package/gsc-weighting-0.1.0.2 (FelipeLessa)
05:13:14 <kmc> so does JS get an entry in the FP popularity contest?
05:13:21 <theorbtwo> It certianly should.
05:13:32 <p_l> well, JS is kinda like Scheme offshoot with weird syntax...
05:13:41 <dv_> the other thing is that c++ is an 800 pound gorilla
05:13:47 <deteego> lol
05:13:49 <dv_> meaning that there are bazillions of libraries for it
05:13:55 <msieradzki> theorbtwo, it's not so simple :)
05:13:57 <deteego> thats both a good and bad thing
05:13:57 <dv_> thats a rather unfair advantage, yes.
05:14:09 <dv_> but still valid
05:14:09 <deteego> dv_: yeah thats what really makes or breakes languages
05:14:11 <kalven> p_l: are you refering to GOAL that was used at naughty dog?
05:14:12 <deteego> its the labraries
05:14:12 <EliasAmaral> but scheme, or js, or lua, none are 'hardcore' as haskell and its type system..
05:14:19 <msieradzki> you need fast scripting language in games like luaji
05:14:20 <deteego> thats what is killing D for example
05:14:21 <p_l> kalven: yeah
05:14:23 <msieradzki> luajit I mean
05:14:37 <EliasAmaral> js is kind of hybrid / not really caring about mathematical beauty
05:14:42 <msieradzki> otherwise you have to move a lot of stuff to C++
05:14:56 <dv_> deteego: the primary reasons why I no longer look into D were the presence of *two* standard libraries, which are incompatible (!!)
05:14:58 <theorbtwo> Indeed; the APIs you have to deal with from the console mfgr were probably designed as C or C++ callable.
05:15:13 <dv_> and the over-javafication of one of them, while the other looks like a C library
05:15:14 <deteego> dv_: yeah thats what I meant
05:15:16 <theorbtwo> If you want to write your engine in something else, then you're going to be spending time writing glue.
05:15:20 <p_l> btw, regarding consoles, afaik till the last generation, even if you had C++, big chunks of code were written in inline assembly (often because the available intrinsics for weird console extensions were inexistant or bad)
05:15:36 <deteego> they are gonna be compatible in D v2.x
05:15:40 <msieradzki> theorbtwo, but parts like writing commands into gfx command buffer
05:15:48 <dv_> p_l: much of ps2 game code used assembler ,yes
05:15:49 <msieradzki> aren't exactly specialized for C++
05:16:39 <dv_> isnt there some restriction in D that effectively disallows a more efficient GC?
05:16:42 <theorbtwo> I've heard from reasonable sources that you *cannot* get a wii license without going through their standard library -- they will verify it.
05:16:47 <dv_> the scope thing might be it
05:16:54 <deteego> its a shame, because D could have been a very beutificul language
05:17:09 <EliasAmaral> theorbtwo, verify what?..
05:17:24 <EliasAmaral> theorbtwo, that you haven't written assembly to replace some bits of it?
05:17:30 <theorbtwo> EliasAmaral: Yes.
05:17:38 <EliasAmaral> o.O
05:17:43 <theorbtwo> Or C that speaks to the same interface.
05:17:48 <dv_> scope is a useful feature that aims to implement RAII in D, however RAII and GCs are generally not compatible
05:17:50 <p_l> dv_: afaik one of the nicest parts of GOAL (the lisp used at naughty dog) was that it allowed very nice use of the coprocessors without ugly hacks, since the type system "knew" about coprocessor datatypes/registers etc.
05:17:58 <EliasAmaral> maybe to ease the emulation for the next generation?
05:18:06 <EliasAmaral> and the millions of fans out here :D
05:18:27 <Saizan> it might be the first time #haskell drifts from "haskell vs. other languages" into even "c++ vs. D"
05:18:33 <dv_> p_l, a game lisp machine. i find the idea both nice and weird :)
05:18:39 <Saizan> the usual is to stop at "c++ sucks"
05:18:51 <Saizan> IOW, there's #haskell-blah :)
05:18:53 <theorbtwo> dv_: Perl gets along quite well using refcounting... for some value of quite well.  The idea of moving to a GC that doesn't give you timely destruction for 6 was quite unpopular.
05:19:06 <deteego> Saizan: on the note of saying that C++ is broken in the same way CVS is broken
05:19:09 <dv_> well, haskell is, amongst other things, a testing ground for language design and features, is it not?
05:19:10 <msieradzki> C++ wins over everything it always has best compilers
05:19:18 <msieradzki> so D has no chances ;P
05:19:27 <Saizan> deteego: yeah, i'm not innocent :)
05:19:27 <deteego> I think if the language was designed properly from the start, instead of a "hacks" ontop of C
05:19:37 <deteego> it would be a different story
05:19:39 <dv_> theorbtwo: I too like refcounting, and there has been significant progress in improving its efficiency
05:19:41 <theorbtwo> OTOH, refcounting has the rather large problem that a small error in one small area can lead to very large memory leaks.
05:19:42 <copumpkin> omg Saizan is not innocent
05:19:50 <EliasAmaral> deteego, it wouldn't be as successful
05:20:16 <deteego> thats prob true
05:20:22 <theorbtwo> (Or, possibly worse, scribbling over memory, if you make the error in the other direction.)
05:20:28 <deteego> guess its a compromise
05:20:36 <Saizan> dv_: that doesn't mean that discussing other languages is not off topic :)
05:20:44 <dv_> theorbtwo: well some things either work 100% or not at all.
05:21:05 <p_l> msieradzki: best compilers? hahahahaha
05:21:11 <theorbtwo> There's a quite large comprimise to be made between being familiar and useful and being pure -- see javascript.
05:21:47 <theorbtwo> (And I don't neccessarly mean pure in the haskell sense.)
05:21:52 <deteego> parrelelism growing at the rate it is is probably one of the few things that will take people off C++
05:22:03 <deteego> and onto more functional languages (such as Haskell!!!)
05:22:21 <Associat0r> dv_: it's not so much a testing ground anymore
05:22:25 <kmc> yay we're the greatest and the best again
05:22:32 <kmc> everyone pat yourself on the back
05:22:39 <kalven> pat pat
05:22:40 * deteego pats himself on the back
05:22:59 <theorbtwo> I agree with you ... to a degree.  I don't think Haskell will neccessarly win because of that; it's too far off the beaten track for too many people.
05:23:08 <kmc> win?
05:23:14 <kmc> what game are you playing exactly
05:23:22 <EliasAmaral> kmc, the popularity contest
05:23:23 <kmc> do you get 1 point for every person who installs ghc?
05:23:35 <dv_> Associat0r: so what is?
05:23:48 <Associat0r> Agda, Epigram, Scala
05:23:48 <copumpkin> pumpkin:~ pumpkin$ cabal install darcs
05:23:49 <copumpkin> cabal: dependencies conflict: regex-compat-0.93.1 requires array ==0.3.0.1
05:23:49 <copumpkin> however array-0.3.0.1 was excluded because darcs-2.3.1 requires array >=0.1 && <0.3
05:24:04 <copumpkin> brand new haskell platform
05:24:15 <ivanm> ouch
05:24:17 <deteego> but seriously, LLVM can be a huge step
05:24:18 <kmc> making software popular should be a means to improving the world, not a goal unto itself
05:24:19 <deteego> for Haskell
05:24:23 <theorbtwo> Exactly 0.3.0.1?  That seems like overkill.
05:24:38 <EliasAmaral> kmc, it's measured by buzz talk / cubic meter, and the earth surrounding is huge
05:24:43 <deteego> hopefully we might even get shared objects that aren't restricted to a certain GHC version
05:24:44 <p_l> also, there are cases when it's not the language itself that decides what is best, but the runtime.
05:24:46 <ivanm> copumpkin: why that old a version of darcs?
05:24:49 <copumpkin> theorbtwo: beats me :P I just installed the latest platform
05:24:51 <deteego> that would be another push for Haskell
05:24:53 <ivanm> have you forgotten to "cabal update" ?
05:24:56 <copumpkin> ivanm: oh maybe I need to cabal update
05:25:00 <ivanm> yes ;-)
05:25:02 <copumpkin> I just installed the latest plaform so I assumed it was good
05:25:03 <ivanm> 2.4.4 is the latest
05:25:12 <ivanm> copumpkin: you had an old cache hanging around
05:25:13 * p_l for example is going with CL for now because his projects need the COMPILE function :)
05:25:19 <copumpkin> ivanm: ah, makes sense
05:25:19 <theorbtwo> Shouldn't it know that the package files are out of date, and tell you that itself?
05:25:21 <ivanm> installing the new platform wouldn't help with that
05:26:00 <theorbtwo> That is, "Warning: your cache is N days old, consider running 'cabal update'." at the bottom.
05:27:40 <ivanm> theorbtwo: sometimes it does
05:28:21 <theorbtwo> Ah, but if you unpack the platform, it considers the package lists that came with it as being from the date you unpacked it?
05:28:52 <theorbtwo> Possibly it should just not come with package lists, or use a date embedded in the file instead of trusting the filesystem's metadata?
05:30:16 <Saizan> it doesn't came with an available packages list.
05:34:37 <roconnor> oh Bonus lives in Ljubljana!
05:34:44 <ivanm> yup
05:34:51 <roconnor> I missed my chance to meet him!
05:34:56 <ClaudiusMaximus> how to put {-# LANGUAGE ... #-} in code blocks in my Haddock source.hs so that they appear in the HTML?
05:35:00 <zygoloid> is that basically pronounced "lovely anna"?
05:35:08 <roconnor> also, Miran is a guy!
05:35:15 <Twey> No
05:35:18 <ivanm> zygoloid: I think so
05:35:34 <geheimdienst> who is miran?
05:35:35 <ivanm> actually, more like "loved"
05:35:38 <roconnor> I though so, but never was sure
05:35:44 <Twey> Except for the ‘j’
05:35:44 <ivanm> geheimdienst: BONUS, i.e. the guy that wrote LYAH
05:35:48 <roconnor> geheimdienst: er, I should have said Bonus is a guy
05:36:00 <geheimdienst> i see
05:36:13 <Saizan> roconnor: you assumed otherwise?
05:36:20 <Twey> In English orthography, something like ‘lyoob-lyana’
05:36:40 <roconnor> Saizan: at first I did, but then I changed my mind after a short while
05:37:01 <danderson> also, interesting fact, in Slovenia all roads lead to Ljubljana
05:37:25 <Saizan> also called Rome 2
05:37:34 <geheimdienst> rome 2.0
05:37:53 <danderson> (empirically, while trying to find Tolmin in the east of the country - two roads forking off in opposite directions both indicated Ljubljana as a destination)
05:37:55 <roconnor> Apperently Ljubljana is a hotbed of computer science
05:38:29 <EliasAmaral> Ljubljana?
05:38:54 <ivanm> danderson: well, a lot of places will have signs on major roads pointing in the general direction of major towns, etc. ...
05:38:59 <ivanm> EliasAmaral: the capital of Slovenia
05:39:30 <EliasAmaral> danderson, radial roads.. might be common in small countries
05:39:32 <danderson> ivanm: yeah, but this repeated itself at pretty much all intersections we reached
05:39:58 <EliasAmaral> here there is a set of roads that ends up in brasília (the capital, close to the geographic center of brazil)
05:40:01 <danderson> turn left into a small country road, you're going to Ljubljana. Head back west towards Italy, you're going to Ljubljana.
05:40:15 <danderson> (it also made it kinda hard to figure out where the heck we were supposed to go :)
05:40:15 <roconnor> @seen BONUS
05:40:16 <preflex>  BONUS was last seen on #haskell 48 days, 19 hours, 47 minutes and 5 seconds ago, saying: :)
05:40:16 <lambdabot> Unknown command, try @list
05:40:30 <roconnor> @ask BONUS do you know Andrej Bauer?
05:40:31 <lambdabot> Consider it noted.
05:40:37 <geheimdienst> well it is true that if you go straight away from ljubljana, 40,000 km later you'll reach it from the other side
05:40:41 <EliasAmaral> @ask dark hm?
05:40:42 <lambdabot> Consider it noted.
05:40:58 <dark> is lambdabot supposed to tell me somehow? .-.
05:40:59 <lambdabot> dark: You have 1 new message. '/msg lambdabot @messages' to read it.
05:41:02 <danderson> geheimdienst: assuming you can drive across two oceans, sure
05:41:02 <mije> bleh
05:41:05 <ivanm> wow, preflex intercepts @seen commands now? :o
05:41:06 <dark> ah
05:41:23 <Zao> danderson: All you need is liftAuto
05:41:36 <dark> @ask dark !
05:41:36 <lambdabot> You can tell yourself!
05:41:40 <dark> .-.
05:42:14 <geheimdienst> all i'm saying is, if slovenia is a small spherical country, and i am sure about the first, then it is perfectly reasonable to have signs saying <- Ljubljana | Ljubljana ->
05:42:32 <ivanm> geheimdienst: I hate to tell you this, but no country is spherical
05:42:50 <ivanm> since they're usually 2-dimensional on the earth's surface
05:43:01 <danderson> "If we assume slovenia to be a perfectly spherical country of uniform density..."
05:43:15 <ivanm> heh
05:43:35 <geheimdienst> "Assuming a perfectly cubic elephant ..."
05:43:35 <Twey> Also if Ljubljana is circular… :þ
05:44:11 * copumpkin went to ljubljana a couple of weeks ago
05:44:18 <ivanm> Twey: well, just change the geometry you're comparing it to
05:44:30 * ivanm has been in that region of the world but not to slovenia itself
05:44:36 <danderson> and annoyingly, despite all roads apparently leading to Ljubljana, I've never been there
05:44:49 <copumpkin> ivan: it wasn't the most exciting place I've ever been :)
05:44:57 <ivanm> heh
05:45:06 <Saizan> because you didn't visit BONUS
05:45:20 <copumpkin> oh he's in ljubljana?
05:45:30 <ivanm> copumpkin: yeah, maybe it's because I was there only to visit family (and thus constrained by that) but I didn't find the balkans that interesting a place to visit either
05:45:38 <ivanm> copumpkin: yes, hence why we're discussing it
05:45:45 <copumpkin> croatia was wonderful
05:45:45 <copumpkin> I loved it
05:46:11 <ivanm> we were considering visiting dubrovnik, but there's no easy way to fly from belgrade to there
05:46:19 <ivanm> and my dad didn't want to sit on a bus for 10 hours :s
05:46:34 <ivanm> (and there's no train, which he would have been happy with)
05:46:34 <copumpkin> yeah, dubrovnik is a pain to get to
05:49:40 <deteego> how did the conversation get to talking about Slovenia?
05:49:46 <dark> I remember that one of the first things that put me off looking into haskell was camelCase
05:50:16 <dark> I suppose there is some rationale behind it, but I still find weird writing this way on my own code
05:50:30 <deteego> I don't have any issues with camelcase
05:51:00 <dark> for the completely newbie, all languages are more or less equal, except by syntax..
05:51:12 <dark> s/ly//
05:52:06 <roconnor> deteego: BONUS lives in Ljubljana.
05:52:45 <Zao> All roads lead to BONUS?
05:53:37 <ivanm> dark: you don't have to use camel-case
05:53:40 <geheimdienst> all roads lead to ljearn u a bljana
05:53:41 <dark> from the lexical conventions on identifiers, what I love most is some-predicate?, int->string, .. etc from scheme
05:53:49 <ivanm> but it's usually preferred to using underscores because it's shorter
05:53:52 <dark> ivanm, it would be unwise to not follow the conventions
05:54:12 <kmc> yeah, Scheme allows a nice set of punctuation in names
05:54:17 <kmc> not having to support infix operators
05:54:28 <ivanm> yeah, the cheats...
05:54:41 <kmc> you could also support infix but require whitespace
05:55:04 <ivanm> which makes sections harder to write
05:55:15 <dark> infix needing whitespace makes me to think about unix's expr
05:55:16 <kmc> this is what agda does
05:55:24 <ivanm> since most people tend to write them as (5+) rather than (5 +)
05:55:45 <kmc> i don't think needing to write (5 +) would be a great loss
05:55:46 <dark> kmc, to talk about it, agda syntax is, on surface, surperb
05:56:32 <dark> also, C++ and its >>
05:56:42 <dark> kmc, it works but is annoying
05:57:12 <kmc> the problem there is twofold
05:57:18 <dark> camel case works too, it annoys me, but kind of works
05:57:26 <kmc> 1) use of overloading to recycle names without regard to semantic consistency
05:57:44 <kmc> 2) overloading existing operators without the ability to define new ones
05:58:25 <dark> I would say that 2) is ok, but haskell has a nice set of unconventional operators
05:59:18 <kmc> i don't think (2) is ok.  it encourages unnatural APIs which are shaped by unrelated concerns
05:59:26 <kmc> see: Boost.Spirit
05:59:35 <Twey> It's not annoying… it's consistent.  You should be doing it anyway.
05:59:53 <kalven> if 2) was allowed then there would be plenty of people bitching about that instead.
05:59:56 <kmc> but, ultimately, this is all syntax, and thus subject to a high noise:significance ratio in discussion
06:01:04 <ksf> SCNR
06:01:16 <ksf> as I saw the blog topic, I just had to submit it with that title.
06:01:19 <ksf> http://www.reddit.com/r/programming/comments/cwtix/haskell_floating_garbage/
06:02:53 <ClaudiusMaximus> urgh, it sorta works, but there must be a better way in Haddock to get pragmas to appear in the html: -- @&#x7B;-&#x23; LANGUAGE TemplateHaskell, ScopedTypeVariables &#x23;-&#x7D;@
06:03:37 <dark> ClaudiusMaximus, CDATA?
06:04:40 <dark> ps: http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Token.html has an example parser in the new api
06:04:50 <dark> looks cleaner *.*
06:06:19 <ClaudiusMaximus> dark: hmm
06:07:22 <ivanm> ClaudiusMaximus: maybe try using \ to escape {, #, etc.?
06:09:20 <osaunders> How do you interactively use functions from a file loaded in GCHi that has a main declaration?
06:09:26 <eikke_> if I got a C function which never returns (blocks, should normally run in a thread), whats the best approach to wrap this?
06:09:33 <osaunders> ...they're all out of scope apparently.
06:09:46 <Nibble> my compiler can't find System.Enviroment
06:10:02 <kmc> eikke_, "foreign import" it, don't mark the import "unsafe", compile with ghc -threaded
06:10:15 <kmc> make the call from its own forkIO'd thread
06:10:46 <kmc> you should not need forkOS
06:11:26 <kmc> osaunders, i'm confused, what's special about your file?
06:11:53 <Nibble> any ideas?
06:11:54 <osaunders> kmc: It has no "module X where" at the top and a main.
06:12:09 <kmc> then you should be able to see everything
06:12:14 <kmc> from "ghci foo.hs"
06:12:24 <kmc> the presence of a binding named "main" does not specially change the behavior
06:12:25 <osaunders> kmc: If I remove main, no problem. If I add a "module X where," also no problem.
06:12:30 <kmc> really?
06:12:59 <osaunders> Yep.
06:13:01 <EvanR> if i remember correctly i need module Main where
06:13:06 <EvanR> you need
06:13:24 <kmc> osaunders, adding "main" to my test module does not hide the other names from ghci
06:13:35 <kmc> do you know why it does in your case?
06:13:48 <kmc> osaunders, perhaps you have a compiled .o file for the module sitting around
06:13:54 <kmc> and ghci is loading that
06:14:06 <osaunders> I'm specifying .hs explictly.
06:14:16 <kmc> yes but does the .o file exist and if so, did you try removing it
06:14:23 <osaunders> Let me do a sanity check here.
06:14:36 <kmc> if you say "ghci foo.hs" and foo.o exists, it will load it
06:14:41 <kmc> if it's not out of date
06:14:43 <Nibble> Guys, I try to do :m +System.Enviroment in ghci. but get error message Could not find module `System.Enviroment':
06:15:27 <osaunders> Yep. Prompt is Main> when a main is present and QGen> (name of the file) when I remove main or specify Module QGen where.
06:15:42 <osaunders> When prompt is Main> top-level functions are out of scope.
06:15:45 <kmc> you want it to say *Main or *QGen
06:15:45 <ClaudiusMaximus> ivanm: i tried escaping \{-# with no success, didn't think about {-\#
06:15:54 <ClaudiusMaximus> Nibble: +n (spelling)
06:16:01 <kmc> * indicating that it's interpreting the file, and therefore can see everything
06:16:03 <osaunders> Ah yes. What does * signify?
06:16:04 <eikke_> kmc: doesnt really work, strange enough
06:16:06 <ivanm> ClaudiusMaximus: or even \{-\#, or maybe \{\-\# !
06:16:06 <ClaudiusMaximus> :t System.Environment.getArgs
06:16:06 <ivanm> ;-)
06:16:07 <lambdabot> IO [String]
06:16:14 <kmc> does the .o file exist and if so, did you try removing it
06:16:22 <kmc> eikke_, what goes wrong?
06:16:26 <ivanm> ClaudiusMaximus: closing bracket could also be tricky if you have CPP enabled in your file
06:16:35 * ivanm -> land of nod
06:16:41 <ClaudiusMaximus> g'night ivanm 
06:16:43 <eikke_> kmc: I'm not sure. might be an issue in the C lib itself
06:16:44 <Nibble> ClaudiusMaximus: what? how would that work?
06:16:57 <osaunders> kmc: It did, I removed it, same problem.
06:17:03 <Nibble> It says it can't find the module
06:17:18 <ClaudiusMaximus> > "Enviroment" == "Environment"
06:17:19 <lambdabot>   False
06:17:36 <eikke_> kmc: I suspects it keeps running int he main thread
06:17:45 <kmc> eikke_, you built with ghc -threaded?
06:17:58 <kmc> that should make FFI calls non-blocking unless marked "unsafe"
06:19:48 <eikke_> yes, both the lib and my executable
06:20:39 <eikke_> hmh, my bad
06:20:43 <eikke_> seems to work now
06:21:12 <dark> parse (reservedOp (makeTokenParser haskellDef) "a") "" "a" -- this returns Right (), shouldn't it somehow return the matched text? (on the right branch, since left is the error condition)
06:23:09 <dark> reservedOp :: GenTokenParser s u m -> String -> ParsecT s u m ()
06:23:21 <dark> reservedOp produces a parser that returns.. unit? õ.o
06:23:47 <dark> it somehow tweaks on some "state" to actually do something?
06:23:53 <osaunders> kmc: OK I think I was wrong.
06:24:13 <yottis> dark: maybe useful to see if the input matches at all or something like that?
06:24:24 <dark> yottis, it matches
06:24:27 <osaunders> kmc: Sorry. That was a bit of a waste of time.
06:24:51 <dark> parse (reservedOp (makeTokenParser haskellDef) "a") "" "n" --> Left (line 1, column 1): unexpected "n" expecting "a"
06:25:29 <dark> yottis, ah, you mean, the parser?
06:25:52 <dark> it is somehow combined into a larger thing for building, as it seems, the AST
06:25:55 <yottis> yes
06:27:22 <h_noob> hi there
06:27:35 <leimy> Howdy
06:28:08 <h_noob> how do I parse string litarel OR number - following construction fails due to type mismatch: parseKeyPair = sepBy1 (pStringLiteral <|> pNatural) pColon
06:28:21 <h_noob> what should I use instead of pStringLiteral <|> pNatural?
06:28:43 <dark> pNatural returns the int itself, I think
06:28:51 <dark> it's parsec 2 or 3?
06:29:18 <dark> h_noob, what you want is something like Left of Int | Right of String, right?
06:29:32 <dark> or you want the int as string?
06:29:38 <h_noob> dark: not sure in both cases :)
06:29:55 <h_noob> I think string representation of Int would be easiest
06:30:03 <h_noob> how do I do that?
06:30:32 <dark> you can do something like sepBy1 (string.. <|> (many1 digit)) pColon
06:30:41 <dark> for some "digit" parser parser
06:30:46 <dark> again, it's parsec 2, right?
06:30:46 <kmc> dark, the reservedOp parser doesn't say what string it matched because you already know
06:30:59 <ClaudiusMaximus> hmm, I have some code like:  hType :: Type -> HType  ;   hType (AppT (AppT (TupleT 2) t1) t2) = HTTuple (map hType [t1, t2])  -- any nice way to extend this to arbitrary n-tuples (well, i could use template haskell...)
06:31:01 <kmc> it only matches one thing, which you provided when constructing the parser
06:31:12 <benmachine> kmc: that's not consistent with e.g. the 'char' parser
06:31:15 <dark> kmc, it "extracts" what is a reservedOp from the language definition (what the language thinks is a reserved op), right?
06:31:16 <h_noob> dark, probably it's parsec 3
06:31:27 <kmc> that's true benmachine
06:31:54 <kmc> dark, doesn't reservedOp take two args? a language and the specific reserved op to match?
06:31:54 <dark> h_noob, are you following some tutorial? all tutorials I find is about parsec2 (I'm on this thing of doing things I don't understand much,in haskell)
06:32:06 <dark> kmc, ... yes..
06:32:25 <kmc> so, it will only match the one you say to match
06:32:36 <ClaudiusMaximus> yikes, ghc just hit 3.5GB with this TH code...
06:32:40 <kmc> unless you care about how much whitespace was before/after, there is no point to it returning a value
06:32:43 <dark> yes, but.. why to ask for a language, then?
06:32:56 <kmc> and if you do care about that, don't use the token parser stuff
06:33:15 <h_noob> dark, thanks, it works with "many"...
06:33:29 <kmc> dark, it takes the language in order to know how to handle whitespace
06:33:32 <kmc> in particular, comments
06:33:41 <dark> ah........ wow.....
06:35:04 <Gracenotes> I feel somewhat guilty using mappend on a function with 4-5 arguments. like I'm making GHC chase through those instances against its will.
06:38:08 * ksf considers getting rid of static typing
06:38:16 <ksf> stuff'd be soooo easy then.
06:38:28 <Ke> bheretic
06:38:31 <Ke> -b
06:38:40 <deteego> ksf: stop going to the dark side
06:39:25 <ksf> well yes but isn't stuff like HList the dark side, too?
06:39:32 <copumpkin> static typing is awesome
06:39:36 <copumpkin> just gotta do it right :P
06:39:58 <kmc> pfft who needs types, i never make mistakes
06:40:24 <kmc> types are just a restriction that gets in the way of me writing whatever program i want, no matter how unreasonable
06:40:30 <Gracenotes> the compiler is hungry for more information about how to optimize your programs, but it needs types
06:40:37 <vanadium> How would you do printf without types
06:40:38 <Gracenotes> will you starve it of this information?
06:40:39 <ksf> ...or is there a sane alternative to HList? I only need option types
06:40:41 <EvanR-work> kmc: guy seriously trolled me this line the other day!
06:40:55 <EvanR-work> except for the unreasonable part
06:41:10 <kmc> well a lot of people just don't understand what types are for
06:41:16 <kmc> and a lot of others have this bullshit leet hacker ego
06:41:39 <benmachine> just out of interest, does this do what I think it does:
06:41:40 <benmachine> (x -> Int) -> (forall y. (y ~ x, Eq y) => y -> Int) -> Int
06:41:54 <benmachine> hmm I could probably check
06:41:55 <kmc> how would i know what you think it does?
06:41:57 <Gracenotes> vanadium: by interpreting bit patterns according to what the format string says, of course. hello there C.
06:42:20 <benmachine> kmc: okay, "anything interesting"
06:42:29 <kmc> that's a weird type
06:42:34 <benmachine> it is
06:42:45 <kmc> what is the point of quantifying y then restricting it to equal x?
06:42:46 <dark> what is ~?
06:42:53 <kmc> type equality constraint
06:43:00 <kmc> enabled by some GHC extensions, forget which exactly
06:43:03 <kmc> GADTs definitely
06:43:09 <benmachine> TypeFamilies
06:43:23 <copumpkin> not GADTs I don't think
06:43:26 <copumpkin> only TypeFamilies
06:43:35 <copumpkin> you can write a type equality GADT with GADTs though
06:43:35 <kmc> really?
06:43:38 <dark> there is a lot of haskell code that actually declare types
06:43:46 <jmreardon>   
06:43:48 <Ke> Gracenotes: format string is just another undefined behaviour, gcc will catch those at compile time
06:43:58 <kmc> the equality coercions are needed to encode GADTs in Fc, but i guess you don't need the syntax in the source language
06:44:10 <benmachine> kmc: are you on haskell-cafe? there's some discussion about use of a typeclass with seq, and some issue about having an Eval constraint on a type doesn't let you tell which one
06:44:13 <EvanR-work> dark: yeah its nice documentation
06:44:14 <benmachine> or, something
06:44:14 <Ke> unless you use non-literal as format string
06:44:22 <kmc> ah
06:44:26 <benmachine> so some people were trying to specify a constraint on only one of the types
06:44:41 <EvanR-work> dark: often you see top level definitions with their types
06:45:00 <benmachine> I was curious to see if I could cheat and use a rankNtype to introduce a context in the middle of the function without doing anything else
06:45:19 <dark> kmc, do you think a typeless haskell could possibly work?
06:45:35 <kmc> dark, very very few languages are typeless
06:45:42 <Gracenotes> what would make it haskell then?
06:45:44 <dark> regardless bad error messages
06:45:45 <kmc> maybe you mean lacking *static* type checking
06:45:53 <EvanR-work> assembly language! ;)
06:46:20 <dark> well, *you* dismissed the types
06:46:22 <dark> =)
06:46:39 <kmc> oh the "who needs types" comment?
06:46:44 <kmc> that was sarcastic ;P
06:47:00 <kmc> lots of people think that way though
06:47:04 <kmc> i was mocking them for cheap laffs
06:47:05 <benmachine> hmm
06:47:08 <jmcarthur> i can't think of a typeless language
06:47:09 <copumpkin> pff, types are overrated
06:47:14 <copumpkin> jmcarthur: untyped lc
06:47:15 <EvanR-work> isSarcasm :: Context -> String -> Bool
06:47:20 <Twey> FORTH is typeless ☺
06:47:27 <tab> jmcarthur: brainfuck :P
06:47:30 <kmc> Perl is kind of typeless, in that when there is a type mismatch it will do its best to attempt some wacky conversion, rather than producing an error
06:47:33 <jmcarthur> copumpkin: i meant one that is used in the real world :P
06:47:34 <benmachine> seems like the y ~ x constraint doesn't stop it being rank-2
06:47:42 <EvanR-work> same in php
06:47:48 <Twey> PHP ditto, but I don't think that exactly counts as typelessness
06:47:57 <robryk> hm.. my cabal wants to reinstall cairo every time it build something dependent on it
06:47:58 <Twey> There are clearly types — it just does implicit conversions of them
06:48:00 <copumpkin> untyped LC is truly untyped :P
06:48:01 <jmcarthur> i consider that weakly typed
06:48:01 <robryk> i have a systemwide older version
06:48:08 <kmc> unix shells mostly handle only strings
06:48:09 <Twey> At least in PHP, you can even check the types
06:48:09 <jmcarthur> (PHP and Perl)
06:48:13 <ksf> well, I need to do run-time constructor matching in any case, and as it seems all my data is going to be single-constructor, the question of static typing becomes keeping track of what can be put into and pulled out of the Dynamic. I don't need to be smart enough to ensure type erasure.
06:48:19 <ksf> (in fact, I can't)
06:48:20 <benmachine> Twey: much good may it do you :P
06:48:24 <Twey> Heheh
06:48:28 <robryk> that is systemwide old versions of its deps; it thinks it was compiled against them earlier
06:48:31 <robryk> any ideas where to look?
06:48:50 * benmachine re-examines that phrase and is a little confused by it
06:49:14 * ksf just goes on and uses Dynamic and hopes that adding safety later is going to be straight-forward type hackery.
06:49:22 <jmcarthur> does the fact that a language lacks static and runtime type *checking* mean that it is typeless?
06:49:27 <jmcarthur> i suppose that would be sufficient...
06:49:29 <benmachine> robryk: see what ghc-pkg list cairo does
06:49:33 * Twey chuckles at the phrase ‘straight-forward type hackery’.
06:49:37 <ksf> there's no typeless languages.
06:49:39 <jmcarthur> i guess more languages are typeless than i at first guessed
06:49:52 <Twey> ksf: Really?
06:49:55 <jmcarthur> ksf: well, there are no typeless *programs* at least
06:50:01 <copumpkin> ksf: untyped lc? :P
06:50:04 <Twey> ksf: You don't consider e.g. FORTH or assembly language to be typeless?
06:50:05 <ksf> in the end, it all ends up as assembly. and div and mov end up operating on different types, even if add doesnt'.
06:50:16 <copumpkin> ksf: languages are independent of implementations
06:50:25 <robryk> benmachine: there is one cairo in ~/.cabal only ; there are two different versions of array; older systemwide, newer in ~/.cabal
06:50:28 <jmcarthur> even untyped lc programs have types, assuming they actually have some purpose
06:50:30 <Twey> Aren't all the types at that level just numbers?
06:50:30 <benmachine> you could compile haskell to untyped lc if you liked >_>
06:50:32 <fasta> copumpkin, not in reality.
06:50:41 <EvanR-work> we had some fun with php recently. a data came in that could possibly by an integer 0, string "0", or any other string. so the condition data == 0 or != 0 failed miserably. because anystring that cant be converted to an int in that context is considered zero. so 'foo' == 0 TRUE
06:50:49 <benmachine> fasta: who needs reality?
06:50:58 <ksf> Twey, well, then there's registers, memory addresses, labels.
06:51:01 <fasta> benmachine, I use it as a substrate for living.
06:51:07 <ksf> those arnen't freely interchangeable.
06:51:10 <Twey> ksf: But they're still all numbers
06:51:19 <jmcarthur> number are representations, not types
06:51:20 <copumpkin> fasta: it's nice to think about things in isolation though, simplifies them
06:51:23 <ksf> ...but the asm parser enforces them.
06:51:25 <benmachine> robryk: I think it's probably a bad idea to install new versions of the array library
06:51:31 <copumpkin> fasta: and when you say "everything has types", then you devalue the meaning of type a bit
06:51:34 <Twey> That's true… perhaps at machine-code level, then
06:51:35 <robryk> why?
06:51:38 <benmachine> guys is the array library one of the ones that you don't want to upgrade
06:51:45 <jmcarthur> that is, the fact that they are numbers is irrelevant to whether it is typed
06:51:50 <ksf> and if you go to the opcode level, the processor will reject many, many programs that aren't well-formed.
06:52:00 <fasta> copumpkin, 1) Yes 2) I didn't say that. 3) I agree with ksf.
06:52:12 <robryk> but why it being the array library causes strange behaviour in cabal when looking at deps?
06:52:15 <copumpkin> fasta: he did though
06:52:28 <fasta> copumpkin, True
06:52:38 <dark> I understand that an instruction operating on a 16-bit word operates on a "type" different from one that takes, say, 32bit-words.. also, floats and such.. alignment requeriments, it has something to do with types
06:52:53 <jmcarthur> copumpkin: all programs have types because, whether they like it or not, programmers mentally assign some sort of meanings to their programs. those types may not be checked by the machine though
06:52:57 <ksf> and when you get to the transistor level, you will see that not everything is connected to everything so the output of one thing obviously has another type than some other output.
06:53:03 <ksf> heck look at the vrml.
06:53:05 <copumpkin> I don't think the fact that our languages get compiled or interpreted on real machines has any bearing as to whether they're typed
06:53:09 <benmachine> robryk: I'm not sure if it's the solution, but the first thing I'd try would be, a. don't ever use cabal upgrade, it's pretty much broken, b. ghc-pkg unregister --user array
06:53:18 <kmc> "programmers mentally assign some sort of meanings to their programs"  <--- not all of them...
06:53:19 <robryk> but i need it
06:53:19 <EvanR-work> jmcarthur: so lambda calculus has types ;)
06:53:26 <robryk> at least it got pulled with something else
06:53:31 <copumpkin> my programs are all meaningless :)
06:53:34 <benmachine> robryk: did you use cabal upgrade?
06:53:36 <fasta> copumpkin, I mostly meant that all languages are designed to run on specific classes of machines.
06:53:41 <jmcarthur> kmc: the only programs i can think of that are meaningless are those that were intended to be meaningless
06:53:42 <copumpkin> fasta: ah, yes
06:53:43 <robryk> hm... not sure
06:53:48 <ksf> even lisp, even after getting rid of numbers etc, has two types: cons cells and atoms.
06:53:57 <copumpkin> fasta: except untyped lc, which was designed before we had machines :P
06:53:57 <dark> if the operand can't possibly be a non-aligned pointer, and you pass to it a number from some random sum, then you have a type error - caught at runtime
06:53:59 <benmachine> robryk: cabal upgrade fetches the latest of everything, even if it's not necessary
06:53:59 <robryk> ok, will check
06:54:03 <copumpkin> or combinator calculus etc.
06:54:04 <Gracenotes> @instances MonadPlus
06:54:05 <benmachine> robryk: which tends to break stuff sometimes
06:54:05 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
06:54:16 <robryk> everything or everything underneath (in dep tree?)?
06:54:17 <Gracenotes> where are all these instances...
06:54:25 <dark> so illegal instructions are kind of type errors in this sense
06:54:41 <fasta> copumpkin, for example a language based on actual physics would be nice to have. Writing a compiler for it would be more or less challenging, but at least your programs will work for basically forever.
06:55:08 <EvanR-work> yeah right, what machine doesnt run down
06:55:13 <copumpkin> fasta: sounds interesting
06:55:16 <benmachine> robryk: all the dependencies
06:55:21 <robryk> ok
06:55:32 <ksf> fasta, vrml?
06:55:41 <robryk> oh well.. will have to recompile half of it them. thanks.
06:55:43 <robryk> *then
06:55:44 * ksf isn't sure about the abbrev
06:55:52 <benmachine> robryk: er, maybe
06:55:54 <Nibble> is there any function that works like takeWhile and one that works like dropWhile but doesn't exit once something that the predicate returns false happens?
06:55:55 <ksf> well, there's hardware description langugages.
06:55:58 <benmachine> robryk: that was just a guess on my part
06:55:58 <dark> fasta, problem is, how to model some physical environment using data? when your precision ends, your problems begin
06:55:58 <EvanR-work> http://en.wikipedia.org/wiki/VRML
06:55:59 <EvanR-work> lol
06:56:00 <fasta> ksf, you mean vhdl?
06:56:03 <ksf> yes.
06:56:18 <benmachine> robryk: but I suppose it's wortha  try
06:56:24 <benmachine> why is cabal so prone to broken
06:56:24 <fasta> dark: modelling 3d environments works fine in games.
06:56:40 <ksf> fasta, iff you know the tricks.
06:56:45 <robryk> it's less prone to broken than various gentoo package managers
06:56:45 <Gracenotes> Nibble: filter?
06:56:57 <benmachine> fasta: except for when it doesn't :P
06:57:07 <dark> fasta, but you still have problems in modelling reality in general
06:57:21 <Gracenotes> really though, where is the IO instance for MonadPlus in GHC 6.12?
06:57:28 <ksf> precision is a problem in large worlds, and you can be sure that the game isn't simulating stuff that happens 200km away.
06:57:29 * benmachine vaguely recalls games where if you walked at a particular wall from a particular angle you passed through it, &c.
06:57:29 <robryk> look at anything-updater there
06:57:30 <zygoloid> a compiler from a programming language to some 2d/3d physics engine would be awesome
06:57:30 <Argue> bonus your wiggler is missing round brown donut patterns on its body
06:57:48 <fasta> You should be able to design your CPU in some kind of language (which can also be produced and rendered) and this same input together with a generic compiler should be able to produce a compiler specialized for that platform.
06:57:58 <dark> it looks like newtonian physics is more related to our relative scale than to the reality per se
06:58:09 <EvanR-work> meh. again 'physics' means rigid body dynamics
06:58:18 <EvanR-work> i figured wed go past that and have electromagnetic computation ;)
06:59:01 <fasta> Unfortunately, nobody does what I describe because it is beyond our tiny machines to compute, AFAIK. 
06:59:01 * ksf thinks he's actually re-implementing typeclasses, here.
06:59:38 <ksf> ...and cpu design is influenced by quantum mechanics.
06:59:55 <dark> fasta, i think one can do hardware description in haskell..
07:00:01 <ksf> and quantum mechanics are darn complex. in the beginning, they couldn't even calculate helium atoms.
07:00:13 <fasta> dark: I know about those. 
07:00:18 <ksf> hydrogen was all they had the compuitng power for.
07:00:42 <EvanR-work> yeah, pencil and paper ;)
07:00:57 <fasta> I read some university level biochemistry. I was quite impressed how far we already are. 
07:02:44 <Nibble> Gracenotes: thanks
07:11:53 <cncl> does ghc generally compile explicit CPS to faster code than returning tuples
07:12:46 <dark> cncl, i heard that cps is the way to go for functional code ( == i know nothing about this but i wanted to talk)
07:12:57 <cncl> haha
07:13:06 <cncl> cps has an obfuscating effect
07:13:35 <dark> all machine languages has some degree of mangling..
07:13:44 <dark> ah
07:13:49 <cncl> i meant cps code is a little harder to read, usually
07:13:55 <dark> you mean, cps on *your* code
07:14:12 <kmc> there was an optimization in GHC, "vectored returns", which in the case of returning a tuple would act a little like a local CPS transform
07:14:24 <dark> cncl, doesn't ghc "remove" some tuples?
07:14:28 <cncl> that is what i assumed
07:14:29 <Gracenotes> if what you want from CPS is laziness, at least that's not needed in Haskell, in contrast to other FP languages
07:14:35 <kmc> and it was taken out as being not worthwhile
07:14:45 <cncl> i see
07:14:45 <kmc> due to some other optimizations picking up the slack, i believe
07:14:47 <kmc> but not sure which
07:14:55 <kmc> wait sorry
07:15:01 <kmc> i don't think vectored returns would matter for tuples
07:15:10 <cncl> in my case, the design lends itself well to either returning tuples, or cps
07:15:12 <kmc> 'cause there's only one place you would return to
07:15:34 <cncl> speed is not really important, but i was kind of curious.
07:15:38 <kmc> it would matter in the case of a sum type, like Either
07:16:41 <cncl> some of the faster haskell code i've seen uses cps or ContT
07:17:54 <kmc> there is http://hackage.haskell.org/packages/archive/monad-ran/0.1.0/doc/html/Control-Monad-Ran.html
07:18:54 <cncl> i can't believe i can read that description and understand it
07:19:02 <cncl> a year ago i would have just laughed
07:21:25 <h_noob> I have problem parsing nested structures with parsec: http://pastebin.org/445531 - how do I properly make parser re-entrant?
07:21:28 <dolio> There was a time in the past when implementing things via continuation passing compiled better, at least.
07:21:34 <dolio> Like LogicT and stuff.
07:21:39 <dolio> I'm not sure what the status is these days.
07:23:03 <robryk> ghc-pkg describe reports something else than what is in ~/.ghc/package.conf.d
07:23:12 <robryk> it reports different deps
07:23:24 <robryk> on systemwide packages and not userwide ones
07:23:29 <dolio> Transforming via codensity sometimes helps, too.
07:24:08 <robryk> what can it be?
07:24:23 <robryk> oh, sorry
07:24:28 <robryk> double packages
07:24:37 <McManiaC> http://npaste.de/f2/ ← pretty cool :D
07:25:08 <cncl> i haven't played with codensity yet, i should take a look (though it's not needed in this case)
07:25:18 <aavogt> McManiaC: that's similar to haskelldb
07:25:41 <aavogt> though you have to run a separate program for code generation there
07:26:25 <robryk> oh. i see. cabal is strange.
07:26:40 <robryk> my systemwide array is version 3.0, local is 3.1
07:26:54 <robryk> so it wants to compile local haskell98, because array is newer
07:27:15 <robryk> then it ends up with two instances of the same version of haskell98
07:27:18 <robryk> and is confused
07:27:56 <aavogt> robryk: some of that strangeness might be explained if you consider that systemwide packages shouldn't depend on per-user packages
07:28:04 <robryk> they don't
07:28:20 <robryk> i have a systemwide array-3.0 and haskell98-something
07:28:37 <robryk> i have local array-3.1
07:28:45 <aavogt> so if you install a library --user first, then need it for a --global package, you'll get two copies
07:28:55 <robryk> when something i try to install locally wants haskell98
07:29:12 <robryk> it installs a per-user haskell98 because per-user array is newer
07:29:25 <robryk> and ends up with a bizarre (for itself) situation 
07:29:42 <robryk> yes, it should do it
07:29:57 <robryk> but the manual states that this is a Bad Thing
07:30:31 <aavogt> what happens if you install with   --constraint="array == 3.0" ?
07:30:37 <McManiaC> aavogt: we're working on a project which uses haskell functions like filter, map etc pp to work on databases :>
07:30:44 <robryk> hm. let me check
07:31:02 <aavogt> perhaps the older one is broken?
07:31:10 <aavogt> McManiaC: did you look at haskelldb?
07:31:17 <robryk> array-3.0 not available
07:31:22 <robryk> perhaps shadowed
07:31:38 <McManiaC> aavogt: yeh, its not exactly the same approach tho
07:31:44 <robryk> i don't think so. i compiled darcs with it today
07:33:36 <robryk> can i get cabal to completely forget about global packages?
07:34:44 <copumpkin> npouillard: when I requested a flattr invite it took less than a day to arrive
07:36:12 <copumpkin> omg an edwardk
07:36:16 * edwardk hides.
07:36:17 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
07:36:31 * edwardk fails to hide well enough and is served a summons by lambdabot.
07:36:37 <copumpkin> lol
07:37:12 <copumpkin> okay, does anyone know of a good reference for HOWTO write a good Show instance?
07:37:24 <aavogt> shows
07:37:25 <copumpkin> I feel like I should be using shows
07:37:26 <copumpkin> I have a GADT and can't derive it
07:37:32 <ksf> http://pastebin.com/ABJXiT8F
07:37:37 <ksf> how to do what I want to do?
07:37:43 <aavogt> @google derive gadt
07:37:45 <lambdabot> http://hackage.haskell.org/package/derive-gadt
07:37:45 <lambdabot> Title: HackageDB: derive-gadt-0.1.1
07:37:55 <ksf> err http://pastebin.com/1Hjzt36R
07:38:03 <ksf> ...remove that stray p there.
07:38:08 <copumpkin> aavogt: yeah, saw that, but wanted to see how to write it myself
07:38:18 <copumpkin> ksf: you sure you want to be woring with Ts and Fs?
07:38:21 <copumpkin> working
07:38:30 <ksf> nope.
07:38:37 <ksf> but the pattern matching is the real problem.
07:38:40 <copumpkin> ksf: with a MPTC you can have a type equality constraint
07:38:47 <aavogt> copumpkin: that package is likely broken for ghc-6.12 due to haskell-src-meta being unloved
07:39:11 <copumpkin> ksf: you can probably do the same in TFs too, but I don't like working with explicit trues and falses anyway
07:39:24 <edwardk> it is loved, its maintainer is just vanished
07:39:38 <copumpkin> ksf: did you try sticking a (x ~ y) => x (y, xs) constraint in?
07:39:40 <ksf> ...well, remove the last case, return x instead of T
07:39:50 <ksf> type instances don't take contexts.
07:39:55 <copumpkin> I didn't think so
07:40:02 <edwardk> if you wanted to take over maintainership you could probably do so, mmorrow hasn't responded to any hails from the community for 6 months
07:40:10 * copumpkin pouts
07:40:26 <copumpkin> well if he still hasn't turned up by the time I reappear in the US, I'll try calling around :P
07:40:56 <aavogt> McManiaC: how do you address queries that generate tables with more columns that you start with?
07:41:04 <copumpkin> ksf: then just write an MPTC
07:41:05 <benmachine> someone said haskell-src-meta?
07:41:06 <copumpkin> or that's what I'd do
07:41:14 <benmachine> I've got that building on 6.12
07:41:20 <benmachine> I was going to offer to take maintainership
07:41:25 <aavogt> yes, it's not on hackage though
07:41:30 <benmachine> I was planning to look at which of its revdeps I broke though
07:41:32 <benmachine> first
07:41:35 <copumpkin> edwardk: I have a random question for you!
07:41:36 <benmachine> but I don't have to :>
07:41:56 * edwardk wonders if a random answer will suffice.
07:42:03 <copumpkin> I hope not
07:42:15 <aavogt> else you end up with copy-pasta here http://hackage.haskell.org/package/haskell-src-exts-qq
07:43:00 <benmachine> oh my goodness I had that exact same ide
07:43:02 <benmachine> idea
07:43:02 <copumpkin> edwardk: do you know how Algebra.RingSolver in agda or newring in coq work? they reduce expressions to polynomials and then normalize them (Horner scheme) and check the normal forms for equality. Do you know if such an approach would work for inequalities too?
07:43:09 <benmachine> antiquoting with splices, anyway
07:43:15 <jmcarthur> benmachine: please! i have a couple projects on hold due to hsm not working
07:43:38 <aavogt> hmm, what does this one mean http://hackage.haskell.org/package/haskell-src-meta-mwotton
07:43:47 <McManiaC> aavogt: what do you mean?
07:44:13 <benmachine> aavogt: oh heh, that's probably pretty much the same as what I've done
07:44:14 <aavogt> McManiaC: I mean a join of some tables
07:44:25 <siracusa> aavogt: This one is the new version for TH-2.4
07:44:27 <edwardk> copumpkin: depends on how strong their guarantees are. if they truly reduce to a normal form then you should be able to check inequality as well, if the normal for is only approximate (e.g. with robdds) then that'll fail.
07:45:15 <copumpkin> nah, it's exact
07:45:17 <edwardk> but you can do all sorts of things to check inequalities
07:45:28 <copumpkin> edwardk: on arbitrary (semi)rings?
07:45:32 <edwardk> *cough* quickcheck
07:45:33 <benmachine> bah, he just commented out renameTs, I actually fixed it
07:45:36 <copumpkin> edwardk: lol
07:46:41 <aavogt> siracusa: it would be helpful if the description said something like that... also explicit template-haskell dependencies don't work so well with cabal right now
07:47:36 <aavogt> it works better if you just look at the ghc version: you can't upgrade major versions of TH (and maybe not minor versions either)
07:49:05 <siracusa> aavogt: Well, I'm not the maintainer. IMO haskell-src-meta should have been updated instead of a new fork.
07:49:35 <benmachine> yes I think so too
07:49:59 <benmachine> aavogt: why don't TH dependencies work?
07:50:06 <siracusa> I just know that this is the last version from Matt Morrow's repo.
07:50:31 <benmachine> I mean, yes they're coupled with GHC dependencies
07:50:34 <aavogt> benmachine: if you build with ghc-6.10 cabal-install will try to get template-haskell-2.4, which breaks
07:50:39 <benmachine> ah
07:50:53 <benmachine> but it breaks rather than trying to install it, right?
07:50:56 <benmachine> I mean
07:51:14 <benmachine> it breaks immediately
07:51:54 <copumpkin> hmm, haskell-mode for vim seems to have added two ugly menus to the top of my macvim
07:52:21 <aavogt> I think haskell-src-meta uses some quoting which will be a compile-time error when mixing wrong template-haskell versions
07:52:42 <benmachine> no I mean, template-haskell 2.4 won't compile on ghc 6.10
07:52:47 <benmachine> so cabal will just fail there
07:52:49 <benmachine> I think/hope
07:53:36 <copumpkin> anyone know how to get rid of them?
07:55:25 <zygoloid> benmachine: i'd suggest, since mmorrow has been gone for so long, that you send him an email, wait a week, then just take over ownership of haskell-src-meta.
07:56:06 <benmachine> zygoloid: hmm, okay
07:56:14 <zygoloid> i think it's time to face the unpalatable assumption that he may not be coming back
07:56:20 <benmachine> p.s. is it Forbidden to reply to 10-day-old -cafe threads
07:57:05 <Martty> wtb: suggestions for faster implementation of:
07:57:06 <Martty> eo [] = []
07:57:07 <Martty> eo (x:xs) = if isEven x then x : eo xs else (eo xs) ++ [x] where isEven = (\x -> (mod x 2) == 0)
07:57:17 <fasta> benmachine, there is not really an effective way to stop you, so there is also no reason to ask. 
07:57:41 <benmachine> fasta: well, I like to know I'm not upsetting anyone
07:57:45 <fasta> benmachine, e.g., it could just as well be that your listed name is not your real name. 
07:57:46 <zygoloid> Martty: eo xs = filter even xs ++ reverse (filter odd xs)
07:58:07 <fasta> benmachine, if it is on-topic I wouldn't even care about years. 
07:58:07 <Martty> figures even already exsited...
07:58:17 <Martty> @src even
07:58:17 <lambdabot> even n = n `rem` 2 == 0
07:58:28 <benmachine> fasta: okay, cool
07:58:30 <Martty> @src rem
07:58:30 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:58:33 <Martty> @src mod
07:58:34 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:58:37 <fasta> benmachine, but I am sure you can find someone with a different opinion.
07:59:08 <zygoloid> Martty: if you're really worried about performance, it might be worth trying eo xs = as ++ reverse bs where (as,bs) = partition even xs
07:59:22 <zygoloid> (criterion is supposed to be pretty good for that sort of performance comparison)
07:59:49 <Martty> zygoloid its okay all these seem pretty fast anyways, thanks
08:00:00 <zygoloid> but the asymptotic win comes from not using ++ repeatedly with a large LHS
08:00:12 <benmachine> Martty: do you mind which order the odd numbers end up in?
08:00:24 <Martty> benmachine no
08:00:35 <benmachine> ah well then, bin the reverse
08:00:44 <zygoloid> @type uncurry (++) . partition even
08:00:45 <lambdabot> forall a. (Integral a) => [a] -> [a]
08:00:49 <benmachine> :)
08:00:58 <zygoloid> > (uncurry (++) . partition even) [1..10]
08:00:59 <lambdabot>   [2,4,6,8,10,1,3,5,7,9]
08:01:24 <Martty> @src partition
08:01:24 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
08:01:24 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
08:01:24 <lambdabot>                               | otherwise = (ts, x:fs)
08:01:30 <Martty> amagod
08:07:41 <EvanR-work> can newtypes be polymorphic
08:07:46 <EvanR-work> newtype Foo a = ?
08:07:59 <olsner> EvanR-work: yep!
08:08:04 <EvanR-work> cool
08:08:16 <azaq23> what does the tilde do in the definition of select?
08:08:37 <aavogt> @src Endo
08:08:38 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:08:46 <Twey> azaq23: Lazy pattern match
08:09:03 <olsner> (not sure if it's called polymorphic when talking about newtypes, but they can take type parameters)
08:09:05 <Twey> Assume the pattern matches and use it as if it does; if it doesn't, throw an error when you try to use the value
08:09:07 <azaq23> Twey: thanks
08:09:11 <EvanR-work> how can i easily 'unwrap' the new type?  i.e. (unwrap foo) to get the goodness inside
08:09:14 <ksf> class Elem x xs r | x xs -> r where
08:09:14 <ksf> instance Elem x (x,ys) T
08:09:14 <ksf> instance Elem x ys t => Elem x (y,ys) t
08:09:14 <ksf> instance Elem x Nil F
08:09:16 <ksf> \o/
08:09:18 <c_wraith> Endo is just a newtype around a -> a
08:10:12 <ksf> dunno how to get rid of T and F, though.
08:10:24 <EvanR-work> unwrap (Foo x) = x
08:10:26 <EvanR-work> ?
08:10:46 <c_wraith> yes, that works.
08:10:55 <ksf> newtype Foo a = Foo {unFoo :: a}
08:11:04 <EvanR-work> can i get around this with type instead of newtype, i just want to shorted the type signatures
08:11:20 <EvanR-work> shorten
08:11:25 <EvanR-work> type Foo a = ?
08:11:32 <aavogt> they are shorter if you don't write them
08:11:47 <EvanR-work> the thing is im trying to debug compiler errors so i *am* writing them
08:11:57 <EvanR-work> to see where i went wrong
08:12:00 <aavogt> btw, haddock seems to add inferred types to documentation now
08:12:06 <copumpkin> ksf: the T and F really just represent whether a class has an instance r not
08:12:49 <copumpkin> so (xs `Contains` x) => restOfTypes
08:13:10 <copumpkin> where Contains is that kind of recursive MPTC relation
08:13:24 <EvanR-work> cool it works
08:13:37 <EvanR-work> type Board a = Array ((Int,Int),(Int,Int)) a
08:14:26 <edwardk> EvanR-work: note that the problem with using 'type' is that you can't declare instances for your 'type's, only newtypes/data/etc.
08:14:42 <EvanR-work> not using type classes at the moment
08:14:57 <EvanR-work> i would use newtype if i really wanted a new type
08:15:04 <edwardk> this is probably not an issue while you don't have much encapsulation, but later on it may be a decision you want to revisit, especially if you are writing a library
08:15:05 <EvanR-work> but i want a type synonym
08:15:07 <edwardk> yep
08:15:07 <ksf> ...I can write wrappers that hide the T and F from the call, but that doesn't make the errors more readable.
08:15:20 <aavogt> for clarity `type' should be called `oldtype'
08:15:26 <edwardk> aavogt: *groan*
08:15:33 <EvanR-work> 'alias'
08:15:56 <ksf> hmmm I could replace T and F with Elem and NotElem
08:16:01 <robryk> what might be wrong if rnf and NFData are lacking?
08:16:21 <robryk> (strict-concurrency can't compile)
08:16:22 <copumpkin> robryk: did you import Control.Parallel.Strategies?
08:16:28 <copumpkin> oh
08:16:38 <copumpkin> it got moved to deepseq recently
08:16:44 <copumpkin> not sure if rnf stayed in place
08:19:06 <benmachine> copumpkin: I think it moved but got re-exported
08:19:27 <EvanR-work> :t (!)
08:19:28 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
08:19:40 <Nibble> @src head
08:19:40 <lambdabot> head (x:_) = x
08:19:40 <lambdabot> head []    = undefined
08:19:49 <Nibble> why is it undefined?
08:19:59 <EvanR-work> what do you want it to compute to?
08:20:14 <EvanR-work> theres no good answer. but if you want to you can defined your own head
08:20:14 <Nibble> wouldn't it be better if it was Nothing
08:20:28 <EvanR-work> it cant be nothing
08:20:30 <EvanR-work> :t head
08:20:30 <lambdabot> forall a. [a] -> a
08:20:30 <c_wraith> benmachine: parallel doesn't export RNF anymore
08:20:35 <robryk> benmachine: unfortunately not
08:20:48 <Nibble> EvanR-work: well, is there no "safe" standard implemention of head
08:20:53 <robryk> and that breaks strict-concurrency
08:20:54 <EvanR-work> are you sure?
08:21:12 <EvanR-work> safeHead :: [a] -> Maybe a
08:21:16 <EvanR-work> safeHead [] = Nothing
08:21:21 <EvanR-work> safeHead (x:xs) = Just x
08:21:25 <benmachine> safeHead = listToMaybe
08:21:26 <c_wraith> :t listToMaybe
08:21:27 <lambdabot> forall a. [a] -> Maybe a
08:21:40 <benmachine> safeHead = foldr (Just . const) Nothing
08:21:56 <c_wraith> robryk, just install strict-concurrency with a constraint on parallel to use the older version.
08:22:10 <robryk> ok; thanks
08:22:19 <EvanR-work> Nibble: listToMaybe ;)
08:22:21 <Nibble> EvanR-work: I asked, if there was no safe on.
08:22:31 <benmachine> that'd be --constraint='parallel < 2' ?
08:22:33 <robryk> shall i leave a note somewhere about it?
08:22:39 <Nibble> EvanR-work: thanks
08:22:46 <c_wraith> benmachine, < 3
08:23:00 <benmachine> aww, <3 you too
08:23:01 <c_wraith> robryk, email strict-concurrency's maintainer
08:23:09 <c_wraith> which is probably dons
08:23:16 <benmachine> it is, according to cabal info
08:23:34 <robryk> ok
08:23:43 <EvanR-work> Nibble: a lot of times you use head in a situation where you it cant be empty (because empty is handled in another definition), and listToMaybe is redundant. ... but these are the times when a mistake could crash your pure code...
08:23:46 <benmachine> hmm
08:23:55 <benmachine> strict-concurrency already depends on the deepseq package
08:24:11 <benmachine> errr
08:24:11 <benmachine> no
08:24:13 <benmachine> parallel does
08:24:19 <benmachine> right that makes sense
08:24:22 <benmachine> ignore me never mind
08:26:11 <c_wraith> yeah, that change to parallel was only made a couple weeks ago, and it's broken a few things.
08:26:41 <c_wraith> mostly because package authors refuse to put upper bounds on their dependencies
08:27:50 <robryk> upper bounds? 
08:28:00 <robryk> ah, version
08:28:03 <c_wraith> yeah
08:28:25 <robryk> but it isn't simple to put them in reasonably
08:28:39 <robryk> you don't want to increase them with every new version of another package
08:28:52 <robryk> oh, that changed major
08:28:54 <robryk> nevermind
08:28:56 <c_wraith> yeah
08:29:58 <robryk> are there any buildlogs/information which version combinations did compile somewhere (on hackage?)?
08:30:28 <benmachine> hackage does have build logs, but only for one combination
08:30:37 <benmachine> typically the latest
08:31:03 <benmachine> with version constraints, mostly you hope the package is following the package versioning policy
08:31:19 <benmachine> for which the first two numbers are the major version
08:31:44 <benmachine> so you do array == 0.3.* etc.
08:33:01 <robryk> and when that log is the exact failure you see it's little help..
08:37:12 * hackagebot scan 0.1.0.6 - lexical style suggestions for source code  http://hackage.haskell.org/package/scan-0.1.0.6 (ChristianMaeder)
08:40:35 <EvanR-work> > length (replicate 10 undefined)
08:40:36 <lambdabot>   10
08:41:09 <benmachine> > length (fix $ replicate 10)
08:41:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:41:10 <qewr> Hi. I'm thinking of starting a web programming project for my university, and I want to use Haskell. As this application will have to be deployed for "Real World" use, would Happstack be the best choice for a framework?
08:41:11 <benmachine> aw
08:42:54 <jmcarthur> qewr: happstack is good. also be sure to check out snap :)
08:43:00 <jmcarthur> qewr: http://snapframework.com
08:43:35 <qewr> jmcarthur: I really, really want to use Snap! But there's a warning on the front page that it's still a work in progess. I was afraid of using it to write the app, only to have an update break all my code. ):
08:44:33 <c_wraith> So far, the only times updates have broken all my code have been because I'm working in the unreleased 0.3 branch. :)
08:45:04 <qewr> c_wraith: This fills me with new-found hope. (: I may end up using Snap.
08:47:55 <chrisdone> qewr: it is a work in progress. i'd use fastcgi or happstack
08:48:40 <chrisdone> e.g. there's no file upload in snap
08:49:08 <chrisdone> if you've got the kinda of time to write one yourself good for you
08:52:43 <copumpkin> jmcarthur: don't like horses?
08:53:01 <copumpkin> Berengal was working on something nice too
08:54:42 <chrisdone> I think Berengal defected to Ur
08:56:48 <EvanR-work> holy crap i just wrote an alien with internal mutable state, enough intelligence to navigate a level, a random number generator, reacts to external stimulus, and has event handlers
08:57:10 <EvanR-work> but without IO or anything else ;)
08:57:55 <EvanR-work> and he implements an interface for other mobile game elements, without exposing his internals
08:57:59 <EvanR-work> without type classes! ;)
08:58:24 <EvanR-work> http://codepad.org/dFSCd0Rc
08:58:45 <ksf> NB: `Key' is a type function, and may not be injective
08:58:52 <ksf> is there a way to make it?
08:59:55 <zygoloid> ksf: sure. use data families instead of type families.
09:00:39 <chrisdone> qewr: http://tryhaskell.org/ -- fastcgi. if you're any good at javascript the server itself doesn't matter too much as long as it can read/write a database and provide a json interface
09:01:22 <EvanR-work> when did typed polymorphic lambda calculus get so much power ;)
09:01:39 <chrisdone> EvanR-work: blog about it
09:01:47 <EvanR-work> thats conal's job ;)
09:01:49 <chrisdone> needs more blogs
09:01:56 <zygoloid> EvanR-work: when someone added General Recursion
09:02:38 <EvanR-work> its amazing! ._.
09:03:29 <EvanR-work> i should probably do real work now
09:04:42 <EvanR-work> what do people have against update syntax?
09:04:55 <c_wraith> it doesn't work anonymously
09:05:12 <c_wraith> You often see yourself writing \s -> s { foo = bar}
09:05:19 <c_wraith> that lambda is painful
09:05:26 <EvanR-work> ah
09:05:48 <EvanR-work> so {foo = bar} should be a standalone function :: Foo -> Bar -> Foo
09:06:03 <c_wraith> Well, it would be Foo -> Foo
09:06:11 <EvanR-work> ah
09:06:12 <c_wraith> But there are probably syntactic complexities introduced by that
09:06:52 <c_wraith> I'm not sure it would be parseable in that manner.
09:06:55 <EvanR-work> the \s -> s { foo = bar } pattern /is/ fairly boiler platey
09:07:02 <EvanR-work> :\
09:07:06 <c_wraith> unless you also removed the current syntax, which would break lots of code
09:07:25 <EvanR-work> but its a lot less boiler than say c++ ;)
09:07:47 <c_wraith> It's not horrible, but...  It stands out as a really clunky spot in what's usually an elegant language
09:09:00 <c_wraith> It's up there with case and a couple other things, in terms of requiring you to introduce names that you don't actually care about.
09:09:17 <c_wraith> I'm also a supporter of some form of anonymous case extension, too :)
09:09:22 <chrisdone> that in general doesn't bother me, but the specific case of
09:09:22 <chrisdone> \s -> s { boobar_muzzles = update (boobar_muzzles s) } really does need anonymous updates
09:09:47 <EvanR-work> ah yeah i almost wrote that one last night
09:09:48 <chrisdone> I ended up using fclabels but removed it because i don't seem to use it that often O_O
09:09:52 <pikhq> EvanR-work: Eh, better than class Foo : FunctorObject {update(Bar *s) {s->foo = bar}};(new FunctorObject())->update(baz);
09:09:55 <pikhq> :P
09:10:01 <EvanR-work> but i decided on just hardcoding the two modifiers i was going to use
09:10:15 <chrisdone> EvanR-work: yeah seems like a good idea in thje long run
09:10:15 <EvanR-work> pikhq: *uhg*
09:15:50 <robryk> @djinn (a, b) -> (a -> c) -> (c, b)
09:15:51 <lambdabot> f (a, b) c = (c a, b)
09:17:44 <EvanR-work> so path finding...
09:17:56 <EvanR-work> in pacman did they just randomly run around?
09:18:03 <EvanR-work> or were they intelligent
09:18:17 <EvanR-work> A* or something implemented in transistors
09:18:39 <EvanR-work> and anyway wonder how trivial it would be in haskell ;)
09:19:01 <c_wraith> it wasn't random, but I doubt it was A*
09:19:19 <ksf> ok, caller-site type safety is done.
09:19:28 <c_wraith> It was probably something simpler, like "move towards, unless there's a wall in the way"
09:19:33 <zygoloid> EvanR-work: you might be interrested in the Hugs TREX record extension: http://cvs.haskell.org/Hugs/pages/hugsman/exts.html
09:19:39 <EvanR-work> c_wraith: i mean, to find the player
09:19:42 <ksf> now I just need to figure out how to infer stuff...
09:19:52 <jmcarthur> EvanR-work: each enemy in pacman has a unique AI
09:20:03 <EvanR-work> really???
09:20:05 <jmcarthur> yes
09:20:10 <EvanR-work> thats awesome
09:20:17 <zygoloid> jmcarthur: are the AIs documented somewhere?
09:20:18 <EvanR-work> so an advanced player can exploit that
09:20:23 <EvanR-work> xD
09:20:28 <jmcarthur> i read about them once, but i can't remember where
09:20:47 <c_wraith> there was the whole saga about the race to become the first person to get a perfect score in pacman :)
09:20:51 <EvanR-work> that adds a whole nother level of depth
09:20:57 <c_wraith> There were definitely exploitable patterns
09:21:07 <jmcarthur> http://home.comcast.net/~jpittman2/pacman/pacmandossier.html#Chapter 4
09:21:15 <jmcarthur> that's not what i read before, but i think it should cover it
09:22:54 <c_wraith> I can't imagine getting a perfect score on one level of pacman, let alone the whole game
09:22:55 <EvanR-work> zygoloid: this is somewhat interesting. reminds me of object calculus
09:23:37 <EvanR-work> i assume a record that is extended is still of the original type and can be used as such
09:23:51 <EvanR-work> becomes a subtype
09:25:40 <ksf> oh noes! don't call it pacman!
09:25:59 <ksf> namco lawyers will descend from above and tear you to shreds!
09:26:42 <seydar> copumpkin: am you on campuses?
09:26:48 <copumpkin> seydar: I quit :P
09:27:00 <seydar> um, explanation needed
09:27:03 <EvanR-work> ksf: im just thinking about path finding in a Array of Bools
09:27:08 <copumpkin> seydar: i.e., not am on campuses
09:27:19 <copumpkin> seydar: decided a PhD in that field was not for me
09:27:51 <ksf> well do it like on any other map, or graph with possible heuristic: use A*
09:28:22 <EvanR-work> ive heard of this, though ive never implemented it much less implemented it in haskell ;)
09:28:40 <c_wraith> For small sets, I'm still a big fan of pre-processing the map with djikstra's algorithm
09:28:42 <EvanR-work> my naive brain says its 3 lines of pure code ;)
09:29:15 <ksf> otoh, as pacman does'nt have open spaces and there's only ever one pathfinding target, you can vastly simplify stuff and make pacman smell. that is. there's a gradient from his position to the rest of the map, decreasing with distance.
09:29:42 <EvanR-work> update the entire gradient map when he moves?
09:29:46 <ksf> the ghosts then either walk up or down that gradient, depending on whether they should flee or not.
09:29:49 <ksf> yep.
09:30:04 <ksf> that way, you traverse the map exactly once, not once for each ghost.
09:30:34 <ksf> oh, and there might be an additional random component to the ghost movement.
09:31:05 <EvanR-work> what about this idea... the enemy follows a path to where he thought pacman was. he gets periodic updates but not a continuous stream
09:31:17 <EvanR-work> and different enemies have different memory 
09:31:44 <robryk> why doesn't hoogle know anything about comonad?
09:31:46 <EvanR-work> if the update interval depended only on time seems like it would be efficient
09:31:52 <ksf> you're thinking like a bleeding neurologist.
09:31:58 <ksf> think like a game developer, instead.
09:32:21 <EvanR-work> well see i said updates only depended on time ;)
09:32:29 <EvanR-work> no on line of sight or sound or anything
09:32:36 <ksf> is not faking it beneficial to gameplay? if not, don't even consider it.
09:33:02 <ksf> game development is all about faking stuff.
09:33:05 <EvanR-work> true i need to figure out desirable game play
09:33:18 <EvanR-work> randomly moving enemies is probably annoying
09:33:29 <EvanR-work> them coming directly after you is probably ridiculous
09:33:29 <ksf> but so is too perfect path finding.
09:33:33 <EvanR-work> and easy to circumvent
09:33:33 <ksf> ...so combine them both.
09:34:05 <EvanR-work> gaunlet had them all come directly at you, not even path finding ;)
09:34:08 <EvanR-work> gauntlet
09:34:12 <ksf> randomly switch ghosts from approaching to fleeing for some time.
09:34:29 <EvanR-work> pacman only had 4 enemies, i will have more
09:34:39 <EvanR-work> if they all on average came after you it would be not good
09:34:42 <EvanR-work> from the whole map
09:34:52 <ksf> well, don't be a philosopher, implement a simple scheme, then playtest.
09:35:15 <EvanR-work> long way from that, dont even have graphics
09:35:31 <EvanR-work> but i think im in a position to easily change the behaviors later
09:35:36 <EvanR-work> because its haskell and all!
09:35:49 <ksf> oh, then make the smell in a radius, only. possibly bigger if it's where you're coming from.
09:35:54 <ksf> think of a cellular automaton.
09:36:39 <EvanR-work> hmm yeah but i those are slow without mutable updates
09:37:08 <EvanR-work> i dont have mutable anything! ;)
09:38:07 <ksf> no arrays?
09:38:15 <ksf> your map should be one.
09:38:21 <EvanR-work> its just the walls
09:38:46 <ksf> you need the nodes, anyway, to pathfind.
09:38:53 <EvanR-work> whatever algorithm i come up with will need to compute a accelerator data structure from that array
09:39:25 <ksf> you might want to google for "amit a star"
09:39:31 <EvanR-work> ok
09:39:48 <ksf> the page has a nice treatease of what data  structures to use
09:40:09 <ksf> ...coming down to a couple of arrays and a binary heap
09:40:33 <EvanR-work> ive seen this page before yeah
09:40:46 <EvanR-work> mutable arrays?
09:40:55 <ksf> yeah
09:40:57 <EvanR-work> >_<
09:41:16 <ksf> well you need a lot of random access into the graph.
09:42:11 <ksf> and as your graph has a very, very, very regular structure, a 2d-array is perfect to represent it.
09:42:23 <EvanR-work> but why mutable
09:42:36 <ksf> well use non-mutable if you want, the algorithm is incremental.
09:42:47 <ksf> ...and then let stream-fusion do the mutation bit.
09:42:57 <EvanR-work> is that automatic?
09:43:05 <ksf> it should be.
09:43:21 <ksf> that is yes, unless it can't do it automatic.
09:43:36 <ksf> uvector is the package name iirc
09:45:18 * Amadiro hi
09:45:35 <EvanR-work> > [1,2,3] >>= replicate 3
09:45:38 <lambdabot>   [1,1,1,2,2,2,3,3,3]
09:46:04 <Amadiro> hi
09:47:04 <EvanR-work> ksf: what if the map was divided logically into rooms and connecting corridors, seems like a static Data.Map with keys (source,destination) and values (path to take?) would work?
09:47:18 <EvanR-work> once the enemy gets to the destination he can use basic ai to hone in on the player
09:47:36 <ksf> if you have a room structure, you can add another pathfinding layer that only deals with room to room pf.
09:47:45 <ksf> ...ignoring the open spaces inside the rooms.
09:48:09 <ksf> I think there's even an a*-implementation on aribtary graphs on hackage
09:48:25 <ksf> ...and if you want a graph library, there's fgl.
09:48:51 <EvanR-work> the prospects seem favorable
09:49:28 <ksf> in the room case, a plain dijkstra might even be faster.
09:49:38 <EvanR-work> yeah
09:49:46 <ksf> ...as a* incurs quite some constant overhead
09:49:54 <ksf> (and has the same worst-case complexity)
09:50:06 <EvanR-work> wondering about (path to take?) value... and how to use it
09:50:36 <EvanR-work> could be a list of squares
09:50:44 <EvanR-work> but that wont work in rooms
09:50:52 <EvanR-work> gah
09:50:53 <ksf> directions.
09:51:04 <ksf> that's 8 values per path element.
09:51:17 <ksf> rle encode it and you've got a decent representation.
09:54:03 <EvanR-work> ive noticed when faced with these problems of algorithm choice and implementation... i try to think if it would be easier in a standard imperative language, and i come to the conclusion no
09:54:12 <EvanR-work> because these problems are still hard
09:54:53 <EvanR-work> the haskell pure thing only makes a difference in global application design
09:55:17 <EvanR-work> how to get the damned enemies to find you is about the same 
09:59:37 <jmcarthur> i bet A* with manhatten distance for the heuristic is probably fast enough for pacman, honestly. it's not like you're doing an RTS with hundreds of units or something
10:00:03 <ksf> well, but smell is more efficient if you only have a single goal.
10:00:07 <ksf> and pacman is _old_.
10:00:25 <copumpkin> omg zygoloid on reddit
10:00:44 <ksf> you can kill all the achievements of early game devs by throwing hardware at reimplementations.
10:01:01 <EvanR-work> where hardware = 386
10:02:10 <jmcarthur> ksf: btw, uvector has been superceded by vector
10:03:15 <jmcarthur> i really think optimizing path finding in pacman would be a waste of mental effort
10:03:27 <EvanR-work> im not cloning pacman
10:03:31 <jmcarthur> ah
10:03:35 <jmcarthur> then perhaps it's not a waste
10:03:36 <EvanR-work> it was just an example 
10:03:39 <jmcarthur> okay
10:03:43 <jmcarthur> i misunderstood
10:04:06 <EvanR-work> more like gauntlet
10:04:25 <EvanR-work> which has the amazing path finding of having every monster go directly to you
10:04:35 <EvanR-work> into walls and such
10:04:59 <ksf> heck c&c had the same.
10:05:29 <ksf> and that was in pentium times. it was truly ridiculous.
10:05:40 <ksf> ...you can a* on low-end handsets just fine.
10:05:59 <ksf> the problem isn't cpu oomph, but memory restrictions.
10:06:46 <ksf> (of course, you shouldn't attempt to find 100 paths in the same frame)
10:07:13 <ksf> (or even call the pathfinder directly from the keyhandler. bleeding retards)
10:07:16 <EvanR-work> i think it makes sense for enemy to decide on a path and use it for a while
10:07:47 <ksf> depends. you want it to recalculate when the target moves. 
10:08:01 <EvanR-work> not necessarily
10:08:09 <EvanR-work> if they have a random component they wont look too stupid
10:08:27 <EvanR-work> on the other hand, i expect the player to move alot
10:08:31 <ksf> it's also sensible to limit the maximum length of paths you extract, for memory reasons.
10:08:44 <ksf> ...always let a* run until it hit a target, tohugh.
10:08:47 <EvanR-work> the paths will be lazily computed
10:08:58 <ksf> oh, and you want to utterly, utterly avoid unreachable areas in your map.
10:09:10 <ksf> as that would trigger the worst-case behaviour.
10:09:19 <ksf> er you can't.
10:09:27 <EvanR-work> why?
10:09:46 <jmcarthur> some heuristic algorithms can generate lazy paths
10:09:48 <ksf> because you have to reach the target to know which first step is right.
10:09:49 <jmcarthur> just not exact ones
10:09:55 <ksf> yep.
10:10:08 <EvanR-work> hrm
10:10:29 <ksf> you can even do that with a*, just stop it early and take the best-scoring path.
10:10:50 <EvanR-work> the smell thing would work lazy right
10:10:53 <jmcarthur> which actually might not be a bad idea
10:11:03 <ksf> then you've got ten or so tiles time to find the real path. units will look confused, but not outright stupid.
10:11:22 <ksf> it's not worth the bother in most cases.
10:11:38 <ksf> a* is bleeding fast if you disallow the worst-case behaviour.
10:11:47 <jmcarthur> EvanR-work: the smell thing depends on what you mean by "lazy". conceptually, smell traces the entire path before giving you a result. the benefit of smell is avoiding recalculating a lot of that stuff for each monster
10:11:49 <ksf> that is, you should make sure that there's alway a path that can be found.
10:12:19 <benmachine> what do people think of the Extensions field in cabal files?
10:12:27 <benmachine> as opposed to LANGUAGE pragmas in source files
10:12:30 <jmcarthur> that is, smell might give you a form of "path sharing"
10:13:09 <ksf> sim city works similar.
10:13:13 <benmachine> the latter have the advantage of being picked up by ghci too, so I avoid the former, but I guess they could be useful for quick static analysis
10:13:21 <ksf> residents move towards areas with lower smell.
10:13:51 <jmcarthur> benmachine: both is probably ideal, but that's harder to maintain
10:14:10 <ksf> heck you can add wind to the equation, so that you can get past enemies when you keep in their shadow.
10:14:17 <benmachine> jmcarthur: the cabal field would then be the union of all extensions you need anywhere?
10:14:19 <jmcarthur> benmachine: i tried to adopt a policy of doing both, but then it was hard to track which modules needed the LANGUAGE pragmas because the .cabal was already enable the extensions
10:14:22 <jmcarthur> benmachine:  yeah
10:14:31 <jmcarthur> *was already enabling
10:14:39 <benmachine> yeah, I can see that being a problem
10:14:41 <ksf> actually, smell with backtracking is the perfect model for predators.
10:15:06 <jmcarthur> smell with decoys would be awesome
10:15:56 <ksf> smell with d* or what's it called.
10:16:03 <ksf> the one that works on incomplete map information.
10:16:11 <EvanR-work> i think im going to attempt to create a graph... maze-like areas will be represented by their turning points, convex rooms as such a turning point, and everything else with some good enough hueristic
10:16:23 <ksf> so you can avoid Us that are in the LOS
10:17:01 <EvanR-work> then a graph algorithm to compute a path from a to b when necessary
10:17:55 <EvanR-work> when they are in the same room as the player they just go for him
10:18:15 <EvanR-work> there can be a map from location to graph node
10:18:57 <EvanR-work> enemies might get stuck but doesnt matter ;)
10:19:05 <jmcarthur> EvanR-work: if you're building a graph anyway be sure to check out the astar package
10:20:06 <jmcarthur> the advantage of A* over more general graph algorithms is that you can focus the search with a heuristic
10:20:20 <EvanR-work> what kind of heuristic
10:20:22 <jmcarthur> a more general algorithm has to consider all paths
10:20:25 <ksf> distance
10:20:32 <ksf> may not underestimate the cost
10:20:44 <jmcarthur> line distance or manhatten distance are popular heuristics
10:21:09 <ksf> ...depends on whether you can move diagonally or not
10:21:26 <EvanR-work> no diagonal movement
10:21:30 <jmcarthur> and by line distance i mean squared distance of course ;)
10:21:37 <ksf> manhattan would still work there, but the sqrt might be well worth the reduced search space
10:21:59 <ksf> oh no that won't work because it's not in the same unit as the other costs.
10:22:22 <ksf> use manhattan if you don't want to sqrt
10:22:38 <jmcarthur> oh you're right, duh
10:22:42 <EvanR-work> confused by this
10:22:50 <copumpkin> you don't need to sqrt
10:22:52 <copumpkin> if you're just comparing things
10:22:52 <jmcarthur> i forgot that A* prefers heuristics that don't overestimate
10:23:02 <EvanR-work> what kind of distance are we talking about, in terms of squares?
10:23:06 <EvanR-work> or graph nodes
10:23:20 <ksf> squares
10:23:27 <ksf> real-world walking distance
10:23:31 <EvanR-work> how is astar package going to know about that
10:23:37 <jmcarthur> EvanR-work: if you are simplifying your maze to graph nodes then you could also include the number of squares between each node as the weights of the arrows
10:23:39 <ksf> you provide it
10:23:52 <EvanR-work> ah
10:23:57 <jmcarthur> EvanR-work: and you use the heuristic to judge distance between unconnected nodes
10:24:15 <jmcarthur> the heuristic is only a guess of course
10:24:50 <jmcarthur> and you can use the special knowledge you have about the maze (that it's actually a grid, not an arbitrary graph) to choose a good heuristic. in this case, manhattan is probably good
10:24:51 <ksf> and, yes, jmcarthur is right, the heuristic may not overestimate
10:24:52 <EvanR-work> so dont overestimate
10:24:59 <ksf> underestimating is fine
10:25:10 <ksf> because then you degenerate into plain dijkstra
10:25:24 <EvanR-work> and the minimum squares possible of distances cant possible overestimate
10:25:47 <ksf> yeah
10:25:52 <EvanR-work> are there better guesses
10:26:01 <jmcarthur> EvanR-work: don't do the pythagorean distance if you can't do diagonals though. manhattan is probably better and faster
10:26:06 <ksf> not for your movement model, no.
10:26:12 <EvanR-work> jmcarthur: right
10:26:23 <ksf> you might want to go hex grids
10:26:28 <ksf> or even free movement
10:26:38 <EvanR-work> nope no thanks
10:26:49 <ksf> free movement isn't that hard
10:27:13 <jmcarthur> once you have free movement you have to do fancier collision detection
10:27:13 <EvanR-work> my guys are already free really, but i reduce them to a array of bool game board for the sake of 'feel'
10:27:53 <EvanR-work> graphically free
10:28:05 <EvanR-work> but mechanically always on a square
10:28:27 <ksf> well usually you can just do circle collisions.
10:28:52 <ksf> that's distance between two points <= radius of both circles.
10:29:06 <ksf> you can do gazzilions of those is a nanosecond.
10:29:06 <EvanR-work> currently they only collide if they occupy the same square
10:29:18 <jmcarthur> ksf: don't forget wall collisions though
10:29:40 <ksf> hmmm yes those are more involved, but still.
10:29:45 <c_wraith> don't forget to skip the square roots when doing distance calculations. :)
10:30:07 <jmcarthur> c_wraith: as we mentioned earlier that is not as great for A*
10:30:12 <EvanR-work> whats worse, sqrt or floor ;)
10:30:13 <ksf> I once wrote an arcanoid that even calculated the delta t before it hits the wall.
10:30:14 <c_wraith> oh, hmm.
10:30:19 <c_wraith> sqrt is much slower than floor
10:30:27 <EvanR-work> k
10:30:35 <jmcarthur> you should not need sqrt
10:30:38 <jmcarthur> you just have a grid
10:30:50 <jmcarthur> pythagoras is useless :)
10:30:50 <ksf> (at arbitrary angles, that is)
10:31:50 <EvanR-work> just drop euclid completely. d = x^2 - y^2 relativity style ;)
10:31:58 <EvanR-work> d^2
10:32:09 <zygoloid> haha, that'd make for an interesting game
10:32:17 <ksf> ...which means, and that's a rare thing for a physics engine, means that stuff can collide arbitrary often in a single frame.
10:32:32 <ksf> no problems with bullets being so fast they fly through you etc.
10:32:49 <EvanR-work> yeah i have speed of light
10:33:04 <EvanR-work> you cant move more than 1 square per game step
10:33:12 <EvanR-work> which is 10ms
10:34:11 <ksf> in the arcanoid case it's important because you can have stray, rare shots that actually do collide twice in a frame, with different blocks.
10:34:21 <ksf> I couldn't stand the thought of that bug.
10:35:30 <ksf> with bullets, you are fine with a line intersection, at least if they don't ricochet.
10:35:42 * zygoloid starts thinking about making a game in the hyperbolic plane again
10:35:55 <ksf> and even then physically correct ricocheing isn't that important for bullets.
10:36:20 <ksf> ...in fact, the physics are so involved there's no sense in not faking them.
10:37:27 <obfuscated> Hello is there some way, I can make myNothingStr in http://pastebin.com/urEtq0Ku return IO String?
10:37:55 <ksf> yes. use return
10:38:01 * ksf looks at the source
10:38:20 <zygoloid> obfuscated: return :: a -> m a, where m is any Monad
10:38:26 <ksf> yes. use return "nothing"
10:38:39 <zygoloid> so you can use it to convert String to IO String in this particular case.
10:38:54 <c_wraith> I do have to worry that you're bringing stuff into IO that appears to have no need to be in IO
10:39:37 <zygoloid> obfuscated: incidentally, getLine >>= (\a -> return a) == getline >>= return == getLine
10:40:46 <obfuscated> zygoloid: thanks for the hint :)
10:41:17 <ksf> :t maybe (return "nothing") (const . getLine)
10:41:19 <lambdabot>     Couldn't match expected type `a -> [Char]'
10:41:19 <lambdabot>            against inferred type `IO String'
10:41:19 <lambdabot>     In the second argument of `(.)', namely `getLine'
10:41:25 <ksf> :t maybe (return "nothing") (const  getLine)
10:41:26 <lambdabot> forall a. Maybe a -> IO [Char]
10:42:48 * ksf still thinks the standard helloworld example should be "main = interact . const "Hello, World!""
10:42:51 <verdelyi> can someone tell me why "f" doesn't typecheck and why "g" and "h" does in http://fpaste.org/h9Et/ ?
10:42:55 <ksf> oh, add a $
10:42:59 <zc00gii> any sml-mode users?
10:43:49 <ksf> dataToExpr . internalize $ x
10:44:33 <ksf> and it's internali_s_e
10:45:03 <verdelyi> ksf: dataToExpr . internalize $ x doesn't work either
10:45:17 <verdelyi> ksf: (and in American it's with z I think)
10:45:23 <ksf> ...then g doesn't, either.
10:45:45 <heatsink> Is there any difference between the patterns ~(foo -> (a, b)) and (foo -> ~(a,b)) ?
10:45:51 <verdelyi> ksf: did you try it? because we spent hours trying to figure this out
10:46:03 <zygoloid> ksf: hello world programs don't usually wait for EOF do they?
10:46:28 <ksf> zygoloid, it shouldn't wait.
10:47:29 <ksf> > let f x = (+ 1) . (*2) $ x in f 5
10:47:31 <lambdabot>   11
10:47:32 <zygoloid> ksf: hah, cool. of course not :)
10:47:43 <ksf> > let f x = (+ 1) ( (*2) x ) in f 5
10:47:44 <lambdabot>   11
10:48:03 <ksf> it's 100% equivalent, by definition of (.) and ($)
10:48:21 <zygoloid> ksf: foo-ize is a reasonable suffix for 'make foo' even in british english aiui
10:48:29 <verdelyi> ksf: we thought so as well. Now load it in ghci please :)
10:48:43 <c_wraith> ksf: it's 100% equivalent for rank-1 types.
10:49:21 <dmwit> verdelyi: id is insufficiently polymorphic, as is ($)
10:49:22 <heatsink> ./configure; buildize; installize
10:49:48 <zygoloid> heatsink: british: the briti shell :)
10:50:35 <verdelyi> dmwit: you mean it's a "feature"?
10:50:46 <copumpkin> verdelyi: it's a "consequence"
10:51:02 <verdelyi> ah, ok.
10:51:18 <ksf> huh.
10:51:25 <ksf> well, yet more gadt strangeness.
10:51:54 <c_wraith> are gadts treated like higher-rank types somehow?
10:52:04 <dmwit> verdelyi: try adding ScopedTypeVariables
10:52:07 <dmwit> verdelyi: and add:
10:52:15 <dmwit> f :: forall t. Comp t => t -> ()
10:52:25 <dmwit> f x = case dataToExpr $ internalize x :: Data (Internal t) of ...
10:52:26 <ksf> there's existentials in his type.
10:52:37 <ksf> er wait no.
10:52:45 <ksf> not in Function
10:53:15 <copumpkin> verdelyi: have you considered de bruijn indices? :P
10:53:21 <copumpkin> (on a completely unrelated note)
10:53:29 <copumpkin> possibly nat-indexed finite sets
10:53:33 <dmwit> locally nameless!
10:53:37 <verdelyi> copumpkin: if I knew what they are. :)
10:54:09 <verdelyi> copumpkin: I'm just trying to hunt an infinite recursion down in ~4000 lines of code
10:54:09 <ksf> "golf a lambda calculus implementation in 4kb of #haskell"
10:54:18 <copumpkin> verdelyi: sounds like a nightmare :P 
10:54:29 <dmwit> verdelyi: A deBruijn index just replaces variable names by numbers that tell how many "function scopes" to look at to find the variable.
10:54:55 <dmwit> verdelyi: e.g. \x. \y. \z. z y x   would become \. \. \. 0 1 2
10:54:58 <verdelyi> copumpkin: it seems to die on a gadt pattern match while evaulating something that really shouldn't contain any infinite stuff (and it worked so far)
10:55:29 <zygoloid> verdelyi: i suspect it's a result of the type family, and is unrelated to the GADT
10:55:34 <verdelyi> dmwit: hmm and does GHC eat it?
10:55:37 <monochrom> de bruijn index is very nice. simplifies algorithms. no worries about variable capture and not-free-occurrence
10:56:05 <dmwit> verdelyi: It means representing your Expr type a different way, not changing the syntax of your Haskell.
10:56:14 <zygoloid> verdelyi: what error do you get?
10:56:19 <copumpkin> verdelyi: the finite set of which I spoke is data Z = Nz; newtype S n = Ns n; data Fin n where Fz :: Fin (S n); Fs :: Fin n -> Fin (S n)
10:56:38 <copumpkin> ideally with some reflective capabilities built into your nat type
10:56:40 <copumpkin> so you can actually use it
10:56:47 <copumpkin> or nat "pair of types"
10:56:50 <verdelyi> zygoloid: GADT pattern match in non-rigid context for `Function'
10:57:17 <verdelyi> zygoloid: the other problem is just a freeze.
10:57:26 <dmwit> verdelyi: Did you try the solution I suggested with ScopedTypeVariables?
10:57:33 <zygoloid> verdelyi: oh, ok then. well, that's because you don't have a type signature on the case expression's argument
10:57:55 <verdelyi> dmwit: I'm just trying. I didn't have the time yet because I was typing.
10:58:00 * dmwit nods
10:58:03 <zygoloid> verdelyi: the checking for existentials escaping in GADT pattern matching is a bit dumb
10:59:15 <zygoloid> i think the problem is that it happens too early in the typechecker for it to have inferred a specific type for the ($)
10:59:40 <verdelyi> dmwit: I tried it, had to add rankntypes and ghci still doesn't like it
11:00:17 <dmwit> WFM
11:00:37 <verdelyi> dmwit: however I'd be more interested in you suggestions about changing the Expr type
11:01:26 <verdelyi> it's actually more complex, the paste is only a minimal test case
11:01:42 <copumpkin> verdelyi: do you like preserving names in printing expressions?
11:01:58 <dmwit> http://fpaste.org/GtJP/
11:02:04 <copumpkin> the nice thing about de bruijn indices is that you don't have to worry about overlapping names and such
11:02:08 <verdelyi> copumpkin: we're generating C code so we need it
11:02:21 <copumpkin> verdelyi: you couldn't just generate random names when making c code?
11:02:55 <ksf> ...or keep the names and still index with de brujin
11:02:58 <verdelyi> copumpkin: we're using a state monad for that, var0, var1, etc and var0_1 var0_2 as well
11:04:00 <ksf> it's always nice to have a chance of identifying stuff in the generated code
11:04:19 <verdelyi> dmwit: oops I missed scopedtypevars, now it works thx
11:04:36 <verdelyi> ksf: we used to use something called observable sharing for that
11:04:52 <verdelyi> ksf: however that involved an unsafeperformIO deep inside the code
11:05:06 <dmwit> You don't happen to work with kmett, do you?
11:05:13 <copumpkin> lol
11:05:18 <dmwit> ;-)
11:05:29 <verdelyi> no, I don't recognize that nick
11:05:36 <verdelyi> we're working with the Chalmers people
11:05:37 <beat> is code.haskell.org down?
11:05:40 <zygoloid> it's a surname rather than a /nick :)
11:05:43 <copumpkin> beat: yep
11:05:50 <ksf> there's also data-reify
11:05:58 <ksf> ...but that doesn't give you access to the names
11:06:02 <beat> hm okay thanks, wondering if it was just me
11:06:11 <verdelyi> yeah we had a reify.hs as well :)
11:06:15 <ksf> wrapping stuff in TH quotes might be worth a try.
11:07:05 <ksf> interop with non-quoted stuff is bad, though, as you can't lift functions.
11:08:24 <dmwit> I wonder what the canonical paper for locally-nameless is.
11:08:24 <verdelyi> ok, I dare to ask the infinite recursion problem as well: I think this is what causes the infinite recursion:  case internalize prg of E.Variable _ -> error "..."
11:08:26 <dmwit> Maybe
11:08:32 <dmwit> http://www.springerlink.com/content/f2m557786x1m5300/ ?
11:08:53 <dmwit> error should exit immediately (no loop)
11:09:00 <verdelyi> where prg is member of Computable, it has internalize... 
11:09:17 <monochrom> perhaps "internalize prg" loops
11:10:02 <verdelyi> most probably.. I just don't understand how it can be. We had a language implementation working with internalize/externalize and it didn't have this problem
11:10:33 <verdelyi> I mean it comes up when compiling a hello world-like example written in our DSL language
11:10:39 * ksf suggests an armada of traces.
11:10:50 <verdelyi> and before, we could compile it just fine
11:11:12 <verdelyi> so prg shouldn't contain any problematic stuff
11:11:44 <verdelyi> ksf: can you point me to some rtfm about that?
11:12:27 <ksf> the Debug.Trace haddock?
11:12:44 <ksf> a refreshing desert in an oasis of purity
11:12:45 <dmwit> ?quote oasis
11:12:46 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
11:12:58 <monochrom> haha
11:13:04 <npouillard> copumpkin: thanks for the info, but kowey gave me one
11:13:29 <verdelyi> ksf: hmm we're already using it somewhere, thx
11:13:54 <copumpkin> npouillard: aha, nice
11:14:18 <verdelyi> I've reduced the compilation code to this: http://fpaste.org/eQQQ/
11:14:43 <verdelyi> unfortunately it's not a good test case because it has lots of dependencies
11:16:16 <verdelyi> and the example code is only example1 :: Data Signed32 -> Data Bool \newline example1 x = x == 2
11:16:30 <verdelyi> anyway I'll try trace
11:17:16 * hackagebot djinn-th 0.0.1 - Generate executable Haskell code from a type  http://hackage.haskell.org/package/djinn-th-0.0.1 (ClaudeHeilandAllen)
11:17:35 <mmmulani> how would you floor a Floating number?
11:17:47 <zygoloid> verdelyi: clearly there's somethign wrong with me, when reading your example code i was wondering why you were defining a function called ewline ;-)
11:18:04 <zygoloid> @type floor
11:18:05 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:18:07 <ksf> wtf I'm being ridiculous I should be using HList
11:18:25 <ksf> ...my hack with Dynamic can't deal with non-concrete types, and that's bad.
11:18:43 <ksf> ...no matter if there's equally much matching going on.
11:18:46 <mmmulani> @type truncate
11:18:46 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:18:49 <mmmulani> gah
11:18:50 * zygoloid found a case yesterday where $([t| foo |]) != foo :o
11:19:26 <verdelyi> after some tracing, it has to be something in prg
11:19:27 <ksf> or is there a less heavy-weight library for polymorphic variants?
11:19:34 <zygoloid> mmmulani: you can then use fromIntegral to get back to a floating type
11:19:49 <verdelyi> any ideas how to derive show for a gadt? It would help me a lot in debugging
11:19:49 <copumpkin> ksf: what are you trying to do?
11:20:08 <ClaudiusMaximus> zygoloid: TupleT and ConT (GHC.Prim.(,)) or something vaguely along those lines?
11:20:29 <ksf> passing messages and back-channels over a TChan
11:20:41 <copumpkin> verdelyi: you have to write the instance yourself, or I've heard that GHC 6.13 can do it for you
11:20:52 <ksf> ...ONE Tchan, not ten thousand or stuff isn't manageable quite fast.
11:21:00 <mmmulani> zygoloid: I'm running into an error where I use multiply with pi and get a Floating number but floor demands a RealFrac and I get an ambiguous type error
11:21:16 * ksf doesn't believe in actors with more than one input queue.
11:21:25 <verdelyi> copumpkin: even if it contains types like "Expr (a->b)"?
11:21:33 <zygoloid> mmmulani: sounds like you need to specify /which/ type which is both Floating and RealFrac you want
11:21:43 <copumpkin> verdelyi: not sure under what conditions it can do it, but apparently it's more than it can before that version
11:21:47 <zygoloid> i'm a little surprised that defaulting doesn't pick one for you tbh
11:22:18 <verdelyi> copumpkin: ok thx
11:22:22 <mmmulani> zygoloid: oh god, how do I specify types in my where clause
11:23:26 <zygoloid> ClaudiusMaximus: http://hackage.haskell.org/trac/ghc/ticket/4233
11:23:41 <ClaudiusMaximus> > let { f x = y x where { y :: Int -> Int ; y = succ } } in f 3
11:23:41 <lambdabot>   4
11:23:48 <zygoloid> mmmulani: just like you specify types at the top level (but indented like the rest of the where clause)
11:24:17 <zygoloid> mmmulani: the top-level is actually one big where clause, as part of the 'module Foo (...) where' definition
11:24:17 <roconnor> > 5 `mod` 0
11:24:18 <lambdabot>   *Exception: divide by zero
11:26:10 <mmmulani> hmmmm, I'm going to try doing it without that
11:26:54 <mmmulani> whoa, how do a floor a sqrt result
11:27:03 <mauke> > floor (sqrt 2)
11:27:04 <lambdabot>   1
11:27:23 <roconnor> someone needs to wrap isqrt and package it on hackage already
11:27:28 <mmmulani> a num can be both RealFrac and Floating?
11:27:31 <roconnor> or the GHC people need to stick it in somewhere
11:27:31 <mmmulani> @type floor
11:27:32 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:27:33 <mmmulani> @type sqrt
11:27:34 <lambdabot> forall a. (Floating a) => a -> a
11:27:48 <Cale> mmmulani: Yeah.
11:27:58 <Cale> mmmulani: Float and Double are both RealFrac and Floating
11:28:03 <lispy> roconnor: IIRC, ilog is also needed
11:28:23 <roconnor> lispy: true, although that is somewhat less painful to implement byhad
11:28:27 <roconnor> hand
11:28:48 <lispy> roconnor: Well, the last time I needed it I actually just stole the implementation from GHC :)
11:28:58 <lispy> A BSD license is nice
11:28:59 <Cale> roconnor: Given all the other numeric stuff that's in there, integer sqrt and log wouldn't be out of place in the Prelude.
11:29:16 <roconnor> make it part of Haskell 2011?
11:29:25 <roconnor> add it to num ?
11:29:27 <roconnor> :D
11:29:30 <lispy> roconnor: yes pleas!
11:29:42 <Cale> But another library would be fine of course. What we really need is a clever implementation with competitive performance.
11:29:54 <Cale> Does GMP supply those?
11:29:57 <copumpkin> yeah
11:30:03 <copumpkin> I wrote bindings to them a while back too
11:30:03 <roconnor> GMP at least supplies sqrt
11:30:19 <roconnor> copumpkin: where is the package on hackage?
11:30:27 <lispy> I forgot which module, but base has a decently performing integer log.
11:30:48 <Cale> lispy: Whaaa? :)
11:31:01 <lispy> At least, when I was doing primality testing it wasn't the bottle neck
11:31:06 <lispy> Cale: it's not exposed
11:31:19 <Cale> oh
11:31:22 <lispy> And this was circa 2003
11:31:25 <Cale> That's interesting
11:31:28 <lispy> So I may have some details wrong
11:31:54 <lispy> I either used it for RSA or primality testing.  It's hard to recall correctly
11:32:25 <dolio> Is the C-- FFI interface available yet? That might make writing a package that imports more GMP stuff easier.
11:32:32 <copumpkin> yeah
11:32:35 <Cale> Man, at some point I'm going to have to fix all my broken Haskell library bookmarks. One advantage of the big extralibs library in older GHCs was that all the documentation was in one place on the web.
11:32:37 <copumpkin> foreign import prim
11:32:49 <copumpkin> roconnor: it wasn't a package
11:33:01 <copumpkin> although I was going to make a package binding specifically to the Natural component
11:33:02 <dolio> I couldn't remember if it was already in 6.12 or slated for 6.14, though.
11:33:11 <Cale> I suppose I could use my local documentation for that, but cabal doesn't automatically produce non-versioned symlinks to documentation either.
11:33:31 <copumpkin> dolio: 6.12 already has it for integer-gmp, but not sure if everyone can use it
11:33:38 <dolio> Ah.
11:33:40 <monochrom> you can't refer irc friends to your local docs :)
11:33:40 <Cale> (so the local urls for stuff has the version number encoded in it)
11:33:46 <Cale> That's true as well.
11:34:09 <Cale> (Though, I could just symlink my documentation directory into my webserver's directory.
11:34:16 <Cale> )
11:34:34 <monochrom> then your webserver will be #haskelled
11:34:50 <Cale> Everyone should have their own webserver, it's so convenient :)
11:35:23 <Cale> None of this facebook nonsense.
11:36:00 <copumpkin> oh I guess I didn't bind to log and sqrt in this patch
11:36:07 <copumpkin> I did some more of them somewhere but not sure where: http://hackage.haskell.org/trac/ghc/ticket/3489
11:36:13 <monochrom> but people don't want to set up their own webservers
11:36:14 <tensorpudding> webhosting isn't free though
11:36:15 <copumpkin> that's the patch, which still hasn't made it in
11:36:29 <tensorpudding> also it's not automatic, and requires writing code
11:36:36 <Cale> tensorpudding: It's almost free if you just use your own computer to do it.
11:36:39 <Cale> (like I do)
11:36:47 <tensorpudding> It's not free if you use your own computer to do it.
11:36:56 <Cale> Well, you have to keep the computer running.
11:36:59 <tensorpudding> Leaving a computer running so that other people can use it wastes electricity
11:37:01 <Cale> But I'd do that anyway
11:37:21 <copumpkin> it's fairly easy to add new bindings
11:37:31 <copumpkin> but I'm not sure people want to bind to all of gmp in a ghc library
11:37:37 <tensorpudding> Also you need to set up DynDNS and all that so that you have a hostname
11:37:51 <Cale> tensorpudding: Right, that's about the most complicated step at present.
11:37:53 <monochrom> there is also some benefit of centralizations like facebook
11:38:07 <dolio> I think separate libraries for the naturals and floats might be all right.
11:38:25 <tensorpudding> Running a webserver on Windows that does something more than serve static pages is a pain
11:38:34 <dolio> Putting all the Integer stuff in integer-gmp makes sense, though.
11:38:35 <Cale> I use yi.org and gnudip2 for that, and it would be nice if it required less technical knowledge.
11:39:16 <copumpkin> dolio: yeah, I was going to write the natural one, but float isn't possible, according to edwardk
11:39:18 <Cale> tensorpudding: Setting up a wiki isn't *so* bad.
11:39:22 <copumpkin> at least using mpfr or anything that uses gmp
11:39:26 <dolio> Really?
11:39:34 <tensorpudding> You can run gitit.
11:39:49 <tensorpudding> Though I've been trying to get gitit to work with lighttpd, no success yet
11:40:02 <tensorpudding> also jsMath
11:40:10 <copumpkin> dolio: apparently changing the gmp allocator has nasty effects when using c libraries that use gmp objects internally, like mpfr
11:40:22 <copumpkin> dolio: stuff gets moved around and mpfr doesn't notice
11:40:33 <copumpkin> he said he was looking for a nice solution but couldn't find one
11:40:38 <dolio> I thought the floats sounded the most interesting, because they have pre-set sizes. You could put that in the type or something.
11:40:40 <dolio> Ah, I see.
11:40:53 <copumpkin> yeah, I was looking forward to doing that, too :/
11:40:58 <Cale> I've been running MediaWiki, mainly so that I don't have to write HTML by hand. Gitit looks pretty nice though, and being written in Haskell is a plus.
11:41:02 <copumpkin> we could do rationals, at least
11:41:17 <copumpkin> or use the gmp floats with their broken rounding
11:42:18 <dolio> It'd probably be best to make sure that the rationals give a significant speed-up over the Haskell-defined one before bothering to write a binding.
11:42:24 <copumpkin> yeah, I agree
11:42:40 <copumpkin> I'm hesitating about writing a natural binding because I'm not sure if it's worth it over Integer
11:42:41 <Cale> But probably what I get the most use out of is the simple ability to drop a file into apache's www directory to share it with others.
11:42:49 <tensorpudding> But the fact that MathML isn't supported in Webkit makes me sad sad.
11:42:50 <copumpkin> although conceptually I don't like using Integers as naturals
11:43:02 <dolio> It would be nice to have a Natural.
11:43:15 <dmwit> newtype Natural = Natural Integer -- problem?
11:43:16 <Cale> All these file hosting services with obnoxious waiting and captchas are a sign that more people could get use out of that ability.
11:43:29 <copumpkin>  dmwit: a little bit of sign checking etc. :P
11:43:35 <dolio> Although, even if you do, you can't statically check the literals.
11:43:41 <copumpkin> yeah :/
11:43:42 <dmwit> copumpkin: all done in instances ;-)
11:43:44 <dolio> It'd be fromInteger + a runtime error.
11:43:45 <copumpkin> that was another concern
11:43:49 <tensorpudding> There aren't enough publically routable IP's
11:43:52 <dmwit> fromInteger = abs
11:43:53 <tensorpudding> and enough domain names
11:44:09 <wli> Natural literals need changes to ghc source somewhere.
11:44:10 <copumpkin> lol
11:44:22 <tensorpudding> address space on the main street of the Internet is tough, the best you can get is a cardboard box
11:44:29 <tensorpudding> unless you want to pay
11:44:30 <wli> I never successfully tracked down precisely where.
11:44:45 <Cale> Free subdomains aren't too bad, but it would be good if there were easier to set up software for, say, the gnudip2 protocol.
11:44:45 <dolio> You can do stuff with template haskell.
11:44:56 <tensorpudding> What is gnudip2?
11:45:00 <dolio> As long as you don't mind writing $(fancy 19284985) and stuff.
11:45:01 <copumpkin> when I saw free subdomain, I thought he was talking about something mathematical
11:45:28 <wli> No go. Natural literals require compiler hacks.
11:45:51 <copumpkin> wli: not in your own qq, at least
11:45:56 <copumpkin> but not sure I'd call that a literal
11:45:57 <Cale> It's a protocol (and associated software) that I use for keeping my DNS records up to date with yi.org.
11:46:50 <tensorpudding> Is it a DNS server that does all the mangling behind the scenes?
11:48:07 <Cale> tensorpudding: Well, it's used by a bunch of the free subdomain providers who run their own DNS servers. The client just sends login information and a simple message to update the IP address they have on file.
11:49:04 <Cale> I'm actually not 100% sure why they don't just do something simpler, like use HTTP with a special (unforgeable) URL to set the IP to the address of the machine that requests it.
11:49:09 <yitz> dolio: john meacham did a beautiful implementation of lazy naturals a few years ago, but could not be convinced to upload it to hackage. you can find it on the cafe via google. someone else ought to cabalize and upload it.
11:50:05 <Cale> But then you still need some software to do that periodically -- setting that up is easy if you're a technical person, but still probably too tricky for the average guy.
11:50:14 <dolio> yitz: I actually mean an Integer-alike that doesn't contain any negatives. Lazy naturals would also be useful, though.
11:51:23 <Cale> In fact, gnudip2 makes life a bit harder in that it's the client's responsibility to know their own Internet IP address, which makes life hard for anyone behind a NAT.
11:51:49 <EvanR-work> Int Integer : Word ?
11:51:55 <EvanR-work> Wordeger ;)
11:51:56 <dolio> Right.
11:52:06 <dmwit> Cale: moanmyip.com solves that problem
11:52:28 <Cale> dmwit: haha
11:53:27 <Cale> For all these IP reporting servers, I haven't managed to find one that simply reports it as a simple piece of text with no surrounding HTML junk to sift through.
11:53:46 <mauke> Cale: http://checkip.dyndns.org/
11:54:00 <Cale> But these days I've taken to just scraping my router's configuration page.
11:54:17 <Cale> (It's also stupid that the router doesn't have such a page)
11:54:19 <dmwit> Most routers these days will do a dyndns-style thing for you.
11:55:10 <edwardk> hrmm the dstm code that was released today makes me want to clean up and package some old haskell paxos cluster code of mine
11:55:19 <edwardk> now i just need to find where i put it
11:55:26 <dmwit> (Mine updates dmwit.dyndns.org whenever it gets assigned a new IP address, for example.)
11:56:01 <Cale> In fact, I find it really strange that there isn't a standard protocol as part of NAT for getting the external IP.
11:56:24 <c_wraith> NAT is designed to be invisible at the client level.
11:56:35 <zygoloid> Cale: UPnP?
11:56:52 <Cale> zygoloid: Oh, does it do that?
11:57:08 <zygoloid> well, i've seen UPnP-using apps find my external IP, so i think so
11:57:23 <Cale> Hmm...
11:58:06 <zygoloid> http://en.wikipedia.org/wiki/Internet_Gateway_Device_Protocol
11:58:21 <Cale> I'll have to look into that then. It would be nice to be able to talk to my router in a standard way for this rather than using a custom HTML scraper.
11:59:28 <EvanR-work> whats a plug and play module to just friggin play wav files. loadWav :: Handle -> IO Sound, playSound :: Sound -> IO ()  ?
12:01:02 <EvanR-work> wouldnt that be cool ;)
12:01:45 <Cale> Yeah, particularly something which abstracted over the various audio resources on different platforms.
12:02:12 <EvanR-work> would have to do background mixing
12:02:13 <Cale> SDL-mixer might be usable
12:02:16 <BrianHV> are there portaudio bindings to haskell perhaps?
12:02:30 <Cale> yes
12:02:54 <Cale> So you might be able to use that :)
12:02:55 <EvanR-work> ah sdl mixer, considering 'just sdl' bindings have no sound at all, i figured sdl mixer was out of the question, will take a look
12:03:00 <b_jonas> EvanR-work: sox which is a commandline tool to play sound, run that from your haskell program
12:03:24 <eugenn> > 3+3
12:03:25 <lambdabot>   6
12:03:28 <EvanR-work> wouldnt want to read the sound files over and over
12:03:36 <EvanR-work> once for each sound effect playing
12:03:53 <zygoloid> Cale: the pupnp project on sourceforge seem to have an implementation. looks like you just need UpnpInit(0,0); UpnpGetServerIpAddress() ;-)
12:03:54 <EvanR-work> a process for each one
12:04:23 <b_jonas> EvanR-work: how about that mode of mplayer where you control it with text commands on a pipe?
12:04:40 <EvanR-work> for a game, wouldnt want to rely on mplayer being installed
12:04:50 <b_jonas> EvanR-work: (maybe sox can do that too)
12:04:56 <zygoloid> also not so good if you're not playing from an externally-visible resource
12:05:13 <b_jonas> EvanR-work: you're riddiculous, the mplayer core is installed on thousand times more machines than your haskell runtime
12:05:28 <EvanR-work> ._.
12:05:29 <b_jonas> EvanR-work: many other gui media players use mplayer inside
12:05:36 <dmwit> Yes... but many don't.
12:05:43 <EvanR-work> what game do you know if that requires mplayer?
12:05:46 <EvanR-work> of
12:06:06 <Cale> Using mplayer for a game's sound effects would probably introduce more latency than would be bearable :P
12:06:23 * EvanR-work refrains from starting a mplayer vs vlc war ;)
12:06:36 <monochrom> isn't there an "mplayer as a lib"?
12:06:40 <Cale> (vlc wouldn't be any better in that regard)
12:06:41 <b_jonas> EvanR-work: I dunno, but I know of windows programs (even games) that come with hundred megabyte large stupid utilites you never use
12:06:51 <EvanR-work> thats nice
12:06:54 <vanadium> ffmpeg...
12:06:55 <vanadium> ?
12:06:59 <b_jonas> Cale: if you don't fork it then it might not 
12:07:05 <EvanR-work> guys sdl_mixer is the answer
12:07:12 <EvanR-work> geez
12:07:18 <EvanR-work> WAV files
12:07:36 <ksf> you can use xinelib
12:07:37 <vanadium> Didn't sdl mixer do the thing where you need a sound server to be able to listen to music while having an sdl mixer thing run
12:07:49 <ksf> very simple and sane C interface
12:07:52 <EvanR-work> thats for 'midis' which are not sound files 
12:08:00 <ksf> sdl sucks for about everything it does
12:08:13 <ksf> another alternative is openAL
12:08:26 <monochrom> haskell has openAL binding
12:08:31 <EvanR-work> i do not need 3d sound, doppler effect, develop apathy, or kitchen sinks
12:08:35 <monochrom> it used to come with ghc too
12:08:46 <EvanR-work> sdl doesnt suck
12:09:03 <eugenn> > Monad m
12:09:04 <lambdabot>   Not in scope: data constructor `Monad'
12:09:05 <sproingie> actually for 2d it really kind of does
12:09:11 <sproingie> for sound perhaps its all right
12:09:13 <ksf> and 2d is what it's about.
12:09:29 <sproingie> it provides a software framebuffer with no accelleration possible
12:09:32 <ksf> even plain glut gives a better windowing abstraction
12:09:37 <EvanR-work> sdl_mixer has some annoyances in the sound department
12:09:44 <monochrom> @faq can haskell do 4d sound?
12:09:44 <lambdabot> The answer is: Yes! Haskell can do that.
12:09:46 <EvanR-work> but its ok
12:10:11 <ksf> xine would have the distinct advantage of being able to play everything through everything.
12:10:14 <eugenn> @quote sound
12:10:15 <lambdabot> DanPascu says: For God's sake, have mercy on us. I'm no mathematician, yet I find 'patch commutation' to sound reliable and trustworthy. 'Patch Flipping' sounds like a drunken monkey doing rollovers
12:10:16 <EvanR-work> but
12:10:28 <ksf> and it should be installed on virtually every linux
12:10:30 <sproingie> sdl 1.3 is supposed to provide rendering to texture.  it's slated to come out of alpha around the time of the perl6 port of duke nukem forever
12:10:33 <EvanR-work> ... im not playing m4a files in my game
12:10:36 <EvanR-work> ksf: it isnt
12:10:40 <EvanR-work> for example, mine
12:10:45 <ksf> well then play .oggs
12:11:33 <EvanR-work> file format is irrelevant, mainly my question was about playing soudn
12:11:52 <eugenn> @quote irrelevant
12:11:52 <ksf> openAL has the same properties, it should be able to output to anything the user needs.
12:11:52 <EvanR-work> you can get whatever decoder you want for whatever you want, as long as i can play the samples
12:11:53 <lambdabot> EvilTerran says: > sort "irrelevant" == sort "evilterran"
12:12:03 <ksf> and you definitely don't need to go 3d to use openGL
12:12:05 <ksf> er AL
12:12:19 <EvanR-work> sdl has more audio backends than openal
12:12:33 <ksf> but then, still, things like automatic stereo panning might be useful.
12:12:34 <EvanR-work> and doesnt have a nice mixer abstraction
12:12:53 <EvanR-work> i have to load the samples manually
12:12:56 <ksf> you don't want steps from the left and steps from the right sound the same.
12:13:09 <EvanR-work> yes i do
12:13:18 <EvanR-work> because its a 2d arcade game
12:13:31 <EvanR-work> and i got better things to focus on
12:13:54 <b_jonas> do you even need sound?
12:13:55 <yitz> floating point question - in the prelude, decodeFloat is defined using floatRadix as the base. But isn't decodeFloat implemented using frexp() from C, which by definition always uses 2 as the base?
12:14:00 <EvanR-work> sound effects!
12:14:09 <sproingie> sdl_mixer is about a hojillion times simpler than openAL for sure
12:14:51 <sproingie> haskell bindings to sfml would be nice
12:15:04 <EvanR-work> heh. c++
12:15:06 <ksf> if you want to hear about my true loyality: you should use jack.
12:15:15 * sproingie doesn't know jack
12:15:19 <b_jonas> yitz: woulnd't matter much in practice, as all (non-big) float types you'll meet in practice use some power of 2 as the base, in which case it's easy to convert, and almost all use 2 as the base
12:15:25 <sproingie> sfml has c bindings too
12:15:28 <ksf> which means you never did pro audio on linux
12:15:45 <b_jonas> yitz: but if you want to ask whether the numeric parts of the prelude suck, well yes, they do suck
12:15:45 <EvanR-work> using jack to play the sound would be slightly more complex to set up, and youd get audio dropouts due to almost everyones machine doing multitasking on a non rt system
12:15:45 <sproingie> just doing basic simple audio drove me insane
12:15:46 <yitz> b_jonas: but you have to know whether to convert.
12:15:47 <edwardk> yitz: decodeFloat is implemented as such on current platforms. in theory it is allowed to do something else. for instance if you implemented one of the ieee decimal floating reps
12:16:00 <b_jonas> yitz: wouldn't the implementation know that?
12:16:02 <ksf> jackd should always run RT.
12:16:22 <ksf> ...and no, you don't get dropouts once you have SCHED_RR
12:16:25 <EvanR-work> you get zero benefit of playing the game sounds via jack
12:16:26 <ksf> RT?
12:16:35 <sproingie> realtime
12:16:39 <EvanR-work> its already real time
12:16:42 <yitz> edwardk: on such platforms, frexp would be different than decodeFloat then?
12:16:44 <eugenn> rt == real time?
12:16:46 <EvanR-work> use a smaller output buffer
12:16:55 <ksf> _I_ get the benefit of being able to feed them through JaMin
12:17:06 <EvanR-work> user input cant cause sound any faster than the buffer size, on jack or anything else
12:17:08 <sproingie> the sound server situation on linux is maddening
12:17:18 <ksf> that's why everyone should use jack.
12:17:20 <yitz> b_jonas: i'm not asking about sucking, just want to know the true facts :)
12:17:27 <EvanR-work> alsa is not a sound server, delete pulse immediately, and reserve jack for pro audio
12:17:28 <edwardk> yitz: frexp is defined explicitly in terms of 2^exp
12:17:46 <yitz> edwardk: yeah. ok, thanks.
12:17:50 <ksf> alsa can't even multiplex.
12:17:50 <sproingie> s/ server//
12:17:58 <EvanR-work> sdl_mixer can
12:18:08 <ksf> yeah but not more than one program.
12:18:19 <EvanR-work> how many programs will this game use
12:18:25 <eugenn> > sort "jam"
12:18:26 <lambdabot>   "ajm"
12:18:30 <ksf> you're hogging the whole darn audio card.
12:18:37 <EvanR-work> uhm no
12:18:46 <EvanR-work> multiple alsa clients can use the card at once
12:19:03 <ksf> iff and only iff the card has hardware multiplexing.
12:19:15 <ksf> which is max. 4 channels, and doesn't work for spdif output.
12:19:21 <edwardk> yitz: not that you're likely to find too many such platforms,  but one could build a floating point type that had those properties, and it could even be ieee, due to ieee-754-2008 ;)
12:19:36 <EvanR-work> i dont think theres any common pc sound hardware which doesnt work
12:19:37 <abbe> ksf, iff = if and only if :)
12:19:45 <yitz> edwardk: but on those hypothetical other platforms, how would you implement decodeFloat then? It is guaranteed to be exact, so you must be able to pick apart the actual representation without doing math. But frexp() is defined as radix 2 always.
12:19:49 <ksf> abbe, I know.
12:19:53 <zygoloid> ksf: it depends. if the machine is running pulseaudio, and alsa is being rerouted through it, then that's fine...
12:19:53 <ksf> iff and only iff is even stronger.
12:19:59 <EvanR-work> sound server gripes belong to 2001
12:20:11 <yitz> is there some other C function that does that?
12:20:12 <EvanR-work> unless you have pulse installed
12:20:15 <zygoloid> EvanR-work: didn't you hear? 2010 is the year of sound server gripes on linux :)
12:20:22 <Zao> EvanR-work: I know of several cards of mine that do not have hardware mixing under alsa.
12:20:27 <zygoloid> just like 2009 was the year of mass network fail
12:20:31 <Zao> EvanR-work: OSS4 with vmix for the glorious win.
12:20:41 <edwardk> yitz: keep in mind you could need that for a particular floating point type on the platform you have NOW. RealFloat isn't limited to Double and Float you know ;)
12:20:45 <EvanR-work> Zao: are you saying alsa apps dont work together on that card?
12:20:51 <EvanR-work> which cards?
12:20:57 <zygoloid> Zao: OSS4: because what we need is even more possibilities for the audio stack :)
12:21:12 * ksf would conjecture a lot of usb cards
12:21:16 <Zao> zygoloid: They came before :D
12:21:19 <ksf> ...the non-pro ones, that is.
12:21:20 <Cale> zygoloid: heh, weird, that gives me my own local network IP :P
12:21:28 <zygoloid> Cale: ;(
12:21:33 <EvanR-work> ill put a note. if you play my game unplug your usb sound card
12:21:33 <Zao> EvanR-work: USB Live!, onboard realteks.
12:21:41 <zygoloid> Cale: maybe you need to tell it your router's ip?
12:21:43 <yitz> edwardk: hmm. ok.
12:21:45 <EvanR-work> its not a very intensive sounding game
12:21:50 <Zao> The latter being a rather common kind, I'd say.
12:21:53 <Cale> Yeah
12:21:56 <yitz> edwardk: TNX
12:22:08 <ksf> EvanR-work, still, you might want to use xine.
12:22:13 <yitz> toLower(^^)
12:22:16 <zygoloid> ksf: (if and only if) and only (if and only if) == if and only if and only if and only (only if) == iff and only (only if) ?
12:22:18 <Zao> Anyway, -blah is cool.
12:22:19 <EvanR-work> ksf: why?
12:22:25 <ksf> if only for the fact that the users can provide their own background music.
12:22:27 <EvanR-work> Zao: is oss4 a totally different api from oss/
12:22:40 <abbe> EvanR-work, backward compatible.
12:22:46 <eugenn> > toLower (^^)
12:22:47 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:22:48 <lambdabot>         against inferred type...
12:22:51 <EvanR-work> ksf: its called the music volume option, set to zero and run xmms as a multitasked program
12:23:03 <ksf> zygoloid, only the first one.
12:23:13 <EvanR-work> though i have no considered in game music at this point
12:23:19 <ksf> which won't work because you hog the sound card.
12:23:22 <Zao> EvanR-work: It has a new mixer API, but it's also compatible.
12:23:28 <EvanR-work> ksf: how so?
12:23:38 <ksf> because not all cards can hardware mix.
12:23:41 <edwardk> yitz: posix doesn't specify methods for dealing with the more exotic floating point reps. otoh, something like mpfr/mpf can provide a valid realfloat that has a different radix, etc. you could even choose to build one yourself right in haskell.
12:23:41 <EvanR-work> so?
12:23:54 <ksf> so you _need_ a sound server or play background music yourself.
12:23:55 <zygoloid> ksf: that is /so/ not the app's responsibility to sort out
12:23:58 <EvanR-work> and?
12:24:08 <EvanR-work> the library will decide 
12:24:35 <ksf> zomfg just have a look at the xine lib and see whether you like it.
12:24:48 <edwardk> for instance: http://hackage.haskell.org/packages/archive/fixed-precision/0.4.0/doc/html/Numeric-Fixed.html -- though i didn't bother to implement RealFloat for various technical reasons. and it is broken because hmpfr is broken under the current build of mpfr.
12:25:02 <EvanR-work> does it magically decide on arts, esd, pulse, jackd, oss to use ;)
12:25:06 <ksf> gstreamer comes to mind, too.
12:25:08 <yitz> edwardk: yeah, i see. i'm trying to interact with Python. it defines sys.float_info.radix, which might not be 2, but only math.frexp(), no other way to pick apart floats. not sure what to do.
12:25:13 <eugenn> > sort "Dropbox"
12:25:14 <lambdabot>   "Dbooprx"
12:25:15 <ksf> should have a decently abstracted output module.
12:25:22 <EvanR-work> in that case ill go with sdl mixer
12:25:33 <EvanR-work> since it does the same thing
12:25:43 <EvanR-work> and who on earth uses arts or esd
12:25:59 <Zao> EvanR-work: People who get it bundled with their distro.
12:26:02 <edwardk> yitz: fixing python APIs is left as an exercise for the reader ;)
12:26:08 <EvanR-work> they can die and fix their system
12:26:30 <EvanR-work> no modern distro installs those
12:26:41 <yitz> edwardk: i have in fact fixed things in python's API in the past, but that wasn't my current work plan :)
12:28:00 <eugenn> @type map
12:28:01 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:28:20 <eugenn> @type liftM2
12:28:21 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:29:51 <ksf> noone should use arts or esd
12:30:09 <EvanR-work> or pulse
12:30:10 <ksf> esd possibly because it was the first server, but arts is just broken.
12:30:54 * ksf thinks jack is going to get more consumer features in the future and then it'll own the market.
12:31:01 <edwardk> yitz: what do you need the (real) radix for? you have frexp which gives you a float in an mantissa and exponent form, such that you could glue it back together and get more or less the original argument
12:31:20 <EvanR-work> jack doesnt have an automatic way to connect to the sound output port
12:31:25 <EvanR-work> you have to guess at the name
12:31:31 <ksf> oh yes it does
12:31:34 <EvanR-work> or give the option to users
12:31:49 * hackagebot filestore 0.3.4.2 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.3.4.2 (JohnMacFarlane)
12:32:00 <ksf> but I agree that it should be more configurable, it connects always to the system ports, by default.
12:32:02 <yitz> edwardk: to create a RealFloat instance, more or less is not good enough, it is required to be exact.
12:32:16 <ksf> ...I might want to feed everything to jamin or something, instead.
12:32:26 <ksf> or an ac3 encoder.
12:32:28 <EvanR-work> also jack (rightly so) has no api for just playing a stream of samples. you have to manually feed the samples to the output buffer in chunks
12:32:39 <edwardk> yitz: if sys.float_info.radix is not 2 you're going to be screwed anyways. so yell at compile time =P
12:32:42 <eugenn> @type vlookup
12:32:43 <lambdabot> Not in scope: `vlookup'
12:32:56 <yitz> edwardk: why?
12:32:59 <edwardk> because python will have officially have jumped the shark ;)
12:33:21 <ksf> yes, as I said, more consumer orientation.
12:33:31 <edwardk> because they'll have given you a radix that they don't give you the tools to work with
12:33:32 <ksf> but from a technical pov, it's better than anything out there.
12:33:42 <EvanR-work> i agree
12:34:07 <yitz> well, yeah. or i could cheat and *not* be exact. or i could make the likely but potentially false assumption that sys.float_info.radix == 2 always.
12:34:26 <EvanR-work> but you have to set a global buffer size, and for its normal use cases you set that to pretty low to reduce interaction latency
12:34:30 <ksf> ...and I think netjack should come with compression.
12:34:34 <copumpkin> edwardk: like the number three in your twitter stream? :P
12:34:38 <EvanR-work> but for normal people they dont care about that and would rather not have dropouts
12:34:48 <EvanR-work> and they need a higher buffer size
12:34:55 <ksf> you should run the whole thing RT
12:34:58 <edwardk> copumpkin: ?
12:34:58 <EvanR-work> you have to set the whole system up carefully
12:35:05 <yitz> edwardk: i think i'm going to choose the lazy path, which is to close my eyes tightly and use frexp as is.
12:35:08 <ksf> again, consumer orientation.
12:35:09 <copumpkin> edwardk: looking at your recent tweets, many of them appear thrice!
12:35:11 <EvanR-work> ksf: people dont have computers/DE that can handle 64 sample buffers
12:35:23 <copumpkin> edwardk: it might just be twitter being wonky though
12:35:26 <EvanR-work> moving the mouse will upset it
12:35:32 <ksf> distro kernels should come with RT, distros should set up the rights, etc.
12:35:39 <EvanR-work> RT will not help that
12:35:44 <ksf> oh, and jack should possibly support more than one user per server.
12:35:49 <edwardk> copumpkin: twitter being wonky. twitter.com/kmett only shows one each for me
12:35:59 <ksf> then use bigger sample sizes by default.
12:36:18 <copumpkin> edwardk: yeah, weird, it's removed the duplicates now
12:36:22 <ksf> the pro audio folks will always be able to change the setting, consumers don't care.
12:36:51 <ksf> ...and probably make it configurable at run-time. and provide some mechanism to re-connect clients on server restarts.
12:37:11 <EvanR-work> also jack is linux only
12:37:27 <EvanR-work> at the moment
12:37:54 <ksf> well I don't give a fuck.
12:37:58 <copumpkin> :O
12:38:25 <ksf> if someone wants to use my programs on windows, they can bleeding port it.
12:38:30 <eugenn> > repeat ":o"
12:38:32 <lambdabot>   [":o",":o",":o",":o",":o",":o",":o",":o",":o",":o",":o",":o",":o",":o",":o"...
12:38:36 <ksf> I won't buy a license to satisfy their laziness.
12:38:47 <EvanR-work> 'if someone has a shitty sound card that alsa doesnt work with, they can fix alsa'
12:39:11 <EvanR-work> we get very productive if we dont care about end users
12:39:20 <ksf> yes.
12:39:23 <ignorabimus> does any of you use "The Haskell Platform" 2010.2.0.0? I dont get cabal running: "This version of cabal is to old to work with ghc-6.12+' 
12:39:28 <ksf> so upstream, that is, alsa, should care about you, the user.
12:39:33 <ignorabimus> But the platform contains 6.12.3
12:39:46 <ignorabimus> Any himts, what I can do?
12:40:08 <Ke> why would some sick person make default linux with rt-scheduling and stuff
12:40:30 <ksf> because enabling RT scheduling doesn't hurt the rest of your system?
12:40:31 <Ke> I hear there is a price to that and no advantages for typical users
12:40:35 <EvanR-work> yes it does
12:40:36 <tensorpudding> JACK is available for Windows, OSX and FreeBSD
12:40:39 * copumpkin is so sleepy
12:40:41 <edwardk> odd how scalbnf tends to be defined in terms of FLT_RADIX but frexp is deliberately in terms of '2'
12:40:49 <EvanR-work> it slows down processing, but reduces interrupt latency
12:40:56 <ksf> you don't need preemption and all that punk.
12:41:15 <Mathnerd314> what class of grammars can Parsec parse? can it do PEG's?
12:41:20 <ksf> ...just very, very high priority scheduling. soft rt is more than enough for jack.
12:41:32 <EvanR-work> in a carefully controlled system it could make your audio work better
12:41:38 <ksf> it needs to hit deadlines, not use a lot of cpu.
12:41:48 <edwardk> Mathnerd314: with enough elbow grease. though it doesn't by default have the memoizing machinery to do the packrat stuff
12:41:49 <EvanR-work> many jack programs do need a lot of cpu
12:41:54 <b_jonas> edwardk: C has bitwise ops which you'd probably only implement on a binary machine anyway, so most likely such machines would have binary floating points with the base being some power of 2
12:42:04 <ksf> yes, but that doesn't matter for the consumer folks
12:42:07 <ulfdoz> Using a lot of CPU does the application, finally breaking any RT-properties.
12:42:19 <edwardk> b_jonas: even on a binary machine ieee defines decimal float reps, they just don't get used much
12:42:32 <edwardk> b_jonas: they are quite useful in finance, etc.
12:42:53 <b_jonas> edwardk: sure, and there are also libraries for big decimal floating point etc
12:43:28 <edwardk> b_jonas: yes. i was just trying to address yitz's concern about how, one actually disassembles a float on a machine where FLT_RADIX in float.h isn't 2. ;)
12:43:41 <Mathnerd314> edwardk: so the naswer is no?
12:43:51 <b_jonas> edwardk: if it's not 2 but a poweer of 2 that wouldn't be such a big problem
12:44:23 <b_jonas> and you can bring in the frexp with the foreign interface anyway
12:44:31 <edwardk> b_jonas: true, the common radixes that have popped up in float.h over the years have been 2, 10, and 16 anyways.
12:45:42 <edwardk> b_jonas: yes. but frexp is a 2. i was curious because upon reflection i couldn't think of a posix-esque frexp-like method that worked with FLT_RADIX. just struck me as an interesting lacuna in the specifications
12:46:02 <yitz> b_jonas: that's just the problem. all i have is frexp through ffi, so i can't reliably define a RealFloat instance.
12:46:20 <b_jonas> yitz: oh, you want to implement a new float type?
12:46:30 <yitz> edwardk: it struck me harder than it struck you
12:46:41 <b_jonas> yitz: I though you just wanted to use floats
12:46:41 * copumpkin strikes both of you
12:47:02 <yitz> copumpkin: but please, please don't ask lambdabot to do that...
12:47:19 <eugenn> @smack lambdabot
12:47:19 * lambdabot loves lambdabot, so no slapping
12:47:42 <eugenn> @hit lambdabot
12:47:43 <lambdabot> No match for "lambdabot".
12:47:52 <yitz> b_jonas: no, i have python floats, and i am trying to define a RealFloat instance.
12:47:57 <eugenn> @strike lambdabot
12:47:57 <lambdabot> Unknown command, try @list
12:48:07 <yitz> @help slap
12:48:07 <lambdabot> slap <nick>. Slap someone amusingly.
12:48:14 <eugenn> @smack eugenn
12:48:15 * lambdabot puts on her slapping gloves, and slaps eugenn
12:48:16 <EvanR-work> python floats are different from normal floats?
12:48:17 <b_jonas> yitz: big floats or fixed floats?
12:48:26 <edwardk> yitz: well, what you can do is always lie and give back the radix as 2 and use frexp and ldexp
12:48:32 <edwardk> rather than scalb
12:48:52 <yitz> b_jonas: whatever the python interpreter provides. happens to be fixed.
12:49:09 <yitz> edwardk: yes i think that's what i'll have to do
12:49:40 <b_jonas> yitz: is this a haskell implemented in python or something?
12:49:48 <edwardk> yitz: keep in mind python floats using a FLT_RADIX based on the contents of float.h, which will be the same as the basic CFloat, CDouble radix anyways.
12:49:49 <b_jonas> just curious
12:50:04 <edwardk> er are using
12:50:18 <edwardk> so you don't need to kill yourself on this ;)
12:50:54 <yitz> edwardk: oh, you mean give 2 as floatRadix. hmm. nah, i'll leave that the truth. so that it can be checked. i really don't think this is going to come up, so i'm going to stop worrying about it.
12:51:29 <edwardk> yitz: what i'm saying is that both ghc and python are relying on the same machinery. =P
12:51:41 <yitz> b_jonas: something like that. not exactly haskell, and not exactly implemented in python. a subset of haskell compiled to python.
12:51:58 <yitz> edwardk: yeah, true.
12:52:41 <eugenn> @help smack
12:52:41 <lambdabot> slap <nick>. Slap someone amusingly.
13:04:32 <EvanR-work> i swear i spend most of my php time hitting tab to get over to the ridiculously nested code blocks
13:07:49 <ezyang> So, I've been thinking of an analogy for iteratees as the classic imperative BufferedInputStream, but with the buffer made persistent. 
13:08:09 <ezyang> Has anyone thought up of this already? 
13:09:42 <copumpkin> don't bufferedinputstreams abstract you from having to ask for more explciitly?
13:09:56 <copumpkin> you can say "give me X many"
13:10:14 <copumpkin> I guess you could do that with an iteratee-like thing
13:12:12 <ezyang> copumpkin: Yeah. 
13:12:41 <ezyang> So you can build the "nice" interface on top of an iteratee 
13:12:57 <ezyang> And the usual iteratee is a sort of no copy version of buffered input stream. 
13:12:57 <copumpkin> has anyone done that?
13:13:10 <ezyang> Dunno :-) 
13:13:35 <ezyang> iteratee is the canonical library, right? 
13:13:48 <copumpkin> not sure, I've only played with my own toy versions
13:13:59 <EvanR-work> iteratee is for IO ?
13:14:15 <ezyang> EvanR-work: Yeah. 
13:14:25 <ezyang> It's kind of a natural extension of lazy bytestrings. 
13:14:31 <robryk> I think snap does that somewhere
13:14:38 <ezyang> except that in the case of lazy bytestrings, only pure computations generate them. 
13:16:31 <Eridius> conal: I had a discussion with my (apple engineer) roommate last night about the possibility of code-gen on the phone
13:16:58 <Eridius> the short answer is there's no way to allow it securely without a big rearchitecture of the kernel (one that would add a significant performance penalty)
13:17:16 <copumpkin> mprotect?
13:17:35 <copumpkin> oh are you talking about object file generation etc.?
13:18:26 <Eridius> yeah mprotect. iPhone doesn't let writable pages get marked executable
13:19:09 <copumpkin> sure, but you write them when not executable, then make them unwritable and executable
13:19:18 <copumpkin> or have they changed it so that doesn't work anymore either?
13:19:23 <Zao> maybe they're tainted for life?
13:19:28 <Eridius> you can't use mprotect, period
13:19:28 <copumpkin> (it did a couple of releases ago)
13:19:29 <CHRIS_____> hey
13:19:34 <robryk> why big? doesn't iphone have support for some sort of permissions you give or deny an application upon installation?
13:19:47 <CHRIS_____> what's haskell good for?
13:19:52 <copumpkin> CHRIS_____: everything
13:19:52 <Zao> CHRIS_____: Anything.
13:19:54 <Eridius> CHRIS_____: nothing at all. It's just a toy
13:19:55 <Eridius> :p
13:19:58 <CHRIS_____> lol
13:20:08 <c_wraith> CHRIS_____: programming
13:20:17 <CHRIS_____> can you give me some good stuff to read about haskell?
13:20:22 <c_wraith> It's really pretty bad at baking cakes.
13:20:23 <Cale> Sure
13:20:27 <Cale> @where lyah
13:20:28 <lambdabot> http://www.learnyouahaskell.com/
13:20:31 <Cale> @where rwh
13:20:31 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:20:31 <CHRIS_____> thanks
13:20:36 <Cale> @where yaht
13:20:37 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
13:20:43 <copumpkin> Eridius: because apple's static analysis will catch that and reject it when you submit to the appstore? or are they actually blocking the syscall with seatbelt now?
13:21:19 <danderson> I vaguely recall a haskell guide on how to design nice types for APIs, which among other things had "derive Show" in it. Anyone know what I'm talking about and have a link?
13:21:41 <Cale> CHRIS_____: Also, feel free to ask questions here. There are a lot of things where it's still a lot easier to just ask than to find the appropriate documentation.
13:21:53 <CHRIS_____> Cale: thank you :]
13:21:53 <Cale> (and people are generally pretty friendly here)
13:22:00 <Eridius> copumpkin: AFAIK, mprotect is blocked via sandboxing.
13:22:06 <copumpkin> ah okay
13:22:09 <copumpkin> I guess they finally started doing that :P
13:22:17 * copumpkin hasn't tinkered with iphones in a while
13:22:20 <Eridius> I haven't actually tested though, but that's what I'm told
13:22:27 <b_jonas> they don't use libc or gcc, are they? 
13:22:38 <b_jonas> those recommend executable writable pages, period
13:22:45 <b_jonas> one of them at least
13:22:52 <Nibble_>     x /= y     =  not (x == y)
13:22:53 <Nibble_>     x == y     =  not (x /= y)
13:22:57 <Nibble_> how the hell does that work?
13:23:01 <Eridius> b_jonas: not sure what you mean
13:23:05 <b_jonas> Nibble_: you define one, the other is defaulted
13:23:05 <Cale> Nibble_: You're expected to override one of those
13:23:06 <sproingie> you can't define both
13:23:06 <copumpkin> Nibble_: infinite loop? :P
13:23:08 <Nibble_> shouldn't it be an infinite lloop
13:23:13 <Nibble_> loop*
13:23:15 <b_jonas> sproingie: can't you?
13:23:18 <copumpkin> sproingie: you could
13:23:20 <benmachine> Nibble_: it is, unless you override one
13:23:21 <sproingie> well you can it's just bottom
13:23:22 <Nibble_> Cale: override?
13:23:24 <Cale> Nibble_: Those are default definitions, so that you can define one and get the other for free.
13:23:26 <copumpkin> sproingie: why?
13:23:32 <obfuscated> does someone know of a tutorial/site that explains web session management in haskell?
13:23:33 <copumpkin> if you define neither it's bottom
13:23:39 <edwardk> c_wraith: of course it is, if you took the time to take out the garbage while you were in the middle of baking a cake, you might forget to take it out on time too!
13:23:40 <Cale> Nibble_: You have to define one of the two for it to actually work.
13:23:47 <ezyang> obfuscated: What framework? 
13:23:51 <Nibble_> Cale: ok. but how would I override it? Some comparing function I guess
13:23:51 <Cale> (In the instance declaration)
13:23:52 <sproingie> right, you can define both.  i meant you can't define both that way
13:23:54 <Cale> yeah
13:24:03 <Cale> instance Eq MyType where
13:24:04 <obfuscated> ezyang: no framework :)
13:24:06 <Cale>   x == y = ...
13:24:14 <Eridius> edwardk: does it do the cooking by the book?
13:24:26 <EvanR-work> it is theoretically satisfying to defined == and not /= and vice versa ;) no implementation!
13:24:48 <ezyang> I doubt you'll find a tutorial, in that case. 
13:24:48 <EvanR-work> it just cant evaluate anything
13:25:23 <Cale> There are some classes, like Exception, for which no implementation is a good implementation.
13:25:32 <edwardk> Eridius: well, you use the IO monad to build up the recipe. After that you just need to evaluate it (and clean the mixing bowl)
13:25:34 <sproingie> obfuscated: web stuff in haskell is a rapidly evolving world of frameworks, there's nothing quite "official" yet
13:25:47 <copumpkin> and call lil jon
13:25:49 <Cale> (By which I mean you can just write   instance Exception MyType   and leave it at that)
13:26:01 <sproingie> obfuscated: i'd take a look at yesod, it looks like one of the nicer ones
13:26:02 <Eridius> edwardk: why can't you just drop the mixing bowl on the floor and let the system reclaim it when you're done?
13:26:29 <b_jonas> Cale: is that because all methods are defaulted to the right thing? or there are no methods at all?
13:26:49 <EvanR-work> Eridius: because the contents of the bowl are infinite and wed get a leak? :)
13:26:49 <Cale> b_jonas: All methods are defaulted to the right thing, assuming an instance of Typeable and Show
13:27:18 <edwardk> Eridius: because, the mixing bowl is an expensive resource that you should make an effort to preserve.  you don't want to have to run out and get a new one. after all you're using haskell, so you're probably on an academic's budget and that would  considerably add to the cost of the cake.
13:27:41 <Eridius> ahh
13:28:14 * Cale wonders how the other thread of conversation resulted in edwardk's latest comment :)
13:28:32 * Eridius chuckles
13:28:33 <edwardk> heya cale =)
13:28:38 <Cale> hey
13:29:04 <sproingie> you can drop the bowl, problem is *you* are also the garbage collector
13:29:11 * Cale also wonders why the UPnP library gives nothing but "Socket Error" when he gives it the address of his router.
13:29:38 <zygoloid> is it ok to use unsafeCoerce to implement things which i could implement a slower and more laborious way?
13:29:54 <edwardk> zygoloid: i'm typically willing to
13:29:57 <Cale> zygoloid: Occasionally?
13:30:04 <Heffalump> zygoloid: IMO yes. A good example is floating point decoding.
13:30:36 <edwardk> Heffalump: or fmap MyNewType
13:30:39 <EvanR-work> fromIntegral :: Word -> Int
13:31:21 <Cale> Actually, floating point decoding is something I'd feel quite uneasy about using unsafeCoerce for, though I suppose it should work.
13:31:33 <Heffalump> it does assume IEEE
13:31:40 <Cale> I'd probably just use decodeFloat for that.
13:31:43 <zygoloid> my example is casting away a type equality constraint in code where i can prove it must hold
13:31:45 <Heffalump> but then Word -> Int makes assumptions
13:31:57 <zygoloid> (but the compiler can't see that, sadly)
13:32:07 <Heffalump> zygoloid: darcs uses that all over the place :-)
13:32:10 <dolio> You shouldn't really use it for Word -> Int.
13:32:14 <Cale> I also wouldn't use it for any other numeric conversions. Unwrapping newtypes I consider okay though.
13:32:30 <zygoloid> Heffalump: hah, excellent, just the sort of answer i was hoping for :)
13:32:34 <Heffalump> Cale: yeah. Actually the use case I was thinking of was the int -> floating bit-pattern conversion.
13:32:47 <Heffalump> zygoloid: though only on phantom types
13:33:01 <dolio> If it's casting between two types that you know are equal, but can't prove so in the type system, that's about the only legitimate use.
13:33:23 <b_jonas> wouldn't it be easy to implement such numeric conversions (Word to Int, or Double to Int, or decoding a Double) by importing a custom C function?
13:33:36 <zygoloid> dolio: i /can/ prove it in the type system, but it would require a /lot/ of code.
13:33:51 <dolio> Well, okay.
13:33:58 <edwardk> b_jonas: sure. but note there is also some magic there. because there are coerces in the conversion from Float to CFloat to call your c function ;)
13:34:04 <b_jonas> dolio: if you can prove they're _equivalent_ (not equal), you could unpack and repack them
13:34:17 <b_jonas> prove that in the type system that is
13:34:42 <zygoloid> Heffalump: it's not strictly a phantom type. i'm passing around instances for the type, but no values of the type
13:34:52 <dolio> b_jonas: There are word2Int primops, I think.
13:35:03 <dolio> The problem is, there's no double2word and word2double.
13:35:21 <dolio> So unsafeCoerce is your only recourse, even though it's not technically safe, if I understand correctly.
13:35:49 <b_jonas> edwardk: couldn't the C function have argument type of HsDouble (provided that's one of float, double, and long double)?
13:36:06 <b_jonas> edwardk: then you do the conversion explicitly in C
13:36:10 <edwardk> b_jonas: so now the semantics of your code depend on whether or not RULES were applied, (not just the unsafeCoerce)
13:36:26 <b_jonas> edwardk: huh? what RULES?
13:36:43 <edwardk> on the conversion from Float to CFloat
13:36:46 <dolio> I think there's a ticket for the Word <-> Double stuff.
13:36:55 <edwardk> (i wrote that before you said use HsDouble)
13:36:59 <b_jonas> oh
13:37:00 <b_jonas> I see
13:37:38 <b_jonas> also, if you really want unsafe, couldn't you use the Ptr part of the ffi to convert between equivalent types unsafely?
13:37:50 <b_jonas> numeric types I mean
13:37:53 <Saizan> converting the bit representation is easy
13:37:54 <b_jonas> not algebraic
13:37:56 <ezyang> b_jonas: unsafeCoerce :-) 
13:38:04 <edwardk> b_jonas: sure, but if you're going there, just unsafeCoerce ;)
13:38:24 <dolio> I think casting Ptrs is the recommended way of converting Word -> Double in the ticket.
13:38:27 <b_jonas> unsafeCoerce is for algebraic (or function) types, isn't it?
13:38:33 <Saizan> the problem is thatthere aren't string guarantees about what an implemnetation would use in the first place
13:38:38 <dolio> Or, Double -> Word, I can't recall which was needed.
13:38:39 <Saizan> *strong
13:38:41 <b_jonas> dolio: er no, not for Word->Double
13:38:48 <b_jonas> dolio: they're not represented the same
13:38:54 <Cale> I'd always use fromIntegral when converting between C numeric types and their Haskell counterparts.
13:38:57 <b_jonas> dolio: I mean for Word->Int or Double->CDouble
13:39:08 <edwardk> b_jonas: it'd work for Word to Double and vice versa due to implementation quirks
13:39:11 <b_jonas> dolio: but I don't recommend that really, only recommend it over unsafeCoerce
13:39:30 <dolio> Word -> Int has a primop already, I'm pretty sure.
13:39:30 <b_jonas> I'd prefer a custom c function 
13:39:37 <copumpkin> yeah
13:39:40 <b_jonas> dolio: is there a public interface for that?
13:39:49 <copumpkin> fromIntegral? 
13:40:03 <copumpkin> it should get rewritten to the primop I think
13:40:23 <edwardk> b_jonas: http://www.haskell.org/ghc/docs/6.6/html/libraries/base/GHC-Prim.html#v%3Aint2Word%23 and vice versa
13:40:27 <b_jonas> copumpkin: doesn't fromIntegral convert through Integer? 
13:40:35 <b_jonas> copumpkin: oh, rewritten
13:40:36 <b_jonas> copumpkin: I see
13:40:40 <copumpkin> b_jonas: it has plenty of rewrite rules attached to it iirc
13:40:41 <dolio> GHC.Prim.int2Word :: Int# -> Word#
13:40:45 <copumpkin> otherwise it'd be death
13:40:55 <dolio> Apparently there is an int2Double#, too.
13:41:11 <b_jonas> copumpkin: does floor :: Double -> Int get rewritten too?
13:41:22 <copumpkin> I think there was a bug open about that
13:41:57 <b_jonas> copumpkin: could it in theory be rewritten without breaking public semantics?
13:42:58 <monochrom> yes there are almost quadratically many rewrite rules for fromIntegral to avoid the middleman
13:43:15 <b_jonas> monochrom: that's great
13:43:20 <copumpkin> no it isn't :P
13:43:29 <c_wraith> can you generate RULES from TH? :)
13:43:33 <b_jonas> now I only need to worry about the floating point conversions, not the all-integral ones
13:43:55 <copumpkin> b_jonas: when in doubt, check the core
13:44:07 <edwardk> b_jonas: realToFrac is just a mess.
13:44:13 <EvanR-work> when in doubt, dump core
13:44:15 <aavogt> data Pragma
13:44:16 <b_jonas> copumpkin: if I'm in doubt I just import a c function from ffi
13:44:16 <aavogt>   = InlineP Name InlineSpec
13:44:18 <aavogt>   | SpecialiseP Name Type (Maybe InlineSpec)
13:44:31 <aavogt> c_wraith: those are all you get
13:44:31 <copumpkin> b_jonas: well, check the ghc core first to make sure you aren't redoing what it's already giving you :P
13:44:39 <b_jonas> copumpkin: there's no public interface for a Double->Double floor variant, is there?
13:44:40 <dolio> Oh, double2Int# isn't what I was thinking.
13:44:56 <b_jonas> copumpkin: if I name the function, one can replace it with the builtin later
13:44:57 <edwardk> dolio: just a rounded version?
13:45:01 <copumpkin> b_jonas: not that I know of
13:45:04 <benmachine> class BestEverClass a b where conv :: a -> b
13:45:05 <b_jonas> when optimizing
13:45:14 <dolio> edwardk: Something like that. Truncated maybe?
13:45:18 <dolio> I was expecting bits.
13:45:20 <edwardk> benmachine: there is a better class
13:45:29 <b_jonas> benmachine: nah, you need four for the four rounding modes (floor, ceil, round, trunc)
13:45:37 <edwardk> class Iso a b where iso :: f a -> f b; instance Iso a a where iso = id
13:45:38 <copumpkin> benmachine: there is one of them
13:45:43 <benmachine> b_jonas: newtypes!
13:45:48 <b_jonas> benmachine: eww
13:45:52 <benmachine> :P
13:46:21 <benmachine> edwardk: copumpkin: namely?
13:46:32 <b_jonas> would that be conv (Floor (x :: Double)) :: Double ?
13:46:33 <dolio> edwardk: Looks like truncation.
13:46:34 <copumpkin> benmachine: I think CosmicRay had one
13:46:40 <edwardk> dolio: meh, oh well ;)
13:46:51 <edwardk> benmachine: the one i supplied above
13:47:03 <benmachine> b_jonas: I was thing in the result type, but it's stupid anyway >_>
13:47:14 <edwardk> benmachine: with generalized newtype deriving you can do all sorts of absurd things with it in constant time.
13:47:20 * benmachine scrolls
13:47:38 <edwardk> benmachine: confluence kind of goes out the window though
13:47:41 <aavogt> @hackage convertible
13:47:41 <lambdabot> http://hackage.haskell.org/package/convertible
13:47:48 <copumpkin> pff confluence
13:50:20 <CosmicRay> copumpkin: what was the question?
13:50:29 <edwardk> copumpkin: yeah who needs data types like 'Set' anyway? ;)
13:50:48 <EvanR-work> confluence?
13:50:49 <b_jonas> benmachine: wait, there's worse, you could also have a gadt typeclass that converts any numerit type to a representing type among the types equivalent with them, eg. converts Int and Int32 (or Int64 as approperiate) to the same type
13:50:58 <b_jonas> that would be ugly
13:51:03 <EvanR-work> convalenscence?
13:51:04 <copumpkin> CosmicRay: your convertible library :) benmachine proposed something like it and I was telling him you'd already been there, done that
13:51:04 <b_jonas> possibly uglier than a conv
13:51:10 <CosmicRay> ah ok
13:51:24 <copumpkin> oh speaking of Set (or Map, actually)
13:51:30 <copumpkin> Riastradh found a bug in Map
13:51:41 <copumpkin> I should email libraries@ with it, since he didn't want to subscribe
13:51:53 <benmachine> b_jonas: sounds like you are describing fromIntegral/realToFrac?
13:51:56 <edwardk> EvanR-work: if you don't do hinky things, in general haskell will make sure that if you have an instance of Foo for type Bar obtained by one means, and get another instance of Foo for type Bar by another means, they'll be the same.
13:51:56 * benmachine confused
13:52:23 <edwardk> EvanR-work: that way if you build a Set Int, and build another Set Int, they'll both agree on the order of the elements, and could be merged, etc.
13:52:40 <b_jonas> benmachine: no, it would convert Int64 and Int32 to different types, but all the newtypes for Int32 to the same type
13:52:51 <EvanR-work> edwardk: if you build two values of type Set Int the same way?
13:52:56 <edwardk> EvanR-work: if you play with implicits in Scala you get something rather 'typeclassy' but without that confluence property. which makes you much more likely to blow a hole in your foot
13:53:00 <benmachine> b_jonas: oic
13:53:09 <roconnor> confluence++
13:53:28 <EvanR-work> or two instances of Set, with param Int
13:53:32 <benmachine> b_jonas: so basically, any conversion that doesn't involve any computation?
13:53:43 <EvanR-work> er
13:53:50 <edwardk> EvanR-work: no matter how you build the Set. any instance of Ord for Int is the same instance.
13:54:15 <EvanR-work> it is?
13:54:43 <edwardk> EvanR-work: well, it should do the same things. it may be reconstructed
13:54:44 <EvanR-work> i guess you arent allow to redeclare the instance for that type.. ?
13:55:01 <edwardk> EvanR-work: correct. this is part of why you can't 'name instances'
13:55:27 <edwardk> in practice you can violate this property with orphan instances or bad type system extensions, etc.
13:55:45 <edwardk> but it holds at least spiritually.
13:56:19 <EvanR-work> spiritual haskell
13:56:20 <edwardk> (it is also why you can't define instances locally within a scope, or do several other things)
13:57:34 <edwardk> heya shapr
13:58:10 <edwardk> gotta run
14:14:33 <b_jonas> benmachine: yes
14:14:56 <EvanR-work> is there a when for Maybe
14:15:09 <b_jonas> benmachine: but with a gadt so you don't have to give an output type
14:15:12 <copumpkin> :t fromMaybe
14:15:13 <lambdabot> forall a. a -> Maybe a -> a
14:15:14 <copumpkin> :t maybe
14:15:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:15:18 <EvanR-work> yeah yeah..
14:15:26 <copumpkin> EvanR: what type would you like?
14:15:30 <EvanR-work> with explicit return () in them
14:15:34 <copumpkin> :t when
14:15:36 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:15:39 <copumpkin> when would work there too
14:15:49 <copumpkin> but not sure why
14:15:53 <copumpkin> :P
14:15:56 <benmachine> can't imagine it being a great deal of use
14:16:01 <benmachine> as opposed to guard or whatever
14:16:08 <copumpkin> Maybe () is isomorphic (ignoring bottoms) to bool
14:16:13 <EvanR-work> do something with the just value, nothing otherwise
14:16:21 <copumpkin> EvanR: fmap?
14:16:32 <copumpkin> still don't know what you mean really P
14:16:37 <copumpkin> >>= ?
14:16:39 <b_jonas> @hoogle (Monad m) => Maybe a -> (a -> m ()) -> m ()
14:16:40 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:16:40 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:16:40 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:16:44 <EvanR-work> :t lookup
14:16:45 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:17:12 <EvanR-work> when maybefoo (playSound (fromJust maybefoo))
14:17:28 <EvanR-work> coolWhen maybefoo playSound ;)
14:18:18 <benmachine> wait, so playSound :: IO () or whatever?
14:18:25 <EvanR-work> Sound -> IO ()
14:18:29 <benmachine> yeah I'd think maybe (return ())
14:18:34 <benmachine> :t maybe (return ())
14:18:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
14:18:52 <EvanR-work> me too... just not as succint as when
14:19:05 <benmachine> define it yourself then :P
14:19:44 <EvanR-work> whenJust = when . isJust, or something
14:20:04 <c_wraith> except isJust doesn't have the type you need.
14:20:13 <aavogt> @type isJust
14:20:14 <lambdabot> forall a. Maybe a -> Bool
14:20:16 <rfh> tried to compile, error message below: http://pastebin.com/YNtxjt2b
14:20:35 <benmachine> whenJust = maybe (return ()), or something
14:21:06 <EvanR-work> this is why haskell games never get finished ;)
14:21:21 <aavogt> rfh: uncurry doesn't combine more than 2 arguments
14:21:23 <benmachine> no it isn't
14:21:27 <EvanR-work> lol
14:21:28 <aavogt> @type uncurry foldr
14:21:28 <lambdabot> forall a b. (a -> b -> b, b) -> [a] -> b
14:21:33 <aavogt> @type foldr
14:21:34 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:22:07 <aavogt> rfh: see, it groups the first two together, giving you a function with 1 less argument
14:22:51 <EvanR-work> :t maybe
14:22:52 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:23:24 <rfh> aavogt: i need a uncurried version of zip on quadruples
14:23:27 <aavogt> rfh: you'll have to write your own   uncurry4, or just use zipp4 curried
14:23:49 <aavogt> @type \a b c d -> zip4 a b c d
14:23:50 <lambdabot> forall a b c d. [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
14:24:00 <aavogt> @type \(a, b, c, d) -> zip4 a b c d
14:24:01 <lambdabot> forall a b c d. ([a], [b], [c], [d]) -> [(a, b, c, d)]
14:24:26 <b_jonas> @hoogke zipWith4
14:24:26 <lambdabot> Data.List zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
14:24:43 <aavogt> rfh: there's no builtin library functions for such a thing
14:24:47 <EvanR-work> :t flip (maybe (return ()))
14:24:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> (a -> m ()) -> m ()
14:25:36 <EvanR-work> :t flip . maybe . return ()
14:25:36 <lambdabot> forall a (f :: * -> *). (Monad f, Functor f) => f (Maybe a -> (a -> ()) -> ())
14:25:42 <EvanR-work> ._.
14:25:55 <rfh> aavogt: mean uncurry . zipp4 (mnames,replicate 12 y,fstdays y,mlengths y) ?
14:26:08 <aavogt> rfh: no
14:26:09 <EvanR-work> :t flip . maybe . (return ())
14:26:10 <lambdabot> forall a (f :: * -> *). (Monad f, Functor f) => f (Maybe a -> (a -> ()) -> ())
14:26:28 <rfh> oh, without punctuation
14:26:51 <benmachine> EvanR-work: \x -> flip (maybe (return () x)) is not what you want
14:27:01 <aavogt> rfh: it's the same work to write     months y = zipp mnames (replicate 12 y) (fstdays y) (mlengths y)
14:27:08 <EvanR-work> :t flip maybe (return ())
14:27:09 <lambdabot> forall a. () -> Maybe a -> ()
14:27:10 <aavogt> or instead of zipp, zip4
14:27:18 <EvanR-work> why is everything type checking >_<
14:27:20 <EvanR-work> lol
14:27:52 <rfh> aavogt: hmm, right
14:28:03 <EvanR-work> ill just use parens
14:29:23 <rfh> aavogt: leave the error at line 89
14:31:32 <aavogt> rfh: I dunno what you're trying to do there with  dnames :: String being an argument to  above which wants a tuple
14:32:27 <rfh> aavogt: dnames is just the second stringline in the output (calender)
14:32:36 <rfh> as a headline
14:33:26 <rfh> beneath banner, for input year with current month
14:35:15 <aavogt> rfh: you need to convert the String  dnames to a Picture
14:35:29 <yitz> preflex seen edwardk
14:35:30 <preflex>  edwardk was last seen on #haskell 37 minutes and 19 seconds ago, saying: gotta run
14:36:10 <rfh> aavogt:yeah something like dnames = (1,21," Su Mo Tu We Th Fr Sa") might work
14:37:26 <aavogt> @docs Data.String
14:37:26 <lambdabot> Data.String not available
14:38:08 * benmachine wonders why base-4.2.0.2 docs still aren't built on hackage
14:38:18 <benmachine> http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Data-String.html
14:38:21 <benmachine> aavogt: ^
14:39:12 <aavogt> rfh: you can use string litterals for Picture using that module + a ghc extension (-XOverloadedString or similar)
14:39:52 <rfh> aavogt: how?
14:40:16 <aavogt> rfh: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/type-class-extensions.html#overloaded-strings
14:40:54 <aavogt> it's not really important though
14:41:27 <rfh> aavogt: got it compiled, but now i have  Non-exhaustive patterns in function zipp
14:42:19 <aavogt> rfh: what happens if two lists are the same length?
14:42:32 <rfh> http://pastebin.com/cPwWKYAm
14:42:44 <aavogt> if you compile with warnings (-Wall), ghc can tell you which cases you're missing
14:44:49 <rfh> aavogt: it irrelevant how long whatever list is, unless it is nonempty
14:45:16 <aavogt> rfh: your first 4 equation match if only one list is empty
14:45:23 <aavogt> if two are empty, they won't match
14:45:43 <rfh> aavogt: right, thats a pain in the ass
14:46:04 <aavogt> so instead of requiring a match like (y:ys), you can just write _
14:46:17 <rfh> dont want to write out 16 possibilities
14:46:21 <aavogt> (or just ys, or whatever lowercase you want)
14:47:09 <aavogt> rfh: you don't have to look at a constructor's values in a pattern match
14:47:16 <aavogt> @src zip
14:47:17 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
14:47:17 <lambdabot> zip _      _      = []
14:47:29 <aavogt> see, that's 2 equations for 2 lists
14:48:39 <rfh> zip has 3 eq
14:48:51 <rfh> zip _ xs
14:48:59 <rfh> zip x:xs _
14:49:06 <rfh> zip x:xs y:ys
14:49:31 <aavogt> well not the one in @src (which works)
14:50:04 <hpc> rfh: the first two of yours have to have the same definition
14:50:15 <hpc> what are you going to zip x with in the second one?
14:50:30 <benmachine> the first one matches everything in any case
14:50:46 <Saizan> yeah, i can't see how those clauses in that order would work
14:51:12 <rfh> hpc: sorry: zip [] xs = [], zip x:xs [] = []
14:51:26 <benmachine> rfh: you don't need to define it like that
14:52:25 <rfh> anyway: is their a more appreciable solution to zipp4 (zip on quadruples) without exhaustive patterns
14:53:15 <Saizan> just add 2 more lists to the definition of zip from @src
14:53:32 <Saizan> still using 2 equations
14:53:52 <hpc> zip4 (w:ws) (x:xs) (y:ys) (z:zs) = (w,x,u,z):zip4 ws xs ys zs
14:53:58 <hpc> zip4 _ _ _ _ = []
14:55:20 <rfh> thats nice
14:55:34 <rfh> and very clear
14:57:04 <BMeph> rfh: http://pastebin.com/LZXkHQfT
14:57:36 <BMeph> rfh: ...I was about to ask what your reasons were for not doing that...I guess I know now. ;)
14:57:39 <hpc> :t on
16:59:35 --- topic: '["Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
16:59:35 --- topic: set by dons!~dons@archlinux/developer/dons on [Thu Jul 22 16:55:46 2010]
16:59:42 <ezyang> Yeah. 
16:59:47 <ezyang> It's a little weaker: 
17:00:11 <ezyang> n is not leaked to the outside, but I can create derivative types Dup n, and (Dup (Dup n)), etc. 
17:01:00 <ezyang> The same way I can make a ST n () 
17:02:32 <Eduard_Munteanu> One way to do it is to require that any code that uses 'n' executs inside NoSmuggle, just like in runST.
17:02:54 <ezyang> Well, I don't know how to implement NoSmuggle :-) 
17:04:02 <Saizan> ezyang: but 'n' would still appear in the result type as part of the first argument to NT, no?
17:04:35 <Saizan> maybe you should give info on the bigger picture
17:04:42 <ezyang> Yeah, that's the idea, I think. 
17:04:43 <ezyang> Sure. 
17:05:15 <ezyang> So, I'm basically implementing a variant of the ST monad, but with the ability to copy the state and run another ST monad inside an ST monad. 
17:05:30 <monochrom> runMyMonad :: (forall n. MyMonad n a) -> a
17:05:44 <monochrom> oh let me think
17:05:49 <ezyang> The copy function is actually C FFI code, and doesn't preserve indexes quite correctly. 
17:06:07 <ezyang> Everything is still there, but I need to translate to lift it into the inner ST monad. 
17:06:18 <Saizan> sounds like oleg's nested regions would fit
17:06:24 <monochrom> interesting
17:06:41 <ezyang> Saizan: That sounds... quite plausible. Lessee... 
17:07:20 <Saizan> the example in the paper is about file handles though
17:07:28 <ezyang> (To conclude: if I branch inside the ST monad, I don't want to create a fresh index type; I want a derivative type which I can push from one to another) 
17:07:36 <ezyang> Saizan: Right, and moving them from one monad to another. 
17:08:13 <ezyang> I didn't understand the implementation of that part of the regions. 
17:08:16 <ezyang> Time to reread... 
17:08:49 <ezyang> Oh, something I thought of: extend Dup to have two type variables 
17:09:30 <ezyang> So, we'd have 
17:09:41 <ezyang> (forall n2. NQ (Dup n n2) a) -> NT n a 
17:10:09 <ezyang> This lets n leak out, but I guess that's ok. 
17:10:23 <ezyang> (I'm not sure why I discarded this solution earlier) 
17:11:23 <ezyang> But the double type index reminds me a lot of Oleg's regions. 
17:11:28 * BMeph renames the function to "unsafeAsInItTossesKittensAtOpenWindowsWhileIPerformIO"...
17:11:42 <Eduard_Munteanu> :)
17:12:12 <ezyang> And then I just write a function 
17:12:17 <ezyang> Node (Dup n n2) -> Node n 
17:12:28 <BMeph> Just trying to be sure folks know "in what sense" that function is "unsafe"... :D
17:12:59 <ezyang> BMeph: I'm drowning in spaghetti pools of unsafe code :^) 
17:14:56 <ezyang> In correct, I actually want to write a function Node (Dup n n2) -> NT n2 (Node n) 
17:15:02 <ezyang> I think this works. 
17:15:07 * ezyang goes off to code it up. 
17:16:00 <ezyang> nope, got it wrong. 
17:16:30 <ezyang> type programming is... so interesting. 
17:16:43 <copumpkin> yep!
17:19:34 <ezyang> Ok, so the function I actually want is Node n -> NT n2 (Node (Dup n n2)) 
17:19:45 <ezyang> And NT n2 needs to know how to perform the translation, which seems fine to me. 
17:20:40 <dpratt71> dependency conflict installing yesod: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28534#a28534
17:20:52 <dpratt71> can I resolve it?
17:23:14 * Saizan wonders why yesod ends up depending on ghc
17:24:31 <Saizan> however no, you need to install a newer ghc
17:24:54 <Cale> directory is one of the packages that comes with GHC
17:25:04 <dpratt71> Saizan: I think the problem may be that my GHC is too new
17:25:15 <Cale> I think I may know why it depends on GHC.
17:25:20 <dpratt71> (just installed 2010.2)
17:26:31 <Cale> Is Yesod the one that uses hint to do dynamic loading of code?
17:26:33 <Saizan> dpratt71: ghc --version ?
17:27:06 <dpratt71> Saizan: 6.10.4
17:27:23 <Saizan> that's "old", we're at 6.12.3 :)
17:27:40 <dpratt71> hmm
17:27:53 <dpratt71> haskell platform does not install/update ghc?
17:28:22 <Saizan> not the linux source package
17:28:37 <monochrom> haskell platform 2010.2 is tied to ghc 6.12.3
17:29:04 <dpratt71> hold up, I think I know what's going on
17:29:06 <monochrom> linux source package detects and refuses ghc 6.10. even 6.12.1,2
17:29:21 <Saizan> two ghcs then
17:30:01 <monochrom> well it's pretty robust. if it finds 6.12.3 at some path, it will use that absolute path to build
17:30:20 <EvanR> how do i 'reexport' something
17:30:21 <monochrom> oh, I see what you mean.
17:30:30 <EvanR> put it in the export list
17:30:33 <EvanR> gah
17:32:48 <dpratt71> news flash: I am an idiot
17:33:21 <dpratt71> I need to put an expiration date on stuff in my downloads folder, after which they self-destruct
17:34:07 <EvanR> crontab -e
17:34:52 <dpratt71> EvanR: think that'll work on Win7? ;-)
17:34:53 * monochrom volunteers his find $HOME/downloads -not -type d -mtime +10 -ctime +10 -print0 | xargs -0 -r rm -f
17:35:04 <EvanR> dpratt71: of course
17:35:08 <EvanR> oh.. nevermind
17:35:32 <EvanR> the hell are you doing on win7
17:35:52 <dpratt71> hey, somebody's gotta make sure Haskell still works on Windows :)
17:36:04 <EvanR> nah
17:36:06 <EvanR> two reasons
17:36:15 <EvanR> 1 who cares about windows
17:36:23 <EvanR> 2 in response to 1, avoid success at all costs
17:36:50 <fryguybob> -1 windows pays for SPJ?
17:36:57 * monochrom suggests this for win7: run virtualbox, run linux inside, access windows file system from inside, find whatever -not -type d -mtime +10 -ctime +10 -print0 | xargs -0 -r rm -f
17:37:31 <dpratt71> EvanR: logic problem: if nobody cares about windows, it is the platform of choice if you're trying to avoid success
17:37:39 <monochrom> hahahaha
17:38:19 <Phyx-> ...
17:38:31 * Phyx- throws clippy at you all
17:38:35 <Phyx-> SICK EM BOY!
17:38:42 <monochrom> what is clippy? clipper?
17:38:43 <EvanR> ._. !!!
17:39:33 <fryguybob> My TeX lion mascot scared off clippy a long time ago.
17:39:47 <Phyx-> lol, you guys seen this? http://www.youtube.com/watch?v=VUawhjxLS2I
17:39:48 <monochrom> haha
17:39:54 <Phyx-> explains what happened to clippy
17:39:56 <Phyx-> partially
17:40:16 <EvanR> ms did market research to determine everyone hated him?
17:40:38 <Phyx-> no... some terrorist group killed him
17:41:06 <EvanR> thats what i said
17:41:08 <Phyx-> watch the link, lol
17:41:16 <EvanR> ms killed him ;)
17:41:34 <ezyang> Oh man, it compiles! 
17:41:34 * dpratt71 was momentarily vexed when he saw "downloading failure..." scroll by
17:42:42 <Phyx-> "double click that!"
17:43:53 <dpratt71> well, now that I have a non-ancient version of GHC, Yesod installs fine
17:44:53 <eugenn> @quote clip
17:44:53 <lambdabot> debio264: says: is the Eclipse plugin for Scala like... not nearly finished?
17:47:29 <Phyx-> 02:35:45 < EvanR> 1 who cares about windows
17:47:32 <Phyx-> <-- well i do...
17:48:26 <dpratt71> does cabal keep the source around when it installs a package?
17:49:24 <QtPlatypus> Can people think of a good synomin for "map"?
17:50:20 <monochrom> atlas
17:50:53 <dpratt71> chart
17:50:54 <monochrom> cabal keeps the tarball around
17:50:57 <Phyx-> dpratt71: I think so
17:51:07 <QtPlatypus> monochrom: In the sence of (a->b) -> f a -> f b
17:51:08 <Phyx-> i've never seen it redownload the same version
17:51:22 <Phyx-> and unpack is usually instant after a install
17:51:38 <Phyx-> navigation_thingy
17:51:44 <monochrom> .cabal/packages/hackage.haskell.org
17:51:56 <dpratt71> Phyx-: thanks; you know where it puts stuff on Windows?
17:52:05 <monochrom> fmap
17:52:06 <Phyx-> *looks*
17:52:19 <hpc> monochrom: haha, that was my answer
17:52:44 <QtPlatypus> monochrom: Yes.  Anouther word that means that but isn't map/fmap
17:52:51 <monochrom> perhaps people reject answers they don't like, for no reason
17:53:03 <Phyx-> dpratt71: %AppData%\cabal\packages\hackage.haskell.org
17:53:11 <monochrom> mapf
17:53:23 <dolio> collect
17:53:24 <benmachine> liftA/liftM are basically fmap
17:53:31 <hpc> :t liftM
17:53:32 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:53:34 <monochrom> liftF
17:53:39 <hpc> @src liftA
17:53:39 <lambdabot> liftA f a = pure f <*> a
17:53:48 <dpratt71> Phyx-: ah! thanks again
17:53:49 <dolio> collect is what it's called in Smalltalk and Ruby, if I recall correctly.
17:53:57 <monochrom> haskell is uplifting
17:54:30 <Pseudonym> Where Fortran is upwinding.
17:55:44 <dpratt71> LINQ calls map 'select'
17:56:03 <tensorpudding> what exactly does it have to do with selecting or collecting?
17:56:20 <benmachine> about as much as it has to do with cartography?
17:56:20 <monochrom> well that's what you get for "meaningful identifiers"
17:56:29 <tensorpudding> Ruby calls it's fold inject
17:56:30 <dpratt71> tensorpudding: well, it's a projection, isn't it?
17:56:38 <Pseudonym> I don't know anything about LINQ.  Is "map" _all_ it does?
17:56:40 <tensorpudding> err, its*
17:56:41 <Phyx-> dpratt71: annoyingly yeah it does :/
17:56:48 <Phyx-> and concatMap is selectMany isn't it?
17:56:49 <dolio> Yes, Smalltalk and Ruby have nice rhyming names.
17:56:59 <dolio> map = collect, filter = select, foldl = inject.
17:57:12 <Pseudonym> There was a young man from Ruby / Who liked to program in Smalltalk
17:57:13 <dpratt71> Pseudonym: LINQ takes quite a bit of inspiration from Haskell, actually
17:57:20 <Pseudonym> Yes, I knew that.
17:57:21 <Phyx-> filter = where in LINQ
17:57:42 <Pseudonym> But I'm curious to know if "select" _is_ "map", or if it does more.
17:57:44 <tensorpudding> I like reduce for fold
17:58:04 <tensorpudding> since it seems to describe the process better than folding
17:58:30 <dpratt71> LINQ select is pretty close (in semantics) to map
17:58:32 <aavogt> tensorpudding: the result can be bigger after a fold
17:58:44 <tensorpudding> bigger in what sense?
17:58:48 <tensorpudding> the structure is reduced
17:58:50 <monochrom> well that's what you get for "meaningful identifiers". everyone disagrees on what the meaning is. they only agree the word is meaningful.
17:58:57 <Phyx-> Pseudonym: it's just map, but it's defined on the IEnumerable interface, so if you have a List after selection you have an IEnumerable which you can then convert back to a list
17:59:00 <dolio> > foldr (\e r -> e:e:r) [] [1..3]
17:59:01 <lambdabot>   [1,1,2,2,3,3]
17:59:24 <EvanR> LINQ is cool right, thats good for haskell, right?
17:59:49 <tensorpudding> It's not good for Haskell
17:59:53 <dpratt71> EvanR: FWIW, LINQ is what got me interested in Haskell
18:00:08 <Phyx-> for me it's the opposite
18:00:16 <Phyx-> LINQ and lambdas got me interested in C# again
18:00:36 <rgrinberg> it's the Smalltalk to Java effect
18:00:38 <tensorpudding> LINQ being good implies more people will be inclined to skip Haskell
18:00:39 <Phyx-> I always prefered it over Java, but now I can throw lambdas around in their smug faces :P
18:00:47 <kmc> lambdas? wow, the future is now
18:01:01 <monochrom> skipping haskell is good
18:01:07 <Phyx-> Java feels seriously outdated :/
18:01:07 <tensorpudding> I wish there were decent free ebooks talking about C# that weren't were more mono-friendly
18:01:15 <dolio> Does that work? I thought Java people were against lambdas, because they're too hard for the average coder.
18:01:16 <tensorpudding> err, that were*
18:01:32 <kmc> dolio, and by "average coder" you mean "lowest-common denominator"
18:01:46 <dolio> kmc: Probably.
18:01:49 <dpratt71> lambdas coming to Java, too
18:01:50 <Phyx-> dolio: afaik, Java has no lambdas, which is one of the things I miss in it
18:01:53 <EvanR> lets call them anonymous methods then
18:02:02 <tensorpudding> I may be using CLR but dammit I don't want to read MSDN
18:02:14 <Phyx-> dpratt71: *eventually* java 7 has been "coming" for years now
18:02:23 <dolio> Phyx-: It doesn't. But there's a feature proposal somewhere. And I recall it being argued against vigorously when it first appeared.
18:02:40 <rgrinberg> Phyx-: maybe they are ditching the language and pumping resources into the vm
18:02:59 <Phyx-> dolio: the other major thing I love about C# is access to *real* pointers
18:03:08 <dpratt71> Phyx-: either way, it doesn't seem as well integrated as it is in C# (based on precious little exposure)
18:03:24 <Phyx-> rgrinberg: that seems like a bad way to go imho. fix your language, then your VM
18:03:35 <kmc> i don't think the average programmer is too dumb to use FP.  i think the average programmer is perhaps not curious enough to learn about FP when everyone ignores it or tells them it's useless
18:03:38 <dolio> I guess that could be handy, although I don't do pointer-level stuff much.
18:03:53 <kmc> but from the number of people who wander in here, a fair number *are* curious enough
18:04:13 <EvanR> the popularity is only going up
18:04:19 <EvanR> we gotta do something about it
18:04:22 <dpratt71> kmc: I think I agree
18:04:36 <kmc> better rename all the standard library functions to greek
18:04:50 <Phyx-> I think, It's like kmc said, The average programmer isn't too stupid for it, but they don't see the point of it
18:04:51 <dpratt71> I insist that basic FP is not fundamentally hard, just different
18:05:08 <kmc> dpratt71, I think Haskell is fundamentally pretty hard, though
18:05:11 <Phyx-> being that "apps" and "facebook apps" are the lowest common denominators these days
18:05:18 <kmc> it has a lot of stuff beyond core FP
18:05:29 <Phyx-> kmc: only if you've first learned an imperative approach
18:05:34 <kmc> no i don't agree
18:05:36 <EvanR> are algebraic data types hard?
18:05:45 <kmc> i think there's a component of that, but also some intrinsic difficulty
18:06:02 <EvanR> you can do a lot with basic functional haskell and data
18:06:03 <Cale> I'm not sure I'd say that Haskell is hard. It has a long learning curve, and the steepness of that curve sometimes is dependent on what you already are familiar with.
18:06:07 <kmc> Haskell makes you think in a more structured rigorous way; that'll never be as easy as copy-pasting PHP snippits together until it sort of works
18:06:10 <EvanR> no transformers...
18:06:17 <Phyx-> Speaking for myself, The only barrier I had when learning Haskell was to switch off my imperative brain
18:06:36 <kmc> and then switch it back on in a more principled setting
18:06:54 <benmachine> haskell is just pretty big
18:06:58 <benmachine> there always seems to be more to learn
18:06:59 <Phyx-> exactly. learning FP has greatly changed how I code, even in Imperative languages
18:07:00 <dpratt71> I think the problem is largely cultural: you Haskell-hackers regularly discuss problems of a nature that scares us mere mortals back to terra firma
18:07:04 <Cale> There's a really steep part at the beginning for imperative programmers, but it levels off eventually and you have a big plateau of lots and lots of stuff which can be learned easily.
18:07:13 <kmc> Phyx-, i meant that Haskell is an imperative language too
18:08:01 <Phyx-> kmc: Well, I've never really agreed with that. But I wouldn't know a better way to phrase it
18:08:10 <ezyang> dpratt71: "If it's not hard, it's not worth researching" :-) 
18:08:35 <jrockway> so i am writing an FFI binding to a C++ library (via a C API i wrote for it)
18:08:39 <kmc> if you like, Haskell is a functional language, the IO monad is an imperative language
18:08:57 <kmc> a lot of people come here wanting to write a program in a straightforward but ill-typed way, and we have to help them figure out how to explain the well-typedness to the checker
18:08:58 <jrockway> is it worth refactoring my C++ code so that I can use mallocForeignPtr instead of using C++'s new/free?
18:09:17 <kmc> i think this is intrinsically hard; it's a design skill somewhat like proving theorems
18:09:27 <ezyang> jrockway: You don't need to refactor too much. 
18:09:37 <ezyang> Just export a C function that can be used to free things. 
18:09:57 <Phyx-> kmc: When I was first thought Haskell, they told us to always write down typesignatures for top level functions. And they were right, it helps alot with learning
18:10:01 <Phyx-> I still do it actually
18:10:09 <Phyx-> I very rarely let GHC infer a type for me
18:10:31 <dolio> People come here asking how to make heterogeneous lists, and they almost always get explanations about existential types, which is kind of hard for accomplishing that.
18:10:33 <kmc> yeah, sigs on top-level bindings is considered good style
18:10:51 <ezyang> Makes it hard to use implicit parameters though :-) 
18:11:00 <kmc> often people who want heterogenous lists just want a list of some sum type
18:11:00 <Phyx-> eww
18:11:02 <dolio> But the truth is that they probably don't need heterogeneous lists in the first place. I've never needed to do that myself.
18:11:12 <jrockway> ezyang: that's what i do now, attach a finalizer to my foreignptr
18:11:30 <Phyx-> dolio: well, they asked the wrong question then :P
18:11:31 <jrockway> but the docs suggest that using ghc's malloc will be faster than using whatever my C++ library uses
18:11:32 <ezyang> Then export another function for allocating things. 
18:11:48 <jrockway> so if i can make a block of RAM, and then mutate it from C, that will require a bit of effort on my part
18:11:52 <jrockway> but if it's faster, i don't care
18:11:53 <ezyang> jrockway: If the C library has the potential to free your memory, it needs to allocate it. 
18:11:59 <kmc> existentials are useful for /open/ sums, and perhaps people come from an OO world where all sums are open (hmm, does Java have "final" on classes?)
18:12:10 <Phyx-> jrockway: hm, that's interested, thanks, Now I'll skip trying to find the slowdown in my code in the mallocs ^_^
18:12:11 <monochrom> yeah I tell them don't use heterogeneous list, don't need "open extensible type" until proven otherwise, just write data Whee = A|B|C.
18:12:12 <ezyang> This will make you a lot happier when you try to port your software to Windows. 
18:12:26 <dolio> Yes, there are final classes, as I recall.
18:12:29 <dolio> String is one, I think.
18:12:42 <ezyang> monochrom: It's really a matter of figuring out what they're actually trying to ask :-) 
18:13:44 <jrockway> here is what the docs say: "GHC notes: mallocForeignPtr has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the ForeignPtr does not require a finalizer to free the memory. Use of mallocForeignPtr and associated functions is strongly recommended in preference to newForeignPtr with a finalizer."
18:13:59 <jrockway> i guess what i'm asking, how far out of my way should i go to follow that advice?
18:14:21 <jrockway> (i haven't tested the two implementations yet, just wondering if it's worth persuing before i do any work)
18:14:31 <jrockway> honestly, this library leaks memory like a sieve
18:14:36 <kmc> jrockway, your alternative to mallocForeignPtr is C++ new/free?
18:14:40 <kmc> then this advice is not relevant
18:14:40 <jrockway> yeah
18:14:47 <jrockway> ok, but i can make it relevant
18:14:50 <jrockway> my C api looks like
18:15:10 <jrockway> Foo *new_foo(int bar, char *whatever) { new Foo( ... ) }
18:15:24 <kmc> it's saying why you should use mallocForeignPtr in preference to malloc + newForeignPtr
18:15:25 <ezyang> jrockway: If your C API is allocating stuff for you, you cannot use mallocForeignPtr. End of story. 
18:15:29 <jrockway> i would be perfectly happy to change that to 'void init_object(Foo *)' and let Haskell manage my memory
18:15:41 <kmc> won't it be most efficient if C manages the memory?
18:15:42 <jrockway> the C code is mine, so I am free to do whatever's better
18:15:46 <jrockway> i don't know
18:15:47 <kmc> the Haskell GC won't even touch it
18:15:55 <kmc> i think that's best, if it's already compatible with your design
18:15:57 <monochrom> I don't matter anyway. There are more than enough people here to jump the gun and suggest the big guns.
18:16:17 <kmc> monochrom, i like your advice, and i usually try to propose something along those lines
18:16:38 <benmachine> monochrom: keep the faith, they'll learn some day
18:16:40 <kmc> often it's an XY problem
18:16:50 <jrockway> i guess the advice is, test both, see which is faster :)
18:16:52 <jrockway> and that's fair
18:17:04 <jrockway> i personally don't trust C++ to do anything right
18:17:08 <jrockway> other than dying in a big ball of fire
18:17:12 <jrockway> it is good at that :)
18:17:17 <kmc> not good enough
18:17:30 <kmc> i.e., incorrect programs run for a while rather than segfaulting immediately
18:17:46 <kmc> like returning a pointer to a stack variable!
18:17:50 <kmc> usually works for a while
18:17:59 <jrockway> yeah
18:18:16 <jrockway> i am well aware of the fun memory management mistakes i can make in C++ and C, and how to ensure that i don't do that stuff
18:18:30 <jrockway> (not that i like it, or would ever use c or c++ for anything important, but i do understand how it all works :)
18:18:38 <kmc> just don't get into a position where it's your job to debug C or C++ code written by non-programmers who don't know either language
18:18:51 <pikhq> kmc: s/C or C++//
18:18:53 <jrockway> i am in that position
18:18:58 <kmc> jrockway, :(
18:19:00 <jrockway> fortunately, i have a good understanding of how the app works
18:19:07 <jrockway> and i am rewriting the whole thing in haskell
18:19:12 <kmc> cool :)
18:19:15 <jrockway> all the hard stuff is in this internal library
18:19:20 <jrockway> it's C++, but it's reasonably OK C++
18:19:25 <kmc> anyway if you let C / C++ manage the memory, you can make a ForeignPtr which calls your routine for deallocation
18:19:27 <EvanR> is that even possible
18:19:28 <kmc> or you can make that explicit
18:19:53 <pikhq> EvanR: Certain subsets of C++ are "OK". Sadly, we can't standardise on that subset.
18:20:15 <jrockway> yeah, that's how i am doing it now
18:20:18 <jrockway> seems to work fine
18:20:31 <aavogt> ghc haskell is probably a similar situation
18:21:22 <kmc> GHC's extensions are a lot more orthogonal than the grab bag of features included in C++ proper
18:21:34 <kmc> it's really a funny name, "C++".  should be more like "C *= 1000"
18:21:45 <aavogt> you could still end up in an awkward situation
18:21:51 <aavogt> look at ghc's coding guidelines
18:22:11 <kmc> a huge unwieldy language with a tiny barely recognizable core of the simplicity of C
18:22:11 <monochrom> since C is negative, C *= 1000 would not increase it. :)
18:22:36 <pikhq> And C++ only modifies the value of C while returning the old value, anyways. :P
18:22:57 <jrockway> but hey, at least the C++ folks came up with a better name!
18:23:00 <jrockway> C++0x
18:23:05 <hpc> pikhq: oh the irony!
18:23:12 <eugenn> > let Applicative a x in f x 4+7
18:23:13 <lambdabot>   <no location info>: parse error on input `in'
18:23:32 <jrockway> ?
18:24:20 <jrockway> so actually, i have another ffi style-related question while i'm here
18:24:28 <jrockway> the library i'm wrapping implements its own everything types
18:24:32 <jrockway> hashes, arrays, etc.
18:25:14 <jrockway> should i keep my haskell data type something like data Foo = Foo (ForeignPtr RawFoo) and add functions like "toList :: Foo -> [whatever]"
18:25:26 <jrockway> or should i try to expose as much of this information as possible to Haskell
18:25:51 <jrockway> like data Foo = Hash { hashData :: [(k,v)], foreignPtr :: ForeignPtr RawFoo }
18:26:18 <eugenn> @quote expose
18:26:19 <lambdabot> No quotes match. My mind is going. I can feel it.
18:27:26 <kmc> jrockway, it really depends.  a common technique is two modules / libraries, one providing a direct raw interface and one providing a more Haskelly interface on top of that
18:27:41 <kmc> in your second example, is the idea of hashData to cache stuff from the C side?
18:27:51 <eugenn> @type mapm
18:27:52 <lambdabot> Not in scope: `mapm'
18:28:00 <Phyx-> @type mapM
18:28:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:28:06 <Phyx-> did you mean that one?
18:28:09 <jrockway> kmc: yeah
18:28:33 <jrockway> i feel like the use case will be 60% acting on the data in pure haskell, and 40% calling C++ functions on the structures
18:28:56 <eugenn> yup
18:29:02 * Eduard_Munteanu wonders if anybody tried using GHC's RTS for managing Linux kernel slabs.
18:29:02 <hpc> > mapM (>>=) [1,2,3]
18:29:03 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> m b) -> [m b])
18:29:03 <lambdabot>    arising fr...
18:29:25 <Eduard_Munteanu> At least for stuff usable in preemptible contexts.
18:29:49 <benmachine> :t mapM (>>=)
18:29:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => [m a] -> (a -> m b) -> [m b]
18:30:05 <benmachine> interesting.
18:30:11 <hpc> that's handy
18:30:14 <Eduard_Munteanu> There was something on LWN on how to make a Haskell kernel module, so I figure some people must've played with this.
18:31:08 <eugenn> :t return
18:31:09 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:31:55 <eugenn> > return 4
18:31:56 <lambdabot>   No instance for (GHC.Show.Show (m t))
18:31:56 <lambdabot>    arising from a use of `M8334305846...
18:32:41 <hpc> > (return 4) `asTypeOf` Nothing
18:32:42 <lambdabot>   Just 4
18:33:27 <hpc> :t (>>=)
18:33:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:33:39 <eugenn> > (return 4) `asTypeOf` Maybe
18:33:40 <lambdabot>   Not in scope: data constructor `Maybe'
18:34:41 <azaq231> @type liftM ($)
18:34:42 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m (a -> b)
18:34:53 <eugenn> :t sort
18:34:54 <lambdabot> forall a. (Ord a) => [a] -> [a]
18:35:38 <eugenn> :t Maybe
18:35:39 <lambdabot> Not in scope: data constructor `Maybe'
18:36:00 <eugenn> @source Maybe
18:36:00 <lambdabot> Maybe not available
18:36:19 <hpc> :t Just 4
18:36:19 <lambdabot> forall t. (Num t) => Maybe t
18:36:21 <hpc> :t Nothing
18:36:22 <lambdabot> forall a. Maybe a
18:36:28 <eugenn> @source m m
18:36:28 <lambdabot> m m not available
18:37:07 <eugenn> @source Nope, that's
18:37:08 <lambdabot> Nope, that's not available
18:37:17 <Phyx-> ?t asTypeOf
18:37:17 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:37:28 <hpc> :t asTypeOf
18:37:28 <Phyx-> ?type asTypeOf
18:37:29 <lambdabot> forall a. a -> a -> a
18:37:29 <lambdabot> forall a. a -> a -> a
18:37:33 <hpc> @src asTypeOf
18:37:33 <lambdabot> asTypeOf = const
18:37:37 <Phyx-> that seems useless
18:37:45 <kmc> asTypeOf?
18:37:52 <kmc> not useless
18:37:56 <hpc> it's a less ugly form of (:: blah)
18:38:04 <Phyx-> yeah, I'm sure it's not, I just can't think og why you'd need it :P
18:38:07 <kmc> it allows you to get around lack of -XScopedTypeVariables
18:38:32 <Phyx-> hm?
18:38:46 <eugenn> @source liftM
18:38:46 <lambdabot> liftM not available
18:38:55 <hpc> it makes type specification first-class
18:39:47 <Phyx-> what would it's two arguments be, 1 the expression and the other something with the type you want?
18:39:49 <eugenn> > Arrow a, Monad m, God g
18:39:49 <lambdabot>   <no location info>: parse error on input `,'
18:39:52 <hpc> yes
18:39:56 <kmc> say i want to expose a function like (read . show)
18:39:59 <Phyx-> > 1 `asTypeOf` (undefined :: Int)
18:40:00 <lambdabot>   1
18:40:01 <EvanR> God class
18:40:11 <hpc> it's useful in the same way ($) is
18:40:13 <kmc> that is, it has an intermediate result with an indeterminate type, i want to let the user specify
18:40:17 <kmc> but it's not in the arg or result type
18:41:13 <wli> worldhlord: Emulator and archival media of the stuff.
18:41:27 <azaq231> liftM act x = do { f <- act; return $ f x }
18:41:35 <kmc> let f :: forall a. (Show a, Read a) => a -> String -> String; f = show . (read :: String -> a)
18:41:53 <kmc> this uses -XScopedTypeVariables to have the "a" from f's sig bound within the annotation on "read"
18:42:00 <Phyx-> right
18:42:04 <Phyx-> with you so far
18:42:06 <hpc> @undo do { f <- act; return $ f x }
18:42:06 <lambdabot> act >>= \ f -> return $ f x
18:42:07 <kmc> but we can rewrite it with asTypeOf and avoid this extension
18:42:35 <Phyx-> right i see
18:42:37 <hpc> @pl do { f <- act; return $ f x }
18:42:38 <lambdabot> (line 1, column 4):
18:42:38 <lambdabot> unexpected "{"
18:42:38 <lambdabot> expecting variable, "(", operator or end of input
18:42:43 <Phyx-> you pass the argument along to asTypeOf
18:42:43 <kmc> (err «f _ = ...» above)
18:42:45 <hpc> @undo do { f <- act; return $ f x }
18:42:45 <lambdabot> act >>= \ f -> return $ f x
18:42:53 <hpc> @pl \ f -> return $ f x
18:42:53 <lambdabot> return . ($ x)
18:42:54 <kmc> let f :: (Show a, Read a) => a -> String -> String; f p x = show (read x `asTypeOf` p)
18:42:54 <Phyx-> then you no longer need Scoped vars
18:42:54 <kmc> yeah
18:44:00 <eugenn> @gimme list of types
18:44:14 <kmc> > [] :: [TypeRep]
18:44:15 <lambdabot>   []
18:44:16 <kmc> ;P
18:45:14 <kmc> > map dynTypeRep [toDyn (), toDyn True, toDyn 3.0]
18:45:14 <lambdabot>   [(),Bool,Double]
18:45:48 <eugenn> > dynTypeRep 5
18:45:49 <lambdabot>   No instance for (GHC.Num.Num Data.Dynamic.Dynamic)
18:45:49 <lambdabot>    arising from the lite...
18:46:11 <eugenn> > dynTypeRep (toDyn 5)
18:46:12 <lambdabot>   Integer
18:46:39 <hpc> :t toDyn
18:46:41 <lambdabot> forall a. (Typeable a) => a -> Dynamic
18:46:45 <eugenn> > dynTypeRep (toDyn map)
18:46:46 <hpc> > toDyn 5
18:46:46 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:46:46 <lambdabot>    `Data.Typeable.Typeable a...
18:46:47 <lambdabot>   <<Integer>>
18:47:06 <Cale> > [typeOf (), typeOf True, typeOf 3.0]
18:47:07 <lambdabot>   [(),Bool,Double]
18:47:26 <eugenn> > typeOf filter
18:47:27 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:47:27 <lambdabot>    `Data.Typeable.Typeable a...
18:47:46 <Cale> > typeOf (filter :: (Integer -> Bool) -> [Integer] -> [Integer])
18:47:47 <lambdabot>   (Integer -> Bool) -> [Integer] -> [Integer]
18:47:47 <eugenn> :t (::)
18:47:48 <lambdabot> parse error on input `::'
18:48:10 <Cale> typeOf only works on monomorphically typed things
18:48:25 <Cale> The reason it works on numeric constants is because of numeric defaulting.
18:48:39 <hpc> yay, compiler quirks
18:48:42 <Cale> (same with toDyn)
18:49:11 <Phyx-> :t toDyn
18:49:12 <lambdabot> forall a. (Typeable a) => a -> Dynamic
18:49:13 <kmc> :: is syntax; it doesn't have a type
18:49:16 <Cale> Well, Typeable aside, numeric defaulting is part of the standard.
18:49:24 <Phyx-> @hoogle Dynamic --info
18:49:24 <lambdabot> module Data.Dynamic
18:49:24 <lambdabot>  
18:49:24 <lambdabot> The Dynamic interface provides basic support for dynamic types.
18:49:52 <Phyx-> so that basically screws type safety
18:49:58 <kmc> no
18:50:01 <kmc> only static type safety
18:50:02 <Cale> and the reason that toDyn, typeOf, etc. need monomorphically typed values is that they use the Typeable typeclass.
18:50:18 <Cale> Well, you still get a measure of static typesafety.
18:50:26 <Cale> :t fromDyn
18:50:27 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
18:50:29 <monochrom> if you don't fool Typeable, Dynamic is type-safe
18:50:30 <Cale> :t fromDynamic
18:50:31 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
18:50:36 <Phyx-> kmc: right, since it uses Typeable I suppose cast would fail at runtime
18:50:41 <Cale> :t cast
18:50:42 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
18:50:53 <Cale> ^^ when you cast back, you get a Maybe result
18:50:58 <Cale> and handle that normally
18:51:12 <eugenn> what's an Arrow? xD
18:51:22 <Cale> eugenn: Do you know what monads are about?
18:51:34 <eugenn> a little bit
18:51:35 <Cale> eugenn: It's just yet another way to structure a combinator library.
18:51:40 <monochrom> Arrow is a type class. Useful methods. Useful examples.
18:51:47 <eugenn> oh
18:51:54 <Cale> So, monads give you one sort of common shape that libraries might fit into, Arrow is another.
18:52:41 <Cale> (I'm assuming that you're talking about Control.Arrow)
18:52:41 <eugenn> is Functor another one of those?
18:53:01 <Cale> Yeah, Functor is more general than Monad, and is extremely simple.
18:53:03 <hpc> yes
18:53:13 <Cale> The only method of the Functor typeclass is fmap
18:53:21 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
18:54:18 <Cale> It's intended to be a generalisation of map for lists. So you have some way of turning plain functions of any type into functions between your f-structures, whatever those might be.
18:54:44 <Cale> Essentially always by applying the function to all the elements of some datastructure, or the results of a computation.
18:54:58 <kmc> "Mappable" would be a reasonable synonym for "Functor"
18:55:15 <kmc> and we can argue endlessly about whether we should or shouldn't favor the mathy words over the OO enterprisey words
18:55:37 <monochrom> s/Monad/Bindable/
18:55:37 <kmc> speaking of... is there any news about class context synonyms getting into GHC?
18:55:43 <wlangstroth> eugenn: typeclassopedia is really handy for a full explanation of that stuff
18:55:48 <monochrom> s/Arrow/Chainable/
18:55:54 <Cale> monochrom: haha
18:56:04 <monochrom> oh Applicative is the easy one. s/Applicative/Appable/
18:56:08 <kmc> i think it's harder to come up with a synonym for Monad which doesn't encourage false intuition.  the nice thing about the crazy weird name is that people *know* they don't know what it is immediately
18:56:09 <eugenn> thanks, i'll check that out!
18:56:14 <Cale> Actually, I think the Arrow typeclass has the wrong axioms, and that Arrow should not generalise Monad now.
18:56:20 <hpc> class synonyms would be nice
18:56:23 <hpc> :t (=~)
18:56:25 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
18:56:48 <kmc> eugenn, a lot of people see Arrow as the next step to learn after Monad; however, Monad is ubiquitous in real code while Arrow is not used very much
18:56:58 <monochrom> And lastly, we need a superclass of all of the above, called "Fishable"
18:57:04 <wlangstroth> haha
18:57:16 <Cale> :t (<=<)
18:57:17 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
18:57:33 <kmc> monochrom, for Pointed?
18:57:34 <monochrom> class Fishable f where "the operators look like fish"
18:57:38 <kmc> hehe
18:57:40 <eugenn> in CT there's something else called natural transformations. does haskell go that far?
18:57:52 <kmc> eugenn, http://hackage.haskell.org/package/category-extras
18:57:56 <Cale> eugenn: Polymorphic functions are natural transformations.
18:57:57 <aavogt> @quote unnatural
18:57:57 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
18:58:05 <kmc> eugenn, http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Yoneda.html the yoneda lemma in Haskell
18:58:24 <eugenn> whoah
18:58:32 <Cale> If you have functors f and g, and you have a polymorphic function f a -> g a, that will automatically be a natural transformation f -> g
18:58:55 <kmc> and Yoneda says how to build a functor out of that, right?
18:59:17 <jmcarthur> i don't think arrow should exist
18:59:20 <Cale> Now, it's a good question whether that gets all the natural transformations or not. With all the type system extensions, I have no idea.
18:59:45 <jmcarthur> if you split it up and generalize the pieces you end up with a generalized functor and some bifunctor stuff
18:59:46 <hpc> actually, yeah, what instances of arrow are there besides (->)?
19:00:03 <kmc> Cale, what do the axioms about natural transformations look like in this context?
19:00:41 <jmcarthur> hpc: an experiment i toyed with along the lines of splitting up Arrow: http://patch-tag.com/r/jmcarthur/alt-stdlib/snapshot/current/content/pretty/Control/Arrow.hs
19:01:02 <jmcarthur> not many instances, and also probably could be taken farther
19:01:09 <jmcarthur> but i think it's a good direction
19:01:17 <jmcarthur> been meaning to make that its own library
19:01:50 <hpc> :t \f -> fmap f id
19:01:51 <lambdabot> forall a b. (a -> b) -> a -> b
19:01:57 <aavogt> does somebody have a permutations for HLists?
19:02:18 <Cale> kmc: That application of that function commutes with fmap of any function.
19:02:30 <eugenn> I heard monads could in theory be implemented in ActionScript xD
19:02:30 <Cale> kmc: That is  eta . fmap f = fmap f . eta
19:02:55 <Cale> kmc: Haskell notation obliterates the names of the functors and objects :)
19:03:12 <hpc> eugenn: monads can be implemented in any language
19:03:17 <wlangstroth> eugenn: it's probably best that it's only implemented in theory
19:03:42 <hpc> all languages i have seen try end up doing monads wrong though
19:03:44 <Cale> eugenn: The trouble is that most non-Haskell languages don't have features necessary to make monads actually convenient to use.
19:04:01 <p_l> nor do they actually need them
19:04:02 <kmc> eugenn, each *individual* monad can be implemented in most languages.  but when we talk about "monads" in Haskell, the significant thing is that they're all part of this type class named Monad and so we have some common syntax and functions for them
19:04:05 <Cale> (and actually implement the abstraction properly, and not in some stupid useless way)
19:04:13 <wlangstroth> eugenn: (apart from the fact that you were obviously making a joke)
19:04:24 <eugenn> hehe
19:04:29 <Cale> The important thing is that we can write a library of functions which will automatically work in *any* monad.
19:04:38 <Cale> The tricky part is return, actually
19:04:40 <Cale> :t return
19:04:41 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:04:49 <kmc> yes, you can implement Maybe in Javascript, and lists, and Parsec... but it's less convenient to write functions that work with all of it
19:04:57 <Cale> As you can see from its type, return is polymorphic in its *result* type.
19:05:10 <Cale> Most OO languages don't have support for that kind of polymorphism
19:05:22 <zeiris> :t (>>)
19:05:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:05:40 <kmc> most OO languages have lists, and exceptions, and threading, and parsers, etc., but they have different built-in special-case syntax for each
19:05:41 <Cale> (as they handle polymorphism by packaging methods along with data, so you can only decide what to do based on the parameters, not the result of your function)
19:06:01 <zeiris> Does the type signature of (>>) imply no state is passed from the (m a) computation to the (m b) computation, -except- monad-specific state?
19:06:20 <hpc> zeiris: the a is not passed, but the m is
19:06:23 <Gracenotes> @src (>>)
19:06:23 <lambdabot> m >> k      = m >>= \_ -> k
19:06:34 <Cale> zeiris: x >> y is equivalent to x >>= const y
19:06:44 <zeiris> (And does that imply you can write a monad with a >> implementation, which automatically breaks computations into independant components. (In the case of something like a parser where structure depends on past parsed values.)
19:06:44 <Cale> So, the result of x is discarded
19:07:01 <Cale> But yeah, in a state monad, for example, the state will be preserved
19:07:12 <Gracenotes> >> should only be overridden when it can be made more efficient than (x >>= const y)
19:07:17 <wlangstroth> Cale: one would hope!
19:07:21 <Cale> > [1,2] >> "abc"
19:07:22 <lambdabot>   "abcabc"
19:07:37 <hpc> > "yes" >> "no"
19:07:37 <lambdabot>   "nonono"
19:08:23 <Cale> In the list monad, you can see that we select one element from the first list in all possible ways, but ignore what it is, before choosing an element of the second list.
19:08:42 <Cale> and so we get one occurrence of each element in the second list for each element of the first
19:08:55 <eugenn> seems like >> repeats the second argument a number of times equal to the number of elements in the first argument list
19:09:00 <Cale> yeah
19:09:05 <Cale> > [1,2,3] >> [4,5]
19:09:06 <lambdabot>   [4,5,4,5,4,5]
19:09:10 <Cale> > [] >> [4,5]
19:09:11 <lambdabot>   []
19:09:18 <zeiris> The monad internal state is passed along - but does (>>)'s type signature imply that -no- other state is passed along... Or am I misunderstanding the do-notation desugaring rules?
19:09:19 <Cale> This is actually useful:
19:09:33 <augur> hmm.
19:09:47 <augur> combinator parsing. elegant, but top-down problems
19:09:48 <Cale> > [1..10] >>= \v -> if even v then [] else [v, 10*v]
19:09:49 <lambdabot>   [1,10,3,30,5,50,7,70,9,90]
19:09:53 <augur> also, how the hell would you do precedence
19:10:11 <augur> i shall be opting for a chart parser :T
19:10:20 <eugenn> :t if
19:10:21 <lambdabot> parse error (possibly incorrect indentation)
19:10:26 <Cale> augur: You should look at chainl
19:10:31 <kmc> > [1,2,3] >>= const [4,5]
19:10:32 <lambdabot>   [4,5,4,5,4,5]
19:10:39 <augur> Cale: oh?
19:10:53 <Cale> augur: which is useful in most of the cases where you have a problem with top-down parsing.
19:11:01 <Cale> (left recursion)
19:11:04 <Gracenotes> zeiris: the only thing that is ignored is the result of the previous computation, which is of type 'a' for 'm a'
19:11:23 <kmc> zeiris, monads aren't about state, in general
19:11:31 <kmc> the internal representation of a monadic value can be anything
19:11:43 <kmc> all you are guaranteed about (>>) is that it satisfies the monad laws
19:11:47 <zeiris> What if m a was itself built up with >>= and >>?
19:11:48 <Cale> augur: For precedence, the usual thing is just to use something like chainl to build up an explicit list of results, and then fix that into a tree later.
19:12:00 <kmc> ((a >> b) >> c) = (a >> (b >> c))
19:12:18 <Cale> augur: In fact, that's usually what you end up doing anyway, if you have flexible precedence levels in your language.
19:12:22 <kmc> (return x >> a) = a
19:12:26 <dolio> Oh, is that what people do?
19:12:34 <augur> aha ok. so basically just dont parse with precedence at all
19:12:38 <augur> just post-process
19:12:43 <Cale> yeah
19:12:45 <dolio> I usually just factor my grammar, CFG-style.
19:12:54 <kmc> i use parsec's "Language" support
19:13:14 <Gracenotes> zeiris: for the most part there's nothing special about (>>). It's a shortcut you can substitute for (>>=) when you want to save a couple of characters.
19:13:15 <kmc> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Language.html
19:13:23 <augur> i was gonna build a mixed chart/precedence parser with a configurable precedence table
19:13:34 <Cale> Factoring the grammar is good when you can do it, but if you have things like Haskell's fixity declarations, it's pretty tough.
19:13:38 <eugenn> the 'state' of a list are the values it contains? 
19:13:39 <dolio> poly ::= mon + poly, mon ::= factor * mon ...
19:13:44 <dolio> Yeah.
19:13:57 <Cale> eugenn: Well, there's no "state" as such
19:14:09 <Cale> eugenn: But to "run" a list means to pick a value from it in all possible ways
19:14:10 <Gracenotes> zeiris: but understanding (>>=) can still be hard, for individual monads, let alone in general
19:14:58 <Cale> eugenn: If you're particularly state-oriented, you could think of the state of each list computation as the list of elements remaining in it which haven't been tried yet.
19:15:27 <Cale> But that's probably weird.
19:15:44 <kmc> that "state" being the recursive call stack in concatMap
19:15:49 <kmc> being as (>>=) = flip concatMap
19:16:05 <eugenn> :t concatMap
19:16:06 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
19:16:10 <Cale> > do x <- ["hello", "goodbye"]; y <- ["world", "#haskell"]; return (x,y)
19:16:11 <lambdabot>   [("hello","world"),("hello","#haskell"),("goodbye","world"),("goodbye","#ha...
19:16:25 <kmc> monads aren't in general about state.  it's a common misconception, as several of the most visible applications of monads are about state
19:16:36 <augur> Cale: ill let you know how well my experiment with flexible fixity goes :D
19:16:51 <eugenn> > let number = 4 in 2 + number
19:16:52 <lambdabot>   6
19:16:52 <Gracenotes> augur: good luck. I never got the chain functions; the type signatures baffled me so.
19:16:55 <kmc> monads aren't about error handling, either, even though Maybe and ErrorT are
19:17:58 <bss_> Why isn't filter implemented tail-recursively?  It seems like that would be faster.
19:18:06 <kmc> @src filter
19:18:06 <lambdabot> filter _ []     = []
19:18:06 <lambdabot> filter p (x:xs)
19:18:06 <lambdabot>     | p x       = x : filter p xs
19:18:06 <lambdabot>     | otherwise = filter p xs
19:18:10 <dolio> Hah.
19:18:21 <kmc> tail recursion works differently in a lazy language
19:18:43 <kmc> this definition is good because it's "productive": it produces a single (:) immediately, without walking the whole list
19:18:50 <kmc> and so it can fuse with a lazy consumer
19:18:56 <Gracenotes> and vanilla tail recursion is somewhat difficult on singly linked lists...
19:18:59 <kmc> and eliminate the overhead of the intermediate list entirely
19:19:08 <Gracenotes> unless you want to reverse them that is
19:19:25 <kmc> lists are only partially data; they're also control-flow structures, a way of wiring producers and consumers together into co-routines
19:19:36 <dolio> > filter even [1..]
19:19:37 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
19:19:42 <dolio> Is that faster with tail recursion?
19:19:47 <bss_> We still get extra stack space used though, right?
19:20:01 <kmc> bss_, no.  the stack in a Haskell implementation like GHC is not a call stack
19:20:07 <kmc> it's a stack of things which are being forced
19:20:58 <Gracenotes> the neat part about GHC is that things are evaluated *exactly* when you need them. (unless you demand them sooner, or strictness analysis comes into play)
19:21:05 <kmc> if you know Python, think about implementing a filtering generator with "yield"
19:21:23 <kmc> (itertools has such a thing)
19:21:23 <bss_> dolio: No, but neither version completes.
19:21:34 <dolio> What?
19:21:39 <bss_> dolio: My ghci here tends to need to be interrupted when I feed it infinite lists.
19:21:46 <Gracenotes> the way it's doing case alternatives all the time.. if I were more skilled with graphics I would finish my STG machine widget thing
19:21:49 <dolio> lambdabot just printed out a prefix of that list.
19:21:51 <kmc> bss_, but the tail-recursive version would never produce anything, while the version that's actually used starts producing immediately
19:22:02 <kmc> try it
19:22:16 * wli has mostly relied on the pj-lester-book explanation of it all which he can't really recite well.
19:22:53 <bss_> Hrm, for dealing with non-finite lists I'm getting faster times and less space usage out of a properly tail-recursive function.
19:23:08 <kmc> bss_, you measured it?
19:23:09 <kmc> interesting
19:23:15 <bss_> Micro tests.
19:23:19 <Gracenotes> that's possible, if you know in advance you'll consume the whole thing
19:23:22 <bss_> Nothing definitive.
19:23:30 <bss_> Just stuff like:
19:23:42 <bss_> head . filter3 (> 2) $ (replicate 10000000 2 ++ [3])
19:23:43 <Gracenotes> you can't always know it though
19:23:54 <mauke> bss_: in ghci?
19:23:55 <kmc> bss_, are you testing in ghci?
19:24:04 <bss_> Yeah, in ghci.
19:24:09 <bss_> filter3 has the same source as filter.
19:24:15 <bss_> filter2 is my tail-recursive version.
19:24:17 <kmc> ghci's bytecode interpreter is not heavily optimizing
19:24:21 <kmc> test it with ghc --make -O2
19:24:36 <mauke> how do you know it's the same source as filter?
19:24:51 <bss_> mauke: @src filter, then type that in. :P
19:25:01 <kmc> it should also be noted that there are lots of fusion rules for the real "filter", aren't there?
19:25:02 <mauke> bss_: what makes you think that's what ghc uses?
19:25:06 <Cale> Yeah, make sure also that you use the filter from the libraries.
19:25:14 <kmc> lambdabot's @src is not always the real source used by GHC
19:25:21 <kmc> it's just a plain text file, compiled for didactic purposes
19:25:24 <Cale> The @src plugin doesn't use real source, it uses instructive source.
19:25:46 <bss_> kmc: The actuall filter in ghci, not my new filter3, is much faster.
19:25:46 <dolio> filter is effectively tail recursive for that test case.
19:25:59 <bss_> Presumably because base as already be compiled and optimized.
19:26:07 <Cale> There's actually a big detail which is left out as well: the real filter has a bunch of RULES which cause it to become fused with adjacent operations.
19:26:12 <dolio> It hits the 'filter (x:xs) | otherwise = filter xs' case 10 million times.
19:26:51 <Cale> (when compiled with -O or -O2)
19:27:00 <bss_> dolio Then use "last" instead of "head" and "< 3" instead of "> 2".
19:27:57 <bss_> Still, I'm off-topic for even myself.
19:27:57 <Cale> bss_: How does your tail recursive filter work? reverse at the end?
19:27:58 <dolio> I'm not the one benchmarking these.
19:28:03 <kmc> bss_, did you try the compiled code?
19:28:09 <bss_> I'm really wondering how best to write my haskell code so that GHC optimizes it.
19:28:20 <bss_> I though forcing tail-recursion was useful.
19:28:27 <bss_> If it isn't, I wonder what is.
19:28:56 <bss_> Cale: Yeah, reverse at the end.  Can't handle infinite lists. :(
19:29:22 <Cale> bss_: Generally, productive functions (ones which can produce part of their output without looking at all of their input) are considered better than tail recursive ones, when you can get them.
19:29:35 <kmc> bss_, if the choice is between writing something tail-recursive or something lazy and productive, i think the latter will be better
19:30:00 <kmc> there is no universal rule and you'll have to profile to be sure, but i'd start with the lazy default
19:30:16 <kmc> (it's also more natural and idiomatic, usually, and so falls on the favorable side of "don't optimize prematurely")
19:30:43 <Cale> If your function takes a large amount of data and uses it all to produce something which can't be evaluated partially without looking at the whole input, then tail recursive and strict are appropriate. In essentially all other cases, laziness is equivalent or better than strictness.
19:31:16 <kmc> this is one of the many areas where Haskell departs from "classical" FP (which is why it's funny that Haskell is the poster child for FP for many programmers)
19:31:22 <kmc> if we were a bit more pompous we might call it "quantum FP"
19:31:25 <bss_> Okay.  Good guidelines.
19:31:30 <kmc> data is not collapsed until you observe it ;)
19:31:38 <Cale> Tail recursive functions are the antithesis of laziness, because they produce *nothing* until they have completely consumed their input.
19:31:50 <bss_> My instinct for tail-recursion was inspired by my Common LISP experience.
19:32:03 <kmc> yeah, it's usually a win with strict eval
19:32:06 * hackagebot unamb 0.2.3 - Unambiguous choice  http://hackage.haskell.org/package/unamb-0.2.3 (ConalElliott)
19:32:21 <Cale> Also, unless you're a bit careful, they have the same stack issues that non-tail-recursive functions have.
19:32:32 <kmc> if you have a situation where you *can't* produce data incrementally, then you might want tail recursion + explicit forcing of the accumulator
19:32:34 <Cale> This is because the stack doesn't represent what you're used to :)
19:32:37 <kmc> as in foldl' (compare to foldl)
19:33:06 <kmc> example being "sum": for most numerical types, (a + (b + (c + ... ))) can't be even a little bit determined until all the computation is done
19:33:21 <Cale> Yeah, using higher order functions whenever you can is typically considered better than explicit recursion.
19:33:25 <bss_> kmc: Yeah, I thought I might have to though some `seq` calls in there to make sure my accumulator a handled strictly.
19:33:32 <kmc> (but not so for «data Nat = Z | S Nat», which lets you do fun stuff like evaluate «length [1..] > 3» to True»
19:33:54 <dolio> seq on an accumulator for filter will barely do anything.
19:33:58 <dolio> If anything at all.
19:34:07 <dolio> You're building directly with constructors.
19:34:22 <Cale> Right, in this case it's not such a great idea anyway.
19:34:28 <bss_> dolio: I noticed that when I was fiddling with my timings.
19:34:40 <dolio> So the values you're constructing are already fully evaluated, effectively.
19:34:58 <Cale> bss_: Lists are used in Haskell as imperative programmers use loops. Often what counts is not so much the time it takes to evaluate the whole list, but the time it takes to evaluate the next element.
19:35:52 <Cale> With the toy implementation of filter (as with the real one), the time to evaluate each element is constant in the length of the list.
19:36:15 <Cale> With tail recursive filter, the time to evaluate the first element is O(n), even if you don't use the next one.
19:37:03 <Cale> Well, I say "toy implementation", but it's *pretty* close to the real one :)
19:37:12 <Cale> (the @src implementation)
19:37:44 <Cale> It's just that the compiler doesn't know as much about how it can simplify interactions between it and other adjacent functions.
19:38:23 <Cale> So if you do filter p . filter q, you would hope that the compiler would fuse away the intermediate list.
19:38:56 <Cale> (and give you the equivalent of  filter (\x -> q x && p x)
19:38:58 <Cale> )
19:39:08 <bss_> k
19:39:21 <dolio> I suppose it should get pretty close to that.
19:39:30 <Cale> The list library contains lots of stuff like that, including that very rule.
19:39:52 <dolio> Oh, does it? It's not just up to foldr/build?
19:40:47 * Phyx- goes fishing for points on stackoverflow
19:40:53 <dibblego> \x -> q x && p x = q .&&. p
19:41:18 <kmc> @hoogle (.&&.)
19:41:18 <lambdabot> No results found
19:43:04 <dolio> I guess relying on foldr/build for all that might require more inlining than libraries not written by dons tend to be comfortable with. :)
19:44:10 <Cale> dolio: Well, filter/filter is a bit special, I think
19:44:48 <Cale> It does do foldr/build, and then combines the FB filters.
19:44:57 <Cale> {-# RULES
19:44:57 <Cale> "filter"     [~1] forall p xs.  filter p xs = build (\c n -> foldr (filterFB c p) n xs)
19:44:57 <Cale> "filterList" [1]  forall p.     foldr (filterFB (:) p) [] = filter p
19:44:57 <Cale> "filterFB"        forall c p q. filterFB (filterFB c p) q = filterFB c (\x -> q x && p x)
19:44:57 <Cale>  #-}
19:45:32 <dolio> Ah.
19:46:20 <Gracenotes> so intense
19:47:11 * azaq231 detects his brain can't handle seeing the word cofree after all these years of no use of the "cof" string except in coffee
19:47:40 <Gracenotes> ..
19:48:07 <Cale> coffin
19:48:46 <Gracenotes> http://en.wiktionary.org/wiki/Special:PrefixIndex/cof
19:49:12 <azaq231> non native speaker
19:49:47 <Gracenotes> the wiktionary list has words from all languages ;)
19:49:51 <Cale> yeah
19:50:30 <aavogt> nearly all those words are  co-otherword
19:50:32 <Gracenotes> I get what you mean though. granted, the list is biased towards latin alphabeted languages
19:51:07 <Cale> Yeah, I think I've misread that word as well :)
19:52:17 <Cale> A mathematician turns coffee into theorems, so either a comathematician would turn theorems into coffee, or cotheorems into ffee, whatever that means :)
19:55:23 <Cale> Cotheorems would probably be falsehoods, and with a little poetic liberty, we can drop the extra f... turning falsehoods into fees -- a tax collector?
19:58:07 <Phyx-> @google cabal file specification
19:58:09 <lambdabot> http://www.haskell.org/cabal/proposal/pkg-spec.pdf
19:58:09 <lambdabot> Title: The Haskell Cabal
19:58:21 <Phyx-> proposal.. is that current?
19:58:51 <monochrom> @quote monochrom cofree
19:58:51 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
19:58:56 <monochrom> @quote monochrom coffee
19:58:56 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
20:00:51 <bss_> Okay, now if I needed to take a list and send values matching a predicate into some calculation and the values a different calculation, would it be "better" to just use filter twice or write something like splitWith :: (a -> Bool) -> [a] -> ([a],[a])?
20:01:18 <Cale> bss_: Use partition
20:01:26 <Cale> :t partition
20:01:26 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:01:28 <bss_> :t partition
20:01:29 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:01:38 <bss_> ah, sweet.
20:03:35 <bss_> Okay, I used cabal to install Data.Number.CReal into my home directory.  What env-var or cmdline-option do I need to have ghci pick that (and any other cabal-installed) libraries automatically.
20:03:48 <mauke> none
20:04:14 <bss_> Prelude> 5 :: Data.Number.CReal
20:04:15 <bss_> <interactive>:1:5:
20:04:17 <bss_>     Failed to load interface for `Data.Number':
20:04:18 <bss_>       Use -v to see a list of the files searched for.
20:04:27 <bss_> Doesn't work for me.  Debian.
20:04:40 <Saizan> "5 :: Data.Number.CReal.CReal"
20:04:56 <Saizan> or "import Data.Number.CReal \n 5 :: CReal
20:04:57 <Saizan> "
20:05:01 * bss_ facepalms.
20:05:18 <bss_> Even the haskell tools make me feel like an idiot. :P
20:08:34 <Jafet> forever $ getLine >>= (hPutStr h) . ("PRIVMSG lambdabot :> " ++)
20:08:38 <Gracenotes> bss_: you could also write a partition that uses tail recursion, incidentally. haskell's partition is nice because it only calculates as far as you need in either list
20:09:38 <bss_> gracenotes: Yeah, I could, but, I think the library version will be faster.
20:09:56 <bss_> gracenotes: I can always re-factor if testing shows the library version is too slow.
20:14:16 <kmc> @hoogle (a -> Bool) -> [a] -> ([a], [a])
20:14:16 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
20:14:16 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
20:14:16 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
20:14:27 <blups0r> Good evening
20:14:31 <kmc> hi blups0r
20:14:47 <blups0r> i have a little problem in haskell
20:15:05 <bss_> Haskell makes all problems little. ;)
20:15:29 <blups0r> is it possible to call a funktion on the return value of that funktion?
20:15:40 <mauke> yes
20:15:46 <mauke> that's what fix does
20:16:56 <blups0r> is fix a haskell funktion
20:16:58 <zeiris> Why does the following code not collect [">>"] in the "See" monad? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28535#a28535
20:17:00 <mauke> yes
20:17:01 <bss_> @src fix
20:17:01 <lambdabot> fix f = let x = f x in x
20:17:08 <mauke> > (\x -> 'A' : x) "123"
20:17:09 <lambdabot>   "A123"
20:17:13 <mauke> > fix (\x -> 'A' : x) 
20:17:14 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
20:17:26 <zeiris> The output of test is ["bind", ..., "bind"], with no ">>" in sight!
20:18:11 <bss_> > let f = (*2) in f . f $ 4
20:18:11 <lambdabot>   16
20:18:12 <blups0r> is fix a prelude funktion?
20:18:17 <mauke> @index fix
20:18:18 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
20:18:18 <bss_> @hoogle fix
20:18:19 <lambdabot> Data.Function fix :: (a -> a) -> a
20:18:19 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
20:18:19 <lambdabot> module Control.Monad.Fix
20:18:19 <Phyx-> no
20:18:20 <mauke> no
20:18:24 <Phyx-> it's in Data.Function
20:18:34 <mauke> and in Control.Monad.Fix
20:18:43 <Jafet> (Or is it Data.Funktion?)
20:20:48 <lucca> > fix error
20:20:49 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
20:22:04 <JoeyA> Fixed!
20:22:40 <interferon> i've frequently made the claim that the Maybe type in Haskell makes NPE's impossible, but the possibility of using "undefined" somewhere and thus crashing the program is leaving me less convinced.  is the availability of undefined any different from the availability of null?
20:23:31 <Saizan> it's somewhat different
20:23:57 <Saizan> since it's not normal/easy to check for "undefinedness"
20:24:07 <zeiris> More specific version: the test on line 30 seems like it should trigger (>>), but doesn't. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28535#a28536
20:24:42 <Saizan> so it's meant to use only for those cases in which the program should crash, not to signal some exceptional but still possible condition
20:24:42 <Jafet> interferon: you gotta import ProgramSafetySilverBullet to free yourself from having to think about error handling
20:24:45 <interferon> Saizan: and it's not possible to simply forget to initialize a slot in an ADT and find that it's undfefined
20:25:01 <kmc> interferon, it is, with records, but you get a warning at compile time
20:25:13 <kmc> right.  we have a thing you're forced by the type system to check for, and a thing you can't normally check for
20:25:16 <interferon> and null can be a legitimate meaning, whereas undefined is just bottom
20:25:28 <Saizan> i.e. it's not meant to report runtime errors, it's meant to say "hey, you violated this precondition i explicitly warned you about!"
20:25:30 <kmc> we don't have a thing you can check for but are not forced to
20:25:34 <interferon> kmc: that's true, about records
20:25:38 <danderson> interferon: what Maybe buys you is making the possibility of "null result" explicit, and forcing the calling code to handle it somehow
20:26:02 <Jafet> ...inevitably with fromJust.
20:26:12 * Jafet bends a spoon
20:26:18 <danderson> it doesn't eliminate other sources of program failure, including IO exceptions (which `undefined` throws when evaluated)
20:26:24 <zeiris> is fromJust bad or something?
20:26:26 <Phyx-> there is no spoon
20:26:38 <bss_> > fromJust Nothing
20:26:39 <lambdabot>   *Exception: Maybe.fromJust: Nothing
20:26:39 <kmc> zeiris, yes, unless you are sure that the result is not Nothing
20:26:48 <zeiris> :t fromJust
20:26:49 <lambdabot> forall a. Maybe a -> a
20:26:52 <danderson> the difference however is that you wouldn't really use `undefined` in a day to day program, other than during development
20:26:56 <zeiris> Oh, jesus.
20:27:00 <kmc> the point of having explicit Maybe (rather than putting "null" in every type) is to force callers to check for the Nothing condition
20:27:04 <bss_> maybe undefined fromJust Nothing
20:27:06 <kmc> by writing "fromJust" you punt on that check
20:27:06 <zeiris> :t fromMaybe
20:27:07 <lambdabot> forall a. a -> Maybe a -> a
20:27:09 <bss_> > maybe undefined fromJust Nothing
20:27:10 <lambdabot>   *Exception: Prelude.undefined
20:27:12 <danderson> whereas in, say, Java, returning null pointers for some reason happens routinely.
20:27:50 <danderson> so the case for undefined is pretty much exactly the same as exceptions in java.
20:27:51 <Jafet> undefined is great for passing -Wall
20:27:58 <interferon> zeiris: fromJust is a partial function, so it's mostly bad
20:28:13 <danderson> your program can fail by not handling the null case, or by not catching an exception and causing the entire program to unwind
20:28:29 <danderson> Maybe eliminates only the first class of failures
20:28:38 <mtnviewmark> Now that I've learned Haskell, I now think of passing null pointers in the same class of "bad smell" as passing magic int values.
20:29:23 <bss_> mtnviewmark: I got to the point where passing a foo* in C/C++ was pretty much exactly like passing Maybe Foo in haskell.
20:29:41 <zeiris> @src (>>)
20:29:41 <lambdabot> m >> k      = m >>= \_ -> k
20:29:51 <bss_> @src join
20:29:51 <lambdabot> join x =  x >>= id
20:30:13 <zeiris> Could the default (>>) definition be getting called instead of my own instance?
20:30:21 <mtnviewmark> right - APIs in C/C++ need to use comments or conventions to indicate if a Foo* is  like a Maybe Foo or not
20:30:52 <mtnviewmark> in C++ you can use the convention (and I often do) of using Foo& vs. Foo*, and only using Foo* for Maybe Foo
20:31:08 <Jafet> optional <shared_ptr <foo>>
20:31:14 <bss_> zeiris: I doubt it.
20:31:59 <bss_> mtnviewmark: Yep, Foo& in C++ was always there.  Foo* in C++ was something you have to check for NULL before touching.
20:32:31 <kmc> mtnviewmark, the problem is that, as with everything else in C++, the choice between these two mostly-identical features is motivated by 17 unrelated considerations
20:32:43 <kmc> btw you can make, and test for, a null reference in C++
20:32:54 <bss_> kmc: Not in valid C++
20:33:00 <Jafet> In C++, the bottom is when there is no Foo.
20:33:03 <kmc> is it undefined behavior?
20:33:06 <wli> Foo & was always kind of poorly-fitting IMNSHO. Strings of *'s and &'s don't fit together well.
20:33:08 <Jafet> It's a deep bottom.
20:33:10 <bss_> kmc: Yep.
20:33:48 <kmc> Jafet has it right, using hundreds of thousands of lines of third party libraries you can get a cumbersome version of some of the basics of Haskell's type system in C++
20:33:57 <bss_> kmc: { Foo *f = 0; Foo &g(*f); } is undefined by the standard, for example.
20:33:59 <mtnviewmark> In theory:    bool isThisRefNull(Foo& foo) { return &foo == 0; }
20:34:03 <kmc> oh, but don't forget that "optional <shared_ptr <foo>>" lexes with a right-shift token
20:34:37 <bss_> kmc: Gah, ">>" and ">>>" are the bane of my templates. :P
20:34:40 <Jafet> C++ is so bad, we're using the new version years before it's out
20:34:50 <kmc> the same could be said of Haskell
20:35:06 <bss_> kmc: ">" now always gets " " on both sides in templates, always.
20:35:10 <kmc> yeah
20:35:17 <kmc> they're fixing that in 1x
20:35:21 <kmc> not because it really matters
20:35:21 <Jafet> Well, Haskell's new version comes out of ghc, not thin air
20:35:27 <kmc> but because it's embarrassing
20:35:36 <kmc> C++'s new version comes from Boost and compiler extensions
20:35:48 <kmc> g++ already implements like half of c++1x
20:35:53 <kmc> it doesn't seem that much different
20:36:04 <bss_> kmc: Did "concepts" get in?
20:36:09 <kmc> nope don't think so
20:36:14 <bss_> kmc: :(
20:36:16 <kmc> they got scrapped from the draft spec
20:36:44 <Jafet> The fun thing is, some obscure dependent types with comparisons in the templates will no longer compile
20:36:48 <bss_> kmc: Yeah, I think between boost and g++ we have most of C++1x, anyway, then.
20:37:17 <JoeyA> Typical workflow in C++:  Try to implement a String library; find out you can't get it to work just right because C++ can't choose the right operator[] for char subscripts; end up with something more ugly than you wanted.
20:37:17 <bss_> Jafet: Unlikely.  They probably needed explicit parens anyway.
20:37:29 <Jafet> I wonder how much empty space there is in current Haskell syntax.
20:37:50 <JoeyA> Typical workflow in Haskell:  Try to implement a library, get a weird error message, enable a scary-looking extension, and everything's hunky-dory (well, sort of)
20:38:38 * bss_ Doesn't like the monomorphism restriction.  He wants Haskell to correctly infer his crazy polymorphic types at the top level, too.
20:38:57 <kmc> bss_, yeah, MMR is much-despised
20:39:01 <JoeyA> I used the UndecidableInstances, IncoherentInstances, etc. extensions, and I ran into a case where adding a type signature inside of a let expression made it choose the wrong function.
20:39:01 <kmc> you can turn it off in GHC
20:39:13 <ezyang> -XNoMonomorphismRestriction 
20:39:26 <kmc> {-# LANGUAGE NoMonomorphismRestriction #-}
20:39:28 <ezyang> But lots of people like the "specify all top-level types" 
20:39:46 <kmc> i think top level sigs save a lot of effort
20:39:48 <bss_> ezyang: Actually, I've found in practice that it is a good rule.
20:39:55 <kmc> catch more errors, get better error messages
20:40:03 <bss_> ezyang: The error messages I get tend to me more understandable.
20:40:19 <ezyang> Yes. We don't recommend it for nothing :-) 
20:40:26 <BMeph> If you expose it in the module, put a signature on it, too.
20:40:27 <kmc> "your program is inconsistent in some way" vs. "you said something specific that was false and here it is"
20:41:26 <bss_> Plus, it avoids poor performance when your function just happens to be polymorphic, but you only even call it on one instance.
20:41:42 * bss_ glances sideways at the old type signature on lookup.
20:42:27 * BMeph wonders if there's such a thing as "premature over-generalization"...
20:42:31 <Saizan> JoeyA: i still have to find a case where IncoherentInstances are a sensible choice
20:42:44 <ezyang> BMeph: Of course! 
20:43:01 <ezyang> The antidote is "you ain't gonna need it" 
20:43:46 <BMeph> ezyang: I think they should have named that one, "Put down the Swiss Army knife, and back away"... ;)
20:43:59 <monochrom> yes, there is premature over-generalization
20:45:01 <Jafet> -XExtendHaskellUntilItCompiles
20:45:04 <BMeph> I really meant, is it used as a (semi-)popular phrase, as "premature optimization" is.
20:45:52 <Saizan> "over" looks rendundant there
20:46:06 <Saizan> anyhow i think it's not as well estabilished
20:47:49 <bss_> premature generalization?
20:47:52 <BMeph> Saizan: Actually, I'd rather drop the "premature" part. :)
20:48:28 <aavogt> overexagerate the hyperbole to make a point
20:48:39 <JoeyA> "<Jafet> -XExtendHaskellUntilItCompiles"  That could actually be an option (though it wouldn't compile anything you throw at it)
20:48:53 <JoeyA> It could include all the extensions, then hone it down until it finds a set that works.
20:48:56 <aavogt> it used to be -fglasgow-exts
20:49:02 <bss_> I think I was tyring to do that.  Making all my function arguments type classes instead of types, e.g.
20:49:11 <BMeph> avogt: What? C'mon, we NEVER exaggerate hyperbole... ;)
20:50:16 <tensorpudding> are monads a design pattern?
20:50:32 <aavogt> probably
20:50:45 <BMeph> tensorpudding: Aren't all classes? 
20:51:37 <aavogt> too bad you can't always take the type inferred by ghci
20:52:16 <Jafet> A designer pattern
20:56:56 <kmc> i think that "design pattern" now simply means whatever the patterns community wishes to encourage
20:58:46 <bss_> kmc: That's not entirely true.  It's a well-tested meta-programming fuction.
20:58:52 <kmc> but in the more narrow usage
20:58:58 <kmc> a design pattern is a library you want to write but can't
20:59:11 <bss_> kmc: A collection of design patterns is a meta-programming library for a particular language or collection of languages.
20:59:44 <bss_> kmc: But, I think haskell tends to discourage design patterns, sort of.
21:00:15 <bss_> kmc: If you are doing it as a design pattern, you should tuen it into a type class or collection of type classes.
21:00:28 <kmc> not necessarily a class
21:00:39 <bss_> kmc: If you can't do that in "normal" haskell, you move to template haskell.
21:00:40 <kmc> classes are overused in Haskell
21:01:26 <aavogt> maybe you can do it with classes, but sometimes TH is more sane from the user's perspective
21:01:33 <kmc> they are not a good general-purpose abstraction mechanism
21:02:08 <bss_> kmc: Most of the design patterns I've used are trying to be data independent, so a type class makes sense.  Common behavior contained and described.
21:02:29 <kmc> behaviors are functions and actions
21:02:36 <kmc> functions and actions are values
21:02:41 <kmc> values can be stored in data types
21:02:45 <kmc> no class required
21:03:41 <kmc> sometimes the type class is nice to have; sometimes it's an unnecessary distraction
21:03:58 <bss_> I'll agree with that last statement.
21:04:52 <bss_> If you can do it without a type class, that's probably best.  If you need to generalize it via type classes later, you can always do that in API/ABI version 2.
21:04:52 <Gracenotes> "whatever patterns the community wishes to encourage" <-- because the language can't, by itself. same for anti-patterns..
21:05:28 <kmc> when i do OOP in Haskell i favor a style where interfaces are types, objects are values, and "classes" (a consistent set of interface-implementations) are invisible or simply identified with their "constructor" functions
21:05:35 <kmc> perhaps this is closer to prototype-based OOP
21:06:07 <Gracenotes> kmc: lots of function-type fields, right
21:06:08 <bss_> gracenotes: Right.  It is meta-programming.  Saying "I have a design pattern for you" is like saying "I would make this a library, but the language has limitations I can't get around, so here's how to do it over-and-over manually."
21:06:09 <kmc> but i think it's better (simpler, cleaner, more flexible, more first-class) than the other correspondence: interfaces are type classes, classes are types + instance declarations, objects are values of many different types
21:06:46 <Gracenotes> kmc: unfortunately you can't do any kind of subtyping
21:06:53 <Gracenotes> at least not easily
21:07:09 <bss_> kmc: Yeah, that's how I think of type classes in haskell, too.  They roughly match interfaces or pure virtual classes in other languages.
21:07:17 <kmc> and some people lean towards the second design by false analogy to OOP
21:07:30 <Gracenotes> well, that's inaccurate. you can do depth, not width.
21:07:37 <kmc> bss_, but i want to *discourage* that style
21:07:48 <kmc> in favor of the simpler style where types serve as interfaces
21:07:52 <kmc> whenever possible
21:08:18 <bss_> Ah, hrm.
21:08:39 <kmc> there is the false assumption that new behavior => new type
21:08:40 <Saizan> where the type in particular is a record with function fields, which would be the methods of the interface
21:08:43 <kmc> which is not even intrinsic to OOP
21:08:52 <kmc> it's intrinsic to a few poorly-designed, low-power OOP languages
21:08:54 <bss_> I can see that, I guess.  You end up passing a lot of thunks around, but I can see it being useful.
21:08:59 <kmc> which lack things like first-class functions
21:09:04 <kmc> which shall remain nameless
21:09:10 <Saizan> thunks?
21:09:48 <kmc> anyway, class-based OOP encourages or requires new types for new behaviors
21:10:06 <bss_> Saizan: "thunks": My Lisp-speak for lazy-evaluated values.
21:10:20 <bss_> Like a "Promise".
21:10:23 <kmc> which is absurd to the functional programmer -- every function is a new behavior, yet many functions have the same type
21:10:32 <Saizan> bss_: this is not related to lazy eval though
21:10:39 <kmc> bss_, if you pass a record of objects "methods", those aren't thunks
21:10:53 <kmc> they're functions, probably already in normal form.  they might be represented in-memory as closures
21:10:53 <Saizan> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
21:11:06 <kmc> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ is also relevant
21:11:10 <bss_> I said thunks, I meant partially-applied functions.
21:11:35 <kmc> partial application isn't related to laziness though
21:11:49 <kmc> and partial application is really invisible in Haskell: every function has one arg, so you can't partially apply them at all ;)
21:12:06 <kmc> of course implementations don't really work that way
21:12:17 <kmc> but the simplest graph-rewriting operational semantics for Haskell has no special treatment of partial application
21:12:26 <kmc> you just fully-apply one-arg functions which return more functiosn
21:17:01 <Saizan> that antipattern article puts the emphasis on all the irrelevant aspects considering haskell is System F\omega and data declarations help with type inference, the real question is if it makes sense and/or there's any need to connect behaviour to types
21:20:01 <kmc> Haskell is not really Fω
21:20:31 <kmc> Fω is similar and makes a good target language
21:20:49 <Saizan> i mostly referred to the higher-rankeness
21:20:51 <kmc> but i don't quite understand what you mean Saizan
21:21:05 <Saizan> you can abstract over arbitrarily polymorphic values
21:22:11 <kmc> what's that got to do with encoding object hierarchies?
21:23:42 <Saizan> "Functions are the masters of reuse: when you use an advanced feature, you need a yet more advanced feature to abstract over it (think: classes < existential types < universally quantified constraints < unknown). But all you need to abstract over a function is another function."
21:25:00 <Saizan> that ".. < unknown" is false
21:25:40 <Saizan> also, it's not true that the two representations give the same guarantees
21:28:24 <aavogt> do 'universally quantified constraints' here mean RankNTypes?
21:28:35 <aavogt> or just regular polymorphic functions?
21:29:24 <Saizan> the former i think, which in fact is not so clear why they are separate from existential types
21:31:35 <NemesisD> anyone in the mood to help me figure out how to get my trivial cat program to compile?
21:31:57 <kmc> sure thing
21:33:01 <kmc> can you put the code and error messages on hpaste.org ?
21:33:04 <NemesisD> http://pastie.org/1074421
21:33:23 <kmc> you're missing a "do" on catFiles
21:33:42 <NemesisD> ah ok. and do is just used on anything that works with io actions?
21:33:50 <kmc> "do" is just syntactic sugar
21:33:55 <kmc> useful for building io actions
21:34:05 <kmc> if you're going to use the "x <- m" syntax, you need "do"
21:34:27 <kmc> do { x <- a; b }   is sugar for   a >>= (\x -> do { b })
21:34:27 <NemesisD> whats the sugar free version?
21:34:33 <NemesisD> oh
21:34:55 <kmc> (>>=) is one of the methods in the "Monad" type class.  for IO its type is «IO a -> (a -> IO b) -> IO b»
21:35:39 <kmc> NemesisD, would you also like style advice?
21:35:44 <Saizan> that statement is also mixing levels, the last sentence is hiding the fact that functions have types, even if there's a lot you can abstract over and still be Rank1
21:35:45 <NemesisD> certainly
21:35:55 <kmc> so first of all, catFiles will crash on the empty list
21:36:01 <kmc> arguably it should do nothing and return
21:36:11 <kmc> but you can rewrite the recursion using mapM_
21:36:12 <kmc> :t mapM_
21:36:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
21:36:35 <kmc> in this case:  mapM_ :: (String -> IO ()) -> [String] -> IO ()
21:36:40 <kmc> very much like a foreach loop, in fact
21:36:41 <kmc> :t forM_
21:36:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
21:36:44 <kmc> forM_ = flip mapM_
21:37:11 <kmc> so «main = getArgs >>= mapM_ catfile»
21:37:20 <kmc> no "do"; you're using (>>=) directly, not through sugar
21:37:47 <kmc> then you just write «catfile :: String -> IO ()»
21:38:01 <kmc> you may also want to use withFile
21:38:02 <kmc> :t withFile
21:38:03 <lambdabot> Not in scope: `withFile'
21:38:06 <kmc> grr
21:38:14 <kmc> :t System.IO.withFile
21:38:15 <lambdabot> forall r. FilePath -> GHC.IOBase.IOMode -> (GHC.IOBase.Handle -> IO r) -> IO r
21:38:29 <kmc> takes care of closing for you, even if there are exceptions
21:39:50 <kmc> NemesisD, you should put type signatures on your top-level bindings
21:40:02 <kmc> in particular, it is easy to screw up in such a way that «main :: IO (IO ())», and does nothing
21:40:09 <kmc> and GHC by default will not complain
21:40:13 <kmc> so it's good to force main :: IO ()
21:40:24 <EvanR> this is like the haskell anthem
21:40:50 <EvanR> just got done watching a war movie with a patriotic speech
21:43:50 <NemesisD> kmc: so im seeing you use withFile like filename mode act, act would be a do? or a lambda?
21:43:58 <kmc> NemesisD, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28537#a28537
21:44:06 <kmc> act can be anything with the right type
21:44:17 <kmc> but a convenient way to build a value with that type is «\handle -> do ...»
21:44:24 <kmc> note also the formatting i use on "do"
21:44:30 <kmc> which is to start it on the next line, 2 spaces indented
21:44:38 <kmc> rather than having it hang off a huge amount of whitespace
21:44:42 <mtnviewmark> anyone here want to test a short survey about the new Haddock output?
21:44:43 <mtnviewmark> http://bit.ly/9Zvs9B
21:44:44 <kmc> this is a matter of preference, of course
21:44:51 <kmc> but i find it more readable personally
21:44:55 <mtnviewmark> can someone let me know if you can take that survey?
21:45:01 <kmc> and you don't have to adjust the whole block if the length of the first line changes
21:45:03 <NemesisD> i think i need a haskell plugin for vim, its going completely haywire on the indentation
21:45:44 <EvanR> i think emacs is more popular
21:45:46 <EvanR> for haskell
21:46:59 <bss_> I use vim, and tabs, but I generally operate in "list" mode.
21:47:06 <NemesisD> im not learning emacs :[
21:47:07 <bss_> That way tabs and spaces look different.
21:47:08 <kmc> i use vim
21:47:11 <dibblego> I use leksah
21:47:12 <kmc> tab characters are the devil
21:47:18 <EvanR> ew vim tabs
21:47:21 <NemesisD> it took me long enough to get good at vim
21:47:23 <EvanR> or are we talking about tab key
21:47:34 <kmc> mtnviewmark, ... i didn't even know Haddock did frames, thanks for pointing it out
21:47:41 <mtnviewmark> heh
21:48:14 <bss_> kmc: I disagree.  The general behavior of mixing tabs and spaces is to blame.
21:49:07 <c_wraith> bss_: You can't easily do proper haskell layout with tabs only, and mixing tabs and spaces is bad...  what's the conclusion?
21:49:10 <dibblego> mtnviewmark, where is the difference to the old haddock?
21:49:11 <bss_> kmc: With disciplined use of tabs your code can be readable to programmers that want various levels of horizontal whitespace.
21:49:29 <mtnviewmark> links 3 & 4 are the new look
21:49:36 <mtnviewmark> lnks 1 & 2 are just for reference
21:49:43 <bss_> c_wraith: I do all my layout with tabs.  I do have to keep in mind how layout treats tabs though.
21:49:46 <dibblego> mtnviewmark, ah right, I should read better :)
21:50:09 <mtnviewmark> no problem-o
21:50:25 <mtnviewmark> so - I take it you *can* access and take the survey - 
21:50:33 <mtnviewmark> good - I'm going to send it off to Haskell-cafe then
21:50:37 <kmc> mtnviewmark, btw the main way i navigate haddock pages is find-in-page (Ctrl-F or /)
21:50:37 <bss_> c_wraith: Well, not all my layout.  Multi-line case expressions only get their patterns half-indented (one space in my indentation policy).
21:50:41 <EvanR> bss_: sounds like an editor problem, not being able to expand leading whitespace regardless of character
21:50:44 <kmc> silly but it works on every website ever
21:50:57 <mtnviewmark> oh - good thought - I'll add that as an option
21:51:08 <kmc> maybe throw in some JS magic
21:51:13 <kmc> so i can hit 'f' and then type an identifier name
21:51:25 <kmc> and get a little zsh-style list of completions, and have it jump to the first one
21:51:26 <bss_> EvanR: vim will expand leading whitespace if I tell it to, but I use spaces and tabs in distinct roles.  Converting one to the other is a mistake.
21:51:27 <kmc> i'd also like a pony
21:51:48 <NemesisD> i come from ruby and the convention there is for 2 space indentation
21:52:01 <Jafet> Make a neat utilities library and call it Pony
21:52:04 <NemesisD> so my editor on all the machines i work on is configured that way
21:52:05 <mtnviewmark> ponies have to wait until HTML5 is widely available
21:52:20 <mtnviewmark> ... <pony> just isn't in XHTML or HTML 4.01
21:52:31 <bss_> EvanR: Tabs indicate the nesting level, which spaces are used used for compiler-ignored (including layout) visual alignment.
21:52:44 <Jafet> Your DTD just isn't pink enough.
21:52:56 <EvanR> this is annoying. i have an IO action that has three possible return types, Maybe allows for two, and Either also allows for two
21:53:41 <EvanR> data Hmm a b c = Left a | Middle b | Right c
21:53:45 <EvanR> :\
21:53:48 <bss_> NemesisD: That could be a problem.  Haskell's layout engine has special treatment for tabs.  In particular, they aren't assumed to be two spaces.
21:53:58 <c_wraith> EvanR: sometimes, it's not worth abstracting.
21:54:09 <EvanR> well what do i use instead
21:54:12 <EvanR> nested Either
21:54:20 <bss_> Maybe (Either l r)
21:54:25 <c_wraith> No, something not polymorphic
21:54:41 <bss_> @type Just . Left $ 1
21:54:42 <mtnviewmark> writes <pony style="effect: sparkle; color: rainbow;">TraLaLa</pony>
21:54:42 <lambdabot> forall a b. (Num a) => Maybe (Either a b)
21:54:51 <EvanR> looks like im going to Maybe Either
21:54:57 <NemesisD> bss_: FFFFFFFFFFFFFF
21:55:01 <kmc> Jafet, http://hackage.haskell.org/package/pony
21:55:01 <c_wraith> data Result = Failure1 String | KindaWorked String | Success Answer
21:55:11 <bss_> @type [Nothing, Just . Left $ 1, Just . Right $ "stuff"]
21:55:12 <lambdabot> forall a. (Num a) => [Maybe (Either a [Char])]
21:55:22 <c_wraith> It's not abstract, it's not polymorphic.  It just does what you need.
21:55:25 <kmc> EvanR, define a type which makes sense for your problem domain
21:55:33 <EvanR> ah
21:55:44 <EvanR> but..
21:55:59 <kmc> Either and (,) are useful locally, but anything which is exposed widely should probalby have its own type
21:56:02 <dibblego> mtnviewmark, done
21:56:09 <mtnviewmark> thank you
21:56:12 <NemesisD> im sure i could scrounge up some haskell plugins
21:56:30 <EvanR> k ill figure something out
21:56:40 <bss_> data SqlResult a = Details a | Count Int | NoResult
21:59:08 <bss_> NemesisD: If you really wanna, you could write layout-free haskell, either explicit "{", "}", and ";" everywhere.
22:00:53 <NemesisD> bss_: im not vehement enough about space tabs enough to do that, i just want a plugin to do the remembering for me  and my system is very much tuned right now for ruby, html, js
22:02:32 <EvanR> you could also use standard style
22:02:36 <EvanR> like everyone else
22:02:41 <EvanR> and no one will hate you
22:02:58 <NemesisD> i have no idea what these things mean. haskell is a scary world of sharp objects for me right now
22:04:59 <yescalona> how convert string to integer?
22:05:12 <EvanR> read
22:05:15 <dibblego> > read "123" :: Integer -- yescalona 
22:05:16 <lambdabot>   123
22:05:37 <EvanR> > read "123j" :: Integer
22:05:38 <lambdabot>   *Exception: Prelude.read: no parse
22:06:18 <bss_> @type reads
22:06:19 <lambdabot> forall a. (Read a) => String -> [(a, String)]
22:06:24 <kmc> yescalona, that question is equivalent to "What's a function of type String -> Integer", and there are many such functions
22:06:41 <kmc> however i'm guessing you want to read ASCII decimal digits as an integer, for which "read" will do what you want
22:06:42 <bss_> > (integer :: Integer, rest) = reads "123j"
22:06:43 <lambdabot>   <no location info>: parse error on input `='
22:06:59 <EvanR> > length "123"
22:06:59 <lambdabot>   3
22:07:01 <kmc> if you need to catch errors, call "reads" and match against [(v,"")]
22:07:05 <bss_> > ((integer :: Integer), rest) = reads "123j"
22:07:05 <lambdabot>   <no location info>: parse error on input `='
22:07:20 <bss_> > reads "123j" :: (Integer, String)
22:07:21 <lambdabot>   Couldn't match expected type `(GHC.Integer.Internals.Integer,
22:07:21 <lambdabot>              ...
22:07:23 <kmc> > let ((integer :: Integer): rest) = reads "123j" in integer
22:07:24 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
22:07:24 <lambdabot>         agains...
22:07:39 <kmc> > let (((integer :: Integer), rest):_) = reads "123j" in integer
22:07:40 <lambdabot>   123
22:07:42 <kmc> > let (((integer :: Integer), rest):_) = reads "123j" in integer
22:07:43 <lambdabot>   123
22:07:44 <kmc> > let (((integer :: Integer), rest):_) = reads "j" in integer
22:07:45 <lambdabot>   *Exception: <interactive>:1:137-180: Irrefutable pattern failed for pattern...
22:07:52 <kmc> that's why you should probably use "case" instead
22:08:13 <bss_> reads "123j"
22:08:16 <bss_> > reads "123j"
22:08:17 <lambdabot>   []
22:08:24 <bss_> > reads "j"
22:08:25 <lambdabot>   []
22:09:05 <kmc> > reads "()"
22:09:05 <lambdabot>   [((),"")]
22:09:17 <yescalona> whats mean "::" in a common language
22:09:28 <kmc> (e :: t) means "e has type t"
22:09:28 <c_wraith> "has the type"
22:10:47 <kmc> you can put pattern guards on a non-function
22:10:49 <yescalona> thx
22:10:52 <kmc> which is a fun roundabout way to write "case" ;)
22:11:37 <bss_> kmc: Ah, I missed the "[]" in the type signature of reads.
22:11:54 <bss_> reads "123j456k" :: [(Integer, String)]
22:11:58 <bss_> > reads "123j456k" :: [(Integer, String)]
22:11:59 <lambdabot>   [(123,"j456k")]
22:12:35 <bss_> It's being used like maybe, I guess?  For non-deteranistic parsing?
22:12:41 * bss_ can't spell.
22:12:56 <c_wraith> yeah, it's so that multiple possible parses may be returned, if it makes sense for the type
22:15:03 <Gracenotes> that's what ReadP does
22:15:25 <Gracenotes> ReadP is somewhat annoying though
22:16:14 <Gracenotes> it might be nicer if it had explicit cuts. at least to use.
22:16:44 <Gracenotes> (<++ isn't the most explicit thing, and look-aheads are hacky)
22:16:53 <EvanR> lol. i just found out how to write an IO action in a way that makes it look like BASIC
22:17:20 <EvanR> paste in a second
22:17:24 * wli isn't convinced on parser combinators.
22:19:30 <kmc> EvanR, http://hackage.haskell.org/package/BASIC ?
22:24:01 <EvanR> http://codepad.org/7ap9VKby
22:24:28 <EvanR> not guaranteed to be correct, its just funny that names in the where are like 'gotos' ;)
22:25:29 <EvanR> kmc: lol this package is awesome
22:28:56 <EvanR> also has the consistency of a slice of COBOL
22:30:50 <EvanR> if we explain recursive programs to people as 'GOTO', would that help or hurt ;)
22:42:48 <kmc> EvanR, continuations are functional GOTO
22:44:12 <Cale> bss_: Yes, that's right (about reads)
23:06:44 <NemesisD> lol whats with all the cartoon network references in learnyouahaskell
23:20:41 <blueonyx> hi, is someone using hgal to check 2 fgl graphs for isomorphism?
23:31:02 <bss_> Hrm, any good way to convert Data.Number.CReal.CReal to Data.Ratio.Rational?
23:31:09 <bss_> Of course, within some accuracy?
23:31:15 * hackagebot shaker 0.2 - simple and interactive command-line build tool  http://hackage.haskell.org/package/shaker-0.2 (AnthoninBonnefoy)
23:31:23 <bss_> approxRational doesn't seem to work.
23:42:06 <ezyang> "Some of the standard list manipulation functions give incorrect results when used on [Char]." Huh. What is Bryan referring to? 
23:42:29 <wioux> bss_: show and then read?
23:48:32 <bss_> wioux: I tried that.
23:48:59 <bss_> wioux:  Rational only reads <Integer> % <Integer>. :(
23:49:29 <kmc> which CReal library bss_?
23:50:05 <bss_> Prelude> read . show $ (pi :: Data.Number.CReal.CReal) :: Rational
23:50:06 <bss_> *** Exception: Prelude.read: no parse
23:50:14 <bss_> Data.Number.CReal
23:50:19 <kmc> what package?
23:50:20 <bss_> Is there a better / different one?
23:50:28 <kmc> there's HERA, i don't know if it's better
23:50:30 <kmc> supposedly faster
23:50:34 <bss_> number-2009.8.9
23:50:47 <kmc> ah, cool
23:50:55 <bss_> numbers-2009.8.9 is supposedly based on the ERA library.
23:50:59 <blups0r> need some help with a piece of code 
23:51:10 <kmc> blups0r, ok
23:51:12 <bss_> blups0r: ok
23:51:38 <blups0r> cant find the piece where he is throwing the error message
23:51:52 <blups0r> should i post the code here or a pastebin link?
23:51:57 <kmc> pastebin
23:52:02 <kmc> hpaste.org or codepad.org
23:52:38 <wioux> > read . show $ (pi :: Data.Number.CReal.CReal) :: Double
23:52:39 <lambdabot>   3.141592653589793
23:52:54 <wioux> > approxRational (read . show $ (pi :: Data.Number.CReal.CReal) :: Rational)
23:52:55 <lambdabot>   Overlapping instances for GHC.Show.Show
23:52:55 <lambdabot>                              (GHC.R...
23:52:57 <bss_> :t \d -> (Ratio.% d) . truncate . (* (fromInteger d))
23:52:58 <lambdabot> forall a. (RealFrac a) => Integer -> a -> Ratio Integer
23:53:10 <blups0r> http://pastebin.com/MDqkUvNy
23:53:11 <bss_> That's roughly what I'm using now...
23:53:20 <kmc> @let rpi :: Data.Number.CReal.CReal; rpi = pi
23:53:21 <lambdabot>  Defined.
23:53:42 <kmc> what's your error blups0r
23:54:06 <bss_> I can't go through Double or Float because I want more digits of accuracy then they provide.
23:54:24 <blups0r> [1 of 1] Compiling Main             ( trie.hs, interpreted )
23:54:25 <blups0r> trie.hs:47:0:
23:54:25 <blups0r>     Occurs check: cannot construct the infinite type: a = [a]
23:54:25 <blups0r>     When generalising the type(s) for insertInTrieLst, insert
23:54:25 <blups0r> Failed, modules loaded: none.
23:54:42 <kmc> blups0r, do you understand the error message?
23:54:59 <kmc> somewhere you've got a type which is simultaneously forced to be "a" and "[a]"
23:55:03 <kmc> and in Haskell there's no type a such that a = [a]
23:55:26 <blups0r> ok 
23:55:44 <blups0r> put wheres the line in the code where i try to do so
23:55:52 <kmc> i haven't found it
23:56:00 <kmc> the error is in either "insertInTrieLst" or "insert"
23:56:08 <kmc> they are mutually recursive, so it type checks them together
23:56:23 <bss_> Line 27... I think you mean (value:v) instead of (v:value).
23:56:33 <bss_> :k (:)
23:56:34 <lambdabot> parse error on input `:'
23:56:42 <bss_> :t (:)
23:56:43 <lambdabot> forall a. a -> [a] -> [a]
23:57:00 <bss_> value has to be first, rest of the list has to be second.
23:57:17 <kmc> blups0r, would you like some advice about style as well?
23:57:43 <wioux> > :t Data.Number.CReal.showCReal
23:57:44 <lambdabot>   <no location info>: parse error on input `:'
23:57:48 <blups0r> ok that was it
23:58:01 <blups0r> advice about style is appreciatex
23:58:14 <kmc> the pattern (x:[]) is more commonly written [x]
23:58:36 <kmc> when constructing a list of one element, you don't need to say [(e)], it is fine to say [e]
23:58:59 <kmc> also you have a function call written like «x == getKey(actual)»; it would be more typically written «x == getKey actual»
23:59:15 <bss_> blups0r: I'd merge the Node and KeyNode constructors.  [] is of type (forall a. [a]) so a Node is just an "empty" keynode, I think.
23:59:28 <kmc> you can also drop the parens in «actual:(insertInTrieLst str value rest)»; operators always bind looser than function application
23:59:34 <kmc> but maybe you like them for readability
