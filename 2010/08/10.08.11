00:00:17 <dolio> Well, that's not totally accurate.
00:00:24 <siteswapper> catenate: And kinds, probably...
00:01:28 <dolio> Types and functions form a category much like sets and functions do.
00:01:57 <dolio> But the wording sort of implies types are categories, which is a bit off.
00:02:50 <bss03> Templated Types and/or Type Constructors is enough to put your type system in category theory space, as I understand it.
00:03:40 <bss03> "Simple" types, like Int, Char, Fixed-length arrays, Tuples, Records can all be reasoned about with "just" Set Theory.
00:04:46 <catenate> Category theory is also why corporate programmers think Haskell is for Ivory-tower weenies.  Java has had all obvious traces of theoretical computer science stripped out of it, for the good of the cut-and-paste code monkey.
00:06:07 <kmc> yeah
00:06:18 <kmc> there's a lot of misconceptions about the relationship between Haskell and maths
00:06:26 <kmc> some people like to use Haskell notation to talk about maths
00:06:40 <bss03> Ugh.  I hate maintaining cut-and-pasted code.
00:06:54 <catenate> Java doesn't even have a polymorphic map, which is easy to understand and utilize in preference to for loop bodies.
00:06:55 <bss03> I've had to do it multiple times, in C, C++, Java, and VB.Net.
00:08:25 <kmc> there are tools from bioinformatics which infer evolutionary trees by matching genomes
00:08:29 <kmc> i wonder if they could be applied to source code
00:08:46 <dolio> Could it do map if it actually had first-class functions? Or is there something about its generics that is too limiting?
00:08:49 <catenate> Go has real closures, at least, but they're also not interested in generics enough to support a polymorphic map.  SO in GO you can write a map function, using a function name or closure, but only for one specific type signature of your function and array.
00:08:59 <kmc> or it involves a runtime cast
00:09:12 <bss03> I've heard of using genetic algorithms to build parse-trees.
00:09:14 <catenate> er, So in Go
00:09:15 <kmc> the finance industry heavily encourages copy-paste code
00:09:27 <bss03> I've never though about "going the other way".
00:09:27 <kmc> there is no release deadline; every day you don't release directly costs thousands of dollars
00:09:48 <kmc> so it's strongly encouraged to copy the nearest similar thing and hack it up just enough to kinda work
00:10:23 <kmc> i if the people using Haskell in finance run into this
00:10:38 <dolio> Yeah, I'm not sure what they were thinking with the lack of parametric polymorphism, considering even Java has it now.
00:10:39 <koninkje> dolio: Java generics _could_ do polymorphic fmap, but it's extremely ugly to work with
00:11:15 <kmc> they weren't thinking
00:11:27 <kmc> specifically, weren't reading, the PL literature
00:11:32 <koninkje> Also, subtyping and generics don't mix because they don't distinguish covariant and contravariant type variables
00:11:34 <ezyang> The feeling I get is that the finance industry is taking advantage of the fact that Haskell code is so short. 
00:11:39 <kmc> koninkje, Scala has that though
00:11:44 <ezyang> So you can quickly prototype and throw away code. 
00:11:51 <dolio> koninkje: I thought we were just talking map for lists. I'd be quite surprised if it could do fmap.
00:11:57 <kmc> Haskell code is short, but i wouldn't say it's necessarily quick to write
00:12:22 <ezyang> Sure. :-) 
00:12:23 <kmc> Python code is easy to write, and APL / J are very short, and both are pretty popular in finance
00:12:26 <koninkje> dolio: fmap is just an interface. if you can do map, then you're set
00:12:31 <kmc> but i think Haskell brings something different to the table
00:12:38 <kmc> "hard but short but correct"
00:12:49 <dolio> I suppose that's true.
00:13:13 <koninkje> but it's really ugly and, as I recall, not at all performant
00:13:29 <koninkje> hence the use of iterators 
00:13:33 <kmc> for the people doing derivatives modeling in Haskell, i wonder how their priorities are set between traders and risk managers
00:13:55 <kmc> the two would tend to favor different approaches
00:13:56 <bss03> kmc: You know, I think we'd have better software in general is langauges where shorter and more correct in general.
00:14:12 <kmc> maybe
00:14:27 <catenate> kmc: I paid a lot of attention to the Plan 9 and Go communities for a while, and they are an island unto themselves.  Totally wedded to their problem domain (low-level OS, and embedded OS), really not interested in many application domains.
00:14:42 <bss03> kmc: Hard?  I don't think Haskell is particularly hard.  I think I had more trouble thinking in Prolog the first time.
00:14:50 <bss03> Of course, I've forgetten my Prolog now.
00:16:34 * ski wonders how one can forget Prolog ..
00:16:45 <kmc> catenate, but they're also not interested in PL literature that might be applicable to their domain, it seems
00:17:36 <catenate> On the other hand, they have produced some beautiful software tools.  I use Acme as my editor/shell interface/window manager, and it's helped me be a lot faster with fewer errors in everything I do, since it outsources almost everything an IDE does to command-line tools and just ties it all together.
00:17:54 <kmc> yeah
00:18:01 <kmc> i really like the Plan 9 philosophy
00:18:28 <catenate> kmc: They certainly do dismiss standards.
00:19:15 <dolio> Forgetting Prolog isn't that bad. You can use the opportunity to learn a better logic language. :)
00:19:51 <kremsera> There are fixed size Integer types like Data.Int32 and Data.Int16
00:19:53 <BMeph> dolio: Recommendations?
00:19:57 <ski> dolio : .. thinking of ?
00:20:02 <kremsera> are there comparable Floating-Point types?
00:20:04 <kremsera> like Float32
00:20:10 <dolio> I've heard good things about lambda prolog.
00:20:11 <ski> Mercury ? Curry ? Escher ? Twelf ?
00:20:14 <catenate> kmc: I think they know about much of what's out there in languages, but employ an extremely selective and rigorous process to determine if it's actually useful for "systems engineering" as they define it.
00:20:14 <dolio> And Mercury.
00:20:24 <ski> yeah, lambdaProlog is cool
00:20:41 <ski> (and lolli, as well .. i should try Linear Twelf some time)
00:20:56 <dolio> Twelf is cool if you're into fiddling with type theories and stuff.
00:21:21 <dolio> I'm not sure what its capabilities are as an actual logic programming language.
00:21:36 <BMeph> What about the OBJ crew, Maude and such?
00:21:42 * RayNbow sighs... it's frustrating if you want to compute something but lack sufficient data...
00:21:51 <catenate> kmc: In the end, I want to do more than what they're building Go for, so I view it as a replacement for C/C++/Java console programs.
00:22:16 <kmc> but surely C++ and Java benefit from parametric polymorphism, such as they have
00:22:29 <dolio> I'm not sure I'd put Maude in the same category.
00:22:46 <kmc> i think it's more the case that they know polymorphism is useful, but think it's too complicated for a KISS design
00:22:50 <kmc> and there's something to that
00:23:01 <catenate> kmc: Go has channels, Hoare's CSP to connect processes rather than shared memory, and that's nice to use and efficient.
00:23:18 <kmc> yeah
00:23:23 <ezyang> kmc: Perhaps because real polymorphism is simple, but in a very mathematical way. 
00:24:00 <koninkje> dolio: Twelf is LF, which corresponds with first-order intuitionistic predicate calculus
00:24:27 <dolio> Yes, but it doesn't use that for computation.
00:25:07 * koninkje missed the "programming language" after "...as an actual logic"
00:25:13 <catenate> What bothers me most about their programming style is that they have absolutely no problem with repetition of source code.  They would rather keep an implementation simple, than make it more complex but shorter.  This is kind of why they don't see the value in parametric polymorphism.
00:26:03 <kmc> catenate, you're talking about the Plan 9 or Go-compiler codebases?
00:26:44 <dolio> It seems unlikely that Twelf would have the kind of support for 'real programs' that Mercury, say, would, simply because that's not its intended use.
00:26:50 <catenate> And why you have to write a separate map function in Go for each function and array signature.
00:27:04 <catenate> kmc: Plan 9 is just C, not Go.
00:27:11 <ski> dolio : btw, "Twelf, my favorite general-purpose functional programming language" at <http://polaro.blogspot.com/2010/01/twelf-my-favorite-general-purpose.html> might be interesting, if you've not seen it before
00:27:17 <catenate> kmc: but it's true of both
00:28:13 <kmc> is #haskell the premier channel for PL nerds?
00:28:17 <kmc> or are there others
00:28:18 <dolio> ski: Yeah, I've seen it. My reaction is kind of "C is my favorite functional language, because I write interpreters for functional languages in it."
00:28:30 <ski> copumpkin : btw, i found <http://wiki.portal.chalmers.se/cse/pmwiki.php/CS/QuantifierEliminationAndFunctionalProgramming> in my logic w3m
00:28:56 <ski> dolio : sorta, i suppose, yes :)
00:29:07 <dolio> But, I mean, it's way better than C for that, obviously.
00:29:44 <Starfire> Anyone interested in taking a look at my record field combinator library?
00:30:10 <kmc> sure
00:30:48 <Starfire> Source is at http://github.com/AstraFIN/fields, haddocks at http://www.niksula.hut.fi/~starfire/haskell/fields/
00:30:56 <catenate> kmc: Looking at other PL source texts I keep thinking Haskell is just years ahead.  Mostly because most other languages are vying for the post-Java spot by being on the JVM.  Clojure is daring in that context because it's a Lisp built into a jar file.
00:31:06 <Starfire> I'm hoping to release it on Hackage, as soon as I get a username.
00:31:08 <kmc> scala too
00:31:16 <kmc> and Scala's type system is fancier than Haskell's in some respects
00:32:43 <baguasquirrel> Scala's type system is interesting in that it allows subtyping, right?
00:32:54 <kmc> and instead of classes it has implicits
00:33:03 <catenate> I personally dig that Haskell compiles down to native code.  I think that's a win over backwards compatibility with Java libraries, but then again I don't much program in domains where those libraries and indeed the JVM seem much more to me than old cruft.
00:33:09 <kmc> (not sure if that's considered part of the type system)
00:33:10 <baguasquirrel> hmm...
00:33:25 <kmc> catenate, well, you could compile Java to native code too.  that's an implementation property, not a language property
00:33:39 <kmc> and such compilers do exist, though i'm not sure if they're used for anything serious
00:33:47 * ski recalls hearing one of the developers of Turbo/PDC/Visual Prolog explain how they added parametric polymorphism because it got tedious to add more (monomorphic) type signatures for append/3 and friends, then they got up to ~100
00:33:49 <kmc> gcc has one
00:34:06 <catenate> Scala's deal as I understand is that there's a deep equivalence between functions and objects, with objects being Scala's root abstraction.
00:34:39 <catenate> kmc: gcj, yeah
00:35:18 <kmc> i'd like to see better JVM interop for Haskell
00:35:26 <kmc> it may grow out of this android project
00:35:27 <kmc> we'll see
00:35:40 <ski> (s/then they/when they/)
00:35:51 <catenate> kmc: that would help it immensely in industry, but bring on the code monkeys
00:36:04 <kmc> i expect the code monkeys would continue to use Java
00:36:14 <dolio> At least one of the compilers could generate Java at some point, I think. But that never took off.
00:36:20 <kmc> YHC maybe
00:36:35 <kmc> but i think we could have good interop between GHC-compiled native code and Java code
00:36:46 <kmc> if someone is willing to wade through JNI bullshit for long enough
00:36:49 <catenate> Java -> Scala, I think.  Clojure's lisp syntax will make it far less popular, IMO
00:36:52 <BMeph> Clojure should make a web framework called "Lisp in a Leyden (jar)"
00:37:25 <kmc> i think the pitch with Clojure and Scala is largely that the code monkeys don't have to switch if they're not comfortable
00:38:17 <catenate> sounds right, have half a shop in Java the other half in Scala.  Like companies today who mix Java, JRuby, and Ruby.
00:39:15 <catenate> Ruby is a much, much better object-oriented language than Java will ever be.
00:39:46 <merijn> Clojure and Lisp aren't really functional languages IMO. They support functional languages better then a lot of other languages, but I wouldn't say that their main focus is functional programming. (Mind you, Clojure does seem more focused on immutability and functional constructs then classic Lisp)
00:39:50 <catenate> Ruby vs Scala I'm not qualified to judge
00:41:02 <etpace> is there a fromJustDefault or something? ie fromJD d m = maybe d id m
00:41:08 <kmc> :t fromMaybe
00:41:09 <lambdabot> forall a. a -> Maybe a -> a
00:41:17 <kmc> i'm not sure it's useful to draw that fine a line around "functional languages"
00:41:21 <kmc> ultimately it is just a style
00:41:30 <kmc> and not a style we use all the time, even in Haskell
00:42:16 <catenate> Ruby because of Rails is likely to be the most likely language to take Java's share of web developers.
00:42:33 <catenate> er, one less likely
00:42:45 <merijn> kmc: I know, but I meant that as a note that I don't think Clojure supports non-functional programming to accommodate people not wanting to switch but because Lisp's have traditionally not been focused solely on functional programming
00:43:10 <merijn> Hell, you can do functional programming in C no problem :)
00:43:46 <merijn> And the result can be quite pretty compared to the imperative C equivalent :p
00:43:55 <mlesniak> altough the compiler does not shout at you when you mix styles ;)
00:44:13 <catenate> I think a key win is just to stop making loop bodies.  Put that code into a function to reuse it.
00:45:01 <catenate> it's a short step from there to map, fold, whatever
00:47:44 <merijn> On a completely unrelated note, is it possible in haskell to serialize continuations?
00:47:44 <kmc> i wouldn't say "no problem"
00:47:50 <kmc> building closures is a pain in C
00:47:53 <ezyang> merijn: Maybe. 
00:48:06 <ezyang> merijn: GHC doesn't have built-in support, but there are some other compilers that support this. 
00:48:50 <kmc> yhc has some support for serializing function values
00:49:11 <kmc> and since Haskell has no support for first-class continuations (in any implementation i know of)
00:49:22 <kmc> your continuation would be an ordinary function value, via some kind of CPS transform
00:50:47 <merijn> I guess I should just download one of the web frameworks using continuations and examine their source instead of trying figure out how they work all by myself...
00:51:28 <ezyang> You'd be thinking of Oleg's DelimCC? 
00:55:33 <merijn> ezyang: Maybe? I've seen some people showing Smalltalk/Scheme code which implement state on top of HTTP using continuations. I've also seen some Haskell frameworks doing the same, but the Scheme version (and I think Smalltalk too) actually store the continuations on disk (since they're serializable) to save them across server restarts. I've seen Haskell frameworks claiming to work the same (minus maybe saving state across server restart) and
00:55:33 <merijn> just trying to figure out how exactly that'd work.
00:55:36 <merijn>  But I guess just looking at the source is more productive then asking increasingly cryptic questions here :p
01:03:26 <kmc> merijn, probably the Haskell frameworks have a more restricted notion of "continuation"
01:03:40 <kmc> but if it doesn't save across restart
01:03:49 <kmc> then it seems possible
01:04:00 <kmc> you can probably implement such a thing in ContT r IO
01:06:10 <Jonno_FTW> @src gcd
01:06:10 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
01:06:10 <lambdabot> gcd x y = gcd' (abs x) (abs y)
01:06:10 <lambdabot>    where gcd' a 0  =  a
01:06:10 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
01:06:33 <merijn> kmc: If you don't save across restart it's probably pretty simple to implement
01:56:34 <Starfire> kmc: Did you look at the library?
01:58:43 <kmc> Starfire, briefly
01:58:45 <kmc> it looks useful
01:59:07 <kmc> do you have any provision for working inside a State monad, or working with IORefs, MVars, etc?
01:59:15 <Starfire> Yes.
01:59:28 <Starfire> The <.#> operator is like .#, but works for any Functor.
01:59:42 <Starfire> So you could do stuff like foo <- takeMVar mv <.#> field
02:00:38 <Starfire> For MonadState, there are the <=: and <=~ operators, which are like regular =: and =~, but assign (or modify) the state.
02:02:35 <quicksilver> Starfire: which library is this?
02:03:07 <Starfire> quicksilver: My record field combinator library. http://github.com/AstraFIN/fields (Haddocks at http://www.niksula.hut.fi/~starfire/haskell/fields/)
02:03:25 <quicksilver> can you contrast to data.accessor or fclabels?
02:03:46 <Starfire> It builds additional functionality on top of fclabels.
02:04:19 <Starfire> Infix record field syntax and some combinators to compose fields together.
02:04:26 <quicksilver> you're wrong about method inlining, by the way.
02:04:34 <quicksilver> GHC does do method inlining by default.
02:04:41 <Starfire> Great!
02:05:19 <quicksilver> ghc doesn't do specialisation in the general sense
02:05:29 <quicksilver> but once code is inlined into a context where types are known
02:05:34 <quicksilver> then the dictionaries are eliminated
02:05:43 <quicksilver> so inlining is the gatekeeper of specialisation, as it were.
02:05:49 <Starfire> That sounds good.
02:06:03 <Starfire> For now, the library only supports fclabels, but it should be possible to support data.accessor and lenses also.
02:06:40 <quicksilver> is it really just an infix operator for getL?
02:06:56 <Starfire> Well, there is also stuff like multiple field access using tuples.
02:07:03 <Starfire> Like record .# (field1, field2, field3)
02:07:27 <Starfire> And direct support for Functors.
02:07:48 <Starfire> maybeRecord <.#> listField <#> subfield
02:08:36 * quicksilver nods
02:08:47 <quicksilver> I haven't actually used fclabels yet (I have my own cobbled together lens thing)
02:09:03 <quicksilver> but if I had noticed that fclabels didn't have infix syntax that would have marked against it IMO ;)
02:09:29 <quicksilver> data-accessor has infix syntax though.
02:09:29 <Starfire> Also, there's a utility function for pattern matching using ViewPatterns and a Data.Function.on analogue.
02:10:10 <Starfire> So you can do case record of (match (field1, field2) -> (3, v)) -> ...
02:10:24 <quicksilver> hmm that is interesting.
02:10:28 <Starfire> Or sortBy (compare `onField` field#subfield) records
02:10:53 * quicksilver nods
02:10:55 <Starfire> I also added support for directly indexing fields that are collections.
02:11:04 <Starfire> Like record .# mapField #! key
02:11:10 <Starfire> But I don't how useful that turns out to be.
02:11:47 <quicksilver> probably more elegant to have a combinator which turns a key into a field
02:12:49 <Starfire> That's what #! does.
02:13:08 <Starfire> It combines a collection and a key into a field accessing a Maybe Element
02:13:29 <Starfire> It also supports assignment, so you can add stuff into maps etc.
02:14:38 <Starfire> http://www.niksula.hut.fi/~starfire/haskell/fields/Data-Record-Field.html has short examples for most of the supported features.
02:16:04 * hackagebot SMTPClient 1.0.3 - A simple SMTP client library  http://hackage.haskell.org/package/SMTPClient-1.0.3 (StephenBlackheath)
02:19:54 <scoles> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28817#a28817  This code loads fine in ghci but when I run main ghci starts to print output but then stops and becomes unresponsive.
02:19:59 <quicksilver> Starfire: intuitively I feel your features should really be folded into fclabels; I *think* data-accessor already has most of what you're saying although perhaps not all.
02:20:00 <scoles> I don't see why I'm just doing some simple arithmetic really
02:20:35 <quicksilver> scoles: you'd defined h recursively
02:20:43 <quicksilver> h   | h*60 < 0
02:20:49 <quicksilver> presumably you meant h' there
02:21:06 <scoles> oops
02:21:25 <Starfire> quicksilver: Yeah, that would be fine.
02:21:27 <scoles> haha thanks :)
02:21:29 <quicksilver> Starfire: still, I need to spend some more time actually using this stuff to decide what interface I like.
02:21:40 <quicksilver> scoles: ghci hanging == accidental recursion quite often
02:21:47 <quicksilver> scoles: it's the first thing I check when someone complains of that.
02:21:59 <scoles> alright :) I've  never had it happen before I was quite puzzled
02:22:10 <quicksilver> Starfire: as you correctly point out it's really hard to get the precedences good enough for everything you might want.
02:22:11 <kmc> did you load with -Wall?
02:22:17 <Starfire> I initially intended to support all first-class label libraries, but I haven't used data-accessor myself so I don't know if it already implements the stuff I have.
02:22:40 <kmc> it can sometimes find these things
02:23:13 <Starfire> quicksilver: Yeah. Currently I have stuff at infixl 7, infixl 8 and infixr 9, which I felt resulted in best composability without parens.
02:48:17 <Paczesiowa> what's the best way to test if two libraries are equivalent? (I have no idea how to use quickcheck for that)
02:54:08 <gwern> Paczesiowa: you mean two functions?
02:54:22 <gwern> test x = function1 x == function2 x, I suppose
03:02:33 <Paczesiowa> gwern: those two functions would have to be in the same library
03:03:05 <ketil> Hm.  getCPUTime doesn't seem to have any reasonable resolution - any similarly simple way to measure time?
03:03:35 <Paczesiowa> ketil: check what criterion does
03:04:04 <exDM69> ketil: what kind of time do you want? wallclock time? monotonic?
03:04:35 <exDM69> ketil: http://hackage.haskell.org/package/clock  there's this one
03:04:55 <byorgey> Paczesiowa: eh? why?  Just import both.
03:06:10 <Paczesiowa> byorgey: this is the same function in the same namespace in the same package, only versions differ
03:07:13 <Saizan> PackageImport should work for those
03:08:25 <Paczesiowa> Saizan: it doesn't, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28819#a28819
03:08:40 <augur> so im watching http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem/
03:09:32 <augur> and i feel a bit dickish, because i want so desperately to point out that with a properly designed OO language (smalltalkish) you can do both things easily
03:10:16 <ketil> exDM69, hm.  I just use getClockTime and increase the size of my test case :-)
03:10:46 <Paczesiowa> augur: no, you cannot
03:10:58 <augur> Paczesiowa: uh?
03:11:19 <Paczesiowa> augur: try all you want, you still will not solve expression problem (that requires static typing) in smalltalk
03:11:41 <augur> class Array; def bind(&l); map { |x| l.call }.inject([]) { |a,b| a + B } end end
03:12:00 <augur> i dont know if that solves "The Expression Problem"
03:12:10 <augur> but it solves the problem this guy is talking about
03:12:14 <Saizan> Paczesiowa: mh, then it seems you'll need to make a wrapper lib for one of the two
03:12:29 <Paczesiowa> it doesn't. expression problem is defined for statically typed languages
03:12:32 <byorgey> Paczesiowa: oh, I see what you are saying.  what error does that code you pasted give?
03:13:01 <augur> Paczesiowa: ah, well. :) statically typed, yes.
03:13:04 <augur> thats obviously a problem.
03:13:05 <merijn> augur: Apples and oranges. The problem was obtaining that in a way that doesn't give up the safety of static typing
03:13:08 <Paczesiowa> byorgey: that it cannot load the interface for ...Parsec module because all versions are hidden
03:13:33 <Paczesiowa> byorgey: explicit -package arguments don't help
03:13:34 <byorgey> I see, that's unfortunate.
03:13:58 <augur> im sort of not sure why this is an issue tho in a statically typed OO language
03:14:10 <augur> adding new methods to a class doesn't change the type signature of the class
03:20:16 <gwern> Paczesiowa: you can always use the import-package extension to ghc, if this isn't production code
03:21:17 <Paczesiowa> gwern: it's just testsuite, I don't care if it crashes
03:21:19 <gwern> import the 2 versions qualified and that should be fine
03:21:36 <Paczesiowa> gwern: do you mean PackageImports? because that doesn't work
03:21:42 <gwern> why not?
03:21:44 <augur> Paczesiowa: how does dynamic class extension change the types of the objects involved?
03:23:00 <Paczesiowa> augur: I don't know about dynamic, but static (like in new C#) has the same problems like fp languages
03:23:13 <augur> im not sure i see how
03:23:22 <augur> an array is an array, new methods or not
03:23:24 <gwern> augur: if you extend a class, aren't you making a new type, most obviously?
03:23:34 <Paczesiowa> augur: FP has the problem, that if you add another variant to the data type, all your functions are broken
03:23:54 <Paczesiowa> augur: now just imagen class that is just a visitor pattern, you extend it, and all the code is broken
03:23:59 <augur> Paczesiowa: i suppose. i would have to really see quite how that would work tho..
03:24:00 <Paczesiowa> *imagine
03:24:07 <augur> im not thinking of visitor patterns tho
03:24:18 <augur> i see how those are a bad solution
03:24:27 <augur> but im thinking of a statically typed ruby or smalltalk
03:24:45 <Paczesiowa> how dare you?!
03:25:02 <augur> im a bold and daring person. :D
03:25:36 <augur> i mean, as far as i can tell, if i add a bind method to an array, its still an array
03:25:46 <merijn> augur: I started thinking about implementing a statically typed python kind of language but stopped when I realised I'd basically be implementing either Haskell or Lisp
03:25:50 <Paczesiowa> try using new (3.0 I thing) C# and creating that visitor pattern, and extend that class later and see what you get
03:26:05 <augur> i already said i think visitor patterns are a bad solution
03:26:14 <augur> so i dont understand why you'd repeating them to me.
03:26:18 <Paczesiowa> statically typed python doesn't sound like lisp
03:26:44 <kmc> if you use visitors, you have to change every visitor when you add a new data type.  if you don't, you have to change every data type when you add a new operation
03:26:53 <kmc> this is the difficulty
03:26:57 <yitz> just joined the channel. i was very perplexed at first by this discussion. there should be a channel rule to use the word "ooclass" whenever referring to OO-style classes and not Haskell-style typeclasses. :)
03:26:58 <augur> kmc: true, but
03:27:01 <augur> if i were doing this in ruby
03:27:06 <augur> it would all be in a single new file
03:27:08 <Paczesiowa> augur: it's not that they are a solution, they are an acceptable use of classes, if you allow such static class extending you break things
03:27:09 <kmc> whether visitors are a good or bad solution depends on how much you expect to change one vs the other
03:27:12 <augur> with only partial compilation
03:27:25 <kmc> imo injecting stuff into every existing class counts as "changing every data type"
03:27:38 <kmc> even if you do it in a new file
03:27:41 <augur> perhaps it is, but its still only partial compilation.
03:27:50 <augur> at least if you have dynamic dispatch
03:27:52 <kmc> what do you mean by partial compilation?
03:27:58 <Paczesiowa> kmc: it wouldn't break things unless you are using visitor pattern I think
03:27:59 <gwern> separate compilation, certes
03:28:15 <augur> yes, i should say separate compilation
03:28:22 <augur> assuming you're even compiling these things :p
03:28:35 <augur> obviously if you're running smalltalk theres no compilation
03:28:50 <augur> so strongtalk, say, would avoid the whole compilation problem entirely by simply not being compiled
03:29:01 <kmc> yeah but that doesn't solve the expression problem
03:29:04 <kmc> just one aspect of it
03:29:07 <gwern> (well, interpeted languages have a whole different set of benefits and problems than compiled languages)
03:29:22 <kmc> interpreters have a whole different set of benefits and problems than compilers
03:29:30 <augur> kmc: im not sure what aspect of the problem is left, tho
03:29:31 <Paczesiowa> how do I write this: "module TestVERSION where", so that I can modify it with -XCPP -DVERSION=2 ?
03:29:52 <augur> you can define new datatypes and new methods without recompiling existing code while retaining static type safety
03:30:00 <kmc> Paczesiowa, #define MODULE_NAME Test ## Version
03:30:15 <kmc> augur, but you still need to modify either every existing type or every existing method
03:30:24 <augur> but you're not modifying any type
03:30:28 <kmc> "modify" by runtime injection maybe
03:30:29 <augur> you're modifying the method lookup tables
03:30:39 <kmc> the lookup tables for every type
03:30:40 <Paczesiowa> kmc: is it documented in ghc docs?
03:30:46 <augur> kmc: yes, but not the types themselves
03:31:00 <kmc> Paczesiowa, no, that's a feature of the C preprocessor.  i'm not sure if it's even supported by GHC's builtin CPP
03:31:03 <augur> so your type checker will never notice anything has changed
03:31:24 <kmc> i have sometimes needed {-# OPTIONS_GHC -pgmP /usr/bin/cpp #-}
03:31:38 <kmc> Paczesiowa, the intent is that you then say Â«module MODULE_NAME whereÂ»
03:31:48 <Paczesiowa> kmc: it breaks on ##
03:32:14 <kmc> maybe it's Â«Test##VersionÂ»
03:32:20 <kmc> http://en.wikipedia.org/wiki/C_preprocessor#Token_concatenation
03:33:38 <augur> kmc: im still unsure why it matters whether or not you modify the lookup tables for all the relevant classes
03:34:20 <Paczesiowa> augur: because if you modify those tables, you break the old code
03:34:25 <augur> no you dont
03:34:37 <augur> no more than adding type classes breaks old haskell code
03:34:52 <augur> if i can go into haskell and add new type classes, and define List as a member of my new magic type class
03:35:01 <augur> without recompiling all my old code
03:35:21 <Paczesiowa> augur: once again, if you have a visitor pattern, you will break it
03:35:51 <augur> yes, but dynamic classes are not visitor patterns
03:36:26 <Paczesiowa> augur: so now you have to worry about what you are allowed to extend
03:36:38 <augur> in what sense
03:37:01 <Paczesiowa> augur: because you can't extend those visitors
03:37:10 <augur> what
03:37:16 <kmc> i think the augur's suggestion started with "don't use visitors"
03:37:29 <augur> kmc: "the augur"? :P
03:37:37 <kmc> heh sorry
03:37:49 <augur> well i certainly am /AN/ augur
03:37:59 <augur> and im the most contextually salient augur in this channel, i suspect
03:38:05 <augur> so i suppose that makes me THE augur
03:39:21 <augur> heres another thing
03:39:27 <augur> this guy says no casts
03:39:31 <augur> well ok
03:39:49 <augur> i dont need cases to check class membership
03:40:08 <augur> var c = that as Const; if (c != null) return c.info;
03:40:11 <augur> ofcourse this is nasty
03:40:12 <augur> but
03:40:22 <augur> case c; when Const then c.info; ... end
03:40:25 <augur> this has no cast
03:40:50 <augur> now granted, obviously you have to recompile this particular code every time you add a new method
03:41:01 <augur> bit you're not recompiling the entire codebase
03:41:14 <augur> er, every time you add a new class*
03:41:18 <augur> its this bit of code, plus the new classes
03:41:39 <augur> so its n+1 compile instead of n, which is a farsight better than n+m for m prior classes
03:42:26 <ketil> Is the scalability of a TArray really, really horrible?  I find that if I double the size, speed is reduced to about 15%, i.e. a factor or 6 or so.
03:42:43 <ketil> (Maybe I'm doing something wrong?)
03:42:44 <Paczesiowa> kmc: nevermind that token concatenation, what aboud using -DMODULE_NAME ?
03:43:22 <gwern> ketil: maybe you're hitting some kind of memory limit - forcing GCs or ceasing to fit in cache or something
03:44:00 <gwern> memory issues sound like they could explain a 6x fall. whaat does profiling say?
03:44:25 <augur> kmc: so yeah. i dont see where the type unsafety comes from. you're not changing the types.
03:46:10 <Paczesiowa> augur: maybe try to implement tha classic example of expressions?
03:46:35 <augur> would you like me to?
03:46:40 <augur> i'd be happy to. give me a moment.
03:47:04 <Paczesiowa> augur: there's a paper by Odersky that has nice examples
03:47:34 <augur> ill just use the example that lammel is using in this c9 video
03:48:02 <kmc> ketil, did you run with ./foo +RTS -s  to see % time spent in GC?
03:48:11 <ketil> gwern, I've run with +RTS -s, it's mostly MUT time.  There appears to be heavy lifting involved.  The same program using STArrays runs in negligible time.
03:48:14 <kmc> note that TArray is implemented currently as an Array of TVar
03:48:15 <Paczesiowa> augur: but I think that you will lose static safety, because if you extened a type with a method, without creating a new type, you lose info about objects, you don't know if they are extend or not
03:48:15 <ketil> kmc: see above
03:48:41 <augur> Paczesiowa: info about what methods a type responds to is not part of any non-dependent type system
03:48:42 * ketil worries that there are scalability issues with the number of TVars.
03:48:59 <augur> its like saying that a hash's keys constitute part of it's type.
03:49:15 <gwern> ketil: well, have you looked at the tvar src?
03:49:19 <ketil> ...and I want to have, well, a few million at least.  Currently, 100K is starting to hurt...
03:49:20 <gwern> ketil: also, what is MUT time?
03:49:23 <augur> or that the set of functions that take a type's instances as arguments constitutes part of that type
03:49:36 <ketil> gwern, no.  MUT is one of the categories from -s, as opposed to GC time.
03:49:49 <augur> sure, you "loose information", or rather, the information changes, Paczesiowa, but its not information that is relevant to static type checking.
03:49:57 <ketil> There's also INIT and EXIT times, both zero.
03:50:02 <ski> augur : O'Caml, object types consist of the messages (with types) the object responds to
03:50:16 <Paczesiowa> augur: what? in a static system you do know what methods object repsonds to, that's why you know when to signal compiler error
03:50:25 <augur> ski: thats fine, but that makes the O'Caml object types effectively dependent types
03:50:31 <ski> it does not
03:50:37 <augur> yes it does
03:50:44 <augur> it turns it from x :: Obj
03:50:49 <augur> to x :: Obj-that-responds-to-foo
03:50:57 <Saizan> ketil: are you doing something like trying to read the whole contents of the array in a single transaction?
03:51:02 <ski> it's just like record types, only supporting inheritance
03:51:05 <Paczesiowa> augur: static languages aren't retarded and have more types than Obj
03:51:29 <Paczesiowa> dynamic languages are languages with just one type
03:51:52 <ski> there's nothing dependent about O'Camls object types; types can't depend on values
03:51:56 <theorbtwo> Not really.  Dynamic languages are languages with a different take on the idea of types.
03:51:58 <augur> it was a standn-type Paczesiowa
03:52:01 <augur> this was obvious
03:52:21 <augur> ski: they depend on method names
03:52:24 <augur> or method ids
03:52:30 <augur> or method definitions
03:52:38 <augur> or method procedures in memory
03:52:41 <augur> or whatever you want
03:52:55 <ketil> Saizan, I guess.  Is that a bad idea? :-)
03:53:03 <augur> but its still dependent on a potentially varying set of methods as well as the object's class
03:53:09 <ketil> (I initialize it in a single transaction)
03:53:11 <Paczesiowa> augur: you think about types/classes as hashtables, that's just an implementation detail
03:53:20 <ketil> Saizan, and do an unsafeFreeze as well.
03:53:23 <augur> Paczesiowa: no, i DONt think about them that way, and thats the point
03:53:31 <augur> a class is NOT a lookup table
03:53:41 <augur> a class instance is NOT defined by the things it responds to
03:53:44 <Paczesiowa> augur: than I have no idea why do you say that classes in ocaml require dependent types
03:53:49 <augur> and hence the methods it responds to are NOT part of its type
03:54:09 <Saizan> ketil: if there are other transactions writing to it a transaction that tries to read all the elements is very likely to retry most of the time
03:54:24 <augur> if you add methods to the type, then it becomes dependent because you're not longer defining the type by some abstract carving up of the value landscape
03:54:42 <augur> you're instead defining it by the relationship that an object bares to a /particular method/
03:55:00 <Paczesiowa> augur: in structural typing, yes the methods define the type. in nominal typing, the set of methods is a prerequisite for the type
03:55:04 <ski> augur : just like you can have `foo :: (Int,String -> IO (),IO ())' in Haskell, so you can have `foo : < f : int; g : string -> unit; h : unit >' in O'Caml .. the difference is that with the records you refer to elements by labels `f',`g',`h', rather than by position ..
03:55:10 <augur> ofcourse that only matters when the method list can change
03:55:11 <ketil> Saizan, the whole thing is (currently) single threaded, so there should be no collisions.  To initialise, I do:   omap <- atomically $ (newListArray (0,n-1) [0..n-1] :: STM (TArray Object Int))
03:55:22 <ketil> (Object is just Int, too)
03:55:25 <augur> if it cant change, obviously the method list is part and parcel of the class definition and theres no effective difference
03:55:58 <Saizan> ketil: nvm then :)
03:56:08 <ski> augur : .. and the record types are extensible, which means that if you write a function (or method) which calls the `f' method on its argument, then you can pass any object to that function, provided that function (statically) has the `f' method (with compatible type)
03:56:09 <augur> ski: sure, but thats a dependent type!
03:56:09 <theorbtwo> If the method list can't change, then it's not a terribly dynamic language.
03:56:35 <ski> augur : where is the dependency from a *value* to a *type*, there ?
03:56:43 <ski> (hint, record labels are not values)
03:56:53 <augur> the value is the _name_ of the record label
03:56:57 <ski> no
03:57:05 <ski> you can't pass around record labels at run-time
03:57:12 <ski> there are such systems, dor sure
03:57:14 <augur> thats irrelevant
03:57:15 <ski> s/dor/for/
03:57:21 <augur> that doesnt make it not dependent
03:57:28 <ski> but O'Camls object system isn't such a system
03:57:28 <augur> that just makes it not dynamic
03:57:36 <augur> its a static dependently typed language
03:57:40 <ketil> Saizan, I've inserted print =<< getClockTime  around the various actions - it seems initializiation does take a bit of time.
03:57:46 <augur> but static and dynamic are separate from dependent types
03:57:48 <ketil> I'll check how it scales.
03:58:14 <ski> dependent is property of static type systems
03:58:18 <augur> no its not
03:58:27 <ski> dynamic types means another thing
03:58:39 <augur> its an abstract property entirely independent of static and dynamic typing
03:58:50 <augur> you can have static dependent types or dynamic dependent types
03:59:16 <theorbtwo> augur: What's the anytonym of dependent?
03:59:41 <augur> theorbtwo: enpendent :D
03:59:42 <ski> (one can for sure consider a (sortof) static type system for a dynamically typed language .. namely one in which one thinks and writes in comments about .. but it doesn't have that much to do with any run-time tag checking)
04:00:07 <augur> ski: if we were doing this in Martin-Lof's logic, it'd be the difference between whether or not all your values for your dependent types are there in the formula before any evaluation happens or not
04:00:21 <augur> well, any proof, since its a logic not a computation method
04:00:58 <ketil> Saizan, the newarray operation goes from 7 seconds for 50K array, to 50 seconds for a 100K array.  Similar for unsafeFreeze (5 to 30 seconds). 
04:01:31 <ski> augur : i'm not sure what you mean by "values for your dependent types are there in the formula"
04:02:19 <ketil> Running 50K transactions on these arrays went from 3 to 5 seconds, possibly within margin of error, and in any case no Big Deal.
04:02:29 <archguest> i am reading "the haskell school of expression" and i came across floating point calculations in chapter two and exercises. i get some really funny answers due to imprecise nature of these numbers and I was wondering if someone could recommend a guide (accessible to an average programmer) to working with floating point numbers in haskell or in general.
04:02:43 <ketil> Saizan, kmc, gwern: thanks for helping out!
04:03:03 <theorbtwo> ski: One can also consider that static typing is a (often flawed) attempt to optimize dynamic typing to happen at compile time.
04:03:13 <augur_> sorry about that, had a brownout
04:03:19 <gwern> ketil: that's quite an increase. one wonders what is going on under the hood - allocating a big array ought to be quick
04:03:25 <augur_> ski: in case it didnt get through:
04:03:25 <augur_> i can have a completely statically defined dependent type "All Hashes with the Key "foo"" or "All Lists of length 3"
04:03:41 <byorgey> archguest: my very short, accessible guide to working with floating point numbers: don't. ;)
04:03:59 <ketil> gwern, probably the transaction builds a log of TVars touched, and does something non-linear to it.
04:04:04 <theorbtwo> That is, when your compiler rejects your program as ill-typed because it cannot prove the bad things do not happen, it's a false positive.
04:04:14 <ski> augur : also, i'm still not sure what you mean by claiming that whether a something can be passed around at run-time is irrelevant to its value status
04:04:32 <byorgey> archguest: seriously, though, you might be interested in http://docs.sun.com/source/806-3568/ncg_goldberg.html
04:04:33 <augur_> now, whether or not something is a member of that type or not is ofcourse something that will be computed live, unless your program is simple enough to be fully type checked before hand
04:04:49 <augur_> but the type ITSELF is still a dependent type
04:04:54 <kmc> ketil, did you solve your problem?
04:05:02 <archguest> byorgey: thanks,i'm looking at that one now
04:05:03 <byorgey> archguest: although that might be more technical than what you are looking for.
04:05:17 <archguest> byorgey: unfortunately, it is :)
04:05:23 <ski> augur : yes, i agree "All Hashes with the Key \"foo\"" can be a dependent type, if you can express "All Hashes with the Key `x'", where `x' is an input to your function
04:05:38 <augur> i dont need it to be an input to a function tho
04:05:44 <ski> (or generally, `x' is any expression)
04:05:53 <kmc> augur, where do you have a type parametrized by a value?
04:05:56 <kmc> that is the simple question
04:06:01 <ski> right, it could be a literal, or an expression `"foo" ++ "bar"'
04:06:04 <augur> you see the 3 in there?
04:06:04 <archguest> byorgey: but i'll try anyway
04:06:09 <augur> 3 is a value, kmc
04:06:19 <kmc> augur, maybe, or maybe it's a type-level 3
04:06:20 <theorbtwo> ski: I don't think the "if" clause is neccessary.
04:06:40 <augur> kmc: perhaps, but the instances of that type dont have type-level 3's as their lengths
04:06:42 <ski> theorbtwo : why ?
04:06:43 <theorbtwo> Maybe your language is smart enough to do away with the arbitrary distinction in most cases.
04:06:49 <ketil> kmc: Identified, yes.  Solved?  Not so much. :-)
04:07:05 <augur> kmc: but like i said, its a moot point if your method lists are immutable
04:07:06 <theorbtwo> ski: Why is "all hashes with the key 'foo'" not a dependent type?
04:07:13 <augur> its only relevant in a language like ruby, where your method lists are mutable
04:07:18 <kmc> the problem is touching many TVars in one transaction?
04:07:33 <kmc> theorbtwo, it's not necessarily so if you have a literal 'foo'
04:07:39 <augur> and therefore your types do indeed become truly and properly dependent in all the relevant ways
04:07:42 <ski> theorbtwo : it is, if that `foo' can be any value (i.e. expression computing a value)
04:07:51 <theorbtwo> Again, why?
04:07:59 <theorbtwo> You are simply restating "that".
04:08:10 <augur> and yes, it is a dependent type, ski
04:08:14 <kmc> then you have a function of type:   { x : label } -> object having { x } -> ()
04:08:21 <kmc> note that x is bound then used in the type signature
04:08:27 <ski> augur : which were you talking about now ?
04:08:29 <kmc> but ocaml doesn't allow its record fields to be passed this way
04:08:30 <kmc> iirc
04:08:45 <augur> you saying hash-with-key-"foo" isnt dependent if "foo" is a constant
04:08:50 <ski> kmc : *nod*
04:09:06 <kmc> augur, if "foo" is a type
04:09:07 <augur> its a dependent type if the language you're using does not provide hash-with-key-"foo" as a pre-existing basic type
04:09:07 <theorbtwo> o'caml may not, but you were making a statement about dependent types, not about types in o'caml.
04:09:15 <augur> kmc: "foo" is a string
04:09:17 <ski> augur : no, i'm only saying it isn't dependent if "foo" *has* to be a literal there
04:09:30 <augur> even if it DOES have to be a literal there
04:09:37 <theorbtwo> ski: I understood what you are saying.  I do not understand why you are saying it.
04:09:38 <ski> right
04:09:39 <kmc> augur, "foo" is syntax ;P  it might stand for a string value, or a string type
04:09:44 <augur> its only independent of HashWithTheKey"Foo" is a type
04:09:57 <augur> that can only exist by creating a member of it explicitly
04:10:29 <augur> if i don't have to use a specially defined HashWithFoo constructor to create a hash with the key "foo", then its not an actual type in the system
04:10:39 <augur> h = {}; h["foo"] = 5
04:10:48 <augur> no constructors used to create HashWithFoo
04:10:48 <kmc> type inference?
04:10:49 <theorbtwo> s/actual/independent/
04:10:57 <kmc> you're making lots of unwarranted assumptions about the type system
04:10:58 <ski> theorbtwo : in every paper i've seen, and in every language i've seen that professes to have dependent types, the expression "dependent type" means that there is a dependency from a value to a type
04:10:59 <augur> nope, no type inference there
04:11:05 <augur> kmc: im just talking ruby here
04:11:12 <augur> or some strong version of ruby
04:11:25 <kmc> you don't need explicit constructors for records with structural subtyping
04:11:36 <augur> no, you dont
04:11:41 <augur> but if you dont have them, you're into Dependent Type land
04:11:42 <kmc> and that has nothing to do with dependent types
04:11:43 <kmc> nope
04:11:45 <augur> yep
04:11:50 <augur> thats how it is, kmc
04:11:54 <ski> theorbtwo : it might be that augur knows about some other system which professes to have what it calls dependent types, but i wouldn't say it has dependent types, in the sense of the word used in e.g. Agda2,Coq,Epigram,Twelf
04:12:01 <augur> the untyped and simply typed lambda calculi cannot do structural types.
04:12:09 <augur> ski: i know of Martin Lof.
04:12:17 <augur> which is _the_ dependent type logic.
04:12:22 <kmc> augur, so you're saying all structurally-subtyped languages are dependently typed?
04:12:26 <ski> yes, Martin-Löf type theory is a dependent type theory
04:12:40 <augur> kmc: a very simple kind of dependent typing, yes
04:12:48 <kmc> how is it "dependent"?
04:12:54 <kmc> where does a type depend on a value?
04:12:58 <kmc> field names aren't values
04:12:58 <augur> "foo"
04:13:03 <augur> it depends right there on a value
04:13:09 <augur> field names are indeed values, kmc
04:13:10 <kmc> no, once again, you are not allowed to pass field names as first class values
04:13:11 <augur> not in Haskell, perhaps
04:13:20 <augur> but if you formalize it into the lambda calculus they are
04:13:31 <kmc> you can say Â«h["foo"] = 3Â» but not Â«\x -> h[x] = 3Â»
04:13:44 <augur> first class ness doesnt make it not a value
04:13:55 <kmc> the staging restrictions are sufficient to lift them into the type system, maybe even invisibly
04:13:55 <augur> or non-first-class-ness rather
04:13:57 <augur> it just makes it not first class
04:13:58 <theorbtwo> kmc: In what language?
04:14:00 <augur> functions in C arent first class
04:14:03 <augur> but theyre still functions
04:14:24 <kmc> theorbtwo, a hypothetical non-dependently-typed language with extensible records
04:14:27 <kmc> which augur was using earlier
04:14:31 <kmc> except then said it was ruby
04:14:52 <ski> e.g. `compose : (f : (x : A) -> B x) -> ((x : A) -> (y : B x) -> C x y) -> ((x : A) -> C x (f x))' in Martin-Löf type theory (not using the exact concrete syntax in the book, since i don't recall it, the abstract syntax is the same) is a dependent type signature
04:14:56 <theorbtwo> kmc: Ruby is an example of a non-dependently-typed language with extensible records.
04:15:08 <augur> yes it is, ski
04:15:29 <kmc> theorbtwo, i would say ruby is dependently typed, though it's not very meaningful in a dynamically typed language
04:15:31 <augur> and if every time i use compose, i explicitly provide a NONCOMPUTED value for it to depend on
04:15:36 <augur> its STILL a dependent type signature
04:15:40 <quicksilver> dependent typing is not actually a property of a language.
04:15:46 <quicksilver> it is a property of a type system.
04:15:51 <quicksilver> (over a language)
04:16:03 <augur> yes but type systems are properties of languages for this discussion so shush :P
04:16:06 <Paczesiowa> quicksilver for the rescue!
04:16:14 <theorbtwo> Indeed, but mostly, one considers the type system that the language itself implements.
04:16:26 <quicksilver> languages don't implement type systems.
04:16:31 <quicksilver> type systems are a way of studying languages.
04:16:36 <ski> augur : it doesn't matter if the value is computed or not, what matters is that any expression (of appropriate type) is allowable for it
04:16:43 <quicksilver> for a given language, I can discuss two different ways of typing the terms in it
04:16:47 * hackagebot fields 0.1.0 - First-class record field combinators with infix  record field syntax.  http://hackage.haskell.org/package/fields-0.1.0 (JussiKnuuttila)
04:17:09 <quicksilver> there is a well-known way of typing haskell terms and it's so important that it's part of the haskell langauge definition.
04:17:09 <augur> ski: and in principle this is true of haskell as well, you just need to write the compiler in the appropriate way
04:17:14 <augur> but that would, of course, change the language
04:17:16 <quicksilver> there is no well-known way of typing ruby terms.
04:17:25 <quicksilver> so if we're talking about ruby we have to invent the type system as we go along
04:17:40 <augur> or ocaml, rather, since its ocaml that had the record type thing
04:17:48 <augur> that doesnt make ocaml not dependently typed
04:17:55 <quicksilver> trivially, I could say that for all expressions E in the ruby, the type of E, is E.
04:18:03 <augur> it just means ocaml's dependent types are HIGHLY restricted
04:18:08 <quicksilver> that is a dependent type system - all expressions can appear in types.
04:18:11 <quicksilver> but it's not a very interesting one.
04:18:48 <ski> (well, Haskell, in the Hugs incarnation has Trex, which is similar to the O'Caml system, except it's only extensible records, no inheritance, no instance variables, &c.)
04:18:49 <theorbtwo> quicksilver: Indeed, it is not, since it doesn't answer any of the questions that you go to a type system to answer.
04:18:50 <augur> quicksilver: it gets worse with the fact that each object is an instance of its own unique class like in smalltalk :)
04:19:08 <theorbtwo> Or, less obsurely, like javascript.
04:19:48 <quicksilver> in statically typed languages, you have the notion that the language checks the types at compile time, which means types matter.
04:20:06 <quicksilver> in some non-statically typed languages, some-kind of type checking is done at runtime.
04:20:16 <augur> ski: obviously in a language like ocaml or haskell, this sort of issue is incredibly minor. the extent to which its a dependent type is effectively nil, because you cant mutate data, changing its dependent type signature in the process. effectively, the literal expression { "foo" = 1 } _is_ a use of the HashWithFoo constructor
04:20:35 <augur> the issue comes up in languages like Ruby, where things like method lists are trivially mutable
04:20:55 * ski wonders what dependent types have with mutation to do ..
04:21:08 <quicksilver> theorbtwo: yes. Normally the property you want to check is "will this crash"
04:21:10 <augur> they dont have much in a language like haskell and ocaml
04:21:11 <augur> as i just said
04:21:18 <quicksilver> theorbtwo: (although there are lots of other things you might also be interested in)
04:21:18 <augur> because you can pretend like its not properly dependent
04:21:34 <augur> but if you DO have mutation, then you cant pretend that you've just got an infinite number of constructors
04:21:48 <augur> because something can be an instance of HashWithFoo one moment
04:21:51 <augur> and not the next
04:21:57 <augur> and then again the moment after that
04:22:27 <augur> and this is where the supposed static typing problem comes in
04:22:41 <augur> because you're defining your types by methods
04:23:10 <augur> and since the method lists change in ruby, this comes to your fully dependent type example
04:23:25 <augur> where the particular arguments to the dependent types are indeed live and computed
04:23:41 <augur> no longer are they they constants of record slot names
04:23:55 <augur> now they're lists of methods that vary depending on the ruby code you evaluated
04:24:29 <augur> and thus any static typing scheme that relies on ability to respond to some method or other is a full fledged dependent type system BY YOUR DEFINITION
04:25:21 <augur> which is the point: if you have a statically typed ruby, the only way that extension of the methods lookup table can corrupt the type system is if you allow methods to be part of the types, but that pushes the types into Martin Lof land
04:25:35 <augur> which is itself beyond the demands of the Expression Problem
04:26:48 <augur> tho im all for having method-dependent typing. its often the case in OO style that the crucial aspect of an object is whether or not it responds to some method, not whether or not its of some class
04:27:30 <augur> maybe that could be a new paradigm.. hyperduck typing. duck typed, but with type signatures to that end
04:30:22 <ketil> STM Update:  OK!  Reimplementing initialization and freezing to do a zillion transaction helps *a lot*.   STM is now about a factor of 2x from STArrays - which is pretty damned good, I think.
04:33:24 <ivanm> :o I thought grauenwolf on proggit proved that STM wasn't a serious contendor for concurrency! :p
04:33:49 <Zao> ivanm: Because *it:s are reputable sources of original research :D
04:33:55 <ski> augur : i'll grant that it probably (i'm not sure how it actually would be done) would be needed to reach for dependent types to be able to statically type something like the Ruby example you mention. what i fail to see is how this makes any type system which includes light-weight record types to be dependent
04:34:04 <ivanm> Zao: "*it:s" ?
04:34:47 <Zao> reddit, proggit, etc.
04:34:51 <augur> ski: if your record types are immutable key-value hashes, or rather, ones where only values are mutable, its not
04:34:52 <ivanm> ahhh, right
04:35:08 <ivanm> Zao: he went and posted a whole bunch of articles about people saying STM doesn't scale, etc.
04:35:14 <ivanm> as in actual academic papers
04:35:18 <augur> ski: but we were talking about whether or not a statically typed Ruby could solve the expression problem or not
04:35:54 <augur> i argued that since method lists are not part of the type signature (unless you have dependent types), then statically typed ruby would not have any shifting types when you extend with new methods
04:36:11 <augur> because an array before extension with bind is an array after
04:36:23 <augur> and therefore there is no problem with static typing
04:36:26 <ski> ski> augur : .. and the record types are extensible, which means that if you write a function (or method) which calls the `f' method on its argument, then you can pass any object to that function, provided that function (statically) has the `f' method (with compatible type)
04:36:31 <ski> augur> ski: sure, but thats a dependent type!
04:37:22 <augur> eh.. i might have been responding to something you said prior to that
04:37:35 <augur> infact i almost certainly was
04:37:49 <augur> but im too lazy to go back and verify this x3
04:37:50 <ketil> ivanm: there was a recent blog post about it ... planet haskell perhaps?
04:38:06 <ivanm> not that I recall
04:38:07 <ski> before, i said
04:38:08 <ski> ski> augur : just like you can have `foo :: (Int,String -> IO (),IO ())' in Haskell, so you can have `foo : < f : int; g : string -> unit; h : unit >' in O'Caml .. the difference is that with the records you refer to elements by labels `f',`g',`h', rather than by position ..
04:38:20 <augur> right, thats what i was responding to
04:38:26 <ski> and that's not a dependent type, in any description i've seen
04:38:34 <ski> (except now, from you, i.e.)
04:38:39 <augur> its only mildly dependent
04:38:50 <ketil> ivanm, anyway - I've only seen them prove that *they* can't effectively use STM, not that it can't be done.
04:39:17 <ivanm> right
04:39:30 <ski> there is no dependency .. the record/object types there act as what you phrased "immutable key-value hashes, or rather, ones where only values are mutable", which you claimed would not be dependent
04:40:00 <ski> i.e. each object has a fixed set of methods/fields it responds to/has
04:40:31 <augur> ski: like i said before, in a language like ocaml or haskell, you can fudge a non-dependent interpretation
04:40:52 <ski> it can't be changed at run-time, and you can't pass method/field names around, you must already know, by the static type, that it has method/field named `f' to be able to refer to it
04:41:23 <augur> right, so i concede that its not properly dependent
04:41:24 <ski> (so `f' is literal in the type, it can't be any expression which would stand for a name/key at run-time)
04:41:48 <augur> but the issue is about Ruby and other languages with mutability
04:42:37 <augur> ski: the way you would have to fudge it to make it not actually dependently typed is something like this:
04:43:16 <augur> the constructor for RecordWithFoo is any record literal <... f: ...>
04:43:36 <augur> foo:**
04:43:42 <augur> or any record name for a record defined to have foo as a record slot
04:43:54 <kamatsu> for one of my university courses, I have to write code in Promela. Promela is an okay language, except that it's syntax is some garbage mix of C and prolog
04:43:55 <ski> augur : ok. i'm ok with it being possibly to overlay a dependent interpretation on it. i'm just claiming that that isn't necessary (and is not typically done, e.g. because O'Camls type system doesn't support the machinery of a dependent type system, so it wouldn't make sense for them to think of the object types as wealy dependent) .. and hance i would not call its type system dependent
04:44:06 <augur> thus you have an infinite number of constructors for RecordWithFoo, and so its "technically" not dependently typed
04:44:07 <augur> fine
04:44:22 <augur> but this is not the case with mutable data structures like hashes in ruby
04:44:38 <augur> where the "constructors" are any program that leads to the relevant key being set
04:44:57 <ski> augur : as i admitted, it's quite possible that you can't model the behaviour of Ruby closely without (actually) dependent types :)
04:45:03 <kamatsu> if i want to write a language really quick, which is little more than a bunch of syntactic shortcuts, that translates to promela, what is the best haskell library or combination of libraries to use
04:45:04 <augur> sure you can
04:45:20 <augur> because ruby doesnt use method lists in its type signatures!
04:45:22 <ski> well, of course it depends on what you mean by "closely" :)
04:45:27 <augur> well, it doesnt have type signatures, but
04:45:42 <augur> you can have a statically typed ruby that ignores method lists
04:45:49 <augur> that just makes it class-typed
04:45:50 <augur> so what
04:45:54 <augur> its still static
04:46:09 <augur> its as static as haskell
04:46:21 <ski> i mean trying to add "something like message lists" in the type system, but somehow make sure that it respects the mutability of what messages an object can respond to
04:46:28 <augur> oh, well
04:46:31 <ketil> by the way - are there any MArray impelementation using MVars (like TArray uses TVars)?  I guess I could cook it up myself easily enough, but that'd be a fairer comparison than STArrays, I think.
04:46:52 <augur> but the point is that you dont HAVE to add message lists to the type system to preserve the kind of static typing that the Expression Problem seeks to preserve
04:47:04 <augur> the Expression Problem is defined on haskell-like type systems
04:47:21 <ski> augur : what you're describing is (i think) something other that what i had in mind by "closely" ;) .. not saying that your idea would not be interesting
04:47:24 <augur> non-dependently typed, often non-higher-order type systems
04:48:01 <augur> so a strongly typed Smalltalk or Ruby _IS_ a solution to the expression problem
04:49:24 <augur> infact, any language with dynamic function lookup will be a solution
04:49:45 <augur> so long as you can update lookup tables at runtime
04:50:13 <augur> also, so long as you can do dynamic subtyping
04:50:27 <augur> well, not dynamic but runtime subtyping
04:50:39 <ski> (btw, i'm not sure why you talk about constructors for records (or maybe you mean "constructor" in e.g. Java sense ?) .. in my view, variant types / algebraic data types have constructors, and then one can pattern-match on them in operations; while record types have selectors/deconstructors/projections/methods/fields, and operations may be defined to return records by "message-dispatching")
04:51:05 <augur> ski: just because constructors make it easy to see how you _can_ pretend like its not dependent
04:51:20 <ski> augur : btw, i wasn't commenting on the expression problem per se, only your use of "dependent"
04:52:40 <augur> also, im still not sure that you can actually qualify ocaml as properly independent, given that there is no way to generically have a record type like that without covertly having dependent computations
04:52:41 <augur> i mean
04:52:56 <augur> i think if you have to have an infinite number of constructors
04:53:04 <kmc> kamatsu, ah, promela :)
04:53:11 <augur> or you have to have some type checker that can compute for an arbitrary number of new types whether or not they
04:53:14 <kmc> i had fun in the course i took using Spin
04:53:18 <kmc> but the syntax is pretty bad
04:53:20 <augur> they're subclasses of a given type
04:53:30 <augur> not _lookup_ whether this is so, but compute it dynamically
04:53:52 <augur> at compile time.. i think that qualifies as dependently typed in the purest sense
04:54:00 <kmc> kamatsu, maybe you can get by with a macro preprocessor like M4
04:54:07 <augur> but not in the really important sense
04:54:10 <rfh> from birds book introduction to fb using haskell, cant make a concept of how to solve the problem: how many binary trees are there of size five? write a program to calculate the number of binary trees of size n for given n.  some code for starting: http://pastebin.com/NJVBakN0
04:54:24 <augur> rfh size five what
04:54:28 <augur> five non-terminal nodes?
04:54:31 <augur> five terminal nodes?
04:54:34 <augur> five nodes total?
04:54:41 <augur> of depth five?
04:54:58 <kmc> kamatsu, but if you want to write a parser for your language, parsec and uu-parsinglib are popular
04:54:59 <rfh> augur: http://pastebin.com/NJVBakN0
04:55:16 <augur> aha, so the number of terminal nodes
04:55:19 <kmc> kamatsu, and if you want to write an AST type and pretty-printing library for Promela, we'd love to have it on hackage
04:55:40 <rfh> augur: yeah, or leafs
04:56:01 <augur> i believe its something like
04:56:02 <ski> augur : O'Caml has type erasure, there's no type computations at run-time. e.g. one can't dynamically check whether an object that has type `< get_x : int; set_x : int -> unit >' actually has type  `< get_x : int; set_x : int -> unit; get_y : int; set_y : int -> unit >'
04:56:16 <augur> permutations n-1
04:56:51 <augur> ski: no what i mean is that if you have some type signature <f:int, ...>
04:57:15 <augur> there could be an arbitrary number of distinct concrete record types that subtype that
04:57:34 <augur> so if i have say
04:57:53 <augur> foo : <f:int> -> int
04:58:09 <ski> augur : i don't follow what constructors (do you mean like object constructors in Java or like data constructors in Haskell or other ?) has to do with pretending the system is not dependent
04:58:25 <augur> and something like record X = X f:int
04:58:39 <augur> i can do foo (X 1)
04:58:56 <augur> (excuse the haskellish, i dont know ocaml at all)
04:59:12 <augur> and since (X 1) is a record like <f:int>, its a valid argument to foo
04:59:25 <ski> ok, sure there's infinitely many subtypes of `<f:int, ...>', yes
04:59:39 <augur> but i never explicitly said that X is a subtype of <f:int> except by inference over the record definitions
04:59:45 <augur> which i suppose is _fine_
04:59:52 <augur> but i dont know if thats strictly non-dependent
05:00:18 <augur> since the type hierarchy is not explicitely defined
05:00:33 <augur> and it would get worse if you dont require filly specified record type signatures
05:00:42 <ski> augur : btw, do you feel O'Camls polymorphic/light-weight variants is dependent, as well ?
05:00:48 <augur> e.g. if you can say "any record with an f field"
05:00:59 <augur> instead of "any record with only the f field"
05:01:06 <kamatsu> kmc: okay, thanks for the pointers.
05:01:32 <augur> ski: i dont know shit about ocaml so i dont know what polymorphic/light-weight variants are :)
05:02:26 <Associat0r> open sum types
05:03:14 <augur> also, ski, in martin-lof, the only way to do something like list-length types is (Sx : len x == 3)y
05:03:55 <augur> which is a dependent type signature
05:04:03 <augur> theres no pi type way of doing that
05:04:47 <augur> or no sorry, im forgetting his notation
05:05:01 <augur> its supposed to be a Pi type, not a Sigma type
05:05:32 <augur> theres no Pi type without non-type functions in the condition
05:06:02 <ski> in O'Caml,  [> `A | `B of int | `C of int list ]  is the type of values that can at least be of the forms  `A  ,  `B n  ,  `C ns  for `int's `n' and `int list's `ns'
05:06:12 <augur> obviously if you _only_ allowed list-length types above and beyond simply typed LC, then that's different
05:06:40 <augur> eh
05:06:48 <augur> i think thats a union type
05:07:01 <augur> well, a combination polymorphic type and union type
05:07:20 <ski> so, if you have a function that takes a value of that type as input, you have to be able to handle all those three constructors, as well as any other constructors which might come along (typically either by doing some default action, or by delegating to some other function)
05:07:41 <augur> data That = A | forall b.b Int | forall c.c [Int]
05:08:10 <augur> or whatever. i think im missing the point of the `'s :p
05:08:38 <augur> ski: yes, you do have to handle multiple constructors, but its a different sort of multiple-constructor handling
05:08:46 <ski> the  `A  ,  `B  ,  `C  here corresponds to `A',`B',`C' in Haskell `data Foo = A | B Int | C [Int]', except that you don't define a type `Foo' like this
05:08:53 <augur> aha ok
05:09:00 <ski> you just use whatever constructors you want
05:09:31 <augur> anyway, its different because the hierarchical relationship between the types is explicitly defined beforehand
05:10:19 <ski> similarly to how with the record system you don't (need to) name object types, they're structural .. if a functions wants an object that supports methods `f' and `g', you can pass any old object which has methods of those names to it (provided the types of the arguments and result of the methods in the object type also match)
05:10:27 <augur> but im not _actually_ sure whether or not this property of the record types thing pushes it out of independently typed land
05:10:29 <augur> it might not
05:11:02 <augur> you might indeed be able to fudge the constructors and treat it like a polymorphic type
05:11:16 <ski> so, e.g. in Haskell you might want to define
05:11:18 <augur> eh.. im not sure tho because you get multiple type signatures then
05:11:39 <ski>   data NonEmptyTree = Leaf Foo
05:11:54 <ski>                     | Branch NonEmptyTree NonEmptyTree
05:12:02 <ski>   data Tree = Empty
05:12:08 <augur> e.g. <f = 1, g = "xyz"> is both <f:Int, ...> and <g:String, ...> and <f:Int, g:String, ...> and the non-underspecified versions thereof
05:12:11 <ski>             | NonEmpty NonEmptyTree
05:12:31 <ski> here it is a bit irritating that you have to wrap an extra `NonEmpty' constructor
05:12:33 <augur> sorry for ruining your code x3
05:12:36 <aristid> what is more fashionable? Data.Projectname or just Projectname?
05:13:20 <aristid> or something else?
05:13:29 <augur> ski: yes, you might well be right, <f:Int> might indeed just be a convenient shorthand for F0 | F1 | ...
05:13:39 <ski> with polymorphic variants in O'Caml you'd just use (i.e. match as well as call)  `Leaf  and  `Branch  in the functions that only accept non-empty trees; while using both those as well as  `Empty  in the functions that should also handle non-empty trees
05:13:50 <augur> but the problem is that the disjoints are computed at compile time
05:13:54 <ski> the type system will make sure you don't pass an empty tree to a function that doesn't expect it
05:14:11 <augur> whereas in Leaf a | Branch a, there is not computation required
05:14:26 <augur> we know exactly what counts as a Tree a at all points
05:14:35 <augur> even if we had type operators we would still know
05:14:46 <augur> the type A|B is fully specified prior to compilation
05:14:50 <augur> whereas the type <f:Int> is not
05:15:16 <augur> what counts as an <f:Int> depends on what code exists defining subtypes of <f:Int>
05:15:23 <ski> by `A|B' you mean something like `Either A B' in Haskell ?
05:15:34 <augur> if Either is a type operator, then sure
05:15:39 <augur> its the union type
05:15:47 <ski> or something like  [`A of a | `B of b]  in O'Caml ?
05:15:58 <ski> union or disjoint union ?
05:16:03 <augur> union
05:16:41 <augur> you could make it disjoint union in this particular case, unless you have underspecified record types
05:16:59 <augur> in ocaml, does <f:Int> only match the records with exactly one field: f?
05:17:05 <augur> or does it match any record with a field f
05:17:10 <ski> so if two values in `A' and `B' have identical representations / comes from some common type `C', then they won't be different, as values in `A | B' ?
05:17:33 <augur> ski: they might be different values, but they're still in A|B
05:17:54 <augur> type systems are not case disambiguation systems
05:18:14 <augur> types are just sets of members
05:18:19 <augur> at least denotationally
05:18:31 <ski> augur : `< f : int >' is the type of objects with exactly the *known* (at this point in the program) methods : `f', taking no parameters, and returning an `int' 
05:18:55 <augur> so does <f:Int> also admit of something of type <f:Int,g:String>?
05:20:12 <augur> i mean, supposing that the presence or absence of g was unknown at compile time for some reason
05:20:17 <augur> but the presence of f was known
05:20:38 <augur> could you apply some function foo:<f:int>->int to something that has both f and g?
05:21:05 * hackagebot svgutils 0.1 - Helper functions for dealing with SVG files  http://hackage.haskell.org/package/svgutils-0.1 (NeilBrown)
05:22:51 <ski> yes, you can "convert" (no-op) an object of type `< f:int; g : string >' into the type `< f : int >'
05:23:34 <ski> but then you can only access the `f' method (through this reference to the object .. the `f' method can of course still be defined in terms of `g')
05:23:48 <ski> if you want to express a "functional update"
05:24:01 <ski>   update_f : < f : int > -> < f : int >
05:24:34 <augur> ok
05:24:48 <augur> so then these are indeed not dependent types, you're correct
05:25:01 <augur> they're tagged intersection types
05:25:09 <ski> then that is not good, since if you pass an object supporting both `f' and `g' to `update_f', and it constructs a copy of the object with all methods the same, except that `f' has been replaced by a new definition
05:25:39 <ski> that doesn't do you much good, since the returned "functional update" doesn't statically express that it actually also supports the `g' method
05:26:01 <ski> so, what you do is you say
05:26:19 <ski>   update_f : < f : int ; .. > as 'o -> 'o
05:26:30 <ski> this would be similar to saying
05:26:51 <ski>   update_f : forall r. < f : int | r > -> < f : int | r >
05:27:05 <ski> (but O'Caml doesn't write the concrete syntax that way)
05:27:52 <ski> meaning that for any "row" `r' for method types you want, if you pass an object which supports all methods in `r' as well as the `f' one, the function will return an object supporting all the methods in `r' as well as the `f' method
05:27:57 <ski> so, e.g.
05:28:06 <ski>   update_f : < f : int > -> < f : int >
05:28:13 <ski> is an instance of this type signature
05:28:14 <ski> as is
05:28:21 <ski>   update_f : < f : int; g : string > -> < f : int; g : string >
05:28:52 <kmc> does that parse as Â«update_f : (< f : int; .. > as 'o) -> 'oÂ» ?
05:29:10 <ski> yes
05:29:27 <kmc> that's cool, local aliases in types
05:29:31 <ski> think of `as' as (flipped) `@' .. or sortof like a `where' in types
05:29:32 <kmc> would be useful in Haskell
05:31:05 <ski> augur : (just making sure we're on the same page) re `A | B', say that `A' contains `0',`1',`2' and `B' contains `0',`-1',`-2' .. then `A | B' contains five values, yes ?
05:32:09 * hackagebot AC-Vector 2.2.0 - Efficient geometric vectors and transformations.  http://hackage.haskell.org/package/AC-Vector-2.2.0 (AndrewCoppin)
05:36:31 <ski> augur : anyway. glad you agree about the dependentness of light-weight record types
05:36:53 <ski> (sorry for being a bit slow on response. i should probably go get some sleep)
05:36:58 <kmc> which is that they aren't dependent?
05:37:12 <ski> yes
05:37:19 <kmc> also, what makes them lightweight, and was anything in CS or software engineering ever described by its creators as "heavyweight"?
05:37:34 <merijn> C++? :p
05:37:45 <kmc> perhaps "industrial strength" is a euphemism for "heavyweight"... too bad for parsec then
05:38:10 <exDM69> kmc: enterprise is the marketing term for "heavyweight"
05:38:28 <merijn> I thought Enterprise was marketing for "sucky"
05:38:41 <augur> dependentlessness :p
05:39:02 <ski> well, i've seen the term light-weight used for systems with structural rather than nominal typing for the records (or similarly for variants / algebraic data types) .. i.e. you don't declare the types, you just use the constructions, with any names (variant constructors or record fields) that strikes your fancy
05:39:22 <augur> ski: dont worry, this is just a case of antonyms not being transparent :)
05:39:39 <augur> there are lots of cases in english where antonymy is not a matter of negation or opposites
05:40:05 <kmc> ah
05:40:19 <augur> for instance, "heavy" and "weighty" are arguably synonyms
05:40:25 <ski> one could say that tuples are light-weight in this sense, in Haskell .. you don't define the tuple types  (but i guess one can interpret it as infinitely many predefined heavy-weight types for you .. but you need a uniform syntax for that to work)
05:40:25 <augur> but the antonym of "heavy" is "light"
05:40:29 <kmc> what happens if you reuse variant constructor names in different parts of the program?
05:40:32 <augur> but the antonym of "weighty" is weightless
05:40:32 <Associat0r> maybe lightweight because they are inferred
05:40:38 <augur> and light and weightless are not synonyms
05:40:47 <augur> so the antonyms of synonyms are not necessarily synonyms
05:40:52 <kmc> is a lw variant type signature a local binding occurrence of its ctor names?
05:41:24 <augur> similarly, the antonym of a morphologically complex word is not necessarily the similarly morpologically complex version of the antonym of the morphologically simpler version
05:41:37 <aristid> @quote freebsd
05:41:37 <lambdabot> NIXDAEMON-COOL says: how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
05:41:47 <Associat0r> I think SML could infer records and OCaml infer variants
05:41:51 <augur> that is, the antonym of "light-weight" is not necessarilly the "-weight" version of the antonym of "light"
05:42:07 <ski> kmc : no problem. (similar to Prolog atoms or Lisp symbols)
05:42:17 <augur> ski: thus ends your lesson in lexical semantics for the day x3
05:43:28 <ski> kmc : if you say  `A "foo" in one part of the program and  `A (32,[sin,cos])  in another  then in the first case you will get a type like  [`A of string | ...]  while in the second case you will get a type like  [`A of int * (double -> double) list]
05:44:28 <kmc> right
05:45:01 <ski> kmc : afaik, the names of the constructors (of polymorphic variants, as opposed to ordinary heavy-weight variant types) are global in O'Caml, i.e. you can't e.g. rename them on import or export from a module
05:46:11 <ski> (it might be nicer if one could rename them at will, and thus gain greater control of which parts of two polymorphic variant types should be merged, when taking their "union" .. but it's probably more complicated to implement, as well)
05:48:14 <ski> augur : ok (but iirc i've seen "heavy-weight" in this context as well :)
05:48:20 <augur> im sure :p
05:48:27 <augur> words can have multiple meanings :p
05:48:45 <augur> in this case it obviously comes from the two different aspects of heavy-weight boxers
05:48:55 <augur> a) they're big brutes who can take a lot of punishment without flinching
05:49:11 <augur> and b) they're big brutes who lumber around slowly
06:33:46 <mornfall> Anyone knows how to make the ghci prompt ... smaller? When I load a couple modules it doesn't fit the screen width...
06:34:04 <mornfall> Ah. :set prompt... now if it could *abbreviate* it instead...
06:34:23 <dobblego> mornfall, I use :set prompt ">> " in ~/.ghci
06:52:35 * hackagebot AC-Vector-Fancy 2.2.0 - Fancy type-system stuff for AC-Vector  http://hackage.haskell.org/package/AC-Vector-Fancy-2.2.0 (AndrewCoppin)
07:02:43 <acowley> Can someone give me a hand with some type-level silliness? http://haskell.pastebin.com/w1tSPPau
07:03:09 <acowley> I'd like to structure things so that test2 type checks
07:03:29 <acowley> But I can't seem to write the Geq class correctly
07:04:34 <acowley> Naively, equality constraints in the context of Geq instances would do what I want, but I don't think they are used when looking up instances
07:11:01 <hpc> @pl \x y -> succ $ foldl (+) x y
07:11:01 <lambdabot> (succ .) . foldl (+)
07:11:15 <hpc> bleh
07:14:51 <zygoloid> instance Geq a c => Geq (Max a b) c where type G (Max a b) c = True
07:15:00 <zygoloid> acowley: ^^ try something like that maybe
07:15:15 <acowley> zygoloid: I did, but it doesn't work right
07:15:46 <zygoloid> acowley: what went wrong?
07:15:55 <acowley> zygoloid: One second, I'm trying it again :)
07:16:25 <acowley> zygoloid: it lets you type check things like http://haskell.pastebin.com/w1tSPPau
07:16:27 <zygoloid> looks like there'll be massive instance overlap problems
07:16:27 <acowley> zygoloid: ack
07:16:37 <acowley> zygoloid: test2 = undefined :: G (Max a (Max b c)) d
07:17:01 <acowley> zygoloid: it will accept that, because it matches the instance based on Geq (Max a b) c without looking at the constraint
07:18:00 <zygoloid> it should match the instance, and add (Geq a d) to the context
07:18:41 * hackagebot regex-pderiv 0.0.8 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pderiv-0.0.8 (KennyLu)
07:18:52 <acowley> zygoloid: Right, but that ends up being discharged somehow
07:19:23 <acowley> zygoloid: Perhaps by unifying a with d
07:19:47 <zygoloid> "instance (Or (G a c) (G b c) ~ True) => Geq (Max a b) c" should hopefully sort out the symmetry problem
07:20:01 <acowley> zygoloid: That was my original approach (hence the Or business)
07:20:12 <acowley> zygoloid: That's also why I needed Undecidable instances
07:20:27 <acowley> zygoloid: because otherwise GHC complains about c appearing more in the context than on the right
07:20:54 <acowley> zygoloid: But the addition to the context isn't working the way I want it to
07:22:43 * hackagebot regex-pderiv 0.0.8.1 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pderiv-0.0.8.1 (KennyLu)
07:22:49 <acowley> zygoloid: interestingly, if you comment out all Geq instances other than the one you just pasted, the bad example "G (Max a (Max b c)) d" still type checks
07:23:01 <acowley> zygoloid: So the context just isn't being forced
07:25:37 <acowley> zygoloid: Hmm. If the big instance for Geq (Max a b) c says "type G (Max a b) c = Or (G a c) (G b c)" then there is a conflicting instance with the identity instance G a a
07:25:53 <acowley> So how to encode the identity without conflict?
07:26:03 <acowley> err, not identity, reflexivity
07:31:55 <acowley> zygoloid: I may have something
07:33:36 <zygoloid> acowley: maybe it'd be easier if you worked in terms of less than?
07:34:42 <acowley> zygoloid: This seems to work http://haskell.pastebin.com/FRYs1HHA
07:34:59 <acowley> zygoloid: I will have a Leq relation that works with Min as well
07:36:39 <acowley> zygoloid: Min and Leq seem to work now, too
07:37:13 <zygoloid> ah right, i guess associated types don't actually care about the instance context
07:37:19 <acowley> zygoloid: Although I'm not 100% confident that things are really working; I'm not sure how to test this thoroughly.
07:37:28 <zygoloid> (their overlap checks can't care)
07:38:49 <zygoloid> i don't think you have enough to show that (G a b ~ True) => G (Max a c) (Max b c) is True
07:39:27 <acowley> zygoloid: You're right
07:40:38 <zygoloid> incidentally i'm considering adopting something like your approach for this: http://control.monad.st/repos/hades/file/94bf7727871d/hades-lib/Hades/Struct/Ways.hs
07:41:50 <acowley> What is that for?
07:42:38 <zygoloid> type-level representation of a GHC setup, as part of my debugger
07:43:14 <acowley> Ah, interesting. So you use the types to pick a path through the debugging code?
07:43:42 <tafryn> I have a GHC.Int.Int32 and want an Int. How do I convert the former to the latter?
07:43:43 <zygoloid> yeah. the types select which code to run, and are also used to statically check that i've covered all the supported setups
07:43:56 <acowley> tafryn: fromIntegral
07:43:57 <zygoloid> tafryn: fromIntegral
07:44:13 <tafryn> Thanks to you both.
07:44:19 <acowley> zygoloid: very cool
07:44:19 <zygoloid> @quote fromIntegral
07:44:19 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
07:44:23 <zygoloid> @quote fromIntegral
07:44:23 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
07:44:32 <zygoloid> where's the ghostbusters one?
07:44:39 <zygoloid> @quote monochrom fromIntegral
07:44:40 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
07:45:15 <acowley> I have "where fi = fromIntegral" in a lot of my code :/
07:45:38 <zygoloid> acowley: it's been good fun so far, but i think i'm approaching the point where i'm going to need to make GHC produce debug symbols :o
07:45:50 <FunctorSalad> acowley: that should be in the standard libs
07:46:05 <hpc> @pl \x -> f >>= g x
07:46:06 <lambdabot> (f >>=) . g
07:46:15 <zygoloid> @let fi = fromIntegral
07:46:16 <lambdabot>  Defined.
07:46:33 <hpc> @let fe = fromEnum
07:46:34 <lambdabot>  Defined.
07:46:39 <acowley> FunctorSalad: To be honest I don't even export that definition in my own code because it's too cryptic
07:46:53 <tafryn> So what would fo and fum be?
07:47:14 <acowley> fromOrd
07:47:32 <hpc> fromUnsafeMissileSilo
07:47:41 <acowley> fromUsersMind?
07:47:55 <FunctorSalad> acowley: IMHO, for very-common items, the gain in brevity is woth the loss in descriptiveness
07:47:59 <aristid> :t \x -> f >>= g x
07:48:00 <lambdabot> forall t (m :: * -> *) a b. (SimpleReflect.FromExpr (m a), SimpleReflect.FromExpr (t -> a -> m b), Monad m) => t -> m b
07:48:07 <aristid> :t \f g x -> f >>= g x
07:48:07 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => m a -> (t -> a -> m b) -> t -> m b
07:48:20 <zygoloid> > map (\n -> if n > 0 then n + 1 else ($n) fi) [-5..5]
07:48:21 <lambdabot>   [-5,-4,-3,-2,-1,0,2,3,4,5,6]
07:48:43 <FunctorSalad> we have fmap instead of functorMap too after all
07:48:49 * hackagebot CheatSheet 2.7 - A Haskell cheat sheet in PDF and literate formats.  http://hackage.haskell.org/package/CheatSheet-2.7 (JustinBailey)
07:48:58 <zygoloid> > map (ap (+) (fromEnum . (>0))) [-5..5]
07:48:59 <lambdabot>   [-5,-4,-3,-2,-1,0,2,3,4,5,6]
07:49:10 <acowley> FunctorSalad: I agree. It's just that "fi" seems a particularly poor name since it has historically been used to close if blocks, etc.
07:49:21 <acowley> fmap at least looks like a map
07:49:25 <hpc> acowley: only in crappy languages
07:49:32 <acowley> fint might be better?
07:49:38 <zygoloid> class Cast a b where cast :: a -> b ?
07:49:45 <acowley> to at least suggest it has something to do with "int"
07:49:55 <acowley> zygoloid: Now that I like! :P
07:50:09 <FunctorSalad> acowley: hmm, point
07:50:16 <FunctorSalad> (the 'if' blocks)
07:50:30 <FunctorSalad> (but... we have `return' too :) j/k)
07:50:37 <kmc> instance Cast a b where cast = unsafeCoerce#
07:50:38 <kmc> problem solved
07:50:56 <hpc> you are a bad person and should feel bad :D
07:51:01 <kmc> haha
07:52:15 <acowley> zygoloid: I think my approach to this type family stuff is running out of steam. Not only due to the shortcoming you pointed out, but if I want any other data types to take part in the Leq or Geq relations then I smack into conflicting instances.
07:52:26 <FunctorSalad> i2n ;)
07:53:30 * kmc amuses himself by pronouncing "Leq" and "Geq" as words
07:53:57 <FunctorSalad> like 'lack' and 'gack'?
07:54:10 <kmc> not quite
07:54:12 <acowley> I say "leak" and "geek"
07:54:28 <kmc> lek and gek maybe
07:54:59 <hpc> "less-equal" "greater-equal"
07:55:30 <acowley> Excuse me sir, but these two numbers are less equal than those two!
07:55:39 <acowley> Sounds good
07:56:06 <hpc> some numbers are more equal than others
07:56:22 <acowley> I don't think that's very politically correct
07:56:22 <kmc> leq, geq, and coq
07:56:26 <hpc> first we let negative numbers into the club, then they will want to be interspersed with the naturals!
07:56:30 <roconnor> > (-0.0) == (0.0)
07:56:30 <lambdabot>   True
07:56:32 <ski> "non-greater","non-lesser"
07:56:36 <hpc> imagine the chaos! society will fall apart!
07:56:46 <kmc> > let x = 0/0 in x==x
07:56:47 <lambdabot>   False
07:56:50 <acowley> man do I hate the negatives
07:57:05 <hpc> and imaginaries
07:57:11 <kmc> go back to negatopia already
07:57:18 <roconnor> hpc: you have a complex
07:57:20 <acowley> I don't even believe in the imaginaries. 
07:57:33 <kmc> i don't believe in the reals, but that's a whole other rant...
07:57:37 <ski> > (signum . recip) `map` [-0.0,0.0]
07:57:37 <lambdabot>   [-1.0,1.0]
07:57:41 <hpc> <3 this channel
07:57:47 <acowley> The reals don't exist, you're on solid ground
07:57:53 <roconnor> people used to debate whether the negative numbers are less than 0 or greater than infinity
07:58:20 <zygoloid> acowley: i got bogged down with my approach trying to implement (forall w. (Ver w :>=: v) ~ True => m w a) -> (forall w. (Ver w :>=: v) ~ False => m w a) -> (forall w. m w a)
07:58:34 <roconnor> > pi :: CReal -- disagrees with you
07:58:34 <dbelange> People used to debate what material was used to make the chain that dangled the earth from the larger crystal spheres
07:58:35 <lambdabot>   3.1415926535897932384626433832795028841972
07:58:39 <Saizan> roconnor: too used to 2 complement? :)
07:58:52 <roconnor> Saizan: this was before such ideas
07:58:57 <zygoloid> i have an implementation but it's O(n^2) lines of code, where n is the number of types which (Ver w) can take
07:59:02 * ski has wondered whether there's some kind of "number system", possibly related to `p'-adic numbers, which are described by maps from natural numbers to digits (in some base), such that the maps are eventually constant
07:59:08 <roconnor> Saizan: it had more to do with the behaviour of multiplication
07:59:22 * zygoloid is very much looking forward to byorgey's work on data kinds
07:59:40 <ski> so "...999" would be `-1', but "..444412574" woul also be valid
07:59:45 <dbelange> ski: "rational" numbers
08:00:18 <ski> why the quotes ?
08:00:35 <zygoloid> for any given base, it sounds like a proper subset of the rationals.
08:00:58 <dbelange> Mainly to make fun of you.
08:01:03 <acowley> zygoloid: what is the intent of that function? 
08:01:08 <ski> ok
08:01:10 <dbelange> You might be thinking of the p-adic rationals specifically.
08:01:32 <dbelange> Since it looks like the digits go infinitely to the left?
08:01:34 <zygoloid> acowley: given some code which works on GHC versions >= v, and some other code which works on GHC versions < v, produce code which works on any GHC version
08:01:48 <winxordie> I'm genuinely surprised by the number of people that believe the reals don't exist.
08:01:57 <ski> yeah, that was the idea. an eventually constant sequence of digits
08:02:48 <zygoloid> winxordie: i suspect the vast majority of people believe the reals exist simply because they've been told as much by figures of authority
08:02:57 <kmc> winxordie, 'exist'?
08:03:01 <acowley> zygoloid: As to byorgey's work, I'm looking forward to it too. But I'm a bit cautious because working in Agda can be quite difficult, so where he and his collaborators draw the line on what's possible will be very important.
08:03:19 <acowley> winxordie: "God invented the integers; all else is the work of man"
08:03:27 <kmc> i acknowledge that the real numbers are a consistent mathematical object, and that they're convenient for certain problems in analysis etc.
08:03:29 <winxordie> kmc: I'm a Platonist. So the statement the reals 'exist' vs don't 'exist' is a very real thing for me.
08:03:52 <Runar> winxordie: A platonist that admits it. That's refreshing.
08:03:53 <kmc> i don't think they describe our world very well
08:04:01 <kmc> yeah, all of my friends are crypto-platonists ;P
08:04:02 <medfly> so what
08:04:09 <Runar> kmc: A platonist isn't interested in "our world"
08:04:14 <jmcarthur> i think the idea of a number system "existing" or "not existing" is kind of strange
08:04:20 <medfly> me too
08:04:24 <Runar> same here
08:04:30 <kmc> i mostly object to the connotation of "real" as meaning you'd go out and find one in nature
08:04:31 <winxordie> acowley, zygoloid: I agree. For about a year I thought I was the one crazy guy around a bunch of analysis-heavy math guys.
08:04:44 <kmc> because an object with an infinite amount of information stored in it seems profoundly unnatural to me
08:05:08 <zygoloid> as a statement in some system of logic i think "there exists a set which obeys these axioms" is reasonable
08:05:12 <acowley> jmcarthur: Perhaps that's just contention over the word "exists"
08:05:20 <winxordie> kmc: well, by definition an object with an infinite amount of information is not in the naturals :P
08:05:54 <winxordie> at least, that's what I get from Chaitin omegas
08:06:05 * ski has a book here which refers to natural numbers as simply "numbers" ("negative numbers don't exist")
08:06:20 <zygoloid> kmc: i'm much more comfortable with the definable numbers :)
08:06:31 <Runar> I thoroughly enjoyed Wildberger on this topic
08:06:40 <jmcarthur> i don't know of any instruments with which i can measure anything in real units to the necessary precision
08:06:42 <acowley> winxordie: a succ destructor of something like the conaturals feels close enough to an infinite amount of information to me
08:06:49 <ski> ("Higher Arithmetic - An Algorithmic Introduction to Number Theory" by Harold M. Edwards)
08:06:51 <Cale> Spivak tends to refer to real numbers as "numbers". It's okay as long as you're reasonably consistent and it's obvious from context what you're talking about. :)
08:06:52 <roconnor> zygoloid: how many definable numbers are there?
08:07:01 <zygoloid> roconnor: countably many.
08:07:12 <rumbert> The GHC documentation says that you must first install GHC (binary) before building GHC.  Is that true?
08:07:15 <roconnor> zygoloid: what happens when you diagonalize the definable numbers?
08:07:18 <zygoloid> (by surjection from formulae in the underlying theory)
08:07:31 <medfly> rumbert, how do you compile GHC without GHC? :ol
08:07:32 <winxordie> acowley: I wish I could reply to that properly. I have no clue what 'conatural' means.
08:07:39 <rumbert> (by true I mean the assertion of the documentation)
08:07:40 <zygoloid> roconnor: you can't express that in the theory from which you generated them, so there's no contradiction, iirc
08:07:57 <jmcarthur> surely if i can measure it using a real-word device then the number i got exists in some number system other than the reals, right?
08:08:04 <kmc> winxordie, there are reals with infinite information though.  almost all of them.
08:08:05 <acowley> winxordie: Sorry, I'm not being fancy, I just mean something isomorphic to an infinite stream.
08:08:12 <rumbert> medfly:  bootstrapping
08:08:13 <roconnor> zygoloid: so what do you mean when you say there are countably many of them?
08:08:14 <winxordie> oh, I see.
08:08:23 <winxordie> kmc: right, but they don't exist. :P
08:08:29 <ski> (jmcarthur : yeah .. apartness of real numbers is only semi-observable)
08:08:36 <kmc> winxordie, so the reals don't exist?
08:08:41 <kmc> even to you as platonist?
08:08:41 <rumbert> medfly: I'm going to take that for 'yes'.
08:08:56 <winxordie> almost all numbers are Kolmorogov random, so taking the reals as a sequence, I think it follows
08:09:00 <zygoloid> roconnor: in order to talk about the definables you need to work in a metalogic above the logic for which you are discussing the definables
08:09:25 <zygoloid> roconnor: in that metalogic you can show that there are countably many definables (this follows trivially from their definition)
08:09:26 <aristid> @where typeclassopedia
08:09:26 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
08:09:28 <winxordie> kmc: Yeah. Simply being a Platonist doesn't mean I follow ZFC all the way through.
08:09:31 <roconnor> zygoloid: so you mean countable in the metalogic?
08:09:31 <Cale> rumbert: Yeah, it's nontrivial to compile GHC if you don't already have a GHC binary.
08:09:45 <zygoloid> roconnor: yes.
08:09:57 <roconnor> zygoloid: and they may not be countable in the logic?
08:10:00 <kmc> it'd be nice if GHC ran in some portable Haskell interpreter like Hugs
08:10:18 <kmc> or if it came pre-compiled to bytecode which runs in some portable bytecode interpreter like yhi
08:10:30 <kmc> sadly ours is not this best of possible worlds
08:10:32 <zygoloid> roconnor: they're not a set in the logic; your diagonalization argument shows that.
08:10:55 * hackagebot CheatSheet 2.8 - A Haskell cheat sheet in PDF and literate formats.  http://hackage.haskell.org/package/CheatSheet-2.8 (JustinBailey)
08:12:04 <zygoloid> roconnor: hmm, actually, i think that statement is too strong. they're certainly not countable, though
08:12:08 <kmc> i'm not sure it's entirely applicable but i'd like to bring up LÃ¶wenheimâSkolem
08:12:18 <roconnor> yes
08:12:54 <winxordie> woah, that's one cool theorem
08:14:04 <acowley> that's a bit of a hammer to this debate
08:14:11 <kmc> this says you can make countable models of the reals even
08:14:21 <quicksilver> kmc: how would you bootstrap the RTS?
08:14:47 <quicksilver> kmc: GHC's RTS requires facilities which don't exist in yhi or hugs
08:15:03 <quicksilver> you could have a kind of GHC-lite, though.
08:15:11 <kmc> yeah
08:15:19 <kmc> a barebones GHC RTS is not too hard to port, as C programs go
08:15:20 <acowley> zygoloid: Do you have any more thoughts on this type family business? My instances overlap too much to let me do anything particular interesting.
08:16:35 <acowley> zygoloid: The inability to use constraints to effect a kind of pattern matching is killing things.
08:17:18 <sm> http://cheatsheet.codeslower.com/CheatSheet.pdf looks quite useful.. wish I'd had it a while back
08:17:55 <sm> Cale: nontrivial as in difficult, or just "takes a while" ?
08:18:52 <kmc> kinda long for a cheat sheet ;P
08:18:59 <kmc> does look useful though
08:19:42 <Cale> sm: Difficult
08:19:52 <Cale> http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
08:20:17 <kmc> after attempting to carry out those instructions
08:20:28 <kmc> i'm pretty sure they're not totally correct ;P
08:20:33 <kmc> it's a good starting point though
08:20:50 <kmc> my goal was not to port GHC but to build GHC as a cross-compiler
08:20:54 <kmc> which is a little different too
08:21:11 <sm> kmc: true, it is long. I guess haskell's syntax is pretty complex eh
08:21:24 <zygoloid> acowley: i'd try using type families instead of associated types. that way you don't have to worry about instance overlap, except in the cases where it's actually inconsistent
08:21:39 <ksf> ezyang, I know how to cathedralise the bazaar
08:21:46 <ksf> http://www.public-software-group.org/liquid_feedback
08:21:47 <acowley> zygoloid: The trouble I've run into with type families is that you can't use constraints of nested applications.
08:21:49 <ksf> we just vote on it.
08:22:11 <zygoloid> acowley: but the checking is a little broken. given: type class a :>=: b :: *; type instance a :>=: a = True; type instance f a :>=: f b = a :>=: b, it claims there's inconsistency
08:22:38 <kmc> it's also pretty comprehensive, and written in prose style rather than condensed form
08:22:44 <chrisdone> luite: ping
08:22:49 <ksf> zygoloid, of course there is.
08:22:51 <kmc> and has motivating sections and whatever
08:22:58 <ksf> both match * -> * kinds.
08:23:10 <zygoloid> ksf: sure. there's overlap. but not inconsistency.
08:23:19 <kmc> it seems like a poor fit for the 3-column layout, but content-wise a highly useful document
08:23:33 <ksf> any overlap means inconsistency in the typefam case.
08:24:06 <zygoloid> ksf: nope. ghc is happy with: type family Or a b :: *; type instance Or True a = True; type instance Or a True = True
08:24:17 <ksf> ...well, at least most of it. I think you can re-write any allowed overlapping stuff into multiple non-overlapping TFs
08:24:31 <Cale> sm: http://cs.anu.edu.au/student/comp1100/haskell/tourofsyntax.html -- you might also find this handy
08:24:41 <zygoloid> the rule is that the result type must be the same in the case of overlap.
08:25:11 <acowley> zygoloid: The issue with nested type function invocation being forbidden is that I can't encode transitive properties
08:25:18 <sm> Cale: thanks, looks easier to search. I'll try that next time
08:25:20 <zygoloid> in the :>=: case, the overlap happens when f a ~ f b. that means a ~ b, so the result is a :>=: b = a :>=: a so the result types are the same.
08:25:23 <ksf> it's a matter of type safetly, not merely instance selection.
08:25:38 <zygoloid> ksf: correct. but the example i gave is consistent.
08:25:48 <sm> yay, first payment for haskell work received
08:25:58 <acowley> zygoloid: With my associated type, I could write type L (Min a b) c = Or (Or (Refl a c) (Refl b c)) (Or (L a c) (L b c))
08:25:59 <acowley>  
08:26:11 <acowley> Where I'd defined Refl as a type family
08:26:28 * sm is on the road to riches now
08:26:37 <acowley> zygoloid: But I can't do the same with just type families
08:26:51 <ksf> zygoloid, what's [Int] :>=: [Word]? True or Int :>=: Word?
08:27:05 <ksf> the checker doesn't understnad recursion.
08:27:06 <zygoloid> ksf: why would it be True?
08:27:33 <ksf> because you can either say a = [Int] or f = [] a = Int
08:27:38 <zygoloid> i know the checker doesn't understand recursion. my complaint is that this leads to it rejecting valid programs
08:27:46 <ksf> oh, sorry, make that [Int] :>=: [Int]
08:27:47 <zygoloid> ksf: ok, but why would that make it be True?
08:28:03 <zygoloid> ksf: it's both, since Int :>=: Int ~ True
08:28:41 <ksf> anyway, don't you want to use TypeEq?
08:28:58 <Saizan> i think ksf is saying that you can't expect that much unfolding, though maybe you could.
08:29:11 <ksf> typefams can't do everything fundeps can, not without superclass constraints.
08:29:27 <ksf> the syntax may be abysmal, but then...
08:30:01 * ksf would like to have -XBacktrackingInstances
08:30:16 <ski> (acowley : .. what does your `Refl' signify ?)
08:30:18 <ksf> ...something like annotating an instance with "this is a failure, backtrack and try again"
08:30:21 <kamatsu> ksf: change the type system into a real logic language?
08:30:21 <acowley> arg, I take back any nasty things I've said about Agda
08:30:31 <ksf> kamatsu, yes.
08:30:42 <acowley> I really want to write type instance Foo (F a b) c = ... and type instance Foo a (Foo b c) = ...
08:30:45 <ksf> as it stands now I have to resort to TH to get what I need.
08:30:56 <zygoloid> how is this not just a bug in the implementation? the doc says "The instance declarations of a type family used in a single program may only overlap if the right-hand sides of the overlapping instances coincide for the overlapping types"
08:31:00 <acowley> ski: I have a type instance Refl a a = True
08:31:25 <ski> oh, so by `Refl' you mean `Equal' or `IsEqual' ?
08:31:34 <acowley> ski: yes
08:31:50 <ksf> (and subsequently completely change my approach as when I use TH there's easier things than running hint and trying arguments. like generating a class that doesn't require backtracking)
08:31:55 <zygoloid> i suppose it depends on what they mean by 'coincide'. and it looks like the exact wording rules out coincide-after-expanding-type-functions
08:32:18 <acowley> zygoloid: I'd prefer your interpretation :/
08:32:40 <ksf> zygoloid, typefams are lazy.
08:33:12 <ksf> I guess one could say that their whnf has to be equal.
08:33:36 <ksf> probably a termination thing.
08:33:43 <luite> chrisdone: yes
08:34:14 <luite> I mean pong
08:35:44 <luite> I have a 3d engine working in javascript by the way (that renders to a Raphael object), I just need the haskell side of things and then I have 3d plotting :)
08:36:04 <zygoloid> ksf: i don't understand your objection. ghc is rejecting a correct program, because it isn't smart enough to be able to prove it correct.
08:36:49 <zygoloid> i would like ghc to be made smarter (while retaining terminating typechecking) so that it can see my program is correct
08:36:52 <luite> of course it's horrendously slow in internet explorer, so I can't use it for things that ar too complex
08:37:15 <chrisdone> luite: hey man, is your tryhaskell source available somewhere?
08:37:20 <acowley> Is terminating type checking really critical?
08:38:06 <chrisdone> luite: the guys working on macaulay2 emailed me asking about the codebase for tryhaskell, and I was thinking I could suggest they take a look at yours too because the code base is simpler and cleaner, with more graphical features
08:38:08 <luite> chrisdone: not yet, I'm also in the middle of a rewrite of the json service, I'm changing it to happstack, to be able to use real persistent sessions
08:38:25 <chrisdone> hmm. not even a github project?
08:38:32 <luite> not yet, sorry
08:38:38 <chrisdone> okies
08:38:40 <zygoloid> acowley: personally, i don't think so, as long as i can easily guide it around the nontermination when proving my code correct (i use UndecidableInstances, in cases where i know instance checking will terminate)
08:38:43 <luite> I'll try to get things a bit more organized soon
08:38:56 <luite> but at the moment I'm mainly just experimenting to see what's possible
08:39:21 <chrisdone> sure
08:40:06 <luite> I'm also waiting for byorgey to finish his new diagrams library ;p
08:40:49 <luite> does macaulay use haskell, or are they just interested in the client side part?
08:41:25 <zygoloid> ksf: my simple change to the check is: after substituting to exhibit the overlap in the overlapping type instances, you may assume that the instances are equal on all smaller (in terms of number of tokens in the usual way) when performing simplifications on the results
08:41:51 <ksf> I don't think it's that easy
08:42:01 <zygoloid> ksf: that gives: instance f a :>=: f a = a :>=: a = True versus instance a :>=: a = True. and my case is accepted. termination follows trivially.
08:42:09 <ksf> ...substituting the rhs while still ensuring termination, that is.
08:42:11 <zygoloid> and it's sound by a simple inductive argument.
08:43:01 <ksf> you're right though that typefams could use a theorem prover.
08:43:19 <ksf> ...inferring stuff like the termination of Mul shouldn't be that hard
08:43:55 <zygoloid> ksf: a generalization which still terminates: you may perform any substitution which reduces the number of tokens on the RHS, except substitutions for equal-sized or larger cases of the family you are checking the soundness of
08:44:06 <cjf> r/
08:44:53 <chrisdone> luite: they specifically asked for 'the haskell.json file', so I sent them the Haskell source. looking at macaulay2's code base, it's in C. so I don't think they're using Haskell at all. I sent them links to other try* variants, assuming they might be asking about client-side which makes more sense
08:44:56 <ksf> zygoloid, I think the way to do this would be to allow custom reduction strategies.
08:45:22 <ksf> let the user specify how to reduce the terms, and let him care about termination.
08:46:06 <zygoloid> ksf: the number-of-terms-must-reduce strategy is already used for instance contexts. it's inconsistent to not also apply it here
08:46:25 <pozic> Does anyone know how GTK calls the signal to drag something?
08:46:58 <zygoloid> ksf: i think custom reduction strategies would be an interesting research project, but probably not enough power-to-weight for incorporation into ghc (much as i'd like them) :(
08:47:41 <dpratt71> reading http://www.haskell.org/haskellwiki/Existential_type and got confused by something...
08:47:56 <dpratt71> "...It is also possible to express existentials as type expressions directly (without aÂ dataÂ declaration) with RankNTypes..."
08:48:21 <bobzhangatthu> It's possible to type infix to moidfy the associative order in ghci?
08:48:57 <bobzhangatthu> I mean I define an operator (|>), and want to change it's associative dynamically for some tests
08:49:16 <dpratt71> the article then goes on to define operations in terms of...a data declaration? is the point that the data declaration can be hidden?
08:49:56 <zygoloid> ksf: hmm, looking through the paper in more detail, it looks like the only change that's needed is to say that the soundness-of-overlap checking tries to unify the RHSs rather than requiring syntactic equality. termination is already guaranteed.
08:50:53 <Twey> bobzhangatthu: Well, you can shadow it
08:51:00 <bobzhangatthu> how to do it?
08:51:19 <bobzhangatthu> oh, i see
08:51:29 <merijn> dpratt71: The point is: I want to have a list of "Show"-able items. Strings and Int's are both show able. How do I put a String and Int in the same list without adding a new data type? (data Wrapper = IntWrapper Int | StringWrapper String)
08:51:37 <Twey> bobzhangatthu: let infixr 4 |>; (|>) = (YourModule.|>) in tests
08:52:40 <dpratt71> merijn: thanks; I think you're on your way to answering the question I'm trying to ask
08:52:59 <merijn> dpratt71: existential types let you do that type of wrapping implicitly by telling the compiler you want a list that can contain any item as long as said item is an instance of show
08:53:01 <dpratt71> is it possible, for example, to define a list value that can contain any kind of value such that there is an associated instance of the Show typeclass for that value...without involving a data declaration at all?
08:53:21 <bobzhangatthu> Data.Dynamic?
08:53:25 <merijn> dpratt71: That sounds about right, yes
08:53:30 <dpratt71> I guess I could have waited a moment to post my question :)
08:53:52 <dpratt71> how would one declare such a list?
08:54:18 <hpc> data [] = exists a . a : [a]
08:54:29 <dpratt71> hpc: exists!
08:54:34 <McManiaC> is there a way to do sth like "someArrow >>> arr someFunction" without that ">>> arr" construction?
08:54:40 <hpc> er, a : []
08:54:58 <merijn> "data MyList = forall a. (Show a) =>  [a]"? I haven't really used existential types much yet, so I dunno the real syntax
08:55:24 <Saizan> you need a constructor
08:55:32 <lantti> "data Show a => Mylist = [a]
08:55:35 <lantti> I think
08:55:40 <dpratt71> Saizan: ah, that may be the bit that I'm missing
08:55:52 <hpc> or type List = [forall a. a], i think
08:55:56 <lantti> "data Show a => Mylist = Mylist [a]
08:55:57 <lantti> Even
08:55:59 <lantti> :)
08:56:02 <ski> dpratt71 : `forall o. (forall a. Show a => [a] -> o) -> o' is a CPS-encoding of such a type (i.e. `exists a. Show a *> [a]')
08:56:03 <Twey> data MyList = forall a. Show a => MyList [a]
08:56:06 <Saizan> lantti: no
08:56:10 <Saizan> hpc: neither
08:56:17 <Saizan> Twey++
08:56:24 <lantti> "data Show a => Mylist a = Mylist [a]
08:56:26 <lantti> ?
08:56:34 <merijn> Oh, I was almost right then :D
08:56:35 <dpratt71> ski: CPS = continuation passing style?
08:57:20 <dpratt71> ok, I'll play around with it a bit more, thanks all :)
08:57:23 <ski> (but it's probably better to either do a `data' declaration, or at least unwrap the CPS once when manipulating a list, rather than doing it multiple times, because of (lack of) sharing with the function values)
08:57:27 <ski> dpratt71 : yes
08:57:49 <ski> lantti : no
08:57:58 <FunctorSalad> data MyList :: (* -> *) where Nil :: MyList () \n       Cons :: Show a => a -> MyList b -> MyList (a,b)
08:57:59 <FunctorSalad> ?
08:57:59 <dpratt71> ok, gotta run, thanks again
08:58:00 <FunctorSalad> :D
08:58:04 <FunctorSalad> heteroshowlist
08:58:29 <ski> er, right ..
08:58:38 <merijn> FunctorSalad: That's awful
08:58:59 <Mathnerd314> @hoogle (Arrow cat) => cat a b -> (b -> c) -> cat a c
08:58:59 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
08:59:00 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
08:59:00 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
08:59:04 <ski> dpratt71 : sorry, what you asked for was `[exists a. Show a *> a]' which would be `[forall o. (forall a. Show a => a -> o) -> o]', rather
08:59:09 <FunctorSalad> I didn't see the problem, just the Show-lists
08:59:19 <ski> (that might require `ImpredicativeTypes', though)
08:59:20 <Mathnerd314> ^ McManiaC: you want >>^ or ^<<
08:59:27 <FunctorSalad> merijn: hmm 'awful'?
09:00:06 <luite> chrisdone: ok, I think they'll be fine with your version then. my new json service is so unfinished that it's probably useless to them (lots of hardcoding that shouldn't be there), and I havent changed much in the console part (planning to do that later). The only thing of the new graphics library that is visible from the client side, is the new runRaphael function, which just evals some javascript code that draws the drawing to some Raphael paper
09:00:36 <ski> hpc : `[forall a. a]' is the type of list of values where each value can assume whatever type you want ... you probably intended `[exists a. a]'
09:00:54 <acowley> dpratt71: http://haskell.pastebin.com/5Nu4vh1x
09:00:57 <McManiaC> Mathnerd314: ok thx :)
09:01:09 <acowley> dpratt71: No data declarations!
09:02:01 <ski> (FunctorSalad : well, i think dpratt71 wanted it more like `data MyList where Nil :: MyList; Cons :: forall a. Show a => a -> Mylist -> MyList' ..)
09:02:40 <FunctorSalad> ski: I considered that... but that's equivalent to [String]
09:02:55 <FunctorSalad> or [Int -> ShowS] if you insist ;)
09:03:05 <ski> acowley : hehe :D
09:03:21 <acowley> ski: Is it not complicated enough looking? :P
09:03:23 <ski> FunctorSalad : assume a nonstandard definition of `Show' ;)
09:03:39 <ksf> zygoloid, we even have an existing theorem prover that's written in haskell.
09:03:50 <ksf> idris is based on it.
09:04:21 <ski> (like `class Show a where showEmpty :: a; shows :: Int -> a -> a; unshows :: a -> Maybe (Int,a)' ..)
09:04:21 <FunctorSalad> ivor?
09:05:07 <FunctorSalad> ski: the 'a' is just eliminable if it appears only once and negatively?
09:05:12 <FunctorSalad> never thought about when exactly it is
09:05:18 <ski> > permutations "ivor"
09:05:19 <lambdabot>   ["ivor","vior","ovir","voir","oivr","iovr","rovi","orvi","ovri","rvoi","vro...
09:05:31 <aristid> > permutations "ab"
09:05:32 <lambdabot>   ["ab","ba"]
09:05:44 <aristid> > length . permutations $ "ivor"
09:05:45 <lambdabot>   24
09:06:27 <dbelange> permutations "kcco"
09:06:35 <dbelange> > permutations "kcco"
09:06:36 <lambdabot>   ["kcco","ckco","ccko","ccko","ckco","kcco","occk","cock","ccok","occk","coc...
09:07:02 <luite> it cut it off just in time :)
09:07:11 <ski> FunctorSalad : well, if you have `exists x. (x,f x)' for a contravariant functor `f', then that is isomorphic to `f ()', yes
09:07:22 <luite> oops, it did show a 'naughty' one ;p
09:07:34 <ski> .. not sure about whether this is the only case
09:07:53 <aristid> > permutations "aa"
09:07:54 <lambdabot>   ["aa","aa"]
09:07:57 <aristid> oO
09:08:36 <acowley> aristid: Those two 'a's don't look the same to permutations
09:08:38 <ski> (what is being permuted is the valid indices into the list)
09:08:51 <acowley> one came from *here* and one came from *there*
09:08:54 <pokoko222> what is the hottest area now in computer science? AI and machine learning i think, you?
09:09:15 <ksf> FunctorSalad, yes.
09:09:40 <merijn> pokoko222: Distributed algorithms and high performance computing are also quite high in the hot areas list
09:09:43 <ski> pokoko222 : HOT languages ("HOT" being "Higher-Order and Typed")
09:09:55 <pokoko222> ski be serious please :D
09:10:07 * ski has seen that abbreviation in some paper
09:10:14 <ksf> any hackage 2.0 devs here?
09:10:21 <ksf> I need to spin liquid feedback a bit more.
09:12:15 * hackagebot improve 0.0.4 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.0.4 (TomHawkins)
09:12:50 <ksf> pokoko222, P /= NP
09:12:58 <ksf> it's all the rage in the ivory tower, right now.
09:13:30 <FunctorSalad> ski: for a covariant functor the 'x' seems outright useless ;)
09:13:36 <FunctorSalad> (Read?)
09:13:45 <pokoko222> ksf complexity analysis?
09:13:51 <ksf> yep.
09:13:54 <merijn> Naah, stuff has calmed down while the proof is being looked over. I think that so far there have been 4 problems with the proof, 1 possibly severe enough to render the entire approach useless
09:14:08 <ksf> economically speaking, there's a lot of stuff going on wrt. data mining and analysis I think.
09:14:29 <ksf> it's always hard to identify something "hot" in cs
09:14:34 <ksf> too many fronts.
09:14:52 <ski> hm, actually
09:14:55 <ski>   data CoYoneda f a = forall x. FMapIncl (x -> a) (f x)
09:15:02 <pokoko222> ksf i heard ontologies are popular too
09:15:12 <pokoko222> and knowledge representation
09:15:22 <merijn> Ontologies are usually seen as more of an AI thing then CS
09:15:34 <pokoko222> well AI is CS
09:15:36 <merijn> Interesting, but so far seems sorta fuzzy
09:16:08 <ski>   i.e. `exists a. (f x,x -> a)' is `CoYoneda f a', where `f' is any type function (but e.g. a covariant functor)
09:16:09 <pokoko222> if you have read general book on cs you would see AI defined as area in CS
09:16:21 <aristid> ski: i'm sure CoYoneda is hot, too
09:16:33 <ski> s/exists a/exists x/
09:16:45 <merijn> pokoko222: Over here AI is distinct from the CS groups
09:17:02 <ski> and the dual of that would be `exists x. (a -> x,f x)' .. so if `a = ()', that's the earlier `exists x. (x,f x)' one
09:17:05 <pokoko222> merijn wanna go private so we dont flood with nonhaskell?
09:17:11 <merijn> Sure
09:17:14 <aristid> ski: exists a. a is like Wrapper (forall a. a)?
09:17:56 <ski> aristid : no `data Foo = MkFoo (exists a. ..a..)' is `data Foo = forall a. MkFoo (..a..)'
09:18:26 <aristid> ski: what is exists a. in haskell, then?
09:18:27 <ski> aristid : so `MkFoo :: (exists a. ..a..) -> Foo', which is basically the same thing as `MkFoo :: forall a. (..a.. -> Foo)'
09:20:02 <ski> `MkFoo :: forall a. (..a.. -> Foo)' could be written in pseudo-code as `forall a. (MkFoo :: ..a.. -> Foo)', or `forall a. ((bar :: ..a..) -> (MkFoo bar :: Foo))' .. which explains the `data Foo = forall a. MkFoo (..a..)' syntax for declaring "existentially quantified datatypes"
09:21:07 <ski> aristid : the `exists a. ' syntax doesn't exist in Haskell (but iirc some implementations support the `exists a. ' syntax in some cases ..)
09:22:01 <aristid> ski: yeah that's why i want to know how to translate it to haskell, because i don't know what exists is
09:23:19 <ski> FunctorSalad : anyway, `CoYoneda f a = exists x. (f x,x -> a)' and `CoYonedaOp f a = exists x. (a -> x,f x)' setting `f' to `IORef' (or any other type function you want to lift to a (co- resp. contra- variant) functor) can be useful
09:23:31 <ksf> aristid, http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types  sheds some light on exists vs. forall
09:23:43 <ksf> ...and why haskell doesn't need the former to get the former.
09:24:01 <ski> aristid : so, if you want to express `exists x. Foo a x => ..x..', then you must create a new datatype, wrapping it
09:24:04 <ski> basically
09:24:37 <ski> (sorry `exists x. Foo a x *> ..x..', that should be .. the other is not as useful)
09:24:45 <ski>   data SomeFoo a = WrapFoo (exists x. Foo a x *> ..x..)
09:24:56 <ski> but since that's not accepted syntax, you rewrite that into
09:25:10 <ski>   data SomeFoo a = forall x. Foo a x => WrapFoo (..x..)
09:25:29 <ski> you can also write this, using GADT syntax as
09:25:35 <ski>   data SomeFoo a
09:25:36 <aristid> ok i think i understand it now
09:25:36 <ski>     where
09:25:57 <ski>     WrapFoo :: forall x. Foo a x => (..x..) -> SomeFoo a
09:26:08 <ski> (where you can omit `forall x. ', if you want)
09:26:32 <ski> (some think this latter syntax is clearer for existentially quantified datatypes)
09:26:59 <aristid> ski: i think GADTs also are nicer syntax for variants
09:27:52 <ski> also, if `(..x..)' is (more or less) a tuple type `(..a..x..,..a..,..x..)', then you can of course write `WrapFoo (..a..x..) (..a..) (..x..)' in the former syntax
09:28:14 <ski> and `(..a..x..) -> (..a..) -> (..x..) -> SomeFoo a' in the latter syntax
09:29:16 <ski> aristid : well, it's a trade-off -- if you don't need an indexed type, then you avoid duplicating the result type on each constructor type, with the ADT syntax
09:29:33 <aristid> ski: yeah, that's true
09:29:43 <ski> .. of course, in some cases the GADT variant might feel more readable in any case
09:29:54 <ski> e.g. compare
09:29:57 <aristid> and you also lose automatic derivation
09:30:14 <ski>   data Expr a = Lit a
09:30:34 <acowley> is instance matching fully lazy?
09:30:35 <ski>               | forall b. App (Expr (b -> a)) (Expr b)
09:30:38 <ski> with
09:30:44 <ski>   data Expr :: * -> *
09:30:46 <ski>     where
09:32:10 <ski>     Lit :: forall a  .            a           -> Expr a
09:32:35 <ski>     App :: forall a b. Expr (b -> a) -> Expr b -> Expr a
09:33:26 <ski> (or even bracketing like `Expr (b -> a) -> (Expr b -> Expr a)' in the latter signature, to emphasize the applicative-functor nature better)
09:33:44 <ski> here i'd say the GADT version of `App' is more readable, for sure
09:35:49 <aristid> ski: Lit is pure and App is (<*>)?
09:35:55 <aristid> :t (<*>)
09:35:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:36:18 <hpc> :t (>>=) <*>
09:36:19 <lambdabot> parse error (possibly incorrect indentation)
09:36:25 <hpc> :t ((>>=) <*>)
09:36:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a -> a -> m b) -> m a -> m b
09:36:40 <hpc> cool
09:36:51 <aristid> oO
09:37:47 <ski> aristid : yeah (actually i didn't think of this being sortof the essense of `Applicative' at first, i only added the `Lit' case to get a base case .. imagine there's lots of other interesting constructors, for other kinds of expressions)
09:38:36 <ski> aristid : btw, note that `instance Applicative Expr' as that stands wouldn't actually satisfy the idiom / applicative functor laws (unless you make `Expr' a proper abstract data type)
09:38:56 <aristid> ski: because of the missing type parameter?
09:39:11 <aristid> oh, no
09:39:15 <aristid> that is there
09:39:30 <ski> no, because `App (Lit f) (Lit a)' isn't the same value as `Lit (f x)'
09:43:11 <sanders_> is there any good method to avoid adding a lot of noise to ones source code when ambiguity exists for literals (like Num or OverloadedStrings)
09:43:12 <ski> `Applicative i' requires (beyond `Functor i') that
09:43:20 <ski>   forall f ia. pure f <*> ia = fmap f ia
09:43:21 <acowley> Anyone have any tips for debugging nontermination of type checking in the presence of UndecidableInstances?
09:43:28 <ski>   forall if a. if <*> pure a = fmap ($ a) if
09:43:30 <ski>   forall if ia ib. (if <*> ia) <*> ib = fmap uncurry if <*> (fmap (,) ia <*> ib)
09:43:34 <ski> aristid : ^
09:43:50 <augur> 'lo peeps
09:43:52 <sanders_> I saw this but it does not appear to be implemented yet http://hackage.haskell.org/trac/haskell-prime/wiki/Defaulting 
09:44:07 <ski> (well, rename `if' to some non-keyword identifier ..)
09:44:10 <augur> ski, whats your favorite parsing technique?
09:44:38 <ski> augur : edwardk's monoidal parsing is interesting
09:44:51 <augur> oh?
09:44:56 <augur> what kind of parsing algorithm is it?
09:44:57 <aristid> ski: using if as a type variable is a bit weird
09:45:27 <ski> yeah, that was inadvertent
09:47:05 <Jonno_FTW> @src min
09:47:05 <lambdabot> min x y = if x <= y then x else y
09:47:13 <Jonno_FTW> @src minimum
09:47:13 <lambdabot> minimum [] = undefined
09:47:13 <lambdabot> minimum xs = foldl1 min xs
09:47:56 <ski> aristid : fun exercise ! : just as `data CoYoneda f a = forall x. FMapIncl (x -> a) (f x)' derives a "free" (covariant) functor `CoYoneda f' from *any* type function `f' (like e.g. `IORef' or `Expr' above); device a similar contraption `FreeApplicative' that derives a "free" applicative function / idiom `FreeApplicative f' from and given type-function `f' (possibly assuming that `Functor f', if you prefer)
09:48:17 <ski> s/and given/any given/
09:48:38 <aristid> ski: i don't understand :D
09:51:08 <ski> aristid : define a type constructor `FreeApplicative :: (* -> *) -> (* -> *)' such that you can (correctly) write `instance Functor (FreeApplicative f) where {...}; instance Applicative (FreeApplicative f) where {...}' (or possibly `instance Functor f => Functor (FreeApplicative f) where {...}; instance Functor f => Applicative (FreeApplicative f) where {...}')
09:51:13 <ski> is that clearer ?
09:52:52 <ski> ("correctly" just meaning that your method implementations satisfy the required associated laws)
09:53:26 <ski> augur : well, you'd have to ask edwardk (or delve into it yourself)
09:53:58 * ski hasn't really done that yet, for real
09:54:43 <aristid> ski: i fear this is still over my head
09:55:03 <Philonous> ski: If you have the (possibly easier?) "Functor f =>" can't you just throw in CoYoneda to make any f a functor first and then apply the new magic Applicative constructor?
09:55:10 * ski just invented this exercise on the spot, so doesn't know how to solve it, yet
09:55:45 <ski> Philonous : well, `CoYoneda f' works regardless of whether you have `Functor f' or not
09:56:06 <augur> ski: read your /msgs :|
09:56:08 <augur> o hai
09:56:09 <ski> Philonous : i.e. one can define `instance Functor (CoYoneda f)' .. for *any* `f', note that !
09:58:39 <Philonous> ski: Yes, I just meant that you can WLOG assume "Functor f" because you can just throw CoYoneda at f first
09:59:55 <Silvah> Heh, you just enlightened me how little I know about Haskell... ;)
10:04:10 <ski> Philonous : no, that'd let you assume `Functor (CoYoneda f)' (which might be part of `Functor (FreeApplicative f)', granted)
10:04:45 <ski> i suppose if the "rest" of `FreeApplicative' preserves `Functor'ness, then that'd give you `instance Functor f => Functor (FreeApplicative f) where {...}' for free, though
10:04:51 <ski> (maybe that's what you had in mind .. ?)
10:05:45 <ski> it might still be that `Functor f' is required (or simplifies) writing `Applicative (FreeApplicative f)' (hence assuming that might simplify it)
10:05:50 <ski> .. i don't know yet
10:06:56 <ski> Silvah : heh, i'm just playing around atm. i'm not sure whether `FreeApplicative' would have any application (it might have, `CoYoneda' does) :)
10:08:15 <Philonous> ski: Assuming you have "Functor f => Applicative (Foo f)" you get "Applicative ( Foo (CoYoneda (f)))" for free. so given "newtype O f g x = O f(g(x))" you get the structure you are searching for as "O Foo CoYoneda"
10:11:10 <ski> Philonous : ah, but you still need to get `Functor (O Foo CoYoneda f)' as well
10:11:29 <ski> (that's what i meant by "`FreeApplicative' preserves `Functor'ness")
10:12:32 <Philonous> ski: Applicative implies functor
10:13:50 <ski> yeah .. but when i said `instance Functor f => Applicative (FreeApplicative f) where {...}' i was only talking about the code implementing the `Applicative' methods .. to make this valid, you'd have to define the `Functor' methods as well
10:14:19 <ski> .. though, on second thought, i realize this is obvious
10:14:37 <ski> @type \f ia -> pure f <*> ia  -- is `liftA', i.e. `fmap'
10:14:38 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
10:14:41 <Philonous> ski: That's trivial: fmap f x = pure f <*> x
10:14:48 * ski nods :)
10:15:05 * ski has been awake somewhat more than 24 hours, atm
10:15:18 <aristid> ski: good night!
10:15:29 <b7j0c> here is a problem for which i have a blunt and uninteresting solution, but was wondering if the brains here had something elegant: in a string, replace whitespace substrings of length greater than 1, with a space of length 1. i.e. so "abc   def" would be transformed to "abc def"
10:15:48 * ski is actually trying to prove some things in Agda2 ..
10:16:17 <Philonous> b7j0c: unwords.words
10:16:30 <b7j0c> thanks Philonous!
10:16:34 <b7j0c> i'll try that out
10:16:45 <aristid> ski: only people who have slept enough can effectively write proofs, IMO
10:16:58 <ddarius> Formal theorem proving.  The last refuge of lost souls.
10:16:59 <alc> > let f = unwords . words in f "abc         def        xyz"
10:17:00 <lambdabot>   "abc def xyz"
10:17:13 <Philonous> b7j0c: No wait, that replaces newlines with whitespaces
10:17:30 <b7j0c> in my case that should actually be ok
10:17:38 <ski> (bah, the system catches any errors i make .. the properties themselves are simple enough that i can understand them easily)
10:17:55 <ddarius> unlines . map (unwords . words) . lines
10:17:58 <Philonous> b7j0c: "unlines.unwords.words.lines" would preserve lines, though
10:18:11 <Philonous> Errr, what ddarius said ;)
10:18:28 <aristid> :t \x y -> map x . y
10:18:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f [a] -> f [b]
10:18:35 <ddarius> ski: So just code randomly until the theorem prover says okay.
10:18:48 <aristid> :t \x y -> map x Prelude.. y
10:18:49 <lambdabot> forall a b a1. (a -> b) -> (a1 -> [a]) -> a1 -> [b]
10:18:57 <aristid> :t \x y -> fmap x Prelude.. y
10:18:58 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
10:19:00 <ski> ddarius : yeah, that's the basic strategy :)
10:19:42 * hackagebot graph-wrapper 0.1 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.1 (MaxBolingbroke)
10:20:50 <aristid> :t let infixr .:; x .: y = fmap x . y in unlines . unwords .: words .: lines
10:20:50 <lambdabot> String -> String
10:21:34 <alc> but that would add a trailing newline if there's no one
10:22:03 <alc> > unlines . lines $ "hello"
10:22:04 <lambdabot>   "hello\n"
10:22:58 <b7j0c> hey thanks guys for the answers...your solutions are more elegant than my own function
10:26:29 <alc> > nubBy (\x y -> x == ' ' && y == ' ') $ "abc     def       xyz\nabc     def"
10:26:30 <lambdabot>   "abc defxyz\nabcdef"
10:27:11 <alc> oops
10:29:10 <aristid> > init . unlines . lines . (++"\n") $ "a b c\nd"
10:29:11 <lambdabot>   "a b c\nd"
10:29:15 <aristid> > init . unlines . lines . (++"\n") $ "a b c\nd\n"
10:29:16 <lambdabot>   "a b c\nd\n"
10:31:08 <alc> nice
10:31:38 <Philonous> > nubBy ((&&) `on` isSpace) "a   b\nc"
10:31:39 <lambdabot>   "a bc"
10:32:31 <ski> > nubBy ((&&) `on` (== ' ')) "a   b\nc de\n f"
10:32:32 <lambdabot>   "a b\ncde\nf"
10:32:40 <Philonous> indeed
10:38:47 <erry969> Hey.
10:39:13 <Cale> hello
10:39:23 <erry969> is anyone here a graphic artist?
10:40:15 <Cale> Well... this is the channel for programming in Haskell, but I know at least a few people here have some ability.
10:40:28 <DW2> Yes.
10:40:43 <DW2> Sorry but i am need of a graphic artist very badly.
10:40:44 <copumpkin> Indeed.
10:40:57 <DW2> I am a great programmer but not a good graphic artist.
10:41:03 <DW2> Art is just not my thing.
10:42:10 <DW2> So, anyone here a good graphic artist?
10:42:19 * BMeph always thought programming was no less an art than writing in general...
10:43:10 <Starfire> When someone asks what I do for a living, I frequently answer that I'm a writer. :)
10:43:41 <DW2> umn ok.
10:44:00 <DW2> Please guys, if anyone here is a graphic artist, please tell me. i really need one.
10:44:00 <copumpkin> DW2: I'd guess there are better places to ask that, regardless of how desperate you are. Maybe a dozen or two out of the 600 people here are decent, but they're likely idle (since most people are)
10:44:15 <bss03-AFK> DW2: Someone here *is* a graphic artist.
10:44:27 <bss03-AFK> DW2: But, I won't tell you who.
10:44:27 <DW2> Do you know any other graphic artist channel?
10:44:28 <copumpkin> DW2: instead, if you found a graphic artist channel, the percentage of graphic artists (and possibly non-idle ones) would be much higher :)
10:44:45 <DW2> Although I can't find one.
10:44:52 <copumpkin> DW2: other would imply that this is one :P but no, since I'm not a graphic artist and we're not affiliated with any
10:44:54 <DW2> bss03, why not?
10:45:34 <bss03> DW2: Can't tell you that either, it would spoil my fun.
10:46:09 <DW2> in this case, your fun means my misery.
10:47:02 <bss03> DW2: You might try a channel that is even slightly associated with the graphic arts.
10:47:02 <copumpkin> he's just kidding around
10:47:15 <Starfire> If you're looking for a game artist, you might want to try something like http://forums.tigsource.com/index.php?board=24.0
10:47:17 <luite> does anyone know a plot program that can output plots to some 3d output format?
10:47:28 <bss03> DW2: Haskell isn't really.  The closest it gets to graphics art is that an OpenGL library has been written for it.
10:47:30 <copumpkin> DW2: guilt tripping us isn't going to make a bunch of theoretical computer scientists and mathematicians magically know something about graphci design
10:47:47 <bss03> You might try #gimp
10:48:40 <bss03> Maybe also #krita and #inkscape
10:48:47 <Zao> Hug #gamedev?
10:48:58 <Zao> Or ask #freenodes?
10:49:11 <dpratt71> is 'exists' a valid quantifier (correct term?) in Haskell? perhaps enabling some language extension?
10:49:23 <copumpkin> dpratt71: unfortunately not in GHC haskell
10:49:26 <dpratt71> or must one formulate it via 'forall'
10:49:26 <copumpkin> I think JHC supports it
10:49:47 <copumpkin> you can do it semi-implcitly with a GADT too
10:50:01 <dpratt71> copumpkin: I see
10:50:07 <copumpkin> data IHAZSEKRIT where NOMINE :: a -> IHAZSEKRIT
10:50:11 <DW2> i think #gimp is most suitable.
10:50:23 <DW2> I think #gimp is most suitable.
10:50:25 <bss03> I think forall is the only standard quantifier.  I don't remember a syntax for "there exists" in the Haskell 2010 Report.
10:50:32 <DW2> oops.
10:50:36 <DW2> Typing mistake.
10:50:39 <copumpkin> there is none in 2010
10:50:44 <bss03> DW2: Cool, good luck.
10:50:45 <copumpkin> DW2: good luck :)
10:50:58 <bss03> DW2: I don't know who is the graphics artists in the room.
10:50:58 <Silvah> ?
10:51:04 <bss03> DW2: Hence why I couldn't tell you.
10:51:08 <DW2> Most should be.
10:51:13 <DW2> Since gimp is a editor.
10:51:27 <Zao> DW2: Except it's probably not topical there either.
10:51:30 <copumpkin> trolling is a art
10:51:39 <alc> @src nub
10:51:39 <lambdabot> nub = nubBy (==)
10:51:45 <alc> @src nubBy
10:51:46 <lambdabot> nubBy eq []             =  []
10:51:46 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:51:59 <Silvah> "a art"?
10:52:07 <Silvah> Not "an art"?
10:52:09 <copumpkin> Silvah: designed specially to make you shudder
10:52:13 <copumpkin> hence the trolling
10:58:32 <carter> question: whats the standard way to deal with cabal complaining about different libraries depending on diffferent versions when they're actually the same version?
10:59:06 <c_wraith> I've seen a lot of cabal errors, and I've never seen that one.
10:59:14 <Silvah> Crying?
10:59:54 <ezyang> carter: Try --reinstall'ing the offending package. 
11:00:09 <carter> and then inductively do the rest?
11:00:15 * copumpkin is so offended by that package
11:00:41 <carter> as far as I can tell, its the hash string stuff after the version number that differs
11:01:02 <carter> this only happened because i was reinstalling some stuff with the -p flag so i could profile...
11:01:21 <c_wraith> yeah...  You'll need to reinstall more stuff.
11:02:04 <c_wraith> I *really* wish there was a way to tell cabal "build the profiling version of that already-installed library, linking it the exact same way"
11:02:52 <c_wraith> What happened was you reinstalled some library that was able to depend on something newer you installed than last time you installed it.
11:02:53 <yitz> @hackage offending
11:02:54 <lambdabot> http://hackage.haskell.org/package/offending
11:03:13 <c_wraith> So the hash changed
11:03:19 <carter> so basically i should just iterate
11:03:23 <aristid> yitz: very funny
11:03:23 <carter> trying to build what i want
11:03:27 <carter> and then seeing what complains
11:03:32 <c_wraith> Which means that something depending on that library no longer works
11:04:09 <c_wraith> yeah.  You can repair this with enough package reinstalls, assuming you get them all to link together consistently
11:05:41 <carter> since -p build both versions, is it better to just always build with the -p flag?
11:06:02 <c_wraith> in order to get consistent linking, you probably will want to do something like "cabal install --reinstall package1-0.1 package2-1.3 packageX-version" so that cabal recognizes that it needs to link them all together consistently
11:06:24 <c_wraith> and yeah, typically the first thing I do after installing cabal-install is edit .cabal/config to always build profiling libs
11:06:28 <carter> cabal ensures consistency when you do that?
11:06:51 <c_wraith> yes, when you tell it to install multiple packages at once, it ensures consistency between all the packages on the command line
11:07:09 <carter> i never knew this
11:07:09 <Ging7> is there anyone there who could spend a little time with me in a porivate chat to help me understand something in haskell please
11:07:26 <carter> why isn't that in boldface caps in the cabal docs on the first page?
11:07:53 <kmc> Ging7, we prefer to answer questions in the channel so third parties can benefit and contribute
11:07:59 <kmc> a lot of people learn just by lurking here
11:08:06 <Ging7> oki
11:09:45 <Ging7> im doing a uni assignment and i have 6 (i thin smal tasks) one says "In a similar way to the function lenght show how the library function replicate thats produces a list of identical elements can be defined using a list comprehension
11:10:01 <Ging7> basicly i dont understand list comprehensions 
11:10:31 <mauke> whoa, how do you define length with list comprehensions?
11:10:45 <applicative> > [x + 1 | x <- [1,2,3]]
11:10:46 <lambdabot>   [2,3,4]
11:10:54 <c_wraith> > sum [1 | _ <- [1..10]]
11:10:55 <lambdabot>   10
11:11:11 <mauke> c_wraith: that's cheating
11:11:20 <c_wraith> I'm pretty sure that's the assignment
11:11:22 <Zao> Much of "implement foo with bar" is.
11:11:26 <c_wraith> As someone else was talking about it last night :)
11:11:34 <mauke> well, then replicate is easy
11:11:44 <c_wraith> yes, replicate is easy :)
11:11:53 <mauke> just change two tokens
11:11:55 <Ging7> i just dont understnd how list comprehensions work
11:12:27 <Ging7> the example they give for replicate is 
11:12:31 <Ging7> replicate 3 True
11:12:57 <mauke> > replicate 3 True
11:12:58 <lambdabot>   [True,True,True]
11:13:17 <mauke> Ging7: what do you not understand about them? i.e. where do your problems start?
11:14:10 <Ging7> pretty much the whole consept of list comprehension and how it works 
11:14:22 <jedai> Ging7: list comprehension in Haskell looks and acts much like set comprehension in math (if that helps you any)
11:14:32 <applicative> Ging7, you understand the ordinary list syntax, like [1,2,3,17]
11:14:37 <mauke> Ging7: well, I can't help you with that. you have to ask more specific questions
11:16:14 <jedai> Ging7: What's your background ?
11:16:23 <applicative> > [x + 1 | x <- [1,2,3]]
11:16:25 <lambdabot>   [2,3,4]
11:16:31 <applicative> > [x + 2 | x <- [1,2,3]]
11:16:32 <lambdabot>   [3,4,5]
11:16:41 <Ging7> i understnad other programming languages like PHP Java C C++ etc 
11:16:42 <applicative> > [x + 2 | x <- [1,2,3,4]]
11:16:42 <lambdabot>   [3,4,5,6]
11:16:47 <applicative> > [x + 2 | x <- [1,2,3,4,5]]
11:16:48 <lambdabot>   [3,4,5,6,7]
11:16:48 <Ging7> but haskell i find hard 
11:16:59 <mauke> Ging7: have you seen a for loop before?
11:17:12 <Ging7> i think i understand the basics like how to use basic function and how to write some of my own but nothing to advanced
11:17:17 <Ging7> yeah
11:17:18 <applicative> Ging7, do those four ^^^ list comprehensions make sense to you?  
11:17:22 <carter> so what are generally good defaults for .cabal/config
11:17:23 <carter> ?
11:17:56 <Ging7> no i dont understand the examples that you have put up 
11:18:00 <c_wraith> carter: I only change the setting for profiling libs.  Others like to set it to build docs automatically.  It really depends on what you're doing.
11:18:08 <jedai> carter: the one that comes by default ? It depends on your needs and wants (doc ? profiling ? global install ?)
11:18:20 <Cale> Ging7: The languages you listed are very similar to one another, in that they all have similar syntax, and the way in which you describe computations is almost the same in each.
11:18:25 <mauke> Ging7: it loops over [1,2,3], setting x to each element in turn
11:18:43 <carter> jedai: fair enough, i was asking in the context of my earlier question though :)
11:18:45 <Cale> Ging7: Haskell really is different not just in its syntax, but in the way in which computations are described.
11:18:51 <mauke> I mean [ x + 1 | x <- [1,2,3] ]. and the x + 1 is the result of each iteration
11:19:02 <medfly> Cale, that's called syntax, stupid
11:19:11 <mauke> medfly: what
11:19:18 <medfly> "the way in which computations are described"
11:19:21 <mauke> medfly: no
11:19:24 <Cale> medfly: no
11:19:26 <mauke> that's semantics
11:19:28 <carter> he means semantics meaybe?
11:19:41 <copumpkin> medfly: it's better to be more respectful
11:19:52 <medfly> that's okay, I'm respectful, just not towards Cale
11:19:59 <copumpkin> medfly: well, you should be
11:20:11 <applicative> Ging7, so where you had [1,2,3]  the comprehension [x+1 | x <- [1,2,3]] gives you [2,3,4] instead.  [x+1 | x <- [1,2,3]]  is the list that adds 1 to each member of [1,2,3]
11:20:17 <Ging7> to be honist im not sure if the question is asking me to rewrite the function replicate using list comprehension or to explain how it works lol
11:20:38 <mauke> Ging7: the former
11:20:55 <mauke> "show how X can be defined" == "define X"
11:21:05 <Phyx-> hrm.. these numbers are really odd
11:21:17 <ski> Ging7 : another example : `[ x * x + 1 | x <- [2,3,5] ]' is the same as `[ 2 * 2 + 1 , 3 * 3 + 1 , 5 * 5 + 1 ]', which simplifies to `[ 4 + 1 , 9 + 1 , 25 + 1 ]', which simplifies to `[ 5 , 10 , 26 ]'
11:21:25 <Cale> In imperative languages, you write programs primarily by describing an ordered sequence of steps, each of which has some effect. In functional languages, you primarily describe what you want to compute using expressions, and the order of evaluation is implicit, or left up to the compiler.
11:21:27 <Ging7> i understand what your examples are doing i just dont understand how 
11:21:42 <mauke> Ging7: well, the part to the right of | is done first
11:22:11 <kmc> Ging7, the basic syntax of comprehensions is  [ what to build | what to loop over ]
11:22:17 <Ging7> ok so something like x<-[1,2,3] is first run
11:22:19 <mauke> you can think of [x + 1 | x <- [1,2,3]] as: foreach x in ([1,2,3]) { yield x + 1; }
11:22:24 <kmc> on the right side of the | you pull values out of some lists using <-
11:22:30 <Phyx-> so... according to this, http://phyx.pastebin.com/vZbi2KPE FFI has no overhead?
11:22:31 <kmc> on the left side of the bar you use those variables you defined
11:22:34 <aavogt> > [ () | False ]
11:22:35 <lambdabot>   []
11:23:04 <Ging7> ok so 
11:23:04 <kmc> as aavogt demonstrated, the right side can also have Boolean true/false expressions, which act like filters -- it throws out elements for which they're false
11:23:12 <kmc> > [ x | x <- [1..10], even x ]
11:23:13 <lambdabot>   [2,4,6,8,10]
11:23:17 <Ging7> [x +1|[1,2,3]] would be like 
11:23:22 <kmc> you need to bind x
11:23:26 <Ging7> [1+1, 1+2, 1+£]
11:23:27 <mauke> Ging7: x is not defined there
11:23:28 <kmc> > [ x+1 | x <- [1,2,3]]
11:23:29 <lambdabot>   [2,3,4]
11:23:40 <applicative> [x +1 | x <- [1,2,3]
11:23:43 <kmc> "the list of elements of the form x+1, where x comes from [1,2,3]"
11:23:49 <kmc> that's how you read it Ging7
11:24:21 <applicative> or "go through the list [1,2,3] and replace each member with (itself + 1)" crudely
11:24:30 <Ging7> ok so how would the replicate function be written?
11:24:34 <ski> Ging7 : so, the `x * x + 1' there corresponds to a loop body `..x..' in `for (...) {..x..}' in C, while the `x <- [2,3,5]' would correspond to the "control part" of `for (int_list xs = make_int_list(2,3,5); int_list_is_empty(xs); xs = int_list_tail(xs)) {int x = int_list_head(xs); ..x..}'
11:24:56 <jedai> > [ (x,y) | x <- [1..3], y <- [1..x] ]
11:24:57 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
11:25:10 <kmc> > [ 'q' | _ <- [1..5] ]
11:25:11 <lambdabot>   "qqqqq"
11:25:16 <kmc> Ging7, ^^^^ replicate-like
11:25:21 <ski> > [ 100 * x + y | x <- [1..3], y <- [1..x] ]
11:25:22 <lambdabot>   [101,201,202,301,302,303]
11:25:22 <kmc> note that we use _ instead of a variable
11:25:23 <applicative> jedai, we're a step below that!
11:25:26 <kmc> meaning "throw out the value"
11:25:30 <kmc> but the looping is still done
11:25:38 <jedai> Ging7: As you see you can also have several bindings in the right part and it acts a bit like nested for loop
11:25:44 <Ging7> if i right _ is a wildcard
11:25:50 <kmc> yes
11:25:58 <kmc> _ is the pattern which matches anything and binds no variables
11:26:06 <mauke> _ is an unvariable
11:26:30 <mauke> it behaves like a variable in that you can bind values to it, but you can't actually use it in expressions
11:26:32 <applicative> we can use const 'q' too though, if thats clearer
11:26:36 <ski> `_' is the always succeeding pattern, the unit to the `@' operator
11:26:42 <mauke> ski: pfft
11:26:43 <acowley> What is the syntax for default associated type synonym defaults?
11:26:49 <acowley> default
11:26:52 <applicative> > [const 'q' x | x <- [1,2,3,4,5]]
11:26:53 <lambdabot>   "qqqqq"
11:26:55 <kmc> acowley, i don't think GHC has them :/
11:27:09 <kmc> well you're also free to bind x without using it
11:27:13 <applicative> > const 'q' 3
11:27:14 <lambdabot>   'q'
11:27:16 <acowley> kmc: I tried and just got an error message "Type declaration in a class must be a kind signature or synonym default"
11:27:16 <applicative> > const 'q' 2
11:27:17 <lambdabot>   'q'
11:27:19 <kmc> > [ 'q' | x <- [1..5]]
11:27:20 <lambdabot>   "qqqqq"
11:27:24 <kmc> acowley, strange!
11:27:38 <acowley> I guess they don't work
11:27:43 <Ging7> i think im understnading it better
11:28:25 <applicative> Ging7, the other thing you might need to write replicate is the [1..5] or [2..6] syntax
11:28:33 <applicative> > [1..5]
11:28:34 <lambdabot>   [1,2,3,4,5]
11:29:56 <Ging7> how do u mean?
11:30:11 <kmc> [1..5] is shorthand for [1,2,3,4,5]
11:30:28 <kmc> (technically it is shorthand for (enumFromTo 1 5), which function call evaluates to that list)
11:30:46 <Ging7> yeah i know the .. thing
11:30:49 <kmc> cool
11:31:03 <jedai> (and technically it works for all instances of the Enum type class, Int being such)
11:31:11 <applicative> > ([const 'q' x | x <- [1..1]] , [const 'q' x | x <- [1..2]] , [const 'q' x | x <- [1..3]], [const 'q' x | x <- [1..4]] , [const 'q' x | x <- [1..5]])
11:31:12 <lambdabot>   ("q","qq","qqq","qqqq","qqqqq")
11:31:13 <kmc> > ['a' .. 'z']
11:31:14 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
11:31:51 <aavogt> > let replq n = [ 'q' | n > 0 ] : replq n in replq 100
11:31:52 <lambdabot>   ["q","q","q","q","q","q","q","q","q","q","q","q","q","q","q","q","q","q","q...
11:31:57 <Starfire> > take 10 [False..]
11:31:57 <lambdabot>   <no location info>: parse error on input `]'
11:31:58 <aavogt> > let replq n = [ 'q' | n > 0 ] ++ replq n in replq 100
11:31:59 <lambdabot>   "qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq...
11:32:01 <applicative> > ([const 17 x | x <- [1..1]] , [const 17 x | x <- [1..2]] , [const 17 x | x <- [1..3]], [const 17 x | x <- [1..4]] , [const 17 x | x <- [1..5]])
11:32:02 <lambdabot>   ([17],[17,17],[17,17,17],[17,17,17,17],[17,17,17,17,17])
11:32:31 <Starfire> > take 10 [False ..]
11:32:32 <lambdabot>   [False,True]
11:32:33 <jedai> aavogt: that's repeat if n > 0
11:32:41 <carter> ok, i'm not modifying this correctly, for the config file do i uncomment the line library-profiling: True
11:32:50 <carter> because that isn't doing it
11:33:04 <applicative> > ([17 | x <- [1..1]] , [17 | x <- [1..2]] , [17  | x <- [1..3]], [17| x <- [1..4]] , [17| x <- [1..5]])
11:33:05 <lambdabot>   ([17],[17,17],[17,17,17],[17,17,17,17],[17,17,17,17,17])
11:33:07 <aavogt> jedai: oh, there's supposed to be a pred in there. But that one doesn't end with a [], it ends with undefined
11:33:19 <aavogt> > let replq n = [ 'q' | n > 0 ] ++ replq (n-1) in replq 100
11:33:23 <lambdabot>   mueval-core: Time limit exceeded
11:33:37 <carter> got it, there was a leading space
11:33:39 <aavogt> interesting
11:33:40 <carter> thanks :)
11:34:08 <aavogt> > let replq n = [ 'q' | n > 0 ] : concat( replq (n-1) ) in replq 100
11:34:09 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:34:09 <lambdabot>         against inferred ty...
11:34:13 <Ging7> here is my attempt to rewrite the replicate function but im guessing its wrong
11:34:15 <Ging7> rep    :: Int -> a -> [a]
11:34:18 <applicative> > replicate 0 17
11:34:19 <lambdabot>   []
11:34:19 <jedai> aavogt: well there's an infinity of [] at the end
11:34:23 <Ging7> rep a b = ['b'|_<- [1..a]
11:34:35 <applicative> @type replicate
11:34:36 <lambdabot> forall a. Int -> a -> [a]
11:34:40 <mauke> Ging7: you're missing a ] at the end
11:34:58 <aavogt> > ["abc"] ++ repeat []
11:34:58 <lambdabot>   ["abc","","","","","","","","","","","","","","","","","","","","","","",""...
11:35:10 <aavogt> > ["abc"] ++ cycle []
11:35:11 <lambdabot>   ["abc"*Exception: Prelude.cycle: empty list
11:35:19 <c_wraith> hahaha
11:35:23 <ski> > let  rep :: Int -> a -> [a]; rep a b = ['b'|_<- [1..a]]  in  rep 10 '!'
11:35:23 <lambdabot>   Couldn't match expected type `a'
11:35:24 <lambdabot>         against inferred type `GHC.Types.C...
11:35:27 <aavogt> > "abc" ++ concat(repeat [])
11:35:30 <jedai> aavogt: so I guess if it's an infinite list it works better since it can just stop evaluating when it has enough to output but with an infinity of [] at the end it just can know if it ends
11:35:31 <lambdabot>   mueval-core: Time limit exceeded
11:36:17 <Ging7> rep  :: Int -> a -> [a]
11:36:18 <ski> Ging7 : you should not confuse  b  and  'b'  the former is a variable name, but the latter is a character
11:36:26 <applicative> Ging7 you're making a list so you need [  blah ]  but you're drawing from a list so you need matching brackets inside too.  [ b | _ <- [1..a]] 
11:36:31 <jedai> aavogt: it's more of a (concat (repeat []))
11:36:33 <Ging7> this i think should say that the function takes an integer and a char and returns a list
11:36:38 <Ging7> is this part correct
11:36:38 <roconnor> @wiki IO_Semantics
11:36:39 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
11:36:41 <ski> @type let  rep a b = ['b'|_<- [1..a]]  in  rep
11:36:42 <lambdabot> forall t t1. (Enum t, Num t) => t -> t1 -> [Char]
11:36:48 <jedai> aavogt: oops you had it :)
11:36:51 <mauke> Ging7: no, "a" is not "Char"
11:37:07 <Ging7> well it should actuall be a string 
11:37:08 <applicative> >  let rep a b = ['b'|_<- [1..a]] in rep 17 4
11:37:08 <lambdabot>   "bbbbbbbbbbbbbbbbb"
11:37:13 <ski> Ging7 : see how you got `[Char]' instead of `[a]', there ? .. that's because you used  'b'  rather than  b
11:37:13 <Ging7> > replicate 3 True
11:37:14 <lambdabot>   [True,True,True]
11:37:21 <mauke> Ging7: it's correct, but it says the function takes an integer and any value at all, and returns a list of those values
11:37:39 <aavogt> > [] : concat (repeat [])
11:37:43 <lambdabot>   mueval-core: Time limit exceeded
11:37:47 <applicative> > replicate 5 'a'
11:37:47 <lambdabot>   "aaaaa"
11:37:52 <applicative> > replicate 5 5
11:37:53 <lambdabot>   [5,5,5,5,5]
11:38:03 <applicative> > replicate 5 "HAHAHA!"
11:38:04 <Ging7> ok as long as it returns repeate list of anything thats fine 
11:38:04 <lambdabot>   ["HAHAHA!","HAHAHA!","HAHAHA!","HAHAHA!","HAHAHA!"]
11:38:04 <aavogt> > replicate 100 [] Prelude.++ concat (repeat [])
11:38:05 <lambdabot>   Not in scope: `Prelude.++'
11:38:29 <Ging7> rep a b = ['b'|_<- [1..a]]
11:38:39 <Ging7> this i think is kinda wrong but hopefully kinda close
11:38:45 <ski> @type (Prelude.++)  -- huh ?
11:38:46 <lambdabot> forall a. [a] -> [a] -> [a]
11:39:00 <mauke> Ging7: you're not using your second function parameter, b
11:39:03 <aavogt> ski: type is different?
11:39:11 <applicative> do you want Prelude.(++) ?
11:39:14 <jedai> Ging7: 'b' is a character, not the b parameter
11:39:39 <Ging7> so b needs the quotes removed
11:39:44 <applicative> Ging7, yes
11:39:49 <ski> > Nothing ++ Nothing :: Maybe String
11:39:49 <lambdabot>   Nothing
11:39:57 <mauke> this works pretty much like in C
11:40:03 <Ging7> now a should make the list repeate upto the number entered by the user
11:40:13 <aavogt> > (Prelude.++)
11:40:14 <lambdabot>   Not in scope: `Prelude.++'
11:40:17 <ski> aavogt : no, `(Prelude.++)' not being in scope for `run', but being in scope for `type'
11:40:25 <aavogt> > Prelude.(++)
11:40:25 <lambdabot>   Not in scope: data constructor `Prelude'
11:40:32 <applicative> 'b' is a plain thing the name of the Char 'b'.  but if you just write b, you're using a 'variable', you're matching with the b in _ <- [1..b]
11:40:37 <ski> (the correct syntax is `(Prelude.++)')
11:40:47 <applicative> sorry, not quite right
11:41:13 <ski> > 'b'
11:41:14 <aavogt> http://haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#new-qualified-operators
11:41:14 <applicative> you're matching with whatever is given as the second argument in rep a b
11:41:14 <lambdabot>   'b'
11:41:22 <ski> > let b = 42 in b
11:41:23 <lambdabot>   42
11:41:26 <ski> > let b = 42 in 'b'
11:41:27 <lambdabot>   'b'
11:41:34 <Ging7> ok it loads but i get NOt in scope: 'whatever i wanted to replicate'
11:41:43 <mauke> Ging7: how are you calling it?
11:41:52 <Ging7> rep 3 hello
11:41:55 <applicative> in your actual definition, you're throwing out the second argument, and getting a list of characters 'b' instead
11:42:00 <mauke> Ging7: you didn't define a variable called hello
11:42:07 <mauke> did you mean "hello"?
11:42:10 <applicative> Ging7, it doesn't know your definition
11:42:24 <mauke> applicative: :-|
11:42:38 <ski> @let repGing7 a b = ['b'|_<- [1..a]]
11:42:39 <lambdabot>  Defined.
11:42:46 <applicative> > let rep a b = ['b'|_<- [1..a]] in rep 100 "hahaha"
11:42:46 <ski> > repGing7 3 "hello"
11:42:46 <lambdabot>   "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb...
11:42:47 <lambdabot>   "bbb"
11:42:57 <Ging7> ah i c so i needed the quotes for it to work or single for chars
11:43:00 <applicative> > let rep a b = ['b'|_<- [1..a]] in rep 100 "October"
11:43:01 <lambdabot>   "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb...
11:43:11 <applicative> > let rep a b = ['b'|_<- [1..a]] in rep 100 Nothing
11:43:12 <lambdabot>   "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb...
11:43:24 <Ging7> its working now and i think i understnad it 
11:43:26 <mauke> Ging7: again, this part is exactly like C or Java :-)
11:43:36 <mauke> variables, chars, strings
11:43:42 <mauke> it's just the rest that's completely different
11:43:43 <Lemmih> Ging7: hello is a variable, "hello" is a String, 'H' is a Char.
11:43:54 <Ging7> basicly it should be saysing repeat b into a list from 1 to a
11:44:26 <applicative> > let rep a b = [ b | hello <- [1..a] ] in rep 5 "Hahah!"
11:44:27 <lambdabot>   ["Hahah!","Hahah!","Hahah!","Hahah!","Hahah!"]
11:44:55 <applicative> > let rep a b = [ b | thisisaverylongvariable <- [1..a] ] in rep 5 "Hahah!"
11:44:56 <lambdabot>   ["Hahah!","Hahah!","Hahah!","Hahah!","Hahah!"]
11:45:49 <applicative> > let rep a b = [ b | thisisaverylongvariable <- [1..a] ] in rep 2 "thisisanotsolongstring"
11:45:50 <lambdabot>   ["thisisanotsolongstring","thisisanotsolongstring"]
11:46:30 <mauke> > let rep a b = [ b | _ <- [1..a] ] in rep 0 "where is your god now?"
11:46:31 <lambdabot>   []
11:46:40 <applicative> > let rep uglyvariable stupidvariable = [ stupidvariable  | thisisaverylongvariable <- [1..uglyvariable] ] in rep 2 "thisisanotsolongstring"
11:46:41 <lambdabot>   ["thisisanotsolongstring","thisisanotsolongstring"]
11:46:53 <napping> what are you up to?
11:47:00 <napping> logs are not illuminating
11:47:01 <applicative> mauke, why does it work for 0, that's what I was going to ask?
11:47:03 <Zao> If you could terminate the comprehension with a condition, it could be more succinct.
11:47:12 <applicative> napping, we're explaining list comprehensions to Ging7
11:47:13 <mauke> applicative: [1..0] == []
11:47:25 <ski> > [3 .. 1]
11:47:26 <lambdabot>   []
11:47:29 <applicative> > [1..2]
11:47:30 <lambdabot>   [1,2]
11:47:35 <applicative> > [1..1]
11:47:36 <lambdabot>   [1]
11:47:39 <applicative> > [1..0]
11:47:40 <lambdabot>   []
11:47:45 <ski> > [ maxBound .. minBound ] :: [()]
11:47:45 <lambdabot>   [()]
11:47:49 <ski> > [ maxBound .. minBound ] :: [Int]
11:47:50 <lambdabot>   []
11:47:51 <applicative> okay, I get it
11:47:59 <applicative> > [1..-1]
11:48:00 <lambdabot>   Not in scope: `..-'
11:48:06 <applicative> > [1..(-1)]
11:48:07 <lambdabot>   []
11:48:21 <mauke> wtf, what do people have against whitespace?
11:48:22 <ski> > [-3 .. 4]
11:48:23 <lambdabot>   [-3,-2,-1,0,1,2,3,4]
11:48:26 <mauke> > [1 .. -1]
11:48:27 <lambdabot>   []
11:48:45 <ski> mauke : me loves it :)
11:49:09 <Ging7> what is the server address for this chat please?
11:49:12 <applicative> mauke, but we thought Haskell was supposed to be very terse
11:49:16 <mauke> today's exercise: prove the whitespace-free subset of C turing complete
11:49:28 <mauke> Ging7: huh? do you mean chat.freenode.net?
11:49:33 <ski> Ging7 : irc.freenode.net, #haskell ?
11:49:35 <Ging7>  thats it
11:49:44 <Ging7> i pressume its 6667?
11:49:47 <ski> yes
11:50:18 <vanadium> b-but you cannot even write int main(){ without whitespace
11:50:49 <mauke> vanadium: yes, you can
11:50:58 <arw> is there a trigraph for space?
11:51:03 <arw> then its easy...
11:51:05 <mauke> arw: no
11:51:06 * ski . o O ( "main(){...}" )
11:51:08 <napping> mauke: It's not interesting if you don't count comments as whitespace
11:51:16 <mauke> napping: right, that's the trivial solution
11:51:19 <vanadium> If this is about omitting return types I am going to pelt you with gcc flags
11:51:27 <Ging_> Top now got tis irc on my client :)
11:51:28 <mauke> vanadium: nope
11:51:31 <vanadium> if int(main)() is actually right...
11:52:01 <napping> Anyway, I'm trying to figure out how to do a design where a tree has extra data hanging off the side
11:52:06 <ski> (vanadium : .. maybe "(int)main()" ?)
11:52:10 <napping> like, results from an extensible set of dataflow analyses
11:52:17 <vanadium> That makes the subset really close to the one that does not use the preprocessor
11:52:34 <napping> I think Scala could to a prety good job with subset constraints and stuff
11:53:12 <napping> that is, I have various analyses which assume various other analyses are also being performed
11:53:19 <napping> and I'd like to define it all in a modular way
11:53:45 <applicative> > let a=[x*x|x<-[1..4]];b=[a,a];c=[a]:[b]in c -- for napping
11:53:46 <lambdabot>   [[[1,4,9,16]],[[1,4,9,16],[1,4,9,16]]]
11:53:56 <Ging_> offtopic: anyone used empathy IM and is it better than pidgen?
11:55:19 <Twey> I have, it's not
11:55:19 <Twey> Feature-wise, it's basically like a stripped-back Pidgin â it's missing a lot of Pidgin's features.
11:55:19 <ski> > let{a=[x*x|x<-[1..4]];b=[a,a];c=[a]:[b]}in(c)
11:55:21 <lambdabot>   [[[1,4,9,16]],[[1,4,9,16],[1,4,9,16]]]
11:55:21 <napping> Ging_: for IRC? I haven't looked into them particularly deeply, but I use irssi
11:56:23 <ski> lambdabot: @hello
11:56:23 <lambdabot> Maybe you meant: help tell
11:56:37 <Ging_> for irc i use xchat
11:57:01 <Ging_> but i have empathy preinstalled on my ubuntu system and wondering wether to remove it 
11:57:03 * ski appears to lag a bit, atm ..
11:57:12 <Ging_> sounds like pidgen without the addons so im gonna remove it 
11:57:36 <napping> so, one trick is to parameterize the type over a wrapper for the recursion
11:58:40 <napping> and then use some kind of type level stuff to hang off a list of annotations
11:58:41 <ski> napping : are you talking about IndirectComposite ?
11:58:45 <napping> yes, perhaps
11:59:04 <napping> although it's a bit more complicated because I've split my syntactic categories into different types
11:59:20 <napping> maybe I could smoosh them back together into a GADT
12:00:06 <napping> I've been reading Terence Parr's language processing book, which recommends less structured AST and tree patterns for a lot of stuff
12:00:30 <ski> @wiki Indirect composite
12:00:30 <lambdabot> http://www.haskell.org/haskellwiki/Indirect_composite
12:01:21 <napping> ski: yes, I think it was an email of mine that convinced SPJ to extend type class resolution to handle that sort of thing :)
12:02:34 <napping> that is, to be able to use instances like (Show (f (Mu f))) => Show (Mu f) and (Show a) => (Show (f a)) to deduce Show (Mu f)
12:03:23 * ski would still like to be able to say things like `instance (forall a. Show a => Show (f a)) => Show (Mu f) where ...', though
12:03:53 <Njh> hey, does anyone know how to get coprimes of numbers?
12:03:55 <ski> (i.e. "Rank-2/`N'" for contexts)
12:04:00 <acowley> My resursive type family isn't working :(
12:04:21 <napping> acowley: they break if they expand to infinite type expressions, I think
12:04:29 <acowley> It should be finite
12:04:37 <acowley> It looks like it's just not evaluating
12:04:51 <napping> paste?
12:04:52 <acowley> I think/hope I just must be missing a case
12:05:05 <acowley> napping: I let the program get long, I'll try to cut it down
12:05:26 <napping> what's "isn't working"?
12:05:28 <napping> type errors?
12:05:54 <acowley> I suppose you could say that. I'm doing a recursive descent down a list at the type level.
12:06:06 <acowley> But the tail of the list isn't evaluating to a list.
12:06:14 <napping> Be more specific about the symptoms of "not working"
12:06:26 <acowley> So it sees the head, then fails to match the tail.
12:06:34 <napping> might be something about injectivity, might be eagerness of the unfolding, might be something else
12:06:46 <acowley> Yeah, I was being a bit facetious there; just ranting.
12:06:59 <acowley> I'll try to extract a smaller program 
12:07:01 <napping> ski: that was suggested way back then too. apparently it's more complicated or something
12:07:22 <napping> changes to allow mutually recursive dictionaries to be produced was said to be just swapping two lines of code
12:09:38 <ski> (i suppose we should keep our eyes open for applications of higher-rank contexts that can't be (easily) written without them (including the above generalized resolution))
12:12:34 <Njh> does anyone know about the module ArithmeticFunctions
12:15:48 <acowley> d'oh... I needed to give my base types a tag even though they're supposed to be totally opaque.
12:15:59 <acowley> Say you want a type family that recurses into a structure
12:16:34 <acowley> Even if you have just one type that can be involved in the structure, say, P. So, for example, I might have a type (P (P a b) c)
12:16:52 <napping> yeah, a distinct Nil usually helps
12:16:55 <acowley> If I want my type functions to recurse through that structure, I can peel off the P type constructor, but I can' recognize bottom
12:16:59 <acowley> it's not just Nil
12:17:07 <acowley> I shouldn't have said bottom
12:17:09 <acowley> I mean a base type
12:17:32 <acowley> type instance Peel (P a b) = ...recurse...
12:17:38 <acowley> type instance Peel a = ...not allowed...
12:18:06 <acowley> If all my type variables are of some made up scalar type
12:18:15 <acowley> then I can match that and stop the recursion 
12:19:25 <napping> if you are searching for a value
12:19:42 <napping> with type classes at least, you can have an overlapping instance like Find x x to cover a base
12:20:14 <acowley> hm, I thought I'd tried with a class earlier
12:21:17 <napping> you just need overlapping instances
12:21:36 <napping> actually, I don't think you need anything it won't suggest you add
12:21:51 <napping> I'm just doing injection and projection like data types ala-cart
12:22:21 <napping> so it's like class InList x union where inj :: x -> union; proj :: union -> Maybe x
12:22:33 <acowley> Well, with type families I get a "Conflicting family instance declaration"
12:22:42 <napping> oh, I guess they don't do overlaps
12:25:01 <EvanR-work> holy crap this channel has a lot of traffic
12:25:11 <EvanR-work> i accidentally was scrolled up since yesterday
12:26:29 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28841#a28841
12:26:32 <int80_h> w00t
12:26:56 <acowley> wow
12:27:09 <acowley> type families are a pain
12:27:41 <napping> are you any closer to having something pruned?
12:27:57 <acowley> On the bright side, I can now have a fact encoded in a type that (Max a b) >= (Max a (Max a b))
12:28:10 <acowley> napping: Adding a Scalar type constructor was my problem
12:28:27 <napping> oh, okay then
12:28:32 <napping> what are you comparing them to?
12:28:32 <acowley> The recursion through the type structure was failing because it when it got to the bottom it bombed out
12:28:42 <acowley> The error message then showed the tail of the list
12:28:43 <napping> they seem nicer for computation type things than fundeps
12:29:08 <napping> maybe not as nice as full dependent types
12:29:18 <acowley> Well, what I wanted to do is to perform some tropical algebra on some quantities I have, rates of stream transmissions in this case, and have assertions about the algebraic combinations.
12:29:20 <napping> but even there it can be a bit of pain coming up with a universe
12:29:22 <acowley> So now I can do that.
12:29:33 <acowley> I have sums and min- and max- products
12:29:34 <copumpkin> napping: it takes at least 7 days
12:29:35 * hackagebot testpack 2.0.1 - Test Utililty Pack for HUnit and QuickCheck  http://hackage.haskell.org/package/testpack-2.0.1 (JohnGoerzen)
12:29:53 <acowley> So I can perform operations on things that have an attached, opaque, frequency
12:30:02 <acowley> and then say something about the result in terms of what you started with
12:30:37 <napping> why are you trying to do that in Haskell?
12:30:38 <acowley> Unfortunately, I don't know if it will prove useful enough or easy enough to use.
12:30:48 <acowley> The error messages for a failed assertion are enormous
12:30:48 <napping> I don't want to think about doing analysis in types
12:31:04 <napping> at least, not haskell class gunk
12:31:26 <acowley> napping: Well I have this system in Haskell, and I noticed that some of my operations have this algebraic structure to them
12:31:29 <EvanR-work> haskell class attack cruister
12:31:40 <Philonous> copumpkin: 6, actually. He took the 7th day off. 
12:31:47 <acowley> napping: So I thought, "Wouldn't it be neat to reflect that structure in the types."
12:31:51 <copumpkin> Philonous: shows how much I know :)
12:31:52 <acowley> napping: Which was, of course, a mistake
12:31:57 <acowley> napping:  :)
12:32:08 <mreh> @src Applicative ZipList
12:32:08 <lambdabot> Source not found. Do you think like you type?
12:32:32 <acowley> napping: But if I can sneak it in without adding any extra burden to the user, I may do so because it is kind of snazzy.
12:32:36 <napping> what leads to a max of frequencies?
12:32:37 * hackagebot shaker 0.3 - simple and interactive command-line build tool  http://hackage.haskell.org/package/shaker-0.3 (AnthoninBonnefoy)
12:32:43 <mreh> pure f = replicate f?
12:32:55 <acowley> It's not an absolute max, it's the maximum of a pair
12:32:58 <EvanR-work> :t pure
12:32:59 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
12:33:04 <EvanR-work> :t replicate
12:33:05 <mreh> :t replicate
12:33:05 <lambdabot> forall a. Int -> a -> [a]
12:33:05 <lambdabot> forall a. Int -> a -> [a]
12:33:06 <acowley> So consider interleaving two streams of data
12:33:12 <napping> if that's the rate at which updates arrive
12:33:12 <mreh> :t repeat
12:33:13 <lambdabot> forall a. a -> [a]
12:33:18 <napping> I don't see what would lead to a max
12:33:19 <acowley> and suppose they are arriving at different rates
12:33:21 <mreh> pure = repeat
12:33:39 <McManiaC> hey guys, I'm having a problem with "cabal haddock". I can install my lib fine, but when I try to generate haddock docs I get a "The last statement in a 'do' construct must be an expression" error
12:33:45 <McManiaC> anyone know why this could happen/how to dbueg this?
12:33:53 <chrisdone> strange bug
12:33:55 <acowley> One option for merging them is to wait until you've received a new element on each stream, dropping elements from the faster stream until an element on the slow stream arrives
12:33:58 <EvanR-work> a -> [a] is required to be repeat?
12:33:59 <acowley> this leads to a min
12:34:19 <EvanR-work> it could be []
12:34:20 <napping> oh, a min formulation of tropical algebra
12:34:20 <mreh> EvanR-work: well for a ZipList Applicative instance
12:34:21 <napping> ok
12:34:22 <acowley> Another option is to deliver elements whenever either stream produces something
12:34:25 <acowley> that would be a sum
12:34:40 <acowley> Another option is to produce tuples at hte rate of the faster stream, reusing elements from the slower stream as needed
12:34:43 <acowley> that leads to a max
12:34:58 <napping> that assume you know which one is faster?
12:34:59 <acowley> So I have these abstract combinators for my streams
12:35:18 <acowley> Not knowing that just limits what you can say
12:35:38 <napping> seems like it should give exactly the update rate of the dominant stream
12:35:39 <acowley> You get very silly facts like: max a b >= a
12:35:49 <acowley> without knowing anything about a or b
12:35:59 <monochrom> McManiaC: That's strange. Recent haddock uses ghc to parse, should have the same parse errors or absence of.
12:36:05 <acowley> But those facts can become more interesting the more sums and products you take
12:36:25 <McManiaC> monochrom: I will try to update cabal/haddock, although I'm at most 1 or 2 versions behind
12:36:35 <acowley> and if, at the end of a bunch of operations, you want to know how your composite stream compares to one of its components, you can do so using all this type level algebra
12:36:42 <napping> McManiaC: are you sure the package built properly? sounds like a syntax error
12:36:59 <monochrom> Recent haddock comes with ghc already. :)
12:37:04 <McManiaC> napping: yes, I can even use it in my example.hs
12:37:42 <napping> pretty strange then, try upgrading haddock
12:37:55 <monochrom> (err, not enough modal operators. recent haddock comes with recent ghc :) )
12:38:03 <McManiaC> http://npaste.de/fi/ â the complete build log
12:38:15 <McManiaC> ghc 6.12.1
12:38:44 <napping> well, have you looked at that line?
12:38:53 <McManiaC> yes, its fine
12:39:10 <monochrom> perhaps TH still confuses haddock
12:39:53 <McManiaC> http://npaste.de/fj/#n25 â line 25 is line 285 ^^
12:41:53 <napping> could be the TH stuff?
12:42:35 <yescalona> haskell rules
12:43:00 <napping> if the '' are treated as a syntax error and close blocks early
12:43:07 <napping> then you'd be left with that let as the last thing in the do
12:43:25 <monochrom> then again Ferry.TH is pretty much plain haskell. it's Ferry.QQ that uses the quotations.
12:43:33 <McManiaC> hm
12:43:40 <napping> Ferry.TH does use the ''Name syntax
12:43:55 <monochrom> oh oops
12:44:08 <McManiaC> yup, there are a few 'Q etc 
12:44:26 <McManiaC> but I used it before and it worked fine
12:44:33 <lantti> Is there a ready or almost ready functional logic package for haskell? I tried hackage, but it didn't catch my eye...
12:44:41 <napping> McManiaC: in Haddock?
12:44:58 <napping> lantti: like Mercury?
12:45:14 <lantti> Yes, something like that.
12:45:30 <monochrom> look for "logict"
12:45:56 <monochrom> the "t" stands for "monad transformer"
12:46:26 <napping> that's a backtracking search monad
12:46:38 <napping> I don't think there is anything that does unification nicely
12:46:44 <McManiaC> napping: yep
12:46:54 <McManiaC> is there a way to update haddock?
12:47:04 <McManiaC> or is it a part of cabal/ghc?
12:47:08 <napping> oh, you haven't done that yet?
12:47:11 <napping> when did you get it?
12:47:16 <napping> how, rather
12:47:36 <napping> If you can clean up the old version you could cabal install a new one
12:48:47 <McManiaC> napping: are you talking with me? :D
12:50:14 <McManiaC> http://npaste.de/fk/ :S
12:50:18 <McManiaC> still doesnt work
12:52:47 <McManiaC> gonna try the latest darcs version and if it doesnt work send a mail to the haddock ML
12:54:07 <napping> looks recent enough
12:54:36 <napping> at least, it claims to use the GHC API
12:55:30 <int80_h> 6.demon.co.uk] has joined #haskell
12:55:31 <int80_h> 12:54 -!- araujo [~araujo@gentoo/developer/araujo] has joined #haskell [12:55] [int80_h(+i)] [4:freenode/#haskell(+CLnt)]                             
12:55:35 <int80_h> sorry
12:55:38 <mreh> what is Applicative in IO all about?
12:55:57 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28841#a28841
12:56:02 <int80_h> that's better
12:57:56 <roconnor> mreh: how do you mean?  Every monad is applicative
12:58:07 <Ging_> im looking to write a function that takes an int and returns and int list func :: Int ->[Int]
12:58:16 <applicative> mreh, what's wrong with (++) <$> readFile "a.txt" <*> readFile "b.txt" >>= writeFile "a+b.txt" ?
12:58:41 <monochrom> applicative explains Applicative :)
12:58:44 <EvanR-work> func = repeat
12:58:48 <EvanR-work> is one
12:59:05 <monochrom> "func = const []" is simpler
12:59:13 <Ging_> the function needs to discover prime numbers in order and to each number run the formula 2^Prime - 1 (2^prime -1)
12:59:14 <applicative> mreh or "  join $ writeFile "a+b.txt" <$> ((++) <$> readFile "a.txt" <*> writeFile "b.txt")
12:59:15 <monochrom> and more general
12:59:21 <mreh> I see
12:59:31 <Ging_> so basicly its working out perfect numbers 
12:59:34 <mreh> I was thinking isn't readFile etc. all the wrong type
12:59:50 <mreh> readFile "blah" is alright though
13:00:00 <roconnor> Ging_: what is the input for?
13:00:16 <EvanR-work> > let f x = [0..x-1] in f 9
13:00:17 <lambdabot>   [0,1,2,3,4,5,6,7,8]
13:00:24 <Ging_> perfect 500 and its tells me perfect number between 1 and 500 or the user chosen number
13:00:49 <EvanR-work> filter perfect [1..n]
13:00:50 <roconnor> Ging_: what is the user chosen number?
13:00:57 <applicative> let cp x y = join (writeFile x <$> readFile y)
13:01:02 <Ging_> 500 in this case but anything
13:01:10 <roconnor> Ging_: is that like an error case?
13:01:13 <Ging_> culd be 1000 if needed
13:01:24 <Ging_> i dont know what you mean error case
13:02:13 <roconnor> Ging_: I don't understand why you need this user chosen number thing
13:02:23 <Ging_> just what it asks 
13:02:24 <roconnor> why not just return an empty list of no perfect numbers are found?
13:02:31 <roconnor> *if
13:02:47 <Ging_> so if i enter perfect 10 its will give me all perfect numbers that do no exceed 10
13:03:07 <EvanR-work> name it perfectsLessThan
13:03:28 <roconnor> Ging_: do what EvanR-work suggests: filter perfect [1..n]
13:03:38 <roconnor> where perfect is a function you write
13:03:43 <Ging_> what does filter do?
13:03:49 <mreh> :t const
13:03:50 <lambdabot> forall a b. a -> b -> a
13:04:04 <mreh> :t pure
13:04:04 <roconnor> @type filter
13:04:05 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:04:05 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
13:04:38 <roconnor> filter takes a predicate and a list an returns the list of those elements statifying the predicate
13:05:04 <Ging_> i have to write the function myself 
13:05:13 <roconnor> oh
13:05:15 <EvanR-work> compute a not-necessarily-proper sublist of a list
13:05:18 <Ging_> a perfect number is a prime number and then this formula
13:05:38 <EvanR-work> Ging_: you dont need to write filter, just write perfect
13:05:39 <Ging_> 2^Prime - 1 (2^prime -1)
13:06:32 <Ging_> i am writing the whole function myself 
13:06:49 <Ging_> i need to understand how to get haskell to do the calculation
13:07:02 <EvanR-work> start with types
13:07:12 <monochrom> first you need to understand how to get yourself to do the calculation
13:07:12 <Ging_> what do u mean 
13:07:19 <EvanR-work> whats the type of the function you are trying to write
13:07:42 <Ging_> perfects :: Int -> [Int]
13:07:53 <Ging_> and the the actuall function 
13:09:55 <nlogax> is there any way out of this situation? http://paste.pocoo.org/show/249041/
13:10:14 <EvanR-work> \n -> filter perfect [1..n]  has that type, as long as perfect has some suggestive type. whats that
13:10:33 <Ging_> do uderstand what im trying o do 
13:10:42 <EvanR-work> s/n]/n-1]/
13:11:04 <acowley> nlogax: Update sox and synthesizer
13:11:30 <EvanR-work> find all perfect numbers between 0 and n-1
13:11:37 <EvanR-work> er n
13:11:39 <EvanR-work> >_<
13:11:59 <nlogax> acowley: i don't know if i'm good enough to do that, but i'll try if there's no other option :)
13:12:16 <acowley> nlogax: Hopefully it will just mean editing the cabal file to relax the version constraint
13:12:34 <nlogax> acowley: i'll try that, thanks
13:12:46 <zachk> ging your formula needs parentheses i believe 
13:13:27 <zachk> > let primes = nubBy (\a b->mod a b == 0) [2..] in take 20 primes 
13:13:28 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
13:13:44 * zachk notes that thats not very effecient though 
13:15:29 <Ging_> brb
13:20:18 <zachk> ging: you need mersenne primes and too take there are approximately only 47 known to mankind to generate perfect numbers 
13:21:09 <Ging_> ok thanks zachk
13:21:16 <Ging_> i ahve to go bbl
13:21:36 <napping> zachk: is it known that all perfect numbers come from mersenne primes?
13:22:04 <zachk> i believe its known that all even perfect numbers come from mersenne primes 
13:22:17 <zachk> but no one has found an odd perfect number yet 
13:22:36 <zachk> wikipedia had quite a bit of info on perfect numbers, mostly which im just regurgitating 
13:22:48 <nlogax> acowley: i think that was ok, at least it got past that step and broke when a bunch of packages required array-0.2.0.0, which i can't install for some reason :)
13:22:58 <nlogax> to the google mobile
13:24:01 <acowley> nlogax: good news!
13:24:27 <napping> ok, so the perfect numbers program will work pretty well up to 10^200 or so with just a table of mersenne primes
13:24:32 <acowley> nlogax: That's usually as far as I'd take the effort to get a package working, so it's good it worked because my next suggestion would be to wait for a better future.
13:24:41 <nlogax> acowley: :D
13:25:03 <nlogax> i'll see if the other ones can be fixed as easily
13:25:31 <napping> after than you can fall back on trial division :)
13:40:49 <McManiaC> napping: changed a few lines and now haddock generation works :O
13:57:01 <nifr> pardon me if I'm trolling, but I'm looking to dualize Data.Foldable.Foldable; anyone have any thoughts on this? There seems to be plenty of design decisions to be made?I'm not seeing a natural choice.
13:57:54 <nifr> so far I'm looking to dualize Monoid as well, mfull :: Comonoid s => s, mparts :: Comonoid s => s -> (s, s)
13:58:26 <nifr> cofold :: (Comonoid s, Cofoldable t) => s -> t s
13:58:48 <aavogt> @type unfoldr
13:58:49 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:58:50 <nifr> which is basically unfold, right? well it seems like there's a natural nondeterminism here
13:59:04 <napping> what are the equations for your comonoids?
13:59:23 <nifr> so perhaps, mparts :: Comonoid s => s -> [(s, s)] and cofold :: (Comonoid s, Cofoldable t) => s -> [t s]
13:59:31 <nifr> napping: that's what I'm trying to determine
13:59:33 <copumpkin> comonoid?
13:59:39 <copumpkin> that's just a monoid isn't it?
13:59:39 <nifr> seems like there's options
13:59:49 <copumpkin> are you talking about monoid objects in CT or monoids in algebra?
13:59:50 <nifr> so perhaps Comonoid is the wrong name
14:00:20 <nifr> I'm trying to take a pragmatic approach, so "some opposite of Monoid" a la contravariant versus covariant functors
14:00:52 <nifr> frankly I'm flipping some arrows and adding Co
14:01:07 <napping> I don't think that works out very well
14:01:27 <napping> unless your \otimes is pretty strange
14:01:39 <nifr> \otimes ?
14:01:47 <copumpkin> Ox
14:01:49 <copumpkin> overlapping
14:01:54 <napping> the pair/tensor/whatever produced by your split
14:02:00 <nifr> OK
14:02:05 <napping> it needs a notion of coassociativity
14:02:06 <mauke> â
14:02:15 <nifr> ah, \otimes
14:02:21 <Veinor> I think you mean 'conotion' ;)
14:02:22 <napping> where let (a,b) = split x in (split a,b) is equal to let (a,b) = split x in (a,split b)
14:02:46 <copumpkin> nifr: to write your Comonoid, you need Cohaskell
14:02:49 <copumpkin> #cohaskell, kthx
14:02:58 <Twey> Haha
14:03:12 <nifr> napping: how is the type mismatch to be ignored there?
14:03:28 <nifr> split a ++ [b] versus a : split b?
14:03:31 <napping> well, that's only supposed to be up to isomorphism
14:03:41 <nifr> ok
14:03:44 <napping> anyway, I don't think you want to generalize the monoid-based fold
14:03:59 <napping> that's really just used to hide the (F a -> a) you need for a generic fold
14:04:00 <nifr> I want the opposite, not a generalization
14:04:12 <napping> how about the old unfold :: (a -> F a) -> a -> mu F
14:04:36 <nifr> since folds are reductive and unfolds are generative, I think there's a corresponding natural source of nondeterminism 
14:04:59 <nifr> else only a teensy (probably) set of coinductive types could afford instances
14:05:37 <napping> on the fold side, the instance is given a constructor from the type it is defined for
14:05:43 <napping> so it can define a case to handle each constructor
14:05:56 <napping> going the other way, the instance just gets some opaque value
14:06:23 <nifr> yeah, the seed, from which the instance could extract the type constructor's structure in different ways?
14:06:38 <napping> I think it only makes sense for infinite structures
14:06:55 <nifr> yeah, unless msplit can "fail"
14:07:15 <napping> and then you end up with something which is not really at all the inverse of those folds
14:07:38 <nifr> monoid laws = mempty is unit/neutral for mappend and mappend is associative?
14:07:56 <napping> ye
14:08:12 <napping> and your comonoid would have laws like split x = (coempty,x) = (x,coempty)
14:08:24 <napping> so, yeah, better not use plain pairs
14:08:29 <nifr> which smells of nondeterminism
14:08:51 <napping> You could make a class for nondeterministically enumerating all structures which would fold to a given result, if you'd like
14:08:58 <nifr> heard of species?
14:09:12 <napping> yes, but I don't see how that's related
14:09:24 <nifr> the generation and enumeration aspect is similar
14:09:25 <napping> but, is there an existing class anywhere for zippable things?
14:09:56 <nifr> I don't follow
14:10:10 <napping> not related to your topic
14:10:21 <napping> some class with a method like f a -> f b -> f (a,b)
14:10:35 <nifr> that's effectively Control.Applicative.Applicative
14:10:40 <napping> or rather, f a -> f b -> Maybe (f (a, b))
14:10:52 <nifr> the idioms paper called it Monoidal f
14:10:56 <copumpkin> napping: I think category-extras has a class called Zip or something
14:11:10 <copumpkin> preflex: seen edwardk
14:11:11 <preflex>  edwardk was last seen on #haskell 6 days, 14 minutes and 43 seconds ago, saying: gotta run
14:11:18 <napping> oh, another thing in there
14:11:23 <copumpkin> :P
14:11:38 <copumpkin> napping: but yeah, how would it differ (law-wise) from applicative?
14:11:57 <napping> well, it would be allowed to fail if things missmatch
14:12:11 * ezyang wonders if edwardk's been on the run for a week now 
14:12:28 <applicative> COntrol.Functor.Zip   class Functor f => Zip f where fzip :: f a -> f b -> f (a, b)
14:12:53 <copumpkin> napping: most zips don't fail, as far as I know
14:13:01 <copumpkin> they just give you what they can
14:13:04 <napping> well, I want it for matching
14:13:16 <copumpkin> hm, then I don't think so
14:14:37 <aristid> haskell's numeric typeclasses are stupid. there's no numeric typeclass without a constructor fromInteger, for example
14:14:57 <copumpkin> aristid: indeed!
14:14:58 <napping> so?
14:15:06 <copumpkin> join the hate club
14:15:09 <napping> that's one of the few things about them that isn't stupid
14:15:10 <applicative> yipe, category extras has ... fzip bizip fzipWith bizipWith counzip counbizip
14:15:20 <aristid> copumpkin: yay!
14:15:31 <nifr> thanks for the conversation
14:15:48 <mauke> xzibit
14:16:02 <napping> Are there any numbers you'd like to work with which are not at least semirings?
14:16:14 <aristid> napping: yes, for example time
14:16:22 <aristid> napping: or mass
14:16:27 <aristid> napping: or anything with a dimension
14:16:36 <applicative> the Himmel numbers 
14:17:25 <jmcarthur> it's even stupider that it requires Show and Eq
14:17:34 <napping> it might make sense for Group or superclasses not to support fromInteger, but to even have a Group would come after fixing lots of other stuff
14:18:07 <napping> anything with a "1" has a sensible definition
14:18:15 <aavogt> @hackage dimensional
14:18:15 <lambdabot> http://hackage.haskell.org/package/dimensional
14:18:21 <napping> and I dare say you'd usually like to be able to override it for efficiency
14:18:31 <napping> hmm, well, a power-of-two thing might not be that bad
14:19:03 <Twey> What is bizip?
14:19:16 <aavogt> aristid: you have to be a bit more fancy if you like to deal with dimensioned numbers, like that package
14:19:30 <napping> putting it another way, is there any numeric types you'd like to work with that don't have a nontrivial homomorphic image of Nat?
14:20:03 <napping> I'm not quite sure you should be able to get away with subtracting times and mass and things like that
14:20:10 <napping> well, mass maybe
14:20:46 <napping> like, TimeDiff vs. CalendarTime
14:21:13 <napping> does anyone program with much of the stuff in category-extras?
14:22:06 <aristid> aavogt: that defines its own (+) and (-) and so on
14:22:48 <copumpkin> napping: nope
14:23:08 <applicative> napping, some have: http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/category-extras-0.53.5
14:23:17 <aristid> hmm i guess not having fromInteger is not enough for that
14:23:25 <aristid> :t sqrt
14:23:26 <lambdabot> forall a. (Floating a) => a -> a
14:23:53 <napping> I think they mostly just use little handy definitions
14:24:25 <napping> anybody using Kan extensions?
14:24:59 <napping> well, I guess pretty much everything is a Kan extension of something
14:31:53 <FunctorSalad> napping: edwardk uses right kans in monads-ran
14:32:33 <FunctorSalad> as more efficient (in some situations) variants of common monads 
14:40:26 <napping> @djinn (m r -> (a -> m r) -> m r) -> (a -> m r -> (b -> m r) -> m r) -> (m r -> (b -> m r) -> m r)
14:40:27 <lambdabot> f a b c d = a c (\ e -> b e (a c (\ _ -> c)) d)
14:40:48 <napping> silly djinn, why did it write (a c (\_ -> c)) instead of c?
14:41:01 <mauke> it's more cromulent
14:41:02 <napping> (which gives the implementation I actually need)
14:41:19 <zygoloid> napping: well, ContT is a special case of a right kan extension iirc
14:41:31 <napping> guess I need to generalize my types a bit more before I can leave it to djinn
14:41:46 <napping> I'm trying to make a monad with a "return" that actually cuts back to the run with the early value
14:41:50 <zygoloid> @src ContT
14:41:50 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
14:42:15 <zygoloid> napping: you can't do that with return, because it wouldn't have the right type.
14:42:18 <napping> wait, that's not quite what I have
14:42:40 <napping> I'm actually trying to make a failure-only version of LogicT
14:42:52 <napping> which cuts back to the run without a value
14:43:12 <zygoloid> do you want to be able to produce multiple values?
14:43:31 <napping> no
14:43:48 <napping> well, I'm really doing that just to abuse fail and pattern matching
14:44:03 <zygoloid> then that sounds like Maybe, or at a push ContT r Maybe
14:44:25 <zygoloid> unless i've missed something ;)
14:44:34 <napping> well, it needs to be a transformer too
14:44:42 <napping> Generic Unification via Two-Level Types and Parameterized Modules
14:44:54 <zygoloid> @hackage MaybeT
14:44:54 <lambdabot> http://hackage.haskell.org/package/MaybeT
14:46:31 <napping> that looks about right
14:46:49 <napping> probably faster if it used continuations, but it'll do
14:57:04 <McManiaC> http://npaste.de/fm/ â can someone help me fixing that error?
15:01:15 <tolkad> What is Data.Vector.Fusion.Stream?
15:01:32 <tolkad> it's description is just "Streams for stream fusion"
15:01:45 <tolkad> à² _à² 
15:01:56 <copumpkin> tolkad: it's the underlying mechanism for stream fusion :)
15:02:24 <c_wraith> tolkad, unless you're changing stuff in vector's implementation, just ignore it.
15:02:29 <copumpkin> they work by representing vectors as stream functions
15:03:22 <tolkad> Is it possible to realloc Vectors?
15:04:19 <aavogt> McManiaC: the second Q has a different phantom type variable than the one you took the ListE out of
15:04:37 <copumpkin> realloc? how do you mean and why do you want to?
15:05:04 <c_wraith> I think he means change the capacity in-place, with no copy.
15:05:19 <tolkad> c_wraith: if possible, otherwise copy
15:05:33 <copumpkin> only if you shrink them
15:05:42 <tolkad> ha
15:05:43 <copumpkin> :)
15:05:59 <copumpkin> if you ask for a subvector it costs nothign
15:06:05 <tolkad> would it be possible to write an Unbox instance for vector?
15:06:12 <tolkad> just kidding
15:06:12 <McManiaC> aavogt: can I fix that somehow?
15:06:41 <aavogt> McManiaC: -XScopedTypeVariables with an annotation on the Q is probably easiest
15:07:02 <McManiaC> aavogt: aaah thanks
15:07:03 <McManiaC> got it
15:07:15 <tolkad> what do I do if I need a variable number of vectors...
15:07:27 <iago> :t let f = undefined :: forall a. (a -> a) -> Bool in f (\x -> x)
15:07:29 <tolkad> hmm, I know what I'll do
15:07:30 <lambdabot> Bool
15:07:34 <tolkad> I'll have a vector of vectors, this supervector being of relatively small size
15:07:44 <tolkad> it will be cheap to copy my vector of vectors
15:08:15 <tolkad> good solution?
15:08:43 <c_wraith> tolkad, if you're using a nested array structure that's regular (that is, every subarray at a given level is the same size), look at the repa library
15:10:06 <tolkad> it has "experimental" stability...
15:10:27 <EvanR-work> stable experimentality
15:11:32 <c_wraith> it's a relatively new library, but it's designed to support regular nested array structures in a way that gives efficient parallelization.
15:11:48 <c_wraith> And it's done by the same people who did the Data Parallel haskell stuff
15:11:53 <c_wraith> So it's not like they're new to the area.
15:21:14 <copumpkin> @hackage hoopl
15:21:14 <lambdabot> http://hackage.haskell.org/package/hoopl
15:21:45 <dpratt71> can't rightly explain why constructing a list of heterogenous values in Haskell makes me so giddy
15:22:20 <dpratt71> not like that isn't trivial in most other languages
15:23:09 <EvanR-work> > let x = undefined; xs = [x,x,x,x,x,x,x] in xs
15:23:10 <lambdabot>   [*Exception: Prelude.undefined
15:24:01 <EvanR-work> 7 values of any type!
15:24:02 <EvanR-work> ;)
15:24:06 <dpratt71> :)
15:24:19 <Zao> Any same type, that is.
15:24:19 <aavogt> hooplr would be a more internet 2.0 appropriate name
15:24:27 <olsner> when I first tried to learn haskell I was a bit iffed that constructing a list of heterogenous values was so hard, but then I realized that I didn't really want to do that anyway :)
15:25:13 <dpratt71> actually, I was thinking about how this is expressed in C#/.NET and something occurred to me...
15:25:16 <EvanR-work> yeah its pointless ;)
15:25:34 <dpratt71> ...the closest thing to typeclasses in that world are interfaces...
15:26:13 <dpratt71> ...and generic (i.e. higher order) lists can have a bare interface element type
15:26:25 <alip> what's the most practical way to represent flags in C binding to haskell? e.g. i have FLAG_A and FLAG_B... the function foo() accepts any number of these flags bitwise OR'ed together
15:27:30 <dpratt71> why can't I (simply) define a list in haskell where the element type is, for example, anything that is an instance of Show?
15:27:39 <hpc> data Flags = Flags {red :: Bool, blue :: Bool, dividebyzero :: Bool, etc :: Bool}
15:27:59 <hpc> if you want strong typing
15:28:12 <hpc> otherwise, [Bool] plus map should work
15:28:33 <hpc> > :t map (&&) [True, False]
15:28:34 <lambdabot>   <no location info>: parse error on input `:'
15:28:35 <dolio> @quote first-class.existentials
15:28:35 <lambdabot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
15:28:38 <dolio> That's why.
15:28:41 <hpc> :t map (&&) [True, False]
15:28:42 <lambdabot> [Bool -> Bool]
15:28:50 <dpratt71> oh
15:29:06 <dpratt71> and he has a very big brain, too (near as I can tell)
15:29:11 <hpc> er, not map
15:29:12 <olsner> dpratt71: if all you want is Show you can just make a list of strings - pretty much the same thing
15:29:13 <hpc> :t zipWith
15:29:14 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:29:26 <hpc> :t zipWith (&&)
15:29:27 <lambdabot> [Bool] -> [Bool] -> [Bool]
15:29:29 <copumpkin> dpratt71: you can translate your existentials to the CPSish form of them
15:29:34 <dpratt71> olsner: mostly just an example
15:29:37 <copumpkin> dpratt71: then you get it! :D
15:29:44 <hpc> > zipWith (&&) [True, False] [True, True]
15:29:45 <lambdabot>   [True,False]
15:30:12 <ezyang> I've implemented a manual locking system with MVars, and now I'm wondering if I should add runtime checks to make sure someone using locked functionality actually owns the lock. Useful safeguard or just paranoia? 
15:30:27 <dpratt71> copumpkin: CPS hurts my head
15:30:52 <Adamant> it's just SSA in functional-land!
15:30:53 <Adamant> :P
15:31:06 <olsner> ezyang: useful! also, you should detect deadlocks and potential deadlocks automatically :)
15:31:16 <mornfall> What's the diff between hinotify and system-inotify? Which one do I want?
15:31:17 <copumpkin> GUnit :: block n O O -> Graph' block n O O
15:31:29 <ezyang> olsner: In that case, the next question is: how? 
15:31:31 <EvanR-work> olsner: ghc does that!
15:31:38 <dolio> I don't think it'd be that hard for Haskell (UHC has them, even), but GHC has lots of other stuff beyond just Haskell.
15:31:42 <olsner> (if you don't, it's only a matter of time before you misuse the system - unless you can put it in the type system)
15:32:00 <ezyang> olsner: I have an uber-safe, type version; this is the unsafe API. 
15:32:19 <ezyang> MVar () doesn't give you any certificate of "you have the lock" 
15:32:55 <olsner> hmm, then it might be enough to prove that the safe version is correct... but only if you never use the unsafe api outside the implementation of the safe one :)
15:33:09 * hackagebot star-to-star 1.0 - the * -> * types, operators, and covariant instances.  http://hackage.haskell.org/package/star-to-star-1.0 (NicolasFrisby)
15:33:35 <ezyang> For whatever strange reason, the unsafe API needs to be kept around ;-) 
15:34:02 <hpc> what fun would haskell be if we couldn't occasionally launch the missiles?
15:34:04 <hpc> :P
15:34:10 * hackagebot star-to-star-contra 1.0 - contravariant instances for * -> * types and operators.  http://hackage.haskell.org/package/star-to-star-contra-1.0 (NicolasFrisby)
15:34:13 <olsner> ezyang: oh, hysterical raisins?
15:34:20 <ezyang> More seriously, I can't actually think of a way to do this. 
15:34:25 <ezyang> olsner: ...sort of. 
15:34:25 <EvanR-work> screw it. im going to play missile command
15:35:10 <ezyang> Let's say I do a ticket based system with MVar Int, where people who want to use the object grab tickets from the MVar Int. 
15:35:40 <olsner> if you don't mind the runtime overhead you could use thread-local storage to keep track of the set of held locks
15:35:43 <ezyang> Where do I store the "current active ticket" and how do I make people look at the ticket and decide whether or not their allowed to go, and if not, sleep? 
15:36:04 <EvanR-work> if people have to do that, they might as well agree to only use MVar () a certain way
15:36:10 <EvanR-work> i.e. take before using, put after done
15:36:11 <ezyang> Right. 
15:36:27 <ezyang> In which case, I just trust the user not to do stupid things without the lock. 
15:36:39 <ezyang> But it feels a little unsafe. Maybe an acceptable amount of risk. 
15:36:50 <EvanR-work> a type-level scheme might be possible, but these things baffle me
15:37:04 <ezyang> Ah, wth, no checking. 
15:38:25 <hpc> ezyang: a specific structure, or arbitrary structure?
15:38:37 <hpc> (that you are manipulating)
15:38:39 <ezyang> hpc: Specific structure. 
15:38:46 <hpc> put the mvar inside the structure
15:39:00 <ezyang> Yeah, that's what I've currently done. 
15:39:24 <ezyang> Basically, I have write locks that don't block read locks. 
15:39:28 <ezyang> So I can't do MVar Structure. 
15:41:14 <olsner> maybe you could... create an "RWVar" to put the structure in?
15:41:43 <hpc> you can still make read operations non-blocking, if the mvar is inside the structure
15:42:04 <hpc> i think
15:42:05 <ezyang> hm, that might work. 
15:42:21 <ezyang> You can still lie and get a copy of the structure and then do write operations on it 
15:42:36 <hpc> or, better idea
15:42:39 <hpc> a micro lock and a macro lock
15:42:41 <c_wraith> But if you don't have a "set" operation, that doesn't matter
15:42:43 <ezyang> but that's not too big of a deal. 
15:43:28 <hpc> the micro lock is grabbed by primitives, and the macro lock is grabbed by large blocks
15:43:41 <hpc> block a read until the micro lock is freed
15:43:54 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28841
15:44:00 <hpc> block writes until a read finishes
15:44:14 <hpc> and you can still create atomic write operations
15:44:15 <ezyang> Hm. 
15:44:18 <int80_h> anyone familiar with takusen? I'm having trouble with bindP.
15:48:28 <jmcarthur> ezyang: wrap the MVar and have a function like withLock :: WrappedMVar -> (forall s . MyVar s -> Lock s a) -> IO a ?
15:48:45 <jmcarthur> ezyang: also obviously requiring that the lock contents be wrapped as well
15:48:52 <jmcarthur> *mvar contents
15:49:00 <jmcarthur> or at least be wrapped when handed to the client code
15:49:40 <jmcarthur> perhaps s/MyVar/MyVal/ would be a better name
16:02:21 <monadic_kid> Did anyone watch the video on Habbit yet?
16:03:19 <mtnviewmark> Habbit? a new Haskell IDE?
16:03:47 <monadic_kid> new bare-metal systems programming language
16:04:02 <monadic_kid> http://www.galois.com/blog/2010/08/11/tech-talk-video-developing-good-habits-for-bare-metal-programming/
16:04:08 <chrisdone> not enough of those around
16:04:08 <monadic_kid> dialect of haskell
16:04:41 <monadic_kid> used to be called "Systems Haskell"
16:05:10 <monadic_kid> but it's not a non-strict language so they changed the name to Habbit
16:05:19 <monadic_kid> strict dialect of Haskell
16:05:46 <monadic_kid> for bare-metal programming, not systems programming in then sense of Go's definition...
16:06:12 <QtPlatypus> What is systems programing in go's sence of the word?
16:06:18 <Ging_> does anyone know how to write a askell function that will find all te prime numbers from 1 to n please
16:06:29 <chrisdone> Ging_: sure we do :-)
16:06:37 <hpc> is this homework?
16:06:42 <chrisdone> smells like it
16:06:42 <monadic_kid> QtPlatypus: they tend to talk about Web-servers as systems programming...
16:07:03 <aavogt> everything is a system
16:07:06 <chrisdone> @google sieve of eratothenesesseses
16:07:08 <lambdabot> No Result Found.
16:07:18 <chrisdone> I can never ever remember that guy's name
16:07:19 <aavogt> http://en.wikipedia.org/wiki/Systems_thinking
16:07:37 <hpc> i like the infinite sieve algorithm
16:07:57 <chrisdone> @hoogle sieve of eratosthenes
16:07:57 <lambdabot> No results found
16:08:02 <chrisdone> @google sieve of eratosthenes
16:08:03 <lambdabot> http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
16:08:03 <lambdabot> Title: Sieve of Eratosthenes - Wikipedia, the free encyclopedia
16:08:06 <monadic_kid> aavogt: that is why Habbit is not using the term systems, they use the term bare-metal which is better term
16:08:08 <chrisdone> got there in the end
16:09:22 <QtPlatypus> monadic_kid: Ok.  I've been pondering working on a DSL to describate the state of systems from the perspective of systems adiminstration.  So you could cleanly do configuration distribution, monitoring and change control.  The currently existing solutions DSLs are unstatisfactory.
16:10:52 <Ging_> sent you a private chat chrisdone
16:11:42 <monadic_kid> anyway they have Unpointed types (types that don't have bottom), I was wondering if there is much difference with Unboxed values
16:12:46 <Ging_> does anyone know how to write a askell function that will find all te prime numbers from 1 to n please
16:13:15 <QtPlatypus> Ging_: Is your 'h' key broken?
16:13:45 <Ging_> no just missed it twice hhhh
16:13:49 <Ging_> ha ha lol
16:14:07 <alip> I want: if someBool then do_something else do_nothing, i can't live out the else.. how do I do it in a nice way?
16:14:22 * alip is still trying to understand haskell :)
16:14:35 <hpc> alip: depends on what type your do_something is
16:14:37 <hpc> :t when
16:14:38 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:14:41 <hpc> :t unless
16:14:42 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:14:45 <hpc> er
16:14:47 <hpc> @src when
16:14:47 <lambdabot> when p s = if p then s else return ()
16:15:48 <alip> ah forgot about when, thanks! :)
16:15:51 <hpc> if you really want to mess with people's heads, you can do "when (not cond) Nothing"
16:15:59 <hpc> in the Maybe monad
16:16:00 <hpc> :P
16:20:04 <QtPlatypus> Ging_: If you had a haskell function that found all the prime numbers from 1 to (n-1) could you use it to write your function?
16:20:29 <mm_freak_> hpc: what's wrong with that?
16:21:16 <Ging_> well the total function is to find all perfect numbers upto 500 but i first need to find all the prime numbers as perfect numbers are found from prime numbers
16:21:19 <mm_freak_> Ging_: the sieve of eratosthenes
16:21:28 <hpc> mm_freak_: nothing really, it just takes a minute to figure out
16:21:57 <mm_freak_> hpc: filterM (const [True, False])  -- my favorite brain teaser =)
16:22:11 <c_wraith> You don't even need primes up to n - 1.  primes up to sqrt n will suffice.
16:22:12 <hpc> haha
16:22:14 <hpc> :t filterM
16:22:15 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
16:22:25 <hpc> oh that's mean
16:22:35 <hpc> and elegant at the same time
16:22:45 <QtPlatypus> c_wraith: I know that.  Optimizations come later.
16:22:45 <mm_freak_> > filterM (const [True, False]) "abc"
16:22:46 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
16:23:24 <hpc> wtf? i thought it removed the even-indexed items?
16:23:30 <Ging_> ok im lost on where we are about primes or perfect numbers
16:23:47 <QtPlatypus> Ging_: We are about primes at this stage.
16:23:51 <zygoloid> hpc: nope :)
16:23:56 <hpc> @src filter
16:23:56 <lambdabot> filter _ []     = []
16:23:56 <lambdabot> filter p (x:xs)
16:23:56 <lambdabot>     | p x       = x : filter p xs
16:23:56 <lambdabot>     | otherwise = filter p xs
16:23:58 <hpc> @src filterM
16:23:59 <lambdabot> Source not found. :(
16:24:08 <QtPlatypus> Ging_: If I gave you that function, could you use it to write your function?
16:24:20 <mm_freak_> hpc: it's filterM, not filter ;)
16:24:27 <hpc> yeah, typo
16:24:31 <mm_freak_> and it's the list monad
16:24:41 <hpc> @src [] filterM
16:24:41 <mm_freak_> so you're filtering nondeterministically
16:24:41 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:25:08 <zygoloid> > catMaybes $ zipWith ($) (cycle [Just, const Nothing]) "abcdefg"
16:25:09 <lambdabot>   "aceg"
16:26:08 <zygoloid> > concat $ zipWith ($) (cycle [return, return []]) "abcdefg"
16:26:09 <lambdabot>   "aceg"
16:26:09 <hpc> > filterM (const [True, False]) [1..]
16:26:11 <lambdabot>   *Exception: stack overflow
16:26:16 <hpc> > filterM (const [True, False]) [1..5]
16:26:17 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1...
16:26:39 <fatuhoku> > []
16:26:40 <lambdabot>   []
16:26:59 <fatuhoku> > import Data.Numbers.Prime
16:27:00 <Kaidelong> > drop 1 []
16:27:00 <lambdabot>   <no location info>: parse error on input `import'
16:27:01 <lambdabot>   []
16:27:46 <Kaidelong> > let f (x:xs) = x : f (drop 1 xs) in f "abcdefg"
16:27:47 <lambdabot>   "aceg*Exception: <interactive>:1:137-164: Non-exhaustive patterns in functi...
16:28:22 <zygoloid> > nubBy (((0==) .) . mod) [2..]
16:28:23 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:28:30 <Kaidelong> > let f ys = case ys of {(x:xs) -> x : f (drop 1 xs), [] -> []} in f "abcdefg"
16:28:31 <lambdabot>   <no location info>: parse error on input `,'
16:28:33 <mm_freak_> > map head . takeWhile (not.null) . map (take 2) . iterate (drop 2) $ "abcdefg"
16:28:34 <lambdabot>   "aceg"
16:28:40 <Kaidelong> > let f ys = case ys of {(x:xs) -> x : f (drop 1 xs); [] -> []} in f "abcdefg"
16:28:41 <lambdabot>   "aceg"
16:29:23 <hpc> oh i see now
16:29:50 <hpc> if filterM was implemented with zipList instead of [], it would do what i thought it would
16:29:57 <hpc> now, it does permutations
16:30:28 <tolkad> are there any tutorials for using repa?
16:30:29 <zygoloid> hpc: i don't think that's true.
16:31:56 <mm_freak_> hpc: i don't know ziplists, but as long as lists model nondeterministm, filterM used that way should give you permutations
16:32:00 <mm_freak_> uhm
16:32:03 <mm_freak_> subsets, not permutations
16:32:18 <mm_freak_> i don't think you can model permutations in the list monad (easily)
16:33:09 * ezyang is annoyed by the fact that adding extra runtime checks is easy, but adding static checks results in having to change lots of APIs. 
16:34:29 <hpc> er, yeah, permutations would be a nightmare
16:35:27 <zygoloid> @let filterA f [] = pure []; filterA f (x:xs) = go <$> f x <*> filterA f xs where go False r = r; go True r = (x:r)
16:35:28 <lambdabot>  Defined.
16:35:30 <tolkad> wait a second... these repa arrays aren't mutable!
16:35:36 <zygoloid> > filterA (const [True, False]) [1..5]
16:35:37 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1...
16:35:42 <copumpkin> tolkad: that's the whole point
16:35:53 <zygoloid> > getZipList $ filterA (const $ ZipList [True, False]) [1,2,3,4,5]
16:35:54 <lambdabot>   [[1,2,3,4,5],[]]
16:36:23 <tolkad> but... I want to store a large, variable amount of data efficiently
16:36:35 <copumpkin> tolkad: then use mutable vectors
16:37:07 <tolkad> copumpkin: I need to store a variable amount of data, vectors don't have something like C's realloc
16:37:27 <copumpkin> then arrays aren't the datastructure you need
16:37:29 <zygoloid> > getZipList $ filterA (\a -> ZipList [a < 2, a > 3, odd a, even a]) [1,2,3,4,5]
16:37:30 <lambdabot>   [[1],[4,5],[1,3,5],[2,4]]
16:37:38 <copumpkin> tolkad: IntMap or Data.Sequence?
16:37:49 <zygoloid> filterA on ZipList just does multiple filters at the same time.
16:38:28 <zygoloid> if list is nondeterminism, ZipList is data parallelism
16:38:38 <hpc> ah
16:38:43 <copumpkin> tolkad: if you want to behave mostly like an array, try the Data.Sequence
16:38:48 <QtPlatypus>   
16:39:05 <copumpkin> tolkad: not sure we have anything common like an "ArrayList", though
16:39:10 <copumpkin> since we tend to not use mutation much :)
16:39:13 <tolkad> copumpkin: I said large amount of data. if I'm storing like 300mb to 1gb will these data structures be inefficient?
16:39:21 <zygoloid> incidentally, i wonder why there's no filterA in Control.Applicative
16:39:49 <hpc> @hoogle filterA
16:39:50 <lambdabot> No results found
16:39:59 <copumpkin> tolkad: you shouldn't be reallocing such large chunks of data then, even in an imperative language :) but no, they won't be. I'd use a list of arrays or something, if you really need to grow (and you only attach to the ends)
16:40:11 <hpc> filterA is a Caleskell thing?
16:40:47 <Miron> Hurrah! Okawaru just gave me the triden of the Octopus King!
16:41:11 <copumpkin> Miron: glad to hear it
16:42:22 <zygoloid> hpc: no, i defined it about 7 minutes ago :)
16:42:43 <hpc> oh i see now
16:42:48 <hpc> long log is long
16:43:08 <zygoloid> concat is a con
16:44:19 <tolkad> ok, so if I'm using repa, and I want to change the value of one cell, how do I do that?
16:44:41 <chrisdone> preflex: poppavic
16:46:04 <copumpkin> tolkad: as I said, it isn't mutable
16:46:24 <ezyang> what function will map False -> 0 and True -> 1? 
16:46:30 <zygoloid> ezyang: fromEnum
16:46:33 <copumpkin> ezyang: fromEnum
16:46:39 <ezyang> cool. 
16:46:42 <copumpkin> tolkad: but it might support fairly efficient "mutation" as it's backed by functions
16:46:50 <copumpkin> ezyang: might be clearer to just write a simple one though
16:46:57 <copumpkin> ezyang: as it relies on the order of constructors in the prelude
16:47:19 <ezyang> Hmm... 
16:47:31 * ezyang is feeling lazy 
16:47:36 <zygoloid> it's not likely to change though
16:47:37 <copumpkin> :)
16:47:44 <zygoloid> since it'd break Real Haskell Code
16:47:55 <zygoloid> such as subsets = filterM (const [False..])
16:48:12 <mm_freak_> hpc: i found a way to make permutations monadically
16:48:15 <copumpkin> tolkad: if you're only doing a few such mutations, you can do it efficiently
16:48:26 <copumpkin> but it'll slow down O(number of mutations)
16:48:40 <tolkad> copumpkin: I don't plan on doing more than 100 per second or so
16:48:51 <copumpkin> lol
16:49:03 <mm_freak_> > foldM (\x y -> zipWith (\l r -> l ++ y:r) <$> inits <*> tails $ x) [] "abc"
16:49:04 <lambdabot>   ["cba","bca","bac","cab","acb","abc"]
16:49:19 <copumpkin> tolkad: out of curiosity, what is your application?
16:49:42 <tolkad> copumpkin: nothing really, I'm just trying to learn about haskell arrays
16:50:20 <tolkad> hmm maybe I could use repa in combination with unsafePerformIO!
16:50:26 <tolkad> think it will work?
16:50:27 <copumpkin> tolkad: no
16:50:43 <copumpkin> tolkad: "300 to 1GB" is "just trying to learn about arrays"?
16:50:46 <mm_freak_> hpc: now if that's not a brain teaser =)
16:50:56 <tolkad> copumpkin: yes.
16:51:27 <tolkad> why wont unsafePerformIO work?
16:51:38 <copumpkin> because it doesn't magically give you an imperative language
16:51:59 <copumpkin> it's still haskell, and a lot of haskell assumes things won't change behind its back
16:52:06 <pikhq> unsafePerformIO does not do what you think it does.
16:52:09 <copumpkin> a lot of repa is built on that assumption
16:52:20 <mm_freak_> tolkad: if you need mutable arrays, why not just use those?
16:52:27 <pikhq> It gives you a very magical thunk, not actual imperative code.
16:52:47 <mm_freak_> if you have to use unsafePerformIO, you're doing something wrongâ¦  in all cases you're likely to come across
16:53:07 <Adamant> not exactly, but it's a good first assumption
16:53:38 <Adamant> well, you qualified with "likely"
16:53:55 <Adamant> so aktually, you're right
16:54:40 <tolkad> I have an idea
16:54:52 <tolkad> I could unsafeCoerce the repa array into a mutable vector
16:54:59 <tolkad> and then just coerce it back when I'm done
16:55:09 <mm_freak_> actually the quest to write a monadic permutations function gave me an extremely elegant way to get what i often wanted
16:55:09 <copumpkin> no
16:55:12 <c_wraith> I recommend trying that.
16:55:15 <hpc> yuck
16:55:20 <copumpkin> tolkad: forget you ever learned about the unsafe* functions
16:55:21 <mm_freak_> > zip <$> inits <*> tails $ "abc"
16:55:21 <lambdabot>   [("","abc"),("a","bc"),("ab","c"),("abc","")]
16:55:22 <tolkad> I'm kidding :P
16:55:55 <tolkad> I guess I'll use a mutable vector of mutable vectors
16:56:15 <mm_freak_> tolkad: you can have multidimensional indices
16:56:26 <mm_freak_> so you don't really need vectors in vectors
16:56:28 <copumpkin> not with Vector
16:56:31 <mm_freak_> oh, true
16:56:37 <hpc> clearly he must do unsafeInterLeaveIO . unsafeCoerce unsafePerformIO
16:56:43 <tolkad> mm_freak_: the point is the ability to copy the outer vector without having to copy the inner ones
16:57:07 <c_wraith> tolkad, you can do that without mutable arrays at all.
16:57:26 <tolkad> c_wraith: but I can't have fast read-write without mutable arrays
16:57:32 <mm_freak_> tolkad: depends on your notion of "copy"
16:57:48 <tolkad> mm_freak_: well, the purpose of copying would be to increase in size
16:58:05 <mm_freak_> tolkad: what's the application?
16:59:10 <tolkad> I want to store a random number of numbers in RAM and randomly modify and remove and add new ones at a specific rate
16:59:28 <medfly> you are using the wrong language to be thinking about that
16:59:47 <jmcarthur> an operational specification will lend itself to an operational implementation
16:59:51 <mm_freak_> tolkad: i would do that using immutable vectors
17:00:26 <mm_freak_> tolkad: don't worry about memory management, because Vectors use fusion
17:00:37 <tolkad> what's fusion?
17:01:13 <tolkad> does haskell combine hydrogen atoms?
17:01:17 <mm_freak_> > take 10 . filter even . map (^2) $ [1..]
17:01:18 <lambdabot>   [4,16,36,64,100,144,196,256,324,400]
17:01:21 <mm_freak_> that's fusion
17:01:36 <tolkad> selecting 10 items from a list?
17:01:44 <hpc> composing filters
17:01:56 <hpc> and manipulating infinite lists in general
17:02:17 <mm_freak_> no, but manipulating the infinite list, as long as you use a finite portionâ¦  fusion takes care of forgetting the unused parts
17:02:19 <copumpkin> tolkad: it'll avoid building intermediate lists
17:02:22 <mm_freak_> i.e. you can do this:
17:02:41 <mm_freak_> > iterate (\x -> 2*x + 1) 1 !! 500
17:02:41 <lambdabot>   654678121579228374002637939365519830443328409208612957896658273619226759280...
17:02:56 <mm_freak_> this is O(1) space
17:03:03 <mm_freak_> it would be O(n) space without fusion
17:03:09 <zygoloid> fusion is a compiler optimization where it converts several well-behaved list producers/consumers into a single loop
17:03:59 <jmcarthur> unless i've been understanding haskell incorrectly for a long time, fusion is not responsible for that being constant space. laziness is
17:04:16 <ddarius> mm_freak_: That's not fusion.  What zygoloid said is fusion.
17:04:20 <jmcarthur> fusion makes the constant space algorithm faster though
17:04:35 <mm_freak_> i thought that fusion takes care of forgetting the past list elements
17:04:44 <Kaidelong> @src (!!)
17:04:44 <lambdabot> xs     !! n | n < 0 = undefined
17:04:44 <mm_freak_> (as one of many optimizations)
17:04:44 <lambdabot> []     !! _         = undefined
17:04:44 <lambdabot> (x:_)  !! 0         = x
17:04:44 <lambdabot> (_:xs) !! n         = xs !! (n-1)
17:04:44 <jmcarthur> no, that's just simple garbage collection
17:04:45 <ddarius> mm_freak_: No, that's just garbage collection.
17:05:00 <mm_freak_> oh, ok
17:05:16 <mm_freak_> ok, the forget the last example =)
17:05:22 <copumpkin> has anyone used hoopl here?
17:05:37 <zygoloid> fusion, if correctly implemented, should not be denotationally observable
17:05:43 <jmcarthur> right
17:06:04 <zygoloid> so you can't really just give examples of it without explaining what's happened operationally
17:06:15 <jmcarthur> well, it could still have some effects on space complexity sometimes
17:06:28 <jmcarthur> if it makes an inappropriately lazy/strict algorithm strict/lazy instead
17:06:36 <zygoloid> the example you gave was fine, if accompanied by an explanation that it'd be fused into a single tight loop
17:06:39 <tolkad> haskell is hard to think about
17:06:45 <jmcarthur> but it will never change the interface of a function whose implementation is fused though
17:06:49 <ddarius> zygoloid: I'm not quite sure I'd say that.  map f . map g -> map (f . g) is an example of fusion
17:07:05 <tolkad> I'll be trying to think of how to implement something and I'll be like "oh I'll just update this variable" and then I'll remember that isn't possible
17:07:17 <jmcarthur> are fusion and deforestation considered the same? i thought fusion was a subset of deforestation
17:07:35 <jmcarthur> (the map composition example not being fusion, in my perhaps incorrect worldview)
17:07:51 <jmcarthur> not *necessary* being fusion, i mean
17:07:56 <ddarius> jmcarthur: Neither term is that strictly defined and they are more or less synonymous.
17:08:05 <jmcarthur> ah okay
17:08:06 <zygoloid> ddarius: i see your point, but i'd still say that's an operational difference since the two are denotationally equivalent
17:08:21 <mm_freak_> hmm, why is fusion needed to manipulate infinite lists?
17:08:25 <ddarius> zygoloid: I agree.
17:08:26 <copumpkin> it isn't
17:08:29 <mm_freak_> laziness should do that just fine
17:08:33 <ddarius> It does.
17:08:37 <tolkad> jmcarthur: http://en.wikipedia.org/wiki/Deforestation http://en.wikipedia.org/wiki/Nuclear_fusion
17:08:46 <jmcarthur> what about strict lists?
17:08:54 <medfly> deforestation and nuclear fusion? o.O
17:08:54 <jmcarthur> fusion could help there
17:09:04 <jmcarthur> (e.g. array fusion)
17:09:30 <mm_freak_> so fusion eliminates the data structure and turns it into a simple loop?
17:09:36 <jmcarthur> yes
17:09:50 <tolkad> like... how do you implement a linked list in haskell? I can't think of how you would add a new element
17:10:03 <jmcarthur> tolkad: haskell's list type is a linked list
17:10:03 <napping> tolkad: like []?
17:10:07 <copumpkin> data List a = Nil | Cons a (List a)
17:10:12 <mm_freak_> ok, so it never makes an asymptotic difference?
17:10:21 <copumpkin> tolkad: doubly linked list is a lot harder, and completely impractical to work with
17:10:35 <copumpkin> well, not a lot harder
17:10:38 <jmcarthur> mm_freak_: i suppose it could, but not in the case of lazy lists
17:10:40 <hpc> doubly linked lists are zippers
17:10:51 <copumpkin> hpc: not really
17:10:51 <napping> impossible to modify, rather
17:10:52 <zygoloid> you could make a doubly-linked list with STRefs, but it'd be about as tedious as the corresponding imperative code
17:11:12 <jmcarthur> you can do doubly linked lists by using IntMap to simulate pointers
17:11:23 <zygoloid> (it also wouldn't be persistent, unlike some of the other suggestions)
17:11:24 <mm_freak_> i think, doubly linked lists aren't hard to implement in haskell, if you go low level
17:11:30 <mm_freak_> and it gives you fast ones, too
17:11:38 <copumpkin> mm_freak_: sure, but they're imperative
17:11:46 <jmcarthur> the IntMap version is pretty fast and is persistent :)
17:11:48 <mm_freak_> copumpkin: under the hood, yes
17:11:58 * zygoloid favours jmcarthur's solution :)
17:11:59 <copumpkin> jmcarthur: then you're just building a linear graph :)
17:12:11 <jmcarthur> copumpkin: nothing wrong with that
17:12:18 <zygoloid> copumpkin: sounds like an opportunity for code reuse :)
17:12:25 <copumpkin> nothing in the type guarantees it to be a linked list!!
17:12:33 <mm_freak_> true, IntMap is fine, but also uses more memory =)
17:12:34 <copumpkin> you could have all sorts of evil graphy things
17:12:54 <zygoloid> > fix (1:)
17:12:55 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:13:14 <mm_freak_> if you're serious about a doubly linked lists, you would probably build something based on Array
17:13:24 <jmcarthur> copumpkin: surely a more powerful type system could prevent you from deviating ;)
17:13:28 <jmcarthur> mm_freak_: why?
17:13:47 <copumpkin> jmcarthur: I wonder where we might find such a thing! :P
17:13:47 <zygoloid> you couldn't have anything that wasn't externally a (possibly infinite) doubly-linked list (possibly with some never-collected garbage) if you used the right interface
17:13:50 <mm_freak_> jmcarthur: because the only reason i could think of to use a doubly linked list is performance
17:13:56 <tolkad> [(1, 1), (2,2)..] 
17:14:01 <tolkad> > [(1, 1), (2,2)..] 
17:14:02 <lambdabot>   No instance for (GHC.Enum.Enum (t, t1))
17:14:02 <lambdabot>    arising from a use of `e_11122' ...
17:14:12 <tolkad> wat
17:14:13 <jmcarthur> mm_freak_: O(n) insertion to the middle of a double linked list! *shudder*
17:14:15 <hpc> rarely do you need to go both ways through a list
17:14:16 <tolkad> oh I see
17:14:18 <ddarius> mm_freak_: Array /= performance
17:14:46 <mm_freak_> jmcarthur: that's true, thoughâ¦  it really depends on the use case
17:14:52 <zygoloid> Seq is probably fast enough for most uses
17:15:15 <mm_freak_> ddarius: why?  Array is almost the fastest data structure, as long as you never add or remove elements
17:15:23 <zygoloid> and should be no worse asymptotically than an IntMap (fsvo asymptotically)
17:15:48 <jmcarthur> mm_freak_: one would normally use a doubly linked list when a zipper would be just as appropriate. in those few cases where it's not (you need access to arbitrary numbers of holes at a time) a doubly linked list implemented as an array would be way too slow
17:15:51 <hpc> if you never add or remove, linking is pointless, as you can do random access perfectly
17:16:07 <jmcarthur> yeah Seq is a good alternative
17:16:15 <napping> mm_freak_: not Array!
17:16:16 <copumpkin> meh, hackage went down right between haddock accesses for me
17:16:16 <copumpkin> annoying
17:16:32 <napping> an array of boxed values loses all the locality benefits
17:16:36 <zygoloid> Milkfloats are the fastest vehicle, as long as you never want them to move.
17:16:40 <napping> and you bounds checking to boot
17:16:51 <mm_freak_> napping: an array of boxed elements has still O(1) access
17:17:06 <jmcarthur> cache coherence is usually a major reason to go with arrays
17:17:19 <ddarius> mm_freak_: A doubly linked list also has O(1) access as long as you are treating it as a doubly-linked list.
17:17:22 <jmcarthur> only unboxed arrays really offer that
17:17:32 <zygoloid> napping: it depends when you force the elements ;)
17:17:39 <copumpkin> oh, all of galois went offline
17:17:45 <copumpkin> which is why hackage is offline now too
17:17:51 <ddarius> I certainly agree that an array is a faster implementation of an array than a doubly-linked list.
17:17:53 <copumpkin> I wonder what happened
17:18:14 <hpc> copumpkin: someone used unsafeLaunchMissiles
17:18:15 <zygoloid> napping: also an array of large boxed values which you randomly access might have better locality than a corresponding unboxed array
17:18:16 <mm_freak_> ddarius: that's a trivial statement and valid for virtually all traversable data structures
17:18:29 <zygoloid> (if it means the array of pointers then fits in cache)
17:18:55 <napping> mm_freak_: something like UArray is getting decently fast
17:19:15 <mm_freak_> hpc: if unsafeLaunchMissiles = unsafePerformIO launchMissiles, then actually the unsafe variant is safer than the safe one =)
17:19:34 <mm_freak_> it launches the missiles only when you look at the button ;)
17:19:40 <hpc> haha
17:19:46 <napping> zygoloid: that sounds very difficult to arrange
17:20:03 <napping> perhaps if you are only retrieving the pointers and passing them off to various other cores, which have the respective items in cache
17:20:27 <HandyGandy> I'm trying to compile a program and am getting undefined reference errors during linkage. THe symbols all look to be imported from Data.Map.
17:20:29 <jmcarthur> mm_freak_: the point is that an array has performance characteristics completely unlike a doubly linked list, and sometimes a true doubly linked list is faster (e.g. O(1) insertion to a doubly linked list vs. O(n) insertion to an array, even a mutable one!)
17:20:53 <zygoloid> napping: if that were the case you'd not need to look at the memory at all if it were unboxed. i agree it's hard to think of a case where the boxed array could be better!
17:20:56 <CakeProphet> untagged unions? do they exist in Haskell?
17:21:03 <jmcarthur> that of course depending on having the "hole" immediately available at the point of insertion already
17:21:16 <jmcarthur> CakeProphet: sure. just use unsafeCoerce all over the place
17:21:48 <CakeProphet> hmmm...
17:21:59 <jmcarthur> i'm not actually recommending that
17:22:04 <CakeProphet> I'll have to think about that one, and I just woke up so I'm not too good at thinking right now.
17:22:10 <napping> zygoloid: well, they do permit lazy evaluation, so they have uses algorithmically
17:22:15 <mm_freak_> jmcarthur: i agree
17:22:21 <zygoloid> napping: right, and that's one way to get a locality benefit
17:22:22 <jmcarthur> CakeProphet: what is the use case that you want untagged unions for?
17:22:23 <CakeProphet> jmcarthur:  I have no use for untagged unions. I'm simply wondering what it would like in Haskell.
17:22:28 <jmcarthur> ah
17:22:46 <napping> see polymorphic variants in O'Cam
17:22:50 <zygoloid> napping: if you only look at the same 20 items in an array of 1000, they're likely to be close in memory in the boxed world and far apart when unboxed
17:22:51 <napping> O'Caml, that is
17:22:53 <jmcarthur> CakeProphet: some forms of polymorphism can substitute for it
17:22:59 <napping> not some exotic irish derivative of Occam
17:23:11 <zygoloid> that'd be great, to be sure
17:23:39 <CakeProphet> jmcarthur:  I'm just wondering how well Haskell fares at being C. Perhaps this question could be answered for a C-to-Haskell translator.
17:24:19 <jmcarthur> CakeProphet: haskell is reasonable at being C. untagged unions are typically simulated with either unsafeCoerce or Ptr with castPtr
17:24:27 <napping> Oh, you mean untagged unions like that
17:24:41 <napping> I thought you meant like untagged unions of sane tagged data
17:24:52 <jmcarthur> napping: no, he means horrible things ;)
17:25:35 <napping> Oh, well, we'd just have to put on a type system to make them sane
17:25:36 <jmcarthur> CakeProphet: even in C there isn't really a such thing as an untagged union. either you are using it to do unsafe casts or you are carrying a tag around with it even if you don't realize it
17:26:07 <napping> and in a sufficiently powerful type system (Ynot?) you can probably explain what's really going on
17:26:10 <jmcarthur> the tag being whatever you check when you determine how to use the union
17:26:14 <CakeProphet> jmcarthur:  ...why on earth would they have an inaccessible tag?
17:26:30 <jmcarthur> CakeProphet: i mean conceptually, not in low level implementation details
17:26:34 <CakeProphet> ah.
17:26:46 <jmcarthur> CakeProphet: in C if you have a union you usually also create a tag yourself, even if you don't call it a tag
17:26:48 <CakeProphet> this is C we're talking about! none of that high level crap. :P
17:27:00 <jmcarthur> CakeProphet: and the tag may not actually be in any sort of wrapper struct or anything like that
17:27:34 <CakeProphet> yes. that is the most sane way to do it. I wonder why C doesn't have tagged unions in the first place.
17:27:37 <jmcarthur> CakeProphet: the only cases i can think of that you don't actually end up making a tag is when you are just using a union to make a prettier unsafe cast
17:28:08 <jmcarthur> (prettier than pointer casts, i mean)
17:28:37 <rhymes> Does hackage have any mirror? it seems down.
17:29:07 <napping> jmcarthur: well, there are things like (void * userarg) for callbacks
17:29:15 <napping> where it's really some kind of existential
17:29:20 <hpc> i recall there being someone who made a pseudo-mirror to test some algorithm related to the build process
17:29:26 <jmcarthur> napping: you still end up doing a cast to get anything useful from it
17:29:31 <hpc> forget the url though
17:29:37 <napping> a cast?
17:29:54 <jmcarthur> pointer cast i mean
17:30:01 <napping> doesn't void* avoid that?
17:30:04 <CakeProphet> @faq can Haskell be everywhere at once?
17:30:04 <lambdabot> The answer is: Yes! Haskell can do that.
17:30:12 <napping> oh well, I don't really expect to rely on the C type system for much of anything
17:30:18 <napping> beyond calculating field offsets, I guess
17:30:24 <jmcarthur> sure, void lets you cast implicitly
17:30:29 <jmcarthur> but it's still a cast
17:31:09 <CakeProphet> casting is what magicians do.
17:31:17 <napping> and what's a cast?
17:31:25 <CakeProphet> magic..
17:31:33 <napping> It doesn't have any operational effect
17:31:43 <napping> your program is sound for other reasons
17:32:02 <napping> with a strong type system, you might be able to express that in a checkable way
17:33:43 <theorbtwo> A cast is the escape hatch in the type system.  It is unsafeCoerce.
17:34:01 <aavogt> @ty cast
17:34:01 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
17:34:38 <jmcarthur> napping: in this case i guess it's weak typing
17:34:42 <aavogt> that one is for verifying types at runtime
17:34:48 <napping> sure, and if your program still can't be made to segfault or go wrong, there was some logic behind it
17:35:12 <napping> I mean, if we are talking about C or unsafeCoerce# style simple ignoring of the types
17:35:28 <ddarius> :t castPtr
17:35:29 <lambdabot> Not in scope: `castPtr'
17:35:35 <ddarius> @hoogle castPtr
17:35:35 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
17:35:36 <lambdabot> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
17:35:36 <lambdabot> Foreign.StablePtr castPtrToStablePtr :: Ptr () -> StablePtr a
17:35:36 <jmcarthur> :t Foreign.Ptr.castPtr
17:35:37 <lambdabot> forall a b. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b
17:36:01 <hpc> what's a fun pointer?
17:36:09 <napping> Is there a more weakly typed version of C?
17:36:16 <hpc> napping: assembly language
17:36:26 <jmcarthur> hpc: iirc, a function pointer, as in C
17:36:29 <ddarius> Functional correctness implies type correctness.
17:36:35 <ddarius> (usually)
17:36:37 <hpc> jmcarthur: ah
17:36:37 <napping> hpc: a pointer to functions, in case they are not interchangeable with normal pointers on the system
17:36:48 <napping> er, hmm
17:36:54 <CakeProphet> hpc:  I only know the term "fun pointer" from Erlang. I assume that's not what you're talking about thouigh...
17:36:58 <CakeProphet> *though
17:37:10 <CakeProphet> but yes, that's what it means.
17:38:27 <napping> ok, that is what it is for. I see the big warnings about not actually casting between them if it's not safe
17:39:44 <CakeProphet> is anyone here familiar with Erlang?
17:39:55 <CakeProphet> I'm wondering how to do links and monitors in concurrent Haskell.
17:39:55 <adnap> I just started learning about the Network library and I'm also pretty new to IO.  Can someone tell me if there is anything wrong with this code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28869#a28869
17:41:16 <CakeProphet> adnap: looks fine to me. :)
17:41:18 <Axman6> adnap: looks ok to me, nice and clear
17:41:23 <Axman6> well done
17:41:30 <napping> CakeProphet: depends how much you want
17:41:54 <CakeProphet> napping:  I assume you could emulate it with exception handling right?
17:41:56 <napping> some you can probably get with a top level wrapper that puts a "catch" around each thread
17:42:25 <CakeProphet> adnap:  the return ()'s at the end of your do blocks are unecessary.
17:42:46 <Axman6> ah yes
17:42:58 <Axman6> bleh, been far too long since i've written any haskell :(
17:43:49 <adnap> For some reason, when I run the client, it says "connect: does not exist...".  I assume that's a problem with my server configuration.
17:43:50 <napping> although being able to add or remove listeners might be a bit harder
17:44:24 <napping> oh, and of course that would all be local
17:45:45 <adnap> Man, I'm so jazzed that I'm starting to understand monads.
17:48:58 <heatsink> Is there an up-to-date online documentation of Alex?
17:49:12 <Axman6> adnap: i found them a hell of a lot easier to use than fully understand
17:49:45 <heatsink> Some of the "monad" wrapper documentation doesn't match the types my alex produces.
17:51:52 <adnap> Axman6: Yeah, I'm just happy to use them.  I understood the laws, but I don't know much about Category Theory.  I'm taking a class in Algebra this fall.  Maybe I'll get a little dose.
17:52:08 <Axman6> i doubt it
17:52:26 <Axman6> i've never done any CT, but i feel confident using most monads
17:53:07 <ddarius> It's not that uncommon for an (abstract) algebra class to cover a tiny bit of category theory.
17:54:07 <adnap> ddarius: Yeah, a former teacher of mine said we might get some.  I asked him specifically about CT, and he said that there's not really a dedicated class for it.  It's mostly just a tool used in a bunch of different subjects.
17:54:34 <Runar> is Hackage OK?
17:54:42 <ddarius> adnap: There are some decent resources for category theory online.  I've never taken a class on category theory or anything near it.
17:54:43 <copumpkin> Runar: nope
17:54:50 <Runar> copumpkin: Thanks :)
17:54:58 <HandyGandy> I'm trying to compile a program and am getting undefined reference errors during linkage. THe symbols all look to be imported from Data.Map.
17:55:45 <HandyGandy> BTW there are class on category theory on youtube, though they are a bit disjointed.
17:55:56 <adnap> ddarius: Yeah, I found this handy page yesterday: http://mathoverflow.net/questions/903/resources-for-learning-practical-category-theory :)
17:57:04 <heatsink> HandyGandy: -package containers
17:58:09 <HandyGandy> heatsink: Thanks.
17:58:42 <napping> HandyGandy: --make in general
17:58:43 <adnap> HandyGandy: ty--I'll search for it.
18:00:34 <ddarius> adnap: I recommend Awodey's book and Barr and Wells' ESSLLI lecture notes (not CTCS) and later "Basic Concepts of Enriched Category Theory" by Kelly.
18:14:53 <etpace> hackage down for you guys?
18:16:17 <dibblego> yes
18:16:21 <copumpkin> yeah
18:16:41 --- mode: ChanServ set +o dibblego
18:16:44 <copumpkin> all of galois seems to be down
18:17:06 --- topic: set to '["Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"] | Hackage is currently down at 0117UTC' by dibblego
18:17:11 --- mode: dibblego set -o dibblego
18:20:34 <Mathnerd314> can every data type be expressed as a series of ADT's? (ignoring memory layout)
18:21:25 <aavogt> what is a series in that context?
18:21:27 <copumpkin> Mathnerd314: ADTs in what sense? do you allow functions in them?
18:21:46 <Mathnerd314> aavogt: list of data declarations
18:21:53 --- mode: ChanServ set +o dibblego
18:22:05 --- topic: set to '["Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "Hackage is currently down"]' by dibblego
18:22:09 --- mode: dibblego set -o dibblego
18:22:14 <dibblego> sorry boot that
18:22:18 <Mathnerd314> copumpkin: I don't consider a function to be a data type, in this context
18:22:18 <copumpkin> dibblego: doubt it'll do much to stop people from asking :)
18:22:20 <tarcieri> ohai
18:22:26 <tarcieri> what's the syntax for a tuple with one element?
18:22:34 <copumpkin> Mathnerd314: so do you consider a datatype of ordinals to be a dataype?
18:22:34 <dibblego> copumpkin, I often check it anyway, so it'll stop me :)
18:22:49 <Mathnerd314> copumpkin: I'm not certain one exists
18:23:02 <copumpkin> Mathnerd314: sure it does, if you allow functions in your ADT :)
18:23:06 <aavogt> tarcieri: that data type doesn't exist
18:23:23 <tarcieri> *boggle*
18:23:25 <dibblego> tarcieri, Identity
18:23:33 <aavogt> tarcieri: what are you looking for in a one-tuple that you don't have from the value itself?
18:23:41 <Mathnerd314> copumpkin: but functions aren't data types; they have no representation in memory
18:23:50 <tarcieri> aavogt: nothing, although it surprises me it's undeclarable
18:23:51 <copumpkin> Mathnerd314: (the countable ones, anyway)
18:23:54 <copumpkin> Mathnerd314: their closures do
18:24:16 <tarcieri> why is this valid syntax: (,42)
18:24:30 <copumpkin> tarcieri: cause you have tuplesections turned on?
18:24:34 <aavogt> > (,42) 1
18:24:34 <lambdabot>   <no location info>: parse error on input `42'
18:24:39 <tarcieri> I see
18:25:17 <Mathnerd314> copumpkin: I still don't see how you'll get a datatype of ordinals
18:25:17 <tarcieri> well, that concludes my questions
18:25:18 <tarcieri> thanks
18:26:54 <copumpkin> Mathnerd314: http://blog.plover.com/math/ordinals.html has an explanation
18:26:59 <copumpkin> it's a fairly simple type though
18:28:43 <Wolfspaw> Good Evening Haskellers, i have a newbie doubt about how haskell(ghc) works in those simple cases: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28870#a28870
18:29:09 <Wolfspaw> Can someone take a look and tell me if it does the 2 things?
18:31:03 <Mathnerd314> copumpkin: that's the type of computable ordinals (since Haskell can't compute uncomputable things)
18:31:27 <Mathnerd314> copumpkin: anyways, I'm pretty certain you can express functions as ADT's
18:31:47 <Mathnerd314> copumpkin: since that's how Haskell compiles them
18:31:56 <Axman6> Wolfspaw: in the second case, woa will be reused once calculated once
18:32:02 <copumpkin> it compiles functions into ADTs? :O
18:32:19 <Axman6> and test should run in constans space
18:32:37 <Wolfspaw> Axman6: hmm, ok. Great, i was afraid it wouldnt xD. 
18:32:41 <Wolfspaw> Axman6: thanks!
18:32:45 <Axman6> or, maybe not, i'm not sure how length is actuall defined in ghc, i'm hoping its using s strict left fold
18:32:48 <Mathnerd314> copumpkin: no, it parses them into AST's (syntax trees), which are expressed as ADT's
18:34:33 <copumpkin> Mathnerd314: oh, sure, but that's an implementation detail
18:34:39 <copumpkin> but yeah, sure, they have a finite representation, you'd hope
18:34:50 <heatsink> copumpkin: What is an ordinal number?
18:35:52 <copumpkin> heatsink: something that tells you where you are in an ordered set
18:37:39 <napping> Wolfspaw: no particular guarantees are made about length, but sharing should be preseved in the latter
18:37:52 <napping> with reasonable implementations length should run in constant space
18:38:02 <heatsink> Ordered sets can have different cardinalities.  How big are the ordinals?
18:38:28 <copumpkin> heatsink: HUGE :P
18:38:40 <Wolfspaw> napping: okay, thanks for the help! ^^
18:39:08 * heatsink holds its arms really really far apart
18:39:10 <heatsink> This big?
18:39:17 <napping> Wolfspaw: although, if you are unlucky the *arguments* to a tail recursive function might get big
18:39:20 <napping> if they are too lazy
18:39:41 <copumpkin> heatsink: not sure you can even describe the ordinals as a set (at least one with a describable cardinality), but I'm not an expert
18:39:57 <heatsink> Hmm, okay
18:40:02 <copumpkin> I'm sure the more mathy people here can answer that
18:41:10 <Wolfspaw> napping: hmm, because of the (n-1) ? , it will make a chain of thunks( n:(n-1):(n-1-1):(n-1-1-1):(n-1-1-1-1)...) ?
18:42:10 <napping> it might
18:42:21 <napping> but is not required to
18:42:26 <Wolfspaw> hm @_@
18:42:35 <napping> ghc -O in particular will realize it will eventuaally be returned, and do it strictly
18:43:56 <Wolfspaw> napping: alright, i'll remember that flag! (Normally im using -O2, even though i dont understand what it does... But since i see here and there people saying "use O2 for better perfomance", i use o.o
18:44:31 <pikhq> Wolfspaw: -O is short for -O1, which is the optimisation level *below* -O2.
18:44:48 <pikhq> Wolfspaw: -O2 takes longer to *compile* than -O1, but generally produces better binaries.
18:44:58 <napping> mostly it's just numerical accumulators that run into that
18:45:03 <Wolfspaw> pikhq: ah! Ok, nice
18:47:10 <copumpkin> did you hear that apple fixed the big pdf hole, but not on the first gen iphone?
18:47:22 <copumpkin> oh whoops, wrong channel
18:47:35 <heatsink> I read the article, but I don't think I get the idea of adding limit ordinals.
18:49:28 <sbahra> Welcome to #haskell, mauke.
18:50:11 <sbahra> copumpkin, that website owned me.
18:50:27 <sbahra> copumpkin, jailbreakme, I thought some warning would pop up after I slid my finger...
18:50:46 <Mathnerd314> sbahra: wrong channel
18:50:53 <sbahra> copumpkin, but no, it just went ahead and owned my iPad. After a reboot, I was just stuck in boot. :-P
18:51:11 <sbahra> Oh.
18:57:15 <lispy> hackage is down :(
18:57:37 <copumpkin> lispy: all of galois seems down :(
18:57:43 <copumpkin> I noticed that lispy1 went offline
18:58:06 <Phyx-> hmm
18:58:18 * Phyx- hopes there's no defacing
19:00:28 <tehgeekmeister> anyone know anything about hackage being down?
19:00:43 <tehgeekmeister> is it coming back soon?
19:01:11 <copumpkin> I hope so
19:01:51 <Phyx-> hey lispy 
19:03:36 <Kaidelong> copumpkin: well it'd be pretty embarrassing considering they are supposed to developing highly reliable systems~
19:03:51 <Kaidelong> but I suppose their website is unrelated to their work
19:03:54 <Kaidelong> in that sense
19:03:57 <copumpkin> yep :)
19:07:36 <lispy> copumpkin: yeah
19:07:40 <jmcarthur> man, it sucks when hackage is down
19:08:04 <lispy> Kaidelong: I think building construction may have taken us off line
19:08:16 <Phyx-> someone ran into it with a crane?
19:08:24 <lispy> hehe
19:08:36 <jmcarthur> is there a mirror yet?
19:08:39 <copumpkin> http://sparky.haskell.org:8080/packages/ is another option
19:08:42 <jmcarthur> somebody needs to set one up
19:08:47 <copumpkin> not sure how to point cabal-install at it though
19:08:53 <jmcarthur> oh sparky!
19:09:30 <Kaidelong> lispy: packet over air?
19:09:33 <jmcarthur> dang it doesn't have online documentation :(
19:09:38 <jmcarthur> at least i can get the package
19:10:00 * Phyx- hugs his local package cache
19:10:24 <tehgeekmeister> Phyx-: is there a way to *keep* all of the packages cached?
19:10:37 <tehgeekmeister> like, *all*.
19:11:01 <Kaidelong> tehgeekmeister: why would that be a good thing unless you WANT to mirror hackage?
19:11:06 <Phyx-> no idea.. I just have the packages I have installed cached
19:11:21 <Phyx-> since I regularly recompile ghc, it saves time aswell
19:11:41 <Phyx-> speaking of which, any idea when 6.14 will be out?
19:11:56 <tehgeekmeister> Kaidelong: because it seems that hackage downtime happens right when i need it most, and if i had all the packages and documentation, there wouldn't be a problem at all.
19:12:18 <copumpkin> tehgeekmeister: just go to sparky
19:12:22 <Kaidelong> surely you'd only want to cache stuff you actually want to use?
19:12:28 <lispy> distributing hackage into a bittorrent cloud would be cool
19:12:41 <Kaidelong> not for example, the console based toilet queing application
19:12:43 <Phyx-> and make cabal use the torrents?
19:13:00 <Phyx-> well, besides that torrents get throttled on alot of universities nowadays
19:13:01 <Phyx-> nay
19:13:02 <Phyx-> :/
19:13:07 <tehgeekmeister> Kaidelong: but i often find out what i want in the process of coding.  it just seems that hackage is small enough i might as well cache the whole thing.
19:13:07 <lispy> yeah :(
19:13:21 <lispy> Phyx-: so just encrypt the packet headers
19:13:23 * copumpkin just installed a package :)
19:14:05 <tehgeekmeister> copumpkin: can i point cabal to sparky?
19:14:08 <lispy> Phyx-: at least, that works on comcast where they drop bittorrent packets after the initial few
19:14:21 <Phyx-> lispy: that could work, would be an interesting idea
19:14:31 <copumpkin> tehgeekmeister: I tried that, but it didn't seem to work for me, but downloading tarballs from it works fine
19:14:49 <tehgeekmeister> copumpkin: meh, i guess if i have to, it'll work.
19:14:52 <Phyx-> lispy: the downside is, that you have to have people leeching
19:15:02 <Phyx-> lispy: if a package isn't used alot, it'll be hard to download
19:15:28 <Phyx-> lispy: and how would you deal with versioning? 
19:15:33 <lispy> Phyx-: hmm....I guess I was thinking that you'd have multiple dedicated seeders.
19:16:19 <lispy> Phyx-: I was also making the assumption that you could bolt a sort of hierarchical set of paths on it, like the URLs now for hackage
19:16:45 <Phyx-> lispy: that would work, but you'd still have a single point of failure for uploading packages though. one server would have to receive the upload and redistribute
19:16:48 <copumpkin> wouldn't have to be bittorrent
19:16:58 <Phyx-> but you could atleast still download
19:17:00 <copumpkin> could just be any DHTish thing
19:17:05 <Phyx-> copumpkin: true
19:17:28 <lispy> Like Tahoe LAFS?
19:17:57 <lispy> http://tahoe-lafs.org/trac/tahoe-lafs
19:18:17 * lispy will be back later
19:18:19 <Phyx-> oooh
19:18:22 <Phyx-> that looks cool
19:18:31 <Phyx-> ok, have fun lispy 
19:19:30 <tehgeekmeister> sparky doesn't have what i need D=
19:19:34 <tehgeekmeister> oh well.
19:19:49 <copumpkin> tehgeekmeister: what do you need?
19:19:56 <copumpkin> I thought it was relatively in sync
19:19:58 <tehgeekmeister> hexpat 0.16
19:20:27 <tehgeekmeister> unless i try to manually cabal update, which seems insane
19:21:43 <tehgeekmeister> if only cabal could be pointed at mirrors easily, man.  i wouldn't mind keeping one up just so i could keep hacking.
19:23:04 <aavogt> tehgeekmeister: you can change in your ~/.cabal/config this field:
19:23:05 <aavogt> remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
19:24:00 <Phyx-> if mirrors exists, why doesn't cabal ship with a list of them?
19:24:56 <copumpkin> aavogt: I've tried, but can't get much out of sparky 
19:25:07 <copumpkin> not sure if that's just my shitty internet connection though
19:25:16 <aavogt> sparky is rather laggy
19:25:19 * aavogt tries
19:25:21 <copumpkin> oh, it was
19:25:21 <copumpkin> it finally finished updating
19:25:44 <copumpkin> so is my 3g dongle
19:28:06 <eflister> can anyone here reboot hackage?
19:28:47 <aavogt> copumpkin: yeah, sparky works, but it's rather laggy compared to the real hackage
19:28:58 <copumpkin> aavogt: yeah, I'm using it now
19:28:58 <aavogt> eflister: you can put in your ~/.cabal/config
19:28:59 <aavogt> remote-repo: sparky.haskell.org:http://sparky.haskell.org:8080/packages/archive
19:29:15 <copumpkin> omg its a Gracenotes 
19:29:18 <copumpkin> Gracenotes: thanks to you, we're saved!
19:29:33 <Phyx-> lol
19:29:50 * Phyx- wonders why some people have weird hostnames on freenode.
19:29:56 <Phyx-> I'm not well versed in freenode-fu
19:32:55 <tehgeekmeister> sparky doesn't even have snap
19:33:00 <tehgeekmeister> it is not up to date at all
19:33:07 <tehgeekmeister> rather, in sync
19:33:35 <aavogt> that's because it's written using happstack
19:35:03 <aavogt> but perhaps Gracenotes can clarify the situation
19:40:09 <zeiris_> Are there any real Haskell applications that make use of arrows/the arrow syntax?
19:41:29 <luite> I've only used it for HXT
19:50:09 <smorg> Currently any place to grab haskell platform for windoze?
19:50:52 <luite> there's a torrent
19:51:00 <medfly> weird. I recall just getting it from the website?
19:54:43 <luite> smorg: I think I still have the .torrent file for windows, want me to upload it somewhere?
19:55:07 <luite> it uses the openbittorrent tracker, so it should still work
19:55:45 <smorg> Hah of course google takes me to hackage to get it ^^
19:56:49 <luite> smorg: yeah I noticed, that's why I offered to upload it :) I already searched the pirate bay, but it isn't listed
19:59:22 <dibblego> I have HaskellPlatform-2010.2.0.0-setup.exe but nowhere to put it
19:59:40 <dibblego> give me a server and I'll plonk it there
19:59:44 <smorg> nor does demonoid
20:00:33 <smorg> really need to get sftp jail working
20:01:26 <luite> http://jabberwock.xs4all.nl:8081/HaskellPlatform-2010.2.0.0-setup.exe.torrent
20:01:30 <luite> hope it works
20:03:55 * dilinger reads mpj's blog post and wishes he lived in portland
20:04:03 <Associat0r> http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem/
20:06:39 * lispy is back
20:06:55 <lispy> dilinger: mpj?
20:07:13 <dilinger> lispy: http://www.galois.com/blog/2010/05/12/tech-talk-developing-good-habits-for-bare-metal-programming/
20:07:24 <lispy> dilinger: we'll post that on vimeo
20:07:41 <lispy> dilinger: http://vimeo.com/channels/galois
20:07:48 <luite> dilinger: galois is down too
20:07:49 <lispy> oh, it's already there
20:08:05 <dilinger> yeah
20:08:19 <Associat0r> does that P stand for Peyton too btw?
20:08:19 <dilinger> habit sounds right up my alley (i do a lot of kernel stuff)
20:08:25 <lispy> a lot of people all over the world have started watching our tech talks.  It's really quite exciting
20:08:46 <Associat0r> lispy
20:08:56 <lispy> Associat0r: yessir?
20:09:08 <Associat0r> Mark Peyton? Jones
20:09:20 * lispy shrugs, dunno!
20:09:50 <monochrom> Indiana Jones and the Lost Monad
20:11:02 <monochrom> Indiana Jones and the Kleisli Lost Monad = IJKLM
20:11:19 <ClarkG> So why's hackage down?
20:12:09 <ezyang> Indiana Jones and the tribe of the UnsafePerformIO 
20:12:24 <luite> ClarkG: it's not down, its IO is just a bit lazier than usual
20:12:26 <lispy> temple of unsafePerformIO
20:12:32 <ClarkG> lol
20:12:41 <monochrom> Simon Peyton Jones and the Stackless Tagless G-Machine :)
20:12:57 <dolio> Spineless, dude.
20:13:01 <monochrom> oops
20:14:13 <copumpkin> been using too much python recently? :)
20:14:21 * copumpkin has :(
20:14:26 <ezyang> STG kind of sounds like a porno. 
20:14:34 <Adamant> copumpkin: damn that real world
20:14:42 <Adamant> I have too :(
20:14:50 <ClarkG> or like an STL
20:14:52 <ClarkG> *STD
20:14:59 <Adamant> it grows on you. kind of like foot fungus.
20:15:01 <copumpkin> Adamant: I wouldn't say that :) just had to write a script for a program that was scriptable in python and nobody's written a plugin for haskell yet
20:15:05 <Adamant> ah
20:15:18 <monochrom> I still haven't learned python :)
20:15:27 <ClarkG> how is that possible?!
20:15:32 <Adamant> monochrom is clearly the wisest person here
20:15:54 <monochrom> I also haven't learned yacc-like parsing
20:16:14 <ClarkG> next thing you know he's going to say he hasn't even learned C yet.
20:16:14 <dibblego> I threatened to quit if I was forced to continue with python, in the interest of the company, and my employer conceded
20:16:20 <lispy> Python? Why did it have to be pythons?  -- Indiana Peyton Jones
20:16:31 <monochrom> heh
20:16:58 <lispy> His father is afraid of packrat parsers
20:17:00 <monochrom> @remember lispy Python? Why did it have to be pythons?  -- Indiana Peyton Jones
20:17:00 <lambdabot> It is forever etched in my memory.
20:17:01 <copumpkin> there's not much to learn
20:17:01 <copumpkin> lol
20:17:25 <copumpkin> what happened to the HWN?
20:17:40 <monochrom> equivalent to mmorrow
20:17:41 <lispy> copumpkin: last I heard, jfredet's computer died
20:17:48 <copumpkin> seems like if whatshisname can't do it, we could find someone else?
20:17:56 <copumpkin> preflex: seen jfredett
20:17:56 <preflex>  jfredett was last seen on #haskell-blah 155 days, 18 hours, 52 minutes and 44 seconds ago, saying: and with that, I bid Adeiu to you, fair Haskellians, I go now to sleep.
20:18:08 <lispy> whoa
20:18:13 <monochrom> sleeping beauty
20:18:24 <lispy> Foreboding much?
20:18:24 <monochrom> we need a prince to kiss him
20:19:33 <copumpkin> preflex: seen spj
20:19:34 <preflex>  Sorry, I haven't seen spj
20:20:59 <lispy> preflex: seen a good time
20:20:59 <preflex>  a was last seen on #perl 155 days, 43 minutes and 20 seconds ago, saying: thanks for all your help, everyone. also thanks for all the resources. maybe next time i come in here you wont be offended by my stanky perl
20:21:10 <lispy> preflex: seen a_good_time
20:21:10 <preflex>  Sorry, I haven't seen a_good_time
20:25:08 <ddarius> Fraa Jad is a badass.
20:26:09 <copumpkin> I haven't read it yet
20:27:54 <ezyang> I can't wait for byorgey's project to land in GHC. 
20:28:42 <copumpkin> ezyang: what's that?
20:31:06 <lispy> Is brent working on the supercompilation?
20:31:52 <copumpkin> that was pejo
20:32:04 <copumpkin> (peter jonsson iirc)
20:33:09 <copumpkin> I remember byorgey mentioning something about a more integrated SHE-alike for doing some limited type-level computation
20:33:56 <catenate> why the symbol $ especially?  I think ... would look better: compare    head . drop 4 $ ['a'..'z'] â 'e'     to     head . drop 4 ... ['a'..'z'] â 'e'
20:34:45 <copumpkin> @let (...) = ($)
20:34:46 <lambdabot>  Defined.
20:34:55 <siracusa> Oh no, Hackage is down ...
20:34:58 <copumpkin> head . drop 4 ... ['a'..'z']
20:35:17 <catenate> > head . drop 4 ... ['a'..'z']
20:35:18 <lambdabot>   Precedence parsing error
20:35:18 <lambdabot>      cannot mix `L..' [infixr 9] and `L....' [infi...
20:35:19 <copumpkin> siracusa: you can go to sparky.haskell.org:8080
20:35:25 <copumpkin> > head . drop 4 ... ['a'..'z']
20:35:26 <lambdabot>   Precedence parsing error
20:35:26 <lambdabot>      cannot mix `L..' [infixr 9] and `L....' [infi...
20:35:41 <catenate> > infix 0 ...
20:35:42 <lambdabot>   <no location info>: parse error on input `infix'
20:35:58 * jmcarthur wonders
20:36:01 <catenate> er, however you tell lambdabot that
20:36:04 <siracusa> copumpkin: Great, thanks!
20:36:25 <copumpkin> @undef
20:36:35 <catenate> infixr 0 ...
20:36:37 <catenate> actually
20:36:42 <tkahn6> is it possible to have a list of arbitrarily typed functions?
20:36:50 <copumpkin> @let infixr 0 ...; (...) = ($)
20:36:51 <lambdabot>  Defined.
20:36:59 <copumpkin> > head . drop 4 ... ['a'..'z']
20:37:00 <lambdabot>   'e'
20:37:03 <catenate> yay
20:37:06 <jmcarthur> i doubt the undef was even necessary
20:37:30 <jmcarthur> @undef
20:37:37 <jmcarthur> @let (...) = ($)
20:37:38 <lambdabot>  Defined.
20:37:42 <jmcarthur> @let infixr 0 ...
20:37:45 <lambdabot>  Defined.
20:37:53 <jmcarthur> > head . drop 4 ... ['a'..'z']
20:37:54 <lambdabot>   'e'
20:37:56 <jmcarthur> :)
20:38:12 <copumpkin> omg l33tness
20:38:18 <catenate> I did waht you just did for myself, already: I love the ability to define new operators.  I was actually wondering whether anyone knew why $ is the best symbol for that purpose
20:38:39 <copumpkin> shorter?
20:39:21 <jmcarthur> probably just arbitrary
20:39:30 <jmcarthur> and yeah, one character is shorter than three :)
20:39:40 <monochrom> all the other easy punctuations are taken
20:39:50 <ddarius> jmcarthur: You don't want to write Foo.... ?
20:40:28 <jmcarthur> i think another motivator for $ is that it's visually dense, which is appropriate since it has such a low fixity
20:40:39 * ddarius considers abusing operators to write code in Morse code.
20:40:44 <jmcarthur> o_O
20:40:45 <catenate> ok then, if we want one symbol,  how about â¦
20:41:12 <monochrom> â¦ was not easy 10 years ago
20:41:13 <jmcarthur> but why?
20:41:30 <catenate> I know, it's already taken as the unicode form of .. by -XUnicodeSyntax
20:42:07 <monochrom> do you remember how hard it was to enter non-ascii symbols 10 years ago?
20:42:41 <copumpkin> nope
20:42:49 <catenate> $ means nothing to me, that's all.  Unicode is easy to enter now, I have thousands of Alt <key> <key> bindings in Acme
20:43:00 <medfly> not at all, considering I did it 10 years ago :P
20:43:03 <tkahn6> is it possible to have a list of arbitrarily typed functions?
20:43:23 <copumpkin> tkahn6: within reason
20:44:03 <tkahn6> im messing around, trying to create an interpreter. it would be useful to have a function table which i could call `lookup` on
20:44:40 <catenate> you could make a tuple of differently-typed functions
20:44:47 <monochrom> for that matter you should be asking why we are still using plain text files for programs
20:44:57 * ddarius always wonders what people expect to do with these "hetergeneous" lists.
20:45:10 <catenate> I'm cool with utf8 plain text, just not ascii plain text
20:45:26 <tkahn6> yeah but then i would have to conceive of every possible type
20:45:43 <monochrom> GUI is easy to create and use now, we have thousands of widgets to choose from, etc.
20:45:57 <copumpkin> tkahn6: not really
20:46:16 <tkahn6> oh ok. how do you mean?
20:46:20 <catenate> I actually just started a project to define methods in various languages to get beyond ascii: http://github.com/catenate/unicoper
20:46:43 <copumpkin> tkahn6: well, you want to represent your language's types in haskell's?
20:46:50 <copumpkin> tkahn6: that will be hard
20:46:54 <smorg> ['a'..'z'] holy crap nice
20:47:19 <copumpkin> tkahn6: assuming you want something that isn't like haskell
20:47:24 <tkahn6> yeah
20:47:51 <copumpkin> so then you need to figure out how your types will work, and represent them as a structure
20:47:53 <monochrom> heterogeneous lists are overrated
20:47:57 <catenate> smorg: I'm reading Real World Haskell, the basic idea is in the first chapter
20:47:59 <copumpkin> note that it doesn't mean you need to imagine every possible type :P
20:48:04 <tkahn6> haha ok
20:48:06 <tkahn6> i'll work on that
20:48:21 <monochrom> if anything, the expression problem itself has higher priority
20:49:07 <catenate> > ['a'..'z']
20:49:07 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
20:49:28 <ddarius> "heterogeneous lists" don't exist
20:49:48 <monochrom> yay!
20:50:34 * copumpkin wrote a simple heterogeneous vector parametrized by a (homogeneous) vector of types in a certain other language
20:51:04 <smorg> >['a','c'..'z']
20:51:29 <catenate> tkahn6: If you want to represent types you could study the way gcc breaks down types in various languages into GIMPLE trees
20:52:04 <catenate> smorg: space after > which is like bird notation in literate-haskell files
20:52:17 <tkahn6> cool. i'll check that out
20:52:33 <copumpkin> or read up on universes in epigram :)
20:52:40 <copumpkin> if you want to look at "the other side" of it
20:53:49 <lispy> What does Maybe a look like in CPS?
20:53:57 <copumpkin> :t maybe
20:53:58 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:54:18 <lispy> b -> (a -> b) -> b?
20:54:49 <ddarius> That's Church/Scott encoded.  It doesn't make sense to talk of Maybe as being in CPS.
20:55:08 <lispy> ah
20:55:32 <ddarius> :t \k -> k Nothing Just
20:55:33 <lispy> I have something right now like ByteString -> Maybe (a, ByteString) and I want to turn it into CPS
20:55:33 <lambdabot> forall a a1 t. (Maybe a -> (a1 -> Maybe a1) -> t) -> t
20:56:14 <ddarius> Again, code is in CPS, not types or even representations of types.
20:56:44 <lispy> ddarius: okay
20:57:56 <copumpkin> lispy: if you want it in CPS, you need to take an additional parameter, which is your continuation
20:58:07 <lispy> Maybe (a, ByteString) becomes (a, ByteString) -> ((a, ByteString) -> b) -> b ?
20:58:52 <lispy> ByteString -> (a, ByteString) -> ((a, ByteString) -> b) -> b, is my final type?
20:59:20 <copumpkin> nope, you got your a and b mixed up
20:59:36 <Saizan> ByteString -> b -> (a -> ByteString -> b) -> b
20:59:38 <copumpkin> but keep the data encoding and the continuation stuff separate, first
21:00:00 <lispy> Saizan: oh, untuple, that's smart
21:00:07 <datwinkdaddy> @hoogle Data.Map.Map
21:00:07 <lambdabot> module Data.Map
21:00:07 <lambdabot> Data.Map data Map k a
21:00:08 <lambdabot> Data.Map map :: (a -> b) -> Map k a -> Map k b
21:00:20 <Saizan> also the 'b' in place of the first (a, ByteString) in yours
21:00:25 <lispy> copumpkin: what do you mean keep them separate?
21:01:15 <copumpkin> well, you can rewrite the original function with a continuation, without breaking up the Maybe
21:02:26 <dolio> BS -> Maybe (a, BS) ==> BS -> (Maybe (a, BS) -> b) -> b ==> BS -> (b, (a, BS) -> b) -> b ==> BS -> (b, a -> BS -> b) -> b ==> BS -> b -> (a -> BS -> b) -> b
21:04:14 <lispy> I'm still not sure I follow the meaning of b
21:04:25 <lispy> BS -> Maybe (a, BS) has 1 type variable
21:04:28 <copumpkin> b is some unknown type that your caller will provide
21:04:31 <lispy> But, the new version has 2
21:04:48 <copumpkin> the function from your original return type to the b is the continuation
21:05:04 <lispy> b is the final result of the computation
21:05:11 <copumpkin> yep
21:05:12 <lispy> so, like Cont a r, r and b are the same
21:05:26 <Saizan> Cont r a
21:05:32 <lispy> Saizan: heeh, thanks
21:05:38 <lispy> I always reorder them on accident
21:05:44 <lispy> I know the r has to come first to make the monad though
21:05:56 <lispy> I could use the same trick here
21:06:06 <copumpkin> anyway, it's the same as Cont
21:06:18 <copumpkin> up to the decomposing of Maybe into a church encoding, at least
21:06:49 <lispy> yes
21:07:06 <copumpkin> @unmtl Cont r a
21:07:07 <lambdabot> (a -> r) -> r
21:07:12 <smorg> > fix (\f (x:y:xs) -> [x] ++ (if null xs then [] else f xs)) $ ['a'..'z']
21:07:14 <lambdabot>   "acegikmoqsuwy"
21:07:26 <lispy> I'm trying out this transformation to see if I can it more memory efficient than the Maybe (a, BS) version
21:14:10 * BMeph encourages lispy to "try it out like a rent-a-Tux"! :)
21:20:41 <lispy> BMeph: heh
21:20:58 <lispy> copumpkin: So, I should be able to leverage Cont to implement this right?
21:21:59 * lispy doesn't see how so he's going with the direct implementation for now
21:26:01 <azaq23> @docs System.IO.Unsafe -- the described program in the documentation for unsafePerformIO does not coredump on ghc 6.12.1
21:26:01 <lambdabot> System.IO.Unsafe -- the described program in the documentation for unsafePerformIO does not coredump on ghc 6.12.1 not available
21:30:04 <deech> You guys probably know this but Hackage appears to be down.
21:30:23 * BMeph not-so-subtily points at the MOTD...
21:30:27 <smorg> last item in /topic
21:31:20 <deech> smorg: I'm relatively new to IRC, what is this /topic you speak of?
21:31:21 <FunctorSalad_> isn't ImpredicativeTypes useful for callCC?
21:31:44 <smorg> deech: type /topic and find out :)
21:31:56 <deech> Sweet!
21:31:57 <FunctorSalad_> so you can type it as '((a -> ContT r m (forall b . b)) -> ContT r m a) -> ContT r m a'
21:32:44 <FunctorSalad_> maybe I'm just misusing callCC though to need to call the cc at multiple b's
21:33:17 <smorg> heh it topic a list for a reason?
21:33:46 <smorg> > last @topic
21:33:47 <lambdabot>   Pattern syntax in expression context: last@topic
21:34:30 <BMeph> copumpkin: So, what does the CPS buy him?
21:42:15 <Saizan> FunctorSalad_: ((forall b. a -> ContT r m b) -> ContT r m a) -> ContT r m a <- maybe this would be enough?
21:42:45 <FunctorSalad_> Saizan: hehe I just thought that. I think it would, but it's not a specialization of callCC ;)
21:42:57 <FunctorSalad_> they'd have to rewrite callCC
21:43:01 <FunctorSalad_> (mtl)
21:43:03 <Saizan> true :)
21:44:57 <FunctorSalad_> (hmm I think I could achieve the same by calling the cc like "cc foo >> return undefined")
21:47:01 <FunctorSalad_> or instantiating b=Void...
21:55:54 <dolio> They wouldn't have to rewrite callCC. Just the type signature.
22:02:46 <lispy> I can't figure out how to write bind for this monad
22:03:12 <lispy> I think I started it correctly: \m f -> SM $ \s r k -> runSM m s r (\a s' -> runSM (f a) s' ...
22:03:27 <lispy> newtype SM r a = SM { runSM :: String -> r -> (a -> String -> r) -> r }
22:04:03 <lispy> I don't see how to get the r or the (a -> String -> r) that gets passed to the second runSM
22:06:46 <dolio> You don't get it. You provide it.
22:06:47 <kmc> FunctorSalad_, i've run into this issue but i used the rank-3 type rather than the impredicatve one
22:07:04 <lispy> dolio: ?
22:07:12 <lispy> dolio: help please :)
22:07:24 <dolio> It might help to think of the 'r' as the failure continuation, and the (a -> String -> r) as the success continuation.
22:07:28 <FunctorSalad_> kmc: I went with newtype Void = Void { void :: forall b . b }, invoke with fmap void cc
22:07:35 <kmc> ok
22:07:48 <FunctorSalad_> (rank-3 though?)
22:07:48 <kmc> that's good, saves having to rewrite the whole Cont library ;)
22:08:06 <dolio> So, when you construct an SM r a, you get \s fail suc -> ...
22:08:27 <dolio> And when you destruct, you 'runSM m fail suc'.
22:08:57 * lispy nods
22:11:16 <lispy> dolio: the problem is that, when I apply (f a), I get something SM r c, and I don't know where the fail/suc come from for it
22:11:37 <FunctorSalad_> (btw, is there any choice to be made in how to lift 'catch' to ContT r IO?
22:11:38 <FunctorSalad_> )
22:11:46 <dolio> Well, you haven't used the success continuation you were passed.
22:11:52 <FunctorSalad_> it seemed like the types just fit together in one way luckily
22:12:08 <lispy> dolio: I passed it to the first runSM
22:12:20 <dolio> No, you didn't.
22:12:46 <dolio> It would have the wrong type anyway.
22:13:30 <dolio> What you're passed are the success and failure continuations of (m >>= f), too.
22:14:01 <dolio> So, first you look at m. If it fails, you fail using the failure continuation of (m >>= f).
22:14:24 <dolio> And the success continuation you've given to m is that lambda expression (\a s' -> ...)
22:16:06 <lispy> dolio: so how does the failure continuation work in the (\a s' -> ...) part?
22:16:34 <dolio> How does 'm >>= \_ -> Nothing' work?
22:17:39 <lispy> I don't see what you're getting at
22:17:50 <lispy> It ignores what its passed and returns Nothing
22:17:52 <dolio> Nothing >>= f is failure.
22:18:06 <dolio> m >>= \_ -> Nothing is also failure.
22:18:27 <lispy> I don't have a Nothing to return.  I need something of type r, so I can't even return a function can I?
22:18:54 <dolio> So, if you're told how what to do on failure for (m >>= f), then if m fails, you do that. And if m succeeds with a, but (f a) fails, you do whatever the failure was.
22:19:22 <dolio> Anyhow, you only have one thing of type r, so there's only one thing you can do anyway.
22:19:32 <lispy> (\a s' -> runSM (f a) fail ... ) ?
22:19:36 <dolio> The types probably fully determine what you can do.
22:20:30 <lispy> Hm...for some reason I thought it would be wrong to repeat the fail
22:20:36 <lispy> It does type check now
22:20:47 <Saizan> yeah, you could've asked djinn :)
22:21:07 <Saizan> ?djinn-add type SM r a = String -> r -> (a -> String -> r) -> r
22:21:07 <lambdabot> Error: Undefined type String
22:21:34 <Saizan> ?djinn-add type SM string r a = string -> r -> (a -> string -> r) -> r
22:21:54 <Saizan> ?djinn SM string r a -> (a -> SM string r b) -> SM string r b
22:21:54 <lambdabot> f a b c d e = a c d (\ f g -> b f c d (\ h _ -> e h g))
22:22:45 <dolio> Well, that's wrong, I think.
22:23:50 <dolio> It got a little zealous with that last continuation.
22:24:14 <lispy> ?djinn a -> SM r a
22:24:14 <lambdabot> Error: kind error: (KVar 3,KStar)
22:24:23 <lispy> ?djinn a -> SM string r a
22:24:23 <lambdabot> f a b _ c = c a b
22:24:57 <Saizan> with a data declaration it might have been clearer
22:25:52 <Saizan> dolio: it also reaused the original String c, it seems
22:26:02 <dolio> That too.
22:26:39 <Saizan> no one ever implemented the linear types extension?:)
22:26:40 <lispy> Thanks guys.  Sorry I was so dense.  Now that I have it type checking it seems more obvious, even though I'm a little hung up on the duplicated fail thingy
22:26:48 <dolio> It used c where it should have used g, and used g where it should have used that thing it threw away.
22:28:17 <Saizan> lispy: with Maybe you don't get told where a Nothing happened, they all look the same from the outside
22:28:50 <lispy> Saizan: hmm?
22:29:23 <Saizan> that was to explain why fail gets used twice in >>=
22:29:58 <lispy> ah
22:30:11 <lispy> the next trick is to write this: parseStrictly :: SM r a -> B.ByteString -> Maybe (a, B.ByteString)
22:30:48 <lispy> parseStrictly p s = runSM p s Nothing (\a s' -> Just (a, s')) ?
22:31:00 <lispy> I guess I should just check if it type checks
22:35:44 <quicksilver> dolio: djinn's attempt to be relevant is only one level deep, it's not fully recursive.
22:36:12 <quicksilver> dolio: as a logic I don't think it's very a nice setup.
22:36:22 <Saizan> unfortunately with continuations around there are always quite a few non-sensical things that typecheck
22:36:52 <quicksilver> yeah, down with continuations! 
22:37:56 <dolio> Well, that's not always true. callCC is fully determined, I think...
22:38:14 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
22:38:14 <lambdabot> Error: Undefined type Cont
22:38:24 <dolio> @djinn-add type Cont r a = (a -> r) -> r
22:38:27 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
22:38:27 <lambdabot> f a b = a (\ c _ -> b c) b
22:39:04 <Saizan> i knew i should've s/always/often/ :)
22:39:17 <dolio> It's the extra state passing that gets you, and that has the same problem without continuation passing.
22:39:40 <dolio> @djinn (s -> (s, a)) -> (a -> s -> (s, b)) -> s -> (s, b)
22:39:40 <lambdabot> f a b c =
22:39:40 <lambdabot>     case a c of
22:39:40 <lambdabot>     (d, e) -> b e d
22:40:36 <dolio> It could throw away d, or do case analysis on 'b e d' and throw away its state and reuse one of the other ones.
22:42:14 <TSC> Poor old hackage is down; is there any other way to get packages?
22:42:24 <Saizan> other things are made worse by CPS though, e.g. Maybe's >>=
22:42:56 <Saizan> once you're given an 'r' you can use it anywhere and forget about the rest
22:43:47 <dolio> @djinn (r -> (a -> r) -> r) -> (a -> (r -> (b -> r) -> r)) -> r -> (b -> r) -> r
22:43:47 <lambdabot> f a b c d = a c (\ e -> b e (a c (\ _ -> c)) d)
22:43:54 <Saizan> TSC: you could try the new one http://sparky.haskell.org:8080/ 
22:44:15 <Saizan> TSC: still in a testing/experimental state though
22:44:33 <TSC> Saizan: Thanks, it looks like it's working so far (:
22:44:39 <TSC> Can I tell cabal to use it?
22:45:20 <Saizan> i think so
22:45:26 <TSC> I'll give it a whirl
22:45:35 <Saizan> add a new remote-repo in ~/.cabal/config
22:45:51 <dolio> That one's calling 'a' twice for some reason?
22:45:53 <dolio> Crazy.
22:45:54 <TSC> How will it know which one to use if there are two?
22:47:09 <Saizan> well, it'd try to use both, if the same package appears in both it'll probably try to download it from the first, but i don't know the details
22:47:35 <TSC> It looks like "cabal update" just fails because the first one (hackage) times out
22:47:56 <Saizan> makes sense
22:48:01 <Saizan> comment it out for now then
22:48:14 <lispy> :t maybe
22:48:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:48:18 <TSC> Yeah, I've done that and it's getting the package list from sparky, hopefully
22:48:34 <dolio> \m f -> case m of { Nothing -> Nothing ; Just x -> case f e of { Nothing -> case m of { Nothing -> Nothing ; Just _ -> Nothing } ; Just y -> Just y }
22:48:39 <dolio> That's what it did.
22:48:54 <Saizan> cabal update should probably handle timeouts more gracefully
22:50:07 <Saizan> ?type \m f -> case m of { Nothing -> Nothing ; Just x -> case f e of { Nothing -> case m of { Nothing -> Nothing ; Just _ -> Nothing } ; Just y -> Just y }
22:50:08 <lambdabot> parse error (possibly incorrect indentation)
22:50:23 <dolio> My bad.
22:50:32 <TSC> Saizan: anyway, it's working via sparky; thanks!
22:50:39 <dolio> Anyhow, it's not wrong, just wasteful.
22:50:40 <Saizan> np
22:53:30 <lispy> Hmm...This is going to require a pretty big refactor :)
23:09:46 <lispy> I still don't see how I can write something of  SM r a -> String -> Maybe (a, String) unless r = Maybe (a, String).  But that's causing problems with a type class I'm trying to use that defines parse :: m a -> String -> Maybe (a, String)
23:10:31 <lispy> oh
23:10:40 <lispy> parse :: m r -> ?
23:11:14 <dolio> If you're trying to implement 'String -> Maybe (a, String)', you wouldn't normally make r a parameter.
23:11:41 <dolio> It'd be 'SM a = SM (forall r. String -> r -> (a -> String -> r) -> r)'.
23:11:58 <lispy> ah
23:12:03 <lispy> I'll try that :)
23:12:22 <dolio> Then at the end you instantiate r to being Maybe (a, String).
23:15:25 * lispy really doubts this will be faster
23:16:32 <lispy> My existing implementation was taking a lot of time in (>>=), and I wondered if that was because it kept cehcking Nothing/Just
23:17:09 <dolio> Well, this keeps checking, too, but in a different way.
23:18:56 <lispy> yeah, criterion already estimates it as slower
23:19:15 <lispy> used to estimate that 1 iteration of 100 samples would take 312 seconds
23:19:17 <dolio> It might be faster for fmap.
23:19:22 <lispy> now it estimates 340 :)
23:20:23 <lispy> dolio: I implemented the Wadler paper on "composable continuations" last night.
23:20:38 <lispy> dolio: In that paper, they index the monads over the subcontinuation type
23:21:00 <lispy> They have two variants.  One that works like Cont meaning it's based on (a -> r) -> r
23:21:08 <lispy> and another one that is based on (a -> p) -> r
23:21:11 <dolio> Right.
23:21:21 <lispy> the latter is more general, but you can't made a monad instance because the type is wrong for bind
23:21:31 <lispy> Do you know which variant your delcont library matches?
23:21:37 <dolio> Neither.
23:22:02 <lispy> Well, what I wanted to know is if one of their versions is more general than your library
23:22:10 <lispy> I realize you based your implementation on a different paper
23:22:39 <lispy> I haven't found an example of something you can do with one that you can't do with the other (in their paper) but I haven't looked too hard.
23:22:58 <dolio> Well, it depends what you mean by that.
23:23:28 <dolio> Off the top of my head, it's probably closer to the (a -> p) -> r version, but there's existential quantification going on.
23:23:48 <dolio> Because it doesn't have any 'result type' thing in the type at all.
23:24:03 <lispy> Yeah.  I noticed that.
23:24:40 <lispy> Is there anyway to simplify the types in that library?  Understanding how Prompts and frames fit together is quite difficult :(
23:24:49 <dolio> But it's not just (a -> p) -> r, either. It keeps a stack of things around, which is how you directly implement some of the other control operators.
23:24:55 <dolio> That is, not shift/reset.
23:25:11 <Saizan> Codensity (\a -> String -> Maybe (a,String)) might be faster than both of those, and using a strict version of Maybe/(,) could also help
23:25:34 <lispy> Saizan: Strict Maybe/(,) requires the 'a' to be strict too?
23:25:44 <lispy> I haven't seen Codensity before
23:25:56 <dolio> However, I think there's a paper by Ken Shan (and possibly Oleg), maybe Shift to Control, which shows that you can implement all the other operators with shift/reset.
23:26:18 <lispy> Saizan: oh, I'm thinking of unboxed tuples not strict tuples
23:26:19 <Saizan> newtype Codensity f a = Codensity (forall r. (a -> f r) -> f r)
23:26:22 <dolio> Which you might not expect, but it can be done, I guess.
23:26:46 <lispy> dolio: Oh.  I thought your lib was based on that paper
23:26:54 <dolio> So on that level, there's nothing you can do with the fancy stack stuff that you can't do with (a -> p) -> r.
23:27:23 <dolio> However, the stuff in CC-delcont implements multiple prompts, which the plain indexed monad cannot do, as far as I know.
23:27:32 <dolio> At least, not just (a -> p) -> r.
23:28:32 <dolio> And not just multiple prompts, but the number of prompts isn't statically limited.
23:29:38 <dolio> Which is how Oleg implements his dynamic references (which are also included in the library).
23:30:17 <lispy> yeah, the dynamic prompts are amazingly useful
23:31:05 <dolio> The paper CC-delcont is based on is A Monadic Framework for Delimited Continuations.
23:31:16 <dolio> By Dybvig, Petyon Jones and Sabry.
23:31:51 <lispy> dolio: but doesn't that one explain how all 4 sets of primitives can be based on the same thing?  So that's why I thought you would know they are equivalent
23:32:23 <dolio> It explains how all single-prompt control operators are inter-implementable.
23:33:01 <lispy> hmm
23:33:46 <dolio> I suspect implementing the other operators using shift/reset isn't nice, either.
23:34:04 <dolio> It probably involves all the extra bookkeeping that goes on for those other operators.
23:34:27 <lispy> How can this be.  My timings and proflings are essentially identical before and after this transformation
23:36:38 <Saizan> i've found similar things in a very badly conducted benchmark on Either sometimes ago on amd64, it seems there was more of a difference on 32bit
23:36:47 <catenate> I installed QuickCheck 2.1.0.3.  When I try to set up the property runner like in RWH, I get "Could not find module `Test.QuickCheck.Batch':  It is a member of the hidden package `QuickCheck-1.2.0.0'."
23:37:11 <lispy> Saizan: are you calling my benchmark bad??!?!?  (okay, maybe it is, I don't really know)
23:37:35 <lispy> I am using criterion though, which should hopefully give me some statistical robustness
23:37:49 <catenate> How do I resolve this, or is there another example I should follow?
23:38:40 <jrockway> so, bytestring question
23:38:45 <Saizan> lispy: i'm calling mine :)
23:38:47 <dolio> You could hide 2.1.0.3
23:38:54 <jrockway> my app mostly reads char *s from a c library, and then eventually concatenates the results CSV-style
23:39:04 <dolio> Or figure out what replaced the Batch module in quick check 2.
23:39:06 <jrockway> should i use lazy bytestrings, since the complexity is better for the concat?
23:39:12 <lispy> Saizan: yeah, just teasting
23:39:30 <lispy> Saizan: I'm just mystified that I can't seem to make a dent in this problem performance wise
23:39:38 <catenate> I'd like the idea of using the newer technique, if there is one
23:39:41 <jrockway> (or should i pick a better representation for the output data, so that the print does the equivalent of the concat operation, but over strict bytestrings)
23:39:43 <lispy> I've tried things that seem obvious, and things that seem less obvious.
23:40:45 <catenate> Of course, if I hide QC2, then I get verboseCheck back
23:40:57 <Saizan> lispy: tried attoparsec? bos spent quite some time optimizing it, even if there are use cases where it'll be slow
23:41:46 <Saizan> jrockway: i'd use Data.Binary.Builder
23:42:38 <catenate> Hm, that's two wins right away.  Ok, how do I hide packages? cabal doesn't seem to have a hide subcommand
23:42:56 <jrockway> Saizan: interesting idea
23:43:28 <lispy> Saizan: I haven't tried it since I started using criterion, but when I benchmarked it before it didn't have any obvious performance improvements and some slow dows
23:43:51 <catenate> The compiler should supportÂ -packageÂ andÂ -hide-packageÂ flags for finer-grain control of package visibility. http://www.haskell.org/cabal/proposal/x138.html
23:44:07 <lispy> Saizan: I should try it again now that I have a pure stress test for the parser
23:44:09 <Saizan> catenate: if you're building with cabal just put QuickCheck < 2 in build-depends, in ghci/ghc directly you can use -hide-package for that run, or ghc-pkg hide for a more persistent hiding
23:44:53 <Saizan> catenate: yeah, it does :)
23:45:22 <catenate> I could put it in OPTIONS_GHC so the file tells the compiler what it expects
23:45:37 <jrockway> builder looks like exactly what i want, since i can make my ffi return strict bytestrings
23:45:48 <jrockway> then when i process, i can convert those to builders, in constant time
23:46:06 <jrockway> providing simplicity in the general case and efficiency for this specific case
23:46:14 <jrockway> @karma+ Saizan
23:46:15 <lambdabot> Saizan's karma raised to 14.
23:49:23 <lispy> This is TOO bizarre.  It's within milliseconds of the same performance.
23:49:32 <lispy> I just did a major refactoring.  How can that be?
23:51:51 <c_wraith> why would refactoring change performance?
23:51:58 <catenate> OPTIONS_GHC doesn't like that the -hide-package option is two words, and quotes doesn't work to make them be taken together
23:52:53 <c_wraith> I thought hide-package wasn't a dynamic option anyway.
23:53:16 <catenate> oh.  ok
23:53:31 <lispy> c_wraith: well, I changed from using Maybe to using church encoding inside the most critical function in my profiles.
23:53:45 <catenate> into the mkfile it goes
23:53:52 <lispy> Give that it gets called a lot I figured there would be some difference
23:53:56 <c_wraith> catenate, why aren't you using cabal?
23:54:32 <catenate> to do what (breathe deep, expose your ignorance)?
23:54:53 <c_wraith> cabal (well, cabal-install, which has a binary named cabal) is a build tool for haskell programs.
23:54:56 <lispy> catenate: cabal is your build tool of choice. It makes great things like hackage possible.
23:55:35 <catenate> I see.  I'll have to look at that.
23:56:01 <lispy> maybe I have to do a clean between builds
23:56:09 <lispy> Maybe that's why my profiles are coming out so consistent
23:56:27 <lispy> I thought configure forced a clean on the next build
