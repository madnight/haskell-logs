00:00:04 <co_dh> enn, I think Guido Van is a brightest bulb. 
00:00:15 <co_dh> s/enn/em
00:00:21 <ivanm> co_dh: won't happen
00:00:28 <JoeyA> which ones?  Oracle's?
00:00:34 <ivanm> they're more likely to use Python than Haskell
00:00:40 <dobblego> if Guido is their brightest bulb, then kiss Haskell goodbye
00:00:45 <ivanm> since they want to use a "popular" language
00:00:47 <co_dh> Python is also cool. 
00:00:54 <dobblego> I'd rather use Java
00:00:59 <JoeyA> Or maybe Go
00:01:03 <ivanm> dobblego: have you looked at Go? they have some really weird things in there...
00:01:08 <JoeyA> Perhaps they'll dump a bunch of resources into it.
00:01:12 <ivanm> JoeyA: Go isn't mature enough for Android
00:01:13 <dobblego> ivanm, yes, exactly my point in fact
00:01:22 <co_dh> I'm not a fan of Rob Pike
00:01:23 <JoeyA> After all, strongly typed efficient languages are hard to come by.
00:01:51 <ivanm> Go is trying to be a statically-checked dynamic language
00:01:55 <ivanm> with currently no optimisations
00:02:18 <ivanm> and their goroutines seem to be a cross between STM and using MVars
00:05:33 <JoeyA> Hmm, I wonder why Data.ByteString.Lazy.putStr $ Data.Binary.encode ([1..] :: [Int]) isn't being lazy.
00:05:55 <c_wraith> putStr can't be lazy, can it?
00:06:12 <c_wraith> Oh, I see what you mean.
00:06:25 <JoeyA> If I'm not mistaken, Data.Binary encodes [Int] as just a series of Ints
00:06:29 <JoeyA> No count variable
00:06:30 <c_wraith> what version of Binary are you using?
00:06:35 <JoeyA> err wait
00:06:38 <JoeyA> there is a count
00:06:41 <JoeyA> Data.Binary
00:06:44 <c_wraith> Binary got strictified at some point.
00:06:54 <c_wraith> like < 0.5 was lazy, then >= 0.5 is strict
00:07:15 <JoeyA> cereal uses strict bytestrings
00:07:44 <JoeyA> And Data.Binary is capable of lazy output for other types (like trees), I've tried it out.
00:08:48 <JoeyA> I'm on 0.5.0.2
00:10:02 <JoeyA> putter used in 0.5.0.2:  put s = put (Seq.length s) >> Fold.mapM_ put s
00:10:40 <JoeyA> putter used in 0.4.4:  put = put . Fold.toList
00:11:59 <JoeyA> but for lists specifically:  put l  = put (length l) >> mapM_ put l
00:12:14 <JoeyA> So 0.4.4 is still strict
00:13:05 <JoeyA> 0.4.1 is also strict on lists.
00:13:10 <c_wraith> ah.
00:13:11 <c_wraith> ok.
00:20:32 <JoeyA> Hmm, it seems Data.Binary 0.5.0.2 can't lazily extract Trees.
00:20:51 <JoeyA> Even though the first thing it's getting, in my case, is a small String
00:21:20 <JoeyA> I conclude that Data.Binary doesn't fully support lazy operations.
00:21:51 <JoeyA> (from the binary package)
00:30:49 <co_dh> @pl \xs ys -> return ( zipWith (&&) xs ys )
00:30:50 <lambdabot> (return .) . zipWith (&&)
00:31:16 <co_dh> :t (return . )
00:31:16 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
00:32:14 <co_dh> :t return (zipWith (&&) [Bool] [Bool])
00:32:14 <lambdabot> Not in scope: data constructor `Bool'
00:32:15 <lambdabot> Not in scope: data constructor `Bool'
00:32:58 <co_dh> :t \xs ys -> return ( zipWith (&&) xs ys)
00:32:59 <lambdabot> forall (m :: * -> *). (Monad m) => [Bool] -> [Bool] -> m [Bool]
00:33:17 <co_dh> :t \xs ys -> return . zipWith (&&)
00:33:17 <lambdabot> forall t t1 (m :: * -> *). (Monad m) => t -> t1 -> [Bool] -> m ([Bool] -> [Bool])
00:33:53 <c_wraith> JoeyA, I think they changed the Get monad to be strict in binary 0.5.  Which is consistent with what you're seeing.
00:34:15 <co_dh> :t \xs ys -> return . ( zipWith (&&))
00:34:15 <lambdabot> forall t t1 (m :: * -> *). (Monad m) => t -> t1 -> [Bool] -> m ([Bool] -> [Bool])
00:34:26 <JoeyA> I have a really cool idea, and I sure hope it's possible: an automatically deduplicating key/value store and good lazy support.  As in, serialization on steroids.
00:34:51 <co_dh> :t return
00:34:52 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
00:34:57 <greap> I'm trying to make some typeclass restricted data definitions, and after looking aruond the consensis seems to be to put the class restrictions to the right if '=', however this seems to prevent deriving as usual. Am I doing something odd here? http://codepad.org/Ixx74p27
00:34:59 <JoeyA> (but not serialization to a stream, serialization to a block file)
00:35:00 <co_dh> :t return .
00:35:01 <lambdabot> parse error (possibly incorrect indentation)
00:35:07 <co_dh> :t (return .)
00:35:08 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
00:35:23 <c_wraith> :t (return (Prelude..))
00:35:24 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m ((b -> c) -> (a -> b) -> a -> c)
00:35:49 <co_dh> :t return $ zipWith (&&)
00:35:49 <lambdabot> forall (m :: * -> *). (Monad m) => m ([Bool] -> [Bool] -> [Bool])
00:37:12 <co_dh> is there a better way to write  :   return (zipWith (&&) xs ys) then the (return . ) .  zipWith (&&)
00:37:31 <co_dh> :t return
00:37:31 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
00:37:48 <co_dh> :t (return . )
00:37:49 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
00:38:12 <c_wraith> Not without some better combinators
00:38:26 <JoeyA> I suppose http://hackage.haskell.org/package/berkeleydb is the closest thing to what I'm talking about.
00:38:31 <ezyang> you could use some curry :-) 
00:38:46 <ezyang> the signature would be different tho 
00:38:55 <dobblego> @djinn ((a -> a) -> b -> b) -> (a -> a -> a) -> b -> b -> b
00:38:56 <lambdabot> f a b _ c = a (\ d -> b d d) c
00:39:08 <c_wraith> :t let f ... g = \x y -> f (g x y) in (...)
00:39:09 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t2 -> t3 -> t) -> t2 -> t3 -> t1
00:39:36 <c_wraith> A combinator like that would significantly shorten a lot of point-free code
00:39:56 <c_wraith> Well.  a lot of code which is generally not written point-free because it's too ugly to do so :)
00:40:08 <c_wraith> I often compromise, and would write something like:
00:40:23 <c_wraith> :t \xs -> return . zipWith (&&) xs
00:40:24 <lambdabot> forall (m :: * -> *). (Monad m) => [Bool] -> [Bool] -> m [Bool]
00:40:36 <ezyang> :t curry (return . uncurry (zipWith (&&)) 
00:40:37 <lambdabot> parse error (possibly incorrect indentation)
00:40:50 <ezyang> :t curry (return . uncurry (zipWith (&&))) 
00:40:51 <lambdabot> forall (m :: * -> *). (Monad m) => [Bool] -> [Bool] -> m [Bool]
00:41:11 <ezyang> :^) 
00:41:41 <co_dh> ezyang: nice
00:42:17 <co_dh> > curry (return . uncurry (zipWith (&&))) [True, False] [True, True]
00:42:18 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Bool.Bool]))
00:42:18 <lambdabot>    arising from a use o...
00:42:39 <co_dh> >(  curry (return . uncurry (zipWith (&&))) )  [True, False] [True, True]
00:42:57 <co_dh> > (  curry (return . uncurry (zipWith (&&))) )  [True, False] [True, True]
00:42:58 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Bool.Bool]))
00:42:58 <lambdabot>    arising from a use o...
00:43:26 <co_dh> >(  curry (return . uncurry (zipWith (&&))) )   [True, False] [True, True]
00:43:35 <co_dh> ezyang: are you sure it works?
00:44:54 <ezyang> Yes, but you haven't specified what monad you're in. 
00:45:20 <co_dh> try Maybe Monad
00:45:30 <ezyang> > (curry ((return :: a -> [a]) . uncurry (zipWith (&&)))) [True, False] [True, True] 
00:45:31 <lambdabot>   [[True,False]]
00:46:52 <JoeyA> Isn't there a typeOf function in Haskell, something to do with FFI?
00:47:18 <Heffalump> it's from the Typeable class. Nothing to do with FFI that I can think of.
00:47:47 <co_dh> @pl \xs -> return (map not xs)
00:47:47 <lambdabot> return . map not
00:48:20 <FunctorSalad> iirc there's also a typeOf in hint (essentially like :type in ghci)
00:48:27 <ezyang> JoeyA: Perhaps you're thinking of sizeOf? 
00:48:46 <JoeyA> no, I was thinking of typeOf, thanks
00:49:15 <ljungk> I'm trying to pattern match a Maybe value inside a IO do block. It doesn't really work.
00:49:56 <ljungk> like this: main = do args <- getArgs \n Just filename = listToMaybe args \n ...
00:50:16 <ezyang> ljunk: You need a let. 
00:50:49 <ljungk> ezyang: let Just filename ... ?
00:50:59 <JoeyA> Good, show $ typeOf is what I'm interested in (or similar)
00:51:20 <ljungk> oh, I meant : main = do args <- getArgs \n Just filename <- listToMaybe args \n ...
00:51:47 <JoeyA> The idea being that the show . typeOf of a variable could be written to a serialized representation to guard against type mismatches.
00:51:57 <co_dh> @pl \xs ys -> (&&) <$> xs <*> ys
00:51:57 <lambdabot> (((&&) <$>) .) . (<*>)
00:51:58 <ezyang> let (Just filename) = ... 
00:52:06 <c_wraith> JoeyA, Typeable can lie.
00:52:16 <c_wraith> You can't trust it with arbitrary types.
00:52:28 <JoeyA> Because someone might name their own type Int or whatever?
00:52:49 <JoeyA> or because it won't distinguish between ByteString and Lazy.ByteString?
00:52:52 <JoeyA> etc.
00:53:00 <ljungk> ezyang: ah, thanks!
00:53:03 <co_dh> :t (&&) <$>
00:53:04 <lambdabot> parse error (possibly incorrect indentation)
00:53:07 <JoeyA> It's not a strong guard, but it can guard against obvious mistakes.
00:53:10 <c_wraith> yeah.  The implementation does some unsafe stuff to prevent two different types from getting the same Typeable object
00:53:11 <co_dh> :t ((&&) <$> )
00:53:12 <lambdabot> forall (f :: * -> *). (Functor f) => f Bool -> f (Bool -> Bool)
00:53:22 <JoeyA> (e.g. storing a FileTree and fetching a File)
00:53:26 <c_wraith> But it doesn't defend its show instance the same way
00:53:48 <Heffalump> why would you use show . typeOf instead of just comparing the typeOf representations directly?
00:54:02 <ljungk> ezyang: but I still don't see how that could work. We're mixing two monads right?
00:54:03 <Heffalump> oh, I see.
00:54:05 <c_wraith> Heffalump, because he's talking about a case involving serialization
00:54:11 <Heffalump> yeah
00:54:28 <Heffalump> and serializing the internal counters wouldn't be good either
01:02:32 <ezyang> ljungk: Just because something is an instance of monad, doesn't mean I have to use it as a monad. 
01:09:41 <ljungk> you're just pattern matching against the type constructor, right?
01:11:23 <JoeyA> Right
01:20:09 <greap> What's with the (Prelude is depricated) warning I'm getting? http://codepad.org/wpz2n0Yz
01:22:29 <dolio> Base 3 is deprecated, including the prelude from that package.
01:22:42 <JoeyA> +1 I get that message when I install packages too.
01:23:22 <greap> dolio: So I should change the cabal dependency to >= 4.0
01:23:23 <greap> ?
01:23:33 <dolio> If you're able to.
01:23:43 <greap> It's my package :)
01:23:47 <dolio> Then yes.
01:24:12 <dolio> Unless you're depending on some other base-3 restricted packages.
01:27:12 <greap> dolio: Why does depending on base use base-3 by default?
01:27:35 <dolio> Not sure.
01:27:50 <dolio> You should be specifying version bounds anyway.
01:29:22 <dolio> And I think saying "base >= 3 && < 5", or something similar, will get it to choose 4.
01:29:59 <dolio> base defaulting to <4 is probably for really old packages, before specifying version bounds was standard practice, I guess.
01:30:07 <dolio> Same with parsec defaulting to <3.
01:30:14 <greap> I usually go with very liberal bounds and then narrow them as I find issues.
01:37:53 * hackagebot NonEmptyList 0.0.9 - A list with a length of at least one.  http://hackage.haskell.org/package/NonEmptyList-0.0.9 (TonyMorris)
01:40:06 <FunctorSalad> hmm getFileStatus autoderefs?
01:40:28 <nont> Hello Haskellers. has any one used the Data.Geo module? I'm at a loss trying to call the (to me) strangely named function "(!.!)"
01:40:35 <FunctorSalad> but why is there 'isSymbolicLink' then ;)
01:41:43 <luite> nont: it's an operator, you can use it like: myCoord = 1.0 !.! 2.0
01:42:05 <dobblego> nont, yes I've used it a lot
01:42:37 <FunctorSalad> ah... getSymbolicLinkStatus
01:42:40 <nont> thank you luite. I saw "ifixl" and so I was thinking it would be "c = (! 1.0000 2.0000 !)
01:42:57 <dobblego> nont, actually, I wrote it
01:43:41 <luite> nont: the infixl and infixl are used to specify the precedence and associativity of the operator, you only need to care about it if you use more than one or mix it with other operators
01:44:03 <nont> thank you dobblego! 
01:44:21 <dobblego> nont, no worries, I do a lot of work with OpenStreetMap
01:45:30 <nont> I'm going to use it to help my fiance schedule her dog walking business by time and total round trip distance
01:45:48 <dobblego> I wrote a GPX file parser too if that helps
01:46:17 <dobblego> i.e. a common format for GPS device track logging
01:46:22 <luite> note that the travelling dog walker problem is NP-hard ;)
01:46:32 <nont> I've heard that!
01:46:52 <FunctorSalad> hmm I suppose it isn't quite the tsp
01:47:17 <FunctorSalad> since you can walk the dog where you want as long as its long enough, no?
01:47:18 <luite> you need some bin packing too if you need to pick up the dogs by car
01:47:41 <FunctorSalad> *laughs at the thought of repeating an arbitrarily small cycle*
01:47:41 <nont> well, its for a very small number of stops, but you do need to pick the dogs up and drop them off at their respective houses
01:48:01 <FunctorSalad> luite: lol
01:48:34 <luite> you may assume that all dogs are spherical for that
01:48:48 <FunctorSalad> (I guess the dogs wouldn't like the optimal packing solution)
01:48:54 <nont> yes, and radiating fleas uniformly
01:49:58 <FunctorSalad> if length you have to walk them >> distances between the clients's houses, the problem isn't hard at all, is it?
01:50:46 <FunctorSalad> (you wouldn't need the TSP solution for the houses because you need to walk around some more, anyway)
01:51:38 <nont> I think you do need a TSP solution because you have to drop each dog off back at their houses. you're not allowed to walk more than one dog at a time
02:16:36 <greap> @src (^)
02:16:36 <lambdabot> x ^ 0            =  1
02:16:36 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
02:16:36 <lambdabot>   where f _ 0 y = y
02:16:36 <lambdabot>         f x n y = g x n
02:16:36 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
02:16:38 <lambdabot>                       | otherwise = f x (n-1) (x*y)
02:16:40 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
02:53:21 <buffalo66> Hi! I'm looking for an introductionary haskell tutorial. any suggestions?
02:53:52 <c_wraith> @where lyah
02:53:52 <lambdabot> http://www.learnyouahaskell.com/
02:53:59 <c_wraith> That's my favorite intro sequence
02:54:21 <aruns> have you checked the haskell wiki - http://www.haskell.org/haskellwiki/Haskell it has a lot of links to tutorials on the main page
02:55:30 <buffalo66> c_wraith, aruns: thanks! will check those out
02:55:56 <aruns> http://www.haskell.org/haskellwiki/Tutorials is the direct link to the online tutorials
02:56:10 <chrisdone> @google Real World Haskell
02:56:12 <lambdabot> http://www.realworldhaskell.org/
02:56:12 <lambdabot> Title: Real World Haskell
02:56:33 <chrisdone> http://tryhaskell.org/
02:57:18 * hackagebot test-framework-th 0.1.3 - Automagically generate the HUnit- and Quickcheck-bulk-code using Template Haskell.  http://hackage.haskell.org/package/test-framework-th-0.1.3 (OscarFinnsson)
02:57:48 <greap> I'm getting a confusing error from ghc for this code segment http://codepad.org/1EugBEe8.
02:58:18 <aruns> can i create a self referencing type with - data SomeThing = SomeThing { a :: Int, b :: Something } deriving (Show) ?
02:58:30 <Saizan> aruns: yes
02:58:42 <greap> I can't see how (*something) would be value rather than (value -> value)
02:59:00 <aruns> hmm for some reason i'm getting an error
02:59:10 <danharaj> I just vomited up last night's dinner. I think this is how compilers feel when they get a parse error?
03:00:52 <Saizan> greap: the error is a bit puzzling, but i think the problem is that the first argument to foldl' is supposed to take 2 arguments while (*mbase) only takes one
03:02:15 <greap> Saizan: Oh yeah, oops...
03:03:03 <greap> Saizan: Probably currys the functions.
03:05:22 <aruns> how do i make a field in a type optional? Maybe doesnt seem to work. data T1 = T1 { a :: Int, Maybe b :: T1} deriving (Show) ?
03:06:48 <aruns> or the |
03:07:04 <greap> aruns: Shouldn't (Maybe b) be a variable?
03:07:31 <Saizan> aruns: data T1 = T1 { a :: Int, b :: Maybe T1}
03:07:39 <Saizan> aruns: Maybe is part of the type.
03:07:47 <aruns> ahhh right, thanks
03:08:55 <aruns> so when i use Maybe, while assigning a value i must use Just right ?
03:09:15 <Saizan> yep
03:10:54 <aruns> brilliant, thanks Saizan 
03:38:08 <ivanm> so, with the restricted type classes I'm writing, I'm thinking of "fixing" the whole Functor/APplicative/Monad/etc. hierarchy
03:38:26 <ivanm> should I just go with what's in the typeclassopedia, or is there a better layout?
03:39:55 <Zol>  Not entirely related: Anyone here have experience with macbooks as development machines?
03:40:22 <ivanm> Zol: Axman6 uses one IIRC (in the sense that he writes code on one I think)
03:40:43 <Zol> ivanm: Ah, thanks!
03:41:34 <Jonno_FTW> heheh
03:41:59 <luite> in my opinion a proper development machine is be black and boxy, and has a trackpoint ;)
03:43:01 <ivanm> luite: are you referring to a really big, massive thinkpad?
03:43:24 <luite> the smaller ones are also boxy looking, at least compared to other brands
03:45:00 <juhp_> Zol: hamishmack too
03:45:09 * juhp_ hugs his T500 :)
03:46:23 <philed> My god, what is wrong with mirc?
03:46:27 <aruns> could someone help me understand whats going on here. i have-   palindrome xs = xs : reverse xs. and i'm getting an error about 'cannot construct infinite type a = [a]'
03:46:52 <ivanm> aruns: because of:
03:46:54 <ivanm> @type (:)
03:46:55 <lambdabot> forall a. a -> [a] -> [a]
03:46:59 <ivanm> @type reverse
03:47:00 <lambdabot> forall a. [a] -> [a]
03:47:08 <philed> aruns: You're trying to cons the whole list onto its reverse.
03:47:10 <ivanm> aruns: you're stating that you want to make [a] the first element of a list of type a
03:47:15 <ivanm> you want ++, not :
03:47:34 <aruns> ahh right
03:48:00 <aruns> so i would do 1 : [1,2] but [1,2] : [2,1] is not possible ?
03:48:10 <ivanm> right
03:49:28 <aruns> thanks :) as you can tell i've just finished chap 3 of 'Real world haskell'
03:49:51 <ivanm> no, I couldn't tell actually
03:50:42 <luite> me neither :)
03:50:48 <aruns> well its really been years since i've written a palindrome function, makes me feel like i'm back in school again lol
03:51:18 <aruns> its one of those things that you never have to do in the 'real world' but a nice simple function for learning a language
03:54:33 <chrisdone> ugh, how do you type annotate Takusen functions?
03:54:49 <chrisdone> how do I convert
03:54:49 <chrisdone> forall q b mark sess.
03:54:50 <chrisdone>                                          (IQuery q sess b,
03:54:50 <chrisdone>                                           DBType [Char] q b,
03:54:52 <chrisdone>                                           Statement
03:54:55 <chrisdone>                                             Database.PostgreSQL.Enumerator.QueryString sess q) =>
03:54:59 <chrisdone>                                          Integer
03:55:02 <chrisdone>                                          -> [(Integer, String, String)]
03:55:05 <chrisdone>                                          -> DBM mark sess [(Integer, String, String)]
03:55:08 <chrisdone> to something less horrific?
03:55:28 <chrisdone> I'm thinking a type class alias
03:55:56 <ivanm> chrisdone: well, a pastebin would help... :p
03:56:10 <chrisdone> why?
03:56:38 <ivanm> because your type sig you pasted above is hard to read due to all the newlines everywhere ;-)
03:56:51 <chrisdone> being on one line doesn't help, trust me
03:56:57 <Saizan> q and b are determined by sess?
03:57:31 <chrisdone> class (ISession sess) => IQuery q sess b | q -> sess, q -> b where
03:57:37 <chrisdone> yeah
03:57:57 <Saizan> that seems like q determines sess
03:58:09 <Saizan> but i guess Statement has the other fundep
03:58:10 <chrisdone> so q determines sess and b
03:58:27 <chrisdone> class (ISession sess) => Statement stmt sess q | stmt sess -> q where
03:58:28 <chrisdone>  
03:58:45 <Saizan> 'k, otherwise the type didn't make sense :)
03:59:20 <Saizan> anyhow, it doesn't seem it'd be too bad if you import Database.PostgreSQL.Enumerator
04:00:15 <chrisdone> :/
04:00:49 <chrisdone> I can barely understand all the dependencies
04:01:31 <chrisdone> Database.PostgreSQL.Enumerator doesn't export QueryString ~_~
04:01:35 <chilili> Any new paste url ? hpaste is down. :)
04:02:09 <aRcatan> for example http://codepad.org and http://gist.github.com/ are popular choices
04:02:22 <chilili> Thanks!
04:05:36 <chrisdone> The class IQuery describes the class of query objects. Each database (that is, each Session object) has its own Query object. We may assume that a Query object includes (at least, conceptually) a (pointer to) a Session object, so a Query object determines the Session object. A back-end provides an instance (or instances) of IQuery. The end user never seens the IQuery class (let alone its methods). 
04:05:42 <chrisdone> well I'm seeing it right now and I'm not enjoying it
04:09:24 <Saizan> that might be because ghc's reduced a context that implies all of those?
04:10:04 <culprit> Hello. I am an experienced C and C++ programmer desiring to gain knowledge of functional programming. I have decided to try to attain this knowledge through Haskell, however, I am finding it difficult to select a book (some books) on this subject. I do not necesserarly desire to learn Haskell in order to use it for "real world" projects.
04:10:47 <chrisdone> Saizan: at least I can reduce half of it because I know what sess is
04:11:52 <culprit> Various sources recommend "Real World Haskell", however, chapter 5 seems to introduce "JSON" which looks vastly not interesting and diverging from my goals. Others yet recommend "Programming in Haskell" and "Learn you a Haskell", however, both look "tutorial-like".
04:11:59 <ivanm> culprit: RWH
04:12:12 <ivanm> the whole point of Real World Haskell is to "teach whilst doing"
04:12:29 <ivanm> as such, the JSON chapter just uses JSON to teach pretty-printing (if memory serves) rather than JSON per-se
04:12:30 <luite> culprit: real world haskell might still be a good choice... like with other programming language, you do have to use the language to actually learn it
04:12:52 <ivanm> all the way through, you write mini cut-down libraries and programs whilst being taught how to parse, pretty-print, test, profile, etc.
04:12:58 <culprit> JavaScript (and web "programming" in general) is something which I am extraordinarily not interested in, so the idea of JSON is very much a turn off as far as RWH is concerned.
04:13:11 <luite> you could skip that chapter
04:13:21 <ivanm> and skip learning about pretty-printing
04:13:28 <ivanm> and the JSON stuff is used for testing later IIRC
04:13:35 <luite> I don't think it's extremely important by itself, it demonstrates how to design a library
04:13:43 <ivanm> culprit: ignore what it's about and just go through it
04:13:47 <ivanm> luite: exactly
04:14:17 <ivanm> culprit: also, JSON is just a common way of storing data; the actual chapter isn't related to java script or web programming at all
04:14:32 <ivanm> IIRC, the closest thing in there to web programming is a cut-down version of hpodcatcher
04:15:04 <culprit> luite: Well, my goal isn't exactly to /learn haskell/, but to introduce my brain to functional programming (haskell is more of a means rather than an end)
04:15:17 <culprit> Ok, I'll give RWH a shot. Thank you.
04:15:27 <ivanm> well, you could give a more theory-oriented text a shot
04:15:41 <ivanm> but there aren't any that have been really updated lately (that are haskell-related)
04:15:47 <aRcatan> though are there any good free theory-oriented texts?
04:15:59 <luite> culprit: it's very difficult to really understand it without doing it... it's like reading grammar rules and word lists for a foreign language
04:16:01 <culprit> "Algorithms: A FP Approach" looks interesting but it's over 10 years old.
04:16:10 <ivanm> yeah, that and okasaki's book
04:16:32 <ivanm> there's computationally oriented matroids, but I think that just uses haskell rather than being about haskell
04:16:34 <ivanm> or FP
04:16:57 <ivanm> otherwise, there might be scala or erlang books that might be suitable
04:17:04 <ivanm> possibly even clojure
04:17:41 <aruns> sorry more noob questions- intersperse y [x:xs] = x : y : intersperse y xs . again i have cannot construct infinite type
04:17:51 <aruns> i have intersperse _ [] = [] before that
04:18:06 <chrisdone> that means you're putting a [y] where you should put a 'y'
04:18:07 <luite> aruns: intersperse y (x:xs)
04:18:21 <aruns> ahh right :P
04:18:32 <aruns> [x:xs] means create a list with those things right ?
04:18:36 <Zao> aruns: No.
04:18:44 <ivanm> that creates a list containing a list
04:18:44 <Zao> aruns: It's a list of a list of those stuff.
04:18:48 <luite> aruns: no, it matches a list with one element, that is a list itself
04:18:55 <ivanm> @type [1:2:[]]
04:18:56 <lambdabot> forall t. (Num t) => [[t]]
04:19:08 <aruns> ok thanks
04:19:14 <Zao> More clearly, it's [(x:xs)]
04:19:27 <ivanm> which is still [[a]]
04:19:28 <Zao> (or (x:xs):[]
04:19:41 <Zao> )
04:19:50 <ivanm> damn it, you beat me to a snarky comment!
04:19:58 <Zao> (can't have unbalanced parenthesis, the rest of the conversation might be tangential)
04:20:46 <aruns> hmm still getting infinite type even with intersperse y (x:xs) = x : y : intersperse y xs
04:21:06 <aruns> intersperse y (x:xs) = x : y : intersperse (y xs)
04:21:16 <aruns> how do you get lambdabot to compute stuff?
04:21:22 <aruns> @intersperse y (x:xs) = x : y : intersperse (y xs)
04:21:22 <lambdabot> Unknown command, try @list
04:21:29 <ivanm> > 1 + 1
04:21:30 <lambdabot>   2
04:21:46 <ivanm> @type let intersperse y (x:xs) = x : y : intersperse y xs
04:21:47 <lambdabot> <no location info>:
04:21:47 <lambdabot>     not an expression: `let intersperse y (x:xs) = x : y : intersperse y xs'
04:21:52 <ivanm> @type let intersperse y (x:xs) = x : y : intersperse y xs in intersperse
04:21:53 <lambdabot> forall t. t -> [t] -> [t]
04:22:10 <ivanm> aruns: you're missing the "intersperse y []" case though
04:22:15 <luite> > let intersperse _ [] = [] ; intersperse y (x:xs) = x : y : intersperse y xs in intersperse ',' "test"
04:22:16 <lambdabot>   "t,e,s,t,"
04:22:21 <ivanm> but the first line you have there looks right
04:22:39 <ivanm> luite: yeah, a singleton case is probably called for
04:22:44 <luite> not really correct since it needs an additinal [x] case
04:24:49 <JoeyA> Where can I find a somewhat exhaustive hierarchy of Haskell modules?
04:25:04 <JoeyA> I guess http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ is what I'm looking for
04:25:35 <ivanm> well, that's an exhaustive list of the ones that come with GHC 6.12.2
04:25:56 <ivanm> you can't get one that covers all of hackage AFAIK
04:26:37 <aRcatan> you could take a look at the Haskell 2010 report if you're only interested in the standard Haskell: http://www.haskell.org/onlinereport/haskell2010/haskellpa2.html#x20-192000II
04:27:04 <aRcatan> (standard library)
04:27:59 <ivanm> so array is part of the "standard library" but containers isn't?
04:28:18 <ivanm> wait, that's not exhaustive: it doesn't even mention the prelude!
04:28:46 <aRcatan> hmm, true. Prelude is earlier in the report.
04:33:19 <orbital_fox> hello
04:35:49 <aRcatan> hello
04:37:14 * ivanm waves idly in orbital_fox's general direction
04:37:32 * orbital_fox waves back at ivanm 
04:37:58 <orbital_fox> im interested in haskell, so i thought id join this channel for starters 
04:38:13 <Jonno_FTW> that's a good start
04:38:49 <orbital_fox> yeah
04:39:08 <Jonno_FTW> what do you need to know?
04:39:19 <orbital_fox> im just working on a project just now, but when i take a break ill look into installing haskell and trying out coding in it
04:39:22 <Jonno_FTW> or will you practice the 'learning from idling' technique?
04:39:44 <orbital_fox> no no Jonno_FTW im very active when it comes to learning
04:39:53 <orbital_fox> so long i find the time, cause there is so much to learn :P
04:40:18 <orbital_fox> im now learning my mac and how to build my make based project through Xcode :P
04:41:37 <orbital_fox> but i have some questions.. things which would be discussed over  a cup of coffee, such as.. isnt functional programming the old thing?
04:42:06 <Zao> orbital_fox: These aren't your grandfathers parenthesis.
04:42:27 <orbital_fox> does functional programming respect the fact processors these days, run in sequence?
04:42:40 <Jonno_FTW> yes
04:42:58 <Jonno_FTW> you might want to look at Control.Concurrent
04:42:58 <orbital_fox> Zao i am not following you
04:43:10 <Jonno_FTW> it makes multithreading VERY simple
04:43:22 <Zao> FP and FP implementations has evolved a fair bit since ancient LISP.
04:43:49 <Zao> Haskell is doing awesome things with type systems, for example.
04:43:56 <Zao> Scary things, I might add :D
04:43:58 <bastl> hey, how can I get a type witness (like here: http://www.haskell.org/haskellwiki/Type_witness )  from a value of that type ?
04:44:07 <orbital_fox> i hoped so Zao, does it challenge C++ implementations?
04:44:59 <Zao> orbital_fox: In what regard?
04:45:53 <luite> orbital_fox: carefully coded C++ is usually a bit faster than haskell, but the gap is not very wide for many types of programs
04:46:05 <orbital_fox> efficiency primarily
04:46:52 <Zao> orbital_fox: Haskell has some fun aspects that you need to take into concern, like how strict your code is, to avoid space leaks.
04:46:58 <Saizan> bastl: something like "a -> Witness a" ? you need a typeclass
04:47:13 <luite> orbital_fox: if you're experienced in optimizing haskell you could come very close to C performance (but this requires a whole new way of thinking about efficiency, C++ experience doesn't help much)
04:47:22 <Zao> Properly crafted Haskell tends to be quite efficient, in the right hands.
04:47:23 <orbital_fox> say my next project was to be a physics engine or a neural network.. which were aimed to be deployed in the market to compete with other product.. would i be making a wise decision choose Haskell?
04:47:51 <hpc> i think so
04:48:14 <bastl> Saizan: i'll try ..
04:48:16 <hpc> unless you want to do the computing on the GPU, then you're stuck with CUDA
04:48:21 <Zao> As you're doing middleware, it'd be a bit painful to provide a library suitable for static linking into VC++ code.
04:48:39 <ivanm> hpc: OpenCl?
04:48:42 <Zao> (as GHC currently uses gcc and crap)
04:48:43 <ivanm> (or whatever it's called)
04:49:03 <hpc> there's OpenCLRaw, but all it does is let you easily link to C code
04:49:16 <ivanm> orbital_fox: IIRC, we at least have a primitive physics engine in Haskell already
04:49:32 <orbital_fox> hehe
04:50:20 <orbital_fox> ow, something ill be reading about but ill ask anyway, does haskell provide ways to link to C++ or even wrap it?
04:50:20 <luite> orbital_fox: you can do it in haskell, but there may be some parts of your code that will require mutable arrays, destructive updates. those parts will look different from the rest of your program.
04:50:30 <luite> orbital_fox: yes, very easily for C code
04:50:45 <luite> orbital_fox: C++ is different, there are a few problems with it
04:50:52 <orbital_fox> like what?
04:50:54 <ivanm> luite: what kind of problems?
04:51:01 * ivanm was thinking of doing some C++ binding this summer
04:52:00 <luite> orbital_fox: one is that C++ objects don't really have an equivalent in haskell, so it's difficult to call methods on them. You can work around that with some wrapping (not sure whether it's possible to call a virtual method directly)
04:52:05 <robertmassaioli> Control.Monad.Logic says that it is not portable because of multi parameter type classes; is there something that I could read that would explain why that is the case?
04:52:27 <ivanm> robertmassaioli: it won't work on other compilers
04:52:42 <ivanm> since not all compilers have that extension
04:52:45 <luite> orbital_fox: another problem is that C++ code requires all kinds of "strange" sections in the object files, for global initializers and destructors for example. these don't work well with the dynamic linker used in ghci, at least on windows
04:52:45 <ivanm> *won't necessarily work
04:52:55 <ivanm> if you just care about ghc, then don't worry about it
04:53:21 <ivanm> luite: what happens if you don't care about windows (i.e. using gcc on *nix)?
04:53:39 <luite> orbital_fox: which means that you probably can't use code that calls C++ code in ghci on windows... but it will work fine if you compile it to an .exe
04:53:40 <robertmassaioli> ivanm: oh, okay then, I thought it meant not portable as in Windows or Linux kind of stuff. Thanks. :)
04:53:55 <ivanm> np
04:54:03 <orbital_fox> luite i dont care the slightest about windows :P
04:54:13 <luite> ivanm: hmm, I think it does work on unix, not 100% sure though
04:54:28 <ivanm> *nod*
04:54:39 <orbital_fox> i do like my code being cross-platform.... but... i wouldnt care if i couldnt get windows in there :P
04:55:02 <luite> orbital_fox: still, if you need to write some really high performance code, or want to link to an external library, it's easier to use C than C++
04:55:04 <orbital_fox> the only reason i was asking about C++ wrapping, it to get allow for some improvements were needed
04:56:19 <JHoglund> I'd like to define a function f(x), one that is valid when x is even and one that is valid when x is odd, how do I do that? I know how to define a function f(x) which is valid when x is 5, 3, or any given number.
04:56:54 <orbital_fox> but i must say at the end of the day.. there is something very unnatural about imperative code.. which day by day gets me more
04:57:02 <luite> JHoglund: you could call  error "not an even number" or something like that, but it's not really possible to enforce it in the type system
04:57:18 <orbital_fox> after i did some vhdl.. i realised there is something very primitive about sequencial processors
04:57:43 <ivanm> luite: he says it's even for both even and odd though... ;-)
04:57:52 <ivanm> and you might be able to use type-level church numerals to do so...
04:58:06 <ivanm> otherwise, use guards and a Maybe (or an error if you want to risk possible crashes)
04:58:16 <JHoglund> luite: Uhm, I'm not sure that you understood what I'm looking for, I'm searching for "if x is odd, do this, otherwise do that", and I figured that the function declaration could be a good place to utilize for that :)
04:58:23 <luite> JHoglund: ooh
04:58:32 <luite> f x | odd x = do this
04:58:38 <luite>      | otherwise = do that
04:58:53 <ivanm> JHoglund: guards
04:59:02 <JHoglund> Ahh :) THanks! I tried to google for "haskell function filter", what would have been a more appropriate search?
04:59:03 <ivanm> as luite said
04:59:08 <luite> bah I thought they lined up :)
04:59:16 <luite> JHoglund: guards :)
04:59:19 <ivanm> luite: proportional fonts
04:59:19 <JHoglund> Great
04:59:54 <bastl> Saizan: you mean just like this one: http://tinyurl.com/34wcqx9 ?
04:59:56 <mietek> Anyone tried out the ants simulation posted on fatvat?
04:59:58 <mietek> http://www.fatvat.co.uk/2010/08/ants-and-haskell.html
05:01:21 <ivanm> I haven't even looked at it
05:01:27 <ivanm> but I did an ant simulation years ago
05:02:07 <mietek> I'm wondering why it uses so much CPU (75%)
05:02:13 <ivanm> (with an attempt at pheremone trails, etc.; didn't work too well because a) I was trying to treat a square grid as a hexagonal one, b) I was limited in size of the grids due to using matlab for rendering of the animations the prof wanted)
05:02:21 <ivanm> mietek: profile it and find out!
05:03:18 <Saizan> bastl: that's something different, it gives you a withness of the equality of two types, and i'm not sure what's the role of phi there
05:04:29 <mietek> Is it possible to disable profiling for packages which do not have profiling information?
05:04:41 <ivanm> ummm..... huh?
05:04:44 <Saizan> bastl: i mean class ToWitness a where toWitness :: a -> Witness a; instance ToWitness Int where toWitness _ = IntWitness; instance ToWitness Char where toWitness _ = CharWitness etc..
05:05:01 <ivanm> mietek: do you mean foo depends on bar, you want to profile foo without enabling profiling on bar?
05:05:06 <ivanm> if so, then no, you can't
05:05:07 <mietek> Precisely.
05:05:10 <mietek> Ah.
05:05:30 <bastl> Saizan. yes. using El it gets table :: forall phi a . (El phi a) => a -> phi a
05:05:30 <bastl> and table _ = proof.
05:05:38 <bastl> (sorry for pasting stuff here)
05:06:06 <bastl> thanks, i think i got it.
05:06:09 <Saizan> bastl: ah, sorry, i was looking at EqS
05:07:25 <mietek> Is it normal not to have a ~/.cabal/config after cabal update?
05:07:49 <Saizan> no
05:08:26 <mietek> And yet, that's what happens here.
05:08:47 <mietek> This is with Haskell Platform 2010.2.0.0 on OS X
05:09:54 <Saizan> are you running cabal as some other user?
05:11:15 <ivanm> mietek: did you have one before?
05:11:39 <ivanm> mietek: try this: locate .cabal/config
05:12:44 <mietek> I'm running cabal as myself, and it created stuff in .cabal
05:12:56 <mietek> Just not the config
05:13:16 <mietek> I didn't have it previously; this is a fresh install
05:13:46 <ivanm> well, I would expect it to create a config file
05:13:53 <ivanm> but it's not that big of a problem I wouldn't think
05:13:56 <ivanm> preflex: seen dcoutts 
05:13:56 <preflex>  dcoutts was last seen on #ghc 2 days, 3 hours, 15 minutes and 26 seconds ago, saying: * dcoutts heads off to Utrecht for 8 days
05:14:14 <mietek> I'm not very concerned; I'd just like to set cabal to always generate profiling information for installed packages, and I don't remember how
05:14:30 <ivanm> mietek: get a config file, and enable it
05:14:46 <ivanm> but I would have thought that cabal update would have created it
05:14:51 <ivanm> what version of cabal-install?
05:15:11 <mietek> Looks like I don't have cabal-install, hm
05:15:37 <ivanm> well, if you could do "cabal install", then yes, you would have cabal-install ;-)
05:15:39 <mietek> N/m
05:15:39 <ivanm> cabal --version
05:15:40 <mietek> cabal-install version 0.8.2
05:15:40 <mietek> using version 1.8.0.6 of the Cabal library 
05:15:55 <ivanm> well, that's the latest
05:15:59 <ivanm> possibly a slight bug?
05:16:47 <ivanm> mietek: if I have no ~/.cabal/config and I do "cabal update", I get a bunch of messages saying it couldn't find a config so it's going to create one
05:16:54 <ivanm> and indeed it does
05:18:01 <Saizan> mietek: here's mine if you need to create it manually http://code.haskell.org/~Saizan/config
05:18:45 <ivanm> Saizan: did you take your hackage password out of there first? :p
05:19:07 <Saizan> ivanm: it wasn't there from the start
05:19:27 <mietek> ivanm: do you have the same version?
05:19:33 <mietek> Saizan: thanks
05:19:37 <ivanm> mietek: yes
05:20:06 <mietek> Well, this is odd
05:20:41 <mietek> (hpaste is broken?)
05:21:19 <mietek> http://paste.lisp.org/display/113983
05:22:36 <ivanm> huh
05:22:45 <ivanm> where is the cabal binary located?
05:23:03 <mietek> lrwxr-xr-x  1 root  staff    55B Aug  7 17:52 /usr/local/bin/cabal@ -> /Library/Frameworks/HaskellPlatform.framework/bin/cabal
05:23:23 <ivanm> I wonder if it's an OSX bug
05:33:06 <dobblego> @type zipWith id
05:33:06 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
05:36:30 <chilili> I try to deduce evalState while learning State Monad, and finally got a type error on runState,  here is my pase,   http://codepad.org/1hPD0Sut  Any help is appreciated. 
05:41:48 <chilili> Thaks, :)
05:45:44 <mietek> cabal: the 'upgrade' command (when used without any package arguments) has
05:45:44 <mietek> been disabled in this release. It has been disabled because it has frequently
05:45:44 <mietek> led people to accidentally break their set of installed packages. It will be
05:45:45 <mietek> re-enabled when it is safer to use.
05:46:13 <mietek> This doesn't seem very nice
05:49:26 <Jafet> mietek: cabal upgrade | grep blah | xargs cabal upgrade
05:49:43 <Jafet> Now you can accidentally break your set of installed packages!
05:50:01 <mietek> Yes, this is the thing which doesn't seem very nice.
05:50:07 <mietek> Warning about it is okay, I guess.
05:55:13 <mietek> Aha
05:55:25 <mietek> /usr/local/var/cabal/config
05:56:00 <mietek> Why would it keep it there?
06:01:48 <dom96> hello, does anyone know how to use hdaemonize package? The daemonize function seems to just kill my program.
06:02:24 <doofer> anyone got any insight on documenting GADTs with Haddock? it doesn't work for me, and I've been unable to find any relevant info on it
06:03:43 <mietek> ivanm: looks like it's updateTVar which is using 99% of the time
06:43:50 <orbital_fox> anyone here installed haskell on a mac?
06:44:03 <orbital_fox> homebrew?
06:44:27 <earthy> the haskell platform works just fine on a mac
06:45:13 <orbital_fox> have you installed it using homebrew? or dmg from the website?
06:48:42 <earthy> dmg from the website
06:52:54 <orbital_fox> ok
06:53:14 <orbital_fox> ill google to checkout if its worth doing it through homebrew
06:53:26 <orbital_fox> earthy do you use any IDE or editor?
06:59:29 <stefan____> any opinions on Scala? someone recommended to me to look into it
07:00:10 <stefan____> haskell-/functional-programming influenced opinions
07:00:12 <stefan____> to make this on-topic ;)
07:00:53 <aristid> stefan____: of course haskell is much better than scala ;)
07:01:07 <aristid> and of course we are totally unbiased
07:02:04 <freiksenet> scala is tied to java infrastructure. so you must love xml to use it )
07:02:27 <freiksenet> aka build tools and this kind of stuff.
07:02:54 <freiksenet> this is a stopper for both clojure and scala to me :|
07:02:57 <arw> stefan____: if you are forced to interface to other software on the java vm, then scala is a nice option.
07:03:10 <arw> stefan____: but on its own i don't really like it that much.
07:03:23 <arw> stefan____: too many java-isms for my taste.
07:04:30 <arw> stefan____: often it doesn't feel like a functional language but rather like java with a less tedious syntax. 
07:15:08 <ineol> @unmtl MaybeT (State s) a
07:15:09 <lambdabot> s -> (Maybe a, s)
07:15:41 <ineol> @unmtl StateT s Maybe a
07:15:41 <lambdabot> s -> Maybe (a, s)
07:16:59 <melkart> i tried using haskell-platform and cabal-install in Fedora 13. but with all packages I tried cabal install fails with an error. is that normal?
07:17:10 <jmcarthur> failing is certainly not normal
07:17:33 <huntse> scala is *way* nicer than java imo.  But *way* less nice than Haskell.
07:18:01 <melkart> as a regular user (not as root) i did "cabal update" and then "cabal install mandulia" (for example). then i get a failure
07:19:54 <huntse> melkart: what's the failure?  It's working fine for me as a regular user on FC13
07:20:27 <melkart> huntse: do u use the haskell-platform from the Fedora archives (yum install haskell-platform) like me?
07:21:18 <huntse> melkart: yes
07:21:24 <melkart> the last line of the failure chain are: / hslua-0.3 failed while downloading the package./ mandulia-0.7 depends on hslua-0.3 which failed to install.
07:22:56 <huntse> hmm. well if it can't download the package that's a bit of a problem.  I'm just trying that particular package now... everything else is working just fine for me though.
07:30:53 <huntse> It's taking a while because I'm just on a netbook here.  But it all seems to be working just fine afaics.  I had to cabal install ObjectName on it's own - for whatever reason it failed when cabal tried to install it as a dependency.
07:32:26 <melkart> thank you... now i am doing likewise, and so far it seems to work
07:33:06 <huntse> melkart: my pleasure. fwliw it seemed to work fine for me.  Good Luck!
07:34:50 <jmcarthur> are we ever going to have Max and Min added to Data.Monoid? :(
07:38:32 <melkart> hfractal, topkata and OpenAL don't work...
07:44:27 <huntse> melkart: have you installed (using yum) openal-soft-devel? cabal only knows how to install dependencies within the world of Haskell packages.  If a haskell package wraps a C library you need to use yum (or whatever) to install the devel rpm so you get the lib and headers and can build the haskell ffi bits for that library.
07:56:42 <huntse> you need freealut-devel as well.  Anyhow, you get the idea...
07:56:42 <melkart> topkata failed with a haskell failure although all its dependencies are installed now
07:56:55 <melkart> yes, thank you. already installed it
07:57:36 <melkart> failure message from hfractal: OpenGLRaw-1.1.0.0 was excluded because hfractal-0.4.2.2 requires OpenGLRaw <1.1.0.0
07:57:45 <melkart> openglraw is already installed
07:58:56 <huntse> melkart: I'm not going to solve all your problems. If you look at that message it's telling you it wants a version less than 1.1.0.0 so the version you have is too modern.  Have a read up about how to solve that for yourself.
08:00:28 <melkart> i thought that cabal was designed to prevent such breakage...
08:00:49 <jmcarthur> it's not broken though
08:01:13 <melkart> i cant install it, although i did as told... how is that not broken?
08:01:17 <jmcarthur> it's properly detecting a dependency error
08:01:30 <melkart> i cant install SDL and fallingblocks either... 
08:01:40 <jmcarthur> do you have the necessary C libaries for those bindings?
08:01:45 <melkart> ah.. sdl probably depends on some fedora package...
08:01:56 <chilili> what does the constructor "State" real do in  "nextStringS = State (\s -> ((), tail s) "  comparing "nextString = \s -> ((), tail s)"  ?
08:02:49 <jmcarthur> chilili: it just wrapped it in a newtype. at runtime there is no difference, but it does affect type checking
08:03:10 <jmcarthur> it also means you can use the State monad
08:03:22 <jmcarthur> because you can define new type class instances for newtypes
08:03:57 <chilili> jmcarthur: nextStringS "abcde" got error while nextString "abcde" works.
08:04:16 <jmcarthur> i don't know these nextString and nextStringS functions
08:04:26 <jmcarthur> oh
08:04:29 <jmcarthur> sorry my bad
08:04:51 <jmcarthur> chilili: it looks like you are just not using nextStringS in a context that expects State
08:05:58 <chilili> I still little confuse on why do I have to use runState nextStringS "abcade" 
08:07:56 <chilili> jmcarthur: thanks. I understand a little more.
08:08:32 <doofer> nextStringS constructs a value of type State by applying a function to the constructor State
08:08:56 <chilili> doofer: yes
08:08:57 <doofer> runState will get the function from something of type State
08:09:20 <doofer> nextString is the function itself, not wrapped in anything
08:09:47 <doofer> does that make it any clearer?
08:09:57 <chilili> doofer: yes!
08:10:15 <chilili> doofer: thanks
08:10:24 <doofer> good :)
08:11:16 <melkart> at last i got fallingblocks to compile but when i run it, it quits with an error nonetheless..
08:12:06 <melkart> ok... thxbye
08:13:23 <siracusa> I'm getting an error `haddock: unrecognized option `--verbose'' when running `cabal haddock'. How can I change the cabal options for haddock?
08:13:47 <doofer> siracusa: try cabal haddock --help
08:14:08 <chilili> doofer: so the wrapper is just the Monad Box, right?
08:15:29 <siracusa> doofer: This doesn't help since cabal passes the verbose option automatically to haddock.
08:15:35 <chilili> I just want to understand it in more perceptual way.
08:16:22 <doofer> chilili: yes, that's a way to think of it, I think (though some may not agree on calling it that)
08:16:55 <doofer> siracusa: ah, sorry, I misinterpreted your question
08:26:09 <Phyx-> Saizan: found out how to read the interface files, http://phyx.pastebin.com/8DrKTu1M
09:26:47 <Phyx-> what's the easiest way to convert a string to a ByteString? or [Word8] ?
09:27:56 <aRcatan> pack in Data.ByteString.Char8
09:29:08 <Phyx-> wow, how did I miss that.. thanks aRcatan 
09:29:14 <aRcatan> np
09:35:40 <lispy> Phyx-: you can also use the OverloadedStrings extension
09:35:56 <lispy> Phyx-: it's nice to use when a module has a lot of string literals but you want to switch to ByteString
09:37:59 <Polarina> Can anyone suggest a nice library to do my own drawings and rendering?
09:38:03 <Phyx-> lispy: well, I just noticed I don't need it, Binary already has an instance of Char and [a] which I missed
09:38:28 <lispy> Polarina: cairo, sdl, and opengl
09:39:01 <Polarina> lispy, thanks. I have looked at cairo, but the major disadvantage is the inability to render on-screen without gtk.
09:39:08 <lispy> Polarina: there are any different styles of drawing and ways to do it and each of those libraries specializes on something different
09:41:39 <Phyx-> hmm Binary makes things so easy... even a bit *too* easy :P
09:42:45 <Polarina> :)
09:45:46 <chrisdone> so it seems that I'm not the only one who finds it difficult to write the type signatures for his takusen-related functions
09:46:08 <chrisdone> every example I've looked at on google code search, the top level definitions have type signatures, except from functions based on takusen
09:46:17 <chrisdone> I will figure this library out!
09:48:56 <chrisdone> x :: ?
09:48:56 <chrisdone> x = doQuery sql (result' id) ()
09:49:05 <chrisdone> I'm starting with: x :: DBM mark Session ()
09:49:21 <chrisdone> but,  No instances for (IQuery q Session b, Statement (String -> Database.PostgreSQL.Enumerator.QueryString) Session q) arising from a use of `doQuery'
09:49:26 <chrisdone> so,
09:50:05 <chrisdone> doQuery :: (Statement stmt sess q, Database.Enumerator.QueryIteratee (DBM mark sess) q i seed b, IQuery q sess b) => stmt -> i -> seed -> DBM mark sess seed
09:50:58 <chrisdone> so how do I instantiate this DBM mark sess seed type
09:52:25 <chrisdone> (into a concrete type or less verbose type than :: (Monad m, Statement (String -> Database.PostgreSQL.Enumerator.QueryString) sess q, Database.Enumerator.QueryIteratee (DBM mark sess) q (m (IterResult (a -> a))) () b, IQuery q sess b) => DBM mark sess ()
09:52:27 <chrisdone> hmm
09:52:40 <chrisdone> (which is what GHC produces)
09:53:17 <Jafet> The only lesson you can draw from this is that sql is crap.
09:53:34 <chrisdone> please someone else tell me they find this difficult to follow too
09:54:01 <Phyx-> @hoogle Date
09:54:01 <lambdabot> Data.Time.Calendar.OrdinalDate fromOrdinalDate :: Integer -> Int -> Day
09:54:01 <lambdabot> Data.Time.Calendar.WeekDate fromWeekDate :: Integer -> Int -> Int -> Day
09:54:01 <lambdabot> Data.Time.Clock getModJulianDate :: UniversalTime -> Rational
09:54:10 <Phyx-> @hoogle getCurrentDate
09:54:10 <lambdabot> No results found
09:54:12 <Phyx-> @hoogle getCurrent
09:54:12 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
09:54:12 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
09:54:12 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
09:54:18 <Jafet> If those types mean anything by themselves, you could use typesyms
09:54:55 <Jafet> No wait, they're classes.
09:54:57 <chrisdone> my usual method of breaking it down into simple parts is failing because it's all interdependent
09:55:22 <Phyx-> @hoogle tick
09:55:22 <lambdabot> System.Posix.Types type ClockTick = CClock
09:55:49 <Phyx-> is there a way to get the current time in ticks/
09:56:22 <Jafet> @hoogle ClockTick
09:56:22 <lambdabot> System.Posix.Types type ClockTick = CClock
09:56:25 <lispy> chrisdone: do you know about #takusen?
09:56:32 <Jafet> @hoogle IO ClockTick
09:56:32 <lambdabot> Did you mean: :: IO ClockTick /count=20
09:56:32 <lambdabot> No results found
09:56:42 <lispy> chrisdone: and have you seen the post on my blog about using takusen?
09:56:45 <chrisdone> lispy: nope! sounds good
09:57:02 <chrisdone> lispy: yeah, I read that and I'm /trying/ to write explicit type signatures right now
09:57:11 <lispy> chrisdone: hehe, okay
09:57:20 <chrisdone> ah, haha. it's just me and you in #takusen
09:57:40 <lispy> chrisdone: there are two tricks I use when figuring out complex type sigs in Haskell.  Try setting the sig to either, :: Int, or :: a, and see what error GHC produces
09:58:00 <lispy> chrisdone: new channels catch on, one user at a time ;)
09:58:16 <dom96> Anyone know how to fix this cabal problem, https://gist.github.com/8eb48fc3e8c7c877e963 ?
09:58:18 <chrisdone> lispy: haha, I do that! I want to see what GHC expects, so I put in an Int
09:58:29 <Phyx-> a screw it, i'll use FFI and a windows specific call
09:59:32 <lispy> chrisdone: also, if you compile with -Wall but have no top level sigs then GHC will print the sig
09:59:45 <chrisdone> lispy: yeah, that's how I'm showing the ones above ^
09:59:49 <ben__> @pl a b = (b \= c) && (b \= d)
09:59:50 <lambdabot> (line 1, column 5):
09:59:50 <lambdabot> unexpected "="
09:59:50 <lambdabot> expecting variable, "(", operator or end of input
10:00:01 <orlandu63> what's the name of the program that takes a filepath as input and returns the package it the file belongs to
10:00:07 <orlandu63> oops
10:00:09 <orlandu63> wrong channel
10:00:23 <chrisdone> lispy: it's (rightly) generating a general type. but I want to specialise it to my particular instance (PostgreSQL)
10:01:07 <lispy> ah
10:02:12 <ben__> @pl \a b -> (b \= c) && (b \= d)
10:02:12 <lambdabot> (line 1, column 12):
10:02:12 <lambdabot> unexpected "\\"
10:02:12 <lambdabot> expecting variable, "(", operator or ")"
10:02:21 <chrisdone> > :t doQuery sql (\x xs -> result' (x:xs)) []
10:02:21 <chrisdone> doQuery sql (\x xs -> result' (x:xs)) []
10:02:21 <chrisdone>   :: (IQuery q sess b,
10:02:21 <chrisdone>       DBType a q b,
10:02:24 <chrisdone>       Statement
10:02:27 <chrisdone>         (String -> Database.PostgreSQL.Enumerator.QueryString) sess q) =>
10:02:30 <chrisdone>      DBM mark sess [a]
10:02:57 <chrisdone> lispy: so I have this ^ which is alright, but way too long for my taste. I know what sess is, it's Session (postgres's session instance type)
10:03:17 <lispy> chrisdone: then you should be able to import Session and use it directly
10:03:28 <chrisdone> like this?
10:03:29 <chrisdone> :t doQuery sql (\x xs -> result' (x:xs)) [] :: DBM mark Session [a]
10:03:30 <lambdabot> Not in scope: `doQuery'
10:03:30 <lambdabot> Not in scope: `sql'
10:03:30 <lambdabot> Not in scope: `result''
10:03:37 <chrisdone> woops, didn't mean to trigger \b
10:04:14 <lispy> chrisdone: I don't tihnk that will work because of the Statement type
10:04:36 <lispy> But I'm not sure
10:05:12 <chrisdone> yeah, I see that the Statement class is dependent on the sess
10:06:45 <chrisdone> oh, woops, I'm putting in the wrong thing here, one sec
10:07:08 <chrisdone> okay, so we have
10:07:14 <chrisdone> > :t doQuery (sql "") (\x xs -> result' (x:xs)) []
10:07:14 <chrisdone> doQuery (sql "") (\x xs -> result' (x:xs)) []
10:07:15 <chrisdone>   :: (IQuery q sess b,
10:07:15 <chrisdone>       DBType a q b,
10:07:17 <chrisdone>       Statement Database.PostgreSQL.Enumerator.QueryString sess q) =>
10:07:21 <chrisdone>      DBM mark sess [a]
10:08:10 <lispy> I was wondering why it wanted a String -> QueryString instance :)
10:08:21 <chrisdone> hehe
10:08:31 <chrisdone> I can see I'm getting myself worked up
10:08:44 * chrisdone gets a bite to eat
10:08:55 <lispy> chrisdone: So, I think QueryString is how takusen is polymorphic in the string type
10:09:08 <lispy> chrisdone: so if you constraint it to ByteString or String that part should go away
10:09:51 <randomwords> I'm clueless when it comes to windows, but I'm trying to make my code compile there. Has anyone had any success installing the haskell gd bindings on windows? 
10:10:56 <luite> randomwords: I haven't tried them, but you'll need to install the gd bindings first
10:11:56 <randomwords> luite: When you say bindings, do you mean the gd-haskell stuff on cabal, or the actuall gd library
10:12:07 <luite> oops
10:12:09 <luite> I meant library
10:12:33 <luite> randomwords: if you have MSYS installed (not included with the haskell platform) you can compile the gd library manually, you'll need to install all its dependencies (probably libpng, libjpeg) too
10:12:51 <randomwords> Yeah I have msys, but like I said, I'm very clueless
10:13:17 <Jafet> If you're clueless, use linux! (Imagine saying this in 1999)
10:13:31 <luite> randomwords: if you can start an msys bash shell, it's more or less the same as compiling in linux
10:13:41 <luite> i.e. run a configure script, make
10:14:05 <chrisdone> lispy: how do I constraint it to ByteString or String?
10:14:09 <luite> it's very tedious though
10:14:22 <randomwords> luite: OK thanks, I'll be back in 20-30 mins when I inevitably fail
10:14:28 <luite> randomwords: wait :)
10:14:35 <aristid> Jafet: i can somehow imagine you saying this in 1999 :P
10:14:47 <luite> randomwords: there's an alternative that may be easier, which was recommended to me recently
10:14:55 <randomwords> All ears
10:14:58 <luite> download takeoffgw
10:15:17 <luite> this uses the cygwin installer to install all kinds of open source packages for windows
10:15:36 <luite> you can probably install libgd with it
10:15:46 <luite> but I haven't tried it myself
10:15:50 <chrisdone> ahhaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
10:16:51 <chrisdone> > :t (doQuery (sql "select 1") (\(a::Int) xs -> result' (a:xs)) []) :: (forall mark. DBM mark Session [Int])
10:16:51 <chrisdone> (doQuery (sql "select 1") (\(a::Int) xs -> result' (a:xs)) []) :: (forall mark. DBM mark Session [Int])
10:16:51 <chrisdone>   :: DBM mark Session [Int]
10:17:29 <luite> randomwords: I think that you'll ahve to edit your cabal configuration file to add the takeoffgw library path
10:17:47 <randomwords> Yeah, that makes sense
10:17:48 <luite> but like I said, I haven't tried it myself yet
10:17:59 <randomwords> If I get it working I might write it up as a guide for others
10:18:08 <chrisdone> withDB :: (Typeable a) => (forall mark. DBM mark Session a) -> IO a
10:18:09 <chrisdone> and so:  withDB (doQuery (sql "select 1") (\(a::Int) xs -> result' (a:xs)) []) => [1]
10:18:09 <chrisdone> but when having x = doQuery .. and giving x such a type annotation as a top-level definition, type errors are thrown
10:18:13 <luite> if you get stuck, I'll try to install it too
10:18:30 * chrisdone fiddles
10:18:36 <luite> I need to learn how takeoffgw works some time anyway :)
10:19:04 <chrisdone> yaaaaaaaaaaaaaay
10:19:44 <chrisdone> it seems I've been doing something catastrophically careless and its confused me to the point bafflement
10:20:21 <chrisdone> lispy: I was getting type errors, so I did the simple test above, but I must've done sql instead of (sql "foo") and then became confused about the type errors
10:20:37 <chrisdone> x :: DBM mark Session [Int]
10:20:37 <chrisdone> x = doQuery (sql "select 1") (\(a::Int) xs -> result' (a:xs)) []
10:20:37 <chrisdone> -- ^ no problem
10:22:18 <chrisdone> but, seems like all the other examples of using this library I looked at on Google Code Search, no one could figure out the specific type sig
10:23:01 <randomwords> luite: I'm installing but gd doesn't seem to be in the available libs
10:26:09 <lispy> chrisdone: heh
10:26:44 <luite> randomwords: hmm, that's unfortunate, it does contain libjpeg and libpng though
10:26:57 <randomwords> luite: Yeah I saw that
10:29:11 <luite> randomwords: what I usually do in msys is ./configure --prefix=/  and then make
10:29:24 <luite> randomwords: followed by make install DESTDIR=somelocation
10:29:34 <randomwords> ok
10:29:47 <luite> then I zip those files in case I need to reinstall haskell platform
10:29:52 <randomwords> ah
10:30:08 <luite> and then I copy the files in DESDTIR to the mingw directory of the haskell platform
10:30:34 <luite> oh I added the haskell platform mingw\bin directory to my PATH
10:33:37 <EvanR> interesting likely intractable problem for you ;)
10:33:59 <EvanR> i am trying to identify floors
10:34:36 <EvanR> consider a rectangle grid, each cell can have one of several shapes like square, triangle and trapezoid rotated one of four ways
10:34:56 <EvanR> a floor is considered to be one side of the shape, the top side
10:35:06 <EvanR> if two shapes next to each others floors meet, they are the same floor
10:35:24 <Jafet> I was reminded of http://captionsearch.com/pix/kinpqp4wv.jpg
10:35:31 <randomwords> top with resp. to the grid?
10:35:42 <EvanR> the 'up' most side
10:35:47 <randomwords> k
10:35:53 <EvanR> so thats an equivalence class
10:36:01 <siracusa> Does a haddock interface file store all the API information about a package, like function names with parameter types, classes, instances, etc.?
10:36:05 <EvanR> now the task is to assign its cell its equivalence class
10:36:12 <ralph__> so how about haskell and music? 
10:36:36 <Raevel> i'm listening to the neverhood soundtrack, so there you go
10:37:18 <JoeyA> I want to do something really naughty:  I want to return a pure expression from an IO action, and have another action that takes input from the caller and identifies any objects the caller kept intact.
10:37:21 <EvanR> assign each cell its equivalence class
10:37:26 <JoeyA> Namely, if the "get" action returns:
10:37:32 <JoeyA> [[1,2],[3,4],[5,6]]
10:37:39 <JoeyA> and we pass it through:
10:37:51 <JoeyA> f [x,y,z] = [x,[300, 400],z]
10:38:12 <JoeyA> I want a "put" action that notices that the [1,2] and [5,6]
10:38:14 <JoeyA> were kept
10:38:40 <EvanR> my idea is to scan all cells until you find an unassign cell, assign it a new number, and 'follow' its floor assigning the number to connected cells
10:38:51 <EvanR> but thats like bad
10:38:56 <JoeyA> It's important that it not lie when it calls two values equal, but it's less important that it always perform this optimization.
10:39:38 <JoeyA> I'm wondering if StableName will help me here:  http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-Mem-StableName.html#t%3AStableName
10:40:32 <JoeyA> To put icing on the cake, I want "gets" to be able to use lazy IO.
10:41:11 <JoeyA> My goal is to create an efficient key-value store with native Haskell semantics.
10:41:14 <JoeyA> You would say:
10:41:18 * chrisdone eats the icing, and substitutes it for marshmellow
10:41:25 <JoeyA> eww
10:41:49 <JoeyA> Unless you're the Michelin man.
10:42:01 <EvanR> JoeyA: theres already efficient key value store
10:42:03 * BrianHV has had his mind blown by the guard example in LYAH's monads chapter.
10:42:15 <Jafet> EvanR: intractable? In two dimensions this is n log n
10:42:23 <EvanR> Jafet: how?
10:42:57 <EvanR> whats n anyway
10:43:13 <Jafet> Number of basic shapes
10:43:24 <EvanR> my way isnt intractable, its just more than n^2
10:43:32 <JoeyA> db <- create "foo.db" ; value <- get "key"; put "key" (f value); close db
10:43:44 <EvanR> n is length of side of grid
10:43:44 <JoeyA> EvanR: What key value store do you speak of?
10:43:51 <EvanR> JoeyA: Data.Map
10:43:57 <JoeyA> I'm talking about on-disk.
10:44:01 <JoeyA> Persistent.
10:44:05 <Jafet> I suppose I don't quite understand what you mean by floor, then
10:44:30 <EvanR> JoeyA: you dont immediately store stuff to disk to support persistence, you periodically back it up to disk
10:44:40 <EvanR> which you can do with show
10:44:44 <EvanR> restore with read
10:44:50 <EvanR> Jafet: yeah i dont know if i explained it
10:44:54 <JoeyA> That's not very efficient.
10:45:02 <EvanR> thats how really databases work
10:45:04 <EvanR> real*
10:45:05 <JoeyA> Data.Binary and friends are nice, but they're not very lazy.
10:45:18 <Jafet> EvanR: not really big real databases.
10:45:33 <EvanR> no they load parts of the thing into memory at a time
10:45:50 <EvanR> but i think that is beyond JoeyA goal
10:45:50 <Jafet> I wouldn't want on-disk storage to behave like in-memory storage, anyway -- let's all try to learn a few lessons from nfs.
10:45:55 <JoeyA> I'm talking about a persistent store that plays well with the Haskell type system.
10:46:13 <Gracenotes> happstack-state?
10:46:23 <JoeyA> nfs is across-the-room storage, not on-disk.
10:46:32 <Gracenotes> not as explicit as a database but works with native haskell types
10:46:34 <JoeyA> It's less likely that the disk will be unplugged.
10:48:02 <EvanR> in principle disk and ram are just as persistent, if you allow for power failure you can allow for hard disk failure
10:48:11 <JoeyA> db <- create "foo.db" ; value <- get "key"
10:48:12 * EvanR splits hairs
10:48:21 <EvanR> JoeyA: you want to use string keys?
10:48:30 <JoeyA> Here, the value is retrieved lazily.  That's not unprecedented.
10:48:57 <EvanR> why would you retrieve it if you didnt know you needed it
10:49:06 <JoeyA> put "key" (f value) doesn't simply serialize the value without looking, it uses reflection ninjitsu to avoid copying the same data back.
10:49:30 <JoeyA> Maybe you just want to look at a small subtree of the input.
10:49:32 <EvanR> gah this sounds like .net or something
10:49:36 <JoeyA> e.g.:
10:49:40 <JoeyA> data FileTree
10:49:52 <JoeyA> ls :: FileTree -> FilePath -> [FilePath]
10:50:05 <JoeyA> stat :: FileTree -> FilePath -> FileTree
10:50:06 <JoeyA> whatever
10:50:16 <randomwords> EvanR: How is it differnet from a standard graph connectivity problem?
10:50:21 <JoeyA> (management of a Haskell-typed file tree)
10:50:25 <randomwords> EvanR: i.e. clique finding
10:50:33 <JoeyA> Anyway, tree <- "get key"
10:50:37 <EvanR> randomwords: probably none, but you guys know more about that than me
10:50:45 <JoeyA> ls "foo/bar/baz" tree
10:51:08 <JoeyA> (that would just retrieve the nodes needed rather than loading the whole tree into memory)
10:51:09 <ralph__> ,paste
10:51:32 <lispy> ralph__: http://hpaste.org
10:51:40 <EvanR> randomwords: how does that go?
10:52:10 <randomwords> EvanR: so off the top of my head (and this is by no means the best solution). I would run a two pass algoithm. First create the graph of you floors. So each vertex is a "room", and each "edge" is iff two floors share a common edge.
10:52:27 <JoeyA> Anyway, StableName looks like exactly what I need:  If sn1 :: StableName and sn2 :: StableName and sn1 == sn2  then sn1 and sn2 were created by calls to makeStableName  on the same object. 
10:52:37 <tibbe> I'm the worker wrapper, yo yo yo
10:52:38 <EvanR> randomwords: wait
10:52:55 <JoeyA> That is the type of equality I'm interested in.
10:52:56 <EvanR> randomwords: room?
10:53:15 <Axman6> tibbe: down in the hood, in the hood, in the hood, in the hood, in the hood in ...
10:53:20 <randomwords> Cell sorruy
10:53:31 * tibbe has been coding too much today, he's losing it
10:53:53 <EvanR> oh
10:53:57 <lispy> > fix (\xs -> text$ "Down in the hood, " ++ xs)
10:53:58 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
10:53:58 <lambdabot>         against inferred ty...
10:54:16 <EvanR> randomwords: that steps seems to be all i really need
10:54:17 <lispy> > fix (\xs -> text$ "Down in the hood, " ++ xs) :: Doc
10:54:18 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
10:54:18 <lambdabot>         against inferred ty...
10:54:24 <EvanR> how do you construct that graph
10:54:26 * lispy sees the problem with it and gives up
10:54:44 <randomwords> Then run a clique finding algorithm on that graph. I'm sure there are more efficient ones, but a simple one would be first make all your verticies "unmarked". Take one, mark it "1", then everything connected to it is also "1". When you have touched everything, take the next unmarked vertex and mark it 2 etc.
10:54:56 <lispy> > fix ("Down in the hood, " ++)
10:54:57 <lambdabot>   "Down in the hood, Down in the hood, Down in the hood, Down in the hood, Do...
10:55:09 <randomwords> EvanR: You can probably fuse the two passes
10:55:29 <lispy> > text "Down" ++ (fix ("in the hood, " ++))
10:55:30 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
10:55:30 <lambdabot>         agains...
10:55:43 <lispy> > text $ "Down" ++ (fix ("in the hood, " ++))
10:55:48 <lambdabot>   mueval: ExitFailure 1
10:55:52 <EvanR> randomwords: right thats what i originally explained, but how do you find the next unmarked cell
10:56:01 <lispy> Axman6: sadly, that hood is _|_ ^^
10:56:02 <EvanR> search through them all again?
10:56:10 <randomwords> EvanR: Well I assume you already have a list of cells. These are  your verticies. For each vertex look at each of its immediate neighbours. If there is a cell there, then add an edge between those two cells in your edge representation
10:56:24 <Axman6> lispy: i was assuming the worker would terminate some time
10:56:35 <Axman6> anyway, sleep time!
10:56:55 <randomwords> If you scan from left to right over the grid then you never need to check left as that is already done.
10:57:00 <Axman6> lispy: also, text is strict
10:57:13 <EvanR> ok but you might come across already visited cells
10:57:18 <EvanR> ?
10:57:39 <randomwords> How so?
10:57:59 <EvanR> or, you might travese the same floor more than once
10:58:19 <randomwords> I don't think you will
10:58:39 <randomwords> You only check the immediate neighboors of each cell
10:58:52 <randomwords> if it's a rectangular grid you are only checking at most 4 other cells
10:58:54 <EvanR> yes so you could go down
10:58:57 <EvanR> 8
10:59:12 <randomwords> Right
10:59:36 <EvanR> so scanning left to right, the start over 1 down means you might meet a previous floor
10:59:46 <EvanR> and you can ignore them
11:00:03 <randomwords> Well that's why you mark cells which you have already touched
11:00:41 <EvanR> ok this shouldnt be that bad then
11:01:11 <randomwords> Thinking about you don't need to build a graph representation, you already have an implicit one
11:02:24 <EvanR> that works
11:02:39 <randomwords> So yeah you may "check" cells you have already included in the clique, but you will make at most 8 checks per cells so the algorithm is still O(V)
11:02:41 <randomwords> which is a good thing
11:03:22 <randomwords> and you can eliminate some of the checks if you think carefully about it
11:03:37 <EvanR> also, according to my shapes, all floors have 1 cell per x-coordinate
11:03:59 <EvanR> will this algorithm always start with the left most cell of a floor
11:04:06 <EvanR> i think so
11:04:07 <Mitar> i would like to use forkIO and killThread in bracket
11:04:11 <randomwords> It can start wherever you want
11:04:20 <Mitar> but as I use a monad over IO, i have to use liftIO
11:04:30 <Mitar> how can I lift killThread so that I can use it in bracket?
11:04:45 <EvanR> it wont find an floor starting with a middle cell i dont think
11:05:46 <EvanR> randomwords: i looked up clique problem, and its indeed intractable xD
11:06:51 <randomwords> EvanR: I think that's a different problem actually
11:07:13 <EvanR> yeah my floors are not maximally connected
11:07:19 <randomwords> EvanR: Yeah, it's connectivity not cliques
11:07:23 <randomwords> I'm being stupid
11:07:27 <EvanR> and the various floor classes dont connect
11:07:31 <randomwords> what I said stands though, just withe wrong name
11:08:00 * EvanR looks up connectivity
11:08:05 <randomwords> You are finding the connected subgraphs
11:08:35 <EvanR> ah right graphs dont need to be connected
11:09:17 <randomwords> You want a flood fill algorithm I think
11:09:20 <randomwords> given you have a grid
11:09:46 <EvanR> hehe
11:09:53 <EvanR> its funny how all these problems are similar
11:10:39 <EvanR> they get mad at me at work when i explain a problem as being equivalent to another
11:10:46 <EvanR> dont know why xD
11:11:38 <Jafet> "Equivalent" could be misleading --  better to say "foo-reduction"
11:11:51 <EvanR> lol
11:12:06 <EvanR> i cant google that
11:12:08 <dainanaki> testing, testing, can anyone see this?
11:12:14 <Draconx> no.
11:12:20 <dainanaki> excellent
11:13:10 <ralph__> lispy, it seems that hpaste.org is not working .. ? 
11:18:01 <randomwords> EvanR: Is flood fill looking promising?
11:18:03 <Mitar> how can i liftIO killThread?
11:18:29 <ezyang> Mitar: liftIO $ killThread tid 
11:18:33 <c_wraith> you can liftIO anything of the appropriate type
11:18:43 <c_wraith> liftIO is *just* a type transformation
11:18:46 <EvanR> randomwords: no, im trying to get courage to do this. the original way is good
11:18:58 <EvanR> its in C ;)
11:19:03 <randomwords> Well if you need any help with code give me a shout
11:19:13 <Mitar>     Couldn't match expected type `IO a'
11:19:13 <Mitar>            against inferred type `ThreadId -> IO ()'
11:19:13 <Mitar>     In the second argument of `($)', namely `killThread'
11:19:13 <Mitar>     In the second argument of `bracket', namely `(liftIO $ killThread)'
11:19:24 <randomwords> The offer stands ;)
11:19:29 <EvanR> k
11:19:54 <sshc> Why can't (>>=) for Cont be declared as "m >>= f = runCont m f"?
11:20:25 <EvanR> join #vim
11:21:42 <Mitar> how can i lift killThread in such context?
11:22:18 <c_wraith> Mitar, you're not passing it a ThreadId
11:22:31 <Mitar> how can i pass it if it is in bracket?
11:22:36 <Mitar> threadID is stored in bracket
11:22:39 <Mitar> that is the idea ;-)
11:22:42 <c_wraith> If you just want a lifted version of killThread, use "liftIO . killThread"
11:22:42 <Mitar> "stored"
11:23:01 <Mitar> i want forkIO for first element of bracket, killThread for second
11:23:29 <c_wraith> yeah.  you need function composition, that is the . operator
11:24:18 <Mitar> ehm, where should i use composition?
11:24:25 <c_wraith> Just where I said.
11:24:32 <c_wraith> use (liftIO . killThread)
11:24:41 <c_wraith> instead of (liftIO $ killThread)
11:25:01 * hackagebot hpage 0.12.2 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.12.2 (FernandoBenavides)
11:25:06 <c_wraith> the latter tries to apply liftIO to killThread, which doesn't make sense, as killThread isn't the right type.
11:25:17 <c_wraith> The former says "First kill the thread, then lift the result"
11:26:03 <EvanR> randomwords: this is resort 7 in my quest to make a platform game on a tile grid, with sloped floors
11:26:13 <EvanR> that you can walk on
11:26:25 <randomwords> I see
11:27:01 <EvanR> and now i see that its not going to solve the issue of interacting with sloped ceilings, because gravity doesnt keep you on the ceiling
11:27:34 <EvanR> *goes insane*
11:29:53 <EvanR> Walt: stop following me >_<
11:29:59 <Walt> :(
11:30:03 <EvanR> just joking
11:30:16 <EvanR> i know youre in every freenode channel
11:31:23 <Jafet> EvanR: N uses a fixed selection of sloped tiles, and there are algorithms on their site
11:31:44 <EvanR> great another nice google keyword
11:31:47 <Jafet> But afaik it's all separating axes
11:32:06 <Jafet> If you want something smarter or more flexible, theirs won't work
11:32:23 <EvanR> separating axes?
11:33:34 <EvanR> i found a flash game
11:33:45 <Jafet> http://www.metanetsoftware.com/technique.html
11:33:48 <EvanR> it has arbitrary geometry
11:35:08 <Jafet> Not really, it's all square tiles
11:37:02 <EvanR> ok
11:37:14 <EvanR> more arbitrary than my shapes
11:37:22 <EvanR> has semi circle etc
11:37:42 <ManateeLazyCat> Does any function retained two digits after the decimal point?
11:38:05 <EvanR> reading the blog
11:38:11 <ManateeLazyCat> I mean 1.23456 will convet to 1.23
11:38:41 <Jafet> If your browser has flash, their separating axes tutorial is quite nice
11:38:56 <Jafet> Almost as good as a printed-book explanation
11:39:27 <Jafet> lazycat: well, there's printf
11:39:45 <ManateeLazyCat> Jafet: Havne't "foo :: Double -> Int -> Double" ?
11:40:32 <Jafet> > let format x k -> (fromIntegral $ floor $ x * 10^k) / 10^k in format 1.23456 2
11:40:33 <lambdabot>   <no location info>: parse error on input `->'
11:40:34 <ManateeLazyCat> Jafet: I use '(truncate $ number * 100) / 100' but i wonder have exist function do this.
11:40:40 <Jafet> > let format x k = (fromIntegral $ floor $ x * 10^k) / 10^k in format 1.23456 2
11:40:41 <lambdabot>   1.23
11:41:02 <Jafet> ...not that 1.23 is actually a Double.
11:41:13 <ManateeLazyCat> Jafet: Haven't bulidin one?
11:41:29 <Jafet> I don't know one
11:41:32 <EvanR> > formatFloatN pi 2
11:41:33 <lambdabot>   Not in scope: `formatFloatN'
11:42:42 <EvanR> in Numeric
11:47:42 <ManateeLazyCat> @src showGFloat
11:47:42 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:47:58 <ManateeLazyCat> :t showGFloat
11:47:59 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
11:56:36 <monadic_kid> does anyone know how to enable bang patterns in jhc?
11:57:32 <orbital_fox> hello
11:57:37 <orbital_fox> hello luite 
11:58:26 <jmcarthur> EnumMap is awesome except for a couple things: (1) Why is it a reimplementation of Data.Map rather than a wrapper around it? (2) There is no EnumSet.
11:58:41 <jmcarthur> s/Data.Map/IntMap/
11:58:46 <JoeyA> How do people typically perform random access on files in Haskell?
11:58:56 <jmcarthur> how would you do it in C?
11:59:06 <JoeyA> well, I could fopen and fseek
11:59:06 <monochrom> seek
11:59:21 <JoeyA> I guess seek is what I seek, then.
11:59:22 <jmcarthur> seems reasonable to me
11:59:24 <lispy> ?hoogle seek
11:59:24 <lambdabot> System.IO SeekFromEnd :: SeekMode
11:59:24 <lambdabot> System.IO data SeekMode
11:59:24 <lambdabot> System.IO AbsoluteSeek :: SeekMode
11:59:36 <JoeyA> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/System-IO.html#v:hSeek
11:59:39 <JoeyA> rftm, JoeyA
11:59:55 <lispy> JoeyA: hehe.  I like hoogle/hayoo to help me find these things
11:59:58 <monochrom> hSeek and ye will hTell
12:00:00 <JoeyA> rftm: Read First the Manual :-)
12:00:35 <JoeyA> Does it work in ByteString-land?
12:00:42 <wli> ftell() is kind of strange to need.
12:00:45 <JoeyA> I'd imagine so.
12:01:06 <JoeyA> well, a common idiom for getting the file length is to fseek() to the end, then ftell()
12:01:09 <monochrom> sounds orthogonal. hSeek and hTell talk about handles only.
12:01:14 <JoeyA> However, one needs to ensure ftell() is 64-bit
12:01:25 <JoeyA> (if dealing with large files)
12:03:13 <lispy> JoeyA: The offset i is given in terms of 8-bit bytes.
12:03:19 <lispy> JoeyA: does that answer your question?
12:03:38 <cinayakoshka> how many times is n^2 evaluated in this:  sum (takeWhile (<10000) [n^2 | n <- [1..], odd (n^2)])
12:03:56 <lispy> JoeyA: If the file is, say, utf8, then seeking in it will be harder than if it's not.  But, why would you seek in a ut8 file by bytes?
12:04:07 <monochrom> could be infinitely many times
12:04:15 <monochrom> err
12:04:39 <lispy> cinayakoshka: I don't know if ghc will share the n^2.  It could or it could decide not to
12:04:49 <monochrom> let x be the number of perfect squares between 1 and 10000. n^2 will be evaluated 2x times.
12:04:51 <c_wraith> You could just do odd n, though
12:04:57 <monochrom> s/will/could/
12:05:08 <c_wraith> since only odd numbers are lead to odd squares
12:05:11 <cinayakoshka> yeah, I know, I just wanted to know how it would work.
12:05:21 <cinayakoshka> thanks.
12:05:24 <lispy> cinayakoshka: if you want to know, you could use ghc-core to look at the compiler output
12:05:25 <c_wraith> ghc *may* decide to share the result, but probably won't
12:05:35 <cinayakoshka> ooohhh...   cool.
12:05:48 <Igloo> If you want it to be shared, let-bind it
12:05:50 <lispy> cinayakoshka: ghc-core is on hackage
12:05:54 <c_wraith> in general, ghc doesn't do common subexpression elimination
12:05:58 <JoeyA> What I'd be interested to know is: is there a spiffy low-level database library for Haskell?
12:06:07 <cinayakoshka> thanks, lispy.
12:06:08 <JoeyA> Even lower-level than BerkeleyDB
12:06:10 <lispy> JoeyA: happstack has something
12:06:18 <lispy> JoeyA: hashed-storage is another style
12:06:32 <Igloo> (not that that /guarantees/ that it will be shared)
12:06:37 <monochrom> if you go lower than that, you look for file systems
12:06:50 <lispy> JoeyA: I'm not sure what you mean by lower-level than BerkeleyDB, isn't the next level down the raw file system? :)
12:06:51 <JoeyA> as in, store values within pages, create references to pages, etc.
12:07:12 <monochrom> or memory management unit
12:07:14 <JoeyA> With DBM, you can't create direct pointers to values if I'm not mistaken.
12:07:15 <cinayakoshka> lgloo: interesting..  very curious.
12:07:36 <JoeyA> To split values, you need to key them by a search key rather than a more efficient direct reference.
12:07:46 <monochrom> use PalmOS. it's databases all the way down!
12:07:53 <lispy> JoeyA: sounds like you'll have to write it.  I've never heard of that.  On the other hand, if there is a C implementation of what you want, you can get at it via the FFI
12:07:54 <JoeyA> lol
12:08:08 <JoeyA> hmm
12:08:36 <EvanR> isnt trying to make a faster database like trying to make a faster operating system
12:08:42 <JoeyA> I wonder if I should try to steal SQLite's pager.
12:09:01 <JoeyA> I'm just trying to make a simpler-to-use database :-)
12:09:07 <EvanR> ah, no 
12:09:08 <JoeyA> I'm probably not even going to have key-values.
12:09:10 <EvanR> you are trying to make it faster
12:09:19 <monochrom> how do you know?
12:09:23 <JoeyA> db <- open "foo.db"
12:09:32 <JoeyA> x <- get db
12:09:37 <JoeyA> put db (f x)
12:09:39 <JoeyA> close db
12:09:52 <EvanR> its easier if you use Data.Map which is periodically backed up
12:09:52 <JoeyA> (where x is an arbitrary type)
12:10:02 <monochrom> yeah, what is f?
12:10:13 <JoeyA> Some function of x
12:10:24 <monochrom> yeah, how complicated is f?
12:10:32 <JoeyA> (normally one that returns substructures of it)
12:10:46 <JoeyA> Anyway, does Data.Map actually back up to disk?
12:10:54 <EvanR> no but its trivial
12:10:55 <c_wraith> No
12:11:03 <EvanR> if you have show and read instances
12:11:21 <c_wraith> actually, you'd probably use toList and fromList
12:11:21 <JoeyA> f would typically be something like DBStorable a => a -> a
12:11:38 <EvanR> c_wraith: and then show and read?
12:11:42 <JoeyA> (you could store different types of values, but that'll probably be guarded against in later versions)
12:12:01 <monochrom> db <- openFile ReadWriteMode "foo.db"
12:12:04 <c_wraith> EvanR: depends.  Those would work for many things, not for others, so...
12:12:15 <JoeyA> More importantly, it'd have lazy semantics.
12:12:15 <monochrom> x <- hReadLn  db
12:12:35 <monochrom> hPrint (f x)
12:12:38 <EvanR> c_wraith: well if the plan is to show a toList, might as well show the whole thing
12:12:43 <JoeyA> as well as value sharing (via System.Mem.StableName)
12:12:45 <monochrom> err, hPrint db (f x)
12:12:50 <monochrom> hClose db
12:13:13 <JoeyA> read and show only support serial laziness, not tree laziness.
12:13:32 <EvanR> IO doesnt support any laziness
12:13:54 <JoeyA> (unless you cheat and use hGetContents)
12:14:03 <JoeyA> or unsafeInterleaveIO, etc.
12:14:26 <JoeyA> > show [1..]
12:14:27 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:15:45 <JoeyA> Hopefully it won't be hard to get a proof of concept written quickly with http://hackage.haskell.org/packages/archive/berkeleydb/2008.10.31/doc/html/Data-BerkeleyDB.html
12:16:06 <JoeyA> Basically, a use case I'm interested in is:
12:16:23 <JoeyA> 1. Stream the stat information of a file tree into a file without exploding in memory.
12:16:29 <monochrom> Look at your own "put db (f x)" and "it'd have lazy semantics". Do you know what this entails? It entails that "put" will do a diff between the file content and (f x), and write the diff rather than the whole file.
12:16:35 <JoeyA> 2. Open that file and access subtrees efficiently.
12:16:39 <magthe> is there some example code out there that I can use to get a grip on reflection (http://hackage.haskell.org/package/reflection)?
12:16:44 <JoeyA> 3. Update the tree.
12:17:01 <JoeyA> monochrom: precisely!
12:17:23 <JoeyA> Hence, the storable types will need a type class to handle that.
12:17:29 <JoeyA> (like Data.Binary does)
12:20:13 <JoeyA> bah, the berkeleydb library I linked operates in-memory.
12:20:21 <JoeyA> err
12:20:34 <JoeyA> I mean it doesn't support working with files.
12:21:21 <monochrom> use mmap. put your Data.Map in a mmap region.
12:21:52 <JoeyA> How?
12:21:58 <monochrom> I don't know.
12:22:03 <JoeyA> lol
12:22:05 <monochrom> 1. use mmap
12:22:09 <JoeyA> thanks for the advice
12:22:14 <monochrom> 2. put your Data.Map in a mmap region
12:22:17 <monochrom> 3. profit
12:22:19 <monochrom> that's how
12:22:40 <JoeyA> except then the values themselves have to be serialized as well.
12:23:21 <EvanR> as serialized as 'in memory' values are
12:26:19 <monochrom> All relational databases give you an insert-key-value, delete-key-value interface. You just have to do it in IO.
12:26:49 <monochrom> db <- open "foo"
12:26:56 <monochrom> f db
12:26:59 <monochrom> close db
12:27:23 <monochrom> f contains calls to lookup, insert, delete, plus whatever your logic is
12:28:04 <illissius`> magthe: the paper is helpful
12:28:08 <monochrom> looks like fewer lines of code than yours, too.
12:28:24 <illissius`> also http://comonad.com/reader/2009/clearer-reflection/
12:29:39 <illissius`> magthe: basically how it works is is the reify* functions take a value and a higher-rank expression/function; it 'reifies' the given value up to the type level, and within the function/expression you can 'reflect' it down to the value level using reflect
12:29:53 <illissius`> it's sort of like a reader monad
12:30:51 <illissius`> (just a lot fancier)
12:32:48 <mauke> implicit configurations: teleporting shit through the type system
12:33:16 <monochrom> at least not teleporting flies
12:34:06 <mauke> zomg transporter accidents
12:34:21 <magthe> illissius`: oki I'll have to spend some time with the paper I think... I just get the feeling that if reflect contained an example things would become clear a lot quicker
12:34:38 <EvanR> transporter psychosis
12:43:15 <illissius`> magthe: really simple example: reify "blablabla" (putStrLn <$> reflect)
12:43:19 <illissius`> prints blablabla
12:44:42 <illissius`> you need to use <$> and similar sugar because everything happens inside Tagged containers (which basically just add a phantom type), which are instances of Applicative and all the rest
12:44:52 <randomwords> luite: Are you around? I'm stucking with this gd stuff
12:45:27 <illissius`> reifyIntegral etc. are just specializations of 'reify' (though in fact reify is implemented using them), maybe they're faster but they don't add extra functionality
12:55:59 <magthe> illissius: sure, but how do I hook up this to a configuration?
12:56:16 <illissius> magthe: what do you mean?
12:56:37 <illissius> in the parlance of the paper, I think the 'configuration' is the value you reify/reflect
12:57:22 <illissius> so you can use it make configuration data available (again, like a reader monad), but the mechanism is more general so you can use it for whatever you want
12:57:59 <magthe> oki, but if I want to use it as a reader monad, how do I "populate it"?
12:58:18 <mauke> with reify
13:00:29 <magthe> so, 'reify foo (bar <$> reflect)' means that 'foo' is available in 'bar'... but then 'bar' will have to have a type (c -> a), where 'c' is the configuration... is that correct?
13:00:45 <illissius> bar is available inside the ()
13:00:49 <illissius> er
13:00:50 <illissius> foo is
13:00:55 <illissius> foo is available inside the () as reflect
13:01:19 <illissius> but it's wrapped in Tagged which is why you need combinators to manipulate it
13:03:09 <illissius> (you can use untag and manipulate it directly, but the final result of the function needs to be a Tagged... the type system ramifications of this are unclear to me atm, it'll likely complain about some things and not others)
13:03:45 <magthe> illissius: so 'reflect' is the Reader monad's 'ask', roughly speaking?
13:04:36 <illissius> right
13:05:39 <magthe> oki, then I'll have to play with it a bit to see how natural it is to write functions using it
13:05:39 <illissius> in fact you could make Tagged an instance of MonadReader if you didn't also have to define local (which doesn't seem to be possible)
13:06:20 <magthe> illissius: thanks for the clarifications
13:06:27 <illissius> (monadlib separates them into ReaderM and RunReaderM so you could do it there...)
13:06:35 <illissius> yw :)
13:06:55 <illissius> i went through pretty much the same "what the fuck is this shit" process a month or so ago
13:32:22 <chrisdone> type X = String
13:32:23 <chrisdone> type Y = String
13:32:23 <chrisdone> is there a type X, Y = String syntax or some such?
13:32:31 <mauke> no
13:32:39 <chrisdone> ;_;
13:32:51 <mauke> why do you need that?
13:32:57 <ezyang> Ye should be using newtypes anyway :-P 
13:33:34 <Phyx-> Ye should be using lisp!
13:33:40 <djahandarie> ezyang, nice tech talk btw
13:33:57 <chrisdone> ezyang made a google tech talk?
13:34:09 <djahandarie> Galois
13:34:26 <chrisdone> ah, that means it may or may not have an accompanying video online
13:34:29 <djahandarie> It does
13:34:34 <chrisdone> excellent
13:34:39 <djahandarie> http://vimeo.com/14432112
13:34:50 <ezyang> djahandarie: Thanks! 
13:35:05 <djahandarie> Yep. You're really good at presenting
13:35:16 <djahandarie> Is the second half recorded anywhere?
13:35:37 <ezyang> It was recorded but the sound was not working, so we decided to can it. 
13:35:43 * Phyx- expected mentioning lisp to be like throwing a grenade in here, but he's dissappointed
13:35:44 <ezyang> I posted annotated slides on my blog. 
13:35:48 <djahandarie> Ah. :(
13:35:50 <djahandarie> Okay
13:36:19 <mauke> Phyx-: this should be possible with plain cpp, actually
13:36:28 <orlandu63> ezyang: link?
13:36:33 <bos> you should dub in some techno music
13:36:38 <djahandarie> Haha
13:36:54 <Phyx-> mauke: lol, you can see that it's a weekend
13:37:15 <ezyang> http://web.mit.edu/~ezyang/Public/galois.pdf 
13:39:12 <djahandarie> ezyang, by the way, who was that person who asked the question about using a functional data structure and your reasons for using an imperative attack to the problem? His voice sounded familiar
13:39:27 <ezyang> That was John Launchbury. 
13:39:48 <ezyang> I actually have a follow up post to that (really good) question queued up for this Monday. 
13:40:09 <djahandarie> Oh okay I saw his talk about Conal's Differentiation
13:43:05 * shapr gives ezyang the Edward Tufte award for the day
13:44:34 <ezyang> \o/ 
13:47:43 <Phyx-> hmm, why does the Equality predicate "IfaceEqPred IfaceType IfaceType" take two types, I know equality if defined between two types, but the predicate only mentions one doesn't it?
13:48:08 <ezyang> Phyx-: What are you looking at? 
13:48:26 <Phyx-> ezyang: GHC's internal types
13:48:37 <Phyx-> IfaceType.IfacePredType to be exact
13:49:50 <lispy> Phyx-: I haven't looked at the code, but if the types are different then you already know they are not equal right?
13:51:07 <Phyx-> lispy: but I assume this structure is just a representation of the equality and doesn't actually check anything. As in it just represents the types
13:51:16 <roconnor_> ezyang: what's a miter?
13:51:20 <roconnor_> @wn miter
13:51:22 <lambdabot> *** "miter" wn "WordNet (r) 2.0"
13:51:22 <lambdabot> miter
13:51:22 <lambdabot>      n 1: joint that forms a corner; usually both sides are bevelled
13:51:22 <lambdabot>           at a 45-degree angle to form a 90-degree corner [syn: {miter
13:51:22 <lambdabot>           joint}, {mitre joint}, {mitre}]
13:51:24 <lambdabot> [8 @more lines]
13:51:29 <Phyx-> the same could be said that if the types are Equal, you wouldn't need to mention them 
13:51:44 <roconnor_> ezyang: what's a miter with respect to circuts?
13:51:49 <ezyang> roconnor_: Combination of two circuits, where the inputs are shared and the corresponding outputs are XORed together. 
13:51:55 <roconnor_> oh
13:52:04 <ezyang> Basically, the miter returns 0 if the circuits have the same outputs, and 1 if they differ. 
13:52:11 <roconnor_> ok
13:52:20 <ezyang> The terminology is unfortunately not very standard :-/ 
13:52:40 <Phyx-> lispy: my question rather comes down to, if you have a function foo :: (Eq a,Eq b) => a -> b -> Bool, I don't see how that's represented
13:53:15 <Phyx-> the whole predicate type representation confuses me, lol
13:53:37 * roconnor_ finds it odd that networks are built impertively, but continues reading
13:59:31 <roconnor> ugh
13:59:57 <roconnor> binding foreign functions seems even harder than making nix packages.
14:00:07 <roconnor> I'm glad I haven't done such work.
14:00:12 <mauke> ... and in the darkness bind them
14:00:17 <roconnor> stupid non-thread safe C libaries
14:01:32 <ezyang> Its dastardly complicated and buggy. 
14:01:55 <ezyang> Especially if you dont even know if the C library works properly either. 
14:02:07 <roconnor> presumably making networks is imperitive because that is how the C library made networks.
14:02:21 <ezyang> Yep. 
14:02:31 <ezyang> "Well, you don't really have a choice if you're writing in C..." 
14:21:07 <chrisdone> > withDB $ execDDL $ cmdbind "insert into paste (title,content,tags,author,language,channel) values ('','','','',?,1)" [bindP (1::Integer)]
14:21:08 <chrisdone> *** Exception: DBError ("42","804") 7 "ERROR:  42804: column \"language\" is of type integer but expression is of type text\nLINE 1: ...tent,tags,author,language,channel) values ('','','','',$1,1)\n                                                                  ^\nHINT:  You will need to rewrite or cast the expression.\nLOCATION:  transformAssignedExpr, parse_target.c:472\n"
14:21:14 <chrisdone> do I need to write ?::integer ?
14:22:35 <hpc> ::Int
14:22:44 <hpc> SQL can't do unbound numbers
14:22:49 <hpc> i think
14:23:06 <chrisdone> if that was true why is there a bindP instance for Integer?
14:23:27 <hpc> :t bindP
14:23:28 <lambdabot> Not in scope: `bindP'
14:23:43 <chrisdone> bindP :: (DBBind a sess stmt bo) => a -> BindA sess stmt bo
14:24:15 <hpc> yikes; so bindP turns a haskell thing into an SQL thing?
14:24:26 <chrisdone> ja
14:24:45 <chrisdone> well, 1::Int works
14:24:47 <hpc> it could just be that Integer's instance makes a string
14:24:53 <chrisdone> I suppose Integer just shows a string
14:25:36 <hpc> what an ugly SQL interface though; haskell can surely do better than that
14:26:49 <chrisdone> haskelldb's is pretty nice
14:27:29 <chrisdone>   insert DM.imanuscript $
14:27:29 <chrisdone>       (DM.submission  <<$ sid)
14:27:29 <chrisdone>     # (DM.filename    <<$ filename)
14:27:29 <chrisdone>     # (DM.contentType <<$ content_type)
14:27:37 <chrisdone> but, I'd prefer a Typeable-based one
14:27:44 <hpc> it's a shame that databases can be programatically ALTER'd, or you could write a library in such a way that query errors can be caught at compile time
14:28:16 <chrisdone> well, you can still do that
14:28:31 <chrisdone> just because it can fail, it's still useful
14:33:03 <kevinburke> Hi, my name's kevin, just starting out with haskell and actually this is the first time I've used IRC, too
14:33:37 <Zao> Hello there, laddy.
14:33:49 <Jafet> Good, the next easy step is to provide us your billing details
14:34:17 <aristid> We accept Visa, Mastercard and traveller's cheques.
14:34:28 <chrisdone> Hi Kevin, welcome to Haskellers Anonymous
14:34:41 <kevinburke> I charge you guys right? For the privilege of me being in this chatroom?
14:34:59 <aristid> close
14:35:07 <mauke> it's a channel, not a chatroom
14:35:11 <Zao> kevinburke: You're surfing long distance, by the way.
14:35:34 * benmachine hugs kevinburke 
14:35:34 <kevinburke> Channel, sorry
14:35:52 <zolika> benmachine
14:35:56 <zolika> :O
14:35:56 <benmachine> I have nothing else to add to this discussion, only random affection
14:35:56 <chrisdone> get off mauke's lawn^]^]^]^]unix beard
14:36:02 <benmachine> zolika: :O is that you
14:36:06 <zolika> yes
14:36:09 <zolika> dD
14:37:49 <kevinburke> I'm working on the problems in the O'Reilly book
14:38:15 <kevinburke> here's the problem: Define a function that takes a list of 2D points and computes the direction of each successive triple. Given a list of points [a,b,c,d,e], it should begin by computing the turn made by [a,b,c], then the turn made by [b,c,d], then [c,d,e]. Your function should return a list of Direction. 8 comments
14:38:32 <kevinburke> data Direction = Left | Right | Straight
14:38:32 <kevinburke> --problem 11:
14:38:33 <kevinburke> data Point = Pt {pointx, pointy :: Float}
14:38:33 <kevinburke> getDirectionList :: [Point] -> [Direction]
14:38:33 <kevinburke> getDirectionList (a:b:c:xs) = 
14:38:57 <kevinburke> I'm curious - how would I get the x and y coordinates for each of a, b, and c? an inline function?
14:39:11 <mauke> pointx and pointy are functions
14:40:06 <Twey> kevinburke: The syntax may be a little misleading
14:40:20 <Twey> kevinburke: After defining that record, pointx, pointy :: Point -> Float
14:40:46 <Twey> kevinburke: (please pastebin code of more than a couple of lines)
14:41:01 <kevinburke> how do you pastebin code?
14:41:09 <mauke> @paste
14:41:09 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:41:17 <Twey> hpaste.org is down again?
14:41:19 <mauke> bah
14:41:22 <Twey> Bah
14:41:29 <kevinburke> @paste
14:41:29 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:41:36 <mauke> try http://codepad.org/
14:41:36 <Twey> moonpatio too
14:41:37 <dolio> hpaste.org
14:41:44 <Twey> dolio: Dead
14:41:50 <dolio> Ah, damn.
14:42:04 <dolio> Moonpatio's been gone for a while.
14:42:22 <kevinburke> http://codepad.org/F0p8DQub
14:43:16 <Twey> @where+ paste http://hpaste.org/ http://codepad.org/
14:43:16 <lambdabot> Good to know.
14:43:19 <Twey> @where paste
14:43:19 <lambdabot> http://hpaste.org/ http://codepad.org/
14:43:32 <Twey> Well, I didn't mean to overwrite moonpatio is it gone for good?
14:43:54 <mauke> overwrite?
14:44:09 <Zao> mauke: Clobber @paste
14:44:12 <dolio> Twey: mmorrow's been gone for a long time, and it was his website.
14:44:23 <mauke> @paste
14:44:23 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:44:32 <Twey> Ah.  I'll leave it overwritten, then.
14:44:37 <mauke> what
14:44:37 <Twey> Oh, right.  Different command.
14:44:41 <Zao> Err, @where paste, that is.
14:45:28 <Twey> kevinburke: If you had a data Direction = Direction String, and say that Direction "n" represents north, and Direction "s" represents south, what do you do when someone inputs Direction "flib"?
14:45:43 <lispy> :t (***) -- what does this one do?
14:45:44 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:46:06 <lispy> > id *** reverse $ [1..5]
14:46:07 <lambdabot>   Couldn't match expected type `(b, [a])'
14:46:07 <lambdabot>         against inferred type `[a1]'
14:46:27 <mauke> > (sqrt *** show) (2, 'x')
14:46:28 <lambdabot>   (1.4142135623730951,"'x'")
14:46:31 <lispy> :t execState
14:46:32 <lambdabot> forall s a. State s a -> s -> s
14:46:49 <mauke> > (f *** g) (x, y)
14:46:49 <lambdabot>   Ambiguous type variable `c' in the constraints:
14:46:49 <lambdabot>    `GHC.Show.Show c'
14:46:49 <lambdabot>      a...
14:46:49 <lispy> :t id *** reverse
14:46:50 <lambdabot> forall b a. (b, [a]) -> (b, [a])
14:46:50 <hpc> @hoogle State s a -> s -> (s, a)
14:46:51 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
14:46:51 <lambdabot> Control.Monad.State.Strict runState :: State s a -> s -> (a, s)
14:46:53 <lambdabot> Data.Graph.Inductive.Graph lpre :: Graph gr => gr a b -> Node -> [(Node, b)]
14:47:03 <mauke> > (f *** g) (x, y) :: (Expr, Expr)
14:47:04 <lambdabot>   (f x,g y)
14:47:18 <lispy> mauke: thanks
14:47:44 <Twey> kevinburke: Please talk in the channel.
14:48:03 <mauke> the trick is to read Arrow a as ->
14:48:28 <lispy> it needs to be an infix type variable
14:48:42 <kevinburke> Sorry I thought that the "Twey: kevinburke:" messages were private
14:49:16 <kevinburke> mauke: so I could say pointx a to get the x coord for Point a?
14:49:21 <mauke> yes
14:49:40 <Twey> kevinburke: They aren't: that's just a convention to indicate the intended recipient of a message.
14:50:21 <kevinburke> Okay
14:50:35 <kevinburke> how do you keep channel threads separate?
14:50:45 <mauke> manually
14:51:22 <kevinburke> i mean like if I'm asking a question and lispy's asking a question, is there any way to filter the replies or is it all just jumbled in
14:51:37 <mauke> there's nothing in the protocol, so it depends on your client
14:51:59 <lispy> kevinburke: don't worry.  I ask lots of questions so you'll get used to it :)
14:52:03 <mauke> mine doesn't offer any filter like that
14:52:19 <kevinburke> Okay
14:52:20 <lispy> kevinburke: but, lambdabot is probably the noisiest here, so you could ignore her if it bothers you
14:52:30 <mauke> we are all part of the hive mind
14:54:38 <Jafet> Keep channel threads separate? I had to do that the time I telnetted to freenode
14:54:46 <mauke> hah
14:54:46 <lispy> kevinburke: and by ignore, I mean the "/ignore" command
14:55:08 <mauke> Jafet: intra, not inter
15:00:56 <hpc> i trained myself to read faster and now i have no problem following the channel
15:02:19 <Nibble> hpc: I trained the channel to write slower
15:02:26 <Nibble> and now I have no problem following the channel
15:02:28 <kevinburke> Cool
15:02:31 <hpc> XD
15:03:15 <Mitar> how can i lift bracket to my own monad based on IO?
15:03:34 <lowasser1> depends on the monad =P
15:03:57 <Veinor> my IRC client colors nicks, and I installed a plugin that colors nicks in actual chat text as well. so if there's a conversation between two people, I'll see their colors together
15:04:25 <opqdonut> the only colours I see in my IRC atm are black and white
15:04:37 <opqdonut> oh, drat, now some red
15:04:49 <Mitar> StateT MyState IO
15:04:52 * mauke boings
15:04:53 <opqdonut> (my own lines are tastefully highlighted)
15:04:56 <siracusa> Veinor: What client are you using?
15:05:10 <mauke> siracusa: WeeChat
15:05:30 <mauke> and you're using ChatZilla
15:05:35 <Veinor> anybody who says my name gets a bright pink background so I can see it :D
15:05:50 <siracusa> mauke: How do you know?
15:06:05 <mauke> siracusa: I sent you a ctcp version request
15:06:26 <LearningHaskell> Q: About simple delta encoding of ascending nums ( eg [20,18,10] need to become [20,2,8] - n0=n0,n1=n0-n1,n2=n2-n1  how to write this? for func d_enc :: [Int] -> [Int]
15:06:28 <Mitar> how can i lift bracket to my own monad based on IO?, where I have defined my monad as StateT MyState IO
15:08:58 <Botje> LearningHaskell: the idea is to walk the list two times simultaneously
15:09:07 <mauke> shouldn't that be -20?
15:09:12 <Botje> with one of the two offset by one
15:10:07 <Veinor> > let deltaEncode xs = zipWith (-) xs (0:tail xs) in deltaEncode [20,18,10]
15:10:08 <lambdabot>   [20,0,0]
15:10:12 <Veinor> whoops.
15:10:47 <mauke> > ap (zipWith (-)) tail . (0 :) $ [20,18,10]
15:10:47 <lambdabot>   [-20,2,8]
15:11:00 <LearningHaskell> mauke: since it's ascending it assumed to be (-) so 20,18,10 becomes 20,20-18=2,18-10=8
15:11:13 <mauke> LearningHaskell: if you descend 20 from nothing, you get -20
15:11:53 <Veinor> > let deltaEncode xs = zipWith (-) (head xs:xs) xs in deltaEncode [20,18,10]
15:11:53 <LearningHaskell> mauke: so the head() must be cut off and use the 2nd list to complement?
15:11:54 <lambdabot>   [0,2,8]
15:12:11 <Veinor> > let deltaEncode xs = zipWith (-) (head xs:xs) (0:tail xs) in deltaEncode [20,18,10]
15:12:12 <lambdabot>   [20,2,8]
15:12:16 <mauke> LearningHaskell: what?
15:12:46 <mauke> > let deltaEncode xs = zipWith (-) (head xs * 2:xs) xs in deltaEncode [20,18,10]
15:12:46 <lambdabot>   [20,2,8]
15:13:12 <LearningHaskell> Veinor/Botje/mauke thank you for the suggested solutions :)
15:13:41 <LearningHaskell> going to nibble on that
15:13:51 <mauke> > ap zip tail . (0 :) $ [20,18,10]
15:13:52 <lambdabot>   [(0,20),(20,18),(18,10)]
15:14:12 <Nibble> > :t ap
15:14:13 <lambdabot>   <no location info>: parse error on input `:'
15:14:22 <Mitar> anyone?
15:14:46 <mauke> :t ap
15:14:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:15:18 <aristid> > (zip<*>tail)[0,20,18,10]
15:15:19 <lambdabot>   [(0,20),(20,18),(18,10)]
15:15:38 <mauke> @quote p`a
15:15:38 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
15:15:54 <opqdonut> @quote `
15:15:54 <lambdabot> LoganCapaldo says: > let sprinkle = intersperse ; on = id ; stars = '*' in sprinkle stars `on` "the sky"
15:16:27 <aristid> > let sprinkle = intersperse ; on = id ; stars = '*' in sprinkle stars `on` "the sky"
15:16:29 <lambdabot>   "t*h*e* *s*k*y"
15:16:38 <aristid> hahaha
15:16:43 <LearningHaskell> lol
15:16:52 <mauke> @quote ix.er
15:16:52 <lambdabot> Berengal says: I was squashing a bug, got frustrated, and typed "fix error" in ghci...
15:16:58 <mauke> @quote ix.er
15:16:58 <lambdabot> mauke says: a hint to beginners: typing 'fix error' in ghci does not have the intended  effect
15:17:09 <Nibble> hehe
15:17:18 <chrisdon`> fix er? I hardly know'er!
15:18:39 <randomwords> What's the syntax for including more than one directory with --extra-include-dirs?
15:19:33 <lispy> is mtl's Control.Monad.State strict or lazy?
15:19:57 <olsner> it has both, doesn't it?
15:20:10 <lispy> olsner: AFAIK
15:20:23 <lispy> olsner: so I was curious about Control.Monad.State ( State )
15:23:33 <orbital_fox> list comprehansion is sexy ;D
15:26:06 <aristid> orbital_fox: wait till you discover that do-syntax can be used for the same purpose
15:26:27 <orbital_fox> :)
15:26:35 <orbital_fox> maybe tomorrow though :P
15:26:48 <Nibble> indeed
15:27:00 <Nibble> list comprehension is almost never the simplest solution
15:27:25 <Nibble> length' xs = sum ([ 1 | x <- xs, (tail xs) /= []])
15:27:28 <Nibble> like that one
15:27:36 <wli> monad comprehension would be nice to have back
15:27:54 <chrisdone> indeed
15:29:16 <orbital_fox> well im calling it a night
15:29:19 <orbital_fox> gnight ppl
15:29:56 <Mitar> how can i lift bracket to my own monad based on IO?, where I have defined my monad as StateT MyState IO
15:30:10 <Mitar> :t lift bracket
15:30:11 <lambdabot> Not in scope: `bracket'
15:30:33 <Mitar> :t lift Control.Exception.bracket
15:30:35 <lambdabot> forall a b c (t :: (* -> *) -> * -> *). (MonadTrans t) => t ((->) (IO a)) ((a -> IO b) -> (a -> IO c) -> IO c)
15:31:04 <benmachine> :t \acq act rel -> liftIO $ acq act rel
15:31:05 <lambdabot> forall t t1 a (m :: * -> *). (MonadIO m) => (t -> t1 -> IO a) -> t -> t1 -> m a
15:31:15 <benmachine> oh whoops
15:31:21 <benmachine> :t \acq act rel -> liftIO $ bracket acq act rel
15:31:22 <lambdabot> Not in scope: `bracket'
15:31:30 <benmachine> :t \acq act rel -> liftIO $ Control.Exception.bracket acq act rel
15:31:31 <lambdabot> forall a (m :: * -> *) a1 b. (MonadIO m) => IO a1 -> (a1 -> IO b) -> (a1 -> IO a) -> m a
15:32:19 <randomwords> I'm trying to install gd bindings for windows and I get this error, Could not find module `Data.ByteString.Base', seems odd
15:33:56 <lispy> Mitar: I think monadIO on hackage already provides bracket in terms of MonadIO
15:34:21 <Mitar> benmachine: i think this is not ok
15:34:43 <LearningHaskell> off to bed
15:34:53 <Mitar> type should be MyMonadBasedOnIO a1 -> (a1 -> MyMonadBasedOnIO b) -> (a1 -> MyMonadBasedOnIO a) -> MyMonadBasedOnIO a
15:35:40 <lispy> Mitar: that's too specific for most stuff.  Why not use the MonadIO class?
15:36:06 <lispy> Mitar: just make MyMonadBasedOnIO an instance of MonadIO
15:36:33 <Mitar> i am checking MonadIO and i am not sure what it is?
15:36:36 <hpc> :t bracket
15:36:37 <lambdabot> Not in scope: `bracket'
15:36:49 <lispy> Mitar: it's a type class for monads that can do IO
15:36:58 <lispy> Mitar: it provides liftIO
15:37:14 <hpc> liftIO :: IO a -> m a
15:37:39 <Mitar> but i already use liftIO?
15:37:46 <Mitar> :t liftIO
15:37:47 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
15:37:53 <lispy> Mitar: separate from MonadIO is a package on hackage called monadIO that provides wrappers around all the normal IO primitives but with MonadIO instead of IO
15:38:34 <hpc> is there an instance MonadIO IO where liftIO = id?
15:38:43 <lispy> hpc: yeah
15:39:00 <hpc> yay
15:39:01 <Mitar> http://hackage.haskell.org/package/monadIO << this is for concurency?
15:39:19 <hpc> no
15:39:23 <hpc> it's a type convenience
15:39:33 <lispy> Mitar: It was developed to make Orc simpiler.  But, it works for non-nocurrency stuff too
15:40:48 <lispy> Mitar: oh, maybe monadIO doesn't have bracket yet
15:41:15 <Mitar> i also cannot find it
15:41:22 <lispy> :t \acq act rel -> bracket (liftIO acq) (liftIO act) (liftIO rel)
15:41:22 <lambdabot> Not in scope: `bracket'
15:41:32 <lispy> :t \acq act rel -> Control.Exception.bracket (liftIO acq) (liftIO act) (liftIO rel)
15:41:32 <lambdabot> forall a b c. (MonadIO ((->) a)) => IO a -> IO (IO b) -> IO (IO c) -> IO c
15:41:44 <lispy> hehe, that didn't work
15:41:48 <lispy> :t liftIO
15:41:49 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
15:42:32 <lispy> maybe you can't write bracket this way
15:44:09 <Phyx-> hrm... well that can't be right... entire base indexed in 13.9kb
15:44:14 <Mitar> hmm
15:44:37 <Mitar> that is strange that i cannot use bracket in my own monad?
15:44:58 <lispy> Mitar: on actually that should still be fine
15:45:10 <lispy> Mitar: but you would definitely need to liftIO it
15:45:25 <Mitar> i am trying, but it does not work
15:45:31 <Mitar> liftIO bracket is not the right one
15:45:33 <lispy> :t \a b c -> liftIO (Control.Exception.bracket a b c)
15:45:33 <lambdabot> forall a b a1 (m :: * -> *). (MonadIO m) => IO a -> (a -> IO b) -> (a -> IO a1) -> m a1
15:46:04 <Mitar> this changes only the result type
15:46:15 <aristid> :t bracket
15:46:16 <lambdabot> Not in scope: `bracket'
15:46:24 <aristid> :t Control.Exception.bracket
15:46:25 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:46:49 <Mitar> i would need MyMonadBasedOnIO a -> (a -> MyMonadBasedOnIO b) -> (a -> MyMonadBasedOnIO c) -> MyMonadBasedOnIO c
15:47:08 <lispy> Mitar: Well, your (a -> MyMonadbasedOnIO b), might need to have 'a' applied and then run to get IO b
15:47:09 <malorie> I'm just starting out with haskell, and a (probably rather simple) question arose: how'd I do something like ['A'..'Z','a'..'z']?
15:47:22 <lispy> Mitar: and the way you do that depends on MyMonadBasedOnIO
15:47:23 <Mitar> type MyMonadBasedOnIO = StateT MyState IO
15:47:30 <opqdonut> malorie: ['A'..'Z']++['a'..'z']
15:47:31 <aristid> > ['A'..'Z'] ++ ['a'..'z']
15:47:32 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
15:47:37 <lispy> so you need like, execState
15:47:41 <aristid> opqdonut: you type faster than me oO
15:47:48 <opqdonut> I felt slow
15:48:01 <hpc> you can write bracket for MonadError
15:48:28 <malorie> opqdonut, aristid: ah. makes sense. would it be possible to do it somehow with (:) and fmap, or something the like, too?
15:48:29 <Mitar> but execState will make all initial states which are used in act and rel the same
15:49:05 <hpc> > ['a'..'Z']
15:49:06 <lambdabot>   ""
15:49:09 <aristid> > fmap id (['A'..'Z']++['a'..'z'])
15:49:10 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
15:49:15 <aristid> malorie: there, using fmap.
15:49:16 <hpc> > ['A'..'z']
15:49:17 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
15:49:21 <malorie> aristid: heh
15:49:29 <hpc> ASCII D:
15:49:33 <lispy> Mitar: all I'm saying is that you need to provide a function that is roughly: MyMonadBasedOnIO a -> IO a
15:49:41 <hpc> er, unicode D:
15:49:49 <aristid> > filter isLetter [minBound .. maxBound]
15:49:50 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\1...
15:50:01 <aristid> malorie: how bout that? also give unicode letters
15:50:11 <lispy> > [minBound .. maxBound] :: String
15:50:12 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
15:50:18 <lispy> that's kind of cool
15:50:36 <siracusa> > length ([minBound .. maxBound] :: String)
15:50:37 <lambdabot>   1114112
15:51:00 <geheimdienst> > 2^21
15:51:01 <lambdabot>   2097152
15:51:15 <geheimdienst> > 2^20
15:51:16 <lambdabot>   1048576
15:51:56 <geheimdienst> i thought unicode was effectively a 21-bit encoding ...
15:51:57 <monochrom> > text "\181"
15:51:58 <lambdabot>   
15:52:03 <malorie> ['a'..'z'] does, generally speaking, not guarantee to produce the list which contains a-z, due to the underlying characterset, right?
15:52:27 <lispy> malorie: I think for 'a' and 'z' it does
15:52:46 <lispy> malorie: but I could be wrong
15:52:46 <megajosh2> What kind of insane character set would have it any other way? :O
15:52:47 <monochrom> the underlying character set is unicode and this is decreed by haskell 98 and haskell 2010.
15:52:49 <hpc> i think a-z and A-Z are required to be continuous
15:52:55 <arw> megajosh2: EBCDIC
15:53:00 <hpc> in modern character sets
15:53:03 <geheimdienst> the underlying character set is unicode ... Char and String are unicode
15:53:08 <arw> megajosh2: the alphabet is non-continuous in EBCDIC
15:53:10 <monochrom> EBCDIC does not comply to haskell 98
15:53:14 <megajosh2> HEATHENS
15:53:17 <hpc> and typically upper and lower case vary by a single bit
15:53:31 <aristid> "modern character sets", hah
15:53:41 <aristid> all the different unicode encodings? ;)
15:53:42 <hpc> relatively speaking
15:53:55 <benmachine> malorie: so in answer to your question, ['a' .. 'z'] is in fact required to produce the alphabet
15:54:01 <aristid> well multiword utf-16 is pretty new actually
15:54:02 <benmachine> because haskell is clever
15:54:05 <malorie> lispy: iirc, there are character sets, which does not lay out the alphabetic characters in a consecutive order ...
15:54:19 <monochrom> This is haskell not c.
15:54:19 <geheimdienst> multiword utf-16 wtf?
15:54:52 <malorie> monochrom: of course. but ['A' .. 'z'] also gives me "unwanted" characters, due to ascii
15:54:55 <trounce> shadowing has just confused the heck out of em
15:55:00 <trounce> I dont get it
15:55:18 <trounce> and whats up with this 'in' expression
15:55:31 <notabel> geheimdienst: the Unicode code space is more than 16 bits wide now; UCS-4 is the only strictly-single-word encoding
15:55:43 <monochrom> ['A' .. 'z'] is unrelated to ['a'..'z']. what is your point?
15:56:03 <aristid> monochrom: there's no particular reason to expect A-Z and a-z to be continuous
15:56:18 <monochrom> I have just said the reason.
15:56:33 <aristid> i meant malorie
15:56:41 <geheimdienst> notabel, okay yeah. i knew that as the whole surrogate pair story. apparently some people call it "multiword" ..
15:56:44 <monochrom> RTFM http://www.haskell.org/onlinereport/haskell2010/
15:56:46 <malorie> aristid: which is what I said
15:57:01 <aristid> heh
15:57:26 <malorie> but yeah. probably doesn't matter _that_ much. thanks, though, for the input concerning my initial question.
15:57:27 <aristid> geheimdienst: i mean non-BMP characters
15:57:34 <Adamant> don't get monochrom started on i18n issues
15:57:45 <notabel> some people use "multiword" to distinguish more directly between UCS-2 (which is 16 bits come hell or high water, and only covers BMP) and UTF-16 (with surrogate pairs)
15:58:48 <aristid> > rangeSize (minBound :: Char, maxBound) >= 2^16
15:58:48 <lambdabot>   True
15:58:55 <Zao> I still have mixed feelings about people who call non-BMP codepoints "ethereal"
15:59:14 <geheimdienst> i thought it was called astral
15:59:24 <Zao> geheimdienst: Probably.
15:59:26 <aristid> and because that range is bigger than 2^16, utf-16 is a multiword encoding.
15:59:28 <Zao> I can't even remember the term :D
15:59:35 <aristid> bigger than 2^16-1
16:00:09 <arw> Zao: well, astral plane :)
16:00:12 <notabel> astral it was
16:00:22 <arw> Zao: as opposed to basic multilingual plane.
16:00:24 <trounce> nvm
16:00:40 <Zao> arw: I don't quite see the connection between BMP and "astral".
16:01:02 <notabel> Zao: the astral plane is the one above this one, where all the real stuff exists
16:01:02 <monochrom> "astral plane"
16:01:17 <monochrom> no, where all the ghostly stuff happens
16:01:18 <megajosh2> @src Data.Map
16:01:19 <lambdabot> Source not found. Sorry.
16:01:22 <megajosh2> :C
16:01:23 <geheimdienst> zao, check out this: http://en.wikipedia.org/wiki/Plane_(Dungeons_%26_Dragons)#Astral_Plane
16:01:39 <Zao> The only association I get for "astral" is "meh, stars"
16:01:44 <notabel> monochrom: yeah, my antecendents didn't really line up too clearly :-)
16:02:52 <geheimdienst> > (maxBound :: Char) == (17 * 2^16)
16:02:53 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
16:02:53 <lambdabot>    arising from the literal `1...
16:03:06 <geheimdienst> > (maxBound :: Char)
16:03:07 <lambdabot>   '\1114111'
16:03:16 <geheimdienst> > ord (maxBound :: Char)
16:03:17 <lambdabot>   1114111
16:03:26 <geheimdienst> > ord (maxBound :: Char) == (17 * 2^16)
16:03:27 <lambdabot>   False
16:03:33 <monochrom> > text "\1114111"
16:03:34 <lambdabot>   
16:03:46 <geheimdienst> > 17 * 2^16
16:03:47 <lambdabot>   1114112
16:04:14 <geheimdienst> i'm bumbling my way through this
16:04:32 <geheimdienst> anyhoo, unicode is 17 planes with 16 bits each (65536 characters)
16:05:10 <monochrom> > text "\x3b1"
16:05:10 <lambdabot>   
16:05:42 <Phyx-> does Binary do any compression?
16:05:49 <monochrom> no
16:06:03 <Phyx-> then how the heck is it fitting all that data in
16:06:48 * Phyx- adds a few trace calls
16:07:06 <monochrom> by not using less space than you expect
16:07:27 <monochrom> fitting a 32-bit word into 32 bits is hardly compression
16:07:43 <Phyx-> no, I think the answer is, we have a bug Z
16:08:04 <monochrom> what is bug Z?
16:08:21 <Phyx-> i was (unsuccessfully) quoting men in black
16:08:37 <Phyx-> it's not encoding every module, it seems to be picking only the first from every package
16:09:19 <monochrom> IOW PEBKAC?
16:09:40 <monochrom> that explains all paranormal phenomena
16:09:45 <Phyx-> lol
16:10:22 <Phyx-> it seems my sorting is..it seems my "sorting" is deleting stuff
16:10:35 <Phyx-> sortBy (compare `on` toFilePath . fst . fst) $ zip a doc
16:10:43 <Phyx-> seems to be only returning 1 element everytime
16:11:23 <hpc> :t sortBy (compare `on` toFilePath . fst . fst) $ zip
16:11:24 <lambdabot> Not in scope: `toFilePath'
16:11:37 <benmachine> sortBy won't change the length of the list, I think
16:11:43 <sshc> Does do notation work with MonadLib?
16:11:52 <benmachine> yes
16:11:58 <megajosh2> Doesn't do notation work with every monad?
16:12:02 <hpc> do notation works with all monads...
16:12:10 <hpc> and regular values too
16:12:11 <hpc> > do 5
16:12:12 <lambdabot>   5
16:12:40 <randomwords> Is anyone in the process of writing a pure haskell png encoder?
16:13:09 <aristid> > do "make me a sandwich"
16:13:10 <Phyx-> benmachine: it shouldn't, but the length of the in.... oh god, it's zip!
16:13:10 <lambdabot>   "make me a sandwich"
16:13:10 <randomwords> Because at this point I think it's going to be faster for me to write one from scrach than to get any existing wrappers to work..
16:13:28 <roconnor> randomwords: I started one 5 years ago, but never went very far
16:13:28 <benmachine> Phyx-: :)
16:13:36 <aristid> > sudo "make me a sandwich"
16:13:37 <lambdabot>   Not in scope: `sudo'
16:13:43 <hpc> png isn't a fun standard
16:13:45 <roconnor> I did learn that string IO sucks
16:13:47 <megajosh2> Unpermitted side effect
16:14:05 <hpc> @let sudo = id
16:14:06 <lambdabot>  Defined.
16:14:10 <megajosh2> lol
16:14:11 <randomwords> So is it infeasable?
16:14:21 <roconnor> randomwords: you have bytestring IO today
16:14:24 <roconnor> you are good
16:14:38 * Phyx- tries again
16:14:38 <Osvald> anyone could help me on this, I have a  type Vec = [Int] and type Mat = [[Int]], matrix and vector and need a VecMult::Vec->Mat->Vec to multiply both
16:14:40 <randomwords> Right, I'll get on it then.
16:14:49 <aristid> @let sudo = const "It will be observed."
16:14:49 <lambdabot>  <local>:4:0:
16:14:49 <lambdabot>      Multiple declarations of `L.sudo'
16:14:49 <lambdabot>      Declared at: <local...
16:15:00 <benmachine> @undefine
16:15:29 <hpc> @let sudo = const "Eh, maybe later."
16:15:30 <lambdabot>  Defined.
16:15:31 <hpc> :D
16:16:01 <chrisdone> the configfile library is great
16:16:09 <randomwords> roconnor: Do you still have the 5-year old code?
16:16:23 <Phyx-> ah, this looks much much better
16:16:28 <megajosh2> Osvald: I saw an example of multi-parameter typeclasses being used for that I think
16:16:34 <roconnor> randomwords: more or less no
16:16:35 <Phyx-> all files are in the mb range instead of the kb range
16:16:43 <sshc> Why should I use mtl instead of MonadLib?
16:17:00 <benmachine> sshc: it's in the haskell platform
16:17:03 <roconnor> sshc: you shouldn't
16:17:14 <Phyx-> hmm, 8.8mb to index base
16:17:25 <roconnor> sshc: the mtl is has several bugs
16:17:32 <benmachine> I think MonadLib's names are uglier >_>
16:17:44 <benmachine> you can use transformers though!
16:17:48 <benmachine> and monads-tf or something
16:18:10 <Osvald> megajosh2: thx, shouldn't be hard I think, I'm having hard times on this
16:18:11 <sshc> How well supported is MonadLib?
16:18:43 <roconnor> I think it is used at Galois Inc.
16:19:03 <megajosh2> Osvald: It's on this page
16:19:10 <megajosh2> ?wiki Functional_dependencies
16:19:10 <lambdabot> http://www.haskell.org/haskellwiki/Functional_dependencies
16:19:19 <megajosh2> Wait no... it isn't plural is it?
16:19:25 <roconnor> [19:16] <benmachine> sshc: it's in the haskell platform   -- this is why I hate the Haskell Platform
16:19:25 <megajosh2> Oh it's a redirect
16:19:59 <sshc> roconnor: Why would you hate the Haskell Platform for including MonadLib?
16:20:31 <benmachine> Osvald: if you're only using Ints in your matrices, you won't need type classes
16:20:35 <benmachine> or functional dependencies
16:20:47 <Osvald> yeah, I just got there when you had mentioned multiparameters
16:20:57 <Osvald> yeah, only ints
16:21:07 <roconnor> I would still hate the Haskell Platform but including MonadLib would make the problems with it more opaque.
16:21:11 <sshc> I don't understand how callCC works
16:21:29 <sshc> roconnor: Why would you still hate it?
16:21:33 <roconnor> sshc: it is tricky
16:22:08 <Osvald> megajosh2: what do you think then? can be very simple, right?
16:22:19 <sshc> roconnor: What doy ou mean?
16:22:22 <sshc> And why don't you like its including MonadLib?
16:22:40 <roconnor> sshc: because it would still in generaly lead people to probably use suboptimal libraries.
16:22:43 <Osvald> for a vecMult::Vec->Mat->Vec
16:22:44 <megajosh2> Osvald: I actually don't understand functional dependencies, but it might be if they use that as a way to solve that example
16:24:23 <roconnor> sshc: It's not the contents of the HP I dislike so much, it is the whole idea of the HP I dislike.  The fact that HP can and will (and currently does) contain bad libraries and the effect of this is what I don't like about HP.
16:24:43 <aristid> roconnor: do you see a superior alternative to the haskell platform?
16:24:44 <roconnor> sshc: the HP is a bad solution to a packaging problem we are experiencing
16:25:10 <sshc> roconnor: Do you consider MonadLib a bad package?
16:25:38 <roconnor> though monochrom says there is not really a packaging problem.
16:25:58 <roconnor> sshc: MonadLib isn't a bad package, but it probably isn't perfect.
16:26:10 <Phyx-> is there a way to in ghci redirect anything printed?
16:26:17 <tibbe> roconnor: the hope is that HP will eventually increase quality of libraries. It hasn't happened yet cause no new libraries have been considered yet. The current set was adopted from ghc extra libs to take that burden of the simons
16:26:21 <aristid> it certainly isn't perfect. nothing in haskell is perfect.
16:26:35 <benmachine> Phyx-: yes, but iirc it's messy
16:26:53 <sshc> roconnor: Isn't it better than mtl?
16:26:53 <Phyx-> :/
16:26:57 <roconnor> tibbe: I think HP is decreasing the quality of libraries.
16:27:05 <sshc> Also, wehre's the State monad in MonadLib?
16:27:06 <roconnor> sshc: It is waaaaaaaaay better than the mtl
16:27:12 <tibbe> roconnor: that would be unfortunate
16:27:13 <Phyx-> benmachine: i have a dew Debug.trace i want to see but there's alot, my console buffer won't take it
16:27:28 <geheimdienst> roconnor, how does it decrease quality?
16:27:28 <tibbe> roconnor: it's meant as a vehicle for code and design reviews
16:27:31 <roconnor> sshc: all the basic monads are in one module IIRC
16:27:40 <benmachine> Phyx-: the obvious solution is to implement it in the trace itself :)
16:27:57 <benmachine> Phyx-: you could for example use unsafePerformIO to communicate with a 'tracing thread'
16:28:00 <tibbe> roconnor: the current members didn't receive one due to grandfathering but all future packages will
16:28:01 <benmachine> and filter there
16:28:05 <por> If I have a data type intended for a particular use, but which I only want used in certain ways, what would be the best way to limit access to the data type? (Can I give more than a type signature with records?)
16:28:15 <benmachine> Phyx-: runhaskell | grep would be my next choice
16:28:19 <randomwords> roconnor: Sorry to keep bothering you, any ideas on good resources (other than the standard itself)?
16:28:24 <roconnor> geheimdienst: because people, including but not limited to benmachine, are suggesting that mtl's inclusion in HP is a reason to use it over MonadLib, despite it being an inferiour buggy library.
16:28:26 <benmachine> Phyx-: but what you want to do can be done in haskell, I just can't remember exactly how
16:28:35 <roconnor> randomwords: the standard is pretty good IIRC.
16:28:38 <sioraiocht> Arnar: ping?
16:28:46 <roconnor> randomwords: It was my primary resource.
16:28:49 <benmachine> roconnor: fwiw I don't necessarily think you should use mtl, just that it might be worth considering that
16:28:51 <sshc> Ah, I see
16:28:56 <sshc> But how does MonadLib work with IO?
16:29:01 <roconnor> benmachine: I don't fault you.  I fault the HP :)
16:29:06 <sioraiocht> arnihermann: ping?
16:29:10 <randomwords> roconnor: And I can just use the existing zlib or deflate or whatever they use for compression I guess
16:29:17 <megajosh2> @type ([])
16:29:18 <lambdabot> forall a. [a]
16:29:22 <Phyx-> benmachine: ah ok, ty, I resortd to just glancing at the passing information. it seems correct, so I guess my HPI files should be good. now to write the reader in C# and i can see :P
16:29:34 <benmachine> roconnor: the hope would be that mtl wouldn't be inferior and buggy because people would fix it
16:29:42 <benmachine> I don't really know why that doesn't happen
16:29:48 <roconnor> tibb
16:30:15 <roconnor> tibbe: there is no need for the HP to do code reviews
16:30:27 <benmachine> he's gone :P
16:30:47 <ben_m> I'm trying to parse a String char-by-char. Every character will stay as-is, except for [ which starts a (possibly nested) loop ... how would you parse that? :S
16:30:52 <sshc> Is Either a monad in MonadLib?
16:31:11 <mauke> ben_m: with a function
16:31:20 <hpc> bar = map foo
16:31:20 <sshc> Looks like it is in Exception.
16:31:24 <benmachine> ben_m: brainfuck? :P
16:31:26 <hpc> er
16:31:33 <ben_m> benmachine: aye :P
16:32:05 <benmachine> ben_m: the nesting is the difficult part obviously, but it's probably not as nasty as you think
16:32:10 * ski . o O ( The `Error e' constraint on the `Monad (Either e)' instance sucks .. )
16:32:22 <benmachine> ben_m: I think you'd go for a reads-like function, only with Maybe instead of a list perhaps
16:32:25 <roconnor> benmachine: possibly because fixing the bugs would change the operational behavour.  Though versioning should solve that problem.  I guess really transformers or what not is supposed to replace the mtl, but it just ends up causing conflicts because they havne't called it mtl.
16:32:28 <sshc> I don't see list or maybe anywhere in MonadLib?
16:32:30 <FunctorSalad_> ben_m: foldMap? o_o
16:32:38 <benmachine> ben_m: i.e. you have a function that returns a parse of the next section, and the rest of the string
16:32:44 <FunctorSalad_> (I don't get the difficulty probably)
16:32:54 <geheimdienst> roconnor, i see your point. in HP's defense however, legacy issues are just part of making software. if people could time-travel back, they would probably do records differently, and the Prelude, and Num, and exceptions, and this and that and the other thing
16:32:56 <roconnor> sshc: list and Maybe are in the prelude
16:33:18 <roconnor> geheimdienst: yes, but HP makes the problem with legacy software worse.
16:33:20 <ben_m> benmachine: Ah, that sounds good.
16:33:21 <FunctorSalad_> ben_m: or just concatMap since apparently you want to produce a string again
16:33:34 <sshc> roconnor: How do I add Maybe layers to a stack of monads with MonadLib?
16:33:46 <FunctorSalad_> concatMap f; f '[' = .... ; f x = [x]
16:33:46 <roconnor> sshc: you need something like MaybeT
16:34:10 <ben_m> FunctorSalad_: Not producing a string
16:34:20 <sshc> roconnor: Yes, but that's in mtl (I think)
16:34:24 <ben_m> parse :: [Char] -> [Operation]
16:34:29 <benmachine> FunctorSalad_: yes but I can't see how concatMap would easily handle nesting
16:34:29 <ben_m> As I have it right now
16:34:32 <sshc> roconnor: I don't see MaybeT or ListT in MonadLib
16:34:39 <sshc> I wonder what ChoiceT is in MonadLib
16:34:46 <ben_m> Operation is just Op Char | Loop [Operation]
16:34:47 <roconnor> sshc: unfortunately MaybeT isn't part of the MTL (you could use ExceptionT ()) but it isn't in the mtl either.
16:34:49 <FunctorSalad_> ben_m: ok, I took 'char-by-char' literally =)
16:34:50 <Frr> noob question: What's the preferred way of signalling exceptions in new code? I heard it was Control.Exception but that seems to be "experimental" and "GHC only"?
16:34:54 <benmachine> MaybeT is not in mtl, ListT is tricky
16:35:00 <FunctorSalad_> that was @ benmachine 
16:35:07 <roconnor> sshc: ListT isn't in the MTL either, unless you count the buggy thing that is there.
16:35:09 <ben_m> FunctorSalad_: I meant that as iterating over the String char-by-char :s
16:35:17 <mauke> Frr: all libraries are
16:35:17 <FunctorSalad_> ben_m: in that case you want something less trivial than what I said ;) 
16:35:20 <roconnor> sshc: well, not so much buggy as horribly broken
16:35:30 <ben_m> I'll try what benmachine suggested :)
16:35:35 <roconnor> sshc: er
16:35:41 <roconnor> sshc: I think ChoiceT is listT
16:35:41 <ben_m> Thanks to you too, though!
16:36:01 <hpc> Frr: Either and Maybe are the preferred pure haskell "exception" types
16:36:07 <Frr> mauke: are what -- experimental, or GHC only?
16:36:20 <roconnor> oh
16:36:25 <roconnor> ChoiceT isn't ListT
16:36:30 <roconnor> but it might do what you want anyways. :)
16:36:43 <sshc> So I can't do ListT or MaybeT if I use MonadLib?
16:36:45 <mauke> Frr: YES
16:36:52 <benmachine> sshc: MaybeT has its own package, anyway
16:36:53 <hpc> you'll find the vast majority of useful things are GHC-only
16:37:09 <roconnor> sshc: MaybeT is just EitherT ()
16:37:28 <benmachine> Frr: ignore Experimental, people are way too cautious with the Stability field
16:37:34 <Frr> So it's best to just write software for GHC and wait for the standard to catch up then?
16:37:49 <roconnor> sshc: but you may have to write you own MaybeT if you don't like EitherT ()
16:38:07 <hpc> GHC barely deviates from the standard
16:38:12 <benmachine> @hackage MaybeT
16:38:12 <lambdabot> http://hackage.haskell.org/package/MaybeT
16:38:16 <hpc> it's just that it has oodles of useful extensions
16:38:20 <Jafet> It's best to just use GHC as the standard!
16:38:31 <hpc> and a library version of itself
16:38:45 <sshc> What's the standard / most popular Monad library?
16:38:51 <sshc> benmachine: I don't think it works with MonadLib
16:39:02 <hpc> mtl is the only one i knew of before today
16:39:06 <roconnor> sshc: the mtl
16:39:30 <benmachine> sshc: depends what you mean by works with
16:39:33 <roconnor> sshc: so if you want the same broken library that everyone else uses, you can use that.
16:39:45 <benmachine> oh I guess it depends on mtl
16:39:45 <benmachine> sucks
16:39:47 <sshc> roconnor: I want the best, even if it's not standard
16:39:57 <roconnor> sshc: transformers is moderately popular, and it may be even correct.
16:40:07 <benmachine> roconnor: I kinda think that even if you didn't have the HP, you'd still get conflicts
16:40:10 <benmachine> er
16:40:12 <benmachine> I mean to say
16:40:21 <sshc> roconnor: Are those the only three libraries?
16:40:25 <roconnor> no
16:40:26 <sshc> roconnor: I thought MonadLib was the most recent
16:40:30 <benmachine> you'd still get competition being skewed by popularity
16:40:37 <roconnor> MonadLib is 2-3 years old I think
16:40:41 <Frr> Alright, I'll use Control.Exception and be GHC-only then. The code looks cleaner than with Either.
16:40:53 <roconnor> benmachine: I agree, but less skewed
16:41:07 <sshc> roconnor: Which monad package is the most well designed / "best"?
16:41:15 <roconnor> putting things like the mtl in HP is like microsoft putting IE into windows.
16:41:44 <roconnor> sshc: I haven't reviewd the lasted monad libraries
16:42:05 <roconnor> sshc: transformers may be a good choice for you
16:42:09 <roconnor> it is well supported
16:42:16 <roconnor> has MaybeT and ListT compatible libraries
16:42:19 <roconnor> and probably isn't buggy
16:42:39 <roconnor> well
16:42:44 <Adamant> what's wrong with mtl, incidently?
16:42:50 <roconnor> don't use the Control.Monad.Trans.List in transformers
16:42:54 <benmachine> transformers has broken ListT
16:42:59 <roconnor> use the ListT package instead
16:43:17 <roconnor> Adamant: ListT is broken and so is something like StateT Cont
16:43:18 <benmachine> Adamant: a lot of people think the Error constraint on the Either monad instance it provides is ugly
16:43:31 <benmachine> and yeah ListT is broken
16:43:36 <benmachine> and it has no Applicative instances for anything
16:43:38 <roconnor> ya, the Error constraint on Either is a bad design choice
16:43:41 <ski> benmachine : yes, it doesn't belong there
16:44:14 <roconnor> I don't know if transformers has the StateT Cont bug
16:44:24 <ski> roconnor : which bug is this ?
16:44:27 <sshc> How is StateT Cont broken?
16:44:44 <roconnor> callCC does the wrong thing with state IIRC
16:44:51 <ski> @unmtl StateT s (Cont o) a
16:44:51 <lambdabot> s -> (a -> s -> o) -> o
16:44:55 <roconnor> I don't recall the details because using callCC with state boggles my mind
16:45:48 <sshc> How does callCC work?
16:45:59 <sshc> I understand how the rest of Continuations work
16:45:59 <ski> @src Cont callCC
16:45:59 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
16:46:24 <parity> How would I go about proving the Pointed functor property stated in Typeclassopedia: fmap g . pure = pure . g ?
16:46:45 <roconnor> @free pure
16:46:46 <lambdabot> Expected variable or '.'
16:46:56 <roconnor> @type pure
16:46:56 <monochrom> there are StateT Cont and ContT State. there is code "put True >> callCC (\k -> put False >> k) >> get". Should the final state be True or False? That is the dispute.
16:46:57 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:47:00 <ski> parity : prove `forall x. fmap g (pure x) = pure (g x)', probably by induction on `x'
16:47:06 <roconnor> isn't the theorem free?
16:47:13 <parity> roconnor: it is, but i'm interested anyway
16:47:54 <benmachine> @help free
16:47:54 <lambdabot> free <ident>. Generate theorems for free
16:47:59 <ski> parity : how is `Pointed' defined ?
16:48:00 <parity> ski: induction on x -- so x should be a number, or ?.  I'm a little unclear what induction on x means when it's just a "forall x"
16:48:03 <hpc> @src pure
16:48:03 <lambdabot> Source not found. Maybe you made a typo?
16:48:13 <sshc> How efficient is transformers?
16:48:14 <roconnor> I wouldn't expect to use induction to prove free theorems
16:48:20 <parity> ski: class Functor f => Pointed where pure :: a -> f a
16:48:20 <sshc> How does its performance compare to that of mtl?
16:48:25 <roconnor> the whole point of free theorems is that they are parametric
16:48:28 <ski> parity : hm, actually .. probably not induction on `x', here
16:48:50 <ski> parity : oh .. for some reason i thought you were talking about a specific instance
16:48:56 <parity> I can assume I have the functor laws, but I am not seeing how that helps me (mostly probably because I've not tried to show anything like this before)
16:48:58 <roconnor> sshc: probably just as terrible as the mtl
16:49:15 <hpc> parity: start with (.) = fmap, perhaps?
16:49:15 <ski> parity : typically, you'd prove laws for each instance you make of a class
16:49:17 <parity> ski: oh, ok, i feel a bit better now ;P no, i'm trying to show it for any definition of pure as long as the functor is well behaved
16:49:42 <ski> parity : it might be in some cases you can do it generically, by referring to other laws, or to free theorems
16:49:45 <roconnor> well, maybe the mtl's performance isn't so terrible
16:50:04 <hpc> and doesn't pure == fmap?
16:50:10 <roconnor> it used to be terrible in Ubuntu because the distributed haskell libraries were not optimised
16:50:16 <parity> ski: yeah, that's what the hint seemes to suggest; I just don't think I know said properties.  And the referent Wadler paper is still a bit beyond my reach.
16:50:17 <ski> hpc : no
16:50:22 <dobblego> pure = const
16:50:30 <ski> hpc : `pure' is basically `return'
16:50:31 <roconnor> pure = return?
16:50:33 <parity> pure ~ return
16:50:35 <parity> yeah
16:50:40 <hpc> oh right
16:50:46 <dobblego> return is basically point :)
16:50:47 * hpc fails at reading types
16:51:01 <parity> intuitively the property makes a lot of sense, i'm just trying to be complete 
16:51:03 <monochrom> theorems for free is probably the hardest paper among Wadler's.
16:51:39 <parity> monochrom: that makes me a feel a bit better :P
16:51:51 <ski> parity : so, if you don't want to go via free theorems, i believe the best one can do is prove it for each instance
16:52:24 <parity> ski: hmm, okay, cool.  i'd read a blog post that seemed to suggest it could be done without that, but maybe I just misunderstood.
16:52:24 <ski> (separately)
16:52:28 <parity> ski: *nod*
16:52:30 <benmachine> pure = liftA0 :O
16:52:38 <benmachine> so it's said
16:52:56 <ski> parity : which post ?
16:53:01 <parity> ski: (sec)
16:53:37 <parity> ski: http://ezyang.com/haskell.html under exercises
16:53:51 <parity> ski: second bullet in the 'pointed' subsection
16:54:12 <parity> ski: free theorems could certainly be the expected path, but there was no remark along those lines so i'd not thought it would be needed.
16:55:09 <ski> ezyang : hm .. what did you have in mind, here ?
16:58:59 <ski> hm, that asks to prove `forall f. Functor f => forall (pure :: forall a. a -> f a). forall a b. forall (g :: a -> b). fmap g . pure = pure . g'
16:59:56 <ski> the equality is between functions of type `a -> f b'
16:59:57 <hpc> question: when writing a haskell CGI script without a CGI module, the HTTP requests come in through stdin, right?
17:00:25 * ezyang hasn't looked at that page in a while 
17:00:27 <lispy> hpc: yes, cgi communicates on stdout/stdin
17:00:27 <ezyang> lessee 
17:00:32 <hpc> crap
17:00:49 <hpc> i get a 500 error when i try to echo stdin to stdout
17:00:57 <benmachine> hpc: you need headers
17:01:04 <hpc> i have those
17:01:04 <benmachine> Content-type: text/plain
17:01:05 * lispy was just going to say that
17:01:13 <benmachine> oh
17:01:16 <hpc> i'm echoing inside the <html>
17:01:21 <benmachine> then check your httpd error logs :)
17:02:53 <Phyx-> http://phyx.pastebin.com/MN4yYw3m <-- weee small sizes :)
17:04:02 <ben_m> I think I'll stop trying to parse things thing manually and just use parsec >_>
17:04:31 <ben_m> My FP-fu is not strong enough yet.
17:04:33 * ski wonders what ben_m is trying to parse
17:04:37 <ben_m> ski: brainfuck
17:04:54 * ski moves away from ben_m on the bench, there
17:04:59 <parity> haha
17:05:02 <ezyang> Hm, did I actually put a really hard question on the exercises. Whoops. 
17:05:08 <parity> ezyang: *whew*
17:05:18 <parity> ezyang: I was following along so well and then hit a brick wall =)
17:05:33 <ski> ezyang : i don't know. i was hoping you'd tell me i was missing something :)
17:05:57 <ezyang> I think I probably would have just drawn a diagram, said "this commutes", and been done. 
17:06:13 <hpc> my error log has no output :(
17:06:19 <ski> well, it commutes because `pure' is natural
17:06:35 <parity> ezyang: what commutes, sorry?
17:06:39 <ski> but i have a feeling you need theorems for free for that
17:06:54 <ski> parity `fmap g . pure' and `pure . g'
17:07:08 <ezyang> parity: Are you familiar with commuting diagrams 
17:07:17 <parity> ezyang: i must not be
17:07:20 <hpc> @where paste
17:07:20 <lambdabot> http://hpaste.org/ http://codepad.org/
17:07:23 <lispy> ben_m: here is how I would do it: http://code.haskell.org/lambdabot/brainfuck/  look in Language.Brainfuck
17:07:51 <hpc> http://codepad.org/kqI0QAl1 is my code
17:07:53 <ski> parity : that a "diagram commutes" is category theoretic jargon for saying that a bunch of morphism compositions actually yield the same result
17:08:02 <hpc> it works in ghci, but not lighttpd
17:08:06 <hpc> and the error log is empty
17:08:28 * Phyx- pokes lispy 
17:08:37 <Phyx-> wait wait waitr
17:08:38 * ski peeks Phyx-
17:08:42 <parity> ski: Ahh, ok.
17:08:44 <Phyx-> there actually is a brainfuck for haskell?
17:08:53 <benmachine> more than one!
17:09:01 * Phyx- informs ski that the pointer was invalid
17:09:28 <ski> parity : if you want, you could say that `pure' commutes with `g' in `pure . g', turning `g' into `fmap g' on the way to `fmap g . pure'
17:10:15 <lispy> heh, I forgot how my bf compiler optimizes
17:10:24 <ski> Phyx- : ah, memory mapped I/O device registers
17:10:26 <parity> ski: okay thanks -- i'll try to grok that after i read up a bit about commutativity diagrams =)
17:10:29 <ben_m> lispy: Nice, thanks.
17:10:29 <ezyang> I gotta run. See you all 
17:11:00 <ski> parity : it (commutating diagrams) really is a very simple (but useful) concept
17:11:09 <ski> ezyang : ok
17:11:17 <parity> ezyang: thanks
17:11:52 <hpc> @hoogle IO Bool
17:11:52 <lambdabot> Did you mean: :: IO Bool /count=20
17:11:52 <lambdabot> No results found
17:11:57 <Mitar> is there a thread safe way of doing select in haskell program? (wait in one thread for input on file descriptor?)
17:12:04 <parity> ski: the wikipedia page on it gets into category theory terminology pretty quickly =/
17:12:34 <lispy> Mitar: Well, the RTS uses select/epoll internally
17:12:40 <lispy> Mitar: So you could rely on that
17:12:46 <Mitar> because X11 lib uses its own select
17:12:46 <Mitar> http://hackage.haskell.org/packages/archive/X11/1.5.0.0/doc/html/src/Graphics-X11-Xlib-Event.html#waitForEvent
17:12:51 <Mitar> directly from C ...
17:13:22 <Mitar> and so using waitForEvent just makes haskell program behave strange
17:13:40 <Mitar> (if I use multiple threads in a program)
17:14:13 <Mitar> so I would like to do the same thing waitForEvent is doing, only with something from haskell RTS
17:15:06 <lispy> Mitar: you might need to talk to either dons or dcoutts.  They should be experts about that
17:15:17 <Mitar> are they here around currently?
17:15:26 <lispy> preflex: seen dcoutts
17:15:26 <preflex>  dcoutts was last seen on #ghc 2 days, 15 hours, 16 minutes and 56 seconds ago, saying: * dcoutts heads off to Utrecht for 8 days
17:15:30 <lispy> preflex: seen dons
17:15:30 <preflex>  dons was last seen on #ghc 5 hours, 33 minutes and 25 seconds ago, saying: beer oclock
17:15:36 <Mitar> thanks
17:16:18 <ski> parity : if you look at <http://en.wikipedia.org/wiki/Commutative_diagram>, then the second diagram you see expresses `h . f = k . g'
17:16:49 <ski> parity : `A',`B',`C',`D' is the types of the argument and result of the four functions
17:16:57 <parity>  ski: yeah, was just looking at that
17:17:16 <parity> ski: so f :: A -> B , etc.?
17:17:21 <ski> parity : `f :: A -> B', `h :: B -> D', `g :: A -> C',  `k :: C -> D'
17:17:23 <ski> yeah
17:17:56 <parity> ski: okay, that's actually pretty straightforward.
17:18:12 <ski> parity : the arrows don't *need* to represent functions, CT is more general than that. but it's a useful standard example of arrows/morphisms
17:18:25 * parity nods.
17:18:39 <ski> parity : so, commutating diagrams is "just" a handy graphical way to display equations between compositions
17:19:00 <Mitar> hmm, wasn't there some function to make handle from fd?
17:19:02 <parity> ski: Gotcha
17:19:05 <Mitar> in posix or somewhere?
17:19:43 <Mitar> aha
17:19:43 <Mitar> System.Posix.IO
17:20:45 * Phyx- wonders who had time to write brainfuck for haskell
17:21:02 <lispy> Phyx-: me
17:21:12 <lispy> Phyx-: that one I linked to was written by me in 2006 :)
17:21:33 <Phyx-> lispy: you have way to much free time
17:21:34 <lispy> Phyx-: specifically for inclusion in lambdabot (although the one that ships with lambdabot is crippled)
17:21:40 <lispy> Phyx-: had, had way too much free time
17:22:05 <Phyx-> lispy: lol, btw, i'm 50% finished with intellisense http://phyx.pastebin.com/MN4yYw3m
17:22:17 <lispy> Phyx-: but, it only took a weekend, too
17:22:28 <lispy> Phyx-: cool
17:22:45 <malorie> when doing `True && "False"' ghci throws "... against inferred type `[Char]'". why does it throw the same error when doing `True && "False"::[Char]' though? (since it mustn't really *infer* anything there, right?)
17:22:54 * Phyx- noticed, talking here and playing MW2 on xbox live is lowering my kill count
17:23:09 <ski> parity : for a somewhat more complex example (i couldn't find a diagram for a only slightly more complex example) see <http://en.wikipedia.org/wiki/Coproduct>
17:23:30 <benmachine> malorie: I think True && "False"::[Char] parses as (True && "False")::[Char]
17:23:30 <Adamant> multitasking only works for computers if you care about both things you are doing
17:23:32 <ski> parity : specifically the one following the text "If the family of objects consists of only two members"
17:23:41 <benmachine> hence, exact same error
17:24:09 <Phyx-> lispy: do those sizes seem off to you? (it has docs, functions, classes and instances)
17:24:18 <malorie> benmachine: well. it throws regardless of parentization whatsoever ...
17:24:20 <parity> ski: ah, i see
17:24:21 <lispy> Phyx-: sorry, I have no idea
17:24:23 <benmachine> malorie: ah well
17:24:38 <ski> parity : they talk about a type/object `X_1 + X_2' (also written in two other notations)
17:24:47 <Phyx-> lispy: neither do i, lol
17:24:48 <benmachine> malorie: the way I think of it is, inferred types bubble up, expected types push down
17:25:00 <ski> parity : this type is basically `Either X_1 X_2', in terms of Haskell
17:25:04 <parity> ski: yeah and they're talking about a particular morphism to complete the digram, i guess. (the dotted f)
17:25:16 <benmachine> malorie: expected type is the type that something should be from the context in which it appears, whereas inferred type is any information about the type that comes from the thing itself
17:25:29 <benmachine> so (x::[Char]) has an inferred type of [Char]
17:25:45 <ski> parity : yeah, first they say that there has to exists `i_1 :: X_1 -> X_1 + X_2', this is `Left :: X_1 -> Either X_1 X_2'
17:25:48 <benmachine> True && x -- x has an expected type of Bool
17:25:50 <benmachine> et voila.
17:26:03 <parity> ski: Ahhh, cool.
17:26:03 <malorie> hm. I see.
17:26:12 <hpc> question the second: http://codepad.org/pO8FnqJt
17:26:13 <ski> parity : similarly, `i_2 :: X_2 -> X_1 + X_2' should exists, i.e. `Right :: X_2 -> Either X_1 X_2'
17:26:17 <parity> *nod*
17:26:24 <hpc> this code outputs the doctype and terminates
17:26:31 <ski> parity : but those two functions only tell you how to *con*struct values in `Either X_1 X_2'
17:26:38 <hpc> so how does a script get the http request information?
17:27:10 <benmachine> hpc: try looking in the environment
17:27:19 <Phyx-> lispy: so gonna make one for whitespace?
17:27:22 <ski> (parity : sorry, phone call .. wait a little bit)
17:27:37 <parity> ski: no worries, i think i have enough to dig a bit more -- thanks for your time!
17:27:54 <benmachine> hpc: you realise the otherwise -> pattern is equivalent to _ ->, right?
17:28:16 <hpc> i like having the word there
17:28:25 <benmachine> it confuses me
17:28:38 <hpc> @src otherwise
17:28:38 <lambdabot> otherwise = True
17:28:53 <benmachine> personally I'd just use Control.Monad.when
17:28:53 <benmachine> but there you go.
17:29:14 <aristid> > otherwise
17:29:15 <lambdabot>   True
17:29:30 <aristid> no, an otherwise -> pattern is not equivalent to _ ->
17:29:45 <benmachine> aristid: in this case it is because otherwise isn't used on the RHS
17:29:55 <aristid> benmachine: ?
17:30:14 <benmachine> aristid: in his paste, he has otherwise -> but doesn't use the binding
17:30:21 <aristid> otherwise is just a value, right?
17:30:21 <benmachine> so it could be replaced with _ ->
17:30:23 <benmachine> yes
17:30:32 <benmachine> but in a pattern context it's just a name
17:30:38 <ski> parity : so, the rest of the diagram explains how to *de*struct elements of `Either X_1 X_2'
17:30:50 <aristid> benmachine: ah, because there is no equality matching!
17:31:02 <benmachine> aristid: mm
17:31:15 <benmachine> except for on numeric constants, but only because they pretend to be constructors
17:31:19 <aristid> hpc: use True instead. using "otherwise" is highly confusing :)
17:31:20 <benmachine> sort of
17:31:39 <hpc> :D
17:31:59 <ski> parity : and it does that by saying that if you've got `f_1 :: X_1 -> Y' and `f_2 :: X_2 -> Y', then there exists a *unique* `f :: Either X_1 X_2 -> Y', such that the diagram commutes (meaning that any two paths with same source and same target, when interpreted as compositions, should be equal compositions)
17:32:30 <ski> @type \(f_1,f_2) -> either f_1 f_2
17:32:31 <lambdabot> forall a c b. (a -> c, b -> c) -> Either a b -> c
17:32:36 <parity> ski: ahh, ok. i'm not clear where the guarantee of uniqueness comes from, but it makes sense 
17:32:42 <aristid> hpc: or whileM (not <$> isEOF) (getLine >>= putStrLn) :D
17:32:54 <hpc> @src whileM
17:32:55 <lambdabot> Source not found. You type like i drive.
17:33:01 <ski> parity : and, what `f' does is basically check whether it's input is an `X_1' or an `X_2', and pass it to either `f_1' or `f_2'
17:33:05 <aristid> http://hackage.haskell.org/packages/archive/monad-loops/0.3.0.2/doc/html/Control-Monad-Loops.html#v%3AwhileM
17:33:26 <aristid> or better, whileM_
17:33:27 <hpc> nifty
17:33:27 <benmachine> hpc: http://codepad.org/KxiWG7Kw explain what happens here :P
17:33:40 <ski> parity : the "exists" here means that for any such `f_1' and `f_2', there exists an `f' such that `f . Left = f_1' and `f . Right = f_2'
17:33:57 <parity> ski: ah, got it
17:33:59 <hpc> benmachine: MADNESS! MWAHAHAHA
17:34:11 <ski> parity : this means that if you always pass `f' a value of the form `Left x_1', then it will give `f_1 x_1' .. and mutatis mutandis for the other case
17:34:35 <benmachine> hpc: the otherwise branch doesn't execute :O
17:34:38 <ski> parity : however, this doesn't guarantee that `Left x_1' and `Right x_2' are the *only* kind of values in the type `X_1 + X_2'
17:34:48 <ski> parity : and *that*s what "uniqueness" here means
17:35:12 <parity> right
17:35:15 <parity> er, Left. ;P
17:35:31 <parity> ski: thanks for explaining that
17:35:56 <ski> parity : and, just to be clear. the whole *point* of this is to express what it *means* for *any* type , here written `X_1 + X_2', to be a *coproduct/sum* of the two types `X_1',`X_2'
17:36:34 <parity> parity: sweet
17:36:37 <hpc> otherwise is exported by Prelude but never defined o.O
17:36:39 <benmachine> ben_m: p.s. http://haskell.pastebin.com/ztDhvxxp this is what I was talking about earlier
17:36:40 <parity> ski: sweet 
17:36:46 <hpc> it's mentioned once in the export list and once in a comment
17:36:48 <ski> parity : so, this is sortof an abstract, general *specification* of what it means to have sum/coproduct types
17:36:48 <benmachine> hpc: it might be imported from somehere else?
17:36:48 <dolio> dolio: You're awesome!
17:37:09 <benmachine> hpc: GHC.Base, apparently
17:37:09 <hpc> @hoogle otherwise
17:37:09 <lambdabot> Prelude otherwise :: Bool
17:37:09 <lambdabot> Data.Bool otherwise :: Bool
17:37:12 <int80_h> has someone preserved the hpaste database? I need to look something up on it, and hpaste proper is down.
17:37:47 <ski> parity : now, to confuse matters for you a bit. there's a lot of different-looking categories. and a specification like the one for "coproduct" makes sense to consider un many categories
17:38:06 <ski> parity : there's one category where the morphism are arbitrary functions, and the objects/"types" are plain sets
17:38:18 <parity> ski: ok...
17:38:19 <ben_m> benmachine: That's helpful, thanks. I just resorted to Parsec for now :D
17:38:28 <int80_h> ski: hi hi hi :)
17:38:31 <ski> parity : here "coproduct" means what is usually called "disjoint union (of sets)"
17:38:40 <benmachine> ben_m: Parsec's probably better (faster, stronger), but it's neat all the same
17:38:45 <benmachine> nicely mutually recursive >_>
17:38:56 <ben_m> Yeah I wanted to do it without Parsec so I knew how to
17:39:05 <ben_m> But I failed at that :P
17:39:08 <jmcarthur> djahandarie: that hackage project page looks awesome
17:39:11 <hpc> also, whoever suggested the environment was right
17:39:20 <ski> parity : i don't know how much math you know. but there's e.g. a category where the objects are vector spaces, and the morphisms are linear transformations / matrices
17:39:21 <benmachine> ben_m: it did take me a good bit of hmming
17:39:37 <djahandarie> jmcarthur, thanks :)
17:39:46 <parity> ski: just enough to hurt myself =).  but I think I understand what you said.
17:39:55 <ski> parity : more or less, each "category" is a small mathematical "world", in which you can consider problems, compute things, prove things, &c.
17:40:02 <hpc> now i am back on track, until i need to deal with POST data
17:40:04 <parity> *nod*
17:40:15 <benmachine> POST comes in stdin iirc
17:40:23 <ski> parity : and the category of vector spaces is the category you want to be in, if you're doing linear algebra, with vectors and matrices
17:40:43 <hpc> POST can be quite complex at times
17:40:46 <parity> ski: bah, friends are calling for dinner.  i'll have to bug you more about this later =)
17:40:49 <benmachine> if you get a multipart thing then you give up and cry and use a proper library
17:40:55 <parity> ski: thanks again for the explanations, they're very helpful
17:41:03 <ski> parity : there are e.g. a "type"/object `|R^3' in there, the space of three-dimensional (real-valued-)vectors
17:41:23 <hpc> i'm gonna do the multipart crap myself
17:41:35 <hpc> i will write a fully functional library if it's the last thing i do
17:41:45 <Phyx-> oh well
17:41:46 <Phyx-> gn
17:41:46 <ski> parity : similarly, for each natural number `n', there's a space/object/type `|R^n' in there, corresponding to `n'-dimensional (real-valued-)vectors
17:41:48 <hpc> (it probably will be)
17:42:08 <benmachine> hpc: hasn't it been done before?
17:42:12 <aristid> hpc: with your last breath, you will conquer the beast!
17:42:28 <hpc> benmachine: reinventing the wheel is good exercise occasionally
17:42:46 <hpc> also, i like it better than learning someone else's crappy wheel
17:42:50 <benmachine> :P
17:42:57 <benmachine> improving someone else's crappy wheel is the best though
17:43:01 <hpc> true
17:43:03 <ski> parity : ok. i'll end the current exchange with saying that in here, what `|R^m + |R^n' (to coproduct/sum of `|R^m' and `|R^n') means is just `|R^(m + n)'
17:43:33 <ski> ("here" = category of vector spaces)
17:43:46 <benmachine> I'm all for reinventing as an exercise, but only with interesting things not tedious RFC-to-parser conversions :P
17:43:59 <hpc> that's enough thinking for tonight; time to sleep and let my subconscious do some thinking for a change
17:45:28 <parity> ski: cool =) i might bug you about this a bit more later to hear more
17:45:36 <ski> yw
17:47:26 <dolio> Categorical constructs like the (co)product end up relating a lot of similar stuff from lots of fields of mathematics.
17:47:43 <dolio> You have products of sets, and products of groups, and products of vector spaces, ...
17:47:58 <Adamant> but where do copumpkins fit in?
17:47:59 <dolio> And they all end up being products in the right category.
17:49:56 <JoeyA> Is it possible to create a default class method that requires the type be in a given class without requiring that of the whole class?
17:49:59 <JoeyA> e.g.:
17:50:07 <JoeyA> class Comparable a where
17:50:32 <JoeyA>     cmp :: a -> a -> Int
17:50:38 <dolio> I think I know what you're asking, and the answer is no.
17:50:51 <JoeyA>     cmp x y = case ord of LT -> -1; GT -> 1; EQ -> 0;
17:51:25 <JoeyA> That code won't work without saying class Ord a => Comparable a
17:51:42 <ski> (presuming s/ord/compare x y/)
17:52:06 <JoeyA> right
17:52:26 <ski> > fromEnum `map` [LT .. GT]
17:52:27 <lambdabot>   [0,1,2]
17:53:00 <JoeyA> > fromEnum . [LT .. GT]
17:53:02 <lambdabot>   [0,1,2]
17:53:05 <aristid> JoeyA: i think the standard way of doing that is providing a separate cmpDefault that can be used to make lightweight instances
17:53:12 <ski> JoeyA : do you have an application in mind which would use anything other than `-1',`0',`1' ?
17:53:18 <JoeyA> okay, thanks
17:53:28 <JoeyA> Comparable was just an example.
17:53:31 <ski> ok
17:53:53 <benmachine> :t Data.Traversable.foldMapDefault
17:53:54 <lambdabot> forall a m (t :: * -> *). (Data.Traversable.Traversable t, Monoid m) => (a -> m) -> t a -> m
17:54:06 <benmachine> :t foldMap
17:54:07 <lambdabot> Not in scope: `foldMap'
17:54:12 <benmachine> :t Data.Foldable.foldMap
17:54:13 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
17:54:50 <ski> @type Data.Foldable.foldMap id
17:54:51 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t, Monoid a) => t a -> a
17:55:30 <aristid> i like the days when my code is shrinking
17:56:29 * ski . o O ( Eilenberg-Moore ? )
17:56:55 <aristid> wtf http://en.wikipedia.org/wiki/Eilenberg%E2%80%93Moore_spectral_sequence
17:57:37 <aristid> ooh that picture looks like one of these "natural transformation" diagrams i saw in a blog post by... ezyang or so
17:58:56 * ski was wondering whether the Eilenberg-Moore category over a monad was related to `foldMap' above
18:00:03 <ski> aristid : was that something apart from "commutative diagrams" ?
18:00:23 <dolio> t a -> a is the type of a t-algebra action.
18:01:03 <dolio> That doesn't have anything to do with the Eilenberg-Moore category necessarily, though.
18:01:12 <aristid> ski: it was something about join and fmap, i think
18:01:25 <dolio> There are categories of algebras for functors that aren't monads.
18:01:38 <ski> ok
18:02:00 * ski should learn more about EM, sometime
18:02:09 <int80_h> does anyone know if hpaste is coming back?
18:02:16 <dolio> And the monad algebras in the EM category are subject to more coherence conditions, I think.
18:02:43 <dolio> The action has to commute with return and join I think.
18:03:02 <ski> sounds probable
18:03:19 <ski> aristid : well, `join' (and `return') should be natural transformations
18:04:06 <aristid> ski: yup, maybe it was join and return
18:04:23 <aristid> ski: hmm maybe it was even with duplicate and extract
18:04:56 <ski> aristid : that `eta' is a natural transformation is more or less expressed like `forall f. eta . fmap f = fmap f . eta'
18:05:29 <ski> (for any `eta')
18:05:40 <aristid> fmap (f . eta) or (fmap f) . eta?
18:05:49 <ski> the latter
18:05:54 <djahandarie> any eta that I choose or any eta that you choose? ;)
18:06:14 <aristid> :t \eta -> eta . fmap f
18:06:15 <lambdabot> forall b a b1 (f :: * -> *). (Show a, SimpleReflect.FromExpr b1, Functor f) => (f b1 -> b) -> f a -> b
18:06:16 <ski> djahandarie : any `eta' you choose, as long as it has a type of the right shape
18:06:26 <aristid> :t \eta -> [eta . fmap f, fmap f . eta]
18:06:27 <lambdabot> forall b (f :: * -> *) b1 (f1 :: * -> *). (Show b, SimpleReflect.FromExpr b, Functor f, Show b1, SimpleReflect.FromExpr b1, Functor f1) => (f b -> f1 b1) -> [f b -> f1 b1]
18:06:36 <aristid> :t \f eta -> [eta . fmap f, fmap f . eta]
18:06:37 <lambdabot> forall b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (b -> b) -> (f b -> f1 b) -> [f b -> f1 b]
18:06:41 <ski> djahandarie : that shape being `forall a. f a -> g a' for any (functors) `f' and `g' you like
18:07:24 <dolio> @free eta :: F a -> G a
18:07:25 <lambdabot> $map_G f . eta = eta . $map_F f
18:07:50 <aristid> ski: so a natural transformation is a function of type f a -> g a with 'forall f. eta . fmap f = fmap f . eta'?
18:09:06 <ski> @type let foo :: (Functor f,Functor g) => (forall a. f a -> g a) -> (a -> b) -> [f a -> g b]; foo eta f = [eta . fmap f, fmap f . eta] in foo
18:09:07 <lambdabot> forall (f :: * -> *) (g :: * -> *) a b. (Functor g, Functor f) => (forall a1. f a1 -> g a1) -> (a -> b) -> [f a -> g b]
18:09:37 <ski> aristid : .. is a function of type `forall a. f a -> g a' (with `f' and `g' any functors). the `forall a.' is important
18:10:07 <ski> (and satisfying that equation, yes)
18:10:24 <aristid> ski: i was using implicit forall! :D
18:10:43 <ski> aristid : yeah, but `f' and `g' shouldn't be implicitly universally quantified
18:10:58 <ski> so, `eta' maps from one kind of "collection", to another kind of "collection"
18:11:02 <aristid> ok yeah, they are not
18:11:08 <aristid> so i should use F and G
18:11:31 <ski> and the law says that it doesn't matter if you change the kind of collection first, or you change the elements by mapping a function first
18:11:40 <aristid> from one kind of burrito to another kind of burrito
18:11:45 <aristid> or maybe to a spacesuit?
18:12:29 <ski> @type listToMaybe
18:12:30 <lambdabot> forall a. [a] -> Maybe a
18:12:36 <ski> that's one example of a natural transformation
18:13:05 <int80_h> if ghc would just implement burritos instead of using monads, I think it would be easier to understand.
18:13:11 <ski> @type return . runIdentity  -- is another one .. for every monad `m'
18:13:11 <lambdabot> forall a (m :: * -> *). (Monad m) => Identity a -> m a
18:13:58 <ski> in CT, we say that `return' itself is a natural transformation, of type `forall a. id a -> m a', but we can't write that `id' in Haskell, except by using a new type
18:14:35 <ski> usually, instead of saying `eta : forall a. f a >-> g a' one would instead write that as `eta : f >-> g', though
18:14:54 <ski>   return_m : id >-> m
18:15:04 <ski>   join_m : (m . m) >-> m
18:15:29 <JoeyA> What's a good way to process a lazy ByteString to ensure that no chunks are longer than 65535 bytes long?  fromChunks . concatMap (\c -> if S.length c > 65535 then myOwnSplitter c else [c]) . toChunks
18:15:33 <JoeyA> Or is there something better?
18:17:34 <aristid> hmm. Monad with Ord constraint *random idea*
18:18:11 <JoeyA> Individual instances of MonadOrd are called "mords"
18:18:22 <ski> aristid : thinking about `Data.Set' ?
18:18:24 <randomwords> I'm converting a Double to a GLDouble. using realToFrac, it's fine on linux but exceptionally slow on windows, is this a known bug?
18:18:36 <aristid> ski: yeah and a function of mine called joinQ
18:19:02 <luite> randomwords: I am around now, have you alreay been able to install gd?
18:19:33 <randomwords> luite: I gave up a while ago, but I've moved onto to doing something less soul eroding for the moment
18:19:39 <randomwords> thanks though
18:20:02 <luite> randomwords: I'll try in a moment
18:24:43 <randomwords> If anone want the answer to my previous question re. realToFrac - using unsafeCoerce resolves the problem
18:26:45 <JoeyA> Does unsafeCoerce basically compile down to a cast in C?
18:27:16 <randomwords> yeah, I assume GLDouble is just a type for a Double, they used to be one and the same
18:27:21 <JoeyA> For instance, if you convert between two number types with unsafeCoerce, will conversion have the same semantics as their respective casts in C?
18:27:30 <dolio> No.
18:27:53 <JoeyA> dag nabbit
18:30:48 <roconnor> don't use unsafeCoerce unless the input and output types are the same
18:41:42 <wakeupsticky> hi all
18:42:10 <ben_m> Can one invite lambdabot into a private channel to help explain things?
18:42:20 <megajosh2> ben_m: You can /msg him
18:42:25 <wakeupsticky> how can i add instance declarations (for Show) for an algebraic data type whose constructors take different numbers of arguments?
18:42:34 <ben_m> megajosh2: Yeah but then I'd have to copy/paste everything :/
18:42:57 <megajosh2> Hmm...
18:43:05 <wakeupsticky> right now i just get the error "Equations for `show` have different numbers of arguments"
18:43:22 <megajosh2> wakeupsticky: What does your code look like?
18:43:36 <megajosh2> (don't flood us with your code <_<)
18:45:04 <wakeupsticky> what's the url for the site that i can paste it to?
18:45:20 <megajosh2> Well there's all kinds you could use
18:45:26 <megajosh2> A lot of people seem to use paste.com
18:45:28 <megajosh2> *pastie
18:45:32 <megajosh2> Or you could use pastebin
18:45:47 <megajosh2> OH GOD
18:45:54 <lispy> or lisppaste
18:45:58 <megajosh2> That
18:46:02 <megajosh2> Was unexpected
18:46:15 <megajosh2> It sure isn't pastie.com...
18:46:31 <wakeupsticky> pastie.com: the leading nipple covers site on the net
18:46:57 <megajosh2> http://pastebin.com
18:47:50 <lispy> http://hpaste.org
18:48:05 <EvanR> pastie.com is decidedly disappointing
18:48:15 <wakeupsticky> ok, i put it up on pastebin
18:48:24 <wakeupsticky> under "Multiple instance declarations for show"
18:48:27 <megajosh2> Okay. Where's the link?
18:48:38 <wakeupsticky> http://pastebin.com/4eJTf2gw
18:49:04 <wakeupsticky> obviously this is for a chess engine but the unexplained stuff should be fairly self-explanatory and isn't important anyway
18:49:18 <wakeupsticky> i just added the first two instance declarations...the one below is fine and has always worked
18:49:38 <megajosh2> The problem is the first two lines in the instance declaration
18:49:46 <megajosh2> You declare "show" as if it takes two arguments
18:49:53 <lispy> wakeupsticky: you need parens around (CKS acolor) and (CQS acolor)
18:50:14 <megajosh2> And if you don't use the value of that argument, just use _
18:50:19 <megajosh2> Well, that pattern match
18:50:22 <wakeupsticky> right, deconstruction
18:50:23 <wakeupsticky> i had _
18:50:28 <wakeupsticky> tried changing it :P
18:50:57 <wakeupsticky> ok, that compiles
18:51:04 <wakeupsticky> need to remember to use parens for all pattern matching
18:51:06 <lispy> wakeupsticky: time to ship it!
18:51:06 <wakeupsticky> >_>
18:51:12 <wakeupsticky> :)
18:52:01 <wakeupsticky> not quite yet...i have everything represented, can load positions from a fen string, and can generate a list of legal moves for a position, but it needs some castling and en passant support and, of course, an evaluation function and a search function
18:52:11 <lispy> fen string?
18:52:23 <JoeyA> Are there Haskell classes for random-access handles?
18:52:28 <wakeupsticky> http://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation
18:52:34 <wakeupsticky> i spent yesterday writing the fen parser
18:52:39 <lispy> JoeyA: I don't think you need a type class for that
18:52:44 <JoeyA> (System.IO's Handle would be an instance, for instance)
18:52:49 <JoeyA> why not?
18:53:17 <lispy> JoeyA: Well, I think GHC currently uses one type for the handles
18:53:19 <megajosh2> Just use randomGen (if that's what the StdGen using function was called) to get an IO value
18:53:25 <megajosh2> ...
18:53:30 <JoeyA> I'm not talking about random numbers
18:53:31 <wakeupsticky> so basically i have 99% of the grunt work done and am about to get to the fun stuff
18:53:32 <megajosh2> I just got randomIO and randomGen mixed up lol
18:53:35 <JoeyA> Random access over a string
18:53:36 <EvanR> haha
18:53:40 <lispy> JoeyA: but maybe there was a resdesign that I missed where they started adding type classes for them
18:53:42 <JoeyA> (err, file or whatever)
18:53:51 <EvanR> Handle is not necessarily random access
18:53:53 <megajosh2> JoeyA: I'm sure there's a way to specify bounds
18:54:12 <EvanR> not all file descriptors support seeking
18:54:15 <JoeyA> In that case, is it possible to create arbitrary Handle handlers?
18:54:25 <EvanR> for example networking, and tape drives
18:54:31 <lispy> I can see someone adding phantom types to Handles so that you can tag them with extra capabilities though
18:54:56 <wakeupsticky> thanks, guys
18:55:11 <lispy> wakeupsticky: you're welcome.  Where will you publish it when done?
18:55:18 <Martty> > error $ error $ error $ error "***Exception!"
18:55:19 <lambdabot>   *Exception: *Exception: *Exception: *Exception: ***Exception!
18:55:36 <EvanR> > fix error
18:55:37 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:55:38 <lispy> > text "Danger Will Robinson! :: Doc
18:55:39 <lambdabot>   <no location info>:
18:55:39 <lambdabot>      lexical error in string/character literal at end o...
18:55:44 <lispy> > text "Danger Will Robinson!" :: Doc
18:55:45 <lambdabot>   Danger Will Robinson!
18:56:01 <JoeyA> @i Doc
18:56:02 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
18:56:07 <JoeyA> :i Doc
18:56:13 <lispy> JoeyA: Can you give me an example of what you mean by arbitrary Handle handler?
18:56:18 <lispy> I don't think i understand
18:56:30 <JoeyA> suppose I want to create a Handle for writing directly to a ByteString in memory
18:56:39 <JoeyA> rather than to a system file
18:56:48 <EvanR> a class which has read, write, open, and close
18:56:54 <lispy> JoeyA: you want to mmap the bytestring?
18:56:55 <JoeyA> Or suppose I want to frobnicate the text when reading/writing.
18:57:04 <megajosh2> frobnicate?
18:57:08 <megajosh2> Did you just make that word up?
18:57:11 <JoeyA> nope
18:57:12 <lispy> megajosh2: hehe, no
18:57:17 <lispy> ?wn frobnicate
18:57:18 <lambdabot> No match for "frobnicate".
18:57:36 <JoeyA> http://www.gnu.org/s/libc/manual/html_node/Trivial-Encryption.html
18:57:37 <lispy> http://catb.org/jargon/html/F/frobnicate.html
18:57:43 <EvanR> can haskell write directly to a bytestring in memory?
18:57:57 <megajosh2> For a real word, it sure does sound phony
18:58:27 <EvanR> if it uses ffi, might as well be a real Handle
18:58:34 <lispy> This notion of writing directly to things in memory is foreign to me
18:58:46 <lispy> I would need code samples
18:59:34 <EvanR> JoeyA is spending a awfully long time in IO land, maybe he needs a visit from the purity police
18:59:38 <lispy> EvanR: oh, I started to look at the takusen sources re: the over allocation you had with hdbc, I think it does the right thing and I just need to test it
18:59:47 <EvanR> lispy: good
19:00:25 <co_dh> can I use ` in variable name ? as a` ? ( the symbol on the left of 1)
19:00:38 <lispy> > let a`b = 1 in a`b
19:00:38 <lambdabot>   <no location info>: parse error on input `='
19:00:43 <lispy> co_dh: ^^
19:00:44 <megajosh2> Purity police? Like in Land of Lisp?
19:00:56 <jrockway> what lisp programmers write pure code?
19:01:01 <co_dh> > let a` = 1
19:01:02 <lambdabot>   <no location info>: parse error on input `='
19:01:08 * jrockway nconcs his lists
19:01:25 <co_dh> but I do remember you can do something similar, 
19:01:31 <co_dh> > let a' = 1
19:01:31 <lispy> jrockway: they write impure code with pure apis
19:01:32 <lambdabot>   not an expression: `let a' = 1'
19:01:38 <megajosh2> http://www.lisperati.com/landoflisp/panel57.html
19:01:40 <lispy> > let a' = 1 in a'
19:01:41 <lambdabot>   1
19:01:49 <co_dh> thanks , lispy
19:02:37 <jrockway> interestingly, i realized that i use something like ST in emacs all the time
19:02:53 <jrockway> i create a temp buffer (with-temp-buffer), mutate my text as appropriate, and then return the entire thing as a string
19:03:12 <jrockway> mutable inside with-temp-buffer, "pure" outside
19:03:43 <lispy> jrockway: You just made me hungry for snickers
19:03:47 <aristid> jrockway: your editing is "pure"?
19:04:03 <roconnor> jrockway: is it type safe?
19:04:10 <jrockway> hey, so what if you can launch the nuclear missiles from inside there
19:04:15 <lispy> aristid: immaculate conception of text
19:04:38 <lispy> Well, ST doesn't let you launch nuclear missiles
19:04:48 <jrockway> there is no type safety in emacs, of course
19:04:48 <lispy> It just lets you aim them
19:04:59 <jrockway> gotta work with what you've got
19:05:22 <jrockway> i only bring it up because i hear people say, "mutating that vector inside ST is weird/confusing/evil"
19:05:35 <jrockway> but in reality, people do stuff like this even when the langauge doesn't enforce purity
19:05:38 <jrockway> because it's a good idea
19:05:56 <aristid> jrockway: oh, you use with-temp-buffer in your emacs lisp programming!
19:06:02 <jrockway> (why did i bring this up? because i'm writing lisp in the other window, and be case someone mentioned something about mutating bytestrings)
19:06:05 <aristid> i thought it was in your file editing routine
19:06:09 <aristid> which would be confusing
19:06:13 <jrockway> yeah
19:07:05 <lispy> megajosh2: heh, I thought his uncle was mr natural at first
19:08:25 <Martty> whats the all but last list function
19:09:24 <lispy> > tail [1..4]
19:09:24 <megajosh2> All but last?
19:09:25 <lambdabot>   [2,3,4]
19:09:25 <megajosh2> Init?
19:09:33 <lispy> > init [1..4]
19:09:33 <megajosh2> > init [1..5]
19:09:33 <lambdabot>   [1,2,3]
19:09:34 <lambdabot>   [1,2,3,4]
19:09:36 <megajosh2> Yup
19:09:41 <Martty> thx
19:14:24 * lispy notes that he too is a defector from the land of lisp to the republic of haskell
19:14:35 <aristid> :t zip<*>init
19:14:37 <lambdabot> forall b. [b] -> [(b, b)]
19:15:02 <aristid> > zip<*>init $ [1,2,3]
19:15:04 <lambdabot>   [(1,1),(2,2)]
19:17:16 <lispy> > fix $ \xs -> zipWith (+) <*> init $ [0,1] xs
19:17:17 <lambdabot>   Couldn't match expected type `t -> [a]'
19:17:17 <lambdabot>         against inferred type `[a1]'
19:17:29 <lispy> > fix $ \xs -> zipWith (+) <*> init $ [0,1] ++ xs
19:17:30 <lambdabot>   [0,2,0,4,0,8,0,16,0,32,0,64,0,128,0,256,0,512,0,1024,0,2048,0,4096,0,8192,0...
19:17:43 <lispy> > fix $ \xs -> zipWith (+) <*> init $ [1] ++ xs
19:17:47 <lambdabot>   mueval-core: Time limit exceeded
19:17:53 <megajosh2> Lol well then
19:18:10 <co_dh> :t zip
19:18:11 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
19:18:14 <aristid> > fix $ \xs -> zipWith (+) <*> init $ [1,1] ++ xs
19:18:15 <lambdabot>   [2,2,4,4,8,8,16,16,32,32,64,64,128,128,256,256,512,512,1024,1024,2048,2048,...
19:18:32 <co_dh> :t <*>
19:18:33 <lambdabot> parse error on input `<*>'
19:18:36 <lispy> > fix $ \xs -> zipWith (+) <*> init $ [2,1] ++ xs
19:18:37 <lambdabot>   [4,2,8,4,16,8,32,16,64,32,128,64,256,128,512,256,1024,512,2048,1024,4096,20...
19:18:40 <co_dh> :t (<*>)
19:18:41 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:18:42 <megajosh2> :t Control.Applicative(<*>)
19:18:44 <lambdabot> Couldn't find qualified module.
19:18:50 <megajosh2> Woopsie?
19:18:54 <megajosh2> :t Control.Applicative.(<*>)
19:18:55 <lambdabot> Couldn't find qualified module.
19:18:57 <lispy> > fix $ \xs -> zipWith (+) <*> init $ [8,1] ++ xs
19:18:57 <lambdabot>   [16,2,32,4,64,8,128,16,256,32,512,64,1024,128,2048,256,4096,512,8192,1024,1...
19:18:58 <megajosh2> Meh
19:19:14 <lispy> > fix $ \xs -> zipWith (+) <*> init $ [-1,1] ++ xs
19:19:15 <lambdabot>   [-2,2,-4,4,-8,8,-16,16,-32,32,-64,64,-128,128,-256,256,-512,512,-1024,1024,...
19:19:22 <lispy> I like it
19:22:43 <lispy> > fix $ \xs -> zipWith (+) <*> init $ [-1,1,1] ++ xs
19:22:44 <lambdabot>   [-2,2,2,-4,4,4,-8,8,8,-16,16,16,-32,32,32,-64,64,64,-128,128,128,-256,256,2...
19:22:52 <lispy> > fix $ \xs -> zipWith (+) <*> init $ [-1,1,0] ++ xs
19:22:53 <lambdabot>   [-2,2,0,-4,4,0,-8,8,0,-16,16,0,-32,32,0,-64,64,0,-128,128,0,-256,256,0,-512...
19:22:54 <co_dh> I don't understand why the type of    zip <*> init is [b] -> [(b,b)]
19:23:04 <lispy> :t zip <*>
19:23:04 <lambdabot> parse error (possibly incorrect indentation)
19:23:16 <lispy> :t (<*>) zip
19:23:17 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [(a, b)]
19:23:28 <lispy> co_dh: does that help?
19:23:32 <megajosh2> :t (<*>)
19:23:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:23:35 <megajosh2> :t map
19:23:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:24:04 <keeperofdakeys> putStrLn [1..9]
19:24:11 <co_dh> lispy: still reading, thanks.
19:24:14 <Axman6> > zip <*> init $ [1,2,3]
19:24:15 <lambdabot>   [(1,1),(2,2)]
19:24:19 <Olivier> Hi. How would you write a function that computes all the cycles of a directed graph in Haskell ? (the real question is how to write a "recursive" set comprehension)
19:24:19 <Axman6> :\
19:24:22 <megajosh2> You're going to print a list with a function that takes a string? <_<
19:24:42 <lispy> > zip <*> id $ [1..3]
19:24:43 <lambdabot>   [(1,1),(2,2),(3,3)]
19:24:50 <megajosh2> Hmm...
19:25:22 <Olivier> cycle = {}, then {i -> j}, then {i -> j -> k} etc.
19:25:31 <aristid> > zip <*> reverse $ [1..3]
19:25:32 <lambdabot>   [(1,3),(2,2),(3,1)]
19:25:51 <keeperofdakeys> putStrLn $ show [1..9]
19:26:11 <keeperofdakeys> [1..9]
19:26:33 <megajosh2> keeperofdakeys: Use `> '
19:26:34 <keeperofdakeys> zip [1..9] [2..10]
19:26:40 <lispy> co_dh: do you know how fmap works on tuples?
19:26:44 <megajosh2> > putStrLn $ show [1..9]
19:26:45 <lambdabot>   <IO ()>
19:26:51 <lispy> > fmap succ (1,1)
19:26:52 <lambdabot>   (1,2)
19:27:02 <lispy> co_dh: notice that it only works on the second element
19:27:09 <co_dh> lispy: yes, it apply to the second element of the tuple.
19:27:09 <megajosh2> lambdabot: I think it ...yeah
19:27:18 <megajosh2> ...
19:27:28 <keeperofdakeys> > zip [1..9] [2..10]
19:27:29 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
19:27:47 <keeperofdakeys> > [1..9]
19:27:48 <lambdabot>   [1,2,3,4,5,6,7,8,9]
19:28:06 <aristid> :t fmap (fmap succ)
19:28:07 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Enum a, Functor f, Functor f1) => f1 (f a) -> f1 (f a)
19:28:17 <lispy> :t fmap fmap fmap
19:28:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:28:22 <keeperofdakeys> I wonder what lambda bot will do with an infinite list? I'm not game enough to find out
19:28:24 <megajosh2> Oh dear god
19:28:32 <lispy> > [1..]
19:28:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:28:34 <aristid> > (succ .) . [1..]
19:28:35 <lambdabot>   No instances for (GHC.Num.Num (f a), GHC.Enum.Enum (f a))
19:28:35 <lambdabot>    arising from a...
19:28:39 <megajosh2> keeperofdakeys: It only prints so many characters from it
19:29:05 <lispy> > succ <$> [1..]
19:29:06 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
19:29:08 <luite> randomwords: wow this is quite an annoying build process
19:29:09 <megajosh2> You can make sections with . ?
19:29:15 <lispy> megajosh2: yeah
19:29:18 <lispy> :t (succ .)
19:29:19 <lambdabot> forall a (f :: * -> *). (Enum a, Functor f) => f a -> f a
19:29:19 <aristid> > (succ .) . (zip <*>id) $ [1..]
19:29:20 <lambdabot>   No instance for (GHC.Enum.Enum (a, a))
19:29:20 <lambdabot>    arising from a use of `e_11' at <...
19:29:32 <megajosh2> I tried doing that in my GHCi and it yelled at me
19:29:47 <megajosh2> Hmm... must have been some type error
19:30:36 <steshaw> :type Data.Map.lookup
19:30:50 <steshaw> @type Data.Map.lookup
19:30:51 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
19:31:07 <co_dh> :t pure succ 
19:31:08 <lambdabot> forall a (f :: * -> *). (Enum a, Applicative f) => f (a -> a)
19:31:12 <steshaw> @type flip Data.Map.lookup
19:31:13 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> Maybe a
19:31:27 <co_dh> what is the f in type of pure succ here ? not decided yet ? 
19:31:33 <steshaw> @let flookup = flip Data.Map.lookup
19:31:34 <lambdabot>  <local>:1:15: Not in scope: `Data.Map.lookup'
19:32:52 <luite> randomwords: I think I'm almost done though, libz, libpng, libjpeg are all installed, libgd just compiled ok
19:33:25 <co_dh> lispy: <*> expect a f ( a-> b) as first argument , but how comes zip match that type? 
19:37:20 <co_dh> > 1 + 1
19:37:21 <lambdabot>   2
19:37:26 <co_dh> anybody? 
19:38:33 <megajosh2> co_dh: I'm pretty sure <*> is just a synonym for fmap
19:38:37 <lispy> :t zip
19:38:38 <megajosh2> :t (<*>)
19:38:38 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
19:38:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:38:39 <megajosh2> :t fmap
19:38:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:38:47 <megajosh2> Well, sort of
19:39:15 <co_dh> @src (<*>)
19:39:16 <lambdabot> Source not found. stty: unknown mode: doofus
19:39:21 <lispy> megajosh2: you're thinking of <$>
19:39:29 <co_dh> @src ((->) a ) (<*>)
19:39:29 <lambdabot> Source not found. You untyped fool!
19:39:58 <lispy> co_dh: I think it's using Functor ((->) r)
19:40:28 <aristid> @src (->) (<*>)
19:40:28 <lambdabot> (<*>) f g x = f x (g x)
19:40:32 <aristid> there, co_dh
19:40:33 <co_dh> lispy: that's the instance of application that I don't understand. 
19:40:47 <lispy> suppose, f = ((->) r), then f (a -> b) = ((-> r) (a -> b) = r -> (a -> b) = r -> a -> b, right
19:40:53 <co_dh> aristid: thanks.
19:42:00 <lispy> so, then zip :: [a] -> [b] -> [(a,b)], then let r = [a], a= [b], and b = [(a,b)] (oh, I'm sneaky with my names....)
19:43:23 <lispy> That means, that (zip <*>) :: f a -> f b, where f = ((->) r)
19:45:14 <co_dh> lispy: I got it, thanks a lot. 
19:46:00 <co_dh> is there a tool can explain this type match procedure for us ? like the sum [a , b , c]
19:46:04 <co_dh> > sum [c,d,e]
19:46:05 <lambdabot>   0 + c + d + e
19:46:13 <co_dh> :t sum [c,d]
19:46:14 <lambdabot> Expr
19:46:48 <lispy> co_dh: what do you mean by type match procedure?
19:47:01 <lispy> co_dh: you want to see how type inferencing/checking works?
19:47:07 <co_dh> yes, 
19:47:25 <co_dh> by something like Expr, 
19:47:51 <lispy> co_dh: You'd probably like the paper, "Typing Haskell in Haskell"
19:47:53 <co_dh> because this type inferencing is hided by ghc, and is difficult for newbies.
19:48:01 <lispy> co_dh: they give a rather simple type checker for haskell written in Haskell
19:48:17 <co_dh> lispy: oh, that title make me scared , but I'll try , thanks. 
19:48:23 <lispy> Oh, well I agree it would be nice to have visualizations of type checking happening but I don't know any research on the topic
19:48:47 <lispy> A type level debugger has been on my wish list for some type
19:48:51 <lispy> er time :)
19:49:05 <co_dh> one of ( the only one ? ) the good thing about imperative programming is you can visualize the state in a debug :)
19:49:23 <co_dh> a debugger
19:49:35 <lispy> debuggers are a weak spot for haskell, it's true
19:49:42 <lispy> But, those imperative languages have decades on us
19:49:47 <lispy> We're playing catchup in some areas
19:50:03 <aristid> you need a debugger for routine tasks in C and similar languages
19:50:09 <co_dh> decades of commercial support. 
19:50:13 <aristid> which is not an advantage.
19:50:28 <co_dh> it's an advantage when reading code. 
19:50:36 <aristid> no
19:50:43 <lispy> co_dh: Well, Ghci has a debugger if you ever want to try it
19:50:58 <lispy> co_dh: Type level debugging though...that's where it's at for the stuff I do in Haskell
19:51:05 <co_dh> yes, I tried. very usefull at some point. 
19:51:06 <lispy> Yet I don't have one
19:52:04 <lispy> co_dh: if you wrote a type check visual debugger for haskell I'm sure you could get some research papers out the experience :)
19:52:43 <co_dh> I didn't have a job yet, and have a family to support :(
19:52:51 <co_dh> I don't.
19:53:03 <lispy> first things first
19:53:06 <luite> randomwords: hmm, I still get an werror when doing cabal install gd
19:53:44 <randomwords> luite: That's about where I got to
19:54:05 <luite> randomwords: internal compiler error: in rest_of_handle_final, at toplev.c:2067
19:56:20 <co_dh> what else can be used as the first argument of <*>, other then zip and pure f ? 
19:56:34 <co_dh> :t (<*> (+)
19:56:35 <lambdabot> parse error (possibly incorrect indentation)
19:56:42 <co_dh> :t ( <*> (+) )
19:56:43 <lambdabot> forall b a. (Num a) => (a -> (a -> a) -> b) -> a -> b
19:57:32 <sshc> Does callCC create a continuation, that, when given another contiuation, calls that given continuation and then passes the same result to the continuation?
19:57:45 <luite> randomwords: oh it installed now, do you have a simple test program for gd?
19:57:46 <co_dh> > (+) <*> (\i -> \f -> 2) 3
19:57:47 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:57:47 <lambdabot>    arising from a use of `...
19:57:52 <sshc> ...and then passes the result to the same continuation?
19:58:16 <randomwords> Not to hand sorry
19:58:48 <co_dh> :t (+) <*>  (\i -> \f -> 2) 
19:58:49 <lambdabot> forall t t1. (Num (t -> t1), Num t1) => (t -> t1) -> t -> t1
19:59:34 <randomwords> luite: How did you resolve that compiler error, it's the same one I had
20:00:10 <luite> randomwords: manually define BGDWIN32 in gd.h
20:00:53 <luite> if I can get a simple gd program to work, I'll upload some instructions and binaries
20:01:09 <randomwords> Wonderful :)
20:02:23 <sshc> Anybody?
20:02:31 <aristid> :t (+) <*> (*2)
20:02:32 <lambdabot> forall a. (Num a) => a -> a
20:02:42 <aristid> > (+) <*> (*2) $ 3
20:02:43 <lambdabot>   9
20:03:03 <aristid> > (/) <*> (+1) $ 3
20:03:04 <lambdabot>   0.75
20:05:22 <Mitar> is there a way to wait for multiple SampleVars at the same time? so that any one gets filled my thread wakes?
20:07:25 <luite> randomwords: bah undefined references, I must have messed something up
20:09:10 <JoeyA> Mitar: I've never used threads in Haskell, but maybe you can make something work with QSem (semaphores)
20:09:48 <JoeyA> As in, when any of the vars is filled in, signalQSem the semaphore
20:09:50 <Mitar> hm, i am using SampleVar, which it seems is extension to semaphore to allow any type to be used
20:09:54 <JoeyA> The waiter would waitQSem on it.
20:10:23 <jrockway> do you need multiple samplevars or can you write a tuple to a single samplevar?
20:10:47 <JoeyA> jrockway: He wants it to wake up if at least one gets filled, not all.
20:10:52 <Mitar> i have multiple threads filling each own samplevar
20:10:53 <JoeyA> Not sure if a tuple will do.
20:11:05 <co_dh> > (+) <*> (*a) b
20:11:05 <Mitar> and then i want one thread to wait for any of those and processes it
20:11:06 <lambdabot>   Couldn't match expected type `a -> a'
20:11:06 <lambdabot>         against inferred type `Simple...
20:11:19 <co_dh> > (+) <*> (*a) $ b
20:11:20 <lambdabot>   b + b * a
20:11:58 <randomwords> luite: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29566#a29566 There's something to test it with. I can't test if it compiles, but I think it's just about right
20:12:13 <co_dh> > f <*> g $ a
20:12:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:12:14 <lambdabot>    `SimpleReflect.FromExpr ...
20:12:31 <co_dh> > f <*> g $ 1
20:12:32 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:12:32 <lambdabot>    `SimpleReflect.FromExpr ...
20:12:38 <co_dh> >t f
20:12:39 <luite> randomwords: I already have something, but it doesn't link
20:13:28 <co_dh> @src (->) <*>
20:13:29 <lambdabot> Source not found. There are some things that I just don't know.
20:13:38 <co_dh> @src (->) (<*>)
20:13:38 <lambdabot> (<*>) f g x = f x (g x)
20:14:01 <co_dh> damn it, <*> is the S combinator .
20:14:33 <luite> randomwords: this is what i've done so far, that allowed me to install the cabal package, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29567#a29567
20:14:55 <luite> randomwords: maybe you have an idea what to do next :)
20:15:30 <luite> randomwords: I don't like having to remove the .la files, but they seem to be wrong or something, even though I have no idea why. libtool complains if I leave them there
20:16:32 <aristid> :t f <*> g
20:16:33 <lambdabot> forall (f :: * -> *) a b. (SimpleReflect.FromExpr (f (a -> b)), SimpleReflect.FromExpr (f a), Applicative f) => f b
20:16:40 <aristid> :t f <*> g $ a
20:16:41 <lambdabot>     Ambiguous type variable `a' in the constraints:
20:16:42 <lambdabot>       `SimpleReflect.FromExpr a'
20:16:42 <lambdabot>         arising from a use of `g' at <interactive>:1:6
20:17:00 <aristid> :t (f :: Expr -> Expr -> Expr) <*> g $ a
20:17:01 <lambdabot> Expr
20:17:05 <aristid> > (f :: Expr -> Expr -> Expr) <*> g $ a
20:17:06 <lambdabot>   f a (g a)
20:18:23 <co_dh> aristid: cool!
20:19:18 <siracusa> Mitar: I don't know what SampleVars are, but maybe you want one thread listening on a channel (Control.Concurrent.Chan) and write to the channel when a Var gets filled.
20:19:23 <sshc> Is there a Parsec that works with transformers?
20:19:58 <Mitar> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Control-Concurrent-SampleVar.html
20:20:30 <Mitar> good side of samplevars for me is that values are overridden if there is something new
20:21:10 <Mitar> so if producer is making more values then consumer can handle, then consumer still gets just the last value
20:21:50 <JoeyA> What's a good way to play around with a Handles and IO thunks deferred with unsafeInterleaveIO?
20:22:04 <JoeyA> For instance, suppose I get a file handle, and hGetContents with it
20:22:22 <JoeyA> Now, that Handle's file position is going to be advanced as reading proceeds.
20:22:33 <sshc> Ag, I still don't understand how callCC works
20:22:34 <JoeyA> (assume the file handle is seekable)
20:22:55 <aristid> @src callCC
20:22:55 <lambdabot> Source not found. stty: unknown mode: doofus
20:23:30 <JoeyA> What if I want to seek to a position and read it?  How can I do it safely in the presence of hGetContents's shenanigans?
20:24:00 <JoeyA> just put the handle back when I'm done with it and don't access the data generated by hGetContents?
20:24:18 <sshc> "unknown mode: doofus"?
20:24:30 <sshc> @src map
20:24:30 <lambdabot> map _ []     = []
20:24:30 <lambdabot> map f (x:xs) = f x : map f xs
20:24:36 <sshc> @src callCC
20:24:36 <lambdabot> Source not found. :(
20:25:10 <sshc> What does callCC do with the function it takes?
20:25:58 <JoeyA> Calls it, passing the current continuation to it.
20:26:01 <roconnor> sshc: it passes the current continuation to it and runs it
20:26:12 <JoeyA> (I think)
20:26:16 <sshc> What it the current contiunation, then?
20:26:19 <sshc> It only takes one argument
20:26:20 <sshc> A function
20:26:35 <sshc> How does it know what the "current continuation" is, whatever that is?
20:26:43 <roconnor> sshc: "the rest of the program" from the CallCC
20:27:13 <roconnor> sshc: the monad is structured so that it has access to the current continuation
20:27:42 <sshc> Hmm.  Does the result of that function get passed to the contiunation again?
20:28:01 <roconnor> the result of which function?
20:28:20 <sshc> The funtion you pass to callC
20:28:29 <sshc> What does callCC do with the result of that function?
20:28:44 <roconnor> sshc: the result of the callCC is the result of that function unless...
20:29:15 <roconnor> sshc: that function calls the passed continutation, in which case the result of callCC is the argument passed to the continuation
20:29:50 <sshc> Are you sure about your latter statement?  I don't see how that's possible
20:29:52 <roconnor> > runCont (callCC (\k -> return 5)) id
20:29:53 <lambdabot>   5
20:30:05 <roconnor> > flip runCont id (callCC (\k -> return 5))
20:30:06 <lambdabot>   5
20:30:18 <dolio> It's possible because the thing passed in has type a -> m b.
20:30:33 <roconnor> > flip runCont id (callCC (\k -> if True then return 5 else return 6))
20:30:35 <lambdabot>   5
20:30:39 <roconnor> > flip runCont id (callCC (\k -> if False then return 5 else return 6))
20:30:40 <lambdabot>   6
20:30:44 <sshc> > runCont (callCC $ \k -> k 3) id
20:30:45 <lambdabot>   3
20:30:45 <roconnor> > flip runCont id (callCC (\k -> if k 7 then return 5 else return 6))
20:30:46 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:30:46 <lambdabot>         against inferred type ...
20:30:49 <sshc> > runCont (callCC $ \k -> return 3) id
20:30:50 <lambdabot>   3
20:30:55 <roconnor> gah
20:30:59 <sshc> What different does return make?
20:31:37 <FunctorSalad_> > runCont (callCC $ \k -> k 3 >> return 4) id
20:31:38 <lambdabot>   3
20:31:53 <roconnor> things get more fun when callCC is not the outer most construct
20:32:10 <roconnor> and even more fun when k is what is returned
20:32:14 <FunctorSalad_> (see, it jumps out)
20:32:44 <sshc> What does the function (passed to callCC) need to return?
20:32:47 <FunctorSalad_> roconnor: o_O that types?
20:33:01 <FunctorSalad_> sshc: it's a bit like 'error'
20:33:04 <roconnor> FunctorSalad_: I think so, so long as you don't leave the runCont
20:33:23 * sshc confused
20:33:34 <FunctorSalad_> it never 'returns' as in executing the next line of the do block it's in
20:33:34 <roconnor> sshc: it is very confusing
20:33:47 <FunctorSalad_> yes I don't really know what I'm talking about either
20:34:18 <FunctorSalad_> (but it's perfectly pure, not using the IO exception mechanism like 'error')
20:34:21 <FunctorSalad_> )
20:34:59 <sshc> > flip runCont succ $ callCC $ \k -> k 2
20:35:00 <lambdabot>   3
20:35:13 <sshc> I thought that'd result in 5
20:35:17 <sshc> 4*
20:35:30 <roconnor> @type callCC (\k -> Left (\a -> k (Right a)))
20:35:31 <lambdabot>     Occurs check: cannot construct the infinite type:
20:35:31 <lambdabot>       m = Either (b1 -> m b)
20:35:31 <lambdabot>       Expected type: m (Either a b1)
20:35:37 <aristid> :t runCont
20:35:38 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
20:35:47 <roconnor> @type callCC (\k -> return (Left (\a -> k (Right a))))
20:35:48 <lambdabot> forall (m :: * -> *) b b1. (MonadCont m) => m (Either (b1 -> m b) b1)
20:35:53 <aristid> :t callCC $ \k -> k 2
20:35:54 <lambdabot> forall (m :: * -> *) b. (MonadCont m, Num b) => m b
20:36:15 <sshc> Since, if I understand it correctly, k refers to the contiunation, succ, and calls succ with 2, and gives that result to the contiuation, resulting in 4
20:36:39 <dolio> succ 2 = 4 now/
20:36:41 <sshc> Clearly I don't understand it correctly
20:36:58 <sshc> No, succ is being called with (succ 2), which is 3
20:37:06 <sshc> would
20:37:10 <dolio> Why is it being called with that?
20:37:14 <FunctorSalad_> from the POV of the argument to callCC, 'k' is a bit like an actual 'return' statement in the sense of imperative langs
20:37:44 <dolio> k is a jump to the continuation, which is succ.
20:37:54 <dolio> So you're jumping to it with 2, which results in succ 2.
20:38:40 <FunctorSalad_> (hmm at least with Cont... with ContT I guess it can make sense to invoke k multiple times?)
20:39:03 <FunctorSalad_> confused too :-(
20:39:21 <dolio> It's possible to invoke continuations multiple times, although it's harder in a typed setting.
20:39:33 <dolio> Whether Cont or ContT.
20:39:43 <roconnor> > let {f (Left (n,k)) = n+k (Right 6); f (Right m) = m} in flip runCont id (f (callCC (\k -> return (Left (5,k))))
20:39:45 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:39:46 <FunctorSalad_> but with Cont it's pointless isn't it?
20:39:50 <dolio> But they never return to where you call them.
20:39:56 <dolio> At least, not this kind
20:40:07 <tmo__> Question for new person in haskell: I decided to get my feet wet by writing a GUI in haskell with gtk2hs, and I'm wondering if there's anything better explaination of how action binding works for menus.
20:40:10 <FunctorSalad_> hmm ok so the analogy to imperative 'return' isn't that bad?
20:40:24 <sshc> > flip runCont succ $ callCC $ \k -> k 2 + k 9
20:40:25 <lambdabot>   No instance for (GHC.Num.Num (Control.Monad.Cont.Cont b b))
20:40:25 <lambdabot>    arising from...
20:41:37 <FunctorSalad_> > flip runContT runWriter $ callCC $ \k -> tell ["oh"] >> k 1 >> tell ["hai"] >> k 2
20:41:42 <lambdabot>   No instances for (GHC.Base.Monad ((,) a),
20:41:47 <lambdabot>                    Control.Monad....
20:42:01 <roconnor> sshc: return (k 2 + k 9)
20:42:16 <sshc> > flip runCont succ $ callCC $ \k -> return $ k 2 + k 9
20:42:17 <lambdabot>   Occurs check: cannot construct the infinite type:
20:42:17 <lambdabot>    a = Control.Monad.Cont...
20:42:22 <roconnor> er
20:42:26 <FunctorSalad_> > flip runContT (runWriter . return) $ callCC $ \k -> tell ["oh"] >> k 1 >> tell ["hai"] >> k 2
20:42:27 <lambdabot>   No instances for (GHC.Base.Monad ((,) b),
20:42:27 <lambdabot>                    Control.Monad....
20:42:27 <sshc> roconnor: Putting return in there really confuses me now
20:42:35 <roconnor> sshc: liftM2 (+) (k 2) (k 9)
20:42:39 <sshc> roconnor: Which type is return using there now?
20:42:44 <FunctorSalad_> @ty runContT
20:42:45 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
20:42:49 <roconnor> ssh return was wrong
20:42:52 <roconnor> my bad
20:43:22 <FunctorSalad_> > flip runContT (listen . return) $ callCC $ \k -> tell ["oh"] >> k 1 >> tell ["hai"] >> k 2
20:43:23 <lambdabot>   No instance for (GHC.Show.Show (m (b, w)))
20:43:23 <lambdabot>    arising from a use of `M87772...
20:43:34 <FunctorSalad_> > runWriter $ flip runContT (listen . return) $ callCC $ \k -> tell ["oh"] >> k 1 >> tell ["hai"] >> k 2
20:43:35 <lambdabot>   No instance for (Control.Monad.Writer.Class.MonadWriter
20:43:35 <lambdabot>                    ...
20:43:39 * FunctorSalad_ gives up
20:43:39 <sshc> > flip runCont succ $ callCC $ \k -> liftM2 (+) (k 2) (k 9)
20:43:40 <lambdabot>   3
20:43:52 <sshc> How does return or bind make sense in a callCC?
20:43:55 <FunctorSalad_> > runWriter $ flip runContT return $ callCC $ \k -> tell ["oh"] >> k 1 >> tell ["hai"] >> k 2
20:43:56 <lambdabot>   No instance for (Control.Monad.Writer.Class.MonadWriter
20:43:56 <lambdabot>                    ...
20:44:11 <roconnor> sshc: your calls to k 2 and k 9 need to be ordered
20:44:14 <sshc> > flip runCont succ $ callCC $ \k -> 3
20:44:15 <lambdabot>   No instance for (GHC.Num.Num (Control.Monad.Cont.Cont a a))
20:44:15 <lambdabot>    arising from...
20:44:20 <sshc> > flip runCont succ $ callCC $ \k -> return 3
20:44:21 <lambdabot>   4
20:44:29 <roconnor> sshc:  so that we know if the result should be (succ 3) or (succ 9)
20:44:41 <FunctorSalad_> what am I doing wrong?
20:44:48 <FunctorSalad_> in the last attempt ;)
20:44:49 <sshc> Hmm.  So it sort of escapes when k is first called.
20:44:49 <roconnor> i.e. you are calling (k 2) "before" (k 9)
20:44:54 <roconnor> yes
20:44:59 <sshc> Interesting, but I'm still mostly clueless and have no idea how that's possible
20:45:14 <sshc> Maybe I'm misunderstanding what k refers to
20:45:39 <lispy> sshc: it's the future
20:45:42 <dolio> How is it possible that putStrLn "Foo" actually prints "Foo" on the screen?
20:45:54 <aristid> in ghci?
20:45:56 <sshc> lispy: What is its type?
20:46:05 <sshc> lispy: Cont r a?
20:46:12 <roconnor> sshc: good question.  it is a very intersting type
20:46:15 <lispy> ?unmtl Cont r a
20:46:15 <lambdabot> (a -> r) -> r
20:46:28 <lispy> sshc: k :: (a -> r), IIRC
20:46:32 <roconnor> sshc: the type of k is a -> m b, where m is the cont monad.
20:46:43 <roconnor> sshc: notice that the result of k is anything!
20:47:00 <roconnor> this is because once k is called with a, the rest of the inner funciton is aborted
20:47:12 <roconnor> so k can be called in anytime you want
20:47:40 <sshc> callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a
20:47:40 <sshc> callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \_ -> c a)) c
20:47:42 <roconnor> it can return any result because the computation won't ever get there
20:47:55 <FunctorSalad_> dolio: hmm? but Cont[T] isn't like that AIUI
20:47:55 <roconnor> in fact, it is better to think of it as returning no result
20:48:01 <JoeyA> Wow, I can't seem to find the Haskell analogue to g_signal_connect in the documentation.
20:48:21 <dolio> FunctorSalad_: Isn't like what? Doesn't represent effects using a monad?
20:48:24 <FunctorSalad_> it can promise to return anything once it returns, because it won't ever return, just like error or exitWith
20:48:49 <FunctorSalad_> dolio: 'has special compiler support'
20:49:14 <dolio> That wasn't really my point.
20:49:46 <FunctorSalad_> just saying why it's a potentially misleading example :)
20:49:49 <sshc> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
20:50:37 <sshc> So callCC creates a contiunation
20:50:41 <sshc> c refers to the continuation
20:50:44 <sshc> the "current contiunation"
20:50:58 <roconnor> nope
20:51:06 <lispy> Cont $ \_ -> c a  <-- that's where the magic of callCC happens
20:51:08 <roconnor> er
20:51:12 * roconnor rethinks
20:51:17 <roconnor> yes
20:51:18 <lispy> that _ is where it's ignoring the current future, it's the abort
20:51:30 <roconnor> I guess c is the current continuation
20:51:48 <sshc> runCont _ c -- um, doesn't that always give the result of the contiunation to c?
20:52:07 <roconnor> yes
20:52:12 <roconnor> well
20:52:12 <sshc> So the continuation would be used twice?
20:52:18 <roconnor> it gives c to the result
20:52:23 <roconnor> c is the final continuation
20:52:36 <roconnor> and is often id.
20:53:02 <roconnor> f (runCont foo id) == runCont foo f
20:53:25 <sshc> It gives the result of whatever that continuation is the "current contiunation", which is c, it looks like
20:53:35 <sshc> Now to understand that contiunation
20:53:52 <lispy> c a continuation, but as roconnor says it's the final one
20:53:53 <FunctorSalad_> I find the 'current' confusing too... maybe one could just call it "what to do with the result"?
20:54:03 <lispy> the current continuation is actually the inner one
20:54:12 <lispy> But we're ignoring it
20:54:18 <lispy> and replacing it with c
20:54:23 <lispy> and then applying f to the result
20:54:47 <FunctorSalad_> Cont r a = (a -> r) -> r.... "if you tell me how to make r from a, I'll get you an r" ;)
20:55:08 <tmo__> Also, what exactly does the type signature for mapM_ mean?
20:55:18 <lispy> :t mapM_
20:55:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:55:36 <tmo__> I know how to obtain it, but I'm wondering how do you interpret it. :P
20:55:40 <lispy> tmo__: it means, given a way to construct m b from a, and [a], I'll give you nothing.
20:55:50 <FunctorSalad_> \o/
20:56:43 <roconnor> (a -> r) -> r  has a lot of the properties that a has
20:56:47 <lispy> tmo__: for example, if (a -> m b) is a way to empty a bank account, and [a] are bank accounts then well...
20:56:58 <tmo__> I see.
20:56:58 <roconnor> forall r. (a -> r) -> r is very much like an a.
20:56:59 <tmo__> Thanks
20:58:35 <lispy> I really don't know how schemers learn continuations.  If I had studied them back when I did lisp, without types, I would have been even more lost than I am now
20:59:44 <tmo__> How could that be? Everyone knows that lisp is the most advance functional language for everything! </paulgraham>
20:59:56 <tmo__> *advanced
21:00:16 <FunctorSalad_> tmo__: it performs the effects involved in producing the bs, but discards them
21:00:50 <lispy> tmo__: yes, it was too advanced for me.  Without static types I had to work a lot harder to understand debug my programs.  Same for having side-effects.
21:00:56 <FunctorSalad_> > runWrtier $ mapM_ (\x -> tell "nom " >> return x) [1..7]
21:00:57 <lambdabot>   Not in scope: `runWrtier'
21:01:02 <FunctorSalad_> > runWriter $ mapM_ (\x -> tell "nom " >> return x) [1..7]
21:01:03 <lambdabot>   ((),"nom nom nom nom nom nom nom ")
21:01:06 <FunctorSalad_> lol
21:01:55 <FunctorSalad_> (I was so unexpecting of it finally compiling that I was surpised by the result)
21:02:13 <lispy> > runWriter $ mapM_ (\lol -> tell (lol ++ " what?") >> return lol) [1..5]
21:02:14 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
21:02:14 <lambdabot>    arising from the literal ...
21:02:28 <lispy> > runWriter $ mapM_ (\lol -> tell (lol ++ " what?") >> return lol) "nom"
21:02:29 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
21:02:29 <lambdabot>         against inferred ty...
21:02:40 <lispy> > runWriter $ mapM_ (\lol -> tell (lol ++ " what?") >> return lol) ["nom", "nom", "nom"]
21:02:40 <lambdabot>   ((),"nom what?nom what?nom what?")
21:04:19 <FunctorSalad_> lispy: just explaining while I'm laughing at lambdabot nom'ing even though I ordered it to
21:04:31 <dolio> > flip runCont id $ callCC $ \k -> foldM (\r e -> if e == 0 then k 0 else return (r*e)) 1 ([1 .. 10] ++ [0] ++ [1..])
21:04:31 <lambdabot>   0
21:04:34 <FunctorSalad_> I didn't expect it to work after all my failures with writer here ;)
21:05:13 <lispy> FunctorSalad_: in your other example, don't you need a lift on the tells?
21:05:26 <lispy> :t lift . tell
21:05:27 <lambdabot> forall (m :: * -> *) (t :: (* -> *) -> * -> *) w. (MonadTrans t, MonadWriter w m) => w -> t m ()
21:05:38 <FunctorSalad_> lispy: hmm... ContT r (Writer w) whould be a MonadWriter
21:05:50 <lispy> would it?
21:05:57 <FunctorSalad_> *should (typo)
21:05:57 <lispy> :i ContT r (Writer w)
21:06:20 <lispy> I don't really know the instances, TBH
21:06:23 <dolio> You can't write pass.
21:06:29 <dolio> So it's not a MonadWriter.
21:06:50 <dolio> One of the deficiencies of the mtl layout.
21:07:00 <FunctorSalad_> pass = error "nobody uses this anyway"
21:07:04 <FunctorSalad_> ;)
21:07:09 <FunctorSalad_> @type pass
21:07:10 <dolio> Yeah, pretty much.
21:07:10 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
21:07:16 <dolio> pass is weird.
21:08:10 <dolio> censor :: (w -> w) -> m a -> m a makes much more sense to me, and I think you can make a ContT instance with it.
21:08:43 <FunctorSalad_> they seem equivalent for plain Writer
21:09:19 <FunctorSalad_> while with pass the censoring function may be made using effects of the inner monad?
21:10:05 <dolio> Something like that.
21:10:13 <dolio> I don't know why you'd need that functionality, though.
21:10:57 <FunctorSalad_> pass :: (w,(a,w -> w)) -> (w, a), censor :: (w -> w) -> (w,a) -> (w,a)
21:11:17 <roconnor> > flip runCont id (do {(m,f) <- (callCC (\k -> return (7, \n -> if n <= 0 then return n else k (pred n,return)))); f m})
21:11:19 <lambdabot>   6
21:11:25 <dolio> Yes, they're roughly isomorphic for the plain writer.
21:11:46 <FunctorSalad_> exactly, even (except for definedness)
21:12:04 <FunctorSalad_> they both curry t the same thing
21:12:13 <FunctorSalad_> ('deep curry')
21:12:20 <lispy> :t pass
21:12:20 <FunctorSalad_> s/\<t\>/to
21:12:21 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
21:12:55 <lispy> what the crap does pass do?
21:13:05 <lispy> I can't tell from the type :(
21:13:31 <dolio> It censors the output with the function returned by the action, and yields the value that comes with it.
21:13:48 <lispy> That is weird
21:14:02 <aristid> :t censor
21:14:03 <lambdabot> forall w (m :: * -> *) a. (MonadWriter w m) => (w -> w) -> m a -> m a
21:14:26 <roconnor> @bot
21:14:26 <roconnor> I think I Cont-bombed lambdabot in a private message
21:14:26 <lambdabot> :)
21:14:38 <lispy> roconnor: you JERK!! ;)
21:15:00 <lispy> ?remember roconnor I think I Cont-bombed lambdabot in a private message
21:15:00 <lambdabot> I will never forget.
21:15:10 <lispy> lambdabot: you always forget you harf-wit
21:15:14 <lispy> half*
21:15:17 <aristid> :t let pass x = do (a, f) <- x; censor f (return a) in pass
21:15:18 <lambdabot> forall (m :: * -> *) b w. (MonadWriter w m) => m (b, w -> w) -> m b
21:15:32 <aristid> @undo pass x = do (a, f) <- x; censor f (return a)
21:15:32 <lambdabot> pass x = x >>= \ (a, f) -> censor f (return a)
21:15:41 <roconnor> FunctorSalad_: anyhow, my function above is sort of an example where the currenty continuation k is passed out of the callCC
21:15:41 <roconnor> FunctorSalad_: at least a function is passed out that uses k
21:16:25 <FunctorSalad_> roconnor: I'll believe that :) just didn't see how to export the exact same type
21:17:01 <FunctorSalad_> should work using a newtype version of the needed infinite type too
21:17:04 <dolio> > let f l = (msum . map return $ l) >>= \e -> tell l >> return (e, filter (/= e)) in runWriterT $ (pass $ f [1..5]) :: [(Int, [Int])]
21:17:05 <lambdabot>   [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
21:17:06 <lispy> FunctorSalad_: what were you trying to do?
21:17:12 <Axman6> @. @pl @undo pass x = do (a, f) <- x; censor f (return a)
21:17:12 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
21:17:21 <Axman6> @. pl undo pass x = do (a, f) <- x; censor f (return a)
21:17:21 <lambdabot> pass = (uncurry (flip censor . return) =<<)
21:17:30 <FunctorSalad_> lispy: leaking the (a -> m b) out of the arg to callCC
21:17:32 <lispy> ?. pl undo pass x = do (a, f) <- x; censor f (return a)
21:17:32 <lambdabot> pass = (uncurry (flip censor . return) =<<)
21:17:41 <FunctorSalad_> (not me, actually)
21:17:45 <lispy> FunctorSalad_: ah
21:19:09 <lispy> who wants to help me implement gnu coreutils in Haskell?
21:19:39 <shachaf> lispy: Why are you doing that?
21:20:00 <roconnor> @bot
21:20:00 <roconnor> I did it again
21:20:00 <roconnor> :(
21:20:00 <lambdabot> :)
21:20:14 <roconnor> ya
21:20:25 <dolio> Some people look at creamed corn and ask, "why?" I look at creamed corn and ask, "why not?"
21:20:26 <roconnor> I haven't be able to return the continuation directly :(
21:20:32 <roconnor> stupid types
21:20:43 <lispy> shachaf: cabal install coreutils -- bam!  now windows sucks a little less :)
21:20:52 <shachaf> lispy: Ah, Windows. Cygwin isn't good enough?
21:21:05 <shachaf> lispy: Given that you want sh anyway.
21:21:13 <lispy> shachaf: cygwin is actually proof of God (you can't gave God with out Satan, right?)
21:21:25 <shachaf> lispy: Come on, it's not *that* bad.
21:21:29 <dolio> Axman6: That implementation of pass in terms of censor doesn't work.
21:21:43 <Axman6> i didn't write it :\
21:21:58 <lispy> shachaf: I dunno, I pretty much avoid cygwin every way I can.  If it's been installed on a machine I consider it "tainted" and avoid it like the plauge
21:22:02 <lispy> plague*
21:22:03 <dolio> Ah. Well, same to whoever did, then. :)
21:22:07 <shachaf> lispy: Really?
21:22:10 <lispy> shachaf: yeah
21:22:23 <shachaf> A while ago when I ran Windows I and got around to installing Cygwin I used it a lot.
21:22:27 <ezyang> lispy: Enh, it's only tainted if they've added cygwin to the defualt path. 
21:22:34 <dolio> roconnor: You need a newtype to pass continuations out of a callCC.
21:22:43 <dolio> Because it leads to recursive types.
21:23:51 <lispy> shachaf: sh is another thing I'd like.  Some how I thought implementing coreutils would be a better warmup exercise
21:24:10 <shachaf> lispy: ...Why not just use Cygwin?
21:24:10 <lispy> shachaf: to be fair, for the task I have in mind, I really only need cat, grep and a few others
21:24:15 <shachaf> It's not great but neither is Windows.
21:24:19 <lispy> shachaf: bah!  It's the devil!
21:24:27 <shachaf> lispy: Besides, you want pipes, right?
21:24:33 <shachaf> Aren't Windows pipes evil too?
21:24:50 * shachaf seems to remember that Windows ran one process to completion, dumped its output to a file, and then ran another process < that file.
21:24:55 <shachaf> I might be thinking of DOS, though. :-)
21:25:16 <lispy> hehe, that's definitely dos like
21:25:24 <lispy> I think windows has sane pipes too though
21:25:32 <lispy> if you can assume a sufficently recent windows
21:40:14 <lispy> anyone here want to redesign the takusen website to be pretty?
21:40:28 <lispy> It's really in need of a good designer, but I lack the skills
21:42:19 <Jonno_FTW> what website?
21:43:44 <lispy> Jonno_FTW: I'm a little embarassed to show you: http://projects.haskell.org/takusen/
21:46:00 <Axman6> heh
21:46:05 <lispy> Jonno_FTW: as you can see, it needs some love
21:46:46 <lispy> I wish it looked like this site: http://www.atheme.org/project/libaosd
21:46:55 <lispy> Jonno_FTW: can you arrange for that to happen?
21:49:03 <Jonno_FTW> oh the horror
21:49:32 <Jonno_FTW> do you want it to look exactly like that?
21:50:01 <lispy> nah, I just want it to be pretty.  Sites I like, the haskell platform download, haskell.org main page, ruby.org main page, xmonad.org
21:50:54 <Jonno_FTW> a single column layout?
21:50:59 <Jonno_FTW> will it just be one page?
21:51:40 <lispy> Jonno_FTW: one page is fine.  It should maybe have a bar somewhere with the links that are in the list on the page it has now
21:51:46 <Jonno_FTW> ok
21:52:02 <lispy> Jonno_FTW: and it should probably have more content like an explanation of what takusen is, maybe some sample code
21:52:08 <lispy> Jonno_FTW: that sort of stuff
21:52:20 <Jonno_FTW> I'll leave some places for you to fill in the info
21:52:24 <lispy> cool
22:00:47 <Jonno_FTW> lispy: do you want a bar of links at the top too?
22:00:58 <Jonno_FTW> or just straight from the header to the content?
22:01:18 <lispy> Jonno_FTW: not sure what you mean by the latter one
22:01:24 <lispy> Jonno_FTW: is there a website I could use as a reference/
22:01:42 <Jonno_FTW> I'm going by that atheme one
22:01:46 <lispy> also, I wonder if we should move this to #takusen
22:02:29 <lispy> Jonno_FTW: I guess the bar at the top is kind of nice then
22:02:36 * lispy thinks takusen needs a logo
22:05:25 <ManateeLazyCat> Cabal support multiple repositories now? I mean i have bubble of relate repositories, if i change some basic repositories, other higher repositories will re-compile again.......
22:06:05 <lispy> ManateeLazyCat: You can specify multiple hackage servers and cabal-install will search them in order.  I don't think what you're asking exists.
22:07:11 <ManateeLazyCat> lispy: "specify multiple hackage servers" ?
22:07:36 <lispy> ManateeLazyCat: yeah.  like, hackage.haskell.org and foo.mycompany.org
22:07:50 <lispy> ManateeLazyCat: both with packages that you can download install
22:08:26 <ManateeLazyCat> lispy: Why i need multiple server? I don't understand...
22:08:35 <ManateeLazyCat> lispy: hackage.haskell.org is not enough?
22:08:46 <ManateeLazyCat> lispy: I haven't catch your point.
22:09:35 <lispy> ManateeLazyCat: Well, suppose the company you work at has packages that are not released to the public.  They could appear there.
22:09:44 <lispy> ManateeLazyCat: but if you don't need it, then don't worry about it :)
22:10:11 <ManateeLazyCat> lispy: Yep, my project under GPL-3, i don't private server. :)
22:10:29 <ManateeLazyCat> s/don't/don't need
22:11:03 <lispy> ManateeLazyCat: well, and it's just one example. Maybe some day we'll have multiple hackage servers for load balancing, or some university will have their own that suplements the public one
22:12:00 <ManateeLazyCat> lispy: Mirror servers?
22:12:30 <ManateeLazyCat> lispy: If not mirror, i worry it will confuse cabal user.
22:15:35 <ManateeLazyCat> lispy: Now i have bubble relate repositories, someone suggest me move those repositories in *one* repository to save pull/install time...but i don't like.... i'm find another way to save install time....
22:17:26 <jmcarthur> i love the text package
22:18:14 <luite> randomwords: I can now compile libgd programs, but I don't have freetype support working yet
22:19:08 <luite> randomwords: and there's still some issue running in ghci (but that may be the same freetype problem)
22:40:31 <Jonno_FTW> lispy: I've finished irt
22:42:54 <lispy> Jonno_FTW: cool
22:43:02 <lispy> Jonno_FTW: where is it?
22:43:24 <Jonno_FTW> i'll hpaste it in a sec
22:43:51 <Jonno_FTW> actually
22:43:55 <Jonno_FTW> I'll host it
22:44:04 <lispy> Jonno_FTW: Thanks for doing that!
22:44:07 <chilili> (,) 1 2
22:44:58 <chilili> How to feed para to " (,)  (+100)  (+200) " please ?
22:46:26 <Peaker> @let funcTuple = uncurry (***)
22:46:26 <lambdabot>  Defined.
22:46:42 <Peaker> > (,) (+100) (+200) `funcTuple` (,) 1 2
22:46:42 <lambdabot>   (101,202)
22:47:01 <Peaker> chilili, like this?
22:47:05 <Jonno_FTW> lispy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29568#a29568
22:48:07 <chilili> Peaker: thanks. so runState (liftM2 (,) rollDice rollDice) $ (mkStdGen 0)  ?
22:49:01 <ManateeLazyCat> lispy: What's cool with Jonno_FTW ?
22:49:43 <Jonno_FTW> lispy: I hosted it here:http://9ch.in/lispy/
22:50:17 <chilili> http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State#Introducing_State  confused me on  "evalState rollDice (mkStdGen 666)"
22:50:51 <lispy> Jonno_FTW: hehe, thanks!
22:51:46 <Peaker> chilili, what's the type of rollDice?
22:52:02 <Jonno_FTW> WHat does this project even do?
22:52:17 <chilili> type GeneratorState = State StdGen    rollDie :: GeneratorState Int
22:53:12 <Peaker> chilili, well, liftM2 (,) rollDice rollDice   will get you an action that generates two dice rolls
22:53:26 <Peaker> chilili, GeneratorState (Int, Int)  (s/Dice/Die there)
22:53:33 <Peaker> @type runState
22:53:34 <lambdabot> forall s a. State s a -> s -> (a, s)
22:54:15 <Peaker> then when you runState on it, and give it the initial "s" (mkStdGen 0), you get the result tuple in "a", in a tuple with the new generator state
22:54:25 <lispy> Jonno_FTW++
22:55:53 <chilili> Peaker: yes, I know . I just want to understand how "runState" do that.  http://codepad.org/1hPD0Sut
22:57:17 <Peaker> chilili, runState just extracts the newtype
22:57:42 <Peaker> chilili, why not first evaluate a simpler "runState" example without the liftM2 stuff?
22:58:49 <chilili> Peaker: how, would you please some tips
22:59:14 <chilili> Peaker:  oh,  i see
22:59:51 <Peaker> chilili, Try to evaluate "runState rollDice (mkStdGen 0)"
23:00:22 <Peaker> chilili, you have to "undo" the "do" notation of rollDice (extract it to the >>= stuff)
23:00:48 <Peaker> Then you can also expand "get" and "put" to their definitions..
23:00:48 <chilili> Peaker: Great! I will try thanks.
23:00:57 <Peaker> chilili, and "return" and ">>=" also
23:01:12 <chilili> Peaker: yes.
23:08:27 <lispy> Jonno_FTW: thanks!  (here it is after some content updates): http://projects.haskell.org/takusen/
23:09:09 <Jonno_FTW> nice
23:09:13 <Jonno_FTW> glad I could help
23:09:15 <shachaf> Is that W3C seal necessary?
23:09:29 <shachaf> It looks out of place.
23:09:40 <lispy> shachaf: I can remove it, I added it as a joke
23:09:45 <lispy> The last version didn't even have closing tags
23:10:39 <Jonno_FTW> You should put the footer inside the content div
23:10:46 <Jonno_FTW> so that the padding is preserved
23:11:06 <lispy> okay
23:11:32 <lispy> Jonno_FTW: try it now
23:13:17 <Jonno_FTW> better
23:15:16 <lispy> Sooo much better than the old page
23:15:53 <ivanm> what page is this?
23:18:33 <Bobbias> Ok, so out of curiocity, does anyone know where I could learn about fast fourier transforms (for audio processing) with minimal math requirements? I've had some calculus, but nothing beyond derivatives and integration.
23:19:18 <Jafet> You could just outsource it to fftw.
23:19:44 <ivanm> Bobbias: does wikipedia help?
23:19:54 <lispy> ivanm: http://projects.haskell.org/takusen/
23:19:58 <ivanm> but yes, fftw is recognised as the best ft package
23:20:08 <ivanm> (and not just in the west!)
23:20:52 <Bobbias> Wikipedia is practically useless for most technical stuff like that, because it basically assumes you already have a PHD in math :/
23:21:01 <ivanm> lispy, Jonno_FTW: I think it would be nicer if when you zoomed in the white box also increased in size
23:21:10 <ivanm> Bobbias: I beg to differ
23:21:23 * ivanm uses wikipedia to work out what the papers he's reading for his PhD mean :p
23:21:30 <lispy> ivanm: do you know how to do that?  I don't
23:21:40 <ivanm> nope
23:21:46 <ivanm> the new haddock output does it though...
23:21:51 <Jafet> Well, perhaps you need one to understand DFTs (which are not really what your average engineer means by Fourier transforms)
23:22:11 <Bobbias> I've found some genuinely helpful articles on wikipedia, but there are quite a few that assume you know a LOT more than most people would
23:22:15 <lispy> ivanm: when I zoom in Chrome it does get bigger
23:22:17 <Jafet> There's also wavelets, which are a bit more computer friendly
23:22:47 <ivanm> lispy: huh, doesn't seem to in firefox
23:22:56 <ivanm> wait, I forgot, that could be due to the zoom extension I'm using
23:23:00 <Bobbias> Well, most computers use FFTs to do audio processing, since they can take any arbitrary waveform and represent it as a sum of sine waves
23:23:14 <ivanm> yes, it is :s
23:23:34 <Bobbias> It makes it really easy to do certain processes, like hi-pass and lo-pass filters, etc.
23:24:04 <Bobbias> wavelets seem to get more use in compression technology
23:24:21 <Bobbias> (though they are pretty close, mathematically)
23:24:24 <Jafet> Band-pass filters are a form of compression
23:24:34 <Jafet> Just encode any cheap mp3 and you'll see
23:25:40 <Bobbias> Yeah, so is applying jpeg image compression on a wave :P (produces some pretty garbled sounds at times, and has some really interesting effects)
23:25:42 <Jafet> Recent firefox finally does what opera has been doing for eons (as usual) wrt page zoom
23:26:00 <opqdonut> zooms all elements?
23:26:43 <ivanm> yeah
23:28:30 <Jafet> Still doesn't resize plugin elements olololol
23:28:42 <Jafet> This is why I have no faith in the web
23:28:58 <Bobbias> An example of why I don't like using wikipedia for some of the more technical things: http://upload.wikimedia.org/math/e/1/2/e122ed1b9dcaf915ce2ff50e3ddef890.png
23:29:44 <ivanm> yeah, what about that?
23:29:58 <ivanm> first of all, you can pull almost any equation out of context and not have it make sense
23:30:08 <Jafet> You're in the haskell channel complaining about classic math notation?
23:30:20 <ivanm> but it looks vaguely like a discrete FT (note: I only did FTs as part of a 2nd year math course 6 years ago)
23:30:27 <Jafet> Well, the only thing that can save you now is a book
23:30:45 <ivanm> O NOES!!!
23:30:53 <ivanm> Kreyszig is pretty good for that kind of stuff
23:31:26 <Bobbias> I was hoping there was a website (as there often are) explaining FFTs in a bit less obtuse manor for someone not very familliar with some of the things involved
23:32:11 <ivanm> Bobbias: does the wiki page have any links?
23:32:59 <Bobbias> http://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm is the page in particular I was reading
23:34:00 <Jafet> Dunno, if such pages existed don't you think the book writers would be out of business
23:35:47 <Bobbias> I've found lots of sites that do explain certain advanced topics in a way targeted at audiances outside the traditional math or engineering audiance for something, but they generally only cover limited topics, hence why authors still have their job
23:40:24 * hackagebot mount 0.1 - Mounts and umounts filesystems  http://hackage.haskell.org/package/mount-0.1 (NicolaSquartini)
