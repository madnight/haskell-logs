00:00:01 <periodic> Also, how can I find people in person who find this stuff as fascinating as I do?
00:00:16 <periodic> All the programmers I know work entirely in PHP, C++, or Java.
00:00:28 <kmc> existentials are useful, however sometimes there's a simpler / more standard solution
00:01:02 <kmc> like it's common for people new to Haskell to want to emulate an OO class hierarchy with type classes and instances and new data types and existentials
00:01:27 <kmc> but then it turns out that a simple data type with multiple constructors does what they want just as well
00:10:20 <dibblego> is there a nub (Ord a) => [a] -> [a] that is not O(n^2) per Data.List.nub?
00:14:43 <dolio> I don't think it's anywhere standard.
00:15:48 <dolio> There are a couple ways to implement it, depending on what properties you want, exactly.
00:16:30 <c_wraith> I guess you can make it O(n log (distinct elements)) using Data.Map as a backing
00:16:40 <c_wraith> Or, well, Data.Set is sufficient
00:16:52 <dolio> map head . group . sort is often suggested, but walking down the list with a Set handles infinite lists.
00:17:50 <luite> but it may be an advantage to get a sorted list in one go
00:18:14 <c_wraith> yeah, depends on your use case
00:18:57 <luite> someone should make a nubs package for all possible use cases ;)
00:19:35 <c_wraith> sort is O(n log n) regardless of the number of distinct elements.  If you expect a lot of repeats, the Set approach could be asymptotically faster
00:20:27 <luite> you could also switch to some O-notation that ignores log factors ;)
00:21:10 <c_wraith> I really don't know which approach would have worse overhead.  This is a case where I'd have to benchmark and tweak a lot.
00:22:19 <luite> you could also specialise the Set approach to a trie-based set for integral types
00:22:29 <luite> but in those cases, you could also use a more efficient sort
00:22:30 <kmc> you can sort faster than O(n log n) if you know something besides relative ordering of elements
00:22:34 <kmc> yes
00:22:48 <mm_freak_> uhmâ€¦  are you people sure about sort?
00:22:52 <kmc> (IntSet.toList . IntSet.fromList) should be like a radix sort, i think
00:22:55 <mm_freak_> i'd say that sort is O(n^2)
00:23:03 <mm_freak_> unless it's probabilistic
00:23:03 <c_wraith> Sort is an insertion sort.
00:23:08 <c_wraith> It's O(n log n)
00:23:22 <c_wraith> at least, it is in GHC. :)
00:23:25 <kmc> do not mistake the Report's sort or @src's for the real implementation
00:23:38 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Data-List.html#sortBy
00:23:43 <c_wraith> I actually took a look at it a couple weeks ago.
00:24:03 <kmc> funny if it's insertion sort because the function there is named "mergesort"
00:24:03 <kmc> ;)
00:24:06 <c_wraith> It's a bottom-up insertion sort.  Looks clean, and I'd assume it's benchmarked thoroughly
00:24:10 <c_wraith> err, merge
00:24:13 <c_wraith> wtf 
00:24:16 <c_wraith> I said that twice
00:24:20 <c_wraith> Despite *thinking* merge
00:24:43 <mm_freak_> c_wraith: remember that O means worst case
00:24:49 <c_wraith> "bottom-up insertion sort" doesn't mean anything. :)
00:24:53 <luite> is there some efficient radix sort implementation on hackage?
00:24:56 <kmc> merge sort is n log n worst case
00:25:02 <c_wraith> mm_freak_, insertion sort is O(n log n) best and worst cases
00:25:05 <c_wraith> err, wtf
00:25:06 <c_wraith> merg
00:25:14 <c_wraith> I fail
00:25:24 <c_wraith> insertion sort is O(n^2) worst case, O(n) best case.
00:25:26 <mm_freak_> c_wraith: how can insertion sort be n * log n in worst case?
00:25:27 <luite> mm_freak_: merge sort is n log n worst case, as is heap sort. you may be confusing it with quicksort
00:25:29 <dolio> Not for lists, that I know of.
00:25:38 <dolio> vector-algorithms has radix sort.
00:25:44 <c_wraith> mm_freak_, I keep saying insertion when I mean merge.
00:25:51 <mm_freak_> c_wraith: ah, ok =)
00:25:52 <kmc> i love how everyone knows all this shit about sorting algos
00:25:54 <Maxdamantus> Wouldn't insertion be more efficient using lists than using arrays?
00:25:54 <c_wraith> mm_freak_, except the times I actually mean insertion. :)
00:26:09 <kmc> despite being mostly irrelevant to real software development or new algorithm development
00:26:17 <kmc> it's what we all learned in Intro to Algorithms
00:26:18 <luite> Maxdamantus: not asymptotically
00:26:18 <Maxdamantus> Hmm.. actually, it'll still be n^2
00:26:43 <kmc> the way you know that someone was half paying attention in that class is if they claim sorting can't be done faster than O(n log n), period
00:27:20 <aRcatan> kmc: so university studies are beneficial after all!
00:27:32 <c_wraith> my favorite result is that you can sort n numbers in the range (1, n^k) in O(n*k) time.
00:27:51 <c_wraith> simple generalization of radix sort!
00:28:51 <mm_freak_> kmc: if all sorting algorithms were O(n^2), you would definitely notice a performance difference in many applications ;)
00:28:52 <luite> anyway, it would be nice to have more average case analysis for algorithms, but it tends to be much harder than worst case analysis
00:29:16 <kmc> yeah mm_freak_, but how often do you code a sort yourself versus calling a standard library function?
00:29:20 <c_wraith> average case analysis is hurt by the fact that it's application-specific, as well
00:29:58 <mm_freak_> kmc: well, there is no 'sort' for arrays in the base library
00:30:03 <luite> c_wraith: depends on how you define the average case, usually just the average over all possible inputs. of course that doesn't say anything about the inputs in a specific application
00:30:49 <c_wraith> But if you're getting into average-case analysis, you really should be focusing on real-world performance, at that point.
00:31:15 <mm_freak_> btw, O(n^2) isn't that bad
00:31:20 <mm_freak_> after all it means worst case
00:31:31 <mm_freak_> and worst case is unlikely
00:31:37 <luite> bah real world performance sounds like an engineering problem, which automatically makes it uninteresting ;)
00:32:11 <luite> mm_freak_: I use O* notation, O(n^2) = O*(1)
00:32:32 <mm_freak_> luite: i don't know O*
00:32:41 <luite> mm_freak_: just ignore all polynomial factors
00:32:58 <c_wraith> mm_freak_, whether worst-case is unlikely or not is *entirely* dependent on the algorithm.  using sorting as an example, selection sort is O(n^2), and really means it.
00:33:13 <luite> instead of bounded by a constant c, you bound by some polynomial p(n)
00:33:43 <c_wraith> Selection sort will *always* do exactly n * (n - 1) / 2 comparisons, and exactly n - 1 swaps.
00:33:43 <luite> mm_freak_: it's often used in the analysis of exponential-time algorithms
00:33:55 <c_wraith> So, its worst case is identical to its best case.
00:34:39 <c_wraith> Just saying "big-O analysis only covers worst case" is highly misleading, without looking at the details of what the algorithms actually do.
00:35:03 <mm_freak_> luite: is there a qualitative difference, which justifies dropping information?
00:35:24 <fasta> luite, if you have to wait for your own programs to terminate, optimization becomes fairly interesting. 
00:36:28 <luite> mm_freak_: yes, a very small difference in the exponential part is always more important
00:37:04 <luite> mm_freak_: for polynomials p and q, O( p(n)2^n ) < O( q(n)2^(0.99999n))
00:37:16 <mm_freak_> c_wraith: i think it's obvious that "worst case" is not a property of O(n^2), but of the algorithm
00:37:35 <mm_freak_> but whatever the algorithm is, it's correct to say that O means worst case
00:38:20 <luite> O-notation is just some way to say how a function is bounded, it doesn't say anything about the function itself or where it comes frome
00:38:41 <mm_freak_> and it doesn't say much about how fast it performs, which was my point =)
00:38:53 <fasta> luite, in theory, finding the algorithm, if you know it exists is O(1). 
00:38:54 <c_wraith> My main point is that algorithms that are O(n^2) are often "compare each element of something against all the rest, in some way".  Those *are* a real performance problem if you can't prove the input size is bounded.
00:39:23 <fasta> luite, assuming it has a proof in some formal system at hand, that is. 
00:39:45 <mm_freak_> c_wraith: in practice O(n^2) sorting means quicksort =)
00:39:51 <luite> fasta: hmm, why O(1)?
00:40:11 <c_wraith> an O(n^2) algorithm being reachable on a public web server opens the server up to low-bandwidth denial of service attacks.
00:40:25 <fasta> luite, an algorithm is a finite object. 
00:40:26 <luite> unless you know a bound on the length of the algorithm (or proof), it's considerably more expensive
00:40:30 <c_wraith> So, in reality, they *are* a real performance problem.
00:41:01 <luite> fasta: that doesn't make it O(1), unless you know "how finite" your algorithm is, i.e. you know a maximum length by some standard
00:41:31 <opqdonut> saying "X is O(1)" is meaningless unless X is a function
00:41:42 <Adamant> c_wraith: being able to explode a regex into tiny sharp shards works remarkably well
00:41:53 <opqdonut> please say "algorithm X has worst-case time complexity O(1)" or something like that
00:41:58 <Adamant> for that sort of thing
00:41:58 <mm_freak_> @unlambda i
00:41:59 <lambdabot>  Done.
00:42:13 <mm_freak_> @unlambda ``.!``.l``.o``. ``.l``.e`.H.l.o.w.r.dri
00:42:13 <lambdabot>   Hello world!
00:42:14 <fasta> luite, http://www.hutter1.net/ai/pfastprg.htm
00:42:40 <c_wraith> Also, no practical libraries export quicksort as their sort algorithm anymore.  mergesort variants have replaced them because of the worst-case guarantees.
00:43:04 <fasta> luite, if you schedule the search for the algorithm correctly, it doesn't cost more than an additive constant. 
00:43:15 <luite> fasta: that doesn't give bounds for any specific problem
00:43:50 <fasta> luite, yes, you are right. 
00:44:43 <DrSyzygy> Heh
00:44:47 <fasta> luite, it is O(problem dependent), but since it disappears in the BigOh term, you can see it like that. 
00:44:58 <DrSyzygy> Random student just emailed me and wanted my Category Theory course to happen again.
00:45:14 <luite> fasta: I have no idea what you mean by that
00:46:43 <fasta> luite, if you want to solve a concrete problem x, you can find the proof for some algorithm in some time that depends on the general problem for x, plus the time it takes to solve x in the first place. As the size of x tends to infinity, the time to find the proof disappears. 
00:47:16 <luite> and it is hard to define a complexity for this specific problem, since the running time depends on the length of the proof, which you don't know beforehand, not on the length of the specification
00:47:30 <luite> there may not even be an algorithm for your problem
00:47:58 <fasta> luite, I already said that that you were told there was an algorithm with a proof in some specific proof system. 
00:48:58 <fasta> luite, no, it's not hard to define this BigOh complexity, since the algorithm is a finite object. O(finite object) = O(1)
00:49:22 <fasta> Or rather O(some_fun(finite_object)) = O(1)
00:49:36 <luite> doesn't a sorting algorithm also work on finite lists?
00:50:03 <fasta> luite, yes, but we are not bounding the time for the general proof procedure. 
00:50:17 <fasta> luite, only for the specific case we are applying it to.
00:50:30 <fasta> luite, in an application, if you sort 1000 elements, it is also O(1). \
00:50:50 <fasta> luite, if you say we sort n, it is O(n log n). 
00:51:11 <luite> still, if you sort a list of n elements that can only be compared pairwise, there is no way your proof generator could come up with an algorithm that could sort them faster than O(n log n)
00:52:05 <fasta> luite, yes, but you give it as input some known algorithm that solves it. 
00:52:42 <luite> solves what?
00:53:36 <luite> sorry we might be talking about different things here, but I'm pretty sure that if everything is O(1), the functions you are talking about are probably pretty uninteresting :p
00:54:51 <fasta> luite, you need to give some specification of the problem you are solving in the form of an algorithm. 
00:55:07 <fasta> luite, anyway, there is a PDF, it is not a trivial result. 
00:55:36 <fasta> luite, much more interesting than your run of the mill graph algorithm, imho. 
00:55:56 <nlogax> can i disable the unicode stuff in yi? where it replaces :: with âˆ· and so on
00:56:15 <luite> fasta: could you be a bit more specific? what exactly do you use as your input size? the length of the specification of your problem? the length of some specific problem instance that needs to be solved?
00:57:01 <fasta> luite, the input size is the size of the problem you are solving, that is in sorting, the number of elements.
00:57:38 <fasta> luite, if you had a really fast computer his algorithm would put all CS people out of work. 
00:58:57 <mm_freak_> @unlambda `r````.k`.s`.a`.H.E.L.L..
00:58:57 <lambdabot>   HaskELL
01:02:30 <luite> fasta: I'm pretty sure it wouldn't :p  and it needs to verify the solution anyway, which in the case of radix sort is just as slow as sorting itself
01:03:50 <fasta> luite, no, it doesn't need to verify the solution. 
01:04:28 <fasta> luite, anyway, I am not going to argue about this, because I know that guy did a perfect job. 
01:04:28 <luite> it does, it gets a specification of the problem and needs to test whether the current algorithm outputs something that agrees with that specification
01:04:53 <fasta> luite, Reviewer:  I propose to accept the paper as is. This is an excellent result, unexpected. 
01:05:40 <luite> see slide 7, "applicability" if you don't believe me (third point is similar to the one I just made about sorting)
01:07:39 <fasta> luite, you failed to understand what this algorithm is about.
01:07:58 <fasta> luite, he _contrasts_ this with Levin search. 
01:31:12 <Maxdamantus> Why does replicate take an Int?
01:31:13 <luite> fasta: ah I see now, I thought at first that it was more like regular Levin search... but it's still not O(1) in any way
01:31:19 <Maxdamantus> Rather than Integral?
01:31:54 <luite> Maxdamantus: some Prelude functions do, unfortunately, try Data.List.genericReplicate instead
01:32:14 <Maxdamantus> Hm.
01:32:16 <fasta> luite, it is an additive constant. 
01:32:22 * Maxdamantus wonders if there's a replicateM equivalent.
01:32:40 <Maxdamantus> Apparently not.
01:32:51 <Maxdamantus> !src replicateM
01:32:55 <fasta> luite, if you have problems with sizes that tend to infinity, how does the term _not_ disappear?
01:33:01 <luite> fasta: it computes the fastest algorithm computing the correct result. if that fastest algorithm is O(n log n), this thing won't be faster
01:33:11 <Maxdamantus> @src replicateM
01:33:11 <lambdabot> replicateM n x = sequence (replicate n x)
01:33:15 <dolio> luite: The algorithm search (for a particular problem) is O(1) in the size of the input to the problem you're searching for an algorithm for, because the time it takes to find the algorithm is completely unrelated to the size of the input you subsequently feed into it.
01:33:15 <fasta> luite, did I say it was?
01:34:40 <fasta> luite, almost certainly the thing will be faster, btw, in engineering numbers if you build a good machine model with suitable theorems. 
01:42:43 <luite> dolio: the time to search for an algorithm isn't really constant though, for larger problem sizes, it will need to find faster algorithms
01:43:37 <luite> both parts are actually O(n), where n is the problem size
01:43:57 <dolio> If I want to sort a list with n elements, the time it takes to search for the most efficient sorting algorithm is independent of n.
01:44:15 <luite> that is true, but that is not what this algorithm computes
01:44:21 <dolio> Yes, it is.
01:44:40 <luite> no it searches for a particular solution for a particular list
01:45:04 <luite> it doesn't prove any general asymptotic bounds
01:46:35 <luite> you need to run this complete algorithm again for other input sizes, you cannot just extract the algorithm that has been found before and use that (although you could use the proofs and algorithms that have been found before to speed up subsequent invocations)
01:47:15 <dolio> What paper are you reading?
01:47:36 <dolio> The one I'm looking at searches for algorithms with correctness proofs and proofs of time complexity in some formal system.
01:47:52 <dolio> And interleaves the search for such algorithms with their execution.
01:47:57 <luite> this one http://www.hutter1.net/ai/pfastprg.htm
01:48:25 <luite> the key is in Algorithm C, which aborts when the solution has been found
01:48:36 <luite> the output is the solution, not the algorithm
01:49:03 <luite> and that's also the way this thing works, algorithm B tests the complexity of verified proofs in finite input sizes
01:49:21 <luite> no asymtotic complexity proofs
01:50:08 <luite> when it takes more time to compute the solution, algorithm A automatically gets more time to produce more algorithms that might be better
01:50:27 <luite> but there is no final algorithm that works for any input size
01:50:55 <fasta> luite, you can modify the algorithm such that it returns the found algorithm as the author notes in his paper. 
01:51:14 <olsner> and that algorithm will work for any input size?
01:51:22 <luite> olsner: yes, but it might not be the fastest
01:51:45 <fasta> olsner, it's like 5 times as slower + HUGE_CONSTANT. 
01:51:53 <luite> olsner: it enumerates only correct algorithms
01:51:57 <fasta> s/as//
01:52:11 <luite> the 5 times slower is only when you run the generation of new algorithms along with the current algorithm
01:52:12 <dolio> Provably correct algorithms, even.
01:52:19 <fasta> olsner, or 1+epsilon + HUGE_CONSTANT, but he doesn't describe that. 
01:53:28 <fasta> Basically our universe is a bit too small to execute some fun algorithms successfully, OTOH, when a human searches for algorithms he has the same problems. 
01:53:56 <olsner> ah, it's only fast enough that it would take longer to find a better algorithm than to use that one, for the original input size
01:54:10 <luite> olsner: yes that's it
01:54:52 <JoeyA> I've been struggling for a couple days to write a lazy recursive file listing action of the form lsR :: IO [FilePath] .  What makes it tricky is that it changes the current directory as it proceeds, meaning everything has to be done in the right order.
01:55:48 <JoeyA> I guess the right way to do it would be to recast it in continuation-passing style (I haven't fully explored that option) and put the unsafeInterleaveIOs in the right place.
01:55:53 <luite> it can use exponential time algorithms if your input size is small, and might find a proof for a polynomial time algorithm when your input size gets larger
01:56:30 <luite> but you have no idea whether the current algorithm is asymptotically optimal for your problem
01:56:50 <JoeyA> lsR :: (FilePath -> IO ()) -> IO () is easier to write.  It just invokes a callback for each file.
01:57:34 <dolio> JoeyA: It should be possible to build a rose tree of some sort if you're fine with unsafeInterleaveIO. I wouldn't base it on calling some chdir IO action, though.
01:57:40 <luite> still an interesting paper, but you can't prove P /= NP with it ;p
01:57:54 <JoeyA> I'm wondering if there's some IORef and unsafe* ninjutsu I can use to wrap lsR :: (FilePath -> IO ()) -> IO () so it is of the form lsR :: IO [FilePath]
01:58:07 <dolio> Rather, ask for the current directory, and then use functions that query the contents of a particular directory recursively.
01:58:38 <JoeyA> I guess I could use an IORef and have the callback append to the list, but I'm not sure that can be lazy.
01:58:47 <olsner> but the correctness thing should mean, that if you pick any generated algorithm and it happens to have a good asymptotic complexity, you know that it's an upper bound (for the lower bound?)
01:59:15 <merijn> Can anyone point me to a HTML parsing and a SQLite (or some other lightweight simple file based database) library?
01:59:24 <olsner> so, if you feed it an NP-complete problem and it outputs a polynomial algorithm you'd have solved P=NP?
01:59:37 <olsner> but you can still not prove P/=NP of course :)
01:59:53 <JoeyA> http://hackage.haskell.org/package/HDBC-sqlite3 -- there's your sqlite3
01:59:54 <luite> olsner: you only know how many steps it needs for finite input sizes (at least that's what algorithm B verifies)... so you'd need to do an asymptotic complexity proof by hand
02:00:23 <merijn> JoeyA: Thanks :)
02:00:36 <luite> olsner: you could of course be very lucky that it does spit out a polynomial-time algorithm for an NP-complete problem, but it's up to you to prove it
02:00:57 <olsner> yep, that's what I meant, doing the complexity proof by hand
02:01:08 <JoeyA> I've been using HDBC for a little while.  It works nicely, but it's not a snazzy combinator library that isolates your queries.
02:01:30 <JoeyA> (err, eliminates the need for SQL text)
02:02:15 <JoeyA> There's HaskellDB, but I didn't look into it much.
02:02:30 <merijn> JoeyA: That's ok, I need only trivial queries anyway. I figured I should do something non-trivial in Haskell, so I intend to parse my banks online deposit/withdrawal history, dump it in a database and generate some reporting from that database to help budget my money :p
02:02:39 <JoeyA> Couldn't really get past the connection function:  sqliteConnect  :: MonadIO  m => SQLiteOptions  -> (Database  -> m a) -> m a
02:03:06 * hackagebot gnuplot 0.4.0.1 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.4.0.1 (HenningThielemann)
02:03:14 <kremsera> whats the pape about? you give an input, an algorithm - and it enumerates equavilent algorithms with at most the same big-O complexity?
02:03:23 <JoeyA> Why can't it just be sqliteConnect :: SQLiteOptions -> IO Connection ?
02:04:14 <ivanm> preflex: seen Heffalump 
02:04:14 <preflex>  Heffalump was last seen on #darcs 1 hour, 55 minutes and 40 seconds ago, saying: @tell lispy go for it
02:04:14 <dolio> JoeyA: lsR d = getDirectoryContents >>= mapM (unsafeInterleaveIO . lsR . (d </>)) >>= return . Node d -- something like this
02:04:57 <luite> kremsera: no it says nothing about big-O complexity. you give it an algorithm and it enumerates algorithms, which it tests for speed on increasingly large input sizes. it keeps the currenly fastest known algorithm and uses that in parallel to compute the solution for a single problem instance
02:06:53 <dolio> JoeyA: Oh, except getDirectoryContents includes "." and "..", so you have to filter that out.
02:08:30 <JoeyA> Here's what I have so far:  http://codepad.org/AecOHoW2
02:09:07 <kremsera> but it says its asymptotically only a factor five slower than the fastest algorithm, - what does asymptotically mean than?
02:09:09 <JoeyA> inDirectory is an exception-guarded directory changing/changing back function, ls is a getDirectoryContents wrapper that sorts and removes "." and ".."
02:09:53 <JoeyA> strictLsR is what I'm trying to make lazy, and lsR just does laziness the imperative way by using a callback.
02:11:05 <luite> kremsera: that only means that the complete algorithm, which includes searching for new algorithms and testing them for speed, is relativly fast (I have to admit that I'm not terribly convinced by the complexity analysis, but that probably means that I should read it more carefully)
02:11:25 <JoeyA> http://codepad.org/h4XnIarN -- I simplified strictLsR a bit
02:11:39 <dolio> JoeyA: Well, you can't sensibly make strictLsR lazy, if I understand inDirectory correctly.
02:12:23 <JoeyA> Do you mean because dealing with exceptions would make it really messy?
02:12:25 <dolio> Or, maybe you can, but I wouldn't recommend it.
02:12:45 <JoeyA> Or the fact that the current directory would jump all over the place until the paths are consumed?
02:13:23 <dolio> Because what directory is set as the current directory depends on what parts of the data structure you've forced.
02:13:32 <JoeyA> (a way to work around the latter problem would be to pass lsR a callback that accepts the whole list, then seq the list to ensure the traversal is done before returning)
02:14:22 <JoeyA> Thus, only in the callback would the current working directory be up in the air.
02:14:38 <luite> kremsera: the point is that if there is an asymptotically fastest algorithm, it will eventually find it, and for extremely large input sizes, it spend at least 20% of the computation time using this algorithm to find the solution to your problem instance
02:15:32 <luite> kremsera: however, there is no way to know for any specific instance, whether this algorithm has already been found
02:16:17 <kremsera> luite, so it does not neccessarily terminate
02:16:47 <dolio> JoeyA: Why not just pass the directory prefix into the recursive calls and avoid mutating the current directory global all together?
02:16:59 <luite> kremsera: you supply an initial algorithm, if that terminates, it's guaranteed to terminate
02:17:16 <luite> kremsera: note that this thing searches for a solution for some problem instance, not for an algorithm
02:17:59 <JoeyA> dolio: It's probably less efficient, given that I'm using String instead of ByteString
02:18:20 <luite> kremsera: you could also output the algorithm that ultimately produced the solution, but you know nothing about its complexity
02:18:24 <jystic-iphone> @pl f x = g x >>= h
02:18:24 <lambdabot> f = (h =<<) . g
02:18:45 <luite> kremsera: well, its asymptotic complexity that is
02:19:20 <JoeyA> I guess I'm just having a bout of premature optimitis, but maybe I'll learn something useful by figuring this out.
02:19:42 <luite> kremsera: you do know that it produced the solution before the algorithm enumerator could produce better algorithms :)
02:20:15 <JoeyA> (the actual code I'm working on doesn't actually build the directory path strings)
02:20:24 <kremsera> lol
02:21:06 <luite> I'm going back to programming, it was an interesting read, but ultimately won't cost any computer scientist their job :p
02:22:20 <dolio> JoeyA: I don't know how setCurrentDirectory works, but it may well build the same strings.
02:24:21 <JoeyA> I won't win this one, will I?
02:27:28 <JoeyA> I imagine setCurrentDirectory just calls the chdir C function, which accepts relative paths.
02:27:57 <JoeyA> But I agree, dancing around in directories isn't a very sensible semantic.
02:29:16 <om-foxy> is there a way to get around "duplicate instance declarations?"  If I have a class /Foo a/ and a class /Bar a/, i'm trying to declare /instance Foo a => Baz a where.../ and /instance Bar a => Baz a where.../, shouldn't the type-checker be able to differentiate between members of /Foo/ and members of /Bar/? 
02:31:30 <Saizan> it's using an open world assumption to be able to better deal with separate compilation
02:32:02 <Botje> om-foxy: what if you have a type that is an instance of both Foo and Bar?
02:32:13 <Saizan> and that leads to completely ignoring instance context while deciding which instance to use, and just imposing it as a constraint after the fact
02:32:21 <Botje> om-foxy: i think you can coax it into working with UndecidableInstances, no?
02:32:41 <Saizan> no, even with OverlappingInstances that won't pass
02:33:07 <om-foxy> Botje, I'll try.  Good point, but isn't that "OverlappingInstances?"
02:33:10 <Saizan> it might work with IncoherentInstances but i'm not sure
02:33:35 <Saizan> anyhow i'd strongly advise against it
02:34:15 <om-foxy> hmm.. no, undecidaBLEinstances is already invoked
02:34:45 <Saizan> om-foxy: maybe you don't want typeclasses at all for what you are doing
02:36:18 <aavogt> om-foxy: you'd need to add a dummy type parameter to Baz
02:37:04 <aavogt> or that's a starting point for dealing with duplicate instances
02:38:52 <om-foxy> Saizan:  A plot can be of points or lines (or both).  A data series with a point format is a decorated data series.  A data series with a line format is a decorated data series.  I want a function that takes a data series and a format and gives me a decorated data series.  (format :: Format a => DataSeries -> a -> Decorated).  Where /instance PointFormat a => Format a/ and /instance...
02:38:54 <om-foxy> ...LineFormat a => Format a/.
02:43:43 <Saizan> Format could well be a datatype rather than a class
02:44:46 <Saizan> it seems like you're trying to use design principles from the OO world and map them directly to typeclasses, that's not in general supported by the way typeclasses work.
02:46:24 <Saizan> a quite more flexible and faithful way to make use of design principles is mapping an interface to a record type, and instances of that interface to functions that create values of that record type
02:46:40 <fasta> Type-classes do map to Java interfaces. 
02:46:46 <Saizan> s/design principles/OO design principles/
02:47:50 <fasta> Most of the time type-classes only complicate your design completely unnecessarily. 
02:48:29 <fasta> For monads, you can argue that it is useful, but for a lot of structures, the module system would also work fine. 
02:49:55 <Saizan> yeah, you're not going to create typeclasses all time time like you do with classes in e.g. Java, if you're doing it right
02:50:41 <Saizan> though haskell's module system is not so strong either, but we have records.
02:51:58 <fasta> You can make every function into a type class, but then you get function types like (A a, B b, C a b, D Int Blah Foo) that fill 3 screens. It does work, but if something is wrong, it's not really fun to find the use-site of these types. This is a tools problem.
02:52:52 <Saizan> it doesn't seem useful even with perfect tools
02:53:34 <fasta> Saizan, I think it also complicates things, yes. 
02:54:10 <fasta> If you want to make your algorithms extremely general, you can always just pass a record with functions into it. 
02:55:16 <aavogt> -XImplicitParams instead of a class to implicitly pass such a record?
02:56:14 <fasta> aavogt, I don't  use that. 
02:56:32 <fasta> aavogt, Oleg has a wonderful solution to this general problem, btw. 
02:57:06 <fasta> If you really do care, you could apply that (search for modulus). 
03:06:47 <ManateeLazyCat> fasta: If you at #gtk+ ? :)
03:08:23 * ManateeLazyCat Have fasta at #gtk+
03:11:33 <fasta> ManateeLazyCat, yes. 
03:12:17 <ManateeLazyCat> fasta: Cool, i consider haskellers are GUI hater. :)
03:13:02 <fasta> ManateeLazyCat, as a developer I hate GUIs, because they are complicated objects with badly defined semantics. 
03:13:17 <fasta> ManateeLazyCat, as a user, I like GUIs when they are carefully written, which most are not. 
03:13:32 <Entroacceptor> so there should be a framework to make it easy to write good guis!
03:13:45 <ManateeLazyCat> fasta: Do you like this http://www.flickr.com/photos/48809572@N02/ ?
03:14:37 <fasta> ManateeLazyCat, give me something I can execute and open-source and I will form an opinion. 
03:15:46 <fasta> ManateeLazyCat, why are you cloning gnome-system-monitor?
03:16:06 <ManateeLazyCat> fasta: I'm not clone.
03:16:21 <ManateeLazyCat> fasta: Since process manager almost same.
03:16:32 <ManateeLazyCat> fasta: Like htop, top, gnome-system-monitor.....
03:16:43 <fasta> ManateeLazyCat, yes, but what's the point of writing it?
03:17:04 <ManateeLazyCat> fasta: For my ILE (Integrated Live Environment).....
03:17:20 <ManateeLazyCat> fasta: All screenshots at http://www.flickr.com/photos/48809572@N02/
03:17:32 * ivanm still thinks ManateeLazyCat should have called it Live Integrated Environment instead for the better acronym... :p
03:18:04 <ManateeLazyCat> ivanm: "Live Integrated Environment" abbreviated is LIE
03:18:10 <ivanm> exactly ;-)
03:18:20 <ivanm> ManateeLazyCat: anyway, here might be a suggestion of what to use as a logo: http://en.wiktionary.org/wiki/ile#Noun
03:18:44 <fasta> From a marketing point of view LIE is better.
03:20:13 * ManateeLazyCat It's a bug of GFileMonitor can't handle /proc
03:20:57 <ManateeLazyCat> ivanm: Well, those name still not finalled, i will consider change to LIE. :)
03:21:29 <luite> hmm, I wonder whether there always is a fastest algorithm for any problem, that it's possible to make increasingly fast algorithms for larger input sizes in some cases
03:21:36 <luite> does anyone know more about this?
03:22:11 <luite> (still related to that paper linked by fasta before...)
03:24:16 <fasta> luite, you mean whether a provably fastest algorithm exists as n to infinity?
03:24:29 <luite> obviously for any fixed problem size, there is a fastest algorithm, since there is some algorithm that ends in n steps, so using more than n instructions will never be faster... 
03:25:06 <luite> fasta: not provably fastest, just whether there always is one fastest algorithm
03:25:32 <ManateeLazyCat> ivanm: I can finish process-monitor today, tomorrow irc-client, then mail-client....
03:25:40 <ivanm> brb
03:25:42 <fasta> luite, but is there a proof that it computes the right result?
03:26:02 <luite> fasta: yes
03:26:34 <ManateeLazyCat> ivan: multimedia-player at http://www.flickr.com/photos/48809572@N02/4916078721/
03:26:35 <fasta> luite, ok, so basically the question is whether his algorithm ever converges. 
03:27:47 <fasta> luite, I can imagine there is an infinite alternating sequence of algorithms that are almost as fast, but it won't go faster and faster on a Turing machine. 
03:28:19 <luite> why not?
03:29:34 <luite> you have a finite alphabet and a finite number of states, but as problem size increases, it could make sense to add more and more states
03:30:17 <luite> I don't see an obvious reason why it should always stop somewhere... although I might have missed an argument for it in the paper
03:31:21 <luite> in an extreme case, say we solve SAT, we could just add more and more states to make it recognize instantly each SAT instance up to a certain size, just by reading the tape once
03:31:47 <luite> that would make a minimal time, optimal, algorithm... but you need to keep adding states to cater for larger inputs
03:32:05 <fasta> luite, yes, I got that point. 
03:32:21 <luite> I just wanted to give a concrete example
03:32:32 <fasta> luite, it was a good example.
03:32:49 <fasta> luite, isn't is simply that Blum's Speedup Theorem applies?
03:35:51 <luite> fasta: hm, I don't think it is, it should be Theorem 2 in that paper
03:38:56 <luite> fasta: adding more states will make it exponentially slower because the turing machine itself is encoded on the tape and executed on a universal turing machine
03:39:11 <luite> I think that might be the reason that that proof works
03:39:43 <fasta> luite, but you can search in lg lg n time. 
03:40:10 <MangledBody> Hi!:)
03:40:13 <fasta> luite, so, once you have the machine on the tape, it is fast. 
03:40:31 <fasta> luite, completely worthless in the real world, though. 
03:40:35 <luite> hmm, why is it fast?
03:42:08 <luite> I mean that switching from one state to another in a regular turing machine is instantly, on the tape-encoded turing machine it isn't
03:42:29 <luite> and I'd guess exponentially slower given the size of the TM, but I'm not sure about it
03:43:56 <luite> reasoning about speed in such a setting is then rather different from that of regular turing machines
03:47:56 <luite> hmm, according to wikipedia, a multitape utm is only a log factor slower than the one it simulates
03:52:05 <fasta> luite, what exactly is our measure of "fast"?
03:53:58 <fasta> It would be kind of interesting to know how many SAT instances are actually difficult for a given number of variables and clauses. That is, cannot be solved with some polynomial algorithm. 
03:54:19 <luite> I think we should switch to some EXPTIME problem instead of SAT
03:54:36 <luite> since then we know that the asymptotic complexity needs to be exponential
03:55:07 <luite> but the same "recognize all instances up to some size" trick still works, every problem recognized in that way is solved in linear time
03:55:31 <luite> (or n log n given the simulation overhead of the tuering machine)
03:55:54 <opqdonut> fasta: there has been some work in that vein, but the question of where the hard instances are is still quite open
03:56:06 <opqdonut> i think the term is parametric complexity
03:56:16 <fasta> opqdonut, fixed parameter complexity, you mean?
03:57:13 <opqdonut> i meant research on the structure of SAT
03:57:20 <opqdonut> how common the hard instances are etc
03:57:44 <fasta> opqdonut, I did some actual enumeration once in my own experiments. 
03:58:05 <opqdonut> overwhelmingly most instances are easy, right?
03:58:14 <fasta> opqdonut, it would be fairly interesting to see graphs of a similar experiment executed on a super computer. 
03:58:18 <luite> but SAT was just an example... not a very good one since there might be polynomial-time algorithms
03:58:20 <opqdonut> that's why sat solver programs are popular
03:58:28 <opqdonut> sure
04:06:03 <fasta> I don't understand why nobody has yet completely destroyed this "proof" of P=NP: http://www.merlins-world.de/ If it is obviously wrong, someone should put it on his/her website. 
04:07:15 <merijn> fasta: People can't be arsed destroying obviously flawed proofs?
04:07:39 <fasta> merijn, it is not obvious, since we had quite long discussion in this channel on it. 
04:09:06 <merijn> You were the one saying "If it is obviously wrong", I can't be arsed reading P=NP proofs until I get some cues from trustworthy people it might be real
04:10:13 <fasta> merijn, I read it, and the only step for further analysis would be to actually try to implement it. 
04:10:39 <fasta> merijn, I also think other approaches could work that are on the P vs NP page, btw. 
04:11:35 <fasta> I think P vs NP is difficult because there is a sequence of convertible problems. Solving the "most difficult one" is probably harder than an extremely reduced one. 
04:12:17 <luite> the shortest/fastest algorithm that slves a problem might be in many cases the algorithm that recognizes instance x and otherwise reverts to some extremely simple algorithm if it encounters another instance. that only has a linear number of states in the input size, and solves x in linear time in its size. 
04:12:46 <merijn> fasta: My gut reaction is that its wrong simply because it claims P=NP
04:12:59 <fasta> merijn, that's the popular opinion, yes. 
04:13:02 <merijn> Which is unlikely to the extreme
04:13:44 <luite> algorithm A does some check on the running time, but I don't completely understand what the author means by that, however, it would be simple to conceive an neverending series of increasingly faster exponential-time "fallback" algorithms
04:14:00 <medfly> fasta, should just have a vote on it then
04:14:11 <fasta> medfly, those have already been done. 
04:14:14 <ivanm> nooo!!!! come back lambdabot!!!
04:14:16 <medfly> hehe
04:14:25 <fasta> medfly, about 10% thinks it is possible, I think. 
04:14:30 <RayNbow`TU> RIP lambdabot
04:14:55 <merijn> fasta: Really? 10% realistically considers P = NP?
04:15:10 <merijn> That seems awfully high
04:15:34 <luite> merijn: that's nothing compared to the 80% crackpots that work on this problem ;)
04:16:28 <fasta> You definitely have to be not normal to solve it. :)
04:16:38 <merijn> I think the unanimous opinion in my CS department is that P != NP
04:17:36 <fasta> merijn, I think it is bad to teach it as universal truth as we simply don't know.
04:18:07 <fasta> merijn, there is an extreme bias to teach that "everyone thinks P!=NP". 
04:18:11 <merijn> fasta: That is not a universal truth, its an opinion
04:18:23 <fasta> merijn, yes, but that was the case in my department at least. 
04:18:57 <fasta> merijn, but the same guy was wrong or rather extremely vague in his complexity for LP. 
04:20:16 <fasta> A good way to demonstrate that you solved it is to crack a crypto key on a desktop, though. 
04:20:40 <luite> LP, what does that have to do with it? (assuming you mean linear programming, I don't know an LP complexity class)
04:21:11 <koala_man> isn't LP all about approximations?
04:21:12 <luite> integer factorization is not known to be NP-complete
04:21:20 <fasta> luite, stating "LP is polynomial" is an extreme simplification. 
04:23:40 <fasta> luite, no, but you can build a SAT circuit out of a factorization problem and solve that. 
04:25:25 <luite> what's the use of that. it's like saying that you can jump over a house and then "proving" that by jumping over a chair
05:05:55 <Phyx-> !seen cippo
05:06:00 <Phyx-> @seen cippo
05:06:00 <preflex>  Sorry, I haven't seen cippo
05:31:06 <ivanm> *sigh* it's rather boring copying every instance of Functor for my version of it...
05:31:16 <Ferdirand> 7 /win 17
05:31:18 <Ferdirand> oops
05:31:36 <ivanm> (since for some reason doing "instance (F.Functor f) => Functor f ... " leads to overlapping instances :s )
05:33:25 <ivanm> anyone here considering getting Bird's new book?
05:52:54 <aruns> hi i'm new to Haskell and trying to figure out how to do parse arguments passed into the program. I want to write be able to pass in standard POSIX style arguments like -o foo -b bar. I have written a little function with this signature [String] -> [(a, b)] . i'd like to have a list of tuples of argument and value
05:53:21 <ivanm> you don't want to do that
05:53:40 <ivanm> there's GetOpt that comes with GHC, or else ndm's CmdArgs is a nice replacement (and he's just written a tutorial blog post about it)
05:53:59 <aruns> ivanm: yes i've seen those, but i guess i'm just writing this so i can understand how Haskell works
05:54:57 <ivanm> *shrug* OK, you can use getArgs to get the actual command line arguments yourself if you want
05:55:10 <aruns> right, so i have parseArgs [] = []
05:55:39 <aruns> parseArgs (k:v:t) = (k, read v) : parseArgs t
05:56:10 <aruns> and i pass in parseArgs System.getArgs, but i'm getting errors about expected [String] and getting IO [String]
05:56:16 <aruns> not sure how to proceed past that
05:56:33 <Botje> do args <- getArgs
05:56:40 <Botje> print (parseArgs args)
05:56:41 <luite> sounds like you have a case of the monads ;)
05:57:42 <opqdonut> aruns: first thing you need to understand is that a list is homogenous. that is, the types a and b must be same for each element of the list
05:58:02 <yrlnry> I just read the Swierstra and Duponcheel paper about error-correcting parser generators.  It is really superb.
05:58:06 <opqdonut> aruns: so you're better off by starting with [(String,String)] as the return type
05:58:14 <aruns> luite: probably, if i can figure out what a monad is :)
05:58:19 <opqdonut> aruns: and adding an interpretation step on top of that
05:59:33 <aruns> Botje: i tried that now i'm getting an error 'Ambiguous type variable 'a' in constraints'
05:59:46 <luite> aruns: in haskell it's a type class (somewhat similar to an interface, if you know Java) that has a few functions
06:00:07 <zygoloid> fasta: ok, you tricked me into looking at merlin again. it assumes that LP can be solved in strongly polynomial time. i'm not looking for more flaws -- one is enough.
06:00:27 <yrlnry> Their parser definition language is just like recursive-descent parser combinators, but the parser representation includes an automatically-calculated boolean that says whether the generated parser could possibly accept the empty input, and a list of the tokens that it could possibly find acceptable as the first token in the input, and a tree that maps those acceptable tokens to sub-parsers that should be invoked in each case.  
06:00:52 <aruns> luite: thanks. slowly getting it, but still not completely clear about how to use it
06:01:15 <yrlnry> So if for example you have a statement parser that has alternatives "while loop" and 17 others and "if statement", and the next token is "IF", it will invoke the "if statement" sub-parser without trying the first 18 parsers that are guaranteed to fail.
06:01:21 <yrlnry> And all this is calculated automatically at compile time.
06:01:28 <yrlnry> I recommend it to anyone who happens to be listening.
06:01:32 <fasta> zygoloid, right, that's what I thought the flaw was too, _but_ when I looked at it again, I couldn't see that there was obviously some place where his numbers where getting really big. 
06:01:37 <luite> aruns: it's used for many things, but there are many specific instances of Monad. they have the same functions, but each one behaves differently. There are some similarities though
06:01:40 <aruns> opqdonu: so define the function as [String] -> [(String, String)] ?
06:01:58 <opqdonut> aruns: yeh
06:02:03 <zygoloid> fasta: that's irrelevant. if the author thinks P=NP, the burden is on him/her to supply the proof, not the reader to make one up.
06:02:13 <fasta> zygoloid, IMHO, the author should have written a proof for that, though. 
06:02:18 <fasta> zygoloid, yes, you are completely right. 
06:02:22 <opqdonut> aruns: or even something like [String] -> [Option], where Option is some suitable data type defined by you
06:02:28 <zygoloid> fasta: otherwise, anyone could just write P=NP, give the well-known algorithm and say "proof left to reader"
06:02:29 <Saizan> yrlnry: that's the one with the Arrow interface?
06:02:44 <fasta> zygoloid, it should never have been published in the first place, then. 
06:02:46 <yrlnry> Saizan:  No, it's all done with applicative functors.
06:03:07 <fasta> zygoloid, OTOH, there is lots of stuff that gets published (like in an actual journal) that should not. 
06:03:10 <zygoloid> fasta: no, i wouldn't say that. it's interesting research, especially if it leads to LP is strongly polynomial => P = NP
06:03:11 <yrlnry> Saizan:  in fact I think it may be the source of the <$> and <*> notations for fmap and ap.
06:03:50 <fasta> zygoloid, yes, the basic concept is interesting, but it is not "done". 
06:03:53 <yrlnry> zygoloid:  Maybe I'm missing something, but that seems obvious.
06:04:13 <fasta> yrlnry, please solve one of the remaining big problems of CS.
06:04:23 <aruns> opqdonut: thanks, trying that
06:04:38 <yrlnry> zygoloid:  the contrapositive is Pâ‰ NP => LP is not strongly polynomial, which appears to be a very weak statement.
06:05:21 <yrlnry> fasta:  A more useful reply would have been to point out what I was missing.
06:05:52 <zygoloid> yrlnry: i'm not sure i see why that's any more obvious.
06:06:12 <fasta> yrlnry, people have been trying to find strongly polynomial algorithms for LP for a very long time. 
06:06:13 <zygoloid> it seems likely to me that P /= NP. it seems plausible that LP is strongly polynomial, and also that it is not.
06:06:14 <aruns> opqdonut: great that worked fine. just for my own understanding. why can't i define the type of the function as [String] -> [(a, b)] ? or [(String, a)]
06:06:42 <Botje> a is not a type, it's a placeholder for a type
06:06:47 <aruns> if the value of an argument is a number, then a would be a Num
06:06:50 <aruns> otherwise a String
06:06:51 <fasta> yrlnry, I have the same opinion as zygoloid. 
06:07:06 <Botje> and once you decide that one element of your list has type (String, Int), a = Int for all every element of the list
06:07:07 <yrlnry> zygoloid:  strongly polynomial means that it is polynomial not merely in the size of the input but in the magnitude of the input numbers?
06:07:08 <merijn> zygoloid: My algorithm for looking at P vs NP papers is that if it claims P=NP and is not being backed by the majority of experts I'm not even gonna bother looking at it :p
06:07:08 <aruns> Botje: yes i know, and thats what i want to use it as.
06:07:28 <zygoloid> Botje: i'm not sure i agree with that. if i write a rank-2 function :: (forall a. [a]) -> Int, then i have to supply a value which works for all types 'a'.
06:07:31 <Botje> because a list enforces that every element has the same type
06:07:59 <Botje> it's true enough until aruns starts messing around with rank2types?
06:08:00 <aruns> ahh right, thanks
06:08:13 <yrlnry> saiam:  the error-correcting parsers thing is here: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.2446
06:08:14 <fasta> merijn, you have to see it as an advanced form of solving a cross-word puzzle.
06:08:18 <yrlnry> Saizan ^^^
06:08:36 <zygoloid> merijn: sounds very reasonable to me. i'd go further. if any P vs NP paper makes it to the stage of being worth looking at (backed by the majority of experts), i probably won't be able to tell whether it's right.
06:09:12 <merijn> zygoloid: True enough :p
06:09:18 <zygoloid> yrlnry: strongly polynomial means that it's polynomial in the /number/ of inputs, independent of their sizes, and it's also in PSPACE.
06:09:27 <zygoloid> (or something like that)
06:09:40 <nbilling> Hi, this may be a naughty question to ask here, but might anyone be able to help me figure out how to get haskell-mode working in emacs?
06:10:08 <fasta> nbilling, read the README?
06:10:23 <fasta> nbilling, use an empty Emacs configuration and follow the README. 
06:10:30 <nbilling> i did, it doesnt address the problem im having
06:10:32 <yrlnry> nbilling:  what seems to be the trouble?
06:10:34 <fasta> nbilling, that should work, and if not contact the author. 
06:10:47 <fasta> nbilling, also, use a supported version of Emacs.
06:11:10 <Saizan> nbilling: seen this page? http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
06:11:20 <nbilling> im using emacs 23.1 i think, i didnt notice anything saying that version wasnt supported
06:11:38 <nbilling> thats the page ive been working off
06:11:43 <zygoloid> yrlnry: (i should also point out that it's polynomial time in the number of primitive arithmetic operations on the inputs, not in the number of steps of a conventional turing machine)
06:11:47 <Saizan> anyhow, what problem are you having?
06:12:27 <yrlnry> zygoloid:  Okay, thanks.
06:12:36 <nbilling> the highlighting works but when i use any of the functions in the menu i get an error saying the symbol i used has a void function
06:12:59 <fasta> zygoloid, but doesn't merely looking at all the equations take a lot of time already? 
06:13:04 <nbilling> eg. Symbol's function definition is void: switch-to-haskell
06:13:13 <yrlnry> nbilling:  I have that same problem.  
06:13:16 <nbilling> for C-c C-B
06:13:27 <yrlnry> nbilling:  did you put (require 'inf-haskell) in your .emacs?
06:13:36 <nbilling> no ill try that
06:14:29 <fasta> zygoloid, if you have a constraint like take (1e9) digits of pi with one variable >= take (1e9) digits of pi, for example.  
06:14:40 <yrlnry> nbilling:  that fixed the problem for me.
06:14:51 <nbilling> oh hey its working now i feel silly
06:15:09 <yrlnry> nbilling:  thanks for helping me!
06:15:13 <luite> zygoloid: PSPACE is the complexity class that contains decision problems that can be solved in polynomial space, it's a superset of NP, that's different from an algorithm that uses poynomial space
06:15:41 <nbilling> i think you got that backwards buddy, you helped me
06:15:45 <nbilling> :)
06:15:58 <yrlnry> nbilling:  No, I've had the same problem for months and was too lazy to deal with it until you showed up.
06:16:04 <nbilling> oh hahahaha
06:16:05 <zygoloid> luite: because it's a collection of decision problems not a collection of algorithms you mean?
06:16:16 <yrlnry> Now that I have it fixed, I feel silly.  Also, I did not know about http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs .
06:17:00 <nbilling> i just noticed one of my lecturers is in this room i hope he didnt see my question lol
06:17:38 <fasta> nbilling, I doubt he/she cares. 
06:18:08 <luite> zygoloid: strongly polynomial says something about an algorithm (although you could make a class of problems that admit strongly polynomial algorithms). But any problem that is in P or in NP also is in PSPACE, so that's not an extra requirement at all
06:18:32 <zygoloid> luite: i...think...that's a 'yes'?
06:19:08 <zygoloid> i certainly meant the-set-of-algorithms-that-run-in-polynomial-space and not PSPACE
06:19:12 <luite> zygoloid: something like that... you could often make an exponential time algorithm that trivially uses polynomial space, for the same problem
06:19:20 <zygoloid> hence my (or something like that) disclaimer! :)
06:19:35 <fasta> P=NP or something like that. 
06:19:39 <zygoloid> haha
06:20:30 <zygoloid> s/it's also in PSPACE/it also runs in polynomial space/ -- happy now?
06:20:59 <luite> somewhat happier at least ;)
06:21:07 <zygoloid> i'm sorry my approximation wasn't precise enough for you! :)
06:21:31 <fasta> luite, why would it even be possible to solve an extremely large class of problems of the form cx<=cx   in strongly polynomial time if c has increasingly more digits?
06:21:33 <cheater> hi guys
06:21:42 <cheater> i have a question not exactly about haskell
06:21:47 <fasta> luite, it almost seems trivially to be impossible. 
06:21:50 <cheater> are bash scripts lazy functional?
06:21:53 <luite> zygoloid: hehe it's already bad enough that many people think "problem in NP -> omg difficult problem" :p
06:22:27 <zygoloid> to be fair, it's easy to see NP and read NP-complete if you're not paying attention
06:22:43 <fasta> Counting numbers is also in NP, surely you can do that, is an easy response in that case. 
06:23:05 <luite> zygoloid: only if you don't know the difference
06:23:17 <zygoloid> luite: ... or you're not paying attention
06:23:19 <luite> fasta: what do you decide with "counting numbers"
06:23:44 <zygoloid> luite: see, it's easy but not easy-complete
06:23:49 <zygoloid> :p
06:23:53 <fasta> luite, strictly speaking whether the amount of numbers would be greater than X, for example. 
06:24:16 <luite> ah
06:24:29 <fasta> luite, it's so easy to misuse the terminology. 
06:24:39 <luite> I had no idea what kind of problem you meant by "counting numbers"
06:24:39 <fasta> er abuse*
06:25:06 <fasta> But I would like to hear some response to the LP constraint I gave. 
06:25:26 <zygoloid> fasta: cx <= cy is constant time in the arithmetic model of complexity
06:26:11 <fasta> zygoloid, I had the impression that they used a different model of complexity for it to be strongly polynomial, but maybe I am wrong.
06:26:23 <zygoloid> fasta: they do, that's the point.
06:26:56 <zygoloid> +, *, /, -, < are all considered to be constant-time, on unbounded integers, aiui
06:27:04 <fasta> zygoloid, I mean a different one from the arithmetic model of complexity.
06:27:38 <fasta> zygoloid, that is, one that is compatible with basically a desktop machine, e.g. RAM model. 
06:28:00 <zygoloid> that sounds like what would normally just be called polynomial time?
06:29:19 <fasta> zygoloid, so, there is a weakly polynomial one, and not a strongly polynomial one and certainly not a polynomial one. 
06:29:51 <zygoloid> fasta: if there's a {weakly|strongly} polynomial algorithm then there's a polynomial algorithm.
06:30:10 <opqdonut> not on a TM
06:30:50 <Phyx-> I seem to remember someone telling me about GhcPkg.hs but I don't remember if that was in Cabal or Cabal-Install
06:30:59 <luite> strongly polynomial time means that you can run it in polynomial time on a TM that doens't have these constant time arithmetic things
06:31:32 <fasta> luite, that sounds right.
06:32:17 <zygoloid> opqdonut: yes, on a turing machine.
06:32:51 <zygoloid> strongly/weakly polynomial time is a partition of polynomial time algorithms into two subcategories.
06:33:09 <luite> if you bound the space, you can execute those operations in polynomial time on a regular TM... so if you add that requirement, you kan just keep using the easier arithmetic model
06:33:37 <zygoloid> and that's why the space bound is part of the definition of strongly polynomial time :)
06:34:52 <EvanR-wo1k> how about a turing machine that doesnt have constant time state shift, tape shift ;)
06:37:11 <zygoloid> EvanR-wo1k: how about a turing machine with the tape removed? :)
06:37:18 <Saizan> Phyx-: Cabal, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/Cabal-1.8.0.4/Distribution-Simple-Program-HcPkg.html
06:37:42 <Phyx-> Saizan: thanks alot! I for some reason couldn't find it
06:38:08 <Saizan> Phyx-: it's a wrapped around the executable, the code for ghc-pkg itself is inside ghc's tree and i don't know if it's exposed by the ghc-api
06:38:22 <Saizan> s/wrapped/wrapper/
06:38:43 <Phyx-> Saizan: I only need a listing of packages, exposed modules and their locations
06:39:15 <Saizan> Phyx-: see "dump" then :)
06:41:19 <Phyx-> Saizan: yeah, I was looking at it last time, but couldn't find how to build a ConfiguredProgram, it seems to want the path, but I assume there should be a default somewhere
06:42:48 <Saizan> Phyx-: look at Distribution.Simple.Program
06:43:49 <Phyx-> Saizan: ah, thanks, that'll work :)
06:45:15 <azaq23> @bot
06:45:28 <Saizan> ghcPkgProgram/configureProgram/lookupProgram/emptyProgramDb are those that you're going to need :)
06:46:53 <Phyx-> Saizan: nice! maybe I can finally get this written today :)
06:50:27 <Saizan> otoh you could look at what Distribution.Simple.GHC.configure does, and check if it's relevant for you.. it feels like this code needs a bit of simplification
06:54:05 <Phyx-> whoops, crashed
06:54:11 <Phyx-> I really need to fix that bug :/
06:54:22 <Phyx-> Saizan: cool, taking a look now
06:54:46 <Phyx-> hm, need the Hi files too
07:00:07 <Saizan> Phyx-: i've used this in the past: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29473#a29473
07:00:37 <Saizan> InstalledPackageInfo contains the path to the directory with the .hi files
07:01:45 <Phyx-> Saizan: oh, that should work then, thanks :) that saves me time 
07:01:48 <Phyx-> Saizan++
07:04:06 <Phyx-> things are oddly simple once you know how they work :/
07:10:54 <Saizan> yeah, and it feels like wandering in a forest until you get to that point..
07:12:51 * lantti likes wandering in forest
07:13:20 <yitz> @karma Saizan
07:13:38 <edwardk> preflex: xseen kmc
07:13:39 <preflex>  kmc was last seen on freenode/#haskell 6 hours, 44 minutes and 22 seconds ago, saying: yeah mm_freak_, but how often do you code a sort yourself versus calling a standard library function?
07:13:48 <copumpkin> omg an edwardk
07:13:52 * edwardk hides.
07:14:02 <Saizan> a wild edwardk appears!
07:14:06 <yitz> preflex: seen lambdabot
07:14:06 <preflex>  lambdabot was last seen on #ghc 3 hours, 33 minutes and 50 seconds ago, saying: Couldn't find fortune file
07:14:16 <edwardk> great, now i need to fear a pokeball ;)
07:14:20 <copumpkin> in his natural habitat!
07:14:51 <djahandarie> edwardk, I think there was some guy who thought one of the comonad laws was wrong somewhere and something to do with category-extras yesterday
07:15:06 <djahandarie> I don't really know, ask ski :P
07:15:29 <edwardk> copumpkin: having spent probably just over half my life logged into irc in some fashion, i suppose you are correct ;)
07:15:53 <edwardk> djahandarie: i think i do have a bug in the statement of the comonad laws in the current category-extras actually
07:16:27 <edwardk> djahandarie: the HEAD version has that fixed, but i never pushed it out as it was a documentation change while a bunch of much bigger changes are looming in the same area ;)
07:16:48 <djahandarie> Ah lol, neat
07:17:10 <djahandarie> Do these bigger changes involve making it more digestible?
07:17:11 <fasta> Why do people advertise they are on an iphone? 
07:17:24 <fasta> Is the input device so bad that they forget to spell or something like that?
07:17:46 <edwardk> fasta: in emails?
07:17:56 <fasta> edwardk, for example.
07:17:59 <edwardk> fasta: the default iphone config sets that as your sig basically
07:18:18 <fasta> edwardk, ok. 
07:18:28 <edwardk> so its more a matter that they are too lazy to change the defaults. ;) i know that is why my iphone emails go out with it ;)
07:18:52 <edwardk> as for jystic here? no idea ;)
07:20:24 <luite> and speaking of doc fixes, it appears that the ad package doesn't use System.Mem.StableName anymore, for reverse mode ad?
07:20:55 <edwardk> luite: it currently uses a package that uses it
07:21:12 <edwardk> luite: it goes through data-reify at the moment
07:21:36 <edwardk> though i will probably have to revert to doing it myself when i get around to allowing for smaller 'black box' jacobians
07:21:41 <copumpkin> edwardk: there's a new CT library for agda by the way :)
07:21:51 <edwardk> copumpkin: nice =)
07:21:58 <edwardk> copumpkin: i didn't even have to write this one!
07:22:04 <copumpkin> yeah!
07:22:35 <BMeph> Next up, here's a little number by Edward Kmett, and the Black-Box Jacobians! <cheers> :)
07:24:25 <luite> edwardk: ah ok. I hope I can use the package in my program, used fad before, but it was too slow, so I wrote my own (very limited) package for only first derivatives on vector
07:25:16 <luite> but I have the feeling that this whole thing that I'm writing will be way too slow...
07:26:53 <edwardk> luite: yeah the 'ad' package does a bunch of different ad modes, including compositions of them. i'm looking at changing the api at some point to invert control a bit, so i can have something like "AD Vector s a"  or "AD Scalar s a" (where you can substitute most any traversable for Vector/Scalar), that'll let me do a lot of things.
07:27:12 <luite> ah that would be nice
07:27:38 <edwardk> in particular i can then precompute a jacobian fragment to apply, i can let 'vgrad' take multiple vectors and scalars, etc.
07:28:17 <edwardk> and separating the infintesimal from the ad mode again would let me get better optimization from the compiler
07:30:10 <edwardk> (it'd also cut down drastically on the number of stablenames required)
07:30:13 <BMeph> BBIAB, sound issues...
07:31:06 <nomeata> Hi. Iâ€™m generating some output using Text.PrettyPrint.HughesPJ. Now I need the coordinates (as in row and column) of some parts of the output. How could I achieve that?
07:31:07 <nomeata> Ideally, I
07:31:31 <luite> by the way I have some equations...   a1^(-f1(x1,x2,x3) + a1(-f2(x1,x2,x3)) = 1,  a2^(-g1(x1,x2,x3)) + a2^(-g2(x1,x2,x3)) = 1   where f1,f2,g1,g2 are linear functions. is there any way to determine whether a1 > a2 regardless of the values of x1,x2,x3 ?
07:31:51 <nomeata> Ideally, there were a function "annotate :: Int -> Doc -> Doc" and at the end a "possitions :: Doc -> [Int, (Int,Int)]", but the API does not seem to allow such a function.
07:32:25 <luite> oops forgot a ^ somewhere
07:32:55 <fasta> nomeata, in my experience those libraries are all incomplete for real tasks. 
07:33:13 <nomeata> fasta: So I need to re-implement it myself?
07:33:15 <fasta> nomeata, I think I like the Leijen one better, though. 
07:33:42 <fasta> nomeata, I think it is better to simply fork if you need changes.
07:33:58 <nomeata> I see
07:34:01 <fasta> nomeata, that is, assuming you think it is worth reusing the code at all. 
07:34:38 <nomeata> The smartness of $$ and sep is nice...
07:34:50 <fasta> For example, AFAIK, you cannot write "display a few data columns" with any of the combinators, AFAIK.
07:35:09 <fasta> You can use it for parts of the problem, though, but not as one Doc expression.
07:35:20 <ajnsit> where can I find the source of ycr2js?
07:35:37 <aruns> i'm trying to use gnuplot - Grahpics.Gnuplot.Simple. but whatever i call it with - even something as simple as plotList [] [1..10] results in this -  Ambiguous type variable `t' in the constraints: `Graphics.Gnuplot.Value.Tuple.C t'
07:36:04 <aruns> the same code processes without errors in ghci, though i dont see anything. (still trying to figure out where it plots to)
07:36:31 <fasta> aruns, ghci understands a different language. 
07:36:39 <fasta> aruns, in particular [] means something else. 
07:37:17 <fasta> aruns, or rather maybe [1..10] in this case.
07:37:25 <fasta> aruns, anyway, add a type annotation. 
07:37:38 <fasta> aruns, something like (1::Int) will probably work. 
07:41:47 <aruns> fasta: thanks. so plotList [] [1::Int .. 10::Int] ?
07:42:26 <fasta> aruns, [1::Int .. 10]
07:42:37 <fasta> aruns, you don't need two annotations. 
07:42:52 <fasta> aruns, you can look at the type using :t
07:43:08 <aruns> parse error on input `Int..' thats the error i get
07:43:08 <fasta> aruns, 1 :: (Num t) => t
07:43:33 <edwardk> luite: well if you're simplifying and f1,f2,g1,g2 are just being documented as linear you should at least be able to remove the - by subsuming it into the functions, simplifying the problem statement slightly
07:43:34 <fasta> aruns, not if you input exactly what I had. 
07:44:10 <luite> edwardk: yeah that step was still within my capabilities :p
07:44:21 <edwardk> ;)
07:44:23 <aruns> fasta: back to the same error - Ambiguous type variable `t' in the constraints: `Graphics.Gnuplot.Value.Tuple.C t'
07:44:35 <fasta> aruns, give a type to the empty list. 
07:44:42 <fasta> aruns, an empty list of _what_?
07:44:53 <fasta> aruns, bananas, ints, floats?
07:45:00 <luite> edwardk: it's probably going to require some iterative decision procedure, since solving for a1 and a2 is non-algebraic
07:45:00 <aruns> [::Attribute] ? like that
07:45:11 <fasta> aruns, like []::[Int]
07:45:14 <edwardk> luite: do you know te formula for f1, f2, g1, g2?
07:45:24 <fasta> aruns, with  ([]::[Int])
07:45:31 <luite> edwardk: yes I have a map of the coefficients
07:45:33 <fasta> aruns, I have no idea whether that is the right type.
07:46:32 <fasta> aruns, plotList uses relatively advanced hackery to present this "easy" interface, but if you don't understand how it works, it only causes pain. 
07:46:53 <edwardk> luite: nothing pretty comes to mind
07:47:41 <luite> edwardk: there are some easy cases, if both f1(x1,x2,x3) < g1(x1,x2,x3) for all values of x_n, and the same for f2/g2, but I don't know how to solve it in general
07:50:50 <luite> comparing the linear functions that way is relatively easy, it's a linear programming problem... (oh I forgot to say that there are some constraints between the x1,x2,x3, in particular, x1 < x2 < x3, and x3 - x2 < x1 - x2)
07:51:08 <luite> err, that should be x2 - x1
07:52:07 <fasta> aruns, got it working?
08:19:03 * hackagebot snap-core 0.2.10 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.10 (DougBeardsley)
08:23:04 * hackagebot snap-server 0.2.10 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.10 (DougBeardsley)
08:26:51 <yrlnry> Are type constructors considered types?  Or are types considered the strict subset of type constructors which have kind * ?
08:27:20 <roconnor> yrlnry: they shouldn't be considered types
08:27:22 <Philippa> the latter
08:27:29 <roconnor> but in some writings the might be
08:27:43 <yrlnry> Thanks.
08:28:07 <zygoloid> i've heard some people say that type constructors must have kind k1 -> k2, but i don't think that's the conventional understanding
08:28:28 <roconnor> zygoloid: I've heard some people say that functions must have type a -> b.
08:28:28 <yrlnry> Surely people consider Int to be a type constructor of kind *?
08:28:37 <roconnor> *cough* conal
08:29:00 <dolio> Value constructors needn't be functions.
08:29:16 <roconnor> o_O
08:29:28 <EvanR-wo1k> i like the idea that all functions take exactly one argument
08:29:51 <roconnor> what are value constructors, if they are are not functions?
08:30:01 <dolio> Nothing is not a function.
08:30:12 <zygoloid> roconnor: conal is right
08:30:14 <EvanR-wo1k> Nothing is Nothing
08:30:42 <zygoloid> yrlnry: looking through the haskell report, i see: type constructors are things like Either or Maybe. Either Int is not a type constructor.
08:30:43 <roconnor> zygoloid: perhaps.  I'm ambivalent
08:30:52 <zygoloid> and types can have kinds other than *.
08:31:02 <yrlnry> Interesting.
08:31:06 <wjt> where's the bot when I want it :'(
08:31:11 <zygoloid> http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-630004.1
08:31:14 <yrlnry> I wonder if the terminology in the report is obsolete?
08:31:17 <zygoloid> ^^ see if your reading matches mine?
08:31:19 <yrlnry> s/obsolete/outdated/
08:31:22 <zygoloid> yrlnry: this is the haskell 2010 report
08:31:24 <djahandarie> So type constructors are a subset of types where the kind is not * ?
08:31:31 <roconnor> yrlnry: I think so.
08:31:43 <yrlnry> zygoloid:  I thought the 2010 report was only a minor update from the 1998 report, and that no effort was made to rewrite it.
08:31:46 <zygoloid> djahandarie: no, type constructors are the things declared in type, data, newtype declarations
08:31:58 <zygoloid> djahandarie: Int is a type constructor.
08:31:59 <roconnor> yrlnry: I think the report evolved in such a way that terms changed their meanings so that the words being used were no longer correct.
08:32:07 <Cale_> Something I've occasionally wondered is what it would be like to have a type system where type constructors/types with kind other than * could have values.
08:32:32 <yrlnry> Cale:  that's how I got to this question in the first place.
08:33:06 <yrlnry> zygoloid: I see that it uses the phrase "nullary type constructors", which seems to me to require that "Int" etc. are type constructors.
08:33:16 <wjt> can anyone think of a good example of a situation where Maybe (Maybe a) is a useful type? :)
08:33:17 <zygoloid> yrlnry: later on it defines type constructor.
08:33:36 <zygoloid> see 4.1.2
08:33:45 <Philippa> yrlnry: they are, same as True is a data constructor
08:33:48 <dolio> @type join :: Maybe (Maybe a) -> Maybe a
08:33:59 <yrlnry> It also says " Îº1 â†’ Îº2 is the kind of types..." so that a type might have kind * -> *.
08:34:24 <wjt> dolio: i'm trying to think of a concrete example of a useful value of that type.
08:34:27 <zygoloid> yrlnry: yep. i think most of your initial responeses in here were wrong ;)
08:34:32 <Philippa> yeah, really 'type' is slightly overloaded because what else do you call expressions on the type level?
08:34:46 <djahandarie> So basically anything in a type signature that isn't a type variable is a type constructor
08:34:49 <yrlnry> Oho, they are distinguishing between the literal "Int" in the source code, which is the type constructor, and the Int type itself, which is constructed when you write "Int".
08:34:54 <djahandarie> Besides application etc
08:35:12 <zygoloid> djahandarie: the individual non-paren, non-variable tokens are type constructors, more-or-less
08:35:41 <Cale_> wjt: *Usually* we join away multiple layers of Maybe straight off, but it's possible to represent multiple points of failure like that. Probably better to use a different type for that though.
08:36:03 <zygoloid> djahandarie: in  Maybe a -> [a]  (== Maybe a -> [] a), Maybe, [] and (->) are type constructors.
08:36:43 <dolio> wjt: There's a way to represent lambda terms using increasing nestings of Maybe as the variables. If you start at 'data Void -- no values', then each time you wrap it in Maybe, you add one additional value.
08:36:56 <djahandarie> Yeah okay
08:37:35 <yrlnry> And both types and type expressions have kinds, analogous to the way both values and value expressions have types.
08:37:49 <Cale_> (->) (Maybe a) ([] a)
08:38:14 <dolio> So that any 'Term Void' can only represent well-scoped lambda terms, like '\x f -> f x' but not '\x -> f x'.
08:38:27 * Cale_ considers how much it would affect our programming style if the function type constructor was always written prefix.
08:38:41 <djahandarie> I should probably get around to reading the report, I haven't yet
08:38:57 <yrlnry> It reads badly.
08:39:23 <fasta> x:: (-> (-> a b c d) a c d f e)
08:39:37 <fasta> That doesn't seem very convenient. 
08:39:38 <Cale_> It would probably force us back into using uncurried functions.
08:40:11 <Cale_> At least, in the deeply nested cases.
08:40:23 <yrlnry> No one shall cast us out of the paradise that SchÃ¶nfinkel has created for us.
08:40:40 <dolio> wjt: data Term v = Bound v | App (Term v) (Term v) | Lam (Term (Maybe v))
08:40:48 <wjt> Cale_, dolio: fwiw this is fall-out from a discussion of whether to support Maybe (Maybe a) in the D-Bus type system. I'm completely failing to find an example of why it might be useful, but I don't think that's a good reason to forbid it :)
08:41:14 <dolio> Oh, well, that's another matter.
08:42:09 <wjt> but it made me start wondering about contexts where it'd be useful
08:42:16 <zygoloid> Cale_: wrt having values for types with kinds other than *, what would you do about the kind of (->) ?
08:43:55 <dolio> Anyhow, with renaming, you can make sense of Maybe and Void as type-level naturals, where the number they correspond to is how many well-defined elements they have.
08:44:22 <wjt> dolio: mmm, yep
08:44:34 <Cale_> wjt: Uh, yeah it would be totally unnatural to forbid it.
08:44:39 <dolio> data Z {- no elements -} ; data S n = FZ | FS n
08:44:46 <wjt> Cale_: yeah, it's completely self-evident to me
08:44:55 <wjt> Cale_: but I just asked around my office and I'm in a minority :(
08:45:04 <Cale_> wjt: You'd hope that any nested construction of type constructors would be representable. A type constructed by a type constructor should be the same as any other type.
08:45:06 <wjt> Cale_: it's as illogical as forbidding a list of lists would be
08:45:19 <zygoloid> wjt: would you have something like Either Bool a?
08:45:22 <dolio> S (S (S (S Z))) = FZ | FS FZ | FS (FS FZ) | FS (FS (FS FZ))
08:45:41 <Cale_> wjt: Lots of C programmers there?
08:46:14 <wjt> zygoloid: D-Bus doesn't have tagged unions; it only has variants, which can contain a value of any type, tagged with its type (including variants, though apparently that's also a bone of contention for the same reason!)
08:46:14 <Cale_> wjt: Even in C, the various ways to construct types will recursively nest in a reasonable way though...
08:46:46 <wjt> Cale_: right, Foo ** is a perfectly meaningful type. But Just Nothing doesn't have a sane representation in Python (if you equate None with Nothing), for instance
08:47:12 <zygoloid> wjt: it does if you don't equate Just with id
08:47:19 <wjt> Cale_: (and yes, C programmers aplenty :))
08:47:22 <Cale_> You probably shouldn't equate them, given that None already otherwise has meaning in Python.
08:47:23 <wjt> zygoloid: sure.
08:47:55 <Cale_> (but I'm not much of a Python programmer)
08:47:58 <fasta> wjt, why are you inventing an adhoc type-system in the first place?
08:48:06 <wjt> fasta: i'm not! it's the d-bus type system
08:48:17 <wjt> http://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-signatures
08:48:22 <Cale_> I would say that if you're representing Maybe, its data constructors should be separate from those of any other type.
08:48:28 <fasta> wjt, I had the impression you were a developer on D-Bus. My bad.
08:48:36 <wjt> fasta: well, I am, but it already exists :)
08:49:01 <roconnor> @hoogle Maybe (Maybe a)
08:49:05 <Cale_> wjt: Wow, that looks brutal.
08:49:13 <fasta> wjt, for a protocol, I don't think anyone cares. 
08:49:14 <zygoloid> i can /understand/ forbidding Maybe (Maybe a) if the mindset is that Maybe means 'nullable' or whatever
08:49:21 <zygoloid> but nullable itself is a bit of a dumb idea imo
08:49:24 <wjt> zygoloid: yeah, that seems to be the mindset difference
08:49:30 <fasta> wjt, as long as you can express everything in some non-ridiculous way.
08:49:49 <EvanR-wo1k> i asked about Maybe (Maybe a) before
08:49:52 <EvanR-wo1k> i was told its useful ;)
08:49:53 <fasta> wjt, by non-ridiculous, I mean efficient. 
08:50:05 <zygoloid> EvanR-wo1k: indeed it is :)
08:50:14 <EvanR-wo1k> what is 'nullable' ?
08:50:32 <fasta> EvanR-wo1k, that it can be null?
08:50:42 <dolio> Ever used Java?
08:50:44 <wjt> Cale_: I actually kind of like the D-Bus type system. (A lot more than I like some other things about it)
08:50:48 <EvanR-wo1k> not really
08:51:00 <zygoloid> EvanR-wo1k: it's a flag on a type which says whether it has a special 'null' value
08:51:11 <EvanR-wo1k> so like Maybe ?
08:51:20 <zygoloid> like maybe except non-composable
08:51:42 * fryguybob is amused that his wife just asked him "what is an emac?"
08:52:05 <midorikid> Sounds like a hightech hamburger.
08:52:07 <fasta> http://blogs.msdn.com/b/ericgu/archive/2004/05/27/143221.aspx
08:52:11 * hackagebot snap-server 0.2.10.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.10.1 (GregoryCollins)
08:52:17 <fasta> Don't read that if you want to retain your eyes.
08:52:55 <EvanR-wo1k> zygoloid: so Maybe is different because it can apply to any type, and nullable is only for some types
08:53:27 <EvanR-wo1k> like, atomic types
08:53:29 <dolio> EvanR-wo1k: In Java, every variable of object type is actually a pointer to the memory allocated to that object. So it can either be a null pointer or something that points to an actual object.
08:53:41 <zygoloid> fryguybob: "The eMac, short for education Mac, was a Macintosh desktop computer made by Apple Inc. It was originally aimed at the education market, then available as a cheaper mass market option over Apple's second generation iMac."
08:53:51 <EvanR-wo1k> dolio: ok
08:53:57 <fryguybob> zygoloid: :D
08:54:08 <zygoloid> EvanR-wo1k: right. in particular, nullable cannot be applied to nullable types
08:54:09 <dolio> If you try to call a method on a null pointer, an exception is thrown.
08:54:12 <fryguybob> She was going for singular of emacs.
08:54:38 <zygoloid> fryguybob: yeah, i guessed ;)
08:54:50 <EvanR-wo1k> does this java thing have anything to do with the dbus issue ?
08:54:51 <Cale_> An emac would be just one macro, I guess.
08:54:52 <dolio> And you can return or test for the null pointer using the name 'null'.
08:55:12 * hackagebot snap-server 0.2.10.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.10.2 (GregoryCollins)
08:55:35 <fryguybob> Cale_: In a dynamic language I guess you could get away with just one...
08:55:39 <EvanR-wo1k> dolio: btw, is there a way to make null be invalid or an error?
08:55:46 <roconnor> maybe maybe is a result of an process that may fail that returns the results of another process that may fail.  Essentially it is a two level error thing, and seems like it would be great to use in DBus if you want to know which component failed.
08:55:52 <dolio> EvanR-wo1k: What do you mean?
08:55:53 <EvanR-wo1k> otherwise that seems pretty messed up
08:56:03 <EvanR-wo1k> that any object varable can be null
08:56:12 <Cale_> (for the E editor :)
08:56:32 <dolio> Yes. Any object variable can be null.
08:56:33 <EvanR-wo1k> would be nice to make it so 'cant be null'
08:56:35 <dolio> Which is, of course, bad.
08:56:36 <arw_> EvanR-wo1k: basic datatypes like int or float are not nullable. but everything else is.
08:56:48 <EvanR-wo1k> in java or dbus or?
08:56:54 <dolio> In Java.
08:56:57 <arw_> EvanR-wo1k: the only way to ensure some not-null constraint is using accessors. in java i mean
08:57:08 <EvanR-wo1k> how?
08:57:21 <dolio> C and C++ are the same way. Any pointer type has a designated null value that doesn't actually point to anything.
08:57:40 <arw_> EvanR-wo1k: if your setSomething is called with null, throw an exception.
08:57:44 <EvanR-wo1k> C and C++ also have a state where its not null *and* doesnt point to anything ;)
08:57:59 <copumpkin> EvanR-wo1k: a segfault variable? :)
08:58:10 <copumpkin> (a hardcore type theory term)
08:59:23 <EvanR-wo1k> lol
08:59:47 <EvanR-wo1k> arw_: ah
08:59:59 <copumpkin> this nectarine tastes funny
09:00:20 <dolio> Anyhow, people are slowly realizing this was a mistake, so there's interest in systems where you can have 'nullable' types that include the null pointer (and thus, you should test for it, maybe), and non-nullable types that can't (so you don't have to test).
09:00:31 <dolio> Which is like Maybe T vs. T.
09:00:36 <EvanR-wo1k> genius
09:00:44 <EvanR-wo1k> why hasnt anyone thought of that before
09:00:51 <zygoloid> dolio: c++ has references, which aren't nullable, and other non-pointer types, at least
09:00:56 <EvanR-wo1k> also i noticed in databases the default is nullable
09:01:01 <dolio> Yeah, true.
09:01:06 <copumpkin> yeah but references are the devil's work
09:01:09 <EvanR-wo1k> like not nullable was a feature slapped on at the end
09:01:18 <kmc> yeah, references are not first-class
09:01:18 <copumpkin> I am not a fan
09:01:19 <arw_> EvanR-wo1k: many people have thought of this before, but many language designers ignore previous work as a matter of principle.
09:01:28 <kmc> "references are non-nullable" is a rule in C++ like any other, which is to say, advisory
09:01:34 <dolio> Although, if you want dynamic memory management, you're stuck, no?
09:01:45 <kmc> it's possible to make a null ref and people do, and it usually does what you expect, never mind what the spec says
09:01:50 <zygoloid> arw_: "all other languages suck, i'm going to invent something new" syndrome?
09:01:53 <copumpkin> kmc: I mostly am not a fan that a function you call can change your local variables without you explicitly letting it
09:01:59 <fasta> dolio, nulls are not a mistake by themselves, fromJust can crash just as hard. 
09:02:09 <kmc> copumpkin, ah.  that's just syntax but i agree it's bad
09:02:13 <arw_> zygoloid: yes. 
09:02:16 <kmc> (there's no explicit "take a reference" operator)
09:02:34 <copumpkin> kmc: I'd call it a little more than syntax, but not much :)
09:02:44 <fasta> If you really want to change something you need to go and to Total Functional Programming for example.
09:02:52 <fasta> do*
09:03:01 <copumpkin> omg we need total haskell
09:03:04 <copumpkin> :P
09:03:13 <zygoloid> kmc: c++ has basically no runtime invariants which can be enforced. at all. so whatever ;)
09:03:19 <kmc> yeah
09:03:39 <dolio> All values automatically containing an extra distinguished null value that you have to test for (and can forget to test for) is the mistake.
09:03:41 <kmc> i like the part where it is literally impossible to write performant portable multi-threaded C++ code
09:04:01 <fasta> dolio, it would be trivial to write a compiler that says "you didn't check for null". 
09:04:10 <zygoloid> dolio: as compared to all values automatically containing an extra distinguished bottom value that you cannot test for? ;-)
09:04:17 <fasta> zygoloid, right
09:04:20 <copumpkin> zygoloid: not letting you test for it is a good thing
09:04:36 <dolio> Great, it's trivial, but no one does it.
09:04:45 <zygoloid> copumpkin: i can't disagree with a feature which makes my programs computable ;)
09:04:46 <mtnviewmark> fasta - but you couldn't reasonable write a compiler that says "you didn't check for -1" --- a common "error" return value
09:05:05 <dolio> zygoloid: Bottom is not the same as null.
09:05:07 <fasta> mtnviewmark, why not?
09:05:20 <fasta> mtnviewmark, you can adapt your compiler for every broken library you interface to. 
09:05:33 <fasta> mtnviewmark, it just depends on how large your organization is. 
09:05:38 <zygoloid> dolio: no, i was speaking tongue-in-cheek.
09:05:45 <mtnviewmark> because how does the compiler know which functions (expressions) have -1 as an exception value that should be checked for, vs. which have -1 as just a normal value?
09:06:05 <medfly> ?
09:06:13 <fasta> mtnviewmark, it has to be be told that by whoever creates the -1 to begin with.
09:06:19 <EvanR-wo1k> yes its better to have two totally different kinds of results, normal and error code
09:06:28 <EvanR-wo1k> or else, a normal one, but it throws an exception
09:06:37 <mtnviewmark> ah- which point you've essentially enhanced the type system of C++.... :-)
09:06:52 <fasta> The problem is that people confuse things. 
09:07:13 <mtnviewmark> indeed, because in C++, it is far to easy to return int   and very hard to return a thing like Maybe int
09:07:32 <EvanR-wo1k> isnt there a 'polymorphic' pair object?
09:07:37 <mtnviewmark> well, s/very hard/painful/
09:07:38 <zygoloid> mtnviewmark: not at all. it's easy to implement Maybe in C++...
09:07:47 <mtnviewmark> yes, I can implement it to
09:07:49 <fasta> EvanR-wo1k, boost has boost::none_t. 
09:08:06 <copumpkin> zygoloid: except no pattern matching and no non-ugly form of monads :P
09:08:07 <EvanR-wo1k> ah boost
09:08:12 <EvanR-wo1k> c++ ++ ;)
09:08:13 <copumpkin> b00st
09:08:14 <mtnviewmark> but  you're not going to find libraries suddenly taking   Maybe<int> 
09:08:16 <zygoloid> copumpkin: right, i was about to say :)
09:08:24 <copumpkin> or even functors 
09:08:27 <zygoloid> mtnviewmark: a lot of our c++ code does :p
09:08:28 <copumpkin> (in the sense we mean them)
09:08:30 <mtnviewmark> (also, frankly, it isn't possible to write   Maybe<x> in general for all x in C++)
09:08:49 <fasta> EvanR-wo1k, or whatever its name exactly is. 
09:08:56 <kmc> boost::optional?
09:09:02 <Martty> ofc there is whtcrap
09:09:03 <fasta> mtnviewmark, it already exists.
09:09:10 <fasta> kmc, yes
09:09:15 <kmc> boost::variant uses function overloading for a poor man's version of pattern-matching
09:09:17 <kmc> it's kind of cute
09:09:24 <mtnviewmark> doesn't it require a default constructor? or is just a safe wrapper around union?
09:09:28 <fasta> I have used boost::optional, it's pretty decent. 
09:10:09 <kmc> of course your co-workers will think you're crazy if you use boost
09:10:25 <Martty> O_o boost is used in development quite a lot
09:10:38 <zygoloid> mtnviewmark: no default constructor required.
09:10:44 <Martty> its not that crazy considering many parts end up in the standard
09:10:47 <kmc> yeah
09:10:58 <mtnviewmark> so the internals of boost:optional must be a bit squirelly - but okay
09:10:58 <kmc> but how much code uses boost::optional, and how much code uses returning a null pointer
09:11:03 <zygoloid> mtnviewmark: getting it to have an efficient memory layout /and/ no default constructor /and/ no compiler-specific hacks is challenging
09:11:08 <kmc> mtnviewmark, it's about 1000 LoC
09:11:08 <mtnviewmark> none the less, I don't see much C++ code using it in the wild
09:11:14 <zygoloid> maybe impossible? due to alignment issues
09:11:30 <mtnviewmark> kmc / zygoloid: exactly! 
09:11:51 <Martty> what is GHC written in?
09:11:56 <kmc> Haskell
09:11:57 <copumpkin> ghc haskell
09:12:01 <kmc> (with GHC extensions)
09:12:06 <Martty> O_o
09:12:14 <kmc> Haskell is a good language for writing compilers
09:12:17 <zygoloid> Martty: the RTS is a combination of C, Cmm and a little haskell
09:12:17 <Martty> what was it first written in
09:12:24 <kmc> Martty, Haskell i think
09:12:24 <Martty> k
09:12:24 <fasta> Perl
09:12:27 <fasta> ;)
09:12:27 <kmc> there are other Haskell compilers
09:12:30 <kmc> and interpreters
09:12:45 <kmc> imo the best approach is to pair your shiny self-hosting compiler with a small portable interpreter in C
09:12:46 <fasta> GHC still depends on Perl, though.
09:12:58 <kmc> unfortunately i don't think any Haskell interpreter currently in existence can run GHC
09:13:13 <kmc> fasta, even if you're doing unregisterised or native-code builds?
09:13:21 <kmc> (native codegen i mean)
09:13:33 <fasta> kmc, I don't remember. 
09:13:59 <dolio> Only the optimizing GCC backend uses Perl, as far as I know.
09:14:04 <zygoloid> kmc: ghci maybe? ;-)
09:14:15 <dolio> Which is going to be dropped Any Time Now.
09:14:29 <fasta> dolio, you are right.
09:14:58 <zygoloid> GHC head can only be compiled with an earlier GHC release, which can only be compiled with an earlier GHC release, which...
09:15:21 <zygoloid> you have to go about 12 compilers back before you get to something which can be built with something else
09:15:21 <EvanR-wo1k> no stop solving the chicken and egg paradox!
09:15:28 <EvanR-wo1k> its supposed to be a paradox
09:15:49 <zygoloid> EvanR-wo1k: paradoxes are only supposed to be apparent contradictions :)
09:15:51 <dolio> Probably goes back to hbc, eventually.
09:16:01 <lispy> Actually, I think the Perl stuff is gone now.  At least the evil mangler is gone, right?
09:16:10 <EvanR-wo1k> so what were saying is current ghc cant compiler ghc?
09:16:17 <EvanR-wo1k> cant compile current gcc?
09:16:24 <dolio> It's not gone because -fvia-c is still around.
09:17:30 <Phyx-> @hoogle (IO a, IO b) -> IO (a, b)
09:18:15 <dolio> uncurry $ liftM2 (,)
09:18:25 <copumpkin> or liftA2
09:19:19 <co_dh> :t liftA2
09:19:30 <fryguybob> liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
09:19:56 <Phyx-> ty
09:21:22 <co_dh> how can I create an object of IO a ? for example, IO int?
09:21:30 <kmc> create from what?
09:21:34 <kmc> from doing some IO, or just from an Int?
09:21:39 <kmc> return :: a -> IO a
09:21:47 <co_dh> > return 5
09:21:55 <Cale_> :t return 5
09:21:56 <co_dh> > return 5 :: IO Int
09:21:57 <djahandarie> lambdabot is gone
09:22:04 <Cale_> oh, I'll bring it back
09:22:05 <Phyx-> @pl \pkg->liftA2 (,) (return $ sourcePackageId pkg) (resolve pkg)
09:22:08 <Phyx-> hrm
09:22:11 <Phyx-> botty died again?
09:22:15 <kmc> co_dh, the way you build IO actions is a) using primitives like putStr, b) using "return" to make actions that don't do any IO, or c) by gluing together smaller actions
09:22:19 <kmc> co_dh, http://haskell.org/haskellwiki/Introduction_to_IO
09:22:27 <djahandarie> Cale_, what is the usualy reason lambdabot goes down anyways?
09:22:34 <djahandarie> usual*
09:22:41 <Cale_> djahandarie: Network failure
09:22:42 <Phyx-> djahandarie: it's that time of month
09:23:00 <djahandarie> Why doesn't it just have code to attempt to reconnect?
09:23:01 <Cale_> djahandarie: It doesn't seem to be able to detect when it has been disconnected from the IRC server.
09:23:12 <djahandarie> Check pings!
09:23:14 <Cale_> It still thinks it's connected just fine, for some reason.
09:23:14 <fryguybob> Phyx-: ap (liftA2 (,) . return . sourcePackageId) resolve
09:23:33 <Phyx-> fryguybob: yeah, but I think that looks worse though
09:23:51 <fryguybob> Phyx-: Just filling in for lambdabot :D
09:23:52 <Phyx-> djahandarie: You could just check to see the socket state
09:23:55 <Phyx-> fryguybob: hehehe
09:24:15 <djahandarie> Phyx-, isn't it just closed or open?
09:24:44 <djahandarie> I think it'd be able to detect if the socket state change, just that it doesn't for some reason
09:24:48 <djahandarie> I've had something like that happen to me
09:25:00 <co_dh> > liftA2  (+) (return 5 :: IO Int) (return 6 :: IO Int)11
09:25:12 <co_dh> that's what I want to do. I want to test liftA2
09:25:24 <djahandarie> Unrelated; I seem to not program "functionally" when concurrency gets involved in the program
09:25:53 <kmc> i think concurrency is inherently non-functional.  perhaps you should use more pure parallelism and less concurrency?
09:26:19 <djahandarie> kmc, well the problem is a concurrent one
09:26:30 <kmc> concurrent programs have the semantics of nondeterministically scheduled sequences of actions
09:26:42 <kmc> if that's an observable fact then your code isn't functional
09:26:52 <copumpkin> djahandarie: does it involve dining sorcerors?
09:27:06 <copumpkin> sorcerer,  I mean 
09:27:09 <Phyx-> why does Ghc-pkg lists hiddenModules? you can't use them can you? nor expose them right?
09:27:16 <djahandarie> I thought it was philosophers?
09:27:21 <kmc> djahandarie, maybe you can code it as a collection of interacting agents, each one implemented by a pure function
09:27:24 <copumpkin> djahandarie: I did too, but harry potter set me straight
09:27:26 <copumpkin> americans don't have philosophers
09:27:35 <djahandarie> copumpkin, hahaha
09:27:48 <kmc> haha
09:27:54 <jcreigh> copumpkin: funny and sad...
09:28:10 * fryguybob watched a movie with a philosopher last night...
09:28:52 <Phyx-> hello?
09:29:00 <kmc> @bot
09:29:04 <djahandarie> Maybe the solution is FRP
09:29:05 <lambdabot> :)
09:29:14 <djahandarie> But it's probably not
09:29:52 <co_dh> > 1 + 1
09:29:59 <lambdabot>   2
09:30:21 <co_dh> > sum [a , b , c , d]
09:30:29 <lambdabot>   Ambiguous occurrence `b'
09:30:35 <lambdabot>  It could refer to either `L.b', defined at <local...
09:30:38 <co_dh> > sum [ c,d,e,f]
09:30:45 <lambdabot>   0 + c + d + e + f
09:31:23 <medfly> @undef b
09:36:02 <lispy> > product [a,b,c,d]
09:36:03 <lambdabot>   1 * a * b * c * d
09:36:03 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
09:36:16 <Phyx-> botty is back!
09:36:18 <Phyx-> wweee
09:36:40 <lispy> :t join product sum
09:36:41 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) [m a]
09:36:41 <lambdabot>     Probable cause: `product' is applied to too few arguments
09:36:41 <lambdabot>     In the first argument of `join', namely `product'
09:36:44 <lispy> :t join
09:36:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:40:16 <co_dh> I might be wrong : what's the point of define a join function , which means different thing for each Monad? 
09:40:31 <Zao> co_dh: So that each Monad does what it should.
09:40:46 <roconnor> co_dh: it has laws that relates it to the other monad operations.
09:41:10 <co_dh> join [[]] is concat, join IO (IO x ) ==> IO x, join f x = f x x . 
09:41:21 <kmc> co_dh, the reason we have this abstraction named "Monad" in the first place is so that we can use the same syntax ("do") and operators (Control.Monad etc.) for a bunch of different but structurally-similar things
09:41:26 <co_dh> I mean , it looks less readable for me. 
09:41:50 <kmc> "join IO (IO x ) ==> IO x" makes no sense
09:41:56 <kmc> join :: IO (IO x) -> IO x
09:42:03 <kmc> but as an actual equation of what the function does
09:42:07 <kmc> you can't write it
09:42:08 <roconnor> co_dh: ya, I would normally use a more specific operation if, say I'm going to work on lists; however ...
09:42:18 <Cale_> co_dh: Because it's useful in all those cases, and we only have to define it once.
09:42:26 <kmc> because the implementation of the IO type is hidden and implementation-dependent.  it's unlike other monads in this respect
09:42:29 <kmc> IO is actually a very atypical monad
09:42:34 <roconnor> co_dh: It is sometimes the case that when you write things more generically you end up with a generic function out at the top, which means ...
09:43:06 <roconnor> a) the polymorphism means there is more provable constraints on your function (e.g. free theorems)
09:43:16 <co_dh> I think it's just too abstract :)
09:43:19 <roconnor> b) you might be able to generalize your code in ways that you didn't initally imagine
09:43:40 <co_dh> thanks , everybody :)
09:43:55 <Cale_> As programmers, we should all love good abstractions, because they mean we don't have to write as much code.
09:44:02 <roconnor> co_dh: but there is little advantage to using the generic functions if your types force them to be specialized anywas.
09:44:32 <Cale_> Now that Control.Monad is written, you'll never have to write 'sequence' or 'mapM' for any library that you recognise as a monad.
09:44:38 <roconnor> co_dh: feel free to stick to using concat.
09:44:49 <Cale_> (You implement >>= and return, and get all that stuff for free)
09:45:01 <Cale_> > sequence [[1,2,3],[4,5],[6,7,8]]
09:45:02 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
09:45:14 <Cale_> and they often do interestingly nontrivial things
09:45:22 <co_dh> > sequence [[1,2],[3,4]]
09:45:23 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
09:45:42 <Cale_> (Well, they're always the same thing in one sense)
09:45:47 <roconnor> > sequence [(+2), (*2)] 4
09:45:48 <lambdabot>   [6,8]
09:46:05 <Cale_> > sequence [id, reverse, map toUpper] "hello"
09:46:06 <lambdabot>   ["hello","olleh","HELLO"]
09:46:24 <co_dh> :t sequence
09:46:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:47:53 <co_dh> :t sequence [id , reverse]
09:47:54 <lambdabot> forall a. [a] -> [[a]]
09:50:52 <zygoloid> > sequence [Node 0 [Node 1 [], Node 2 []], Node 3 [], Node 4 [Node 5 [Node 6 []]]]
09:50:52 <lambdabot>   Node {rootLabel = [0,3,4], subForest = [Node {rootLabel = [0,3,5], subFores...
09:50:53 <co_dh> I like this principle of software : there is only one way to do things. 
09:50:58 <Cale_> co_dh: If that's confusing, note that for any type e, the type constructor (->) e is a monad
09:51:11 <Cale_> Where (->) e a is the same as e -> a
09:51:29 <Cale_> The function monad does implicit parameter passing:
09:51:46 <Cale_> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
09:51:47 <lambdabot>   ("hello","olleh","HELLO")
09:51:52 <co_dh> I know about (->) e , thanks. I'm dh__ , 
09:52:11 <co_dh> and I borrowed the co_ from copumpkin :)
09:52:12 <kmc> hehe
09:52:27 <EvanR-wo1k> co_dh: thats a weird principle consider there isnt one way to do anything
09:53:06 <EvanR-wo1k> i think that principle appeared as a result of people using dynamic languages where a 'way' to do something involved a lot of invisible 'you just have to know' side effects
09:53:08 <Cale_> It's pretty hard in general to enforce that constraint in a Turing complete language ;)
09:53:10 <co_dh> one way to do thing is the philosophy of python, and it helps to reduce learning curve.  
09:53:14 <EvanR-wo1k> that is its not written in the code what its doing
09:53:26 <kmc> i think it appeared in opposition to Perl basically
09:53:28 <co_dh> perl has many way to do the same things, and it's hard to learn. 
09:53:40 <EvanR-wo1k> in haskell everything is explicit, even in monadic code you see its Reader r a
09:53:46 <Cale_> No matter how hard you try to make it such that there's only one way to do things, there will be many.
09:53:50 <EvanR-wo1k> so there doesnt need to be one way to do stuff
09:54:20 <EvanR-wo1k> there is definitely not one way to do things in python
09:54:47 <co_dh> I agree it's not one way in python, but in python , they try to do it in one way. 
09:55:14 <EvanR-wo1k> i still think its about defining a 'way' as short code -> large complex side effects
09:55:18 <co_dh> in haskell, we have Monad, Application, Arrow, list comprehension, they all similar, and has overlap in functionality. 
09:55:21 <EvanR-wo1k> which is what perl does  alot of
09:55:44 <EvanR-wo1k> yes but you can see that its using those classes so you can read about it
09:55:51 <EvanR-wo1k> random perl code cant be deciphered
09:56:12 <sproingie> python talks a lot about there being one way to do it but that hasnt really been the case for a long time
09:56:27 <EvanR-wo1k> in dynamic languages 'hidden code' is good code, requiring a lot of extra documentation which doesnt get written
09:56:50 <co_dh> what hidden code are you talking about? 
09:57:02 <Cale_> I think what's more important than there being one way to do things is that it's as easy as possible to correctly translate between different ways, and check that your transformation is correct.
09:57:09 <EvanR-wo1k> having one way to do stuff limits the amount of ephemeral knowledge of the hidden workings of commands
09:57:27 <vpetro> sproingie: i think there are many ways of doing things in python, but there is only one, pythonic, way that it should be written
09:57:29 <Cale_> (Algebraically, in the ideal case)
09:57:32 <EvanR-wo1k> if there are not hidden workings, you dont need to limit the ways
09:57:48 <sproingie> vpetro: i don't think that's even holding up very well these days
09:57:54 <EvanR-wo1k> vpetro: is that a language feature or just a convention?
09:58:08 <vpetro> EvanR-wo1k: convention
09:58:11 <EvanR-wo1k> if convention then shouldnt really be called pythonic
09:58:16 <EvanR-wo1k> since it can be applied to anything
09:58:24 <sproingie> there are certainly common practices that the community at large picks up.  the same goes for perl.
09:58:40 <kmc> yeah
09:58:46 <kmc> every time i start ranting about how perl is obsolete
09:58:59 <kmc> people tell me "no if you just use all these specific CPAN modules it's like a modern programming language"
09:59:02 <sproingie> haskell's community seems to be fond of finding new ways to abstract so things tend to be a moving target sometimes
09:59:17 <EvanR-wo1k> if its easy to tell from *reading* the code what a 'practice' means, then no need to have conventions based only one number of ways
09:59:38 <EvanR-wo1k> better to concentrate on conventions for readability, semantic clarity...
09:59:43 <EvanR-wo1k> performance
09:59:46 <sproingie> kmc: meh.  there's things cpan won't fix, like the notion of scalars
10:00:17 <sproingie> much as i appreciate perl's flexibility i'm loath to start projects in it
10:00:26 <kmc> yeah
10:00:33 <kmc> most dynamic languages are equivalently flexible aren't they?
10:00:51 <Cale_> The central theme of functional programming in my mind is that instead of solving problems directly, we factor the process of designing solutions to problems through the process of designing programming languages.
10:00:53 <sproingie> not really.  doing anything like a generator in perl is pretty painful
10:01:27 <Cale_> In general, there will be a lot of ways to design a language which will make it better at certain things than others.
10:01:37 <sproingie> i've read Higher Order Perl, and the syntax for some things is just ... hairy
10:01:42 <djahandarie> What's PHP good at? Sucking?
10:01:57 <Cale_> djahandarie: Fooling beginners into thinking that it is easy to use.
10:01:59 <sproingie> PHP got the 1-sigil-namespace thing right.  i'm trying to think of something else nice to say
10:02:00 <ezyang> it's good at making webpages really really fast. 
10:02:02 <mwc> Is there a support group for people struggling with enumerators?
10:02:02 <sproingie> drawing a blank
10:02:02 <medfly> djahandarie, easy to make websites in it.
10:02:10 <ezyang> mwc: Just ask away. 
10:02:29 <medfly> djahandarie, I personally think it's better than Haskell, which takes too much work and takes over the entire website making process.
10:02:32 <medfly> (at it)
10:02:38 <aRcatan> PHP is good at being available on every cheap web hosting plan
10:02:42 <mwc> I don't quite get the the plumbing of enumerators to enumeratees to iteratees. My mental models is on a unix pipeline, is that a mistake?
10:02:44 <hiredman> php got gotos so you can write a code generator for it nicely
10:02:48 <medfly> djahandarie, there is really no need for that much effort just for a small thing.
10:02:56 <aRcatan> which can be very important thing in smoe situations
10:02:56 <EvanR-wo1k> ezyang: php, webpages, fast???
10:03:11 <EvanR-wo1k> oh, *making* then fast
10:03:18 <EvanR-wo1k> not making them *fast* ;)
10:03:19 <ezyang> EvanR: Yah 
10:03:30 <ezyang> Though, as far as interpreted languages go, PHP is pretty lightweight. 
10:03:41 <sproingie> i wouldnt say that
10:03:45 <sproingie> lua is lightweight
10:03:47 <djahandarie> I don't think PHP makes writing websites fast
10:03:52 <EvanR-wo1k> its one of the slowest dynamic languages
10:04:06 <EvanR-wo1k> and its server implementation is so inefficient in terms of database resources
10:04:07 <sproingie> php had exactly the right deployment model at exactly the right time
10:04:11 <aRcatan> PHP needs very little work to get simple things done
10:04:13 <djahandarie> I take forever to write things in PHP because stuff breaks all the time
10:04:15 <sproingie> the rest is network effects
10:04:28 <EvanR-wo1k> worse is better
10:04:38 <aRcatan> I think PHP is just fine for beginner programmers interested in making web sites
10:04:40 <sproingie> "better" is rarely actually better
10:04:40 <mwc> So is treating iteratees as a unix pipeline the wrong thing to do?
10:04:47 <ezyang> mwc: The vertical composition resembles a pipeline, yes. 
10:04:54 <co_dh> let's focus on Haskell , I love it, but the learning curve is too high , you know , after Category theory, Monad, Applicative, Arrow, I still have enumerator, enumeratee and iteratees, ... oh no.
10:04:55 <sproingie> i should learn iteratees sometime
10:05:01 <mwc> I ask because when I try to compose them sequentially, I keep finding the need to insert joinI inexpectedly
10:05:18 <sproingie> haskell does tend to be a moving target
10:05:21 <Cale_> co_dh: You only need to learn those things as you come to them.
10:05:24 <sproingie> iteratees are a pretty new thing
10:05:25 <ezyang> mwc: The usual monadic composition is a little different from pipelines. 
10:05:32 <ezyang> mwc: It's more like parser combinators, if you're familiar with those. 
10:05:36 <sproingie> Arrow is nice to know but i don't know of much code that uses them in anger
10:05:38 <sproingie> other than Yampa
10:05:41 <Cale_> co_dh: I would say learning category theory is unnecessary, though it's certainly nice to have.
10:05:47 <mwc> Yes, that's what I'm trying to get. I can see how iteratees compose monadically
10:06:00 <mwc> the "horizontal" composition
10:06:08 <mwc> but the vertical composition is a little daunting
10:06:08 <ezyang> mwc: Ah, sure. 
10:06:09 <medfly> djahandarie, most of the time in webdev you need super simple things.
10:06:16 <EvanR-wo1k> php's memory management system is utterly fail
10:06:19 <medfly> djahandarie, in those scenarios haskell has no advantage over PHP.
10:06:19 <co_dh> but I really like Arrow, it's unix's pipe!
10:06:21 <ezyang> Vertical composition is the pipeline. 
10:06:32 <medfly> is Haskell better at memory management? COME ON.
10:06:38 <ezyang> You can convert a stream of bytes into a stream of integers into a stream of tokens etc 
10:06:42 <EvanR-wo1k> i havent run into a memory leak in haskell yet
10:06:46 <mwc> for instance, I wanted to do enumerator $$ enumeratee $$ iteratee
10:06:55 <EvanR-wo1k> php, if it runs for more than 25ms, is an automatic memory leak
10:06:58 <mwc> but I had to do enumerator $$ joinI (enumeratee $$ iteratee)
10:06:58 <djahandarie> medfly, when making a web application it's usually never simple
10:07:02 <Cale_> medfly: Than PHP? PHP sucks at memory management too.
10:07:14 <sproingie> goes back to php's deployment model.  you can limit memory and run time and despite that this *can* be done on just about any other web platform, hardly any have ever bothered to actually *do* it
10:07:26 <medfly> djahandarie, I didn't say web application.
10:07:34 <EvanR-wo1k> i limit memory, but then nothing will run
10:07:35 <medfly> djahandarie, I meant websites. Haskell is totally unnecessary for that.
10:07:45 <EvanR-wo1k> because i run out of memory
10:07:53 <medfly> djahandarie, not to mention it strips you away from all your HTML knowledge. it's like you have to learn again just to make the exact same thing. CLEVER.
10:08:00 <sproingie> i would argue that any website using something like taint is crying out for a stronger type system
10:08:03 <Cale_> medfly: Every website with more than a couple pages is really a web application.
10:08:14 <mwc> medfly: sure, but everything but assembly is totally unnecessary for any task you can do on a computer ;)
10:08:23 <sproingie> taint itself seems to have gone by the wayside, but nearly every web framework reinvents it as a CSRF prevention device every other year
10:09:14 <EvanR-wo1k> php requires a framework to seriously make a website, even a static one with repeated elements. so does haskell. so which is better?
10:09:22 <Cale_> medfly: Also, I should show you hamlet or one of the other quasiquoting HTML things sometime. You can write HTML in a simpler or more familiar syntax :) (It's just that the XHtml lib we were using didn't take that route)
10:09:27 <sproingie> haskell web frameworks are in their infancy
10:09:38 <aristid> sproingie: ironically it seems like most existing haskell frameworks don't use tainting in types
10:09:56 <nus> php is by-product of web publishing industry
10:10:05 <nus> nobody really cares what's inside
10:10:21 <nus> as long as there's infrastructure to deliver
10:10:22 <sproingie> i would rather write real html with a real templating system like wicket or facelets uses
10:10:24 <co_dh> can I get a Haskell job in 5 years?
10:10:31 <sproingie> last thing i want is an alternative to html that i can't preview
10:10:35 <medfly> mwc, it's just an unnecessary abstraction layer.
10:10:44 <ezyang> mwc: What code are you working off of? 
10:10:46 <kmc> co_dh, can, yes.  a number of us (myself included) have jobs programming in Haskell
10:10:52 <kmc> and i have less than 5 years Haskell experience
10:10:58 <mwc> ezyang: enumerator-0.4
10:10:58 <aristid> co_dh: my crystall ball is broken, but maybe somebody else can predict the future better ;)
10:11:04 <kmc> co_dh, but i wouldn't count on it.  you'll have to work hard for it
10:11:14 <ezyang> Ok. I haven't looked closely enough at that version of the code yet. 
10:11:19 <EvanR-wo1k> get hired anywhere and convinced them to use haskell for something
10:11:19 <sproingie> a zen student once asked his master, "master, how long will it take me to achieve enlightenment?"
10:11:23 <EvanR-wo1k> then you have a haskell job
10:11:24 <co_dh> kmc: cool, where are you ? if you don't mind
10:11:29 <sproingie> the master said "it's hard to say.  perhaps ten years"
10:11:35 <kmc> ipwnstudios.com
10:11:45 <sproingie> the student then asked "but if i study hard and apply myself day and night, how long then?"
10:11:46 <co_dh> oh, same as Cale, 
10:11:50 <sproingie> the master replied "twenty years"
10:11:54 <kmc> granted it has been mostly C and shell script so far -- I'm modifying GHC to target Android
10:12:14 <medfly> kmc, how is it a Haskell job then?
10:12:26 <Twey> Because he's modifying GHC to target Android
10:12:26 <medfly> kmc, I just need to put in 10 minutes of Haskell coding every day to make you happy?
10:12:29 <co_dh> correct me if I'm wrong, is Android a java platform?
10:12:36 <Twey> Java-based
10:12:38 <kmc> co_dh, you can load native code too
10:12:47 <sproingie> co_dh: it uses the java language to write apps.  the VM is dalvik.
10:12:54 <mwc> co_dh: that's the subject of a lawsuit between Oracle and Google ;)
10:12:59 <EvanR-wo1k> sproingie: and whats the point of that zen anecdote?
10:13:03 <sproingie> and you can do native code but it requires a rooted phone
10:13:06 <kmc> nope
10:13:07 <kmc> it does not
10:13:16 <sproingie> EvanR-wo1k: meditate on it some :)
10:13:19 <EvanR-wo1k> gah
10:13:21 <EvanR-wo1k> >_<
10:13:23 <kmc> http://developer.android.com/sdk/ndk/index.html
10:13:26 <co_dh> ok, then, but you write Haskell to generated binary to be called from java?
10:13:31 <kmc> yes
10:13:42 <Twey> It doesn't have to use JavaLang.  The fact that it's â€˜Java-basedâ€™ is to do with the fact that Dalvik is basically a JVM, albeit a modified one.
10:14:03 <Twey> You can write in other languages that compile to Java bytecode
10:14:10 <sproingie> i have my doubts my g1 will run haskell apps acceptably
10:14:18 <sproingie> teeny tiny memory space
10:14:19 <kmc> or you can produce native code
10:14:30 <co_dh> I don't have access to android.com , damn it.
10:14:32 <kmc> the main obstacle there is that most of the platform APIs are Java-only
10:15:00 <kmc> you'd need to write (or generate) JNI and FFI wrappers for those
10:15:00 <co_dh> can you call java api from haskell?
10:15:05 * lispy plans to avoid Java like the plague now that Oracle is suing people for using it
10:15:22 <djahandarie> LOL Oracle is suing people for using Java?
10:15:23 <kmc> co_dh, through C, yess
10:15:28 <aristid> lispy: you didn't avoid it like the plague before?
10:15:33 <EvanR-wo1k> oracle threatened to sue google
10:15:34 <mwc> djahandarie: that depends if you ask Oracle or Google
10:15:35 <kmc> co_dh, not sure any of the projects to make it nicer / more direct are usable
10:15:35 <ezyang> kmc: Aw, you didn't hack GHC to support the JAva calling convention :-) 
10:15:37 <sproingie> co_dh: through some torturous chain of JNI and FFI, it's technically possible.  there's no built-in support for it
10:15:38 <lispy> djahandarie: they are suing google for the android stuff
10:15:43 <kmc> ezyang, might still do
10:15:56 <sproingie> dunno if android even does jni or if it does its own thing
10:15:59 <lispy> kmc: lambavm?
10:16:00 <kmc> it does JNI
10:16:12 <lispy> kmc: it already exists, BTW.  and there is the jvm-bridge package too
10:16:13 <EvanR-wo1k> without a settlement (or real court), oracle wants google to eliminate all copies of their java platform
10:16:21 <EvanR-wo1k> which is lol
10:16:26 <kmc> i don't want to compile Haskell to JVM
10:16:33 <sproingie> i suspect sun filed a motion to that effect
10:16:34 <kmc> i want to compile Haskell to native code and have it call JVM code
10:16:39 <sproingie> "Plaintiff's motion is lol"
10:16:42 <lispy> kmc: jvm-bridge uses FFI
10:16:49 <kmc> where do i find it?
10:16:50 <sproingie> s/sun/google/
10:16:54 <nus> it's not about Java per se. It's a patent suite case with much more general claims.
10:17:03 <lispy> ?google jvm-bridge
10:17:04 <lambdabot> http://sourceforge.net/projects/jvm-bridge/
10:17:04 <lambdabot> Title: Java VM Bridge for Functional Languages | Download Java VM Bridge for Functional ...
10:17:05 <kmc> not on hackage :/
10:17:13 <EvanR-wo1k> one count of copywrite infringement
10:17:26 <sproingie> (copy on write infringement?)
10:17:27 <lispy> kmc: oh, the version on sf.net is hold, get it here: http://semantic.org/jvm-bridge/
10:17:32 <EvanR-wo1k> lol
10:17:48 <lispy> kmc: it is cabalized, but the project is starting to bit rot
10:17:56 <EvanR-wo1k> if google copied non free code, that was monumentally stupid
10:18:00 <EvanR-wo1k> but patents are a joke
10:18:18 <sproingie> google didn't write dalvik
10:18:19 <Cale_> Actually, hmm -- hamlet is not bad, but has anyone actually written a QQ for (X)HTML syntax directly?
10:18:46 <co_dh> I hope google lost the oracle lawcase, so there will be no java job in google, so guess what ? they will switch to Python , lol
10:18:48 <lispy> kmc: a friend got it working, but I doubt he was able to merge his (mostly trivial) patches.  I think Ashley Yakeley was unreachable when he tried
10:18:52 <Cale_> I could have sworn that was one of the first things someone did with the quasiquoter extension, but I can't seem to find one now.
10:19:31 <sproingie> no one is switching to anything.  oracle's silly motion will be slapped down, and they'll probably settle
10:19:48 <EvanR-wo1k> how is that 'slapped down'
10:19:54 <EvanR-wo1k> thats surrendering
10:20:06 <sproingie> the "destroy all phones" motion.  google will probably offer a settlement.
10:20:21 <sproingie> google is not oracle's competition
10:20:26 <EvanR-wo1k> isnt it a bit like robbery?
10:20:46 <sproingie> yes it is.  i still predict a settlement.
10:20:59 <EvanR-wo1k> yes i didnt mean to contradict that 
10:21:16 <Cale_> Someone should steal the Haddock stylesheets that the Snap guys did and make it the default theme.
10:21:20 <p_l> co_dh: ... yeah, let's bring even more fail
10:21:35 <aristid> EvanR-wo1k: ironically sun started patenting every kind of shit after IBM did a similar robbery on them
10:21:38 <p_l> (not because Python is bad language, but because of CPython's implementation)
10:21:53 <p_l> aristid: ironically, Sun never planned to use those patents other than in self-defence...
10:22:00 <ezyang> "you ain't got soul if you ain't got static typing" 
10:22:01 <aristid> p_l: well...
10:22:10 <p_l> Oracle has no scrupules... :P
10:22:26 <sproingie> p_l: schwartz purportedly suggested the suit to oracle
10:22:48 <kmc> if Google actually has to switch to Python they will put more work into their non-shitty Python implementation
10:22:50 <p_l> sproingie: interesting
10:22:52 <kmc> and it will be a net win for the world
10:23:11 <p_l> kmc: yeah, and we will get then *only* Python, while at least for now, I've got some leeway
10:23:13 <co_dh> I hope google switch to Haskell :)
10:23:19 <sproingie> an llvm-powered mobile runtime would be lots of awesome
10:23:23 <Adamant> unlikely
10:23:29 <p_l> sproingie: that I agree with :D
10:23:31 <co_dh> my 1 year of python's experience is : static type check in Haskell is good !
10:23:35 <Adamant> given their attitude to Smalltalk and Lisp
10:23:43 <p_l> Adamant: rather to C++ and Java
10:23:44 <kmc> co_dh, people use Haskell at Google.  one or two people will produce a fully working "prototype" in Haskell, and then they'll have an army of C++ programmers rewrite it
10:24:18 <sz1> why?
10:24:21 <p_l> though I heard one group greenspunned their own language onto JVM to avoid "allowed languages list"
10:24:22 <ezyang> kmc: Do they actually do that? 
10:24:24 <co_dh> "prototype"
10:24:28 <kmc> ezyang, 's the rumour i heard
10:24:29 <p_l> ezyang: some people might
10:24:33 <sproingie> unladen is based on llvm.  using llvm would give haskell a very nice in as well
10:24:37 <absentia> Objective-C++
10:24:40 * absentia scores.
10:24:44 <kmc> god no
10:24:46 <p_l> actuall software has to be written in approved language
10:24:55 <p_l> absentia: ... why did you decide to fuckup a nice lang?
10:24:57 <Adamant> kmc: unsurprised, that seems to happen in a lot of places in the Valley. they won't "ship" with it, but they'll use it for prototyping
10:25:00 <p_l> (Objective-C)
10:25:02 <kmc> because if only C++ had even more not-quite-orthogonal stuff bolted on
10:25:36 <Adamant> where "it" is language that's not seen as commercially vialbe
10:25:45 <absentia> :-)  not me... apple.  I like C++....  (call me sick, I know).  I like Objective-C.  I'd only do Objective-C++ if I had legacy code in C++.  Personally, I find writing ObjC so damn easy. 
10:25:52 <kmc> it's not commercially viable because nobody ships with it
10:25:56 <kmc> ;)
10:25:57 <Adamant> but is quite powerful
10:26:04 <Adamant> kmc: truth!
10:26:11 <sproingie> i like some subset of C++
10:26:25 <Adamant> I like the subset called C
10:26:27 <sproingie> i really like D.  shame the runtime is such a trainwreck.
10:26:33 <illissius> i wonder how clang will handle C++ with both apple's 'blocks' closures and C++1x closures...
10:26:47 <kmc> "ship" is an irrelevant term for webapps.  use whatever you want on your server, nobody needs to know
10:26:52 <Adamant> can't they unite them?
10:27:00 <illissius> Adamant: i don't know :)
10:27:01 <kmc> most webapps use a number of different languages
10:27:05 <mwc> Has apple contributed the blocks code to clang? I thought it was only implementing in GCC
10:27:06 <illissius> the syntax is definitely different
10:27:13 <illissius> i strongly suspect the semantics are too
10:27:14 <Adamant> kmc: I used quotes because it's usually internal stuff
10:27:18 <FunctorSalad> like real closures?
10:27:19 <mwc> *in their in-house version of GCC
10:27:28 <absentia> In ObjC, you can do pure C.  It's directly compatible with the C libs... verynice.  If you want to do dynamic stuff, instead of [re]inventing it yourself... you can use the ObjC parts.  you get both static and dynamic.  it's quite nice.
10:27:33 <Adamant> and webapps, hence "ship"
10:27:36 <illissius> mwc: oh? my impression was that they added it to clang and they use that
10:27:38 <illissius> but i could be wrong
10:27:43 <absentia> LLVM is awesome... C blocks are interesting.
10:27:50 <sproingie> i dont think clang is where new features to the language are going
10:28:04 <sproingie> clang has enough on its plate implementing the existing language
10:28:39 <kmc> after decades of "functional programming is useless in the real world", the solution for concurrency is to kludge functional programming onto every language
10:28:40 <illissius> sproingie: i believe they've mostly accomplished that by now
10:28:54 <Adamant> kmc: hee hee
10:29:45 <sproingie> i would say it's more that imperative languages are stealing useful bits from functional
10:29:47 <Adamant> although when we get to thousands of processors, STM and such may crap out
10:29:56 <kmc> yeah
10:30:03 <kmc> i don't think Apple are particularly pushing STM are they?
10:30:08 <Adamant> no
10:30:16 <Adamant> they're pushing Grand Center
10:30:21 <Adamant> *Central
10:30:51 <wli> Systems with thousands of processors are already out there.
10:30:56 <Adamant> which I'm not aware of using STM, but might (no personal experience)
10:31:11 <illissius> Adamant: i don't believe it does
10:31:13 <Adamant> wli: doing STM? if so, awesome
10:31:27 <wli> Not doing STM that I know of.
10:31:30 <Adamant> ah.
10:31:47 <Adamant> yeah, the usual Linux supercomputers
10:31:59 <wli> You mean IRIX.
10:32:14 <wli> Linux is out there too, I suppose.
10:32:28 <Adamant> wli: I thought Linux could do like 4096 processors or so with patches
10:32:30 <illissius> it's analogous to using Chans in haskell to send IO actions to other threads where they get queued and executed (with somewhat more logic than that for ordering and prioritizing and whatever)
10:32:55 <Adamant> probably more than that now
10:33:29 <Adamant> you're the kernel hacker so I'd defer to you on that one
10:33:35 <wli> Adamant: I wrote the patch that got the support into mainline Linux, and there's no set limit, not 4096 or anything. Anyhow, 2.6.x needs no patches.
10:33:42 <Adamant> ah
10:33:50 <Adamant> cool!
10:34:18 <Ke> Adamant: linux can do 4096 without patches, but most supercomputers are probably several nodes of 2.6.9-variants 
10:34:49 <Ke> and ipc is done with infiniband
10:35:31 <Ke> (2.6.9 is just a guess based on some funny statistic I can't remember)
10:36:24 <nlogax> @seen mtnviewmark
10:36:24 <preflex>  mtnviewmark was last seen on #haskell 1 hour, 24 minutes and 53 seconds ago, saying: kmc / zygoloid: exactly! 
10:36:24 <lambdabot> Unknown command, try @list
10:37:09 <Ke> wli: heh, are there actually monolithic computers with more than 4096 cpus?
10:37:23 <sproingie> they take several cabinets
10:37:31 <sproingie> not sure you call them "monolithic" at that point
10:37:32 <Adamant> or several rooms
10:37:38 <Adamant> :P
10:38:12 <Ke> I thought such clusters are actually comprised of several independent computers
10:38:22 <sproingie> they're a modular design
10:38:25 <sproingie> but logically it's one computer
10:38:32 <Ke> with each running operating system of it's own
10:38:39 <sproingie> not a cluster, no
10:40:26 * wli was referring to SSI, not compute clusters.
10:40:28 <dv-> is there a EpochTime -> Day function?
10:40:53 <notabel> on something like the IBM Blue Gene series, each compute core runs its own single-process kernel. each logical partition has a head node which runs a larger kernel, providing single system image
10:42:00 <notabel> but since each node only runs a single process, the process heirarchy reflects the number of nodes in the partition
10:43:17 * wli was not under the impression Blue Gene was SSI.
10:44:09 <sproingie> each LPAR is.  dunno how big an LPAR is allowed to get.
10:44:34 <Wolfspaw> about Mark last post: http://blog.plover.com/ , concerning Mote x Mobit : I prefer Mobit , because i like more the sound of it and because Mote is already used in Sensor Wireless Networks ;~~~~
10:44:43 <Wolfspaw> I couldn't find a place to comment in his post ; - ;
10:45:58 <zygoloid> Wolfspaw: i'm generally of the opinion that mjd gets to choose the name since it was his idea
10:46:17 <p_l> actually, BlueGene isn't an SSI, but a shared I/O system, afaik
10:46:19 <Wolfspaw> zygoloid: yeah, you're right xD
10:46:55 <p_l> the "fat" nodes are I/O nodes, the compute kernels only have drivers for the networks
10:47:19 <zygoloid> i don't like mobit because it seems like a contraction of monadic bit, which feels wrong
10:47:49 <zygoloid> plus it's either pronounced mow-bit, which doesn't match how i pronounce monad, or pronounced mob-bit, which feels awkward to say :)
10:47:55 <Wolfspaw> zygoloid: hm, it's a good point
10:48:07 <zygoloid> ^^ this sort of discussion is exactly why i don't think ti should be discussed ;-)
10:48:30 <Wolfspaw> lol xD
10:49:04 <zygoloid> fwiw /me will be trying out "mote" to see how it's received
10:49:44 <sproingie> mote.godseye.org
10:53:59 <aRcatan> return () :: Wii ()
11:01:46 <FunctorSalad> does Malcolm Wallace frequent this channel?
11:02:24 <mauke> preflex: ? who:MalcolmWallace
11:02:24 <preflex>  malcolmw
11:02:32 <mauke> preflex: seen malcolmw
11:02:32 <preflex>  malcolmw was last seen on #ghc 30 days, 20 hours, 23 minutes and 8 seconds ago, saying: full sigs would be my preference
11:02:33 <Jagdwurst> wow,  gromit & wallace
11:02:56 <FunctorSalad> mauke: thx
11:03:27 <FunctorSalad> (was just wondering whether my 256 colour-mode for HsColour was rejected or just landed in the spamfilter;))
11:03:50 <FunctorSalad> it's backwards-compatible and only takes effect with a special configfile, so I can't imagine why not
11:04:57 <ezyang> Suppose I have some value x :: Num a => a. I'd like to use x as an Int as well as an Integer. How do I do this, without making x monomorphic and using a conversion function? 
11:05:10 <yrlnry> Jagdwurst:  My three-year-old was delighted to discover that we lived near Wallace Street, and wanted to know if there was also a Gromit Street.  Sadly, there is not.
11:05:21 <ezyang> (essentially, I want to be able to say, "use this dictionary for this use of x, and this other dictionary for this alternate use of x") 
11:05:58 <Jagdwurst> yrlnry: xD
11:06:02 <Cale> ezyang: Just use x twice?
11:06:14 <ezyang> Cale: Hm, maybe I'm misinterpreting my type error then 
11:06:26 <Cale> ezyang: and make sure that the monomorphism restriction isn't applying to your binding and messing things up
11:06:39 <kmc> ezyang, is x a function argument?
11:06:43 <Cale> ezyang: You can give x an explicit type signature, and it might help.
11:06:46 <kmc> if so, that function needs to have a rank-2 type
11:06:55 <ezyang> I have monomorphism restriction turned off. 
11:06:58 <kmc> (âˆ€ a. Num a â‡’ a) â†’ r
11:07:18 <ezyang> kmc: When I tried that, I got "A pattern type signature cannot bind scoped type variables `g'       unless the pattern has a rigid type context" 
11:07:26 <kmc> ezyang, hpaste?
11:07:35 <mauke> (âˆ€Î±. Num Î± â‡’ Î±) â†’ Ï
11:07:40 <kmc> ;P
11:08:00 <ezyang> sure, just a sec. 
11:08:56 <FunctorSalad> *has idea to pull out some ornamental character range to write the Num* *can't be bothered*
11:09:15 <kmc> (âˆ€Î±. â˜­ Î± â‡’ Î±) â†’ Ï
11:09:17 <ezyang> Oh, I guess I really do want rank-w types 
11:09:20 <FunctorSalad> haha
11:09:25 <ezyang> erm, 2 
11:09:28 <kmc> rank-Ï‰? :O
11:09:38 * kmc would like to see a rank-Ï‰ type
11:09:42 <FunctorSalad> kmc: I don't get the pun if any
11:09:44 <mauke> rank Ï‰Ìˆ
11:10:01 <kmc> Ï‰, the first transfinite ordinal
11:10:05 <FunctorSalad> concerning the hammer + whatever it's called in english
11:10:09 <kmc> it's not a pun
11:10:14 <FunctorSalad> suckle
11:10:16 <kmc> just an ornamental character i know how to type
11:10:18 <FunctorSalad> *sickle
11:10:32 <kmc> "hammer and suckle" would be a good name for a band
11:10:36 <zygoloid> mauke: your ->s and =>s look very similar :/
11:11:02 <Phyx-> @pl fmap catMaybes $ mapM (findInterface dirs) modules
11:11:03 <lambdabot> fmap catMaybes (mapM (findInterface dirs) modules)
11:11:32 <ezyang> O.o 
11:11:36 <ezyang> "No instance for (G.Network ((G.Network g) => g))" 
11:11:46 <yrlnry> kmc:  in the default keyboard bindings on Ubuntu, it is bound to the compose-key sequence "CCCP".
11:11:47 <zygoloid> haha what
11:11:53 <kmc> yup
11:12:13 <mauke> âªâˆ€Î±Â· â˜ƒ Î± â‡’ Î±â« â†’ Ï
11:12:21 <ezyang> Um. WTF. 
11:12:23 <yrlnry> I think it's the only oddity they put in.  There is no default binding for the snowman.
11:12:25 <c_wraith> ezyang, how'd you manage that?
11:12:39 <Martty> whats the windows key do in linux?
11:12:49 <yrlnry> crashes the system.  What else?
11:12:50 <mauke> anything you want
11:12:52 <sproingie> whatever you tell it to
11:12:54 <zygoloid> installs windows and reboots :)
11:12:57 <Martty> doesnt uninstall linux!?
11:13:00 <sproingie> usually it's mapped to meta
11:13:01 <c_wraith> Martty, on many linux platforms, it defaults to opening some menu
11:13:07 <Martty> some start-like menu?
11:13:10 <kmc> yrlnry, Compose < 3
11:13:12 <c_wraith> yes
11:13:17 <Martty> cool
11:13:18 <mauke> did you mean: Compose â™¥
11:13:19 <sproingie> i've never seen a distro that maps the windows key to a menu
11:13:20 <yrlnry> kmc:  right, I forgot about that.
11:13:22 <sproingie> the menu key perhaps
11:13:31 * theorbtwo <3s compose.
11:13:35 <Martty> i should try some linux desktop 
11:13:35 <c_wraith> sproingie: debian, ubuntu
11:13:36 <Martty> os
11:13:40 <theorbtwo> ...but doesn't have one right now.
11:13:42 <sproingie> my menu key is mapped to compose
11:13:52 <kmc> my flag key launches programs
11:13:56 <kmc> because that's how i mapped it
11:14:03 <Martty> flag key
11:14:04 <Martty> hahaha
11:14:05 <ezyang> I can't seem to reproduce in a smaller example... 
11:14:06 <FunctorSalad> ï¼®ï½•ï½
11:14:07 <zygoloid> mine does nothing
11:14:23 <mauke> my flag key is the xmonad command key
11:14:24 <Martty> how do you do without windows+r or windows+d ?
11:14:32 <mauke> what does that do?
11:14:42 <p_l> sproingie: Windows key is "Super", "Windows menu" is "Hyper"
11:14:44 <Martty> open a command prompt and show the desktop
11:14:48 <kmc> how do you Haskell programmers do without Java's "protected" keword?
11:14:59 <mauke> Martty: why would I want to show the desktop?
11:15:01 <yrlnry> My flag+e and flag+a temporarily unstack all the windows at once
11:15:02 <kmc> Martty, you can of course bind those in GNOME or whatever
11:15:07 <mauke> Martty: flag+enter opens a new terminal here
11:15:12 <kmc> i don't have them because my desktop is a featureless black void
11:15:13 <Martty> mauke: to access whatever you have on the desktop!
11:15:13 <c_wraith> I have a quick launcher for terminal, and...  never, ever look at my desktop
11:15:18 <kmc> and if i want to type commands i will open an xterm
11:15:19 <Twey> Haha
11:15:20 <mauke> Martty: you mean my wallpaper?
11:15:23 <sproingie> fedora default has compose on menu.  it also appears to be completely broken.
11:15:24 <Martty> no, the files in there
11:15:30 <mauke> Martty: "in"?
11:15:34 <kmc> which is kind of like a "Run command" box, except it doesn't kill itself after one command
11:15:36 <Twey> Nobody stores files on their desktop
11:15:38 <mauke> it's just a flat surface
11:15:38 <Twey> That's just silly
11:15:40 <kmc> and has the ability to display output
11:15:47 <kmc> Martty, Â«ls ~/DesktopÂ»
11:15:55 <ezyang> Anyway, this doesn't work (though it doesn't give the awesome error message): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29474#a29474 
11:15:57 <Martty> its a folder like any other
11:16:05 <mauke> Martty: what's a folder?
11:16:08 <kmc> ezyang, right, that needs to be rank-2
11:16:12 <Martty> the desktop O_o
11:16:15 <kmc> f :: (forall a. Num a => a) -> IO ()
11:16:18 <ezyang> Ohhhh 
11:16:22 <ezyang> Duh. 
11:16:26 <Twey> Martty: No noâ€¦ what is a â€˜folderâ€™?  :Ã¾
11:16:26 <mauke> Martty: so the desktop is a folder, which is a desktop? RECURSION DETECTED
11:16:30 <Phyx-> people still have wallpapers? I never see mine
11:16:40 <Martty> mauke: aren't we in haskell!?
11:16:41 <Twey> I see mine through my lovely full-screen terminal
11:16:43 <kmc> right, the desktop is a folder like any other.  so why do you need a special key to display it?
11:16:53 <mauke> Martty: right. /me wanders off to #haskell-blah
11:17:00 <ezyang> ok, time to figure out how to get the awesome error... 
11:17:03 <FunctorSalad> > let â“ƒâ“Šâ“‚ = undefined in 1
11:17:04 <lambdabot>   <no location info>: parse error on input `â“ƒâ“Šâ“‚'
11:17:11 <Martty> because the moment you assign a special key it is more easily accessible and thus you use it to store temp files you wanna have at hand!
11:17:12 <FunctorSalad> > let (â“ƒâ“Šâ“‚) = undefined in 1
11:17:13 <lambdabot>   1
11:17:17 <Martty> well thats how i use it at least..
11:17:21 <Phyx-> mauke: make sure you're wearing a belt, they like to steal pants in there
11:17:30 <FunctorSalad> woha what a potential gold rush of operators
11:17:31 <FunctorSalad> ;)
11:17:36 <Martty> mauke: im done anyways :p 
11:17:48 <yrlnry> FunctorSalad:  someone could set up a collection of APL operators.
11:17:50 <FunctorSalad> if anyone knew how to type them
11:18:03 <FunctorSalad> (I copied from kcharselect o_O)
11:18:17 <yrlnry> Unfortunately for APL you really need to be able to use the same operator as both unary prefix  and binary infix, which Haskell won't do.
11:18:24 <FunctorSalad> yrlnry: hmm? they look like this? (I don't know any APL)
11:18:33 <zygoloid> yrlnry: apart from for -
11:18:39 <yrlnry> Right.
11:18:50 <zygoloid> DODGY SPECIAL CASE! AARGH!
11:18:50 <mauke> ezyang: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29474#a29475
11:19:44 <yrlnry> I like that Haskell has some of those dodgy special cases.  It suggests that the designers were intelligent pragmatists rather than wacky zealots.
11:19:58 <kmc> yeah
11:20:04 <kmc> the design is actually full of compromises
11:20:06 <yrlnry> When I was first learning Haskell I found it reassuring.
11:20:21 <FunctorSalad> hehe
11:20:22 <kmc> for example, they compromised by allowing effects
11:20:33 <mauke> I'm a wacky zealot
11:20:38 <ezyang> mauke: Yeah. 
11:20:42 <yrlnry> SML's use of ~ as a negative symbol in numeric literals was offputting.
11:20:53 <mauke> whoa, it actually does that?
11:20:58 <aristid> do you have good estimates how many lines of haskell are functionally equivalent to a certain number of lines of java/...? :)
11:21:05 <ezyang> So now I have to figure out why 'No instance for (G.Network (forall g. (G.Network g) => g))' is happening. 
11:21:14 <FunctorSalad> yrlnry: obviously fromIntegral is much less intrusive
11:21:16 <FunctorSalad> ;)
11:21:28 <aristid> ezyang: because there is no matching instance *very helpful*
11:21:32 <RichardBarrell> mauke: makes sense. Isn't SML like spectacularly monomorphic everywhere?
11:21:32 <kmc> wait, it actually wants an instance of a polytype?
11:21:35 <kmc> that should be impossible
11:21:54 <FunctorSalad> even with ImpredicativeTypez?
11:21:56 <ezyang> But I can't construct a minimal example that causes this. 
11:21:58 <kmc> think so
11:22:24 <kmc> i'm surprised you can even get to the point where it wants that instance
11:22:45 <ezyang> ah, excellent. 
11:22:48 <yrlnry> mauke:  I believe it had a unary minus operator too.  But if you wanted to write the compile-time constant for -3, you had to write ~3.  I don't know why writing -3 wasn't enough to invoke the compiler's constant folder.
11:22:56 <yrlnry> s/had/has/
11:23:12 <edwardk> aristid: depends on the domain. in some domains 1:100, in others it can dip as low as 1:1 ;)
11:23:28 <kmc> Illegal polymorphic or qualified type: forall a. a In the instance declaration for `C (forall a. a)'
11:23:35 <kmc> that's with -XImpredicativeTypes -XFlexibleInstances
11:24:07 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29480#a29480 
11:24:21 <RichardBarrell> aristid: depends on the domain. It can take three lines to type out an anonymous inner class in Java for a callback which in Haskell might fit inside part of one line.
11:24:23 <c_wraith> @hoogle <<
11:24:23 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
11:24:23 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
11:24:23 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
11:24:24 <ezyang> So, my guess is that I need to tweak the signature of that list. 
11:24:26 <edwardk> kmc: have i mentioned that recordwildcards have changed my life ;)
11:24:29 <edwardk> ?
11:24:32 <kmc> haha edwardk
11:24:56 <FunctorSalad> edwardk: I abuse them all the time too
11:25:04 <dolio> edwardk: Did someone tell you that your comonad laws are wrong?
11:25:06 <aristid> FunctorSalad: -ab
11:25:21 <edwardk> dolio: yeah. i knew. someon mentioned it a few months back
11:25:24 <FunctorSalad> aristid: well, I do have a bit of a bad conscience if someone who doesn't know them has to read the code
11:25:25 <dolio> Ah.
11:25:27 <RichardBarrell> aristid: on the other hand, extremely side-effectful code that runs around reading and writing files won't be much shorter in Haskell than it would in, um, well it'd be a *little* bit shorter in Haskell because Java's IO libraries are so unpleasant, but close to 1:1. :P
11:25:32 <ezyang> Sure enough, this compiles http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29480#a29481 (though with a deprecated warning) 
11:25:47 <ezyang> So, uh, does this mean I need to make my own custom list type? 
11:25:50 <FunctorSalad> "why the hell is he defining a foo in this where clause and isn't using it... and why does the program break if I rename foo"
11:25:58 <aristid> RichardBarrell: i'm doing stuff with times and dates. does that help with making the estimate?
11:26:02 <edwardk> dolio: iirc my head branch has the laws fixed up, but i never pushed it out because the big rewritten release was always just over the next hill ;)
11:26:15 <dolio> Heh.
11:26:23 <kmc> ezyang, what are you trying to do?
11:26:37 <RichardBarrell> aristid: I honestly like to assume 1:1 and hope to later find myself pleasantly surprised.
11:26:45 <ezyang> kmc: So, this is a test suite, and I have a bunch of generic values that I want to do tests on. 
11:26:47 <kmc> ezyang, a list of a âˆ€ type is much less common than a list of an âˆƒ type
11:26:53 <aristid> RichardBarrell: well i don't intend to write java code to compare it :D
11:27:05 <edwardk> FunctorSalad: kmc pointed out they are a useful way to define 'new binding forms' and i have to admit, it is an awesome way to bring a ton of names into local scope when you can't follow the typeclass discipline for some reason or other
11:27:07 <aristid> i just want to show off to java programmers
11:27:14 <ezyang> So the real code looks more like: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29480#a29482 
11:27:36 <RichardBarrell> aristid: (disclaimer: most of the shortish programs that I find rattling around my skull live almost entirely in System.IO and System.Process, which aren't even Haskell's strongest points)
11:27:37 <kmc> edwardk: #define YDO getYS >>= \YS{..} -> io $ do
11:27:38 <edwardk> aristid: there you're in 1:1 territory. you won't win much
11:27:42 <FunctorSalad> edwardk: ah. I was thinking of using them for construction ;)
11:27:50 <kmc> from the window manager i started to write
11:27:58 <kmc> which has a Reader YS or whatever
11:27:59 <edwardk> kmc: scary
11:28:00 <ezyang> So, something I could do is specialize on the list, and then zip 'em together 
11:28:01 <kmc> :)
11:28:12 <FunctorSalad> makeRectangle100 width = Rectangle{..} where height = 100
11:28:14 <FunctorSalad> ;)
11:28:19 <aristid> edwardk: nah, 1:1 is implausible :)
11:28:49 <edwardk> aristid: implausible, but actual. it just isn't a domain that benefits a ton from haskell's type system
11:29:05 <FunctorSalad> edwardk: agreed about local scope... it even tempts me to put redundant members into my records ;)
11:29:12 <FunctorSalad> wait... view patterns!
11:29:16 <edwardk> FunctorSalad: yeah
11:29:34 <FunctorSalad> (use a view pattern to make the redundant record?)
11:29:37 <aristid> edwardk: i don't want to believe you :)
11:29:50 <edwardk> FunctorSalad: foo (view -> V {..}) = ... can do all sorts of scary things
11:30:04 <ezyang> Maybe you just want record punning... 
11:30:13 <aristid> but even if the LOC was actually 1:1, i think using haskell for it is a good decision anyways, as developing that way is much more fun
11:30:27 <FunctorSalad> foo (view -> V{..}) = let width=height in V{..} -- lol
11:30:40 <FunctorSalad> (assuming V has width and height)
11:31:07 <FunctorSalad> (ok, you probably don't want to return a V)
11:35:23 <dom96> Why doesn't redirecting the output of ghc --make to a file work ? i.e 'ghc --make someApp.sh >> file.log'
11:35:23 <lambdabot> dom96: You have 1 new message. '/msg lambdabot @messages' to read it.
11:35:36 <kmc> maybe it prints on stderr?
11:35:43 <kmc> ghc --make foo.hs 2>&1 >> foo.log
11:36:13 <mauke> kmc: what
11:36:51 <mauke> ghc --make >>foo.log 2>&1
11:37:03 <dom96> kmc: no. All it prints is Linking ...
11:37:10 <dom96> And that doesn't get put in the file
11:37:54 <dom96> mauke: that works
11:37:57 <dom96> thanks
11:44:53 <kmc> dom96, perhaps you wanted to force recompilation?
11:44:55 <kmc> -fforce-recomp
11:46:04 <dom96> nah, i was just testing an auto updater bash script. But thanks that will still come in handy.
11:50:18 <FunctorSalad> &> foo.log :p
11:50:18 <sahilm> Any painless way to get haskell-mode in emacs?
11:50:26 <FunctorSalad> I guess that's not as standard...
11:51:06 <sahilm> Anybody hacks Haskell in emacs?
11:51:33 <FunctorSalad> 'painless'? I don't remember doing anything fancy
11:51:40 <FunctorSalad> to get started with it at least
11:52:04 <sahilm> Okay I'll just pull it from the repos
11:52:05 <sahilm> Thanks
11:52:06 <FunctorSalad> IIRC you put the haskell mode directory into your loadpath...
11:52:22 <FunctorSalad> ah. what other method is there? :)
11:52:28 <FunctorSalad> distro package I guess
11:53:10 <jmcarthur> i used a distro package. all i had to do was add a thingy to my ~/.emacs file, and even that was given to me as an instruction by the package manager
11:53:38 <FunctorSalad> loadpath and auto-mode-alist entry I guess
11:53:43 <jmcarthur> yup
11:53:49 <FunctorSalad> hmm or actually the latter may be handled by the site file
11:53:58 <jmcarthur> don't think it is though
11:54:01 * jmcarthur checks
11:54:15 <jmcarthur> oh, it indeed is
11:58:18 * hackagebot xml-basic 0.1.1.1 - Basics for XML/HTML representation and processing  http://hackage.haskell.org/package/xml-basic-0.1.1.1 (HenningThielemann)
11:59:00 <aristid> yay for gadts
12:00:19 * hackagebot tagchup 0.4.0.1 - alternative package for processing of tag soups  http://hackage.haskell.org/package/tagchup-0.4.0.1 (HenningThielemann)
12:17:00 <EvanCarroll> withFile' :: FilePath -> IOMode -> (Handle -> IO a) -> IO a  
12:17:13 <EvanCarroll> nvm
12:28:41 <FunctorSalad> huh... Criterion.Main claims that: "[this] is a function which will cause results to be evaluated to head normal form (NF)"
12:28:56 <FunctorSalad> isn't that like impossible in haskell ;)
12:29:15 <FunctorSalad> if memory serves about the definition of "head normal form"
12:29:29 <FunctorSalad> (reduce in the body of lambdas)
12:30:06 <dolio> Yes.
12:30:24 <FunctorSalad> about the impossibility too?
12:30:31 <FunctorSalad> at least with compiled code...
12:30:45 <FunctorSalad> I mean even with unsafe stuff
12:31:39 <FunctorSalad> hmm apparently it just means rnf (there is an NFData constraint on this function)
12:32:17 <dolio> It is impossible, except in some special cases, perhaps.
12:33:42 <dolio> For instance, with let v = e in \_ -> v, you can arguably reduce under the lambda by applying it and evaluating the result.
12:33:49 <dolio> Which will reduce e.
12:34:07 <dolio> And since it's shared, that reduction will be saved.
12:34:51 <dolio> However, that's a pretty special case.
12:35:53 <FunctorSalad> yes, the function in question has type nf :: NFData b => (a -> b) -> a -> Pure
12:36:23 <FunctorSalad> the (a->b) -> a thing is just to prevent memoization, since criterion wants to evaluate $1 $2 many times
12:36:34 <FunctorSalad> but 'b' might itself be a function type
12:37:14 <dolio> \_ -> e will not reduce in the same way, though.
12:39:32 <FunctorSalad> an NFData instance for a function type can't really expect the argument to be unused
12:40:37 <dolio> I don't know what NFData would do for functions other than seq.
12:40:41 <FunctorSalad> well, in that special case you could do hnf f = let !x = f undefined `using` rnf in \_ -> x, no?
12:40:51 <FunctorSalad> but only in the special case :)
12:40:51 <dolio> Which certainly isn't inducing a normal form.
12:40:56 <FunctorSalad> yeah
12:41:24 <FunctorSalad> (to reconstruct the f after reducing the body)
12:42:12 <dolio> Yes, if you know it's a constant function, you can do that.
12:42:29 <dolio> A non-strict constant function, even.
12:42:52 <FunctorSalad> (possibly a superstitious ! before the x there)
12:44:12 <lispy> dolio: make the argument strict like bang patterns?
12:44:58 <FunctorSalad> lispy: dolio means you can't do 'f undefined' for a constant strict function
12:45:15 <sahilm> Why does this work? head' (x:_) = x
12:45:23 <FunctorSalad> (or you can, but the 'rnf' will then crash the program ;))
12:45:25 <sahilm> > head' (x:_) = x
12:45:27 <lambdabot>   <no location info>: parse error on input `='
12:45:51 <dolio> I guess if it's strict, but isn't constantly bottom-valued, it technically isn't constant.
12:45:59 <lispy> sahilm: it works because it takes the head of the list and returns it
12:46:01 <FunctorSalad> oh, right
12:46:07 <dolio> Depending on how you want to define things.
12:46:19 <lispy> > let head' (x:_) = x in head' [1..]
12:46:20 <lambdabot>   1
12:46:26 <sahilm> lispy: How is it taking the head of the list?
12:46:34 <lispy> sahilm: (x:_)
12:46:46 <sahilm> Yeah but I can't figure what that means.
12:46:54 <lispy> sahilm: do you know what (:) is?
12:46:56 <lispy> :t (:)
12:46:57 <ezyang> sahilm: Do you know what pattern matching is? 
12:46:57 <lambdabot> forall a. a -> [a] -> [a]
12:47:08 <BMeph> Have we discussed mjd's blog article today already?
12:47:12 <sahilm> : is the cons operator
12:47:17 <ezyang> BMeph: linky? 
12:47:21 <sahilm> It adds stuff to the head of a list?
12:47:29 <lispy> > let head' (x:xs) = x in head' [1..] -- does this version make more sense to you sahilm
12:47:30 <lambdabot>   1
12:47:44 <sahilm> lispy: I can see that I works
12:47:50 <sahilm> lispy: But it's not making sense.
12:48:02 <sahilm> : adds stuff to the head of the list?
12:48:03 <lispy> sahilm: it's actually the list data constructor.  That it works as cons is because it's how you construct lists
12:48:23 <lispy> sahilm: data [a] = [] | a : [a] -- not valid haskell
12:48:30 <FunctorSalad> in a pattern it "undoes" the consing
12:48:44 <tafryn> > [1,2,3] == 1:2:3:[] -- This might help, sahilm.
12:48:45 <lambdabot>   True
12:48:47 <FunctorSalad> lispy: I think the issue is pattern matching
12:48:56 <sahilm> FunctorSalad: Yes.
12:49:05 <sahilm> :t :
12:49:07 <lambdabot> parse error on input `:'
12:49:14 <tafryn> :t (:)
12:49:15 <sahilm> :t (:)
12:49:15 <lambdabot> forall a. a -> [a] -> [a]
12:49:16 <lambdabot> forall a. a -> [a] -> [a]
12:49:28 <FunctorSalad> > let (x,y) = (1,2) in x
12:49:29 <lambdabot>   1
12:49:40 <sahilm> So it returns a new list with a in it.
12:50:19 <lispy> sahilm: Yeah.  But you can also deconstruct a value by looking at its constructor
12:50:22 <mauke> > case [1,2,3] of (x : xs) -> (x, xs)
12:50:23 <lambdabot>   (1,[2,3])
12:50:40 <sahilm> > let (x,y) = ("car", "bus") in x
12:50:41 <lambdabot>   "car"
12:51:02 <sahilm> > let (x,y) = ("car", "bus") in y
12:51:03 <lambdabot>   "bus"
12:51:45 <sahilm> lispy: "deconstruct"?
12:52:01 <sahilm> lispy: return the *integral* elements? Like chars from a list?
12:52:04 <lispy> sahilm: yes, take it part into the things that make it up
12:52:04 <EvanCarroll> is there a better way to to `delete (arr!!idx) arr`
12:52:20 <mauke> sahilm: return the elements it was constructed from
12:52:29 <EvanCarroll> I want to delete the index, not the first occurance of the value at the idx
12:52:33 <sahilm> mauke: all elements?
12:52:41 <mauke> sahilm: well, there are only two
12:52:42 <mauke> but yes
12:52:45 <sahilm> Yeah so : is the list constructor?
12:52:50 <mauke> one of them
12:53:00 <sahilm> Which can be used to get the parts of the list as well.
12:53:07 <mauke> there are two list constructors
12:53:20 <mauke> [], which takes no values, and (:), which takes two
12:53:20 <lispy> sahilm: bingo
12:53:36 <sahilm> > let x = [] in x
12:53:37 <lambdabot>   []
12:53:50 <sahilm> > let x = [] in [1..5]
12:53:51 <lambdabot>   [1,2,3,4,5]
12:54:07 <lispy> sahilm: and this is true of all data types in haskell (although, for some data types the constructors are hidden away in a module and the language will forbid you from accessing them.  It just depends on the author's wishes.)
12:54:20 <sahilm> lispy: okay.
12:54:39 <lispy> sahilm: similarly, you can think of data Int = 1 | 2 | 3 | ...
12:54:45 <sahilm> >let x = (x:[]) in [1..5]
12:54:47 <tafryn> lispy: Which data types have hidden constructors?
12:54:48 <FunctorSalad> EvanCarroll: let (x,y) = splitAt idx arr in x++y
12:54:55 <mauke> tafryn: Data.Map.Map
12:54:56 <lispy> tafryn: IO is a  good example
12:54:57 <FunctorSalad> EvanCarroll: let (x,_:y) = splitAt idx arr in x++y
12:55:00 <FunctorSalad> correction
12:55:20 <mauke> also, IORefs
12:55:42 <FunctorSalad> EvanCarroll: perhaps you want a different data structure, since this is O(idx)!
12:55:44 <sahilm> >let x = (x:xs) in [1..5]
12:56:01 <FunctorSalad> (exclamation, not factorial :P)
12:56:07 <lispy> sahilm: you need to use the x that you're defining, otherwise it's just evaluating a constant :)
12:56:31 <sahilm> lispy: How would I rewrite the above?
12:56:38 <lispy> > let (x:xs) = [1..5] in (x:xs)
12:56:39 <lambdabot>   [1,2,3,4,5]
12:56:58 <lispy> > let (x:xs) = [1..5] in xs
12:57:00 <lambdabot>   [2,3,4,5]
12:57:05 <FunctorSalad> EvanCarroll: hmm I assumed you're using a list there btw
12:57:12 <sahilm> > let (x:_) = [1..5] in (x:_)
12:57:13 <FunctorSalad> maybe your array library uses (!!) too
12:57:14 <lambdabot>   Pattern syntax in expression context: _
12:57:27 <mauke> sahilm: you can't use _ in expressions
12:57:37 <lispy> sahilm: Unfortunately, you can't use _ on the right hand side of equals
12:57:52 <cncl> are there examples of fclabels in use somewhere
12:57:53 <lispy> sahilm: There is a compiler that allows this, and sets _ = undefined when you do it
12:58:01 <cncl> i don't even know what language options i need at the top of my file
12:58:05 <sahilm> >let (x:_) = [1..3] in (x:xs)
12:58:11 <cncl> the source doesn't include any examples
12:58:20 <sahilm> aargh.
12:58:21 <lispy> > let (x:_) in [1..5] in (x:undefined)
12:58:22 <lambdabot>   <no location info>: parse error on input `in'
12:58:25 <FunctorSalad> TemplateHaskell probably cncl 
12:58:31 <sahilm> okay.
12:58:35 <sahilm> I need to define xs
12:58:35 <FunctorSalad> I don't really know fclabels
12:58:44 <cncl> ok
12:58:45 <lispy> > let (x:_) = [1..5] in (x:undefined)
12:58:46 <lambdabot>   [1*Exception: Prelude.undefined
12:58:50 <sahilm> yeah.
12:58:53 <BMeph> ezyang: http://blog.plover.com/prog/haskell/monad-terminology.html
12:58:55 <cncl> is there a records thing that's better than fclabels?
12:58:57 <monadic_kid> cncl: I've got code that uses them
12:59:02 <EvanCarroll> FunctorSalad: I am
12:59:08 <ezyang> BMeph: Ah. 
12:59:09 <cncl> monadic_kid: cool
12:59:13 <sahilm> But I'm still not sure what (x:xs) means.
12:59:18 <EvanCarroll> FunctorSalad: that's really ugly.
12:59:22 <EvanCarroll> FunctorSalad: but ok.
12:59:33 <ezyang> I don't like mote, because the real world isn't really indicative of what a monadic value is. 
12:59:34 <FunctorSalad> ?
12:59:46 <EvanCarroll> I guess trying to make an immutable array mutable is a bad idea
12:59:47 <lispy> sahilm: it's easy, the colon is a constructor, it takes an element and a list and gives a new list.  In this case, the element is x and the list is xs.
12:59:51 <FunctorSalad> lists aren't meant for random access, there's just no way you'll avoid iterating
13:00:03 <EvanCarroll> removing from the middle is probably not very haskelish
13:00:19 <FunctorSalad> it's not 'haskellism', linked lists are like that :p
13:00:25 <sahilm> so (x:xs) will return me a new list with x in it?
13:00:36 <sahilm> provided xs is defined previously as a list.
13:00:41 <FunctorSalad> you might want a list zipper or an IntMap
13:00:48 <monadic_kid> cncl: it's not that diffcult really, only when  you need to define type signatures of labels where it might seem a bit weird if you're not use to type operators
13:01:20 <cncl> do i need to enable type operators
13:01:24 <FunctorSalad> EvanCarroll: at least mine won't iterate over the list *twice* :P
13:01:26 <cncl> TypeOperators ?
13:01:28 <monadic_kid> cncl: yes
13:01:28 <sahilm> lispy: Is the above correct?
13:01:33 <lispy> sahilm: yeah
13:01:33 <cncl> ah that's what i was missing
13:01:40 <lispy> > 1 : [2,3]
13:01:41 <lambdabot>   [1,2,3]
13:01:45 <lispy> sahilm: ^^
13:01:51 <monadic_kid> cncl: and import Prelude hiding (id, (.), mod)
13:01:55 <lispy> > 3 : []
13:01:56 <lambdabot>   [3]
13:01:58 <cncl> type operators are just infix names for parametric types right
13:02:01 <sahilm> lispy: But the parens have specil meaning, right?
13:02:05 <sahilm> special
13:02:08 <cncl> yeah i know control.category :)
13:02:13 <sahilm> they define a pattern?
13:02:17 <monadic_kid> cncl: and constructors
13:02:24 <sahilm> I've seen them used to define tuples.
13:02:24 <lispy> sahilm: no, but sometimes they are syntatically needed
13:02:35 <sahilm> lispy: for precedence?
13:02:39 <lispy> sahilm: actually, it's (,) that creates tutples
13:02:43 <lispy> :t (,)
13:02:44 <lambdabot> forall a b. a -> b -> (a, b)
13:02:49 <sahilm> lispy: yeah.
13:02:57 <lispy> > zipWith (,) [1..3] "abc"
13:02:58 <lambdabot>   [(1,'a'),(2,'b'),(3,'c')]
13:03:23 <monadic_kid> cncl: it uses template haskell to generate labels from record members
13:03:29 <lispy> sahilm: oh, and empty parens does have a meaning.  () is called "unit".  It's a type with 1 value
13:03:36 <lispy> > () == ()
13:03:37 <sahilm> zipWith (;) [1..5] [2..7]
13:03:37 <lambdabot>   True
13:03:39 <mauke> data () = ()
13:03:41 <monadic_kid> cncl: uses class cateogry . for composing labels
13:03:52 <sahilm> > zipWith (;) [1..5] [2..7]
13:03:53 <lambdabot>   <no location info>: parse error on input `;'
13:04:00 <mauke> sahilm: ; is not an operator
13:04:12 <lispy> > let (;) = (,) in zipWith (;) [1..5] [2..7]
13:04:13 <lambdabot>   <no location info>: parse error on input `;'
13:04:21 <sahilm> I thought (,) was a placeholder.
13:04:27 <sahilm> to zipWith
13:04:28 <lispy> > let (.) = (,) in zipWith (.) [1..5] [2..7]
13:04:29 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6)]
13:04:34 <mauke> sahilm: huh?
13:04:41 <sahilm> mauke: nevermind.
13:05:02 <sahilm> lispy: you defined (.) as (,), right?
13:05:04 <yrlnry> sahilm:  (,) is the function that takes a and b and returns (a,b)
13:05:09 <FunctorSalad> is there a benchmark lib that will actually make me the obvious plot for an `Int -> a' function?
13:05:15 <lispy> > let f a b = (a, b) in zipWith f [1..4] ['a'..'z']
13:05:16 <lambdabot>   [(1,'a'),(2,'b'),(3,'c'),(4,'d')]
13:05:21 <lispy> sahilm: does that example help?
13:05:23 <sahilm> > :t zipWith
13:05:24 <lambdabot>   <no location info>: parse error on input `:'
13:05:36 <FunctorSalad> Criterion has plotting, but doesn't seem to have any notion of input size, just resampling :\
13:05:36 <sahilm> >T zipWith (,)
13:05:45 <sahilm> >:t zipWith (,)
13:05:47 <lispy> :t zipWith
13:05:48 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
13:05:49 <yrlnry> @t zipWith
13:05:49 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:05:51 <lispy> :t zipWith (,)
13:05:52 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
13:06:36 <sahilm> > :t zip
13:06:37 <lambdabot>   <no location info>: parse error on input `:'
13:06:49 <sahilm> > :t zip (,)
13:06:50 <mauke> sahilm: you fail at pattern recognition
13:06:50 <lambdabot>   <no location info>: parse error on input `:'
13:06:51 <edwardk> preflex: xseen copumpkin
13:06:51 <preflex>  copumpkin was last seen on freenode/#haskell 3 hours, 39 minutes and 24 seconds ago, saying: americans don't have philosophers
13:07:02 <lispy> sahilm: you can't fix "> " and ":t"
13:07:06 <lispy> sahilm: er, mix
13:07:17 <sahilm> :t zip
13:07:18 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
13:07:33 <Phyx-> :t zipWith (,)
13:07:34 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
13:07:52 <lispy> sahilm:  "> " means, "evaluate this expression" and ":t" means, "tell me the type of this expression"  But it wouldn't make sense to ask it to evaluate a type
13:08:21 <yrlnry> @type 1
13:08:22 <lambdabot> forall t. (Num t) => t
13:08:24 <sahilm> I didn't know what > meant. I thought it was a directive to the bot to eval haskell code.
13:08:25 <lispy> (sometimes we do compute with types, but that's different)
13:08:35 <EvanCarroll> FunctorSalad: that's kind of clever
13:08:36 <yrlnry> sahilm:  that is correct
13:08:39 <mauke> sahilm: yes, and :t is not haskell code
13:08:40 <EvanCarroll> x,_:y
13:08:42 <EvanCarroll> never saw that before
13:08:44 <cncl> monadic_kid: the example on its own cabal description seems to be wrong.. mkLenses is not in scope
13:08:59 <sahilm> mauke: how is :t not haskell code?
13:09:02 <monadic_kid> cncl: i'm making example, hold on
13:09:04 <sproingie> it's a ghci command
13:09:07 <FunctorSalad> (?)
13:09:07 * lispy goes back to work
13:09:07 <mauke> sahilm: uh, it's a syntax error for one?
13:09:28 <cncl> incorrect example on its own cabal description does not instill much faith :)
13:09:47 <mauke> @type 1::1
13:09:48 <lambdabot>     No instance for (Num Unit)
13:09:48 <lambdabot>       arising from the literal `1' at <interactive>:1:0
13:09:48 <lambdabot>     Possible fix: add an instance declaration for (Num Unit)
13:10:04 <sahilm> mauke: I thought :t was part of the syntax. I guess it's just a ghci directive.
13:10:22 <yrlnry> sahilm:  right.
13:10:24 <sahilm> like :r and :l
13:11:33 <sahilm> > let x = x in [1]
13:11:34 <lambdabot>   [1]
13:11:51 <sahilm> > let (x:xs) = x in [1,2,3]
13:11:52 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
13:11:57 <mrsolo> is BangPatterns commonly used?
13:12:09 <Cale> mrsolo: Quite commonly, yeah.
13:12:22 <dolio> > Unit :: 1
13:12:22 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
13:12:23 <lambdabot>    arising from a use of ...
13:12:25 <sahilm> > let (x:xs) = x in [1,2,3]:[]
13:12:27 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
13:12:33 <Cale> mrsolo: When you need a bit of strictness, it's often a lot more convenient than using seq directly.
13:12:36 <mauke> > [1,2,3] : []
13:12:37 <lambdabot>   [[1,2,3]]
13:12:44 <jutaro> howard@brazee.net
13:12:50 <FunctorSalad> yeah it's easy to use, you just spray everything in the general vicinity of the function in question with !s (self-irony)
13:13:02 <Cale> heh
13:13:24 <mrsolo> Cale: ah thanks
13:14:01 <Cale> It's just as easy to harm things with too much strictness, so I wouldn't recommend the shotgun approach :P
13:14:36 <cncl> monadic_kid: how do i even make the labels/lenses?
13:14:58 <monadic_kid> cncl: :->
13:15:02 <sahilm> > head [1..3]
13:15:03 <lambdabot>   1
13:15:10 <monadic_kid> cncl: hold on a sec
13:15:10 <cncl> yeah but i have to do mkLenses first right
13:15:11 <mrsolo> cale: easy to harm things? such as? 
13:15:15 <cncl> ok
13:16:06 <bdon> noob question: state monad.  Explained everywhere as if it were some singular thing, but I'm not sure what to actually import.      Ambiguous module name `Control.Monad.State'
13:16:21 <lispy> ?hoogle State
13:16:22 <lambdabot> module Control.Monad.State
13:16:22 <lambdabot> Test.HUnit.Base data State
13:16:22 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
13:16:30 <mauke> bdon: it is a singular thing
13:16:30 <yrlnry> What's the simplest example of two expressions that have different values, and which are the same except that one has a pattern marked with ~ and the other doesn't?
13:16:42 <BMeph> > let f !(x:xs) = head xs in f [1..]
13:16:42 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:16:43 <lambdabot>    `SimpleReflect.FromExpr ...
13:16:57 <bdon> Why can I not import Control.Monad.State?
13:16:59 <bdon>     Ambiguous module name `Control.Monad.State':
13:17:01 <roconnor> import Control.Monad.State ought to work (assuming you are using the awful mtl)
13:17:14 <mauke> bdon: what's the rest of the message?
13:17:14 <bdon> mtl?
13:17:20 <bdon> it was found in multiple packages: monads-tf-0.1.0.0 mtl-1.1.0.2
13:17:21 <roconnor> monad transformer library
13:17:26 <mauke> well, there you are
13:17:29 <lispy> bdon: put your code on hpaste.org?
13:17:31 <roconnor> ah yes
13:17:34 <monadic_kid> cncl: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29484#a29484
13:17:37 <bdon> Well, that's pretty much it
13:17:50 <mauke> > (\(_,_) -> ()) (error "!")
13:17:51 <lambdabot>   *Exception: !
13:17:55 <cncl> monadic_kid: oh, it's mkLabels
13:17:56 <mauke> > (\ ~(_,_) -> ()) (error "!")
13:17:57 <lambdabot>   ()
13:18:04 <roconnor> bdon: you have to hide one of the packages ... I forget how you do that
13:18:07 <lispy> bdon: if you use a cabal file you could avoid this, or add -hiding foo, to your command line
13:18:08 <FunctorSalad> bdon: import "mtl" Control.Moand.State and add {-# LANGUAGE PackageImports #-}
13:18:14 <bdon> Do I have multiple Control.Monad.State...s, because of some hackage stuff I downloaded?
13:18:16 <sproingie> (_,_) looks like i'm being mooned
13:18:17 <FunctorSalad> .... add on top of the file
13:18:23 <mauke> bdon: yes
13:18:26 <roconnor> bdon: yes
13:18:28 <bdon> Or is it ambiguous in Platform to begin with
13:18:30 <bdon> Ah
13:18:33 <yrlnry> or is it the case that all such pairs of expressions will have the same value?
13:18:38 <monadic_kid> cncl: you only need to enable template haskell where ever you use mkLabels
13:18:42 <bdon> What's horrible about mtl, and which do you recommend?
13:18:42 <roconnor> I would hope it isn't ambiguous to begin with
13:18:48 <FunctorSalad> the package import has the advantage of shutting it up once and for all, say if you reinstall ghc ;)
13:18:53 <mauke> yrlnry: does (\ ~(_,_) -> ()) (error "!") count?
13:18:54 <cncl> monadic_kid: the example has mkLenses on its own cabal description :)
13:18:57 <roconnor> bdon: mtl has a few bugs.  I like monadlib myself
13:18:59 <cncl> which is wrong!
13:19:08 <FunctorSalad> roconnor: hmm?
13:19:12 <FunctorSalad> (bugs?)
13:19:18 <bdon> Shouldn't there be some kind of contorl of these names?
13:19:28 <roconnor> FunctorSalad: there is that cont / state bug, and there is listT which isn't a T.
13:19:39 <bdon> Very intimidating for an already intimidating thing to be trying to start up with
13:19:43 <BMeph> yrlnry: Check it out...:
13:19:47 <cncl> monadic_kid: thanks
13:19:47 <BMeph> > let f (x,y) = 3 in f (undefined)
13:19:48 <lambdabot>   *Exception: Prelude.undefined
13:19:51 <BMeph> > let f ~(x,y) = 3 in f (undefined)
13:19:52 <lambdabot>   3
13:20:01 <mauke> BMeph: why the parens?
13:20:04 <roconnor> bdon: packages try to fix the mtl and be compatible at the same time
13:20:23 <FunctorSalad> bdon: yes IMHO it was a bad idea to overload the module name, but just add the package import 
13:20:29 <BMeph> yrlnry: ^^ Get it? :)
13:20:33 <roconnor> bdon: but yes, the package management in ghc is more or less broken.
13:20:34 <sahilm> > ('a':['b','c'])
13:20:35 <lambdabot>   "abc"
13:20:40 <bdon> Man.  Isn't this channel infested with the official maintainers?  If it's so widely reviled, how is it not fixed?
13:20:44 <sahilm> How would I deconstruct?
13:20:56 <roconnor> bdon: it was less of a problem before hackage caused a proliferation of packages to be devoloped and easily distributed.
13:21:01 <bdon> Ah
13:21:11 <BMeph> mauke: Because 1) I cut-n-pasted from another expression, which 2) I was too lazy to remove then from. :)
13:21:19 <FunctorSalad> bdon: too late now I guess, changing the module names now would cause even more confusion
13:21:22 <mauke> BMeph: and how is your example different from mine?
13:21:24 <EvanCarroll> how come I can't `length.words`
13:21:25 <roconnor> bdon: Presumably package management is broken in every language ;)
13:21:29 <bdon> Who's in charge of this anyways?
13:21:36 <bdon> Python seems pretty consistent
13:21:39 <roconnor> bdon: Haskell is mostly anarchy
13:21:41 <EvanCarroll> length is polymorphic, and words returns [Str]
13:21:48 <yrlnry> BMeph:  yes.  Is it the case that the value can only differ when the refutable version yields _|_?
13:21:55 <bdon> Who distributes the Platfrom?
13:21:56 <Chowder1> lol
13:21:56 <BMeph> mauke: I ran mine and you didn't. ;Ã¾
13:21:58 <roconnor> bdon: how does python distribute their packages.
13:22:02 <mauke> BMeph: yes, I did
13:22:10 <bdon> Huge consistent standard library
13:22:16 <zachk> > 2 + 2 
13:22:16 <roconnor> I suppose Java does okay package management IIRC.
13:22:17 <lambdabot>   4
13:22:17 <lispy> wait wait.  The solution here is to use a cabal file.
13:22:28 <Chowder1> >2+2
13:22:29 <bdon> Other things aren't in any central repositoory, but I've never encountered a name clash
13:22:32 <lispy> Using the package import extension is not the right way to solve this
13:22:33 <roconnor> bdon: who guards the gates in Python and ensures consistency?
13:22:46 <bdon> Guido and some cabal
13:22:56 <bdon> They have a benevolent dictator
13:23:00 <bdon> Not always great
13:23:07 <lispy> We have a BSD license
13:23:08 <roconnor> bdon: So Hackage is unmanaged
13:23:32 <roconnor> bdon: and since the mtl is broken various people have proposed "compatiable" changes.
13:23:52 <bdon> Are packages like mtl only editable bytheir original author?
13:24:01 <roconnor> bdon: by "compatible" changes we mean of course, incompatiable changes in the sense you can't have both packages at the same time because they have the same interface
13:24:21 <mauke> yrlnry: that sounds like it should be true in theory
13:24:31 <roconnor> bdon: ... techinally anyone with a hackage account can edit any other hackage package.  Though I think that would be frowned upon.
13:24:54 <roconnor> (I've done it in the past before for minor bug fixes)
13:24:54 <mauke> in practice I can catch _|_ or use threads + timing differences to get different values
13:25:04 <bdon> Way out of what I have any rght to say, but somebody needs to fix this before it gets too big to handle.  If Haskell were to ever really take off with this in place, it will never be fixable
13:25:15 <yrlnry> mauke:  Okay, thanks.
13:25:28 <yrlnry> Also I guess a program that can solve the halting problem can tell the difference.  :)
13:25:35 <roconnor> bdon: I think it is in the works  See FunctorSalad's remark
13:25:40 <roconnor> [16:17] <FunctorSalad> bdon: import "mtl" Control.Moand.State and add {-# LANGUAGE PackageImports #-}
13:25:41 <bdon> Thanks for clarifying though, #haskell
13:25:54 <roconnor> that is a pretty good suggestion I think
13:25:57 <BMeph> yrlnry: As long as one answer is "less-defined" than the other, it's legal.
13:26:03 <bdon> What does that mean?
13:26:13 <lispy> bdon: Or use cabal and then it's fixed
13:26:17 <bdon> And what effects will the defficiencies in mtl have on my program?
13:26:21 <roconnor> bdon: it means import Control.Monad.State from the mtl package
13:26:33 <yrlnry> BMeph:  Oh, so for example one might yield x:_|_ and the other might yeld x:y:_|_.  Sure.
13:26:33 <cncl> monadic_kid: did you mean for get to be getL?
13:26:44 <roconnor> but this isn't standard haskell syntax, so a pragma is needed at the beginning of the file
13:26:49 <cncl> monadic_kid: it's called 'getL' in the version i have (0.9.1, apparently)
13:27:01 <yrlnry> BMeph:  thanks, that was very helpful.
13:27:17 <BMeph> yrlnry: ...sure. ;)
13:27:18 <bdon> What do y'all use in place of mtl in your own code?
13:27:29 <monadic_kid> cncl: think so, yeah i'm using and older version, there is a M version for state monads
13:27:30 <roconnor> bdon: the bad effects of using the mtl are that ListT won't work properly, and neither will StateT Cont (or was it ContT State, I never remember).
13:27:41 <mauke> bdon: mtl
13:27:58 <cncl> monadic_kid: ah i see
13:28:07 <roconnor> bdon: I last used monadLib.  But there have been more recent packages such as the mmtl which seem interesting
13:28:07 <BMeph> bdon: hvy-mtl! :D
13:28:59 <monadic_kid> bdon: i've used transformers, that's pretty much interchangable with mtl if you're using lightly
13:29:00 <roconnor> bdon: but I must admit that after prototyping with monad stacks, I usually get a performace gain by rewriting my monad by hand.
13:29:20 <roconnor> bdon: partly because (at one point in time) the ubuntu libraries for haskell pacakges were unoptimized!!!!
13:29:25 <roconnor> god I hope that is fixed by now.
13:29:31 <mrsolo> so why does haskellplatfom ship with mtl if it is somewaht broken?
13:30:05 <roconnor> mrsolo: because lots of packages depend on the mtl I guess.  I don't know.  I've been arguing that it should be removed. ... but then again I think the whole haskell platform should be scrapped.
13:30:38 <mrsolo> roconnor, eh? why is that?
13:31:24 <BMeph> mrsolo: For the same reason legacy systems preserve flaws: people have incorporated the flawed code function into their own code, so that it'll break with "right: code, and they bitch long and loudly if anyone threatens to "fix" it. ;)
13:31:29 <roconnor> mrsolo: because people will end up developing programs that depend on inferior packages that end up in the haskell platform and we will never ever escape the clutches of the mtl and the like.
13:31:32 <monadic_kid> i think jhc comes with transformers now, but no monad-fd/tf
13:31:53 <roconnor> ya, what BMeph said.
13:32:00 <roconnor> much better put.
13:32:35 <monadic_kid> it wouldn't be that much hassle for most people to re-compile with transformers and monads-fd
13:32:39 <monadic_kid> from mtl
13:32:41 <monadic_kid> i think
13:33:04 <mubangs> Are the deficiencies of mtl be fixable with its current structure?
13:33:06 <BMeph> mrsolo: Oh, and ditto with the Num hierarchy, except that the reformers, having gotten wise the hard way, are now bitching because it _hasn't_ been fixed... :)
13:33:10 <roconnor> mrsolo: the package management in cabal is inadequate.  Rather than facing up to the tough challenges of fixing it, the Haskell Platform is an attempt to stick one's head in the sand to avoid the problems by adding gate keepers.
13:34:00 <monadic_kid> i'm sure dons said if everyone votes for it we can get something else to replace mtl in hplatform
13:34:06 <mubangs> Who would you feel comfortable having as gate keepers?
13:34:07 <roconnor> mubangs: the bugs should be.
13:34:10 <mubangs> Dons, obviously
13:34:39 <sproingie> how long til we hate the replacement for mtl?
13:34:45 <FunctorSalad> <lispy> wait wait.  The solution here is to use a cabal file. <lispy> Using the package import extension is not the right way to solve this <-- I disagree. I want my source to be loadable by tools that don't know about cabal, like ghci.
13:35:06 <roconnor> sproingie: I think it will be longer.  We understand monad transformers quite a bit more than when the mtl was written.
13:35:08 <mubangs> I'm guessing SPJ and Hudak and okmij and crap are pretty busy and wouldn't want to deal with politics and mortal issues
13:35:08 <lispy> FunctorSalad: we need a cabal ghci mode.  It's true.
13:35:26 <mrsolo> i see
13:35:37 <sproingie> should get the ball rolling on replacing it then
13:35:46 <mrsolo> well i think haskell platfrom is a good starting point for me at least
13:35:48 <sproingie> probably wont manage to dislodge it but you might at least get both in
13:35:51 <monadic_kid> roconnor: as i said earlier, dons said if people vote for it, mtl can be replaced in haskell platform
13:35:59 <mrsolo> narrow down a list of libraries to learn from for start
13:36:17 <sproingie> you could have mtl included and hidden
13:36:18 <roconnor> when the mtl was written the behaviour of StateT-Cont wasn't even clearly known to be a bug.
13:36:22 <mubangs> Well, you'd think State would be in that list
13:36:23 <FunctorSalad> lispy: (or ghc -e :ctags or ghc -e :type blah)
13:36:25 <mubangs> Yet it seems contentious
13:36:28 <mrsolo> that was when i assume haskellplatfom contains top of the line packages; guess i was wrong
13:36:30 <roconnor> though they should have known better about listT.
13:37:19 <roconnor> monadic_kid: That would fix the mtl problem, but not the problem with the Haskell Platform itself
13:37:35 <aristid> is OverlappingInstances also evil for classes that are not exported?
13:37:46 <monadic_kid> roconnor: what's the problem i didn't follow everything
13:38:10 <roconnor> monadic_kid: [16:31] <BMeph> mrsolo: For the same reason legacy systems preserve flaws: people have incorporated the flawed code function into their own code, so that it'll break with "right: code, and they bitch long and loudly if anyone threatens to "fix" it. ;)
13:38:13 <mubangs> Well the list of issues with the libraries I've run into since starting to learn Haskell are the State monad ambiguity, and that Download won't compile on OS X.  Not game-stopping, but both pretty fundamental
13:38:22 <lispy> aristid: It seems like it shouldn't be as evil, but I don't for sure
13:38:52 <monadic_kid> roconnor: deprecation mechanism?
13:38:57 <aristid> lispy: thing is, i'm having trouble finding a way around OverlappingInstances, so i'm very tempted...
13:39:07 <roconnor> how does CPAN manage their namespace?
13:39:19 <mubangs> What's the actual issue with ListT
13:39:20 <roconnor> I'd think Perl would have the same sorts of problems.
13:39:27 <roconnor> mubangs: it doesn't make monads.
13:39:39 <mubangs> So what laws are broken where?
13:40:14 <sproingie> roconnor: pretty much solely by peer pressure.  PAUSE admins can yank an account if someone really abuses the namespace with misleading packages
13:40:39 <FunctorSalad> another problem with ListT is that it "executes" the monadic actions way too eagerly
13:40:42 <sproingie> roconnor: but by and large people dont do that
13:40:58 <monadic_kid> if they are going to bitch just let them use an older version of the platform or provide the package as a deprecated one that will get phased out, until they can be bothered to sort it out
13:41:26 <monadic_kid> The platform is still quite new i doubt there will be many who are going to bitch about it
13:41:35 <FunctorSalad> ListT m a = ListT (m (Maybe (a,ListT m a))) -- better ListT
13:41:55 <roconnor> mubangs: I forget the details of which laws are broken.
13:41:56 <FunctorSalad> (every cons is wrapped in an 'm')
13:41:59 <sproingie> ow
13:41:59 <yrlnry> CPAN doesn't manage the namespace.
13:42:27 <yrlnry> What little namespace management there is is provided by PAUSE, which is the CPAN upload server.  Basically, the first person to squat on a piece of namespace territory owns it.
13:42:45 <mubangs_> Man, freenode webchat keeps cutting me off.  What IRC client are yall using?
13:42:49 <roconnor> yrlnry: packages are the same as namespaces?
13:42:50 <yrlnry> But just because I squat on Foo::Bar does not prevent anyone else from squatting Foo::Bar::Baz or anything other than Foo::Bar.
13:42:57 <yrlnry> roconnor:  Yes.
13:43:02 <FunctorSalad> xchat
13:43:06 <sproingie> mubangs_: there's a line length limit in irc itself
13:43:06 <mauke> mubangs_: irssi
13:43:17 <roconnor> I guess that is one solution
13:43:20 <sproingie> most clients should wrap.  irssi does it.
13:43:27 <yrlnry> It has worked well for Perl for a long time.
13:43:29 <mauke> sproingie: no
13:43:29 <sproingie> i thought xchat did too
13:43:33 <mubangs_> No, not cutting off my messages, but it stops updating the channel at all
13:43:47 <yrlnry> If someone else has already taken the awesome name you wanted, oh well, you can still think of another one.
13:43:48 <sproingie> well that's xchat for you
13:43:58 <FunctorSalad> sproingie: I think it does
13:44:04 <sproingie> i gave up on it when i saw what a grotesque mockery its python API was
13:44:06 <roconnor> maybe we have been doing our namespace / package management wrong this whole time
13:44:26 <roconnor> and we should be putting our package names into our module names
13:44:32 <yrlnry> The worst things that has happened to me with the CPAN model is not too bad.  I own X::Y and some loser comes along and posts X::Y::Fast, or X::Y::Better, or some such.  
13:44:44 <roconnor> Mtl.Monad.State instead Control.Monad.State
13:44:55 <sproingie> CPAN is not without its problems, but there's hardly a language community in the world who doesn't want something as successful as CPAN
13:45:08 <sproingie> (uh oh there's that "avoid success")
13:45:11 <lispy> import Org.Haskell.MTL.Control.Monad.State -- No thanks.
13:45:28 <roconnor> lispy: it's not so terrible IMHO
13:45:34 <yrlnry> Lispy: That works very badly in many ways.
13:45:49 <pikhq> lispy: With only qualified imports!
13:46:15 <mubangs_> Can someone explain the nature of the problem with mtl and ListT?
13:46:19 <yrlnry> lispy:  For example, when I was working at Morgan Stanley  about ten years ago, they complained bitterly that even though they owner ms.com, Microsoft had squatted on the com.ms Java namespace and would not stop using it.
13:46:26 <lispy> roconnor: I think the language extension that lets you state the package name is superior to Mtl.Control.Monad.State
13:46:28 <yrlnry> And who was going to stop them?
13:46:45 <roconnor> lispy: why are we adding another name space level to our name spaces
13:47:14 <mubangs_> Are there any other known issues with the Platform-included libraries?
13:47:15 <roconnor> lispy: how is import "mtl" Control.Monad.State any better than import Mtl.Control.Monad.State
13:47:16 <aRcatan> i herd u like namespaces so i put a namespace in your namespace AAARGh
13:47:27 <lispy> roconnor: Because making the creator explicit _and_ required sucks.
13:47:45 <yrlnry> Also tying the name of your software to the weird vagaries of ICANN and international trademark law is an obviously silly thing to do.  
13:47:58 <mubangs_> Well if multiple packages do the same thing, how else could you?
13:49:02 <yrlnry> > let ~(h1:h2:t) = "f" in h1
13:49:03 <lambdabot>   *Exception: <interactive>:1:149-164: Irrefutable pattern failed for pattern...
13:49:19 <yrlnry> Why didn't that yield "f"?
13:49:42 <roconnor> > let ~(h1:~(h2:t)) = "f" in h1
13:49:43 <lambdabot>   Not in scope: data constructor `:~'
13:49:45 <yrlnry> I thought it would bind h2 and t to _|_ and then yield h.
13:49:47 <roconnor> > let ~(h1: ~(h2:t)) = "f" in h1
13:49:48 <lambdabot>   'f'
13:49:51 <roconnor> > let (h1: ~(h2:t)) = "f" in h1
13:49:52 <lambdabot>   'f'
13:50:00 <yrlnry> hm.
13:50:38 <roconnor> yrlnry: btw, all lets already come with a twidle in front of every pattern.
13:51:00 <roconnor> yrlnry: so your twiddle had no semantic change.
13:51:21 <yrlnry> Ahhh.  Enlightenment!
13:51:48 <yrlnry> I read that all lets wre irrefutable, but I couldn't understand that because it didn't occur to me that the subparts of the pattern could be made separately irrefutable.
13:51:52 <yrlnry> Thanks.
13:56:08 <int80_h> how do I update cabal packages to use base version 4.x?
13:56:20 <lispy> yrlnry: I could be wrong, but if you found something that gave a different answer (not counting _|_) when evaluated with ~ than without you'd have a language bug
13:56:56 <lispy> int80_h: probably the biggest thing is to upgrade to the new exception stuff.  There is a package available to help with that transition
13:57:05 <roconnor> lispy: am I allowed to catch the loop exception?
13:57:14 <FunctorSalad> no
13:57:17 <FunctorSalad> ;)
13:57:29 <FunctorSalad> that's outside the denot semantics isn't it
13:57:43 <int80_h> lispy: which would be what? cabal advised me to update all packages to use base version 4.x, which is what prompted me to ask.
13:57:57 <roconnor> you know, migration to the new exceptions has been a lot smoother than migrating from the mtl
13:58:01 <lispy> int80_h: ah.  Just as econd
13:58:24 <FunctorSalad> Control.OldException?
13:58:43 <roconnor> we should move the mlt to Control.OldMonad!
13:58:49 <FunctorSalad> ^^
13:58:51 <int80_h> I'm changing around the takusen tutorial code to use dons bytestring-csv. It seems to be becoming something more than just a takusen tutorial.
13:59:10 <roconnor> or better yet.  Mtl.Monad :P
13:59:24 <lispy> int80_h: heh
13:59:31 <FunctorSalad> maybe people will think that older means more powerful
13:59:39 <yrlnry> Single variable name patterns are always irrefutable.
13:59:41 <lispy> int80_h: It's either oldException or extensible-exceptions
13:59:41 <int80_h> I don't think it's useful to demonstrate takusen out of context, so I'm giving it somethign to do. Which means using other libraries.
13:59:44 <FunctorSalad> like in fantasy games
13:59:59 <ljungk> is there a function that applies a function on a data structure  until it "doesn't change" ?
14:00:02 <yrlnry> nd I imagine that _ is always irrefutable.
14:00:15 <roconnor> ljungk: I'm not aware of one.
14:00:21 <lispy> ljungk: fix?
14:00:26 <lispy> :t fix
14:00:27 <lambdabot> forall a. (a -> a) -> a
14:00:32 <mauke> all variables are irrefutable
14:00:34 <roconnor> lispy: :D
14:00:35 <monadic_kid> woohooo,  latest version of jhc fixes the issues i had with writing a baisc game/event loop with SDL
14:00:41 <yrlnry> lispy:  that's not it.
14:00:46 <lispy> :)
14:01:03 <roconnor> monadic_kid: does raincat now compile with JHC?
14:01:17 <ljungk> lispy: where is fix?
14:01:26 <yrlnry> ljungk:  no, but you can   deadHorse f x = if fx == x then x else deadHorse f fx where fx = f x
14:01:30 <roconnor> ljungk: you don't want fix.  lispy was joking.
14:02:16 <ljungk> ok, but what is it then_
14:02:17 <ljungk> ?
14:02:17 <FunctorSalad> @let fixit f x = let ys = iterate f x in fst . head . filter (uncurry (==)) $ zip ys (tail ys)
14:02:19 <lambdabot>  Defined.
14:02:29 <Cale> ljungk: It's defined in Data.Function
14:02:35 <FunctorSalad> > fixit (`div` 2) 42
14:02:35 <roconnor> ljungk: you have to write your own, like yrlnry just did.
14:02:36 <lambdabot>   0
14:02:42 <roconnor> Cale: it is?
14:02:43 <FunctorSalad> omg it worked the first time
14:02:51 <yrlnry> FunctorSalad++
14:02:54 <FunctorSalad> :D
14:03:04 <int80_h> oh great "cabal install cabal-install" is hanging at the link stage
14:03:44 <int80_h> it's hanging here "Linking dist/build/cabal/cabal ..."
14:03:48 <monadic_kid> roconnor: I don't know, it has many dependancies, jhc doesn't support multi-parameter type-classes with FD and those tend to be (over-) used but john is planning to add type families at some point
14:03:50 <notabel> int80_h: give it time
14:04:00 <Cale> roconnor: I even checked!
14:04:03 <notabel> i noticed the same thing yesterday, but it eventually finished
14:04:05 <Cale> It's also in Control.Monad.Fix
14:04:13 <int80_h> cool
14:04:18 <yrlnry> @source fix
14:04:18 <lambdabot> fix not available
14:04:23 <roconnor> Cale: um, are you talking about fix?
14:06:32 <FunctorSalad> yrlnry: I prefer your name for the function ;)
14:07:00 <ljungk> ah, now I see what fix is :)
14:07:03 <Cale> roconnor: yes
14:07:06 <mauke> @src fix
14:07:06 <lambdabot> fix f = let x = f x in x
14:07:16 <roconnor> Cale: fix isn' the function ljungk is looking for
14:07:25 <Cale> roconnor: He asked where it was
14:07:40 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
14:07:41 <lambdabot>   3628800
14:07:53 <mauke> this isn't the function you're looking for *handwaves*
14:08:01 <roconnor> ah I guess I misunderstood the reference for it
14:08:39 <roconnor> _o/ this isn't the function you're looking for _o\
14:09:00 <ljungk> yeah, I do but I just didn't get how such a type signature could even make sense
14:09:13 <yrlnry> The explanation of irrefutable patterns on pages 33â€“34 of the H98 report is excellent, with many incisive examples.   I should have looked there first.
14:09:29 <FunctorSalad> ljungk: it doesn't make sense in a strict language, in fact
14:09:30 <Cale> ljungk: It is somewhat surprising.
14:09:32 <yrlnry> ljungk:  Yeah, it's bizarre all right.
14:10:03 <roconnor> ljungk: you are looking into the heart of computer science
14:10:09 <Cale> If you treat it as a statement of logic, it's basically a contradiction.
14:10:10 <roconnor> ljungk: most people go blind
14:10:14 <FunctorSalad> (a more bottomup way to think of fix is as the limit of: f(_|_), f(f(_|_)), f(f(f(_|_)))....
14:10:21 <roconnor> ljungk: some go mad
14:10:24 <FunctorSalad> which will all be _|_ for strict f)
14:10:25 <Cale> The heart of computer science is a contradiction :0
14:10:32 <ljungk> heh
14:10:34 <yrlnry> "As a proof method, general recursion is wholly bogusâ€”its type, âˆ€P â‡’ (P â†’ P ) â†’ P is a blatant lie."
14:10:51 <Cale> :t fix id
14:10:52 <lambdabot> forall a. a
14:10:58 <mauke> FunctorSalad: I've used fix in Perl
14:11:01 <Cale> YAY MATHEMATICS IS FINISHED
14:11:30 <FunctorSalad> mauke: hmm I suppose even 'strict languages' are nonstrict for function types
14:11:32 <ljungk> Cale: haha
14:11:44 <FunctorSalad> (for 'a' a function type)
14:12:14 <lispy> Cale: about time!
14:12:15 <mauke> newtype Void = V Void
14:12:16 <FunctorSalad> I mean you can have a function taking a function which is 'const undefined', but doesn't return undefined, in most langs
14:12:39 <FunctorSalad> I'm identifying undefined and 'const undefined' there
14:14:22 <chrisdone> beep
14:15:59 <FunctorSalad> how do I get the stime/utime of the current process
14:16:10 <FunctorSalad> seems like that'd be better for benchmarking than clock time
14:18:07 <lispy> FunctorSalad: are you benchmarking 'const undefined'?
14:18:21 <FunctorSalad> =)
14:18:59 <FunctorSalad> system "ps -o time -p $PPID"? :P
14:24:51 <int80_h> so I am trying to run Test.hs that comes with Text.CSV.ByteString. I get this error :"Could not find module `Data.ByteString.Lex.Double'"
14:25:00 <int80_h> I have .cabal in my $PATH
14:25:17 <int80_h> oh wait
14:26:03 <int80_h> hmm, yeah still a problem
14:28:31 <int80_h> any advice on how to fix this? Do I need to install manually? I tried that and that failed.
14:29:29 <int80_h> hmmm
14:29:44 <roconnor> int80_h: in what way are you running Test.hs?
14:29:57 <int80_h> okay I figured out how to install it manually. But shouldn't dependencies automaically install?
14:30:06 <int80_h> runhaskell test.hs
14:30:21 <int80_h> runhaskell test.hs data.csv
14:31:28 <roconnor> int80_h: have you installed bytestring-lexing?
14:31:44 <int80_h> it works. I had to install bytestring-lexing manually. I wonder why cabal didn't install it when I installed the CSV-bytestring.
14:32:14 <roconnor> because cabal is deficient, like I said earlier :D
14:33:00 <lispy> int80_h: it only installs dependencies if you install things from hackage
14:33:12 <lispy> int80_h: otherwise it checks dependencies and complains
14:33:24 <int80_h> gotcha
14:33:49 <roconnor> lispy: bytestring-lexing isn't part of bytestring-csv
14:34:01 <roconnor> int80_h: I guess the real problem is that cabal hasn't been told about the tests
14:34:24 <roconnor> int80_h: dons just tossed a couple of files into the distribution and prays for the best
14:34:59 <roconnor> extra-source-files:  examples/Test.hs examples/data.csv
14:35:05 <roconnor> ^^ this is all that cabal was told
14:35:21 <lispy> roconnor: I didn't expect bytestring-lexing to be part of bytestring-csv (and I'm not sure why you told me...what did I say?)
14:35:23 <monochrom> I would not want packages installed just for the tests.
14:35:56 <roconnor> lispy: you said "it only installs dependencies if you install things from hackage"
14:36:18 <roconnor> but even if int80_h did install bytestring-cvs from hackage, bytestring-lexing isn't a depedency
14:36:20 <lispy> roconnor: right.  As a reason for why bytestring-lexing wasn't automatically installed
14:36:26 <ljungk> how can I construct list of []'s of length N? something like applyNtimes N ([]:) [[]]
14:36:28 <lispy> ah, not a dependency
14:36:30 <roconnor> even though it is a dependency of examples/Test.hs
14:36:42 <monochrom> > replicate 5 []
14:36:43 <lambdabot>   [[],[],[],[],[]]
14:36:48 <ljungk> ah
14:36:48 <roconnor> no one told cabal this fact
14:36:58 <lispy> roconnor: I thought you meant bytestring-lexing was not _included_ with bytestring-csv.  But you meant marked as a dependency of it
14:37:36 <roconnor> does cabal have testing fields and testing dependencies?
14:37:55 <monochrom> no
14:38:23 <ljungk> and if I want to make an infinite one? I guess I could do map (\x -> []) [1..] :)
14:38:29 <roconnor> sometimes I feel like we should just toss out cabal and use nix instead.  But that is probably a bit extreme.
14:38:32 <monochrom> > repeat p[
14:38:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:38:35 <monochrom> > repeat []
14:38:36 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
14:39:01 <ljungk> ah, this is probably very basic
14:39:01 <lispy> roconnor: actually, a GSoC student this year implemented some new testing functionality.  So those might be in an unreleased version
14:39:06 <sproingie> > take 5 $ repeat []
14:39:07 <lambdabot>   [[],[],[],[],[]]
14:39:21 <roconnor> @src replicate
14:39:21 <lambdabot> replicate n x = take n (repeat x)
14:39:26 <FunctorSalad> rename (!!) unfastPerformIndexing
14:39:28 <FunctorSalad> :\
14:39:39 <ljungk> thanks
14:40:05 <lispy> > let unsafePerformIndexing = (!!) in [1..4] `unsafePerformIndexing` 2
14:40:07 <lambdabot>   3
14:40:07 <monochrom> perhaps you paranoid people are interested in renaming fix to unsafeFix.
14:40:09 <roconnor> ljungk: btw, the implementation is essentially fix ([]:)
14:40:14 <monochrom> and haskell to unsafeHaskell
14:40:16 <roconnor> > fix ([]:)
14:40:17 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
14:40:24 <roconnor> @src repeat
14:40:24 <lambdabot> repeat x = xs where xs = x : xs
14:40:50 <roconnor> well, fix has been inlined in this definition
14:40:52 <lispy> unsafeLongestIdentifierInTheLanguageSoTherePerformIO
14:41:17 <monochrom> bloody puritan fundamentalists
14:41:46 <FunctorSalad> monochrom: actually I'm ranting about performance here
14:42:09 <monochrom> then just call it slow. there is nothing unsafe.
14:42:17 <sproingie> @src fix
14:42:17 <lambdabot> fix f = let x = f x in x
14:42:18 <FunctorSalad> parsing a record by doing "words" and the looking up each field with (!!)
14:42:31 <FunctorSalad> monochrom: I called it 'unfast'
14:42:53 <BMeph> unsafePerformEvaluationOfHaskellInAReallyDarkCorner... ;Ã¾
14:42:54 <sproingie> doublePlusUnfastPerformIO
14:44:08 <mrsolo> so is there a way to do quick benchmarking/profiling under ghci?
14:44:31 <copumpkin> :set +s :P
14:44:35 <copumpkin> that's as far as it goes though
14:45:19 <tam1138> hi!
14:46:01 <monochrom> ghci speed is misleading anyway
14:46:06 <tam1138> I'm a total Haskell noob, trying to use Data.Binary, but I can't because it's hidden (this is on Arch).  why would it be hidden?  (how) should I make it not-hidden?
14:46:26 <lispy> tam1138: are you using a .cabal file?
14:46:27 <monochrom> why would it be hidden? bad setup.
14:46:38 <lispy> tam1138: if so, did you add it to the dependencies?
14:46:55 <monochrom> but check out "ghc-pkg expose"
14:47:12 <mrsolo> monochrom, misleading in what way?
14:47:14 <tam1138> i just installed ghci from Arch
14:47:41 <tam1138> plus a few haskell packages from AUR
14:47:51 <monochrom> ghci is usually slower
14:48:13 <monochrom> ghci also keeps more in the heap
14:48:28 <mrsolo> monochrom, right i am not looking for absolute number
14:48:28 <tam1138> would installing those extra packages from AUR cause Data.Binary to become hidden?
14:48:53 <mrsolo> rather  help me to do quick and dirty comparision between two algorithms
14:49:11 <monochrom> ghci can be asymptotically different than compiled code.
14:49:14 <mauke> ghc -O2 can make a big difference
14:49:57 <tam1138> what can i read to understand the implications of exposing a hidden package?  (google didn't provide any obvious results)
14:50:31 <fxr> I couldn't find any posts or threads about the web framework salvia. I think it is very modular. any links to discussions or something?
14:50:31 <monochrom> you can import its modules without writing a .cabal file
14:50:48 <tam1138> is there a downside?
14:51:03 <sproingie> i keep reading salvia as "saliva"
14:51:41 <mrsolo> asymptotically hmm oh well so much for that
14:52:05 <monochrom> if two packages clash module names, and both are exposed, there are inconveniences
14:52:16 <tam1138> how can i find out if there are clashes?
14:52:31 <monochrom> by trying to import
14:53:23 <monochrom> I don't know of anything clashing with Data.Binary. It is unreasonable to hide. Someone did you a disservice.
14:53:52 <tam1138> thanks
14:53:58 <tam1138> i will whine to the Arch devs
14:54:47 <copumpkin> tam1138: omg
14:57:12 <monochrom> perhaps the arch devs reply back "we didn't hide it". then you will know a mysterious person hacked into your computer and hid it.
14:57:24 <monochrom> perhaps you hid it when you sleepwalked.
14:57:48 <tam1138> heh
14:57:54 <tam1138> i can try a fresh install
14:59:14 <osaunders> Does anyone know where I can find the documentation for the standard GHC libraries on a macports install of Haskell platform?
14:59:16 <roconnor> a fresh install!
14:59:18 <roconnor> ?
14:59:51 <tam1138> yes!  a fresh install!
15:00:31 <roconnor> ugh
15:00:38 <roconnor> I'm so glad I switched to nix
15:00:55 <tam1138> uh
15:00:57 <tam1138> i'm running linux
15:01:01 <tam1138> i didn't mean a fresh OS install
15:01:04 <tam1138> blech
15:01:05 <roconnor> no more random state changes when upgrading packages
15:01:14 <roconnor> tam1138: nix is a package manager
15:01:20 <roconnor> kinda a bad name I guess
15:01:21 <tam1138> ah
15:01:51 <roconnor> nix supports (only) clean builds
15:02:28 <monochrom> I am so glad I don't use distro packages for ghc and libs.
15:02:46 <roconnor> monochrom: don't you get cabal conflicts left right and center
15:02:57 <roconnor> monochrom: and eventually unresolvable clashes of dependencies?
15:02:59 <monochrom> what are cabal conflicts?
15:03:10 <Peaker> I delete my ~/.cabal and ~/.ghc and reinstall everything once in a while
15:03:14 <roconnor> I don't know.  I stoped using cabal install a year ago
15:03:33 <roconnor> People regularly pop in here with such troubles.
15:03:40 <monochrom> I cannot reproduce your problem.
15:03:44 <Peaker> I think cabal-install could be cool if someone patched GHC to add import/export signatures (and an extension to specify explicit import types)
15:03:52 <Peaker> and then cabal-install used that for dep matching
15:04:30 <monochrom> But perhaps I should tip you in. I use "user-install: False" consistently. ("True" consistently would also work.)
15:04:46 <roconnor> monochrom: the most famous example is QuickCheck 1 vs QuickCheck 2
15:05:05 <roconnor> I understand you can only have 1 installed and this divides hackage in half
15:05:07 <monochrom> All conflicts are due to: interleaving --user and --global in wrong orders; interleaving --user and distro in wrong orders.
15:05:14 <roconnor> so you can only install half of the packages on hackage
15:05:31 <c_wraith> You can have both versions of quickcheck installed
15:05:36 <roconnor> oh?
15:05:41 <c_wraith> You just can't have a package that depends on both transitively
15:05:41 <roconnor> c_wraith: what do I get with ghci?
15:06:15 <c_wraith> roconnor: standard ghci behavior.  It's like having transformers and mtl installed
15:06:28 <roconnor> c_wraith: so neither works :)
15:06:29 <jedai_> roconnor: probably Quickcheck2 (except if you hide it)
15:06:50 <c_wraith> You can't *use* both quickchecks at once, but you can have them installed at the same time.
15:08:22 <roconnor> c_wraith: if I install quicheck 1, and some other package installes a quickcheck 2 depencency, then I can no longer use quickcheck 1 in ghci like I was doing before intalling that random unrelated package?
15:08:35 <monochrom> I used to have both installed. I got no problems. I don't have both now.
15:09:06 <roconnor> monochrom: did you use ghci?
15:09:11 <monochrom> no.
15:09:14 <c_wraith> roconnor, you just need to hide the one you don't want to use at the moment.  even at the command line
15:09:23 <c_wraith> or with :set
15:09:29 <c_wraith> There are many ways to make it work
15:09:33 <roconnor> I didn't have to hide it before I installed random-unrelated pacakge
15:09:37 <c_wraith> installed doesn't mean "in scope"
15:09:44 <monochrom> I had both parsec 2 and 3. I used one of them in ghci.
15:09:49 <roconnor> monochrom: well, maybe if you don't use ghci you have no problem.
15:09:57 <c_wraith> so hide it.  hiding a package doesn't break anything.
15:10:28 <roconnor> c_wraith: when I install random package, are it's dependencies brought into scope?
15:11:09 <c_wraith> roconnor, yes.  By default, libraries that are installed are registered as visible, whether installed directly or indirectly
15:11:22 <monochrom> random doesn't depend on quickcheck
15:11:42 <roconnor> c_wraith: that is a big problem IMHO
15:12:24 <roconnor> mubangs wouldn't have had a problem if cabal didn't have such behaviour
15:12:33 <c_wraith> really, I think quickcheck is a bad example because libraries shouldn't list quickcheck in their dependencies unless they're also test frameworks that enhance quickcheck
15:13:05 <monochrom> <monochrom> I would not want packages installed just for the tests.
15:13:10 <roconnor> c_wraith: how do I add Arbitrary instances without depending on quickcheck?
15:13:22 <roconnor> anyhow
15:13:30 <roconnor> s/QuickCheck/mtl then if you feel better
15:13:41 <c_wraith> Why would you include arbitrary instances *outside* of your tests?
15:13:50 <ezyang> Does test-framework automatically attempt to shrink failed quickcheck cases? 
15:13:52 <c_wraith> But yes, saying transformers would make me happier
15:13:56 <monochrom> there are conflicts between mtl1 and mtl2?
15:13:58 <roconnor> so other people can use my data structures.
15:14:07 <roconnor> monochrom: huge conflicts
15:14:09 <roconnor> er
15:14:11 <roconnor> sorry
15:14:21 <roconnor> I was still thinking quickcheck
15:14:34 <monochrom> IMHO you should clear up your thoughts first.
15:15:08 <roconnor> in fact we can pick any package that has multiple versions.
15:15:56 <roconnor> monochrom: how do you live without ghci?
15:15:57 <monochrom> been there done that got no problems unless for example C code is included in packages.
15:16:12 <monochrom> I use ghci. I just mean I don't use quickcheck in ghci.
15:16:41 <roconnor> monochrom: do you have multiple version of any libs installed?
15:16:42 <monochrom> You are right I can't live without ghci. I even need it for adding up marks when grading.
15:16:53 <ivanm> monochrom: because your tests are perfect and don't need testing?
15:20:32 <monochrom> Please find 4 tarballs of cabalized packages in the following url, install them all, use them all, and see for yourself: http://www.vex.net/~trebla/tmp/
15:21:36 <monochrom> two versions of "watermelon". then a package that uses one version. then another package that uses the other version. then you can import both users in ghci or whatever, see what happens. (good answers happen)
15:22:41 <monochrom> In the future I expect you to give procedures and files of similar high quality for other people to reproduce problems (or lack of problems) before you insert foot into mouth.
15:22:57 <monochrom> The scientific method.
15:22:59 <roconnor> Prelude> :m + Watermellon
15:23:00 <roconnor> Could not find module `Watermellon':
15:23:02 <roconnor>   Use -v to see a list of the files searched for.
15:23:04 <dankna> spelling
15:23:06 <roconnor> ah
15:23:08 <roconnor> oops
15:23:31 <roconnor> Prelude> :m + Watermelon
15:23:33 <roconnor> module `Watermelon' is not loaded
15:24:20 <monochrom> wrong working directory?
15:24:24 <roconnor> I tried that after installing only the first watermelon package
15:24:45 <roconnor> what does working directory have to do with anything?
15:25:10 <monochrom> you don't know? change to some other directory and try again.
15:25:28 <roconnor> oh intersting
15:25:37 <monochrom> now you know
15:26:14 <osaunders> Does Haskell Platform come with documentation?
15:26:44 <monochrom> yes but not built or installed. I hacked its install script to build documentation
15:27:27 <monochrom> in scripts/install.sh : I add "./Setup haddock" before "./Setup copy"
15:27:28 <JoeyA> Is there a platform-independent function for getting the user's home directory path?
15:27:40 <JoeyA> getEnv "HOME", or is that Unix-specific?
15:27:58 <acowley> Anyone have any experience building Windows DLLs with GHC 6.12.3?
15:28:29 <monochrom> System.Directory.getHome or something
15:28:42 <ivanm> http://hackage.haskell.org/packages/archive/directory/latest/doc/html/System-Directory.html#v:getHomeDirectory
15:28:51 <JoeyA> Cool, thanks
15:28:54 <roconnor> monochrom: oh neat.  Why did this work but mubangs had trouble with mtl / transformers ?
15:29:12 <monochrom> I don't know mubangs.
15:30:19 <JoeyA> Does seq x x ever make sense?
15:30:31 <roconnor> JoeyA: never
15:30:32 <monochrom> no
15:30:48 <roconnor> JoeyA: it is surprisingly common for something that doesn't do anything
15:30:54 <roconnor> people misunderstand seq
15:31:19 <monochrom> perhaps the right word is "redundant"
15:31:27 <Axman6> all seq a b says is that if b is evaluated, then a will be evaluated before b
15:31:28 <JoeyA> I guess because seq x y means "strictly evaluate x *when we evaluate y*".  Is that correct?
15:31:34 <JoeyA> oh, okay
15:31:40 <monadic_kid> i've read a version of bitc is comging out quite soon
15:31:52 <copumpkin> Axman6: it doesn't even mean before, really
15:31:59 <monochrom> "evaluate x before evaluate x" is harmless but tautological
15:32:34 * BMeph edits monochrom's statement: perhaps the right word is "asinine" ...FTFY! ;)
15:32:36 <monochrom> or "strictness depends on x when strictness depends on x"
15:32:40 <roconnor> technically before isn't part of the semantics of seq, only of pseq
15:33:08 <roconnor> seq x y can evaluate y first then x.
15:33:45 <roconnor> monochrom: thanks for the cabal lesson
15:34:51 <JoeyA> Is this a safe way to ensure that Data.CryptoHash.SHA1's hash value is fully computed before returning it from an action?  http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29492
15:35:03 <monochrom> We both should thank Saizan. He insisted "can coexist". Then I constructed this example.
15:35:23 <JoeyA> Without the seq, it opens a bunch of file handles and crashes the program with openBinaryFile: resource exhausted (Too many open files)
15:35:27 <Axman6> JoeyA: what's the type of hash?
15:35:33 <monochrom> (I was hoping to construct this example to refute. Evidently it confirms instead. Scientific method triumphs.)
15:35:33 <Axman6> ah bytestring
15:35:44 <Axman6> that should do it i think
15:35:48 <JoeyA> Well, it's yielding a strict ByteString from a lazy ByteString
15:35:51 <roconnor> @hoogle evalutate
15:35:51 <c_wraith> looks right to me
15:35:51 <lambdabot> No results found
15:35:55 <roconnor> @hoogle eval
15:35:56 <lambdabot> Control.Monad.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
15:35:56 <lambdabot> Control.Monad.RWS.Strict evalRWS :: RWS r w s a -> r -> s -> (a, w)
15:35:56 <lambdabot> Control.Monad.RWS.Lazy evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
15:35:58 <roconnor> @hoogle evaluate
15:35:59 <lambdabot> Control.Exception evaluate :: a -> IO a
15:35:59 <lambdabot> Control.OldException evaluate :: a -> IO a
15:35:59 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
15:36:03 <JoeyA> It seems like SHA1.hashlazy should strictly perform it, but it doesn't.
15:36:11 <roconnor> JoeyA: use Control.Exception.evaluate
15:36:18 <roconnor> that's what it is for
15:36:21 <bos> JoeyA: you could use "return $!" instead of seq then return
15:36:23 <roconnor> (assuming hash is strict
15:36:28 <JoeyA> ah
15:36:32 <Axman6> @src ($!)
15:36:33 <lambdabot> f $! x = x `seq` f x
15:36:58 <JoeyA> seq hash $ return hash does work, but it seems scary to have the seq outside of the return.
15:37:10 <c_wraith> the seq needs to be outside the return
15:37:12 <Axman6> just use return $! hash
15:37:12 <bos> why does it seem scary?
15:37:13 <c_wraith> because return is lazy
15:37:32 <c_wraith> if the seq isn't outside the return, it won't help with anything
15:37:34 <JoeyA> It looks like it's outside of the monad
15:37:38 <bos> more precisely, return doesn't evaluate its argument
15:37:50 <roconnor> JoeyA: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29492#a29493
15:37:50 <c_wraith> err, yes, I should say return is non-strict
15:38:02 <bos> JoeyA: that's because you're thinking of what return does incorrectly :-)
15:38:10 <roconnor> don't listen to Axman6, use evaluate
15:38:22 <c_wraith> roconnor, I think using evaluate is inappropriate when your goal isn't to catch exceptions
15:38:26 <JoeyA> It looks like uttering sha1File "foo/bar.txt" could end up performing the hash even when the action is not chained to main.
15:38:38 <roconnor> c_wraith: is that why it is in Exception?
15:38:42 <c_wraith> roconnor, yes
15:38:46 <roconnor> okay
15:38:50 <roconnor> I think you are wrong though
15:38:56 <roconnor> I'd totally use evaluate here still
15:39:12 <c_wraith> evaluate introduces IO
15:39:21 <roconnor> he is already in IO!
15:39:34 <JoeyA> Indeed.  I'm using it to work around laziness that IO caused.
15:39:35 <roconnor> it's perfect
15:39:41 <c_wraith> For a process that, unless you're catching exceptions, isn't semantically part of IO.
15:39:41 <JoeyA> If IO got me into this mess, than IO can get me out :-)
15:39:42 <djahandarie> Trapped in IO
15:40:03 <monochrom> in IO, "evaluate" and "return $!" are "different", sure, but they overlap alot. you probably are in the overlap.
15:40:23 <monochrom> I think people overblow the difference.
15:40:34 <roconnor> monochrom: what is the difference? 
15:41:05 <c_wraith> I just don't think evaluate is appropriate unless you actually intend to cause and handle imprecise exceptions
15:41:07 <roconnor> other than that $! doesn't guarentee evaluation order and just happens to work this way in GHC?
15:41:20 <c_wraith> $! is guaranteed to work right.
15:41:21 <monochrom> the difference is so subtle I don't remember. the doc has an example. but see that you seldom do what the example does anyway.
15:41:24 <roconnor> c_wraith: no it isn't
15:41:35 <c_wraith> Yes, it is.
15:41:45 <roconnor> c_wraith: you need to use pseq to guarentee evaluation order
15:41:51 <roconnor> c_wraith: seq x y can evaluate y before x.
15:41:52 <JoeyA> Anyway, thanks for telling me about evaluate
15:41:54 <c_wraith> you don't need evaluation order
15:41:57 <roconnor> that's why pseq exists.
15:42:04 <c_wraith> or rather, it doesn't matter
15:42:08 <roconnor> oh
15:42:11 <roconnor> maybe you are right here
15:42:16 <roconnor> anyhow
15:42:20 <JoeyA> Wait, why can seq x y evaluate y before x?
15:42:21 <c_wraith> (x `seq` return x) >>= whatever
15:42:29 <JoeyA> I thought the point of seq was to evaluate x before y.
15:42:32 <mauke> JoeyA: why not?
15:42:45 <roconnor> JoeyA: seq only guarentess that the result is bottom of x is bottom
15:42:48 <c_wraith> using seq or pseq, x *will* be evaluated before whatever, in that case.
15:43:04 <c_wraith> And that's all code that uses "return $!" usually cares about
15:43:19 <monochrom> If you go by Haskell98 and no more, you only know strictness, not order. That is why. seq only plays with strictness. Could be implemented by different orders.
15:43:51 <roconnor> JoeyA: one possible impleemenat of seq is to first evalyate y, if it is non-bottom, then evaluate x, if it is non-bottom return y.
15:43:55 <c_wraith> well, unless you have an implementation of >>= that's so lazy that it doesn't even examine its first argument.
15:44:03 <monochrom> But in practice, who is the creative pervert who pulls your leg? Show me!
15:45:24 <c_wraith> I guess lazy state doesn't examine its first argument in >>=
15:45:46 <c_wraith> So there are some monads lazy enough that "return $!" doesn't do exactly what you'd expect.
15:45:59 <monochrom> Everything you say "isn't guaranteed" about seq also holds for, for example, http://hackage.haskell.org/package/strict/ .
15:46:43 <monochrom> The logical conclusion is that that package is useless.
15:47:52 <monochrom> People overblow the distant plausibility that "some vapourware compiler may does it differently"
15:48:07 <JoeyA> For anyone who cares' benefit, evaluate $ Just $ SHA1.hashlazy contents does NOT coerce the hash; it just coerces the Just, which doesn't need it.
15:48:33 <JoeyA> Instead, use Just <$> (evaluate $ SHA1.hashlazy contents) , as it works
15:48:36 <c_wraith> JoeyA, indeed.  seq only evaluates to WHNF.
15:48:57 <c_wraith> and evaluate is written in terms of seq
15:49:50 <JoeyA> I don't think I fully grok WHNF, but I get the idea that it only strictly evaluates the topmost expression, so I correctly inferred that evaluate $ Just $ SHA1.hashlazy contents would not work.
15:50:03 <JoeyA> (by work, I mean force evaluation of the hash)
15:50:04 <c_wraith> That it works as well as it does for you is because you're return a strict bytestring
15:50:12 <monochrom> the topmost data constructor, yeah
15:50:26 <c_wraith> and for strict bytestrings, forcing the topmost data constructor is sufficient to force the whole thing.
15:50:34 <monochrom> or for many standard data types like bool and int, the actual value
15:50:38 <c_wraith> That's not true of something like a string, for instance.
15:50:47 <ezyang> If my Haskell program hangs, what's a good way of figuring out where it hung? 
15:51:12 <Saizan> monochrom: ghc itself will compile code that uses seq to something that evaluates in the less expected order sometimes, though
15:51:13 <monochrom> if it's full of IO, you can insert from logging
15:51:50 <monochrom> oh fun. but I guess "evaluate soon enough, I just want to save memory" is good enough.
15:52:29 <Saizan> yeah, in e.g. foldl' you just need the strictness hint for ghc to figure out the rest
15:53:08 <monochrom> I should not have called Saizan's to cause him to refute me again. :)
15:53:20 <monochrom> s/to/name to/
15:53:55 <monochrom> anyway, if there is little IO, or if you think "debugging printfs are so passe", use ghci debugger.
15:54:28 <monochrom> my personal approach is write in small pieces and almost prove correctness of each piece.
15:54:31 <c_wraith> I personally think Debug.Trace is occasionally useful.
15:54:49 <c_wraith> I haven't used it often, but sometimes it's invaluable to find my boneheaded mistakes
15:55:29 <monochrom> I used to use it when I was less mature.
15:56:11 <Ke> monochrom: the las I heard ghci debugger does not support debugging real programs
15:56:25 <Ke> ie. ones using cabal
15:56:29 <iocor> what's a fast way to produce a list that contains only "Data 'a'" monads that is 4 times as long as a passed list "ponies"
15:56:42 <monadic_kid> bit of a strange langauge: http://tachyon.in/clay/
15:57:00 <c_wraith> iocor, that's a very confusingly phrased question.  some kind of homework problem?
15:57:17 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29494
15:57:24 <int80_h> dons might want to look at this
15:57:36 <iocor> c_wraith, no, this is  me just hacking
15:59:32 <c_wraith> iocor, well, the question is very unclear.  I really don't know what you mean.
16:00:19 <iocor> c_wraith, so I have this list full of stuff ["a", "cows", "cheese"] for example, and I want to replace each item with 4 `Data 'a'` types
16:01:38 <monochrom> but which values of `Data 'a'` types?
16:01:43 <c_wraith> That's still really vague.  what does "4 `Data 'a'` types" mean?
16:01:57 <iocor> never mind
16:02:00 <c_wraith> What's the type signature of the function you want to write?
16:02:04 <monochrom> I mean you may as well say "replace by 4 numbers". which numbers would you like? 0? 1000?
16:02:17 <iocor> [String] -> [Data]
16:02:27 <iocor> Data = Data Char deriving (Show, Read, Eq)
16:02:44 <c_wraith> and what do you mean by 4 of them?
16:02:48 <mtnviewmark> or is it [a] -> [Data a]?
16:02:50 <c_wraith> That isn't really clear?
16:03:22 <c_wraith> Should the length of the output list be the same as the length of the input list?  Should it be 4 times as long?
16:03:41 <iocor> c_wraith, 4x as long
16:03:58 <mtnviewmark> would this be an example?  [7, 2] -> [Data 7, Data 7, Data 7, Data 7, Data 2, Data 2, Data 2, Data 2]
16:04:09 <c_wraith> So, you don't actually care what the input list contains, just how long it is?
16:04:15 <iocor> c_wraith, yes
16:04:24 <mtnviewmark> or this? [7, 2] -> [Data 7, Data 2, Data 7, Data 2, Data 7, Data 2, Data 7, Data 2]
16:04:46 <iocor> [7,2] -> [Data 'a',Data 'a',Data 'a',Data 'a',Data 'a',Data 'a',Data 'a',Data 'a']
16:05:11 <monochrom> concatMap
16:06:03 <mtnviewmark> uhm, really?  [Data Char] is the return type?
16:06:06 <c_wraith> > let {f x = let {l = length x} in take (4 * l) $ repeat 5} in f ["one", "two"]
16:06:07 <lambdabot>   [5,5,5,5,5,5,5,5]
16:06:21 <monochrom> there is much correlation between "can't describe problem" and "can't write program".
16:06:23 <c_wraith> mtnviewmark, Data is the return type.  It doesn't have a type variable
16:06:36 <int80_h> monochrom : I can testify to that.
16:06:38 <mtnviewmark> what is    Data 'a' then?
16:06:46 <c_wraith> he listed it above
16:06:51 <c_wraith> "data Data = Data Char"
16:07:28 <c_wraith> with a deriving clause, but that's not important for this part
16:07:29 <monochrom> too many datas :)
16:07:30 <mtnviewmark> let f x = concatMap (const $ replicate 4 42) in f ["one", "two"]
16:07:38 <mtnviewmark> > let f x = concatMap (const $ replicate 4 42) in f ["one", "two"]
16:07:38 <lambdabot>   Overlapping instances for GHC.Show.Show ([b] -> [t])
16:07:39 <lambdabot>    arising from a use ...
16:07:47 <monochrom> is "data" a reserved word?
16:08:18 <chrisdone> should be
16:08:23 <monochrom> oops, yes, can't pull "data Data data= Data data" tricks
16:08:35 <chrisdone> > let data = 1 in undefined
16:08:36 <lambdabot>   <no location info>: parse error on input `data'
16:08:47 <monochrom> data Data daTa = Data daTa
16:08:51 <chrisdone> ew
16:08:55 <chrisdone> data Data data' = Data data'
16:08:56 <c_wraith> ouch, my eyes
16:09:33 <monochrom> if you think it hurts, you haven't tried PL/I. if if=then then then=else else else=if
16:10:07 <blackdog> monochrom: they're just variables, then?
16:10:11 <monochrom> yes
16:10:16 <monochrom> sometimes
16:12:18 <kmc> > let lÐµt = lÐµt in Ñ–n
16:12:19 <lambdabot>   Yes sir!
16:12:27 <c_wraith> what?
16:12:37 <c_wraith> > in
16:12:38 <lambdabot>   <no location info>: parse error on input `in'
16:13:28 <monochrom> lambdabot is full of surprises.
16:14:05 <yescalona> @karma 
16:14:05 <lambdabot> You have a karma of 0
16:14:11 <yescalona> @karma python
16:14:12 <lambdabot> python has a karma of 0
16:20:26 <mtnviewmark> or the Tristan Tzara version:  data Dada dada = Dada dada
16:21:27 <mtnviewmark> > let f = concatMap (const $ replicate 4 42) in f ["one", "two"]
16:21:28 <lambdabot>   [42,42,42,42,42,42,42,42]
16:22:03 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29494
16:23:12 <JoeyA> How good is GHC at garbage collecting?  Namely, if you use mallocForeignPtr to allocate a block, then end up not returning it, will GHC add a compiled free, or will it linger until it's garbage collected?
16:29:14 <int80_h> :t readDouble
16:29:14 <lambdabot> Not in scope: `readDouble'
16:29:39 <int80_h> :t Data.ByteString.readDouble
16:29:40 <lambdabot> Not in scope: `Data.ByteString.readDouble'
16:29:47 <int80_h> @hoogle readDouble
16:29:47 <lambdabot> No results found
16:30:31 <int80_h> why would I want to use ByteString instead of a String?
16:30:35 <mtnviewmark> int80_h: are you trying to read an IEEE 754 double to/from ByteString?
16:31:19 <int80_h> mtnviewmark: I'm trying to understand the test code from dons Text.CSV.ByteString, and perhaps fix it.
16:31:29 <mtnviewmark> ah
16:32:11 <int80_h> but I don't know why one would use a ByteString over a String. Is it a matter of I/O efficiency?
16:33:45 <c_wraith> It's a matter of working with bytes, rather than characters.
16:33:55 <c_wraith> You can't represent an image as a list of characters.
16:33:59 <c_wraith> Or any other binary data
16:34:35 <c_wraith> IO *is* more efficient, because it doesn't require any conversion, but really.  bytes and characters aren't the same.  don't interchange them. they're not interchangeable
16:35:13 <int80_h> http://hackage.haskell.org/packages/archive/bytestring-csv/0.1.2/doc/html/Text-CSV-ByteString.html
16:35:42 <int80_h> okay, but why then does this package use bytestrings to parse cvs formatted data then?
16:35:57 <c_wraith> cvs isn't really text
16:36:00 <int80_h> if ByteStrings and Strings are nto interchangeable?
16:36:07 <c_wraith> err, csv
16:36:07 <int80_h> hmm
16:36:07 <pikhq> int80_h: Are you even vaguely familiar with C?
16:36:25 <int80_h> pikhq: vaguely is a good way to describe my familiarity, yes.
16:36:35 <c_wraith> When I say text, I mean things you intend to manipulate *as text*.
16:37:02 <c_wraith> a CSV file, you generally see as a container for lots of fields, in a tabular format.
16:37:10 <c_wraith> those individual fields might contain text
16:37:13 <pikhq> int80_h: ByteStrings are a C char*. Strings are something like struct list {unicode_code_point_t data;struct list *next;}.
16:37:14 <c_wraith> or they might contain numbers
16:37:18 <c_wraith> Or some other things.
16:37:35 <c_wraith> So it makes sense to treat a CSV file as bytes, at least on the initial pass.
16:37:38 <int80_h> pikhq: that was a good way to describe it for me. Thanks :)
16:39:01 <pikhq> (the bit about ByteStrings being char* isn't even analogy. It really is a char* with some wrapping to make it work with the language runtime.)
16:39:22 <int80_h> c_wraith, care to look at this test program that comes with text.csv.bytestring? It doesn't do anything. I figure getting it to work would make a good patch submission and help me understand better.
16:39:59 <c_wraith> int80_h, Not right now.  Too much other stuff going on
16:40:03 <int80_h> no worries
16:40:15 <int80_h> pikhq: how about you?
16:41:51 <Saizan> pikhq: it also has length and offset fields
16:42:20 <kmc> int80_h, String is simple, lazy, and character-based.  ByteString is fast, memory-efficient, and byte-based
16:42:40 <kmc> there's also the "text" library if you want ByteString performance but on characters rather than bytes
16:42:48 <kmc> and even more options
16:42:52 <kmc> ezyang had a blog post about the options recently
16:43:02 <int80_h> have the url?
16:43:04 <pikhq> Saizan: Oh, yes, it's also got what'd be micromanaged in C.
16:44:59 <int80_h> kmc: I'm not looking for performance gain in particular. I'm writing a tutorial for Takusen at the requesy of lispy. It's gotten out of hand as now I'm looking to create a model of how it may actually be used, which means in concert with other libraries. I was doing my own parsing, but dons suggested I use  test.csv.bytestring
16:46:24 <int80_h> and this is a little above my skill level, as the only documentation is the source, and a test program that doesn't do anything
16:47:17 <int80_h> kmc: but if you have a url to that blog entry I'd like to read it.
16:47:47 <kmc> http://blog.ezyang.com/2010/08/strings-in-haskell/
16:48:29 <kmc> also if you're not familiar with bytes vs. characters, encodings, and the like, (and can stand joel spolsky) there's http://www.joelonsoftware.com/articles/Unicode.html
17:00:59 <kmc> :t Ñ–n
17:01:00 <lambdabot> parse error on input `??'
17:09:02 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29494
17:19:26 <kmc> int80_h, you should have type signatures on your top-level  bindings
17:19:31 <kmc> especially Â«main :: IO ()Â»
17:19:47 <kmc> it is easy to accidentally write main of type IO (IO ()) or such
17:19:53 <int80_h> kmc: this isn't my code, it's dons
17:20:01 <int80_h> I'm just trying to get it to work
17:20:02 <kmc> oh :/
17:20:06 <int80_h> or do something
17:20:07 <kmc> dons should do what i say ;P
17:20:16 <kmc> ;)
17:20:48 <int80_h> kmc: so when it gets a file it can read, it just ends
17:21:00 <int80_h> any idea on how to get it to print whatever it's supposed to be printing?
17:21:23 <Igloo> Printing nothing looks like the right behaviour to me
17:21:40 <Igloo> It only prints something for lines with 6 fields, and that data has more than 6 fields per line
17:21:50 <int80_h> hmm, I need to paste something then. I gues I don't understand what is supposed to be happening
17:22:00 <int80_h> oooh
17:22:07 <Igloo> You want data of the format in the comment
17:22:16 <kmc> Â«[_,a,b,_,c,d] <- csvÂ»
17:22:44 <kmc> this pattern will only match 6-field rows
17:22:52 <kmc> and will discard the rest (because it's a list comprehension)
17:24:23 <int80_h> ah, now it's clear
17:24:34 <int80_h> now I can maybe do something with this
17:33:09 <greap> Is there a way to break lines in source? For example, split a 300 digit number over multiple lines.
17:33:38 <roconnor> does \<cr> work inside tokens?
17:33:47 <roconnor> wait
17:33:51 <roconnor> that isn't haskell is it
17:33:52 <roconnor> :(
17:34:30 <Zao> > 12345 * 10^5 + 67890 -- look ma, breaking numbers :D
17:34:31 <lambdabot>   1234567890
17:34:34 <kmc> hack it using string syntax
17:34:41 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29496#a29496
17:34:47 <Zao> Or a string with some concat and show, of course.
17:34:52 <Zao> Err, read.
17:36:03 <kmc> ho ho ho, \ as a line continuation works if you enable CPP: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29497#a29497
17:36:13 <kmc> i am growing more and more fond of CPP in a perverse way
17:36:19 <greap> kmc: haha nice
17:36:53 <kmc> it solves a particular niche of quick and dirty metaprogramming, which is frequently needed in Haskell, and for which TH is overkill
17:37:01 <kmc> sometimes the CPP solution is far simpler
17:38:08 <Pseudonym> I've tried to learn TH a few times, but I've never really "gotten" it.
17:38:17 <Pseudonym> I mean, I "get" it.
17:38:27 <Pseudonym> But it doesn't seem to hit that sweet spot.
17:38:44 <kmc> yeah
17:38:54 <kmc> it is a cumbersome tool
17:39:21 <Pseudonym> Haskell is beautiful and pretty, TH is downright clunky by comparison.
17:39:30 <kmc> Haskell has its warts, too
17:39:33 <kmc> but i agree with the comparison
17:39:47 <Pseudonym> I don't mind CPP because the level of clunkiness is on par with C.
17:39:57 <Pseudonym> That's really twisted when I think about it.
17:40:10 <sproingie> low expectations
17:40:18 <Pseudonym> I guess so, yeah.
17:40:42 <kmc> there's no sweet spot for TH.  it's a tool of last resort, never feels like the right way to do anything
17:40:42 <doofer> you just said that to make me curious when I came in, didn't you?
17:40:47 <kmc> haha
17:41:16 <kmc> we should devise a simple string preprocessor which is a little nicer than CPP
17:41:21 <kmc> implement it in Haskell and make it standard
17:41:26 <Pseudonym> m4
17:41:38 <kmc> m4 is not simple ;P
17:41:42 <Pseudonym> True.
17:41:46 <Pseudonym> But it's a little nicer than CPP.
17:41:48 <kmc> CPP is *almost* what you want
17:42:16 <kmc> what about CPP with the ability to plug in arbitrary functions of type (String -> IO String)?
17:42:33 <Pseudonym> ML staged compilation is pretty nice.
17:42:51 <kmc> so you can do more complicated munging in Haskell, but avoid a full AST representation if that's not warranted
17:42:58 <kmc> anyway
17:43:02 <kmc> Haskell can be pretty boilerplatey
17:43:13 <kmc> it's not obvious to the C++ and Java refugees because their standards are absurdly low
17:43:14 <geheimdienst> there it goes. "we just need a simple string preprocessor. let's just add ifs and loops. and functions. and arithmetic." boom, we got a monstrous dibblywoggle like bash
17:43:15 <geheimdienst> ;)
17:43:30 <kmc> geheimdienst, that's why i jump to the logical conclusion and embed Haskell ;)
17:43:55 <kmc> Haskell does pretty well for a very static language but still, there's a need to repeat yourself that preprocessing can help with
17:43:59 <geheimdienst> kmc, good thinking
17:44:00 <Pseudonym> I have to say, though, type families removed one of the reasons why I thought I needed TH.
17:44:16 <kmc> which?
17:44:23 <nniro> would it be possible to expand a list so its elements are passed as arguments to a function, directly?
17:44:32 <FunctorSalad> hmm does compiling with more cost centers (-auto < -auto-all < -caf-all) distort the results more compared to the optimized version?
17:44:38 <FunctorSalad> the prof results
17:44:46 <Pseudonym> If you have a polymorphic data type, you sometimes want to optimise the representation depending on which type you instantiate it with.
17:44:53 <FunctorSalad> since apparently it prevents elimination of functions? (?)
17:44:59 <geheimdienst> on that general topic, i wrote "f, g, h :: Int -> Blah". but that doesn't sit well with haddock. it appears that comments only work when they precede the function type, not the function declaration
17:45:05 <Zao> nniro: Something like frobnicate f [1,2,3] becomes  f 1 2 3?
17:45:22 <nniro> Zao: yes
17:45:25 <geheimdienst> any way around this? i don't want to repeat the same gunk type lots of times
17:45:30 <Zao> No idea, but it sounds a bit unlikely.
17:45:37 <doofer> nniro, you can use Data.Dynamic for witchcraft like that
17:45:42 <FunctorSalad> geheimdienst: -XCPP
17:45:42 <FunctorSalad> ;)
17:45:55 <nniro> doofer: cool thanks, I'll look at it
17:45:56 <Zao> As if you recurse, the type of the partially applied "function" will change for each step.
17:46:03 <geheimdienst> gna gna gna
17:46:04 <FunctorSalad> assuming CPP is actually ran before haddock
17:46:08 <FunctorSalad> lol
17:46:34 <geheimdienst> :)
17:46:37 <Pseudonym> geheimdienst: You could use a typedef.
17:47:07 <kmc> nniro, it's an unusual thing to want.  your function needs a special type that can't really be achieved, and can be hacked with type classes
17:47:12 <geheimdienst> pseudonym, hm okay, maybe i'll do that
17:47:21 <kmc> nniro, why do you want to do this?
17:47:25 <Pseudonym> Not a great idea.  Better to fix the bug in haddock.
17:47:27 <FunctorSalad> SIG(f) SIG(g) SIG(h) ;)
17:47:42 <kmc> nniro, http://okmij.org/ftp/Haskell/polyvariadic.html#polyvar-fn
17:48:28 <kmc> @quote among.types
17:48:29 <lambdabot> ski_ says: unique among types, 'Void -> X' has its own charm. tourists should definitly pay a visit.
17:48:32 <kmc> damn
17:48:32 <kmc> @quote among.types
17:48:33 <lambdabot> ski_ says: unique among types, 'Void -> X' has its own charm. tourists should definitly pay a visit.
17:48:37 <nniro> kmc: actually I'm implementing a simple extreme programming method which is to create tests for functions (like for certain arguments, certain results are expected)
17:48:44 <kmc> @quote Oleg.Kiselyov
17:48:45 <lambdabot> bartek says: It took me 2 years of studying teachings of Oleg Kiselyov (who was raised among types, where he learned to speak their language), but finally, I have the solution.
17:48:54 <kmc> nniro, did you look at QuickCheck?
17:49:09 <kmc> Haskell has a number of testing frameworks
17:49:11 <kmc> RWH discusses some of them
17:49:13 <kmc> @where RWH
17:49:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:49:16 <kmc> (free to read online)
17:49:36 <doofer> kmc, nniro: it has its uses, I used it recently in a project, where there was a typed representation of the data, which was substituted by one which was easier to work with... so the types were guaranteed from earlier
17:50:09 <doofer> of course, I could have kept the typed representation...
17:50:25 <nniro> kmc: I've had a lot of trouble getting quickcheck to compile correctly... and I thought it could only work for functions in the IO monad
17:50:30 <kmc> nniro, definitely not
17:50:47 <kmc> it's mostly designed to check input vs. output on pure functions
17:51:03 <kmc> (functions returning IO actions are pure too, but the return value is something opaque that you can't compare to other things)
17:51:12 <roconnor> quickcheck kinda doesn't work for functions returning IO 
17:51:14 <kmc> quickcheck comes with Haskell Platform doesn't it?
17:51:21 <nniro> ah
17:51:27 <kmc> http://book.realworldhaskell.org/read/testing-and-quality-assurance.html
17:51:28 <nniro> well I compiled ghc myself, that's why eheh
17:51:34 <kmc> nniro, install Haskell Platform
17:51:36 <roconnor> nniro: good for you
17:51:46 <roconnor> Haskell Platform is the plague
17:51:53 <nniro> ahah
17:52:03 <kmc> i saw Haskell Platform save a burning kitten from a tree
17:52:34 <roconnor> kmc: HP put the kitty in the tree and set the tree on fire in order to stage the rescue
17:52:38 <geheimdienst> also, saw it save a tree form burning
17:54:53 <dibblego> roconnor, what is your objection to HP?
17:55:26 <roconnor> [16:31] <BMeph> mrsolo: For the same reason legacy systems preserve flaws: people have incorporated the flawed code function into their own code, so that it'll break with "right: code, and they bitch long and loudly if anyone threatens to "fix" it. ;)
17:55:38 <roconnor> er
17:55:47 <roconnor> maybe that doesn't entirely make sense out of context
17:55:53 <FunctorSalad> will this actually DWIM? "evaluate (img `using` rnf)"
17:56:00 <FunctorSalad> for benchmarking
17:56:01 <roconnor> HP preserves flaws.
17:56:08 <nniro> kmc: I prefer to compile my own version of ghc and packages, I don't really like binary distributions
17:56:12 <FunctorSalad> img :: some recursive ADT
17:56:21 <kmc> nniro, ok.  then get quickcheck and some compatible versions of its dependencies
17:56:24 <roconnor> nniro: what distro are you using?
17:56:31 <nniro> free software/open source give us this pleasure, so I take it :)
17:56:35 <kmc> FunctorSalad, probably.  how do i know WYM?
17:56:58 <nniro> roconnor: my own actually, based vaguely on slackware and on linux from scratch
17:56:59 <kmc> (img `using` rnf) will return () after evaluating img fully (assuming reasonable NFData instances)
17:57:04 <FunctorSalad> "fully" forcing the img
17:57:10 <FunctorSalad> yes
17:57:26 <roconnor> nniro: have you seen nixos?
17:57:35 <nniro> roconnor: not yet :)
17:57:40 <roconnor> it's awesome
17:57:58 * roconnor evangalizes
17:58:24 * nniro checking infos on nixos
17:58:35 <geheimdienst> can i put function types into the module export list? or something? i'm uneasy about repeating the function name in the export list, then in the type declaration, then again in the definition. especially for tiny one-liner functions
17:59:15 * kmc reprises earlier statement about boilerplate
17:59:18 <nniro> roconnor: I can't stand package managers, that's why I did my own ahah
17:59:36 <roconnor> nniro: that's because they all suck.  nix is different
17:59:39 <roconnor> it doesn't suck
17:59:43 <nniro> I even made a tool in haskell to track what packages I have on my system
17:59:44 <geheimdienst> kmc, yeah that's how i remembered i wanted to ask this
17:59:47 <kmc> haha
18:00:07 <nniro> s/packages/softwares
18:00:19 <roconnor> nniro: :D
18:00:24 <kmc> nixos looks really cool, anyone here use it regularly?
18:00:37 <roconnor> I do
18:00:45 <roconnor> I've been using it for 10 months or so
18:01:15 <kmc> can i run urxvt, chromium, pidgin, xchat, and ghc?
18:01:34 <roconnor> kmc: is that a nix question?
18:01:34 <nniro> roconnor: if you want to try it :   http://git.neuroponic.com/swmng.git/    you can download a snapshot, it's on the right of commits
18:01:42 <kmc> yeah.  does it support this set of packages
18:02:06 <FunctorSalad> meh I can't derive NFData because the ctors aren't in scope
18:02:10 <djahandarie> Ooh neat, it uses Haskell for its package manager
18:02:19 <FunctorSalad> (not exported)
18:02:54 <roconnor> kmc:  pidgin, xchat, and ghc are all packaged
18:03:24 <roconnor> the other two are not packaged under those names at least.
18:05:01 <djahandarie> urxvt is probably rxvt
18:05:11 <djahandarie> chromium is probably not packaged if it isn't under chromium
18:05:34 <roconnor> rxvt is packaged
18:05:41 <FunctorSalad> oh god it uses haskell?
18:05:44 <FunctorSalad> :D
18:06:02 <roconnor> what uses haskell?
18:06:08 <djahandarie> Nix
18:06:24 <roconnor> Nix is not written in Haskell.  I think it is written in C or maybe C++
18:06:41 <djahandarie> oh
18:06:43 <djahandarie> You're right
18:06:59 <djahandarie> They just said purely functional and Haskell in like the second sentence
18:07:07 <djahandarie> How decieving
18:07:09 <roconnor> yes
18:07:24 <roconnor> kmc: is chormium the google browser?
18:08:07 <roconnor> oh here it is
18:08:13 <roconnor> I don't know what I didn't find it before
18:08:58 <geheimdienst> we should make something like nixos for cabal. cabal packages break quite often when upgrading a dependency ...
18:09:03 <roconnor> it is named chrome for some reason
18:09:31 <roconnor> geheimdienst: there is this hack-nix thingy for converting cabal stuff to nix expressions.  I'm not sure how it works.
18:09:50 <roconnor> geheimdienst: monochrom says that cabal pacakges don't break.
18:10:20 <nniro> it seems like the nixOS requires a great deal of coding/scripting for each packages by the package maintainers
18:10:22 <roconnor> you guys should duke it out and come to a conclusion.
18:10:26 <djahandarie> roconnor, chrome is the Google version of chromium
18:10:56 <roconnor> nniro: I've found it very easy to package software.
18:11:13 <djahandarie> roconnor, are you the nixos Haskell maintainer? ;)
18:11:18 <roconnor> nope
18:11:55 <geheimdienst> i dunno, on my system, there always seems to be some snafu where something depends on x-0.1 while something else depends on x-0.2, which causes breakage. and the last cabal update somehow made half my cabal packages evaporate ...
18:12:13 <roconnor> if all it takes to build a piece of software is configure; make; make install, then you don't have to write much beyond the name of the package and its source URL.
18:12:15 <nniro> roconnor: well if the totallity of the configurations needed for x packages needs to be converted to their version, that ought to be, perhaps easy, but pretty long, ahah
18:12:39 <roconnor> nniro: how do you mean? 
18:12:45 * roconnor hasn't looked at the x packages
18:13:02 <nniro> roconnor: x as in any package, none in particular
18:13:16 <roconnor> oh
18:13:36 <roconnor> ya, well for many packages there is 1 configuration
18:14:00 <roconnor> but it is true, if there are multiple configurations it is upto the packager to parameterize them all
18:14:04 <nniro> yes but they need to go through the specific configuration for a package and convert it to their own version of that configuration
18:14:06 <roconnor> or at least as many as they care to.
18:14:44 <roconnor> nniro: usually ./configure does all the needed configuration
18:14:49 <roconnor> for simple applications
18:15:42 <nniro> roconnor: I didn't mean the compilation process, I meant configuration like /etc/fstab
18:16:05 <nniro> roconnor: like for grub, they gave the example :  boot.loader.grub.device = "/dev/sda";
18:16:18 <roconnor> oh, that is different.  Ya, system configuration is done by nixos.
18:17:02 <nniro> roconnor: this means that the package manager had to go through the configuration for grub and create a nixos version of that configuration ;P
18:17:04 <roconnor> making system configuration modules for nixos is harder than packaging software for nix
18:17:40 <roconnor> nniro: well, to the extent they are willing to.  NixOS may provide a narrow interface than available because no one has bothered to make a full interface.
18:18:20 <nniro> :)
18:18:21 <roconnor> but so far I have found enough hooks to insert arbitrary strings of text to do what I please
18:18:27 <roconnor> e.g. encrypted root
18:20:41 <nniro> roconnor: oh yeah, the idea of a single configuration file for the whole system is a good one
18:22:59 <nniro> it's a little like having your whole system in a git/darcs repository :)
18:23:10 <roconnor> not exactly unfortuantely
18:23:50 <roconnor> you need to include the nix expressions found in the nix packages as well
18:24:14 <roconnor> and techinically you also need the downloaded source code those expressions use.
18:24:21 <roconnor> but still
18:25:58 <nniro> thinking about it, source code management systems are like functional file systems
18:26:11 <roconnor> ideally I guess
18:26:17 <geheimdienst> write-only
18:26:47 <geheimdienst> i mean, immutable. once something's written, can't be changed
18:26:54 <roconnor> yes
18:27:08 <nniro> yes and as far as I know, that's what functionnal programming is all about :)
18:29:18 <roconnor> at least it is what FP should be about
18:38:32 <nniro> oh also, is there a function in haskell to convert a string to an integer? like convert "200" to 200
18:38:48 <dibblego> @type (read, reads)
18:38:49 <lambdabot> forall a a1. (Read a, Read a1) => (String -> a, String -> [(a1, String)])
18:38:59 <geheimdienst> > (read "200") :: Int
18:39:00 <lambdabot>   200
18:39:20 <nniro> ah thanks :)
18:42:31 <nniro> what about splitting a string where a certain character is? like "1,2,3,4" -> ["1", "2", "3", "4"]
18:42:54 <dibblego> see Data.List.Split on hackage or the span/break
18:42:59 <geheimdienst> > break (== ',') "1,2,3"
18:43:00 <lambdabot>   ("1",",2,3")
18:43:13 <geheimdienst> > break (== '|') "1|2|3"
18:43:14 <lambdabot>   ("1","|2|3")
18:43:40 <aristid> :t break
18:43:41 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:43:44 <dstcruz> > split "," "a,b,c"
18:43:45 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
18:43:45 <lambdabot>         against inferr...
18:43:57 <aristid> :t split
18:43:57 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
18:44:03 <djahandarie> lol
18:44:12 <FunctorSalad> @hackage split -- dstcruz 
18:44:13 <lambdabot> http://hackage.haskell.org/package/split -- dstcruz
18:44:20 <geheimdienst> > split ',' "a,c,x"
18:44:22 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
18:44:22 <lambdabot>         against inferr...
18:44:43 <geheimdienst> teh haksell is goin grate todays
18:45:39 <JoeyA> The readlink C function returns ssize_t, not int.  Assuming the return value won't be that big, is this safe?
18:45:41 <JoeyA> foreign import ccall unsafe "readlink"
18:45:41 <JoeyA> 	c_readlink :: CString -> CString -> CSize -> IO CInt
18:45:57 <JoeyA> (that big, as in, bigger than int but within the range of ssize_t)
18:46:11 <djahandarie> I sometimes try to replicate static types in dynamically typed languages
18:46:15 <djahandarie> It never works out
18:46:27 <JoeyA> There isn't a CSSize (C ssize_t), as far as I know.
18:46:57 <JoeyA> bah, it's so easy in Haskell:
18:47:02 <JoeyA> replicate (static . types)
18:47:09 <JoeyA> if it doesn't compile, stick an M after replicate
18:47:17 <djahandarie> Haha
18:47:23 <McManiaC> gotta love haskell syntax sometimes: http://npaste.de/hL/ :D
18:47:53 <aristid> McManiaC: arrows *run away*
18:47:55 <djahandarie> Not bad
18:47:57 <McManiaC> :D
18:48:07 <djahandarie> I like how that looks
18:48:13 <blackh> McManiaC: I like your "wall of code" effect there, too
18:48:23 <aristid> @hoogle orElse
18:48:23 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
18:48:27 <djahandarie> I wouldn't like trying to edit it though without something to fix my whitespace for me though
18:48:46 <geheimdienst> syntax cat tinks ur doin it rong
18:49:48 <dibblego> @check \a b -> (a `Data.Generics.Aliases.orElse` b) == (a `mplus` (b :: Maybe Int))
18:49:49 <lambdabot>   Not in scope: `Data.Generics.Aliases.orElse'
18:49:55 <dibblego> boo
18:49:59 <aristid> McManiaC: have you tried using <<< instead of >>> to make it flow nicer?
18:50:20 <djahandarie> I think using <<< would make it more confusing
18:50:41 <aristid> why? i'm mentally changing it to <<< to understand it :D
18:51:24 <McManiaC> hm
18:51:30 <McManiaC> I dont
18:51:31 <McManiaC> :P
18:51:45 <McManiaC> since all of the other stuff around it is with >>> aswell
18:51:53 <geheimdienst> change everything to use xpath. done. ;-)
18:51:58 <McManiaC> hehe
18:52:14 <McManiaC> maybe I should do that
18:52:15 <McManiaC> :)
18:52:22 <dibblego> is there a combinator for selTagsChildren [] ?
18:52:29 <McManiaC> no
18:52:37 <McManiaC> its my own one
18:53:09 <kmc> oh dear arrows
18:54:53 <geheimdienst> @hoogle -<
18:55:00 <geheimdienst> btw i can guess what -< is, but where is it defined?
18:55:07 <kmc> it's not an operator
18:55:12 <kmc> it's part of the arrow "proc" syntax
18:55:24 <kmc> foo <- bar -< baz
18:55:26 <geheimdienst> so it's a language extension?
18:55:33 <kmc> read it like an arrow from baz to foo, labeled with "bar"
18:55:36 <kmc> yes
18:55:38 <kmc> -XArrows
18:55:44 <geheimdienst> i see. thanks
18:55:50 <luite> there's also -<<
18:55:57 <luite> which requires ArrowApply
18:56:03 <kmc> not to say that there aren't libraries defining the operator (-<)
18:56:08 <kmc> but i think in this case it's the arrow syntax
18:56:17 <dolio> It is.
18:56:20 <McManiaC> actually its "proc foo -> do a <- f -< foo; ..."
18:56:23 <copumpkin> someone should really confuse people
18:56:24 <dolio> -< is application.
18:56:29 <djahandarie> copumpkin, done.
18:56:31 <aristid> McManiaC: there, with <<<: http://npaste.de/hM/
18:56:33 <copumpkin> and make a library that does it
18:56:38 <copumpkin> all the same syntax
18:56:49 <copumpkin> and use -XArrows in one module and the library with do syntax in another
18:57:48 <McManiaC> aristid: not really better :>
18:58:16 <aristid> McManiaC: i think it's better, because the "flow" is from right to left and from top down
18:59:07 <McManiaC> aristid: subject is down->up tho ;)
18:59:22 <aristid> McManiaC: yeah, maybe you should do everything down->up :D
18:59:23 <McManiaC> *from bottom up
18:59:43 <McManiaC> aristid: doubt that'll work :>
18:59:56 <aristid> McManiaC: maybe with ArrowLoop?
18:59:59 <luite> ? better left to right from flow is Why
19:00:24 <aristid> luite: because the arrow syntax dictates it, at least partially
19:00:29 <McManiaC> .know dont I
19:00:33 <aristid> x <- f <- y
19:00:51 <aristid> you can literally see right-to-left arrows
19:00:57 <luite> oh yes if you use -< everywhere it's probably more clear
19:01:18 <aristid> x <- f -< y
19:01:20 <aristid> there, fixed
19:01:26 <McManiaC> if I only had "getChildren >>> something" then I'd agree with you
19:01:36 <geheimdienst> btw what html walking library is that? deep, getChildren, selTag ...
19:01:39 <aristid> McManiaC: but subject is what changed your mind?
19:01:45 <luite> but I think the >>> and <<< stand out enough to immediately see the direction of the flow... >>> gets somewhat messy though if you combine it with (.)
19:02:01 <McManiaC> but with subject, and a couple of longer ones after my pasted code I think its not very consistent if you use >>> once and <<< the other time
19:02:12 <aristid> luite: (.) is (<<<)
19:02:30 <luite> :t (<<<)
19:02:33 <aristid> McManiaC: in my example i used <<< for subject too
19:02:57 <geheimdienst> it is <<<wimpy>>> to complain about the mixing of <<<arrow directions>>>
19:03:00 <McManiaC> aristid: yeh but I dont think thats easier readable at all :P
19:03:03 <aristid> luite: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Category.html
19:03:33 <luite> hmm, that's not the regular arrow (<<<) is it?
19:03:39 <aristid> McManiaC: i think it is readable:)
19:03:41 <luite> or has it moved?
19:03:49 <aristid> luite: it has moved
19:03:53 <geheimdienst> luite, it's both in C.Category and C.Arrow
19:03:56 <McManiaC> aristid: want to argue about it? :D
19:04:05 <aristid> McManiaC: we should fight to death
19:04:14 <McManiaC> lets get the broadswords guys!
19:04:25 <aristid> death to the arrow mixers!
19:04:38 <luite> still, I don't often use the (->) arrow
19:07:54 <dolio> It provides several useful combinators.
19:26:52 <Gregoryx2> Win FREE Riot Points for LoL, WoW Gamecards, or even Starcraft 2! All and more at http://www.prizerebel.com/index.php?r=2679305
19:26:59 <geheimdienst> @where ops
19:29:49 <Makoryu> @where lambdabot
19:31:25 <Rotaerk> Win FREE IOU's, back rubs, and mowed lawns AND MORE at ...
19:32:49 * copumpkin kicks Rotaerk 
19:33:00 <Rotaerk> ow
19:33:38 <Rotaerk> there's this homeless guy in my town who's selling bad art on the side of the road
19:33:51 <Rotaerk> never seen a homeless entrepreneur before
19:38:00 <atude> what is function "onto"
19:38:42 <Rotaerk> atude, you mean "onto function"?
19:38:43 <copumpkin> atude: in math?
19:38:49 <atude> copumpkin: yes
19:39:03 <Rotaerk> http://www.regentsprep.org/Regents/math/algtrig/ATP5/OntoFunctions.htm
19:39:11 <atude> copumpkin: given the set S={x,y,z} and T={a,b}, how many onto mappings are there from S->T
19:39:27 <copumpkin> atude: it means you cover your codomain
19:39:43 <copumpkin> so you'd take all the mappings that only map to a or only map to b and throw them out
19:40:40 <atude> copumpkin: so 5 mappings?
19:41:00 <bengold_> Hey all, I'm trying to learn a little category theory, and I'm having trouble with an example on wikibooks
19:41:04 <bengold_> http://en.wikibooks.org/wiki/Haskell/Category_theory
19:41:47 <bengold_> The exercise at the end of the "Introduction to Categories" section part 2... I'm having trouble figuring it out. It's the one that says "(Harder.) If we add another morphism to the above example, it fails to be a category. Why? Hint: think about associativity of the composition operation."
19:41:48 <copumpkin> atude: I'd guess not
19:42:02 <atude> copumpkin: ?
19:42:28 <nniro> geheimdienst: break wouldn't work well for splitting a string correctly
19:42:30 <copumpkin> atude: how many morphisms are there total?
19:42:34 <copumpkin> mappings, I mean
19:42:46 <nniro> > break (== ',') ",3"
19:43:33 <atude> copumpkin: I thought only 5
19:43:34 <geheimdienst> guess that would give ("", ",3"). so what? that's expected, isn't it?
19:43:39 <dolio> There are 2^3 total functions.
19:44:03 <copumpkin> atude: so dolio told you the answer there. Now how many of them don't cover the output?
19:44:17 <copumpkin> as in, how many ONLY map to a or b, but not both
19:44:26 <nniro>  > id 1
19:44:33 <nniro> it won't work for me? ;P
19:44:41 <copumpkin> nniro: lambdabot isn't working
19:44:49 <copumpkin> she's on strike today
19:44:55 <nniro> lol
19:45:09 <nniro> it was the first time I was trying it... what a drag ;P
19:45:26 <nniro> geheimdienst: this would be better I think :     map (deleteBy (==) ',') $ groupBy (\a b -> b /= ',') "123,456,789,abc"
19:45:29 <copumpkin> people kept telling her to fix error and she took it personally
19:46:18 <nniro> geheimdienst: otherwise, you need to call tail to correctly get rid of the character
19:46:25 <nniro> geheimdienst: with break that is
19:46:56 <nniro> > map (deleteBy (==) ',') $ groupBy (\a b -> b /= ',') "123,456,789,abc"
19:46:59 <geheimdienst> oh i see. yeah it's kinda unfortunate all the "drop 1" that you need between the breaks
19:47:04 <nniro> gives :  ["123","456","789","abc"]
19:47:34 <geheimdienst> clearly it would be easier with your function. i wonder why break wasn't implemented like that
19:47:43 <FunctorSalad> I haven't read what exactly the question is but it seems like the answer is Data.List.Split
19:47:59 <FunctorSalad> it has all the variants regarding whether to keep delimiters etc
19:48:04 <atude> dolio: so that's the number of mappings from S->T but, which mappings exist?
19:48:24 <FunctorSalad> (drop, keep with left word, keep with right word)
19:48:34 <dolio> All of them?
19:48:39 <copumpkin> lol
19:48:55 <geheimdienst> functorsalad, yeah D.L.Split is cool. we were just bitching about how break could be more helpful by dropping the separator
19:49:25 <nniro> FunctorSalad: I'm sure, but implementing it is pretty easy and...
19:49:57 <FunctorSalad> geheimdienst: hmm only in the special case where your predicate only matches one particular element (or you don't care)
19:50:03 <atude> dolio: well, it doesn't seem right if T = {1,2,3} and S->T = 3^3
19:50:10 <FunctorSalad> IIRC I've used break if I want the breaking item too
19:50:14 <copumpkin> bengold_: you need to be looking for a pair of arrows that are in the category but their composition isn't
19:50:23 <copumpkin> bengold_: and one of the pair is probably the arrow they just added ;)
19:50:24 <atude> {a,b,c} *
19:50:56 <copumpkin> oh actually
19:51:53 <bengold_> copumpkin: Hmmm... but composition doesn't have to be defined over every pair of morphisms in the category, right?
19:52:11 <dolio> For finite sets, it's quite uncontroversial that there are |T|^|S| functions S -> T.
19:52:21 <dolio> If you're asking how many of those are onto, that's another matter.
19:52:22 <copumpkin> well, ones that share an object
19:52:51 <aristid> :t fromMaybe <*> stripPrefix ","
19:53:03 <aristid> haha, imagine the answer.
19:53:18 <atude> dolio: well how to figure how many are onto?
19:53:20 <dolio> But, in the case where T = {a, b}, it's easy, because the only way for a function to fail to be onto is if it only targets one of the elements.
19:53:51 <copumpkin> atude: COUNT :P
19:53:53 <bengold_> copumpkin: I'm not positive I understand still. No matter how I compose them, things seem to be kosher... I'm a little confused.
19:54:11 <nniro> FunctorSalad: what's the name of the package for Data.List.Split? cause I don't have it installed
19:54:22 <FunctorSalad> nniro: split
19:54:49 <geheimdienst> (tragic that you need an extra package for that ... :-( )
19:54:49 <FunctorSalad> (yes, implementing it isn't very hard, but annoying to do in every new project ;))
19:55:03 <copumpkin> bengold_: think about (f . g) . h vs. f . (g . h)
19:55:12 <aristid> i like fromMaybe <*> x
19:55:25 <bengold_> copumpkin: Hah, just found that right as you typed it :) Thanks
19:55:32 <FunctorSalad> @type fromMaybe <*> ?x
19:55:44 <FunctorSalad> @bot
19:56:04 <aristid> > :t (fromMaybe <*>)
19:56:05 <aristid> (fromMaybe <*>) :: forall b. (b -> Maybe b) -> b -> b
19:56:14 <copumpkin> atude: you can either count all the mappings by hand, or figure out the total and subtract the number that aren't onto, as I was suggesting before
19:56:20 <copumpkin> atude: so, how many are not onto?
19:56:47 <nniro> FunctorSalad: yeah I agree... my current method is to copy a Util.hs module for every new project...
19:57:00 <copumpkin> brb
19:57:37 <atude> copumpkin: I get 2
19:57:51 <atude> copumpkin: but, something tells me that's wrong
19:58:07 <bengold_> copumpkin: For when you get back, I think I'm still missing something. Both of those seem to compose perfectly fine from B->A...
19:58:18 <dolio> No, it's correct.
19:59:00 <pumpkin> omg it's a cale
19:59:40 <atude> dolio: which are they?
20:00:03 <atude> dolio: 2 with are not onto and 4 that are
20:00:08 <dolio> (\_ -> a) and (\_ -> b).
20:00:19 <dolio> 2^3 = 8, so there are 6 that are onto.
20:00:33 <atude> ... 
20:00:39 <atude> maybe I'm over looking this
20:00:51 <pumpkin> bengold_: ?
20:01:20 <bengold_> pumpkin: I think I'm still missing something. Both of those seem to compose perfectly fine from B->A...
20:01:37 <bengold_> pumpkin: Where's the problem with f . (g.h) and (f.g) .h?
20:02:01 <pumpkin> benc___: f == f . id_a == f . (g . h) == (f . g) . h == id_b . h == h
20:02:35 <copumpkin> ... I think :)
20:03:27 <bengold_> copumpkin: Wait really? I didn't think you could just reduce those down like that. Earlier on it says that in the category Set, both sine and cosine are morphisms from the same object to the same object, but they aren't the same morphism
20:03:53 <bengold_> copumpkin: I was assuming similarly, that we can't just reduce down like that because of that... ?
20:08:49 <copumpkin> bengold_: I think the point is that that's the only option, because we only added one morphism to the category
20:08:51 <copumpkin> and that's h
20:09:02 <copumpkin> if we'd added more A -> A or B -> B morphisms too, it could work
20:09:20 <copumpkin> but just adding h, h is forced to be the same as f
20:10:44 <bengold_> copumpkin: Okay, I can follow that I think. But if thats so, where's the problem? If h and f are the same, then we didn't add any morphisms at all?
20:10:48 * hackagebot hmatrix-gsl-stats 0.1.2.4 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.2.4 (VivianMcPhail)
20:11:26 <copumpkin> bengold_: yeah, say it was phrased as "add an h morphism, distinct from the existing morphisms, to the above category. Is the result a category?"
20:11:38 <bengold_> copumpkin: Word. Gotcha. Alright gtg
20:11:42 <bengold_> copumpkin: Thanks for the help!
20:33:54 * hackagebot hsignal 0.1.2.3 - Signal processing  http://hackage.haskell.org/package/hsignal-0.1.2.3 (VivianMcPhail)
20:34:56 <EvanCarroll> Does System.Random guarentee the same result on different platforms? or only the specified platform?
20:35:19 <bos> it should be portable
20:35:25 <EvanCarroll> nifty.
20:35:36 <bos> but you shouldn't use it anywhere. it's terribly, terribly slow.
20:35:42 <geheimdienst> return 4; // determined by fair dice roll ...
20:36:36 <djahandarie> Thankfully, it isn't a monad ;)
20:38:07 <bos> dons: do you use anything special for http serving at galois?
20:40:44 <djahandarie> bos, do you have any interesting projects lined up now that you're wrapping up the I/O manager with Johan?
20:42:40 <bos> djahandarie: always :-)
20:43:01 <djahandarie> Hehe
20:43:14 <bos> djahandarie: getting ready for a major text and text-icu relesae
20:43:48 <FunctorSalad> why is the $ required in:
20:43:53 <FunctorSalad> f $ do
20:43:56 <FunctorSalad>   foo
20:44:27 <FunctorSalad> (I don't see how the syntax would be ambiguous if it was allowed without ($))
20:44:47 <dolio> It probably wouldn't be ambiguous, but it isn't allowed.
20:45:12 <FunctorSalad> (($) isn't special of course, I mean any operator)
20:45:21 <FunctorSalad> hmm ok
20:46:56 <dolio> Agda, for instance, allows 'f \x -> ...'
20:48:16 <JoeyA> System.Random.Mersenne is pretty quick, but you can only instantiate one generator per application.
20:48:28 <bos> JoeyA: use mwc-random instead
20:48:40 <bos> it's faster, and has a better API
20:49:16 <JoeyA> What about quality?  Better/worse/the same?
20:49:20 <luite> and it's writtenby bos instead of dons ;)
20:49:33 <bos> it has a smaller period, but still unimaginably huge
20:51:34 <luite> I still need to rewrite an old genetic algorithm library where the main problem was getting the random numbers there fast enough while keeping the interface relatively clean and generic
20:51:47 <luite> one of the newer generators may help
20:54:46 <FunctorSalad> adding line numbers: unlines . map (uncurry $(printf "%4d %s")) . zip [1..] . lines
20:54:47 <FunctorSalad> :-)
20:55:29 <JoeyA> I don't know how to use mwc-random, but for what it's worth, here's a pseudorandom lazy ByteString generator that uses System.Random.Mersenne:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29501#a29501
20:55:42 <djahandarie> Ugh printf
20:55:52 <FunctorSalad> (nobody will ever need more than 10000 lines)
20:56:04 <FunctorSalad> djahandarie: printf is awesome
20:56:09 * JoeyA agrees
20:56:28 <FunctorSalad> you are free to write the exact same thing 3 times as verbosely :p
20:56:33 <JoeyA> When someone posted a showHex alternative to printf "%02x", it took a while before I realized those aren't the same.
20:56:46 <luite> JoeyA: having only a single stream of randoms is rather annoying in a pure/lazy setting though
20:56:55 <FunctorSalad> JoeyA: padding?
20:56:56 <JoeyA> Indeed
20:57:08 <kmc> printf is an interpreter for a domain-specific language
20:57:09 <JoeyA> FunctorSalad: correct
20:57:21 <kmc> fair enough, now why do we specify that language using a string rather than some proper typed EDSL combinators
20:57:30 <JoeyA> luite: Indeed, it would be better (as in, actually useful) if multiple generators could be instantiated.
20:57:44 <djahandarie> Is Oleg's type-safe printf anywhere on hackage?
20:58:06 <luite> JoeyA: they need to be splittable as well
20:58:14 <JoeyA> Being able to generate pseudorandom lazy ByteStrings is useful for writing hard drive and flash memory testers.
20:58:25 <FunctorSalad> djahandarie: ? I used printf-th, which is typesafe
20:58:36 <JoeyA> (if you can generate two that are the same, the task is really nice and easy)
20:58:40 <kmc> sigh
20:58:41 <FunctorSalad> (note the dollar)
20:58:46 <djahandarie> FunctorSalad, oleg has one written in h98
20:58:53 <FunctorSalad> ah
20:59:29 <djahandarie> Oh wait, no, he uses TH in his
20:59:49 <luite> isn't there a package that has some nice operators for this poke/plusPtr FFI stuff by the way? the regular function names get really ugly
20:59:58 <nniro> kmc: QuickCheck is far from easy to use ahah
21:00:07 <kmc> someone want to ban CTAPOMAK?
21:00:13 <djahandarie> The new version of QuickCheck needs a nice guide to go along with it
21:00:13 <kmc> nniro, did you read RWH?
21:01:26 <JoeyA> luite: I tried using Data.Binary at one point, but there was a problem with it (I either couldn't get it to run fast enough, or System.Random.Mersenne using IO was a problem.
21:01:40 <luite> JoeyA: what whas the speed you got out of that unsafeInterleaveIO generator by the way?
21:01:45 <JoeyA> Or maybe it was because it didn't have good ByteString capabilities.  Not sure.
21:01:56 <JoeyA> You mean the one I pasted?
21:01:59 <luite> yes
21:02:07 <JoeyA> 250MB/s one one core of my Core 2 Duo 1.5GHz
21:02:12 <JoeyA> err, 240MB/s
21:02:32 <luite> oh that's acceptable... now if only it were splittable ;)
21:02:36 <nniro> kmc: I did, but I can't find how I can add specific inputs and what result I want
21:02:41 <FunctorSalad> parsec should use one of these cute ascii art arrows that point to the location of the error
21:02:44 <JoeyA> What does splittable mean?\
21:02:48 <kmc> nniro, it's not designed for that kind of testing
21:02:48 <FunctorSalad> ("right here ---->" :))
21:02:51 <kmc> it generates inputs automaticall
21:02:59 <kmc> you express properties rather than specific input-output pairs
21:03:04 * djahandarie pokes CTAPOMAK to fix his client
21:03:06 <kmc> anyway you can probably hack it in, but maybe HUnit is more what you want
21:03:08 <luite> JoeyA: that you split the random generator (which you don't really have in this case), into two independent new generators
21:03:10 <kmc> @where ops
21:03:19 <djahandarie> @where lambdabot
21:03:32 <JoeyA> luite: Do both generators produce the same output?
21:03:35 <kmc> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseud
21:03:35 <kmc> onym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
21:03:48 <luite> JoeyA: no, that's the idea, otherwise you could just copy the internal state :)
21:03:50 --- mode: ChanServ set +o copumpkin
21:03:54 <kmc> thanks copumpkin
21:03:58 --- mode: copumpkin set +b CTAPOMAK!*@*
21:04:07 <copumpkin> wow, nice ban, mr client
21:04:11 <kmc> hehe
21:04:22 <copumpkin> typing where ops will highlight me btw
21:04:30 <copumpkin> (as in I have an actual highlight set for it)
21:04:34 <djahandarie> Real men type in the whole hostmask
21:04:38 <copumpkin> djahandarie: lol
21:04:54 <copumpkin> what's the ban that redirects them to another channel, anyway?
21:04:58 <copumpkin> I feel bad banning him outright
21:04:59 <luite> JoeyA: the problem is to make them really independent, i.e. tests for randomness would not only work within a single generator, but also between the resulting generators after a split
21:05:15 <djahandarie> copumpkin, append $#somechannel
21:05:26 --- mode: copumpkin set -b CTAPOMAK!*@*
21:05:31 <nniro> kmc: does QuickCheck support having more than one argument that it randomly generate?
21:05:42 --- mode: copumpkin set +b CTAPOMAK!*@*$#haskell-ops
21:05:46 <copumpkin> like that?
21:06:31 <luite> JoeyA: mersenne does take a lot of time to initialize by the way, you could implement some optimized split: for example generate 1000 bytes of random numbers for each generator using the old generator, and then split it (lazily), only actually initialize the new generators if the buffer has been used
21:06:32 <copumpkin> oh it's a bang I think?
21:06:36 <copumpkin> oh, it works
21:07:03 <bos> luite: the split function shouldn't be there in the first place. it's completely theoretically unsound.
21:07:19 <JoeyA> Couldn't you just create two RNGs with different seeds?
21:07:21 <luite> JoeyA: oh and there hasn't been much research on splittable generators, so if you're looking for some thesis subject ;)
21:07:33 <bos> there's been none.
21:07:36 <JoeyA> Nope, I'm not an RNG maker, just a user.
21:07:48 <copumpkin> I thought there was one reference, and that's how it got in there in the first place
21:07:53 <bos> i read the original paper on splittable PRNGs, in which the authors pulled the idea out of their asses.
21:08:03 <copumpkin> if it were possible to do well, it'd be really nice to have
21:08:07 <copumpkin> but nobody knows :P
21:08:19 <luite> ah I have the paper saved somewhere deep in my to-read pile :)
21:09:16 <nniro> I'd also like to know if it's possible to gradually apply the elements of a list to a function, if we take it for granted that the function is already made to accept the amount of elements
21:09:47 <luite> JoeyA: you have to get the random seeds from somewhere, and the problem is that regular randomness tests only apply to generated numbers within the same "stream"...
21:10:50 <JoeyA> Anyway, the point I was trying to make with my paste ( http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29501#a29501 ) is that generating pseudorandom ByteStrings should be easier.  None of the PRNG packages I've seen have an explicit ByteString option.
21:11:04 <JoeyA> Generating a word at a time probably has a lot of function call overhead, anyway.
21:11:05 <luite> there is a vector-random package
21:11:09 <luite> that fills vectors
21:11:57 <JoeyA> That's neat.  I'll have to get around to benchmarking it sometime.
21:12:35 <JoeyA> (though I'd want to convert to ByteString first (by byteswapping Word64s))
21:13:25 <bos> mwc-random fills vectors, too :-)
21:14:20 <nniro> I would like a function that is able to do this :  applyListAsArg :: [a] -> Int -> (? -> d) -> d     where Int is the amount of elements from the list [a] which is applied to the function
21:14:56 <copumpkin> ?
21:15:19 <copumpkin> what's the ? in there, and why only one d returned?
21:15:45 <luite> applyListAsArg [2,3,4] 2 (+) = 5   ?
21:16:04 <nniro> the '?' there is because I don't know the class that should be there eheh
21:16:05 <copumpkin> oh, a fold on a prefix?
21:16:38 <copumpkin> oh
21:16:43 <copumpkin> you can't do that
21:16:54 <copumpkin> you want a variable arity function in there
21:16:59 <nniro> luite: hmm not quite, the function should accept the 3 arguments from the list
21:17:23 <copumpkin> nniro: if you want a variable arity function, you can either make it take a list as input :)
21:17:40 <copumpkin> or you can do some magic with type-level numbers and get the equivalent of a type-level vector function
21:18:23 <nniro> would be cool to be able to mess more with the partly applied functions in haskell
21:18:37 <nniro> something which would permit what I want
21:19:30 <Axman6> which is?
21:19:33 <nniro> like the function applyListAsArg would gradually apply the arguments to the function but not run it
21:19:34 <djahandarie> copumpkin, how would doing that on the type-level help? Wouldn't you have the same issue with kinds?
21:19:49 <nniro> only after it has all the arguments, it would run the actual function
21:19:49 <copumpkin> not realy
21:21:09 <cncl> does parsec3 not work with monads-fd?
21:21:30 <nniro> isn't that a little what ap does anyway?
21:22:34 <Axman6>  :t ($ id)
21:22:41 <Axman6> :t ($ id)
21:22:53 <djahandarie> ($ id) :: ((a -> a) -> b) -> b
21:22:54 <Axman6> lambdabotttttt :(
21:23:17 <Axman6> it's just not the same without the forall a b. :'(
21:27:51 <nniro> how else should I do it then? I have a certain amount of strings in a list and depending on a command given by the CGI argument, one of 20 actually haskell functions would need to be called with certain of those strings from the list as arguments
21:28:22 <dankna> I hesitate to mention Dynamic
21:28:47 <dankna> I suspect it's not necessary if you were to tell us more about how the command determines the call
21:30:20 <nniro> well currently, it's implemented with a case which takes a string to figure which haskell function to execute
21:30:55 <luite> you may be looking for something more along the lins of mueval or hint then
21:31:02 <dankna> well, what are the functions?  different activities depending on what page the user wants to look at?
21:31:13 <dankna> and what are the parameters and how does it know which is which
21:32:23 <nniro> dankna: yes, the commands are for seeing different pages, the parameters are in a simple 2 elems tuple list (name, value)
21:32:33 <cncl> argh, i can't use parsec3 and fclabels at the same time?
21:33:03 <cncl> since parsec3 uses mtl and fclables uses monads-fd
21:33:09 <dankna> nniro: so perhaps you want something like a list...
21:33:24 <dankna> Map String [String]
21:33:26 <dankna> er
21:33:48 <dankna> Map String (([String] -> CGI ()), [String])
21:34:11 <dankna> the first element of the pair being the function that's called, and the second element being the list of the names of the parameters it takes?
21:36:08 <nniro> dankna: but then all the code to check for valid parameters has to be in the function themselves, taking even more code in the end
21:36:14 <dankna> oh.
21:36:20 <dankna> well.  what sort of validity constraints are there?
21:36:38 <dankna> if each parameter is its own set of rules, you can't avoid writing that code somewhere.  if you can factor them out, then maybe something like...
21:36:44 <dankna> data ParameterType = ...
21:37:13 <dankna> Map String ((... -> CGI ()), [String]) and, separately, Map String ParameterType
21:37:19 <dankna> the second map telling you what type goes with each parameter
21:37:25 <dankna> and then you have a function that performs validation
21:37:33 <dankna> I wrote ... because it's not clear yet what type we can give that part
21:37:58 <nniro> dankna: yeah ok, let me paste the code
21:38:31 <dankna> hpaste it please
21:38:52 <nniro> yeah that's what I'm doing, don't worry
21:39:02 <djahandarie> Is hpaste even up?
21:39:19 <dankna> okay, just saying :)
21:39:21 <dankna> no idea
21:39:38 <djahandarie> Doesn't seem like it
21:39:44 <dankna> well, there are many fine alternatives to it
21:39:48 <djahandarie> chrisdone needs to man up and hijack that domain ;)
21:39:49 <nniro> yeah, guess not ahah
21:39:51 <dankna> I lie.  there are many lame alternatives.  but they exist.
21:40:07 <dankna> honestly, I don't see that we need the domain itself
21:40:18 <djahandarie> Well, we have access to it so I don't see why not
21:40:37 <dankna> fair
21:40:58 <djahandarie> I find it so odd that no one knows who is running the current service
21:41:26 <dankna> eh?  I did a whois on it the other day and told chrisdone
21:41:33 <nniro> dankna: http://www.pastebin.ca/1926507
21:41:36 <dankna> it's not like it's a secret
21:41:38 <dankna> nniro: looking
21:41:48 <djahandarie> dankna, we know who owns the domain
21:41:52 <dankna> oh
21:42:04 <dankna> yeah, it is odd
21:42:20 <dankna> watch, we'll transfer it and someone will come in here all angry :)
21:42:24 <FunctorSalad> p = try (eof >> return []) <|> liftM2 (:) p1 p     -- this doesn't seem to work... why?
21:42:49 <FunctorSalad> seems like it should be about equivalent to many1 p1 >> eof
21:42:56 <dankna> nniro: yick, I see why you want to refactor.  that's a huge case.
21:43:07 <nniro> dankna: lol
21:43:39 <FunctorSalad> but it successfully returns a one-element list though the input should clearly parse as two elements
21:44:22 <dankna> okay, so every page-handler function takes conn lang and tuid.  some of them also take additional parameters...
21:45:05 <dankna> well, I think I would use Data.Dynamic for this
21:45:12 <djahandarie> Nooo
21:45:18 <dankna> please open and skim the docs on that - you'll have questions
21:45:24 <dankna> djahandarie: lol
21:45:39 <djahandarie> Make a record with a bunch of Maybes for the optional params
21:45:42 <dankna> hmmm
21:45:53 <djahandarie> Or at least enforce the required params
21:46:22 <dankna> well, I was going to walk him through using dynamicApply or whatever it's called to enforce the req'd params, yes
21:46:31 <dankna> but what you said may be a better approach
21:46:54 <dankna> but the situation is such that every param is optional to a different page
21:47:03 <dankna> each individual param is only used by a couple pages
21:47:23 <nniro> yeah, so the record would be huge too :)
21:47:44 <dankna> so let's do it with Dynamic :)
21:48:58 <nniro> dankna: give me a small overview how you would see this, in theory
21:49:16 <dankna> okay
21:49:28 <dankna> so you're going to have two Maps which you construct statically
21:49:36 <dankna> one map is going to tell you the types of each parameter
21:49:38 <dankna> it'll be something like
21:49:44 <EvanCarroll> this seems like a really bad pseudo random algo, when seeded with numbers that end in 9
21:49:47 <dankna> Map String ParameterType
21:50:44 <dankna> the first thing your dispatcher will do is iterate through the entire list of parameters that are found and case on the parameter type for each one that's present, calling convStrToDec or whatever's appropriate
21:51:00 <dankna> now, the other map will be like
21:51:20 <dankna> oh - the key to that first map is the parameter name if that wasn't clear
21:51:23 <dankna> now, the second map
21:51:31 <nniro> eheh convStrToDec was before someone told me about read today ;P
21:51:35 <dankna> gotcha :)
21:51:44 <dankna> but you still need to statically know the type you're reading into
21:52:03 <dankna> the second map will be Map String (Dynamic, [String])
21:52:25 <dankna> the key is the page name.  the Dynamic is a dynamic object holding a function to be used as the method for the page.
21:52:32 <dankna> the list of strings is the list of parameters to that page.
21:53:04 <dankna> your dispatcher's second step after translating the parameters is to look up the page in the second map and verify that all the required parameters are present.
21:53:22 <dankna> note that I made it a [String] and not a Set String because the function will need them in a particular order
21:53:31 <dankna> and we might as well store that order here
21:53:42 <dankna> to construct the page map, you'll do something like
21:53:52 <dankna> pageMap :: Map String (Dynamic, [String])
21:54:30 <nniro> dankna: hold on a sec, my page functions would need to be changed, or not?
21:54:38 <augur> hey peeps
21:54:45 <augur> hey dankna
21:54:55 <dankna> pageMap = Map.fromList [("search", (toDyn doSearch, [])), ("fillPayment", (toDyn doFillPayment, ["userid", "payid", "paid_amount"])), ...]
21:55:01 <dankna> no, they won't need to be changed with this approach
21:55:02 <dankna> hey augur!
21:55:15 <augur> sup dudeface
21:55:37 <dankna> that's an interesting appelation.  am I its referent?
21:55:43 <augur> yes
21:55:51 <dankna> not much is up.  how are you, face-dude?
21:56:10 <augur> 8D
21:56:12 <augur> D8
21:56:16 <augur> ize good
21:56:19 <dankna> hehe
21:56:29 <dankna> :t toDyn
21:56:33 <dankna> oh, no lambdabot :(
21:56:42 <dankna> well, toDyn takes an argument of ANY type and returns a Dynamic
21:56:48 <nniro> toDyn :: Typeable a => a -> Dynamic
21:56:51 <dankna> thanks
21:56:58 <dankna> well, any Typeable type
21:57:44 <dankna> now, I assume it's clear to you how to do those first two steps - translating the parameters with read or whatever's appropriate, and checking that you have all the mandatory parameters
21:57:49 <dankna> speak up now if it's not
21:58:16 <nniro> yeah, seems so
21:58:37 <nniro> I'm more concerned how to pass those arguments to the function that was pushed to the Dynamic type :)
21:58:38 <dankna> now since the parameters may be heterogeneous (not all the same type)
21:58:46 <dankna> right, don't worry, I'm about to get to that :)
21:59:02 <dankna> you'll want to call toDyn on each parameter, giving you a [Dynamic] of the parameters
21:59:17 <dankna> now you have your Dynamic function and your [Dynamic] of the parameters
21:59:34 <dankna> you can now fold down the list calling dynApply (spelling?  is it dynApply or dynamicApply?) on it
21:59:50 <nniro> dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
21:59:52 <dankna> :t dynApply -- go go gadget lambdabot!
22:00:01 <dankna> yes
22:00:16 <dankna> dynApply takes two parameters.  the first is a Dynamic containing a function, the second is a Dynamic containing a parameter.
22:00:42 <dankna> if the type of the function and parameter are such that the parameter is a legitimate next argument to the function, it returns Just the result of applying them
22:00:49 <dankna> you know how Haskell has partially-applied functions and all that?
22:01:04 <dankna> if that argument was the final argument, the result of dynApply will be the result of the function
22:01:16 <dankna> otherwise it will be a partially-applied function that still wants the remaining parameters
22:01:28 <dankna> if the types don't match, you get Nothing back, but at this point you've already checked that they do
22:01:51 <nniro> I see :)
22:01:54 <dankna> finally you've got your result in a Dynamic.
22:02:20 <dankna> since you statically know that the type of the result should be IO (), you can call fromDyn or fromDynamic (they have subtly different semantics but it should be obvious which is the right one - I hope so anyway cause I forget :D)
22:02:29 <dankna> to get that out and return it, thereby actually performing the action
22:02:32 <EvanCarroll> gah
22:02:38 <EvanCarroll> (1E)$5
22:02:40 <EvanCarroll> =(
22:02:45 <dankna> I had to figure all this out a few months ago from the docs, which wasn't easy ><
22:02:57 <dankna> EvanCarroll: assembly?
22:02:58 <nniro> dankna: lol I bet ;P
22:03:28 <dankna> anyway, that should be all you need to get started; good luck and feel free to ask me any further questions :)
22:03:49 <dankna> my use-case was actually CGI processing as well
22:03:50 <EvanCarroll> dankna: ?trying to take a slice with E
22:03:55 <dankna> Evan: ahh
22:04:04 <EvanCarroll> aparently E is some sort of compiler construct, and not a function
22:04:07 <dankna> hrm
22:04:13 <nniro> dankna: I went through the same kind of hussle trying to learn existentially quantified types ;P
22:04:19 <nniro> hassle*
22:04:34 <dankna> nodnod
22:04:59 <nniro> dankna: thanks, I'll try it out :)
22:05:40 <dankna> welcome
22:09:46 <JoeyA> If I want to express 100 milliseconds in Haskell with System.Time, is noTimeDiff {tdPicosec = 100 * 10^9} a good way to do it?
22:09:49 <JoeyA> Or is there a shorter way?
22:10:07 <kmc> System.Time is deprecated btw
22:10:13 <JoeyA> In favor of?
22:10:15 <kmc> (you may have some specific reason to use it)
22:10:19 <kmc> Data.Time
22:10:23 <kmc> System.Time is from the "old-time" package
22:10:31 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/old-time-1.0.0.4/System-Time.html see first line under "Description"
22:10:54 <kmc> imo neither time library is all that great but you may find one or the other more to your liking
22:12:12 <JoeyA> I'm mainly interested in getting 100 milliseconds from now and later testing if the current time is past that.
22:13:58 <EvanCarroll> >  let nine count | count == 0 = 0 | otherwise = nine (count-1) : (sum $ (take count $ map ((9*).(10^)) [0..]))
22:14:03 <EvanCarroll> why doesn't that work ?
22:14:31 <JoeyA> Have you told your Haskell compiler how much you appreciate it lately?
22:14:39 <EvanCarroll> yes
22:14:53 <kmc> EvanCarroll, can you tell us something about how it doesn't work?
22:15:08 <EvanCarroll>     Occurs check: cannot construct the infinite type: t = [t]
22:15:22 <kmc> Â«take count $ map fÂ» is suspect
22:15:28 <kmc> you probably want Â«take count . map fÂ»
22:15:39 <JoeyA> Because the count == 0 case is producing a number
22:15:45 <JoeyA> and the otherwise case is producing a list
22:15:59 <EvanCarroll> eh?
22:15:59 <ljungk> is there a split function somewhere?
22:16:08 <JoeyA> What is nine count supposed to return?
22:16:10 <ezyang> ljunk: Package 'split' 
22:16:11 <ljungk> to split a string on somthing
22:16:21 <EvanCarroll> JoeyA: a number 9, 99,999,9999
22:16:22 <EvanCarroll> etc
22:16:32 <EvanCarroll> a list of them rather
22:16:33 <JoeyA> oh
22:16:42 <ezyang> ljungk: If you only need to split on a character, itâ€™s easier 
22:16:50 <JoeyA> As in [9] or [9,9] or [9,9,9] ?
22:16:53 <ezyang> @hoogle Eq a => a -> [a] -> [[a]] 
22:16:56 <JoeyA> Or [9, 99, 999, 9999] ?
22:17:21 <ljungk> ezyang: yes
22:17:27 <JoeyA> > let nine count | count == 0 = [0] | otherwise = nine (count-1) : (sum $ (take count $ map ((9*).(10^)) [0..])) in nine 4
22:17:59 <EvanCarroll> JoeyA: the latter.
22:18:08 <JoeyA> > 2+2
22:18:17 <JoeyA> Hmm, lambdabot is sleeping or dead.
22:18:26 <JoeyA> or not here.
22:19:33 <JoeyA> err, I think the composition needs to be flipped.
22:19:42 <ljungk> ezyang: something like the opposite of intercalate
22:19:44 <JoeyA> Since  (sum $ (take count $ map ((9*).(10^)) [0..])) produces a sigle value
22:19:51 <JoeyA> nine (count-1) produces the rest
22:20:42 <lispy> lambdabot sleeps with the fishes
22:21:09 <JoeyA> > let nine count | count == 0 = [0] | otherwise = (sum $ (take count $ map ((9*).(10^)) [0..])) : nine (count-1) in nine 10
22:21:10 <JoeyA> [9999999999,999999999,99999999,9999999,999999,99999,9999,999,99,9,0]
22:21:12 <ezyang> ljungk: http://hackage.haskell.org/package/split-0.1.2 
22:21:52 <JoeyA> You'll probably want to put a tail . reverse on top of it all.
22:23:58 <JoeyA> > map (read . flip replicate '9') [1..10] :: [Integer] -- cheating
22:23:58 <JoeyA> [9,99,999,9999,99999,999999,9999999,99999999,999999999,9999999999]
22:24:14 <EvanCarroll> hahaha
22:24:18 <EvanCarroll> yea i was thinking about that.
22:24:32 <EvanCarroll> probably not any slower either.
22:28:55 <kmc> @bot
22:29:03 <Axman6> > iterate ((+9) . (*10)) 9
22:29:07 <kmc> Cale, can has lambdabot?
22:30:17 --- mode: ChanServ set -o copumpkin
22:42:08 <nniro> dankna: I was writing a test full implementation but I'm getting tired so I just wrote a simple straight forward test case... I'm having trouble figuring how to use fromDyn though
22:43:54 <dankna> nniro: it may be necessary to provide a type signature, you need to use it in a context where the type you want out is statically known
22:44:04 <dankna> in this case the type you want out is IO ()
22:46:04 <nniro> dankna: http://www.pastebin.ca/1926535
22:46:10 <dankna> looking
22:46:53 <dankna> ah, you want fromDynamic instead
22:46:56 <dankna> fromJust $ fromDynamic
22:48:50 <nniro> I had to do : input2 = toDyn (22 :: Int) for it to work
22:48:53 <nniro> but it works ahah
22:50:27 <nniro> dankna: here's the whole stuff... I'm really tired though so I may be doing it all badly :  http://www.pastebin.ca/1926540
22:51:56 <EvanCarroll> Axman6++ very nice.
22:52:11 <Axman6> heh
22:52:41 <dankna> looks pretty good to me.  certainly shorter than what you had!
22:53:18 <EvanCarroll> yea, I agree.
22:53:29 <EvanCarroll> That's why I ++ed him.
22:54:21 <EvanCarroll> I really like those sort of problems
22:54:41 <EvanCarroll> i wish there was a website that had good golfing questions
22:54:51 <EvanCarroll> something like the euler challanges but not as detailed.
22:55:49 <EvanCarroll> you could probably rewrite mine as a fold.
22:56:51 <EvanCarroll> I bet you could write iterate as a fold too
22:56:57 <copumpkin> a fold over what?
22:57:00 <EvanCarroll> @src iterate
22:57:02 <copumpkin> an infinite list?
22:57:08 <EvanCarroll> yes
22:57:14 <copumpkin> oh, sure
22:57:25 <EvanCarroll> how do you get the source w/ the bot
22:57:26 <copumpkin> I'd write it as an unfold though
22:57:26 <nniro> dankna: oh yeah, I need to create a list with each functions and all the arguments that they accept (giving by the same way the order)
22:57:39 <EvanCarroll> what is an unfold?
22:58:10 <RayNbow`TU> unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
22:59:00 <kmc> nniro, instead of using Dynamic
22:59:04 <kmc> since you're already classifying the types
22:59:06 <kmc> why not
22:59:13 <kmc> Â«data Arg = ATString String | ATInt IntÂ»
22:59:38 <RayNbow`TU> http://webcache.googleusercontent.com/search?q=cache:Vm0TUq9rrbcJ:hpaste.org/fastcgi/hpaste.fcgi/view%3Fid%3D5906+http://hpaste.org/fastcgi/hpaste.fcgi/view%3Fid%3D5906&cd=1&hl=nl&ct=clnk&gl=nl  -- alternative unfoldr
22:59:47 <kmc> btw your nested "Nothing -> return ()" are the pattern to recognize as a sign that you can use the Maybe monad instance
23:00:35 <kmc> do { f1' <- dynApply f1 input1; f12 <- dynApply f1' input2; fromJust $ fromDynamic f12 }
23:01:20 <kmc> nniro, did you read about HUnit?
23:01:36 <nniro> kmc: sorry, so much stuff to do at once ;P
23:02:02 <nniro> kmc: I wrote about HUnit on a paper, I'll check about it after
23:02:29 <kmc> well it looks like you're trying to write a unit testing framework in a kind of weird way
23:02:32 <nniro> kmc: actually the code in main is just a sample test case, just to get a small version working
23:02:42 <kmc> and HUnit is a pretty well established unit testing framework
23:02:49 <kmc> so maybe it could give you some ideas on how to structure it
23:03:09 <nniro> kmc: oh I'm actually learning Dynamic for another project of mine
23:03:13 <kmc> ok
23:03:58 <nniro> kmc: to fix this horror : http://www.pastebin.ca/1926507
23:04:45 <kmc> wow your code is marching off the side of my screen
23:04:47 <kmc> what's with that
23:05:29 <ezyang> nniro: Wow, that looks impressively like Java. 
23:05:39 <kmc> nniro, this is insanely bad
23:05:43 <nniro> ahah, it's a command parser for a CGI website
23:05:56 <kmc> and i don't think Dynamic will fix it up particularly
23:06:13 <kmc> why do you want Dynamic, as opposed to simply a type with multiple constructors?
23:06:51 <kmc> you have an awful lot of "if isNothing"
23:06:56 <kmc> shouldn't it use pattern matching instead?
23:07:24 <nniro> the arguments are part of the type [(String, String)] hence why there's so much lookups and isNothing
23:07:42 <kmc> right
23:07:48 <kmc> shouldn't you use pattern matching instead of isNothing?
23:08:24 <nniro> maybe it's because I'm tired but I don't see how
23:09:00 <ezyang> nniro: One possibility is to take advantage of laziness and do all the lookups in one block, regardless of the condition 
23:09:33 <kmc> like this maybe nniro http://codepad.org/32Dd1kp7
23:09:42 <kmc> there's lots of other stuff wrong here
23:09:49 <kmc> like that (False, False, False, Nothing) looks real suspicious
23:10:04 <kmc> you should define a new type, probably a record, instead of that tuple
23:10:16 <copumpkin> holy crap
23:10:19 <copumpkin> that must've taken a while to write
23:10:28 <nniro> kmc: ah I didn't know about that technique, I always had the mindset that case only takes one argument at a time ahah
23:10:35 <kmc> nniro, it does take one argument
23:10:38 <kmc> in this case it's a tuple
23:10:44 <dankna> for the record, I'm the one who advised him to do it with a Dynamic
23:10:51 <kmc> also all this Â«conn lang tuidÂ» you're passing everywhere might could be simplified with Reader monad
23:11:20 <nniro> copumpkin: it used to be even worse heh -_-
23:11:21 * copumpkin murders dankna 
23:11:29 * dankna is dead
23:11:44 <ezyang> nniro: 20 lines. I bet you could reduce it to that long. 
23:11:55 <ezyang> Improving readability in the process too. 
23:11:57 <kmc> nniro, it seems you're new to Haskell, i wonder why you chose to write 250 lines of (by your own admission) awful repetitive code, rather than tackle a smaller problem and get a really nice clean solution
23:12:12 <kmc> 250 lines is incredibly long for a Haskell function
23:12:26 <nniro> kmc: this is actually code I wrote a few years ago
23:12:30 <copumpkin> I'd factor a function into smaller ones if it was even 20 lines
23:12:35 <kmc> isn't this function doing 30 different things? unrelated verbs on your "funcName" argument?
23:12:44 <copumpkin> I really don't like large functions
23:12:49 <copumpkin> (in haskell, at least)
23:12:51 <nniro> me neither eheh
23:13:06 <nniro> hence why I desperately wanted to get rid of this ahah
23:13:35 <nniro> see at least with Dynamics, I can create a list of the functions and the arguments that they take in the correct order
23:13:51 <nniro> then using map, do the rest of the work
23:14:05 <nniro> something like :  [("staticFunc1", toDyn staticFunc1, ["bog", "bah"])] ++
23:14:05 <nniro> 	[("staticFunc2", toDyn staticFunc2, ["foo", "bar"])]
23:15:11 <nniro> kmc: repetitive code? how long it been since you wrote C code? ;P
23:15:23 <kmc> nniro, a couple days
23:15:29 <kmc> what's your point
23:15:50 <nniro> kmc: in C, this could be much worse than this
23:15:52 <kmc> yeah
23:15:56 <kmc> Haskell isn't C
23:16:03 <kmc> it'd be even worse in PDP 11 assembler
23:16:15 <kmc> or implemented using wire-wrapped 74 series discrete logic chips
23:17:00 <nniro> large functions or not, implementing this was a nightmare
23:17:16 <kmc> no kidding
23:17:33 <nniro> at the time, I couldn't figure how I could generalize it enough to make this painless
23:17:35 <kmc> i have no idea why you'd continue on such an insane path
23:17:44 <kmc> for 250 lines
23:19:01 <nniro> if not by using Dynamic, how else should this be done?
23:19:04 <kmc> anyway if you want to learn how to write nice clean Haskell code, it will take some time
23:19:20 <kmc> you can't jump into a big messy problem like this as a beginner
23:19:33 <JoeyA> Well, you can, but it's a chance to learn :-)
23:19:42 <JoeyA> But the code won't be so nice, of course.
23:19:57 <kmc> past some point it's not a good learning experience
23:20:08 <kmc> to learn you need to tackle problems a bit harder than what you can do comfortably, but not too much
23:20:13 <kmc> this is well established in every domain
23:20:45 <kmc> if you know Python you can probably jump into Ruby at some big complicated problem like this
23:20:50 <kmc> because they're not too different
23:20:55 <kmc> but Haskell really is different
23:21:08 <kmc> and saying "it would be worse in C" is not a good justification
23:21:35 <nniro> heh
23:22:02 <kmc> nniro,  why don't you start by factoring your huge function into a bunch of smaller ones
23:22:06 <kmc> handling only one verb each
23:22:13 <kmc> that should make it more manageable, testable etc.
23:22:32 * JoeyA jumped into playing with the ST monad prematurely
23:24:17 <nniro> I progressed quite a lot since I wrote this
23:24:25 <kmc> cool
23:24:31 <nniro> I guess we all do in a year
23:24:36 <kmc> then maybe my advice is not relevant
23:24:50 <kmc> nniro, i hope so
23:25:04 <kmc> i've been working in Haskell for four or five years and I still learn a lot
23:26:10 <nniro> kmc: this is my latest project : http://git.neuroponic.com/?p=swmng.git;a=blob;f=swmng.hs;h=dc60f44aa82e15cccabb5d0127063c4d401a368d;hb=c2ccdd36ca20d3f1393ba58c6eea7a4371dbbf6d
23:26:30 <kmc> cool
23:26:34 <kmc> looks better :)
23:27:42 <nniro> kmc: this is a snapshot so you can compile it :  http://git.neuroponic.com/?p=swmng.git;a=snapshot;h=c2ccdd36ca20d3f1393ba58c6eea7a4371dbbf6d
23:28:57 <nniro> I haven't pushed the latest changes I did to the code, I recently got hlint and did lots of small changes according to the suggestions it gave me
23:29:36 <nniro> and also started to get rid of the Util.hs dependencies
23:30:16 <EvanCarroll> is folding over an inf list bad?
23:30:33 <FunctorSalad> not if it's a foldr
23:30:56 <FunctorSalad> but it should eventually not use the recursive result ;)
23:31:08 <EvanCarroll> well, that only makes it possible.
23:31:15 <EvanCarroll> does it make it good practice?
23:31:29 <FunctorSalad> > foldr (\a r -> if a==10 then [] else a:r) [1..]
23:31:43 <FunctorSalad> bot!
23:33:24 <Veinor> EvanCarroll: it's perfectly fine as long as you know for sure that your fold function will ignore its second argument eventually
23:34:59 <copumpkin> prove it!
23:35:24 <EvanCarroll> Veinor: that's not what I was getting at
23:35:49 <EvanCarroll> can you generally  rewrite folds overinfinite lists with something like `iterate` or some other preelude function?
23:35:55 <Veinor> ah
23:36:09 <EvanCarroll> my fault, bad original question
23:36:16 <copumpkin> EvanCarroll: a fold over an infinite list is just giving you recursion
23:36:46 <EvanCarroll> so is a fold over an inf list better written as a recursive function?
23:36:57 <EvanCarroll> which one do you find cleaner?
23:37:30 <copumpkin> well, as a recursive function you might be able to use a nice existing function
23:37:36 <copumpkin> like the one we were talking about before is an unfold
23:37:49 <dibblego> EvanCarroll, only foldr will work on an infinite list and it *is* general recursion for a list
