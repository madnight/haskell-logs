00:12:13 <vipex> hi I subscribe to Haskell-Cafe mailing list, there'are option: Receive (daily) diggest? (Yes, No) --> what that mean?
00:12:40 <solrize> if you say no, then every time someone mails to the list, you get sent a copy, this can happen many times a day
00:12:56 <solrize> if you say yes, then the list software saves up all the messages every day and sends them all to you in one email
00:13:48 <vipex> oh ok thanks
00:14:18 <solrize> np
00:25:56 <vipex> hi, is any confinience way reading mailinglist archive? somebody told me there're a software for read milist archive
00:29:24 <Starfire> vipex: I think at least some of the mailing lists are mirrored at fa.haskell on Google Groups.
00:32:13 <ksf> vipex, gmane
00:32:22 <ksf> use your favourite nntp client
00:33:28 <ksf> http://news.gmane.org/gmane.comp.lang.haskell.cafe
00:34:28 <ksf> in general, http://gmane.org/about.php
00:35:10 <vipex> ksf: ok thanks :)
00:35:30 <vipex> Startfire: thanks
00:44:13 * ksf misses pineapple news from beos
00:44:28 <ksf> the only nntp client ever that did not have any flaws at all and rocked like hell.
00:48:58 <blackdog> ksf: is nntp still a going proposition?
00:50:12 <ksf> "going proposition"?
00:52:06 <BMeph> ksf: Will that client be in Haiku? :)
00:52:32 <ksf> haiku will stick with binary compability to beos until it's out of beta.
00:53:07 <ksf> ...although they do have an incompatible, additional abi right now, based on a newer gcc
00:53:21 <ksf> tbh, c++ just sucks when you write an os api.
00:54:14 <ksf> so, yes, pineapple should run just fine under beos
00:54:30 <ksf> but I don't feel like firing up a virtualbox for it
00:54:34 <blackdog> ksf: just surprised people still use nntp.
00:54:56 <ksf> why shouldn't people?
00:55:00 <blackdog> the web seems to have consumed most specialty protocols.
00:55:14 <ksf> it's vastly superiour to smtp when it comes to mailing lists and stuff, and...
00:55:20 <ksf> web forums truly suck.
00:55:32 <blackdog> google groups isn't that awful
00:55:48 <blackdog> and you don't get that weird thing with messages missing & out of order
00:55:50 <ksf> it's still outside of my mail client
00:56:19 <blackdog> true. RSS etc is geared for read-only, i suppose.
00:56:34 <ksf> you're supposed to sort them by date and thread...
00:57:05 <ksf> X-No-Archive is not so bad as you might think. most don't even know it exists
00:57:24 * blackdog just came up with a gensym algorithm with exactly 26 possible symbols, and isn't as ashamed of it as he probably should be.
00:57:25 <ksf> and wrt. gmane, messages don't expire there
00:58:04 <ksf> you can xover over centuries of messages, there.
00:58:32 <blackdog> ksf: oh, i wasn't thinking x-no-archive - i just remembered messages coming in out of order and being confused. long time since i hung out on rec.games.roguelike.angband or the computer chess group, though... sort of miss the scary devil monastery.
00:59:05 <ksf> irc messages also come in out of order, that's what multithreading gets you.
00:59:53 <Zao> IRC lacks global ordering in the network too.
00:59:54 <ksf> it's not noticeable in modern times, anymore, except when there's a serious server malfunction, which usually doesn't happen
01:00:01 <Zao> Which makes things even more amusing.
01:00:02 <blackdog> i've never seen a reply come in before a message in IRC, though.
01:00:03 <ksf> lags are just too imperceptably
01:00:30 <blackdog> NNTP servers tended to batch deliberately, didn't they?
01:00:43 <ksf> in the very olden days, certainly
01:00:59 <ksf> they synced via dialup directly to other servers, after all
01:01:08 <ksf> usenet predates the other internets.
01:04:39 <osfameron> that's good!  keeps the numbers down!
01:08:06 <ksf> yeah the eternal september seems to be over, despite google.
01:09:54 <olsner> about time! over here, september ended about 9 months ago
01:10:50 <ksf> things were better when you knew that you'd enrage half the internet when you top-quote in a usenet message.
01:11:34 <c_wraith> I thought people got upset over top-posting, not top-quoting. :)
01:11:46 <olsner> in my book, complaining about top-posting is about a 100 times worse offense than top-posting
01:11:52 <ksf> yeah, they de.
01:11:53 <ksf> o
01:11:58 <c_wraith> A) top-posting
01:11:59 <c_wraith> q) What's the most annoying thing on usenet?
01:12:10 <c_wraith> as the old joke goes :)
01:13:03 <fasta> Not replying to the right message is kind of annoying, but IMHO, a good client should be able to detect this. It is a technology problem which happens to be solving problems caused by incompetent users. 
01:14:10 <fasta> That is I think people create a new message with all the internal information to keep track of the message deleted with as subject Re: <foobar>. I don't know the details, because it is not something I care about and I make sure I don't make the mistake :)
01:14:15 <ksf> the registration process should involve a message exchange in which the human has to demonstrate being able of proper quoting.
01:16:50 <earthy> usenet was unix to unix copy in the olden days
01:17:01 <earthy> which could even do 'dialup' over IP. :)
01:17:36 <earthy> plus, nntp servers still tend to batch deliberately. :)
01:18:27 <earthy> oh, and google groups is basically nntp accessed online.
01:18:36 <earthy> at least, that's what it stems from.
01:19:32 <vipex> Hey, what do you think about OCaml?
01:19:44 <vipex> Caml supports functional, imperative, and object-oriented programming styles. --> WOW
01:20:16 * ksf would right now like to have a use case of a cache of fd's pointing to real files that doesn't involve sticking my code into combinatorrent
01:20:32 <ksf> it's also impure
01:20:42 <ksf> and french.
01:20:47 <vipex> impure? what is?
01:21:18 <ksf> it freely mixes side-effectfull stuff and non-side-effectfull stuff
01:21:23 <ksf> thus, it's also strict
01:21:39 <ksf> also, it's syntax sucks
01:21:46 <ksf> its.
01:22:03 <vipex> :D
01:22:16 <vipex> have tried it before choosing Haskell?
01:22:24 <vipex> have u*
01:22:25 <ksf> briefly, yes
01:25:41 <vipex> somebody in mailing list say "OCaml are heavily used in financial domain"
01:26:10 <ksf> in automated trading, yes
01:26:32 <Gracenotes> that seems to be the case, and Haskell in places for financial backend stuff as well
01:26:37 <vipex> And he said about memory leaks in haskell http://jlouisramblings.blogspot.com/2010/04/haskell-vs-erlang-for-bittorent-clients.html
01:27:10 <Gracenotes> for my personal use, it's largely the syntax that bothers me. that's Wadler's law for you though
01:27:34 <ksf> well, lazy languages sometimes leak space, strict languages almost always leak time
01:27:52 <vipex> ksf: hehe, money is there (trading)
01:28:51 <ksf> ocaml's type system is also inferior
01:28:55 <fasta> All these stories about memory leaks in Haskell simply mean memory leaks by the programmer, unless he actually found problems in the RTS (which there have been too and might still be).
01:29:11 <ksf> ...though it's still better than anything you're likely accustomed to
01:29:12 <fasta> ksf, polymorphic variants are not in Haskell
01:29:33 <fasta> OCaml is certainly not dominated by Haskell. 
01:29:48 <ksf> but at the very least outcommunitied.
01:30:00 <ksf> and we have hlist
01:30:04 <fasta> It's a bad thing to choose a language based on the community. 
01:30:13 <fasta> HList is a non-integrated piece of research. 
01:30:32 <fasta> Typically after a development like that it should get into a compiler.
01:30:51 <fasta> That hasn't happened yet and everyone kept arguing for years about what is the "best". 
01:31:04 <ksf> I don't think that will happen before there's a solution to the expression problem
01:31:09 <fasta> The fundamental problem being that Haskell is not extensible. 
01:31:20 <fasta> Like e.g. Qi is. 
01:31:43 <fasta> The static part of Qi is in a lot of ways better than Haskell. 
01:32:15 <fasta> But nobody uses Qi because of the "community problem".
01:32:55 <fasta> It also seems that Clojure is the new hype, but AFAIK, Clojure doesn't add anything new or interesting. 
01:32:57 <pastorn> fasta: what's the "community problem"?
01:33:08 <fasta> pastorn, not having any. ;)
01:35:20 <eevar2> fasta: clojure does offer a very mature ecosystem
01:36:59 <vipex> hmmm, clojure running on JVM & CLR, i wouldn't use them
01:37:35 <fasta> eevar2, it provides a very specific ecosystem, which is not necessarily applicable to all problems. 
01:37:36 <eevar2> there's also scala, if for some reason you think multiparadigm is the way to go. but that's JVM too
01:37:46 <fasta> eevar2, e.g. for embedded programming it is basically useless.
01:38:46 <Raynes> vipex: Why not?
01:39:28 <ksf> scala is very good at what it's meant for, that is to replace java
01:39:33 <HugoDaniel> hello
01:39:42 <pastorn> sup?
01:39:43 <Raynes> If you don't mind the JVM, and the application domains of the JVM aren't a hindrance, Clojure is pretty awesome.
01:40:08 <ksf> both of them could even be the slow death of java
01:40:22 <Raynes> I don't think "it's not perfect for everything" is necessarily a downfall. I don't know of many languages that can say they are.
01:40:28 <ksf> which always suffered from lack of innovation
01:40:28 <HugoDaniel> when java dies we will all go to the funeral and throw a big party
01:40:31 <Raynes> s/many/any/
01:40:36 <ksf> and that's not going to get better now sun's dead.
01:40:52 <HugoDaniel> sun is not dead
01:40:57 <HugoDaniel> they just smile with a different face
01:40:58 <ksf> java is not half as bad as it's usually supposed to be
01:41:04 <ksf> that is, it's vastly better than c++
01:41:09 <vipex> haha
01:42:43 <vipex> tunning-up java applications (hardware specific) require tunner skill
01:43:10 <Zao> "tuning"
01:44:13 <Gracenotes> yay for module cycles I have to draw in kolourpaint to figure out - http://i.imgur.com/MqwGB.png
01:44:17 <vipex> i have pay $2000 to make our customer'd server works as it is (Sun Sparc)
01:44:30 <vipex> that just for tunning the JBOSS & Oracle
01:44:48 <Gracenotes> the arrow to get rid of, I think, points from Core -> ServerParts
01:44:54 <vipex> if you leave them default you'll get damned slow response 
01:45:16 <fasta> vipex, that sounds like a good myth to make money.
01:45:17 <ksf> Gracenotes, you know, there's packages that do such stuff for you
01:45:26 <Gracenotes> in fact, I need to get rid of ServerParts altogether :/
01:45:31 <ksf> ...and can draw professionally looking arrows.
01:45:38 <mreh> Core -> ServerParts -> Package -> Packages
01:45:50 <mreh> and repeat
01:45:57 <vipex> fasta, yes it is
01:46:01 <vipex> :D
01:46:05 <Gracenotes> mreh: yeah, the thing about graphs is that it makes it ridiculously easy to spot
01:46:17 <Gracenotes> ksf: packages to.. draw pretty graphs? :o
01:46:33 <ksf> and html pages, too.
01:46:47 <ksf> full reports full of text and graphviz output
01:46:48 <mreh> can't graphviz handle such a graph?
01:46:58 <ksf> very, very nice and enterprisey.
01:47:25 <Gracenotes> well, to be to truly enterprisey you need to do them by hand 
01:47:37 <ivanm> mreh: I don't see why it can't
01:47:43 <ivanm> it might not look like that though
01:47:45 <Gracenotes> mainly I don't want to see a graph with 40 modules in it just to find a cycle
01:47:53 <ivanm> since it tries to avoid crossing lines, etc. (unless you fiddle with it a lot)
01:48:06 <ivanm> Gracenotes: what kind of graph are you dealing with?
01:48:10 <Gracenotes> as dot is not great at cycles in the first place, and its edge uncrossing algorithm often leaves much to be desired
01:48:12 <mreh> what's the tool called again? the one to drawn haskell graphs
01:48:20 <Zao> vacuum?
01:48:20 <ivanm> SourceGraph ?
01:48:24 <mreh> @google visualising haskell
01:48:25 <lambdabot> http://www.youtube.com/watch?v=X4-212uMgy8
01:48:25 <lambdabot> Title: YouTube - Vacuum: visualize Haskell data structures live
01:48:29 <ivanm> Zao: that's for heap allocations
01:48:30 <mreh> @google visualising haskell universe
01:48:32 <lambdabot> http://donsbot.wordpress.com/2009/03/16/visualising-the-haskell-universe/
01:48:32 <lambdabot> Title: Visualising the Haskell Universe ¬´ Control.Monad.Writer
01:48:43 <ivanm> there's also modgraph or something which just does module visualisations
01:48:44 <Gracenotes> ivanm: well, the mainly the one I just drew to find the cycles in this particular region of modules :)
01:49:01 <ksf> Gracenotes, http://hackage.haskell.org/package/graphmod
01:49:05 <mreh> graphmod
01:49:10 <ivanm> ksf: yeah, that's the other one
01:49:13 <mreh> damn!
01:49:16 <Gracenotes> even though GHC listed the sequence, it helped to check the import statements themselves to see *why* they were needed
01:49:24 <fasta> Gracenotes, what package contains the best implemented algorithms then? 
01:49:24 * ivanm thinks SourceGraph produces nicer looking graphs though, in his completely unbiased opinion :p
01:49:34 <Gracenotes> and truly, an automated import-graph tool cannot understand human emotion
01:49:43 <ivanm> Gracenotes: SourceGraph can find cycles for you
01:49:48 <fasta> ivanm, didn't you reimplement some graphviz algorithms?
01:49:56 <ksf> there's also pkggraph
01:50:24 <ivanm> fasta: I've got an idea how to do tred
01:50:25 <ksf> ah, sourcegraph.
01:50:33 <Gracenotes> but anyhow. crisis averted.
01:51:03 <ivanm> pkggraph doesn't seem that robust though
01:51:12 <ivanm> for starters its deps need constraining on Cabal at least
01:51:29 <ksf> sourcegraph is great.
01:51:40 * ivanm is also considering how to split out the call-graph generation from the visualisation/analysis part of SourceGraph into its own library
01:51:42 <ivanm> ksf: thanks! :D
01:51:55 <ivanm> I'd hack on it more, but some people keep wanting me to hack on other things instead...
01:52:47 <Gracenotes> most graph-drawing algorithms work only on DAGs
01:53:11 <Gracenotes> and need cycle-removing heuristics otherwise, which tend to be meh much of the time
01:53:14 <ivanm> Gracenotes: circo, sfdp, etc. don't count then? :p
01:53:42 <Gracenotes> I'm ignoring them because they don't look much prettier than the cycle-removing heuristics >.> or maybe I'm feeding them the wrong graphs
01:54:12 <ivanm> Gracenotes: you need to feed them undirected graphs for them to work properly
01:54:24 <ivanm> i.e. graph { foo -- bar } as opposed to digraph { foo -> bar }
01:55:02 <Gracenotes> oh, it's syntactically/semantically okay.. just not in layout
01:55:20 <ivanm> if you want alternatives, have a look at tulip and maybe ubigraph
01:55:31 <ivanm> (though ubigraph is only free for personal use rather than being FLOSS)
01:59:42 <Gracenotes> after using pgf/tikz frequently, I'm more of a fan of positioning things manually for moderately sized graphs (1-20 nodes)
02:00:20 <Gracenotes> but not too manually -- specifying relative locations (above left of, right, below) rather than coordinates
02:01:59 <ksf> jlouis, you there?
02:03:57 <jlouis> ksf: sure
02:04:56 <ksf> I'm currently doing fd caching, and just realized that I'd have to treat sockets as untouchable without application support
02:05:38 <jlouis> ksf: what do you need?
02:05:49 <ksf> that's what I'd like to ask you...
02:05:57 <jlouis> haha
02:06:04 <jlouis> what is your problem then? 
02:06:25 <ksf> some way in which combinatorrent could tell me what sockets can be closed 
02:06:40 <jlouis> ah, yes
02:06:49 <jlouis> do you know how I do it in etorrent?
02:07:00 <ksf> nope
02:07:01 <jlouis> http://jlouisramblings.blogspot.com/2010/05/adding-support-for-more-than-1024-files.html is the blog post about that
02:08:11 <jlouis> I think we should go for somewhat the same idea
02:08:23 <ksf> yeah, I can do lru easily, and that's what I plan to do for the fds that correspond to files
02:08:35 <ksf> but I assumed that it's a bit more complex with sockets
02:08:42 <jlouis> it is
02:09:34 <jlouis> have not given it much thought. I think you need to draw some statistics and then kill off peers which are "boring"
02:09:41 <ksf> ...I'm doing fifo for the pipe buffers, which are interchangeble and hopefully completely drained before they hit the front of the queue, again.
02:09:58 <ksf> otherwise, stuff will block a bit and thus a new one will be created.
02:10:26 <ksf> I was more thinking of an interface to do that
02:10:31 <jlouis> another thing is that it is worthwhile to try to keep some peers up for each running torrent
02:11:31 <ksf> would peer ratings get reset on a reconnect?
02:11:39 <jlouis> yes
02:11:55 <jlouis> there is no rating per se, but reconnections have considerable overhead
02:12:07 <jlouis> if you disconnect a peer, you plan to keep it disconnected for a while
02:12:10 <ksf> can we estimate the rating we have with another peer?
02:12:20 <jlouis> not at the moment, no
02:12:36 <jlouis> but it should not be too hard to draw up that statistic
02:14:48 <jlouis> I envisioned the peer manager to do such calculations originally
02:14:56 <jlouis> or rather, do the hard work :)
02:15:12 <jlouis> each peer control process will have the necessary data avilable
02:16:30 <ksf> hmmm probably combinatorrent should just register a callback that would get a list of sockets, number of pipes and a list of file-backed fd's and return a list of what should get killed
02:16:43 <zygoloid> jlouis, ksf: you could fork off another process if you want more fds :)
02:17:10 <jlouis> zygoloid: blasphemy! :)
02:17:33 <zygoloid> 'course, that's nowhere near as cool as what you're planning, so as you were ;-)
02:17:51 <jlouis> ksf: yes, you need some information on the fd's, sockets, etc to decide what to kill
02:18:50 <jlouis> perhaps it can be solved differently
02:19:09 <jlouis> each peer could just close itself down if it deems itself quasi-dead
02:19:26 <ksf> but that might not be necessary
02:19:57 <ksf> I've got 101370 max fd's system-wide (that's the default), and people might have increased their per-process limit
02:20:48 <jlouis> Perhaps, we could have a manager and ask that one if it is necessary to close down
02:21:07 <ksf> so unless we've got one or two really, really generous peers and over 1024/3 files to write to, we shouldn't need to close sockets.
02:21:37 <jlouis> right
02:22:04 <jlouis> hmm
02:22:33 <jlouis> I don't think sockets happen to be a really hard problem
02:22:40 <jlouis> or worrying problem
02:24:30 <jlouis> there is an upper limit on these for the whole system
02:24:47 <jlouis> and you should be rotating torrents if you have more than three in queue anyway
02:25:45 <jlouis> I am somewhat worried by non-progression if we only have access to peers who can't send us anything, but I am also worried about continuous reconnections
02:28:49 <blackdog> i seem to be doing "do ok <- someMonadicAction; if ok ..." a lot. is there a better pattern?
02:29:07 <ksf> like ktorrent, which happily uploads gigabytes to peers without bothering to rotate to peers that are interesting?
02:30:16 <ksf> cap c a p = if p then c else a
02:30:25 <ksf> someMonadicAction >>= cap ...
02:30:53 <koala_man> ksf: from a naive point of view, that's the optimal thing. find peers with good download rates and push as much as you can do them
02:31:11 <ksf> yep but they weren't sending anything.
02:31:33 <ksf> ...and then I end up manually kicking peers because ktorrent doesn't.
02:31:40 <koala_man> ah, if it's not seeding then yes. that sucks.
02:31:42 <blackdog> ksf: right, just turning if into a function. fair enough, thought there might be a standard combinator.
02:31:47 <blackdog> thanks
02:31:53 <zygoloid> @type ?someMonadicAction >>= flip when ?someThing
02:31:54 <lambdabot> forall (m :: * -> *). (?someMonadicAction::m Bool, Monad m, ?someThing::m ()) => m ()
02:32:12 <zygoloid> blackdog: ^^ when is pretty close, but takes a Bool rather than an ma Bool
02:32:15 <zygoloid> *m
02:33:02 <ksf> oh, you can do ifM p c a = p >>= cap c a, of course.
02:34:06 <blackdog> yep. am just trying to avoid reinventing stuff that's idiomatic, i've done that enough
02:34:10 <zygoloid> where does the name 'cap' come from?
02:34:20 <ksf> consequent, alternative, predicate.
02:34:26 <ksf> argument order.
02:34:37 <ksf> pca is ordinary if.
02:34:46 <ksf> pac would be inverted if.
02:35:39 <ksf> I'm thinking about adding functional versions, that take an a and  (a -> Bool)
02:38:51 <ksf> ...I'm constantly inventing some combinator or the other, and fail to collect them into a module
02:38:59 <zygoloid> @type if' <$> ?somePredicate >*< ?thenCase >*< ?elseCase
02:38:59 <ksf> they're usually too trivial to do so
02:39:00 <lambdabot> forall a (f :: * -> *). (?somePredicate::f Bool, Functor f, ?thenCase::a, ?elseCase::a) => f a
02:39:04 <ksf> nothingIf True _ = Nothing
02:39:04 <ksf> nothingIf _ x = x
02:39:25 <zygoloid> ksf: fwiw i call that <?>
02:39:42 <ksf> and wouldn't be worth naming if it weren't for the fact that they unclutter something else.
02:40:28 <ksf> ...and that's another reason not to import them from somewhere.
02:40:37 <blackdog> ksf: yeah, exactly. if it's not totally idiomatic and obvious to other coders, i'll probably just fold the logic into the function, it doesn't seem to clear them up that much anyway.
02:41:02 <ksf> just keep the definitions nearby
02:42:32 <ksf> monadic code usually degenerates to cps with me
02:42:44 <jlouis> ksf: I don't know much about what ktorrent does. But most clients are notoriously bad at handling peers
02:43:00 <jlouis> combinatorrent and etorrent are rather naive, but it seems to work quite well
02:43:10 <blackdog> i think i'm probably actually less productive with haskell - i get a first version written fast, but i'm haunted by the possibility that there's an elegant one-liner.
02:43:30 <ksf> just feed the whole program through @pl and you've got one.
02:44:27 <ksf> I think you shouldn't worry if hlint doesn't shout at you.
02:45:46 <ksf> speaking of hlint. it's complaninig about  f `fmap` m = m >>= return . f
02:45:55 <ksf> daring me to replace the rhs with fmap.
02:49:02 <Blkt> good day everyone
02:51:50 <zygoloid> good day
02:52:56 <zygoloid> ksf: sounds like good advice to me (though i'd write it <$>). unless you don't have a Functor instance?
02:53:30 <ksf> I don't, I'm defining it
02:53:40 <ksf> ...for a transformer
02:53:45 <ksf> to be precise an iteratee
02:54:30 <ksf> and as the types would be the same on the lhs and rhs using fmap would be an infinite loop
02:55:31 <ksf> the only other possibility would be to duplicate a lot of code from the >>= instance
03:26:20 * ksf got a mental block
03:26:45 <ksf> if I close those fd's and recreate them by path, SOMEBODY MIGHT HAVE MESSED WITH TEH FILES!
03:27:42 <p_l> you can register for monitoring them in between
03:27:57 <ksf> and I wouldn't be able to do anything about it.
03:28:21 <ksf> If I wouldn't close those fd's they'd still be valid even when the files are deleted.
03:28:39 <ksf> (not that that's particularily useful from a whole system pov)
03:29:09 <p_l> ksf: make a temporary dir on the same filesystem then hardlink them?
03:30:00 <ksf> you don't understand, there's just no way to go about that on unix and have it be referentially transparent
03:31:01 <fasta> ksf, can't you use the rights system to do that?
03:31:15 <ksf> and then along comes root
03:31:20 <p_l> ksf: what exactly are you trying to accomplish?
03:31:41 <ksf> getting over perfectionism?
03:32:00 <p_l> ...
03:32:04 <Zao> The fundamental "problem" is that someone can replace a file you have open, so if you reopen a file with the same name, you have no guarantee that it's the same file.
03:32:20 <Zao> The only way to reliably get another fd to a file is to dup it.
03:32:27 <ksf> currently, it's about multiplexing multiple sockets to mulitple files
03:32:41 <ksf> though the code as it is should easily work into the other direction, too.
03:32:55 <ksf> (aka a file server)
03:33:23 <ksf> Zao, but the reason I'm closing them is not to run out of them.
03:33:57 <jon_k> how would I go about pretty printing a file format where continuation-lines start with a character ("|" for example) and the same level of indentation? any ideas?
03:34:35 <ksf> there's some indentation pretty printing stuff in HugesPJ etc.
03:34:48 <Zao> ksf: I suspected as much.
03:34:53 <ksf> Text.PrettyPrint.*
03:35:11 <jon_k> i already checked on that but did not see how it would allow for lines (and only auto-wrapped lines) to start with some kind of prefix.
03:36:09 <ksf> if in doubt, do the pretty-printing first and then wrap lines
03:36:10 <Zao> ksf: You could remember the inode of the file, then check the inodes of the file, and bail if it's not the same.
03:36:32 <Zao> Awfully hacky though.
03:36:43 <zygoloid> ksf: ok. in that case, i'd suggest fmap = liftM would be a nicer definition.
03:36:59 <ksf> at least warning combinatorrent that it should re-sha the file for chunks would be an idea
03:37:00 <zygoloid> liftM should really be what hlint suggests changing that to anyway...
03:37:05 <jon_k> maybe that's what i'll end up doing. but it breaks auto-wrapping.
03:37:32 <ksf> actually, that's quite easy with inotify
03:38:04 <jon_k> how feasible would it be to extend one of the pretty printers to include this? expecially in terms of portability? how would i go about doing this?
03:38:07 <ksf> zygoloid, heck, yes.
03:38:45 <ksf> I'm always ignoring liftM exactly _because_ it should be fmap.
03:39:04 <Zao> ksf: You should clearly just open the raw disk itself and eschew the use of those fancy "file handles" and "file systems".
03:39:25 <ksf> I'm actually considering that.
03:39:45 <ksf> well, backing the whole thing in a file and then providing a fuse/9p interface.
03:40:21 <ksf> ...which could lead to way better performance because of control over fragmentation
03:42:12 <ksf> linux filesystems and incomplete files are evil, anyway.
03:42:15 <ksf> beos does that right.
03:42:43 <ksf> ...where you don't need to ship a browser or such with a progress bar because the file manager can do that.
03:48:05 <zygoloid> {-# DERIVE instance (Monad m) => Applicative m = myTHDeriveFunction ''m #-}
03:50:22 <zygoloid> or even: {-# DERIVE instance (Monad m) => Applicative m = [d| instance (Monad $m) => Applicative $m where pure = return; (<*>) = ap |] #-}
03:50:38 <zygoloid> would be really handy :)
04:02:30 <earthy> beos and filesystem. dang, that's newspeak right there. ;)
04:02:58 <earthy> (ofcourse, Dominic Giampaolo did interesting stuff)
04:10:40 <cizra> When trying to compile qthaskell with --enable-shared, I get "cannot satisfy -package OpenGL-2.4.0.1", although I believe it's installed (not sure it's shared as well!). Where to begin investigating?
04:11:06 <cizra> oh my, my opengl is out of date
04:11:55 <mjk> It'very good if haskell supports chinese(not only IO supports chinese)!
04:12:12 <ManateeLazyCat> mjk: What's problem with Chinese?
04:12:39 <ManateeLazyCat> mjk: What do you mean "not only IO supports Chinese" ?
04:13:06 * ManateeLazyCat qthaskell is unactivited...
04:13:32 <mjk> ManateeLazyCat: Can I use chinese?my english is poor
04:13:41 <ManateeLazyCat> mjk: Yes.
04:13:59 <ManateeLazyCat> mjk: Maybe you can query to me . :)
04:14:19 <mjk> –ª–ª
04:15:38 <mjk> ManateeLazyCat: ±»»Á”√getLine >>= putStrLn,¥”øÿ÷∆Ã®»°µ√µƒ ‰»Îø…“‘÷±Ω”œ‘ æ÷–Œƒ£¨µ´ «»Áπ˚÷±Ω””√putStrLn "º∆À„ª˙",æÕœ‘ æ¬“¬Î¡À
04:15:48 <ManateeLazyCat> cizra: If qtHaskell make you crazy, you can try to use gtk2hs, a active project and have many developers to support it. :)
04:16:04 <ManateeLazyCat> mjk: Do you use Linux?
04:16:15 <jon_k> should I rather try to patch the needed functionality into my local version of an existing pretty printer or roll my own one (that is limited to what I need)? :-)
04:16:21 <cizra> ManateeLazyCat: hmmm. How many have lost their sanity? IIRC Qt was quite nice
04:16:47 <ManateeLazyCat> mjk: Best, don't write Chinese at this channel. You can /query to me or write English.
04:16:53 <mjk> ≤ª «£¨ «window XP
04:17:25 <ksf> cizra, qt is problematic because it's c++-based
04:17:34 <ManateeLazyCat> cizra: I'm not mean Qt, is qtHasekll, qtHaskell author looks disappear and don't response user's feedback.
04:17:51 <ksf> and c++ is a bugger to interface to, unless you use c++ _and_ use the same compiler, version and moon phase.
04:17:55 <ManateeLazyCat> cizra: Like ksf said, C++ is big problem on ABI.
04:18:00 <mjk> ManateeLazyCat: Œ“”√gtk2hs∞¥≈•ø…“‘œ‘ æ÷–Œƒ£¨µ´ «»Áπ˚µ•ª˜¥˙¬Î «¿Ô∫¨”–÷–ŒƒæÕ¬“¬Î
04:18:10 <cizra> hmmm, OK. Thanks for the input.
04:18:15 <cizra> ksf: ^^
04:18:18 * ksf isn't seeing any chinese, it's all mojibake
04:18:26 <ManateeLazyCat> mjk: I think you need some encode/decode process.
04:18:48 <ManateeLazyCat> ksf: If you want see Chinese, i can flood this channel ... :)
04:19:12 <mjk> ManateeLazyCat: Œ“»Á∫Œ”√encode/decode,ªÚ’ﬂencode/decode‘⁄ƒƒ∏ˆƒ£øÈ¿Ô
04:19:57 <ManateeLazyCat> mjk: ‰Ω†ÊúÄÂ•ΩÁ≤òË¥¥‰Ω†ÁöÑ‰ª£Á†Å. (English: You best to paste your code).
04:20:21 <ManateeLazyCat> mjk: ÂèØËÉΩÊòØÂÖ∂‰ªñÈóÆÈ¢ò (Maybe the other problems you haven't noticed)
04:22:38 <ManateeLazyCat> cizra: Because qtHaskell is unactived, some problem will crazy you and noone can help you.
04:22:54 <mjk> ManateeLazyCat: main = do putStrL "÷–Œƒ≤‚ ‘"
04:23:44 <cizra> ManateeLazyCat: thanks for the tip. I'll look into gtk2hs.
04:23:56 <mjk> ManateeLazyCat: main = do putStrLn "÷–Œƒ≤‚ ‘"
04:24:13 <ManateeLazyCat> mjk: No problem with me, btw, perhaps the encoding problem of Windows XP, since it use gb2312
04:24:29 <ManateeLazyCat> mjk: I'm use utf8 locate on Linux, no problem with Chinese.
04:25:12 <ManateeLazyCat> cizra: Make "~/.cabal/bin" in your PATH, then do "cabal install gtk2hs-buildtools && cabal install gtk" will install newest gtk2hs.
04:25:34 * ksf thinks we should decommission #yi and redirect traffic here.
04:25:47 <Ke> heh irssi identifies chinese utf-8 as ISO-8859-1
04:25:49 <mjk> ManateeLazyCat: ø…ƒ‹ «XPµƒŒ Ã‚£¨µ´ «IO∂¡»°µƒ’˝≥£:°„) 
04:25:58 <ksf> at least here there's always enough lurkers to console people for not getting any answers.
04:26:13 <ksf> that's not utf-8
04:26:26 <Zao> ksf: A keen observation.
04:26:27 <ksf> ManateeLazyCat is sending utf-8, I'm seeing proper boxes there
04:26:47 <ManateeLazyCat> ksf: Do you have any Chinese font in your system?
04:27:02 <ksf> yes, but xchat isn't falling back on them
04:27:10 <Zao> I echo ksf, ManateeLazyCat has proper UTF-8 IRC, while mjk is sending mojibake.
04:27:19 <ksf> at least a large chunk of characters, that is.
04:27:28 <ManateeLazyCat> ksf: maybe it's the problem of xchat
04:27:35 <ManateeLazyCat> ksf: That's not support utf-8
04:27:45 * ManateeLazyCat I use erc. :)
04:28:15 <mjk> ManateeLazyCat: Can you see the msg that I sent in Chinese?
04:28:27 <ManateeLazyCat> mjk: Yes.
04:28:40 <ksf> Êàø
04:28:58 <ManateeLazyCat> ksf: Are you Japanese?  
04:29:08 <ksf> hey I just pasted that.
04:29:22 <ksf> they look all the same, to me.
04:30:00 <ManateeLazyCat> ksf: Áé∞Âú®ÊàëÁöÑÁºñÁ†ÅÊòØ UTF-8Ôºå ‰Ω†ÂèØ‰ª•Ê≠£Â∏∏ÁúãÂà∞ÂêóÔºü
04:30:48 * ManateeLazyCat Now i'm use utf-8, can you see it normally. ^^
04:31:05 <HugoDaniel> i just updated the bytestring pkg
04:31:10 <zenzike> I'm using pandoc to spit out some files, and their encoding is being changed from utf-8 to latin1, even though my LANG environment variable says en_US.UTF-8. Does anybody have a suggestion as to what might be going on?
04:31:23 <HugoDaniel> and i keep getting this error: Couldn't match expected type `bytestring-0.9.1.5:Data.ByteString.Internal.ByteString' against inferred type `BS.ByteString', is this related ?
04:31:35 <ksf> everything you sent seems to have been transmitted correctly. I can definitely see chinese characters when I change the font...
04:31:54 <Zao> ManateeLazyCat: Everything you've sent has been parsed correctly here.
04:32:04 <Zao> Of course, irssi does some fairly intelligent guessing.
04:32:04 <ManateeLazyCat> HugoDaniel: BS is for "Data.ByteString" ?
04:32:14 <HugoDaniel> yes ManateeLazyCat
04:32:15 <HugoDaniel> hmm
04:32:24 <ManateeLazyCat> HugoDaniel: Your error is clear. :)
04:32:31 <HugoDaniel> i just did a ghc-pkg hide on the bytestring 0.9.1.6 :/
04:32:38 <HugoDaniel> it works
04:32:43 <ManateeLazyCat> HugoDaniel: :)
04:32:48 <HugoDaniel> fugly :/
04:33:23 <ManateeLazyCat> ksf: Yes, you can't see it if you haven't correct Chinese font to support it.
04:33:25 <HugoDaniel> i dislike bytestrings and encodings and the way everybody avoid utf-8 :/
04:34:05 <ManateeLazyCat> ksf: I recommend you use ÊñáÊ≥âÈ©ø-ÂæÆÁ±≥Èªë font, a free and complete Chinese font.
04:34:21 <ManateeLazyCat> ksf: If you use Debian system, do "sudo aptitude install ttf-wqy-microhei -y"
04:34:34 <ksf> well, I wouldn't be able to read any of it, anyway.
04:34:57 <ManateeLazyCat> ksf: ttf-wqy-microhei support CJK font well, and more important it's free font. :)
04:35:23 <ManateeLazyCat> HugoDaniel: Or use Text?
04:35:36 <mjk> how to uninstall the module use "cabal instal Encode"?
04:35:42 <ksf> I can read latin, cyrillic and a bit of greek and that's it.
04:36:14 <ManateeLazyCat> mjk: ghc-pkg unregister encode-VersionNumber
04:36:25 <mjk> ManateeLazyCat: thanks
04:36:49 <ManateeLazyCat> mjk: Infact, you can't uninstall any package that install by Cabal.
04:37:10 <ManateeLazyCat> mjk: command "ghc-pkg unregister" use to unregister package from ghc database.
04:37:30 * ManateeLazyCat Cabal haven't uninstall command.
04:37:49 <ManateeLazyCat> I'm glad to see have some Chinese guys use Hasekll. :)
04:37:51 <mjk> ManateeLazyCat: ’‚—˘ª˙∆˜¿Ô≤ª «æÕ¡Ùœ¬¿¨ª¯Œƒº˛¡À¬£ø
04:38:12 <mjk> ManateeLazyCat: :D 
04:38:29 <ManateeLazyCat> mjk: Â¶ÇÊûú‰Ω†ÁúüÁöÑÊúâÊ¥ÅÁôñÔºå Áõ¥Êé•Âà†Èô§ ~/.cabal ‰∏ãÈù¢ÁöÑÊñá‰ª∂Â∞±ÂèØ‰ª•‰∫ÜÔºå
04:38:56 <mjk> ManateeLazyCat: œ‘ æ¬“¬Î
04:38:58 <ManateeLazyCat> mjk: I'm always see  , maybe it's the problem of Windows XP.
04:39:03 <jkramer> Ahoy
04:39:23 <wlangstroth> yar
04:39:35 <jkramer> I was just wondering: Does Haskell reduce computations at compile time? For example, is reverse [1,2,3] reduced to [3,2,1] at compile or runtime?
04:39:41 <ManateeLazyCat> If anyone want to study Chinese, i can teach he. :)
04:39:56 <ksf> jkramer, not yet, no
04:40:00 <ksf> but it's soon to come
04:40:05 <ksf> ...soon as in soon(tm)
04:40:16 <jkramer> Hehe
04:40:18 <jkramer> Nice, thanks
04:40:26 <ksf> google for "supero"
04:40:53 <dv-> reverse [1..] hm
04:41:27 * ManateeLazyCat I'm reading the story of C-- and LLVM ... :)
04:41:44 <wlangstroth> LLVM is pretty amazing
04:42:18 <ManateeLazyCat> wlangstroth: From ghc's message, LLVM backend maybe intro in ghc-6.14 (next version), 
04:42:20 * ksf is grabbing a beer and enjoying watching the slovaks beat them sheepfuckers
04:44:11 <sinelaw> hehe
04:44:14 <jkramer> ksf: http://community.haskell.org/~ndm/supero/ doesn't load :)
04:45:05 * ManateeLazyCat I'm expect LLVM bring us a better ghc. :)
04:45:23 <ksf> yep community.haskell.org seems down
04:45:39 <ManateeLazyCat> ksf: It's always...
04:45:43 <ManateeLazyCat> down...
04:46:03 <ksf> try http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.107.7279
04:46:29 <wlangstroth> I think you can set --fllvm on 6.13 - I haven't tried it, though
04:46:43 <ksf> there's also a newer paper in the darcs repo, but you'd have to tex it yourself.
04:46:44 <sinelaw> http://www-users.cs.york.ac.uk/~ndm/downloads/paper-supero_making_haskell_faster-27_sep_2007.pdf
04:47:23 <ManateeLazyCat> wlangstroth: I will wait ghc-6.14 release, then try llvm backend.
04:47:25 <ManateeLazyCat> :)
04:49:15 <wlangstroth> I know there's at least one summer-of-code student working on it
04:52:39 * ManateeLazyCat After read ghc-llvm.pdf, i know what's mean of NCG (native code generator)... :)
04:54:15 <ksf> I think the main question is whether ghc will come with a custom version of llvm or all necessary changes will already be in upstream llvm
04:55:41 <wlangstroth> ksf: are Alp Mestanogullari or Maximilian Bolingbroke ever on #haskell?
04:55:55 <wlangstroth> (the guys doing the google summer-of-code llvm project)
04:55:56 <ManateeLazyCat> ksf: C backend more limit and trick, NCG make ghc developer's life not so happy. :) 
04:55:59 <ksf> if they are, I don't know their nicks.
04:56:05 <wlangstroth> right
04:59:36 <ManateeLazyCat> Infact, ghc has use NCG instead C backend? I'm not familiar with ghc status ....
04:59:52 <wlangstroth> edwardk: what was your motivation for Data.Void, completeness? Or does it come in handy somewhere?
05:01:12 <wlangstroth> ManateeLazyCat: pretty sure the C backend is deprecated in the next release
05:01:35 <ManateeLazyCat> wlangstroth: Happy to hear that. :)
05:02:00 <edwardk> wlangstroth: i needed it for some theoretical properties in category-extras
05:02:21 <edwardk> wlangstroth: alpmestan hops on from time to time
05:04:54 <edwardk> wlangstrong in particular to make Hask into a closed cartesian category, i needed a unit for (,) and Void is more correct than (). Though there are two notions of void, lets call them Unit and Void, and Unit would have been more appropriate
05:05:07 <edwardk> wlangstroth: gotta run, will chat more later
05:05:13 <wlangstroth> edwardk: ah, I see - thanks
05:07:32 <ManateeLazyCat> Why need STG between Core and C ?  
05:07:45 <ManateeLazyCat> Some ghcer explain it?
05:09:09 <ManateeLazyCat> I read ghc-llvm.pdf, and found STG between Core and C--....
05:10:11 <earthy> hysterical raisins.
05:11:07 <wlangstroth> the reasoning around the  STG: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
05:11:34 <wlangstroth> edwardk is my nerd hero
05:14:03 <alpounet> wlangstroth, hi
05:14:05 <alpounet> i'm Alp
05:14:15 <ManateeLazyCat> Now i understand, LLVM is not backend to ghc, it's backend to C-- of ghc.
05:15:02 <wlangstroth> alpounet: hi Alp - we were just discussing llvm
05:15:23 <alpounet> yeah, just saw that
05:15:39 <alpounet> you don't have -fllvm with a vanilla GHC
05:15:49 <wlangstroth> oh, my mistake then
05:16:05 * ManateeLazyCat ghc-llvm.pdf give me clear framework about ghc and it's backend.
05:17:04 <wlangstroth> alpounet: is the code you're working on up somewhere?
05:17:16 <alpounet> wlangstroth, with David Terei's github GhcCodeGen repo, though, you have it... but you have to build GHC with that CodeGen in the sourcetree yourself.
05:17:37 <alpounet> wlangstroth, on github too. at the moment i'm patching the binding to the llvm API
05:17:39 <alpounet> i should push soon
05:17:45 <wlangstroth> cool - thanks!
05:17:52 <alpounet> and then i'll resume my work on the code generator
05:36:59 <mokrzu> hello, i wrote funtcion that exec. any other fun.. two times: "dual f = f . f" and now i try to write fun.. that execute other four times: "dual2 f = dual . dual $ f"
05:37:19 <mokrzu> why i have to use ($) character ?
05:37:46 <ksf> you could also use dual (dual f)
05:38:01 <ksf> $ is the same as a whitespace, but with a different precedence
05:38:05 <ksf> @src ($)
05:38:06 <lambdabot> f $ x = f x
05:38:11 <ManateeLazyCat> mokrzu: duality = dual . dual
05:38:25 <ksf> that, too.
05:38:26 <ManateeLazyCat> mokrzu: Or "dual2 f = dual $ (dual f) 
05:38:38 <mokrzu> ok, i tried
05:38:39 <Zao> Without the $, your code is   dual2 f = dual . (dual f)
05:38:45 <ksf> or dual2 = dual $ dual $ f
05:38:48 <Zao> Which is not what you want.
05:38:56 <ManateeLazyCat> mokrzu: So you can remove f at two-side, and replace $ with "."
05:39:22 <mokrzu> dual4 f = dual . dual f  - but it didn't work
05:39:22 <ManateeLazyCat> mokrzu: I recommend you always write "dual2 f = dual (dual f)"
05:39:33 <ManateeLazyCat> mokrzu: Then use hlint help you improve code.
05:39:45 <ksf> that's a useful advice, at least until you get comfortable with things.
05:39:56 <ManateeLazyCat> mokrzu: It's should be "dual4 = dual . dual" 
05:40:25 <mokrzu> ok, now i understand
05:40:27 <ksf> @pl dual2 f = dual (dual f)
05:40:28 <lambdabot> dual2 = dual . dual
05:40:39 <ksf> @unpl dual . dual
05:40:40 <lambdabot> (\ c -> dual (dual c))
05:40:49 <mokrzu> thanks
05:40:52 <ManateeLazyCat> mokrzu: $ use to remove ()
05:41:20 <ManateeLazyCat> mokrzu: So "dual2 f = dual (dual f)" equal "dual2 f = dual $ dual f"
05:41:57 <djahandarie> f (g x) == f $ g x == f.g $ x
05:42:31 <ManateeLazyCat> mokrzu: Because you got "dual2 f = dual $ dual f" you can replace "$" with ".", then you got "dual2 = dual . dual", just algorithm, not funtion argument "f" . :)
05:43:19 <djahandarie> And if you have something x = whatever x, you can remove the x on both sides. So in your case dual4 f = dual.dual $ f   is   dual4 = dual.dual
05:43:49 <ManateeLazyCat> mokrzu: If you don't understand those trick, i recommend you write normal format "dual2 f = dual (dual f)" and install hlint.
05:44:03 <ManateeLazyCat> mokrzu: hlint will help you a lot that how to improve your code. :)
05:44:31 <ManateeLazyCat> mokrzu: Use "cabal install hlint" install hlint.
05:46:06 * ManateeLazyCat I like Qt framework and rich widget, but i don't like C++ . :)
05:46:42 <mokrzu> ok, thank you for help
05:46:55 * ManateeLazyCat Special Qt's signal framework is better than Gtk+ one.
05:47:03 <ManateeLazyCat> mokrzu: You're welcome. :)
05:52:05 <cizra> ManateeLazyCat: Somewhat non-Haskell question: I created a simple GUI with glade-3, then tried to load it, got (test.hs:27623): libglade-WARNING **: Expected <glade-interface>.  Got <interface>.
05:52:26 <cizra> ManateeLazyCat: It seems that my glade doesn't produce the XML libglade expects.
05:52:54 <ManateeLazyCat> cizra: Download glade from darcs repo. Then you will found a "demo" directory that include many demos. :)
05:53:09 <ManateeLazyCat> cizra: In gtk2hs-0.11, we forgot add demos in package.
05:53:19 <tab> cizra: depends on the project file format i think. gtkbuilder or libglade
05:53:44 <ManateeLazyCat> cizra: In "glade/demo/" have many demos, you can look it. :)
05:53:55 <mokrzu> small problem, when i try to install hlint by caball i gets error "hlint-1.7.2 depends on haskell-src-exts-1.9.0 which failed to install.
05:54:23 <ManateeLazyCat> mokrzu: Paste all error ?
05:54:30 <wlangstroth> I just had hlint fail on Arch, too
05:54:35 <wlangstroth> (fine on os x)
05:54:50 <mokrzu> i use arch
05:54:55 <cizra> tab: Ahhh!
05:55:33 * ManateeLazyCat I never use glade or gtkbuild create my gtk2hs program. :)
05:55:38 <wlangstroth> mokrzu: something about the configure failing - I haven't figured it out yet
05:55:45 <cizra> tab: ooh, sexy, it works!
05:56:07 <cizra> ManateeLazyCat: Why? Do you create your UI in runtime, in code?
05:56:17 <ManateeLazyCat> cizra: Yes, 
05:56:27 <cizra> ManateeLazyCat: Any particular reason?
05:56:31 <dcoutts> using glade is perfectly ok
05:56:52 <mokrzu> error: http://dpaste.com/207513/
05:57:29 <ManateeLazyCat> cizra: Infact, my project not a special GUI program, it's multi-processes framework to contain any other GUI program, so glade and gtkbuilder nothing help. :)
05:57:46 <cizra> oh
05:58:12 <ManateeLazyCat> cizra: So i need use code generate "framework UI" dynamic.
06:00:37 <wlangstroth> mokrzu: try "cabal install happy" and then "cabal install hlint"
06:01:25 <ivanm> dammit, I missed edwardk
06:01:39 <ivanm> dcoutts: I thought glade was being deprecated (by gtk+)
06:01:48 <ManateeLazyCat> mokrzu: And make sure your "~/.cabal/bin" in your PATH, or build symlink for happy, otherwise can't found where the happy.
06:01:52 <tab> ivanm: the program itself no
06:02:00 <ManateeLazyCat> ivanm: gtkbuilder is new one.
06:02:30 <tab> glade knows how to build gtkbuilder format on current versions
06:07:10 <wlangstroth> mokrzu: let me know if that worked
06:09:50 * ManateeLazyCat brb
06:11:18 <mokrzu> wlangstroth: http://dpaste.com/207518/ 
06:12:03 <zachk> try adding ~/.cabal/bin to your path 
06:13:18 <wlangstroth> mokrzu: ditto to what ManateeLazyCat and zachk said - make sure ~/.cabal/bin is in your PATH
06:13:36 <dcoutts> sigh, we should just fix that cabal path issue
06:17:05 <quicksilver> dcoutts: you could automatically grep the IRC logs for cabal and somehow group the sentences by similarity and thus automatically work out the most recurring problems to prioritise ;)
06:17:28 <wlangstroth> quicksilver: haha - nice
06:17:55 <dcoutts> quicksilver: heh, though note that we do have a prioritisation system in the bug tracker
06:18:27 <aristid> i recently noticed that cabal upgrade is disabled
06:18:33 <dcoutts> yes
06:18:47 <dcoutts> and it's even more disabled in the development version
06:19:24 <fasta> I think dcoutts stated repeatedly that the behavior was broken. 
06:19:34 <aristid> dcoutts: why is upgrading hard?
06:19:37 <dcoutts> it's not broken as such, it's just not what people want
06:19:51 <dcoutts> people don't understand what they're getting
06:19:53 <fasta> dcoutts: that's what I meant. 
06:19:54 <aristid> is it the interference of distribution-provided packages like in ubuntu?
06:20:11 <dcoutts> aristid: no
06:20:30 <dcoutts> aristid: the problem is that it upgrades everything, and you don't want that, you only want to upgrade some things
06:20:59 <aristid> why?
06:21:09 <geheimdienst> it's because many packages don't pay attention to backwards compatibility, so an upgrade will break things often ... right?
06:21:12 <aristid> when i do sudo apt-get upgrade it also updates everything
06:21:14 <dcoutts> aristid: you don't want to upgrade the core packages that come with ghc
06:21:36 <aristid> dcoutts: then those should be version-locked, right?
06:22:08 <dcoutts> aristid: that might be one way to get more useful behaviour
06:23:21 <dcoutts> but until we implement something like that, the best thing to do is just turn it off
06:23:30 <dcoutts> using "cabal install" instead works fine
06:23:46 <dcoutts> the name "upgrade" is misleading anyway
06:23:53 <aristid> dcoutts: installing parsec 3 was surprisingly hard
06:24:00 <aristid> i had to manually append the version number
06:24:28 <dcoutts> aristid: that was on purpose though
06:24:36 <dcoutts> because by default you should get the default version
06:24:45 <fasta> Parsec 2 is supposedly more stable or whatever it is. 
06:24:56 <ivanm> fasta: used to be faster
06:24:58 <dcoutts> and if you want a non-default version you can say so, by doing cabal install 'parsec >= 3'
06:25:00 <aristid> but 3 has more shininess.
06:25:04 <ivanm> AFAIK parsec-3 is now just as stable and as fast
06:25:14 <fasta> If you want the transformer version you need version 3. 
06:25:16 <ivanm> but with less documentation because the miriad tutorials, etc. haven't been ported
06:25:22 <fasta> (which is usually what you want)
06:25:26 <dcoutts> the version in the Haskell Platform (and thus the distros) in version 2
06:25:41 <dcoutts> some distros used to ship only version 3, which was wrong
06:25:43 <ivanm> dcoutts: is that likely to be bumped now that 3.1 has fixed the performance issues?
06:25:57 <ivanm> well, gentoo ships both, which can be a right royal PITA
06:25:58 <dcoutts> ivanm: it'll need to go through the proposal process
06:26:08 <ivanm> dcoutts: *nod* but do you think it's likely?
06:26:31 <dcoutts> if the new authors/maintainers can demonstrate that it's as good as the old one, yes
06:26:56 <dcoutts> as far as I know, nobody has presented any evidence
06:27:20 <dcoutts> though I hear it's supposed to be good now
06:27:24 <ivanm> *nod*
06:27:31 * ivanm should hit the sack
06:27:32 <ivanm> g'night all
06:28:10 <ville> Anyone here with an example of  using Gtk2Hs ComboBox and the standard interface with it, not the one specialized for displaying text? All the examples I've managed to google up or look from the gtk2hs/demos/ use the text interface which leaves out the stage of adding a column to the combobox.
06:42:32 <zenzike> I've got the feeling that ghc is ignoring my locale settings: files are being produced by pandoc using latin1, when my LC_ALL and LC_CTYPE are set to en_GB.utf8, anybody got suggestions?
06:42:53 <ksf> dcoutts, I tend to do deep upgrades with portage
06:43:05 <ksf> otherwise, those world upgrades take forever
06:43:33 <dcoutts> ksf: it's got a whole system to manage that however, and QA
06:43:56 <ksf> of course, you need to slot stuff and keep doing deep updates even when just installing to keep stuff from drifting apart
06:44:12 <ksf> maybe that's the problem.
06:44:21 <ksf> i.e. cabal trying not to be a distribution
06:44:43 <ksf> I bet arch could use another package manager, it already has a dozen or so.
06:45:49 <ksf> what about prompting the user if there's more than one concievable way to upgrade?
06:46:04 <dcoutts> ksf: in portage, core packages are designed to be updated, with ghc they're just not
06:46:23 <dcoutts> even when it's possible in principle, they're not tested for that use case
06:46:40 <ksf> so pin them
06:46:53 <dcoutts> right sure, we just don't have that imlemented
06:47:41 <dcoutts> and we need a design for how pinning should work
06:47:55 <dcoutts> it's relatively straightforward in the resolver, but how should they be specified
06:47:57 <aristid> dcoutts: well there are package managers that are closer to what cabal wants to do than portage
06:48:02 <dcoutts> and how do you override it etc etc
06:48:11 <ksf> ~/.cabal/package.pin
06:48:27 <ksf> which also prompts things like ~/.cabal/package.use...
06:48:41 <dcoutts> ksf: though it has to be pre-populated with the sensible defaults, which depends on the ghc version
06:49:09 <ksf> $GHC/package.pin
06:49:12 <dcoutts> or perhaps we actually want to pin all the HP packages by default
06:49:54 <ksf> portage's masking works out quite well
06:50:09 <dcoutts> portage is a distro of course, it's got lots of people doing QA
06:50:17 <dcoutts> and doing the QA before uploading
06:50:25 <ksf> no they don't
06:50:36 <dcoutts> well, sometimes they don't do it well enough :-)
06:50:45 <ksf> qa is done by putting stuff online and removing a ~ in case packages go without bugs for some time.
06:51:03 <dcoutts> I used to be a gentoo developer, we did do QA :-)
06:51:32 <dcoutts> ksf: you're talking about a second layer of "stabilisation"
06:51:38 <dcoutts> the ~arch vs arch thing
06:51:51 <dcoutts> there's basic QA done before the package is even uploaded
06:52:27 <ksf> I don't think that was the case in the beginning
06:52:38 <dcoutts> they got stricter over time
06:52:58 <ksf> back in the good olde days, one could actually shoot oneself in the foot without trying to.
06:53:12 <aristid> i don't think the gentoo model is particularly well-suited for imitation
06:53:50 <ksf> well they demonstrated how to start out with a small developer base
06:54:35 <ksf> and I think "rely on users to push stuff from unstable to stable" is a good idea.
06:54:52 <roconnor> aristid: what is the gentoo model?
06:55:22 <aristid> roconnor: uh, hard to say. i just know how it was when i used it
06:55:36 <aristid> with use flags and masks and ~amd64 vs amd64
06:55:38 <dcoutts> roconnor: you have a small team in charge of a bunch of packages covering some category of functionality. e.g. there's the web team and the haskell team.
06:55:39 <aristid> a huge mess :P
06:55:50 <ksf> I love it
06:55:59 <dcoutts> roconnor: they upload source packages and do QA
06:56:07 <aristid> ksf: well, maybe it's good for enthusiasts
06:56:08 <ksf> it means that you can install something from unstable while keeping your core packages stable
06:56:11 <aristid> but i prefer ubuntu now.
06:56:25 <ksf> ...and cabal users are going to be of that kind
06:56:32 <aristid> ksf: i don't think so
06:56:42 <aristid> cabal users are haskell enthusiasts
06:56:46 <aristid> not packaging enthusiasts
06:56:53 <ksf> exactly. and gentoo users linux enthusiasts.
06:57:09 <dcoutts> roconnor: it's a relatively traditional distro model, the main difference is it's primarily source based so it allows somewhat greater flexibility and customisation.
06:57:14 <MacMagnus> does anybody see whats wrong with this code? it wont compile.... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26212#a26212
06:57:22 <aristid> many linux enthusiasts do NOT want to use gentoo.
06:57:30 <roconnor> dcoutts: I understood that, but I think aristid was refering to something more specific.
06:57:34 <ksf> cabal users are going to want to be able to install an upgraded package fast, very fast, and not wait for upstream to sanction it.
06:57:53 <dcoutts> ksf: people want both, which is part of the problem
06:58:02 <roconnor> I was wondering if nixos has whatever property aristid was talking about.
06:58:07 <aristid> roconnor: well suffice to say, there is a reason why i switched away from gentoo. but it's too long ago to remember details, sadly
06:58:12 <ksf> ...which is the reason for ~foo vs. foo
06:58:21 <aristid> ah, nixos is certainly highly interesting
06:58:31 <roconnor> aristid: I'm using it
06:58:40 <ksf> at the very least one can learn proper filesystem layout from nixos
06:58:41 * hackagebot array 0.3.0.1 - Mutable and immutable arrays  http://hackage.haskell.org/package/array-0.3.0.1 (IanLynagh)
06:58:54 <aristid> roconnor: nixos is, from a theoretical perspective at least, "gentoo done right"
06:59:00 <dafis> MacMagnus, when you're using (==), you need an Eq constraint
06:59:19 <roconnor> aristid: that's how I think of it.
06:59:25 <roconnor> aristid: but I've never used gentoo
06:59:37 <ksf> aristid, make that "gentoo is used by linux enthusiasts"
07:00:07 <dafis> MacMagnus, but use pattern matching
07:00:23 <aristid> dcoutts: say, do you use cabal at work too? or do you use other deployment mechanisms?
07:01:10 <MacMagnus> dafis: i need to make a neew Maybe-type that "supports" Eq?
07:01:29 <dcoutts> aristid: yes, as for other mechanisms, I've used windows batch scripts that call cabal as a way to automate build+deployment
07:01:39 <dcoutts> aristid: i.e. nothing sophisticated
07:01:55 <dafis> MacMagnus, no, push :: Eq a => Maybe a -> [Maybe a] -> [Maybe a]
07:02:12 <dafis> MacMagnus, but really, use pattern matching
07:02:40 <dafis> push Nothing [Nothing] = [Nothing]
07:02:48 <dafis> push Nothing xs = xs
07:03:00 <MacMagnus> yes, Ill try that :)
07:03:02 <MacMagnus> thanks!
07:03:13 <dafis> push x [Nothing] = [x]
07:03:15 <aristid> dafis: this looks like a Monoid?
07:03:27 <dafis> push x xs = x:xs
07:03:29 <aristid> hmm no, it's a "deep" monoid
07:03:39 <dcoutts> aristid: I admit that I sometimes use makefiles that call ghc --make, when hacking, when there's a project with lots of executables. cabal's build does not yet let one specify a target exe / module, it only builds everything.
07:04:12 <dcoutts> aristid: I always use cabal for the final builds however
07:05:44 <aristid> dcoutts: so it's at least possible to use it for that
07:06:47 * hackagebot base 4.2.0.2 - Basic libraries  http://hackage.haskell.org/package/base-4.2.0.2 (IanLynagh)
07:06:59 <djahandarie> Nice
07:07:18 <dcoutts> aristid: sure, that's what it's really good for, it makes sure the build is fairly clean and repeatable with dependencies tracked ok.
07:07:47 * hackagebot bytestring 0.9.1.7 - Fast, packed, strict and lazy byte arrays with a list interface  http://hackage.haskell.org/package/bytestring-0.9.1.7 (IanLynagh)
07:11:41 <McManiaC> oi! gtk2hs made it onto hackage? :)
07:11:49 * hackagebot Cabal 1.8.0.6 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.8.0.6 (IanLynagh)
07:12:49 * hackagebot old-time 1.0.0.5 - Time library  http://hackage.haskell.org/package/old-time-1.0.0.5 (IanLynagh)
07:14:50 * hackagebot process 1.0.1.3 - Process libraries  http://hackage.haskell.org/package/process-1.0.1.3 (IanLynagh)
07:15:51 * hackagebot unix 2.4.0.2 - POSIX functionality  http://hackage.haskell.org/package/unix-2.4.0.2 (IanLynagh)
07:16:03 <McManiaC> do you guys prefer wxHaskell (?) or gtk2hs?
07:16:36 <Ke> wxgtk is almost obsolete
07:16:47 <quicksilver> that wasn't one of the options, Ke
07:16:57 <quicksilver> I don't think many people have used both, McManiaC 
07:17:11 <McManiaC> whatever wx* is the "most common" one
07:17:12 <quicksilver> I've used some wx and found it fine - it is a bit easier to get running native on a mac.
07:17:31 <McManiaC> I never did GUI programming
07:17:47 <quicksilver> (wxgtk is a particular backend for wxwindows)
07:18:29 <Ke> quicksilver: wxhaskell is wxgtk
07:18:34 <quicksilver> no.
07:18:43 <quicksilver> wxgtk is a particular backend for wxhaskell.
07:18:55 <Ke> same diff
07:18:58 <quicksilver> no.
07:19:18 <McManiaC> are there any differences regarding portability?
07:19:18 <quicksilver> they are different, and wxwindows (actually, wxwidgets is the name now) is in no sense "Almost obsolete"
07:19:25 <quicksilver> it is a current, actively developed project.
07:19:34 <quicksilver> McManiaC: well, as I said, wx works a bit better on the mac
07:19:45 <quicksilver> gtk on the mac requires you to run X11 which many mac users don't like doing.
07:19:51 <McManiaC> any experiences with windows?
07:19:59 <McManiaC> hmkay
07:20:01 <quicksilver> I'm sure they're both fine there. I've never used windows.
07:20:10 <ville> quicksilver: however hopefully the current codebase will soon be left behind at least as far as the API it offers for the C++ user.
07:20:40 * quicksilver has never been a C++ user
07:20:48 <quicksilver> but that sounds like a good thing, anyway.
07:21:17 <aristid> i heard Qt works relatively well on the mac
07:21:29 <ville> wx3 is something I'm looking forward to
07:21:31 <quicksilver> I've not heard many reports of qthaskell, though
07:21:37 <quicksilver> (although perhaps it works well)
07:22:15 <ville> Although right now Qt seems to be taking over with Nokia pushing it, as far as I can see developers wanted. Well here in Finland anyway.
07:22:34 <p_l> quicksilver: Qt is relatively hard to interop with
07:23:43 <p_l> it's slightly easier for "dynamic" languages when using SMOKE, but overall, I consider Qt to be one of the harder toolkits to interact with (especially since it has to use custom preprocessor)
07:24:00 <McManiaC> so basicly, theres no big difference between gtk2hs and wxhaskell? just a matter of... "taste"?
07:25:47 <dcoutts> McManiaC: as quicksilver said, it's actually rather hard to do a sensible evaluation, few people have used both, and it's not that useful for me to say "yes I use gtk2hs" :-)
07:25:51 <pastorn> McManiaC: wxhaskell has really nice bindings, but it's hard to get it to run :/
07:25:59 <pastorn> (all the dependencies etc.)
07:26:06 <fasta> McManiaC, it is unlikely that you find someone who has used both for more than a few months. 
07:26:44 <dcoutts> McManiaC: if it helps at all as a data point, I've used gtk2hs to make stuff for paying customers
07:27:13 <dcoutts> (and nobody complained "oh it doesn't look native")
07:27:23 <fasta> dcoutts: do you have any wxhaskell experience? 
07:27:42 <dcoutts> fasta: no, so I'm also no help in a comparison
07:27:57 <McManiaC> ok, but its not like wxhaskell/gtk2hs is kind of "deprecated" or old, buggy, anything
07:28:05 <fasta> I think it doesn't really matter that much. 
07:28:07 <dcoutts> fasta: I know a little about the wxHaskell API, I stole bits of it and implemented it in gtk2hs
07:28:30 <fasta> Probably wxwidgets was more popular than gtk+ for a long time. 
07:28:37 <fasta> That probably has changed now.
07:29:00 <fasta> From a legal point of view it is kind of nice that wxwidgets is BSD. 
07:29:24 <dcoutts> but it doesn't help much, since some of the backends are LGPL
07:29:32 <dcoutts> e.g. gtk+
07:30:15 <fasta> But on Windows you are not dependent on such code. 
07:30:30 <fasta> (which is what most people seem to care about)
07:30:50 <fasta> Not that what most people care about is important ;)
07:31:02 <arw_> where is the problem about lgpl?
07:31:37 <dcoutts> arw_: it's slightly more work to comply
07:32:03 <arw_> i can understand that gpl is a major problem, but lgpl is easy, except beeing a little more text to read than bsd...
07:32:11 <fasta> You basically have to list all the object files to make it possible to relink. 
07:32:20 <dcoutts> arw_: right, it's pretty simple
07:32:52 <dcoutts> you have to arrange for the client to be able to get the source of the LGPL bits, either by giving them the tarballs or giving them a promise that they can get them if they ask
07:33:08 <dcoutts> and it needs to be relinkable, which is easy for C shared/dynamic libs
07:33:24 <McManiaC> Loading package wxcore-0.12.1.6 ... linking ... <interactive>: /home/nils/.cabal/lib/wxcore-0.12.1.6/ghc-6.12.1/HSwxcore-0.12.1.6.o: unknown symbol `__dso_handle'
07:33:27 <McManiaC> ghc: unable to load package `wxcore-0.12.1.6'
07:33:27 <McManiaC> :O
07:33:29 <McManiaC> hm
07:33:58 <arw_> dcoutts: right, static linking would make it a little ugly.
07:34:02 <dcoutts> arw_: and for LGPL Haskell code, as fasta says, you need to provide your code in relinkable .o form. It can be one big .o file though, doesn't have to be individual .o files.
07:34:44 <dcoutts> arw_: I've done it, it's not hard. I just added some extra code in the Setup.hs script to link all the modules into one big .o file.
07:35:10 <fasta> I think it is one line of shell code ;)
07:35:33 <fasta> It is basically some practical boring knowledge that you need to get.
07:37:08 <arw_> hm, right. the linking problem makes it a little less easy than i thought. 
07:39:17 <dcoutts> arw_: it's really not hard, I can send you the few lines needed in the Setup.hs if it'd help
07:40:56 <arw_> no need, the app is gpl anyways.
07:41:28 <arw_> or rather "its gpl, but tell me if you want another license, i just picked that one at random"
07:42:04 <arw_> (and its internal stuff, so i don't think it will ever leave the premises ;)
07:42:47 <gwern> 'the license is a quantum superposition; don't look too closely or it may collapse to something you don't like'
07:43:54 <pastorn> McManiaC: as i said, it's hard to get it to run
07:44:05 <pastorn> you'll be chasing dependencies for *hours*
07:44:11 <McManiaC> hmm :(
07:44:37 <McManiaC> thats not what I've been looking for
07:44:37 <McManiaC> lol
07:44:42 <McManiaC> lets try gtk2hs‚Ä¶
07:44:48 <pastorn> if you're a good l1nuxx h4xx0r then you'll get wxhaskell working in ~4 hours
07:45:00 <pastorn> do that :)
07:45:08 <Ke> I said it was almost obsolete ;o)
07:45:36 <djahandarie> @elite I am a good linux hacker.
07:45:37 <lambdabot> i aM A 9ooD 1iNuX haxxER.
07:45:45 <Ke> I remember having quite a bit of technical difficulties when it was installed
07:46:04 <Ke> (but then again I'm known to have false memories)
07:46:08 <pastorn> Ke: you mean you actually managed to install wxHaskell?
07:46:21 <Ke> pastorn: wxGTK
07:46:31 <pastorn> i usually give up after 90 minutes version bullshit
07:46:42 <fasta> pastorn, heh, in 4 hours you can even do that on Windows compiled from source ;)
07:46:44 <Ke> wxhaskell should probably easy since gentoo has an ebuild for it
07:46:51 <pastorn> "you have this, but not *exactly* that version bla. bla. bla."
07:47:19 <pastorn> fasta: yeah, but in windows you don't have any dependencies
07:47:43 <fasta> pastorn, on Linux it is vastly easier, in my experience. 
07:48:20 <heropass> @elite logically sound conclusion
07:48:20 <lambdabot> |OGIc4l|y S0UnD c0NC1u5iOn
07:48:24 <pastorn> fasta: i'm only using lolbuntu, and i've never succeded :/
07:50:10 <gwern> they sailed away for a year and day / to the land where the Bong-tree grows
07:51:21 <McManiaC> dcoutts: did you use glade, too?
07:51:26 <McManiaC> or plain gtk2hs?
07:53:51 <dcoutts> McManiaC: I've done projects both ways
07:54:06 <dcoutts> McManiaC: glade is great for prototyping GUI design
07:55:58 <wlangstroth> ... and there in the wood ...
08:19:30 <c_wraith> woo.  hint is not threadsafe!  That explains so much! :)
08:34:00 <Saizan> heh, if hint was threadsafe we'd have ghc --make -jn by now :)
08:35:44 <fasta> The irony...
08:35:48 <gwern> c_wraith: so what did the error turn out to be and have you submitted a haddock patch yet?
08:38:16 <c_wraith> gwern, I have not.  I'm still working with daniel to determine whether something else is a bug that can be fixed, or an inherent limitation.
08:38:29 <chrisdone> hey dons what's a haskell postgresql driver that's stood the test of time for you?
08:38:46 <c_wraith> But a haddock patch is probably a very good idea, and I should do it.
08:38:50 <gwern> mm. well, don't forget about adding a warning then
08:39:43 <c_wraith> chrisdone: None are particularly good.  My co-worker is working on a proper non-blocking wrapper for libpq for other projects to use, but it's not done yet.
08:40:12 <chrisdone> c_wraith: what about takusen?
08:40:32 <c_wraith> like anything oleg's done, takusen confuses me. :)
08:40:52 <Saizan> takusen is the one that makes hpaste lock its database every now and then
08:41:13 <c_wraith> But I doubt he re-wrote the library binding, so it probably uses blocking libpq calls, which means it can tie up all the OS threads.
08:41:16 <chrisdone> Saizan: >_<
08:41:34 <andyjgill> Does anyone know the approved way of having cabal call configure? I'm trying to fix nanocurses.
08:41:42 <chrisdone> HDBC-postgresql is supposedly "stable" according to the hackage package
08:42:09 <c_wraith> hdbc-postgresql works well enough...  Just be aware that it does use blocking calls
08:42:20 <chrisdone> c_wraith: what does that mean?
08:42:25 <Saizan> andyjgill: iirc there's a "build-type: Configure"
08:42:53 <c_wraith> chrisdone: it means that it ties up an entire OS thread for the duration of the database request
08:42:58 <andyjgill> Ahh. I looked for documentation, but missed this one. I'll check it out.
08:42:58 <gwern> some people specify 'Custom' and call it from Setup.hs
08:43:02 <Saizan> c_wraith: doesn't -threaded prevent that?
08:43:35 <c_wraith> Saizan: As far as I understand it, using -threaded just lets you have up to N concurrent requests blocked.
08:44:28 * hackagebot freesound 0.1.0 - Access the Freesound Project database  http://hackage.haskell.org/package/freesound-0.1.0 (StefanKersten)
08:44:34 <Saizan> c_wraith: i had a different impression but i've not looked much into this
08:45:15 <Saizan> anyhow, i imagine a binding based on non-blocking calls would be more efficient anyway
08:45:18 <c_wraith> Saizan: well, it doesn't play nicely with the IO manager.  There must be a penalty for that.
08:46:07 <dcoutts> andyjgill: and the Setup.hs has to use the defaultMainWithHooks autoconfUserHooks rather than the defaultMain
08:46:29 <andyjgill> dcoutts: do you have an example package I could look at?
08:46:37 <dcoutts> andyjgill: and check that configure is really needed, cabal is reasonably good at checking for C libs and headers
08:47:04 <Saizan> network uses configure
08:47:16 <andyjgill> This is nanocurses, which I'm just trying to get built. Running configure by hand make it work.
08:48:21 <dcoutts> andyjgill: network or unix packages use configure
08:48:38 <dcoutts> andyjgill: is nanocurses something you're just trying to get working, or something you're packaging yourself?
08:49:08 <gwern> nanocurses is already packaged iirc
08:49:08 <andyjgill> Dons pointed me to it, but it fails to install. I offered to look at it for him.
08:49:21 <andyjgill> try cabal install nanocurses
08:49:35 * gwern did some work on nanocurses if memory serves
08:49:52 <dcoutts> andyjgill: if you're making improvements I can suggest how to eliminate the configure script, it looks pretty short
08:50:09 <andyjgill> Sure. We are happy to help.
08:50:12 <dcoutts> andyjgill: I see it currently says build-type Simple, which is why cabal ignores the configure
08:50:36 <andyjgill> dcoutts: (I've forward you the failure we are seeing)
08:50:57 <dcoutts> andyjgill: ok, delete the configure.ac :-) add extra-libraries: curses and includes: regex.h sys/types.h
08:51:14 <dcoutts> and don't bother with the PATCH_COUNT thing
08:51:46 <chrisdone> c_wraith: now i'm confused. why would it block the whole OS thread for a database request?
08:52:31 <chrisdone> c_wraith: it's communicating over a socket, so..
08:53:09 <dcoutts> andyjgill: so the error is due to some file asking for config.h, when configure did not get run so it's not built
08:53:25 <andyjgill> dcoutts: Its not generating the config.h (which comes from the config.h.in, which was what configure was doing)
08:53:35 <dcoutts> andyjgill: right
08:53:37 <andyjgill> dcoutts: Yes.
08:53:45 <Saizan> chrisdone: ghc can't preempt threads inside C calls
08:55:16 <chrisdone> Saizan: so launching a separate OS thread for DB and web site and communicating over channels is a solution?
08:58:04 <Saizan> chrisdone: i've this recollection that with -threaded GHC will already use a separate OS thread for blocking FFI calls, e.g. wait() works fine with -threaded even without passing "+RTS -Nn", though i've no idea how much that scales
08:58:15 <gwern> footnote 5: 'What a cheat!'
08:58:49 <dcoutts> andyjgill: I still get errors in the c code, getline clashes with a standard function from stdio.h
08:58:49 <gwern> hm. I wonder whether a funnelsort would be better than our current quasi-mergesort
08:59:07 <gwern> n*log n operations, and apparently much better memory locality as it's cache-oblivious
08:59:17 <andyjgill> dcoutts: Its a bit messy, yes.
09:00:16 <dcoutts> andyjgill: with that function renamed it all compiles ok for me, having deleted configure[.ac] and removed the #include "config.h"
09:00:20 <chrisdone> Saizan: hm. okay
09:00:31 <djahandarie> gwern, a funnel sort is just an n-way mergesort, no?
09:00:41 <dcoutts> andyjgill: death to autoconf :-)
09:00:47 <andyjgill> dcoutts:  :-)
09:01:10 <dcoutts> andyjgill: make sure you list includes: regex.h sys/types.h
09:01:13 <gwern> djahandarie: n^1/3-way mergesort, using something called a funnel to sort them
09:01:19 <dcoutts> andyjgill: and run cabal check, and do what it says
09:01:32 <chrisdone> Saizan: i'll try it and if i get problems i'll separate them with channels
09:01:53 <dcoutts> andyjgill: oh and purge the configure-related files from the extra-source-files list
09:02:09 <andyjgill> dcoutts: Will do, and will push
09:02:31 <gwern> 'Most cache oblivious algorithms rely on a divide and conquer approach. They reduce the problem, so that it eventually fits in cache no matter how small the cache is, and end the recursion at some small size determined by the function-call overhead and similar cache-unrelated optimizations, and then use some cache-efficient access pattern to merge the results of these small, solved problems.'
09:02:38 <gwern> good summary
09:04:04 <gwern> wish I knew where the nanocurses repo is
09:04:11 <gwern> I seem to've lost my copy
09:04:36 <andyjgill> dcoutts: getline is never used, anyway.
09:04:40 <heropass> @wn fardel
09:04:42 <lambdabot> *** "fardel" wn "WordNet (r) 2.0"
09:04:42 <lambdabot> fardel
09:04:42 <lambdabot>      n : a burden (figuratively in the form of a bundle)
09:06:58 <c_wraith> ok, anyone have suggestions regarding this:
09:06:59 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26225#a26225
09:07:18 <c_wraith> I know that I'm ignoring the case where action could result in an exception.
09:07:26 <c_wraith> Outside of that, is my approach flawed?
09:07:50 <dcoutts> andyjgill: nor openfd, nor forcenext
09:08:54 <dcoutts> andyjgill: which mean that includes list was bogus, you want curses.h, that's it.
09:09:00 <c_wraith> as a quick summary, my goal is to return the same result for multiple requests in quick succession.
09:09:11 <c_wraith> without calculating it multiple times
09:09:37 <andyjgill> dcoutts: It works for me with curses.h
09:09:45 <dcoutts> andyjgill: the configure was full of lies! :-)
09:10:22 <dcoutts> andyjgill: the reason to list the includes is so cabal can check they're present, it's not directly needed since it gets included via the utils.h in the .hsc file.
09:10:33 <chrisdone> hmm i've never looked into haskelldb for some reason. it looks really cool
09:10:47 <dcoutts> andyjgill: but it means users will get much better error messages when curses.h is missing
09:11:12 <andyjgill> dcoutts: Yes. Any false dependancies have been removed.
09:11:38 <andyjgill>  Module `Prelude' is deprecated:
09:11:45 <andyjgill> should I worry about this?
09:13:24 <dcoutts> andyjgill: see cabal check
09:13:41 <dcoutts> andyjgill: follow that advice and it'll resolve the issue
09:13:49 * dcoutts disappears to perform in a play...
09:14:26 <Saizan> c_wraith: so if some reader is late and the first buch of readers got served the action should run again?
09:14:36 <Saizan> c_wraith: *bunch
09:14:38 <c_wraith> Saizan, yes, that's my intention
09:14:39 * hackagebot bson 0.0.3 - BSON documents are JSON-like objects with a standard binary encoding  http://hackage.haskell.org/package/bson-0.0.3 (TonyHannan)
09:15:32 <c_wraith> This is to work with hint being not thread safe...  I want it to reload the action whenever it won't stomp on itself to do so.
09:16:39 <c_wraith> But I don't want to serialize incoming web requests completely, so I'm allowing those that come in in quick succession to share the same loaded action.
09:17:23 <Saizan> looks fine
09:17:40 <c_wraith> thanks.  It appears to work properly, I just wanted a sanity check. :)
09:18:27 <Saizan> heh :)
09:24:29 <McManiaC> dcoutts: what gtk lib creates a systray icon?
09:26:56 <arw_> McManiaC: GtkStatusIcon is the type you are looking for.
09:27:28 <McManiaC> thx
09:27:30 <McManiaC> :)
09:29:25 <stepcut> I am trying to do memory profiling. +RTS -s says that I had 128MB maximum residency, the .prof file says the total alloc was 3.5MB.. Why the big difference ?
09:31:08 <jmcarthur> isn't the former that maximum that was used at any point in time and the latter the total allocations over the entire execution of the program?
09:31:17 <jmcarthur> *the maximum
09:31:58 <stepcut> sure... But how did it use 128MB if it only allocated 3.5MB
09:31:59 <jmcarthur> oh wait...
09:32:02 <jmcarthur> heh
09:32:07 <jmcarthur> i dunno
09:32:25 <stepcut> the 3.5MB allocation seems unlikely
09:32:27 <jmcarthur> i didn't pay attention to the units. didn't realize they were the same
09:32:30 <jmcarthur> yeah
09:32:32 <stepcut> because it is processing a 128MB file
09:33:18 <sclv> is it useing bytestrings?
09:33:28 <stepcut> yes
09:33:44 <sclv> dunno if prof is going to count foriegn/pinned allocation
09:34:00 <jmcarthur> oh right. bytestrings use foreignptr, not bytearray
09:34:02 <quicksilver> bytestrings aren't "alloc"
09:34:07 <stepcut> ah
09:34:12 <quicksilver> they're not part of what the GC processes
09:34:19 <quicksilver> which is what those parts of the stats are really about
09:34:28 <jmcarthur> does the gc process bytearray?
09:34:33 <quicksilver> yes
09:34:43 <stepcut> well that is going to make it a bit trickier to squash this space leak
09:34:48 <jmcarthur> okay. just making sure i'm not completely imagining that
09:34:53 <stepcut> the -s output seems more correct though..
09:35:05 <stepcut> 136,062,948 bytes allocated in the heap
09:35:11 <quicksilver> stepcut: well, the GC is still tracking the actual ByteString objects
09:35:16 <quicksilver> just not the underlying data they point to
09:35:29 <quicksilver> so as far as the GC is concerned 
09:35:31 <stepcut> k
09:35:54 <stepcut> the profiling does show the ByteString growing over time, so I can just imagine that is multiplied some some larger factor I guess
09:36:39 <quicksilver> ...so as far as the GC is concerned, all bytestrings are 24 bytes or 48 or something
09:36:53 <quicksilver> irrespective of how big they are.
09:37:02 <stepcut> yeah
09:37:15 * jmcarthur wishes there was a way to inform the GC otherwise so it could collect at more appropriate times
09:38:45 <stepcut> I am using L.writeFile to save a lazy bytestring to disk. The lazy bytestring is being read from a network socket. For some reason the whole bytestring is getting read into RAM. Does this mean that someone must still be referencing the head of the bytestring somewhere? Or do I have unrealistic expectations as to how garbage collection should happen ?
09:39:05 <mux> are you using 6.12.2 ?
09:39:14 <stepcut> 6.13
09:39:21 <stepcut> why ?
09:39:26 <djahandarie> Is c.h.o down again? Sweet damn
09:39:36 <mux> mm, because there was a bug with hGetContents that has been fixed, and could cause such a behaviour IIRC
09:39:51 <quicksilver> stepcut: how are you reading the lazy bytestring from the network socket?
09:40:00 <stepcut> right. My could is actually using a local version of hGetContents that is supposedly not broken..
09:40:31 <quicksilver> ah, yes, I think you're just being optimistic about how often finalizers run
09:40:52 <quicksilver> finalizers don't have speed guarantees and 128M really isn't that much :)
09:41:01 <mux> oh. indeed
09:41:39 <stepcut> quicksilver: what if I think it is too much? How could I change my code to use less ?
09:42:22 <quicksilver> you can't
09:42:26 <quicksilver> finalizers are magic
09:42:30 <quicksilver> beyond your ken ;)
09:42:46 <quicksilver> seriously, I don't know what choices you have here.
09:42:52 <mux> isn't there a RTS switch for that?
09:42:56 <quicksilver> It is of course possible you are holding onto the head of the bytestring ;)
09:43:08 <stepcut> I mean, would using strict bytestrings and reading smaller chunks at a time be any different ?
09:43:20 <mux> that's basically what lazy bytestrings do :-)
09:43:41 <stepcut> mux: that is what I thought
09:43:45 <mux> they use non-blocking reads to get chunks which are just strict bytestrings
09:44:00 <stepcut> mux: so, using iteratees or something would not really help here ?
09:44:04 <mux> and offer an API on top of that to make them look like real bytestrings
09:44:14 <sclv> finalizers only run with GC, right?
09:44:34 <mux> stepcut: I'm not sure; if the finalizers are being run too late, you could maybe tweak that with RTS switches
09:44:35 <sclv> and GC runs less often than you would think, with bytestrings, because it thinks they are very tiny
09:44:39 <mux> but that's pure speculation on my part
09:44:43 <sclv> as I recall
09:44:56 <stepcut> sclv: yeah
09:44:56 <mux> but if, as quicksilver said, you're atcually holding onto the head of the bytestring, it won't help
09:45:05 <sclv> "oh? only 3.5MB allocated? no need to perform gc yet..."
09:45:19 <quicksilver> perhaps, although I think there is a wallclock timer to
09:45:27 <quicksilver> i think it always GCs at least N times per second
09:45:33 <sclv> So essentially you want a hacky way to force gc to run more often.
09:45:33 <quicksilver> certainly there are RTS flags for that
09:45:38 <stepcut> mux: right that is what I am trying to figure out. I seems that when my code just skips over a large chunk of the input, it is fine, it is only when it tries to write it to disk that there is a problem
09:45:39 <quicksilver> System.performGC is that
09:45:56 <quicksilver> System.Mem.performGC perhaps
09:46:00 <quicksilver> @hoogle performGC
09:46:01 <lambdabot> System.Mem performGC :: IO ()
09:46:16 <sclv> right -- if my hunch is right, then a combination of flags and performGC should do the trick. but so ugly :-(
09:46:33 <quicksilver> adding lots of performGC will at least demonstrate if this *is* the problem
09:46:37 <quicksilver> or if something else is wrong
09:46:40 <mux> or use Data.ByteString.Unsafe/Internals and call finalizeForeignPtr yourself? :-)
09:47:01 <stepcut> having a local copy of hGetContentsN is useful.. because I can just stick performGC right in the loop ;)
09:47:18 <mux> Iteratees should indeed ensure that memory is released in a timely manner, if they are used properly
09:47:37 <mux> I find them surprisingly complex though
09:47:38 <stepcut> performGC didn't help
09:47:59 <stepcut> mux: how would they help with this issue ? 
09:48:01 <djahandarie> Should Step 4.1 REALLY be making a parallel program in http://haskell.org/haskellwiki/Haskell_in_5_steps ?
09:48:21 <hpc> i think so
09:48:36 <hpc> although 4 should be more than a calculator
09:48:46 <mux> stepcut: there are standard iteratees that release the chunk as soon as it has been processed, and allocate it via low-level malloc-like functions
09:49:04 <mux> I don't remember the specifics
09:49:28 <stepcut> mux: so the iteratee does the malloc/free. But if it just used ByteString, then it would not really help ?
09:49:38 <quicksilver> correct, stepcut
09:49:49 <mux> sounds like it indeed
09:49:51 <stepcut> ok, that I can understand
09:49:57 <quicksilver> anyway, if adding performGCs didn't fix it then I think you've proved GC frequency is not your problem.
09:50:04 <quicksilver> it'd start to look for references to the list.
09:50:57 <djahandarie> Someone should make a "learn how to program" using Haskell as the language. Tailored entirely towards people who have never done any programming
09:51:13 <djahandarie> Then we can catch a bunch of people before they are corrupted by all those other paradigms. ;-)
09:51:34 <BONUS> so like a dumbed down LYAH? :D 
09:51:45 <BONUS> i dont know if it can be dumbed down anymore hehe
09:51:46 <stepcut> yeah, I don't have much. But I wonder.. I initially stick the bytestring in and IORef, and then if I want to write it to disk, I use atomicModifyIORef to get the bytestring, and I stick an empty ByteString in the IORef in its place.. but maybe that is not really working right
09:52:10 <djahandarie> BONUS, well, LYAH relates a ton of concepts to other programming languages, which would just be very confusing to someone who doesn't know those other languages.
09:52:20 <djahandarie> It wouldn't neccessarly be dumbed down, just written a different way
09:52:25 <BONUS> true
09:53:02 <djahandarie> I wish I could draw sweet images like you :P
09:53:10 <BONUS> :)
09:53:33 <mux> yeah, the LYAH art is just great
09:53:38 <mux> I went through it for the pics
09:53:44 <stepcut> actually.. there is another issue. the beginning of the bytestring contains some header information that I parse into a structure that I keep around. The rest of the bytestring is the body I want to write to disk. Maybe that is the problem. I need some way to tear the tail off the header information so that holding onto the headers does not also hold onto the tail ?
09:53:58 <mux> BONUS: if only you have had the courtesy to write that 5 years earlier! ;-)
09:54:29 <stepcut> I would think that using 'L.span' would achieve that though.. 
09:54:49 <sclv> stepcut: forcing the parsing to be strict would help?
09:57:31 <stepcut> sclv: I think it is 
09:57:55 <stepcut> sclv: you can't get at the body unless the headers have successfully be parsed
09:57:57 <stepcut> been parsed
09:59:18 <McManiaC> dcoutts: http://npaste.de/Xr/ am I missing anything here? that little programm always dies after poping up the menu
09:59:52 <Saizan> stepcut: with lazy bytestring holding to the headers would at worst hold into the respective chunks, not all of them.
10:00:22 <sclv> stepcut -- fully parsed, or could you be missing something? (another hacky test -- rnf the headers and see if it changes things)
10:12:59 * hackagebot fixed-precision 0.3.0 - Fixed Precision Arithmetic  http://hackage.haskell.org/package/fixed-precision-0.3.0 (EdwardKmett)
10:16:34 <edwardk> hrmm, there appear to be bugs in the hmpfr binding =/
10:16:34 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
10:16:41 <edwardk> @messages
10:16:41 <lambdabot> ivanm said 3h 44m 24s ago: in conversation with dcoutts, I'm really thinking that the whole dual-class approach is going to be too much of a hassle for little return and will probably not bother
10:16:41 <lambdabot> with it anymore unless you can come up with an actual real use case for it (and just coming up with your Iterated example doesn't count, since you haven't said _why_ you'd want to do that)
10:16:58 * edwardk shrugs
10:19:50 <edwardk> @hackage hmpfr
10:19:50 <lambdabot> http://hackage.haskell.org/package/hmpfr
10:23:16 <edwardk> Data.Number.MPFR.pi Down 256 ==> 3.141592653589793, Data.Number.MPFR.pi Down ==> ../get_str.c:151: MPFR assertion failed: size_s1 >= m Aborted
10:23:19 <edwardk> whee
10:23:42 <edwardk> guessing it has something to do with the fac tthat in general you can't FFI out to anything that uses GMP internally
10:39:19 <stepcut> ok. If I do my atomicModifyIORef in one liftIO request, and the L.writeFile request in a second liftIO call, then i get a space leak. But if I do them both in the same liftIO call, I don't..
10:39:24 <McManiaC> http://npaste.de/Xv/ <- did anyone manage to install gtk2hs on windows?
10:47:42 <jmcarthur> stepcut: what kind of transformer stack is it?
10:48:17 <stepcut> jmcarthur: giant.. uses ReaderT, ErrorT, MaybeT and WriterT 
10:48:22 <jmcarthur> eek
10:48:57 <jmcarthur> in that order?
10:49:46 <jmcarthur> eh nevermind
10:50:04 <jmcarthur> i don't even want to try working out what >>= looks like after unwrapping it
10:50:11 <stepcut> jmcarthur: :)
10:50:28 <sclv> that's freaking devilish
10:50:50 <stepcut> still, it's not clear to me why that would cause this :-/
10:51:13 <stepcut> hmm
10:52:52 <jmcarthur> @unmtl ReaderT r (ErrorT e (WriterT o IO)) a
10:52:52 <lambdabot> r -> IO (Either e a, o)
10:53:12 <jmcarthur> plus a Maybe in there somewhere
10:53:30 <jmcarthur> around the a?
10:53:42 <stepcut> one moment
10:55:16 <stepcut> @unmtl ReaderT req (ErrorT res (WriterT f (MaybeT m))) a
10:55:16 <lambdabot> req -> m (Maybe (Either res a, f))
10:55:24 <stepcut> that looks right
10:55:27 <jmcarthur> oh it has MaybeT in it
10:55:31 <McManiaC> lol
10:55:43 <jmcarthur> wow that's not very fun looking
10:55:49 <McManiaC> <3 stepcut 
10:55:49 <McManiaC> :D
10:55:53 <stepcut> jmcarthur: you're not supposed to look at it :)
10:56:21 <jmcarthur> i don't really see how two liftIOs would make bind space leak
10:56:22 <mtnviewmark> what is that? the "I'll have one of everything" Monad?
10:56:55 <jmcarthur> mtnviewmark: that would be RWS ;)
10:57:16 <mtnviewmark> I take one on rye w/mayo... omnomnom
10:57:27 <jmcarthur> @unmtl RWS r w s a
10:57:27 <lambdabot> r -> s -> (a, s, w)
10:57:56 <stepcut> mtnviewmark: ReaderT is so you can read the request, ErrorT is in case you encounter an 'error' and need to escape early with a different value, WriterT is used to filter the response, and MaybeT is used for it's MonadPlus-ness
10:58:01 <stepcut> ez
10:59:32 <jmcarthur> @unmtl RWST r w s (RWST r' w' s' (RWST r'' w'' s'' IO)) a
10:59:32 <lambdabot> r -> s -> r' -> s' -> r'' -> s'' -> IO (a, s, w, s', w', s'', w'')
10:59:37 <jmcarthur> :D
10:59:59 <jmcarthur> of course it has a simpler equivalent
11:00:46 <stepcut> with the single liftIO, I get the ByteString out of the IORef in the Request, and write it to disk in one pass. That all happens in the IO monad. With two liftIO's I read the ByteString out of the IORef in one pass, and then write it to disk in a second place. Perhaps something in that stack is holding onto the bytestring I guess
11:04:59 <stepcut> I could try each one by itself and see I guess
11:07:23 <McManiaC> from where do I get pkg-config >= 0.9.0 ?
11:10:10 <stepcut> actually, it is weirder. If I read the value the IORef and never use it, then it uses a bunch of RAM. But if I actually write the value to disk in that same liftIO, then it is ok..
11:12:52 <c_wraith> sounds like a pretty typical space leak.
11:13:44 <toki78> hi
11:13:53 <toki78> are there ODE bindings ?
11:15:45 <stepcut> c_wraith: yeah.. seems that atomicIORef is not really releasing the reference. If I do a readIORef on the ioref afterwards, and print the (now empty) string it contains, then the leak goes away
11:16:39 <stepcut> 'tis trouble
11:20:23 <sclv> toki: ODE solvers?
11:20:26 <burp> hmatrix
11:20:29 <burp> @ toki78 
11:20:59 <burp> it has gsl bindings
11:21:46 <sshc> I'm trying to figure out what the acronym "cf." could possibly represent in the context of Haskell documentation: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Monad.html#v:liftM
11:21:48 <sinelaw> @#$!
11:21:48 <lambdabot> Unknown command, try @list
11:21:56 <sinelaw> sshc, cite from
11:22:04 <sshc> Ah.
11:22:22 <sshc> Thanks
11:22:27 <sinelaw> :)
11:22:48 <sinelaw> i hate acronyms
11:22:51 <sinelaw> IHA
11:22:53 <sshc> I agree!
11:22:59 <sinelaw> WOT
11:23:02 <sinelaw> (waste of time)
11:23:08 <sshc> IHA?
11:23:38 <sshc> You know, you're not entirely convincing when you use them right after you say you hate them :)
11:23:46 <sinelaw> I Hate Acronyms
11:24:11 <sinelaw> as I said a minute ago
11:24:23 <sinelaw> :/
11:25:08 <sinelaw> I also hate when people use "tweetspeak"
11:25:19 <sinelaw> as if everybody in the world uses tweeter and likes it
11:25:34 <Tarrasch> Hi, why can't I write this:
11:25:37 <Tarrasch> > [(+2)] `zipWith ($)` [4]
11:25:38 <lambdabot>   <no location info>: parse error on input `('
11:25:51 <sinelaw> Tarrasch, you can't use that in a `
11:25:58 <McManiaC> `` can only contain one function
11:26:00 <McManiaC> no arguments to that
11:26:13 <Tarrasch> but isn't (zipWIth ($)) a function?
11:26:14 <sinelaw> > let zipThat = zipWith ($) in [(+2)] `zipThat` [4]
11:26:14 <lambdabot>   [6]
11:26:22 <sinelaw> Tarrasch, syntax limitations
11:26:36 <Tarrasch> sinelaw, ok, I see, Thanks everyone :)
11:26:54 <Philonous> Tarrasch: Hah, I'd love to see that in haskell, too 
11:26:57 <McManiaC> dcoutts: ping
11:27:11 <sshc> sinelaw: What is tweetespeak?
11:27:16 <sshc> I've never used Tweeter.
11:27:20 <sinelaw> nor have i
11:27:37 <sinelaw> but I ocassionaly have to try and decipher what others are trying to say
11:27:52 <sinelaw> and even if I already know, I don't like it
11:28:13 <sinelaw> keep it for tweeter, says me
11:31:16 <Mathnerd314> what makes cabal-install distinguish between per-user and global installations?
11:31:51 <Mathnerd314> cabal install cabal is user, but cabal install cabal-install is global...
11:31:59 <toki78> burp, no i mean Open Dynamics Engine
11:32:02 <McManiaC> setup.exe: pkg-config version >=0.9.0 is required but it could not be found. <- what am I missing? :(
11:32:04 <burp> ok
11:32:39 <toki78> burp, i want physics in my haskell program
11:33:34 * hackagebot threads 0.3 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.3 (BasVanDijk)
11:34:34 <McManiaC> I love hackage packages without haddock documentation :P
11:35:19 <burp> it just needs to be generated I think
11:35:23 <burp> with some delay?
11:39:17 <monochrom> You can build doc yourself.
11:40:02 <b52> Configuring cairo-0.11.0...
11:40:05 <b52> setup.exe: Missing dependency on a foreign library:
11:40:07 <b52> * Missing C library: z
11:40:08 <b52> any idea what could be wrong?
11:40:23 <burp> you're missing libz?
11:40:32 <burp> development headers
11:42:43 <jystic> @pl f a xs = route $ map (\(r, h) -> (r, h a)) xs
11:42:43 <lambdabot> f = (route .) . map . (`ap` snd) . (. fst) . flip ((.) . (,)) . flip id
11:48:44 <monochrom> apt-get install zlib1g-dev
11:50:49 <absentia> blue:  naw, lots of idlers here wit autojoin
11:51:04 <absentia> (sorry, missend)
11:51:49 <sclv> toki: there are a number of physics bindings, but not that one, I think
11:52:26 <sclv> oh wait, there it is: http://hackage.haskell.org/package/HODE
11:52:58 <sclv> a few different ones listed here: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:physics
11:54:04 <sclv> there's also this http://physics-dph.blogspot.com/, but I think roman got busy and went on to other things
11:57:37 <Twey> Hehe, hpysics
12:06:35 <edwardk> ARSERT? :)
12:07:20 <edwardk> we woops wrong channel =)
12:10:32 <aristid> hpysics oO what a name
12:11:16 <jbapple> my intuition is that Data.Sequence should be indexed by Integer instead of Int, since "Data.Sequence.replicate N v" takes only O(lg N) space
12:11:25 <Saizan> Mathnerd314: what do you mean by "cabal install cabal-install is global"? the default installation type is set in your ~/.cabal/config and doesn't change wrt packages
12:11:27 <jbapple> Am I nuts?
12:12:51 <jbapple> I mean, I only have 2G of RAM on this machine, but I can Data.Sequence.replicate N for very large values of N. Larger-than-the-number-of-protons-in-the-known-universe large
12:13:15 <Saizan> and rnf it?
12:13:46 <jbapple> Saizan: of course not
12:14:03 <jbapple> but if I wanted to rnf everything I would be writing ML
12:14:15 <Mathnerd314> Saizan: cabal install cabal-install installs to C:/Program Files/Haskell, while cabal install cabal installs to my profile
12:14:36 <Saizan> jbapple: yeah, but i'm not sure how strict indexing is
12:14:50 <jbapple> (I mean, I can't actually do the replicate, since replicate takes an Int. If I build my own replicate I can do it)
12:15:25 <jbapple> Saizan: It doesn't force any more than its path, which is O(lg n), again
12:15:41 <EvanR-work> :t genericReplicate
12:15:42 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
12:15:43 <sclv> ?ty replicate
12:15:44 <lambdabot> forall a. Int -> a -> [a]
12:16:22 <sclv> one could make the same argument for lists as well.
12:17:00 <EvanR-work> :t replicateM
12:17:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
12:17:01 <Saizan> jbapple: ok, i guess i just disagree with "Data.Sequence.replicate N v" taking only O(log N) space, doesn't it have O(N) nodes?
12:17:07 <EvanR-work> :t genericReplicateM
12:17:08 <lambdabot> Not in scope: `genericReplicateM'
12:17:26 <jbapple> sclv: Sure, but lists don't store their indices, while data.Sequence does
12:17:27 <sclv> > take 3 $ genericReplicate 1000000000000 "hi"
12:17:28 <lambdabot>   ["hi","hi","hi"]
12:17:43 <jbapple> Saizan: yes, but there is sharing
12:17:45 <edwardk> jbapple: Data.Sequence.replicate uses log n storage
12:17:58 <edwardk> jbapple: lowasser put in a patch a while back
12:18:05 <jbapple> edwardk: Yeah, that's what I'm saying
12:18:19 <jbapple> edwardk: A patch for Data.Sequence to use Integer?
12:18:35 <Saizan> Mathnerd314: ah, check the install-dirs in your config file
12:18:38 <edwardk> no, the patch to replicate using logarithmic space and sharing
12:18:49 <jbapple> seqPow 0 x = S.singleton x
12:18:49 <jbapple> seqPow n x =
12:18:49 <jbapple>     let xs = seqPow (n-1) x
12:18:49 <jbapple>     in xs S.>< xs
12:18:54 <jbapple> ^^ Saizan
12:18:58 <edwardk> oh you're saying that you should be able to replicate something huge
12:19:22 <EvanR-work> shouldnt replicate by O(1)
12:19:26 <jbapple> edwardk: I think you misunderstand me. That's my point. Since sharing is possible, Data.Sequences can grow huge in reasonable memory
12:19:28 <edwardk> submit a request for genericReplicate ;)
12:19:33 <jmcarthur> EvanR-work: how?
12:19:59 <jbapple> edwardk: I am thinking of making a request, but I thought I would sanity check here first.
12:20:10 <EvanR-work> replicate n x = x : (replicate (n-1) x)
12:20:19 <jmcarthur> EvanR-work: we're talking about Data.Sequence
12:20:27 <jbapple> edwardk: It's also not just a metter of a new function, like with lists, since Sequences have to actually store their indices as measures
12:20:34 <EvanR-work> is it not as lazy?
12:20:41 <jmcarthur> EvanR-work: it's not a list
12:20:45 <EvanR-work> so
12:20:49 <jmcarthur> it's a fundamentally different structure
12:20:51 <Saizan> EvanR-work: anyhow we're talking about space, not time.
12:20:51 <EvanR-work> its a trie or something
12:20:51 <edwardk> jbapple: ah, then in that case i'd probably reject you too ;)
12:20:56 <jmcarthur> no it's not
12:20:59 <edwardk> make Data.Sequence.Huge ;)
12:21:00 <EvanR-work> ok
12:21:02 <jmcarthur> it's a finger tree
12:21:03 <Saizan> EvanR-work: your replicate uses O(n) space
12:21:17 <EvanR-work> no it doesnt?
12:21:32 <Saizan> EvanR-work: you build N fresh cons cells.
12:21:32 <jmcarthur> well, it does if you fully evaluate it
12:21:40 <Saizan> EvanR-work: repeat is O(1)
12:21:43 <edwardk> Saizan: not until you come along and look at them =P
12:21:56 <EvanR-work> well what if i look at them with !!
12:22:01 <EvanR-work> i evaluate but dont need most of them
12:22:05 <EvanR-work> should be instantly reclaimed
12:22:06 <Saizan> well, ok, then seqPow is O(1) too :)
12:22:14 <jmcarthur> it will still create multiple cons cells
12:22:21 <EvanR-work> but they dont need to stay
12:22:22 <edwardk> EvanR-work: the problem there is you may or may not use O(n) space, depending on if someone else also holds a ref to the list
12:22:23 <jmcarthur> instead fo reusing them
12:22:33 <EvanR-work> hrm
12:22:37 <jbapple> EvanR-work: they might need to stay, so the GC won't necessarily reclaim
12:23:17 <EvanR-work> ok so it uses O(n) stochastic space
12:23:36 <jmcarthur> EvanR-work: anyway, Data.Sequence is basically a 2-3 tree where the leaves hold the elements of the list from left to right
12:23:49 <jbapple> EvanR-work: What is "stochastic space"/
12:23:50 <jmcarthur> there's more to it than that
12:24:05 <EvanR-work> i just made it up
12:24:28 <jbapple> Also, even deepSeq-ed, seqPow N would, I think, use O(lg N) space
12:24:43 <edwardk> EvanR-work: O(n) is a perfectly legitimate description of something even if it is also O(1)
12:25:04 <edwardk> O is just an upper bound on the worst case
12:25:14 <edwardk> it doesn't have to be a very tight bound
12:25:14 <jmcarthur> i usually say that the space complexity of a lazy structure is what it would be if it was fully evaluated
12:25:16 <danharaj> When people say O they usually mean \Theta
12:25:20 <jbapple> edwardk: If you allow that on IRC, you're going to have to correct everyone who says "o(n)" and means "O(n)" :-)
12:25:33 <edwardk> jbapple: that I do ;)
12:25:35 <jbapple> On IRC, O(N) and o(N) tend to both mean \Theta(N)
12:25:50 <Saizan> jmcarthur: yeah, especially when there's no surrounding context
12:26:00 <jmcarthur> who says o(n) instead of O(n)?
12:26:21 <jmcarthur> i don't know that i've ever seen that mistake on IRC
12:26:27 * EvanR-work suddenly pulls out big omega
12:26:28 <edwardk> jmcarthur: me neither
12:26:29 <jbapple> I've seen it many times
12:26:37 * Saizan neither
12:26:38 * edwardk shrugs
12:26:41 <jbapple> I've even seen edwardk do it
12:26:44 <Twey> I never have
12:26:46 <jbapple> I saw it on here last night
12:26:53 <sclv> but what is oO(n) ? :-)
12:27:00 <jmcarthur> o_O(n)
12:27:03 <Twey> Java
12:27:03 <EvanR-work> lol
12:27:09 <pastorn> lol
12:27:10 <Twey> It's so slow they have a special computation class for it
12:27:14 <gwern> sclv: it's thinking in horror of how you have an n-complexity algorithm
12:27:19 <gwern> when it should be log n
12:27:21 <ikke> T
12:27:27 <edwardk> jbapple: i challenge you to find a log of that ;)
12:27:27 <Twey> Haha
12:27:38 <ikke> ?
12:27:57 <jbapple> edwardk: of you saying it?
12:28:08 <sclv> ‡≤†_‡≤†(n)
12:28:08 <edwardk> yes =)
12:28:27 <jbapple> 2010-05-06.123429-0700PDT.txt:(08:44:30 PM) Edward Kmett: i also think o(1) concat and o(1) split are incompatible in the same way the o(1) insert and o(1) deleteMin are incompatible
12:28:42 <EvanR-work> ‚ò≠_‚ò≠(n)
12:29:37 <EvanR-work> communism class
12:30:12 <jbapple> 2010-06-14.115620-0700PDT.txt:(05:39:36 PM) gwern: kmc: when your target is c performance, o(1) and log n are worlds apart
12:31:00 <kmc> it depends if you're talking about problems or solutions
12:31:02 <sinelaw> EvanR, who's responsible for putting that symbol in the standard unicode set?!
12:31:03 <jbapple> everybody typos
12:31:15 <kmc> for a problem it's usually unwise to say \Theta, as someone might come up with a better algorithm
12:31:39 <edwardk> jbapple: hah you win ;)
12:31:41 <EvanR-work> sinelaw: the unicode people
12:31:48 <kmc> for algorithms you can usually provide an upper and lower bound
12:31:50 <sinelaw> the communist unicode people
12:31:51 <EvanR-work> alternatively, the ghost of stalin
12:31:57 <kmc> but i'm sure there are some exotic algorithms where the lower bound is not proven
12:32:39 <EvanR-work> complexity class is meaningless! you could write O(1) cure-all algorithm that effectively never completes
12:32:42 <edwardk> jbapple: maybe i was just being conservative. i mean its awfully hard to find o(1) algorithms ;)
12:32:44 <sclv> cf: http://blogs.msdn.com/b/michkap/archive/2005/01/29/363208.aspx
12:33:59 <sclv> heh -- this algorithm is dominated completely for very large values of one.
12:35:02 <wvd> Anyone ever worked with the 'llvm' package in Hackage? If so, did it work well?
12:35:02 <jbapple> kmc: The only known provably-asymptotically-optimal MST algorithm does not have a tight analysis yet
12:35:29 <sclv> wvd: I've only heard good things.
12:35:31 <edwardk> jbapple: the chazelle version?
12:35:32 <kmc> interesting
12:35:43 <danharaj> MST?
12:35:50 <c_wraith> minimum spanning tree
12:35:59 <jbapple> and it is known known yet if splay trees are even o(lg n) competitive
12:36:11 <Lemmih> wvd: It doesn't play nice with GHCi but otherwise it works pretty well.
12:36:12 <jbapple> edwardk: Pettie, I think
12:36:17 <EvanR-work> why is everyone suddenly saying o() >_<
12:36:23 <wvd> Lemmih: "doesn't play nice", as in?
12:36:31 <jbapple> (And yes, I mean little-o there)
12:36:45 <jbapple> splay trees ARE known to be O(lg n) competitive
12:37:04 <Lemmih> wvd: Doesn't work at all with GHCi.
12:37:25 <wvd> Lemmih: Just in the interactive prompt?
12:38:01 <jbapple> The original pairing heaps don't have a complete analysis yet, but Elmasry (I think) has a version with O(lg lg n) amortized decreaseKey
12:38:05 <Lemmih> wvd: Right, compiled programs using LLVM works just fine.
12:40:42 <Mathnerd314> is there a shorter way to write "a <- return 1" ?
12:40:50 <kmc> let a = 1
12:41:18 <kmc> or, replace a with 1 in the rest fo the code
12:41:19 <Mathnerd314> ok
12:41:54 <kmc> "<- return" is almost never useful
12:42:24 <c_wraith> Just x <- return Nothing
12:42:35 <c_wraith> still not useful, but in a different way!
12:42:37 <kmc> yeah, that's the one use case i can think oy
12:42:39 <kmc> of*
12:42:52 <kmc> if the LHS is a refutable pattern and you want to invoke "fail" implicitly
12:43:05 <danharaj> because implicitly failing is always fun
12:43:12 <kmc> > do { Just _ <- return Nothing; return 7 } :: [Int]
12:43:12 <c_wraith> I guess that's true.  It's not useful if Nothing is a constant, but if it's a variable it has meaning.
12:43:13 <lambdabot>   []
12:43:35 <jbapple> http://www.google.com/codesearch?hl=en&sa=N&filter=0&q="<-+return"++lang:haskell&ct=rr&cs_r=lang:haskell
12:43:39 <kmc> it's still a bit hackish
12:43:44 <jbapple> about 2000 hits
12:43:54 <c_wraith> It's very hackish.
12:43:58 <c_wraith> @src catMaybes
12:43:58 <lambdabot> catMaybes ls = [x | Just x <- ls]
12:44:20 <c_wraith> No, that's a different pattern.
12:45:08 <jbapple> even in GHC http://www.google.com/codesearch/p?hl=en#jysarkix6sg/compiler/main/GHC.hs&q=%22%3C-%20return%22%20lang:haskell&sa=N&cd=10&ct=rc
12:45:37 <kmc> some of these use cases look fishy
12:45:45 <kmc> not everyone who writes Haskell code indexed by Google is an expert
12:45:55 <Accidus> Let C be a category that is V-enriched (w.r.t. CCC structure in V), has V-powers and V-copowers. And if F -| G is a V-enriched adjunction, is the monad GF necessarily strong?
12:46:38 <Accidus> I have a paper that claims that if we replace V with the presheaf category for V, then it is, but no proof is given...
12:47:41 <jbapple> kmc: I agree
12:53:28 <c_wraith> does anyone, by any chance, have code that pretty-prints hint's InterpreterError type to html?
12:54:01 <caxapok> hi. where I can find "Real World Haskell" in pdf for printing?
12:54:34 <jmcarthur> i only know of the html and dead tree versions
12:54:45 <edwardk> @google real world haskell pdf
12:54:46 <lambdabot> No Result Found.
12:54:52 <edwardk> http://fldit-www.cs.uni-dortmund.de/~peter/RealWorldHaskell.pdf
12:54:57 <caxapok> jmcarthur: html isn't good for print...
12:55:09 <edwardk> but i think if you're going the dead tree route its nicer to the authors to just buy a copy ;)
12:55:12 <dons> caxapok: you'll need to get the ebookk for example
12:55:37 <jmcarthur> caxapok: well, ideally it is, but usually people ignore the criteria that would make it nice
12:55:41 <aristid> caxapok: if you need a printed version of real world haskell and you also want nice type-setting, just buy the damn book
12:56:07 <dons> there is a very nicely formatted ebook version in many formats
12:56:52 <caxapok> aristid: I live in Russia and buying is very high price :(
12:57:01 <jmcarthur> how high?
12:57:49 <jmcarthur> lol at your link, edwardk 
12:57:57 <caxapok> ~22 pounds + delivery
12:58:07 <c_wraith> 22 pounds?
12:58:25 <caxapok> edwardk: thanx. I download it now.
12:58:47 <edwardk> jmcarthur: i didn't actually attempt to follow it =)
12:58:57 <caxapok> c_wraith: ok, UK.
12:59:27 <jmcarthur> caxapok: that's a cheaper price than it is available for in america
13:00:01 <caxapok> edwardk: ohh. You PDF is simply html printed :( quility isn't good for print
13:00:15 <aristid> i paid more than 22 pounds
13:00:28 <jmcarthur> 22 pounds is not much for it, honestly
13:00:47 <caxapok> thanx
13:01:08 * edwardk thinks he was slightly annoyed at the pdf ;)
13:01:10 <dons> $39.99
13:01:11 <dons> (Android, Mobi, PDF, ePub)
13:01:15 <dons> on oreilly, apparently.
13:01:15 <jmcarthur> aw, i was going to offer a book trade
13:01:21 <aristid> i paid 38 euros
13:01:22 <dons> btu there's a $4 iphone app
13:01:40 <jmcarthur> a copy of RWH from america for a copy of Algebra of Programming... if he can track it down for a reasonable deal ;)
13:02:39 <aristid> jmcarthur: well, that opportunity window has closed ;)
13:03:34 <mreh> our GLUT binding is BSD3, but what is GLUT itself?
13:04:01 <jmcarthur> not open source
13:04:41 <arw_> could freeglut be used?
13:04:45 <jmcarthur> freeglut is under x-consortium license. i don't know anything about it
13:05:12 <jmcarthur> presumably i am using freeglut, not the closed-source, abandonware glut
13:05:39 <jmcarthur> oh, is x-consortium license the same as MIT license?
13:06:20 <jmcarthur> ah, it essentially is
13:06:24 <jmcarthur> so very permissive
13:06:36 <mreh> is that the X11 license?
13:06:52 <jmcarthur> i guess?
13:06:54 <mreh> non-communist
13:06:59 <jmcarthur> right ;)
13:07:03 <mreh> gooood
13:07:32 <pastorn> mreh: we can't have communist licenses?
13:08:02 <mreh> pastorn, you can do what you like, I'm not going to stop you
13:08:20 <djahandarie> I will.
13:08:23 * djahandarie takes out his bat
13:08:35 * pastorn hides
13:08:39 <pastorn> @slap djahandarie 
13:08:39 * lambdabot would never hurt djahandarie !
13:08:43 <pastorn> WTF!!??!?!?!
13:08:51 <jmcarthur> @slap pastorn
13:08:51 * lambdabot slaps pastorn
13:08:56 * pastorn cries
13:09:07 <jmcarthur> stop crying!
13:09:09 <jmcarthur> @slap pastorn
13:09:10 <lambdabot> Come on, let's all slap pastorn
13:09:20 * pastorn cries his eyes out
13:09:21 <mreh> @slap pastorn
13:09:21 * lambdabot smashes a lamp on pastorn's head
13:09:31 <pastorn> what is this? a public beating?
13:09:31 <jmcarthur> it just gets worse and worse
13:09:53 <pastorn> glith: help!
13:09:57 <mreh> it's public justice
13:10:22 <bremner> @waterboard pastorn
13:10:22 <lambdabot> Unknown command, try @list
13:10:25 <bremner> bummer
13:10:34 <pastorn> hehe
13:13:20 <djahandarie> Silly, it's not @waterboard, it's @enhanced_interrogation_techniques
13:13:42 <mreh> @definately_dont_torture pastorn
13:13:43 <lambdabot> Unknown command, try @list
13:13:57 <mreh> can't spell
13:14:06 <mreh> @slap mreh
13:14:07 * lambdabot slaps mreh with a slab of concrete
13:21:18 <sinelaw> @slap and kicks
13:21:18 * lambdabot slaps and kicks
13:21:20 <sinelaw> @slap and kicks
13:21:20 * lambdabot is overcome by a sudden desire to hurt and kicks
13:21:34 <sinelaw> @slap and puke
13:21:34 <lambdabot> stop telling me what to do
13:21:36 <sinelaw> ok.
13:21:55 <Mathnerd314> are there "forbidden things" that one should never do in Haskell?
13:22:06 <jmcarthur> unsafe*
13:22:20 <c_wraith> Woo, unsafeCoerce!
13:22:33 <Mathnerd314> those are just unsafe.... people do use them
13:22:47 <sinelaw> argh
13:22:48 <jmcarthur> only for FFI bindings, usually
13:22:54 <jmcarthur> or for language features that do not exist
13:22:59 <sinelaw> yeah
13:23:00 <jmcarthur> not for everyday code
13:23:10 <danharaj> average haskellers use average functions
13:23:37 <jmcarthur> i use a lot of unsafePerformIO because i write new language primitives and FFI bindings a lot
13:23:46 <jmcarthur> but most people should pretty much never have to
13:24:19 <Mathnerd314> though what language features don't exist?
13:24:38 <jmcarthur> unsafeCoerce can be used to get around the lack of certain type system features, as an example
13:24:39 <c_wraith> initialization-time IO
13:24:46 <sinelaw> ooh compiz crashed
13:24:55 <benmachine> ooh!
13:25:08 <jmcarthur> unsafePerformIO can be used to create new referentially transparent primitives that use IO underneath the hood
13:25:10 <sinelaw> jmcarthur, i completely avoided them in all my bindings
13:25:15 <sinelaw> by using my allocated-processor package
13:26:36 <jmcarthur> sinelaw: unfortunately that is not enough for the things i'm doing, as far as i can tell
13:26:49 <sinelaw> jmcarthur, such as?
13:26:56 <jmcarthur> sinelaw: since i'm making RT primitives and stuff
13:27:06 <jmcarthur> sinelaw: DiffList semantics, for example?
13:27:10 <jmcarthur> err
13:27:13 <jmcarthur> DiffArray
13:27:15 <jmcarthur> sorry
13:27:22 <sinelaw> what's that
13:27:27 <sinelaw> ignoramous here
13:27:27 <jmcarthur> operational semantics, that is
13:27:56 <chrisdone> can someone link me an example schema definition for haskelldb?
13:28:01 <jmcarthur> sinelaw: DiffArray is a kind of array that gives you purely functional constant time update, but if you use the old version it has to recompute it based on the new one
13:29:22 <jmcarthur> sinelaw: i'm making a buffer object primitive for my opengl bindings that allows you to create and modify buffer objects in constant time in pure code, only becoming linear time if you start using old versions instead of allowing them to just be garbage collected
13:29:33 <jmcarthur> well, actually that's mostly done. i'm doing textures now
13:29:40 <jmcarthur> but with similar semantics
13:29:45 <chrisdone> @hoogle Table
13:29:45 <lambdabot> module Text.XHtml.Table
13:29:46 <lambdabot> Data.Graph type Table a = Array Vertex a
13:29:46 <lambdabot> Text.Html table :: Html -> Html
13:30:14 <sinelaw> hmm
13:30:34 <jmcarthur> sinelaw: DiffArray uses unsafePerformIO along with MVar underneath the hood to use mutation without you seeing it
13:30:50 <sinelaw> ok that's a complex case
13:31:07 <jmcarthur> well, these are the kinds of things i do ;)
13:31:17 <c_wraith> It is.  It's also quite clever.  Sadly, it's way slower than anyone would expect.
13:31:29 * hackagebot hs2dot 0.1.1 - Generate graphviz-code from Haskell-code.  http://hackage.haskell.org/package/hs2dot-0.1.1 (OscarFinnsson)
13:31:33 <jmcarthur> c_wraith: yeah. still haven't figured that out (in the case of DiffArray)
13:32:09 <sinelaw> is OscarFinnsson  duplicating stuff that ivanm already did?
13:32:11 <jmcarthur> c_wraith: i doubt it will be as big a deal for my purposes though since mutations should be a lot less common than the cases that DiffArrays are typically used for
13:36:51 <sinelaw>  should we try to avoid unsafePerform even for "pure" transformations if they require set-up tear-down stuff?
13:37:42 <monochrom> oh, expensive setup and teardown?
13:37:55 <sinelaw> yes
13:38:04 <sinelaw> that can be omitted except for the first time you run it
13:38:27 <monochrom> interesting. all overhead should be amortized.
13:39:00 <sinelaw> what do you mean
13:39:24 <jmcarthur> this is essentially what the "unsafePerformIO trick" does. it does the setup once
13:39:43 <jmcarthur> it's usually used to create top-level mutable variables
13:40:28 <jmcarthur> the trick is to make it a CAF and set it to NOINLINE
13:41:08 <jmcarthur> it's dirty. there have been proposals to just make a new language feature to let you do it more cleanly (and reliably, since it depends on unspecified things)
13:41:42 <jmcarthur> i don't think any of the proposals went anywhere though
13:41:52 <c_wraith> doesn't some other haskell compiler implement one of them?
13:41:59 <jmcarthur> really?
13:42:00 <c_wraith> where "other" = "non-ghc"
13:42:10 <Ke> @pl (\x -> return x)
13:42:10 <lambdabot> return
13:42:17 <Ke> yup
13:43:09 <Ke> I actually had one of those for some reason
13:45:13 <jmcarthur> i'm not finding the compiler that has this
13:45:30 * jmcarthur gives up
13:46:01 <gwern> jhc
13:46:03 <sshc> In the List monad example in http://www.haskell.org/all_about_monads/html/listmonad.html, can a list smaller than one of size 3 be returned from parseArg?  Can the list returned be bigger than 3?
13:46:12 <jmcarthur> huh, i looked at the jhc manual
13:48:38 <sinelaw> jmcarthur, don't you agree that doing the same thing within the language (as I try to do) is better if you can?
13:49:02 <sinelaw> i build a structure that ends up being equivalent to writing a long do-style sequence of commands
13:49:12 <monochrom> It seems parseArg and stuff is designed to give at most 3 items.
13:49:30 <sinelaw> except you have a functional interface and you're not exposed to the allocation/dealoction stuff 
13:49:33 <sinelaw> without unsafePerform
13:49:50 <jmcarthur> sinelaw: i agree that it's best to do things in haskell if you can, but i see nothing wrong with exposing a pure interface over impure implementation
13:50:12 <sinelaw> jmcarthur, using magic that's hard to understand
13:50:18 <Mathnerd314> sshc: it can be any size < 3
13:50:23 <sinelaw> esp. if you're not into how the compiler works
13:50:28 <jmcarthur> sinelaw: sometimes the initialization *has* to happen before anything else and you can't just cleanup and reinitialize as needed, for example
13:50:33 <Mathnerd314> sshc: and that's all
13:51:23 <jmcarthur> sinelaw: the only alternative would be to stick everything in IO. the thing is, it's not so much a limitation of haskell as it is of the underlying API you are wrapping. it's just a sucky position to be in
13:52:38 <jmcarthur> sinelaw: i think if somebody doesn't understand something they shouldn't be surprised if something breaks, but that doesn't mean they should avoid it for the rest of their lives. if they do, they will never learn it, and they will never be able to take advantage of it in the first place
13:52:48 <jmcarthur> everybody that bends the rules had to start somewhere
13:53:07 <danharaj> unsafePerformIO : The gateway function
13:53:46 <syntaxfree> @remember  danharaj: unsafePerformIO : The gateway function
13:53:46 <lambdabot> Okay.
13:53:48 <danharaj> Next thing you know, you'll be doing lines of unsafeCoerce off of an IO monad's back in a dark alley.
13:53:52 <BMeph> sshc: Yes, and Yes. :)
13:54:06 <jmcarthur> unsafeCoerce is one of those functions that i'm still afraid to use
13:54:07 <syntaxfree> I'm having trouble getting back on my groove.
13:54:20 <syntaxfree> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26251#a26251
13:54:37 <danharaj> jmcarthur: I can't see unsafeCoerce ever being safe to use outside of a compiler implementation. It actually depends on the way the compiler represents data, no?
13:55:17 <jmcarthur> syntaxfree: Elo and Result don't actually have instances of Num and Floating there
13:55:27 <Botje> syntaxfree: Result (1/...)
13:55:31 <jmcarthur> you just said their implementations have to have it (which i also think is a bad idea)
13:55:49 <jmcarthur> danharaj: i have seen uses of it proven to be safe that GHC is just unable to verify
13:55:56 <syntaxfree> jmcarthur:  oh yeah. deriving. 
13:56:05 <syntaxfree> (if deriving is even available for Num)
13:56:11 <monochrom> I keep mixing up "gateway" and "getaway". Perhaps unsafePerformIO is also the getaway function.
13:56:22 <jmcarthur> syntaxfree: it's not unless it's a newtype and you use GeneralizedNewtypeDeriving
13:56:33 <syntaxfree> I guess I'll work with raw numbers for a while.
13:56:57 <syntaxfree> First get to working code.
13:57:23 <jmcarthur> syntaxfree: {-# LANGUAGE GeneralizedNewtypeDeriving #-} ; newtype Elo a = Elo a deriving Num ...
13:57:56 <syntaxfree> hmm. how smart/common is this?
13:58:03 <sclv> danharaj: unsafeCoerce is used to implement, e.g. Data.Dynamic
13:58:04 <sinelaw> jmcarthur, I dunno about that philosophy. It would be better if you could always be on the safe side
13:58:12 <sinelaw> that's what a high level language is for
13:58:24 <jmcarthur> syntaxfree: it doesn't have to be smart because it just uses the Num instance from the internals, and it's common enough
13:58:37 <jmcarthur> sinelaw: i'm talking strictly about libraries here
13:58:40 * hackagebot extcore 0.9 - Libraries for processing GHC Core  http://hackage.haskell.org/package/extcore-0.9 (TimChevalier)
13:58:44 <jmcarthur> sinelaw: to offer new primitives
13:58:56 <jmcarthur> sinelaw: what i'm doing right now would be impossible without unsafe things
13:59:05 <syntaxfree> oh well. thanks.
13:59:42 <jmcarthur> sinelaw: and i'm exposing a strictly RT interface. i don't think anybody is going to cry about it
14:00:39 <jmcarthur> sinelaw: just think of what i'm doing as "not haskell"
14:00:59 <sinelaw> jmcarthur, sure
14:01:20 <sinelaw> it's cool, i just don't want to have to do this for every FFI that is a little more than trivial
14:01:36 <jmcarthur> it just depends what kind of interface you want to expose
14:01:47 <jmcarthur> sometimes a C library takes a little massaging, that's all
14:02:00 <sinelaw> i manage to expose nice functional interfaces without unsafeperform
14:02:05 <sinelaw> just using a different approach
14:02:07 <ezyang> I will note that Haskell people are used to their interfaces being "safe" (as in pure and threadsafe), so be careful. 
14:02:25 <jmcarthur> ezyang: who are you talking to? me?
14:02:28 <syntaxfree> there was a python dictionary-like type with key/value functionality...
14:02:34 <sinelaw> using IO and hiding it in a composable function-like type
14:02:47 <sinelaw> that has category, functor, applicative, and arrow instances
14:02:58 <ezyang> jmcarthur: Yeah, but just making a general comment 
14:03:30 <jmcarthur> ezyang: i wouldn't be going through the trouble if i didn't have the same mentality ;)
14:03:42 <ezyang> Cool :-) 
14:04:09 <sinelaw> b . a means "initialize a, then initialize b, then run a, then run b on the result, then deallocate in reverse order"
14:04:36 <jmcarthur> sinelaw: sure, but suppose you don't want an arrow or monadic interface?
14:04:53 <sinelaw> jmcarthur, you don't have to use arrows
14:04:56 <jmcarthur> sinelaw: your approach is implementation driven
14:04:58 <sinelaw> it's just a convenience
14:04:59 <jmcarthur> that's all i mean
14:05:10 <sinelaw> why is it implementation driven?
14:05:19 <sinelaw> by not being regular haskell functions?
14:05:20 <jmcarthur> because your interface is shaped by its implementation
14:05:30 <sinelaw> the user doesn't see this
14:05:35 <sinelaw> he sees things that are like functions
14:05:41 <sinelaw> the interface is pure
14:05:52 <jmcarthur> that's not what i mean
14:06:33 <sinelaw> so I'm not getting it :)
14:06:57 <jmcarthur> i'm trying to figure out hopencv so i can come up with an example of the kind of interface i would give it
14:07:09 <jmcarthur> heh, we're back to that again ;)
14:07:30 <jmcarthur> but i think i give up. i don't really feel like trying to figure it out right now i think
14:07:37 <sinelaw> ok :)
14:07:45 <sinelaw> i'm interested in knowing what's wrong though
14:08:44 <jmcarthur> sinelaw: btw, your frp robot is cool
14:10:06 <sinelaw> yes it is :) 
14:10:20 <sinelaw> jmcarthur, next step is to improve its behavior - add a kalman filter on the face detection
14:10:22 <jmcarthur> sinelaw: oh i was looking at hopencv, not cv-combinators
14:10:42 <sinelaw> so i'm gonna start a filtering package for haskell
14:10:46 <jmcarthur> sinelaw: okay, this is easier to figure out than that low level binding
14:11:14 <sinelaw> jmcarthur, oh yeah, HOpenCV is really low level only
14:11:21 <sinelaw> like opengl-raw or something
14:11:40 <sinelaw> you should be looking at cv-combinators, there's nice examples there and also in RMP
14:11:42 <jmcarthur> sinelaw: "i'm interested in knowing what's wrong though"  <-- nothing is wrong. i'm just going to explain the difference between our approaches
14:11:48 <jmcarthur> if i can
14:11:48 <Ke> can I assume that sepEndBy1 consumes all the separators after the last entry?
14:11:59 <sinelaw> jmcarthur, ok
14:12:10 <gio123> is here lambda calculus fun ppl?
14:12:35 <jmcarthur> sinelaw: the first thing i would do is think about the interface i want regardless of how i will have to write it
14:12:58 <sinelaw> jmcarthur, yeah, that was my approach basically
14:13:04 <jmcarthur> sinelaw: my understanding is that images are a very important concept in OpenCV, so i'd consider making them an important type
14:13:38 <jmcarthur> sinelaw: now, let me just sketch out some types here...
14:13:47 <sinelaw> k
14:15:47 * hackagebot hs2dot 0.1.2 - Generate graphviz-code from Haskell-code.  http://hackage.haskell.org/package/hs2dot-0.1.2 (OscarFinnsson)
14:17:14 <JoeyA> Has anyone tried to bring the "purely functional" concept to user interfaces?
14:17:28 <sinelaw> JoeyA, heard of FRP?
14:17:48 <lispy> JoeyA: search for Conal Elliot
14:17:59 <JoeyA> Ah, thanks.
14:19:06 <ddarius> @where conal
14:19:06 <lambdabot> http://conal.net
14:20:30 <gio123> is here lambda calculus fun ppl?
14:20:50 <sinelaw> gio123, what
14:21:39 <jmcarthur> sinelaw: resize :: Int -> Int -> InterpolationMethod -> Image -> Image ;  dilate :: Int -> Image -> Image ;  camera :: Int -> Behavior Image ;  videoFile :: String -> Behavior Image ;  window :: Behavior Image -> Behavior Window ;  renderWindows :: Behavior [Window] -> IO ()
14:21:41 <JoeyA> Does that actually involve bringing the functional experience to users, or is it just an approach to implementing user interfaces via functional programming?
14:21:45 <sinelaw> gio123, what do you want
14:21:52 <jmcarthur> sinelaw: like i said, i don't know much about OpenCV or what's important with it
14:22:08 <jmcarthur> but based on some of the things i see, that's what i would lean toward
14:22:26 <jmcarthur> it's FRP stuff, obviously
14:22:31 <gio123> can u see pm?
14:22:55 <sinelaw> jmcarthur, yes. the only drawback of my approach is that instead of Image -> Image you get IOProcessor Image Image, but it has an equivalent interface to a function
14:23:14 <sinelaw> gio123, no. and you don't need to pm me anyway
14:23:38 <jmcarthur> sinelaw: well for one you are stuck with the limitations of Arrow
14:23:43 <gio123> ok. bye
14:23:45 <jmcarthur> Monad would be more powerful
14:23:54 <sinelaw> jmcarthur, right. the IOProcessor is what i want to eventually become a behavior 
14:24:07 <sinelaw> i'm working on the semantics first
14:24:10 <jmcarthur> sinelaw: so you favor arrow frp?
14:24:17 <sinelaw> jmcarthur, not sure yet
14:24:20 <sinelaw> it has problems
14:24:34 <sinelaw> monad is perhaps too powerful
14:24:34 <jmcarthur> both arrow and classical have their share of problems :\
14:24:43 <sinelaw> i prefer arrow over monad
14:24:49 <jmcarthur> i don't :)
14:25:01 <sinelaw> jmcarthur, i think interfaces should be as weak as they possibly can
14:25:04 <sinelaw> (most general)
14:25:17 <jmcarthur> sinelaw: i'm also still thrown off that you are exposing Ptrs and calling it pure
14:25:23 <jmcarthur> in cv-combinators, i mean
14:25:26 <sinelaw> jmcarthur, i'm not really exposing them
14:25:32 <sinelaw> i could use newtype if I wanted
14:25:36 <jmcarthur> sure you are. through type aliases
14:25:52 <sinelaw> for some reason i avoided newtype. not sure why.
14:26:09 <sinelaw> jmcarthur, what i mean is that there's no part of the interface that requires you to use the pointer
14:26:12 <sinelaw> directly
14:26:16 <jmcarthur> okay
14:26:24 <sinelaw> but you're right that it should be enforced
14:26:43 <mun> hi
14:26:54 <sinelaw> hi
14:27:10 <sinelaw> jmcarthur, what's you complaint about non-arrowized frp?
14:27:19 <jmcarthur> sinelaw: normally when i see a type alias the first thing i do is look at its definition. i usually assume that the author intended for me to do that
14:27:22 <sinelaw> it's less often mentioned
14:27:33 <sinelaw> jmcarthur, ah ok. i wasn't aware of that
14:27:38 <mun> is there an 'unfold' function in the library?
14:27:48 <benmachine> :t Data.List.unfoldr
14:27:49 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:27:57 <benmachine> nope.
14:28:01 <ricree> I've been reading real world haskell, and I'm having some trouble with one of the early parts in the "Using Databases" chapter.  toSql 0 causes an error that no instance arises.  toSql (0 ::Int) works.  Why doesn't it work without it the way that it does in that section of the book?
14:28:20 <gwern> @remember WilliamTaysom The journey to the dark side begins with the desire for power. In our case the power function
14:28:20 <lambdabot> It is forever etched in my memory.
14:28:23 <gwern> @flish
14:28:25 <jmcarthur> sinelaw: i just mean the semantic questions it raises about time, mainly
14:28:49 <sinelaw> jmcarthur, did you see my post about axiomatic basis for frp?
14:29:05 <jmcarthur> sinelaw: yes i did. we are sharing similar approaches i think
14:29:40 <sinelaw> that's good
14:29:56 <sinelaw> what we need is a comprehensive, consistent model
14:30:10 <sinelaw> and after that implementation attempts
14:30:10 <jmcarthur> sinelaw: btw, if you ever see me mention dctp or denotative continuous-time programming, i mean the same thing as what most call frp
14:30:32 <sinelaw> jmcarthur, that's cool. I suggested using Denotational Temporal Programming
14:30:47 <sinelaw> maybe we can adopt a common new name (FRP isn't so great, as conal himself said)
14:31:06 <jmcarthur> sinelaw: well, i got conal's blessing on DCTP, if that means anything
14:31:25 <sinelaw> jmcarthur, ok :) i'm just not entirely certain about what will happen with the continuous part
14:31:39 <sinelaw> i know we want it, but it may be infeasible to implement without major glitches
14:31:40 <jmcarthur> i think the continuous part is critical
14:31:50 <Saizan> you could coin a completely new name rather than stacking adjectives :)
14:31:54 <jmcarthur> as you just said, we should get a model first ;)
14:32:08 <jmcarthur> Saizan: yeah
14:32:11 <sinelaw> jmcarthur, there are also inherent differences between continuous and discrete
14:32:13 <ricree> Does anyone know why HDBC's toSql function fails when I try something like "toSql 0", but succeeds with "toSql (0 ::Int)" ?
14:32:22 <sinelaw> Funtime
14:32:23 <sinelaw> :)
14:32:26 <jmcarthur> Saizan: i think i'd like to reserve the new names for implementations
14:32:34 <jmcarthur> :)
14:32:43 <Saizan> ricree: because it needs to know the actual type of that 0 to know what to do with it
14:32:47 <Saizan> ?type 0
14:32:48 <lambdabot> forall t. (Num t) => t
14:33:11 <Saizan> as you see, 0 by itself is polymorphic
14:33:21 <MacMagnus> lol, check this out... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26258#a26258 does anybody know how to return -1 ?
14:33:43 <jmcarthur> sinelaw: i think those differences are exactly why we should emphasize it. if we don't stick to one or the other then we are not working on a well-defined enough idea to get anywhere
14:34:02 <sinelaw> yeah
14:34:05 <MacMagnus> (maybe placting the [] at first) :P
14:34:07 <jmcarthur> sinelaw: and continuous-time is just closer to reality as we experience it, which is why i choose continuous time :)
14:34:15 <ricree> Saizan: any idea why "Real World Haskell" would freely use it in it's examples when it doesn't work?
14:34:16 <sinelaw> i agree
14:34:19 <sinelaw> continuous time is great
14:34:25 <Dashkal> ricree: What section is the example you're reading from in?
14:34:31 <Botje> eval: let foo [] = -1 in foo []
14:34:34 <ricree> http://book.realworldhaskell.org/read/using-databases.html
14:34:39 <sinelaw> was just pointing out one of my worries
14:34:55 <Dashkal> ricree: I have the book in front of me.  What section in that chapter?
14:35:10 <ricree> in the "Query Parameters" section
14:35:39 <jmcarthur> sinelaw: anyway, my current approach is essentially to generalize integration to any monoid with a nonintegral exponent (which will be time, in my dctp model)
14:36:15 <jmcarthur> sinelaw: oops, not necessarily *any* monoid
14:36:27 <jmcarthur> i'm still working on what's necessary, but i don't think that is enough
14:36:34 <jmcarthur> well, i know it's not
14:36:42 <jmcarthur> necessary but not sufficient
14:36:54 <Saizan> ricree: no, maybe it worked in an earlier version of HDBC but i doubt it
14:36:58 <Dashkal> ricree: I'll need a moment to get set up.  I'm curious about this myself.
14:37:28 <jmcarthur> sinelaw: i also need to come up with a good story for impulses, if any
14:37:30 <Saizan> ricree: ah, are you trying this in ghci or in a file?
14:37:37 <ricree> ghci
14:37:57 <jmcarthur> sinelaw: but if i can do that then i've essentially generalized yampa's Event
14:38:08 <Saizan> maybe the defaulting magic in ghci got less magical in recent releases
14:39:32 <Saizan> ricree: ghci is (or has been) more prone to guessing a type for you in these cases, it's called extended-defaulting iirc
14:40:04 <sinelaw> jmcarthur, impulses are a bad story
14:40:10 <sinelaw> well, that's my hunch
14:40:10 <diracdelta> Hi, given something like 'data Thing = Int | String' how does one create a function of type Thing->String?
14:40:17 <sinelaw> they are only defined in terms of integration
14:40:43 <jmcarthur> sinelaw: yeah, i'm leaning toward treating them as an implementation detail rather than a part of the model, but then that would limit my possibilities a lot
14:40:44 <Twey> diracdelta: You can't ‚Äî there's no string in that
14:40:44 <sinelaw> but maybe in the framework of generalized integration it's sufficient for anything you'd want to do with events anyhow
14:41:03 <Twey> (well, you can ‚Äî ‚Äòconst "foo"‚Äô and suchlike, but I'm guessing that's not what you want ;))
14:41:31 <Saizan> diracdelta: that datatype defines two constructors called Int and String respectively, it doesn't define two constructors that hold an Int or a String
14:41:32 <Twey> diracdelta: ‚Äòdata Thing = Int | String‚Äô creates a datatype ‚ÄòThing‚Äô with two constructors, ‚ÄòInt‚Äô and ‚ÄòString‚Äô, which take no arguments
14:42:01 <diracdelta> Twey: So does it override the standard types then?
14:42:02 <jmcarthur> sinelaw: that's something i'm hopeful but skeptical about
14:42:17 <sinelaw> it needs proof
14:42:20 <jmcarthur> right
14:42:26 <Twey> diracdelta: No, you're defining *data* constructors with those names, which are values ‚Äî you only define ‚ÄòThing‚Äô in the type namespace
14:42:29 <sinelaw> jmcarthur, in my last post i tried something like that
14:42:48 <jmcarthur> link?
14:42:50 <Twey> diracdelta: If you want to create two constructors that hold an Int and a String respectively, you need to name them: data Thing = IntThing Int | StringThing String
14:42:57 <sinelaw> http://noamlewis.wordpress.com/
14:43:07 <Twey> diracdelta: Then you can write a function getStringThing (StringThing s) = s
14:43:13 <jmcarthur> haha, we're talking about impulses in front of somebody with the nick diracdelta 
14:43:17 <sinelaw> rather, http://noamlewis.wordpress.com/
14:43:17 <Twey> diracdelta: Or you can use record syntax to do that for you
14:43:20 <sinelaw> oops
14:43:24 <sinelaw> http://noamlewis.wordpress.com/2010/06/13/axioms-for-frp-discussing-insensitivity/
14:43:31 <sinelaw> jmcarthur, heh i just noticed too
14:43:40 <Twey> data Thing = IntThing { getIntThing :: Int } | StringThing { getStringThing :: String }
14:43:59 <ddarius> Ugh.
14:44:07 <sinelaw> jmcarthur, see the comment for a correction about delta. 
14:44:12 <diracdelta> Twey: Thanks, that clarifies a lot.
14:44:18 <sinelaw> jmcarthur, in short a delta is: T -> (T -> A) -> (U -> A)
14:44:24 <sinelaw> U is the type of subsets of T
14:44:33 <sinelaw> (we're talking math model here, not haskell)
14:44:42 <Twey> diracdelta: You're welcome
14:44:53 <sinelaw> the args are the delta's offset and a "test function"
14:45:06 <sinelaw> A is a monoid
14:45:17 <sinelaw> the delta returns U -> A which will give you mempty if the offset is not in the subset
14:45:20 <alexyk> dons: ping
14:45:29 <sinelaw> and will give you the value of the function at the offset, if it is.
14:45:57 <sinelaw> delta offset f u = if offset `in` u then f offset else mempty
14:46:42 <sinelaw> that's completely equivalent to the definition of delta in distribution theory
14:48:38 <sinelaw> so if we continue this analogy, an event is a function U -> A which returns the event's value if the time of the event is in the subset given (U is the type of subsets of time)
14:48:44 <sinelaw> and gives mempty otherwise
14:49:08 <yairchu> sinelaw: "f u" is not a nice sequence of variable names. it's sms cursing
14:49:17 <yairchu> :)
14:49:53 <sinelaw> ah, i'll regex my entire codebase immediately!
14:50:11 <yairchu> :)
14:50:39 <Dashkal> How do you activate language extensions in ghci?
14:50:57 <Twey> :set -X<extension name>
14:51:38 <monochrom> {-# LANGUAGE RankNTypes #-}
14:52:10 * jmcarthur wishes he understood measure theory
14:53:52 <Twey> monochrom: No, that doesn't work
14:54:49 <sinelaw> jmcarthur, the stuff i know is easy
14:54:53 <monochrom> Lies.
14:54:55 <sinelaw> first chapter of the book
14:55:03 <sinelaw> i didn't really study it properly
14:55:09 <jmcarthur> sinelaw: what book? :)
14:55:16 <sinelaw> rudin, real and complex analysis
14:56:47 <sinelaw> jmcarthur, if you follow the delta analogy, an event is what i said - a function that tells you if the given subset of time contains the event or not (the value is either `mempty` or the value of the event, or something like that)
14:56:56 <Twey> Prelude> {-# LANGUAGE ViewPatterns #-}
14:56:57 <Twey> Prelude> let f (succ -> x) = x in f 3
14:56:58 <sinelaw> s/if/whether
14:57:01 <Twey>     Illegal view pattern:  (succ -> 3)
14:57:28 <monochrom> No, put {-# LANGUAGE RankNTypes #-} in a source code file, then load it into ghci.
14:57:57 <jmcarthur> sinelaw: i follow it
14:58:27 <yairchu> monochrom: or set -XRankNTypes
14:58:42 <Twey> monochrom: But that's not within GHCi ‚ò∫
14:58:48 <sinelaw> you can mappend deltas to get the delta that yields either value, or mappended values if they both appear in the subset you're testing
14:58:51 <monochrom> I prefer {-# LANGUAGE RankNTypes #-}, it's more persistent.
14:58:58 <Twey> How?  :√æ
14:59:08 <yairchu> Prelude> :set -XRankNTypes
14:59:10 <Twey> You still have to execute the command in every new GHCi session.
14:59:26 <jmcarthur> Twey: use a .ghci file
14:59:31 <monochrom> Twey: Does ghci ignore {-# LANGUAGE RankNTypes #-} in source code files? If not ignored, then it works within ghci.
14:59:34 <Dashkal> ricree: After poking, I'm afraid I can't give a definite answer.  My best guess is that the type of the literal 0 is too ambigious.  In practice, you'd be using a specific type, rather than (Num t) => t, so this shouldn't occur in your code.
14:59:38 <Twey> jmcarthur: Still provides no advantage over :set
14:59:44 <jmcarthur> Twey: why not?
14:59:49 <jmcarthur> it's used implicitly
14:59:52 <sinelaw> jmcarthur, i am somewhat more inclined to the other approach
14:59:55 <Twey> jmcarthur: What advantage does it provide?
15:00:07 <ricree> Dashkal: Thank you for looking.
15:00:08 <monochrom> source code files are persistent.
15:00:21 <jmcarthur> Twey: is this for a project or for *all* ghci sessions?
15:00:54 <Twey> monochrom: It doesn't work within GHCi because you have to write an external file.  I guess you can use Haskell to write it, thereby *technically* doing it from within GHCi, but it seems like a terribly roundabout way to do ‚Äò:set -XRankNTypes‚Äô.
15:01:31 <Twey> jmcarthur: I have no idea; monochrom is just arguing that writing {-# LANGUAGE RankNTypes #-} and then using :l on the file is better than just doing ‚Äò:set -XRankNTypes‚Äô in general.
15:02:07 <sinelaw> jmcarthur, the other approach i want to try is to have different time domains (events will be defined on discrete time) but common definitions in a general setting, using appropriate instances for each case
15:02:13 <monochrom> For the record, I never said or implied "better". I only said and implied: works, and more persistent.
15:02:14 <jmcarthur> Twey: well, i'd say for certain cases it is
15:02:15 <sinelaw> not sure how they will combine though
15:02:23 <lispy> Is the package db buggy in ghc 6.12?  I swear I haven't done anything unusual on this machine and it's telling me some packages are broken/missing
15:02:35 <monochrom> Don't you hate people who put words into my mouth.
15:02:45 <jmcarthur> sinelaw: not sure i follow on events being on discrete time
15:02:54 <Twey> monochrom: It's no more persistent than ‚Äò:set -XRankNTypes‚Äô ‚Äî wherever you would have to execute ‚Äò:set -XRankNTypes‚Äô you will have to write (at least) ‚Äò:l /path/to/file‚Äô instead
15:03:01 <sinelaw> jmcarthur, not follow = not agree?
15:03:05 <Twey> Be that in a .ghci or manually
15:03:51 <Saizan> lispy: have you cabal installed something?
15:03:59 <lispy> Saizan: yes
15:04:00 <jmcarthur> sinelaw: IRL, events (are perceived to) happen at any time, not on some discretized version of our time line. or is that not what you mean?
15:04:08 <Twey> monochrom: Besides, it doesn't enable it in GHCi anyway ‚Äî LANGUAGE pragmas apply only for the current file
15:04:13 <monochrom> That argument also says source code files are no more persistent than re-entering the code through .ghci or manually.
15:04:27 <ivanm> preflex: seen edwardk
15:04:27 <preflex>  edwardk was last seen on #haskell 2 hours, 3 minutes and 19 seconds ago, saying: * edwardk thinks he was slightly annoyed at the pdf ;)
15:04:40 <Saizan> lispy: that can possibly break packages, or make them appear broken
15:04:52 <lispy> Saizan: what, really?
15:04:53 <sinelaw> jmcarthur, that's not what i mean. events can happen at any time, but if you look at a single "event signal", it's defined as something analgous to a sequence of time values with event values
15:05:01 <sinelaw> not sure about the details yet
15:05:18 <jmcarthur> sinelaw: ah, like Reactive's [(T, a)] semantics for events?
15:05:20 <Saizan> lispy: yup, e.g. http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
15:05:28 <sinelaw> jmcarthur, similar in a way, but not exactly
15:05:42 <monochrom> Right, LANGUAGE pragmas don't turn things on at the prompt. But they turn things on for the content of the file. It works in ghci.
15:05:42 <Twey> monochrom: The difference being that a source file contains many lines of code, and persistence therefore allows you to replicate that effect with a single line, whereas enabling a single extension requires only one line of code anyway, so there is no saving
15:05:54 <jmcarthur> sinelaw: Reactive's events are severely flawed and i think it's because the model as specified isn't what was really intended
15:05:55 <sinelaw> i'm trying to do it in a more general way that makes it completely analogous to continuous time
15:06:01 <sinelaw> jmcarthur, yes i know
15:06:03 <jmcarthur> yeah
15:06:18 <jmcarthur> sinelaw: that was agreement with your idea being different, not an attack on your idea, btw
15:06:20 <Twey> monochrom: The question was: < Dashkal> How do you activate language extensions in ghci?
15:06:39 <monochrom> The question does not say "for the prompt"
15:06:59 <monochrom> It is just as valid to interpret "for files loaded into ghci"
15:07:12 <Twey> monochrom: It doesn't activate a language extension in GHCi, for any interpretation.  a) It isn't performed within GHCi, and b) it doesn't apply to the environment accessible in GHCi
15:07:24 <sinelaw> jmcarthur, maybe something like: an event signal is a function from one specific set (which contains a countable amount of distinct time values of this event's occurances) to values
15:07:38 <sinelaw> jmcarthur, so the new thing here is that each event has a different domain
15:07:44 <jmcarthur> ah\
15:07:46 <jmcarthur> -\
15:07:48 <monochrom> I agree to disagree.
15:07:49 <Twey> monochrom: So whether it's the activation or the effect that's intended to take place within GHCi, it fails to meet the criterion.
15:07:53 <sinelaw> unlike continuous values that have a common domain (the real line, essentially)
15:07:54 <darq> hello.. how to remove all even indexes and leave just the odd [4,5,2,1,7] ---> [4,2,7] ?
15:07:58 <sinelaw> jmcarthur, it's weird
15:08:29 <sinelaw> jmcarthur, then, the measure i define on that domain (call it D) is the counting measure: for any subset of D the measure is the number of elements in the subset
15:08:43 <sinelaw> which corresponds to the number of events, btw
15:08:53 <jmcarthur> right
15:09:00 <dafis> alexyk: You will soon have mail :)
15:09:01 <pastorn> darq: f (x:xs) = x : g xs; g (x:xs) = f xs
15:09:07 <pastorn> darq: ^^ and add base cases
15:09:15 <sinelaw> and an event is a function D -> A
15:09:46 <sinelaw> with D measurable, which is exactly like continuous signals T -> A with T measurable - there's really no difference except i've used different letters
15:09:53 <alexyk> dafis: love mail! :)
15:09:54 <sinelaw> if you consider only the general requirements
15:09:54 <jmcarthur> right
15:10:07 <jmcarthur> and in fact this could also work for continuous domains
15:10:12 <sinelaw> exactly
15:10:12 <jmcarthur> other than IRL time
15:10:20 <jmcarthur> very interesting
15:10:21 <sinelaw> IRL?
15:10:26 <jmcarthur> In Real Life
15:10:46 <jmcarthur> but i meant it more loosely than that
15:10:49 <sinelaw> btw, the measure is nice because it always gives you the "number of values" you get in a given subset
15:10:58 <sinelaw> for events, the number of events
15:10:58 <jmcarthur> i meant any sort of "global" time
15:11:14 <sinelaw> for continuous signals, the amount of time
15:11:28 <jmcarthur> what is the definition of "measurable," exactly?
15:11:38 <jmcarthur> is it abstract?
15:11:50 <edwardk> hrmm. apparently it isn't just the show operations on hmpfr that are busted =(
15:11:58 <sinelaw> jmcarthur, http://en.wikipedia.org/wiki/Measure_%28mathematics%29
15:12:19 <sinelaw> a measure is a function over a sigma-algebra
15:12:37 <sinelaw> that satisfies certain properties. it's not difficult just need to learn the definitions
15:13:17 <sinelaw> but it's ok to not know the theory - i hardly know it myself (as i said i learnt the very basic part of it)
15:13:44 <sinelaw> jmcarthur, anyway i think this approach is nicer than delta stuff
15:13:52 <jmcarthur> sinelaw: yeah i think i independently invented this stuff
15:14:00 <jmcarthur> as most people probably do
15:15:03 <sinelaw> i don't think they do
15:15:08 <sinelaw> i didn't
15:15:19 <jmcarthur> well, most people generalizing integrals, at least
15:15:25 <jmcarthur> :P
15:15:45 <sinelaw> heh
15:16:06 <sinelaw> lebesgue integration is pretty innovative, i don't think i could have invented it
15:16:09 <jmcarthur> of course all this is far better thought out than anything i did
15:16:33 <sinelaw> it also turns out to be really simple which is cool (lebesgue integration)
15:16:37 <sinelaw> compared to what they had before
15:16:40 <jmcarthur> all sorts of properties i didn't think of and stuff
15:16:43 <jmcarthur> awesome
15:16:56 <jmcarthur> i fail to formalize things
15:17:52 <sinelaw> jmcarthur, yeah i'm happy i did this one course
15:18:07 <sinelaw> with a crazy lecturer who insisted on us knowing stuff from the basics
15:18:21 <sinelaw> rather than throwing around imprecise buzzwords
15:18:32 <jmcarthur> thank god people like that exist
15:19:04 <edwardk> lesbegue measure is one of those 'narrow passes' in the terrain of mathematics, you need to get through it to see all sorts of neat stuff.
15:19:06 <sinelaw> jmcarthur, but i hope i'll finish my degree, his is my last exam and it's not easy to pass
15:19:16 <sinelaw> :) it comes at a price
15:19:20 <jmcarthur> heh
15:19:59 <edwardk> sinelaw: re: crazy lecturer who insisted on you knowing stuff from the basics, we call those people mathematicians. We call those who don't, physicists or engineers ;)
15:20:31 <dafis> edardk. :)
15:20:32 <ivanm> oh, you're back edwardk...
15:20:45 <dafis> s/edard/edward/
15:21:04 <edwardk> heya ivan
15:21:05 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
15:21:21 <ezyang> @pl \b -> if b then id else negate 
15:21:21 <lambdabot> flip (flip if' id) negate
15:21:21 <sinelaw> edwardk, right!
15:21:30 <ezyang> Alright, your turn. Any better ways? 
15:21:51 <benmachine> make your own function
15:21:52 <benmachine> called bool
15:21:58 <benmachine> :: a -> a -> Bool -> a
15:21:58 <sinelaw> edwardk, i wish i had more lecturers like that
15:22:01 <benmachine> it comes in handy a lot
15:22:05 <sinelaw> edwardk, last course though, so no hope for that now
15:22:15 <edwardk> ivanm: sorry if my tone earlier was a bit off. i go out of my way in my libraries to avoid that over-specific instance problem. I understand that you may not share my tic. ;)
15:22:28 <benmachine> e.g. doesFileExist fp >>= bool (readFile fp) (complainLoudly fp)
15:22:30 <ivanm> edwardk: heh, fair enough
15:22:56 <ivanm> edwardk: I wasn't sure how much of what you said was because someone would actually want that as opposed to you just playing devil's advocate, etc.
15:23:07 <edwardk> @type ((fromEnum b * 2 - 1) *)
15:23:08 <lambdabot> Int -> Int
15:23:16 <ivanm> and tbh I doubt anyone would do fancy tricks like that with FGL graphs (since what would be the point?)
15:23:20 <benmachine> edwardk: lols
15:23:25 <lispy> Saizan: I don't use cabal upgrade
15:23:31 <edwardk> there is a missing fromIntegral int here somewhere
15:23:36 <lispy> Saizan: So, I think this might be a bug
15:23:50 <benmachine> :t \b -> (fromIntegral (fromEnum b * 2 - 1) *)
15:23:51 <lambdabot> forall a b. (Enum a, Num b) => a -> b -> b
15:23:57 <sinelaw> jmcarthur, in a way, i still don't believe nobody created a model for systems with events before
15:24:01 <sinelaw> i'm sure there is one
15:24:02 <edwardk> ivanm: well, it is a criterion i'd place on a library i'd write is all =)
15:24:11 <sinelaw> jmcarthur, there's also this thing called "Algebraic system theory"
15:24:12 <edwardk> but it is easy to arm-chair quarterback these things
15:24:15 <benmachine> :t \b -> (fromIntegral (fromEnum b * 2 - 1) *) `const` not b
15:24:16 <lambdabot> forall b. (Num b) => Bool -> b -> b
15:24:36 <jmcarthur> sinelaw: sorry i'm gonna have to go soon
15:24:43 <sinelaw> jmcarthur, k
15:24:59 <ivanm> edwardk: well, yeah, but you write stuff that is so complicated that the original library that contained the principles behind it is now too large and unweildy to manage so you duplicate your basic code everywhere because you don't have enough time to split that library up! :p
15:25:00 <dafis> :t ([negate, id] !!) . fromEnum
15:25:01 <lambdabot> forall a a1. (Num a, Enum a1) => a1 -> a -> a
15:25:07 <jmcarthur> i'd like to continue later though
15:25:32 <edwardk> ivanm: category-extras is a bit of a bad example, but... touche ;)
15:25:52 <ivanm> :D
15:25:55 <sinelaw> jmcarthur, yeah i really need someone to discuss with. probably tomorrow then :) its late here.
15:26:00 <jmcarthur> alright
15:26:00 <edwardk> i'm more than willing to import category-extras, it just doesn't make people happy when I do ;)
15:26:40 <sinelaw> edwardk, you made a good point in that comment on my post, about acyclic dependencies, but is that really decidable?
15:26:41 <ivanm> edwardk: as I said, your ideas sound really cool/interesting; but without a decent description/paper/etc. it's a bit hard for people to comprehend/appreciate *hint, hint*
15:26:47 <sinelaw> edwardk, asking out of ignorance
15:26:49 <sinelaw> hey Peaker :)
15:27:00 <edwardk> sinelaw: it just becomes a very scary type system =)
15:27:22 <sinelaw> edwardk, what do you mean
15:28:08 <Peaker> sinelaw, hey
15:28:24 <sinelaw> Peaker, was just discussing models for frp with jmcarthur here
15:29:59 <edwardk> ivanm: definitely. the problem really comes down to the fact that i didn't want to write such a library. I simply kept answering questions and the questions kept getting broader and broader in scope. =P So while it would be beneficial to others for me to take a week or so and do so, it hardly benefits me ;)
15:30:35 <sinelaw> edwardk, i would certainly be happy for a nicer linear algebra lib
15:30:46 <ivanm> edwardk: ugh, yeah, I know what you mean; honestly the functionality I needed in graphviz was achieved a couple of versions ago
15:30:54 <ivanm> but now it's the project I spend most of my time on :s
15:31:00 <ivanm> sinelaw: lol
15:31:09 <ivanm> sinelaw: go help hack on hmatrix then ;-)
15:31:26 <edwardk> sinelaw: i'm actually about 3 steps from writing one, because I can't use hmatrix
15:31:27 <sinelaw> ivan, i don't like it that dimensions are not enforceable
15:31:31 <edwardk> ivanm: license ;)
15:31:45 <sinelaw> edwardk, didn't you also say you don't like something there?
15:31:51 <benmachine> GPlol
15:31:56 <ivanm> sinelaw: hmatrix-static?
15:32:03 <sinelaw> ivanm, yeah i know, but it's much more limited
15:32:10 <ivanm> fair enough
15:32:14 <sinelaw> ivanm, on the other hand i didn't really try using them yet
15:32:18 <sinelaw> just looking at docs
15:32:26 <ivanm> at a guess, is part of the reason for using GPL because it also links to GSL?
15:32:27 <edwardk> sinelaw: the license keeps me from using it. there was some stuff fred eaton did a few years back, and i'm sure there are other such staticly bounded libs
15:32:37 <edwardk> ivanm: sure, which keeps me from using that as well ;)
15:32:45 <ivanm> (I'm still not sure why a linear algebra library still links to a general science library...)
15:32:55 <ivanm> edwardk: did you try talking with the dev about it?
15:33:46 <edwardk> ivanm: he got in touch with me about some ad things about 5 hours ago actually and I took a jab at the gpl'd nature of hmatrix keeping me from using it ;)
15:33:55 <sinelaw> ivanm, thanks for adopting fgl btw
15:34:17 <ivanm> sinelaw: np; I guess you're one of the people happy about the changes tomberek and I are doing?
15:34:24 <edwardk> i currently avoid talking about linear algebra in my code by abusing Traversables and parametricity
15:34:54 <edwardk> sinelaw: an approach i'd like to see for a linear algebra lib would be something like i'm doing in my fixed-precision lib
15:35:34 * ivanm heads off to uni
15:35:36 <ivanm> bye all
15:35:49 <sinelaw> ivanm, actually i'm just happy someone is maintaining it. but also some of the changes
15:35:52 <sinelaw> bye
15:36:04 <edwardk> sinelaw: see the readme at http://github.com/ekmett/fixed-precision/blob/master/README.markdown
15:36:16 <ivanm> sinelaw: "some of" sounds like you disapprove of some others... :p
15:36:42 <sinelaw> ivanm, nope i just don't know what they mean \ if they matter to me
15:36:51 <sinelaw> ivanm, i'm still in my haskell puberty :)
15:36:57 <ivanm> sinelaw: see my blog post about it?
15:37:18 <ivanm> edwardk: in your README there, you might want to state who you are on #haskell... :p
15:37:29 <edwardk> ivanm: hahaha
15:37:42 <sinelaw> ivanm, yes that's where i heard
15:37:49 <ivanm> ahhh, right
15:38:00 <ivanm> so you missed all the endless discussions about it on the mailing lists ;-)
15:38:10 <sinelaw> yeah, and didn't read the whole post yet
15:38:31 <ivanm> sinelaw: short version: if you're currently happy with how FGL works, then the first four main changes there won't affect you
15:38:32 <sinelaw> ivanm, today i finished (really pressured) at the last moment the LAST uni. assignment
15:38:38 <sinelaw> i'm finishing my degree soon
15:38:42 <ivanm> sinelaw: cool!
15:38:48 <sinelaw> that's why i'm a little off
15:38:54 <ivanm> yeah, np
15:39:35 <ivanm> sinelaw: anyway, the main changes that will possibly affect you: type sigs get a bit more verbose but also more explicit about what they're doing (from the type family usage)
15:39:42 <sinelaw> wasting all my free time thinking about FRP
15:39:46 <Philonous> Is there a stable library for functional temporal programming?
15:39:53 <sinelaw> heh
15:40:04 <ivanm> you can now do equality on graphs, etc. (since some people have resorted to using graphviz to do serialisation with current fgl :s)
15:40:13 <sinelaw> Philonous, there are a few more recent ones, there is no standard good one yet
15:40:29 <sinelaw> Philonous, take a look at Peakachu (not documented though, you'll have to ask yairchu) or elerea
15:40:32 <ivanm> and some function names, etc. will change
15:40:42 <Philonous> sinelaw: Ok, thanks
15:40:43 <sinelaw> ivanm, yeah the instances part is nice
15:41:04 <sinelaw> Philonous, the older ones are Reactive (which is a very serious attempt but has bugs) and Yampa (a bit older)
15:41:10 <ivanm> note that you can't derive them, you have to explicitly state them, but we provide functions that do that for you
15:41:24 * ivanm heads off for real this time
15:41:27 <sinelaw> ok
15:41:37 <yairchu> Philonous: you can also check out the game "DefendTheKing" written using it. the code is long but only because it's a networked real-time-strategy game
15:41:58 <sinelaw> yairchu is talking about peakachu
15:42:02 <sinelaw> not yampa
15:42:50 <Philonous> sinelaw: Guessed so as you mentioned him/her in relation with peakachu
15:43:06 <sinelaw> k
15:43:09 <Philonous> sinelaw: I've looked at reactive but it seamed to have some problems
15:43:28 <sinelaw> Philonous, yeah reactive has open bugs and it doesn't seem like they're getting fixed
15:44:22 <Philonous> yairchu: Will do, thanks.
15:44:39 <sinelaw> yairchu, to be honest some intro docs are really needed
15:44:49 <sinelaw> :)
15:45:13 <yairchu> sinelaw: help is welcome :)
15:45:26 <yairchu> welcomed
15:45:50 * hackagebot fixed-precision 0.4.0 - Fixed Precision Arithmetic  http://hackage.haskell.org/package/fixed-precision-0.4.0 (EdwardKmett)
15:46:27 <sinelaw> edwardk, that thing uses TH?
15:46:33 <sinelaw> yairchu, yeah, if i only had time :)
15:46:44 <sinelaw> and also i don't remember most of the stuff you told me
15:46:54 <edwardk> sinelaw: only optionally
15:47:03 <edwardk> sinelaw you can specify precision three ways
15:47:05 <sinelaw> edwardk, i mean if you want static stuff
15:47:13 <sinelaw> with specific bit lengths
15:47:20 <edwardk> you can say: sin pi :: Fixed Down Double -- which gives you 53 bits
15:47:26 <sinelaw> yeah i see the README
15:47:26 <edwardk> sin pi :: Fixed Down $(bits 12345123)
15:47:32 <edwardk> or you can reify it from a value
15:47:51 <edwardk> which means it uses universal quantification to guard you against shooting yourself in the foot
15:47:55 <sinelaw> edwardk, what do you use this lib for? cause i have at least one idea :)
15:48:20 <edwardk> sinelaw: i plan on using it for interval arithmetic as part of some code for taylor models
15:48:30 <sinelaw> aaaaah
15:48:31 <sinelaw> that
15:48:40 <edwardk> what is the idea if you don't mind sharing?
15:48:44 <napping> What's a taylor model?
15:49:04 <sinelaw> edwardk, i was cynical now, if that wasn't clear. i have no idea what you mean.
15:49:19 <sinelaw> as for my idea: use it for hardware description language generation
15:49:21 <edwardk> napping: when you work with interval arithmetic it tends to have some problems with the fact that intervals quickly expand
15:49:28 <Peaker> sinelaw, yairchu: I think the most important thing is explaining the outline: The fact the combinations are of type sums, not products, that a "Program" converts type sum streams. That the Category instance is not chronological, but pipelining. That "Append" is chronological, and "Merge" is a parallelization
15:49:48 <sinelaw> Peaker, yeah i told yairchu earlier that two paragraphs ought to do it
15:49:53 <napping> Oh, you want to extend affine intervals with low degree polynomials in the epsilons?
15:49:55 <edwardk> napping: you can fix this by using a better model, a taylor model uses a taylor series, and just a very small interval that contains the error of the series
15:51:05 <napping> Anyone here know about Haddock internals?
15:51:06 <sinelaw> edwardk, i did some hardware development recently and following the fixed-point error bounds and requirements is a huge headache
15:52:06 <edwardk> so if you have a function f :: R^n -> R that is defined on some n-ary interval x :: IR^n, you build can build a taylor model around any point in x , which consits of the first n terms of the taylor series, and an interval covering the remainder and into which you throw any accumulated detritus from floating point error, etc.
15:52:15 <edwardk> sinelaw: then very much so 
15:52:22 <mreh> napping >+++*>
15:52:34 <edwardk> sinelaw: though the taylor models might be better than raw intervals for the reasons mentioned above
15:52:53 <edwardk> there exists one taylor model library out there that is in wide use, but it has an academic-only license.
15:53:11 <edwardk> and taylor models need derivatives, and i already have code for generating those...
15:53:13 <chrisdone> i just tried out haskelldb on one of my databases, looks pretty neat!
15:53:18 <edwardk> so it seemed like a good fit
15:54:33 <edwardk> sinelaw: there even turn out to be neat tricks for 'cleaning up' taylor models as you go moving error out of the interval and back into the taylor terms.
15:54:49 <sinelaw> sounds awesome
15:55:12 <sinelaw> i want to understand this. but not at this exact moment
15:55:26 <sinelaw> can you point me to some reading material?
15:55:33 <edwardk> they turn out to be useful when solving initial value problems/ODEs because you can model the uncertainty in the initial value with the interval, and see where the system might go based on the entire starting interval
15:55:49 <edwardk> rather than the usual IVP approach of just 'shooting bullets' and seeing where they land
15:56:12 <edwardk> sure, one sec.
15:57:00 <sinelaw> edwardk, nice. i think i studied something related in control theory
15:57:01 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.76.3313 is a good easy to read introduction
15:57:16 <edwardk> i discovered them by accident a couple of weeks ago
15:57:16 <sinelaw> also ode-based analysis of where the thing can go
15:57:34 <sinelaw> edwardk, but that was mainly fourier based stuff
15:57:40 <edwardk> *nods*
15:57:59 <edwardk> i'm more familiar with fourier analysis myself
15:59:11 <edwardk> I hadn't cared about initial value problems since college, but then sclv brought up the question of how to generalize his lazy splines library to multiple dimensions during hac-phi and i became curious again
16:01:54 <sinelaw> edwardk, i liked the nyquist analysis thing using Cauchy's argument principle
16:01:57 <edwardk> sinelaw: but it looks like i need to go fix bugs in hmpfr before fixed-precision will be usable =(
16:02:04 <sinelaw> heh
16:03:06 <edwardk> sinelaw: it works fine until you look at its answers ;)
16:03:24 <sinelaw> heh
16:03:27 <sinelaw> small problem
16:03:35 <sinelaw> edwardk, do you know that nyquist test thing?
16:03:46 <sinelaw> for convergence
16:03:57 <edwardk> i know cauchy's argument principle, but i'm not recalling the nyquist test off hand
16:04:31 <edwardk> the stability criterion?
16:04:34 <sinelaw> yes
16:04:48 <edwardk> ahh
16:04:50 <edwardk> yes
16:06:37 <sinelaw> who would have guessed that by counting curve rotations around the point -1 you get to know stability
16:07:02 <edwardk> Probably Harry Nyquist ;)
16:07:10 <sinelaw> yes indeed
16:09:19 <edwardk> i never did take any classes on control engineering. googling around the space makes it look interesting in theory. probably hell in practice
16:09:53 <sinelaw> edwardk, i did one course and it was boring as hell due to very bad lecturing, but looked interesting
16:10:36 <edwardk> i didn't stick around long enough in academia to find fun electives
16:10:51 <sinelaw> it wasn't an elective
16:10:58 <edwardk> fair nuff
16:10:59 <magicman> ?unmtl ContT b m a
16:10:59 <lambdabot> (a -> m b) -> m b
16:11:08 <magicman> ?type (return undefined >>=)
16:11:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m b
16:11:14 <sinelaw> and i'm not sticking around enough either. finishing my undergrad and getting out, at least for now
16:12:11 <edwardk> I'd love to go play academic but I can't afford the pay cut to get my phd.
16:12:31 <sinelaw> i would like it in theory, but i can't stand exams
16:12:41 <sinelaw> i never do very good even if i know
16:13:09 * edwardk loves exams
16:14:04 <sinelaw> ugh
16:14:09 <sinelaw> you're kidding
16:14:31 <malc_> I love traffic lights but only when they're green
16:14:39 <edwardk> No, actually. I have a bit of an obsessive personality that is somehow very much gratified by testing material. ;)
16:14:57 <sinelaw> edwardk, you must be one of those that always do well
16:15:11 <edwardk> Before I binged through academia I collected like 50-odd different industry certifications in overcompensation for my lack of formal education ;)
16:15:42 * gwern never understands people who don't test well. what's with them
16:15:59 <edwardk> I graduated with a 4.0/4.0. ;)
16:16:07 <edwardk> er that is out of, not divided by ;)
16:16:07 <sinelaw> ugh
16:16:09 <benmachine> I love exams except for when they scare the shit out of me
16:16:13 <benmachine> which they do with frequency
16:16:16 <sinelaw> you people disgust me
16:16:36 <malc_> edwardk: please do tell the audience how freaging old where you upon graduation
16:16:43 <edwardk> malc_: hahahahaha
16:17:11 <sinelaw> i do so bad in exams
16:17:12 <malc_> s;ea;i + more
16:17:13 <gwern> sinelaw: this is #haskell - the first target of the zombie apocalypse for our juicy brains
16:17:20 <edwardk> malc_: I was 29 when i finished my undergrad.
16:17:30 <sinelaw> edwardk, just as I am at this very moment, finishing my undergrad
16:17:32 <edwardk> Though, to be fair I started it when I was 28 =P
16:17:37 <mjk> I use Gtk2Hs, in menu item the event "onActivateLeaf" excute the code "mainQuit", if in ghci, it can't close the main window;if make it to .exe file in XP console, it's ok, why?
16:17:46 <gwern> there probably isn't a single person here with an iq below 120, and I'd lay pretty good odds that it may be as high as 130
16:17:50 <sinelaw> took me 4 years though
16:18:01 <sinelaw> whcih is the standard program for this degree
16:18:24 <malc_> gwern: you'd loose the money
16:18:36 <sinelaw> edwardk, funny coincidence. i'm 29
16:19:21 <gwern> edwardk: how does one do a bachelor's in a year?
16:19:21 <gwern> malc_: ?
16:19:27 <edwardk> sinelaw: i'm 34 now, i picked up a couple of masters degrees and learned haskell after that, then returned to industry, 
16:19:47 <sinelaw> ok enough i'm getting depressed here
16:19:49 <hpc> gwern: connect the dots ;P
16:19:51 <malc_> gwern: sinelaw here sucks at exams, so he's iq should be pretty low
16:19:57 <hpc> or that
16:20:41 * Axman6 has an exam this arvo
16:20:50 <sinelaw> :_(
16:20:57 <edwardk> gwern: get it in writing from admissions that they'll take transfer credit even after you're enrolled. enrolled at 3 other colleges, CLEP/credit by exam 30 out of 120 credits, enroll in the honors program so you need 'honors credit' from doing extra work in the courses in your disciplines, and then use the honors credit to shorten dependency chains
16:20:58 <benmachine> IQ tests your peformance at IQ tests :O
16:20:59 <gwern> malc_: not necessarily. plenty of people do well on iq tests than even heavily g-loaded tests like the sat
16:21:11 <edwardk> gwern: and it was a double bachelors' ;)
16:21:26 <gwern> benmachine: among other things...
16:21:52 <benmachine> gwern: debatable >_>
16:22:04 <gwern> edwardk: what. you enrolled in 4 colleges just to take some exams and get credits from them
16:22:06 <siracusa> mjk: Yes that's a bit strange, try `destroyWidget win' where win is the main window and call mainQuit in the handler for destroying the main window
16:22:09 <benmachine> well, I say that largely on the basis of wishful thinking
16:22:21 <edwardk> gwern: the multiple enrollments worked around the credit count cap until i convinced them to let me do all my coursework for the final semester there. and i got them to let me count 4 graduate courses as undergradute courses to work around scheduling conflicts
16:22:48 <gwern> benmachine: no, the statistics are pretty solid. IQ is correlated with health, longevity, earnings, lack of crime, and a whole host of other things
16:22:58 <edwardk> gwern: no i enrolled at 4 colleges for real, doing 30+ credits in a semester.
16:23:00 <sinelaw> edwardk, impressive bureaucracy engineering there
16:23:02 <mjk> siracusa: i try it
16:23:21 <benmachine> gwern: hmph
16:23:23 <gwern> edwardk: I am mildly amazed and impressed. was this for a dare or were you just in that much of a hurry?
16:23:29 * benmachine mumbles something about correlation and causation
16:23:40 <edwardk> gwern: mostly to see if i'd burn out
16:23:49 <hpc> did you?
16:23:56 * gwern ponders doing 30+ credits a semester. just getting the classtime in sounds like a challenge
16:24:00 <edwardk> gwern: but i was also trying to fix a serious imbalance in my work/education mix ;)
16:24:11 <edwardk> gwern: i wrote software to solve my schedule ;)
16:24:23 <edwardk> hpc: nah, i ran out of money before i burned out =(
16:24:33 * malc_ edwardk used C++ for this software
16:24:37 <malc_> now attack him
16:24:44 <edwardk> malc_: hahahaa worse. perl.
16:24:45 <luite> how many credits is normal for a semester? (the european credits are 60 a year, so 30 for a semester wouldn't be spectacular :) )
16:24:54 <edwardk> luite: 12 is a full load here
16:24:57 <benmachine> edwardk: I prefer perl to C++, it has fewer illusions :P
16:24:58 <gwern> benmachine: if you admit the correlations, as the data forces you to, you must then admit IQ is measuring a third factor - which is all I need to prove to prove 'among other things'
16:24:59 <malc_> edwardk: oh yeah i've forgotten that you were into that
16:25:05 <hpc> perl has excellent hackability
16:25:20 <gwern> edwardk: really? that sounds like a NP problem - like binpacking
16:25:31 <benmachine> gwern: ok, but I don't have to admit that that's intelligence, I guess
16:25:34 <sinelaw> edwardk, i was too interested in various non-school related subjects to study efficiently and get good grades
16:25:35 <hpc> NP != unsolvable, and there aren't that many classes
16:25:42 <gwern> benmachine: no, but I wasn't trying to make you admit that :)
16:25:44 <edwardk> gwern: it is, so give in and use a 2-optimal solution then improve it
16:25:53 <sinelaw> edwardk, haskell being the main one
16:25:54 <benmachine> gwern: cool beans
16:26:14 <gwern> benmachine: important part of philosophy - keeping in mind what you're trying to prove and not proving too much or too litte
16:26:17 <edwardk> i fortunately didn't discover haskell until i was finishing my math MA
16:26:50 <benmachine> I discovered haskell while starting my maths BA
16:26:56 <benmachine> am I going to get screwed [y/n]
16:27:02 <malc_> edwardk: bullcrap, you didn't fall in love, but discover..
16:27:08 <benmachine> actually probably n
16:27:10 <gwern> (did you know MacFarlane of gitit/pandoc etc. is a philosophy professor? I didn't until I happened to check out his website.)
16:27:25 <benmachine> (was haskell invented or discovered??)
16:27:37 <jesusabdullah> gwern: Really? That's interesting
16:27:53 <jesusabdullah> But it makes sense based on the "feel" I got from the pandoc website
16:27:53 <malc_> it was begotten by unholly aliance between Miranda and that other guy
16:27:56 <sinelaw> edwardk, i think having a lot of industry experience was the culprit of my studies
16:27:58 * jesusabdullah isn't gonna explain that
16:28:10 <sinelaw> i knew too much to be interested in doing well
16:28:13 <tromp_> haskell was born
16:28:16 <sinelaw> a lot of stuff was boring
16:28:29 <benmachine> sinelaw: "knowing too much" is not an excuse that tends to work on my supervisors unforunately :(
16:29:17 <sinelaw> benmachine, same here
16:29:23 <mjk> siracusa: Excuse me! can you give me a piece code?
16:29:38 <sinelaw> benmachine, although in my final degree project it helped a lot. they gave me compelte freedom
16:29:43 <siracusa> mjk: one sec ...
16:29:47 <sinelaw> and i picked my own subject (that FRP robot)
16:30:02 <sinelaw> instead of being forced to do what some supervisor tells me to
16:30:14 <edwardk> industry experience was really useful. a lot of time students have trouble figuring out why they should care about what the professor is lecturing about. having been a graphics guy, i had no problem with motivation for linear algebra, calc, diff eq. having played with wavelets, i loved fourier analysis, etc.
16:31:00 <benmachine> I never ask why I should care about maths :P
16:31:01 <sinelaw> that's true
16:31:01 <gwern> I sometimes think people go to college too early
16:31:08 <sinelaw> i was much more interested in the maths than others
16:31:11 <edwardk> malc_: actually haskell was spawned inspite of miranda ;)
16:31:11 <dons> @seen alexyk
16:31:11 <lambdabot> Unknown command, try @list
16:31:13 <benmachine> actually that's not true
16:31:38 <benmachine> sometimes bits of the course are like wtf this has nothing to do with anything
16:31:49 <malc_> edwardk: yeah yeah, commercial slut miranda was
16:31:59 <dafis> preflex: seen alexyk
16:31:59 <preflex>  alexyk was last seen on #haskell 1 hour, 22 minutes and 6 seconds ago, saying: dafis: love mail! :)
16:32:33 <benmachine> ironically that tends to be the "example applications" they shoehorn into applied courses
16:33:27 <dafis> dons: new insights on alexyk's code?
16:34:29 <zuserm> hey, I want to do something like:
16:34:29 <zuserm> data D a b = A a | B b
16:34:29 <zuserm> instance (Enum a, Enum b, Bounded a, Bounded b) => Enum (D a b) where
16:34:29 <zuserm>     fromEnum (A a) = fromEnum a - (minBound :: a)
16:34:29 <zuserm>     fromEnum (B b) = fromEnum b - (minBound :: b) + (maxBound :: a) + 1
16:34:29 <zuserm>     toEnum = undefined
16:34:30 <zuserm> but the type vars don't make it, is there some way around this?
16:34:48 <heropass> \quit rebooting for system update
16:34:53 <benmachine> zuserm: first of all, for big pastes please use a pastebin
16:34:56 <kmc> zuserm, -XScopedTypeVariables
16:34:58 <zuserm> sorry
16:35:01 <benmachine> zuserm: secondly, yes that
16:35:09 <kmc> pastebin is more convenient too, since it won't scroll away
16:35:22 <sinelaw> edwardk, do you recommend doing a masters?
16:35:26 <kmc> you can rejigger the code to avoid it though
16:35:33 <benmachine> zuserm: however, your code doesn't really make sense, because minBound isn't necessarily Num
16:35:39 <kmc> :t asTypeOf
16:35:40 <lambdabot> forall a. a -> a -> a
16:35:52 <kmc> fromEnum (A a) = fromEnum a - (minBound `asTypeOf` a)
16:35:56 <edwardk> sinelaw: i learned more from each than i did from my bachelors.
16:36:06 <sinelaw> which masters did you do
16:36:26 <benmachine> zuserm: possibly you mean fromEnum a - fromEnum (minBound `asTypeOf` a)
16:36:29 <edwardk> math and cs (with a "graduate certificate" in AI mixed in)
16:36:32 <sinelaw> problem is i may lack math skills, may need to do math bachelors to really know something 
16:36:42 <zuserm> yeah, i forgot some fromEnums
16:36:44 <siracusa> mjk: Something like this should work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26269#a26269
16:36:53 <benmachine> wait, minBound not being Num is not the problem, it not being Int
16:36:59 <benmachine> is the problem but ok you know already
16:37:04 <sinelaw> edwardk, math in my bachelor's is very lacking
16:37:13 <mjk> siracusa: thx
16:37:18 <sinelaw> math for engineers style of things except for two or three good courses
16:37:31 * jesusabdullah too :D
16:37:33 <jesusabdullah> well, sort of
16:37:41 <jesusabdullah> math minor, so I got linalg and optimization
16:37:46 <jesusabdullah> but otherwise!
16:38:05 <edwardk> sinelaw: most people who only get exposed to math via math-for-engineers courses just don't get what all the fuss is about. not enough focus on proof and foundation, more on mechanical application
16:38:05 <jesusabdullah> still, all very practical
16:38:42 <sinelaw> edwardk, yeah but i had the luck to have those 2-3 very good courses
16:38:54 <sinelaw> so i know what i'm missing
16:39:43 <edwardk> i think binging through math by total immersion was immensely helpful to me, i didn't have time to forget the material before i was using it again
16:40:32 <benmachine> edwardk: yeah, all my friends doing science courses are like "maths is boring" and I go "no it's not" and then they show me their maths and I go "...yup, that's pretty boring"
16:40:52 <edwardk> benmachine: =)
16:41:04 <edwardk> benmachine: very well put
16:41:36 <hpc> theoretical scientists, experimentalists, or engineers?
16:41:56 * hpc doesn't consider engineering science courses to be real science
16:42:05 <jesusabdullah> Well no, it's engineering!
16:42:06 <benmachine> hpc: mine? the course is called "natural sciences"
16:42:24 <benmachine> I'd say theoretical but I don't do the course so I don't know
16:42:24 <hpc> that sounds like biology
16:42:31 <benmachine> it isn't
16:42:34 <benmachine> well
16:42:39 <benmachine> it's crazy modular
16:42:49 <benmachine> you can do biology if you like but plenty of people don't
16:42:52 <benmachine> it's basically like
16:42:56 <kmc> haha benmachine
16:43:02 <sinelaw> a lot of engineering courses are actually abstract math
16:43:09 <sinelaw> not totally abstract
16:43:12 <sinelaw> but pretty high level
16:43:15 <benmachine> you get a normal university's physics, chemistry, and biology courses, and you randomly swap bits of them as suits you
16:43:18 <hpc> it's like the delicatessen version of science?
16:43:19 <benmachine> and you get natural sciences
16:43:21 <sinelaw> control engineering being one example
16:43:26 <sinelaw> and statistical signal processing another
16:43:26 <jesusabdullah> applications of abstract maths to physical systems
16:43:28 <hpc> you pick your toppings, and always come out with a sandwich
16:43:33 <jesusabdullah> material mechanics!
16:43:33 <sinelaw> (basically work on hilbert spaces)
16:43:38 <benmachine> hpc: basically yes :P
16:43:45 * jesusabdullah really likes material mechanics
16:43:49 <hpc> that sounds fun, actually
16:44:13 <hpc> conceptually fun, anyway
16:44:16 <benmachine> heh
16:44:22 <benmachine> I don't know why it's done like that
16:44:24 <benmachine> but it seems to work!
16:46:05 <sinelaw> do you blow things up?
16:46:14 <sinelaw> if you don't blow things up it's not fun
16:46:25 <sinelaw> or not
16:47:22 <sinelaw> mechanical engineering have nice labs
16:47:26 <sinelaw> where you actually build stuff
16:47:31 <jesusabdullah> Not my ME :(
16:47:38 <jesusabdullah> Our EE department has lots of labs here, though
16:47:45 <sinelaw> jesusabdullah, i think it's in 3rd year mostly
16:47:49 <jesusabdullah> My girlfriend built a color organ
16:47:49 <sinelaw> at least here
16:47:52 <jesusabdullah> sinelaw: I'm a grad student
16:47:55 <sinelaw> ah
16:47:57 <sinelaw> :(
16:48:00 <jesusabdullah> Yeah :(
16:48:01 <sinelaw> jesusabdullah, really?
16:48:05 <jesusabdullah> There are some okay labs early on, yeah
16:48:10 <jesusabdullah> but our labs are lacking imo
16:48:15 <sinelaw> in ee here all we had is horribly boring transistor-resistor style stuff
16:48:20 <sinelaw> didn't build anything
16:48:20 <gwern> color organ?
16:48:24 <jesusabdullah> Yeah, the early crap sucks balls
16:48:27 <sinelaw> i hate transistors
16:48:30 <sinelaw> so complicated
16:48:33 <hpc> resistor labs are bullshit
16:48:43 <sinelaw> hpc, no it was pretty high level
16:48:46 <sinelaw> but i don't like it
16:48:50 <jesusabdullah> Yeah gwern, she had a lowpass, bandpass and highpass filter attached to some LEDs and piped music to it
16:49:05 <sinelaw> jesusabdullah, awesome
16:49:06 <jesusabdullah> so the bass made the red LED pump, and the guitar made the yellow one light up
16:49:08 <jesusabdullah> Yeah, it was rad
16:49:11 <hpc> awesome
16:49:16 <sinelaw> we had some stuff like that but it was just connected to a scope
16:49:16 <jesusabdullah> Looked really nice with RHCP's "snow"
16:49:26 <hpc> it needs MIDI out into a tesla coil
16:49:33 <gwern> 'rabbi? rabbi, is there a proper prayer for the Czar^Whardware?' 'is there a blessing for the hardware - of course there is a blessing for the hardware, my son! ... May God bless and keep the hardware.... far away from us!'
16:49:38 <jesusabdullah> She had to design a mips processor in vhdl too
16:49:52 <sinelaw> jesusabdullah, i did that too!
16:49:54 <sinelaw> that was fun
16:49:54 <jesusabdullah> which sounds horrible, but also pretty cool
16:49:57 <jesusabdullah> Cool!
16:50:06 <sinelaw> it was a lot of work, we did it from scratch completely
16:50:08 <jesusabdullah> She doesn't like programming, so I don't think she really enjoyed it
16:50:11 <jesusabdullah> but I thought that was cool
16:50:12 <sinelaw> VHDL is horrid
16:50:13 <jesusabdullah> Yeah, same with her
16:50:15 <sinelaw> that's is true
16:50:22 <napping> the new reduceron stuff is neat. I was just reading the strategy paper - I bet you could do sparks really cheaply in hardware
16:50:25 <jesusabdullah> Like, every lab involved adding more to it
16:50:44 <jesusabdullah> until the end, when it could actually do something with a given set of instructions
16:50:48 <jesusabdullah> neat stuff
16:50:55 <gwern> sounds like a serious learning experience
16:50:58 <sinelaw> cool, we just had to build the whole thing from scratch including specialized instructions for doing image processing faster and stuff, pipelining, etc...
16:50:59 <jesusabdullah> yeah
16:51:09 <jesusabdullah> crazy
16:51:09 <napping> Also, it's not obvious how you could pipeline it for a single program, but if you go SMT it should be easy
16:51:19 <sinelaw> SMT?
16:51:28 <napping> Simultaneous MultiThreading
16:51:32 <sinelaw> i wish we had used Lava or something instead of that horrible VHDL
16:51:36 <monochrom> SAT modulo theories
16:51:40 <sinelaw> also verilog, although it's a tad less worse
16:51:42 <jesusabdullah> verilog?
16:51:42 <napping> that too :)
16:51:43 <jesusabdullah> hah
16:51:50 <jesusabdullah> beat me to it
16:51:51 <sinelaw> Lava looks neat
16:52:09 <sinelaw> verilog is vhdl without the overhead
16:52:12 <gwern> I sometimes wonder if philosophy could be taught better by taking a single work like descartes's _Meditations_, fully formalizing it, and then classifying objections to it by which premises they deny
16:52:57 <napping> or finding how completely shot through with implicit assumptions it is
16:53:21 <gwern> napping: that's quite valuable too
16:53:24 <napping> and fun side discussious about your choice of underlying logic. Bleh
16:53:57 <gwern> most arguments are enthymatic to an extent one doesn't realise
16:54:11 <jesusabdullah> what is lava, exactly?
16:54:29 <sinelaw> jesusabdullah, haskell embedded language for hardware description
16:54:39 <jesusabdullah> ah
16:54:52 <sinelaw> the reduceron guys use one variant of it
16:54:57 <jesusabdullah> apparently there's a visual "programming language" called Lava
16:54:59 <jesusabdullah> and I was like
16:55:03 <sinelaw> no... :)
16:55:06 <jesusabdullah> "this can't be right"
16:55:07 <jesusabdullah> XD
16:55:11 <sinelaw> P
16:55:22 * jesusabdullah googles reduceron
16:55:25 <sinelaw> http://www.cs.york.ac.uk/fp/reduceron/
16:55:38 <sinelaw> jesusabdullah, ^^^
16:55:43 <jesusabdullah> *nod*
16:55:49 <Peaker> Programming by editing a text string sucks -> Let's do visual programming -- a really common non-sequitur
16:56:01 <sinelaw> edwardk, are lie groups important / useful to know?
16:56:11 <napping> gwern: I think you'd have trouble getting people to accept any reasonably powerful underlying logic
16:56:21 <sinelaw> napping, also at you since you seem to be a math guy
16:56:24 <jesusabdullah> Trying to keep track of how components interact with each other with visual programming sucks
16:56:27 <jesusabdullah> :S
16:56:32 * jesusabdullah learned labview in some labs
16:56:38 <gwern> napping: why not? most philosophers can be handled by predicate logic and modal logic
16:56:40 <jesusabdullah> I guess our labs don't suck that bad
16:56:44 <jesusabdullah> they're just relatively easy is all
16:56:53 <lispy> gwern: what is modal logic?
16:56:58 <gwern> those aren't too bad. if you're a philosophy student and you can't handle predicate and modal logics, you don't deserve to be a philosophy student
16:57:18 <sinelaw> my last lab is due soon, we programmed an fpga to filter colors out of a video stream
16:57:24 <sinelaw> pretty silly
16:57:34 <gwern> lispy: think predicate logic, extended with a few operators to speak about 'possible', 'impossible', 'necessary', 'must' predicates
16:57:56 <lispy> gwern: ah
16:58:04 <sinelaw> what's the logic model for the common mathematical reasoning?
16:58:27 <lispy> sinelaw: I know it as 'classical' logic
16:58:27 <edwardk> sinelaw: they come up a lot in differential geometry. it depends on what you want to do
16:58:33 <monochrom> classical logic
16:58:41 <jesusabdullah> oh, so that's what those are called (fpga)
16:58:42 <gwern> lispy: so you might say '(possible) in (all worlds) that (forall x. x == x)', in my english version if you catch my drift
16:58:57 <napping> Well, I was thinking of mechanized formalizations. And things like infinite stacks of universes are the sorts of things I've seen philosophers be sceptical about
16:58:57 <lispy> sinelaw: and intuitionistic logic (or construction logic) seems to be catching on these days
16:59:11 <edwardk> sinelaw: "classical"
16:59:14 <lispy> gwern: got it, thanks
16:59:27 <mjk> siracusa: now it's OK! thank you
16:59:38 <sinelaw> heh ok thanks lispy, monochrom, and edwardk 
17:00:03 <Saizan> (anyone knows any twelf here?)
17:00:19 <lispy> dons: do you speak twelf?
17:00:35 <gwern> lispy: you would use this for something like descartes's ontological arguments. for example, you might formalize 'if god exists in one possible world, he will exist in all other worlds; there is possible world with god; therefor god exists in all worlds' (this is not descartes argument)
17:00:53 <monochrom> Many humans are too smug and proud of their human identity to formalize anything. Ambiguity gives them "richness" and leeway to weasel.
17:00:54 <gwern> *is a
17:01:18 <gwern> monochrom: yeah yeah go tell it to #lojban :)
17:01:49 <sinelaw> monochrom, i realized that one of my weaknesses is actually a strength. sometimes I "don't understand" but it's really that the stuff i'm learning is not well defined
17:01:52 <napping> Saizan: how about Coq? What are you looking for?
17:02:14 <edwardk> Saizan: enough to claim i know 'any twelf' but not enough to be useful for answering your twelf questions ;)
17:02:17 <sinelaw> monochrom, i've had multiple instances during my degree where everybody got it except for me
17:02:24 <sinelaw> and it turned out to be just plain wrong
17:02:31 <kmc> modal logic is really a family of logics, depending on which modal operators you add
17:02:35 <sinelaw> (usually not defined precisely)
17:02:53 <kmc> for example one useful one is linear temporal logic, which has "next", "always", "eventually", and "until"
17:03:16 <edwardk> kmc: hence why display logic is cool, even if logicians hate it
17:03:50 <lispy> gwern: okay
17:03:54 <monochrom> Many programmers and mathematicians alike like to document incompletely. This gives them license to accuse reader of "not seeing the obvious".
17:04:05 <sinelaw> monochrom, yeah
17:04:12 <sinelaw> "it's easy to see..."
17:04:16 <Saizan> napping, edwardk: i've this puzzling error http://pastebin.com/3XZ1sasZ i can't see what it could be complaining at :\
17:04:32 <sinelaw> one guy told the lecturer once: easy to see...but difficult to understand!
17:04:41 <dolio> gwern: You forgot the equivocation. That argument isn't convincing without the equivocation. :)
17:04:52 <gwern> @wn mathematicaster
17:04:53 <lambdabot> No match for "mathematicaster".
17:05:00 <monochrom> "realToInt: this function converts real to int" "of course everyone knows what I mean"
17:05:08 <magicman> ... twelf looks like Prolog meets Agda.
17:05:13 <cheater99> hi
17:05:19 <cheater99> hello monochrom 
17:05:19 <gwern> dolio: oh? how would you equivocate that modal ontological argument?
17:05:22 <magicman> I'm intrigued.
17:05:34 <monochrom> monochrom does not know cheater99
17:05:49 <magicman> (at least, the example on wikipedia does so...)
17:05:49 <cheater99> sure you do
17:05:49 <Saizan> magicman: yeah, + higher order terms
17:06:02 <sinelaw> another thing is that in my degree they try to make it easier by simplifying some things and that only ends up being more complicated because less precise
17:06:05 <dolio> gwern: You get people to agree with the premises without explaining the technical definitions of "necessary" and "possible".
17:06:09 <cheater99> we used to troll eachother on efnet #math.
17:06:53 <lispy> cheater99: does that mean we get to feed you till you explode?
17:06:55 <gwern> dolio: maybe you do, but I strive to be a simple honest atheist analytic philosophy guy :)
17:07:01 <napping> Saizan: sorry, that seems like syntax. Looks fine to me if [x] is the binding and = fits in %define and so on
17:07:03 <cheater99> lispy: <3
17:07:29 <dolio> gwern: You'll never give philosophy a bad name like that.
17:07:52 <gwern> dolio: all I have to do is corrupt the morals of some youth
17:08:06 <gwern> shouldn't be too hard. just turn my harsh gaze on society's idols
17:08:26 <napping> edwardk: does display logic help capture substructural systes?
17:08:46 <napping> I'm in the market for a dependent type system with linear types
17:09:02 <edwardk> napping: yes!
17:09:37 <sinelaw> did you guys hear about that conman who claims to have 200-point IQ (and probably does) but also claims to have developed a "science" in which he "proveS" that god exists?
17:10:12 <sinelaw> i checked it out it turns out the "paper" he wrote was publised in a creationist thing disguised as a scientific journal
17:10:16 <edwardk> napping: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.30.4174
17:10:42 <gwern> sinelaw: he's from long island, so I've read entirely too many articles
17:10:51 <kmc> kurt g√∂del had a symbolic proof of the existence of god
17:11:02 <sinelaw> gwern, i checked out his stuff, it's completely void of content
17:11:09 <sinelaw> not a single definition even
17:11:18 <kmc> perfectly valid symbolic logic, starting from cherry-picked axioms of course
17:11:18 <gwern> sinelaw: I meant to read his book just to see where he goes wrong, but not sure it was ever published
17:11:26 <gwern> kmc: yeah, it's pretty interesting. I disagree with a core assumption, naturally
17:11:28 <sinelaw> gwern, sadly he was on TV and many people took it seriously
17:11:41 <gwern> langan is weird
17:11:59 <sinelaw> gwern, which assumption was it that you disgree with?
17:12:04 <sinelaw> kmc, sounds interesting
17:12:20 <gwern> sinelaw: iirc, that having all properties is not contradictory
17:12:46 <jesusabdullah> that's a pretty outrageous assumption
17:12:48 <sinelaw> gwern, even the property of not having all properties?
17:12:53 <kmc> though, the L√∂wenheim-Skolem theorem says that there exist models for G√∂del's system whose gods are only countably omnipotent
17:12:59 <gwern> :)
17:12:59 <kmc> :D
17:13:00 <edwardk> napping: also http://consequently.org/papers/display.pdf -- i can't find the original "substructural logic on display" paper that i read which i believe was also by restall
17:13:02 <sinelaw> haha
17:13:54 <gwern> sinelaw: one of my professors, grim, tried to show that god's omniscience involves a contradiction by way of powersets and the old set paradoxes
17:14:03 <cheater99> kmc: countability is fine, that still means the god could be every single atom in the universe.
17:14:13 <edwardk> kmc: that is fine, if you're an ultra-finitist it might be the same thing ;)
17:14:34 <gwern> infinities are why we can't have nice things
17:15:13 <sinelaw> no, lack of sleep is why
17:15:37 <sinelaw> night! :)
17:15:39 <gwern> 'In his essay "Don't Eliminate Cut!" George Boolos demonstrated that there was a derivation that could be completed in a page using cut, but whose analytic proof could not be completed in the lifespan of the universe.'
17:16:11 <monochrom> of course we don't eliminate cuts in practice
17:16:38 <cheater99> gwern: what's 'cut'?
17:16:40 <edwardk> just prove the admissability of it and move on
17:16:47 <jesusabdullah> I wanna know too: What's cut?
17:16:49 <monochrom> but 1 page vs lifespan of universe is a great accomplishment :)
17:16:57 <edwardk> cheater99: a cut is a lemma or function application
17:16:57 <jesusabdullah> oh jesus, too much msg
17:17:09 <gwern> cheater99: http://en.wikipedia.org/wiki/Cut-elimination
17:17:12 <cheater99> have you guys got a link to the said paper?
17:17:25 <edwardk> cheater99: proving it is admissable in a logic proves you can reason locally in the logic
17:17:43 <napping> still finite, right? So, what's the problem again?
17:18:01 <edwardk> napping: spoken like a true mathematician ;)
17:18:56 <dolio> Is it bigger than, like e^e^e^e^13?
17:19:01 <dolio> I heard that's the highest number.
17:19:33 <edwardk> > exp (exp (exp (exp 13)))
17:19:34 <lambdabot>   Infinity
17:19:37 <edwardk> yep
17:19:40 <edwardk> it is ;)
17:19:54 <gwern> :t exp (exp (exp (exp 13)))
17:19:54 <lambdabot> forall t. (Floating t) => t
17:19:59 <blackdog> cheater99: gah, i hate how hard it is to get hold of papers without journal access.
17:20:08 <cheater99> yes.
17:20:11 <gwern> > maxBound :: Float
17:20:12 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
17:20:12 <lambdabot>    arising from a use of...
17:20:19 <c_wraith> > exp (exp (exp (exp 13))) :: CReal
17:20:19 <gwern> > maxBound :: Double
17:20:20 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
17:20:20 <lambdabot>    arising from a use o...
17:20:23 <lambdabot>   mueval-core: Time limit exceeded
17:20:26 <dolio> Also, 24 is the highest number.
17:20:26 <gwern> > maxBound :: CReal
17:20:26 <lambdabot>   No instance for (GHC.Enum.Bounded Data.Number.CReal.CReal)
17:20:26 <lambdabot>    arising from ...
17:20:33 <gwern> villainous!
17:20:42 <blackdog> it seems bizarre - the papers are photo-ready when they're delivered, and peer-review is done for free - what do the publishers provide?
17:20:42 <c_wraith> dolio, that sounds suspiciously like a quote from Mr. Show
17:20:47 <edwardk> dolio: your universe keeps contracting
17:21:03 <dolio> c_wraith: It is suspicious, isn't it?
17:21:10 <edwardk> dolio: i think this is a consequence of spending too much time in agda, you just can't prove anything about bigger numbers ;)
17:21:33 <monochrom> Cut: You want to prove A‚ä¢G via a lemma L, and the cut rule says here is how: prove A‚ä¢L, and prove A,L‚ä¢G. Then you can conclude A‚ä¢G. Cut-elimination says: you can go rewrite that proof so it doesn't use the cut rule, you can think of it as "code reuse by inlining everything", and so you see why it can lengthen proofs tremendously.
17:21:49 <dolio> Agda lets you prove things about arbitrarily large numbers. It's clearly not something an ultrafinitist would like.
17:23:17 <edwardk> dolio: an ultrafinitist is one who is willing to throw out a perfectly good good grasp on reality because said reality doesn't fit his preconceptions.
17:24:04 <dolio> Yeah. Plus, they don't have any formal systems, to my knowledge.
17:24:11 <dolio> Just don't like the ones we have.
17:24:46 <napping> I think a few of them have done some reasonably interesting things
17:25:13 <dolio> I'll admit I haven't looked very hard.
17:25:16 <napping> results about how you can prove things mod <bignum> by reasoning as in N, and stuff like that
17:26:48 <edwardk> > exp (exp (exp 79)) :: CReal
17:26:53 <lambdabot>   mueval: ExitFailure 1
17:27:38 <dolio> Oh, did I have to many es?
17:28:18 <edwardk> dolio: that's the first skewes' number, which is big enough to be plausibly not possible to compute exactly
17:28:22 <Veinor> > exp (exp 79) :: CReal
17:28:28 <lambdabot>   mueval: ExitFailure 1
17:29:08 <Veinor> graham's number is pretty funny
17:29:27 <Veinor> it's so massive you can't comprehend it
17:29:34 <Veinor> and the lower bound for the problem it's a bound on is 13
17:34:44 <interferon> so is llvm in ghc 6.12.1 or do i need to be running from darcs?
17:35:20 <napping> edwardk: plausible is a pretty pretty weak statement.
17:36:56 <edwardk> napping: not my argument ;)
17:37:03 <edwardk> i already said they were crazy ;)
17:37:39 <interferon> i cant believe that the "evil mangler" is a real thing :)
17:38:09 <monochrom> evil things are usually real. elegant things are usually platonic.
17:38:12 <napping> even just writing the power of 10 out explicitly probably runs into a Beckenstein bound
17:41:22 <Saizan> interferon: it got recently merged into HEAD iirc, so not in any release
17:41:35 <interferon> Saizan: ah i see
17:42:11 <interferon> and will llvm mean that Cmm goes away?
17:43:26 <Saizan> no
17:44:08 <Saizan> Cmm will still be what's between STG and LLVM code (or C or asm)
17:44:54 <Saizan> the evil mangler is only used when you go via C, btw
17:46:28 <Saizan> ".. -> Cmm -> C -> asm -mangler-> asm" vs. ".. -> Cmm -> asm" vs. ".. -> Cmm -> LLVM -> asm" 
17:49:39 <interferon> right
17:49:47 <interferon> and is ngc the default on an x86 machine?
17:49:59 <interferon> when i run ghc with no special flags am i running the ngc?
17:51:26 <napping> yes, for quite a few versions now
17:52:03 <uorygl> So, SpiderMonkey.  I'm going to see if I can make a Haskell binding to it.
17:52:09 <uorygl> Or, rather, the part of it that I'm actually going to use.
17:52:49 <uorygl> I've never used the FFI before.  What's my binding going to look like, if everything goes nicely?  Just a single .hs file?
17:53:24 <kmc> did you read the RWH chapter on FFI?
17:53:37 <uorygl> Nope.
17:54:19 <alexyk> I have two maps with the same keys.  One is a M.map of another.  Now I want basically a zipWith for maps; is there one?
17:54:25 <benmachine> it probably depends on how much stuff you want to import and how involved it is
17:54:54 <interferon> can i get ghc to emit intermediate languages, like core, stg, cmm?
17:55:03 <kmc> yes
17:55:08 <thoughtpolice> interferon: yes
17:55:22 <benmachine> -ddump-users-guide >_>
17:55:47 <napping> alexyk: intersection(With)
17:56:10 <alexyk> absent M.zipWith, I'm forced to do another M.mapWithKey step m1 where step k v = let v2 = M.lookup k m2 ... 
17:56:17 <alexyk> ok looking up intersection
17:56:35 <interferon> kmc, thoughtpolice: can you point me int he right direction?
17:57:06 <Saizan> ?google ghc user guide flag reference
17:57:08 <lambdabot> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/profiling.html
17:57:08 <lambdabot> Title: ChapterÔøΩ5.ÔøΩProfiling
17:57:14 <Saizan> not that!
17:57:33 <benmachine> close enough :P
17:58:00 <alexyk> that's where you end up anyways
17:58:11 <benmachine> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/options-debugging.html
17:58:36 <alexyk> Ben Laden == son of Laden, benmachine == ?
17:58:47 <benmachine> wat
17:58:49 <interferon> benmachine: thanks!
17:58:54 <benmachine> different etymology :P
17:59:36 <alexyk> "Son of machine!" -- cursed teh first robot when the blaster misfired...
18:02:13 <monochrom> or "forkIO of main"
18:03:37 <uorygl> So CString is just a bunch of bytes, not a pointer thereto, right?
18:04:07 <uorygl> If a C function takes a pointer to a string, that needs to be Ptr CString?
18:05:01 <monochrom> type CString = Ptr  CChar
18:05:28 <monochrom> "A C string is a reference to an array of C characters terminated by NUL."
18:06:10 <monochrom> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Foreign-C-String.html
18:06:12 <mjk> I used the function toolbarInsertNewButton of Gtk2Hs, but doc says Warning: this function is deprecated and should not be used in newly-written code.N
18:06:45 <mjk> which function Now I should to use?
18:07:23 <gwern> villainous!
18:08:13 <monochrom> hrm, the doc doesn't have suggestions?
18:09:00 <monochrom> it is really too bad. "id is deprecated. kthxbye"
18:09:09 <mjk> monochrom: no
18:09:15 <uorygl> monochrom: mm, okay.
18:10:29 <mjk> monochrom: the doc doesn't say suggestions
18:11:29 <monochrom> two unforgivable crimes of programmers: not write doc; not read doc.
18:12:18 <napping> I'm reading the new strategies paper. It looks like their evalList will always force the spine
18:41:54 <tommd> Am I missing something or is this failure to infer a type (inferrable because of FunDeps) a GHC bug?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26270#a26270
18:43:35 <kmc> is Tagged from the "tagged" library?
18:45:07 <kmc> i don't see how the fundep does you any good at all
18:45:31 <kmc> since 'a' is not mentioned in any of the class variables, nor is it used via ScopedTypeVariables within the scope of any signature with a 'TestClass4' context
18:53:34 <mauke> tommd: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26270#a26271
18:53:40 * edwardk looks up at the mention of Tagged
18:54:26 <edwardk> for is a good name for that combinator
18:55:38 <mauke> tommd: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26270#a26272
19:03:33 <alexyk> anybody using leksah?  how is it?
19:05:30 <blackh> alexyk: It works. Basically it's good for locating symbols and taking you to the location of your compile error. It has some minor annoyances such as wrong window focus after a text search, etc.
19:06:15 <blackh> If you can install gtk2hs on your platform, then the Leksah part is easy.
19:06:42 <blackh> Linux is the easiest platform to install gtk2hs on.
19:06:56 <alexyk> blackh: I got it installed on Mac, looks nice
19:07:11 <blackdog> blackh: did duncan catch up with you? i was chasing him about the cabal patches you made for mac os x - think they're making it in now, but he wanted to know if there was a way to do proper relocatable libs on mac
19:07:12 <Saizan> tommd: the two uses of b are implicitly instantiated to different fresh meta variables, that's the problem
19:07:13 <blackh> I can't make it work on the Mac. Are you using the supplied binary?
19:08:30 <blackh> blackdog: I can't remember how it all worked! It's been a while.
19:08:37 <Saizan> tommd: that's because let implicitly generalizes, it's not a bug
19:08:53 * kmc is still confused how 'a' does anything at all
19:08:58 <blackdog> blackh: heh, yeah. i couldn't remember either, was hoping you'd retained a bit more.
19:10:27 <blackh> Well, if dcoutts asks me, I'll read what I did. What I remember is that it wasn't a complete solution, but I think if you want to make it relocatable, you can run this Apple utility on your binaries before you release them.
19:11:01 <blackh> That seems like a reasonable solution.  It's all in the GHC manual - I documented everything.
19:12:01 <blackdog> ah, ok. i think it'll be in the next cabal release anyway
19:17:51 <alexyk> blackh: got the dmg, runs fine; I have gtk in MacPorts tho'
19:18:23 <blackh> For me it crashed, but I'm using Mac OS 10.5.8 (not Snow Leopard).
19:18:26 * alexyk observes Mac-concerned nick share prefix "black"
19:18:47 <alexyk> blackh: ah, ancient, steam-powered one
19:19:30 <alexyk> it's been 2+ years since I paid what, $129 for the Snow Leopard?
19:19:38 <blackh> I got accused of being a "Mac person" the other day.  I was horrified!
19:20:43 <alexyk> blackh: nothing wrong with that :) being a PC person is worse I guess; or a Windows one
19:21:04 <blackh> I'm mostly a sandal-wearing bearded Jethro-tull listening Linux user.
19:22:39 <alexyk> blackh: buy some Keen ones, shave teh beard and listen to New Age, then you can deserve a Mac
19:22:41 <ezyang> Re: http://blog.downstairspeople.org/2010/06/14/a-brutal-introduction-to-arrows/ it's not clear to me why this couldn't have been implemented in a monad. 
19:22:45 <edwardk> gah the version of hmpfr on code.haskell.org is old =(
19:25:31 <ezyang> ah, nvm. 
20:19:30 <ddarius> This is rather late, but the deep inference community has some interesting things to say with respect to cut and which cuts are useful/harmful.
20:21:39 <blackh> The first cut is the deepest.
20:21:40 <gwern> deep inference?
20:21:53 <Axman6> baby, i know
20:22:47 <gwern> ddarius: is deep inference that quasi new thing in machine learning for building multiple layers of encodings each of which minimizes entropy? or something
20:24:34 * hackagebot webserver 0.4.2 - HTTP server library  http://hackage.haskell.org/package/webserver-0.4.2 (KazuYamamoto)
20:24:40 <alexyk> can I replace Map Int a by IntMap while preserving all the Map's API?
20:25:05 <Axman6> should be able to i think
20:25:05 <alexyk> baby, I know deep inference
20:25:14 <Axman6> try it and find out
20:25:32 <pookleblinky> Does Chris Done ever come here?
20:25:40 <alexyk> pookleblinky: all teh time
20:25:45 <gwern> preflex: seen chrisdone
20:25:45 <preflex>  chrisdone was last seen on #haskell 4 hours, 32 minutes and 31 seconds ago, saying: i just tried out haskelldb on one of my databases, looks pretty neat!
20:25:50 <blackh> alexyk: The interface is exactly the same.
20:26:10 <alexyk> blackh: goodgood
20:26:20 <pookleblinky> Nice. I've been studying lojban, and his lojban utilities look very cool.
20:29:22 <alexyk> apparently demonadification of nested lookup speeds things up.  monads == slow!
20:30:14 <alexyk> this improvement by dafis got speedup: http://paste.pocoo.org/show/225929/
20:30:16 <ddarius> gwern: No
20:30:31 <ddarius> @google deep inference
20:30:33 <lambdabot> http://alessio.guglielmi.name/res/cos/
20:30:33 <lambdabot> Title: Deep Inference
20:30:36 <alexyk> notice how fancy-shmancy Kleisli flies out the window and takes slow with him
20:30:40 <gwern> drat. although, I couldn't see what relevance cut would have to that area anyway
20:31:40 <kmc> haha
20:31:42 <kmc> monads == slow
20:31:44 <kmc> someone tell jdh
20:31:54 <alexyk> save a kitten -- kick Kleisli's ass!
20:32:25 <alexyk> kmc: he called dons "barrow biy"; what's that?
20:32:27 <alexyk> boy
20:32:29 <gwern> monads were slow; just compare haskell with clean
20:32:38 <gwern> hopefully this is largely obviated by the last decade or so of ghc improvement
20:33:11 <alexyk> gwern: if an experienced hand like dafis squashes a monad, it makes me think!
20:33:18 <ddarius> Those should inline to the exact same thing.
20:34:05 <alexyk> ddarius: really?  then I take it all back!  Kleisli, come back, I'll change!  Hear me, Kleisli!  I'm a changed person!  I swear!
20:35:01 <alexyk> btw I wanted at first to write the boring case, but then asked and got the tadpole devil >=> thingy
20:35:36 <ddarius> alexyk: I'm not saying they do, I'm just saying that, after optimizations, they should unless some specialization or inlining is missed.  Without optimizations I can imagine there is a potentially significant difference.
20:36:16 <alexyk> ddarius: ah ok.  and I should be a millionaire! :)
20:36:33 <ddarius> alexyk: Does M refer to Data.Map?
20:36:40 <alexyk> ddarius: yep
20:39:26 <zuserm> How bad of a person would it make me to assume that toEnum 0 is valid for all instances of Enum?
20:39:54 <mauke> pretty bad
20:40:17 <Saizan> maybe you want Bounded and minBound ?
20:41:18 <zuserm> I suppose I could check that fromEnum minBound <= 0
20:41:34 <zuserm> and fromEnum maxBound >= 0
20:41:44 <zuserm> or I could just to something reasonable instead
20:41:57 <blackh> zuserm: toEnum 0 is valid for () in case that helps.
20:43:07 <zuserm> blackh, I'm pretty sure it's valid for all the common types, but there there isn't anything that says it has to be
20:43:32 <mauke> I have three types where it's not valid
20:43:38 <blackh> I would consider it valid for maxBound to be one less than minBound if the type has no values.
20:44:04 <blackh> (But then what would the values be? [*** head explodes ***])
20:44:24 <mauke> what do you mean by "one less than?"?
20:45:21 <blackh> minBound == toEnum(0), maxBound == toEnum (-1)  <-- I don't see why you couldn't make a type like this if you really wanted to
20:46:34 <jbapple> Why isn't Map Int type familied to IntMap?
20:49:23 <kmc> because Map isn't a family, both libraries predate families, it'd complicate things and break implementations other than recent GHC
20:49:34 <kmc> and confuse users who don't care
20:50:11 <jbapple> I understand some of that.
20:50:36 <jbapple> I was assuming, of course, that it would be #ifdefed out
20:50:46 <jbapple> and that Map would have to be turned into a family
20:50:57 <jbapple> and I know that they both predate families
20:51:06 <jbapple> Let me try to ask a better question
20:51:19 <kmc> i think it would make more sense to make a new, fancy finite-maps library with a drop-in API-compatible replacement
20:51:38 <jbapple> What interface problems would occur if Map were turned into a family and Map Int was IntMap?
20:52:04 <kmc> type families are already a core component of fancy nonparametric containers in vector and DPH
20:52:10 <kmc> that's one of the main use cases
20:52:14 <kmc> jbapple, you mean technically?
20:52:18 <jbapple> For instance, now, Map can be used unapplied in contexts that have kind * -> * -> *; is that true of type families?
20:52:21 <kmc> well, it'd be an overlapping instance
20:52:29 <jbapple> Oh, good point
20:52:59 * jbapple checks to see if one can make a vector a for any type a
20:54:44 <ddarius> alexyk: Yeah.  With optimizations those two functions produce the same core.
20:55:06 <alexyk> ddarius: supercool, thx!  my trust in monads is restored.
20:59:32 <alexyk> is there a library module to intern ByteStrings and return Ints?
20:59:37 <alexyk> and lookup nack
20:59:37 <alexyk> back
21:02:27 <kmc> you mean something fancier than a simple Map?
21:02:32 <kmc> perhaps you want bytestring-trie
21:06:58 <blackdog> alexyk: PerfectHash can do that
21:07:02 <alexyk> how about both forward-backwrad lookup?
21:07:03 <blackdog> uses CMPH underneath.
21:07:16 <alexyk> CMPH?
21:07:29 <blackdog> c minimal perfect hashing library
21:07:37 <blackdog> cmph.sf.net
21:07:58 <alexyk> ah ok; "insertion is not supported"?
21:08:45 <blackdog> ah, i should have said - it's for when you know the set of strings beforehand
21:09:11 <blackdog> sorry, you probably need to do it at runtime... going to need a tree or hashtable for that
21:09:15 <edwardk> hrmm. i can't seem to make hide nor hair out of why hmpfr is crashing on me =(
21:09:19 <alexyk> blackdog: well I do... but was going to collect them FP-ally
21:09:45 <edwardk> i get the fact that mpfr uses gmp, and that haskell plugs into gmp in bad ways that breaks anything else that uses gmp
21:10:05 <alexyk> how about a (bytestring-trie, IntMap ByteString) for a forward-backward dictionary?
21:10:08 <edwardk> and that theoretically hmpfr does some trickery to work around that
21:10:28 <edwardk> but i can't seem to find where their 'initS' routine ever gets used
21:10:37 <edwardk> and can't figure out if that is the problem ;)
21:11:09 <zuserm> edwardk, hmpfr is obviously crashing due to lack of vowels
21:11:17 <edwardk> hmpfr..
21:12:03 <edwardk> zuserm: well it does crash when i try to convert one to a string, so i wouldn't put it past it. but i'm only using base 10. if i was using base 11 it'd start needing vowels.
21:13:03 * alexyk imagines haskell plugging into gmp in bad ways as a giant squid fighting a giant spermwhale
21:13:26 <edwardk> alexyk: now i have visions of a spermwhale going 'bad touch! bad touch!'
21:14:00 <alexyk> haskell is the squid probably, tentacles trie to plug in
21:14:02 <alexyk> try
21:15:02 <alexyk> blackdog: thx for the reference, may come useful
21:15:03 <zuserm> I find it upsetting that fromEnum goes to Int rather than Integer
21:15:35 <blackdog> alexyk: no worries. i should put out a new release, i found i needed a couple of other functions that i haven't put in the public version yet.
21:26:22 <ddarius> edwardk: Try with an alternate Integer implementation perhaps?
21:27:23 <edwardk> ddarius: that would kind of shut down my use of the library since i'm hoping to be non-invasive
21:27:37 <ddarius> Just to test.
21:28:02 <edwardk> well, this actually makes direct reference to gmp-integer internals
21:28:18 <edwardk> so its a fairly invasive test
21:28:22 <ddarius> I figured but was hoping it wouldn't.
21:28:26 <jarick> Hello. How exactly does one getElems on a IO (IOArray Int Word8)?
21:28:37 <ddarius> @hoogle getElems
21:28:38 <lambdabot> Data.Array.MArray getElems :: (MArray a e m, Ix i) => a i e -> m [e]
21:28:45 <mauke> jarick: you don't
21:29:00 <mauke> you attach a callback and do stuff there
21:29:17 <ddarius> mauke breaks out imperative lingo
21:29:23 <jarick> mauke: I'm afraid I do not follow.
21:29:31 <jarick> http://pastebin.com/d1wAtVwb is what I was doing.
21:29:42 <jarick> It does not work, clearly because of the differing types
21:29:49 <mauke> that's a weird kind of state
21:30:03 <mauke> why is RHState a phantom type
21:30:12 <mauke> and why does it encapsulate an IO something?
21:30:50 * ddarius leaves this one to mauke.
21:30:54 <mauke> jarick: do you happen to know javascript?
21:31:15 <jarick> mauke: I won't say I "know" javascript. I came from scheme.
21:31:25 <jarick> I briefly understand it.
21:31:42 <mauke> well, my analogy would have been XmlHttpRequest
21:31:52 <jarick> Also, perhaps I am doing this entirely wrong. What is intended is to keep a state containing, amongst other things, a mutable array.
21:31:55 <mauke> the asynchronous version
21:31:59 <jarick> Which swap will mutate
21:32:05 <mauke> yeah, that's not what it does right now
21:32:19 <mauke> you have a state that's an array *generator*
21:32:46 <jarick> mauke: Ah. Right. Now that you mention it.
21:32:52 <mauke> jarick: data RHState = RHState{ win :: IOArray Int Word8 }
21:33:11 <mauke> (get rid of first 'win' and IO)
21:33:44 <jarick> mauke: I misintepreted the output of :t newarray then. Oops.
21:33:58 <jarick> Give me a moment to attempt to figure this out?
21:34:30 <mauke> newArray is a function that takes two arguments and returns an array generator
21:35:15 <jarick> Ah, I thought newArray returns an array
21:35:17 <mauke> (a custom made generator for that particular array size and element type)
21:35:52 <mauke> jarick: that wouldn't make sense because all calls with the same arguments return the same values
21:36:05 <mauke> that doesn't work well with mutable values
21:37:57 <mauke> here's my take on the IO thing: http://mauke.ath.cx/stuff/haskell/how-to-io.html
21:47:03 <jarick> mauke: Sorry to bother you again, but I still do not follow the difference between ``data Foo a = Foo Integer'' and ``data Foo = Foo Integer''
21:47:41 <mauke> it's like the difference between foo = 42 and foo a = 42
21:47:43 <jarick> This confusion is perhaps stemming from the examples in ``A Gentle Introduction to Haskell''
21:48:01 <mauke> .oO( a "gentle" introduction )
21:48:15 <mauke> jarick: the 'a' is a type parameter
21:48:59 <mauke> data Two a = C a a;  now (C 1 2) :: Two Integer
21:49:06 <mauke> C 'x' 'y' :: Two Char
21:49:36 <mauke> when a type parameter is not used in its body, it's called a phantom type
21:49:43 <jarick> Ah hah.
21:49:48 <mauke> I don't think you need to worry about that for now
21:49:51 <kmc> it's much like function-definition syntax
21:50:09 <kmc> on the left-hand side you have the name of the thing you're defining (Foo) followed by names for zero or more arguments
21:50:26 <kmc> on the right hand side you describe what the thing is, possibly using those arguments
21:50:56 <ezyang> The right-side has what's called a "phantom type" 
21:51:14 <ezyang> since a is not being used for anything. 
21:51:48 <kmc> be sure not to mix up the Foo on the left of = with the Foo on the right of =
21:51:59 <kmc> they're totally distinct things which happen to be named the same
21:52:34 <jarick> kmc: Yes, that bit I got. The RHS Foo is termed a constructor?
21:52:45 <mauke> data constructor
21:52:52 <mauke> the left Foo is a type constructor :-)
21:52:55 <kmc> yeah
21:53:03 <kmc> i've heard 'value constructor' for the RHS as well
21:53:44 <c_wraith> No response from Hint's maintainer about my minimal test cause.  Maybe that means he agrees it's a bug, and is trying to see if there's a solution.
21:53:47 * jarick rues the day he said that "Hey, I've got 9 months before school starts, let's fiddle with another language"
21:53:55 <kmc> and sometimes we are sloppy and use "type" to mean both "type" and "type constructor"
21:54:17 <Rectal> Hi guys, studying for a COMP exam, was wondering about this question. Invent a Haskell definition of a function that has the same type as g, but for which the type of f would be too general. I am assuming I would need a Eq in there somewhere
21:54:18 <kmc> like you'll talk about "the Maybe type", but really Maybe is a type constructor, and things like (Maybe Char) are types
21:54:41 <kmc> Rectal, that does not follow from the information you've given us
21:54:47 <kmc> we don't know what f and g ar
21:55:10 <Rectal> Oh... OH
21:55:25 <Rectal> I just realised, the reason why it didn't make sense is becuase I was't reading the previous part on the other page
21:55:28 <Rectal> My bad
21:55:38 <kmc> it's possible that Eq is involved in this case, but it has nothing to do with the general problem you've posed
21:55:46 <Rectal> Rectal took stupid pills today, or didn't take his non-stupid pills
21:55:48 <kmc> :) 's cool
21:55:49 <Rectal> Sorry
21:55:59 <kmc> if you'd still like help you can put the code snippits on hpaste.org
21:57:06 <Rectal> Yes, I would like that
21:57:21 <Rectal> i dunno if I should make study food (nachos) or keep studying
21:57:47 <Rectal> I just hope my Tutors aren't on here secretly taunting me for going through the exams the day before it is due
21:58:18 <blackh> Rectal: I hope your tutors told you that Haskell kicks butt.
21:59:45 <kmc> don't learn Haskell, it will ruin your ability to enjoy a typical programming job
21:59:59 <kmc> ehehe
22:01:26 <Rectal> well, one of them loves it.
22:01:46 <Rectal> I think it is okay, but I don't think I will use it again
22:01:58 <jarick> kmc: Yes, I am swapping between haskell and avr-asm and C and pic-asm
22:02:07 <jarick> It's quite unpleasant.
22:03:04 <ddarius> jarick: You could be swapping between COBOL, C, and Java.
22:03:37 <kmc> i quite like embedded systems programming in asm and C
22:03:42 <blackh> Rectal: The reasons why Haskell is great aren't immediately obvious.  Purity is a really big thing.
22:03:43 <kmc> that's what those languages are good for
22:03:48 <ddarius> kmc: I like assembly.
22:04:09 <jarick> ddarius: I did do C# and FORTRAN the other time. 
22:04:10 <kmc> C is bad when someone wants you to write a f%&$^king web browser or an IRC client
22:04:21 <Rectal> What would you use to make it?
22:04:26 <Rectal> java?
22:04:27 <ddarius> jarick: C# >> Java (sigh)
22:04:28 <kmc> any safe language
22:04:29 <blackh> ddarius: Assembly doesn't come *close* to how brilliant Haskell is!
22:04:42 <Rectal> Does Haskell have a skynet function?
22:04:43 <jarick> ddarius: Have you met pic-asm then?
22:04:52 <sshc> Haskell is very brilliant!
22:05:17 <kmc> there is an enormous difference between memory-safe languages and the rest
22:05:27 <ddarius> jarick: I've probably seen some, but I haven't done too much microcontroller programming.  My EE stuff has mostly stayed discrete.  I don't want a hobby other than programming to just be programming again.
22:05:34 <sshc> How do I convert an Integral to a Fractional type, 
22:05:34 <jarick> ddarius: C# then java? :D
22:05:37 <sshc> and visa versa?
22:05:38 <blackh> Rectal: We don't talk about Haskell's "launch missiles" function.
22:05:40 <kmc> and using memory-unsafe languages to write common applications code is insanely dangerous
22:05:45 <ddarius> jarick: C# is much better than Java.
22:05:53 <kmc> jarick, I think Haskell is actually a practical tool for every day tasks... but also, I think you have to learn so much to get to the point where you will, that few people do
22:06:07 <blackh> sshc: fromIntegral
22:06:41 <jarick> ddarius: WRT pic-asm, the 14-bit word arch is horrible. There's exactly ONE working register. 
22:06:51 <jarick> But I think we've gone horribly offtopic.
22:06:55 <Rectal> First year, first semest course for programming, we started with Haskell. It blew my mind, I was like, why can't I set x = 2, then use that x in another function, where are my beloved loops!
22:07:00 <jarick> Back to fiddling 
22:07:07 <kmc> hehe
22:07:25 <ddarius> jarick: Doesn't sound too much different from the Z80 or 6502.
22:07:55 * kmc programs AVR in C and C++ and quite enjoys it
22:08:05 <blackh> sshc: Oh - vice versa is 'round' or 'floor' or 'ceiling'
22:08:09 <kmc> ...much more than i ever enjoyed programming "real" computers in those languages
22:08:18 <jarick> kmc: You should try the ARM, the cortex M3s are quite nice.
22:08:22 <kmc> yeah
22:08:26 <kmc> i saw there are some really cheap ARMs now
22:08:29 <jarick> Specifically TI's implementation of it.
22:08:38 <jarick> kmc: Also, TI provides free no-questions-asked sampling
22:09:15 <kmc> nice
22:09:18 <tommd> kmc: Isn't there an AVR haskell package somewhere?
22:09:32 <kmc> you can program AVRs using Atom, a cool Haskell EDSL
22:09:44 <kmc> programming AVR in Haskell would be total madness
22:10:11 <tommd> kmc: Yeah, I know that one.  Still haven't gotten around to doing it.
22:10:16 <kmc> how many thunks can you fit in 64 bytes ;)
22:10:19 <BMeph> ddarius: Thanks for the Lawvere paper recommend, I was pleasantly surprised. I actually noticed (what I think are) a typo or two, even. :)
22:10:27 <tommd> Would like to do something moderately large like make PTP in Atom for AVR.
22:10:33 <kmc> PTP?
22:10:34 <jarick> kmc: You could swap.
22:10:55 <tommd> kmc: PTP = Picture Transfer Protocol (think digital camera)
22:10:59 <kmc> ah
22:11:01 <kmc> over USB?
22:11:04 <tommd> yes
22:11:09 <kmc> that's a cool idea
22:11:13 <kmc> the V-USB stack for AVR is pretty impressive
22:11:17 <tommd> So you'd need USB gadget side code.
22:11:28 <tommd> kmc: Can atom hook up with that easily?
22:11:28 <jarick> There exist external largish spi SRAM
22:11:43 <kmc> tommd, no idea.  but it basically just generates C
22:11:45 <kmc> so probably
22:11:49 <tommd> I'd like cheap SPI Flash more.
22:11:56 <BMeph> kmc: Madness? THIS! IS! HASKELLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL!!! 8D
22:12:14 <jarick> tommd: It's called an SD card. 
22:12:30 <kmc> yup
22:12:33 <jarick> I'm in Asia, those come REALLY cheap here.
22:12:34 <sshc> kmc: How much would one need to learn to "get to the point where" Haskell would be a practical tool for everyday use?
22:12:43 <kmc> sshc, I don't know how to quantify
22:13:11 <Mathnerd314> are there any good alternatives to IORef? (i.e., not in the IO monad)
22:13:14 <sshc> Can you try your best to elaborate?
22:13:16 <kmc> Mathnerd314, STRef
22:13:30 <kmc> well, do you feel like you could use Haskell as a practical tool for everyday use today?
22:13:33 <Rectal> I have a function called iFunction :: Eq [a] => [a] -> a, I need it to somewhere in it check for equality, but I am not good with algebraic datatypes,
22:13:47 <kmc> very odd to have an Eq [a] constraint
22:13:53 <kmc> much more common to have Eq a, and get Eq [a] for free
22:13:53 <ezyang> Rectal: You probably want Eq a, not Eq [a] 
22:13:54 <Rectal> I couldn't because I am terrible, and Haskell can't make me Lunch
22:14:27 <Rectal> riiighhhttt, I uh, my bad
22:14:33 <Rectal> I see what I did there
22:15:11 <kmc> sshc, i guess what i'm saying is that when I first learned Haskell, I would use it for big fancy languages projects (interpreters, compilers, debuggers) and it worked out well, but I'd still write more mundane everyday "scripting"-type stuff in another language
22:15:24 <kmc> and only recently am I beginning to do that stuff in Haskell with the same or better level of productivity
22:15:29 <kmc> (4 years after starting to learn)
22:15:42 <kmc> i'm not sure that i *couldn't* have before
22:15:51 <kmc> it just didn't seem like a reasonable thing to do
22:16:10 <kmc> it also helps that i spend far too much time here and reading Haskell blogs and papers etc. so it's all fresh in my mind
22:16:35 <kmc> i spent about a year coding mostly in Python and rarely thinking about Haskell
22:16:40 <kmc> and it took some time to get back to speed after that
22:16:45 <kmc> a lot of things had changed
22:16:49 <kmc> e.g. Applicative becoming popular
22:16:53 <Rectal> YAR HAR! I solved in, and also wish I was a pirate!
22:17:00 <kmc> e.g. good parallelism and concurrency support in GHC
22:17:17 <kmc> that last one is a really big point in favor of Haskell for small tasks, btw
22:17:27 <kmc> cause it's not a big laborious production to define a thread and fork it off
22:17:58 <kmc> you can prototype with threads rather than it being like version 3 of some big iterative design process
22:18:39 <Rectal> I use Python for small tasks, once
22:44:44 <Pseudonym> Google didn't turn up anything useful for "Google WebApp Project Validator" in the first wouple of pages, if that's what you meant.
22:44:56 <Pseudonym> s/wouple/couple/
22:46:25 <solrize> python's threading is easy to use
22:46:38 <solrize> though it uses OS threads which are high overhead
22:47:35 <Pseudonym> Define "high overhead".
22:48:14 <solrize> they are created with a system call, switching between them is expensive, etc. compared with ghc threads
22:48:18 <Pseudonym> Depends on the OS.  QNX threads are quite low-overhead.  I've been told it's also true on Symbian, though I've never written that myself./
22:48:31 <solrize> could be
22:48:50 <Pseudonym> Linux threads are unnecessarily heavyweight, because it makes a whole process for each thread.
22:49:07 <solrize> shrug
22:49:15 <solrize> anyways haskell and erlang have very lightweight threads
22:49:23 <Pseudonym> Yeah, that's true.
22:49:29 <Hunner> Is qnx still used much?
22:49:35 <Pseudonym> Yup.
22:49:38 <solrize> some embedded thingies use it
22:49:45 <solrize> canon digicams used it but switched recently
22:49:58 <solrize> i've been looking at lua a little bit
22:50:08 <Pseudonym> Vending machines, barcode scanners, remote sensors, robots...
22:50:09 <solrize> it's cute, much lighter weight than python
22:51:14 <kmc> if by "python's threading" you mean the implementation in CPython
22:51:23 <kmc> then it is useless for actual parallelism
22:51:37 <kmc> fine for concurrent semantics, easy way to write blocking I/O, that sort of thing
22:51:44 <kmc> but you won't actually use multiple cores
22:51:53 <kmc> in fact code tends to get slower as you have more cores
22:52:05 <solrize> yeah, but cpython is so slow to begin with that if you're thinking about multiple cores you're using the wrong implementation even without that issue :)
22:52:13 <kmc> which implementation would you recommend?
22:52:31 * kmc has high hopes for berp
22:52:41 <solrize> python?  i guess pypy isn't usable yet
22:52:47 <solrize> i dunno what berp is
22:53:01 <Pseudonym> GHC and Erlang have different requirements than Python, incidentally.
22:53:10 <solrize> python is a scripting language, that's kind of overextended for complicated or high performance applications
22:53:11 <Pseudonym> In Erlang, you can migrate threads across CPUs.
22:53:15 <kmc> eh
22:53:17 <solrize> except special things like numpy
22:53:21 <kmc> i think "scripting language" is a worse than useless term
22:53:30 <kmc> there's no reason Python couldn't be suitable for those things
22:53:40 <kmc> JavaScript and Lua are similar, highly dynamic, functional, object-oriented languages
22:53:44 <kmc> with very fast implementations
22:54:31 <solrize> js is similar to lisp
22:54:38 <kmc> yup
22:54:51 <solrize> python is a bunch of nested dictionaries and it's hard to get around that
22:54:52 <Pseudonym> In the sense that most things are similar to Lisp. :-)
22:55:04 <kmc> maybe it's my own bias in seeing most dynamically typed languages as similar
22:55:16 <kmc> but isn't js also substantially nested dictionaries
22:55:37 <solrize> hmm perhaps so
22:55:43 <Pseudonym> The reason for JS's existence is to manipulate object structures such as DOM.
22:55:55 <solrize> pypy should speed up python a lot
22:55:57 <Pseudonym> So that's what it "really" does.
22:56:36 <solrize> for large scale programming i think type systems are important
22:56:46 <kmc> tracing JIT should have no problem seeing through dictionaries in the common (unchanging) case
22:56:50 <kmc> it works for JS and Lua
22:56:55 <kmc> agreed solrize
22:58:00 <solrize> python statica analysis generally can't tell if some other function has monkey-punched your code, i don't know if js and lua are like that
22:58:00 <djahandarie> I don't think JS is that similar to Lisp
22:58:28 <kmc> yeah, you're not going to get great compiled code from js or lua or python by a purely static analysis
22:58:35 <kmc> i wonder if berp has any way around this, incidentally
22:58:41 <Pseudonym> djahandarie: It's similar in the sense that it forces you to represent all your data the JS way.
22:59:09 * edwardk gives up on the mpfr bug, and waits to see if he can get an answer from the author.
22:59:23 <kmc> but anyway, that's the point of JIT.  using runtime information to make the common case fast, while leaving the uncommon stuff alone
22:59:41 <solrize> ic, can that work reliably for python?  detect runtime punching?
22:59:52 <kmc> yeah
22:59:54 <mauke> punching?
22:59:55 <kmc> why not?
22:59:56 <edwardk> i think it has to do with an internal change in mpn_get_str which may now allocate temporary memory that ghc somehow stomps
23:00:03 <solrize> i guess psyco does something like it, but doesn't get that big a speedup
23:00:06 <djahandarie> Pseudonym, the JS way?
23:00:09 <kmc> is "monkey-punch" a portmanteau of "monkey-patch" and "donkey-punch"?
23:00:13 <edwardk> mauke: monkey patching is sometimes called duck punching
23:00:26 <mauke> why?
23:00:40 <edwardk> mauke: its a play on duck typing... if you have a duck and it doesn't quack the way you like punch it until it does
23:00:44 <kmc> hehe
23:01:03 <adu> what?
23:01:26 <kmc> i think Lua and JS are equally susceptible to this problem
23:01:40 <kmc> Lua is definitely based on this "everything is a dictionary" idea
23:01:47 <kmc> perhaps more so than python
23:01:54 <edwardk> "Well, I was just totally sold by Adam, the idea being that if it walks like a duck and talks like a duck, it‚Äôs a duck, right? So if this duck is not giving you the noise that you want, you‚Äôve got to just punch that duck until it returns what you¬†expect."
23:02:02 <Pseudonym> djahandarie: Arrays, hash tables and basic types.
23:02:06 <solrize> there should be a hackathon sprint for ripping through the python and ruby library manuals and reimplementing all the libraries in haskell
23:02:14 <adu> what is monkey punching?
23:02:23 <kmc> solrize, okay, let's start with itertools and functools ;)
23:02:42 <solrize> adu, monkey punching means stuff like replacing methods on existing classes from someplace else in the program
23:02:44 <edwardk> adu: in languages that permit runtime modification of the dictionaries of prototypes that make up their classes it is sneaking in and mutating those dictionaries to do extra or different stuff
23:03:02 <edwardk> adu: er dictionaries or prototypes
23:03:03 <danharaj> sounds like taking a shit on semantics
23:03:18 <kmc> or even modifing the fields in a single instance
23:03:29 <edwardk> danharaj: the kind of people who monkey patch don't care much about words like "semantics" ;)
23:03:33 <kmc> sort of
23:03:39 <edwardk> kmc: true
23:03:39 <djahandarie> Pseudonym, linked lists are much more central to Lisp & friends than arrays are...
23:03:44 <kmc> it still preserves the semantics of the language of course
23:03:53 <kmc> but any guarantees in the contract of the class might be gone
23:04:03 <solrize> i like hedgehog lisp, wihch tends to use tuples and avl-trees instead of linked lists
23:04:05 <Pseudonym> djahandarie: Once again, though, Lisp forces you into its way of representing data.
23:04:14 <danharaj> I don't see how you can guarantee *anything* in Python.
23:04:48 <kmc> cool solrize
23:05:07 <Pseudonym> You can guarantee that your code will break next version.
23:05:08 <solrize> do you know about it?  http://hedgehog.oliotalo.fi/
23:05:13 <Pseudonym> That's a pretty strong guarantee.
23:05:30 <solrize> it's a tiny interpreter for embedded apps... never really caught on, and lua sort of occupied the space it aimed at
23:05:40 <djahandarie> Pseudonym, I don't understand how "Arrays" is something that strongly relates Lisp and JS
23:05:43 <earthy> ghe. yeah.
23:05:51 <djahandarie> Pseudonym, any more than any other programming language in existance
23:05:53 <solrize> but it's (mostly) functional, using avl trees as persistent data structures, like data.map
23:05:55 <earthy> python 1.5.2 /= python 1.5.2
23:06:07 <Pseudonym> djahandarie: The thing is, Lisp and JS have limited abstractions for representing data.
23:06:10 <adu> Pseudonym: djahandarie: I think you're both right, I actually have a page about data representation in both: http://drosera.co.cc/drospecs/drosera_dson.html
23:06:20 <earthy> (and I've got bitten by the differences between python 1.5.2 and python 1.5.2
23:06:21 <Pseudonym> BTW, I wasn't the one who claimed that JS was like Lisp.
23:06:23 <earthy> )
23:06:27 <Pseudonym> I was being snarky.
23:06:49 <solrize> i guess lisp is more compilable than js, with traditional methods
23:07:12 <Pseudonym> There's been 40 years of research in how to compile Lisp.
23:07:23 <p_l> solrize: depends what lisp, as well. It's much easier when you know the code won't change at runtime...
23:07:30 <edwardk> js is a lisp, it just has a funny syntax ;)
23:07:48 <kmc> it's easy when the code changes at runtime, as long as you're willing to call the compiler-as-a-library when it does
23:08:00 <solrize> is ML dead?  it seems more usable than haskell in a lot of ways
23:08:06 <solrize> but old
23:08:09 <kmc> which ML?
23:08:11 <kmc> Standard ML?
23:08:13 <kmc> or OCaml?
23:08:34 <solrize> either.  i mean both still have users, but the implementations don't seem going anywhere
23:08:39 <kmc> yeah
23:08:42 <kmc> new code is being written in ML
23:08:55 <danharaj> Isn't OCaml more popular in some countries than Haskell?
23:08:55 <kmc> but i don't see a big push to industrialize them, as with Haskell
23:08:59 <kmc> france ;)
23:09:05 <danharaj> Damn Frenchies
23:09:07 <danharaj> and their wine
23:09:09 <danharaj> and cheese
23:09:11 <danharaj> and philosophy
23:09:14 <kmc> i dunno, they are pretty different
23:09:20 <kmc> the languages i mean
23:09:36 <solrize> ocaml and ml?
23:09:42 <kmc> ml and haskell
23:09:48 <solrize> yes, very different
23:10:13 <adu> doesn't ocaml have both bytestring and bitstring pattern-matching?
23:10:16 <kmc> they are seen as similar only because that region of design space is relatively sparse
23:10:24 <solrize> adu, erlang has that, dunno about ml
23:10:29 <BMeph> I thought it was "Established" that Eich wrote JS as a Scheme, with C syntax?
23:10:51 <kmc> whereas everyone and their dog has introduced a new dynamically typed OO languages
23:11:14 <solrize> scheme would never let 2+"1" = 3
23:11:31 <kmc> no sane language does
23:11:41 <solrize> JS and lua both do :(  not sure about perl
23:11:47 <kmc> implicit conversions are a godawful terrible idea
23:11:58 <edwardk> solrize: yes, but kmc has a sane definition of sane ;)
23:12:00 <solrize> python does a lot also, though not that one
23:12:04 <mauke> Ok, modules loaded: Main.
23:12:04 <mauke> *> 2+"1"
23:12:05 <mauke> "3"
23:12:14 <adu> kmc: yes, but conversions are nice when they're not automatic
23:12:16 <edwardk> mauke: hahaha
23:12:19 <kmc> nice Num String instance ;)
23:13:21 <edwardk> instance IsString Int where fromString = read
23:13:24 <solrize> haskell is a moving target and it seems to stay difficult.  getting past each conceptual hurdle opens up new ones
23:13:57 <edwardk> solrize: this is a good thing. you're done learning when you're dead ;)
23:14:07 <mauke> *> 2 + "hello"
23:14:07 <mauke> "jgnnq"
23:14:16 <danharaj> Haskell changes so quickly because functional programming changes quickly.
23:14:33 <djahandarie> That's a nice instance
23:14:52 <danharaj> New ideas are discovered all the time, and one of the design goals of Haskell was to facilitate exploration and research of new ideas.
23:15:07 <djahandarie> Except the usual crazy type stuff that'll happen because of it making everything a pain
23:15:10 <solrize> danharaj, yeah, i wonder if the industrialization efforts are premature
23:15:14 <kmc> Haskell the standard has not moved much
23:15:18 <adu> I think the hardest part of Haskell is the typeclasses
23:15:20 <kmc> Haskell as she is spoke has chaned a lot
23:15:55 <kmc> i don't think any industrialization is premature; the industrial use of FP is absurdly postmature
23:16:02 <Rectal> 2 + hello? They dropped in on the foot, that hurts like "Hell" they do it below the knee bel "o", twice "too"
23:16:07 <danharaj> solrize: I do not think so, because you can abstain from features that make you dizzy.
23:16:14 <kmc> so yes there will be rough edges, but only the daring early adopters are using it now anyway
23:16:15 <edwardk> solrize: you can do a _lot_ with Haskell 98 or 2010 without moving off into the crazy land of magical type system extensions
23:16:29 <adu> granted there are some obscure data declarations, but so far as I've seen 90% of all language extensions have to do with typeclasses
23:16:39 <aristid> :t fmap chr . (+) `on` ord
23:16:40 <lambdabot> Char -> Char -> Char
23:16:42 <kmc> there are only two extensions past H2010 that i think are really vital to getting work done
23:16:44 <solrize> edwardk, if you do that you're missing out on all the interesting stuff ;)
23:16:48 <aristid> why doesn't this work in my ghci? oO
23:17:01 <danharaj> kmc: Pattern guards, GADTs?
23:17:03 <aristid>     No instance for (Functor ((->) Int))
23:17:03 <aristid>       arising from a use of `fmap' at <interactive>:1:0-7
23:17:03 <aristid>     Possible fix: add an instance declaration for (Functor ((->) Int))
23:17:06 <edwardk> solrize: yeah going back another 10 years further to pick up ML because its stable doesn't sound like a lot of fun to me ;)
23:17:07 <kmc> danharaj, no
23:17:14 <djahandarie> aristid, import Control.Monad.Instances ?
23:17:15 <aristid> i think there IS an instance of Functor (e ->)
23:17:18 <kmc> PatternGuards are in H2010 and are just nice sugar anyway
23:17:27 <danharaj> oh, that's nice.
23:17:31 <aristid> djahandarie: thanks
23:17:37 <kmc> and i don't think GADTs are essential
23:17:37 <edwardk> solrize: especially when the flagships that carry its ideas forward have even crazier ideas than we do ;)
23:17:42 <aristid> djahandarie: i somehow expected Control.Functor to suffice
23:17:43 <kmc> they let you get some additional type safety, yes
23:17:46 <edwardk> kmc: they aren't you can finally tagless them away
23:17:53 <solrize> who's carrying ML's ideas ?
23:17:55 <kmc> yeah
23:18:08 <edwardk> solrize: ocaml and f# each have a fair chunk of it in their blood
23:18:09 <solrize> i think ML's runtime can be a lot smaller
23:18:10 <kmc> the two i think are really essential are Rank2Types and ExistentialQuantification
23:18:18 <aristid> fmap f . g `on` h seems to be a pattern
23:18:22 <edwardk> kmc: well you can model the latter with the former
23:18:28 <edwardk> so just rank2 types
23:18:29 <kmc> hmm true
23:18:32 <kmc> just rank2 types then :)
23:18:40 <danharaj> 'model'
23:18:47 <danharaj> I think sugar is important.
23:18:56 <solrize> is ST possible in haskell 98?
23:18:59 <kmc> no
23:19:01 <kmc> no rank-2 types
23:19:05 <aristid> danharaj: aren't GADTs the sugar?
23:19:05 <djahandarie> danharaj, I'm pretty sure it'd be the same syntax?
23:19:06 <edwardk> danharaj: meh, nothing is wrong with a little contination passing style ;)
23:19:11 <kmc> oh, and if you consider them extensions: FFI, unsafePerformIO, and unsafeCoerce (for libraries, of course)
23:19:25 <kmc> we might be better considering Typeable an extension and hiding unsafeCoerce
23:19:33 <aristid> Rank2Types is totally cool
23:19:47 <solrize> what's a rank 2 type?  surely not ordinary *->* types like List ?
23:19:48 <danharaj> Why aren't Rank2Types Haskel2010 anyway?
23:19:49 <kmc> danharaj, i agree sugar is important, but i was speaking only of which extensions are truly vital
23:19:54 <edwardk> Typeable can be implemented in the language with a suitable straightjacket
23:20:15 <danharaj> Rank2 seems to be a fairly straightforward and well understood extension.
23:20:27 <kmc> solrize, (forall a. x) -> y
23:20:35 <solrize> some of the most recent type-system stuff was added to catch haskell up to c++ in generics capabilities
23:20:42 <solrize> type families were for that
23:20:42 <kmc> if a rank-n type appears with a quantifier on the left side of (->), the overall type is rank-n+1
23:20:46 <edwardk> danharaj: it is, but its also the straw that tips things over into _requiring_ type signatures which means it pushes you into requiring type checking rather than just inference
23:20:49 <solrize> oh ok
23:20:59 <aristid> @remember solrize some of the most recent type-system stuff was added to catch haskell up to c++ in generics capabilities
23:20:59 <lambdabot> It is stored.
23:21:03 <edwardk> danharaj: so support could be a burden for minimalist implementations
23:21:10 <aristid> @quote catch.haskell.up.to.c++
23:21:10 <lambdabot> solrize says: some of the most recent type-system stuff was added to catch haskell up to c++ in generics capabilities
23:21:15 <aristid> *giggle*
23:21:39 <danharaj> edwardk: I suppose. But pragmatically speaking, I think most people would fill in top-level types anyway, and that's where you'll see most of your rank-2 stuff, no?
23:21:47 <kmc> solrize, so with higher-rank types we can use polymorphism not just to express flexibility of a function, but to *require* flexibility from one of its arguments
23:22:04 <kmc> we can make combinators that force their input to ignore certain things
23:22:11 <kmc> that's key to making runST safe
23:22:14 <edwardk> danharaj: yes, but the algorithm can be all inference except when breaking up recursive definitions otherwise, it means you have to let type info flow two ways
23:22:38 <solrize> aristid, "Garcia et al. [15] compare the support for generic programming offered
23:22:38 <solrize> by Haskell, ML, C++, C#, and Java. They give a table of qualitative
23:22:38 <solrize> conclusions, in which Haskell is rated favourably in all respects except
23:22:38 <solrize> associated types. This observation was one of the motivations for the
23:22:38 <solrize> work we describe here.
23:22:39 <solrize> "
23:22:44 <solrize> http://research.microsoft.com/~simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
23:23:01 <solrize> cool, a new version of that paper is up :)
23:23:03 <kmc> i remember a very tricky error when using ($) with higher-rank types
23:23:13 <kmc> basically "f $ x" didn't work and "f x" did
23:23:25 <danharaj> that seems strange?
23:23:33 <edwardk> solrize: i agree. on the other hand, a good chunk of c++ compilers until very recently didn't handle partial template specialization very well, anyways, so they were catching up with a standard that was only implemented properly in a handful of compilers ;)
23:23:36 <aristid> kmc: did f `id` x work?
23:23:40 <kmc> don't know
23:23:45 <kmc> i don't have the example handy
23:23:48 <danharaj> :t $
23:23:49 <lambdabot> parse error on input `$'
23:23:52 <edwardk> kmc: id won't help there
23:23:54 <danharaj> :t ($)
23:23:55 <lambdabot> forall a b. (a -> b) -> a -> b
23:24:07 <kmc> i think basically that (x -> x) won't specialize to (forall a. f a) -> (forall a. f a)
23:24:14 <edwardk> kmc i've had to make a $$ which takes a quantified argument before for some CPS'd bits
23:24:15 <edwardk> yeah
23:24:34 <edwardk> @type runST
23:24:35 <lambdabot> forall a. (forall s. ST s a) -> a
23:24:36 <aristid> edwardk: id didn't work?
23:24:41 <edwardk> you can't runST $ do ...
23:24:48 <kmc> :t runST (return 3)
23:24:50 <lambdabot> forall t. (Num t) => t
23:24:52 <kmc> :t runST (return 'x')
23:24:54 <lambdabot> Char
23:24:55 <kmc> :t runST $ return 'x'
23:24:56 <lambdabot> Char
23:25:00 <edwardk> hrmm
23:25:10 <edwardk> maybe it was a bit uglier than that =)
23:25:15 <kmc> yeah
23:25:18 <kmc> i've only hit it once
23:25:22 <kmc> but it puzzled the hell out of me
23:25:29 <solrize> why use State instead of ST?  
23:25:30 <aristid> solrize: research.microsoft.com doesn't connect
23:25:36 <kmc> solrize, they're totally different
23:25:38 <aristid> solrize: maybe because i use a linux computer? :D
23:25:45 <solrize> works for me
23:25:46 <edwardk> solrize: because StateT exists and STT doesn't? =)
23:25:50 <kmc> in both semantics and typical implementation
23:25:54 <napping> danharaj: actually, rank-2 type inference is decidable, it's just a huge pain
23:26:10 <aristid> solrize: well, it certainly doesn't work for me, so i don't know what's in the paper
23:26:13 <solrize> edwardk, hmm.  why no STT?
23:26:15 <kmc> it's easy to understand the implementation of State, how it performs, etc.
23:26:22 <solrize> aristid, try again, maybe it was momentary
23:26:27 <kmc> solrize, same reason as no IOT.  ST uses real mutable destructive in-place updates of memory
23:26:32 <solrize> http://www.haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns  
23:26:42 <kmc> State is just sugar for a pure functional state-passing style
23:27:00 <edwardk> while rank 2 is decidable, rank 2 with any other extensions blows up pretty fast, and rank 3 and above is not, plus you lose all sorts of 'principal typing' properties when you add rank 2 inference
23:27:49 <aristid> solrize: no, still doesn't work (well, technically the browser hasn't given up yet this time, but it doesn't load at all)
23:27:56 <solrize> the pdf slides look good
23:28:20 <aristid> solrize: ok, now this is crazy
23:28:25 <aristid> i got it to download
23:28:26 <aristid> with wget
23:28:29 <aristid> firefox doesn't work
23:28:30 <solrize> shrug
23:28:57 <aristid> this being on a microsoft.com server, i immediately see conspiracy theories!
23:29:29 <solrize> but, haskell's type system and having to think about it at every level of programming feels like thinking about geometry as encoded in set theory
23:29:37 <solrize> aristid, i'm using ff on linux too
23:29:59 <aristid> solrize: then it's just weird :P
23:30:18 <Mathnerd314> could one implement the ST monad with accessible state? (i.e., no destructive update)
23:30:32 <kmc> yes
23:30:35 <solrize> i wrote a toy edsl yesterday, where each edsl action spewed some code for a simple VM, usually by allocating a register (kept in a state variable).  so it was in WriterT State Register 
23:30:42 <kmc> you can implement ST on top of State, but it won't perform as well
23:31:00 <edwardk> you lose at a minimum a logarithmic term in performance
23:31:07 <solrize> and it took half the afternoon just to figure out how to get the type right
23:31:32 <solrize> but i guess one gets more fluent with that.  it was the first time i'd used a transformer
23:31:44 <kmc> solrize, for technical reasons, or because you weren't sure what you wanted?
23:31:47 <napping> Can you make proper STVars?
23:31:51 <aristid> oh, associated types are very cool
23:32:00 <napping> I think the types are a problem, unless you resort to Dynamic
23:32:03 <coppro> okay, monads are breaking my brain again; I should not try to write a parser with Parsec after a Haskell drought
23:32:16 <aristid> are they functionally equivalent to fundeps?
23:32:18 <solrize> kmc, wasn't sure what i wanted, wasn't sure quite how Writer (Endo String) worked, etc
23:32:38 <aristid> coppro: but monads are easy to understand. they're just an Applicative with bind :)
23:32:41 <kmc> "getting the types right" is often really part of design and specification, not implementation
23:32:46 <aristid> coppro: or join, if you prefer that.
23:32:48 <coppro> aristid: yes, I know
23:32:55 <kmc> indeed you can write many useful parsers using only Applicative
23:32:56 <aristid> coppro: hmm
23:32:58 <kmc> all the context-free ones
23:33:08 <coppro> but what I want to do with Parsec is insert a skip operation into the stream without affecting the result of the monadic computation
23:33:11 <solrize> well in python i'd have just used print statements :)
23:33:12 <coppro> and I'm tired and in a hurry
23:33:25 <aristid> coppro: then do that later
23:33:28 <kmc> solrize, so why not StateT Register IO
23:33:30 <coppro> can't
23:33:55 <coppro> basically, parseThis >>= parseThat needs to be come parseThis >>? spaces >>? parseThat so that the result of spaces is discarded and parseThis is passed to ParseThat
23:34:20 <kmc> :t (<*)
23:34:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
23:34:24 <solrize> well, i wanted the purity
23:34:26 <coppro> yay
23:34:28 <coppro> thanks
23:34:29 <aristid> coppro: parseThis >>= \a -> spaces >> parseThat
23:34:33 <kmc> solrize, but in Python you wouldn't care about the purity?
23:34:40 <solrize> in python i like to use StringIO so the print statements don't actually print
23:34:48 <kmc> ah
23:34:50 <kmc> craziness
23:34:50 <solrize> python is inherently impure
23:35:00 <aristid> @src (<*)
23:35:01 <lambdabot> (<*) = liftA2 const
23:35:11 <solrize> or yield statements
23:35:31 <aristid> kmc: (parseThis <* spaces) >>= parseThat?
23:35:36 <kmc> maybe?
23:35:39 <kmc> is that what you want?
23:35:45 <aristid> i'm not coppro
23:35:51 <kmc> right
23:35:54 <kmc> so what's the question
23:36:00 <aristid> kmc: i'm trying to understand
23:36:04 <coppro> kmc: yes, thanks
23:36:06 <kmc> that'd be equivalent to:  do { x <- parseThis; spaces; parseThat x }
23:36:21 <aristid> which in turn is equivalent to my simple proposal
23:36:21 <kmc> it's really only a little shorter, and harder to read if you don't know the combinators
23:36:27 <coppro> what's the precedence on that?
23:36:28 <aristid> @undo do { x <- parseThis; spaces; parseThat x }
23:36:28 <lambdabot> parseThis >>= \ x -> spaces >> parseThat x
23:36:37 <kmc> yeah
23:36:40 <solrize> wow, bos has a new paper up
23:36:45 <mauke> @pl parseThis >>= \ x -> spaces >> parseThat x
23:36:45 <lambdabot> (spaces >>) . parseThat =<< parseThis
23:36:47 <aristid> lambdabot: your code is exactly the same as mine save for variable names and spacing :)
23:37:04 <aristid> mauke: seems like it doesn't know about (<*)
23:37:49 <mauke> parsec2 isn't an instance of applicative anyway
23:38:19 <solrize> is there a reason haskell doesn't allow punctuation-alphabetic names like agda?  
23:38:30 <solrize> like   .foo.  
23:38:46 <aristid> solrize: modules use dots
23:40:04 <solrize> true
23:41:28 <dons> solrize: it was the style at the time. theorem provers are aimed at embedding other languages, so they have very flexible syntax.
23:41:32 <dons> e.g. twelf, agda.
23:42:20 <solrize> ic.  this occurred to me in messing with haskell edsl's which are fully of .&&.  .+.  and so forth
23:42:52 <solrize> s/fully/full
23:43:15 <solrize> and at a certain point using alphabetic words would be more readable
23:43:38 <aristid> solrize: embedding alphanumerics might make some operators easier to understand, that's true
23:43:42 <cizra> Oh yuck. my gtk2hs hello world is 16 megabytes unstripped and 8.3 megs stripped. Does it link the whole GTK statically?
23:44:20 <solrize> dons you might want to put bos and johan's new paper on reddit?
23:46:03 <jarick> cizra: Does ldd still indicate a link?
23:48:38 <solrize> zomg, there is this horrible hack in python programs of using pipes to communicate between threads in the same process, to get them to unblock on i/o.  and it looks like ghc does that too now except on linux.  (that's an os groan, not a ghc groan)
23:57:55 <kmc> solrize, i think that's an old hack
23:58:02 <kmc> i remember seeing it recommended for C code too
23:58:10 <sinelaw> hey
23:58:28 <kmc> linux eventfd is supposed to supersede i think
