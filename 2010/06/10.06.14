00:01:04 <Jafet> edwardk, ie. reify the calculation tree
00:01:21 <edwardk> Jafet: yeah. i do it now for ad purposes anyways
00:01:27 <Jafet> The C++ bindings to mpz_f do that.
00:01:37 <edwardk> Jafet: neat =)
00:01:55 <Jafet> That way the minimum precision can be tracked automatically through an expression
00:02:04 <edwardk> Jafet: it could yield a pretty fast computation model
00:02:56 <edwardk> i'll start with a pure binding
00:16:29 * hackagebot orc 1.1 - Orchestration-style co-ordination EDSL  http://hackage.haskell.org/package/orc-1.1 (TrevorElliott)
00:16:32 * hackagebot monadIO 0.9.1.0 - Overloading of concurrency variables  http://hackage.haskell.org/package/monadIO-0.9.1.0 (TrevorElliott)
00:16:51 <mjk> ManateeLazyCat:如何解决在程序文件中显示中文，比如直接在putStr里面？
00:17:03 <Axman6> o.O
00:17:39 <Silvah> No doubt.
00:19:17 <Jafet> Might be Mongolian.
00:22:09 <sinelaw> aha
00:22:35 <Silvah> > map chr $ take 40 $ randomRs (0, 255) $ mkStdGen 69
00:22:36 <lambdabot>   "\t\159\193\ETX\US\255z\170\175\204V\164\234(\137I)\149\194\SYN6C\226\DC1U\...
00:22:45 <Silvah> :(
00:24:00 <Silvah> The Show instance for [Char] broke everything :(
00:27:05 <Axman6> > text . map chr . take 40 . randomRs (0, 255) $ mkStdGen 69
00:27:06 <lambdabot>           每z陋炉V陇锚(I)6C芒U楼cD]没霉z垄h
00:27:35 <Silvah> @hoogle text
00:27:36 <lambdabot> Text.Html text :: String -> HtmlAttr
00:27:36 <lambdabot> Text.PrettyPrint.HughesPJ text :: String -> Doc
00:27:36 <lambdabot> Text.XHtml.Transitional text :: String -> HtmlAttr
00:28:29 <Axman6> > text "a\ta\ta"
00:28:30 <lambdabot>   a        a        a
00:28:49 <pastorn> > text "a\t\tack"
00:28:50 <lambdabot>   a                ack
00:29:26 <Axman6> map org "\ACK"
00:29:30 <Axman6> > map org "\ACK"
00:29:31 <lambdabot>   Not in scope: `org'
00:29:36 <Axman6> > map ord "\ACK"
00:29:37 <lambdabot>   [6]
00:29:43 <Axman6> > map ord "\ACK\SYN"
00:29:44 <lambdabot>   [6,22]
00:29:54 <pastorn> nice :)
00:30:12 <Axman6> text "\SYN"
00:30:16 <Axman6> > text "\SYN"
00:30:27 <Axman6> lambdabot!
00:30:37 <pastorn> @botsnack
00:30:37 <lambdabot> :)
00:30:40 <Silvah> > 8
00:30:41 <lambdabot>   8
00:30:42 <Axman6> > text "\SYN\ACK"
00:30:54 <Silvah> lol
00:30:59 <pastorn> > let x = x + 1 in x
00:31:03 <lambdabot>   mueval-core: Time limit exceeded
00:31:03 <Silvah> She does not listen to you.
00:31:11 <Axman6> > text "\SYN \ACK"
00:31:19 <Axman6> how odd
00:31:33 <pastorn> > text "don't listen to Axman6"
00:31:33 <lambdabot>   don't listen to Axman6
00:31:43 <Silvah> lol
00:32:09 <pastorn> @botsnack
00:32:09 <lambdabot> :)
00:33:23 <Silvah> @slap lambdabot
00:33:24 <lambdabot> Come on, let's all slap lambdabot
00:33:49 <Axman6> oh my :o
00:40:32 <Axman6> edwardk: the intervals hackage page links to http://patch-tag.com/r/ekmett/intervals but it doesn't exist
00:51:34 <blueonyx> hi, which is the new locale lib, and why does the new time lib use the old locale lib?
00:52:03 <blueonyx> @hoogle formatTime
00:52:03 <lambdabot> Data.Time.Format formatTime :: FormatTime t => TimeLocale -> String -> t -> String
00:52:04 <lambdabot> Data.Time.Format class FormatTime t
00:52:04 <lambdabot> System.Time formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
00:52:16 <blueonyx> @hoogle TimeLocale
00:52:17 <lambdabot> No results found
01:37:29 <edwardk> erm... patch-tag is hosed
01:37:43 <edwardk> i just reverted many days worth of packages
01:38:07 <edwardk> i have the material i had on there 3-4 weeks ago
01:39:04 <edwardk> Axman6: it existed up until patch-tag ate all my repos this morning
01:39:40 <Blkt> good day everyone
01:40:07 <ivanm> greetings Blkt 
01:40:44 <edwardk> Axman6: i guess it is time to waste my morning learning git and figuring out github
01:40:59 <johnw> edwardk: do you need help with something?
01:41:47 <quicksilver> dolio: I have a holiday soon. Maybe I'll have a chance to compose it.
01:41:50 <edwardk> johnw: patch-tag ate a dozen repos i was collaborating with folks through, so i'm looking to figure out how i can toss code around this morning ;)
01:42:09 <johnw> what is patch-tag?
01:42:24 <edwardk> johnw: patch-tag : darcs :: github : git
01:42:30 <johnw> ahh
01:48:42 <benc__> huh
01:48:59 <benc__> my cabal ? does not exist error from yesterday has changed into
01:49:00 <benc__> $ cabal install
01:49:00 <benc__> cabal: j: does not exist
01:49:20 <ivanm> wtf is "j" and why is it wanting it?
01:49:33 <benc__> no idea
01:49:44 <benc__> yesterday it was giving ? where ? was hex code 0x9a
01:50:03 <benc__> its a known bug apparently but I'm interested to see that its changed to a different character today
01:50:05 <ivanm> benc__: how did you install cabal-install?
01:50:16 <benc__> cabal install cabal  (or something like that)
01:50:17 <ivanm> have you tried wiping your ~/.cabal/config ?
01:50:48 <benc__> nah, I went back to an old version of cabal ;)
01:51:16 <byorgey> edwardk: re: patch-tag, yikes.  
01:52:11 <edwardk> byorgey: it wouldn't be such a kick in the pants except that i'd _just_ gotten into a pretty productive groove and then published it as the url for a dozen projects or so
01:52:26 <byorgey> yeah =(
01:52:39 <edwardk> oh, i just got a working version of MPFR bindings that work using data.reflection to set their rounding mode and precision
01:52:48 <edwardk> i was going to upload it when i noticed that all my repos were gone
01:52:50 <byorgey> edwardk: I hope you didn't actually lose any work?
01:53:31 <edwardk> aside from losing this morning shuffling stuff around so i can load it on my laptop for work? the only thing i may have lost is my last few versions of my sat solver
01:54:14 <byorgey> well, that's good at least.  but yeah, I don't know what's up with patch-tag
01:54:26 <byorgey> it was behaving strangely so I sent an email to the users list yesterday
01:54:41 <byorgey> but my email still hasn't actually appeared on the list, and there hasn't been any traffic snice May 29
01:55:09 <byorgey> and I haven't heard anything one way or another from the maintainers; you'd think they'd be aware of what's going on
01:55:38 <edwardk> byorgey: thomas was on here the other day
01:56:01 <byorgey> oh, was he? ok.  what did he say?
01:56:49 <ivanm> was it something like "what am I doing here?" :p
01:56:54 <ivanm> preflex: seen thomas
01:56:54 <preflex>  thomas was last seen on ##javascript 7 days, 23 hours, 17 minutes and 15 seconds ago, saying: yorick, I see, thanks
01:56:59 <ivanm> >_>
01:57:34 <edwardk> preflex: xseen patch-tag
01:57:34 <preflex>  patch-tag was last seen on freenode/#haskell 1 day, 8 hours, 5 minutes and 16 seconds ago, saying: edwardk, here's the haddock feature req http://patch-tag.com/r/tphyahoo/patchtag-public-bugs/wiki/feature/haddock+generation
01:57:42 <edwardk> we talked about features and a bunch of stuff
01:58:04 <edwardk> ok, the git-hub exodus has begun http://github.com/ekmett/intervals
01:58:18 <byorgey> presumably "eating yr repos" was not one of the features you discussed
01:58:34 <edwardk> byorgey: fraid not. ;) 
01:58:57 <edwardk> byorgey: i wonder if he heard one of my 'i need an excuse to learn git/use github more' comments as a challenge ;)
01:59:51 <edwardk> darcs-to-git seems to be working fine though
02:00:04 <byorgey> mignitude, hehe
02:00:10 <jrockway> dcoutts: i think i successfully "darcs sent" you my stdcall-support-for-c2hs patch
02:00:20 <jrockway> dcolish: the calling convention is now a proper type, instead of a string
02:00:32 <jrockway> and the function that extracts it is now named correctly (like the other functions)
02:02:36 <edwardk> byorgey: the name was stolen from sun's interval library 
02:05:41 <jrockway> dcoutts: actually, the mailing list rejected my patch
02:06:05 <edwardk> byorgey: http://github.com/ekmett/fixed-precision/blob/master/Numeric/Precision/Fixed.hs the mpfr bindings
02:06:20 <byorgey> edwardk: I suppose from a purely etymological point of view it ought to be "mikritude"
02:06:26 <byorgey> but I like mignitude =)
02:06:33 <edwardk> hah
02:07:04 <byorgey> wait, no, I'm getting my classical languages confused
02:07:11 <byorgey> argh
02:08:21 <jrockway> email is such a primitive way to manage patches :(
02:09:40 <sinelaw> yeah
02:09:53 <sinelaw> they should have public branches
02:09:58 <sinelaw> that accept commits
02:10:00 <jrockway> yeah
02:10:06 <sinelaw> from which the managers can then pull if they like
02:10:12 <jrockway> because i have to push this to github so i can get my patch on my work machine
02:10:34 <sinelaw> can't you clone the repo?
02:12:07 <jrockway> $work prohibits connections arbitrarily 
02:12:14 <jrockway> jrock.us is blocked, github.com isn't
02:12:40 <jrockway> they also have super secret rules that let you do something against the rules, and then tell you you're doing it wrong 2 months later
02:12:58 <jrockway> (not that i care.  if i get fired for fixing our software on the weekend, there are a million other places that will hire me :)
02:13:31 <jrockway> interestingly, we have been trying to hire a java/C++ developer for the last few months
02:13:34 <jrockway> haven't found *anyone*
02:13:42 <jrockway> programming is really a "seller's market"
02:14:12 <p_l> jrockway: I doubt it... maybe depends on location
02:14:51 <p_l> (well, it is a seller's market if you can show a paper trail to claim your experience, I guess)
02:15:59 <jrockway> everyone we've interviewed has amazing paper trails
02:16:06 <jrockway> however, they don't have any clue about programming
02:16:29 <jrockway> "what would you choose to learn if we gave you a week to learn anything about programming you wanted to"
02:16:33 <p_l> hah
02:16:36 <jrockway> "uh, i can't even imagine something like that"
02:16:39 <jrockway> wrong answer
02:16:47 <jrockway> "who is your favorite programmer"
02:16:56 <jrockway> one guy told us, "richard stallings from the free software foundation"
02:16:57 <p_l> damn, that's an open ended question... I'd have a troubleanswering because there's too many possible learning options...
02:17:02 <koala_man> "if there was anything remaining that I could learn in a week, I'd have done it over the vacation already"
02:17:10 <jrockway> so you don't even know the name of your favorite programmer?
02:17:13 <jrockway> fail.
02:17:20 <jrockway> the programming questions go similar
02:17:25 <koala_man> that is terrible
02:17:26 <jrockway> "reverse a string in your favorite language"
02:17:32 * earthy doesn't have a really favorite programmer
02:17:38 <earthy> jrockway:  reverse
02:17:43 <earthy> *done*. :)
02:17:44 <jrockway> "implement the Fibonacci sequence recursively"
02:17:57 <koala_man> mine's Fabrice Bellard
02:17:57 <earthy> I don't even know what that means.
02:18:02 <p_l> jrockway: I'd say that I can't point a favourite, but I can tell which ones inspire me. :)
02:18:25 <earthy> 'write a recursive program that will output the fibonacci sequence'? I can do that. :)
02:18:26 <jrockway> we did finally find someone with a good attitude and an ability to program
02:18:30 <jrockway> he came in on the first day, seemed nice
02:18:34 <FauxFaux> jrockway is scaring me.
02:18:40 <jrockway> called in the second day claiming there was a gas leak in his house
02:18:43 <jrockway> never heard from him again
02:18:48 <koala_man> ouch
02:18:48 <earthy> okay, that sucks.
02:18:55 <p_l> jrockway: someone checked if he survived?
02:19:00 <jrockway> yeah, he survived
02:19:12 <jrockway> he told a friend of a friend of someone that works here "he didn't want to travel"
02:19:23 <p_l> heh
02:19:28 <jrockway> he could have just told us that, and someone else would have gone on the one trip that might have been required for this project
02:19:37 <jrockway> some may say, "well clearly, you aren't offering enough money"
02:19:48 <jrockway> but we are an investment bank, and we are willing to pay at the top of the industry
02:19:52 <jrockway> it makes no sense to me at all
02:19:58 <benc__> i guess it means *you* failed the interview ;)
02:20:02 <p_l> I'm kinda in a bind like that as well... dropping out of uni or stopping for a year doesn't look enticing, so finding a good place is hard
02:20:03 <earthy> where are you guys based? :)
02:20:08 <jrockway> chicago
02:20:11 <earthy> ah.
02:20:36 <o-_-o> jrockway, where in chicago ?
02:20:46 <jrockway> downtown
02:20:48 * o-_-o used to live there long long ago
02:20:58 <o-_-o> ah...
02:21:05 * p_l sits in north scotland and obviously is far from applying to banks ;-)
02:21:35 <jrockway> i think my new plan is to do this project myself, and use haskell instead of C++/Java
02:21:49 <jrockway> we can't find C++/Java developers, and we probably can't find Haskell developers... so... might as well use a language i like ;)
02:21:52 <eevar2> they don't have banks in scotland? :p
02:22:05 <o-_-o> all banks don't use haskell
02:22:29 <earthy> jrockway: good idea :)
02:22:35 <p_l> eevar2: no, can't travel too far for too long
02:22:39 <earthy> if you can get it past management
02:22:42 <jrockway> FWIW, we already use haskell
02:22:42 <o-_-o> it would be kind of insane if all banks switched to haskell for everything
02:22:54 <jrockway> and by "we", i mean "me"
02:22:57 * earthy cougys
02:22:59 <earthy> coughs, even
02:23:01 <o-_-o> heh
02:23:02 <jrockway> but hey, the haskell project was a great success
02:23:08 <Ytinasni> o-_-o: i think the word you're looking for is "sane"
02:23:09 <sinelaw> what was it
02:23:16 <earthy> o-_-o: never gonna happen... the cobol is too entrenched
02:23:19 <eevar2> jrockway: sole developer at that place?
02:23:27 <sinelaw> jrockway, what is the project
02:23:28 <o-_-o> earthy: haskell the new cobol
02:23:30 <o-_-o> why not
02:23:32 <earthy> (have you ever *seen* the interchange formats banks use?)
02:23:33 <eevar2> cause i could see that scaring people away
02:23:42 <jrockway> the project was transforming some databases we bought into a usable format
02:23:47 <eevar2> even if the work/pay was great
02:23:49 <o-_-o> we will have the y10k problem and they will be looking for haskell programmers
02:23:51 <earthy> o-_-o: because what is not cobol and mission critical is java
02:23:57 <jrockway> i've seen FIX
02:23:58 <o-_-o> earthy, heh
02:24:01 <jrockway> it's not that bad
02:24:07 <FauxFaux> Eugh, FIX.
02:24:11 <earthy> due to the fact that java is *highly* amenable to maintenance by average programmers.
02:24:12 <o-_-o> Ytinasni, truer words were never spoken
02:24:15 <Ytinasni> :D
02:24:33 <o-_-o> earthy, I am just kidding
02:24:47 <jrockway> java just makes a mess that takes a lot of people to clean up
02:24:51 <jrockway> i've never seen a simple java program
02:24:53 <earthy> about programming language usage I do not kid
02:25:19 <earthy> jrockway: I've never seen a truly obfuscated java program either
02:25:35 <jrockway> that's really a function of you
02:25:40 <jrockway> i can usually navigate through pretty much anything
02:25:43 <jrockway> but i dont' necessarily enjoy it
02:25:50 <jrockway> i can't think of any time i've ever enjoyed reading a java program
02:26:03 <jrockway> (except the libraries, and only because they are so hilariously convoluted)
02:26:09 <earthy> :)
02:26:21 <earthy> it's not the language. it's the infrastructure around it
02:26:27 <earthy> (loads of libs, loads of IDE support)
02:26:52 <earthy> I don't think there's really any other platform as rich, save .NET
02:26:59 <earthy> and even then.
02:27:23 <jrockway> i find CPAN much nicer than anything Sun or Microsoft has come up with
02:27:31 <p_l> earthy: Java is usually obfuscated at bytecode level... though it's pretty unreadable, IMHO
02:27:40 <jrockway> tests are actually easy to write in perl, so people do it
02:27:49 <jrockway> in java, you have to rewrite all your code and create a class for each test
02:27:54 * earthy nods
02:27:56 <jrockway> so people test one thing, and the rest they manually check
02:28:11 <jrockway> (a coworker was recently using an open-source java FIX parser.  totally broken.)
02:28:17 <jrockway> because there was only one test
02:28:22 <jrockway> and you need more than one test to test a FIX parser ;)
02:28:31 <earthy> :)
02:29:03 <earthy> however, perl is trivial to obfuscate at source code lvel
02:29:20 <p_l> when I want flexibility, I usually go for CL... (not enough Haskell knowledge/experience) xD
02:29:34 <edwardk> i will say one thing, holy hell is git fast
02:29:39 <jrockway> it's pretty easy to write clean perl, too ;)
02:29:42 <p_l> and yes, Perl is Write-Once way too often (not to say that you can't make it readable)
02:30:07 <jrockway> our department is half good programmers and half 9-5 coders, and we've managed to teach everyone to write reasonably decent perl
02:30:11 <jrockway> you have to want to do it
02:30:15 <jrockway> but once you want to do it, it's easy
02:30:20 * earthy nods
02:30:24 <jrockway> the tools that make it easy to write horrible code make it easy to write good code, too
02:30:35 <earthy> I don't disagree
02:31:17 <earthy> I'm just saying that java is enough of a straitjacket that even if you don't really want to write good code, it's hard to write truly horrible code
02:31:36 <jrockway> what about factory factory factory factory factories?
02:31:42 <earthy> in the 'throw loads of people at the problem' school of programming that is a good thing
02:31:44 <jrockway> you may understand what operations the code performs
02:31:49 <jrockway> but you will never understand what it does
02:32:09 <earthy> factory factory factory factories are hard to write. :)
02:33:03 <jrockway> http://www.google.com/codesearch?hl=en&lr=&q=lang%3Ajava+factoryfactory&sbtn=Search
02:33:09 <jrockway> sadly, i don't think that most of those are jokes :)
02:33:14 <jrockway> no FactoryFactoryFactory though
02:33:28 <jrockway> but a factoryfactoryfactory is just a special type of factoryfactory, so ... :)
02:34:01 * earthy laughs
02:34:23 * earthy knows http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
02:34:33 <sinelaw> i wish i had a job with haskell
02:34:39 <earthy> I do. :P
02:34:44 <sinelaw> :_(
02:34:49 <sinelaw> instead i'm doing web crap
02:34:52 <earthy> (I wish I could *keep* a job with haskell...)
02:34:53 <sinelaw> and .net hell
02:35:17 <earthy> (the writing's on the wall for this project
02:35:17 <earthy> )
02:35:44 <sinelaw> hey yitz 
02:35:59 <yitz> hi sinelaw. wassup?
02:36:10 <jrockway> maybe i will convince the powers that be that i need to hire a bunch of haskell developers
02:36:13 <jrockway> that would be excellent
02:36:14 <sinelaw> yitz, doing some statistical signal processing :) :(
02:36:19 <jrockway> i would give it a 1% chance though
02:36:38 <yitz> ooo. sounds intense.
02:37:08 <eevar2> jrockway: probably easier to find decent haskell programmers than c++/java coders, tho?
02:37:15 <HugoDaniel> hi
02:37:55 <sinelaw> yitz, yeah. thanks for the comment on the blog btw, i need more ways to justify using measurable domains. the idea needs more exploration
02:38:10 <theorbtwo> eevar2: Hard to sell businesspeople on that.
02:38:13 <eevar2> even if the language is uncommon, only those with some interest/dedication do pick it up
02:38:26 <yitz> sinelaw: yeah, it's a cool idea
02:38:30 <jrockway> dunno
02:38:34 <jrockway> probably hard too
02:38:50 <theorbtwo> That is, businesspeople tend to want quantity and price, not quality, especially if quality is difficult to determine.
02:38:51 <jrockway> you are going to get all the reddit people that "like" haskell, but couldn't actually write a line of it
02:38:54 <sinelaw> problem is i'm not really a mathematician
02:39:09 <yitz> sinelaw: the main issue is not that tho. the main issue is formalizing time sequencing.
02:39:12 <HugoDaniel> sinelaw: im doing webcrap also
02:39:16 <HugoDaniel> in haskell
02:39:17 <HugoDaniel> :P
02:39:21 <sinelaw> HugoDaniel, good for you.
02:39:23 <theorbtwo> You can buy four java programmers cheaper then four haskell programers, so java is the obvious choice.
02:39:28 <sinelaw> HugoDaniel, the crap is on the client side though
02:39:31 <jrockway> not in finance
02:39:32 <HugoDaniel> ah
02:39:34 <sinelaw> HugoDaniel, i wish there was haskell -> javascript
02:39:37 <jrockway> the java programmers want a lot of money too
02:39:39 <HugoDaniel> yeh :( i struggle with JS too
02:39:41 <jrockway> because "it's finance"
02:39:43 <HugoDaniel> it has some nice features though
02:39:47 <sinelaw> Handheldo, i'm using GWT now
02:39:51 <eevar2> i guess. i certainly wouldn't mind getting paid for learning haskell :p
02:40:00 <SubStack> jrockway: could just troll github for people who've actually built stuff in it
02:40:07 <sinelaw> after failing with JS too many times (and you only find out at runtime and only on certain browsers - yikes
02:40:07 <jrockway> good idea
02:40:22 <jrockway> we have a problem in that we love recruiters
02:40:23 <sinelaw> HugoDaniel, that is
02:40:37 <jrockway> for example, the company that "recurited me" gets half my salary
02:40:39 <yitz> theorbtwo: haskell programmers can't be bought, only hired. as opposed to java programmers. so it all depends on your business model.
02:40:46 <SubStack> jrockway: !!
02:40:48 <sinelaw> yitz, why is that an issue? i mean is there a specific problem you see?
02:41:05 <jrockway> (not bad for me, i asked for what i wanted and that's what i see... but it's a waste of money IMHO)
02:41:21 <theorbtwo> yitz: My point is that businesspeople want to buy programmers like they'd buy nails.
02:41:27 <yitz> sinelaw: i mean how you define the types in a way that a calculation can't depend on the future. i forget what you called it.
02:41:55 <sinelaw> causality
02:42:00 <yitz> theorbtwo: then that's what they'll get. nails.
02:42:11 <sinelaw> yitz, haskell's type system is not powerful enough to express most of what we do anyway
02:42:13 <yitz> right causality
02:42:19 <sinelaw> i'm not trying to express that in haskell types
02:42:40 <yitz> sinelaw: i think we can do at least something
02:42:48 <sinelaw> that's a separate problem, which btw i see as solvable through exposing only causal building blocks / interfaces
02:43:19 <HugoDaniel> sinelaw: i use yui 3
02:43:28 <sinelaw> HugoDaniel, that's still javscript though
02:43:32 <HugoDaniel> yes
02:43:34 <sinelaw> although i'm sure it's nice
02:43:46 <sinelaw> problem with GWT is that it's java-based
02:43:51 <sinelaw> which is almost as bad as javascript
02:43:57 <HugoDaniel> but it puts a nice abstraction that works out browser glitches... most of the time
02:44:01 <sinelaw> even worse sometimes
02:44:12 <sinelaw> but on the average it's much better
02:44:24 <sinelaw> much = 0.6
02:44:38 <HugoDaniel> :D
02:44:46 <yitz> sinelaw: that's asking for trouble - IO wanted to do it that way, too. except sometimes it was just *so* convenient to expose just one *little* building block that violates the rules - just be careful how you use it. and then on down the slippery slope.
02:45:06 <HugoDaniel> from what i've heard, there is a shortage on good JS coders
02:45:11 <sinelaw> yitz, nah, i don't intend exposing anything that can let you violate the laws
02:45:23 <yitz> sinelaw: then someone else will.
02:45:25 <illissius-> ((almost as bad)*x + (even worse)*y)/(x+y) = much better?
02:45:36 <jrockway> javascript has a lot of fanbois
02:45:44 <quicksilver> HugoDaniel: there is a prevalence of bad JS coders.
02:45:47 <sinelaw> yitz, too bad for them. they might as well use IO with unsafeperform
02:45:50 <quicksilver> HugoDaniel: not quite the same as a shortage of good ones
02:45:58 <quicksilver> HugoDaniel: it just makes the good ones hard to find in the dross.
02:46:01 <SubStack> node.js is actually quite excellent
02:46:08 <sinelaw> every silly ass can start writing JS in no time
02:46:11 <HugoDaniel> quicksilver: thats me there.... a bad * coder... :/
02:46:38 <HugoDaniel> my specially is quick and dirty hacks :(
02:46:45 <SubStack> makes me want to write an asynchronous event machine monad
02:46:46 <HugoDaniel> it is actually a lifestyle...
02:46:56 <HugoDaniel> even my relationships are quick and dirty
02:47:01 <yitz> is someone who writes js using the yhc backend a bad coder?
02:47:10 <sinelaw> u meen quik & drty
02:47:16 <HugoDaniel> :)
02:47:49 <sinelaw> yitz, does that really work?
02:47:51 <sinelaw> if it does maybe i'll use it
02:48:01 <sinelaw> though it doesn't seemed to be maintained
02:48:23 <yitz> sinelaw: i admit i have not tried to do real work with it.
02:48:45 <yitz> sinelaw: ndm just released a new version of supero, so yhc in general is still very alive.
02:49:29 <HugoDaniel> right now im working on a html form generator
02:49:32 <HugoDaniel> im haskell + js
02:49:59 <HugoDaniel> ...nothing fancy, just because people keep asking me to do huge forms :/
02:50:16 <sinelaw> what's supero
02:50:48 <gio123> \join english
02:51:05 <HugoDaniel> i have done 2 half baked projects in haskell, this is my third
02:51:15 <HugoDaniel> i must start thinking about uploading them to hackage
02:52:06 <sinelaw> we need an llvm backend to js
02:52:10 <sinelaw> that would be cool
02:52:21 <HugoDaniel> yes!
02:52:47 <HugoDaniel> browsers should ditch JS and guarantee to interpret only the llvm isa
02:53:00 <HugoDaniel> i dream about that day
02:53:17 <blackdog> how would you do sandboxing etc?
02:53:32 <quicksilver> same way as you already do it
02:53:33 <earthy> blackdog: not provide a system call interface.
02:53:39 <quicksilver> run in a VM and limit access to a fixed api
02:53:43 <HugoDaniel> well, ok, part of the llvm isa
02:53:44 <HugoDaniel> :P
02:53:45 <earthy> (or, alternatively, a restricted one)
02:53:46 <quicksilver> but honestly I don't see the advantage
02:53:51 <earthy> me neither
02:54:02 <quicksilver> when it comes down it to, JS is a weird choice, but it works fine
02:54:10 <quicksilver> and there is a lot of investment in good JS JIT and VMs
02:54:15 <earthy> javascript is Good Enough (which obviously is the largest enemy of Good)
02:54:36 <quicksilver> JS is perfectly flexible enough to be a compilation target.
02:54:46 <quicksilver> much better compilation target than C, for example.
02:54:51 <HugoDaniel> really ?
02:54:54 <quicksilver> sure
02:54:56 <blackdog> quicksilver: in terms of ease, sure
02:55:02 <quicksilver> C is full of stupid edge cases
02:55:03 <blackdog> performance is surely harder
02:55:13 <quicksilver> blackdog: intuitively, I guess so.
02:55:19 <quicksilver> but actually writing a performant C compiler is very very hard.
02:55:26 <quicksilver> (although, obviously, people have done it)
02:55:27 <blackdog> or at least, you have to rely on the performance of the underlying javascript engine, i suppose
02:55:38 * earthy nods
02:55:49 <blackdog> quicksilver: is it hard to write a performant c compiler for generated c, though?
02:55:51 <earthy> the javascript engines these days are quite good.
02:55:58 <quicksilver> the man years gone into good C compilers must be an order of magnitude more than into javascript engines
02:56:03 <earthy> blackdog: that's why we have LLVM
02:56:17 <quicksilver> and, yet, the javascript engines are much less than an order of magnitude behind
02:56:27 <HugoDaniel> there are huge amounts of money wasted on JS JIT's
02:56:29 <quicksilver> except for some specific cases.
02:56:42 <Lajla> Can any confirm that V8 has TCO?
02:56:47 <blackdog> sure, but there's a difference between the sort of C people write in the real world, and the sort of C you can generate - if you can assume a restricted C (like what you might be able to do if it's generated), surely some stuff is easier
02:56:52 <Lajla> All the statements about it are quite cryptic.
02:57:09 <blackdog> Lajla: see if you can blow the stack with a tail-calling function:)
02:57:40 <Lajla> Infinite factorial here I come.
02:57:47 <theorbtwo> blackdog: There's a language called cminusminus that is designed to be a c-like language to use as a backend for implementing other languages.
02:57:47 <HugoDaniel> :)
02:58:39 <HugoDaniel> the stack machine approach should be ditched
02:58:44 <blackdog> theorbtwo: llvm does seem to be the new hotness, though
02:58:47 <quicksilver> blackdog: well there are a set of specific reasons why C is bad; at the low level it's very inexpressive.
02:58:55 <HugoDaniel> why is everything stack based ? it just doesn't make sense these days...
02:58:58 <theorbtwo> Indeed it does.
02:59:00 <quicksilver> blackdog: I'm not the man to list them for you though.
02:59:28 <fasta> All these languages are in the end pretty tied to some specific hardware model, though. I don't know of a language which basically assumes you have a 3d chip, which takes into accounts the distance to values, etc. 
03:00:00 <blackdog> quicksilver: yeah, i wouldn't argue with that. but js is such a dynamic language, it seems intuitively plausible that it'd be hard to prove the sort of properties you'd like to rely on for drastic transformations
03:00:13 <fasta> It is my understanding that all the old compilers can basically be thrown away when a change like that happens. 
03:00:38 <quicksilver> blackdog: take a look at how the JIT stuff works.
03:00:48 <quicksilver> blackdog: it basically does just-in-time type inference
03:00:58 <quicksilver> blackdog: and restores a static skeleton to your dynamic language.
03:01:13 <fasta> Everyone is programming and optimizing for something which is essentially something that will probably not exist anymore in 20 years. 
03:01:15 <blackdog> quicksilver: sure. means you have to rely on the runtime engine a lot more, though.
03:01:26 <quicksilver> blackdog: so, for example, it notices that in "function(x) { return (x+1); }" x is only ever used a number, and so it generates arithmetic code.
03:01:35 <quicksilver> blackdog: sure. But we already have the runtime engines in the browsers.
03:01:39 <fasta> (assuming the hardware people do what they are supposed to)
03:01:41 <quicksilver> the runtime harness is already there.
03:01:57 <edwardk> byorgey: have most of my stuff moved over finally http://github.com/ekmett
03:02:04 <quicksilver> blackdog: this conversation was about whether browsers should switch to providing llvm interpreters instead of JS ones ;)
03:02:07 <byorgey> edwardk: nice
03:02:40 <Lajla> blackdog, is 1500 a reasonable size for a call stack?
03:02:47 <byorgey> sigh, I hate proving substitution lemmas
03:02:51 <Lajla> It returns infinity on 1500 in a second.
03:03:01 <Lajla> C-- is awesome
03:10:25 <blackdog> damn. i'd assumed you can repeatedly call uncurry on something, and it'd be guaranteed to hit a type error eventually
03:11:51 <blackdog> but you can whack "uncurry $" repeatedly on the front of foldl forever, and you'll keep getting valid types
03:12:03 <blackdog> how else would you find the arity of something?
03:14:59 <edwardk> blackdog: oleg has some dark magic for an "IsFunction" class
03:15:34 <edwardk> blackdog: but you can have functions with effectively infinite arity
03:15:39 <quicksilver> blackdog: you can't find the arity of something without breaking polymorphism.
03:15:50 <quicksilver> or breaking naturality (which is probably what I meant)
03:16:02 <quicksilver> in *general* that is.
03:16:17 <quicksilver> in the specific case that you know the type eventually terminates at one of a fixed set of ground types, you can.
03:16:41 <blackdog> maybe i'm going about this the wrong way
03:17:39 <blackdog> basically, i'm given a haskell function. i need to know how many parameters it'll accept so that i can throw an error in rubyland if it doesn't make sense.
03:18:04 <blackdog> if there's some approximation i can make so that i occasionally reject functions that might work, that's ok.
03:18:25 <blackdog> i suppose i could just limit the depth and assume that if 20 uncurries don't do it, we're never going to make it wokr...
03:18:56 <blackdog> is there a cleaner way of doing it than that?
03:21:39 <quicksilver> blackdog: forget uncurry, that's surely irrelevant to what youw ant.
03:22:01 <quicksilver> just try to apply it to the parameters you've been given
03:22:10 <quicksilver> and complain if you get a type error
03:24:15 <blackdog> no, i think it is relevant
03:24:41 <blackdog> i scan every top-level declaration in the module, and only export it to ruby if it's plausible that ruby might be able to call it
03:25:09 <illissius-> blackdog: what are you working on? a haskell->ruby bridge?
03:25:10 <blackdog> so in effect, i need to show that for each argument, i have a way to translate from ruby to haskell
03:25:15 <quicksilver> sure.
03:25:20 <blackdog> illissius-: yeah. github.com/mwotton/hubris
03:25:23 <quicksilver> but this is nothing to do with uncurry.
03:25:32 <quicksilver> just keep inspecting arguments
03:25:38 <quicksilver> making sure you can translate.
03:25:43 <blackdog> i don't have the arguments yet
03:25:49 <quicksilver> sorry, argument types.
03:26:14 <quicksilver> if you have the type (a -> b) do the following, IMO:
03:26:22 <blackdog> i can't necessarily look at each argument in turn, though
03:26:25 <quicksilver> 1) is 'a' a ruby-translatable parameter type
03:26:37 <quicksilver> 2) is 'b' a function type - then expand and look for more arguments
03:26:49 <quicksilver> 3) otherwise, is 'b' a ruby-translatable return type
03:27:49 <blackdog> so actually pick it apart on the type level
03:29:02 <quicksilver> I think so. What you're doing is making a decision on types.
03:29:06 <quicksilver> This seems the natural way to me.
03:31:53 <blackdog> for some reason, HINT gives you back the type of an expression as a string.
03:31:55 <blackdog> eesh.
03:43:49 <muhtimin> win 35
03:45:43 <blackdog> oh god i need gensyms
03:45:44 <blackdog> the pain
03:47:09 <quicksilver> blackdog: clumsy, isn't it. I guess it's because there isn't a standard type for representing types.
03:49:55 <quicksilver> you can do (clumsy) tricks with asTypeOf 
03:50:30 <blackdog> quicksilver: in the interests of moving forward, i think i'm gonna stick with the uncurry trick for the momnet
03:50:38 <quicksilver> blackdog: for example (typeChecks "foo `asTypeOf` (\_ -> undefined)" )
03:50:48 <quicksilver> blackdog: that tells you if it's a function type.
03:51:14 <quicksilver> if you say so. I really don't see how the uncurry trick helps but I've probably missed something ;)
03:51:16 <blackdog> it'll break on some things, but it's enough to tell me arity for simple things. i can throw the hard cases aside and just not export them.
03:51:35 <blackdog> well, if i can uncurry a function three times but not four, i know how many arguments it has
03:52:00 <blackdog> although i could use the asTypeOf trick there too
03:53:01 <quicksilver> yes.
03:53:15 <quicksilver> foo `asTypeOf` (\_ _ _ -> undefined)
03:53:24 <quicksilver> but you can simply check if 
03:53:38 <quicksilver> "foo undefined undefined undefined" typechecks
03:53:42 <quicksilver> which is arguably more elementary.
04:04:22 <EnglishGent> hi all :)
04:05:00 <EnglishGent> can someone tell me why 1/0 in Haskell doesnt raise an error, or return NaN - but instead gives 'Infinity' ?
04:05:17 <EnglishGent> that doesnt feel right to me at all! :|
04:05:38 <p_l> EnglishGent: it is kinda right, but it's easier to say that 1/0 is an error...
04:05:56 <benc__> i have some code that seems to be happily using infinity
04:05:59 <benc__> as a result of that
04:05:59 <EnglishGent> hi p_l 
04:06:12 <EnglishGent> I think it ought to be an error - infinity is technically wrong isnt it?
04:06:55 <EnglishGent> eep! it's even worse than that - Infinity is a member of Eq - so 1/0 == 2/0 -> True!
04:06:57 <benc__> well infinity doesn't exist as a "number" in the same sense as a float
04:07:09 <p_l> EnglishGent: NaN is the correct answer, the thing is that usually Infinity isn't much different than that...
04:07:21 <EnglishGent> I thougth the IEEE standard distinguished between NaN and Infinity though
04:07:34 <Zao> Who says that Haskell cares aboot IEEE?
04:07:39 <Axman6> > 1/0 == 2/0
04:07:40 <EnglishGent> it's an error in most languages
04:07:40 <lambdabot>   True
04:08:02 * EnglishGent just tried it in Python as well... and Haskell is normally *so* much more beautiful than Python (semantically)
04:08:10 <benc__> is NaN an error in IEEE?
04:08:18 <fasta> http://www.psc.edu/general/software/packages/ieee/ieee.php seems to suggest infinity exists.
04:08:26 <p_l> benc__: depends on mode
04:09:11 <EnglishGent> yes - it's a value meaning the result is not a number, as far as I recall the standard distinguishes between +Infinitity, +InfinitesemlyGreaterThanZero, -veInfinity,-veInfinitesmlyBelowZero & NaN
04:09:21 <EnglishGent> (modulo spelling errors!) :)
04:09:29 <fasta> EnglishGent, I don't see what's better about what Python does.
04:10:38 <EnglishGent> it stops & raises an error.. rather than yielding a value which will allow your calculation to continue merrily on it's way with the error propagating through it
04:11:21 <fasta> EnglishGent, it is just a different semantics, not "better" in an objective sense.
04:11:22 <EnglishGent> by allowing Infinity to be a member of Eq as well Haskell is happy to let me write code proving 1 = 2 (i.e. 1/0 == 2/0) - whereas mathematically this is nonsense
04:11:32 <quicksilver> EnglishGent: haskell is making some vague attempt to follow IEEE
04:11:39 <fasta> EnglishGent, no, it doesn't.
04:11:46 <EnglishGent> hi fasta, quicksilver  :)
04:12:04 <quicksilver> EnglishGent: "Infinity" is not a member of "Eq", by the way.
04:12:14 <quicksilver> EnglishGent: "Infinity" is a value.
04:12:21 <EnglishGent> so why does 1/0 == 2/0 evaluate to true?
04:12:22 <quicksilver> "Double" is a member of "Eq".
04:12:22 <fasta> EnglishGent, floating point stuff is bolted onto Haskell is a certain sense, yes.
04:12:36 <EnglishGent> anyway .. I can live with it - and I still really like Haskell
04:12:42 <quicksilver> I believe the IEEE standard specifies that Infinity == Infinity is true.
04:12:45 <quicksilver> I'm not sure.
04:12:48 <EnglishGent> it just came as a big shock when I discovered it
04:12:51 * EnglishGent shrugs
04:12:52 <quicksilver> in fact, floating point equality is broken anyway.
04:13:10 <quicksilver> if you want to be purist, Double shouldn't be a member of Eq - even completely ignoring Infinity and NaN.
04:13:11 <EnglishGent> yeah - it is in everything :|
04:13:15 <fasta> The world would be a better place without a FPU. 
04:14:08 <fasta> The hardware people should just provide us with Rationals ;)
04:14:21 <EnglishGent> I'd agree quicksilver - it would be nice to support floating arithmetic with error margins, or even doing math algebraically :)
04:14:34 <EnglishGent> fasta:  - the hardware people should provide us with Oracles! :P
04:14:35 <EnglishGent> :)
04:14:39 <fasta> EnglishGent, interval arithmetic already exists.
04:14:49 <quicksilver> EnglishGent: anyway, the basic reason for haskell's behaviour is to provide semantics which maps to real FPU instructions.
04:15:00 <quicksilver> EnglishGent: so that a floating point instruction can be compiled as a floating point instruction.
04:15:07 <EnglishGent> fasta: - in Haskell? can you give me a link please? :)
04:15:09 <quicksilver> anything 'saner' would require wrapping around every FP instruction.
04:15:20 * EnglishGent didnt know that (interval arithmetic)
04:15:23 <edwardk> EnglishGent: invervals on hackage
04:15:25 <quicksilver> which would kill performance.
04:15:28 <edwardk> i uploaded it a few hours ago
04:15:30 <EnglishGent> ty edwardk :)
04:15:38 <fasta> @hackage interval arithmetic
04:15:38 <lambdabot> http://hackage.haskell.org/package/interval arithmetic
04:15:44 <fasta> Oh, never mind. 
04:15:54 <edwardk> http://hackage.haskell.org/package/intervals
04:15:57 <fasta> Just search for interval on the hackage website. 
04:16:17 <edwardk> i think @hackage just appends your string to the base url
04:16:28 <fasta> edwardk, yes, it does. 
04:16:53 <fasta> Anyway, the problem basically is that we are too impatient. 
04:16:56 <edwardk> EnglishGent: the 0.1.3 tried to use fpu rounding modes correctly, but ran into a problem with the fact that glibc is flat busted
04:17:11 <fasta> So, we invented some fluffy semantics that everyone now has to live with. 
04:17:32 <EnglishGent> perhaps an odd view - but I'd actually prefer haskell *not* to have floats by default, I'd rather you have to import them (I want to be able to use haskell as a teaching tool - and I do not want students thinking that 1/0 is infinity)
04:17:35 <edwardk> EnglishGent: the new version doesn't do any rounding mode adjustments. i've been putting together a library for wrapping MPFR, and explicitly using its rounding modes
04:17:53 <EnglishGent> I shall definitely take a look - thanks edwardk  :)
04:17:53 <edwardk> EnglishGent: http://github.com/ekmett/fixed-precision
04:17:54 <fasta> EnglishGent, that is not true. 
04:18:04 <fasta> > 1.2::Float
04:18:06 <lambdabot>   1.2
04:18:06 <edwardk> which i'll be using in the next version of intervals
04:18:10 <fasta> > 1.2::Double
04:18:11 <lambdabot>   1.2
04:18:24 <EnglishGent> what is not true fasta? (serious question)
04:18:27 <fasta> EnglishGent, no need to import anything.
04:18:41 <fasta> EnglishGent, never mind.
04:18:48 <edwardk> EnglishGent: the end goal isn't to use naive interval arithmetic at all, but instead to use taylor models to get tigher intervals
04:18:57 <fasta> EnglishGent, maybe I should actually read the _whole_ sentence ;)
04:19:08 * EnglishGent smiles at fasta  :)
04:19:57 <edwardk> there. i packaged up the fixed-precision lib for hackage
04:20:11 <edwardk> i'll need to document it a bit ;)
04:20:34 * hackagebot fixed-precision 0.2.0 - Fixed Precision Arithmetic  http://hackage.haskell.org/package/fixed-precision-0.2.0 (EdwardKmett)
04:21:48 <quicksilver> EnglishGent: there are reasons for 1/0 being Infinity in IEEE.
04:21:58 <quicksilver> EnglishGent: you may not think they are particularly good reasons, but they are not stupid.
04:22:24 <quicksilver> there are a class of continuous analyses for which the extension to (R + Inf) is natural, and the IEEE Inf behaviour handles the case correctly.
04:22:51 <quicksilver> how common these analyses are (versus other kinds of conceivable FP implementation) in practice is left as an exercise to the reader.
04:23:21 <EnglishGent> okay.. thanks for the references quicksilver :)
04:23:49 <quicksilver> in particular there are functions which are "continous everywhere except a set of measure zero"
04:23:58 <quicksilver> whose extension to (R + Inf) is, in fact, continuous everywhere.
04:24:06 <quicksilver> and that's convenient. For those functions.
04:24:17 <quicksilver> I can honestly say I have never, ever, found it convenient in a real program ;)
04:24:26 <quicksilver> but I can conceive that it might be, sometime, for someone.
04:25:01 <edwardk> i've actually had uses for negative zero for identifying signs of poles and what not as well
04:25:17 <edwardk> so the various vagaries of IEEE floating point suck until they are indispensible ;)
04:25:26 <edwardk> gotta run
04:27:37 * hackagebot fixed-precision 0.2.0.1 - Fixed Precision Arithmetic  http://hackage.haskell.org/package/fixed-precision-0.2.0.1 (EdwardKmett)
04:38:53 <fxr> are there any linear algebra packages for binary data? I wanna define kronecker and hadamart over bits.
04:43:15 <ivanm> fxr: none that i know of
04:43:35 <ivanm> you could possibly use hmatrix or something and define the functions appropriately to treat it as binary data
04:44:22 <fxr> ivanm: I tried that one but it's class definitions poorly documented.
04:44:33 <ivanm> in what sense?
04:44:44 * ivanm doesn't remember any class stuff in hmatrix
04:45:00 <ivanm> then again, I haven't used it for a while
04:45:05 <ivanm> oh, the Container stuff?
04:45:18 <ivanm> looks like its solely to be able to deal with complex numbers
04:45:37 <fxr> http://hackage.haskell.org/packages/archive/hmatrix/0.9.3.0/doc/html/src/Numeric-LinearAlgebra-Algorithms.html#Field
04:46:31 <ivanm> fxr: I'm saying use "Matrix Double" or something and define the operations you need appropriately
04:47:09 <ivanm> maybe even just use vector
04:47:17 <fxr> ivanm: oh sorry.
04:47:19 <ivanm> (as in the vector library)
04:47:31 <fxr> ivanm: I'm specially looking for an efficient impl.
04:47:54 <ivanm> there's no pre-existing binary linear algebra library that I know of
04:48:08 <fxr> ivanm: one of my friends wrote cryptanalysis library in CL and I'm trying to help him.
04:48:17 <ivanm> AFAIK, the only linear algebra libraries are hmatrix, blas and possibly vector-algorithms
04:48:45 <fxr> ok
04:48:46 <ivanm> oh, there's also hmatrix-glpk and hmatrix-special as extensions to hmatrix
04:49:21 <ivanm> @hackage Vec-Boolean
04:49:22 <lambdabot> http://hackage.haskell.org/package/Vec-Boolean
04:49:27 <ivanm> fxr: ^^ actually, this might do what you want
04:56:37 <fxr> actually I guess I need something like LLVM bitcode.
04:56:58 <fxr> I think it should be rewritten in haskell
04:57:08 <ivanm> *shrug*
05:08:40 <BAFANA|Taejo> > 2**17
05:08:41 <lambdabot>   131072.0
05:08:47 <BAFANA|Taejo> > 2**17 :: Repr Double
05:08:49 <lambdabot>   Not in scope: type constructor or class `Repr'
05:10:52 <ivanm> BAFANA|Taejo: what's the purpose of your prefix?
05:11:26 <BAFANA|Taejo> a foolish gimick to demonstrate support of my football team
05:11:47 <shadowspar> \o/ bafana bafana =)
05:15:29 <ivanm> >_>
05:29:29 <ManateeLazyCat> I always add function-name in "error" to debug, so i know which function throw error. And trouble is i need update function-name information in error when i change current function name. I want a perfect solution : printf "error position : " ++ currentFunction . When ghc scan current function define, ghc will replace currentFunction with "function name" String.
05:29:36 <ManateeLazyCat> So it's possible?
05:31:22 <ivanm> maybe with TH
05:32:14 <zygoloid> don't think TH lets you find the current function
05:32:37 <EnglishGent> hi ManateeLazyCat  :)
05:32:39 <EnglishGent> ltns!
05:32:49 <ManateeLazyCat> ivanm: When ghc compile code, i think ghc will know current function, i don't want TH 
05:32:53 <ivanm> zygoloid: neither do I, but if anything can it would probably be TH
05:33:07 <ManateeLazyCat> EnglishGent: Hey! :)
05:33:12 <ivanm> ManateeLazyCat: you want some kind of meta-programming to do that AFAIK, which means TH if anything
05:33:38 <ivanm> ManateeLazyCat: better option: try to have a way of recovering from errors rather than using error
05:33:42 <mreh> are some structure unable to be memoized?
05:33:43 <zygoloid> i wonder if -XCPP supports __FUNCTION__ ;-)
05:34:08 <ivanm> mreh: sure, a list of functions wouldn't be able to be memoized AFAIK
05:34:25 <ivanm> something that's too big to fit in RAM
05:34:40 <mreh> this array expression is repeatedly expanded for example
05:34:48 <ManateeLazyCat> ivanm: Sure, recovering error is better. But i want how to implement my idea.
05:34:49 <mreh> it's a few megabytes of image, that might be why
05:35:00 <ivanm> mreh: heh, sure sounds like it
05:35:22 <ivanm> ManateeLazyCat: as I said, the only way I can think of requires meta-compilation
05:35:24 <ManateeLazyCat> zygoloid: What's -XCPP ?
05:35:26 <ivanm> or some kind of pre-processor
05:35:29 <mreh> ivanm; what does the memoization? the haskell RTS?
05:35:32 <ivanm> ManateeLazyCat: uses the C pre-processor
05:35:49 <ManateeLazyCat> ivanm: Like macro replace?
05:36:06 <ivanm> mreh: are you hoping for automatic memoisation? or have you actually implemented memoisation?
05:36:11 <mreh> I suppose if you have a large graph, you need to store bits
05:36:17 <ivanm> ManateeLazyCat: right, all that #define, #ifdefine, etc. stuff
05:36:20 <mreh> ivanm: it's in a let clause
05:36:31 <ivanm> that's not really memoisation then...
05:36:45 <ivanm> manual CSE, maybe
05:37:22 <mreh> as haskell is a lazy functional language you get memoization for free
05:37:26 <mreh> rigth?
05:37:40 <Axman6> no
05:37:56 <Axman6> in theory you can, but GHC at least doesn't implement it
05:38:04 <ivanm> because of space leaks, etc.
05:38:32 <mreh> so it only really works automatically for small things
05:38:57 <ivanm> mreh: there is no memoisation at all
05:39:07 <mreh> I'm just confused about the output of the profiler
05:39:10 * Axman6 used to campaign for a memoisation annotation for functions, but has since realised doing it by hand is easier
05:39:12 <zygoloid> mreh: haskell is a non-strict functional language. GHC gives more-or-less lazy oprational semantics
05:39:15 <ivanm> there is some caching maybe, but that's about it
05:39:50 <ivanm> Axman6: yeah, even considering CSE: explicit manual CSE (where/let statements) usually results in cleaner, better-looking code IMHO
05:39:51 <zygoloid> mreh: lazy operational semantics means that inspecting the result of a function call will only cause that function to be invoked once.
05:39:58 <mreh> it's reporting a function call to fetch the image for every pixel in the image, but the expression to fetch it is in a let clause
05:40:06 <ManateeLazyCat> ivanm: Like your said, i need some meta-compilation to implement it, so how to get function name information from ghc or other tool?
05:40:08 <mreh> zygoloid: this is the thing
05:40:10 <zygoloid> mreh: it doesn't mean that the function will be invoked no times if it's already been invoked for the given arguments
05:40:16 <ivanm> ManateeLazyCat: no idea
05:40:25 <zygoloid> mreh: the former is laziness, the latter would be memoization
05:40:45 <mreh> but the function is being called with the same arguments!
05:40:47 <ivanm> ManateeLazyCat: I don't know much TH, but from what little I know (cue the saying about a little knowledge) you'd have to define your function within TH brackets
05:40:57 <ivanm> or else write a pre-processor using haskell-src-exts or something
05:41:01 <zygoloid> mreh: yes, and ghc does not implement memoization
05:41:02 <ManateeLazyCat> ivanm: If ghc use LLVM as backend, maybe we can get those information from LLVM, right?
05:41:08 * hackagebot wai-handler-fastcgi 0.1.0 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-0.1.0 (MichaelSnoyman)
05:41:23 <ivanm> ManateeLazyCat: I doubt it
05:41:27 <mreh> okay
05:41:31 <mreh> I need to think about this
05:41:33 <Axman6> bleh, i need a quad core machine!
05:41:34 <ivanm> since by that stage the function name has gone
05:41:48 <ivanm> Axman6: well, you can get one...
05:42:00 <ivanm> obtaining sufficient funds may be a slight impediment however :p
05:42:00 <Axman6> if i had money
05:42:07 <mreh> nothing uses 4 cores!
05:42:07 <Axman6> yeah
05:42:16 <Axman6> my programs do!
05:42:25 <Axman6> i wish i had far more than 4 cores
05:42:29 <Axman6> 8 or 16
05:42:31 <ivanm> Axman6: they can't if you don't have a 4 core machine!
05:42:33 <mreh> can I get compilers to build on multiple cores?
05:42:39 <ivanm> mreh: to an extent
05:42:40 <Axman6> they could be a shitty as hell, i just want lots of them
05:43:01 <ivanm> in that you might be able to build individual files separately on different cores
05:43:04 <Axman6> ivanm: they do when submitted to the shootout ;)
05:43:08 <mreh> I was thinking if I compile GHC with the llvm backend, it would only compile on half my processing power
05:43:17 <mreh> I might work out how to compile it on AWS
05:43:18 <ivanm> but AFAIK all compilers use a single core per file/logical unit
05:43:22 <ivanm> Axman6: lol
05:43:30 <ManateeLazyCat> ivanm: Hmmm... looks i need write myself tool to implement this feature. Thanks for your suggestion! :)
05:43:38 <ivanm> ManateeLazyCat: no worries
05:43:48 <Axman6> ManateeLazyCat: if you use make, you can make it use multiple cores
05:43:49 <ManateeLazyCat> BTW, how the status of LLVM for ghc?
05:44:02 <ivanm> however, I think you're inventing more work for yourself than what is needed (i.e. you're yak-shaving)
05:44:10 <mreh> so what memoises in the memo-combinators library?
05:44:21 <ivanm> AFAIK, the patches haven't been merged into GHC HEAD yet
05:44:33 <ivanm> but David is over at GHC HQ hacking on this stuff
05:44:42 <mreh> will we get llvm in future builds?
05:44:46 <ivanm> mreh: it provides memoisation combinators to avoid re-computing stuff more than once
05:44:48 <Axman6> hopefully
05:44:56 <ivanm> but it can affect memory usage
05:44:59 <mreh> then we'll be faster than C
05:45:05 <ManateeLazyCat> ivanm: yak-shaving? I can't understand .... :-(
05:45:10 <ivanm> mreh: not automagically we won't
05:45:28 <ivanm> ManateeLazyCat: http://en.wiktionary.org/wiki/yak_shaving
05:45:34 <mreh> I know, I know
05:45:39 <mreh> i was just being hopeful
05:45:50 <ivanm> in your case, I think you're doing the second definition ;-)
05:46:38 <ivanm> whereas bos called his development of statistics + criterion a case of yak-shaving when developing text, and overall falls into the first category (since he did useful benchmarking, and criterion is used elsewhere, etc.)
05:47:59 <ManateeLazyCat> ivanm: I understand now.
05:48:05 <mreh> where can I got to grok all this memoization
05:48:06 <ivanm> good-o
05:48:12 <mreh> RWH?
05:48:17 <ivanm> mreh: why do you think you need memoisation?
05:48:21 <ivanm> and no, RWH doesn't cover memoisation
05:48:23 <ManateeLazyCat> ivanm: Of course, i won't do that now even i just want get function information. :) 
05:48:25 <mreh> ivanm: I just want to grok it
05:48:29 <ivanm> it's usually not encouraged
05:48:46 <mreh> it's recreationally grokking
05:48:52 <ManateeLazyCat> ivanm: I just wonder has any exist solution do that. :)
05:49:14 <ivanm> mreh: the way it's usually defined in haskell is by having a top-level Map or something that is defined as being all possible input/output pairs of your function
05:49:15 <mreh> are you sure it doesn't relate to performance
05:49:30 <ivanm> and you do all your function evaluation by looking the value up in that Map
05:49:43 <ivanm> and it lazily gets evaluated as you call a specific value
05:50:00 <ivanm> however, if you call too many values you're obviously going to use more and more RAM as the individual thunks get evaluated
05:50:18 <ivanm> mreh: see also http://www.haskell.org/haskellwiki/Memoization
05:51:25 <mreh> what does CSE expand to?
05:51:41 <Axman6> common sub-expression elimination i think
05:51:44 <ivanm> Common Sub-expression Elimination
05:51:51 * Axman6 wins
05:51:53 <ivanm> mreh: also see Cale's comment on this (completely wrong) blog post: http://michaelspeer.blogspot.com/2007/11/dons-benchmark.html
05:52:00 <ivanm> Axman6: but you only think it, I _know_ it!
05:52:11 * Axman6 is humble
05:52:23 <ivanm> direct link to Cale's comment: http://michaelspeer.blogspot.com/2007/11/dons-benchmark.html?showComment=1196291040000#c4541191776372081735
05:56:44 <ManateeLazyCat> What's the biggest improvement if ghc use llvm as backend?
05:57:04 <Axman6> better numerical code for things like vector and DPH
05:57:34 <ivanm> and hopefully more optimisations thanks to the work the LLVM guys have done on their end
05:57:35 <arw_> portability perhaps?
05:57:42 <Axman6> and general speedups for a lot of code
05:57:43 <ivanm> arw_: that too, to an extent
05:58:06 <Axman6> i doubt we'll see any portability improvements. the runtime is still very platform dependant
05:58:13 <ivanm> of course, an LLVM backend will have problems of its own...
05:58:23 <kamatsu> Also it means a fair bit of cleanup of the code base, iirc
05:58:32 <ivanm> we now have to compile everything up to 4 times; with LLVM that will increase to up to 6 different versions of everything :s
05:58:34 <kamatsu> LLVM backend is quite a bit smaller and gives comparable results to native code gen
05:59:11 <ManateeLazyCat> Axman6: Have any compatible problem after switch to LLVM backend?
05:59:18 <ivanm> kamatsu: do you know if harrop has responded to his "you're only an intern, what do you know?" comment now that Google is giving a talk at ICFP?
05:59:22 <djahandarie> ivanm, "up to" 4 times? When would it choose to or not to skip a whole compiliation run?
05:59:27 <kamatsu> ivanm: i think he's suspiciously silent.
05:59:52 <ivanm> djahandarie: currently there's: static linking, static + profiling, dynamic linking, dynamic + profiling
06:00:15 <ivanm> atm, only the first occurs by default
06:00:36 <ManateeLazyCat> ivanm: So what's the 6 with llvm?
06:00:46 <ivanm> ManateeLazyCat: add to that LLVM and LLVM + profiling
06:00:53 <kamatsu> ivanm: i don't think that's right.
06:01:01 <ivanm> oh? why not?
06:01:17 <kamatsu> ivanm: LLVM is just another backend, like the gcc backend or the native code gen backend.
06:01:38 <ivanm> kamatsu: but doesn't everything have to be compiled especially for it?
06:01:48 <ivanm> or is it only the resulting binaries?
06:02:01 <kamatsu> I don't understand what you mean
06:02:12 * ivanm admits that he isn't that well versed in how the LLVM backend works, but that was the impression he got
06:02:17 <kamatsu> yes, haskell programs have to be compiled especially for LLVM if they want to use the LLVM backend.
06:02:25 <ManateeLazyCat> kamatsu: So ghc will use two backends? gcc and llvm?
06:02:31 <kamatsu> but this is the same as having to compile them to C for GCC backend.
06:02:37 <kamatsu> ManateeLazyCat: It has its own native generator as well.
06:02:53 <ivanm> kamatsu: I thought that the LLVM backend was going to be in parallel to the native code gen backend
06:03:01 <Axman6> it is
06:03:01 <ivanm> so if you wanted to support both you'd have to compile for both
06:03:11 <Axman6> i don't believe so
06:03:17 <ivanm> ManateeLazyCat: GCC backend is being deprecated
06:03:25 <ivanm> Axman6: hmmm....
06:03:42 <Axman6> the LLVM backend should produce files compatible with the non LLVM files
06:03:56 <ivanm> oh, OK
06:04:08 <ivanm> so just the final "let's make a binary" step would result in something different?
06:04:18 <ivanm> whereas all the .so/.dll files are the same?
06:04:28 <kamatsu> yes
06:04:34 <kamatsu> this is likely to be the result
06:04:42 <Axman6> it's the Core -> Asm step that's different i believe.
06:04:55 <kamatsu> you don't need to link everything at the LLVM assembly level
06:05:07 <kamatsu> you can link stuff when that llvm assembly is compiled further to native binaries
06:05:21 <Axman6> they'll produce different assembly/machine code, but they should be compatible. like suing -O2 and -O3 in GCC will produce different machine code
06:05:23 <ManateeLazyCat> So ghc need two version code to support gcc and llvm?
06:05:23 <ManateeLazyCat> I hope ghc focus one backend. 
06:05:26 <ivanm> looks like you need to explicitly tell GHC to use the LLVM backend
06:05:39 <Axman6> ManateeLazyCat: it already has two
06:05:40 <kamatsu> for now, yes.
06:05:51 <ivanm> which IIUC means it doesn't inter-operate with the native code gen backend
06:06:09 <Axman6> what?
06:06:16 <ivanm> ManateeLazyCat: for x86 and x86_64, there is already the native code gen backend and the gcc backend (which is usually discouraged)
06:06:31 <Axman6> if you compile half a package using the LLVM backend, and half using the NCG, it should all work fine
06:06:50 <kamatsu> Axman6: maybe not yet, but certainly by GHC 6.13
06:06:55 <ivanm> then why does it need the explicit -fllvm flag to compile a library?
06:07:04 <Axman6> kamatsu: s/13/14?
06:07:08 <kamatsu> yes
06:07:10 <kamatsu> sorry
06:07:15 <Axman6> :)
06:07:21 <Axman6> you're coming to AusHac right?
06:07:27 <ivanm> Axman6: s+s/13/14+\1/+ :p
06:07:30 <kamatsu> yes
06:07:36 <kamatsu> david terei (llvm guy) isn't tho
06:07:37 <Axman6> excellent
06:07:41 <Axman6> yeah :(
06:07:50 <ManateeLazyCat> ivanm: Which backend do you use now?
06:07:57 <kamatsu> i think most of us use NCG
06:08:15 <ivanm> yeah, imagine going off to GHC HQ rather than hanging around here for AusHack, even though he didn't know about AusHak when he planned his trip...
06:08:19 <Axman6> the LLVM backend is pretty experimental
06:08:33 <Axman6> yeah, what a jerk :(
06:08:36 <ivanm> ManateeLazyCat: the only recommended time to use the GCC backend is when you're doing a lot of numeric/floating point stuff
06:08:39 <kamatsu> it was done as an undergrad thesis project last year
06:08:40 <ivanm> and possibly parallel stuff
06:08:53 <ivanm> kamatsu: "honours", to those of us down here ;-)
06:09:16 <ivanm> took me a while to realise that (I was trying to work out why someone was doing a year-long thesis for their bachelors)
06:09:40 <kamatsu> oh, well, yes
06:10:59 <kamatsu> in other news, I completed my first paper about JS generation from purely functional langs today.
06:11:07 <kamatsu> hopefully TacticalGrace is kind
06:11:13 <Axman6> heh
06:11:14 <coonsta> kamatsu: URL?
06:11:14 <ivanm> cool
06:11:23 <kamatsu> coonsta: not up yet, i am still going over it
06:11:27 <ivanm> did you reference the YHC -> JS backend?
06:11:33 <kamatsu> ivanm: yes, briefly
06:11:49 <kamatsu> I couldn't really get much info on it. I got some uncompilable source code
06:12:00 <ivanm> cool (just trying to prevent any further allegations from Harrop about lack of peer review, etc.)
06:12:02 <ivanm> :p
06:12:07 <ivanm> kamatsu: lol
06:12:18 <kamatsu> i really don't care what Harrop thinks
06:12:33 <kamatsu> obviously he has an anti-academic bias
06:12:54 <ivanm> Axman6: I know you're usually busy on thursday nights, but do you think you could maybe do a talk at the CLUG PSIG with me in August about AusHack?
06:13:13 <Axman6> will i get paid/food?
06:13:18 <quicksilver> harrop says what he chooses to waste everyone's time
06:13:23 <quicksilver> please, do yourself a favour and ignore it.
06:13:28 <ivanm> Axman6: you will have the chance to get food...
06:13:32 <ivanm> kamatsu: surely not! otherwise why would he critique your papers on the poor amount of academic quality in them!
06:13:36 <Axman6> quicksilver: it's so hard though :(
06:13:42 * quicksilver doesn't find it so hard.
06:13:45 <Axman6> ivanm: i might be able to
06:13:56 <ivanm> quicksilver: tbh, I find a great way to find interesting articles on reddit is to look at where harrop is trolling :p
06:14:02 <ivanm> Axman6: cool
06:14:03 <quicksilver> heh.
06:14:10 <Axman6> ivanm: heh
06:14:18 <ivanm> oh, and I still haven't managed to work out what his PhD was in (since he sometimes calls himself Dr)
06:14:29 <kamatsu> the strange thing is he can be quite reasonable when he's arguing against dynamic languages
06:14:40 <kamatsu> but when he argues against Haskell he goes all batshit
06:14:46 <kamatsu> sorry for cursing
06:14:48 <ivanm> kamatsu: unless he's trolling comp.lang.lisp :p
06:14:55 <aristid> kamatsu: well, maybe it's you who is biased
06:15:12 <kamatsu> aristid: well, no, i was just reading a thread on stack overflow including him
06:15:17 <aristid> kamatsu: because you agree with him you think that it's more reasonable what he writes, even if it is entirely superficial :)
06:15:17 <pookleblinky> Someone should just make a language designed to annoy him
06:15:18 <ivanm> aristid: he's in here, he's doing haskell related academic work; do you _think_ he's biased?
06:15:23 <ManateeLazyCat> ivanm: AusHack url?
06:15:23 <ivanm> pookleblinky: lol
06:15:25 <pookleblinky> And thereby spare everyone his trolling
06:15:33 <ivanm> ManateeLazyCat: http://www.haskell.org/haskellwiki/AusHac2010
06:15:36 <pookleblinky> As he rages against Fooskellisp
06:15:36 <Axman6> aristid: no, he seriously goes batshit insane when talking about haskell
06:15:44 <ManateeLazyCat> ivanm: Thanks. :)
06:15:46 <tab> ivanm: physics
06:15:51 <Axman6> he often has some good points too, but he just turns into a massive dick
06:16:09 <ManateeLazyCat> ivanm: Oh, Australia Haskell? Surprise to me.... 
06:16:10 <aristid> Axman6: and he doesn't turn batshit insane when talking about dynamic languages like lisp?
06:16:11 <ivanm> tab: oh? is that why he's obsessed with ray tracers?
06:16:16 <pookleblinky> Zed Shaw can pull off being an asshole.
06:16:20 <pookleblinky> Some people can't
06:16:28 <Axman6> aristid: i haven't seen any lisp rants of his
06:16:33 <ivanm> ManateeLazyCat: Axman6 and I have been spamming -cafe about it on and off since ZuriHac ;-)
06:16:49 <aristid> Axman6: ivanm said something about dynamic languages, of which lisp is one :D
06:16:51 <ivanm> pookleblinky: if by "pull off" you mean "make everyone recognise that you're one", then sure
06:16:52 <kamatsu> Ever since Zed's new blog, I haven't instantly recognized posts he's written as his
06:17:07 <kamatsu> I always think "Wow, this is such a troll article, it's almost like it was written by Zed Shaw"
06:17:08 <ManateeLazyCat> ivanm: Maybe i need create ChinaHac .... :)
06:17:10 <kamatsu> and then i realise..
06:17:16 <tab> ivanm: maybe, dunno why to be honest
06:17:25 <ivanm> Axman6: the lispers get pissed off at him because every now and then he pops up in comp.lang.lisp and says how mathematica/ocaml/F# are better than Common Lisp
06:17:30 <kamatsu> ManateeLazyCat: China is pretty big place
06:17:32 <aristid> kamatsu: it was quite weird when he wrote that programming will become like a factory job
06:17:37 <ivanm> ManateeLazyCat: go ahead!
06:17:40 <ivanm> the more the merrier!
06:17:48 <Axman6> mathematica? ha
06:17:49 <kamatsu> aristid: I like it when he makes assumptions about how much I know
06:17:55 <ManateeLazyCat> Unfortunately, just little Chinese programmer like Haskell . :)
06:17:56 <kamatsu> "Name 4 contributors to your favorite tool"
06:18:00 <Axman6> mathematica is horrible in so many ways
06:18:03 <ivanm> kamatsu: isn't Australia bigger?
06:18:04 <kamatsu> "I bet you can't"
06:18:09 <kamatsu> ivanm: than China!?
06:18:16 <pookleblinky> aristid, there is a point there, though. It's scary to think of how small the percentage is of programmers who actually learn haskell and such just to expand their minds.
06:18:23 <ManateeLazyCat> ivanm: I think China is bigger than Australia.
06:18:31 <ivanm> kamatsu: duh, sorry
06:18:32 <pookleblinky> Probably the majority do not have passion for programming.
06:18:41 <ivanm> was thinking of something else for some stupid reason
06:18:47 * ivanm hasn't had enough sleep this past weekend
06:18:48 <kamatsu> alot of people get attached to things religiously though
06:18:50 <aristid> pookleblinky: i think we will need fewer (and better) programmers in the future :)
06:19:03 <kamatsu> most dynamic typing people steer clear of haskell due to bad experiences with Java or whatever
06:19:15 <kamatsu> although this is changing
06:19:18 <ivanm> kamatsu: what happens if your favourite tool is a one-man-show? :p
06:19:23 <pookleblinky> aristid, or a Ramsey Gordon to convert code monkeys into impassioned haskellers.
06:19:35 <pookleblinky> "You call this a closure? BOLLOCKS!"
06:19:46 <kamatsu> Yes, Haskellers should say "bollocks"
06:19:48 * edwardk_ waves hello.
06:19:54 <kamatsu> it's an english language after all
06:19:56 <Axman6> o/ edwardk_ 
06:20:04 <aristid> kamatsu: BOLLOCKS! Why?!
06:20:18 <kamatsu> aristid: it was invented by englishmen!
06:20:20 <aristid> .oO(i need to look up what "bollocks" means)
06:20:37 <tab> aristid: equivalent of bullshit
06:20:39 <aristid> ah, testicles
06:20:44 <aristid> TESTICLES!
06:20:48 <kamatsu> tab: It can also be used instead of "damn"
06:20:50 <ivanm> hey edwardk 
06:20:57 <edwardk> heya ivan
06:20:59 <Axman6> kamatsu: or bullshit
06:21:00 <pookleblinky> You can safely say that if a programmer ever, ever reads Lambda the Ultimate for fun or the Haskell Wiki, he's instantly in the top 10%
06:21:02 <edwardk> did my example make sense?
06:21:02 <tab> kamatsu: true
06:21:11 <ivanm> edwardk: did my response to your example make sense? :p
06:21:22 <pookleblinky> Just because he's actually curious. It's not just a job to him.
06:21:28 <edwardk> ivanm: haven't been at a computer until just now
06:21:31 <kamatsu> pookleblinky: wow, so you're saying that haskell programmers are usually better than all other programmers?
06:21:35 <ivanm> heh
06:21:44 <aristid> pookleblinky: and if he's hanging out in #haskell, he's an elite programmer!
06:22:02 <pookleblinky> kamatsu, how many people who know haskell, are bored by it?
06:22:03 <kamatsu> btw, Jon Harrop reads lambda the ultimate
06:22:06 <kamatsu> i think he enjoys what he does
06:22:09 <ivanm> kamatsu: I think he's trying to say that those that go out of their way to learn more advanced techniques, tools, etc. are
06:22:22 <pookleblinky> Glue together things they googled and sacrifice a chicken to Knuth?
06:22:25 <aristid> kamatsu: he probably can be granted to be in the top 10% :D
06:22:39 <kamatsu> aristid: i guess you're sadly right.
06:23:08 <edwardk> ivanm: your proposed implementation won't work =)
06:23:14 <ivanm> why not?
06:23:29 <Philonous> kamatsu: I don't really know Harrop, but I doubt that he is a bad programmer. 
06:23:42 <aristid> kamatsu: good to have enemies anyway. fosters community spirit :P
06:23:50 <pookleblinky> Zed Shaw's point is probably right, though. The field of programming becoming stratified much more rigidly into actual programmers, and codemonkeys. Like medics in Overdrawn at the Memory Bank
06:23:52 <kamatsu> us vs. them mentality?
06:23:56 <edwardk> ivanm: foo :: (InductiveGraph (g a b)) => g a b -> Iterated (g a) b works for the base case, but the types look like g a b :- g a (g a b :- g a (g a (g a b)) :- ....
06:23:57 <kamatsu> or in this case, us vs. him
06:23:58 <ivanm> edwardk: AFAIK, it is still possible to only consider graphs that are * -> * -> *, but the type sigs get uglier
06:24:07 <edwardk> you only have a Graph for the outermost g a b
06:24:14 <edwardk> beyond that you can't use the iterated.
06:24:15 <aristid> what's the name for entities that have kinds?
06:24:17 * ManateeLazyCat I hope haskell mathematician can write his paper more understandable, sometimes crazy to me.... :)
06:24:19 <aristid> something with kind * is a type
06:24:20 <edwardk> aristid: types
06:24:29 <aristid> but * -> * is not a type i think?
06:24:32 <ivanm> edwardk: hmmmm.....
06:24:33 <edwardk> aristid: Maybe is also a type
06:24:37 <jmelesky> pookleblinky: i don't think it's stratified so much as specialized into different fields
06:24:40 <kamatsu> I think types have kinds
06:24:46 <kamatsu> so any kinded thing is a type
06:24:50 <ivanm> edwardk: do you actually use/need that though? ;-)
06:24:52 <aristid> edwardk: hmm that's a bit surprising
06:24:53 <kamatsu> bijective
06:25:00 <edwardk> ivanm: yes
06:25:07 <edwardk> aristid: Maybe is a type.
06:25:11 <ivanm> edwardk: as in do you actually need to use that with FGL
06:25:13 <aristid> edwardk: i heard you :P
06:25:16 <edwardk> it is not an inhabited type. ;)
06:25:22 <ivanm> I thought you were writing your stuff completely from scratch
06:25:47 <aristid> edwardk: my intuition was that only (Maybe a) would be a type
06:25:58 <aristid> but obviously wrong
06:26:02 <edwardk> ivanm: my point was that polymorphic recursion is a usecase. it comes up with simpler cases than that but it was one i could rattle off on the way out the door ;)
06:26:09 <aristid> so only types with kind * are inhabited?
06:26:24 <edwardk> aristid: no, we also have # and (#)
06:26:27 <wlangstroth> is there an operator for "binding" a list of pure functions to a list of values? (All the examples I've seen are monadic)
06:26:32 <edwardk> aristid: those are also inhabited types
06:26:40 <edwardk> and for that matter ? and ??
06:26:44 <aristid> edwardk: i didn't know about # and (#)
06:26:56 <aristid> something to do with boxing?
06:26:56 <ivanm> edwardk: I agree that there might be cases where you want/need that kind of stuff
06:27:05 <Accidus> What condition do I need to impose on an adjunction F -| U such the induced monad F;U is strong?
06:27:27 <ivanm> however, I would think it's more of a niche use case and less wanted/requested than the ability to constrain the types, etc.
06:27:32 <ivanm> so it's a trade-off
06:27:40 <Saizan> aristid: yeah, GHC adds # (#) ? and ?? to deal with unboxed values
06:28:15 <edwardk> ivanm: imho it is kind of like defining Monad by saying class Return m a where return :: a -> m a;   class Bind m a b where (>>=) :: m a -> (a -> m b) -> m b -- there are times when you really DO need to be that pedantic and occasional usecases, but mot of the time the extra specificity gets in the way
06:28:18 <aristid> Saizan: FOUR kinds just for unboxing?
06:28:24 <edwardk> er most
06:28:31 <edwardk> aristid: yeah
06:28:43 <Saizan> and subkinding!
06:29:03 <Philonous> > [+1,*2,const 7] <*> [1,7,100] -- wlangstroth like that? 
06:29:04 <lambdabot>   A section must be enclosed in parentheses thus: (+ 1)A section must be encl...
06:29:07 <ivanm> edwardk: in this case, however, I think it's the other way round; people (especially Henning) have repeatedly asked for the ability to constrain the types, etc.
06:29:12 <Philonous> > [(+1),(*2),const 7] <*> [1,7,100]
06:29:13 <lambdabot>   [2,8,101,2,14,200,7,7,7]
06:29:49 <aristid> > getZipList $ ZipList [+1,*2,const 7] <*> ZipList [1,7,100]
06:29:50 <lambdabot>   A section must be enclosed in parentheses thus: (+ 1)A section must be encl...
06:29:51 <edwardk> ivanm: my point is that i think ultmately you need to define both apis, with a lifting from the polymorphic version into the monomorphic version
06:30:02 <aristid> > getZipList $ ZipList [(+1),(*2),const 7] <*> ZipList [1,7,100]
06:30:03 <lambdabot>   [2,14,7]
06:30:13 <Philonous> > zipWith ($) [(+1),(*2),const 7] [1,7,100]
06:30:14 <ivanm> edwardk: not sure how well the lifiting would work though
06:30:15 <lambdabot>   [2,14,7]
06:30:33 <aristid> Philonous: yeah, zipWith is liftA2
06:30:35 <ivanm> if you can suggest some ways of doing so that don't involve too much duplication, I'd be interested in seeing it
06:30:39 <edwardk> ivanm: well, its easy to go from the higher kinded one to your overly specific type classes
06:30:45 <edwardk> but you will have duplication
06:30:50 <ManateeLazyCat> edwardk: You have better solution for polytechnic code?
06:30:53 <ivanm> (since I'm definitely not doing what Henning asked and duplicating the classes to have explicit non-labelled variants)
06:30:57 <wlangstroth> wonderful! thanks, guys
06:30:57 <edwardk> by the very nature of the api
06:31:10 <Philonous> aristid: Sure, but I don't like zip Lists. Too much noise with too little benefit. 
06:31:11 <ManateeLazyCat> s/polytechnic/polymorphism
06:31:11 <ivanm> edwardk: hmmm....
06:31:30 <ivanm> edwardk: can you send me a quick example of how to do so in an email?
06:31:34 <aristid> Philonous: you can use them with generic Applicative functions
06:31:43 * ivanm would discuss this further now, but needs to sleep
06:31:53 <edwardk> erm, take what you have and cut and paste it along side something very much like the existing fgl, done ;)
06:32:09 <ivanm> edwardk: so there's no inter-op then...
06:32:13 <ManateeLazyCat> edwardk: I always did some wrap type when i want polymorphism function/type. I wonder have better solution than that.
06:32:15 <ivanm> I thought you meant with some kind of interop
06:32:24 <edwardk> add a newtype LiftedGraph g a b = Graph (g a b) -- which is an instance of your new types
06:32:39 <ivanm> OK...
06:32:51 <ivanm> hmmm....
06:32:56 <edwardk> ivanm: that last piece is the bridge that lets you use any fgl-like graph with ivan-like graphs
06:32:58 <ivanm> so there'll be some boilerplate involved...
06:33:02 <ivanm> edwardk: lol
06:33:10 <ivanm> OK, I"ll have a think about that during the week and see how I go
06:33:49 <edwardk> ManateeLazyCat: i hav a whole spiel about how one can use comonads to separate shape from data and side-step the whole issue, but i don't want to regurgitate it right now ;)
06:33:49 <ivanm> edwardk: I suppose I could then have the APIs exactly the same (or close to) and people just import whichever one they want/need
06:33:59 <edwardk> ivanm: yeah
06:34:06 <ivanm> edwardk: you need to write your comonad stuff up and formalise it
06:34:10 <ivanm> maybe for TMR?
06:34:18 <ivanm> since I'd also appreciate a more fully fleshed out manifesto
06:34:20 <edwardk> ivanm: if i do i'll just write the lib ;)
06:34:32 <ivanm> edwardk: no, I mean more a tutorial approach as well
06:34:34 <edwardk> ivanm: it hasn't reached a pain point for me yet
06:34:36 <ManateeLazyCat> edwardk: Do you have any darcs repo let me try? 
06:34:48 <ManateeLazyCat> Or library?
06:34:54 <edwardk> ManateeLazyCat: i had hpasted it to moonpatio at one point, but that appears dead
06:35:02 <edwardk> ManateeLazyCat: tomberek may still have a copy
06:35:13 <edwardk> but its hard to understand the gist without the context =)
06:35:17 <ivanm> edwardk: well, all of my understanding about it is trying to understand from my discussions with you; an actual document about what it is, why we'd want it, why it's cool, etc. would be greatly appreciated
06:35:36 <ivanm> I think the HNN trac had a copy
06:35:57 <o-_-o> if I've previously declared a function in ghci
06:35:58 <edwardk> ivanm: its somewhere between rewriting category-extras and taking ove rthe world on my priority list ;)
06:36:05 <ivanm> lol
06:36:05 <o-_-o> how do I print the source of the function ?
06:36:14 <edwardk> o-_-o you can't
06:36:16 <ivanm> bah, can't seem to find it
06:36:25 <o-_-o> edwardk, !
06:36:32 <o-_-o> :'(
06:36:35 <ivanm> o-_-o: @show in lambdabot works by explicitly defining a lookup map of function names to sources
06:36:44 <ivanm> o-_-o: ghci converts them to byte-code, etc.
06:36:51 <ManateeLazyCat> edwardk: When time relase those ? I will try it first-time. :)
06:36:56 <ivanm> don't forget, it's possible to have very long function sources...
06:37:15 <edwardk> ManateeLazyCat: i'll let you know when/if i put something out.
06:37:23 <ManateeLazyCat> edwardk: If ivanm said it's cool, it's must be very cool ... :)
06:37:41 <ManateeLazyCat> edwardk: Thanks! :)
06:37:42 <ivanm> ManateeLazyCat: the approach sounds cool; I'm not sure if I fully understand it though ;-)
06:38:06 <edwardk> it winds up terrifying people because i used the word comonad ;)
06:38:06 <ivanm> edwardk: thing is, having a dual-layer approach like this will make it harder to integrate with the generic graph library (since I would then need to have a dual-layered approach to that as well...)
06:38:20 <ivanm> edwardk: go back to using "annotated" :p
06:38:28 <ManateeLazyCat> ivanm: I love #haskell, i can study much advanced tips that can't found any other place. :)
06:38:36 <ivanm> ManateeLazyCat: see http://trac.haskell.org/HNN/wiki/CodeDraft
06:38:40 * ivanm finally found it~
06:38:43 <ivanm> s/~/!/
06:38:55 <ivanm> should have trusted firefox's awesome bar to begin with rather than google... ;-)
06:39:07 <edwardk> ManateeLazyCat: http://hackage.haskell.org/packages/archive/rope/0.3/doc/html/Data-Rope-Annotated.html is another 'annotated' library of mine, but the types there aren't ideal
06:39:19 <ManateeLazyCat> ivanm: I think Google's Safe APIs is better.
06:39:36 <ManateeLazyCat> ivanm: I plan to add it to my Webkit browser for safely browse. :)
06:39:45 <ivanm> well, it was obviously failing in my attempt to find that page ;-)
06:40:32 <edwardk> ivanm: i still need a good asymptotically efficient graph topological sort for my ad lib
06:40:41 <ivanm> since googling for (without quotes) "edward kmett graph HNN" doesn't bring up anything relevant, except for edwardk saying that they're working on on in #hnn
06:40:45 * ManateeLazyCat Of course, i will add some tools to around GFW. I don't like firefox or Chrome's, always attack by China gov.
06:40:49 <o-_-o> I am using eureqa to find functions to fit my data and pasting them directly into ghci to find which function is the right fit :-)
06:40:51 <ivanm> edwardk: not sure if such a thing is possible
06:40:56 <ivanm> let us consult the brains trust!
06:40:58 <ivanm> preflex: seen Cale 
06:40:58 <preflex>  Cale was last seen on #haskell 8 hours, 52 minutes and 57 seconds ago, saying: It's good at lots of stuff which isn't easily qualified as a specific type of application
06:41:07 <o-_-o> thankfully all the functions I had defined were in the history
06:41:18 * o-_-o let's out a *sigh* of relief
06:41:21 <ivanm> what's eureqa?
06:41:44 <ivanm> you mean this?
06:41:46 <ivanm> http://ccsl.mae.cornell.edu/eureqa
06:41:50 <edwardk> ivanm: well i know i can do it in O(n log n) but Data.Graph uses naked ++'s to glue together the result, so can drift past quadratic
06:41:52 <o-_-o> ivan, yes
06:42:03 <o-_-o> ivanm, yes
06:42:47 <ManateeLazyCat> ivanm: You mean firefox's search bar....
06:42:55 <ManateeLazyCat> ivanm: Misunderstand.
06:43:08 <ivanm> ManateeLazyCat: the awesome bar is firefox's extended address bar
06:43:27 <ivanm> edwardk: which actual function in Data.Graph?
06:43:43 <ivanm> @ask Cale do you know of any reliable way to impose an ordering upon graphs?
06:43:44 <lambdabot> Consider it noted.
06:43:48 <edwardk> iirc it was topSort, or something like that
06:43:54 <ManateeLazyCat> ivanm: Search or open url?
06:43:59 <ivanm> @tell Cale oh, and efficient sorts would be nice ;-)
06:44:00 <lambdabot> Consider it noted.
06:44:11 <ivanm> ManateeLazyCat: for this, I just searched for "HNN" and it looked through my history
06:44:23 <ivanm> edwardk: *nod*
06:44:41 <ivanm> edwardk: so that doesn't cope with graphs that have nothing in common?
06:44:49 <aristid> yay for topological sorting
06:44:58 <ivanm> @time
06:44:59 <lambdabot> Local time for ivanm is Mon Jun 14 23:44:35
06:45:01 * ivanm -> sleep
06:45:03 <ivanm> g'night all
06:45:11 <edwardk> ivanm: well. all i care about is iterating outward from one node
06:45:19 <ivanm> edwardk: *nod*
06:46:14 <edwardk> ivanm: i just need to make sure i've "pushed" all my partial derivatives into a given before i go to push them further back in the graph
06:46:20 <edwardk> er into a given node
06:48:10 <quicksilver> edwardk: all sufficiently complex programs contain (at least one) poorly specified and buggy toplogical sort routine
06:48:45 * EnglishGent wonders if that includes the topological sort routine ;)
06:48:49 <edwardk> quicksilver: i'm okay with poorly specified, as long as it is well implemented ;)
06:48:58 <edwardk> EnglishGent: by construction there has to be one in there somewhere ;)
06:49:13 <aristid> the topSort algorithm in containers is much more advanced than what i once implemented :D
06:50:30 <quicksilver> edwardk: well in the typical case (in code at large) the data structures are completely inappropriate, there is no abstract graph structure available, and the programmer does some ad-hoc, hackish, and in a few cases ingenious.
06:50:37 <HugoDaniel> my haskell sucks so much :(
06:50:50 <aristid> woah, dfs uses  the ST monad
06:51:07 <quicksilver> edwardk: it's alike (but far worse than) the fact that C programmers don't trust data structure libraries so they go to absurd lengths not to use anything like an associative array.
06:52:59 <Axman6> @src Exception
06:52:59 <lambdabot> Source not found. Take a stress pill and think things over.
06:54:27 <bobzhangthu> whois edwardk
06:54:42 <edwardk> me
06:54:55 <bobzhangthu> sorry, i am a newbie, type error
06:54:59 <edwardk> =)
06:55:39 <bobzhangthu> has anyone used the library hmatrix in Mac OS?
06:57:46 <bobzhangthu> or the linking error, anyone knows how to handle it? thanks
06:57:47 <bobzhangthu> bash-3.2$ ghc --make 1.hs
06:57:47 <bobzhangthu> Linking 1 ...
06:57:47 <bobzhangthu> Undefined symbols:
06:57:50 <bobzhangthu>   "_iconv_close", referenced from:
06:57:52 <bobzhangthu>       _hs_iconv_close in libHSbase-4.2.0.0.a(iconv.o)
06:57:55 <bobzhangthu>      (maybe you meant: _hs_iconv_close)
06:57:59 <bobzhangthu>   "_iconv_open", referenced from:
06:58:02 <bobzhangthu>       _hs_iconv_open in libHSbase-4.2.0.0.a(iconv.o)
06:58:05 <bobzhangthu>      (maybe you meant: _hs_iconv_open)
06:58:08 <bobzhangthu>   "_iconv", referenced from:
06:58:12 <bobzhangthu>       _hs_iconv in libHSbase-4.2.0.0.a(iconv.o)
06:58:14 <ivanm> bobzhangthu: there was something about this on haskell-cafe recently
06:58:15 <bobzhangthu>      (maybe you meant: _hs_iconv_close, _hs_iconv_open , _hs_iconv )
06:58:17 <ManateeLazyCat> bobzhangthu: paste?
06:58:18 <Choko> I've a project, after I've upgraded from quickcheck 2.1.0.2 to 2.1.0.3 it still wants to 2.1.0.2 (<command line>: unknown package: QuickCheck-2.1.0.2), I've tried to remove .cabal and .ghc but it doesn't work If I check the code out under a new user it works so somewhere in my homedir something has gone wrong, but where?
06:58:18 <bobzhangthu> ld: symbol(s) not found
06:58:21 <bobzhangthu>  
06:58:27 <ivanm> bobzhangthu: also, you shouldn't paste so many lines into IRC
06:58:35 <ManateeLazyCat> bobzhangthu: You can check gtk2hs list.
06:58:42 <dcoutts> Choko: try cabal clean
06:58:45 <ivanm> bobzhangthu: IIRC, the solution is soemthing to do with macports iconv not being compatible with OSX's native version
06:58:51 <ManateeLazyCat> bobzhangthu: I remember some guy have same problem with you 
06:59:16 <dcoutts> Choko: there's nothing wrong with your installed packages, it's just that old .hi files in that project refer to old packages
06:59:28 <Choko> great!
06:59:43 <bobzhangthu> ? I did not know why, I just used the library hmatrix. sorry to paste so many lines
06:59:44 <ManateeLazyCat> bobzhangthu: Yes, same problem, search "Woes on MacOS 10.6 - linking issues" with gtk2hs list.
07:01:55 <ManateeLazyCat> bobzhangthu: http://sourceforge.net/mailarchive/forum.php?thread_name=FCEB0AA7-E8CD-434E-B5C3-1F31DAEC223E%40in.tum.de&forum_name=gtk2hs-users
07:07:07 <ManateeLazyCat> EnglishGent: Bye, i need off now, good to see! :)
07:07:21 <ManateeLazyCat> you...
07:07:28 <EnglishGent> ok - ttyl ManateeLazyCat  :)
07:12:40 * hackagebot markov 0.1 - Simple interpreter for Markov's normal algorithms  http://hackage.haskell.org/package/markov-0.1 (IlyaPortnov)
07:12:42 <HugoDaniel> is there any way to avoid this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26159#a26159
07:12:43 <HugoDaniel> ?
07:12:45 <HugoDaniel> :(
07:14:50 <aristid> HugoDaniel: avoid what?
07:15:13 <HugoDaniel> the comment
07:15:14 <HugoDaniel> :P
07:15:43 <aristid> explain
07:15:51 <HugoDaniel> ok, ill repaste
07:15:54 <HugoDaniel> maybe it will be obvious
07:17:17 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26160#a26160
07:17:18 <HugoDaniel> this :P
07:20:14 <quicksilver> HugoDaniel: data FormField = FormField CommonAttributes FormDetail
07:20:30 <quicksilver> data FormDetail = LineText Size | ParagraphText Size
07:21:31 <HugoDaniel> quicksilver
07:21:41 <HugoDaniel> sorry, i did not explain correctly
07:21:55 <HugoDaniel> yes, i could do that, it would be the same
07:22:03 <HugoDaniel> whenever i have a case i would have to write them all by hand
07:22:32 <HugoDaniel> ill change it, but it won't solve what i was trying to get done :/
07:23:54 <HugoDaniel> a case or pattern match or whatever else
07:25:28 <dafis> HugoDaniel, named field syntax? data FormField = LineText { getCommonAttributes :: CommonAttributes, size :: Size } | ParaGraphText { getCommonAttributes :: CommonAttributes, size :: Size }
07:25:44 <HugoDaniel> that would break, right ?
07:25:47 <djahandarie> Man I wish I could draw sweet pictures like BONUS 
07:25:49 <HugoDaniel> two functions "size" declared
07:26:15 <dafis> HugoDaniel, both have the same type, hence it works
07:26:27 <HugoDaniel> ok
07:26:33 <HugoDaniel> im going for it then
07:26:44 <HugoDaniel> hmm
07:26:46 <HugoDaniel> but anyway
07:26:50 <HugoDaniel> if i want to add another field
07:26:54 <HugoDaniel> that has other properties
07:26:57 <HugoDaniel> it would break
07:27:09 <dafis> Then for setCommonAttributes ff ca, you just write ff{getCommonAttributes=ca}
07:27:29 <HugoDaniel> thats not my problem
07:27:39 <dafis> Thus it would be better to name the field just commonAttributes instead of getCommonAttributes
07:27:59 <HugoDaniel> what if i have FormField = LineText Size | MultipleChoice [Stuff] | ...
07:28:20 <HugoDaniel> i would have to write them all in all my code spots that pattern matches with that type :/
07:28:31 <dafis> HugoDaniel, if you add a field of the same type to both constructors, you can give it the same name in both
07:29:14 <HugoDaniel> hmm
07:29:24 <dafis> the fields in different constructors just need to have the same type if you give them the same name
07:29:30 <HugoDaniel> yes ok
07:29:38 <HugoDaniel> what if i call size when there is none ?
07:30:00 <dafis> pattern match failure
07:30:03 <HugoDaniel> :P
07:30:05 <HugoDaniel> precisely
07:30:19 <HugoDaniel> thats why i need to function (LineText blah) ...
07:30:32 <HugoDaniel> oh well
07:30:42 <wlangstroth> what about record syntax?
07:30:51 <dafis> HugoDaniel, so far, both your constructors have the same fields
07:30:55 <alexyk> anybody has any ideas on speeding up my twitter mining, http://github.com/alexy/husky/blob/master/SocRun.hs?
07:30:57 <HugoDaniel> yes, but they won't
07:31:03 <HugoDaniel> thats because im testing other stuff right now
07:31:19 <HugoDaniel> i could write quite complex constructors
07:31:33 <dafis> alexyk, yes, I'll send you a strictified version of SocRun.hs in a few minutes, maybe that'll help
07:31:35 <HugoDaniel> im even planing to add recursion there :/
07:31:55 <quicksilver> HugoDaniel: you are wrong; with my solution it would not be the same.
07:32:06 <quicksilver> my solution did reduce the amount of boilerplate.
07:32:10 <HugoDaniel> yes, indeed
07:32:13 <alexyk> dafis: are you serious?  that would be awesome!
07:32:16 <HugoDaniel> i have just rewritten my code quicksilver
07:32:19 <dafis> HugoDaniel, for the common fields, the record syntax is still quite convenient
07:32:36 <HugoDaniel> but still the pattern matching in the other functions would break
07:32:38 <HugoDaniel> which is my problem
07:32:39 <dafis> alexyk, it might not change anything, have to see
07:32:51 <HugoDaniel> i didn't paste them
07:32:56 <alexyk> surely
07:33:42 <HugoDaniel> ill just keep the comment with that list of functions to update, and make sure i dont forget to read it whenever i add a new constructor
07:33:49 <dafis> HugoDaniel, the pattern matching would only break if you don't include cases for the other constructors
07:34:11 <quicksilver> HugoDaniel: well there really isn't any great need for a comment
07:34:16 <quicksilver> HugoDaniel: teh compiler will tell you if you miss something
07:34:21 <HugoDaniel> dafis: thats my point... i have to keep a list of functions where i do pattern match on that data type, in a comment!!
07:34:50 <quicksilver> with my solution you would only need to change functions which match on FormDetail
07:34:57 <quicksilver> ones which don't use FormDetail would still work fine.
07:35:22 <HugoDaniel> quicksilver: then ill just make sure i don't add a '_' in the pattern match (which i tend to do in the cases)
07:35:37 <HugoDaniel> specially because im often using Maybe as the return type 
07:35:54 <HugoDaniel> Maybe works well with '_' on the matching (i just return Nothing there)
07:35:58 <HugoDaniel> and *boom* it blows :/
07:36:37 <HugoDaniel> ill be returning Nothing because i missed to include the constructor on the case match
07:36:53 <HugoDaniel> i dont know
07:36:55 <HugoDaniel> whatever
07:36:57 <HugoDaniel> ok
07:36:58 <HugoDaniel> thanks
07:38:33 <dafis> alexyk, sent
07:39:12 <HugoDaniel> newfield = field{attributes = (attributes field){id = newname} }   nobody told me it would be preaty :)
07:39:15 <alexyk> got it, superthanks!  will try
07:41:26 <quicksilver> HugoDaniel: fclabels/data.accessor/other favour lens package
07:41:41 <HugoDaniel> what do you recommend quicksilver ?
07:42:47 <quicksilver> I've not used any of the above, I have a half-baked one of my own
07:42:53 <quicksilver> fclabels seems to get some support these days.
07:47:43 <HugoDaniel> allright, thanks :)
07:51:45 <HugoDaniel> template haskell always seems so sluggish
07:55:22 <Choko> dcoutts: thanks it was some compiled file which was the issue :)
07:58:26 <Reygun> bye guys! see you tomorrow
07:59:24 * ManateeLazyCat Damn, GFW filter http://www.google.com/reader/atom/feed/ , my Google-Reader Client need integrate with GFW tools, otherwise i can't access http://www.google.com/reader ... fuck GFW.
07:59:55 <HugoDaniel> ambiguous module name `Control.Monad.Trans' :)
08:00:03 <HugoDaniel> fclabels doesn't cope with happstack
08:00:54 <HugoDaniel> it uses the monads-fd-0.1.0.1 and happstack uses mtl
08:01:01 <HugoDaniel> hmmf :(
08:01:49 <dafis> HugoDaniel, dirty fix: edit one of the .cabal files so that both use the same monad transformer lib
08:02:06 <ToRA> HugoDaniel: my usual trick there is just ghc-pkg hide monads-fd after installing fclabels
08:03:42 <ToRA> straw poll, what's the opinion on uploading an existing package to hackage with a similar name, but different dependencies? (e.g. making an fclabels-mtl)
08:03:44 <HugoDaniel> ah, thanks :) let me try them out
08:04:19 <ToRA> HugoDaniel: though I think with that approach you won't be able to use the monad related stuff in fclabels (modM etc.)
08:04:43 <quicksilver> ToRA: which presumably only works if you don't actually use any of the fclabels MonadState stuff
08:04:56 <quicksilver> ToRA: otherwise it would complain that MonadState != MonadState
08:05:09 <ToRA> quicksilver: nod
08:06:05 <ToRA> 2bh, I really don't like fclabels notion of modM, I'd expect it to be of the form modM :: (a :-> b) -> (b -> m b) -> a -> m a
08:06:21 <ToRA> not the monadstate implicit updater form
08:10:13 <quicksilver> well, a monadstate hook is useful if you're a heavy monadstate user
08:10:23 <quicksilver> but it's not exactly hard to write yourself if you want it.
08:10:36 * ManateeLazyCat http://www.google.com/reader/atom/feed/ + YourRssUrl + ?n= + TheNumberYouWantRead
08:12:36 <quicksilver> ToRA: in a few caes, you want an entirely monadic notion of Lens
08:13:12 <quicksilver> ToRA: data MLens m f = MLens { get :: m f, set :: f -> m () }
08:13:29 <quicksilver> ToRA: for example, if you want to bring IORefs "in" to your system.
08:13:34 <ToRA> ooh
08:13:47 <quicksilver> ToRA: you can then compose these with ordinary functional lenses but only on one side
08:13:55 <quicksilver> (and always producing an MLens not a plain one, obviously)
08:14:00 <ToRA> I've actually been having thoughts very loosly along those lines recently
08:14:16 <quicksilver> my half-baked half-written lens thing had this.
08:14:25 <HugoDaniel> so, fc label is the shiznit
08:14:33 <zygoloid> preflex: seen mmorrow
08:14:33 <preflex>  mmorrow was last seen on #ghc 147 days, 12 hours, 16 minutes and 49 seconds ago, saying: * mmorrow is rtfm'ing
08:14:59 <alexyk> dafis: definitely goes with less RAM for now.  I wonder, does ! in a type definition makes it strict too?  Perhaps I should also bangify the main graoh type: http://github.com/alexy/husky/blob/master/Graph.hs
08:14:59 <HugoDaniel> i am wondering if hiding the Prelude (.) and importing Control.Category does not break all the places where i already use this operator
08:15:16 <ToRA> I could see some use for that kind of MLens stuff in a pet gl/game library project thing I'm working on
08:15:49 <ToRA> quicksilver: got anything published/blogged on it or should I just work it through with pen&paper till it drops out?
08:16:07 <quicksilver> ToRA: I've not even thought about it carefully. It just seemed obvious, and it worked as far as I took it :)
08:16:14 <ToRA> heh ok
08:16:32 <quicksilver> I had it pasted on the old hpaste, but we lost that
08:16:39 <quicksilver> I think it's on the new hpaste but google doesn't index the new one
08:16:47 <ToRA> nw
08:17:00 <ToRA> it'll probably be more fun to try and derive my own thing
08:17:02 <quicksilver> ToRA: oh, here you are : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1058
08:17:03 <dafis> alexyk, Yes, a bang on a Constructor field makes it strict, too. In Graph.hs, there's nothing to be banged
08:17:05 <ToRA> ah cool
08:17:24 <dafis> alexyk, what about the speed?
08:17:28 <quicksilver> there's nothing there which isn't obvious
08:17:46 <quicksilver> that's weird. It has exactly the same paste ID!?!?
08:17:56 <quicksilver> did someone manage to save moonpatio's database and import it? How did that happen?
08:18:07 <quicksilver> who runs hpaste now, in fact?
08:18:11 <alexyk> dafis: seems a bit better, it's at day 11 now.  It used to choke at day 20 trying to write it out
08:18:37 <alexyk> I've added a day limiting parameter, we'll see shortly
08:18:54 <dafis> alexyk, keep me informed
08:18:54 <zygoloid> what's happened to mmorrow?
08:19:04 <c_wraith> I think the manual ate him
08:19:11 <c_wraith> preflex: seen mmorrow
08:19:11 <preflex>  mmorrow was last seen on #ghc 147 days, 12 hours, 21 minutes and 27 seconds ago, saying: * mmorrow is rtfm'ing
08:19:19 <zygoloid> must be one big manual
08:20:16 <c_wraith> all told, he dropped out of contact with everyone.  Kind of worrying.
08:20:24 <zygoloid> surely he's not lost interest in haskell?
08:21:48 <jmcarthur> woah
08:21:59 <jmcarthur> has it really been that long?
08:22:15 * hackagebot zcache 0.0.0 - Zobrist keys for game state tracking  http://hackage.haskell.org/package/zcache-0.0.0 (SamAnklesaria)
08:22:18 <roconnor> mmorrow read the manual and found out that Haskell has no formal semantics :(
08:22:32 <roconnor> he must have been so disappointed he moved to sml
08:23:19 <geheimdienst> ... until he discovers sml's formal semantics are not specified with formal semantics ...
08:23:44 <zygoloid> maybe he's been working on getting vacuum to work with every known version of ghc
08:23:47 <roconnor> geheimdienst: :O
08:23:55 <zygoloid> if so i guess we'll not see him for a few more years
08:24:34 <geheimdienst> (hidden reference to the brief mostly wrong history of programming ...)
08:32:00 <alexyk> dafis: ghc 6.10.4 dies with "sc: internal error: allocGroup: free list corrupted"; yesterday it was a "strange closure"...  I guess I need to upgrade to 6.12.
08:32:28 <alexyk> it went more slowly, probably doing more evaluation, with memory increasing slower
08:33:42 <jmcarthur> i've gotten the "strange closure" with 6.12 once, but i don't remember how
08:34:23 <dafis> alexyk, hmm, the internal error may be a one time thing, might try again, perhaps after recompiling
08:34:47 <lispy> good morning #haskell
08:35:52 <djahandarie> Mornin
08:36:16 <dafis> alexyk, if it's going more slowly, I've probably put too much strictness in, I would need to follow the code more closely to know where, maybe I'll find the time today or tomorrow
08:36:54 <alexyk> cool, I'll comment it better
08:43:52 <Accidus> A strong monad over C is a monad over C in the 2-category of locally C-indexed categories. Does anyone know a place where I can find this proof?
08:44:18 <Accidus> In particular, where the strength comes from.
08:44:52 <geheimdienst> i'm guessing it comes from monad gym
08:44:59 <Accidus> :)
08:45:45 <BMeph> Maybe it's monad genetics! ;镁
08:46:24 <fasta> Accidus, presumably in the place where that statement is being made. 
08:46:39 <fasta> Accidus, otherwise, shoot the author at sight, please.
08:46:45 <Accidus> It's made in a paper by Moggi.
08:46:55 <Accidus> Without the proof :P
08:47:31 <fasta> Accidus, isn't it a definition, btw?
08:47:50 <c_wraith> monad steroids?
08:47:54 <Accidus> fasta, what do you mean?
08:48:06 <Accidus> fasta, that a strong monad is a monad in the 2-category , etc.?
08:48:11 <fasta> Accidus, a strong monad over C is defined to be ....
08:48:32 <fasta> Accidus, that would require no proof, obviously.
08:48:41 <Accidus> fasta, I guess you could, but at some point you'd want to prove the equivalence between formulating it as a 2-categorical concept and as a (usual) monad with a strength
08:48:49 <Accidus> And it's that proof I'm interested in
08:48:58 <Accidus> I want to see where the strength comes from
08:49:30 <fasta> Accidus, you can better try the Haskell Cafe. For me it has been some time that I read a theoretical monad paper.
08:50:14 <Accidus> Hmm... If I ask a mailing list, I might as well ask on the categories mailing list
08:50:50 <gwern> didn't know we had one
08:53:17 <Accidus> gwern, "we"? as in human kind?
08:54:49 <gwern> we as in the haskell community
08:55:25 <Accidus> gwern, it's not just the haskell's mailing list
08:55:33 <Accidus> gwern, there's a general mailing list for category theory
08:55:50 <fasta> Accidus, how many subscribers does it have? 
08:56:16 <Accidus> fasta, dunno. The ones that count, I guess (Lawvere, Joyal, etc.)
08:56:35 <dolio> What's a locally C-indexed category?
08:57:28 <Accidus> dolio, roughly speaking, morphisms are associated with objects. So for each object A of C, there is a collection of morphisms: X --A--> Y
08:57:39 <Accidus> And you can compose arrows with the same label
08:58:14 <Accidus> And also, if you have a map: A --f--> B in C, then you can move arrows X -- B --> Y to arrows X --A-->Y
09:01:10 <dolio> So, which Cs in your statement above correspond to categories, and which correspond to an object in the category?
09:01:24 <Accidus> All of the Cs correspond to categories
09:01:33 <Accidus> A,B's correspond to objects in C
09:02:05 <dolio> No, I mean, "A strong monad over C is a monad over C in the 2-category of locally C-indexed categories."
09:02:18 <dolio> Or is the category locally indexed by itself?
09:02:26 <Accidus> C is the category
09:02:41 <Accidus> A strong monad is an endofunctor from C to C
09:03:11 <Accidus> With natural transformations from I to T and from T^2 to T, where T is the monad
09:03:17 * BMeph wonders what a strong bad monad entails...
09:03:18 <dolio> I know what a monad is.
09:03:30 <Accidus> So over the 2-category of locally C-indexed categories
09:03:58 <Accidus> A monad is a (locally C-indexed) endofunctor T from C (considered as a C-indexed category) to C
09:04:35 <Accidus> With "natural transformations" from I to T and from T^2 to T
09:04:55 <Accidus> Oh, and C has to have finite-products
09:06:08 <Accidus> Well, actually, I'm a bit off here.
09:06:45 <gwern> don't feel bad. 'out of the crooked timber of humanity no straight thing was ever made'
09:07:12 <Accidus> The endofunctor is not from C considered as C-indexed
09:07:39 <Accidus> But from "self C", in which the arrows for an object A are the maps C(AxX,Y)
09:08:20 <Accidus> Oh well, I might as well start to instantiate all the definition until I get the strength
09:08:44 <Accidus> It's a shame there are no tutorials/proofs in sight though (which was my original question)
09:08:51 <c_wraith> BMeph: typing with boxing gloves on
09:13:29 <dolio> Accidus: Looking at it, it's probably fairly straight forward.
09:14:09 <dolio> Presumably a monad in that 2-category has an extra component telling you where it takes the index.
09:14:36 <dolio> So if f : A --X-> B, then Tf : TA --TX-> TB.
09:15:15 <Accidus> No... The object on the arrow should be X
09:15:31 <Accidus> (on the right arrow)
09:15:53 <dolio> Oh.
09:16:06 <dolio> Yeah, I guess that makes more sense.
09:16:42 <dolio> Since strength is X x TA -> T (X x A) isn't it?
09:19:00 <dolio> That makes Tf : X x TA -> TB in self C.
09:19:04 <Accidus> Not really. So that's a morphism from TA to T(XxA)
09:19:22 <Accidus> That is, TA --X-->T(XxA)
09:21:37 <dolio> There's an A --X--> X x A for all A and X, though. The identity for X x A in C.
09:22:48 <dolio> Applying T gets you TA --X--> T (X x A), which is X x TA -> T (X x A).
09:22:56 <Accidus> Aye, I can see that.
09:23:06 <Accidus> So then the various coherence conditions become..
09:23:08 <dolio> Then you just have to prove that it satisfies whatever conditions strength should.
09:24:49 <Accidus> Aye, I see.
09:26:22 <Accidus> So now I need to see how do I know which properties to choose
09:26:24 <cwb> I'm looking at the docs for Data.Time.Calendar.Day and it says it has both Show and Read instances. Two problems: 1. ghci claims there is no Read Day instance 2. Where can I find the definition of instances?
09:27:49 <c_wraith> cwb: are you looking at the docs for the same version you're using?
09:28:44 <cwb> c_wraith: Not quite. I'm using 6.12.1 and the docs are for 6.12.2. Let me check..
09:28:53 <Accidus> Thanks dolio 
09:29:16 <cwb> c_wraith: Docs for 6.12.1 still claims Day has a Read instance..
09:30:30 <c_wraith> are you using time or old-time?
09:31:22 <cwb> importing Data.Time.Calendar loads old-locale-1.0.0.2 and time-1.1.4
09:31:49 <c_wraith> Yeah, it has to be time..
09:31:58 <Gracenotes> also the Data.Time prefix
09:31:59 <mux> I confirm that there is no Read instance, and also, which seems weird, there is a Show instance but it's defined in Data.Time.Calendar.Gregorian
09:32:07 <mux> on the other hand, Day is just a newtype of Integer
09:32:28 <c_wraith> 1.1.4 is quite old.
09:32:40 <mux> (6.12.3rc1 here)
09:32:43 <c_wraith> the current version of time is 1.2.0.2
09:33:03 <c_wraith> but even 1.1.4 is documented as having a Read instance for Day
09:33:30 <cwb> What's the best way to upgrade? (My installation is the Haskell Platform for Mac OS X.)
09:33:47 <mux> 1.2.0.2 doesn't seem to contain such instances either
09:34:05 <c_wraith> cwb: I don't think upgrading will help
09:34:11 <mux> there is a Show one that is commented out in Data.Time.Calendar.Days
09:35:05 <c_wraith> Eh.  You might be best off pretending there isn't a Read instance
09:35:11 <cwb> The show instance works fine for me (displaying yyyy-mm-dd format) and I was hoping read would do the reverse so read $ show d :: Day == d
09:35:41 <cwb> I can write one myself I presume.
09:35:50 <mux> or use parseTime
09:35:53 <BMeph> cwb: Is it Read, or Real -- "Read" carefully... ;)
09:35:57 <c_wraith> I wouldn't.  I'd just parse it manually
09:36:18 <mux> or readTime
09:36:27 <mux> both of which are found in Data.Time.Format
09:36:31 <c_wraith> read is kind of a hack, anyway.  I ignore it, almost all the time.
09:36:36 <cwb> BMeph: It's Read.. :)
09:36:45 <mux> yeah, read is good for debugging mostly :-P
09:36:53 <Gracenotes> usually you don't want generic Read, you want Read for a specific type
09:37:08 <Gracenotes> same with Num - mostly
09:37:27 <Gracenotes> so don't feel bad about making your own readesque function..
09:37:41 <Gracenotes> plus, orphan instances bad, etc.
09:37:54 <cwb> Ah, I didn't realise that... But don't you get type-specific reads by specifying the instance of read using ::.. ?
09:38:25 <Gracenotes> or by having the type inferred with the read call
09:39:37 <cwb> Many thanks for the help! I'll go give readTime a try.
09:39:54 * hackagebot orc 1.1.1.0 - Orchestration-style co-ordination EDSL  http://hackage.haskell.org/package/orc-1.1.1.0 (TrevorElliott)
09:40:25 <Gracenotes> it is nice for basic composable serialization though
09:52:49 <Apocalisp> What do you call a category whose only morphisms are endomorphisms?
09:53:11 <c_wraith> closed?
09:53:37 <zygoloid> Apocalisp: boring? :)
09:53:40 <Apocalisp> A monoid?
09:53:44 <Accidus> Some kind of discrete category
09:53:56 <Apocalisp> Or does Monoid only apply to the category of Sets?
09:53:57 <Accidus> Hmm... Ah! An index monoid
09:53:59 <zygoloid> Apocalisp: if it only has one object, it's a monoid
09:54:00 <Accidus> * indexed
09:54:34 <Apocalisp> Yeah, I think I mean it has only one object.
09:54:45 <Accidus> Blachs. Let me say that again: Apocalisp, it's called an indexed monoid
09:54:59 <Apocalisp> Accidus: OK, thanks.
09:55:08 <Accidus> So you have a class of labels, Ob C, and for each label A, you have a monoid Hom(A, A)
09:55:43 <jmcarthur> so this is a category where the only morphisms are identities?
09:55:49 <Accidus> No
09:55:58 <Apocalisp> Accidus: Yeah, that sounds right. So Hom(A,A) is a monoid no matter which category C is?
09:56:00 <Accidus> jmcarthur, That would be the discrete category
09:56:13 <jmcarthur> i need to learn my category theory
09:56:17 <Accidus> Apocalisp, aye, because you had a unit (id_A) and multiplication (composition)
09:56:27 <djahandarie> learnyousomecategorytheory.com
09:56:32 <Apocalisp> Accidus: You say true.
09:56:37 <Apocalisp> Thanks a bunch
09:56:37 <jmcarthur> djahandarie: i wish!
09:57:59 <Saizan> @type Endo
09:58:00 <lambdabot> forall a. (a -> a) -> Endo a
10:17:41 <alexyk> Data.Trie has no fold, is one supposed toListBy first?
10:20:23 <dons> heya alexyk 
10:20:31 <alexyk> hey dons!
10:20:32 <dons> alexyk: in general, you should avoid toList functions
10:20:41 <dons> but first I'd use Data.Map with insertWith' 
10:21:07 <dons> its an interesting property that no amount of external `seq` can ensure strict updates to Data.Map. you have to use insertWith'
10:21:17 <alexyk> aha
10:21:20 <dons> also, in general for your problem, is there a small data set that exhibits the problem, that you could provide?
10:21:31 <dons> people will probably dive in and do some work for you if it is easy to run :)
10:21:54 <alexyk> I really have big ones, 5-6 GB in Clojure at least; Haskell swells to 20 GB quickly allocating them and around
10:22:29 <dons> that's probably due to lazy updatess in Data.Map. did you try heap profiling to see what is allocating?
10:22:30 <alexyk> dons: I've asked Twitter for the full graphs, but I should be able to cook smaller ones soon
10:22:52 <alexyk> yeah, will do heap profiling too
10:22:58 <dons> sometimes squashing little laziness like this can yield 10-fold speedups and reductions in space, so it is a good idea to do some profiling.
10:23:31 <alexyk> at first it just crawled, and then -A10G made it fly when loading, so even though it was allocating a lot, it was OK :)
10:23:48 <alexyk> loading already beat Clojure as is, but walking chokes
10:24:13 <alexyk> I'll profile more and switch to insertWith' indeed
10:24:22 <dons> i would put good money that ghc will be a lot faster, once you do some profiling to see what is allocating :)
10:24:34 <dons> all those optimizations and profiling tools over 20 years make a difference :)
10:24:51 <dons> alexyk: so do you know how to get started profiling? it is very easy
10:24:58 <dons> compile with: -prof -auto-all
10:25:03 <dons> run with +RTS -p
10:25:10 <dons> and then look in foo.prof file afterwards
10:25:20 <dons> which will list each functoin by how much time and space it is taking
10:25:24 <alexyk> yeah, that was my reason to try it, finally.  Yep, I did that: http://github.com/alexy/husky/blob/master/sc10days.prof
10:25:37 <andrewsw> while on that subject, can you point to some good profiling tutorials? 
10:25:41 <dons> socDay                         SocRun                33.3   39.4 
10:25:50 <dons> andrewsw: RHW chapter on profiling
10:25:54 <andrewsw> d'oh
10:25:56 <andrewsw> heh
10:26:00 <alexyk> nothing sort of startling there, since I load huge graphs and then walk them fully, each iteration
10:26:27 <alexyk> socDay is each day's simulation; socRun walks Twitter day by day
10:26:40 <dons> is  that with -auto-all turned on?
10:26:45 <alexyk> yep
10:26:48 <dons> cool.
10:27:00 <dons> ok. then i'd do heap profiling to get      the graph of the heap by type and by 'retainer'
10:27:11 <dons> that tells you who is holding on to memory, and what  type of data is allocated the most
10:27:37 <dons> that's the -hy and -hr flags to +RTS (check the Real World Haskell section)
10:27:47 <dons> but first, move over to inserting with insertWith'
10:28:15 <alexyk> ok! sounds like a plan.  :)
10:32:34 <mreh> how come nobody has written netpbm library
10:32:48 <jmcarthur> nobody needed it yet?
10:33:06 <mreh> it's your bread a butter
10:33:19 <mreh> you can have mine when I've finished it
10:37:53 <lispy> mreh: what is netpbm? :)
10:38:20 <mreh> a simple image format, wastes masses of space but it's useful
10:38:29 <lispy> I see...
10:38:36 <lispy> Why is it so useful?
10:38:39 <Ke> easy to write from fortran/matlab
10:38:41 <mreh> it's easy to write a library for
10:38:42 <lispy> (what are you uses, etc)
10:39:06 <lispy> I guess that makes sense
10:41:52 <BMeph> Is the Caleskell defn of flip something CT-ish? It looks like the (function) inverse of costrength, but my CT-fu, he is weak... :)
10:43:13 <kmc> netpbm is easy to generate from any language (try shell script)
10:43:28 <kmc> and it's a good intermediate format for streaming images between different filters
10:43:32 <Saizan> ?ty flip
10:43:33 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:45:23 <Saizan> doesn't costrength involve Either?
10:46:07 <mtnviewmark> ?ty Prelude.flip
10:46:08 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
10:46:47 <mreh> I don't even think you could call it an image format
10:47:08 <mreh> apart from the header
10:47:19 <mreh> and the interpretation of the bytes
10:47:43 <kmc> yeah
10:48:31 <mreh> I hope that made no sense whatsoever
10:48:34 <aristid> :t flip id
10:48:35 <kmc> correct
10:48:35 <lambdabot> forall a b. a -> (a -> b) -> b
10:48:45 <Saizan> "you can't call it a binary format" might be more sensical
10:49:03 <kmc> there are ASCII and binary flavors of each of the netpbm formats
10:49:52 <mreh> I don't even know why the ASCII was included
10:50:20 <lispy> oh interesting, in Haskell flip takes a function and returns one and the types are very semetric.  In Caleskell, it's much harder to see that from the type.
10:50:29 <lispy> a -> f b, is sort of unclear
10:50:48 <magicman> ?type (.)
10:50:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:51:01 <aristid> :t flip
10:51:02 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:51:53 <aristid> @src flip
10:51:53 <lambdabot> flip f x y = f y x
10:52:03 <aristid> what's the caleskell source of flip?
10:52:19 <magicman> \f a -> fmap ($a) f, I think?
10:53:16 <magicman> ?type \f a -> fmap ($a) f
10:53:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
10:53:17 <bos> sightings of the new GHC event manager in the wild: http://bit.ly/aI33oa
10:54:38 <sinelaw> someone quickly recommend a book
10:54:47 <sinelaw> to buy on amazon if i'm already ordering something
10:54:52 <sinelaw> quick!
10:54:56 <aristid> sinelaw: real world haskell
10:55:01 <sinelaw> ah! great
10:55:02 <sinelaw> :)
10:55:18 <sinelaw> aristid, how did i not think of that
10:55:37 <aristid> sinelaw: because you trust #haskell so much.
10:55:38 <sinelaw> oy expensive
10:56:19 <aristid> try "Purely Functional Data Structures", it's cheaper here
10:56:26 <sinelaw> hmm
10:56:52 <sinelaw> more expensive
10:57:04 <aristid> heh, funny
10:57:08 <aristid> it's cheaper here
10:57:17 <sinelaw> where's here
10:57:18 <gwern> the art of programming languages by pierce, then?
10:57:22 <aristid> sinelaw: amazon.de
10:57:26 <sinelaw> ah
10:57:35 <sinelaw> gwern, hmm how is that?
10:57:42 <gwern> abstract
10:58:01 <sinelaw> useful? i mean, is it stuff that's important to know?
10:58:16 <sproingie> i thought pierce's TAPL was Types And Programming Languages?
10:58:31 <gwern> was it? then I did get it confused with knuth
10:58:34 <sinelaw> heh
10:58:35 <sproingie> yah
10:58:57 <gwern> sinelaw: well, it certainly would put you in an excellent position to understand all the various uses of types in haskell
10:59:58 <kmc> and beyond
11:00:08 <kmc> TaPL is excellent
11:00:17 <aristid> hmm it seems like i mostly buy expensive books
11:00:40 <gwern> life is short. why buy crap?
11:00:45 <Saizan> TAPL spends a lot of time on subtyping and how to represent object systems in pure lambda calculus, though the later chapters have System F_omega and friends
11:01:13 <sinelaw> Saizan, do you have recommendations?
11:01:18 <sinelaw> what's domain theory btw?
11:01:41 <gwern> but then, I'm biased since I wrote a whole essay on how we have too much media and we need to end all subsidies such as intellectual property
11:02:13 <gwern> (as any subsidies are both economically and esthetically inefficient)
11:02:17 <sinelaw> IP _is_ bad in it's current incarnation
11:02:31 <sinelaw> hinders progress in many cases
11:02:33 <sinelaw> but not all, btw
11:03:03 <Saizan> sinelaw: domain theory is what's used in e.g. the denotational semantics of haskell, with the definedness partial order (the one where _|_ comes from) and relative continuity conditions on functions
11:03:52 <sinelaw> TaPL is $36 here
11:03:54 <sinelaw> there
11:03:55 <sinelaw> whatever
11:04:24 <sinelaw> but knowledge is priceless
11:05:09 <Saizan> (afaiu btw, i've never studied any of this rigorously)
11:05:29 <gwern> sinelaw: 36$ is pretty reasonable
11:06:17 <Saizan> (which is also why i don't have book recommendations :)
11:08:25 <sinelaw> ok, TaPL it is.
11:14:58 <BMeph> @type \f a -> f <*> pure a
11:14:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
11:15:05 <BMeph> @type flip
11:15:06 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:15:29 <Veinor> :o
11:15:32 <BMeph> Sneaky...
11:16:05 * ManateeLazyCat pasted "PageMode code." at http://paste2.org/get/877627
11:16:06 <ManateeLazyCat> I have above code, all field in PageMode is static, except "pageModeHook", it's dynamic, i want inject some code at runtime. And i want share PageMode between different OS-processes, one process update "pageModeHook", other processes can also read newest status from "pageModeHook". I can't transfer PageMode between processes (too costly), so how to define "defaultMode" ? I also don't want use unsafePerformIO. 
11:16:30 * BMeph wonders how one can justify having a function that uses "f (a -> b)" only depend on a Functor quality...
11:17:13 <zygoloid> @type (\a -> a >>= (return $!))
11:17:14 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m a
11:17:16 <zygoloid> ^^ is there a name for that?
11:17:34 <ManateeLazyCat> One solution is use unsafePerformIO define "pageModeHook" in PageMode, but i wonder have other neat solution?
11:17:36 <zygoloid> (and is there any way to implement it for Functors?)
11:17:56 <mauke> :t evaluate
11:17:57 <lambdabot> Not in scope: `evaluate'
11:19:35 <ManateeLazyCat> Example, i when open .hs file, page will load HaskellMode, then any haskell tools (such as hlint) will add it's result in "pageModeHook" of haskellMode.
11:21:14 <ManateeLazyCat> All PageMode's properties is static (except pageModeHook) is define by library author, and user can add any actoin in "pageModeHook" for extend library
11:22:32 * ManateeLazyCat pasted "Hook code." at http://paste2.org/get/877638
11:22:52 <ManateeLazyCat> Above is Hook funtions.
11:23:42 <ManateeLazyCat> One solution i can think is use "unsafePerformIO $ hookNew" (hookNew :: IO Hook) to create "pageModeHook" when PageMode create.
11:24:19 <ManateeLazyCat> Then i can read/write Hook of PageMode in different processes.
11:25:37 <djahandarie> New IO manager looks very nice so far
11:25:56 <ManateeLazyCat> djahandarie: Example?
11:26:13 <djahandarie> ManateeLazyCat, no example yet, but there is a fairly easy-to-read paper 14:49 - paper_cc1 [~paper_cc@217.10.38.198] has quit [Client Quit]
11:26:16 <djahandarie> Gah
11:26:20 <djahandarie> http://www.serpentine.com/bos/files/ghc-event-manager.pdf
11:26:42 <ManateeLazyCat> For my case, "unsafePerformIO $ hookNew" is ugly? I can't think other way.
11:27:12 <djahandarie> I wasn't responding to you btw, just making a random comment
11:31:34 <djahandarie> Ah cool, the black hole mechanism in GHC was upgraded as a result of this too
11:31:42 <ManateeLazyCat> Simple, my idea is create PageMode as constant, then any processes can access those PageMode, because pageModeHook is TVar type, i can access pageModeHook through constant PageMode, then update pageModeHook status dynamic.
11:32:41 <ManateeLazyCat> djahandarie: Has Haskell googler?
11:33:07 <ManateeLazyCat> djahandarie: I found one author of "ghc-event-manager.pdf" is from Google ....
11:34:06 <djahandarie> Huh?
11:34:27 <ManateeLazyCat> djahandarie: I'm reading "ghc-event-manger.pdf"....
11:34:48 <ManateeLazyCat> djahandarie: I'm wonder googler like Haskell.... :)
11:35:14 <djahandarie> Oh, yeah, Johan is from Google
11:35:23 <djahandarie> I think he's been in this channel before, though I forget what nick
11:36:20 <astrolabe> Is there a C++ parsec parser?
11:36:34 <kmc> ManateeLazyCat, if you're using unsafePerformIO like that, be sure to use a NOINLINE pragma
11:36:58 <djahandarie> astrolabe, you mean a parser combinator for C++?
11:37:04 <ManateeLazyCat> kmc: I try avoid use unsafePerformIO, do you have any better solution?
11:37:06 <astrolabe> djahandarie: yes
11:37:13 <djahandarie> astrolabe, there is Sprint
11:37:14 <kmc> if (unsafePerformIO $ newIORef 0) or the like gets inlined at its call sites, it'd be a clear disaster
11:37:24 <kmc> astrolabe, or did you mean a Parsec parser which parses C++?
11:37:41 <kmc> ManateeLazyCat, i'd have to think about it
11:37:45 <astrolabe> I guess what kmc said.  I want to use parsec to parse C++
11:37:49 <djahandarie> Ah
11:37:51 <kmc> i don't know of such a thing
11:38:01 <kmc> jhc has a neat extension which allows to execute IO actions at the top level
11:38:04 <kmc> i wish ghc had it
11:38:14 <ManateeLazyCat> kmc: Or let multiple processes update TVar is bad idea?
11:38:17 <benmachine> there's a library for parsing C
11:38:22 <benmachine> obv C++ is a somewhat taller order
11:38:26 <djahandarie> astrolabe, there is language-c for C
11:38:29 <astrolabe> Is there any reason the C++ version shouldn't exist, except for hard work?
11:38:30 <kmc> er, the only point of using a TVar would be for multiple threads to use it
11:38:37 <ManateeLazyCat> kmc: I'm afraid ghc's unsafePerformIO will make thing became worse. 
11:38:43 <djahandarie> astrolabe, but that is written in alex and happy anyways, not parsec
11:38:44 <burp> !karma c++
11:38:45 <aristid> benmachine: "somewhat taller" is probably an understatement
11:38:51 <kmc> astrolabe, parsing C++ is exceptionally difficult and requires semantic knowledge of the language
11:39:13 <kmc> since Parsec is much more flexible than traditional parser generators, I assume it's possible
11:39:17 <kmc> but would still be a ton of effort
11:39:27 * djahandarie agrees
11:39:28 <benmachine> aristid: yeah, a little :)
11:39:29 <aristid> the llvm guys are writing a c++ compiler
11:39:49 <astrolabe> kmc: Do you mean that you need to know what classes are already defined?
11:39:49 <aristid> and they're, what, maybe 60% done now after a few years
11:39:58 <ManateeLazyCat> kmc: Well, my program is multi-processes extensionable system, i hope i can build hook to extend library.
11:40:01 <benmachine> astrolabe: well, you might find a fair few Haskellers think C++ shouldn't exist :) but apart from that, no
11:40:20 <aristid> astrolabe: things like name lookup and dependent names are making the thing a bit more complicated
11:40:47 <aristid> astrolabe: let's assume the following simple code: a b;
11:40:54 <astrolabe> I wish even haskell was easier to parse
11:40:55 <aristid> how do you figure out whether that's valid?
11:41:21 <djahandarie> astrolabe, Haskell is a ton easier to parse that C++ for sure
11:41:26 <astrolabe> aristid: I don't know.  I guess look up 'a' in a table to see if it's a class.
11:41:29 <ManateeLazyCat> kmc: In jhc, how it make "IO action at the top level" ? Why you said it's neat? Can you explain simply? 
11:41:35 <benmachine> astrolabe: haskell's not *too* bad although there are some nasty bits like the let/lambda metarules
11:41:48 <aristid> astrolabe: well there's a ton of complexity
11:42:10 <astrolabe> aristid: I can believe it.  C++ seems to just go on and on.
11:42:32 <aristid> it's obviously doable... if you have a few years of time.
11:42:51 <BMeph> djahandarie, ManateeLazyCat Were you mentioning tibbe? :)
11:42:52 <zygoloid> astrolabe: you should use a tool like Dehydra or GCC-XML. in any case, you probably don't /want/ a correct c++ parser, rather you want the one which g++ implements. :)
11:42:55 <ManateeLazyCat> kmc: I just use unsafePerformIO when i just *read* and don't touch it after creation. 
11:43:16 <ManateeLazyCat> kmc: I just use unsafePerformIO when i just *read* and don't touch it after creation. 
11:43:20 <ManateeLazyCat> Sorry, erc bug.
11:43:25 <aristid> zygoloid: llvm is making a c++ parser, which is probably the most promising approach.
11:43:33 <astrolabe> It's a bit depressing.  Why can't all computer languages have simple grammars?
11:43:42 <aristid> http://clang.llvm.org/
11:43:42 <ManateeLazyCat> BMeph: Yes, i'm reading his's paper "Scalable Event Handling for GHC".
11:43:44 <kmc> because 90% of everything is crap
11:43:52 <aristid> astrolabe: well, because people hate parens
11:43:57 <djahandarie> BMeph, Tibell?
11:43:59 <aristid> (see: lisp)
11:44:10 <kmc> also people think that any new language must have "c-like syntax"
11:44:11 <ManateeLazyCat> djahandarie: BMeph said Johan
11:44:26 <kmc> because uninformed people believe that syntax is the hardest part of learning a language
11:44:41 <aristid> kmc: haskell's syntax is not c-like, but probably still more complex than astrolabe would like
11:44:44 <astrolabe> Didn't Philippa and xerox turn parsec into a monad in order to be able to parse haskell?
11:44:45 * hackagebot shoap 0.2 - A very basic SOAP package  http://hackage.haskell.org/package/shoap-0.2 (RichardFergie)
11:44:51 <ManateeLazyCat> kmc: Yep, maybe run "IO action" in different processes is bad idea.
11:44:52 <BMeph> ManateeLazyCat: Who is responsible for making your "real" Hook TVars? :)
11:44:56 <aristid> @remember kmc because uninformed people believe that syntax is the hardest part of learning a language
11:44:56 <lambdabot> Good to know.
11:45:03 <aristid> @quote syntax
11:45:03 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
11:45:04 <lambdabot> true functional programming), and you've got haskell
11:45:10 <aristid> @quote kmc
11:45:10 <lambdabot> kmc says: Right, for example Either (pun not intended)
11:45:13 <aristid> hmm
11:45:21 <aristid> did i use @remember right?
11:45:22 <djahandarie> Haha
11:45:32 <djahandarie> aristid, pretty sure, yes
11:45:37 <djahandarie> @quote because.uninformed
11:45:37 <lambdabot> kmc says: because uninformed people believe that syntax is the hardest part of learning a language
11:45:51 <ManateeLazyCat> BMeph: I'm build a extensionable system (use gtk2hs) like Emacs some way.
11:46:19 <ManateeLazyCat> BMeph: Example, I can write a stand HaskellMode for edit Haskell source code.
11:46:30 <astrolabe> To me the advantage of simple syntax would be that it would be easy to write code analysis/generation tools.
11:46:51 <zygoloid> aristid: well, dehydra works today, and sounds like it would cover astrolabe's use case
11:47:00 <ManateeLazyCat> BMeph: When i export Hook of HaskellMode, any other haskell tools (such as hlint) will add it's result to haskellModeHook
11:47:13 <aristid> astrolabe: what is your use case?
11:47:14 <ManateeLazyCat> BMeph: Then i can build a extensionable system.
11:47:38 <astrolabe> aristid: A bigish complicated program at work that needs refactoring
11:47:40 <aristid> fact: i don't use auto completion when writing c++ code, because the editors never get it right.
11:47:40 <kmc> i can't find the jhc top-level IO thing now
11:47:43 <kmc> i was sure it had it
11:47:47 <ManateeLazyCat> BMeph: And trouble is, my program is not single-process, it's a multi-processes framework like Chrome's
11:48:21 <zygoloid> aristid: sorry, i misread an earlier comment of astrolabe's :)
11:48:23 <aristid> astrolabe: well, maybe you can bank on the fact that the program probably uses only 30% of C++.
11:48:37 <ManateeLazyCat> BMeph: So core (daemon process) is control everything, and editor is running in child process. 
11:48:53 <astrolabe> aristid: That's true
11:48:58 <astrolabe> but does it help?
11:49:00 <ManateeLazyCat> BMeph: So i need share Hook of PageMode information in different processes.
11:50:08 <aristid> astrolabe: there are also expensive refactoring tools for c++
11:50:10 <ManateeLazyCat> aristid: I think dons is told me.
11:50:26 <ManateeLazyCat> aristid: I'm switch from OOP -> Lisp -> Haskell. :)
11:50:54 <astrolabe> aristid: I guess the most important thing for me is to understand the dependencies and remove the unnecessary ones.
11:51:19 <aristid> astrolabe: if you can make such a program, maybe you have a market.
11:51:49 <astrolabe> aristid: :)  I suspect I don't have sufficient time, or maybe ability.
11:52:02 <BMeph> ManateeLazyCat: Whenever I see some complex data type (say, a pair of TVars holding lists of IO actions), and the default is "undefined", and you use it with "unsafePerformIO", I can only imagine a few, incredibly rare times when you will not "pull a C" (i.e., "segmentation fault (core dumped)")...
11:52:32 <aristid> astrolabe: heh maybe you should make a haskell refactoring program instead, which is also sorely needed for some programs
11:53:04 <ManateeLazyCat> BMeph: No, undefined just for compile test now, i won't use it, I try to write "unsafePerformIO $ hookNew" when create "defaultMode"
11:54:13 <ManateeLazyCat> BMeph: Because "hookNew :: IO Hook" will return "IO Hook", so i want use "unsafePerformIO" wrap "hookNew" when define "defaultMode"
11:54:50 <ManateeLazyCat> BMeph: As most haskeller, i don't want to use unsafePerformIO, but i don't know have other way can fix my problem
11:55:07 <aristid> ManateeLazyCat: what about join?
11:55:12 <aristid> :t join
11:55:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:55:40 <aristid> :t join :: IO (IO a) -> IO a
11:55:41 <lambdabot> forall a. IO (IO a) -> IO a
11:56:30 <alexyk> the new degree of Haskell dependency: reading the New Yorker about new graduates "when a student dons a cap and gown...", my parser stalled at dons.
11:56:46 * ManateeLazyCat pasted "Hook model" at http://paste2.org/get/877671
11:56:55 <ManateeLazyCat> Above is all my code model about Hook.
11:58:48 <Gracenotes> oh, I wrote a Hook too recently! except I used IORef...
11:58:49 <ManateeLazyCat> My idea is, let "pageModeHook" is empty when create PageMode. When user use "addHook" add action to Hook, those actions will run before/after "pageModeLoad".
11:58:51 <illissius-> astrolabe: KDevelop4 has pretty solid C++ support, I think it's at release candidate stage or something
11:59:05 <illissius-> also some very basic refactoring tools
11:59:05 <djahandarie> Ooh, I like the title of this paper "Seq no more" heh
11:59:11 <ManateeLazyCat> Gracenotes: IORef is not safe when multi-threaded update status at same time.
11:59:32 <Gracenotes> ManateeLazyCat: everyone's expected to register their hooks at the very beginning
11:59:53 <djahandarie> Lots of coauthors from Heriot-Watt University though
12:00:06 <Gracenotes> oh, you mean, for mutual exclusion while running the hooks?
12:00:14 <ManateeLazyCat> Gracenotes: My problem is Hook, is how to bulid a neat way to share "TVar Hook" in different OS-processes 
12:00:36 <ManateeLazyCat> Gracenotes: I always use TVar/MVar instead ioRef
12:00:54 <Gracenotes> the only problem with those is that they can be empty
12:00:55 <ManateeLazyCat> Gracenotes: In most case, i use TVar.
12:01:12 <alexyk> so can anybody tell me, if I have to quash laziness with bangs and 's to make a large graph work, why should I bother and not go back to OCaml?  (Spoken as a Voldemort's advocate; I love the cabal and hackage and everything.)
12:01:26 <ManateeLazyCat> Gracenotes: So i use TVar always, only use MVar when need some synchronous (such as signal)...
12:01:45 <alexyk> and concurrency I love very much, not to be seen in OCaml until the 2nd French Revolution
12:01:54 <Gracenotes> and it's annoying to check every time for a value inhabiting my vars that I don't want
12:02:14 <alexyk> "a value inhibiting my vars" sounds like a call for Terminix
12:02:19 <ManateeLazyCat> Gracenotes: So use TVar instead IORef.
12:02:55 <ManateeLazyCat> Gracenotes: Use STM, you will got "lock free" concurrent model, and you don't need care empty problem like MVar.
12:03:01 <alexyk> can lazyness be faster if you know you gotta do it all?  e.g., is a deferred computation optimized before it's finally done?
12:03:24 <ManateeLazyCat> Gracenotes: Transform from IORef to STM is easy and natural.
12:03:40 <Gracenotes> is STM included in ghc nowadays?
12:03:47 <illissius-> yes
12:03:53 <ManateeLazyCat> Gracenotes: Yes.
12:03:57 <Gracenotes> in any case, atomicallyModifyIORef is more-than-sufficient..
12:04:12 <Gracenotes> given that concurrent reads are safe anyway
12:04:16 <roconnor> atomicallyModifyIORef++
12:04:18 <dcoutts> alexyk: it's not simply the case that stricter is faster, getting good performance means understanding evaluation order and evaluating things strictly or lazily as appropriate.
12:04:30 * ManateeLazyCat pasted "STM library" at http://paste2.org/get/877679
12:04:35 <ManateeLazyCat> Gracenotes: Above is my STM library
12:04:44 <Gracenotes> *atomicModifyIORef
12:04:48 <ManateeLazyCat> Gracenotes: Hope it will help you if you want do a switch.
12:05:13 <ManateeLazyCat> Gracenotes: I used to use IORef everywhere, i switch to STM now. :)
12:05:17 <Gracenotes> laziness is inefficient. except when it isn't.
12:05:29 <dcoutts> alexyk: if you used a strict language you'd still want to evaluate some things lazily but you'd have to use more heavyweight abstractions like iterators/sequences or you might simply write your program in a less modular way
12:06:01 <alexyk> dcoutts: right.  Scala got a lazy val and Stream, for instance.
12:06:07 <djahandarie> I still don't understand why haskell.org reverted to the old design and old logo...
12:06:15 <djahandarie> Does anyone know?
12:06:34 <eurehot> hello
12:06:35 <jmcarthur> restoration from backups killed the template
12:06:40 <alexyk> and Clojure's seq is lazy which is awesome.  It's almost like Haskell without IO monads and types. :)
12:06:55 <jmcarthur> wait, lazy seq?
12:07:14 <alexyk> jmcarthur: that's Clojure's way to explode Haskellers' heads :)
12:07:17 <eurehot> which book would you recommend me, if i wanna learn to think in haskell mode?
12:07:21 * ManateeLazyCat pasted "The code i use" at http://paste2.org/get/877687
12:07:24 <jmcarthur> alexyk: what's the point of it?
12:07:33 <alexyk> eurehot: realworldhaskell.org FTW
12:07:33 <Gracenotes> djahandarie: http://haskell.org/haskellwiki/?title=MediaWiki:Standard.css <- wasn't backed up, I'm guessing
12:07:40 <eurehot> i was thinking about haskell school of expression but i need some feedback ^^
12:07:42 <Gracenotes> not valid CSS! for shame
12:08:09 <alexyk> jmcarthur: it's basically the meat of it all.  maps and arrays all have seq API, and seqable things are processed lazily.  Dynamism really pays off there.
12:08:24 <dcoutts> alexyk: so there you go, so the point is, for good performance you do need to understand evaluation order. It's not necessary for thinking about the result, but it can be pretty important for performance. Fortunately it's not hard to understand.
12:08:32 <jmcarthur> alexyk: you mean strict by default but use seq for laziness?
12:08:38 <ManateeLazyCat> http://paste2.org/get/877687 is the code i use, i just want to use other way replace unsafePerformIO, please tell me if anyone know how to fix it. Thanks!
12:08:48 <djahandarie> Ugh
12:08:55 <pastorn> eurehot: which languages do you already know?
12:08:57 <Gracenotes> seq is a bit more complicated than just 'force evaluation'...
12:09:12 <jmcarthur> i don't really like seq, personally
12:09:23 <alexyk> jmcarthur: right; and since almost everything is seq, it's kinda awesome.  A typical answer to a bug on #clojure is "map is lazy".  It's baby thunks.
12:09:39 <ManateeLazyCat> Gracenotes: Can you read your Hook implement? Maybe have some cool feature i can study. :)
12:09:43 <jmcarthur> alexyk: i kind of like lazy by default :)
12:09:52 <thoughtpolice> all of clojure's sequence types are lazy by default aren't they?
12:09:56 <jmcarthur> means the compiler is free to play around a lot
12:10:01 <eurehot> pastorn: java mostly, but i do know a bit of python
12:10:17 <thoughtpolice> (i'm not very familiar with clojure so i wouldn't know the exact way to say what I mean :)
12:10:18 <jmcarthur> s/lazy/non-strict/
12:10:26 <alexyk> jmcarthur: well if I do data mining on large in-memory data, it's necessary to quash laziness, apparently; I got some bangs to insert...
12:10:36 <pastorn> eurehot: if you already know some programming then you should get RWH
12:10:51 <alexyk> thoughtpolice: if you use seq API you access them lazily
12:10:59 * hackagebot not-in-base 0.1.1 - Useful utility functions that only depend on base.  http://hackage.haskell.org/package/not-in-base-0.1.1 (OscarFinnsson)
12:11:10 <pastorn> eurehot: personally i'm too cheap to buy it, and i don't like the online version of it, so i stick to wikibooks
12:11:17 <jmcarthur> alexyk: it's about selective control of evaluation though. it's not really a matter of strictness vs. laziness as it is a matter of the two complementing each other
12:11:19 <telephone> Has Ubuntu good support for haskell?
12:11:26 <eurehot> pastorn: is this book like a mindpack or just writing applications?
12:11:33 <pastorn> telephone: it's in apt...
12:11:38 <eurehot> telephone: yes
12:11:38 * Heffalump spies another MissingH
12:11:44 <ManateeLazyCat> dcoutts: I have code at http://paste2.org/get/877687 , i want update "pageModeHook" with different OS-processes, do you know any other solution except unsafePerformIO ?
12:11:45 <thoughtpolice> alexyk: ok, that's a better way to say it. i do like clojure a lot; rich is a very smart man with some sound design decisions
12:11:57 <ManateeLazyCat> telephone: Yes, but old ghc.
12:12:01 * hackagebot text-xml-generic 0.1.1 - Serialize Data to XML (strings).  http://hackage.haskell.org/package/text-xml-generic-0.1.1 (OscarFinnsson)
12:12:03 <pastorn> eurehot: well... i don't think that you're gonna get one without the other...
12:12:13 <alexyk> thoughtpolice: yeah, now FP folk who has to live in JVM has choices
12:12:18 <jmcarthur> my preferred way to control evaluation is by using bangs in ADTs and creating new data types if i need a special evaluation order
12:12:27 * ManateeLazyCat Ubuntu is Debian + newest sources
12:12:39 <pastorn> ok, you CAN do all the project euler stuff in haskell without learning any haskell (haskelllove, anyone?)
12:12:51 <telephone> ok. I am currently using gentoo, but want better powerusage for my laptop. Hence I think of switching to ubuntu.
12:13:14 <pastorn> eurehot: RWH is a good book to guide you to what tools to use for different tasks etc.
12:13:16 <Gracenotes> ManateeLazyCat: very basic thing cooked up - http://code.haskell.org/hackage-server/Distribution/Server/Hook.hs
12:13:24 <eurehot> pastorn, i wanna learn to think in a different way actually :p
12:13:27 * alexyk arrives at a random association "a little girls with bangs in her ADTs"
12:13:33 <sclv> telephone: ubuntu is fine. mainly you just install ghc and then get your own toolchian running on top anyway.
12:13:33 <alexyk> girl
12:13:39 <ManateeLazyCat> Gracenotes: Thanks, i will look it. 
12:13:42 <sclv> at least as a more serious dev.
12:13:52 <pastorn> eurehot: then just start writing stuff
12:13:55 <pastorn> :)
12:14:15 <Gracenotes> the only problem with ubuntu is the version
12:14:16 <dcoutts> ManateeLazyCat: if a PageMode contains mutable variables then it must be constructed inside the appropriate monad, you must not use unsafePerformIO
12:14:17 <pastorn> you'll get the mindset eventually :)
12:14:24 <telephone> sclv: and cabal will probably build up my haskell system?
12:14:30 <Gracenotes> and given the release cycles of ubuntu and ghc... a strong meh here
12:14:38 <eurehot> even with reading RWH?
12:14:45 <pastorn> eurehot: of course
12:14:50 <sclv> telephone -- right, but as Gracenotes points out, you might actually want to install a newer ghc first.
12:14:57 <sclv> which isn't bad at all, these days.
12:15:03 <pastorn> eurehot: you can't learn haskell without learning haskell :p
12:15:06 * jmcarthur just realized that "thunk" and "bang" are both onomatopoeia
12:15:15 <jmcarthur> s
12:15:22 <alexyk> so I am completely effed trying to install ghc 6.12 on CentOS/RHEL5.  No rpms in sight; gentoo prefix's ebuild is broken; nix fails to be.  Binary ghc for amd64 fails with "push is bad" groan; building from source with the existing and working 6.10.4 says <command line>: unknown package: base-3.0.1.0.  Why, why?
12:15:26 * pastorn is impressed that jmcarthur probably spelled that correctly
12:15:45 <jmcarthur> pastorn: i used "google spell check" ;)
12:15:46 <Gracenotes> they are onomatopoeiae
12:15:54 <jmcarthur> Gracenotes: not according to wikipedia
12:15:56 <pastorn> jmcarthur: :D
12:16:03 <telephone> sclv: so I should do a manual installation of ghc?
12:16:07 <Gracenotes> I just picked the most vowel-heavy plural
12:16:08 <pastorn> eurehot: do you see my point?
12:16:14 <jmcarthur> heh
12:16:16 <ManateeLazyCat> alexyk: ghc-pkg check?
12:16:27 <eurehot> pastorn: i do, now im wondering how long this will take :)
12:16:31 <pastorn> it's sort of the same that you can't learn java and not learn object oriented programming
12:16:32 <sclv> oupeia :-)
12:16:32 <alexyk> ManateeLazyCat: the old one you mean right
12:16:40 <pastorn> eurehot: depends on how clever you are :p
12:16:42 <jmcarthur> pastorn: uhh... yes you can :)
12:16:49 <ManateeLazyCat> alexyk: ?
12:16:54 <dcoutts> alexyk: sorry, why don't the generic ghc binary tarball work?
12:17:04 <jmcarthur> i've seen a lot of one-class java programs
12:17:06 <pastorn> jmcarthur, eurehot: well, you CAN, but you've gotta be pretty damn persistent not to
12:17:12 <ManateeLazyCat> alexyk: Ubuntu old ghc?
12:17:13 <alexyk> dcoutts: it reported that push in .s file is bad or some such
12:17:13 <sclv> telephone: if you want to the latest, yes. but you might be able to use a generic binary tarball
12:17:22 <jmcarthur> you can basically write C in java if you just don't make more than one class
12:17:29 <ManateeLazyCat> alexyk: I never use ghc in Ubuntu source.
12:17:32 <telephone> I have also read that xmonad works in ubuntu, so ubuntu could probably be a good development platform!
12:17:37 <dcoutts> alexyk: that's pretty weird, got any details?
12:17:41 <sclv> jmcarthur: and don't use other people's classes :-)
12:17:53 <alexyk> ManateeLazyCat: I'm on CentOS and have a working ghc-6.10 which I built in fact in a gentoo prefix portage as a slap-on for source builds...
12:18:02 <jmcarthur> sclv: you're not really practicing OO design just because you use somebody else's interfaces
12:18:11 <dcoutts> alexyk: sounds like ghc is running but something's weird with the interaction with the C compiler and assembler
12:18:13 <alexyk> dcoutts: I've rm -fr'ed it, but for you and the reliability of haskell, I'll revive it! :)
12:18:30 <roconnor> alexyk: nixos or nixpkgs will save you from package hell
12:18:46 <ManateeLazyCat> Gracenotes: Your Hook very like mine, just i use TVar instead IORef. :)
12:18:54 <sclv> jmcarthur: very little in java actually practices OO design :-)
12:19:01 <alexyk> roconnor: I tried to install nix but it failed to build nothin'
12:19:02 <jmcarthur> sclv: that's like saying C programmers are doing functional programming just because they are using a library that provides mostly referentially transparent functions
12:19:11 <dcoutts> ManateeLazyCat: but Gracenotes is not using unsafePerformIO :-)
12:19:25 <roconnor> alexyk: does that mean it succeeded in building somethin' ?
12:19:29 <sclv> and I've seen some very functional code in C.
12:19:39 <Gracenotes> this is true, but mostly because there is a block specifically for initializing them..
12:19:55 <ManateeLazyCat> dcoutts: The cause i use unsafePerformIO is i want update Hook status in different OS-processes.
12:20:05 <jmcarthur> sclv: it's surprising how much there actually is, usually without the writers even realizing
12:20:20 <alexyk> roconnor: alas, it failed right away.  :( patch dependency -- the GNU patch it couldn't even get.  Makes one mighty doubtful.
12:20:22 <dcoutts> ManateeLazyCat: no it's because you have not thought enough about the structure and think you need hacks like unsafePerformIO
12:20:30 <dcoutts> ManateeLazyCat: it is not essential
12:21:10 <ManateeLazyCat> dcoutts: Yes, i can build PageMode in moand, but i need build other IPC to transform the value of Hook between different processes.
12:21:16 <jmcarthur> ManateeLazyCat: wait, you're using TVar with unsafePerformIO? that will bite you later
12:21:37 <ManateeLazyCat> jmcarthur: I know, that's why i don't want use it. :)
12:21:48 <dcoutts> ManateeLazyCat: I don't see what that has got to do with it
12:21:59 <ManateeLazyCat> dcoutts: Currently, i use DBus as my IPC for processes.
12:22:12 <Gracenotes> jmcarthur: well, if he's just wrapping newTVarIO :: a -> IO (TVar a), then it's probably not so bad
12:22:23 <jmcarthur> oh, well, no, that's not too bad
12:22:24 <ManateeLazyCat> dcoutts: I don't want use *two* IPC in my program.
12:22:25 <Gracenotes> at least in terms of STM-level runtime bugs, but as for other bugs..
12:22:33 <jmcarthur> i've done that, even... and regretted it
12:22:36 <sclv> newTVarIO is specifically documented for use with unsafePerformIO :-)
12:22:43 <roconnor> alexyk: I don't quite get your problem, but too bad it didn't work for you.
12:22:45 <jmcarthur> yup
12:22:48 <alexyk> dcoutts: ah, probably I got the i386-unknown instead of x86_64
12:22:50 <ManateeLazyCat> sclv: Detail?
12:22:56 <sclv> http://hackage.haskell.org/packages/archive/stm/2.1.2.0/doc/html/Control-Concurrent-STM-TVar.html
12:22:57 <roconnor> alexyk: let me know if you want to try again ever.
12:23:02 <alexyk> roconnor: do you use nixos or just nix?
12:23:08 <dcoutts> alexyk: ahh, that'd explain it
12:23:10 <alexyk> roconnor: I really want to nail it
12:23:13 <sclv> For those who really frowm on the use of unsafePerformIO, this might be considered a documentation bug :-)
12:23:20 <roconnor> alexyk: I'm running nixos
12:23:33 <alexyk> roconnor: on what metal?
12:23:39 <alexyk> does it run on a laptop?
12:23:44 <dcoutts> alexyk: the ghc program would have worked because you'll have the 32bit libs installed, but when ghc tried to use gcc, the gcc was expecting 64bit code not 32bit
12:23:50 <roconnor> alexyk: acer aspire timeline 3810T
12:23:59 <roconnor> oh
12:24:04 <roconnor> also on my dell laptop something at work
12:24:12 <sclv> Oh, that reminds me, is it reasonable/straightforward to have a 64 bit and 32 bit ghc installed next to one another?
12:24:17 <dcoutts> ManateeLazyCat: I've no idea why you think the form of IPC you're using is related to whether or not you need unsafePerformIO to make a PageMode
12:24:21 <alexyk> roconnor: cool!  I'm pondering a latest Dell Latitude, will it blink me pretty windowses like them ubuntus?
12:24:26 <sclv> (I need the 32 bit one to do ffi to a 32 bit only lib) 
12:24:37 <dcoutts> ManateeLazyCat: why not just make defaultMode :: IO PageMode  ?
12:24:38 <roconnor> alexyk: blink you?
12:24:40 <sclv> Any tips on how to set things up cleanly for this sort of thing?
12:24:46 <alexyk> roconnor: ok display
12:25:02 <dcoutts> ManateeLazyCat: it's constructing a value containing new mutable refs, thus it must be in IO
12:25:08 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26164 -- I don't understand
12:25:18 <roconnor> alexyk: I'm running kde
12:25:27 <alexyk> I wonder if I should follow Ubuntu lemming-like for ease of use, or Debian for ready availability of real FP packages, or nixos for sensible packages
12:25:32 <roconnor> alexyk: the kde on my dell at work is very pretty
12:25:55 <roconnor> alexyk: I'm not sure why it is less pretty on this laptop.  Maybe I need to nuke old kde settings from my home directory
12:26:25 <ulfdoz> roconnor: You're doing it wrong! ;) The gnome-dwarfs will come off their holes and blame you for that. ;)
12:26:32 <alexyk> roconnor: but the quality of desktop packaging, etc., is it all good on nixos?  I remember preferring openSUSE to RedHat a while ago for the better fit quality
12:26:33 <sclv> @ty listArray
12:26:34 <ManateeLazyCat> dcoutts: If i make "defaultMode :: IO PageMode", i can't transform the value of "IO ()" through DBus message.
12:26:34 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
12:26:37 <sclv> mreh ^^
12:26:46 <roconnor> ulfdoz: how can I be doing it wrong if I don't know what I'm doing
12:26:56 <mreh> urgh
12:27:00 <alexyk> I also like Arch to consider, and it it has Haskell to the gills.  Choices...
12:27:02 <dcoutts> ManateeLazyCat: then pass the constructed page mode as a parameter to the dbus code
12:27:05 <roconnor> alexyk: I'm not sure what you mean.
12:27:32 <ulfdoz> roconnor: Word! I like kde for that. But I'd prefer a continuing kde3, it was just more complete.
12:27:43 <Gwern-away> alexyk: every OS dons uses has haskell to the gills, until he stops using it
12:28:14 <roconnor> ulfdoz: kde3 is no longer actively supported by nixos.
12:28:16 <alexyk> roconnor: there's a whole feeling of ease of managing a Linux setup, its GUI packaging, etc., which made Ubuntu dominant, and now one wouldn't want to have a broken gentoo-like thing to go tweak instead of just enjoying an Emacs with Haskell in a pretty window!
12:28:28 <wvd> Does anyone have an example of calling functions from a DLL in Haskell? I've been trying to google it, but it didn't give me any results who made sense.
12:28:35 <alexyk> Gwern-away: which is the OS du jour then?
12:28:48 <Gwern-away> alexyk: for now, arch linux
12:28:57 <alexyk> Gwern-away: aha!  so 90% is explained
12:28:59 <ulfdoz> roconnor: It's no longer supported even by kde.org. However, I liked it very much, it was exactly what I liked. Control & Stupidity.
12:29:22 <Gwern-away> alexyk: wouldn't surprise me if he switched to nixos or another 'second generation package system' OS in a few years
12:29:27 <roconnor> alexyk: ah.  There is no ease of managing packages.  But I do sleep soundly knowing that all my upgrades can be rolledback.
12:29:38 <Gwern-away> alexyk: note the downside - support suffers when he moves away. ask our openbsd users how well haskell is supported in ports
12:29:53 <alexyk> Gwern-away: so Debian is dead then?
12:30:06 <alexyk> Gwern-away: stop being so away, I have to shout
12:30:07 <Gwern-away> alexyk: it's not so hot, let's say
12:30:08 <jmcarthur> <3 arch
12:30:24 <Gwern-away> alexyk: IT'S GOOD EXERCISE
12:30:29 <alexyk> Gwern-away: WHAT?
12:30:42 <roconnor> Gwern-away: who is he?
12:30:50 <Gwern-away> alexyk: YOU KNOW, CICERO CONSTRUCTED AN UNDERGROUND CHAMBER TO YELL HIS SPEECHES. THAT'S HOW HE BECAME SUCH A GREAT ORATOR
12:31:05 <alexyk> Gwern-away: GEORGE BUSH SENIOR?
12:31:14 <c_wraith> the chamber yelled his speeches?
12:31:16 <roconnor> Gwern-away: oh, dons
12:31:33 <benmachine> <3 jmcarthur 
12:31:50 <jmcarthur> :D
12:32:00 <jmcarthur> i have been hearted
12:32:04 <Gwern-away> alexyk: NO, I HAVEN'T SEEN HIM
12:32:29 <alexyk> I kind of leaned toward Debian as it used to have best OCaml and listed first on Haskell Download for Linux.  And Arch is used by the small nations of Middle Earth.
12:33:13 <alexyk> but I'd give nixos a try.  roconnor: how easy is it to cook up a nixos def when missing, a la Arch?
12:34:11 <roconnor> alexyk: It required me learning a bit more about linux than I like to know.  If your missing package builds with ./configure; make; make install it is really easy to make a new package.
12:34:51 <alip> is there a builtin way to figure out e.g. whether a list has X or more elements without calculating its length? or should I go with a function like http://paste.pocoo.org/raw/225415/
12:35:13 <roconnor> alip: something like drop n l == []
12:35:18 <dafis> alip: not . null . drop (n-1)
12:35:18 <alexyk> nixos sounds like darcs, so Haskellers are just bound to converge on it like flies on butter! :)
12:35:24 <ManateeLazyCat> dcoutts: The key is not value of PageMode, just "pageModeHook" is dynamic, other fields in PageMode are static, I want share Hook (TVar [IO ()]) between processes.
12:35:36 <alip> dafis: thanks! :)
12:36:00 <Philippa> > drop -1 [1,2,3]
12:36:01 <lambdabot>   Overlapping instances for GHC.Show.Show
12:36:01 <lambdabot>                              (GHC.T...
12:36:02 <ManateeLazyCat> dcoutts: I want a process update add "IO ()" in Hook, then other processes can read those new Hook status 
12:36:05 <alexyk> nixos has a great strength that it's written by the Dutch people, and we all know the Dutch people drive the FP in reality.
12:36:17 <Philippa> > drop -1 [1::Int,2,3]
12:36:18 <lambdabot>   Overlapping instances for GHC.Show.Show
12:36:19 <lambdabot>                              (GHC.T...
12:36:24 <Philippa> > drop -1::Int [1::Int,2,3]
12:36:25 <lambdabot>   <no location info>: parse error on input `::'
12:36:30 <dafis> > drop (-1) [1,2,3]
12:36:32 <lambdabot>   [1,2,3]
12:36:32 <Philippa> > drop (-1::Int) [1::Int,2,3]
12:36:33 <lambdabot>   [1,2,3]
12:36:35 <Philippa> ah
12:36:59 <zygoloid> > take (-1) [1,2,3]
12:37:00 <lambdabot>   []
12:37:05 <Philippa> I rarely deal with integers, hence not having learned the wrinkle
12:37:24 <roconnor> alexyk: God created the earth, but the Dutch created the Netherlands.
12:37:27 <Philippa> bit embarrassing, really :-)
12:37:55 <Gwern-away> alexyk: it depends more on nixos's maturity. network effects you know
12:38:00 <alexyk> roconnor: exactly.  Erik Meijer is teaching Haskell in MSFT, imagine trying to that.
12:38:40 <dcoutts> ManateeLazyCat: I don't see the problem. Why does defaultMode need to use unsafePerformIO? (it doesn't)
12:38:42 <theorbtwo> It's not actually difficult to imagine.
12:38:55 <theorbtwo> What's difficult to imagine is Haskell actually getting used in Microsoft.
12:38:57 <ManateeLazyCat> dcoutts: I can pass other static field through DBus, but i don't know how to pass the value of "IO ()", if i build *emptry* Hook in other processes, Hook is insignificant
12:39:03 <ManateeLazyCat> dcoutts: Ok, i explain why i need it.
12:39:13 <dcoutts> ManateeLazyCat: if you can share them now when they are TVar [IO ()] then you'll still be able to do it when you're not using unsafePerformIO
12:39:13 <sproingie> i've heard LINQ was directly inspired by HaskellDB
12:39:38 <dcoutts> ManateeLazyCat: ah ok, but that's an unrelated problem
12:39:58 <ManateeLazyCat> dcoutts: Pass "TVar [IO ()]" ?
12:40:09 <ManateeLazyCat> I need think about it.
12:40:11 <dcoutts> ManateeLazyCat: the fact that you cannot marshal values of type IO () is not related to your use of unsafePerfomIO
12:40:21 <alexyk> sproingie: there's a whole story with F# growing from haskell .NET and LINQ from it, and I visited folks in MSFT and it's all true
12:40:24 <roconnor> theorbtwo: now try to imagine using coq at MS
12:40:52 <alexyk> roconnor: using coq in workplace?
12:40:55 <ManateeLazyCat> dcoutts: Yes, that's true, i just think about how to hack it with unsafePerformIO, like you said. :)
12:40:57 <Twey> They're not really *using* Haskell, they're just stealing little bits from it and missing the bigger picture
12:41:01 <dcoutts> ManateeLazyCat: I'm not talking about the marshalling, I'm just saying that whatever you do, you don't need (and must not use) unsafePerfomIO
12:41:16 <dcoutts> ManateeLazyCat: and in this case it does not help you anyway
12:41:37 <Gwern-away> maybe in a decade or two
12:41:39 <roconnor> alexyk: use it at the MSR-INRIA joint centre
12:41:50 * Twey wishes that IO weren't opaque 
12:41:51 <roconnor> *I use it
12:41:55 <Gracenotes> I would be suspicious of marshaling memory-address-type things too
12:42:06 <dcoutts> Twey: you can make your own IO that's not opaque
12:42:09 <Gracenotes> if this is the idea.. uh
12:42:23 <dcoutts> Gracenotes: yeah, it's a crazy idea
12:42:26 <alexyk> roconnor: ah, but that's MSR's smart way to attract FP folk and good programmers in general!  Sponsoring Haskell and F# is very clever indeed for attracting good people.
12:42:50 <Twey> dcoutts: Sure but it's a huge task and none of the existing stuff will work with it.
12:43:00 <sproingie> i'm quite happy to see haskell's ideas "stolen" far and wide
12:43:06 <sproingie> i prefer to see it as spreading its seed
12:43:18 <Twey> sproingie: I would be if they got the *good* bits
12:43:18 <zygoloid> what's a good way to provide a ghci-style interactive haskell session? ghc-api?
12:43:18 * ManateeLazyCat pasted "DBus instance" at http://paste2.org/get/877741
12:43:19 <ManateeLazyCat> dcoutts: My real problem is i don't know how to pass "TVar [IO ()]" through DBus, if you want pass value through DBus, you must instance like above code.
12:43:25 <dcoutts> Twey: you can make an IO that lifts opaque IO blobs but where the rest is visible
12:43:30 <sproingie> i'd say linq is a good bit
12:43:34 <Twey> sproingie: And didn't horribly mangle them as they went
12:43:47 <alexyk> why does haskell-platform want OpenGL C library??
12:43:57 <Twey> alexyk: Because it includes GL bindings?
12:43:59 <dcoutts> ManateeLazyCat: you can only pass values and object interfaces via DBus, you cannot pass references
12:44:11 <ManateeLazyCat> dcoutts: Yes, that's the real problem
12:44:18 <alexyk> is it like necessary for a basic platform?
12:44:19 <dcoutts> ManateeLazyCat: you cannot share a single TVar between two OS processes
12:44:21 <Twey> sproingie: How?  The syntax is horrible, and it's nasty to implement  so much so that often the old way is easier
12:44:34 <Twey> It's okay to *use*, but creating your own monad is no fun at all
12:44:35 <dons> alexyk: it includes GL as part of the platform specification.
12:44:46 <dons> alexyk: you should probably just use the platform installers that come in binary form.
12:44:50 <dons> what distro are you using?
12:44:50 <sproingie> Twey: as far as i've heard you only need to implement SelectMany
12:44:59 <sproingie> which is basically bind
12:45:17 <Saizan> alexyk: i don't think there's anything else in the platform that depends on those bindings
12:45:27 <ManateeLazyCat> dcoutts:  Sometimes multi-processes framework like Chrome is not good for extensionable system
12:46:02 <alexyk> dons: I'm on an all-messed up CentOS and I slapped gentoo portage on top of it.  It has ghc 6.10 but 6.12 ebuild is broken; I got ghc from binary tarball which works and now tried to compile the platform from source.
12:46:19 <dcoutts> ManateeLazyCat: if you're making a distributed system then consider passing messages rather than sharing state
12:46:21 <sproingie> portage on centos.  wowsers.
12:46:26 <Twey> sproingie: Really?  http://aabs.wordpress.com/2007/06/09/designing-a-linq-query-provider/
12:46:30 <alexyk> prefix portage is a lovely feast
12:46:39 <ManateeLazyCat> dcoutts: "you cannot share a single TVar between two OS processes", except use hacking way "unsafePerformIO", but i think unsafePerformIO just make thing become worse.
12:46:55 <dcoutts> ManateeLazyCat: no, there is no "except".
12:46:59 <alexyk> trye that next time you got no root: http://www.gentoo.org/proj/en/gentoo-alt/prefix/
12:47:06 <alexyk> installs on Mac too
12:47:17 <Twey> alexyk: Ah, they fixed that at last, did they?
12:47:22 <sproingie> Twey: i'd say most of the awfulness of that is due to SPARQL
12:47:35 <alexyk> (I mount it in a case-sensitive volume).  Twey -- it went a long way, very robust now.
12:48:08 <ManateeLazyCat> dcoutts: Yes, i always use DBus pass message through my different processes (core <-> editor, core <-> web-browser, core <-> file-manger)
12:48:25 <sproingie> Twey: there's only so much you can do to make elegant the guts of some functional feature on top of an imperative language.  anyway most people dont have to write their own providers.
12:48:38 <Twey> alexyk: No, I mean that that should be the default for any package manager  I consider it a bug that it wasn't possible in earlier versions of Portage.
12:49:21 <Twey> sproingie: Right.  They've taken one thing (monads) and hacked it on top of an existing imperative language, making it an awful kludge.
12:49:21 <ManateeLazyCat> dcoutts: Infact, i use unsafePerformIO to build some constant value, so it's safe if i don't update it's value like TVar?
12:49:28 <alexyk> Twey: you mean relocating?  it's still not automatic with all ebuilds...
12:50:02 <sproingie> Twey: somehow i fail to take offense.  "turf it all and just use haskell instead" was not going to be a winning strategy
12:50:12 <dcoutts> ManateeLazyCat: if it's a constant you do not need unsafePerformIO
12:50:25 <ManateeLazyCat> dcoutts: I said another thing.
12:50:29 <ManateeLazyCat> dcoutts: Wait, i paste code.
12:50:31 <Twey> sproingie: It probably would be, if MS endorsed it.
12:50:33 <sproingie> python has list comprehensions and i wish they did it with some nice extensible API
12:50:49 <sproingie> Twey: they have F#, and that hasn't exactly taken over the world
12:50:50 <pastorn> dcoutts: it might be a global var that needs IO initialization...
12:50:59 <Twey> sproingie: And they're not exactly pushing it
12:51:13 <sproingie> i think people give microsoft a little too much credit sometimes
12:51:28 <dcoutts> pastorn: well that's not necessary either, since one does not need that in application code
12:51:30 <Twey> It remains an alternative option, at best  they haven't applied nearly the marketing pressure to it that they did with C#
12:51:40 <alexyk> sproingie: F# is making huge inroads.  VS 2010 supports it, and MS androids become human when they see it!
12:51:43 * ManateeLazyCat pasted "tempClient code" at http://paste2.org/get/877752
12:51:43 <ManateeLazyCat> dcoutts: Example, i build a temporary DBus client for send signal like above, because i won't update the value of tempCleint, so it's safe with unsafePerformIO? 
12:51:46 <Twey> Haha
12:51:58 <Heffalump> there's no point in them upping the pressure, it's only competing with C# really
12:51:59 <sproingie> yet the #1 smartphone platform is still programmed in java (sort of)
12:52:23 <Twey> The #1 smartphone platform was iPhone OS, last I looked
12:52:29 <sproingie> android overtook it
12:52:32 <ManateeLazyCat> dcoutts: I has know i'm wrong about "unsafePerformIO with TVar", but i want confirm http://paste2.org/get/877752 is right way.
12:52:39 <Twey> Really?  Statistics?
12:52:43 <sproingie> iphone is probably back on top what with the rush to upgrade
12:52:48 <Twey> That would be pretty cool
12:53:02 <dcoutts> ManateeLazyCat: the point is not if it's safe but if it's a good idea, which it is not.
12:53:03 <sproingie> temporary.  it may be apple, but it's also AT&T vs everyone else
12:53:09 <zygoloid> i thought iphone was 20-something% and android was appoaching 10%
12:53:13 <Twey> But I looked only the other week and iPhone was about twice as popular as Android devices
12:53:17 <Twey> Yeah
12:53:36 <dcoutts> ManateeLazyCat: no, it's using unsafePerformIO to construct a mutable variable, that's bad.
12:54:08 <ManateeLazyCat> dcoutts: I will use "tempClient" send DBus signal in different processes, but the value of tempClient won't change after it create.
12:54:15 <sproingie> at any rate, iPhone isn't a C# success story either
12:54:23 <dcoutts> ManateeLazyCat: then just make it in IO, stop trying to use unsafePerformIO
12:54:40 <Twey> Indeed not but that's more to do with Microsoft's lack of pull in the smartphone market than anything else
12:54:47 <Twey> On desktops, C# has become ubiquitous
12:54:57 <Twey> (Windows desktops, anyway)
12:55:02 <sproingie> not sure about that
12:55:03 <Heffalump> ubiquitous in what sense?
12:55:12 <sproingie> i'd say flash has far more penetration
12:55:26 <Heffalump> it's not the main impl language of the apps (that's C++)
12:55:47 <alexyk> for Map's insertWith', I need a function a->a->a combining previous and new values; what do I use to discard the previous, i.e. do plain insert?  i.e. is there a cute little function for that?
12:56:00 <sproingie> i guess my MS office communicator app is probably in C#
12:56:04 <c_wraith> just use const x as your function
12:56:12 <sproingie> looking at the rest of what i have up, i'm pretty sure that's it
12:56:28 <dafis> alexyk, insert is strict enough
12:56:30 <dcoutts> ManateeLazyCat: there are a few special cases where unsafePerformIO is legitimate. Using it as a way to help structure your program is not a legitimate use of unsafePerformIO.
12:56:30 <Twey> Heffalump: No, but it's installed on every Windows desktop since '08 or so
12:56:37 <alexyk> c_wraith: is it the right order of ignoring?
12:56:41 <Heffalump> what do you mean "installed"? C# is a language/compiler, not a runtime.
12:56:48 <c_wraith> dafis: that's not always true.
12:56:56 <danharaj> He means CLR/.NET?
12:56:57 <c_wraith> alexyk, I believe so.
12:56:57 <Twey> The .NET runtime and C# libraries
12:56:58 <monochrom> "install haskell" :)
12:57:00 <Heffalump> if you mean the .NET runtime, most code that targets it is probably C#, yes
12:57:08 <sproingie> Twey: and even with that ubiquitous installation base, they can't move programming language cultures overnight
12:57:16 <Heffalump> but then so is the C++ runtime
12:57:30 <ManateeLazyCat> dcoutts: Use unsafePerformIO build a FilePath is legitimate ? :)
12:57:30 <alexyk> dafis: dons emphasized the need for insertWith' strongly so now I want to replace M.insert with it.  Or is it in vain?
12:57:34 <dafis> c_wraith, yes, I was assuming insertion of already evaluated things
12:57:39 <dcoutts> ManateeLazyCat: no
12:57:46 <alexyk> the ' is what I'm after
12:57:47 <ManateeLazyCat> dcoutts: I mean a constant FilePath
12:57:54 <dcoutts> ManateeLazyCat: no
12:57:56 <Twey> Heffalump: But most Windows coding is done with .NET nowadays
12:58:12 <Twey> C#, even
12:58:31 <ManateeLazyCat> dcoutts: Example like above?
12:58:31 * ManateeLazyCat pasted "another unsafePerformIO code" at http://paste2.org/get/877770
12:58:32 <sproingie> i would dispute that
12:58:48 <sproingie> even so, C# remains a rather conventional language for those apps to be written in
12:58:52 <ManateeLazyCat> dcoutts: http://paste2.org/get/877770 is legitimate ?
12:58:53 <dcoutts> ManateeLazyCat: nope
12:58:55 <dafis> alexyk, you need insertWith' if you combine the old and new value, if you just insert, insert is fine, supposing the values you insert aren't thunks
12:58:56 <sproingie> even though the same platform can support F#
12:58:58 <Heffalump> Twey: is it?
12:59:28 <ManateeLazyCat> dcoutts: Looks i did "bad thing" twice.... 
12:59:29 <alexyk> dafis: so it won't get us far then :(
12:59:58 <sproingie> i think sneaking FP in with so-called kludges like linq is exactly the way to make it happen
13:00:04 <Twey> Heffalump: Isn't it?  All the new MS toys are written using C#, C# is the language being taught in schools, and C# is the languages the enterprises are hiring for
13:00:26 <Heffalump> I thought most schools still teach Java
13:00:33 <sproingie> office is still in C++.  except again for that communicator thingie.
13:00:47 <sproingie> which i just suspect is c# since it appears to use wpf
13:00:50 <Twey> Java still has some share of the latter two markets, but C# has made it to mostly an even footing in the last few years alone, compared to Java's what is it now, 15 years?
13:00:51 <monochrom> Most people still speak without backing data.
13:00:55 <Heffalump> sproingie: one way of looking at F# is like LINQ but more so. It's certainly still quite a kludge.
13:01:00 <danharaj> C# would be a step up from java for teaching. This is a scientific fact.
13:01:14 <ManateeLazyCat> dcoutts: If i build code like http://paste2.org/get/877752 , what's the worst thing will happen?
13:01:15 <Twey> danharaj: Heh
13:01:26 <Heffalump> sproingie: Visual Studio uses WPF, but I don't think that's C#
13:01:35 <sproingie> Heffalump: sure but at least a large proper subset of F# that's still reasonably useful is pure
13:01:39 <monochrom> Most people on IRC know Haskell.
13:01:51 <ManateeLazyCat> monochrom: Really?
13:01:56 <Twey> Most people are monochrom.
13:01:58 <Heffalump> sproingie: it's not the purity really that I think is a kludge, it's the type system.
13:01:59 <sproingie> Heffalump: it's definitely .NET, i'm not aware of any non-.NET uses of WPF
13:02:12 <sproingie> Heffalump: you have to admit it beats the C++ type system
13:02:28 <monochrom> ManateeLazyCat: Yes, if you hang out in #haskell
13:02:35 <dons> alexyk: did you get insertWith' working nicely?
13:02:55 <dcoutts> ManateeLazyCat: Firstly, people will think you're a bad coder. Secondly, the details of how it might go wrong are tricky, it depends on what the code does and how it gets called.
13:03:14 <Twey> Laziness is intrinsic to Haskell.  I think anything that aims to take ideas from Haskell needs to take that one.  It's the foundation for most of the rest, and without it, the rest becomes a lot less impressive.
13:03:16 <dcoutts> ManateeLazyCat: the more code the harder it is to evaluate what might go wrong.
13:03:16 <alexyk> dons: was just going to, but dafis says it won't be different since my M.insert already ignores the previous value...  Is that right?
13:03:26 <Heffalump> Twey: I disagree
13:03:44 <dons> alexyk: well, that might be right, if that's how you're using it.
13:03:53 <Heffalump> I think there are a lot of Haskell idioms that do rely on laziness.
13:03:54 <dons> alexyk: did heap profiling reveal what is being allocated?
13:04:02 <monochrom> I take ideas from Haskell like infix notation. Does infix notation need laziness?
13:04:13 <Heffalump> but I think the language, particularly with GHC extensions, has a lot of stuff that isn't based on laziness.
13:04:16 <dcoutts> ManateeLazyCat: and if you don't understand it well enough to know if or how it might go wrong then you should not be using it.
13:04:17 <ManateeLazyCat> dcoutts: I see, infact, i use IO Client before, just don't want pass "Client argument" to everywhere, then i build tempClient, looks i did a bad choose. :)
13:04:29 <alexyk> dons: I decided to switch to ghc-6.12 first on the server as well, will get to it!
13:04:48 <alexyk> I develop on a Mac with 6.12 so would rather run on the same
13:04:48 <dons> alexyk: cool. i'd help out, but am busy, so really just want to check in you're making progress.
13:04:57 <dons> can't wait to see the heap profiles
13:05:18 <dcoutts> ManateeLazyCat: don't be afraid of passing arguments. There are various idioms to make it nice.
13:05:18 <alexyk> dons: np, I appreciate that.  I'll also cook some sample data.
13:05:37 <dons> Gwern-away: http://vorlon.case.edu/~lps/software/automata/
13:06:05 <ManateeLazyCat> dcoutts: Ok, thanks for your help! I will refactory my code to remove unsafePerformIO
13:06:13 <dcoutts> ManateeLazyCat: great
13:06:24 <lowasser> What are some general tips on when -qm -qw is bad and when it's good?
13:06:48 <monochrom> what are -qm -qw?
13:06:49 <Twey> Heffalump: Mostly the type-system, surely?
13:06:54 <ManateeLazyCat> dcoutts: As the result, i can't build Hook since unsafePerformIO is not right way ....
13:07:03 <lowasser> RTS parallelization options
13:07:14 <dons> lowasser: generally it is bad, unless you know that threads shouldn't migrate
13:07:16 <monochrom> thanks
13:07:27 <dons> lowasser: e.g. you have N threads on N cores and they do the same amount of work
13:07:39 <ManateeLazyCat> dcoutts: I will lookup for other way to provide Hook, maybe it's impossible...
13:07:55 <lowasser> grawr
13:08:47 <lowasser> if you had a program that had some bits that shouldn't migrate and some bits that should, any workarounds you'd suggest?
13:09:10 <Heffalump> Twey: yeah
13:09:15 <Heffalump> but that's a pretty major bit :-)
13:09:36 * Heffalump is still not really sure if laziness is worth the cost.
13:10:05 <sclv> I've found that increasing amounts of my code are built around tying the knot, etc.
13:10:43 <dons> didn't igloo propose strictifying inserts into Data.Map recently?
13:10:52 <Heffalump> I've spent significant amounts of time programming (i.e. years) in a strict functional language on a couple of occasions, and you certainly miss all the little idioms.
13:11:01 <dons> i think we'll be fine once the "intuitive" strictness is the default. e.g. foldl' for sum, strict updates in containers.
13:11:21 <dons> and we have more balanced structures with mixed laziness and strictness
13:11:29 <Heffalump> and better language support for strictness
13:11:53 <sclv> Heffalump: in what sense?
13:12:19 <Heffalump> I'm not entirely sure. But it always feels awkward to make things strict.
13:12:27 * earthy nods
13:12:37 <earthy> Clean is easier in that regard
13:13:05 <Heffalump> strict things don't really feel first-class
13:13:56 <dons> i like strict array types. vector feels natural.
13:13:57 * ManateeLazyCat "With the correct way to write code, not to get lazy and use the hacking way."  I learned this today . :)
13:14:13 <dons> and spine lazy,element strict types
13:14:25 <sclv> I could imagine, e.g. List a = Cons a (List a) | Nil also declaring a type "!List = Cons !a !(List a) | Nil" automatically, and some appropriate efficient functions to map between the two, maybe.
13:15:30 <lowasser> I'd definitely like to imagine facilities for specialization and strictification of data structures
13:15:37 <earthy> I like iteratees. ;)
13:16:13 <earthy> sclv: well. that's almost what Clean does
13:16:19 <dons> lowasser: we have some facilities already. i'm sketching a paper on it. see e.g. adaptive-containers
13:16:34 <dons> generating both specialized code *and* data from a type
13:16:36 <earthy> sclv: in fact, you can specify strictness for any argument to any function
13:16:59 <sclv> I realized just recently that iteratees are the free monad over the function (r->) -- not that I know what to do with that :-)
13:17:12 <sclv> s/function/functor/
13:18:01 <earthy> and the compiler will then do strictness inference all through your program
13:18:29 <sclv> earthy: right. i've played with clean a bit. there's a whole bunch of neat stuff there.
13:19:27 <alexyk> well trying to compile haskell-platform lead to emerge opengl glut, which installed of X11 and much else you'd be surprised at, e.g. libxslt.  Now it's compiling and then fails in OpenGL package.  Is there a way to rip it off like a dirty dog?
13:19:48 <alexyk> ./configure --without-any-damn-X-stuff
13:20:03 <alexyk> ./configure --vt100=on
13:20:26 <alexyk> rip out I meant.  No need to rip off dogs
13:20:30 * ManateeLazyCat dcoutts always pointed out the essence of the problem.... :)
13:20:31 <jmcarthur> i basically ignore the existence of the haskell platform
13:20:39 <Heffalump> earthy: I don't. Not very compositional.
13:20:50 <earthy> iteratees?
13:20:54 <Heffalump> earthy: YEAH
13:20:55 <alexyk> jmcarthur: can I just get cabal for 6.12 somehow?
13:21:00 <Heffalump> sorry, hit caps lock at the wrong time
13:21:11 <earthy> hm. they seem a bit more compositional to me than lazy I/O
13:21:12 <dons> alexyk: you're using the gentoo package? or the unix src package?
13:21:12 <jmcarthur> alexyk: cabal should come with ghc, shouldn't it?
13:21:19 <jmcarthur> alexyk: or do you mean cabal-install?
13:21:29 <alexyk> jmcarthur: cabal-install
13:21:34 <Heffalump> earthy: well, perhaps in terms of actually working correctly when you compose them :-)
13:21:51 <jmcarthur> alexyk: you can just download the source and run the .sh script it comes with, which will get all of its dependencies and stuff for you
13:22:09 <earthy> but yeah, they look a bit weird, true
13:22:46 <alexyk> dons: I'm compiling from source; since prefix portage installed GL into /opt/portage/usr/{include,lib}, it apparently can't find them: error: GL/glu.h: No such file or directory.  Should I specify CPPFLAGS/LDFLAGS before ./configure?
13:22:55 <ManateeLazyCat> alexyk: If you has install ghc,  don't install Cabal
13:23:14 <ManateeLazyCat> alexyk: I recommend you use bootstrap.hs in cabal-install package.
13:23:23 <alexyk> ManateeLazyCat: ok
13:23:32 <ManateeLazyCat> alexyk: It will buid every necessary packages for cabal 
13:23:34 <jmcarthur> i still can't say i really "get" iteratees. i see that they are compositional and everything, but they seem so dependent on understanding the internals that my mind won't accept it as an abstraction of any sort
13:23:41 <dons> ManateeLazyCat: that's not really appropriate at the moment.
13:23:49 <dons> alexyk is installing the haskell platform from source.
13:23:59 <earthy> I just strongly feel that the performance issues I've run into while trying to keep my code neat can be reasonably easily solved using iteratees
13:24:05 <ManateeLazyCat> dons: Oh, 
13:24:14 <alexyk> yep, I'll try that first, then resort to cabal-install with .sh
13:24:21 <dons> alexyk: i think you can pass the include path, yes.
13:24:28 <jmcarthur> alexyk: you need to install some opengl libraries if you want to build the platform
13:24:29 <earthy> (haven't gotten round to recoding though)
13:24:30 <ManateeLazyCat> alexyk: If you use Haskell Platform, you has build everything you need.
13:24:32 <zygoloid> what's the right way to decide which versions to put in .cabal dependencies?
13:24:35 <jmcarthur> oh, include path...
13:24:36 <Gwern-away> dons: '# Donate the library to hslibs. ' heh
13:25:16 <Gwern-away> dons: I'll package that in exchange for one xmonad patch review of your choice :)
13:25:17 <jmcarthur> dons: btw, the platform on AUR doesn't build for me because the opengl stuff seems to have messed up dependencies in the PKGBUILD or something
13:25:27 <ManateeLazyCat> alexyk: Ignore my word if you install haskell-platform. :)
13:25:33 <dons> Gwern-away: as indicated, i will be available in july for that.
13:25:36 <dons> jmcarthur: thanks.
13:26:06 <Gwern-away> bah
13:27:51 <alexyk> dons: yeah, doing things like export CPPFLAGS=-I/opt/portage/usr/include and similar for LDFLAGS seems to have appeased the platform.  But, I'd really prefer to be able to disable the OpenGL crap.
13:29:02 <alexyk> wow there's Data.Graph.Inductive scrolling by, what's that?
13:29:11 <jmcarthur> fgl
13:29:14 <alexyk> ah
13:29:41 <Gwern-away> phew, 'automata' hasn't been taken yet
13:30:01 <ezyang> better nab it fast :-) 
13:30:05 <alexyk> how do you rename yourself on IRC again?
13:30:12 <MrElendig> /nick
13:30:14 <ManateeLazyCat> dons: We can merge gtk2hs into Haskell-Platform since gtk2hs now just (glib, gio, cairo, pango, gtk) ?
13:30:23 <jmcarthur> dons: in GLURaw's PKGBUILD:  depends=('ghc' 'haskell-cabal' 'haskell-openglraw' '')
13:30:35 <Heffalump> ManateeLazyCat: someone needs to make a proposal
13:30:39 <jmcarthur> the stray '' throws everything off i think
13:31:00 <ManateeLazyCat> Heffalump: I think merge gtk2hs to Haskell-Platform is helpful.
13:31:30 <ManateeLazyCat> Heffalump: Then all haskellers have a stable Graphics Toolkit in Haskell-Platform.
13:31:31 <sclv> ManateeLazyCat: right. he just means there's a process to be followed.
13:32:05 <ManateeLazyCat> Heffalump: So you mean i need add new ticket?
13:32:32 <Heffalump> no, there's a more complicated process than that (because the platform is a big deal)
13:32:33 <dons> jmcarthur: oh yikes.
13:32:37 <Gwern-away> I like the idea of gtk2hs in the HP, but I worry that it is unreliable and will drag down the HP
13:32:38 <earthy> does gtk2hs work without X11 on mac os x?
13:32:40 <dons> jmcarthur: that was a bug in cabal2arch from a few versions back
13:32:41 <ManateeLazyCat> gtk2hs package just include core-packages, and has cabalized.
13:32:46 <dons> Gwern-away: unreliable?
13:32:51 <dons> to build?
13:32:54 <yaxu1> Hi all, I'm finishing a paper on musical pattern in haskell
13:32:59 <dons> yaxu1: nice
13:33:02 <Gwern-away> dons: building, linking, running
13:33:07 <yaxu1> writing the bit on why I chose haskell for an EDSL
13:33:12 <yaxu1> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26169#a26169
13:33:13 <alexy|not-away> ok say I have ~/.cabal full of ghc-6.10's packages.  Now I got a platfrom with 6.12's cabal, hot as a fresh baguette.  If I say cabal update, will it eff my ~/.cabal?  Should I move that away? Is it lost?
13:33:19 <dons> Gwern-away: do you have evidence?
13:33:19 <Gwern-away> dons: it may just be me, but I seem to see a lot of gtk-related bugs, and trebly so on mac and windows
13:33:28 <ManateeLazyCat> earthy: I don't know the status of MacOS, but i know gtk2hs can install Linux and Windows well.
13:33:29 <jmcarthur> dons: my (i think up to date) cabal2arch does that
13:33:32 <dons> well, they'll have to pass the proposal test
13:33:35 <yaxu1> would anyone be able to have a look to check I'm using the right terms etc?
13:33:37 <dons> jmcarthur: ok.
13:33:41 <Heffalump> yaxu1: sure
13:33:42 <dons> jmcarthur: might have reintroduced it
13:33:52 <yaxu1> Heffalump: thanks, it's that hpaste I just linked
13:34:00 <Gwern-away> ManateeLazyCat: what is 'well'? 'as reliable as the stuff currently in the HP'?
13:34:01 <earthy> manateelazycat: last I checked there's no gtk for native quartz...
13:34:30 <alexyk|noway> Gwern-away: Caesar said: buildi, linki, runni.
13:34:37 <Heffalump> I wouldn't really call 'functors and monads' type-level constructs.
13:35:07 <Gwern-away> ooh, this is a good opportunity to try out 'cabal init'
13:35:07 <Heffalump> and I don't quite know what "once the notion of a pattern is defined in formal terms" means, but it might make more sense in the full context.
13:35:08 <alexyk|noway> anyhow, can ~/.cabal's coexist?  is it not ghc-versioned?
13:35:39 <yaxu1> Heffalump: it means defining a musical pattern as a functor and/or monad
13:35:43 <Heffalump> alexyk|noway: ~/.cabal just stores the cabal configuration and source packages. The installed packages sit with the GHC install.
13:35:55 <ManateeLazyCat> Gwern-away: I admit install gtk2hs on non-unix system maybe drag down HP, but it's not the reason we can't do a try, is it?
13:35:57 <earthy> manateelazycat: apparently there's a quartz gtk backend...
13:36:07 <Gwern-away> ManateeLazyCat: what is 'can't do a try'...
13:36:10 <yaxu1> Heffalump: so just constructs then?
13:36:23 <alexyk|noway> Heffalump: ok; so say I installed into ghc 6.10.  Will ~/.cabal know that and know that 6.12 is virginal and needs to be filled in?
13:36:31 <jmcarthur> Gwern-away: i like  cabal init --minimal
13:36:36 <Heffalump> alexyk|noway: yes, it looks at the ghc-pkg list
13:36:52 <alexyk|noway> Heffalump: with the ghc-pkg in the path, right?
13:36:55 <Heffalump> yaxu1: I guess. Now I think about it more I'm less negative about the 'type-level' bit, it does make some sense.
13:37:18 <Heffalump> btw perhaps "defined in formal terms" would be better as "defined in terms of those constructs"
13:37:45 <Heffalump> (btw the last 'pattern' in that sense should be plural)
13:37:54 <Gwern-away> hm, would automata be more Control or Data categories?
13:37:56 <Gwern-away> data I guess
13:38:02 <alexyk> Heffalump: OK you promise that if I put the 6.12 ghc-pkg ahead of 6.10's and say cabal update, it won't mess up my ~/.cabal?
13:38:15 <yaxu1> Heffalump: OK thanks, this is for a music computing audience rather than computer science so a bit of handwaving is fine
13:38:23 <Heffalump> alexyk: make sure that ghc itself is ahead too, not just ghc-pkg.
13:38:31 <Gwern-away> pfft, cabal init doesn't know how to generate a lgpl2.1 LICENSE
13:38:37 <alexyk> Heffalump: yep, their bin/ is
13:38:40 <Heffalump> and depends on how strong a promise you want :-) I do it all the time and it doesn't, so I'd be rather surprised.
13:38:50 <Heffalump> but I'm not offering to come round to your house and fix it if I'm wrong ;-)
13:38:51 <ManateeLazyCat> I think Mac users don't like gtk+ (aslo gtk2hs) until someday gtk+ have native appearance in Mac.
13:38:55 <Gwern-away> and it errored out with an empty .cabal!
13:38:57 <Gwern-away> zomgwtf
13:39:11 <alexyk> Heffalump: indeed I'm not making my house available for ghc repairs :)
13:41:21 <w3rs> hi all. got problem installing yi (from cabal-install). googled for it, found the same case at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26119
13:41:33 <ManateeLazyCat> But it's okay since gtk2hs can install easily by cabal
13:41:36 <alexyk|yes-way> ok, running new cabal has overwritten ~/.cabal/config.
13:42:06 <alexyk|yes-way> and reverted to no profiling.
13:42:31 <sclv> w3rs -- you got the dread diamond dependency.
13:42:34 <alexyk|yes-way> cabal update shoulda warn about that (wink toward the haskell-platformers)
13:43:01 <alexyk|yes-way> "all your hand-crafted uncommenting in .cabal/config will be lost, y/N?"
13:43:04 <sclv> check the cabal of yi and see what the version bounds it specifies on data-accessor-transformers are
13:43:29 <sclv> erm, data-accessor-monads-fd that is
13:43:50 <Heffalump> alexyk|yes-way: huh? It's never done that to me.
13:43:58 <jmcarthur> me either
13:43:59 <Heffalump> did you have a very old cabal before?
13:44:08 <sclv> if it allows it, try to install with a lower version of d-a-m-f that doesn't have the transformers==2 dependency
13:44:11 <alexyk|yes-way> Heffalump: I had a cabal from 6.10!
13:44:30 <Heffalump> that's, errm, unexpected
13:44:34 * alexyk made peace with Gwern's -away
13:45:01 <alexyk> Heffalump: ominous!  Start your ghc repair truck and point it toward the NH/VT border!
13:45:39 <Heffalump> I'll need to start with the channel tunnel, and then wait for the Bering Strait to freeze over.
13:45:54 <Heffalump> I could be some time..
13:46:15 <alexyk> how do I reinstall with cabal after updating config to profile?
13:46:24 * gwern changes nick just to annoy alexyk 
13:46:25 <Heffalump> with great pain
13:46:32 <Heffalump> you can use --reinstall for each package, but it won't chase deps
13:46:42 <Heffalump> unless something's changed recently, which it might have, as others have complained about this
13:46:54 <alexyk> Heffalump: well I caught it on the very first one
13:47:24 <alexyk> Heffalump: wow!  Our former Soviet colony! :)
13:47:24 <jkramer> Ahoy
13:47:38 <alexyk> Heffalump: (kidding)
13:48:08 <jkramer> Is there a tool for haskell that can show me reduction steps? Maybe some kind of debugging mode for ghci or something
13:48:21 <dons> e.g. the ghci debugger?
13:48:30 <dcoutts> alexyk: huh? cabal does not overwrite old config files
13:48:31 <dons> http://www.haskell.org/ghc/docs/6.10.4/html/users_guide/ghci-debugger.html
13:48:46 <jmcarthur> RyanT5000: planning to seek that written consent from apple mentioned in the new sdk rules to use ghc-iphone?
13:49:23 <RyanT5000> jmcarthur: i've started looking into it
13:49:37 <jmcarthur> just curious
13:49:39 <alexyk> Heffalump: or where are you?
13:49:42 <gwern> dcoutts: incidentally, any idea why 'cabal init' crashes when there's a 'tests.hs' file?
13:49:56 <dcoutts> gwern: no idea, got any more details?
13:49:59 <Heffalump> alexyk: the channel tunnel refers to the English channel
13:50:04 <RyanT5000> jmcarthur: yeah, apple's not being especially forthcoming with details
13:50:10 <jmcarthur> :(
13:50:19 <RyanT5000> and they're now under investigation for a number of things by the FTC, or so i've heard
13:50:20 <alexyk> Heffalump: but your domain shows as .li!
13:50:23 <dcoutts> alexyk: btw, yes you can have packages from ghc 6.10 and 6.12 installed at the same time with the same ~/.cabal stuff
13:50:24 <jmcarthur> ah
13:50:28 <Heffalump> alexyk: it's just a vanity domain
13:50:32 <RyanT5000> so we'll see
13:50:33 <jkramer> dons: Can it show me reduction steps?
13:50:40 <alexyk> Heffalump: ah ok, I felt nostalgic for a moment
13:50:44 <jkramer> Looks like it only allows me to trace source and step through it
13:50:46 <dcoutts> alexyk: for example I've got 5 versions of ghc and lots of packages for each one
13:50:53 <dons> jkramer: you can step through the reduction
13:50:56 <Heffalump> also, if you think .li is Lithuania, it's not
13:51:03 <Heffalump> it's Liechtenstein
13:51:09 <ManateeLazyCat> RyanT5000: Nothing can change Apple's closed :)
13:51:10 <jkramer> I'm looking for a tool that can show me execution/reduction paths like this: http://pastie.org/1004419
13:51:24 <alexyk> dcoutts: that's cool.  after compiling haskell-platform and installing it, and saying cabal update, looks I got a new .cabal/config anyhow.
13:51:27 <RyanT5000> ManateeLazyCat: well, if anything can, it's a government investigation :P
13:51:38 <dcoutts> gwern: ah cabal: ModuleName.fromString: invalid module name "tests"
13:51:41 <alexyk> how I I verify cabal built profiling versions>
13:51:44 <alexyk> ?
13:51:45 <gwern> right
13:51:46 <sclv> jkramer: http://www.haskell.org/hat/
13:51:47 <jmcarthur> RyanT5000: get enough developers now?
13:52:07 <sclv> don't know how maintained it is. there are a few other projects along those lines.
13:52:16 <dcoutts> alexyk: you didn't delete the ~/.cabal dir or anything? any idea why the old file might have disappeared?
13:52:18 <alexyk> Heffalump: ah ok, the Red Army didn't get that far; I thought of .ly.  I'd feel nostalgic if I kept the money in .li, but alas! :)
13:52:18 <Saizan> jkramer: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=reverse+[1,2,3]
13:52:31 <ManateeLazyCat> RyanT5000: Sorry, my chinese friend won't join your team. 
13:52:35 <dcoutts> alexyk: it only makes a new config when there is none present already
13:52:51 <RyanT5000> ManateeLazyCat: yah, i talked to your friend a lot; we may end up collaborating in the future, though
13:52:51 <sclv> here's another. http://hackage.haskell.org/package/GHood
13:53:05 <Saizan> jkramer: be careful though, it doesn't implement sharing accurately
13:53:14 <ManateeLazyCat> RyanT5000: BTW, he love your ghc-iphone. :)
13:53:15 <RyanT5000> jmcarthur: yeah, we've found a lot of people; i'm still in the process of getting back to everyone who emailed applying
13:53:15 <dcoutts> alexyk: you can ask cabal to build profiling versions by putting the appropriate setting in your ~/.cabal/config file
13:53:28 <jmcarthur> RyanT5000: awesome!
13:53:33 <alexyk> dcoutts: right, I just want to verify it did after I did.
13:53:39 <jkramer> sclv, Saizan: Aww, sweet, both look pretty much like what I was looking for
13:53:44 <jkramer> Will give both a try, thanks
13:54:04 <zygoloid> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+tails+[]+%3D+[[]];+tails+(x:xs)+%3D+(x:xs):tails+xs+in+tails+(reverse+[1,2,3,4])
13:54:16 <zygoloid> ^^ not a strictly-speaking correct answer :-/
13:54:25 <dcoutts> alexyk: oh then try compiling some code in profiling mode and using that package 
13:54:56 <jkramer> Saizan: You mean sharing as in pointers to finished executions in different places?
13:55:18 <alexyk> ah ok, --reinstall scrolls things by twice
13:56:08 <Saizan> jkramer: as in the fact that e.g. it computes (double 5) twice here http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+double+x+%3D+x+%2B+x+in+double+(double+5)
13:56:11 <jmcarthur> RyanT5000: if you need anything generic (not ipwn specific but relevant to game dev in haskell) done ask me about it. if i will end up needing it myself i'd likely be willing to work with you on it on some spare time
13:56:20 * ManateeLazyCat Flash is suck in Linux, always crash....
13:56:24 <Saizan> zygoloid: it's a bit long, why not in particular?
13:56:30 <jmcarthur> s/done ask/done, ask/
13:56:40 <Heffalump> ManateeLazyCat: it always crashes in Windows, in my experience
13:56:40 <zygoloid> Saizan: look at the answer. it's missing parentheses
13:56:54 <ManateeLazyCat> Heffalump: It's always crash in everywhere.
13:57:05 <jkramer> Saizan: Yeah, that's what I meant. But I think I can live with that :)
13:57:07 <gwern> I wonder how many modules specify RankNTypes rather than Rank2Types because that's the only one that the ghc error message mentions?
13:57:11 <Saizan> > 4 : 3 : 2 : (:) 1 [] : []
13:57:12 <lambdabot>   No instance for (GHC.Num.Num [t])
13:57:12 <lambdabot>    arising from a use of `e_14321' at <in...
13:57:16 <RyanT5000> jmcarthur: cool; there's a lot of stuff that we can do to improve Haskell as a game dev platform
13:57:21 <Saizan> > (4 : 3 : 2 : (:) 1 []) : []
13:57:22 <jmcarthur> definitely
13:57:22 <lambdabot>   [[4,3,2,1]]
13:57:28 <Saizan> zygoloid: i see :)
13:57:29 <ManateeLazyCat> Heffalump: I try to disable Flash in my webkit browser even i make it running in separate process like Chrome
13:58:41 <systemfault> I never had any problem with flash on windows.
13:58:56 <systemfault> It's a nightmare on osx and linux though
13:59:10 <ManateeLazyCat> systemfault: Adobe is too lazy
13:59:29 <zygoloid> i've found flash has started to work almost flawlessly in linux in the past few months
13:59:37 <zygoloid> fullscreen video is still laggy though
13:59:41 <jmcarthur> they've dropped the 64 bit linux beta of it :(
13:59:42 <ManateeLazyCat> systemfault: I think most those crashes can avoid if they're test completely.
14:00:00 <djahandarie> Hm, maybe making a game would be kind of interesting in Haskell
14:00:09 <alexyk> if I had a stacj overflow, will -K5G be safe to throw at it?
14:00:11 <systemfault> jmcarthur: Well, flash 10 64bit for linux was lagging bad.
14:00:12 <djahandarie> There's a weekend project :D
14:00:17 <jmcarthur> yeah
14:00:23 <djahandarie> Give me some time to play with FRP more
14:00:32 <ManateeLazyCat> jmcarthur: What's do you mean? Adobe don't support 64 bit linux ? I found they release a beta version.
14:00:42 <jmcarthur> ManateeLazyCat: they did, but they recently dropped it
14:00:47 <alexyk> how should I gauge -A10G -K5G w.r.t to each other?
14:01:06 <ManateeLazyCat> jmcarthur: Unfortunately, they drop Flash to develop html5 ?
14:01:14 <ManateeLazyCat> Joking... :)
14:01:14 <jmcarthur> djahandarie: of course FRP is not strictly needed for games in haskell :)
14:01:21 <jmcarthur> ManateeLazyCat: :P
14:02:00 <ManateeLazyCat> jmcarthur: I prefer to disable Flash in my Webkit browser if flash crash every 5 minutes that crazy me.
14:02:22 <Saizan> alexyk: i don't think they are so much related
14:02:43 <alexyk> Saizan: but what's the order of magnitude of stack do I need vs heap?
14:02:55 <alexyk> when I ran out stack, it says it had a default of 10M
14:03:07 <Saizan> a stack overflow is usually a bug.
14:03:21 <Saizan> and -K is only a maximum limit
14:03:22 <Saizan> iirc
14:03:35 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26170#a26170
14:03:36 <jmcarthur> yeah simply increasing the stack size isn't just dodging the real issue (and usually won't help anyway, in my experience)
14:03:39 <dafis> alexyk, heap oughtto be much larger than stack
14:03:43 <gwern> thoughts on this kind error I ran into with automata? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26170#a26170
14:03:43 <jmcarthur> *is just
14:04:39 <gwern> I'm particularly confsued since that typeclass seems to need 2 args: 'class (Eq  a, Monoid  c) => CollX c a | c -> a where' according to http://hackage.haskell.org/packages/archive/EdisonAPI/1.2.1/doc/html/Data-Edison-Coll.html#t%3ACollX
14:04:43 <Saizan> the stack limit is artificial anyhow, it's only there to catch such bugs rather than thrashing your machine :)
14:04:47 <ville> Anyone with an example of using Gtk ComboBox and adding a model and cell renderer to it manualy? All the examples I have managed to unearth with google either create it with the model or use the 'text' interface
14:05:27 <ManateeLazyCat> ville: I recommend you download darcs version.
14:05:42 <ManateeLazyCat> ville: Then you will found many demo about in treelist directory. 
14:05:51 <ville> ManateeLazyCat: darcs version of gtk2hs you mean?
14:06:06 <ManateeLazyCat> ville: Yes, we forgot add demos in gtk2hs-0.11, unfortunately
14:06:12 <Saizan> gwern: yeah, CollX wants 2 arguments, but both of kind *
14:06:25 <Saizan> gwern: while your set has kind * -> *
14:06:30 <ManateeLazyCat> ville: In darcs version, have many demos in directory "gtk/demo/treelist"
14:06:48 <ville> ManateeLazyCat: I've /usr/share/docs/gtk2hs/demos/treeList
14:07:05 <ManateeLazyCat> ville: I think you forgot to handle TreeViewColumn.
14:07:57 <ville> ManateeLazyCat: Seems like I've 0.10.1 installed
14:08:12 <ManateeLazyCat> ville: For build a TreeView, you need : TreeView + TreeViewColumn + TreeModel + CellRenderer
14:08:25 <ManateeLazyCat> ville: Which OS do you use?
14:08:53 <gwern> Saizan: but it's just a variable used in the type sig, I don't specify that 'set' takes an arg
14:08:55 <ManateeLazyCat> ville: I recommend you use command "cabal install gtk2hs-buildtools && cabal install gtk" to install gtk2hs-0.11
14:09:08 <ManateeLazyCat> ville: And make sure "~/.cabal/bin" in your PATH.
14:09:12 <w3rs> sclv: erm, yi depends on data-accessor-monads-fd == 0.2.* , and d-a-m-f-0.2.0.1 (minimal) depends on transformers-0.2.* (while yi requires transformers-0.1.*)
14:09:20 <ville> ManateeLazyCat: I'm on Arch Linux, rather not use cabal to install things
14:09:31 <ville> ManateeLazyCat: and stick with the platform's package manager.
14:09:42 <dcoutts> ville: the new gtk package is in arch so you're ok
14:09:43 <ManateeLazyCat> ville: Why not use Cabal?
14:10:00 <ManateeLazyCat> ville: Now all gtk2hs package install by Cabal.
14:10:19 <ManateeLazyCat> ville: Don't like gtk2hs-0.10 need do some "configure && make ... " thing.
14:10:40 <jmcarthur> i use cabal-install only if there is some reason i can't just use bauerbill
14:10:47 <Saizan> gwern: the kind is inferred from your use of set: "... => set st -> .."
14:11:10 <ville> ManateeLazyCat: I just prefer to stick with my distro's package management, less worrying that way.
14:11:31 <sclv> w3rs: bizarre. I have yi 0.6.2.2 installed with data-accessor-monads-fd-0.2 and transformers 0.1.4.0 and everything works fine.
14:11:31 <ManateeLazyCat> ville: I recommend you read "GTK+ 2.0 Tree View Tutorial" by Tim-Philipp before you write TreeView code with gtk2hs.
14:12:04 <ManateeLazyCat> ville: TreeView is little complicated than other widget in Gtk+
14:12:58 <gwern> Saizan: is there any easy fix?
14:13:00 <ville> Anyway I've a column and I've my ComboBox but call to treeViewAppendColumn combo column doesn't wish to compile.
14:13:18 <eurehot> whoa, RWH is quite large... does that "mindset" include chapters from 7 on? or are small applications (if we can call the apps lolz) enough?
14:13:38 <Saizan> w3rs: having problems installing yi? try this: --constraint="data-accessor-monads-fd == 0.2" --constraint="data-accessor < 0.2.1.3"
14:13:42 <aristid> eurehot: the crazy thing is that it still only covers a small part of the haskell universe.
14:14:13 <kmc> s'pose that within an IO action i'm doing things like parsing, which can fail for purely computational (not IO-related) reasons
14:14:24 <kmc> any thoughts on using ErroT e IO versus "real" exceptions to model this?
14:14:46 <eurehot> aristid: youre scaring me
14:14:49 <Saizan> gwern: use "S.CollX (set st) st" maybe? not sure if it makes sense but it should typecheck.
14:14:49 <ville> Isn't ComboBox supposed to be also a tree view?
14:15:02 <dcoutts> kmc: it's a perfectly sensible strategy to use pure error handling for pure errors, and to use exceptions for IO errors
14:15:08 <jmcarthur> if it's an error condition generated by pure code then i would not use exceptions
14:15:23 <kmc> that's how i'm doing it currently
14:15:37 <w3rs> Saizan: thanks, seems this helped :)
14:15:37 <Reygun> hi! gusy
14:15:40 <kmc> but it seems like it's just more effort to accomplish something that's already in IO
14:15:47 <dcoutts> kmc: as for errors generated in IO but by pure functions inside, well that's a judgement call
14:15:55 <jmcarthur> kmc: does it even need to be in IO in the first place?
14:16:17 <kmc> sort of
14:16:20 <kmc> in a very local sense, no
14:16:34 <dcoutts> kmc: e.g. you could quite legitimately say that a function that's supposed to read and parse a file format could throw an IO exception if the format is wrong.
14:16:46 <kmc> yeah, that's the situation i'm in
14:16:58 <jmcarthur> palmer_ == luqui ?
14:17:01 <gwern> Saizan: yes, it does seem to typecheck, but then, it immediately errors out on something else, so dunno if it makes global checks pass
14:17:02 <kmc> this is a small project and it's not worth it to factor out the parser and provide it separately
14:17:11 <kmc> so it's all within IO, from the user's perspective
14:17:11 <Reygun> O.O
14:17:12 <palmer_> nope :p
14:17:14 <Reygun> wtf
14:17:17 <dcoutts> kmc: then just have it fail in IO
14:17:27 <jmcarthur> kmc: whichever is more covenient i guess
14:17:30 <jmcarthur> *convenient
14:17:32 <kmc> yeah
14:17:36 <Reygun> my tab key not  avalaible?
14:17:48 <kmc> i'm mainly wondering if people have experience as to one approach or the other turning out well or poorly
14:17:58 <kmc> particularly for non-obvious reasons
14:18:04 <jmcarthur> palmer_: alright, just wondering (luqui == Luke Palmer)
14:18:35 <palmer_> hehe.  nope.  just another sf dev lurking. :p
14:18:44 <jmcarthur> kmc: as a client of your interface, i would not be annoyed if an IO action throws exceptions
14:19:15 <alexyk> well ghc 6.12 segfaulted much earlier than 6.10.  So much for progress!
14:19:22 <dcoutts> jmcarthur, kmc: right, that's the important consideration
14:19:34 <alexyk> is 6.10.4 q trusted and true vs 6.12 greener?
14:19:50 <dcoutts> alexyk: no both work, something is just odd with your setup :-)
14:20:49 <alexyk> dcoutts: right, I mean the executable segfaults much faster under 6.12.  Under 6.10 it marched upon a death by "strange closure" after 20 days of data, 6.12 just segfaults after 12
14:21:08 <alexyk> the executable produced by
14:21:11 <jmcarthur> alexyk: using any FFI libs?
14:21:17 <ManateeLazyCat> ville: Looks "gtk/demo/menu/ComboDemo.hs", it has all your need. :)
14:21:23 <dcoutts> alexyk: ah ok, that's a bit different.
14:21:32 <alexyk> jmcarthur: using tokyocabinet-haskell but it it pure Haskell I believe
14:22:02 <jmcarthur> alexyk: it says it's a binding
14:22:38 <alexyk> jmcarthur: sorry I don't use it after dumping back with Data.Binary, so this one is no FFI
14:22:50 <ManateeLazyCat> ville: You just need use comboBoxEntryNewText create comboBox, then use comboBoxAppendText add String List.
14:23:06 <jmcarthur> alexyk: you are sure that it's not being used lazily?
14:23:12 <ville> ManateeLazyCat: Can't. I get the ComboBox out from GtkBuilder.
14:23:24 <dcoutts> alexyk: or that it's not already corrupted the heap when you initially use it
14:23:27 <jmcarthur> (i don't know what this library does. i'm just checking)
14:23:27 <gwern> arggh
14:23:34 <alexyk> jmcarthur: I cut it out of the executable :)
14:23:37 <gwern> I'm going to have to modify every freaking type sig at this rate
14:23:47 <jmcarthur> wait... cut it out?
14:23:48 <alexyk> I have a separate program to redump as Data.Binary
14:23:53 <jmcarthur> ah
14:23:58 <alexyk> so the main processing just loads it back anew
14:24:00 <dcoutts> alexyk: try compiling with the debug rts and run that
14:24:12 <alexyk> dcoutts: +RTS what?
14:24:16 <ManateeLazyCat> ville: I'm not recommend use GtkBuilder build gtk2hs program, special when you don't know how it to work.
14:24:32 <dcoutts> alexyk: when linking with ghc, use -debug, it links in the debug version of the rts
14:24:41 <alexyk> ok
14:24:56 <alexyk> so ghc --make -debug -fforce-recomp will do it?
14:24:57 <ManateeLazyCat> ville: Looks the source code ComboDemo.hs.
14:25:15 <jmcarthur> alexyk: hmm... have you been compiling with optimizations?
14:25:23 <alexyk> jmcarthur: yep, -O2
14:25:32 <jmcarthur> alexyk: okay, just checking in regards to your performance
14:26:19 <alexyk> I'm sure I have some egregious thunk-spewing line somewhere, just have to find where :)  I'll run with -debug first, then will profile the heap
14:26:31 <alexyk> "the heap eaters" <-- a Haskell rock band
14:26:37 <jmcarthur> if you are segfaulting it's handle that first ;)
14:26:46 <jmcarthur> *i'd
14:27:13 <ManateeLazyCat> ville: And more important is, you need hang your own function on signal `onEntryActivate` (entry of ComboBox).
14:27:46 <ville> ManateeLazyCat: yes that's all fine, none of that however shows how to use the normal interface not specific to text.
14:27:56 <gwern> (man, I am so guessing on these type changs. it'll be a miracle if it ever compiles, much less works)
14:28:45 <alexyk> is -O2 compatible with -debug?
14:28:51 <alexyk> i.e. desirable?
14:29:35 <blackdog> lastlog quicksilver 
14:29:40 <alexyk> "the type guessers" <-- gwern's rockband
14:29:52 <Twey> Haha
14:30:11 <sinelaw> how about "the undecidables"
14:30:21 <sinelaw> "inspector GADT"
14:30:27 <sinelaw> heh
14:30:41 <blackdog> sinelaw: i think you need "X and the Undecidables". but what should X be?
14:30:56 <gwern> Inspector GADT and his monads
14:30:59 <wli> Either Simon or Oleg
14:31:29 <sinelaw> simon is better
14:31:31 <gwern> hm. we can't use qualified names in an instance definiion?
14:31:56 <ddarius> You pretty much have to be able to.
14:32:29 <gwern> ddarius: but then whence my error?
14:32:36 <ManateeLazyCat> ville: Easy, don't use Entry with ComboBox.
14:32:40 <ddarius> I don't know what your error is.
14:32:50 <gwern> instance (Ord k)   F.Assoc FM k where                                                                            F.toSeq             = toSeq
14:32:57 <gwern> /home/gwern/automata/Tree234Map.hs:199:3:                                                                         Qualified name in function definition: F.toSeq
14:32:57 * ManateeLazyCat Oh, 05:32 am in China
14:33:02 <benmachine> gwern: try toSeq = toSeq
14:33:25 <gwern> benmachine: that's so stupid it just might work
14:33:33 <ddarius> gwern: You can't qualify that name because it is a definition.
14:33:38 <benmachine> gwern: :D
14:33:44 <ddarius> gwern: However, toSeq = toSeq will definitely make a loop.
14:33:53 <benmachine> ddarius: depends
14:34:02 <benmachine> I'm hoping that toSeq on the LHS will be F.toSeq
14:34:09 <benmachine> whereas on the RHS it will be thismodule.toSeq
14:34:20 <dafis> gwern, if it doesn't work, toSeq = This.Module.toSeq
14:34:25 <gwern> ddarius: I know, that's why I'm saying it's stupid
14:34:28 <ManateeLazyCat> ville: I recommend you read some GTK+ ComboBox manual from Google, write code after you understand the principle of ComboBox.
14:35:13 <ManateeLazyCat> ville: It's too late, i need sleep. If you still don't know how to make it work, please send any question to gtk2hs list, we will help you. 
14:35:25 <ManateeLazyCat> Bye all, night! :)
14:36:32 <benmachine> gwern: does it work?
14:36:40 <gwern> benmachine: I'm not sure
14:36:51 <gwern> ask again in 10 minutes when I may've resolved some other issues
14:37:46 * gwern ponders these infinite type errors. the loop of ddarius?
14:38:06 <benmachine> k
14:38:45 <ddarius> gwern: x = x should never cause a type error.
14:39:16 <gwern> the problem is, some of the definitions like 'unionSeq = unionSeq' don't give the infinite type error, but some, like 'lookup = lookup', do
14:39:19 <gwern> hrm
14:39:22 <benmachine> ddarius: what if the two x refer to different things?
14:39:42 <benmachine> gwern: maybe the local lookup is a different type to the qualified one?
14:39:45 <benmachine> *from
14:40:20 <gwern> 'count = count' works, and count is defined locally; just like lookup is
14:40:56 <gwern> and there aren't any type sigs for the functions, so those can't be out of date and conflicting
14:40:57 <alexyk> dcoutts: does -debug affect available memory/slow down things?
14:41:45 <gwern> benmachine: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26170#a26171
14:41:57 <ddarius> Bah, benmachine is right.
14:42:04 <ddarius> (Depending on how you have the import statements.)
14:42:21 <benmachine> :)
14:43:15 * gwern slots in some undefineds to see whether there are any other issues. don't seem to be
14:43:28 <dcoutts> alexyk: yes it slows things down because the rts will be doing lots of assertion checks, especially during GC.
14:43:42 <alexyk> dcoutts: cool
14:43:57 <alexyk> we'll quash that bug like a dirty insect it is
14:43:58 <dcoutts> alexyk: it should find heap corruption earlier than it would otherwise
14:46:44 <gwern> oh wow. look at all these errors
14:46:52 <gwern> blows my scrollback buffer
14:47:50 <gwern> dons: I'm going to give up on this one. edison & ghc have changed too much since 2002 and I don't understand it or all the stuff this library is doing
14:47:59 <gwern> benmachine: if you want what I have so far I can send you it
14:48:30 <benmachine> gwern: my curiosity is only idle
14:48:59 <gwern> dons: if you want it either, too
14:49:00 <lowasser> who's using edison?
14:49:19 <gwern> http://vorlon.case.edu/~lps/software/automata/
14:49:30 <lowasser> hawt
14:49:59 <lowasser> man, now I want to reimplement this
14:50:06 <gwern> (there are limits to how much bitrot can be undone without intimate knowledge)
14:50:11 * hackagebot monadIO 0.9.2.0 - Overloading of concurrency variables  http://hackage.haskell.org/package/monadIO-0.9.2.0 (TrevorElliott)
14:50:27 <gwern> lowasser: you probably would have to
14:50:55 <lowasser> yay, a fun project!
14:51:09 <gwern> (man, nearly 2 hours down the drain.)
14:51:19 <lowasser> awww
14:53:13 * hackagebot orc 1.1.2.0 - Orchestration-style co-ordination EDSL  http://hackage.haskell.org/package/orc-1.1.2.0 (TrevorElliott)
14:54:42 <benmachine> gwern: don't shower for a couple of weeks, that ought to regain you the lost time
14:55:17 <danharaj> ^ it will also improve the potency of your neckbeard powers.
14:56:47 <gwern> what do people have against neckbeards
14:56:59 <gwern> they cover up pale pasty often acne-ridden digusting meat
14:57:24 <gwern> fur makes everything better
14:57:34 <djahandarie> What room did I walk into?
14:57:39 <alexyk> dafis: dons: how about Map.unionWith?  I rely on it a lot, and it's too lazy isn't it?
14:57:42 <monochrom> hairskell
14:57:49 <geheimdienst> gwern: a fact cats have known for long
14:57:53 <gwern> where we wear the hairshirt
14:57:56 <gwern> and beard
14:58:07 <gwern> geheimdienst: exactly! ever see a naked cat or dog? nasty
14:58:16 <benmachine> @remember gwen fur makes everything better
14:58:16 <lambdabot> Done.
14:58:18 <benmachine> oops
14:58:27 <benmachine> @forget gwen fur makes everything better
14:58:27 <lambdabot> Done.
14:58:33 <benmachine> @remember gwern fur makes everything better
14:58:33 <lambdabot> I will never forget.
14:58:34 <danharaj> Unfortunately, neckbeardage seldom improves the aesthetics of a typical open source programmer.
14:58:43 <alexyk> gwern: the boyars opposing Peter the Great's beard-cutting quoted a bishop saying that men shouldn't walk around naked-faced like cats and dogs
14:58:47 <djahandarie> danharaj, what about enterprise programmers?
14:58:48 <benmachine> @quote gwern
14:58:48 <lambdabot> gwern says: wonder what a co-human would be like. would it consume feces and emit steak? you could put a human and a co-human in a circle then
14:58:57 <benmachine> :O
14:59:06 <djahandarie> I think there was a movie about that actually
14:59:08 <benmachine> heh
14:59:14 <djahandarie> Human centipede or something
14:59:16 <benmachine> kiiiind of
14:59:18 <kmc> also an episode of south park
14:59:18 <danharaj> no
14:59:23 <benmachine> less category theory though
14:59:24 <danharaj> cohumans eat cofood
14:59:33 <danharaj> not opfood
14:59:38 <monochrom> the whole environment is cohuman
14:59:47 <hpc> would a cohuman eat cocookies, or just cookies?
14:59:56 <benmachine> okies, surely?
14:59:58 <geheimdienst> co-okies
14:59:59 <monochrom> but back to haskell: the whole environment is cohaskell
15:00:03 <danharaj> okies.
15:00:16 <alexyk> co-okies co-dokies
15:00:54 <geheimdienst> "okies" sounds like the thing a 14-year-old haskell girlie would say
15:00:55 <alexyk> dcoutts: just like it was a ghc 6.10 bug, it's a 6.12 bug! sc: internal error: ASSERTION FAILED: file rts/sm/Storage.c, line 1241
15:01:01 <alexyk> Twitter data wins again
15:01:15 <alexyk> big-ass graph 1, ghc 0
15:02:07 <alexyk> but at each point it comes close to filling my RAM, at 55GB+ or so
15:02:07 * hpc read that as "big ass-graph"
15:02:10 <aristid> geheimdienst: i assume the sample of 14-year-old haskell girlies is large enough to deduct that.
15:02:31 <alexyk> hpc: if Twtter produces what it does, well may be
15:04:16 <geheimdienst> aristid, i'm referring to the _typical_ 14-year-old haskell girlie. there may be exceptions, maybe even sizable diverging minorities in that population
15:04:57 <dafis> alexyk, Map.unionWith is lazy in the value, that might be a problem for you
15:04:57 <aristid> geheimdienst: but how can you make statistically significant assertions about 14-year-old haskell girlies without a sufficiently large sample?
15:05:08 <gwern> alexyk: but dogs and cats don't walk around naked-faced
15:05:54 <gwern> aristid: I fear it is illegal to sample a sufficiently large population of such
15:05:59 <alexyk> gwern: that's what you think; cats think they are naked-faced as it's how they know themselves; if you glue a beard on them, that's anotehr matter
15:06:30 <alexyk> dafis: yep, it's a possible culprit.  OK my cafe closes, will reconnect shortly
15:06:38 <geheimdienst> aristid, why do you keep going on about the sample not being sufficiently large? sounds almost like you think there _are_ not enough of them
15:06:41 <aristid> gwern: you cannot make science illegal!
15:06:55 <gwern> aristid: of course you can. look at nazi science
15:06:56 <gwern> or mad science
15:06:59 <geheimdienst> gwern, "sample" does not mean "eating" or something
15:07:03 <aristid> geheimdienst: it's at least something i cannot rule out.
15:07:10 <gwern> geheimdienst: or something...
15:07:35 <wli> Or American science, where global warming and evolution are illegal.
15:08:05 <aristid> evolution is a product of the devil.
15:08:12 <gwern> nazi science sneers at the devil!
15:08:33 <gwern> (http://en.wikipedia.org/wiki/Irregular_Webcomic!#Themes)
15:08:41 <Saizan> when one is given reduction rules like these http://pastebin.com/BnAP7YkE , does he have to be creative in applying them to subexpressions too? e.g. to reduce "(let x = \y.y in x) (\z.z)" ?
15:08:47 * geheimdienst is a TA at Haskell Curry's Girl School for the Lazy
15:11:09 <monochrom> He does not have to be creative. He just has to be exhaustive.
15:11:40 <aristid> geheimdienst: where all students are 14?
15:12:04 <Saizan> monochrom: i.e. if no rule matches the toplevel expression try the inner ones?
15:12:23 <Saizan> no
15:12:33 <Saizan> i just didn't see let-C ..
15:12:46 <geheimdienst> those that say things like "okies" are mostly 14, yes. the school is for age 12-19
15:13:15 <EvanR-work> school for the barely legal
15:13:20 <Saizan> ah, no, let-C doesn't match because x is not an Answer
15:13:54 <monochrom> this set of rules seems to be convergent. no worries about looping.
15:14:07 <geheimdienst> evanr-work, male teachers and female hot 18-year-old students are no issue. the neckbeards take care of that
15:14:12 <monochrom> it also seems to have unique final answer
15:14:29 <geheimdienst> (theirs. i don't have a neckbeard.)
15:14:39 <hpc> lol
15:14:52 <EvanR-work> i dont
15:14:55 <EvanR-work> because its monday
15:15:17 <monochrom> But you do have to try subexpressions sooner or later.
15:16:04 <monochrom> "let x=N in (\y.B) C" you want to apply let-I to a subexpression
15:16:49 <Saizan> make sense
15:17:02 <Saizan> *makes
15:17:48 <Saizan> so since i'm defining a small-step reducer and i want it to be deterministic i need to fix an order myself
15:43:10 * edwardk waves hello.
15:43:20 <alexyk> I need unionWith'
15:43:30 <alexyk> and unionsWith'
15:43:44 <geheimdienst> hi edwardk. you just missed today's discussion of neckbeards
15:44:00 <geheimdienst> and 14-year-old haskell girlies saying "okies" for okay
15:44:02 <alexyk> and naked-faced cats
15:44:14 <geheimdienst> and beards glued to cats
15:44:34 <alexyk> edwardk: are you one of 'em leftcoasters?
15:46:02 * Axman6 has a neckbeard
15:46:15 <alexyk> bluebeard cats <-- new species
15:46:23 <dafis> alexyk: Are you sure you need unionWith' ?
15:46:46 <alexyk> dafis: or how do we strictify them?
15:46:53 <sshc> Does System.Random work with 32-bit computers?
15:47:26 <alexyk> sshc: did you get one at garage sale?
15:48:06 <dafis> Looking at SocRun, you use unionWith (+) and unionWith (-), I think on Floats, that shouldn't give large thunks
15:48:12 <Axman6> sshc: i should hope so
15:48:50 <edwardk> geheimdienst: i try to live a neckbeard free existence, more of an evil-twin-style goatee man myself.
15:49:00 <dafis> And once unionWith minMax2, on the one hand, I already put bangs there, on the other, it shouldn't give large thunks either
15:49:11 <edwardk> alex: east coaster
15:49:14 * wli got his face lasered
15:49:32 <dafis> sshc, System.Random works fine, albeit slow on 32-bit computers
15:49:37 <alexyk> dafis: but it adds new entries too
15:49:40 <wli> (neck, too)
15:49:57 <alexyk> wli: into a cyborg?
15:49:58 <dafis> alexyk: where?
15:50:14 <alexyk> dafis: if a key is in only one map?
15:50:50 <dafis> alexyk: then the value is taken unchanged
15:51:12 <wli> alexyk: Laser hair removal. No cyborgs.
15:52:46 <alexyk> wli: did it hurt?
15:54:20 <dafis> alexyk: can you do a profiling run for ten days? It would help to see a few profiles.
15:54:39 <alexyk> dafis: yep, I'll do the heap next then
15:54:56 <dafis> alexyk: and -P
15:55:17 <alexyk> dafis: what's -P?
15:55:22 <alexyk> vs -p?
15:55:51 <dafis> alexyk: a little more info, allocation figures in bytes, e.g.
16:01:22 <alexyk> dafis: -hy, -hr, or both?
16:02:14 <dafis> alexyk: if things haven't changed recently, you can do only one of them at a time, I't say -hy first
16:02:24 <dafis> s/I't/I'd/
16:10:37 <alexyk> indeed
16:12:31 <sshc> Does System.Random work with 64-bit computers?
16:12:34 <sshc> I meant to ask that
16:12:43 <dafis> sshc: sure
16:13:03 <sshc> [1~"This implementation uses the Portable Combined Generator of L'Ecuyer [System.Random] for 32-bit computers, transliterated by Lennart Augustsson. It has a period of roughly 2.30584e18."
16:15:02 <dafis> sshc: that refers to the algorithm used, it might mean it wouldn't work on 16-bit computers
16:18:58 <zeiris> How does Haddock determine the package.conf.d directory? It's seeing an out of date path from an old installation, but I know the correct path via "ghc-pkg list".
16:18:59 <alexyk> my grandgrandpa had an 2-bit computer... worked on steam
16:19:32 <edwardk> alexyk: mah, valve must have been around longer than a thought ;)
16:20:36 <edwardk> they must have had a blast distributing such awesome games as 00, and 10
16:21:17 <zeiris> It looks like the Haddock path problem is a hard-coded bug of some kind, since it doesn't point to any version of GHC I've ever installed :(
16:21:23 <zeiris> I don't even -have- an E drive.
16:22:34 <Saizan> zeiris: i think it reconstructs the path from haddock --print-ghc-libdir
16:22:45 <ddarius> alexyk: Two WHOLE bits?!
16:22:57 <Saizan> zeiris: ah, i've seen people report something like that before
16:23:04 <alexyk> ddarius: it was a sawing machine :)
16:23:14 <alexyk> I think it's worth 2 bits
16:24:19 <ddarius> Such excesses boggle the imagination.
16:24:37 <edwardk> ddarius: well, they could only get one of them to work at any given time. his grandgrandmama used to call it a lighthouse but his great grandpa wouldn't hear any of that. 
16:24:45 <zeiris> Saizan: yeah, there's occasional mentions but no fixes yet. Today's post on comp.lang.haskell.cafe suggests someone's on it, though.
16:24:48 <dafis> zeiris, Saizan: http://www.haskell.org/pipermail/haskell-cafe/2010-June/078914.html
16:29:21 <Saizan> zeiris: ah, i'd try with -B path/to/lib/ghc-$yourver/
16:29:35 <zeiris> Trying variations of that now. Space in the filepath.... Ugh.
16:30:47 <zeiris> Hm. Slight step forward: now it gives a Warning: could not find link destinations for: GHC.Types.Int GHC.Word.Word32 and etcetera.
16:31:30 <dafis> zeiris, that means it doesn't find the haddocks for base
16:31:47 <zeiris> The reason I'm doing this is because Leksah doesn't seem to see any of the modules it should in its window on the right, and froze on first startup. I assume it's due to something to do with Haddock.
16:33:14 <zeiris> So I need to point Haddock to a GHC libdir via -B, and a GHC docdir ?
16:35:07 <dafis> zeiris: --read-interface=foo, iirc, but consult the haddock manual
16:35:38 <dafis> I haven't invoked haddock manually in a long time
16:36:03 <zeiris> I'm doing it manually to figure out why Leksah can't do it automatically :[
16:36:32 <zeiris> I'd nuke the install and re-do, but this -is- a totally clean install I think.
16:38:23 <RyanT5000> so, who maintains the evil mangler - or alternatively, who wrote it?
16:38:45 <zeiris> Hm. Found a potential fish!
16:39:16 <danharaj> The Evil Mangler is the spawn of Shub-Niggurath
16:39:25 <zeiris> The GHC.Paths seems to be the source of this stuff. The four paths it exports are fine... Except docdir, which is "C:\\Programs\Haskell Platform\\2010.1.0.0/base-4.2.0.0"
16:39:40 <zeiris> Is it safe to assume that the final / (which doesn't matchthe formatting of the other paths) breaks everything?
16:39:47 <ddarius> danharaj: It's getting less and less necessary as time progresses.
16:39:47 <RyanT5000> danharaj: lol
16:40:04 <danharaj> ddarius: And with strange aeons, even the Evil Mangler may die.
16:41:03 <dafis> zeiris: It's not safe to assume that, but it's a good candidate
16:41:34 <zeiris> It kinda makes sense. If docdir is broke, things that use it might end up using a default... Which would explain the E:/foo path on a computer with no E drive.
16:41:53 <zeiris> ghc-paths-0.1.0.6 is not in my GHC libdir though o.O Where is it?
16:42:26 <dafis> zeiris: is there something like locate on Windows?
16:42:28 <Saizan> ghc-pkg describe ghc-paths
16:42:44 <zeiris> dafis: yeah, I think 'where' is similar.
16:43:25 <mreh> I've known that as "which"
16:43:46 <EvanR> question. is it possible to prove this statement true: every particular program either halts on a given input or does not halt
16:43:50 <zeiris> Thanks Saizan, looks like it's in a cabal directory.
16:44:10 <mreh> EvanR, yes
16:44:16 <mreh> it's the excluded middle
16:44:22 <EvanR> hmm
16:44:30 <EvanR> thats an axiom?
16:44:38 <Twey> mreh: Not quite  only one mentions the input
16:44:39 <dafis> EvanR, mreh: so intuitionists have a hard time proving that
16:44:43 <mreh> I can provide no counter case
16:44:50 <EvanR> Twey: i meant to put input on the other
16:44:52 <Twey> Oh
16:44:55 <Twey> Then yes
16:45:27 <Twey> p v 卢p
16:45:46 <dafis> In classical logic
16:46:02 <EvanR> for some reason i have a hard time understanding that in practice. its sort of like deterministic chaos, we set this thing up and let it go, but we empirically and theoretically have no idea (yet) whether it will stop. so who says it either does or does not
16:46:22 <mreh> the universe
16:46:26 <EvanR> :\
16:47:24 <ddarius> EvanR: Deterministic chaos is nothing compared to Turing completeness.
16:48:22 <EvanR> ok i guess its logically equivalent to saying that if it stops there is some N the halting step, otherwise there isnt. it cant be both or neither
16:48:50 <mreh> yes, you just can't tell which
16:48:53 <zeiris> How can I change/examine GHC_PATHS_DOCDIR?
16:48:53 * EvanR superficially feels better about it
16:49:17 <alexyk> amazing how slow the run becomes under -hy
16:50:01 <mreh> I just independently discovered the Taylor series
16:50:25 <mreh> I think
16:50:49 <Saizan> zeiris: where are you seeing that?
16:50:49 <mreh> oh no, the Maclaurin series
16:50:52 <monochrom> Note that mathematical "stop" and empirical "stop" are also different.
16:51:26 <monochrom> Or rather, no reason why they must be the same.
16:51:42 <zeiris> Saizan: GHC-paths source is very brief, and defines "docdir = GHC_PATHS_DOCDIR". I'm not sure what the LANGUAGE CPP pragma does.
16:52:28 <chrisdone> Wow, The Haskell Platform solved all my package problems!
16:52:36 <chrisdone> Thanks, dons!
16:52:41 <Saizan> zeiris: ah, that's a placeholder that gets filled in during compilation
16:52:58 <zeiris> Hm. So to change it I would have to recompile GHC.Paths?
16:53:15 <Saizan> zeiris: the Setup.hs script calculates what to put there
16:53:18 <dafis> alexyk: I think -hr is slower
16:53:41 <Saizan> zeiris: yeah, and you'd have to rebuild haddock to use the rebuilt GHC.Paths
16:53:47 <zeiris> Do GHC path-handling functions even have trouble with mixed \\ and / separators?
16:54:35 <monochrom> @remember monochrom testing 
16:54:35 <lambdabot> Done.
16:54:40 <monochrom> @quote monochrom testing
16:54:41 <lambdabot> monochrom says: testing 
16:54:44 <Saizan> i wouldn't think so, but don't cite me on that :)
16:54:57 <monochrom> @forget monochrom testing 
16:54:57 <lambdabot> Done.
16:55:00 <monochrom> @quote monochrom testing
16:55:00 <lambdabot> No quotes match.
16:55:02 <chrisdone> monochrom: nice. go unicode, go!
16:55:25 <monochrom> @remember chrisdone Wow, The Haskell Platform solved all my package problems! Thanks, dons!
16:55:26 <lambdabot> Nice!
16:56:08 <Saizan> heh
16:56:17 <geheimdienst> @quote chrisdone solved
16:56:18 <lambdabot> chrisdone says: Wow, The Haskell Platform solved all my package problems! Thanks, dons!
16:56:46 <djahandarie> haha
16:56:56 <interferon> so if i want to use parsec applicatively, do i always need to manually define an Applicative instance for GenParser?  i'm worried that this will overlap with someone else's definition
16:57:04 <chrisdone> now i can develop with Snap on both linux and os x without trouble
16:59:42 <chrisdone> interferon: alternatively you could write a newtype like MyParser which is just a layer ontop and implements Applicative
16:59:55 <interferon> that's ture
16:59:57 <interferon> *true
17:00:06 <ddarius> interferon: If you are making an application and it overlaps with an instance declaration in another library (which it shouldn't be there) then you can just remove your instance declaration.
17:00:09 <interferon> but i was hoping there was a standard Text.ParserCombinators.Parsec.Applicative i could include
17:00:20 <interferon> maybe i should submit a patch
17:00:21 <ddarius> interferon: Parsec 3 has an Applicative instance.
17:00:30 <interferon> ah i see
17:00:40 <interferon> is it backwards-compatible with 2? 
17:00:58 <monochrom> Yes.
17:01:39 * chrisdone squints at the ghc warnings on his cabal install build log. why you do this, guys?
17:02:47 <ben__> How do I tell cabal to use global settings in config file? It doesn't seem to accept a --global flag.
17:03:22 <ben__> in ~/.cabal/config there is a global config section. How do you tell cabal to use it?
17:03:35 <ben__> help?
17:04:01 <ben__> cabal wiki pages don't seem to talk about it
17:04:37 <Saizan> are you referring to the install-dirs?
17:04:45 <ben__> yes
17:04:56 <Saizan> cabal install --global will use those
17:05:19 <Saizan> and, btw, if you need sudo with that use --root-cmd=sudo
17:05:19 <dafis> ben__, uncomment the line user-installs: True and change True to False
17:05:56 <dafis> user-install
17:05:57 <ben__> ok. 
17:06:15 <ben__> Why doesn't cabal update also accept --global? 
17:06:40 <interferon> silly cabal-install question: how can i get it to choose parsec3 rather than parsec2?
17:06:47 <dafis> ben__, cabal update just grabs the latest index from hackage
17:07:02 <Saizan> interferon: cabal install "parsec >= 3"
17:07:05 <ddarius> interferon: Explicitly request parsec-3.*
17:07:05 <dafis> --global doesn't make sense for that
17:08:27 <zeiris> Where is GHC.Paths.docdir supposed to point, anyway?
17:08:46 <zeiris> Come to think of it, the path I have is broken period. The mixed / and \\ are a secondary concern.
17:08:56 <ben__> Ok. I can see it might not make sense for that, though it's going to my home directory and I might want multiple people to be able to administer. It doesn't make sense for the all to have to cabal update so that they have the list duplicated in their home direictory
17:09:26 <interferon> if i import a package into ghci is there a way to tell which ghc package it was loaded from?
17:10:06 <zeiris> Is there any reason for docdir to point to "C:\\Haskelllibdir\\base-4.2.0.0"?
17:10:10 <dafis> ben__, then you'd need to globally install cabal-install, when you build it via bootstrap.sh, pass that the --global flag
17:10:49 <syzygic> hello everyone
17:11:01 <dafis> hello syzygic
17:11:11 <ben__> ok. that's very helpful
17:11:13 <ben__> thaks
17:12:04 <syzygic> I am running into problems installing gtk2hs using macports.  Can someone help me ;)
17:13:32 <sgillespie> hello
17:14:10 <zeiris> Why would "runghc Setup.hs install" fail to register a package with "ghc-pkg list packagename"?
17:14:12 <sgillespie> How efficient are haskell threads?
17:14:27 <danharaj> sgillespie: Pretty lightweight
17:15:13 <sgillespie> So i'm looking at marlowe's paper on implementing high performance web servers
17:15:24 <dafis> zeiris: could it be a global vs.user thing?
17:15:31 <sgillespie> I notice that he does forkIO on every connection that comes in
17:15:49 <sgillespie> It seems to me, it would be safer to use some sort of a thread pool
17:15:55 <sgillespie> am I missing something?
17:15:57 <c_wraith> forkIO is pretty cheap.
17:16:03 <c_wraith> it's nothing like forking an OS thread
17:16:08 <sgillespie> yeah, i get that
17:16:25 <danharaj> forkOS is the heavyweight one afaik
17:16:30 <syzygic> I can't seem to pin down the problem with my gtk2hs install; When building gtk2hs, it always errors with "*** No rule to make target" on some file, but the file changes all the time. Any suggestions?
17:16:31 <sgillespie> but what if you have several concurrent threads running...does that matter?
17:16:43 <zeiris> dafis: ran it with both --global and --user.
17:16:56 <c_wraith> for a server?  typically you're spending most of your time waiting on IO, in the real world.
17:16:57 <dafis> zeiris: error message?
17:17:30 <zeiris> Hm, no. Installs to Program Files\Haskell, prints "Registering ghc-paths-???..."
17:17:31 <sgillespie> well let's throw away the server part
17:17:40 <sgillespie> for now
17:17:58 <gwern> the cockles of my heart are warmed when I contemplate how many clones of quickcheck there are: http://en.wikipedia.org/wiki/QuickCheck
17:18:12 <geheimdienst> sgillespie, a thread pool is pretty much what he's using. forkIO is similar to creating a Runnable (java's term). then haskell runtime then executes the Runnables on multiple threads. afaik you can change the number of threads in the threadpool via a command line switch when starting your program
17:18:40 <dafis> zeiris: I don't think rebuilding ghc-paths is a good idea
17:18:41 <geheimdienst> so i'm not an expert, but i'd say forkIO is something like http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)
17:18:51 <sgillespie> geheimdienst: are we talking about the -threaded runtime?
17:18:53 <zeiris> dafis: how else do I fix the broken docdir?
17:19:12 <zeiris> I'm 90% sure all the Haddock, and thus Lexah, problems stem from a malformed docdir on the Windows install of Haskell Platform.
17:19:13 <sgillespie> Well, I know java uses OS threads
17:19:23 <zeiris> Make that 99%, since the directory is plain wrong.
17:19:32 <c_wraith> sgillespie, yes, that's the threaded runtime.  but the non-threaded one just uses a single OS thread anyway.
17:19:33 <Saizan> it shouldn't be so bad to rebuild ghc-paths
17:19:41 <dafis> zeiris: I don't know, but reinstalling ghc-stuff might break all kinds of things
17:20:01 <zeiris> More than are already broken? A life without haddock is no life at all :(
17:20:29 <dafis> zeiris: okay, then go ahead and try
17:20:36 <sgillespie> So there is no point threading in non-threaded runtime?
17:20:55 <sgillespie> Also, in RWH, they say that overhead is greater in threaded runtime
17:21:00 <c_wraith> sgillespie, it allows you to program in a more straightforward manner, and it still gives you non-blocking IO.
17:21:06 <geheimdienst> the issue with -threaded iirc is this: without -threaded, if one thread makes a blocking system call, all threads block (the os doesn't see haskell's lightweight internal threads. so as far as the os is concerned, the whole process is now blocked.) if you use -threaded, you can have multiple blocking threads, at the cost of a little more overhead
17:21:18 <zeiris> If I confirm that this is the root of the bugs, I'll try and look for where GHC_PATHS_DOCDIR comes from. First I want confirmation, though.
17:21:25 <alexyk> dafis: do you think Map.insertWith' is better than Map.alter?
17:21:40 <alexyk> dons: ^^?
17:21:52 <dafis> alexyk: never used alter, let me check the sources
17:21:53 <c_wraith> alexyk, Data.Trie does give you folds.  It implements Foldable.  but its implementations of them are SLOW
17:22:00 <sgillespie> so going back to the server example, if you don't use -threaded, then you are essentially building a single threaded server with non-blocking io
17:22:26 <c_wraith> sgillespie, at some level, that's true.  But you're ignoring the advantage that you can write your code as if you were using blocking IO
17:23:06 <sgillespie> yeah, so you could essentially build both types without changing your code
17:23:17 <alexyk> c_wraith: yeah.  My walks over maps are giant folds often, and I need the rich map API.  Representing graph as a map of maps served me well in Clojure and OCaml and I want to keep it that way... for a grand Twitter data shootout to come!  That's noy your granny's puny Fibbonacci numbers shootout.
17:23:29 <alexyk> not
17:24:01 <alexyk> c_wraith: your nick sounds like The Wrath of C, btw :)
17:24:31 <alexyk> behold, you slow ruby serfs, the wrath of C is quick!
17:24:32 <dafis> alexyk: in your uses of alter, can the result ever be Nothing?
17:24:43 <alexyk> never
17:24:52 <dafis> alexyk: If not, insertWith' is definitely better
17:25:07 <alexyk> ok, a few improvements will be due
17:25:10 <sgillespie> So, if I use -threaded, am I creating an OS thread every time I forkIO?
17:25:12 <dons> hey alexyk 
17:25:17 <c_wraith> sgillespie, well, the two runtimes aren't that far apart.  -threaded has the advantage geheimdienst mentioned with regards to blocking system calls, and it allows for utilization of multiple system cores, when the non-threaded runtime doesn't.
17:25:23 <gwern> alexyk: really? I read c_wraith as akin to ringwraith
17:25:34 <Saizan> zeiris: are you sure you've only one installation of ghc? 
17:25:38 <gwern> nine pointers for mortal men, doomed to die...
17:25:38 <c_wraith> sgillespie, No, forkIO is *always* a green thread.
17:25:48 <dons> alexyk: i wish i had time to try your code with bytestring-tries and so on.
17:25:49 <alexyk> hey dons!  the -hy is chugging along, by tomorrow probably it will do something :)
17:25:53 <dons> ha!
17:25:59 <dons> you will have pretty graphs :-)
17:26:05 <dons> and they'll reveal the shape of your heap
17:26:34 <gwern> (in the land of assembler, where the type sigs lie)
17:26:36 <c_wraith> sgillespie, The difference between the two runtimes is that the threaded one maps the green threads over a pool of OS threads.
17:26:39 <alexyk> dons: ghc crashed with internal errors under -debug, it turns out the segfault in 6.12 and "strange closure" and "stack overflow" in 6.10 seems related at the highest RAM usage
17:26:49 <sgillespie> ah, this is good stuff
17:26:53 <dons> alexyk: -debug ?
17:26:54 <c_wraith> sgillespie, Just be aware that the OS thread pool's size defaults to one. :)
17:26:56 <alexyk> I guess this is the results of straining every sinew of it
17:27:07 <alexyk> dons: I ran with -debug after a segfault
17:27:30 <dons> oh, you got a stack overflow?
17:27:35 <sgillespie> interesting
17:27:39 <gwern> alexyk: you bleed on the cutting edge so the rest of us don't have to. kudos
17:28:00 <alexyk> 6.10 crashed with those strange effects or just got stuck and unresponsive to Ctrl-C; 6.12 segfaulted and under -debug confessed to internal error in Storage.c
17:28:25 <dons> you might want to cap the maximum memory footprint (e.g. +RTS -M10G) or so
17:28:27 <sgillespie> okay, thanks for all of your responses, its been very helpful
17:28:29 <alexyk> gwern: tell your kids how we fought together for their bright future
17:28:37 <dons> any segfault is a runtime bug that should be reported, by the way
17:28:38 <dons> ?bug
17:28:38 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
17:28:54 <gwern> alexyk: eine language, eine ghc, eine haskell!
17:28:56 <dons> we really need to get some test data to distribute to people
17:29:04 <sgillespie> so i remember having problems killing threads
17:29:04 <dons> so others can test what you're doing
17:29:15 <sgillespie> am I doing something wrong or is that something I have to deal with?
17:29:16 * dons back later
17:29:18 <alexyk> dons: right, I'll tag it in git for leisure reporting :)
17:29:26 <alexyk> but now have to forge on to victory
17:30:11 <alexyk> gwern: Gott mit haskell! or is it MIT?
17:30:34 <gwern> alexyk: we must have lebenstypes
17:30:35 <dafis> alexyk: Got it with Haskell
17:30:49 <alexyk> dafis: :)
17:31:33 <gwern> @quote liberat
17:31:33 <lambdabot> gwern says: The Java programmers will welcome us as liberators! I estimate that we will need 50,000 haskellers at most and will be able to wind up the occupation quickly
17:31:45 <alexyk> gwern: lebensrecursion!
17:31:54 <gwern> alexyk: that is jew science
17:32:24 <gwern> untermenschen recurse; ubermenschen use appropriate morphisms
17:32:46 <gwern> the latter are built on the former like our empire will be built on jew corpses
17:33:11 <elliottt> why was Data.Array.Diff removed from the array library?
17:33:29 <dafis> elliottt, It was darned slow
17:33:55 <zeiris> If I understand correctly, the docdir points to a root directory where .hi files are located for all the "base" installed modules?
17:33:56 <kmc> use IntMap or EnumMap instead
17:33:56 <elliottt> dafis: was it slow for the current version of the array, or just the older copies
17:34:37 <dafis> elliottt: all versions
17:34:41 <elliottt> if you only ever used the current version, presumably you would be ok
17:34:45 <elliottt> oh, nevermind then.
17:35:10 <jbapple> It's a shame it was slow. I don't understand why it had to be. Dietz demonstrated persistent arrays where access and modification take lg (lg m), where m is the number of operations since the array was initialized
17:35:21 <jbapple> Was it a GC thing?
17:35:25 <dafis> elliottt: usually, switching from Data.Array.Diff to Data.Array gave speedup factors from 10-100
17:35:39 <elliottt> dafis: unfortunately, that's not currently an option
17:35:50 <elliottt> i would use Data.Array in a second if i wasn't constrained to Monad m :)
17:36:15 <zeiris> Do people not program in Haskell on Windows or something? As far as I can tell, Haddock from the Haskell Platform simply doesn't work on Windows :[
17:36:23 <dafis> jbapple, I've no idea whether it was GC, but I agree that it's a pity it was so slow
17:36:26 <gwern> zeiris: chicken and egg
17:36:44 <zeiris> Indeed, avoid success at all costs and all that.
17:36:56 <dafis> elliottt: how does that allow DiffArrays but not plain arrays?
17:37:08 <elliottt> didn't DiffArray present a pure interface?
17:37:17 <elliottt> normal arrays work in IO
17:37:17 <c_wraith> So do plain arrays
17:37:17 <elliottt> and i'm stuck in Monad m
17:37:26 <c_wraith> MArray is in IO or ST
17:37:33 <gwern> elliottt: there's always monadio too
17:37:34 <elliottt> right, and i can't pick the monad
17:37:40 <elliottt> monadio isn't an option, currently
17:37:41 <c_wraith> but simple copy-on-write Arrays are pure
17:37:46 <jbapple> https://dspace.lib.rochester.edu/fileDownloadForInstitutionalItem.action?itemId=5260&itemFileId=8146
17:37:51 <elliottt> copy on write would kill performance
17:37:52 <djahandarie> DiffArray ARE O(1) aren't they? They would provide speedups -eventually- wouldn't they?
17:38:04 <elliottt> this is a big array with lots of writes
17:38:11 <elliottt> it works well in ST, but i need a monadic interface too.
17:38:25 <elliottt> and unfortunately, the monadic interface is Monad m.
17:38:44 <kmc> is the difference between O(1) and O(log n) going to kill you?
17:38:53 <kmc> because tree-based maps have good sharing
17:38:57 <kmc> and IntMap is pretty fast
17:39:08 <elliottt> yes, that will kill me.
17:39:18 <elliottt> intmap is the current implementation, and it's too slow
17:39:24 <gwern> kmc: when your target is c performance, o(1) and log n are worlds apart
17:39:26 <jbapple> I guess Dietz's arrays are only amortized efficient, and that may not hold in a persistent setting (see Okasaki's book)
17:39:42 <kmc> you profiled it, i assume
17:39:43 <djahandarie> It'd be great if someone made DiffArray actually work fast
17:39:45 <kmc> how many elements are in your map?
17:39:47 <dafis> elliottt: do you need older versions of the array?
17:39:52 <elliottt> dafis, no
17:40:34 <elliottt> but there is an operation in the monad that gets passed into this function, which makes using ST still not an option
17:40:36 <jbapple> Can anybody find a bug report discussing the removal?
17:40:41 <dafis> elliottt: then try runST (do ar <- unsafeThaw pureArray; modify; unsafeFreeze)
17:41:09 <elliottt> dafis: not currently an option, as there is an operation passed in that will be used on the array, that is in m
17:41:31 <c_wraith> That doesn't sound incompatible with that suggestion
17:41:50 <dafis> elliottt: runST inside the other monad
17:41:58 <kmc> how many keys?
17:41:58 <c_wraith> dafis' suggestion is essentially "mutate what looks like a pure array outside"
17:42:21 <ben__> Hi. When I run a global cabal install "cabal install xxxx --global" it creates the library in /usr/local/lib but the global conf directory /usr/local/ghc-6.12.3/packages.conf.d is not updated. How can I find out where cabal is registering the package?
17:42:49 <djahandarie> Here is the bugreport for splitting diffarray http://hackage.haskell.org/trac/ghc/ticket/3370
17:43:30 <dafis> ben__, turn up the verbosity?
17:43:33 <jbapple> http://hackage.haskell.org/trac/ghc/ticket/2727
17:43:35 <elliottt> dafis: that would involve interleaving operations in m, and ST
17:43:35 <heatsink> elliottt: Will you ever want to run in a monad that re-executes code (backtracking, nondeterministic choice, call-with-current-continuation, etc.)?
17:43:46 <elliottt> heatsink: no backtracking
17:43:54 <elliottt> it's just a loop.
17:44:04 <c_wraith> elliott, that interleaving is mostly in the type system.
17:44:05 <ben__> cool the man page on cabal doesn't mention debug/verbose flags. 
17:44:11 <elliottt> actually, now that i think of it, i may be able to get away with using ST to coordinate actions in m
17:44:33 <elliottt> oh wait, no.  the results from the operation are written into the array.
17:44:51 <elliottt> imagine, f :: Monad m => (a -> m a) -> m [a]
17:45:05 <heatsink> It sounds like your code is not intended to be run in an arbitrary monad, so "Monad m" is not a precise enough class constraint.
17:45:17 <elliottt> it isnt.  this is a consequence of a legacy interface
17:45:29 <elliottt> i'm not sure it's within the scope of my current work to change it
17:45:43 <absentia> n/win shrink 3
17:45:54 <dafis> ben__, cabal install -v3 --reinstall --global offending-package
17:46:23 <heatsink> Hmm.
17:46:25 <elliottt> it seems like my best option is to rework the interface, so i'll start investigating that.
17:46:32 <elliottt> thanks for the suggestions, everyone :)
17:46:33 <gwern> legacy haskell?
17:46:37 <elliottt> :)
17:46:41 <gwern> that's a new one on me
17:48:13 <heatsink> Does that mean it's time for another revolution?
17:52:33 <heatsink> Hey, is there a simple example of data families that I can put on the haskellwiki?  RIght now it has generalized tries, which are an excellent example, but too complex for an introductory wiki entry.
17:54:22 <djahandarie> Well there is the page on the GHC user guide for em
17:58:17 <ben__> dafis: Thanks. I found the problem. I installed ghc-6.12.3 from binary release not rpm. cabal was using pkg-config to find ghc so it was using old ghc-6.10 and stuffing it in that package config area
17:59:28 <gwern> heatsink: it's always time for another revolution. 'The revolution devours its children.'
18:00:20 <geheimdienst> the revolution seems to be recursive
18:01:05 <ben__> I used with-compiler to specify /usr/local/bin/ghc executable. now things seem to work except that I'm getting a build error. 
18:04:26 <alexyk> is it possible that -hy causes a problem?  with that, my executable is stuck in the data loading phase, and RAM just grows and grows much beyond what was without -hy at that point
18:07:29 <zeiris> How can I trace -where- haddock gets the non-existant path E:\ghc\ghc-6.12.1\lib\package.conf.d?
18:10:40 <alexyk> is there a better way to get a submap of N keys out of a map than fromList . take N . fromList?
18:10:41 <zeiris> Grepping haddock source for variations thereof suggests it's not even in there... But in some library it uses :(
18:11:02 <heatsink> I don't know where it gets the path from.  A possible culprit is the database used by ghc-pkg
18:11:04 <alexyk> zeiris: a Linux box is cheap nowadays! :)
18:11:14 <alexyk> and its slashes are forward!
18:11:38 <alexyk> \ reads as "anal cranial inversion"
18:11:42 <alexyk> in paths
18:11:58 <alexyk> and results are unpredictable
18:12:02 <zeiris> Yeah, but I need food. And to buy food I need money. And to make money I'd like to write software I can sell.
18:12:12 <zeiris> None of my clients run Linux.
18:12:28 <napping> haddock you say?
18:12:30 * zeiris was waiting for the "just use Linux" comments for two hours now.
18:12:40 <alexyk> zeiris: kidding... writing commercial software in haskell is cool
18:12:43 <monochrom> just use MacOS X
18:12:54 <alexyk> although Dr. Harrop teaches us that F# sells better
18:12:58 <napping> what kind of path?
18:13:23 <dafis> alexyk: Yes, let (k,_) = elemAt n m; split k m
18:13:59 <ben__> How do I tell cabal to use a particular path for hsc2hs? for ghc I could use with-compiler but there is not a similar flag for hsc2hs. Cabal is complaining it can't find it even though it's in /usr/local/bin/hsc2hs. I guess it's using pkg-config. is there a web page that describes how cabal uses pkg-config? I installed ghc 6.12.3 from binary tarball. I ran make install. It installed execs in /usr/local/bin/ . How do I get it to register the 
18:14:01 <ben__> excutables with pkg-config?
18:14:44 <zeiris> napping: "haddock: can't find a package database at E:\ghc\ghc-6.12.1\lib\package.conf.d", which is invalid (E: is a CD drive) and seems to be hard-coded somewhere since there are mentions of others having the same problem.
18:14:54 <alexyk> zeiris: I was holding up well then :) or didn't notice c:\ :)
18:15:20 <zeiris> I thought it was a GHC.Path.docdir problem (which was set to an invalid path) but fixing it hasn't helped. Although I may have screwed up the fix.
18:15:23 <napping> a package database? and ghc-pkg works?
18:15:33 <alexyk> dafis: cool! I trust it won't compute the rest as it takes k only and is lazy split?
18:15:43 <zeiris> Ghc-pkg works fine, cabal-install works great.
18:15:55 <napping> did you build Haddock yourself?
18:16:07 <dafis> alexyk: btw, I forgot the fst, you only want one part of the map
18:16:14 <zeiris> Initially, no, I got it via cabal-install on a clean Haskell Platform install.
18:16:32 <alexyk> dafis: or I can do it in a let and ... in k
18:16:34 <napping> cabal install compiled it, right?
18:16:36 <zeiris> I later re-built ghc-paths to fix docdir, then re-built haddock via cabal-install.
18:16:40 <zeiris> Yes.
18:16:53 <napping> oh, ok. I wouldn't expect it to have bad paths baked in then. Weird.
18:17:09 <Saizan> zeiris: make sure you're using the haddock.exe that you just built, rather than the original one
18:17:17 <napping> You could try running strings on it.
18:17:19 <zeiris> Oh christ, I didn't think of that.
18:17:24 <alexyk> wow, -hy really adds 2 hours to my proggy.  It allocated like 200 TB last time I checked or so
18:17:30 <monochrom> e: was probably someone's extra hard disk :)
18:18:07 <zeiris> 'grep -r "E:" *' on the cabal source doesn't return anything, though. (I'm bad with grep though.)
18:18:49 <ben__> ok. I may have got that wrong re pkg-config. It's using some linux-system executable directory but I don't know which one. 
18:18:52 <dafis> alexyk: split is lazy enough, if you only want the first component, it won't build the second
18:19:10 <alexyk> good, good.  I start seeing the y in lazy
18:19:15 <ben__> How do I find out how cabal finds executables?
18:19:19 <dafis> alexyk: what do you mean 'can I do it in a let'?
18:19:41 <alexyk> dafis: just saying I won't need fst, I'll say let (k,_) = ... in k
18:19:50 <alexyk> sorry, fst of the whole, right
18:19:53 <alexyk> k is just key
18:19:54 <zeiris> Saizan: I had a second haddock.exe :'(
18:20:05 <monochrom> cabal probably doesn't find executables at all
18:20:19 <dafis> ben__, safe way to find out is reading the sources
18:20:29 <monochrom> @slap sources
18:20:29 * lambdabot submits sources' email address to a dozen spam lists
18:20:58 <dafis> ben__, but it lets ghc find them, System.IForgotwhichModule
18:20:59 <Saizan> ben__: it looks in the $PATH
18:21:08 <ben__> I think it does. It's not getting them  from path. 
18:21:42 <ben__> It was grabbing an old version of ghc when my path has a ghc in /usr/local/bin
18:22:11 <Saizan> well, it also depends on which one goes first
18:22:20 <ben__> now it can't find hsc2hs in /usr/local/bin/hsc2hs and there's no way to tell it to use a particular path
18:22:46 <Saizan> --with-hsc2hs=/usr/local/bin/hsc2hs
18:22:48 <monochrom> there is also an entry in .cabal/config
18:23:16 <ben__> aah. default config doesn't have that option. missed it on web page. 
18:23:31 <ben__> I'll use that for now and dig into how it finds executables later. 
18:24:12 <Saizan> zeiris: ah, so the new one works?:)
18:24:19 <dafis> ben__, it splits the PATH and looks in all directories until it finds it
18:25:02 <zeiris> Saizan: careful testing in progress. Can find the package now, and Leksah loads metadata now, but I'm trying to figure out why.
18:26:48 <ben__> weird. My path has /usr/local/bin and hsc2hs is in /usr/local/bin but it doesn't find it. 
18:26:50 * hackagebot hstest 0.0.1 - Runs tests via QuickCheck1 and HUnit; like quickCheck-script but uses GHC api  http://hackage.haskell.org/package/hstest-0.0.1 (DaveHinton)
18:26:50 <zeiris> It looks like the busted GHC.Paths.docdir does not cause the error I was having trouble with. It causes a Warning since Haddock can't find the docs to link for stuff like GHC.Word.Word8 and whatnot, but that's not a showstopper.
18:27:08 <zeiris> Trying to reproduce the error again...
18:27:16 <ben__> dafis: what was the code file you looked at?
18:28:42 <dafis> ben__, I dug around in the cabl-install sources a while back, I don't remember which file it was, it called findExecutable, which is in one of the System modules
18:29:37 <ben__> dafis: so it wasn't in the ghc sources. someone else suggested it was calling ghc to find the executable
18:30:14 <dafis> ben__, cabal-install uses the ghc function to find the executables
18:30:21 <monochrom> findExecutable seems to be in System.Directory
18:30:44 <monochrom> it says it uses PATH
18:31:08 <c_wraith> dafis, you know something about hint, right?
18:31:18 <c_wraith> GhcException "\nDuring interactive linking, GHCi couldn't find the following symbol:\n  Site_site_closure\nThis may be due to you not asking GHCi to load extra object files,\narchives or DLLs needed by your current session.  Restart GHCi, specifying\nthe missing library using the -L/path/to/object/dir and -lmissinglibname\nflags, or simply by naming the relevant files on the GHCi command line.\nAlternatively, this link failure might indicate a bug in 
18:31:18 <c_wraith> GHCi.\nIf you suspect the latter, please send a bug report to:\n  glasgow-haskell-bugs@haskell.org\n"
18:31:18 <dafis> monochrom: right and on *nix, the implementation lives in System.Posix, iirc
18:31:20 <monochrom> sometimes "it uses ghc" means "it uses the libs that come with ghc"
18:31:32 <dafis> c_wraith, very little
18:31:32 <ben__> OK. hopefully there's some verbose output that can help me find out why it didn't find my executables. 
18:31:42 <c_wraith> I'm getting that error message about 50% of the time, on exactly the same invocation of hint
18:31:57 <ben__> because if it's just splitting my current path it should have succeeded.
18:32:19 <ben__> regardless I got my compilation to work using the --with-hsc2hs flag as suggested so thanks 
18:32:27 <monochrom> "On Windows, findExecutable  calls the Win32 function SearchPath"
18:32:59 <c_wraith> Is this some sort of race condition?  Does hint compile things to disk somewhere?
18:33:00 <monochrom> but it is a superset of PATH
18:34:01 <dafis> c_wraith, sorry, beyond my ken
18:34:36 <ben__> monochrom: Thanks for the info. I'm on linux so that's not a concern for me.  
18:40:05 <zeiris> It looks like the problem was caused by an old haddock .exe that was left over on my system :[
18:43:15 <zeiris> This explains the occasional errors others have had. Probably dropped haddock.exe somewhere ages ago, and forgot.
18:43:52 <zeiris> The incorrectly set docdir is a separate bug, and probably not a gamebreaking one... Now all I gotta do is figure out how to post to haskell-cafe to complete the thread.
18:44:29 <Saizan> still the E: thing seems gratuitous
18:45:14 <zeiris> That -is- fishy, but it was an old haddock version so who knows what it was doing.
18:55:36 <gwern> did you know that the konami code works on newsweek.com?
18:55:46 <c_wraith> yep
18:55:48 <gwern> up up down down left right left right b a start
18:55:53 <c_wraith> just learned it earlier today
18:55:54 <gwern> *enter
18:55:55 <c_wraith> it's rather funny
18:56:09 <gwern> yes, I agree
18:56:22 <gwern> good advice too. you always should go for the head, unless they're fast zombies
18:56:23 <alexyk> is Data.Map.fold strict, or why isn't there a ...fold'?
18:56:46 <c_wraith> gwern, do you know of any race conditions in hint?
18:57:02 <gwern> c_wraith: sure. all the disk access it does
18:57:12 <gwern> those libraries and files could be changing under your feet
18:57:20 <c_wraith> gwern: does it do writes, though?
18:57:32 <gwern> c_wraith: and I have vague recollection of hint writing out files to deal with the qualified imports issue
18:57:55 <alexyk> or, does Map implement Foldable for foldl'?
18:58:07 <c_wraith> it implements Foldable, yes
18:58:55 <alexyk> and is the foldl' resulting good enough?  strong, fast enough?
18:59:07 <T_S_> Anyone know if is there a generic zip library providing zipWith that will work on Data.Vector?
19:00:00 <chessguy> 'evening
19:00:07 <solrize> hi chessguy
19:00:28 <solrize> i don't remember this happening before: "import Control.Monad.State" gets a name collision.  
19:00:30 <solrize>       it was found in multiple packages: monads-tf-0.0.0.1 mtl-1.1.0.2
19:00:46 <solrize> does some cabal package cause that, and how do i get it to go away?
19:00:46 <gwern> someone was naughty
19:00:57 <c_wraith> solrize, if you installed monads-tf recently, that would start
19:01:01 <gwern> solrize: the quick solution is ghc-pkg hide monads-tf-0.0.0.1
19:01:14 <c_wraith> and gwern's solution is good.
19:01:21 <solrize> ok, trying that
19:01:22 <solrize> thanks
19:01:36 <solrize> worked! 
19:01:47 <solrize> what's the story?
19:02:08 <c_wraith> there are at least three different packages that provide Control.Monad.State.
19:02:26 <c_wraith> If more than one of them is installed, ghc complains that it's visible in multiple spots
19:02:29 <solrize> sigh
19:02:37 <c_wraith> And requires that you tell it which one to use.
19:02:47 <solrize> is there a way to tell it in program text?
19:02:54 <gwern> yes
19:03:03 <c_wraith> Pretend the answer is no, though, since you shouldn't use that extension.
19:03:07 <gwern> but that is a horrible eldritch evil ghc extension I won't even tell you the name of
19:03:13 <solrize> heh, ok
19:03:18 <c_wraith> However, if you use cabal to build your program, that also takes care of it
19:03:30 <c_wraith> cabal is totally worth using. :)
19:03:31 <solrize> i've never really figured out cabal
19:03:37 <solrize> but i keep hearing i should use it
19:03:38 <solrize> :)
19:03:40 <c_wraith> It's easier than ever, thanks to cabal init
19:03:54 <zeiris> Leksah seems like it abstracts away the details of Cabal.
19:03:58 <gwern> oh the wonderful wonderful things the wonderul wizard of cabal does!
19:04:01 <zeiris> Worth a try, if you can deal leaving your standard editor :)
19:04:48 <solrize> leksah?
19:05:34 <gwern> solrize: a sort of IDE for haskell
19:06:05 <solrize> i guess emacs is in my bones
19:06:26 <jon_of_arc> Yeah, it gathers there if you're exposed to it
19:06:50 <solrize> lol
19:07:10 <wlangstroth> (insert profunctory carpal tunnel joke)
19:07:21 <wlangstroth> prefunctory
19:07:26 * jon_of_arc is also irredeemably contaminated with emacs
19:07:31 <gwern> some of us are carps, you insensitive clod!
19:07:55 * wlangstroth desperate for a haddock joke
19:08:15 <gwern> fishy grammar
19:08:27 <wlangstroth> I knew "fishy" would return
19:09:26 * wlangstroth is an aweserome spellinator: perfunctory
19:09:35 <monochrom> "I upgraded ghc and it fried haddock"
19:10:12 <wlangstroth> there apparently IS punning in Haskell
19:10:34 <gwern> > product [1..5]
19:10:35 <lambdabot>   120
19:10:47 <gwern> @wn perfunctory
19:10:49 <lambdabot> *** "perfunctory" wn "WordNet (r) 2.0"
19:10:49 <lambdabot> perfunctory
19:10:49 <lambdabot>      adj 1: hasty and without attention to detail; not thorough; "a
19:10:49 <lambdabot>             casual (or cursory) inspection failed to reveal the
19:10:49 <lambdabot>             house's structural flaws"; "a passing glance";
19:10:51 <lambdabot> [3 @more lines]
19:11:02 <gwern> third time was the charm
19:11:16 <chessguy> i think @wlangstroth meant to say 'obligatory'
19:11:18 <solrize> when writing a monad transformer stack how do you decide which monad is the inner and which is the outer?
19:11:27 <solrize> e.g. WriterT State vs StateT Writer
19:12:04 <sshc> Does there exist a version of the 99 exercises without the solutions?
19:12:05 <solrize> i guess WriterT State is the one that makes sense
19:12:06 <wlangstroth> chessguy: nope, "perfunctory" in humour being a "gimme" joke
19:12:19 <sshc> I like to look at the next few exercices without risking viewing the solution beforehand
19:12:29 <chessguy> hm. i've never heard it used in that context, but ok
19:12:40 <monochrom> sometimes the order doesn't matter. sometimes the order matters but you know from your goal
19:12:57 <gwern> hm. sicp uses two exercises where the function only varies by 0/+ and 1/*
19:13:01 <Saizan> in your case it doesn't matter.
19:13:03 <gwern> time for a digression on monoids!
19:13:42 <monochrom> ErrorT State is markedly different from StateT Error. But WriterT State and StateT Writer are too similar.
19:14:40 <gwern> > mconcat [1..5]
19:14:40 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:14:40 <lambdabot>    `Data.Monoid.Monoid a'
19:14:40 <lambdabot>  ...
19:14:43 <monochrom> and between ErrorT State and StateT Error you just ask yourself a skill-testing question: when error occurs, do you want to keep or throw away state?
19:14:44 <gwern> > mconcat [1..5] :: Product
19:14:45 <lambdabot>   `Data.Monoid.Product' is not applied to enough type arguments
19:14:45 <lambdabot>  Expected kin...
19:14:59 <gwern> > mconcat [1..5 :: Product]
19:14:59 <lambdabot>   `Data.Monoid.Product' is not applied to enough type arguments
19:15:00 <lambdabot>  Expected kin...
19:15:06 <gwern> bah
19:15:07 <heatsink> mconcat $ map Product [1..5]
19:15:16 <heatsink> > mconcat $ map Product [1..5]
19:15:17 <lambdabot>   Product {getProduct = 120}
19:15:20 <gwern> oh
19:16:06 <ddarius> > 1 :: Product Int
19:16:07 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Product GHC.Types.Int))
19:16:07 <lambdabot>    arisin...
19:16:11 <ddarius> God dammit.
19:16:22 <gwern> ?src Monoid
19:16:22 <lambdabot> class Monoid a where
19:16:22 <lambdabot>     mempty  :: a
19:16:22 <lambdabot>     mappend :: a -> a -> a
19:16:22 <lambdabot>     mconcat :: [a] -> a
19:17:56 <Saizan> monochrom: skill-testing?
19:19:21 <gwern> @hoogle (+)
19:19:22 <lambdabot> Prelude (+) :: Num a => a -> a -> a
19:19:22 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
19:19:22 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
19:19:26 <gwern> @hoogle (*)
19:19:26 <lambdabot> Prelude (*) :: Num a => a -> a -> a
19:19:26 <lambdabot> Prelude (**) :: Floating a => a -> a -> a
19:19:26 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
19:21:11 <monochrom> to make it sound easier
19:21:20 <gwern> @src mconcat
19:21:20 <lambdabot> Source not found. Where did you learn to type?
19:21:47 <wlangstroth> whoa lambdabot
19:22:38 <wlangstroth> lambdabot needs some anger management
19:23:18 <monochrom> You have just seen her anger management.
19:23:53 <wlangstroth> lambdabot is a she?
19:23:58 <gwern> > sum [1..5]
19:23:59 <lambdabot>   15
19:24:15 <monochrom> Letting it out a bit at a time is more managed than hiding, accumulating, then unpredictably bursting.
19:24:57 <sshc> Does there exist a version of the 99 exercises without the solutions?
19:24:58 <sshc> I like to look at the next few exercices without risking viewing the solution beforehand
19:25:28 <monochrom> program your adblock+ to hide the solutions :)
19:26:16 * BMeph practices the "Pulsar method" of anger management; it makes life Exciting! ;
19:26:40 <gwern> > mconcat $ map Sum [1..5]
19:26:41 <lambdabot>   Ambiguous occurrence `Sum'
19:26:41 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
19:26:49 <gwern> > mconcat $ map Data.Monoid.Sum [1..5]
19:26:50 <lambdabot>   Sum {getSum = 15}
19:27:22 <monochrom> GHC practices generational anger management :)
19:29:15 <dafis> bye everyone
19:29:26 <alexyk> I need to mapWithKey fn which takes the key only, not value; how do I drop the last argument?
19:29:55 <gwern> @hoogle product
19:29:55 <lambdabot> Prelude product :: Num a => [a] -> a
19:29:55 <lambdabot> Data.Foldable product :: (Foldable t, Num a) => t a -> a
19:29:55 <lambdabot> Data.List product :: Num a => [a] -> a
19:30:16 <Saizan> ?type M.mapWithKey
19:30:17 <lambdabot> forall k a b. (k -> a -> b) -> M.Map k a -> M.Map k b
19:30:39 <Saizan> alexyk: mapWithKey (const . fn)
19:30:48 <alexyk> yep, thx
19:34:47 <gwern> hm, it's nice to be able to write in Markdown in gitit, and hyperlink hoogle easil
19:35:05 <gwern> 'Here's an example. If we called `iterate (^3) 2`, we would get the infinite list  `[2,8,512,134217728,2417851639229258349412352..]`; but `sum` clearly has a stopping case. So we [compose](!Wikipedia "Function composition") `iterate` with [takeWhile](!Hoogle): `iterate` gets the seed value and the knowledge of how to keep changing the seed value, and `takeWhile` gets the knowledge of when the seed value has changed enough. '
19:35:22 <gwern> or
19:35:24 <gwern> 'If we wanted to use the Sum or Product monoids in actual code, we would use the [Data.Monoid](!Hoogle) library, which gives us Sum and Product on everything in the [Num](!Hoogle) typeclass:'
19:37:43 <monochrom> 'But I want to call `(^3) `iteratee` 2`. Do you see my problem?'
19:38:50 <gwern> monochrom: there are always limitations
19:39:10 <gwern> if you must write it that way, that's what delimited blocks are for - ~~~~{.haskell}\n\n~~~~
19:39:33 <monochrom> quoting and escape codes, piled higher and deeper
19:39:42 <wlangstroth> the (!Hoogle) bit is pretty good, just admit it
19:40:10 * gwern considers the interwiki links to be my greatest contribution to gitit. even though I seem to be the only user
19:41:07 <wlangstroth> that "bang" notation to a search site is good because the link presumably doesn't go stale
19:41:15 <gwern> the hoogle links are pretty much what you expect - http://www.haskell.org/hoogle/?hoogle=Data.Monoid
19:41:42 <gwern> it might be cool to parse that url and extract the first hit, and go *there* instead; in which case now it's like a canonical name service
19:41:55 <gwern> (but I think that's a step too far. it'd really kill rendering time)
19:43:03 <wlangstroth> I guess there's no "first hit" flag in the query string of Hoogle, then?
19:43:09 <gwern> wlangstroth: well, it beats all hollow linking to http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Monoid.html
19:43:25 <Mathnerd314> how many monoids overlap? (like Sum and Product for Num)
19:43:49 <gwern> Mathnerd314: I'd imagine for any interesting datatype, there are many monoids
19:44:05 <gwern> there are several on just Int and Bool, imagine how many you could define on Char
19:44:11 <monochrom> There are 4 monoids for Bool, using && || == /= respectively
19:44:14 <wlangstroth> gwern: exactly - much work saved
19:44:14 <Mathnerd314> so why does Haskell allow only one typeclass for Monoid?
19:44:51 <napping> because Haskell doesn't have a good way of handling multiple instances for the same type
19:45:18 <gwern> hence the newtypes
19:45:38 <gwern> manually telling haskell which of the many possibilities to pick
19:45:45 <monochrom> How many typeclasses for Monoid do you want? 10?
19:46:10 <gwern> monochrom: we demand ten *million*!
19:46:12 <Mathnerd314> monochrom: 1. that works for all monoids.
19:46:55 <monochrom> If I want to write a polymorphic function that "should work for all monoids", what type sig should it have?  (Monoid a) => a->a?  (Monoid3 a) => a->a? ...
19:47:26 <jbapple> @hoogle Monoid3
19:47:26 <lambdabot> No results found
19:47:29 <napping> Mixing a global instance with local customization gets into trouble, I think
19:47:32 <gwern> monochrom: I guess there'd be a 'super monoid'! it takes a monoid as an arg... :)
19:47:45 <BMeph> "There are over 80 quintillion Monoids in the Haskell jungle. These are their stories." ;)
19:47:50 <Mathnerd314> monochrom: the first, since it is closest to your description
19:48:31 <wlangstroth> Mathnerd314: there's always category-extras, from which I'm sure any permutation of monoid you'd like may be derived
19:48:32 <gwern> napping: no, it makes perfect sense; just needs to be principled
19:49:02 <napping> How does the example go? I think existentials can break things a bit, if you think you have a value from an instance, but you have the wrong dictionary
19:50:04 <napping> ah, like if you've got data Eqable a where Eqable :: (Eq a) => a -> Equable a, and foo (Equable x) (Equable y) = x == y
19:50:23 <napping> wait, need a signature - foo :: Equable a -> Equable a -> Bool
19:56:13 <heropass> zoiks, what'd I miss
19:56:34 <heropass> @hoogle Monoid
19:56:34 <lambdabot> module Data.Monoid
19:56:35 <lambdabot> Data.Monoid class Monoid a
20:01:47 <vipex> please correct: pattern = overloaded functions in OOP?
20:03:30 <monochrom> wrong. best correction: s/=/like/
20:03:49 <monochrom> Theorem: forall x,y: x is "like" y
20:03:50 <napping> as a first refinement, something like overloading only on a closed (final in Java) set of classes
20:05:10 <napping> Even that misses the big idea that the set of constructors cover all possible values in a type without overlap
20:05:59 <monochrom> pattern is case switching, literally.
20:06:21 <Axman6> vipex: do you mea pattern as in pattern matching?
20:07:35 * hackagebot vector 0.6.0.2 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.6.0.2 (RomanLeshchinskiy)
20:12:00 <vipex> Axman6: I mean several functions that have different parameters
20:12:17 <vipex> oh wait, might am mistake about pattern in Haskell
20:12:33 <vipex> sayMe :: (Integral a) => a -> String
20:12:33 <vipex> sayMe 1 = "One!"
20:12:33 <vipex> sayMe 2 = "Two!"
20:12:33 <vipex> sayMe 3 = "Three!"
20:12:33 <vipex> sayMe 4 = "Four!"
20:12:34 <vipex> sayMe 5 = "Five!"
20:12:34 <vipex> sayMe x = "Not between 1 and 5"
20:12:53 <wlangstroth> so not quite the same as overloading
20:13:01 <vipex> by that code, pattern more likely switch (if-then-else / case)
20:13:58 <vipex> hmm, I just remember yesterday i read a definition of haskell as I know like overload functions in OOP
20:15:42 <wlangstroth> you mean something that looks like overloading?
20:17:01 <kmc> overloading by type?
20:17:15 <vipex> wlangstroth: yes
20:17:28 <vipex> kmc: by parameters count or type
20:17:31 <kmc> vipex, don't try to understand Haskell by setting up equations of the form "X = Y in OOP"
20:17:35 <kmc> vipex, that's not an OOP concept anyway
20:17:59 <kmc> Haskell is not just a renaming of concepts you already know
20:18:02 <kmc> like most other languages
20:18:30 <wlangstroth> sayMe _ 1 = "One!" looks like overloading, but Haskell's types are different than Java or C++ types
20:19:21 <vipex> OK
20:19:26 <napping> vipex: algebraic data and pattern matching are almost exactly opposite from classes and overloading
20:19:28 <vipex> am reading http://learnyouahaskell.com/syntax-in-functions
20:19:39 <napping> OO uses coalgebra, and terminal coalgebras are useless
20:20:34 <wlangstroth> C/C++/Java types (primitives) are based on the "metal" (the processor), whereas Haskell's are more like math
20:20:44 <vipex> previously Im read "Programmin in Haskell", get borred in half then I move read "Real World Haskell"
20:21:12 <vipex> then I found this http://learnyouahaskell.com Author having same background experience with me
20:22:08 <wlangstroth> learnyouahaskell has a great design - simple, with silly illustrations
20:22:32 <vipex> so I decide pause "Programming in Haskell" and completing read learnyouahaskell :D
20:24:17 <vipex> napping: Yes, I try read Haskell materials from math perspective, but it'll help me alot to undertand if there'is sample comparation with OOP / common programming
20:25:48 <wlangstroth> I have to side with napping - it's better if you don't compare "normal" (iterative) programming with Haskell programming
20:26:11 <vipex> so why I ask that question to get confirmation (pattern =? overloading =? switch-case) 
20:26:35 <vipex> wlangstroth: OK I'll
20:27:18 <Saizan> pattern matching is a lot like a generalized switch-case
20:31:02 <vipex> Saizan: Finally I figure it :)
20:41:56 <interferon> given a single object of type a, is there a built-in function that will create a list with just that one object?  right now i'm using "(:[])"
20:42:32 <gwern> return
20:42:41 <ddarius> interferon: return will given an appropriate instance, but (:[]) is shorter and more explicit.
20:42:46 <gwern> but the monkey operator is good too
20:43:11 <gwern> @quote monkey.operator
20:43:11 <lambdabot> psykotic says:  (:[]) is the happy monkey operator
20:43:14 <ddarius> @quote robot.monkey
20:43:14 <lambdabot> No quotes match. Sorry.
20:43:16 <interferon> the full expression is "(:[]) <$> parsecCombinator" which i find a little ugly
20:43:21 <interferon> gwern: :)
20:43:33 * gwern thinks Applicative looks like line noise no matter like you slice it
20:43:36 <interferon> i did notice that it looked a lot like a smiley
20:43:41 <ddarius> interferon: return <$> p will probably be a little confusing.
20:43:52 <kmc> "pure" too
20:43:53 <interferon> gwern: no, i love Applicative
20:44:23 <interferon> yeah, i think that becomes more confusing
20:44:30 <interferon> surprised that there's no Data.List.singleton
20:44:43 <ddarius> @hoogle singleton
20:44:43 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
20:44:43 <lambdabot> Data.IntMap singleton :: Key -> a -> IntMap a
20:44:43 <lambdabot> Data.IntSet singleton :: Int -> IntSet
20:45:01 <gwern> interferon: would a singleton be like mempty?
20:45:18 <interferon> no, it would be like "singleton :: a -> [a]"
20:45:26 <interferon> singleton = (: [])
20:45:54 <interferon> @t (: [])
20:45:54 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
20:46:04 <gwern> ah, so it'd be like mappend . mempty?
20:46:05 <interferon> @type (: [])
20:46:06 <lambdabot> forall a. a -> [a]
20:46:09 <interferon> gwern: right
20:46:10 * gwern has monoids on the brain today
20:46:21 <interferon> @type mappend . mempty
20:46:22 <lambdabot> forall a (f :: * -> *). (Monoid a, Monoid (f a), Functor f) => f (a -> a)
20:46:34 <interferon> or maybe not
20:47:22 <gwern> 'The data points reported are the median of 3 executions, and we measure up to 7 cores as measurements on the 8th core are known to introduce some variability.' <-- I think everyone else just calls this 'the last core slowdown'
20:54:42 <monochrom> there are too many singletons
20:58:47 <ClaudiusMaximus> @type mappend mempty
20:58:48 <lambdabot> forall a. (Monoid a) => a -> a
21:00:20 <heropass> @type mappend
21:00:21 <lambdabot> forall a. (Monoid a) => a -> a -> a
21:00:41 <heropass> @type mempty
21:00:43 <lambdabot> forall a. (Monoid a) => a
21:49:08 <ksf> argh I need blocking I/O
21:49:44 <c_wraith> that's not a complaint I'm used to hearing.
21:49:53 <ezyang> Running out of resources? 
21:49:53 <ksf> at least partly, that is
21:50:32 <ksf> the thing is that I can't in good consciousness cache pipes if I don't know that they're ready for transfer, again
21:50:56 <sshc> Where is (Either e) made an instance of the Monad class?
21:51:11 <sshc> (The error monad)
21:51:43 <ksf> so I need to run my splice(2) calls blocking, which means I need an OS thread for each one, which I think means pooling OS threads.
21:52:28 <ezyang> Control.Monad.Error 
21:52:33 <c_wraith> can you not use waitWriteFD?
21:52:34 <ezyang> sshc: But I recommend using failure instead. 
21:52:45 <ksf> hmmm good point
21:52:50 <c_wraith> Or whatever the name of it is?
21:55:17 <sshc> ezyang: Failure?
21:56:57 <ezyang> http://hackage.haskell.org/package/failure 
21:57:08 * ksf reads pipe(7)
21:57:49 <sshc> ezyang: Why would you suggest that?
21:58:52 <ezyang> sshc: Because the monad instance for Either is really sucky 
21:59:15 <ezyang> And failure managed it a lot more reasonably. 
21:59:51 <sshc> ezyang: What's wrong with Either?
21:59:56 <sshc> How is it "sucky"?
22:00:14 <c_wraith> Because it depends on Error, for a pretty bad reason
22:00:28 <ksf> there's control.monad.exception
22:00:41 <ksf> which is also an Either monad, but on heavy steroids.
22:02:11 <ksf> actually, I think I worry too much wrt. to blocking or rather EAGAINing because of pipes
22:02:36 <ezyang> ksf: C lineage much? 
22:02:50 <ezyang> It might be soothing to go and see what GHC actually does under the hood. 
22:03:09 <ksf> one thing's for sure, it doesn't use splice()
22:03:30 <ksf> and it doesnt' come with tibbe's nice new shiny epoll support, yet.
22:04:55 <ksf> whether or not I'm blocking because the kernel can't keep up draining one pipe or can't keep up draining some other pipe and thus is in ioblock against the fs doesn't matter.
22:05:51 <ksf> which means that I could actually just use one pipe per fs/core
22:08:39 * ksf wonders why linux doesn't take care of creating pipe buffers for splice if necessary itself.
22:10:15 <ezyang> Orc reminds me a lot of the logic monad. 
22:11:20 <ezyang> since it operates like the list monad, has combinators like eagerly and cut... it's just parallel. 
22:12:59 <monochrom> Orc is nice. And monadly.
22:13:16 <ezyang> It is monadly. :-) 
22:14:39 <sshc> According to http://www.haskell.org/all_about_monads/html/listmonad.html, the list monad is made an instance by "instance Monad [] where".  Is that syntax even valid?
22:14:56 <ksf> oh damn those posix bindings
22:15:21 <ksf> ...naming O_NONBLOCK NonBlockingRead, as if there wouldn't be non-blocking writes.
22:15:23 <c_wraith> :t undefined :: [] Int
22:15:24 <lambdabot> [Int]
22:15:33 <c_wraith> @kind []
22:15:33 <lambdabot> * -> *
22:16:47 <c_wraith> yes, [] is valid syntax for referring to the list-of type constructor
22:16:48 <sshc> Is there any documnetation or further reading on this anybody can point me to?
22:17:23 <sshc> Is [] just special case syntax?
22:17:31 <c_wraith> yes
22:18:03 <c_wraith> almost everything about list syntax is special
22:18:17 <jbapple> @hoogle return
22:18:17 <lambdabot> Prelude return :: Monad m => a -> m a
22:18:17 <lambdabot> Control.Monad return :: Monad m => a -> m a
22:18:17 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
22:21:15 <sshc> I'm also trying to find how the List monad is defined in Hoogle
22:21:21 <sshc> where, rather
22:21:57 <sshc> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-List.html seems to only contain the transformer version
22:22:21 <ksf> do the docs that weak finalizers aren't guaranteed to run still hold?
22:22:33 <ksf> I ask because they sucessfully fixed that for foreignPtrs...
22:23:09 <sshc> What is Control.Monad.RWS?
22:23:20 <ksf> ReadT WriteT State
22:26:03 <ezyang> ksf: My understanding is that sequential foreign pointers finalizers are guaranteed to run, but concurrent foreign pointers are not. 
22:26:07 <Gracenotes> @unmtl RWS
22:26:07 <lambdabot> err: `RWS' is not applied to enough arguments, giving `/\A B C D. A -> C -> (D, C, B)'
22:26:29 <Gracenotes> well then
22:26:33 <ksf> this is all bloody insanity
22:27:00 <ksf> it's like they want to force us into using monadic regions
22:27:21 * ezyang thinks monadic regions aren't a bad thing... 
22:27:40 <c_wraith> @unmtl RWST String [Int] Int IO
22:27:40 <lambdabot> err: `RWST String [Int] Int IO' is not applied to enough arguments, giving `/\A. String -> Int -> IO (A, Int, [Int])'
22:27:47 <ksf> yeah but I'd like to keep my worries to the IO level, right now, not extend them to the type system.
22:27:52 <c_wraith> oh, right
22:27:57 <c_wraith> @unmtl RWST String [Int] Int IO Integer
22:27:58 <lambdabot> String -> Int -> IO (Integer, Int, [Int])
22:28:26 <ezyang> ksf: I mean, the types can help you deal with your IO problems 
22:28:29 <Gracenotes> not like that is more clear about which one is state, which one is reader, etc :)
22:28:33 <ezyang> by reducing the amount of things you can do in IO 
22:29:12 <Gracenotes> er. although, [Int] is a monoid, Int appears as both an argument and a result, and String is just read, so there you go actually
22:29:55 <Gracenotes> and the ordering of terms in RWST possibly have something to do with it
22:35:14 <solrize> is there something like "show" which doesn't put quotes around strings?
22:35:30 <ezyang> solrize: What do you mean? 
22:35:38 <ezyang> > print "foo" 
22:35:39 <lambdabot>   <IO ()>
22:35:43 <ezyang> bah 
22:35:50 <solrize> > length (show "foo")
22:35:51 <lambdabot>   5
22:36:02 <solrize> i just want to get "foo" (3 characters)
22:36:12 <ezyang> well... just use "foo" itself... 
22:36:16 <solrize> but it should work on the Show class, so i can still show integers and so forth
22:36:22 <ezyang> ah, I see. 
22:37:07 <solrize> well i'll just use separate functions, typeclasses are too lisp-ish already ;)
22:38:59 <solrize> nice, my first monad transformer works, after all these years ;)
22:39:26 <solrize> or rather, instance of such
22:43:01 <sshc> In http://www.haskell.org/all_about_monads/html/errormonad.html, toString, which :: Integer -> ParseMonad String, is defined by "toString n = return $ show n".  Could it also be written "toString = liftM show"?
22:43:17 <ezyang> sshc: Yep. 
22:43:23 <ezyang> :t return . show 
22:43:24 <lambdabot> forall (m :: * -> *) a. (Monad m, Show a) => a -> m String
22:43:28 <ezyang> :t liftM show 
22:43:28 <lambdabot> forall a1 (m :: * -> *). (Show a1, Monad m) => m a1 -> m String
22:43:35 <ezyang> erm, no, that's not quite right 
22:43:41 <ezyang> :t \x -> return (show x) 
22:43:42 <lambdabot> forall a (m :: * -> *). (Show a, Monad m) => a -> m String
22:44:07 <ezyang> They're not equivalent, sorry :o) 
22:46:08 <sshc> ezyang: I must not be understanding liftM.  Why couldn't I use it?
22:46:16 <sshc> I'll read backscroll in the morning
22:46:34 <ezyang> sshc: You can use it, but not in the same way as return . show 
22:46:43 <ezyang> liftM show is monad to monad 
22:46:49 <ezyang> return . show is normal value to monad 
22:48:55 <nus> @type liftM
22:48:56 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
22:52:59 <zeiris> Has anyone gotten themes to work with Leksah on Windows?
22:53:18 <portnov> hm. Is `yi' alive? Seems all docs are about 2007..2008 and are obsolete
22:53:53 <zeiris> That is not dead, which can eternal lie.
22:55:31 <dons> portnov: definitely alive
22:55:33 <dons> see in #yi
22:55:52 <dons> http://hackage.haskell.org/package/yi
22:58:00 <Hunner> zeiris: i just read that today!
22:58:27 <Hunner> cthulhu :)
23:00:27 <jbapple> I just wrote a data structure with an operation that is O(1). I benchmarked it against Data.Seq, which provide the operation with O(lg n) complexity, but my new data structure is slower every time. A lot slower :-(
23:00:54 <Mathnerd314> jbapple: optimize!
23:01:35 <jbapple> That's next, but I'm not actually sure it's worth the trouble
23:01:56 <jbapple> I mean, if I get get back to "tied", I still haven't accomplished anything
23:02:27 <Mathnerd314> are you certain it's O(1)?
23:02:52 <jbapple> I'm pretty sure.
23:03:13 <jbapple> I guess benchmarking can help me check that
23:04:53 <Hunner> :t (<$>)
23:04:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:05:16 <Mathnerd314> @hoogle ($>)
23:05:17 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
23:05:17 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
23:05:17 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
23:05:32 <Hunner> :t fmap
23:05:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:06:13 <Mathnerd314> :t $
23:06:14 <lambdabot> parse error on input `$'
23:06:22 <Mathnerd314> :t ($)
23:06:23 <lambdabot> forall a b. (a -> b) -> a -> b
23:07:47 <Mathnerd314> the alternate standard library just makes so much more sense...
23:08:29 <Mathnerd314> :t (<*>)
23:08:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:08:37 <Mathnerd314> :t (<$>)
23:08:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:08:40 <Mathnerd314> :t ($)
23:08:41 <lambdabot> forall a b. (a -> b) -> a -> b
23:16:01 <heropass> :t fmap
23:16:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:16:14 <heropass> :t (<$>)
23:16:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:18:56 <vipex> hi, sorry asking another topic, how usually Haskell program interact with the GUI? as in WEB-base I could figure my self
23:19:07 <vipex> is possible using Windows native GUI?
23:19:32 <Zao> vipex: Sure.
23:19:47 <Zao> There's a Win32 package closely mirroring the API.
23:19:54 <Zao> (apart from PeekMessage, for some obscure reason)
23:21:45 <vipex> Zao: ok I'll find it later
23:22:15 <vipex> say, I create GUI window & objects using Delphi, and I want Haskell as a backed
23:22:22 <vipex> backend*
23:22:25 <Zao> It's bundled with Windows builds of GHC.
23:22:33 <Zao> vipex: That'd be ... odd.
23:22:59 <vipex> what you mean with ... odd?
23:23:29 <Zao> You could either (possibly) embed Haskell. Or foreign import your Delphi code (maybe). Or create a separate Haskell process and communicate via stdin/stdout.
23:23:33 <vipex> in GHC bundled so far I know its using GTK --> hate that
23:23:38 <Zao> vipex: Not typically something some madman would do.
23:23:41 <Zao> vipex: No.
23:23:49 <Zao> vipex: GHC does not bundle anything GTK.
23:24:41 <Zao> Win32 has the good old createWindow, registerClass, etc. from regular win32 programming.
23:24:47 <vipex> Zao: communicate via stdin/stdout --> it seems the best way
23:25:03 <Zao> If you want some kind of richer UI library/framework, use gtk2hs, wx or something similiar.
23:25:11 <Zao> vipex: There is also the option of communicating via sockets.
23:25:24 <Zao> The sky (and Oleg) is the limit!
23:26:02 <vipex> can you point me to some URL?
23:26:22 <vipex> mmm, is there JS framework fow Haskell?
23:26:39 <vipex> said working with ExtJS or else 
23:27:38 <vipex> http://qooxdoo.org/ seems good another options
23:34:39 <heropass> :t Functor
23:34:40 <lambdabot> Not in scope: data constructor `Functor'
23:35:39 <heropass> @hoogle Functor
23:35:39 <lambdabot> Prelude class Functor f
23:35:39 <lambdabot> Control.Monad class Functor f
23:35:40 <lambdabot> Control.Monad.Instances class Functor f
23:35:45 <dons> vipex: look on hackage.haskell.org
23:36:04 <heropass> :t fmap
23:36:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:46:47 <kniu> I need an ad-hoc type inference algorithm for pure type systems with implicit parameters.
23:46:48 <kniu> help.
23:48:13 <solrize> uh...
23:48:43 <solrize> that sounds undecidable
23:56:06 <jbapple> kniu: try foetus, but Andreas Abel
23:57:00 <jbapple> *by
23:57:01 <kmc> "qooxdoo is a comprehensive and innovative framework for creating rich internet applications (RIAs). Leveraging object-oriented JavaScript"
23:57:27 <kmc> they're leveraging object-oriented javascript
23:57:36 <kmc> much better than simply /using/ object-oriented javascript
23:57:50 <danharaj_> kmc don't let the business people steal our synonyms.
23:58:32 <kmc> they're also using functional javascript of course, but that's not a popular buzzword ;P
