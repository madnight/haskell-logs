00:00:20 <tensorpudding> also (*3) works
00:02:11 <bastl> @pf +
00:02:11 <lambdabot> Maybe you meant: bf pl
00:02:28 <bastl> @pointful +
00:02:28 <lambdabot> (+)
00:02:44 <bastl> @pointful (3+)
00:02:44 <lambdabot> (\ a -> 3 + a)
00:02:47 <Olathe> @index NoBuffering
00:02:47 <lambdabot> System.IO
00:03:01 <bastl> @pointful (+)
00:03:01 <lambdabot> (+)
00:03:06 <bastl> is that a bug ?
00:03:08 <Olathe> "Module `System.IO' does not export `NoBuffering'"
00:03:24 <Olathe> @unpl (+)
00:03:24 <lambdabot> (+)
00:03:44 <Olathe> @unpl id
00:03:44 <lambdabot> (\ a -> a)
00:04:53 <bastl> @unpl f x y = (x,y)
00:04:53 <lambdabot> f x y = (x, y)
00:05:09 <bastl> @plf x y = (x,y)
00:05:09 <lambdabot> x = fix (,)
00:05:13 <bastl> cool
00:05:30 <bastl> @unpl fix (,)
00:05:30 <lambdabot> fix (,)
00:06:16 <JoeyA> If I say length xs twice, can I be reasonably sure GHC will optimize it (evaluate it once instead of multiple times)?
00:09:59 <copumpkin> no
00:10:06 <copumpkin> unless they're both let to the same thing
00:11:11 <JoeyA> suppose I say:
00:11:22 <tomberek> copumpkin.. isn't this the subexpression elimination issue?
00:11:23 <JoeyA> tripleLength xs = [length xs, length xs, length xs]
00:11:35 <tomberek> no, that will do it three tims
00:11:35 <copumpkin> JoeyA: it'll calculate it three times
00:11:46 <tomberek> @src replicate
00:11:46 <lambdabot> replicate n x = take n (repeat x)
00:11:54 <tomberek> @typeof replicate
00:11:55 <lambdabot> forall a. Int -> a -> [a]
00:12:19 <tomberek> or will that do it three times too?
00:12:29 <copumpkin> nope
00:12:56 <tomberek> let len=length xs in [len.len,len]   or replicate 3 (length xs)
00:13:12 <copumpkin> both
00:13:13 <JoeyA> Why would length xs be calculated 3 times when written out like that?  Isn't this what referential transparency is all about?
00:13:24 <JoeyA> I'd think that'd be a trivial optimization.
00:13:25 <copumpkin> JoeyA: it can introduce space leaks
00:13:39 <tomberek> sounds good.... JoeyA, i thought so too....
00:14:30 <Olathe> Yay ! I now have no buffering on stdout (import System.IO (..., BufferMode(NoBuffering)))
00:14:39 <tomberek> copumpkin, easy cases like this should be done though, honestly.... "function called with same arguments gives same answer" is drilled into our heads so often.. seems a perfect application of the concept
00:14:50 <copumpkin> nope
00:15:25 <copumpkin> what if length produced a huge value of 100MB, and sharing it between those three caused it to be retained and not GCed
00:15:31 <copumpkin> even though you never requested it for the tail
00:16:11 <tomberek> copumpkin... ghc looks at type of length
00:16:14 <tomberek> @typo length
00:16:14 <lambdabot> forall a. [a] -> Int
00:16:28 <copumpkin> tomberek: that's a very special case and is kind of silly
00:16:31 <tomberek> "wow, just an Int,, subexpression elimination should be ok"
00:16:37 <tomberek> i konw
00:17:01 <copumpkin> Int isn't built in
00:17:07 <copumpkin> there's no reason the compiler should know about it
00:17:28 <tomberek> i've seen the question before, i thought wrong at first, it just seems to be a common misunderstanding
00:18:01 <JoeyA> Unrelated, but I'm pretty amazed how quickly I was able to whip this up:  http://codepad.org/2tGJb6Yl
00:18:11 <tomberek> now,, what about for strictly evaluated functions?
00:20:29 <FunctorSalad_> copumpkin: why shouldn't the optimizer know about lots of silly special-case optimizations if the general prob can't be solved?
00:20:39 <JoeyA> Maybe I'm just used to messing around with pointer logic in C.  I liked how I could just take the idea of n `div` 2 and (n+1) `div` 2 splitting n in half and write such a pretty implementation.  I didn't even think through it.
00:20:45 <bastl> I just learned a bit about existentials. Is there a way to extract a hidden value ? I always get "type variable escapes" (which is true). I try to do what is mentioned in the documentation to function 'on' in multirec zipper: http://tinyurl.com/2cykuda
00:20:59 <FunctorSalad_> (in fact, you can do that as a user with {-# RULES #-})
00:21:17 <FunctorSalad_> but I don't know whether RULES are enough to do common subexpression elimination
00:21:33 <FunctorSalad_> JoeyA: btw, did you check that it *doesn't* do this special case?
00:21:33 <JoeyA> Awesome
00:21:47 <JoeyA> Doesn't do what case?
00:22:27 <FunctorSalad_> JoeyA: CSE (common subexpr. elimination) for `length'
00:23:22 <tomberek> FunctorSalad: it just seems to be institutional knowledge, i just don't know how to check it
00:23:24 <FunctorSalad_> bastl: you can only extract the value if the result of what you're doing doesn't depend on what type was inside the box
00:23:33 <JoeyA> FunctorSalad_: I didn't benchmark it or anything, so my answer would be Nothing
00:23:49 <FunctorSalad_> like, if you have an existential "exists a. (a -> Int, a)", applying fst to snd is fine
00:24:24 <FunctorSalad_> I thought that maybe one could see it in ghc-core
00:24:43 <bastl> FunctorSalad_: yeah, i got that yesterday, but then the docs of 'on' are misleading. for update the existential is fine, but i wanted something like (forall xi. phi xi -> r xi -> a) -> Loc phi r ix -> ix  in which ix escapes.
00:24:50 <FunctorSalad_> but I don't know if any automatic CSE (if it exists) is done before or after ghc-core's output
00:25:45 <bastl> Is there a trick to get around it? Like refining the types before ... I just want to extract the focus ...
00:26:22 <bastl> oops, the type was wrong it should be 'xi' at the end.
00:26:43 <tomberek> FunctorSalad: i can't claim to be able to effectively parse ghc-core
00:27:08 <FunctorSalad_> bastl: the somewhat typesystem-breaking way to get around it is to have a Typeable constraint and use `cast'
00:27:37 <FunctorSalad_> (which is `safe' in that it won't segfault, but couldn't be implemented without unsafeCoerceIO, AFAIK)
00:27:53 <FunctorSalad_> err s/IO//
00:28:31 <bastl> i get the idea, but cant imagine the type.
00:29:01 <bastl> ah, cast xi to a you mean.
00:29:12 <FunctorSalad_> data Foo where Foo :: (Typeable a, ...) => ... -> a -> .... -> Foo
00:29:20 <FunctorSalad_> oh, I meant if the existential type is under your control
00:29:40 <FunctorSalad_> I don't remember the multirec zipper well
00:30:15 <FunctorSalad_> AIUI you could define your family `phi' such that that "phi xi" implies that xi is typeable
00:30:15 <bastl> ok, thanks. that was helpful.
00:31:14 <bastl> that would mix two kinds of genericity. sounds ugly :-)
00:31:36 <FunctorSalad_> bastl: indeed. I was just going to say that it's probably unnecessary
00:31:55 <FunctorSalad_> "phi" was some finite family in multirec, wasn't it?
00:32:08 <bastl> yes.
00:32:09 <FunctorSalad_> so you'd just `case' on the "phi ix" witness
00:32:19 <FunctorSalad_> *phi xi
00:32:27 <FunctorSalad_> and in each branch, `xi' would be known
00:33:01 <bastl> yea, i thought something like that, but didnt get it to work. In the end ghc told me that xi escapes
00:33:32 <FunctorSalad_> hmm, should work that way, maybe some typo or annotation needed
00:33:49 <bastl> we'll see
00:34:06 <FunctorSalad_> if the result of each `case' branch depends on `xi', I think you need an annotation
00:34:22 <FunctorSalad_> it's not possible to infer the generalization I think
00:35:15 <FunctorSalad_> gadt pattern matching is similar to dependent pattern matching after all...
00:51:13 <mlesniak> How do I prevent show-ing small doubles in scientific notation, i.e. I want 0.01 instead of 1e-2?
00:52:22 <dolio> > showFFloat 1e-9
00:52:22 <lambdabot>   No instance for (GHC.Real.Fractional
00:52:22 <lambdabot>                     (Data.Maybe.Maybe ...
00:52:29 <dolio> > showFFloat Nothing 1e-9
00:52:29 <lambdabot>   Overlapping instances for GHC.Show.Show
00:52:30 <lambdabot>                              (GHC.B...
00:52:35 <dolio> @type showFFloat
00:52:36 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
00:52:41 <dolio> > showFFloat Nothing 1e-9 ""
00:52:41 <lambdabot>   "0.000000001"
00:52:50 <mlesniak> dolio, Great & perfect :) Thanks!
00:54:13 <FunctorSalad_> tomberek: it's much simpler than haskell in principle, but it's still hard to decipher due to being longer, yes
00:54:28 <tomberek> yeah.. obfuscated
00:54:52 <FunctorSalad_> (it's a stripped-down haskell but with type-level lambdas :))
01:06:06 <dolio> > showFFloat Nothing 1e-100
01:06:07 <lambdabot>   Overlapping instances for GHC.Show.Show
01:06:07 <lambdabot>                              (GHC.B...
01:06:10 <dolio> > showFFloat Nothing 1e-100 ""
01:06:11 <lambdabot>   "0.000000000000000000000000000000000000000000000000000000000000000000000000...
01:06:24 <koninkje> FunctorSalad_: "it" ?
01:06:46 <FunctorSalad_> koninkje: ghc's `core' lang
01:06:51 <koninkje> ah
01:06:58 <ville>  f . g is just syntactic sugar to avoid lot of ()?
01:07:29 <FunctorSalad_> not really sugar; it's function composition
01:07:48 <koninkje> f . g = \x -> f (g x)
01:07:58 <ville> But basically all it does is calls them in order from right-to-left
01:07:59 <kulakowski> . is a function just like any other
01:08:26 <bastl> :r
01:09:14 <Botje> compare: head ( filter (\x -> not (null x)) (map return [1..10]))
01:09:24 <Botje> with: head . filter (not . null) . map return $ [1..10]
01:09:44 <Botje> and now you can easily take out parts of that "pipeline" and give them names
01:10:17 <FunctorSalad_> ville: I mean that "f . g" is a valid expression on its own while omitting the x from f (g x) isn't ;)
01:11:04 <FunctorSalad_> of course 'sugar' isn't rigorously defined
01:11:20 <ville> Ok fair enough, didn't consider that sittuation.
01:11:33 <kulakowski> but 'syntax' is, and there is no syntax specific to .
01:18:28 <ville> Botje: Can that map return $ [1..10] part be written with out using the $? Real World Haskell didn't offer any explanation of what $ does, it just suddenly appears in code.
01:18:49 <Botje> not really
01:19:00 <Botje> if you take, for example: head . map return [1..10]
01:19:09 <Botje> that translates to \x -> head (map return [1..10] x)
01:19:09 <FunctorSalad_> ville: it's a space (function application), but right-associative and lowest precedence
01:19:10 <koninkje> ville: f $ x = f x
01:19:13 <Botje> which is not what you want
01:19:43 <FunctorSalad_> map return [1..10]?
01:19:45 <Botje> you could do head (map return [1..10]
01:19:52 <Botje> )
01:20:21 <FunctorSalad_> whereas the space has highest precedence and is left-associative
01:20:37 <FunctorSalad_> some users think that ($) should be left too
01:20:56 <ville> Is that some not-so-subtle remark about the value of money?
01:21:19 <koninkje> no, just an obscure tradition from the elder days of Haskell
01:21:33 <FunctorSalad_> hehe... rather subtle to me
01:21:40 <FunctorSalad_> (since I've never thought of it that way)
01:22:21 <koninkje> (though MPJ jokes about people who want to see bling)
01:22:55 <koninkje> (...as a subtle suggestion to prefer (.) instead, where appropriate)
01:23:02 <tomberek> FunctorSalad: how would that work?
01:25:02 * koninkje thinks left-associative ($) might be a nice touch
01:25:11 <FunctorSalad_> (I thought that if anything it's meant as a reminder of the paramount importance of money, by forcing you to have money even in your code everywhere)
01:25:32 <tomberek> isn't that just infixl 0 $.  and  f $. x = f x
01:25:48 <ville> FunctorSalad_: guess you could go that way too, the lowest precedence part cauht me.
01:27:11 <ville> FunctorSalad_: so in the particular bit above, map return $ [1..10] it forces the generation of the list to occur before map is called?
01:28:32 <ville> No that's not it I guess.
01:28:35 <alpounet> yes tomberek
01:28:41 <tomberek> hey alp
01:28:46 <alpounet> hey
01:29:01 <tomberek> alpounet, what you up to?
01:29:39 <alpounet> working quite much on my GSoC heh
01:29:41 <alpounet> and you ?
01:30:25 <FunctorSalad_> ville: it does nothing in that expression... but I gathered that your whole expression is "head . map return $ [1..10]"?
01:30:34 <benc__> in this http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
01:30:37 <FunctorSalad_> there it makes the parens like:
01:30:46 <FunctorSalad_> (head . map return) [1..10]
01:30:47 <benc__> there is code like (Get n p ~ Unlocked)
01:30:50 <FunctorSalad_> instead of
01:31:00 <FunctorSalad_> head . map (return [1..10])
01:31:01 <tomberek> alpounet: still learning the ins and outs
01:31:07 <FunctorSalad_> which is equivalent to
01:31:08 <benc__> where does ~ come from? (eg what paper or language extension?)
01:31:25 <tomberek> benc.. he mentions that he uses that instead of =  because == is overused
01:31:34 <FunctorSalad_> sorry, I mean without ($) it's equivalent to
01:31:45 <FunctorSalad_> head . ((map return) [1..10])
01:32:00 <tomberek> bnec__: so he uses ~ to mean type equivalence... it can be used with the TypeFamilies extension
01:32:07 <FunctorSalad_> but with ($) it's what I wrote
01:32:21 <benc__> ok its part of TypeFamilies
01:32:59 <tomberek> ya
01:37:49 <koninkje> ville: talking about when things are "called" doesn't always translate well to Haskell because of the laziness. For example, the evaluation of map f xs is going to occur in synchrony with whenever the (first) consumer is looking at the output. For lists in particular list-fusion techniques can make the order of evaluation very different
01:45:13 <tomberek> is it possible to have a list at the type level?
01:45:36 <dolio> Yes.
01:45:40 <koninkje> ville: when starting out it's probably best to try to just manually apply the definitions of (.) and ($) and seeing what comes out
01:45:43 <koninkje> head . map return $ [1..10]
01:45:43 <koninkje> head . map return $ enumFromTo 1 10
01:45:43 <koninkje> (head . map return) (enumFromTo 1 10)
01:45:43 <koninkje> (\x -> head (map return x)) (enumFromTo 1 10)
01:45:43 <koninkje> head (map return (enumFromTo 1 10))
01:46:05 <tomberek> dolio: how does one do this?
01:46:22 <dolio> data Nil ; data Cons a b
01:46:34 <dolio> Int `Cons` Char `Cons` Nil
01:47:06 <tomberek> dolio.. hm.. i kinda like it
01:57:42 <FunctorSalad_> tomberek: HList
01:57:45 <FunctorSalad_> (package)
01:57:50 <tomberek> yeah?
01:58:03 <FunctorSalad_> well, it has typelevel lists for you ;)
01:58:19 <tomberek> ooh
02:00:24 <jaspervdj> stepkut: ping
02:02:45 <tomberek> what function can do this?
02:02:48 <tomberek> newtype CompF f g a = CompF (f (g a))
02:02:51 <tomberek> f,g,h Functors
02:02:54 <tomberek> f (a,b) => id
02:02:58 <tomberek> f (g (a,b)) => CompF f g (a,b)
02:03:07 <tomberek> f (g (h (a,b))) => CompF (CompF f g) h (a,b)
02:03:22 <tomberek> and so on?
02:11:23 <ibt> huh, looks like #python has more people
02:13:18 <FunctorSalad_> anyone think putStr(Ln) could use a shorter synonym in the prelude?
02:13:23 <FunctorSalad_> psl
02:13:32 <FauxFaux> Just alias it in your ide?
02:13:51 <Axman6> FauxFaux: or just put
02:13:52 <dv-> imo putStrLn should've been called print, and print something else
02:13:54 <Axman6> uh, FunctorSalad_
02:14:04 <Axman6> dv-: printS?
02:14:04 * exDM69 agrees with dv- 
02:14:07 <FunctorSalad_> FauxFaux: but for invoking ghc from the commandline, for example ;)
02:14:43 <FunctorSalad_> "psl" is nicely untaken assuming you're not involved with projective special linear groups or something
02:14:55 <ibt> my least concern about Prelude problems
02:15:08 <zachk-wut> i like p at times
02:20:08 <FunctorSalad_> > printf "%s" "hai"
02:20:08 <lambdabot>   Ambiguous type variable `a' in the constraints:
02:20:08 <lambdabot>    `GHC.Show.Show a'
02:20:08 <lambdabot>      a...
02:20:14 <FunctorSalad_> ...
02:20:43 <FunctorSalad_> > map id $ printf "%s" "hai"
02:20:44 <lambdabot>   Ambiguous type variable `a' in the constraints:
02:20:44 <lambdabot>    `GHC.Show.Show a'
02:20:44 <lambdabot>      a...
02:21:05 <FunctorSalad_> @type map
02:21:06 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:21:20 <FunctorSalad_> oh, *this* isn't redefined to fmap
02:21:22 <FunctorSalad_> ;)
02:22:07 <ibt> > printf "%s" "x" :: String
02:22:08 <lambdabot>   "x"
02:22:22 <FunctorSalad_> or that way, yes
02:22:55 <FunctorSalad_> thought there were no instances for any other list type :)
02:23:06 <FunctorSalad_> which may not be enough though
02:58:06 <k23z__> is there any fundamental difference between html and xml ?
02:58:21 <mreh> well, there's xhtml
02:58:27 <k23z__> right
02:58:29 <mreh> they're kind of the same
02:58:30 <k23z__> so is there any fundamental difference between html and xml ?
02:58:35 <k23z__> ok
02:58:53 <mreh> I don't really know what xml is... it's some kind of standard
02:59:17 <scree> afaik they look the same but are for quite different things
02:59:21 <mreh> anyway, this is #haskell, for talking about haskell :)
02:59:29 <dibblego> html is not xml
03:00:04 <scree> html is exlusively web markup, and is very similar to xml, which is for representing abstract data trees
03:00:12 <k23z__> like                 S = "" | <tagname>S</tagname> | S S
03:00:18 <k23z__> I guess that's the XML grammar right there ...
03:00:25 <k23z__> well there are also attributes ..
03:01:38 <benc__> and namespaces
03:02:03 <scree> and you *can* impose a sort of type system on it
03:03:32 <ibt> k23z__: i don't think html has to be well formed
03:03:44 <k23z__> ibt, oh ?
03:03:50 <k23z__> ibt, are you sure ?
03:04:01 <benc__> heh depends on who is doing the requiring
03:04:24 <JN> well, html looks kinda like xml but it is not well-formed *xml*..
03:05:02 <ibt> i think xhtml documents are supposed to be well formed
03:05:07 <benc__> ibt: they are
03:05:19 <benc__> but i think xhtml is fairly abandoned now
03:05:31 <JN> yes.  xhtml is an xml-compliant representation of html
03:05:38 <ibt> XHTML5 is undergoing development as of September 2009, as part of the HTML5 specification.
03:06:08 <ibt> k23z__: okay, anyway. i would say that there is a fundaemental difference.
03:07:14 <JN> the fundamental difference is that html is domain-specific whereas xml is open-ended (can apply to any domain by defining your own schemas)..
03:10:29 <FunctorSalad_> "well-formed" what? :)
03:10:51 <JN> html is not well-formed xml. :)
03:10:55 <FunctorSalad_> surely html is well-formed html ;))
03:10:58 <JN> and vice-versa
03:10:58 <FunctorSalad_> ah
03:11:37 <FunctorSalad_> is it the <foo/> construct?
03:11:40 <JN> but I think the point might have been that xml has a stricter syntax that requires each opening tag to have a closing tag .. and also requires attributes to be enclosed by quotes (single or double)
03:11:48 <JN> and that <foo/> construct is xml-only
03:14:21 <fryguybob> <b>blah <i>blah</b></i>  <-- invalid xml
03:15:59 <copumpkin> not that it's valid html either
03:23:11 <mreh> dear deadrie, my pattern guards are always ugly and unreadable, please help
03:23:55 <ibt> mreh: hpaste?
03:25:03 <mreh> broken
03:25:10 <mreh> @where hpaste
03:25:10 <lambdabot> http://hpaste.org/
03:25:17 <mreh> @where hpaste2
03:25:17 <lambdabot> http://hpaste.org/
03:25:31 <mreh> @where moonpatio
03:25:31 <lambdabot> I know nothing about moonpatio.
03:26:35 <ivanm> mreh: moonpatio is down
03:26:38 <ivanm> and mmorrow is AWOL
03:28:24 <mreh> http://pastebin.com/qtJNjkxT
03:28:45 <mreh> I think pattern guards are going to be ugly inevitably
03:30:15 <ivanm> preflex: seen tomberek
03:30:15 <preflex>  tomberek was last seen on #haskell 1 hour, 26 minutes and 52 seconds ago, saying: and so on?
03:30:52 <quicksilver> mreh: there are no patter guards in that paste.
03:31:21 <mreh> quicksilver, what do you call the thing to the right of the pipe?
03:31:41 <quicksilver> mreh: a guard
03:32:13 <quicksilver> pattern guards are an extension that are like a hybrid of list comprehension syntax and guards, which allow guards to introduce bindings.
03:32:59 <quicksilver> I don't find guards at all ugly, although for rather long lines like that I'd probably break the line before the |
03:33:16 <quicksilver> and align the = signs
03:33:18 <k23z__> how hard would it be to write something that would render HTML like a browser does ?
03:33:26 <k23z__> something minimal
03:33:33 <quicksilver> mreh: like this : http://pastebin.com/xZze8eKZ
03:33:38 <k23z__> like straight-to-the-point quick quick fast !
03:33:39 <quicksilver> k23z__: extraordinarily hard.
03:33:54 <k23z__> quicksilver, are you sure ?
03:33:56 <quicksilver> yes.
03:34:00 <k23z__> quicksilver, I intend to do that
03:34:07 <quicksilver> gecko and webkit are millions of lines of source code each.
03:34:19 <k23z__> why is it so hard ?
03:34:19 <quicksilver> have fun. It is an interesting project.
03:34:21 <exDM69> k23z__: HTML rendering is very very difficult but if you want to build an app, you can pick up some of the rendering toolkits out there and plug it in your gui
03:34:25 <yitz> mreh: warning, in pattern guards <- means something subtly different than in the other two ways that it is used in Haskell
03:34:46 <quicksilver> k23z__: the HTML layout model is subtle and surprisingly hard to implement.
03:34:56 <yitz> mreh: you can always avoid pattern guards by using the Maybe monad or the Exit monad
03:34:57 <mreh> yitz: in a case expression?
03:35:04 <k23z__> exDM69, I'm a fan of the UNIX philosphy and the wmii people, so I want to build things from scratch, as if I were on a desert island and all software went *poof* except my compiler
03:35:09 <mreh> for example
03:35:17 <mreh> that uses ->
03:35:21 <mreh> what am I talking about
03:35:29 <yitz> oh, three ways, right. do bindings and list comprehension (you could count those as one I suppose)
03:35:31 <exDM69> k23z__: building things from scratch is not unix philosophy, it's called NIH syndrome
03:35:37 <yitz> ha
03:35:42 <k23z__> exDM69, NIH syndrome ?
03:35:50 <quicksilver> k23z__: the exact opposite of the UNIX philosophy, which is to solve problems by combining small reusable pieces like the coreutils.
03:35:58 <yitz> so yeah do binding and list comprehensions
03:36:12 <quicksilver> anyway, an HTML renderer is an interesting project, and I don't want to discourage you from it.
03:36:15 <Ytinasni> k23z__: if you just care about HTML and not CSS etc, it's not too difficult.
03:36:17 <exDM69> k23z__: NIH = not invented here, wikipedia has a page with practical examples ranging from the french military to software engineering
03:36:20 <quicksilver> but you asked how hard it is, and the answer is very hard.
03:36:31 <yitz> in other uses, rhs is in a monad and lhs extracts values from the monad. in pattern guards <- doesn't do that
03:36:57 <k23z__> exDM69, it's mainly because I don't have control over things
03:37:00 <yitz> I think pattern guards are very ugly for that reason. I've never had use for them.
03:37:16 <k23z__> exDM69, and I want to have full control, I don't want to read docs because I don't have time , so basically I want to rewrite everything from scractch
03:37:28 <exDM69> that hardly saves any time now does it?
03:37:43 <k23z__> exDM69, it depends, on the long-run it may save a lot of time
03:38:13 <k23z__> exDM69, and given that I'm a programmer for let's say 8 years now as a hobby or profesionally I think it's reasonable ...
03:38:41 <yitz> k23z__: you can rebuild the compiler from scratch, too. it would be fun! see you in 20 years.
03:39:02 <k23z__> yitz, no, the compiler I won't touch, it's ok as it is
03:39:50 <yitz> k23z__: it's actually not exactly ok. like anything built over 20 years, there are a lot of huge improvements that could be made if it were rebuilt now from scratch.
03:40:04 <k23z__> yes C++ has some problems and any language does(Haskell has less) but I cannot touch compilers since it would mean for me to read piles of books on compiler theory, formal languages and stuff that I would use nowhere else
03:40:41 <Ferdirand> and somehow, all the rest of software does not require reading books and theory to get right ?
03:40:50 <k23z__> yitz, I imagine that real compiler programmers have beards, white beards
03:41:08 <quicksilver> actually if you read about compiler theory, formal languages, and stuff, you would learn a lot of stuff you will use.
03:41:14 <yitz> k23z__: yes. they didn't have those beards before they began though.
03:41:15 <quicksilver> for example, when writing an HTML renderer.
03:41:19 <quicksilver> HTML is a formal language.
03:41:36 <quicksilver> a renderer is much like a compiler - it parses the documented, and 'compiles' it to a different form
03:41:44 <yitz> HTML is a very special case of a formal language called sgml
03:41:48 <k23z__> quicksilver, yes it is, but I'd like to use a parser, the problem is after I use a parser...
03:41:57 <k23z__> quicksilver, how do I know where to draw each of the elements
03:41:58 <quicksilver> not admittedly executable code, but some kind of flow layout representaiton.
03:42:06 <quicksilver> k23z__: by reading the HTML specs
03:42:11 <quicksilver> shame, because you don't read docs
03:42:19 <quicksilver> perhaps you will invent a new layout language instead?
03:42:23 <k23z__> haha
03:42:31 <quicksilver> anyhow my point is that this process is very like writing a compiler.
03:42:41 <quicksilver> so you *would* learn a lot by writing a compiler first that you would use again.
03:42:47 <quicksilver> (I'm not suggesting you actualyl do that)
03:42:49 <k23z__> quicksilver, maybe I will write a HTML -> k23z__layoutlanguage convertor and then render my own stuff which I thought out
03:43:08 <quicksilver> also, to be a useful web browser these days you need a javascript virtual machine
03:43:13 <exDM69> any HTML renderer is not likely to be standards compliant in the first years of it's existance, so it will formally be "a new language" ;)
03:43:17 <quicksilver> including a compiler of some kind for that.
03:43:19 <k23z__> quicksilver, I can use rhino for that ..
03:43:27 <quicksilver> ah, so you'll re-use rhino?
03:43:33 <quicksilver> then why not just re-use gecko or webkit?
03:43:39 <quicksilver> where's the difference?
03:43:49 <yitz> quicksilver: using html as a layout language is abuse. it's a document structure language. css and xsl are layout languages.
03:43:54 <k23z__> quicksilver, because I want to write the renderer in order to have a demo to show off at some interview when getting a job
03:44:03 <k23z__> quicksilver, this is my goal, to show off a demo
03:44:16 <quicksilver> yitz: yes, when I say HTML I meant "HTML, CSS, and the flow object model"
03:44:23 <quicksilver> yitz: it's just a bit cumbersome to type that in every line.
03:44:40 <quicksilver> k23z__: OK. That's not the reason you gave before.
03:44:44 <quicksilver> :)
03:45:21 <k23z__> quicksilver, well, I am also thinking that maybe somewhere down the line I'll start my own company and I'd like to have my own software written from scratch, but until then I need to get a job
03:45:32 <yitz> when we used to be perl programmers, we could have said @HTML as contrasted with $HTML.
03:53:57 * hackagebot hexpat 0.18 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.18 (StephenBlackheath)
03:54:57 * hackagebot hexpat-iteratee 0.6 - Chunked XML parsing using iteratees  http://hackage.haskell.org/package/hexpat-iteratee-0.6 (StephenBlackheath)
04:01:50 <exDM69> I've got two large-ish sorted lists of real numbers. I'd need to find a pair (an, bn) such that they are as close to each other as possible.
04:02:04 <exDM69> has anyone got a neat pairing algorithm in mind?
04:02:51 <zygoloid> exDM69: lockstep iteration through the two lists
04:03:25 <exDM69> all I can think of is modifying k-nearest neighbor or using a genetic algorithm but the first is not very well suited and the second is slow
04:03:40 <exDM69> zygoloid: lockstep iteration? could you tell more
04:04:12 <zygoloid> exDM69: ok. so if an is part of this pair, there's only two candidate bns.
04:04:27 <zygoloid> (the smallest one >=an and the largest one <=an)
04:04:40 <zygoloid> you can iterate over the lists together and find all such pairs in O(n) time
04:05:07 <exDM69> that is practically a greedy algorithm, isn't it
04:06:24 <BONUS> i feel as though i'm missing something here. if the list is sorted, why not just go over the list and compare adjecent numbers?
04:07:01 <BONUS> minimumBy (\x y -> abs $ x - y) .(zip`ap`tail)
04:07:14 <Ytinasni> BONUS: there are 2 lists, but that's the general idea
04:07:25 <BONUS> oh there are two lists, ah
04:07:48 <BONUS> i'd merge them first into one sorted list and then do that
04:08:28 <Twey> fmap abs . (-)
04:08:28 <preflex>  Twey: you have 1 new message. '/msg preflex messages' to read it.
04:08:50 <zygoloid> BONUS: that's clever
04:09:01 <Twey> 12:08:09 <preflex>  kmc said 2 days, 14 hours, 17 minutes and 56 seconds ago: you suck ;P
04:09:05 <Twey> Haha.
04:09:16 <Twey> preflex: You have to be the worst postbot ever :Ã¾
04:09:40 <kulakowski> I got the impression that exDM69 wanted one from each list?
04:10:08 <zygoloid> @let taggedMerge (x:xs) (y:ys) | x < y = (False,x):taggedMerge xs (y:ys) | otherwise = (True,y):taggedMerge (x:xs) ys; taggedMerge xs ys = map ((,)True) xs ++ map ((,)False) ys
04:10:09 <lambdabot>  Defined.
04:12:01 <Twey> Why do we say zip `ap` tail instead of zip <*> tail?
04:12:05 <orlandu63> is there a way to make haskell interpret the type constructor S S S O as S (S (S (O)))?
04:12:10 <orlandu63> or rather, ghc
04:12:13 <BONUS> Twey: sounds cool to pronounce
04:12:17 <Twey> Heh
04:12:35 <Twey> orlandu63: Don't think so
04:12:47 <ivanm> greetings he-who-draws-ungrammatical-trippy-tutorials
04:12:52 <Twey> Heh
04:12:53 <ivanm> @quote zip`ap`tail
04:12:53 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
04:12:54 <mreh> S . S . S $ O
04:13:09 <Twey> mreh: In types?  :Ã¾
04:13:15 <Ytinasni> > minimumBy (\x y -> abs $ x - y) .(zip`ap`tail) $ taggedMerge [0.1,0.3..1.0] [1/3,2/3]
04:13:16 <lambdabot>   Couldn't match expected type `GHC.Ordering.Ordering'
04:13:16 <lambdabot>         against inferr...
04:13:21 <mreh> they're constructors
04:13:30 <Twey> Type constructors
04:13:35 <Twey> Not data constructors
04:14:06 <mreh> orlandu63, what do you want to do exactly?
04:14:35 <zygoloid> > minimumBy (comparing $ \((a,x),(b,y)) -> (a==b, abs (x-y))) . (zip`ap`tail) $ taggedMerge [1,3,4,6] [2,5,7]
04:14:36 <lambdabot>   ((False,1),(True,2))
04:14:52 <zygoloid> > minimumBy (comparing $ \((a,x),(b,y)) -> (a==b, abs (x-y))) . (zip`ap`tail) $ taggedMerge [1,3,4,6] [2.1,5,7]
04:14:52 <lambdabot>   ((True,2.1),(False,3.0))
04:15:00 <zygoloid> > minimumBy (comparing $ \((a,x),(b,y)) -> (a==b, abs (x-y))) . (zip`ap`tail) $ taggedMerge [1,3.3,4,6] [2.1,5,7]
04:15:01 <lambdabot>   ((False,4.0),(True,5.0))
04:15:23 <zygoloid> > minimumBy (comparing $ \((a,x),(b,y)) -> (a==b, abs (x-y))) . (zip`ap`tail) $ taggedMerge [1,3.3,4,6] [2.1,5.1,7]
04:15:24 <lambdabot>   ((True,5.1),(False,6.0))
04:15:29 <zygoloid> looks like it works to me.
04:16:21 <Twey> Three must be a way to write that more nicely
04:16:25 <zygoloid> yeah
04:16:28 <Twey> There**
04:18:51 <scree> @src taggedMerge
04:18:52 <lambdabot> Source not found.
04:19:01 <scree> @type taggedMerge
04:19:02 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [(Bool, a)]
04:19:02 <Ytinasni> scree: scroll up.
04:19:34 <Twey> :t uncurry (***) . ((==) *** fmap abs . subtract)
04:19:35 <lambdabot> forall b a. (Eq b, Num a) => (b, a) -> (b, a) -> (Bool, a)
04:19:58 <scree> Ytinasni: ah :)
04:20:16 <Twey> > minimumBy (comparing $ uncurry (***) . ((==) *** fmap abs . subtract)) . ap zip tail $ taggedMerge [1, 3.3, 4, 6] [2.1, 5.1, 7]
04:20:17 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
04:20:17 <lambdabot>    arising from a use of `GHC.N...
04:20:46 <Twey> Oh, drat
04:21:25 <Twey> Not much nicer anyway :-\
04:30:09 <zygoloid> > minimumBy (comparing $ abs . uncurry subtract) . map (snd.fst &&& fst.snd) . (zip`ap`tail) . map (snd . head &&& snd . last) . groupOn fst $ taggedMerge [1,3,4,6] [2,5,7]
04:30:09 <lambdabot>   (1,2)
04:30:34 <zygoloid> maybe that's clearer?
04:32:28 <Ytinasni> zygoloid: if you don't use taggedMerge, this becomes much clearer.
04:34:13 <exDM69> BONUS: oh, I should have been more elaborate on the subject. the lists are of different sizes and greedy algorithms yield suboptimal results
04:34:42 <exDM69> some elements may be dropped (ie. those that can't find a good pair)
04:37:14 <zygoloid> exDM69: well, the approach given so far allows you to produce the pairs in order of distance in O(n log n) time. i don't think you can realistically hope to beat that.
04:37:29 <mreh> can I do a purely functional convolution?
04:37:35 <mreh> with lists
04:37:40 <zygoloid> (ok, it needs some tweaks to find the second-best matching for each element, but...)
04:37:56 <mreh> let me rephrase that
04:38:00 <mreh> is it easy?
04:38:12 <mreh> and efficient
04:38:20 <zygoloid> exDM69: the trick would be to maintain a heap of best pairs, and when you eliminate one, find the next-best for each element and push those back into the heap
04:38:41 <ibt> mreh: i don't think it'd be efficient if you used standard lists
04:38:54 <exDM69> zygoloid: yeah, you can't beat the performance but the quality of the result is the issue here
04:39:06 <exDM69> I'd need to get a good fit rather than get it fast
04:39:17 <zygoloid> exDM69: there's no QoR issue. it's giving you optimal results.
04:39:38 <zygoloid> unless you're ranking them by something other than distance?
04:39:48 <exDM69> no, just the distance
04:40:07 <Ytinasni> zygoloid: they're sorted, so there's a total order.
04:40:13 <ibt> mreh: http://hackage.haskell.org/packages/archive/dsp/0.2.1/doc/html/src/DSP-Convolution.html#conv
04:40:49 <zygoloid> Ytinasni: can you provide some context for that? i'm not sure what point you're making.
04:41:29 <Ytinasni> even if he's ranking by something other than distance, there IS an optimal result, and you do return it.
04:42:03 <zygoloid> Ytinasni: yes, but the approach relies on properties of distances on the real line
04:42:29 <Ytinasni> i guess.
04:43:06 <ibt> mreh: !! and reverse are slow on standard lists, so it could be especially bad if you didn't use Array/Vector
04:43:30 <zygoloid> i'd give the right answer under the condition that the optimum is always taken from an adjacent pair of points
04:43:53 <ibt> mreh: course, i guess you only do the reverse once.. bleh, tired.. sleep
04:44:10 <mreh> ibt: the convolution is a very stateful algorithm I think
04:44:13 <Ytinasni> oh, i'm misunderstanding you.
04:44:35 <Ytinasni> i'm already making that assumption :D
04:45:15 <mreh> a functional implementation would be very space inefficient
04:45:15 <mreh> I can see why some people hate haskell today :)
04:45:21 <mreh> it really makes you think
04:49:32 <max_atreides> which is not corporate world wants out of a programming language
04:49:36 <max_atreides> *not what
04:56:11 <mreh> indeed
04:56:32 <mreh> they might see the functional paradigm as deliberately over complicating things
04:56:36 <mreh> also
04:56:43 <ivanm> mreh: and not being blub enough?
04:58:29 <mreh> yeah, but you can hardly blame someone for not being able to think in anything other than blub after 20+ years
04:58:42 <mreh> blame the educators
04:59:57 <mauke> I'm reading about c2hs
05:00:16 <mauke> I see it can import enum definitions, but is it possible to skip some enum values?
05:00:37 <mreh> manually delete them :)
05:00:46 <mauke> from where?
05:00:54 <mreh> c just has integer enums
05:01:06 <mauke> yes?
05:01:07 <mreh> it doesn't have an enum construct persay
05:01:14 <mauke> *per se
05:01:28 <mauke> and I don't see how that answers my question
05:01:53 <Ytinasni> why do you want to skip some values?
05:02:06 <mreh> I don't know of a way of doing it, you can open the source code and delete them
05:02:15 <mauke> mreh: which source code?
05:02:16 <mreh> from the header files
05:02:18 <mreh> the C
05:02:27 <mauke> right, I'm editing system headers just to write a haskell wrapper
05:02:30 <mauke> how about no
05:02:53 <mreh> you want to remove functionality from a program, that's the only way I know how
05:02:56 <mauke> Ytinasni: they're not part of the public interface, just marking the start/end of the enum range
05:03:01 <ville> When I have something like: 'xx <- something' that xx can have the same name as data X = X { xx :: Int } with in the same module?
05:03:41 <mauke> mreh: I don't want to remove functionality from a program, I want to wrap a library's public interface
05:03:42 <exDM69> ville: yes, I think but then you can't use the xx function
05:04:01 <mauke> ville: xx is (mostly) a normal function, so the usual shadowing rules apply
05:04:08 <ville> exDM69: Ok so that would be a problem.
05:04:19 <exDM69> ville: do { xx <- foo ; somethingWith xx } is equal to foo >>= (\xx -> somethingWith xx)
05:04:29 <mreh> c2hs converts the enums into a algebraic type non?
05:04:36 <Twey> Is equal to foo >>= somethingWith
05:04:41 <mauke> yes
05:04:51 <exDM69> ville: and there you can clearly see the lambda masking the xx from the outer scope
05:05:04 <quicksilver> Twey: only if "xx" does not occur in 'somethingWith', which is the point here
05:05:08 <exDM69> Twey: true, but that does not illustrate the problem there
05:05:10 <quicksilver> Twey: other occurrences of xx are the point.
05:05:14 <Twey> Ah, that's an expression, not a function.
05:05:16 <Twey> Okay.
05:05:34 <quicksilver> we need to be allowed to use colour for meta-syntax
05:05:36 <mreh> I can't think of a way that won't result in your either editing C or Haskell code manually
05:05:43 <Twey> Heh
05:05:46 <ttmrichter> I just installed hoogle (cabal install hoogle) and gave it a test run.  Why is it that when I give it hoogle "Num a => [a] -> a" as a search it gives me not only the expected things like the Prelude's product, but it also gives me unexpected things like the Prelude's head and last functions (not Num type) or, even worse, functions like abs (doesn't involve lists at all) or foldl (involves a lot more than just a list, but not necessarily a Num)?
05:05:54 <mreh> the C code will potentially reference each enum
05:06:09 <ville> Right so my 'variable' masks the 'accessor' function. ( Yes I am not a Haskell coder, I need to learn the vocabulary one day )
05:06:10 <mreh> so it's going to end up in your Haskell
05:06:23 <Philonous> mauke: You can edit the hs file that c2hs creates or you can not let c2hs handle the enum in the first place but translate it by hand
05:06:27 <dcoutts> ttmrichter: sounds like it's working as designed
05:06:34 <exDM69> ville: the "variable" is actually a function parameter
05:06:36 <mauke> then why am I using c2hs in the first place
05:06:49 <exDM69> ville: the do notation is syntactic sugar which makes it look like a variable
05:07:01 <Philonous> mauke: I don't know, why are you?
05:07:03 <mauke> Philonous: there are about 500 enum values
05:07:11 <dcoutts> ttmrichter: it does a "nearest" search on the types. You'd be surprised how useful that is to newbies who don't really know what type they're looking for.
05:07:18 <ville> exDM69: Yeah I recall reading that is was just syntactic sugar for something horrible.
05:07:24 <mauke> because people said it was a nice tool to simplify the creation of haskell wrapers
05:07:28 <mreh> I've been talking out my bum again
05:07:58 <exDM69> ville: no, it's not horrible, just terribly hard for an imperative head to understand. but once you get over it, it's a very clean solution
05:08:05 <exDM69> ville: even without the sugar
05:08:13 <ttmrichter> dcoutts: Is it possible to tone it down a tad?  I'm getting like three screens full here on that type.
05:08:16 <Twey> Well, it can be â˜º
05:08:17 <mauke> exDM69: I don't think it's terribly hard to understand
05:08:23 <dcoutts> ttmrichter: ask for fewer results
05:08:35 <FunctorSalad_> ttmrichter: `head' and `last' actually match
05:08:37 <exDM69> mauke: for me it was
05:08:43 <FunctorSalad_> for types which are Num
05:08:45 <kmc> why would "do" be hard for an imperative programmer to understand? it's the essence of imperative programming
05:08:47 <mauke> well, you were doing it wrong :-)
05:08:49 <Philonous> mauke: Also, you could could not export the superfluous constructors
05:09:11 <kmc> oh right, "imperative programmer" means "programmer who's not seen FP" and "functional programmer" means "programmer who's seen FP"
05:09:13 <exDM69> kmc: what I meant is that >>= is hard to understand
05:09:17 <kmc> what odd terminology
05:09:18 <ttmrichter> FunctorSalad_: Matches types which are Num and every other type under the sun too.  If I'm putting Num => in it, doesn't that indicate I'm interested in Num outputs?
05:09:25 <Twey> :t head `asTypeIn` ($ [3])
05:09:25 <lambdabot> forall a. (Num a) => [a] -> a
05:09:38 <Twey> :t head [3]
05:09:38 <kmc> >>= runs one thing, and feeds the result to a function to determine what to do next
05:09:38 <dcoutts> ttmrichter: that might just be the context that you've got
05:09:38 <lambdabot> forall t. (Num t) => t
05:09:42 <hpc> :t asTypeIn
05:09:43 <lambdabot> forall a b. a -> (a -> b) -> a
05:09:43 <FunctorSalad_> ttmrichter: I mean that some specializations of `head' are a match, so it should output `head'
05:09:49 <mauke> exDM69: not if you've ever seen a callback-based event system
05:09:52 <dcoutts> ttmrichter: and you might be asking "what fits here" ?
05:10:04 <hpc> interesting
05:10:09 <FunctorSalad_> ttmrichter: I agree that some other matches are silly; I think it doesn't do proper unification
05:10:19 <kmc> if x is a recipe, and f is a function generating recipes, then Â«x >>= fÂ» is the recipe "first do x, then pass its result to f to figure out a second thing to do, then do it"
05:10:34 --- mode: ChanServ set +o quicksilver
05:10:36 <FunctorSalad_> ttmrichter: ( which would rule out abs (a -> a) unifying with [b] -> b )
05:10:36 <dcoutts> FunctorSalad_: it used to but Neil found that this search gave more useful results. I think I agree with him.
05:10:40 <Twey> asTypeIn = const :: a -> (a -> b) -> a
05:10:43 --- mode: quicksilver set -c
05:10:44 <fryguybob> quicksilver: colorForth?
05:10:51 <Twey> Thanks
05:10:57 <quicksilver> Twey: do { xx <- bar; 3do something with xx }
05:10:59 <quicksilver> like that ;)
05:11:04 <Twey> Cool.  :-D
05:11:16 <dcoutts> ttmrichter: similarly, for foldl, it can be used to construct something of type Num a => [a] -> a
05:11:18 <quicksilver> but it seems to be unpopular.
05:11:20 --- mode: quicksilver set +c
05:11:23 --- mode: quicksilver set -o quicksilver
05:11:31 <FunctorSalad_> dcoutts: hmm haven't used the type search facility that much (the set of packs searched is too small IMHO), but ISTR that I'd have preferred unification
05:11:37 <ivanm> ugh
05:11:45 <ivanm> let's keep this channel free colourless
05:11:48 <ivanm> all nice and bland
05:11:49 <ivanm> :p
05:11:50 <Twey> quicksilver: I keep +c off in ##English, personally.  It makes highlighting things much easier.
05:11:51 <ville> exDM69: http://codepad.org/0ZfHfThH would the use of 'xx' shadowing the accessor in that context be considered confusing?
05:11:52 <exDM69> ville: the guys above said some pretty good points about the do notation and >>=, I hope you were reading
05:12:15 <ville> exDM69: To the best of my ability, I am not yet clear what >>= does.
05:12:32 <exDM69> ville: look 10 lines up for a good explanation of >>=
05:12:38 <mauke> Philonous: that almost works
05:13:08 <quicksilver> ivanm: IMO people who don't like colour can turn it off in their clients.
05:13:14 <quicksilver> used correctly, it enhances communication.
05:13:15 <mauke> Philonous: no, that works pretty well if I write my own Bounded instance
05:13:18 <kmc> ville, (>>) does the same thing as the semicolon in C, except that it's a normal infix opr and can be overloaded
05:13:19 <quicksilver> used incorrectly, it gets you banned.
05:13:19 <mauke> thanks
05:13:21 * quicksilver grins
05:13:33 --- mode: ChanServ set +o mauke
05:13:33 --- mode: mauke set -c
05:13:44 <kmc> ville, and (>>=) is a version of (>>) where the result from executing the recipe on the left hand side is used to compute the recipe on the right hand side
05:13:53 <FunctorSalad_> uh so is syntax highlighting a 'correct' use in here? :o
05:14:01 <kmc> so it expresses "do something, then use that to decide what to do next"
05:14:10 <quicksilver> fully syntax highlighting is painful within the common available colour set.
05:14:12 <FunctorSalad_> one problem I see is that most schemes would be pretty unreadable either on dark or light
05:14:15 <exDM69> ville: the non-sugared version demonstrates clearly the masking issue, where the lambda abstraction binds the xx
05:14:17 <FunctorSalad_> (background)
05:14:28 <quicksilver> but distinguishing between syntax and meta-syntax, or variables and metasyntactic variables
05:14:31 <quicksilver> is handy.
05:14:39 <FunctorSalad_> good idea
05:14:59 <ville> exDM69: Yes I understod that part, my paste was just trying to highlight where I am using the shadowing and if it is really considered confusing?
05:15:02 <FunctorSalad_> typevars and metatypevars often get mixed up...
05:15:30 <FunctorSalad_> and "..." is a valid operator as we know ;)
05:15:33 --- mode: mauke set -o mauke
05:15:43 <mauke> test: data TypeCon = DataCon
05:15:58 <FunctorSalad_> works
05:16:01 <kmc> :O
05:16:07 <kmc> mauke, you have a program to do the highlighting?
05:16:11 <FunctorSalad_> at least if the intent was that TypeCon is bold and DataCon inverse video
05:16:24 <mauke> kmc: no
05:16:29 <exDM69> ville: obviously you are using fake variable names so it's hard to tell. With good variable names that's probably not an issue
05:16:32 <mauke> FunctorSalad_: well, italic, but good enough
05:16:32 <FunctorSalad_> (or black on white)
05:17:19 <mauke> kmc: I have macros in my irc client, so I type data `b{TypeCon} = `i{DataCon}
05:17:28 <kmc> aha
05:18:01 <ville> exDM69: Fair enough. http://codepad.org/DeGPxAn4 is my actual incomplete code, where I noticed I'd run into shadowing that then prompted the question.
05:19:11 <FunctorSalad_>  /exec ... | hscolour? ;)
05:19:24 <zygoloid> mauke: why not just use ^B and ^V? :)
05:19:25 <FunctorSalad_> if it's even the same markup :o
05:19:36 <mauke> zygoloid: can't remember those
05:19:54 <FunctorSalad_> oooh
05:19:58 <FunctorSalad_> 1,09module HaiWorld
05:20:03 <FunctorSalad_> actually works
05:20:13 <ville> SharkWorld
05:20:18 <FunctorSalad_> that was: /exec -o echo "module HaiWorld" | hscolor
05:20:21 <FunctorSalad_> (xchat)
05:20:33 <Botje> hehe, cool
05:20:36 <benmachine> neat
05:20:42 <exDM69> ville: I'd rename the "variable" in the code in that case
05:20:44 <benmachine> xchat is clever enough to translate the codes?
05:20:52 <benmachine> or do they just work in both contexts
05:20:58 <hpc> they work in both
05:21:11 <hpc> mIRC and ilk are the ones that have to translate the % codes
05:21:12 <ivanm> FunctorSalad_: any idea how to disable the colours from within xchat?
05:21:20 <ville> exDM69: Ok. This must be a recurring pattern in Haskell coding, is there a common naming scheme for this type of sittuation?
05:21:27 <FunctorSalad_> 02fix f 04= 03let f x 04= x 03in x
05:21:27 <FunctorSalad_> 
05:21:32 <FunctorSalad_> that was HsColour now
05:21:43 <FunctorSalad_> hscolour is from the colorize-haskell package iirc
05:21:44 <kmc> HsColour has IRC output?
05:21:44 <mauke> I don't think I like it
05:21:47 <FunctorSalad_> HsColour from HsColour
05:21:56 <copumpkin> very colorful in here
05:21:57 <FunctorSalad_> ivanm: no
05:22:00 <chrisdone> ville: priming?
05:22:00 <exDM69> ville: also you could get rid of the mw prefix there and import the module as qualified
05:22:06 <ivanm> xchat seems to have an option to disable entering coloured stuff...
05:22:14 <benmachine> also, it's let x = f x in x
05:22:15 <benmachine> :P
05:22:21 <FunctorSalad_> hehe
05:22:35 <ivanm> unless i have to go explicitly and set each mIRC colour to black... :s
05:22:36 <exDM69> ville: yeah foo -> foo' is a common haskell naming convention
05:22:37 <mauke> ville: what are you going to do with the variables? just use them to make a MainWindow?
05:22:45 <ville> chrisdone: hah forgot all about that!
05:22:48 <FunctorSalad_> ivanm: that bad already?
05:22:48 <ville> mauke: Yes.
05:22:57 <FunctorSalad_> 'twas just some syntax highlighting :(
05:23:06 <ivanm> FunctorSalad_: I've had it in other channels where someone was using mibbit or something and _everything_ was coloured
05:23:13 <ivanm> so no, it's not bad _here_
05:23:16 <ville> exDM69: I forgot all about the ' in identifiers, too much C++ for me.
05:23:21 <chrisdone> wait are you guys using colours? I thought there were disabled in this channel
05:23:27 <ivanm> just figured that since the subject had come up I'd find out how to ensure it doesn't happen again
05:23:29 <benmachine> chrisdone: they recently got un-disabled
05:23:41 <benmachine> and then like children with new toys we are all going ooh colours
05:23:41 <ivanm> chrisdone: quicksilver opened the flood gate
05:23:44 <FunctorSalad_> in before redisabling
05:23:45 <mauke> ville: then consider: MainWindow <$> Gtk.builderGetObject b Gtk.castToWindow "main_window" <*> ... <*> ...
05:23:48 <benmachine> and then we'll forget about them and never use them again
05:24:19 <FunctorSalad_> but why did that HsColour pipe work?
05:24:21 <ville> mauke: Ok I have to read what <$> and <*> does.
05:24:26 <quicksilver> I deny it.
05:24:31 <FunctorSalad_> are the escape sequences the same for terminal and irc?
05:24:34 <quicksilver> I closed the floodgate too.
05:24:37 <hpc> FunctorSalad_: yes
05:24:40 <benmachine> oh yes you did
05:24:41 <quicksilver> mauke opened it again ;)
05:24:41 <FunctorSalad_> ah
05:24:52 <chrisdone> awesome!
05:25:01 <chrisdone> i can't actually see any of them, but, cool
05:25:09 <benmachine> heheh
05:25:10 <quicksilver> I don't like the hscolour stuff, it's too christmas tree like
05:25:16 <alar> @hoogle ByteString-> String
05:25:17 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
05:25:17 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
05:25:17 <lambdabot> Prelude show :: Show a => a -> String
05:25:22 <quicksilver> I just like something simple to distinguish code and commentary or metasyntax
05:25:32 <alar> @hoogle Word8 -> String
05:25:32 <lambdabot> Prelude show :: Show a => a -> String
05:25:32 <lambdabot> Text.Show show :: Show a => a -> String
05:25:32 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
05:25:42 <chrisdone> quicksilver: it's funny on blogs. oh i'm glad you used *yellow* for this symbol! squinting makes my brain think faster anyway!
05:25:46 <FunctorSalad_> I wasn't really going to use it all the time
05:26:03 <FunctorSalad_> what about "highlight -Shaskell -sacid" though?
05:26:05 <hpc> chrisdone: that's exactly how i feel about blue in terminals
05:26:07 <FunctorSalad_> ;]
05:26:22 <hpc> especially because vim likes to designate that color for comments
05:26:29 <benmachine> hpc: :set background=dark?
05:27:01 <hpc> i just changed the color
05:27:11 <benmachine> that works too I guess ;P
05:27:13 <benmachine> *:P
05:27:26 <mauke> no, fixing the wrong background setting is better
05:27:31 <chrisdone> hpaste's highlighting is nice
05:27:33 <benmachine> I like syntax highlighting in general
05:27:37 <chrisdone> when it's up
05:27:39 <benmachine> but some highlighters make weird decisions
05:27:45 <benmachine> like highlighting zipWith
05:27:53 <benmachine> or other library functions
05:27:54 <chrisdone> huh?
05:27:55 <benmachine> which is silly
05:28:06 <chrisdone> oh, yeah. that's pointless
05:28:20 <chrisdone> you really want to see syntactic boundaries like where strings start and end
05:28:25 <FunctorSalad_> it'd be pointful to highlight all currently legal functions though
05:28:34 <quicksilver> well I could understand highlight identifiers form the current module differently from other modules
05:28:35 <chrisdone> FunctorSalad_: that would be awesome!
05:28:45 <exDM69> the same thing in python, many highlighters highlite zip and map because they're built-in functions in python (ie. implemented in C)
05:28:54 <quicksilver> and highlighting local identifiers (let/lambda/<- bound) differently from module-level ones.
05:28:58 <exDM69> but they're used just like regular functions anway
05:28:59 <chrisdone> quicksilver: maybe a different colour per import
05:29:08 <mauke> chrisdone: god, no
05:29:10 <quicksilver> chrisdone: heh. For most uses I think one would be enough.
05:29:13 <chrisdone> mauke: yeah :P
05:29:14 <benmachine> quicksilver: ooh yes, that'd be good for fixing shadowing
05:29:28 <benmachine> or you could just not shadow but whatever
05:29:40 <chrisdone> personally my highlighting is basically dark shades of blues and greens
05:29:41 <quicksilver> even if you're not shadowing, it help to understand
05:29:44 <quicksilver> (other people's code)
05:29:51 <FunctorSalad_> what a waste that we have this hyperstatic language but nobody cba to do it ;)
05:29:55 * benmachine shadows all the time >>_>
05:30:01 <quicksilver> Ah, this function comes from some library he's importing
05:30:06 <FunctorSalad_> (highlighting based on advanced static analysis)
05:30:10 <quicksilver> this function is somewhere in this file let's read the definition.
05:30:44 <chrisdone> you don't technically need to use colours of colours
05:30:51 <chrisdone> you could just have mini-bar information when the cursor is over it
05:31:03 <chrisdone> like C-c C-t
05:31:13 <quicksilver> yup, that too definitely
05:31:21 <FunctorSalad_> chrisdone: scion had that for local vars
05:31:24 <quicksilver> but I like the idea of 3 colours for "other modules / this module / local"
05:31:25 <chrisdone> s/of colours/of course
05:31:26 <FunctorSalad_> which is awesome
05:31:31 <FunctorSalad_> but it has bitrotten again, sigh
05:31:41 <FunctorSalad_> maybe it has unbitrotten in the meantime
05:31:44 <quicksilver> @seen nominolo
05:31:44 <lambdabot> Unknown command, try @list
05:31:48 <chrisdone> quicksilver: yeah, that's nice. have you tried such a thing?
05:31:49 <quicksilver> preflex: seen nominolo
05:31:49 <preflex>  nominolo was last seen on #ghc 3 days, 16 hours, 33 minutes and 27 seconds ago, saying: Well, the new license says that in order to use it for more than 90 days you *have* to aquire a service contract.  But the academic programme thing might give us the way out.
05:31:52 <quicksilver> chrisdone: no.
05:32:30 <quicksilver> FunctorSalad_: most recent commit august 2009
05:32:37 <quicksilver> FunctorSalad_: diagnosis: mild bitrot.
05:32:40 <chrisdone> i suppose we'd need some kind of intellisense + compilation server combo
05:32:48 <quicksilver> chrisdone: the framework is all there
05:32:54 <quicksilver> has been written multiple times, in fact :)
05:33:01 <quicksilver> but scion is probably the most promising.
05:33:03 <chrisdone> what's it called?
05:33:05 <hpc> this sounds a lot like Eclipse
05:33:06 <chrisdone> oh
05:33:19 <hpc> only for Haskell and preferably not massive bloat
05:33:38 <quicksilver> completion is very hard for haskell.
05:33:41 <chrisdone> Leksah probably does stuff like this but no one's using it because it's not emacs
05:33:46 <chrisdone> s/probaby/definitely
05:33:52 <quicksilver> java is almost uniquely suited to completion
05:34:08 <chrisdone> quicksilver: why's it very hard?
05:34:14 <benmachine> chrisdone: it's not vim either :P
05:34:17 <quicksilver> because it has the property that the stuff to the left of the insertion point (i.e. what you'd just typed) gives you type context on what you're going to type next.
05:34:24 * chrisdone waited for the vim crowd to chime in
05:34:29 <quicksilver> foo.get<TAB>
05:34:48 <quicksilver> the type of 'foo' must already be knowable by the compiler, it can lookup all methods for foo
05:35:02 <quicksilver> in haskell you write the verb before the subject
05:35:06 <quicksilver> getPropery foo
05:35:23 <chrisdone> oh that kind of completion
05:35:23 <quicksilver> and so while you've only typed 'get' the editor can't yet know that your context is going to be foo.
05:35:43 <benmachine> yeah but how often do you use tab-completion in ghci
05:35:44 <quicksilver> it's just one of those weird syntactic coincidences
05:35:50 <benmachine> I use it on nearly everything
05:35:59 <hpc> chrisdone: i use vim over leksah because one is easier to use over ssh
05:36:11 <FunctorSalad_> quicksilver: that only makes it "hard if you want to take the context into account" :)
05:36:11 <quicksilver> benmachine: sure, just sketching to hpc why you can't easily do eclipse completion for haskell
05:36:18 <chrisdone> quicksilver: now that makes me think about all the awesome stuff you could do with analyzing the context
05:36:29 <quicksilver> FunctorSalad_: right. if you don't take the context into account then it's just dumb text completion
05:36:34 <quicksilver> FunctorSalad_: all editors can do that (surely)
05:36:35 <hpc> eclipse also does underlining though, which is potentially more useful
05:36:52 <quicksilver> chrisdone: you can only analyze the parts the user has alreayd typed, though
05:36:57 <chrisdone> i.e. substitute 'undefined' in at the cursor and then wrap a lambda around it. get the type of the function. wallah! -- right?
05:37:00 <chrisdone> "easy" 
05:37:02 <FunctorSalad_> chrisdone: @server: yes, we should definitely put all the generalpurpose metadata stuff into a server that needn't know about editors
05:37:13 <quicksilver> chrisdone: (when he's halfway through a line of code)
05:37:13 <chrisdone> FunctorSalad_: yeah, i agree
05:37:18 <quicksilver> that's what scion is
05:37:25 <quicksilver> a server that needn't know about editors.
05:37:27 <chrisdone> @google scion
05:37:28 <lambdabot> http://www.scion.com/
05:37:28 <lambdabot> Title: Scion
05:37:29 <quicksilver> (AIUI)
05:37:33 <quicksilver> http://github.com/nominolo/scion/commits/master
05:37:34 <FunctorSalad_> hmm
05:37:36 <quicksilver> @where scion
05:37:36 <lambdabot> I know nothing about scion.
05:37:44 <benmachine> I googled scion and found a lot of cars
05:38:01 <quicksilver> @where+ scion http://github.com/nominolo/scion
05:38:01 <lambdabot> Done.
05:38:24 <chrisdone> sound sawesome!
05:38:27 <chrisdone> i'm going to try it tonight
05:39:37 <quicksilver> it probably doesn't work with 6.12
05:39:40 <quicksilver> although, maybe it does
05:39:41 <FunctorSalad_> ah. knew that scion is a server, but wasn't sure if it's general
05:39:48 <quicksilver> nominolo_: does scion work with 6.12?
05:39:56 <quicksilver> preflex: seen nominolo_ 
05:39:56 <preflex>  nominolo_ was last seen on #ghc 20 days, 22 hours, 49 minutes and 19 seconds ago, saying: so it's probably something from the strictness analyser
05:40:07 <quicksilver> @tell nominolo does scion work with 6.12?
05:40:08 <lambdabot> Consider it noted.
05:40:11 <FunctorSalad_> maybe it's easy to fix?
05:40:15 <benmachine> preflex: seen nominolo
05:40:16 <preflex>  nominolo was last seen on #ghc 3 days, 16 hours, 41 minutes and 54 seconds ago, saying: Well, the new license says that in order to use it for more than 90 days you *have* to aquire a service contract.  But the academic programme thing might give us the way out.
05:40:24 <FunctorSalad_> if it's just some things that were renamed in the 6.12 ghc api
05:40:44 <FunctorSalad_> but I'm not good at git :p
05:40:50 <quicksilver> FunctorSalad_: it's probably not very hard, but it might require understanding some bits.
05:41:03 <chrisdone> let myLongVarName = 10 in x * <TAB>
05:41:03 <chrisdone> transform to: \what -> let myLongVarName = 10 in x * what
05:41:03 <chrisdone> :t \what -> let myLongVarName = 10 in x * what -- > Num n => n
05:41:03 <chrisdone> lookup local variables, find myLongVarName, substitute:
05:41:04 <lambdabot> Expr -> Expr
05:41:06 <chrisdone> let myLongVarName = 10 in x * myLongVarName
05:41:10 <chrisdone> could this work!?
05:41:50 <FunctorSalad_> my capslock was just honestly stuck :o
05:42:01 <FunctorSalad_> (and I don't even have a working capslock; it's bound to control)
05:42:02 <benmachine> chrisdone: sounds a bit unpredictable
05:42:11 <chrisdone> benmachine: why?
05:42:12 <benmachine> chrisdone: "pi" is in scope and has that typesig too
05:42:13 <kmc> that makes it harder to get unstuck
05:42:17 <nominolo> quicksilver: the development version works with 6.12
05:42:17 <lambdabot> nominolo: You have 1 new message. '/msg lambdabot @messages' to read it.
05:42:20 <benmachine> not that typesig but
05:42:23 <FunctorSalad_> kmc: indeed. I'm not sure what did it
05:42:26 <chrisdone> benmachine: then you'd type my<TAB>
05:42:28 <kmc> happens to me too
05:42:48 <nominolo> I also added support for doing GHC API stuff in their own process
05:43:03 <nominolo> haven't pushed it to the repo yet, though
05:43:13 <chrisdone> nominolo: how come it's dependent on the GHC version -- because GHC's API changes often?
05:43:41 <nominolo> chrisdone: I added some ifdefs, so it should work with 6.10 as well
05:43:48 <chrisdone> ahh
05:43:54 <nominolo> it's not pretty
05:44:10 <nominolo> chrisdone: what are you doing?
05:44:17 <FunctorSalad_> nominolo: btw what is the meaning of the branches? (hope I'm not confusing your github with some other project there)
05:44:29 <FunctorSalad_> but apparently the master branch wasn't the development one at least for some time
05:45:01 <nominolo> yeah, I know.  It's the devel branch
05:45:12 <nominolo> I should probably change that
05:46:26 <FunctorSalad_> oh I just find git very intimidating in general ;)
05:47:47 <FunctorSalad_> don't think it's just my haskell partiality to say that darcs is a lot easier
05:48:18 <FunctorSalad_> but getting OT
05:48:36 <kmc> git is wonderful :)
05:48:54 <FunctorSalad_> it is? :o
05:48:57 <kmc> yes
05:48:59 <benmachine> I like git
05:49:11 <benmachine> takes some getting used to though
05:49:27 <FunctorSalad_> does it really need to have a zillion commands that to the newb eye seem to do overlapping things? ;)
05:49:29 <kmc> the thing i like about git is that it has a simple immutable data model
05:49:44 <kmc> so you can easily understand what's being stored
05:49:49 <nominolo> FunctorSalad_: yeah, if you don't use the intended workflow it gets really annoying
05:49:49 <FunctorSalad_> ok maybe I should read about that model first
05:49:58 <kmc> git does?
05:50:03 <kmc> git supports lots of workflows
05:50:05 <copumpkin> has anyone wondered how to write modular addition in peano arithmetic?
05:50:29 <kmc> the complexity of git is in the commands which manipulate this store
05:50:39 <nominolo> kmc: in theory, yes.  In practice you have to understand it really well to use most other workflows.
05:50:48 <kmc> nominolo, which workflow is the special one?
05:51:07 <nominolo> well, for one, a new feature branch for everything.
05:51:26 <kmc> i used git extensively in a pretty centralized svn-like workflow and it was fine, and i'm sure that's not how kernel devs use it
05:51:45 <nominolo> kmc: were there other users?
05:51:58 <kmc> many
05:52:14 <burp> I use it in a centralized way with feature branches too
05:52:32 <kmc> the biggest headache we had was that there was a parallel CVS repository
05:52:38 <kmc> that people were still committing to
05:52:45 <kmc> and which had to be merged into git regularly
05:52:49 <burp> rebasing often into feature/bug branches… merge with master and push
05:52:52 <kmc> but even that was relatively doable
05:53:05 <burp> so you don't have "merge commits"
05:53:58 <mun> is "\forall s. s \in S --> P(s) an equivalent expression to "\forall s \in S. P(s)"?
05:55:17 <FunctorSalad_> uh, in set theory the latter is defined to be sugar for the former
05:55:39 <benmachine> the former doesn't really make sense to me
05:55:48 <benmachine> well it kind of does
05:55:52 <mun> well
05:55:54 <mun> i'm not sure myself
05:55:59 <benmachine> but you're allowing s to be absolutely anything at all
05:56:01 <mun> then what is the expanded version of the latter?
05:56:01 <benmachine> which is a bit odd
05:56:07 <FunctorSalad_> benmachine: it makes sense in ZFC defined in untyped first-order logic
05:56:19 <benmachine> ok
05:56:22 <FunctorSalad_> which has only such anything-at-all quantifiers, yes :)
05:56:33 <benmachine> but I think the latter is clearer
05:56:54 <FunctorSalad_> mun: in the setting I mentioned, the latter is defined as the former
05:57:00 <mun> FunctorSalad_, but is there a better expanded form of the latter?
05:57:02 <mun> i see
05:58:00 <chrisdone> nominolo: what am i doing? just curious
05:58:13 <benmachine> open-pandoc is quite an obnoxious name
05:58:54 <quicksilver> nominolo: ah, bad nominolo ;) surely the point of having a github is to make commits visible ;) 
05:59:00 <quicksilver> nominolo: but, excellent that work proceeeds.
05:59:07 <mun> FunctorSalad_, but what if I want to write an expression exp, which has the type real * real. exp = "\forall s t. (s,t)" allows exp to have type real * real given s t are of type real.
05:59:43 <FunctorSalad_> ?
05:59:58 <mun> FunctorSalad_, but exp = "\forall s t. s \in S /\ t \in T --> (s,t)" would make exp a boolean expression, right?
06:00:11 <FunctorSalad_> what formalism is this?
06:00:50 <mun> FunctorSalad_, just untyped first order, where (s,t) is a pair of s and t
06:01:03 <FunctorSalad_> (s,t) is not a proposition
06:01:05 <mun> let alone the pair actually
06:01:10 <mun> ok, let me try again
06:01:11 <FunctorSalad_> it can't be the right arg of (-->)
06:01:32 <FunctorSalad_> that only makes sense in type theory
06:01:44 <FunctorSalad_> (and s,t would have to be quantified over Type)
06:02:12 <mun> would the type of exp in exp = "\forall s. s" and exp = "\forall s. s \in S --> s" be the same?
06:02:34 <FunctorSalad_> "forall s. s" is not a well-formed formula either
06:02:53 <mun> FunctorSalad_, oh?
06:03:13 <FunctorSalad_> "s" is a term in the scope of the quantifier
06:03:26 <FunctorSalad_> but the body must be a proposition
06:03:31 <FunctorSalad_> like "forall s. s = s"
06:03:36 <akosch> is there a haskell implementation i can run on sparc64?
06:03:54 <kmc> akosch, GHC, but its sparc codegen is not great
06:04:01 <kmc> i'd expect it to be better with LLVM
06:04:15 <mun> FunctorSalad_, right
06:04:17 <FunctorSalad_> mun: traditional predicate logic has two "types" on the metalevel: propositions and terms
06:04:26 <FunctorSalad_> quantification is always over terms
06:04:41 <FunctorSalad_> or over individuals, actually
06:04:46 <FunctorSalad_> terms just denote individuals
06:04:47 <akosch> kmc: are you sure it runs on sparc64, not just sparc?
06:05:08 <kmc> akosch, not positive.  i know in the repa paper they had benchmarks on UltraSPARC T2
06:05:15 <kmc> but i don't know if it was in 32-bit or 64-bit mode
06:06:30 <akosch> kmc: thanks. What about hugs and other alternatives...?
06:06:41 * hackagebot uuagc 0.9.24 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.24 (ArieMiddelkoop)
06:06:45 <kmc> hugs is mostly portable C, iirc
06:07:18 <akosch> hm, maybe it's worth checking out
06:09:36 <mun> FunctorSalad_, thansk
06:09:38 <dhouthoo> quit
06:39:54 <BONUS> david haskellhoff
06:41:03 <Cale> BONUS: Is that a new character for the book? :)
06:41:30 <Axman6> oh shit, it's the hoff!
06:41:40 <BONUS> Cale: oh yeah!
06:46:24 <kmc> @pl \(a,b) -> [a,b]
06:46:25 <lambdabot> uncurry ((. return) . (:))
06:46:35 <kmc> @pl concatMap (\(a,b) -> [a,b])
06:46:35 <lambdabot> (uncurry ((. return) . (:)) =<<)
06:46:51 <BONUS> :t sequence [fst,snd]
06:46:51 <lambdabot> forall a. (a, a) -> [a]
06:47:01 <zygoloid> David Haskellhoff, from Maybewatch?
06:47:06 <BONUS> haha
06:47:45 <BONUS> > sequence [fst,snd] (1,2)
06:47:46 <lambdabot>   [1,2]
06:48:00 <FunctorSalad_> BONUS: featured in a new LYAH chapter? ;o
06:48:20 <BONUS> why not
06:48:21 <FunctorSalad_> wtf! the Y reaches into the L horizontally
06:48:34 <FunctorSalad_> is that new in XFT or whatever xchat is using?
06:48:54 <djahandarie> :t sequence [fst,snd]
06:48:55 <lambdabot> forall a. (a, a) -> [a]
06:49:00 <FunctorSalad_> it's not an optical illusion; I can tell from the pixels
06:49:19 <Axman6> welcome to kerning... i think
06:49:41 <djahandarie> Tuples are monads?
06:49:45 <Axman6> no
06:49:51 <djahandarie> Not sure how that works then
06:49:51 <BONUS> functions are
06:49:54 <Axman6> functions are
06:49:55 <FunctorSalad_> Axman6: ok but is it a new feature in the involved frameworks?
06:49:55 <djahandarie> Ah
06:50:13 <Axman6> who knows, I use an Os which has always had it :)
06:50:17 <djahandarie> Would that only work with the (->) instance?
06:50:24 <FunctorSalad_> tuple-with-a-fixed-type is a monad if the fixed type is a monoid
06:50:39 <Axman6> djahandarie: basically, f >>= g == \x -> g (f x) x
06:50:43 <Axman6> i think
06:50:43 <FunctorSalad_> I once dreamed that there was a Writer instance, but apparently there isn't
06:51:21 <FunctorSalad_> instance Writer w ((,) w) -- this
06:52:10 <FunctorSalad_> instance Monid w => MonadWriter w ((,) w) 
06:52:12 <FunctorSalad_> :p
06:52:47 <djahandarie> > sequence [head, last] [1,2,3]
06:52:48 <lambdabot>   [1,3]
06:53:25 <Saizan> there's Monoid w => Applicative ((,) w), i think
06:53:26 <Axman6> > replicateM 3 show 1
06:53:27 <lambdabot>   ["1","1","1"]
06:53:31 <Axman6> :\
06:53:33 <FunctorSalad_> Saizan: ah
06:53:46 <FunctorSalad_> that may have caused the confusion
06:57:37 <FunctorSalad_> btw why do monoid-constrained variables traditionally get the name `w'? ;)
06:58:55 <FunctorSalad_> from the association with Writer maybe...
06:59:30 <Saizan> i've seen m used if there isn't a monad around too
07:00:18 <Saizan> but yeah, i think w comes from Writer 
07:09:04 <BONUS> FunctorSalad_: now look what you made me do http://dl.dropbox.com/u/665999/haskellhoff.png
07:09:38 <ivanm> @slap BONUS 
07:09:38 * lambdabot pokes BONUS  in the eye
07:10:29 <dv-> lol
07:11:12 <djahandarie> Bahaha
07:11:16 <djahandarie> NSFW!!!
07:12:32 <BONUS> i didn't know jeresig was a moderator of the haskell reddit
07:12:37 <BONUS> isn't he the guy who invented javascript
07:12:42 <BONUS> along with douglas crockford
07:13:33 <ivanm> well, he created the haskell reddit
07:13:40 <ivanm> way back before dons thought of having one
07:14:14 <benmachine> instance Monad ((->) t)
07:14:18 <benmachine> bzzt
07:14:21 * benmachine scrolled up
07:14:32 <edwardk> BONUS: my eyes!
07:14:51 <BONUS> >:)
07:14:52 <edwardk> Don't Haskell the Hoff
07:15:36 <edwardk> BONUS: javascript was brendan eich
07:16:20 <BONUS> ah, right. john resig made jquery then
07:16:27 <edwardk> BONUS: yeah
07:16:53 <edwardk> eich is to blame for javascript, jresig just made it cool ;)
07:17:01 <FunctorSalad_> BONUS: omg
07:18:35 <mauke> FFFFFFFFFFFFUUUUUUUUUUUUU
07:19:07 <mauke> why is everything so broken
07:19:21 <Zao> The Haskell motto just kicked in, yo.
07:19:38 * edwardk finally figured out how to transpose a pair of Traversables (I just need another copy of the inner one to use as a skeleton!)
07:20:02 <mauke> hopefully cabal configure can run arbitrary code
07:20:03 <Saizan> BONUS: that's going to be the cover, right?:)
07:23:52 <BONUS> Saizan: haha, oh my people would be furious
07:24:42 <FunctorSalad_> mauke: http://hackage.haskell.org/packages/archive/Cabal/1.8.0.4/doc/html/Distribution-Simple.html#v%3ApreConf
07:24:45 <FunctorSalad_> seems like it
07:25:21 <mauke> yes, but it still sucks
07:26:01 <mauke> because now I have to figure out how to run whatever C compiler is used on that platform
07:26:28 <FunctorSalad_> uh doesn't that arg your hook is given contain that info?
07:28:26 <mauke> I don't know
07:31:37 <mauke> bah, why do I even care
07:31:49 <mauke> this thing will use ghc on unix, the end
07:37:09 <ville> http://www.haskell.org/gtk2hs/docs/devel/System-Glib-GError.html -- how fitting.
07:37:12 <FunctorSalad_> mauke: didn't find a c compiler in the arg to confHook, but maybe the cabal api has some IO function to obtain it...
07:37:33 <FunctorSalad_> cabal does need one, doesn't it
07:38:28 <mauke> I have an even better idea: forget cabal
07:39:32 <mauke> because hsc2hs is broken and I have no idea how to make cabal go through the contortions to work around it
07:39:54 <dcoutts> mauke: what's the problem exactly?
07:40:20 <mauke> I have a .hsc file with custom #defines for code generation
07:40:39 <mauke> those macros need access to the library I'm wrapping
07:40:51 <mauke> ok, so I #include "whatever.h"
07:41:14 <mauke> (this is just a local test, btw; the C library isn't installed yet)
07:41:59 <mauke> I run hsc2hs with the right -I.. flag; get linker errors for the functions
07:42:21 <mauke> ok, makes sense; the generated C program needs the actual library, not just the header
07:42:26 <dcoutts> right
07:42:38 <mauke> so I add -L-L.. -L-lwhatever
07:42:45 <mauke> same result
07:43:13 <mauke> because even though I put -L-lwhatever at the end, hsc2hs helpfully reorders my command line and puts -lwhatever first
07:43:18 <mauke> where it's ignored
07:43:27 <dcoutts> mauke: ah, fun
07:43:39 <dcoutts> where as it should put -L flags first
07:44:02 <dcoutts> it's slightly odd that it reorders them at all
07:44:53 <mauke> % hsc2hs -L-L.. -I.. System/Console/Unibilium/Enum/Bool.hsc -L-lunibilium
07:44:53 <mauke> ...
07:44:53 <mauke> command was: /home/mauke/usr/local/bin/gcc -L.. -lunibilium System/Console/Unibilium/Enum/Bool_hsc_make.o -o System/Console/Unibilium/Enum/Bool_hsc_make
07:45:22 <dcoutts> mauke: that's not reordered
07:46:23 <mauke> depends
07:46:39 <mauke> it pulled the -l option in front of the filename
07:47:16 <dcoutts> oh I see what you mean
07:47:46 <dcoutts> it should put the .o first
07:47:51 <mauke> yes
07:48:12 <dcoutts> has this been reported?
07:48:27 <mauke> apparently not, I'm still looking through ghc trac
07:48:28 <dcoutts> I know you're also looking for a workaround, but it also needs to be fixed properly
07:49:25 <alar> what's the best way to turn ByteString into hex string?
07:49:29 <mauke> workaround is hsc2hs --no-compile, then run ghc on the .c file
07:49:38 <dcoutts> FunctorSalad_: btw, to run gcc in a Cabal Setup.hs you use something like: rawSystemProgramConf verbosity gccProgram progConf flags
07:50:14 <dcoutts> FunctorSalad_: that will then respect --with-gcc= and --gcc-options= flags on the command line
07:50:38 <mauke> while I'm at it, embedding C code in hsc2hs files is needlessly complicated
07:52:37 <alar> concatMap (\x-> hex!! (shiftR x 4):(hex!! (x .&. 0xF)):[]) where hex="0123456789ABCDEF" looks very ugly
07:53:07 <alar> :t shiftL
07:53:07 <lambdabot> forall a. (Bits a) => a -> Int -> a
07:53:26 <zygoloid> @type Data.ByteString.Char8.foldr (showHex . ord) []
07:53:27 <lambdabot> BSC.ByteString -> String
07:53:31 <mauke> alar: I'd use printf "%*v02X" "" str
07:53:44 <alar> @hoogle showhex
07:53:44 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
07:54:02 <zygoloid> > BSC.foldr (showHex . ord) [] (BSC.pack "Hello")
07:54:03 <alar> @karma+ zygoloid
07:54:03 <lambdabot>   "48656c6c6f"
07:54:03 <lambdabot> zygoloid's karma raised to 5.
07:54:24 <mauke> whoops, except it's broken
07:54:45 <mauke> you need printf "%*v.2X" ""
08:01:29 <mreh> @instances functor
08:01:29 <lambdabot> Couldn't find class `functor'. Try @instances-importing
08:01:33 <mreh> @instances Functor
08:01:34 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:01:41 <mreh> there's no IArray
08:02:09 <mreh> well, with an import even
08:02:49 * Saizan bends it
08:04:43 <mreh> :|
08:04:52 <mreh> wat
08:06:31 <mauke> dcoutts: filed #4115
08:07:26 <mreh> I think I see why, it's odd that the Array typeclass is not parameterised on the index too
08:08:18 <Saizan> it should be easy to write instance Ix i => Functor (Array i e) where ...
08:09:06 <mreh> Array includes mutable arrays also
08:09:08 <mreh> not good
08:09:22 <Saizan> no, Array is a type (constructor) not a class.
08:10:07 <mreh> so how does Functor (Array i e) make sense?
08:10:15 <mreh> oh right
08:10:23 <Saizan> err, without e
08:10:23 <dcoutts> mreh: I agree, there are some array types that cannot be made instances of the array class because they only work for some index types (e.g. bitmaps are only 2-d arrays)
08:10:36 <Saizan> Functor (Array i)
08:11:46 <mreh> why don't we have an array preprocessor included in Haskell' and make the whole thing neat
08:12:28 <mreh> Array (i, i) e = Array i (Array i e)
08:12:42 <mreh> makes unboxing hard
08:12:43 <Saizan> you could make "instance (forall e. IArray a e, Ix i) => Functor (a i) where" if you weren't afaird of overlapping instances and you could have "forall e. IArray a e" in a context
08:13:05 <mreh> hang on, my brain is trying to escape
08:13:05 <Saizan> though maybe you can do something similar with gadts
08:13:12 <marcuy> does anyone knows if it's possible to set up a deterministic pushdown automata for {a^n b^m / n>m}  (i'm having troubles to reach the final state)
08:13:44 <soupdragon> marcuy, man.. that is hard
08:13:55 <Saizan> mreh: "Array (i, i) e = Array i (Array i e)" looks like something you can write with data families
08:14:15 <mreh> Saizan: what are those?!
08:14:22 <Saizan> or type families..
08:14:32 <marcuy> soupdragon, any ideas?
08:14:37 <Saizan> mreh: heard of LANGUAGE TypeFamilies ?
08:15:04 <soupdragon> marcuy, no.. that's why I said it's so hard
08:15:32 <soupdragon> marcuy, welll..... Maybe you could construct an NFA for it first
08:15:49 <soupdragon> because it's always possible to convert NFA to DFA isn't it?
08:16:17 <marcuy> I've constructed a non deterministic pushdown automata for that language, but I can't do it with a deterministic one
08:16:49 <soupdragon> marcuy, but there is an algorithm to convert NFA to DFA isn't there?
08:17:26 <marcuy> soupdragon, yes, but this is about pushdown automatas, not finite automatas
08:17:35 <soupdragon> oh sorry
08:17:37 <soupdragon> okay
08:18:42 <soupdragon> marcuy I guess you could look at it as { a^m a^k b^m }
08:18:48 <soupdragon> so that n=m+k
08:19:01 <soupdragon> for a PDA that might work I think
08:20:36 <soupdragon> marcuy; what do you think?
08:20:43 <FunctorSalad_> apparently it has to guess nondet'cally where a^m ends and a^k begins
08:23:27 <marcuy> soupdragon, as FunctorSalad_ says, I think we are in the same problem with the pushdown atomata
08:24:21 <marcuy> soupdragon, I can't push M elements and then ignore K elements
08:24:36 <soupdragon> hm
08:25:07 <FunctorSalad_> is there some convenient property that deterministic context-free langs have? that could help you to prove that this one isn't
08:25:58 <marcuy> FunctorSalad_, as far as I know no..
08:26:04 <fusion5> hi, if i have datatypes such as these (except much much bigger), what should i use to convert from arbitrary List values to PList values and viceversa? http://pastebin.com/VKL0PWDu
08:26:25 <FunctorSalad_> (... and that context-free langs don't have, obviously :))
08:26:40 <FunctorSalad_> in general
08:28:09 <markus3> hi! a question: if i import Data.Array and do "listArray (0, maxBound-1 :: Int) []", then ghci exits...
08:28:18 <markus3> why is that?
08:28:38 <markus3> no error, no nothing.. just exits
08:28:58 <markus3> this happens in cygwin
08:30:58 <markus3> cmd on the other hand starts to print the array, says the first value is (0, ()), then hangs, stops responding and exits
08:33:13 <siracusa> markus3: Same for me, I didn't try it in cygwin but I think the cygwin output is buffered
08:33:47 <siracusa> markus3: I'd guess it tried to allocate to complete array in memory which fails
08:34:10 <markus3> yepm and sometimes cmd prints out a few more values than just zero, and prints the values to be "()"
08:34:42 <markus3> like [(0,()), (1, ()), ....
08:35:40 <markus3> anyway, I'm trying to encode a big bunch of strings into ints, so that my program would run faster, which datastructure would be good for ding that?
08:35:54 <markus3> I could use lists, but the lookup is O(n)
08:36:26 <markus3> I could use arrays, but I don't know how big of an array I would need...
08:36:56 <FunctorSalad_> markus3: hmmm it oughtn't ever do that unless you use unsafeCoerce or similar
08:37:07 <FunctorSalad_> but I have no idea about Data.Array
08:37:38 <FunctorSalad_> but sounds like a bug if `listArray' isn't specifically documented as "zomg dangerous never use thsi"
08:37:43 <markus3> first time for me too
08:38:15 <siracusa> Interesting, `listArray (0, 1 :: Int) []' yields `array (0,1) [(0,*** Exception: (Array.!): undefined array element'
08:38:23 <kmc> markus3, consider IntMap
08:38:40 <kmc> (it's faster than the more generic Map)
08:38:46 <soupdragon> siracusa doesn't seem that interesting to me
08:38:55 <markus3> siracusa: yep, but thats supposed to be -- when you don't give values, all are undefined
08:39:16 <markus3> kmc: ok, I'll check it out
08:39:37 <markus3> is the lookup log n like for regular maps?
08:40:31 <markus3> I thought about using maps: strings as keys and ints as the encoded values: and then keep track of the max value
08:40:35 <kmc> sort of
08:40:42 <kmc> it's bounded by the size of Int on your platform
08:40:54 <kmc> anyway i think that asymptotic complexity analysis is worse than useless in these situations
08:41:13 <markus3> why do you say that?
08:41:19 <FunctorSalad_> markus3: "array Segmentation fault" on linux too
08:41:44 <markus3> FunctorSalad_: hmm
08:41:55 <kmc> because there are a lot of important constant factors
08:42:11 <kmc> and the typical container does not have tens of millions of elements
08:42:23 <markus3> at least the memory dosn't start to grow, when i initiate the array to have bounds from 0 to maxBound :: Int
08:42:39 <kmc> you see people bend over backwards to use arrays or fancy hash tables because "it's O(1) not O(log n)"
08:42:41 <FunctorSalad_> and the docs don't contain any warnings...
08:42:44 <kmc> even when they have 1000 elements
08:42:46 <FunctorSalad_> bug, I'd say
08:42:46 <kmc> and log n is 7.
08:43:13 <siracusa> soupdragon: Ok, after having a glance at the Array docs it's not that interesting to me anymore  ;-)
08:43:54 <FunctorSalad_> > log 1000
08:43:55 <lambdabot>   6.907755278982137
08:44:01 <FunctorSalad_> :)
08:44:07 <soupdragon> > 2^7
08:44:08 <lambdabot>   128
08:44:17 <soupdragon> > exp 7
08:44:17 <FunctorSalad_> > (exp 1)**7
08:44:18 <lambdabot>   1096.6331584284583
08:44:18 <lambdabot>   1096.6331584284585
08:44:22 <FunctorSalad_> ;)
08:44:29 <kmc> not quite the same
08:44:40 <soupdragon> > map log . iterate (10*) $ 1
08:44:41 <lambdabot>   [0.0,2.302585092994046,4.605170185988092,6.907755278982137,9.21034037197618...
08:44:50 <FunctorSalad_> kmc: huh? should be
08:45:04 <soupdragon> > map )(1/log 2) * log) . iterate (10*) $ 1
08:45:04 <lambdabot>   <no location info>: parse error on input `)'
08:45:06 <soupdragon> > map ((1/log 2) * log) . iterate (10*) $ 1
08:45:07 <lambdabot>   [0.0,3.3219280948873626,6.643856189774725,9.965784284662087,13.287712379549...
08:45:14 <FunctorSalad_> x**y =def= exp(y*log x)
08:45:26 <FunctorSalad_> as I know it...
08:45:38 <kmc> > (exp 1)**7 - exp 7
08:45:38 <lambdabot>   -2.2737367544323206e-13
08:45:55 <FunctorSalad_> okay, not in floating point ;)
08:45:57 <soupdragon> -2.2737367544323206e-13 = 0
08:46:09 <Peaker> kmc, Hash tables do have a much smaller constant in a lot of cases
08:46:19 <kmc> yeah
08:46:26 <Peaker> kmc, I think mostly they bend over for this smaller constant, I think they're aware its not an O() issue mostly
08:46:33 <kmc> i'm not convinced
08:46:40 <kmc> anyway, trees have their own problems
08:46:43 <kmc> binary trees really suck
08:46:49 <kmc> but high-arity trees are good
08:47:01 <FunctorSalad_>  /nick BinaryTree;/say :(
08:47:43 <Peaker> I want a data structure that can be more expensive to build/modify, but has really fast lookups (can't be a dense array, would rather have something better than log(N) lookup). I think a hash table with carefully selected hash may be a good choice there
08:48:01 <kmc> yeah
08:48:37 <Peaker> kmc, At my workplace, we really need small-constant lookup structures and hashes do seem to be much better at this than binary search trees, even if they are susceptible to much worse worst-cases
08:51:50 <fasta> kmc, n-ary vs binary is an implementation detail if the software is flexible. 
08:52:11 <kmc> yeah
08:52:16 <fasta> E.g. in Haskell, the compiler could rewrite binary to n-ary, with n>2. 
08:52:24 <kmc> it's an implementation detail with dramatic performance implications
08:52:27 <kmc> fasta, in tree structures?
08:52:31 <fasta> kmc, sure. 
08:52:42 <fasta> Just that it doesn't do so, is another story. 
08:52:46 <kmc> how would the optimization work?
08:53:28 <quicksilver> kmc: it's like unfolding recursive functions
08:53:32 <quicksilver> only for data structures
08:53:43 <fasta> It would involve all kinds of specification about the hardware and this information would be made available to the compiler. Based on that, the compiler might decide that doing what quicksilver already said. 
08:53:55 <quicksilver> data Tree a = Tip a | Bin (Tree a) (Tree a)
08:53:56 <quicksilver> because
08:53:58 <quicksilver> becomes
08:54:36 <quicksilver> data Tree a = Tip a | BinTipTip a a | BinTipBin a (Tree a) (Tree a) | BinBinTip (Tree a) (Tree a) a
08:54:51 <kmc> yeah
08:55:00 <soupdragon> um
08:55:02 <quicksilver> no idea under what circumstances that's an optimisation :)
08:55:13 <soupdragon> data Tree' a = Tip a | BinTipTip a a | BinTipBin a (Tree' a) (Tree' a) | BinBinTip (Tree' a) (Tree' a) a
08:55:18 <kmc> there are strictness issues
08:55:28 <quicksilver> there are, yes.
08:56:03 <kmc> i don't think you'll get an efficient n-ary tree type by writing a 2-ary tree and having the compiler do a general-purpose optimization
08:56:14 <fasta> kmc, and why not?
08:56:25 <soupdragon> so I can ask:  That was from Tree a = Mu F[a] where F[a] = a + X*X to Tree' = Mu (F[a]oF[a])?
08:56:37 <kmc> because as the library author you can make more assumptions than the compiler can
08:56:41 <kmc> you know how the tree will be used
08:56:51 <kmc> e.g. as an associative container or whatever
08:57:20 <soupdragon> or if you started ith 1+X data N = Z | S N you'd get 1 + (1 + X) data N' = Z | O | SS N'?
08:57:47 <fasta> kmc, by definition you are right in that case, yes. 
08:58:05 <fasta> kmc, a solution is to make a compiler that can understood those assumptions. 
08:58:10 <fasta> understand*
08:58:20 <markus3> heh: I was testing IntMap and did "let new = insert 1 "bcd" new" and guess wat happened...
08:58:25 <kmc> it seems the wrong way to approach the problem, if all you want is fast associative containers
08:58:32 <kmc> but there are other benefits
08:58:35 <kmc> markus3, what?
08:58:48 <markus3> infinite loop :p
08:58:58 <kmc> ;P
08:58:58 <markus3> works in python though :)
08:59:04 <fasta> markus3, that's what I had expected.
08:59:05 <kmc> yeah
08:59:23 <kmc> in ghc-compiled code, it might quit with the exception "<<loop>>"
08:59:24 <mauke> markus3: how do you do that in python?
08:59:26 <Peaker> ghc is so inconsistent about flags. "-main-is", "--make", "-threaded"
08:59:39 <fasta> In Python if you write list = list.append(bar) you get something unexpected, imho.
08:59:44 <markus3> you know, like in any imerative language
08:59:52 <mauke> markus3: ?
08:59:54 <markus3> x = x +1
08:59:54 <kmc> right, the superficially similar syntax does something different
09:00:04 <kmc> because "let" isn't assignment
09:00:07 <markus3> if x was 2, then now its 3
09:00:07 <mauke> markus3: that's not recursive
09:00:24 <mauke> markus3: this is more like int x = x + 1; in C
09:03:50 <Peaker> What's the difference between "seq" and "pseq"?
09:04:22 <mauke> pseq is for evaluating expressions in sequence in parallel, obviously!
09:05:38 <markus3> anyway thanks for the help, IntMap does what I want...
09:06:11 <jnj> Quick question, can I list methods of a type class in ghci? Like, showing ==,/= of the Eq class.
09:06:18 <kmc> :browse Eq
09:06:21 <jnj> Thank you
09:06:23 <kmc> err
09:06:26 <Peaker> :info
09:06:30 <kmc> that's the one
09:06:34 <jnj> :) Thanks
09:07:00 <kmc> Peaker, http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg10973.html second para
09:19:42 <Peaker> kmc, I like Simon Marlow :)
09:19:48 <kmc> :)
09:22:22 <mnislaih> Any software developer located in Cambridge who can help me with a local question ?
09:31:57 * hackagebot openid 0.1.4.6 - An implementation of the OpenID-2.0 spec.  http://hackage.haskell.org/package/openid-0.1.4.6 (TrevorElliott)
09:32:15 <Liskni_si> what's the current status of cabal-install versus parsec3?
09:46:24 <ddarius> pseq has operational guarantees that seq doesn't.
09:47:00 <ddarius> Denotationally, there is no difference.
09:49:16 <c_wraith> @hoogle [(a,b)] -> ([a], [b])
09:49:16 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
09:49:16 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
09:49:31 <c_wraith> huh.  I should have known that.
09:51:37 <djahandarie> So why does the fixed type of the tuple need to be a monoid for the tuple to be a monad?
09:51:57 <bastl> how can i pass comdline-args to ":main" in ghci ?
09:52:03 <kmc> djahandarie, you need a "default" value
09:52:05 <kmc> to implement return
09:52:08 <c_wraith> djahandarie, it significantly aids in the definition of return
09:52:10 <kmc> return :: a -> (b,a)
09:52:32 <c_wraith> I guess technically, if there was a Pointed class, it would be enough for return.
09:52:34 <kmc> and you have to combine things somehow
09:52:44 <c_wraith> But you need Monoid for >>=
09:52:50 <Taejo> c_wraith: point :: a -> f a, you want default :: a
09:53:17 <c_wraith> oh, you're right.  pointed doesn't fit.
09:53:30 <c_wraith> kind error in my brain. >_>
09:53:49 <djahandarie> Hm
09:54:09 <soupdragon> :t choose
09:54:09 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
09:54:30 <ddarius> c_wraith: Pointed is the right term though.
09:54:56 <soupdragon> @let factorial n = product [1..n]
09:54:57 <lambdabot>  Defined.
09:55:09 <soupdragon> > let choose n k = (factorial n / factorial k) / factorial (n-k) in choose 200 100 / 4^100
09:55:10 <lambdabot>   Infinity
09:55:14 <soupdragon> > let choose n k = (factorial n / factorial k) / factorial (n-k) in choose 20 10 / 4^10
09:55:15 <lambdabot>   0.17619705200195313
09:55:58 <c_wraith> :t ^
09:55:59 <lambdabot> parse error on input `^'
09:56:02 <c_wraith> :t (^)
09:56:02 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
09:56:07 <c_wraith> :t (**)
09:56:08 <lambdabot> forall a. (Floating a) => a -> a -> a
09:56:43 <c_wraith> hmm.  ^ is right...  oh.  soupdragon, define factorial with div instead of /
09:56:52 <c_wraith> that will make it default to Integer
09:57:04 <c_wraith> err, I mean, define choose with div
09:57:09 <eevar> anyone with a reddit account who could add http://www.fatvat.co.uk/search/label/haskell to the aggregator? -- I don't know the guy, but enjoy his posts and assume redditing someone is fine w/o asking first..?
09:57:14 <soupdragon> > let choose n k = (factorial n / factorial k) / factorial (n-k) in choose 40 20 / 4^20
09:57:15 <lambdabot>   0.12537068761957926
09:57:20 <soupdragon> > let choose n k = (factorial n / factorial k) / factorial (n-k) in choose 80 40 / 4^40
09:57:20 <lambdabot>   8.89278787739072e-2
09:57:25 <soupdragon> > let choose n k = (factorial n / factorial k) / factorial (n-k) in choose 160 80 / 4^80
09:57:26 <lambdabot>   6.297983078680194e-2
09:57:33 <soupdragon> it's tending to 0? boring
09:58:12 <Olathe> @src foldl
09:58:12 <lambdabot> foldl f z []     = z
09:58:12 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:58:13 <Olathe> @src foldl'
09:58:13 <lambdabot> foldl' f a []     = a
09:58:13 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:58:17 <ddarius> factorial n `div` factorial k = product [k..n] assuming k <= n
09:58:52 <Olathe> Is strictness going to help with foldb ?
09:59:13 <Cale> eevar: You know that all you need to create a reddit account is a choice of username and password, and the ability to answer a captcha :)
09:59:31 <ddarius> It's the captchas that get me.
09:59:33 <eevar> that latter part never works for me
09:59:54 <ski> Olathe : `foldb' being ?
10:00:05 <ski> a monoidal fold ?
10:00:19 <ddarius> ski: A tree structured fold.
10:00:35 <soupdragon> why not call it tree
10:00:47 <soupdragon> if the data type si  Xfloo I call the fold  xfloo
10:00:52 <Olathe> ski: Pairwise fold.
10:00:56 <Cale> I might have come up with that name... it was for 'fold binary'
10:01:06 <ddarius> Not a fold on a tree, a fold on a list with a tree structure of combination.
10:01:25 <ski> ok, that's more or less what i meant by "monoidal fold", then
10:01:59 <ski> (thinking of the list type as a free monoid, and using that to bracket the sub-computations in (hopefully) more efficient ways)
10:02:14 <ddarius> ski: I figured, I was just being more specific.
10:02:38 <ski> np (i was just thinking you actually meant a fold on an actual tree type)
10:04:08 <ski> afaiu, the reason adding strictness can help with `foldl' is that it is uses an accumulator
10:04:43 <ski> if the accumulator is "small", then it can go some time before the accumulator is actually forced, hence forcing it incrementally can help
10:06:01 <ski> so, how would this `foldb' work ? split a list into a head, and two interleaves halves of the rest, and do recursive calls on the halves ?
10:07:21 <Olathe> ski: http://codepad.org/IWWJen18
10:07:26 <ski> ok
10:07:29 <ddarius> > let foldb (*) e [] = e; foldb (*) e [x] = x; foldb (*) e xs = foldb (*) e (foldb' xs) where foldb' (x:y:xs) = x*y:foldb' xs; foldb' xs = xs in foldb (*) 1 [1..10]
10:07:30 <lambdabot>   3628800
10:09:19 <ddarius> @let foldb (*) e [] = e; foldb (*) e [x] = x; foldb (*) e xs = foldb (*) e (foldb' xs) where foldb' (x:y:xs) = x*y:foldb' xs; foldb' xs = xs
10:09:20 <lambdabot>  Defined.
10:09:36 <Olathe> > foldl (++) "a" ["b", "c"]
10:09:37 <lambdabot>   "abc"
10:09:41 <Olathe> > foldr (++) "a" ["b", "c"]
10:09:42 <lambdabot>   "bca"
10:09:45 <Olathe> > foldb (++) "a" ["b", "c"]
10:09:46 <lambdabot>   "bc"
10:10:05 <ddarius> > foldb (+) z [a,b,c,d,e,f,g,h]
10:10:05 <lambdabot>   a + b + (c + d) + (e + f + (g + h))
10:10:17 <ski> Olathe : the two first arguments are supposed to form a monoid
10:10:22 <soupdragon> neat
10:10:35 <soupdragon> > foldb (+) z [1..]
10:10:38 <lambdabot>   mueval-core: Time limit exceeded
10:10:41 <soupdragon> > foldb (+) z [1..100]
10:10:45 <lambdabot>   1 + 2 + (3 + 4) + (5 + 6 + (7 + 8)) + (9 + 10 + (11 + 12) + (13 + 14 + (15 ...
10:11:11 <Olathe> foldb is nice for sums.
10:12:04 <ski> > foldb (++) mempty [Just "a",Just "bc",Nothing,Just "",Just "def"]
10:12:05 <lambdabot>   Just "abcdef"
10:12:21 <ddarius> :t (++)
10:12:25 <Olathe> > foldl' (+) 0 . map (1/) $ [1..4096::Rational]
10:12:28 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:12:28 <lambdabot>   mueval-core: Time limit exceeded
10:12:32 <Olathe> > foldb (+) 0 . map (1/) $ [1..4096::Rational]
10:12:33 <lambdabot>   248861304146222747678734619489099620720646863515990397874790491713295179000...
10:12:46 <Olathe> Much faster.
10:13:37 <djahandarie> :t mappend
10:13:38 <lambdabot> forall a. (Monoid a) => a -> a -> a
10:14:16 <djahandarie> I see that (++) == mappend in lambdabot
10:14:19 <djahandarie> @src (++)
10:14:19 <lambdabot> []     ++ ys = ys
10:14:19 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:14:19 <lambdabot> -- OR
10:14:19 <lambdabot> xs ++ ys = foldr (:) ys xs
10:14:25 <djahandarie> No NB :-(
10:14:32 <ski> bug Cale ?
10:18:13 <djahandarie> > (+3) . [1,2,3]
10:18:14 <lambdabot>   [4,5,6]
10:18:43 <djahandarie> > (+3) . Just 5 ++ 9
10:18:44 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
10:18:44 <lambdabot>    arising from a use of...
10:18:48 <djahandarie> Haha oops
10:19:50 <djahandarie> > (+3) . Just 5 ++ Just 9
10:19:51 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:19:51 <lambdabot>    `Data.Monoid.Monoid a'
10:19:51 <lambdabot>  ...
10:21:02 <ksf> http://crazymotion.net/haskell-uber-alles/wM6PIs7UzXn4jAy.html
10:24:48 <ski> @let foldbB (*) u [] = u; foldbB (*) u [a] = a; foldbB (*) u (a:as) = a * foldbB (*) u (comb as) where comb (a0:a1:as) = a0 * a1 : comb as; comb as = as
10:24:50 <lambdabot>  Defined.
10:25:52 <ski> > foldb (+) z [0 .. 9999999]
10:26:00 <lambdabot>   mueval: ExitFailure 1
10:26:01 <ski> > foldbB (+) z [0 .. 9999999]
10:26:05 <lambdabot>   mueval-core: Time limit exceeded
10:26:22 <ski> (hm, that worked just 10 seconds ago ..)
10:26:28 * ski tries once more
10:26:30 <ski> > foldb (+) z [0 .. 9999999]
10:26:30 <djahandarie> > (fmap (+10) getSum) . (Just (Sum 5) ++ Just (Sum 9))
10:26:31 <lambdabot>   Ambiguous occurrence `getSum'
10:26:31 <lambdabot>  It could refer to either `Data.Monoid.getSum...
10:26:36 <djahandarie> Gah
10:26:36 <lambdabot>  Terminated
10:26:38 <ski> > foldbB (+) z [0 .. 9999999]
10:26:41 <djahandarie> > (fmap (+10) Data.Monoid.getSum) . (Just (Sum 5) ++ Just (Sum 9))
10:26:42 <lambdabot>   mueval-core: Time limit exceeded
10:26:45 <lambdabot>   Ambiguous occurrence `Sum'
10:26:45 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
10:26:52 * djahandarie sighs
10:27:03 <djahandarie> > (fmap (+10) Data.Monoid.getSum) . (Just (Data.Monoid.Sum 5) ++ Just (Data.Monoid.Sum 9))
10:27:05 <lambdabot>   Just 24
10:28:32 <ski> hm
10:28:35 <ski> > foldbB (+) z [0 ..]
10:28:36 <lambdabot>   0 + (1 + 2 + (3 + 4 + (5 + 6) + (7 + 8 + (9 + 10) + (11 + 12 + (13 + 14)) +...
10:28:40 <ski> > foldb (+) z [0 ..]
10:28:50 <lambdabot>   mueval: ExitFailure 1
10:28:54 <djahandarie> Whoa
10:28:55 <ski> i suppose i should i tried that immediately
10:29:09 <Olathe> @let foldb2 :: (a -> a -> a) -> a -> [a] -> a; foldb2 _ s [] = s; foldb2 f s xs = go xs where go [x] = f x s; go xs = go (pairAp xs); pairAp (x:y:zs) = f x y:pairAp zs; pairAp xs = xs
10:29:09 <ski> s/should i/should've/
10:29:11 <djahandarie> Why is it not adding those numbers
10:29:12 <lambdabot>  Defined.
10:29:18 <ski> Olathe : `z :: Expr'
10:29:29 <c_wraith> djahandarie, because of the z
10:29:31 <ski> arg, s/Olathe/djahandarie/
10:29:32 <Olathe> > foldb (+) z [0..]
10:29:34 <c_wraith> > f z
10:29:34 <djahandarie> Ah
10:29:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:29:35 <lambdabot>    `GHC.Show.Show a'
10:29:35 <lambdabot>      a...
10:29:36 <lambdabot>   mueval-core: Time limit exceeded
10:29:43 <Olathe> > foldb (+) (z::Expr) [0..]
10:29:43 <djahandarie> Didn't see that
10:29:49 <lambdabot>   mueval: ExitFailure 1
10:30:05 <Olathe> Wow
10:30:17 <ski> > foldb2 (+) z [0..]
10:30:21 <lambdabot>   mueval-core: Time limit exceeded
10:31:57 <djahandarie> Are there any other weird redefinitions in Lambdabot besides . and ++ ?
10:32:08 <ezyang> :t (++) 
10:32:10 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:32:16 <ski> djahandarie : `flip' .. not sure there's anything else
10:32:22 <ezyang> :t flip 
10:32:22 <djahandarie> :t flip
10:32:23 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:32:23 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:32:31 <ezyang> wut 
10:32:34 <djahandarie> :t return
10:32:35 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:32:39 <ezyang> Oh, I guess that makes sense 
10:32:46 * ski was going to say `map' .. but realized Cale hadn't changed that
10:32:53 <djahandarie> lol
10:33:27 <djahandarie> Isn't the Functor instance for lists fmap = map ?
10:33:29 <ski> ezyang : i suggested `flip' to Cale (will the official burning begin anytime soon ?)
10:33:35 <ski> djahandarie : yes
10:33:47 <djahandarie> So wouldn't making map = fmap mess that up?
10:33:55 <ezyang> @slap ski 
10:33:56 * lambdabot pushes ski  from his chair
10:33:57 <djahandarie> Unless you mean change it some other way
10:34:18 <ski> djahandarie : not if you just hide the standard `map' and reexport a new one
10:34:24 <ski> (being `fmap')
10:34:51 <ski> otherwise you'd either need to define `mapList', or define it directly in the instance for `Functor'
10:34:58 <ski> (like with `fmap' for `Maybe')
10:35:14 <djahandarie> Right
10:35:31 <Peaker> I think since lambdabot is a lot for teaching purposes, making it inconsistent with standard Haskell is not a good idea
10:35:37 <djahandarie> Peaker, I agree
10:36:15 <ski> so .. hm, an example showing why a strictly forcing variant of `foldb' / `foldbB' / `foldb2' might be useful ?
10:37:01 <ski> (or did we already do that above ?)
10:37:21 <FunctorSalad_> map = fmap = foldr ((:) . f) [] 
10:37:23 <FunctorSalad_> ;)
10:37:34 <FunctorSalad_> *map f = fmap f = ....
10:37:53 <djahandarie> What functor would that flip be used on? Besides ((->) r)
10:38:25 <Peaker> djahandarie, it could be used to apply each of a list of functions with the same arg
10:38:45 <Olathe> I think foldb is, essentially, strict.
10:39:16 <Olathe> foldbB is lazy and very slow.
10:39:17 <djahandarie> :t flip (+1)
10:39:19 <lambdabot> forall a b. (Num b) => a -> (a -> b) -> b
10:39:48 <Twey> map = fmap = flip foldr [] . fmap (:)
10:39:48 <djahandarie> :t flip ([+1])
10:39:48 <lambdabot>     A section must be enclosed in parentheses thus: (+ 1)
10:39:57 <djahandarie> :t flip [(+1)]
10:39:58 <lambdabot> forall a. (Num a) => a -> [a]
10:40:02 <ski> djahandarie : it would be a generalization of `flip :: (e -> a -> b) -> (a -> (e -> b)', based on generalizing the `(e ->)' functor to any functor `f'
10:40:13 <djahandarie> ski, I know, just trying to see other uses for it
10:40:40 <djahandarie> > flip [(+1), (+2)] 5
10:40:41 <lambdabot>   [6,7]
10:40:46 <Twey> 18:38:57 < lambdabot> forall a b. (Num b) => a -> (a -> b) -> b
10:40:48 <Twey> What?
10:41:02 <Olathe> > foldl (+) (z::Expr) [1..]
10:41:03 <Twey> How does that work?  Surely it must be Num (a -> b)?
10:41:09 <lambdabot>   mueval: ExitFailure 1
10:41:14 <Olathe> > foldr (+) (z::Expr) [1..]
10:41:16 <ski> > [cos,sin,tan] `flip` (pi/3)
10:41:18 <lambdabot>   mueval-core: Time limit exceeded
10:41:20 <lambdabot>   mueval-core: Time limit exceeded
10:41:52 <ski> > foldr (+) z [0 ..]
10:41:53 <lambdabot>   0 + (1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (1...
10:42:02 <ski> Olathe : the right fold works
10:42:19 <djahandarie> > flip (+1) 2 (-1)
10:42:22 <lambdabot>   0
10:42:27 <djahandarie> > flip (+1) 2 (-5)
10:42:28 <lambdabot>   -4
10:42:30 <Olathe> > foldl (+) z [1..]
10:42:38 <ski> Twey : i believe there's an `instance Num a => Num (e -> a)' in scope in lambdabot
10:42:41 <lambdabot>   mueval: ExitFailure 1
10:42:44 <Olathe> > foldbB (+) z [1..]
10:42:46 <djahandarie> Yeah
10:42:49 <lambdabot>   mueval-core: Time limit exceeded
10:43:01 <ski> > 2 3 :: Integer
10:43:02 <lambdabot>   2
10:43:37 <ski> > foldbB (+) z [0 ..]  -- Olathe, and this too
10:43:38 <lambdabot>   0 + (1 + 2 + (3 + 4 + (5 + 6) + (7 + 8 + (9 + 10) + (11 + 12 + (13 + 14)) +...
10:43:51 <Olathe> > foldbB (+) z [1..]
10:43:52 <lambdabot>   1 + (2 + 3 + (4 + 5 + (6 + 7) + (8 + 9 + (10 + 11) + (12 + 13 + (14 + 15)) ...
10:44:06 <Twey> > (+ 1) + (+ 2)
10:44:07 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:44:07 <lambdabot>    arising from a use of `...
10:44:11 <Olathe> > foldb (+) z [1..25]
10:44:12 <lambdabot>   1 + 2 + (3 + 4) + (5 + 6 + (7 + 8)) + (9 + 10 + (11 + 12) + (13 + 14 + (15 ...
10:44:12 <Twey> > (+ 1) + (+ 2) $ 5
10:44:13 <lambdabot>   13
10:44:19 <ski> (it's just that poor lambdabot gets overwhealmed by all the heavy requests)
10:44:23 * Twey scratches his head.
10:44:25 <Twey> What does it do?
10:44:43 <djahandarie> Makes things more confusing
10:44:55 <Twey> Haha
10:45:01 <ski> Twey : basically `(+) = liftM2 (+)' in the environment monad
10:45:19 <Twey> Ah
10:45:27 <Olathe> @let foldbC f s [] = s; foldbC f s xs = go xs where go [] = s; go [x] = f x s; go (x:y:zs) = f (f x y) (go zs)
10:45:30 <lambdabot>  Defined.
10:45:39 <Twey> So that's (5 + 2) + (5 + 1)?
10:45:40 <Olathe> > foldbC (+) z [1..]
10:45:41 <lambdabot>   1 + 2 + (3 + 4 + (5 + 6 + (7 + 8 + (9 + 10 + (11 + 12 + (13 + 14 + (15 + 16...
10:46:33 <ski> > ((\x -> x^2 - 1) / (\x -> x - 1)) `map` [-5 .. 5]  -- polynomial division .. well, sortof :)
10:46:34 <lambdabot>   [-4.0,-3.0,-2.0,-1.0,-0.0,1.0,NaN,3.0,4.0,5.0,6.0]
10:46:54 <ski> Twey : aye
10:47:08 <djahandarie> ...
10:47:11 <djahandarie> *confused*
10:47:59 <djahandarie> Oh
10:48:06 <djahandarie> Interesting
10:48:17 <Olathe> > foldb f z [1..25]
10:48:18 <lambdabot>   f (f (f (f (f 1 2) (f 3 4)) (f (f 5 6) (f 7 8))) (f (f (f 9 10) (f 11 12)) ...
10:48:26 <Olathe> > foldbB f z [1..25]
10:48:27 <lambdabot>   f 1 (f (f 2 3) (f (f (f 4 5) (f 6 7)) (f (f (f (f 8 9) (f 10 11)) (f (f 12 ...
10:48:30 <djahandarie> :t ((\x -> x^2 - 1) / (\x -> x - 1))
10:48:31 <lambdabot> forall a. (Fractional a) => a -> a
10:48:36 <Olathe> > foldbC f z [1..25]
10:48:37 <lambdabot>   f (f 1 2) (f (f 3 4) (f (f 5 6) (f (f 7 8) (f (f 9 10) (f (f 11 12) (f (f 1...
10:49:22 <ski> > (((\x -> x^2 - 1) / (\x -> x - 1)) `graph`) `map` [-2 .. 3]
10:49:23 <lambdabot>   [(-2.0,-1.0),(-1.0,-0.0),(0.0,1.0),(1.0,NaN),(2.0,3.0),(3.0,4.0)]
10:49:44 <Taejo> what is the difference between the various FGL Graph instances (DGI.Tree and DGI.PatriciaTree)?
10:50:11 <ski> > ((\x -> x^2 - 1) / (\x -> x - 1)) x
10:50:11 <lambdabot>   (x * x - 1) * recip (x - 1)
10:50:22 <soupdragon> :t graph
10:50:23 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
10:51:57 <ski> Olathe : ok
10:54:05 <djahandarie> Those overgeneralized types can be kinda scary
10:54:27 <ski> (only as scary as you let them ;)
10:54:32 <ski> > let foldbB' (*) u [] = u; foldbB' (*) u (a:as) = a * foldbB' (*) u (comb as) where comb (a0:a1:as) = a0 * a1 : comb as; comb as = as in foldbB' f z [0 ..]
10:54:33 <lambdabot>   f 0 (f (f 1 2) (f (f (f 3 4) (f 5 6)) (f (f (f (f 7 8) (f 9 10)) (f (f 11 1...
10:55:49 <ski> (also, in this case, i got `graph' (and `cograph') from category, so they aren't really any more generalized than their source .. rather the other way around)
10:55:59 <ski> (s/category/category theory/)
10:56:46 <Spewns> it's like you're speaking in scheme
10:56:49 <Spewns> ;[
10:57:10 <ski> well, Scheme is a nice little language
10:57:15 <Spewns> :P
10:58:53 <Spewns> yes, i like it. i'm a functional programming noob and scheme was very easy to learn
11:04:54 <ski> hm .. on simple tries, i only seem to manage to make a strict version worse ..
11:05:31 * ski notices that "tries" is spelled the same as ibid
11:06:10 <Olathe> How do I get ghci to not show a result ?
11:06:33 <aristid> is it possible to generalise (.) to normal Arrows?
11:07:18 <ezyang> aristid: Yeah. See Data.Category 
11:07:31 <ski> Olathe : `let foo = ...' ?
11:07:31 <aristid> oh, Category is a requirement for Arrow
11:07:49 <ski> (and then possibly do `seq foo ()' if you actually wanted to force it to WHNF)
11:09:13 <Olathe> ski: Ahh, thanks
11:10:14 <aristid> why doesn't this work in ghci? let dot = (Control.Category..)
11:10:43 <Olathe> Try (Control.Category.(.))
11:10:49 <mauke> Olathe: fail
11:10:57 <Olathe> :(
11:11:06 <mauke> aristid: you also fail
11:11:26 <aristid> mauke: ok, and why?
11:11:36 <mauke> for saying something "doesn't work"
11:11:39 <Twey> It should work
11:11:49 <Twey> Unless it's following the new rules for qualified operators
11:12:00 <Twey> In which case it'll be â€˜let dot = Control.Category..â€™
11:12:11 <aristid> duh, i thought you immediately see the problem so i don't have to copy the error message
11:12:28 <Twey> Ah, nice
11:12:35 <Twey> Type error â€” it wants a defined cat
11:12:58 <aristid> mauke: http://codepad.org/KRvKnWbf
11:13:22 <Twey> I guess let bindings can't be polymorphic?  o.@
11:13:39 <Twey> Oh
11:13:45 <Twey> They can, you just have to provide the type explicitly
11:13:54 <c_wraith> yes, the MR applies to them, too
11:13:55 <aristid> Twey: i tried that, but failed at it
11:14:00 <mauke> disable the MR
11:14:03 <Twey> Ah
11:14:04 <Twey> Yeah
11:14:14 <Twey> :set -XNoMonomorphismRestriction
11:14:29 <Silvah> Hello everyone.
11:14:34 <aristid> thanks
11:14:44 <Twey> Hi
11:14:47 <aristid> stupid monomorphism restriction
11:15:14 <Silvah> You do not need to say twice that it is stupid.
11:15:27 <backinaction> directionList [p:ps] = [direction p (head (take 2 ps)) (last (take 2 ps))] ++ directionList ps
11:16:00 <backinaction> I don't really get the ghci error message when I try to load my source file that contains that code
11:16:13 <aristid> Silvah: i only said it ocne?
11:16:13 <backinaction>     Couldn't match expected type `(a, a)'
11:16:13 <backinaction>            against inferred type `[(a, a)]'
11:16:21 <Cale_> [p:ps] is a list with one element which is a list whose first element is p and where the rest is ps
11:16:31 <Cale_> Are you sure that's what you mean?
11:16:40 <Silvah> aristid: stupid (...) restriction. You said it twice.
11:17:01 <aristid> Silvah: ???
11:17:05 <ski> Silvah : i don't see that
11:17:21 <backinaction> Cale_: hmm...I wonder if I should use [p:q:r:rest] then...
11:17:23 <Silvah> Restrictions are stupid by definition.
11:17:28 <aristid> Silvah: no.
11:17:34 <aristid> some restrictions are reasonable.
11:17:40 <portnov> @hoogle (...)
11:17:40 <lambdabot> No results found
11:17:44 <Twey> Like types.  â˜º
11:17:48 <Cale_> backinaction: You probably just want (p:ps), or indeed (p:q:r:ps)
11:18:16 <backinaction> Cale_: opps...I meant (p:ps)
11:18:31 <Twey> What's up with â€˜head (take 2 ps)â€™?
11:18:36 <Cale_> backinaction: but not with the square brackets, since you want this to apply to an arbitrary nonempty list, not a list whose only element is another list.
11:18:39 <Twey> That's rather redundant.
11:19:04 <Cale_> Yeah, try to avoid using head and tail altogether.
11:19:05 <pastorn> !! 3 ?
11:19:14 <pastorn> oh wait
11:19:16 <Cale_> Whenever you use head and tail, you could always be using pattern matching.
11:19:17 <pastorn> !! 2
11:19:18 <Silvah> They are not? Suddenly some thing are not stupid anymore? I thought that everything is stupid.
11:19:24 <Twey> directionList (p1 : p2 : p3 : ps) = direction p1 p2 p3 ++ directionList ps
11:19:25 <ski> backinaction : `p : ps' is the list that starts with `p' and continues with the elements of the list `ps'. but you probably don't mean `directionList p : ps = ...' either, since that parses as `(directionList p) : ps = ...' -- hence the brackets in `directionList (p : ps) = ...'
11:19:41 <Twey> Er
11:19:43 <Twey> directionList (p1 : p2 : p3 : ps) = direction p1 p2 p3 : directionList ps
11:20:09 <aristid> Cale_: but pattern matching is not point-free.
11:20:25 <Twey> I'd be tempted to write this in terms of chunk and map.
11:20:44 <Cale_> aristid: That's true, but head and tail should only be used when you're absolutely certain that they won't fail.
11:20:55 <aristid> true.
11:20:58 <Silvah> Who cares? In our world, pointless style is, ahem, pointless.
11:21:12 <aristid> Silvah: stupid, too?
11:21:35 <Silvah> As everything, yes.
11:24:01 <Silvah> Eh, aren't you used to such my behavior? I always say that something is stupid, pointless and whatnot.
11:27:26 <Twey> Silvah: How could I be used to it?  I don't think I've ever seen you before.
11:28:46 <Silvah> Oh.
11:28:55 <_minoru> hello everybody
11:29:14 <backinaction> Cale_: I need the position independence of head and tail
11:30:26 <Silvah> I was annoying you all here for last three weeks... You forgot me?
11:30:42 <aristid> conal: i have a question about the secs... wouldn't it be possible to generalise the whole thing to arrows (not deeparrow) with result=(^>>) instead of result=(.)
11:30:43 <aristid> ?
11:30:50 <backinaction> I don't want to take points in elements 1, 2, and 3 out of ps at all
11:31:01 <backinaction> I just want p to change through each iteration
11:31:22 <conal> aristid: what's (^>>) ?
11:31:22 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
11:31:35 <ski> @type (^>>)
11:31:36 <lambdabot> forall b c (a :: * -> * -> *) d. (Arrow a) => (b -> c) -> a c d -> a b d
11:31:45 <aristid> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/Control-Arrow.html#^%3E%3E
11:31:58 <ski>   ab ^>> b_c = arr ab >>> b_c
11:32:04 <backinaction> so, the first iteration of directionList should see: [a,b,c,d,e], the second [b,c,d,e], the third [c,d,e], the fourth stops there
11:32:14 <Silvah> Arrows! Abandon all hope!
11:32:14 <aristid> i mean <<^, not >>^, sorry
11:32:25 <aristid> Silvah: for they are stupid, too.
11:33:00 <Silvah> Uhm, could you change the topic?
11:33:01 <aristid> :t (<<^).second :: forall a b c d. (b -> c) -> (a -> (d, b)) -> a -> (d, c)
11:33:02 <lambdabot> forall b c a d. (b -> c) -> (a -> (d, b)) -> a -> (d, c)
11:33:07 <aristid> :t (.).second
11:33:07 <lambdabot> forall (f :: * -> *) b c d. (Functor f) => (b -> c) -> f (d, b) -> f (d, c)
11:33:20 <aristid> :t (Prelude..) Prelude.. second
11:33:21 <lambdabot> forall a b c d. (b -> c) -> (a -> (d, b)) -> a -> (d, c)
11:33:21 <conal> aristid: compare the type of (<<^) with the types of first, second, and result
11:34:14 <conal> aristid: it loses generality.  
11:34:39 <Silvah> Arrows are too stupid to be stupid, actually ;)
11:34:43 <aristid> conal: hmm ok so i've been thinking in the wrong direction
11:35:51 <conal> aristid: read "tangible functional programming" yet?  it illustrates use of DeepArrow/SECs beyond the function arrow.
11:35:59 <conal> @where Eros
11:35:59 <lambdabot> http://conal.net/papers/Eros
11:36:05 <aristid> conal: well i watched the video and have read 50% of the paper
11:36:07 <Cale_> backinaction: I'm not quite sure I understand. You just have to ensure that the recursive call to directionList is applied to the right list, don't you?
11:37:47 <aristid> conal: btw. page numbers are a wonderful invention :P
11:38:11 <conal> aristid: it's a conf paper.  the publisher adds page numbers.
11:38:14 <gwern> page numbers are a relic of the past. in the brave new future, we will refer to individual letters, using GUIDs
11:38:31 <conal> aristid: are you struggling to refer to something in the paper?
11:38:40 <conal> aristid: if so, you can use sections.
11:39:05 <aristid> conal: no, it's just harder to read when you don't know which side of the stack i'm on
11:39:12 <aristid> because i use duplex printing
11:39:32 <conal> aristid: stapled?
11:39:38 <aristid> conal: loose
11:39:45 <aristid> i'm lazy :P
11:39:46 <conal> ah.
11:40:02 <conal> aristid: the stapler is another wonderful invention. :p
11:40:14 <conal> ;)
11:40:26 <EvanR-work> intercalate pages
11:40:32 <aristid> i also don't find my stapler :/
11:40:42 <c_wraith> is it a red swingline?
11:42:09 <backinaction> Cale_: yeah
11:42:11 <conal> aristid: maybe there's a fairly easy way for me to add page #s w/o changing pagination.
11:42:40 <aristid> that would be useful
11:42:55 <backinaction> Cale_: I have decided to use this: directionList (p1:p2:p3:ps) = [direction p1 p2 p3] ++ directionList p2:p3:ps
11:43:13 <backinaction> should do the same thing as the head/tail crap
11:44:06 <conal> anyone know an easy way to add page numbers to an acm sigplan-style formatted latex doc, without changing pagination?
11:46:03 <backinaction>     Couldn't match expected type `(a, a)'
11:46:04 <backinaction>            against inferred type `[(a, a)]'
11:46:15 <backinaction>     In the second argument of `(++)', namely
11:46:15 <backinaction>         `directionList p2 : p3 : ps'
11:46:27 <backinaction> err... can you say "WTF?"?
11:47:08 <backinaction> nvm
11:47:19 <gwern> the type checker may err, but humans always do
11:47:24 <ski> conal,aristid : Stefan Bergman, a complex analyst, once told a student : "a mathemathician's most important tool is his stapler". (this was in the days before word processors and TEX)
11:47:25 <backinaction> just add parentheses around p2:p3:ps
11:47:46 <conal> ski: nice :)
11:48:07 <ski> backinaction : function application binds tighter than (almost) everything else
11:48:31 <backinaction> *Main> directionList [(2, 0), (1,4), (4, 1), (-4, 0), (4, 1)]
11:48:31 <backinaction> [RightTurn,RightTurn,Straight]
11:48:41 <backinaction> Mwahahahaha!
11:50:03 <djahandarie> ski, can I bind my papers with function application?
11:51:39 <ski> "Bergman was a prolofic writer. [..] His method of writing was this: First, he would write a manuscript in longhand and give it to the secretary. When she had typed it up he would begin revising, stapling strips of paper over the portions that he wished to change."
11:51:44 <ski> "Strips would be stapled over strips, and then again and again, until parts of the manuscript were so thick that the stapler could no longer penetrate. Then the manuscript would be returned to the secretary for a retype and the whole cycle would begin again. Sometimes it would repeat ad infinitum. [..]"
11:52:19 <ezyang> I'm writing FFI bindings to a C library that needs lots of strange flags to the compiler. What's a good example cabal file to cargo cult off of? 
11:52:25 <gwern> poor guy. if he had just been born a few decades later, he would've loved word processors
11:52:29 <gwern> ezyang: curl?
11:52:37 <ski> conal : that's the context for the above citation, from the book "Mathematical Apochrypha" by Steven G. Krantz
11:52:38 <ezyang> Ok, will try 
11:53:44 <ezyang> gwern: Huh, build-type is Configure? Curious. 
11:53:45 <conal> ski: oh, wow.  now i get the stapler remark.  thx for the charming story!
11:54:04 <gwern> ezyang: you asked for a curious one...
11:54:10 <ezyang> oof, that's a bit too curious :-) 
11:56:16 <Olathe> @hoogle union
11:56:16 <lambdabot> Data.IntMap union :: IntMap a -> IntMap a -> IntMap a
11:56:16 <lambdabot> Data.IntSet union :: IntSet -> IntSet -> IntSet
11:56:16 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
11:57:22 <djahandarie> @hoogle difference
11:57:22 <lambdabot> Data.IntMap difference :: IntMap a -> IntMap b -> IntMap a
11:57:22 <lambdabot> Data.IntSet difference :: IntSet -> IntSet -> IntSet
11:57:22 <lambdabot> Data.Map difference :: Ord k => Map k a -> Map k b -> Map k a
11:57:55 <djahandarie> Given two arrays what is the fastest way to get their difference?
11:58:32 <ville> djahandarie: assume they are equal and return nothing.
11:58:45 <gwern> @quote array
11:58:45 <lambdabot> gwern says: Haskell has the best arrays around; problem is, we don't know which module it is.
11:59:28 <mauke> :t (\\)
11:59:28 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
11:59:57 <djahandarie> Yeah, that's for lists
12:00:05 <ski> @index (\\)
12:00:05 <lambdabot> bzzt
12:00:28 <gwern> djahandarie: yes, but do you understand the point of my quote?
12:00:50 <djahandarie> ...I don't think so
12:01:16 <gwern> djahandarie: there are so many array variants in haskell that a general answer must be slow, pathological, or nonexistent
12:01:32 <gwern> (ville = pathological, mauke = slow, gwern = nonexistent)
12:03:00 * djahandarie is confused
12:03:24 <aristid> @src (\\)
12:03:24 <lambdabot> (\\) = foldl (flip delete)
12:03:34 <aristid> :t delete
12:03:35 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
12:03:39 <aristid> @src delete
12:03:40 <lambdabot> delete = deleteBy (==)
12:04:02 <aristid> @src deleteBy
12:04:02 <lambdabot> deleteBy eq x []        = []
12:04:02 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
12:04:38 <aristid> aaah
12:04:50 <aristid> > [1,2,3,4,5] \\ [3,4]
12:04:51 <lambdabot>   [1,2,5]
12:05:04 <ski> > [2,2,1] \\ [1,2]
12:05:05 <lambdabot>   [2]
12:05:56 <aristid> oO that's not what i expected
12:06:07 <djahandarie> > (Data.Vector.fromList [1,2,3,4,5]) \\ (Data.Vector.fromList [2,3])
12:06:08 <lambdabot>   Not in scope: `Data.Vector.fromList'Not in scope: `Data.Vector.fromList'
12:06:09 <aristid> > delete 2 [2,2]
12:06:10 <lambdabot>   [2]
12:06:18 <djahandarie> I'd like something like that ^^
12:06:27 <aristid> oh, it only deletes the first occurrence
12:07:06 <ski> djahandarie : maybe parallel arrays ?
12:07:20 <EvanR-work> > filter (!= 2) [2,2]
12:07:20 <lambdabot>   Not in scope: `!='
12:07:24 <EvanR-work> > filter (/= 2) [2,2]
12:07:25 <lambdabot>   []
12:07:36 <aristid> @let (!=) = (/=)
12:07:36 <lambdabot>  Defined.
12:07:43 <aristid> > 2 != 2
12:07:44 <lambdabot>   False
12:08:03 <EvanR-work> and now we see why i keep thinking != is right ;)
12:08:21 <aristid> EvanR-work: why?
12:08:32 <robin_rytich> damn, haskell.org down again?
12:08:33 <djahandarie> ski, do you mean PArr or...?
12:08:36 <djahandarie> robin_rytich, yeah
12:08:52 <EvanR-work> because people wrecklessly defining parachute operators ;)
12:09:08 <EvanR-work> define >> shiftR
12:09:22 <ski> djahandarie : aye
12:09:51 <djahandarie> I recall someone saying that was unmaintained or something... maybe rl?
12:09:52 <balor> Anyone know where the darcs repo for http://hackage.haskell.org/package/protocol-buffers-1.6.0 hides?
12:10:08 * ski doesn't know ..
12:10:17 <gwern> balor: http://code.haskell.org/protocol-buffers
12:10:42 <balor> gwern: thanks...the cabal file has a typo in it :)
12:10:58 <robin_rytich> did anyone had troubles building vacuum-cairo? Cabal says: Ambiguous occurrence `G.eventKeyName'
12:11:10 <robin_rytich> *have
12:12:42 <ski> @quote Cabal
12:12:42 <lambdabot> dcoutts says: Of course Cabal-1.2 works perfectly well with all versions of GHC
12:12:53 <BMeph> Does anyone else find it ironic that vector has a 'slice' function, but no 'splitAt'? 
12:13:18 <djahandarie> I really like Data.List.Split
12:13:25 <djahandarie> The same sort of interface should be used everywhere
12:13:48 <Twey> What sort of interface?
12:14:00 <djahandarie> The Splitter type
12:14:08 <djahandarie> Which lets you use combinators
12:14:53 <JoeyA> Why aren't these the same? :
12:14:56 <JoeyA> > replicateM 3 [1..2]
12:14:57 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
12:15:02 <JoeyA> > do {[1..3]; [1..3];}
12:15:03 <lambdabot>   [1,2,3,1,2,3,1,2,3]
12:15:07 <JoeyA> err
12:15:15 <JoeyA> > do {[1..2]; [1..2]; [1..2];}
12:15:15 <lambdabot>   [1,2,1,2,1,2,1,2]
12:15:32 <djahandarie> Couldn't something like that be defined for all Traversable? Not entirely sure
12:16:08 <sclv> not all traversable things have a useful notion of split
12:16:22 <djahandarie> Yeah
12:16:37 <ski> > do a <- [1..2]; b <- [1..2]; c <- [1..2]; return [a,b,c]  -- `replicateM 3 [1..2]'
12:16:38 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
12:16:39 <djahandarie> Would need "Splittable" or something
12:17:03 <JoeyA> ah, I think I get it
12:17:15 <JoeyA> > replicateM 3 (putStrLn "hello")
12:17:15 <lambdabot>   <IO [()]>
12:24:41 <Twey> Polarina: How do you pronounce the â€˜Ã°â€™ in â€˜gÃ³Ã°an dagâ€™?
12:25:47 <Twey> djahandarie: Oh, I see
12:25:53 <Twey> I never knew that was there
12:26:32 <Heffalump> aargh, is haskell.org down again?
12:26:42 <Cale_> > map last (replicateM 3 [1..2])
12:26:43 <lambdabot>   [1,2,1,2,1,2,1,2]
12:26:43 <djahandarie> Yar matey
12:26:59 <Cale_> > do { [1,2], [1,2], [1,2] }
12:27:00 <lambdabot>   <no location info>: parse error on input `,'
12:27:05 <Cale_> > do { [1,2]; [1,2]; [1,2] }
12:27:06 <lambdabot>   [1,2,1,2,1,2,1,2]
12:31:31 <sclv> hah. between haskell.org and proggit I'm in a v. unreliable ecosystem of most used sites.
12:31:51 <djahandarie> I really don't know what is up with all the Haskell services recently
12:32:28 <djahandarie> Someone must be conspiring against Haskell
12:33:12 <Twey> I blame jdh.  He's obviously DDoSing us.  ;)
12:33:19 <fryguybob> C++ called, they want their reliability back.
12:33:24 <Twey> Heheh
12:33:51 <Zao> Twey: Isn't 'Ã°' towards "th"?
12:34:12 <Saizan> djahandarie: the obvious problem is that the hardware and software of these servers is not entirely haskell
12:34:46 <Twey> Zao: It's usually [Ã°] or [Î¸] in devoiced contexts, AFAIKâ€¦ but in something I just heard, someone pronounced it more like [É¾] or [d], so I'm a little confused.
12:34:50 <djahandarie> Hardware can be written in Haskell?
12:35:02 <Twey> djahandarie: What did you think Lava was for?
12:35:18 <Twey> You describe hardware, then you â€˜unsafePerformIO $ nanoConstruct hardwareâ€™
12:35:31 <Twey> And whoosh
12:35:35 <djahandarie> Haha
12:35:40 <Zao> Twey: atomically construct ? :D
12:36:09 <Twey> Hahaha
12:36:29 <Twey> unsafePerformIO . atomically $ construct hardware
12:38:11 <Saizan> especially useful if you need some extra ram
12:38:39 <Taejo> @pl (\x -> (x, ())
12:38:39 <lambdabot> (line 1, column 15):
12:38:39 <lambdabot> unexpected end of input
12:38:39 <lambdabot> expecting variable, "(", operator or ")"
12:39:06 <Twey> Taejo: flip (,) ()
12:39:10 <Taejo> thanks
12:39:13 <Twey> Or (, ()) with tuple sections
12:39:27 <Taejo> is there a tuple sections extension?
12:39:34 <Twey> Yes
12:39:51 <Twey> -XTupleSections
12:40:03 <aavogt> > (,y) x
12:40:04 <lambdabot>   <no location info>: parse error on input `y'
12:40:19 <aavogt> > (y,) x
12:40:19 <lambdabot>   <no location info>: parse error on input `)'
12:40:26 <Twey> > (3, ) 2
12:40:27 <lambdabot>   <no location info>: parse error on input `)'
12:40:32 <Twey> Apparently \b doesn't have it enabled
12:40:44 <aavogt> the issue is that \bot is built with ghc-6.10
12:43:08 <mauke> does anyone here know a bit about terminfo?
12:43:23 <mauke> or: how crazy does this API look: http://mauke.ath.cx/tmp/unibi/System-Console-Unibilium.html
12:44:35 <tomberek> is there someway to have (Foldable f,Foldable g) => Foldable (CompF f g)      -- newtype CompF f g a = CompF (f (g a))
12:45:54 <aristid> @hoogle CompF
12:45:54 <lambdabot> No results found
12:46:02 <aristid> tomberek: what is CompF?
12:46:39 <tomberek> aristid:  i listed it above... newtype CompF f g a  = CompF {runCompF::f (g a)}
12:47:09 <tomberek> aristid: it's a composition, in this case, of Functors, probably Foldable
12:47:13 <aristid> tomberek: oh, so it is defined by yourself
12:47:24 <tomberek> it's in category-extras
12:47:48 <mauke> :t foldMap
12:47:48 <lambdabot> Not in scope: `foldMap'
12:47:51 <tomberek> I have it working like this:instance (Alternative g,Foldable f,Foldable g) => Foldable (CompF f g) where
12:47:55 <soupdragon> how could I get the coefficients of 1/(e^x-1)?
12:48:04 <tomberek> but I'm not sure that the Alternative part is required
12:48:09 <soupdragon> I guess that's a 2 liner :/
12:48:11 <tomberek> i want to remove that constraint
12:48:15 <soupdragon> can't think how to do it in one
12:48:55 <tomberek> soupdragon : and more readable
12:49:00 <soupdragon> ??
12:49:12 <tomberek> to have 2
12:49:30 <soupdragon> who care about readability!
12:49:38 <tomberek> aristid: make sense?
12:49:42 <mauke> foldMap f (CompF fga) = foldMap (foldMap f) fga ?
12:49:48 <mauke> does that even typecheck
12:50:04 <aristid> tomberek: i don't understand it.
12:50:14 <aristid> tomberek: but really that doesn't mean anything :)
12:50:45 <tomberek> aristid : hehe, basically, I want to express that the composition of two Foldables is also Foldable
12:51:43 <Saizan> mauke: yep
12:51:50 <thoughtpolice> dons: ping
12:51:59 <tomberek_> oops
12:53:26 <Saizan> tomberek_: seen "foldMap f (CompF fga) = foldMap (foldMap f) fga"?
12:53:37 <tomberek_> hm...
12:53:59 <tomberek_> Saizan: i'll try it out, thanks
12:55:19 <mauke> foldMap = (. runCompF) . foldMap . foldMap
12:55:54 <tomberek_> mauke, oooh, nice
12:57:29 * Saizan prefers "foldMap f = (foldMap . foldMap) f . runCompF" 
12:57:39 <soupdragon> that's crazy lol does it work??
12:57:46 <soupdragon> how can you do recursion like that
12:57:47 <tomberek_> thanks... but where did that Monoid constraint go?,, oh! implied by Foldable?
12:58:28 <Saizan> it's given to you
12:58:39 <mauke> soupdragon: what recursion?
12:58:47 <soupdragon> oh
12:58:52 <aavogt> soupdragon: the types of all foldMaps are different
12:58:53 <Saizan> soupdragon: the foldMap's in the RHS are for other types
12:58:54 <soupdragon> mauke you mean it's typeclasses that stop?
12:58:56 <soupdragon> okay
12:59:29 <noteventime> ?
12:59:43 <soupdragon> actually feel like I understand quantum mechanics after reading this http://simple.wikipedia.org/wiki/Quantum_mechanics
13:00:27 <Polarina> Twey, we pronounce 'Ã°' the same way we pronounce 'Ã¾'.
13:00:31 <monochrom> You are right, "understand" is no more than a feeling.
13:00:38 <Peaker> Feynman said(or was it someone else?) if someone feels they understand Quantum Mechanics, they're just understanding some small application of it to some niche
13:00:57 <soupdragon> Dirac looks so cool
13:01:13 <aavogt> have you seen his delta?
13:01:17 <soupdragon> he :)
13:10:02 <tomberek_> Saizan: thanks
13:18:10 <ezyang> Anyone know a mirror for the cabal docs? haskell.org is down... 
13:18:48 <gwern> "I am only a child playing on the beach, while vast oceans of truth lie undiscovered before me."
13:18:59 <Nereid> ezyang: http://www.mirrorservice.org/sites/www.haskell.org/ appears to exist
13:19:07 <Nereid> although it's old old old
13:19:15 <Nereid> http://www.mirrorservice.org/sites/www.haskell.org/ghc/docs/latest/html/libraries/ ?
13:19:21 <kmc> Polarina, really? i thought one was voiced and the other unvoiced
13:19:22 <ezyang> that looks... ancient 
13:19:46 <Nereid> ezyang: other pages are newer
13:20:02 <c0sine> hey what is the significance of Book here
13:20:16 <c0sine> data BookInfo = Book Int String [String]
13:20:22 <Nereid> Book is the name of the constructor
13:20:23 <tensorpudding> Book is the type constructor
13:20:29 <c0sine> okay
13:20:31 <tensorpudding> data constructor, rather
13:20:38 <tensorpudding> so you'll have a function called Book
13:20:43 <c0sine> OH
13:20:50 <Nereid> Bool :: Int -> String -> [String] -> BookInfo
13:20:50 <c0sine> i thought it would be called BookInfo
13:20:52 <Nereid> Book :: Int -> String -> [String] -> BookInfo
13:20:55 <tensorpudding> with type Book :: Int -> String -> [String] -> BookInfo
13:20:56 <c0sine> I see
13:21:03 <c0sine> thanks
13:21:15 <tensorpudding> type constructors are functions in that sense
13:21:18 <Nereid> and it could have been called BookInfo
13:21:32 <tensorpudding> You can call it that, because the namespace of types and constructors are separate.
13:21:36 <Nereid> it's not uncommon to give the type and the constructor the same name.
13:21:43 <c0sine> oh okay
13:21:50 <c0sine> that would make sense to me
13:21:52 <tensorpudding> You can also have several different constructors for a given type, if you have an enumeration
13:22:00 <c0sine> but i can see why that would be a bad habit too
13:22:01 <tensorpudding> like data Bool = True | False
13:22:13 <Nereid> False | True, rather
13:22:13 <byorgey> c0sine: it's not a bad habit, it's rather common actually
13:22:18 <c0sine> okay
13:22:21 <tensorpudding> or data Maybe a = Just a | Nothing
13:22:25 <Nereid> order
13:22:26 <Nereid> :-)
13:22:27 <byorgey> but can sometimes be confusing to people just learning
13:22:42 <aristid> Bool is unnecessary, we have Maybe ()
13:22:55 <aavogt> maybe it's bad to write data like:    data Confuzle a = Maybe a | Either a a
13:22:59 <Nereid> aristid: there are various reasons why we would want to give isomorphic types different names
13:23:13 <byorgey> aristid: Maybe is unnecessary, we have  Either ()
13:23:19 <aristid> byorgey: indeed.
13:23:31 <tensorpudding> Int is unecessary, we have [Bool]
13:23:36 <mauke> Bool ~ Either () ()
13:23:37 <byorgey> from now on let's just write all our types in terms of (), Either, and (,)
13:23:43 <aristid> (a,b) is unnecessay, we have (a,b,())
13:23:44 <mauke> and Fix
13:23:47 <Nereid> mauke: except when dealing with bottom
13:23:52 <byorgey> yes, and Fix of course
13:24:00 <kmc> how about HFix
13:24:05 <dafis> But Maybe () has four values, Bool only three, so they're not equivalent.
13:24:08 <kmc> imo, if you have one constructor it's almost obligatory to use the name of the type, and if you have more than one it's probably wrong to use the name of the type
13:24:22 <byorgey> kmc: well, instead let's just make Haskell kind-polymorphic
13:24:27 <kmc> sure byorgey
13:24:31 <tensorpudding> we'll just Church encode all our naturals.
13:24:32 <kmc> -XKindPolymorphism
13:24:57 * byorgey is now in Cambridge!
13:25:09 * ezyang is in the wrong place, clearly! 
13:25:15 <kmc> which one byorgey
13:25:28 <byorgey> kmc: the UK one
13:27:06 <gwern> haskell is unnecessary, we have x86 assembler
13:27:31 <kmc> there should be a transatlantic maglev vactrain between the two cambridges
13:27:39 <tensorpudding> computers are unnecessary, we have pencil and paper and vivid imaginations
13:27:49 <osfameron> imaginations are unnecessary, we have television
13:27:52 <Nereid> lol
13:27:57 <kmc> beat me to it
13:28:30 <tensorpudding> the physical world is unecessary, we have psychoactive drugs
13:29:01 <Saizan> psychoactive drugs are unnecessary we've madness.. ?
13:29:36 <kmc> psychoactive drugs are unnecessary, we have Haskell
13:29:44 <tensorpudding> everything is unecessary, we have nothingness
13:29:45 <kmc> now it's full circle?
13:29:46 <dv-> if god wanted us to compute, we'd be silicon based!
13:30:22 <dv-> o well.
13:32:45 <dv-> I tried.
13:34:00 <gwern> the physical world is unnecessary since our minds are instantiated on thermal fluctuations interpreted the right way
13:34:53 <noteventime> What's up with haskell.org?
13:35:08 <dancor> nothing's up about it..
13:35:18 <gwern> I think that's the joke
13:35:20 <gwern> woosh
13:35:26 <benmachine> byorgey: oh hi
13:35:45 <dancor> i don't think it was a joke
13:35:45 <noteventime> Then I guess the swedish government decided to censor it or something
13:35:57 <noteventime> I haven't been able to access it in two days, from different connections
13:36:10 <texodus> it was up this morning
13:36:14 <texodus> not so now
13:36:46 <kmc> zing
13:36:47 <noteventime> texodus: I must have been unlucky then :)
13:37:02 <mreh> > let x+ = 1 in x+
13:37:02 <lambdabot>   <no location info>: parse error on input `='
13:37:05 <dancor> gwern: so when do you think we'll get a human mind onto compy
13:37:06 <kmc> Haskell is a threat to sweden's indigenous language, Agda
13:37:27 <gwern> dancor: the whole brain emulation roap map puts it at around 2060 or so, I think
13:37:45 <gwern> kmc: oh, is that why Sweden is so sensible and rational?
13:37:50 <gwern> the sapir-whorf hypothesis strikes again
13:37:53 <kmc> haha
13:38:09 <kmc> much has been made of the French OCaml connection
13:38:19 <tomberek_> kmc, Saizan, anyone : would you mind taking a look at this? It works, i have a few TODOs left, but i'm wondering if you think it would be useful http://pastebin.com/CfUu21YX
13:38:36 <mreh> mr computer, meet my good friend mr infinite regress
13:38:43 <byorgey> hi benmachine 
13:38:53 <gwern> the French Ocaml connection? smuggling coq proofs through Marseilles, bribing customs to look the other way...
13:39:07 <tomberek_> byorgey: hey, check out above, i got it working
13:39:08 <kmc> hey you have to train long and hard to become a coq smuggler
13:39:56 <gwern> kmc: no way, people just pick it up
13:40:12 <gwern> you like it or you don't
13:40:17 <byorgey> tomberek_: nice =)
13:40:35 <mreh> Alonzo Church died? When did this happen?!
13:40:42 <tomberek_> byorgey, so now the product can be lifted all the way to the top, and then back down
13:40:46 <kmc> mreh, 1995
13:40:54 <mreh> kmc :)
13:41:32 <tomberek_> byorgey, todo: allow the lifting to be done level by level... and to auto-newtype a given structure with Of, CompF, etc.
13:42:37 * hackagebot SyntaxMacros 0.2 - Syntax Macros in the form of an EDSL  http://hackage.haskell.org/package/SyntaxMacros-0.2 (MarcosViera)
13:45:01 <dancor> i can get the current day with (utctDay <$> getCurrentTime) but i can't get tomorrow with ((+ 1) . utctDay <$> getCurrentTime).  what's the right way?
13:45:45 <kmc> Acme.Now
13:45:49 <kmc> ;)
13:45:50 <dancor> heh
13:45:55 <mreh> > let ðœ¶ = "It Works!" in ðœ¶
13:45:55 <lambdabot>   "It Works!"
13:46:03 <c_wraith> @hoogle utctDay
13:46:03 <lambdabot> Data.Time.Clock utctDay :: UTCTime -> Day
13:46:03 <lambdabot> Data.Time.Clock utctDayTime :: UTCTime -> DiffTime
13:46:06 <soupdragon> @let ðœ¶ = "qed"
13:46:07 <lambdabot>  Defined.
13:46:08 <dancor> i was really looking forward to incrementing days
13:46:26 <c_wraith> oh.  You can just increment days, in the native representation of Day
13:46:28 <mreh> what's the deal, alphanumeric characters are okay as names?
13:46:35 <fryguybob> Try again tomorrow?
13:46:50 <c_wraith> It's just not an instance of Num, so you can't use +
13:47:25 <dancor> c_wraith: what can you use
13:48:03 <mreh> haskell with mathematical symbols is teh win
13:48:12 <c_wraith> http://hackage.haskell.org/packages/archive/time/1.2.0.2/doc/html/Data-Time-Calendar.html#v%3AaddDays
13:48:41 <dancor> did you bring haskell.org back up just to spite me
13:49:44 <dancor> ty, for answer and site back
13:49:56 <c_wraith> Yes, I'll totally take credit for that. :)
13:54:14 <tomberek_> byorgey: any ideas? or has this been done before?
13:54:58 <ski> hm, <http://hackage.haskell.org/package/SyntaxMacros-0.2> looks interesting (it appears to be for concrete syntax)
13:56:58 <byorgey> tomberek_: very cool, I've not seen this done before, not like this at least.
13:57:09 <byorgey> tomberek_: unfortunately I don't have too much time to think about it at the moment.
13:57:25 <tomberek_> ah,, ok, if something pops up though, let me know
13:57:46 <djahandarie> Are there any libraries for generating cool 2d patterns (for something like image generation)?
13:58:26 * ski thinks of the (old) Pan and Panchico
13:58:36 <ski> (maybe conal could elaborate on that)
14:02:18 <conal> djahandarie: i've been working on such a thing for the last year.  it's a dsel and compiler that generates GPU code.  it's stalled while i'm waiting for haskell GUI platforms to improve.
14:04:22 <byorgey> djahandarie: you should also look at the Chalkboard project from University of Kansas
14:04:55 <byorgey> http://www.ittc.ku.edu/csdl/fpg/Tools/ChalkBoard
14:05:32 <Polarina> kmc, nope -- they are exactly the same. :)
14:06:25 <kmc> heh
14:06:52 <Polarina> Is haskell.org down?
14:07:03 <Saizan> yes
14:07:21 <Polarina> I am getting "Packet filtered" errors when pinging.
14:12:38 <c_wraith> It's not down for me
14:12:50 <c_wraith> well, hackage.haskell.org is up for me
14:13:07 <ezyang> hackage is on a different server than haskell.org 
14:13:08 <noteventime> Hackage works for me too, but nothing else
14:13:21 <c_wraith> ah, ok
14:13:28 <tommd> http://downforeveryoneorjustme.com/haskell.org
14:13:33 <Igloo> haskell.org is known to be down. People are working on it.
14:14:56 <dv-> haskell.org obviously needs to move to the cloud!
14:15:28 <ezyang> no, it just needs to move out of Yale 
14:16:16 <MPiechotka> Hello. Why GHC does not allow to use custom gcc when on mingw32?
14:25:30 <Veinor> ezyang: I hear MIT offers a service!
14:25:44 <ezyang> I've offered to the folks at Galois. 
14:27:19 <chrisdone> @let chrisdone_x = 2
14:27:20 <chrisdone> @let chrisdone_y k = x * k
14:27:20 <chrisdone> @let chrisdone_x = 3
14:27:20 <chrisdone> > chrisdone_y 10
14:27:20 <lambdabot>   Not in scope: `chrisdone_y'
14:27:20 <lambdabot>  Defined.
14:27:21 <lambdabot>  Defined.
14:27:22 <lambdabot>  <local>:14:0:
14:27:22 <lambdabot>      Multiple declarations of `L.chrisdone_x'
14:27:22 <lambdabot>      Declared at...
14:27:36 <chrisdone> hm interesting
14:27:40 <soupdragon> should have been chrisdone_x
14:27:52 <mauke> > chrisdone_y 10
14:27:53 <lambdabot>   x * 10
14:28:25 <chrisdone> so they can reference eachother, but multiple-toplevel defs are disallowed
14:28:35 <chrisdone> (i.e. re-definition)
14:29:25 <chrisdone> they can reference eachother right?
14:29:40 <chrisdone> @let chrisdone_y k = chrisdone_x * k
14:29:40 <chrisdone>  
14:29:40 <chrisdone>  
14:29:40 <lambdabot>  <local>:13:0:
14:29:40 <lambdabot>      Warning: Pattern match(es) are overlapped
14:29:40 <lambdabot>               I...
14:29:57 <chrisdone> lol that's pretty.. odd
14:30:12 <chrisdone> just literally dumping them in a file. fair dos
14:30:20 <gwern> @undefine
14:30:22 <gwern> oops
14:30:29 <chrisdone> @undefine love
14:31:13 <applicative> > let (chrisdonex, chrisdoney) = (2, chrisdonex + chrisdonex) in chrisdoney
14:31:13 <lambdabot>   4
14:31:30 <gwern> chrisdonkey
14:31:41 <ddarius> chrisdonquixote
14:31:42 <soupdragon> how do you opena chrisdondoor?
14:32:00 <monochrom> open sesame
14:32:54 <chrisdone> `-_`-
14:33:10 <gwern> don chris - you may kiss his lambda
14:33:38 <monochrom> he may ask you for a favour
14:33:49 <chrisdone> done make jokes about my name
14:50:26 <Gracenotes> hm. there's not really a nice way to remove boilerplate Maybe-casing and return an Either, is there
14:50:38 <kmc> ?
14:51:00 <Twey> maybe (Left yourValue) Right
14:51:09 <kmc> :t maybe (Left 'x') Right
14:51:09 <lambdabot> forall b. Maybe b -> Either Char b
14:51:22 <kmc> :t either (const Nothing) Just
14:51:23 <lambdabot> forall a a1. Either a1 a -> Maybe a
14:51:39 <dibblego> @type flip maybe Right . Left
14:51:40 <lambdabot> forall a a1. a1 -> Maybe a -> Either a1 a
14:51:48 <Gracenotes> Twey: that sort of type is a good one
14:52:00 <Gracenotes> and dibblego's is even better :)
14:52:05 <Twey> Yeah
14:52:15 <Twey> Wellâ€¦ if you want to give it a name
14:52:19 <Twey> I probably wouldn't bother :Ã¾
14:52:38 <Gracenotes> yeah, semi-obvious solution after all - make your own combinator. it works well because my Errors come from a group of Enum constructors
14:52:50 <Gracenotes> so one can be relatively terse. wooooo.
14:53:37 <Gracenotes> and I shall call it <?. or something.
14:53:56 <Twey> Hehe
14:54:52 <snelgrov>  /quit
14:55:11 <moonlite> In Parsec, are there any, say, "not"-combinator or something like that? 
14:55:22 <moonlite> I'm thinking like: many1 (not digit)
14:55:41 <Twey> moonlite: What would the type of that look like?
14:55:56 <chrisdone> yeah use lookahead
14:56:17 <moonlite> Twey, good point
14:56:18 <kmc> well, you can accept characters based on any predicate
14:56:32 <kmc> that's different from a general "not" combinator
14:56:42 <moonlite> chrisdone, i'll look at that
14:57:02 <kmc> :t Text.Parsec.Char.satisfy (not . isDigit)
14:57:04 <lambdabot> forall s u (m :: * -> *). (Text.Parsec.Prim.Stream s m Char) => Text.Parsec.Prim.ParsecT s u m Char
14:57:05 <moonlite> yeah i was only thinking in terms of, i don't know, "char-parsers" 
14:57:11 <moonlite> ah
14:57:12 <chrisdone> Twey: basically one like that is just a parser which doesn't consume, but does parse the input and fails on parse success, succeeds on parse fail
14:57:15 <chrisdone> i've done it before 
14:58:10 <chrisdone> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Combinator.html#v%3AlookAhead
14:58:13 <moonlite> thanks everyone!
14:58:43 <chrisdone> or see the source of notFollowedBy for inspiration
15:00:39 <moonlite> chrisdone, yeah i was looking at notFollowedBy.
15:00:50 <chrisdone> lookAhead is the best bet!
15:01:16 <moonlite> So what i want to do is skip a bunch of nondigits for as long as i can and then parse a digit
15:01:58 <chrisdone> not :: String -> Parser a -> Parser (); not label p = (lookAhead p >> fail ("unexpected " ++ label)) <|> return ()
15:02:00 <chrisdone> something like that
15:02:10 <chrisdone> oh
15:02:23 <chrisdone> then you're better off with satsify, i guess
15:06:32 <soupdragon> so you can't implement x^0 on constructive reals
15:07:32 <soupdragon> since it's equivalent to zerop
15:09:55 <dolio> The 0 is also supposed to be a real?
15:10:13 <soupdragon> yes
15:14:57 <roconnor> let zeropow x = 1
15:15:17 <soupdragon> oh what you are right what the hell was I thinking
15:15:29 <soupdragon> yeah I meant 0^x
15:15:42 <roconnor> let powzero x = 0
15:15:46 <soupdragon> but 0^0 = 1
15:15:47 <roconnor> er
15:15:48 <roconnor> right
15:15:58 <roconnor> so it works so long as x is appart from 1
15:16:04 <roconnor> er
15:16:06 <roconnor> from 0
15:16:06 <soupdragon> mm.
15:16:15 <soupdragon> yeah that works Iguess it's just like divison
15:16:20 <roconnor> anyhow
15:16:29 <soupdragon> I thought I'd just broke constructive math
15:16:33 <roconnor> x ** y := exp (y * log (x))
15:16:53 <roconnor> ** is discontinuous at (0,0)
15:17:09 <roconnor> and so it typically undefined constructively
15:18:11 <soupdragon> okay that makes a lot of sense then
15:18:20 <soupdragon> by the way the #epigram channel exists now
15:18:47 <soupdragon> just for anyone interested in pigs
15:25:22 <kmc> anyone here used "satchmo"?
15:25:30 <kmc> or have other suggestions about SAT solving in Haskell?
15:25:55 <kmc> i tried using "incremental-sat-solver" but it failed to solve a formula which i verified by hand is solvable
15:27:44 <tommd> kmc: I see funsat and sat-micro - are those not in a usable condition?  If you can write one, I'd be interested in a blog on your thoughts wrt SAT solvers on hackage.
15:28:13 <tommd> Not right now, obviously, but once you've filtered thought some and have thoughts to share.
15:28:26 <kmc> mm
15:29:02 <kmc> i should make one of these blog things
15:29:59 <ivanm> preflex: seen tomberek_ 
15:29:59 <preflex>  tomberek_ was last seen on #haskell 1 hour, 32 minutes and 34 seconds ago, saying: ah,, ok, if something pops up though, let me know
15:30:17 <tomberek_> ivanm: give me a sec
15:30:34 <ivanm> sure
15:30:39 <gwern> the last time I tried to cabalize a hackage sat-solver, I was rebuffed quite strongly
15:32:16 <Saizan> well, if it was a hackage sat-sover why would it need to be cabalized?
15:33:02 <gwern> *haskell
15:33:17 <gwern> hm. who was that red guy with the scarf who opposed Megaman?
15:33:29 <jesusabdullah> Dr. Robotnik?
15:33:40 <jesusabdullah> Dr. Wiley?
15:33:52 <gwern> no no, he was an opposing robot... thingy
15:33:52 <gwern> guy
15:33:55 <jesusabdullah> oh
15:33:59 <djahandarie> Ugh, slow hackage is making it impossible to code
15:34:01 <jesusabdullah> FABRIGE EGG MAN?!
15:34:03 <gwern> sort of has a shield
15:34:13 * gwern has never heard of Fabrege egg man
15:34:45 <jesusabdullah> It's from a youtube video
15:34:54 <jesusabdullah> idk my mega mans that well
15:34:57 <jesusabdullah> maybe it was
15:34:59 <jesusabdullah> SHIELD MAN
15:35:06 <BONUS> Dr. Wily was the main antagonist but everytime he built many robot masters 
15:35:17 <gwern> -_-
15:35:27 <gwern> BONUS: it was a cosplay and I forgot to ask who he was
15:35:47 <BONUS> haha
15:36:10 <gwern> he won a prize, even, and I told him that he'd left too early
15:37:24 * gwern remiscences fondly watching http://www.vidgle.com/podcast/2010/04/24/con-goer-i-con-29-2010-features-cosplay-skits/
15:38:00 <jesusabdullah> BONUS: Was that you that submitted David Haskellhoff to reddit? I lol'd
15:38:20 <soupdragon> that picture made me literally blush
15:38:24 <jesusabdullah> ahaha @ speedo
15:38:33 * gwern thought it sucked and downvoted. bah humbug
15:38:41 <jesusabdullah> lambda-o?
15:38:46 <jesusabdullah> but gwern 
15:38:52 <jesusabdullah> It's DAVID HASKELLHOFF
15:39:26 <gwern> so?
15:40:34 <jesusabdullah> PFFFRICKINSHT
15:42:26 <tomberek_> ivanm: howdy
15:42:55 <ivanm> tomberek_: just thinking, when doing equality on Contexts, should we care about the order of the lists?
15:43:08 <ivanm> i.e. should we be doing == `on` sort for them?
15:43:19 <tomberek_> no, they should be Sets really
15:43:23 <ivanm> which means we need Ord for the Node types just for Eq?
15:43:31 <ivanm> tomberek_: they shouldn't be sets; multisets maybe, but not sets
15:43:42 <tomberek_> yes yes, bags
15:43:58 <ivanm> unless we switch the definition to being (Node g, [EdgeLabel g])
15:44:06 <ivanm> and build maps... >_>
15:45:04 <tomberek_> switch which definition?
15:45:23 <mreh_> type T = T T
15:45:23 <mreh_> *groan*
15:45:38 <monochrom> type T = T_T :)
15:45:53 <ivanm> for predecessors and successors
15:46:46 <kmc> haha
15:46:54 <kmc> type T a = a a
15:47:12 * soupdragon wants it to be called U
15:47:39 <tomberek_> ivanm: how would that fix it?
15:48:04 <soupdragon> type T a b = b a
15:48:05 <Twey> instance Ord T where compare T Coffee = GT
15:48:06 <mreh_> @remember <mreh> type T = T T <monochrom> type T = T_T
15:48:06 <lambdabot> Okay.
15:48:16 <ivanm> well, we could actually use a Set then, though it'd be more of a Map
15:48:23 <mauke> @quote <mreh>
15:48:24 <lambdabot> <mreh> says: type T = T T <monochrom> type T = T_T
15:48:35 <ivanm> tomberek_: actually, if we wanted a Set there we'd have to force Ord on at least the Node type
15:49:00 <ivanm> mreh_: why @remember with <mreh> rather than just mreh?
15:49:18 <tomberek_> ivanm,, ok, keep it as list and have Eq be 'on' sort, constain Ord Node g
15:49:30 <mreh_> to make separating the two lines of conversation easier
15:49:31 <benmachine> I'd've @remembered monochrom <mreh> ...
15:49:51 <mreh_> I didn't think it would attribute it to <mreh>
15:49:56 <ibt> huh, why does haskell.org go down constantly?
15:50:00 <ibt> kind of embarassing
15:50:00 <ivanm> tomberek_: won't do it now, since that would require Ord on the label as well
15:50:09 <tomberek_> arg!
15:50:11 <ivanm> tomberek_: I think we should just specify that instnaces should return a sorted list for that
15:50:16 <ivanm> makes it easier on us :p
15:50:23 <ivanm> ibt: dodgy server
15:50:50 <djahandarie> I can go beat up the people at Yale, I'm not too far :P
15:50:52 <ibt> ivanm: seems like they should consider moving the site. this seems to happen too much
15:50:59 <ivanm> they are
15:51:02 <ibt> okay, good
15:51:31 <tomberek_> ivanm : hm, why can't we just define compare on Context
15:51:46 <ivanm> tomberek_: we can
15:52:01 <ivanm> but you usually shouldn't require Ord for an Eq definition
15:52:06 <ivanm> since Ord requires Eq :p
15:52:23 <tomberek_> it's Ord of a component
15:52:51 <mreh_> is there any Haskell implementation that can rival Mathematica's
15:52:57 <mreh_> of visualisation
15:53:13 <mreh_> GNUplot seems a likely candidate
15:53:17 <ivanm> huh?
15:53:19 <mreh_> but it makes me cry
15:53:24 <ivanm> you mean you want a plotting library?
15:53:28 <ivanm> there's Chart for 2D stuff...
15:53:35 <edwardk> mreh_: mathematica can do crazy stuff with visualization
15:53:45 <ivanm> but yeah, the Haskell gnuplot library is rather bad
15:53:53 <mreh_> you can use them as first class values
15:54:12 <ivanm> I ended up writing my own conversion functions when I needed to use gnuplot for plots
15:54:15 <edwardk> mreh_: byorgey's newer version of his diagrams library is becoming quite sexy, but its not really directly about plotting graphs 
15:54:42 <ivanm> edwardk: is there any indication when he'll be releasing?
15:54:53 <mreh_> has he accidentally discovered faster than light travel?
15:55:23 <tomberek_> ivanm: i'm ok if the Eq of Context requires Ord on Node g
15:55:53 <ivanm> tomberek_: except then we'd also really need Ord on the label
15:56:08 <tomberek_> ivanm: why?
15:56:33 <ivanm> because of cases like [(1, 'a'), (1, 'b')] vs [(1, 'b'), (1, 'a')]
15:56:42 <ivanm> tomberek_: I think we'd just be better off having the instance writers ensure that those lists are sorted
15:56:49 <ivanm> since most would be using a Map or something...
15:57:06 <tomberek_> ivanm: that indicates two edges between two nodes, are we allowing that?
15:57:20 <ivanm> sure we are
15:57:25 <ivanm> what do you have against multigraphs?
15:57:52 <monochrom> they're so promiscuous
15:59:40 <ivanm> ibt: http://www.reddit.com/r/haskell/comments/cbkkb/wwwhaskellorg_wiki_mailing_list_server_has_been/
15:59:47 <BMeph> Are all sets ordered, by definition, or is that just a Haskell thing? ;)
15:59:49 <tomberek_> ivanm:  nothing...   it just seems bad to require sorting when it isn't needed
16:00:00 <ivanm> BMeph: haskell
16:00:12 <ivanm> BMeph: since you can have a set of functions, etc.
16:00:20 <kmc> it's common in code
16:00:28 <kmc> if you implement a set by a binary search tree
16:00:32 <ivanm> and even in maths I don't think people normally consider an ordering on functions...
16:00:48 <ivanm> well, in the church encoding of a set you definitely don't have ordering
16:01:44 <BMeph> ivanm: Well, _you_ can have a set of functions... I just always wondered why Haskell examples seem to just assume that the Haskell definition is "the way" sets are defined, as opposed to just the way Sets are defined.
16:01:56 <tomberek_> ivanm: how about we just say that implementors have to return that Adj list the same way each time, though not necessarily ordered
16:01:59 <orbisvicis> how do I convert Fractional->RealFrac. I have a function that takes in a fractional and uses properFraction, and ghc complains
16:02:18 <ivanm> tomberek_: sure, make it deterministic
16:02:35 <BMeph> orbisvicis: Make it Real, man... ;)
16:02:48 <tomberek_> ivanm: i think that's better than sorting all the time
16:02:49 <ivanm> tomberek_: though if it's graph-specific (as opposed to instance-specific) then it'd be harder to tell if two graphs built differently are the same
16:03:04 <jesusabdullah> Keep it real, son
16:03:05 <edwardk> google translate just translated a pdf from russian to english for me. I am greatly amused.
16:03:30 <ivanm> I think it's better to enforce how it should be specified
16:03:34 <BMeph> edwardk: Pix, or it didn't happen! ;)
16:03:37 <ivanm> since then you can compare different instances, etc.
16:04:27 <BMeph> edwardk: Seriously, though, I'm interested in the addr of the Russian pdf (it's been too long since I've used any Russian...).
16:04:53 <ivanm> tomberek_: I think current FGL sorts them because of how it's defined
16:05:02 <ivanm> and in general doing so would probably be better
16:05:17 <edwardk> BMeph: http://sp.cmc.msu.ru/datalog/levshin-swps.pdf
16:05:42 <ivanm> tomberek_: after all, when will people care about testing Equality on Contexts? when they're doing == on graphs
16:05:59 <edwardk> BMeph: i still need to bounce back and forth between the translation and the original to read it, but for an automatic translation its quite tolerable
16:06:37 <ivanm> and then you don't want it to be specific to the ordering of that particular graph (e.g. if the ListGraph returns those adjacency lists in the order of the graph's definition; if the same graph is built two different ways then you still want == to be true)
16:06:40 <ibt> ivanm: thanks
16:06:47 <ivanm> np
16:06:54 <jmcarthur> what does "compromised" mean for the haskell.org server?
16:07:06 <kmc> ?
16:07:17 <jmcarthur> kmc: http://www.reddit.com/r/haskell/comments/cbkkb/wwwhaskellorg_wiki_mailing_list_server_has_been/
16:07:31 <ivanm> jmcarthur: good question
16:07:47 <kmc> yikes
16:07:51 <djahandarie> Heh @ BMeph's reply
16:07:53 <kmc> maybe all our GHCs are backdoored now
16:08:19 <monochrom> haha
16:08:21 <tomberek_> ivanm: then how about we define something like: equalGraphWith :: (Context g -> Context g -> Bool ) -> g -> g -> Bool
16:08:41 <ivanm> tomberek_: makes it hard to use == for that ;-)
16:08:47 <ivanm> I mean use that for ==
16:09:17 <soupdragon> can I call SQL from haskell?
16:09:23 <ivanm> tomberek_: why don't you like forcing the instance to sort them?
16:09:31 <tomberek_> ivanm: correct. well if they are using their own implementations of Graph, then they can do (==) = equalGraphWith (myEqualContext)
16:09:37 <ivanm> soupdragon: using one of the DB libraries you probably can
16:09:37 <soupdragon> like I could use haskell to make a huge big table, then SELECT from it and display the results graphically?
16:09:57 <ivanm> soupdragon: sure, if you write a printing function for it ;-)
16:10:24 <tomberek_> ivanm: because we are imposing a sorting
16:10:43 <ivanm> yeah, but what's wrong with that?
16:12:18 <ivanm> OK, I lied
16:12:29 <ivanm> fgl's equal function does an explicit sorting by the Node value
16:13:03 <ivanm> however, depending on how it gets spat out it could fail on multiple edges
16:15:02 <tomberek_> ivanm: how about the sorting only happens when == is called, i'm ok with that
16:15:29 <tomberek_> otherwise predecessors remains unsorted
16:15:35 <ivanm> yeah
16:15:52 <ivanm> ugh, I just made fgl state that two graphs weren't equal when they were
16:15:57 <ivanm> because of multiple edges
16:16:11 <tomberek_> ok, that is fine... i just didn't want sorting to happen when it wasn't needed
16:16:30 <ivanm> I don't see why you don't like sorting by default though
16:17:18 <ivanm> > intersect [1,2] [2,1]
16:17:18 <lambdabot>   [1,2]
16:17:23 <ivanm> cool...
16:17:30 <tomberek_> ivanm: why sort the predecessors list when you don't need to?
16:17:36 <ivanm> anyway, whenever we sort we need either Ord on EdgeLabel, or use intersect on a list of edge labels
16:17:48 <ivanm> tomberek_: I'm saying that it should _generate_ them sorted
16:18:07 <ivanm> ideally, we would use a Map (Node g) (Set (EdgeLabel g)) or something anyway
16:18:20 <ivanm> preflex: seen Cale 
16:18:20 <preflex>  Cale was last seen on #haskell 6 hours, 17 minutes and 23 seconds ago, saying: I might have come up with that name... it was for 'fold binary'
16:18:57 <tomberek_> ivanm: yes, let's say someone's Graph instance does not store them sorted,, they would have to go sort it.
16:19:00 <Cale_> why hello there
16:19:24 <ivanm> hey Cale_ 
16:19:55 <ivanm> Cale_: I've just come up with the dilemma of how to test for equality on graphs with multiple edges
16:19:59 <Cale_> (I am downstairs on my dad's machine which is running VMware inside which I am running and using OSX)
16:20:05 <ivanm> note that current FGL fails with this
16:20:32 <ivanm> in your opinion, is it better to force equality on edge labels or to just use Data.List.intersect or something?
16:20:34 <soupdragon> hi Cale
16:20:40 <jesusabdullah> > intersect [[1,2],[3,4]] [[1,2],[2,3]]
16:20:41 <lambdabot>   [[1,2]]
16:20:46 <jesusabdullah> cool
16:20:48 <Cale_> Can't you treat multiplicity on edges as a special kind of edge label?
16:21:04 <Cale_> soupdragon: hello
16:21:11 <tomberek_> Cale, each edgeLabel is a List? perhaps
16:21:29 <soupdragon> Cale this is funny http://i.imgur.com/Dwize.gif but not as good as that Iwasawa theory page
16:21:45 <ivanm> > equal (mkGraph [(1,1), (2,2)] [(1,2,'a'), (1,2,'b')] :: Gr Int Char) (mkGraph [(1,1), (2,2)] [(1,2,'b'), (1,2,'a')])
16:21:45 <lambdabot>   Not in scope: `equal'Not in scope: type constructor or class `Gr'Not in sco...
16:21:51 <ivanm> bah
16:21:56 <ivanm> ^^ anyway, that returns False
16:22:14 <Cale_> soupdragon: haha
16:22:37 <ivanm> lol
16:22:50 <Cale_> ivanm: Oh, I suppose you could sort them...
16:23:00 <ivanm> soupdragon: you're saying not bother testing whether the labels are equal and just check there are the same number?
16:23:08 <ivanm> Cale_: yeah, which forces an Ord constraint on the label type for edges
16:23:16 <ivanm> ugh, s/soupdragon/Cale_/
16:23:21 <tomberek_> @typo intersect
16:23:21 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
16:23:31 <tomberek_> @src intersect
16:23:31 <lambdabot> intersect = intersectBy (==)
16:23:45 <tomberek_> @src intersectBy
16:23:45 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
16:23:58 <Cale_> If you don't want to sort them, you run into the problem that there's nothing better than O(n^2) to check if they're the same
16:23:58 <ivanm> so yeah, that's O(n*m)
16:23:58 <jesusabdullah> > intersectBy (==) [[1,2],[3,4]] [[1,2],[2,3]]
16:23:59 <lambdabot>   [[1,2]]
16:24:02 <jesusabdullah> huh
16:24:09 <ivanm> Cale_: which is what I figured
16:24:34 <ivanm> tomberek_: waddaya figure? require Ord on EdgeLabel as well? :/
16:24:49 <ivanm> Cale_: or else we can state that only simple graphs are allowed :p
16:24:59 <jesusabdullah> shit, idk lambdas yet
16:25:15 <tomberek_> not a fan
16:25:17 <BMeph> @typo negative
16:25:18 <lambdabot> Not in scope: `negative'
16:25:39 <tomberek_> ivanm: what do we lose with equalGraphWith?
16:25:46 <tomberek_> (need a better name)
16:26:04 <ivanm> I don't like the option of making users have to pick
16:26:34 <ivanm> one thing I hate about current fgl is that there's no Eq instance
16:27:22 <tomberek_> ok... hm... ivanm: what if we only require edgeLabel to have Eq
16:27:32 <tomberek_> erg... no
16:27:46 <ivanm> and there's the problem
16:28:03 <ivanm> what do we prefer: runtime performance or less constraints?
16:28:04 <tomberek_> ivanm: the reason I am against Ord or Eq on edgeLabel is because i want to make graphs where edge labels are functions
16:28:23 <ivanm> tomberek_: right, but in that case are you going to want to test for equality?
16:28:36 <ivanm> (and I've done that before myself, so I agree that forcing that is bad)
16:28:49 <ivanm> @instances Eq
16:28:50 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
16:28:51 <ivanm> @instances Ord
16:28:51 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
16:29:00 <ivanm> hmmm.... which types have Eq but not Ord?
16:29:28 <tomberek_> sure, but if i want test that the edgeLabels are equal, i'd have to test equality on a function by perhaps testing a few values
16:29:33 <tomberek_> or labeling the functions
16:29:56 <tomberek_> data LabeledFunc f = LabeledFunc Int f
16:30:39 <zbanks> I'm having a bit of trouble with cabal while haskell.org is down
16:30:59 <zbanks> I'm trying to install chart, which is failing because I can't install packedstring
16:31:18 <ivanm> huh? I thought hackage was still up
16:31:25 <ivanm> zbanks: hackage is still up
16:31:37 <zbanks> hackage is up, but haskell.org has most of the info that could be used to help
16:31:47 <ivanm> tomberek_: so you want to test for equality on the graph structure only?
16:32:02 <ivanm> zbanks: what's your actual error?
16:32:15 <ivanm> I can't recall the last time that haskell.org helped with a compilation error...
16:32:57 <tomberek_> ivanm: have a topology equals,, with no constraints.. if they want a full eq, use the equalWith
16:33:09 <tomberek_> so (==) is topology, adding no constraints, no work
16:33:15 <ivanm> tomberek_: I disagree
16:33:22 <ivanm> == should match the actual graph itself
16:33:27 <zbanks> Anyway, using ghc 6.12.1 and cabal 0.8.0, I can't install packedstring because ghc "Could not find module `Data.Data' (hold on, pastebinning)
16:33:34 <ivanm> and have a topology == as an extra function
16:33:42 <tomberek_> ivanm: ok, then other way around
16:33:58 <ivanm> (which is equivalent to (==) `on` (nmap (const ()) . emap (const ())) :p )
16:34:15 <ivanm> tomberek_: so, about Ord vs intersect for Edge labels; opinion?
16:34:35 <zbanks> http://paste.lisp.org/display/111165
16:34:41 <tomberek_> ivanm: the downside of intersect is that it's slow?
16:34:53 <ivanm> right
16:35:13 <ivanm> in this case, I think performance is preferred
16:35:17 <tomberek_> ivanm: can we go with intersect, but allow it to be overloaded by instances?
16:35:52 <ivanm> especially since I can't off the top of my head think of a type that has Eq but not Ord
16:35:52 <zbanks> And vanm: haskell.org being down hurts because I see a helpful result on google that seems to describe my error, but I can't view it (& it's not cached)
16:36:09 <ivanm> tomberek_: well, it'll just be some equal functions and instances have to write their own Eq instance (for Graphs at least)
16:36:17 <ivanm> for Context, we can't do an override
16:36:33 <ivanm> and as people are unlikely to want to do equality testing on them, i'm willing to use intersect for that
16:36:43 <ivanm> zbanks: which version of GHC?
16:36:43 <tomberek_> ivanm: ok, let's do something like that.. 
16:37:14 <tomberek_> so intersect, but people can rewrite it?  eg, the default Vector based one we make will do sort?
16:37:22 <zbanks> ghc 6.12.1 and cabal 1.8.0.2 (cabal-install 0.8.0)
16:37:39 <ivanm> zbanks: actually, which version of Chart are you trying to install?
16:37:41 <gwern> @wn oy vey
16:37:42 <lambdabot> No match for "oy".
16:37:42 <lambdabot> No match for "vey".
16:37:44 <ivanm> it doesn't use packedstrings ...
16:37:46 <gwern> oy vey!
16:37:53 <gwern> wordnet is such a potzer
16:38:54 <zbanks> ...okay this is strange...
16:38:56 <tomberek_> ivanm: sorry for being difficult, i'm just thinking that i will want to put things in edgeLabels that don't work well with Ord
16:39:00 <zbanks> For some reason, it now works?
16:39:18 <ivanm> tomberek_: I'm trying to think of a type which would have Eq but not Ord...
16:39:33 <zbanks> (installing chart, that is)
16:39:48 <zbanks> I'm sorry for that... wow. I'm curious why that happened
16:40:02 <gwern> > 365 * 24 * 60
16:40:03 <lambdabot>   525600
16:40:04 <ivanm> zbanks: did you do a cabal udpate in between or something?
16:40:14 <ivanm> > pi^2
16:40:15 <lambdabot>   9.869604401089358
16:40:33 <jesusabdullah> zbanks: I'd be interested in knowing how you like chart. I'm thinking of trying it myself <_<
16:40:39 <zbanks> I may have, but I know I ran cabal update a fwe minutes ago
16:40:43 <ivanm> > 365 * 24 * 60 * 60
16:40:44 <lambdabot>   31536000
16:40:56 <ivanm> jesusabdullah: it's non obvious how to use it without looking at the examples on the home page
16:41:01 <zbanks> jesusabdullah: I'll let you know. it looks pretty nice.
16:41:03 <ivanm> but it does produce nice looking plots
16:41:11 <jesusabdullah> I've been using python/matplotlib but I don't like using it for >1 chart
16:41:13 <ivanm> > 24 * 60 * 60
16:41:14 <lambdabot>   86400
16:41:16 <jesusabdullah> ivanm: Cool
16:41:22 <zbanks> I really envy matplotlib for python... so awesome
16:41:27 <jesusabdullah> hah
16:41:31 <ivanm> dammit, I seem to recall some pi^2 = number of seconds in a year or something rule of thumb, but I can't recall what it is :s
16:41:55 <gwern> that doesn't sound like a very useful rule of thumb
16:42:02 <zbanks> vanm: well pi * 10^7...
16:42:11 <soupdragon> > pi^2
16:42:12 <lambdabot>   9.869604401089358
16:42:31 <jesusabdullah> the pylab interface is easy to pick up if you've used matlab's, but it quickly gets obnoxious of you try to make too many plots imo
16:42:52 <gwern> 'well, all you have to do is multiply 3 numbers, only one of which is 3 digits -' 'NO I WANT TO SQUARE A TRANSCENDTAL'
16:42:57 <jesusabdullah> because you put them together by running a bunch of different procedures
16:43:09 <zbanks> > pi * 10 ^ 7 - 365 * 24 * 60 * 60
16:43:09 <lambdabot>   -120073.46410206705
16:43:54 <jesusabdullah> the side effects are the only effects <_< if I understand that idea correctly
16:44:08 <ivanm> tomberek_: well, I just did a diff of the instances of Eq in base, etc. with those of Ord and for most of them I find it unlikely that anyone would use it for a graph, but anyway
16:44:12 <zbanks> That's pretty close. Off by about 33 hours...
16:44:20 <gwern> I like Stross's idea that certain algorithms can summon creatures from other dimensions
16:44:25 <gwern> now there's a side-effect for you
16:44:26 <jesusabdullah> anyways: I kinda wish it was at least easier to do something object-oriented instead--like, plot.xaxis()
16:44:33 <soupdragon> gwern hehe what book is that from? :)
16:44:40 <ivanm> gwern: well, when it lets you cancel a lot of pi's out for back of the envelope calculations it can be 
16:44:44 <ivanm> (this was in physics)
16:44:48 <jesusabdullah> instead of running xaxis() and just "knowing" what the active plot is
16:44:52 <tomberek_> wait, we have Eq for edgeLabels already as a constraint?
16:44:55 <gwern> soupdragon: his Laundry universe. I think _The Atrocity Archives_ was the first book?
16:45:01 <soupdragon> cool
16:45:02 <jesusabdullah> ...anyways.
16:45:17 <gwern> soupdragon: stross is awesome, needless to say
16:45:31 <ivanm> tomberek_: yup
16:45:58 <jesusabdullah> Stross?
16:46:12 <gwern> I was won over when I ran into this line
16:46:14 <gwern> 'â€œHey, Geoff! Get a load of this!â€
16:46:14 <tomberek_> ivanm: dang, and we can't get rid of that? A function can't be Eq'd
16:46:14 <gwern> I carried on screwing the card back into its chassis. John is not a priority interrupt.'
16:46:20 <ivanm> not what I was talking about, but anyway: http://everything2.com/title/pi+seconds+is+a+nanocentury
16:46:21 <gwern> http://freesf.strandedinoz.com/wordpress/2010/05/toast-charles-stross-2/
16:46:26 <ivanm> tomberek_: that's for Context instances
16:46:34 <ivanm> are you going to want to test for equality on contexts?
16:46:37 <tomberek_> ivanm: it would mean that == is structure based
16:46:49 <tomberek_> hm...
16:46:51 <tomberek_> tough
16:47:05 <jesusabdullah> gwern: Accelerando's author?
16:47:10 <gwern> jesusabdullah: believe so
16:47:11 <jesusabdullah> I couldn't finish Accelerando :(
16:47:12 <ivanm> I _might_ do that in some of my algorithms, but I doubt it
16:47:24 <applicative> > pi
16:47:25 <lambdabot>   3.141592653589793
16:47:44 <ivanm> tomberek_: actually, we couldn't even use intersect; we'd have to write a custom list equality function
16:48:05 <gwern> jesusabdullah: it overloaded you that much with awesome, eh
16:48:11 <ivanm> due to duplications, having to then check the intersection is equal to both initial lists, etc.
16:48:17 * ivanm should go eat breakfast, etc.
16:48:20 * wolverian glares at GHC running out of memory linking gitit
16:48:29 <mreh_> can I install gtk2hs with cabal now?
16:48:30 <wolverian> well, someone running out of memory.
16:48:51 <mreh_> the 0.10 sources have no .cabal
16:48:53 <ivanm> mreh_: the individual parts, yes
16:49:02 <ivanm> mreh_: it's on hackage as gtk, etc.
16:49:06 <jesusabdullah> gwern: maybe? :P
16:49:15 <tomberek_> ivanm:  an extra class EqualGraph that can have the constrains on the edgeLabels?
16:49:24 <ivanm> ugh
16:49:29 <gwern> wolverian: that happens a lot. you pulled in highlighting-kate I take it
16:49:31 <tomberek_> lol
16:49:36 <wolverian> gwern: I did.
16:49:44 <ivanm> tomberek_: if you're not going to do equality on Contexts, then this isn't a problem
16:49:47 <applicative> mreh_, what operating system are you using...
16:50:11 <mreh_> applicative: Ubuntu
16:50:18 <mreh_> because I'm weak
16:50:24 <ivanm> tomberek_: I think we should default to using Ord-based == for edge labels on the graphs that come with FGL, but people can then newtype it and write a custom instance if they so desire
16:50:50 <mreh_> and Debian was too hard for me
16:51:04 <jesusabdullah> I just learned that minesweeper is an NP-complete problem :o
16:51:10 * jesusabdullah uses fedora these days
16:51:13 <ivanm> mreh_: install the relevant -devel versions of gtk+, etc.; then do "cabal install gtk"
16:51:20 <tomberek_> ivanm: maybe i'm getting confused. Perhaps i should just ask, can my edge label be a function?
16:51:22 <jesusabdullah> still have unbunto on my desktop
16:51:26 <ivanm> tomberek_: sure
16:51:34 <ivanm> tomberek_: as long as you don't want to test for equality
16:51:36 <applicative> mreh_, good luck.  It is always torture but I'm dim.
16:51:38 <tomberek_> but i can't do (==) on the graph
16:51:41 <ivanm> or use Show, etc.
16:51:49 <jesusabdullah> ...I had a Hell of a time getting haskell working propers in ubuntu :(
16:51:57 <tomberek_> ivanm: can i still define it? and can i test topological equality?
16:52:03 <ivanm> tomberek_: if we do it my way, not by default; but you can newtype the graph type and write a custom Eq instance that uses the topology-based equality
16:52:04 <gwern> jesusabdullah: most turn-based games of interest are in pretty hairy complexity classes. look at Go
16:52:09 <chrisdone> jesusabdullah: why?
16:52:36 <ivanm> chrisdone: well, Cale_ for one uses the generic binary for GHC and installs packages by hand rather than using Ubuntu's packages
16:52:40 <jesusabdullah> chrisdone: I have no idea why. I just couldn't get things running. Couldn't even get cabal on there iirc
16:52:44 <tomberek_> ivanm: then i'm ok.. so the constraint is not on Graph, but on the Eq instance?
16:52:55 <chrisdone> ivanm: me too
16:52:57 <jesusabdullah> chrisdone: Could've just been a stale install of everything. Computer's been wheezing for a while XD
16:53:04 <zbanks> I found a package for cabal for ubuntu that works pretty well
16:53:07 <ivanm> on my machine at uni the version of GHC is so out of date that I built it by hand (pfft to using generic binaries! :p) and use cabal-install
16:53:15 <ivanm> tomberek_: right
16:53:18 <zbanks> (other than this strange mishap) 
16:53:20 <tomberek_> then that's fine!!!  sorry for being a pain
16:53:23 <ivanm> tomberek_: I was never saying to have it on the graph ;-)
16:53:26 <jesusabdullah> Yeah, I figure if you can get cabal then you're g2g
16:53:33 <jesusabdullah> but never got it on there
16:53:39 <ivanm> well, Cabal comes with GHC...
16:53:41 <zbanks> Yeah. I'll try to find the package for you. (It's what I'm using right now)
16:53:44 <ivanm> so you shouldn't need a package
16:53:49 <ivanm> cabal-install on the other hand... :p
16:53:52 <chrisdone> just get the ghc binary and download cabal-install, off you go
16:53:52 <wolverian> hrm. I just can't link it on this macbook. unless I can increase swap space somehow. unless the linker is actually leaking memory?
16:54:01 <tomberek_> ivanm: ok, in that case,, i was arguing the wrong thing... to Eq a Context, i'd be ok with requiring Ord
16:54:04 <zbanks> http://sporkcode.wordpress.com/2009/07/05/haskell-cabal-in-ubuntu/
16:54:12 <tomberek_> ivanm: or whichever you'd like
16:54:16 <ivanm> tomberek_: Ord for the labels as well?
16:54:18 <jesusabdullah> It was a while ago
16:54:26 <ivanm> good-o
16:54:35 <zbanks> (Maybe this is wrong, because I remember it not working by default...)
16:54:35 <jesusabdullah> like I said I haven't used that in a long time, and haskell stuff seems to be running great on my lappy
16:54:39 * ivanm -> food
16:54:40 <tomberek_> ivanm: yeah,, um.. i have no preference, so i leave it to your (sounder than mine) judgement
16:54:44 <wolverian> I really wish hackage had a build farm and binary packages. :)
16:54:49 <jesusabdullah> at least, xmonad and some random program a friend of mine made work
16:55:47 * jesusabdullah should look for some worthwhile xmonad customizations
17:00:41 <ivanm> wolverian: binary packages woudln't work in general due to too many different possible dep choices
17:00:47 <ivanm> including C libs
17:08:57 <kmc> edwardk, around?
17:12:48 <mreh_> what is gtk2hsC2hs
17:14:25 <mreh_> has someone here started name this father of modern computing thread on 4chan?
17:16:28 <Cale_> mreh_: I think it's a specialised version of c2hs for use with gtk2hs
17:16:42 <Cale_> c2hs is a preprocessor that helps with FFI stuff
17:17:07 <mreh_> it doesn't seem to exist
17:17:40 <Cale_> Did you install gtk2hs-buildtools ?
17:17:56 <mreh_> no :)
17:17:58 <mreh_> found it
17:18:14 <Cale_> Yeah, not sure why it can't be a dependency for gtk2hs
17:18:20 <mreh_> strange it's not a dep for it
17:18:23 <mreh_> yah yah
17:18:31 <mreh_> or glib
17:18:31 <Cale_> I think it's something to do with executables not being allowed as deps.
17:19:10 <Cale_> glib didn't give me any problems though. Just installing the gtk2hs-buildtools, followed by gtk2hs worked for me
17:19:46 <Taejo> will upgrading cabal-install break ghc 6.10?
17:20:34 <jre2> anyone know why the configure script for binary ghc downloads uses explicit paths to various utils instead of whatever's in your path?
17:23:01 <Saizan> Taejo: no
17:23:24 <Saizan> Taejo: "cabal install cabal-install" should work fine
17:29:08 <sfultong> haskell.org was "hacked"?
17:29:30 <ezyang> sfultong: Spam, apparently 
17:30:42 <sfultong> well, paint me red and call me a dirigibile
17:30:56 <interferon> that sounds involved
17:31:23 <sfultong> oh, it shouldn't take long
17:31:25 <jesusabdullah> I think I'll call you a firetruck instead!
17:31:30 <ivanm> sfultong: I'm out of red paint, but I'm calling you a dirigible
17:31:31 <ivanm> happy? :p
17:31:33 <kmc> more paint required if you go in the other order
17:31:45 <sfultong> ivanm: oh, more than
17:31:49 <mgsloan1> hrmm, no hoogle :(
17:31:51 <jesusabdullah> true
17:31:57 <jesusabdullah> Damn!
17:32:03 <jesusabdullah> I have paint too! But it's white
17:32:19 <interferon> kmc: i think that's the way i was thinking of it
17:32:34 <sfultong> if you ionize me beforehand, you could probably run me through a car factory painting unit
17:34:37 <sfultong> apparently that is called electrophoretic deposition... good old wikipedia
17:34:56 <fryguybob> @wn unionize
17:34:57 <lambdabot> *** "unionize" wn "WordNet (r) 2.0"
17:34:57 <lambdabot> unionize
17:34:57 <lambdabot>      v 1: recruit for a union or organize into a union; "We don't
17:34:57 <lambdabot>           allow people to come into our plant and try to unionize
17:34:57 <lambdabot>           the workers" [syn: {unionise}]
17:34:59 <lambdabot>      2: form or join a union; "The autoworkers decided to unionize"
17:35:01 <lambdabot>         [syn: {unionise}, {organize}, {organise}]
17:41:38 <Taejo> can I specify in my cabal file where to put executables (I want to use cabal to build my program, but it's not appropriate to be installed: it's a project-specific tool)
17:41:50 <Taejo> on the other hand, I don't want cabal clean to delete it
17:42:57 <Saizan> you can pass --bindir= to cabal install
17:43:47 <Taejo> thanks
17:53:54 <Makoryu> Sooooo.
17:54:06 <Makoryu> What's going on with the servers *this* week?
17:58:09 <Makoryu> Ah, I see there's an announcement of it on reddit
18:00:30 <ezyang> Can I call functions marked inline from the FFI? 
18:01:02 <dons> Makoryu: completely unrelated stuff, but affecting only www.haskell.org
18:01:05 <dons> we're working on it.
18:01:16 <dons> ezyang: inline C stuff? hmm. yes.
18:01:23 <dons> the hard thing is calling macros
18:03:23 <ezyang> Hm. 
18:03:30 <ezyang> I guess my cabal file is slightly defective then 
18:03:39 <RyanT5000> hey dons, long time no see :)
18:03:43 <RyanT5000> (it's my fault)
18:05:33 <jberryman> where can I learn how to use #ifdef pragmas in my modules. I'm striking out
18:07:05 <Saizan> you should just need {-# LANGUAGE CPP #-} at the top
18:07:25 <ezyang> OH! That's what I was missing. 
18:08:07 <ezyang> no, it still thinks it's not there 
18:15:00 <ezyang> http://stackoverflow.com/questions/997738/haskell-ffi-calling-funptrs seems to suggest otherwise, for "static inline" 
18:20:15 <Nereid> why can't GeneralizedNewtypeDeriving work with classes with associated types :(
18:32:10 * hackagebot directory-tree 0.2.0 - A simple directory-like tree datatype, with useful IO functions  http://hackage.haskell.org/package/directory-tree-0.2.0 (BrandonSimmons)
18:32:17 <ivanm> Nereid: because the associated type stuff is still in its infancy
18:32:30 * BMeph compares type inference with associated types to falling in an 8' sphere of Brawndo and having to drink your way out!
18:32:34 <ivanm> TacticalGrace said he was waiting for SPJ to finish the new type checker before he worked on improving it
18:32:50 <ivanm> Nereid: I'm in a similar situation
18:32:53 <Nereid> heh
18:35:01 <Nereid> so I can't hope for that until at least 6.14 I guess
18:35:10 <Nereid> or 6.13
18:35:28 <applicative> > (some [] , many [], some Nothing, many Nothing) 
18:35:29 <lambdabot>   ([],[[]],Nothing,Just [])
18:35:37 <applicative> > some [1]
18:35:40 <lambdabot>   mueval-core: Time limit exceeded
18:35:43 <ivanm> Nereid: 6.13 is the developmental version
18:35:47 <applicative> > many [1]
18:35:48 <Nereid> I know
18:35:49 <ivanm> 6.14 will be the next release
18:35:50 <lambdabot>   mueval-core: Time limit exceeded
18:35:57 <ivanm> just checking ;-)
18:36:00 <Nereid> :)
18:36:01 <applicative> > some (Just 1)
18:36:04 <lambdabot>   mueval-core: Time limit exceeded
18:36:06 <ivanm> @src some
18:36:06 <lambdabot> some v = some_v
18:36:06 <lambdabot>   where many_v = some_v <|> pure []
18:36:06 <lambdabot>         some_v = (:) <$> v <*> many_v
18:36:15 <applicative> seems to be a terrible bug in control applicative.  
18:36:16 <ivanm> @type some
18:36:17 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
18:36:27 <Nereid> :t many
18:36:27 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
18:36:38 <ivanm> @hoogle some
18:36:38 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
18:36:38 <lambdabot> Control.Exception data SomeException
18:36:38 <lambdabot> Control.Exception SomeException :: e -> SomeException
18:37:15 <applicative> both some and many are defined with mutually recursive where clauses; somehow it's not grounded.  
18:37:28 <applicative> it seems to have been so in GHC 6.8 even
18:38:01 <Saizan> some and many only really make sense for parsers
18:38:29 <applicative> uu-parsinglib hides them and defines its own.  i was looking for an import
18:38:39 <applicative> is that the answer though
18:51:28 <RyanT5000> hey so
18:51:32 <RyanT5000> who owns galois?
18:51:57 <RyanT5000> or, more precisely, is there anyone who frequents our humble IRC channel who speaks for them?
18:52:33 <vermin_slam> i think hpaste is down ...
18:53:25 <Saizan> RyanT5000: i'd ask dons :)
18:53:39 <RyanT5000> yeah, i will the next time i see him around
18:53:53 <RyanT5000> is there anyone else in here who does "industrial" stuff?
18:54:15 <RyanT5000> i'm interested in figuring out more people to collaborate with on open-source haskell stuff
18:55:15 <soupdragon> OSS collaboration sounds differen than industrial work ?
18:57:15 <RyanT5000> soupdragon: well, sometimes it helps to throw some money behind the OSS projects :)
18:57:27 <soupdragon> hehe I guess that is true yes
18:57:38 <RyanT5000> which i'm presently doing, but i'd also like to find some other people and get them to do it as well :)
18:59:33 <Cale_> I could have sworn I'd seen Andy Gill on IRC before...
18:59:50 <Cale_> Maybe I'm imagining it :)
19:03:16 <Nereid> @hoogle (a -> b) -> (b -> b -> c) -> a -> a -> c
19:03:16 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
19:03:16 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
19:03:16 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
19:03:21 <Nereid> oh thanks
19:05:53 <vermin_slam> i'm a newbie trying to learn more about type classes, but I don't understand what's wrong with this example ... why does the second version not compile? http://codepad.org/ZKzG0QAf
19:06:03 <vermin_slam> sorry for using a foreign paste site, but hpaste was down
19:06:52 <kmc> i like codepad
19:07:04 <kmc> it's not pastebin.com ;)
19:07:14 <vermin_slam> indeed
19:07:34 <kmc> vermin_slam, you're mixing up types and classes
19:07:36 <monochrom> Num (Num a)? Why nest? just Num a.
19:07:59 <monochrom> copumpkin would say "Nom (Nom a)"
19:08:00 <kmc> Â«Num (Num a)Â» doesn't make sense, because the syntax for a constraint is Â«C TÂ» where C is a class and T is a type
19:08:05 <kmc> (Num a) is not a type, it's another constraint
19:08:27 <kmc> a type class is like a set of types.  when you say "Num Int" you mean "Int is one of the types in Num".
19:08:40 <kmc> so it makes no sense to say "'Int is one of the types in Num' is one of the types in Num"
19:08:51 <kmc> the part to the right of => is also broken
19:08:55 <applicative> you want to say  instance Num a => Num (Quotient a)
19:09:13 <monochrom> and there is another error. you have the correct number of Num's but you bias them to one side.
19:10:29 <vermin_slam> ah
19:10:38 <applicative> you are saying, on the supposition that type a is Num, i declare Quotient a also to be a Num type 
19:10:52 <vermin_slam> i get it now; the constriant on a goes all the way to the left
19:11:05 <kmc> constraints you require go on the left of =>
19:11:14 <kmc> => what the instance provides goes on the right
19:11:25 <kmc> if you like, you're defining a  "function" which takes "how to add a's" and returns "how to add (Quotient a)'s"
19:11:29 <applicative> yeah, it is a little hard to read at first.  you sort of want to ignore the constraint at first.
19:11:32 <kmc> and the => is then a bit like the function arrow ->
19:11:45 <monochrom> it was easy to read at first for me
19:11:46 <kmc> and there is a sense in which this can be made precise and is useful for compilers in implementing type classes
19:12:35 <applicative> monochrom, it is just that the simpler cases run:  instance Num Foo  or instance Num Foo a
19:12:46 <vermin_slam> this makes a lot more sense now
19:13:06 <kmc> :)
19:13:15 <kmc> that's better than "this makes a lot less sense now"
19:13:19 <applicative> monochrom, so you trip up reading instance Num Foo a => Ord (Foo a, Int) or something
19:13:20 <kmc> we try to avoid that one
19:13:37 <vermin_slam> yeah, that one is much less productive
19:13:45 <applicative> monochrom, which I think is what happened here. 
19:13:53 <monochrom> I didn't trip up when I was learning that. I learned from the gentle introduction.
19:14:28 <applicative> it's not a grave matter obviously. 
19:14:29 <kmc> hehe
19:14:33 <BMeph> applicative: Surely, you mean: Num (Foo a) amirite? ;)
19:14:43 <applicative> yes
19:14:45 <vermin_slam> i came from python so, recursion was okay, but the type stuff, that's been the hard thing to grasp
19:14:45 <kmc> "i learned Haskell by having someone beat me with sticks"
19:14:56 <monochrom> No, not a grave matter. Just refuting an over-generalizing.
19:15:00 * wli started early on enough but has been so thoroughly surpassed by so many who've started after him.
19:15:34 * wli doesn't remember there being things like the Gentle Introduction to Haskell around, just survey papers.
19:15:42 <applicative> vermin_slam, Haskelly types are wonderful, like a dream, constantly astounding.
19:16:00 * BMeph started late in life, so as to maintain his almost-perfect record of underachievement!
19:16:57 <ivanm> Haskell's type system is a nice, comfortable, padded and roomy straight-jacket that protects you from harm (though there is unsafeRemoveJacket if you _do_ want to hurt yourself)
19:17:34 <kmc> Haskell's type system exists to limit what you can do
19:17:36 <applicative> there's nothing straightjacket-like about the type system
19:17:43 <kmc> stupid computer, trying to prevent me from writing incorrect programs
19:17:50 <applicative> man do I oppose this dismal conception. 
19:17:57 <ivanm> applicative: I've read some detractors call Haskell's type system a straight jacket
19:18:01 <ivanm> kmc: heh
19:18:35 <applicative> ivanm, and some praisers too, like um..  the youthful blogger ...  ezyang
19:19:07 <ivanm> I find it akin to a straight jacket in that it does protect you from self-harm (trying to add two Strings together, etc.)
19:19:11 <kmc> Real Hackers don't make mistakes and therefore have no use for a type system
19:19:12 <ivanm> s/akin/analogous/
19:19:14 <gwern> http://blog.ezyang.com/2010/03/straitjacket-programming/ hm
19:19:24 <applicative> the more types there are, the  more power you have.  In Haskell, they form an infinite hierarchy and a category.  
19:19:55 <gwern> '
19:19:55 <gwern> Even though I recognize the `elegance' of certain Haskell constructs, the
19:19:55 <gwern> language was a straitjacket for me because of two things: the type system
19:19:56 <gwern> and the functional purity. 
19:19:59 <gwern> http://groups.google.com/group/comp.lang.lisp/browse_thread/thread/9948645b27a2d49e
19:20:00 <applicative> with "no types' there's just one type where  A -> A  is part of A.  Yick.
19:20:47 <Makoryu> And where IO A is part of A!
19:20:50 <Makoryu> ï¼ˆã€€Â°âˆ€Â°ï¼‰
19:21:25 <applicative> Makoryu, indeed.  
19:21:54 <applicative> "Lisp is more flexible" I wonder what he means
19:22:08 <ivanm> applicative: it lets you shoot yourself in the foot
19:22:11 <soupdragon> it is probably talking about the object system
19:22:16 <Makoryu> applicative: "in bed"
19:22:39 <soupdragon> A = A -> A oh no!!! lambda calculus!
19:22:54 <Saizan> hehe
19:23:08 <soupdragon> This is a real danger to type theorists everywhere
19:23:15 <applicative> untyped yick.  Fix x for everything
19:24:36 <monochrom> untyped lambda calculus provides fix for free
19:24:46 <applicative> @type fix 1
19:24:46 <lambdabot> forall a. (Num a) => a
19:25:02 <soupdragon> > fix 1 == 1
19:25:03 <lambdabot>   True
19:25:39 <applicative> > (\x -> fix x == x) 1
19:25:40 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
19:25:43 <applicative> hahahah
19:25:58 <Makoryu> Then who was Num!?
19:26:17 <ivanm> gwern: ugh, http://groups.google.com/group/comp.lang.lisp/msg/d8c3bdc11258475f
19:26:25 <systemfault> Hmm, what is fix? :(
19:26:30 <ivanm> @type fix
19:26:31 <lambdabot> forall a. (a -> a) -> a
19:26:35 <ivanm> > fix error
19:26:35 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:26:48 <monochrom> fix is http://www.vex.net/~trebla/haskell/fix.xhtml
19:26:52 <systemfault> Thanks :D
19:27:24 <fhobia> what is the function that pads a string to some width? e.g. pad "abc" 5 -> "  abc" ?
19:27:24 <applicative> Makoryu, somehow it knows how to see a 1 :: Int -> Int
19:27:29 <gwern> ivanm: any surprise he's there?
19:27:50 <ivanm> gwern: no, not really
19:27:58 <ivanm> interesting that xahlee at least partially agreed with him though
19:28:01 <systemfault> @src fix
19:28:02 <lambdabot> fix f = let x = f x in x
19:28:10 <applicative> fhobia, I remember one in Data Text.  center or something.  
19:28:21 <ivanm> and xahlee is feeling self congratulatory later on
19:28:29 <Makoryu> > cycle "*Exception: "
19:28:29 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:28:39 <mauke> fhobia: printf
19:29:21 <applicative> center 8 'x' "HS" = "xxxHSxxx"
19:29:40 <fhobia> thanks applicative, mauke 
19:29:48 <mauke> > printf "%*s" 5 "abc" == "  abc"
19:29:48 <lambdabot>   True
19:30:34 <mauke> re: haskell being a straightjacket, I think a Larry Wall quote is appropriate here
19:30:56 <mauke> "Why is this so clumsy?"  "The trick is to use Perl's strengths rather than its weaknesses."
19:31:27 <applicative> fhobia, see http://hackage.haskell.org/packages/archive/text/0.7.1.0/doc/html/src/Data-Text.html   You'd have to redefine it for regular strings.
19:31:29 <systemfault> So, people uses fix for anonymous recursion? That's it?
19:31:47 <mauke> fix is the source of all recursion
19:31:52 <fhobia> applicative: thanks
19:32:01 <systemfault> mauke: Pardon?
19:32:09 <Raynes> Oh no! Kill i... Oh, recursion. I thought you said 'evil'.
19:32:20 <mauke> recursive bindings can be understood in terms of 'fix'
19:32:54 * ivanm should head off
19:32:56 <ivanm> bbl
19:33:14 <applicative> goodbye ivanm
19:33:18 <Nereid> :t fix 1
19:33:19 <lambdabot> forall a. (Num a) => a
19:33:34 <Nereid> :t let x = 1 in (x, fix x)
19:33:34 <systemfault> mauke: So it's would be easy to do the classic fib with fix?
19:33:34 <lambdabot> forall t a. (Num t, Num a) => (t, a)
19:33:57 <Nereid> systemfault: yeah, all recursion can be done with fix
19:34:08 <applicative> > let x = 1 in (x, fix x)
19:34:09 <lambdabot>   (1,1)
19:34:32 <applicative> Nereid, that's baffling me.  
19:34:50 <Nereid> > let fac' f 0 = 1; fac' f n = n * f (n - 1); fix fac' 5
19:34:51 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:34:51 <Cale_> applicative: heh, it's from the instance of Num for functions
19:34:52 <mauke> :t (0 :) . (1 :) . ap (zipWith (+)) fibs tail
19:34:52 <lambdabot> Not in scope: `fibs'
19:34:58 <mauke> :t (0 :) . (1 :) . ap (zipWith (+)) tail
19:34:59 <lambdabot> forall a. (Num a) => [a] -> [a]
19:35:00 <Nereid> errr
19:35:02 <Cale_> applicative: 1 is also the constant function (\x -> 1)
19:35:02 <applicative> Cale_ we see that.   
19:35:09 <Nereid> > let fac' f 0 = 1; fac' f n = n * f (n - 1) in fix fac' 5
19:35:10 <lambdabot>   120
19:35:12 <mauke> > fix $ (0 :) . (1 :) . ap (zipWith (+)) tail
19:35:13 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
19:35:17 <applicative> I wasn't seeing that the first 1 in the pair was also that. 
19:36:20 <Draconx|Laptop> applicative, I imagine that it isn't, due to let polymorphism.
19:36:56 <mauke> > iterate (round . ((0.5 + sqrt 1.25) *) . fromInteger) 1
19:36:57 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
19:36:57 <systemfault> mauke: I see
19:37:23 <Nereid> :t let x = () in fix x
19:37:23 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `()'
19:37:23 <lambdabot>     In the first argument of `fix', namely `x'
19:37:23 <lambdabot>     In the expression: fix x
19:37:25 <Nereid> heh
19:37:34 <applicative> Draconx, but can that be right, they were the same variable in let x = 1 in  (x, fix x)
19:38:09 <Nereid> shouldnt (x, fix x) have the type ((a -> a), a) for some a?
19:38:09 <Saizan> ?type let x = 1 in (x,x)
19:38:10 <Draconx|Laptop> applicative, right, but let polymorphism allows you to instantiate the same variable as different types in the body.
19:38:10 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1)
19:38:13 <mauke> systemfault: let x = E in B ==> (\x -> B) (fix (\x -> E))
19:38:16 <Nereid> oh.
19:38:17 <Nereid> well then
19:38:21 <Saizan> applicative: the monomorphism restriction is off
19:38:44 <mauke> modulo polymorphism
19:38:56 * applicative is secretly in love with the monomorphism 'restriction'.
19:39:01 <Nereid> lol
19:39:14 <Draconx|Laptop> > let x = id in if x True then x 5 else x 6
19:39:15 <lambdabot>   5
19:39:19 <Draconx|Laptop> applicative, like that
19:39:48 <applicative> yipe, i see.  so we don't really know what the (1, fix 1) was
19:39:50 <Nereid> > let x = 1 :: (Num a) => a in (x, fix x)
19:39:51 <lambdabot>   (1,1)
19:39:56 <Nereid> hmm
19:40:05 <Nereid> oh, that's still polymorphic
19:40:05 <Nereid> :/
19:40:07 <mauke> > let xs = 1 : map succ xs in xs
19:40:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:40:22 <Nereid> > fix (1:) . map succ
19:40:22 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[t]'
19:40:27 <Nereid> ugh I fail
19:40:29 <mauke> > (\xs -> xs) (fix (\xs -> 1 : map succ xs))
19:40:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:40:48 <Nereid> > fix $ (1:) . map succ
19:40:49 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:42:56 * applicative thinks lamdabot should maintain monomorphism; children may be visiting this channel.
19:43:15 <systemfault> > take 10 $ fix $ (1:) . map succ
19:43:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:43:49 <Makoryu> I agree with whoever said that the MMR should be a warning
19:44:13 <applicative> > [1,2,3,4,5,6,7,8,9,10] <*> [1,2,3,4,5,6,7,8,9,10]
19:44:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,...
19:44:39 <applicative> > [1,2,3,4,5,6,7,8,9,10] <*> [1]
19:44:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:45:00 <applicative> so it's const, unsuprisingly.  I think it should be succ. 
19:45:11 <Nereid> > 1 1
19:45:11 <lambdabot>   Ambiguous type variable `t' in the constraint:
19:45:12 <lambdabot>    `GHC.Num.Num t' arising f...
19:45:21 <mauke> > 1 (1 :: Int)
19:45:21 <lambdabot>   1
19:45:27 <Nereid> o_o
19:45:43 <applicative> such depravity, you might as well write JavaScript
19:45:58 <mauke> > (sin + pi) 4
19:45:59 <lambdabot>   2.3847901582818647
19:46:05 <soupdragon> <3 that
19:46:17 <Nereid> so we have like a Num a => Num (b -> a) instance?
19:46:21 <soupdragon> this is what I have in scheme too it kick ass
19:46:25 <Makoryu> Nereid: Apparently!
19:46:28 <Nereid> heh
19:46:31 <soupdragon> fuckin add functions and shit WTF
19:46:34 <Nereid> which is reasonable, erally
19:46:35 <Nereid> really*
19:46:47 <mauke> > sin == sin
19:46:47 <lambdabot>   *Exception: (==): No overloading for function
19:46:53 <Makoryu> :t null || (length > 4)
19:46:53 <lambdabot>     Couldn't match expected type `Bool'
19:46:53 <lambdabot>            against inferred type `[a] -> Bool'
19:46:53 <lambdabot>     In the first argument of `(||)', namely `null'
19:46:58 <kmc> hey JavaScript is a perfectly reasonable functional language
19:47:16 <mauke> Javascript 1.6, yes
19:47:24 <applicative> kmc, i know, but with 'dynamic typing' and so on.
19:47:27 <Nereid> :t ap (||) null ((>4) . length)
19:47:28 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[a]'
19:47:28 <lambdabot>     In the second argument of `ap', namely `null'
19:47:28 <lambdabot>     In the expression: ap (||) null ((> 4) . length)
19:47:31 <Nereid> hmm
19:48:01 <Nereid> :t length > 4
19:48:02 <lambdabot> Bool
19:48:06 <Nereid> :V
19:48:13 <Makoryu> :t liftA2 (||) null ((> 4) . length)
19:48:14 <lambdabot> forall a. [a] -> Bool
19:48:16 <applicative> 'hahah' + (typeof 'haha') 
19:48:21 <Nereid> yeah that's what I meant.
19:48:34 <mauke> :t let tan = sin / cos in tan
19:48:35 <lambdabot> forall a. (Floating a) => a -> a
19:48:54 <mauke> > length > 4
19:48:55 <lambdabot>   *Exception: (==): No overloading for function
19:49:03 <mauke> why is there an Ord instance?
19:49:04 <Makoryu> Nereid: For a while I was hearing a lot of cool stuff about J, and went and learned some of it and tried implementing some of the neater tricks in Haskell's typeclasses
19:49:07 <Nereid> :t (||) <$> null <*> ((>4) . length)
19:49:07 <lambdabot> forall a. [a] -> Bool
19:49:31 <applicative> @type \x -> 1 x
19:49:31 <lambdabot> forall t t1. (Num (t -> t1)) => t -> t1
19:49:35 <Nereid> ugh, haskell.org is down again
19:49:42 <Nereid> aha applicative.
19:49:43 <Cale_> whee
19:50:00 <Cale_> Brownout killed the computer upstairs, but not this one :)
19:50:03 <applicative> Nereid, serves them right for chucking monomorphism
19:50:08 <Nereid> ha
19:50:16 <applicative> That's when the rot set in.
19:50:34 <monochrom> use a UPS to fight brownouts.
19:50:40 <Nereid> conal_: 
19:51:10 <Cale_> This machine doesn't have a UPS, but perhaps has a nicer powersupply than mine.
19:51:15 <Nereid> http://hackage.haskell.org/packages/archive/vector-space/0.6.2/doc/html/Data-VectorSpace.html
19:51:18 <Nereid> Vector in same direction as given one but with length of one. If given the zero vector, then return it. 
19:51:27 <Nereid> it doesn't do as advertised :c
19:51:46 <applicative> > (1 :: Int -> Double) 2
19:51:47 <lambdabot>   1.0
19:52:16 <conal> Nereid: yo
19:54:17 <applicative> > (1 :: Double -> Int) . (2 :: Float -> Double) $ 3.33
19:54:18 <lambdabot>   1
19:54:20 <systemfault> Is it possible to make a one-line case statement in ghci?
19:54:28 <mauke> sure, why not?
19:54:41 <systemfault> mauke: I'm still a beginner.. 
19:54:47 <Nereid> case x of { p1 -> e1; ... }
19:54:48 <mauke> > case "system" of _ -> "fault"
19:54:49 <lambdabot>   "fault"
19:54:55 <systemfault> Thanks :)
19:54:57 <vermin_slam> > ("test" :: Int -> Int -> String) 2 3
19:54:58 <lambdabot>   Couldn't match expected type `GHC.Types.Int
19:54:58 <lambdabot>                                ...
19:55:05 <mwotton> Axman6: you around? is there an aushac page somewhere?
19:55:10 <mwotton> thinking about icfp teams;)
19:55:13 <vermin_slam> :(
19:55:19 <mauke> > (sin / cos) x
19:55:20 <lambdabot>   sin x * recip (cos x)
19:55:48 <mauke> > deriv (sin / cos) x
19:55:49 <lambdabot>   1 * cos x * recip (cos x) + sin x * negate (1 * negate (sin x) * recip (cos...
19:55:54 <Nereid> :t deriv
19:55:55 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
19:56:03 <Nereid> Dif, eh
19:56:07 <mauke> > deriv sin x
19:56:08 <lambdabot>   1 * cos x
19:56:28 <Nereid> > deriv (^2) 
19:56:28 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:56:28 <lambdabot>    arising from a use of `...
19:56:30 <Nereid> > deriv (^2) x
19:56:31 <lambdabot>   1 * x + x * 1
19:56:33 <Nereid> heh
19:57:06 <Nereid> > x - x
19:57:06 <lambdabot>   x - x
19:57:07 <vermin_slam> it doesn't care much for simplest form huh
19:57:08 <Nereid> right.
19:57:15 <Nereid> vermin_slam: well it doesn't simplify anything
19:57:16 <Nereid> :t x
19:57:17 <lambdabot> Expr
19:57:27 <Nereid> there's just a Num Expr and so on instance
19:57:30 <mauke> ^ this is pretty awesome considering haskell has no introspection, you can't access a function's source, and deriv is an ordinary haskell function, not a macro
19:58:25 <vermin_slam> yeah, i was thinking about analytic differention in haskell and i came to that same roadblock
19:59:02 <vermin_slam> i figured you would need to take the function as a string and reimplement all the notation on top of your program like a parser
19:59:08 <Saizan> there's a few packages that implement it via Num and the other typeclasses
19:59:09 <mauke> > map (deriv (^2)) [-2 .. 3]
19:59:10 <lambdabot>   [-4,-2,0,2,4,6]
19:59:25 <jb55> top
19:59:25 <Saizan> no need to use strings
19:59:32 <mauke> > map (deriv (deriv (^2))) [-2 .. 3]
19:59:33 <lambdabot>   [2,2,2,2,2,2]
20:00:16 <Nereid> > (deriv exp - exp) x
20:00:16 <lambdabot>   1 * exp x + negate (exp x)
20:00:35 <Nereid> > deriv (f . g)
20:00:36 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:00:36 <lambdabot>    `GHC.Show.Show a'
20:00:36 <lambdabot>      a...
20:00:39 <Nereid> blah
20:00:49 <Nereid> > deriv (exp . (*a)) x
20:00:50 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a'
20:00:50 <lambdabot>         against inferr...
20:00:53 <Nereid> > deriv (exp . (*2)) x
20:00:54 <lambdabot>   1 * 2 * exp (x * 2)
20:02:11 <mauke> > deriv abs x
20:02:11 <lambdabot>   signum x * 1
20:02:16 <mauke> heh
20:02:36 <mauke> > deriv abs 0
20:02:37 <lambdabot>   0
20:04:39 <vermin_slam> well, thanks again for the help with that type class thing; good night all
20:12:40 <Schalken> If 'fac' is the factorial function, and I have a program 'main = print $ fac 42', will 'fac 42' be evaluated each time the program is run, or does GHC calculate and store the result statically during compilation?
20:14:06 <deech> Both haskell.org and Hayoo have been down quite a bit over the last week. Is there a connection?
20:14:10 <Niccus> i have no idea but you might be able to tell by doing it with 'fac 1' and then something like 'fac 200'
20:14:31 <soupdragon> you could look at the compiler output
20:17:09 <Nereid> well this is interesting
20:17:10 <Nereid> `free x :: a
20:17:14 <Nereid> @free x :: a
20:17:14 <lambdabot> f x = x
20:17:14 <gwern> I am almost certain that fac 42 will be re-evaluated
20:17:24 <gwern> ghc doesn't do much partial evaluation like that
20:17:41 <jewillco> @help free
20:17:41 <lambdabot> free <ident>. Generate theorems for free
20:18:06 <mwotton> what? and ruin the whole theorem economy?
20:18:42 <adu> i <3 theorems
20:19:00 <Schalken> gwern: Shouldn't it though? Would that not be a perfectly valid optimization strategy: to evaluate functions at compile time if their arguments are already known?
20:19:08 <gwern> Schalken: sure, it could
20:19:34 <Makoryu> Schalken: You forget, Haskell is a lazy language ;)
20:19:35 <gwern> Schalken: but partial evaluation is very difficult in general; that's why it's an obscure research area, and not a conventional technique
20:20:06 <gwern> I mean, the first partial evaluator didn't even exist until what, a decade after futamura first published?
20:20:49 <gwern> Makoryu: that doesn't matter; if the evaluation of fac 42 forced an undefined or error call, it could be caught and not replaced with any value
20:21:23 <Makoryu> gwern: In my defense, my explanation was in jest.
20:21:30 <gwern> kind of like supercompilation; the research is out there, but no one has gotten it into a useful language or compiler
20:23:27 <gwern> Makoryu: well, it could've been a valid problem, but it isn't and it's worth knowing why
20:23:54 <kmc> Schalken, GHC does have a fairly aggressive inliner
20:24:04 <kmc> but it's hard to say for sure what will happen
20:24:21 <kmc> you can dump out code at various points in the compilation pipeline
20:24:29 <gwern> if it involves any computation, don't expect anything...
20:24:47 <kmc> the form that's useful here would be "core" i believe
20:25:22 <gwern> if it involves renaming stuff and moving stuff around, then you might be happier
20:27:39 <jewillco> @free scanl :: (a -> b -> a) -> a -> [b] -> [a]
20:27:39 <lambdabot> (forall x. f . h x = k (f x) . g) => $map f . scanl h y = scanl k (f y) . $map g
20:28:29 <jewillco> @free scanlM :: (a -> b -> m a) -> a -> [b] -> m [a]
20:28:29 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
20:29:14 <jewillco> @free scanlM :: (a -> b -> M a) -> a -> [b] -> M [a]
20:29:14 <lambdabot> (forall x. $map_M f . h x = k (f x) . g) => $map_M ($map f) . scanlM h y = scanlM k (f y) . $map g
20:31:06 <gwern> http://giovanni.bajo.it/2010/05/compile-time-function-execution-in-d/
20:31:22 <gwern> notice that d requires you to request compiletime eval
20:32:17 <jewillco> @help djinn
20:32:17 <lambdabot> djinn <type>.
20:32:17 <lambdabot> Generates Haskell code from a type.
20:32:17 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
20:32:33 <jewillco> @djinn (a -> b -> M a) -> a -> [b] -> M [a]
20:32:34 <lambdabot> Error: Undefined type M
20:32:48 <jewillco> @djinn (a -> b -> m a) -> a -> [b] -> m [a]
20:32:48 <lambdabot> Error: Undefined type []
20:33:01 <jewillco> @djinn (a -> b -> a) -> a -> [b] -> [a]
20:33:01 <lambdabot> Error: Undefined type []
20:34:21 <jewillco> @djinn a -> [a] -> [a]
20:34:22 <lambdabot> Error: Undefined type []
20:34:42 <jewillco> @djinn (a -> b) -> (c -> b) -> Either a c -> b
20:34:42 <lambdabot> f a b c =
20:34:42 <lambdabot>     case c of
20:34:42 <lambdabot>     Left d -> a d
20:34:42 <lambdabot>     Right e -> b e
20:34:54 <jewillco> @djinn List a -> List a
20:34:54 <lambdabot> Error: Undefined type List
20:35:46 <jewillco> @djinn type A x; x -> A x
20:35:46 <lambdabot> Cannot parse command
20:35:52 <jewillco> @djinn {x}
20:35:52 <lambdabot> Cannot parse command
20:36:20 <jewillco> @djinn data List a = Null | Cons a (List a)
20:36:20 <lambdabot> Cannot parse command
20:36:53 <gwern> jewillco: perhaps you could install djinn or take this to msg
20:37:00 <gwern> note that djinn can do very little
20:38:39 <InvestigatorSala> it doesn't seem to be evaluated at compile-time.
20:47:55 <Nereid> *tumbleweed*
20:48:12 <Spewns> *cricket*
20:54:08 <ksf> dons, you're a beast
20:54:22 <ksf> or you've got a rss feed of reddit.
20:54:27 <ksf> either way, you're way too fast.
20:54:28 <gwern> > 2 / 14
20:54:28 <lambdabot>   0.14285714285714285
20:54:59 <soupdragon> > 142+857
20:54:59 <lambdabot>   999
20:55:17 <soupdragon> coincidence? I don't think so..
20:55:31 <gwern> it was determined by the first axioms laid down by the greeks
20:55:48 <gwern> the solemnity of that sum coming down through history... really makes one think
20:55:58 <soupdragon> :)
20:56:34 <gwern> http://www.reddit.com/r/haskell/comments/cbkkb/wwwhaskellorg_wiki_mailing_list_server_has_been/
20:56:37 <gwern> oh dear
20:56:50 * gwern wonders if all those services salt and hash the passwords
20:57:11 <ksf> ...and why doesn't data.hashtable come with a modify function?
20:57:14 <dons> here's something: when translating C to Haskell, people seem to switch control and data structures willy nilly
20:57:20 <dons> and then get surprised about performance changes
20:57:29 <dons> should that be surprising? how can we ensure that doesn't happen?
20:57:43 <dons> to wit: http://stackoverflow.com/questions/2978979/haskell-math-performance
20:57:52 <ksf> make c a haskell dsl
20:57:53 <gwern> dons: create a C edsl
20:58:08 <dons> translating a for(0 .. 6)  ; loop into a iterate on a list isn't going to be equivalent
20:58:11 <Cale> dons: aggressive deforestation?
20:58:12 <dons> without a few more papers on fusion
20:58:17 <dons> indeed.
20:58:35 <dons> ok. i'll try the native version using the vector library fusion framework.
21:00:08 <ksf> hmmm maybe just use a foldl'?
21:00:14 <ksf> I'm too lazy to try right now.
21:01:30 <dons> me too. but looks like a good case for fusion
21:02:44 * dons is stressing ghc
21:02:46 <dons> $s$wnsteps_r5HN :: System.Random.Mersenne.Pure64.MTBlock.MTBlock -> Int# -> ByteArray# -> Int# -> DLANode -> Int# -> Int# -> Double# -> Double# -> Double# -> Double# -> Double# -> Double# -> Double# -> Double# -> Double# -> DLA.Rmonad.R State
21:04:34 * Axman6 gives GHC a chill pill
21:05:20 <dons> i needz more registerz
21:05:30 <Axman6> get a sparc
21:06:34 <gwern> ah. now I remember why I never use the keybinding for downcase-region, because I keep hitting C-x c instead
21:06:38 <gwern> shucks darn
21:06:44 * adu gives Axman6 some sparc
21:06:54 <Axman6> yay :D
21:07:13 <adu> dons: are you doing asm?
21:07:21 <ksf> dons, you have 16 vanilla and additionally mmx/sse registers
21:07:44 <adu> I'm slowly becoming an expert with x64
21:07:58 <ksf> also, you've got more hardware than logical registers
21:08:11 <dons> adu: no, just generating functions with many registerized arguments
21:08:12 <ksf> and that's 16 sse registers, btw.
21:08:13 <adu> I've been manually translating lots of x64 to arm, so I've been slowly becoming an ARM expert as well...
21:08:59 <adu> btw I <3 the arm enter/leave equivalents
21:11:42 <adu> ksf: did you know that x87 and sse treat NaNs differently?
21:12:12 <RyanT5000> hey dons, do you think galois would be interested in collaborating on any open source projects? i've been talking to dcoutts lately about getting some of my company's ARM stuff into GHC properly, and there might be some other projects we'd be interested in joining
21:12:49 <adu> i would love to work on GHC on ARM, i have an android device to test on :)
21:13:27 <dons> "actually somehow beats the C version (slightly) in my test setup"
21:13:30 * dons does happy dance
21:13:39 <dons> http://stackoverflow.com/questions/2978979/haskell-math-performance/2979049
21:13:44 * adu dances for the sake of dancing
21:13:49 <ksf> I don't know much about sse
21:14:01 <adu> ksf: do you know what a NaN is?
21:14:09 <ksf> but I was kinda surprised about some x87 nan behaviour
21:14:32 <ksf> ...I didn't event want to use the nan value, just rotate it over the stack or something.
21:14:55 <ksf> made me use elaborate reshuffling not to get my whole stack transformed into nans
21:15:34 <adu> both x87 and sse convert sNaN (0...) to qNaN (1...) but x87 returns the max (in case 2 arguments are NaN) and sse returns the first one
21:19:07 <ksf> dons, shouldn't the llvm and gcc backend use all 32 registers?
21:19:35 <ksf> ...and those sse ones are big enough to take two doubles each
21:21:34 <Nereid> anyone familiar with yampa?
21:21:55 <ksf> it's a lot of arrows
21:21:58 <Nereid> it is
21:22:00 <ksf> but it works, unlike reactive
21:22:06 <ksf> but then so does elerea
21:22:33 <Nereid> anyway, my problem is this:
21:23:23 <Nereid> I have some desired velocity v, and I want to let some position x be controlled by that velocity, except be clamped within a certain range
21:23:39 <dons> ksf: ooh, probably :)
21:24:02 <Nereid> so I clearly need something more than x <- integrate -< v
21:24:13 <Nereid> but I'm not sure how to do it.
21:24:16 <ksf> map a clamp function over it
21:24:20 <Nereid> that won't do.
21:24:21 <Nereid> because
21:24:24 <ksf> or a bell curve if you want
21:24:35 <Nereid> if x is already at 0
21:24:36 <ksf> or rather a sine
21:24:46 <Nereid> (say it's clamped to [0,1] for concreteness)
21:24:47 <Nereid> and v is negative
21:24:55 <Nereid> and v goes positive again, then there will be some delay before x starts moving.
21:25:18 <Nereid> because the integral would be negative
21:25:31 <Nereid> so we'd have to wait for it to become positive before seeing a change in x.
21:26:07 <ksf> so you want to clamp v on the position of x
21:26:08 <Nereid> for more concreteness, x is the position of an object that's controlled by arrow keys.
21:26:18 <Nereid> well
21:26:22 <Nereid> I thought about that
21:26:33 <Nereid> but if x is just slightly bigger than 0
21:26:37 <Nereid> and v is large and negative
21:26:39 <Nereid> what do we do?
21:26:45 <Nereid> I want x to go to exactly 0.
21:27:25 <ksf> I don't think "exact" works well with a continuous interpretation of integrals
21:27:25 <Nereid> hmm
21:27:32 <ksf> but I'm a bit out of my maths here.
21:27:32 <dons>   /r/haskell is about to overtake /r/cpp
21:27:38 <dons> just ruby, JS and python ahead. 
21:27:44 * dons boings. the haskell reddit has grown strongly
21:27:51 <Nereid> lol
21:27:59 <dons> good sign for active communiity
21:28:10 <Nereid> I think I have an idea. let me try it
21:28:20 <ksf> that's all just smurfs of oleg
21:28:20 <pastorn> dons: no! we must avoid it!
21:28:34 <ksf> he needs multiple accounts to be able to fill his input buffers without getting bored.
21:32:05 * Cale guesses that ksf is a go player, maybe
21:32:29 <Cale> (at least, that's the only place I've heard the term "smurfs" used quite like that)
21:35:41 <fhobia> :) so narrowing down the imports like "import System.Locale (defaultTimeLocale)" does not strip down the size of the final binary huh?
21:36:59 <ksf> Cale, there's also a very warm, friendly and welcoming community around the spring project.
21:37:12 <ksf> that is, they won't insult your mother completely unprovoked.
21:38:04 <Cale> fhobia: I wouldn't expect it to.
21:38:51 <fhobia> yeah, just experimenting :)
21:38:52 <ksf> though smurfing is at least half-way accepted in spring 
21:39:20 <ezyang> phew, finally answered all of the comments on DB=Category post 
21:39:22 <ksf> ...possibly because rank is based on playing time alone.
21:40:03 <ksf> ghc does dead code elemination
21:40:13 <ksf> but stripping would be a good idea
21:40:33 <Cale> ezyang: So how should we think of the Yoneda completion of a database? ;)
21:40:55 <soupdragon> Yoneda lemma turns functors into string
21:41:33 * ezyang brain explodes 
21:43:01 <ezyang> I guess I should go reread sigfpe 
21:43:02 <Cale> In 10 years, SQL will have LIMIT and COLIMIT statements, and stuff for Kan extensions and ends :)
21:43:05 <ezyang> I might have an answer 
21:45:10 <BMeph> fhobia: Just as Snark Hint (pat. pend.), but there is a very effective way GHC has to reduce the size of the final binary: tell GHC that you want to reduce the size of your final binary. Surprisingly, ks a lot! ;)
21:45:19 <ezyang> I guess I need to figure out what check and uncheck are in the category of schemas 
21:46:17 <ezyang> oh lol 
21:46:21 * BMeph_ thinks BMeph needs to chill a little... ;)
21:46:36 <ezyang> it's saying something not so useful about schema changes 
21:46:37 <Cale> Oh no, LIMIT is already a keyword in SQL :)
21:48:16 <wli> Cale: END and COEND?
21:48:52 <ezyang> Say I have a mystery program that takes an arbitrary database schema change, and migrates data over. Then I can figure out what the migration is by passing in the identity schema change. 
21:48:58 <ezyang> I wonder what that mystery program looks like... 
21:49:30 <Cale> END is a SQL keyword, but COEND isn't ;)
21:49:38 <orbisvicis> to change the class of a type, you have to define a function in the (DesiredClass a) as fromPreviousClass :: (PreviousClass a) => a -> b. And if the type doesnt need to change, the function is pretty much \w -> w ?
21:49:52 <FunctorSalad_> is there a ghc flag to specifically inhibit the "Loading package ..." messages?
21:50:18 <FunctorSalad_> nvm, grep -v ;)
21:50:18 <Cale> orbisvicis: Types belong to various classes. You don't change the class of a type.
21:50:43 <Cale> orbisvicis: In order to make a type belong to more classes, you write instances
21:51:02 <ksf> FunctorSalad_, -v0?
21:51:22 <Cale> orbisvicis: You can think of a class as being like a predicate which may be true or false of any given type
21:51:35 <Cale> orbisvicis: and when it's true, that means there's an implementation of some interface of functions
21:51:36 <ezyang> I don't know if what I said made any sense :^) 
21:52:40 <Cale> orbisvicis: For example, Integer belongs to the Ord class, because there's an implementation of (<) and (>=) and so on for it.
21:52:40 <ksf> it doesn't to me.
21:53:22 <ksf> if you pass an identity change to the program you describe in the first sentence, you would get an empty migration action
21:53:29 <orbisvicis> Cale: what about functions such as fromInteger, etc ?
21:53:47 <ezyang> ksf: Yeah, that's problematic 
21:53:55 <Cale> :t fromInteger
21:53:56 <lambdabot> forall a. (Num a) => Integer -> a
21:54:05 <ksf> do you mean inferring the change from two schema?
21:54:14 <Cale> fromInteger is a method of the Num class
21:54:27 <Cale> In order to belong to the Num class, various types implement fromInteger
21:54:44 <Cale> Or I should say, there are instances for those types which implement fromInteger
21:55:05 <Cale> instance Num Float where
21:55:06 <Cale>  ...
21:55:11 <ksf> that might even be easier than change to migration, as there might be no clear migration for some changes, in the general case.
21:55:19 <Cale>   fromInteger x = integerToFloat x
21:55:28 <Nereid> so yeah, anyone know what's up with haskell.org? :(
21:55:38 <ksf> "compromised"
21:55:39 <Cale> (where integerToFloat is probably primitive, so this isn't a wonderful example ;)
21:55:40 <ksf> see reddit
21:55:42 <Nereid> oh
21:55:54 <ezyang> oh! 
21:56:31 <ksf> which means that someone has gained access to the porn folder and is now occupying all the bandwidth.
21:56:37 <ezyang> ksf: No, I'm barking up the wrong tree; Yoneda's lemma says given a mystery machine that takes schema migrations and pumps out a database, I can find out what the original database was by passing the identity schema migration. 
21:56:53 <ezyang> s/migration/change/ 
21:57:07 <orbisvicis> right, both Integer and (Num a) are types, can something like (Fractional a,RealFrac b) => a -> b be done ? This is what I intended when I said, changing the class: of "a" 
21:57:21 <ezyang> which is, uh, not very interesting 
21:57:50 <ezyang> Well, it might be interesting, but I'd have to study the mystery machines more, anyhoo 
21:58:20 <Cale> Num a isn't a type
21:58:21 <ksf> ct is like post-modernism: complicated proof for stuff that's actually obvious
21:58:42 <ezyang> It's true. "It makes that which is trivial, trivially so." 
21:58:51 <Cale> Num a is a class constraint which says that the type variable a must refer to a type which is an instance of Num
21:59:12 <Cale> :t realToFrac
21:59:13 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
21:59:49 <Cale> This converts from any type in the class Real to any type in the class Fractional
22:00:49 * orbisvicis goes take a look at the module
22:00:51 <ksf> compare it to kant's goal: finding pure terms of consciousness that are not derived from perception.
22:00:54 <ezyang> Though, in its defense, the proof for the Yoneda lemma is pretty simple... 
22:00:54 <tomberek_> byorgey
22:01:18 <soupdragon> I'd like to get cracking on the category theory again
22:01:45 <ezyang> soupdragon: I've had success with the "bang head", put down, "bang head on different text" approach 
22:02:04 * BMeph is curious which module orbisvicis is going to take a look at...
22:02:07 <soupdragon> yeah that's my approach too heh
22:02:18 <orbisvicis> BMeph: GHC.Real, i think
22:02:35 <soupdragon> one of the problems is likely that I don't have anything to apply category theory to, since I only do really basic math
22:02:56 <ezyang> If you do set theory, there's lots of stuff to do 
22:02:57 <soupdragon> as opposed ot algebraic geometry or grothendeicks galois theory or something that actually makes use of cats
22:03:20 <BMeph> orbisvicis: (I may regret this, but...) Do you have a kind of good idea of what it is you're "really" trying to do? :)
22:03:22 <ezyang> I don't do algebraic geometry or galois theory either 
22:03:54 <ksf> compare the notion of commutating diagrams to "terms are grounded in the spontanity of thought, as sensual reflection on the impression of perception. out of those terms reason can make no other use than judging."
22:06:55 <ezyang> I'm using empty data types to model pointer destinations from the FFI, and GHC's complaining that they are unused. How should I rewrite the code to squash the warning? 
22:07:08 <ezyang> ksf: IS that... supposed to be a similarity or difference? 
22:07:18 <ksf> erm both?
22:07:25 <aavogt> {-# OPTIONS_GHC -fno-warn-unused... #-}
22:07:26 <ksf> something like an isomorphism
22:07:26 <ezyang> hee 
22:07:32 <ezyang> aavogt: srsly? 
22:08:04 <aavogt> what's the code that triggers the warning?
22:08:06 <Cale> ezyang: What kind of empty types?
22:08:12 <ksf> I'm reflecting about the process of rational thought vs. formal logical thinking
22:08:22 <Cale> ezyang: Usually you can   newtype Foo = Foo (Ptr Foo)
22:08:29 <ezyang> like, data FooStruct = FooStruct 
22:08:31 <soupdragon> that's wacky
22:08:40 <Cale> ezyang: which isn't really empty, but works nicely for pointers
22:08:40 <aavogt> oh, it's not actually empty
22:08:44 <orbisvicis> Cale: ok, kinda complicated, but the quick & dirty summary, are functions such as realToFrac implemented as I thought they would be
22:08:56 <ezyang> Cale: Curious. Don't I have to unwrap that though? 
22:08:57 <ksf> ...aside from the fact that a logical system should be correct, it'd be great if it would clearly and trivially map onto that which we are bleeding acustomed to.
22:09:02 <Cale> @src realToFrac
22:09:02 <lambdabot> realToFrac = fromRational . toRational
22:09:13 <soupdragon> % git pull
22:09:18 <soupdragon> Already up-to-date.
22:09:19 <soupdragon> :(
22:09:29 <Cale> realToFrac is implemented by composing fromRational and toRational, as you see there, which are methods of the two classes
22:09:33 <Cale> :t fromRational
22:09:33 <lambdabot> forall a. (Fractional a) => Rational -> a
22:09:35 <ezyang> ksf: "Unfortunately, the people in the position to do that are already accustomed to it" 
22:09:43 <Cale> ^^ everything in Fractional implements that one
22:09:47 <Cale> :t toRational
22:09:48 <lambdabot> forall a. (Real a) => a -> Rational
22:09:55 <Cale> ^^ everything in Real implements that one
22:10:13 <aavogt> ezyang: sometimes ghc doesn't know when things are used, say when a type is only named in the results of some TH-generated code
22:10:26 <ksf> but they're not necessarily aware of it.
22:10:31 <Cale> and so any type which is in Real, we can convert its values to Rationals, and then convert those Rational numbers to anything in Fractional
22:11:49 <ezyang> I wonder if EmptyDataDecls squashes the error 
22:11:52 <aavogt> Cale: perhaps emphasize typeclasses as sets of monotypes?
22:12:02 <aavogt> it's not an error anyhow
22:12:35 <soupdragon> I just wanna do like  [ Line red a b, Line red c d, Polygon blue [a,b,c,d] ] and have it figure out the dimensions and render it as a SVG or PNG or such
22:12:44 <ezyang> ooh, sweat, no warnings 
22:12:46 <aavogt> ezyang: this code is for some crazy people who love -Wall?
22:12:51 <ezyang> Yup! 
22:12:54 <ttmrichter> Is Haskell.org down for just me or for everybody?
22:13:01 <Nereid> ttmrichter: everyone
22:13:13 <ezyang> Actually, EmptyDataDecls has the semantics I want too; it shouldn't be inhabited by pure Haskell types 
22:13:21 <Nereid> hmm
22:13:24 <aavogt> soupdragon: but how are they arranged?
22:13:25 <ttmrichter> Nereid: Any idea what's going on?
22:13:28 <Nereid> http://www.reddit.com/r/haskell/comments/cbkkb/wwwhaskellorg_wiki_mailing_list_server_has_been/
22:13:30 <soupdragon> dik
22:13:34 <soupdragon> idk**
22:13:42 <soupdragon> I just want do output graphic easily
22:13:45 <ksf> from what I can see, the comparison of the consequences that arise when a) something is regarded as implying something b) the same, but the other way round (one of a and b being discarded quickly or at least being "exotic") and c) both seen as implying the other play a key role.
22:13:47 <Nereid> perhaps it would be good to put a notice that/why haskell.org is down in the topic?
22:13:49 <ttmrichter> Is Reddit down for just me or for everyone?  :D
22:13:51 <soupdragon> I have to use open gl or something weird
22:13:53 <Nereid> who can do that? Cale?
22:13:58 <ksf> oh, from what I can see *right now*
22:13:58 <Nereid> ttmrichter: just you ;)
22:14:04 <ezyang> It'd down for me too! It seems to go to localhost... 
22:14:06 <ksf> it's damn foggy up there.
22:14:07 <ezyang> :o) 
22:14:11 <aavogt> soupdragon: http://hackage.haskell.org/package/diagrams
22:14:20 <soupdragon> I can't install cairo :(
22:14:28 <Nereid> how do you not have cairo :(
22:14:37 <soupdragon> I cant get ubuntu working
22:14:54 <aavogt> even hackage managed to get gtk2hs installed
22:14:57 <ksf> ubuntu isn't meant to work, but to get uninstalled.
22:15:01 <Nereid> lol
22:15:04 <Nereid> I don't really like ubuntu.
22:15:09 <Nereid> it breaks all the time.
22:15:11 <ttmrichter> Nereid: It's a joke.  Reddit always makes me reload about three times before delivering a page.
22:15:12 <soupdragon> ksf doesn't help me get a working linux system..
22:15:18 <Nereid> ttmrichter: heh
22:15:42 <ksf> reddit is bad at times, better on others
22:15:44 <ttmrichter> Oh, good!  The platform page is still accessible which is what I was after anyway!
22:15:47 <ksf> soupdragon, gentoo
22:15:52 <ttmrichter> Thanks, Nereid.
22:16:00 <Nereid> ksf: likewise
22:16:03 <Nereid> lol
22:16:07 <soupdragon> ksf can I pm you
22:16:12 <kuitang> Why is continuation-passing-style tail recursive? Doesn't the call stack just get transferred to the call stack of the continuation?
22:16:19 <soupdragon> about gentoo
22:16:26 <ksf> -blah?
22:16:28 <Nereid> kuitang: that's tail recursion isn't it?
22:16:42 <ezyang> kuitang: Because the continuation call never "returns" 
22:16:48 <soupdragon> kuitang you just answerd your own question ^-^
22:16:50 <ksf> (I hate being the only one answering)
22:16:53 <lispy|web> kuitang: seems like cps would be a prime candidate for tail call optimization
22:17:07 <kuitang> Wouldn't you still need space for a call stack?
22:17:09 <ezyang> (and in fact, it is!) 
22:18:03 <ksf> kuitang, to return values, you mean?
22:18:14 <ksf> (from functions that don't return)
22:18:25 <BMeph> To return values to _what_?!?
22:18:53 <ksf> the beginning of the program, of course.
22:19:01 <BMeph> It's closures all the way down! 8D
22:19:25 <ksf> the non-lexicality of cps can be quite discomforting
22:19:30 <lispy|web> ezyang: did you get all your ffi stuff sorted?
22:19:31 <kuitang> Suppose you have list_k [] _ = k []; list_k (x:xs) k = list_k xs (\y -> k x:y)
22:19:49 <soupdragon> what the heck
22:19:55 <danharaj> What does non-lexicality mean?
22:20:08 <soupdragon> which function is that supposed to be a CPS conversion of?
22:20:35 <ksf> in a language like C, you can see the stackframes build up with every { you enter and destruct with every }
22:21:02 <ksf> in cps, there's just construction.
22:21:09 <ezyang> lipy|web: Yeah, I think so. 
22:21:12 <danharaj> ah
22:21:37 <lispy|web> ezyang: cool!
22:21:51 <ksf> but the actual confusing part about cps as usually practices (as opposed to olegisms) is not labelling your continuations on the call site.
22:22:05 <Cale> :t let list_k [] _ = k []; list_k (x:xs) k = list_k xs (\y -> k x:y) in list_k
22:22:06 <lambdabot>     Couldn't match expected type `[a] -> t'
22:22:06 <lambdabot>            against inferred type `Expr'
22:22:06 <lambdabot>     In the expression: k []
22:22:13 <Cale> :t let list_k [] k = k []; list_k (x:xs) k = list_k xs (\y -> k x:y) in list_k
22:22:14 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
22:22:14 <lambdabot>       Expected type: [[a]] -> ([a] -> [a]) -> a
22:22:14 <lambdabot>       Inferred type: [[a]] -> ([a] -> a) -> a
22:22:21 <ksf> you can end up with foo (return ()) bar (return ()) (return . const $ ()) and now try to find out which argument is which...
22:22:24 * soupdragon is hoping they'll clarify
22:23:05 <tomberek_> :r
22:23:07 <tomberek_> oops
22:24:22 <Cale> :t let list_k [] k = k []; list_k (x:xs) k = list_k xs (\y -> k (x:y)) in list_k
22:24:23 <lambdabot> forall a t. [a] -> ([a] -> t) -> t
22:24:42 <Cale> > let list_k [] k = k []; list_k (x:xs) k = list_k xs (\y -> k (x:y)) in list_k [1,2,3,4,5] id
22:24:43 <lambdabot>   [1,2,3,4,5]
22:24:43 <orbisvicis> Cale: focusing on fromRational, i see that it simply takes a ratio and returns a ratio. So what makes the new ratio a Fraction is simply that the fromRational function is part of the Fractional class ?
22:25:01 <soupdragon> I guess I'll install blender and output .obj files, that's a quick way to get graphics
22:25:38 <Cale> orbisvicis: fromRational takes a number of type Rational, and produces a number of some other type (which must belong to the Fractional class)
22:26:06 <Cale> > fromRational (3/5 :: Rational) :: Complex Float
22:26:07 <lambdabot>   0.6 :+ 0.0
22:27:16 <Cale> orbisvicis: The means of doing that conversion is encoded in the instance of Fractional for Complex Float
22:27:19 <kuitang> Cale: in each call to list_k, wouldn't the k go like (\y -> k (5:[])), (\y -> k (4:5:[])), so you would build up an unevaluated stack of calls to (:) ?
22:28:02 <Cale> kuitang: Well, if you want, I can evaluate that by hand and see what happens...
22:28:31 <kuitang> Cale: well, when I tried that's what i got
22:31:29 <kuitang> Cale: list_k [1,2] id = list_k [2] (\y -> id (1:y))
22:31:41 <soupdragon> what function is it the CPS transform of?
22:32:31 <kuitang> soupdragon: I might be confusing the terms. It's a simplified version of an example in the little schemer, which calls that a continuation
22:32:32 <orbisvicis> BMeph: you asked me what I was trying to do, besides simply looking around the number system, I ran into this stupid number problem. All my signatures are Fractional, except in my last function I used properFraction, so now I've got to change everything to RealFrac or Real&Fractional because there are no existing functions defined to convert between RealFrac <-> Fractional
22:32:43 <soupdragon> yes but which function is it the CPS transform of?
22:32:46 <Cale> kuitang: http://codepad.org/HYUtLueg
22:32:53 <orbisvicis> now I'm tempted to simply leave off the type signatures and let haskell pick the best one from the context
22:32:54 <soupdragon> didn't y ou start with a function and transform it to get taht?
22:33:30 <orbisvicis> i mean, I don't even see the need to differentiate between RealFrac and Fractional, they might as well be one class
22:33:42 <aavogt> @src RealFrac
22:33:42 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
22:33:42 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
22:33:42 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
22:33:42 <kuitang> soupdragon: No; in the book it was presented as a way to collect multiple results
22:33:47 <soupdragon> ok
22:34:15 <kuitang> Cale: You wouldn't be able to evaluate this until the very end when you get (5:[])
22:34:16 <soupdragon> also I didn't expect little schemer to get into CPS
22:34:16 <aavogt> orbisvicis: if you write RealFrac a => , is the same as   (Real a, Fractional a, RealFrac a) =>
22:34:27 <soupdragon> since seasoned schemer starts much more basic than that
22:34:46 <Cale> kuitang: Well, list_k does nothing but call itself until it reaches the end of the list
22:35:34 <Cale> (with different parameters)
22:35:42 <aavogt> @hoogle (RealFrac a, Fractional b) => a -> b
22:35:42 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
22:35:42 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
22:35:42 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
22:35:52 <kuitang> Cale: but you still have a call tree for (:) ?
22:35:53 <Cale> So you'll never get any part of the result until you walk all the way down the list
22:35:54 <aavogt> @hoogle (RealFrac a, Fractional b) => b -> a
22:35:54 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:35:54 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
22:35:54 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
22:36:03 <Cale> > let list_k [] k = k []; list_k (x:xs) k = list_k xs (\y -> k (x:y)) in list_k [1..] id
22:36:06 <lambdabot>   mueval-core: Time limit exceeded
22:36:10 <aavogt> hoogle is being rather unhelpful :(
22:36:14 <Cale> ^^ this will take forever producing nothing
22:36:34 <kuitang> Cale: so you don't get the constant space advantage of tail recursion with list_k
22:36:54 <Cale> Wait, are you talking about strict evaluators?
22:37:10 <Cale> list_b is tail recursive, anyway
22:37:18 <Cale> er, list_k of course ;)
22:38:07 <aavogt> @type properFraction . toRational
22:38:08 <lambdabot> forall b a. (Integral b, Real a) => a -> (b, Rational)
22:38:11 <aavogt> orbisvicis: ^^
22:38:46 <Cale> kuitang: But it accumulates what might be a rather large function in its parameter
22:39:14 <BMeph> aavogt: He's using Fractionals, not Reals. If he switches to Real, he might as well just make 'em RealFrac. :)
22:40:17 <orbisvicis> @hoogle (Real a, Fractional b) => b -> a
22:40:17 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:40:17 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
22:40:17 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
22:40:20 <orbisvicis> ..
22:40:45 <Cale> kuitang: Things which are simply tail recursive and which don't evaluate or pattern match on their parameters can tend to build up large expressions
22:41:03 <ksf> is referential transparency justified by the non-observability of causality as a phenomenom?
22:41:05 <Cale> :t realToFrac
22:41:06 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
22:41:08 <orbisvicis> im not sure that I want reals, they just allow Ord on Num, right, no division etc. so then, what BMeph said..
22:41:22 <Cale> orbisvicis: I'm not sure you can generally go the other way
22:41:35 <danharaj> ksf: wat? I can observe causality?
22:41:38 <aavogt> @src Fractional
22:41:38 <lambdabot> class  (Num a) => Fractional a  where
22:41:38 <lambdabot>     (/)             :: a -> a -> a
22:41:38 <lambdabot>     recip           :: a -> a
22:41:38 <lambdabot>     fromRational    :: Rational -> a
22:41:40 <Cale> orbisvicis: What Fractional type are you trying to convert to what Real type?
22:41:42 <ksf> no you can't.
22:42:01 <aavogt> there aren't any methods to leave a type that is only Fractional
22:42:04 <BMeph> orbisvicis: That's pretty much "the point" of RealFrac vs. Fractional; a RealFrac is a Fractional that's also a Real - thus, the name. :)
22:42:04 <ksf> you can at best infer its existence by repeated experiment
22:42:18 <danharaj> ksf: What the hell kind of definition of observation are you using.
22:42:31 <aavogt> (this is including any methods in Num)
22:42:48 <ksf> but MERE ACCUMULATION OF OBSERVATIONAL EVIDENCE IS NOT PROOF (Death)
22:43:02 <Cale> causality might just be a statistical phenomenon
22:43:45 <danharaj> an observation of stochastic processes is still an observation
22:44:07 <danharaj> in fact, causality is probably violated at the quantum level. In Quantum field theory, a particle can be affected by things happening outside of its light cone.
22:44:09 <ksf> you can't observe the process, you can observe its _results_.
22:44:19 <Cale> danharaj: Really?
22:44:27 <orbisvicis> Cale: if two classes have the same types, then it should be possible to coerse back and forth. It started as Fractional -> RealFrac -> Fractional with doubles
22:44:27 <Cale> danharaj: Are you sure about that?
22:44:40 <danharaj> Cale: I was told that by my friend who is working in QFT
22:44:52 <danharaj> Cale: He is a grad student though, so disregard his 'knowledge' ;)
22:45:13 <danharaj> ksf: Not to be offensive (more flippant, really), but that is an epistemology straight out of a first year philosophy course.
22:45:17 <ksf> causality being violated is a good thing, I don't want to live in a deterministic universe.
22:45:47 <Cale> orbisvicis: RealFrac is a subclass of Fractional
22:45:49 <danharaj> violation of causality does not imply non-determinism.
22:45:50 <BMeph> ksf: Why not?
22:46:01 <ksf> which might be caused by the fact that I'm no phisicist.
22:46:01 <Cale> orbisvicis: There are types which are Fractional but not RealFrac.
22:46:05 <danharaj> ksf: however, quantum theory strongly hints at it.
22:46:05 <tomberek_> ksf? yeah, why not?
22:46:24 <Cale> orbisvicis: For example, Complex Double is Fractional, but is not a RealFrac type
22:46:24 <tomberek_> what is wrong with a deterministic universe?
22:46:30 <ksf> because I'd like to kill myself if I did.
22:46:45 <ksf> which I couldn't because it'd be predetermined for me to live on
22:46:46 <ksf> which sucks.
22:46:55 <soupdragon> you know what's worse than findnig a huge spider..
22:46:57 <soupdragon> finding 2
22:46:58 <Rotaerk> causality is a theoretical model to describe relationships between observations
22:47:11 <soupdragon> because then you think...  they're got to be more
22:47:13 * ksf agrees with Rotaerk 
22:47:14 <tomberek_> ksf : because you have misconceptions about determinism
22:47:27 <ksf> oh I know about chaos
22:47:29 <BMeph> ...y'know, this discussion ought to be in -blah, so I'll save it. :)ksf: So, If your universe isn't deterministic, who's to say that you won't just 
22:47:31 <ksf> but I still don't like it.
22:47:53 <Rotaerk> bmeph, did you mean to cut off the last bit? :P
22:47:55 * BMeph is impressed with that rearrangement of type...
22:48:01 <ksf> god! not me. that's the point.
22:48:04 <ksf> I hate that bugger.
22:48:15 <tomberek_> ksf: just because you inhabit a particular universe, doesn't mean you know which one you are in
22:48:36 <ksf> you assume that I care much for outside reality.
22:48:39 <Cale> I like this idea that perhaps the fundamental laws of physics are all CPT symmetric, and so you can't really tell the future from the past, except that at one end of the universe, there's really low entropy, and that's what gives time its direction.
22:48:54 <Rotaerk> anyway, the idea of a "real world", i.e. that there is a "universe" in which we "exist", is just a theoretical model to describe one's subjective experiences
22:48:56 <ksf> I happen to wake up each morning into an observably quite similar (ie. messy) room, but that's about it.
22:48:56 <soupdragon> Cale yeah that spooked me when I heard abot that
22:49:03 <orbisvicis> Cale: I thought the data types were the same .. simply extended the functions. Oh this gets confusing, extended types
22:49:11 <soupdragon> but I feel like I learned something important from it
22:49:23 <tomberek_> Cale : the other fun one is how much physics you can get from point of view invariance
22:49:44 <orbisvicis> nondeterminism is the gateway to solipsism. First start off as superman, then control the universe :)
22:49:45 <soupdragon> classical mechanics is from energy invariance I guess
22:50:11 <ksf> but then there's also a couple of reoccuring girls in my dreams, so I figure they're about as real
22:50:24 <BMeph> orbisvicis: Welcome to Haskell! We name things the way we please, not the way all the other "cool kids" do... :)
22:50:31 <Cale> Of course, I shouldn't really say "the fundamental laws of physics" like they were just one thing. :P
22:50:52 <tomberek_> recomends : http://philsci-archive.pitt.edu/archive/00003662/
22:50:54 * Cale doesn't believe in an objective reality
22:51:12 <tomberek_> or, for the powerpoint version http://www.colorado.edu/philosophy/vstenger/Nothing/Lawhigh.ppt
22:51:24 * BMeph thinks objective reality believes in Cale.
22:51:26 <ksf> on a metaphysical level, my intuitive-naive understanding is that we all dream each other
22:51:42 <Rotaerk> solipsism is the default philosophy, without assumption
22:51:45 <ksf> which is caused by the fact that I actually attribute subject-status.
22:51:59 <Rotaerk> beyond that you make assumptions that other souls exist in those people-like patterns, for the sake of simplicity
22:52:00 <ksf> ...to you
22:52:12 <orbisvicis> what about the concept of a shared universe and a private universe
22:52:14 <Rotaerk> i.e. a theoretical model
22:52:17 <Rotaerk> perhaps implicitly held
22:52:29 <orbisvicis> so, a personal reality intermingled with an objective reality
22:52:39 <ksf> orbisvicis, funny enough, there's no way to tell the difference
22:52:46 <BMeph> What about taking this convo to @haskell-blah? Please? 
22:52:56 * ksf agrees
22:53:00 <BMeph> Er, #haskell-blah
22:53:00 <wli> Classical mechanics is basically all Lagrangian/Hamiltonian variational stuff and Poisson brackets.
22:53:09 <orbisvicis> ksf: perhaps, assuming enough variance in the personal reality, the true reality can be determined
22:53:12 <soupdragon> wli, oh never heard of poisson brackets
22:53:27 <mjrosenb> wli: and it is awesome.
22:53:36 <ksf> orbisvicis, /join #haskell-blah and I tell you
22:53:39 <soupdragon> wli don't see that in my book either:[
22:53:49 * Cale uses poisson brackets to catch fish
22:53:58 <soupdragon> lol
22:53:59 <orbisvicis> ok, on topic, should I just make all my type signatures Doubles, RealFracs, or get rid of them ?
22:54:30 <soupdragon> Orbivicis, totally up to you - I turn of MonomorphismRestriction and only write type sigs when I really really want to
22:54:37 <ksf> orbisvicis, do you have idea of or care about numerics?
22:54:42 <ksf> if not, go with doubles.
22:54:42 <augur> oh god, Mrs Robinson makes me feel wonderful ::hugs everyone:: :D
22:54:54 <BMeph> orbisvicis: Considering you're using "properFraction", doesn't that give away your hand, type-wise? 
22:55:26 <soupdragon> oh okay, poisson bracket is like a lie bracket
22:56:52 <orbisvicis> *stupid properFraction. but no, it accepts Doubles in the type signature
22:57:12 <orbisvicis> aavogt: are type signatures required in xmonad code ?
22:57:39 <orbisvicis> ksf: if numerics as in the wikipedia entry, not realy
22:58:11 <Cale> If I catch, on average, x fish in every hour with my Poisson brackets, what is the probability that I will catch exactly n fish in any given hour?
23:03:04 <aavogt> orbisvicis: it has to build with  -Wall -fno-warn-unused-do-bind -Werror
23:03:04 <jsanders> anyone have any idea why I would get the error "There is no available version of ghc that satisfies >=6.9" from cabal?
23:03:23 <Cale> jsanders: Perhaps because you're using ghc 6.8.x?
23:03:25 <orbisvicis> I don't know what that means
23:03:48 <Cale> (and are trying to install a package which requires a newer ghc)
23:03:55 <jsanders> Cale: my ghc version is 6.12.1
23:03:58 <Cale> hmm
23:04:03 <Rotaerk> cale, depends on the probability distribution?
23:04:08 <BMeph> So, is anyone working on an MVCC-using model for STM? In Haskell, that is?
23:04:16 <Rotaerk> though I guess there's a "poisson distribution", iirc
23:04:18 <aavogt> the ghc-api package perhaps?
23:05:19 <Cale> Rotaerk: yeah, in addition to what I said, you really need that the rate is independent of the time since the last fish caught as well
23:05:28 <Cale> Rotaerk: and then it's a Poisson distribution
23:05:28 <aavogt> orbisvicis: those are flags passed to ghc
23:05:49 <Cale> jsanders: ghc-pkg list ghc
23:06:26 <aavogt> perhaps cabal-install is using a different ghc than you think you are
23:07:10 <jsanders> Cale: ran ghc-pkg check and it looks like 'ghc-6.12.1' is broken somehow 
23:07:19 <jsanders> not sure how that would happen
23:07:48 <jsanders> any ideas how I might fix that easily?
23:08:00 <orbisvicis> wtf, how do I not have ghc man pages
23:08:15 <orbisvicis> aavogt: so -fno-warn-unused-do-bind
23:08:35 <orbisvicis> .. basically means, warnings on things without signatures, and exit on warnings ?
23:08:50 <aavogt> no
23:09:27 <aavogt> it means don't warn when you do something like:   do { Just 1; Just 2 }
23:09:30 <FunctorSalad_> @typ properFraction
23:09:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
23:09:40 <FunctorSalad_> omg
23:09:47 <aavogt> instead of   do { _ <- Just 1; Just 2 }
23:10:03 <aavogt> FunctorSalad_: how so amazing?
23:10:25 <FunctorSalad_> aavogt: not at all... just a Prelude(?) function I had never heard of ;)
23:10:34 <aavogt> @type lex
23:10:34 <lambdabot> String -> [(String, String)]
23:10:45 <aavogt> that's another prelude function
23:11:11 <aavogt> trivia: how many functions are defined in the Prelude?
23:11:58 <jsanders> for the record, reinstalling GHC fixed my problem.
23:13:46 <BMeph> jsanders: Ah, but did it fix the Operator? ;)
23:14:15 <jsanders> BMeph: what do you mean?
23:14:20 <aavogt> hmm, ghc claims 205 functions
23:17:13 <aavogt> FunctorSalad_: out of about 200 functions, it's pretty likely that you wouldn't know them all
23:19:10 <trontos> what's the best way to append an element to the end of a list?
23:19:44 * trontos needs to append an elment to the end of an accumulator list...
23:20:19 <aavogt> @src ShowS
23:20:19 <lambdabot> type ShowS = String -> String
23:20:34 <aavogt> trontos: 'append' like you do with ShowS
23:20:46 <aavogt> > shows 123 " and the rest"
23:20:47 <lambdabot>   "123 and the rest"
23:21:10 <trontos> isn't that prepending?
23:21:18 <FunctorSalad_> aavogt: more than I'd have guessed
23:21:19 <FunctorSalad_> :)
23:21:39 <aavogt> trontos: what's the difference?
23:21:53 <trontos> pre is before, appending is to the end
23:22:15 <trontos> give (x:xs), I'd like to have the list of xs with the last element x
23:22:18 <trontos> if that makes sense?
23:22:28 <trontos> s/have/make
23:23:10 <aavogt> I mean you can use    xs ++ [x], but that takes time proportional to  length xs
23:23:24 <soupdragon> you can make a data type like list but with :++ a constructor
23:23:28 <trontos> not worried about  time at this point (just learning)
23:23:42 <trontos> ah, that makes sense
23:24:20 <aavogt> but if you instead of an accumulating parameter, you have a function that prepends something to the end, you can compose functions to get a quick append
23:24:22 <trontos> brillant, thanks aavogt
23:24:47 <aavogt> > shows 1 . shows 2 $ []
23:24:48 <lambdabot>   "12"
23:25:09 <trontos> mind hurts :)
23:25:19 <trontos> don't have a good intuitive feel for this yet
23:25:30 <trontos> I'm happy with the xs ++ [x] for the time being
23:25:54 <trontos> I know it is inefficient, but at least it helps me to get this to compile
23:26:00 <soupdragon> it's just (xs ++) . ([x] ++) . []
23:26:04 <soupdragon> oops
23:26:12 <soupdragon> the last . should be $
23:26:17 <trontos> or not
23:26:30 <soupdragon> > ("xs" ++) . (['x'] ++) $ []
23:26:31 <lambdabot>   "xsx"
23:27:03 <aavogt> except the xs is also a function, soupdragon
23:27:18 <aavogt> (if we use a similar style to ShowS)
23:27:28 <trontos> thanks for the help
23:29:54 * ski wonders whether we should call `(++)' the "prepending" function, instead
23:41:30 <Nereid> ski: what's wrong with "concatenation"?
23:42:16 <ski> it's ok, except (a) `concat' (b) `(++) foo' is a function which prepends `foo'
23:42:55 <Nereid> so what should we call (-), if (-) foo doesn't subtract foo?
23:43:03 <ski> good question
23:44:48 <mjrosenb> rsb
23:44:55 <mjrosenb> at least, that is what arm calls it
23:45:19 <ski> does that stand for something ?
23:45:27 <mjrosenb> reverse subtract
23:46:23 <Nereid> well we do have a subtract function, where subtract = flip (-)
23:46:28 <ski> in "cancelling subtraction", we have that in `rest = minuend - subtrahend', it is `(- subtrahend)' which "acts" on `minuend' to produce `rest'
23:46:46 <Nereid> words
23:47:41 <ski> similarly, in addition, we have that in `sum = augend + added', it is `(+ addend)' which acts on `augend' to produce `sum' .. this is if addition is defined by matching on the right argument
23:48:14 <ski> e.g. the `augend' can be an absolute temperature, `addend' is a temperature difference, and then `sum' is a new absolute temperature
23:48:21 <augur> i find myself doing all sorts of crazy things that seem very Monad-like to me
23:48:26 <augur> its so painful
23:48:35 <Nereid> ski: are these even words
23:48:38 <Nereid> augend, subtrahend
23:48:39 <Nereid> :(
23:48:50 <ski> or `augend' can be a point in an affine space, and `addend' is a vector, so `sum' is a new point
23:48:52 <augur> and im doing them in ruby
23:48:58 <ski> Nereid : sure :)
23:49:04 <Nereid> summand
23:49:05 <Nereid> thank you
23:49:18 <ski> you're right :)
23:49:47 <ski> they are the traditional words for the different roles of the arguments and result in addition, subtraction
23:50:05 <Nereid> but addition is commutative, so who cares which summand is which
23:50:20 <ski> addition of a vector to a point is not commutative
23:50:51 <Nereid> it's not addition in the sense of an abelian group, since the two arguments have different types
23:50:52 <Cale> But it is if you identify points and vectors :)
23:51:05 <Nereid> Cale: which you can only do if you fix an origin
23:51:06 <ski> Cale : .. which requires an arbitrary choice :)
23:52:00 <mjrosenb> ski: the addition should not typecheck
23:52:10 <ski> mjrosenb : indeed
23:52:32 <ski> (i.e. the commutative law would not type check)
23:52:58 <Nereid> ski: you could always overload + to act on a vector and a point in the reverse order
23:53:04 <Nereid> making it effectively commutative
23:53:20 <ski> (well, it's not the same operation, then)
23:53:56 <Nereid> (I agree)
23:53:57 <ski> (then it just says that `forall a b. plus a b = flip plus b a', which is obvious)
23:54:25 <Nereid> what's the point of this discussion
23:54:33 <ski> i'm not sure
23:54:42 <mjrosenb> Nereid: to show how smrt we all are.
23:54:45 <bill``> hi
23:54:46 <Nereid> (++) is a concatenation operator. I'm fine with that.
23:55:10 <c_wraith> :t (<>)
23:55:10 <lambdabot> Doc -> Doc -> Doc
23:55:17 <dolio> The point is that it's apparently a big deal whether (++) is named append or prepend or concatenate.
23:55:27 <Nereid> or we could just call it (++)
23:55:37 <c_wraith> it is?
23:55:51 <ski> Nereid : do you read that out loud as "double-plus" ? :)
23:56:09 <Nereid> plus-plus, if I'm reading code aloud
23:56:09 * mjrosenb unfortunately reads it as 'increment'
23:56:22 <JN> when attempting to read haskell, I never know how to pronounce the operators.. 
23:56:33 <Nereid> spell them out ;)
23:56:39 <Nereid> greater-than-greater-than-equals
23:56:42 <JN> less-than-asterisk-greater-than is really awkward to say
23:56:53 <dv-> Do people pronounce code in their heads?
23:56:53 <Nereid> "thingy"
23:57:12 <Nereid> f thingy x thingy y
23:57:33 <JN> I do.  the voice in my head sounds just like I sound.. :q
23:57:47 <tomberek_> is there a class of functors that all functors are a part of except ((,)a)
23:58:00 <Nereid> I'm not sure what I do
23:58:08 <ski> (JN : .. then how do you know whether you're crazy or not ? ;)
23:58:26 <ski> tomberek_ : i don't think so
23:58:27 <Nereid> I might pronounce code in my head but when I do I just use a picture for operators
23:58:38 <Nereid> tomberek_: why would you want one?
23:58:44 <JN> I think.. therefore I am not crazy.  q.e.d.
23:59:01 <tomberek_> i'm trying to do some recursion, but have it stop on a typeclass constraint
23:59:18 <Nereid> paste
23:59:22 <bill``> i don't even know what a functor is yet :-)
23:59:47 <Nereid> the mathematical definition comes to mind first for me
