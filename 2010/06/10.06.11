00:00:07 <kniu> how DO you implement let-blocks with recursive definitions in an interpreter?
00:00:14 <Veinor> kmc: like printf?
00:00:17 <kmc> yeah
00:00:38 <kmc> if you're just after some kind of default / named-argument scheme
00:00:56 <kmc> then you can use a record, with a "default" value provided, and using the record-update syntax
00:01:10 <kulin> well what i was doing was writing a general function more like printf, but for withCString
00:01:11 <kmc> kniu, with lazy eval?
00:01:24 <kmc> if your args all have the same type, how about a list?
00:01:24 <kulin> but i guess ill just be doing with2CString with3CString etc
00:01:25 <kniu> kmc, kind of
00:01:45 <kmc> well it's not too different either way
00:01:50 <Veinor> kulin: withCString?
00:02:04 <Veinor> oh, FFI stuff
00:02:05 <kulin> its for converting to char* for foreign 
00:02:11 <Veinor> I don't know the FFI, so
00:02:56 <kmc> would the type «[String] -> ([CString] -> IO a) -> IO a» be acceptable?
00:04:11 <kulin> i could make it work but i would end up hoping the list sizes were right at some point in the program, so ill just do the other way
00:04:23 <kmc> yeah
00:04:25 <kulin> i doubt ill have more than 5 cstrings in a single call, so its just 3 functions
00:04:28 <kulin> or rather 4
00:05:00 <ulfdoz> Isn't it possible with template haskell?
00:06:07 <ksf> kulin, http://www.haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
00:06:29 <ksf> which shows a not-too-hacky way of doing printf
00:06:49 <ksf> other options include fundeps or oleg-style cps
00:07:55 <ksf> ulfdoz, it's even possible without
00:08:19 <ksf> not with type String -> whatever -> IO (), though, because haskell isn't dependently typed
00:08:39 <ksf> but one could definitely generate the pattern on the type level with th, parsing a string.
00:08:56 <ksf> ...what's just not going to work is run-time patterns.
00:12:55 <kulin> man that paper is dense
00:18:23 <ksf> yep it's more aiming at giving an intuition about how to use type functions in general rather than going into the details of the examples
00:42:16 <vipex> hi, leksah platform installed... (windows x64), now I confuse how to start with the IDE :((
00:42:54 <vipex> where I should start?
00:43:10 <vipex> how steps create & compile "Hello World"
00:43:31 <ezyang> Is there a way to match on just data constructor (without having to worry how many fields the constructor has?) 
00:43:46 <Starfire> ezyang: Cons {}
00:44:06 <vipex> sory, haskell platform i mean*
00:45:34 <ezyang> Starfire: Cool. 
00:45:48 <byorgey> vipex: the Platform doesn't come with an IDE
00:46:13 <kulin> hah leksah is apparently the haskell ide of choice, i was totally unaware
00:46:22 <byorgey> vipex: you can use your own favorite editor, or you can install something like leksah
00:46:30 <Zao> kulin: According to what?
00:46:35 <kulin> their site :)
00:47:05 <byorgey> I think it's probably true that among people who use some sort of IDE for Haskell, leksah is far and away the most popular.
00:47:19 <byorgey> but I think the majority of people still just use emacs or vim.
00:48:13 <kulin> i might have to try it out sometime, just using emacs myself
00:48:41 <kulin> actually what am i saying, i would die without vim keybindings
00:49:07 <Zao> kulin: Good boy.
00:49:48 <byorgey> vim keybindings in emacs??
00:50:00 <kulin> yep
00:50:15 <kulin> emacs keybindings were dreamed up by some guy who hates wrists or something
00:50:21 <byorgey> hehehe
00:50:44 <danharaj> both are dinosaurs built by and for the neckiest of beards.
00:51:22 <kulin> its true
00:52:08 <Veinor> I like emacs :(
00:52:47 <blackdog> calling something "neckbeardy" isn't much of an argument against it
00:52:57 <blackdog> or is logic for neckbeards too?
00:53:18 <danharaj> The beard is strong with this one.
00:54:26 <Hunner> i tried emacs after 10 years of vim. it's pretty good. better at some things, not as good at others. it's just a case of the right tool for the right job
00:54:37 <kulin> interns
00:54:38 <blackdog> danharaj: untrue, sadly. i have a cricket beard.
00:55:03 <danharaj> The neckbeard has transcended material presence.
00:55:15 <Zao> Hunner: You've got to match up your brain damage type to the right editor.
00:57:07 <Hunner> that too. i started recommending "try both and see what fits you" instead of defaulting to vim, but not much other change
00:57:41 * blackdog is slightly sad that no-one asked what a cricket beard is
00:57:59 <Hunner> anyone who's programed procedurally for years and switched to haskell knows how hard it is to change you're way of thinking
00:58:04 <byorgey> blackdog: what is a cricket beard?
00:58:08 <blackdog> 11 a side
00:58:15 <byorgey> hehe
00:58:26 <blackdog> thank you, you're an excellent straight man
00:58:44 <Hunner> your* :(
00:58:50 <Hunner> (for me)
00:59:22 <blackdog> i suppose it could be a combover neckbeard
01:00:48 <vipex> Hunner: It's totaly TRUE
01:00:50 <vipex> :(
01:01:11 <vipex> it's hard for switching from procedural / OOP env
01:01:55 <vipex> so please suggest me, Im totally new in haskell... just being starting...
01:02:09 <vipex> I have haskell platform for windows installed
01:02:38 <vipex> now I should pick an editor, what ide/editor you guys use?
01:02:46 <vipex> what steps next?
01:02:51 <danharaj> notepad++
01:02:52 <vipex> please suggest
01:02:54 <blackdog> emacs is popular, vim is too.
01:03:00 <kulin> any editor, the compiler is totally seperate
01:03:03 <blackdog> but it doesn't matter that much at this stage
01:03:06 <Hunner> emacs and gvim work in widows
01:03:16 <blackdog> you should spend a lot of your time at the REPL, just playing and trying things.
01:03:19 <danharaj> yes, use an editor that will take you just as long to learn as Haskell will.
01:03:32 <Hunner> oh right
01:03:41 <vipex> what is REPLS?
01:03:44 <blackdog> well, there are two questions there - what he should use, and what we use.
01:03:45 <vipex> REPL*
01:03:51 <danharaj> ghci
01:03:56 <lyndon> vipex: ghci
01:04:04 <Hunner> whats the learning curve on leksah?
01:04:06 <blackdog> read-eval-print loop - just the ghci console, basically.
01:04:46 <danharaj> If leksah is anything like other IDE's on Windows, like Visual Studio, Eclipse, or Codeblocks, etc. it shouldn't be that high.
01:05:13 <vipex> ghci comes with the haskell platform, it's an interactive is it? it's not for building our code is it?
01:05:15 <danharaj> But there's no need for an IDE for basic Haskell. GHC is much better at building automagically. say the average C compiler.
01:05:26 <danharaj> than say*
01:06:01 <Hunner> vipex: yes, ghci is your new best friend
01:06:04 <blackdog> Hunner: it's still pretty new. it certainly hasn't had nearly as much work put into it as visual studio or eclipse.
01:06:10 <vipex> can you teach me in short how create Hello World?
01:06:15 <Zao> WinGHCi is nice too, if you're on Windows.
01:06:30 <vipex> yes please in WinGHCi
01:06:32 <blackdog> it'll be interesting eventually, but you'll probably hit a few bumps. if you're learning, you want a nice simple editor like emacs
01:06:43 * blackdog is just deliberately infuriating danharaj now.
01:06:48 <Zao> > print "HI!"
01:06:49 <lambdabot>   <IO ()>
01:06:52 <danharaj> You can't infuriate me, I use soap.
01:06:59 <vipex> just an Hello World please, I wanna some Hello World .exe compiled
01:07:01 <J-roen> vipex: http://www.haskell.org/haskellwiki/Haskell_in_5_steps
01:07:35 <vipex> ok am googling emacs now...
01:07:42 <Hunner> no!
01:07:44 <kulin> dont learn emacs
01:07:47 <vipex> :D
01:07:47 <kulin> or anything, use what you know
01:08:01 <kulin> learn 1 new thing at a time
01:08:12 <danharaj> if all you need is syntax highlighting, use notepad++
01:08:27 <vipex> I use scitee, wondering how integrate haskell compiler
01:08:36 <kulin> you dont integrate it
01:08:41 <vipex> ???
01:08:46 <kulin> just run the compiler from the prompt
01:08:54 <lyndon> yes, learning both haskell and vi/emacs at the same time would be very frustrating. notepad++ would be much nicer.
01:08:59 <vipex> then how I compile the code over editor?
01:09:04 <vipex> kulin: oh isee!
01:09:09 <danharaj> ghc --make
01:09:13 <Hunner> syntax hilighting in haskell is almost silly, since everything just ends up being your function names
01:09:28 <vipex> it's totaly new, damned... i'm delphi / visual C programmer
01:09:39 <roconnor> top-level pattern matches are fun!
01:09:52 <danharaj> Hunner: It helps me see case and let expressions more clearly, at the least.
01:09:52 <silver> emacs isn't hard :S well it'll take may be hour or two to complete the tutorial and you're ready to code there
01:10:15 <vipex> ok step by step, I open GHCi now...
01:10:33 <pastorn> vipex: putStrLn "hello world!"
01:10:48 <blackdog> Hunner: there are a few keywords... and you can colour literal strings.
01:11:15 <J-roen> vipex: Just follow the instructions on http://www.haskell.org/haskellwiki/Haskell_in_5_steps.
01:11:17 <blackdog> actually, what i do is to use ghc-mod, which gives you a bit of integration with a syntax checker. emacs only, though.
01:11:24 <pastorn> vipex: are you working with some reading material?
01:11:25 <vipex> pastorn: got it (found haskell case sensitive :( )
01:11:31 <pastorn> (are you going to work with)
01:11:38 <pastorn> of cource it is!
01:11:41 <vipex> now, how I compile my Hello World to executable?
01:11:52 <pastorn> start a new file
01:11:53 <J-roen> vipex: Again: http://www.haskell.org/haskellwiki/Haskell_in_5_steps.
01:11:54 <pastorn> Hello.hs
01:11:56 <Hunner> blackdog: yeah, but it's not super useful like bourne, c, ruby, etc. the more useful part is being able to pull up types
01:12:10 <vipex> yes, I open many tabs contain haskell article on my browser :D
01:12:14 <pastorn> vipex: read J-roens link
01:12:32 <vipex> i need some practice since my background also programmer :D
01:12:53 <kulin> <- impressed
01:13:19 <blackdog> Hunner: hm. I don't know, I don't like coding without syntax highlighting. you also have the distinction of types, type variables and terms
01:13:33 <blackdog> because you have the case-driven distinction there, you can colour them pretty easily
01:13:35 <vipex> where I create my Hello.hs?
01:13:47 <vipex> from GHCi or win explorer? 
01:14:07 <pastorn> vipex: just save it from your text editor somewhere
01:14:08 <roconnor> vipex: notepad
01:14:15 <vipex> pastorn: OK, i real Haskell_in_5_steps now..
01:14:18 <vipex> reading...
01:14:48 <vipex> read*
01:16:35 <vipex> I read the instruction:
01:16:36 <vipex> And compile it with:
01:16:36 <vipex>     $ ghc -o hello hello.hs
01:17:02 <vipex> where I type those command? in GHCi or console?
01:17:07 <pastorn> yes, but since you're on windows it's gonna be a bit different
01:17:12 <pastorn> console
01:17:13 <kulin> right, you run the ghc executable on the hello.hs text file to create the executable hello
01:17:18 <pastorn> have you added ghc to you path?
01:17:22 <danharaj> ghci is just an interpreter, it evaluates pieces of code.
01:17:28 <pastorn> (or however windows works that...)
01:17:31 <vipex> yes, i already setting up the path,
01:17:37 <vipex> so it could reach anywhere
01:18:01 <pastorn> vipex: good, then just stand in the same dirctory as hello.hs and run that command
01:18:35 <vipex> done, i just succesfully compile the hello.hs :D
01:19:46 <vipex> ... wuuuh like that? it's totaly new env / coding style for me :((
01:19:55 <vipex> how to debug haskell code :((
01:20:16 <vipex> i miss F9 (delphi) / F5 (VS) compile shortcut :))
01:20:17 <lyndon> vipex: leksah might be ok for you, more ideish
01:21:02 <ksf> oh, I wanted to try out how leksah's yi support is coming
01:21:05 <pastorn> vipex: when i program in haskell i almost *never* actually compile my code
01:21:07 <pastorn> because
01:21:09 <vipex> oh mine... Hello World exe produce 876 KB in size ???
01:21:15 <pastorn> if it typechecks, it must work ;)
01:21:26 <ksf> vipex, it's statically linked
01:21:27 <Zao> vipex: There's a fair amount of runtime.
01:21:29 <p_l> vipex: statically compiled, I guess... and 876KB? That's small
01:21:31 <pastorn> vipex: yes, you get the garbage collector and everything in there
01:21:41 <ksf> and propably not stripped
01:21:49 <vipex> pastorn: what do you mean?
01:21:56 <vipex> almost never compile?
01:21:59 <p_l> vipex: Hello World using iostreams, with old C++ compiler (Cfront) took 1.5M
01:22:01 <vipex> how you do that?
01:22:03 * Zao strips ksf and brings out the gtar and gfeathers.
01:22:22 <pastorn> vipex: GHCi is what's called a REPL (Read-Evaluate-Print-Loop)
01:22:29 <pastorn> so i load my file in ghci
01:22:37 <Zao> :r foo.hs
01:22:38 <Zao> :main
01:22:45 <Zao> -- profit!
01:22:49 <vipex> pastorn: hmmm just interpret it while coding before actualy built (compile) ?
01:22:51 <pastorn> when i've changed my file a little, i want to see if my changes was correct, so i reload it with :r
01:22:53 <Zao> Or is it :l, can never remember.
01:23:04 <ksf> :r is reload
01:23:21 <ksf> I always have to terminals open, one vi and one ghci/shell
01:23:23 <pastorn> vipex: yes, and you can try out your functions in GHCi as well
01:23:33 <pastorn> (not just make sure they typecheck)
01:23:40 <lyndon> unfortunately opengl doesn't play very nicely with ghci
01:23:49 <vipex> ok, i got your idea
01:24:01 <vipex> now what command to load the source in to GHCi?
01:24:08 <pastorn> ghci File.hs
01:24:23 <kulin> anyone know of any good examples for foreign function interface working with c functions of the form "void getPair(int &a, int &b)" or "Pair getPair()" I know how to get primitives out of c code but not anything more complex
01:24:25 <pastorn> then in your file, add "x = 100" on a line
01:24:31 <vipex> ok sory late read your response, i try now
01:24:36 <pastorn> then in GHCi ":r"
01:24:38 <pastorn> x
01:24:50 <Zao> kulin: Last I checked, C didn't have references.
01:24:51 <vipex> no location info
01:25:03 <vipex> how move GHCi to my source path?
01:25:05 <kulin> oh I didn't know that
01:25:28 <Dashkal> gcc has a nasty habit of letting you use c++ constructs in c code
01:25:31 <pastorn> vipex: no clue... you need to add it to your path
01:26:14 <kulin> well the ffi isnt limited to only c is it?
01:26:19 <ksf> -std=C99
01:26:26 <ville> pass -std=xxx -Wall -Wextra -pedantic and it ought to tell you off
01:26:29 <ksf> -pedantic -Wall
01:26:30 <Zao> vipex: :cd ?
01:26:43 <ville> xxx being your preferred standard
01:27:08 <Zao> FFI only speaks a limited number of calling conventions.
01:27:27 <vipex> :cd c:\ == OK
01:27:30 <Zao> Typically, if you want to use C++ classes, you need to conjure a bunch of helper functions.
01:27:32 <vipex> what command for list?
01:27:50 <kulin> i dont want a class as much as i just want to return tuples of a certain size
01:28:02 <Zao> (as the "cplusplus" convention has not existed for ages, as the semantics of it were rather undefined"
01:28:05 <Zao> )
01:28:19 <ksf> getCurrentDirectory >>= getDirectoryContents
01:28:42 <Zao> kulin: Make a helper that puts them into separate function arguments?
01:29:28 <kulin> im not sure that im following you? i have a 3rd party c function which returns a vector with 3 values, and i want to return that to the haskell code
01:29:47 <ksf> c can't return vectors
01:29:47 <kulin> i can deconstruct it to 3 ints, but passing back the 3 ints is throwing me
01:30:02 <Zao> What language are you talking about? It doesn't sound like C.
01:30:03 <pastorn> vipex: wat?
01:30:08 <kulin> well its just a struct
01:30:09 <ksf> it's going to take a *struct and writes to that, most likely
01:30:10 <kulin> Vector3
01:30:15 <vipex> ok now, behind GHCi i succesfully load the Hello.pas using: :l Hello.pas
01:30:23 <vipex> so, there is nothing
01:30:26 <Zao> I really hope that you meant .hs
01:30:28 <pastorn> .pas?
01:30:39 <vipex> hahaha sory
01:30:39 <pastorn> vipex: :p
01:30:41 <vipex> Hello.hs
01:30:42 <vipex> :D
01:30:51 <vipex> i type:
01:30:57 <ksf> it could in principle return a primitive sse vector, though.
01:31:00 <vipex> :l Hello.has
01:31:07 <vipex> Ok, modules loaded: Main
01:31:11 <vipex> so what next?
01:31:11 <ksf> ...at which point the haskell ffi would fail
01:31:13 <pastorn> old habits die hard...
01:31:27 <pastorn> vipex: read above what i said about adding x = ...
01:31:29 <vipex> the code not displayed on GHCi consolse?
01:31:35 <vipex> what command to interpret / run it?
01:31:44 <ksf> just type a function name
01:31:44 <vipex> Hello.hs*
01:31:50 <pastorn> vipex: no, ghci is just typechecking and evaluating stuff when you tell it to
01:31:52 <ksf> you're in a do block
01:32:41 <rothwell> 'lo. are there any better examples of using the "monad" wrapper for Alex? i don't understand the one included example (words_monad.x)
01:32:43 <ksf> ghci also makes for a very, very decent calculator
01:33:49 <vipex> pastorn: oh ok, :r ... hmmm... i got the idea :D
01:33:57 <pastorn> vipex: are you reading some material?
01:34:03 <pastorn> or are you just playing?
01:34:52 <vipex> pastorn: read this chats & just playing :D
01:34:54 <vipex> why?
01:35:06 <kulin> so my best bet for passing back 3 ints would be to malloc the space in a c wrapper function, write the 3 ints to it, and then pass the pointer back to the haskell code? nothing safer?
01:35:14 <vipex> am in *main> now in GHCi :D
01:35:28 <Zao> kulin: alloca and friends help.
01:35:30 <pastorn> vipex: http://en.wikibooks.org/wiki/Haskell
01:35:36 <ksf> kulin, alloc on the haskell side
01:35:41 <pastorn> that has some really good material in there
01:36:07 <ksf> pass that as a struct, copy stuff over in c and then return void
01:36:15 <pastorn> vipex: you should start reading there and trying out the examples
01:36:30 <vipex> pastorn: I already read many of them, I need play something :D
01:36:46 <Zao> withAlloca'd 10 (\p -> do { c_nativeFunc p 10; peekRangeFrom p })
01:36:46 <vipex> ok am start play one by one :)
01:36:47 <ksf> alloca is _really_ fast, so it's not like you would be wasting time.
01:36:49 <ezyang> Is it just me, or does this list seem really incomplete? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26076#a26076 
01:36:51 <Zao> But with proper function names.
01:36:56 <vipex> thank you mates
01:37:05 <ezyang> It's a mapping of Build-tools to Hackage packages that declare them in Cabal. 
01:37:15 <pastorn> vipex: :)
01:37:44 <kulin> i see, thanks zao and ksf
01:37:47 <vipex> pastorn: ;)
01:38:46 <vipex> oh one more thing before i continue playing... is this real programming in haskell need good in math?
01:38:46 <Zao> kulin: There's a bunch of functions in Foreign that probably helps.
01:39:03 <vipex> in fact am average in math
01:39:13 <vipex> is this true*
01:39:13 <ksf> and with a bit of luck gcc will inline the function into your wrapper so there's even less overhead.
01:39:13 <Zao> f :: [a] -> Ptr a -> IO b -- like this
01:39:31 <ksf> you don't need to be good at maths
01:39:31 <lyndon> vipex: It depends what kind of programs you want to write.
01:39:38 <ksf> but you're definitely going to get better at abstract algebra
01:39:41 <Zao> Err, [a] -> (Ptr a -> IO b) -> IO b
01:39:48 <vipex> ksf: I read some article about that lol
01:40:00 <vipex> so it should be find if that isn't tru :D
01:40:02 <vipex> true*
01:40:32 <vipex> lyndon: sure :)
01:40:37 <ksf> .oO( class (Monoid a, Monoid b) => SemiRing a b )
01:41:04 <ksf> wait that's undecidabel.
01:41:45 <ksf> no it's not it's not an instance, after all.
01:41:52 <vipex> this code just confuse me lol: Prelude> let fac n = if n == 0 then 1 else n * fac (n-1)
01:42:09 <ksf> > product [1..4]
01:42:10 <lambdabot>   24
01:42:17 <ksf> @src product
01:42:17 <lambdabot> product = foldl (*) 1
01:42:20 <ksf> @src foldl
01:42:21 <lambdabot> foldl f z []     = z
01:42:21 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:42:25 <lyndon> vipex: It looks a lot nicer when it's written in pattern matching style.
01:42:38 <pastorn> vipex: in haskell you can't have if without else
01:42:53 <vipex> lyndon: wattaa... what is pattern matching style? :((
01:43:03 <ksf> let fac 0 = 1
01:43:09 <pastorn> vipex: the code always needs another way to go in case the Bool is false
01:43:12 <ksf> ...without the let
01:43:26 <ksf> fac n = n * fac (n - 1)
01:43:49 <ksf> oh, fac n | n > 0
01:44:04 <ksf> fac n | otherwise = error "negative?"
01:44:30 <vipex> pastorn: i see
01:44:50 <vipex> ksf: your code never stopped my processor its 50%... now :((
01:44:51 <vipex> lol
01:45:07 <vipex> how to break current process in GHCi?
01:45:10 <vipex> what command?
01:45:14 <Zao> Ctrl-C?
01:45:15 <pastorn> CTRL+c
01:45:20 <vipex> not work
01:45:29 <vipex> oh ok,
01:45:38 <vipex> it's late in response :D
01:46:10 <vipex> typing u'r code: let fac n = n * fac(n-1)
01:46:13 <vipex> fac 64
01:46:16 <lyndon> vipex: like this http://gist.github.com/434258
01:46:21 <vipex> .................................. 
01:46:25 <ksf> you need the fac 0 = 1 case
01:46:32 <ksf> otherwise there's no terminating condition
01:46:41 <vipex> yeah i just trying anything you said lol
01:47:16 <ksf> and fac 0 = 1 has to be on top of fac n = ..., patterns are matched in order of definition.
01:47:55 <vipex> lyndon: factorial pattern matching ---> I don't see where the pattern :(
01:48:05 <vipex> completely confusing me haha
01:48:19 <kulin> pattern is 0
01:48:24 <ksf> "0" and "n" is the pattern
01:49:01 <ksf> where 0 obviously only matches 0, and n matches everything because it's a variable
01:49:13 <ksf> ...which is then bound on the rhs of the =
01:50:04 <ksf> :t S
01:50:05 <lambdabot> Not in scope: data constructor `S'
01:50:26 <ksf> @data Nat = S Nat | Z
01:50:27 <lambdabot> Unknown command, try @list
01:50:29 <ksf> hmmm
01:50:31 <bastl> how can I convert "ceiling $ logBase 2 $ i" to type Int ?
01:50:40 <ksf> lambdabot's lacking a feature, /me things
01:50:52 <bastl> > ceiling $ logBase 2 $ 16
01:50:52 <ksf> bastl, there's more than one way to rome
01:50:52 <lambdabot>   4
01:51:01 <ksf> :t ceiling
01:51:03 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
01:51:23 <ksf> round, ceiling etc. all yield integral types
01:51:25 <kulin> wow alloca is awesome
01:51:27 <vipex> ksf: hmm i see, got the point
01:51:28 <ksf> ...and Int is one of them
01:51:42 <ksf> :t properFraction
01:51:43 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
01:51:45 <Veinor> > (ceiling . logBase 2 $ 16) :: Int
01:51:47 <lambdabot>   4
01:51:53 <bastl> Veinor: thanks
01:51:56 <lyndon> vipex: It might be worth comparing how factorial would be written in a language you are familliar with, to how it is written in haskell. Keep in mind you probably want to look at a recursive solution in both.
01:52:35 <Veinor> so it'll be an Int if you need it to be one
01:52:55 <vipex> lyndon: TRUE
01:53:00 <ksf> forM_ [1..n] $ \n -> modify (+n)
01:53:05 <bastl> but ghc tells me, No instance RealFrac Int
01:53:13 <ksf> :t forM_ [1..n] $ \n -> modify (+n)
01:53:14 <lambdabot> forall (m :: * -> *). (MonadState Expr m) => m ()
01:53:20 <Veinor> bastl: could you post your code?
01:53:24 <ivanm> bastl: well, yeah, because integers aren't floating point...
01:53:25 <ksf> :t \n -> forM_ [1..n] $ \n -> modify (+n)
01:53:26 <lambdabot> forall (m :: * -> *) s. (Num s, Enum s, MonadState s m) => s -> m ()
01:54:03 <Veinor> using hpaste or something.
01:54:08 <bastl> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26077#a26077
01:54:28 <bastl> any simpler way would do too :-)
01:54:53 <Veinor> what exactly are you trying to do?
01:55:04 <bastl> convert a bitstring to int
01:55:09 <bastl> very very basic.
01:55:26 <bastl> (and BTW learning to fold)
01:55:32 <Veinor> so you want an f such that f [1,0] = 2, f [1,0,0] = 4, f [1,1,0] = 6, etc?
01:55:38 <bastl> yes
01:56:11 <Veinor> I think that's a one-liner
01:56:14 <bastl> thats so damn easy, but i dont know the "right" way to implkement it
01:56:20 <bastl> i guessed so
01:56:24 <ksf> :t let fac = execState . State $ \n -> forM_ [1..n] $ \n -> modify (*n) in fac 4
01:56:25 <lambdabot>     No instance for (Num ())
01:56:25 <lambdabot>       arising from the literal `1' at <interactive>:1:43
01:56:25 <lambdabot>     Possible fix: add an instance declaration for (Num ())
01:56:40 <ksf> :t let fac = execState . State $ \n -> forM [1..n] $ \n -> modify (*n) in fac 4
01:56:41 <lambdabot>     No instance for (Enum [()])
01:56:41 <lambdabot>       arising from the arithmetic sequence `1 .. n'
01:56:41 <lambdabot>                    at <interactive>:1:41-46
01:56:47 <kulin> it would have to keep track of place though
01:56:48 <Veinor> now I just have to figure out what it is
01:56:51 <kulin> so that is somewhat interesting
01:57:08 <Ferdirand> > zipWith (*) (iterate (*2) 1) . reverse $ [1,1,0]
01:57:10 <lambdabot>   [0,2,4]
01:57:19 <Ferdirand> > sum . zipWith (*) (iterate (*2) 1) . reverse $ [1,1,0]
01:57:20 <lambdabot>   6
01:57:21 <bastl> Veinor: I think you can put my code on one line. I jsut expanded it to see the signatures etc
01:57:33 <kulin> fancy
01:57:44 <ksf> :t let fac n = execState . State . forM [1..n] $ \n -> modify (*n) in fac 4
01:57:45 <lambdabot>     Couldn't match expected type `(a, s)' against inferred type `[b]'
01:57:45 <lambdabot>     In the second argument of `(.)', namely `forM ([1 .. n])'
01:57:45 <lambdabot>     In the second argument of `(.)', namely `State . forM ([1 .. n])'
01:57:47 <aristid> @src iterate
01:57:47 <lambdabot> iterate f x =  x : iterate f (f x)
01:57:59 <aristid> @pl iterate f x =  x : iterate f (f x)
01:57:59 <lambdabot> iterate = fix ((ap (:) .) . ((.) =<<))
01:58:04 <aristid> lol!
01:58:04 <Veinor> > let f = foldr (\x y -> x + 2 * y) 0 . reverse in [f [1,0,0], f [0,1,1,0,0]]
01:58:06 <lambdabot>   [4,12]
01:58:26 <ksf> :t let fac n = execState . forM [1..n] $ \n -> modify (*n) in fac 4
01:58:27 <lambdabot> forall t. (Enum t, Num t) => t -> t
01:58:32 <Veinor> that's not efficient though because reverse is slow
01:58:39 <ksf> :t let fac n = execState . forM [1..n] $ \n -> modify (*n) in fac
01:58:40 <lambdabot> forall s. (Num s, Enum s) => s -> s -> s
01:59:05 <Ferdirand> but you cannot know the length of the list until you iterate over it, right ?
01:59:10 <Veinor> > let f = foldl (\x y -> 2 * x +  y) 0 in [f [1,0,0], f [0,1,1,0,0]]
01:59:11 <lambdabot>   [4,12]
01:59:23 <ksf> the state monad sucks
01:59:52 <Veinor> you don't need to know the length in advance though
02:00:06 <Ferdirand> right, you must multipy the accumulator then
02:00:12 <bastl> funny, if I leave out all the type sigs from my code it works ...
02:00:15 <aristid> Veinor: shouldn't you use foldl' there?
02:00:41 <pastorn> how do i find out the size of my terminal?
02:00:55 <pastorn> @hoogle IO (Int,Int)
02:00:55 <lambdabot> System.Random genRange :: RandomGen g => g -> (Int, Int)
02:00:55 <Veinor> yeah, you should use foldl'
02:00:55 <lambdabot> Prelude floatRange :: RealFloat a => a -> (Int, Int)
02:00:55 <lambdabot> Data.Time.Calendar.OrdinalDate mondayStartWeek :: Day -> (Int, Int)
02:01:00 <ksf> pastorn, vty?
02:01:03 <pastorn> @hoogle IO (Word,Word)
02:01:03 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
02:01:03 <lambdabot> Data.Array.MArray getBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)
02:01:03 <lambdabot> Data.Array.IArray bounds :: (IArray a e, Ix i) => a i e -> (i, i)
02:01:08 <Veinor> bastl: it's because  ix doesn't have the type Int -> Int
02:01:16 <pastorn> ksf: isn't there an environment thing?
02:01:16 <aristid> > foldl' (flip (:)) [1,2,3]
02:01:17 <lambdabot>   Overlapping instances for GHC.Show.Show ([b] -> [b])
02:01:18 <lambdabot>    arising from a use ...
02:01:20 <Veinor> @type ceiling . logBase 2
02:01:21 <lambdabot> forall a b. (RealFrac a, Integral b, Floating a) => a -> b
02:01:23 <ksf> pastorn, hell no
02:01:25 <Veinor> it has that type
02:01:27 <aristid> > foldl' (flip (:)) [] [1,2,3]
02:01:28 <lambdabot>   [3,2,1]
02:01:31 <ksf> the size can change during runtime
02:01:37 <ksf> it's a terminal emulator thing
02:02:01 <bastl> Veinor: and that was my initial question :-)
02:02:06 <aristid> foldr f x . reverse = foldl (flip f) x
02:02:09 <Veinor> ahh
02:02:10 <aristid> if i got this right
02:02:10 <pastorn> ksf: geometry :: (Read  i, Integral  i) => IO  (i, i)
02:02:13 <pastorn> it was is haha
02:02:30 <Jonno_FTW> hi
02:02:47 <Veinor> you can't pass an integer to logBase 2
02:03:18 <ksf> I've once seen a nice integer log on the cafe, that should be in the standard libraries
02:03:39 <bastl> > ceiling $ logBase 2 $ 0
02:03:40 <lambdabot>   -17976931348623159077293051907890247336179769789423065727343008115773267580...
02:03:42 <Jonno_FTW> is there an efficient way to convert a list of strings into  list of ints?
02:03:45 <bastl> whats that ?
02:03:52 <aristid> :t logBase
02:03:53 <lambdabot> forall a. (Floating a) => a -> a -> a
02:03:58 <Veinor> > logBase 2 $ 0
02:03:59 <lambdabot>   -Infinity
02:04:05 <bastl> ah
02:04:07 <Jonno_FTW> . logBase 2 1
02:04:13 <Jonno_FTW> > logBase 2 1
02:04:14 <lambdabot>   0.0
02:04:14 <Axman6> Jonno_FTW: map read? :\
02:04:33 <Jonno_FTW> oh right, forgot about that one
02:04:34 <aristid> bastl: the logarithm of zero is undefined :)
02:04:52 <bastl> aristid. sure:  -Infinity 
02:04:54 <Veinor> well, it's 'defined' to be negative infinity
02:05:03 <Veinor> speaking of, how can I embed that value in my program?
02:05:10 <Veinor> -Infinity doesn't work, for obvious reasons
02:05:31 <aristid> Veinor: i think mathematically, -Infinity is merely the limit of the expression
02:05:44 <aristid> > -1/0
02:05:45 <lambdabot>   -Infinity
02:06:12 <ksf> > 0/0
02:06:13 <lambdabot>   NaN
02:06:15 <ksf> > -0/0
02:06:16 <lambdabot>   NaN
02:06:29 <ksf> now that's the principle of least surprise...
02:06:34 <Veinor> I guess you could just let infinity = 1/0
02:06:47 <aristid> :t -1/0
02:06:48 <lambdabot> forall a. (Fractional a) => a
02:06:56 <aristid> sure
02:07:10 <Veinor> if you needed to reference it
02:08:53 <vipex> following your disccussion, it seems everything is math :D
02:09:44 <ksf> alex: src/Yi/Lexer/Haskell.x: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
02:10:24 <ksf> hmmm
02:10:41 <ksf> actually, I shouldn't complain about haskell but about yi or something else
02:10:54 <ksf> ...gvim doesn't grok those characters, either
02:11:44 <int-e> > ceiling (1/0) == 2^1024
02:11:45 <lambdabot>   True
02:12:28 <int-e> > ceiling (1/0 :: Float) == 2^128
02:12:28 <lambdabot>   True
02:12:42 <int-e> :/
02:12:45 <pettter> what
02:13:13 <pettter> > 1/0
02:13:14 <lambdabot>   Infinity
02:13:26 * ksf thinks alex and happy should be retired
02:13:30 <ksf> ...as soon as possible
02:13:41 <Veinor> > ceiling (1/0) == 2^1024 - 1
02:13:42 <lambdabot>   False
02:13:44 <int-e> that's what you get if you interpret infinities as normal IEEE 754 floating point numbers. (Lesson: You should not do that.)
02:13:47 <ksf> it's perfectly sensible to use a dsl
02:13:55 <Veinor> > ceiling (1/0 :: Float) == 2^128 - 1
02:13:56 <lambdabot>   False
02:14:19 <int-e> > ceiling (1/0 - 1/0) > ceiling (1/0)
02:14:20 <lambdabot>   False
02:14:34 <int-e> > ceiling (-1/0 - 1/0) < ceiling (-1/0)
02:14:34 <lambdabot>   False
02:14:40 <Veinor> > ceiling (1/0 - 1/0)
02:14:41 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
02:14:46 <int-e> > ceiling (-1/0 + 1/0) < ceiling (-1/0)
02:14:47 <Veinor> > 1/0 - 1/0
02:14:47 <lambdabot>   True
02:14:47 <lambdabot>   NaN
02:14:48 <pettter> well, IEEE754 defines bit patterns for infty/NaN etc. doesn't it?
02:14:51 <int-e> my bad.
02:15:04 <pettter> by the way, 1/0 should be NaN, not infy
02:15:06 <Axman6> pettter: yeah
02:15:06 <pettter> *infty
02:15:10 <int-e> pettter: right. (not so much for NaN - it allows many representations)
02:15:10 <ksf> there's a shitload of different NaNs
02:15:11 <Veinor> sometimes #haskell talks about type theory and endomorphisms. and sometimes we play around with infinity
02:15:30 <int-e> pettter: they distinguish -0 from +0. But they are equal.
02:15:45 <ksf> and sometimes we make fun of at least php and c++
02:16:03 <pettter> int-e: that also sounds wrong somehow
02:16:37 <pettter> And how do you distinguish between them if they are equal?
02:16:40 <vipex> emm.. may I ask one think? what different procedurall programming and functional programming?
02:17:04 <ksf> in functional programming, everything is an expression, even statements.
02:17:12 <kulin> that was really painless to get 3 ints out of c, thanks again ksf and zao, but it seems like whenever i make progress, it is also bedtime :(
02:17:22 <Axman6> vipex: in procedutal programming, you give a list of instructions on how to do things. in functional programming, you tell the computer what to do, and it decides how to do it
02:17:37 <Axman6> kulin: it is always so :(
02:18:06 * hackagebot properties 0.0.2 - check quickCheck properties in real time.  http://hackage.haskell.org/package/properties-0.0.2 (AlbertoCorona)
02:18:14 <int-e> pettter: they have different bit representations, but if you compare them (==), the result will be that they are equal.
02:18:27 <vipex> what about code structure? it's equal with procedural or something else?
02:18:43 <ksf> usuall not at all
02:18:54 <pettter> int-e: in that case they are not distinguished, they are equal, but the number 0 has several representations
02:19:00 <pastorn> vipex: haskell is very value-driven, not state 
02:19:02 <ksf> vipex, http://www.cs.chalmers.se/~rjmh/Papers/whyfp.pdf
02:19:03 <pastorn> *state-driven
02:19:10 <pettter> one with sign + and one with sign -
02:19:14 <pastorn> ksf: borked
02:19:19 <int-e> pettter: they are distinguished though
02:19:27 <pastorn> all of ch.chalmers.se is pretty borked
02:19:37 <pettter> if you get the sign bit?
02:19:50 <int-e> > (1/(-0), 1/0)
02:19:51 <lambdabot>   (-Infinity,Infinity)
02:20:02 <pastorn> vipex: you can't do stuff like x++ or --x in haskell, instead you define
02:20:12 <pastorn> inc x = x + 1
02:20:15 <pastorn> dec x = x - 1
02:20:16 <pettter> again, a/0 is NaN, not infinity
02:20:16 <ksf> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.100.8004
02:20:37 <Axman6> vipex: functional programming is much more like maths, there is no state
02:20:44 <vipex> hmm isn't built-in operators?
02:20:49 <int-e> pettter: IEEE 754 disagrees. I don't want to argue whether that was a smart decision or not.
02:21:10 <Axman6> vipex: x++ doesn't make any sense in maths does it?
02:21:11 <ksf> vipex, you can structure your program procedurally when using fp, but why would you want to use a style that inevitably leads to more bugs?
02:21:16 <vipex> Axman6: dead me... am bad in math :(
02:21:20 <pettter> int-e: OK, in that case my memory has failed me :)
02:21:45 <pastorn> vipex: in haskell you'll write lots of code that in C would be something like f(int x) { if (x == y) {return y + x;} else { return f(x-1);}
02:22:17 <vipex> Axman6: True
02:22:19 <Axman6> pastorn: what a horrible example :P
02:22:28 <pastorn> vipex: but in haskel the 'return' part is implicit, so you don have to think about it
02:22:37 <pastorn> Axman6: you're a horrible exapmle!
02:23:11 <pastorn> s/think about/write
02:24:02 <vipex> the last think* is the return value?
02:24:21 <triyo> n00b question. Could someone please explain to me the difference between foldl and foldr. (I know that the accumulation happens left-to-right and right-to-left respectively. My question is more why and which one to use when.)
02:25:59 <triyo> Also does foldr perform better than foldl and why
02:26:29 <ksf> arrr it all depends
02:26:40 <Axman6> triyo: you'd generally use foldr when you need to make use of laziness (like concat = foldr (++) []), and foldl when you want to work in 'constant' space. (in my experience anyway. and in general, you want to use foldl' instead of foldl for almost all cases)
02:26:43 <ksf> http://www.haskell.org/haskellwiki/Fold
02:27:08 <Linnk> triyo: there is a pretty good explanation here http://learnyouahaskell.com/higher-order-functions
02:27:21 <vipex> give me some example in haskell said reserve a text
02:27:26 <Axman6> > foldl f x [a,b,c]
02:27:26 <lambdabot>   f (f (f x a) b) c
02:27:29 <vipex> vipex = xepiv
02:27:30 <Axman6> > foldr f x [a,b,c]
02:27:31 <lambdabot>   f a (f b (f c x))
02:27:59 <Axman6> > reverse "vipex"
02:28:00 <lambdabot>   "xepiv"
02:28:10 <blackdog> damn, non-hashed darcs repos are slower than a wet week in canberra
02:28:16 <vipex> :D its already built-in? damned :))
02:28:21 * Axman6 glares at blackdog 
02:28:21 <Dashkal> :t (:)
02:28:22 <lambdabot> forall a. a -> [a] -> [a]
02:28:35 <Axman6> vipex: strings are just lists
02:28:49 * blackdog gives axman6 a big, shit-eating grin.
02:28:51 <Axman6> > ['v','i','p','e','x']
02:28:52 <lambdabot>   "vipex"
02:28:53 <vipex> tring in GHCi... lol its true  :))
02:29:17 <blackdog> Axman6: i actually rather enjoyed my three days in canberra.
02:29:20 * Axman6 bans blackdog from hacking at AusHac, but demands attendance and silence
02:29:24 <blackdog> was good to be resurrected at the end, though.
02:29:42 <vipex> lambdabot: what's that? its reversing funct?
02:29:50 <blackdog> heh. i'm just blackh's chauffeur, then?
02:30:04 <Axman6> yes
02:30:06 <blackdog> meaning to ask - you got an ICFP team together yet?
02:30:18 <blackdog> is no fun hacking solo
02:30:18 <Axman6> no, it's in the middle of my exams
02:30:27 <blackdog> well, your course is clear
02:30:39 * blackdog is carefully ambiguous
02:30:42 <ksf> triyo, http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'  is even better
02:30:43 <Axman6> heh
02:30:56 <triyo> ksf: thx
02:31:24 <Axman6> triyo: figuring out when to use which comes with experience
02:32:51 <vipex> need restart, out for a while...
02:39:06 <jaffa4> hi
02:39:20 <jaffa4> I have a problem I am trying to setup a package and I cannot
02:43:10 <noteed> jaffa4: you can describe your problem; if someone can help, he/she'll answer
02:43:58 <jaffa4> I am trying to install pugs
02:44:07 <jaffa4> I used cabal install pugs
02:44:34 <jaffa4> It fails to compile a dependency pugs-compat
02:44:45 <jaffa4> I am trying to install pugs-compat myself
02:44:55 <jaffa4> I am trying to fix it
02:45:15 <jaffa4> So I downloaded it into a directory
02:45:36 <jaffa4> I issued runhaskell Setup.lhs configure --ghc
02:46:11 <jaffa4> I get an error message: dependencies are missing regex-pcre-builtin -any, stringtable-atom >=0.0.6.1
02:47:12 <noteed> wasn't there any specific error message when it failed on pugs-compat (when cabal install pugs)?
02:47:25 <jaffa4> yes
02:47:45 <jaffa4> src\Pugs\Compat\Posix.hs:203:12: Not in scope: `c_opendir'
02:47:53 <jaffa4> I am on Windows
02:48:24 <jaffa4> It is not clear for me if System.Posix.Internals contains that function on Windows
02:48:37 <jaffa4> according to the documentation
02:48:49 <jaffa4> System.Posix.Internals is defined on all platforms
02:48:56 <jaffa4> I am not sure what defined means.
02:49:19 <jaffa4> I thought defined means that c_opendir is available on Windows too
02:49:26 <jaffa4> so that error should not occur.,
02:49:32 <jaffa4> yet it happens.
02:52:21 <jaffa4> Ok i have two problems
02:52:56 <jaffa4> 1. How do I modify a package on my machine and install it.
02:52:56 <pettter> jaffa4: lucky you
02:53:08 <ksf> windows' posix support is a joke
02:53:32 <ksf> cabal unpack <name>, cd <dir>, vi etc, cabal install
02:54:15 <jaffa4> let me try that
02:54:49 * ksf thinks there should be an additional local-version field that you can increment when you mess around with packages
02:55:05 <ksf> ...one that is'nt exposed to hackage
02:55:40 <ksf> hrm yi hackability seems to approach zero, yet again
02:56:19 <ksf> I think there's just too much code in it
02:56:27 <jaffa4> when I say runhaskell Setup.lhs configure
02:56:30 <jaffa4> I get errors
02:56:31 <ksf> xmonad did that right with core
02:56:46 <ksf> jaffa4, hpaste.org
02:58:11 <jaffa4> http://paste.org/pastebin/view/19604
02:58:32 <jaffa4> the problem is those depencies are not missing
02:58:40 <jaffa4> runhaskell is stupid.
02:59:46 <ksf>  you pass --user?
02:59:57 <ksf> otherwise it's only looking at the global database
02:59:59 <jaffa4> ???
03:00:18 <ksf> hmm I don't know how they deal with that on windows
03:00:36 <jaffa4> what do you mean by pass - user?
03:00:58 <ksf> runhaskell Setup.lhs configure --user
03:01:30 <ksf> try ghc-pkg list stringtable-atom   , it should show which database it's registered in.
03:02:17 <ksf> Setup.lhs, unlike the cabal command, by default assumes that you want to do a global install and thus things can only depend on globally installed packages
03:05:17 <Baughn> ksf: That seems somewhat inconsistent, doesn't it?
03:05:31 <ksf> yes
03:05:51 <ksf> but then a) I didn't do that and b) Setup.hs isn't supposed to be a end-user interface
03:06:34 <jaffa4> What should I use then?
03:06:52 <ksf> cabal the command line program
03:07:00 <ksf> ...package "cabal-install"
03:07:19 <jaffa4> and how do I modify the package?
03:07:29 <ksf> you edit it?
03:07:39 <jaffa4> yes
03:18:17 <jaffa4> I get to the second state install
03:18:26 <jaffa4> but then I get another error
03:19:22 <jaffa4> -> Setup.lhs: Error: Could not find module: Pugs.Compat with any suffix: ["hi"]
03:23:31 <ksf> looks like they're using a custom setup.hs and something's failing
03:23:49 <ksf> you might want to ask the pugs guys, whereever they are
03:23:53 <vipex> since im very noob in haskell i would ask about monads
03:23:55 <ksf> (and still exist)
03:23:56 <vipex>  monads is a concept?
03:24:02 <ksf> it's an abstraction
03:24:12 <ksf> so, yes.
03:24:24 <vipex> monads is haskell's built-in stuff?
03:24:28 <pastorn> vipex: there's a nice video lecture called "Don't fear the monads"
03:24:43 <vipex> is monads a library or what
03:24:45 <pastorn> vipex: no, Monads is a typeclass defined in the language
03:24:47 <ksf> it's an abstraction along the same lines as calling everything that has operators resembling + and * and behaves like you'd expect a "semiring"
03:25:05 <pastorn> vipex: think of it like a powerful way of doing java interfaces... sort of...
03:25:48 <pastorn> vipex: you probably need to play aroud a little with the haskell type system before you dive into using them... create your own types and maybe a typeclass or two
03:25:57 <ksf> and among many other things, monads also capture the notion of imperative (procedural) programming
03:26:09 <ksf> yep
03:26:29 <ksf> for know, I'd recommend a tutorial that concentrates on just using IO, without mentioning the word "monad"
03:26:33 <sepp2k> pastorn: The "it" in "think of it..." means typeclasses right? Because it sounds as if it meant monads, which is maybe a bit confusing.
03:26:34 <ksf> -k
03:26:54 <ksf> sepp2k, well, monad transformers form a monad
03:27:14 <pastorn> ksf: http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads/
03:27:17 <pastorn> whoop
03:27:19 <pastorn> vipex: ^^^^^
03:27:25 <pastorn> sepp2k: yes :/
03:27:36 <vipex> ok, need finding it my self :)
03:27:47 <ksf> which is slighly confusing because that's then an abstraction of an abstraction of an abstraction of an abstraction
03:28:04 <vipex> damned damned damned ... haskell really confusing me haha
03:28:08 <ksf> ...and one needs to be an abstract nonsensist to grok that kind of stuff.
03:28:12 <pastorn> vipex: but start playing around with the haskell types...
03:28:25 <vipex> downloading tutorial video...
03:28:28 <pastorn> and do some error recovery through the Maybe type etc.
03:29:00 <ksf> or some non-deterministic programming with the list monad
03:29:04 <pastorn> vipex: but really, this might be a bit much if you just wrote hello world 90 minutes ago....
03:30:05 * ksf went for http://ertes.de/articles/monads.html  as introductory tutorial in "what monads are not"
03:30:08 <vipex> :D 
03:30:34 <ksf> vipex, it's perfect for people not caring for abstract algebra and not coming from other fp languages
03:31:27 <pastorn> vipex: even so, you should still be comfortable with pattern-matching and let ... in... syntax before trying...
03:31:43 <pastorn> otherwise you risk just getting confused and frustrated :/
03:32:41 <vipex> ok i'll start in real world
03:33:21 <ksf> actually, you should try to understand zygohistomorphic prepromorphisms, first.
03:33:22 <vipex> pattern-matching = never encountered in programming usually
03:33:37 <vipex> zygohistomorphic prepromorphisms = what is this :))
03:33:39 <ksf> it like case switches on steroids
03:33:44 <ksf> wait that's c
03:33:58 * ksf tries to recall whether pascal has something like that
03:34:08 * Zao huggles given-when in Perl.
03:34:08 <ksf> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
03:34:09 <vipex> your term never happend in conventional programming lol
03:34:20 <Zao> It's hard reading Perl when you keep mapping . to composition.
03:34:50 <pastorn> Zao: how does it work in perl?
03:35:05 <ksf> the idea to get from that is that there's no need to understand all that stuff because it's not what programmers, but crazy mathematitians do.
03:35:24 <aristid> ksf: "zyghistomorphic prepomorphism" is the exact opposite linguistically of "warm fluffy thing" :P
03:35:32 <ksf> the haskell community is, more or less, split into hackers, mathematitians, and both.
03:35:50 <vipex> wow
03:36:22 <zenzike> what's the best way to get escaped keys from user input? I'm guessing that getChar can't detect keys like Ctrl-k?
03:37:07 <vipex> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms --> absolutely haven't idea what they're talking about :( (or am too stupid)
03:37:57 <vipex> :D
03:38:27 <aristid> roconnor seems to be the author
03:38:32 <aristid> preflex: seen roconnor
03:38:32 <preflex>  roconnor was last seen on #haskell 2 hours, 24 minutes and 23 seconds ago, saying: vipex: notepad
03:38:51 <ksf> the problem with category theory is that it's usually way too abstract to make sense of when you don't have any concrete examples to apply it to
03:38:57 <mreh> where does Debug.Trace.trace go to? Stderror?
03:39:26 <Zao> pastorn: . is string concatenation.
03:39:44 <ksf> ...to become a category theorist, one has to work through pages and pages of examples and chase thousands of diagrams and write even more proofs until you grok it.
03:40:14 <ksf> so it's best to just ignore them.
03:40:30 <aristid> ksf: i suppose very few mathematicians elect to become category theorists rather than something else.
03:41:03 <jaffa4> >>= pipeping!!!!!!!!!
03:41:55 <mreh> category theory is completely useless to most people I thought :)
03:42:01 <mreh> it's too general
03:42:44 <aristid> why is it so useful to programming languages in particular?
03:42:56 <ksf> it's not
03:43:11 <ksf> a heck of other fields use it, too.
03:43:22 <ksf> although all that graph theory is used much in cs
03:43:57 <dafis> mreh: No, a little bit of category theory everybody needs.
03:44:18 <dafis> Can't do mathematics nowadays without knowing what functors are.
03:45:05 <dafis> aristid: It's particularly useful for language designers
03:45:24 <Generalskip> hi all
03:45:32 <Generalskip> anyone not asleep here?
03:45:34 <dafis> hi Generalskip
03:45:51 <Generalskip> hey 
03:45:58 <aristid> Generalskip: why should we be asleep?
03:46:03 <aristid> it's noon!
03:46:04 <vipex> how you guys start with haskell? it's completely confusing you? how many times you need to comfort with haskell?
03:46:08 <Generalskip> well it is early hehhe
03:46:14 <aristid> no it's not :)
03:46:21 <Generalskip> u know thursday parties, hangovers
03:46:29 <pastorn> vipex: just try following some book or the other
03:47:07 <Generalskip> Guys and girls..... i need some help with building something on the web, programming, software devel...  database....
03:47:12 <Generalskip> anyone interested ?
03:47:26 <aristid> hmm my mind is somehow jumping around pretty randomly :D
03:47:42 <aristid> now i wonder which abstractions lend themselves to code generation
03:47:51 <ksf> some frustration while having the compiler reject your code without you understanding the type errors is quite inevitable, but that goes away once it compiles and you notice that it runs bug-free right away.
03:48:00 <ksf> the important thing is not to go too fast
03:48:14 <aristid> ghci is the best friend.
03:48:16 <vipex> yeah
03:48:23 <Generalskip> hmmm maybe i`m in the wrong channel
03:48:39 <ksf> there's a lot of very advanced material around that can distract 
03:48:58 <byorgey> Generalskip: this channel is for discussion of the Haskell programming language.
03:49:02 <Generalskip> anyone here wanna do a job for me ?
03:49:15 <zygoloid> that's probably quite unlikely
03:49:23 <zygoloid> unless you pay well :)
03:49:25 <ksf> but once you're comfortable freely juggling functions, the road ceases to be stony
03:49:35 <ksf> or, well, you at least know stones to be stones.
03:49:42 <pastorn> vipex: there are many good and freely available books: http://book.realworldhaskell.org/read/ http://learnyouahaskell.com/ http://en.wikibooks.org/wiki/Haskell
03:49:50 <Generalskip> byorgey   i pay well for job well done 
03:49:57 <ksf> Generalskip, let me guess, a facebook clone?
03:49:59 <pastorn> vipex: i suggest you pick one and start reading
03:50:13 <Generalskip> where do i go to meet someone ? like seriouss job offer 
03:50:30 <vipex> am going hunting'em now :)
03:51:08 <pastorn> vipex: if you have experience with c and pascal and have written some non-trivial stuff, then RWH is good
03:51:29 <vipex> RWH?
03:51:29 <pastorn> LYAH is little more beginner friendly (as has nice pictures!)
03:51:29 <byorgey> Generalskip: no idea.  try doing a Google search for "web development".
03:51:37 <pastorn> vipex: Real World Haskell
03:51:41 <Generalskip> ooook, i`ll look elsewhere  thnx guys have a nice day
03:52:18 <pastorn> vipex: i personally like WB because the articles are very consice (and most have some exercises)
03:53:33 <vipex> WB? sorry my head stacked
03:53:40 <byorgey> vipex: feel free to ask questions on here, and also you will probably learn a lot by signing up to the haskell beginners mailing list and asking questions there or just reading the messages on the list
03:53:50 <dafis> vipex: wikibook
03:53:53 <byorgey> @where beginners
03:53:54 <lambdabot> I know nothing about beginners.
03:53:58 <pastorn> vipex: RWH = Real World Haskell; LYAH = Learn You A Haskell; WB = WikiBooks
03:54:16 <pastorn> hahahahhaha
03:54:19 <pastorn> byorgey: NICE
03:54:56 <byorgey> @where+ beginners http://haskell.org/mailman/listinfo/beginners
03:54:56 <lambdabot> It is stored.
03:55:01 <byorgey> @where beginners
03:55:01 <lambdabot> http://haskell.org/mailman/listinfo/beginners
03:55:04 <vipex> many thanks mates, I was so touched :D
03:55:45 <byorgey> @vixen how can you not know anything about beginners?
03:55:46 <lambdabot> of course i can
03:55:59 <byorgey> evasive as usual
03:56:18 <aristid> @faq beginners
03:56:19 <lambdabot> The answer is: Yes! Haskell can do that.
03:56:36 <aristid> @faq Does Haskell support DT?
03:56:36 <lambdabot> The answer is: Yes! Haskell can do that.
03:56:40 <aristid> LIAR
03:56:58 <byorgey> aristid: Conor McBride would disagree with you ;-)
03:57:04 <vipex> haha
03:57:07 <aristid> byorgey: huh?
03:57:33 <byorgey> http://personal.cis.strath.ac.uk/~conor/pub/she/
03:57:34 <jaffa4> I have question
03:57:39 <jaffa4> g $ 1 2 3 4
03:57:52 <jaffa4> is it g (1 2 3 4)?
03:57:53 <vipex> wait wait, i need archive this chat lol
03:57:57 <byorgey> jaffa4: yes
03:57:57 <ksf> yes
03:58:06 <ksf> or rather almost 
03:58:09 <ksf> it's a precedence trick
03:58:14 <byorgey> jaffa4: but that will be an error because it is trying to apply 1 to 2
03:58:16 <ksf> @src ($)
03:58:16 <lambdabot> f $ x = f x
03:58:17 <byorgey> and 1 is not a function
03:58:19 <aristid> > g $ 1 2 3 4
03:58:20 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:58:20 <lambdabot>    `GHC.Show.Show b'
03:58:20 <lambdabot>      a...
03:58:29 <aristid> :t g $ 1 2 3 4
03:58:30 <lambdabot> forall b. (SimpleReflect.FromExpr b) => b
03:58:41 <aristid> :t g
03:58:42 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
03:58:46 <byorgey> vipex: it is already archived!
03:58:49 <aristid> :t (1 2 3 4)
03:58:50 <lambdabot>     Ambiguous type variable `t' in the constraint:
03:58:50 <lambdabot>       `Num t' arising from the literal `4' at <interactive>:1:7
03:58:50 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
03:58:52 <sepp2k> byorgey: It can be with the right Num instance...
03:59:04 <byorgey> @where logs
03:59:04 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
03:59:09 <byorgey> vipex: ^^^
03:59:22 <aristid> why does lambdabot accept :t g $ 1 2 3 4?
03:59:30 <byorgey> sepp2k: well, yes =)
03:59:57 <dafis> aristid: because lambdabot has weird Num instances
03:59:58 <vipex> oh mine haha dunnot bout that, i never use IRC previously lol
03:59:59 <aristid> byorgey: oh, cool a preprocessor for adding partial DT?
04:00:03 <byorgey> aristid: lambdabot uses a special library which lets it reify expressions
04:00:12 <byorgey> aristid: indeed =)
04:00:21 <aristid> byorgey: it doesn't accept (1 2 3 4) isolated, which is confusing
04:00:24 <byorgey> > g a b c
04:00:25 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:00:25 <lambdabot>    `GHC.Show.Show a'
04:00:25 <lambdabot>      a...
04:00:35 <byorgey> > g a b c :: Expr
04:00:36 <aristid> > g 1
04:00:37 <lambdabot>   g a b c
04:00:37 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:00:37 <lambdabot>    `SimpleReflect.FromExpr ...
04:00:50 <aristid> > (1 2 3 4) :: Expr
04:00:51 <lambdabot>   1
04:00:59 <aristid> ooh
04:01:04 <byorgey> aristid: it is a bit confusing, yes
04:01:04 <aristid> strange stuff going on
04:01:14 <byorgey> @where SimpleReflect
04:01:14 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
04:01:18 <byorgey> that's the library it uses
04:01:43 <byorgey> it's nice for illustrating folds and such
04:01:50 <byorgey> > fold f z [a,b,c] :: Expr
04:01:51 <lambdabot>   Not in scope: `fold'
04:01:55 <byorgey> > foldr f z [a,b,c] :: Expr
04:01:56 <lambdabot>   f a (f b (f c z))
04:03:26 <aristid> > f <$> [1,2,3] <*> [1,2,3] :: Expr
04:03:27 <jaffa4> > 1
04:03:28 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:03:28 <lambdabot>         against inferred ...
04:03:28 <lambdabot>   1
04:03:43 <aristid> > f <$> [1,2,3] <*> [1,2,3] :: [Expr]
04:03:44 <lambdabot>   [f 1 1,f 1 2,f 1 3,f 2 1,f 2 2,f 2 3,f 3 1,f 3 2,f 3 3]
04:03:49 <aristid> yay.
04:03:55 <byorgey> nice =)
04:04:11 <jaffa4> permutation?
04:04:40 <aristid> byorgey: so this stuff has instances for a->b, a->b->c and so on? is that how it works?
04:04:48 <byorgey> jaffa4: more like combinations, it applies f to all combinations of one element from the first list and one from the second
04:05:03 <byorgey> aristid: well, you only need an instance for a->b
04:05:12 <byorgey> since a->b->c = a->(b->c)
04:05:26 <byorgey> aristid: but yes, and some instances for base types
04:05:39 <byorgey> aristid: and some special definitions for variables like f,g,h,a,b,c,x,y,z
04:06:02 <aristid> byorgey: i wonder if you can use this trick for making functions that take different numbers of parameters depending on how they're used
04:06:53 <byorgey> aristid: yes, you can.  try reading the Text.Printf module source. =)
04:08:21 <jaffa4> What is line like this isInvocant    :: !Bool ?
04:08:26 <jaffa4> I mean !
04:08:41 <aristid> damn i'm always forgetting the where in class X where
04:10:00 <dafis> jaffa4, it's a strictness annotation
04:10:38 <pastorn> Does anyone have "Programming With Arrows" by Hughes saved on disk?
04:10:41 * hackagebot multirec-alt-deriver 0.1.1 - Alternative multirec instances deriver  http://hackage.haskell.org/package/multirec-alt-deriver-0.1.1 (DanielSchuessler)
04:10:43 <pastorn> the host is borked
04:11:07 <pastorn> and i don't feel like paing $25 for something that's usually free...
04:15:20 <vipex> is there outside a haskell discussion forum with "starter - beginner - intermediate - expert" classification?
04:15:55 <roconnor> if x is vector in the direct sum of V and W, is there a unique decomposition x = v + w ?
04:16:16 <dafis> roconnor, by definition of direct sum
04:17:28 <pastorn> vipex: i don't really think there are that many forums for haskell stuff
04:17:30 <ksf> vipex, there's only two categories, beginners and oleg.
04:17:40 <pastorn> it's mostly mailing lists
04:17:43 <pastorn> and here
04:17:50 <ksf> and possibly stackoverflow
04:17:53 <ksf> reddit, too.
04:18:00 <ksf> and of course blogs
04:18:08 <vipex> i see
04:18:22 <vipex> oleg? :p
04:18:35 <dafis> vipex: Oleg Kiselyov
04:18:35 <ksf> http://okmij.org/ftp/
04:18:37 <pastorn> vipex: he's a dude who likes to mess with the type system
04:18:57 <ksf> he's the one ghc sends your programs to to get them typechecked
04:19:01 <vipex> haha
04:19:09 <dafis> vipex: Ordinary people measure their type-system fu in milli-olegs
04:19:36 <aristid> byorgey: i made a version of repeat that can take 1 or 2 parameters, but it's a bit hard to use: http://codepad.org/ItUdcDBL
04:19:44 <vipex> googling, mostly bad forum :))
04:19:49 <aristid> you need to use myRepeat 1 (2 :: Int) :: [Integer]
04:19:58 <aristid> the (2 :: Int) feels wrong
04:21:00 <dafis> aristid: genericReplicate perhaps?
04:22:24 <aristid> dafis: that works, cool
04:22:49 <aristid> http://codepad.org/Y0OrI9zs
04:24:00 <aristid> dafis: why didn't the Int version work for myRepeat 1 2 :: [Integer] tho?
04:24:39 <Zao> Defaulting and less deduction?
04:25:11 <aristid> Zao: i don't follow
04:25:14 <Baughn> aristid: I'm pretty sure that code of yours is evil
04:25:19 <Baughn> Just sayin'
04:26:27 <jaffa4> How do I set this : #ifdef PUGS_HAVE_POSIX?
04:26:39 <aristid> i could also build a constructor for arbitrary-sized tuples
04:26:39 <aristid> yay
04:27:23 <Baughn> You've seen printf, I assume?
04:27:31 <aristid> not really looked at it
04:27:40 <Baughn> It uses the same tricks. Only worse.
04:27:53 <aristid> heh
04:28:13 <aristid> Baughn: it's broken by design. printf is stringly-typed :)
04:29:01 <Baughn> ..that /could/ be fixed. >_>
04:33:23 <dafis> aristid: the Int version didn't work because "myRepeat 1 2 :: [Integer]" doesn't tell the compiler which instance to choose
04:33:34 <aristid> dafis: huh?
04:34:19 <dafis> aristid: It doesn't look at the available instances and sees I have an instance Repeat (Int -> [a]) a where...
04:35:16 <aristid> dafis: but why does it look at the instance with Integral n?
04:35:20 <dafis> aristid: and then selects that,
04:35:58 <dafis> aristid: It sees "myRepeat 1 2"
04:36:01 <wavewave> what is the best way to find out memory leak?
04:36:35 <aristid> dafis: i don't understand
04:36:37 <dafis> so it must find an instance Repeat xxx n where, for n in Num
04:37:08 <dafis> because all it knows is 1 :: Num n => n
04:38:07 <aristid> dafis: n is a fundep
04:38:20 <aristid> your n at least
04:38:20 <dafis> Okay, so there are instance Repeat [a] a and instance Repeat (Int -> [a]) a, both match so far
04:39:13 <dafis> Now, myRepeat 1 is then applied to 2,
04:39:40 <dafis> so it needs an instance Repeat (x -> y) a
04:40:05 <dafis> That rules out the first one
04:40:52 <dafis> but the compiler doesn't say "I have an instance for x = Int, so I'll say 2 is an Int"
04:41:35 <dafis> but it says "I don't know what type of number 2 is, and I can't find out, too bad for you"
04:42:13 <dafis> but if you have instance Integral i => Repeat (i -> [a]) a,
04:42:30 <dafis> you have a type class constraint on 2
04:42:52 <dafis> Now defaulting kicks in (section 4.3.4 of the report iirc)
04:43:18 <dafis> and it defaults 2 to Integer, according to the rules in the report
04:43:25 <dafis> happiness ensues :)
04:44:21 <dafis> wavewave, what sort of memory leak?
04:46:20 <wavewave> I am dealing with huge number of data and basically count things. 
04:46:43 <wavewave> But it is consuming memory linearly... 
04:46:52 <dafis> wavewave, smells like unwanted laziness somewhere
04:47:14 <wavewave> dafis: Yes.. in fact, I found the spots several times. 
04:47:15 <aristid> dafis: hmm this is a weird behavior
04:47:21 <dafis> wavewave, are you using a foldr somewhere?
04:47:22 <ksf> a retainer profile might help, but scattering a few strictness annotation might very well be way faster
04:47:34 <aristid> dafis: so essentially to have defaulting kick in, i need variables in the instance?
04:47:49 <dafis> aristid: yes, but there are not many good options
04:47:49 <wavewave> dafis: but often some changes recur the problem back.  
04:47:54 <ksf> also, if you have list code, switching to the fusion framework.
04:48:04 <ksf> er stream-fusion
04:48:23 <wavewave> I am planning to do so.. :)
04:48:32 <dafis> aristid, yes, you need type class constraints for defaulting (and quite restricted constraints)
04:48:36 <wavewave> before that, anyway, profiling is quite hard for me. 
04:48:54 <ksf> well, do it now, fusing the whole stuff might enable ghc to strictify better
04:48:56 <wavewave> ksf: especially retainer profile... 
04:49:21 <wavewave> ksf: I tried several options of profiles -hy, -hd -hr... 
04:49:40 <ksf> it takes practice, and also the ghc manual
04:49:48 <wavewave> ksf: but I couldn't spot where is exactly the problem.. 
04:49:53 <ksf> and it's helpful to be able to read core
04:50:13 <ksf> where strictness is explicit
04:50:19 <wavewave> ksf:  hmm. by the way, my code already becomes quite big.. (by bad design of course.  ;) 
04:50:35 <mklappstuhl> hey 
04:50:39 <wavewave> ksf: then, is reading a core a good way?
04:51:03 <dafis> wavewave, after you've learned reading core, yes
04:51:09 <mklappstuhl> BONUS: are there any people already translating learnyouahaskell.com ?
04:51:21 <wavewave> dafis: Hmm, I see. 
04:51:29 <ksf> as a quick tutorial: let introduces lazyness, case introduces strictness
04:51:34 <wavewave> dafis: it's still very scary to me. :O
04:51:51 <dafis> wavewave, that'll last a while
04:51:55 <ksf> ...and patterns in case are printed front to back due to a bug in the pretty printer that noone cares to fix ;)
04:52:03 <wavewave> ksf: yes. I understood this very recently.. :)
04:52:37 <ksf> er back to front
04:52:44 <ksf> I guess that's the reason of the bug.
04:53:16 <wavewave> ksf: I do not understand what you said. 
04:53:32 <wavewave> dafis: so how can I start seeing core code, by the way?
04:53:39 <ksf> cabal install ghc-core
04:53:53 <dafis> wavewave, -ddump-simpl
04:54:08 <ksf> which passes all the arguments for you and passes the output through hscolour before lessing it.
04:54:12 <dafis> wavewave, and redirect the output to some file
04:54:26 <dafis> wavewave, or ghc-core (on hackage)
04:54:47 <Baughn> Does the monomorphism restriction happen to have anything to do with general abstract nonsense's monomorphisms?
04:55:27 <wavewave> I made my own libraries. Does core analysis show inside libraries?
04:55:47 <ksf> usually, yes, because ghc inlines like crazy
04:56:33 <dafis> wavewave, but only if you compile with optimisations
04:56:50 <dafis> without, it doesn't inline across module boundaries
04:57:23 <wavewave> dafis: I see... it's difficult to get the feeling though. 
04:58:01 <wavewave> hmm I failed to install ghc-core. 
04:58:13 <dafis> wavewave, what error message?
04:58:17 <wavewave> pcre-light can not be installed.. 
04:58:27 <dafis> because?
04:58:35 <wavewave> maybe I have to install pcre?
04:58:51 <wavewave> Base.hsc:417: error: PCRE_DUPNAMES undeclared (first use in this function)
04:58:52 <dafis> the C library?
04:59:22 <dafis> looks like the C library
04:59:32 <dafis> have you got that?
04:59:32 <wavewave> hmm I have pcre and pcre-devel.. 
05:00:01 <dafis> then it /should/ work, I think
05:00:21 <dafis> try cabal install -v3 pcre-light
05:00:37 <vipex> hi mates, a forum discussion has it's fans. it's well archived and most people like this kind of discussion. how do you think if I setup one like this community http://delphi-id.tk/ ?
05:00:46 <dafis> make it shout, shout, let it all out...
05:01:02 <vipex> what* do you think
05:01:23 <wavewave> hmm maybe my pcre is too old?
05:01:33 <dafis> wavewave, that might be
05:01:42 <wavewave> I am using RHEL5. 
05:01:53 <byorgey> aristid: neat.  what makes it hard to use?
05:03:51 <jaffa4> What is  withCString name $ \s ?
05:03:58 <jaffa4> what is \?
05:04:18 <byorgey> jaffa4: that's an anonymous function
05:04:21 <dafis> jaffa4: ASCII approximation to a lambda
05:04:30 <byorgey> \x -> foo   is a function which takes an argument x and returns foo
05:04:40 <byorgey> > (\x -> x + 1) 3
05:04:41 <lambdabot>   4
05:05:18 <byorgey> jaffa4: so in your case, withCString name  expects a function as an argument, so it is given  \s -> something
05:05:39 <dafis> wavewave, no idea whether RHEL5 might be the cause
05:06:04 <jaffa4> there is no \s parameter
05:06:31 <byorgey> jaffa4: 'withCString name $ \s' by itself is a syntax error.
05:06:37 <byorgey> jaffa4: there's nothing on the next line?
05:06:41 <wavewave> dafis: Hmm, at least my notebook (debian squeeze) can install pcre-light. 
05:06:54 <aristid> byorgey: the problem was that defaulting didn't kick in, but we solved that
05:07:07 <wavewave> but my program is on my server. :-(
05:07:09 <aristid> but now i've written something MORE INSANE
05:07:11 <byorgey> aristid: ah, ok, great
05:07:14 <aristid> a tuple builder!
05:07:16 <byorgey> awesome!
05:07:16 <aristid> http://codepad.org/E6yzmiIC
05:07:32 <aristid> buildTuple 1 2 3 4 -> 4-touple
05:07:38 <jaffa4> here it is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26078#a26078
05:07:43 <vipex> test... been dc :(
05:08:08 <jaffa4> there is one parameter name
05:08:33 <dafis> aristid, tuples go up to 100 :)
05:08:47 <aristid> dafis: with TH, we might get to that :D
05:08:52 <aristid> but i won't do that manually
05:09:16 <aristid> too bad there are no 1-tuples
05:09:17 <dafis> aristid: no need for TH, a small python script can do it too
05:10:30 <dafis> jaffa4, there are two parameters, 'name' before the '$' and the anonymous function \s -> something after
05:10:59 <jaffa4> but what is \s?
05:11:21 <jaffa4> ok
05:11:24 <jaffa4> I see
05:11:25 <dafis> wavewave: try cabal installing pcre-light on your server with cranked up verbosity
05:11:38 <fabiim> Can i check the source files of the modules ghci loads ? 
05:12:18 <dafis> fabiim, if you have the sources
05:12:23 <wavewave> dafis: I did.. the main error is the same.. some undefined symbol.. 
05:12:47 <wavewave> dafis: I think it's too old version problem.
05:13:41 <dafis> wavewave, can you grep your libpcre* for that symbol?
05:14:28 <dafis> wavewave, maybe it's a c2hs issue or something
05:15:22 <aristid> hmm lazy i/o might work better if the garbage collector were more intelligent
05:15:23 <jaffa4> how would you define a function if it does not exist?
05:15:37 <wavewave> dafis: no such symbols in libpcre*
05:16:09 <ksf> jaffa4, the "\" is ascii for λ
05:16:16 <Peaker> defining a function of 2 args, no sugar: f = \x -> \y -> x * y     more sugar: f x = \y -> x * y    even more sugar:  f x y = x * y
05:16:42 <ksf> ...and pronounced as such
05:16:58 <aristid> defining a function of 2 args, point-free style: f = (*)
05:17:10 <jaffa4> how would you check if a given function does not exist?
05:17:25 <aristid> :t f would report an error
05:17:27 <wavewave> dafis: okay. in my notebook which has pcre 7.3, pcre.h has the symbol PCRE_DUPNAMES
05:17:27 <lambdabot> Not in scope: `would'
05:17:27 <lambdabot> Not in scope: `report'
05:17:27 <lambdabot> Not in scope: `an'
05:17:36 <aristid> see.
05:17:45 <wavewave> dafis: but in my server with pcre 6, it does not have the symbol. 
05:17:48 <Peaker> jaffa4, That's checked by the compiler, when compiling
05:17:50 <jaffa4> and in haskell
05:17:57 <fabiim> dafis, i have /usr/share/doc/ghc6-doc/libraries/base/src/* ... but i'm not find something i (think) was suppose to find in Ghc.Prim 
05:18:04 <Peaker> jaffa4, The compiler checks the names you use exist
05:18:29 <jaffa4> is there a compiler pragma for that?
05:18:30 <wavewave> dafis: so this is the version problem quite clearly. 
05:18:42 <benmachine> :t f
05:18:43 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
05:19:00 <fabiim> i was trying :info (->)  i  and got (...) Defined in GHC.Prim . yet i can't find it in the GHC.Prim source 
05:19:33 <Peaker> jaffa4, value = 1 ; x = valeu * 2    -- no need for pragma, compiler yells that "valeu" doesn't exist. Is this what you mean?
05:19:59 <dafis> fabiim, GHC.Prim is generated, not from Haskell source, out of luck there
05:20:04 <jaffa4> the program uses a package
05:20:23 <jaffa4> which may not include some functions depending on the platform
05:20:37 <jaffa4> I want to define the function if it is not included.
05:20:51 <fabiim> dafis, oh ok tks 
05:20:56 <Peaker> jaffa4, packages should generally export the same names in all platforms
05:21:12 <jaffa4> this one does not.
05:21:17 <ksf> fabiim, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html
05:21:21 <Peaker> jaffa4, If they do export different things according to some compile-time check, you better do the same check when using those names
05:21:22 <dafis> wavewave, seems so
05:21:27 <Peaker> jaffa4, which package is it?
05:21:47 <jaffa4> System.Posix.Internals
05:22:16 <benmachine> jaffa4: you could use cabal to include a source file on particular platforms
05:22:16 <jaffa4> Peaker: yes , that is not a bad idea.
05:22:18 <wavewave> dafis: so right now, I have to use -ddump-simpl
05:22:45 <rtypo> hey guys just a quick question: what does the $= operator mean?
05:22:45 <wavewave> dafis: thanks for helping me though.
05:22:50 <dafis> ksf: No sources
05:23:15 <ksf> yes
05:23:17 <rtypo> a $= b
05:23:21 <ksf> and -> isn't even mentioned.
05:23:32 <benmachine> rtypo: I think it's from OpenGL?
05:23:45 <rtypo> ah yes, it's an opengl app
05:23:53 <Peaker> rtypo, The GL packages define it to set a GL state variable
05:24:16 <dafis> ksf: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html gives a 'Not found'
05:24:25 <benmachine> http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
05:24:28 <benmachine> rtypo: ^
05:24:35 <rtypo> amazing, i searched the web 15 minutes for any info
05:24:39 <rtypo> thanks guys :)
05:24:47 <ksf> dafis, your internet is broken.
05:24:51 <dafis> ksf: wrong link, sorry :http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-prim-0.2.0.0/src/GHC-Prim.html#Int%23
05:26:14 <ksf> those sources are just not meant to be consumed by mere mortals
05:26:23 <benmachine> dafis: Prim means primitives, there aren't really source codes for primitives
05:26:24 <wavewave> dafis: whoa.. horribly large code. ;-P
05:27:00 <dafis> benmachine, I know, I have looked for them in the source distributions
05:27:15 <dafis> it's generated from primops.txt, iirc
05:27:34 <benmachine> oh right yes
05:28:09 <dafis> wavewave, if you have turned on -O2, at least that's as big as it will get :)
05:28:12 <ksf> http://darcs.haskell.org/ghc-stable/ghc/compiler/prelude/primops.txt.pp
05:28:54 <wavewave> dafis: but I found it seems helpful now. thx.. 
05:29:17 <fabiim> what does :  instance Functor ((->) s ) where  fmap f g = f.g is trying to accomplish ? 
05:29:33 <ksf> the _actual_ sources are http://darcs.haskell.org/ghc/rts/PrimOps.cmm
05:29:58 <dafis> fabiim: a Functor instance for the partially applied function type
05:30:55 <zygoloid> fabiim: it says that functions are functors, which lift functions on values to functions on the results of functions.
05:30:57 <dafis> ksf: Can you translate that to Haskell?
05:31:04 <ksf> nope
05:31:14 <ksf> haskell is translated _to_ cmm
05:31:26 <ksf> and those functions all work directly on the stg
05:31:32 <dafis> What a loss (aesthetically)
05:32:16 <ksf> it's way more readable than llvm assembly...
05:32:48 * dafis wishes for a computer with GHC-core as machine language
05:33:50 <ksf> dafis, then you're going to love this: http://video.google.com/videoplay?docid=-1518197558546337776#
05:34:18 <vipex> ksf: what do you think if I setup new one Haskell Community Forum?
05:34:41 <ksf> I don't think a www forum would gain traction
05:34:51 <vipex> The goal helping newbies start using haskell in forum fassion
05:35:12 <vipex> just like ne :D
05:35:13 <vipex> me*
05:36:05 <ksf> well, there's the -beginners and -cafe mailing lists, and they have a gmane interface
05:36:14 <vipex> at least it'll archived well
05:36:28 <ksf> and I don't think you'd be able to convince anyone to switch away from smtp/nntp
05:37:15 <vipex> i don't wanna anyone switch away from mailing list :)
05:37:41 <vipex> but a forum kind has it's own style
05:37:44 <ksf> but without experienced users, you won't be able to help newbies
05:37:52 <vipex> hmm
05:38:03 * ksf is reminded of a long-winded argument in the german pirate party about that.
05:38:24 <dafis> ksf: what's the accent of the speaker? Not easy to understand with those acoustics
05:38:27 <ksf> in the end it was the forum moderators arguing alone against the rest that their way is The Best (TM)
05:38:41 <ksf> something british
05:38:55 <ksf> yeah university of york
05:39:27 <vipex> the forum dedicated to everyone who willing help starter through forum way (it's archived as FAQ), I don't think I wan help newbies since I absolutely noob
05:40:29 <dafis> ksf: but is he from there? I seem remember a different accent from Yorkshire ('kay, was PRSY, Sheffield)
05:40:31 <ksf> we do have a beginner mailing list, and I'd be surprised if faqs wouldn't end up in the tutorials etc.
05:40:32 <ville> How do I get a Graphics.UI.Gtk.ListStore from a Graphics.UI.Gtk.Builder? There doesn't appear to be a Graphics.UI.Gtk.castToListStore to be used with Graphics.UI.Gtk.builderGetObject.
05:41:02 <ksf> I really can't tell. Everyone without a scandinavian accent sounds foreign to me.
05:41:20 <dafis> vipex: for helping beginners, we have a specialised mailing list, the haskell-cafe and #haskell
05:41:30 <Twey> ksf: In English?
05:41:54 <ksf> vipex, to put it bluntly, stop worrying and get going on coding :)
05:41:58 <ksf> Twey, yes.
05:42:25 <ksf> according to an american my german accent is virtually non-perceptible, it's all "scandinavian"
05:42:30 <vipex> it's ok, i just wanna makes addition way through haskell community :(
05:42:34 <Twey> ksf: Haha!
05:42:50 <ksf> which doesn't surprise me, as I've got a strong northern accent
05:43:02 <vipex> since not most people like mailing-list, and some likes forum style
05:43:05 <ksf> ...in german, that is.
05:43:33 <dafis> ksf: northern as in Dithmarschen, Altona, Jever or what?
05:43:34 <Twey> Aye
05:43:36 <ksf> to the point where people wonder why my platt is so bad, with that natural pronounciation.
05:43:48 <ksf> northern as in hamburg/holstein
05:44:12 <vipex> ksf: by the way i just already setup the new one :(
05:44:21 <vipex> here http://haskell.tk/
05:44:45 <dafis> ksf: Bremen here
05:45:18 * dafis ss-tolpert ueber ss-pitze SS-teine
05:45:35 <ksf> nah that's hamburg, we don't do that
05:45:42 <vipex> go and use them if you're willing, not forching though
05:46:16 <vipex> i don't make any classification yet
05:46:19 <dafis> ksf: but I do
05:48:18 <vipex> ksf: i even not going take any benefit from it, except nice article / tutorial / step by step archived as well... noobs will learn from it
05:48:43 <ksf> http://www.kmonos.net/pub/files/big10.pdf
05:48:51 <ksf> \o/
05:48:57 <ksf> the bidi graph paper is online
05:49:16 <ksf> vipex, I'm not going to stop you, I just don't think it's going to fly.
05:50:12 <vipex> ksf: sure, let people choose they way
05:50:30 <byorgey> vipex: there is software that lets you view mailing lists as if they are fora.
05:50:40 <byorgey> I think that's what most people do who like a forum-like interface.
05:50:47 <vipex> yeah i know
05:51:00 <mreh> can I overwrite an instance of some class?
05:51:04 <byorgey> since the various @haskell mailing lists are the long-established means for communication in the Haskell community.
05:51:26 <ksf> but an interface doesn't make a forum
05:51:27 <byorgey> mreh: no, you have to make a newtype
05:51:37 <ksf> in a forum it's costumary to move posts etc.
05:52:18 <vipex> sad... i already setup it... who willing help other though the forum
05:54:53 <vipex> Would you be an forum administrator / moderator / contributor? i will setup the account if you are willing to
05:57:02 <wavewave> dafis: can I ask a question of how to match profile file and core file?
05:57:49 <dafis> wavewave, sure, can't promise a good answer though
05:59:13 <dafis> wavewave, generally, matching profile and core becomes easier the more {-# SCC #-}s you have
06:00:08 <Twey> byorgey: The provided interface doesn't tend to be very good, though
06:00:12 <wavewave> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26079#a26079
06:00:21 <Twey> Presumably due to intrinsic differences between the two formats
06:00:36 <wavewave> dafis: this is a part of my hp file after -hd -p runtime option. 
06:00:46 <Twey> Holy crap what is that.
06:01:34 <ksf> that's raw data
06:01:53 <ksf> you want to run hp2ps on that
06:02:01 <ksf> or hp2ps -colour, even.
06:02:04 <dafis> wavewave, run it through hp2ps -c
06:02:12 <wavewave> ksf: yes. I did.. but it shows too little info.. 
06:03:10 <ksf> have a look at the dumps per type?
06:04:16 <wavewave> ksf: it just shows (:) is consuming most of memory. 
06:04:24 <wavewave> ksf: also I#.. 
06:04:44 <dafis> wavewave, can I see the code?
06:04:45 <wavewave> ksf: what does dumps per type mean?
06:04:53 <ksf> ...what you just did
06:05:17 <ksf> @hoogle I#
06:05:18 <lambdabot> No results found
06:05:19 <wavewave> dafis: in fact, the code is too large and too scattered. 
06:05:23 <ksf> wth is that?
06:05:46 <wavewave> I guess it's some internal GHC type for Int 
06:06:04 <wavewave> type constructor. maybe. 
06:06:33 <wavewave> If I can understand the hp file format, then at least by eye, I can find out something.. 
06:06:50 <ksf> oh it's the type constructor to put an Int# in an Int
06:07:17 <wavewave> ksf: yes.. but Int and (:) are everywhere. 
06:07:20 <ksf> which means that you want to have a look at the core and have a look for Int without #, and add a bit of strictness.
06:07:31 <vipex> I have setup 2 categories if you willing to fill it :D (1. New to Haskell 2. Haskell in Practice) --> I'll stay on those 2 categories since I start learn Haskell lol. please check http://haskell.tk/
06:07:32 <wavewave> ksf: I cannot spot.. 
06:07:33 <ksf> ...so that ghc can unbox the ints.
06:07:35 <dafis> ksf: I# is the constructor for Int, data Int = I# Int#
06:08:03 <ksf> as for the (:) case, I'd recommend stream-fusion and/or througout manual program analysis
06:08:34 <wavewave> ksf: How can I do manual program analysis ? 
06:08:45 <mreh> when you see a module in the synopsis of a haddock, does that mean it exports the whole module?
06:08:51 <ksf> zen.
06:09:02 <ksf> retainer profiles help doing that.
06:09:07 <wavewave> what is this? <MSSMScan-0.2:MSSMScan.Read.sat_syRs>
06:09:14 <ksf> but they're admittedly hard to read.
06:09:24 <wavewave> MSSMScan.Read is my module name. 
06:09:30 <dafis> wavewave: I'm almost sure you're not consuming your list strictly enough
06:09:40 <wavewave> but I cannot find sat_syRs ...
06:09:54 <ksf> it's a lambda or let or where
06:09:54 <wavewave> even in my core.. 
06:10:00 <ksf> without SCC annotations
06:10:18 <ksf> blame for that goes to the ghc devs, who don't use a sane random seed for the symbols.
06:10:25 <wavewave> dafis: I think so ;-)
06:10:34 <ksf> please direct flames to #ghc
06:11:07 <dafis> wavewave, try profiling with -hb
06:11:08 <wavewave> I just want to know how you find the too-lazy spot in fairly large program.. 
06:11:53 <dafis> wavewave, mainly knowing a handful of common patterns
06:12:07 <dafis> then scanning the code for them
06:12:26 <ksf> someone should definitely write a tutorial on it
06:12:38 <wavewave> absolutely. 
06:12:54 * ksf volunteers dons
06:13:16 <wavewave> at least if I can find where the spot is very easily. 
06:13:38 <wavewave> then I can try many things. !, seq, pseq, deepseq, whatever.
06:15:02 <wavewave> anyway, so now.. using SCC annotation is the best way?
06:15:18 <ksf> definitely
06:15:30 <ksf> especially if you have a lot of local definitions
06:15:32 <wavewave> dafis: I tried -hb option but it is too crude.. 
06:15:46 <dafis> wavewave, much drag?
06:15:47 <ksf> oh, and don't forget --auto-all
06:16:01 <wavewave> ksf: I did it. 
06:16:16 <wavewave> dafis: no drag
06:16:24 <mreh> are Unboxed Arrays magic?
06:16:45 <ksf> dark, but not deep
06:16:52 <wavewave> dafis: so is DRAG  the thing I have to watch?
06:17:06 <mreh> ksf: were you saying that to me?
06:17:39 <dafis> wavewave, drag means something holds on to stuff when it's no longer used. void and drag are the bad guys
06:18:15 <wavewave> not that much void and drag.. 
06:18:23 <wavewave> but fairly large LAG. 
06:18:42 <wavewave> LAG ~t 10% of USE 
06:18:44 <dafis> wavewave, suspicious, but not necessarily bad
06:19:08 <ksf> mreh, yes
06:19:12 <dafis> Oh, just 10% of use, not much, really
06:19:46 <wavewave> by the way, how can I use SCC? 
06:20:07 <ksf> {-# SCC "foobar" #-}
06:20:18 <wavewave> ksf : thx. 
06:20:42 <ksf> they scope lexically.
06:21:02 <magicman> Is there a write-up somewhere about the mtl VS transformers thing?
06:21:37 <Zao> Apart from all over cafe?
06:22:00 <ddarius> Mostly you want to recognize bad patterns as you write code and fix them then.  It's much easier that way.
06:22:05 <ksf> I think it had been established that mtl is bad?
06:22:13 <ksf> the problem is the bikeshedding over its successor.
06:22:17 <magicman> Right.
06:22:40 <magicman> mtl is bad because... (sorry, I've been living under a rock regarding this >_>)
06:23:14 <magicman> Because the amount of code to write is quadratic in the amount of monad transformers or something?
06:23:41 <ddarius> I doubt any other "successor" to mtl solves that.  Though some wierder approaches mitigate it.
06:24:10 <ksf> compose-trans?
06:25:27 <ksf> oh we have RegionT, I never knew.
06:25:50 <magicman> Most of the things I'm finding is people having trouble with combinations of libraries such that they depend on both mtl and transformers.
06:26:03 <magicman> Or something about the "transformers" that exist in mtl.
06:26:14 <ksf> and they usually don't even care.
06:27:20 * hackagebot graphics-formats-collada 0.3.1 - Load 3D geometry in the COLLADA format  http://hackage.haskell.org/package/graphics-formats-collada-0.3.1 (LukePalmer)
06:28:05 <magicman> *nod*, okay.
06:28:42 <ddarius> magicman: The benefit of transformers is that it splits off the concrete monad definitions which are Haskell 98 from the monad class definitions which require extensions.
06:28:57 <magicman> Ah!
06:29:08 <magicman> So that's what the monad-fd and monad-tf packages are for?
06:29:12 <ddarius> Yes.
06:29:17 <ksf> as if anybody would care about h98
06:29:19 <magicman> (FunDeps and TypeFamilies, I guess)
06:29:23 <ddarius> Yep.
06:30:41 <magicman> Excellent. I'll look into those, then. If only to get to know some alternatives.
06:30:44 <magicman> Thanks :)
06:31:00 <ksf> ...if we had closed type funs and if they'd border more on turing completeness without undecidableinstances than now, I think we could forget about fundeps
06:31:01 <ddarius> magicman: transformers + monad-fd = mtl
06:31:11 <ksf> oh, and if they supported matching on contexts
06:31:59 <ksf> compose-trans seems to be using eugenia's whacked monad of monad transformers stuff
06:36:23 <illissius`> say I have a StablePtr, but at the point where haskell retrieves it from C, I don't know what -type- of StablePtr it is... what I do know is that it's a member of a given type class. is there any way to wrap it in an appropriate existential or something and retrieve it that way? or is this totally crazy and impossible and I should just figure out something else? (everything i've tried so far results in "ambiguous type variable" errors)
06:39:28 <mreh> can I get unsafeIndex from the Data.Array module hierarchy?
06:39:34 <quicksilver> illissius`: you should be able to use a StablePtr to an existential, yes.
06:39:47 <quicksilver> illissius`: you can't retrieve a stableptr which isn't existential and pretend it is
06:39:53 <quicksilver> but you can store the existential in the first place
06:40:25 <quicksilver> operationally "storing a type class existential" is really storing a tuple of methods.
06:40:37 <quicksilver> a tuple of function pointers, if you like to think in C
06:40:46 <quicksilver> ...all you can do is call one of them.
06:42:30 <wavewave> ahh.. this memory leak makes me really mad.. 
06:42:56 <illissius`> hmm. what I meant is obviously I can't deref a stableptr if I don't know what type it is. but if I do know a type class it's in maybe I can somehow deref it and wrap it in an existential for the type class sort of at the same time
06:43:21 <wavewave> Why can't I find which list is persistently present in memory?
06:43:52 <dafis> mreh, unsafeIndex is ByteString, for Arrays, it's unsafeAt, exported from Data.Array.Base
06:44:06 <quicksilver> illissius`: yes, I know what you meant.
06:44:10 <quicksilver> illissius`: the answer is "No."
06:44:18 <quicksilver> illissius`: but you can, instead, do what I have just suggested.
06:48:37 <illissius`> okay then, thanks
06:48:59 <quicksilver> illissius`: it's probably useful to remember that types only exist at compile time.
06:49:04 <dafis> wavewave, what does your programme do? Does it get the data from disk/via socket... as a String?
06:49:06 <illissius`> problem is it can potentially be a member of several different classes when I store it, and the at the points where I retrieve it I only have knowledge of a given subset of those, so that doesn't work
06:49:14 <illissius`> but I'll figure out something else then
06:49:21 <quicksilver> illissius`: when dereference a pointer if you don't know *at compile time* what the type is.
06:49:32 <quicksilver> then you can't possibly get the right type class instance
06:49:44 <quicksilver> the solution is to store the type class instance - which is what an existential does.
06:49:54 <wavewave> dafis: basically read data from disk and sort and count some patterns. 
06:50:05 <quicksilver> I suspect the right answer for you is some kind of tuple of functions or existential.
06:50:14 <dafis> wavewave, String, ByteString, Text?
06:50:35 <wavewave> dafis: this reads ByteString. 
06:51:17 <dafis> wavewave, good. and then it parses the data from the ByteString, right?
06:51:23 <wavewave> dafis: yes. 
06:51:34 <dafis> to what datatype?
06:52:22 <wavewave> it's making a Data.Map.
06:52:37 <wavewave> key is pattern and value is occurrence list. 
06:53:05 <dafis> wavewave, are you using foldr, fold or foldl'
06:53:14 <dafis> ?
06:53:49 <wavewave> dafis: I used foldl' 
06:54:08 <bastl> How can one write multiple patterns in a lambda expression ?
06:54:14 <dafis> wavewave, pity, in a way, that would've been so easy
06:54:21 <bastl> > (\'c' -> True) $ 'c'
06:54:21 <lambdabot>   True
06:54:49 <dafis> wavewave, but are you using insertWith or insertWith' ?
06:54:57 <wavewave> insertWith'
06:56:01 <dafis> wavewave, then it's probably more promising to look somewhere else first
06:56:16 <wavewave> dafis: ??
06:56:48 <mreh> how could `unsafeAt` possibly be slower than (!)?
06:56:50 <dafis> wavewave: if you use foldl' and insetWith', constructing the Map should be strict enough
06:56:54 <mreh> it would atleast be as fast
06:57:09 <wavewave> dafis.. 
06:57:19 <wavewave> dafis: .. 
06:57:55 <dafis> wavewave: you're not doing anything after constructing the Map, except outputting it?
06:58:03 <wavewave> dafis: BTW, then why profiling shows [] and Int are the main memory leak?
06:58:16 <chrisdone> just a vague notion, has someone put some thought into encoding the encoding of a string in the type?
06:58:32 <chrisdone> so instead of String, String a, so that you can't mismatch two encoding types
06:58:44 <dafis> mreh: in what situation is unsafeAt slower than (!)?
06:59:12 <wavewave> dafis: in fact, my program is a little bit more complicated. I use multiple threads. 
06:59:46 <wavewave> dafis: each thread process each file and later I am combining them. 
06:59:51 <mreh> dafis: well I'm using "unsafeIndex" too
06:59:58 <dafis> wavewave: I ran the .hp snippet through hp2ps, I don't see much I#, [] is the big thing
07:00:00 <mreh> but it still eliminates the bounds checks
07:00:49 <dafis> mreh: unsafeAt is bad if you use it on unboxed arrays of unknown type
07:01:16 <mreh> dafis: how do you mean?
07:01:25 <mreh> ghc will fill in unknown types
07:01:41 <wavewave> dafis: Ahh. that hp snippet has too small info.  roughly [] has 60% and I# has 40%. 
07:02:10 <mreh> dafis: did you say anything, I lost my connection
07:02:25 <wavewave> So I guessed some [Int] type has a leak. 
07:02:53 <dafis> mreh: I meant if you have something like foo :: (ctx) => UArray Int a -> b, then it's slow, I don't know why
07:03:21 <dafis> wavewave: That's reasonable
07:03:50 <dafis> wavewave: where does [Int] appear in your programme?
07:04:58 <mreh> it's more like UArray Int a
07:05:05 <mreh> bah
07:05:10 <mreh> it's more like UArray (Int,Int) a
07:05:38 <mreh> it's actually UArray (Int,Int) Double
07:06:36 <wavewave> dafis: I am not quite sure... of course, there are many... 
07:07:00 <wavewave> dafis: but they are small mostly. 
07:08:45 <wavewave> dafis: let me look at the code a little bit. I got some idea.
07:13:16 <dafis> mreh: UArray (Int,Int) Double should be okay, it's overloaded unboxed arrays that don't play nicely with unsafeAt, according to http://www.haskell.org/pipermail/haskell-cafe/2010-March/074757.html
07:13:39 <dafis> mreh: but you say (!) is faster?
07:22:17 <wavewave> dafis: I think I found the spot. 
07:22:34 <wavewave> I have some code like 
07:22:45 <dafis> wavewave: Good. where was it?
07:22:58 <wavewave> zip [1..] $ map parseInput strlines1
07:23:11 <dafis> wavewave: Ouch
07:23:19 <wavewave> this is for numbering each line. 
07:24:30 <wavewave> dafis: I found it using SCC. 
07:24:45 <dafis> wavewave: but it's too lazy, you're not doing anything but building thunks until the end
07:25:01 <wavewave> dafis: yes.. now I got some feeling. 
07:25:11 <quicksilver> hmm.
07:25:16 <quicksilver> zip [1..] should be fine, surely?
07:25:19 <quicksilver> what's the problem.
07:25:20 <dafis> wavewave: a good one, I hope
07:25:21 <wavewave> dafis: I think i have to make it using stream. 
07:25:48 <wavewave> quicksilver: it's working but memory leak.
07:25:54 <quicksilver> that shouldn't leak memory
07:26:04 <quicksilver> zip [1..] shouldn't change the memory characteristics of the list its attached to
07:26:04 <dafis> wavewave: or write a nice low-level loop with a couple of bang-patterns
07:26:18 <wavewave> quicksilver: by itself, it doesn't have problem.. 
07:26:21 <quicksilver> attached to a lazily generated list it's still a lazily generated list.
07:26:35 <benmachine> it could potentially if ghc did CSE, I guess that's why ghc doesn't do CSE >_>
07:26:50 <dafis> quicksilver: it's the map wrapped in the zip
07:26:53 <benmachine> quicksilver: what if the list being zipped with was a circular structure, might that matter?
07:26:56 <wavewave> quicksilver: but it is waiting until argument evaluated. 
07:27:09 <dafis> quicksilver: thunks in tuples are way bad
07:27:45 <quicksilver> thunks in tuples are exactly the same as thunks outside of tuples
07:27:54 <quicksilver> unless you are naively applying seq to the tuple
07:28:01 <quicksilver> that's the only circumstance there is a difference
07:28:01 <wavewave> dafis: in fact, I really don't want to make everything in alow-level loop
07:28:08 <quicksilver> (which is why naive application of seq is, well, naive)
07:28:11 <BMeph> benmachine: A cycle, you mean? By all rights (due to implementation leaks revealed by vacuum, et al.), that should definitely NOT leak.
07:28:15 <wavewave> dafis: it remind me of C again. 
07:28:19 * kmc has successfully calculated the factorial of 5 using Haskell code running on ARM Android
07:28:30 <benmachine> BMeph: k
07:28:31 <kmc> since this is all Haskell is really good for, i proclaim the project a complete success ;)
07:28:38 <benmachine> kmc: :D
07:29:13 <aristid> <quicksilver> unless you are naively applying seq to the tuple
07:29:17 <aristid> quicksilver: what happens then?
07:29:31 <kmc> > (undefined, undefined) `seq` ()
07:29:31 <lambdabot>   ()
07:29:36 <BMeph> kmc: Do you have a drop-in function generation, a la augustss' LLVM?
07:29:38 <kmc> > (undefined :: (Int, Int)) `seq` ()
07:29:38 <lambdabot>   *Exception: Prelude.undefined
07:30:03 <kmc> BMeph, not sure what you mean
07:30:06 <wavewave> dafis: thank you for your sincere help!
07:30:14 <benmachine> aristid: it evaluates up to the tuple constructor, not the values inside
07:30:29 <aristid> benmachine: everything else would have surprised me
07:30:33 <kmc> it's GHC-output code, not a DSL
07:30:37 <wavewave> I also thank kmc 
07:30:42 <kmc> and it's using unregisterised fvia-C, not LLVM (for now)
07:30:46 <benmachine> aristid: well then you need not be surprised
07:30:56 <quicksilver> aristid: well then it only seqs the tuple, not the thunk inside.
07:30:56 <aristid> yay
07:31:04 <wavewave> huk I am sorry. thank ksf.. 
07:31:10 <aristid> quicksilver: of course.
07:31:15 <quicksilver> but that's why you shouldn't treat seq as magic, because it isn't.
07:31:16 <benmachine> aristid: but if for e.g. you did a foldl' with a tuple accumulator it might still thunk all over your stack
07:31:20 <aristid> quicksilver: are there people who think something else?
07:31:21 <quicksilver> right.
07:31:24 <quicksilver> aristid: I don't know.
07:31:30 <kmc> well, seq is magic in some sense
07:31:36 <BMeph> kmc: Ah. Not as entertaining, then... ;)
07:31:39 <quicksilver> aristid: someone was suggesting that "zip [1..]" was bad because it wrapped thunks in tuples
07:31:42 <kmc> ;P BMeph
07:31:43 <benmachine> it's magic because it can differentiate between undefined and const undefined
07:31:43 <quicksilver> and "wrapping thunks in tuples" was bad
07:31:53 <quicksilver> I have no idea what they meant
07:31:56 <aristid> benmachine: ah, there it's somewhat hidden
07:31:57 <quicksilver> I was hoping for illumination ;)
07:31:59 <BMeph> kmc: I believe this is the right entry: http://augustss.blogspot.com/2009/01/llvm-arithmetic-so-we-want-to-compute-x.html
07:32:04 <quicksilver> kmc: yes, it is magic, you're right.
07:32:15 <quicksilver> kmc: what I mean, is it doesn't magically do what you want :)
07:32:21 <kmc> though it's worth mentioning that for monomorphic data types, it's not magic
07:32:23 <benmachine> (fsvo differentiate, that is)
07:32:27 <aristid> @src zip
07:32:27 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
07:32:27 <lambdabot> zip _      _      = []
07:32:28 <kmc> seq True x = x; seq False x = x
07:32:32 <aristid> @src zip'
07:32:33 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:32:42 <jkramer> Ahoy
07:32:51 <dafis> quicksilver: it makes them less likely to be made strict by the strictness analyser
07:32:52 <benmachine> for most datatypes seq could be a normal function
07:33:00 <benmachine> seq 0 x = x; seq _ x = x etc.
07:33:01 <jkramer> Does Network.Browser have problems with https?
07:33:14 <jkramer> Or self-signed certs?
07:33:16 <quicksilver> in particular, you can't apply it to an unknown type with any expectation of knowing what it means.
07:33:19 <benmachine> jkramer: in that it doesn't support it at all, yes
07:33:21 <kmc> int-literal patterns are weird
07:33:26 <quicksilver> dafis: Ah, right. The strictness analyser is a pain.
07:33:26 <jkramer> Oh
07:33:29 <BMeph> kmc: Actually, this one is better: http://augustss.blogspot.com/2009/01/llvm-llvm-low-level-virtual-machine-is.html
07:33:37 <quicksilver> dafis: sometimes I think any code which depends on the strictness analyzer should be considered buggy.
07:33:45 <quicksilver> (since the strictness analyzer is complex and hard to predict)
07:33:45 <jkramer> Knowing that could have saved me a few hours :)
07:33:51 <benmachine> jkramer: until recently it took https URLs and pretended they were http, at least with redirects
07:33:57 <jkramer> benmachine: Are there alternatives?
07:34:00 <benmachine> jkramer: but it should just choke and die now
07:34:01 <quicksilver> (also the strictness analyzer is non-equational and non-compositional)
07:34:22 <benmachine> jkramer: I understand Network.Curl does https, but I've never really looked into it
07:35:02 <dafis> quicksilver: but without the strictness-analyser, my ! key would be worn out every other week
07:35:04 <jkramer> benmachine: I've just installed the latest release (4000.0.9) and it still pretends to be doing something, i.e. it performs some or a lot of requests
07:35:24 <BMeph> The worst offense about seq is that it's specifically and deliberately implementation-dependent. Unfortunately, that is its purpose. :\
07:36:02 <benmachine> jkramer: hmm, maybe there's been no official release since that bug got fixed
07:36:38 <jkramer> benmachine: Upload date is Sun Dec 20 21:53:39 UTC 2009
07:36:59 <jkramer> Oh wait
07:37:06 <jkramer> No, it's correct :)
07:37:24 <benmachine> well
07:37:32 <benmachine> possibly it still gets requests wrong, then
07:37:34 <kmc> perhaps the bigger issue is the lack of operational details in the Haskell spec
07:37:48 <benmachine> I encountered the problem of an http page redirecting to an https one
07:37:58 <benmachine> that should just fail now (the fix was in on 12/12/09)
07:38:18 <kmc> perhaps there should be a "Haskell 2010 Operational Addendum" which codifies some aspects
07:38:22 <benmachine> but maybe initially requesting an https page isn't handled in the same way
07:38:28 <kmc> and which implementations could conform to or not
07:38:43 <benmachine> kmc: I'm undecided, I like how free ghc is to screw around with how code executes
07:38:49 <benmachine> e.g. strictness analysis and that
07:39:04 <kmc> yeah
07:39:11 <kmc> usually these things are written as minimum guarantees
07:39:18 <jkramer> So there' no working HTTP implementation for Haskell currently? :(
07:39:27 <jkramer> Well, beside using unsafe external libs
07:39:31 <BMeph> Sometimes, the OCD-like focus of (procedural) programmers on implementation details of programming constructs impresses me. At other times, I wonder how they ever get any programming done.
07:39:42 <benmachine> jkramer: there's no haskell implementation of SSL
07:39:49 <kmc> not all procedural programmers are like that
07:40:02 <kmc> at my last job i interviewed a remarkable number of people who thought that a computer was a machine for executing Java source code
07:40:12 <benmachine> jkramer: it's not a job haskell is very well suited for, I understand, because operational details like execution time can lead to security vulnerabilities
07:40:20 <BMeph> kmc: No, not all. But the ones that are more than make up for the rest, IMO.
07:41:06 <kmc> anyway people do care about huge performance implications of how they structure code
07:41:08 <kmc> and with good reason
07:41:22 <benmachine> they do indeed
07:41:40 <kmc> and right now best practices for performance in Haskell are tuned to GHC and GHC only
07:41:43 <kmc> and not to any spec
07:41:44 <benmachine> and it is pretty annoying that one can't really write portable code that demands performance
07:41:54 <benmachine> err demands?
07:41:58 <kmc> indeed as i understand it, Haskell implementations don't even have to be lazy
07:42:00 <benmachine> I think I mean, has
07:42:11 <BMeph> kmc: For example, people who worrk about the difference between singly- and doubly-linked lists. Not for performance reasons, not for access characteristics, but just because they can't focus on how the list is used, without knowing if it's a singly- or doubly-linked list.
07:42:11 <benmachine> they have to be non-strict
07:42:16 <digitteknohippie> i confirm, as a constituent of "people", we do care for performance, especially from how code is structured.
07:43:22 <jkramer> benmachine: It's still sad :(
07:43:51 <osfameron> what would a non-strict but not lazy Haskell implementation look like?
07:44:11 <kmc> you could do full call-by-name
07:44:15 <benmachine> jkramer: kinda yeah. it'd be good if there were some nice SSL bindings and then an https library that just used those
07:44:15 <kmc> which would duplicate work everywhere
07:44:28 <benmachine> I believe there's a gnutls binding that's bitrotted a bit
07:44:40 <kmc> the trick of "laziness" or "call by need" over CBN is to use some mutable update behind the scenes to remember the results of evaluating thunks
07:45:16 <kmc> which is the irony, we go on about purity but the very evaluation model used by GHC is constantly overwriting stuff in place to do even the most basic computation
07:45:19 <kmc> but it's all hidden ;)
07:45:25 <kmc> "wiggly pointers going everywhere, like snakes"
07:46:14 <p_l> kmc++
07:46:19 <p_l> For the gollum impersonation xD
07:46:36 <quicksilver> kmc: it's only superficially ironic, I think.
07:46:44 <quicksilver> kmc: in some respects its exactly the point.
07:46:55 <kmc> err i was quoting simon peyton-jones there
07:47:00 <kmc> (though not about GHC)
07:47:47 <p_l> kmc: I recalls similar quote going in some part of LotR... or I might have mixed it with another book. I do recall such a scene anyway.
07:47:59 <kmc> so perhaps SPJ was quoting gollum
07:48:26 <zygoloid> the RTS /needs/ to modify memory, due to the underlying architecture. in-place updates are just an optimization.
07:50:51 * hackagebot hlint 1.7.2 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.7.2 (NeilMitchell)
07:53:43 <jeltsch> > let helloWorld = "Hello " ++ "world!"
07:53:45 <lambdabot>   not an expression: `let helloWorld = "Hello " ++ "world!"'
07:53:51 <jeltsch> > "Hello " ++ "world!"
07:53:52 <lambdabot>   "Hello world!"
07:54:32 <benmachine> > showString "Hello " . showString "world" $ return '!'
07:54:33 <lambdabot>   "Hello world!"
07:54:52 <zygoloid> showString == (++) ?
07:55:03 <benmachine> err, I think so yes
07:55:14 <benmachine> except String -> String for no clear reason
07:55:34 <BMeph> I remember the "thunks modify memory" issue from Appel's ML paper.
07:55:36 <benmachine> well it's to help write ShowS functions
07:55:42 <kmc> > integerToBreakfast 2186493
07:55:43 <lambdabot>   "Headache pills and water"
07:55:47 <conal> so laziness is operationally complex and denotationally simple.  and the denotational part is what supports precise simple reasoning.
07:55:57 <jeltsch> (\n -> product [1..n]) 5
07:56:02 <benmachine> > integerToBreakfast 2186492
07:56:03 <lambdabot>   "A selection of cold meats with crisp bread"
07:56:36 <p_l> ... integer to breakfast?
07:56:47 <kmc> > integerToBreakfast 77923
07:56:48 <lambdabot>   "Strawberry jam toast"
07:56:54 <zygoloid> > integerToBreakfast . round $ pi * 1000000
07:56:55 <lambdabot>   "Cornflakes"
07:56:59 <zygoloid> nice
07:57:01 <p_l> > integerToBreakfast 42
07:57:02 <lambdabot>   "Cup of tea and a biscuit, gotta dash"
07:57:14 <p_l> > integerToBreakfast 666
07:57:15 <lambdabot>   "Cup of tea and a biscuit, gotta dash"
07:57:22 <p_l> :/
07:57:45 <benmachine> > 666 - 42
07:57:45 <lambdabot>   624
07:58:01 <p_l> > integerToBreakfast 4519
07:58:02 <lambdabot>   "Apples, pears, mango and kiwi"
07:58:13 <zygoloid> > length . group . sort $ map integerToBreakfast [1..10000]
07:58:14 <lambdabot>   13
07:58:21 <conal> oh -- more accurately, simple reasoning about *denotation*.  more difficult reasoning about operation (e.g. time & space use).
07:58:23 <noteed> conal: is it really that complex? or is it when you want it efficient?
07:58:23 <jeltsch> > (\n -> product [1..n]) 10
07:58:25 <lambdabot>   3628800
07:58:25 <zygoloid> > map head . group . sort $ map integerToBreakfast [1..10000]
07:58:26 <lambdabot>   ["A selection of cold meats with crisp bread","Apples, pears, mango and kiw...
07:58:27 <jeltsch> > (\n -> product [1..n]) 1000
07:58:28 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
07:58:36 <BMeph> benmachine: The String -> String thing is to trade the O(n^2) behavior of prepending for the memory burden of closures. (Did I get that jargon roll call right? ;)
07:58:40 <jeltsch> > (\n -> product [1..n]) 1000000
07:58:42 <lambdabot>   *Exception: stack overflow
07:58:50 <benmachine> @check integerToBreakfast n == integerToBreakfast (n + 13)
07:58:50 <lambdabot>   Not in scope: `integerToBreakfast'Not in scope: `integerToBreakfast'
07:58:53 <benmachine> :(
07:59:01 <jeltsch> > putStr "Hello!"
07:59:02 <lambdabot>   <IO ()>
07:59:25 <benmachine> > all (\x -> integerToBreakfast x == integerToBreakfast (x + 13)) [1 .. 10000]
07:59:26 <lambdabot>   True
07:59:40 <benmachine> BMeph: yeah, it's pretty clever
07:59:44 <zygoloid> the left section of (++) in a partial application of showString ensures that the LHS of each ++ contains only a small string.
07:59:57 <benmachine> BMeph: but in principle the existence and type of showString are only a convenience
08:00:14 <conal> noteed: if you want precision/correctness, yes.  which i guess is why imperative programming (including haskell IO) is rarely reasoned about precisely in practice.
08:01:36 <quicksilver> zygoloid: or less obviously, but equivalently, it ends up constructing a final expression in which (++) is associated to the right, no matter what order you constructed it in.
08:01:44 <BMeph> benmachine: Oh, sure! If Strings were binary trees instead of linear lists, appends would always be O(1), with other operations paying for it. Sounds like a perfect structure for laziness... ;)
08:02:00 <quicksilver> zygoloid: but I have always wondered what the overhead of all the (.)-thunks is 
08:02:05 <gio123> x
08:02:08 <quicksilver> BMeph: and that's exactly what showString gives you, in fact.
08:02:24 <quicksilver> (a binary tree of strings, forces on demand at the end)
08:02:26 <benmachine> BMeph: I just meant in that it's equivalent to (++)
08:02:30 <BMeph> quicksilver: :)
08:02:52 <rjsimmon>  > integerToBreakfast -1
08:02:56 <StefanBpo> Hello, is there someone who can help me with a problem in C#??
08:03:04 <benmachine> > integerToBreakfast (-1)
08:03:05 <lambdabot>   "*Exception: Prelude.(!!): negative index
08:03:10 <benmachine> eep
08:03:13 <cvic> >integerToBreakfast 6342634
08:03:19 <cvic> > integerToBreakfast 6342634
08:03:20 <lambdabot>   "Leftover vindaloo curry"
08:03:26 <cvic> Most interesting
08:03:34 <benmachine> StefanBpo: this is a channel about haskell, not C#
08:03:47 <kmc> StefanBpo, how did you find this channel?
08:03:53 <benmachine> StefanBpo: there might be someone who can help you but there's probably a better place
08:03:54 * kmc is still trying to work out how it happens
08:04:08 <StefanBpo> i found it under google
08:04:11 <cvic> Maybe he heard that Erik Meijer is trying to turn C# into Haskell 
08:04:16 <cvic> haha
08:04:27 <BMeph> StefanBpo: Short answer: Yes. Better answer: likely, but also likely not here... ;)
08:04:30 <kmc> StefanBpo, /join ##csharp
08:04:38 <benmachine> kmc: I have a vague recollection that some channel somewhere deliberately avoids the use of "programming" in their topic
08:04:40 <dafis> StefanBpo: Out of curiosity, what did you google?
08:04:50 <StefanBpo> ok i will join!;)
08:04:54 <benmachine> in the hope that people will not find them with generic queries
08:04:55 <kmc> haha benmachine
08:04:57 <StefanBpo> progamming help chat
08:04:58 <StefanBpo> lol
08:05:00 <StefanBpo> :P
08:05:01 <kmc> haha
08:05:02 <benmachine> see!
08:05:09 <kmc> StefanBpo, you should learn Haskell anyway ;)
08:05:24 <StefanBpo> its for a school project lol
08:05:28 <siracusa> @faq Can Haskell solve C# problems?
08:05:28 <lambdabot> The answer is: Yes! Haskell can do that.
08:05:32 <kmc> get a better school
08:05:37 <StefanBpo> hahaha
08:05:47 <StefanBpo> nah, i like c#:P
08:05:50 <conal> we could replace "The Haskell programming language" with "The Haskell executable specification language".
08:06:04 <kmc> haha
08:06:07 <benmachine> slash library specification language, surely
08:06:09 <StefanBpo> but i am going to join an other channel;)
08:06:14 <benmachine> <3 ffi
08:06:17 <cvic> Indeed
08:06:19 <StefanBpo> thanks for the positive replies
08:06:27 <illissius`> @faq can haskell has cheezburger?
08:06:27 <lambdabot> The answer is: Yes! Haskell can do that.
08:06:39 <cvic> >integerToBreakfast -1
08:06:43 <StefanBpo> @faq ur a computer?
08:06:44 <lambdabot> The answer is: Yes! Haskell can do that.
08:06:51 <benmachine> StefanBpo: if the people in ##csharp are nasty to you, it's probably because they wish they were doing haskell instead
08:07:01 <StefanBpo> haha lol!:P
08:07:09 <jaffa4> hi
08:07:12 <benmachine> hi
08:07:32 <jaffa4> Is it possible to install an earllier version of a package?
08:07:42 <kmc> yes everyone else has Haskell envy
08:07:50 <BMeph> StefanBpo: (Semi-)Seriously, if you learn Haskell now, you'll have a step up on all the C# updates at least to 12.0 :)
08:08:05 <benmachine> jaffa4: yes, cabal install foo-1.2.3.2 should work
08:08:08 <conal> benmachine: i bet you're onto something there.  i wonder if anyone has studied and charted the happiness/kindness of chat rooms for various programming languages.
08:08:24 <benmachine> conal: well, there is plenty of anecdotal evidence :)
08:08:29 <kmc> we have a particular reputation (and engage in a bit of self-congratulation over it)
08:08:29 <jaffa4> and can I get what versions are available?
08:08:36 <kmc> jaffa4, off hackage
08:08:40 <benmachine> kmc: giggle, yes to both
08:09:12 <jaffa4> I need to find System.Posix.Internals
08:09:22 <jaffa4> It does not seem to be among the packages
08:09:30 <benmachine> but I'd rather be smug than grumpy any day
08:09:43 <conal> :)
08:10:01 <kmc> it's easier to dismiss people as being "smug"
08:10:02 <benmachine> jaffa4: try ghc-pkg find-module System.Posix.Internals
08:10:04 <zygoloid> quicksilver: i don't like the "(++) is associated to the right" description, because it's less general (what about composing with things which aren't left sections of (++)?)
08:10:08 <kmc> and it's the FP stereotype
08:10:16 <cvic> Haskell? In my C#?! Morelikely than you think 
08:10:17 <conal> ah -- "Haskell -- the language of happy elitists"
08:10:22 <kmc> hahahaha cvic
08:10:35 <kmc> if you know better ways to do things, you're a "smug weenie"
08:10:35 <cvic> *More likely 
08:10:43 <djahandarie> Heh, Go beats Haskell in one of the shootout benchmarks
08:11:02 <kmc> centipedes
08:11:04 <cvic> Speed... heh, "A day at the races with ASM" 
08:11:07 <cvic> good essay 
08:11:15 <benmachine> jaffa4: that will tell you if the module is in any packages you already have (it tells me that said module is in base)
08:11:18 <cvic> How about we discuss some other metrics 
08:11:34 <kmc> the programming language shootout is decadent and depraved
08:11:36 <benmachine> (p.s. you can't install other versions of base, it's an exception to the general rule)
08:11:43 <jaffa4> do you think it is safe to go back to and earlier ase?
08:11:48 <jaffa4> base
08:11:59 <cvic> If I want speed, I can use assembly. But I'm going to generate it with Haskell D: 
08:12:10 <kmc> jaffa4, i'd install a totally separate GHC / packages in a prefix
08:12:10 <benmachine> jaffa4: it's neither safe (in general) nor should it be necessary usually, what's your specific problem?
08:12:28 <djahandarie> Someone run them with the LLVM backend
08:12:33 <jaffa4> some functions are missing from a package
08:12:37 <djahandarie> I'm interested in the speed gains
08:12:39 <BMeph> kmc: I'd say #haskell folks are most proud about being so reasonable, that troll leave frustrated. But then, that's an Awesome rep to have.... :)
08:12:47 <kmc> heh BMeph
08:12:47 <jaffa4> I think maybe they were removed
08:12:52 <kmc> we don't get many competent trolls
08:12:52 <BMeph> s/troll/trolls/
08:12:57 <kmc> or else they are extremely competent
08:13:04 <jaffa4> but it is possible that there were there.
08:13:16 <cvic> Catatrollmorphisms 
08:13:23 <djahandarie> Hahaha
08:13:24 <cvic> and barbed wire 
08:14:08 <benmachine> jaffa4: which?
08:14:20 <cvic> It's easier to troll C++. Nuff said 
08:14:25 <benmachine> jaffa4: if they were removed, it's pretty likely that they were renamed, or there's some other way of doing the same thing
08:14:39 <kmc> it's pretty easy to troll #haskell
08:14:46 <jaffa4> I do not know if there were there.
08:14:47 <cvic> To properly troll Haskell you need to read some research papers on category theory and stuff 
08:14:55 <jaffa4> I guess I should see the source.
08:14:57 <kmc> you just have to ask how to convert IO String into String, and then get angry about the answer
08:14:59 <jaffa4> c_opendir
08:15:29 <cvic> "Ok, so I heard that monads are like fluffy pink clouds. Discuss"
08:15:34 <jaffa4> beatmox:  if there were renamed
08:15:43 <jaffa4> that could be solved easily
08:16:03 <kmc> my guess is that c_opendir is a foreign import
08:16:08 <kmc> in which case you can just import it yourself
08:16:32 <jaffa4> from where?
08:16:40 <kmc> from C
08:17:18 <kmc> foreign import "dirent.h opendir" c_opendir :: CString -> Ptr ()
08:17:20 <kmc> or whatever
08:17:31 <kmc> err IO (Ptr ()) for sure
08:17:38 <mreh> how can I make arrays even fasterer?!
08:18:11 <dafis> mreh: depends, what's your use-case?
08:18:28 <monochrom> I think mreh is joking
08:18:31 <mreh> dafis: well I'm iterating through the same arrays alot
08:18:38 <djahandarie> Fasterererer
08:18:39 <benmachine> mreh: put .Unboxed on all your imports, magic results
08:18:48 <monochrom> memoize the array <duck>
08:18:53 <mreh> benmachine: well, unfortunately not
08:18:59 <mreh> quack
08:19:02 <BMeph> monochrom++
08:19:03 <dafis> mreh: STUArrays?
08:19:20 <BMeph> mreh: STFUArrays! <goose>
08:19:25 <jaffa4> kmc: I get a parse error on that
08:19:30 <benmachine> </goose> </duck>
08:19:39 * benmachine diligently tidies up after people
08:19:50 <monochrom> <coq />
08:20:09 <kmc> jaffa4, you have to turn on the ForeignFunctionInterface extension
08:20:15 <kmc> read about FFI; RWH has a good chapter
08:20:23 * BMeph thinks..."someone"...should use the handle monocoque
08:20:24 <mreh> I'm rather underwhelmed by the performance, but I haven't tried the equiv in C yet
08:20:51 <dafis> mreh: elaborate?
08:21:27 <jaffa4> RWH?
08:21:38 <dafis> jaffa4: RealWorldHaskell
08:21:50 <dafis> @where RealWorldHaskell
08:21:50 <lambdabot> http://www.realworldhaskell.org/
08:21:58 <ManateeLazyCat> Have exist function equal "x - (x `mod` y)" ?
08:22:11 <mreh> dafis: I'm only iterating through arrays, it's probably doing in the order of 1million operations accessing and multiplying numbers
08:22:35 <dafis> mreh: mutating the arrays?
08:22:35 <mreh> convolution of 640x480 image by a 11x11 kernel takes 20s in haskell
08:22:44 <mreh> dafis: loading the result into a new array
08:22:54 <aristid> @hoogle (w a -> b) -> w [a] -> [b]
08:22:55 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
08:22:55 <lambdabot> Control.Parallel.Strategies parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
08:23:21 <ManateeLazyCat> Or good mathe name for "x - (x `mod` y)" ?
08:23:43 <aristid> @hoogle (m a -> b)
08:23:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:23:43 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
08:23:43 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
08:24:00 <benmachine> ManateeLazyCat: (x `div` y) * y does the same thing, but not really any faster :P
08:24:07 <osfameron> Control Monads forever!
08:24:36 <benmachine> aristid: is that like, un-mapM
08:24:39 <aristid> :t fmap sequence repeat
08:24:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
08:24:46 <aristid> benmachine: yeah exactly :)
08:24:57 <mreh> dafis: this is the code so far http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26084#a26084
08:25:03 <aristid> mapW :: Comonad  w => (w a -> b) -> w [a] -> [b]
08:25:06 <ManateeLazyCat> benmachine: Do you know any good name for "x - (x `mod` y)" ?
08:25:16 <benmachine> ManateeLazyCat: nope
08:25:36 <benmachine> if you come up with one let me know :P
08:25:51 <monochrom> don't use a mathy name. see what happened to monad and magma. use an enterprisy name.
08:25:57 <roconnor> > 19 - (19 `mod` 3)
08:25:58 <lambdabot>   18
08:26:00 <ManateeLazyCat> benmachine: I wonder have a mathematics name for this function. :)
08:26:08 <roconnor> > 19 `div` 3 * 3
08:26:09 <lambdabot>   18
08:26:12 <monochrom> I suggest "profit after tax"
08:26:29 <monochrom> think of x `mod` y as tax
08:30:13 <benmachine> monochrom: synergisticDynamism x y
08:30:54 <dafis> mreh: looks like you need more strictness, give me some time to test it
08:31:04 <ManateeLazyCat> monochrom: I want a simple name, i have increase value "x", but i want "x" is multiple of "y", so i write "x - (x `mod` y)"
08:32:35 <benmachine> reduceToMultipleOf if you like verbosity
08:32:52 <tromp> roundDownTo...
08:33:05 <benmachine> weird sort of rounding though
08:33:13 <benmachine> but I guess that makes as much sense as anything
08:33:45 <Twey> floorTo
08:34:06 <ManateeLazyCat> cutResidue
08:34:13 <ManateeLazyCat> How about that?
08:34:14 <Twey> No :þ
08:34:20 <tromp> it's more common to round up to multiples. esp. when allocating stuff
08:34:35 <benmachine> Twey: no?
08:34:59 <Twey> ‘cutResidue’ sounds like a lumberjack's job >.>
08:35:19 <benmachine> so?
08:35:20 <ManateeLazyCat> Twey: Better word to replace "cut" ?
08:35:32 <monochrom> drop
08:35:39 <mreh> remove
08:35:42 <Twey> What's wrong with ‘floorTo’?
08:35:46 <benmachine> technically "less" works, but it's uncommon to use it like that
08:35:48 <monochrom> nothing wrong
08:36:51 <kmc> guys i think we should paint the bikeshed purple
08:37:29 <monochrom> no, we should print "profit after tax" on the bikeshet
08:37:52 <kmc> you! yes you! you behind the bikesheds! stand still laddy!
08:38:43 <zygoloid> ooh ooh bikeshed? i have opinions! me! me!
08:40:10 <Twey> @let floorTo = join . fmap subtract . flip mod
08:40:11 <lambdabot>  Defined.
08:40:16 <Twey> > floorTo 3 8
08:40:17 <lambdabot>   6
08:40:20 <Twey> > floorTo 3 9
08:40:20 <lambdabot>   9
08:40:23 <Twey> > floorTo 3 10
08:40:24 <lambdabot>   9
08:40:28 <Twey> Okay?  :þ
08:40:36 <ManateeLazyCat> Thanks all, i use "cutResidure" :)
08:40:44 <aristid> Twey: floorToMultiple :P
08:41:01 <ManateeLazyCat> Twey: floorTo looks complicated than "x - (x `mod` y)" . :)
08:41:11 <Twey> ManateeLazyCat: Nobody will understand what that's supposed to mean
08:41:20 <Twey> So long as you're okay with that, go right ahead :þ
08:41:20 <aristid> ManateeLazyCat: cutResidure is ununderstandable:)
08:41:27 <Twey> Haha
08:41:41 <monochrom> there is no meaningful name
08:41:50 * Twey hands aristid ‘incomprehensible’: ‘you were looking for this, sir?’
08:42:13 <Twey> ‘floorToMultiple’ is probably the best, but I think just ‘floorTo’ is comprehensible
08:42:27 <Twey> (and considerably shorter)
08:42:47 <ManateeLazyCat> Twey: floorToMultiple is good name. :)
08:42:52 * BMeph prefers "unununderstandable"... ;þ
08:43:06 <Twey> Ununununununununununun…
08:43:21 <aristid> ManateeLazyCat: obviously. after all, it was MY idea
08:43:38 <ManateeLazyCat> aristid: Ok, thank you guys. :)
08:43:54 <kmc> > fix ("un"++)
08:43:55 <lambdabot>   "ununununununununununununununununununununununununununununununununununununun...
08:43:56 <ManateeLazyCat> I love this name. :)
08:44:40 <tromp> cycle "un"
08:44:54 <jesusabdullah> > cycle "unt-tiss "
08:44:55 <lambdabot>   "unt-tiss unt-tiss unt-tiss unt-tiss unt-tiss unt-tiss unt-tiss unt-tiss un...
08:45:02 <jesusabdullah> hooray!
08:45:42 <ManateeLazyCat> Bye all, i will login again when i can't found good name for my function. :)
08:45:52 * jesusabdullah read up on fix
08:45:53 <jesusabdullah> neato!
08:46:16 <kmc> > fix ((0:) . scanl (+) 1)
08:46:17 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:47:05 <kmc> > let fibs = 0 : scanl (+) 1 fibs in fibs
08:47:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:47:09 <jesusabdullah> I remember my first implementation of that sequence, in java, like 5 years ago
08:47:13 <jesusabdullah> It was really long iirc
08:47:38 <jesusabdullah> had that whole "xold, xnew" nonsense
08:47:45 <aristid> jesusabdullah: at least 10 lines!!!!!!!!!!!
08:47:50 <jesusabdullah> at LEAST
08:47:52 <jesusabdullah> XD
08:50:45 <benmachine> Twey: residue is a thing
08:50:57 <benmachine> so it makes sense
08:51:08 <BMeph> Eww...soapyResidue. :(
08:51:17 <BMeph> ;)
09:16:23 <aristid> preflex: seen edwardk
09:16:24 <preflex>  edwardk was last seen on #haskell 1 day, 1 hour, 4 minutes and 57 seconds ago, saying: so members n k = (n + k) * members (n - 1) k `div` n -- also holds giving me a nice recurrence when i flip it around
09:16:46 <markus3> hi! a question: I'm trying to do some profiling, but the *.prof file shows much less "total time" than it's actually using
09:16:57 <markus3> even when I recompile and run without profiling
09:17:13 <kmc> markus3, did you run your program with +RTS -s
09:17:18 <kmc> (in addition to -p)
09:17:28 <markus3> em, no...
09:17:33 <kmc> perhaps the total time adds up to the total work rather than the total wall clock time
09:17:42 <kmc> -s prints useful stats (and is independent of profiling)
09:18:04 <markus3> so I don't have to do a profiling build to use it?
09:19:08 <kmc> correct
09:20:30 <markus3> I had another problem,  for wich I didn't manage to find an answer: my program used more stack than 8Mb, so I tried to increase it. But when I said -K100M, but still included the -p flag, it still said, that the stack limit was 8MB..
09:21:11 <markus3> but leaving out the -p, in the prof file it said it was using -p...
09:21:36 <Lemmih> markus3: No .prof file is written if you omit the -p flag.
09:22:04 <Lemmih> markus3: You're looking at the old .prof file.
09:23:20 <markus3> hmh.. I don't know -- notepad++ said, there was an update. I'll go and try some more..
09:23:58 <Lemmih> markus3: Changing the stack size limit should work fine with profiling enabled. Sure you did it right?
09:26:03 <markus3> well I think I did, but when you say, that what happens is impossible, I became to doubt myself :P
09:26:12 <markus3> i'll just ry again
09:27:21 <alip> I get time_t as a return value from a C function, how can i turn it into a LocalTime?
09:28:09 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/Foreign-C-Types.html#t%3ACTime
09:28:33 <alip> thanks!
09:31:30 <alip> kmc: and how do I get a time_t out of a UTCTime?
09:32:52 <alip> kmc: nvm found it :)
09:33:25 <jaffa4> I wonder how c structs can be imported
09:33:29 <jaffa4> that part is not clear
09:36:18 <kmc> well, you typically pass structs by pointer
09:36:29 <kmc> and if you have a haskell-side data type representing what you want
09:36:48 <kmc> called Foo
09:36:49 <kmc> then you can make an instance of Storable to poke / peek it into the C struct via a (Ptr Foo)
09:36:59 <kmc> but it's tedious to write such things by hand
09:37:02 <kmc> and so there are wrapper generators
09:37:19 <kmc> hsc2hs, c2hs, GreenCard
09:37:21 * Zao favors bindings-DSL
09:37:57 <kmc> ah, very nice
09:38:00 <Starfire> If a C struct is passed by value, is there any way to express that in Haskell? I gave up and wrote an easily-FFIable C wrapper instead.
09:38:42 <kmc> Starfire, none that I know of
09:38:46 <kmc> passing structs by value is rare, i think
09:38:46 <Zao> b-DSL allows you to define helpers easily, which is nice.
09:38:59 <Zao> But there's still some additional effort needed.
09:40:55 * hackagebot ad 0.40 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.40 (EdwardKmett)
09:41:12 * edwardk waves hello.
09:41:17 <edwardk> preflex: xseen jmcarthur
09:41:18 <preflex>  jmcarthur was last seen on freenode/#haskell 18 hours, 57 minutes and 23 seconds ago, saying: FunctorSalad: shred also will fail on compressed filesystems, RAID, and NFS
09:43:10 <ezyang> Starfire: Yes! 
09:43:22 <ezyang> You just make a Ptr to an "empty" data type, and never deref the pointer. 
09:43:29 <ezyang> Oh wait, pass by value 
09:43:35 <ezyang> Hm. >:-/ 
09:43:36 <edwardk> i finally figured out the gradients implementation
09:44:00 <tao_> hmm
09:44:15 <tao_> it looks like i can only use limited set of licences with cabal?
09:44:32 <edwardk> so now if you ask for 50th derivatives of a multiple argument function function, it'll just do the right thing.
09:45:16 <edwardk> i still need to add full fledged "Mode"s for Sparse and Dense, but the core of their implementation is complete
09:45:38 <edwardk> rather i have the Modes but I don't have the pretty little public API module for each
09:45:42 <jmcarthur> edwardk: i'm here
09:46:29 <Lemmih> tao_: You are free to use any license you want as long as it is BSD3. (:
09:46:38 <edwardk> jmcarthur: got the trie working
09:46:48 <lpsmith> Is HDBC thread-safe enough to cover the situation where one thread is database connection while another thread calls "disconnect" on that connection?
09:46:59 <jmcarthur> tao_: if you want to use a license not supported directly by cabal you can just say OtherLicense
09:47:02 <edwardk> jmcarthur: http://patch-tag.com/r/ekmett/ad/snapshot/current/content/pretty/Numeric/AD/Internal/Sparse.hs
09:47:06 <jmcarthur> ooh
09:47:18 <Lemmih> tao_: On a more serious note, 'Other' is also an option.
09:47:38 <edwardk> which let me define gradients :: (Traversable f, Num a) => FU f a -> f a -> Stream f a; gradients f as = Sparse.ds as $ f $ Sparse.vars as
09:47:38 <edwardk>     
09:47:58 <jaffa4> GreenCard?
09:48:04 <tao_> huh
09:48:05 <tao_> ok
09:48:19 <Zao> What do calling conventions say about passing non-primitive types anyway?
09:48:20 <tao_> i just want to use artistic license
09:48:26 <Zao> Isn't that highly compiler-dependant?
09:48:30 <jmcarthur> jaffa4: this is the first i've heard of it, but it looks cool
09:48:56 <Starfire> Zao: I guess so.
09:49:06 <edwardk> i could probably stand to replace the IntMaps with something that supports a left-biased drop in a faster fashion. i.e. a "finger patricia trie" but the asymptotics are more or less right
09:49:18 <jmcarthur> edwardk: wait, so it's just Cofree IntMap? how disappointingly simple ;)
09:49:23 <jaffa4> which is the best import tool?
09:49:39 <edwardk> well the intmap contains the invariant that i never store a key with lower value in a map indexed by a given value
09:49:56 <jmcarthur> yeah, i see from the amount of code that there are invariants
09:50:23 <jaffa4> I decided to look at System.Posix.Intervals
09:50:35 <jaffa4> but that file is very strange
09:50:36 <edwardk> but it reads very much like the Tower mode that is in the adjacent module
09:51:04 <edwardk> modulo the fact that once you build the intmaps you need to spew the values back out into the user's supplied functor
09:51:26 <edwardk> and the tensors data type works well with it:
09:51:30 <jaffa4> see: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26085#a26085
09:51:58 <edwardk> *Numeric.AD.Mode.Mixed> headT $ tailT $ tailT $ tailT $ tensors $ gradients (\[x,y] -> x*sin y) [2,3]   ==> [[[0.0,0.0],[0.0,-0.1411200080598672]],[[0.0,-0.1411200080598672],[-0.1411200080598672,1.9799849932008908]]]
09:52:23 <jmcarthur> oh that's cool
09:52:24 <edwardk> showing that by the third derivative anything that takes more than one derivative with respect to x goes to 0
09:52:57 <edwardk> and the trie causes those various -0.1411...'s to all come from the same computation
09:53:06 <jmcarthur> nice
09:55:30 <edwardk> *Numeric.AD Numeric.AD.Internal.Identity> gradients (\(Id x) -> sin x) 1 => 0.8414709848078965 :< Id (0.5403023058681398 :< Id (-0.8414709848078965 :< Id (-0.5403023058681398 :< Id (0.8414709848078965 :< Id (0.5403023058681398 :< Id (-0.8414709848078965 .. even shows the correct cycles, etc.
09:59:44 <edwardk> after i get those two modules in (Sparse and Dense), integrate them into the Mixed mode, i'd like to think about adding support for Interval arithmetic and Taylor Models.
09:59:51 <chrisdone> ciao guys
09:59:57 <kmc> hi chrisdone
09:59:57 <edwardk> since I need the former for the latter
10:00:19 <edwardk> that'll let you compute with AD and get bounds on your errors
10:09:29 <ezyang> How do I unlink a file from Haskell? 
10:09:48 <mauke> @hoogle remove
10:09:48 <lambdabot> Data.Graph.Inductive.Monad.IOArray removeDel :: IOArray Node Bool -> Adj b -> IO (Adj b)
10:09:49 <lambdabot> System.Directory removeDirectory :: FilePath -> IO ()
10:09:49 <lambdabot> System.Directory removeDirectoryRecursive :: FilePath -> IO ()
10:10:30 <mauke> @hoogle removeFile
10:10:30 <lambdabot> System.Directory removeFile :: FilePath -> IO ()
10:11:14 <ezyang> oh, System.Directory, not System.IO. Gotcha 
10:15:24 <alexyk> how do you fmap read or something over getArgs to slurp them quick?
10:20:22 <alexyk> is there a library type for pathnames?
10:20:26 <kmc> :t fmap read getArgs
10:20:27 <lambdabot> Not in scope: `getArgs'
10:20:31 <kmc> :t fmap read System.getArgs
10:20:32 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
10:20:32 <lambdabot>       Expected type: IO String
10:20:32 <lambdabot>       Inferred type: IO [String]
10:20:39 <kmc> :t fmap (map read) System.getArgs
10:20:40 <lambdabot> forall a. (Read a) => IO [a]
10:20:53 <pastorn> this arrow business of having 'newtype MyArr a b = MyArr (a -> (MyArr a b, b))
10:20:59 <pastorn> it makes my head spin
10:21:20 <pastorn> won't that cause an eternal loop, stack overflows and whatnot?
10:21:32 <kmc> that's a weird arrow
10:22:00 <pastorn> kmc: apparently that's the simplest way to do ArrowLoop
10:22:36 <pastorn> kmc: http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
10:22:55 <chrisdone> alexyk: FilePath?
10:23:04 <alexyk> ok
10:23:37 <jkramer> :t FilePath
10:23:38 <lambdabot> Not in scope: data constructor `FilePath'
10:23:41 <jkramer> :i FilePath
10:23:50 <jkramer> Hm
10:23:53 <jmcarthur> pastorn: i doubt that is the simplest way
10:23:56 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/filepath/System-FilePath.html
10:24:04 <jmcarthur> pastorn: isn't there an instance for (->)?
10:24:05 <alexyk> @hoogle FilePath
10:24:06 <lambdabot> module System.FilePath
10:24:06 <lambdabot> Prelude type FilePath = String
10:24:06 <lambdabot> System.IO type FilePath = String
10:24:10 <jkramer> It's just a String, is it?
10:24:11 <jkramer> Yeah
10:24:19 <kmc> but you're not supposed to depend on that
10:24:23 <pastorn> jmcarthur: you're right, there is...
10:24:29 <kmc> :t (</>)
10:24:30 <lambdabot> Not in scope: `</>'
10:24:31 * pastorn browses som source...
10:24:35 <kmc> :t (System.FilePath.</>)
10:24:36 <lambdabot> FilePath -> FilePath -> FilePath
10:24:47 <kmc> > "foo" System.FilePath.</> "bar"
10:24:47 <lambdabot>   Not in scope: `System.FilePath.</>'
10:24:55 <chrisdone> </> is the best thing since chopped up bread
10:25:04 <jkramer> let me guess, </> = ++ ? :)
10:25:09 <jmcarthur> pastorn: they key to understanding arrows is to ignore them until you know you actually need them
10:25:12 <kmc> no, it adds a separator too
10:25:15 <chrisdone> jkramer: nope! it's plat-form specific
10:25:21 <jkramer> Ah
10:25:23 <jmcarthur> well, s/need/could benefit from/
10:25:32 <chrisdone> woops, push that hyphen along
10:26:23 <pastorn> instance ArrowLoop (->) where
10:26:25 <pastorn>         loop f b = let (c,d) = f (b,d) in c
10:27:31 <jmcarthur> yup
10:28:06 <aristid> :t loop
10:28:07 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
10:28:18 <pastorn> in this case: loop :: ((b,d) -> (c,d)) -> (b -> c)
10:28:31 <aristid> :t loop . uncurry
10:28:32 <lambdabot> forall b d c. (b -> d -> (c, d)) -> b -> c
10:28:48 <pastorn> < loop 
10:29:29 <pastorn> > loop (\(x,b) -> if b then (-x,b) else (x*x, not b)) $ 1
10:29:32 <lambdabot>   mueval-core: Time limit exceeded
10:29:32 <ville> What is a function that accepts a function which turns something to a string and it isn't particularly picky what the something is: f :: ( Something -> String ) -> IO (), in C++ it would be a function template.
10:29:58 <pastorn> ville: printf?
10:30:10 <jmcarthur> ville: foo :: (a -> String) -> IO ()
10:30:18 <solidsnack> ville: I Haskell, that's just another function.
10:30:24 <solidsnack> s/I/In/
10:30:31 <pastorn> @type print
10:30:32 <kmc> :t show
10:30:32 <lambdabot> forall a. (Show a) => a -> IO ()
10:30:33 <lambdabot> forall a. (Show a) => a -> String
10:30:54 <kmc> print = putStrLn . show
10:30:56 <jmcarthur> ville: but the function i just gave you is impossible unless it doesn't use its argument. you at least need to put a constraint on the type variable to be able to do anything useful
10:31:28 <kmc> "Show" is the set of all types with a canonical string representation
10:31:38 <kmc> and "show" is the function that gives you the representation
10:32:25 <kmc> :t \f x -> putStr (f x)
10:32:26 <lambdabot> forall t. (t -> String) -> t -> IO ()
10:32:36 <Gracenotes> @type maybe (return ())
10:32:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
10:32:41 <kmc> no "Show" constraint there because you're using 'f' instead of 'show'
10:32:48 <kmc> :t (putStr .)
10:32:49 <lambdabot> forall (f :: * -> *). (Functor f) => f String -> f (IO ())
10:32:50 <ville> Ok I'd have to name the concept to be able to use the type.
10:32:55 <kmc> ?
10:33:15 <kmc> i don't know what that means
10:33:54 <kmc> how is a function like «(a -> String) -> IO ()» going to do anything useful, if you don't provide a value of type 'a'?
10:34:22 <Gracenotes> you mean previously of C++0x
10:34:29 <kmc> «(a -> String) -> a -> IO ()» is useful (though circuitous)
10:34:42 <kmc> and that's just (putStr .)
10:34:52 <HugoDaniel> what is the current package to be used instead of haskellDB ?
10:35:12 <chrisdone> HugoDaniel: for what?
10:35:14 <Gracenotes> what, database packages? there are a few of them..
10:35:18 <aristid> :t fix
10:35:19 <lambdabot> forall a. (a -> a) -> a
10:35:20 <HugoDaniel> chrisdone: hey :D
10:35:32 <HugoDaniel> chrisdone: i just want to generate some SQL code for my datatype
10:35:34 <kmc> "if A implies A, then A"
10:35:47 <chrisdone> hai :D
10:35:50 <HugoDaniel> class Sql a where toSql :: a -> String  
10:35:52 <HugoDaniel> :P
10:35:58 <HugoDaniel> i would like to avoid that :P
10:36:13 <chrisdone> you want to avoid it why?
10:36:21 <Gracenotes> kmc: that really links bottom and false pretty well...
10:36:31 <Gracenotes> or moderately well
10:36:40 <HugoDaniel> i dont know... i got in my mind that using a combinator lib would probably be a better thing 
10:37:06 <kmc> bbl
10:37:14 <chrisdone> HugoDaniel: it would be cool to see an sql monad
10:37:24 <HugoDaniel> :)
10:38:39 <chrisdone> HugoDaniel: have you seen Ur?
10:38:45 <HugoDaniel> nop
10:40:31 <chrisdone> HugoDaniel: it's pretty awesome. it's a haskell-like language for web programming. it has built in syntax for html and sql with a powerful type system that ensures programs don't go wrong
10:40:40 <HugoDaniel> oh
10:40:46 <Twey> Isn't it dependently-typed?
10:41:33 <chrisdone> Twey: yep
10:41:36 <chrisdone> HugoDaniel: http://www.impredicative.com/ur/demo/sql.ur.html
10:41:53 <jmcarthur> ville: could you paste a C++ version of what you are wanting to do somewhere?
10:42:02 <chrisdone> the nice thing is the schema is defined within the language, so it can ensure compile time correctness
10:43:46 <ville> jmcarthur: actually my Haskell code is probably more appropriate, hopefully, just trying to reduce some boiler plate into a single function
10:43:54 <jmcarthur> okay
10:43:59 <jmcarthur> hpaste.org
10:44:31 <aristid> chrisdone: for some reason that reminds me of xslt.
10:45:33 <HugoDaniel> this seems a bit too much for me :/
10:45:38 <HugoDaniel> i have several datatypes
10:46:06 <chrisdone> HugoDaniel: i'm just linking you because it's interesting, not suggesting you use it
10:46:09 <HugoDaniel> ill just apply the KISS design pattern and define my sql class... 
10:46:39 <HugoDaniel> yes you are!!
10:46:41 <HugoDaniel> :D
10:46:44 <chrisdone> though it's probably the safest way to write a site around
10:46:45 <chrisdone> :p
10:46:46 <ville> jmcarthur: http://codepad.org/ffUIM105 here are the two functions that I wish to make into one. Namely the only things that change are the name of the column ( lines 4 and 17 ) and the type the Gtk.ListStore stores and what function to call on it ( line 7 and 20 ).
10:46:51 <HugoDaniel> hmm
10:47:03 <HugoDaniel> im writing a quick and dirty html form generator
10:47:17 <ville> jmcarthur: That's lot of code to repeat for one column, the tree views have more columns in reality.
10:47:22 <HugoDaniel> i would like it to generate valid SQL along with it
10:47:39 <HugoDaniel> it seems that everything is quick n dirty with me :/
10:47:49 <ville> jmcarthur: So I was going for something like: connect ::  Gtk.ListStore -> Gtk.TreeView -> String -> ( a -> String ) -> IO ()
10:47:49 <chrisdone> HugoDaniel: you're portuguese!
10:47:54 <HugoDaniel> :D
10:47:55 <chrisdone> don't be too hard on yourself :p
10:48:22 <solidsnack> chrisdone: Another tool in that vein is OPA.
10:48:30 <jmcarthur> ville: does GTK.ListStore not expose the type it contains in its own type?
10:48:41 <jmcarthur> ville: i don't know GTK or its bindings
10:49:03 <chrisdone> solidsnack: link?
10:49:31 <solidsnack> chrisdone: http://mlstate.com/opa/documentation_-_introduction
10:49:36 <djahandarie> Has there been something like http://muckandbrass.com/web/display/~cemerick/2010/06/07/Results+from+the+State+of+Clojure,+Summer+2010+Survey done for Haskell?
10:49:37 <narens> hey, say I have a function f that returns an infinte list of things... if i now perform two functions g on f and h on f which read the list till some condition... will haskell recompute from the beginning to pass the input to g and h?
10:49:49 <ville> jmcarthur: Me neither really, my first Haskell program thus far.
10:50:08 <jmcarthur> ville: my inclination without understanding what the code does would be to just copy one of them and replace pieces with parameters, leaving the type signature out entirely. then i would see if the inferred type signature makes sense by checking it in ghci
10:50:53 <mauke> narens: depends on how you do it
10:51:28 <narens> mauke: how so? I know haskell will not recompute if it was a finite list in a where clause and I used it several times... but what about infitie
10:52:40 <mauke> (g (f x), h (f x)) will (probably) recompute the list, let y = f x in (g y, h y) won't
10:52:48 <mreh> is there a strict sum?
10:53:05 <jmcarthur> mreh: if you compile with optimizations then the standard sum will be strictified
10:53:19 <narens> mauke: even if f x returns infinite list? the things that were already generated will not be recomputed?
10:53:24 <jmcarthur> narens: nope
10:53:29 <jmcarthur> it will use the same list
10:53:31 <mreh> jmcarthur: *raises eyebrow*
10:53:37 <jmcarthur> mreh: it's true
10:53:49 <narens> jmcarthur: interesting, thanks
10:54:08 <mreh> jmcarthur: will it be inlined into a tail recursive loop?
10:55:38 <jmcarthur> mreh: ghc will see that the foldl is being used on a strict function (+) and will use the strictness to essentially achieve what you are suggesting
10:55:57 <jmcarthur> mreh: that is assuming, of course, that (+) is strict on the type you are summing
10:56:09 <jmcarthur> it may not be since it depends on the instance of Num
10:56:16 <mreh> jmcarthur: so the arguments need to be rnf for that to happen
10:56:18 <jmcarthur> but if it's Int or something it should work
10:56:21 <jmcarthur> huh?
10:56:35 <jmcarthur> i don't understand
10:56:39 <jmcarthur> why don't you just try it?
10:56:55 <mreh> jmcarthur, I hate it when people say that
10:57:00 <mreh> I suppose so :)
10:57:26 <jmcarthur> ghc has a reasonable strictness analyzer
10:57:49 <jmcarthur> it's not perfect, but sum is a case that it catches
10:58:47 <mreh> what if the list is not in rnf?
10:58:54 <jmcarthur> the list doesn't need to be at all
10:59:10 <mreh> i suppose so
10:59:52 <jmcarthur> the list can even be infinite. you can run a nonterminating sum in constant space with optimizations
11:00:10 <jmcarthur> assuming the result doesn't grow
11:00:29 * hackagebot CHXHtml 0.1.0 - A W3C compliant (X)HTML generating library  http://hackage.haskell.org/package/CHXHtml-0.1.0 (PaulTalaga)
11:00:33 <mreh> naturally, it's the same as a loop
11:00:38 <jmcarthur> right
11:02:08 <jmcarthur> anyway, i'm out
11:02:42 <mreh> there has to be something I'm missing, some excess laziness
11:02:55 <jmcarthur> got a space leak?
11:03:10 <mreh> runtime statistics say it's 84% efficient
11:03:18 <jmcarthur> oh, high GC
11:03:46 <jmcarthur> could just mean you have deep data structures
11:04:02 <mreh> 33 billion bytes
11:04:15 <mreh> oh 21 MB total
11:04:25 <jmcarthur> you could try heap profiling
11:04:37 <jmcarthur> or use regular profiling to see where your time is going
11:04:59 <jmcarthur> anywa, i'm really out now
11:05:17 <mreh> jmcarthur == out
11:07:08 <chrisdone>  True
11:24:19 <aristid> haskell seems to be the favorite syntax to base experimental languages on
11:24:36 <candlefighter> i wonder if you can purify c
11:24:38 <aristid> see agda and also for example http://www-ps.informatik.uni-kiel.de/currywiki/
11:24:48 <candlefighter> that is, take certain parts -- mark them as pure
11:24:53 <aristid> candlefighter: well, put it all in a IO monad, and then the IO is a pure value
11:24:53 <zygoloid> aristid: well, it's an exceptionally clean and simple syntax.
11:24:59 <candlefighter> test them for pureness, then parallelize 
11:25:11 <candlefighter> and by certain parts I mean functions or methods
11:25:29 <aristid> zygoloid: yeah it's reasonable syntax
11:26:06 <zygoloid> aristid: it's more-or-less the minimal set of changes you need from pure lambda calculus to support infix operators. plus case, let and if :o
11:28:16 <mreh> I've just experimented with sum and foldl' and sum is less memory efficient even with optimisation enabled
11:29:25 <c_wraith> yeah...  my benchmarking found that sum is slower than foldl' (+), even with -O2
11:29:36 <ezyang> Blah, why doesn't Ubuntu package hasktags 
11:29:37 <mreh> what gives
11:30:19 <Twey> Because Ubuntu sucks, use Arch?  :þ
11:30:45 <c_wraith> sum is a library function..  It doesn't get recompiled when you change the optimization level.  It's possible that default installs don't use -O2 when compiling it.
11:30:54 <tommd> Does Arch have package signing yet?
11:31:50 <BMeph> With a lazy language, a lot of "special forms" are kicked to the curb, since the reason for their specialness is to delay evaluation of an argument.
11:32:08 * BMeph <3 non-strict evaluation
11:32:37 <dMazz> "Wouldn't a Haskell robot just sit there and be lazy? Or actually, I guess if you told it to do something it would delay doing it until you actually demanded the results. "
11:33:21 <BMeph> dMazz: That's what I do! 8D
11:33:26 <mauke> @quote lecture
11:33:26 <lambdabot> chessguy says: heh. i think i'm officially addicted. i'm chatting in #haskell, helping hack on a haskellwiki page, browing a reddit thread about haskell, while playing a haskell video lecture in the
11:33:26 <lambdabot> background
11:33:30 <mauke> not that one
11:34:21 <ville> jmcarthur: Here's what ghc has to say about the type of the function from earlier: http://codepad.org/hdmx3MYq
11:40:00 <jmcarthur> ville: well there you go :)
11:40:16 <c_wraith> jmcarthur, weren't you leaving?
11:40:21 <jmcarthur> c_wraith: i left
11:40:31 <jmcarthur> i went from work to home
11:40:32 <ville> No idea what half of the stuff there is before => but guess I find out at some point in time
11:51:36 <c_wraith> @hoogle Either a b -> Maybe b
11:51:36 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
11:51:36 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
11:51:36 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
11:53:32 <aristid> :t either Nothing Just
11:53:33 <lambdabot>     Couldn't match expected type `a -> c'
11:53:33 <lambdabot>            against inferred type `Maybe a1'
11:53:33 <lambdabot>     In the first argument of `either', namely `Nothing'
11:53:45 <mtnviewmark> :t either (const Nothing) Just
11:53:45 <aristid> :t either (const Nothing) Just
11:53:46 <lambdabot> forall a a1. Either a1 a -> Maybe a
11:53:46 <lambdabot> forall a a1. Either a1 a -> Maybe a
11:54:17 <mtnviewmark> wonders if there should be a class Maybable m wtih asMaybe :: m a -> Maybe a
11:54:51 <mtnviewmark> and also class Eitherable m with asEither :: b -> m a -> Either b a
11:54:58 <aristid> mtnviewmark: there is Foldable.
11:55:21 <mtnviewmark> but can that be used to convert from on Foldable instance to another?
11:55:32 <aristid> :t Data.Foldable.foldr (<|> . pure) empty
11:55:33 <lambdabot> parse error on input `.'
11:55:48 <aristid> :t Data.Foldable.foldr ((<|>) . pure) empty
11:55:49 <lambdabot>     Ambiguous occurrence `empty'
11:55:49 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
11:55:49 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
11:55:58 <aristid> :t Data.Foldable.foldr ((<|>) . pure) Control.Applicative.empty
11:55:59 <lambdabot> forall (f :: * -> *) a (t :: * -> *). (Alternative f, Data.Foldable.Foldable t) => t a -> f a
11:56:12 <aristid> mtnviewmark: no, but from and Foldable to any Alternative.
12:05:15 <dafis> mreh: ping
12:08:00 <aristid> @hoogle a -> f a -> f a
12:08:01 <lambdabot> Data.Graph.Inductive.Internal.Queue queuePut :: a -> Queue a -> Queue a
12:08:01 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
12:08:01 <lambdabot> Data.Sequence (<|) :: a -> Seq a -> Seq a
12:11:11 <JoeyA> > do {a <- [1..5]; b <- [a | a == 2 || a == 3]; return (a,b)}
12:11:11 <lambdabot>   [(2,2),(3,3)]
12:11:20 <JoeyA> > do {a <- [6..10]; b <- [a | a == 2 || a == 3]; return (a,b)}
12:11:20 <lambdabot>   []
12:12:07 <JoeyA> Is there a way to make it return [(6,Nothing), (7,Nothing), (8, Nothing), (9, Nothing), (10, Nothing)] that works for any Monad or MonadPlus?
12:12:49 <JoeyA> > do {a <- [6..10]; b <- [if a == 2 || a == 3 then Just a else Nothing]; return (a,b)}
12:12:50 <lambdabot>   [(6,Nothing),(7,Nothing),(8,Nothing),(9,Nothing),(10,Nothing)]
12:12:56 <JoeyA> > do {a <- [1..5]; b <- [if a == 2 || a == 3 then Just a else Nothing]; return (a,b)}
12:12:57 <lambdabot>   [(1,Nothing),(2,Just 2),(3,Just 3),(4,Nothing),(5,Nothing)]
12:13:18 <Twey> > repeat empty `zip` [6 .. 10] :: [Maybe Int]
12:13:19 <lambdabot>   Ambiguous occurrence `empty'
12:13:19 <lambdabot>  It could refer to either `Control.Applicative...
12:13:30 <JoeyA> I can do that, but what about any MonadPlus in general?
12:13:32 <aavogt> JoeyA: the Maybe or the list?
12:13:58 <aavogt> as in, which thing is being generalize?
12:14:02 <aavogt> *generalized
12:14:05 <Twey> > repeat mzero `zip` [6 .. 10] :: [Maybe Int]
12:14:05 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
12:14:06 <lambdabot>         again...
12:14:10 <Twey> Ack
12:14:20 <JoeyA> The list
12:15:06 <JoeyA> Here's the context of the problem:  http://codepad.org/uQpMZUsU
12:15:24 <Twey> > flip zip (repeat mzero) [6 .. 10] :: [(Int, Maybe ())]
12:15:25 <lambdabot>   [(6,Nothing),(7,Nothing),(8,Nothing),(9,Nothing),(10,Nothing)]
12:15:29 <JoeyA> err
12:15:50 <JoeyA> char is bound to the first character of a string
12:16:23 <JoeyA> Now, just like in JavaScript, "a"[0][0] exists because subscripting a string yields a string with one character.
12:16:34 <JoeyA> But "string"[0][1] doesn't.
12:16:41 <dafis> mreh: read me?
12:16:55 <aavogt> @type flip execState 6 . Data.Traversable.traverse (do n <- get; put (n+1); return (n,Nothing))
12:16:56 <lambdabot>     Couldn't match expected type `State a b'
12:16:56 <lambdabot>            against inferred type `(s, Maybe a1)'
12:16:56 <lambdabot>     In the first argument of `return', namely `(n, Nothing)'
12:17:14 <Twey> JoeyA: So return it when you substring?  I'm a little confused.
12:17:21 <aavogt> @type Data.Traversable.traverse (do n <- get; put (n+1); return (n,Nothing))
12:17:22 <lambdabot> forall s a a1 (t :: * -> *). (MonadState s ((->) a), Num s, Data.Traversable.Traversable t, Monoid s) => t a -> (s, t (Maybe a1))
12:17:41 <JoeyA> Now, in the code I codepadded, char1 has no results.  Rather than it collapse into nothing, my goal is to get either Nothing, or Just x
12:18:19 <JoeyA> I'm wondering if it's possible to do using the interface provided by MonadPlus, or if it needs more power.
12:18:56 <aavogt> @type put
12:18:57 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
12:20:02 <aavogt> @type flip execState 6 . Data.Traversable.traverse (\_ -> do n <- get; put (n+1); return (n,Nothing))
12:20:03 <lambdabot> forall a a1 (t :: * -> *). (Applicative (State a), Data.Traversable.Traversable t, Num a) => t a1 -> a
12:20:25 <aavogt> @type flip evalState 6 . Data.Traversable.traverse (\_ -> do n <- get; put (n+1); return (n,Nothing))
12:20:25 <lambdabot> forall a a1 a2 (t :: * -> *). (Applicative (State a), Data.Traversable.Traversable t, Num a) => t a1 -> t (a, Maybe a2)
12:22:06 <aavogt> JoeyA: so you want the computation to continue even when char1 would not match?
12:22:12 <JoeyA> Yes
12:22:36 <aavogt> monadplus is sufficient
12:22:57 <aavogt> @type \f -> liftM Just f `mplus` return Nothing
12:22:58 <lambdabot> forall a1 (m :: * -> *). (MonadPlus m) => m a1 -> m (Maybe a1)
12:22:59 <JoeyA> I want it to yield a Maybe JPRef.  If no match, yield Nothing.  If one or more matches, for each match, yield Just x
12:23:37 <JoeyA> Hmm, if I `mplus` return Nothing, will I still get a stray Nothing if there are matches?
12:24:18 <aavogt> @type mzero
12:24:22 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
12:24:41 <aavogt> well it should be   liftM (const Nothing) mzero
12:25:24 <aavogt> JoeyA: in that case, you will never get any Nothing when something matches, provided that your MonadPlus instances follow the rules
12:27:08 <chrisdone> MonadPlus is specifically good for backtracking
12:31:13 <JoeyA> So in liftM Just myMonadValue `mplus` return Nothing, where would you put the liftM (const Nothing) mzero ?
12:31:52 <JoeyA> For instance, in the case of the list monad, I want [] to yield [Nothing] and [5] to yield [Just 5]
12:31:59 <JoeyA> (no nothing in the second one)
12:32:28 <chrisdone> what's the type of your desired function?
12:32:53 <JoeyA> In my actual case, JSONPath (Maybe JPRef)
12:33:07 <JoeyA> In the case of the list monad, [Maybe Int]
12:33:20 <chrisdone> feel free to generalise
12:33:57 <aavogt> JoeyA: instead of return Nothing
12:34:01 <JoeyA> (Monad m) => m a -> m (Maybe a)
12:34:27 <aavogt> because     return a `mplus` return b   doesn't specify which one you get
12:34:50 <JoeyA> char1 <- liftM Just (char #> 1) `mplus` liftM (const Nothing) mzero
12:35:08 <aavogt> @hoogle optional
12:35:09 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
12:35:09 <lambdabot> Text.Parsec.Combinator optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
12:35:09 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
12:35:31 <JoeyA> What I just pasted doesn't work because it's equivalent to liftM Just (char #> 1)
12:35:40 <JoeyA> which yields no results at all when there are no matches.
12:35:45 <chrisdone> > optional (Nothing :: Maybe Int)
12:35:46 <lambdabot>   Just Nothing
12:36:02 <chrisdone> > optional ([] :: [Int])
12:36:03 <lambdabot>   [Nothing]
12:36:30 <chrisdone> is this what you need?
12:36:37 <mreh> it's incredible to see the size of the Core output for something simple
12:36:40 <aavogt> @src optional
12:36:41 <lambdabot> optional v = Just <$> v <|> pure Nothing
12:36:56 <aavogt> hmm, then I was right the first time :)
12:37:26 <aavogt> @docs Control.Monad
12:37:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
12:37:26 <chrisdone> aavogt: i've implemented this function for Parsec-like libraries, hehe. Applicative is great
12:38:01 <chrisdone> what class is (<|>) from, Alternative or some such?
12:38:04 <chrisdone> :t (<|>)
12:38:05 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
12:38:10 <chrisdone> a'ight
12:38:10 <aavogt> which is just like monadplus
12:38:26 <chrisdone> sure. monadplus just has monoid laws, iirc. i don't know what laws if any Alternative has
12:38:35 <aavogt> @docs Control.Applicative
12:38:35 <lambdabot> Control.Applicative not available
12:38:54 <chrisdone> @src Alternative
12:38:55 <lambdabot> class Applicative f => Alternative f where
12:38:55 <lambdabot>     empty :: f a
12:38:55 <lambdabot>     (<|>) :: f a -> f a -> f a
12:38:59 <JoeyA> > do {a <- [1..5]; b <- optional [a | a == 2 || a == 3]; return (a,b)}
12:39:00 <lambdabot>   [(1,Nothing),(2,Just 2),(2,Nothing),(3,Just 3),(3,Nothing),(4,Nothing),(5,N...
12:39:00 <aavogt> @docs Control.Applicative
12:39:00 <lambdabot> Control.Applicative not available
12:39:16 <chrisdone> probably one law: empty <|> x == x
12:40:01 <JoeyA> The optional isn't right here because it returns both 2,Just 2 and 2, Nothing
12:40:13 <chrisdone> or: empty <|> x == x <|> empty == x
12:40:48 <aavogt> chrisdone: isn't the definition of optional also assuming:     pure x <|> pure y = pure x
12:41:01 <JoeyA> <  do {a <- [1..5]; b <- [a | a == 2 || a == 3] <|> [100]; return (a,b)}
12:41:07 <JoeyA> > do {a <- [1..5]; b <- optional [a | a == 2 || a == 3]; return (a,b)}
12:41:08 <lambdabot>   [(1,Nothing),(2,Just 2),(2,Nothing),(3,Just 3),(3,Nothing),(4,Nothing),(5,N...
12:41:13 <JoeyA> ugh
12:41:18 <JoeyA> > do {a <- [1..5]; b <- [a | a == 2 || a == 3] <|> [100]; return (a,b)}
12:41:18 <lambdabot>   [(1,100),(2,2),(2,100),(3,3),(3,100),(4,100),(5,100)]
12:41:46 <aavogt> > [1] <|> [2]
12:41:47 <lambdabot>   [1,2]
12:41:48 <chrisdone> aavogt: for reason i completely missed the 'Applicative f =>' part and *then* thought it was odd that it was missing and thought "i always thought it *was* a subclass", haha
12:41:55 <JoeyA> Same thing.  I'm trying to get something like [(1,100),(2,2),(3,3),(4,100),(5,100)]
12:42:01 <chrisdone> @slap chrisdone
12:42:01 * lambdabot smashes a lamp on chrisdone's head
12:42:07 <chrisdone> alright, not that rough
12:42:26 <JoeyA> Note how the zero case goes away when there's a result
12:42:40 <JoeyA> What I'm trying to do is analogous to a left join in SQL.
12:44:22 <JoeyA> I don't know if it's possible with MonadPlus alone
12:46:52 <JoeyA> A yet simpler, yet less likely to be true question is: given any MonadPlus, can you convert a monadic value to a list?
12:47:06 <JoeyA> In the case of the list monad, you don't have to do anything
12:47:52 <JoeyA> Considering the idea that [1,2,3] can be thought of as having a "result set" containing [1,2,3]
12:48:09 <chrisdone> @hoogle Monad m => m a -> [a]
12:48:09 <chrisdone> @hoogle Monad m => m a -> m [a]
12:48:09 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
12:48:10 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
12:48:10 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
12:48:10 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
12:48:10 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
12:48:11 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
12:48:28 <chrisdone> hmm nice effort, hoogle
12:48:36 <Philippa> JoeyA: you can't, only the other way round, but that should make sense if you think about it
12:50:11 <JoeyA> Or, rather than a list, a monadic value encapsulating that list
12:50:24 <JoeyA> @hoogle Monad m => m a -> m [a]
12:50:24 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
12:50:24 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
12:50:24 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
12:50:40 <JoeyA> @hoogle MonadPlus m => m a -> m [a]
12:50:40 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
12:50:41 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
12:50:41 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
12:51:13 <Philippa> JoeyA: should be even more obvious then, then - you can't even do it in the list monad if you hold the data structure itself abstract
12:51:49 <chrisdone> > let mplusToList mp = mp >>= \x -> return [x] in mplusToList [1..5]
12:51:50 <lambdabot>   [[1],[2],[3],[4],[5]]
12:52:37 <Philippa> wrong shape :-)
12:52:42 <chrisdone> exactly
12:52:58 <JoeyA> Is there a class with the method needed to do that?
12:53:52 <Philippa> not in the mainstream haskell libs
12:53:56 <chrisdone> @hoogle Foldable
12:53:57 <chrisdone> Traversible and Foldable can generate lists, iirc
12:53:57 <chrisdone> i mean, there is literally a function thingToList
12:53:57 <lambdabot> module Data.Foldable
12:53:57 <lambdabot> Data.Foldable class Foldable t
12:54:08 <Philippa> oh, point
12:54:18 <Philippa> basically, you can do it if the monad itself is "sufficiently list-like"
12:54:28 <Philippa> but most monads intentionally hold themselves abstract
12:55:15 <chrisdone> :t toList -- fwiw
12:55:16 <lambdabot> Not in scope: `toList'
12:55:23 <chrisdone> :t Data.Foldable.toList -- fwiw
12:55:24 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
12:55:42 <JoeyA> Thanks
12:55:54 <chrisdone> Philippa: could you say any foldable type is list-like?
12:56:08 <Philippa> chrisdone: given toList, I'd say so, yeah
12:59:22 <alexyk> @src Data.Map.foldlWithKey
12:59:22 <lambdabot> Source not found. I am sorry.
12:59:33 <alexyk> looks like it wasn't there in 6.10?
12:59:49 <chrisdone> @hoogle Data.Map.foldWith
12:59:49 <lambdabot> Data.Map foldWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
13:00:07 <chrisdone> what version is lambdabot's base?
13:00:26 <sclv> couple quick questions -- how can i tell if my ghc is 32 or 64 bit?
13:01:01 <thoughtpolice> sclv: run 'ghc +RTS --info'
13:01:09 <thoughtpolice> and you get ' ,("Host architecture", "x86_64")
13:01:10 <sclv> second, if it produces 64 bit binaries, does this  mean i can't link to c libs that are 32 bit?
13:01:21 <thoughtpolice> sclv: correct
13:01:33 <sclv> is there a way around that?
13:01:48 <thoughtpolice> i don't think so, unfortunately :/
13:01:58 <thoughtpolice> what library in particular are you binding to?
13:02:14 <sclv> a proprietary api
13:02:30 <sclv> the vendor only provides 32 bit linux binaries :-(
13:02:53 <alexyk> so I develop on 6.12 and need to run on 6.10; how can I conditionally employ foldWithKey for the older one instead of foldlWithKey?
13:03:04 <sclv> the java and .net bindings are 64 bit compatible they say, but not c/c++
13:03:18 <sclv> there's got to be some sort of solution...
13:03:34 <keep_learning> bsearch ::Double->Int->Double bsearch n k =fun 1 n where                fun lo hi   | abs(mid-lo)<1e-9 = mid                            | mid^k>n  = fun lo mid                            | otherwise  = fun mid hi                            where mid=(lo+hi)/2                --lo=0                --hi=n   
13:04:10 <alexyk> well there's a foldWithKey in both... is it as fast as fold(l/r)WithKey or what's the story?  http://hackage.haskell.org/trac/ghc/ticket/3999 is not all clear to me
13:04:50 <thoughtpolice> sclv: if you have compat. libs for 32bit on your linux system, you can probably get a 32bit copy of GHC to run without too much effort
13:05:11 <keep_learning> http://pastebin.com/Q1ps0tvV kindly tell mein why this code is working 
13:05:29 <sclv> right -- that means setting up a seperate toolchain for this one binary. ah well. maybe that's the only way.
13:05:34 <keep_learning> if i am not providing lo and hi value
13:06:48 <keep_learning> some one please
13:06:51 <keep_learning> i am stuck 
13:07:05 <keep_learning> how does this program getting the lo and hi value
13:08:30 <djahandarie> It would be nice if there were someway to abstract something like unlines.f.lines  .... as if a function knew its inverse and you could just do (inverse f).g.f
13:08:38 <kyagrd> keep_learning, lo and hi seems to be defined at top level
13:09:02 <kyagrd> on no
13:09:03 <kyagrd> sorry
13:09:21 <kyagrd> is this haskell?
13:09:22 <gwern> djahandarie: sounds like a typeclass
13:09:23 <aavogt> keep_learning: do you know what a function is?
13:09:42 <djahandarie> gwern, well, I mean one that is already in prelude. :P
13:09:55 <kyagrd>  keep_learning, fun is a ML binder not haskell's haskell use backslash
13:09:58 <JoeyA> keep_learning: lo and hi are the parameters to fun, which is defined in the where section.
13:09:59 <keep_learning> aavogt a little bit 
13:10:06 <keep_learning> i am learning 
13:10:08 <Twey> It's hard to write
13:10:26 <JoeyA> So replace "fun" with "notSoFun" and it might make a bit more sense :)
13:10:28 <keep_learning> joeyA yes
13:10:29 <kyagrd> keep_leanring, please first make sure that it is parsed and type checked
13:10:40 <keep_learning> but when i put --lo and --hi
13:10:41 <aavogt> the code does work, kyagrd
13:10:48 <aavogt> it's a question of understanding it
13:10:49 <keep_learning> so program is still working
13:10:49 <Twey> I guess it needs multi-parameter type-classes… but no, even more than that, because you can have more than one function from a -> b
13:10:53 <JoeyA> No, the initial values passed to the function are 1 and n
13:10:56 <gwern> djahandarie: no one is going to hand it to you on a silver platter, no...
13:11:01 <JoeyA> -- is a comment in Haskell
13:11:30 <JoeyA> err
13:11:34 <gwern> djahandarie: maybe you could make a monad out of it, actually?
13:11:37 <gwern> mm, or maybe not
13:11:39 <JoeyA> here, when you uncomment lo=0 and hi=n
13:11:44 <gwern> hard to say what that means in general
13:11:47 <JoeyA> those are distinct from the parameters to fun
13:11:54 <JoeyA> because of lexical scoping
13:12:07 <keep_learning> joeyA so when i uncomment --lo and hi 
13:12:08 <kyagrd> oh, fun is a local function
13:12:08 <JoeyA> You can have 2 variables with the same name and not clash
13:12:21 <kyagrd> I missed where
13:12:21 <keep_learning> then those parameters are passed to the function
13:12:44 <JoeyA> > (\x -> (\x -> x) "inside x") "outside x"
13:12:45 <lambdabot>   "inside x"
13:13:26 <JoeyA> Notice in the example I gave, when x is invoked, it could either refer to the inside or outside \x.  However, due to lexical scoping rules, it uses the inside one and ignores the outside one
13:13:26 <djahandarie> I mean, it'd just be some way to describe inverse morphisms... not sure how that should be done though
13:13:33 <JoeyA> but if I take out the inside one:
13:13:42 <JoeyA> > (\x -> (\y -> x) "inside y") "outside x"
13:13:43 <lambdabot>   "outside x"
13:13:44 <Twey> http://pastebin.com/SxvYnrn8 — less confusing when properly formatted.
13:14:23 <djahandarie> I suppose it'd need to be an isomorphism for what I'm trying to do
13:14:29 <keep_learning> i guess i got a bit 
13:14:35 <Blkt> does anyone know a fairly simple random module for Haskell?
13:14:36 <keep_learning> so i will try to learn more 
13:14:39 <keep_learning> haskell 
13:14:44 <keep_learning> thank you all
13:15:08 <aavogt> @hoogle random
13:15:08 <lambdabot> package random
13:15:08 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
13:15:08 <lambdabot> module System.Random
13:15:17 <aavogt> Blkt: that one is simple
13:15:51 <Blkt> aavogt: thanks
13:17:15 <gwern> djahandarie: I guess you would define a typeclass 'class (Functor b) => Bijective a b where in :: a -> b; out :: b -> a'
13:17:19 <gwern> or something like that
13:17:41 <aavogt> that's a kind error
13:17:48 <gwern> noooo
13:18:29 <gwern> aavogt: then what's right?
13:18:31 <djahandarie> Oooh
13:19:31 <aavogt>  in :: a -> b a; out :: b a -> a
13:20:03 <aavogt> or drop the Functor constraint
13:20:20 <alexyk> djahandarie: see lenses
13:20:22 <gwern> aavogt: and the example of [char] -> [[char]] -> [char]?
13:20:54 <alexyk> djahandarie: google for "pierce lenses"
13:21:45 <aavogt>  instance Bijective [Char] [] where in = words; out = unwords
13:21:50 <alexyk> my executable bailed with: sc: <<loop>> -- wtf?
13:22:09 <gwern> hm. I guess that would work
13:22:15 <aavogt> why would you write a program that would never halt?
13:22:19 <aavogt> that's the real wtf
13:22:24 * alexyk observes that suggesting a random google query slows down scrolling
13:22:28 <gwern> aavogt: obviously he's working with codata
13:22:37 <aristid> aavogt: servers would never halt i guess
13:23:01 <alexyk> aavogt: so it decided it never stops somehow...  hmm
13:23:20 <alexyk> can I ask it where it thinks the loop is?
13:23:40 <aavogt> aristid: or do/should they just execute an infinite sequence of halting computations
13:24:07 <aavogt> the distinction is probably useless
13:24:41 <aristid> aavogt: yeah:)
13:24:47 <gwern> aavogt: I don't think you can execute an infinite sequence of halting computations without it being a loop
13:25:52 * alexyk admires how a practical question with blocking implications triggers a theoretical feast of thought
13:26:43 <aavogt> alexyk: zombies?
13:27:12 <alexyk> aavogt: ?
13:27:16 <gwern> p-zombies are boring. inverse-p-zombies are cool
13:27:53 <alexyk> I literally translated a happily halting Clojure program, and Haskell believes it's a <<loop>>
13:28:04 <alexyk> loop my shiny CPU!
13:28:16 <gwern> ur doin it rong
13:28:20 <ddarius> alexyk: You probably made a typo or translated something like let x = f x too literally.
13:28:24 <Twey> What are ‘inverse p-zombies’?  Something that has no behaviour associated with moral entities, yet still requires moral treatment?
13:29:22 <gwern> Twey: something which acts unconscious, but actually is conscious. imagine when anesthetic only partly succeeds
13:29:34 <Twey> Ick
13:29:39 <gwern> apparently they are extremely difficult to detect...
13:30:00 <gwern> the relevancy of the question is obvious; inverse p-zombies are often traumatized
13:30:20 <dMazz> inverse zombies, Dead 4 The Left
13:31:11 <alexyk> ddarius: that's probably the culprit.  I used to rename it like let x' = foo x, but in many cases Clojure had (let [x (foo x ...) x (moo x ...)] ...) -- so how do I find a possible culprit?  any magic warnings?
13:31:57 <gwern> alexyk: well, profile it, let it run for a while, kill it, and see what the .prof fingers?
13:32:45 <ddarius> alexyk: A warning for unused variable names will usually find it.
13:33:05 <alexyk> okok
13:34:12 <ddarius> When you have something like f x = let x = g x in h x the parameter x is not used.
13:35:22 <mtnviewmark> oy - is code.haskell.org down?
13:36:26 <Twey> Ugh, not again
13:36:34 <mtnviewmark> i can ping it but darcs pull to it just hangs
13:36:47 <aristid> github.com is more reliable :P
13:37:11 <Twey> Yeah, HTTP server looks like it's not responding
13:37:23 <Twey> It really is :-\
13:37:27 <mtnviewmark> bitbucket (but I'm a heathen and prefer hg to darcs)
13:37:37 <gwern> odd. the wiki is up
13:37:57 <Twey> Can't imagine this really reflects well on the fabled stability and reliability we hawk :þ
13:38:01 <mtnviewmark> "Failed to download URL http://code.haskell.org/haddock/_darcs/inventory: Failure when receiving data from the peer"
13:38:18 <Saizan> Twey: well, the server is not in haskell :P
13:38:43 <Twey> Saizan: Sure, but they don't know that
13:38:43 <djahandarie> Can't wait until that Flying Frog guy decides to blog about this
13:38:48 <Saizan> patch-tag is quite stable i think? probably not as many users though
13:38:53 <Twey> djahandarie: Haha
13:39:07 <gwern> djahandarie: actually, he might have a point there - if we can't even keep our servers running, it doesn't speak well of our competency and/or resources
13:39:11 <bitstream0101> I'm trying to build multiset-0.2 under ghc 6.10.4 and get: 'Could not find module 'Data.Data', member of hidden package 'base'.  What am I doing wrong?
13:39:39 <djahandarie> gwern, sure, but I'm sure he'll spin it off to some much higher degree
13:39:55 <gwern> bitstream0101: sounds like it's an old package
13:40:19 <Twey> If he does mention that the server isn't Haskell-based, I suspect he'll be asking why >.>
13:40:20 <Saizan> bitstream0101: try with --preference="base >= 4"
13:40:34 <aavogt> Saizan: shouldn't it be < 4?
13:40:39 <Saizan> bitstream0101: if that doesn't work you'd have to edit the .cabal file
13:40:39 * Twey thinks --preference="base >= 4" should be default now.
13:40:46 <bitstream0101> Saizan: ok, thanks
13:40:52 <djahandarie> But I defeinitely think we need to give a kick in the butt to whoever is working on moving this stuff over to other servers and all involved parties
13:40:59 <Saizan> aavogt: iiuc the problem is that it's using base-3
13:41:13 <djahandarie> definitely* whomever*
13:41:31 <bitstream0101> Saizan: Thanks, that did it =)
13:42:00 <Saizan> bitstream0101: btw, i think you have an old version of cabal-install
13:42:26 <Saizan> "cabal install cabal-install" to upgrade it
13:42:28 <bitstream0101> Saizan: Just realized that =)
13:42:36 <gwern> yo dawg..
13:42:40 <Veinor> I should write a surreal number library.
13:42:50 <djahandarie> Don't do cabal install cabal-install if your package manager handles that, fyi
13:42:58 <Veinor> if only because surreal numbers are awesome :D
13:43:11 <ddarius> I'd be surprised if there isn't some toy surreal number module somewhere.  I'm pretty sure I've seen one or two.
13:43:15 <bitstream0101> djahandarie: this is on a windows box, unfortunately ;P
13:44:41 <gwern> yo dawg, i herd you liek cabal-install so i wrote cabal-install with cabal so you can cabal when you cabal-install
13:45:06 <Veinor> searching for 'surreal' on http://hackage.haskell.org/packages/archive/pkg-list.html finds nothing
13:49:04 <BMeph> gwern: ...so you can cabal install when you cabal-install
13:49:20 <mtnviewmark> @Veinor: look at http://bitbucket.org/mtnviewmark/haskell-playground/src/6cfd9f100c74/Conway/ 
13:49:20 <lambdabot> Unknown command, try @list
13:49:25 <mtnviewmark> several different approaches there
13:49:25 <mtnviewmark> '
13:49:26 * gwern likes saying that word: cabal cabal cabal cabal
13:49:42 <gwern> mtnviewmark: this isn't twitter, your @s are no good here
13:49:59 <djahandarie> gwern, Kabbalah!
13:50:01 <Veinor> oh, well it's no fun if people haven't already done it
13:50:04 <Veinor> *have
13:51:29 <mtnviewmark> oh - but my code is all just toy
13:51:46 <mtnviewmark> please - do it! it's fun, and you probably do a better job of it
13:52:14 <BMeph> Veinor: Want some fun? Write an Io interpreter for me! -- http://bit.ly/ad08W5 describes the language (or notation, rather) :)
13:58:03 <jesusabdullah> Hey #haskell, I'm having promblems installing haskell-platform: http://pastie.org/1001251
13:58:13 <jesusabdullah> If anyone has any ideas, I'd love to hear them :)
14:00:26 <BMeph> jesusabdullah: My idea is: UR DOIN IT RONG! ;þ
14:03:05 <BMeph> jesusabdullah: Hack ./configure, and see if you can make it do --make... ;)
14:04:48 <jesusabdullah> What about this issue of not being able to compile main = putStr "Hello World!\n" ?
14:05:04 <jesusabdullah> I mean, I can runhaskell it fine, but I get the same errors when I try to ghc -o it'
14:05:09 <Saizan> BMeph: --make wouldn't help
14:05:44 <Saizan> jesusabdullah: are you on OS X?
14:06:00 <jesusabdullah> Saizan: Some version of Fedora
14:06:51 <jesusabdullah> Oh, and while I did download and install gmp, the files are not in root--I have them with my user-level prefix
14:07:28 <Saizan> anyhow, googling "Error: suffix or operands invalid for `push' ghc" gives some results wrt ghc-6.10.4
14:07:35 <jesusabdullah> d-oh
14:07:41 <jesusabdullah> why I didn't think to google...
14:08:21 * BMeph also is ashamed
14:09:53 <jesusabdullah> hmm
14:09:56 <jesusabdullah> probably a similar issue
14:10:27 <jesusabdullah> hmm
14:13:17 <dons> gwern: http://vimeo.com/channels/galois#12428370
14:13:17 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
14:13:43 <gwern> that the sel4 talk?
14:13:43 <ddarius> dons: Excellent.
14:13:58 <dons> gwern: no, spivak. the others will follow
14:14:03 <BCoppens> dons: any news on the seL4 talk? :-)
14:14:09 <dons> we've had 160 talks, of which the last 4 or so are videotaped
14:14:14 <dons> each of those will come up in following days
14:14:19 <gwern> oh. oh well, if the pipeline is now working, I can wait
14:14:21 * BCoppens cheers at dons
14:14:21 <dons> but just to let you know, they'll all be on the vimeo channel
14:14:48 <BCoppens> I had often been very annoyed at the fact that all these cool talks were happening, but I couldn't see them :)
14:15:29 <dons> well, the more views we get, the more i can advocate for additional resources to support them.
14:15:38 <dons> so share with your friends :-)
14:16:05 * jesusabdullah will watch later
14:16:06 <BCoppens> dons: resources in the form of money? I'm sure you could get some donations for this kind of stuff :)
14:16:08 * gwern wonders how to download from vimeo
14:16:54 <dons> resources in the form of editing, better microphones, etc
14:17:00 <BCoppens> ah k
14:17:09 <dons> possibly bandwidth too
14:17:12 <gwern> (ack, clive can't download)
14:17:18 <dons> e.g. higher-end vimeo account
14:18:37 <gwern> hm, source doesn't include any flv links...
14:18:40 <BCoppens> gwern: you'd have hoped that with iPads not doing flash, it'd support <video :-)
14:18:49 * BMeph suggests multiple Android phones for A/V support... ;)
14:18:51 <BCoppens> (as the Onion site does these days)
14:19:08 <gwern> I know, I'll watch the HTTP headers. it has to request the video file from *somewhere*
14:19:40 <Ke> vimeo supports html5
14:19:46 <dons> gwern: why not just watch it in your browser?
14:19:51 <dons> offline use?
14:19:53 <gwern> dons: too slow a connection
14:19:59 <dons> ah
14:20:02 <BCoppens> dons: downloading it at uni and watching it on the train :)
14:20:44 <ezyang> dons: I might be able to arrange for hosting downloadable files if you guys do the encoding 
14:20:48 <gwern> interesting, vimeo uses amazon S3
14:21:11 <dons> ezyang: oh i think this is fine.
14:21:16 <ezyang> cool. 
14:21:21 <dons> we don't need to offer services beyond what vimeo does, imo.
14:21:46 <gwern> ooh, I think I found the .mp4
14:22:09 <gwern> yup yup 306M of mp4 goodness
14:22:27 <gwern> http://av.vimeo.com/71427/476/22404287.mp4?token=1276292143_2ea651b5d07f400aad48d24c30b2923f
14:22:44 * edwardk waves hello.
14:22:49 <BCoppens> dons: (another advantage of downloading the MP4 directly is that you don't have to deal with flash :-)
14:22:57 <gwern> times like this that being technically inclined pays off a little
14:23:11 <gwern> a mundane would be helpless to download the video directly
14:23:12 <BCoppens> gwern: probably the token will be a one-time token
14:23:21 <gwern> BCoppens: well, try it and see
14:23:42 <gio123> is there anobody who works in lambda calculus?
14:23:42 <gwern> ah, yeah, it is onetime :)
14:23:54 <BCoppens> gwern: :p
14:25:01 <gwern> BCoppens: you can probably reuse the token though! it'd be a bit harsh for it to truly be one-time
14:25:09 <BMeph> gio123: What's the nature of the Church-Rosser emergency? ;)
14:25:33 <gwern> BCoppens: a user's connection breaks and it has to restart, but oh noes it was onetime and the user has no way to make it do a fresh request! that user is never coming back because vimeo is obviously broken etc.
14:26:42 <BCoppens> gwern: I'd imagine the flash code internally would deal with that? :)
14:26:52 <svk_> Hi, sorry to noob it up, but I'm a bit confused by the System.IO docs -- what's the easiest way to write a ByteString to a file handle?
14:26:55 <gwern> you imagine much
14:27:02 <BCoppens> yeah ;)
14:27:09 <svk_> Performance shouldn't really matter a lot
14:27:10 <earthy> svk: Data.ByteString.hPut
14:27:49 <earthy> (it's not in System.IO... :))
14:27:49 <svk_> Aha, thanks
14:27:58 * hackagebot ad 0.40.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.40.1 (EdwardKmett)
14:28:04 <svk_> Yeah, I'm still getting used to how the modules are organized
14:28:08 * edwardk grumbles about simple bugs.
14:28:18 <BCoppens> gwern: but I have a plan, let me have a closer look at this ;)
14:30:13 <ddarius> edwardk: The last version number I saw was 0.28 I think.
14:30:30 <earthy> svk: it's not always obvious.
14:30:40 <edwardk> ddarius: ah, i slowed down external releases a bit ;)
14:30:46 <edwardk> i picked up gradients along the way though
14:30:48 <earthy> but that goes for Java and .NET as well.
14:31:23 <edwardk> ddarius: i.e. headT $ tailT $ tailT $ tailT $ tensors $ gradients (\[x,y] -> x*sin y) [2,3] ==> [[[0.0,0.0],[0.0,-0.1411200080598672]],[[0.0,-0.1411200080598672],[-0.1411200080598672,1.9799849932008908]]]
14:31:48 <edwardk> which properly only computes the distinct 3rd derivatives and then drops them in the right places
14:33:03 <edwardk> that statement there uses all of my ramblings from the last few days, the stream comonad for the result, the tensors polymorphically recursive data type, the bag-indexed tries, etc.
14:33:23 <aristid> :t headT
14:33:25 <lambdabot> Not in scope: `headT'
14:33:25 <ddarius> edwardk: "bag-indexed tries" ?
14:33:32 <edwardk> and the computational win for the bag-indexed tries turned out to be huge.
14:33:34 <aristid> edwardk: what's headT?
14:33:42 <ddarius> edwardk: So you are saying that the -0.14112... is only calculated once?
14:33:58 <edwardk> aristid: its in Numeric.AD.Types it is how to take the head of a data Tensors f a = a :- Tensors f (f a)
14:34:06 <edwardk> ddarius: exactly!
14:34:16 <ddarius> edwardk: Do you normalize the bags into som kind of list and then use a fairly normal trie?
14:34:35 <edwardk> ddarius basically ;)
14:35:19 <edwardk> so if you go to compute the 16th derivatives of a 5 input function it'll compute 15k'ish distinct values rather than 152 billion
14:35:58 <edwardk> and i'm careful during the construction of the tries to only store the entries that are in ascending order in terms of indices, which becomes a bigger and bigger win as i get farther out
14:36:15 <edwardk> k^n vs. (n + k - 1) choose n
14:37:07 <edwardk> (modulo logarithmic/constant factors, depending on how you price patricia trie lookups)
14:37:23 <gio123> BMeph: hi
14:37:29 <edwardk> aristid: http://hackage.haskell.org/packages/archive/ad/0.40/doc/html/Numeric-AD-Types.html
14:38:03 * hackagebot bluetile 0.4.1 - A modern tiling window manager with a gentle learning curve  http://hackage.haskell.org/package/bluetile-0.4.1 (JanVornberger)
14:38:47 <edwardk> ddarius: i'll be adding Numeric.AD.Mode.Sparse to use the shiny new trie model to compute higher order gradients and other related functions using the sparse model. (it can actually be a win even on first order gradients if you have a fairly sparse formula)
14:39:20 <edwardk> this also creates a lot of incentive for me to get Roman a patch to vector to at least get Data.Vector a Traversable instance so it can be used with my library =/
14:39:48 <ddarius> Is a Vector Traversable instance particularly difficult?
14:39:55 <edwardk> no, its just not present
14:40:04 <edwardk> neither is Functor, Monad, Foldable, etc. 
14:40:14 <edwardk> he agreed to accept a patch, i just have to send one
14:40:36 <dons> instance Monad m => Functor (Stream m) where
14:40:39 <edwardk> Foldable is a touch tricky because the names overlap
14:40:54 <dons> fold = G.fold
14:41:35 <edwardk> dons: well i need traversable on Data.Vector itself so i can do things like grad Vector.sum (Vector.fromList [1,3,...10])
14:42:10 <edwardk> that way the computation can internally use vector fusion, but i can ultimately traverse the output like any other traversable functor
14:43:22 <edwardk> coz more often than not i'm just using traversable to 'bolt on' a bunch of variable indices ot my partials
14:43:28 <edwardk> er or
14:43:49 <edwardk> beyond that internally Vector can work its magic
14:44:47 <edwardk> a future pass will likely include unboxed ad modes, which should play very nicely with DPH, etc.
14:45:08 <edwardk> since data Forward a = Forward a a -- can be unboxed very nicely for floats and doubles.
14:46:35 <edwardk> dons: i noticed that Vector doesn't include the backsubstitution stuff that is in dph to handle Vector (Vector a) -- do you know if that is on the radar or is given up on as an artifact of the current design?
14:46:53 <edwardk> (none of the vector variants seem to support it)
14:53:18 <djahandarie> Is YHC's Javascript backend maintained/used?
14:53:48 <ezyang> iirc, not recently 
14:54:46 <ezyang> see "YHC: compiler errors" 
14:57:36 <noteed> which package provide the X11 backend for cairo?
14:59:22 <ezyang> bleh, I don't really understand rank 2 types, although I understand what they do in the ST monad 
15:01:18 <ezyang> So, I want to use rank 2 types to bind some data to "parent data" 
15:01:37 <ezyang> so I can only use it with that parent, and not another one 
15:01:50 <BCoppens> gwern: meh I think vimeo hates me, it'll be for another time ;)
15:01:54 <ezyang> but I'm not quite sure what the rank 2 types look like, or if I need to introduce a monad to get this 
15:07:23 <noteed> BCoppens, did you try the script at http://ossguy.com/?p=172 ?
15:08:48 <kmc> how's life in haskell-land?
15:08:54 <BCoppens> noteed: nice! it actually works!
15:08:56 <mreh> amazing
15:09:04 <mreh> I learned lots today
15:09:17 <kmc> :D
15:09:18 <kmc> what did you learn?
15:09:28 <BCoppens> noteed: (I had tried another script, which did not work. and my attempts to get vimeo's HTML5 <video> support working did not succeed either)
15:09:51 <BCoppens> noteed: so thanks!
15:09:59 <mreh> how to optimise with explicit loops, and some gcc args to squeeze even more out
15:10:02 <noteed> BCoppens: you're welcome
15:10:10 <kmc> which args are those?
15:10:39 <kmc> by "explicit loops" do you mean something like tail-recursion with an unboxed accumulator?
15:10:54 <noteed> BCoppens: do you see who I am?
15:10:59 <mreh> -optc-O3 and -optc-fno-float-store
15:11:01 <mreh> kmc: yes
15:11:15 <mreh> oh and -funbox-excess-precision
15:11:26 <kmc> funbox
15:11:27 <kmc> cool
15:11:35 <kmc> O3 is as high as gcc goes right?
15:11:37 <BCoppens> noteed: you are someone with a Belgian IP, but I don't see your name if that's what you mean :p
15:11:40 <mreh> kmc yes
15:12:01 <mreh> it takes 10% of the time now!
15:12:15 * hackagebot binary-communicator 1.0.1 - Flexible way to ease transmission of binary data.  http://hackage.haskell.org/package/binary-communicator-1.0.1 (YvesPares)
15:12:16 <noteed> BCoppens: I'm the guy from Namen, we met twice at Ghent FPG
15:12:25 <BCoppens> noteed: :D cool!
15:12:34 <mreh> how much better performace could I expect with the llvm backend?
15:12:54 <BCoppens> noteed: we've almost finished our program for the 3rd meeting btw :)
15:13:37 <noteed> BCoppens, I'm looking forward to it
15:13:56 <mreh> i was suprised how much a few nested (:)s can add to the runtime
15:14:01 <BCoppens> noteed: me too :p
15:14:38 <noteed> BCoppens: I was really happy to see Atze Dijkstra last time
15:14:59 <mreh> any relation?
15:17:44 <noteed> BCoppens: can't you leak some info about the program ?
15:18:40 <BCoppens> mreh: no idea actually :)
15:18:48 <BCoppens> noteed: and yeah I was happy too :p
15:19:24 <BCoppens> noteed: *probably* it'll be the 'yoopf' talk (as suggested on the ml), a short intro to scala, and something by tom schrijvers but I forgot what exactly :)
15:20:30 <BCoppens> noteed: but obviously no guarantees ;)
15:21:34 <noteed> BCoppens: sounds great
15:21:40 <BCoppens> yeah :)
15:23:00 <kmc> mreh, only one way to find out :)
15:23:35 <djahandarie> ezyang, I don't know about your specific problem, but the way I think of rankN polymorphism is as which function gets to pick which type... f :: (forall a . a -> a) -> (Char, Int).... here f doesn't get to pick the type a, but the supplied function gets to pick the type
15:23:35 <noteed> BCoppens: do you know if Atze was happy from its participation?
15:24:14 <ezyang> djahandarie: That makes sense. 
15:24:21 <BCoppens> noteed: mmm I don't know, I hope so (honestly I was a tiny bit preoccupied that evening because I had to leave to the US the next morning :(
15:24:27 <ezyang> I'm not sure if I can wield that into what I'm trying to do though :-) 
15:28:33 <byorgey> djahandarie: isn't it exactly the body of f which gets to choose the type for the supplied function there?
15:28:49 <Utkarsh> any reason why I'm getting '<interactive>:1:0: Not in scope: `sort'' in ghci? (Windows 7)
15:29:03 <byorgey> djahandarie: the supplied function has type (forall a. a -> a), i.e. it must work for any type
15:29:20 * hackagebot CHXHtml 0.1.1 - A W3C compliant (X)HTML generating library  http://hackage.haskell.org/package/CHXHtml-0.1.1 (PaulTalaga)
15:31:24 <djahandarie> byorgey, eh, yeah that came out kinda wrong... I meant to say that the caller of f doesn't get to pick the type a, it has to be supplied by the callee. i.e., f's caller would need to supply a value with the type (forall a . a->a)
15:35:12 <djahandarie> On a semi-related note, it'd be cool if GHC had type lambdas
15:36:54 <djahandarie> Although I don't know how that'd affect type inference...
15:38:13 <Twey> That's the ugliest library I've seen in a while
15:38:14 <ezyang> Ok, so I want to design an ST like monad with semantics like this: computation in the monad is associated with a network, and I should only be able to manipulate objects associated with that network whil in this monad. 
15:38:23 <ezyang> Ok, so that looks a lot like ST, with rank 2 types 
15:38:49 <ezyang> Now, I wonder, what kind of type should this function have: duplicateNetwork :: ? Network -> ? Network 
15:40:43 <djahandarie> Twey, the *ugliest*? It isn't that bad
15:40:57 <jbapple> ezyang: Have you read "modal types for mobile code" by Tom7?
15:41:10 <ezyang> jbapple: Googling 
15:41:51 <ezyang> dude, it's a thesis. :o) 
15:42:18 <Twey> djahandarie: Only in a while
15:42:19 <jbapple> indeed, it is.
15:42:41 <byorgey> djahandarie: I know how type lambdas would affect type inference.  they would make it undecidable.
15:43:19 <byorgey> GHC is definitely not getting type lambdas anytime soon, as cool as it would be in theory
15:43:41 <jbapple> type inference is undecidable in the presence of many existing GHC features
15:44:03 <Twey> Like -XUndecidableInstances?  ;)
15:44:11 <byorgey> well, that's true.
15:44:15 <monochrom> compiler correctness is undecidable at present, too :)
15:44:25 <Twey> Heheh.
15:44:29 <aristid> byorgey: DT is coming up again and again
15:44:45 <byorgey> and why shouldn't it? =)
15:45:09 <monochrom> some people say, "let's use dependent type". now they have two problems.
15:46:05 <djahandarie> byorgey, well, I don't see why explicit foralls would be allowed but not explicit type applications and type lambda
15:46:25 <akR4> hi
15:46:40 <jbapple> djahandarie: explicit type applications are allowed
15:46:55 <byorgey> djahandarie: explicit type applications would be very cool, and are much easier than type lambdas.
15:47:13 <byorgey> jbapple: no they aren't.
15:47:32 <jbapple> byorgey: Data.Set.Set a
15:48:00 <jbapple> is an application of Data.Set.Set, of kind * -> *, to a variable 'a'
15:48:11 <byorgey> jbapple: I think djahandarie meant something like if you have  f :: forall a. Set a -> blah, being able to write   f {Int} set ...
15:48:23 <djahandarie> Yeah
15:48:45 <byorgey> jbapple: of course you can apply types to other types, what you can't do is explicitly provide a type argument to a polymorphic function
15:48:46 <djahandarie> Where you'd currently need to do a newtype and instance
15:48:57 <jbapple> I see. In the example you give, parametric polymorphism would be broken
15:49:28 <byorgey> no, not at all, as long as f is not allowed to pattern match on the type you pass it
15:50:04 <byorgey> every time f is applied it gets instantiated at a particular monomorphic type anyway, this would just give you more control over which one you get
15:50:19 <byorgey> it can be useful in certain strange situations.
15:50:26 <jbapple> If it can't pattern match, then what functions could be written that can't already be written now?
15:50:53 <byorgey> it's not about being able to write new functions, it's about being able to use them better
15:51:05 <jbapple> ok, can you give me an example
15:52:19 <jbapple> Maybe with types like f :: (forall a. Set a) -> blah, rather than f :: forall a . Set a -> blah
15:52:34 <byorgey> hmm... it's hard to think of a good example off the top of my head, it usually comes up when dealing with type-indexed GADTs...
15:53:03 <byorgey> in most "normal" cases, type inference is enough for GHC to figure out what type to instantiate a polymorphic function with
15:53:12 <jbapple> byorgey: well, let me know if you can find an example
15:53:22 <byorgey> sure, I will
15:54:22 <jbapple> Back on type lambdas, I have had some success in cases where I wanted type lambdas by eta-contracting type synonyms
15:54:24 <jbapple> example:
15:54:48 <Heffalump> byorgey: type functions may provide an example
15:54:49 <jbapple> type IntMapFrom = Data.Map.Map Int
15:55:26 <Heffalump> because of the unification problems (X a not unifying with X a if X is a type synonym family, and so even a type signature doesn't work for fixing a type)
15:55:47 <byorgey> Heffalump: hmm, yes...
15:55:57 <jbapple> If you write type IntMapFromLong a = Data.Map.Map Int a, then IntMapFromLong doesn't really have kind (* -> *), and it can't be used as a parameter to instance declarations or types that require something of kind * -> *
16:00:30 * hackagebot regex-base 0.93.2 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-base-0.93.2 (ChrisKuklewicz)
16:00:32 * hackagebot regex-compat 0.93.1 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-compat-0.93.1 (ChrisKuklewicz)
16:01:05 <byorgey> jbapple: right, because type synonyms must be fully applied
16:01:29 <byorgey> technically, IntMapFromLong does have kind * -> * but you just can't ever use it ;-)
16:01:31 * hackagebot regex-pcre 0.94.2 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-0.94.2 (ChrisKuklewicz)
16:02:17 <jbapple> byorgey: Does it have kind * -> *? I thought the type system was specified in such a way that it could not be given that kind
16:02:32 * hackagebot regex-posix 0.94.2 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-posix-0.94.2 (ChrisKuklewicz)
16:03:04 <jbapple> well, GHC says it has kind * -> *
16:03:07 <byorgey> jbapple: I'm not 100% sure, but I think it still has a kind
16:03:08 <jbapple> sorry, GHCi
16:04:30 <jbapple> SPJ's papers page is several years behind
16:04:32 * hackagebot regex-tdfa 1.1.3 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-tdfa-1.1.3 (ChrisKuklewicz)
16:05:04 <byorgey> hehe
16:05:10 <byorgey> he's too busy writing them to update the page =)
16:06:33 * hackagebot regex-posix-unittest 1.1 - Unit tests for the plaform's Posix regex library  http://hackage.haskell.org/package/regex-posix-unittest-1.1 (ChrisKuklewicz)
16:07:22 <byorgey> wow, Chris is on an upload spree
16:07:54 <byorgey> it always takes me such a long time to convince myself that a package is actually ready to upload, I have no idea how anyone uploads six all at once =)
16:21:03 <aakarsh> hi haskell newbie question, I am trying to understand the concept of Just what does it mean to return Just val
16:22:38 <Veinor> aakarsh: okay, Just "foo" has the type Maybe String
16:22:56 <Veinor> so does Just "hi there", Just "what's up?" and Nothing
16:23:11 <aakarsh> ok
16:23:19 <aakarsh> so they are all Maybe
16:23:22 <Veinor> yeah
16:23:27 <mauke> I don't know if it helps, but you can think of Maybe as a list with a maximum length of 1
16:23:33 <Veinor> if x has the type t, Just x has the type Maybe t
16:23:43 <Veinor> and Nothing has the type Maybe t for all t
16:23:50 <Philonous> `Just` is a data constructor. A value of type `Maybe a` is constructed by the values Nothing (i.e. no data provided) or "Just <value of typ a>" 
16:24:14 <mauke> 'Nothing' is like [], 'Just x' is like [x]
16:24:27 <aakarsh> k
16:24:42 <aakarsh> it is a val constructor of Maybe
16:24:51 <Veinor> right.
16:24:55 <Philonous> It is aptly named because a value of type `Maybe String` may encode Just <a String> or Nothing at all. 
16:24:57 <aakarsh> Nothing is a val constructor of Maybe too 
16:25:09 <aristid> yes
16:25:12 <Veinor> if you wanted to write a function that searched a list for an element, it should return a Maybe Int
16:25:22 <Veinor> return Just 3 if it's in the 3rd position, or Nothing if it's not there
16:25:45 <aakarsh> k then we can pattern match on Nothing
16:26:29 <aakarsh> k makes a bit more sense
16:26:58 <aakarsh> thanks all 
16:27:12 <Veinor> no problem.
16:44:54 <trinithis> Is there a better way of writing this function: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26088
16:47:38 <tensorpudding> it might be good to handle non-positive Int
16:48:14 <EvanR> bah thosell never happen
16:48:40 <trinithis> you can also assume largestSize is >= original list size
16:48:54 <EvanR> i wasnt serious
16:49:12 <trinithis> as in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26088#a26090
16:49:14 <tensorpudding> oh, hmm
16:49:20 <tensorpudding> > drop 5 [1..3]
16:49:21 <lambdabot>   []
16:49:43 <altmattr> I am looking to replace the c preprocessor with a haskell libraray (one less dependency), I don't need everything, jut #include and #define.  Does anyone know of a package that might do the job?
16:50:45 <tensorpudding> also bleh, that's a triply-nested list?
16:52:06 <trinithis> yes
16:52:44 <tensorpudding> There is a function which can split lists too, I think
16:53:03 <EvanR> :t splitOn
16:53:03 <lambdabot> Not in scope: `splitOn'
16:53:07 <tensorpudding> @type splitAt
16:53:08 <lambdabot> forall a. Int -> [a] -> ([a], [a])
16:53:16 <tensorpudding> > splitAt 5 [1..3]
16:53:17 <lambdabot>   ([1,2,3],[])
16:53:23 <ddarius> @hackage cpphs
16:53:23 <lambdabot> http://hackage.haskell.org/package/cpphs
16:53:28 <cheater99> hi guys
16:53:31 <tensorpudding> pattern match on that to save some drops and takes
16:53:33 <cheater99> what are 'generics'?
16:53:33 <EvanR> > splitAt (-3) [1..3]
16:53:34 <lambdabot>   ([],[1,2,3])
16:53:36 <cheater99> hi tensorpudding
16:54:04 <danharaj> eww LGPL
16:54:08 <tensorpudding> generics usually refers to types that exhibit parametric polymorphism
16:54:20 <cheater99> via pattern matching?
16:54:36 <tensorpudding> no
16:54:44 <cheater99> then what?
16:54:57 <tensorpudding> you can have generic programming without pattern matching
16:55:06 <cheater99> how?
16:55:09 <mtnviewmark> > takeDrop 3 [1..8]
16:55:10 <lambdabot>   Not in scope: `takeDrop'
16:56:07 <EvanR> cheater99: look at the function length
16:56:08 <mtnviewmark> :t unfoldr
16:56:09 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:56:19 <EvanR> :t length
16:56:20 <lambdabot> forall a. [a] -> Int
16:56:23 <tensorpudding> in Haskell, there are algebraic datatypes and typeclasses
16:56:27 <cheater99> EvanR, i don't know how
16:56:55 <EvanR> it works for any [a], where a is any type
16:57:01 <tensorpudding> a type which is an instance of a certain typeclass will have operations defined over it
16:57:03 <cheater99> that's a generic?
16:58:05 <tensorpudding> length is a generic function
16:58:12 <cheater99> is a point-free defined function a generic?
16:58:24 <hpc> not necessarily
16:58:36 <hpc> in the type of length, a is the generic type
16:58:47 <tensorpudding> the genericity is in the types
16:58:49 <danharaj> polymorphic is more descriptive than the ever nebulous 'generic'
16:59:06 <cheater99> aha
16:59:14 <tensorpudding> compare the function length to genericLength
16:59:17 <tensorpudding> @type length
16:59:18 <lambdabot> forall a. [a] -> Int
16:59:19 <altmattr> darius: how did I miss that?
16:59:23 <tensorpudding> @type genericLength
16:59:24 <lambdabot> forall b i. (Num i) => [b] -> i
16:59:35 <altmattr> ddarius: thankyou very much
16:59:48 <tensorpudding> there is added polymorphism in genericLength because it can return different possible types, any type which is an instance of Num.
17:00:39 <EvanR> whats this function :: (Num i, Traversible t) => t a -> i ;)
17:00:55 <tensorpudding> but anyway, with things like [a], you can use pattern matching to deconstruct the input, and manipulate the bound variables
17:01:09 <mtnviewmark> > let chunk n as = map fst $ takeWhile (not.null.snd) iterate (splitAt n . snd) ([],as) in chunk 3 ['a'..'z']
17:01:10 <lambdabot>   Couldn't match expected type `[(a1, [a])]'
17:01:11 <lambdabot>         against inferred type `(...
17:01:14 <aristid> EvanR: a kind of length?
17:01:18 <tensorpudding> but it doesn't have to be generic
17:01:20 <EvanR> superGenericLength
17:01:39 <tensorpudding> only if the functions you use to manipulate them are
17:02:04 <mtnviewmark> > let chunk n as = map fst $ takeWhile (not.null.snd) $ iterate (splitAt n . snd) ([],as) in chunk 3 ['a'..'z']
17:02:06 <lambdabot>   ["","abc","def","ghi","jkl","mno","pqr","stu","vwx"]
17:02:08 <mtnviewmark> almost!
17:02:40 <mtnviewmark> > let chunk n as = drop 1 $ map fst $ takeWhile (not.null.fst) $ iterate (splitAt n . snd) (as,as) in chunk 3 ['a'..'z']
17:02:41 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
17:02:44 <mtnviewmark> ta da
17:02:57 <Veinor> drop 1 is also known as tail
17:02:59 <Veinor> :P
17:02:59 <mtnviewmark> > let chunk n as = drop 1 $ map fst $ takeWhile (not.null.fst) $ iterate (splitAt n . snd) (as,as) in chunk 3 []
17:03:00 <lambdabot>   []
17:03:08 <mtnviewmark> > tail []
17:03:09 <lambdabot>   *Exception: Prelude.tail: empty list
17:03:12 <mtnviewmark> > drop 1 []
17:03:13 <lambdabot>   []
17:03:15 <Veinor> ah.
17:03:18 <mtnviewmark> so, no, it's not
17:03:22 <Veinor> bah.
17:03:27 <hpc> humbub
17:03:34 <hpc> s/b/g
17:03:54 <Veinor> humgub?
17:03:56 <mtnviewmark> perhaps 
17:04:12 <mtnviewmark> > let chunk n as = drop 1 $ takeWhile (not.null) $ map fst $ iterate (splitAt n . snd) (as,as) in chunk 3 []
17:04:13 <lambdabot>   []
17:04:25 <mtnviewmark> > let chunk n as = drop 1 $ takeWhile (not.null) $ map fst $ iterate (splitAt n . snd) (as,as) in chunk 7 ['a'..'z']
17:04:27 <lambdabot>   ["abcdefg","hijklmn","opqrstu","vwxyz"]
17:04:34 <mtnviewmark> > let chunk n as = drop 1 $ takeWhile (not.null) $ map fst $ iterate (splitAt n . snd) (as,as) in chunk 1 ['a'..'z']
17:04:35 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
17:04:42 <mtnviewmark> > let chunk n as = drop 1 $ takeWhile (not.null) $ map fst $ iterate (splitAt n . snd) (as,as) in chunk 0 ['a'..'z']
17:04:43 <lambdabot>   []
17:04:49 <mtnviewmark> > let chunk n as = drop 1 $ takeWhile (not.null) $ map fst $ iterate (splitAt n . snd) (as,as) in chunk -8 ['a'..'z']
17:04:51 <lambdabot>   Overlapping instances for GHC.Show.Show
17:04:51 <lambdabot>                              (GHC.T...
17:05:04 <mtnviewmark> > let chunk n as = drop 1 $ takeWhile (not.null) $ map fst $ iterate (splitAt n . snd) (as,as) in chunk (-8) ['a'..'z']
17:05:05 <lambdabot>   []
17:05:11 <hpc> > let chunk n as = drop 1 $ takeWhile (not.null) $ map fst $ iterate (splitAt n . snd) (as,as) in chunk 3 [1..]
17:05:12 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
17:05:22 <hpc> oh nice, it is even infinite
17:05:36 <mtnviewmark> the (as,as) is a bit of a hack
17:06:03 <mtnviewmark> > let chunk n as = takeWhile (not.null) $ map fst $ drop 1 $ iterate (splitAt n . snd) (undefined,as) in chunk 7 ['a'..'z']
17:06:04 <lambdabot>   ["abcdefg","hijklmn","opqrstu","vwxyz"]
17:06:07 <mtnviewmark> there
17:06:10 <mtnviewmark> far less hacky
17:06:34 <hpc> will it ever hit undefined?
17:06:55 <mtnviewmark> no - the drop 1 ensures that
17:07:12 <mtnviewmark> and the "undefined" is a signal to programmers that "I know, for sure, that this value won't ever be used"
17:08:04 <hpc> :t iterate
17:08:05 <lambdabot> forall a. (a -> a) -> a -> [a]
17:08:22 <Twey> Because nobody *ever* calls tail [].  ;)
17:09:18 <mtnviewmark> mind you, I have no idea what chunkArb in the original hpastetwo entry was supposed to do....
17:11:19 <gwern> > tail []
17:11:19 <lambdabot>   *Exception: Prelude.tail: empty list
17:15:07 <cheater99> what do you call the notation on slide 5 here? http://www.comlab.ox.ac.uk/people/ralf.hinze/talks/Open.pdf
17:16:17 <ezyang> I'm not sure how to resolve this type error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26091#a26092 
17:16:52 <hpc> cheater99: i haven't seen that notation before
17:17:00 <ezyang> except maybe an unsafeCoerce 
17:17:34 <hpc> unsafeCoerce is never the answer
17:17:39 <cheater99> monochrom, any idea?
17:17:41 <kmc> where's NT defined?
17:17:55 <jbapple> does unsafeCoerce have any run time cost?
17:17:59 <kmc> nope
17:18:03 <kmc> except your soul
17:18:06 <monochrom> monochrom is not here
17:18:07 <jbapple> :-)
17:18:09 <ezyang> oh, I missed that one 
17:18:19 <jbapple> Well, when extracting from Coq, you get to keep your soul :-)
17:18:28 <ezyang> added 
17:18:44 <kmc> cheater99, http://en.wikipedia.org/wiki/Sequent_calculus
17:18:56 <kmc> it's a way of defining logical relations
17:19:00 <kmc> here the downward double arrow
17:19:26 <kmc> each horizontal line is basically an implication written vertically
17:19:36 <gwern> @quote unsafeCoerce
17:19:36 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
17:19:49 <cheater99> ah hm
17:19:52 <benmachine> \o.
17:19:56 <kmc> if each thing above the line is in the relation, then the thing under the relation is too
17:20:07 <kmc> and so your relation is defined as the least set closed under these implications
17:20:35 <kmc> if you read TaPL you will be up to your eyeballs in this stuff by chapter 2 or so
17:20:39 <kmc> and it's a great book ;)
17:22:28 <ezyang> OH! 
17:22:32 <cheater99> thanks kmc
17:22:35 <cheater99> very helpful
17:22:36 <ezyang> It's not complainign about the rank-2 type, it's complaining a != a1 
17:22:53 <cheater99> ok i recognize this now
17:22:56 <cheater99> i have read up on it indeed
17:23:02 <cheater99> a loooong time ago
17:28:04 <jbapple> ezyang: I think it might also be complaining about the rank-2 type
17:28:53 <ezyang> jbapple: I fixed it by getting rid of pattern matching. 
17:29:16 <dolio> ezyang: If the argument has type "forall a. F a", you can't match against it as if it were "F a".
17:29:16 <ezyang> revision posted 
17:29:28 <ezyang> dolio: Why not? 
17:29:37 <jbapple> I asked about pattern matching on forall-quantified types on one of the mailing lists a couple of years ago
17:29:42 <dolio> Because you need to instantiate it to a specific a first.
17:29:52 <ezyang> Hmm. 
17:29:55 <jbapple> I think SPJ said something like : "eh, it's not worth the trouble"
17:30:03 <Rikardo3> does anybody knows how to create a mouse listener in haskell for OpenGL something like KeyboardMouseCallback
17:30:10 <ezyang> I guess that makes sense 
17:30:19 <Rikardo3> or passive motion ?
17:30:24 <ezyang> Assigning it to an actual variable means it gets instantiated, while pattern matching skips it. 
17:30:32 <dolio> Down in some core theory, it's like matching against /\a -> e as if it were just e.
17:30:45 <dolio> You need to apply it to something before you get the right type to match against.
17:30:57 <dolio> Not that it couldn't be done, but GHC doesn't do it.
17:31:26 <jbapple> SPJ: "I grant that arguably these should work, but I think it'd be quite tricky to make it do so, because it'd involve re-generalising in the pattern.  Furthermore, I can't see any use for it.  Just remove the type signature from the pattern."
17:33:01 <kmc> Rikardo3, that's not the responsibility of OpenGL, but rather whatever windowing / GUI library you're using
17:33:10 <kmc> e.g. GLUT, SDL, GTK
17:33:56 <kmc> Rikardo3, GLUT callbacks are documented here http://hackage.haskell.org/packages/archive/GLUT/2.2.2.0/doc/html/Graphics-UI-GLUT-Callbacks-Window.html
17:34:32 <Rikardo3> kmc, thx
17:39:44 <Rikardo3> kmc, passiveMotionCallback is excatly what I was looking for ;-)
18:14:12 <interferon> trying to build ghc for the first time and i get this strange error on my macbook: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26095#a26095
18:14:23 <interferon> looks like my "head" command is incompatible?
18:14:51 <interferon> hmm, i see.  nevermind, it's running a perl command called "head"
18:27:19 <mreh> ho can strictness possibly slow things down? I removed some bang patterns from some constants in a function, and the thing sped up!
18:27:43 <ddarius> mreh: Sure it can.  Arbitrarily much.
18:28:21 <dolio> > (const $! length [1..]) 5
18:28:24 <lambdabot>   mueval-core: Time limit exceeded
18:28:25 <dolio> > (const $ length [1..]) 5
18:28:29 <lambdabot>   mueval-core: Time limit exceeded
18:28:33 <ddarius> flip
18:28:38 <dolio> Oh, right.
18:28:46 <dolio> > const 5 $! length [1..]
18:28:50 <lambdabot>   mueval-core: Time limit exceeded
18:28:51 <dolio> > const 5 $ length [1..]
18:28:51 <lambdabot>   5
18:29:00 <ddarius> Or with magic:
18:29:08 <ddarius> > 5 $! length [1..]
18:29:11 <lambdabot>   mueval-core: Time limit exceeded
18:29:13 <ddarius> > 5 $ length [1..]
18:29:14 <lambdabot>   5
18:29:20 <dolio> Oh right. Forgot we had that.
18:29:23 <mreh> witchcraft
18:29:54 <blackdog> more practically: if you're writing something that could be modelled as a stream, making it strict will cause you to read the whole thing in at once, which could blow out memory usage and locality
18:30:32 <mreh> they're just constants used occasionally in some loops
18:30:37 <mreh> bounds for the loops
18:30:49 <mreh> they're calculate from the arguments
18:33:11 <mreh> with laziness you share the values through graph reduction, but if a value is strict, that doesn't invalidate that right?
18:33:22 <mreh> it's still part of the structure of some graph
18:33:38 <benmachine> with laziness stuff is evaluated at most once
18:33:49 <benmachine> is my understanding
18:34:04 <benmachine> strict can make that 1 instead of 0 but not 2 instead of 1
18:34:23 <mreh> very curious
18:34:26 <mreh> wanna see?
18:34:32 <benmachine> curiouser and curiouser
18:34:35 <benmachine> sure why not
18:34:35 <mreh> I get a factor of two increase in speed
18:34:47 <benmachine> done any profiling?
18:35:04 <mreh> benmachine: lots
18:35:07 <benmachine> do more
18:35:12 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26096#a26096 -- my gaussian kernel evolves
18:36:16 <benmachine> maybe some rewrite rules are only correct with lazy arguments?
18:36:21 * benmachine wild speculation
18:36:33 <aristid> :t unsafeAt
18:36:34 <lambdabot> Not in scope: `unsafeAt'
18:36:54 <mreh> aristid: look in Data.Array.Base
18:36:58 <mreh> it's *secret*
18:37:09 <benmachine> :t Data.Array.Base.unsafeAt
18:37:10 <lambdabot> forall (a :: * -> * -> *) i e. (Data.Array.Base.IArray a e, Ix i) => a i e -> Int -> e
18:37:11 <mreh> actually read about unsafeAt on the wiki, it explains it
18:37:44 <mreh> benmachine: I'll profile, but I think it wont shed much light on it, optimisations are disabled as soon as a profile
18:37:51 <mreh> I profile*
18:38:10 <aristid> mreh: why don't you use the (!)?
18:38:21 <mreh> aristid: unsafeAt is better
18:38:24 <mreh> but unsafe
18:38:27 <benmachine> disabled?
18:38:39 <aristid> mreh: why is it better?
18:38:39 <mreh> benmachine: aren't optimisation disabled?
18:38:39 <benmachine> I find stuff runs slower when optimised but I assumed that was not stuff being disabled
18:38:44 <benmachine> just profiler overhead
18:38:58 <mreh> aristid: there's no bounds checks performed
18:39:04 <benmachine> mreh: that's not something I've heard and would be pretty weird
18:39:10 <benmachine> but maybe it's true
18:39:16 <mreh> (!) does some bounds checking and then calls unsafeAt itself
18:39:34 <mreh> after converting your Ix value into an Int
18:39:47 <mreh> so you can do that step yourself, unless you're already indexing with Ints
18:40:01 <mreh> speeds things up a lot
18:40:23 <mreh> good for tight loops
18:40:44 <mreh> what is a CAF?
18:40:57 <aristid> mreh: i'd expect the optimising compiler to do a lot of that already
18:41:32 <mreh> aristid: it's not something the optimiser can do, it's unsafe, so it could cause the thing to crash if used unwisely
18:41:47 <mreh> *crash*
18:41:51 <aristid> mreh: well, it can move the bounds check outside the tight loop
18:41:52 <benmachine> CAF = constant applicative form
18:42:15 <benmachine> I believe it's a top-level binding that is only evaluated once (because it has no arguments)
18:42:21 <mreh> aristid: I wish it were clever enough to infer those kinds of things, but you can do that yourself
18:42:23 * benmachine browsing http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/profiling.html
18:43:42 <benmachine> mreh: no obvious mention of optimisations either way
18:44:07 <mreh> benmachine: the overheads must be big then
18:44:08 <danharaj> 01Is SPJ's book on implementing functional languages still decently modern?
18:44:20 <benmachine> mreh: well, sure
18:44:35 <benmachine> would you expect anything else?
18:44:40 <manju> hello
18:44:46 <mreh> yes, but I have no idea what I'm talking about
18:44:49 <benmachine> :D
18:44:50 <benmachine> hi5
18:44:51 <mreh> like most people who complain
18:45:06 <benmachine> s/who complain//
18:45:12 <manju> I am getting a state using x0 <- get (x state)
18:45:22 <manju> is this considered IO ?
18:45:37 <benmachine> allow for the possibility that everyone else is as stupid as you
18:45:38 <aristid> talking about things that you have no clue about is fun
18:45:51 <benmachine> manju: not enough information provided
18:45:58 <benmachine> manju: where'd you get that get function?
18:46:06 <benmachine> what does x do?
18:46:08 <benmachine> what is state?
18:46:34 <reified> danharaj: do you mean this ancient book: http://www.amazon.com/Implementing-Functional-Languages-Prentice-Hall-International/dp/0137219520
18:46:37 <manju> one min let me dig the documentation up
18:46:58 <danharaj> reified: Is there any other by spj?
18:47:05 <benmachine> manju: whether stuff is IO or not is usually easy to tell from the type signature
18:47:13 <benmachine> e.g. :t get in ghci
18:47:23 <benmachine> with the appropriate modules loaded
18:47:37 <manju> ah...
18:49:25 <reified> danharaj: http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
18:49:30 <manju> get :: (HasGetter g) => g a -> IO a
18:49:35 <manju> hmm...ok
18:49:40 <manju> so next question
18:49:52 <manju> If I write a wrapper function around this
18:49:54 <manju> like
18:50:08 <danharaj> reified: those are the same book, no?
18:50:29 <manju> nevermind
18:50:41 <manju> I think it is better I try it first
18:51:13 <benmachine> manju: I like that attitude :D but you're welcome to come back when you have
18:51:34 <benmachine> (or before, even!)
18:57:48 <dolio> quicksilver: I think it's time you wrote that "overlapping instances don't do what you want" rant on haskell-cafe.
18:58:33 <benmachine> I like that rant :)
18:58:44 <manju> ok I have a do in a function
18:58:57 <manju> can make the do go to another function ?
18:59:15 <manju> like a = do <something>
18:59:30 <manju> a = b and b = do <something>
18:59:41 <manju> or do I need a do in a also ?
18:59:51 <manju> like a = do b
19:00:20 <benmachine> manju: if 'x' is a single statement (or expression) then 'do x' is exactly the same as 'x'
19:00:48 <benmachine> manju: e.g. thing = do putStrLn "blah" is the same as writing thing = putStrLn "blah"
19:00:52 <aristid> :t \x -> do x
19:00:54 <lambdabot> forall t. t -> t
19:00:56 <benmachine> I prefer the latter
19:01:02 <benmachine> aristid: hah, neat
19:01:21 <manju> I've written a function, it is working
19:01:23 <aristid> benmachine: it doesn't even enforce a monad
19:01:28 <manju> but it is so cluttered
19:01:32 <benmachine> > do 4
19:01:33 <lambdabot>   4
19:01:36 <benmachine> how about that
19:01:50 <stepcut> I am looking for a parser that will parse lazy bytestrings and return the results lazily. But it seems the parsers want to parse the whole document so they can return something like, Ok a | Failure String. Am i missing on that does 'online parsing' ?
19:01:55 <manju> so I want to clean it up, but I don't know where to remove the do's and where to put them
19:02:00 <aristid> manju: you can split it, and you can have do in do
19:02:07 <manju> aristid, ok
19:02:24 <tensorpudding> if you don't know when to use do-notation, you're probably not understanding what do-notation is.
19:02:31 <benmachine> manju: if you put the function on hpaste.org or something we'll be able to offer more specific advice
19:02:47 <aristid> tensorpudding: should beginners restrict themselves to >>=?
19:02:48 <manju> benmachine, ok...hang on
19:02:51 <benmachine> stepcut: this is something that gets asked a lot, but I forget what the answer is
19:02:59 <manju> aristid, which is what I am trying
19:03:01 <benmachine> stepcut: I'm helpful, right?
19:03:05 <tensorpudding> aristid: no, they can learn do first
19:03:13 <manju> to convert do to >>=
19:03:15 <tensorpudding> but they should learn what it means
19:03:25 <tensorpudding> at least, they should know the types
19:03:30 <benmachine> nah
19:03:35 <benmachine> well
19:03:37 <stepcut> benmachine: I believe UU parser is one..
19:03:37 <benmachine> I dunno
19:03:38 <benmachine> maybe
19:03:44 <benmachine> stepcut: rings a vague bell
19:03:59 <benmachine> I'm disinclined to tell people what they should or should not know
19:04:15 <aristid> @undo do x <- [1,2,3]; return (x+1)
19:04:15 <lambdabot> [1, 2, 3] >>= \ x -> return (x + 1)
19:04:18 <benmachine> especially early on in their education, people learn things in different ways
19:04:28 <aristid> manju: @undo can do that
19:04:29 <benmachine> it's all just a way of entertaining you until you Really Get It
19:05:14 <Gracenotes> why is it that GHC complains that I haven't used 
19:05:21 <tensorpudding> maybe it's true that there is no one right way to teach it.
19:05:26 <Gracenotes> er. let me complain about my IRC client now :/
19:05:42 <Gracenotes> it says "Imported from `Control.Monad' but not used: `msum'", and when I remove the import, it says "Not in scope: `msum'"
19:05:53 <gwern> has anyone GHC even so far as to go some
19:06:18 <tensorpudding> gwern: what you say?
19:06:43 <Gracenotes> this is counter intuitive behavior
19:06:43 <manju> tensorpudding, I vaguely understand where to use do
19:06:52 <gwern> tensorpudding: we accidentally your entire base you have no time
19:07:01 <Gracenotes> a naive Haskell-source-fixer would get stuck in an infinite loop
19:07:04 <Gracenotes> this is unacceptable
19:07:13 <benmachine> Gracenotes: heh, ouch
19:07:24 <manju> tensorpudding, I am trying to concretize my understanding and I am not very good at learning from books, I learn better through experimentation
19:07:38 <benmachine> Gracenotes: well, if msum is only used in unused code as it were, you can get that error
19:07:49 <Gracenotes> manju: that's what... urgh, can't do it
19:08:01 <gwern> Gracenotes: hm, I've run into issues where used code got reported as unused. maybe that's what's happening here
19:08:09 <gwern> -Wall is not perfect
19:08:14 <benmachine> manju: the rules for converting between do and normal syntax are quite simple and can be applied mechanically
19:08:17 <manju> Gracenotes, can't do what ?
19:08:28 <benmachine> manju: make a silly joke :P
19:08:34 <gwern> @undo foo >>= \x -> f x
19:08:34 <lambdabot> foo >>= \ x -> f x
19:08:39 <gwern> @do foo >>= \x -> f x
19:08:40 <lambdabot> do { x <- foo; f x}
19:09:13 <manju> heh...ok
19:09:31 <Gracenotes> gwern: that seems to be the case.. it seems silly to be warn twice about code not being used though, particularly when the second warning has the implied meaning of "this is not used *anywhere* in the source file"
19:09:36 <gwern> see? mechanical
19:09:44 <aristid> @do a >>= b
19:09:44 <lambdabot> do { c <- a; b c}
19:09:51 <manju> http://github.com/manjunaths/Mass-Spring-Simulator/blob/master/skel.hs
19:10:00 <gwern> ...or is it? maybe lambdabot shells out to Amazon Mechanical Turk, where a legion of dead-end grad students pounce on every haskell job
19:10:05 <manju> in this I have a function called motion
19:10:11 <manju> and it looks ugly
19:10:16 <manju> I am trying to beautify it
19:10:26 <manju> nevermind that it is not completely working
19:10:35 <Gracenotes> any Haskell beauticians in the house
19:10:40 <gwern> Gracenotes: well, -Wall tries to report all issues, not just some issues. it's not like hlint, it doesn't want to put you through your paces
19:10:55 * edwardk waves hello,
19:11:10 <Gracenotes> manju: it looks okay... GLUT code is necessarily ugly, I think
19:11:17 <manju> Gracenotes, ok
19:11:52 <Gracenotes> though you might want to make a quaternion datatype if you're abstracting over it - your decision though
19:12:18 <Gracenotes> the unfortunate part about graphics is that the real thing you often want to abstract over is dimension
19:12:36 <manju> Gracenotes, I know, I just wanted quick results, for you know instant gratification :-)
19:12:53 <manju> my first ever haskell code with a main in it!
19:12:58 <Gracenotes> for me, at least. And you end up doing some task for x, and then the exact same thing for y, and then z, etc.
19:13:03 <edwardk> Gracenotes: sadly quaternions do not generalize to other dimensionalities ;)
19:13:35 <blackdog> i'm having a bit of trouble working with exceptions thrown from pure code. If you have something of type a, how do you know what exceptions it might throw when it's evaluated? I can't even seem to bind it without knowing that.
19:13:38 <manju> Gracenotes, also quaternions are useful (in my case) only for the trackball
19:13:38 <Gracenotes> yes, that is true. I mean, looking at his code - http://github.com/manjunaths/Mass-Spring-Simulator/blob/master/skel.hs - and most other graphics code, there's a line for x, line for y, ...
19:13:44 <wli> sedenions?
19:14:42 <manju> I feel kind ashamed of my code, but it is the first cut
19:14:43 <Axman6> blackdog: don't you just try and catch SomeException e?
19:14:50 <Gracenotes> blackdog: depends on what functions you pass it though..?
19:14:58 <Gracenotes> i.e. partial functions
19:15:24 <edwardk> wli: well you lose all the useful structure as you go to octonions and sedenions ;) which is kind of the point. the nice thing about quaternions is you can use unit quarternions to model rotation matrices in 3d, you don't get any such relationship with the 2 slightly large cousins of quarternions.
19:15:34 <blackdog> for concreteness: i have " try(evaluate $ decompress $ pack "foo")
19:15:35 <edwardk> er s/large/larger/
19:15:47 <Gracenotes> for an arbitrary type, catching is the only way surely :/
19:16:30 <Randroid> I've been learning J and Haskell. I prefer Haskell, but find J *very* interesting. Any of you Haskellers have an opinion on it? (Yes, it's syntax looks daunting, but once you learn it it's not so bad.)
19:16:37 <Randroid> *its
19:16:42 <edwardk> sedenions have no commutativity, no associativity, not even that weirdly weak alternativity thing you get with octonions
19:16:43 <blackdog> Gracenotes: sure, but what exception do you catch? it seems to want to return Either *something* ByteString
19:16:43 <Gracenotes> edwardk: I did a game in C++ last semester where some of the physics code had a 30-line block for x, then a nearly identify 30-line block for y
19:17:03 <edwardk> Gracenotes: as someone who used to work in that industry i find this unsurprising ;)
19:17:15 <Gracenotes> SomeException is an instance of Show
19:18:01 <Gracenotes> so if you're concerned with catching it and otherwise forgetting about, it can be Either String ByteString, maybe
19:18:04 <blackdog> oh, SomeException was a literal type. sorry, i thought it was an example. cheers Axman6/Gracenotes
19:18:42 <Axman6> i'm not sure how you'd deal with trying to catch only exceptions of a specific type
19:18:51 <Axman6> i should learn more about exceptions in haskell
19:19:39 <blackdog> Axman6: a generic exception is exactly what i wanted.
19:19:51 <blackdog> i get a bit skittish about exceptions thrown from pure code
19:19:58 <Axman6> yeah
19:20:07 <blackdog> it feels like someone promised me a pony and delivered me horseshit
19:20:19 <benmachine> heheh
19:20:40 * Axman6 thinks dons needs to write a nice blog post about how to use exceptions in haskell, since he seems to think they're great for asynchronous communication
19:21:03 <danharaj> There's like a dozen different ways of doing exception-style error propagation in Haskell.
19:21:29 <blackdog> the best thing about standards ...
19:23:25 <blackdog> so the zlib decompress/compress stuff - it makes perfect sense that compress should be ByteSTring -> ByteString
19:23:35 <blackdog> but decompress should be a Maybe, surely.
19:23:59 <blackdog> (although i suppose a really good decompression format would have no illegal sequences:)
19:24:17 <temp> I should remember this but how do you do f(f(f(f(x)))  ie f^y(x)
19:24:34 <Axman6> iterate f x !! y
19:24:37 <edwardk> iterate f x !! y
19:24:41 * Axman6 wins
19:24:43 <edwardk> hah
19:24:47 <blackdog> Axman6: fastest draw in the west
19:24:53 <Axman6> pew pew!
19:24:54 <gwern> blackdog: disallowed sequences are bloat!
19:24:58 <Gracenotes> the other semicanonical one is foldr (.) id (replicate y f)
19:25:10 <benmachine> appEndo . foldMap Endo $ replicate n f
19:25:20 <benmachine> er, y, right
19:25:29 <blackdog> gwern: well, exactly. but if you ask zlib to decompress a random string, it usually complains
19:26:04 <gwern> tsk. I bet all those headers and whatnot zlib expects soak up entire bytes!
19:26:12 <blackdog> anyway, zlib's still not working for me in hubris because ruby gets confused by embedded nulls in strings, but at least it's throwing a well-behaved exception rather than just dirtying its nappy now.
19:26:28 <blackdog> gwern: the libjudy guy would be outraged.
19:26:47 <gwern> won't someone think of the caches?
19:27:39 <JuanDaugherty> hubris is ruby-haskell FFI?
19:27:47 <blackdog> JuanDaugherty: yeah
19:28:08 <danharaj> why do people like to choose nondescriptive names for their libraries.
19:28:12 <blackdog> some stupid bastard wrote this crappy implementation, and i've been trying to fix his code ever since.
19:28:27 <danharaj> blackdog: sounds like ruby development to me ;D
19:28:30 <blackdog> danharaj: because it's memorable.
19:29:09 <JuanDaugherty> it sounds like a bad idea, but in principle it could be carried out
19:29:23 <JuanDaugherty> best in a general interlang context though
19:29:32 <gwern> danharaj: what would you name it? 'ruskell'?
19:29:56 <ddarius> iterate f x !! y is not ideal (for multiple reasons)
19:29:57 <JuanDaugherty> the name style itself is dead on
19:30:01 <danharaj> gwern: I am not good at this but, oh how about hRuby? Seems to be a popular method of naming libraries.
19:30:20 <JuanDaugherty> you can't top hubris, don't even try
19:30:22 <blackdog> I did actually think about "raskell" or "rascal"
19:30:29 <blackdog> but somebody else took it first
19:30:38 <blackdog> JuanDaugherty: cheers:)
19:30:44 <benmachine> danharaj: sounds weird
19:30:44 <ddarius> iterate f x !! y == recipe for stack overflows
19:30:56 <blackdog> JuanDaugherty: why does it sound like a bad idea, btw?
19:30:57 <danharaj> JuanDaugherty: If you mention hubris to me in the context of programmers I think of alpha male programmers who don't bathe and love taking a shit on other people's code.
19:31:07 <benmachine> ddarius: rly? how so?
19:31:34 <JuanDaugherty> i have defintely been bathing at least every other day now for several weeks
19:31:35 <benmachine> ddarius: if we assume that f is non-strict, is that way worse than any other?
19:31:39 <gwern> hm, 'hasby' might work
19:31:50 <ddarius> benmachine: If f is non-strict, then it will be fine.
19:31:53 <gwern> only 83k google hits
19:32:08 <benmachine> ddarius: how about sometimes-but-not-usually non-strict
19:32:09 <danharaj> What about FFI.Ruby
19:32:18 <ddarius> benmachine: Then it will not be fine.
19:32:29 <benmachine> ddarius: hmm
19:32:35 <ddarius> benmachine: Depending on how "unusually" it is non-strict.
19:32:36 <blackdog> danharaj: it's a marketing thing, to be completely honest.
19:32:41 <benmachine> ddarius: you'd use a strict accumulator or something?
19:32:56 <JuanDaugherty> all ruby shit is marketing
19:32:59 <danharaj> blackdog: I suppose. I'm just ranting because I like knowing what a library is by its name.
19:33:00 <blackdog> and you're thinking about it from a Haskeller's perspective. bridge projects are inherently two-world.
19:33:01 <dolio> > iterate (1+) 0 !! 1000000
19:33:01 <gwern> JuanDaugherty: can't top 'hubris'? quite a hubristic statement
19:33:02 <lambdabot>   *Exception: stack overflow
19:33:24 <dolio> You need a !!! that evaluates everything along the way.
19:33:31 <blackdog> gwern: i have to squeeze something from ozymandias into the release notes
19:33:31 <ddarius> benmachine: The solution I think is best in this case is to use an iterate for a head-strict list type.  However, there are two other (classes of) solutions.
19:33:36 <JuanDaugherty> or I guess you could say market oriented, market guided, something like that
19:33:40 <ddarius> dolio: That's one of the other classes.
19:33:51 <ddarius> dolio: Alternatively, you could have an iterate that forces things as it builds.
19:34:00 <dolio> Yeah, that works, too.
19:34:16 <blackdog> JuanDaugherty: and you can see how successful it's been for them. objectively speaking, haskell code is shorter, safer and orders of magnitude faster, but RoR has name recognition even from non-technical types.
19:34:31 <JuanDaugherty> yes, because it's a hubristic attempt to merge two already hubristic langs
19:34:32 <gwern> blackdog: look upon my exceptions and despair ye programmer...
19:34:35 <benmachine> so basically you calculate f(x) then f(that) then f(that) the necessary number of times?
19:34:53 <JuanDaugherty> that futhermore clash philosophically compounding the hubris
19:35:00 <danharaj> look upon my Monads ye programmers and despair.
19:35:15 <gwern> danharaj: no. god no
19:35:30 <danharaj> gwern: You don't like my monads? :(
19:35:34 <benmachine> warm, fluffy things
19:35:39 <blackdog> JuanDaugherty: i've thought about that quite a lot, actually. there'd be almost no point writing a bridge between ocaml and haskell. languages have to be different to make them worth bridging
19:35:43 * Rotaerk kicks danharaj in the monads.
19:35:50 <gwern> that's fine when the joke is 'my monads, let me show you them'. but don't sully bryron!
19:36:11 <benmachine> *fuzzy things
19:36:11 <gwern> no
19:36:21 <danharaj> Was that Byron? For some reason I recalled that as a Coleridge poem.
19:36:26 <danharaj> It's been a while.
19:36:42 <benmachine> languages have to have different libraries written for them to make them worth bridging?
19:36:57 <danharaj> Wait no, the internet says it was a Shelley poem DAMMIT
19:36:59 <danharaj> I am uncultured.
19:36:59 <ddarius> benmachine: Incidentally, for iterate, since f is always the same function, it is either always strict or always non-strict.
19:37:03 <blackdog> you both suck, it's Shelley.
19:37:04 <gwern> well, let's check
19:37:13 <gwern> I remember the poem as having more guts than coleridge would put in, though
19:37:15 <benmachine> ddarius: oh, true I guess
19:37:29 <gwern> benmachine: well, if they have the same libraries, why use the one?
19:37:31 <blackdog> benmachine: i'd say they need to have different outlooks
19:37:51 <benmachine> ddarius: hmm, unless it was e.g. a function from lists to lists, in which case it might be strict up to the first cons if the first element is 0, or something
19:37:58 <danharaj> What can a Haskell program gain from Ruby FFI?
19:38:21 <gwern> blackdog: well, at least shelley was a friend of byron! closer than coleridge
19:38:29 <danharaj> Hey, they all lived in the same time period.
19:38:58 <benmachine> danharaj: if you have some pre-existing ruby system and you want to write some extension to it, it'd be nice to do that in a Real Language (tm)
19:39:28 * benmachine thinks of shelley and byron and is reminded of http://harkavagrant.com/index.php?id=56
19:40:11 <ddarius> benmachine: The question is whether it forces its argument to WHNF or not, i.e. whether it looks at its argument at all or not.  It either does or it doesn't.  It can't know not to look at the sometimes argument without looking at the argument.
19:40:31 <gwern> such an excellent comic
19:40:39 <benmachine> ddarius: hm, ok
19:40:51 <benmachine> gwern: 'tis
19:41:15 <blackdog> danharaj: i think we've had this argument before, but here we go again: it's difficult to make haskell be dynamic. it's not impossible, but it can be tricky. ruby is well-established as a glue/web language. therefore, if you have a computation-intensive app you'd like to put on the web, getting a ruby guy to do the front end, using your haskell library is not totally stupid.
19:41:25 <ddarius> benmachine: Consider a simpler case: f :: (X,Y) -> (X,Y), it doesn't matter whether f is strict in Y depending on X because the question is whether it is strict in the pair as a whole.
19:41:51 <dolio> > iterate (\(x:xs) -> x:x:xs) [1] !! 1000000
19:41:52 <lambdabot>   *Exception: stack overflow
19:42:03 <ddarius> benmachine: However, an interesting case is the function compose :: [a -> a] -> (a -> a).  Should it be foldr (.) id or foldl' (.) id?
19:42:09 <blackdog> but the other way around is the real drawcard - i don't really expect haskell hackers to be that pragmatic. if you have a successful but slow ruby app, putting the hard bits in haskell also makes sense and is less painful than doing it in c.
19:42:26 <danharaj> blackdog: fair enough, I thought you were emphasizing on the other direction, calling Ruby from Haskell.
19:42:40 <benmachine> ddarius: foldl' (.) id seems a bit of an odd idea, does it really make sense to seq a composition?
19:42:47 <benmachine> before applying it
19:42:54 <ddarius> Sure.
19:43:04 <Cale> ddarius: surely the first one, no?
19:43:13 <blackdog> danharaj: ah. yeah, that's pointless;) if you knew what you wanted to do, you'd be doing it in haskell.
19:43:23 <benmachine> but you can't evaluate it to the top-level constructor
19:43:27 <benmachine> because... there isn't one
19:43:31 <benmachine> because functio
19:43:32 <benmachine> n
19:43:51 <Cale> > foldr (.) id (repeat (1:)) []
19:43:52 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:44:12 <ddarius> benmachine: The top-level construction is lambda, however I think application more the example I'm going for rather than composition.
19:44:21 <Cale> This is a case where I think foldr is clearly more efficient.
19:45:01 <benmachine> in other news, it's nearly 4am and I'm supposed to be getting up at something vaguely before midday tomorrow
19:45:32 <benmachine> I'll read the scrollback in the morning :P
19:47:14 <Cale> > iterate (\ ~(x:xs) -> x:x:xs) [1] !! 1000000
19:47:18 <lambdabot>   mueval-core: Time limit exceeded
19:47:28 <Cale> (it works, anyway :)
19:47:56 <kmc> what's the preferred library for converting a utf8-encoded ByteString to a String?
19:48:13 <Cale> iterate + strict function + large indexing operation -> stack overflow
19:51:58 <ddarius> applies = foldr ($) 0 v. applies = foldl' (flip ($)) 0 . reverse  Which is better?
19:56:13 <gwern> kmc: where are you getting such a bs from? presumably that lib has such a function
19:56:55 <EvanR> @hoogle utf8
19:56:55 <lambdabot> No results found
19:57:21 <gwern> EvanR: hoogle doesn't index specific libraries
19:57:30 <gwern> if it doesn't come with ghc, hoogle doesn't have it
19:58:22 <edwardk> kmc: there is always http://hackage.haskell.org/packages/archive/utf8-string/0.3/doc/html/Data-ByteString-UTF8.html
20:00:57 <ddarius> appliesr = foldr ($), appliesl = foldl' (flip ($)), appliesl' = foldl' (flip ($!))
20:26:21 <blackdog> is there a better idiom for this: getFunctions moduleName = (\x -> [a |Fun a <- x]) <$> getModuleExports moduleName
20:26:37 <blackdog> the explicit lambda annoys me a bit
20:26:55 <blackdog> but a map and a filter annoys me even more
20:29:26 <tensorpudding> something tells me that <*> might be good here
20:31:06 <ddarius> blackdog: I doubt you'll find a "better" way.
20:40:06 <blackdog> tensorpudding: haven't used <*>. where's it used idiomatically? 
20:40:26 <tensorpudding> getFunctions moduleName = fmap (fmap (\Fun a -> a)) (getModuleExports moduleName) maybe?
20:41:13 <aavogt> that's not the same
20:41:24 <aavogt> > [ x | Just x <- [Just 1, Nothing]]
20:41:25 <lambdabot>   [1]
20:41:26 <Twey> Also going to break
20:41:28 <tensorpudding> is it not?
20:41:39 <aavogt> > fmap (\(Just x) -> x) [Just 1, Nothing]
20:41:40 <lambdabot>   [1,*Exception: <interactive>:1:143-156: Non-exhaustive patterns in lambda
20:41:43 <Twey> Like so
20:42:02 <tensorpudding> Okay, so it only fails if there is more than one constructor for that type.
20:42:15 <blackdog> there is:)
20:42:22 <blackdog> that's why i needed the filter before
20:42:23 <Twey> That's the whole point of that comprehension
20:42:34 <tensorpudding> Why not make an explicit case statement?
20:42:48 <blackdog> because it's verbose
20:42:49 <Twey> That's even more verbose
20:43:11 <aavogt> explicit case inside a mapMaybe
20:43:12 <tensorpudding> The question is not about verbosity, but elegance.
20:43:28 <tensorpudding> Also understandability.
20:43:47 <blackdog> hm, i thought the comprehension was quite understandable
20:43:51 <ddarius> It is.
20:43:53 <tensorpudding> At least, I judged it to be that.
20:44:05 <tensorpudding> I don't think it's more understandable
20:44:05 <Twey> I believe it is, yes.
20:44:12 <Twey> It's perfectly comprehensible.
20:44:39 <aavogt> you have to know what happens when pattern matches fail in list comprehensions / do
20:45:08 <blackdog> i thought that kind of implicit guard was pretty idiomatic
20:45:28 <ddarius> It is.
20:45:45 <dolio> If it isn't clear, you need to lern yer list comprehensions. :)
20:45:54 <tensorpudding> Maybe it would be less disagreeable if the list comprehension.
20:46:08 <aavogt> if what about it?
20:46:24 <mauke> if only.
20:46:38 <tensorpudding> rather, maybe it would be less disagreeable if it were clear that the list comprehension was not just desconstructing Fun's, but also ignoring the non-Fun's
20:47:35 <mauke> clearness is in the eye of the beholder
20:47:38 <tensorpudding> I was seeing that as saying "take an x, match it to Fun a", the same as the code I stated was essentially doing.
20:47:49 <Twey> tensorpudding: That's exactly what list comprehensions do.
20:47:54 <ddarius> blackdog: You could do catMaybes . map unFun for an appropriate unFun function, but unFun would be fairly inelegant.
20:47:59 <mauke> everyone else was seeing it as a filter
20:48:28 <mauke> tensorpudding: btw, do you know uniplate?
20:48:30 <blackdog> ddarius: yeah, it's a bit like pushing the dead hamster under the carpet around
20:48:47 <tensorpudding> the pattern of [a | a <- x] should be x, therefore I figured that the thing written was just unpeeling the constructor off of a Fun a. 
20:48:53 <tensorpudding> I don't know uniplate.
20:49:07 <mauke> it's nice
20:49:13 <Twey> Filtering on pattern-matches is one of the primary uses of list comprehensions, IME.
20:49:16 <ddarius> Neil uses this pattern often.
20:49:32 <Twey> tensorpudding: Sorry?  x isn't a pattern there (a is).
20:49:43 <dolio> How about "do Fun a <- x ; return a". You know that uses fail, right?
20:50:00 <tensorpudding> I don't think I've ever used list comprehension in my own code.
20:50:02 <dolio> Unless GHC is smart.
20:50:03 <wli> Some of us are still wanting monad comprehensions back.
20:50:08 * Twey raises a hand.
20:50:32 <Twey> But while we're in that mood, we might as well wish for first-class pattern-matching functions ;)
20:50:45 <c_wraith> give me first-class record labels.
20:50:48 <dolio> @undo do Fun a <- x ; return a
20:50:48 <lambdabot> x >>= \ b -> case b of { Fun a -> return a; _ -> fail ""}
20:50:51 <tensorpudding> Twey: What do you mean?
20:51:08 <Twey> 04:48:36 < tensorpudding> the pattern of [a | a <- x] should be x, therefore I figured that the thing written was just unpeeling the constructor  off of a Fun a. 
20:51:10 <tensorpudding> My understanding was that it was exactly the same as what dolio had just stated.
20:51:13 <wli> monad comprehensions are rather less of an extension
20:51:13 <Twey> x is not a pattern
20:51:25 <Twey> a is a pattern
20:51:31 <Twey> (the second one)
20:51:36 <tensorpudding> I shouldn't have used that term "pattern" the first time.
20:51:40 <wli> And also restore pre- polymorphic scare sanity of various sorts
20:51:55 <Twey> I'm not sure what you mean by ‘the pattern of [a | a <- x] should be x’, then.
20:52:06 <tensorpudding> I meant that \x -> [a | a <- x] is a no-op
20:52:08 <ddarius> Twey: He's trying to say, map id = id essentially.
20:52:11 <Twey> Ahh.
20:52:27 <tensorpudding> It sounded right in my head, sorry.
20:52:33 <Twey> Okay. ☺
20:52:48 <tensorpudding> I didn't know that the list comprehension implicitly used fail.
20:52:59 <dolio> > do Just x <- [Just 5, Nothing, Just 6] ; return x
20:53:00 <lambdabot>   [5,6]
20:53:06 <tensorpudding> Mostly because I've never used that "Constructor a <- Foobar" trick.
20:54:08 <Twey> They're essentially sugar over do-notation
20:54:30 <Twey> [a | a <- x] desugars to ‘do a <- x; return a’
20:54:48 <Twey> The fact that they're restricted to the list monad is a rather odd quirk.
20:54:52 <aavogt> @undo [ x | Just x <- [Just 1, Nothing]]
20:54:53 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) [Just 1, Nothing]
20:55:06 <wli> They weren't restricted to the list monad 
20:55:08 <tensorpudding> There's a case statement there.
20:55:14 <Twey> Yeah.  Ick.
20:55:46 <aavogt> perhaps it's better to call case an expression
20:55:57 <ddarius> It is an expression and not a statement.
20:55:57 <tensorpudding> case-block
20:56:08 <Twey> It would have been cleverer of it to use maybeToList: concatMap maybeToList [Just 1, Nothing]
20:56:15 <tensorpudding> case-notation?
20:56:37 <ddarius> Call it a case expression because that's what it is.
20:56:50 <Twey> > [Just 1, Nothing] >>= concatMap
20:56:51 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t'
20:56:51 <lambdabot>         against inferred ...
20:56:52 <Twey> Er
20:56:52 <aavogt> so the individual choices are 'statements' but the whole thing is an expression
20:56:55 <Twey> > [Just 1, Nothing] >>= maybeToList
20:56:56 <lambdabot>   [1]
20:57:03 <tensorpudding> I've never heard a definition of an expression before.
20:57:13 <ddarius> aavogt: I believe the "choices" are called "alternatives"
20:57:41 <ddarius> tensorpudding: You can check the Report for what Haskell calls an expression.  A common broad definition is that expressions have a value, statements do not.
20:58:10 <tensorpudding> In any case it's just slipping into the old habits...
20:58:23 <aavogt> you can substitute a simple variable for an expression
20:58:46 <aavogt> but you can't write     case a of { x; y; z }
20:59:39 <ddarius> You wouldn't call the branches of a case "statements".
21:10:09 <aavogt> I guess the similarity between  (pattern,expression) that happens in do notation, and in case is sort of too weak to give both the same name
21:12:39 <allbery_b> enh.  "clauses"
21:19:55 <kulin> i think perhaps i hate mathematical formulas, they are like uncommented code
21:21:37 <Saizan> unless they are commented
21:21:38 <robertmassaioli> kulin: most code can be self commenting and most maths can be too ... kinda
21:21:58 <kulin> im just trying to read about quaternions, and they are giving all these formulas using i and whatever
21:22:28 <ddarius> @google "Imaginary numbers are not real"
21:22:29 <lambdabot> http://www.mrao.cam.ac.uk/~clifford/introduction/intro/intro.html
21:22:29 <lambdabot> Title: Imaginary Numbers are not Real - the Geometric Algebra of Spacetime
21:22:30 <kulin> and i could figure it out, but id have to take apart all their work
21:22:39 <kulin> just like uncommented code
21:24:02 <Saizan> if i'm guessing correctly those are axioms, not something you derive
21:25:08 <kulin> i suppose, im just dumb, but in any event im just looking for something that should have a picture answer, and instead i have to figure out what the matrix is doing
21:26:24 <ddarius> And others are like "i suppose im just dumb, but in any event im just looking for something that should have an algebraic answer, and instead i have to figure out what the picture is doing"
21:27:11 <kulin> ya
21:27:33 <kulin> but those people know they arnt dumb, because they are all in PhD classes and write Math as Maths
21:28:01 <ddarius> Mathematics is not about blindly writing and manipulating symbols.
21:28:34 <kniu> @hoogle a -> b -> c -> (a, b) -> c
21:28:34 <lambdabot> No results found
21:28:41 <kniu> @hoogle (a -> b -> c) -> (a, b) -> c
21:28:41 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
21:28:41 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
21:28:41 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
21:29:10 <aavogt> @djinn a -> b -> c -> (a, b) -> c
21:29:11 <lambdabot> f _ _ a _ = a
21:29:46 <kniu> @pl (\f -> uncurry (++) . partition f)
21:29:46 <lambdabot> (uncurry (++) .) . partition
21:40:26 * edwardk finally relents and gives up on a thousand lines of dirty code for a couple of little dirty orphan instances on Data.Vector so he can get on with his life.
21:41:20 <deech> Has anyone here used org-babel for Haskell programming? And if so is it worth my time?
21:42:46 <Twey> How do I get a ClockTime into RFC 822 format using System.Time?
21:49:01 <ManateeLazyCat> In type Foo, it has define like this "newtype Foo = Foo deriving Show", can i write new "instance Show Foo" to overwrite Show instance?
21:49:42 <ManateeLazyCat> Or has any language extension can do that?
21:51:28 <aavogt> that's not a valid newtype
21:51:45 <ManateeLazyCat> newtype NativeWindowId = NativeWindowId (Ptr ()) deriving (Eq, Show)
21:52:02 <ManateeLazyCat> aavogt: Above is type NativeWindowId in gtk2hs.
21:52:39 <aavogt> why do you want a different show instance for?
21:52:39 <ManateeLazyCat> aavogt: But i want overwrite new Show instance for NativeWindowId
21:52:45 <aavogt> you can't do that
21:52:56 <seydar> it's a friday night and i need math help
21:52:59 <seydar> so i turn to you all
21:53:03 <ManateeLazyCat> aavogt: Because i need transform NativeWindowId to String.
21:53:04 <seydar> how do i generate a t distribution
21:53:24 <ManateeLazyCat> aavogt: Then i can transform NativeWindowId through DBus message.
21:53:51 * ManateeLazyCat pasted "instance for NativeWindowId" at http://paste2.org/get/874212
21:53:53 <ManateeLazyCat> aavogt: Above
21:54:22 <ManateeLazyCat> aavogt: I want "show = show . fromNativeWindowId".
21:55:07 <aavogt> you can't replace instances that already exist
21:55:09 * ManateeLazyCat pasted "instance for Variable" at http://paste2.org/get/874214
21:55:41 <ManateeLazyCat> aavogt: Look http://paste2.org/get/874214 , except NativeWindowId, other type is same format.
21:55:43 <seydar> this shit is breaking my balls
21:55:45 <aavogt> make a newtype for NativeWindowId, or use a different class for serialization, or your own function
21:56:19 <ManateeLazyCat> aavogt: If i cant make NativeWindowId use same format, i can re-write those duplicate instance with TH 
21:56:32 <aavogt> it makes sense to multiply window ids?
21:56:53 <seydar> my balls are so fucking broken right now
21:57:33 <ManateeLazyCat> aavogt: Oh, i think newtype for NativeWindowId is good idea.
21:57:43 <ManateeLazyCat> aavogt: Thanks!
21:58:16 <aavogt> though equivalently you could just make a different newtype around Ptr ()
21:58:41 <ManateeLazyCat> aavogt: I don't want touch gtk2hs code.
21:59:18 <aavogt> what I mean is that here:   newtype A = A Int; newtype B = B A
21:59:29 <aavogt> you can write instead   newtype B = B Int
21:59:58 <ManateeLazyCat> aavogt: Yes, i got it.
22:00:27 <aavogt> as in, those two representations are the same... your code and instances will differ
22:01:06 <ManateeLazyCat> aavogt: It's a good idea, i will change my code... Thank you. :)
22:03:35 <blackdog> did i miss anything? the apartment next to mine just caught fire.
22:06:28 <BMeph> blackdog: Did you get a coat hanger and some hot dogs? ;)
22:07:46 <blackdog> thought it was burning toast... don't leave the electric blanket on when you go away for a long weekend, people.
22:08:51 <alexyk> will this cause <<loop>>: let rec = rec {field=newVal} -- ?
22:09:34 <alexyk> or can I shadow this way?
22:09:41 <kmc> that is not shadowing
22:10:18 <alexyk> kmc: I've successfully killed a CentOS with a 106 GB vmcore dump with one of those perhaps
22:10:21 <kmc> all "let" binding-groups are recursive
22:10:21 <alexyk> or something
22:10:25 <kmc> nice
22:10:32 <Cale> alexyk: That'll define a value recursively.
22:10:46 <Cale> alexyk: It may or may not cause a <<loop>>
22:11:16 <alexyk> Cale: so that shoulda killed it -- once it did <<loop>>, then it ate my server
22:12:19 <alexyk> I can't believe ghc kept mum about it... any warnings for recursive values?
22:13:32 * hackagebot vector-instances 0.0.1 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-0.0.1 (EdwardKmett)
22:13:56 * edwardk cringes at releasing a library full of orphan instances
22:16:07 <Gracenotes> edwardk: every version is a major version! :D
22:16:23 <edwardk> =)
22:16:45 <edwardk> i was literally doubling the amount of code in my library for wont of those instances
22:16:48 <edwardk> i finally had enough ;)
22:17:02 <edwardk> besides they caused me to break my overall naming convention... the horror!
22:18:59 <dolio> Did Roman not want them in vector or something?
22:19:32 <edwardk> dolio: he said he'd take a patch, but the patch is proving tricky to write in a way that i think he'd accept
22:19:47 <Axman6> how so?
22:20:00 <edwardk> and he was a little waffly on wanting some of them since they can't be implemented for the other Vectors
22:20:32 <edwardk> Axman6: well, it is tricky to write Traversable in a way that makes the Stream fusion code happy
22:20:41 <Axman6> air enough
22:20:43 <Axman6> f*
22:21:10 <edwardk> my current hack is to define traversable using toList and then rebuild using fromListN
22:21:47 <edwardk> ideally there would exist a whole 'Applicative' fusion module that traverse could just tap into ;)
22:21:59 <edwardk> but that is a bit deep of a rabbit hole ;)
22:22:21 <kniu> @hoogle [Maybe a] -> a
22:22:21 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
22:22:22 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
22:22:22 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
22:22:56 <kniu> @hoogle (a, Maybe b) -> Maybe (a, b)
22:22:56 <lambdabot> No results found
22:24:04 <mtnviewmark> :t uncurry $ map (,) 
22:24:04 <lambdabot>     Couldn't match expected type `b -> c'
22:24:05 <lambdabot>            against inferred type `[b1 -> (a, b1)]'
22:24:05 <lambdabot>     In the second argument of `($)', namely `map (,)'
22:24:50 <jmcarthur> deforestation is tedious to maintain
22:25:03 <jmcarthur> i want supercompilation
22:25:19 <mtnviewmark> :t uncurry $ fmap (,) 
22:25:20 <lambdabot> forall b a b1. (b -> a, b) -> b1 -> (a, b1)
22:25:26 <mtnviewmark> that's what I meant
22:25:48 <edwardk> i'm going to go through and rip out more methods now that i ripped out the Vector specifics. I think the stuff that just lifted things into Monad using liftM instead of fmap can go
22:25:58 <mtnviewmark> but it's not right
22:27:29 <mtnviewmark> :t \a -> lift (a,)
22:27:30 <lambdabot> parse error on input `)'
22:27:41 <mtnviewmark> right  - no sections on tuples
22:27:47 <mtnviewmark> w/o some extension
22:27:58 <mtnviewmark> :t \a -> lift (\b -> (a,b))
22:27:59 <lambdabot> forall t t1 (t2 :: (* -> *) -> * -> *). (MonadTrans t2) => t -> t2 ((->) t1) (t, t1)
22:28:20 <mtnviewmark> :t \a -> liftM (\b -> (a,b))
22:28:21 <lambdabot> forall a1 t (m :: * -> *). (Monad m) => t -> m a1 -> m (t, a1)
22:28:27 <jmcarthur> exploratory coding is fun when the problem is small, but as soon as you start making data types with 83 constructors it's not fun anymore
22:28:30 <mtnviewmark> there - uncurry that
22:28:39 <edwardk> jmcarthur: hahah
22:28:47 <mtnviewmark> ya know - the same could be said of classes with 83 members
22:28:50 <mtnviewmark> :-)
22:28:57 <edwardk> jmcarthur: data types a la carte might be a big win for you ;)
22:29:15 <jmcarthur> edwardk: sadly not. this is essentially just an enum type
22:29:31 <jmcarthur> but i still have to pattern match it a couple times :(
22:29:34 <edwardk> jmcarthur: =/
22:29:38 <edwardk> Data ?
22:29:39 <edwardk> =)
22:29:42 <jmcarthur> heh
22:29:48 <mtnviewmark> :t liftM $ (,)
22:29:48 <lambdabot> forall a1 (m :: * -> *) b. (Monad m) => m a1 -> m (b -> (a1, b))
22:29:55 <jmcarthur> i could probably use TH actually
22:30:05 <edwardk> what is the pattern for?
22:30:56 <BMeph> :t (fmap.).pure
22:30:57 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => (a -> b) -> f1 (f a -> f b)
22:30:59 <jmcarthur> i'm working on a purely functional abstraction over opengl. this particular case of it is just the internal texture formats
22:31:06 <jmcarthur> nothing to bad, really
22:31:10 <jmcarthur> just tedious
22:31:12 <jmcarthur> *too bad
22:31:13 <mtnviewmark> :t uncurry (\a -> liftM $ (,) a)
22:31:14 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a, m a1) -> m (a, a1)
22:31:15 <mtnviewmark> there!
22:31:41 <mtnviewmark> kniu - that'll do it
22:31:52 <kniu> oh wow
22:32:00 <jmcarthur> edwardk: it's not bad in this case since i'm just value level. i'm having to come up with something more manageable for the external formats because i want it to be visible in the type
22:32:07 <mtnviewmark> do you really need it uncurried?
22:32:55 <jmcarthur> so i've been spending the last half hour or so playing around with different ways to construct the types instead of making each one individually
22:33:02 <mtnviewmark> I think I'd call it pairM
22:33:40 <mtnviewmark> let pairM a = liftM $ (,) a in "hello" `pairM` Just "world"
22:33:52 <mtnviewmark> > let pairM a = liftM $ (,) a in "hello" `pairM` Just "world"
22:33:52 <lambdabot>   Just ("hello","world")
22:33:59 <mtnviewmark> > let pairM a = liftM $ (,) a in "hello" `pairM` Nothing
22:34:00 <lambdabot>   Nothing
22:34:25 <mtnviewmark> > let pairM a = liftM $ (,) a in "hello" `pairM` ["world", "planet", "solar system", "galaxy", "universe"]
22:34:26 <lambdabot>   [("hello","world"),("hello","planet"),("hello","solar system"),("hello","ga...
22:35:04 <jmcarthur> i could probably come up with a way to construct the internal format values too, which i guess might simplify the interface
22:35:08 <edwardk> hah
22:35:58 <mtnviewmark> reminds me of combintor I wrote recently that I hadn't seen
22:35:58 <edwardk> if it makes you feel better i just had to encode a better heuristic about if a traversable was big, by adding a lazy nat type and encoding big (S (S (S (S (S _)))) = True ;) to decide between forward and reverse jacobian calculation ;)
22:36:22 <jmcarthur> o_O
22:36:25 <mtnviewmark> with :: (a -> b) -> a -> (a,b)
22:36:25 <mtnviewmark> with f a = (a, f a)
22:36:54 <mtnviewmark> so (with f) is a function like f, but one that returns both the argument and the result as a pair
22:37:10 <edwardk> jmcarthur: it let me generalize a type sig and in general the Reverse method is way more expensive, so i only want to use it if there are more than a few args -- arguably i should probably make the threshold higher
22:37:25 <mtnviewmark> turned out really really useful for many problems in Project Euler
22:37:31 <BMeph> @type (,)<*>pure
22:37:31 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> (a, f a)
22:37:35 <jmcarthur> this abstraction is a PITA, but it will be oh so useful once it's done (i hope)
22:38:12 <BMeph> Hmm, different "f"....
22:38:30 <jmcarthur> anyway, it's bed time. i should go before i drive myself up the wall
22:38:30 <mtnviewmark> withM :: (Functor m) => (a -> m b) -> a -> m (a,b)
22:38:31 <mtnviewmark> withM f a = fmap (\b -> (a,b)) $ f a
22:38:47 <mtnviewmark> (where M is a misnomer, since it only requires Functor)
22:40:05 <mtnviewmark> :t let withM f a = fmap (\b -> (a,b) $ f a in withM (flip const)
22:40:06 <lambdabot> parse error on input `in'
22:40:15 <mtnviewmark> :t let withM f a = fmap (\b -> (a,b)) $ f a in withM (flip const)
22:40:15 <lambdabot> forall a t. t -> a -> (t, a)
22:41:10 <Scriptor> what does the build function do in the source for splitEvery (http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/src/Data-List-Split-Internals.html#splitEvery)? The only source I can find for a build function is in Heap where all it does is foldr insert Empty
22:41:40 <mtnviewmark> I believe that build is in GHC's implementation of Prelude
22:41:47 <mtnviewmark> it is part of list fusion
22:43:48 <BMeph> That's "build g = g (:) []", right?
22:43:58 <mtnviewmark> Scriptor - it is in GHC.Base:  http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-Base.html
22:44:10 <mtnviewmark> @src buid
22:44:10 <lambdabot> Source not found. I feel much better now.
22:44:20 <mtnviewmark> @src GHC.Base.build
22:44:20 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
22:44:43 <mtnviewmark> but yes, BMeph nailed it
22:45:21 <Scriptor> ah, thanks
22:46:12 <BMeph> So, "foldr c n (build g) ==> g c n"
22:48:36 <bos> @type flip fix
22:48:37 <lambdabot> forall a b. a -> ((a -> b) -> a -> b) -> b
22:50:16 <mtnviewmark> @src fix
22:50:16 <lambdabot> fix f = let x = f x in x
22:50:35 <mtnviewmark> how the hell does that work?!?!?!
22:50:55 <Cale> mtnviewmark: Try it with some function :)
22:51:10 <Cale> fix (1:) = let x = (1:) x in x
22:51:42 <mtnviewmark> aha
22:51:49 <mtnviewmark> here I was trying to figure out
22:51:50 <Cale> > fix (1:)
22:51:51 <mtnviewmark> fix (1+)
22:51:51 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:52:04 <mtnviewmark> > fix (1+)
22:52:08 <lambdabot>   mueval-core: Time limit exceeded
22:52:17 <mtnviewmark> > fix (0+)
22:52:21 <lambdabot>   mueval-core: Time limit exceeded
22:52:22 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
22:52:23 <lambdabot>   3628800
22:52:47 <Cale> fix finds the least-defined fixed point of a function
22:52:57 <Cale> If f undefined = undefined, then fix f = undefined
22:52:58 <mtnviewmark> so I see that it works from some kinds of functions - and it clearly fails for functions where the fixpoint isn't well defined
22:53:07 <mtnviewmark> but does it work for *all* functions that have a fixpoint?
22:53:25 <Cale> All functions have at least one fixed point in Haskell.
22:53:37 <Scriptor> won't splitEvery create a ton of new lists?
22:53:43 <Cale> (It just might have some bottoms in it)
22:54:03 <Cale> (That is, you have to consider nontermination a value here ;)
22:54:20 <mtnviewmark> :t splitEvery
22:54:21 <lambdabot> Not in scope: `splitEvery'
22:55:38 <Scriptor> argh, what I said was just wrong, I meant that the splitter function seems to create some needlessly long lists before take is mapped onto them
22:55:51 <Cale> So for example, it's not going to find the nontrivial fixed point of (\x -> x^2), it's going to find the stupid one.
22:56:09 <Cale> (that undefined^2 = undefined)
22:57:04 <Cale> Scriptor: But map is defined as a foldr
22:57:04 <mtnviewmark> okay- so it is only useful for a certain class of functions - ones where the "prefix" (used loosely) can be computed before the entire result
22:57:19 <Cale> Scriptor: and so it'll fuse with the build
22:57:42 <Cale> mtnviewmark: Yeah
22:58:04 <Cale> Basically what it really does is to capture general recursion
22:58:25 <Cale> If you can write a recursive definition for something: x = ... x ...
22:58:26 <Scriptor> what is fusing? right now it looks like [4,3,2,1] would be turned into [[4,3,2,1], [2,1]], is that right?
22:58:33 <Scriptor> if splitting into lists of 2
22:58:53 <Cale> then you could instead write x = fix (\y -> ... y ...)
22:59:44 <Cale> "fold/build"    forall k z (g::forall b. (a->b->b) -> b -> b) . 
22:59:44 <Cale>                 foldr k z (build g) = g k z
22:59:53 <Cale> This is the rewrite rule which matters here...
23:00:15 <Axman6> > undefined == undefined
23:00:16 <lambdabot>   *Exception: Prelude.undefined
23:00:19 <Axman6> :(
23:00:54 <Cale> let's see...
23:01:53 <Cale> map f xs = build (\c n -> foldr (\x ys -> c (f x) ys) n xs)
23:03:34 <Cale> so...  map (take i) (build (splitter ls)) = build (\c n -> foldr (\x ys -> c (take i x) ys) n (build (splitter ls)))
23:03:47 <Cale> aha! and then we can apply the rewrite rule
23:04:19 <Cale> -> build (\c n -> (splitter ls) (\x ys -> c (take i x) ys) n)
23:05:58 <mtnviewmark> > take 10 $ fix (\xs -> 1 : map (/2) xs)
23:05:59 <lambdabot>   [1.0,0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.95312...
23:06:26 <mtnviewmark> though not sure I don't find the version based on iterate to be more clear
23:06:26 <Cale> Now, assuming that outer build doesn't fuse with anything else, that would give:
23:06:28 <Scriptor> Cale: is the main point of build to abstract out the cons function?
23:06:29 <Cale> = splitter ls (\x ys -> take i x : ys) []
23:06:39 <mtnviewmark> > take 10 $ iterate (/2) 1
23:06:40 <lambdabot>   [1.0,0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.95312...
23:07:12 <Cale> Scriptor: Basically what the list library does internally is often to represent lists using functions
23:07:39 <Cale> (\cons nil -> cons 1 (cons 2 (cons 3 nil))) in place of (1 : (2 : (3 : [])))
23:08:29 <Cale> foldr (though it doesn't quite have the right parameter order for it) can be seen as a way to convert a real list like (1 : (2 : (3 : []))) into one of those functions
23:08:38 <ksf> setup: ./Graphics/UI/Gtk/General/IconTheme.chs: invalid argument                                                                                               
23:08:43 <ksf> anyone know that error?
23:08:59 <Cale> and if we have a function like (\cons nil -> cons 1 (cons 2 (cons 3 nil))), and we want to get back to a normal list, we can apply it to the arguments (:) and []
23:09:03 <Cale> which is what build does
23:09:31 <Cale> It turns out that by making use of this sort of conversion, you can eliminate the construction of many intermediate lists.
23:09:55 <Cale> (after inlining some things, you end up with foldr next to build, and you can cancel them
23:09:56 <Cale> )
23:10:21 <ksf> ...I installed the recent version of gtk2hs-buildtools, assuming that's what I'm supposed to do
23:10:46 <Cale> So you have to be really careful when you go and say that some composite of list functions will build unnecessary lists, because it really might not once optimisations are turned on.
23:11:15 <Cale> Here, the list implicitly constructed by 'map' is fused away.
23:11:58 <Cale> Er, sorry, the list *consumed* by map
23:12:36 <Cale> the map operation itself goes away, in a sense
23:12:51 <Cale> It becomes a simple function application
23:13:54 <Cale> and depending on how the result of splitEvery gets used, and whether it gets inlined, you might get even more cancellation
23:14:06 <ski> (the producer of list elements is fused directly with the consumer of them)
23:14:14 <Cale> since the result of splitEvery, after that bit of rewriting, is itself a build
23:15:07 <Cale> and so if you foldr over the result of splitEvery, and the definition of splitEvery gets inlined into your code, then the list produced by splitEvery will never actually be produced
23:15:58 <Cale> (the rewrite rule will fire and destroy the foldr/build pair)
23:16:32 <ManateeLazyCat> ksf: Update darcs version.
23:16:37 <ksf> hmmm according to the internets gtk2hs doesn't like my POSIX locale
23:17:04 <ManateeLazyCat> ksf: Yes, it's a bug of Gtk2HsSetup.hs
23:17:14 <ManateeLazyCat> ksf: Make your locate with UTF8
23:17:21 <ManateeLazyCat> ksf: If you don't want use darcs version.
23:18:21 <ManateeLazyCat> ksf: We have fix this bug in darcs version, if you prefer like gtk2hs-0.11, you can set your locate to UTF8, then re-compile again, i think problem will fix.
23:18:34 <Scriptor> Cale: ok, thank you so much for taking the time to hep, this'll take some time to digest :)
23:18:45 <blackdog> is "foo <- bar >>= baz" bad style?
23:19:01 <ezyang> I'd prefer 
23:19:04 <blackdog> it feels a bit awkward reading from the middle out
23:19:06 <ezyang> foo <- baz =<< bar 
23:19:27 <blackdog> ah, so it reads from right to left
23:20:13 <danharaj> I am weird in that I think >>= looks better than do.
23:20:31 <danharaj> >>= and lambdas versus do notation to be precise.
23:20:33 <blackdog> yeah, the other alternative is just dangle it off the end with >>= style, i guess.
23:20:57 * ksf notices that there's no POSIX.utf8
23:20:58 <ezyang> Mostly, I look for unity within a line 
23:21:01 <blackdog> it's strange - i don't mind reading right to left for pure stuff, but it feels strange for monadic code
23:21:03 <ezyang> and point free as much as possible 
23:21:23 <ezyang> blackdog: That's because you're thinking "do this, then that, then that" 
23:21:34 <ezyang> Which obviously should be LTR 
23:21:46 <blackdog> yeah, pretty much.
23:22:08 <ezyang> I sort of think Haskell code that squiggles its way down the page is kind of beautiful 
23:22:12 <ezyang> but I might be strange 
23:22:19 * blackdog rather enjoys having the free time to care about his code at the micro level
23:22:29 <danharaj> We're all perverts at some level.
23:22:41 <ManateeLazyCat> ksf: Do you want darcs version? If you answer no, i will give your another solution.
23:22:50 <blackdog> danharaj: oh dear, we're not back to the Ruby argument, are we?
23:23:04 <danharaj> Ruby is for dog fuckers, in this metaphor.
23:23:06 <ksf> I'm re-trying with en_GB.utf8 right now
23:23:12 <ezyang> Hey guys; are monadic regions just the (forall s. s) trick? 
23:23:14 <blackdog> bitch!
23:23:24 <ManateeLazyCat> ksf: If you don't want utf8, i can give your another solution.
23:23:31 <ksf> I don't mind at all
23:23:41 <danharaj> Actually no, Ruby is the teenager who just learned about his own body, and is using a sock to... well... Ok I'll stop.
23:23:41 <ManateeLazyCat> ksf: Replace ● with * in IconTheme.chs
23:23:51 <ksf> I've just been to lazy to care about it in the past
23:24:00 <ManateeLazyCat> ksf: Then you don't need modified locate or use darcs version.
23:25:14 <ksf> seems to work fine, thanks
23:25:24 <ManateeLazyCat> ksf: NP. :)
23:25:36 * ManateeLazyCat Infact, it's all my fault about IconTheme.chs ....
23:26:08 <ManateeLazyCat> I have write a Emacs extension (gtk2hs.el) that transform documentation from GTK+ Manual automatically.
23:26:40 <ManateeLazyCat> That copy ● from GTK+ documentation.
23:26:59 <ManateeLazyCat> So we got this bug in non-utf8 locate.
23:27:42 <ksf> otoh, we can appoximate the traveling salesmen in a thousand ways that are very elegant and aren't capable of getting our charsets straight.
23:28:25 <ksf> it's really all ascii's fault.
23:28:26 <c_wraith> yes.  charsets are not algorithmic.  that makes them harder.
23:28:38 <c_wraith> charsets are *political*
23:28:39 <ksf> back in the ebcdic days, people still knew how to convert.
23:29:07 <ManateeLazyCat> ksf: I just don't noticed this problem when i wrote gtk2hs.el.
23:29:18 <ksf> yeah it's not your fault
23:29:33 <ksf> I wonder why the IO layer changed its default behaviour
23:29:52 <ksf> considering that we have a binary file mode, iirc
23:30:37 <c_wraith> The new behavior is nicer, in the end.  It's just a painful switch for existing code.
23:30:43 <ksf> and a significant amount of blame goes to the linux devs, too
23:30:55 <ksf> ...who were unwilling to support utf8
23:31:19 <ksf> ...by tagging files, that is. they need to read #!... , after all.
23:31:28 * ManateeLazyCat Many problem will disappear if we all use utf8
23:31:43 <ksf> indeed
23:32:02 <c_wraith> China and Japan really hate UTF-8, because it makes most of their characters 3 bytes, where an encoding like Big5 makes most of their characters 2 bytes.
23:32:26 <ManateeLazyCat> c_wraith: No, we love utf-8
23:32:38 <ezyang> Also the Han unification annoyed a lot of people. 
23:32:51 <ksf> that's going to be compressed away, anyway.
23:33:12 <ManateeLazyCat> c_wraith: Infact, it's a fault of Microsoft.
23:33:15 <ksf> run gzip over it and the difference should be imperceptible
23:33:17 <danharaj> casing in Unicode is also horrific
23:33:30 <c_wraith> yeah, locale-specific case rules are horrible
23:33:34 <ManateeLazyCat> c_wraith: Microsoft make Windows (Chinese version) default locate with gb2312.
23:33:35 <c_wraith> and so is microsoft, yes. :)
23:33:37 <ksf> danharaj, the same goes for ascii
23:33:46 <danharaj> ksf: I mean performance-wise.
23:33:53 <ManateeLazyCat> c_wraith: And not utf-8.
23:34:03 <ksf> ....well at least western iso
23:35:02 * ManateeLazyCat I admit, most UTF-8 space is eat by CJK, special Chinese.
23:35:12 <ksf> ...I'd be the first one to aknowledge an upper-case http://en.wikipedia.org/wiki/
23:35:25 <Twey> ksf: Encoding~
23:35:29 <ksf> In handwriting I've always used it.
23:36:52 <blackdog> the only part of this code that still makes me want to throw up is generating C code by pasting together strings
23:37:16 <Twey> UTF-16 provides two-byte encoding of CJK
23:37:32 <ManateeLazyCat> Many encoding problem (include switch with Unix) will disappear if Microsoft make default locate with utf-8 and not gb2312
23:38:06 <c_wraith> I agree that utf-8 should be the default on all systems these days.
23:38:13 <zeiris> What would be an equivalent of a Python dictionary in Haskell? A "Map Key Dynamic" is ugly, a "[Foo] where data Foo = A Int | B Char ..." is slow on lookups by key... Maybe a Set of Foo, using union (and custom Ord instance for Foo) to implement by-key lookups?
23:38:36 <Twey> zeiris: Map Key Dynamic is the equivalent
23:38:50 <Twey> It's ugly because having a heterogenous dictionary is ugly >.>
23:38:52 <ezyang> zeiris: When you say "Python dictionary", we say, underspecified. 
23:39:00 <c_wraith> Except we generally *like* the type system, so we specify the types of the values
23:39:28 <zeiris> Yeah, I phrased that poorly. I need a data type -like- the Python dictionary, except with typing for values. It's not a record because presence/number of attributes may change.
23:39:43 <zeiris> And having a record full of "Maybe Attr" would also be ugly.
23:39:54 <earthy> are the values taken from a limited, known set of types?
23:40:09 <earthy> then you can do  Map Key UnionOfTypes
23:40:24 <ksf> depending on use case, you could get away with an existential wrapper
23:40:34 <earthy> where UnionOfTypes is an ADT distinguishing between the known types
23:41:29 <zeiris> The data type is basically a record, except often not all attributes are specified. So a record full of Maybes actually might be perfect.
23:41:33 <earthy> or, alternatively, look at HList. :P
23:43:59 <ManateeLazyCat> If you just want a polymorphism-type for Map, i recommend use Nested-Tuple instead HList, HList is overkill sometimes.
23:44:17 <ManateeLazyCat> Use Nested-Tuple, you don't need change exist code.
23:44:30 <ManateeLazyCat> Just use (a, (b, c)) replace (a, b, c)
23:44:56 * ManateeLazyCat Infact, HList is nested-tuple, but more complicated.
23:46:11 <zeiris> I see HList uses the "type signatures only" method of documentation :D Is there a module for nested tuples?
23:46:54 <ManateeLazyCat> zeiris: I have some code "type Keymap = Map Key Action"
23:47:18 <ManateeLazyCat> zeiris: And Action use Nested-Tuple for write polytechnic-function in Action.
23:47:59 <ManateeLazyCat> zeiris: Wait a second, i paste my code.
23:48:14 <zeiris> Yeah, that works. I think I'm gonna go with Data.Set and a custom data type.
23:49:02 <zeiris> If "Foo = A Int | B Int Int | C Char ..." I have type safety concerning contents, and can implement key lookups by defining Ord to ignore contents of Foo :D
23:49:45 * ManateeLazyCat pasted "Nested-Tuple code" at http://paste2.org/get/874296
23:49:55 <ManateeLazyCat> zeiris: Above is my nested-tuple code.
23:50:17 <ManateeLazyCat> zeiris: Not a library, just explain how nested-tuple works. :)
23:51:29 <zeiris> Cool :)
23:51:55 <ManateeLazyCat> zeiris: In my code, Action is wrap for contain polymorphism-function (that have different argument).
23:52:22 <ManateeLazyCat> Then you can make any function wrap in Action, then lookup in Map.
23:52:53 <ManateeLazyCat> zeiris: Example, foo :: (Arg1, (Arg2, Arg3)) -> IO ()  and bar :: (Arg1, (Arg2, (Arg3, Arg4))) -> IO ()  have different argument.
23:53:23 <zeiris> So the type looks like Tuple Tuple Tuple... But what about the last one, where the type is TArg2, TArg3, doesn't that cause a typematch error?
23:53:23 <ksf> I WANT DYNAMIC LINKING!
23:53:31 <ManateeLazyCat> Because function's argument is "nested-tuple", so we just need write instance for arg1, arg2, arg3, arg4, then we can apply any polytechnic function.
23:53:38 <ksf> sorry I just had to mention that now that my box isn't thrashing, anymore.
23:53:40 <zeiris> I WANT CONSISTENT DOCUMENTATION QUALITY!
23:54:13 <ManateeLazyCat> instance (ActionInputArgs a, ActionInputArgs b) => ActionInputArgs (a, b) where
23:54:14 <ManateeLazyCat>     envGet env = liftM2 (,) (envGet env) (envGet env)
23:54:14 <ManateeLazyCat>  
23:54:25 <edwardk> zeiris: crap is consistent ;)
23:54:25 <blackdog> ksf: dynamic linking? you mean os-level?
23:54:31 <zeiris> ManateeLazyCat: aaaah :)
23:54:34 <ksf> no cabal-level
23:54:39 <ksf> and ghc-pkg level
23:54:51 <zeiris> edwardk: heh, so it is!
23:54:57 <ManateeLazyCat> zeiris: Because you have "instance (a,b) where", then ghc will do rest work for you.
23:54:59 <ksf> ghc can do .so's just fine, it's the tools that can't deal with it.
23:55:09 <blackdog> ksf: that works, i think
23:55:19 <blackdog> are you on mac?
23:55:21 <ksf> linux
23:55:24 <ManateeLazyCat> zeiris: So you just write instance for every *argument*, then ghc will match any *argument-nested-tuple*.
23:55:36 <blackdog> pretty sure that works - i'm using dynlibs in hubris
23:55:39 <blackdog> cabal handles it ok too
23:56:02 <ksf> cabal doesn't pass -shared when linking executables, and ghc-pkg fails to register packages that don't contain .hi but only .hi_dyn files
23:56:14 <blackdog> except on mac. hopefully dcoutts_ will let me know what's wrong with stephen blackheath's patch soon...
23:56:27 <blackdog> it does if you set --enable-shared, doesn't it?
23:57:04 <ksf> that will give you libaries, but executables will still be static
23:57:19 <ManateeLazyCat> zeiris: So nested-tuple fix your problem?
23:58:00 <tensorpudding> static kills computers, i don't want that shit in my libraries :|
23:58:26 * edwardk gives in and adds an unsafe poly-variadic grad combinator to the ad lib
23:58:59 <ManateeLazyCat> zeiris: In my code, nested-tuple for build polytechnic function, but you can write your own nested-tuple for your situation.
23:59:23 <edwardk> Numeric.AD.Unsafe ? or out in the main API clearly demarcated?
23:59:28 * ManateeLazyCat Nested-Tuple is good idea to match *polymorphism-type* (if i can call this)
