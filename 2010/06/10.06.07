00:04:02 <ski> well, with functions-as-relations, the union of two functions seen as relations needn't be a function
00:04:38 <ski> if we insist on the result being a function, that is what forces `X' and `Y' to unify, when we take the union of `{a : X}' and `{a : Y}'
00:06:02 <ski> when taking the union of sets, there's no corresponding restrictive condition that unifies parts of the sets
00:18:10 <gio123> ski
00:19:05 <ddarius> {1,2} =:= {1,2,X,Y} => X = 1 /\ Y = 2 \/ X = 2 /\ Y = 1
00:19:24 <ddarius> \/ X = Y = 1 or 2
00:23:34 <ski> hrm, of course you're right .. i retract my last statement :)
00:23:48 * ski ponders what prompted him to say it
00:24:25 <sizzler> what would be the best way to generate enough symbols so I can find the line nos. causing problem in a ffi binding lib. 
00:24:42 <sizzler> I tried -debug to ghc but it still doesnt show line nos.
00:26:50 <sizzler> I get a segmentation fault when I call the foreign fn. and want to see what line in the c prg. is causing probs
00:27:11 <ski> ddarius : ah, i see. i was talking about union, while you were talking about unification. i deretract the retracted statement :)
00:27:18 <copumpkin> compile your c module with -g
00:27:24 <copumpkin> and then run the whole thing in gdb
00:42:30 <sizzler> copumpkin, I did that. still the backtrace in gdb lists some weird functions and only 2 frames (cannot unwind)
00:42:41 <copumpkin> maybe something's screwing up your stack
00:44:39 * hackagebot bio 0.4.4 - A bioinformatics library  http://hackage.haskell.org/package/bio-0.4.4 (KetilMalde)
00:52:55 <h-cell> zip (IO [a]) (IO [b]) /= IO [(a,b)] can anyone explain?
00:53:17 <opqdonut> :t zip
00:53:18 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
00:53:18 <h-cell> is there  a zipM or something?
00:53:26 <opqdonut> :t liftM2 zip
00:53:27 <lambdabot> forall a b (m :: * -> *). (Monad m) => m [a] -> m [b] -> m [(a, b)]
00:53:31 <opqdonut> you can use that for example
00:53:42 * hackagebot ad 0.27 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.27 (EdwardKmett)
00:53:50 <copumpkin> there is a zipM
00:53:53 <copumpkin> :t zipM
00:53:54 <lambdabot> Not in scope: `zipM'
00:54:01 <copumpkin> :t zipWithM (,)
00:54:02 <lambdabot> forall a b. (Monad ((,) a)) => [a] -> [b] -> (a, [b])
00:54:06 <copumpkin> omg
00:54:19 <copumpkin> not what I wanted
00:54:20 <opqdonut> :t zipWithM (liftM2 (,))
00:54:20 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => [m a1] -> [m a2] -> m [(a1, a2)]
00:54:22 <opqdonut> :)
00:54:28 <copumpkin> there, that's more like it
00:54:36 <opqdonut> liftM2 zip is cuter...
00:54:48 <copumpkin> it's different though
00:54:55 <copumpkin> I guess he wanted liftM2 zip
00:54:58 <edwardk> now with prettier type signatures
00:55:24 <BMeph> :t liftM unzip
00:55:25 <lambdabot> forall a b (m :: * -> *). (Monad m) => m [(a, b)] -> m ([a], [b])
00:55:49 <BMeph> :t liftM2 zip
00:55:49 <ski> @type mapAndUnzipM
00:55:50 <lambdabot> forall a b (m :: * -> *). (Monad m) => m [a] -> m [b] -> m [(a, b)]
00:55:50 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m (b, c)) -> [a] -> m ([b], [c])
01:09:19 <h-cell> thanks opqdonut
01:10:01 <shadwick> bleh, why is haskell.org still down?
01:23:08 <Schalken> I have "No instance for (Control.Monad.IO.Class.MonadIO (StateT MD5Context IO))", but here it is in this module which I have imported: http://hackage.haskell.org/packages/archive/transformers/0.1.4.0/doc/html/src/Control-Monad-Trans-State-Lazy.html#line-182 How can I debug this?
01:28:06 <Saizan> Schalken: are you sure that's the same StateT type you are using?
01:33:13 <Schalken> Saizan: Ah! Err, no, I was importing Control.Monad.State.Lazy, but the instance decl is in Control.Monad.TRANS.State.Lazy. Thanks!
01:47:42 <Blkt> is there a cond statement in Haskell?
01:47:48 <Blkt> sort of?
01:48:21 <exDM69> Blkt: you can use guards
01:48:45 <Blkt> I need it inside a function and is too little code that appear only once to refactor it into a function I suppose
01:48:56 <Blkt> mmm
01:48:57 <roconnor> if then else?
01:49:08 <exDM69> roconnor: is there an else if there?
01:49:22 <roconnor> well you can do if then else if then else if then else ...
01:49:28 <ski> > case () of () | 2 > 3 -> "2 > 3" | 2 < 3 -> "2 < 3" | 2 == 3 -> "2 == 3"
01:49:29 <lambdabot>   "2 < 3"
01:49:31 <Blkt> that's hugly, but I think I can reafctor the whole function as exDM69 said
01:49:39 <roconnor> but I'd usually write a function in the where clause
01:49:43 <roconnor> with guards as exDM69 says
01:49:44 <exDM69> Blkt: you can always make a private function with guards inside the outer function
01:49:48 <Blkt> the if then else is Hugly I ment
01:49:50 <ski> (indent as prefered)
01:49:53 * ksf applauds the excellent haddock that comes with fgl.
01:49:59 <Blkt> exDM69: how?
01:50:05 <ski> Blkt : ^
01:50:11 <exDM69> Blkt: foo f = foo'
01:50:20 <roconnor> ski: oh I don't think I knew you could have gaurds in case statements
01:50:23 <ksf> there's an example for every function, and no function has too short and cryptic a name
01:50:44 <exDM69> Blkt: foo f = foo' f where foo' f | f == 0 || f == 1 = x    | f % 2 == 0 = y
01:50:46 <ksf> also, it's always perfectly clear from the context in which order traversal functions traverse.
01:50:48 <exDM69> Blkt: like that
01:50:54 <Blkt> exDM69: awsome, thanks
01:51:15 <exDM69> Blkt: insert newlines and indentations where appropriate
01:51:27 <Blkt> sure
01:51:27 <ski> exDM69 : btw, in that case, there's no need to pass `f' as a parameter
01:51:55 <exDM69> ski: the guards work without parameters too?
01:51:59 <ski> > let foo | 2 > 3 = "2 > 3" | 2 < 3 = "2 < 3" | 2 == 3 = "2 == 3" in foo
01:52:00 <lambdabot>   "2 < 3"
01:52:02 <ski> exDM69 : yes
01:52:06 <Blkt> ski: I got the point anyway, one of the arguments to be defined in a where clause can be guarded
01:52:33 <Blkt> and that's good sometimes
01:53:34 <roconnor> Blkt: arugments aren't guarded, it is the entire line that is guarded.
01:54:23 <Blkt> mmm
01:55:15 <Blkt> roconnor: not in exDM69 example, am I wrong?
01:55:41 <Blkt> he defined a guarded inner function in a where clause
01:56:02 <ski> Blkt : in exDM69's example, the equation defining  foo' f  was guarded
01:56:02 <roconnor>  "foo' f" is the line with the guard.  The guard does't apply to "f"
01:56:39 <Blkt> roconnor: yes, but if foo had more lines inside where, only foo' would be guarded, right?
01:57:16 <roconnor> Blkt: The guards can refer to to more parameters than just f if there were more parameters
01:57:27 <roconnor> Blkt: and the guards don't even have to mention f at all.
01:57:51 <roconnor> Blkt: but yes, the guard only applies to "foo' f"
01:58:02 <Blkt> I think I got it
01:58:31 <roconnor> if foo' had more sophisticated pattern matching then foo' might be defined over several lines.
01:58:43 <roconnor> in that case the guards only apply to one line
01:59:00 <ksf> ...the part after | is just an arbitrary term of type Bool
01:59:11 <ksf> no magic there
01:59:17 <ksf> @src otherwise
01:59:17 <lambdabot> otherwise = True
01:59:22 * ski kindly hands roconnor the fine, fine words "(defining) equation" and "clause"
01:59:32 <roconnor> ski: ahhhh
02:00:16 <ksf> @djinn [(Bool,a)] -> a
02:00:16 <lambdabot> Error: Undefined type []
02:00:24 <ksf> lazy bastard.
02:00:34 <ski> @djinn (Bool,a) -> (Bool,a) -> a
02:00:34 <lambdabot> f (a, b) =
02:00:34 <lambdabot>     case a of
02:00:34 <lambdabot>     False -> \ (c, d) ->
02:00:34 <lambdabot>              case c of
02:00:34 <lambdabot>              False -> d
02:00:36 <lambdabot>              True -> b
02:00:38 <lambdabot>     True -> \ (e, f) ->
02:00:40 <lambdabot>             case e of
02:00:42 <lambdabot>             False -> b
02:00:44 <lambdabot>             True -> f
02:01:26 <ksf>  @djinn (Bool,a) -> (Bool,a) -> a -> a
02:01:31 <ksf> @djinn (Bool,a) -> (Bool,a) -> a -> a
02:01:31 <lambdabot> f (a, b) =
02:01:31 <lambdabot>     case a of
02:01:31 <lambdabot>     False -> \ (c, d) e ->
02:01:31 <lambdabot>              case c of
02:01:31 <lambdabot>              False -> e
02:01:33 <lambdabot>              True -> d
02:01:35 <lambdabot>     True -> \ (f, _) g ->
02:01:37 <lambdabot>             case f of
02:01:39 <lambdabot>             False -> g
02:01:41 <lambdabot>             True -> b
02:02:00 <ksf> that's more like it.
02:02:15 <Blkt> what the hell is @djinn ?
02:02:19 <safiire> How can I get ghc to produce an x86_64 binary instead of i386, on osx?
02:02:21 <ski> @help djinn
02:02:21 <lambdabot> djinn <type>.
02:02:21 <lambdabot> Generates Haskell code from a type.
02:02:21 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
02:02:50 <ksf> safiire, install the 64bit version
02:02:56 <ksf> (I'm no osx user)
02:03:21 <Makoryu> safiire: You have to have 6.12, for starters.
02:03:28 <safiire> I do
02:03:53 <safiire> I have installed 6.12 from the haskell platform for osx.
02:03:56 <ivanm> safiire: you have a 64bit processor presumably?
02:04:01 <safiire> yes
02:04:03 <edwardk> @tell ivanm i managed to encapsulate the universal quantification behind a type synonym.
02:04:03 <lambdabot> Consider it noted.
02:04:12 <edwardk> hah and then he speaks
02:04:13 <ivanm> @clear
02:04:13 <lambdabot> Messages cleared.
02:04:26 <ivanm> edwardk: yup, I was waiting for you to start typing!
02:04:31 * ivanm has satellites...
02:05:25 <edwardk> ivanm: now they look like: hessian :: (Traversable f, Num a) => FU f a -> f a -> f (f a)
02:05:45 <edwardk> and i export the 4 type synonyms UU, UF, FU, FF in each module
02:05:58 <ski> (.. whence universal quantification ?)
02:06:04 <safiire> I do have a 64 bit processor, and I believe mostly snow leopard is all 64 bit now.  I am trying to call some haskell code from my c++ project in xcode and it is having trouble finding the symbol _environ.  I can make xcode emit a 64bit binary or an i386.  I was seeing if it made any difference if I compile the gch portion in different arches.
02:06:20 <edwardk> ski: they were like
02:06:46 <edwardk> hessian: (Traversable f, Num a) => (forall s. Mode s => f (AD s a) -> AD s a) -> f a -> f (f a)
02:06:57 <edwardk> the quantifier served two purposes
02:07:33 <edwardk> to keep you from using the details of the particular AD mode you were using to cheat. (so you can't access the primal or do bad things in general), and to keep you from confusing infinitesimals.
02:08:10 <ski> m, the first is just abstracting away impl. details
02:08:18 <ivanm> edwardk: \o/
02:08:24 <edwardk> ski: yes
02:08:35 <edwardk> ski: but they were scaring the hell out of some folks ;)
02:09:09 <edwardk> and you can quickly summarize the rules behind the 4 argument types and then read the rest of the sigs without boilerplate
02:09:48 * ivanm isn't paying much attention here atm as he's talking with his folks via skype
02:10:46 * ski doesn't really know what the `hessian' is, though ..
02:11:29 <edwardk> ski: jacobian of grad
02:11:53 <ski> hm, k
02:12:12 <edwardk> ski: its the n * n matrix of 2nd derivatives of a function from R^n -> R
02:12:28 <edwardk> n is being approximated by the Traversable f above
02:13:14 <edwardk> so hessian f xs -- gives you the information on the inflection at that point
02:13:19 <ski> so twice-partials ?
02:13:24 <edwardk> yeah
02:13:47 <edwardk> it'll be subsumed by my shiny new gradients method once i work out how to get the cofree AD mode to work
02:15:19 <edwardk> gradients :: (Traversable f, Num a) => (forall s. Mode s => f (AD s a) -> AD s a) -> f a -> (f :> a) -- where f :> a is the cofree comonad/branching stream of f.
02:16:06 <edwardk> which gives answers like a :< f (da :< f (dda :< f (ddda  ...)))
02:16:21 <ski>   f :> a  =  nu r.  a * f r
02:16:23 <edwardk> with each level holding higher and higher level partials
02:16:30 <edwardk> yeah
02:16:40 <edwardk> data f :> a = a :< f (f :> a)
02:17:14 <ski> hm, or maybe actually `f :> a' being a non-regular type `a * f :> f a' ?
02:17:32 <ski> hm, ok not, then
02:17:37 <BONUS> vim
02:17:40 <edwardk> hah that is the other one i tried
02:17:50 <BONUS> lol wrong prompt
02:17:51 <ski> ed
02:18:03 <edwardk> data f :- a = a :- (f :- f a)
02:18:35 <ski> (.. since you said `a :< f (da :< f (dda :< f (ddda  ...)))')
02:19:13 <edwardk> the f :- a type is one i'm considering how to build a conversion to from f :> a
02:19:16 <ski> (or, hm, actually i somehow read that as `a :< (fa :< (ffa :< (fffa ...)))')
02:19:17 <edwardk> because its darn convenient
02:19:48 <edwardk> the d*a's there are all the same type, just denoting the higher derivatives
02:20:11 <edwardk> ski: challenge for you
02:20:27 <ski> the use of `f :- a' on the type and `a :- ..f..' on the value level seems (needlessly) confusing to me
02:20:32 <edwardk> find me a function for (f :> a) -> f :- a -- that does the right thing
02:20:59 <edwardk> hahaha that is the first time i've ever heard you of all people, call notation confusion ;)
02:21:20 <edwardk> er confusing
02:21:33 <ski> well, i'm sometimes picky with notation .. mostly with ambiguous notation, though
02:22:02 <edwardk> but i'm serious about hunting for a function from (f :> a) -> f :- a -- that'd be really nice to have
02:22:34 <ski> (like the twice-damned `f = f(x)',`D (x^2)',`d f / d x' confusion, and it's many more hydra-heads that keep popping up !)
02:24:05 <edwardk> (a :< as) = a :- fmap head as :- fmap (fmap head . tails) :- ... or something
02:24:42 <edwardk> trick is identifying the nice base case and recurrence
02:25:46 <edwardk> where head = extract and tails (a :< as) = as
02:25:47 <ski> hm
02:27:19 <ski> hm
02:28:49 <ski>   f (f :> a)  <~>  f (a * f (f :> a))  >->  f a * f (f (f :> a))
02:28:51 <ski> whither ?
02:29:20 <edwardk> yeah
02:29:27 <edwardk> wait
02:29:35 <edwardk> did you drop an extra f in there (or maybe i did)
02:29:43 <edwardk> i just sketched ;)
02:29:59 <ski> i wrapped an extra `f', since i appeared to need that in the above
02:30:00 <edwardk> no you're right
02:30:13 <edwardk> shouldn't the base case for each is a no?
02:30:41 <edwardk> (f :> a) = a :< (f :> a)
02:30:43 * ski peers confounded at edwardk
02:31:58 <ski> hm
02:32:05 <edwardk> oh
02:32:05 <edwardk> hah
02:32:29 <edwardk> er nope, nm i thought i caught the misunderstanding but the pasted data types were right here
02:34:21 <ski>   f (f :> a)  <~>  f (a * f (f :> a))  >->  f a * f (f (f :> a))  <~>  f a * f (f :- f a)  >->  f (a * (f :- f a))  <~>  f (f :- a)
02:34:28 <ski> look yonder ^
02:34:38 <ski> we start with
02:35:07 <edwardk> we start with (f :> a)
02:35:22 <ski> hm, actually
02:35:23 <edwardk> the base case of f :- a is an a 
02:36:00 <ski> (i was in-goring that, since for some reason i though that was an odd case .. which it appears to not be)
02:36:43 <ski> (but something is amiss in my thought)
02:37:13 <edwardk> see why i thought it was an interesting exercise?
02:37:23 <ski> hm
02:37:53 <edwardk> hrmm i may have a recurrence
02:38:41 <edwardk> layers aas = head aas :- (fmap head . tails) aas :- (fmap (fmap head . tails) . tails) aas
02:38:51 <edwardk> seems to suggest a base case of head
02:39:08 <ski>   f :> a  <~>  a * f (f :> a)  >->  a * f (f :- a)  >->  a * (f :- f a)  <~>  f :- a
02:39:12 <edwardk> and that you take that through (\f -> fmap f . tails)
02:39:14 <ski> this leaves us to prove
02:39:22 <ski>   f (f :- a)  >->  f :- f a
02:40:19 <edwardk> ski: you can't do that one no?
02:40:24 <edwardk> the outer a is missing
02:40:57 <ski> that b'ain't
02:41:49 <edwardk> ?
02:42:17 <trin_cz> hi, is there a way to specify wider paper size (or smaller font) in hp2ps. The ps is deformed when using long lines.
02:42:59 <ski>   f (f :- a)  <~>  f (a * (f :- f a))  >->  f a * f (f :- f a)  >->  f a * (f :- f (f a))  <~>  f :- f a
02:43:02 <ski> there
02:43:23 <mreh> any plans to integrate c2hs into ghc?
02:43:30 <ski> (`f (f :- a)' contains no single outer `a', but one `a' for each branch of the outermost `f')
02:43:55 <edwardk> so now haskellify that ;)
02:44:00 * ski suspect this inner process commutes with the recursion of the outer one
02:44:36 <ski> there ought to be a tool to automatically translate definitions-by-commutative-diagrams into Haskell ..
02:45:01 <ville> Here I was thinking that was Haskell already.
02:45:49 <ski> you'll note i've used `unzip :: forall a b. f (a,b) -> (f a,f b)' above
02:45:58 <edwardk> yeah
02:46:11 <ski> (but i don't think that's a restriction, inside Haskell)
02:46:26 <edwardk> its safe for any Functor f.
02:46:47 <edwardk> i use it a lot with my derivatives library
02:46:57 <edwardk> since i keep things tupled because you can always unzip
02:47:06 <edwardk> but can't always zip
02:47:11 <ski> *nod*
02:48:46 <ski>   levels :: Functor f => f :> a -> f :- a
02:49:22 <edwardk> ski: thats the goal
02:50:01 <edwardk> that gives me a very pretty gradients type. because the end user could take my cofree comonad and chunk it, looking k elements into the result for their answer
02:50:05 <ski>   levels (a :< f_fa) = a :- sequence (levels `fmap` f_fa)
02:50:23 <ski>   sequence :: Functor f => f (f :- a) -> f :- f a
02:50:28 <edwardk> sexy
02:50:53 <ski> (.. now, what to name this variable ? ..)
02:51:12 <edwardk> i hope you don't mind if i call the internal function for the sequence ski ;)
02:54:39 <ski>   sequence fas = as :- sequence f_fa_s
02:54:43 <ski>     where
02:54:47 <ski>     as = (\(a :- _) -> a) `fmap` f_fa
02:54:48 <ski>     f_fa_s = (\(_ :- fa) -> fa)
02:54:52 <ski> something like that
02:55:01 <ski> er, missing on the last line
02:55:08 <edwardk> thats pretty close to what i spit out modulo a fmap
02:55:09 <ski>     f_fa_s = (\(_ :- fa) -> fa) `fmap` f_fa  -- corrected
02:56:04 <ski> maybe one could do something fancy with comonads here, not sure
02:56:12 <edwardk> yeah
02:56:39 <ski> @type sequence
02:56:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:56:42 <edwardk> erm where did f_fa come from
02:56:50 <ski> @type Data.Traversable.sequence
02:56:51 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
02:57:18 <ski> edwardk : er, sorry, unify `fas' and `f_fa'
02:57:26 <ski> (the naming is bad, and inconsistent)
02:57:34 <edwardk> np
02:58:05 <ski> so i suppose maybe `sequence' above ought to be called `unsequence' ?
02:58:33 <ski> (or `cosequence' ?)
02:58:39 <edwardk> yeah
02:58:51 <ski> (since `(f :-)' is probably a comonad ..)
02:59:01 <edwardk> its just 'ski' in my code ;)
02:59:28 <edwardk> ski: well, it can be obtained from (f :>) -- so it should be
02:59:55 * ski solemnly resolves to name his temporary functions and types `edwardk', `Edwardk', `edwardk42', &c.
03:00:00 <edwardk> hahaha
03:00:26 <edwardk> well it is a nested combinator in a where clause =P
03:01:38 <ski> well, this was a fun exercise
03:01:48 <ski> thank you, kind sir !
03:02:19 <edwardk> happy to feed you puzzles, especially when they make my code cleaner ;)
03:02:32 * ski grins
03:02:47 <edwardk> next exercise
03:02:53 <edwardk> the comonad for (f :-) ;)
03:03:08 * ski was sortof suspecting that
03:03:35 <ski> so, `extract' and `fmap' are obvious
03:03:38 <ski> so
03:03:53 <ski>   split :: forall a. f :- a -> f :- (f :- a)
03:04:23 <edwardk> shouldn't be terrible
03:04:25 * ski peers at this from different angles
03:05:20 <ski>   a * (f :- f a)  >->  (f :- a) * (f :- f (f :- a))
03:05:59 <ski>   a * (f :- f a)  >->  a * (f :- f a) * f (f :- a) * (f :- f (f (f :- a)))
03:06:03 <ski> ho hum ..,
03:06:13 <ski> oh
03:06:29 <ski>   a * (f :- f a)  >->  a * (f :- f a) * (f :- f (a * (f :- f a)))
03:06:38 <ski> is perhaps a more useful unfolding
03:06:54 <edwardk> hrmm
03:07:02 <FunctorSalad> CPS is made pretty cool alone by the fact that you have to type fewer tuples and case statements (caused by returning multiple resp. sumtype values), isn't it? ;)
03:07:14 <edwardk> FunctorSalad: yes =)
03:07:25 <edwardk> though the newtypes to make haskell happy eat up all that nice economy
03:08:04 <ski> (it would be even cooler if we could get similar performance behaviour without invoking the (well, more or less) global CPS transformation)
03:09:11 <FunctorSalad> edwardk: hmm newtypes? I mean I just use "... -> (Foo -> Bar -> IO r) -> IO r" instead of "... -> IO (Foo,Bar)"
03:09:21 <edwardk> ski: hrmm do you think the notation is less ambiguous if i used data f :- a = (f :- f a) :- a ?
03:09:35 <FunctorSalad> it's a bit like "out" parameters ;)
03:09:51 <edwardk> FunctorSalad: that works fine
03:10:01 <edwardk> its whe you want to interoperate with ContT, etc. that it bites you
03:10:07 <edwardk> witness the body of monad-ran ;)
03:10:15 <FunctorSalad> I see
03:10:34 <ski> edwardk : that would be somewhat better, yes (the former was not really ambiguous, just giving incorrect suggestions); however not using the same symbol for the type constructor as for the data constructor would also do fine ;)
03:11:14 <FunctorSalad> heresy
03:11:23 <FunctorSalad> ;)
03:11:51 <edwardk> any luck with duplicate?
03:12:04 <ski> (pondering ..)
03:12:34 <ivanm> edwardk: I'm back if you wanted to say anything to me ;-)
03:12:42 <edwardk> i'm good =)
03:14:18 <ski> (hm, i suppose i shouldn't use `Zippable (f :-)' before having proved `Comonad (f :-)' ..)
03:14:39 <edwardk> hah
03:15:06 <edwardk> yeah you may need zipping which would kind of ruin the whole thing
03:15:15 <edwardk> in fact i can't see how you wouldn't need it
03:15:46 <ski> well, i appear to need `f (f :- a)  >->  f :- f a', at least
03:16:17 <edwardk> f (f :- a) -> f :- f a -- you already built which is hany
03:16:18 <edwardk> er handy
03:16:52 <ski> hm, oh .. i thought this was the ither direction :)
03:17:06 <edwardk> the other way needs zip
03:17:17 <ski> (but maybe i need the other as well ..)
03:18:07 <edwardk> conceptually you have broken up things into towers of fs. a :- f a :- f (f a) :- ... but you can't peel off one f from each consistently
03:18:27 <edwardk> if f was Traversable perhaps
03:18:39 <edwardk> which for me it is
03:18:59 <edwardk> and i can also guarantee that i only build these things from a limited number of cases where all fs have the same shape
03:22:58 <FunctorSalad> . o O ( the decls "val = (.)" and "arg = flip (.)" let you write some pretty hilarious code... but I'm not sure if it's good or evil )
03:23:13 <ski> @where SEC
03:23:13 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
03:23:53 <FunctorSalad> you can systematically eliminate points that way without degenerating into line noise like with (.) ;)
03:24:03 <FunctorSalad> but not sure how readable it really is
03:24:40 <ski> (with some training, one can often spot `result' and `argument' in `(foo .) .'-kind line noise)
03:24:55 <FunctorSalad> ski: (ad SEC) sure, I wasn't claiming any originality
03:25:15 <ski> (just pointing to it in case you hadn't seen it yet)
03:28:11 <FunctorSalad> I've seen "range" and "result" used :) chose "val" for symmetry with "arg" ;)
03:29:01 <FunctorSalad> "res" is too overloaded (result, resource, thing)
03:29:30 <ski>   f :- a  >->  (f :- a) * ((f :- a)  <~>  a * (f :- f a))  >->  (f :- a) * (f :- (f :- f a))  >?>  (f :- a) * (f :- f (f :- a))  >->  <~>  f :- (f :- a)
03:29:39 <Zao> FunctorSalad: response
03:29:45 <FunctorSalad> point
03:29:57 <Zao> resurrect :D 
03:30:03 <FunctorSalad> while "valor" etc aren't so common in CS
03:30:04 <edwardk> @hpaste
03:30:05 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:30:05 <FunctorSalad> ;)
03:30:39 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25970#a25970
03:32:27 <edwardk> ski: thanks for your help! =)
03:32:56 * ski wonders whether there's any way to avoid the `f :- f a  >->  f (f :- a)' above
03:33:29 <edwardk> not and retain anything like the semantics of (f :> a) where you can see the entire tower below you
03:33:46 <ski> (presumably then with the help of a lemma / helper-function that does most of the real work)
03:34:14 <FunctorSalad> such abbreviated identifiers were really bizarre when I was very young (you know, before you learned to lookup definitions aggressively and pondered the identifier instead ;) Zao's res=resurrect? would be a good example)
03:34:49 <edwardk> going to grab a half our worth of sleep
03:34:55 <edwardk> thanks again
03:35:02 <edwardk> lemme know if you spot a comonad in there
03:35:06 <edwardk> but i'm dubious
03:35:11 * ski possibly will take a nap, too ..
03:35:12 <FunctorSalad> :)
03:36:01 <xenoblitz> Guys, say I have 3 types... data A, data B and data C a... is it possible to have a list of C A and C B as [C a]? Hope I have worded that correctly. 
03:36:31 <ski> xenoblitz : you can have `[C (Either A B)]' ..
03:37:31 <xenoblitz> ski: ok thanks... can you shed any light on why its not possible to have directly [C a] is it due to type inference?
03:37:55 <ski> you can have `[C a]' as well, but that `a' is not related to `A' and `B', then
03:38:08 <ski> of course you can also have `[C A]' as well as `[C B]'
03:38:22 <xenoblitz> ski: so either [C A] or [C B] basically
03:38:29 <FunctorSalad> you can think of [C a] as "for any concrete 'a' you can give me, I have a [C a]"
03:38:32 <ski> .. maybe what you're *actually* looking for is existential data types ?
03:38:44 <FunctorSalad> neither a:=B nor a:=C do in this case :)
03:38:54 <xenoblitz> ski, FunctorSalad: yes makes sense
03:38:54 * ski is just guessing wildly, based on the insufficient information given in this case
03:39:17 <FunctorSalad> xenoblitz: it *is* possible to make types like lists but where you don't have to make the same choice each time... but it's more complicated
03:39:18 <xenoblitz> ski: could be hehe because the way i need it I'm assuming there exists a type
03:39:22 <xenoblitz> where bla bla
03:39:41 <xenoblitz> FunctorSalad: type classes to the rescue?
03:40:04 <ski> (hint : it would be easier to read your mind if you gave more context, gave actual code snippets, explained what problem you're *really* trying to solve, and/or pasted some problematic code ..
03:40:37 <FunctorSalad> xenoblitz: yeah that's what HList does... and then there are the existentials ski mentioned, either as list element type, or built into your collection type somehow
03:40:39 <xenoblitz> ski: ok I'll try to come up with a simple example as its kinda hard to take the idea from my code directly
03:41:18 <xenoblitz> FunctorSalad, ski: I'll look up existentials when haskell.org is back I guess ;P
03:41:44 <FunctorSalad> (Either could be considered an existential type if you squint hard enough ;) except Either is just for two types while existentials are possibly infinite sums)
03:42:02 * ski was feeling tired, so he decided to lie down and sleep.
03:42:08 <FunctorSalad> it's very analogous to binary "OR" vs the existential quantifier in predicate logic
03:43:38 <FunctorSalad> (if you think of the latter informally as a sort of "infinitary OR")
03:44:10 <FunctorSalad> exists a. P[a] "=" P[x1] or P[x2] or P[x3] or ......
03:44:19 <FunctorSalad> if x_i is an enumeration of your universe
03:45:53 <xenoblitz> something like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25971#a25971
03:47:05 <xenoblitz> hope it makes sense hehe
03:47:22 <xenoblitz> I guess existentials IS what i am looking for
03:48:06 <Ytinasni> he wants a GADT on Instruction, maybe.
03:48:38 <xenoblitz> Ytinasni: I tried that, unfortunately I'm converting my data types to JSON and found it a tad complicated to use GADTs
03:49:04 <FunctorSalad> xenoblitz: for just two types "Either" is fine, no need for existentials
03:49:27 <FunctorSalad> (your B and C)
03:49:30 <xenoblitz> FunctorSalad: yeah I'll do that, looks like the simplest option
03:49:53 <mreh> haskell.org is still down :(
03:50:00 <mreh>  rl
03:50:06 <mreh> it's been broken over a day now
03:50:19 <FunctorSalad> Ytinasni: especially if B and C are under his control...
03:50:43 <FunctorSalad> then you might want to join them into a single GADT type FOO where the old B will be "FOO B" and the old C "FOO C"
03:50:43 <xenoblitz> mreh: what I do is google what I need and click on the cached links
03:50:57 <FunctorSalad> hmm wait, that wouldn't help at all ;)
03:51:04 <FunctorSalad> nvm
03:51:14 <FunctorSalad> you'd still have to existential-wrap
03:51:49 <mreh> is hackage on a different machine?
03:52:46 <xenoblitz> FunctorSalad: no worries, I'll use Either or simply return two lists... otherwise I'll look up existential types
03:53:00 <xenoblitz> FunctorSalad, ski, Ytinasni: thanks
04:01:50 <o-_-o> hello
04:01:58 <o-_-o> I have a small problem
04:02:08 <o-_-o> I have a state of type IORef :: Bool
04:02:18 <zygoloid> i quite like the syntax 'data Instruction Captain = ...; data Instruction General = ...', but i'm not sure whether that'd be an open (type family) or closed (GADT) type function
04:02:46 <o-_-o> I want to get it and stuff it back into itself after 'not' it
04:02:49 <o-_-o> like so
04:03:04 <zygoloid> i guess closed, by analogy to function bindings
04:03:08 <xenoblitz> zygoloid: you lost me at open and closed =/
04:03:12 <o-_-o> active state $~ not (get (active state))
04:03:38 <zygoloid> xenoblitz: essentially, would other modules be able to extend it by saying 'data Instruction MyType = ...'
04:04:08 <Lemmih> o-_-o: Do it in two steps.
04:04:22 <xenoblitz> zygoloid: well closed really if I understood correctly, as I don't intend to let other modules extend it
04:05:16 <o-_-o> Lemmih, ok
04:05:19 <o-_-o> I tried this
04:05:29 <o-_-o>  argh <- get (active state)
04:05:30 <o-_-o>   active state $~ not argh
04:05:50 <o-_-o> now I get Couldn't match expected type `Bool -> Bool'
04:05:50 <o-_-o>            against inferred type `Bool'
04:06:00 <o-_-o> in the second argument of ($~)
04:06:07 <o-_-o> namely not argh
04:06:17 <zygoloid> xenoblitz: well, you can write that today as 'data Instruction a where Attack :: Instruction Captain; Order :: Instruction General; ...'
04:06:28 <zygoloid> xenoblitz: but that won't allow generateInstructions to be well-typed
04:06:48 <xenoblitz> zygoloid: yeah it still doesn't solve my problem =P
04:06:52 <zygoloid> xenoblitz: incidentally, how do you intend to /use/ the result of generateInstructions?
04:07:32 <Lemmih> o-_-o: Try: active state $~ not
04:07:33 <zygoloid> it seems like you'd want to pattern-match on Captain/General before you could make sense of the instruction
04:08:08 <zygoloid> in which case, i think you just want data Instruction = CaptainInstruction CaptainInstruction | GeneralInstruction GeneralInstruction
04:08:16 <xenoblitz> zygoloid: mainly use them to change a game state, I wrote a function which receives [Instruction a] but now I realize that in order to work like this I need to change a few things (before I was using Instruction only)
04:08:27 <o-_-o> Lemmih, ah...that worked
04:08:57 <o-_-o> Lemmih, why didn't (not argh) work ?
04:09:12 <o-_-o> :t of not argh is Bool ?
04:09:13 <lambdabot> parse error on input `of'
04:09:24 <o-_-o> :t not False
04:09:25 <lambdabot> Bool
04:09:38 <zygoloid> xenoblitz: well, another option would be to make an existential, data AnyInstruction where AnyInstruction :: Instruction a -> AnyInstruction
04:09:58 <Lemmih> @type Data.IORef.modifyIORef
04:09:58 <lambdabot> forall a. GHC.IOBase.IORef a -> (a -> a) -> IO ()
04:10:33 <Lemmih> o-_-o: $~ is modifyIORef. It takes an IORef and a function for modifying it.
04:11:12 <Lemmih> o-_-o: That is, the second argument must have the type (Bool -> Bool) and not just Bool.
04:11:25 <o-_-o> how do put something into a state ?
04:11:31 <xenoblitz> zygoloid: I'm reading up on existentials just to see my options: http://webcache.googleusercontent.com/search?q=cache:sZkhZI66FIoJ:www.haskell.org/haskellwiki/Existential_type+haskell+existential&cd=1&hl=mt&ct=clnk&gl=mt
04:11:37 <o-_-o> $= ?
04:11:45 <xenoblitz> zygoloid: thanks though
04:12:19 <Lemmih> o-_-o: That or 'set', I think. Check the documentation to be sure.
04:12:41 <o-_-o> Lemmih, ok...thanks
04:12:44 <o-_-o> one more thing
04:13:00 <o-_-o> I don't know if this makes sense...but here goes it anyway
04:13:10 <o-_-o> keyboard :: State -> KeyboardMouseCallback
04:13:18 <o-_-o> this is how the glut callback function is defined
04:13:27 <o-_-o> keyboard state (MouseButton b) Down _ _ =
04:13:35 <o-_-o> and this is function definition
04:13:50 <o-_-o> now when I try to get things out of state it says parse error
04:13:53 <o-_-o> like so
04:13:58 <o-_-o> keyboard state (MouseButton b) Down _ _ =
04:14:10 <o-_-o> s <- get (active state)
04:14:28 <o-_-o> is this because there is no 'do' 
04:14:40 <Lemmih> o-_-o: Yes.
04:14:50 <o-_-o> ah...thanks
04:14:58 <o-_-o> ok that worked cool
04:15:13 <o-_-o>   a <- get (active state)
04:15:13 <o-_-o>   active state $= not a
04:15:16 <o-_-o> this works
04:15:40 <Lemmih> o-_-o: That's the same as: active state $~ not
04:16:05 <o-_-o> Lemmih, yeah...now I get it :-)
04:16:16 <o-_-o> :t ($=)
04:16:17 <lambdabot> Not in scope: `$='
04:16:32 <Lemmih> ?index $=
04:16:32 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
04:16:46 <Lemmih> :t (Graphics.UI.GLUT.$=)
04:16:46 <lambdabot> Couldn't find qualified module.
04:17:03 <o-_-o> Lemmih, it is in the state monad I think
04:17:27 <o-_-o> import Data.IORef ( IORef, newIORef )
04:17:32 <Lemmih> o-_-o: No, it's from the OpenGL package.
04:18:34 <o-_-o> hmmm
04:18:41 <Bigglotron> anyone currently on knowledgeable about Haskell game development?
04:19:34 <o-_-o> http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
04:19:45 <Jafet> Bigglotron: "tricky"
04:20:23 <o-_-o> Bigglotron, I am writing simple GLUT programs using haskell
04:20:48 <Bigglotron> oic.
04:20:48 <o-_-o> Bigglotron, I plan to do 'something' along the lines of a 3d demo
04:21:04 <o-_-o> nothing big like a game, though
04:21:24 <Bigglotron> I've been porting a pen and paper rpg system some friends and I wrote to a set of haskell modules.
04:21:27 <o-_-o> Bigglotron, there is a quake like game written in haskell
04:21:37 <o-_-o> Bigglotron, cool
04:21:47 <Bigglotron> I saw that one. Someone's master's thesis right?
04:22:14 <o-_-o> yesh
04:22:18 <o-_-o> yeah*
04:22:57 <Bigglotron> Mostly I'm doing it because it confirms that the game rules formalise well and also to do some numerical tests / visualisation stuff that would be hard on paper because of the lack of numbers in the rules.
04:23:38 <Itkovian> Bigglotron: See also HRay for a Haskell raytracer based on formal rules.
04:23:43 <Itkovian> by boegel 
04:23:54 <boegel> by me!
04:23:56 <Bigglotron> that sounds interesting. i like raytracers.
04:24:17 <boegel> so do I
04:24:49 <o-_-o> heh
04:25:02 <Bigglotron> I am a relatively inexperienced Haskell programmer at the moment though. heh.
04:25:19 <boegel> Bigglotron: so was I when I implemented HRay
04:25:33 <boegel> and I still am, actually
04:25:36 <Jafet> There is a raytracer in javascript
04:25:44 <Bigglotron> haha.
04:26:04 <Bigglotron> What is bugging me about this game thing is how do I represent inherently stateful game characters in the type system.
04:27:36 <Bigglotron> Do I just have to bite my lip and make each minor change in a character require a whole new character value based on the old one
04:27:39 <Jafet> Seems that some nut wrote it to benchmark google V8. We should hook him up with dons
04:28:08 <Bigglotron> or use skeleton data and calculate everything else from functions only or what
04:28:15 <Jafet> Bigglotron, there are numerous ways to handle state in haskell; be sure to familiarize yourself with them first
04:28:54 <Jafet> ST or IO, CPS, State(T)
04:28:59 <Bigglotron> I am familiar with the IO monad / monads in general but not to the point of writing my own.
04:29:12 <Bigglotron> Don't know the others.
04:29:19 <o-_-o> Bigglotron, state monad
04:29:36 <o-_-o> Bigglotron, have you seen how state is handled in a GLUT program ?
04:29:49 <o-_-o> that looks interesting
04:30:04 * hackagebot minesweeper 0.8.9 - Minesweeper game which is always solvable without guessing  http://hackage.haskell.org/package/minesweeper-0.8.9 (PeterDivianszky)
04:30:24 <rj248842> is haskell.org down, and if so, when will it be up again?
04:30:30 <sioraiocht> down again, eh?
04:30:38 <Itkovian> it's been down for some time now afaik
04:30:43 <sioraiocht> bummer, dude
04:30:59 <Bigglotron> I haven't, o-_-o.
04:31:03 <Bigglotron> I'll look.
04:31:17 <o-_-o> ok here is a small program I am writing
04:31:30 <Jafet> But today it is different! Today I can righteously berate you all for not reading the topic.
04:32:19 <o-_-o> Bigglotron, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25972#a25972
04:32:54 <o-_-o> there a statevar is used to store and retrieve state, but I am sure there are better ways to do this, I am also a newbie at this...
04:33:17 <o-_-o> Bigglotron, http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
04:35:20 <Bigglotron> Ah. When I first looked at OpenGL stuff I was wondering what all the $= was about. Now I know.
04:38:26 <Itkovian> boegel: isn't HRayMain not simply the cmdline version?
04:39:42 <Bigglotron> well thanks for the info dudes. i'm gonna sleep.
04:42:59 <boegel> Itkovian: it might be, yes
04:43:07 <boegel> Itkovian: I seem to recall such a thing
04:43:10 <Itkovian> It is certainly building
04:43:13 <Itkovian> without gtk crap
04:43:20 <Itkovian> thx
04:43:26 <boegel> yeah, I don't think the gtk stuff is required
04:45:18 <boegel> what's the deal with haskell.org?
04:45:30 <boegel> "avoid succes at all cost"?
04:47:19 <Lemmih> boegel: http://www.reddit.com/r/haskell/comments/cbkkb/wwwhaskellorg_wiki_mailing_list_server_has_been/
04:47:21 <Jafet> It makes a lot of sense actually, now that you put it that way
04:48:09 <Ke> mirrors would be awesome for extra reliability
04:48:19 <pastorn> boegel: yeah, it was getting too much traction lately
04:49:32 <Jafet> Also note that there are much fewer than 666 people in here now
04:49:44 <Itkovian> yeah 634 :-)
04:50:05 <HugoDaniel> hi
04:50:28 <pastorn> hello
04:52:01 <benmachine> didn't we get up to 700 at some point
04:55:14 <boegel> so, we're succesful at avoiding succes? w00!
04:56:08 <Jafet> Nope!
04:58:20 <guenni68> hello
05:01:23 <guenni68> any news when haskell.org will be up again?
05:01:51 <Lemmih> guenni68: "soon".
05:02:04 <ivanm> preflex: seen tomberek
05:02:04 <preflex>  tomberek was last seen on #haskell 1 day, 1 hour, 41 minutes and 34 seconds ago, saying: copumpkin.. what about coq?
05:02:42 <guenni68> Lemmih: what caused it?
05:03:18 <aleator> To interface with C I need to pack four character strings to an int. Any ideas how to do this easily?
05:03:48 <Lemmih> guenni68: http://www.reddit.com/r/haskell/comments/cbkkb/wwwhaskellorg_wiki_mailing_list_server_has_been/
05:04:24 <guenni68> Lemmih: thx
05:05:41 <ivanm> @tell tomberek changes pushed; sorry for the one-big-meta-patch but the changes were all interconnected too much :s
05:05:41 <lambdabot> Consider it noted.
05:05:42 <dafis> aleator: fromEnum, shift and add simple enough?
05:06:31 <ivanm> @ask tomberek also, how about we move all the class definitions to Data.Graph.Inductive ?
05:06:31 <lambdabot> Consider it noted.
05:09:16 <Blkt> how do I exactly use ghci command :break [<mod>] <l> [<col>]?
05:09:25 <Blkt> what does [<mod>] stands for?
05:09:31 <Axman6> module
05:09:36 <Axman6> i'd guess
05:09:53 <Blkt> thanks
05:10:04 <Axman6> so, module, line, collumn
05:10:06 <Axman6> -l
05:12:21 <noteed> preflex: seen dcoutts
05:12:22 <preflex>  dcoutts was last seen on #haskell 9 hours, 41 minutes and 35 seconds ago, saying: aavogt: thing is, when people think of mirroring they start thinking about rsync, which doesn't help
05:12:40 <dmwit> Axman6: so, modue, line, collumn? ;-)
05:13:05 <Axman6> precisely
05:13:18 <dmwit> In order of increasing l-count, of course.
05:22:23 <jeltsch> Hi, are there any estimations about when haskell.org will be up again.
05:23:14 <Jafet> When something forces it
05:24:12 <digitteknohippie> can we force it?
05:24:13 <digitteknohippie> XD
05:24:26 <dmwit> haskell.org `seq` ()
05:24:36 <dmwit> or... hm
05:24:38 <dmwit> it `seq` ()
05:24:45 <digitteknohippie> lol
05:26:04 <Lemmih> dmwit: 'haskell . org' must have the type 'Request -> Response'. Simply using 'seq' isn't gonna cut it.
05:26:23 <dmwit> ack
05:27:23 <Jafet> Sin.
05:27:56 <hpc> what about Haskell.org? that's a package qualifier, and domain names are case-insensitive
05:30:24 <tilarids> Hi to all. Is it really possible to construct a data type when it is defined as a struct with fields(all of them have the same type), and I want to construct it from the list of the arguments?
05:31:27 <hpc> not with a constructor, but you could make a function that calls the constructor
05:33:49 <dcoutts> noteed: hmm?
05:35:11 <_Matt_J_W_> testing testing, anyone reading me?
05:35:36 <bremner> _Matt_J_W_: no
05:35:39 <tilarids> hpc: hmm. as I understand, constructor is nothing more than a function?
05:35:42 <guenni68> _Matt_J_W_: I do
05:35:53 <_Matt_J_W_> thank you
05:36:04 <_Matt_J_W_> I'm getting a funny message in haskell-in-depth though
05:36:05 <guenni68> _Matt_J_W_: np
05:36:08 <hpc> tilarids: a constructor is what makes the data type
05:36:26 <hpc> tilarids: any function a -> Type has to at some point call a constructor for Type
05:36:58 <noteed> dcoutts: Hi, are you available for a chat?
05:37:05 <_Matt_J_W_> any message I submit is followed by "cannot send to channel" or something similar
05:37:29 <dcoutts> noteed: I've got a few minutes
05:39:02 <hpc> tilarids: someone else can probably explain it better than i can
05:40:02 <Schalken> Is there any reason doesDirectoryExist would return true in the case of a socket?
05:40:08 <Schalken> True*
05:40:48 <hpc> because it exists :P
05:41:42 <_Matt_J_W_> Once mroe for luck
05:41:54 <Schalken> hpc: But its not a directory. It's a socket.
05:42:06 <_Matt_J_W_> sorry guys, but does anyone know what's wrong with haskell in depth?
05:42:12 <hpc> same thing if you think about it
05:42:17 <hpc> you can pull files out of both
05:43:15 <Schalken> hpc: It doesn't seem so: "/home/jesse/.config/google-chrome/SingletonSocket: getDirectoryContents: inappropriate type (Not a directory)"
05:43:39 <hpc> heh, i don't know then
05:50:24 <temp> is there a better way to do something like > changetoNewIfOldIsNothing old maybeNew = if isJust maybeNew then fromJust maybeNew else old
05:50:45 <hpc> :t maybe
05:50:46 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:51:17 <hpc> maybe old id maybeNew
05:51:34 <hpc> :t fromMaybe
05:51:35 <lambdabot> forall a. a -> Maybe a -> a
05:51:47 <hpc> or fromMaybe old maybeNew
05:52:37 <_Matt_J_W_> turns out haskell in depth is moderated and only the ops get to talk publically
05:54:28 <ivanm> _Matt_J_W_: your nick has to be registered
05:54:34 <ivanm> once your nick is registered you can talk there
05:55:00 <hpc>  /msg nickserv help if you don't know how
05:58:21 <_Matt_J_W_> Thanks guys
05:58:45 <_Matt_J_W_> that command rings vaguely familiar 
05:58:59 <_Matt_J_W_> is it followed by username and passwd?
05:59:01 <ivanm> _Matt_J_W_: note that there are nicer way of coming out and asking what to do than instantly claim that theere's cencorship
05:59:09 <ivanm> e.g. actually ask why you can't talk ;-)
05:59:27 <ivanm> _Matt_J_W_: if you've already registered, then it's /msg nickserv identify <password>
05:59:33 <_Matt_J_W_> Ivan 
05:59:35 <ivanm> (without the <...>)
05:59:36 <_Matt_J_W_> mate
05:59:39 <_Matt_J_W_> don't push it
05:59:44 <ivanm> don't push what?
05:59:50 <_Matt_J_W_> thank you for your help
05:59:50 <hpc> the button
05:59:54 <hpc> > unsafeLaunchMissiles
05:59:55 <lambdabot>   Not in scope: `unsafeLaunchMissiles'
05:59:56 <_Matt_J_W_> but I didn't come here to be lectured
06:00:35 <ivanm> who's lecturing?
06:00:52 <ivanm> hpc: as in the one in the hitchhiker's guide to the galaxy radio play? :p
06:00:58 <_Matt_J_W_> You are my friend. As I said, thanks for your help and good day
06:01:04 * ivanm doesn't have his copy of the scripts with him atm unfortunately :s
06:02:33 <kmc> i came here to be lectured
06:02:55 <ivanm> kmc: then ask dibblego for one :p
06:02:58 <ivanm> (no offence dibblego)
06:02:59 <kmc> ;P
06:03:45 <lpsmith> ddarius, you around?
06:03:59 <ivanm> preflex: seen ddarius 
06:04:00 <preflex>  ddarius was last seen on #haskell 5 hours, 44 minutes and 35 seconds ago, saying: \/ X = Y = 1 or 2
06:04:19 <ddarius> Just now.
06:06:06 <J-roen> :r
06:06:12 <J-roen> Sorry :D
06:06:43 <lpsmith> ddarius, Out of curiousity,  do you understand Free Theorems?   I mean,  I have a pretty good intuitive grasp on parametericity,  but I don't quite get the theoretical foundations.
06:07:23 <Lemmih> What an odd guy, that Matt.
06:07:33 <ivanm> Lemmih: agreed
06:07:46 <ivanm> and I always find it weird when some random person calls me their friend... :s
06:07:57 <aavogt> me too, friend
06:07:59 <ddarius> The theoretical foundation is a concept called logical relations.  However, parametricity is closely related to naturality in category theory, and parametricity in general is related to a more general concept called dinaturality.
06:08:32 <ivanm> aavogt: you only half disturb me as I've conversed with you for a while here
06:08:34 <ivanm> sorry :p
06:09:01 * ivanm goes off to fall unconsious and have hallucinations for 8 hours or so
06:09:02 <lpsmith> well,  but the first part of Wadler's "Theorems for Free!"  uses logical relations,  but mentions that there isn't a naive set-theoretic model of types
06:09:22 <lpsmith> :t callCC
06:09:23 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
06:09:34 <lpsmith> err
06:10:14 <lpsmith> ddarius, what's the free theorem for callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a?
06:11:18 <ddarius> @free ((a -> (r -> b) -> b) -> (r -> a) -> a) -> (r -> a) -> a
06:11:18 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
06:11:34 <ddarius> @free callCC :: ((a -> (r -> b) -> b) -> (r -> a) -> a) -> (r -> a) -> a
06:11:35 <lambdabot> (forall q f1. (forall x f2 f3. h . f2 = f3 . g                               =>                                h (q x f2) = f1 (f x) f3)              =>               (forall f4 f5. f . f4 = f5 . g
06:11:35 <lambdabot>                            =>                              f (k q f4) = p f1 f5)) => f . f6 = f7 . g => f (callCC k f6) = callCC p f7
06:14:53 <ddarius> The most general free theorem for a type is not something that will necessarily just pop out at you, though you can intuitively use it without really knowing what it is.
06:17:09 <hpc> since haskell.org is down and google/wikipedia are not being helpful, what is a free theorem?
06:17:22 <ddarius> @google "Theorems for Free"
06:17:23 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9875
06:18:12 <kmc> theorems for free, lemmas $5
06:18:27 <kmc> (that's how they get you)
06:18:28 <ddarius> The shortest answer is it is a theorem about a function that you get just from looking at its type.
06:18:57 <hpc> neat; how would you go about finding them?
06:19:08 <Phyx-> hmm I know haskell.org (and the mailing list) are down, but the mail I just send didn't bounce, lol. Are all mails going into a dark void?
06:19:30 <hpc> Phyx-: it is probably sitting on some mail relay somewhere
06:20:09 <Phyx-> hpc: most likely, since I haven't received anything from cafe since last week
06:20:10 <Phyx-> lol
06:21:32 <djahandarie> ezyang, that databases are categories stuff is pretty cool
06:22:20 <o-_-o> float min = width < height ? width : height
06:22:25 <o-_-o> how do I do this ?
06:23:18 <ddarius> o-_-o: Use if then else.
06:23:23 <ddarius> @free x :: a
06:23:23 <lambdabot> f x = x
06:23:40 <o-_-o> I did but it says parse error
06:23:43 <djahandarie> Or just use the min that is already defined for you :-)
06:23:54 <hpc> @free g :: a -> b
06:23:54 <lambdabot> h . g = g . f
06:23:55 <o-_-o> ah
06:24:04 <o-_-o> :t min
06:24:05 <lambdabot> forall a. (Ord a) => a -> a -> a
06:31:22 <ziman> @free f :: a -> f (a -> b) -> f b
06:31:23 <lambdabot> Extra stuff at end of line
06:32:05 <o-_-o> I have some functions in  a file b.hs
06:32:10 <o-_-o> my main is in a.hs
06:32:21 <o-_-o> how do I include b.hs and compile it ?
06:32:32 <ddarius> @free x :: Int
06:32:32 <lambdabot> x = x
06:33:15 <ziman> @free f :: (a -> b -> c) -> (a -> b) -> (a -> c)
06:33:15 <lambdabot> (forall x. k . p x = q (g x) . h) => h . f1 = f2 . g => k . f p f1 = f q f2 . g
06:33:34 <ville> o-_-o: perhaps look into using cabal to manage your build
06:34:31 <kmc> o-_-o, rename b.hs to B.hs and put the line "module B where" at the top
06:34:37 <kmc> then in a.hs you can say "import B"
06:34:44 <kmc> and "ghc --make a.hs" will automatically find and build B.hs
06:34:47 <o-_-o> kmc, ah...thanks
06:35:02 <o-_-o> mv vector.hs Vector.hs
06:35:06 <o-_-o> oops worng window
06:35:42 * ville grumbles something about files beginning with capital letter
06:38:06 <aristid> ville: good filenames are all-lowercase.
06:38:35 <kmc> blame the Haskell module system
06:38:37 <portnov> @hoogle vector
06:38:37 <lambdabot> Test.QuickCheck vector :: Arbitrary a => Int -> Gen [a]
06:39:20 <ville> aristid: yes all_lowercase, but I blame society for Haskell's module system inflicting the scourge of capital letters in file names
06:40:32 <kmc> let's all agree to blame Java
06:40:34 <aristid> ville: i think hyphens inside filenames are fine, too.
06:40:52 <aristid> kmc: yes, that's a good target.
06:42:35 <fryguybob> Windows doesn't let you have a.hs and A.hs so ghc --make doesn't care about caps, but cabal init does.  Probably a bug in cabal init...
06:43:23 <o-_-o> how do I convert from one type to another
06:43:46 <o-_-o> Glsizei is being returned by the function, but I want it to be Double
06:43:59 <o-_-o> GLsizei
06:44:20 <kmc> "how do I convert A to B" is just a way of asking "tell me some function of type A -> B"
06:44:37 <kmc> Haskell doesn't have privileged special type-conversion functions
06:44:39 <kmc> :t fromIntegral
06:44:40 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:44:44 <kmc> ^^^ should do it
06:44:46 <o-_-o> ah...
06:45:19 <o-_-o> damnit I knew this
06:45:32 <o-_-o> I stop programming for 21 days and I forget everything
06:45:33 <kmc> but (e.g.) there are at least 5 reasonable ways to convert Double to Int, C picks one arbitrarily as "the conversion", Haskell provides them as functions
06:45:41 <o-_-o> kmc, ok
06:46:57 <kmc> o-_-o, that reminds me of the "learn programming in 21 days" books
06:47:02 <kmc> "forget programming in 21 days"
06:51:41 <T_S_> @free g:: [a->b] -> a -> [b]
06:51:41 <lambdabot> (forall k. (forall p q. h . p = q . f                        =>                         k p = q)           =>            $map k xs = ys) => $map h . g xs = g ys . f
06:52:07 <o-_-o> kmc, heh...:-)
06:52:17 <zygoloid> kmc: on the other hand, there's only one reasonable natural way to convert Int to Double, and Haskell requires us to explicitly state it.
06:53:12 <T_S_> @free g:: [ a -> b] -> [a] -> [b]
06:53:12 <lambdabot> (forall k. (forall p q. h . p = q . f                        =>                         k p = q)           =>            $map k xs = ys) => $map h . g xs = g ys . $map f
06:56:00 <kmc> yeah
06:56:22 <o-_-o> so these haskell bank jobs
06:56:30 <o-_-o> where are they advertised ?
06:56:30 <kmc> it's not a universally better approach
06:56:40 <o-_-o> how do people get hired to them ?
06:56:44 <kmc> it's the simpler / more orthogonal approach
06:56:56 <kmc> o-_-o, there was an ad on haskell@ recently
06:57:19 <kmc> or on reddit
06:57:22 <o-_-o> kmc, yes I saw that, and I heard don say that there are japanese banks which are hiring too
06:57:27 <Lemmih> o-_-o: Some are on linked-in. And you get them by applying for them.
06:57:35 <kmc> there is tsuru capital
06:57:37 <kmc> (not a bank)
06:57:38 <zygoloid> fwiw, i'd take inferrable types over implicit conversions any day...
06:57:38 <o-_-o> Lemmih, hmmm
06:58:05 <zygoloid> o-_-o: you might want to talk to standard chartered
06:58:14 <kmc> personally i am suspicious of jobs that say "we're using Haskell! but you must also know Java, C#, and Excel VBA"
06:58:31 <zygoloid> preflex: seen ndm
06:58:31 <preflex>  ndm was last seen on #haskell 1 year, 29 days, 3 hours, 39 minutes and 51 seconds ago, saying: plus with current compiler technology, it would be slower
06:58:42 <zygoloid> preflex: seen augustss
06:58:42 <preflex>  augustss was last seen on #haskell 104 days, 13 hours, 39 minutes and 59 seconds ago, saying: rawr: exactly what it says
06:58:55 <o-_-o> zygoloid, hmm...my haskell skills are next to nothing
06:59:15 <o-_-o> zygoloid, if I applied it would be a insult to good haskell community :-)
06:59:22 <o-_-o> s/a/an
06:59:45 <o-_-o> I was just curious, maybe in a sometime, but not now
06:59:54 <kmc> there are exceedingly few haskell jobs
07:00:05 <kmc> though the trend is upward
07:00:09 <o-_-o> and anyway I am in India, so I doubt anyone would hire me
07:00:11 <o-_-o> kmc, yes
07:00:17 <o-_-o> that is nice
07:00:38 <kmc> there will also be many more F# jobs over time
07:00:47 <o-_-o> I don't know F#
07:01:03 <o-_-o> or OcaML
07:01:05 <kmc> i don't think language is always the most important factor
07:01:18 <kmc> but i do think using Haskell correlates with other desirable properties
07:01:30 <kmc> that may be unrelated to the language itself
07:01:53 <kmc> i'm not sure whether F# correlates in the same  way
07:02:21 <kmc> ocaml is kinda neat but it seems to be stuck in neutral
07:02:37 <o-_-o> haha...neutral ?
07:02:38 <kmc> there's not a big push to industrialize it, as with Haskell and F#
07:03:02 <aristid> kmc: there's one user of ocaml with heavy advertising on google.
07:03:07 <kmc> jane st. capital
07:04:17 <kmc> i expect a lot of prospective ocaml users will end up using F# instead
07:04:43 <aristid> or even haskell
07:04:55 <kmc> yes
07:04:56 <aristid> but once you have an ocaml codebase, staying with it doesn't seem that stupid
07:05:12 <kmc> there is this notion that OCaml is a compromise position between Haskell and traditional imperative languages
07:05:34 <kmc> and the idea of compromise could be attractive or undesirable depending on strategy and personal attitudes
07:05:39 * Itkovian is still looking for high-quality haskell benchmarks with different input sets.
07:05:43 <aristid> kmc: aren't scala and f# ugly compromises too?
07:05:45 * o-_-o wonders why he chose haskell instead of OcaML
07:05:51 <Itkovian> I mean, longer running that nofib.
07:05:55 <kmc> i'm not sure the notion is valid, btw
07:05:59 <aristid> o-_-o: because it's pure, man :D
07:06:11 <Itkovian> OMG, has the troll hit here too? :-)
07:06:14 <o-_-o> I had some really good reasons back then, ah correct OcaML is not good at multi-core
07:06:16 <mreh> question: does the FFI statically link in code?
07:06:40 <o-_-o> atleast it was not top-priority when I started looking at haskell
07:06:42 <kmc> again, I think we should market Haskell as the pragmatic alternative to Haskell
07:06:51 <kmc> o-_-o, what are your goals in learning Haskell or OCaml?
07:07:10 <o-_-o> kmc, currently it is just to have some fun
07:07:31 <kmc> then you made the right choice ;)
07:07:38 <o-_-o> kmc, and learn some neat things, it seems haskell has opened up places in my brain that I didn't even know existed
07:07:45 <benmachine> #haskell thinks you were right to choose haskell
07:07:51 <kmc> yeah, surprise
07:07:52 <o-_-o> which is kind neat
07:08:20 <o-_-o> I come from C and C++ and shell scripting (mainly systems programmer), so this was a big leap
07:08:42 <kmc> but if your goals were "write soft realtime apps" or "interface with .NET libraries", then i'd admit to it being the wrong choice ;)
07:08:45 <EvanR-work> shell scripting is often functional in nature
07:09:12 <mreh> Manuel M. T. Chakravarty <- that truly is a fantastic name
07:09:27 <o-_-o> kmc, I am on linux, I don't .NET makes sense to me
07:09:34 <kmc> yeah
07:09:35 <o-_-o> s/don't/don't think
07:09:40 <kmc> i wish there were a good .NET implementation on Linux
07:09:40 <EvanR-work> mono
07:09:45 <kmc> mono is slow
07:10:02 <EvanR-work> who cares
07:10:08 <kmc> me
07:10:13 <o-_-o> heh
07:10:23 <benmachine> kmc: what's good for writing soft realtime?
07:10:23 <kmc> C# is a better language than Java, and CLR is a better VM than JVM
07:10:29 <EvanR-work> for failing technology we just need emergency backward compatability, not state of the art implementation
07:10:35 <o-_-o> C ?
07:10:39 <kmc> benmachine, depends.  i was contrasting with OCaml, since Jane St. came up
07:10:45 <kmc> but they do a lot of work to make OCaml work for them
07:10:46 <benmachine> (not that it sounds like something I'd ever want to do, mind >_>)
07:10:53 <benmachine> ah, okay
07:11:00 <kmc> Haskell may be edging in on soft realtime
07:11:06 <kmc> and we have DSLs for hard realtime (Atom)
07:11:38 <kmc> .NET is failing technology?
07:11:54 <EvanR-work> its not interesting except that microsoft put its name on it
07:12:02 <kmc> it's not interesting, true
07:12:05 <kmc> it's a better Java
07:12:12 <EvanR-work> 'java done right'
07:12:16 <kmc> which is something the world needs
07:12:27 <kmc> even if you or I don't particularly care to use it
07:13:03 <kmc> in particular it's a widely-used VM that supports many languages easily, more easily than JVM does
07:14:56 <EvanR-work> the thing with these vm's is that they arent solving anything
07:15:13 <EvanR-work> the fact that theres no good implementation on not windows exemplifies this
07:15:23 <EvanR-work> whats the point of a vm if its platform specific
07:15:37 <kmc> nice circular argument ;)
07:15:51 <EvanR-work> you might as well implement a separate c# compiler with multiple backends
07:16:11 <EvanR-work> or a gcc
07:16:13 <Ke> jit is needed on x86 if you want to take advantage of all the instruction sets and still run on most systems
07:16:15 <kmc> =z
07:16:21 <fryguybob> EvanR-work: Not exactly.
07:17:10 <Ke> (without having multiple compiled versions)
07:17:31 <T_S_> finally started using ghci inside emacs. any tips for getting autocompletion turned on?
07:19:04 <EvanR-work> if you wish for CLR to be ported to other systems in a nice way, you might as well wish for some better technology to do also become wide spread
07:19:51 <EvanR-work> so were back to the microsoft having their name on it bonus
07:19:55 <kmc> no
07:20:06 <kmc> i would also wish for a better technology
07:20:18 <kmc> but there's tremendous existing investment in CLR
07:20:28 <kmc> like it or not that is a substantial factor
07:20:34 <kmc> it's not just marketing
07:21:02 <EvanR-work> the existing investment that matters is mono?
07:21:06 <kmc> no
07:21:10 <o-_-o> ok I am going home now...nice talking to all of you and good night
07:21:14 <kmc> night o-_-o 
07:21:28 <EvanR-work> proprietary software isnt an investment
07:21:31 <Schalken> How can I foldM on an instance of Data.Class.List?
07:22:03 <Ke> mono is hanging by a thread since Novell is dying
07:22:12 <Ke> sadly
07:22:28 <benmachine> Schalken: I've not heard of Data.Class.List, what package is it from?
07:22:47 <Ke> haskell.org pleeeaaase
07:23:01 <kmc> EvanR-work, many people know C# and CLR.  there are many million-LoC codebases using them.  there are lots of tools, Free and otherwise
07:23:09 <Ke> did chalmers oslt have a mirror of that?
07:23:10 <kmc> none of that is true of your mythical not-yet-invented better VM
07:23:19 <kmc> hackage is still up and has most docs iirc
07:23:20 <Schalken> benmachine: http://hackage.haskell.org/package/List
07:23:45 <Ke> kmc: I want haskellwiki
07:24:00 <Ke> or other xmonad gnome docs
07:24:01 <benmachine> (Data.List.Class, then)
07:24:04 <EvanR-work> kmc: in what way do those rely on CLR
07:24:13 <EvanR-work> the programs in c#
07:24:33 <kmc> sure you can rebuild the whole infrastructure around a different VM
07:24:48 <Ke> kmc: mono is doing just that
07:24:48 <kmc> i'm not sure why you'd want to
07:24:52 <Schalken> benmachine: Right, my bad.
07:24:54 <kmc> Ke, is it?
07:24:58 <EvanR-work> you have to do something similar to have a not windows runtime anyway
07:24:59 <kmc> i thought it implemented the same VM
07:25:08 <Ke> kmc: because CLR is nonfree and windows only
07:25:30 <kmc> okay
07:25:32 <kmc> maybe i mean CLI
07:25:35 <kmc> i think that's what i mean
07:25:53 <kmc> there is a common VM spec, bytecode language, etc.
07:26:01 <Ke> well VM means always implementation afaik
07:26:01 <kmc> which is implemented by MS and by mono
07:26:16 <kmc> i don't agree
07:26:21 <kmc> every language defines a virtual machine
07:26:23 <Ke> kmc: mono is not bytecode compatible
07:26:27 <kmc> :(
07:26:29 <benmachine> Schalken: what exactly do you mean, do you have examples of stuff you've already tried, etc.
07:27:08 <EvanR-work> also mono does not have the windows support libs
07:27:25 <EvanR-work> what would they do, use wine?
07:27:45 <kmc> so Windows-specific code written in C# will not work
07:27:54 <kmc> the same is true of Java, Haskell, and C of course
07:28:05 <EvanR-work> isnt that the majority of c# code
07:28:08 <kmc> i have no idea
07:28:38 <Ke> you can always just recompile
07:28:49 <Schalken> benmachine: Well, I have a `ListT IO ByteString`, which implements a list of `ByteString`s, and I want to loop over those ByteStrings and perform some IO. With a normal list I would do that with a foldM, but because this is a special list I don't have that function.
07:28:52 <fryguybob> mono is binary compatible.
07:29:10 <Ke> hmm
07:29:13 <EvanR-work> its like closed source windows programs, an emergency implementation should be sought so that we can run the program at some point in the distance future. but its not a living system anymore, its frozen without source/freedom
07:29:30 <edwardk_> @type runListT
07:29:31 <lambdabot> Not in scope: `runListT'
07:29:58 <portnov> @hoogle ListT
07:29:58 <lambdabot> Control.Monad.List newtype ListT m a
07:29:58 <lambdabot> Control.Monad.List ListT :: m [a] -> ListT m a
07:29:58 <lambdabot> Language.Haskell.TH ListT :: Type
07:30:09 <edwardk_> newtype ListT m a = ListT { runListT :: m [a] } -- runListT will get an IO [a]  out of  your ListT IO a
07:30:39 <edwardk_> though in general ListT IO isn't idea. since ListT isn't a "real" monad transformer
07:30:43 <edwardk_> er ideal
07:30:53 <Ke> fryguybob: interesting, I remember reading otherwise, but no binary compatibility is mentioned on the frontpage
07:30:53 <edwardk_> better but much harder to use is mlist
07:30:54 <benmachine> edwardk_: we're talking about a "real" ListT
07:31:06 <benmachine> i.e. not the one from mtl
07:31:10 <edwardk_> benmachine: yay! ok. i'll relax then =)
07:31:11 <Ke> *but now
07:31:23 <EvanR-work> Ke: i thought that it will run binaries, of course you need the dependency libs
07:31:28 <edwardk_> http://hackage.haskell.org/package/mlist is the one i was thinking of. which one is this?
07:31:36 <nff> Ke, I've made mono apps a few years ago, and they worked out the box on windows like on linux
07:31:43 <benmachine> http://hackage.haskell.org/package/List
07:31:43 <fryguybob> Ke: There are areas that are not covered API wise, and there are some extensions and explorations in mono that don't run on CLR such as sse IIRC.
07:32:20 <Schalken> edwardk_: The ListT IO ByteString is implementing IO read from a file, if I runListT on it, the entire file will be read into memory, which is bad because it is potentially many GB.
07:32:49 <EvanR-work> i smell iteratees approaching
07:32:59 <edwardk_> Schalken: you're using the mlist or List package based ListT then? and not the MTL version?
07:33:13 <kmc> EvanR-work, smells like victory
07:33:27 <Schalken> EvanR-work: I tried to use the Iteratee package but I couldn't get it to work in constant space.
07:33:35 <edwardk_> Schalken: the buzz has already given away part of the answer, iteratees are usually the way to go
07:33:48 <Ke> nff: and you compiled them to bytecode and run on system with .NET and no mono?
07:33:56 <edwardk_> Schalken: that is usually a sign that you're holding onto parts of the input bytestring
07:33:56 <benmachine> Schalken: there are some functions in Data.List.Class that seem designed for folding over Lists
07:34:28 <nff> Ke, I compiled them using mono, and ran them on windows, as the .exe files that they are.
07:34:54 <gerryxiao> hello
07:35:10 <Ke> nff: mono can compile to native code, the bytecode part is interesting part here
07:35:19 <gerryxiao> is ST monad State monad?
07:35:27 <nff> as I understand it, they're just CIL, which is JIT'd at runtime
07:35:29 <kmc> gerryxiao, no
07:35:38 <edwardk_> mono implements a bunch of random extensions to the CIL, that don't work in windows, but it also implements the stock CIL.
07:35:53 <kmc> gerryxiao, State is sugar for passing and returning states in the normal pure functional way
07:35:55 <Twey> gerryxiao: ST is a State Transformer monad  it's a restricted environment for imperative programming yielding a pure result
07:36:12 <Ke> nff: there is an option to create native executables
07:36:19 <Twey> gerryxiao: State just allows threading a value implicitly through a bunch of transformations
07:36:19 <kmc> gerryxiao, ST has "true" mutable reference cells, much like IORef, but uses some type trickery so you can get the end result as a pure value
07:36:57 <Schalken> edwardk_: I'm using the List package. I'm the asker of this question: http://stackoverflow.com/questions/2981582/haskell-lazy-i-o-and-closing-files A solution using the iteratee would not run in constant space, but the solution using the ListT does. In that particular question the function being foldeed over the list is md5UpdateContext :: a -> b -> b, but I now want to fold a function of type (a -> b -> IO b) instead.
07:37:01 * hackagebot suffixarray 0.0.1 - Suffix arrays  http://hackage.haskell.org/package/suffixarray-0.0.1 (DanielDeKok)
07:37:02 <gerryxiao> kmc: i can't find docs about ST monad
07:37:23 <jnj> I have imported IO, but am getting "Not in scope: data constructor `IO'" when doing func :: IO ()   -- am I missing an import or doing something else wrong?
07:37:30 <kmc> gerryxiao, http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Control-Monad-ST.html and http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Data-STRef.html
07:37:33 <benmachine> @hackage base
07:37:33 <lambdabot> http://hackage.haskell.org/package/base
07:37:40 <kmc> jnj, doing something else wrong, can you upload full code to hpaste.org?
07:38:01 <jnj> kmc: I'll try and strip it down, will post result in a bit, thanks.
07:38:02 <kmc> jnj, you're trying to use IO as a data constructor, not a type constructor
07:38:10 <edwardk_> woot. suffixarrays. i wonder if he implements karkainan and saunders
07:38:11 <Schalken> edwardk_: The iteratee that should run in constant space but doesn't is here: http://stackoverflow.com/questions/2981582/haskell-lazy-i-o-and-closing-files/2983328#2983328
07:38:12 <kmc> i.e. you're trying to use it in a position analogous to Just, rather than analogous to Maybe
07:38:31 <jnj> ah.. return () then
07:38:33 <jnj> thanks
07:38:39 <kmc> jnj, IO is an "abstract type" meaning you don't get to see its data constructor, you can only build IO actions using functions provided for you
07:38:39 <gerryxiao> kmc: thx
07:38:40 <kmc> like return yes
07:38:45 <kmc> :)
07:39:00 <edwardk_> sadly, no
07:39:05 <edwardk_> =(
07:39:21 <kmc> in GHC Haskell you can actually import the IO data constructor, but the details of what's inside are implementation-dependent and generally gruesome
07:39:24 <edwardk_> its just a naive self-sort
07:45:03 <benmachine> Schalken: do you mind if I make wild guesses on the basis of little evidence or expertise? :P
07:45:17 <Schalken> benmachine: better than nothing
07:45:41 <T55555> hello, newbis question about Monad, >> and >>= to composite (bind) 2 monads, but is it possible to composite 2 "different" type of Monad, does it make sense ?  for example:  (m1 a) >> (m2 b)  or  ( m1 a) -> ( a -> m2 b) -> m2 b; like combine 2 different monda... ex. combine IO Monad and State Monad ... thx.
07:45:53 <kmc> T55555, not as such
07:45:53 <benmachine> I think I'd try Control.Monad.State.Strict
07:45:58 <kmc> T55555, look into "monad transformers"
07:46:00 <Twey> T55555: No, it doesn't make sense
07:46:03 <edwardk_> gah silly data.digest.pure.md5 taking lazy bytestrings
07:46:04 <kmc> @unmtl State s a
07:46:04 <lambdabot> s -> (a, s)
07:46:07 <kmc> @unmtl StateT s IO a
07:46:07 <lambdabot> s -> IO (a, s)
07:46:19 <benmachine> edwardk_: what should it take?
07:46:29 <Twey> T55555: But you can wrap one of the monads so that it can be embedded in the other, if both support it
07:46:32 <kmc> T55555, also (>>) doesn't compose "2 monads".  the thing called a "monad" is the type itself, i.e. IO or Maybe or (State s)
07:46:38 <Twey> T55555: That's what monad transformers are for
07:46:45 <kmc> (>>) sequences two values which belong to the same type, which must be a monad
07:46:46 <kmc> :t (>>)
07:46:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:47:24 <edwardk_> benmachine: well the update version seems ideal for taking a strict one. and it'd be fairly straightforward to build Data.Digest.Pure.MD5.Lazy out of a strict Data.Digest.Pure.MD5 
07:48:02 <benmachine> edwardk_: ah, yeah I guess so
07:48:02 <T55555> I will take a look about monad transformers.  thanks for the answers.
07:48:12 <benmachine> edwardk_: still, what's wrong with fromChunks . pure?
07:48:30 <edwardk_> benmachine: that you put that extra check on what could otherwise be your fast path
07:49:04 <benmachine> mm
07:49:26 <edwardk_> benmachine: (of course md5 has enough overhead that its largely irrelevant) but why make you allocate the list wrapper, and the new Chunk wrapper just to throw them away?
07:49:42 <benmachine> convenience?
07:50:02 <benmachine> but yes I agree with you :P
07:50:50 <edwardk_> i was going through looking for where the memory was going in that tiny iteratee version
07:52:02 <Schalken> edwardk_: Any findings?
07:52:19 <edwardk_> Schalken: i wonder about the guts of the Data.Digest.Pure.MD5 that should be tight
07:52:50 <Schalken> edwardk_: Because if I can do this with Iteratees instead of the hand build ListT IO ByteString it would be awesome.
07:53:05 <Schalken> edwardk_: Surely the same leak would appear in the ListT IO ByteString version?
07:53:26 <edwardk_> Schalken: does it?
07:53:36 <EvanR-work>  alias foo ListT IO ByteString ;)
07:53:49 <Schalken> edwardk_: No, it runs in constant space.
07:53:54 <edwardk_> hrmm
07:54:17 <bastl> hey, what should I use to deal with files and directories: typed System.Path or untyped System.FilePath ? Is package pathtype stable/maintained enough ?
07:55:53 <edwardk_> Schalken: then i'm tempted to want to check the iteratee file driver, etc. because the code there shouldn't hang on to anything. the iteratee is almost stateless
07:56:18 <gio123> g\
07:56:31 <Schalken> edwardk_: The docs said to use fileDriverFd, which I am using.
07:56:50 <edwardk_> hrmm is that strict or lazy stateT?
07:57:31 <edwardk_> can you try swapping the import to Control.Monad.State.Strict ?
07:58:00 <edwardk_> it may just be that you're lazily computing your md5. between that and a seq annotation or two you should be ok
07:58:19 <benmachine> the default StateT is lazy
07:58:24 <Schalken> edwardk_: Ahh, that I can't remember. This was a few hours ago I'll have to put the iteratee version back together so I can try it with a strict StateT.
07:58:48 <edwardk_> the version that was pasted on overflow was lazy
07:59:19 <Schalken> edwardk_: Ah, I beleive mine was also lazy, then.
07:59:43 <benmachine> also I hear it's a good idea to return $! stuff sometimes
07:59:46 <Schalken> edwardk_: Which is a shame because I was so proud of my ListT IO ByteString solution, if only I could fold a monad over it.
07:59:58 <benmachine> Schalken: hpaste it!
08:00:08 <edwardk_> you can ... as long as that monad is IO ;)
08:00:16 <edwardk_> or some variation on the theme
08:01:01 <Schalken> edwardk_: Wait, so can I fold a function (a -> b -> IO b) over a ListT IO ByteString??? That was my original question.
08:03:00 <T55555> hey, back to my combine 2 different type of monad. someone said it makes no sense... but, for example, you need read content of file ( IO Monad ) and show on windows GUI  ( any GUI Monad ), how can you combine theses 2 actions ( 2 Mondas) ?
08:03:29 <Zao> T55555: Normally such UI monads tend to be transformers around IO.
08:03:31 <edwardk> Schalken: http://hackage.haskell.org/packages/archive/mlist/0.0.2/doc/html/src/Data-MList.html has a mfold and basically identitical types
08:03:48 <edwardk> Schalken: i'm more familiar with that one than the ListT you imported but its basically the same thing
08:03:54 <Zao> Look for liftIO$ or io$ or similiar constructs.
08:04:10 <Zao> T55555: It's probably easier if you mention which one you're dealing with.
08:04:19 <Twey> T55555: Some GUIs are implemented in IO itself.  Others have runGUIMonad :: GuiMonad a -> IO a functions.
08:04:20 <EvanR-work> T55555: its a good idea to separate it, gui from file i/o
08:04:39 <EvanR-work> mixing them results in a spaghetti imperative program
08:05:04 <Twey> But most of them are indeed IO transformers, since otherwise you can't do IO inside GuiMonad (e.g. in response to UI events).
08:05:31 <T55555> ok. thanks guy. I am just thanking about there are many different type of Monad, and combine them ( interactive/dependency between each other ) may needed... that's why my question about combine different type of Monad. thx.
08:05:45 <benmachine> Schalken: foldrL :: List l => (a -> ItemM l b -> ItemM l b) -> ItemM l b -> l a -> ItemM l b
08:05:52 <benmachine> doesn't that do what you want?
08:05:57 <edwardk> T55555: sadly not all monads can be combined with all other monads
08:06:06 <T55555> oh
08:06:13 <benmachine> ItemM l in this case = IO
08:06:21 <zygoloid> T55555: in general you can't combine any two monads. lots of monads have 'transformer' versions which allow combining, but some (such as IO, STM, ST s and probably any GUI monad) must live at the 'bottom' of the monad stack.
08:06:28 <edwardk> T55555: but we have monad -transformers which build more complicated monads out of base monads
08:06:32 <edwardk> and you can interoperate with the simpler base monad
08:06:43 <edwardk> typically a monad like 'GUI' would be built out of those kinds of transformers
08:06:47 <zygoloid> T55555: in particular, if a monad's actions can't be "undone", then it must live at the bottom of a stack
08:06:50 <edwardk> so you'd have it being something like
08:07:03 <edwardk> type GUI = StateT InternalGUICruft IO
08:07:14 <edwardk> which gets hidden from you
08:07:18 <EvanR-work> ContT IO for the win
08:07:42 <edwardk> and if so, then most of the time you'll get an operation from Control.Monad.Trans for 'lift' or 'liftIO' to get at the monads one layer down.
08:07:47 <T55555> i see. thx.
08:08:42 <edwardk> it turns out that certain monads when you go to combine them by wrapping one in the other that the new construction violates the monad laws or fails to work at all because you can't 'distribute' one over the other.
08:09:27 <edwardk> a common example is the topic currently being rambled on about in the channel "ListT" .. i.e. if you have a monad m, then it would make sense at first glance that m [a] would be a monad.
08:10:03 <edwardk> but it turns out to violate a couple of associativity assumptions that are critical to the correctness of a monad.
08:10:24 <zygoloid> edwardk: isn't it just the case that the mtl implementation is broken?
08:10:33 <zygoloid> there's a monad-law-following ListT on the wiki
08:10:46 <edwardk> zygoloid: that waqs what i was getting to. you need to tweak it and the result isn't just a composition of the base monads
08:11:03 <edwardk> but there are others that you definitely don't want to mix: STM and IO for instance. 
08:11:30 <T55555> wow. thx.
08:11:31 <zygoloid> yeah. "/\a -> [IO a]" is most certainly /not/ a monad.
08:12:37 <edwardk> T55555: it turns out there are certain classes of monads that can work together, and ultimately it comes down to the existence of either a distributive law between those two monads (which is how the MTL transformers are all built -- yes modulo state for some smartass in the audience)
08:13:35 <Schalken> benmachine: mfoldr looks like it does exactly what I need, but its from a different package without the methods I'm currently using from List. foldrL looks like it /might/ do what I need but I'm confused as to what a ItemM /is/ exactly. :/
08:13:35 <zygoloid> there are edge cases: in principle we could have a transformer version of ST, but the implementation doesn't admit one.
08:13:50 <edwardk> or via some form of coproduct which works for a subset of monads (for which there are a scary class of monads called ideal monads, which can be combined with other ideal monads)
08:14:04 <benmachine> Schalken: ItemM is a type family in the List class
08:14:22 <quicksilver> edwardk: is a -> m [b] definitely an arrow, or does it fail by the same problem?
08:14:34 <benmachine> Schalken: i.e. what type ItemM is depends on what instance of List you are using
08:14:34 <edwardk> zygoloid: can we? STM retries in an STT s STM would be bad
08:15:11 <Schalken> benmachine: I am using the ListT interface.
08:15:18 <benmachine> right
08:15:19 <benmachine> and
08:15:26 <benmachine> to quote the source:
08:15:27 <benmachine> instance Monad m => List (ListT m) where type ItemM (ListT m) = m
08:15:37 <benmachine> (followed by the rest of the methods)
08:15:45 <benmachine> so ItemM (ListT IO) = IO
08:16:01 <benmachine> so foldrL :: List l => (a -> ItemM l b -> ItemM l b) -> ItemM l b -> l a -> ItemM l b
08:16:06 <benmachine> with l = ListT IO
08:16:21 <Schalken> benmachine: Oh, ItemM is always the monad underneath the ListT?
08:16:23 <benmachine> is (a -> IO b -> IO b) -> IO b -> ListT IO a -> IO b
08:16:37 <benmachine> Schalken: yes
08:16:47 <zygoloid> edwardk: why would that be bad? TVars can't be manipulated in ST
08:16:58 <benmachine> if you're actually using a ListT
08:16:59 <Schalken> benmachine: Aha! Now I can fold a function (a -> b -> IO b) over it!
08:17:13 <benmachine> Schalken: I think so
08:17:47 <djahandarie> Isn't the type (a -> IO b -> IO b)?
08:18:02 <benmachine> djahandarie: yeah, but that's good enough I think
08:18:03 <edwardk> retries would be able to rerun STT actions though
08:18:12 <zygoloid> edwardk: yes. and that would be fine, no?
08:18:52 <benmachine> @undo f g x y = do r <- y; g x r
08:18:52 <lambdabot> f g x y = y >>= \ r -> g x r
08:18:56 <zygoloid> the ST implementation would have to ensure that the old state was seen, not the new state
08:18:58 <Schalken> djahandarie: Yeah, but I can pull the value out of the IO monad in the second argument and pass it to my function :: (a -> b -> IO b) with a bind.
08:19:20 <benmachine> :t \g x y -> y >>= g x
08:19:21 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> a -> m b) -> t -> m a -> m b
08:19:52 <edwardk> do x <- newSTRef 1; STM stuff here; z <- readSTRef x; y <- writeSTRef x 2; backtracking STM stuff here; could see 2 in z
08:20:02 <Schalken> benmachine: I happen to be copying a file, and I'm already using foldlL, if I switch to foldrL, wont that make the file end up backwards (because its folding in the other direction)?
08:20:05 <zygoloid> edwardk: no, it couldn't. that'd be a broken STT.
08:20:21 <edwardk> zygoloid: at that point it is no longer ST because you just made your STT have to implement the full semantics of STM!
08:20:29 <benmachine> Schalken: it depends, but not necessarily
08:20:38 <zygoloid> edwardk: imagine STT implemented as State (Map STRefKey Any)
08:20:59 <zygoloid> s/State/StateT/ but i hope you get the idea
08:21:06 <edwardk> sure, but you just lost the power of ST's ability to model imperative calculation behind the facade.
08:21:22 <Schalken> benmachine: What does it depend on?
08:21:25 <edwardk> i've written that very ST variant, but its logarithmically slower than a real ST.
08:21:29 <zygoloid> you only lose an implementation detail of ST. as i said, the current ST implementation doesn't admit such a transformer, but the semantics of it does
08:21:45 <benmachine> Schalken: what function you're using in the fold, I guess
08:21:52 <benmachine> where your lists are coming from and going to
08:22:26 <edwardk> ok then we're in violent agreement and only bickering about terminology ;) i'd hesitate to call such a beast ST ;)
08:22:30 <kmc> haha
08:22:34 <kmc> good job everyone
08:22:54 <Schalken> benmachine: Well the function just takes the given chunk of data and writes it to another file. If I fold in the other direction, I would imagine it would write the last chunk first, reversing the file.
08:23:05 <zygoloid> \o/
08:23:42 <kamatsu> hey
08:23:53 <benmachine> Schalken: hmm. is it cheap to just try it and see? :P
08:23:56 <kamatsu> you know that "Right Tool" programming language ranking thing that went around reddit?
08:24:03 <kmc> yes
08:24:06 <kamatsu> Haskell came out pretty well one some of the questions
08:24:10 <kmc> link?
08:24:18 <kamatsu> http://therighttool.hammerprinciple.com/
08:24:31 <kamatsu> "Learning this language improved my ability as a programmer"
08:24:46 <kamatsu> "I would recommend most programmers learn this language regardless of if they have a specific need for it"
08:24:55 <kamatsu> "Learning this language significantly changed how i use other languages"
08:25:03 <kamatsu> "This language has unusual features that i often miss"
08:25:11 <kamatsu> "This language has a very coherent design"
08:25:18 <kmc> Haskell ranks highly in all the properties which I am sure were added with the thought that Haskell would rank highly on them
08:25:24 <kamatsu> "This language is built on a small core of orthogonal features"
08:25:40 <kamatsu> hm
08:25:57 <kmc> not many people would use Coq for casual scripting :/
08:26:01 <edwardk> kamatsu: heh i just started. i also find it sad that there were only 6 boxes or so on the first screen i wasn't comfortable checking
08:26:12 <quicksilver> edwardk: you didn't answer my question :-(
08:26:18 <Schalken> benmachine: I dont really want to write the code and find out I just copied a file backwards and the List interface has no way of copying it the right way, but if its the only way I can find out I guess I have to...
08:26:30 <kmc> edwardk, have fun ranking all those languages on every question...
08:26:37 <kamatsu> edwardk: i had the same problem.
08:26:40 <edwardk> quicksilver: that would be because i didn't see it ;)
08:26:45 <kmc> Haskell: Most dissimilar from: PHP, C++, C, Visual Basic, Java
08:26:58 <kamatsu> http://therighttool.hammerprinciple.com/items/haskell
08:27:06 <kamatsu> looking at the rankings, we don't have good results for
08:27:09 <edwardk> quicksilver: you should have the same problem with associativity. the arrow is just the kleisli arrow and the associativity of binds is what is at issue
08:27:14 <kamatsu> There are many good commercial tools for this language
08:27:16 <benmachine> Schalken: it's not necessarily the only way, it's just sometimes the easiest way
08:27:30 <kamatsu> nor do we have nice results for "
08:27:31 <kamatsu> This language allows me to write programs where I know exactly what they are doing under the hood"
08:27:46 <quicksilver> edwardk: Yes, but the arrow laws don't require as much, it seems to me.
08:27:46 <andrewsw> isn't that sometimes the point?
08:27:48 <kamatsu> nor "This is a mainstream language"
08:27:52 <benmachine> Schalken: I'd expect that either you could do both tasks with the same sort of fold, or the types will force things to be done the right way
08:28:03 <edwardk> quicksilver: there is the associativity of arrow composition
08:28:05 <quicksilver> edwardk: the arrow laws only require applicative; which doesn't speak of associativity of bind
08:28:12 <kmc> "commercial tools" is ambiguous unfortunately
08:28:24 <kmc> "tools as commercial products" versus "tools suitable for commercial-grade work"
08:28:25 <Schalken> benmachine: Hmm, ok, code it is. *back in 10*
08:28:35 <kamatsu> kmc: exactly, i was just thinking that
08:28:42 <quicksilver> edwardk: a -> f b is an arrow if f is merely Applicative, I mean
08:29:09 <quicksilver> edwardk: and it's a category if f is merely Functor, IIRC
08:29:23 <quicksilver> (m [a] is certainly a Functor)
08:29:24 <edwardk> quicksilver: yes the static arrow but that relies on the associativity of the arrow composition obtained from the monoid of the strong lax monoidal functor you have as your applicative
08:29:30 <benmachine> oh, I never noticed that the Kleisli instance of Arrow doesn't even use bind
08:29:39 <kmc> Ada ranks highly for "If my code in this language successfully compiles, there is a good chance my code is correct."
08:29:45 <kmc> counterexample: http://www.youtube.com/watch?v=kYUrqdUyEpI
08:29:56 <earthy> ka*boom*
08:30:06 <earthy> (I presume)
08:30:07 <kamatsu> Ada is a fairly safe language though, but there's no defence against human stupidity
08:30:11 <kamatsu> ...except perhaps Agda.
08:30:28 <benmachine> heh
08:30:41 <earthy> ah, right, indeed, ariane 5
08:30:47 <earthy> the code was pretty correct
08:30:59 <earthy> however, it was not applicable for the use case.
08:31:02 <earthy> so it was not ada
08:31:02 <kmc> the code was a correct control program for ariane 4
08:31:34 <quicksilver> edwardk: I believe you but I'm surprised. I'll have to think it through when I have some spare brain cycles.
08:31:50 <djahandarie> How do you guys decide if you "know a language" or not? There is obivously knowing the paradigm which is required, then maybe certain  language specifics, but beyond that it's just learning the libraries and becoming at solving problems with the language...
08:31:51 <quicksilver> edwardk: Functor alone gets you "Category + arr" which is a kind of weak notion of Arrow
08:31:56 <edwardk> quicksilver: the associativity of arrow composition is key. arrows form a category.
08:32:09 <djahandarie> becoming fast*
08:32:12 <edwardk> categories have just two things going for them. identity arrows, and associativity of composition
08:32:26 <quicksilver> you get that just from Functor though.
08:32:41 <quicksilver> you can define >>> for (a -> f b) where f is Functor
08:32:44 <kmc> djahandarie, for what purpose? i'll list a language on my rsum iff i know enough that i know i could learn what i'll need for a reasonable project within the project timeframe
08:32:47 <quicksilver> and it's associative.
08:32:51 <benmachine> djahandarie: yeah there are about five languages that I can read but have never done any serious development in
08:33:01 <benmachine> ok five is an exaggeration
08:33:04 <edwardk> no, you don't. functor gives you the fmap f . fmap g = fmap (f. g) law. it says that your maps are associative .... because the . in the underlying category is associative
08:33:08 <kmc> but "expert" is a much higher bar
08:33:22 <edwardk> it says nothing about how the . or >>> <<< for your particular Arrow instance associates!
08:33:26 <quicksilver> hmm. No, you still need join.
08:33:35 <kmc> a friend of mine defines "expert knowledge" as "ability to have constructive conversations with the language's designers"
08:33:35 * quicksilver is obviously misremember something.
08:33:47 <quicksilver> Ah!
08:33:56 <kmc> there's also the definition that being an expert in anything requires 10,000 hours of practice
08:34:05 <djahandarie> kmc, I would say there are a couple languages that I could satisfy "learn what i'll need for a reasonable project within the project timeframe" and I have never coded in them once
08:34:11 <kmc> right
08:34:26 <quicksilver> It's sufficient for Kleisli m a to be a Functor
08:34:31 <quicksilver> that's different from 'm' being a Functor.
08:34:33 <kmc> if you know Python well, you can probably list Ruby according to that rule
08:34:42 * quicksilver had his Functors in a tangle ;(
08:34:43 <edwardk> nope again. because you need to compose them
08:34:51 <kmc> not that you will produce the most beautiful idiomatic Ruby code
08:35:17 <Twey> http://therighttool.hammerprinciple.com/statements/i-often-feel-like-i-am-not-smart-enough-to-write-t  Clojure ranked significantly higher than Coq?  What?
08:35:37 <kmc> i'm more surprised it outranks Haskell
08:35:43 <edwardk> Kleisli m a is a functor for Kleisli (NaiveListT IO) -- even though Kleisli (NaiveListT IO) fails as an arrow
08:35:44 <kmc> Coq had few respondents generally
08:35:51 <benmachine> quicksilver: you can define Functor m => Functor (Kleisli m a)
08:35:55 <kmc> and if you know Coq well enough to check the box, you probably are smart enough to write it :)
08:36:11 <djahandarie> Yeah, the inital filtering was probably a bad move
08:36:12 <kmc> Clojure is much more something people would have looked into over an afternoon
08:36:27 <djahandarie> It should have been "have you touched this language before" or something more accepting
08:36:35 <qebab> wow
08:36:36 <edwardk> i can fmap a _pure_ computation over Kleisli m a easily, that doesn't say how kleisli composition associates
08:36:42 <kmc> Haskell has more respondents than Clojure, actually
08:36:45 <kmc> i'm surprised about that
08:36:48 <kmc> but it's older
08:36:51 <qebab> clojure beats haskell and prolog :o
08:37:03 <djahandarie> Otherwise it'll bias the results because the only people who decided to learn it well would be answering the questions
08:37:18 <benmachine> where's the "I often feel like this language is not smart enough for me" question
08:37:27 <kmc> http://therighttool.hammerprinciple.com/items/standard-ml/o-caml
08:37:39 <kmc> haha benmachine
08:37:46 <kmc> ranking #1: PHP
08:37:49 <edwardk> benmachine: +1
08:37:49 <kmc> training wheels without the bike
08:37:50 <Twey> Haha
08:38:08 <Twey> djahandarie: I think the point was to get opinions from people who actually know the language and use it regularly
08:38:19 <kmc> Scheme is less similar to Common Lisp than to Smalltalk, SML, and Clojure
08:38:23 <Twey> Newbies are probably going to say I feel I am not smart enough to program in this language to everything :
08:38:38 <kmc> nah Twey
08:38:55 <kmc> most people who can program won't be intimidated by Python
08:39:00 <benmachine> I think most people will think that about their first language
08:39:03 <kmc> they may not know it but they won't think they're too dumb for it
08:39:05 <Twey> kmc: They've never seen my Python ;)
08:39:08 <kmc> ;P
08:39:13 <kmc> bitches don't know bout my python
08:39:20 <FunctorSalad> apropos Kleisli... "/\ a b. a -> M b" couldn't be a Control.Category even if it wasn't for the overlapping (->) instance, could it....
08:39:29 <FunctorSalad> M a monad
08:39:30 <Twey> Hahaha
08:39:45 <djahandarie> Twey, who would say "I know this language" and also say "I am not smart enough to program in this language"
08:39:48 <kmc> whereas most people who can program *will* be intimidated by Coq
08:39:53 <FunctorSalad> (did I dream that or was there something I could have meant? ;))
08:40:21 <kmc> FunctorSalad, (Kleisli m) is an Arrow and thus a Category
08:40:34 <FunctorSalad> kmc: yeah, I specifically mean the naked a -> M b
08:40:45 <kmc> why not, then?
08:40:48 <edwardk> FunctorSalad: it works fine that is Kleisli m
08:41:00 <benmachine> we don't have type-level lambdas, that doesn't help
08:41:01 <kmc> aside from the overlapping instance and the lack of actual type-level functions
08:41:44 <Twey> djahandarie: Good question
08:42:08 <kamatsu> ah, with the "Commercial tools" question, there is also an "open source tools" question
08:42:24 <kamatsu> hence i think the "commercial tools" question is justified in haskell's case
08:42:30 <kmc> i agree
08:42:47 <kmc> and more commercial tools would be nice but i don't think we should lose sleep over it, unless there's a specific need not being filled
08:43:04 <illissius> ...bytestrings can contain null characters, right?
08:43:06 <kmc> it seems more likely that companies would fund IHG to improve existing tools
08:43:08 <kmc> illissius, yes
08:43:12 <illissius> ok
08:43:28 <kmc> well, regular ByteStrings contain bytes, not characters
08:43:32 <kmc> so the pedantic answer is "no"
08:43:41 <kmc> ByteString.Char8 can contain '\0'
08:44:46 <EvanR-work> bytes strings can contain zero
08:45:27 <EvanR-work> zero cannot escape from a bytestring
08:45:31 <EvanR-work> no matter how hard to tries
08:45:41 <EvanR-work> it :(
08:46:32 <BONUS> i wish ? was allowed as part of an identifier in Haskell
08:46:41 <BONUS> so we could have ByteString.empty and ByteString.empty?
08:47:02 <kmc> gb2scheme
08:47:06 <kamatsu> BONUS: are you a ruby programmer?
08:47:22 <EvanR-work> > let (?) = (+) in 3 ? 5
08:47:22 <lambdabot>   8
08:47:26 <Schalken> benmachine: My file is backwards. *cries*
08:47:34 <BONUS> kamatsu: heavens no! but i do like that from ruby though
08:47:41 <edwardk> 98 statements to go? * 40 languages or so that is somewhat of a hellish survey
08:47:42 <kmc> ByteString.emptyp
08:47:52 <kmc> edwardk, i warned you
08:47:53 <BONUS> > let blah? p = True in ()
08:47:54 <EvanR-work> BONUS: and foo! to mean side effects ;)
08:47:54 <lambdabot>   ()
08:48:00 <BONUS> haha
08:48:03 <kmc> :t ?p
08:48:04 <lambdabot> forall t. (?p::t) => t
08:48:21 <kmc> very few people think they're not smart enough to write C
08:48:27 <kmc> perception does not align with reality :O
08:48:30 <mux> I kinda like those ruby conventions; it's obviously not as good as having controlled side-effects with the help of the type system, but I think it's good style
08:48:58 <edwardk> kmc: hahahaha
08:49:03 <EvanR-work> the better you are at C, the more likely you think you arent good enough to write C ;)
08:49:16 <kamatsu> I really like Agda's mixfix syntax
08:49:19 <kamatsu> I wish haskell had it
08:49:29 <kmc> {-# LANGUAGE Agda #-}
08:49:36 <djahandarie> Heh
08:49:38 <kmc> would be interesting to see a similar ranking for features or concepts instead of languages
08:49:38 <kamatsu> it lets you define functions like "if _ then _ else _" 
08:49:40 <EvanR-work> mux: yes
08:49:47 <kamatsu> kmc: i agree
08:49:59 <kmc> "recursion", "abstract data types", "objects", "test-driven development", "first-class functions", "modularity"
08:50:07 <kamatsu> "monads"
08:50:20 <kamatsu> sadly i think monads may not score too well, even though programmers use them all the time
08:50:23 <kamatsu> (jquery)
08:50:27 <kmc> "i use this feature often", "i think this feature is essential for writing good software", "i find this feature easy/hard to understand"
08:50:27 <benmachine> Schalken: sry :(
08:50:45 <djahandarie> I *really* dislike how all academic-related stuff is always stuck in PDF format when on the web
08:50:48 <kmc> kamatsu, similarly first-class functions might score lower than "delegates" and "blocks" and "functors"
08:50:57 <Cale_> djahandarie: Why?
08:51:11 <Schalken> benmachine: This makes me a sad panda.
08:51:12 <Cale_> Personally, I love LaTeX's beautiful typesetting. :)
08:51:16 <Schalken> benmachine: Ahwell I think I
08:51:26 <Schalken> benmachine: I think I'll leave it for another day.
08:51:35 <djahandarie> Cale_, because it doesn't feel like a webpage
08:51:43 <djahandarie> Cale_, and makes me never want to click them
08:51:56 <Cale_> If I have to read anything of length, I don't want it to look like a webpage at all :P
08:52:17 <djahandarie> Also the formatting is for a paper, not a website
08:52:29 <Cale_> Why should it look like a website, if it's not?
08:53:03 <Cale_> Web browsers have pretty awful typesetting in general.
08:53:08 <djahandarie> It is something I click on in the middle of traveling between websites -- I'd prefer it to at least act like one, or preferbly actually be one
08:53:18 <djahandarie> preferably*
08:53:20 <smarmy> anyone have any problems mixing Data.Iteratee's dependency on monad transformers from the "transformers" package with the stuff included in the "mtl" package?
08:53:21 <Cale_> I don't know of any web browser which does anything near as good a job as LaTeX does.
08:53:49 <djahandarie> Cale_, I would love it if someone did LaTeX for an actual website, but they are doing it for papers, and it doesn't always translate well to the screen.
08:54:21 <Schalken> edwardk1: benmachine: Cya! Thanks for your help.
08:54:23 <kamatsu> kmc: at least people agree on a vocabulary to describe programming languages, but the features contained therein seem to have different names in different languages.
08:54:32 <kmc> kamatsu, yeah :/
08:54:38 <mux> Cale_: it's getting better though, now that firefox 3 for instance, supports kerning and ligatures
08:54:44 <kmc> my pet example is "hash consing" and "flyweight pattern"
08:54:45 <kmc> same thing
08:54:50 <kmc> two useless names
08:54:54 <kamatsu> "goroutines"
08:54:56 <kmc> two communities reinventing the wheel
08:54:57 <kmc> haha
08:55:03 <kmc> "goroutines" is awful
08:55:08 <kmc> it's just marketing
08:55:35 <kamatsu> or the various different uses of the word "functor"
08:55:40 <kmc> yeah
08:55:43 <kmc> i can think of 3 off-hand
08:55:51 <djahandarie> For example, I clicked on "Introductions to Agda" and I got this http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Othertutorials
08:55:53 <kmc> which are pretty distinct
08:56:00 <djahandarie> 7 papers to read
08:56:02 <mreh> is a pointer a functor?
08:56:21 <djahandarie> Actually the link was "Language tutorials", but yeah, no difference
08:56:21 <kamatsu> mreh: i would say so
08:56:23 <illissius> also, I frequent click links in web pages, but more or less *never* follow a cite from a pdf
08:56:33 <illissius> (and I know pdfs can have links, but they tend not to)
08:56:47 <illissius> *frequently
08:56:55 <mreh> you can write map in C quite nicely
08:57:06 <Cale_> mreh: Only with a retarded type.
08:57:10 <kamatsu> kmc: C++'s functor, Haskell's functor, and ML's functor?
08:57:26 <kmc> yeah
08:57:31 <Cale_> mreh: and with limited ability to supply functions to it
08:57:48 <kmc> functions in C aren't first-class unless you do a lot of other work
08:57:56 <Cale_> (you would either have to supply function pointers, or invent your own closure mechanism)
08:57:57 <mreh> I think Haskell's functor is better
08:58:00 <kmc> you can't make them dynamically by closing over free variables
08:58:17 * BMeph is amused that he dislikes "serious" papers written as webpages...
08:58:24 <kamatsu> Well, if you take the categorical definition of a functor, you can almost C how the other uses came about
08:58:31 <kmc> similarly in C++.  "functor" is the C++ community's established name for their standard workaround, i mean, "design pattern"
08:58:44 <kamatsu> C++'s functor is a function and an object..
08:58:45 <mreh> heh
08:58:55 <kmc> kamatsu, sure, because CT is a universal vocabulary ;)
08:59:03 <mreh> I lost that article where someone casts the big 5's patterns in Haskell
08:59:12 <kamatsu> ezyang?
08:59:14 <kmc> ezyang had something like that iirc
08:59:22 <Cale_> BMeph: Indeed, if it's intended as a serious paper, but written only as a webpage, I tend to immediately get suspicious of the quality of the contained work. There's a lot more quackery in HTML than there is in beautifully LaTeX'd PDF.
08:59:38 <kmc> not like Haskell doesn't have patterns of its own
09:00:11 <kmc> i think Haskell (and Python, and Ruby, and Lisp) communities have a healthier attitude towards "patterns" than Java and C++ communities
09:00:25 * BMeph reads Cale_'s comment and -> Immediately<- starts thinking about "Time Cube"...
09:00:30 <Cale_> hehe
09:00:32 <mreh> you mean not "aren't we great"?
09:00:41 <BMeph> Cale_: I Sooooooo agree with you there. :)
09:00:46 <Cale_> BMeph: Someone should do a LaTeX version of Time Cube ;)
09:01:05 * BMeph LOLs
09:01:07 * kmc petitions for the timecube symbol to be added to Unicode
09:01:11 <kamatsu> kmc: Ruby has a pretty strong association with the original Patterns peole.
09:01:16 <kamatsu> *people
09:01:16 <kmc> really?
09:01:20 <kmc> maybe i'm misinformed then
09:01:22 <kamatsu> kmc: Alot of smalltalkers moved to ruby.
09:01:38 <BMeph> kamatsu: On purpose? ;)
09:01:51 <kamatsu> BMeph: I don't follow your implication
09:01:58 <illissius> as a happy medium, how about offering both? then I can click links, and other people can admire the pretty typesetting (;. (OR! just hyperlink the cites in the pdf. also works.)
09:02:05 <Cale_> The original gang of four had a much healthier attitude toward patterns than all the people who read their book.
09:02:13 <kamatsu> which language is more flexible? Ruby or Haskell?
09:02:24 <Cale_> (and completely misunderstood the point of it)
09:02:54 <kmc> kamatsu, Ruby apparently
09:02:58 <Blkt> Cale_: what do you mean?
09:03:00 <illissius> ruby basically is smalltalk with a different syntax, no?
09:03:02 <kamatsu> Cale_: The problem with patterns is that people started thinking "I have a problem, what patterns should I use to solve it"
09:03:09 <kamatsu> illissius: and without some of the extra-cool features
09:03:24 <quicksilver> Cale_: you may be being slightly unfair by saying 'all' the people who read the book :)
09:03:35 <Cale_> quicksilver: Well, yes, I am being unfair :)
09:03:45 <illissius> I don't really get why ruby suddenly took off when smalltalk had been around since forever though
09:03:48 <quicksilver> all the people on reddit, though, I will accept
09:03:54 <kamatsu> I read the book, but after reading each pattern I wrote my own little addendum on why I thought that pattern was crap
09:04:02 <kamatsu> illissius: the lack of an image? the existence of Rails?
09:04:26 * quicksilver had the impression it was Rails
09:04:27 <kamatsu> I had to reach fairly strongly to say why I thought the strategy pattern was crap, but it was a good mental exercise.
09:04:30 <alpounet> Rational is an instance of Real right ?
09:04:31 <quicksilver> but that's not scientific.
09:04:45 <Cale_> Blkt: Patterns are a sign of weakness in a programming language. If you write similar looking code all the time and yet can't abstract that similarity away into a library for some reason, that's a problem.
09:04:52 <illissius> rails is def part of it, don't know if it's all of it though
09:05:14 <kamatsu> illissius: it emerged at a time when people were looking at dynamic languages seriously
09:05:16 <Cale_> Blkt: I'm pretty sure that the original gang of four were aware of this, but somehow didn't make it clear enough in their book.
09:05:17 <kamatsu> illissius: unlike smalltalk?
09:05:17 <illissius> (ignorant question) can you even implement rails (more or less) in smalltalk?
09:05:23 <quicksilver> well once you get critical mass then people start saying nice things about you on blogs / seminar / books /conferences
09:05:36 <quicksilver> perhaps rails pushed ruby to critical mass and then it succeeded after than on its own merit.
09:05:37 <kamatsu> illissius: yes, you could, but you'd need a good consistent smalltalk implementation without too much of an image overhead.
09:05:54 <Blkt> Cale_: I get the point now
09:05:56 <quicksilver> certainly ruby existed for many years pre-rails without making much of an impact.
09:06:14 <kamatsu> Python took off around the same time
09:06:21 <kmc> Cale_, a confounding issue being that "pattern" has now expanded to mean "anything the 'patterns community' likes"
09:06:31 <kmc> so it also describes things that aren't abstractable repetition
09:06:35 <kamatsu> like MVC?
09:06:56 <kamatsu> you can abstract that, all you need is a "framework" of confusing and poorly documented tools to generate code for you
09:07:01 <kmc> here in #haskell we like the "first-class function pattern" and the "type signatures pattern" and the "write code that works pattern"
09:08:03 <illissius> now, a dumb question that relates to haskell for a change, I hope ForeignPtrs (Concurrent-style) aren't kept from being collected merely by references to them in their own finalizers?
09:08:07 <Cale_> kmc: I tend to think that any form of repetition that we can recognise ought to *somehow* be abstractable, in some language. We might not know what that language is...
09:08:44 <kmc> but what would it mean to abstract out type signatures?
09:08:45 <kamatsu> Cale_: what about super low level repetition like many pattern cases in a haskell function definition ?
09:08:57 <Twey> Surely it's abstractable in any language with macros/TH
09:09:00 <Cale_> kamatsu: We do actually abstract over that quite often.
09:09:03 <kmc> it would mean type inference, which we already have and to which we prefer signatures in some cases
09:09:10 <kamatsu> Cale_: care to give an example?
09:09:15 <Cale_> :t maybe
09:09:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:09:27 <kamatsu> oh
09:09:29 <Cale_> kamatsu: And all the stuff about generics
09:09:31 <kamatsu> right, i see
09:09:31 <Twey> Turing-completeness means we can generate any pattern of code
09:09:33 * hackagebot ChristmasTree 0.2.1 - Alternative approach of 'read' that composes grammars instead of parsers.  http://hackage.haskell.org/package/ChristmasTree-0.2.1 (MarcosViera)
09:09:49 <kamatsu> why is it called ChristmasTree?
09:09:51 <Cale_> and things like foldr as well
09:10:00 <kmc> what i'm saying is that "pattern" has come to mean things that aren't patterns of code
09:10:12 <kmc> it has come to mean "best practice"
09:10:15 <Cale_> kmc: Well, perhaps you're right
09:10:22 <Twey> kamatsu:  ChristmasTree (Changing Haskell's Read Implementation Such That by Mainpulating ASTs it Reads Expressions Efficiently) 
09:10:29 <kmc> if you like something, you call it a pattern
09:10:33 <kmc> if you dislike it, you call it an anti-pattern
09:10:34 <Twey> This amuses me.
09:10:42 <Cale_> Twey: Yeah, I love that name too.
09:10:45 <kmc> :D
09:10:52 <Twey> Though it's somewhat spoilt by the typo in Mainpulating :
09:11:06 <kamatsu> Mainpulating is a perfectly cromulent word
09:11:10 <Twey> Hehe
09:11:21 <alpounet> @instances Rational
09:11:22 <lambdabot> Couldn't find class `Rational'. Try @instances-importing
09:11:25 <alpounet> @instances Real
09:11:25 <lambdabot> Double, Float, Int, Integer
09:11:26 <kamatsu> is it cromulent or cromulant?
09:11:33 <kamatsu> I guess cromulant is the american spelling
09:11:38 <Twey> kamatsu: -ant
09:11:46 <Twey> Hm
09:11:53 <Twey> Google says -ent
09:12:08 <Twey> Oh, but it has plenty of results for -ant too
09:12:11 <kamatsu> oh, maybe Cromulent is the american spelling, and Cromulant is the good old fashioned British way
09:12:17 <Cale_> Yeah, I always thought it was "cromulent"
09:12:49 <quicksilver> http://www.googlefight.com/index.php?lang=en_GB&word1=cromulant&word2=cromulent
09:13:00 <quicksilver> (ent wins by a factor of 100)
09:13:35 <Twey> What good old-fashioned British way?  It was invented by an American, in '96 :
09:14:44 <kamatsu> ah crap, i just realised there are 118 statements in this programming language ranking thing
09:14:48 <quicksilver> matt groenig is one of the most british americans though :)
09:14:53 <kamatsu> and i have to rank 19 languages in each one
09:15:30 <Twey> kamatsu: I know!
09:15:38 <Twey> I stopped when I realised that, too.  :
09:15:57 <Twey> quicksilver: Apparently it was Cohen who coined it, though 
09:16:00 <kmc> haha kamatsu
09:16:22 <kamatsu> oh the pain of a programming languages researcher
09:16:47 * Phyx- really needs to configure his client for unicode
09:17:18 <kamatsu> Phyx-: just because Twey always uses that emoticon? It's just :P so whenever you see gibberish, that's it.
09:17:34 <kmc> the site is missing some statements
09:17:47 <kmc> "This language is useful for being smug in arguments"
09:17:59 <kamatsu> aha
09:18:03 <kmc> "When I find that someone loves this language I usually disregard everything else they have to say"
09:18:04 <kamatsu> Haskell is great with that
09:18:04 <Phyx-> kamatsu: lol
09:18:13 <kmc> @quote algorithmic
09:18:13 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
09:18:29 * benmachine giggles
09:18:30 <EvanR-work> lol
09:18:30 <kamatsu> I had a very fun argument with a bunch of Go fans on reddit recently.
09:18:48 <kamatsu> I guess enjoying programming language arguments makes me a troll, but I'm right dammit.
09:19:11 <kmc> kamatsu, were they trying to convince you that dynamic downcasts from interface{} are really totally not at all the same as dynamic downcasts from Object in Early-Middle Java?
09:19:17 <kamatsu> kmc: yes.
09:19:22 <kmc> sigh
09:19:26 <kmc> they are predictable
09:19:34 <kamatsu> kmc: also that generics would make Go like STL and Boost.
09:19:45 <aristid> kamatsu: go seems completely uninteresting
09:19:58 <kamatsu> kmc: and also that not having type safety and not having abstractions are good things cos it's easier to understand.
09:19:59 <kmc> Ranked highly in: "2. This language is likely to be a passing fad"
09:20:16 <kmc> "6. I am reluctant to admit to knowing this language"
09:20:36 <kamatsu> aristid: i agree, and I worked with their creators
09:20:48 <kamatsu> *it's creators
09:20:50 <kamatsu> *its
09:21:14 <Phyx-> Hmmm, i've been doing too much haskell lately
09:21:19 * Phyx- fires up the xbox 
09:21:48 <Phyx-> before I go, Is network 2.2.1.7 broken?
09:21:53 <kamatsu> there was a hilarious response by one redditor
09:21:54 <kamatsu> let me find it
09:21:54 <kmc> Go was designed by brilliant systems people who are not programming-language experts
09:22:06 <Phyx-> Preprocessing library network-2.2.1.7...
09:22:06 <Phyx-> Network\Socket.hsc: In function `main':
09:22:06 <Phyx-> Network\Socket.hsc:1024: error: invalid application of `sizeof' to incomplete ty
09:22:09 <Phyx-> pe `ucred'
09:22:11 <kmc> they had one immensely successful previous design
09:22:27 <Phyx-> anyone know if that's me or the package b0rked?
09:22:43 <kamatsu> kmc: that's something i quickly realised speaking to them. They were just not at all up to date with programming languages research.
09:22:55 <kmc> and i think people like that are valuable in a design team
09:22:59 <kmc> but not as the only members
09:23:14 <kamatsu> kmc: It saddens me cos google had a shot at making a language that brought new ideas and new thinking into the mainstream
09:23:29 <kamatsu> kmc: and they came out with a disappointing language like Go
09:23:35 <kmc> Haskell is already doing that, without any big-name help
09:23:49 <Phyx-> "cabal install network<2.2.1.7" <-- I thought that was the correct syntax
09:23:52 <kamatsu> kmc: that's true, but it's still saddening that that is the state of new languages in the industry.
09:23:52 <Phyx-> anyone?
09:23:54 <kmc> all we have to do is rebrand Haskell as the pragmatic alternative to Haskell
09:24:08 <kmc> and get some big company to say they use it
09:24:21 <kamatsu> I quote a redditor Go fan.
09:24:24 <kamatsu> "But why do new projects in statically-typed languages seem to so rarely be competitive? To take one example, there used to be a Facebook competitor written in Java, but after only a year, it got rewritten in PHP in 2004 for performance and maintainability reasons, before becoming irrelevant outside of the South Pacific. Facebook itself is largely PHP and JS, with some Erlang, Java, Ruby, and C++."
09:24:38 <aristid> kmc: and optimally a big company that is not financial? :D
09:24:44 <kamatsu> "Where are the Facebooks, the Twitters, the Wordpresses, the MochiWebs built from the ground up in OCaml or Haskell or Scala?
09:24:47 <kamatsu> It's almost as if strong static type checking was risky. Like your project is likely to fail if you use it."
09:24:50 <BMeph> "Pattern" is the "sick" of the programming world....
09:24:56 <kmc> doesn't Twitter use Scala in a significant role?
09:25:05 <kamatsu> kmc: i know, i pointed that out in my counterargument
09:25:13 <aristid> kamatsu: as if java had meaningful static type checking.
09:25:21 <kamatsu> aristid: better than Go
09:25:30 <aristid> wow, go is even worse than java?
09:25:36 <kamatsu> aristid: it's about as good as ancient java.
09:25:45 <Cale_> aristid: Go is more comparable with C, from what I've seen.
09:25:48 <aristid> kamatsu: you mean generics improved that?
09:25:52 <kmc> also it's the typical myopia of ignoring all software except for things that you see every day
09:25:59 <kamatsu> aristid: yes, somewhat 
09:26:02 <kmc> most software isn't even publicly released let alone used by average users
09:26:12 <aristid> kamatsu: i somehow dislike java generics, they really are only 10% of the way towards a good solution
09:26:13 <djahandarie> kmc, pretty sure Scala does most of the heavy data-processing for Twitter, though Ruby is used for nearly everything else
09:26:29 <kamatsu> aristid: this is true, but they do make simple things like collections alot more type safe.
09:27:13 <kamatsu> but I found it amusing that he only quoted web projects where dynamic scripting languages are the norm
09:28:51 <aristid> kamatsu: i think it's three reasons in web projects: (1) culture/experience, (2) web framework, (3) bad collective experiences with c/c++/java
09:30:20 <kamatsu> aristid: I think flexible compiled languages such as Haskell have a chance in the web space.
09:30:22 <Twey> Java rewritten in PHP for performance reasons?
09:30:23 <Twey> What?
09:30:36 <monochrom> hahaha
09:30:39 <kamatsu> Twey: I know, but note that this arbitrary social network is unnamed.
09:30:46 <kamatsu> Twey: I live in the south pacific, i've never heard of it
09:30:51 <Twey> Heh, hmm
09:30:55 <aristid> kamatsu: yes, and if only in a niche for a while.
09:30:58 <arw> sufficiently stupid java is slower than php, iff you write your own php-to-c++ compiler ;>
09:30:59 <monochrom> C written in turing machine to improve performance :)
09:31:04 <Twey> arw: Sure, sure
09:31:21 <dcoutts_> Phyx-: it is correct syntax however you need to escape the argument containing the '<' character, as that means something special to the shell
09:31:23 <Twey> arw: But surely people who could write Java that crappy wouldn't have much better a time with PHP :
09:31:24 <kamatsu> monochrom: nah, evaluate your lambda calculus via substitution to improve performance and memory consumption.
09:31:30 <tibbe> haskell.org where art thou?
09:31:35 <dcoutts_> Phyx-: cabal install 'network<2.2.1.7'
09:32:03 <kamatsu> monochrom: environments are for people that can't write performant combinators.
09:32:04 <monochrom> perhaps it is "improve time and space complexity". :)
09:32:10 <dcoutts_> Phyx-: otherwise the shell reads it as "cabal install network" and set the stdin of that process to the file "2.2.1.7" (which presumably does not exist)
09:32:16 <kmc> odd, Go is "most similar to" mostly functional languages
09:32:21 <kmc> SML, OCaml, F#, Clojure
09:32:30 <ddarius> "improve spacetime complexity!"
09:32:35 <kamatsu> Its concurrency model is like CML right?
09:32:39 <kmc> don't know
09:32:39 <djahandarie> Are you sure it's not s/functional/esoteric/ ?
09:32:45 <monochrom> "improve your country's GNP! improve your organ size! improve your time complexity!"
09:33:06 <kmc> it's "static types without the suck" and "good concurrency"
09:33:08 <kamatsu> organ referring of course to the spleen.
09:33:22 <kmc> improve your coq power
09:33:31 <kamatsu> Coq is there but no Agda :(
09:33:59 <kamatsu> i put Coq in my list and am replacing Coq with Agda in all my rankings. Afaik they're broadly similar
09:34:24 <kmc> they're not that similar, but compared to anything else on the list, yes
09:35:03 <kamatsu> Haskell is at the top of my list for a surprisingly large amount of things
09:35:16 <kamatsu> including "I would use this language for casual scripting"
09:35:54 <kmc> buck the trend and use Coq
09:35:58 <kamatsu> haha
09:36:07 <kamatsu> prove your regex correct!
09:36:43 <Twey> Haha
09:36:45 <kmc> yes
09:36:48 <dancor> perl regex syntax for inline correctness proof?
09:36:51 <kamatsu> Also leads to surprising results, I would more likely use C for quick scripting than Java.
09:37:26 <dancor> C is so library-deficient tho
09:37:34 <kmc> yeah
09:37:35 <kamatsu> it's good for POSIX stuff.
09:37:46 <dancor> it seems like to me.  i guess elite C coders refuse to reuse
09:37:47 <Phyx-> dcoutts_: ah ok, thanks :)
09:37:54 <fryguybob> Why isn't Coq in the bottom of this one? http://therighttool.hammerprinciple.com/statements/this-language-makes-it-easy-to-shoot-yourself-in-t
09:37:58 <kmc> C is good until you need any basic data structure
09:38:04 <kamatsu> fryguybob: where is it?
09:38:05 <dancor> ya
09:38:11 <kamatsu> fryguybob: i suppose i could just open the page
09:38:15 <kmc> i was wondering if there was any project to provide C++ STL to pure C code
09:38:19 <kmc> would be a hack but maybe a decent idea
09:38:26 <dancor> C++ STL has a lot of good data structures i think
09:38:30 <kamatsu> kmc: couldn't you just write your own suite of data structures?
09:38:32 <fryguybob> kamatsu: 29th
09:38:37 <kmc> kamatsu, of course
09:38:45 <aristid> python is in the bottom list?!
09:38:52 <kamatsu> ?
09:38:58 <kamatsu> conclusion: programmers are stupid
09:38:59 <aristid> i've often shot myself in the foot with python.
09:39:04 <kamatsu> i always do
09:39:04 <fryguybob> I don't think Coq has foot yet.
09:39:06 <zygoloid> kmc: why not just use a c++ compiler and the stl with your c code?
09:39:08 <kmc> it's a vague subjective idea
09:39:28 <kmc> zygoloid, because you'd have to write code that is substantially C++ in syntax and semantics
09:39:45 <zygoloid> only when using the stl...
09:39:52 <kmc> yes
09:39:57 <aristid> zygoloid: i always try to avoid the evil c++ word to avoid flamewars, except when i can't resist.
09:40:03 <kmc> i want simple C syntax, semantics, and type system
09:40:13 <kmc> with a good library of basic data structures
09:40:25 <zygoloid> kmc: so write a wrapper around your favourite stl data structure, providing a c interface
09:40:34 <aristid> like, i refrained from saying that c++ is the most statically typed mainstream language
09:40:35 <kmc> isn't that what i proposed
09:40:43 <ddarius> Oh God, using the C++ STL in C would be atrocious.
09:40:53 <kmc> ddarius, not sure why, with decent wrappers
09:41:25 <ddarius> kmc: Well, probably for the same reason almost any polymorphic data structures in C are atrocious.
09:41:33 <kmc> ok sure
09:42:39 <kmc> wow, Haskell is #2 on "This language is good for scientific computing"
09:43:03 <kmc> it seems there's a big difference between "scientific computing" and "numeric computing"
09:43:14 <aristid> kmc: where's R on that list?
09:43:17 * fryguybob sighs at Fortran...
09:43:18 <kmc> #4
09:43:27 <kmc> don't hate on Fortran
09:44:15 <aristid> kmc: can you link the thing?
09:44:27 <kmc> http://therighttool.hammerprinciple.com/statements/this-language-is-good-for-scientific-computing
09:44:52 <exDM69> I'm shocked how much fortran is still used
09:45:05 <exDM69> Mr. Dijkstra called it the "infantile disorder"
09:45:09 <exDM69> and that was in 1975
09:45:11 <fryguybob> kmc: More a sigh of perhaps we would be better off if we still had to use punchcards...
09:45:33 <kmc> fortran has a lot of archaisms but is basically still a reasonable DSL for describing numerical computations to get blazing fast autoparallelized machine code
09:45:43 <kmc> writing a whole app in fortran is madness though
09:45:55 <Phyx-> grr can't seem to install any network at all
09:46:03 * kmc wonders idly if anyone has done Fortran FFI from Haskell
09:46:40 <kamatsu> which language has the most dogmatic community?
09:46:46 <aristid> kmc: i like R because the "almost everything is a vector" simplifies a lot of computations
09:46:59 <kamatsu> python is pretty dogmatic i guess
09:47:01 <kmc> seems like as new languages are accepted, old ones can actually become less bad as an average over their use cases
09:47:02 <kamatsu> are we dogmatic?
09:47:15 <gwern> oh yes
09:47:23 <kmc> same thing is happening with C++
09:47:34 <kmc> fewer people are writing regular apps in C++ thanks to Java and C# and Python etc.
09:47:43 <kamatsu> kmc: is this C++ with crazy template machines or without crazy template machines.
09:47:50 <zygoloid> i find it interesting how "language is a fad" is highly correlated with "language is good for prototyping" and "language is easy for beginners"
09:47:50 <kmc> and so the average C++ program is more aligned to the C++ niche
09:47:54 <kmc> not that C++ isn't still bad for that niche
09:47:59 <kmc> but it may be less bad than the alternatives
09:48:01 <aristid> kamatsu: with crazy template stuff of course :P
09:48:07 <kmc> ha zygoloid
09:48:12 <kmc> is there a big correlation chart somewhere
09:48:33 <aristid> kmc: did i mention that c++ is one of the more statically typed languages? certainly more statically typed than (even modern) java :P
09:48:39 <kmc> yeah
09:48:48 <fryguybob> @quote dogma
09:48:48 <lambdabot> No quotes match. That's something I cannot allow to happen.
09:48:50 <kamatsu> well, C's type system is less restricted than haskell
09:48:54 <fryguybob> guess we are not dogmatic.
09:48:59 <kmc> Java has a simple weak type system
09:49:05 <kamatsu> *C++
09:49:06 <kmc> C++ has a fancy complicated type system
09:49:13 <kamatsu> it's still a weak type system
09:49:16 <kmc> which has a lot of promise but in practice mostly gets in the way
09:49:17 <kmc> yes
09:49:20 <kamatsu> C++ has all of the typefails of C.
09:49:32 <kmc> weaker than Java in the technical sense of "weak"
09:49:39 <kmc> but you can import unsafeCoerce in Haskell too
09:49:44 <kamatsu> ah, there's another mistake in Go
09:49:49 <kamatsu> Nullable references!
09:49:55 <kmc> "weak" is still partially determined by common practice rather than language design
09:49:57 <kmc> kamatsu, yes
09:50:00 <jmcarthur> at least you can index types with integers in C++. can't even do that in haskell
09:50:09 <aristid> it's stronger than java in that generics in c++ actually use types all the way.
09:50:17 <kamatsu> jmcarthur: sure you ca
09:50:18 <kamatsu> *can
09:50:25 <kamatsu> jmcarthur: Data Z;
09:50:30 <kamatsu> jmcarthur: Data S a;
09:50:30 <jmcarthur> kamatsu: if you reimplement integers at the type level
09:50:37 <kmc> jmcarthur, or use something like She
09:50:40 <jmcarthur> that's not integers anyway ;)
09:50:40 <kmc> to do it for you
09:50:44 <kamatsu> fine
09:50:45 <aristid> kamatsu: oh sure you can simulate it in haskell, but restricted DT is more promising :P
09:50:48 <jmcarthur> kmc: she brings us closer :)
09:50:50 <kmc> still pretty far from the bounds of what's called "Haskell"
09:51:25 <jmcarthur> much less convenient than how C++ does it though
09:51:27 <aristid> the language called GHC removes a lot of haskell's limitations.
09:51:34 <jmcarthur> i mean, once you get over template syntax
09:51:43 <kamatsu> jmcarthur: I haven't been able to do that yet
09:51:57 <kamatsu> ah, there's a dogmatic community: Go
09:52:01 <jmcarthur> but if you imagine haskell syntax with c++ semantics then type level integers is quite nice
09:52:27 <kamatsu> jmcarthur: you can do them nicely in D.
09:52:30 <jmcarthur> numeric literals and normal operators
09:52:38 <jmcarthur> kamatsu: yeah, D is pretty nice compared to C
09:52:40 <jmcarthur> *C++
09:52:48 <kmc> hehe, Go ranks below a number of dynamically-typed languages for "If my code in this language successfully compiles, there is a good chance my code is correct."
09:52:50 <pastorn> jmcarthur: sounds like python with dependent types
09:52:57 <kamatsu> i did a project in D once.
09:53:01 <kamatsu> i regretted it
09:53:03 <kmc> Python already has dependent (dynamic) types
09:53:08 <jmcarthur> pastorn: what does?
09:53:08 <kamatsu> compiler and library support is *terrible*
09:53:10 <kmc> kamatsu, why?
09:53:10 <kmc> ah
09:53:16 <pastorn> at least haskell syntax + C++ semantics ~= typed python
09:53:17 <kmc> yeah there are two different std libs right?
09:53:26 <kamatsu> yup
09:53:30 <kamatsu> and 2 different language versions
09:53:32 <aristid> pastorn: except it's not static?
09:53:32 <jmcarthur> kamatsu: i used D a fair bit back in the <2.0 days. i liked it a lot then. i used tango instead of phobos though
09:53:37 <exDM69> I suggest boo if typed python is what you want
09:53:43 <pastorn> wtf is static?
09:53:54 <aristid> pastorn: python doesn't have static typing?
09:53:54 <pastorn> i've seen that in java
09:54:02 <kamatsu> pastorn: static is types are resolved at compile time.
09:54:03 <pastorn> oh, so not
09:54:13 <pastorn> static int readInt(String s);
09:54:14 <kamatsu> pastorn: python is dynamic because it's resolved at run time.
09:54:17 <kamatsu> pastorn: no
09:54:30 <jmcarthur> that's different
09:54:34 <kamatsu> Haskell is statically typed, Python is dynamically typed.
09:54:35 <pastorn> is it java that uses the word the wrong way
09:54:37 <pastorn> ?
09:54:46 <kamatsu> "static" literally means "at compile time"
09:54:52 <kmc> pastorn, it means lots of different things
09:54:53 <kamatsu> "dynamic" means "at run time"
09:55:00 <kmc> pastorn, arguably Java is using it wrong here
09:55:04 <kamatsu> Java's use isn't exactly incorrect as it is misleading
09:55:06 <kmc> pastorn, and arguably they're just using it differently
09:55:15 <kmc> some of this comes from the desire to minimize the number of keywords
09:55:17 <pastorn> ok :)
09:55:22 <aristid> jmcarthur: do you think a GHC extension providing types parametrised by integers would be feasible?
09:55:25 <kmc> that's why C++ uses it for many unrelated things
09:55:31 <jmcarthur> it's not an incorrect usage of the word "static," but it would be an incorrect usage of "statically typed"
09:55:39 <pastorn> hey, anyone here know anything about cabal?
09:55:40 <kmc> global scope vs. local scope vs. methods
09:55:41 <kamatsu> aristid: I think it might be, but you couldn't infer such a type.
09:55:43 <zygoloid> well, "static" means something like "fixed and unchanging"
09:55:49 <jmcarthur> aristid: i think type-level numeric literals is feasible
09:55:52 <kamatsu> pastorn: dcoutts knows everything about cabal
09:55:56 <pastorn> i have sort of written a library, and want to set it up/test it
09:56:01 <aristid> pastorn: i only said "static" because we were talking about typing, so i thought "static typing" was the obvious meaning :)
09:56:04 <jmcarthur> yeah it wouldn't be inferrable in all cases
09:56:11 <Phyx-> hmm odd... MSys can build network but Cygwin can't
09:56:29 <pastorn> dcoutts_: hello? can haz halp plz?
09:56:39 <jmcarthur> pastorn: what is it you need?
09:56:44 <pastorn> dcoutts_: could you please PM me when you read this...
09:56:47 <aristid> jmcarthur: it would be very useful for HList and Matrix stuff at the very least
09:56:53 <kamatsu> jmcarthur: arguably you'd get subtyping though..
09:56:54 <jmcarthur> just ask. maybe somebody who is not dcoutts_ knows
09:57:12 <pastorn> i want to know how to set it all up properly for making something to put on hackage, and how to view the generated documentation
09:57:12 <zygoloid> pastorn: you might be better off with an @tell
09:57:28 <pastorn> zygoloid: true, thank
09:57:28 <ddarius> Neel Krishnaswami is my favorite person on LtU.
09:57:34 <dcoutts_> pastorn: jmcarthur's suggestion is almost always the best policy
09:57:34 <kamatsu> jmcarthur: should the haskell runtime automatically convert between Int(1..10) and Int(1..100) ?
09:57:43 <jmcarthur> pastorn: you can generate the docs by running cabal haddock :)
09:57:43 <pastorn> haha
09:57:54 <pastorn> jmcarthur: ok, cool
09:58:03 <jmcarthur> pastorn: cabal check  is nice too :)
09:58:23 <Phyx-> is there a cabal command to reinstall all packages or update all?
09:58:41 <pastorn> so what i have is X.Y where all the goodies is, but i want the user to just use import X and hide X.Y in the haddock documentation
09:58:50 <pastorn> and have all the docs appear in X
09:59:04 <pastorn> when they're in fact written in X.Y (reexporting)
09:59:11 <ml-n`> Phyx-: cabal upgrade      Upgrades installed packages to the latest available version
09:59:27 <jmcarthur> pastorn: that should work without special effort
09:59:33 * dcoutts_ does not recommend cabal upgrade
09:59:43 <Phyx-> ml-n`: it's also been dissabled :P
09:59:46 <jmcarthur> pastorn: as long as you are rexporting things from X
10:00:00 <pastorn> jmcarthur: then the docs will appear in X?
10:00:08 <ml-n`> ic
10:00:09 <Phyx-> dcoutts_: wouldn't it be possible to just maintain a list of code packages and just not upgrade those?
10:00:10 <djahandarie> What would "upgrade" even mean in cabal's sense? It doesn't get rid of old versions
10:00:19 <jmcarthur> Phyx-: use your package manager or do it manually. cabal isn't a package manager
10:00:31 <jmcarthur> pastorn: yes
10:00:34 <pastorn> djahandarie: it just installs the newest versions alongside the old ones
10:00:39 <Phyx-> jmcarthur: huh?
10:00:50 <dcoutts_> Phyx-: core packages you mean, yes that's something we're thinking about, there's more details than one might initially think of
10:00:50 <djahandarie> pastorn... so the same things as "install"
10:01:06 <pastorn> djahandarie: upgrade is meant to run on *all* your installed packages
10:01:07 <jmcarthur> Phyx-: cabal's function is primarily as a build system
10:01:07 <dcoutts_> Phyx-: the other thing we're working on is "cabal install world"
10:01:29 <djahandarie> pastorn, yeah, I just mean it'd be closer to "cabal install-all" or something
10:01:31 <Phyx-> dcoutts_: lol, and what would that do?
10:01:46 <Saizan> djahandarie: "cabal upgrade foo" will also try to install newer versions of the dependencies
10:01:48 <kamatsu> haha
10:01:51 <pastorn> djahandarie: haha... if you succed with $ cabal install * # please tell me
10:01:52 <Saizan> djahandarie: that's the difference with install
10:01:55 <kamatsu> the random ordering of this language quiz is amusing
10:01:59 <jmcarthur> dcoutts_: really? that sounds like an amazing way to burn through your cpu and hard drive space :)
10:02:02 <Phyx-> jmcarthur: I'm on windows, but even if I was on a unix os, what would a local packager have to do with the cabal packages?
10:02:03 <kamatsu> it put Assembler at the top of "Readability"
10:02:04 <djahandarie> Saizan, ah, okay, I see
10:02:06 * ddarius forget he was supposed to be writing a C compiler this week.
10:02:14 <kamatsu> ddarius: why?
10:02:17 <jmcarthur> dcoutts_: oh, does "world" just mean "packages i've already installed"?
10:02:25 <dcoutts_> Phyx-: the "world" file is the list of packages you deliberately installed, as opposed to dependencies that got pulled in
10:02:32 <dcoutts_> jmcarthur: right, not all of hackage ;-)
10:02:35 * BMeph wants a "cabal conspiracy" command for the world thing. ;)
10:02:43 <Phyx-> jmcarthur: it's not so big a stretch to imagine wanting to reinstall your packages. I've had the config file get corrupted before, would have been handy
10:03:01 <BMeph> Or "conspire"
10:03:04 <djahandarie> What if someone makes a "world" package on hackage?
10:03:06 <kamatsu> BMeph: it should show freaky animations on your screen and play cracktro music
10:03:10 <jmcarthur> Phyx-: in the absense of a package manager the best way i know of is to manually reinstall them using cabal-install
10:03:15 <dcoutts_> djahandarie: then nobody can ever install it! :-)
10:03:16 <Phyx-> dcoutts_: ah ok, that would be very handy, then I could do cabal install world --reinstall :)
10:03:35 <djahandarie> dcoutts_, maybe it'd make more sense as cabal install-world or cabal install --world or something
10:03:56 <jmcarthur> cabal install --world
10:03:58 <Phyx-> jmcarthur: yeah, but that's a pain :P lol
10:03:58 <dcoutts_> Phyx-: only you'd not really want to do that, cabal will already reinstall packages that are broken due to missing dependencies
10:03:58 <BMeph> kamatsu: Especially fluttery motions at the edges - like you'r e_almost_ able to see something happening... >;)
10:04:35 <jmcarthur> Phyx-: not my problem that windows has no great package manager ;)
10:04:44 <ddarius> kamatsu: dons suggested it last night and I said I probably would.  It should only take a few hours of effort.
10:04:52 <djahandarie> I think cabal install --world would be confusing because then what woud "cabal install --world somepackage" do... it should probably be a seperate command like install-world
10:04:57 <kamatsu> ddarius: why are you doing it though? to what end?
10:05:03 <jmcarthur> djahandarie: good point
10:05:13 <Phyx-> jmcarthur: but again I don't see what an external package manager has to do with haskell packages. Are those even visible to it? you're saying apt-get knows about for instance Haskell-src-exts?
10:05:20 <jmcarthur> djahandarie: then again, it's easy to specify the command syntax unambiguously
10:05:21 <dcoutts_> djahandarie: but you're right in your earlier point about upgrade not really making sense given that we can install multiple versions. I've removed upgrade completely in the latest code. It now tells people to use install, or possibly install --upgrade-dependencies
10:05:40 <ddarius> kamatsu: It'll probably be fun and it shouldn't take much time.  Also, it's the in thing to do.
10:05:55 <kamatsu> ddarius: i thought people stopped writing compilers a few years ago
10:06:04 <kamatsu> that's what roman lechinsky said
10:06:10 <jmcarthur> Phyx-: well, my package manager knows hackage  (bauerbill on arch linux)
10:06:10 <pastorn> ddarius: BNFC?
10:06:35 <ddarius> pastorn: Haskell.  Why the heck would I use BNFC?
10:06:38 <dcoutts_> djahandarie: cabal install world somepackage, will mean to install the latest versions of all the packages in the world file, plus somepackage, and to add somepackage to the world file upon successful installation
10:06:39 <jmcarthur> it needs some work, but it does actually handle updates for me at least
10:06:52 <pastorn> ddarius: you won't have to write a parser?
10:06:59 <ddarius> pastorn: I don't have to write a parser.
10:07:00 <pastorn> writing parsers can get tedious
10:07:07 <Phyx-> jmcarthur: don't think that's the norm though, don't think i've seen yum knowing hackage
10:07:08 <pastorn> ddarius: why not?
10:07:12 <Phyx-> then again, haven't looked
10:07:15 <pastorn> jmcarthur: PM 4 U
10:07:19 <ddarius> pastorn: There is already a complete C parser in the libraries.
10:07:22 <pastorn> haha
10:07:25 <jmcarthur> djahandarie: `cabal help install' already says there are two ways to invoke install:   cabal install [FLAGS]  or  cabal install [PACKAGES]
10:07:26 <zygoloid> jmcarthur: Language.C?
10:07:26 <pastorn> ddarius: you lazy...
10:07:36 <zygoloid> s/jmcarthur/ddarius/
10:07:39 <ddarius> pastorn: I intend to be done in a few hours.  That's part of the goal.
10:07:45 <pastorn> ah, ok
10:07:52 <pastorn> ddarius: what's the backend?
10:07:57 <dcoutts_> jmcarthur: that's sort-of because [PACKAGES] can be empty, referring to the local dir
10:07:59 <pastorn> LLVM? Jasmin?
10:08:00 <jmcarthur> Phyx-: also, arguably, haskell packages would be best ported to each respective package manager
10:08:03 <pastorn> X86?
10:08:04 <ddarius> pastorn: LLVM most probably
10:08:17 <djahandarie> C--
10:08:17 <ddarius> zygoloid: Yes.
10:08:18 <pastorn> ddarius: do you intend to use the LLVM library?
10:08:22 <ddarius> Yes.
10:08:23 <jmcarthur> dcoutts_: ah.  well, my point is just that the syntax is already specified :)
10:08:32 <pastorn> ddarius: you probably shouldn't...
10:08:32 <ddarius> Unless I decide some other approach would be quicker.
10:08:43 <Phyx-> jmcarthur: i would rather have them out, since people will take more libreries in using unix only dependencies
10:08:44 <pastorn> as i understand it, the LLVM library is for writing really fast code
10:08:48 <Phyx-> which already annoy me :|
10:08:50 <pastorn> like inline assembly
10:08:56 <djahandarie> ddarius, you mean the Haskell LLVM bindings?
10:08:57 <jmcarthur> Phyx-: well, it'
10:08:59 <jmcarthur> dang
10:09:03 <ddarius> djahandarie: Yes.
10:09:06 <Phyx-> liberties*
10:09:10 <jmcarthur> Phyx-: well, it's nice in that a real package manager can install C dependencies for you, too
10:09:14 <djahandarie> In fact, why doesn't GHC use those bindings for the LLVM backend?
10:09:29 <pastorn> djahandarie: as i said
10:09:29 <dcoutts_> jmcarthur: if in practise we have problems with ambiguity then we can deal with it then, I'm happy with adding more kinds of targets on the command line, like local dirs, http urls etc
10:09:38 <ddarius> djahandarie: They probably didn't exist when the LLVM backend was being used, or maybe it does.
10:09:44 <ddarius> s/used/made/
10:09:53 <pastorn> you should see the LLVM bindings as a way of doing inline assembler
10:10:06 <ddarius> pastorn: LLVM is meant to be a compiler backend.  I'm writing a compiler.
10:10:08 <jmcarthur> dcoutts_: yeah i would love to be able to install from http (or darcs, hint hint)
10:10:14 <djahandarie> They were released before the backend for sure, not sure when the work on the backend started though
10:10:21 <noteed> djahandarie: I think there is the llvm-related gsoc will try to use those bindings
10:10:26 <dcoutts_> jmcarthur: http I hope to do soon, darcs/git/etc is much harder
10:10:35 <djahandarie> noteed, ah, cool
10:11:04 <dcoutts_> jmcarthur: afterall you wouldn't want it to darcs get the whole repo every time you install, it needs thought about how to handle local copies of repos
10:11:10 <ddarius> Maybe I'll throw some Hoopl in !
10:11:33 <pastorn> ddarius: yes, but the haskell LLVM library by augustsson isn't intended for backends
10:11:42 <jmcarthur> dcoutts_: darcs already has a local cache now at least
10:11:50 <pastorn> it's itended for getting really fast algorithms
10:12:02 <jmcarthur> still has to rebuild pristine if you get a fresh repo though
10:12:08 <dcoutts_> jmcarthur: oh does that mean it can avoid downloading patches completely?
10:12:14 <djahandarie> pastorn, is a backend suppose to produce really slow algorithms? :P
10:12:41 <pastorn> djahandarie: when you make a backend you'll probably want to have a deep embedding of the target language
10:12:52 <pastorn> it'll get kindo hard to debug otherwise
10:12:54 <jmcarthur> dcoutts_: yup :)
10:12:56 <pastorn> *kinda
10:13:02 <dcoutts_> jmcarthur: nice
10:13:03 <noteed> pastorn: quoting the gsoc blog post: Last week, I started working with the Haskell binding of the LLVM API, which will be my best friend this summer since the first part of my SoC consists in using this package to rewrite a part of the back-end.
10:13:20 <jmcarthur> dcoutts_: if you check out, say, ghc, then check it out again, the second will be *much* faster
10:13:47 <jmcarthur> or at least, this is my understanding
10:13:57 <pastorn> noteed: i just know that noone that has done the CC course on chalmers that i've talked to has used that library
10:13:59 * jmcarthur braces himself for a flurry of corrections
10:14:54 <djahandarie> jmcarthur, is the local cache just of the files to avoid redownloading them? Or some intermediate parsed form
10:15:38 <pastorn> this is all a bit too clever: http://hackage.haskell.org/package/llvm
10:15:42 <jmcarthur> djahandarie: i don't know the format. it's whatever the repositories store themselves. (they use hardlinking to avoid copying)
10:16:37 <jmcarthur> dcoutts_: yeah, i just tried it. a second checkout of ghc skips to making a pristine copy. doesn't pull any patches
10:16:46 <mux> jmcarthur: they do? is that even possible on windows?
10:16:56 <jmcarthur> mux: no idea. i'm on linux
10:18:11 <mux> same here, but I'm being curious
10:18:17 <mux> well, not linux, but whatever
10:19:16 <jmcarthur> dcoutts_: darcs get --lazy http://darcs.haskell.org/ghc ghc2  0.64s user 0.22s system 46% cpu 1.845 total
10:19:18 <jmcarthur> :)
10:19:23 <dcoutts_> :-)
10:20:33 <djahandarie> (-:
10:22:21 <benmachine> 
10:22:49 <Nola> is there an addon for Haskell that makes all declarations have local scope?
10:23:28 <sclv> huh?
10:23:51 <kmc> local to what?
10:24:11 <Nola> if I use 'type' then it must be global, why is everything global in Haskell except for the the Module space?
10:24:18 <IRCSTINKS> i think scope where they were declared
10:24:21 <kmc> Nola, you can choose not to export something from your module
10:24:25 <IRCSTINKS> like { } scoping in c-like langs
10:24:26 <Nola> The modules system is like a 1-dimensional vector
10:24:32 <kmc> module Foo() where type Bar = String
10:24:36 <kmc> Bar won't be exported
10:24:52 <kmc> there isn't anything more fine-grained for type synonyms and the like
10:24:52 <IRCSTINKS> Nola: is my guess wrong?
10:25:08 <kmc> (type, data/newtype, class, instance, default, infix/infixr/infixl)
10:25:37 <kmc> local variable bindings are introduced with let, where, lambda, or case
10:26:57 <kmc> i'm not sure what you mean by your "1-dimensional vector" comment
10:31:09 <zygoloid> ddarius: i vaguely recall that last time i looked at the llvm backend (a long time ago now) there was no way to write out the llvm bitcode to a file (only to compile it into code running in-process)
10:32:14 <gwern> huh. I now have >1200 patches in my personal wiki
10:32:20 <noteed> zygoloid: you mean the new ghc backend or the llvm bindings?
10:32:24 * gwern writes more than I think I do, I guess
10:32:36 <zygoloid> noteed: the llvm bindings. but it looks like that's been long-fixed
10:32:38 * jmcarthur should really keep a personal wiki
10:32:58 <djahandarie> Hmm, a personal wiki
10:33:01 <noteed> zygoloid: I seem to recall a blog post with an example of writing the bitcode
10:33:04 <djahandarie> That sounds potentially very useful
10:33:19 <djahandarie> I have a habit of neglecting things like that though
10:33:19 <gwern> djahandarie: it is
10:33:23 <pastorn> gwern: how have you set that up?
10:33:25 <zygoloid> noteed: yeah, there's a function for that now. i think i must have been using 0.0.2!
10:33:31 <jmcarthur> i have tried it twice, but i always drift back to old habits (either not writing things down or scattering random text files everywhere)
10:33:40 <jmcarthur> pastorn: gitit maybe?
10:33:40 <djahandarie> Haha jmcarthur me too
10:33:44 <gwern> djahandarie: the nice thing is that once you get it going, you want to use it; you run into a link or a factoid that supports something you wrote, and you go add it
10:33:45 <smarmy> i always lose my web server hosting my wiki
10:33:49 <gwern> pastorn: yeah, I use gitit locally
10:33:59 <pastorn> never heard of...
10:34:23 <gwern> !
10:34:27 <pastorn> yes
10:34:31 <gwern> I think gitit is one of the better haskell apps
10:34:36 <gwern> up there with xmonad and darcs
10:34:40 <jmcarthur> gitit is indeed very nice
10:34:40 <gwern> albeit much less used :(
10:34:59 <gwern> but then, at one time or another I've been a dev for all 3, so...
10:35:26 <noteed> zigoloid: http://augustss.blogspot.com/2009/01/llvm-llvm-low-level-virtual-machine-is.html
10:44:03 <mreh> how can I just display an image quickly
10:44:22 <mreh> I've got a matrix of pixel values, need to visualise it fast
10:44:29 <mreh> in haskell
10:44:34 <opqdonut> ascii art ;)
10:44:35 <benmachine> fast in programmer-time or fast in execution time
10:44:40 <soupdragon> you could print out an HTML table which has the cells colored by the pixels
10:44:43 <mreh> programmer-time
10:44:51 <benmachine> ah, I can send you a thing to do it with SDL
10:44:56 <noteed> mreh: PPM file format is quite simple
10:45:13 <Zao> mreh: Write to temporary file, invoke suitable application?
10:45:13 <olsner> XPM too
10:45:29 <BMeph> Is anyone here familiar with the (Ruby) Wagn project?
10:45:37 <Zao> GTK would probably not be horribly hard either, assuming you know GTK's Image, Window and Pixbuf classes.
10:45:38 <mreh> I'm going to be wrapping libavcodec so we can all the nice coder/decoders
10:45:48 <mreh> until then
10:45:51 <mreh> lots of ideas here
10:45:57 <Twey> SDL too
10:46:14 <Twey> Or that libpng binding on Hackage
10:46:27 <mreh> pngload?
10:46:27 <Zao> Or cry.
10:46:32 <benmachine> mreh: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25974#a25974
10:46:34 <Twey> Could be
10:46:46 <mreh> it only loads them, it can't save them
10:46:48 <noteed> mreh: or maybe Andrew Copin's http://hackage.haskell.org/package/AC-EasyRaster-GTK
10:47:02 <benmachine> mreh: typo'd a comment but you get the idea :P
10:47:20 <kmc> yes PPM
10:47:30 <benmachine> oh I guess I've missed out the setvideomode bits
10:47:43 <kmc> open xview as a subprocess, write ppm on pipe
10:47:47 <Twey> benmachine: I'm pretty sure the SDL binding has functions for setting individual pixels
10:47:56 <Twey> You don't have to mess about with the plumbing
10:48:07 <benmachine> Twey: hmm
10:48:14 <benmachine> Twey: it has rect-drawing
10:48:27 <benmachine> not sure about pixel-setting
10:48:58 <noteed> mreh: a lot of image viewer automatically reload upon file changes
10:51:03 <Twey> benmachine: Well, you could draw a 11 rectangle
10:51:20 <Twey> Probably the same thing
10:52:46 <benmachine> Twey: I suspected my way might be faster
10:53:45 <Gracenotes> is there a simpler way of saying: char '0' >> option 0 (char '.' >> option 0 foo)?
10:54:02 <Gracenotes> benmachine: it doesn't expose the pixel-drawing, iirc
10:54:18 <Gracenotes> to do that, you have to get down and/or dirty with the SDL screen buffer format
10:54:30 <benmachine> yeah
10:54:34 <benmachine> isn't too hard though
10:54:51 <Gracenotes> the hardest part would be making it work with the C* types
10:55:28 <Gracenotes> once you have that... but, right, not exposed (SDL_Surface is a black box in the bindings)
10:56:02 <Veinor> http://lambda.bugyo.tk/cdr/mwl07/mwl07.html
10:56:11 <Veinor> http://twitpic.com/1tkzve
10:57:00 <benmachine> it's not a black box is it?
10:57:04 <benmachine> I mean
10:57:08 <nominolo> :t show . read
10:57:08 <lambdabot> String -> String
10:57:15 <nominolo> WRONG!
10:57:23 <kmc> hmm
10:57:25 <benmachine> there are quite a few things that might as well be accessors
10:57:29 <benmachine> surfaceGetFoo
10:57:34 <kmc> if you write an async logging thread in Haskell in the obvious way
10:57:37 <Gracenotes> if the pointer isn't exported
10:57:40 <kmc> then that thread also does the work of formatting the log messages
10:57:43 <nominolo> are there any defaulting rules for Read?
10:57:50 <benmachine> Gracenotes: it kiiind of is
10:57:56 <kmc> that's neat
10:57:57 <Gracenotes> oh mai
10:58:13 <zygoloid> > show . read $ "()"
10:58:14 <lambdabot>   "()"
10:58:17 <benmachine> not the pointer itself but the pixeldata pointer
10:58:21 <Gracenotes> benmachine: nonetheless, you don't get the benefit of any hsc stuff that goes on
10:58:23 <zygoloid> nominolo: how is it wrong?
10:58:34 <nominolo> it should fail with an ambiguity error
10:58:37 <mreh> can't generate docs without configuring the package, which means installing the dependencies :(
10:58:41 <zygoloid> nominolo: it gets defaulted
10:58:41 <Gracenotes> nominolo: (read . show) should be identity
10:58:45 <benmachine> should be (Show n, Read n) => String -> String
10:58:54 <benmachine> with no further information to resolve n
10:59:11 <nominolo> benmachine: no, since 'n' doesn't occur in the actual type
10:59:13 <zygoloid> n is then defaulted to ()
10:59:24 <Gracenotes> oh, you mean, for typeclasses. the way to do that is to specify the type of read
10:59:25 <nominolo> zygoloid: yes, which is just wrong
10:59:32 <zygoloid> nominolo: in what way is that wrong?
10:59:39 <roconnor> @type read . show
10:59:39 <benmachine> nominolo: it's documented behaviour
10:59:40 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
10:59:44 <nominolo> zygoloid: it doesn't make any sense
10:59:45 <nominolo> benmachine: where?
10:59:57 <benmachine> nominolo: it's documented on haskell.org :x
10:59:58 <Gracenotes> nominolo: suppose you do show . read . show . read. What is your ideal type signature for that?
11:00:04 <roconnor> @type show . read
11:00:04 <lambdabot> String -> String
11:00:19 <nominolo> Gracenotes: It should be rejected due to ambiguity
11:00:20 <Gracenotes> (Show a, Read a, Show b, Read b)? which one's a and which one's b?
11:00:31 <benmachine> Gracenotes: you can't tell, which is why it's ambiguous :P
11:00:41 <Gracenotes> ah. likewise, the expression (3 + 4) should be rejected due to ambiguity
11:00:54 <Gracenotes> however, it's sort of a Haskell feature that defaults are provided
11:00:57 <benmachine> often the type of (3 + 4) can be inferred
11:01:03 <zygoloid> nominolo: should \a -> a^3 be rejected too?
11:01:06 <nominolo> Gracenotes: well, for numbers defaulting makes sense.  for most other things it doesn't
11:01:07 <benmachine> but you have a problem with say fromIntegral 7
11:01:07 <Gracenotes> the expression by itself
11:01:10 <zygoloid> @type (^)
11:01:11 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
11:01:21 <Gracenotes> nominolo: right, I was going to say. turns out that () is defined as a default
11:01:30 <zygoloid> ^^ note that \a -> a ^ 3 has type (Num a, Integral b) => a -> a
11:01:32 <benmachine> ghci has extended defaulting rules
11:01:41 <nominolo> Gracenotes: you get similar problems with quickcheck
11:01:55 <mreh> how come I can only obtain the gtk bindings from a repo?
11:02:00 <mreh> that is, not hackage
11:02:06 <benmachine> nominolo: only in ghci/mueval/whatever
11:02:12 <nominolo> @quickcheck \xs ys = reverse (xs ++ ys) == reverse xs ++ reverse ys
11:02:12 <lambdabot> Unknown command, try @list
11:02:13 <benmachine> nominolo: also, -fwarn-defaulting
11:02:33 <zygoloid> nominolo: see section 4.3.4 of the report: http://www.cse.iitb.ac.in/~as/fpcourse/haskell98_report/decls.html#overloading 
11:03:07 <djahandarie> @check \xs ys = reverse (xs ++ ys) == reverse xs ++ reverse ys
11:03:07 <lambdabot>   Parse error at "=" (column 8)
11:03:19 <djahandarie> @check \xs ys -> reverse (xs ++ ys) == reverse xs ++ reverse ys
11:03:20 <lambdabot>   "OK, passed 500 tests."
11:03:40 <nominolo> djahandarie: right, which should fail
11:03:48 <zygoloid> nominolo: the rules listed there aren't quite what GHC implements
11:03:51 <djahandarie> nominolo, too few tests
11:03:55 <nominolo> @check \xs ys -> reverse (xs ++ ys) == reverse xs ++ reverse (ys :: [Int])
11:03:56 <lambdabot>   "Falsifiable, after 4 tests:\n[0]\n[2,2]\n"
11:04:12 <zygoloid> hooray for defaulting :(
11:04:31 <nominolo> So, it's a library problem, not a compiler problem
11:05:05 <nominolo> anyone know how to find the defaulting definitions?
11:05:12 <nominolo> ghci's :info doesn't help
11:05:40 <kmc> mreh, you can "cabal install gtk" as of recently
11:05:55 <mreh> kmc: not the version I require
11:06:01 <kmc> :/
11:06:01 <mreh> 0.10
11:06:18 <kmc> then that's how come
11:06:24 <kmc> is they only fully cabalized it recently
11:06:36 <mreh> bum
11:06:46 <mreh> it seems to not exist on hackage
11:06:54 <kmc> out of curiosity, why do you need 0.10
11:07:27 <mreh> google hasn't indexed it
11:07:37 <mreh> kmc: because that's what this library needs
11:07:40 <kmc> btw some linux repos have packages older than 0.11
11:07:42 <heatsink> nominolo: I think defaulting has to be defined in the same file.  It's not exported like classes.
11:07:43 <kmc> ok
11:07:50 <nominolo> benmachine: ok, if I type it into a file it fails with an ambiguity error as expected 
11:07:51 <mreh> I could just change the numbers in the cabal file and see what happens!
11:08:01 <mreh> 0.11 is only "one" more
11:08:04 <benmachine> nominolo: tada
11:08:05 <mreh> spinal tap
11:08:15 <mreh> this module goes to eleven
11:08:24 <nominolo> heatsink: yup "Only one default declaration is permitted per module, and its effect is limited to that module. If no default declaration is given in a module then it assumed to be: 
11:08:28 <nominolo> default (Integer, Double)"
11:09:17 <nominolo> heh, there's an "is" missing.
11:10:21 <kmc> the rankings thing has Haskell as the second-to-least "mainstream" language
11:10:34 <sproingie> what's the least?
11:10:45 <kmc> Coq
11:10:46 <nominolo> haskell.org is back!  yay!
11:10:52 <benmachine> :O
11:10:55 <Twey> \o/
11:11:14 <kmc> Agda is 10th most mainstream?
11:11:17 <kmc> some weirdness clearly ;P
11:11:19 <benmachine> lolol
11:11:45 <sproingie> clearly not a maintsream sample
11:12:07 <kmc> Haskell is known as non-mainstream, which is different from not being known at all
11:12:27 <mreh> it's so relative
11:12:38 <kmc> probably very few people checked the box for Agda or Mozart-Oz or APL
11:12:40 <monochrom> mainstream is so passe
11:13:48 <mreh> we need a library like mathematica's amazo visualisation routines
11:15:20 <dons> http://haskell.org/ back
11:15:50 * magicman cheers \o/
11:16:00 <zygoloid> that's, like, /so/ five minutes ago! ;-)
11:16:13 <kmc> still at yale?
11:16:30 <jmcarthur> i once discovered that drawing a rectangle for each sample of a heatmap using the diagrams package is pretty slow
11:16:34 <zygoloid> (also hooray)
11:16:39 <jmcarthur> but it was fairly easy to write at least
11:16:43 <djahandarie> dons, on a different box?
11:18:15 * hackagebot ad 0.28 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.28 (EdwardKmett)
11:19:12 <edwardk> now with the shiny Tensors data type!
11:19:36 * BMeph "Ooh!"s at the shininess... ;)
11:19:54 * BMeph then "Aah!"s at the Tensoricity! 8D
11:20:05 <edwardk> data Tensors f a = a :- Tensors f (f a)
11:20:24 <edwardk> a :- f a :- f (f a) :- f (f (f a)) :- ...
11:20:46 <BMeph> kmc: There's an Agda box already? Sweet!
11:21:07 <soupdragon> wow
11:21:07 <edwardk> i have a number of combinators i'm adding that return cofree comonads, and i worked out a way with ski to convert that into the Tensors type above.
11:21:41 <edwardk> sadly Tensors f is not a comonad. =/
11:22:14 <kmc> "Based on 0 responses from 0 people, we've built up the following picture of Agda"
11:22:15 <kmc> well
11:22:21 <edwardk> kmc: hahahaha
11:22:29 <kmc> "6. This language would be good for teaching children to write software"
11:22:33 <jmcarthur> that's an interesting structure
11:23:27 <edwardk> jmcarthur: i'm using it with head, and tail like combinators to let you pick off the appropriate number of times you want to iterate the gradient.
11:23:28 <kmc> interesting, "I usually use this language on solo projects" is close to "I can imagine using this language in my day job"
11:23:28 <jmcarthur> Mu:fix::Tensor:iterate ?
11:23:35 <kmc> i guess we imagine the world we want to see
11:24:09 <edwardk> jmcarthur: the iterate would have to be something a bit funny.
11:24:20 <jmcarthur> :t iterate
11:24:20 <lambdabot> forall a. (a -> a) -> a -> [a]
11:24:35 <edwardk> unfoldT :: (a -> f a) -> a -> Tensors f a
11:24:37 <jmcarthur> well i guess so
11:24:56 <edwardk> would be the simplest you can get but isn't fully general
11:25:30 <jmcarthur> i meant from the view of lifting functions from term to type level
11:25:49 <edwardk> unfoldT for Tensors is kind of like a iterate version of ana for Mu so yeah
11:26:21 <jmcarthur> Iterate :: (* -> *) -> * -> [*]
11:26:27 <jmcarthur> in psuedo-syntax
11:26:33 <soupdragon> can't read that
11:27:21 <edwardk> i wanted the tensors type so i could let end users unzip the f-branching streams i give back without having to care about stream internals
11:28:22 <edwardk> jmcarthur: i have kind puzzled through your analogy it mostly works =)
11:28:29 <edwardk> er kind of
11:29:03 <jmcarthur> Fix :: (* -> *) -> * -> *   ... to be complete
11:29:27 <jmcarthur> well, that actually *is* Mu. Iterate is not Tensors though
11:30:35 <edwardk> you need kind variables ;)
11:30:38 <jmcarthur> yeah
11:31:31 <EvanR-work> whats the next level after kinds
11:31:37 <kmc> sorts
11:31:39 <EvanR-work> lol
11:31:40 <kmc> sometimes
11:31:45 <jmcarthur> depends on the language
11:31:52 <kmc> but at that point you usually say "fuck it" and get dependent types
11:31:58 <edwardk> EvanR-work: super-kinds. usually you just move to a pure type system of some sort and just add another universe
11:31:59 <kmc> in which case they're all at the same semantic level
11:32:14 <jmcarthur> <3 universe polymorphism
11:32:18 <kmc> but Omega has an infinite hierarchy (and GADT-like data at each level) without DT
11:32:23 <EvanR-work> sounds like acceleration jerk snap crackle pop
11:32:28 <kmc> hehe
11:32:33 <edwardk> EvanR-work: heh
11:32:37 <kmc> i wish Haskell had datakinds
11:32:46 <heatsink> What do you call the level below "type"?
11:32:49 <kmc> value
11:32:52 <edwardk> heatsink: term
11:32:54 <kmc> or "term"
11:33:05 <kmc> kind N where { Z :: N; S :: N -> N }
11:33:37 <jmcarthur> like Agda's Set1?
11:33:39 <soupdragon> kmc what is that?
11:33:58 <kmc> kind Vec (n :: N) (a :: *) where { Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a }
11:34:07 <soupdragon> why not just use normal values
11:34:15 <heatsink> Value makes sense.  I thought terms were what you get with application, which you have at all levels.
11:34:17 <edwardk> soupdragon: one of the exotic inhabitants of the interesting evolutional backwater is omega.
11:34:18 <kmc> this is hypothetical haskell syntax
11:34:34 <soupdragon> yeah I know it's hypothetical
11:34:35 <kmc> no dependent types required
11:34:40 <kmc> works like GADT
11:34:54 <kmc> err
11:35:01 <edwardk> heatsink: well, the usual phrasing is that values are the results you get from terms, but as there are lots of people in the world, there are lots of usage patterns that have evolved.
11:35:04 <kmc> the second thing shouldn't be "kind"
11:35:35 <edwardk> the latter is just data no?
11:35:40 <edwardk> you want it in the regular universe
11:35:42 <kmc> yeah it would be
11:36:02 <edwardk> otherwise you can't swap Vec's around with other normal types
11:36:33 <kmc> if n :: N, then is there some x s.t. x :: n ?
11:36:47 <soupdragon> kmc that's what I was asking pretty much
11:36:47 <kmc> or do types of data kind have no inhabitants?
11:37:08 <kmc> it is sometimes useful to reify the proofs into the value level
11:37:20 <kmc> P_Z :: Z :: N
11:37:27 <edwardk> kmc: but its also sometimes useful to be proof oblivious for erasure purposes
11:37:39 <edwardk> otherwise you wind up in agda land where you just crash for wont of memory ;)
11:38:14 <EvanR-work> they should be coming out with infinite memory machines soon
11:38:37 <edwardk> EvanR-work: man, turing laid the groundwork for those a long time ago, when will industry get off its behind and release some?
11:38:43 <EvanR-work> yeah
11:38:44 <Saizan> edwardk: well, erasure would work on closed computation, i.e. at runtime not during typechecking, no?
11:38:44 <kmc> just patch the RTS to buy more storage from S3 when it runs out of RAM
11:39:00 <edwardk> i guess they are having some problems down at the infinite tape factory with cost controls
11:39:02 <ezyang> Does anyone know if Cabal supports Greencard? 
11:39:08 <kmc> erasure doesn't work with partial functions
11:39:28 <kmc> because your proof might be a bullshit diverging term
11:39:35 <edwardk> kmc: with agda that could get very very expensive
11:39:41 <kmc> yeah
11:39:45 <dcoutts_> ezyang: I think I removed it because it was bit rotted, if someone wants to test it then it should be easy enough to add it
11:40:12 <edwardk> agda needs to try for a while and then go .. meh, i trust you. thats good enough for me ;)
11:40:34 <kmc> edwardk, just like TA's checking proofs ;)
11:40:52 <edwardk> exactly =)
11:40:56 <kmc> pro tip: if you have an unjustified algebraic step, put it across a page break
11:41:05 <kmc> ;)
11:41:07 <edwardk> hahaha
11:41:36 <edwardk> my usual approach was to just beat my head against it for the next day and a half until i went to the professor and he pointed out the problem with the question
11:41:56 <edwardk> i clearly was going about it all wrong
11:43:16 <Saizan> we should just wait for memristors to solve all this puny problems
11:49:14 <roconnor> we have infinite memristors?
11:49:35 <roconnor> ugh, soon linear time algorithms will be too slow
11:50:46 <jmcarthur> they are already too slow
11:50:55 <jmcarthur> (depends what you're talking about)
11:51:44 <EvanR-work> log time is too slow
11:51:55 <djahandarie> Meristor? Isn't that an electrical circuit type thing?
11:51:56 <EvanR-work> n log n is unbearable
11:52:08 <roconnor> djahandarie: yes
11:52:11 <jmcarthur> n! is too fast
11:52:33 <jmcarthur> we need n!!!!!!!! time algorithms
11:52:36 <jmcarthur> anybody know of one?
11:52:56 <EvanR-work> the algorithm to compute your moms weight
11:52:59 <aristid> the ! conveys the speed.
11:53:07 <jmcarthur> aristid: ha!
11:53:16 <jmcarthur> see, i said "ha" really quickly
11:53:22 <philo> hi
11:53:35 <jmcarthur> hidyho
11:53:37 <aristid> jmcarthur: i suppose your response time is O(n!!!!!!)
11:53:43 <Ferdirand> hello
11:54:26 <EvanR-work> O(ackermann^m(n))
11:54:42 <Ferdirand> @type fmap . flip id
11:54:42 <lambdabot> forall b (f :: * -> *) a. (Functor f) => a -> f (a -> b) -> f b
11:54:46 <jmcarthur> EvanR-work: that would be a weird algorithm
11:54:51 <Ferdirand> is there a standard name for this ?
11:55:32 <jmcarthur> not that i know of
11:55:32 <djahandarie> Busy beaver numbers? :-)
11:55:41 <jmcarthur> besides  (($x)<$)
11:55:59 <philo> how mature is meta haskell ?
11:56:00 <jmcarthur> and that only when not doing point free
11:56:10 <jmcarthur> philo: what is meta haskell? template haskell?
11:56:26 <philo> template haskell yes
11:56:31 <jmcarthur> pretty mature
11:56:32 <philo> i thought the name was meta haskell
11:56:38 <jmcarthur> nope, template haskell
11:56:42 <lpsmith> meta-ocaml
11:56:45 <lpsmith> :)
11:56:51 <EvanR-work> meta^n haskell
11:56:51 <fryguybob> @oeis ackermann
11:56:52 <lambdabot>  a(n+1) = 2^a(n) with a(0) = 0. This is the Ackermann function A_3(n+1) as de...
11:56:52 <lambdabot>  [0,1,2,4,16,65536]
11:57:03 <lpsmith> well, there was a meta-ml,  too
11:57:34 <philo> yea i see now
11:57:36 <lpsmith> meta! haskell
11:57:37 <djahandarie> @oeis busy beaver
11:57:37 <lambdabot>  Busy Beaver sequence, or Rado's sigma function: maximum number of 1's that a...
11:57:38 <lambdabot>  [0,1,4,6,13]
11:58:03 <roconnor> is that really ackermann?
11:58:16 <philo> do  they continue to work on template haskell ?
11:58:32 <jmcarthur> philo: as far as i know, yes. a lot of packages depend on it
11:59:52 <djahandarie> Busy beaver goes something like [1,6,21,107,47176870, roconnor> djahandarie: yes
11:59:57 <djahandarie> Agh
12:00:04 <djahandarie> 8690333381690951
12:00:08 <djahandarie> Is what I meant to paste
12:00:12 <augur> the busy beaver algorithm includes roconnor as its 6th solution?! D:
12:00:30 <fryguybob> @oeis 1,6,21,107
12:00:30 <lambdabot>  Busy Beaver problem: maximal number of steps that an n-state Turing machine ...
12:00:30 <lambdabot>  [1,6,21,107]
12:00:50 <ziman> if i wanted something growing more rapidly than BB(x), i could take a relativized BB_n(x); but, is there a /conceptually/ more extreme function (i mean a named function with occurence in literature)?
12:01:04 <roconnor> djahandarie: it kinda feels like I could write a primitive recursive funciton to compute that.
12:01:24 <philo> why isnt haskell about to handle C++ as Foreign language ? is it difficult to implement ?
12:01:57 <djahandarie> roconnor, BB numbers are hard-as-hell to prove
12:02:11 <roconnor> djahandarie: I mean a(n+1) = 2^a(n)
12:03:22 <soupdragon> you can't implement BB on a turing machine can you?
12:04:21 <dons> philo: you can call C++ from Haskell. see e.g. qtHaskell
12:04:32 <djahandarie> I don't think so, because if you could then that could be used to make up the BB numbers themselves
12:04:41 <dons> philo: http://qthaskell.berlios.de/
12:04:48 <jmcarthur> dons: well, but you have to admit that it isn't the most fun thing to do in haskell
12:05:06 <dons> indeed.
12:05:16 <jvoorhis> dons: how do they implement that?
12:05:28 <dons> preprocessors to generate the C wrappers
12:05:38 <ziman> roconnor, if you fix one of the parameters of Ack(m,n), it might become primitive recursive, maybe? (opposed to Ack(n,n))
12:05:49 <roconnor> ziman: yes, that is true
12:05:54 <ziman> that one was Ack_3
12:05:55 <jmcarthur> actually... maybe i should look into stealing those preprocessors to use on other projects
12:05:58 <roconnor> oh!
12:06:04 <jvoorhis> ok, that makes sense, but it's not quite the same as calling C++
12:06:06 <c_wraith> soupdragon, if you could implement BB on a turing machine, you could solve the halting problem on a turing machine.  This leads to a contradiction.
12:06:11 <jmcarthur> they probably rely on the Qt conventions though, i bet
12:06:17 <roconnor> ziman: that is a retarded lookup result
12:06:37 <c_wraith> since BB is essentially the maximum time you need to run an algorithm to determine if it's going to terminate or not.
12:06:40 <roconnor> when I look up ackermann sequence I expect to get A(n,n)!
12:06:52 <jvoorhis> dons: for a moment i thought you were alluding to some new FFI symbol mangler :)
12:07:07 <roconnor> @oesis 1 3 7 61
12:07:07 <lambdabot>  Simplified Ackermann function (main diagonal)
12:07:07 <lambdabot>  [1,3,7,61]
12:07:09 <jvoorhis> and so on
12:07:23 <jmcarthur> woah, qthaskell has you pass () to functions that don't take arguments? WHY?
12:07:38 <roconnor> > 2^2^2^65536 - 3
12:07:43 <lambdabot>   mueval: ExitFailure 1
12:07:47 <roconnor> :(
12:07:50 <illissius> jmcarthur: because it's retarded
12:07:59 <illissius> i tried looking at the api docs once and it's indecipherable
12:08:06 <jmcarthur> tuples?!
12:08:07 <burp> http://en.wikipedia.org/wiki/Hyper_operator define that for haskell Integers :D
12:08:10 <jmcarthur> oh, i have a suspicion
12:08:23 <jmcarthur> it's probably because C++ supports overloading with different number of arguments
12:08:42 <jmcarthur> they probably used type classes to simulate that overloading for different argument types (made out of tuples)
12:09:00 <jmcarthur> *different number and different types
12:09:16 <illissius> jmcarthur: also, it's because qthaskell defines a separate type class, afaict, for every single case where the same method name is used in more than one class
12:09:24 <illissius> which is, again, retarded.
12:10:11 <roconnor> 2^2^2^65536 - 3 is really big
12:10:45 <Zao> s/3/2  is even bigger
12:11:10 <ziman> 2^2^2^65526 - 3 is not bigger :)
12:11:16 <roconnor> Zao: 2^2^2^65526 - 3 is definitely smaller
12:11:28 <Zao> \b3 then, pedants.
12:12:26 <gwern> eek
12:12:30 <gwern> look at all those haskell emails
12:12:43 <gwern> 18 over an hour
12:12:53 <Phyx-> wweee
12:12:56 <Phyx-> emails from Cafe
12:15:03 * clanehin does a haskell.org cheer
12:15:21 * Phyx- joins in
12:15:26 <Zao> Good thing it doesn't host any essential services.
12:20:30 <jmcarthur> illissius: it's not retarded. it's just a necessary part of a faithful binding to C++. arguably, C++ is retarded ;)
12:23:30 <monochrom> oh, haskell.org is back?
12:23:43 <monochrom> neato
12:23:51 --- mode: ChanServ set +o monochrom
12:23:53 <illissius> jmcarthur: depends on your definition of "faithful"
12:24:04 <illissius> qthaskell is, imo, faithful to the wrong aspects of it.
12:24:14 --- topic: set to '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by monochrom
12:24:21 <Zao> I wouldn't want to use Qt from anything but C++, personally.
12:24:22 --- mode: monochrom set -o monochrom
12:24:37 <Zao> I can't see the idioms mapping much well at all to languages with different impedance.
12:24:44 <illissius> (full disclosure: am currently tinkering with qt bindings myself, which may or may not suck less, which is assuming i get anywhere with them.)
12:25:32 <illissius> Zao: the ruby bindings are pretty nice; don't really know any other language well enough to judge :-)
12:25:55 <jmcarthur> Zao: my coworker is using the python qt bindings and says it's... okay
12:26:05 <jmcarthur> he's used the C++ interface a lot more
12:28:18 <aristid> jmcarthur: isn't something like gtk2hs and qthaskell extremely low-level anyways?
12:28:41 <danharaj_> 'extremely'
12:28:42 <aristid> perhaps naive, but i'd expect it to be wrapped in something a lot more abstract
12:29:07 <danharaj> If you want extremely low-level, look at the win32 api >_<
12:29:17 <aristid> danharaj: no, thanks :P
12:29:20 <Twey> burp: There's even an implementation on the page.
12:31:19 <Twey> burp: h 0 _ b = b + 1; h 1 a 0 = a; h 2 _ 0 = 0; h ((>= 3) -> True) _ 0 = 1; h n a b = h (n - 1) a (h n a (b - 1))
12:32:07 <aristid> danharaj: you don't think haskell developers want something more high-level than qt?
12:32:11 <burp> oh yes, a recursive definition
12:32:13 <jmcarthur> aristid: yes, but writing a proper functional wrapper is a pain
12:32:23 <jmcarthur> aristid: i very much want something higher level
12:32:35 <BMeph> burp: You were expecting a for loop? ;)
12:32:42 <burp> BMeph: nope :>
12:32:50 <aristid> jmcarthur: just ask on stackoverflow and edwardk1 might write it :D
12:33:06 <Cale_> burp: What function is that? (Just got here)
12:33:15 <burp> Cale_: http://en.wikipedia.org/wiki/Hyper_operator
12:33:17 <Twey> Cale_: The hyper operator
12:33:17 <danharaj> aristid: I want something higher level than gtk/qt/wx, but that is hard.
12:33:27 <roconnor> GuiTV!
12:33:39 <Cale_> Ah, I see.
12:33:54 <aristid> danharaj: if i understand it correctly, some people think arrows is what guis should be based on
12:34:00 <danharaj> ew no god\
12:34:15 * danharaj vomits everywhere. Every. Where.
12:34:38 <roconnor> danharaj: that's what Conor did when he read scrap your boilerplate
12:34:40 * soupdragon joins in
12:34:46 <Twey> Haha
12:34:59 <Twey> It's not very useful to say that an interface is based on arrows, I think more useful to talk about the operations the arrow methods implement
12:35:07 <sproingie> i think theres as much hope for a single higher level abstraction for guis as there is for a single workflow for them
12:35:23 <roconnor> GuiTV!
12:35:34 <Twey> Eros looks cool
12:35:35 <sproingie> mm yeah i dont need continuous values
12:35:56 <sproingie> gimme discrete events any day
12:36:20 <aristid> Twey: well i don't understand arrows yet, so if i know that a gui is based on it, i might put in more effort in learning them :D
12:36:37 <danharaj> sproingie: discrete events are a special case of continuous values
12:36:44 <roconnor> applicative functor + category ?= arrow?
12:36:49 <roconnor> er
12:36:50 <Cale_> I think continuous values make a lot of sense in things like games.
12:36:53 <roconnor> too many ?'s
12:36:57 <sclv> the discontinuous case :-)
12:37:12 <philo> <danharaj> sproingie: discrete events are a special case of continuous value ??
12:37:13 <sproingie> everything's a special case of atoms
12:37:17 <roconnor> danharaj: I think it is best to consider that statement false
12:37:29 <danharaj> why you be hating on step functions
12:37:33 <safiire> Is anyone aware of what's called the _environ bug on osx?  I have the haskell platform installed, and I am trying to create a audio unit plugin which links against some haskell code. libHSbase-4.2.0.0.a references the symbol _environ.  This symbol is found in crt1.o.  Since this is not an executable, but a library as all audio plugins are, the linker can never find this symbol because shared objects do not link against crt1.o.  Does 
12:37:33 <safiire> anyone know how I can get the linker to resolve this symbol, or not care that it is missing, short of compiling haskell from scratch and removing the function that references environ() from it?   On OSX nothing should call environ(), it is a bug in osx, but there is a work around where it should really call _NSGetEnviron().  Sorry this is sort of a long and detailed problem, but I am not sure quite what to do.  Any help would be appr
12:37:34 <safiire> ieciated.
12:37:39 * Cale_ hands sproingie a muon
12:37:42 <roconnor> danharaj: step functions are not computable
12:37:54 <sproingie> well if you take the original definition of atom
12:37:57 * sclv blinks
12:38:05 <danharaj> roconnor: that practically does not come up because your continuous signals are approximated discretely anyway.
12:38:11 <sproingie> Cale_: i dropped it can i have another?
12:38:29 <roconnor> danharaj: I still worry
12:38:31 <danharaj> roconnor: They are not computable because Real equality is not computable, but that doesn't stop us from using floats.
12:38:51 <roconnor> danharaj: in our hybrid systems work there were issues with flow moving backwards.
12:39:10 <roconnor> danharaj: we should stop using floats :D
12:39:19 <danharaj> roconnor: good luck with that religion :p
12:39:34 <roconnor> danharaj: I'm hoping it works out as well as purity has
12:39:45 <Heffalump> is the ICFP 2010 accepted papers list somewhere? I can see congratulations flying around the net but can't find the list
12:40:00 <Twey> aristid: There are a bunch of arrow-based GUI toolkits
12:40:08 <danharaj> Not until the bonds of von Neumann are cut and the promised one leads us to architectural valhalla.
12:40:18 <Twey> Hehe
12:40:19 <danharaj> Verily the reduceron is the way.
12:40:27 <ClaudiusMaximus> i had some problems in some physics model code with infinitely many discrete events occuring without time advancing...
12:40:28 <Twey> Amen, brother
12:40:42 <ClaudiusMaximus> so i just cheated and ignored simultaneous events..
12:40:49 <Saizan> safiire: i may try on #ghc or the ghc-users mailing list
12:40:51 * sclv would also like a gander at that list when it becomes available
12:40:58 <Saizan> safiire: s/i/you/
12:41:07 <safiire> Saizan : Ok, I may try that.
12:41:11 <danharaj> ClaudiusMaximus: Quantum field theorists do just as much shady business to make quantum physics work :p
12:41:25 <sclv> simultaneous is a tricky notion...
12:42:02 <aristid> "different times but unknown order" :)
12:43:09 <sclv> dt^2 == dt^2 == 0, but compare dt dt = undefined.
12:43:11 <sclv> so to speak
12:43:42 <roconnor> ClaudiusMaximus: that doesn't sound relativistic
12:44:09 <roconnor> ClaudiusMaximus: actualy, what is a QM event?
12:44:34 <ClaudiusMaximus> roconnor: it was a 2D Newtonian model of colliding circles, i've not done anything relativity/quantum
12:44:48 <roconnor> ah
12:45:32 <roconnor> well Newtonian mechanics isn't even close to computable
12:45:36 <roconnor> or even well defined
12:45:42 <Rafau> would like someone to look at my project in haskell from the studies?
12:46:35 <Rafau> someone who knows haskell and functional programming
12:47:32 <Rafau> this is my first contact with haskell ;]
12:49:05 <Eelis> has anyone used Happy's Generalized LR parser generator recently? i get irrefutable pattern failures on trivial grammar files..
12:50:37 <Eelis> i get the feeling GLR is bitrotting away
12:53:05 <aristid> @hoogle all
12:53:05 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
12:53:05 <lambdabot> Data.ByteString all :: (Word8 -> Bool) -> ByteString -> Bool
12:53:05 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
12:53:26 <aristid> @hoogle any
12:53:26 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
12:53:26 <lambdabot> Data.ByteString any :: (Word8 -> Bool) -> ByteString -> Bool
12:53:26 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
12:53:45 <aristid> @unpl all id
12:53:45 <lambdabot> all (\ a -> a)
12:54:06 <paper_cc> aristid: hum, "and"?
12:54:07 <Twey> Silly \b
12:54:09 <paper_cc> @ty and
12:54:10 <lambdabot> [Bool] -> Bool
12:54:11 <aristid> :t and
12:54:12 <lambdabot> [Bool] -> Bool
12:54:15 <aristid> paper_cc: thanks
12:54:22 <Twey> (\ xs -> all (\ a -> a) xs)
12:54:37 <sclv> Rafau: if you want a code review of something, post the relevant bit up on hpaste.org, and post a link to the channel.
12:54:40 <Twey> and = foldr (&&)
12:54:43 <sclv> odds are somebody will take a gander.
12:54:53 <paper_cc> @ty foldr (&&)
12:54:54 <lambdabot> Bool -> [Bool] -> Bool
12:54:59 <paper_cc> @ty foldr (&&) True
12:55:00 <lambdabot> [Bool] -> Bool
12:55:48 <aristid> :t or
12:55:49 <lambdabot> [Bool] -> Bool
12:56:59 <SColes> I'm trying to construct a map that has duplicate keys with a combining function but I can't seem to figure out how to build up a list of values.  Using : as my combining function gives me an infinite type error how should I be going about this?
12:58:30 <Botje> SColes: can you show code?
12:58:49 <dafis> SColes: (++) as combining function and wrap everything in []
12:59:19 <ClaudiusMaximus> :t Data.Map.insertWith
12:59:20 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
12:59:46 <ClaudiusMaximus> :t (:)
12:59:46 <lambdabot> forall a. a -> [a] -> [a]
13:00:14 <kmc> :t M.insertWith (++)
13:00:15 <lambdabot> forall a k. (Monoid a, Ord k) => k -> a -> M.Map k a -> M.Map k a
13:00:19 <newsham> roconnor: around?  I had a quick (off-topic) question.  Whats the relation between C-CoRN and mizar's formalized mathematics project?  same goal? slightly diff? competing?  complementary?
13:00:22 <Rafau> sclv: thanks, I'll do it later when I finish
13:00:52 <Botje> .. or that
13:01:57 <ClaudiusMaximus> a -> a -> a   won't unify with  a -> [a] -> [a]  unless   a = [a]   which isn't allowed because it is an infinite type (a = [[[[[[[[[[[[[[[[[[ ...)
13:03:16 <aristid> :t replicate
13:03:17 <lambdabot> forall a. Int -> a -> [a]
13:03:33 <aristid> :t replicateM
13:03:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
13:04:03 <aristid> @hoogle Int -> [a] -> [a]
13:04:03 <lambdabot> Prelude drop :: Int -> [a] -> [a]
13:04:03 <lambdabot> Prelude take :: Int -> [a] -> [a]
13:04:03 <lambdabot> Data.List drop :: Int -> [a] -> [a]
13:04:31 <aristid> @pl f n = take n . cycle
13:04:31 <lambdabot> f = (. cycle) . take
13:04:45 <aristid> hmm isn't there some better function for that?
13:04:49 <aristid> or wait
13:04:51 * hackagebot visual-graphrewrite 0.4.0.1 - Visualize the graph-rewrite steps of a Haskell program  http://hackage.haskell.org/package/visual-graphrewrite-0.4.0.1 (ZsoltDollenstein)
13:05:16 <aristid> @pl f n l = concat (replicate n l)
13:05:16 <lambdabot> f = (join .) . replicate
13:06:35 <SColes> dafis, doh, thanks :)
13:06:53 * hackagebot hlint 1.7.1 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.7.1 (NeilMitchell)
13:07:26 <dafis> SColes: no sweat :)
13:08:52 <Eelis> newsham: mizar's collection of articles is several orders of magnitude larger in scope and size.
13:09:19 <Eelis> newsham: mizar is based on set theory. Coq (and therefore C-CoRN) is based on type theory.
13:09:33 <Eelis> newsham: more questions are better asked in #coq, as this has little to do with Haskell
13:11:50 <aristid> @src replicateM
13:11:50 <lambdabot> replicateM n x = sequence (replicate n x)
13:12:10 <Twey> replicateM = fmap sequence . replicate
13:13:22 <aristid> @pl replicateM n x = sequence (replicate n x)
13:13:22 <lambdabot> replicateM = (sequence .) . replicate
13:13:48 <aristid> Twey: that fmap is in the (->) monad?
13:14:00 <Twey> Yes
13:14:09 <Twey> I dislike operator sections :
13:14:09 <djahandarie> Twey, you write your (f .) . g 's like that?
13:14:25 <Twey> (f .) . g is horribly visually confusing
13:14:36 <aristid> fmap f . g is confusing too:/
13:14:36 <djahandarie> I agree... not sure if fmap f . g is better though
13:14:55 <djahandarie> It looks nicer but is even harder to tell what is going on
13:15:46 <djahandarie> I like f .: g I guess
13:15:50 <Starfire> zipWith runs until the shorter list is exhausted, right? I don't suppose there's some clever way to run until the longer list is exhausted, supplying a default value for the other list when it's run out.
13:15:53 <djahandarie> Where .: = (.).(.)
13:16:06 <djahandarie> It's an extra thing to memorize but then once you learn it it's easy to understand what it does
13:16:30 <djahandarie> But since it's a single operator it's not hard to memorize and recognize
13:16:30 <danharaj> Starfire, append the constant infinite list of your default value to the shorter list?
13:16:31 <djahandarie> Dunno
13:16:32 <aristid> @ty \n l -> join (replicate n l)
13:16:32 <lambdabot> forall a. Int -> [a] -> [a]
13:16:35 <sclv> Starfire: nope. you can also write a zipWith that takes (a -> a -> a) and just lets the tail of the longer list stay unchanged
13:17:10 <Starfire> I just wrote a zipWithDefault :: a -> b -> (a -> b -> c) -> [a] -> [b] -> [c]
13:17:32 <Starfire> But it's 4 equations, and I was wondering if there might be a shorter way.
13:18:46 <kmc> http://therighttool.hammerprinciple.com/items/f/haskell ouch for F#
13:18:47 <soupdragon> zipWithDefault a b f as bs = zipWith f (as ++ repeat a) (bs ++ repeat b)
13:19:18 <Starfire> That will result in an infinite list, no?
13:20:32 <aristid> @src sequence
13:20:32 <lambdabot> sequence []     = return []
13:20:32 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:20:32 <lambdabot> --OR
13:20:32 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:20:46 <aristid> @pl \n l -> join (replicate n l)
13:20:47 <lambdabot> (join .) . replicate
13:21:08 <aristid> oh, i'm repeating myself, sorry.
13:21:50 <kmc> i think (f .) . g is readable but only because it's a specific pattern i recognize
13:22:02 <kmc> and maybe it's best to write code whose readability doesn't depend on hanging out on IRC all day
13:22:26 * Botje explained the pattern to a student and now understand is
13:22:27 <Botje> *it
13:22:58 <c_wraith> I really wish .. wasn't syntax, so I could just say f .. g = \x y -> f (g x y)
13:23:05 <mux> Botje: mm, can I explain that pattern to you then?
13:23:18 <EvanR-work> let (...) = (+) in 4 ... 3
13:23:23 <EvanR-work> > let (...) = (+) in 4 ... 3
13:23:24 <lambdabot>   7
13:23:26 <EvanR-work> cool
13:23:30 <Botje> mux: you just have to do the work of @pl :)
13:23:34 <c_wraith> works, but I really wish I could use the name ..
13:23:44 <mux> Botje: heh, yeah, I was just goofing around :-)
13:23:44 * jmcarthur prefers   (fmap.fmap) f g   or   fmap f . g   to   (f .) . g
13:24:07 <djahandarie> You can let (...) = (.).(.), which kind of makes sense
13:24:07 <Twey> Yeah
13:24:18 <danharaj> :t .
13:24:19 <lambdabot> parse error on input `.'
13:24:25 <danharaj> :t (.)
13:24:26 <EvanR-work> (f .) . g looks like a monster head
13:24:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:24:27 <aristid> :t (.).(.) join replicate
13:24:27 <djahandarie> But maybe that would be confused with ((f .) . ) . g
13:24:28 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a]'
13:24:28 <lambdabot>     Probable cause: `replicate' is applied to too many arguments
13:24:28 <lambdabot>     In the second argument of `(.)', namely `replicate'
13:24:48 <aristid> :t (.).(.)
13:24:49 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:24:53 <djahandarie> I just really don't like mixing fmap and . for the same purpose
13:24:59 <jmcarthur> ((f .) . ) . g    <-- fugly
13:25:05 <aristid> :t (Prelude..)Prelude..(Prelude..)
13:25:06 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:25:07 <djahandarie> jmcarthur, indeed, I'd never use that anywhere
13:25:11 <djahandarie> lmao aristid 
13:25:14 <jmcarthur> (fmap.fmap.fmap) f g
13:25:16 <burp> @let () = (.).(.)
13:25:16 <lambdabot>  <local>:18:1: lexical error (UTF-8 decoding error)
13:25:19 <burp> aw :(
13:25:20 <djahandarie> Haha
13:25:22 <aristid> :t ((.).(.)) join replicate
13:25:22 <lambdabot> forall a. Int -> [a] -> [a]
13:25:41 <aristid> or in conal's syntax: (result.result) join replicate
13:25:43 <burp> someone make lambdabot utf-8 capable
13:25:57 <djahandarie> burp, I think that'd involve moving it to 6.12
13:26:08 <aristid> i think secs can make code more readable \o/
13:26:10 <kmc> :t (,3)
13:26:10 <djahandarie> Not sure what it runs on atm
13:26:10 <lambdabot> parse error on input `3'
13:26:19 <jmcarthur> yeah secs are pretty nice
13:26:19 <kmc> @version
13:26:19 <lambdabot> lambdabot 4.2.2.1
13:26:19 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:26:37 <jmcarthur> i haven't fully drunk the koolade though
13:27:06 <kamatsu> @src take
13:27:06 <lambdabot> take n _      | n <= 0 =  []
13:27:06 <lambdabot> take _ []              =  []
13:27:06 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:27:56 <aristid> jmcarthur: you wouldn't go as far as deeparrows?
13:27:59 <pastorn> @pl (\x -> (x,x))
13:27:59 <lambdabot> join (,)
13:28:09 <pastorn> @type join
13:28:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:28:11 <aristid> my understanding of them is troubled by my lack of understanding arrows
13:29:31 <djahandarie> Arrows suddenly got really easy for me to understand once I looked at the function instance of them
13:30:06 <kmc> yeah, Arrow just generalizes "function-like" things
13:30:25 <kmc> from a -> b to (Arrow (~>)) => a ~> b
13:30:43 <djahandarie> Hell if I know what all the conveyor belt analogy stuff is
13:30:51 <aristid> djahandarie: i have trouble expanding my understanding beyong functions
13:30:54 <kmc> djahandarie, they're just like burritos
13:31:02 <aristid> but i haven't really tried hard so far
13:31:12 <aristid> kmc: warm and fluffy burritos
13:31:14 <danharaj> god dammit
13:31:17 <danharaj> now I want a burrito.
13:32:18 <oldsalt> hey guys, i have a problem: i cabal installed a package (hack-contrib to be precise) but i can neither import its modules in my app nor load them in ghci. any hints what i might be doing wrong?
13:32:39 <oldsalt> it's listed by ghc-pkg list
13:32:59 <kmc> anyway each Arrow (~>) has identities (a ~> a) for each a, and function-like composition (b ~> c) -> (a ~> b) -> (a ~> c)
13:33:06 <kmc> i.e., each Arrow is a Category
13:33:10 <djahandarie> aristid, if you really understand them for function its just a matter of plugging other stuff in
13:33:14 <djahandarie> functions*
13:33:28 <djahandarie> No more mind bending than that, I don't think
13:33:36 <aristid> djahandarie: i doubt i understand them for funcitons then
13:33:49 <aristid> djahandarie: i think i somehow need more than one instance of a typeclass to understand it
13:33:56 <aristid> Maybe and [] did the trick for Monads
13:34:01 <kmc> aristid, try (Kleisli m) then
13:34:04 <jmcarthur> aristid: do you at least "understand" Category?
13:34:09 <aristid> jmcarthur: no.
13:34:27 <kmc> data Kleisli m = Kleisli (a -> m b)
13:34:38 <jmcarthur> aristid: how about Monoid?
13:34:39 <djahandarie> Why does that have such a weird name
13:34:43 <aristid> jmcarthur: monoids are ftw
13:34:44 <kmc> instance (Monad m) => Category (Kleisli m) where
13:34:52 <kmc> djahandarie, because that's called the "Kleisli category" of a monad
13:34:53 <jmcarthur> aristid: Category is a fancy Monoid :)
13:34:58 <kmc> it's named after some guy, that's all
13:35:07 <kmc> a category is a "typed monoid"
13:35:09 <jmcarthur> aristid: it's just a Monoid where you can't mappend just anything
13:35:14 <djahandarie> kmc, I guess I should have been more specific... "why'd we inherit that weird name?"
13:35:22 <kmc> djahandarie, because Haskell always inherits the weird name
13:35:23 <jmcarthur> aristid: id is like mempty, and (.) is like mappend
13:35:29 <kmc> people complain when we do; people complain when we don't
13:35:42 <aristid> jmcarthur: but they are disparate?
13:35:46 <djahandarie> I think we should when the name isn't THAT weird
13:35:52 <aristid> jmcarthur: why doesn't it just use monoid then?
13:36:15 <kmc> every monoid is a category
13:36:38 <jmcarthur> aristid: a Category is like a Monoid except that they types can prevent you from composing just any pair of objects
13:36:41 <jmcarthur> *the types
13:37:02 <kmc> data MC m a b = MC m
13:37:08 <kmc> instance (Monoid m) => Category (MC m) where
13:37:15 <kmc> id = MC mempty
13:37:28 <kmc> (MC x) . (MC y) = MC (x `mappend` y)
13:37:43 <aristid> kmc: but not the other way round?
13:37:46 <kmc> aristid, right
13:37:50 <kmc> aristid, (->) is a category
13:37:56 <kmc> taking the Prelude definitions of id and (.)
13:38:03 <kmc> id :: a -> a
13:38:10 <kmc> (.) :: (b -> c) -> (a -> b) -> (a -> c)
13:38:14 <kmc> but if you had
13:38:20 <kmc> data AnyFunction = forall a b. AnyFunction (a -> b)
13:38:27 <kmc> you could not write a Monoid instance for it
13:38:37 <kmc> you can't compose just any two functions; their types have to match
13:38:41 <aristid> jmcarthur: wait, isn't Category like MonadPlus but with two non-class parameters instead of one?
13:38:47 <jmcarthur> you can make a Monoid from a Category if you fix the type parameters
13:38:51 <aristid> Monoid (m :: *)
13:38:57 <aristid> MonadPlus (m :: * -> *)
13:39:07 <aristid> Category (m :: * -> * -> *)
13:39:09 <jmcarthur> aristid: MonadPlus also shares the Monoid laws (in addition to something else, usually)
13:39:20 <jmcarthur> Alternative might be a better example than MonadPlus
13:39:23 <kmc> aristid, you're right about the kinds, but the progression might be misleading
13:39:26 <jmcarthur> since it has less baggage
13:39:31 <jkingkong> If I use a strict foldl with a function f say, and f depends on a function g that is *not* strict, will the foldl execute the g strictly?
13:39:38 <kmc> note that (.) :: (b ~> c) -> (a ~> b) -> (a ~> c)
13:39:42 <aristid> jmcarthur: Alternative is like MonadPlus without the Monad baggage?
13:39:49 <kmc> and not (a ~> b) -> (a ~> b) -> (a ~> b)
13:39:56 <kmc> as you might expect from MonadPlus
13:39:59 <aristid> somebody should make a big diagram with all these classes :D
13:40:02 <jmcarthur> aristid: yes
13:40:06 <kmc> isn't there one in Typeclassopedia
13:40:08 <jmcarthur> aha! h/o
13:40:15 <jmcarthur> i have a favorite
13:40:15 <aristid> @src Alternative
13:40:15 <lambdabot> class Applicative f => Alternative f where
13:40:15 <lambdabot>     empty :: f a
13:40:15 <lambdabot>     (<|>) :: f a -> f a -> f a
13:40:30 <aristid> but Alternative has Applicative baggage
13:40:32 <kmc> jkingkong, "execute" is not the right word; you probably want "evaluate"
13:40:36 <jmcarthur> aristid: http://just-bottom.blogspot.com/2010/04/programming-with-effects-story-so-far.html
13:40:36 <aristid> @src Applicative
13:40:36 <lambdabot> class Functor f => Applicative f where
13:40:36 <lambdabot>     pure  :: a -> f a
13:40:36 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:40:40 <kmc> and how exactly does f depend on g?
13:40:41 <djahandarie> Except Applicative is lighter than monad :-)
13:40:43 <jkingkong> kmc: yes evaluate
13:41:06 <jmcarthur> hmm, it doesn't relate category to monadplus and alternative and monoid, though
13:41:07 <djahandarie> That's a nice chart jmcarthur 
13:41:24 <Veinor> I think I'm going to write a brainfuck interpreter
13:41:24 <aristid> now what's the difference between Applicative and Monad
13:41:28 <jkingkong> kmc: f takes two arguments, then looks at the output of g applied to the two arguments, then does something
13:41:33 <aristid> everything getting more confusing by the minute :D
13:41:36 <kmc> "looks at" = "pattern-matches"?
13:41:48 <kmc> aristid, you know liftM2, liftM3, etc?
13:41:56 <aristid> kmc: yes
13:41:59 <kmc> aristid, Applicative is only as powerful as those, plus return
13:42:03 <jmcarthur> aristid: applicative doesn't give you a way to dynamically restructure the computation according to the contents of the functor
13:42:07 <kmc> in other words you can build a fixed pipeline of actions
13:42:14 <kmc> but you can't use the *result* of one action to choose the next action
13:42:16 <aristid> ah
13:42:19 <kmc> that ability is the essence of (>>=)
13:42:45 <aristid> kmc: and that lack of power makes it applicable to types that can't be monads
13:42:50 <kmc> with Parsec, Applicative gives you context-free grammars and Monad gives you context-sensitive
13:42:51 <kmc> aristid, right
13:43:03 <kmc> and every monad is an applicative functor
13:43:11 <kmc> and every Monad would be Applicative, except for historical baggage
13:43:12 * hackagebot clash 0.1.0.1 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.0.1 (ChristiaanBaaij)
13:43:18 <kmc> you can always say
13:43:21 <aristid> there's WrappedMonad
13:43:29 <kmc> instance Applicative M where { pure = return; (<*>) = ap }
13:43:51 <aristid> an example of something where it's Applicative but no Monad?
13:44:08 <kmc> ZipList i think?
13:44:28 <kmc> lists are Applicative in "two ways" but only Monad in one way
13:44:47 <kmc> > (,) <$> ZipList [2,3] <*> ZipList [4,7]
13:44:48 <lambdabot>   No instance for (GHC.Show.Show
13:44:48 <lambdabot>                     (Control.Applicative.Zip...
13:44:56 <kmc> > getZipList $ (,) <$> ZipList [2,3] <*> ZipList [4,7]
13:44:56 <lambdabot>   [(2,4),(3,7)]
13:44:59 <jmcarthur> yeah, ZipList is one example
13:45:29 <kmc> because there's only one reasonable way to write "join"
13:45:33 <kmc> and it contradicts the zipping
13:45:34 <kmc> i think
13:45:57 <jmcarthur> not strictly the case
13:46:08 <aavogt> @type transpose
13:46:09 <lambdabot> forall a. [[a]] -> [[a]]
13:46:10 <djahandarie> Maybe an interesting way to introduce Monads would be to introduce all the other stuff first
13:46:12 <jmcarthur> if you look only at infinite lists you can define a valid monad instance with those semantics
13:46:20 <kmc> djahandarie, that's what Typeclassopedia does
13:46:21 <djahandarie> That way it'd be a progression rather than a bunch of seemingly random rules
13:46:25 <kmc> cool jmcarthur
13:46:30 <aristid> > getZipList $ pure [1]
13:46:31 <lambdabot>   [[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1...
13:46:45 <djahandarie> kmc, that thing in the PDF? :P
13:46:49 <kmc> yes
13:47:05 <jmcarthur> kmc: join for infinite ziplists looks like taking the diagonal if you visualize the structure in 2D
13:47:19 <kmc> ok
13:47:34 <kmc> makes sense
13:47:52 <jmcarthur> it's just like  (Int -> (Int -> a)) -> (Int -> a)
13:48:01 <kmc> :O
13:48:03 <kmc> indeed
13:48:16 <jmcarthur> no coincidence :)
13:48:39 <jmcarthur> (actually, it's more like s/Int/Nat/, but ignore that)
13:48:46 <kmc> i was ignoring it ;)
13:49:40 <kmc> btw
13:50:00 <kmc> is there any data structure with "list-like" semantics but which stores evaluated elements in large array blocks?
13:50:15 <kmc> (!!) would still be O(n) asymptotic but you could divide out a constant factor of thousands
13:50:17 <jmcarthur> well, there's ByteString and Rope
13:50:22 <kmc> yeah, it'd be like Rope
13:50:26 <Veinor> I read that as ByteString and Rape
13:50:26 <kmc> or lazy BS
13:50:27 <kmc> but more general
13:50:29 <Veinor> D:
13:50:34 <jmcarthur> but they aren't polymorphic, yeah
13:50:49 <kmc> this could be infinite unlike Seq
13:50:54 <jmcarthur> i don't know of any
13:50:58 <kmc> and would not aspire to better asymptotic complexity
13:51:02 <jmcarthur> would be nice to have i think
13:51:16 <jmcarthur> [Vector a] or something?
13:51:30 <mreh> who's done drawing-combinators before? Do I mapM render to a list of (Image a)s?
13:51:31 <kmc> yeah
13:52:06 <Veinor> hm. how is substringing a rope logarithmic?
13:52:09 <jmcarthur> mreh: you could be able to mconcat them or something, shouldn't you?
13:52:47 <Veinor> oh wait, I see it now
13:52:50 <mreh> oh yeah
13:53:15 <kmc> http://hackage.haskell.org/packages/archive/fmlist/0.8/doc/html/Data-FMList.html cute
13:53:26 <kmc> cute example :)
13:53:39 <jmcarthur> heh
13:54:27 * fryguybob always snickers when he sees snoc.
13:55:04 * BMeph skittles when he sees cons... ;)
13:55:30 <benmachine> forM should've been called Mpam
13:56:16 <jmcarthur> it should have been called forLoopForStubbornImperativeProgrammers
13:56:31 <aristid> jmcarthur: you never use forM?
13:56:39 <c_wraith> isn't that what it's called?
13:56:59 <jmcarthur> aristid: i admit to having used it once, but then i saw a nice refactoring and even that disappeared
13:57:13 <aristid> jmcarthur: so mapM is your beast?
13:57:25 <jmcarthur> umm... in a manner of speaking maybe :)
13:58:12 <Peaker> forM is nice for imperative programming.. $ \i -> do ...
13:58:14 <jmcarthur> i kind of like traverse. i wish it had a shorter name though
13:58:24 <Peaker> it's as short as possible, 1 token :)
13:58:43 <jmcarthur> Peaker: for is shorter than forM ;)
13:58:51 <Peaker> jmcarthur: same same :)
13:58:55 <jmcarthur> :t Data.Traversable.for
13:58:56 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Data.Traversable.Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
13:59:00 <jmcarthur> it's also more general :)
13:59:48 <djahandarie> kmc, you know, for all the burrito stuff going around in the Haskell tutorials, I actually think that Typeclassopedia doesn't have enough metaphors.
13:59:54 <kmc> well
14:00:00 <kmc> get yr. metaphors elsewhere then
14:00:09 <kmc> there's no shortage
14:00:18 <BMeph> djahandarie: Meta-metaphors? ;p
14:00:31 <kmc> @quote explanation
14:00:31 <lambdabot> xerox says: * xerox gets sucked in a vortex of -fdisallow-overlapping-explanations
14:00:33 <kmc> @quote explanation
14:00:33 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
14:00:42 <jmcarthur> hmm... Traversable could be replaced with generalized Functor
14:00:50 <djahandarie> kmc, well sure, but it'd be nice for good one to be litered somewhere between all these definitions
14:01:05 <djahandarie> and lol @ that quote
14:01:25 <jmcarthur> class Category (~>) => Functor (~>) f where fmap :: (a ~> b) -> (f a ~> f b)
14:01:25 <kmc> djahandarie, i guess?
14:01:43 <jmcarthur> and the "traversable" instances would have Kleisli m as the category
14:01:52 <jmcarthur> where m is Applicative
14:01:57 <kmc> Cale wrote "Monads as containers" and "Monads as computation"
14:02:03 <jmcarthur> oh snap
14:02:04 <jmcarthur> i'm wrong
14:03:01 <jmcarthur> oh, wait, no, i was right. ignore me :)
14:03:17 * BMeph is enjoying the absinthe-like qualities of Cook's Data Abstraction paper...
14:03:26 <jmcarthur> i should have known i was right because i went through the same exercise with mapM specifically
14:03:34 <jmcarthur> previously
14:03:41 <Botje> BMeph: do you, like, lick the paper?
14:03:50 <jmcarthur> yum
14:04:25 <Botje> I guess oleg's papers are printed with lsd, then
14:06:36 <kmc> more like Datura
14:06:46 <BMeph> Botje: Interesting...but no. I print my papers at work, so I'm pretty sure they wouldn't appreciate psychedelic ink. Although it would explain how the Engineering group works... ;)
14:10:03 <jethr0> good evening haskell
14:10:10 <benmachine> good evening
14:10:11 <kmc> good morning jethr0
14:10:30 <BMeph> Good afternoon! ;)
14:10:31 <jethr0> I was wondering, is there a way to construct a map such that:
14:10:53 <jethr0> each possible key has a function affixed that will be evaluated on first map lookup?
14:11:04 <jethr0> i.e. an infinite map of thunks
14:11:07 <jethr0> or sth. like that?
14:11:57 <jethr0> or would you need state for this?
14:12:19 <Botje> jethr0: you can do it with arrays
14:12:21 <gwern> you are asking about memoization?
14:12:25 <Botje> but they're not infinite, obviously
14:12:28 <kmc> Data.Map is already lazy
14:12:31 <kmc> but not infinite
14:12:36 <jethr0> yes, basically i'm asking about memoization ;)
14:12:44 <kmc> look at data-memocombinators
14:13:21 <jethr0> good idea, why not look it up under its proper name ;). thx, kmc
14:14:42 <kmc> it uses clever tricks to push the mutation down into the lazy eval system itself
14:14:49 <kmc> since lazy eval is ultimately all about mutation
14:19:18 * BMeph is fascinated by how coyly people try to slip by a question that can be used to answer "teh Real Question"...and Fail. Every. Time.
14:20:04 <kmc> AB problem?
14:21:14 <soupdragon> yeah totally
14:21:14 <ddarius> It's clearly the DY problem.
14:22:20 <kmc> but there's always another step back
14:22:35 <kmc> until you get to "how do i maximize global utility?" or "how do i increase the amount of dopamine in my brain?"
14:22:49 <ddarius> Define "global utility"
14:22:50 <kmc> and i think these are both outside the scope of #haskell
14:23:08 <kmc> global utility is defined as the thing which it is morally right (tm) to maximize
14:23:34 <kmc> utilitarianism is not so much a moral philosophy as it is a way of being slightly more precise about what the problem of moral philosophy is
14:23:53 <ddarius> kmc: By moving the undefinedness around?
14:24:02 * benmachine tries and fails to find out what the AB problem is
14:24:16 <ddarius> benmachine: How to get great abs in less than a week !
14:24:24 <benmachine> :x
14:24:25 <kmc> by following 1 simple rule
14:24:43 <ddarius> that some mother found while doing the dishes
14:24:54 <benmachine> and google on DY just turns up calculus
14:24:55 <kmc> ddarius, i think it's not even moving undefinedness.  it's just the observation that, if we want to think rationally about morality, we'd better have a way to measure outcomes and decide which ones are best
14:25:14 <kmc> if you are a solipsist, your "global utility" function might be purely selfish
14:25:32 <ddarius> kmc: At least that would be defineable and coherent.
14:25:38 <kmc> sort of
14:25:44 <kmc> most people don't know what they want, let alone anyone else
14:26:10 <kmc> this is part of my problem with moral philosophy, i think it's ill-posed pending major advances in philosophy of mind and self
14:26:17 <ddarius> kmc: Yes, but a (time varying) partial order could conceivably be established.
14:26:29 <kmc> anyway let's just tile the universe with smiley faces and be done with it
14:26:34 <gwern> how does the quip go? 'consequentialism is the strange idea that good actions make the world a better place'?
14:26:36 <kmc> i said this at a party the other day and everyone left the room
14:26:52 <ddarius> kmc: I just don't believe that utility, as defined by economics, can coherently be made in a global function.
14:27:25 <kmc> right, the economists study some special cases that are more tractable
14:27:36 <ddarius> Like Pareto optimality and such ?
14:28:10 <c_wraith> Pareto optimality is a really bad special case.  It's hard to not be pareto optimal in the real world.
14:28:11 <benmachine> kmc: I wish I went to your parties
14:28:36 <kmc> i mean that they study utility as it relates to markets where people appear to act according to a transitive preference function on unbiased estimators of outcomes
14:28:53 <ddarius> c_wraith: Isn't essentially impossible to make a Pareto improvement even assuming we could evaluate what everyone thought?
14:29:01 <kmc> you can define the utility of something operationally, if you can make people buy and sell it "rationally" and let them set their own price
14:29:25 <kmc> for problems of individual vs. social choice, see Arrow's theorem
14:29:46 <ddarius> kmc: So, you are saying not even the special case coherently generalizes and the less special "moral" version is often meant to.
14:30:12 <kmc> i'm saying that what moral philosophers mean by utility is more general than what economists mean
14:30:20 <kmc> and so it's not a fair criticism that the economic idea won't generalize
14:30:24 <kmc> it just means there's more work to be done
14:30:42 <ddarius> kmc: Yes, but if the special case can't be extended how would the general case be extended?
14:30:42 <kmc> c_wraith, yeah
14:31:51 <kmc> it can be extended
14:32:31 <BMeph> So, is there an implementation of B-Trees in Haskell? I'm looking, but I don't see any...
14:33:26 <kmc> BMeph, i don't know of one.  what did you want to do, out of curiosity
14:34:26 <gwern> just use finger trees :)
14:35:02 <kmc> gaah can't find pages about the AB problem
14:35:05 <kmc> am i misremembering the name?
14:36:12 <Nola> why do people have such a hard time writing "real programs" in funtional programming languages?
14:36:17 <kmc> ah
14:36:22 <jav_> Hi there! I'm trying to cabalize my Haskell source code and I would like for one of my executables to end up in libexecdir... how do I achieve that?
14:36:23 <soupdragon> because they're trolling ?
14:36:24 <kmc> it's canonically "XY problem"
14:36:26 <kmc> Nola, i don't
14:36:33 <Nola> not you kmc
14:36:35 <Nola> Most people
14:36:37 <soupdragon> "durrrr LISP isn't used in the real world"
14:36:46 <kmc> Nola, because there's not much pressure to learn it in the first place
14:36:59 <gwern> my problem is that most programs I use already exist
14:37:00 <soupdragon> I think it's just people repeating what nonsense they have been told
14:37:17 <gwern> if cat or ls didn't exist, man, I could code up a storm in haskell
14:37:26 <kmc> @remember gwern my problem is that most programs I use already exist
14:37:26 <lambdabot> Done.
14:37:46 <kmc> @flush
14:37:46 <lambdabot> Not enough privileges
14:37:47 <kmc> :(
14:37:49 <gwern> @flish
14:37:54 <ddarius> gwern: How many of the programs you use don't exist?
14:37:57 <kmc> @vixen why don't you like me?
14:37:57 <lambdabot> because i don't see the need to
14:38:04 <kmc> ouch
14:38:04 <ddarius> Excellent answer.
14:38:06 <gwern> ddarius: very few
14:38:10 <kmc> @nixon respect
14:38:10 <lambdabot> I don't know anything that builds the will to win better than competitive sports.
14:38:14 <kmc> aww
14:38:20 <kmc> @. vixen nixon
14:38:20 <lambdabot> what if i don't?
14:38:21 <jesusabdullah> ouch lambdabot
14:38:23 <ddarius> I don't think @nixon takes any input.
14:38:23 <kmc> @. vixen nixon
14:38:23 <lambdabot> let me answer that later, okay?
14:38:28 <jesusabdullah> very ouch
14:38:46 <kmc> @remember lambdabot <kmc> @vixen why don't you like me? <lambdabot> because i don't see the need to
14:38:46 <lambdabot> Okay.
14:39:00 <EvanR-work> whats the command to see if haskell can do something
14:39:21 <kmc> @faq Can Haskell give a smug, one-line answer to a question about Haskell's capabilities?
14:39:21 <lambdabot> The answer is: Yes! Haskell can do that.
14:39:28 <jesusabdullah> > 1+1
14:39:29 <lambdabot>   2
14:39:29 <jesusabdullah> ?
14:40:11 <kmc> @protontorpedo
14:40:11 <lambdabot> is there an oo db in haskell?
14:40:11 <benmachine> gwern: re-write stuff in haskell!
14:40:14 <benmachine> do it Right This Time
14:40:16 <kmc> @protontorpedo
14:40:16 <lambdabot> I dont think tcl cn do that
14:40:20 <jesusabdullah> map (-1) [1,2,3,4,5]
14:40:25 <jesusabdullah> > map (-1) [1,2,3,4,5]
14:40:26 <lambdabot>   [-1,-1,-1,-1,-1]
14:40:30 <ddarius> Indeed.  Reright everything.
14:40:30 <kmc> :O
14:40:31 <jesusabdullah> damn!
14:40:39 <kmc> > map (subtract 1) [1..5]
14:40:40 <lambdabot>   [0,1,2,3,4]
14:40:44 <kmc> jesusabdullah, usually that'd be a type error
14:40:52 <kmc> lambdabot has some craaaazy instances loaded
14:40:59 <hpc> :t subtract 1
14:41:00 <lambdabot> forall t. (Num t) => t -> t
14:41:08 <kmc> > 2 3
14:41:09 <jesusabdullah> That's "negative 1" not "subtract 1" huh?
14:41:09 <lambdabot>   Ambiguous type variable `t' in the constraint:
14:41:09 <lambdabot>    `GHC.Num.Num t' arising f...
14:41:15 <kmc> > 2 (3 :: Int)
14:41:16 <lambdabot>   2
14:41:21 <kmc> jesusabdullah, yeah, a wart in the syntax
14:41:32 <davidL> does anyone know the student conference fee for ICFP this year or is it generally the same every year?
14:41:40 <jesusabdullah> oh snap
14:41:41 <kmc> instance (Num a) => Num (b -> a) where what the fuck?
14:41:53 <benmachine> > map (negate 1) [1,2,3,4,5]
14:41:54 <lambdabot>   [-1,-1,-1,-1,-1]
14:42:07 <jesusabdullah> heh
14:42:13 <benmachine> kmc: vector-space I think?
14:42:15 * ddarius foresees some entertaining errors at the nexus of unary negation and numbers as functions.
14:42:20 <jesusabdullah> > map negate [1..5]
14:42:20 <hpc> >map (const fix) [4..]
14:42:21 <lambdabot>   [-1,-2,-3,-4,-5]
14:42:22 <gwern> oy gevalt: http://lesswrong.com/lw/2ab/harry_potter_and_the_methods_of_rationality/24d6?context=3
14:42:23 <jesusabdullah> yaay
14:42:35 <kmc> what i do know is that the first-place prize for the ICFP contest is a cool $1k
14:42:35 <hpc> > map (const fix) [4..]
14:42:36 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a)
14:42:36 <lambdabot>    arising from a u...
14:42:45 * jesusabdullah is easily amused by silly examples
14:42:50 <wli> where f + g = \x -> f x + g x ; f * g = \x -> f x * g x etc.
14:42:53 <gwern> kmc: I wonder how much a 1st place ICFP is worth on the ol resume
14:43:13 <kmc> which is a lot more than the previous years' prizes of "someone will say something nice about you on the Internet"
14:43:20 <hpc> > (+ * -) 4
14:43:21 <lambdabot>   <no location info>: parse error on input `*'
14:43:37 <hpc> > ((+) * (-)) 4
14:43:38 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:43:38 <lambdabot>    arising from a use of `...
14:43:45 <hpc> > ((+) * (-)) 4 3
14:43:45 <lambdabot>   7
14:43:50 <jesusabdullah> > (+).(*).negate 4
14:43:50 <hpc> haha
14:43:51 <lambdabot>   No instance for (GHC.Show.Show (f ((a -> a) -> a -> a)))
14:43:51 <lambdabot>    arising from a ...
14:44:07 <kmc> "morewrong.com is already taken" :(
14:44:11 <jesusabdullah> > (+1).(* 2).negate 4
14:44:12 <lambdabot>   No instance for (GHC.Num.Num (f a))
14:44:12 <lambdabot>    arising from a use of `e_1124' at <i...
14:44:14 <jesusabdullah> heh
14:44:17 <jesusabdullah> should probably stop
14:44:26 <kmc> jesusabdullah, you can PM lambdabot too
14:45:54 <jesusabdullah> kmc: Thanks, I forgot >_<
14:46:19 <mreh> so I have to open my own openGL window with drawingcombinators?
14:47:09 <Peaker> I had some trouble with DrawingCombinators: No cropping, and the text-rendering lib doesn't do a good job at AA, apparently
14:47:19 <ddarius> Atlas's machinery's eke Bridger's
14:48:58 <mreh> Peaker, it semantics of Image is an infinite 2D array of pixels, might have something to do with it
14:49:08 <mreh> don't know if you can mask
14:49:10 <Peaker> mreh: That shouldn't be a problem
14:49:16 <Peaker> mreh: The semantics definitely allow cropping/masking
14:49:43 <illissius> <jmcarthur> hmm... Traversable could be replaced with generalized Functor <jmcarthur> class Category (~>) => Functor (~>) f where fmap :: (a ~> b) -> (f a ~> f b) <jmcarthur> and the "traversable" instances would have Kleisli m as the category <jmcarthur> where m is Applicative
14:49:46 <illissius> oh dear
14:50:01 <illissius> if I ever manage to understand that, will it be safe to say that I know a little bit about category theory?
14:50:05 <mreh> I'd image you zip the pixels with the and operator with your mask
14:50:35 <Peaker> mreh: or you could just have a "crop" function whose semantics is masking with a square or some such
14:50:47 <ddarius> illissius: A very little bit.
14:50:53 <Peaker> mreh: You could implement whatever operation is implementable well with OpenGL
14:50:55 <mreh> Peaker: of course, abstraction
14:51:13 <ddarius> illissius: You'd know more about certain Haskell abstractions.
14:51:37 <kmc> illissius, "category theory" is a vocabulary for discussing various domains in a uniform way
14:51:51 <kmc> in this case Haskell
14:51:58 <ddarius> kmc: Category theory is more than just a "common language."
14:52:05 <kmc> so that statement is about Haskell but "in" CT, in the same way it's in English
14:52:19 <ddarius> It's not "in CT" at all.
14:52:49 <kmc> functors and kleisli category of a monad?
14:53:08 <kmc> i agree that CT has some results but they rarely seem to come up in discussion of Haskell
14:53:19 * edwardk1 just realized he has been misreading the PVP this entire time.
14:53:31 <edwardk1> kmc: oh? =-)
14:53:58 <kmc> i've been meaning to ask you what the hell a right Kan extension is edwardk1 ;)
14:54:07 <ddarius> kmc: I am confident that most categorists would not be able to make much sense of what jmcarthur said.
14:54:25 <kmc> nor would most English speakers
14:54:34 <ddarius> kmc: Well, if you have enough of them, the right Kan extension making functor is the right adjoint to precomposition.
14:54:47 <kmc> hrm
14:54:56 <edwardk1> kmc: http://comonad.com/reader/2008/kan-extensions/
14:55:09 <edwardk1> http://comonad.com/reader/2008/kan-extensions-ii/
14:55:15 <kmc> kaaaaan!
14:55:16 <edwardk1> http://comonad.com/reader/2008/kan-extension-iii/
14:55:20 <kmc> thanks
14:55:27 <soupdragon> lol
14:55:54 <edwardk1> kmc: and http://hackage.haskell.org/package/monad-ran for when you're done with that and the category-extras bits on the topic ;)
14:56:06 <kmc> yeah, that's where i ran into them
14:57:04 * edwardk1 wonders if he could be replaced with a bot that just links to his blog in response to the first occurence of a keyword in a given day. ;)
14:57:53 * hackagebot ad 0.30.0 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.30.0 (EdwardKmett)
14:58:07 <ddarius> Great googly moogly.
14:58:38 <ddarius> kmc: You can completely understand what jmcarthur is talking about without knowing any category theory, whereas knowing category theory (and Haskell) would help you little or not at all without being familiar with the libraries he refers to.
14:58:45 <edwardk1> kmc: i find that it is easier to get your head around right kan extensions via first understanding Yoneda and Codensity, and their left Kan extension kin via the contravariant yoneda lemma and density.
14:59:06 <kmc> ddarius, agreed
14:59:28 <ddarius> edwardk1's Kan extensions are a very special case.
14:59:39 <edwardk1> yeah
15:00:04 * ezyang still thinks it sounds like a martial arts move 
15:00:05 <kmc> is edwardk1 the version of edwardk that only works on non-empty lists?
15:00:14 <edwardk1> mine are just ways to put together functors that come to and from Hask. there are of course other categories that are worth using
15:00:16 <edwardk1> yeah
15:00:19 <edwardk1> well
15:00:26 <edwardk1> actually I'm the edwardk of kind * -> *
15:00:33 <kmc> ah right
15:00:35 <kmc> :t typeOf1
15:00:36 <lambdabot> forall (t :: * -> *) a. (Typeable1 t) => t a -> TypeRep
15:00:41 <edwardk1> exactly
15:01:24 <edwardk1> kmc: i'm fond of lifting things one kind up: http://hackage.haskell.org/packages/archive/ad/0.28/doc/html/Numeric-AD-Internal-Classes.html#t%3ALifted
15:01:25 <ddarius> I would say most uses of Kan extensions significantly rely on choosing "interesting" source categories.
15:01:28 <fryguybob> edwardk1: Working on "Write your self an Automatic Differentiation in 48 hours" I see.
15:01:47 <ddarius> More like 72 hours with no sleep.
15:01:53 <edwardk1> that too
15:02:13 <edwardk1> a dirty little secret is that if you look at the release schedule for category-extras it came together the same way
15:02:22 <fryguybob> once the tutorial is written it will take readers 48 hours though.
15:02:36 * edwardk1 just realized how many more modules are in the new ad package
15:02:46 <edwardk1> maybe i went a little nuts this morning
15:02:47 <ddarius> edwardk1: So you must have gone to sleep yesterday at earliest about five in the morning.  When do you get to work?
15:03:00 <edwardk1> ~8 in the morning
15:03:19 <edwardk1> i usually get by on about 3 hours worth of sleep. by now my body is used to it
15:03:51 <kmc> impressive
15:03:57 <jesusabdullah> Horrifying
15:04:10 <ddarius> I guess that's not too different from me not counting weekends.
15:04:10 * kmc could do that when 16 years old but no longer
15:04:25 <edwardk1> i also do most of my best coding when completely strung out tired because i stop overthinking things ;)
15:04:31 <kmc> haha
15:04:45 <ddarius> I do my best coding when the leprechauns assist me.
15:04:55 <edwardk1> ddarius: you might like: http://hackage.haskell.org/packages/archive/ad/0.28/doc/html/Numeric-AD-Tensors.html. i'm rather pleased with how the Tensors type turned out.
15:05:29 <edwardk1> though i do think it was prettier when it was data f :- a = a :- (f :- f a)
15:05:57 <mauke> a :-( f :-( f a))
15:06:12 <jmcarthur> edwardk1: i've been thinking about lifting my abstract algebra like that, too
15:06:36 <jmcarthur> edwardk1: not sure about naming conventions though
15:06:37 <edwardk1> mauke heh unhappy?
15:06:54 <ddarius> Incidentally, haskell.org was down because it was busy churning out documentation for the ad package.
15:07:00 <jmcarthur> lol
15:07:02 <edwardk1> lol
15:07:22 <edwardk1> actually it _does_ take a bit of time to generate the haddock ;)
15:07:26 <edwardk1> i blame the template haskell
15:07:26 <jmcarthur> except that hackage is an entirely different server, that's funny ;)
15:07:56 <ddarius> Does the Hackage haddock generation get the TH instances?  And if so, does that mean it executes the TH?  And if so...
15:08:09 <edwardk1> ddarius: apparently the answer is now a yes
15:08:23 <edwardk1> ddarius: color me pleasantly surprised
15:09:02 <ddarius> instance $(readFile "/etc/passwd") where {}
15:09:07 <edwardk1> =)
15:09:07 <kmc> doesn't Haddock have an entirely unreasonable level of integration with GHC API?
15:09:29 <edwardk1> ddarius: you forgot the check to see if you're running as root during the cabal install ;)
15:09:45 <kmc> there was some cabal bug where running haddock would clobber your .o files
15:10:17 * dcoutts_ thinks that it was a haddock bug
15:10:28 <dcoutts_> though one workaround is in cabal
15:10:36 <edwardk1> jmcarthur: what kinds of things are you looking at type operators for?
15:11:28 <dcoutts_> ddarius: compiling (or using haddock) is not safe from a security pov, and it's not just TH you have to worry about
15:12:28 <dcoutts_> ddarius: note that the hackage builder uses a sandbox for exactly this reason
15:12:58 <kmc> what else is unsafe?
15:13:00 <kmc> preprocessors?
15:13:37 <jmcarthur> edwardk1: i'm just interested in exploring other things to lift, similar to how Alternative is a lifted Monoid
15:14:07 <jmcarthur> really Alternative has an extra requirement too, of course. i wish we had a Functor version instead of requiring Applicative
15:14:29 <ddarius> edwardk1: Nested data type.  That is nice.
15:14:46 <dcoutts_> kmc: yes, preprocessors, Setup.hs scripts
15:15:01 <edwardk1> ddarius: I was very pleased that the 'tensors' function was able to be built.
15:15:20 <edwardk1> ddarius: that lets me generate a cofree comonad, which i'm very comfortable with, and spit out the tensors if i need to.
15:15:24 <dcoutts_> kmc: probably one can convince ghc to do unpleasent things on your behalf with suitable command line flags
15:16:17 <ddarius> edwardk1: You /define/ the classes Copointed and Comonad there?
15:16:35 <edwardk1> a : - f da :- f (f dda) :- f (f (f ddda)) :- ...  and it then directly models the tower of tensors for higher gradients
15:16:47 <edwardk1> ddarius: i haven't yet split off a comonads package from category-extras
15:17:02 <ddarius> We really need a widely-accepted one.
15:17:05 <edwardk1> yeah
15:17:15 <edwardk1> its more or less the next item on my plate
15:17:52 <ddarius> Control.Comonad is going to be nicer than Control.Monad (?)
15:18:17 <ddarius> No need to (re)define the (co)free (co)monad.
15:18:18 <edwardk1> i plan to break out a package of functors and one of comonads, and one of monads from category-extras and then build -extras versions of each that use the mutual dependencies
15:19:16 <edwardk1> so the cofree comonad in comonads will be the basic one, and then the comonad-extras version will have a cofree comonad based on the bifunctor fixpoint that is the current category-extras version
15:19:41 <ddarius> Yeah.  The comonad package should be very basic/straightforward code.  Not craziness.
15:19:45 <edwardk1> since you only really need ot for the Control.Morphisms machinery
15:20:00 <edwardk1> the problem folks have with category-extras is it is a mixture of mundane and er.. insane
15:20:01 <jmcarthur> :)
15:20:34 <edwardk1> this way i can have a small core set of packages that people can use and get progressively more esoteric as the dependencies build
15:20:52 * ddarius wonders if there is a good way to do adjunctions that doesn't fall into craziness.
15:21:01 <ddarius> but is still useful
15:21:09 <djahandarie> Okay, I have to say I lold pretty hard when I read this convo in here http://codepad.org/ZoZNGTa2
15:21:41 <edwardk1> heh
15:22:01 <edwardk1> benmachine: you ever figure out the AB problem?
15:22:08 <benmachine> blarg
15:22:14 <benmachine> I stopped paying attention
15:22:24 <edwardk1> did you mean the http://en.wikipedia.org/wiki/ABA_problem ?
15:22:44 <kmc> no
15:22:48 <kmc> i meant the XY problem it turns out
15:23:02 <ddarius> As opposed to http://en.wikipedia.org/wiki/ABBA_problem
15:23:16 <kmc> my description was alpha-equivalent but that's not good enough for google apparently
15:23:20 <benmachine> heh
15:23:22 <edwardk1> kmc: =)
15:23:32 <kmc> "Did you mean: a different thing by every word you used"
15:23:40 <djahandarie> Heh
15:23:50 <benmachine> ah, neat
15:23:57 <edwardk1> alpha equivalent search is the next big thing
15:24:11 <kmc> search engines are categories
15:24:17 <ddarius> FreshML to the rescue
15:24:21 <kmc> probably
15:24:43 <benmachine> I don't like to accuse people of the XY problem though
15:24:59 <benmachine> I mean you can't always know how much explanation is necessary
15:25:10 <benmachine> I guess it's a useful concept to have though
15:25:20 <kmc> benmachine, right, hence the long discussion of moral philosophy that ensued
15:25:29 <edwardk1> My wife accuses me of the XY problem. I accuse her of the XX problem. Somehow, we still get by.
15:25:32 <kmc> haha
15:25:49 <ddarius> benmachine: You don't have to accuse anyone.  Simply ask "What is your actual problem?"
15:25:56 <kmc> the error in the XY problem is not of providing too little explanation, so much as making wrong guesses
15:26:13 <ddarius> or "What are you actually working on/actually trying to do/ultimately trying to do?"
15:26:14 * edwardk1 learns a lot pursuing XY problems though ;)
15:26:20 <roconnor> newsham: competing, but C-CoRN has a smaller scope.
15:26:20 <yitz> kmc: no, they're functors.
15:26:26 <benmachine> ddarius: mm, I suppose so
15:26:30 <BMeph> kmc: Sorry about the one-hour-later reply, but...I "want" to have an implementation of a B-tree to play with. That is "Really" what I'm looking for. If you (or no one else) has one in Hackage, I'll look to code one myself. :)
15:26:39 <benmachine> but then you can also have the thing that used to drive me up the wall in #python
15:26:48 <benmachine> when people would come on and ask "how do I do this"
15:26:53 <benmachine> and the response would be "you don't want to do that"
15:27:00 <newsham> roconnor: eelis gave me the rundown
15:27:01 <kmc> and the response is "you're an idiot, die in a fire"
15:27:04 <benmachine> :D
15:27:05 <benmachine> that too
15:27:11 <kmc> benmachine, i had that experience too
15:27:31 <kmc> thing is, i'm asking about something strange because i have reasons for dismissing the obvious solutions
15:27:44 <benmachine> "we substituted your question with our own, and answered that instead"
15:27:53 <kmc> i do that here
15:28:15 <benmachine> well, you do it with charisma :P
15:28:24 <hpc> my favorite is when the asker goes "i substituted your solution with my own, and it still doesn't work"
15:28:26 <benmachine> so you are excused
15:28:29 <benmachine> hpc: lol
15:28:31 <ddarius> hpc: Heh.
15:30:53 <ddarius> benmachine: Anyway.  Judgement is required.  Errors will be made.  People shouldn't be whiny bitches.
15:31:15 <ddarius> Tomorrow I will solve world peace.  A problem that has plagued us for millenia.
15:31:45 <edwardk1> kmc: it usually comes up here in the form: How do I get an Int out of this annoying IO Int? 
15:31:51 <kmc> hehe edwardk1
15:32:11 <hpc> > liftEdwardk1
15:32:12 <lambdabot>   Not in scope: `liftEdwardk1'
15:32:17 * benmachine hugs ddarius 
15:32:21 <ddarius> "unsafeCoerce: cuz it's what you'd do in C."
15:32:43 <medfly> hey
15:33:53 <Peaker> unsafeCoerce: Crashing like it's 1970
15:34:21 <BMeph> BTW, I call that substituted answer thing a "Folger's Gambit". :)
15:34:45 <BMeph> ...which likely shows my age...good! :)
15:35:35 <benmachine> YX Problem: You explain that you want to do X and instead of an answer you're asked "Why would you want to do X?"
15:35:38 * benmachine giggles
15:36:48 <ddarius> Better than "You explain that you want to do X and instead of an answer you're asked 'Why would you want to do Y?'"
15:36:57 <djahandarie> Heh true
15:37:38 <ddarius> "What?!  I don't.  I don't want to do Y."  "Just as I thought."
15:39:03 <ksf> "I want to do this in PHP" "Why would you want to sodomize yourself with a retractable baton?"
15:39:08 <ksf> sounds logical to me.
15:39:28 <wlangstroth> ksf: except those really are the same
15:40:35 <wlangstroth> ksf: sorry, still reeling from the pain of a "please-fix-this" job
15:40:54 <ksf> nono you're right.
15:41:13 * BMeph always considered using PHP as sodmizing with a remote-controlled extendable baton, whose controls are announced to the Internet...
15:41:22 <dmwit> haha, from my browsing (starting at "XY problem"): "The reason I don't answer more questions is because so many of them are so damn stupid."
15:41:23 <ksf> "I want to do this in PHP" "Why would you want to do that in Haskell?" is the thing.
15:41:23 <medfly> why?
15:41:29 <medfly> PHP isn't so bad.
15:41:47 <hpc> medfly: yes it is; i would rather code in perl than php
15:41:52 <ksf> you mean it's better than brainfuck?
15:41:57 <wlangstroth> medfly: Drupal
15:41:57 <medfly> sure, it's not awesome, but you can work with it.
15:42:13 <hpc> yeah, you can also work with INTERCAL, not that you should
15:42:25 <ddarius> What's wrong with INTERCAL?
15:42:30 <ksf> medfly, sure, and there are people who orgasm on retractable batons.
15:42:34 <ksf> (no offense meant)
15:42:38 <medfly> :)
15:43:13 <medfly> it must be that I'm so desperate that if someone asked me to work I wouldn't be like "but not in like, PHP or something, right?", but hop on it straight away.
15:43:15 <BMeph> Personally, I don't have a problem with Brainfuck. Of course 1) I programed in C on a PDP-11 in my "formative years"; 2) I like FORTH. So...yeah. :)
15:43:29 <ksf> let's rework that to "sodomize yourself with a ship mast wrapped with red-glowing barbed wire"
15:43:43 <kmc> yikes
15:43:46 <medfly> red-glowing barbed wire?
15:43:57 <wlangstroth> I don't even want to know how fast you came up with that
15:44:00 <benmachine> presumably glowing with heat
15:44:02 <Twey> Heheh
15:44:04 <ddarius> BMeph: Brainfuck isn't bad.  It's just tedious.  Nothing wrong with FORTH either.
15:44:08 <Twey> BMeph: FORTH is awesome.
15:44:14 <Twey> But Brainfuck has no abstraction.  :
15:44:15 <ksf> it was'nt me.
15:44:25 <ksf> it's at least five years old, now.
15:44:28 <wli> C on a PDP-11? That's older school than me.
15:44:28 <aristid> when to use MonadPlus and when to use Alternative?
15:44:36 <wlangstroth> PHP is just roughly the opposite of fun, that's all
15:44:42 <medfly> hey wli, how are you doing?
15:45:01 <ksf> it was my former boss, who, asked the question 'now what should I do?' would look innocent and say, "I think you should take a ship mast, wrap..."
15:45:05 <benmachine> aristid: that's an odd question; surely you use whichever your datatypes are instances of?
15:45:26 <BMeph> I just consider BF as "if some C programmer ssaw FORTH and got all jealous, and decided to make C work as close to FORTH as possible, what would it be..." material.
15:45:28 <aristid> benmachine: [] and Maybe are instances of both
15:45:29 <benmachine> your former boss sounds like a delightful person
15:45:30 <wli> medfly: Badly.
15:45:32 <Twey> ksf: I think that's the question every manager dreads
15:45:36 <benmachine> aristid: yeah, so are... most things
15:45:36 <medfly> wli, I cannot resist reading your nick as "willy".
15:45:42 <benmachine> that are instances of either
15:45:43 <Twey> Hehe.
15:45:58 <Twey> Anything that is both Alternative and Monad is MonadPlus
15:45:59 <Twey> Er
15:46:01 <Twey> Yes
15:46:05 <Twey> That is what I meant to say
15:46:07 <ksf> he's enough of an acid head to stand above that.
15:46:07 <aristid> benmachine: let's take Data.Foldable.foldr (mplus . return) mzero
15:46:18 <benmachine> there are some laws in Alternative and MonadPlus but no-one can remember what they are
15:46:24 <medfly> wli, that sucks.
15:46:25 <aristid> should that rather use Alternative?
15:46:42 <benmachine> aristid: um, I think both are defined
15:46:53 <aristid> benmachine: i mean stylistically
15:46:53 <ddarius> benmachine: The MonadPlus laws are straightforward.  There are just two equally valid sets.  
15:46:53 <Twey> benmachine: MonadPlus is Alternative for monads.  We wouldn't have it if Applicative were a prerequisite for Monad, as it should be.
15:46:54 <benmachine> like, one's msum and the other's asum
15:47:02 <Twey> aristid: ^
15:47:17 <benmachine> Twey: there are MonadPlus laws that interact with >>= aren't there?
15:47:18 <BMeph> Free Willy! (Offer Good While Supplies Last...)
15:47:28 <Twey> aristid: I'd write the Alternative instance then define MonadPlus in terms of it, I think.
15:47:30 <aristid> Twey: so i should use Alternative in this case?
15:47:35 <benmachine> BMeph: I don't think I want to know what your supplier is
15:47:36 <ddarius> benmachine: I prefer the distributive version have the name MonadPlus and agree with Cale with having the abortive version be name MonadOrElse.
15:47:37 <aristid> no i mean for the funciton
15:47:42 <Twey> aristid: For convenience, it's probably best to have both
15:47:47 <Twey> (if your type is indeed a Monad)
15:47:50 <aristid> Data.Foldable.foldr (mplus . return) mzero
15:47:51 <gwern> you know, I was assuming BMeph was really old because he spoke of programming on PDP-11s, but after that last comment, I've decided he's young and just went to a really poor university
15:47:53 <Twey> benmachine: Don't think so
15:47:59 <Twey> Hey
15:48:03 <Twey> I did PDP-11 programming
15:48:05 <benmachine> Twey: most people forget them but they're there :P
15:48:09 <ddarius> mplus distributes over (>>=)
15:48:14 <Twey> And I haven't even been to university yet
15:48:32 <medfly> someone tell me what is PDP-11
15:48:35 <Twey> benmachine: But do they not apply to Alternative, too?
15:48:44 <Twey> medfly: It's an old system/OS
15:48:52 <medfly> okay, why did you program on it
15:48:57 <BMeph> gwern: Hey, I went to a very fine university, so don't blame my faults on it, thank you. :)
15:49:00 <ddarius> (m `mplus` n) >>= f = (m >>= f) `mplus` (n >>= f)
15:49:01 <wlangstroth> medfly: a lovely old machine the size of a large frige
15:49:02 <Twey> Wait
15:49:10 <Twey> Not an OS?  What am I thinking of?
15:49:12 <benmachine> ddarius: imo, MonadOrElse isn't really that useful
15:49:22 <Twey> Oh, POP-11.  Heh.
15:49:29 <gwern> Twey: I don't think PDP-11s came with OSs
15:49:33 <ddarius> benmachine: Why not?  Several MonadPlus instances would better be in that class.
15:49:35 <gwern> most computers of that vintage didn't
15:49:38 <Twey> Yeah
15:49:41 <BMeph> medfly: The PDP-11 is the computer, whose assembly language was the inspiration/model for C. :)
15:49:42 <Saizan> aristid: if you're making a function that's polymorphic over the applicative/monad used, and go with Alternative, since it's (in principle) more general
15:49:44 <aristid> so it is Data.Foldable.foldr ((<|>) . pure) empty [1,2,3]
15:49:50 <medfly> oh, it was?
15:49:50 <benmachine> ddarius: several? I believe the Maybe instance is identical, what else is there?
15:49:51 <Twey> There was a book on AI with POP-11 that was my first introduction to programming, before I ever touched an actual computer
15:50:03 <aristid> ignore the [1,2,39
15:50:14 <ddarius> benmachine: Either, IO, deterministic parsers
15:50:18 <benmachine> err, by identical I mean Maybe follows both at once
15:50:28 <benmachine> do parsers not follow both at once as well?
15:50:32 <benmachine> and IO is just weird
15:51:16 <aristid> IO is not in Alternative it seems
15:51:26 <benmachine> it's complicated to make it so
15:51:28 <benmachine> if possible
15:51:54 <Twey> Is it truly possible?  The side-effects
15:52:02 <benmachine> dunno
15:52:03 <benmachine> maybe?
15:52:26 <Twey> I mean, it's trivial to make it one, but you might end up with crazy output as the runtime tries the options
15:52:40 <benmachine> you might do
15:52:45 <aristid> benmachine: every MonadPlus is Alternative by virtue of WrappedMonad at least
15:53:07 <benmachine> aristid: hmm
15:53:52 <benmachine> it's not easy to search haskellwiki for alternative
15:53:55 <aristid> @pl WrapMonad u <|> WrapMonad v = WrapMonad (u `mplus` v)
15:53:55 <lambdabot> (line 1, column 29):
15:53:55 <lambdabot> unexpected "="
15:53:55 <lambdabot> expecting variable, "(", operator, "<|>", "&&", "***", "&&&" or end of input
15:54:26 <aristid> oh it's too difficult for poor @pl
15:54:59 <benmachine> is it even possible without the proper unwrappers?
15:55:11 <aristid> @pl f x y = WrapMonad ((unwrapMonad u) `mplus` (unwrapMonad v))
15:55:11 <lambdabot> f = const (const (WrapMonad (unwrapMonad u `mplus` unwrapMonad v)))
15:55:30 <aristid> @pl f x y = WrapMonad ((unwrapMonad x) `mplus` (unwrapMonad y))
15:55:30 <lambdabot> f = (WrapMonad .) . (. unwrapMonad) . mplus . unwrapMonad
15:55:44 <aristid> benmachine: no, probably not
15:56:09 <ddarius> benmachine: Maybe does not satisfy that distributivity law.  mplus (Just True) (Just False) >>= \b -> if True then Nothing else Just () = Nothing, mplus (Just True >>= ...) (Just False >>= ...) = Just ()
15:56:15 <aristid> :t mplus `on` unwrapMonad
15:56:16 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => WrappedMonad m a -> WrappedMonad m a -> m a
15:56:17 <mauke> (WrapMonad .) . (mplus `on` unwrapMonad)
15:56:53 <aristid> :t ((.).(.)) WrapMonad mplus `on` unwrapMonad
15:56:54 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => WrappedMonad m a -> WrappedMonad m a -> WrappedMonad m a
15:56:59 <ddarius> benmachine: In general anything that commits to a choice early will fail, hence deterministic parsers.
15:57:04 <benmachine> ddarius: do you mean, if b then Nothing else Just ()
15:57:08 <aristid> heh! secs to the rescue again
15:57:17 <ddarius> benmachine: Yes.
15:57:23 <benmachine> oh right
15:57:24 <benmachine> I see
15:57:25 <ddarius> Which, incidentally, is guard . not
15:57:32 <benmachine> yes
15:57:34 <aristid> :t ((.).(.)) WrapMonad (mplus `on` unwrapMonad)
15:57:35 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => WrappedMonad m a -> WrappedMonad m a -> WrappedMonad m a
15:57:42 <benmachine> hmm ok
15:57:56 <aristid> :t (((.).(.)) WrapMonad mplus) `on` unwrapMonad
15:57:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => WrappedMonad m a -> WrappedMonad m a -> WrappedMonad m a
15:58:09 <aristid> weird, why do both typecheck
15:58:35 <aristid> oh, probably because both are correct
16:00:13 <aristid> :t (((.).(.)) WrapMonad mplus)
16:00:14 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> WrappedMonad m a
16:00:44 <hpc> :t mplus `on` unwrapMonad
16:00:45 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => WrappedMonad m a -> WrappedMonad m a -> m a
16:01:13 <aristid> hpc: fun stuff, isn't it?
16:01:20 <hpc> it really is
16:01:34 <hpc> i wish i groked monads better
16:03:26 <kmc> can i help?
16:03:29 <aristid> @let (..) = (.).(.)
16:03:29 <lambdabot>   Parse error: DotDot
16:03:40 <aristid> why's that a parse error?
16:03:41 <Cerulean> :whois aristid 
16:03:51 <soupdragon> does anyone know a book or whatever on category theory that defines everything in terms of category theory?
16:04:04 <HugoDaniel> hi there
16:04:12 <soupdragon> hello
16:04:12 <ddarius> soupdragon: There are a few things that do stuff along those lines.
16:04:16 <aristid> @let ('') = (.).(.)
16:04:16 <lambdabot>   Improper character constant or misplaced '
16:04:17 <kmc> 'morning HugoDaniel
16:04:20 <ddarius> soupdragon: For example Lawvere's thesis.
16:04:32 <aristid> Cerulean: why did you :whois me?
16:04:44 <soupdragon> is there anything easier to follow than Lawvere's thesis :(
16:04:45 <aristid> and what would be a good alternative syntax for ..?
16:04:45 <benmachine> aristid: .. is reserved for [1 .. 5] etc.
16:04:53 <aristid> benmachine: oh too bad
16:05:04 <ddarius> soupdragon: http://www.jstor.org/pss/2273784 also kinda sorta does that
16:05:13 <benmachine> aristid: sometimes people use .:
16:05:13 <HugoDaniel> hey kmc
16:05:13 <ddarius> Lawvere's thesis isn't too bad.
16:05:14 <HugoDaniel> :)
16:05:21 <soupdragon> im still fiber-phobic
16:05:23 <aristid> @let (.:) = (.).(.)
16:05:24 <lambdabot>  Defined.
16:05:37 <soupdragon> I think I need to practice a lot more basic category theory before looking into these things
16:05:43 <hpc> :t (.:)
16:05:44 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:05:46 <aristid> :t WrapMonad .: mplus `on` unWrapMonad
16:05:47 <lambdabot> Not in scope: `unWrapMonad'
16:05:50 <soupdragon> thanks though
16:05:51 <aristid> :t WrapMonad .: mplus `on` unwrapMonad
16:05:52 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => WrappedMonad m a -> WrappedMonad m a -> WrappedMonad m a
16:05:56 <aristid> yay!
16:07:14 <BMeph> ddarius: Maybe your some-day blog article can be called, "Bundles and Fibers and Jets, O My!" :)
16:07:29 <ddarius> soupdragon: Benabou's view is that categories as "we" work with them are fibrations, i.e. the usual uses of sets in category theory are usually family constructions and a fibration would allow this structure without committing to set theory.
16:08:23 <BMeph> ddarius: Alternatively, "It All Started With Adjunctions..." ;)
16:08:30 <ddarius> BMeph: See Lawvere's notes on the Toposes of Laws of Motion
16:08:33 <soupdragon> lol
16:08:41 <aristid> soupdragon: do you think understanding category theory makes one a better programmer?
16:08:52 <ddarius> BMeph: I find (parameterized) representability to be more foundational than adjunctions.
16:09:01 <soupdragon> aristid, all I can say is the people that managed to actually understand it are excellent
16:09:15 <ddarius> Why does the goal need to be a better programmer?
16:09:27 <BMeph> ddarius: Fine, fine you win! :)
16:09:35 * BMeph surrenders
16:09:38 <edwardk> I think it has given me a lot of neat tools to use to solve problems
16:09:43 <aristid> ddarius: it does not need to be.
16:09:48 <aristid> ddarius: but for me, it would be.
16:09:49 <ddarius> BMeph: http://www.acsu.buffalo.edu/~wlawvere/ToposMotion.pdf Interesting but hard to follow read.
16:10:04 <ddarius> edwardk: It can be a side-effect without being a goal.
16:10:25 <BMeph> ddarius: Oh, crap, _you're_ saying it's a tough read, and you expect ME to get it?!? =8*O
16:10:40 <aristid> ddarius: is it illegitimate to have it as a goal?
16:10:55 <ddarius> No.
16:11:06 <soupdragon> aristid, I think the point is you are likely to get more than that out of it
16:11:11 <ddarius> BMeph: The basic ideas aren't too difficult but it isn't very well presented.
16:11:41 <ddarius> My point was simply that there's no reason not to study it for its own sake or for some other end.
16:12:33 <aristid> ddarius: i didn't mean to imply that
16:12:46 <djahandarie> ddarius, what is that paper... about?
16:13:49 <ddarius> djahandarie: a.t.o.m.s, a right adjoint to exponentiation, making differential equations (and tangent bundles) representable.
16:14:07 <ddarius> I find the fractional exponentiation stuff pretty interesting.
16:14:18 <djahandarie> Representable?
16:15:09 <ddarius> djahandarie: Representing them with "first class" objects in a category.
16:16:26 <ddarius> As a simple example, the tangent bundle of a manifold is the exponential object M^T where T is an atom (and M is the manifold.)
16:17:16 <ddarius> That PDF reads like some rambling thoughts Lawvere jotted down.
16:17:46 <djahandarie> Considering its a transcript of a video, that would make some sense
16:17:50 <danharaj> He *is* getting old :p
16:18:52 <pokoko222> hello mortals, haskell still kicks scala's ass?
16:18:54 <pokoko222> :D
16:18:54 <soupdragon> I wonder what it means for a differential equation to be representible
16:19:26 <djahandarie> pokoko222, who told you there were mortals in this channel?
16:20:16 <hpc> lambdabot is going to someday bitrot; does that count?
16:20:29 <kmc> pokoko222, did you see http://therighttool.hammerprinciple.com/browse
16:20:35 <kmc> this seems like your kind of website
16:20:51 <ddarius> soupdragon: Well an autonomous first order differential equation is just a vector field.  In the lingo of that paper, that is a section of the projection of the tangent bundle, i.e. an arrow f : X -> X^T such that   f = id where  projects to the base point.
16:21:04 <kmc> for example pokoko222 http://therighttool.hammerprinciple.com/items/haskell/scala
16:21:57 <djahandarie> Interestingly, Scala won "This language is good for distributed computing" and "This language excels at concurrency"
16:22:07 <pokoko222> soupdragon i think it means it is not separable, so you must use euler and direction fields. i might be wrong on this
16:22:23 <kmc> Haskell has not much for distributed computing
16:22:36 <djahandarie> Does Scala?
16:22:36 <kmc> and it ranks just after Scala for concurrency
16:22:38 <pokoko222> kmc tnx nice links
16:22:40 <kmc> don't know
16:22:45 <ddarius> This is probably what I want: http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6V0K-46V4M0S-H&_user=10&_coverDate=11%2F08%2F2002&_rdoc=1&_fmt=high&_orig=search&_sort=d&_docanchor=&view=c&_rerunOrigin=scholar.google&_acct=C000050221&_version=1&_urlVersion=0&_userid=10&md5=22f8424965b419640f4c52a88fbed6a4
16:22:56 <aristid> i don't think these lists are 100% accurate, kmc
16:23:06 <pokoko222> nothing is 100% accurate 
16:23:13 <kmc> djahandarie, it has Java RMI at the least
16:23:23 <kmc> aristid, they're just surveys
16:23:27 <kmc> take it with a big grain of salt
16:23:27 <gwern> > "" == "'"
16:23:28 <lambdabot>   False
16:23:40 <pokoko222> i dunno but i think scala will take over with time
16:24:01 <pokoko222> having more paradigms is undefeatable 
16:24:04 <aristid> pokoko222: scala seems to be a hudge hodge-podge
16:24:13 <pokoko222> explain 
16:24:14 <kmc> pokoko222, C++ should take over then
16:24:15 <aristid> it seems to be the 21st century c++
16:24:26 <pokoko222> kmc no it will become obsolete in 10 years
16:24:32 <medfly> just like C
16:24:34 <kmc> anyone who goes on about "paradigms" probably does not understand programming languages in detail
16:24:35 <medfly> no one knows it now
16:24:59 <pokoko222> kmc well i do and i say what i said
16:25:00 <kmc> "paradigms" are a myth and/or a smokescreen for Java and C++ to excuse lacking basic features
16:25:08 <pokoko222> haha i knew you will start this
16:25:11 <aristid> kmc: but then, who _does_ understand that in detail?
16:25:20 <pokoko222> lame arguments
16:25:43 <aristid> ooh i remember
16:25:45 <kmc> aristid, btw my point linking the site was not that they're accurate...
16:25:51 <aristid> pokoko222 is a pure troll
16:25:57 <aristid> i saw him somewhere else
16:26:06 <pokoko222> disneyland?
16:26:08 <kmc> aristid, we know him well
16:26:14 <kmc> it's cool
16:26:14 <alexbobp> what paradigms do they claim?
16:26:25 * djahandarie claims ALL paradigms
16:26:37 <kmc> C++ and Java are "imperative" and "object-oriented" and this somehow excuses not having lambda
16:26:38 <alexbobp> I meant java and c++
16:26:48 <pokoko222> oh lord this is philosophy come ooone
16:27:00 <alexbobp> kmc: I always figured it was just a careless omission
16:27:01 <kmc> pokoko222, you came here to start a fight obviously
16:27:10 <medfly> java being horrible is kind of a consensus, not an opinion
16:27:11 <yashton> when you think about it though, lambdas are powerful but easily abused
16:27:28 <pokoko222> kmc if conversation=fight then yes
16:27:29 <Ke> kmc: I think C++1x has lambdas
16:27:34 <kmc> alexbobp, sure, but if you ask any diehard C++ user why it lacks <favorite FP feature here>, they will respond with a 3 page boilerplate code-pattern that does the same thing but is "idiomatic OOP"
16:27:43 <kmc> Ke, yup
16:27:46 <yashton> and java and other enterprise languages are specifically about ease of corporate programming
16:27:48 <pokoko222> c++ is a killer but stuff like scala will kill it 
16:27:50 <aristid> kmc: the funny thing is that in haskell, lambdas aren't used all that often ;)
16:27:53 <alexbobp> kmc: to be fair function pointers are not three pages long
16:28:01 <kmc> function pointers aren't first-class functions either
16:28:06 <Ke> kmc: eg http://gcc.gnu.org/gcc-4.6/cxx0x_status.html
16:28:11 <alexbobp> kmc: they both have the *feature*, they are just ugly because they don't have a syntactic sugar for it
16:28:13 <Peaker> kmc: typically 3 page boilerplate template code, not really OOP
16:28:14 <yashton> where corporate programming is all about not so bright programmers
16:28:16 <kmc> boost's implementation of tuples and variants is thousands of LoC
16:28:24 <ddarius> aristid: I dislike lambda syntactically but I still use it very often.
16:28:27 <kmc> Peaker, but the phrase "idiomatic OOP" will definitely come up
16:28:36 <kmc> even if the "idiom" is how to get around flaws in C++ specifically
16:28:37 <kmc> haha
16:28:39 <aristid> ddarius: don't use use hofs more often?
16:28:46 <kmc> pokoko222 is always a pleasure
16:28:50 <Peaker> alexbobp: in C++ you're supposed to use "C++ Functors", not func-ptrs, or you have to pass (void*) contexts and cast it yourself
16:28:57 <aristid> kmc: every language has flaws, even haskell. like lack of DT :)
16:29:01 <kmc> yashton, i agree.  Java makes a lot of business sense even if I would never want to use it
16:29:03 <kmc> aristid, yup
16:29:15 <ddarius> aristid: I do use other HOFs quite often and I still use lambda a lot.
16:29:18 <Peaker> kmc: what business sense?
16:29:20 <kmc> yashton, and it's not that all Java programmers are dumb.  it's that the language tries to equalize the smart ones and the dumb ones
16:29:29 <Peaker> I don't understand why a crippled languages is more suitable "for business"
16:29:32 <alexbobp> anyways I agree, I'd love to have lambdas in c++ and java
16:29:39 <Peaker> kmc: what benefit is there in that?
16:29:39 <kmc> it limits the damage done by bad programmers, and prevents good programmers from confusing everyone
16:29:43 <alexbobp> both of them have a really fugly closest substitute
16:29:53 <Peaker> kmc: I doubt it. smart programmers will figure out how to confuse everyone :)
16:29:55 <yashton> kmc: i agree, it's all about limiting the damage one poor programmer can do.
16:29:57 <kmc> Peaker, you get to treat software development as a repeatable process involving
16:30:03 <kmc> replaceable components
16:30:03 <aristid> ddarius: in more limited languages like ruby, you use lambdas more often, i think
16:30:16 <kmc> anyway "lambda" is not really the issue, "first-class functions" are
16:30:17 <yashton> i tend to use lamdas in C# quite often
16:30:29 <gwern> > 50000 / 0.05
16:30:30 <lambdabot>   1000000.0
16:30:41 <MarcWeber> aristid: The kind of thing you use in Ruby most often is called block and behaves like a lambda.
16:30:42 <kmc> Python's lambda is crippled but it still has real first-class functions, and so to me counts as a functional language (though many Pythonists try to disown the label, and they do make it hard in certain other ways)
16:30:44 <aristid> > "over " ++ show 9000
16:30:45 <lambdabot>   "over 9000"
16:30:58 <kmc> actually Ruby's block has some weird difference from lambda, i thought
16:31:09 <aristid> MarcWeber: yeah that's what i meant
16:31:12 <pkrumins> > fail "can go only up to 8999"
16:31:12 <kmc> "return" in a block makes a non-local exit from the function containing the block
16:31:13 <lambdabot>   No instance for (GHC.Show.Show (m a))
16:31:13 <lambdabot>    arising from a use of `M8783023376...
16:31:13 <kmc> iirc
16:31:25 <aristid> pkrumins: use error
16:31:29 <yashton> readability always trumps power i'm afraid :-)
16:31:41 <pkrumins> oh!
16:31:44 <yashton> and python's emphasis on readibilty and a general code style is laudable
16:31:48 <kmc> it was funny to watch people on reddit talk about "wouldn't it be great if some language had first-class control flow"
16:32:05 <ddarius> Smart programmers don't write code that confuses everyone.
16:32:11 <Peaker> kmc: as in ContT?
16:32:14 <aristid> kmc: return in a block makes a non-local exit from the function containing the block? i just have to repeat that because it sounds.... ridiculous
16:32:18 <kmc> Peaker, i was thinking of Scheme's call-cc
16:32:27 <kmc> aristid, it makes it look more like "for" or "while"
16:32:30 <yashton> ddarius: nothing written in perl is every not obfuscated ;-)
16:32:31 <Peaker> yashton: "readability" is not a unary verb :)
16:32:34 <kmc> people prefer readable weak code because they can read 3 pages of code and feel like they got something done
16:32:36 <medfly> hiya Peaker 
16:32:39 <Peaker> medfly: hi
16:32:43 <kmc> rather than staring at one line of code for two hours and feeling dumb
16:32:52 <Peaker> yashton: Readability to the beginner and to the expert are very different things
16:32:55 <aristid> kmc: doesn't that mean that blocks can't leave the function as a value?
16:33:03 <Peaker> yashton: Python caters very well to "readability to the beginner"
16:33:09 <aristid> otherwise the behavior would be weird
16:33:11 <kmc> aristid, i'm not sure, not a ruby programmer myself
16:33:14 <Peaker> yashton: I think Haskell caters much better to "readability to the expert"
16:33:16 <Raynes> alexbobp: Looks like your Java wish will come true in Java 7.
16:33:23 <aristid> kmc: perl blocks are better than that i think :D
16:33:30 <Peaker> yashton: And I think power brings more expert readability, not less
16:33:34 <kmc> i mean this is all pretty stereotypical...  "people only use languages other than Haskell because they're dumb"
16:33:45 <medfly> YOU'RE DUMB
16:33:47 <kmc> so i think i'll stop ;P
16:33:50 <yashton> Peaker: with good composition, yes. The problem with most code is methods/functions that are 500+ lines long, hard to reason out.
16:33:55 <aristid> medfly: NO UR DUM
16:34:00 <alexbobp> Raynes: alright... now java just needs operator overloading and I can start taking it seriously again...
16:34:05 <Peaker> yashton: Haskell makes functions typically 1-5 lines long :)
16:34:07 * alexbobp stopped using java when he learned C++
16:34:17 <Peaker> yashton: even when they're long, they're usually just a big lexical scope for lots of small functions
16:34:43 * Raynes never learned Java because he found Haskell and Clojure.
16:34:54 <aristid> Peaker: it's possible to write long functions in haskell, though, and they can be a NIGHTMARE
16:34:59 <Peaker> with power/abstractions, beginner readability may suffer, but: Composability, correctness, mathematical simplicity all gain
16:35:20 <medfly> imo beginner readability just means resembling languages commonly known, yeah?
16:35:23 <Peaker> aristid: Ref. transparency makes it easier to decompose
16:35:31 <medfly> unless you mean a total beginner :-p
16:35:36 <Peaker> medfly: Also using little to no abstraction
16:35:41 <theorbtwo> medfly: Largely, yes.
16:35:46 <theorbtwo> Peaker: I wouldn't go that hard.
16:35:47 <Peaker> medfly: Repeating patterns rather than capturing them
16:35:59 <yashton> the nice thing about Java over C++ is the emphasis on Javadoc, which if you can read the interface signature, you can forget what it actually does. I hate having to go to the code just to see what something does.
16:36:17 <theorbtwo> Giving things names, and explanitory names, is also very important for readability.
16:36:23 <ddarius> medfly: I don't see what resembling a commonly known language does to help a beginner to programming unless you are going to include English in that.
16:36:31 <ddarius> medfly: Nevermind.
16:36:46 <theorbtwo> ...and by explanitory, I mean that they explain things to your audience, not just to you.
16:36:57 <ddarius> "explanatory"
16:37:20 <theorbtwo> Calling something an "arrow" isn't explanatory unless your audience can be expected to know category theory.
16:37:40 <danharaj> I don't think people struggle with new nomenclature when they're learning something.
16:37:50 <Peaker> theorbtwo: There's a conflict between short concise names that make the structure clear, and long names that make the code more approachable at the expense of the structure
16:37:53 <aristid> theorbtwo: on the other hand, calling it WarmFluffyThing isn't helpful either.
16:37:57 <danharaj> We are very good at learning, and even creating new words when we need them.
16:38:16 <jesusabdullah> Haskell has lots of arrows! -> <- =>
16:38:17 <yashton> on the other hand, the verbose variable names are easier when your IDE autocompletes them
16:38:31 * ddarius thinks the meaning of "category theory" in the Haskell community has warped out of all resemblence to how it is used outside the Haskell community.
16:38:35 <Peaker> theorbtwo: Also, Haskell makes names hard:  What name could "f", "a", and "b" have in fmap :: (a -> b) -> f a -> f b?
16:38:50 <kmc> theorbtwo, actually, the Haskell term "Arrow" is really confusing as it relates to CT
16:38:53 <kmc> afaik
16:39:02 <medfly> soon there will be a separate article in wikipedia, category theory (computer science)!!!
16:39:07 * medfly goes to check if it exists
16:39:09 <theorbtwo> Peaker: (in -> out) -> functor in -> functor out
16:39:32 <danharaj> theorbtwo: in and out are duplicating information. The position of a and b w.r.t. to the arrows already encodes that.
16:39:40 <kmc> to most beginners, Haskell's "Functor" and "Monad" would be best thought of as totally undefined terms until explained in detail
16:39:42 <Peaker> theorbtwo: I am not sure at all that is an improvement
16:39:53 <aristid> danharaj: and the Functor f => already encodes that f is a functor, sure
16:39:57 <yashton> there is a convention though, we tend to use abcd for variables, f for function
16:40:00 <kmc> which is better than calling it "DataStructure" and "SequentialDataStructure" or whatever
16:40:30 <hpc> kmc: those look like Java class names
16:40:32 <theorbtwo> danharaj: Don't repeat yourself applies to code, not documentation, and "in" and "out" are only one or two extra characters.
16:40:54 <kmc> http://www.classnamer.com
16:41:06 <danharaj> theorbtwo: Documentation is not only names. It is also structure. You are duplicating information in your code for no  reason.
16:41:15 <ddarius> medfly: Plenty of computer scientists have a good handle on "what category theory is about" (or they have no idea what it is at all.)  It seems to be mostly Haskellers that have identified it with some strange esoterica.
16:41:27 <danharaj> theorbtwo: I am from a mathematical background, though, so maybe I admire concise definitions over verbosity.
16:41:28 <theorbtwo> kmc: I'm not sure about that.  SequentialDataStructure is slightly closer to being a short description of what it means then Functor.
16:41:33 <Peaker> theorbtwo: It is somewhat less scalable at presenting structure
16:41:45 <Peaker> theorbtwo: fmap is simple, but as the type signature grows, these longer names become less and less nice
16:41:46 <kmc> theorbtwo, err, nothing sequential abotu Functor
16:41:50 <kmc> something slightly sequential about Monad
16:41:58 <yashton> SequentialDataStructure is kind of vague, Functor actually means something specific
16:42:03 <kmc> theorbtwo, the point is, using a readable name is likely to introduce confusion
16:42:08 <theorbtwo> Slightly, but the syntax requires that we give them names, so we should give them names that actually make sense.
16:42:08 <Peaker> theorbtwo: "Functor" only means "PolymorphicParamTransformableByForwardFunc"
16:42:22 <theorbtwo> kmc: Er, right.
16:42:38 <kmc> as much as we complain about the "help, i don't get monads" people
16:42:40 <danharaj> theorbtwo: they are variables, so let's give them variable names.
16:42:46 <kmc> at least they understand that there's something they don't get
16:42:49 <Peaker> theorbtwo: "SequentialDataStructure" doesn't say anything about what functor does
16:42:59 <Peaker> theorbtwo: not sure how it's related at all
16:43:01 <yashton> kmc: and at least they are trying to learn
16:43:01 <kmc> versus making assumptions about "SequentialDataStructure" based on soomething unrelated
16:43:15 <theorbtwo> kmc: Right, functors aren't sequential, I disagree that using a redable name will introduce confusion.
16:43:35 <Peaker> Applicative/Monad introduce potential for sequencing (They give an order to "f" or "m" values being fused together, that could be considered a sequence)
16:43:46 <benmachine> ThingThatCanBeFmapped f => (a -> b) -> f a -> f b
16:43:49 <Peaker> theorbtwo: But how do you convey the structure that Functor captures in a shor tname?
16:44:11 <kmc> (and i don't think we complain about the people trying to learn monads, except in as much as there's sometimes an XY problem)
16:44:15 <theorbtwo> Peaker: I don't know.  Partlly, because I don't know what structure a functor captures, to be honest.
16:44:17 <yashton> I don't think a short name will capture it, that's what full documentation is for
16:44:18 <kmc> (where X = do IO)
16:44:23 <kmc> (and sometimes a prerequisite problem)
16:44:40 <yashton> doing :t is nice for a little reminder, but you can't pack a lot of information into it
16:44:53 <theorbtwo> kmc: Partly, that goes "I don't know how to do this, and I don't know monads.  Therefore, I should do this using monads!"
16:45:01 <kmc> hehe
16:45:04 <kmc> @quote two.problems
16:45:04 <lambdabot> jwz says: Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.
16:45:08 <Peaker> theorbtwo: In Haskell, anything that has a type parameter that can be changed from "a" to "b" using a function (a -> b)  and   when that function is used with "id" it is equivalent to "id",  is a Functor. That's the structure
16:45:42 <Peaker> theorbtwo: It's a concept that takes a bit of explaining. I don't think a short name can convey that meaning
16:45:48 <Peaker> (Except by reference to the concept, e.g: "Functor")
16:45:57 <theorbtwo> I can buy that.
16:46:30 <yashton> the worst thing you can do is to think you understand something because the wording seems right
16:46:34 <yashton> take "return" for example
16:47:08 <aristid> yashton: it'd be better something like, say, "pure"?:)
16:47:26 <yashton> "bind" has been suggested in some articles
16:47:41 <theorbtwo> yashton: Yeah, return is a good example of misnaming something.  "Bind" would be good, or "wrap".
16:47:53 <Peaker> I like "wrap"
16:47:55 <aristid> iirc people say that Applicative should be a prerequistie for Monad
16:47:57 <theorbtwo> You shouldn't call something "return" unless it's going to exit a function.
16:47:59 <aristid> @src Applicative
16:47:59 <lambdabot> class Functor f => Applicative f where
16:47:59 <lambdabot>     pure  :: a -> f a
16:47:59 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
16:48:06 <Peaker> aristid: of course
16:48:14 <Peaker> aristid: and the split to Pointed/etc
16:48:15 <aristid> and therefore, pure it be
16:48:31 <Peaker> aristid: the problem is backwards compatibility -- and what do we do when we discover more intermediate classes?
16:48:37 <hpc> Applicative used to be prerequisite for Monad, didn't it?
16:48:46 <Peaker> hpc: Applicative was discovered after Monad
16:48:53 <hpc> ah
16:49:11 <aristid> Peaker: maybe allowing instances to define superclass methods would help
16:49:16 <benmachine> isn't bind a name usually given to (=<<)?
16:49:23 <danharaj> someone proposed that didn't they? superclassing?
16:49:27 <aristid> Peaker: let's take the Arrow/Category split... the old instances would still work...
16:49:30 <danharaj> Personally I do not like global instances.
16:49:38 <benmachine> global instances ar egood
16:49:39 <benmachine> imo
16:49:58 <danharaj> But you have things like List having two applicative structures.
16:50:00 <aristid> the alternative being something like ML's functors? (which i need to learn)
16:50:06 <Peaker> aristid: there's the class-aliases proposal
16:50:06 <kmc> err, "bind" is already used for (>>=)
16:50:10 <benmachine> superclassing has been proposed, we haven't worked out the details
16:50:14 <kmc> "pure" and "wrap" are good
16:50:22 <Peaker> danharaj: do you want everything using explicit instances everywhere?
16:50:27 <benmachine> danharaj: yeah, but you don't want the same class to behave in two ways
16:50:34 <kmc> once the Applicative stuff is ironed out then we can just use "pure"
16:50:44 <Peaker> danharaj: That's what newtypes are for
16:50:47 <danharaj> Peaker: I don't know what I want. Something like, I don't know. Types parametrized by functions.
16:50:49 <kmc> and Monad will only have (>>=) and maybe (>>)
16:50:52 <kmc> and fail in MonadFail ;P
16:51:00 <aristid> danharaj: DT?
16:51:13 <danharaj> aristid: a limited form. Certainly DT can obviate the need for typeclasses, no?
16:51:13 <aristid> lol DT is becoming a buzzword
16:51:14 <Peaker> I don't sympathize much with all thew newtype-hate.  I just miss some TH boilerplate gens for my newtypes
16:51:29 <Peaker> kmc: (>>) is from Applicative
16:51:30 <kmc> danharaj, not really
16:51:35 <kmc> Peaker, you're right
16:51:39 <hpc> what's DT?
16:51:44 <kmc> though its presence in Monad is about efficient overloading
16:51:47 <kmc> hpc, dependent types
16:51:47 <aristid> Peaker: what's (>>) in Applicative?
16:51:53 <kmc> @google dependently typed programming in Agda
16:51:54 <benmachine> *>
16:51:54 <hpc> ah
16:51:55 <kmc> :t (<*)
16:51:55 <Peaker> @type (*>)
16:51:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
16:51:56 <lambdabot> http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
16:51:56 <lambdabot> Title: Dependently Typed Programming in Agda
16:51:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
16:52:03 <kmc> :t (*>)
16:52:04 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
16:52:37 <aristid> ah!
16:52:44 <Peaker> aristid: Applicative is like Monad, when you don't want "dynamic choice of effects". That is, when you know ahead of time exactly which "m"s you will combine, without looking at the "a"s,  (referring to values of types "m a")
16:53:02 <Peaker> (>>) doesn't get to look at the previous result (the "a") to choose the next effect, so it can work with Applicative
16:53:04 <aristid> Peaker: yeah, jmcarthur pointed to a diagram saying basically that
16:53:12 <aristid> http://just-bottom.blogspot.com/2010/04/programming-with-effects-story-so-far.html
16:53:17 <kmc> danharaj, Haskell's type classes are in effect a) a system for introducing values into a special, global scope, b) a way of selecting values from that scope as implicit function arguments
16:53:32 <kmc> see Scala, which has no type classes as such, but has implicit args of a general sort
16:53:43 <kmc> DT languages tend to have implicit args but that's not fundamental to being DT
16:54:15 <kmc> another way to look at Applicative is that it only has as much power as liftA, liftA2, etc.
16:54:25 <danharaj> kmc: I was thinking of carrying the function arguments in the type.
16:54:43 <Peaker> aristid: Functor -- can't change the "effect"/"wrapper".  Applicative: Can combine/fuse effects/wrappers, but only pre-chosen ones.  Monad:  Can combine effects based on previous results of "effects"
16:54:54 <kmc> danharaj, can you elaborate?
16:54:58 <Peaker> kmc: Yeah, I think you should be able to implement either (<*>) or liftA2
16:55:06 <kmc> (preferably some Agda code ;))
16:55:18 <kmc> Peaker, yeah, actually liftM = liftA = (<$>) = fmap
16:55:20 <kmc> you're right
16:55:27 <kmc> :t liftA2 ($)
16:55:28 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
16:55:39 <danharaj> kmc: hardly. Probably not at the moment :p
16:55:46 <aristid> Peaker: i wonder if getting Applicative/Alternative into Monad and changing the do-syntax to allow generating Applicatives would be a big gain
16:55:51 <danharaj> kmc: I'll think about it and try to translate it into agda.
16:56:27 <kmc> i know Coq has a typeclass system.  i know very little about it
16:57:19 <soupdragon> it's "just" sugar for dependent records
16:57:34 <kmc> DT languages tend to have implicit args because otherwise you get a lot of fairly obvious applications especially of types
16:57:53 <Lajla> Does any of you know if there's a C-- IRC channel around?
16:57:55 <aristid> what's the difference between fmap and liftA?
16:57:57 <kmc> map Int (\_ -> String) show [1..5]
16:58:00 <kmc> aristid, none
16:58:01 <kmc> :t liftA
16:58:01 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
16:58:09 <kmc> err maybe liftA is type-specialized
16:58:11 <kmc> @src liftA
16:58:11 <lambdabot> liftA f a = pure f <*> a
16:58:22 <kmc> there's a law that that = f <$> a
16:58:24 <kmc> i think
16:58:25 <kmc> i hope so
16:58:28 <Peaker> aristid: I don't think we need much syntax for Applicatives.  liftAn makes Applicatives pretty easy to use
16:58:29 <aristid> why does it use pure and <*> and not <$>?
16:58:40 <ddarius> aristid: Philippa suggested and implemented a do-for-Applicative thing, but do-notation doesn't really fit Applicative.
16:58:43 <hpc> @check f <$> a == liftA f a
16:58:44 <lambdabot>   Precedence parsing error
16:58:44 <lambdabot>      cannot mix `Control.Applicative.<$>' [infixl ...
16:58:56 <hpc> @check (f <$> a) == (liftA f a)
16:58:57 <lambdabot>   Couldn't match expected type `f a'
16:58:59 <Peaker> aristid: possibly to use just methods from the Applicative class
16:59:19 <aristid> Peaker: but <$> is from Functor!
16:59:30 <aristid> which is a prerequisite of Applicative
16:59:36 <hpc> @src (<$>)
16:59:36 <lambdabot> f <$> a = fmap f a
16:59:46 <Peaker> aristid: I know, it's probably an asthetic thing
16:59:54 <aristid> -- | A variant of '<*>' with the arguments reversed.
16:59:54 <aristid> (<**>) :: Applicative f => f a -> f (a -> b) -> f b
16:59:54 <aristid> (<**>) = liftA2 (flip ($))
16:59:57 <aristid> this is weird too
17:00:07 <kmc> why?
17:00:07 <ddarius> kmc: There is. liftA = fmap
17:00:09 <benmachine> I think the idea of liftA is you can define pure and <*> and then give the Functor instance in terms of it
17:00:09 <aristid> why not just (<**>) = flip (<*>)
17:00:18 <benmachine> aristid: that comment is a lie
17:00:23 <kmc> ddarius, but its type is (needlessly) specialized
17:00:30 <benmachine> aristid: the effects happen in the same order
17:00:34 <ddarius> kmc: Just like liftM's
17:00:39 <kmc> yeah
17:00:40 <ddarius> aristid: That means something different.
17:00:51 <aristid> :t (<**>)
17:00:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
17:01:00 <aristid> :t flip (<*>)
17:01:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
17:01:09 <aristid> ddarius: how so?
17:01:28 <kmc> order of effects
17:01:49 <ddarius> aristid: f <**> x means execute x then f then apply.  flip (<*>) means execute f then x then apply.
17:01:49 <Peaker> aristid: which "f" gets fused on which side
17:02:19 <ddarius> swap x and f in each (though technically it doesn't matter)
17:02:25 <Peaker> @type liftA2 (flip ($))
17:02:26 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f (a -> b) -> f b
17:02:32 <Peaker> @type (flip (<*>))
17:02:33 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
17:02:44 <aristid> hmmm
17:02:47 <Peaker> the former will run effects left-to-right.  The latter right-to-left
17:04:49 <hpc> [1, 2, 3] <**> [+2, +2, +2]
17:04:54 <hpc> > [1, 2, 3] <**> [+2, +2, +2]
17:04:55 <lambdabot>   A section must be enclosed in parentheses thus: (+ 2)A section must be encl...
17:05:06 <aristid> can you translate <*> and <**> into list functions for me?
17:05:29 <aristid> @src liftM2
17:05:29 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:05:41 <hpc> > [1, 2, 3](flip <*>) [+2, +2, +2]
17:05:41 <lambdabot>   A section must be enclosed in parentheses thus: (+ 2)A section must be encl...
17:05:47 <Peaker> > (<**>) [1,2,3] [(+10), (+100)]
17:05:48 <lambdabot>   [11,101,12,102,13,103]
17:05:54 <Peaker> > flip (<*>) [1,2,3] [(+10), (+100)]
17:05:55 <lambdabot>   [11,12,13,101,102,103]
17:05:56 <aristid> @undo liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:05:56 <lambdabot> liftM2 f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
17:06:21 <BMeph> Someone needs to invent an imperative-style programming language that doesn't conflate execution and evaluation...oh, NM, we're using it! ;)
17:06:28 <Peaker> aristid: same result, different "effect" (different list order/wrapper)
17:07:46 <aristid> m1 <*> m2 = concatMap (\x1 -> concatMap (\x2 -> [x1 x2]) m2) m1
17:08:02 <kmc> (print "hello" >> pure id) <*> (print "world" >> pure 3)
17:08:18 <kmc> (print "world" >> pure 3) <**> (print "hello" >> pure id)
17:09:22 <aristid> m1 <**> m2 = map (flip ($)) $ concatMap (\x1 -> concatMap (\x2 -> [x1 x2]) m2) m1
17:09:53 <aristid> wait, wrong
17:10:36 <aristid> m1 <**> m2 = concatMap (\x1 -> concatMap (\x2 -> [x2 x1]) m2) m1
17:11:40 <aristid> map (flip ($)) is a nice trick
17:12:05 <aristid> :t flip id
17:12:06 <lambdabot> forall a b. a -> (a -> b) -> b
17:16:01 <aristid> :t flip id undefined
17:16:02 <lambdabot> forall a b. (a -> b) -> b
17:17:42 <benmachine> :t fix
17:17:43 <lambdabot> forall a. (a -> a) -> a
17:17:50 <benmachine> :t fix . unsafeCoerce
17:17:51 <lambdabot> Not in scope: `unsafeCoerce'
17:17:53 <benmachine> :(
17:18:36 <djahandarie> :t map (flip ($))
17:18:37 <lambdabot> forall a b. [a] -> [(a -> b) -> b]
17:19:02 <djahandarie> ...huh?
17:19:21 <djahandarie> How would that be useful
17:19:31 <kmc> who said it was?
17:20:42 <wlangstroth> any of you guys know Mark Wassell?
17:21:07 <hpc> :t flip map ($)
17:21:07 <lambdabot>     Couldn't match expected type `[a]'
17:21:07 <lambdabot>            against inferred type `(a1 -> b) -> a1 -> b'
17:21:07 <lambdabot>     In the second argument of `flip', namely `($)'
17:22:53 <wlangstroth> (he wrote, and then seemingly abandoned HJS, a JavaScript interpreter in Haskell)
17:23:20 <gwern> I tried to package HJS. failed
17:23:25 <gwern> hard stuff
17:23:48 <wlangstroth> "hard stuff"? It's a mess - "academic code"
17:24:09 <gwern> wlangstroth: well, fixing the bitrot was pretty darn hard
17:24:22 <gwern> after piling on a bunch of hacks which started causing their own problems, I gave up
17:24:44 <wlangstroth> no kidding - I'm fixing it up, but it's seriously cobweb-laden
17:24:44 <soupdragon> I hate people that attack academic whatever
17:24:57 <djahandarie> soupdragon, how academic of you
17:25:05 <kmc> ivory tower elitists
17:25:06 <wlangstroth> soupdragon: hate away - academics don't follow style guides
17:25:15 <gwern> I wasn't as good at packaging as I am now, but still a lot of the difficulty was intrinsic
17:25:28 <djahandarie> gwern, time at UPS has served you well, huh?
17:25:29 <soupdragon> not as bad as "LISP isn't used in industry" people though
17:25:32 <wlangstroth> gwern: oh, I sympathize
17:26:03 <gwern> djahandarie: I can cabalize a package in time for the midnight plane circuits!
17:26:07 <soupdragon> anyway it sucks that this is becoming a popular phrase or though or whatever it is
17:26:21 <djahandarie> Haha
17:26:26 <theorbtwo> general-purpose insult?
17:26:35 <kmc> i think there are some issues common to much of academically-produced code
17:26:43 <soupdragon> kmc, I don't
17:26:47 <wlangstroth> gwern: I had to completely re-do the console interface (main)
17:26:51 <kmc> which is also shared with some industrial code
17:27:00 <kmc> but the latter set is not as easily picked out
17:27:03 <gwern> wlangstroth: I don't think I even got to fully building
17:27:06 <theorbtwo> People have been calling things "academic" ever since education was institutionalized.
17:27:24 <soupdragon> you mean calling things academic as a demerit
17:27:25 <soupdragon> ??
17:27:39 <theorbtwo> soupdragon: Quite.
17:27:54 <gwern> well, which academic? plato's academy or the later Skeptical academy?
17:28:05 <soupdragon> I wonder if it just stems from people getting bad grades and being sore about it
17:28:30 <soupdragon> or maybe it's inferiority complex
17:28:59 <gwern> I think it's the unmotivated work
17:29:03 <djahandarie> soupdragon, I've seen a lot of projects in academia done in the mindset that they will be thrown away once they get their degree
17:29:09 <gwern> and that much of it doesn't work out
17:29:22 <wlangstroth> gwern: mine builds, it just doesn't take flags yet: http://github.com/wlangstroth/hjs/tree/will
17:29:37 <djahandarie> As in, don't focus on long-term sustainability, instead, just get the job done.
17:29:40 <gwern> djahandarie: 'in CS, we progress by standing on each other's toes' eh
17:29:46 <kmc> i would wager that most thesis code is substantially rewritten, if it continues to be used
17:30:00 <soupdragon> I think we should be nice to academics. If it wasn't for them everyone would be programming in PHP.......... oh wait...
17:30:05 <kmc> haha soupdragon
17:30:07 <gwern> 'everything should be written top-down, except the first time'
17:31:34 <wlangstroth> that code is a disaster to read, and that's from a Haskell beginner, so that's saying something
17:31:56 <gwern> wlangstroth: is it even worth packaging?
17:31:56 <soupdragon> wlangstroth: so ditch it instead of insulting a large group of people ?
17:32:18 <gwern> wlangstroth: I can't say that I've ever regretted abandoning its packaging - the need has never really been apparent
17:33:05 <wlangstroth> gwern: it'll be kind of "neat" - the guy built it off of a paper, so once it's cleared up, it has some educational value
17:33:27 <wlangstroth> it just needs to be un-f#$@%ed
17:33:39 <monochrom> unfanthomed
17:34:16 <wlangstroth> soupdragon: getting to insult a large group of people is just a pleasant ... side-effect
17:34:32 <soupdragon> not very nice for other people though
17:35:18 <wlangstroth> my ire is reserved for those who refuse to follow a style guide
17:35:29 <wlangstroth> not all academics fall into that category
17:35:53 <gwern> haskell doesn't really have a style guide tho
17:35:56 <monochrom> style guides are overrated
17:36:01 <gwern> except hlint which didn't exist when hjs was written
17:36:11 <hpc> the only true style guide is consistency
17:36:31 <wlangstroth> hpc ftw - I don't care which style guide, just pick something
17:36:54 <monochrom> At least, dumb style guides like "indentations must be divisible by 4", "variable name length must be a prime number"
17:37:42 <theorbtwo> Indentations should be consisitant.  I really don't care what N is, so long as N is a constant.
17:37:52 <wlangstroth> exactly
17:38:37 <ddarius> "Line lengths must form a Collatz sequence."
17:38:42 <gwern> divisible by 4 doesn't sound too bad
17:38:54 <hpc> and if you deviate from consistent indentation, deviate consistently, not inconsistently
17:39:05 <hpc> like, half-indented where
17:39:36 <monochrom> relics of plain text files
17:40:15 <hpc> in an ideal world, all indentation would be tabs and we wouldn't need space-alignment
17:40:50 <kmc> no, in an ideal world you'd have real flexible alignment points
17:40:57 <kmc> \t is a terrible substitute
17:41:38 <hpc> in an ideal world, computer memory models wouldn't be based on one-dimensional tape?
17:41:52 <soupdragon> I can't understand why anyone cares about such trivial matters
17:42:06 <kmc> soupdragon, ;P
17:42:48 <soupdragon> how many spaces there are in your indentation or whatever.. if you're hacking on someone else code you just do what they do. If you are writing your own thing do you have time to think about this nonsense?
17:42:56 <kmc> yes
17:43:14 * hpc picks whatever looks best in $editor/$language
17:43:20 <kmc> it has a small but real effect on quality of life as you work
17:43:32 <hpc> 4 for haskell, 2 for perl, otherwise i end up indenting across the whole screen
17:43:45 <hpc> when i have to use it at work, at least
17:44:15 <kmc> and no i won't "do what they do" when it's 8 space
17:44:26 <hpc> 8 spaces is so damn many
17:44:26 <wlangstroth> hpc: someone's forcing you to use perl? I thought everyone's being forced to write Ruby these days.
17:44:28 <kmc> which is quite literally unusable in C++
17:45:00 <hpc> wlangstroth: it isn't so bad, as it fits perl's use case
17:45:32 <hpc> wlangstroth: i still bang my head when i need to do something like manipulate a pointer
17:47:13 * heatsink plays satanic music for hpc to headbang to
17:56:20 <danharaj> 8 space tabs? geeze.
17:56:22 <danharaj> Why???
17:56:44 <Cale> because that makes them unusable ;)
17:57:11 <jmcarthur> also because that is how tab is defined
17:57:34 <Cale> Well, align to the next multiple of 8 spaces
17:58:03 <Cale> But yeah, I think tabs have no place in source code, and should always be converted to spaces.
17:58:24 <Cale> I don't care how much people indent things by as long as things which are supposed to line up do.
17:58:53 <danharaj> It would be nice if you could turn on a flag to reject files with tabs in them.
17:59:11 <Cale> I tend to choose my indentation by hanging things off of the initial keyword of a block.
17:59:18 <jmcarthur> there is a flag to warn you, at least
17:59:24 <danharaj> o rly
17:59:26 <jmcarthur> and if you use -Werror then it fails
17:59:28 <jmcarthur> -fwarn-tabs
17:59:43 <danharaj> it seems to be just a small step to get
17:59:45 <danharaj> -fuck-tabs
17:59:50 <jmcarthur> heh
18:00:01 <kmc> "uck! tabs!"
18:00:02 <danharaj> although ghc also has a treat warnings as errors flags, right?
18:00:04 <kmc> perfectly innocent
18:00:14 <jmcarthur> huh?
18:00:25 <Cale> danharaj: That's what -Werror is
18:00:34 <jmcarthur> danharaj: if you use -Werror then warnings cause compilation to fail instead, otherwise they just give you a message but continue anyway
18:00:43 <danharaj> jmcarthur: right.
18:08:43 <wlangstroth> hpc: manipulating pointers in a haskell channel? I won't hear of such talk.
18:09:41 <ddarius> "How would you like to build your resume? ( ) Build online ( ) Copy & Paste ( ) Upload"  "Copy & Paste" ?  What the heck?
18:09:51 <monochrom> haha
18:10:28 <monochrom> choose it. you will likely find out what it means.
18:10:54 <wlangstroth> ddarius: it should be "Copy & Paste ( ) - for that extra professional smell"
18:11:41 <wlangstroth> "when you care enough to copy & paste the best"
18:13:34 <kmc> google "latex resume" -> download source -> edit -> upload pdf
18:13:40 <kmc> does that count as "build online" or "copy & paste"?
18:15:22 <hpc> depends; does the form use a radio button or check boxes?
18:15:39 <ddarius> Radio button.
18:16:12 <ddarius> Check boxes would be [ ]
18:16:27 <hpc> ah
18:16:48 <wlangstroth> elinks?
18:17:40 <wlangstroth> (as in the text-based browser, where [ ] is a check box)
18:27:04 <Olathe> > (-27)**(1/3)
18:27:05 <lambdabot>   NaN
18:27:09 <Olathe> Why is that NaN ?
18:27:10 <liquidweaver> Isn't haskell scottish?
18:27:36 <Olathe> > 27**(1/3)
18:27:37 <lambdabot>   3.0
18:27:48 <dons> liquidweaver: yeah, totally. 
18:27:56 <djahandarie> Do you want a complex number, Olathe?
18:28:03 <liquidweaver> Awesome. Scots Rule.
18:28:17 <ddarius> Haskell was an American.
18:28:21 <dons> its not really scottish.
18:28:32 <mauke> > (-27)**(1/3) :: Complex Double
18:28:33 <lambdabot>   1.5 :+ (-2.5980762113533156)
18:28:37 <liquidweaver> I know :P
18:28:37 <dons> but some of the early implementations came out of glasgow and edinburgh
18:30:02 <Olathe> mauke: I don't get it. Isn't there a real result for that ?
18:30:10 <soupdragon> why would you take the cube root of -27?
18:30:21 <soupdragon> > (-3)^3
18:30:22 <lambdabot>   -27
18:30:26 <Olathe> To test that Haskell gives the cube root of -27.
18:30:36 <soupdragon> > (1.5 :+ (-2.5980762113533156))^3
18:30:36 <lambdabot>   (-26.99999999999999) :+ (-3.552713678800501e-15)
18:30:39 <soupdragon> > (1.5 :+ (2.5980762113533156))^3
18:30:40 <lambdabot>   (-26.99999999999999) :+ 3.552713678800501e-15
18:30:44 <soupdragon> see there are 3 cube roots
18:30:59 <Olathe> Well, sure, but why doesn't it give a real result if there is one ?
18:31:02 <mauke> @hoogle cbrt
18:31:02 <lambdabot> No results found
18:31:05 <Olathe> Instead of NaN
18:31:17 <soupdragon> Olathe, well I don't know why should we prefer a real number?
18:31:23 <mauke> Olathe: can you give me an algorithm to get that result?
18:31:53 <soupdragon> well not every number has a real cube root...
18:32:22 <Axman6> > > (-27) ** (1/3) :: Complex CReal
18:32:22 <lambdabot>   <no location info>: parse error on input `>'
18:32:27 <Axman6> > (-27) ** (1/3) :: Complex CReal
18:32:28 <lambdabot>   1.5 :+ 2.5980762113533159402911695122588085504142
18:32:41 <Axman6> > ((-27) ** (1/3))**3 :: Complex CReal
18:32:44 <lambdabot>   mueval-core: Time limit exceeded
18:32:47 <soupdragon> I mean if you consider,  1,w,w^2  the cube roots of 1, and you rotate that by 5 degrees.. say, they're all cube roots of cis 5 but none of them are real
18:33:11 <ddarius> a ** b = exp (b * log a)
18:35:34 <soupdragon> lol that was totally wrong what I said
18:35:44 <soupdragon> hum how do I correct it
18:36:34 <soupdragon> none of the cube roots of i are real
18:36:36 <Olathe> > let realRoot root n = if root <= 0 then error "zomg" else if n < 0 then if even root then error "zomg" else -(realRoot root (-n)) else n**(1/fromIntegral root) in realRoot 3 (-27)
18:36:37 <lambdabot>   -3.0
18:37:01 <aavogt> soupdragon: but aren't we restricted to real numbers as input given the type of ** ?
18:37:11 <soupdragon> hmh I don't think so
18:37:25 <aavogt> @type (**)
18:37:26 <lambdabot> forall a. (Floating a) => a -> a -> a
18:37:28 <gwern> you speak with a forked tongue, white man
18:37:34 <soupdragon> wait a sec
18:37:39 <soupdragon> I was right before with the cis 5 stuff
18:37:39 <aavogt> real in real out
18:41:20 <aavogt> @check \a b -> a**b /= a**b  || a**b == signum a*abs a**b
18:41:20 <lambdabot>   "Falsifiable, after 0 tests:\n-1.0\n0.0\n"
18:43:00 <theorbtwo> @check \a b c -> a*b*c == a*c*b
18:43:01 <lambdabot>   "OK, passed 500 tests."
18:43:42 <theorbtwo> Hm.  That's not actaully true, given finite-precision floating point.
18:43:57 <aavogt> try something else
18:44:32 <aavogt> floating point seems to be commutative
18:44:56 <altmattr> how does System.system decide what shell to run in?  It is not using the same shell as I have for my user.
18:44:57 <soupdragon> theorbtwo++
18:45:08 <altmattr> I upgraded bash for this user, but System.system still uses the old one
18:45:09 <soupdragon> (I love when people break quickcheck)
18:45:18 <soupdragon> (smells like victory)
18:45:33 <aavogt> check \a b c -> a*b*c == (a*b)*c
18:45:46 <aavogt> @check \a b c -> a*(b*c) == (a*b)*c
18:45:47 <lambdabot>   "OK, passed 500 tests."
18:45:55 <aavogt> @check \a b c -> a*(b*c) == (a*b)*(c::Double)
18:45:56 <lambdabot>   "Falsifiable, after 8 tests:\n3.0\n3.5\n0.6666666666666667\n"
18:46:12 <aavogt> @check \a b c -> a*c*b == a*b*(c::Double)
18:46:12 <lambdabot>   "Falsifiable, after 11 tests:\n-2.8\n1.5\n1.5714285714285714\n"
18:46:20 <FunctorSalad> altmattr: hmm, this returns /bin/bash for me: system "echo $SHELL"
18:46:36 <aavogt> @check \b c -> c*b == b*(c::Double)
18:46:37 <lambdabot>   "OK, passed 500 tests."
18:46:52 <FunctorSalad> altmattr: maybe look into the source code :) (that's not an rtfm; I don't know the answer)
18:47:33 <altmattr> FunctorSalad: after the upgrade the shell echo will give e the updated executable (/usr/local/bin/bash) but $BASH_VERSION gives the old version
18:49:45 <aavogt> soupdragon, theorbtwo defaulting to Integer
18:50:25 <FunctorSalad> system sauce http://hackage.haskell.org/packages/archive/process/1.0.1.2/doc/html/src/System-Process.html#system
18:51:26 <gwern> huh. google's webspider will execute javascript when visting pages
18:52:01 <aavogt> @check \a b -> b == 0 || a**b /= a**b  || a**b == signum a*abs a**b
18:52:01 <lambdabot>   "Falsifiable, after 6 tests:\n-1.8571428571428572\n4.0\n"
18:52:54 <aavogt> @check \a ->  let b = 1/3 in a**b /= a**b  || a**b == signum a*abs a**b
18:52:54 <lambdabot>   "OK, passed 500 tests."
18:53:57 <FunctorSalad> altmattr: found it
18:54:16 <FunctorSalad> hmm... clipboard fail ;)
18:55:21 <jmcarthur> it's amazing that writing wrappers around imperative APIs can result in so much code for so little functionality, sometimes
18:55:29 <FunctorSalad> commandToProcess :: CmdSpec -> (FilePath, [String])
18:55:29 <FunctorSalad> commandToProcess (ShellCommand string) = ("/bin/sh", ["-c", string])
18:55:29 <FunctorSalad> c
18:55:44 <FunctorSalad> nvm that last c
18:56:21 <jmcarthur> 300 lines of code not counting whitespace and comments for 10 exposed functions so far, 7 of which are trivial and 3 of which are the vast majority of the code
18:56:26 <FunctorSalad> that's from the darcs version though; the haddock isn't online for .Internal http://darcs.haskell.org/packages/process/System/Process/Internals.hs
18:57:12 <FunctorSalad> sounds like a serious wrapper :)
18:57:19 <FunctorSalad> purely functional or something?
18:57:23 <jmcarthur> yeah
18:57:46 <FunctorSalad> altmattr: tl;dr it uses /bin/sh ;)
18:57:48 <jmcarthur> that is, of course, the cause of the code inflation. adapters like this take work
18:58:46 <ddarius> apt-get autoclean = happier
18:58:47 <Olathe> > 0^(1/0)
18:58:48 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:58:48 <lambdabot>    `GHC.Real.Fractional t'
18:58:48 <lambdabot> ...
18:58:50 <jmcarthur> but at least now i have some cool looking functions, at least if you are an opengl programmer
18:58:55 <Olathe> > 0^(1/0) :: Double
18:58:56 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:58:56 <lambdabot>    `GHC.Real.Fractional t'
18:58:56 <lambdabot> ...
18:59:02 <Olathe> > 0**(1/0)
18:59:02 <lambdabot>   0.0
18:59:09 <jmcarthur> here's a fun one:   modify :: Storable e => BufferObject e -> Int -> Int -> (forall s. MVector s e -> BO s e a) -> (BufferObject e, a)
18:59:58 <FunctorSalad> ddarius: must be ubuntu \ debian
19:00:20 <FunctorSalad> what lib is that jmarthur?
19:00:34 <jmcarthur> i'm wrapping opengl with a purely functional interface
19:00:45 <jmcarthur> BufferObject is things like VBOs
19:00:53 <FunctorSalad> sounds hard
19:00:59 <jmcarthur> yeah :\
19:01:00 <FunctorSalad> and useful
19:01:06 <jmcarthur> i don't have much to show for my effort yet
19:01:18 <jmcarthur> can't even test it yet. don't have enough to render
19:01:32 <jmcarthur> hmm... guess i could just read things back out from buffers though
19:01:54 <aavogt> pure fun interfaces!
19:02:13 <aavogt> what is a BO though?
19:02:15 <FunctorSalad> oh. autoclean's a command, not a pkg
19:02:25 <jmcarthur> i'm also finding that i don't know how to treat certain parts of the spec. one thing in particular makes my job really hard
19:02:58 <jmcarthur> if you map a buffer object into your address space, the spec says the implementation is allowed to corrupt the buffer (!)
19:03:28 <jmcarthur> and it doesn't provide a way for you to recover the data unless you make a copy before you map it :(
19:03:48 <jmcarthur> but i hear that this doesn't really happen in modern implementations
19:04:50 <kmc> you can map a buffer object into host address space?
19:05:37 <forrest> forgive the intrusion, but i'm so happy that with all your help I've finally got some code that works: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25979#a25979
19:05:40 <jmcarthur> so right now i'm throwing an exception from a pure function if this happens. i wouldn't normally do that, but if what i hear is true and it doesn't happen in modern implementations then i think i'm okay
19:06:16 <jmcarthur> kmc: yes
19:06:22 <kmc> what's the function to do it?
19:06:25 <soupdragon> I want someone to help em
19:06:26 <soupdragon> me
19:06:42 <jmcarthur> glMapBufferRange
19:07:11 <jmcarthur> and glUnmapBuffer is the one that gives you the return code indicating whether there was any corruption while it was mapped
19:07:19 <kmc> ah, strange
19:07:23 <kmc> never had cause to use that
19:07:36 <kmc> in my experience the fancy GL extensions are woefully under-documented
19:07:45 <jmcarthur> it's in core
19:07:53 <kmc> oh, in OpenGL 3?
19:07:57 <jmcarthur> yup
19:07:58 <kmc> ah
19:08:02 <kmc> that's why then ;P
19:08:39 <altmattr> it is still a totaly mystery to me, but I think I can get it going with runInteractiveProcess
19:08:45 <kmc> can you render to a buffer object without a copy?
19:09:19 <jmcarthur> kmc: i'm using an implementation inspired by DiffArray to get faster updates than copying
19:09:35 <jmcarthur> still slower than a mutable buffer in IO though
19:09:48 <kmc> i mean in the OpenGL API
19:09:53 <jmcarthur> oh
19:09:59 <jmcarthur> oh i dunno about rendering
19:10:25 <kmc> i remember a two-step process
19:10:31 <kmc> where a FBO can bind a texture as the current framebuffer
19:10:34 <kmc> and you can render into that
19:10:47 <kmc> and then glReadPixels to get it into a VBO or the like
19:11:07 <jmcarthur> oh i see. i think there are fancy ways to avoid the copy, but i can't recall any details
19:11:25 <Saizan> forrest: you should probably use L.splitAt rather than L.take + L.drop
19:11:25 <kmc> (basically the VBO replaces host-side buffers, whereas the FBO replaces the screen surface)
19:11:30 <jmcarthur> right
19:11:33 <kmc> but maybe there's a more direct way now
19:11:39 * jmcarthur shrugs
19:11:46 <kmc> this is if you want to use the graphics pipeline to compute geometry
19:11:53 <jmcarthur> right
19:12:09 <forrest> Saizan: I read about splitAt but wasn't sure how to unpack the tuple
19:12:19 <jmcarthur> speaking of computing geometry, opencl and opengl apparently are designed to play nice together
19:12:42 <jmcarthur> or rather, opencl is designed to play nice with opengl
19:12:53 <kmc> yeah
19:12:57 <jmcarthur> there are ways to take the output from opencl and use it directly in opengl
19:13:01 <jmcarthur> which sounds nice to me
19:13:34 <jmcarthur> i don't know much about opencl or anything. i just peeked at it the other day and saw that
19:13:46 <kmc> yeah
19:13:51 <gwern> > splitAt 5 "fooobar"
19:13:52 <lambdabot>   ("fooob","ar")
19:13:59 <kmc> as usual i know the old, hard way to do things and not the good way ;P
19:14:04 <jmcarthur> heh
19:14:10 <gwern> forrest: doesn't look too complex to me
19:14:24 <Saizan> forrest: ah, i guess you haven't learned about pattern matching yet
19:14:43 <forrest> Saizan: yes, that sounds like what I need
19:15:20 <Saizan> > let (a,b) = splitAt 2 "foo" in a
19:15:20 <lambdabot>   "fo"
19:15:35 <Saizan> > case splitAt 2 "foo" of (a,b) ->  a
19:15:35 <lambdabot>   "fo"
19:15:55 <gwern> > fst $ splitAt 2 "foo"
19:15:56 <lambdabot>   "fo"
19:16:14 <jmcarthur> aavogt: BO is a monad built from ST and WriterT so that as you modify the MVector is keeps a log of the data you are replacing so that the old BufferObject can be rebuilt if it's needed later (in the style of DiffArray)
19:16:23 <jmcarthur> *it keeps a log
19:17:04 <forrest> I was hoping it would be that simple -- I'll try to make that work
19:20:56 <forrest> Saizan: awesome, my codes much clearer now (and still works!)
19:21:22 <Saizan> forrest: cheers :)
19:22:19 <forrest> would I be correct to guess that this code loads each part into memory, and if I want to write some huge parts, I'd better write them in chunks?
19:25:20 <Saizan> since L.readFile uses "lazy I/O" (which somewhat controversial) it's already reading in chunks, though i'm not sure how strict L.splitAt is
19:26:03 <gwern> Saizan: I'd expect l.splitAt to be pretty lazy up to the index
19:26:18 <forrest> that's what I was wondering -- whether lazy io would take care of it for me. i guess i will do some memory tests to find out
19:27:45 <Saizan> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/bytestring-0.9.1.6/src/Data-ByteString-Lazy.html#splitAt <- yeah, it's as lazy as it gets
19:28:12 <Saizan> so you shouldn't ever have more than two chunks in memory at once
19:28:24 <gwern> hooboy the BS code is not that pretty
19:29:03 <gwern> I've noticed that that auxiliary-with-int-accumulator seems to be a real signature of dons's coding style
19:30:13 <gwern> @src splitAt
19:30:13 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
19:30:13 <BMeph> gwern: Patent pending. ;)
19:30:22 <gwern> BMeph: too late, prior art
19:30:39 <jbapple> gwern: is it called "go" and defined in a where clause? :-)
19:31:09 <gwern> wait, that splitAt definition looks pretty inefficient; doesn't that cause 2 list traversals?
19:31:26 <gwern> jbapple: not 'go', but it does have a prime!
19:31:52 <Cale> gwern: yes, that is not the real implementation of splitAt, it's the specification
19:32:39 <BMeph> Cale: Good ol' denotational semantics, eh? 
19:33:00 <gwern> hm. base says 'splitAt n xs           =  (take n xs, drop n xs)
19:33:07 <gwern> but then there's this weird splitAt#
19:33:12 <Cale> hehe :)
19:33:35 <gwern> ah, there are multiple versions toggled by CPP
19:33:39 <gwern> #ifdef USE_REPORT_PRELUDE
19:33:46 <Saizan> i'm not that convinced that it's less efficient, we should have benchmarks
19:34:10 <ddarius> Actually, the take/drop implementation has some things going for it and is not always less efficient.
19:34:16 <kmc> i much prefer wild speculation to benchmarks
19:34:22 <gwern> wow, I'm not sure I even follow this efficient splitAt
19:34:30 <gwern> splitAt (I# n#) ls
19:34:31 <gwern>   | n# <# 0#    = ([], ls)
19:34:31 <gwern>   | otherwise   = splitAt# n# ls
19:34:31 <gwern>     where
19:34:31 <gwern>         splitAt# :: Int# -> [a] -> ([a], [a])
19:34:33 <gwern>         splitAt# 0# xs     = ([], xs)
19:34:35 <gwern>         splitAt# _  xs@[]  = (xs, xs)
19:34:38 <gwern>         splitAt# m# (x:xs) = (x:xs', xs'')
19:34:41 <gwern>           where
19:34:43 <gwern>             (xs', xs'') = splitAt# (m# -# 1#) xs
19:34:47 <kmc> big paste makes baby lambdabot cry
19:34:49 <gwern> I... think it only does 1 traversal
19:34:50 <BMeph> It must be inefficient; there isn't one in Data.Vector ... ;
19:35:37 <kmc> xs@[] ?
19:35:40 <Cale> It's just the obvious thing, but with everything unboxed
19:35:52 <kmc> saves building one Nil cell
19:36:00 <kmc> or maybe two
19:36:09 <Saizan> hey, do you want to lose sharing on Nil cells?
19:36:11 <Cale> and that :)
19:36:12 <kmc> wouldn't those be commoned together anyway?
19:36:18 <kmc> isn't every Nil cell in the universe shared? ;P
19:36:19 <ddarius> kmc: The Nil constructor only exists once.
19:36:21 <ddarius> Yes.
19:36:32 <kmc> so what gives
19:36:33 <Saizan> right, which makes it quite amusing :)
19:36:37 <kmc> maybe they don't want to assume that
19:36:41 <kmc> for whatever reason
19:36:55 <kmc> it is an implementation detail, but so is any performance guarantee on Haskell
19:37:05 <ddarius> I suspect the code is from older days of GHC.  The unboxing anything anymore.
19:37:15 <kmc> mm
19:37:22 <fryguybob> @hoogle a -> b -> a -> [(a,b)]
19:37:23 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
19:37:23 <lambdabot> Data.Generics.Twins gmapAccumQr :: Data d => (r' -> r -> r) -> r -> (a -> e -> (a, r')) -> a -> d -> (a, r)
19:37:23 <lambdabot> Data.Generics.Twins gmapAccumQl :: Data d => (r -> r' -> r) -> r -> (a -> e -> (a, r')) -> a -> d -> (a, r)
19:37:26 <ddarius> +doesn't gain
19:37:39 <kmc> because strictness analyzer + inliner does it for you now?
19:37:42 <BMeph> kmc: Think of it as ensuring the future goes back into the past to set the universe right...or not. This version sounds sexier,though, doesn't it? ;)
19:37:45 <fryguybob> @hoogle a -> b -> [a] -> [(a,b)]
19:37:46 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
19:37:46 <lambdabot> Data.Generics.Twins gmapAccumQr :: Data d => (r' -> r -> r) -> r -> (a -> e -> (a, r')) -> a -> d -> (a, r)
19:37:46 <lambdabot> Data.Generics.Twins gmapAccumQl :: Data d => (r -> r' -> r) -> r -> (a -> e -> (a, r')) -> a -> d -> (a, r)
19:37:57 <ddarius> kmc: One thought is the xs@[] pattern leads to using the pointer that may already be in a register rather than needing to load a constant, but... I think it is just randomness.
19:38:12 <kmc> mm
19:38:27 <kmc> good point
19:38:51 <kmc> never thought i'd see Haskell code optimized for fewer register loads ;P
19:38:51 * BMeph prefers the "going-backwards-in-time" theory...
19:38:54 * hackagebot heist 0.2.0 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.2.0 (DougBeardsley)
19:39:20 <ddarius> kmc: You're not trying hard enough.
19:40:20 <ddarius> One of the reasons I don't code C++ as much is that I have a hard time not micro-optimizing it.
19:40:34 <kmc> well, why else would you use C++?
19:41:01 <kmc> aside from boring reasons like "the guy who signs my paychecks says i should"
19:41:43 <ddarius> I've never written C++ intentionally for money, though I did unexpectedly get some money for C++ code once.
19:41:51 <lispy> heh
19:42:03 <lispy> "Write C++, get paid unexpectedly!"
19:42:05 <kmc> haha
19:42:08 <systemfault> :)
19:42:13 <systemfault> C++ is fun :/
19:42:14 <lispy> ddarius: did they pay you to stop writing c++ by any chance?
19:42:28 <ddarius> lispy: I had already stopped (for that codebase) by then.
19:42:30 <kmc> "i'm not a hooker, though i did unexpectedly get some money for sex once"
19:42:37 <lispy> kmc: hehe
19:42:55 <fryguybob> What's another way to write: foo f xs = [(x,f x) | x <- xs] ?
19:43:19 <ddarius> map (id&&&f)
19:43:22 <kmc> :t (id &&&)
19:43:22 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
19:43:26 <fryguybob> Ah that's it.
19:43:31 <kmc> :t \f -> map (id &&&)
19:43:31 <lambdabot> forall t b c'. t -> [b -> c'] -> [b -> (b, c')]
19:43:33 <kmc> :t \f -> map (id &&& f)
19:43:34 <lambdabot> forall a c'. (a -> c') -> [a] -> [(a, c')]
19:43:35 <kmc> bleh
19:43:39 <lispy> and shorter than the zip I was thinking of
19:43:42 <ddarius> map . (id &&&)
19:44:07 <fryguybob> Thanks
19:44:23 <kmc> @pl \f -> map (\x -> (x, f x))
19:44:23 <lambdabot> map . ap (,)
19:44:30 <lispy> ?pl \x -> zipWith (\y -> (y, f x))
19:44:30 <lambdabot> zipWith . flip (,) . f
19:44:31 <kmc> :t ap (,)
19:44:31 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
19:44:42 <lispy> er heh, I typod
19:45:06 <kmc> :t ((,) <*>)
19:45:07 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
19:45:13 <lispy> ?pl \x -> zipWith (\y -> (y, f y)) x x
19:45:13 <lambdabot> join (zipWith (ap (,) f))
19:45:25 <kmc> :t (,) <*> succ
19:45:26 <lambdabot> forall a. (Enum a) => a -> (a, a)
19:45:33 <kmc> :t ((,) <*> succ) 3
19:45:34 <lambdabot> forall a. (Enum a, Num a) => (a, a)
19:45:37 <kmc> > ((,) <*> succ) 3
19:45:38 <lambdabot>   (3,4)
19:46:16 <ddarius> Hmm.  Should I go into cyber warfare?
19:46:38 <kmc> can you get business cards that say "CYBER WARRIOR"
19:47:05 <ddarius> kmc: I could make them.
19:47:16 <kmc> so could i
19:47:31 <ddarius> kmc: They would potentially be accurate in my case.
19:47:46 <ddarius> (Maybe in your case as well.)
19:47:51 <kmc> not to my knowledge
19:55:33 <lispy> ddarius: well, cyber defense is huge at the moment
19:55:38 <lispy> ddarius: not sure about cyber warfare
19:56:24 <gwern> cyber defense is cyber warfare
19:57:00 <gwern> to say otherwise is to say 'well, fortifications are huge, but I'm not sure they have anything to do with war'
19:57:41 <gwern> (napoleon recommended 'a circumspect defense, followed by rapid and audacious attack'. kind of hard to do the former without a 'defense')
19:57:46 <wli> I'm not sure what cyberdefense would consist of. Auditing things for bugs/exploits, fixing bugs/exploits, RAS, I can't even think of anything beyond that.
19:58:09 <gwern> wli: that's a pretty good start
19:58:39 <lispy> wli: honey pots, designing tools/methodologies that lead to less exploitable or unexploitable systems
19:59:03 <wli> I guess there's actually using crypto for what it's meant for too.
20:01:06 <wli> Oh, wait, there is actually something around there related to authentication methods that's kind of a research problem. Passwords have some sort of innate stupidity to them, so other ways actual humans authenticate get interesting, though it's kind of a long-in-the-tooth affair compared to cleaning up exploits.
20:11:05 <akosch> do you have any advice on practicing haskell? i've done project euler problems and tweaked my xmonad config quite much, but now i would like to do something that involves reading other peoples code...
20:11:22 <akosch> but nothing too complex ;)
20:12:03 <akosch> any ideas?
20:12:33 <kmc> find a library you like off hackage
20:12:35 <kmc> and read it
20:12:40 <kmc> and write an app to use it
20:12:49 <kmc> i've been enjoying the graphviz library lately
20:12:56 <akosch> sounds fair, how do i know it's quality code i learn from?
20:13:03 <kmc> dunno
20:13:22 <kmc> typical Haskell exercises would include writing interpreters and compilers for various other languages
20:13:32 <kmc> i did some graphics stuff early on too
20:13:37 <kmc> with OpenGL
20:13:38 <akosch> well that seems like a challenge ;)
20:13:45 <akosch> i mean compilers
20:13:47 <kmc> writing a Scheme interpreter is surprisingly easy
20:13:57 <kmc> writing a Scheme compiler is, though harder, still surprisingly easy
20:14:05 <kmc> especially if you target, say, a stack-based VM
20:14:16 <akosch> how about an interpreter for a dynamic language?
20:14:27 <kmc> well Scheme is dynamic
20:14:30 <kmc> in most of the senses usually meant
20:14:43 <kmc> "dynamic language" is a constellation of associated features and not a totally precise category
20:14:43 <wli> (The JVM makes tail recursion difficult but you'd probably roll your own VM anyway.)
20:14:46 <akosch> yeah, i meant ruby or something like that (python, etc...)
20:14:50 <kmc> sure
20:15:00 <kmc> an interpreter for Python could be a fun project
20:15:11 <kmc> there's already a parser lib on hackage
20:15:14 <kmc> but maybe you'd want to learn that
20:15:21 <kmc> and there's a Python compiler on hackage too, berp
20:15:36 <kmc> it compiles via Haskell and thus gets to use GHC's RTS to run Python code
20:15:44 <kmc> which is a big improvement over the CPython RTS, at least theoretically
20:15:59 <akosch> hm, sound like fun
20:16:00 <kmc> akosch, i also enjoyed inventing my own languages while learning Haskell
20:16:09 <kmc> i did a few stack-based concatenative languages early on
20:16:24 <akosch> i'm not quite in that league yet :)
20:17:42 <akosch> my main studies focus around electrical engineering, so writing an interpreter/compiler seem to me like a large task...
20:18:29 <kmc> yeah an interpreter is much easier than a compiler
20:18:38 <kmc> start with a simple lambda calculus with numbers
20:18:53 <kmc> what have you studied in EE so far?
20:19:22 <akosch> well many things :)
20:19:26 <ddarius> gwern: The US military is starting to move into an offensive stance in cyberspace not just the purely defensive stance its had up until now.
20:19:44 <heatsink_> They're just starting?
20:19:50 <ddarius> heatsink_: Yes.
20:20:04 <akosch> for example electromagnetic field theory, electronics, quantum mechanics, etc...
20:20:54 <akosch> i also had some some classes in soft computing, but not much programming
20:21:28 <akosch> ironically i work as a programmer :(
20:21:33 <heatsink_> I thought it was always part of their stance, even if they paid less attention to it before.
20:21:38 <kmc> what's "electronics"?
20:21:49 <kmc> have you done any logic design in VHDL or Verilog or similar?
20:22:10 <akosch> kmc: yeah, that too (but analog stuff also)
20:22:15 <kmc> a friend of mine wrote a Scheme-based language to output the (extremely verbose and boilerplate-y) VHDL code for a project
20:22:21 <kmc> actually many projects
20:22:26 <kmc> making something similar in Haskell could be fun
20:22:35 <kmc> VHDL has an insane amount of repetition
20:22:50 <ddarius> heatsink_: There has been no mandate and no authority for the military to perform cyber attacks.-
20:23:01 <akosch> kmc: i only know verilog, but i've heard VHDL is not that different
20:23:06 <wli> I think there was Lava or some such.
20:23:52 <kmc> Lava is a Haskell EDSL for hardware synthesis
20:23:56 <kmc> or rather a family of same
20:25:05 <akosch> kmc: nice idea, but i rather would do something for which i have the hardware to run it ;)
20:25:18 <kmc> you can buy a cheap FPGA board
20:25:42 * wli has some interpreter project for some made-up-on-the-fly language in progress of sorts.
20:26:33 <akosch> kmc: one of those would be nice, but i live in hungary and i'm a bit poor :)
20:27:09 <wli> The idea was to minimize the effort spent on the concrete language and focus on the module system for a sort of mini-ML with a higher-order module system.
20:27:20 <kmc> ah
20:28:37 <akosch> kmc: i think i'll stick with the interpreter: python maybe
20:28:47 <akosch> kmc: thanks for the suggestions!
20:29:26 <kmc> :D
20:29:55 <akosch> kmc: maybe a subset of python ;)
20:31:02 <kmc> yeah
20:31:03 <jesusabdullah> rpython?
20:31:12 <kmc> you can start with a tiny subset
20:31:17 * wli hasn't been able to figure out what the papers say module systems do to type inference nor much of anything else that's supposed to go on, but even worse got stuck on writing a spec in part because of not knowing enough about how the language specs work etc.
20:33:55 <heatsink_> ddarius: If you mean they haven't allocated people and money to doing cyberattacks, perhaps, but the US military has a stated policy of using any method available to achieve tactical superiority.  So I think they would consider it within their authority.
20:35:47 <heatsink_> ddarius: One documented incident was embedding trojans in oil pipeline control software they suspected was being stolen.
20:36:14 <kmc> hehe
20:36:22 <kmc> the US military has a stated policy of "we do whatever the fuck we want"
20:36:37 <kmc> also that sounds more strategic than tactical to me
20:37:16 <heatsink_> ddarius: There was a speaker a while ago: http://www.iti.illinois.edu/content/iti-distinguished-lecture-series-dls
20:37:26 <heatsink_> Scroll down to "Understanding U.S. Cyberattack Policy"
20:39:02 <heatsink_> Hm, strategic is probably the right word
20:39:51 <heatsink_> Dang, it's like they decided to use lossless compression for those videos or something
20:40:10 <kmc> there's actually a cyber attack program embedded in the video
20:40:39 <kmc> it will infect your brain and cause you to vote Republican
20:41:46 <tensorpudding> what if you already vote Republican?
20:42:18 <clanehin> I think some people would argue that's intelligence stuff, not military, but meh.
20:43:50 <jesusabdullah> What does ^= mean?
20:43:56 <heatsink_> It's military if your goal is to disrupt things.
20:44:21 <kmc> jesusabdullah, not a standard operator.  is it defined in some library you're using?
20:44:26 <kmc> @hoogle (^=)
20:44:26 <lambdabot> No results found
20:45:31 <clanehin> heatsink_: the distinguishing factor is organizational identity, not intent.  CIA,NSA,etc /= Pentagon.  To people in that field, it matters.
20:45:46 <dcoutts_> chaps, this is getting off-topic
20:45:53 <clanehin> yeah, sorry
20:46:01 <heatsink_> ok
20:46:57 * hackagebot ad 0.31.0 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.31.0 (EdwardKmett)
20:47:12 <edwardk> now with all sorts of fun higher order manual data/typeable instances
20:47:29 <gwern> ddarius: I'm sure the USMC is interested in offensive as well
20:47:37 <gwern> no weapon is too complex for the USM
20:47:40 <edwardk> (without sacrificing encapsulation)
20:47:47 <dcoutts_> edwardk: I see you're continuing your campaign to test the asymptotic complexity of the cabal-install dependency resolver ;-)
20:47:56 <edwardk> dcoutts: hhahahahaa
20:48:42 <dcoutts_> edwardk: I've seriously been considering an optimisation to deal with situations where there are many versions of essentially the "same" package
20:48:57 <ddarius> Yes.  When I said (and say) military, I mean USAF/USMC/US Navy/US Army.  I'm not making any statements about CIA/NSA/etc.
20:49:09 <gwern> dcoutts_: which is worse for the resolver, a shit ton of deps like gitit or a shit ton or versions like ad?
20:49:14 <edwardk> dcoutts: hrmm, what is the strategy now?
20:49:32 <gwern> ddarius: and then there are more obscure forms of cyberwarfare sponsored by the military. like tor
20:49:38 <edwardk> 'try the latest and back off'?
20:49:59 <dcoutts_> edwardk: currently it looks through all versions that satisfy the constraints imposed by other package deps
20:50:05 <ddarius> gwern: The Air Force is definitely the branch that is/will be most responsible for cyber warfare.
20:50:37 <gwern> ddarius: eh. cyberwarfare doesn't map cleanly onto any branch. look at the navy's development of tor
20:50:48 <dcoutts_> gwern: hmm, I'm not sure
20:51:33 <edwardk> dcoutts: well i keep changing the major version, so anyone who has bounds that cover more than one is asking for it ;)
20:51:42 <dcoutts_> edwardk: the optimisation would be to group multiple versions of a package together, with groups determined by whether other packages distinguish the versions, and whether the multiple versions have different dependencies.
20:51:45 <gwern> (what an interesting project tor is. you know, wikileaks was launched with sniffed tor traffic)
20:52:38 <edwardk> ah nice. something like an LCA/van Emde Boas-style splittable set implementation would make that pretty easy
20:52:50 <dcoutts_> edwardk: the point being that within such groups the usual algorithm would not distinguish them based on constraints, so it is safe to discard all but the highest ranked version (usually the latest version)
20:53:11 <edwardk> good, then i'll continue to spam you with versions so you can have a test case ;)
20:53:19 <dcoutts_> heh, thanks
20:53:20 <jesusabdullah> kmc: It's from charts. Thanks!
20:54:32 <dcoutts_> edwardk: if you want to defeat my optimisation all you need to do is change the package dependencies slightly with each revision
20:54:34 <ddarius> gwern: No aspect of warfighting maps cleanly onto any branch.  Hence my use of "most responsible."  Every branch has their own aircraft.
20:56:11 <edwardk> dcoutts: thanks for the protip. i'll make sure to add a second package that i upload on the same frequency that i require a lockstepped version of
20:56:24 <dcoutts_> ah yes, that'd do it
20:57:01 <edwardk> dcoutts: sadly that will actually probably be the case when i split up category-extras ;)
20:57:21 <dcoutts_> edwardk: ah but that's a more mature package, you don't do daily releases of that
20:57:32 <dcoutts_> erm s/daily/hourly/
20:57:44 <ddarius> Hah
20:57:47 <edwardk> dcoutts: mostly because i haven't been able to untangle the dependencies enough to do the major overhaul i have intended ;)
20:57:50 <edwardk> hahahaha
20:59:23 <edwardk> the main things i want to finish in the AD library right now are some polymorphically recursive versions of grad/jacobian so i can compute a tower of partial derivatives, and then add a few more non-trivial variations on newton's method/gradient descent
20:59:28 <edwardk> and then it should quiesce as well
21:00:17 <jesusabdullah> automatic differentiation?
21:00:25 <edwardk> i may want to go through and make my back end jacobian class syntactically a little bit closer to conal's beautiful differentiation, but thats about it
21:00:35 <jesusabdullah> this sounds neat
21:00:44 <dcoutts_> edwardk: as a slightly more serious Q, have you found the frequent releases useful e.g. in terms of feedback from users?
21:01:16 <ibt> i was enjoying category-extras. just kind of wondered why it stop getting updated
21:01:17 <edwardk> jesusabdullah: "diff sin = cos" but importantly diff (exp . exp . exp . exp . exp . exp . exp . exp) executes in the same asymptotic complexity as the underlying function, despite the fact that its symbolic derivative explodes
21:01:29 <ddarius> Users don't have time to provide feedback before a new release is out.
21:01:42 <edwardk> jesusabdullah: lets you take the derivative/gradient/jacobian/higher order derivatives of an arbitrary haskell function basically
21:01:54 <edwardk> dcoutts: actually it has been priceless
21:02:13 <jesusabdullah> oh geez, that's a lotta nested exp's
21:02:35 <jesusabdullah> neat
21:02:50 <mxc> hi, anyone know if its possible to pacman (with your favorite AUR tool) build to pass arguments to the cabal build system when installing the haskell platform?  (i want to enable-documentation, optimization, and profiling libraries)
21:03:04 <mxc> (on arch linux)
21:03:22 <edwardk> i've got a couple of guys who are using it, and it is easier to explain cabal install than it is to say go pull this patch set, etc.
21:04:09 <edwardk> bjorn buckwalter just swapped over a bunch of his geographical code to it, barak pearlmutter has been giving me feedback, mostly complaining about the fact that i let the types shape my API more than the math, etc ;)
21:04:48 <edwardk> and then ddarius has been giving me shit with each release. i'd hate to disappoint him ;)
21:04:49 <ddarius> That's the magic of category theory.
21:04:49 <dcoutts_> edwardk: supposing you were able to tell your users to cabal install http://foo.net/ad/ad-0.31.0.tar.gz, would that be useful?
21:04:55 <ibt> mxc: you can edit the PKGBUILD
21:05:28 <edwardk> dcoutts: that could be, though i'd still need to juggle a good way to push the dist tarballs, somewhere
21:06:04 <edwardk> i don't mean to actually cause a problem. i just figure that given my penchant for letting my public repo lag behind my private one, it was better to push early and often ;)
21:07:17 <edwardk> it is also a consequence of flopping my workflow around, previously i'd push everything to a darcs repo on comonad.com, but since i push to patch-tag now, i don't have a way to store the haddocks to reference when talking to folks
21:10:03 <Pseudonym> > let fac n = product [1..n] in map (\x -> fromRational ((x - 4/3)*9/2) * sqrt 3) . scanl (+) 0 $ [ (fac i)^2 % fac (2*i) | i <- [0..] ]
21:10:03 <lambdabot>   [-10.392304845413264,-2.598076211353316,1.299038105676658,2.598076211353316...
21:10:09 <Pseudonym> > let fac n = product [1..n] in map (\x -> fromRational ((x - 4/3)*9/2) * sqrt 3) . scanl (+) 0 $ [ (fac i)^2 % fac (2*i) | i <- [0..] ] !! 100
21:10:10 <lambdabot>   Couldn't match expected type `[GHC.Real.Rational]'
21:10:10 <lambdabot>         against inferred...
21:10:26 <Pseudonym> > let fac n = product [1..n] in (!!1000) . map (\x -> fromRational ((x - 4/3)*9/2) * sqrt 3) . scanl (+) 0 $ [ (fac i)^2 % fac (2*i) | i <- [0..] ]
21:10:28 <lambdabot>   3.141592653589793
21:10:46 <Pseudonym> Still trying to work this one out.
21:18:46 <Hunner> Hi. When I try to work out ':t fmap fmap fmap' by hand I get ':t fmap $ fmap $ fmap'
21:18:52 <ddarius> Pseudonym: I think you want to look at the double factorial.
21:19:10 <Pseudonym> Ah, good point.
21:19:10 * Hunner has a fault-ly wired brain and needs to fix it
21:19:34 <edwardk> hunner start with 'fmap fmap'
21:19:36 <edwardk> @type fmap fmap
21:19:36 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
21:19:41 <Pseudonym> I was working on the assumption that it was related to an arctan formula.
21:19:45 <Pseudonym> Which is probably also true.
21:20:07 <Hunner> Yeah. I'm trying to go from the type of 'fmap fmap' and giving it 'fmap'.... but it's not working
21:20:32 <Pseudonym> :t fmap fmap
21:20:32 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
21:21:01 <edwardk> so now, to feel that fmap you need the type of fmap to unify the first argument
21:21:07 <edwardk> @type fmap
21:21:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:21:12 <edwardk> @type fmap fmap
21:21:13 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
21:21:51 <edwardk> er unify with
21:23:02 <edwardk> since f1 has kind * -> *, we'll start there. you have (->) (a -> b) (f a -> f b) as the outside of fmap and the otherside you have f1 (a' -> b') as the type of the first argument
21:23:10 <edwardk> unifying those will set f1 = (->) (a -> b)
21:23:42 <edwardk> and then its a really mechanical process ;)
21:23:55 <Hunner> okay.... @type makes more sense with the kinds than :t :)
21:43:18 <robertmassaioli> I've looked through hackage and I was just wondering, has anybody made an iCalendar package that I can import? I have written a basic one and I want to know if I should continue. Thanks.
21:58:39 <adu> robertmassaioli: do you mean the microformat?
21:59:13 <anthonix_> hi, could anyone suggest a way of transforming an Int to a list of bool representing bitpos? or some other way I could map Bool -> Bool functions to each bitpos.. ?  
22:01:02 <robertmassaioli> @adu I mean the one that is specified by rfc5545 (http://tools.ietf.org/html/rfc5545)
22:01:02 <lambdabot> Maybe you meant: arr ask do id
22:01:23 <dons> > map (testBit 0xdeadbeef) [0 .. 4 * sizeOf (undefined :: Int)]
22:01:24 <lambdabot>   Not in scope: `sizeOf'
22:01:28 <dons> anthonix_: ^
22:01:44 <dons> anthonix_: look in Data.Bit
22:02:15 <Ytinasni> > let intToBits i = case i of { 0 -> []; j -> odd j : intToBits (j`div`2) } in intToBits 5
22:02:16 <lambdabot>   [True,False,True]
22:02:25 <anthonix_> thanks!
22:09:28 <FunctorSalad> you know what I think might be useful? a simple terminal tree widget listing all the haddock in existence or on your local machine ;)
22:09:56 <FunctorSalad> could allow more convenient nav than a web browser
22:10:17 <FunctorSalad> I noticed you can easily locate the haddock with ghc-pkg...
22:10:30 <FunctorSalad> (the haddock loc is an attribute of the package)
22:10:30 <Cale> > let intToBits 0 = []; intToBits j = odd j : intToBits (j `div` 2) in intToBits 5
22:10:31 <lambdabot>   [True,False,True]
22:10:49 <Cale> (another way to write that)
22:11:28 <Cale> > let intToBits = map odd . takeWhile (/= 0) . iterate (`div` 2) in intToBits 5
22:11:28 <lambdabot>   [True,False,True]
22:11:58 <Ytinasni> that one's nice :D
22:12:37 <Cale> :)
22:15:14 <adu> wow
22:15:23 <Cale> > unfoldr (\b -> guard (b > 0) >> return (odd b, b `div` 2)) 4738
22:15:24 <lambdabot>   [False,True,False,False,False,False,False,True,False,True,False,False,True]
22:15:45 <adu> wow^2
22:15:48 <Ytinasni> nah, that's just silly.
22:19:42 <Cale> @let foldTree tip branch = f where f Tip = tip; f (Branch x l r) = branch x (f l) (f r)
22:19:44 <lambdabot>  Defined.
22:19:56 <Cale> @let mapTree f = foldTree Tip (Branch . f)
22:19:57 <lambdabot>  Defined.
22:21:00 <Cale> @let bitTree = Branch [] (mapTree (False:) bitTree) (mapTree (True:) bitTree)
22:21:02 <lambdabot>  Defined.
22:23:03 <ODAY> 1/quit
22:24:11 <Cale> foldTree undefined (\x l r n -> if n == 0 then x else if even n then l (n `div` 2) else r (n `div` 2)) bitTree 4738
22:24:16 <Cale> > foldTree undefined (\x l r n -> if n == 0 then x else if even n then l (n `div` 2) else r (n `div` 2)) bitTree 4738 
22:24:17 <lambdabot>   [False,True,False,False,False,False,False,True,False,True,False,False,True]
22:24:40 <Cale> (Okay, that's getting a bit silly :)
22:28:37 <jmcarthur> > let intToBits n = testBit n <$> [31,30..0] in intToBits (4378::Int32)
22:28:37 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
22:29:06 <jmcarthur> > let intToBits n = testBit n <$> [7,6..0] in intToBits (99::Int8)
22:29:07 <lambdabot>   [False,True,True,False,False,False,True,True]
22:29:12 <Cale> > (\tip branch -> branch [] (bitTree tip (branch . (False:))) (bitTree tip (branch . (True:)))) undefined (\x l r n -> if n == 0 then x else if even n then l (n `div` 2) else r (n `div` 2)) 849
22:29:13 <lambdabot>   Couldn't match expected type `t -> ([GHC.Bool.Bool] -> b) -> t1'
22:29:13 <lambdabot>         ag...
22:29:15 <Cale> mmm
22:29:44 <edwardk> i swear i spend half of my time coding shuffling code from one module to another
22:30:15 <Cale> er, duh, of course :)
22:30:31 <Cale> > fix (\bitTree -> (\tip branch -> branch [] (bitTree tip (branch . (False:))) (bitTree tip (branch . (True:))))) undefined (\x l r n -> if n == 0 then x else if even n then l (n `div` 2) else r (n `div` 2)) 849
22:30:31 <lambdabot>   [True,False,False,False,True,False,True,False,True,True]
22:30:40 <Cale> It needed moar fix
22:31:58 <robertmassaioli> hmm, is there a good place to ask if a new package is a good idea or is there a better place for that? :)
22:32:54 <BMeph> Cale: Missing a "dropWhile not" on the testBit ones, eh? :)
22:33:03 <Cale> robertmassaioli: What's your idea?
22:33:26 <Cale> BMeph: those were jmcarthur's
22:33:45 * BMeph looks again...
22:34:25 <BMeph> Cale: My bad, so they were. I guess I need to highlight more folks' names. Sorry, j-mac, carry on! :)
22:34:33 <robertmassaioli> I was thinking of implementing the iCalendar spec as a package for hackage. (rfc5545 if you want to know more http://tools.ietf.org/html/rfc5545#section-1)
22:35:28 <Cale> That sounds like something worthwhile.
22:35:38 <Cale> There's already a parser which might be useful there
22:36:03 <edwardk> is there a nice tool for describing how and why your package requires other packages?
22:36:09 <robertmassaioli> cale: I thought so too. And really, is that a generic parser or a specific one?
22:36:45 <robertmassaioli> Cale: I looked and could not see one. :)
22:38:10 <robertmassaioli> Cale: wow okay I see it but it implements the old spec and not the new one. Hmm, I'll have to look at the differences.
22:43:05 <Cale> edwardk: Hmm... that would be interesting to see. Something which takes two package names and shows all the complete dependency chains between them.
22:44:33 <edwardk> cale: or given one shows the digraph of dependency chains from it
22:47:49 <Cale> This seems like the sort of thing which would exist somewhere at some point during cabal's execution. It's probably just a matter of coercing it into printing it out for you :)
22:48:20 <MarcWeber> Cale: can you explain? I don't understand what you mean by "complete dependency chains". Probably hack-nix can do that easily because Nix provides such a feature natively
22:48:30 <dcoutts_> Cale: cabal-install constructs an InstallPlan which is basically a full dependency graph
22:49:12 <MarcWeber> So all which is missing isa dotty backend :)
22:49:38 * hackagebot ad 0.32.0 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.32.0 (EdwardKmett)
22:50:06 <Cale> MarcWeber: I mean lists of packages which are totally ordered by the dependency relation (each one depends on the next), and such that if x and y are two adjacent packages in the list, there is not some package z such that x depends on z and z depends on y
22:50:18 <Cale> (so you can't add anything extra to the chain)
22:50:52 <edwardk> hrmm hackage and {-# OPTIONS_HADDOCK hide #-} don't seem to play nicely you get a front page that includes all the links for all the modules, even the hidden ones but the pages aren't there
22:51:43 <jmcarthur> BMeph: i was trying to show what the hardware stores, not what i would write on paper ;)
22:51:57 <dcoutts_> edwardk: you should be able to reproduce that behaviour using cabal haddock, if you can please report what you think is wrong / what you would expect/want
22:52:14 * jmcarthur watches edwardk continue to pump out more updates to ad on hackage
22:52:27 <dcoutts_> Cale: so you mean all paths through the full dependency graph
22:52:36 <edwardk> dcoutts: when i run haddock locally my index doesn't contain the extra files
22:52:43 <edwardk> but when i upload it to hackage it seems them all
22:53:13 <Cale> dcoutts_: all the paths through its Hasse diagram anyway
22:53:14 <dcoutts_> edwardk: ohh right, hackage is using the list of exposed-modules
22:53:22 <edwardk> i have a couple of .Internal modules for things like tensors and streams which are needed piece-meal
22:53:34 <edwardk> ahh
22:53:44 <edwardk> then what i could do is add those as other-modules
22:53:56 <dcoutts_> edwardk: which is not unreasonable, given that they are indeed exposed
22:53:58 <edwardk> since the reason i was willing to hide them is that their api is fully exported in other modules
22:54:10 <dcoutts_> edwardk: right, other-modules get hidden automatically, no pragmas needed
22:54:13 <Cale> dcoutts_: I've noticed that with documentation: True in my .cabal, the default settings for haddock don't produce source links. How can I turn that on?
22:54:18 <edwardk> dcoutts yeah but perhaps it would be nice to not generate a broken link though
22:54:34 <edwardk> cale: --hyperlink-source
22:54:42 <Cale> edwardk: Where does that go?
22:54:44 <dcoutts_> Cale: you cannot at the moment, there's a ticket if you want to help suggest how the configuration should work
22:54:51 <edwardk> cabal haddock --hyperlink-source
22:54:55 <Cale> ah, okay
22:55:00 <dcoutts_> it's a design question not any implementation problem
22:55:05 <edwardk> i type it like 50 times a day ;)
22:56:34 <Cale> dcoutts_: The best interface for a shovel is sometimes a hole.
22:57:18 <Cale> (that is to say, you could just pin the option on all the time, since when is it ever not useful?)
22:57:28 <edwardk> dcoutts: that looks like it'll work
22:58:09 <dcoutts_> Cale: it's not useful when hscolour is not installed, and it isn't by default
22:58:12 <MarcWeber> Cale: http://mawercer.de/~marc/out.svg haskell-env at the bottom is a set of all dependencies required to build scion
22:58:14 <Cale> But... I suppose just a haddock-flags: field in ~/.cabal/config would work
22:58:41 <MarcWeber> Of course you're not interested in glibc dependencies and such.
22:59:40 * hackagebot ad 0.33.0 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.33.0 (EdwardKmett)
23:02:30 <MarcWeber> Cale: I updated the graph removing the -src-with-tagcs items
23:02:36 <Cale> MarcWeber: I bet it would also look tidier if you took the transitive reduction first. (Remove the arrows which are implied by the others)
23:04:11 <Cale> Like, for example, there doesn't need to be an arc from glibc-2.11.1 to diffutils-2.8.1, since diffutils depends on coreutils which depends on acl which already depends on glibc
23:04:41 <dcoutts_> edwardk: wow, halved your previous time-between-releases record!
23:05:47 <MarcWeber> Cale: correct. Given that all I had to do was running one line in the shell its pretty enough for my taste.
23:06:17 <Cale> :)
23:06:51 <dcoutts_> Cale: I wonder how one would best present such chains when there are conditional dependencies
23:06:54 <edwardk> dcoutts: =) i wanted to make sure the current version wouldn't have broken links on cabal
23:07:02 <edwardk> er hackage
23:07:26 <MarcWeber> dcoutts_: One page for each variation.. and do this for each dependency..
23:07:35 <MarcWeber> So print a book for each package.
23:07:55 <dcoutts_> MarcWeber: hah, yeah the problem is the explosion in combinations
23:08:24 <Cale> We'll just make a book with 2^n pages :)
23:08:47 <MarcWeber> dcoutts_: Another way: make it interactive: Let the user select for each dependency which flag combination to use and which of the matching packages within a version range given that you seleected a compiler at the beginning :)
23:09:10 <edwardk> dcoutts: well, one version would be to show the dependencies based on just the currently selected solution
23:09:26 <MarcWeber> I'ts like building sand castles: You add a small stone and see what happens.. You can continue doing so forever..
23:09:32 <edwardk> dcoutts: that'd be enough that folks could get a quick 'why' when they're trying to figure out what packages they haul in
23:09:50 <dcoutts_> edwardk: oh you mean when reporting errors in cabal-install dep resolution
23:11:03 <dcoutts_> edwardk: we've been considering for the new hackage server an upload staging area, the idea is you get a preview of what the package page will look like, along with extra QA info etc, then you can either re-upload or commit. Also, the tarball would be available for users or automated build/test agents.
23:11:03 <edwardk> dcoutts: i was referring to the bit i was mentioning earlier about how it'd be nice to be able to just get a directed graph of what your dependencies are for a given package
23:11:48 <edwardk> not necessarily a hackage thing, more of a local. hey what does my installed package foo require?
23:11:53 <dcoutts_> edwardk: you need to be specific about the context however, the dependencies for a package are surprisingly malleable
23:11:55 <dancor> can i install ghc-6.12.2 thru archlinux
23:12:13 <dcoutts_> edwardk: ahh, installed packages, yes they have completely specific deps
23:12:16 <edwardk> dcoutts: i'm looking at it from the perspective of a given installed cabal package
23:12:58 <dcoutts_> edwardk: in that case you're ok, just use ghc-pkg dot
23:13:28 <dcoutts_> or there's Cabal lib code to get a Graph of the installed packages
23:14:13 <edwardk> dcoutts: woo, so a little glue and one of the graphviz libraries and i'm in business
23:14:39 <JoeyA> Yay, haskell.org is finally back up
23:14:49 <Cale> dcoutts_: Something else maybe to think about: I've noticed that a lot of beginners mess up their packages by accidentally installing a different version of say, bytestring, or one of the other packages which comes with ghc, and then ending up with half their packages depending on one and half on the other version, resulting in a confusing mess :)  It might be worthwhile to introduce a special 'blessed' flag (similar t
23:14:50 <Cale> o hidden/exposed) where cabal would avoid installing a different version of that package automatically.
23:15:01 <dcoutts_> edwardk: ghc-pkg --help suggests: ghc-pkg dot | tred | dot -Tpdf >pkgs.pdf
23:15:24 <edwardk> doh even better
23:15:54 <dcoutts_> Cale: right, there are two prongs to this, one is removing the upgrade command which did not do what people expected
23:16:19 <dcoutts_> Cale: and the second is some system to avoid installing new versions of "core" packages
23:16:44 <dcoutts_> I've done the first part already
23:21:58 <edwardk> dcoutts: that helped a bunch now i know that it is the mlist dependency i have that is dragging in base-3
23:22:54 <dcoutts_> Cale: one of the things to think about is what would the behaviour be, it's easy enough to merely prefer the same versions as you have now, but what if you ask to install something that needs a later version of a core package?
23:23:14 <dcoutts_> does it just do it? does it warn? does it fail? can you override it?
23:23:50 <edwardk> is there a "ListT done right" that doesn't have a dependency on transformers?
23:23:56 <edwardk> other than the mlist one?
23:24:35 <edwardk> the List package depends on transformers and so is dead to me until the refactoring of mtl actually happens due to my other dependencies
23:24:48 <dcoutts_> edwardk: there shouldn't be any problem with "dragging in" base-3, you can indirectly depend on base 3 and 4
23:26:35 <edwardk> dcoutts: *nods* just mining through what random cruft i'm importing seeing if i really want it to all come in.
23:28:03 <edwardk> i'm currently only using them for a set of monadic versions of variations on newton's method that i'm not entirely sure are sound that way anyways ;)
23:29:29 <Gracenotes> hum. tar file entries don't have to be laid out in any particular order, do they?
23:29:32 <Gracenotes> looks flat rather than hierarchical, if I read the standards right...
23:30:17 <Gracenotes> strings seems to confirm this. okay then :)
23:31:08 <edwardk> Gracenotes: tar's are designed to be fast to append to so you can use them directly on tape, they have no internal order to the file structure
23:31:51 <edwardk> it is a 'Tape ARchive" ;)
23:31:56 <Gracenotes> :o !!
23:32:16 <Gracenotes> so then I have an excuse for my map to existential data structures, because an arbitrary type might be needed at any time to deal with an entry
23:32:22 <dcoutts_> Gracenotes: they will compress better if you keep all versions of a package's .cabal files together, otherwise it does not matter
23:33:15 <Gracenotes> okay, I think decentralized importing can be managed sanely, efficiently, and lazily
23:33:42 <dcoutts_> Gracenotes: why does it need existential stuff?
23:35:14 <Gracenotes> dcoutts_: I was just going to allow features to import their own stuff, but this would mean a few things: 1. directories for a feature have to be grouped together before being passed, and all of the data must be loaded into memory
23:35:32 <altmattr> the "total time" calculation in my profiling output is significantly less than real run-time.  Is this normal?
23:35:56 <Gracenotes> 2. if parsing fails for a given feature, the state updated by the previous features will still count as macid events
23:36:42 <dcoutts_> Gracenotes: hmm, I'm sure we can demultiplex entries so that we do not need to guarantee that all feature entries be grouped
23:36:43 <Gracenotes> on the other hand, if you take it an entry at a time, accumulating changes to data structures which the feature is responsible for, and committing it all at the end, this doesn't sound totally insane I hope
23:37:21 <dcoutts_> Gracenotes: it sounds sane I'm just wondering if you're making the types more complicated than necessary
23:37:42 <Gracenotes> dcoutts_: and also macid would state have to be updated incrementally in that case
23:37:57 <Gracenotes> s/would state/state would/
23:38:22 <Gracenotes> dcoutts: well, the Import monad itself is a bit messy :)
23:38:53 <dcoutts_> -> #hackage
23:49:12 <altmattr> can anyone help me out interpreting the output of ghc profiling
23:49:13 <altmattr> ?
23:53:28 <robertmassaioli> altmattr: that may be tricky over IRC, maybe post it as a Stack Overflow question and link to it?
23:56:11 <altmattr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25987#a25987
23:56:38 <altmattr> I think i worked out one bit
23:57:06 <altmattr> where one cost center contains another, the total for the enclosing cc is the cost of the ccs inside it plus its own cost
23:57:26 <altmattr> but if you use -P instead of -p, you can see the ticks allocated just to that cc (they are not accumulated)
23:58:23 <altmattr> or is it?
23:58:26 <altmattr> arg!
23:58:34 <altmattr> and what are these CAFs?
