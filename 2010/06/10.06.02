00:00:48 <Gracenotes> the problem is that - now I have a ServerTree. each node has a Resource, a ServerPart Response, or both. including the top-level node. but what if you want more than one top-level ServerPart Response, or >1 Resource?
00:00:49 * edwardk looks forward to the sight of the new chia-hackage.
00:02:09 <Gracenotes> it has a loose Data.Tree-like structure.. hm, maybe I should change the node contents from Maybe (ServerPart Response) to [ServerPart Response]
00:02:44 <edwardk> would address the more than 1 portion of your concern.
00:03:19 <soupdragon> is there a different library than diagram (one that doesn't need dependencies) I can use to generate a vector graphic?
00:03:44 <edwardk> soupdragon: i saw one floating around that used opengl to render but i forgot what it was called
00:04:22 <soupdragon> clutter?
00:04:22 <Gracenotes> the Resource type, by the way, is Map Method (DynamicPath -> MediaType -> ServerPart (Response, Bool)). lots going on there...
00:04:37 <soupdragon> oh this graphics-drawingcombinators
00:04:54 <edwardk> gracenotes: hrmm does it make sense to have more than one then?
00:05:01 <soupdragon> mann Luke Palmer writes a LOT of libraries
00:05:46 <soupdragon> I haven't written a single library ..
00:05:47 <Gracenotes> edwardk: in the cases I can think of? no. but better to err on the side of reasonable generalities when abstracting, I guess
00:05:54 <soupdragon> at least not one that's not gone in the bin
00:06:33 <Gracenotes> on the other hand - the current implementation just replaces resources when there are conflicting paths. this is probably the best behavior.
00:07:05 <edwardk> well, the question is can you actually implement the generality there? you have a Map Method to a function that returns a ServerPart, does ServerPart have a way to tell you that you don't have something present? and how would that differ from the list?
00:07:06 <Gracenotes> the one place where replacements shouldn't happen is for ServerParts. so, I should encode this, actually.
00:07:06 <soupdragon> graphics-drawingcombinators-1.4.1 depends on FTGL-1.333 which failed to
00:07:06 <soupdragon> install.
00:07:07 <soupdragon> all this stuff
00:07:33 <FunctorSalad_> soupdragon: libftgl-dev?
00:07:43 <soupdragon> I'm not on linux :(
00:07:47 <FunctorSalad_> or whatever the package is called in you dist
00:07:48 <FunctorSalad_> oh
00:08:12 <Gracenotes> edwardk: if the returned ServerPart ends up being mzero, move on to access the next resource at that URI
00:09:30 <edwardk> so what keeps you from just merging them into the the same Map? you have a map from method to a function. the merge should be just gluing the two functions together
00:10:18 <edwardk> merge :: (DynamicPath -> MediaType -> ServerPart (Response, Bool)) -> (DynamicPath -> MediaType -> ServerPart (Response, Bool)) -> DynamicPath -> MediaType -> ServerPart (Response, Bool)
00:10:42 <soupdragon> cool gloss works
00:10:44 <Gracenotes> yeah, that's the more complicated one.
00:11:02 <edwardk> which should just be lifting the monadplus a couple of times over the function arguments, no?
00:11:11 <Gracenotes> fmap . fmap . fmap . fmap . ...
00:11:34 <edwardk> merge f g p m = f p m `mplus` g p m -- or something like that
00:11:55 <FunctorSalad_>  @remember <Gracenotes> ...
00:12:03 <Axman6> :t fix fmap
00:12:04 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
00:12:04 <lambdabot>       Expected type: a
00:12:04 <lambdabot>       Inferred type: f a
00:12:07 <Gracenotes> less fmaps than initially predicted
00:12:08 <edwardk> just from looking at the type you pasted above and the fact that you said ServerPart was a monadplus
00:12:10 <Axman6> :(
00:12:25 <Gracenotes> yes, and a monoid
00:12:36 * edwardk isn't afraid of a good old fashioned pointful definition when it suits ;)
00:13:04 <Gracenotes> @pl \f g p m -> mplus (f p m) (g p m)
00:13:05 <lambdabot> liftM2 (liftM2 mplus)
00:13:07 * Axman6 prefers them
00:13:09 <Gracenotes> oh. well.
00:13:25 <edwardk> Gracenotes: yeah hence my earlier mention of "a couple of lifts" =)
00:13:57 <Gracenotes> right, the number of arguments and levels of indirection for (liftM2.liftM2)
00:14:36 <Makoryu> @pl \f g h -> f g <@> f h
00:14:36 <lambdabot> flip =<< (((.) . (<@>)) .)
00:15:00 <Makoryu> @pl \(<@>) f g h -> f g <@> f h
00:15:00 <lambdabot> (line 1, column 3):
00:15:00 <lambdabot> unexpected "<"
00:15:00 <lambdabot> expecting pattern
00:15:03 <Gracenotes> this would only work for the simpler, relatively untyped (stringly-typed, you might say) version of Resources I currently have. earlier today I was trying to implement resources in terms of existential quantification and typeable, but Sterling talked me out of it... got something half-working though...
00:15:06 <Makoryu> Oh fine
00:15:15 <Makoryu> @pl \argh f g h -> f g `argh` f h
00:15:15 <lambdabot> join . ((flip . ((.) .)) .) . (.)
00:15:32 <edwardk> what does the typeable/existential rats nest buy you?
00:16:04 <edwardk> resources being currently just dumb strings?
00:16:17 <edwardk> and you want them to get a bit smarter?
00:16:26 <Gracenotes> well, you get to define things as -- data Resource = forall a. (Typeable a, FromReqURI a) => Resource [Maybe a -> ServerPart Response]
00:16:35 <Gracenotes> (basic definition that I used for making sure it compiled!)
00:17:26 <Gracenotes> and then, addToResource callback orig@(Resource callbacks) = case [cast callback] `asTypeOf` map Just callbacks of [Just m] -> Resource (m:callbacks); _ -> orig
00:17:39 <Gracenotes> (excuse the asTypeOf hackery)
00:18:16 <edwardk> no worries. i'd need to dig deeper into the codebase to see how scary it'd make the surrounding code
00:18:29 <Gracenotes> and you get a collection of things that, given a string, can determine if it yields a resource representation via FromReqURI, and pass it on to whoever needs it... x.x
00:19:57 <edwardk> hrmm
00:20:18 <edwardk> ok, i'm officially crosseyed from lack of sleep. i'll have to pick this up in daylight ;)
00:20:24 <Gracenotes> but, as he noted, I could spend all summer making the most expressively typed data structures, without getting much else done
00:20:30 <edwardk> yep
00:20:44 <edwardk> strings all the way! ;)
00:20:56 <Gracenotes> woo
00:21:26 <Gracenotes> plus existential quantification still doesn't solve the problem of generic subresources
00:21:53 <Gracenotes> the current implementation of it
00:22:29 <Gracenotes> (and good night..)
00:22:29 <edwardk> there is always the idea of doing just what you need to get to the next stage, then once you have a bunch of code using the simple model, you'll know where the lack of abstraction chafes
00:23:06 * edwardk is hardly one to advocate for a lack of abstraction usually, but... )
00:23:11 <edwardk> anyways, later.
00:40:16 <danharaj> Oh thank goodness.
00:40:20 <danharaj> I felt so isolated.
00:42:14 <tomberek> ski: hey
01:21:51 <FunctorSalad> ahem unix domain sockets question again... do the poor things get confused with duplex?
01:22:07 <FunctorSalad> hope it's not too off-topic... I *am* doing it in haskell ;)
01:23:26 <FunctorSalad> my client/server works fine with just a few req/response pairs (over the same socket), but locks up when a lot of them are done in sequence
01:24:15 <p_l> FunctorSalad: maybe you got lost somewhere in the protocol or queues?
01:26:58 <FunctorSalad> p_l: no real queue, this is just a single session where the client sends "n", sends n requests, then receives n replies (using lazy bytestring IO...). the server receives an integer 'n', and ... hmm... does receiving (a query) and sending (the response) in lockstep... maybe that's my problem right there
01:27:28 <FunctorSalad> but shouldn't it work despite this incoherency between server and client ;)
01:27:38 <FunctorSalad> oh, or maybe not
01:27:55 <FunctorSalad> I'm dumb... ;)
01:28:18 <FunctorSalad> (to be fair I switched back and forth between various delimitings ;))
01:29:02 <FunctorSalad> the server will keep streaming replies, which never get read by the client until all messages are sent...
01:29:12 <FunctorSalad> which only works for small n due to buffering
01:29:15 <FunctorSalad> I suppose
01:29:33 <alip> does haskell have any interface to unix passwd entries? like getting the unix username
01:30:36 <FunctorSalad> the current one? readProcess "whoami" [] ""? ;)
01:31:30 <Twey> getEnv "USER"
01:32:32 <alip> hmm ok, how about getting a user's real name? ;)
01:32:50 <Botje> alip: the unix package has System.POSIX.User
01:33:21 <Botje> getLoginName / getRealUserID
01:33:48 <alip> Botje: awesome! thanks :)
01:34:45 <FunctorSalad> of course that's better, but sometimes I don't want to grovel through the haddocks and just do readProcess o_o
01:35:01 <FunctorSalad> if it's not some inner loop...
01:35:54 <Twey> alip: getEnv "USER" >>= fmap userName . getUserEntryForName
01:36:04 <FunctorSalad> hmm wrong word I think. Anyway, I meant the one for "do a lengthy search"
01:46:33 <codolio> Is OCaml a younger hybrid of Haskell with something else?
01:46:42 <ejt> no
01:46:47 <ejt> derivative of ML
01:46:55 <codolio> Haskell + Erlang or Haskell + Lisp would be the options in this article.
01:47:04 <Axman6> the only relation is that it's functional, sort of
01:47:24 <codolio> Or maybe Erlang + Lisp.
01:47:30 <codolio> I wasn't even considering that possibility.
01:47:53 <Gracenotes> haskell is a mutant monster programming language created in the laboratory of evil geniuses
01:47:58 <Twey> codolio: Options for what?
01:48:06 <Twey> Haskell + Lisp, I'd go for.
01:48:13 * Axman6 wonders what the relationship is between dolio and this codolio person
01:48:23 <Twey> A functional language and an imperative language with macros.
01:48:27 <codolio> Totally unrelated.
01:48:45 <FunctorSalad> Gracenotes: with a steam-powered robot of death made out of scrapped boilerplate as a sidekick
01:48:45 <codolio> Twey: "Technical gatherings are buzzing with talk and, of course, debates about Haskell, Lisp/Scheme, Erlang and their younger hybrid cousins O’Caml, Scala, F# and Clojure."
01:49:04 * Axman6 would go with Haskell + Erlang, because he likes both
01:49:07 <FunctorSalad> hwere is that from codolio ?
01:49:15 <FunctorSalad> where
01:49:20 <codolio> http://www.jot.fm/issues/issue_2009_07/column4/
01:49:21 <Gracenotes> Axman6: they should dual
01:49:52 <Axman6> Gracenotes: even though i don't know anything about category theory, apparently i know enough to understand that was a horrible pun. well done
01:50:16 <temoto> Any advices on (preferrably typed) message exchange protocol implementation? I'd like to add another constructor to Message type and have it automagically serializable and parsable.
01:50:37 <Axman6> i'd use binary or cereal
01:50:49 <FunctorSalad> Axman6: I don't see any CT pun in what Gracenotes said :o
01:50:54 <Axman6> because they're yummy
01:50:54 <Axman6> yeah i went there
01:51:04 <temoto> Axman6, those are package names?
01:51:12 <FunctorSalad> yes
01:51:16 <Twey> dolio: Haskell is as much a ‘hybrid’ as O'Caml
01:51:17 <Axman6> yes
01:51:18 <dolio> FunctorSalad: Do you have a duel core processor?
01:51:21 <ivanm> temoto: cereal is a fork of binary
01:51:27 <Twey> (i.e. a derivative, not really a hybrid at all)
01:51:52 <FunctorSalad> dolio: hmm I misread the ordering of messages
01:52:04 <Olathe> I'm trying to implement type-level numbers, but I can't figure out the algorithm ghc uses to solve for unknown types when you have fun things like instance (Mul a T64 t, Add t t s) => Mul a T128 s. Does anyone know where to find information on it ?
01:52:13 <FunctorSalad> thought Axman6's message @ Gracenotes came before the "dual" message
01:56:50 <FunctorSalad> lol I parsed 'coming' as 'gathering' there "Once again the computing community is coming to appreciate the expressive power of functional programming (FP)"
01:57:18 <FunctorSalad> sounds a bit cultish in that reading
01:57:33 <dolio> Better than the sexual reading.
01:57:48 <mlh> FunctorSalad: yes I always want to reach out and rewrite that use to 'beginning'
02:00:57 <FunctorSalad> dolio: yes... "once again?"... is FP really that great...
02:01:34 <dv-> fpfpfp
02:18:57 <Peaker> Who maintains vty? How do I propose patches?
02:19:43 <alip> how do i go about converting an IO String to Either SomeError String? I'm slightly confused with monads it seems :)
02:20:37 <Taejo> alip: you can convert it to an IO (Either SomeError String) -- is that what you want? You can't take things out of IO
02:21:03 <Taejo> (well, you can, but you almost certainly shouldn't)
02:22:01 <Peaker> @hoogle catch
02:22:01 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
02:22:01 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
02:22:01 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
02:22:18 <Taejo> @hoogle SomeError
02:22:18 <lambdabot> No results found
02:22:36 <dv-> @type Right
02:22:36 <lambdabot> forall b a. b -> Either a b
02:23:39 <Peaker> @type \a -> catch (liftM Right a) Left
02:23:39 <lambdabot>     Couldn't match expected type `IO (Either a a1)'
02:23:40 <lambdabot>            against inferred type `Either IOError b'
02:23:40 <lambdabot>     In the second argument of `catch', namely `Left'
02:23:49 <Taejo> alip: I assume you want the Left case if there is an exception in running the IO action?
02:24:11 <Peaker> @type \a -> catch (liftM Right a) (return . Left)
02:24:12 <lambdabot> forall a1. IO a1 -> IO (Either IOError a1)
02:24:51 <Peaker> You could replace "return . Left" with something that's specific to some exception type if you use the new "Exception e => .." catch
02:25:51 <alip> Taejo: hmm, here's what i'm trying to do: I'm trying to parse a configuration file to get user's gecos using ConfigFile.. i'd like to set its defaulthandler (defaulthandler :: ConfigParser -> SectionSpec -> OptionSpec -> Either CPError String) so that i can use (getLoginName >>= fmap userGecos . getUserEntryForName) which returns an IO String, i need to catch the possible errors and convert it to CPError
02:26:49 <Taejo> but defaulthandler does IO, and therefore must have return type (IO something)
02:27:07 <Peaker> alip, When you use >>= with .  it's nicer to use =<< so you read in a single direction :)
02:27:21 <Peaker> left-to-right-to-left
02:28:38 <Twey> And ‘a >>= return . f’ is the same as ‘fmap f a’ or ‘f <$> a’
02:30:30 <temoto> Axman6, random.axman6.com is this your site?
02:30:45 <Axman6> yep
02:31:50 <Accidus> Hmm... Again, not exactly Haskell, but this seems like the closest place to ask: What is the usual denotational semantics for let-polymorphism?
02:32:50 <ivanm> temoto: he's not that random IRL :p
02:33:09 <temoto> ivan, :)
02:34:29 <quicksilver> Accidus: system F?
02:34:36 <quicksilver> (or variants thereof)
02:36:27 <Accidus> But system-F forces you into PER
02:36:43 <Accidus> quicksilver, I was hoping to stay within categorical semantics
02:37:00 <ivanm> is there any way to get GHC to spit out the code it generates when doing deriving?
02:37:29 <ivanm> (I need to write a class instance manually due to using associated tyeps, so I want to see how it would do it normally and copy it)
02:38:03 <quicksilver> ivanm: it doesn't generate haskell.
02:38:31 <ivanm> OK, do you know how to get something to generate equivalent Haskell code?
02:38:40 <quicksilver> it generates Core; dumping the core will show you
02:39:00 <quicksilver> well, you can look at the output of DrIFT or Data.Derive
02:39:00 <ivanm> except how would I go from Core -> Haskell? ;-)
02:39:27 <ivanm> hmmm...
02:39:27 <quicksilver> although they're not guaranteed to produce the same code as GHC I guess they produce something equivalent in most cases.
02:39:30 <kmc_> by removing explicit type abs / app
02:40:21 <ivanm> *nod*
02:47:11 <Peaker> There's a darcs repo for vty. I made some patches. Not sure where I send them to ...
02:48:24 <quicksilver> Peaker: the vty trac perhaps?
02:48:42 <quicksilver> or email corey o'connor who released the last version of vty
02:48:55 <ivanm> Peaker: darcs send ?
02:49:06 <Peaker> I don't know how to work with darcs yet :)
02:49:14 <Peaker> quicksilver, got his email?
02:49:20 <ivanm> Peaker: darcs record, then darcs send -a
02:49:54 <Peaker> Can darcs whatsnew  show a colored diff?
02:50:13 <ivanm> don't think so
02:50:20 <ivanm> what kind of colours do you want?
02:51:03 <quicksilver> Peaker: http://www.haskell.org/pipermail/haskell-cafe/2009-September/065996.html
02:51:25 <Peaker> ivanm, green for new lines, red for removed
02:51:29 <kmc_> any colour you like so long as it's black
02:51:49 <ivanm> Peaker: well, I've never done anything like that; maybe ask on #darcs
02:51:51 <ivanm> kmc_: white for me
02:52:32 <Peaker> "darcs show author" is cool
02:52:40 <quicksilver> run the command in emacs and turn on diff-mode
02:52:45 <quicksilver> that's how I see diffs in colour.
02:52:50 <quicksilver> there are surely other ways :)
02:54:00 <Peaker> heh
02:54:09 <Peaker> my "sendmail" is not configured
02:54:16 <Peaker> How do I make a patch to send manually?
02:54:30 <Peaker> doh, gotta run, will do it some other time
02:55:14 <pozic> The largest contribution to open-source software can probably be made by simply having a default sendmail implementation that always works.
02:55:30 <Libster> haskell sux lol
02:55:54 <pozic> John Harrop?
02:56:25 <Libster> it's so slow they should make it an imperative language
02:56:35 <Axman6> slow? ha
02:56:47 <d3mn0id> trolls must die.
02:56:47 <pozic> Libster: your trolling is really bad. You require training.
02:56:52 <Libster> o
02:56:55 <Libster> please train me
02:57:00 <pozic> Libster: no time.
02:57:22 <pozic> Trolling for dummies would sell pretty well, I suppose.
02:57:25 <Libster> i thought that since you guys all like haskell you would be humorless geeks and i wouldn't need to try very hard
02:57:36 --- mode: ChanServ set +o quicksilver
02:57:41 --- mode: quicksilver set +b *!*Libster@*.bltmmd.east.verizon.net
02:57:41 --- kick: Libster was kicked by quicksilver (kthxbye)
02:57:41 <d3mn0id> lol
02:57:47 --- mode: quicksilver set -o quicksilver
02:58:17 <Itkovian> Nice shot.
02:58:29 <quicksilver> you don't think I peaked too soon?
02:58:35 <Itkovian> Not really.
02:58:46 <Itkovian> In some cases one cannot be fast enough.
02:58:49 <kmc_> what's even the point of that
02:58:54 <kmc_> i do not understand
02:59:03 <copumpkin> of hwat?
02:59:06 <copumpkin> what, even
03:01:02 <ivanm> copumpkin: trolling presumably
03:01:06 <Saterus> if i have a "MaybeT IO Maybe String", is there a way to collapse it to be "MaybeT IO String"?
03:01:34 <ivanm> whoever he is has been on IRC for over 3 years; one wonders if he's spent the whole time trolling...
03:01:58 <copumpkin> I'm sure he just hangs out in another channel and felt like coming to troll in here after reading something about haskell
03:02:47 <quicksilver> Saterus: Yes.
03:02:59 <ivanm> copumpkin: unless he always trolls though, why would you suddenly decide to start trolling?
03:03:09 <quicksilver> Saterus: well, perhaps.
03:03:13 <ivanm> and if he has always trolled, surely after 3 years someone would have kickbanned some sense into him...
03:03:23 <quicksilver> Saterus: you mean MaybeT IO (Maybe String) ?
03:03:46 <arcatan> i was quite amused by the troll!
03:03:46 <Saterus> quicksilver: yes. that's what i'm starting with.
03:04:07 <quicksilver> runMaybeT :: MaybeT IO (Maybe String) -> IO (Maybe (Maybe String))
03:04:22 <quicksilver> liftM (join) :: IO (Maybe (Maybe String)) -> IO (Maybe String)
03:04:32 <quicksilver> MaybeT :: IO (Maybe String) -> MaybeT IO String
03:04:45 <quicksilver> so the answer is MaybeT . liftM join . runMaybeT
03:04:46 <quicksilver> I think.
03:04:50 <quicksilver> make sense?
03:05:29 <ivanm> quicksilver: using ndm's Data.Derive, what do you think would be the better approach? Using the TH method? http://community.haskell.org/~ndm/darcs/derive/derive.htm
03:05:33 <kmc> how about (>>= maybe mzero return)
03:06:19 <kmc> that will collapse (m (Maybe a)) to (m a) for any MonadPlus m
03:06:47 <quicksilver> I think that you should never end up in this situation anyway, if you use the "right" MaybeT combinators.
03:07:22 <Saterus> quicksilver: guessing you're on that part.
03:09:51 <temoto> Axman6, reading your guide on cereal http://random.axman6.com/blog/?p=124 that's great post
03:10:16 <Axman6> thanks :P)
03:10:17 <Axman6> -p
03:10:41 <temoto> Axman6, but it's not clear how to avoid defining another get/put overload for another constructor of my type.
03:10:45 <Axman6> temoto: although that example isn't how i'd normally use cereal
03:11:55 <temoto> Is it possible to make serialization 'just work' with some sensible encoding format without inventing the format itself?
03:13:03 <Axman6> temoto: check out http://code.haskell.org/binary/ to see how i'd normally do it
03:15:04 <ivanm> Axman6: I thought you were using cereal nowadays?
03:15:47 <ivanm> also, I don't know if he's released yet, but kolmodin was working on a version of binary that uses iteratees IIRC
03:15:49 <Axman6> depends on the task, but cereal is just a strict bytestring version of binary with alternative instances for the Get monad
03:15:56 <ivanm> hmmm....
03:20:13 <ivanm> preflex: seen ndm
03:20:13 <preflex>  ndm was last seen on #haskell 1 year, 24 days, 1 minute and 33 seconds ago, saying: plus with current compiler technology, it would be slower
03:20:29 <d3mn0id_> wow
03:20:33 <d3mn0id_> long time
03:20:42 <ivanm> he has a new nick now IIRC
03:20:53 <ivanm> but still, he was rarely here IIRC
03:22:20 <Taejo> in Parsec, does eof only match once at the end of file, or arbitrarily many times?
03:22:37 <temoto> Taejo, it matches end of input.
03:23:02 <ketil_> Axman6, cereal is strict as in Data.ByteString (not .Lazy) or as in strictly parsing?
03:23:03 <pozic> Taejo: you mean whether eof;eof == eof?
03:23:15 <Taejo> pozic: well eof >> eof, yes
03:23:30 <ketil_> Axman6, (my program broke on upgrading to latest Binary, since it is now strictly parsing lazy bytestrings).
03:23:34 <pozic> Taejo: well, try it?
03:23:42 <temoto> Axman6, Binary example is great for its small size, thanks. But it is still implementing custom serialization format, and as such, still another put (IntE), put (OpE) for every constructor.
03:23:57 <Taejo> pozic: fair enough
03:24:10 <pozic> Taejo: I think it is like the empty string, just at the end. So, my guess would be yes.
03:24:37 <ivanm> ketil_: did you ask kolmodin about it
03:24:39 <ivanm> ?
03:25:20 <ketil_> ivanm, I sent an email to him and dons - dons explained the change, turns out that it makes GHC faster.
03:25:31 <ivanm> hmmm.....
03:25:35 <ivanm> silly ghc ;-)
03:25:49 <ketil_> ivanm, and since GHC is a somewhat important use case, I'm shopping for a new lazy binary library I can use.
03:26:16 <ketil_> I thought about cereal, of course, but apparently, it is strict, too.
03:26:17 <ivanm> ketil_: don't know of any other binary libraries though...
03:26:31 <pozic> Parsec could really use a function with type f::<some_parser> -> String -> SomeNoNFailureType (but might throw an exception) -- just for quick testing
03:26:57 <ketil_> fromJust . parseTest?
03:26:58 <pozic> (at least, I can imagine that everyone already has written such a function)
03:27:18 <pozic> ketil_: doesn't parseTest return an either?
03:27:20 * ketil_ didn't look, but surely turning an error into an exception is possible?
03:27:28 <ketil_> fromRight, then.
03:27:44 <pozic> @hoogle parseTest
03:27:44 <lambdabot> Text.Parsec.Prim parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
03:27:44 <lambdabot> Text.ParserCombinators.Parsec.Prim parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
03:27:53 <ketil_> ..that is, turning an error-value (Nothing, Left, etc) into an exception.
03:28:02 <pozic> ketil_: that does't return the value.
03:28:15 <ivanm> well, there's NewBinary which doesn't work with 6.12 ...
03:28:32 <ketil_> ivanm, NewBinary is deprecated long ago, or so I thought.
03:28:42 <pozic> ketil_: it is trivial to write, but convenience stuff like that is useful.
03:29:13 <pozic> ketil_: alling error already returns an exception.
03:29:19 <pozic> calling*
03:29:22 <Taejo> I just got a runtime error "Text.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string." -- just for curiosity, would it be possible to distinguish between nullable and non-nullable parsers in the type system?
03:29:48 <ketil_> Taejo, GADTs?  (Sorry, just saw apfelmus' video)
03:29:58 <Taejo> probably with GADTs, yes
03:30:00 <pozic> Taejo: that would be possible.
03:30:29 <kmc> is that even necessary?
03:30:39 <kmc> you could just have two types «NullableParser a» and «Parser a»
03:30:46 <pozic> Taejo: still, writing many (something_that_always_succeeds) is like writing while(true) bar
03:30:51 <Axman6> i really liked that GADT video
03:30:57 <kmc> link?
03:30:58 <quicksilver> kmc: but that would mean re-writing all combinators twice to work over either.
03:31:09 <quicksilver> or developing a typeclass to unify the two.
03:31:14 <kmc> yeah
03:31:23 <pozic> It would complicate things for little reason.
03:31:32 <Taejo> pozic: I get why it's a problem, and I saw my bug easily, but I'd like to see it at compile-time, not runtime
03:31:41 <quicksilver> I'm not sure the GADT works.
03:31:48 <quicksilver> How can you specify the behaviour of <|> ?
03:31:56 <pozic> If on the other hand you want to really solve these things you must integrate better error messages into the compiler output.
03:32:05 <quicksilver> (that it is nullable if either branch is nullable)
03:32:19 <pozic> How to do that has long been figured out, it's just that no production compiler supports that.
03:32:43 <Taejo> pozic: do you have a reference for the "long figured out" -- I'm curious
03:32:44 <quicksilver> hmm. with type classes on the GADT parameter, I suppose.
03:36:48 <ivanm> anyone know if ndm is still working on derive?
03:36:51 <zygoloid> pozic: the thing where you construct a proof and look at the essential terms? that's pretty neat
03:37:07 <ivanm> he hasn't updated it to the latest version of uniplate, which is going to cause compatibility problems with hlint and hoogle :/
03:47:23 <ketil_> kmc: link to video: http://apfelmus.nfshost.com/blog/2010-06-01-gadts-video.html
03:49:06 <aristid> heh his name is actually apfelmus!!
03:49:32 <aristid> (apfelmus means apple puree)
03:49:32 <ivanm> wow, jdh is even cherry-picking which comments to respond to!
03:53:08 <pozic> Taejo: http://people.cs.uu.nl/bastiaan/phdthesis/index.html
03:53:21 <pozic> zygoloid: no, which approach is that?
03:53:32 <Taejo> pozic: thanks
03:56:47 <Taejo> aristid: on reddit: <apfelmus> I can recommend eating applesauce while watching this video. ;)
04:00:19 <pastorn> @pl (\f g -> do { x <- f; y <- g; lolFun x y } )
04:00:19 <lambdabot> (line 1, column 13):
04:00:19 <lambdabot> unexpected "{"
04:00:19 <lambdabot> expecting variable, "(", operator or ")"
04:00:20 <aristid> there's a small error in the phantom types version
04:00:29 <aristid> Eq (Expr a) (Expr a)
04:00:45 <aristid> Eq :: Expr a -> Expr a -> Expr a is clearly wrong :)
04:01:02 <pastorn> @pl (\f g -> f >>= (\x -> g >>= (\y -> h x y)))
04:01:02 <lambdabot> (. ((. h) . (>>=))) . (>>=)
04:01:07 <pastorn> oh shit
04:01:17 <pastorn> @type join
04:01:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:01:40 <pastorn> @type (join .) . liftM2
04:01:40 <aristid> i think it should be forall b. Eq (Expr b) (Expr b)
04:01:40 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
04:01:40 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
04:01:40 <lambdabot>     In the second argument of `(.)', namely `liftM2'
04:02:43 <pastorn> how do i deal with it? i want this: f :: (a -> b -> m c) -> m a -> m b -> m c
04:02:57 <pastorn> (and i don't have applicative, and don't want to use it either)
04:03:00 <ivanm> preflex: seen TacticalGrace
04:03:01 <preflex>  TacticalGrace was last seen on #ghc 13 days, 22 hours, 37 minutes and 35 seconds ago, saying: * TacticalGrace knows from painful experience.
04:03:10 <ivanm> :(
04:04:24 <pastorn> @pl (join $ liftM2 f g)
04:04:24 <lambdabot> join (liftM2 f g)
04:04:29 <pastorn> wow
04:04:38 <pastorn> @unpl (join $ liftM2 f g)
04:04:38 <lambdabot> ((\ e -> g >>= \ b -> e >>= \ a -> return (f b a)) >>= \ j -> j)
04:04:42 <kmc> hmm, so bang-patterns are a sugar for seq...
04:04:42 <pastorn> hehe
04:04:51 <kmc> is there any idea for a sugar for par?
04:04:57 <kmc> or is the idea that Strategies should take care of that?
04:07:59 <pozic> Is the movie of apfelmus only 32MB? How long is it? 4 minutes?
04:08:43 <Axman6> 18
04:10:42 <Axman6> it's a movie that should compress extremely well
04:12:49 <zygoloid> pozic: i can't seem to find the paper (proof normalization for better type errors is a hard thing to google for!)
04:13:35 <zygoloid> pozic: but the idea was to construct a proof that the program is ill-typed, then minimize that proof, and use the minimal proof to show the set of places where the error might lie
04:17:03 <pozic> Does this work for anyone? wget http://www.archive.org/download/ExplanationOfGeneralizedAlgebraicDataTypesgadts/GADTs.mov
04:17:21 <pozic> It seems they are low on bandwidth.
04:17:40 <aristid> i guess to avoid making too many errors you should write the text first and let it be reviewed
04:17:55 <aristid> because apfelmus found that changing the movie is hard..
04:18:34 <ivanm> OK, my comment is there now...
04:21:47 <emilmeln> Does anyone know how costly are TVars in terms of space? Specifically, I'm interested in large transactional array of small elements (1-2 bytes).
04:25:34 * hackagebot parsec-extra 0.1.0.2 - Some miscellaneous basic string parsers.  http://hackage.haskell.org/package/parsec-extra-0.1.0.2 (AriePeterson)
04:38:00 <quicksilver> emilmeln: well, everything in haskell is fairly expensive in terms of bytes.
04:38:35 <quicksilver> emilmeln: I don't know the internals of TVars but it's probably 4-8 machine words, so 16+ or 32+ bytes depending on arch.
04:45:35 <emilmeln> quicksilver: OK. I'm just trying to make a concurrent array of bits, but with behaviour like TVar (UArray Int Bool). Unfortunately, pure unboxed arrays don't allow in-place modification...
04:45:57 <quicksilver> no, you'd have to write in a whole changed array
04:46:12 <quicksilver> that might be a perfectly reasonable solution though
04:46:33 <RyanT5000> are DiffArrays recommended for that sort of thing?
04:46:42 <RyanT5000> or have they fallen into disfavor
04:47:03 <emilmeln> DiffArrays are quite slow.
04:49:28 <pastorn> RyanT5000: don't use DiffArray :)
04:49:36 <pastorn> STArray is the way to go, or so i hear
04:50:04 <RyanT5000> STArray doesn't seem like the way to go for this guy's problem, though
04:51:31 <kmc> instead of DiffArray i would use IntMap
04:51:35 <kmc> or EnumMap
04:51:49 <kmc> that will give good sharing between versions
04:52:14 <kmc> if you need super performance, you may want to drop STM (and for other reasons too)
04:54:57 <kmc> otherwise, perhaps Array Int (TVar Word64)
04:55:14 <emilmeln> kmc: But I need O(1) access to the array elements (number of elements is about 10k).
04:55:30 <kmc> > log 10000
04:55:31 <lambdabot>   9.210340371976184
04:55:55 <kmc> obviously there are unknown constant factors here
04:56:06 <emilmeln> I don't see another choice except Array Int (TVar Word64)
04:56:23 <kmc> but i wouldn't assume that IntMap is much slower than Array
04:56:26 <kmc> without profiling it
04:56:38 <kmc> for millions of keys, probably.  10,000 is not so many
04:57:56 <quicksilver> don't make any assumptions about haskell performance, just try it and see
04:57:57 <quicksilver> ;)
04:58:07 <quicksilver> as kmc says, intmaps are pretty fast.
04:58:21 <kmc> IntMap has O(1) access
04:58:35 <kmc> because there's a bound on the size of a key
04:58:35 <copumpkin> on a given machine
04:58:37 <kmc> ;)
04:59:19 * kmc really doesn't trust the relevance of asymptotic complexity for associative containers
05:00:46 <emilmeln> OK, thanks to all. I'll try to use IntMaps.
05:01:39 <kmc> emilmeln, i'm interested to see any benchmarks you make vs. arrays
05:02:04 <kmc> "criterion" is really nice for that
05:02:21 <quicksilver> kmc: and, conversely, arrays are O(log n) on real-world memory models
05:02:30 <quicksilver> what matters is real performance, of course
05:02:37 <quicksilver> not asymptotic.
05:02:49 <copumpkin> the main benefit of arrays is cache performance, I'd guess
05:03:01 <kmc> yes
05:03:06 <kmc> if you have locality in your problem
05:03:26 <copumpkin> even without, the IntMap jumps around a lot just looking up your key
05:03:41 <kmc> true
05:03:56 <kmc> i don't know if it's specifically cache-optimized like judy arrays are
05:04:04 <copumpkin> it isn't
05:04:15 <theorbtwo> The asymoptotic performance of any data storage is "you don't have infinite memory, you idiot".
05:04:15 <copumpkin> it's just using ADTs for the trie structure
05:06:31 <Starfire> Why are arrays O(log n) ?
05:07:15 <voker57> arrays or lists?
05:07:23 <zygoloid> Starfire: which arrays?
05:08:10 <Starfire> zygoloid: The ones quicksilver was referring to a while ago.
05:08:38 <zygoloid> Starfire: oh, i see. because addition is log(n).
05:09:30 <Starfire> zygoloid: Ahh. So log(n) for arbitrarily large sizes, but O(1) for machine words?
05:10:12 <Starfire> Though quicksilver was talking about memory models.
05:10:20 <zygoloid> there's also an effect from processor caches. and physically selecting between more memory units requires more fanout on the relevant signal (though that's more like log (log n) i think)
05:10:22 <quicksilver> Starfire: you can't be asymptotic "for machine words"
05:10:28 <emilmeln> BTW: why StorableArray is slower than IOUArray?
05:10:30 <quicksilver> Starfire: asymptotic means "as n tends to infinity"
05:10:38 <Starfire> Yeah, you're right.
05:10:42 <quicksilver> Starfire: you can't let "n tend to infinite" and still stay inside machine words.
05:11:08 <hpc> also, addition is always one clock cycle
05:11:15 <zygoloid> quicksilver: which particular log(n) were you referring to? :)
05:11:20 <quicksilver> hpc: not for arbitrary sized integers it isn't
05:11:33 <hpc> for machine words
05:11:36 <quicksilver> for arbitrary sized integers, addition is O(length of representation)
05:11:48 <quicksilver> and length of representation is log n, unless you have a very odd representation.
05:12:07 <hpc> we weren't talking about arbitrary integers, i don't think
05:12:30 <quicksilver> zygoloid: multiple levels of cache effects, page effects, swap effects, and address decode effects
05:12:31 <zygoloid> hpc: we were talking about asymptotics, so the integers must be able to grow arbitrarily
05:12:41 <quicksilver> hpc: of course we were, he said O(1), that's asymptotic.
05:12:53 <Starfire> Yeah, my mistake.
05:13:02 <quicksilver> if we restrict to 32-bit integers, then IntMap lookup has a constant bound
05:13:08 <quicksilver> (just like array lookup has a constant bound)
05:13:48 <kmc> emilmeln, hmm, good question.  maybe it's more trouble for the garbage collector because it has to stay in one place?
05:14:21 <quicksilver> maybe it's just the overhead of the storable instance?
05:14:31 <quicksilver> I don't know. For which operations is Storable array slower?
05:14:45 <kmc> yeah makes sense quicksilver
05:15:54 <zygoloid> possibly StorableArray copies elements a byte at a time, whereas IOUArray copies a word at a time?
05:20:11 <emilmeln> Is it (at least theoretically) possible to make a transactional chunk of memory (e.g. TVar ByteArray#)?
05:20:31 <kmc> that's not what that would be
05:20:35 <kmc> i don't think
05:20:58 <kmc> well, maybe it is in theory
05:21:06 <benmachine> STUArray?
05:21:10 <kmc> but TVar won't accept unboxed types
05:21:16 <kmc> same reason you can't have [Int#]
05:23:15 <emilmeln> Well, let it be boxed ByteArray :)
05:23:52 <zygoloid> ByteArrays are immutable, though
05:23:52 <emilmeln> The main "idea" is to monitor some memory range.
05:24:08 <kmc> emilmeln, then it's not a chunk of transactional memory
05:24:14 <kmc> it's a transactional pointer to regular, immutable memory chunks
05:24:41 <emilmeln> Oh, sorry. I meant MutableByteArray.
05:25:21 <quicksilver> emilmeln: I think you are under a fundamental misapprehension here
05:25:25 <kmc> that's still not transactional
05:25:28 <quicksilver> emilmeln: the inside of a TVar is immutable.
05:25:46 <kmc> emilmeln, TVar (Ptr a) is not a chunk of transactional memory
05:25:52 <quicksilver> in (TVar a) the contents - the value of type a - is an immutable value
05:25:58 <quicksilver> this is because all values are immutable in haskell.
05:26:01 <kmc> it's a reference cell, which is transactional, and holds a regular old pointer
05:26:04 <quicksilver> TVar isn't an exception to this rule.
05:26:09 <kmc> all values are immutable, anywhere.  by definition.
05:26:15 <quicksilver> as kmc is just explaining, TVar is like a transactional reference.
05:26:16 <kmc> things which are mutable should not be called values
05:26:22 <quicksilver> right.
05:26:45 <aristid> they should be called variable :D
05:26:53 <aristid> xslt has it the wrong way round
05:26:53 <kmc> anyway i think if you wanted a true "transactional array" it would require some support from the STM system itself
05:26:58 <zygoloid> in "TVar (Ptr a)", the thing pointed to by the Ptr could change asynchronously (from a forkIO'd thread, for instance). but the pointer itself will be transactional.
05:27:04 <kmc> @quote xslt
05:27:05 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
05:28:10 <zygoloid> of course, because you can't (or at least shouldn't) do arbitrary IO inside STM, you can't tell that the pointee has changed...
05:28:27 <emilmeln> Thanks for the explanation.
05:28:44 <emilmeln> I wanted something impossible :)
05:29:14 <kmc> i don't think it's impossible
05:29:23 <kmc> i think it's probably more trouble to get than it's worth
05:29:52 <kmc> when «TVar (IntMap Bool)» and «Array Int (TVar Word64)» are viable alternatives
05:30:15 <kmc> the former is a style of concurrent programming i try to advocate
05:30:28 <kmc> you use persistent structures with sharing between updates in an immutable lockless way
05:30:28 <emilmeln> Maybe I wanted to control transactional heap from Haskell, but this is something for hardcore hackers...
05:30:43 <kmc> and you do fast updates of mutable cells holding pointers to these
05:31:53 <zygoloid> emilmeln: i think you want TArray
05:32:18 <kmc> "It is currently implemented as Array ix (TVar e)"
05:32:22 <kmc> :(
05:32:48 <emilmeln> zygoloid: Not exactly. I want reader threads to wake up after any write th the array.
05:33:11 <temoto> emilmeln, sounds close to Chan.
05:33:14 <quicksilver> that doesn't sound like STM at all
05:33:25 <quicksilver> that sounds like an MVar with observers via a Chan
05:33:41 <quicksilver> (or skip the MVar and send the actual data direct down the Chan if you prefer)
05:33:54 <quicksilver> STM is for the case when you have concurrent updates going on and you need to guarantee consistency.
05:35:13 <emilmeln> No, what I need is something like TVar (IntMap a) or Array Int (TVar a).
05:35:37 <quicksilver> I don't see how TVar relates to "reader threads wake up after any write"
05:35:51 <quicksilver> TVar is "guaranteed consistent read"
05:35:55 <quicksilver> not "wakeup after any write"
05:36:05 <quicksilver> I'm probably missing part of your plan.
05:37:59 <Axman6> emilmeln: STM is used when you need to treat memory like a transactional database
05:38:25 <emilmeln> quicksilver: I don't explained myself correctly, my fault.
05:41:30 <quicksilver> emilmeln: that's OK :)
05:44:51 <emilmeln> And, AFAIU, any transaction will be executed atomically with respect to other transactions. What if there are two transaction groups, every group operates _only_ on it's own data. Am I right saying that transaction from one group would block not only transaction from it's own group, but also all transactions from another group?
05:46:42 <quicksilver> emilmeln: not sure what you mean by groups.
05:46:53 <quicksilver> technically STM transactions don't generally block
05:47:08 <quicksilver> they execute optimistically, and then fail at commit time if they turn out to be inconsistent.
05:47:29 <quicksilver> inconsistency is decided by keep records of all TVars accessed in the transaction.
05:47:48 <emilmeln> wait a second, i'll write sample code
05:48:05 <quicksilver> "failed" transactions in this sense are re-run automatically
05:49:47 <ivanm> preflex: seen tomberek
05:49:47 <preflex>  tomberek was last seen on #haskell 5 hours, 7 minutes and 33 seconds ago, saying: ski: hey
05:52:58 <zaarg> sorry if this is an off-topic question, but what do people think of erlang?
05:53:55 <wlangstroth> zaarg: could you be more specific?
05:54:37 <zaarg> well, i only ask because i've noticed lots of erlang job ads lately.
05:55:12 <ivanm> when is it safe to use UndecidableInstances?
05:55:23 <voker57> erlang doesn't have currying
05:55:32 <quicksilver> ivanm: it's not runtime unsafe
05:55:39 <quicksilver> ivanm: it can cause infinite compile times
05:55:44 <ivanm> hmmm...
05:55:45 <quicksilver> ivanm: (although I think there is a recursion limit in practice)
05:55:56 <ivanm> quicksilver: so if ghci can load it it should be OK?
05:56:05 <quicksilver> yes.
05:56:15 <quicksilver> overlapping and incoherent are the semantically unsound ones
05:56:26 <quicksilver> undecidable is just you being smarter than GHC's built in termination checker.
05:57:20 <ivanm> quicksilver: you see any problems with using it here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25891#a25891
05:57:42 <ivanm> it bitches about "Constraint is no smaller than the instance head in the constraint: Show (Node g)"
05:57:49 <ivanm> same for NodeLabel and EdgeLabel
05:59:02 <emilmeln> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25892
05:59:23 <quicksilver> ivanm: looks superficially OK, probably the interactions between type families and class instances will cause many such warnings..
05:59:39 <ivanm> yeah
06:00:03 <ivanm> TacticalGrace has told me that he's waiting for SPJ to finish the improved type checker + some free time from teaching, etc. to be able to improve type family support
06:00:20 <quicksilver> emilmeln: since one set of transactions only touch tv1 and hte other set only touch tv2 they will not interfere with each other.
06:00:36 <quicksilver> probably this is what you expect.
06:02:22 <emilmeln> quicksilver: OK, and what if transaction returns an IO action (e.g. sending to / receiving from socket)?
06:02:55 <ivanm> if derive was up to date, I would try getting it to do the instances for me; as it stands I would need to downgrade uniplate which I'm loath to do :s
06:03:09 <quicksilver> emilmeln: that's not relevant to anything
06:03:22 <quicksilver> it can return an IO action or a hamster
06:03:31 <quicksilver> the question is which TVars it touches
06:03:36 <quicksilver> and that's the only question.
06:03:39 <ivanm> So I just used Drift to generate them for me and am copy/pasting them in
06:04:12 <emilmeln> quicksilver: but what about an order of action execution?
06:04:23 <aristid> everybody's talking about parallelisation, but it seems like haskell also wins at other use cases: http://substack.net/posts/cb328d/Binary-Stream-Parsing-in-Node-js :D
06:04:47 <emilmeln> something like join (atomically x)
06:04:48 <quicksilver> emilmeln: if you return an IO action then it hasn't been executed
06:05:02 <quicksilver> emilmeln: you execute it after it returns, if you choose to.
06:05:22 <quicksilver> again, this is completely irrelevant to the mechanics of STM
06:05:35 <quicksilver> what do you do with the values computed after the end of the transaction is your business.
06:07:23 <kmc> :t join . atomically
06:07:24 <lambdabot> Not in scope: `atomically'
06:08:36 <kmc> right
06:08:55 <kmc> «join (atomically x)» will use «x :: STM (IO a)» to atomically determine something to do, then (outside STM and non-atomically) do it
06:09:22 <quicksilver> the execution order might be more clear if written as "do act <- atomically x; act;"
06:09:29 <quicksilver> obviously the action is run *after* the atomically
06:09:41 <quicksilver> and, being entirely irrelevant to STM, is not in any way run atomically.
06:09:59 <kmc> well it could itself contain "atomically"
06:10:04 <kmc> but that'd be a separate transaction
06:10:05 <quicksilver> of course, when an IO action is returned by an STM action you are free to wait a while before you execute it, and execute it multiple time.
06:10:39 <quicksilver> do act <- atomically x; make coffee; act; eat pizza; act; solve four colour theorem; act; act; act;
06:10:39 <aristid> :t atomically
06:10:40 <lambdabot> Not in scope: `atomically'
06:10:41 <ivanm> hmmmm..... is it wrong/bad to not include the record labels in your Show/Read instances just for the sake of brevity?
06:10:46 <ivanm> @hoogle atomically
06:10:46 <lambdabot> Control.Exception data NestedAtomically
06:10:46 <lambdabot> Control.Exception NestedAtomically :: NestedAtomically
06:10:46 <lambdabot> Control.OldException NestedAtomically :: Exception
06:10:50 <ivanm> heh
06:10:52 <ivanm> @hoogle atom
06:10:53 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
06:10:53 <lambdabot> Foreign.C.Types data CSigAtomic
06:10:53 <lambdabot> Control.Exception data NestedAtomically
06:10:53 <kmc> aristid, cool.  JavaScript, the world's most popular functional language
06:11:00 <quicksilver> ivanm: I don't think so, as long as you generate correct haskell code.
06:11:05 <aristid> kmc: not used like one :/
06:11:06 <ivanm> *nod*
06:11:12 <kmc> aristid, it is there
06:11:17 <quicksilver> ivanm: in fact, in some ways it's a little odd that the standard instances *do* include the record labels.
06:11:25 <quicksilver> ivanm: after all, record notation is supposed to just be sugar...
06:11:31 <ivanm> quicksilver: because we're going to use a list of Contexts for the new Show/Read instances for graphs in FGL, and they're verbose enough as is...
06:11:33 <emilmeln> Wow, is means one can do an arbitrary action based on some transactional data value.
06:11:34 <quicksilver> ivanm: ...but they make a semantic change to Show instances.
06:11:47 <kmc> emilmeln, sure.  IO actions are first-class values in Haskell
06:11:54 <aristid> kmc: oh, sure, and you can use it, but then you can also probably use haskell instead.
06:11:56 <ivanm> quicksilver: heh, especially since you can't change the order in the instances
06:12:00 <ivanm> whereas you can when defining them
06:12:10 <kmc> there are no restrictions on where and how you can compute IO actions, only where you can execute them
06:12:16 <kmc> aristid, confused
06:12:20 <quicksilver> ivanm: then again, almost all the derivings are evil, since they break all kinds of equational rewritings which ought to be valid.
06:12:28 <kmc> aristid, functional programming (using functions as values) is common in real-world javascript
06:12:29 <aristid> kmc: it's funny tho how the word Monad is slowly creeping into the programming mainstream.
06:12:41 <ivanm> quicksilver: true
06:12:53 <kmc> and this whole "why bother, you might as well use Haskell" is silly; there are lots of points in the design space of functional languages
06:13:16 <aristid> kmc: well, i have in fact written a library that competes with node.js
06:13:21 * geheimdienst was startled when he came across "monadic" and "dyadic" when reading about apl the other day
06:13:26 <kmc> hehe geheimdienst
06:13:52 <ddarius> geheimdienst: It also comes up in predicate logic and the pi calculus.
06:14:01 <aristid> kmc: but there are some things that make me less optimistic about the future of javascript
06:14:05 <kmc> aristid, it's funny how first-class functions are slowly creeping into the programming mainstream after three quarters of a century
06:14:13 <kmc> aristid, such as?
06:14:13 <aristid> like the lack of progress on server-side standardisation
06:14:16 <kmc> mm
06:14:33 <kmc> you mean that JS is a standard language but has no standard interface to the outside world?
06:14:38 <aristid> there's a project for it, and everybody pays lip service
06:14:50 <aristid> yea, the standard library is so tiny that most things are invented over and over
06:14:54 <aristid> usually in a bad way
06:15:27 <aristid> and while there are projects for remedying this, they seem to be stuck
06:15:38 <geheimdienst> probably 1st-class functions are like garbage collection ... academically, has been well-understood for decades, but GC only became popular with java in the 90s
06:16:18 <aristid> kmc: i was involved in trying to find a standard for binary objects (like ByteString). well, there are now Binary/A to Binary/F proposals, and some variations on them, none has been accepted
06:16:19 <emilmeln> kmc: Thanks. Suddenly I realized that I need good old MVars.
06:17:02 <kmc> emilmeln, ah :)
06:17:45 <aristid> kmc: so if i say "i'd rather use haskell", then that's because i'm disillusioned about javascript.
06:18:02 <ivanm> ugh, Read instances look so ugly...
06:18:35 <kmc> fair enough
06:19:59 <emilmeln> About Read type class: why Haskell committee hadn't adopted LISP-style read/print?
06:21:10 <Cale> ivanm: Write them using ReadP
06:21:20 <ivanm> Cale: isn't that GHC only?
06:21:28 <ivanm> then again, I suppose I'm using GHC-only extensions...
06:21:29 <Cale> Well...
06:21:32 <ivanm> >_>
06:21:47 <Cale> If you must avoid ReadP, use list comprehensions extensively.
06:21:51 <ivanm> Cale: of course, the other thing is that I'm not actually writing them per-se; I'm getting the output from DrIFT and editing :p
06:22:05 <Cale> (or perhaps list-monad do-notation of course)
06:22:23 <ivanm> yeah, just tried list monad notation; it failed :s
06:22:32 <ivanm> oh, wait, there it is
06:22:34 <Cale> Oh?
06:22:38 <Cale> okay :)
06:22:40 <Cale> :t reads
06:22:40 <lambdabot> forall a. (Read a) => String -> [(a, String)]
06:22:43 <Cale> :t readsPrec
06:22:44 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
06:22:48 <ivanm> I put extra [...] in when I shouldn't have
06:23:03 <ivanm> the big problem with ReadS IMHO is the explicit passing of new state...
06:23:09 <Cale> That's essentially  StateT String []
06:23:49 <ivanm> so, now to work out how to write ReadPrec stuff
06:24:21 <ivanm> just use readPrec rather than readsPrec ?
06:24:52 <ivanm> @type lex
06:24:53 <lambdabot> String -> [(String, String)]
06:26:06 <Cale> The ReadP library has a readP_to_S which you can use. ReadPrec is an associated library if you really care about the precedence stuff.
06:26:50 <ivanm> ooohhhh, I missed the difference between ReadP and ReadPrec
06:26:53 * Cale wonders if hackage is really being slow or if it's just his connection
06:27:44 <ivanm> grrr, it doesn't help when the Read documentation doesn't include readPrec, just says you can define it instead :@
06:27:48 <emilmeln> Why "base" library contaions ReadP parsers instead of Parsec? Is it about speed?
06:28:29 <ivanm> emilmeln: because base uses ReadP, not Parsec
06:28:38 <ivanm> (Parsec is too high-level for Read)
06:28:48 <ivanm> and Parsec is too big to include as part of Base
06:28:50 <Cale> emilmeln: ReadP is particularly convenient for writing instances of Read
06:28:53 <ivanm> and has too many features
06:29:13 <Cale> I actually like something else about ReadP: it has an efficient fair choice operator (+++)
06:29:34 <madhadron> Now, if you're using parsec anyway, and you have a peculiar external format, go ahead.
06:29:47 <ivanm> Cale: so what, I write parsers using ReadP, then how do I convert that to a ReadPrec value?
06:29:55 <madhadron> As I did about an hour ago...
06:30:00 <Cale> ivanm: lift?
06:30:08 <ivanm> madhadron: except I'm talking about writing Read instances
06:30:10 <ivanm> Cale: oh, right
06:30:25 <madhadron> ivanm, So am I.  I just happened to have some really wonky external formats.
06:30:29 <emilmeln> What's the difference between +++ and <++. For some reason a can't understand the term "symmetric choice"...
06:30:52 <ivanm> madhadron: well, I'm not using Read to parse in external formats
06:31:23 <ivanm> emilmeln: hmmm.... I have no idea :s
06:31:25 <madhadron> ivanm, Fair 'nuff.
06:31:26 <Cale> emilmeln: x <++ y means that if x succeeds at all, then y is not used.
06:31:33 <Twey> I guess +++ is empty if both are empty, the non-empty one if one is empty… but no idea what the behaviour might be if both are non-empty
06:31:49 <Cale> (y is only used if x *totally* fails)
06:31:53 <Twey> Some sort of combination of them, perhaps?
06:32:03 <madhadron> Twey, the phrase "fair choice" would indicate it's nondeterministic.
06:32:09 <ivanm> Cale: so what is the difference between ReadPrec and ReadP?
06:32:18 <Twey> I guess so
06:32:25 <Cale> ivanm: The ability to set precedence levels
06:32:27 <madhadron> ivanm, ReadPrec includes precendence.  ReadP is purely reading.
06:32:46 <ivanm> so when to parens stuff?
06:32:50 <ople_> [2 of 9] Compiling Data.FileStore.Types ( Data/FileStore/Types.hs, dist/build/Data/FileStore/Types.o )
06:32:50 <madhadron> ivanm, If you're reading simple data types, you may as well just lift a readP
06:32:51 <ople_> Data/FileStore/Types.hs:78:19:
06:32:51 <ople_>     Couldn't match expected type `ByteString'
06:32:51 <ople_>            against inferred type `bytestring-0.9.1.6:Data.ByteString.Lazy.Internal.ByteString'
06:32:51 <ople_>     In the expression: fromString
06:32:53 <ople_>     In the definition of `toByteString': toByteString = fromString
06:32:55 <ople_>     In the instance declaration for `Contents String'
06:32:57 <ople_> Data/FileStore/Types.hs:79:19:
06:32:59 <ople_>     Couldn't match expected type `ByteString'
06:33:02 <ople_>            against inferred type `bytestring-0.9.1.6:Data.ByteString.Lazy.Internal.ByteString'
06:33:02 <madhadron> ivanm, Right.  But if you have two interspersed, recursive types
06:33:03 <ople_>     In the expression: toString
06:33:05 <ople_>     In the definition of `fromByteString': fromByteString = toString
06:33:07 <ople_>     In the instance declaration for `Contents String'
06:33:09 <Twey> ople_: Er.
06:33:09 <ople_> cabal: Error: some packages failed to install:
06:33:11 <ople_> filestore-0.3.4.1 failed during the building phase. The exception was:
06:33:14 <ople_> ExitFailure 1
06:33:14 <Cale> ople_: You know, you could have just used hpaste.
06:33:16 <quicksilver> ople_: don't do that!
06:33:18 <Twey> ople_: We'd prefer it if you used a pastebin.
06:33:22 <ivanm> this is what I'm writing Show/Read instances for: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25891#a25891
06:33:34 <madhadron> You may want to control the precendence, and then you need to directly write a ReadPrec
06:33:37 <ivanm> except I'm stripping out the Record fields from the Show/Read instances for brevity
06:33:49 <ivanm> madhadron: nope, nothing recursive (or at least it shouldn't be)
06:34:17 <ivanm> ople_: I take it you have two versions of bytestring installed? that is what we in the know like to call a "bad situation"
06:34:18 <madhadron> Does anyone know if there's a way to write something like lift for monadtransformers, but which recurses all the way down a transformer stack?
06:34:18 <ivanm> :p
06:34:20 <Cale> ople_: It looks like you're using multiple ByteString libraries at once somehow, or confusing lazy and strict ByteStrings with each other?
06:34:47 * Cale really wishes that lazy bytestrings didn't have the exact same name as strict ones
06:34:53 <madhadron> ivanm, Any reason you're not just deriving?
06:35:14 <ivanm> madhadron: because the real definition uses Associated Types
06:35:19 <ivanm> and the GHC type checker can't deal with that
06:35:24 <Cale> $ cabal update
06:35:24 <Cale> Downloading the latest package list from hackage.haskell.org
06:35:24 <Cale> cabal: timeout
06:35:27 <Cale> ouch
06:35:32 <ivanm> besides, I want to strip out the record fields for brevity
06:35:34 <ivanm> Cale: :(
06:35:42 <madhadron> ivanm, Good reason.
06:35:53 <Cale> oh, there we go, it's back to working :)
06:35:53 <Schalken> Given a FilePath, how can I get the "Data.Digest.MD5.hash" of the file contents, calculated in constant space? I am having a problem with the laziness and buffers being closed before the hash string is actually evaluated.
06:35:54 <quicksilver> Cale: pretty sure it's multiple versions, not lazy/strict
06:36:08 <ivanm> madhadron: so, should I be using ReadP or ReadPrec?
06:36:16 <ivanm> or a mixture of the two?
06:36:16 <Cale> ivanm: Probably ReadP
06:36:16 <quicksilver> Cale: I don't think you get version numbers in the error messages unless mutliple versions are involved?
06:36:30 <Cale> quicksilver: That is possible
06:36:30 <madhadron> ivanm, I would use ReadP
06:36:39 <madhadron> ivanm, And just use lift to turn it into a ReadPrec
06:36:43 <ivanm> Cale, madhadron: so I wouldn't need to deal with parens or anything?
06:36:57 <madhadron> ivanm, If you don't have any in your wire format, then no.
06:37:14 <madhadron> Or rather, none that aren't tuples.
06:37:14 <Cale> ivanm: ReadPrec is more for if you're parsing an infix expression grammar (or possibly lambdas)
06:37:30 <ivanm> madhadron: about to say... ;-)
06:37:32 <ivanm> Cale: *nod*
06:37:47 <madhadron> ivanm, Understand what I mean, not what I say! (:
06:37:55 <ivanm> heh
06:39:29 <ople_> ivanm: you are right
06:40:06 <ivanm> ople_: well, you want to uninstall the one that _doesn't_ come with GHC (most probably the newer one)
06:40:07 <madhadron> Schalken, One of the head normal form functions?
06:40:14 <ivanm> and then rebuild whatever was built against it
06:40:15 <Twey> Is there any way with Data.Typeable to check if a TypeRep has an instance for a particular class?
06:40:33 <madhadron> Schalken, Or a function like deepSeq?  Not stuff I'm deeply familiar with, but you basically just have to force it.
06:40:54 <quicksilver> Twey: no. types and classes exist at compile-time, not run-time.
06:41:07 <Cale> Oh, hey, bloodknight uses MonadRandom, so a tiny bit of my code is already in there ;)
06:41:14 <ivanm> madhadron: is there some "(Read a) => ReadPrec a" parser?
06:41:20 <ivanm> i.e. how do you prse sub-components?
06:41:23 <quicksilver> (sure, TypeReps exist at runtime but they're not really types, they're a hack ;)
06:41:35 <madhadron> ivanm, Call read or readPrec?
06:41:45 <ivanm> madhadron: aren't they the wrong type though?
06:41:48 <madhadron> And let type inference take care of it?
06:42:01 <madhadron> If you call them in a context where they have the right type, you should get the right instance.
06:42:15 <ivanm> or do I need "readS_to_P read" or something?
06:42:27 <madhadron> So if you have a simple type like Constr Int
06:42:30 <ivanm> @type readPrec
06:42:31 <lambdabot> Not in scope: `readPrec'
06:42:37 <ivanm> @hoogle readPrec
06:42:37 <lambdabot> Text.Read readPrec :: Read a => ReadPrec a
06:42:37 <lambdabot> module Text.ParserCombinators.ReadPrec
06:42:37 <lambdabot> Text.ParserCombinators.ReadPrec data ReadPrec a
06:42:45 <madhadron> You could probably just lex for the Constr, then readPrec on the int
06:42:49 <ivanm> wouldn't I need an un-lift?
06:42:58 <ivanm> madhadron: except it takes 4 values
06:43:28 <zygoloid> @type do h <- System.IO.openFile "foo.txt" System.IO.ReadMode; c <- System.IO.hGetContents h; let { md5 = ?hash c }; length md5 `seq` System.IO.hClose h; return md5
06:43:28 <lambdabot> forall a. (?hash::String -> [a]) => IO [a]
06:43:31 <madhadron> ivanm, Should scale up as you would expect.  I just gave the simple case.
06:43:32 <zygoloid> Schalken: ^^ something like that might work
06:43:54 <ivanm> @hoogle lex
06:43:54 <lambdabot> Prelude lex :: ReadS String
06:43:54 <lambdabot> Text.Read lex :: ReadS String
06:43:54 <lambdabot> Text.Read.Lex lex :: ReadP Lexeme
06:43:59 <madhadron> ivanm, And unlifting shouldn't really be necessary.  Just get a value by hook or crook.
06:44:08 * ivanm is confused
06:44:10 <zygoloid> though to be sure you should probably use pseq rather than seq
06:44:16 <madhadron> If you know the next thing in your stream should be an Int, just read the Int the way you normally would
06:44:22 <zygoloid> and maybe rnf too :)
06:44:50 <emilmeln> What is "linear implicit parameters"? What distinguishes them from usual implicits?
06:44:54 <ivanm> madhadron: except you and Cale said to use ReadP, which doesn't seem to have a way to read in an Int or something :s
06:45:23 <zygoloid> emilmeln: linear implicit parameters implicitly invoke split :: a -> (a, a) if they're used more than once
06:45:25 <Cale> readS_to_P
06:45:46 <madhadron> ivanm, Ah, I see.  case readPrec s of [(nextInt,rest)] -> ...; [] -> fail
06:45:47 <emilmeln> Also, what is "type operators". I haven't found documentation in GHC manual for them.
06:45:55 <madhadron> bbs
06:46:00 <ivanm> Cale: right, that's what I thought; I just figured that there would have been a default "readS_to_P reads" since people would need that quite often...
06:46:06 <Cale> emilmeln: Infix type constructors
06:47:39 * Cale starts to get mildly irritated that this makefile isn't aware of cabal ;)
06:47:45 <emilmeln> zygoloid: this is only for random values?
06:49:15 <Cale> emilmeln: If implicit parameters are "implicit reader monad", then linear implicit parameters are "implicit supply/state monad"
06:49:33 <Cale> emilmeln: You don't have to worry about them because GHC doesn't support them anymore
06:50:19 <emilmeln> Cale: this is exactly the reason why I'm asking about them :)
06:50:29 <ivanm> grrr.... my ReadP value is bitching about infinite type :s
06:50:32 <Cale> oh
06:50:58 <ivanm> @type readS_to_P reads
06:50:59 <lambdabot> Not in scope: `readS_to_P'
06:51:09 <ivanm> @type Text.ParserCombinators.ReadP.readS_to_P reads
06:51:10 <lambdabot> forall a. (Read a) => Text.ParserCombinators.ReadP.ReadP a
06:51:21 <emilmeln> And yes, compared to LISP dynamic variables, Haskell's implicits are awesome!
06:51:38 <quicksilver> emilmeln: no they aren't.
06:51:41 <ivanm> oh, I needed to give a type sig to my readP function defined in the where
06:51:48 <quicksilver> emilmeln: implicit parameters are an ugly misfeature
06:51:55 <quicksilver> emilmeln: they don't scale and they don't compose
06:52:00 <quicksilver> and they break equational rewriting.
06:52:12 <Axman6> what are implicit parameters?
06:52:44 <Twey> > let f n = n * ?m in let ?m = 5 in f 2
06:52:44 <lambdabot>   10
06:52:49 <Twey> That's an implicit parameter
06:52:51 <Cale> quicksilver: Do lisp's dynamic variables satisfy any of those properties? ;)
06:52:59 <Twey> :t let f n = n * ?m in f
06:53:00 <lambdabot> forall a. (Num a, ?m::a) => a -> a
06:53:02 <Twey> They appear in the type
06:53:21 <Cale> Dynamic scope is a broken idea.
06:53:39 <quicksilver> Cale: I judge lisp by different standards.
06:53:39 <emilmeln> quicksilver: really? I thought they would be fine with lots of small functions sharing some common variables...
06:53:44 <Twey> Yeah…
06:54:08 <Jonno_FTW> hey, how can I make edit the chain' function to only need one argument" http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25893#a25893
06:54:13 <quicksilver> Cale: in haskell I value the property that subexpressions are subexpressions, and have a principal type, and this principal type tells me interesting information about re-using the subexpression.
06:54:13 <ople_> ivanm: how to uninstall with cabal
06:54:20 <ivanm> ople_: you can't
06:54:29 <quicksilver> Cale: since lisp doesn't have types I don't really think along those lines.
06:54:36 <Axman6> Twey: woah... that works? o.O
06:54:38 <ivanm> ople_: "ghc-pkg list bytestring" to get the installed ones
06:54:46 <Axman6> that's ... horrible :|
06:54:57 <Cale> quicksilver: But even if lisp doesn't have a type system as such, you still need to think about the types of things.
06:55:04 <Twey> Axman6: Not any more :-D
06:55:04 <quicksilver> Cale: lisp dynamically scoped variables are like the "withColour red $ do foo" construct you get in, for example, a graphics combinator system
06:55:09 <Cale> (In fact, probably more than you do when writing Haskell code)
06:55:15 <Twey> Jonno_FTW: Well, you can stick 'em in a tuple…
06:55:16 <ivanm> ople_: then "ghc-pkg describe bytestring-<version>" to get all the installed files
06:55:22 <quicksilver> Cale: (or at least, they're used for that kind of thing)
06:55:30 <ivanm> "ghc-pkg unregister bytestring-<version>" to make GHC forget about it
06:55:40 <ivanm> and then delete the directories listed
06:55:47 <quicksilver> Cale: if you think of them that way - and exercise appropriate disciplines to use them that way - and think of the lisp dynamic state as an implicit monad, then they're usable.
06:55:48 <ivanm> ople_: and don't ever do "cabal upgrade" again!
06:56:06 <Jonno_FTW> Twey: i just want to be able to map it over a list, without having to use chain x []
06:56:18 <ople_> ghc-pkg list|grep byte
06:56:19 <ople_>     bytestring-0.9.1.4, bytestring-csv-0.1.2, cgi-3001.1.7.1,
06:56:19 <ople_>     bytestring-0.9.1.6, cautious-file-0.1.5, cgi-3001.1.7.1,
06:56:45 <quicksilver> looks a bit like one version installed global and one version installed local?
06:56:58 <Twey> Jonno_FTW: Why don't you pass those parameters in ‘chain’, then?
06:57:02 <quicksilver> since cgi appears twice at identical versions I deduce those are different pacakge dbs.
06:57:59 <ivanm> ople_: which version of GHC do you have?
06:58:19 <Jonno_FTW> Twey: since chain x = M.integral $ chain' x [] , gives a type error
06:59:07 <BONUS> interesting: mappend for Logic values reminds me of ropes
06:59:09 <ivanm> @tell tomberek I think I have Show and Read working properly for _all_ Contexts (i.e. no need to define it per-instance)! \o/  Let me clean them up a bit more tomorrow night, then I'll push them
06:59:10 <lambdabot> Consider it noted.
06:59:20 <benmachine> I managed to break all of my dph libraries by reinstalling random
06:59:26 <Twey> Jonno_FTW: I think you want chain = M.integral $ flip chain' []
06:59:31 <ople_> ghc-6.10.4   in ports on FreeBSD
06:59:42 <Twey> integral needs a function
06:59:52 <benmachine> oh yeah, and hmatrix
06:59:57 <benmachine> which won't reinstall because
06:59:57 <benmachine> configure.hs: user error (Pattern match failure in do expression at configure.hs:98:4-13)
07:00:11 <benmachine> I love friendly error messages
07:00:23 <FunctorSalad> hahaha
07:00:25 <ivanm> ople_: OK, then yeah, you want to get rid of bytestring-0.9.1.6
07:00:35 <ivanm> benmachine: :o
07:00:37 <Twey> Friendly error messages are a myth ☺
07:00:39 <Jonno_FTW> Twey: that gives a type error as well
07:00:41 <ivanm> benmachine: which version is that?
07:00:55 <benmachine> ivanm: 0.9.3.0
07:01:00 <benmachine> cabal install
07:01:03 <ivanm> @remember Twey Friendly error messages are a myth ☺
07:01:03 <lambdabot> It is forever etched in my memory.
07:01:19 <ivanm> benmachine: installed for me here (not via cabal-install though)
07:01:26 * ivanm -> land of nod
07:01:28 <ivanm> g'night all
07:01:32 <ople_> how to get the rid of bytestring
07:01:40 * benmachine tries Setup.lhs and it works
07:01:47 <ivanm> ople_: I already told you how!
07:01:50 <benmachine> how odd
07:02:02 <ivanm> ople_: then "ghc-pkg describe bytestring-<version>" to get all the installed files
07:02:06 <ivanm> "ghc-pkg unregister bytestring-<version>" to make GHC forget about it
07:02:12 <ivanm> and then delete the directories listed
07:02:17 <ivanm> ople_: and don't ever do "cabal upgrade" again!
07:02:21 <ivanm> ^^ WHat I said earlier
07:02:50 * benmachine blinks
07:03:02 <benmachine> I have two versions of Cabal installed
07:03:02 <FunctorSalad> WTF is this comment about dog training? http://www.kimbly.com/blog/000263.html
07:03:10 <benmachine> this is possibly not a great idea
07:03:11 <ivanm> benmachine: that's OK
07:03:16 <benmachine> oh ok
07:03:18 <FunctorSalad> you think it's a markov chain at first, but it's *slightly* too coherent for that
07:03:21 <ivanm> benmachine: Cabal is the only library that ships with GHC that you can safely upgrade
07:03:34 <benmachine> but cabal-install is using 1.8.0.2 whereas runhaskell Setup.lhs is using 1.8.0.4
07:03:39 <benmachine> the latter works the former doesn't
07:03:45 <ivanm> FunctorSalad: spam methinks
07:04:01 <ivanm> FunctorSalad: you have one by "free games", another about ugg boots, then jordan shoes, etc.
07:04:18 <ivanm> benmachine: then rebuild cabal-install so it'll use the new version of Cabal
07:04:32 <Twey> It looks like someone's substituted some keywords into the output of the Postmodernism Generator
07:04:37 * benmachine cabal install cabal-install
07:04:40 <ivanm> benmachine: there's probably a bug in 1.8.0.2 that affects hmatrix that .4 fixes
07:04:44 <FunctorSalad> ivanm: but why'd a spammer take the time to write a pseudo-markov-chain manually? ;)
07:04:44 <ivanm> Twey: heh
07:04:52 <benmachine> it installed random-1.0.0.2
07:04:54 <ivanm> FunctorSalad: probably stole one from elsewhere
07:04:58 <ivanm> benmachine: stop it!
07:05:08 <benmachine> ivanm: too late :x it's only like three files
07:05:11 <ivanm> wait, actually, random might be safe...
07:05:19 <benmachine> no it broke everything last time
07:05:21 <ivanm> no, I lie
07:05:24 <benmachine> oh
07:05:26 <ivanm> benmachine: cabal install cabal-install --reinstall <-- that should do it...
07:05:31 <benmachine> nothing is any more broken than it was before
07:05:42 <EvanR-work> you guys should stop breaking haskell!
07:05:46 <benmachine> fuck, it installed random *again*
07:05:48 <ivanm> benmachine: what version of GHC do you have?
07:05:52 <benmachine> 6.12.1
07:05:57 <ivanm> benmachine: what does "ghc-pkg check" say?
07:06:05 <ivanm> maybe it's rebuilding random because something else is broken
07:06:13 <benmachine> ivanm: that hmatrix and the dph libraries are broken
07:06:15 <ivanm> try "cabal install cabal-install --dry-run -v"
07:06:23 <ivanm> benmachine: the dph libraries are? :o
07:06:24 <ivanm> why?
07:06:26 <benmachine> cabal-install upgraded itself ages ago
07:06:29 <benmachine> they depend on random
07:06:34 <benmachine> whose package ABI hash changed
07:06:40 <FunctorSalad> I had problems with random reinstalling itself too
07:06:42 <benmachine> or whatever it is
07:06:44 <ivanm> ugh
07:06:53 <FunctorSalad> what is it?
07:06:56 <FunctorSalad> and network!
07:07:01 <ivanm> no idea sorry :s
07:07:01 <benmachine> hmatrix seems to be installing now though
07:07:04 <ivanm> and I should hit the sack
07:07:06 <ivanm> g'night all
07:07:08 <benmachine> yes good night
07:07:13 <FunctorSalad> good night
07:07:29 <yottis> anyone been successful in installing berp with cabal here?
07:07:40 <FunctorSalad> it's really annoying because it breaks all the packages that depended on the other ABI, apparently :((
07:07:41 * benmachine unregisters the old broken hmatrix
07:08:09 <ivanm> yottis: should be fine if you have GHC 6.10.x (there's a bug/problem with 6.12 apparently that stops language-python from working)
07:08:13 <benmachine> FunctorSalad: reinstall stuff and then reinstall it again :P
07:08:32 <yottis> or rather, the problem seems to be language-python. it triggers happy to be installed (via some dependency's dependency i assume), happy pukes a whole bunch of warnings but afaik it gets installed
07:08:46 <yottis> but language-python still wants to install it again
07:08:59 <yottis> i've got ghc 6.10.4
07:09:03 <benmachine> is it on your PATH?
07:09:15 <benmachine> does your path have a ~ in it
07:09:15 <yottis> the happy binary?
07:09:18 <benmachine> yes
07:10:07 <yottis> oh, i didn't
07:10:13 <gio123> z
07:10:14 <yottis> now i get cabal: alex is required but it could not be found.
07:10:17 <yottis> funkyness
07:12:17 <hpc> is there a reason C code needs to be compiled by GHC for Haskell calls to work?
07:12:31 <hpc> or more specifically, what is the reason
07:12:56 <quicksilver> I don't believe it does, no
07:13:02 <quicksilver> just needs to be linked by ghc.
07:13:59 <hpc> ah
07:15:22 <quicksilver> there might be some conveniences enabled by compiling with ghc, like getting the include path right or something (I'm not sure)
07:20:02 <Cale> Well, also the minor convenience that you get to pass the .c files directly on the commandline, rather than compiling them as a separate step ;)
07:20:04 <yottis> ah, awesome, got it working
07:20:48 <yottis> the problem was that the original cabal was compiled locally, and cabal updating cabal put the new binary in a different directory which was later on in the path
07:21:04 <yottis> apparently that caused some peculiar side effects
07:28:01 <ksf> hmmm
07:28:17 * ksf is wondering about how to send multiple streams over iteratees
07:28:58 <ksf> e.g. in a http pipeline, should I send a "now you're going to get another reply" stream message, or re-start the whole iteratee?
07:30:02 <ksf> there's the question on when and how to send the headers, too
07:30:43 <ksf> maybe iteratees should come with session types by default
07:31:13 <quicksilver> haha.
07:31:42 <Cale> Wow, that's quite a suggestion ;)
07:32:00 <Cale> I think that might actually make them more convenient at the type level than they already are ;)
07:33:51 <ksf> my gripe with this is that if I have say enumHttp :: Iteratee m a -> m (Iteratee m a), I can't make it into enumHttp :: (Header -> Iteratee m a) -> m (Iteratee m a) without breaking the interface
07:41:30 <ksf> I'm going to need to extend the Stream type anyway, to send flushes for gather output
07:42:25 <ksf> which reminds me... did I already mention that haskell sucks wrt. extensible datatypes?
07:47:11 <kamatsu> ksf: what's wrong with existential quantification and a typeclass?
07:48:06 <ksf> writing the data types to plug in there
07:48:11 <ksf> in general, the expression problem
07:48:34 <ksf> I've seen papers who allegedly solve it, but so far nothing has hit hackage, afaik.
07:49:19 <ksf> if typefams could deal with class contexts, the right adt could be chosen automagically, at least.
07:53:03 <gwern> chrisdone: your surmise is correct
07:53:07 <chrisdone> gwern: lol
07:53:18 <chrisdone> i like that. that's a good idea
07:55:10 <zark4711> (newbe) i have f :: a -> State s b; i want f' :: Maybe a -> State s (Maybe b); is there a funciton for that? sometimes i just dont see the solution, even when it's easy. liftM looks kinda like what i want. i am not shure.
07:55:14 * hackagebot console-program 0.1.0.2 - Interprets the command line and a config file as commands and options  http://hackage.haskell.org/package/console-program-0.1.0.2 (AriePeterson)
07:55:15 <ksf> hey I could even require the iteratee to send a special message back to aknowledge that it knows that it's dealing with another reply in the pipeline, now, so there's at least dynamic safety.
07:55:18 <chrisdone> on tryhaskell.org's Google Analytics I have a goal of >1 minute set, there have been 883 goal conversions since launching. I wonder how many of them had a look at the Real World Haskell book and downloaded GHC as a result
07:55:47 <jmcarthur> :t liftM Just
07:55:48 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m (Maybe a1)
07:55:49 <ksf> I didn't.
07:56:10 <jmcarthur> :t (liftM.liftM) Just
07:56:11 <lambdabot> forall (m :: * -> *) a1 (m1 :: * -> *). (Monad m, Monad m1) => m (m1 a1) -> m (m1 (Maybe a1))
07:56:20 <ksf> At least I _think_ I installed 6.12.1 before trying tryhaskell
07:56:29 <jmcarthur> oh i misread
07:57:20 <jmcarthur> zark4711: it looks to me like your second type would unify with the first already
07:59:11 <edwardk> hrmm any ideas how to trick TH into being happy with something vaguely like the following? http://paste.lisp.org/display/111063#1
07:59:20 <zark4711> jmcarthur: ah, because i wrote type variables. that was wrong i should have used SomeTypeA and SomeTypeB instead of a and b
07:59:27 <jmcarthur> aha
07:59:47 <edwardk> template haskell flips out because it can't find all the instances while it is giving me the instances. if i try adding as extra contexts for the instances, it doesn't see them
08:00:26 <ksf> edwardk, put them into another file?
08:00:31 <zark4711> jmcarthur: hmm. i think i will write the appropriate function by and and then i possibly see, what builtin function it matches
08:00:34 <ksf> it might not see the ones in the file it's called in.
08:00:45 <jmcarthur> :t maybe $ return Nothing
08:00:46 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> m (Maybe a1)) -> Maybe a -> m (Maybe a1)
08:00:52 <jmcarthur> wrong
08:01:14 <edwardk> ksf: well, the problem is its defining a whole numerical tower for me, so i'd need several files each containing one line of template haskell
08:01:20 <edwardk> for each use case
08:01:30 <edwardk> hardly feels like TH is saving me any work in that case ;)
08:01:47 <jmcarthur> :t maybe (return Nothing) . (liftM.liftM) Just
08:01:47 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m a) -> Maybe a1 -> m (Maybe a)
08:01:54 <jmcarthur> there we go
08:02:00 <zark4711> cool
08:02:15 <jmcarthur> @unpl maybe (return Nothing) . (liftM.liftM) Just
08:02:15 <lambdabot> (\ c -> maybe (return Nothing) (liftM (liftM Just) c))
08:02:20 <jmcarthur> not helpful
08:02:20 <edwardk> ksf: its problem is it doesn't see the instance for Show ($t a), Eq ($t a) when it goes to define one for Num ($t a)
08:02:37 <jmcarthur> :t \f -> maybe (return Nothing) (liftM Just . f)
08:02:38 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m a) -> Maybe a1 -> m (Maybe a)
08:02:51 <jmcarthur> maybe a little easier to see what's going on there
08:03:17 <quicksilver> edwardk:  you want an unchecked TH which outputs to a file which you later compile
08:03:23 <quicksilver> edwardk: something like explicit staging.
08:03:45 <edwardk> quicksilver: either that, or i could just build the TH fragment by hand, perhaps the quasiquotation is what is causing it to flip out
08:04:28 <edwardk> quicksilver: because when it typechecks the quotation it doesn't know about all the information about $t
08:05:46 <edwardk> i was hoping to avoid turning that chunk of code into a bunch of explicit TH juju though as I know I won't be able to maintain the result in 3 months that way ;)
08:06:40 <zark4711> thank you very much
08:07:26 <triyo> I tried compiling the head ghc on my mac os x, I followed the instructions as per docs. Unforinatelly I got an error during the build as far as I can tell.
08:07:45 <quicksilver> edwardk: I think I'd personally generate haskell source
08:08:01 <quicksilver> edwardk: ...but then I'm unfamiliar with TH, so perhaps I don't see the TH way
08:08:24 <edwardk> quicksilver: if i have to fall back on CPP i'll feel like i'm cheating ;)
08:08:38 <triyo> here is a snippet of the error I got: http://codepad.org/VINeOfTk
08:09:03 <quicksilver> edwardk: I didn't mean CPP; I meant a haskell executeable which generates .hs code which you then compile
08:09:28 <triyo> I tried "make framework-pkg", and I tried normal "./configure --prefix=... && make install"
08:09:39 <triyo> both gave me errors
08:10:23 <triyo> I am trying to get head ver in order to play around with the DPH package.. :(
08:11:33 <applicative> triyo, I installed 6.13, but maybe I was lucky... What ghc are you using to build it?
08:12:53 <triyo> applicative: I have 6.10.4
08:13:33 <applicative> the one from macports that builds x86_64_apple_darwin?
08:14:05 <applicative> I see you are building a x86_64_apple_darwin of the head ghc
08:14:06 <triyo> correct, that exact reason I went for the macports ver at the time
08:15:49 <applicative> yeah, i did too, but when i reinstalled the os i went for the other since it's 6.12.  but it doesn't seem like that difference can be the source of  the  problem.
08:17:46 <applicative> i'm afraid that's the limit of my wisdom, 'it builds with the os x platform installer'...
08:18:36 <triyo> applicative: Haskell platform, does that contain 64bit build?
08:18:47 <applicative> triyo, no that's the downside
08:19:02 <triyo> hmm, I'm stuck ;)
08:19:32 <applicative> triyo, i just wonder if getting the 64 to work involved all kinds of cleverness, and something is missing here.
08:20:04 <BMeph> zark4711, jmcarthur  Check this:
08:20:43 <BMeph> :t Data.Traversable.traverse
08:20:44 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
08:20:51 <triyo> perhaps so, I'll need to flip a few switched here and there and see if it makes a difference
08:21:00 <jmcarthur> lol
08:21:02 <applicative> triyo, but i don't have much wisdom, as I said, maybe it would be obvious what to do to someone who works with HEAD a lot.  ... llike bos who just got on.
08:21:05 <jmcarthur> i always forget about that one
08:21:26 <jmcarthur> of course... i don't know if State is an instance of Applicative
08:21:35 <jmcarthur> but i think there is a monad version too
08:21:49 <BMeph> :t Data.Traversable.traverse (f :: a -> State s b)
08:21:50 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr (State s b))
08:21:50 <lambdabot>       from the context ()
08:21:50 <lambdabot>       arising from a use of `f' at <interactive>:1:27
08:22:06 <jmcarthur> :t Data.Traversable.traverse (undefined :: a -> State s b)
08:22:07 <lambdabot> forall a s b (t :: * -> *). (Data.Traversable.Traversable t, Applicative (State s)) => t a -> State s (t b)
08:22:12 <triyo> applicative: thx, I'll try to chat to bos and see if he can shed some light on this.
08:22:12 <hpc> i've used <$> to lift a function over StateT before, so it should be an applicative
08:22:15 <jmcarthur> yeah, no instance
08:22:22 <jmcarthur> hpc: you mean a Functor
08:22:33 <hpc> :t (<$>)
08:22:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:22:38 <hpc> oh :(
08:22:40 <hpc> my mistake
08:25:40 * ksf likes linux. all the 64bit pain was gone a couple of months after the amd64 got out
08:25:40 <triyo> bos: I am having a tough time installing ghc head ver on a Mac OS X 10.6.3. Are there know problems getting the x64 build to succeed?
08:26:00 <dayz> hi
08:26:12 <dayz> if a constant c is of type T, would it be correct to say c is an element of T?
08:26:25 <bos> triyo: i am sure i wouldn't know
08:26:31 <ksf> dayz, sure
08:26:44 <triyo> bos: ok, no prob.
08:26:45 <ksf> types are sets of values
08:26:56 <ksf> and kinds are sets of types
08:27:03 <ksf> and sorts are sets of kinds
08:27:17 <dayz> i see
08:27:42 <dayz> but why is the : notation usually, e.g., c : T?
08:27:48 <dayz> why not c \in T?
08:27:50 <ksf> but then, typeclasses are sets of types in a sense, too.
08:28:12 <ksf> because : is type theory, not set theory
08:28:34 <ksf> it's like asking "but why is := spelled =?
08:28:41 <ksf> ="?
08:29:01 <chrisdone> O_O
08:29:18 <dayz> ksf, hmm i'm not sure, actually...
08:29:22 <ksf> you might see \elem in inferrence rules
08:29:42 <Cale> dayz: Pretty much just tradition.
08:30:14 <applicative> dayz, c:T , or c :: T in Haskell is often pronounced "c has type T" but there's no reason not also to put it in the language of sets; it just that this is more specific
08:30:15 <sclv> edwardk: have you played with the cofree comonad over reader?
08:30:17 <ksf> as for a rationale, it might be that wrt. curry-howard, some author wanted to constrain \elem to the value level
08:30:57 <Cale> dayz: Well, and the fact that you have some collection of terms and some collection of types, and you typically define an arbitrary relation between them which corresponds to type ascription, and you don't necessarily set things up in such a way that it's natural to treat types as sets of terms.
08:31:00 <edwardk> sclv: at one point
08:31:03 <ksf> in Agda, you often see things like T : Set, as Set is the basic kind
08:31:05 <sclv> i just realized that its an incremental fold :-)
08:31:17 <edwardk> sclv: =)
08:31:31 <applicative> dayz, as ksf says, in Haskell, some of the language of sets is used about lists and the data type Set a
08:31:32 <dayz> i see
08:31:36 <triyo> applicative: now that I have a look, even though build failed, ghc got compiled and seems to work, however, ghci executable fails on start.
08:31:55 <edwardk> sclv: i have a code fragment from showing that to copumpkin around here somewhere
08:31:57 <applicative> triyo, I'll be d*mned! good work
08:31:59 <ksf> and : is abused as list constructor
08:32:05 <ksf> so we got stuck with ::
08:32:19 <triyo> so it "sort of" built, but not all the necessary packages
08:32:28 <edwardk> sclv: i believe it is present in comonad.com/haskell/Origami.hs
08:32:31 <applicative> not the par one?
08:32:36 <applicative> par ones.
08:33:34 <edwardk> sclv: but yeah, that cofree comonad describes a Moore machine
08:34:03 <dayz> basically, I have received reviewers' feedback on a paper. The reviewer complained of confusing notation I used for a proof.
08:34:07 <applicative> triyo, you can use your existing cabal with flags to demand that this ghc, wherever it is build things.  I don't know if you could get it to build e.g. ghc-haskeline
08:34:30 <dayz> the proof is presented in verbose form, and uses o :: Obj type of notation
08:34:38 <sclv> are all comonads arrows?
08:34:45 <Cale> sclv: in a sense, yes
08:34:46 <triyo> applicative: exactly my thoughts, I'll give that a try
08:34:52 <edwardk> sclv: sure, cokleisli arrows
08:35:08 <Cale> sclv: If w is a comonad, then the types "w a -> b" form an arrow
08:35:09 <edwardk> sclv: you can make their comonadic "actions" into arrows in that sense
08:35:23 <applicative> triyo, but i think if it didn't install the data-parallell libraries, i don't know how you install them, must involve a lot of c flags and stuff
08:35:50 <sclv> gotcha
08:36:56 <triyo> applicative: ghc-pkg list prints just to pkgs: ffi and rts,
08:37:13 <edwardk> bbiab
08:39:40 <applicative> triyo, damn that does seem hopeless, mine seems to have built most of the libraries that are now in the platform.
08:41:15 <triyo> applicative: yup, pretty hopeless indeed. I'll try to see if there are any useful config options I can pass in before build that might help..
08:43:45 <applicative> triyo, yeah, i'm clueless, the only other thing I can think of is to study the macports or fink file and see what hoops they had to jump through to get it to build 64 bit
08:45:07 <applicative> triyo,  but it can't be trivial, otherwise gcollins would have cut and pasted for a macports 6.12
08:45:31 <triyo> applicative: yup, that might be a good idea to have a look at macports x64 port, thx.
08:48:25 <triyo> got to run, I'll be back later with the status of my x64 build on my Mac
08:48:32 <ksf> then I've already got Int -> m (Iteratee m a) in addition to the vanilla Stream -> Iteratee m a, unifying those and allowing them to take no argument at all seems like a good idea.
08:49:30 <ksf> and I need moar typeclasses. I'm sick and tired of refactoring thousands of functions on every change to the iteratee adt
08:58:51 <Saizan> maybe you just need an API rather than typeclasses
08:59:14 <Baughn> Is it possible to use TH to remove a binding from the module environment?
09:00:19 <chrisdone> let x = 10 in x * x -- is `x' here a constant? people might call it a variable but... it don't vary
09:00:23 <Baughn> ..also, is there a ParsecT anywhere?
09:00:33 <Baughn> chrisdone: It's a binding.
09:00:40 <Saizan> Baughn: yup, see parsec-3
09:00:45 <chrisdone> binding. that'll do
09:01:11 <Saizan> i'd call "x = 10" a binding, and x a bound variable
09:01:31 <chrisdone> Saizan: but what's variable about it?
09:01:51 <Baughn> Saizan: Yay
09:02:06 <ksf> "variable" and "constant" are a moot distinction given that you can convert any let into a function and vica-versa
09:02:12 <ksf> er lambda
09:02:15 <Baughn> I reserve "variable" for TVars, MVars, IORefs and such
09:02:16 <Twey> chrisdone: It does vary
09:02:26 <chrisdone> how?
09:02:33 <ksf> the real difference is between -> -typed values and those who aren't.
09:02:41 <Saizan> for the rest of the body it might as well vary, since you've abstracted over its value
09:02:42 <Twey> > let f x = let n = x + 2 in n * 3 in (f 3, f 4)
09:02:43 <lambdabot>   (15,18)
09:03:00 <Twey> For the first call, ‘n’ is 5; for the second, it's 6
09:03:05 <Twey> It varies between calls
09:03:06 <chrisdone> that varies. i'm talking about mine
09:03:15 <Baughn> \s -> s { foo = bar } -- Also, please tell me there's a simpler way to say this
09:03:22 <chrisdone> Baughn: nope!
09:03:25 <Twey> It's a constant variable ;)
09:03:26 <ksf> Baughn, fc-labels
09:03:30 <Twey> It *can* vary, ergo it's a variable
09:03:38 <Twey> The fact that it doesn't isn't very relevant
09:03:39 <chrisdone> apart from the glorious fclabels, yes :p
09:03:42 <djahandarie> Baughn, not without crazy extension junk which I don't like using
09:03:46 <ksf> ...at least that seems to be what the cool guys are using
09:03:49 <djahandarie> Can't records do something nice with that as well?
09:03:53 <ksf> there's also data-accessor and lenses
09:03:53 <Baughn> djahandarie: Givveee meeeee
09:04:14 <Baughn> ksf: fc-labels, data-accessors.. yeah, I know about those
09:04:14 <chrisdone> Twey: ah that's a good way of putting it
09:04:40 <djahandarie> http://hackage.haskell.org/package/records
09:04:43 <ksf> that'd be "set foo bar"
09:04:57 <Baughn> ksf: I've been trying to hack the GHC type-checker (and why is the code in /there/) to refrain from putting selector functions into the global environment while still letting me use the syntactic versions, but no luck so far
09:05:28 <Baughn> ..or rather, it doesn't really make sense for it. Wiring lenses directly into GHC woudl work better, I think.
09:05:53 <ksf> fc-labels looks quite nice
09:06:05 <ksf> ...the TH part could go into ghc
09:06:34 <Baughn> ksf: It's not as simple as you'd think..
09:06:56 <Baughn> One really wants to allow foo{bar,baz} record-puns while still making the selectors lenses
09:08:18 <Baughn> Hum, fc-labels looks better than data-accessors though.
09:09:29 <ksf> is records usable in practice, that is does it refrain from throwing non-iductivity errors at you all the time?
09:09:42 <ksf> oh, and it's virtually impossible to google for.
09:09:43 <djahandarie> Not sure
09:09:52 <djahandarie> Yeah, poor name choice
09:10:37 <ksf> hackage should just rename packages to the md5 of the name if it can find it in /usr/share/dict
09:14:15 <chrisdone> preflex: seen BONUS
09:14:15 <preflex>  BONUS was last seen on #haskell 2 hours, 15 minutes and 8 seconds ago, saying: interesting: mappend for Logic values reminds me of ropes
09:14:32 * ksf would like to see a records vs. HList comparison
09:15:07 <djahandarie> I haven't ever seen anyone actually use HList, but I've heard it mentioned in here a couple of times
09:15:20 <djahandarie> Are there any projects that I can look at?
09:15:41 <ksf> there's eg the OOHaskell paper
09:15:56 <Baughn> Does anyone know how to make cabal-install/haddock actually generate source links?
09:15:59 <gwern> djahandarie: actually, aavogt recently created an arrows-based xmonad config which uses hlist for its type-level 'if'. or something like that
09:16:02 <ksf> I think it suffered from performance problems, at least in the beginning
09:16:06 <ksf> too many typeclasses
09:16:15 <gwern> Baughn: can't cabal pass a --hyperlink-source option or whatever/
09:16:44 <Baughn> gwern: Well, I mean the links to colorized source of the installed package that you get on hackage
09:17:05 <gwern> oh. I think that's a hs-color option
09:17:22 <gwern> The flags --with-PROG and --PROG-option(s) can be used with the following programs: alex ar c2hs cpphs ffihugs gcc ghc ghc-pkg greencard haddock happy hmake hsc2hs hscolour hugs jhc ld lhc lhc-pkg nhc98 pkg-config ranlib strip tar
09:19:41 <Baughn> That's odd..
09:20:01 <BMeph> Baughn: 3? Yes, it is! ;)
09:20:14 <gwern> Baughn: well, that's from my cabal install --help
09:20:41 <Baughn> THough I finally managed to make it stop complaining, there are still no source links. :/
09:21:00 <Baughn> Hackage does it, so I can only assume it's possible, but..
09:21:45 <dcoutts> Baughn: the cabal haddock command has the --hyperlink-source flag
09:22:09 <aavogt> djahandarie: also see haskelldb, which now uses HList
09:22:16 <Baughn> dcoutts: cabal install does not.
09:22:17 <ksf> wait records seems to be a re-implementation of grapefruit-records
09:22:23 <dcoutts> Baughn: right
09:22:59 <dcoutts> Baughn: http://hackage.haskell.org/trac/hackage/ticket/517
09:23:34 <Baughn> Ah.
09:26:06 <ksf> hmmm http://www.informatik.tu-cottbus.de/~jeltsch/research/ppdp-2010-paper.pdf
09:31:05 * Baughn decides to just replicate the entire data declaration code in TH
09:32:35 <Baughn> ..no, seriously, is there any way I can undefine a declaration in TH? Or modify it?
09:33:02 <ksf> export a modified version?
09:34:01 <Baughn> That would work if I didn't intend to have the result working in the same module as the code.
09:34:16 <ksf> there's always module pain when using TH
09:34:38 <Baughn> Well, I'm prototyping something I might want to put in GHC later.. it'll be fine.
09:35:04 * hackagebot async 1.1 - Asynchronous Computations  http://hackage.haskell.org/package/async-1.1 (PeterSimons)
09:35:54 <ksf> so you're intending to fix ghc by putting features into it that require said fixes to look nice?
09:35:57 <ksf> nice tactic.
09:37:20 <Baughn> Of course, first I need to learn TH. Then more GHC internals.
09:37:23 <Baughn> It's a bit of a project.
09:43:37 <Saizan> Baughn: what about $(someMacro [d| the declaration |]) so the macro can see the declaration without it being really defined.
09:43:51 <Baughn> Saizan: I can do that?
09:43:56 <Saizan> sure
09:44:41 <Baughn> Should probably read up on TH syntax..
09:47:29 <chrisdone> @let 1 = 10
09:47:30 <lambdabot>  Defined.
09:47:37 <Baughn> > 1
09:47:38 <lambdabot>   1
09:47:41 <chrisdone> ll
09:47:50 <chrisdone> :p
09:48:24 <djahandarie> > let 1 = 10 in 1
09:48:24 <lambdabot>   1
09:48:57 <djahandarie> > let 1a = 10 in 1a
09:48:58 <lambdabot>   <no location info>: Parse error in pattern
09:49:34 <chrisdone> i've never noticed that case
09:49:36 <benmachine> > let a 1a = a in a 4
09:49:37 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
09:49:37 <lambdabot>    arising from a use of `...
09:49:42 <djahandarie> What exactly is happening in the first one? Why would you be able to bind numerical identifiers to values but then not use them?
09:49:46 <benmachine> > let a 1a = a in a 4'c'
09:49:47 <lambdabot>   *Exception: <interactive>:1:145-152: Non-exhaustive patterns in function a
09:49:51 <benmachine> wups
09:49:54 <benmachine> > let a 1a = a in a 1'c'
09:49:55 <lambdabot>   'c'
09:49:58 <quicksilver> djahandarie: it's a hack to make case x of 1 -> .... work
09:50:01 <chrisdone> does the runtime just discard all bindings that are constructors?
09:50:20 <quicksilver> it's not very pretty.
09:50:26 <Saizan> djahandarie: 1 there is a pattern
09:50:29 <chrisdone> > let Nothing = 1 in Nothing
09:50:30 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
09:50:30 <lambdabot>    arising from the lite...
09:50:46 <Saizan> > let x@1 = 10 in x
09:50:47 <lambdabot>   *Exception: <interactive>:1:149-156: Irrefutable pattern failed for pattern...
09:50:51 <djahandarie> Oh, damn
09:50:56 <quicksilver> > let Nothing = Just 1 in ()
09:50:57 <lambdabot>   ()
09:50:57 <chrisdone> ah, duh, type checking
09:51:09 <quicksilver> ^^ all constructors are valid in bindings.
09:51:13 <djahandarie> > let Nothing = Just in Nothing
09:51:13 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t'
09:51:13 <lambdabot>         against inferred ...
09:51:19 <djahandarie> Oh
09:51:20 <djahandarie> lol
09:51:20 <djahandarie> fail
09:51:29 <djahandarie> > let Nothing = Just in Nothing 2
09:51:30 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t'
09:51:30 <lambdabot>         against inferred ...
09:51:34 <djahandarie> Poo
09:51:39 <quicksilver> I just did the working example djahandarie
09:51:44 <quicksilver> you should read before writing.
09:51:48 <chrisdone> quicksilver: 'tis a strange one. i wonder if GHC can produce warnings for that
09:51:50 <benmachine> quicksilver: couldn't it be argued that numeric literals are sort-of constructors?
09:51:54 <quicksilver> benmachine: yes.
09:52:02 <djahandarie> Oh heh
09:52:06 <benmachine> so what's the unpretty bit?
09:52:09 <djahandarie> > let Nothing = Just 1 in Nothing
09:52:09 <lambdabot>   Nothing
09:52:26 <quicksilver> benmachine: they're polymorphic, and desugar to something using Eq
09:52:30 <chrisdone> benmachine: the fact it's a moot expression
09:52:51 <benmachine> quicksilver: oh, yeah I suppose so
09:52:52 <Baughn> Saizan: Thank you for your assistance. My bid for world domination is now proceeding splendidly.
09:52:55 <chrisdone> (1) it creates no binding, (2) it doesn't even pattern match
09:52:57 <mreh> is that even valid haskell?
09:53:03 <chrisdone> it makes not much sense
09:53:05 <benmachine> chrisdone: the existence of moot expressions isn't hackish in my view
09:53:19 <chrisdone> benmachine: well it doesn't mean anything
09:53:23 <benmachine> you'd have to introduce unnecessary special cases to avoid them
09:53:32 <benmachine> chrisdone: neither does let () = () in ()
09:53:39 <quicksilver> let 1 = 10 in ... should desugar to let x | x == 1 = 10 in ...
09:53:40 <chrisdone> > let 'a' = 'b' in 'a'
09:53:40 <lambdabot>   'a'
09:53:44 <quicksilver> which is a bit odd ;)
09:54:06 <quicksilver> or is it let x | 1 == 10 = 10 ?
09:54:10 <chrisdone> benmachine: that's a valid pattern match though,
09:54:29 <quicksilver> plus a fromIntegral or two.
09:54:31 <chrisdone> lol
09:54:39 <benmachine> chrisdone: you mean in that the patterns actually match?
09:54:55 <emilmeln> I'm trying to compare performances of vanilla arrays and intmaps with respect to indexing time. Here what I've made with criterion framework: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25894. Can someone suggest me where I'm wrong in this benchmark (apart from indexing only by one subscript)?
09:55:49 <chrisdone> benmachine: no because it creates no binding, nothing to evaluate
09:56:28 <benmachine> chrisdone: okay I am no longer sure what we're arguing about if anything
09:56:31 <illissius> anyone know if there's a particular reason Foreign.ForeignPtr doesn't expose a way to remove finalizers from ForeignPtrs? looking at the source there doesn't seem to be a technical obstacle
09:56:35 <chrisdone> quicksilver: is that in the report? that it should desugers to Eq?
09:56:39 <quicksilver> chrisdone: yes.
09:56:56 <benmachine> illissius: removable finalisers don't sound very final :P
09:57:10 <benmachine> illissius: I guess it's just not necessary in most use cases?
09:57:10 <quicksilver> case x of 1 -> desugars to case x of y | y == fromIntegral 1 ->
09:57:19 <chrisdone> so GHC isn't compliant here?
09:57:40 <benmachine> erm
09:57:40 <illissius> benmachine: basically the scenario is 'what if the foreign library finalizes it first, in which case ghc shouldn't do it again later'
09:57:45 <illissius> (but i'm still thinking this through)
09:57:53 <quicksilver> chrisdone: what makes you think it's not compliant?
09:57:58 <chrisdone> quicksilver: ahh for numeric literals
09:58:12 <chrisdone> i thought this applied across the board
09:58:34 <benmachine> illissius: personally I'd be keen to give the responsibility to either ghc or the foreign library and keep it there, but I'm not an expert in the matter
09:58:48 <benmachine> finalisers always seemed a bit odd to me anyway
09:59:01 <benmachine> they don't seem to be guaranteed to anything
09:59:03 <benmachine> ever
10:00:16 <benmachine> also, zonedTimeToUTC is a total lie of a function
10:00:24 <ksf> hmm the only thing I'd like to have that records doesn't provide is a Maybe-returning lookup
10:00:27 <gwern> http://www.informit.com/articles/printerfriendly.aspx?p=1407357
10:00:29 <benmachine> oh wait no it isn't
10:00:37 <gwern> oh noes stepanov doesn't like our mergesort
10:00:43 <illissius> well afaict it's mainly to make sure resources get freed, not to 'do' anything. like, so ghc doesn't just collect the pointer but also the malloc-d memory it's pointing to. or is that not what you meant?
10:01:33 <benmachine> illissius: ignore me, I'm not being useful :P
10:01:59 <illissius> k!
10:02:12 <jbapple> code.haskell.org is down again.
10:02:25 <jbapple> Does anyone have any uptime stats for any of the *.haskell.org services?
10:02:29 <chrisdone> the door's open. AGAIN
10:02:49 <jbapple> chrisdone: what?
10:03:04 <ksf> oh I guess zipWith allows to do that
10:03:47 <chrisdone> jbapple: seen Shaun of the Dead?
10:04:31 <jbapple> chrisdone: yes, years ago.
10:04:58 <Hunner> :t (<*>)
10:04:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:05:32 <gwern> Cale: notice that apache is dead. again. this is why I characterized it as a weekly thing
10:05:40 <BMeph> Ah, the joys of out-of-context quotes... "If you're working in prolog the entirety of computer science is irrelevant"
10:05:57 <Cale> gwern: Hm? No, it's working. It was just slow.
10:06:16 <djahandarie> Could at least use nginx or lighttpd
10:09:07 <eevar> how would you create a lazy list whose head could be gc'ed?
10:09:45 <benmachine> eevar: all lists are like that, I think
10:09:54 <benmachine> as long as you don't keep references to the head of the list around
10:11:05 <jmcarthur> yeah, just start referencing the tail instead of the head and the head will be GCed
10:11:55 <ksf> if you need the head later but want to re-create the list instead of keeping it around, you can do something like foo () = [1..]
10:12:05 <ksf> which works due to arcane rules.
10:12:49 <Cale> Well, not *that* arcane. ;) Functions aren't memoised, but constants are.
10:13:21 <ksf> well but [1..] is constant
10:13:25 <eevar> ksf: great, exactly what i was looking for
10:13:35 <zygoloid> are there any guarantees that GHC won't CAF up that [1..] ?
10:13:46 <ksf> yes. the arcanity I was referring to.
10:13:59 <zygoloid> ksf: i don't believe that's guaranteed, is my point.
10:14:06 <ksf> something related to sharing, /me thinks
10:14:13 <Cale> zygoloid: Well, there's the fact that if it ever did, almost every Haskell program ever written would leak memory like a sieve.
10:14:22 <ksf> you'd have to ask someone who actually understands that kind of stuff
10:14:24 <Cale> But apart from that... perhaps not ;)
10:14:37 <zygoloid> Cale: it's not a leak if it's still reachable, and unreachable CAFs can be collected :)
10:15:03 <zygoloid> but yeah, i'd probably consider it to be a bug if ghc retained that list
10:16:07 <FunctorSalad> isn't it a "higher-level leak" if it's still reachable but nobody knows how? ;)
10:17:11 <Cale> Another thing is that while it does lift some CAFs, it will never automatically lift a CAF such that it separates adjacent lambdas (that doesn't quite apply here though)
10:18:24 <zygoloid> right, i've seen that guaranteed by the GHC manual
10:18:48 <benmachine> is it guaranteed by the hugs manual though? :P
10:19:09 <Cale> The Haskell language spec doesn't say anything much at all about operational semantics.
10:19:28 <benmachine> mm
10:19:43 <benmachine> this always seemed sensible to me but on the other hand you do have to care about that stuff while writing programs
10:19:54 <c_wraith> seq seems like the only thing that talks about operational semantics
10:20:05 <Cale> seq doesn't even talk about operational semantics
10:20:16 <benmachine> isn't seq just seq _|_ a = _|_
10:20:24 <Cale> seq is defined by the equations that   seq _|_ y = _|_ and seq x y = y otherwise
10:20:24 <benmachine> or
10:20:28 <benmachine> right
10:21:27 <Cale> While the monomorphism restriction doesn't explicitly mention operational semantics, the only reasonable justification for it is operational in nature, and it's practically the only thing in the spec which is like that.
10:21:59 <Cale> (Though, maybe it could be argued that seq is like that too)
10:22:03 <jmcarthur> so technically seq x y doesn't even have to evaluate x if it is proven that x is not _|_?
10:22:10 <Cale> jmcarthur: right
10:22:19 <jmcarthur> makes sense
10:22:24 <Cale> jmcarthur: Moreover, it's free to evaluate y first, and then x
10:22:41 <jmcarthur> well, sure, and i think ghc actually takes advantage of that sometimes, doesn't it?
10:22:47 <jmcarthur> that's what pseq is for, at least
10:22:47 <Cale> jmcarthur: (just has to make sure that x is not _|_ before it allows the surrounding case to pattern match)
10:22:54 <Cale> yeah
10:23:09 <jmcarthur> does pseq have a simple semantics like seq?
10:23:21 <Cale> It has identical semantics to seq
10:23:32 <jmcarthur> err... i guess it does :)
10:23:34 <Cale> The difference is purely operational
10:23:52 <Olathe> What's an easy way to get a Cartesian product of lists ?
10:24:03 <Olathe> liftM2 (,) ?
10:24:35 <ksf> @src zip
10:24:35 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
10:24:35 <lambdabot> zip _      _      = []
10:24:40 * jmcarthur debates whether he thinks that the fact that pseq and seq are not observably different is acceptable
10:25:06 <Cale> Olathe: yes
10:25:16 <Cale> Olathe: Or for moar lists, use sequence
10:25:23 <djahandarie> Moar!
10:25:28 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
10:25:28 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
10:25:37 <Olathe> Ahh, sequence is nice. Thanks :)
10:25:40 <Olathe> @index sequence
10:25:40 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:36:16 <Baughn> Saizan: It occurs to me, ParsecT should /not/ still include a "user state".
10:37:51 <FunctorSalad> so you can/have to add it manually..?
10:38:13 <Baughn> No, if you want a State you should use ParsecT State, simple as that
10:38:29 <Baughn> In my case I want a ParsecT Writer
10:38:30 <FunctorSalad> that's what I mean by 'manually'
10:38:36 <Baughn> Right.
10:38:46 <Baughn> Having the built-in one adds conceptual overhead.
10:39:44 <FunctorSalad> it is from before ParsecT existed?
10:40:41 <Baughn> ..then Parsec should be ParsecT State
10:40:51 <benmachine> Baughn: it's about backtracking
10:41:04 <benmachine> if you backtrack a ParsecT then the user state gets unstated
10:41:06 <benmachine> eeer
10:41:10 <benmachine> terrible use of language
10:41:11 <benmachine> but
10:41:15 <FunctorSalad> :)
10:41:22 <FunctorSalad> can you restate that?
10:41:26 <FunctorSalad> SORRY
10:41:35 <Baughn> benmachine: Oh. That makes sense.
10:44:52 <FunctorSalad> (you mean the old state is estated and...?)
10:45:03 <FunctorSalad> *dodges tomatoes*
10:47:53 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25895 <-- Using lenses, I went from.. that to this.
10:48:01 <Baughn> Okay, so the first one could be improved without lenses. Still.
10:53:05 <portnov> @hoogle split
10:53:06 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
10:53:06 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
10:53:06 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
10:57:30 <yitz> Baughn: well, the "lenses" could just be all those individually defined record updaters.
10:57:50 <Baughn> I know, I know...
10:58:13 <Baughn> Though it wouldn't be too hard to think up a scenario where that isn't quite enough. Still, I like the slightly unfair comparison. :P
10:59:32 <mindeavor> solution: someone create a linux node js hosting site
10:59:45 <mindeavor> :P
11:00:07 <mindeavor> whoops wrong chat
11:01:05 <greap> Is there a reason why you can't pattern match an argument, and then curry? For example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25897#a25897
11:01:20 <soupdragon> greap, not really - it's just not allowed
11:01:41 <greap> I often find situations where it would be very convenient.
11:02:40 * hackagebot ChasingBottoms 1.3.0 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0 (NilsAndersDanielsson)
11:02:46 <edwardk> greap: most of the time when someone does so it is a typo, otherwise, the only real reason is that the = denotes a location that you can't backtrack past, so sliding it around forms a bit of complication . you could probably move it out, but not back in, if anyone really wanted to allow it.
11:02:52 <yitz> greap: i've done it instinctively plenty of times, then gotten the error. on the other hand, i've also done it accidentally just as many times and the error saved me.
11:04:43 <yitz> edwardk: yeah, presumably moving the =  would be equivalent to _ = \_ ->
11:05:53 <yitz> or rather x = (...) x
11:06:18 <edwardk> yitz: well, you could rewrite by adding extra args and plumbing them through but going the other way risks changing meaning... er yeah you caught it =)
11:06:25 <chrisdone> chasingbottoms is my favourite package name
11:06:43 * hackagebot bindings-yices 0.2 - Bindings to the Yices theorem prover  http://hackage.haskell.org/package/bindings-yices-0.2 (PepeIborra)
11:06:45 <hpc> :t (...)
11:06:46 <lambdabot> Not in scope: `...'
11:07:30 <yitz> edwardk: going the other way could still make sense if an earlier parameter pattern has changed
11:08:25 <yitz> hpc: "..." was my way of saying "whatever"
11:08:35 <hpc> heh
11:11:15 <FunctorSalad> @let x ... y = 2*x + y -- it's a valid operator name though
11:11:15 <lambdabot>  Defined.
11:11:27 <FunctorSalad> > 1 ... 2 ... 3
11:11:28 <lambdabot>   11
11:11:30 <FunctorSalad> ;)
11:11:54 <c_wraith> :t \f -> let x = f x in x
11:11:55 <lambdabot> forall t. (t -> t) -> t
11:12:15 <c_wraith> That's such a mind-bending definition at first.
11:12:37 <Baughn> The type isn't much better
11:15:41 <philo> meta haskell hoooray lol
11:21:23 <SKK> hi
11:22:05 <soupdragon> hi
11:22:28 <edwardk> woot, i managed to work around most of my template haskell woes by just not using an expression quotation
11:22:45 <edwardk> that let me fool about half of my code into compiling
11:23:24 <mokrzu> hello, have anyone know how in xmonad resize windows in vertical ?
11:27:45 <ksf> meta+j or k
11:28:04 <ksf> there's no "vertical" in that sense, it's resizing the master window of the current layout
11:28:21 <ksf> also, #xmonad
11:28:50 <ksf> er no h and l
11:29:01 <ksf> j and k are moving focus, shift+meta moving windows
11:29:46 <Philonous> Template haskell uses normal functions, so could I create those, too, with template haskell?
11:29:56 <Baughn> Yes, just not in the same module
11:30:36 <mokrzu> meta key = mod key ? //sorry for off-topic
11:30:37 <Philonous> Baughn: Ok, nice. It's a shame, though, that you can't mix TH functions with regular code
11:31:16 <ksf> mokrzu, yes, whatever mod key you use
11:31:44 <mokrzu> ok, thanks
11:32:33 <Philonous> Oh, and the quoting brackets are sugar, I presume? What do they desugar to?
11:33:27 <Twey> Quoting brackets?
11:33:33 <Twey> Oh, TH?
11:34:06 <Philonous> Yes, "[| ... |]" etc.
11:38:14 <edwardk> Philonous: they desugar down to a 'Q Exp' 'Q [Dec]' or 'Q Type'
11:38:30 <edwardk> Philonous: and they also perform a bit of a type checking pass during the desugaring process
11:39:08 <Philonous> edwardk: Oh, so they aren't just functions `String -> Q Exp` ?
11:39:39 <benmachine> no they're "clever"
11:39:44 <edwardk> Philonous: there is a bit of an incestuous relationship with them and the typechecker
11:39:53 <zygoloid> they do too much type checking, if you ask me...
11:40:07 <Starfire> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25898#a25898 -- Why does GHC require UndecidableInstances for this code?
11:40:23 <zygoloid> [d| instance Foo Bar where $(stuff) |] will complain if there's already a Foo Bar instance
11:40:23 <edwardk> zygoloid: yeah i just spent days trying to figure out a work around for what turned out to be code diabetes caused by too much sugar ;)
11:40:30 <qz> is there anything special i need to do after doing "ghci mysource.hs" to be able to see types using :t ?
11:40:47 <edwardk> zygoloid: or worse, if the superclasses of Foo aren't already in scope
11:41:31 <zygoloid> why do they bother doing any typechecking inside [| ... |] brackets?
11:41:52 <Philonous> Is there a "dumbed down" version of them?
11:42:17 <edwardk> zygoloid: i know there is an issue where you need to do so in order to support the [t|...|] case
11:42:29 <greap> Is there a 'j' library for haskell?
11:44:22 <zygoloid> edwardk: i think that Q [Dec] versus Q Dec annoys me more than the typechecking, tbh
11:45:02 <zygoloid> i assume that they switched from declaration quoting and splicing using DecQ to Q [Dec] pretty late on, which is why all the rest of the interface is in terms of DecQ?
11:45:08 <Philonous> Or is there a package to parse haskell code?
11:45:22 <zygoloid> Philonous: yep, haskell-src or haskell-src-exts
11:45:27 <Philonous> Thanks!
11:45:43 <edwardk> haskell-src-exts is pretty good. also mmorrow and some folks have some quasiquoters built on them
11:45:48 <zygoloid> Philonous: if you want to generate TH expressions from it, use haskell-src-meta
11:45:59 <zygoloid> @hackage haskell-src-meta
11:45:59 <lambdabot> http://hackage.haskell.org/package/haskell-src-meta
11:46:01 <edwardk> yeah thats the package
11:46:35 <Philonous> At the moment I just want to tranlate an "enriched" haskell syntax to regular haskell
11:50:43 <alexyk> I'm getting a parse error (possibly incorrect indentation) on the "case" here: http://paste.pocoo.org/show/221138/ -- why?  I use soft tabs which are spaces.  Is it the let under a do?
11:51:34 <c_wraith> what line?
11:52:22 <alexyk> case args of
11:52:38 <alexyk> when I had case all on the same line as let with {...}, it compiled
11:52:54 <c_wraith> oh, the "case" needs to be indented further than the first token after the let
11:53:22 <alexyk> ah... tricky
11:53:25 <Starfire> Does anyone know the answer to my question above?
11:57:54 <BMeph> Is there a mailing list or chat room that just works on records?
11:58:41 <Saizan> Starfire: high-level: because the heuristic used to guarantee termination doesn't accept that case; low-level: because "Maybe id" doesn't mention "t" and vice versa
11:59:04 <Saizan> BMeph: what?
11:59:42 <Starfire> Saizan: OK, thanks.
11:59:46 <kmc> yeah i noticed that you have to turn on -XFlexibleInstances to allow [d| instance $t where ... |]
11:59:57 <kmc> err [d| instance C $t where ... |]
12:00:00 <kmc> even if you don't actually use it for non-H98 heads
12:00:20 <alexyk> I'm running a main under IO, which calls a fetch under runTCM, a monad for TokyoCabinet which wraps IO; all is good.  But now, from fetch, I want to print progress to stderr.  The do I try to stick in fetch complains it wants to chain IO, not TCM: http://paste.pocoo.org/show/221144/.  How can I reach back for IO from there?
12:00:28 <ozataman> Hey all
12:00:31 <gwern> http://papers.ssrn.com/sol3/papers.cfm?abstract_id=31213 "I Just Ran Four Million Regressions" by Xavier Sala-i-Martin
12:00:42 <kmc> alexyk, that is a question about the TCM monad specifically
12:00:45 <c_wraith> TH has some weirdness.  I've noticed things like top-level splices being dependent on where you put them in a file.
12:00:53 <kmc> alexyk, but it might be an instance of MonadIO
12:00:55 <kmc> :t liftIO
12:00:55 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
12:01:03 <deech> Hi all, I have a question about monads like Maybe and Either. Is there an elegant way to string them together?
12:01:09 <kmc> deech, monad transformers
12:01:19 <kmc> deech, though i wouldn't exactly call them elegant
12:01:35 <kmc> @unmtl ErrorT e IO a
12:01:35 <lambdabot> IO (Either e a)
12:01:48 <kmc> @unmtl ErrorT e (State s) a
12:01:48 <lambdabot> s -> (Either e a, s)
12:01:59 <kmc> @unmtl StateT s (Either e) a
12:02:00 <lambdabot> s -> Either e (a, s)
12:02:08 <deech> kmc: so I end up doing a lot of: case (...) of Just x -> (case (... x) of Just x ...) Nothing -> (some error handling etc.)
12:02:19 <kmc> right
12:02:28 <alexyk> kmc: it TCM actually wraps IO: newtype TCM a = TCM { runTCM :: IO a } deriving (Monad, MonadIO)
12:02:40 <kmc> alexyk, if it derives MonadIO then you can use "liftIO"
12:02:43 <BMeph> Saizan: Is there a mailing list of chat channel devoted to discussion of records - their syntax, how to improve it, alternative models, ideas like that.
12:02:57 <ozataman> I'm having some haddock problems.. with multi-line function parameters, the comment (description) for each parameter gets shifted up and the comment for the first parameter doesn't even show. does anybody know how to get around this?
12:03:08 <BMeph> mailing list *or chat, I meant.
12:03:14 <alexyk> kmc: it's awe-inspiring.  How do I use it?  :)
12:03:18 <kmc> liftIO is?
12:03:25 <alexyk> for now yes
12:03:29 <kmc> :t liftIO (putStrLn "Hello, world!")
12:03:30 <lambdabot> forall (m :: * -> *). (MonadIO m) => m ()
12:03:32 <alexyk> it has stars in its type
12:03:44 <kmc> alexyk, you can ignore that, though i can explain it if desired
12:04:00 <alexyk> but in that paste -- where do I stick said liftIO?
12:04:11 <kmc> wherever you have an IO action that you want to turn into a TCM action
12:04:51 <kmc> alexyk, lambdabot prints types in their full glory, using the form «forall x y z. T».  that is, it explicitly lists before the type all the type variables that are used (and sometimes gives extra info for them, as in the "kind signature" you noticed)
12:05:03 <kmc> however for most purposes you can just read the T part
12:05:20 <alexyk> ah
12:05:49 <ozataman> haddock help, anyone?
12:06:03 <kmc> occasionally you see a type like (forall x. S) -> T
12:06:12 <kmc> which is different from forall x. S -> T
12:06:15 <kmc> and in that case it does matter
12:08:53 <alexyk> so in a case alternatives, I either print or do nothing.  When I do nothing I seem to need to -> IO (), but I can't get IO into scope!  where is it?  I thought it's in Prelude?...
12:09:17 <Botje> alexyk: return ()
12:09:23 <alexyk> Botje: ah
12:09:29 <Botje> alexyk: return lifts a value of type a to IO a
12:09:35 <Botje> (or, indeed, any monad)
12:09:46 <alexyk> right right, we can't construct IO right
12:09:57 <Botje> oh, you can construct IO without a problem
12:10:02 <Botje> you can't /execute/ it in pure code :)
12:10:08 <BMeph> deech: Have you considered PatternGuards?
12:12:02 <JoeyA> Is there a nicer way to do this?  if i == ai then b else if i == bi then a else x
12:12:12 <kmc> alexyk, IO is an example of an "abstract type", meaning that its data constructors are hidden
12:12:35 <Botje> JoeyA: wrap it into a function
12:12:38 <alexyk> kmc: yep!  what do I need to import to get liftIO?  Control.Monad.Trans doesn't export it
12:12:52 <soupdragon> cond [ i == ai --> b, i == bi --> a, otherwise --> x ]
12:13:05 <JoeyA> I wasn't sure if a case expression could do it
12:13:17 <soupdragon> case i of ((==ai)->True) -> b ;  ((==bi)->True) -> a ; _ -> x
12:13:20 <benmachine> JoeyA: something like fromMaybe x $ lookup i [(ai, b), (bi, a)]
12:13:23 <kmc> alexyk, it does,
12:13:31 <kmc> do you have some werid library version?
12:13:46 <Botje> soupdragon: that's .. wishful thinking.
12:14:11 <alexyk> kmc: nope, but when I do: import Control.Monad.Trans (liftIO) -- I get that error.
12:14:11 <benmachine> Botje: hmm? it's view patterns
12:14:26 <benmachine> although guards are easier
12:14:30 <Botje> hmm
12:14:35 <Botje> didn't see the extra arrow
12:14:40 <Botje> bleh, it's late :)
12:14:46 <benmachine> it's 8pm :P
12:15:10 <kmc> alexyk, however you could have a system where IO is not an abstract type, and still maintain purity
12:15:11 <benmachine> and I haven't eaten, I should do that
12:15:30 <kmc> GHC's implementation of IO is not like that
12:15:31 <djahandarie> Man, it's quite a long drive to MIT :(
12:15:56 <kmc> why do you want to go to MIT?
12:16:02 <kmc> also from where?
12:16:11 <djahandarie> I'm in Storrs CT
12:16:18 <djahandarie> For the Haskell meet
12:16:19 <kmc> it's a longer drive to Caltech :)
12:16:36 <kmc> ah, when is the next one?
12:16:42 <kmc> apparently June 8
12:16:48 <kmc> i'll be there :)
12:18:11 <djahandarie> I could probably find some way to utilize public transportation
12:18:14 <alexyk> wow, I just wrap any case crap into liftIO (...) and it compiles!
12:18:26 <alexyk> of course it derives MonadIO
12:20:29 <alexyk> seems like monadic exercises are masochistic pastimes: erect obstacles, then get behind them, and then combine obstacles of various kinds, preferably unfit together
12:20:50 <djahandarie> It'd be nice if they'd increase the speed limit on the highway to like 100mph or something
12:20:51 <alexyk> fork M and M_ versions of all functions
12:21:11 <kmc> yeah alexyk, monads feel like obstacles for a long time after starting to learn Haskell
12:25:30 <Twey> Why do we have opaque IO, again?
12:25:55 <Twey> Why do we have opaque IO, again?
12:25:58 <kmc> probably to avoid constraining implementations in how they implement IO
12:26:22 <Twey> Ah
12:26:40 <FunctorSalad> did alexyk leave?
12:26:44 <FunctorSalad> or just rename
12:26:44 <kmc> looks like
12:26:55 <kmc> the guts of GHC's IO aren't pretty
12:26:56 <djahandarie> How would transparent IO work? (not sure if that is the proper term)
12:27:10 <kmc> djahandarie, well, various ways
12:27:13 <kmc> i'll give a simple example
12:28:16 <deech> Hi all, I am trying to understand monad transformers by constructing a stack of Reader and Writer: transformerTest :: ReaderT Int a (WriterT String IO ()). Why does the compiler make me specify the 'a'?
12:30:14 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25900#a25900 djahandarie here's a concrete, pure IO type using GADTs
12:30:18 <yitz> deech: it depends on the definition of the function
12:30:37 <kmc> by "pure" i mean that it doesn't rely on hacks like side-effecting evaluation (while for example GHC's implementation of IO does)
12:32:01 <djahandarie> Would it be possible to actually make IO like that?
12:32:08 <kmc> sure
12:32:21 <kmc> your implementation would have two pieces, an evaluator and an executor
12:32:36 <kmc> the purpose of the evaluator is to reduce terms to weak head normal form
12:32:40 <deech> yitz: I thought that a Reader only took a single environment type.
12:33:26 <FunctorSalad> deech: that's not really a transformer stack
12:33:45 <FunctorSalad> maybe you want: ReaderT Int (WriterT String IO) a
12:33:45 <qz> is there any way to make [String] out of [IO String] ?
12:33:46 <yitz> deech: oh now I get your question
12:33:51 <djahandarie> kmc, then why isn't it done like that?
12:34:02 <kmc> the purpose of the executor is to call the evaluator on an IO action, then look at what constructor came back and do what it says
12:34:09 <FunctorSalad> the second arg of ReaderT (resp WriterT) is the inferior monad
12:34:14 <djahandarie> qz, you can get IO [String] out of [IO String] with sequence
12:34:19 <sepp2k> qz: You can turn it into IO [String], but you can never escape the IO.
12:34:23 <yitz> deech: ReaderT takes 3 parameters
12:34:23 <Lajla> FunctorSalad, is your name a brilliant pun on 'word salad'?
12:34:29 <sepp2k> (unless you use unsafe functions)
12:34:37 <JoeyA> Is there a way to simplify forM [1..3] $ \_ -> [1,2,3,4] ?
12:34:40 <qz> sepp2k, djahandarie: thanks
12:34:48 <Cale> djahandarie: Well, if you do it that way, you probably want to do more deforestation, to remove the construction of these IO trees from the program as an optimisation.
12:34:49 <FunctorSalad> Lajla: hmm more on "cable salad", and not all that brilliant :(
12:34:49 <kmc> JoeyA, replicate 3 [1,2,3,4]
12:34:53 <deech> yitz: I read that it takes r m a.
12:34:58 <JoeyA> kmc: Not the same
12:35:07 <kmc> err
12:35:10 <Cale> djahandarie: So it would be somewhat more tricky to optimise than the hacky way of doing things.
12:35:10 <kmc> replicateM 3 [1,2,3,4]
12:35:11 <JoeyA> You're thinking of forM [1..3] $ \_ -> return [1,2,3,4]
12:35:19 <JoeyA> Ah, thanks
12:35:19 <deech> So the 'r' is my environment and the 'm a' is the (WriterT ..)
12:35:20 <yitz> deech: the second, your a, needs to be a monad type. it's is where you stack the next monad level.
12:35:27 <qz> djahandarie, how do i turn it into IO [String] then?
12:35:36 <djahandarie> :t sequence
12:35:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:35:40 <kmc> qz, sequence :: [IO String] -> IO [String]
12:35:42 <qz> ah
12:35:49 <kmc> qz, turns a list of recipes into a recipe which produces a list
12:35:55 <Cale> djahandarie: Also, it's not 100% clear what to do about FFI, but that could probably be dealt with.
12:36:29 <djahandarie> Cale, why doesn't the current form of IO need that optimization?
12:36:33 <yitz> deech: ReaderT Int (WriterT String IO) ()
12:36:40 <kmc> djahandarie, there's no one current form.  every compiler can do it differently
12:36:53 <djahandarie> GHC's for example
12:36:55 <Cale> djahandarie: Well, the current implementation of IO in GHC just uses side-effectful functions
12:36:56 <kmc> the version in GHC uses side-effecting function application behind the scenes
12:37:32 <hpc> that makes sense
12:37:32 <djahandarie> So basically, it doesn't even keep track of it?
12:37:36 <deech> yitz: Ah. That makes sense.
12:37:40 <kmc> keep track of what djahandarie
12:37:43 <Cale> Basically, using function parameters of an empty type (called State# RealWorld, if you'd like to know), in order to get GHC's normal dependency analysis to schedule the code the right way
12:37:56 <deech> yitz: I think I tried every other combo!
12:38:00 <kmc> GHC's implementation of IO is chosen mostly for efficiency, i think
12:38:05 <kmc> it's not pretty or simple
12:38:05 <yitz> deech: FunctorSalad said that up there ^
12:38:23 <kmc> this is why IO is abstract in the standard
12:38:32 <kmc> so that regular developers don't need to worry about it
12:38:46 <djahandarie> Hm
12:38:49 <qz> do i need to somehow tell ghci to interpret file after :load'ing it ? because it says 'Not in scope' for everything, even though :list main shows my function with several declarations ?
12:38:54 <Cale> Yeah, and we're free to think of IO using whatever toy-model we prefer :)
12:39:07 <yitz> why is the gadt formulation nicer?
12:39:23 <kmc> it doesn't require you to think about impure functions
12:39:26 <yitz> in the end there will still be side effects
12:39:31 <Cale> yitz: It doesn't involve cheating with side-effectful functions.
12:39:38 <kmc> yitz, but not side-effectful functions
12:39:48 <deech> yeah I think I missed that. Thank to both of you!
12:40:02 <yitz> side effectful constructors are better than side effectful functions?
12:40:11 <kmc> yitz, the constructors don't have side effects
12:40:14 <Cale> yitz: It wouldn't be the constructors which were side effectful
12:40:19 <kmc> yitz, you are building an ordinary algebraic data type
12:40:27 <kmc> which is a totally inert value
12:40:35 <Cale> yitz: Just the interpreter/executor which is pattern matching on those and carrying out the described effects.
12:40:54 <Cale> (part of the runtime system)
12:40:55 <FunctorSalad> -XUnsafeConstructors
12:40:58 <FunctorSalad> ;)
12:41:02 <yitz> and that interpreter has side effects, just like now.
12:41:11 <FunctorSalad> (doesn't really exist!)
12:41:15 <kmc> yitz, similarly you can use Language.C and build a C function's AST in memory, but your C function doesn't run until you glue it onto a C compiler
12:41:21 <Cale> Yes, but what GHC does is secretly stash effects in the evaluator
12:41:51 <Cale> By creating functions whose evaluation has the desired effect.
12:42:05 <Cale> Whereas evaluation really ought to be pure.
12:42:18 <kmc> GHC re-muddles evaluation and execution at a level which is still visible from Haskell code (if you import the right stuff)
12:42:40 <kmc> this GADT implementation would not admit any Haskell terms with side-effecting evaluation
12:42:46 <yitz> so your formulation wouldn't allow unsafePerformIO?
12:43:01 <kmc> yitz, i think you would need more magic to implement unsafePerformIO
12:43:06 <Cale> yitz: Yeah, unsafePerformIO would be harder.
12:43:11 <kmc> it wouldn't be an ordinary Haskell function, as in GHC
12:43:11 <Cale> (than it is now)
12:43:16 <kmc> it'd be a special kind of closure
12:43:19 <kmc> which hooks into the executor
12:44:08 <yitz> kind of like seq on steroids
12:44:15 <Cale> So, there are some reasons why we practically might want to stay with the messy implementation (at least until someone sorts out a whole bunch of these details ;)
12:44:37 <djahandarie> So Haskell 2020
12:44:44 <Cale> Particularly, I expect that the deforestation part would be huge.
12:44:51 <Cale> Though I might be wrong.
12:44:51 <yitz> Conalskell
12:45:33 <Cale> Another similar representation would be as MonadPrompt with a well-chosen prompt type.
12:46:34 <Cale> That's quite similar to the GADT approach. (The prompt type, indicating the primitive IO actions will be a GADT, MonadPrompt itself is a bit like a CPS monad)
12:48:33 <lispy> Cale: the prompt in MonadPrompt isn't the same as the delimited continuation style prompt is it?
12:48:41 <magicman> ... Awesome. I just got ghci to tell me "*** Exception: Maybe.fromJust: Nothing".
12:48:48 <magicman> Funnily enough, it was during interpretation >_>
12:48:51 <Twey> magicman: That's not hard
12:48:54 <Twey> > fromJust Nothing
12:48:55 <lambdabot>   *Exception: Maybe.fromJust: Nothing
12:49:01 <magicman> Oh, I know.
12:49:07 <copumpkin> magicman: don't use fromJust, basically
12:49:13 <Twey> Oh!
12:49:19 <Twey> You mean the error occurred in GHCi itself?
12:49:27 <magicman> Yes, it was GHCi itself.
12:49:32 <Twey> Oo-er.
12:49:32 <copumpkin> oh nice
12:49:36 <Twey> Bug report!
12:49:48 <hpc> fromJust is just pattern matching with a different name for non-exhaustive pattern exceptions
12:49:59 <magicman> Apparently using GADTs as an associated type doesn't quite work >_>
12:50:09 <copumpkin> magicman: oh yeah, that's a known bug
12:50:15 <copumpkin> I thought it was fixed in 6.12 though
12:50:26 <magicman> Ehn, still using 6.10, I'm afraid.
12:50:34 * magicman is behind on stuff.
12:51:29 <magicman> But okay, if it's fixed, then that's cool. Thanks :)
12:51:38 <copumpkin> I think so
12:51:54 <copumpkin> by associated type you mean associated data/data family?
12:51:55 <kmc> don't fear the future :)
12:52:15 <kmc> yeah 6.12 allows you to create a data instance which is a GADT
12:52:31 <magicman> As in a "class Stuff a where data SomeType a :: * -> *"
12:52:43 <copumpkin> yeah
12:52:45 <magicman> And an instantiation with "data SomeType Int r where {...}"
12:52:47 <copumpkin> that's just a data family
12:58:30 <siracusa> I was wondering why I've gotten strange debug output related to the PortNumber type of the network package. Then I saw the Show instance is behaving a bit strange (see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25901#a25901). Is that intended?
13:03:27 <kmc> siracusa, looks like it's storing the port in network byte order, and not reversing it for show
13:03:38 <kmc> (assuming you're on a little-endian machine)
13:04:08 <kmc> that's probably a bug especially because it means show output will depend on the endianness of the machine
13:04:49 <siracusa> Ah, I see, it's just flipped bytes
13:04:58 <kmc> same behavior here
13:05:06 <kmc> (btw you don't need to explicitly call "show" to test)
13:15:39 <Olathe> Is there a way to have a functional dependency where it's both a -> b and b -> a ?
13:19:01 <BONUS> yeah
13:19:05 <Jedai> Why not ?
13:19:12 <BONUS> class Foo b | a -> b, b -> a where
13:20:02 <Olathe> Ahh, thanks :)
13:20:19 <thoughtpolice> i think it may just be me, but functional dependencies make my brain hurt
13:20:22 <thoughtpolice> :(
13:20:45 <Twey> thoughtpolice: Mine too
13:20:46 <copumpkin> yep, just you
13:21:21 <jmcarthur> my brains handles them fine, but i much prefer type families anyway
13:21:25 <Jedai> thoughtpolice: and type families ?
13:21:42 <thoughtpolice> Jedai: much better
13:22:33 <thoughtpolice> i never really needed FDs, and by the time type families came around I was doing type-level stuff
13:22:37 <Jedai> Nice, since they seem to be preferred now and for the future
13:22:38 * hackagebot random-fu 0.1.0.0 - Random number generation  http://hackage.haskell.org/package/random-fu-0.1.0.0 (JamesCook)
13:22:41 <benc__> is thee a nice example for type familites?
13:22:44 <benc__> families
13:22:59 <thoughtpolice> so type families made much more sense since I really used them first
13:23:15 <Dashkal> Is there a good starting point for learning how haskell translates to C?  I'm curious and want to look into the feasibility of using haskell to program for lego mindstorms.
13:23:26 <thoughtpolice> I also prefer to think of specifying invariants at the type level using functions rather than relations
13:23:39 * hackagebot twidge 1.0.0 - Unix Command-Line Twitter and Identica Client  http://hackage.haskell.org/package/twidge-1.0.0 (JohnGoerzen)
13:23:53 <kmc> Dashkal, what processor does mindstorms have?
13:23:57 <alexyk> why is haskell platform for linux at 6.10.4 while puny macs get 6.12?!
13:24:06 <kmc> alexyk, it's not
13:24:07 <Dashkal> kmc: Looks like ARM just glancing over things
13:24:17 <alexyk> kmc: for Gentoo at least
13:24:23 <kmc> oh well, blame gentoo
13:24:25 <thoughtpolice> benc__: there are a couple of really good uses for them, simon peyton jones wrote a paper with some good examples
13:24:29 <Twey> Nor for Arch
13:24:39 <kmc> debian has 6.12.1
13:24:42 <alexyk> gentoo!  I blame you.
13:24:59 <burp> irk gentoo
13:25:03 <kmc> Dashkal, the original paper describing GHC's backend is http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
13:25:08 <alexyk> well, Arch is used by three Poles and five Greeks anyways
13:25:11 <thoughtpolice> benc__: look at this paper here - http://www.haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
13:25:17 <thoughtpolice> it's very good
13:25:21 <Twey> alexyk: And almost every Haskeller ;)
13:25:26 <Twey> … oh wait
13:25:41 <kmc> Dashkal, this is a good starting point for learning how Haskell could translate to C.  i'm not sure that's important to your project, though
13:25:44 <benc__> ok then
13:25:44 <kmc> but it's good to know
13:26:01 <alexyk> the good thing, 6.10.4 is in the prefix portage
13:26:12 <thoughtpolice> Dashkal: it may be better to just use something like 'atom' to generate C code, which you then compile for your lego mindstorms
13:26:13 <Dashkal> kmc: danke.  Now I just hope I'm up to reading this.
13:26:13 <Dashkal> It's currently at 'curiosity'.  I'll see if it's reasonable enough to be worth the effort.
13:26:37 <kmc> i agree with thoughtpolice that atom is more likely to be suitable
13:26:39 <thoughtpolice> Dashkal: currently, GHC is not very easy to port, especially to very constrained resource systems like mindstorms (I'm assuming anyway)
13:26:42 <Dashkal> thoughtpolice: That's kind of what I'm going with.  My current knowledge is pretty much summed up in the RWH performance chapter.  Lots to go
13:26:44 <kmc> i saw a post about programming Arduino with Atom recently
13:27:04 <thoughtpolice> Dashkal: the main problem is that if you want GHC-compiled code to run there, you have to port the compiler and its runtime system to that architecture
13:27:09 <Dashkal> But it did mention that there's a point where we go from Core to C (or asm, but that's not so useful when I want to run on ARM)
13:27:14 <thoughtpolice> which is, to say the least, not totally trivial
13:27:23 <kmc> you only need to port the RTS really
13:27:32 <kmc> assuming you want to cross-compile and are willing to go via C or LLVM
13:27:56 <Dashkal> This looks promising for the final step: http://nxtgcc.sourceforge.net/
13:28:04 <Dashkal> But I have to get to C first
13:28:04 <alexyk> how do I get the baddest-ass optimization with ghc?
13:28:13 <alexyk> I still have to beat Clojure!
13:28:43 <thoughtpolice> yeah, but setting up GHC as a cross compiler would be even more of a pain in the ass, because I know for a fact certain build tools used by GHC need to be compiled for the target system, but also run during the compilation of GHC itself
13:29:11 <Dashkal> again, this is why I want to compile hs -> c.  not directly to machine code.
13:29:31 <thoughtpolice> also, LLVM isn't guaranteed to really produce correct ASM for architecture 'x' given any arbitrary LLVM bitcode. you can get yourself into some problems with endianness, for example
13:29:33 <Dashkal> I go directly to arm machine code and I have to duplicate a lot of effort.
13:29:42 <thoughtpolice> Dashkal: it's not easy either way
13:29:47 <Dashkal> no question there
13:29:55 <thoughtpolice> compiling haskell to C in the way GHC does it is going to still require massive effort
13:30:05 <Dashkal> *nods*
13:30:23 <thoughtpolice> notably, because you're going to have to port the evil mangler (go ahead and kill yourself now) to post-process arm assembly to implement post-compiled optimizations like tail-call optimization
13:30:31 <thoughtpolice> this is why everybody in GHC HQ wants to get rid of the C backend
13:30:39 <thoughtpolice> because maintaining it sucks and it's not very flexible
13:30:52 <kmc> well you can just do an unregisterized build
13:30:54 <thoughtpolice> and ties GCCs hand with some optimizations
13:30:56 <kmc> which requires no evil mangler
13:31:01 <kmc> that's how ghc-iphone works
13:31:16 <thoughtpolice> i thought the EM was required for unregistered builds too
13:31:17 <kmc> unregisterized via-C, using Apple's official C compiler
13:31:22 <thoughtpolice> oh well, ignore me then :P
13:31:38 <kmc> and the patchset against vanilla GHC 6.10.2 is surprisingly small
13:31:58 <thoughtpolice> Dashkal: I would say an easier alternative would be instead of porting GHC, to just use atom to generate C code to run on the NXT
13:32:12 <Dashkal> thoughtpolice: Looking into atom now.  Porting ghc is probably over my head
13:32:18 <kmc> that's a totally different thing
13:32:27 <kmc> but it's both an easier and a more useful thing
13:32:45 <thoughtpolice> yes
13:32:54 <Dashkal> It certainly seems to be the way to go for accomplishing my goal.  Writing a C backend for GHC is way over my head.
13:33:10 <kmc> it already has a C backend
13:33:27 <Dashkal> Ok, now I'm confused.  Perhaps I'm describing what I want to do poorly?
13:33:29 <kmc> and it already has a C backend that's mostly portable
13:33:40 <kmc> GHC has four backends now:
13:33:51 <kmc> 1) portable C code.  simple, slow
13:34:07 <kmc> 2) C code which must be compiled with GCC specifically, then the assembly is post-processed by the Evil Mangler.  faster but awful
13:34:14 <kmc> 3) direct native codegen, only for certain architectures
13:34:16 <kmc> 4) LLVM
13:34:22 <copumpkin> 5) bytecode for ghci
13:34:26 <kmc> true copumpkin
13:34:28 <BONUS> what about C--
13:34:39 <kmc> Cmm is a stage used internally for all of those
13:34:41 <copumpkin> c-- is an intermediate step
13:34:45 <BONUS> ah, right
13:34:49 <thoughtpolice> Dashkal: you want to run haskell directly on the NXT, yes? if so, that requires porting GHC. it already has a C backend, but it still requires porting in various parts of the RTS to work properly on that architecture.
13:34:54 <aristid> bytecode could work for the mindstorms setting
13:34:57 <Choko> how small is the portable c ?
13:35:04 <kmc> out of curiousity, how much RAM does the NXT have?
13:35:09 <Dashkal> thoughtpolice: 'directly' is up for debate.
13:35:15 <kmc> if the answer is not "many megabytes" then this is not even worth considering
13:35:17 <thoughtpolice> Dashkal: atom, on the other hand, is just a library that you use in a haskell program that generates C for you
13:35:48 <thoughtpolice> Choko: not very small
13:36:06 <thoughtpolice> it's pretty god-awful C, by all means, because it doesn't do things like use the C stack directly, etc
13:36:23 <Dashkal> I'm getting conflicting messages from this damn thing.  I can't tell if my code runs on the unit or on the PC now.
13:36:28 <Dashkal> lemme research more
13:36:44 <copumpkin> can you call alloca with a negative parameter in gcc btw?
13:36:49 <copumpkin> will it subtract from your stack?
13:36:50 <kmc> :O
13:36:50 <FotherMucker> !hi
13:36:57 <FotherMucker> Damn, no bots :(
13:37:03 <kmc> there are bots...
13:37:07 <kmc> @nixon
13:37:07 <lambdabot> You won't have Nixon to kick around anymore, because, gentlemen, this is my last press conference.
13:37:09 <FotherMucker> They don't work :<
13:37:09 <Dashkal> ok, on the unit
13:37:20 <kmc> > fix ((0:) . scanl (+) 1)
13:37:20 <FotherMucker> Ahh
13:37:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:37:24 <FotherMucker> Hello bot
13:37:36 <copumpkin> FotherMucker: you interested in haskell?
13:37:38 * Dashkal snickers
13:37:40 <Dashkal> ok, nevermind
13:37:46 <Dashkal> Flash and RAM NXT has 256 KB flash memory and 64 KB RAM memory.
13:37:50 <FotherMucker> copumpkin: Why else would I be here?
13:37:51 <aristid> :t (0:)
13:37:51 <lambdabot> forall t. (Num t) => [t] -> [t]
13:37:57 <kmc> > text $ map pred "Ifmmp!GpuifsNvdlfs"
13:37:57 <lambdabot>   Hello FotherMucker
13:38:02 <aristid> :t scanl (+) 1
13:38:03 <lambdabot> forall a. (Num a) => [a] -> [a]
13:38:06 <FotherMucker> Hello lambdabot
13:38:31 <kmc> Dashkal, no way in hell any ghc-compiled program will fit in 64 KB RAM
13:38:38 <aristid> Dashkal: that amount of memory is an insult :)
13:38:38 <Dashkal> kmc: Yeah.  *sigh*
13:38:55 <lispy> hbc was for embedded systems, righT/
13:38:58 <Dashkal> Still, there's an option.  If I can get the thing communicating with a PC, I can run the haskell code on a PC and have it send ocmmands to the unit
13:38:59 <lispy> right?*
13:39:00 <aristid> it's not like a few megabytes would cost anything
13:39:07 <sclv> nhc ftw!
13:39:14 <lispy> sclv: ah, thanks
13:39:26 <aristid> Dashkal: yeah that would almost definitely be an option
13:39:33 <lispy> or JHC (it doesn't have a GC so it doesn't use ram right?)
13:39:38 <kmc> ;p
13:39:39 <kmc> using the nhc/yhc bytecode interpreter would have some advantages
13:39:52 <kmc> but there's no avoiding the fact that Haskell programs use lots of RAM
13:39:56 <Dashkal> Something like that has to be done.  I see bindings for lua and perl.
13:40:01 <kmc> as they build closures and boxed polymorphic values and everything else
13:40:04 <Dashkal> I even see a java port!
13:40:09 <jmcarthur> lispy: that was a joke?
13:40:15 <lispy> jmcarthur: indeed
13:40:35 <jmcarthur> sorry, didn't register that way with me immediately
13:40:36 <lispy> jmcarthur: well, jhc really doesn't have a GC
13:40:38 <kmc> i wonder if you could program the NXT in Forth?
13:40:41 <jmcarthur> yeah
13:40:42 <lispy> jmcarthur: not a proper one
13:41:00 <Dashkal> I saw Forth in the list
13:41:09 <jmcarthur> supposedly has some problematic region inference, but i don't even know that state of that
13:41:39 <Dashkal> pbForth
13:41:54 <lispy> jmcarthur: yeah.  And, IIRC you can splice in bohem(sp?) gc for C since it generates standards compliant C
13:41:57 <Dashkal> Capable of bluetooth connections with a computer or up to three other NXT Intelligent Bricks.
13:42:05 <Dashkal> There.  the pc controlling idea is possible somehow then
13:42:15 <lispy> jmcarthur: but that gc is conservative for C so it leaks a little all the time
13:42:34 <jmcarthur> lispy: don't you have to replace malloc and realloc with GC_malloc and GC_realloc for that?
13:42:49 <jmcarthur> or is that what you mean by "splice in"?
13:43:00 <lispy> jmcarthur: Hmm...So in the worst case maybe it needs some massaging?
13:43:04 <alexyk> can I use a Fedora haskell-platform on CentOS?
13:43:06 <jmcarthur> yeah i guess
13:43:18 <lispy> jmcarthur: I was actually thinking at the linker step
13:43:23 <jmcarthur> ah
13:43:34 <lispy> alexyk: should work
13:43:34 <kmc> using boehm GC on a managed language is a perversely terrible idea
13:43:47 <jmcarthur> it may be possible, but i think standard boehm usage is to use GC_malloc
13:43:57 <jmcarthur> kmc: yeah :(
13:44:02 <jmcarthur> i think lhc uses it currently
13:44:23 <jmcarthur> at least, i couldn't get anything to build with lhc until i installed boehm
13:44:28 <lispy> I think of using it as just a cheap hack to get some GC in place
13:44:38 <jmcarthur> yeah
13:45:01 <thoughtpolice> jmcarthur, lispy: correct
13:45:19 <tomberek> listTuple
13:45:19 <lambdabot> tomberek: You have 1 new message. '/msg lambdabot @messages' to read it.
13:45:23 <lispy> once upon a time I was writing a schema -> x86 compiler and the GC is kind of where I stopped :)
13:45:23 <tomberek> oops
13:45:38 <thoughtpolice> it's on my TODO list to write a new GC that is actually accurate as opposed to conservative
13:45:40 <lispy> These days, I think I should translate to Haskell and then compile that
13:46:01 <jmcarthur> thoughtpolice: for lhc?
13:46:05 <thoughtpolice> yes
13:46:07 <lispy> (actually, not meant to be scheme either, but instead elisp)
13:46:12 <jmcarthur> rock
13:46:18 <thoughtpolice> there are several things i'm meaning to do
13:46:27 <thoughtpolice> GC and FFI are two major ones
13:46:37 <jmcarthur> thoughtpolice: while you're at it, write an incremental gc for ghc. :)
13:46:46 <jmcarthur> something good enough for soft-real-time
13:46:55 <matt_m> kmc:  Regarding the transparent IO, I don't think we want IO to be data, for efficiency reasons.  I think it'd be better to have IO values be functions - you can't inspect them, but evaluation is still pure.
13:48:04 <matt_m> kmc:  But I agree having pure evaluation would be desirable.  It should be possible to interpret IO values in a context in which they don't produce side effects
13:48:20 <matt_m> by substituting your own interpreter
13:48:40 <thoughtpolice> jmcarthur: considering I want to turn LHC into a cross compiler (like JHC) at sometime in the future too, so you can take one big C file -> compile and run anywhere, perhaps an incremental GC is better suited for lhc ;)
13:49:04 <copumpkin> or no GC!
13:49:10 <jmcarthur> thoughtpolice: btw, i'm sure it comes up for you already, but my experiments with lhc have occasionally resulted in a C file that has multiples of the same case in a switch statement
13:49:33 <thoughtpolice> jmcarthur: oh yes, the optimizer passes right now are pretty puny
13:49:35 <jmcarthur> with different code for each case though, so i don't even know how to fix it manually
13:49:48 <jmcarthur> heh
13:49:49 <fryguybob> kmc: Why forth? is there some haskell to forth compiler?
13:49:58 <jmcarthur> just making absolutely sure that it's known
13:50:14 <jmcarthur> thoughtpolice: compile and run anywhere would be awesome
13:50:32 <thoughtpolice> right now there's not much more than DCE, some inlining and basic simplification done after transformation to GRIN, then we do a transformation to Grin2 (which is simpler,) where we do DCE and simplification, then just spit out C code
13:50:39 <thoughtpolice> (DCE = dead code elimination)
13:50:50 <thoughtpolice> there are about 50 optimizations in boquist's thesis which need implementation I think ;)
13:50:50 <kmc> fryguybob, not that i'm aware of
13:51:01 <jmcarthur> i've been meaning to read about grin
13:51:08 <thoughtpolice> plus a ton more we'll eventually think up in mad-scientist labs
13:51:21 <kmc> i mentioned forth because it's an interesting language and is used for embedded and low-level programming
13:51:52 <fryguybob> kmc: Ok, just wondering... if there was I would use it :D.
13:52:48 * hackagebot twidge 1.0.1 - Unix Command-Line Twitter and Identica Client  http://hackage.haskell.org/package/twidge-1.0.1 (JohnGoerzen)
13:53:32 <thoughtpolice> jmcarthur: also, some optimisations could definitely be broken. me and lemmih are in the process of improving the test suite and build process right now
13:53:48 <thoughtpolice> so it's easier to see when things break
13:53:52 <thoughtpolice> aside from that, memory usage :/
13:54:10 <thoughtpolice> which actually isn't *terrible* for such simple code, but still somewhat bad IMO.
13:54:30 <thoughtpolice> (2kLOC + GHC's base library) == 800mb residential memory used for control flow analysis, etc
13:54:37 <forrest> err, how does one get a just plain thingie from an IO thingie ?
13:54:48 <jmcarthur> thoughtpolice: is there a projected timeline on this stuff?
13:54:54 <kmc> forrest, you mean convert IO a to a?
13:54:56 <kmc> forrest, you don't
13:55:04 <forrest> kmc: exactly
13:55:06 <thoughtpolice> because when you do something as simple as 'putStrLn', you're really pulling in a ton of code from GHC (i.e., all the new encoding stuff that went into 6.12)
13:55:13 <kmc> forrest, but you can use the thing within a sequence of IO steps
13:55:21 <jmcarthur> forrest: you turn a plain function into a function that works on IO :)
13:55:30 <thoughtpolice> better than JHC at first, anyway
13:55:40 <kmc> do { putStrLn "Enter your name:"; name <- getLine; print ("Hello, " ++ name) }
13:55:48 <thoughtpolice> JHC circa 2005/2006 -> compile 'hello world', say goodbye to 1 gigabyte of RAM and 20 minutes of CPU time
13:55:57 <jmcarthur> heh
13:55:57 <thoughtpolice> jmcarthur: no
13:56:12 <kmc> forrest, the "<-" syntax within "do" is crucial here
13:56:16 <thoughtpolice> jmcarthur: Lemmih and I are on complete opposite sides of the globe, so communication takes place at roughly 12 hour intervals sometimes
13:56:19 <kmc> getLine has type IO String, meaning it's some action which, if performed, would give you a string
13:56:24 <kmc> when you say "name <- getLine"
13:56:24 <forrest> ah the <- is critical
13:56:25 <jmcarthur> ha
13:56:27 <forrest> ok
13:56:28 <thoughtpolice> (he's sweden, i'm CST in the US)
13:56:32 <kmc> you are saying "run that action, and call the result 'name' locally"
13:56:42 <jmcarthur> where in the US?
13:56:47 <kmc> then in the rest of the "do" block, name :: String
13:56:47 <thoughtpolice> jmcarthur: texas
13:56:48 * jmcarthur is CST as well
13:56:50 <jmcarthur> ah
13:56:59 <jmcarthur> alabama, here
13:57:01 <matt_m> thoughpolice: Where in Texas?
13:57:03 <forrest> is there a type of <- ?  I can't do :t (<-) in ghci
13:57:07 <kmc> forrest, no
13:57:11 <kmc> it's not an operator; it's syntax
13:57:13 <Botje> <- is syntax
13:57:15 <matt_m> thoughtpolice: ^
13:57:21 <kmc> "do" is syntactic sugar
13:57:22 <forrest> alright
13:57:26 <thoughtpolice> matt_m: houston
13:57:27 <kmc> for (>>=), which *is* an ordinary operator
13:57:34 <matt_m> thoughtpolice:  I used to live in Houston
13:57:35 <kmc> forrest, i recommend http://haskell.org/haskellwiki/Introduction_to_IO
13:57:47 <benc__> this is the bit where someone tells you what <- gets translated into and its impossible to understand
13:57:47 <thoughtpolice> matt_m: are you mmorrow, by chance?
13:57:48 <kmc> to get a quick handle on this stuff
13:57:57 <matt_m> thoughtpolice:  No
13:58:02 <thoughtpolice> ah, ok just wondering
13:58:09 <thoughtpolice> mmorrow lived in austin I believed, so I was just wondering
13:58:22 <forrest> kmc: thanks
13:58:33 <kmc> do { x <- a; b }   ===>   a >>= (\x -> b)
13:58:34 <matt_m> thoughtpolice:  Well I currently live in Austin actually.. but I'm still not mmorrow :)
13:58:38 <thoughtpolice> jmcarthur: but, the current plan for LHC is just to release early and often until we get something that can 'mostly work' for a good set of programs
13:58:41 <thoughtpolice> matt_m: ah
13:59:15 <thoughtpolice> jmcarthur: if you'd like to help, please drop by in #lhc-compiler - there is a lot of low hanging fruit, e.g. I just rewrite the entire command line interface
13:59:34 <thoughtpolice> so now you can just say 'lhc file.hs' and nothing else, for whole program goodness :)
14:00:57 <kmc> hi edwardk
14:01:01 <kmc> i'm coming to Boston Haskell again, i think
14:01:07 <edwardk> kmc: woot =)
14:01:12 <kmc> going to be in town most of the summer
14:02:10 <copumpkin> damn, I'm missing kmc again
14:02:14 <edwardk> i have two libraries that use stablenames that i was debating between to talk about, my external sat solving monad using stablenames (which might fit very well with nirav's talk) and the reverse mode ad stuff
14:02:16 <kmc> :(
14:03:26 <edwardk> i'll probably use the AD lib, just because i won't have to do as much to polish it up for public release
14:04:03 <edwardk> kmc: what brings you out our way this summer?
14:04:17 <kmc> nothing in particular
14:04:21 <kmc> seems like a cool place to live
14:04:35 <kmc> i like NYC but it's expensive and most of the tech jobs are in finance
14:04:41 <edwardk> *nods*
14:04:46 <kmc> (that's where i am now)
14:11:15 <ezeike> Hey, pretty new to haskell. I need to compare two strings and take an action if they are different. Anyone have some pointers or sample code?
14:11:26 <kmc> > "foo" == "bar"
14:11:26 <lambdabot>   False
14:11:40 <kmc> > if "foo" == "bar" then 3 else 7
14:11:40 <lambdabot>   7
14:11:52 <sepp2k> ezeike: Action as in IO? If so then use when
14:12:00 <kmc> > when ("foo" /= "bar") $ putStrLn "different"
14:12:00 <lambdabot>   <IO ()>
14:12:01 <kmc> :t when
14:12:02 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:12:25 * djahandarie does not think he meant using a monad
14:13:21 <aristid> :t when
14:13:22 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:13:39 <djahandarie> Maybe by "pointer" he meant Foreign.ForeignPtr? :P
14:13:39 <aristid> @src when
14:13:39 <lambdabot> when p s = if p then s else return ()
14:14:17 <djahandarie> I'd still like to see (>> return ()) as a function in some library
14:14:25 <djahandarie> :t (>> return())
14:14:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
14:14:46 <djahandarie> @hoogle m a -> m ()
14:14:46 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
14:14:46 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
14:14:46 <lambdabot> Text.ParserCombinators.ReadP skipMany :: ReadP a -> ReadP ()
14:14:51 <djahandarie> :-(
14:15:07 <aristid> @src void
14:15:07 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:15:27 <djahandarie> Preferably without importing Foreign. :P
14:15:27 <aristid> djahandarie: write your own library?:)
14:15:41 <djahandarie> aristid, just for one function? lol
14:16:05 <djahandarie> It's just something I find myself doing all the time
14:16:22 <aristid> djahandarie: you probably can find other things too :)
14:16:30 <djahandarie> Maybe
14:20:52 <FunctorSalad> @pl \f x z -> x z >>= f z
14:20:52 <lambdabot> flip (liftM2 (>>=))
14:21:12 <FunctorSalad> @pl \f x z -> f z =<< x z
14:21:13 <lambdabot> liftM2 (=<<)
14:21:19 <FunctorSalad> hmm...
14:21:20 <kmc> :t liftM2 (>>=)
14:21:21 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (a -> m b) -> m1 (m b)
14:21:37 <FunctorSalad> maybe liftM2 should just be called 'l' or so :p
14:21:50 <kmc> :P
14:21:58 <FunctorSalad> it's a bit too ugly to really be able to say that it prettifies above code
14:22:07 <ezeike> sepp2k: Don't think it's IO, it's an Xmonad action
14:22:20 <FunctorSalad> X is fine too
14:22:25 <FunctorSalad> "when" works with any monad
14:22:29 <kmc> an X monad is fine too
14:22:48 <FunctorSalad> oh no you saw through it ;)
14:25:23 <ezeike> ok I tried it out, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25902#a25902
14:25:25 <ezeike> got an error
14:25:58 <gwern> today is a good day to file a ghc request for an option that removes intermediate files
14:26:21 <zooko> Folks: is there any way I can get the haskell platform for my old Solaris/x86 system?
14:26:23 <gwern> kmc: you know, the other day I saw the 'a cat is fine too' meme pop up in an episode of _Bakemonogatari_
14:27:19 <kmc> ezeike, oldWS is not a string
14:27:40 <kmc> it's an IO action that, when executed, creates a new mutable reference cell and stores the string "1" in it
14:27:50 <gwern> zooko: on a weirdo platform like that, it may be better to start with ghc and build up from there with cabal-install
14:28:07 <gwern> zooko: I offhand haven't heard of any solaris support in HP. supporting windows/linux/mac is hard enough
14:28:09 <kmc> saying «oldWS = newIORef "1"» is not good enough to create a global IORef
14:28:14 <ezeike> kmc: ok. any iea how I can make this work then?
14:28:20 <kmc> you're just giving a name to the "make a new IORef" action
14:28:23 <kmc> you're not making one
14:28:27 <FunctorSalad> ezeike: execute the creation of the IORef in main
14:28:41 <FunctorSalad> then pass it to your function as a local variable
14:29:12 <zooko> gwern: thanks
14:29:54 <FunctorSalad> main = do { r <-newIORef 1 ; ... XConfig { someHook = myHook r } }
14:30:23 <FunctorSalad> myHook r = ..your previous code, which now has an IORef it can use..
14:32:14 <ezeike> FunctorSalad: ok thanks. it now says r not in scope, my defaultConfig (where someHook would be) is defined outside of main though
14:34:42 <FunctorSalad> ezeike: it has to be connected to main somehow though :) and you needn't create the IORef in *main*, you just want to create it *once*, not every time the hook is run
14:35:01 <FunctorSalad> (which would happen if you do "d <- newIORef 1" in the hook)
14:35:13 <FunctorSalad> err nvm the change of var name
14:35:14 <tomberek> is there some way to do newtype Only a b = Only {runOnly:: a b c} with forall c or something?
14:35:37 <FunctorSalad> forall c. runOnly :: a b c
14:36:04 <tomberek> FunctorSalad: but then it needs to be data?
14:37:10 <copumpkin> tomberek: what would you do with such a type? :o
14:37:28 <tomberek> copumpkin: drop type information i no longer need
14:37:29 <FunctorSalad> tomberek: no
14:37:30 <copumpkin> do you want it to be existential or universal?
14:37:53 <FunctorSalad> ("no" for the universal)
14:38:14 <tomberek> i want to be able to do     (* -> * -> * )   ->   *->*
14:39:15 <gwern> 'Add a flag to remove/delete intermediate files generated by GHC' http://hackage.haskell.org/trac/ghc/ticket/4114 <-- thoughts?
14:39:46 <kmc> tomberek, newtype Only a b = Only { runOnly :: forall c. a b c }
14:40:01 <kmc> requires PolymorphicComponents, or Rank2Types, or RankNTypes, etc.
14:40:32 <tomberek> whoa!  i haven't used those much
14:40:39 <copumpkin> tomberek: it may not be what you want though
14:40:46 <kmc> Only :: (forall c. a b c) -> Only a b
14:40:51 <kmc> which has a "forall" on the left of ->
14:40:55 <kmc> which is what makes it higher-rank
14:41:10 <kmc> this is a weird thing to want, but i'm sure there's some use case
14:41:22 <copumpkin> what kinds of type constructors will a be?
14:41:31 <kmc> i think the existential makes more sense
14:41:34 <tomberek> kmc.. um, I'm not sure the difference between where the forall c is
14:41:35 <copumpkin> I'm thinking of (,) or Either or (->)
14:41:41 <copumpkin> and none of them have any meaningful use
14:41:48 <kmc> tomberek, what i gave is the universal type
14:42:02 <Twey> Why does Rank2Types still exist?  Does it provide something RankNTypes doesn't?
14:42:02 <preflex>  Twey: you have 1 new message. '/msg preflex messages' to read it.
14:42:07 <copumpkin> you can't construct a (,) with a universal snd wiithout undefined
14:42:10 <kmc> Twey, decidable inference
14:42:12 <kmc> iirc
14:42:34 <kmc> tomberek, with my version, «Only (Left 'x') :: Only Either Char»
14:42:36 <FunctorSalad> with some "but"?
14:42:41 <copumpkin> Either with a universal right gives you nothing over the plain value, and (->) with a universal return value needs undefined
14:43:08 <tomberek> i think i'm lost
14:43:09 <kmc> tomberek, but if you try to use Right you'll need to pass something like "undefined" -- because the Only ctor gets to choose 'c'
14:43:17 <kmc> tomberek, maybe you could describe what you're trying to accomplish
14:44:03 <kmc> if the idea is that «Only Either a» represents «Either a b» for some particular, unknown b, then you want the existential version
14:44:06 <tomberek> kmc: i'm using ATs   and i need to destroy a kind
14:44:16 <kmc> that's not any clearer
14:44:38 <kmc> maybe you just want a synonym where not all the vars on the LHS are used?
14:44:39 <copumpkin> tomberek: like saying "I want to take a Maybe a to a", you need to decide what to do with the discrepancy :P
14:45:02 <copumpkin> in the Maybe case you need to decide what to do with the Nothing, here you need to decide how you want your missing type variable to behave
14:46:01 <FunctorSalad> just throw a "user error" in case of Nothing
14:46:02 <FunctorSalad> ;)
14:46:13 <kmc> why don't we implicitly make Nothing an element of every type
14:46:17 <copumpkin> type-level error calls
14:46:24 <copumpkin> kmc: omg good idea
14:46:30 <kmc> {-# LANGUAGE Java #-}
14:46:30 <copumpkin> it's kind of a long name though
14:46:37 <copumpkin> need something shorter :)
14:46:49 <gwern> '@Steve: In 2005 the GHC run-time system was four times the size of Version 6 Unix. Since then it has only gotten bigger. – Norman Ramsey Jan 6 at 4:56'
14:46:57 <kmc> haha
14:46:59 <Gracenotes> -XNoJava
14:47:00 <tomberek> kmc.. um, it's hard to explain.. maybe I can show in a paste
14:47:03 <kmc> yeah
14:47:04 <kmc> that'd be good
14:47:33 <FunctorSalad> "size"?
14:48:06 <gwern> hm, 4114. nice number
14:48:10 <gwern> FunctorSalad: LoC I'd guess
14:48:39 <FunctorSalad> (I have no idea how big a Unix 6 is tbh)
14:53:34 <tomberek> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25903#a25903
14:53:46 <tomberek> kmc: i tried to delete all the other stuff
14:54:59 <copumpkin> still doesn't really tell us much
14:55:08 <tomberek> dang
14:55:25 <copumpkin> the only comment you have in there doesn't mention the type you're asking us about :)
14:55:36 <copumpkin> unless I'm missing something
14:55:59 <tomberek> oops.. those Const's should be Identity
14:57:11 <tomberek> so... Shape (Of f m) is of kind *->*      so I want Shape (Of f m) a  --> Of f (Shape m a)
14:57:44 <tomberek> but ATs don't let me write that a
14:58:26 * kmc is in a twisty maze of asstypes
14:58:36 <copumpkin> I thought it was allowed if you turned on undecidable instances
14:58:50 <kmc> can you describe what the classes Rip and Merge mean?
14:59:15 <kmc> if m is an instance of Rip, then «m a b» is what sort of thing?
14:59:31 <tomberek> kmc:  well, there's the idea of a Product.. simple instances are (,)  and data Prod a b = Prod a b
14:59:37 <kmc> sure
14:59:49 <tomberek> and so you can have a Functor `Of` Product
15:00:20 <tomberek> edwardk suggested I split up Product into Splittable,Joinable... for ease, Rip and Merge
15:00:59 <tomberek> I want to be able to go from :::   Of Functor Product a b --->  On Product Functor a b
15:00:59 <copumpkin> ah, I see
15:01:01 <kmc> what provdse Control.Functor.Combinators.Of ?
15:01:09 <copumpkin> category-extras I'd assume
15:01:13 <tomberek> yep
15:01:21 <kmc> k
15:01:24 <copumpkin> damn, it's midnight
15:01:41 <kmc> hahaha
15:02:00 <kmc> @remember copumpkin <copumpkin> damn, it's midnight  * copumpkin is now known as pumpkin
15:02:00 <lambdabot> I will never forget.
15:02:01 <mreh> shouldn't you turn into a carriage?
15:02:11 <tomberek> kmc: i've tried making Shape m :: * -> * -> *  but i run into similar problems
15:02:15 <pumpkin> :)
15:02:22 <sinelaw> lambdabot is back
15:02:23 <sinelaw> nice
15:02:25 * pumpkin is too jetlagged to think
15:02:29 <pumpkin> g'night!
15:02:43 <sinelaw> night
15:02:45 <kmc> i wonder what would happen if i understood all of category-extras at once
15:02:53 <kmc> if my skull would literally explode from the outward pressure
15:02:59 <tomberek> kmc: a small rip in space-time
15:03:13 <RichardBarrell> kmc: enlightenment.
15:03:17 <tomberek> kmc: i'm actually getting more and more comfortable with it.. I'm using it to learn
15:04:03 <kmc> okay so «Of f p a b» =~ «f (p a b)» ?
15:04:25 <tomberek> yes,,, in cat-speak    Of f p a b -> On p f a b
15:04:27 <kmc> so it's like (.).(.) at type level
15:04:49 <kmc> :t (.).(.)
15:04:50 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:04:50 * BMeph wonders if that space-time-rip...thing explains ddarius' success in his military endeavors and rock climbing...
15:04:55 <tomberek> kmc   Functor of Products   <------> Product of Functors    is the functionality i want
15:04:58 <kmc> ok
15:05:00 <kmc> right
15:05:04 <kmc> so p might be (,)
15:05:06 <c_wraith> I read that as ddarius-prime
15:05:10 <tomberek> yes
15:05:17 <kmc> ok
15:05:22 <kmc> i am slowly grokking your code
15:05:24 <kmc> :)
15:05:47 <kmc> so you want to break this "Product" concept into "Rip" and "Merge"
15:06:03 <tomberek> kmc: this shows an example that works, but i'm trying to clean it up.. check out the first section  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25875#a25875
15:06:30 <mreh> since we're going off topic, what is a "hybrid-domain convolution"?
15:06:41 <kmc> so each product has a Shape ty-con and an Info ty-con, each of which might be instantiated for either pair element
15:06:59 <kmc> "shape" and "info" are strange names for what to me seem symmetrically acting on the first or second element
15:07:05 <kmc> but i suppose you have a particular application in mind
15:07:57 <tomberek> kmc:  yes,  this at first glance seems similar to Control.Functor.Zip
15:08:33 <kmc> yeah
15:09:27 <kmc> and you said the Consts in the Rip (,) instance should be Identity?
15:09:27 <tomberek> kmc: maybe a first/second concept might be better, but those are taken ,, i'm not attached to the names, open to suggestions
15:09:33 <kmc> that would make more sense to me
15:09:36 <tomberek> yeah, sorry
15:09:40 <kmc> ok cool
15:10:32 <kmc> and then you want Shape and Of to commute
15:10:42 <kmc> likewise Info?
15:11:05 <tomberek> correct, i think.. hehe
15:11:24 <tomberek> did you see the examples.. that code is working,, i'm trying to abstractify it
15:11:41 <kmc> i see
15:12:48 <kmc> this is more code than i'm prepared to read right now
15:12:50 <kmc> sorry :/
15:13:09 <tomberek> kmc: only look at the examples at the top
15:13:19 <tomberek> kmc: it explains the concept in a few lines
15:17:53 <qz> is it possible to get access to symbols local to some function in ghci?
15:19:49 <kmc> no :/
15:20:00 <kmc> sort of, with the ghci debugger
15:20:07 <qz> sad :( would've helped with debugging..
15:20:20 <kmc> qz, you can use Debug.Trace to print out values as evaluation happens
15:20:43 <qz> kmc, is it possible to print types? like :t in ghci
15:20:55 <kmc> hmm
15:20:58 <kmc> types are known statically
15:21:15 <kmc> but perhaps you want to get the type inferred for a local "let" or "where" binding
15:21:24 <kmc> i don't know a way to do that, other than giving it a bogus signature and seeing what the error is
15:21:40 <qz> yeh, i need it for a let
15:21:47 <qz> how do i give it a bogus signature?
15:22:11 <kmc> > let x :: Char; x = 2 + 7 in x
15:22:11 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
15:22:11 <lambdabot>    arising from the literal `2...
15:22:24 <kmc> qz, you can use signatures in "let" just as at top level
15:24:45 <lispy> I heard this was a good place to learn about lambdas.
15:25:16 <qz> kmc, if only i'd know how to do it at top level :p you doing let a = blabla and then doing a :: Sometype ?
15:25:50 <aavogt> there was a tool using the ghc-api to ask what the types of undefinedS were in your file
15:25:52 <kmc> qz, you haven't been putting type signatures on your top-level bindings?
15:25:59 <kmc> qz, most tutorials introduce that really earl
15:26:00 <kmc> y
15:26:05 <kmc> because it's important for getting good error messages
15:26:11 <qz> ah, you mean that. i see
15:27:25 <aavogt> http://www.haskell.org/haskellwiki/Hac5/Projects#Goals_in_GHC.28i.29
15:29:28 <kmc> aavogt, cool, but the github repo hasn't been touched in a year :/
15:29:34 <kmc> maybe it works though
15:30:18 <kmc> i don't see it on hackage
15:31:30 <gwern> aavogt: I don't even understand what that goals thing is
15:34:21 <aavogt> kmc: it works
15:34:32 <kmc> cool
15:34:56 <kmc> you have to patch ghc?
15:35:03 <aavogt> gwern: you have a program that tells you what the types of values in expressions are
15:35:21 <aavogt> kmc: It did something useful without a patch to ghc
15:35:22 <ddarius> @google chameleon type debugger
15:35:24 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.73.6170&rep=rep1&type=pdf
15:35:24 <lambdabot> Title: The Chameleon Type Debugger (Tool Demonstration)
15:36:32 <gwern> aavogt: instead of having to lift things to the top level?
15:37:03 <aavogt> yes
15:38:33 <qz> hrm.. earlier i was told that 'you can never escape IO' when i wanted to convert [IO String] into [String], but isnt <- doing that ?
15:38:41 <kmc> qz, sort of
15:38:44 <aavogt> sequence
15:38:51 <kmc> you don't really get a String value out
15:38:58 <kmc> it's more like you provide a function and it gives the string to that function
15:39:05 <kmc> the function is implicitly the rest of your "do" block
15:39:19 <kmc> do { x <- a; b }   ===   a >>= (\x -> b)
15:39:25 <qz> ah
15:39:31 <kmc> this (>>=) is the cornerstone of the typeclass named Monad
15:39:40 <kmc> in the case of IO, its type is «IO a -> (a -> IO b) -> IO b»
15:39:41 <aavogt> qz: [IO String] doesn't specify any order for the effects by each element of the list
15:40:04 <kmc> [IO String] is a list of recipes.  you can choose to execute all or none or some of the recipes, and in any order, or possibly more than once
15:40:16 <qz> hrm
15:40:28 <qz> and sequence just executes them all once in order?
15:40:31 <kmc> i.e. «sequence» and «sequence . reverse» are two different functions of type «[IO String] -> IO [String]» that will give you different results
15:40:31 <kmc> yes
15:40:51 <kmc> sequence_ [] = return ();  sequence_ (x:xs) = do { x; sequence_ xs }
15:40:58 <kmc> that's sequence_, the version which throws out the results
15:41:11 <kmc> the code for sequence is a bit longer but not bad either
15:41:21 <kmc> sequence :: [IO a] -> IO ()
15:41:36 <kmc> note that these functions like "sequence" and "mapM" are ordinary functions you can defin
15:42:00 <kmc> Haskell has user-defined control flow structures, essentially, but they're ordinary functions
15:42:18 <edwardk> the magic of laziness
15:42:26 <deech> Hi all, I have a datatype : data Session = forall a b. Cont a b. Can I make Map of Sessions that have different Cont types?
15:42:39 <qz> how do you guys keep that all in a head.. =p
15:42:49 * qz goes back to tutorial
15:42:53 <aavogt> I don't think that matters until you want something somewhat different from what's in the library
15:43:15 <kmc> edwardk, those aren't the ones i meant actually
15:43:17 <kmc> but that too
15:43:33 <kmc> deech, you can make a [Session] yes
15:43:36 <kmc> that's an existential type
15:43:39 <edwardk> deech: yes, but you usually need some mechanism to disambiguate the types, i.e. Typeable or the fact that the map uses stablenames as keys so you can check the types indirectly, etc.
15:44:03 <benmachine> deech: if you get a Session out, you can't really do anything with the a b in the Cont constructor
15:44:08 <benmachine> because they could be of any type
15:44:16 <edwardk> in general you use an existential to box up those different types, and then need to use some other mechanism (like the typeable, etc) to get the type back out
15:44:23 <aavogt> benmachine: you can unsafeCoerce!
15:44:31 <benmachine> aavogt: ouch
15:44:37 <benmachine> but, true I guess
15:44:47 <aavogt> that's what edwardk is suggesting anyhow
15:44:50 <kmc> usually the solution is to bundle in some operatiors
15:44:57 <benmachine> you can't really do it safely unless you have some other information though
15:45:09 <edwardk> aavogt: well, Typeable at least gives you a er.. 'safeCoerce' ;)
15:45:18 <kmc> data Counter = forall c. Counter { new :: IO c, incr :: c -> IO () }
15:45:22 <kmc> look it's an object ;)
15:45:25 <benmachine> relativelySafeCoerce
15:45:27 <deech> I see. Well I'm trying to store sessions for a web app. So some session "abcdef" maps to a suspended function "Cont a b".
15:45:33 <benmachine> safeUnlessYouDeliberatelyTryToBreakItCoerce
15:45:37 <kmc> and often these operations you bundle come from a type class
15:45:41 <ezyang> benmachine: :^)
15:45:41 <kmc> though it's not required
15:45:57 <kmc> and i find that OOP in Haskell is easier if you don't try to use type classes for everything you'd use an OO class for
15:46:02 <kmc> because classes are mostly just types
15:46:07 <edwardk> deech: the question is why is there an actual 'b' ? if you change your perspective perhaps you just have a Cont a (IO ()) -- or a ContT r IO a for a common r tye
15:46:55 <chrisdone> http://tryhaskell.org/?input=let%20d%3d40;b%3dd/10%20in%20sequence_[circle(sin%20i*d%2bd%2bb)(cos%20i*d%2bd%2bb)(d/20)|i%3C-[0,0.4..6.2]]
15:46:57 <chrisdone> hehe
15:47:03 <kmc> djahandarie, my friend figured out how to get from Storrs to Boston using a series of buses
15:47:53 <kmc> woah it has a drawing API?
15:47:55 <kmc> how's it work?
15:47:58 <deech> edwardk: ok lets say that all my apps return an "IO String" making my continuations "Cont r (IO String)", how does that change the one free variable?
15:48:25 <benmachine> Graphics.Raphael.Raphael
15:48:36 <benmachine> is involved somehow.
15:48:50 <aavogt> what does the second Raphael mean?
15:49:00 <edwardk> deech: well, what i was getting at was if you can lift things up into a single common type for all of your continuations you don't have to worry about the existential headaches
15:49:11 <benmachine> I imagine it's the Raphael type constructor in the Raphael module
15:49:18 <edwardk> aavogt: same as Data.Array.Array or Data.Data.Data ;)
15:49:27 <benmachine> I just made it type error and then picked something that looked likely
15:49:32 <edwardk> though the latter is just gratuitous
15:49:37 <aristid> aavogt: Graphics.Raphael is the module
15:49:37 <benmachine> heh
15:49:43 <kmc> need moar data
15:49:53 <aristid> try typing :t circle in tryhaskell.org
15:50:07 <kmc> i did that but it froze
15:50:25 <deech> edwardk: true, I'll try to tighten up the datatype.
15:50:27 <kmc> i'd guess that Raphael is a monad
15:50:59 * edwardk just had to effectively reimplement the entire haskell numeric type tower 'one level up' on terms of kind * -> * how sad
15:51:02 <chrisdone> kmc: hey it uses the Raphael javascript library
15:51:20 * benmachine hugs edwardk better
15:51:44 <chrisdone> kmc: and yeah, the Raphael is just a writer monad for generating some simple commands for tryhaskell to pick up and translate to Raphael
15:52:39 <chrisdone> http://github.com/chrisdone/graphics-raphael/blob/master/Graphics/Raphael.hs
15:52:53 <aristid> chrisdone: cool
15:53:04 <edwardk> benmachine: in order to be able to define my various AD combinators in a way that i can safely mix and match different ad modes i wound up wanting the signature to look something like:
15:53:14 <aavogt> @unmtl Writer w a
15:53:14 <lambdabot> (a, w)
15:53:37 <edwardk> diff2UF :: Functor f => (forall s. Mode s => AD s a -> f (AD s a)) -> a -> f (a,a) -- for a function that returns the answer and first derivatives of a function that returns multiple answers, for instance
15:53:41 <doofer> hello everyone!
15:53:48 <chrisdone> ah, sorry. it's state monad. for later recall of variables
15:53:48 <doofer> does anyone know of a reasonable way to achieve something equivalent to deriving Eq and Ord instances where only constructors and not constructor arguments are taken into account (for example, data E = Ident String | ...; Ident _ == Ident _ = True)?
15:54:03 <kmc> :t (==) `on` toConstr
15:54:04 <lambdabot> forall a. (Data a) => a -> a -> Bool
15:54:09 <edwardk> However, to have any actual interesting functions, then (forall s. Mode s => AD s a) needs to be a Num if a is a Num, Floating if a is Floating, etc.
15:54:17 <chrisdone> :t toConstr
15:54:18 <lambdabot> forall a. (Data a) => a -> Constr
15:54:24 <chrisdone> what's this Data class?
15:54:27 <chrisdone> @hoogle Data
15:54:28 <lambdabot> module Data.Data
15:54:28 <lambdabot> Data.Data class Typeable a => Data a
15:54:28 <lambdabot> Data.Data dataCast1 :: (Data a, Typeable1 t) => c (t d) -> Maybe (c a)
15:54:32 <aavogt> generic programming
15:54:32 <chrisdone> oh ok
15:54:38 <kmc> > let f = (==) `on` toConstr in (f (Just 3) (Just 7), f (Just 3) Nothing)
15:54:38 <lambdabot>   (True,False)
15:54:42 <kmc> it's from SYB
15:54:56 <kmc> doofer, ^^^
15:55:02 <edwardk> chrisdone: Data.Data.Data is used for generic programming it comes from the 'scrap your boilerplate' set of generic programming combinators
15:55:11 <chrisdone> sure
15:55:19 <kmc> doofer, you can derive Data in GHC
15:55:24 <edwardk> GHC is smart enough to define instances for you
15:55:37 <edwardk> if you let it
15:56:18 <doofer> oh, that seems to be exactly what I'm looking for!
15:56:23 <doofer> thanks :)
15:56:25 <aavogt> doofer: if you don't want to count underscores, you can also write    Ident {} == Ident {} = True
15:56:26 <kmc> damn, raphael can produce some nice output
15:56:27 <kmc> death to flash :)
15:56:29 * edwardk really needs to write a blog article on 'scrap your boilerplate without losing abstraction'
15:57:03 <aavogt> edwardk: you mean it's not unavoidable?
15:57:23 <aavogt> this is sort of like how there is (or should be) a Data instance for Data.Fixed
15:57:40 <edwardk> aavogt: not if you're smart about it. though, you typically need to expose fake constructors
15:58:19 <edwardk> aavogt: take a look at the Data instance in http://hackage.haskell.org/packages/archive/heaps/0.2/doc/html/src/Data-Heap.html
15:58:23 <aavogt> and then write the data instance yourself :(
15:58:24 <edwardk> aavogt: as an example
15:58:45 <aavogt> @type gfoldl
15:58:46 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
15:58:48 <edwardk> aavogt: the data instance there pretends that 'fromList' is the constructor
15:59:08 <edwardk> so the end user is exposed to just a list of elements that they can do whatever they want to
15:59:27 <aavogt> that's better than nothing
15:59:30 <edwardk> since reconstruction from a list for a brodal/okasaki heap is O(n) it costs me nothing asymptotically to maintain the invariants
16:00:19 <edwardk> so going through gunfold ... gfoldl is still linear
16:00:27 <qz> if i have functions a, b   how do i construct function f that returns a(b) ? (b may have arguments ofcourse)
16:00:40 <kmc> err
16:00:43 <kmc> do you mean a(b) really
16:00:45 <kmc> or do you mean a(b(x))
16:00:50 <kmc> @src (.)
16:00:50 <lambdabot> (f . g) x = f (g x)
16:00:50 <lambdabot> NB: In lambdabot,  (.) = fmap
16:00:54 <qz> yeah ofcourse a(b(x))
16:01:16 <kmc> qz, not sure why "of course", it's a perfectly reasonable thing to pass a function as the argument to another function
16:01:29 <qz> oh.. a dot. nice one
16:01:35 <kmc> yeah
16:01:43 <kmc> it's supposed to look vaguely like the mathematical "compose" operator
16:01:46 <aavogt> it's different with multiple arguments to b
16:01:55 <kmc> :t ?f . ?g . ?h $ ?x
16:01:56 <lambdabot> forall a b a1 a2. (?f::a -> b, ?g::a1 -> a, ?h::a2 -> a1, ?x::a2) => b
16:02:03 <kmc> right
16:02:09 <aavogt> @pl \x y z -> f (g x y z)
16:02:09 <lambdabot> ((f .) .) . g
16:02:10 <kmc> every function in Haskell really only has one argument
16:02:21 <chrisdone> @pl \f g x -> f (g x)
16:02:21 <lambdabot> (.)
16:02:22 <kmc> so when you account for the convention for encoding multiple arguments
16:02:26 <kmc> then it is different
16:02:36 <aavogt> at which point you're probably better off writing the lambda
16:02:48 <kmc> :t \f g -> (f.) . g
16:02:49 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
16:02:49 <chrisdone> or using ~>!!
16:02:56 <kmc> what in bloody hell is that
16:03:18 <qz> was gonna ask same thing..
16:03:26 <aavogt> there is a library for that kind of stuff, right?
16:03:36 <qz> aavogt, multiple arguments where? to function b?
16:03:45 <edwardk> hrmm the haskell platform page on how to get the platform for Ubuntu Karmic/Jaunty is still talking about the 2009 platform.
16:03:54 <qz> so if its a(b(x,y)) it becomes more complicated than dot?
16:04:06 <kmc> qz, in Haskell, a 2-argument function is usually represented by a function that takes one argument, and returns a function which takes the second argument
16:04:07 <qz> (dot worked just fine in my case)
16:04:20 <kmc> so if you write (f . g) and g is such a "2-argument function"
16:04:29 <aavogt> qz: tuples are single arguments
16:04:30 <kmc> then the function it returns after taking one arg will itself be the arg to f
16:04:42 <qz> oh
16:04:44 <aavogt> qz: f :: a -> b -> c   vs   f :: (a,b) -> c
16:04:50 <kmc> :t (+)
16:04:51 <lambdabot> forall a. (Num a) => a -> a -> a
16:04:52 <kmc> :t uncurry (+)
16:04:53 <edwardk> qz: in haskell we don't usually tuple up our arguments. a function that takes 2 arguments is a function that takes one argument, and returns a function that takes the other.
16:04:53 <lambdabot> forall a. (Num a) => (a, a) -> a
16:04:58 <kmc> > (+) 2 3
16:04:59 <lambdabot>   5
16:05:02 <kmc> > uncurry (+) (2,3)
16:05:02 <lambdabot>   5
16:05:04 <edwardk> hence why (+) has the funny looking type
16:05:12 <edwardk> :t (+)
16:05:13 <lambdabot> forall a. (Num a) => a -> a -> a
16:05:20 <edwardk> :t (+) 1
16:05:21 <lambdabot> forall t. (Num t) => t -> t
16:05:35 <kmc> > map ((+) 3) [1,2,3,4]
16:05:36 <qz> i wonder if there are any benefits in such complexity, in other languages two arguments are uh.. just two arguments
16:05:36 <lambdabot>   [4,5,6,7]
16:05:45 <kmc> qz, yes, many
16:05:54 <kmc> it makes the language simpler -- every function has exactly one arg
16:05:59 <aavogt> you can get wonderful type errors
16:05:59 <kmc> there aren't any zero-arg functions either
16:06:11 <kmc> and it allows a lightweight syntax for partial application
16:06:15 <kmc> which turns out to be very useful
16:06:27 <edwardk> qz: actually it is a level of simplicity, because now you only ever deal with functions of 'one argument' in some sense. you can partially apply functions, you can do a lot of things with them that previously would require you to deal with a lot of manual plumbing
16:06:29 <kmc> i used it in the map above, though there's an even lighter syntax which applies then
16:06:45 <kmc> it is a lot better to say «f = g 3» rather than «f x = g 3 x»
16:06:55 <qz> i see
16:07:00 <mauke> qz: are there any benefits in adding an ad-hoc collection type ("parameter list") that can't be used anywhere else, or stored, or whatever?
16:07:01 <aavogt> I think the underscore notation used elsewhere for partial application isn't too much heavier
16:07:05 <gwern> even if it's strange to learn
16:07:33 <qz> in scala underscores are used to get partial application
16:07:34 <aavogt> but it's sort of an explicit type annotation
16:07:44 <edwardk> aavogt: it becomes harder when you don't really have a separate 'statement' level to scope the _'s to
16:07:56 <kmc> mauke, in good languages it's just sugar
16:07:57 <edwardk> aavogt: which means they tend to be a bad fit in a lazy setting
16:08:00 <gwern> qz: oh noes it's hungarian notation
16:08:05 <kmc> in Python you can ask for or provide your argument list as an actual list
16:08:12 <kmc> (and/or dictionary)
16:08:20 <gwern> kmc: so like lisp?
16:08:23 <kmc> yeah
16:09:07 <aavogt> edwardk: what do you mean by scoping _?
16:09:39 <mauke> def f(g, *xs): return g(*xs)  # does this do what I think it does?
16:09:53 <qz> oh and also.. what is preferred way to do text processing in haskell? (like ruby has regexp syntax sugar builtin)
16:09:53 <kmc> i can't read minds
16:10:17 <aavogt> qz: regexes aren't too bad in haskell
16:10:17 <kmc> qz, depends what you want to do
16:10:23 <kmc> basic list ops, or regex, or real parsers
16:10:25 <qz> tutorials mention isPrefixOf, isSuffixOf.. but those are rather weak tools =p
16:10:34 <chrisdone> well you have regexes with the polymorphic (=~)
16:10:36 <kmc> writing actual parsers in Haskell is easier than writing a complicated regex in any language
16:10:38 <chrisdone> or is it (~=)
16:10:47 <aavogt> @type (=~)
16:10:48 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
16:10:49 <qz> kmc, i need to be able to extract substrings and match string with a pattern
16:10:52 <kmc> btw qz you may like http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html
16:10:55 <edwardk> aavogt: map (_ + _) _ starts to become a bit of a mess, you can scope the _'s to be binding a lambda somewhere, but the choice of delimiter isn't obvious
16:10:55 <kmc> and the rest of the book
16:11:25 <chrisdone> does it unnerve anyone else when people use full words for type variables?
16:11:27 <qz> kmc, thanks. gonna jump to that chapter
16:11:28 <Cale> qz: Parser combinator libraries, like Parsec and ReadP are quite nice for most things that are too complicated to accomplish with something like 'words'
16:11:41 <chrisdone> it's almost like i find it harder to understand because the words are longer
16:11:50 <benmachine> (=~) is like the most typeclass-polymorphic function ever
16:12:03 <Twey> map ($$1 + $1) $2, perhaps?
16:12:08 <aavogt> edwardk: ah, I see now
16:12:34 <Twey> mauke: f = ($)
16:12:36 <chrisdone> edwardk: yeah they try to do this in lisp
16:12:42 <Twey> With varargs
16:12:52 <benmachine> Twey: no I think f = flip const
16:13:05 <benmachine> with varargs... sort of
16:13:09 <Twey> benmachine: Nope
16:13:15 <benmachine> rly?
16:13:20 <Twey> It takes a function and a bunch of arguments, and applies the function to the bunch of arguments
16:13:20 <aavogt> are not regexps faster than parser combinators?
16:13:21 * benmachine tries it out
16:13:30 <chrisdone> (* _ _) = (LAMBDA (X Y) (* X Y))
16:13:41 <edwardk> chrisdone: yeah its just an idea that doesn't hold up well once you remove the magic lisp/schemish meaning from ()'s
16:13:42 <benmachine> ohh,
16:13:43 <benmachine> yes
16:13:56 <benmachine> I didn't keep both g in my head at once >_>
16:14:04 <Twey> Both g?
16:14:13 <Twey> THere's only one g
16:14:27 <benmachine> there are two g's, but they mean the same thing
16:14:28 <edwardk> aavogt: a regexp can be a parser combinator ;)
16:14:31 <JasonFelice> So, what happens if you don't hear from a hackage maintainer to whom you've submitted a patch?
16:14:35 <benmachine> which is what I failed to notice
16:14:37 <chrisdone> aavogt: faster to write?
16:14:38 <benmachine> somehow
16:14:52 <aavogt> edwardk: I mean monadic parser combinators
16:14:52 <qz> hm.. ByteString has almost all stuff i need. is it a direct String replacement?
16:14:58 <mauke> qz: no
16:15:01 <benmachine> I read it as def f(x, *xs): return g(*xs)
16:15:14 <qz> when should i use ByteString then?
16:15:15 <benmachine> and then I told everyone about how silly I was at much greater length than was necessary
16:15:26 <chrisdone> there are loads of standard functions that use String
16:15:28 <edwardk> qz: almost. it only holds bytes, but its fast, its fast to slice, but not to append to
16:15:29 <mauke> qz: when you work with bytestrings
16:15:33 <chrisdone> qz: cuz it's faster in certain situations
16:15:37 <qz> i see
16:15:43 <Twey> benmachine: That would be ‘const g’ anyway
16:15:49 <edwardk> qz: and it has a nice memory footprint
16:15:53 <chrisdone> i.e. large amounts of text
16:15:59 <Twey> Or, well, (const g $)
16:16:25 <qz> holding bytes means it is not encoding-aware and such?
16:16:28 <benmachine> Twey: I subscribe to the in-for-a-penny... model of wrongness
16:16:33 <chrisdone> const g undefined
16:16:34 <Twey> benmachine: Did you know that flip const = const id? :-D
16:16:36 <gwern> my rule of thumb is use bytestring when you're processing big ASCII strings
16:16:40 <benmachine> Twey: yes
16:16:51 * Twey thinks that's quite cool.
16:16:57 <benmachine> also yes :)
16:17:32 <mauke> qz: yes, but the Data.ByteString.Char8 functions effectively give you latin-1
16:18:17 <qz> hm.. what's best way to deal with utf-8 then?
16:18:30 <qz> (i guess Data.ByteString.Utf8)
16:18:37 <chrisdone> Twey: have you seen (~>)?
16:18:44 <mauke> define "deal with"
16:18:50 <Twey> chrisdone: As a type variable?
16:19:03 <Twey> Or conal's editor combinator?
16:19:11 <Twey> (was it conal's?)
16:19:13 <chrisdone> conal's editor
16:19:16 <chrisdone> yeah
16:19:23 <Twey> Yeah
16:19:35 * chrisdone thinks that's awesome
16:22:16 <conal> matt hellige came up with the (~>) idiom which combined my "result" and "argument" combinators in a simpler & terrifically useful way.  http://matt.immute.net/content/pointless-fun
16:22:27 <conal> now i use ~> quite a lot
16:29:34 <tomberek> conal: isn't the applicative you mention just (->)
16:30:29 <conal> tomberek: i mentioned an applicative?
16:30:52 <tomberek> er.. in the blog
16:31:15 <Cale> That's not conal's blog ;)
16:31:20 <tomberek> ah
16:31:42 <Cale> (f ~> g) . (f' ~> g') = (f' . f) ~> (g . g') -- this property is really lovely
16:31:52 <Cale> It's an interchange law :)
16:32:03 <tomberek> what package is all that in?
16:33:14 <conal> tomberek: you'll find aspects in TypeCompose and in DeepArrow
16:33:42 <conal> @wiki TypeCompose
16:33:42 <lambdabot> http://www.haskell.org/haskellwiki/TypeCompose
16:33:45 <conal> @wiki DeepArrow
16:33:45 <lambdabot> http://www.haskell.org/haskellwiki/DeepArrow
16:34:51 <tomberek> conal.. cause i usually find myself looking for something like ~>... what are the differences between those two?
16:34:57 <conal> tomberek: and theory in the Tangible Functional Programming paper
16:35:00 <Cale> Oh, of course... ~> is just "fmap"
16:35:03 <conal> @where Eros
16:35:03 <lambdabot> http://conal.net/papers/Eros
16:35:27 <benmachine> so that law is actually just (f . g) . (f' . g') = ...
16:35:42 <conal> tomberek: DeepArrow is more general.  not limited to ->
16:35:48 <Cale> Well, not quite the usual instance of fmap
16:36:08 <tomberek> conal,, does one of them include a (.).(.) variant?
16:36:25 <Cale> It comes from -> being a bifunctor
16:36:29 <conal> tomberek: both.  i call it result.result
16:36:39 <conal> tomberek: for intuition and generality
16:37:28 <tomberek> conal, i saw in FGL he did (...) = (.).(.) and i liked it
16:37:32 <tomberek> as an infix
16:37:48 <hpc> :t (.).(.)
16:37:49 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:38:03 <hpc> hah!
16:38:12 <fxr> http://gist.github.com/423182 , could you please tell me what is a low severe, high mild in this criterion output?
16:39:43 <kmc> (f ~> g) h x = g (h (f x)) ?
16:39:57 <Cale> fxr: I'm not sure of the technical *ahem* criterion for each of those categories, but I believe it's just classifying the outliers based on whether they were lower or higher than average, and by how far off they were.
16:40:32 <kmc> (f1 ~> f2 ~> g) h x y = g (h (f1 x) (f2 y))
16:40:34 <kmc> is this correct?
16:41:00 <conal> kmc: yeah
16:41:01 <Cale> The first equation is, let me think about the second a moment ;)
16:41:09 <Cale> ah, yeah
16:41:10 <kmc> cool
16:41:13 <kmc> that is useful indeed
16:41:30 <conal> kmc: meaning to "edit" h such that f1 & f2 get applied to the arguments and g to the result.
16:41:37 <kmc> yeah
16:41:51 <hpc> i like it
16:42:04 <conal> :)
16:42:15 <Cale> It's categorically justified too :)
16:43:09 <Cale> You'll see it often written as Hom(f,g).
16:43:28 <fxr> Cale: thanks
16:44:24 <Cale> fxr: Basically, I think it does that so that it can warn you if there seems to be a lot of outliers (because maybe your machine started or stopped doing something else while the tests were happening)
16:44:35 <aristid> @src (~>)
16:44:35 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:44:56 <Cale> The "variance is unaffected by outliers" statement there indicates that it doesn't think the outliers are a problem.
16:45:54 <conal> aristid: (~>) :: (a' -> a) -> (b -> b') -> ((a -> b) -> (a' -> b'))
16:46:10 <conal> aristid: and more generally with "deep arrows" (see DeepArrow package & TFP paper)
16:46:19 <aristid> conal: what's the intuition behind ~>?
16:47:00 <conal> aristid: it adds some pre- and post-processing to function (for instance)
16:47:59 <conal> f ~> g == argument f . result g == result g . argument f
16:48:38 <tomberek> conal: so   h (f x) (g x) -> ?    h $.  f ~> g   ?
16:48:43 <conal> aristid: in addition to argument & result, you can throw in first & second. 
16:49:10 <aristid> conal: so (f ~> g) is like (.) with pre-processing f and post-processing g?
16:49:24 <conal> aristid: yeah
16:49:29 <aristid> or ($)?
16:49:41 <aristid> i think it would be ($)
16:49:43 <conal> (f ~> g) h = g . h . f
16:49:59 <xezz> hiho
16:50:10 <conal> tomberek: i doubt it.  check the types
16:50:17 <xezz> is there a nice way to negate a bool?
16:50:43 <aristid> conal: if you can write it so easily with two dots, the use-case must be somewhat hidden from my mind
16:51:14 <fxr> Cale: yeah thanks. the low severe, high mild should be the classification of the  distance from rest of the data I guess.
16:51:14 <conal> aristid: check out the TFP paper and the SEC post, and you'll see the composability.
16:51:48 <hpc> it gives the pattern a name, which has exactly the same benefits as the ($) function does
16:52:06 <aristid> conal: i still have the agda tutorial (damn that one could use PAGE NUMBERS) and an iteratee tutorial on my stack
16:52:10 <aristid> -stack+queue
16:53:03 <aristid> conal: anyway, do you have links?
16:53:16 <conal> @where SEC
16:53:16 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
16:53:17 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
16:53:21 <conal> @where Eros
16:53:22 <lambdabot> http://conal.net/papers/Eros
16:53:30 <conal> aristid: ^^
16:53:42 <mauke> @msg #haskell preflex messages
16:53:42 <lambdabot> Not enough privileges
16:53:48 <aristid> blog is good for me
16:54:27 <conal> aristid: the TFP (Eros) paper give the story more generally, showing how the generalization enables dynamic composition of values and GUIs for them (and code & types)
16:54:34 <gwern> @msg #haskell preflex messages
16:54:34 <lambdabot> preflex messages
16:54:35 <preflex>  kmc said 1 day, 3 hours, 4 minutes and 24 seconds ago: @remember alexyk like a centipede, when I start typing, I stop and search inside me for a monad waiting to happen.  Is it ripe enough?  I never know!
16:54:47 <kmc> @remember alexyk like a centipede, when I start typing, I stop and search inside me for a monad waiting to happen.  Is it ripe enough?  I never know!
16:54:47 <lambdabot> It is forever etched in my memory.
16:55:09 <lambdabot> mauke: this power is a power great for good or evil!
16:55:13 <kmc> @quote centipede
16:55:13 <lambdabot> alexyk says: like a centipede, when I start typing, I stop and search inside me for a monad waiting to happen.  Is it ripe enough?  I never know!
16:56:13 <lambdabot> gwern: o rly?
16:56:36 <gwern> @flish
16:56:36 <lambdabot> Not enough privileges
16:56:46 <gwern> oh noes, I suck at wheel war
16:56:56 <lambdabot> tee hee
16:57:07 <mauke> @flish
16:57:30 <mauke> @admin + gwern
16:58:15 <aristid> @src (->) arr
16:58:15 <lambdabot> arr f = f
16:59:04 <aristid> @src ***
16:59:04 <lambdabot> f *** g = first f >>> second g
16:59:24 <mauke> it's a bit sad how ownable lambdabot is
17:00:11 <tomberek> @src <$>
17:00:11 <lambdabot> f <$> a = fmap f a
17:00:11 <monochrom> lovely pet. "own one today!"
17:00:35 <aristid> :t ((.).)
17:00:35 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
17:00:46 <gwern> mauke: it can't be too bad or it would've wreaked destruction by now
17:00:58 <gwern> mauke: admins being able to do bad things isn't really a flaw
17:01:02 <aristid> :t ((Prelude..)Prelude..)
17:01:03 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
17:01:08 <mauke> gwern: how about the "anyone can be an admin" part?
17:01:17 * BMeph is both amused and saddened by the lack of perceiving a(n imperative) function's parameter list as a tuple
17:01:20 <gwern> mauke: how's that?
17:01:44 <mauke> gwern: did you see my first @msg attempt, followed by a successful @flush?
17:01:51 <mauke> I gave myself admin privs
17:02:20 <gwern> you weren't already an admin?
17:02:34 <mauke> <mauke> @msg #haskell preflex messages  <lambdabot> Not enough privileges
17:02:38 <JasonFelice> So, what happens if you don't hear from a hackage maintainer to whom you've submitted a patch?
17:02:44 <gwern> good point
17:03:08 <gwern> mauke: so how did you op yourself? surely it's not as simple as '@admin + mauke'
17:03:15 <mauke> JasonFelice: I made my own module and uploaded it to hackage
17:03:34 <benmachine> gwern: would it be wise to tell everyone? :P
17:03:44 <gwern> benmachine: sunlight is the best disinfectant
17:03:48 <Axman6> @admin
17:03:48 <lambdabot> Not enough privileges
17:03:50 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25904#a25904
17:03:52 <Axman6> @admin+ Axman6
17:03:52 <lambdabot> Not enough privileges
17:03:53 <benmachine> gwern: that is medically inaccurate
17:03:54 <Axman6> >_>
17:04:11 <ksf> that's nice. one can actually see how the google servers chunk their tcp packets
17:05:22 <Gracenotes> ksf: cool
17:05:31 <gwern> mauke: do you tell lambdabot to @msg itself @admin + mauke?
17:05:43 <benmachine> gwern: but you need admin to use @msg don't you?
17:05:49 <mauke> gwern: no, @msg is an admin command
17:05:53 <gwern> drat
17:05:57 * gwern continues thinking
17:06:06 <benmachine> besides, I don't know why lambdabot would be a lambdabot admin :P
17:06:24 <hpc> or why lambdabot would process its own commands
17:06:31 <benmachine> mm
17:06:44 <Axman6> ksf: what's going on there?
17:07:17 <gwern> hpc: well, @msg doesn't seem to have a padding leading space, so if it got a message from itself and it is a lambdabot admin...
17:07:35 <ksf> Axman6, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25904#a25905
17:07:42 <benmachine> you don't get messages that you send to channels do you?
17:07:43 <ksf> which uses my splice-enabled iteratee implementation
17:07:48 <mauke> gwern: how does lambdabot decide if a command comes from an admin?
17:07:48 <benmachine> but you do get messages that you sedn to yourself
17:08:20 <benmachine> checkPrivs msg = gets (isJust . M.lookup (Msg.nick msg) . ircPrivilegedUsers)
17:08:23 <hpc> wtf, you do get self-sent commands
17:08:24 <gwern> mauke: I assume it has something to do with the protocol, it does a /who to verify registered nicks, and then does a config look up
17:08:25 <benmachine> that's how
17:08:39 <mauke> it does a /who? since when?
17:08:48 <benmachine> it grabs it from the message itself
17:09:01 <gwern> I vaguely recall not being able to do admin commands when not verified
17:09:04 <benmachine> just the nick though, so if you knew any admins who weren't online at the time...
17:09:25 <mauke> it's a simple nick comparison, and nicks are free
17:09:32 <benmachine> mm
17:09:37 <benmachine> that's not ideal
17:10:05 <benmachine> but then, is it possible to do anything with admin on lb?
17:10:18 <benmachine> you can consume system resources, but you could do that anyway...
17:10:20 <gwern> benmachine: the usual dos crap, on a machine nowhere near you
17:10:22 <gwern> kind of useful
17:10:33 <benmachine> just messaging people?
17:10:40 <gwern> join channels and spam them
17:10:43 <benmachine> everything'd go through two layers of flood protection :P
17:12:26 * benmachine giggles at LB code
17:12:27 <benmachine>                     -- these must be listed first.  Maybe.  Nobody really
17:12:27 <benmachine>                     -- knows, but better to be safe than sorry.
17:12:53 <gwern> lb is a blast from the past
17:12:59 <gwern> a less elegant tool of a bygone era
17:13:04 <dcoutts> hah
17:13:07 <benmachine> does she need retiring
17:13:18 <dcoutts> @vixen do you need to retire?
17:13:18 <lambdabot> i do occassionally, i guess
17:13:32 <benmachine> I didn't mean in a euphemistic way
17:13:34 <aristid> conal: i think the SEC thing actually helps me understand (.) better, so thanks for that
17:13:52 <FunctorSalad> LB?
17:13:59 <Axman6> \bot
17:14:03 <FunctorSalad> aaahh
17:14:03 <aristid> > ((.).(.)) (+1) (+) 0 0
17:14:04 <lambdabot>   1
17:14:04 <gwern> benmachine: if running is life for a program, then I think you do mean the euphemism
17:14:10 <conal> aristid: cool :)
17:14:11 <FunctorSalad> well bot is 19
17:14:16 <FunctorSalad> a bit early
17:14:17 <aavogt> @google lb broth
17:14:18 <lambdabot> http://en.wikipedia.org/wiki/Lysogeny_broth
17:14:18 <lambdabot> Title: Lysogeny broth - Wikipedia, the free encyclopedia
17:14:36 <conal> i suspect the infix-ness of (.) is what interferes with seeing its composability.
17:14:49 <benmachine> gwern: :(
17:14:56 <conal> as contrasted with first & second
17:15:02 <aavogt> you prefer prefix?
17:15:03 <aristid> @hoogle if_
17:15:03 <lambdabot> Foreign.C.Error throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
17:15:03 <lambdabot> Foreign.C.Error throwErrnoPathIf_ :: (a -> Bool) -> String -> FilePath -> IO a -> IO ()
17:15:03 <lambdabot> Foreign.Marshal.Error throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()
17:16:10 <FunctorSalad> @vxen how old are you?
17:16:10 <lambdabot> 19, you?
17:16:13 <FunctorSalad> see.
17:17:12 <JasonFelice> mauke: You uploaded a newer version of someone else's module, or you made a differently-named one?
17:17:17 <aristid> conal: what's also confusing is that you have the dots to compose the whole expression, and the result=(.)
17:18:50 <mauke> JasonFelice: differently named
17:19:00 <conal> aristid: yeah.  one reason i prefer "result".  also, result is much more general.
17:20:24 <gwern> JasonFelice: you can do both, I think
17:20:32 <gwern> or did NMUs get banned?
17:20:48 <gwern> I remember that multiple uploads of the same version were banned because of me, but not whether NMUs were
17:21:05 <aristid> conal: when you look at the type of (.) and the type of first (when forced into the (->) arrow), it's striking how similar they are
17:21:31 <conal> aristid: exactly!
17:21:51 <conal> aristid: which suggests generalizing (.)
17:21:58 <aristid> :t (.)
17:21:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:21:59 <gwern> my god! it's full of stars
17:22:04 <aristid> conal: this way?
17:22:05 <conal> aristid: which leads to DeepArrow's result
17:22:23 <mreh> :t (<<<)
17:22:24 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
17:22:24 <aristid> do i need to read the paper for that?
17:22:51 <conal> aristid: yeah.  i'd intended to do some follow-on blog posts after the SEC ones, but haven't so far.
17:23:30 <mreh> that's a confusing definition of function composition
17:23:40 <conal> aristid: no, not that way.  fmap is the wrong generalization
17:23:49 <Cale> mreh: The generalisation to an arbitrary functor?
17:24:02 <Cale> mreh: Or the Control.Category one?
17:24:17 <mreh> uh... the first one
17:24:22 <mreh> I suppose it makes sense
17:24:27 <mreh> it's fmap
17:24:41 <Cale> Yeah, just take f = (e ->) to recover usual function composition from that
17:24:45 <mreh> maths never ceases to amaze me
17:24:57 <mreh> right
17:25:13 <aristid> hmm fmap = second for the (,) a Functor, it seems
17:25:15 <mreh> but this isn't haskell98
17:25:42 <mreh> damn you haskell98 and your restrictions!
17:25:49 <Cale> mreh: Well, it's not the Prelude (.) from Haskell 98
17:25:59 <Cale> mreh: But you can define this (.) in Haskell 98
17:26:01 <benmachine> haskell98 doesn't have hierarchical modules :P
17:26:13 <benmachine> haskell98 is silly in some regards
17:26:23 <mreh> are we going to be eliminating surplus symbols from haskell'?
17:26:32 <mreh> like <$>
17:26:32 <Cale> surplus?
17:26:37 <Cale> huh?
17:26:39 <mreh> redundant
17:26:46 <benmachine> how is <$> redundant?
17:26:50 <mreh> they are defined in terms of other symbols
17:26:59 <benmachine> (<$>) = fmap
17:27:03 <mauke> :t [(.), fmap, (<$>), liftM, liftA]
17:27:04 <lambdabot> forall a b (f :: * -> *). (Applicative f, Monad f) => [(a -> b) -> f a -> f b]
17:27:10 <mreh> or more general operators
17:27:18 <Cale> <$> works nicely syntactically along with <*>
17:27:24 <benmachine> only lambdabot has (.) = fmap
17:27:31 <benmachine> only lambdabot and other people who like doing that
17:27:34 <mauke> :t [(Prelude..), fmap, (<$>), liftM, liftA]
17:27:35 <lambdabot> forall b c a. [(b -> c) -> (a -> b) -> a -> c]
17:27:48 <benmachine> liftA is completely useless so far as I can tell
17:27:49 <aristid> benmachine: conal seems to prefer another generalization of (.)
17:28:03 <aristid> :t liftA
17:28:04 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
17:28:14 * Axman6 is still waiting for (.) = (Prelude..), (Cale..) = fmap
17:28:19 <benmachine> liftA f x = pure f <*> x
17:28:25 <Cale> liftA is so that you can define a Functor instance in terms of the Applicative instance
17:28:53 <Cale> If you've already written your instance of Applicative, you can go and write  instance Functor Foo where fmap = liftA
17:29:12 <aavogt> @src Applicative
17:29:12 <lambdabot> class Functor f => Applicative f where
17:29:12 <lambdabot>     pure  :: a -> f a
17:29:12 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
17:29:23 <benmachine> Cale: I guess so... but I imagine they both have to be in the same module since Functor is a superclass
17:29:23 <aavogt> Cale: doesn't the  Functor f =>  stop you from doing that?
17:29:27 <Cale> (and that will satisfy the superclass constraint for Applicative)
17:29:35 <benmachine> hmm actually yeah
17:29:43 <benmachine> would that even work
17:29:47 <Cale> Yes
17:29:50 <benmachine> oh ok
17:29:52 <benmachine> cool.
17:29:54 <mreh> trust him
17:30:08 <benmachine> well I was thinking it might lead to something like (Functor f) => Functor f
17:30:20 <mreh> that's madness
17:30:28 <Cale> The superclass constraint just means there has to be an instance. Haskell isn't picky about how you define that instance.
17:30:34 <benmachine> but I guess haskell's clever about that sort of thing
17:30:48 <aristid> @src [] (<*>)
17:30:48 <lambdabot> (<*>) = ap
17:30:55 <aristid> @src ap
17:30:55 <lambdabot> ap = liftM2 id
17:30:59 <Cale> You could even make them mutually recursive if you wanted to
17:31:09 <benmachine> that would be um neat
17:31:27 <mauke> @src liftM2
17:31:27 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:32:36 <benmachine> ho hum
17:32:46 <benmachine> ghc-pkg is going to whine about broken packages at me forever
17:32:56 <benmachine> because I can't fix them without reinstalling GHC and they're packages I never use anyway
17:34:28 <mreh> you can fix it
17:34:44 <conal> aristid: see http://hackage.haskell.org/packages/archive/DeepArrow/0.3.3/doc/html/Control-Arrow-DeepArrow.html#v%3Aresult
17:34:48 <mreh> I fixed mine after I broke it to smitheries
17:35:05 <benmachine> mreh: I've fixed everything except the dph libraries, which aren't hackagable
17:35:06 <conal> aristid: the type i like for result is analogous to first & second
17:35:27 <mreh> benmachine: download the source and reinstall
17:35:34 <conal> aristid: which then can be freely composed with first & second on arbitrary "deep arrows"
17:35:35 <mreh> cabal install --reinstall in the src di
17:35:37 <mreh> r
17:35:44 <benmachine> mreh: can you even do that with dph?
17:35:54 <benmachine> also, from where
17:36:11 <mreh> benmachine, what's a dph?
17:36:21 <benmachine> the data parallel haskell libraries
17:36:50 <mreh> oh
17:37:13 <benmachine> they're probably quite friendly with GHC so I'm disinclined to faff with them
17:37:21 <Cale> benmachine: You can't just unregister them?
17:37:31 <benmachine> Cale: I suppose I could
17:37:36 <benmachine> given that I never use them
17:37:39 <benmachine> and nothing else does either
17:37:53 <benmachine> can I get them back afterwards?
17:37:53 <aristid> conal: so what would be a use case for that?
17:37:55 <benmachine> uh
17:37:59 <benmachine> I guess not since they're broken
17:38:00 <conal> aristid: the problem with fmap in the context of SECs is that 'fmap f' requires f to be a function and results in a function.
17:38:07 <Cale> benmachine: You can install ghc again
17:38:13 <conal> aristid: tangible functional programming
17:38:19 <Cale> Which you'll probably eventually do anyway :)
17:38:23 <benmachine> heh, right
17:38:26 * benmachine kills them
17:38:27 <aristid> conal: no i mean just something concrete to help me understand
17:39:05 <benmachine> woo, no more whining
17:39:12 * benmachine wonders when 6.12.3 is coming
17:39:23 <Cale> benmachine: and then OH NO EVERYTHING ELSE SEKRITLY DEPENDEDED ON THEM!!!!111one
17:39:33 <conal> aristid: the paper shows how deep arrows form the basis of interactively synthesizing values, GUIs, types, and code.
17:39:43 <benmachine> Cale: DDDD:
17:39:57 <conal> aristid: only the first of those four comes from the function arrow.  the others require the more general notion of 'result'
17:40:35 <aristid> conal: so where is that paper again?
17:40:36 <conal> aristid: there's also a video if you prefer.  less technical/dense than the paper.
17:40:43 <conal> @where Eros
17:40:44 <lambdabot> http://conal.net/papers/Eros
17:41:23 <conal> aristid: icfp paper & slides + google tech talk video
17:41:28 <monochrom> dependededededekind?
17:41:40 <monochrom> tartartartartarglia
17:41:49 <aristid> conal: i found the tech talk
17:41:55 <aristid> conal: i shall see which works better for me
17:42:07 <conal> aristid: cool.  you'll get my motivation there.
17:44:46 <aristid> conal: hah the user-friendly vs programmer-friendly part reminds me of the command line versus GUI thing
17:45:28 <FunctorSalad> cli can be better for the user too
17:45:44 <aristid> yeah that's why i use it as a user
17:46:37 <g06|in> why does [1,3..8.0] == [1.0,3.0,5.0,7.0,9.0] ?
17:46:54 * benmachine has a moment where the time he spends trying to automate a task eventually exceeds the time the task would have taken
17:47:50 <Axman6> > [1.0,3.0..8.0]
17:47:50 <lambdabot>   [1.0,3.0,5.0,7.0,9.0]
17:47:55 <Axman6> o.O
17:48:04 <Axman6> @src enumFromThenTo
17:48:04 <lambdabot> Source not found. Do you think like you type?
17:48:12 <Axman6> mostly
17:48:30 <Cale> g06|in: I consider that a bug in the standard.
17:48:37 <jbapple> > [1,3..8]
17:48:38 <lambdabot>   [1,3,5,7]
17:49:51 <jb55> > [1,3..8.0] == [1,3..8]
17:49:51 <lambdabot>   True
17:50:01 <Cale> > 8 + (3-1)/2 :: Double
17:50:02 <lambdabot>   9.0
17:50:24 <Axman6> > [1.0,3.0..8.5]
17:50:25 <lambdabot>   [1.0,3.0,5.0,7.0,9.0]
17:50:32 <Axman6> > [1.0,3.0..7.5]
17:50:33 <lambdabot>   [1.0,3.0,5.0,7.0]
17:50:39 <Axman6> > [1.0,3.0..7.51]
17:50:40 <lambdabot>   [1.0,3.0,5.0,7.0]
17:50:46 <Axman6> > [1.0,3.0..7.99]
17:50:47 <lambdabot>   [1.0,3.0,5.0,7.0]
17:51:17 <g06|in> floating-point roundoffs
17:51:19 <g06|in> hmmm
17:51:20 <g06|in> thanks
17:51:20 <Cale> [n,n'..m] does  takeWhile (<= m + (n' - n)/2)  (when n' >= n)
17:52:43 <xezz> is there a sqrt funktion for integers?
17:52:46 <Cale> Personally, I think that [n, n' .. m] should never contain any element greater than m
17:53:01 <Axman6> me either
17:53:08 <Axman6> xezz: not by default
17:53:16 <Cale> xezz: No, but you could use something like  floor . sqrt . fromIntegral
17:53:32 <Axman6> you can define one, but i don't think it exists because it doesn't make all that much sense a lot of the time
17:53:46 <Cale> (though that will go via double precision floating point by default)
17:53:53 <benmachine> I wrote a implementation of the babylonian square root algorithm that worked on integers
17:54:13 <benmachine> it turned out to be much much slower than the double way :P
17:54:17 <benmachine> although hmm did I optimise
17:54:35 <xezz> @src fromIntegral
17:54:35 <lambdabot> fromIntegral = fromInteger . toInteger
17:54:58 <Cale> :t fromIntegral
17:54:58 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:55:04 <Cale> ^^ the more important thing :)
17:55:14 <qz> is feature matrix from http://www.haskell.org/haskellwiki/Regular_expressions true? strange that RW Haskell book advices to use posix library =p
17:55:17 <Cale> It converts from any integer-like type to any numeric type at all
17:55:37 <Olathe> Are there any nonletters that type names can start with ?
17:55:47 <Cale> :
17:55:58 <benmachine> don't you need TypeOperators for that?
17:56:12 <Cale> : is the only "uppercase" symbol character
17:56:13 <xezz> mh nice works :P
17:56:28 <Cale> you can use any of the other symbol characters to start off an infix type variable though
17:58:05 <Cale> qz: Seems about right to me, except that I have no idea about the speed column. I would expect that the DFA-based libraries would be much faster in general than the Perlish ones.
17:58:18 <tomberek> where does $. live?  i'm trying to start using the ~> stuff
17:58:25 <Olathe> Hmm, I'm trying it, but I can't make a type called :1.
17:58:55 <Cale> Olathe: If it starts with :, then it has to be made entirely of symbol characters, and it has to be written infix
17:59:06 <aavogt> > undefined :: 1
17:59:07 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
17:59:07 <lambdabot>    arising from a use of ...
17:59:19 <Olathe> Cale: Ahh, OK. Thanks :)
17:59:54 <xezz> thx 4 ya help and gn8 :P
18:00:33 <tomberek> @src $.
18:00:34 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:01:09 <aristid> @hoogle $.
18:01:09 <lambdabot> No results found
18:02:12 <aavogt> why must it be so awkward to combine cases that need mutually exclusive typeclass constraints in a single function?
18:14:16 * byorgey makes a lambda-sausage pizza with carmelized onions and rosemary
18:14:39 * BMeph makes a lambda-sausage pizza with carmelized onions and rosemary's baby!
18:34:51 <tomberek> is there any typeclass for the notion of a product of values? (,) and data Prod a b = Prod a b would be trivial cases?
18:35:19 <monochrom> No.
18:36:12 <tomberek> monochrom: is there any reason? or are they identical so there would be no reason to use one over the other?
18:36:43 <monochrom> I suppose so.
18:37:48 <monochrom> But I don't believe in "reason" for why some code is written and some other code is not. I only believe in demand-supply for this; and even then, demand-supply from only the vocal minority.
18:39:56 <monochrom> Prelude has fst and snd because someone bitched hard enough and/or someone had too much free time. Prelude does not have similar things for 4-tuples because no one bitched hard enough and no one was bored enough. There is no "logical reason".
18:39:59 <aristid> why do many papers have no page numbers? :(
18:40:09 <danharaj> latexfail
18:40:25 <monochrom> because they leave page numbers to the publisher.
18:40:33 <aristid> monochrom: good one.
18:40:51 <Olathe> We need typeclasses that implement (!!) and (++) for tuples !
18:41:19 <monochrom> clearly, many papers you download from authors are authors' pre-print draft files rather than publishers' final copy.
18:41:20 <aristid> Olathe: you mean like in HList?
18:42:46 <Olathe> Ahh, maybe :)
18:43:13 <monochrom> Maybe HList
18:44:30 <Olathe> How useful would type-level Word8s be ?
18:44:51 <systemfault> Well.. they're bytes
18:44:59 <Olathe> Sure.
18:45:38 <aristid> type-level Word8s? *scratches head*
18:45:41 <Olathe> I think it would be nice if you wanted types that didn't look like S (S (S N)).
18:45:53 <aristid> Olathe: i wouldn't want Word8 for that
18:45:56 <Olathe> You could have T35 or something.
18:46:01 <Olathe> What would you want for it ?
18:46:18 <aristid> well something with more than 256 values
18:46:24 <Olathe> Ahh.
18:46:49 <aristid> Olathe: DT and restricted versions of it are of course a very interesting thing
18:46:59 <Olathe> What's DT ?
18:47:06 <danharaj> dependent types
18:47:06 <aristid> dependent types
18:47:31 <aristid> when functions can take types as parameters (and return types), and where types can take values as parameters
18:48:05 <danharaj> I thought type operators were a separate dimension.
18:48:52 <aristid> danharaj: type operators? aren't data/newtype constructors only special functions anyways?
18:49:16 <danharaj> functions that take types and return types: type constructors
18:49:20 <aristid> oh sorry talking bullshit
18:49:49 <aristid> danharaj: well functions that return types is implied by DT, i think
18:50:10 <aristid> kmc probably knows more about it than i do
18:50:32 <danharaj> functions that take value arguments and return types are DT, but that is orthogonal from taking types and returning types, although I doubt you ever see DT without type constructors.
18:52:50 <dolio> Actually, the logical framework is that way.
18:53:26 <dolio> It's first-order.
18:55:24 <dolio> You have *, the kind of types. And then you define a universe U : * of codes of types, along with T : U -> * taking codes to their types.
18:55:50 <dolio> The types they represent, even.
18:56:31 <dolio> Then you could have higher-order codes U -> U and such. But those are values.
18:57:50 <aristid> dolio: it's hard to understand what you say:)
18:57:56 <aristid> for me at least.
18:58:55 <dolio> Int : U is a code. T Int is the type of elements of Int.
18:59:15 <dolio> List : U -> U, List Int : U, T (List Int) : *
19:03:31 <zoheb> Is there any curried fn corresponding to the if then else keywords
19:03:51 <dolio> No.
19:04:05 <zoheb> @pl (\x y z -> if x then y else z)
19:04:05 <lambdabot> if'
19:04:22 <zoheb> :t if`
19:04:23 <lambdabot> parse error on input ``'
19:04:26 <zoheb> :t if '
19:04:27 <lambdabot>     lexical error in string/character literal at end of input
19:04:32 <zoheb> :t iff'
19:04:33 <lambdabot> Not in scope: `iff''
19:04:35 <dolio> if' isn't actually defined anywhere.
19:04:48 <mauke> and you fail at copy/paste
19:04:52 <zoheb> where did lambdabot get it from?
19:05:06 <zoheb> :t if'
19:05:06 <lambdabot> Not in scope: `if''
19:05:07 <dolio> It didn't get it from anywhere.
19:05:17 <dolio> It's just one of the things @pl produces in its output.
19:05:22 <zoheb> ok
19:05:34 <dolio> Since otherwise it couldn't @pl things with if-then-else in them.
19:05:53 <zoheb> ok, sounds good
19:09:39 <aristid> dolio: something like if' should exist.
19:09:49 <aavogt> hmm, is there a way to quickcheck typeclasses?
19:09:58 <aavogt> as in, see if they do the right thing for various types?
19:10:43 <aavogt> @where irulan
19:10:43 <lambdabot> I know nothing about irulan.
19:10:57 <jbapple> :t maybe
19:10:58 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:11:03 <Olathe> > fromEnum True
19:11:04 <lambdabot>   1
19:11:05 <aavogt> @where+ irulan http://www.doc.ic.ac.uk/~tora/irulan/
19:11:06 <lambdabot> Nice!
19:11:20 <jbapple> in keeping with maybe, if' should be called "bool"
19:11:40 <jbapple> well, I guess the arguments would be backwards
19:11:46 <aavogt> foldr foldl should be called listl listr
19:11:51 <jbapple> :-)
19:11:53 <Olathe> > let if' c t f = [f, t] !! fromEnum c in if' True 1 2
19:11:53 <lambdabot>   1
19:11:59 <Olathe> > let if' c t f = [f, t] !! fromEnum c in if' False 1 2
19:11:59 <lambdabot>   2
19:12:21 <jberryman> it seems like the only function on the MArray class that really uses mutability is writeArray
19:12:25 <jberryman> is that true?
19:12:27 <aavogt> @pl \b x y -> [y,x] !! fromEnum b
19:12:27 <lambdabot> flip (flip . ((!!) .) . flip (:) . return) . fromEnum
19:12:42 <aavogt> dolio: it could do that expansion :P
19:12:50 <deech> Hi all, I am trying to make a counter web app using continuations. The function that actually adds has type (Int -> Cont () Int), by the continuation is stored as (Cont () (IO String)). I have the function that converts (Int -> Cont () Int) to (Cont () (IO String)), but I'm having trouble reversing it.
19:13:10 <Olathe> @instances Bool
19:13:11 <lambdabot> Couldn't find class `Bool'. Try @instances-importing
19:13:12 <dolio> Then it would have to know about fromEnum and (!!).
19:13:16 <Olathe> @instances-importing Bool
19:13:17 <lambdabot> Couldn't find class `Bool'. Try @instances-importing
19:13:19 <deech> Any help is appreciated.
19:14:15 <aristid> aavogt: foldr foldl should be replaced by Foldable.foldr/foldl :)
19:14:17 <aavogt> deech: why should that function have an inverse?
19:14:26 <aavogt> aristid: that too
19:14:54 <dolio> That's also seriously convoluted for if'.
19:15:23 <deech> aavogt: so that I can take it back out of storage and add number.
19:15:35 <Olathe> @pl \b x y -> [x,y] !! fromEnum (2-b)
19:15:35 <lambdabot> flip (flip . ((!!) .) . (. return) . (:)) . fromEnum . (-) 2
19:15:48 <jberryman> deech: people seem to get good help on stackoverflow under the haskell tag if you wanted to outline your problem more fully
19:15:57 <aristid> :t guard
19:15:57 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
19:16:05 <deech> I have some code here: http://pastebin.com/X7Y7c3vZ
19:16:17 <aristid> :t maybe
19:16:17 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:16:27 <Olathe> \x y b -> [x, y] !! fromEnum b
19:16:32 <Olathe> @pl \x y b -> [x, y] !! fromEnum b
19:16:32 <lambdabot> flip flip fromEnum . (((.) . (!!)) .) . (. return) . (:)
19:16:46 <Olathe> @unpl flip flip
19:16:46 <lambdabot> (\ b c f -> c f b)
19:16:56 <aavogt> deech: what's the difference between   Cont () x  and x?
19:17:02 <aavogt> @unmtl Cont () x
19:17:02 <lambdabot> (x -> ()) -> ()
19:17:28 <Olathe> @pl \x y b -> [y, x] !! fromEnum b
19:17:28 <lambdabot> flip flip fromEnum . (((.) . (!!)) .) . flip (:) . return
19:17:38 <aavogt> oh, the parameter order is that way for Monad purposes
19:17:43 <aristid> > let if' x y z = maybe z (const y) (guard x) in if' True 1 2
19:17:44 <lambdabot>   1
19:17:50 <aristid> > let if' x y z = maybe z (const y) (guard x) in if' False 1 2
19:17:51 <lambdabot>   2
19:17:58 <dolio> Cont () x is (roughly) isomorphic to ().
19:18:00 <aristid> @pl if' x y z = maybe z (const y) (guard x)
19:18:00 <lambdabot> if' = flip (flip . flip maybe . const) . guard
19:18:14 <aristid> i think my if' is more elegant than the one with fromEnum :)
19:18:34 <deech> aavogt: Cont () Int is a function that has integer intermediate values and no output.
19:19:03 <aavogt> so how do you know the function does anything?
19:19:08 <dolio> @type \b x y -> fromMaybe y (guard b >> return x)
19:19:09 <lambdabot> forall a. Bool -> a -> a -> a
19:20:06 <aristid> :t fromMaybe
19:20:07 <lambdabot> forall a. a -> Maybe a -> a
19:20:24 <aristid> @pl \b x y -> fromMaybe y (guard b >> return x)
19:20:24 <lambdabot> (flip fromMaybe .) . (. return) . (>>) . guard
19:20:52 <deech> aavogt: I was trying to implement this control flow: a user hits a "+" button, the server adds another counter_add in the chain, and returns the result.
19:24:28 <aavogt> deech: shouldn't you use   Cont (IO ()) a  instead?
19:25:26 <aavogt> or more likely  ContT () IO a?
19:25:38 <deech> aavogt: yes that makes more sense
19:26:26 <deech> So I should store something like ContT () IO Int and convert that to ContT () IO String?
19:31:16 <meanburrito920> I'm looking for a version of foldl that starts with the tailmost element without having the overhead of navigating the entire list using 'tail'. any ideas of where to look?
19:31:57 <gwern> meanburrito920: you can't go to the end of a singly-linked list without traversing the list
19:32:04 <djahandarie> If you want to start from the right of the list you need to traverse the whole thing
19:32:07 <djahandarie> Oops
19:32:11 <djahandarie> Too slow
19:32:15 <EvanR> reverse the list first or use a Data.Sequence
19:32:26 <gwern> what EvanR said
19:32:28 <djahandarie> Yeah
19:32:35 <meanburrito920> ah, cool. thanks
19:46:44 <Nereid> cool
19:46:44 <Nereid> http://www.haskell.org/yale/papers/haskell-workshop03/index.html
19:46:55 <Nereid> exactly what I need to write a game. :o
19:50:41 <ezracooper> .
19:50:49 <EvanR> where can i read about monadic parser combinators
19:51:12 <jmcarthur> real world haskell has a chapter on parsec, doesn't it?
19:51:20 <aavogt> something like that
19:51:41 <aavogt> so functions with variable numbers of arguments aren't very composable are they?
19:51:50 <jmcarthur> eep
19:52:05 <djahandarie> Huhh?
19:52:09 <aavogt> as in, it doesn't seem possible to define:   f . hBuild
19:52:23 <aavogt> I suppose hBuild should have taken a continuation
19:53:16 <aavogt> I can say, use    f $ hBuild 1 2 3 4
19:53:44 <EvanR> this explains how to use parsec, and i figured that out already from the parsec docs. now, how do i make my own parser using 'raw materials' ;)
19:53:53 <EvanR> whats the trick
19:53:55 <EvanR> need more info
19:54:10 <aavogt> but it isn't apparent how to reuse the definition of HBuild
19:58:41 <alexyk> ok, anybody on gentoo?  #gentoo-haskell is deadified
19:59:54 <dcoutts> alexyk: it's not dead, it's just the middle of the night :-)
20:00:03 <tomberek> where?
20:00:12 <alexyk> dcoutts: hey, you keep mum there! :)
20:00:15 <EvanR> in the only place that matters, america
20:00:36 <tomberek> EvanR: there are other places? i meant where in america.... hehe
20:00:41 <alexyk> why haskell beat ocaml?  cause is microsoft haskell!  good ol' usa rocks again!
20:00:46 <EvanR> oh, right
20:01:07 <tomberek> alexyk, zawhatnow?
20:01:33 <alexyk> tomberek: we have ghc thanks to MSFT funding, don't we?
20:01:49 <tomberek> didn't know that.. cool
20:02:01 <EvanR> microsoft research
20:02:19 <EvanR> does not equal microsoft ;)
20:02:22 <tomberek> hey, $ is $  (er.. unless.. well, you know)
20:03:01 <shahbaz> i'm trying to get cabal to install bluetile+xmonad+gtk2hs, etc. on ubuntu, but keep getting errors, is this channel ok to ask such questions?
20:03:11 <alexyk> EvanR: well, c'mon now, you can't take the money and disrespect the simple folk toiling in the Redmond woodwork!
20:03:27 <EvanR> no one paid me a dime to use haskell
20:03:38 <EvanR> oh wait
20:03:43 <alexyk> money has logic -- all the blood and sweat of the ASP.NET developers hailing from the remote corners of the world went there
20:03:51 <EvanR> the projects at work are in haskell ;)
20:03:58 <EvanR> but i dont work for microsoft
20:04:03 <alexyk> all their dreams of breaking free and logical and beautiful
20:04:11 <Nereid> hmm
20:04:13 <Nereid> someone remind me
20:04:27 <alexyk> EvanR: true, but w/o funding core founders usually there's no language
20:04:51 <EvanR> haskell was largely a ripoff of miranda
20:05:00 <alexyk> cf. Scala -- EPFL, Clojure -- rhickey supported by donations, Linus by the open source cabal, etc.
20:05:02 <Nereid> what's the difference between, say, data X = X !Int, and newtype X = X Int?
20:05:33 <dcoutts> Nereid: it's subtle, they're almost the same
20:05:42 <Nereid> I'm sure it's subtle
20:05:45 <dcoutts> Nereid: it's to do with strictness in pattern matching
20:05:50 <Nereid> hmm
20:06:11 <dcoutts> Nereid: pattern matching a newtype never forces the thing inside
20:06:24 <dcoutts> Nereid: pattern matching a constructor with a strict field force the thing in that field
20:06:32 <Nereid> hmm
20:06:47 <Nereid> alright
20:07:01 <Nereid> I think I understand.
20:11:10 <aavogt> EvanR: I don't think miranda has type classes
20:11:31 <EvanR> or monads, monadic io
20:11:41 <EvanR> which sort of falls under classes
20:12:03 <aavogt> you don't need typeclasses for Monad
20:12:29 <aavogt> though that sort of defeats the purpose of collecting many useful functions in Control.Monad
20:12:54 <aavogt> since they would all need an additional argument containing the methods of the Monad class
20:13:16 <saml> is there built in binary tree? or should I roll out my own ?
20:13:31 <EvanR> Data.Map
20:13:32 <aavogt> @src Map
20:13:32 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:13:39 <aavogt> @src Data.Map.Map
20:13:39 <lambdabot> Source not found. Are you on drugs?
20:13:45 <EvanR> lol
20:13:49 <saml> Map is Tree?
20:13:57 <aavogt> data Map k a
20:13:58 <aavogt>   = Data.Map.Tip
20:14:00 <aavogt>   | Data.Map.Bin !Data.Map.Size !k a !(Map k a) !(Map k a)
20:14:23 <aavogt> it's implementation is hidden however
20:14:47 <saml> i'll just do data Tree a = Node a | Branch (Tree a) (Tree a)
20:15:16 <aavogt> there is a Data.Tree, but doesn't require 2 or 0 children at each node
20:15:17 <EvanR> just do a import Data.Map
21:01:00 <heropass> @wn vikalpa
21:01:00 <lambdabot> No match for "vikalpa".
21:01:12 <heropass> @wn discrimination
21:01:13 <lambdabot> *** "discrimination" wn "WordNet (r) 2.0"
21:01:13 <lambdabot> discrimination
21:01:13 <lambdabot>      n 1: unfair treatment of a person or group on the basis of
21:01:13 <lambdabot>           prejudice [syn: {favoritism}, {favouritism}]
21:01:13 <lambdabot>      2: the cognitive process whereby two or more stimuli are
21:01:15 <lambdabot>         distinguished [syn: {secernment}]
21:02:45 <heropass> @wn monad
21:02:45 <lambdabot> *** "monad" wn "WordNet (r) 2.0"
21:02:45 <lambdabot> monad
21:02:45 <lambdabot>      n 1: an atom having a valence of one
21:02:45 <lambdabot>      2: a singular metaphysical entity from which material
21:02:45 <lambdabot>         properties are said to derive [syn: {monas}]
21:02:47 <lambdabot>      [also: {monades} (pl)]
21:07:13 <totalamateur> I'm looking for someone that knows how to use macros. anyone?
21:07:44 <totalamateur> there is $ involved
21:11:09 <lispy|web> totalamateur: ($) is an operator (a normal function) in haskell.  Or do you mean template haskell?
21:11:45 <aavogt> too late
21:15:39 <JoeyA> @hoogle (c -> d) -> (a -> b -> c) -> a -> b -> d
21:15:39 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
21:15:39 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
21:15:39 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
21:16:16 <JoeyA> Is there a function/operator similar to compose that takes a 2-argument rvalue instead of one argument?
21:16:50 <JoeyA> > zipWith (negate . (+)) [1,2,3] [4,5,6]
21:16:51 <lambdabot>   [-5,-7,-9]
21:17:20 <FunctorSalad> hehe
21:17:20 <JoeyA> Like that, but lambdabot uses a special (.) here
21:17:27 <JoeyA> I tried importing Control.Applicative
21:17:31 <FunctorSalad> I think it's the Num instance for functions
21:17:32 <pumpkin> @typo ((.) . (.)) :: (c -> d) -> (a -> b -> c) -> a -> b -> d
21:17:33 <aavogt> @type (.) (.)
21:17:33 <lambdabot> forall c d a b. (c -> d) -> (a -> b -> c) -> a -> b -> d
21:17:34 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
21:17:47 <FunctorSalad> Caleskell made your example fail and failing
21:17:50 <FunctorSalad> :)
21:17:51 <c_wraith> @type on
21:17:52 <FunctorSalad> *at
21:17:52 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:17:53 <lispy|web> > zipWith (negate Preude.. (+)) [1,2,3] [4,5,6]
21:17:54 <lambdabot>   Not in scope: `Preude..'
21:18:09 <aavogt> oh no, pumpkin is more right
21:18:34 <FunctorSalad> > zipWith ((negate .) . (+)) [1,2,3] [4,5,6]
21:18:35 <lambdabot>   [-5,-7,-9]
21:19:03 <FunctorSalad> you don't really need to spell the (.) . (.) out...
21:19:10 <FunctorSalad> at that point I'd rather define something :o
21:19:18 <FunctorSalad> too obscurantous
21:20:03 <JoeyA> Does ((.) . (.)) work by composing compositions?
21:20:08 <lispy|web> > zipWith (negate Prelude.. (+)) [1,2,3] [4,5,6]
21:20:09 <lambdabot>   Not in scope: `Prelude..'
21:20:21 <lispy|web> hmm
21:20:29 <lispy|web> > Prelude.head [1..3]
21:20:30 <lambdabot>   1
21:20:44 <lispy|web> So, what is the correct name of (.) from the prelude?
21:20:47 <FunctorSalad> > negate (\() -> 1) ()
21:20:48 <lambdabot>   -1
21:20:59 <FunctorSalad> it's *this* what caused the fail at failing
21:21:05 <pumpkin> JoeyA: it's actually easier to think of as fmap . fmap
21:21:14 <pumpkin> JoeyA: I think, at least
21:21:30 <JoeyA> > zipWith (negate ((<$>).(<$>)) (+)) [1,2,3] [4,5,6]
21:21:31 <lambdabot>   No instances for (GHC.Num.Num (f (a -> a)), GHC.Num.Num (f a))
21:21:31 <lambdabot>    arising f...
21:21:40 <FunctorSalad> > (\() -> 1) + (\() -> 2)
21:21:40 <lambdabot>   Overlapping instances for GHC.Show.Show (() -> t)
21:21:40 <lambdabot>    arising from a use of ...
21:21:50 <JoeyA> oops
21:21:50 <FunctorSalad> > (\() -> 1::Int) + (\() -> 2)
21:21:51 <lambdabot>   *Exception: show: No overloading for function
21:22:08 <FunctorSalad> > ((\() -> 1) + (\() -> 2)) ()
21:22:08 <JoeyA> > zipWith (((<$>).(<$>)) negate (+)) [1,2,3] [4,5,6]
21:22:09 <lambdabot>   3
21:22:09 <lambdabot>   [-5,-7,-9]
21:22:50 <JoeyA> > zipWith (((.).(.)) negate (+)) [1,2,3] [4,5,6] -- works in GHCi and Hugs with only Prelude
21:22:51 <lambdabot>   [-5,-7,-9]
21:24:48 <JoeyA> :t ((.) . (.))
21:24:49 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:25:34 <lispy|web> so is Prelude not imported in the mueval stuff?
21:25:47 <lispy|web> The @type thingy can see Prelude.. but not >
21:25:57 <lispy|web> And this makes me angry!
21:26:02 <lispy|web> (okay not really)
21:26:23 <lispy|web> :t ((Prelude..) Prelude.. (Prelude..))
21:26:24 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
21:27:05 <BMeph> lispy|web: Don't think about kittens with spikes on them...that might get you Really Angry! =8*O
21:27:17 <portnov> :t ((.) . (.))
21:27:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:27:47 <lispy|web> BMeph: nah, those kittens totally deserved it.
21:28:14 <Axman6> BMeph: on or in?
21:29:51 <portnov> :t (.)
21:29:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:31:16 <FunctorSalad> BMeph: what?
21:31:49 <JoeyA> @let (.<) :: (c -> d) -> (a -> b -> c) -> (a -> b -> d) ; a .< b = (\c d -> a $ b c d)
21:31:51 <lambdabot>  Defined.
21:31:58 <FunctorSalad> Axman6: I understood it as armored kittens with additional outwards spikes
21:32:14 <JoeyA> > zipWith (negate .< (+)) [1,2,3] [4,5,6]
21:32:15 <lambdabot>   [-5,-7,-9]
21:32:17 <JoeyA> :)
21:34:24 <pjb3> I'm trying to work my way through this article:
21:34:25 <pjb3> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
21:34:38 <pjb3> and in the explain of the solution to exercise one
21:34:45 <pjb3> the author says
21:34:59 <pjb3> Write this composition as f'*g'.
21:35:13 <pjb3> and later
21:35:14 <pjb3> So we're looking for a debuggable function, call it unit, such that unit * f = f * unit = f
21:35:27 <soupdragon> unit would be 1 then
21:35:53 <pjb3> I'm totally confused as to what * is supposed to mean in this context
21:36:00 <soupdragon> multiplication
21:36:07 <aavogt> * probably isn't multiplication?
21:36:11 <BMeph> Composition!
21:36:28 <pjb3> you can multiply a function by a function?
21:36:51 <tomberek> pjb3: no, it's feed the result of one into the next
21:37:03 <pumpkin> if it's monads, your unit is probably return
21:37:17 <pumpkin> and * isn't regular function composition
21:37:18 <pjb3> Is f' * g' different that f' . g' ?
21:37:19 <aavogt> it's not commutative usually
21:37:26 <lispy|web> pjb3: concepts like, 'multiplication' tend to mean different things in different contexts.  Here it means function composition
21:37:27 * BMeph consults the Text...
21:37:54 <pjb3> Given a pair of debuggable functions, f' and g', we can now compose them together to make a new debuggable function bind f' . g'. Write this composition as f'*g'.
21:38:22 <pjb3> so * must mean something in the context of a monad I guess
21:38:22 <soupdragon> f'*g' = bind f' . g'
21:38:31 <pumpkin> :t (<=<)
21:38:32 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
21:38:32 <pjb3> soupdragon: right, ok
21:38:46 <pumpkin> :t return
21:38:47 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
21:38:48 <pjb3> so f' * g' mean bind f' then compose with g'
21:38:50 <aavogt> that fish looks about right
21:39:27 <aavogt>  f' * g' = \x -> f' =<< (g' x)  -- here
21:39:43 <pumpkin> @typo (return <=<)
21:39:44 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> a -> m b
21:39:50 <pumpkin> @typo (<=< return)
21:39:51 <lambdabot> forall (m :: * -> *) c a. (Monad m) => (a -> m c) -> a -> m c
21:40:14 <aavogt> > [id, (return <=<), (<=< return)]
21:40:14 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> m b) -> a -> m b)
21:40:14 <lambdabot>    arising...
21:40:19 <aavogt> @type [id, (return <=<), (<=< return)]
21:40:20 <lambdabot> forall b (m :: * -> *) a. (Monad m) => [(a -> m b) -> a -> m b]
21:40:20 <pjb3> So you can't actually just say:
21:40:24 <pjb3> f' * g'
21:40:34 <pjb3> in this case
21:40:43 <pumpkin> pjb3: you could if you redefined the (*) operator
21:40:52 <aavogt> in the context of the problem
21:40:58 <pjb3> well, sure, but I'm just trying to follow the example
21:41:18 <pjb3> in the article, and the concept of what * means doesn't seem to be introduced
21:41:50 <pumpkin> "Write this composition as f'*g'"
21:41:55 <pumpkin> that pretty much defines it
21:42:08 <pumpkin> "Given a pair of debuggable functions, f' and g', we can now compose them together to make a new debuggable function bind f' . g'. Write this composition as f'*g'. " is more complete
21:42:17 <pumpkin> which is what soupdragon said earlier
21:42:34 <pjb3> Correct, but when the author says "Write this composition as f' * g'"
21:42:50 <pjb3> He's not implying that I make that happen in ghci
21:43:13 <pjb3> just that when I see that notation used in the article, to apply that meaning
21:43:32 <pumpkin> well, that's fine, but if you want to use his code, you need to define his notation the way he does
21:43:52 <pumpkin> if you're just following along for the concepts, feel free to not write any haskell code
21:43:53 <pjb3> pumpkin: so you think he does imply that I should define the * operator/function?
21:44:02 <pumpkin> yeah
21:44:18 <pjb3> ok, makes sense
21:45:03 <edwardk> woot. the mixed mode ad compiles. forward, reverse, and ad towers, next up hessians
21:45:11 <pumpkin> edwardk: omg
21:45:28 <edwardk> pumpkin: finally figured out all my template haskell woes
21:45:35 <pumpkin> TH for what? :o
21:45:41 * BMeph wonders why he's seeing a pumpkin before midnight...
21:45:54 <pumpkin> BMeph: it was after midnight when I went to bed
21:45:55 <edwardk> pumpkin: to share the code for computing the jacobian between implementations
21:46:11 <copumpkin> edwardk: oh, so you're doing forward too now?
21:46:17 <copumpkin> omg your package name will be misleading!
21:46:23 * BMeph then remembers that midnight is different, in different places...
21:46:31 <edwardk> copumpkin: it'll just be 'ad' if hackage will let me ;)
21:46:42 <copumpkin> aha
21:46:47 <copumpkin> excellent!
21:46:50 <edwardk> otherwise i'll be 'mad' ;)
21:47:07 <copumpkin> next up, an gradient (a/de)scent optimization package
21:47:14 <edwardk> that is already in here
21:47:19 <copumpkin> oh, even better
21:47:52 <edwardk> i actually rather like the new package. let me throw it up on patch-tag, its not _quite_ ready for hackage as it is missing a good half of the API still
21:48:05 <copumpkin> there's worse on hackage :P
21:48:16 <edwardk> yeah but i want to actually get a consistent api first
21:48:23 <copumpkin> yeah, makes sense
21:48:25 * ezyang wonders if a "Baby Hackage" would be useful. 
21:49:24 <BMeph> Hackety-Hackage? ;)
21:49:38 <ezyang> :-)
21:49:41 <edwardk> copumpkin: i should have a nice 'jacobian' implementation soon though, which will compute the first partial derivative using forward mode ad, then check the number of outputs, if the number of outputs is less than the number of inputs, it can switch to reverse mode ad
21:50:19 <edwardk> copumpkin: stuff like that was why i wanted a single unified API, which has required all sorts of craziness including what might be the single ugliest typeclass i've ever written
21:51:33 <pjb3> In my attempt to "Write this composition as f' * g'", I came up with this:
21:51:34 <pjb3> (*) :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String)) -> ((Float,String) -> (Float,String))
21:51:35 <pjb3> f' * g' = bind f' . g'
21:51:44 <edwardk> copumpkin: https://patch-tag.com/r/ekmett/ad/snapshot/current/content/pretty/Numeric/AD/Classes.hs is the fairly tedious bit of template haskell i needed
21:51:49 <pjb3> If I try to use it, I get
21:51:50 <soupdragon> pjb3, delete the first line
21:51:59 <soupdragon> just do  f' * g' = bind f' . g'
21:52:01 <soupdragon> no more
21:52:09 <pjb3> Ambiguous occurrence `*'
21:52:22 <soupdragon> that's because * is multiplication
21:52:24 <aavogt> import Prelude hiding ((*))
21:53:08 <tomberek> edwardk: hey, almost got it... does this make any sense at all?   instance (Functor (m a), Zip f) = Zip (Of f m a)
21:53:15 <edwardk> copumpkin: but it makes each individual mode fairly simple: https://patch-tag.com/r/ekmett/ad/snapshot/current/content/pretty/Numeric/AD/Forward.hs
21:53:46 <pjb3> oh, I thought it would figure out which * I wanted since I'm not calling * with Ints, I'm calling it with functions
21:53:46 <copumpkin> edwardk: oh that (the forward) is quite nice
21:53:47 <aavogt> tomberek: does m really have kind  * -> * -> * ?
21:53:56 <edwardk> tomberek: not immediately
21:53:56 <tomberek> yes
21:54:30 <aavogt> there isn't enough context to see if that makes sense
21:54:35 <edwardk> copumpkin: and about 2/3rds of the code in that Jacobian method is boilerplate
21:54:39 <edwardk> er Jacobian data type
21:54:46 <edwardk> er class or whatever ;)
21:55:05 <tomberek> basically, if a functor can be zipped, so can a functor of pairs
21:55:06 <edwardk> (instance!) obviously i've been awake too long
21:55:34 <edwardk> tomberek: is one of those a bifunctor ?
21:55:39 <tomberek> m
21:55:53 <tomberek> ( a pair  (,) or my Product)
21:56:30 <edwardk> copumpkin: reverse doesn't wind up appreciably worse, actually https://patch-tag.com/r/ekmett/ad/snapshot/current/content/pretty/Numeric/AD/Reverse.hs
21:56:57 <copumpkin> looks neat :)
21:57:02 * copumpkin shudders at all the Num in there though
21:57:11 <copumpkin> but I guess it can't be avoided for now
21:57:14 <edwardk> Om Num Num Num
21:57:52 <edwardk> i tried getting away from it everywhere, but unfortunately unifying my code with the code for a derivative tower required it
21:58:04 <edwardk> since at the least i need the zero of the underlying type
21:59:09 <tomberek> so... no?
21:59:13 <edwardk> copumpkin: next major step i think is providing another module which exposes a constructor for each mode, and lets you say things like diff Forward sin 0 -- or diff Reverse sin 0
21:59:44 <edwardk> tomberek: sorry, not quite parsing the application yet. it makes sense, given a cursory glance but i haven't grasped any deep implications one way or the other
21:59:49 <tomberek> or is this related to Fix?
22:00:04 <copumpkin> you shouldn't need Fix if I understood what you were doing
22:00:12 <tomberek> ok, thanks
22:00:18 <edwardk> (unfortunately i used all the good names for those constructors for the constructors for the underlying modes themselves)
22:00:19 <copumpkin> but it's quite possible that I haven't :)
22:09:45 <tomberek> ok,, how about instance Foldable f => Foldable (Of f (,) a) ?
22:10:18 <BMeph> I see London, I see France...I see conal's log-in dance! :)
22:13:00 <FunctorSalad_> Num Num Num =)
22:13:18 * BMeph thinks it should be "England", or even "Scotland", to match the national status of France. London's big, but it's not (yet?!?) that big....
22:14:45 <tensorpudding> England and Scotland are both a bit smaller than France.
22:16:48 <tomberek> if f is Foldable, shouldn't f (,a) be foldable?
22:18:11 <BMeph> tensorpudding: But they're all nations; London's "just" a city...that's it, I'm suing  whoever makes up those nursery rhymes, mine is obviously defective! >:|
22:18:49 <jeffwheeler> Hmm, cabal installing language-python takes all my memory like nothing I've seen cabal do before, in Language.Python.Version3.Parser.Parser. I'm guessing it runs out of memory, too, because it fails with an ExitFailure 9 that I've never seen before.
22:19:08 <jeffwheeler> I've got 4gb with little else running, so that's pretty impressive.
22:19:10 <djahandarie> jeffwheeler, yes, GHC issue
22:19:22 <jeffwheeler> djahandarie: oh, I guessed it was just huge
22:19:29 <edwardk> BMeph: perhaps it is a matter of perspective. if it was written by someone standing by london on the english channel who could just make out london and just make out the coast of france?
22:19:42 <BMeph> tomberek: (Just being nit-picky, but that's f(a, ) that you have there...) :)
22:19:44 <djahandarie> jeffwheeler, the HEAD is fixed, I think they are working on getting a patch back into the current branch
22:20:06 <tomberek> BMeph,, i'm working with this :instance Foldable f => Foldable (Of f (,) a) where
22:20:19 <jeffwheeler> djahandarie: cool, thanks
22:21:17 <tomberek> can't quite get it to work
22:21:58 <FunctorSalad_> . o O ( go fix my HEAD, create some wealth, ... )
22:22:27 <edwardk> wouldn't instance (Foldable f, Foldable (p a)) => Foldable (Of f p a) be more appropriate?
22:22:41 <Nereid> hmm
22:22:50 <Nereid> so I'm using Yampa (FRP) to write a game
22:22:54 <Nereid> more or less following http://www.haskell.org/yale/papers/haskell-workshop03/index.html
22:23:06 <Nereid> but due to the nature of the game
22:23:15 <Nereid> I require thousands of objects. I wonder how performace would be
22:24:16 <BMeph> Nereid: Fork 'em! Fork 'em right in the processor! ;)
22:24:22 <Nereid> lol
22:26:31 <alexyk> so I have this code reading 3 million strings from tokyo cabinet not much faster than clojure.  Basically it just conses a new one to the list.  Why would it be slow?  http://github.com/alexy/husky/blob/master/TC2.hs
22:27:55 * BMeph gets dizzy trying to figure out which variable is a type variable, and which one is a value, especially when it's the same...glyph
22:28:21 <dmwit> Use dependent types, then there's no confusion.
22:28:23 <alexyk> does it make sense to seq a list accumulating?
22:28:26 <dmwit> Everything is a value and a type variable.
22:28:42 <Nereid> lol
22:28:50 <BMeph> dmwit: 1) It isn't my code; 2) It's still using the same glyph. :(
22:29:16 * BMeph things 'f' is much too popular for its own good
22:29:31 <dmwit> alexyk: Have you profiled it?
22:29:51 <alexyk> dmwit: how do I do that? :)
22:30:05 <BMeph> alexyk: Remember: first, find the problem, _then_ propose the fix... ;)
22:30:06 <dmwit> When compiling, add -prof -auto-all to your command-line.
22:30:18 <alexyk> cool
22:30:19 <dmwit> Then, when running, add +RTS -p to the command-line.
22:30:29 <aavogt> BMeph: because often they are conceptually the same thing
22:30:33 <copumpkin> you might want to insert your own SCCs
22:30:35 <dmwit> +RTS -p -RTS if you want to add parameters after the run-time ones (though you might as well put them before).
22:30:41 <aavogt> like the foo in   data Foo = Foo
22:30:41 <alexyk> copumpkin: you're alive!
22:30:42 <copumpkin> since you don't have many top-level functions
22:30:46 <copumpkin> alexyk: indeed :)
22:30:53 <dmwit> Read the manual when you decide you want more control over the profiling. =)
22:31:17 <dmwit> The relevant chapter: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/profiling.html
22:31:19 <alexyk> copumpkin: why, oh why did you morph into a different timezone?...  you're stuck with those Europeans in speedos now
22:31:23 <BMeph> aavogt: Often, they are...except for when they aren't. ;)
22:31:30 <copumpkin> alexyk: indeed! I'm a dirty european again
22:31:38 <copumpkin> no speedos yet though
22:31:44 <copumpkin> thinking of buying a vespa though ;)
22:31:47 <alexyk> copumpkin: you can get them from Amazon.de
22:31:52 <alexyk> or .fr
22:32:02 <dmwit> copumpkin: Oh, which timezone now?
22:32:13 <alexyk> a vespa and a giant lock
22:32:14 <copumpkin> dmwit: central european :)
22:32:21 <copumpkin> alexyk: oh I'm too badass to get anything stolen
22:32:47 <alexyk> copumpkin: so what's SCCs?
22:32:54 <dmwit> > readIntAtBase 2 isDigit digitToInt "11011110"
22:32:54 <lambdabot>   Not in scope: `readIntAtBase'
22:32:58 <copumpkin> set cost cent(er/re) I believe
22:33:07 <copumpkin> alexyk: they're "profiling spots" that the profiler will measure for you
22:33:11 <copumpkin> you can put them on any expression
22:33:14 <dmwit> > readInt 2 isDigit digitToInt "11011110"
22:33:15 <lambdabot>   [(222,"")]
22:33:19 <dmwit> > chr 222
22:33:20 <lambdabot>   '\222'
22:33:28 <alexyk> ah!  but why is it better that auto-everything?
22:33:32 <copumpkin> the -auto-all that dmwit suggested automatically puts a cost center on every top-level declaration you have, but that doesn't help much
22:33:43 <copumpkin> alexyk: well, you have lots of expressions!
22:33:50 <copumpkin> 5 is an expression
22:33:52 <BMeph> aavogt: You think too conservatively. Try (Monad m) => m () -> (a -> b) -> m a -> m b; m f =...
22:33:56 <copumpkin> (5 +) is one
22:34:01 <copumpkin> and so on
22:34:15 <alexyk> oh boy
22:34:15 <dmwit> -auto-all isn't -auto-everything, that's why =)
22:34:22 <copumpkin> alexyk: so what it does is just stick cost centers on the top-level declarations you have
22:34:39 <copumpkin> if you want them on an inner loop, just add {-# SCC "zomg this is a string I'll see in my profiler" #-}
22:34:47 <dmwit> zomg
22:34:48 <copumpkin> and it'll measure stuff about that
22:34:55 <alexyk> zomg!
22:34:58 <aavogt> what is stuff?
22:35:03 <copumpkin> I'm glad you both understand :)
22:35:15 <alexyk> stuff is stuffy
22:35:20 <copumpkin> aavogt: depends what you ask the profiler to measure
22:35:21 <dmwit> I'm SICK and TIRED of these mutherflippin' STRINGS on this MONDAY-TO-FRIDAY PLANE!
22:35:26 <copumpkin> lol
22:36:45 <aavogt> better than snakes
22:37:07 <alexyk> so far haskell is exactly as fast as clojure...  and is now at 4 GB of RAM, which is better than clojure's 10 or so
22:37:31 <alexyk> but now it has to map a list of strings into JSONb, and it doesn't look good.
22:38:00 <aavogt> you use String here?
22:38:03 <alexyk> so what's the fastest way to serialize a Map of Strings to Map of Strings to Ints to disk?
22:38:20 <aavogt> String is not known for good performance
22:38:30 <alexyk> aavogt: ByteStrings actually
22:38:35 <alexyk> I banished Strings
22:38:44 <alexyk> I should've
22:38:48 <dmwit> Data.Binary is good for serialization.
22:39:07 <ski> tomberek : SYN ACK
22:39:15 <aavogt> does " Map of Strings to Map of Strings to Ints"   mean   Map String (Map String Int)?
22:39:30 <alexyk> after all this struggle to suck a giant blob of json out of a database, I want to serialize it fast and read it back fast.
22:39:44 <dmwit> aavogt: Hard to get a valid type out of any other parse of the English, I think.
22:39:58 <alexyk> aavogt: that's a conversational approx. of ByteString ... :)
22:39:58 <aavogt> dmwit: it could be a function?
22:40:14 <dmwit> Serializing functions is harder.
22:40:24 <alexyk> no functions
22:40:28 <dmwit> But I don't think anybody who knows the word serialization would ask such a question. =P
22:40:31 <aavogt> it's clearer to use the actual syntax of types
22:40:40 <dmwit> I can agree with that, anyway.
22:40:52 <aavogt> dmwit: with support from the runtime you could serialize functions
22:41:02 <dmwit> hm
22:41:15 <Rotaerk> why serialize a function?
22:41:16 <dmwit> Yes, I suppose so. Why not?
22:41:18 <alexyk> copumpkin: so are you up already or what?
22:41:50 <aavogt> Rotaerk: because  (A -> B)  may be more concise / easier to manipulate than   Map A B
22:41:52 * BMeph wishes there were a version of 64-bit IntMaps...for everyone, not just the folks whose machines have time-tested 64-bit compilation toolchains...
22:41:59 <copumpkin> alexyk: indeed :) sleep schedule is all messed up
22:42:27 * ski . o O ( "serialize an `m' where `m ! (s0 :: String) ! (s1 :: String) :: Int'" ? )
22:42:37 <dmwit> aavogt: It seems like there's some weird issues.
22:42:38 <alexyk> copumpkin: see, you'll catch strange East Coast night animals and semi-nocturnal Left Coasters now.  All the family men will be asleep!
22:43:02 <dmwit> What about serializing a function that's closed over a pointer, for example?
22:43:04 <aavogt> dmwit: right, if it was really easy, it would already be done
22:43:11 <alexyk> I'm afraid even to think what kind of deep-water fish shows up here when Europe is awake
22:43:25 <Rotaerk> aavogt, easier how? and how does this imply serialization?
22:43:54 <alexyk> but, a but of overlap does exist
22:44:03 <ski> note that OCaml supports marshalling of functions (with some restrictions)
22:44:22 <copumpkin> ski: how does that work?
22:44:29 <dmwit> Hm, I guess I'm a night animal then. huh
22:44:34 <alexyk> ski: you better not mention ocaml, I'm eyeing it now while my haskell eats the CPU
22:44:53 <alexyk> eyeing with my inner eye that is
22:44:54 <ski> copumpkin : it's built-in to the run-time system. they traverse the reachable parts, just like the GC does
22:45:13 <copumpkin> ah, so it's not serializing code, but just bindings/closures?
22:45:20 <alexyk> "the reachable parts" is a good title or slogan
22:45:26 <alexyk> and a rockband name
22:45:53 <FunctorSalad_> is it good or evil that haskell doesn't have any introspection on function values/closures?
22:45:54 <ski> copumpkin : *and* you're only allowed to read it back into a process running the *same* program, compiled on the *same* architecture (by the *same* compiler, but there's only one)
22:46:02 <copumpkin> ski: I see
22:46:05 <ski> copumpkin : *nod*
22:46:08 <copumpkin> FunctorSalad_: it'd be nice to have in IO
22:46:09 <ski> it's better than nothing
22:46:22 <copumpkin> vacuum might have some of the machinery in it to do that already
22:46:26 <FunctorSalad_> on one of the hands it keeps things conceptually cleaner to not have it, and one could always do metadata explicitly...
22:46:40 <FunctorSalad_> OTOH it would have been practical many times
22:46:45 <Rotaerk> I understand the point of serializing data, but not functions...
22:46:54 <FunctorSalad_> functions can be data
22:46:54 <copumpkin> Rotaerk: why are they different?
22:47:00 <ski> (but you can use this to read back into a later instance of the program .. or another instance on the same machine .. or on another machine (send over network, e.g.))
22:47:16 <copumpkin> Rotaerk: what if I choose to represent my Set a as a -> Bool for some reason?
22:47:17 <FunctorSalad_> data BinaryTree = Node (Bool -> BinaryTree) | Leaf Int
22:47:26 <FunctorSalad_> contrived example
22:48:15 <ski> FunctorSalad_ : i think it might be reasonable to have it in the "warning, GHC-specific internals" section, with warning signs that this can change in the next version
22:48:59 <aavogt> Rotaerk: serializing an application's state
22:49:03 <Rotaerk> a function is a parameterized expression; an expression being an unresolved value... you serialize values, not expressions
22:49:04 <ski> Rotaerk : also to send client code over a network to execute on the server, e.g.
22:49:12 <aavogt> which is most convenient to express as functions
22:49:20 <ski> (i.e. more generally, mobility)
22:49:30 <copumpkin> Rotaerk: because you say so?
22:49:31 <aavogt> it's rather awkward to keep  data and functions separate
22:49:42 <FunctorSalad_> copumpkin, ski : no way to do it in a clean way? from the type-system's POV
22:49:42 <aavogt> (by sticking the functions in a class)
22:50:15 <FunctorSalad_> I suppose one problem is that a function given type doesn't contain any information about the closures "instantiating" it
22:50:18 <ski> FunctorSalad_ : there might be a way, related to code-as-modality or something .. but i don't know it
22:50:40 <FunctorSalad_> so you couldn't have "grabClosureVar 'foo :: (Int -> String) -> Bool"
22:50:44 <Rotaerk> hmm I suppose serializing expressions is possibly useful for distributed computing
22:50:51 <FunctorSalad_> since not all closures have captured a bool....
22:51:09 <copumpkin> Rotaerk: it's also fairly common to transform data to functions
22:51:10 <ski> (and by "code-as-modality" i mean research that relate meta-code that manipulate code to different kinds of modal logics)
22:51:13 <FunctorSalad_> it could be dynamic though
22:51:13 <copumpkin> say, representing a list by a fold over it
22:51:27 <copumpkin> church encoding
22:51:28 <FunctorSalad_> ski: ah. I don't know anything about that :)
22:51:47 <FunctorSalad_> Rotaerk: a function is also a tuple ;)
22:51:52 <alexyk> are there any optimization options to ghc?  would randomly sprinkling seq make it perkier?
22:51:59 <copumpkin> alexyk: -O2 ?
22:52:00 <Rotaerk> FunctorSalad_, howso?
22:52:05 <alexyk> ok...
22:52:09 <ski> @type [('a',False),not]
22:52:09 <lambdabot>     Couldn't match expected type `(Char, Bool)'
22:52:09 <copumpkin> alexyk: usually not, but sometimes
22:52:09 <lambdabot>            against inferred type `Bool -> Bool'
22:52:09 <lambdabot>     In the expression: not
22:52:21 <FunctorSalad_> Rotaerk: Int -> A ~ .... A * A * A * A ....
22:52:35 <FunctorSalad_> you mentioned the intensional view, that it's an expression
22:52:50 <FunctorSalad_> but extensionally a function is just a (possibly-infinite) indexed product
22:53:04 <copumpkin> alexyk: probably best to profile first to figure out what is slow though
22:53:05 <FunctorSalad_> but that's not how you'd want to serialize it ;)
22:53:10 <ski> @djinn (a,a) -> (Bool -> a)
22:53:10 <lambdabot> f (a, b) c =
22:53:11 <lambdabot>     case c of
22:53:11 <lambdabot>     False -> b
22:53:11 <lambdabot>     True -> a
22:53:14 <Rotaerk> hmm
22:53:20 <alexyk> copumpkin: sure, that's tmrw :)
22:53:25 <Rotaerk> what's the ~
22:53:36 <ski> supposed to be "type-isomorphic"
22:53:49 <Rotaerk> oh is-approximately
22:53:51 <FunctorSalad_> yeah. and I'm glossing over the fact that "Int -> A" contains only computable sequences ;)
22:54:21 <copumpkin> @hackage species
22:54:21 <lambdabot> http://hackage.haskell.org/package/species
22:54:30 <FunctorSalad_> but at least in traditional math "Int -> A" can be thought of as just an infinite product
22:54:31 <ski> FunctorSalad_ : from a computable stand-point, you can't exhibit nonconstructive tuples in the latter, either :)
22:54:48 <alexyk> is 6.12 much faster than 6.10?  I could only get 6.10 going in prefix portage for now
22:54:53 <Rotaerk> a function is more generally representable as a set of 2-tuples
22:54:56 <FunctorSalad_> ski: not sure how to make sense of the latter computationally except as the former
22:54:56 <copumpkin> wow, the Species typeclass is fairly large :) and has a C superclass, yay
22:55:05 <copumpkin> byorgey: how did you like working with numeric-prelude?
22:55:20 <Rotaerk> well, no a Map
22:55:22 <ski> FunctorSalad_ : well, there's a theory of choice-sequences that can be applied
22:56:59 <tomberek> hey byorgy
22:57:23 <tomberek> er.. byorgey
22:58:46 <ski> FunctorSalad_ : one axiom of that has as a consequence that for every `phi :: (Natural -> a) -> Bool', `f :: Natural -> a', if `phi f' terminates (with `True' or `False'), then `phi' has only looked at a finite "prefix" of `f' (there's an upper bound of the naturals it has passed to `f' to determine its output), which means that for any other `g :: Natural -> a' sharing the same prefix, `phi f = phi g'
22:59:51 <FunctorSalad_> ski: I've heard of that informally :)
23:00:01 <ski> here `Natural -> a' is more or less the same as `Stream a' (defined by `data Stream a = Cons {head :: a,tail :: Stream a}' (where `data' really being `codata'))
23:00:24 <FunctorSalad_> why not ordinary function space?
23:00:35 <ski> sorry ?
23:00:54 <FunctorSalad_> I mean that "Natural -> a" is already defined, why use Stream instead?
23:01:13 <ski> `Stream a' was just a comparision
23:01:20 <ski> (to better explain what "prefix" meant)
23:01:43 * BMeph gets annoyed that there's a perfectly good, non-negative Integral type...that is NOT used for list indices...
23:01:56 <copumpkin> BMeph: indeed
23:01:59 <ski> which ?
23:02:01 <copumpkin> I hate Int
23:02:08 <BMeph> ski: Word
23:02:13 <copumpkin> it wasn't in h98
23:02:21 <copumpkin> which is supposedly the reason, but fuck h98
23:02:22 <ski> > succ (maxBound :: Word)
23:02:23 <lambdabot>   *Exception: Enum.succ{Word}: tried to take `succ' of maxBound
23:02:30 <copumpkin> ski: Int is already bounded in the same way
23:02:34 <BMeph> ski: Int's red-headed step-child (no relation to Neil Mitchell, though...;)
23:02:35 <ski> yes, i know
23:02:38 <copumpkin> a Natural type would be even better
23:02:40 <ski> (and that's bad too, imo)
23:02:48 <copumpkin> I started a binding to gmp naturals
23:02:53 <ski> for some applications, `Word' would be ok
23:02:55 <copumpkin> it wouldn't take much to finish it
23:03:01 <FunctorSalad_> > (-1) :: Word
23:03:02 <lambdabot>   18446744073709551615
23:03:11 <FunctorSalad_> not sure what errors that would catch statically, BMeph
23:03:22 <ski> but for counting in potentially-infinite ephemeral/transient lists, a proper `Natural' is neede
23:03:25 <ski> d
23:03:27 <aavogt> is a gmp natural more or less Integer?
23:03:37 <ski> i'd assume so
23:03:38 <BMeph> FunctorSalad_: Don't blame me for passive-aggressive GHC coders... :)
23:03:41 <copumpkin> aavogt: Integer is a fairly thin wrapper on top of a natural
23:03:45 <copumpkin> aavogt: on the gmp side of things though
23:03:53 <copumpkin> so the Integer in ghc is a binding to the gmp integer
23:04:14 <copumpkin> gmp naturals only recently got separated out nicely in the gmp api
23:04:17 <aavogt> so there's much overhead in an extra bit for some sign?
23:04:42 <copumpkin> aavogt: nope, but it's cleaner to have a binding to a type that can't represent negative numbers
23:04:45 <tomberek> ski, howdy
23:04:47 <aavogt> or is it more about making sure that your intermediate values aren't negative?
23:04:56 <copumpkin> aavogt: and many functions make way more sense on naturals than integers
23:05:03 <ski> tomberek : you wanted something, yesterday ?
23:05:21 <FunctorSalad_> so does it just runtime zomg fail when you do 0-1?
23:05:32 <FunctorSalad_> or truncate, which I'd consider worse
23:05:37 <tomberek> oh,, that i finally had a full understanding why a list was needed, not just a bag for the initial you talked about
23:05:42 <ski> @type genericLength
23:05:43 <lambdabot> forall b i. (Num i) => [b] -> i
23:05:52 <ski> @type genericSplitAt
23:05:53 <lambdabot> forall i b. (Integral i) => i -> [b] -> ([b], [b])
23:06:38 <BMeph> Another numeric failing I like to gripe about: Gaussians!
23:06:39 <ski> imo, these should be `length' and `splitAt',&c. in `Prelude' (or only `Data.List' if you prefer)
23:06:57 <ski> BMeph : what about Eisensteinians ?
23:07:03 <FunctorSalad_> > (1::Int) :+ 2
23:07:04 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
23:07:04 <lambdabot>    arising from a use o...
23:07:09 <FunctorSalad_> :o
23:07:13 <FunctorSalad_> oh no
23:07:17 <ski> @src Complex
23:07:17 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
23:07:25 <FunctorSalad_> weird
23:07:34 <ski> datatype constraints strike again !
23:07:40 <FunctorSalad_> my thought too
23:08:05 <BMeph> ski: They're representable, if a little ragged; Floating allows square roots, after all.
23:08:12 <ski> (.. me being a bit unfair there, since this is not about the specific failing of it, just a bad/unwanted declaration)
23:09:18 <edwardk> meh, an hour spent chasing down a precedence bug. (forgot to add a bunch of fixity decls)
23:09:19 <BMeph> Premature optimisation Strikes again! :(
23:09:37 <FunctorSalad_> it optimizes anything?
23:10:22 <ski> BMeph : i'd probably want to represent then as `data Eisensteinian a = MkEisensteinian a a a' where either we go with normal/canonical forms, so at least one of the three components must be `0' at all times, or we only do normalizations lazily, as needed
23:10:27 <BMeph> FunctorSalad_: I meant that Complex declaration. ;
23:10:33 <FunctorSalad_> BMeph: me too
23:10:45 <ski> BMeph : .. so, i'm not sure how square roots enter the picture ..
23:10:59 <FunctorSalad_> but what optmization does that constraint allow...?
23:11:36 * ski wonders when GHC will fix the handling of datatype constraints (not only on GADTs)
23:11:45 <BMeph> ski: By using a view on the current form, so you can have Eisensteinian forms as wanted.
23:12:04 <soupdragon> why is MkEisensteinian a triple?
23:12:17 <edwardk> FunctorSalad_: it'd be kind of nice to kill that rather useless RealFloat constraint on Complex since it doesn't actually add any value and is more of a holdover from when people thought that was how they'd implement these things
23:12:18 <ski> BMeph : oh, you meant reusing `Complex Double' or whatever ..
23:12:26 <BMeph> FunctorSalad_: Trig functions with Complex numbers.
23:12:37 <ski> soupdragon : simplest representation .. usually `a' there would be `Natural'
23:12:58 <FunctorSalad_> BMeph: you get those anyway as long as you make it "RealFrac a => RealFrac (Complex a)"
23:13:01 <ski> (well, simplest representation *i* know of)
23:13:15 <BMeph> ski: MkE a b q, right? :)
23:13:15 <soupdragon> I would have just gone with x + wy
23:13:20 <soupdragon> what's wrong with that?
23:13:35 <soupdragon> oho wait
23:13:38 <soupdragon> I didn't see this 'at least one of the three components must be `0' at all times'
23:13:48 <soupdragon> that makes sense now
23:14:13 <soupdragon> so it's basically selecting a triangular region to be on
23:14:15 * BMeph is confused now...
23:14:53 <ski> BMeph : say that `epsilon' represents `(- 1 + i * sqrt 3) / 2, then `MkEisensteinian a b c' represents `a + b * epsilon + c * epsilon^2'
23:14:54 <edwardk> Complex would be better as a class than as a data type, i can't do everything i want with automatic differentiation of complex analytic functions as it stands now
23:15:42 <ski> soupdragon : yes .. i first didn't think of allowing `a' to be `Integer' .. in that case, we also need that all three components must be non-negative
23:16:04 <BMeph> FunctorSalad_: I imagine that the "optimization" was making it so that you didn't have to explicitly make that Complex declaration.
23:16:36 <ski> BMeph : so, the *point*, just like with the gaussian *integers*, is to only represent the eisensteinian *integers*
23:16:53 <ski> BMeph : now, what did you mean by `MkE a b q' ?
23:18:24 <BMeph> ski: I don't know now. I think I weas leaping ahead to an algebraic rep instead.
23:18:50 <ski> BMeph : so `a + b * sqrt q' for some `q' ?
23:19:03 <ski> (`a' and `b' being integers)
23:20:07 <ski> btw, i wonder whether having a constraint on a `data' type with no constructors would fit into a fixed constraints-on-(non-GADT)-`data`-types feature
23:20:24 <sinelaw> hi
23:21:20 <FunctorSalad_> edwardk: is anything forcing you to make the complex analytic function type use the `Complex' type?
23:21:30 <BMeph> Integral Void where {}
23:22:51 <aavogt> you can drop the where there
23:23:14 <ski>   where fromInteger = error "sorry !"
23:23:43 * BMeph gives ski a No-Prize!
23:23:47 <ski> (well, ok, that's in `Num' actually)
23:24:07 * ski no-accepts the no-prize, and no-bows deeply
23:25:00 <ski> tomberek : ah, ok. nice :)
23:25:11 <tomberek> huh?
23:25:12 <tomberek> oh
23:26:43 <soupdragon> http://mathworld.wolfram.com/EisensteinInteger.html <-- cool
23:27:36 <soupdragon> nice to compare with http://mathworld.wolfram.com/Fermats4nPlus1Theorem.html
23:27:37 <tomberek> maybe you can help me,  instance (Functor (m a),Zip f) => Zip (Of f m a) where
23:29:14 <soupdragon> The characterization by Dörrie is nice too
23:29:27 <soupdragon> reminds me of staring at the axioms of quaternions thinking wtf
23:33:58 <Nereid> @hoogle (c -> d) -> (a -> b -> c) -> a -> b -> d
23:33:58 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
23:33:58 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
23:33:58 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
23:34:05 <Nereid> nope.
23:34:21 <Nereid> but yeah I guess I could just use
23:34:27 <Nereid> :t \x -> ((x .) .)
23:34:28 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
23:34:29 <edwardk> FunctorSalad_: well, ideally things like realPart would be able to go from AD s (Complex a) -> AD s a
23:34:32 <Nereid> guhhh
23:34:45 <edwardk> Complex (AD s a) -> AD s a -- is all I can express at the moment
23:35:25 <Nereid> hmm
23:35:34 <edwardk> FunctorSalad_: i'm exploring options of just making a nicer Numeric.Complex or something that does the right thing, but as usual what the right thing is, is somewhat nebulous
23:35:38 <Nereid> I wonder if there are things like (..) = (.).(.), (...) = (.).(.).(.), and so on
23:35:42 <Nereid> there should be.
23:35:49 <soupdragon> is there a haskell library that can print out SVG files?
23:36:01 <aavogt> produce them, soupdragon?
23:36:03 <soupdragon> i mean like it outputs the SVG text
23:36:04 <tomberek> hey edwardk, i'm still stuck on that instance of Zip
23:36:19 <aavogt> soupdragon: there's Cairo from gtk2hs
23:36:30 <soupdragon> yeah I have not managed to install cairo or gtk
23:36:31 <aavogt> a nice higher-level wrapper of that is diagrams
23:36:37 <edwardk> why do you think it is zippable?
23:36:47 <soupdragon> I tried installing this stuff with fink and then cabal and it just isn't working
23:37:10 <aavogt> I dunno how to get gtk2hs for OSX
23:37:16 <aavogt> surely it's been done before
23:37:30 <soupdragon> yeah I haven't been able to get any linux to boot and haskell doesn't work in the VM
23:37:34 <soupdragon> so I am pretty screwed
23:37:35 <tomberek> edwardk: if you have a Zippable,, surely you can Zip a Zippable of Functors?
23:38:23 <edwardk> tomberek: surely is a weasel word, motivate it. ;) what does the type of zip look like there
23:38:47 <edwardk> (honest curiosity, i haven't yet tried to solve this one way or the other)
23:39:00 <tomberek> it's the Of f m a b
23:39:10 <tomberek> so instance (Functor (m a),Zip f) => Zip (Of f m a) where... i think
23:39:13 <BMeph> Nereid: I believe, (.).(.) is (one of) (.:)'s definition(s).
23:39:23 <Nereid> :t (.:)
23:39:23 <lambdabot> Not in scope: `.:'
23:39:27 <Nereid> hmm
23:39:30 <edwardk> installing category-extras to check
23:40:32 <tomberek> wait,,, you don't have your own package installed?
23:41:01 <edwardk> tomberek: i just reinstalled ghc about 3 hours ago ;)
23:41:11 <ski> @let (.:) = (.) . (.); (.::) = (.:) . (.); (.:::) = (.::) . (.)
23:41:12 <lambdabot>  Defined.
23:41:15 <tomberek> oh, ok, forgiven...hehehe
23:41:18 <edwardk> needed 6.12.1 to make the ad library happy
23:41:38 <copumpkin> what was wrong with 6.10?
23:42:11 <Nereid> :t (.:)
23:42:12 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
23:42:20 <Nereid> heh
23:43:00 <edwardk> tomberek: it doesn't work
23:43:05 <edwardk> you need at least Zip (m a) as well
23:43:06 <ski> @type \g f a b -> (g .: f) a b
23:43:06 <lambdabot> forall a b t t1. (Functor ((->) t), Functor ((->) t1)) => (a -> b) -> (t -> t1 -> a) -> t -> t1 -> b
23:43:13 <ski> @type \g f a b c -> (g .:: f) a b c
23:43:14 <lambdabot> forall a b t t1 t2. (Functor ((->) t), Functor ((->) t1), Functor ((->) t2)) => (a -> b) -> (t -> t1 -> t2 -> a) -> t -> t1 -> t2 -> b
23:43:17 <edwardk> or BiZip m
23:43:18 <tomberek> edward k,,, ok, let's Zip (m a)
23:43:33 <edwardk> really what you want
23:43:45 <ski> tomberek : @src Of
23:43:51 <Nereid> (.::) = fmap fmap (fmap fmap fmap)
23:43:52 <Nereid> :(
23:44:03 <tomberek> BiZip sounds right, cause m is going to be the Product idea
23:44:04 <edwardk> instance (Zip f, Bizip p) => Bizip (Of f p) -- is what you really want
23:44:09 <Nereid> but of course (.) = fmap
23:44:12 <ski> Nereid : blame Caleskell :)
23:44:15 <Nereid> :)
23:44:23 <tomberek> ski:  newtype Of f p a b = Of f (p a b)
23:44:34 <ski> ok, so `Of' is `(.:)'
23:44:39 <ski> (on the type level)
23:45:08 <copumpkin> hmm
23:45:11 <copumpkin> it is?
23:45:27 <copumpkin> is there missing () there?
23:45:34 <ski> yes, `(g .: f) a b = g (f a b)
23:45:52 <ski> copumpkin : yes, the rhs should have one more bracket pair, otherwise it's illegal
23:46:01 <copumpkin> ok :)
23:46:06 <ski>   newtype Of f p a b = Of (f (p a b))
23:46:12 <BMeph> newtype Of f p a b = Of { runOf :: f (p a b) }
23:46:16 <tomberek> edwardk: so far: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25906#a25906
23:46:21 <edwardk> tomberek: bizip ~ fzipWith bizip -- you just need to get the newtypes in there
23:46:46 <tomberek> hm...
23:47:02 <ski>   Of :: forall_kind k0 k1 k2 k. (k2 -> k) -> (k0 -> k1 -> k2) -> (k0 -> k1 -> k)  -- what we'd want
23:47:05 <edwardk> fzipWith bizip :: (Bizip p, Zip f) =>f (p a c) -> f (p b d) -> f (p (a, b) (c, d))
23:47:26 <edwardk> so you just have to rip off the Of's and put it back on at the end
23:48:09 <edwardk> bizip (Of a) (Of b) = Of (fzipWith bizip a b)
23:48:35 <edwardk> does that give you what you want?
23:48:44 <soupdragon> http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fpackage&as_q=SVG
23:48:51 <soupdragon> A whole list of them but not sure any of them actually do it
23:48:57 <soupdragon> maybe I should just program in postscript
23:48:59 <edwardk> if you think about it, it can only be bizippable, because you need to know what to do with the other side of the bifunctor
23:49:05 <soupdragon> but I don't know if it has floats
23:49:15 <tomberek> edwardk: i'll check
23:49:35 <edwardk> there should be a similar construction for Biff and On as well
23:49:59 <tomberek> it compiles
23:50:07 * ski idly wonders whether there's a `Boff' type constructor
23:50:17 <edwardk> (i.e. bizipWith fzip fzip)
23:50:20 <ski> (`On' : `Of' :: `Biff' : `Boff')
23:50:26 <tomberek> well,, i still need Zip
23:50:35 <edwardk> tomberek: you can't have it ;)
23:50:43 <tomberek> i'm trying an operation and it says...     No instance for (Zip (Of [] (,) Int))
23:50:45 <edwardk> the types say no
23:51:24 <tomberek>    arising from a use of `sink' at <interactive>:1:0-5  Possible fix: add an instance declaration for (Zip (Of [] (,) Int))
23:52:12 <edwardk> Biff p f g a b = p (f a) (g b) -- Of (f (p a b)) -- is the flopped around version, no place for the extra arg, so Boff collapses to Of
23:53:04 <BMeph> instance (Zip f, Zip (p a)) => Zip (Of f p a) where	fzipWith f = Of . fzipWith (fzipWith f) . runOf
23:53:16 <BMeph> (comments in the module)
23:53:19 <tomberek> oooh, let's try it!
23:53:50 <edwardk> BMeph: *twitch*
23:54:38 <tomberek> BMeph.. hm... couldn't match types
23:55:05 <BMeph> Well, it's almost midnight here, so good night... :)
23:55:58 <jaspervdj> What is the time complexity for pattern matches? Is it optimized to O(log n) or O(1) in certain cases?
23:56:39 <ski> it should be `O(1)', modulo uses of guards, pattern guards, view patterns, and numeric literals
23:56:49 <edwardk> jaspervdj: they desugar down to simpler cases in core. the complexity of a case dispatch in core is O(1), so its the question of how many primitive case's are required
23:57:11 <ski> (this is assuming the pattern is given .. obviously in general it depends on the size of the pattern, as well)
23:57:14 <edwardk> jaspervdj: (of course that is counting the computation of the actual result as O(1))
23:57:16 <copumpkin> so if I write a function with a few thousand constant string matches
23:57:20 <copumpkin> will it get compiled into a trie?
23:57:27 <copumpkin> (assuming GHC doesn't die with all the constant data in the source file)
23:58:09 <edwardk> copumpkin: quite possibly, if you don't have any |'s floating around forcing relative orderings, etc.
23:58:35 <copumpkin> yeah, just f "edwardk" = (); f "copumpkin = error "wtf" and so on
23:59:25 <soupdragon> http://tilings.math.uni-bielefeld.de/Files/Can_subst_1_rule.gif
23:59:26 <tomberek> copumpkin, that would be interesting
23:59:27 <soupdragon> I don't get ths
23:59:31 <edwardk> ultimately it'd turn into a series of nested case statements
23:59:55 <soupdragon> I wonder what it means
